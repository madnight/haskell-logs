00:00:59 <solrize> edwark that page is not loading
00:00:59 <edwardk> (the 'quantification' bit being my er, abuse, of newtype ForAll f = ForAll { runForAll :: forall a. f a }
00:01:14 <edwardk> solrize: i think my pretty printer is sucking ass =)
00:02:21 <edwardk> that happens to be the longest page i've tried running through it. text-vimcolor seems to not scale
00:03:00 <solrize> "Even if GADTs are expressive enough to develop all proofs of interest, there is a risk that they will become the
00:03:00 <solrize> C++ Template Metaprogramming of functional languages."
00:06:01 <edwardk> there, i disabled the syntax highlighting stuff, that seems to have helped. try again?
00:06:18 <dons> C++ templates were an accident
00:06:30 <solrize> edwardk, it works now
00:06:42 <dons> i guess languages are either criticised, or used by no one.
00:06:51 <dons> so this is a good thing
00:06:55 <dons> concepts are in people's heads
00:08:29 <solrize> edward i don't know enough theory to comment on that article other than that the page loads now
00:08:37 <edwardk> sol: =)
00:10:07 <edwardk> now i need to find a new highlighter, preferrably one javascript based, coz the vim one, well, it apparently doesn't like dozens of small code snippets
00:10:24 <solrize> dons (re erlang) i haven't heard of anyone implementing erlang-like concurrency into haskell (transparent use of shared structure or copying for message passing, possible separate gc's per process, transparent serialization to remote machines etc)
00:10:43 <solrize> i guess it's doable in principle
00:10:55 <taruti> solrize: it is hard.
00:11:01 <solrize> i heard of someone running an erlang test with 20 million threads
00:11:02 <julz> hm, seems nobody can help me :-(
00:11:22 <taruti> solrize: just a subset of Haskell data can be serialized (in GHC).
00:12:00 <solrize> julz i remember looking at that earlier and not being familiar with external stuff it uses
00:12:07 <dons> solrize: there's no distribution, really
00:12:16 <dons> but "erlang-like concurrency" is not well defined
00:12:50 <dons> let's see what ulf wiger says
00:12:58 <dons> he'd know. http://ulf.wiger.net/weblog/2008/02/06/what-is-erlang-style-concurrency/
00:13:00 <lambdabot> Title: 9 Ulf Wiger 5f » What is Erlang-Style Concurrency?, http://tinyurl.com/2knzhv
00:13:08 <solrize> i think it means, no shared data in the language semantics though it can be used in the implementation under the hood
00:13:16 <dons> "I would suggest that ability to support selective message reception is sufficient for Erlang-style concurrency. It can be done either by matching on a single message queue (Erlang, OSE Delta), or by using different mailboxes/channels (Haskell"
00:13:46 <solrize> also the thing with supervision trees for restarting crashed processes
00:13:57 <julz> solrize: me either but thanks anyway ;-)
00:14:04 <dons> supervision is complete separate, and not part of the concurrency mechanisms
00:14:10 <dons> its a small matter of libraries :)
00:14:30 <dons> "copying" is fine too, purely functional stuff tends to act that way
00:14:53 <dons> ulf's article is really interesting, and maybe authoritative on the terminology
00:14:56 <taruti> doing supervision for Haskell is quite doable.
00:15:09 <taruti> and so is passing polymorphic messages via single channel.
00:15:26 <dons> ulf says some good things, "You to use Haskellre right in noting that Erlang may not be ideal for large data processing. The main problem may not be the concurrency model, but rather dynamic typing, which gives the compiler less information to work with. I think Haskell may have much better potential in this area,"
00:15:30 <taruti> distribution & hot code updates are hard.
00:16:05 <dons> we've some hot update solutions, but distribution is very primitive
00:16:09 <solrize> i wonder what happened to the happs multimaster stuff, it that helps
00:16:27 <dons> shared memory multicore boxes though, haskell's doing well on this most common of archs :)
00:16:38 <dons> the new parallel GC will land soon as well
00:16:43 <dons> so your cores won't be idle while GC is happening
00:16:46 <taruti> solrize: if you happen to need it I have some of the process stuff for erlang style things sitting around.
00:17:01 <dons> matthew_-'s done a fair bit on that too
00:17:18 <dons> though Chans and MVars seem to do the job for an awful lot of casees
00:17:32 <dons> solrize: so when are you going to upload some code to hackage.haskell.org ?
00:17:36 <taruti> (polymorphic message passing is done via a hlist of handlers + automatic conversion to a union type by a typeclass without needing to define new instances..
00:17:40 <solrize> taruti, hmm, i want to get armstrong's book about erlang, i'm actually pretty suspicious of the "let it crash" aspect
00:17:42 <dons> #haskell questions aren't free, you know :)
00:17:47 <solrize> dons, what was i supposed to be hackign?  :)
00:17:50 <solrize> hacking
00:17:56 <dons> something useful!
00:18:03 <solrize> hah, in haskell?  :)
00:18:10 <taruti> solrize: the let it crash actually works quite well in erlang.
00:18:12 <dons> well, what are you waiting for?
00:18:19 <dons> there's 497 libraries on hackage.haskell.org
00:18:32 <dons> if you're quick, i.e. next 12 hours, you could make number 500.
00:18:38 <lispy> haha
00:18:42 * solrize not likely to be that quick
00:18:49 <lispy> better hurry, this offer won't last long :)
00:18:49 <dons> i should do a little announcment when 500 arrives
00:19:06 <dons> since that's really an awesome milestone, given hackage is only just 14 months old
00:19:12 <solrize> that IS impressive
00:19:22 <solrize> i'd like to write a tls stack
00:19:54 * lispy wonders what percent of open source haskell libraries end up on hackage
00:19:57 <solrize> i had a more grandiose plan a few days ago (it involved a lot of sorting) but i think the urgency of that has diminished a bit
00:20:01 <dons> i think hsgnutls has tls
00:20:14 <dons> http://www.cs.helsinki.fi/u/ekarttun/hsgnutls/
00:20:16 <lambdabot> Title: hsgnutls
00:20:18 <solrize> i mean WRITE A TLS STACK not wrap some core dumping C library
00:20:28 <dons> even better
00:20:37 <dons> life's short. when is the upload?
00:20:56 <dons> gwern: needs to be on hackage, http://www.cs.helsinki.fi/u/ekarttun/hsgnutls/
00:20:57 <lambdabot> Title: hsgnutls
00:20:57 <taruti> solrize: you might want to start writing a free (BSD licensed) public key crypto api in Haskell for a start :)
00:20:58 <lispy> solrize: hey, not all C code dumps core.  Some of it runs on windows and the stuff ghc produces shouldn't be dumping core unless you're using unsafe* :)
00:21:21 <dons> its so sad musasabi got sick, he was churning out network code for haskell at a prodigious rate
00:21:30 <solrize> http://trevp.net/tlslite (not written by me but i figure i'd more or less imitate this) <--- run under haskell/python bridge :)
00:21:31 <lambdabot> Title: TLS Lite
00:22:05 <lispy> solrize: you could do me a huge favor and write some static analysis tools for python in haskell :)
00:22:12 <solrize> haha
00:22:44 <solrize> taruti, i started writing a crypto API last week and immediately got into a huge argument with ppl here about whether the encryption function should be in the IO monad :)
00:23:17 <lispy> why should it be in IO?
00:23:20 <sjanssen> is encryption not a pure function?
00:23:43 <solrize> semantically secure encryption has to be impure
00:23:46 <lispy> (doesn't everything run inside of IO anyway...eg., main)
00:24:12 <solrize> i'm trying to figure out if there's a way to put it in ST instead sort of like data.unique
00:24:14 <sjanssen> solrize: ah, for random numbers, eh?
00:24:16 <lispy> solrize: why is that? (I'm trying to understand)
00:24:17 <solrize> sjanssen yes
00:24:41 <solrize> lispy: if you encrypt the same string twice you have to get two distinct answers
00:24:53 <solrize> referential opaqueness instead of transparency :)
00:24:55 <lispy> Hmm...Couldn't you just accept a randomgen to pure code and then get the random generator from IO before you enter the pure code?
00:25:13 <solrize> lispy that would allow you to use the same randomgen twice
00:25:23 <solrize> this is the exact same argument i had last week i think
00:26:08 <lispy> well, either way, IO is a standard part of the language.  Use it if you need it.
00:26:20 <solrize> yeah, it just seems kind of ugly to have to do it that way
00:26:21 <lispy> I'm just hoping to understand why it's needed.
00:26:40 <solrize> you mean why you have to get two different answers?
00:26:50 <sjanssen> solrize: I'd offer two suites of functions
00:26:56 <solrize> so the eavesdropper can't tell that you've sent the same message twice
00:27:02 <sjanssen> functions of type RandomGen -> Input -> Output
00:27:09 <sjanssen> and functions of type Input -> IO Output
00:27:26 <lispy> You could also represent things using an existential type, ala ST monad
00:27:43 <lispy> then I think you could prevent the same randomgen from being used twice
00:28:05 <solrize> sjanssen i guess maybe haskell programmers are different, but when i've supported this type of library in java or python, people REALLY want to be able to say "encrypt(string)" and have all the right stuff happen out of sight without their thinking about it further
00:28:05 <lispy> Actually, scratch that.  I think it works the other way.
00:28:22 <solrize> yeah it's reasonable to have additional, pure functions
00:28:23 <sjanssen> solrize: exactly, that is what the second suite is for
00:28:53 <dons> the IO one would be convenient, just not as flexible
00:29:21 <dons> and if you can come up with a purely functional interface, that offers maximum power (full rollback to previous states, easy parallelisation, etc)
00:29:25 <dons> so much the better
00:29:35 <solrize> noooooooo   rollback to previous states = BAD BAD BAD
00:29:46 * sjanssen is amazed dons hasn't pointed out that the pure API is better for quickcheck :)
00:29:52 <dons> right
00:29:53 <lispy> dons: but, I don't think you can in this case.  Since you really want the answer to be different each time.  So you break equational reasoning.
00:29:59 <dons> you can't test it if it's not pure
00:30:15 <solrize> well you could import a randomgen into IO ...
00:30:15 <dons> lispy: you might want to throw back to previous generator states ?
00:30:27 <dons> and regenerate a sequence from the same state
00:30:28 <taruti> solrize: if you are struct with the crypto thing maybe do a decent random number thing that can be used for crypto first?
00:30:41 <solrize> taruti i don't understand that question
00:30:47 <dons> sjanssen: why isn't XMonad.Operations.hs pure?
00:30:47 <lispy> dons: Well, I agree on a pure interface if you caputure all the inputs, like the random gen/seed :)
00:30:51 <dons> who can i blame?
00:30:56 <wli> I'm more concerned with sparse matrices at the moment.
00:30:59 <taruti> solrize: for secure crypto you need good random numbers.
00:31:07 <solrize> right
00:31:09 <wli> Sparse vectors, too.
00:31:14 <sjanssen> dons: which part of it?
00:31:16 <taruti> and System.Random is not cryptographically good iirc.
00:31:24 <solrize> right, get random numbers from /dev/urandom
00:31:26 <solrize> i.e. IO
00:31:28 <dons> sjanssen: all of it? :)
00:31:35 <lispy> isn't System.Random also really slow?
00:31:35 <dons> what were we thinking!
00:31:44 <dons> lispy: compared to mersenne-random, yeah
00:31:47 <sjanssen> well, most of the code is actualy stateful
00:31:50 <dons> and the (new!) pure mersenne-random
00:31:52 <dons> which also rocks
00:32:02 <sjanssen> Opertions.hs has almost all of our X grunt work
00:32:04 * dons should release int-e's magic refactorings
00:32:09 <solrize> mersenne is not what a cryppie would call a serious rng
00:32:14 <dons> sjanssen: there's a lot of logic in that code though
00:32:16 <dons> solrize: indeed.
00:32:35 <dons> solrize: there a big warnings. great for QuickCheck data generation though -- good distribution
00:32:37 <solrize> there should be a pure RNG based on AES, that would support splitting provably (based on the well tested AES security criteria)
00:32:53 <solrize> actually i think i know enough to write that
00:32:56 <dons> that would be a research paper, if you can prove splitting is sound
00:32:58 <solrize> so maybe it could be upload #500
00:33:10 <solrize> dons it wouldn't be a research paper it would be pretty trivial
00:33:35 <sjanssen> dons: yeah, I've known for a while that there are StackSet primitives waiting to be split out, but thats a bit annoying to do
00:33:36 <dons> a purely functional generator, that provably supports splitting, and had good performance?
00:33:47 <Adamant> is there a need for a good CSPRNG for Haskell like a Fortuna implimentation?
00:33:50 <wli> sjanssen: What's a StackSet?
00:33:58 <solrize> dons "good performance" is in the eye of the beholder but yes to the other stuff
00:34:01 <sjanssen> wli: xmonad data structure
00:34:10 <dons> solrize: for what its worth, the System.Random is not known to have sound splitting, and cites only 2 papers, where the topic is explored only lightly
00:34:15 <solrize> adamant, fortuna is really intended for stirring physical entropy into an rng, not pure functionality
00:34:26 <solrize> dons they are reading the wrong papers they need to read some cryptography stuff
00:34:30 <solrize> here is a good url
00:34:34 <solrize> sec
00:34:48 <solrize> http://www-cse.ucsd.edu/~mihir/cse207/classnotes.html  explains how to do those proofs
00:34:49 <lambdabot> Title:
00:34:52 <dons> this might be a particular issue with purely functional generators
00:35:13 <dons> "   -- |The 'split' operation allows one to obtain two distinct random number
00:35:13 <dons>    -- generators. This is very useful in functional programs (for example, when
00:35:13 <dons>    -- passing a random number generator down to recursive calls), but very
00:35:13 <dons>    -- little work has been done on statistically robust implementations of
00:35:13 <dons>    -- 'split' (["System.Random\#Burton", "System.Random\#Hellekalek"]
00:35:15 <edward1> splitting is hard
00:35:16 <dons>    -- are the only examples we know of"
00:35:27 <solrize> dons unless i completely misunderstand the problem i just don't think there is a problem
00:35:38 <RyanT5000> what library should I use to save PNGs?
00:35:49 <dons> you take one generator, you split it into two, that are unrelated.
00:36:09 <lispy> RyanT5000: I'd look on hackage if i were you
00:36:29 <solrize> yes correct, the proof would go something like: showing any relationship between the split pairs would break the hypothesis that AES is undistinguishable from a random permutation
00:36:42 <lispy> RyanT5000: out of 497 libraries, one of them must do pngs :)
00:36:50 <solrize> the thing is, the RNG's that statististicians and numerical types use aren't anything like cryptographic RNG's
00:36:59 <solrize> but the crypto stuff is slower, i suppose
00:37:16 <Adamant> right
00:38:22 <RyanT5000> lispy: I can't even find an image manipulation library on there, other than SDL-image
00:38:52 <lispy> I see
00:39:37 <solrize> there might be some faster way to do it based on universal hashing
00:39:40 <solrize> hmm
00:39:44 <solrize> i'll think about that
00:40:29 <solrize> > 663 / 16
00:40:33 <lambdabot>  41.4375
00:40:47 <solrize> mersenne might be an OOM faster than AES
00:40:55 <solrize> but what programs really spend much of their time generating random numbers?
00:41:12 <lispy> RyanT5000: what about this: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Imlib-0.1.1
00:41:14 <lambdabot> http://tinyurl.com/3xkrk9
00:42:17 <RyanT5000> lispy: ah; that might work
00:42:35 <RyanT5000> i didn't realize that "imlib" was image-related :P
00:42:39 <solrize> http://www.anythingbutipod.com/archives/2006/11/sandisk-sansa-c200-disassembled.php  here is the hardware i want to run my crypto API on :)
00:42:40 <lambdabot> Title: SanDisk Sansa c200 Disassembled, http://tinyurl.com/t47n5
00:42:48 <solrize> i got three of them for 15 USD each from woot.com
00:44:06 <lispy> dons: You know what would be cool.
00:44:20 <lispy> dons: packages that provide tests should show hpc statistics on hackage.
00:44:30 <dons> yeah
00:44:34 <dons> that's a *huge* todo
00:44:38 <lispy> dons: and we should give non-tangible rewards for projects that attain a high level of testing
00:44:43 <dons> kick some heads about who's not writing tests
00:44:44 <lispy> oh okay
00:44:54 <dons> QuickCheck or Die!
00:45:02 <lispy> rewards for testers, not punishments for non-testers!
00:45:24 <dons> ok. QuickCheck and 1000 virgins will await you
00:45:30 <lispy> hah!
00:45:36 * lispy starts writing tests
00:45:41 <RyanT5000> are there debs for 6.8.2?
00:45:44 <wli> What if you don't like virgins?
00:45:58 <lispy> RyanT5000: in unstable, but I don't tihnk tehy made it to testing yet
00:45:58 <RyanT5000> or a repo
00:46:11 <RyanT5000> lispy: how about 6.8?
00:46:38 <lispy> I don't know about 6.8, but I did install 6.8.2 from a deb on debian/unstable x86_64
00:46:49 <RyanT5000> ah ok
00:47:25 <lispy> RyanT5000: but, people tell me, building ghc is pretty easy these days, not real reason not to just build it and install it in your homedir
00:47:33 <RyanT5000> hm
00:47:39 <RyanT5000> i'll think about that in a while
00:47:53 <lispy> yeah, just giving info, the decision is yours :)
00:48:19 <lispy> dons: how can darcs attract more hackers?
00:48:34 <dons> it could be simpler
00:48:47 <RyanT5000> yah; well i'm on 6.6.1 right now; the only reason i wanted to update is because Imlib is requiring array, and i wanted to avoid modifying the cabal file
00:48:50 <dons> but its not really like xmonad, for example, so i don't know
00:48:50 <lispy> dons: did you seen droundy's comment the other day that he's going to stop maintaining it within a year and he doesn't think anyone wants to become maintainer
00:48:57 <dons> i'd just like it to work.
00:48:59 <dons> lispy: yeah
00:49:06 <dons> we'll need that long to move ghc
00:49:17 <dons> he should turn it into an ICFP paper
00:49:23 <solrize> darcs?
00:49:28 <lispy> turn what into an ICFP paper?
00:49:35 <dons> the darcs experience
00:49:40 <lispy> no way we can make the deadline for this year
00:49:55 <dons> one lone physics guy takes on the vcs world with a vision
00:50:02 <solrize> it sounded like darcs 1 was very mysterious inside, is darcs 2 any less so ?
00:50:06 <dons> that was taken up as the gold standard in distributed vcs, and their user interface
00:50:35 <sjanssen> lispy: whoa, where did droundy say this?
00:50:41 <lispy> solrize: It's hard to say.  Darcs is mysterious, but it doesn't need to be.
00:50:53 <dons> sjanssen: thread a few days ago. maybe david was just feeling grumpy though
00:51:06 <dons> apparently no one reads darcs-devel anymore
00:51:28 <lispy> sjanssen: not trying to create a panic here, he didn't say it would be going away anytime soon.  just that he doesn't know what to do about maintainership in the future.  But, he said it on darcs-devel@darcs.net, I think you can find it on gmane
00:51:29 <solrize> i remember there was some patch operation a while back where nobody knew whether it was np-hard.  has that been resolved?
00:51:38 <dons> yeah
00:51:43 <dons> it wasn't np-hard.
00:51:47 <solrize> oh good
00:51:59 <lispy> dons: and who proved it?
00:52:06 <dons> heh
00:52:28 <solrize> coool
00:52:58 <lispy> david is probably the smartest (or second smartest) person I've ever met, and he puts in an amazing amount of effort for darcs.  But, I have a hunch it could be structured better for the sake of performance.
00:53:10 <dons> http://lists.osuosl.org/pipermail/darcs-devel/2008-March/007637.html
00:53:13 <lambdabot> Title: [darcs-devel] The future maintenance of darcs (was: GHC's darcs evaluation wiki  ..., http://tinyurl.com/2j9y3d
00:53:18 <dons> i'm not sure david mentioned anything about stopping in a year
00:53:31 <dons> "I certainly will continue using darcs, but the amount of time I've spent on
00:53:32 <dons> darcs this year just isn't maintainable"
00:53:36 <lispy> he did, but that thread came after his comment
00:54:08 <dons> "My estimate is
00:54:08 <dons> that by this time next year, darcs will be effectively unmaintained."
00:54:22 <dons> sjanssen: http://lists.osuosl.org/pipermail/darcs-devel/2008-March/007634.html if you're interestd, and work down
00:54:23 <lambdabot> Title: [darcs-devel] GHC's darcs evaluation wiki page, http://tinyurl.com/2o4gv2
00:54:41 <dons> time for git-darcs
00:54:47 <dons> bringing the darcs api to the git filesystem
00:55:05 * dons heads to bed. nytoll
00:55:14 <lispy> I don't think git is the way to go
00:56:12 <lispy> I think monotone and darcs are the only two out there that care about the correctness of the data model
00:56:32 <solrize> nite
00:57:40 <piojo> lispy: sorry for interrupting like this, but is the idea that darcs can have provably correct operation, while git (and others) rely on bugs being reported?
00:58:13 <piojo> i don't know much about darcs
00:58:51 <lispy> piojo: It's more like, you do some operations and then sometimes you don't get the results you should and it's a flaw in the semantics of the tool
00:59:26 <lispy> piojo: Now, when the tool says, "Oh, I don't know what to do, show me." to the user, then that's one thing.  But when the tool says, "Okay, done, no problems." and does something weird.  That's bad.
01:00:13 <piojo> right
01:00:27 <piojo> and that's what you mean by the data model?
01:00:41 <lispy> ya
01:00:48 <piojo> okay
01:01:47 <lispy> From the darcs experience, it does certainly seem that always trying to have a correct data model may cause lots of problems performance wise
01:01:49 <vegai> Meh. I just use mercurial
01:02:05 <vegai> who by the way just released 1.0.
01:02:22 <vegai> if someone has a good reason to use darcs, then so be it, but that reason cannot be "because it's written in Haskell"
01:02:44 <lispy> But, I think david is really on to something with the new hashed format.  Darcs needs to leave data on disk whenever it possible can an use handles (the hashes) whenever possible.  It also needs to only ever stream data, not load all at once like it does now.
01:02:48 <piojo> lispy: i really don't know what i'm talking about, i admit, but perhaps the problem is just that it's hard to write a good user interface to a complex program in a purely functional language
01:03:19 <lispy> piojo: darcs is praised for having a very good UI
01:03:35 <lispy> it's the performance and opaqueness that is cursed
01:04:03 <lispy> take svn for instance.  It does the wrong thing in some cases, but it's much easier to understand it and when it will do the wrong thing.
01:04:21 <lispy> But, with darcs, it's not easy to understand when it will do the wrong thing.
01:04:49 <lispy> (and with darcs the wrong thing is usually taking up all the CPU or RAM)
01:04:52 <sjanssen> the worst is when it won't do anything
01:06:03 <lispy> I think there are currently two concerns in darcs that need better seperation before the performance can be fixed.
01:06:34 <lispy> You want to be able to optimize darcs in terms of # of operations done on patches
01:06:53 <lispy> But, I think some of those operations force patches to be loaded into memory.
01:07:33 <lispy> So, that needs to be seperated from the algorithms so that as long as they have good complexity as a function of operations on patches then you'd expect good performance overall
01:07:50 <lispy> That's why I was praising the hashed idea.
01:07:52 <piojo> that makes sense
01:08:21 <piojo> i see. (well, sort of, at least. i haven't read any of the darcs design docs)
01:09:02 <lispy> That's another problem.  Only expert haskell hackers can deal with the complexity of the darcs source.  And most of those people are busy doing research and don't have enough interest in darcs to contribute.
01:09:14 <piojo> darcs seems pretty functional / lazy in terms of design, from what i understand
01:09:33 <lispy> I'm intermediate and struggling to become expert, so I know this well.  The darcs source knocks me on my butt often :)
01:09:46 <lispy> Yeah, darcs tries to use very lazy IO
01:09:59 <piojo> having a stack of patches upon which operations are performed reminds me of the idea of chaining up lazy function calls
01:10:00 <lispy> But, I'm extremely skeptical about lazy IO
01:10:06 <yitz> lipsy: I think these things are being worked on, and serious progress has been made recently with darcs 2.
01:10:57 <lispy> yitz: yeah, david has done some pretty amazing things in prep for darcs2.  BTW, I'm working on darcs for my masters project so I'm fairly aware of the current changes :)
01:11:19 <lispy> (although, a lot of my stuff is orthogonal to david's recent work)
01:12:01 <yitz> lipsy: i have been using darcs seriously for a few years, including with groups of developers on commercial projects. it has worked great for me.
01:12:15 <lispy> I'm also very tempted, after I finish my masters, to attempt some of my performance ideas...
01:12:17 <wli> yitz: You mentioned last night that solving quadratics is "almost as easy" as solving linear. I'm a bit fuzzy on how quadratics need less than the full Grobner treatment otherwise required for polynomials.
01:12:55 <lispy> yitz: that's great to hear.  I wish I could use darcs at my job.
01:13:14 <yitz> lipsy: you just need to be a little careful about a few things, and need one person on the team who knows how to do that.
01:13:17 <wli> yitz: I probably couldn't absorb an in-depth explanation, but if there's some explanation of why this is plausible that would do.
01:13:41 <lispy> My main optimization idea is to replace the lazy IO with explicit chunking/streaming when reading and then getting the data back out of memory and back onto disk somewhere.
01:14:30 <lispy> And using unique handles to things that are conceptually unique so that the patches rarely have to be streamed in/out of memory
01:15:08 <lispy> The next phase, I think, would be figuring out how to allow darcs to need less global information to work locally within a patch sequence
01:15:50 <yitz> wli: I didn't say I know that for sure, just a guess. Based on the observation that there is always a huge amount more known about the quadratic case than higher order.
01:16:56 <yitz> wli: where are you located?
01:17:05 <wli> yitz: Portland, OR
01:18:31 * wli could show up on the doorstep of galois.com in a pinch.
01:19:18 <lispy> yitz: oh, you work at galois?
01:19:35 * wli does not know.
01:19:46 * wli guesses not.
01:20:17 <yitz> lipsy: me? no.
01:20:46 * wli had a common meeting place in mind when he mentioned it.
01:21:09 <yitz> wli: quick google search shows that there is alg. geometry going on at both Reed and PSU. Must be people around there who know the latest.
01:21:49 * yitz is half-way around the world from Portland, OR.
01:21:52 <wli> Is it plausible that it's "almost as easy as linear" on account of focus/directrix shenanigans?
01:23:29 <yitz> wli: I doubt it's "almost as easy as linear". I think it's solvable with a lot of work, as opposed to higher-order which would probably be hopeless to solve in general.
01:24:32 <wli> Solving linear systems takes a bit of work, too, albeit well-boundedd by various things.
01:25:45 <yitz> wli: in other words, people have done that work for us already. as opposed to quadratic, as far as we know so far :)
01:26:18 <yitz> @localtime yitz
01:26:18 <lambdabot> Local time for yitz is 2008-03-25 10:26:18 +0200
01:26:37 <yitz> @localtime wli
01:26:37 <lambdabot> Local time for wli is Tue Mar 25 01:28:09 2008
01:28:01 <wli> yitz: point
01:30:32 <blarz> @localtime blarz
01:34:16 <lambdabot> Local time for blarz is Tue Mar 25 09:34:14 2008
01:34:25 <yitz> wli: besides the problem of singularities, you also have complexities from the fact that you only want real solutions ("integral" points over R). So, for example, the hyperbola y^2-x^2=4 and the unit circle have no common points over the reals.
01:34:36 <blarz> ah, I was ignoring ctcp
01:34:56 <wli> Hmm. I think I may know some things that would allow me to compute Grobner bases analytically under certain conditions.
01:35:48 <wli> s/analytically/in closed form/
01:36:22 <wli> Or at least allow me to do some elimination.
01:38:38 <yitz> wli: ok, good! well, as I said, I'm not working in this stuff, and it looks like a lot is being done, so I would ask around.
01:38:51 <wli> yitz: The indeterminates are split up into three groups, one vector of y's per-point, and one vector each of p and q for each interval. The things look like p = y^t A q for a bisymmetric matrix A (one row of Pascal's triangle along the NE-SW diagonal) and homogeneous equations B p = 0 and C q = 0 for nonsquare (clearly rank-deficient) matrices B, C.
01:41:04 <wli> yitz: Certain choices of problem inputs I think will make the homogeneous equation in the q's only have a line as a solution.
01:41:56 <yitz> wli: if you can do that, then you're back to the linear case.
01:42:12 <jaj> @seen hpaste
01:42:12 <lambdabot> I haven't seen hpaste.
01:43:24 <mofmo1> hey, i want to pattern match with a variable
01:43:35 <mofmo1> but i dont want to bind the variable, i want to pattern match against hte value of the variable
01:45:55 <cjs_> What's the cool way to take the lists [1,2,3] and [4,5,6] and get [[1,2], [3,4], [5,6]]?
01:46:35 <yitz> mofmo1: case
01:47:05 <Botje> cjs_: zipWith (\x y -> [x,y])
01:47:11 <Botje> oh wait
01:47:15 <solrize_> er no
01:47:15 <Botje> too early, nm :)
01:47:17 <sjanssen> cjs_: I don't see the pattern?
01:47:39 <solrize_> x++y  `groupBy` hmm
01:47:39 <cjs_> zip and then turn the pairs into lists.
01:47:39 <mofmo1> yitz: i need to pattern match against two dimensions however
01:47:57 <sjanssen> cjs_: that isn't what you wrote above
01:48:05 <mofmo1> i have data Expr = Expr String Float Float Float
01:48:16 <cjs_> Oops, I messed up. I meant, [[1,4], [2,5], [3,6]]
01:48:21 <sjanssen> @pl zipWith (\x y -> [x, y])
01:48:21 <lambdabot> zipWith ((. return) . (:))
01:48:37 <yitz> @let groupsOf n = takeWhile (not.null) . map (take n) . iterate (drop n)
01:48:38 <lambdabot> Defined.
01:48:54 <mofmo1> and i have a variable val which is an Expr and I want to make sure that the String = "LAB" and that the first Float is equal to a variable x
01:48:56 <yitz> > groupsOf 2 $ [1,2,3]++[4,5,6]
01:48:57 <lambdabot>  [[1,2],[3,4],[5,6]]
01:48:59 <solrize_> > map fst . groupBy (`div` 2 . snd) (zip (x++y) [0..])
01:48:59 <lambdabot>  Couldn't match expected type `(a, b1) -> b'
01:49:03 <solrize_> groupsOf?
01:49:07 <solrize_> @hoogle groupsOf
01:49:07 <lambdabot> No matches found
01:49:22 <yitz> solrize_: I just defined it above.
01:49:27 <solrize_> oh
01:49:30 <solrize_> hmm
01:49:41 <mofmo1> zipWith $ splitAt (length x) (x ++ y)
01:49:49 <mofmo1> something like that cjs
01:50:02 <ski> > transpose [[1,2,3],[4,5,6]]
01:50:03 <lambdabot>  [[1,4],[2,5],[3,6]]
01:50:11 <solrize_> :t transpose
01:50:12 <lambdabot> forall a. [[a]] -> [[a]]
01:50:13 <mofmo1> well i guess you could do that mr fancy pants
01:50:14 <solrize_> wow
01:50:23 <solrize_> @source transpose
01:50:23 <lambdabot> transpose not available
01:50:30 <solrize_> @hoogle transpose
01:50:30 <lambdabot> Data.List.transpose :: [[a]] -> [[a]]
01:50:30 <lambdabot> Data.ByteString.transpose :: [ByteString] -> [ByteString]
01:50:30 <lambdabot> Data.ByteString.Char8.transpose :: [ByteString] -> [ByteString]
01:50:38 <solrize_> neato
01:50:52 <yitz> transpose is really useful, I use it all the time.
01:50:57 <ski> > foldr (zipWith (:)) (repeat []) [[1,2,3],[4,5,6]]
01:50:58 <lambdabot>  [[1,4],[2,5],[3,6]]
01:51:09 <Mr_Awesome> ski: thats not really what he wanted
01:51:36 <mofmo1> Mr_Awesome: yes it is, he changed hsi mind
01:51:36 <cjs_> Wow, that zipWith is pretty magical....
01:51:37 <solrize_> transpose is good
01:51:38 <ski> Mr_Awesome : `he' being `cjs_' ?
01:51:44 <dibblego> Cale, I'd rather lambdabot give me a "Add a type signature" than silently allowing certain properties to succeed
01:52:01 <solrize_> hmm
01:52:05 <cjs_> Actually, I need to do this for arbitrary numbers of lists....
01:52:07 <Mr_Awesome> mofmo1: oh, right, nvm ski
01:52:16 <dibblego> @msg Cale I'd rather lambdabot give me a "Add a type signature" than silently allowing certain properties to succeed
01:52:16 <lambdabot> Not enough privileges
01:52:21 <dibblego> get stuffed lambdabot
01:52:30 <sjanssen> @let groupsOf' n = unfoldr (\xs -> guard (not . null $ xs) >> return (splitAt n xs))
01:52:30 <lambdabot> Defined.
01:52:49 <solrize_> > groupsOf' 3 [1..10]
01:52:50 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
01:52:50 <yitz> mofmo1: doSomething (Expr "LAB" x y z) | x == val = ...
01:52:51 <ski> dibblego : `@tell'
01:53:00 <dibblego> oh thanks
01:53:03 <dibblego> @tell Cale I'd rather lambdabot give me a "Add a type signature" than silently allowing certain properties to succeed
01:53:03 <lambdabot> Consider it noted.
01:53:21 <sjanssen> @scheck \n xs -> groupsOf n xs == groupsOf' n xs
01:53:22 <lambdabot>   Failed test no. 2. Test values follow.: -1, [()]
01:53:29 <ski> dibblego : `@msg' is to make lambdabot directly msg a channel (or user, is suppose)
01:53:49 <dibblego> ski, ok thanks
01:54:01 <ski> @help msg
01:54:01 <lambdabot> msg <nick or channel> <msg>
01:54:05 <ski> @help tell
01:54:05 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
01:54:21 <yitz> @let repeatM = sequence . repeat
01:54:21 <lambdabot> <local>:6:10:     Ambiguous type variable `m' in the constraint:       `Monad...
01:54:28 <sjanssen> @check \n xs -> n > 0 ==> groupsOf n xs == groupsOf' n xs
01:54:29 <lambdabot>  OK, passed 500 tests.
01:54:36 <solrize_> @let groupsOf'' n = map snd $ groupBy \(x,y)->x`div`n $ zip [1..]
01:54:36 <lambdabot>  Parse error
01:55:11 <yitz> @let repeatM :: Monad m => m a -> m [a]; repeatM = sequence . repeat
01:55:11 <lambdabot> Defined.
01:55:18 <solrize_> > let n=3 in (map snd $ groupBy (\(x,y)->x`div`n) $ zip [1..]) [1..20]
01:55:18 <lambdabot>      Occurs check: cannot construct the infinite type:
01:55:18 <lambdabot>       t = (t, t1) -> B...
01:55:25 <solrize_> bah
01:55:57 <solrize_> zzz
01:56:29 <sjanssen> solrize_: use . rather than $
01:56:30 <yitz> @let groupsOf'' n = takeWhile (not.null) . evalState (repeatM $ State $ splitAt n)
01:56:30 <lambdabot> Defined.
01:57:01 <solrize_> > let n=3 in (map snd $ groupBy (\(x,y)->x`div`n) . zip [1..]) [1..20]
01:57:01 <lambdabot>      Occurs check: cannot construct the infinite type:
01:57:01 <lambdabot>       t = (t, t1) -> B...
01:57:10 <solrize_> > let n=3 in (map snd . groupBy (\(x,y)->x`div`n) $ zip [1..]) [1..20]
01:57:11 <lambdabot>      Occurs check: cannot construct the infinite type:
01:57:11 <lambdabot>       t = (t, t1) -> B...
01:57:15 <solrize_> er ... ?
01:57:30 * sjanssen still prefers the unfoldr :)
01:57:33 <solrize_> hmm
01:57:37 <sjanssen> solrize_: turn the other $ into .
01:57:45 <yitz> @scheck \n xs -> groupsOf n xs == groupsOf'' n xs
01:57:46 <lambdabot>   Completed 91 test(s) without failure.
01:57:53 <solrize_> > let n=3 in (map snd . groupBy (\(x,y)->x`div`n) . zip [1..]) [1..20]
01:57:54 <lambdabot>      Occurs check: cannot construct the infinite type:
01:57:54 <lambdabot>       t = (t, t1) -> B...
01:58:38 <sjanssen> @type groupBy
01:58:39 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
01:58:47 <solrize_> oh
01:58:49 <solrize_> hmm
01:58:57 <solrize_> ok
02:01:33 <solrize_> let groupsOf n = map snd . groupBy (\(a,b) (c,d) -> a`div`2 == c`div`2) . zip [1..] in groupsOf 3 [1..20]
02:01:42 <solrize_> > let groupsOf n = map snd . groupBy (\(a,b) (c,d) -> a`div`2 == c`div`2) . zip [1..] in groupsOf 3 [1..20]
02:01:43 <lambdabot>  Couldn't match expected type `(a, b)'
02:01:59 <yitz> @tell glguy hpaste is not announcing.
02:01:59 <lambdabot> Consider it noted.
02:02:24 <solrize_> > let groupsOf n = map snd . groupBy (\(a,b) (c,d) -> a`div`n == c`div`n) . zip [1..] in groupsOf 3 [1..20]
02:02:24 <lambdabot>  Couldn't match expected type `(a, b)'
02:02:33 <ertai> @type groupWith
02:02:34 <lambdabot> Not in scope: `groupWith'
02:02:44 <solrize_> > let groupsOf n xs = map snd . groupBy (\(a,b) (c,d) -> a`div`n == c`div`n) . zip [1..] xs in groupsOf 3 [1..20]
02:02:45 <lambdabot>  Couldn't match expected type `(a, b)'
02:03:06 <solrize_> > let groupsOf n xs = map snd . groupBy (\(a,b) (c,d) -> a`div`n == c`div`n) . (zip [1..] xs) in groupsOf 3 [1..20]
02:03:07 <lambdabot>  Couldn't match expected type `(a, b)'
02:03:10 <solrize_> ??
02:03:17 <ertai> @let groupWith f = groupBy g where g x y = f x == f y
02:03:18 <lambdabot> Defined.
02:04:10 <sjanssen> > (\n -> map (map snd) . groupBy (\_ (x, _) -> x `mod` n /= 0) . zip [0..]) 3 [1..10]
02:04:11 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
02:04:20 <solrize_> argggh
02:04:22 <yitz> sjanssen: i've decided that i don't like unfoldr when adding an extra Maybe wrapper loses whatever simplicity you may have gained.
02:04:46 <solrize_> yitz yeah that always seemed messy to me too
02:05:23 <sjanssen> I don't see how Maybe adds complexity?
02:05:49 <yitz> ertai: groupWith f === groupBy ((==) `on` f)
02:06:09 <quicksilver> sjanssen: just syntactic complexity, I presume.
02:06:12 <ertai> @type on
02:06:14 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
02:06:16 <cjs_> You'd kinda think that there's be a way to do this with a list comprehension.
02:06:17 <yitz> right
02:06:28 <quicksilver> yitz: yes, I agree. I wish for a version of unfuldr which always returns the 'Just' version.
02:06:29 <ertai> yitz: thanks I didn't know 'on'
02:06:50 <solrize_> yeah i'm tryng to find the listcomp too
02:07:01 <ertai> @src on
02:07:01 <lambdabot> (*) `on` f = \x y -> f x * f y
02:07:34 <ertai> @pl  \x y -> f x * f y
02:07:34 <lambdabot> (. f) . (*) . f
02:08:41 <yitz_> quicksilver: and one more chance for the compiler to miss unrolling things
02:08:52 <sjanssen> @let unfoldr' p f = unfoldr (\x -> guard (p x) >> return (f x))
02:08:53 <lambdabot> Defined.
02:09:15 <solrize_> let g n xs = [[x,y] | [[(x,y)]] <- groupBy (\(x,n)->x`mod`n /= 0) (zip xs [0..])]
02:09:20 <solrize_> let g n xs = [[x,y] | [[(x,y)]] <- groupBy (\(x,n)->x`mod`n /= 0) (zip xs [0..])] in g [1..20]
02:09:24 <solrize_> > let g n xs = [[x,y] | [[(x,y)]] <- groupBy (\(x,n)->x`mod`n /= 0) (zip xs [0..])] in g [1..20]
02:09:24 <lambdabot>  Couldn't match expected type `(t, t) -> Bool'
02:09:44 <solrize_> ehh what was i thinking
02:09:47 <solrize_> i'm too sleepy to be doing this
02:09:49 <solrize_> later
02:10:28 <sjanssen> > unfoldr' (not . null) (splitAt 3) [1..]
02:10:29 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23,...
02:11:23 <yitz_> sjanssen: there you go!
02:11:48 <cjs_> The real killer would be to have it do [[1,2,3], [4,5,6], [7,8,9]] -> [[1,4,7], [2,5,8], [3,6,9]] for an arbitrary number of lists.
02:11:56 <cjs_> Isn't that some sort of matrix transform?
02:12:11 <solrize_> > transpose  [[1,2,3], [4,5,6], [7,8,9]]
02:12:12 <lambdabot>  [[1,4,7],[2,5,8],[3,6,9]]
02:12:22 <solrize_> that came out a little ways back
02:12:23 <yitz_> > transpose $ groupsOf 3 [1..]
02:12:24 <lambdabot>  [[1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76...
02:12:36 <cjs_> That's it? Sheesh. I thought I looked at that already.
02:13:17 <solrize_> :t scan
02:13:19 <lambdabot> Not in scope: `scan'
02:13:21 <solrize_> :t scanl
02:13:23 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
02:13:51 <ski> > map (take 4) $ transpose $ groupsOf 3 [1..]
02:13:55 <lambdabot>  Terminated
02:14:38 <solrize_> :t unfoldr
02:14:39 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
02:14:46 <ski> @type unfoldr'
02:14:47 <lambdabot> forall b a. (b -> Bool) -> (b -> (a, b)) -> b -> [a]
02:14:51 <ertai> is there a way to give field names in GADTs (like in data T = T { name :: X })?
02:15:09 <yitz_> ertai: no. sadly
02:15:37 <ertai> yitz_: ok, thanks (will write these functions...)
02:16:11 <solrize_> there's also no way to have gadt deriving Show.... is that just b/c gadt's are new and not completely implemented or is there some more subtle reason?
02:16:16 <solrize_> i've asked this before btw
02:16:35 <ski> ertai : http://www.haskell.org/ghc/docs/latest/html/users_guide/data-type-extensions.html#gadt
02:16:37 <lambdabot> Title: 8.4. Extensions to data types and type synonyms, http://tinyurl.com/2cmgjm
02:19:33 <yitz_> ski: oh thanks - they fixed that. ertai, so yes, it's supported now.
02:19:59 <ertai> ski: thanks
02:20:05 <yitz_> solrize_: hmm, why shouldn't Show deriving work for GADTs?
02:20:11 <ertai> yitz_: yes I'm reading this too
02:23:13 <solrize_> yitz i asked why it doesn't work and there wasn't any clear answer
02:23:36 <ski> generally, it can't be supported
02:23:56 <mockm> @pl \n -> map (take n) . iterate (drop n)
02:23:56 <lambdabot> ap ((.) . map . take) (iterate . drop)
02:23:57 <ski> possibly it could be supported for a subset of the possible GADT declarations
02:29:03 <yitz_> ski: do you know an example of a GADT declaration in which every type mentioned has a Show instance, yet there is no clear way to define a Show instance for the GADT?
02:29:52 <solrize_> yitz i don't know any obstacle to manually defining a show instance, i'm just saying ghc doesn't derive them automatically like it can for ordinary data declarations
02:30:24 <yitz_> ski said "generally, it can't be supported"
02:30:44 <kosmikus> doesn't work for existentials, but otherwise, Show would work
02:31:53 <yitz_> kosmikus: are existentials more of a barrier for GADTs than for ordinary ADTs?
02:31:58 <kosmikus> no
02:32:12 <kosmikus> the same
02:32:30 <kosmikus> for existentially quantified types, you by default have *no* information at compile time
02:32:36 <kosmikus> that's not enough to derive anything ;)
02:33:03 <solrize_> @hoogle exists
02:33:04 <lambdabot> System.IO.Error.isAlreadyExistsError :: IOError -> Bool
02:33:04 <lambdabot> System.IO.Error.alreadyExistsErrorType :: IOErrorType
02:33:04 <lambdabot> System.IO.Error.isAlreadyExistsErrorType :: IOErrorType -> Bool
02:33:19 <solrize_> @hoogle exists a. => a -> Float
02:33:19 <lambdabot> No matches, try a more general search
02:33:28 <kosmikus> yitz_: but there are sufficiently many GADTs that don't have pure existentials ...
02:33:40 <kosmikus> yitz_: plus, I like to use GADT syntax for normal datatypes
02:33:55 <kosmikus> yitz_: so I would love if GHC supported deriving for those ...
02:34:15 <yitz_> right. sounds like they just haven't gotten around to that yet. is there a ticket for it?
02:35:16 <kosmikus> another problem is that not everything is as easy as Show for GADTs
02:35:36 <kosmikus> Read is much harder
02:36:32 <ski> (yitz_ : sorry, went for a cup of tea)
02:37:15 <yitz_> kosmikus: why is Read hard?
02:38:11 <kosmikus> yitz_: because you in general have to define multiple instances for one datatype
02:38:56 <kosmikus> yitz_: if you take the hello-world-example, the typed expression GADT, then "instance Read (Expr Bool)" will be different from "instance Read (Expr Int)"
02:39:17 <kosmikus> both instances should really only allow to parse the constructs that end up having the right type
02:41:08 <yitz_> kosmikus: I don't see why that's any different than ADTs. The Read instance for data Foo a will depend on the the Read instance for each a; same with GADts.
02:41:31 <kosmikus> yitz_: in general, consumers like Show are easier to define than producers like Read (shameless plug: read the SYB Reloaded and Revolutions papers).
02:41:59 <kosmikus> yitz_: oh, but it is different, because it doesn't even have to depend on the Read instance for the argument.
02:42:37 <kosmikus> yitz_: think: data Expr :: * where Num :: Int -> Expr Int; Bit :: Bool -> Expr
02:42:46 <kosmikus> sorry, Expr :: * -> *
02:43:20 <kosmikus> then "instance Read (Expr Int)" should parse just things like "Num 3"
02:43:32 <kosmikus> and "instance Read (Expr Bool)" should parse just things like "Bit False"
02:43:53 <kosmikus> there's no way to define "instance (Read a) => Read (Expr a)" sensibly though
02:45:02 <yitz_> kosmikus: Sure - it will parse Num 3 and Bit False, and fail on anything else, just like what would happen in a Haskell expression.
02:46:06 <Baughn> > let tau v = sqrt (1-v^2) in tau .7
02:46:06 <lambdabot>   add an instance declaration for (Num (f a))
02:46:14 <Baughn> > let tau v = sqrt (1-v^2) in tau 0.7
02:46:15 <lambdabot>  0.7141428428542851
02:48:06 <mofmo1> YES, my silly imperative language with the expressive power of ASM and none of the power works!
02:48:40 <kosmikus> yitz_: but you can't define such a function in a uniform instance
02:48:50 <Baughn> mofmo1: Only thing left is to require input programs to be encrypted! Using the first sixteen bytes of the encrypted code as the encryption key!
02:49:31 <kosmikus> yitz_: try to define "instance (Read a) => Read (Expr a)" with your behaviour for the Expr datatype given above by hand -- it won't work
02:49:37 <mofmo1> Baughn: my language is so powerful you only get to use 7 registers. to add stuff you have to add registers.
02:50:08 <Baughn> mofmo1: Huh. Even x86 has more than that.
02:50:20 <mofmo1> Baughn: like i said, none of the power
02:50:22 <Baughn> So, um.. what's the point?
02:50:28 <mofmo1> Baughn: just an excersise
02:50:33 <Baughn> Ah.
02:50:36 <mofmo1> it taught me a lot about records and transformers
02:50:49 <mofmo1> some of the code needs tightening up but im just happy it works haha
02:50:59 * Baughn hatess records. Hatess them, my precious.
02:51:15 <yitz_> kosmikus: it would have to return forall a. Expr a
02:52:23 <yitz_> kosmikus:  forall a. Read a => Expr a
02:52:55 <kosmikus> yitz_: but that's an uninhabited type (modulo undefined)
02:53:36 <yitz_> kosmikus: that makes it a bit less useful, i suppose
02:53:47 <kosmikus> yitz_: :)
02:54:00 <yitz_> > undefined
02:54:01 <lambdabot>  Undefined
02:54:39 <Baughn> > [1,2,undefined]
02:54:39 <lambdabot>  Undefined
02:55:07 * Baughn wonders when that'll get fixed
02:55:21 <kosmikus> Baughn: ?
02:55:47 <Baughn> kosmikus: It should be able to print the 1 and 2 before giving up. Like this, see..
02:55:56 <Baughn> > repeat 1000 1 ++ undefined
02:55:57 <lambdabot>  Couldn't match expected type `t -> m' against inferred type `[t1]'
02:56:05 <Baughn> > replicate 1000 1 ++ undefined
02:56:06 <lambdabot>  Undefined
02:56:13 * Baughn sweatdrops
02:56:53 <kosmikus> oh yes, of course; but I guess lambdabot's output is a reasonable approximation for the irc environment
02:57:12 * Baughn shrugs. It's just that I already sent a patch to fix it, oh, a week or so..
02:57:18 <Baughn> ..
02:57:33 <kosmikus> ah ... now I understand :)
02:57:37 <Baughn> I can't believe I didn't realize that, if the smtp server is down, mail won't get sent
02:57:51 <Baughn> Been using gmail too long. Which darcs doesn't. >_<
02:58:36 * Baughn feels very embarrased
02:58:42 <yitz_> Baughn: install esmtp locally. configure it to use gmail.
02:59:25 <Baughn> yitz_: I suppose that'd work
02:59:35 <Baughn> Easter's over, though, so I intend to shout at my ISP now
02:59:57 <yitz_> Baughn: that's also work. :)
03:00:24 <Baughn> They're blocking outgoing port 25. Including, apparently, to their smtp server - it answers to pings just fine.
03:09:44 <mofmo1> hmm parsec's string parser doesnt do what i want it to do =/
03:09:59 <mofmo1> it seems to consume input even if it ends up failing. so i can't differentiate "hi" and "he"
03:10:21 <mofmo1> string "hi" <|> string "he" -- will never work for he
03:10:33 <Mr_Awesome> use try if you need backtracking
03:10:42 <mofmo1> ah
03:10:46 <Mr_Awesome> but that particular situation is best done with some left-factoring
03:10:52 <mofmo1> left factoring?
03:11:01 <mofmo1> what i have is a list of strings
03:11:15 <mofmo1> then i implemented a function that basically foldrs with <|>
03:11:16 <Mr_Awesome> char 'h' >> (char 'i' <|> char 'e'), roughly
03:11:25 <mofmo1> oh no that's not an option
03:11:30 <Mr_Awesome> well, try will solve your problem then
03:12:00 <malcolmw> parsec's non-compositional <|> strikes again!
03:12:02 <mofmo1> ok lemme lookup the docs on try
03:19:00 <mofmo1> ok
03:19:03 <mofmo1> that made everything work
03:20:48 <byorgey> the fact that <|> works this way isn't necessarily a problem, it's just the fact that it's apparently not documented very well
03:21:01 <byorgey> no one seems to realize it until they've banged their head on it for a while first
03:27:08 <scook0> non-backtracking <|> is the whole basis of Parsec's efficiency, isn't it?
03:27:15 <scook0> otherwise it would leak space all over the place
03:27:37 <scook0> I think it might help with error-reporting too
03:28:08 <malcolmw> there are other ways of getting the same efficiency, without sacrificing compositionality
03:29:12 <scook0> I was under the impression that you couldn't do much better with a monadic parser, though I could be mistaken
03:29:33 <scook0> (because you can't predict whether it's safe to throw away input)
03:30:29 <malcolmw> polyparse has the dual operator to 'try', called 'commit'
03:31:13 <malcolmw> parsec throws away input unless you tell it not to, polyparse keeps input until you tell it to throw it away (commit)
03:32:39 <malcolmw> this has two benefits: your grammar is not broken before you add 'commit's, and it is much easier to guess where to 'commit' than it is to guess where to 'try'
03:36:24 <yitz_> malcolmw: so parsec is broken and fast by default, and polyparse works and is slow by default. If you're careful, you can make parsec work and polyparse fast. So I guess it's a matter of taste. :)
03:39:12 <yitz_> kosmikus: I see a number of trac tickets where deriving is fixed for GADTs in various ways. So it did work at some point. Did they then disable it?
03:44:55 <earthy> yitz: ofcourse, there is also uulib's UU.Parsing, which is both working and fast. ;)
03:45:16 <earthy> (if you don't care too much about context sensitivity in your grammars)
03:51:05 <yitz_> earthy: I'm not up on uulib. (I have it installed somewhere, but haven't studied it.)
03:54:10 <yitz_> malcolmw: so parsec is broken and fast by default, and polyparse works and is slow by default. If you're careful, you can make parsec work and polyparse fast. So I guess it's a matter of taste. :)
03:54:31 <malcolmw> who said polyparse was slow? :-)
03:54:58 <malcolmw> lazy polyparse is orders of magnitude faster than parsec
03:55:19 <yitz_> malcolmw: if you don't insert commits, it will bog down, no?
03:55:56 <malcolmw> well, possibly
03:56:31 <malcolmw> but it is easier to see where to commit, than where to try
03:56:32 <yitz_> the whole idea of parsec was to gain speed by being strict
03:57:15 <malcolmw> and it turns out that you gain more speed by being lazy (in the right places)
03:58:33 <yitz_> in mofmo1's example, you would say string "he" <|> commit (string "hi")?
03:59:16 <malcolmw> no, you would just say: string "he" `onFail` string "hi"
03:59:43 <yitz_> so when do you need to commit?
04:00:30 <malcolmw> you commit when you have seen the initial part of a structure that disambiguates it from everything else
04:02:29 <malcolmw> so if you have a datatype T = AB Char | AC Int, you can write a parser like (do token "AB"; commit (do c <- char; return (AB c))) `onFail` (do token "AC"; commit (do i <- int; return (AC i)))
04:03:21 <malcolmw> except typically of course, it is not just a Char or Int contained within the structure, but something very much larger
04:04:03 <quicksilver> or, you can just not bother
04:04:05 <quicksilver> :)
04:04:12 <quicksilver> unless you're parsing gigabyte files
04:04:19 <julz> Hi, sorry to come back again you are my last hope ;-) I pasted http://www.hpaste.org/6610 but there are several errors I have to fix
04:04:47 <julz> I did this http://www.hpaste.org/6608 but still can not compile
04:04:58 <julz> plz can anyone help me out?
04:05:49 <Dybber> does anyone in here know if matlab or octave supports higher-order functions? (the activity on the matlab channel is low, so I thought somebody in here might know)
04:05:58 <Beelsebob> I'd suggest asking about a particular error, and explaining why you think it's valid julz
04:06:11 <Beelsebob> rather than just asking people to "please fix my code for me"
04:06:38 <julz> oh no, was not my intention, sorry I will paste the error
04:07:06 <julz>  Couldn't match expected type `a' (a rigid variable) 	   against inferred type `Char'       `a' is bound by the type signature for `runIt' at upyours.hs:7:20       Expected type: [a]       Inferred type: String
04:07:41 <julz> I don't know much about haksell, saw it 2 days before for the first time
04:07:55 <quicksilver> julz: that error is caused by giving the wrong type signature
04:08:02 <quicksilver> (in particular, one which is too general)
04:08:05 <Beelsebob> indeed
04:08:18 <quicksilver> a simple fix is just to omit the type signature completely
04:08:36 <Beelsebob> what immediately jumps out is your otherwise branch
04:08:36 <Beelsebob> you call result
04:08:36 <Beelsebob> which returns a String
04:08:36 <Beelsebob> not a general list of anything
04:08:38 <quicksilver> which may just reveal a different error, of course :)
04:08:38 <julz> yes, ok thats what I was assuming, but I can not imagine where to change what
04:08:38 <julz> ok how to?
04:08:44 <quicksilver> you could comment out the typesig for runIt.
04:09:03 <Beelsebob> in general I don't recommend doing that
04:09:36 <Beelsebob> (1) type signatures are documentation (2) if the type doesn't match what you expected, you probably got the code wrong
04:09:44 <Beelsebob> so it's a good plan to have them there to check against
04:10:14 <julz> hm, I tried several types but always getting a similiar error
04:10:35 <Beelsebob> well, the input certainly is a String
04:10:44 <Beelsebob> and you call result on a list, which always returns a String
04:10:45 <julz> yes it is
04:10:51 <Beelsebob> so the correct type is String -> String
04:11:04 <Beelsebob> whether this is the type you intended is a different matter
04:11:21 <julz> which I have to assing to what?
04:11:43 <Beelsebob> pardon?
04:12:13 <julz> do I need to assign type String to "runIt :: [Char] -> [a]"?
04:12:33 <Beelsebob> well, first, you don't assign anything in Haskell.. ever
04:12:48 <julz> ok, ok, as I said jsut a 2 day newb
04:12:50 <julz> ;-)
04:12:52 <Beelsebob> what you need to do is correct your type signature
04:12:58 <Beelsebob> runIt :: String -> String
04:13:24 <Beelsebob> the closest you will ever come to an assignment in Haskell is a monadic bind, and that's a long way away
04:14:08 <julz> but as I read the documentation isnt runIt :: [Char] -> [a] a String -> String?
04:14:28 <julz> what do I get wrong here I feel a bit stupid, sorry for that
04:14:37 <Beelsebob> yes, String -> String is an instance of [Char] -> [a]
04:14:38 <Beelsebob> but
04:14:55 <Beelsebob> your type signature tells the compiler what inputs and outputs you claim to be able to give
04:15:13 <Beelsebob> so with that type signature you are claiming that your function can also return a [Int]
04:15:15 <quicksilver> julz: don't apologise, it's a very understandable misunderstanding
04:15:18 <Beelsebob> or a [Jam]
04:15:28 <Beelsebob> or a [anything else at all]
04:15:28 <quicksilver> after all [Char] is an example of [a]
04:15:38 <quicksilver> it's just that -> [a] promises you can return ANY a
04:15:40 <quicksilver> not just Char
04:15:51 <Beelsebob> and the compiler has said "but hang on, this thing can only return [Char]"
04:16:09 <malcolmw> quicksilver: hmm, yes, I _am_ parsing files of > 6Gb of structured data
04:16:11 <Beelsebob> if I try and hook it up with a function that expects a [Int], things are gonna go badly wrong
04:16:36 <julz> ok, so I have to change [a] to be definitly a string?
04:16:42 <Beelsebob> yep
04:17:18 <Beelsebob> your type signature can always under-specify what types your function can return, but never over-specify
04:17:24 <julz> ok great, to know whats wrong, I think I need to read again how to do
04:17:41 <Beelsebob> i.e. you can specify listReverse :: String -> String
04:17:51 <Beelsebob> and you will gain a reverse function that only works on Strings
04:18:03 <Beelsebob> but you can't specify listReverse :: a -> a
04:18:14 <Beelsebob> because the code provides no way to reverse a Maybe Int
04:18:45 <Beelsebob> (along with many other data types)
04:19:04 <julz> thanks a lot I will try my best, maybe I will be back later on ;-)
04:19:10 <Beelsebob> np :)
04:20:34 <skorpan> @pl \w -> focus w >> mouseMoveWindow w
04:20:34 <lambdabot> liftM2 (>>) focus mouseMoveWindow
04:52:47 <Baughn> Installing a signal handler appears to disable the deadlock/loop detection, presumably because I have a catch that would break the loop if the signal is ever received. (And it's ever so clever about it..)
04:53:12 * SamB sighs with relief that his problem was just a loose keyboard cable so he doesn't need to reboot or even restart X
04:53:21 <Baughn> Problem is, the signal will never be received in /practice/, if it's deadlocked - it's XCPU. Is there any way to override that logic?
04:54:18 <SamB> Baughn: I think you'd have more luck in #ghc or on the GHC trac...
04:54:30 <Baughn> Hm. Point.
04:55:13 <SamB> just because of the obscure nature of the question
04:55:53 <Baughn> Mm. Still trying to make a perfect lambdabot, here. :P
04:56:04 * SamB wonders why his hands feel like they have pins and needles when he's pretty sure his circulation has not been cut off recently...
04:56:19 <Baughn> SamB: Using a laptop?
04:56:22 <SamB> no!
04:56:36 <Baughn> So no chance it's due to bad grounding, then
04:56:48 <SamB> ?
04:58:00 * SamB wishes google was better at case-sensitivity
04:58:10 <SamB> it would be nice to be able to search for NeWS
04:58:11 <Baughn> SamB: Laptops have a bizarre tendency to connect the casing to ground. If there's leakage current and grounding is missing..
04:59:02 <SamB> I haven't learned about design safety yet
04:59:40 <Baughn> http://en.wikipedia.org/wiki/Double_insulation <-- For the record, I hate everything that's not class 2 or above
05:00:28 <SamB> my designs are as of this moment not insulated at all, beyond wire insulation
05:00:39 <Baughn> SamB: And you don't get shocked?
05:00:52 <SamB> they all run at low voltages
05:00:54 <Baughn> SamB: ..well, I suppose you're probably using a battery eliminator that /is/ grounded
05:01:14 <SamB> my home doesn't even have proper grounding, so...
05:02:07 <SamB> anyway, the highest voltage I've used is probably 10 volts...
05:03:02 <Baughn> It's very, very hard to avoid getting AC into your circuits if you don't have grounding. I don't see how you could live with it..
05:04:10 <SamB> well, my latest design has only been run on batteries ;-)
05:04:23 <Baughn> That's cheating!
05:04:27 <SamB> and it does have grounding
05:06:48 <SamB> it even has a voltage regulator, because the 74LS10 chips only take 5+-0.25 V, and the Electronics Learning Lab only provides multiples of 1.5 V
05:08:12 <SamB> but, being constructed on solderless breadboards as it is, it doesn't have any casing, nevermind insulation beyond wire insulation...
05:08:57 <SamB> I guess my designs come under Class III ;-)
05:09:20 <Baughn> That's fine. I find it very hard to believe that the power supplies in that lab aren't properly grounded. :P
05:09:24 <Zao> "Mostly harmless".
05:09:47 <SamB> oh, the equipment in the lab is normally grounded, yes...
05:12:28 <SamB> but I'm fairly certain that the adjustable-voltage terminals don't have any relationship with the external ground (mostly because of the experiment we did last semester where we connected the negative terminal of one to the positive terminal of the other...)
05:13:22 <syntaks> hello
05:13:32 <SamB> hi
05:15:51 * SamB uploads photos of his latest design to facebook, as he meant to do last night
05:20:16 <syntaks> re
05:20:55 <SamB> hi again
05:21:59 <SamB> Baughn: see http://www.facebook.com/album.php?aid=28026&l=73201&id=791687424
05:22:00 <lambdabot> Title: Incompatible Browser | Facebook
05:25:59 <ski> hm .. there appears to be no `instance Read TypeRep'
05:26:02 <SamB> okay, I really have to get ready to leave for school
05:37:39 <matthew_-> SamB: you *had* to use your feet?!
05:39:50 <idnar> what's the shortest way to read everything from stdin?
05:40:16 <taruti> getContents
05:44:49 <yitz_> idnar: cat
05:44:58 <yitz_> (at the shell prompt)
05:45:10 <idnar> yitz_: heh
05:45:36 <glen_quagmire> cat :: Either Stream File -> Stream
05:47:40 <syntaks> is it possible for a record-style data type to include the fields of another record-style type?
05:48:07 <glen_quagmire> why not?
05:48:27 <glen_quagmire> data A = A { b :: B }   data B =  B { s :: String }
05:49:51 <matthew_-> syntaks: not in an inheritance / subtyping / subclass way a la OO though
05:50:10 <syntaks> glen_quagmire, I mean more like this data A = A { field1 :: Int } and data B = B{ field1 :: Int, field :: Int} but in a way where the field1 in B comes from A
05:50:33 <matthew_-> syntaks: no, think about the type of field1
05:50:36 <syntaks> matthew-_, thats what I meant, kiund of a simple "extends"
05:50:40 <matthew_-> field1 :: A -> Int
05:50:47 <matthew_-> but then you define it to be :: B -> Int
05:50:48 <glen_quagmire> field1 would be exposed as top level
05:50:49 <matthew_-> it can't be both
05:50:56 <glen_quagmire> so name clash
05:51:10 <DRMacIver> Hm. What are the current best choices for Haskell + XML?
05:51:23 <quicksilver> haxml, tagsoup and hxt
05:51:29 <quicksilver> in no particular order
05:51:39 <matthew_-> Haskell - XML
05:51:43 <matthew_-> :p
05:52:00 <glen_quagmire> is there (-) defined for types?
05:52:11 <syntaks> DRMacIver, I've looked at HaXML and HXT and liked HXT better... especially the documentation was more complete
05:52:31 <matthew_-> glen_quagmire: well, so much as you can do numbers in types, you can do addition and subtraction
05:52:32 <DRMacIver> matthew_-: Well, yes. But the data I need to parse is already in an XML format. :)
05:52:43 <DRMacIver> syntaks: Thanks
05:52:44 <glen_quagmire> > Int - Float
05:52:46 <lambdabot>   Not in scope: data constructor `Float'
05:52:54 <matthew_-> glen_quagmire: no, that would be silly ;)
05:53:22 <syntaks> DRMacIver, HaXml has no support for namespaces, HXT has... in my case that was also important
05:53:23 <matthew_-> And Haskell isn't a Type. It's at least a Kind and probably a Sort :)
05:53:59 <glen_quagmire> as soon as we have haskell to java bridge, we'd have xml heaven
05:54:11 <quicksilver> glen_quagmire: I think you mis-spelt 'Hell'.
05:54:39 <DRMacIver> I thought people had basically given up on the idea of a Haskell to Java bridge anyway?
05:55:10 <quicksilver> I don't why it's something you'd give up on.
05:55:14 <matthew_-> quicksilver: I was considering a /quit segfault ...
05:55:20 <quicksilver> But equally it's not somethign I find very interesting...
05:55:23 <syntaks> I do a lot of Java XML stuff and none of it is very pretty... (and I tend to believe that isn't entirely my own fault)
05:56:03 <quicksilver> a compiler from haskell to bytecode would be interesting just because it would be fun to run haskell code in applets
05:56:17 <quicksilver> but it would be quite tricky to do, and I suspect very tricky to do well.
05:56:17 <DRMacIver> quicksilver: There is a compiler from Haskell to bytecode already.
05:56:31 <DRMacIver> @go lambdavm
05:56:32 <lambdabot> http://www.cs.rit.edu/~bja8464/lambdavm/
05:56:32 <lambdabot> Title: LambdaVM - The Haskell to Java Translator
05:56:54 * quicksilver nods
05:56:57 <quicksilver> good point.
05:57:09 <DRMacIver> And I think there's a Haskell-Java JNI bridge
05:57:11 <dolio> There was one for YHC, too, I think, but I'm not sure if that's maintained.
05:57:12 <DRMacIver> lambada or something
05:57:28 <quicksilver> I'm fairly sure lambada is bitrotted
05:57:37 <DRMacIver> But as far as I can tell no one uses them and neither is actively maintained.
05:57:43 <idnar> @pl \x -> sum x / length x
05:57:43 <lambdabot> liftM2 (/) sum length
05:57:46 <DRMacIver> Which is what I meant by "people had given up on the idea" :)
05:57:50 <syntaks> java bytecode as a compilation target would indeed be a neat thing... regardless of whether it integrates with existing Java stuff or not
05:58:13 <glen_quagmire> we need standard protocol for foreign function calls.  all runtimes that implement the protocol can communicate with each other calling others' libraries
05:58:57 <quicksilver> glen_quagmire: there is one.
05:59:01 <quicksilver> it's called the C ABI
05:59:09 <DRMacIver> (incidentally, wrt the above, I don't need a lot of XML capability. I basically need to scrape some simple data out of an XML document and then I'm done with XML)
05:59:36 <syntaks> DRMacIver, sounds like you might want to look at tagsoup first then
05:59:56 <DRMacIver> It's practically regexpable. But the last time I used regular expressions on XML I was informed that "XML is not raw text, you barbarian. It has structure and beauty." :)
06:00:04 <enticingjelly> gah
06:00:09 <enticingjelly> kaffee schlÃ¤gt mir so auf den magen
06:00:19 <enticingjelly> und trotzdem will ich nicht aufhÃ¶ren ihn zu trinken.
06:00:45 <quicksilver> enticingjelly: ?
06:00:50 <glen_quagmire> quicksilver: oh nice
06:00:58 <quicksilver> DRMacIver: tagsoup is probably the simplest and great for simple tasks
06:01:08 <enticingjelly> quicksilver, mehr gibt's nicht zu sagen, ich denke ich habe meinen punkt ziemlich klar dargestellt %)
06:01:26 <glen_quagmire> @babelfish  mehr gibt's nicht zu sagen
06:01:26 <lambdabot> Unknown command, try @list
06:01:36 <enticingjelly> quicksilver, oh. wrong channel. sorry.
06:01:38 <quicksilver> DRMacIver: haxml is actually not very hard either but has a slightly less obvious API.
06:01:40 <glen_quagmire> my gigabyte is not so sad
06:01:41 <quicksilver> enticingjelly: ;)
06:01:47 <enticingjelly> quicksilver, huh. i seriously didn't notice. again, sorry ;)
06:01:55 <quicksilver> it's OK. I was just confused :)
06:01:58 <DRMacIver> quicksilver: Ok. Thanks.
06:05:18 <DRMacIver> hm
06:05:24 <DRMacIver> Yeah, tagsoup looks exactly like what I need.
06:05:28 <DRMacIver> Thanks
06:23:32 <DRMacIver> Yep. Tag soup worked perfectly.
06:24:54 <quicksilver> \o/
06:25:25 <DRMacIver> That has to rank as one of the easiest times I've ever had dealing with XML in fact. :)
06:25:42 <DRMacIver> Granted that's probably as much that it was a pretty trivial task as it was tagsoup, but still.
06:25:49 <glen_quagmire> anything -soup is good in xml,html
06:26:54 <Saizan> does tagsoup do any wellformedness checking?
06:27:50 <DRMacIver> No. That's rather the point. :)
06:34:57 <syntaks> the mere existence of the *-soup family of projects is proof of how horribly wrong XML went
06:35:12 <uccus> an FFI is not easy... to cover C, Java and perhaps Scheme within the same FFI framework kills the diversity
06:35:14 <quicksilver> tagsoup parses at the tag level, not the tree level
06:35:28 <quicksilver> that makes it fast for many tasks
06:35:41 <syntaks> quicksilver, which is how most humans view XML anyway (sadly)
06:35:47 <quicksilver> but not great for files where the nesting is semantically important.
06:36:20 * uccus wonders if .NET/Java could be uniformly treated by an advanced-enough FFI
06:36:43 <quicksilver> if you're happy to have an FFI based on a stupid broken type system
06:36:44 <quicksilver> (objects)
06:36:46 <quicksilver> then sure :P
06:37:03 <Lacrymology> excuse me, what's wrong with this? removeOne n (a:s) = if a == n then s else (a:(removeOne n s))
06:37:11 * uccus believes by the time Haskell' finishes, .NET + Java will be DEAD!
06:37:17 <Lacrymology> it tells me "unexpected keyword else"
06:37:29 <uccus> quicksilver: and you're okay with C?
06:37:34 <uccus> :)
06:37:37 <quicksilver> Lacrymology: looks fine to me
06:37:41 <Beelsebob> Lacrymology: it may be a layout issue
06:37:43 <quicksilver> Lacrymology: line break in a bad place perhaps?
06:37:45 <Beelsebob> but it looks fine to me
06:38:02 <Beelsebob> make sure your else is as indented an your then
06:38:13 <quicksilver> uccus: the C FFI has virtually no type system: just a few basic types, pointers ints and doubles being the key ones.
06:38:15 <Lacrymology> quicksilver: no line breaks..
06:38:45 <quicksilver> > let removeOne n (a:s) = if a == n then s else (a:(removeOne n s)) in removeOne 2 [1,2,3,4]
06:38:49 <lambdabot>  [1,3,4]
06:38:53 <quicksilver> Lacrymology: works for me!
06:39:01 <quicksilver> Lacrymology: there must be something else wrong with your code.
06:39:11 <syntaks> works here too
06:39:13 <quicksilver> uccus: as far as it goes, then, it's fine. It does the job.
06:39:35 <quicksilver> uccus: but if the conversation is about a more capable FFI, then a more expressive type system is an obvious thing to wonder about.
06:39:43 <uccus> quicksilver: that makes the .NET/JVM task a bit hard..
06:39:59 <uccus> yeah obviously I want a more capable FFI
06:40:49 <uccus> _when it comes to .NET/JVM_, that is, bytecode that force you to a type system
06:42:25 <Lacrymology> quicksilver: yeah, wrong line
06:42:40 <quicksilver> Lacrymology: :)
06:43:47 <byorgey> Lacrymology: note you also need a case for  removeOne n []  ...but maybe you already have that and you just pasted that one line.
06:47:17 <enticingjelly> :t flip (. map)
06:47:19 <lambdabot> forall c a b. (a -> b) -> (([a] -> [b]) -> c) -> c
06:58:32 <Lacrymology> byorgey: yeah, I have that
06:59:22 <byorgey> Lacrymology: ok, cool.  did you figure out what was wrong then?
07:01:58 <ertai> there is no standard function like 'maybe' but for lists, right/
07:02:01 <Beelsebob> Has anyone got any experience with calling Python from Haskell?
07:02:02 <ertai> +?
07:02:13 <Beelsebob> @src maybe
07:02:13 <lambdabot> maybe n _ Nothing  = n
07:02:13 <lambdabot> maybe _ f (Just x) = f x
07:02:17 <kpreid> ertai: foldr is that function.
07:02:25 <Beelsebob> idd
07:02:26 <ertai> kpreid: I don't think so
07:02:46 <Beelsebob> why not?
07:02:49 <Beelsebob> what's the difference?
07:03:00 <ertai> I would like:
07:03:10 <Beelsebob> with maybe you provide a zero value, a function f to fold on, and a Maybe to fold
07:03:12 <byorgey> ertai: foldr and maybe are church-encodings of list and Maybe respectively.  but maybe you are thinking of a different generalization.
07:03:13 <Beelsebob> looks like fold to me
07:03:19 <ertai> list nil cons [] = nil
07:03:28 <kpreid> I bet ertai wants a non-recursive function
07:03:29 <ertai> list nil cons (x:xs) = cons x xs
07:03:44 <byorgey> aha
07:03:52 <ertai> however for maybe they are the same
07:03:53 <Beelsebob> ah, a shalow fold essentially
07:04:53 <ertai> that's not terribly missing but can be useful in a pipeline of functions
07:05:00 <byorgey> ertai: I don't think that function already exists in the standard libraries.
07:06:56 <ertai> I'm wondering if it could be the definition of some class method (Traversable, Foldable...)
07:07:03 <EvilTerran> ertai, i want the same thing, really
07:07:06 <ertai> however I've check these
07:07:34 <EvilTerran> i think uniplate might do that
07:07:46 <ertai> hum, possible...
07:08:44 <EvilTerran> ?where uniplate
07:08:44 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/uniplate/
07:10:18 <EvilTerran> hm. seems not.
07:12:28 <EvilTerran> that'd be instance Uniplate [a] where uniplate [] = ([], \[] -> []); uniplate (x:xs) = ([xs], \[xs] -> x:xs) -- i think
07:14:54 <byorgey> doesn't that seem just a tad, um, excessive?  ;)
07:14:56 <Beelsebob> so is that a no to ppl having tried using Haskel -> Python calls?
07:15:06 <EvilTerran> byorgey, indeed, it strikes me as somewhat redundant
07:15:10 <byorgey> Beelsebob: glguy has done it I think
07:15:11 * Beelsebob suspects he's gonna have to use Haskell -> C -> Python
07:15:12 <EvilTerran> that'd be why it's not a standard instance
07:15:20 <Beelsebob> byorgey: cool, I'll poke him if I see him
07:15:32 <byorgey> Beelsebob: he was using pygments for the new hpaste IIRC
07:15:41 <Beelsebob> interesting
07:16:12 <Beelsebob> I'm in need of the ability to call out to the lego robots NXT APIs
07:16:26 <Beelsebob> so robotlang can do shinies
07:16:31 <EvilTerran> ertai, given that at least two of us want it, maybe now i'll feel justified in lobbying to get it put in 6.10's Data.List :)
07:17:10 <ertai> EvilTerran: why not, but what would be a good name for it?
07:17:16 <EvilTerran> "list" looks fine to me
07:17:28 <EvilTerran> to go with "maybe" and "either"
07:18:16 <ertai> EvilTerran: ok, then what's the process
07:20:57 <ertai> Moreover I'm wondering if a list version of formMaybe could be added too
07:21:02 <EvilTerran> alternatively, "class Destruct a b where { type fs; destruct :: fs -> a -> b }; instance Destruct [a] b where type fs = (b, a -> [a] -> b); destruct (nil, cons) [] = nil; destruct (nil, cons) (x:xs) = x `cons` xs" :P
07:22:16 * EvilTerran notes you could make a Fold class likewise, but neither such class is actually particularly useful as a class, just as a hack to share the same name across different types
07:22:45 <EvilTerran> i don't know what the process is...
07:22:57 <Beelsebob> Wow
07:23:16 <Beelsebob> one of my students has managed to write some code that breaks both Ghc and Hugs
07:23:42 <Beelsebob> both of them sit trying to compile the code for about 10 minutes at 100% CPU usage and the asplode with internal erros
07:23:44 <Beelsebob> errors
07:23:49 <EvilTerran> "instance Destruct () b where type fs = b; destruct b () = b" ;)
07:24:29 <matthew_-> yeah, like Hugs can even parse type families
07:24:59 <dolio> Beelsebob: glguy wrote a Haskell -> Python bridge recently.
07:25:01 <EvilTerran> matthew_-, well, i could've elected to express it as fundeps, but i figured type families are more of the flavour du jour
07:25:02 * byorgey suggests extra credit for Beelsebob's student =)
07:25:04 <dolio> For hpaste2.
07:25:19 <EvilTerran> Beelsebob, can you paste it? i'm intrigued.
07:25:41 <matthew_-> EvilTerran: yeah, they du jour, but I still really love the relational style of fundeps. Even though they are slightly clunky
07:26:01 <EvilTerran> i agree, really. type families're painfully verbose in comparison, imo.
07:26:59 <matthew_-> well, they're less clunky in that you can in some cases not use classes and just do type family Foo ...
07:27:21 <EvilTerran> that's true. the associated ones're clunky, though
07:27:27 <matthew_-> agreed.
07:27:36 <Beelsebob> EvilTerran: unfortunatel, no
07:27:37 <matthew_-> However, they have recently saved my arse
07:27:39 <dolio> EvilTerran: You should look at Control.Recursion in category-extras. That has all sorts of recursion combinators using fixpoints and shape functors.
07:27:41 <Beelsebob> it's an assesment
07:27:44 <Beelsebob> so I can't poke it
07:27:44 * EvilTerran notes that he could probably've written his class with just an unassociated type family
07:27:55 <syntaks> erm... how do I catch the exception that occurs when read can't parse a value as in (read "x") :: Int?
07:28:07 <EvilTerran> ?src Read
07:28:07 <lambdabot> class Read a where
07:28:07 <lambdabot>   readsPrec    :: Int -> ReadS a
07:28:07 <lambdabot>   readList     :: ReadS [a]
07:28:07 <lambdabot>   readPrec     :: ReadPrec a
07:28:07 <lambdabot>   readListPrec :: ReadPrec [a]
07:28:17 <EvilTerran> ?src ReadS
07:28:17 <lambdabot> Source not found. Do you think like you type?
07:28:22 <EvilTerran> ...
07:28:23 <matthew_-> @instances MonadPlus
07:28:26 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
07:28:37 <EvilTerran> ?hackage Control.Recursion
07:28:37 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Control.Recursion
07:28:53 <matthew_-> @type read
07:28:55 <lambdabot> forall a. (Read a) => String -> a
07:28:55 <dolio> @hackage category-extras
07:28:55 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/category-extras
07:29:01 <matthew_-> ew, it must call error
07:29:18 <EvilTerran> syntaks, if you've got a bit of IO monad handy, you can use readIO
07:29:26 <EvilTerran> ?type reads
07:29:27 <lambdabot> forall a. (Read a) => String -> [(a, String)]
07:29:43 <EvilTerran> or you can use that - it returns a list of all possible parses, so an empty list on failure
07:29:53 <EvilTerran> dolio, ta
07:29:54 <syntaks> that sounds good
07:30:00 <syntaks> EvilTerran, thanks
07:30:25 <matthew_-> > (readIO "a" :: IO Int) `mplus` (return 5)
07:30:27 <lambdabot>  <IO Int>
07:30:35 <matthew_-> grr. that does work. ;)
07:31:12 <EvilTerran> ?hoogle catch
07:31:12 <lambdabot> Prelude.catch :: IO a -> (IOError -> IO a) -> IO a
07:31:13 <lambdabot> Control.Exception.catch :: IO a -> (Exception -> IO a) -> IO a
07:31:13 <lambdabot> System.IO.Error.catch :: IO a -> (IOError -> IO a) -> IO a
07:31:56 <EvilTerran> matthew_-, i'm guessing there's an instance MonadPlus IO where x `mplus` y = x `catch` const y --?
07:32:21 <dolio> @src IO mplus
07:32:21 <lambdabot> m `mplus` n = m `catch` \_ -> n
07:32:26 <matthew_-> I would assume so. There's certainly an instance
07:32:32 <matthew_-> there we are then
07:32:39 <EvilTerran> dolio, heh. quite so.
07:33:04 <EvilTerran> using reads is probably neater a lot of the time, mind.
07:33:24 <matthew_-> I'm not necessarily advocating using mplus over catch though. Catch is probably quite a lot clearer.
07:33:38 <gnuvince> :t catch
07:33:41 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
07:33:46 <EvilTerran> listToMaybe [x | (x,"") <- reads str]
07:34:05 <yitz_> EvilTerran: dons proposed maybeRead
07:34:22 <EvilTerran> yitz_, which'd be pretty much what i just wrote?
07:34:30 <yitz_> yep
07:34:32 <matthew_-> why specialise it to maybe? surely anything in MonadPlus would be good
07:34:58 <EvilTerran> anything in Alternative!
07:35:03 <yitz_> matthew_: and that was the continuation of the discussion on cafe after dons proposed it.
07:35:23 <dolio> > read "1234    " :: Int
07:35:25 <lambdabot>  1234
07:35:34 <dolio> It gets that sort of thing wrong, too.
07:35:38 <yitz_> predictably, some people wanted to generalize it to any monad using fail. ugh.
07:35:50 <EvilTerran> > reads "1234    " :: [(Int, String)]
07:35:51 <lambdabot>  [(1234,"    ")]
07:35:53 <EvilTerran> hm.
07:35:59 <quicksilver> well that's easy to fix.
07:36:04 <quicksilver> just depends how you define 'wrong'
07:36:09 <EvilTerran> > read "1234 warghlebargle" :: Int
07:36:10 <lambdabot>  Exception: Prelude.read: no parse
07:36:26 <quicksilver> you can use lex, I think, to fix that part
07:36:30 <quicksilver> :t lex
07:36:30 <dolio> read only ignores extra whitespace.
07:36:31 <lambdabot> String -> [(String, String)]
07:36:31 <matthew_-> yitz_: well we all know that fail shouldn't be in Monad anyway... ;)
07:36:37 <quicksilver> lex "1234   "
07:36:42 <yitz_> conal then posted simple mayM and mayA combinators that lift anything in Maybe to any MonadPlus or Applicative. So there you have it.
07:36:44 <EvilTerran> yitz_, see, i avoid that sort of thing by suggesting Alternative instead of anything Monadic ;)
07:36:44 <quicksilver> > lex "1234   "
07:36:45 <lambdabot>  [("1234","   ")]
07:36:59 <yitz_> s/Applicative/Alternative/
07:37:12 <yitz_> yeah :)
07:37:30 <dolio> yitz_: Yeah, but that loses information about why the parse failed, if you want that sort of thing.
07:37:35 <EvilTerran> > lex "    "
07:37:36 <lambdabot>  [("","")]
07:38:01 <EvilTerran> yeah, going via Maybe will lose you some info. might be better to go via Either
07:38:08 <dolio> Yeah.
07:38:16 <EvilTerran> or just go direct, and write loads of instances ;)
07:38:26 <Saul_> Is there a library for disjoint sets?
07:38:32 <matthew_-> and then you go the whole hog and end up at ErrorT (Either String) a
07:39:04 <dolio> Well, I suggested using fail, but restricting the type to MonadPlus, which would presumably have proper fail implementations.
07:39:04 <quicksilver> nah, you don't
07:39:06 <yitz_> dolio: yes. I proposed using (Read a, Error e, MonadError e m) => String -> m a. But not seriously though, because no one wants a global dependency on mtl. sigh.
07:39:19 <quicksilver> you end up at MonadError e m => m a
07:39:24 <quicksilver> as yitz_ says
07:39:37 <dolio> But that didn't seem to be liked by the anti-fail people.
07:39:45 <quicksilver> ErrorT should never appear in library types
07:40:02 <quicksilver> (in visible type signatures I mean)
07:40:31 <yitz_> anyway, you can easily lift to it.
07:41:18 <yitz_> dolio: in MonadPlus, fail is pronounced "mzero"
07:41:35 <dolio> Well, it isn't, though, because mzero doesn't take a string.
07:42:08 <dolio> If you restructured the classes, fail would be better in MonadPlus, though, interdefined with mzero.
07:42:21 <dolio> Or, really, in MonadZero, but we don't have that, currently.
07:42:26 <yitz_> @src Maybe fail
07:42:26 <lambdabot> fail _      = Nothing
07:42:56 <glen_quagmire> > fail undefined
07:42:56 <lambdabot>   add an instance declaration for (Show (m a))
07:42:58 <yitz_> dolio: so yeah, it takes a string, but...
07:43:08 <glen_quagmire> > fail undefined :: Maybe Int
07:43:08 <lambdabot>  Nothing
07:43:41 <dolio> The important part of fail in readM is that you can report whether the read failed due to no parses or multiple parses.
07:45:04 <dolio> It isn't visible in Maybe, but it is in either, for example.
07:45:42 <dolio> And ErrorT, and IO (I think)...
07:46:44 <yitz_> > let readMany = unfoldr $ listToMaybe . concatMap reads . tails in readMany "34, 56, 79; 10, and 20." :: [Int]
07:46:45 <lambdabot>  [34,56,79,10,20]
07:47:00 <oklofok> @die 1d2
07:47:00 <lambdabot> 1d2 => 1
07:47:11 <dolio> That would allow readM to subsume readIO as well, for instance.
07:47:20 <EvilTerran> yitz_, er, that's perverse
07:48:53 <yitz_> > let readMany = unfoldr $ listToMaybe . concatMap reads . tails in readMany "There is Nothing of Any Value in This String, Just a Bunch of Silly Words" :: [Maybe String]
07:48:54 <lambdabot>  [Nothing]
07:48:57 <dolio> @die 1000000d1000000
07:48:57 <lambdabot> 1000000d1000000 => 500092180643
07:49:27 <yitz_> > let readMany = unfoldr $ listToMaybe . concatMap reads . tails in readMany "There is Nothing of Any Value in This String, Just 13 Silly Words" :: [Maybe Int]
07:49:28 <lambdabot>  [Nothing,Just 13]
07:50:33 <glen_quagmire> traverse eval env   where env :: Map String Val; eval :: Val -> Wrap Val;    how can I make sure eval acutally gets called?
07:51:02 <glen_quagmire> it seems like (traverse eval env) doesn't seem to actually evaulate things
07:51:10 <yitz_> That function is actually very useful for parsing free-form user input after prompting for a bunch of stuff, without needing a messy regexp.
07:52:04 <glen_quagmire> yitz_: niffy
07:54:32 <EvilTerran> @faq can i do nifty one-liners for NLP in haskell using only standard library functions?
07:54:32 <lambdabot> The answer is: Yes! Haskell can do that.
07:55:23 <yitz_> @faq What is the answer to any question?
07:55:23 <lambdabot> The answer is: Yes! Haskell can do that.
07:57:23 <yitz_> @vixen What is the answer to any question?
07:57:23 <lambdabot> what was the question again?
07:57:33 <yitz_> that's better
07:58:20 <xerox> ?faq can Haskell have such a comprehensive faq?
07:58:20 <lambdabot> The answer is: Yes! Haskell can do that.
07:59:30 <paczesiowa> do any of you know what exactly does kdevelop's haskell support look like? there are no project templates or plugins
08:00:42 <Twey> Can Haskell work with ActiveX?
08:01:07 <Peaker> augustss, are you here?
08:03:10 <malsyned> Is there a mature alternative to Network.HTTP that uses unsafeInterleaveIO for the byestream containing the HTTP response payload?
08:04:10 <malsyned> I'm writing an HTTP downloader app and I want to add a progress indicator
08:04:16 <Peaker> Any idea if augustss's trickery with lvalues/rvalues (http://augustss.blogspot.com/2007/08/programming-in-c-ummm-haskell-heres.html) would also allow to define ptr-like semantics?  A p <- (takePtr a) function that later lets you modify a via (deref p) ?
08:04:17 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2948p6
08:04:40 <paczesiowa> malsyned: take a look at curl bindings
08:05:27 <paczesiowa> malsyned: curl has examples in c docs of progress indicators, you just need to port it to haskell
08:06:03 <malsyned> paczesiowa: thanks
08:08:01 * Beelsebob has never understood people's facination with writing C in Haskell
08:08:05 <Beelsebob> write Haskell in Haskell already
08:08:59 <malsyned> Beelsebob: I know that when I first started using Haskell, I wanted to make sure that things I frequently did in other languages would still be easy in Haskell.  That could be where some of the motivation is from.
08:09:23 <Beelsebob> malsyned: yes, but that doesn't mean that you should do said frequently done things in the same style
08:09:31 <Beelsebob> e.g. you frequently write while loops in C
08:09:54 <Beelsebob> but you should probably translate them to primitave recursion or calls to higher order functions when you write Haskell
08:10:03 <Beelsebob> instead of abusing Haskell until you can write something loop like
08:10:14 <malsyned> Beelsebob: true.  but there is a certain amount of comfort to be gained from knowing that, if you're not clever enough or knowledgeable enough at Haskell to get the "right" way to do it, you can still slog through with your old habits.
08:10:24 <Beelsebob> true
08:10:38 <Beelsebob> the only problem is that you have to be cleverer to do that, than you do to do it the Haskell way
08:10:43 <newsham> yah, that augustss, what a non-haskell programmer.
08:10:57 <Beelsebob> as we see from the fact that people are writing articles on how to do it
08:11:01 <Peaker> Beelsebob, Actually, I don't want to use that to write C in Haskell
08:11:15 <Peaker> Beelsebob, I am in a discussion where i am trying to prove to someone Haskell does indeed support imperative programming
08:11:23 <malsyned> Beelsebob: and you miss out on all of the useful lessons that you can learn from writing Haskell in Haskell.
08:11:27 <Beelsebob> ah, interesting
08:11:50 <Philippa> Peaker: don't forget to show them things like mapM/mapM_, then
08:11:50 <Beelsebob> malsyned: okay, sure, from a purely accademic point of view, it's nice to learn lessons from it
08:11:59 <Peaker> Beelsebob, I am in awe with that C-in-Haskell - it shows me that Haskell has this cool power. Not that I should use that power :-)
08:12:07 <Philippa> or even sequence, which coupled with the right list gets you any loop you want
08:12:51 <Philippa> Beelsebob: that, and knowing that you can do well-factored imperative code in haskell is indeed useful
08:12:51 <Philippa> you just don't necessarily want to do it as if it were C
08:13:04 <malsyned> Philippa: that's something that's been a real revelation for me using Haskell - that lists can be used in places where loops are used in other languages.  The two don't really strike me as compatible concepts, but somehow it works.
08:13:12 <newsham> "and you miss out on all of the useful lessons that you can learn from writing Haskell in Haskell.
08:13:16 <ertai> I don't understand that type error http://hpaste.org/6621#a0 does someone see the issue?
08:13:16 <Beelsebob> Philippa: tbh, if I want to do imperative code, I'll use an imperative language
08:13:24 <newsham> not entirely.  you can write something imperatively, and then transform it step-by-step
08:13:26 <Beelsebob> if I want to call said imperative code from Haskell I'll use the FFI
08:13:31 <newsham> ase higher order imperatives
08:13:32 <newsham> etc.
08:13:35 <Beelsebob> rather than abusing Haskell until it looks vaguely right
08:13:37 <newsham> how is that missing out on the poewr of haskell?
08:14:05 <Beelsebob> there's no point in using a power drill (Haskell), as a saw, when you could just put down the power drill for a minute and pick up a saw
08:14:05 <newsham> s/ase/use/
08:14:30 <Philippa> except for the part where the power drill actually in many regards makes a better saw
08:14:41 <Beelsebob> (other than it might be an interesting task to prove that power drills can be used as saws)
08:14:45 <newsham> there's no point using an analogy as a saw, when you can just put down the analogy and use a saw
08:14:58 <Philippa> really, aside from the part where your code tends to end up A-normalised to fit do notation it's actually a better imperative lang than most
08:15:00 <Beelsebob> newsham: a bad analogy is like a leaky screwdriver :)
08:15:00 <Peaker> can a concept similar to IORef's (readIORef, writeIORef) be implemented in Haskell (As in, not be built-in in some magical monad)?
08:15:40 <Philippa> Peaker: I think it can be done with GADTs, definitely not in Haskell 98 though
08:15:42 <allbery_b> STRefs?
08:15:42 <newsham> you can even start dropping the do-notation and using lifted functions
08:15:48 <wli> Haskell has all the mutation etc. imperative languages have. It just has a way of enforcing discipline in their use.
08:15:52 <Philippa> allbery_b: is built-in in a magical monad
08:15:55 <Beelsebob> Philippa: I think it could be done with Haskell 98
08:16:00 <Beelsebob> it might be slow though
08:16:08 <Beelsebob> you'd have to represent "memory" as a big hash table
08:16:12 <Beelsebob> and carry it arround with you
08:16:15 <Philippa> Beelsebob: it can't. Try typing it
08:16:21 <allbery_b> hm, I thought the only magic was the forall gate
08:16:24 <Philippa> you need a polymorphic heap, and you can't build it
08:16:32 <Peaker> Beelsebob, great, I don't care about slow now, just about "possible" :)
08:16:35 <Beelsebob> Philippa: you do the same trick C does, bin all types and call everything a void *
08:16:51 <Beelsebob> not nice
08:16:55 <Beelsebob> but would work
08:17:01 <newsham> peaker: State?
08:17:15 <Philippa> Beelsebob: Data.Dynamic isn't part of Haskell 98 either
08:17:27 <glen_quagmire> data Object = All | Imaginable | Types ...
08:17:35 <newsham> data Locals = Local { a :: Int, i :: Int }
08:17:39 <Beelsebob> no, but my new type VoidPtr which I'm going to use everywhere is Philippa
08:17:45 <newsham> gets a
08:17:53 <Peaker> newsham, not exactly State, but something like IORef which has an "identity", such that I can use: writeIORef (readIORef ptr1) blah   and   writeIORef (readIORef ptr2) bleh   and both of these would write to the "slot" of the same identity
08:18:18 <Beelsebob> type Memory = VoidPtr -> Word8
08:18:19 <Beelsebob> ....
08:18:19 <newsham> peaker: why cant i do that using reads?
08:18:23 <Philippa> Beelsebob: if you use the FFI then you can do it, yes. Though you'll have to be more subtle about it IIRC
08:18:25 <Philippa> otherwise no, you can't
08:18:34 <Beelsebob> Philippa: I think you can without the FFI
08:18:35 <Peaker> newsham, maybe you can, but "State" isn't it
08:18:39 <Beelsebob> you just lose a lot of nice stuff
08:18:44 <Philippa> Beelsebob: like the required interface
08:18:46 <Beelsebob> like being able to use any type other than VoidPtr
08:18:56 <Philippa> congratulations, you just built a monomorphic heap again
08:19:01 <gnuvince> Is it possible to create data definitions in GHCi?
08:19:01 <Beelsebob> exactly
08:19:09 <Beelsebob> so it can be done
08:19:13 <Philippa> no, it can't
08:19:15 <Philippa> read the types
08:19:19 <Philippa> *you can't implement that*
08:19:29 <Beelsebob> where am I going to get a type error?
08:19:44 <Beelsebob> if *all data* has type VoidPtr
08:19:58 <quicksilver> Beelsebob: then you're no implement what was asked for.
08:20:10 <Philippa> read the types of the IORef and STRef ops, Beelsebob
08:20:13 <quicksilver> Beelsebob: IORef is a polymorphic type constructor
08:20:18 <Beelsebob> ah, okay
08:20:19 <Beelsebob> fair enough
08:20:25 <Beelsebob> I see what you're getting at now
08:20:35 <Philippa> when people say Haskell's the world's finest imperative language, there are reasons :-)
08:20:40 <quicksilver> you can implement 'IORefs which are all Ints'
08:20:41 <quicksilver> certainly
08:20:50 <quicksilver> or any particular fixed set of tpes.
08:20:55 <newsham> read ref a = "gets a", write ref a = "modify (\l -> l {a=v})"
08:20:57 <Philippa> quicksilver: even that's a bit tricky without the FFI
08:21:04 <Philippa> if you get your own monad, that's different
08:21:10 <sclv_> or for all Typeables
08:21:17 <quicksilver> I was assuming I got my own monad, yes.
08:21:19 <Philippa> sclv_: Haskell 98
08:21:37 <quicksilver> sclv_: in a haskell 98 context, Typeable is basically some particular fixed set of types.
08:21:44 <quicksilver> ;)
08:21:53 <sclv_> ok, this is true.  i missed that criteria. :-)
08:22:05 <quicksilver> but you will need unsafeCoerce to cope with types which hadn't been invented when you wrote your program.
08:22:14 <quicksilver> (Data.Dynamic uses unsafeCoerce)
08:22:17 <Philippa> Peaker: I'm pretty certain it can be done in System Fc though, and from there very probably with GADTs
08:22:35 <Philippa> you'd be doing so within your own monad (which can be a MonadIO still) though
08:22:48 <Philippa> because you need a slice of state to carry around the heap
08:22:53 <Philippa> make any sense?
08:22:58 <ertai> I don't understand that type error http://hpaste.org/6621#a0 does someone see what's the issue?
08:23:10 <sclv_> usafeCoerce can be written with just unsafePerformIO though...
08:23:28 <Philippa> ertai: what's the error?
08:23:59 <ertai> the error is there http://hpaste.org/6622#a0
08:25:41 <Philippa> no it isn't
08:25:46 <Philippa> the erroneous code may be
08:26:07 <quicksilver> Philippa: different past :)
08:26:09 <quicksilver> paste.
08:26:47 <quicksilver> ertai: 'C' is a class which relates 'm' and 'a'.
08:27:05 <quicksilver> ertai: when using pureModifier, there is no clue to the compiler which 'm' to use.
08:27:14 <quicksilver> ertai: because the types of pureModifier don't mention m
08:27:31 <quicksilver> therefore it can't deduce that m & m2 are the same (in the error it gives)
08:29:03 <glen_quagmire> ertai: maybe F should derive Monad?
08:29:22 <byorgey> would a functional dependency  a -> m  fix it?
08:30:59 <quicksilver> yes, very likely.
08:31:27 <quicksilver> the other option is a dummy parameter with an m type
08:31:31 <quicksilver> to pureModifier
08:33:49 <ertai> quicksilver, byorgey, glen_quagmire: thanks all, the fun dep seems fine for me
08:33:49 <glen_quagmire> nevermind. F being Monda doesnt fix it
08:38:04 <zeroflagWork> mauke: around?
08:38:27 <mauke> zeroflagWork: yes
08:38:39 <zeroflagWork> mauke: just wanted to let you know that my C++ parser now understands the first test.cpp file... :]
08:38:52 <mauke> nice :-)
08:41:40 <zeroflagWork> mauke: I'm currently precompiling OGRE for the next tests. :P
08:42:25 <mauke> zeroflagWork: I've written http://mauke.ath.cx/stuff/vim/perl-mauke-0.08.vim
08:43:06 <zeroflagWork> to get rid of the perl/python/c/something syntax? :P
08:48:15 <Ben___> hello, a question, what version of happs need to hpaste?
08:49:30 <Peaker> I want to have an inner IO action throw an exception indicating the will to exit, such that the mainloop can catch it - should I use throwIO?
08:52:58 <quicksilver> Peaker: throwDyn is preferred.
08:54:30 <Peaker> quicksilver, thanks, I'll look that up
08:55:50 <quicksilver> Peaker: just because it lets you choose your own type for the custom exception
08:55:53 <quicksilver> which is nice and clean.
08:56:06 <Peaker> does it use any sort of runtime typing for this?
08:56:12 <Peaker> or is it all compile-time trickery?
09:01:09 <quicksilver> Peaker: it uses a very weak sort of runtime typing
09:01:33 <quicksilver> Peaker: "cooperative" runtime typing, if you like, because the type has to 'cooperate' by instancing the typeable class to define a type representation.
09:01:39 <quicksilver> (but you can ask GHC to do that for you)
09:01:43 <roconnor> why not throwIO a  userError ?
09:01:59 <quicksilver> and you can violate type safety by deliberately supplying a broken instance
09:02:03 <quicksilver> roconnor: no strong reason.
09:02:10 <Peaker> quicksilver, what happens if I break type safety?
09:02:12 <quicksilver> I just think throwDyn with a fresh type is cleaner.
09:02:19 <roconnor> throwIO is portable.
09:02:24 <Peaker> can I make it segfault?
09:02:27 <quicksilver> Peaker: then you can access the internal representation of one type as another type
09:02:36 <quicksilver> that can cause a segfault, yes.
09:02:36 <Peaker> quicksilver, evil
09:02:50 <quicksilver> roconnor: true, but that's not something I care about.
09:03:04 <quicksilver> I'm not interested in haskell implmentations which don't support data.dynamic.
09:03:05 <roconnor> quicksilver: oh, interesting view.
09:03:07 <quicksilver> (it's not hard to do)
09:03:53 <Peaker> quicksilver, I can envision an alternate pure-compile-time approach where the type inference adds a new Either type layer for each action you call, according to the types of errors it can raise
09:04:05 <quicksilver> yes, I can imagine that too
09:04:16 <Peaker> quicksilver, generating a complete compile-time specification of all exceptions that can be thrown - which sounds like a good thing
09:04:17 <quicksilver> but you'd
09:04:20 <quicksilver> yeah
09:04:25 <quicksilver> it would be, in some ways.
09:04:43 <quicksilver> but it could require unrelated code to need updating, in some cases
09:04:49 <quicksilver> to 'pass through' the exception types
09:04:53 <quicksilver> if you were doin explicit type sigs.
09:05:05 <quicksilver> it's really the same pros/cons as the Java 'throws' clause.
09:05:16 <quicksilver> (except we'd have type inference! much more convenient)
09:05:54 <Peaker> yeah, so more pros, less cons :-)
09:06:02 <masklinn> @pl (concat .) . map
09:06:02 <lambdabot> (=<<)
09:06:07 <Peaker> So breaking binary-level compatibility is the main con?
09:06:18 <quicksilver> not what I meant, actually
09:06:29 <quicksilver> I just meant the inconvenience of having to alter 'middle layer' modules
09:06:36 <quicksilver> because you added an exception at the 'bottom layer'
09:06:43 <quicksilver> and you had explicit type sigs in the middle.
09:06:46 <quicksilver> in a large system.
09:06:57 <quicksilver> it's a scaling question.
09:07:48 <quicksilver> it would be interesting to mock something up with MPTCs and see if it seemed usable.
09:08:00 <Peaker> I see, but your explicit type-sig could contain either explicit exceptions or some type that abstracts away the possible exceptions - such that they are inferred automatically
09:08:02 <quicksilver> it's rather likely someone has tried before :)
09:08:05 <Peaker> MPTC?
09:08:12 <quicksilver> multi-parameter typeclass
09:08:23 <quicksilver> I'm thinking 'Throws e m', or similar
09:08:40 <Peaker> @undo do { (a b) where a x = x ; b x = 2*x }
09:08:40 <lambdabot>  Parse error at "where" (column 12)
09:08:49 <Peaker> what are the rules regarding where clauses in do's?
09:08:52 <quicksilver> (Throws ArithmeticException m, Throws NetworkException m) => m ()
09:09:11 <quicksilver> where clauses go on definitions and case clauses
09:09:25 <quicksilver> not on (general) expressions.
09:09:37 <Peaker> quicksilver, that sounds great, if   (Throws any m) => m ()   was possible
09:09:51 <quicksilver> well, it would be.
09:10:00 <quicksilver> you can always universally quantify.
09:10:05 <quicksilver> :)
09:10:11 <monochrom> (Referring to the haskell-cafe message "separate input calculation output")  "In another language I would use global variables"  Now I see why programming in other languages are so error-prone, and why Haskell is so hard. :)
09:10:12 <quicksilver> but there are more subtle things you might want to say
09:10:22 <Peaker> then why isn't that the usual way of throwing in Haskell? :)
09:10:25 <Peaker> what kinds?
09:10:26 <quicksilver> and that's where it gets tricky
09:10:39 <quicksilver> you might want to mention some and not others
09:11:17 <Peaker> If the Java model is usable then having all-or-nothing should be at least as usable
09:11:25 <Peaker> most languages use the nothing model
09:11:45 <monochrom> http://www.haskell.org/pipermail/haskell/2004-June/014271.html  is the first message I saw this from.
09:11:45 <lambdabot> Title: [Haskell] Exceptions in types and exception-free programming
09:13:27 <quicksilver> Peaker: the design space is a bit more complex than it appears at first glance.
09:13:36 <quicksilver> oleg's message might be somewhat illuminating.
09:14:10 <Peaker> actually, now that I think about it, the Java/Python approach of catching based on exception type is also inadequate, at least with the way it is used within those languages..
09:14:30 <Peaker> Its impossible to catch what you want without the specification being too broad
09:15:24 <Peaker> for example, the other day I encountered a bug in a Python package, it used:  "try: import Something except ImportError: print 'Module Something does not exist'" -- when in fact there was an error in a deeper import inside the module
09:15:51 <Peaker> you might want to narrowly specify: "Catch the specific case where the module itself does not exist"
09:15:57 <Peaker> though its unclear how its best to specify that
09:23:29 <Peaker> http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors  uses Typeable, but ghc 6.6.1 wants me to use -fglasgow-exts to derive an instance for this class
09:23:30 <lambdabot> Title: 8 ways to report errors in Haskell, http://tinyurl.com/2yz77l
09:25:33 <Peaker> is Typeable a Glasgow extension?
09:27:46 <Baughn> Peaker: No, but the derivation is
09:28:07 <Baughn> Peaker: You can define your own easily, and indeed there's a pattern that allows for simple derivation, it just isn't in the standard
09:28:29 <matthew-_> can you have a where clause for a whole class instance?
09:28:30 <Peaker> oh, ok
09:28:44 <quicksilver> matthew-_: I strongly suspect not.
09:28:52 <matthew-_> that sucks
09:29:08 <quicksilver> the syntax would be a bit screwy if you could
09:29:14 <quicksilver> instance Foo Bar where ... where ...
09:29:18 <matthew-_> meh
09:29:40 <ddarius> Especially as 'instance Foo Bar' is syntactically valid.
09:30:39 <matthew-_> well, if you had instance Foo Bar on its own then there are no methods, so it would make no sense to have a where clause
09:30:44 <matthew-_> so it's not ambiguous at all
09:30:50 <Peaker> where can I find good-style examples of catchDyn? I can't seem to use "where' inside a "do" so it looks like: catchDyn runLoop quitHandler  and its unreadable to stick the entirety of the code in there, and I currently use runLoop <- return (code) ; quitHandler <- return (code)  but that's ugly
09:31:06 <ddarius> matthew-_: Semantically, no.
09:32:20 <mauke> er
09:32:33 <mauke> let { runLoop = code; quitHandler = code }; ...
09:32:34 <matthew-_> besides, where clauses can be nested anyway
09:32:51 <matthew-_> foo x y = blah where blah = case e of ... where e = ...
09:33:04 <ddarius> matthew-_: I'm talking about the empty bindings case.
09:33:10 <Peaker> matthew-_, inside a do block? It seems to not have access to the lexical scope that way
09:33:19 <matthew-_> ddarius: yes sure.
09:33:24 <matthew-_> anyway...
09:33:29 <quicksilver> Peaker: you can either use let, or you can put the where just outside the do block
09:33:30 <Peaker> mauke, that would not have access to previous stuff assigned(<-)  in the "do" block, would it?
09:33:39 <mauke> Peaker: why not?
09:33:40 <quicksilver> Peaker: it's quite hard to explain without example code to be honest.
09:33:48 <Peaker> quicksilver, I need the lexical scope from inside the do block
09:34:20 <quicksilver> then you need to use let.
09:34:27 <Peaker> http://hpaste.org/6623
09:34:51 <Peaker> @undo do { a <- b ; let f x = a*2 in f 5 }
09:34:51 <lambdabot> b >>= \ a -> let { f x = a * 2} in f 5
09:34:59 <Peaker> ohh, I thought the let was taken outside before the entire do
09:35:18 <quicksilver> any time you have x <- return (foo) it's probably clearer to write let x = foo
09:35:39 <quicksilver> personally I wouldn't bother to name runLoop and quitHandler though.
09:35:49 <quicksilver> I'd just use them as expressions.
09:35:57 <mauke> is haskell.org down?
09:35:59 <quicksilver> (possibly with an infix catchDyn)
09:36:28 <matthew-_> mauke: not working for me
09:36:30 <Peaker> oh, its "let x=foo" without the "in" when in a do block, now I understand let in ghci
09:36:34 <quicksilver> ;)
09:36:49 <Baughn> > let quine s = "> " ++ s ++ show s in quine "let quine s = \"> \" ++ s ++ show s in quine "
09:36:53 <lambdabot>  "> let quine s = \"> \" ++ s ++ show s in quine \"let quine s = \\\"> \\\" +...
09:37:37 <mauke> :t takeWhileM
09:37:39 <lambdabot> Not in scope: `takeWhileM'
09:38:17 <Peaker> how do I get GC statistics/etc again?
09:38:30 <Peaker> mauke, I wrote it to repeat SDL's pollEvent until NoEvent is returned
09:39:02 <mauke> are you sure you want (\Quit -> return ())?
09:39:54 <yuriyp> @where alternate
09:39:54 <lambdabot> I know nothing about alternate.
09:40:43 <mauke> oh, do you have data Quit = Quit somewhere?
09:42:00 <mauke> Peaker: http://hpaste.org/6623#a1
09:43:16 <yuriyp> @hoogle a -> a -> [a]
09:43:17 <lambdabot> Data.List.genericReplicate :: Integral i => i -> a -> [a]
09:44:42 <mauke> :t flip (:) . return
09:44:43 <lambdabot> forall a. a -> a -> [a]
09:45:17 <yuriyp> :-)
09:45:51 <mauke> @pl \x y -> [x, y]
09:45:51 <lambdabot> (. return) . (:)
09:48:35 <psnively> Is it time to write a FPS or RTS game in Haskell?
09:49:10 <ddarius> There have been one or two FPS and I think someone made some kind of RTS.
09:49:11 <bos> no reason why it shouldn't be doable. all it requires is ... people.
09:49:17 <bos> yes, frag.
09:49:23 <mauke> monadius
09:49:46 <matthew-_> sessions-2008.3.25 released. Get it while it's hot.
09:50:56 <xerox> What is it?
09:51:26 <psnively> Er, I meant something better than frag. :-)
09:51:36 <newsham> has anyone thought of making an Eclipse module for haskell
09:51:46 <ddarius> There's EclipseFP
09:51:48 <dolio> @seen kuribas
09:51:48 <lambdabot> I haven't seen kuribas.
09:53:43 <dolio> @tell kuribas haskell-indentation doesn't like type instance declarations (it seems to be okay with type family).
09:53:43 <lambdabot> Consider it noted.
09:54:43 <quicksilver> newsham: plenty of people have thought of it.
09:54:59 <newsham> thats all I could ask for I guess :)
09:55:16 <quicksilver> newsham: unfortunately, writing eclipse modules is slightly more pleasant than consuming cockroaches whilst running across broken glass being chased by rhinocerouses.
09:55:17 <Philippa> psnively: were you planning on sticking with FRP, or going for a more traditional implementation of the game sim?
09:55:39 <newsham> i'm using eclipse for the first time, seems fairly decent (if not a little real estate inefficient)
09:55:39 <Philippa> Most of the rest can fairly clearly be done, and I think you'll end up with something reasonably nice but still suffering all the usual problems
09:55:57 <Philippa> though I know you could have a lot of fun using something like hs-plugins in place of UnrealScript and the likes
09:56:07 <Philippa> gametype transformers, anyone? :-)
09:56:10 <Peaker> mauke, Yeah I have data Quit = Quit above
09:56:17 <psnively> Hi Philippa. Well, I'd hope for FRP, I guess, but I'm not religious about it.
09:56:32 <Philippa> *nod*
09:56:52 <Philippa> I guess there're also problems about things like extensible record encodings
09:57:03 <quicksilver> newsham: I think eclipse is quite nice for java, if your machine is powerful enough for it. I tried it for a while.
09:57:14 <Philippa> as the last FPS I played with a fixed datatype for all entities was Quake
09:57:19 <Peaker> mauke, thanks for the feedback, using a let now
09:57:19 <psnively> I only sound like I'm religious about when when Achilleas posts on LtU and asks for the grillionth time how you do MVC in a pure functional language.
09:57:26 <Philippa> heh
09:57:49 <quicksilver> newsham: but do some investigation into what is required to write a new eclipse plugin and you'll see where I'm coming from :)
09:58:01 <psnively> Surely there's a reasonable "Expression Problem" solution in Haskell?
09:58:09 <ddarius> There exist solutions...
09:58:20 * ddarius tactfully dropped "reasonable"
09:58:22 <mauke> @go types a la carte
09:58:24 <lambdabot> http://lambda-the-ultimate.org/node/2700
09:58:24 <lambdabot> Title: Data Types a la Carte | Lambda the Ultimate
09:58:25 <Philippa> psnively: not good enough that I've been comfortable using it on actual expressions :-(
09:58:28 <Peaker> and a flipped catchDyn
09:58:37 <mattam> psnively: What's Tim Sweeney's opinion about this ?
09:58:52 <Philippa> and I've been building a batch of interpreters and a framework to make them easy for the last 18 months or so
09:59:12 <Philippa> mattam: Tim's got different constraints
09:59:52 <Philippa> he's got to be fairly careful about which techs he pushes - he called the shift to OO in gamedev right, but he needs to be more conservative about the shift to FP because he's got big commercial customers
10:00:11 <psnively> My overall impression (keeping in mind that I don't talk to Tim every day) is that Tim likes much of Haskell's design but a) doesn't feel laziness is the way to go, and b) finds the syntax an unacceptably high barrier to entry.
10:00:15 <Philippa> but AFAICT he's mostly looking at doing the same old stuff concurrently via STM at the mo
10:00:16 <newsham> quick: I have no intention of writing eclipse code :)
10:00:28 <newsham> but under ideal circumstances I might consider using it
10:00:49 <Philippa> psnively: I think mostly re syntax it's as much the purity doing it - do notation is still ugly for a lot of people
10:01:28 <mattam> What about augustss's syntax ?
10:01:45 <psnively> Philippa: I think he's up to something quite a lot more subversive... imagine a leniently-evaluated language with a pure type system, and something (STM? Uniqueness types?) on top that looks an awful lot like traditional imperative/OO programming...
10:01:46 <quicksilver> Peaker: one of the nice things is that you can write your own combinators
10:02:01 <quicksilver> Peaker: like ignoreQuits a = catchDyn a (\Quit -> return ())
10:02:13 <psnively> He's been quite clear about not having a type/term distinction in his language.
10:02:18 <shepheb> does GHC incorporate Wadler's deforestation algorithm?
10:02:19 <Philippa> psnively: yeah, that's the long-term aim - I imagine STM for UnrealScript will come much sooner
10:02:39 <Philippa> I mean, there's demand for that now
10:02:42 <psnively> Philippa: I doubt that (read: I think the language stuff he's been talking about will appear in Unreal tech 4).
10:02:43 <mattam> There's also dcc, it look like promising combination.
10:02:45 <Peaker> quicksilver, yeah, too many ways to do the same thing :)
10:02:46 <psnively> Of course there is.
10:03:00 <Saul_> shepheb: As far as I know it does
10:03:10 <Philippa> psnively: AFAICT you can do an STM implementation of UnrealScript without altering the language
10:03:26 <ptolomy2> Hm. The Hackage build machine has a diferent version Data.ByteString than I do (i have that one that came with GHC) so the compile for my cabal fails.
10:03:58 <psnively> Philippa: I imagine that's true. I just don't think he will between Unreal tech 3 (i.e., several months ago) and Unreal tech 4.
10:03:59 <dcoutts_> ptolomy2: which package?
10:04:11 <K0MPR3SS0R> hi guys
10:04:11 <psnively> But I am admittedly guessing/reading between the lines.
10:04:18 <K0MPR3SS0R> i have a small itsy bitsy problem
10:04:18 <Philippa> psnively: UTech 3 was mostly 'done' technologically a while ago
10:04:19 <K0MPR3SS0R> http://hpaste.org/6624
10:04:40 <Philippa> and an STM implementation's a fairly orthogonal thing
10:04:42 <K0MPR3SS0R> trying to make a binary search tree with a node value and a count value at the node
10:04:53 <K0MPR3SS0R> getting an error, and I dont see where it is
10:05:11 <Philippa> so I can picture it happening - UTech 4 will, judging by historical trends, be for the generation of consoles after the current one
10:05:13 <psnively> Philippa: the point was only that it doesn't have STM now, so you're suggesting either a) Unreal tech 4 won't include his all-new language, or b) there will be a "3.5" release with STM. I'm saying that I believe a) to be false, and b) to be unlikely.
10:05:35 <ptolomy2> dcoutts_: hiccup-0.40 (which, by the way, is steadily approaching the real Tcl implementation in features and speed.. might be the most complete implementation that isn't the real one)
10:05:54 <Philippa> b) is more likely than you'd think - Deus Ex was based on a late-in-the-day UTech 1, for example, and I believe benefitted from some of the tweaks from UT
10:05:57 * ptolomy2 hasn't talked about it with anyone in months, so he had to mention the progress. :-P
10:05:59 <quicksilver> Peaker: quite. But the point that I'm making is how easy it is to define new ways which are best for a particular case :)
10:06:27 <Philippa> it doesn't change any interfaces, so in many ways it's on a par with "we squeezed a few more cycles out of some of this"
10:06:36 <Peaker> quicksilver, well, I dislike that this approach requires this weird Typeable stuff
10:06:47 <Peaker> quicksilver, (not your suggestion, the whole throw to signal exit)
10:06:48 <dcoutts_> ptolomy2: so your code is not compatible with bytestring-0.9.0.4
10:07:05 <dcoutts_> dons: we should not have added the IsString instance without bumping the api version
10:07:21 <Philippa> and doing a 3.5 release gives a chance to find out who has problems with the tech "in the wild", too
10:07:27 <psnively> Yeah. If he does, cool. But the new language is where the heat is.
10:07:44 <Philippa> agreed, and that's a long way off still
10:07:53 <Philippa> I just hope like hell he doesn't write another single-pass compiler :-)
10:07:59 <psnively> He isn't.
10:08:04 <dcoutts_> ptolomy2: so you have two options, declare that it is not compatible with that version, or fix your code and rely on the later bytestring version
10:08:21 <psnively> At least, if his comments on the existing UnrealScript compiler are any indication. :-)
10:08:38 <wli> Philippa: A singlepass compiler for what?
10:08:43 <dcoutts_> ptolomy2: either way you'll have to put a version constraint on the bytestring dependency in your .cabal file, like build-depends: bytestring >= 0.9.0.4
10:09:02 <Philippa> wli: the current UnrealScript compiler's single-pass, and has been creating maintenance hell for years
10:09:03 <psnively> UnrealScript has a single-pass compiler.
10:09:04 <ptolomy2> dcoutts_: Hmm.. my general policy (mostly due to laziness) has been to use what comes with my GHC distribution wherever possible, so I'm probably going to mark it incompatible with 0.9.0.4.. is that the oldest version with IsString?
10:09:20 <dcoutts_> ptolomy2: it probably is
10:09:21 * gwern looks at lispy's elisp compiler and wonders what the use-case was
10:09:35 <Philippa> had it been more maintainable, we'd probably have seen some improvements that'd make eg the Mutator system in UT* more flexible
10:09:45 <psnively> A "handwritten single-pass recursive descent compiler in C++, which serves mostly as an example of how not to do it" is how Tim described the UnrealScript compiler to me.
10:10:04 <Philippa> there's some real call for "class transformers" in modifying gameplay
10:10:13 <Philippa> but in a statically-typed lang that needs parametric polymorphism
10:11:06 <mattam> What's in the source language ?
10:11:25 <Philippa> mattam: ?
10:11:43 <Philippa> psnively: yeah. I've heard more from someone who used to work at Epic, too
10:11:51 <psnively> Per?
10:11:51 <mattam> In UnrealScript
10:11:52 <quicksilver> Peaker: yeah. There are other ways to signal exit which are much simpler.
10:12:00 <Philippa> *nod* - known Per online for ages and ages
10:12:00 <quicksilver> Peaker: but they do require changing to a different monad
10:12:09 <quicksilver> (no surprise there)
10:12:16 <psnively> Per is very, very sharp.
10:12:18 <Peaker> quicksilver, Combining IO with another monad with a transformer?
10:12:29 <quicksilver> Peaker: right.
10:12:32 <Peaker> quicksilver, I first used an IORef that I pass down to signify exit
10:12:43 <Philippa> Yeah. Thankfully less inclined to cut people with it than he used to be :-)
10:12:50 <psnively> mattam: ? UnrealScript is... UnrealScript. Basically Java-derived, but with, e.g. language-level support for HFSMs.
10:13:04 <quicksilver> Peaker: using built-in transformers the simplest would be ErrorT, and just ignoring the conets of the 'Left'
10:13:12 <quicksilver> Peaker: i.e. just using Left to signify exit.
10:13:22 <psnively> Philippa: ? He seems very level-headed to me. But most really brilliant people I know don't suffer fools gladly.
10:13:34 <mattam> H? Finite State Machines ?
10:13:41 <psnively> Hierarchical.
10:13:51 <mattam> Oh right.
10:13:59 <quicksilver> on the wiki, MonadExit is basically Either, but designed for this.
10:14:12 <Philippa> psnively: we're both ex-#flipcoders, if that helps explain anything
10:14:16 <matthew-_> would you say that negate is a symmetric or reflexive operation?
10:14:23 <Philippa> I've been just as bad in my time, believe me
10:14:51 <psnively> I think I'm just starting. I've even been semi-avoiding LtU lately because I'm tired of posting the same rants over and over and over...
10:15:17 <psnively> Those who want to learn, will; those who don't; wont. Myself included.
10:15:18 <Peaker> quicksilver, Why would that be better than throwIO with a userError?
10:15:20 <mattam> matthew-_: these terms correspond to relations.... so neither.
10:15:23 <Philippa> I've had to stop myself from responding to the odd repeat offender with something really nasty a few times
10:15:37 <quicksilver> matthew-_: I'd say it was an involution.
10:15:44 <quicksilver> if you're after fancy words.
10:15:45 <psnively> I've found that pressing Command-Q whenever I see Achilleas' name works wonders.
10:16:01 <Philippa> tbh I think Achilleas has acted in one of visible bad faith or staggering idiocy enough times he probably shouldn't be posting still, but hey
10:16:27 <matthew-_> damnit, stop taking me so literally. :) if you have a mapping f of a -> b such that f f == id, what is the fancy word?
10:16:33 <psnively> Even Anton has gently asked him why he's there, in essence, and Anton has the patience of a saint.
10:16:55 <mattam> Involution is right.
10:16:58 <psnively> Anyway, enough bashing. If I wanted to do that, I'd do it on LtU. :-)
10:17:03 <quicksilver> involution is the fancy word.
10:17:11 <matthew-_> mattam: oh bother. I don't know that word!
10:17:18 * matthew-_ grabs dictionary
10:17:26 <Twey> Haha
10:17:30 <quicksilver> self-inverse is the really boring word that other people might use
10:17:44 <Philippa> heh. Well, I tend to think standards of behaviour're slightly looser in here - there're words I simply wouldn't use on LtU that I've used plenty of times in here, for example
10:18:04 <quicksilver> btu it's utterly uncool compared to involution
10:18:20 * Codex_ uses the words "fixed point free".
10:18:24 <psnively> Oh, I agree. I'm just trying not to wallow in frustration anywhere--there, here, proggit, whatever.
10:18:33 <mauke> bipotent
10:18:44 <Philippa> *nod*
10:18:45 <psnively> Interesting, though, that I have specific nemeses on both LtU and proggit. Hmm.
10:18:46 <lament> Philippa: like "lollygagging" or "cowabunga"?
10:19:18 <equant> join #rockbox
10:19:22 <quicksilver> some words are more cromulent in #haskell
10:19:53 <Philippa> lament: one example'd be 7 letters, ends in "wit"
10:20:59 <Philippa> psnively: in other news, I proposed a close relative of one of the tools I suggested on LtU for a Summer of Code project this year. Oh, and I'm toying with a design for a dynamic (and dynamically typed) language which is quickly making me miss type classes
10:21:15 <lament> quick grep yields 4 results: antiwit, ferdwit, lackwit and wantwit :)
10:21:35 <Philippa> lament: I suspect you have a bowdlerised dictionary :-)
10:21:38 <dolio> I can think of two others.
10:21:47 <lament> Philippa: yes, i'm beginning to suspect that as well :)
10:22:09 <dolio> One seems more like a haskell-blah word, though.
10:22:11 <psnively> Philippa: for the love of God, why? :-)
10:22:26 <Peaker> does the stdlib contain any unordered set type?
10:22:38 <Philippa> psnively: because I want to toy with stuff without having to do a PhD project just to do type inference for it
10:23:00 <psnively> Just use Oz, then. :-D
10:23:06 <Philippa> the dynamic bit, however, wants some clarification: the language is also purely functional
10:23:20 <dolio> Peaker: I think the best you could do is an Eq set, although there isn't one of those, either.
10:23:21 <lament> is there a good online introduction to category theory?
10:23:26 <psnively> Ah so.
10:24:14 <lament> (good = better than wikipedia)
10:24:44 <Philippa> and if I worked in Oz I wouldn't be able to try some of the sugar I have in mind (longish story, but part of an oldish project of mine)
10:24:46 <dolio> I've collected some free-online category theory books, but I haven't read any.
10:24:48 <psnively> lament: Break down and buy a copy of "Conceptual Mathematics."
10:25:02 <psnively> Philippa: I was being facetious anyway. :-)
10:26:24 <Philippa> psnively: it's not an entirely stupid question, though Oz isn't the only language to suggest - "why not use Scheme?" needs answering for example
10:26:51 <psnively> Right.
10:28:34 <lament> oz is that really cool and awesome language that nobody uses
10:28:37 <dolio> Peaker: One cute encoding of a set of Eq things, is: 'type Set a = a -> Bool'
10:28:47 <Philippa> anyway, working out how to sugar multiple monads in a language with no typeclasses is painful
10:29:04 <dolio> Although it's hard to enumerate the contents of that (list would be better for enumeration).
10:29:09 <mauke> dolio: but how do I choose an element of a set?
10:29:26 <lament> with the axiom of choice!
10:29:33 <idnar> haha
10:29:34 <Peaker> dolio, you can't do much with that encoding though :-)
10:29:34 <dolio> Hehehe.
10:29:56 <dolio> Peaker: Well, you can do unions, intersection, etc. all very easily.
10:30:02 <dolio> It's just getting things out that's hard. :)
10:30:02 <Philippa> I suspect I need to make the sugar do manual dictionary passing, it's probably minimally painful but still sucks
10:30:13 <Peaker> dolio, yeah but little more :-)
10:30:28 <Peaker> dolio, also, if you do a lot of intersections/unions you're going to start paying heavy prices
10:31:16 <dolio> Also, it's easier to take the complement of that kind of set than of a set represented as a list.
10:32:03 <Peaker> dolio, how do you convert the set to a sorted list?
10:32:24 <mauke> toList set = []
10:33:31 <dolio> Clearly it's: 'toList set = filter set enumerateAllValues' :)
10:35:49 <dolio> Technically you could do that for all types that are both Bounded and Enum.
10:36:27 <dolio> Although, if you have an Enum instance like floating point numbers, it wouldn't work so well (although I don't think they're Bounded).
10:36:40 <dolio> > minBound :: Double
10:36:41 <lambdabot>   add an instance declaration for (Bounded Double)
10:36:41 <lambdabot>     In the expression: min...
10:40:19 <dolio> Strictly speaking, it probably makes more sense for floating point numbers to be bounded (by infinites, forgetting about NaN) than for them to be Enums the way they are (since f + 1.0 isn't the next largest number after f).
10:40:34 <johnnowak> getting back to the expression problem briefly, i don't suppose anyone has maintained some catalogue of concepts or functions that are difficult or impossible to express in haskell (or similar languages)
10:41:22 <Vulpyne> Since Haskell is turing complete, I don't think any could be impossible.
10:41:51 <Philippa> Vulpyne: is the wrong answer
10:42:00 <johnnowak> feel free to rephase my question so that it's useful
10:42:11 <Philippa> if you have to implement an interpreter or equivalent first, it doesn't count
10:42:11 <lament> Vulpyne: brainfuck is also turing-complete.
10:42:31 <EvilTerran> johnnowak, there's algorithms that don't work without mutable state, say
10:44:13 <Vulpyne> lament: So it would theoretically be possible to write any function in it that you could with any other programming language.
10:44:17 <dolio> You might have some luck looking at proposals (part of) whose job it is to alleviate the expression problem.
10:44:26 <dolio> Like open types.
10:44:37 <dolio> Or OOHaskell (?).
10:44:57 <lament> Vulpyne: right, the key word being 'theoretically'
10:44:59 <mauke> is OOHaskell on hackage?
10:45:00 <Philippa> Vulpyne: you have the simply-typed lambda calculus with fix, write polymorphic id
10:45:30 <dolio> A system of extensible exceptions is an example that comes to mind.
10:45:47 <Vulpyne> philippa: Could I not write a Haskell interpreter in it that would support polymorphic id?
10:45:53 <johnnowak> dolio: aye, i've read some of the open type/function proposals. i suppose things along those lines are what i'm looking for. it's a hopelessly vague question i realize
10:46:10 <Philippa> Vulpyne: you could, but you won't be able to pass STLC+fix functions into it
10:46:39 <roconnor> dolio: MonadError?
10:46:43 <Vulpyne> Since I don't know lambda calculus, I don't have a response to that. :)
10:46:45 <Philippa> bear in mind that your program doesn't have access to its own source
10:46:56 <Philippa> you know lambda calculus: it's a subset of haskell
10:47:05 <Philippa> you have lambda, variables, application and that's it
10:47:22 <Jaak> typed lambda calculus is...
10:47:22 <Philippa> the type system is limited to simple types (anything of kind *, more or less) and functions
10:47:29 <johnnowak> well, you can write programs in the untyped language calculus you can't write in haskell
10:47:29 <Vulpyne> I see.
10:47:36 <johnnowak> language => lambda
10:47:47 <Philippa> you get a fixpoint operator, that's enough to make it turing complete
10:48:01 <dolio> roconnor: Yeah, I don't think that solves the problem, really, although I'd have to reaquaint myself with the stuff to explain exactly why.
10:48:06 <Jaak> @type \x -> x x
10:48:08 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
10:48:08 <lambdabot>     Probable cause: `x' is applied to too many arguments
10:48:08 <lambdabot>     In the expression: x x
10:48:23 <mauke> @pl \x -> x x
10:48:23 <lambdabot> join id
10:48:39 <dolio> roconnor: It's more like, you want to add new kinds of IO exceptions, say.
10:48:53 <Philippa> Vulpyne: the "any function" result is only true until you care about the types, essentially
10:49:09 <roconnor> dolio: Hmm, I guess unioning execeptions is a bit annoying, because you end up nesting MonadErrors.
10:49:28 <Philippa> because otherwise it's properly phrased that any function can be /encoded/, not implemented
10:49:44 <roconnor> dolio: oh. I thought IO exceptions were brokenish.
10:50:03 <gbacon> @src filterM
10:50:03 <lambdabot> Source not found. Just try something else.
10:50:10 <dolio> Yeah. Instead you might want to write an open exception type, so you can add new constructors for that exception type when you need to report new kinds of errors.
10:50:10 <gbacon> @ty filterM
10:50:11 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
10:50:36 <Philippa> (see "but my machine only knows about natural numbers, how can it manipulate expressions?")
10:50:38 <dolio> I've heard polymoprhic variants let you solve the problem, too.
10:50:48 <johnnowak> are there any languages with soft type systems powerful enough to give you types similar to what you'd get in ML but without ruling out functions like \x -> x x (or requiring some annotation)? most soft type systems seem to focus on firming up untyped languages rather than loosening up typed languages
10:51:06 <roconnor> dolio: but MonadError allows you to make any exception type; ignoring the stupid Error class requirement.
10:51:14 <dolio> roconnor: Well, IO exceptions may be broken. But imagine you were designing an ideal IO exception mechanism. :)
10:51:26 <gbacon> @src Control.Monad.List.filterM
10:51:26 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:51:33 <gbacon> @index filterM
10:51:33 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
10:52:06 <roconnor> dolio: I imagine using MonadError everywhere. ... I suppose I don't have a very good imagination.
10:52:07 <Philippa> johnnowak: add a "damned if I know!" type ("Top", say) in place of unification failure and do plain H-M?
10:52:17 <dolio> Heh.
10:52:21 <Philippa> of course, then it'll type stuff that obviously can't work
10:52:40 <johnnowak> heh, well. i was hoping for something a bit more elegant.
10:53:02 <johnnowak> something that makes a bit more effort let's say.
10:53:27 <dolio> roconnor: http://people.cs.uu.nl/andres/OpenDatatypes.pdf has a bit on exceptions.
10:54:03 <gbacon> @src filterM []
10:54:03 <lambdabot> Source not found. My mind is going. I can feel it.
10:54:05 <bos> johnnowak: this is an active area of research (look for "well-typed programs can't be blamed", and felleisen's recent stuff). no languages have come of it yet; they're still developing the theory, and it's very early on.
10:54:33 <johnnowak> bos: indeed
10:56:21 <psnively> I would take a HARD look at Typed Scheme.
10:56:25 <dolio> roconnor: And you can have a type that represents all exceptions to do with some particular domain, and catch them all with one `catch`
10:57:00 <roconnor> hmm
10:57:03 <psnively> See also http://lambda-the-ultimate.org/node/2061
10:57:05 <lambdabot> Title: Gradual Typing for Objects | Lambda the Ultimate
10:57:08 <dolio> roconnor: Then do case analysis on the exception, and rethrow the ones you're not interested in. Then, when new exceptions (constructors) get added, your old code will still work, and just rethrow the new exceptions.
10:57:23 <Binkley> Hi, has anyone else had a problem building GHC after pulling patches in the past few days (after the package re-org)?
10:57:28 <Binkley> there doesn't seem to be anyone awake on #ghc
10:57:41 <johnnowak> psnively: why the /hard/ emphasis?
10:58:11 <dolio> roconnor: I imagine you can do all this with type classes (possibly needing some existential types), but that'd get Olegy.
10:58:46 <roconnor> dolio: I glaced at Oleg's paper on OO programming in Haskell '98
10:58:49 <psnively> johnnowak: Because Typed Scheme does some very powerful things, like correctly typechecking "(map add1 (filter number? l))"
10:58:57 <roconnor> I found it both terrifying and exciting.
10:59:10 <roconnor> It really didn't look all that bad, from a glance.
10:59:34 <roconnor> and using mfix to create new objects was cute!
10:59:42 <johnnowak> psnively: hm. i'll give it another look, thanks.
11:00:32 <dolio> Yeah, he does some amazing stuff, but a lot of times the fact that you can do the stuff he does doesn't mean that it's a nice way to do things practically.
11:00:44 <psnively> But I would not ignore Jeremy Siek's work, either.
11:01:41 <dolio> Like, most stuff you can do with GADTs he can probably translate to type classes and fundeps, but I'm not sure you'd want to use the latter.
11:01:48 <roconnor> dolio: I haven't studied his OO work deeply, but it seemed like it just needed a dusting of syntatic sugar.
11:02:51 <psnively> johnnowak: http://lambda-the-ultimate.org/node/2622 is a good thread. There's some back-and-forth between Matthias Felleisen and Jeremy Siek themselves.
11:02:52 <dolio> Yeah, I haven't studied that stuff to extensively, either.
11:02:53 <lambdabot> Title: The Design and Implementation of Typed Scheme | Lambda the Ultimate
11:06:47 <johnnowak> thanks psnively
11:10:10 <thorlund> where should i go to find a good haskell guide if i already know sml? :)
11:10:45 <mauke> yaht, gentle introduction
11:11:08 <byorgey> @where yaht
11:11:08 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
11:11:16 <mauke> http://www.haskell.org/tutorial/
11:11:16 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
11:11:35 <thorlund> its a bit to this is how you move from c to functional programming for my taste :)
11:11:37 <byorgey> yeah, the gentle introduction might be better
11:11:50 <byorgey> which, the gentle introduction?
11:12:13 <thorlund> no yaht
11:12:22 <byorgey> oh, try the gentle introduction then
11:12:27 <byorgey> it's actually not all that gentle =)
11:12:44 <mofmog> is there a form of getLine that works with backspace, delete etc?
11:12:44 <thorlund> :D
11:12:47 <mauke> 'a "gentle" introduction' might be a better name :-)
11:13:02 <thorlund> or maybe a not so gentle  ? ;P
11:13:06 <bos> mofmog: System.Console.Readline
11:13:41 <bos> mofmog: or System.Console.SimpleLineEditor
11:13:49 <bos> @hoogle getLineEdited
11:13:49 <lambdabot> No matches found
11:13:52 <bos> feh.
11:14:05 <mauke> mofmog: getLine does that
11:14:09 <mauke> how are you using it?
11:14:35 <bos> mauke: no it doesn't.
11:14:42 <mauke> it does here
11:14:50 <bos> "here"?
11:15:05 <mauke> my computer
11:15:09 <bos> http://www.codinghorror.com/blog/images/works-on-my-machine-starburst.png
11:15:10 <lambdabot> http://tinyurl.com/2yuke8
11:15:38 <glen_quagmire> do  { a <- f a; return a;} how can I do this?
11:15:52 <mauke> mfix f
11:15:53 <glen_quagmire> without monads , I can use where clause
11:16:30 <Philippa> mdo rather than do, assuming the monad is in MonadFix
11:16:33 <Philippa> if not, you can't do it
11:17:18 <glen_quagmire> i am trying to implement letrec  and the book uses this kind of circular construct
11:17:26 <glen_quagmire> let is so hard
11:19:02 <roconnor> @type mfix
11:19:03 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
11:19:21 <gwern> @seen dons
11:19:21 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 10h 24m 16s ago.
11:20:16 <gwern> @tell dons I know about hsgnutls (I've got most of Einar's stuff); what I'm blocked on is the dependencies like network-alt
11:20:16 <lambdabot> Consider it noted.
11:22:28 <lament> re typed scheme: i can't believe a cs paper seriously uses the term 'scripting language' and even calls Scheme that
11:22:58 <gwern> lament: god punishes each man according to a special plan
11:24:22 <gbacon> how do I get filterM's source from lambdabot?
11:24:25 <gbacon> @src filterM
11:24:25 <lambdabot> Source not found. Maybe you made a typo?
11:24:32 <Deewiant> @src [] filterM
11:24:32 <lambdabot> Source not found. stty: unknown mode: doofus
11:24:41 <gbacon> @src ([]) filterM
11:24:41 <lambdabot> Source not found. Take a stress pill and think things over.
11:24:54 <gbacon> lambdabot: DWIM!
11:24:54 <desegnis> No, filterM is not a class method
11:25:01 <Deewiant> it just doesn't have it
11:25:25 <gbacon> @ty filterM
11:25:26 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
11:25:33 <glen_quagmire> is it ok to have   func (x:xs) = do ..     func [] = mdo .. ?
11:26:03 <glen_quagmire> I get parse error when I use mdo and do for same function
11:26:19 <DRMacIver> hm. If I had a [Either a b] (actually some custom type looking like this) and I want to extract an ([a], [b]) is there a good way to do it?
11:26:38 <Deewiant> DRMacIver: http://hackage.haskell.org/trac/ghc/ticket/974
11:26:47 <lambdabot> Title: #974 (Add partitionEithers, lefts, rights to Data.Either) - GHC - Trac
11:26:50 <dolio> filterM _ [] = return [] ; filterM p (x:xs) = do b <- p x ; if b then (x:) `liftM` filterM p xs else filterM p xs -- or something like that.
11:27:50 <DRMacIver> Deewiant: Thanks. Having the function doesn't actually help me, but maybe looking at the implementation will. :)
11:28:02 <Deewiant> :-)
11:28:18 <DRMacIver> Oh. The implementation is the obvious thing
11:32:57 <roconnor> there goes my patent on partitionEithers.
11:34:13 <roconnor> DRMacIver: Conor suggests foldMap ((may . left) &&& (may . right))
11:34:18 <roconnor> http://www.haskell.org/pipermail/libraries/2008-February/009286.html
11:34:20 <lambdabot> Title: [GHC] #974: Add unzipEithers, lefts, rights to Data.Either, http://tinyurl.com/2vt6jo
11:35:12 <roconnor> @hoogle foldMap
11:35:13 <lambdabot> Data.Foldable.foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
11:35:13 <lambdabot> Data.Traversable.foldMapDefault :: (Traversable t, Monoid m) => (a -> m) -> t a -> m
11:35:31 <mofmog> hmm, System.Console.Readline seems to be giving me trouble
11:35:47 <mofmog> it returns a Maybe (IO String) so if i patter match out the IO String, i can't get the String part out of the IO
11:35:59 <Saizan> ?hoogle may
11:36:00 <lambdabot> System.Time.May :: Month
11:36:00 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
11:36:00 <lambdabot> Data.Maybe.maybe :: b -> (a -> b) -> Maybe a -> b
11:36:21 <roconnor> I think may doesn't exist yet
11:36:28 <roconnor> it has type may    :: Alternative f => Maybe a -> f a
11:36:41 <Deewiant> ?hoogle Alternative
11:36:41 <lambdabot> Control.Applicative.Alternative :: class Applicative f => Alternative f
11:37:30 <roconnor> I think Alternative is to  Applicative as MonadPlus is to Monad.
11:37:47 <Saizan> yep
11:38:26 <roconnor> what's the relantionship between Alternative and Monoid?
11:38:55 <roconnor> f a is always a monoid when f is Alternative?
11:38:56 <dolio> Alternative f --> forall a. Monoid (f a)
11:39:42 <Saizan> but we don't have that instance in the stdlib
11:39:45 <roconnor> should the words undecidable instances come to mind here?
11:39:52 <Saizan> yep
11:40:22 <roconnor> nothing a little wrapper can't fix.
11:40:22 <Saizan> also overlapping with a lot other instances
11:40:46 <dolio> Well, for instance, the Monoid for Maybe isn't even the same as the monoid you get from the MonadPlus/Alternative for Maybe.
11:41:45 <paolino> @instances Applicative
11:41:45 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
11:42:14 <roconnor> dolio: it isn't?
11:42:51 <roconnor> oh you mean the Monoid a => Monoid (Maybe a)?
11:42:57 <dolio> No. 'instance Monoid m => Monoid (Maybe m) where'
11:43:16 <dolio> MonadPlus for Maybe corresponds to the monoid for First.
11:43:18 <Saizan> "First" is the one
11:43:55 <roconnor> @src mplus (Maybe a)
11:43:55 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
11:43:59 <paolino> @instances-importing Control.Applicative
11:44:00 <lambdabot> Couldn't find class `Control.Applicative'. Try @instances-importing
11:44:05 <roconnor> @src (Maybe a) mplus
11:44:05 <lambdabot> Source not found. I am sorry.
11:45:45 <Deewiant> @src Maybe mplus
11:45:45 <lambdabot> Nothing `mplus` ys  = ys
11:45:45 <lambdabot> xs      `mplus` _ys = xs
11:46:16 <roconnor> @type mplus
11:46:16 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
11:46:29 <roconnor> oh wait, wrong plus
11:46:34 <roconnor> @src Monoid
11:46:34 <lambdabot> class Monoid a where
11:46:34 <lambdabot>     mempty  :: a
11:46:34 <lambdabot>     mappend :: a -> a -> a
11:46:34 <lambdabot>     mconcat :: [a] -> a
11:46:43 <roconnor> @src (Maybe a) mappend
11:46:43 <lambdabot> Source not found. Sorry.
11:46:49 <Deewiant> @src Maybe mappend
11:46:49 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:46:50 <roconnor> @src Maybe mappend
11:46:50 <lambdabot> Source not found. Just what do you think you're doing Dave?
12:00:10 <Vulpyne> Say I wanted to make a very simplistic HTTP protocol parser with Parsec, how horrible would this be? http://hpaste.org/6626
12:00:24 <Vulpyne> It doesn't really look nice to me, which makes me think there's probably a better way.
12:04:06 <lament> I'm using FFI to link with a C library that commonly deals with pointers to Foo and Bar. I don't know or care what Foo and Bar actually are, but I still want them typechecked. How do I do that?
12:04:32 <lament> i could do type FooPtr a = Ptr a but that's ugly because of the a
12:04:53 <Lemmih> lament: type FooPtr = Ptr
12:05:05 <lament> but then i still have to write FooPtr a
12:05:09 <lament> can i somehow avoid that?
12:05:31 <Jaak> type FooIntPtr = Ptr Int...
12:05:34 <lament> what i want is a "void pointer"
12:05:36 <Lemmih> lament: newtype FooPtr = FooPtr (Ptr FooPtr)
12:05:45 <Jaak> Ptr () then
12:06:25 <lament> oh, does that work?
12:08:56 <Jaak> why's "newtype FooPtr = FooPtr (Ptr FooPtr)" better than "type FooPtr = Ptr ()"?
12:14:37 <kjdf> is it possible to obtain a pointer to haskell object?
12:14:47 <kjdf> or otherwise uniquely map it to int
12:15:06 <kjdf> (in ghc)
12:15:08 <opqdonut> no, not really
12:15:29 <opqdonut> coercing into Ptr or something might work, dunno
12:15:36 <roconnor> there aren't really objects.  Haskell things are values.
12:16:07 <Lemmih> kjdf: Yes, with System.Mem.StableName.
12:16:25 <roconnor> Lemmih: damn it, how can that work.
12:16:37 <Twey> Thought they were functions.
12:16:47 <lament> they're morphisms.
12:16:50 <lament> ...with stable names
12:17:02 <Jaak> Twey: functions are also values
12:17:24 <Lemmih> roconnor: It has some limitations.
12:17:38 <Twey> True
12:17:46 <kjdf> thanks Lemmih
12:18:18 <roconnor> Lemmih: it looks like StableName a could be implemented as (Int, a) if one wanted.
12:19:34 <roconnor> actually, it kinda looks like StableName a could be implemented as Int.
12:20:30 <roconnor> or rather as Integer
12:20:34 <Lemmih> Well, it actually is.
12:20:59 <Twey> Heh
12:21:29 <roconnor> What does StableName a have to do with a?
12:21:54 <roconnor> semantically speaking
12:23:00 <roconnor> Well, I suppose the answer is nothing, it is just less confusing to have names associated with types of objects the are supposed to be taging.
12:23:17 <Lemmih> Yep.
12:25:06 <roconnor> Well, I guess a StableName isn't very much like a pointer.  I wonder if it will do what kjdf wants.
12:25:46 <kjdf> yes, it rather is
12:25:54 <kjdf> what I want
12:27:22 <roconnor> Lemmih: wow. How did you decode what kjdf wanted?
12:27:34 <roconnor> oh I see now
12:27:36 <roconnor> `` or otherwise uniquely map it to int
12:28:36 <roconnor> ``Convert a StableName to an Int. The Int returned is not necessarily unique;
12:28:42 <roconnor> :D
12:28:54 <kjdf> unique enough :)
12:29:11 <Lemmih> roconnor:  Yes, that and my psychic abilities.
12:30:21 <roconnor> Why do I get this sneeky feeling that StableName is implement simply as a counter giving out serial numbers.
12:32:24 <kjdf> (what I'm after is a way to have values being kept from GC until foreign code is done with them)
12:34:56 <Lemmih> kjdf: StablePtr's are in memory until you free them.
12:36:27 <Fester_> i would like to ask a GSoC related question
12:36:58 <kjdf> oh, even better
12:37:01 <Fester_> i just submitted an application for a project on implementing neural network library and probably some kind of a Machine Learning Framework
12:37:02 <kjdf> thanks Lemmih :)
12:37:09 <dcoutts_> Fester_: try #haskell-soc
12:37:24 <desegnis> Fester_: you may enjoy #haskell-soc
12:37:49 <Twey> Fester_: For extra laughs, see #haskell-soc!
12:38:36 <Fester_> thanks, i have missed the referennce to it on the soc page
12:38:41 <Fester_> and why laughs?
12:39:05 <Twey> No idea, hunger getting to my brain.
12:39:10 * Twey goes a-scavenging.
12:45:10 <roconnor> what's the latex for the infinity symbol?
12:45:21 <byorgey> \infty
12:45:23 <Deewiant> \infty
12:45:35 <byorgey> kind of odd, isn't it?
12:46:25 <roconnor> yeah, I'd use &infin
12:46:42 <olsner> \inf I would call it
12:46:53 <idnar> is there a length limit or something? :P
12:46:59 <idnar> \infinity isn't that long
12:48:22 <dolio> No, no length limit.
12:48:39 <olsner> it's only as long as infinity :P
12:48:42 <opqdonut> they probably meant typing convenience
12:48:44 <byorgey> who knows, maybe Don Knuth was in a bad mood ;)
12:48:45 <dolio> Considering \blacktriangleright
12:49:02 <dolio> Or \longleftrightarrow
12:49:13 <opqdonut> yeah
12:51:59 <desegnis> The sad thing is that for some arrows, you'd really want \implies, but then you'd probably habe to live with \implies2, \implies3, ..., \impliesbla
12:52:09 <desegnis> *have
12:54:13 <dolio> Huh, Haskell Server Pages is back.
12:57:15 <Twey> Haskell Server Pages?
12:57:24 <Twey> Seriously?  o.@
12:57:34 <dolio> Think Haskell with embedded first-class html.
12:57:41 <dolio> Including pattern matching, I think.
13:00:18 <dolio> Originally by Erik Meijer, but then he went off to MS and added it to VB instead. :)
13:00:26 <dolio> Because no one uses Haskell. :)
13:03:01 <byorgey> I know I don't.
13:03:23 <Lemmih> @seen nibro
13:03:24 <lambdabot> I haven't seen nibro.
13:03:26 <byorgey> And I definitely don't sit around and chat on an IRC channel about it either.
13:04:11 <blarz> ha, that'd be really lame
13:04:25 <byorgey> for sure
13:04:40 <opqdonut> yep
13:04:49 <byorgey> lame
13:09:31 <solrize> smerdlyakov (probably misspelled) had some kind of dependently typed HTML templating scheme
13:09:44 <solrize> as if haskell server pages wasn't far out enough :)
13:10:45 <solrize> http://laconic.sourceforge.net/
13:10:46 <lambdabot> Title: The Laconic programming language family
13:12:50 <Lemmih> solrize: s/l/k/
13:26:14 <DRMacIver> Hm. No bindings to imagemagick? Anything approximately equivalent?
13:27:21 <Heffalump> Tim Chevalier was writing some
13:27:30 <Heffalump> at the last hackathon
13:27:33 <Heffalump> dunno how far he got
13:28:08 <DRMacIver> Yeah, I see an email from him in the mailing list but nothing seems to have emerged from that.
13:28:13 <Heffalump> ask him
13:28:22 <Heffalump> might prompt some action, or at least a half-finished version
13:29:01 <matthew-_> @seen dons
13:29:01 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 1h 48m 8s ago.
13:29:17 <DRMacIver> Not a bad idea. Is he in here?
13:29:37 <Heffalump> Binkley is his nickname, or at least was last I remember.
13:30:14 <DRMacIver> Fair enough. I'll drop him him an email.
13:32:19 <DRMacIver> (Although frankly my use case is so non-serious I could just call out with shell commands. :) )
13:48:39 <julz> hi, it's me again
13:49:02 <julz> thanks to your help I finally made it working
13:49:13 <julz> but there is still a question?
13:49:33 <Lemmih> I'm not sure how to answer that.
13:49:56 <byorgey> julz: what's the question?
13:49:59 <julz> http://hpaste.org/6627 is running in ghci, but how the hell do I have a string tested with  runIt?
13:50:14 <julz> sorry was writing slowly ;-)
13:50:57 <Lemmih> julz: runIt "string goes here"?
13:51:13 <julz> hm yes thats what I supossed
13:51:52 <julz> it is not printing anything, (I'm a newb) shouldn't it? or am I missing something?
13:53:23 <Lemmih> julz: Annotate your paste with the output from ghci.
13:54:14 <julz> *Main> runIt "-8-^!8s%s18152ss32f-1-*1&!%$fa8f!33!1402f96**f42!$4af3&*" Loading package haskell98 ... linking ... done. "" *Main>
13:54:37 <Lemmih> julz: It prints "" which is an empty string.
13:54:43 <julz> so I supposed to have a failed or any thing else
13:54:51 <julz> ah yes indeed
13:55:30 <julz> is that what it should do? I supossed failed e.g.
13:56:54 <Lemmih> julz: It is what you programmed it to do.
13:57:43 <julz> hm let me explain. it is a game and I had to fix the code of a language I don't know
13:57:45 <stepcut> I remember reading a blog a few years ago, where someone explained how quantum computers work, and then they implemented a quantum computer in haskell that could run some basic quantum computing algorithms. But now I can't find it. I  remember an early lesson dealt with normal xor/not gates and then quantum gates.
13:57:51 <stepcut> I think there were even pretty pictures.
13:58:28 <stepcut> anyone else remember this ?
13:58:56 <Vulpyne> http://sigfpe.blogspot.com/2007/03/monads-vector-spaces-and-quantum.html -- This stuff maybe?
13:58:58 <lambdabot> Title: A Neighborhood of Infinity: Monads, Vector Spaces and Quantum Mechanics pt. II, http://tinyurl.com/2qxwb8
14:01:48 <lament> i have a quantum brainfuck interpreter, but it's in Python
14:02:27 <lament> quantum programming's not all that exciting, especially in emulation
14:03:06 <stepcut> Vulpyne: I don't think so. But, around the same time period.
14:03:43 <roconnor> stepcut: I think there are several implementations.  I saw a talk or two at the ASL in Montreal (2006?)
14:03:56 <stepcut> lament: yes, that is part of what the blog series was about. It should what quantum computing really is about, and why it may not be that cool after all.
14:04:54 <roconnor> quantum computing is pretty cool; although possibly not as cool as many people believe.
14:05:04 <stepcut> I believe the author expressed that he thought quantum computing was overhyped, and not well understood.
14:05:07 <julz> Lemmih: did you saw my answer? Thats why I don't know if it is what it is supposed to do ;-)
14:07:15 <biouser> hello
14:07:21 <Lemmih> julz: Well, I like to help people who are interested in Haskell and it seems that you are not.
14:07:30 <lament> what's CPO?
14:07:56 <lament> (the name of a category)
14:08:12 <lament> oh, found
14:08:22 <roconnor> complete partial order
14:08:26 <julz> I'am intrested but I need to learn quick, I think I will do some more with haskell but ...
14:08:36 <roconnor> which I suppose may technically be a catagory.
14:09:04 <biouser> http://hpaste.org/6628
14:09:06 <roconnor> because every partial order is a catagory.
14:09:45 <biouser> my function is returning [[(Int,Int,Int,Int)]] I want to see where (8,3,1,1) is and if it is adjacent to (7,1,1,1)
14:11:18 <roconnor> biouser:  you have a list of lists?
14:11:35 <biouser> roconnor, I believe so
14:11:50 <roconnor> biouser: do you want to flatten that first, or do you want to check this condition in each list?
14:12:01 <biouser>  closedKnights :: [Int] -> Hyper_pos -> Hyper_pos -> [[Hyper_pos]]
14:12:20 <roconnor> @hoogle indexOf
14:12:20 <lambdabot> No matches found
14:12:25 <roconnor> @hoogle index
14:12:25 <lambdabot> Data.Ix.index :: Ix a => (a, a) -> a -> Int
14:12:25 <lambdabot> Data.ByteString.index :: ByteString -> Int -> Word8
14:12:25 <lambdabot> Data.Sequence.index :: Seq a -> Int -> a
14:12:29 <biouser>  type Hyper_pos = (Int, Int, Int, Int)
14:12:33 <roconnor> @hoogle find
14:12:34 <lambdabot> Data.List.find :: (a -> Bool) -> [a] -> Maybe a
14:12:34 <lambdabot> Data.Foldable.find :: Foldable t => (a -> Bool) -> t a -> Maybe a
14:12:34 <lambdabot> Data.ByteString.find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
14:12:46 <roconnor> damn it, what is that function called.
14:12:56 <roconnor> @hoogle a -> [a] -> Int
14:12:56 <lambdabot> No matches, try a more general search
14:13:01 <biouser> roconnor, oh, right, I am using head $ so the first list is what is important I suppose
14:13:07 <wagle_home> :t index
14:13:09 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
14:13:19 <lekro> :t indexOf
14:13:20 <lambdabot> Not in scope: `indexOf'
14:13:40 <roconnor> ah elemIndex
14:13:45 <wagle_home> oh, duh
14:13:46 <roconnor> or elemIndeces
14:13:53 <roconnor> @type elemIndex
14:13:54 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
14:14:02 <roconnor> @type elemIndeces
14:14:03 <lambdabot> Not in scope: `elemIndeces'
14:14:11 <roconnor> @type elemIndices
14:14:12 <lambdabot> forall a. (Eq a) => a -> [a] -> [Int]
14:14:19 <biouser> roconnor, if I could get the function to return the first list that satisfied that condition I would be getting somewhere perhaps
14:14:20 <roconnor> biouser: those functions may be useful.
14:14:22 * wagle_home writes "always read more scrollback" 100 times
14:14:46 <roconnor> biouser: one problem at at time. :)
14:14:58 <roconnor> @type find
14:14:58 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
14:15:12 <biouser> @hoogle find
14:15:12 <lambdabot> Data.List.find :: (a -> Bool) -> [a] -> Maybe a
14:15:12 <lambdabot> Data.Foldable.find :: Foldable t => (a -> Bool) -> t a -> Maybe a
14:15:12 <lambdabot> Data.ByteString.find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
14:15:19 <roconnor> biouser: find will locate the first element of a list satifying an arbitrary predicate.
14:16:02 <roconnor> well, it will return the first element satifying the predicate.
14:16:15 <roconnor> findIndex will locate it.
14:17:53 <biouser> roconnor, thanks findIndex okay how do I set a variable equal to my list in ghci again, 'let'?
14:19:15 <biouser> got it, nm, thank you
14:20:26 <roconnor> biouser:  you really care about the index?
14:20:28 <roconnor> ok
14:20:53 <dons> http://reddit.com/info/6dd29/details  session types! now i understand what's going on
14:21:16 <biouser> roconnor, I don't really care about the index perhaps
14:22:35 <roconnor> biouser: then find will give you your result directly.
14:22:38 <roconnor> @type find
14:22:39 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
14:23:01 <biouser> (a-> Bool) does not compute
14:23:07 <biouser> t is now my list
14:23:37 <biouser> > findIndex (8,3,1,1) t                              does not work
14:23:39 <lambdabot>   Not in scope: `work'
14:23:56 <biouser> sry lambdabot
14:24:15 <Saizan> ?type findIndex
14:24:16 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
14:24:49 <Saizan> biouser: you want findIndex (==(8,3,1,1)) t, i think
14:25:15 <biouser> it is a list of (Int,Int,Int,Int) thanks Saizan
14:26:16 <biouser> nice Saizan, roconnor, my vertex was there, yes!
14:26:58 <roconnor> biouser:  you want elemIndex (8,3,1,1) t
14:27:25 <roconnor> and then you want find (\t -> elemIndex (8,3,1,1) t) listOfLists
14:27:43 <roconnor> er
14:27:49 <roconnor> not quite
14:28:04 <roconnor> but something vaguely like that. ... preferably something that type checks.
14:28:49 <Saizan> ?type elemIndex
14:28:56 <pakaran> hi
14:29:02 <pakaran> I'm starting to learn Haskell
14:29:04 <lambdabot> thread killed
14:29:10 <pakaran> is it ok if I ask a couple possibly stupid questions?
14:29:29 <dons> pakaran: of course!
14:29:30 <roconnor> @src elemIndex
14:29:30 <lambdabot> elemIndex x     = findIndex (x==)
14:30:10 <pakaran> when it says the type of 5 is "(Num t) => t" that just means some type, t, such that t is a numeric type ("Num t" returns true)?
14:30:35 <patapon> :t fromInteger 5
14:30:41 <roconnor> pakaran: it means 5 is a polymorphic and could be used as an Int, Integer, Double, Complex Double, etc.
14:30:42 <dolio> dons: Interesting stuff.
14:30:48 <pakaran> weird
14:30:49 <lambdabot> forall a. (Num a) => a
14:30:55 <pakaran> I'm just trying to wrap my brain around this stuff
14:30:58 <dons> pakaran: basically, literals are polymorphic
14:31:06 <nibro> pakaran: yes, that's a pretty decent simple explanation of it
14:31:20 <nibro> :t 5 :: Int
14:31:22 <lambdabot> Int
14:31:23 <dons> this usually isn't well understood in most languages
14:31:26 <nibro> :t :: Float
14:31:27 <dons> 5.0 /= 5 , for example
14:31:27 <lambdabot> parse error on input `::'
14:31:31 <nibro> :t 5 :: Float
14:31:32 <lambdabot> Float
14:31:49 <dons> but in haskell numeric literals are just symbols representing some type that behaves like a number
14:32:05 <dons> ?users
14:32:05 <lambdabot> Maximum users seen in #haskell: 470, currently: 469 (99.8%), active: 23 (4.9%)
14:32:11 <roconnor> > 5 + 5 :: Expr
14:32:14 <Saizan> pakaran: rather than (Num t returns true) we say that t is an instance of Num, in fact the syntax to declare that is instance Num TheType where (+) = <code for +>; etc..
14:32:15 <pakaran> so there's no actual problem with, say, defining your own type, Even, so that it represents any Int that is even?
14:32:22 <lambdabot>  5 + 5
14:32:23 <dons> right!
14:32:24 <pakaran> ah ok...
14:32:31 <dons> just as long as it implements Num
14:32:39 <dons> > 5 :: Complex
14:32:40 <lambdabot>      `Complex' is not applied to enough type arguments
14:32:40 <lambdabot>     Expected kind `?',...
14:32:41 <pakaran> and you can then test it by doing the equivalent of (nump i)?
14:32:43 <dons> > 5 :: Complex Integer
14:32:44 <lambdabot>   add an instance declaration for (RealFloat Integer)
14:32:44 <lambdabot>     In the expression: ...
14:32:52 <dons> > 5 :: Fixed
14:32:52 <lambdabot> Terminated
14:32:55 <dons> heh
14:33:00 <roconnor> > 5 :: Complex Double
14:33:04 <dons> > 5 :: Rational
14:33:08 <lambdabot>  5%1
14:33:08 <lambdabot>  5.0 :+ 0.0
14:33:21 <pakaran> ...
14:33:24 <pakaran> that's just too cool
14:33:24 <dons> lots of different numeric types, all sharing the numeric literals
14:33:29 <dons> yeah, its super awesome
14:33:36 <dons> not widely appreciated either, imo
14:33:39 <roconnor> > 2^5 :: Expr
14:33:43 <lambdabot>  2 * 2 * (2 * 2) * 2
14:33:46 <dons> hah
14:33:48 <Saizan> pakaran: no, you can't test if a type is an instance of a class at runtime, you just require that it is in your types
14:33:55 <roconnor> now I'm just causing trouble.
14:34:01 <pakaran> > 2^6 :: Expr
14:34:01 <lambdabot>  2 * 2 * (2 * 2) * (2 * 2)
14:34:10 <elliottt> it's a nice way of handling the coercion semantics
14:34:13 <nibro> why the parenthesis?
14:34:20 <pakaran> ah... cute...  I wonder how exponentiation is implemented
14:34:26 <roconnor> nibro: It is doing repeated squaring
14:34:40 <pakaran> ah!
14:34:45 <roconnor> @src (^)
14:34:46 <lambdabot> Source not found. There are some things that I just don't know.
14:34:53 <roconnor> oh come on.
14:34:55 <patapon> > x^6
14:34:56 <lambdabot>  x * x * (x * x) * (x * x)
14:34:58 <nibro> @src (**)
14:34:58 <lambdabot> Source not found. Do you think like you type?
14:35:05 <nibro> @src **
14:35:05 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
14:35:13 <nibro> huh?
14:35:17 <roconnor> @src Double (**)
14:35:17 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:35:18 <patapon> > x^y
14:35:24 <pakaran> so it's able to look at, say, 6 = 110 and see that it needs 2*2, as well as (2*2)*(2*2), going in that order
14:35:26 <lambdabot> Terminated
14:35:28 <nibro> those are prelude functions for cryin' out loud!
14:35:44 <roconnor> nibro: (**) is a class member.
14:35:57 <nibro> roconnor: ah, of course
14:36:11 <nibro> ?users
14:36:11 <lambdabot> Maximum users seen in #haskell: 470, currently: 468 (99.6%), active: 23 (4.9%)
14:36:54 <nibro> ?users
14:36:54 <lambdabot> Maximum users seen in #haskell: 470, currently: 469 (99.8%), active: 23 (4.9%)
14:36:56 <pakaran> hmm, maybe I screwed up my setup
14:37:00 <pakaran> buyt things like that are erroring out for me
14:37:02 <pakaran> Prelude> 2^20 :: Expr
14:37:02 <pakaran> <interactive>:1:8: Not in scope: type constructor or class `Expr'
14:37:22 <nibro> > 2^20 :: Expr
14:37:24 <Saizan> pakaran: Expr is not from the standard libraries
14:37:29 <lambdabot>  2 * 2 * (2 * 2) * (2 * 2 * (2 * 2)) * (2 * 2 * (2 * 2) * (2 * 2 * (2 * 2))) ...
14:37:50 <Valodim> hahaha, what
14:37:59 <pakaran> if it's doing repeated squaring...
14:38:08 <pakaran> 20 in binary is 10100 (16+4)
14:38:50 <pakaran> so I'd expect it to just do (2*2)(2*2) and then multiply that by ((2*2)*(2*2))*((2*2)*(2*2)), surely?
14:39:09 <nibro> pakaran: no, it's not that clever
14:39:20 <nibro> pakaran: and that would actually be wrong
14:39:34 <pakaran> yeah, need to repeat the second one
14:39:43 <nibro> pakaran: since Expr is the type of reified Haskell expressions
14:39:51 <pakaran> I'm really just trying to wrap my brain around this stuff now
14:40:07 <nibro> pakaran: so 2^20 :: Expr really needs to be 20 2's with * between them
14:40:16 <Jedai> pakaran: Expr doesn't show you the sharing
14:40:40 <pakaran> ah, right
14:40:49 <pakaran> so it can't completely memoize out things that would change the type
14:40:51 <Jedai> pakaran: But basically, all the (2 * 2) are shared here
14:41:04 <patapon> x^6 -> let y = x * x in y * y * y
14:41:12 <idnar> pakaran: it's sharing, not memoization
14:41:32 <idnar> pakaran: it's just that you can't see the sharing in the Expr representation
14:41:39 <pakaran> interesting...
14:42:17 <Saizan> Expr is a bit of an hack intended for demostrations
14:42:17 <pakaran> so if you, for example, try to compute the 20th fibonacci number in the obvious way, it doesn't memoize the 19th, 18th... but does determine that it needs the same value in several places, and "shares" the work of computing?
14:42:17 <pakaran> or what?
14:42:24 <Jedai> pakaran: No
14:42:26 <Saizan> > foldr f z [1..10]
14:42:41 <lambdabot>  thread killed
14:43:00 <Jedai> pakaran: The compiler isn't an IA... What you're asking for would be extremely difficult to implement efficiently
14:43:30 <Saizan> pakaran: if you do it the obvious way it just recomputes every time
14:43:42 <Jedai> pakaran: Because the compiler would have to decides where to memoize
14:44:01 <pakaran> ok, I was really wondering...
14:44:22 <Saizan> pakaran: and it's hard to tell where memoizing is a win, since space matters
14:44:33 <pakaran> right
14:44:40 <Jedai> pakaran: In (^) case, the sharing is explicit too, it's just you can't see it on Expr results
14:44:51 <pakaran> ah ok
14:45:11 <nibro> ?users
14:45:11 <lambdabot> Maximum users seen in #haskell: 470, currently: 469 (99.8%), active: 20 (4.3%)
14:45:13 <pakaran> and that's inherent in how the compiler designer decided to implement ^ in terms of *?
14:45:27 <dons> heya nibro
14:45:34 <nibro> heya dons :-)
14:45:51 <Jedai> pakaran: Yeah, the sharing is explicit in the source, like in (let y = x * x in y * y)
14:45:54 <\z> has anyone else seen http://beautifulcode.oreillynet.com/2008/03/four_lines_of_code_1.php yet?
14:45:56 <lambdabot> Title: Four Lines of Code - Beautiful Code, http://tinyurl.com/24dkkk
14:46:07 <\z> really complex problem solved in 4 lines of Haskell.  ;-)
14:46:19 <Jedai> pakaran: That's just the normal implementation of a power function
14:46:41 <\z> Interesting quote: "
14:46:41 <\z> Haskell truly is a different language. It makes most other programming languages look like dialects of each other."
14:46:46 <pakaran> see, I'm not at that advanced a level...
14:47:10 <nibro> dons: I see you're off to see gothenburg in a few weeks
14:47:24 <dons> yeah!
14:47:59 <pakaran> I would be tempted to implement power in terms of something like (in a C-like syntax, since I'm just learning Haskell) power(x, y) { if(y==0) return 1; else return x*power(x,y-1)};
14:49:06 <nibro> I'll be sure to get in for the hackathon, my long hiatus from Haskell coding makes me want for more... :-)
14:49:18 <dons> nibro: yeah, should be lots of fun.
14:49:34 <dons> nibro: get some xmonad installs going :)
14:49:51 <pakaran> and then to do exponetiation by squaring, I would do something with right shifting and calling power explicitly to multiply in the relevant power when it's odd
14:49:52 <pakaran> oh well
14:50:09 <pakaran> it's all just... really weird for me now
14:50:09 <ari> > let power x 0 = 1; power x y = x * power x (y-1); in power 2 5
14:50:10 <lambdabot>  32
14:50:42 <Twey> pakaran: power _ 0 = 1; power x y = x * power x (x - 1)
14:51:05 <pakaran> and _ means unspecified argument, kind of like it does in prolog?
14:51:12 <nibro> dons: does xmonad run on windows? :-D
14:51:32 <Twey> pakaran: Yep
14:51:46 <pakaran> ah
14:51:51 <pakaran> rather a lot like it does in prolog, i'd guess
14:51:57 <nibro> ?users
14:51:57 <lambdabot> Maximum users seen in #haskell: 470, currently: 467 (99.4%), active: 21 (4.5%)
14:51:59 <dons> nibro: we could try :)
14:52:27 <Twey> pakaran: It means 'something goes here but I don't care what, so whatever it is, just discard it'
14:52:44 <Jedai> pakaran: Well if you implement pwer this way, you won't have any sharing... But that's not how it is done in reality
14:52:46 <dons> Cale: does the lambdabot on code.haskell.org author still point to my email address?
14:53:05 <pakaran> right...  i was just screwing around
14:53:07 <Twey> @src (^)
14:53:07 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:53:09 <Twey> :-(
14:53:17 <Twey> @type (^)
14:53:19 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
14:53:25 <Twey> Type but no source :-(
14:53:39 <pakaran> ok...
14:53:46 <Heffalump> @seen DRMacIver
14:53:47 <lambdabot> DRMacIver is in #xmonad, #haskell-blah, #scala and #haskell. I last heard DRMacIver speak 44m 23s ago.
14:53:56 <pakaran> do simply takes a set of functions, and makes sure they're executed in order?
14:54:03 <DRMacIver> Hm?
14:54:11 <Twey> pakaran: Err.  Not quite.
14:54:13 <Heffalump> DRMacIver: you were looking for Binkley..
14:54:37 <Twey> pakaran: do = monads = headache territory for the beginner :-)
14:54:46 <Twey> There are a bunch of tutorials out there.
14:54:46 <Binkley> Heffalump: he emailed me earlier... I assume it was about the same thing
14:54:52 <DRMacIver> Indeed. :)
14:54:52 <Heffalump> ah, ok.
14:54:53 <pakaran> well, i've seen basic examples using do
14:55:00 <DRMacIver> But thanks
14:55:04 <Binkley> :-)
14:55:46 <dons> Binkley: you're not heading over the hackathon this time, are you?
14:56:00 <Jedai> power _ 0 = 1
14:56:00 <Jedai> power x y | even y = z * z
14:56:00 <Jedai>           | otherwise = x * z * z
14:56:00 <Jedai>           where z = power x (y `div` 2)
14:56:02 <Binkley> dons: sadly, no, not unless I find $1000 lying on the sidewalk :-)
14:56:05 <pakaran> Twey, but thinking in terms of functional programming philosophy about *how* it makes sure they're executed in order is a bad idea?
14:56:06 <Twey> pakaran: The apparent simplicity is deceptive :-P
14:56:06 <dons> yeah :)
14:56:13 <dons> i think i'm the only USAsian going
14:56:13 <Heffalump> dons: you got Galois to pay for you?
14:56:16 <Twey> pakaran: By all means think about it
14:56:26 <dons> Heffalump: nope, taking vacation
14:56:26 <Twey> pakaran: But... probably you should get the syntax and other basics down first
14:56:30 <Heffalump> ah, right.
14:56:35 <dons> Binkley: did you know there's direct flights to amsterdam now?
14:56:38 <Heffalump> that's dedication :-)
14:56:41 <Binkley> dons: yeah, I've seen the ads
14:56:46 <dons> Binkley: half the price of Frankfurt too
14:56:48 <dons> so that helped
14:56:50 <Heffalump> are you doing anything else in Europe while you're over?
14:56:56 <Binkley> I look forward to taking advantage of them someday when either I or my group has money
14:57:00 <Jedai> pakaran: A power function like that is already a little better
14:57:02 <dons> Heffalump: nah, just hanging out in gothenburg a bit
14:57:13 <dons> Binkley: you'll need to get an intern job somewhere :)
14:57:35 <Binkley> dons: well, I turned one down in the hopes that my group will have money this summer to fund me for doing research, which may have been a foolish move on my part, we'll see :-)
14:57:47 <dons> oh, cool.
14:57:56 <dons> i know yav's doing some dual project with PSU
14:58:01 <dons> i guess there's a few others going on too
14:58:03 <Binkley> yav?
14:58:08 <dons> iavor
14:58:11 <Binkley> ah, ok
14:58:23 <Japsu> @type foldr
14:58:23 <dons> he's  changed the spelling to help with the phonetics :)
14:58:24 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:58:24 <matthew-_> dons: ffs, you could have waited until I'd written part 3 before redditing it
14:58:27 <Binkley> well, I think both Galois and PSU are currently trying to club the same government agency into submission
14:58:31 <dons> matthew-_: oh, oops :)
14:58:35 <dons> matthew-_: i was inspired.
14:58:41 <dons> matthew-_: a fair bit of interest here
14:58:45 <dons> Binkley: right
14:58:48 <dons> grr!
14:58:52 <Heffalump> matthew-_: you were looking for me yesterday?
14:58:56 <pejo> Binkley, do grad students in the US not get funded during summers normally?
14:59:14 <dons> Binkley: oh, you could do SoC...
14:59:20 <dons> have you thought about that?
14:59:23 <dons> external core even
14:59:26 <Binkley> pejo: they get funded when their groups have research grants
14:59:39 <pakaran> Jedai, what does `div` do?
14:59:41 <Binkley> our research grant is in limbo because of government flim-flammery
14:59:44 <dons> we should talk sometime about ext-core support for helping tune code
14:59:46 <matthew-_> Heffalump: possibly. Don't worry :)
14:59:53 <Binkley> dons: well, I noticed the SoC announcement, but I hope that ext-core will be done long before that
15:00:04 <Jedai> pakaran: A integral division (5 `div` 2 == 2)
15:00:04 <Binkley> which is dependent on this darcs pull that I'm doing finishing within the next couple of days :-)
15:00:07 <dons> Binkley: but are you interested in doing something ghc-ish for SoC?
15:00:15 <dons> $5k ...
15:00:17 <pakaran> also, if I thought of let as doing something like declaring a variable on the stack in c or java, would I be entirely wrong?
15:00:20 <Binkley> dons: well... if I don't have funding to do my normal research, maybe
15:00:21 <dons> that's like 7 hackathons!
15:00:23 <\z> dons: what's the status of Data.ByteString these days?
15:00:25 <Binkley> but I'm not sure when I'll know about that
15:00:26 <Binkley> heh
15:00:36 <\z> I seem to remember there being discussion of a typeclass that would make ByteString interchangeable with String
15:00:36 <dons> Binkley: ok, well deadline for applications is 31st of the month
15:00:39 <dons> so think quick
15:00:39 <Binkley> I don't think I could shoehorn my normal research into something SoC-related
15:00:45 <dons> yeah true
15:00:47 <\z> but Data.String only mentions fromString as an instance method
15:00:48 <pakaran> Jedai, It amuses me that I can execute that entire line and get "true"
15:00:49 <Binkley> yeah, I'm not going to have an answer about the grant by the 31st
15:00:52 <Binkley> so I probably won't apply
15:00:54 <Binkley> but it was a nice thought
15:00:54 <Jedai> pakaran: You're right
15:00:56 <dons> \z, it has IsString
15:01:10 <dons> there's no String type class, but you can use string literals
15:01:28 <Heffalump> most other string functions are on general lists anyway
15:01:39 <Heffalump> so can't also be overloaded for bytestrings
15:01:55 <\z> dons: is there some generic way to walk across a String or ByteString?  like a generic version of uncons?
15:02:11 <dons> fmap ?
15:02:20 <dons> oh, no Functor ByteString :)
15:02:23 <dons> just pick one.
15:02:34 <Heffalump> obviously it's not a functor, it's not parameterised :-)
15:02:39 <dons> :)
15:02:45 <dons> its Monoidal though
15:02:52 <dons> so you get empty, append and concat
15:03:19 <mofmog> hey, is it possible to get a critique of my code
15:03:19 <\z> so there isn't a typeclass that unifies ByteString with String yet, is there?
15:03:22 <\z> aside from IsString
15:03:40 <mofmog> imho, it's a bit messy atm
15:03:49 <\z> (empty, head, concat, but not uncons or the equivalent)
15:04:42 <pakaran> how do I write a new function in the interpreter to use later?
15:04:44 <pakaran> like lisp defun?
15:04:59 <dolio> let function = ...
15:05:21 <Twey> pakaran: (use GHCi for this, hugs is less forgiving)
15:06:56 <pakaran> ah ok
15:07:10 <pakaran> i was screwing around...  did
15:07:14 <pakaran> nth 0 b = head b
15:07:24 <pakaran> nth a b = nth (n-1) (tail b)
15:07:31 <pakaran> and I get weird errors when I actually call it
15:07:39 <notASmartGirl> > [1,2,3] !! 2
15:07:40 <lambdabot>  3
15:07:56 <Twey> nth = (!!)
15:07:58 <Twey> :-)
15:08:07 <lament> pakaran: look at your definition. Where does 'n' come from?
15:08:33 <pakaran> ?
15:08:35 <pakaran> ah
15:08:51 <ddarius> Maybe names better than a and b are called for
15:09:06 <pakaran> like i said, just screwing around
15:09:08 <pakaran> and damn it
15:09:12 <pakaran> now my computer is swapping like crazy
15:09:16 <Twey> Heh
15:09:26 <lament> also, a and b in general are not good variable names
15:09:38 * EvilTerran would go for "n" and "xs"
15:09:47 <pakaran> i know that
15:09:48 <lament> a and b are almost reserved syntax :)
15:09:54 <pakaran> i'm a grad student in computer science
15:09:58 <ddarius> EvilTerran: You and about 90% of the people in this room.
15:10:01 <pakaran> ... a and b have special meanings?
15:10:06 <EvilTerran> :)
15:10:10 <Binkley> pakaran: no one's questioning your knowledge; they're just trying to help you make your code better
15:10:15 <pakaran> i'm sorry
15:10:21 <pakaran> like I said, it was a toy example
15:10:31 <pakaran> mostly trying to test that I knew the syntax right
15:10:40 <dolio> Yes, i is always an Int variable...
15:10:50 <notASmartGirl> > let { nth 0 (x:xs) = x; nth index (x:xs) = nth (index-1) xs; } in nth (-1) []
15:10:50 <lambdabot>   Non-exhaustive patterns in function nth
15:10:51 <dolio> Oh wait, this isn't #fortran.
15:11:09 * EvilTerran is merely a vessel of the #haskell gestalt conciousness
15:11:17 <pakaran> lol
15:11:27 <notASmartGirl> pakaran: pattern matching make the sourcode shorter
15:11:31 <pakaran> to be fair, the word "haskell" sounds like it could be Hungarian...
15:11:49 * blarz loves pattern matching
15:11:51 <pakaran> though i isn't valid hungarian notation
15:11:53 <pakaran> and neither are a and b
15:11:58 <ddarius> nth idxN lstL = ...
15:12:09 <blarz> I hated this (if (bla) then else) or (cond) foo in scheme
15:12:15 <Binkley> You mean "I am not valid hungarian notation" ;-)
15:12:19 <pakaran> if I tried to implement the lisp function cdadaddr in haskell would I get kicked?
15:12:33 <Axioplase> pakaran: the word"Haskel" is a first name...
15:12:36 <Twey> nth 0 (x:xs) = x; nth n+1 (x:xs) = nth n xs
15:12:45 <Twey> (ahaha I used an n+k pattern)
15:12:53 <ddarius> pakaran: There are multiple functions that correspond to lisp's cdadaddr
15:12:59 <Twey> (I've always wanted to do that)
15:13:31 <dolio> @type tail . head . tail . head . tail . tail
15:13:32 <lambdabot> forall a. [[[a]]] -> [a]
15:13:33 <pakaran> ddarius, that's just too cool for words
15:13:40 <Twey> Axioplase: Makes you wonder which of his ancestors decided to name themselves 'Curry'
15:13:49 <dolio> Or is it the other way around?
15:13:56 <jajaman2> I get "Ambiguous occurrence `Scalar' " when loading some modules in ghci. The Scalar type is different in two modules, do I have to qualify them, even internally in a module?
15:14:06 <ddarius> :t snd . fst . snd . fst . snd . snd
15:14:07 <lambdabot> forall a b b1 a1 b2 a2 a3. (a3, (a2, ((a1, ((a, b), b1)), b2))) -> b
15:14:20 <dolio> Oh, there is that, too.
15:14:28 <pakaran> wow
15:14:43 <pakaran> i think it's very, very cool that things like that just automagically work
15:15:03 <nibro> ?users
15:15:03 <lambdabot> Maximum users seen in #haskell: 472, currently: 471 (99.8%), active: 28 (5.9%)
15:15:18 <Twey> pakaran: cdadaddr = tail . head . tail . head . tail . tail
15:15:21 <Twey> (for lists)
15:15:46 <pakaran> I was actually more being facetious when I mentioned that
15:15:58 <Twey> I guessed :-P
15:16:09 <Twey> Hmm
15:16:15 <wagle_home> using fst and snd is more accurate
15:16:22 <Twey> > fst [1, 2, 3]
15:16:23 <lambdabot>  Couldn't match expected type `(a, b)' against inferred type `[a1]'
15:16:33 <Twey> wagle_home: Not necessarily
15:16:45 <wagle_home> (cons 1 'a')
15:16:45 <pakaran> and I'm guessing that what lambdabot was saying is, that for any list (a3, (a2, ... etc, it will return b in that list?
15:16:48 <Twey> Depends whether you're more interested in lists or conses
15:16:59 <wagle_home> (car (cons 1 'a')) ==> 1
15:17:07 <wagle_home> (cdr (cons 1 'a')) ==> 'a'
15:17:11 <Twey> Yep
15:17:25 <ddarius> data SExp a = Atom a | Combination { car :: SExp a, cdr :: SExp a }; cdadaddr = cdr . car . cdr . car . cdr . cdr
15:17:36 <Twey> But (car '(1 "a" "b")) ==> 1
15:17:50 <Twey> And (cdr '(1 "a" "b")) ==> '("a" "b")
15:18:02 <Twey> Depends whether you're interested in the abstraction or the implementation.
15:18:12 <pakaran> now you're losing me
15:18:27 <wagle_home> (1 "a" "b") is syntactic sugar for (1 . ("a" . ("b" . ())))
15:18:32 <Twey> Yes
15:18:48 <ddarius> Twey: The problem with car and cdr is that you don't know what the abstraction is.  Is it a list, a pair, a rose tree, some combination?
15:18:58 <Twey> But in Haskel, [1, 2, 3] is not syntactic sugar for (1, (2, (3, ())))
15:19:08 <Twey> ddarius: True
15:19:12 <Twey> Haskell**
15:19:21 <pakaran> ddarius, well, of course, car and cdr were originally convenient shorthand for the inventer of lisp and his students, after register names on the machine they were working on...
15:19:27 <pakaran> and it got into wide use
15:19:37 <ddarius> pakaran: The names are irrelevant.
15:19:46 <pakaran> I believe they added "first" and "rest" when they went to standardize lisp, or so a prof once told me
15:20:03 <wagle_home> when did i claim it did?
15:20:06 <lament> Twey: what's the difference between (1 . (2 . (3 . ()))) and 1 : 2 : 3 : [] ?
15:20:18 <lament> apart from haskell having nicer syntax as usual
15:20:38 <wagle_home> is lisp you can have 1 : 2 as a value
15:20:41 <pakaran> i'd argue that the lisp syntax makes the order of evaluation clear
15:20:52 <pakaran> but i'm more familiar with lisp than i am with haskell, so maybe i should just shut up
15:20:56 <wagle_home> ...  or (1 : 'a')
15:20:57 <lament> haskell also makes the order of evaluation perfectly clear
15:21:05 <lament> ....it's unspecified :)
15:21:38 <Peaker> lament, that would only matter for performance concerns, wouldn't it?
15:21:58 <lament> pakaran: the order of evaluation doesn't matter in haskell, mostly
15:22:00 <pakaran> I can certainly come up with cases in C, Java, etc where it would matter
15:22:13 <EvilTerran> that's because they have side-effects
15:22:31 <patapon> Haskell has async exceptions :-D
15:22:34 <pakaran> f(i++, ++i) is not likely to give the same result as f(j++, ++j) even if i and j are initially the same in the calling method
15:22:35 <patapon> so we get to be in the same boat
15:22:43 <Twey> lament: In Haskell?  Types :-)
15:22:43 <pakaran> erm
15:22:49 <pakaran> or they wouldn't if I'd put them in the other order
15:22:52 <pakaran> which I meant to do
15:22:53 <pakaran> but you get my point?
15:23:11 <Twey> That's the root of the issue, fst and snd don't take a list or they'd translate directly to car and cdr
15:23:16 <nibro> pakaran: that's one of the reasons why we love haskell so much :-)
15:23:18 <bparkis> an algorithms thing: http://www.bparkis.com/node/12 has anyone heard of this idea?
15:23:23 <lambdabot> Title: Revision-Controlled Data Structures | www.bparkis.com
15:23:28 <lament> pakaran: in scheme, you certainly want to know the order of, say (cons (set! x 1) (set! x 2))
15:23:32 <patapon> car and cdr don't take a list either, they take a tuple
15:23:38 <nibro> pakaran: we don't have to bother about silly things like what you just said
15:23:38 <lament> pakaran: in haskell, this situation can't arise because there's no set! :)
15:23:52 <wagle_home> haskell (,) are the most like lisp pairs
15:23:57 <pakaran> ah...
15:24:00 <Twey> pakaran: They do take lists, because in Lisp lists are just nested conses
15:24:12 <Twey> In Haskell, though, lists are not just nested tuples
15:24:29 <lament> Twey: i still see no difference between haskell _lists_ and lisp _lists_
15:24:31 <Twey> They have a separate type to themselves
15:24:41 <Twey> lament: That wasn't the question
15:24:46 <pakaran> so you can't actually implement, say, ++i as something like temp := i; i := (i+1);return temp?
15:24:57 <patapon> Lisp lists aren't lists, they are trees
15:25:00 <nibro> pakaran: if you're working with pure code, no
15:25:01 <ddarius> pakaran: Haskell doesn't have assignment.
15:25:03 <lament> pakaran: there's no :=
15:25:22 <nibro> pakaran: in pure code, there are no side effects, so evaluation order doesn't matter
15:25:39 <pakaran> see, it still seems to me like that would make it impossibel to do anything
15:25:43 <ddarius> const 3 (fix id)
15:25:44 <nibro> pakaran: but then you can of course go into the IO world, where there are := equivalents
15:25:44 <wagle_home> in haskell, the elements in "haskell lists" all have the same type, and the second element of the list cell is a list of that type.
15:25:45 <sm> no :=, no self, no problem
15:26:01 <nibro> pakaran: define 'anything' :-)
15:26:16 <pakaran> ok...
15:26:17 <lament> @faq can haskell do anything?
15:26:17 <lambdabot> The answer is: Yes! Haskell can do that.
15:26:25 <pakaran> reasonable definition of anything...
15:27:05 <wagle_home> @faq can haskell prove that haskell halts?
15:27:05 <lambdabot> The answer is: Yes! Haskell can do that.
15:27:16 <nibro> haskell makes the separation of pure and unpure code explicit
15:27:16 <wagle_home> ha!  haskell is therefore trivial
15:27:28 <qwr> pakaran: do { temp <- get; put (temp + 1); return temp }
15:27:52 <pakaran> while(i < arraySize) {array[i]++; i++;}
15:27:56 <lament> pakaran: at this point, you should probably read a tutorial instead of getting confused by all the contradictory information you're likely to get from the channel
15:27:57 <pakaran> though I suppose you could emulate that with map
15:28:09 <nibro> pakaran: exactly!
15:28:10 <qwr> pakaran: http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State-Lazy.html#3
15:28:11 <lambdabot> http://tinyurl.com/2dn8t6
15:28:23 <EvilTerran> pakaran, haskell does have representations of mutable values and arrays in monadic form
15:28:30 <nibro> but if you really want to do code that has side effects, you can do that in the IO monad
15:28:38 <Axioplase> patapon: lisp lists are lists. They are of the algebraic data type List = NIL | Cons val List
15:28:45 <nibro> the IO monad contains everything that is unpure
15:28:48 <EvilTerran> but they're all safely bundled up and kept away from pure code
15:29:08 <Axioplase> Any list is a comb in fact (is that the right term, "com"?)
15:29:21 <pakaran> I guess I sort of understand this on the intellectual level
15:29:24 <pakaran> but it's still weird to me
15:29:29 <wagle_home> Axioplase, no, lisp pairs are of type Value x Value
15:29:29 <patapon> Axioplase: lisp lists are much closer to: data List = Cons a b; data Nil = Nil
15:29:32 <lament> pakaran: read a tutorial.
15:29:47 <benny99> hi -- did somebody read 'Fun of Programming'? I'm stuck at the first exercise: What is a tree in linear shape? A tree like (a (b (c Null) Null) Null) ?
15:29:47 <nibro> pakaran: of course if you've never seen a pure language before, it's bound to be weird :-)
15:29:48 <Axioplase> wagle_home: pairs, not lists. NIL is a list
15:29:53 <lispy> or, type LispCons a b = (a, b)
15:29:54 <wagle_home> lisp therefore has "improper lists"
15:30:13 <lispy> (but, my example has the problem that () is not a type of (,)
15:30:24 <wagle_home> Axioplase,  (cons 1 'a') is fine in lisp..  (1 : 'a') is not fine in haskell
15:30:27 <Axioplase> pakaran: don't try to map Haskell to Lisp nor conversely. It just doesn't work. Learn haskell, you'll see how they resemble and how they differ.
15:30:44 <Axioplase> wagle_home: but (cons 1 'a) is not a list.
15:31:01 <benny99> lispy: dunno what's up, but you maybe did use a tuple instead of a list?
15:31:06 <lispy> Well, lisp and haskell have far more in common than haskell and most languages :)
15:31:07 <benny99> (where you wanted to use a list)
15:31:11 <pakaran> ok...
15:31:19 <pakaran> I am trying to learn it
15:31:22 <wagle_home> its a list, but an improper one..  (list? (cons 1 'a')) returns True
15:31:24 <pakaran> and I didn't mean to take everyone's time
15:31:29 <pakaran> more to ask some things that seemed odd to me
15:31:36 <Axioplase> wagle_home: a list in Lisp/Scheme always finishes by '()
15:31:36 <nibro> pakaran: we're here to help :-)
15:31:47 <wagle_home> Axioplase, nope
15:31:52 <pakaran> and I do feel like... I almost don't have the right kind of thinking to undersand some of what you're saying
15:31:53 <qwr> lispy: Cons a b = (Maybe a, Maybe b)
15:31:56 <benny99> lispy: ups -- didn't get what was going on ^^
15:32:13 <lispy> qwr: oh, nice, yes we have to have dotted pairs :)
15:32:24 <Axioplase> wagle_home: ah right. That confirms my thoughts then. Lisp stinks, Scheme rocks.
15:32:32 <lament> hahahaha
15:32:41 <lament> and Arc is the best!!!!!!!!!!!!!!!
15:32:49 <lispy> Arc, FTW
15:33:12 * Twey laughs.
15:33:17 <pakaran> I guess since lisp is sort of functional, and something I've seen before, I've tended to think in terms of "lisp without setq and friends" which is difficult for me to think about programming in
15:33:18 <wagle_home> Axioplase, how does that follow?
15:33:25 <lispy> benny99: no problem, I realized that from what you said, but didn't know how to fix it :)
15:33:27 <nibro> pakaran: it takes a while to get used to, certainly
15:34:02 <Axioplase> wagle_home: in Scheme (list? (cons 1 ')) returns #ff
15:34:02 <pakaran> now I do realize that setq essentially *is* a side effect, in the same way print statements are
15:34:02 <Twey> pakaran: That's not *so* bad a way to look at it
15:34:02 <gweiqi> pakaran: have you read sicp?
15:34:10 <Axioplase> #f
15:34:13 <pakaran> sicp?
15:34:14 <lispy> pakaran: You will find that lisp, resembles lambda calculus, and haskell is heavily based on lambda calculus.
15:34:17 <Twey> pakaran: But we have other things to replace setq and friends :-)
15:34:47 <gweiqi> pakaran: it's a great book, google it and read it online... teaches scheme in a mostly functional style
15:35:02 <lispy> pakaran: but, the off thing is that even though Haskell's syntax is usually farther from lambda calc than that of lisp, haskell more closely matches lambda calc (the type variant of it anyway) than lisp does
15:35:14 <gweiqi> pakaran: it's great for preparing the right mindset for haskell
15:35:26 * benny99 didn't read SICP completely yet, but recommends it highly (a hobbyist)
15:35:31 <qwr> pakaran: http://mitpress.mit.edu/sicp/full-text/book/book.html
15:35:32 <lambdabot> Title: Structure and Interpretation of Computer Programs
15:35:34 <ddarius> How do you get to be a grad student in CS without having even heard of SICP?
15:35:46 <lispy> ddarius: go to a java school?
15:35:47 <benny99> there are also lectures :)
15:35:52 <pakaran> ddarius, to be very honest?  doing things mostly when they're assigned to be done in class
15:35:58 <pakaran> also, my masters work was largely in pure complexity theory
15:36:05 <nibro> heh, I'm a grad student doing haskell, and I have never heard of SICP either :-)
15:36:19 <pakaran> (which I'm coming to realize I do *not* want to do for a career - theory, like pure math, basically involves staring at problems for weeks to see if you can make anything out of them)
15:36:19 <patapon> careful, this channel is logged!
15:36:25 <patapon> and you're admitting not knowing of sicp
15:36:49 <lispy> yeah and lambdabot might ban you ;)
15:36:55 <benny99> those lectures of Abel and Sussman 'belong' to SICP don't they?
15:37:04 <benny99> and what are linear shaped trees now :-[ ?
15:37:15 <ddarius> benny99: Draw one.
15:37:15 <pakaran> if the bot bans you for saying something, wouldn't that be a statement having a side effect?
15:37:23 <lispy> but, to be fair, it's more important that you are comfortable with the concepts than if you've read the classic text
15:37:24 <pakaran> and hence logically impossible for a lambdabot?
15:37:25 * pakaran ducks.
15:37:26 <benny99> ddarius: ?
15:37:27 <Axioplase> pakaran: join #scheme, and read each book from the topic of the channel.
15:37:38 <benny99> ddarius: (3 (2 (1 Null) Null) Null) <-- ?
15:37:43 <ddarius> benny99: Take some paper and a pen or pencil and draw it.
15:37:51 <benny99> ddarius: I don't know what they are
15:37:52 <dolio> benny99: I imagine your guess was right. A tree with only one non-null branch at each node.
15:37:56 <benny99> ddarius: I can't draw one
15:38:06 <pejo> ddarius, I think SICP is less common at places where ML/Haskell is used.
15:38:13 <ddarius> benny99: That is an example.
15:38:17 <pakaran> Axioplase, would it be easier to just read a haskell tutorial?
15:38:23 <benny99> is ddarius a bot?
15:38:46 <wagle_home> Axioplase, thats because some idiot decided list? should be O(n)..  /me rolls eyes
15:38:47 <Axioplase> pakaran: SICP and co. Are good for *any* functional language
15:38:52 <lispy> benny99: often scheme/lisp lists are drawn by using a box for each cons cell, the box has two arrows coming out of it, one pointing at each thing the cons is carrying.  A dotted pair has no arrow but instead the value is where the arrow should be.
15:38:56 * benny99 is a bot
15:38:58 <ddarius> pejo: I would think the language used would be irrelevant.  I probably read SICP when I was 15.
15:39:04 <blarz> ttp://mitpress.mit.edu/sicp/full-text/book/book-Z-H-4.html#%_toc_start
15:39:14 <benny99> lispy: ._.?
15:39:25 <benny99> lispy: ah, guess we are talking about different things
15:39:45 <benny99> I'm sorry -- I just bashed in my question between your discussion I guess :-[
15:39:57 <lispy> benny99: oh, I thought you wanted to know how to graphically draw (3 (2 (1 Null) Null) Null) on paper
15:40:00 <wagle_home> not that list? was ever a useful function
15:40:05 <pakaran> the reason I'm learning haskell is that a friend suggested tht learning it would help me program better in any language.. something about thinking differently
15:40:09 <ddarius> wagle_home: Indeed.
15:40:18 <Axioplase> wagle_home: Well, I rarely write code where I depend on LIST? anyway... it's better to deisgn wel your program and dispatch at the last moment...
15:40:19 <benny99> lispy: no, no
15:40:49 <benny99> lispy: I wasn't referring to lisp either -- I just read in a paragraph the expression 'linear shaped tree' and I wonder what that could be
15:41:16 <lispy> okay
15:41:33 <benny99> lispy: yep, some kind of rude :/, didn't want to kill your discussion
15:41:42 <mauke> a tree all of whose left branches are empty
15:41:43 <benny99> guess ddarius got that wrong either
15:41:45 <mauke> or right branches
15:41:53 <benny99> mauke: thanks :)
15:42:03 <wagle_home> > [[]..]
15:42:05 <lambdabot>   add an instance declaration for (Enum [a])
15:42:24 <lispy> lisp does allow some pretty cool things though.  Once in a course to demonstrate how lisp is different from other languages, I wrote a program (in about 40 lines) that reads itself as input and searches over itself looking for the symbol waldo.  as it searches it wraps its own source in calls to car/cdr so that when the result is evaluated it returns the symbol waldo :)
15:42:31 <lispy> benny99: np
15:43:00 <qwr> pakaran: yes, it's quite different. somewhat like learning to program again.
15:43:05 * benny99 says thanks to mauke and ducks away from ddarius and lispy ;)
15:43:22 <benny99> (agreed)
15:43:23 <pakaran> qwr, and it's normal for it to seem just plain *weird*, even if logically true, in the meantime?
15:43:33 <lispy> they even have a standard language feature in common lisp to read in your own source
15:43:35 <dolio> list? has to be O(n), no?
15:43:36 <lispy> I should go
15:43:43 <benny99> pakaran: it did for me :p
15:43:44 <dolio> Otherwise it should be called cons?
15:43:53 <benny99> pakaran: s/did/was
15:43:58 <mauke> nil is list? but not cons?
15:44:19 <pakaran> good to know
15:44:33 <benny99> lispy: bye :)
15:44:39 * benny99 is away
15:44:41 <qwr> pakaran: probably. i know ocaml and scheme before learning haskell, so it wasn't so weird. just had to learn how to program without implicit side effects.
15:44:48 <pakaran> i think nil isn't a cons because there's no two values that cons to be nil (or the length would have to be 1 or more)?
15:44:48 <qwr> s/know/knew
15:44:55 <dolio> Ah, well, then it's nil-or-cons?
15:45:26 <TomMD> I noticed I get link errors if one exposed module used functions from another module in the package that was not exposed.  To fix this I exported (Exposed-modules: ) the others, but could I use "Other-modules:" to fix this as well?  I'd try but its on my other machine.
15:45:51 <wagle_home> dolio: yeah, its O(n), as i roll my eyes about above
15:45:59 <ddarius> dogbite: That's what listp means in CL.
15:46:24 <ddarius> Crap
15:46:50 <mauke> *> (listp (cons 1 2))
15:46:51 <mauke> T
15:47:01 <qwr> pakaran: but still. it is different enough from ocaml that when you're new to haskell, you'll basically don't know what a heck to do, when writing some state-rich code
15:47:13 <patapon> pata pata pata pon
15:47:33 <pakaran> qwr, but it really does end up being *easier* to program in?
15:47:38 <qwr> pakaran: like some non-trivial network code ;)
15:47:59 <lament> haskell is one step closer to curry-howard isomorphism
15:48:00 <qwr> pakaran: it's mixed. some things are really easier. some are not.
15:48:04 <lament> away from programming and towards math
15:48:22 <Axioplase> qwr: I came from OCaml, and I confirm :)
15:48:26 <patapon> pakaran: Lots of people find programming in Haskell quite rewarding, the best way to find out if you are one is to give it a shot
15:48:56 <pakaran> I am doing that
15:48:58 <patapon> there aren't 462 people in the channel because they all like a good challenge
15:49:07 <pakaran> and I'll shut up now, and not use everyone's time, sorry
15:49:10 <Axioplase> qwr: though I found out that the easiest thing to do is to consider a state monad to be just another semantical constraint to get used to (jsut as when I started ML from a Scheme background, and had to bear with types)
15:49:56 <dolio> I'm not sure how there are that many people here.
15:50:00 <dolio> I don't think they all talk.
15:50:16 <ddarius> 76% of us are bots.
15:50:21 <TomMD> @users
15:50:21 <lambdabot> Maximum users seen in #haskell: 472, currently: 463 (98.1%), active: 22 (4.8%)
15:50:22 <patapon> dolio: they are here to hang on my every word!
15:50:32 <TomMD> thats fairly normal numbers
15:50:53 <benny99> mau*ke, ca*le, do*ns, lambda*bot, dol*io, DRM*..., and some more are talking from time to time, but that's it I guess
15:51:31 <Saizan> i'm not a bot! i'm a free man!
15:51:36 <dolio> You could see roughly how many people talk, but someone removed the social graph form the topic.
15:51:42 <TomMD> benny99: Not a bad idea, @seen-censored
15:51:46 <ddarius> benny99: Most of the people in the channel list talk, but they do it at different times.
15:51:50 <DRMacIver> benny99: I talk really rarely in here. :)
15:52:47 <benny99> DRMacIver: well, but I saw you talking from time to time (also Saizan) -- sorry, didn't want to highlight you
15:52:52 <benny99> if I did
15:53:00 <benny99> now I did for sure.. whatever
15:53:01 <ddarius> The bots are starting to get uppity.
15:53:04 <wagle_home> i had a female renaissance dancer tell me that busks (corsets) were great, once you got used to them, because they then let you make dance moves that would otherwise be hard or impossible..  haskell types are a busk!
15:53:10 <DRMacIver> You didn't. I just happened to be looking at the channel. :)
15:53:25 <benny99> DRMacIver: see ;)
15:53:49 <benny99> ddarius: :D
15:54:08 <benny99> lambdabot: it begins :o
15:55:10 <benny99> I'll leave for today, good night :)
15:55:42 <Peaker> > ((Left 5) >>= return)
15:55:44 <lambdabot>  Add a type signature
15:55:49 <Peaker> > ((Left 5) >>= return)::Maybe Int Int
15:55:50 <lambdabot>      Kind error: `Maybe' is applied to too many type arguments
15:55:50 <lambdabot>     In the typ...
15:55:52 <Peaker> oops
15:55:56 <Peaker> > ((Left 5) >>= return)::Either Int Int
15:55:56 <lambdabot>   add an instance declaration for (Error Int)
15:56:08 <Peaker> why must Left arg be an instance of Error?
15:56:27 <dolio> That's how the instance is declared, unfortunately.
15:57:54 <wagle_home> > fmap (+1) (Left 1)
15:57:56 <lambdabot>  Left 1
15:58:03 <wagle_home> > fmap (+1) (Right 1)
15:58:04 <lambdabot>  Right 2
15:58:20 <wagle_home> > fmap (+1) (1,2)
15:58:21 <lambdabot>  (1,3)
15:58:35 <wagle_home> hmm
15:58:54 <wagle_home> > fmap (+1) (1,2) >>= return
15:58:54 <lambdabot>   add an instance declaration for (Monad ((,) t))
15:59:00 <wagle_home> awww
15:59:04 <wagle_home> 8)
15:59:20 <dolio> Huh, that should work...
16:00:02 <dolio> I guess it isn't actually declared anywhere...
16:00:25 <dolio> (,) t is the writer monad (for monoids t).
16:02:28 <wagle_home> > (1,2) >>= return
16:02:29 <lambdabot>   add an instance declaration for (Monad ((,) t))
16:02:36 <wagle_home> (just in case)
16:02:55 <dolio> Yeah, I checked. It isn't in Control.Monad.Writer or .Instances.
16:03:02 <dolio> I thought it was, but I guess not.
16:03:20 <dcoutts> @seen dons
16:03:20 <lambdabot> dons is in #ghc, #xmonad, #haskell-soc and #haskell. I last heard dons speak 1h 28s ago.
16:03:47 <wagle_home> well, what should return 2 :: (Char, Int) return?
16:04:32 <dcoutts> dons, I realised earlier that we should not have added the instance IsString ByteString in the 0.9.0.x series since it's an api change, it should have been in 0.9.1.x
16:16:21 <lament> wagle_home: is she hot?
16:20:40 <dons> dcoutts: ok. we need to do a version bump anyway
16:23:30 <matthew-_> dons: please encourage those who are interested to contact me with any comments or ideas they have
16:23:44 <dons> ok will do!
16:24:32 <TomMD> A new haskell project starting up?
16:25:41 <psnively> BTW, any word on the status of GHC for PPC Leopard?
16:26:29 <pejo> psnively, I think macports carries a patched 6.8.2 now.
16:29:10 <mofmog> hmm, it seems like my program needs more error checking *sigh*
16:29:14 <mofmog> this is gonna be fun to implement
16:29:47 <psnively> Gah.
16:30:03 <psnively> pejo: Thanks. Any chance of that patch showing up outside macports anytime soon? :-D
16:32:14 <pejo> psnively, the patch is pulled from the ghc trac afaik. There was a discussion with bug numbers on ghc-users mailing list, it started out with a mail from Gregory Wright (sp?) with a subject along the lines of  "ANN: ... 6.8 ... in MacPorts".
16:32:32 <psnively> Thanks, pejo. :-)
16:33:47 <thoughtpolice> matthew-_: very interesting article on session types. reading it now. :) i was wondering when something on this would come about; the haddock generated documentation makes me want to stab my eyes...
16:34:18 <matthew-_> thoughtpolice: yeah, fortunately, I've now broken haddock to the point where it won't generate the documentation
16:34:26 <matthew-_> thus I've also stopped documenting the code
16:34:41 <matthew-_> a series of tutorials seemed like a "Good Idea"
16:35:13 <thoughtpolice> :)
16:46:00 <Lemmih> nibro: Ping.
16:46:12 <solrize> :t hGetChar
16:46:13 <lambdabot> Not in scope: `hGetChar'
16:46:21 <solrize> :t hgetChar
16:46:22 <lambdabot> Not in scope: `hgetChar'
16:46:29 <solrize> :t hPutStr
16:46:30 <lambdabot> Not in scope: `hPutStr'
16:46:31 <Lemmih> :t System.IO.hGetChar
16:46:32 <lambdabot> GHC.IOBase.Handle -> IO Char
16:46:37 <solrize> thanks
16:46:55 <solrize> @src GHC.IOBase.Handle
16:46:55 <lambdabot> Source not found. Do you think like you type?
16:47:09 <Lemmih> nibro: The HSP darcs repo has zero patches...
16:48:23 <Lemmih> nibro: Oh, sorry. I misread your announcement.
16:49:18 <Jedai> matthew-_: On session types I completely share thoughtpolice opinion, both on the tutorial ans the haddock documentation ! ^^
16:49:47 <dons> matthew-_ has achieved olegian feats, imo
16:49:56 <dons> matthew-_,  ICFP paper on the way?
16:50:01 <dons> or at least HW?
16:50:03 * matthew-_ blushes
16:50:10 <dons> I think this would be guaranteed HW material, fwiw
16:50:23 <Jedai> ?source GHC.IOBase
16:50:23 <lambdabot> GHC.IOBase not available
16:50:28 <matthew-_> dons: ICFP is the goal
16:50:30 <nibro> Lemmih: I'm here, what repo did you try? :-)
16:50:33 <dons> ok, sweet
16:50:39 <matthew-_> but I have about 7 days to write the paper
16:50:54 * matthew-_ buys shares in coffee
16:51:08 <Lemmih> nibro: I mistook this for the main repo: http://code.haskell.org/HSP
16:51:08 <lambdabot> Title: Index of /HSP
16:51:21 <nibro> Lemmih: ah, right
16:51:45 <augustss> matthew-_: looks like ICFP stuff to me.  It's about time someone did session types right
16:51:59 <Lemmih> nibro: I look forward to hacking some HSP with you at hac4.
16:52:59 <nibro> Lemmih: awesome! :-)
16:53:26 <matthew-_> augustss: many thanks.
16:56:56 <Saizan> man, i'm going to need to upgrade this pc just to run ghc.. it feels weird
16:56:59 <mofmog> what do i do if there are two conflicting functions but i want to use both?
16:57:07 <mofmog> for example, Parsec's try and IO's try
16:57:26 <thoughtpolice> mofmog: qualified imports
16:57:27 <Saizan> mofmog: you qualify them with the module name
16:58:10 <thoughtpolice> i.e. 'import Text.ParserCombinators.Parsec as P', then just instead of 'try' use 'P.try'
16:59:09 <gwern> @seen lispy
16:59:09 <lambdabot> lispy is in ##logic, #haskell-blah, #darcs, #ghc and #haskell. I last heard lispy speak 1h 15m 33s ago.
16:59:53 <gwern> oh well. at least lispy brought the autoproc repo up to date
17:00:09 <gwern> speaking of which, does anyone here use procmail? you might find it interesting
17:00:31 <gwern> http://projects.codersbase.com/repos/autoproc
17:00:32 <lambdabot> Title: Index of /repos/autoproc
17:00:36 <gwern> @where autoproc
17:00:36 <lambdabot> I know nothing about autoproc.
17:00:49 <gwern> @where+ autoproc http://projects.codersbase.com/repos/autoproc
17:00:49 <lambdabot> It is forever etched in my memory.
17:02:10 <dolio> wagle_home: Sorry, I stepped out to dinner. For (,) t, return a = (mempty, a) ; (m, a) >>= f = let (m', b) = f a in (m `mappend` m', b)
17:03:36 <matthew-_> so is it standard that on reddit, for every 2 up votes you get, there'll be one down vote?
17:03:47 <dolio> wagle_home: So, Char isn't a Monoid, so 'return 2 :: (Char, Int)' isn't allowed.
17:03:48 <matthew-_> is this "how the world behaves" for haskell articles?
17:03:50 <EvilTerran> hence the monoid constraint
17:04:00 <gwern> matthew-_: pretty much
17:04:02 <EvilTerran> matthew-_, that's the internet for you
17:04:38 * matthew-_ is quite glad he doesn't follow reddit or LtU or /. or any of that rubbish
17:05:36 <gwern> LtU, rubbish?
17:05:47 <ddarius> matthew-_: Why isn't your blog in Planet Haskell so I don't have to deal with reddit?
17:05:50 <gwern> Lambda is the ultimate (PL blog)!
17:05:52 <shapr> @users
17:05:52 <lambdabot> Maximum users seen in #haskell: 472, currently: 442 (93.6%), active: 22 (5.0%)
17:06:22 <matthew-_> ddarius: how do I get it in planet haskell?
17:06:36 <matthew-_> I do RSS feeds! what more do you want? The blog is automated with Haskell...
17:06:44 <gwern> and of course, lambda is the ultimate opcode, ultimate political party, and so on...
17:06:57 <ddarius> planet@community.haskell.org
17:07:04 <dolio> LtU is certainly a cut above reddit and slashdot.
17:07:19 <ddarius> LtU is quite a bit more than a cut above reddit and slashdot.
17:08:00 <dolio> Yeah. People who know what they're talking about actually seem to be the norm on LtU.
17:09:06 <dolio> Although, I don't read the discussions, mostly.
17:09:16 <dolio> I just subscribe to the RSS for articles.
17:09:28 <dolio> That is, links to papers.
17:10:11 <ddarius> matthew-_: http://planet.haskell.org/policy.html Covers the details a bit more, but basically email that address saying you want to be added.
17:10:11 <lambdabot> Title: Membership policy - Planet Haskell
17:10:21 <gwern> the forums can be quite interesting
17:10:42 <gwern> particularly for the blue-sky discussions of what could be done with static typing, imo
17:11:17 <matthew-_> ddarius: done
17:12:21 <ddarius> matthew-_: It says at the end of that policy page that the requests are handled in batches so there may not be an immediate reply.
17:12:39 <matthew-_> okeydokie
17:13:16 <matthew-_> well it's past my bed time anyway. Thanks for all the comments and advice today. :)
17:27:24 <gwern> confusing. we have a hfuse on darcs.haskell.org, and we also have a hfuse repo on code.haskell.org!
17:27:35 <gwern> and they seem to be quite different hfuses
17:28:33 <gwern> and then there's the one on http://www.willthompson.co.uk/darcs/hfuse/
17:28:34 <lambdabot> Title: Index of /darcs/hfuse
17:28:42 <gwern> which I *think* was merged with http://code.haskell.org/hfuse/
17:28:43 <lambdabot> Title: Index of /hfuse
17:32:38 <tcr> In the List Monad, is there a way to splice a list into the result list? E.g.: do foo <- [[1,2], [3,4,5]]; sequence (mapM return foo)  => [[1], [2], ...]  comes close, but I'd like [1, 2, ...] (without having to concat the result explicitly)
17:34:53 <nibro> tcr: not sure I understand from that example what you're trying to do
17:35:04 <dolio> > do foo <- [[1,2],[3,4,5]] ; foo
17:35:07 <lambdabot>  [1,2,3,4,5]
17:35:23 * Twey blinks.
17:35:36 <Twey> H... why?
17:35:55 <nibro> aah, right!
17:35:59 <TSC> The list monad glues its results together
17:36:28 <EvilTerran> Twey, that's [[1,2],[3,4,5]] >>= id, ie concatMap id [[1,2],[3,4,5]]
17:36:29 <nibro> if [] is the monad, then [[1,2],[3,4,5]] :: m (m a), so foo :: m a
17:36:31 <dolio> ... = [[1,2],[3,4,5]] >>= \foo -> foo = concatMap id [[1,2],[3,4,5]] = concat [[1,2],[3,4,5]]
17:36:32 <Japsu> In the [] monad, (>>=) == flip concatMap
17:36:58 <Twey> EvilTerran: Oh
17:37:02 <Twey> :-)
17:37:16 <Japsu> > let bind = flip concatMap in [[1,2],[3,4,5]] `bind` id
17:37:16 <lambdabot>  [1,2,3,4,5]
17:37:25 <Japsu> > [[1,2],[3,4,5]] >>= id
17:37:25 <lambdabot>  [1,2,3,4,5]
17:37:38 <Japsu> ^___^
17:37:47 <tcr> dolio: Of course! Thank you!
17:38:07 <dolio> No prob, Bob.
17:39:10 <mauke> >>= id is join
17:39:14 <mauke> and join == concat
17:41:14 <Twey> That's strange
17:41:27 <Twey> I thought id was meant to do nothing to its argument
17:41:41 <Japsu> @type join
17:41:42 <Twey> Oh, but wait, that's after unpacking, isn't it
17:41:42 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:41:47 <Japsu> join removes one level of monadness
17:42:01 <Twey> >>= is the one doing the join?
17:42:07 <mauke> @src join
17:42:07 <lambdabot> join x =  x >>= id
17:42:12 <Japsu> join = (>>= id)
17:42:16 <Japsu> that's the definition
17:42:38 <Twey> @src [] >>=
17:42:38 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
17:42:45 <Twey> Ack
17:42:49 <Japsu> @src [] (>>=)
17:42:49 <lambdabot> m >>= k     = foldr ((++) . k) [] m
17:42:52 <Japsu> ^^
17:42:52 <Twey> AckOh
17:42:53 <Twey> Heh
17:43:08 <Twey> Aye
17:43:10 <bd_> I find going from join/fmap/return makes more sense when looking at how the list monad's constructed
17:43:44 <bd_> join :: m (m a) -> m a, in other words [[a]] -> [a].  And fmap :: (a -> b) -> m a -> m b, so (a -> b) -> [a] -> [b]
17:43:56 <Japsu> [] and Maybe are the simplest monads
17:44:02 <bd_> with m >>= f  =  join $ fmap f m, you can soon see why it happens
17:44:16 <pjd> Japsu: what about Identity?
17:44:21 * pjd ducks
17:44:24 <bd_> or Reader
17:44:24 <Japsu> let me rephrase that
17:44:29 <Japsu> [] and Maybe are the simplest *non-trivial* monads
17:44:38 <Japsu> Reader.. brrh
17:44:43 * Japsu still doesn't grok Reader
17:45:03 <Japsu> @src (r ->) (>>=)
17:45:03 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:45:07 <pjd> Reader is just as simple
17:45:07 <Japsu> @src (->) (>>=)
17:45:07 <lambdabot> f >>= k = \ r -> k (f r) r
17:45:12 <bd_> join f = \e -> f e e; fmap f m = f . m
17:45:14 <bd_> return = const
17:45:39 <bd_> Basically it's a way of threading around a hidden parameter
17:45:40 <Japsu> what are the monadic values in the Reader monad?
17:45:50 <pjd> Japsu: functions
17:45:51 <bd_> Japsu: functions from an environment to a result
17:45:55 <Japsu> hmmmm
17:45:55 <pjd> fmap is (.)
17:46:02 <mauke> > succ . "HAL"
17:46:03 <lambdabot>  "IBM"
17:46:07 <Japsu> @go all about monads
17:46:08 <lambdabot> http://www.haskell.org/all_about_monads/html/index.html
17:46:08 <lambdabot> Title: All About Monads
17:46:11 <Japsu> mauke: lol
17:46:22 <Japsu> lol
17:46:35 <bd_> :t (succ .)
17:46:36 <lambdabot> forall a (f :: * -> *). (Functor f, Enum a) => f a -> f a
17:46:40 <pjd> Japsu: return gives you a constant function, and join gives you a function that "applies twice"
17:46:41 <bd_> hmmm
17:46:46 <Japsu> > map succ "HAL"
17:46:46 <lambdabot>  "IBM"
17:46:53 <Japsu> (pasteable ;)
17:46:56 <pjd> > let square = join (*) in square 5
17:46:57 <lambdabot>  25
17:47:07 <Japsu> wicked
17:47:07 <bd_> :t succ
17:47:08 <lambdabot> forall a. (Enum a) => a -> a
17:47:13 <bd_> mhm
17:47:17 <bd_> :t \a -> (a .)
17:47:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:47:20 <Japsu> @go all about monads
17:47:21 <lambdabot> http://www.haskell.org/all_about_monads/html/index.html
17:47:21 <lambdabot> Title: All About Monads
17:47:22 <pjd> > join (++) "hoy"
17:47:22 <lambdabot>  "hoyhoy"
17:47:24 <bd_> :t (.)
17:47:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:47:28 <EvilTerran> bd_, er, that's just (.)
17:47:43 <EvilTerran> (foo ??) = (??) (foo), regardless of what ?? and foo are
17:47:46 <bd_> ah, a generalized version of some sort?
17:47:49 <bd_> yes, I know
17:47:59 <ddarius> > join f x
17:47:59 <lambdabot>  Add a type signature
17:48:04 <EvilTerran> and then you can beta-reduce and get rid of the lambda
17:48:05 <Japsu> hmmmm
17:48:08 <bd_> hmm, prelude version is just (a -> b) -> a -> b, what's lambdabot using
17:48:09 <Japsu> no (r ->) in AAM?
17:48:10 <ddarius> > join f x :: Expr -> Expr
17:48:11 <lambdabot>  <SimpleReflect.Expr -> SimpleReflect.Expr>
17:48:11 <EvilTerran> > join f x :: Expr
17:48:12 <lambdabot>  f x x
17:48:19 <bd_> er rather
17:48:20 <TSC> bd_: It's using the Functor version
17:48:22 <bd_> b -> c) -> (a -> b) -> a -> c
17:48:31 <bd_> TSC: what module's that?
17:48:43 <bd_> and, ah, (.) = fmap
17:48:45 <EvilTerran> bd_, it's using the instance Functor (e ->) where fmap = (.)
17:49:02 <EvilTerran> well, it's using that idea. except backwards. :P
17:49:08 <TSC> Control.Applicative, I think
17:49:21 <bd_> Prelude Control.Applicative> :t (.)
17:49:21 <bd_> (.) :: (b -> c) -> (a -> b) -> a -> c
17:49:30 <EvilTerran> it's not defined in the standard libraries this way
17:49:38 <EvilTerran> that's just something Cale (IIRC) did for the bot
17:49:42 <ddarius> :t (Prelude..)
17:49:43 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:49:50 <TSC> :t Control.Applicative.liftA
17:49:51 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
17:49:54 <Japsu> (.) = fmap ;)
17:49:57 <EvilTerran> because some people think it should be defined in the standard libraries this way
17:50:00 <mauke> > (id ++ reverse) [1 .. 4]
17:50:01 <lambdabot>  [1,2,3,4,4,3,2,1]
17:50:09 <EvilTerran> and because it's amusing
17:50:15 <ddarius> :t (++)
17:50:16 <lambdabot> forall m. (Monoid m) => m -> m -> m
17:50:20 <Japsu> it'd be cool to have (.) = map = fmap
17:50:21 <ddarius> Wunderbar
17:50:28 <pjd> wooh, nice
17:50:53 <TSC> :t (id ++ reverse)
17:50:53 <lambdabot> forall a. [a] -> [a]
17:51:20 <Japsu> !!
17:51:26 <Japsu> oh
17:51:27 <Japsu> monoid
17:51:32 <mauke> > sortBy (comparing length ++ compare) . words $ "a b foo bar c baz xy"
17:51:33 <lambdabot>  ["a","b","c","xy","bar","baz","foo"]
17:51:35 <Japsu> > id ++ reverse :: Expr
17:51:35 <lambdabot>  Couldn't match expected type `Expr'
17:51:43 <Japsu> > (id ++ reverse) :: Expr
17:51:43 <lambdabot>  Couldn't match expected type `Expr'
17:51:45 <Japsu> bah
17:52:07 <pjd> Monoid++
17:52:08 <glen_quagmire> > (id ++ reverse) :: ([Expr] -> [Expr])
17:52:08 <lambdabot>  <[SimpleReflect.Expr] -> [SimpleReflect.Expr]>
17:52:24 <TSC> That is frightening
17:52:39 <Japsu> @karma Monoid
17:52:40 <lambdabot> Monoid has a karma of 1
17:52:47 <glen_quagmire> > (id ++ reverse) [1,2,3]
17:52:48 <lambdabot>  [1,2,3,3,2,1]
17:53:11 <dafra> hi all
17:53:17 <glen_quagmire> hi dafra
17:53:27 <dafra> anybody using emacs haskell mode ?
17:53:33 <glen_quagmire> i am your MS Office Visual Studio Haskell Help Wizard
17:53:39 <dafra> i got some errors
17:54:02 <TSC> I use it
17:54:09 <glen_quagmire> .cC( emacs not vista compatible )
17:54:16 <dafra> xp there
17:54:29 <dafra> i got errors with haskell-indent
17:54:49 <dafra> so i have to stick to doc-mode ?
17:54:56 <TSC> What errors?
17:55:01 <wagle_home> doctor!  doctor!  it hurts when i used vista!  8)
17:55:11 <EvilTerran> ... I seem to recall some folks wanting to distinguish between Additive (like []) and Alternative (like Maybe) Applicatives
17:55:29 <EvilTerran> how exactly would you characterise the difference?
17:55:58 <dafra> turn-on-haskell-indent -> Wrong type argument: commandp
17:56:43 <TSC> What version of haskell-mode?
17:57:06 <dafra> 2.4 downloaded last week
17:57:53 <dafra> start-interpreter menu fails too
17:59:30 <ddarius> EvilTerran: Right distribution maybe
17:59:46 <TSC> Hm, I am using haskell-mode 2.4 with emacs 22 and emacs 23 without any problems
18:00:17 <dafra> strange
18:00:22 <TSC> It might be worth running "emacs -q" and seeing if it works then
18:00:39 <dafra> what's emacs "-q" ?
18:00:49 <TSC> It doesn't load your init file
18:00:56 <EvilTerran> ddarius, i was thinking, for Alternative, maybe require the operator to be idempotent
18:01:03 <dafra> ok, thanks
18:01:25 <EvilTerran> seeing as i think that'd get, say, both Maybe and Parsec parsers (I think)
18:03:24 <EvilTerran> ddarius, can you elaborate on what you mean by "right distribution"?
18:04:05 <ddarius> (m >>= f) `mplus` (n >>= f) === (m `mplus` n) >>= f
18:04:16 <EvilTerran> ah, over >>=. that makes sense.
18:04:31 <ddarius> But idempotency of section of mplus seems like it would work.
18:06:07 <Twey> Hm, don't seem to be a lot of Haskell jobs going, do there?
18:06:28 <ddarius> Twey: Become a plumber.  The world always needs more plumbers.
18:08:07 <Twey> ddarius: Hahaha
18:08:10 <Twey> Or an undertaker
18:09:13 * ddarius had a girlfriend (of sorts) that had worked in a mortuary.
18:09:21 <Twey> I don't kid myself that I'm good enough to do Haskell professionally (unless training was provided, I guess), but I was just looking around some job sites, and only one of them had a Haskell job -- and that was something really obscure where Haskell knowledge was only mentioned as an aside
18:09:37 <ddarius> @where jobs
18:09:37 <lambdabot> I know nothing about jobs.
18:09:42 <Twey> My next-door neighbour is studying to get into forensic pathology
18:10:00 <Twey> Did work experience in a morgue
18:10:17 <ddarius> @where+ jobs http://www.haskell.org/haskellwiki/Jobs
18:10:17 <lambdabot> I will remember.
18:10:50 <TomMD> @where goodJobs
18:10:50 <lambdabot> I know nothing about goodjobs.
18:10:52 <TomMD> damn
18:12:05 <Twey> Haha, TomMD
18:12:10 <Twey> Oh well... lots in Python anyway
18:12:29 <TomMD> Twey: never again do I wish to be paid for writing Python
18:12:47 <Twey> TomMD: Why?  Bad experiences?
18:12:56 <ddarius> For TomMD, the joy of writing Python transcends monetary gain.
18:13:10 <Twey> Hehe
18:13:21 <mauke> @quote
18:13:21 <lambdabot> Masklinn says: truth is that lambdabot and dons recursively coded each other
18:13:39 <Twey> Hahahaha
18:14:11 <EvilTerran> ddarius, but if we, say, required the operation in Alternative to be idempotent, what'd the requirement for Additive be? that it explicitly not be idempotent?
18:14:58 <TomMD> Twey: Dynamic type systems pissed me off.  I hated running into bugs I knew Haskell would have caught but python let slip till runtime.
18:15:25 <ddarius> TomMD: So what you're really saying is that you need a lobotomy so that you forget about Haskell.
18:15:27 * EvilTerran is trying to think of some arrangement so having different instances for the same type for each makes sense
18:15:35 <Twey> Hehe
18:15:47 <Twey> See, I come from a dynamic background nowadays.
18:16:06 <Twey> I'm used to having to test every branch of my code for subtle bugs.
18:16:30 <TomMD> ddarius: Never!  Most Haskell jobs I know about are more rewarding (money and accomplishments) than Python jobs.
18:16:51 <Twey> Nice if you can get 'em :-(
18:17:15 <gweiqi> so how do you find a haskell job
18:17:18 <EvilTerran> eg, some trickery to make the Alternative for Maybe be left-biased, and the Additive be combining
18:17:38 <blackdog_> gweiqi: get to know haskell people. hm, wonder where you'd find some of them...
18:17:42 * Twey turned down a $90k sysadmin job last year
18:17:43 <dcoutts> don't find one, make one
18:17:47 * Twey must've been mad
18:18:14 <TomMD> Twey: No, that was a good move.
18:18:25 <blackdog_> Twey: how many years have you done sysadmin work? i think there's a definite maximum for retention sanity
18:18:43 <Twey> TomMD, blackdog_: Considering I'm an 18-year-old college dropout... :-\
18:19:16 <Twey> See, this was back when I was still in college, so I decided to stay in education
18:19:24 <Twey> Then dropped out for other reasons anyway :-(
18:19:27 <Twey> *grumble*
18:19:59 <gweiqi> why don't you finish?
18:20:40 <mofmog> hey, what's the currently the best gui system for haskell?
18:20:52 <mofmog> it seems a lot of tutorials on them are sorta outdated
18:21:48 <ddarius> @src Alternative
18:21:48 <lambdabot> class Applicative f => Alternative f where
18:21:48 <lambdabot> 	empty :: f a
18:21:48 <lambdabot> 	(<|>) :: f a -> f a -> f a
18:21:55 <EvilTerran> mofmog, gtk2hs, i think
18:21:56 <Japsu> mofmog: probably wxHaskell or Gtk2Hs, haven't tried either of them
18:21:57 <Twey> gweiqi: Can't reapply until next year... need to stay afloat until then at least :-\
18:22:13 <ddarius> @src Additive
18:22:13 <lambdabot> Source not found. Maybe if you used more than just two fingers...
18:22:25 <mofmog> anyways, on my next project i'm definitely going from error checking in mind... oh god
18:22:45 <gweiqi> Twey: I hear dumpster diving can be rewarding
18:22:51 <Twey> Heh
18:22:58 <EvilTerran> mofmog, what?
18:23:02 <Twey> Anyway, must sleep... 'night all
18:23:18 <EvilTerran> @localtime Twey
18:23:22 <lambdabot> Local time for Twey is Wed Mar 26 01:23:23 2008
18:23:25 <mofmog> evilterran: you should see this interpreter i just finished.
18:23:36 <mofmog> most bad input will make it just die
18:23:48 <mofmog> and i've been reading up on error checking and it seems like it'd be a pain to graft on
18:24:13 <ddarius> Your interpreter isn't monadic?
18:24:19 <mofmog> it is
18:24:26 <mofmog> it's doubly monadic in fact
18:24:34 <gweiqi> what does that mean?
18:24:42 <mofmog> it has two monads at once!
18:24:50 <gweiqi> using transformers?
18:24:53 <mofmog> of course
18:24:56 <gweiqi> k
18:24:56 * EvilTerran has occasionally stepped back from a bit of code he's spent several hours concentrating on intently, thought "jesus christ, what the hell was i smoking when i wrote this?! and why can't i remember?!", and set about re-writing it
18:25:01 <bd_> graft on an ErrorT :)
18:26:08 <blackdog_> heh. old law of computer science: when faced with a problem, add another layer of abstraction. monads just make it explicit :)
18:26:17 <EvilTerran> there's patterns that're kinda necessary to follow to keep code with lots of transfomers tidy and maintainable
18:26:25 <ddarius> It used to be when I looked back on code I wrote years before I would wonder what the fuck was wrong with me.  Now I actually think a lot of my older (but newer than that) code is reasonable.
18:27:04 <EvilTerran> like newtyping your monad stack in another module, writing the appropriately newtype-wrapped and lifted functions in there, and then exporting and using it as if it were a new monad
18:28:54 <gweiqi> to fully encapsulate your implementation of the type as a monadT?
18:29:16 <ddarius> gweiqi: There are a lot of benefits of doing what EvilTerran says.
18:29:27 <ddarius> And he's right that that is standard operating procedure.
18:29:46 <mauke> @quote standard
18:29:46 <lambdabot> Cale says: Screw standardisation, let's just work on base 2.0 now so that by the time Haskell' comes out, it'll be completely out of date.
18:29:53 <mauke> hmm, no
18:29:55 <gweiqi> ddarius: and this is basically just to prevent the spread of ugliness to other modules, right?
18:29:58 <EvilTerran> gweiqi, indeed. it's the encapsulation that's important.
18:30:19 <EvilTerran> gweiqi, it's so you don't have to sprinkle lifts everywhere in your code
18:30:21 <gweiqi> cool
18:30:35 <ddarius> The most obvious and superficial difference is the latter one EvilTerran mentioned.
18:30:35 <tcr> If you have class Foo a b ... can't you have two instances Foo Bar Quux and Foo Bar Zorql?
18:30:36 <EvilTerran> and so you don't have to add more everywhere when you add a new transformer
18:31:02 <EvilTerran> (that last one's the most noticable aspect of the encapsulation)
18:31:02 <mauke> tcr: sure you can, unless functional dependencies say otherwise
18:31:05 <ddarius> (This is why people actually write code this way rather than say that writing code this way is a good idea.)
18:31:29 <gweiqi> so you have functions to lift into a particular monad instead of the general lift?
18:31:49 <ddarius> gweiqi: You just make your monad an instance of MonadState, etc.
18:31:50 <tcr> mauke: That's what it's complaining about. What does that mean exactly?
18:32:16 <EvilTerran> gweiqi, you write pre-lifted versions of the functions
18:32:20 <mauke> it means the class is really class Foo a b | a -> b
18:32:29 <mauke> which says a uniquely determines b
18:33:11 <tcr> Oh, I see.
18:33:14 <mauke> http://haskell.org/haskellwiki/Functional_dependencies
18:33:17 <EvilTerran> gweiqi, as i'd wrap my repeatedly-transformed monad in a newtype which i then wouldn't export the constructor of, i'd need to export functions that can deal with that particular monad for all the functionality i've introduced with transformers and want to expose
18:33:19 <gweiqi> ddarius, EvilTerran: ahh, i see, is there a good starting point to read more about these kinds of issues?
18:33:20 <lambdabot> Title: Functional dependencies - HaskellWiki
18:33:53 <EvilTerran> someone pasted a link which explained this very matter very well a few days ago
18:33:57 <EvilTerran> can't for the life of me remember which
18:34:51 <mofmog> aggghhhh why doesn't IO just work like parsec >_<
18:34:52 <Saizan> Cale's tutorial?
18:34:59 <mofmog> if something is a bad input you should just try again!
18:35:25 <dcoutts> mofmog, or perhaps it should backtrack and try something else :-)
18:35:30 <ddarius> With Parsec3 and a touch of effort you could parse the input stream...
18:35:34 <mofmog> perhaps
18:35:56 <mofmog> well the problem is say i accidently press <enter>
18:36:10 <mofmog> the program just exits instead of saying, "You're doofus, let's try this again"
18:36:25 <mauke> what program?
18:36:51 <mofmog> my stupid attempt at making an interpreter for a simple imperative language
18:37:05 <mauke> well, then don't make your program exit :-)
18:37:20 <mofmog> of course, but that involves checking for errors!
18:37:23 <mofmog> agggghh
18:37:34 <EvilTerran> write a utility function
18:37:39 <mauke> what are you using to read input?
18:37:50 <EvilTerran> "readLineMatching :: (String -> Bool) -> IO String"
18:38:28 <mofmog> i already have "justReadLine"
18:38:54 <mofmog> eventually itll be "justReadthe******Line'
18:47:32 <mofmog> check out this monstrosity: http://codepad.org/oep0rBwR
18:48:24 <EvilTerran> ?where hpaste
18:48:24 <lambdabot> I know nothing about hpaste.
18:48:32 <EvilTerran> ?hpaste
18:48:32 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:49:12 <EvilTerran> for future reference, that's where we usually paste round these parts
18:50:25 <mofmog> no, my code was too long
18:50:33 <mofmog> apparently
18:51:07 <EvilTerran> huh
18:51:21 <EvilTerran> you're right, that's a bit of a monstrosity
18:51:37 <EvilTerran> i'd suggest lexing and parsing seperately
18:51:41 <mofmog> mm
18:51:59 <mofmog> it's so hacked together you can sort of feel the adhoc top down design dripping from it
18:52:03 <EvilTerran> given that parsec is general enough to support parsing on any token stream
18:52:28 <mofmog> it's also some of the most imperative code i've written in haskell
18:52:59 <EvilTerran> also, you don't need do blocks inside a branch if there's only one monadic action in 'em
18:53:09 <EvilTerran> eg, some of those "do if"s
18:53:16 <EvilTerran> "Just x  -> do eval x
18:53:18 <EvilTerran> "
18:53:34 <mofmog> i just had those there just in case hah
18:53:47 <mofmog> i sort of felt i was nesting too many conditions
18:53:56 <mofmog> no actually, that was nagging me like hell
18:54:31 <EvilTerran> listRef ix = listToMaybe . drop ix
18:55:38 <EvilTerran> you could write 195-197 as "case drop b p of { x:_ -> eval x; [] -> takeLine }"
18:56:01 <EvilTerran> (or the equivalent with layout instead of {}s and ;s, of course)
18:59:14 <EvilTerran> modList x i xs = before ++ [x] ++ after where (before,after) = splitAt i xs
19:00:32 <EvilTerran> toExpr = map fromRight . filter leaveRight . mapReadExpr -- now i'm just being picky, but i like pointfree code :)
19:01:07 <EvilTerran> unfortunately, there's no catRights to go with catMaybes
19:01:18 <mofmog> i think the major problem was trying to deal with so much state
19:01:33 <mofmog> also, the fact that "Either" and "Maybe" are so close in functionality infuriates m
19:01:35 <mofmog> e
19:01:58 <EvilTerran> well, that's what Applicative and Alternative are for
19:02:15 * EvilTerran tends to use Alternative f => f instead of Maybe when he can be bothered
19:02:54 <mofmog> well lots of functions return one or the other even though they use them the same way (error checking)
19:04:28 <EvilTerran> you can probably do something clever with Traversable or something to convert between Alternative+Traversable instances without writing any new instance-specific code
19:06:28 <wli> classify :: [Either t t'] -> ([t], [t'])
19:06:50 <EvilTerran> ?hoogle classify
19:06:51 <lambdabot> No matches found
19:07:10 <wli> Maybe t is isomorphic to Either () t
19:07:16 <EvilTerran> ... i thought so. but i hear that'll be somewhere in the stdlib for 6.10
19:22:58 <gwern> > 0.01^500
19:22:58 <lambdabot>  0.0
19:23:24 <ddarius> > 0.01 ^ 500 :: Rational
19:23:25 <lambdabot>  1%10000000000000000000000000000000000000000000000000000000000000000000000000...
19:23:27 <gwern> :t (^)
19:23:27 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
19:27:34 <ddarius> J does control by dualizing sums.
20:13:19 <edward1> @seen ski
20:13:19 <lambdabot> ski is in ##logic and #haskell. I don't know when ski last spoke.
20:14:27 <ahunter> Hey, I'm having some performance problems with System.Random...specifically,I'm using it to generate an (extremely long) random list of Ints, and it seems to be killing the runtime; generating each number is progressively slower
20:14:32 <SamB> can anyone explain the blue stuff in http://research.microsoft.com/~simonpj/papers/boxy/boxy-techreport.pdf ?
20:14:34 <lambdabot> http://tinyurl.com/33y9fw
20:15:14 <edwardk> I decided to continue on with the exponential functor/hoas/catamorphism stuff from the other day: http://comonad.com/reader/2008/higher-order-abstract-syntax-a-la-carte/ Anyone feel like checking to see if I screwed up anything obvious?
20:15:16 <lambdabot> Title: The Comonad.Reader » Higher-Order Abstract Syntax Ã la Carte, http://tinyurl.com/39rjkh
20:16:02 <dons> ahunter: have you tried using one of the high performance random packages on hackage?
20:16:08 <dons> mersenne-random is *very* fast
20:16:12 <Cale> ahunter: That's interesting. It really shouldn't, since it does the exact same thing for each iteration...
20:16:12 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
20:16:24 <sclv_> laziness issues?
20:16:27 <dons> but yeah, the generation cost is the same over time
20:16:30 <ahunter> dons: no, I'll check that out.
20:16:33 <bos> be nice if the mersenne generator were splittable.
20:16:35 <dons> so maybe you're hanging on to the list or something?
20:16:51 <edwardk> samb: explain as in 'why is it in blue?'
20:17:04 <sclv_> ahunter: are you using randomRs?
20:17:09 <SamB> edwardk: well, more like "where do they say what it is"
20:17:13 <dons> there's also the mersenne-pure package, which is almost as fast as the other one, but pure
20:17:13 <ahunter> sclv_: I'm using the list very lazily, yes, but I'm not sufficiently knowledgeable about System.Random to see where that could screw me
20:17:39 <ahunter> sclv_: I'm using (randoms $ mkStdGen <seed>) :: [Int]
20:17:41 <SamB> because those things aren't in the figures in the main paper...
20:17:52 <ahunter> then passing that to a function which iterates across it until terminated (for other reasons)
20:18:43 <gwern> @seen lispy
20:18:43 <lambdabot> lispy is in ##logic, #haskell-blah, #darcs, #ghc and #haskell. I last heard lispy speak 4h 35m 7s ago.
20:18:50 <bos> ahunter: it sounds like you're retaining a reference to the entire list.
20:19:07 <dons> yeah, not the generation, but rather the transformation that's going to be trouble
20:19:17 <ahunter> bos: looking at my code, I am...I can see how that might nuke my space usage a bit, but how does that kill me in time?
20:19:22 <edwardk> samb: heh page 29
20:19:42 <bos> ahunter: because you're accumulating a huge list that doesn't get used, but has to be hit by the GC.
20:19:48 <edwardk> I think they just picked up Wadler's fetish for coloring papers and ran with it ;)
20:19:53 <SamB> it really seems like they should have included a reference there with the first mention of figure 2...
20:20:02 <edwardk> yeah
20:20:07 <bos> ahunter: if you generate 100 million numbers, you'll have a 100 million element list
20:20:08 <ahunter> bos: ah, yes, duh
20:20:16 <edwardk> Wadler at least talks about it in the opening paragraph or two when he uses color
20:20:20 <gwern> @ask lispy I haven't heard much from you lately; what do you think of the autoproc patches? does it still produce a correct working .procmailrc?
20:20:20 <lambdabot> Consider it noted.
20:20:32 <ahunter> bos: thing is, I don't think this program should use enough memory to really hit the GC, but ah, well, I'll see if I can avoid hanging that ref
20:20:53 <bos> ahunter: it's also possible that your problem is somewhere else entirely.
20:21:03 <SamB> edwardk: it's not the use of color that I object to -- it's the addition of things to supposedly reproduced figures without any statement of the addition...
20:21:29 <bos> ahunter: it sounds like you're fairly new to haskell, and it's not unusual for distant causes to have effects somewhere that you won't necessarily expect.
20:21:47 <bos> profiling is your friend.
20:22:00 <ahunter> bos: possibly.  otoh, swapping out the randomly generated list for something like [1..total] just plain works.  I'm aware of the nasty-non-obvious problems, yes...just not great at finding where mine is, of course
20:22:28 <Cale> ahunter: Are you using the elements of the list in order?
20:22:37 <ahunter> Cale: yes
20:22:41 <Cale> okay...
20:24:35 <sclv_> >> randoms $ mkStdGen 12 :: [Int]
20:24:38 <sclv_> > randoms $ mkStdGen 12 :: [Int]
20:24:39 <lambdabot>  [-210336530,1960816370,1831137698,-2016069848,347972675,864025317,759729547,...
20:25:09 <sclv_> the values randoms gives are obv. going to be different than [1...1000] -- any chance at all that this might span an issue elsewhere?
20:25:40 <sclv_> or not.
20:26:20 <ahunter> sclv_: possible, highly unlikely. among other things, same behaivor observerd with something roughly equiv. to map (`mod` 1000) $ randoms $ mkStdGen 12
20:26:47 <sclv_> huh.
20:28:30 <sclv_> I'm running that in my ghci and while its filling my term with junk, it doesn't seem to show the slightest sign of slowing... :-)
20:28:31 <SamB> what colors has wadler used?
20:29:35 <ahunter> sclv_: heh.  also, unless I'm missing something, I don't think it's GC and hanging on to the list--if I make just as long lists with [1..total] or w/e, I don't get the same problem, as noted
20:29:43 <sclv_> one last shot in the dark -- are you using anything like the (!!) operator?
20:29:59 <ahunter> nope
20:30:23 * sclv_ sighs and goes back to his sandwich.
20:36:18 <SamB> edwardk: so the "â f" part added into the "Î â¢ t : Ï' â  f" judgement is the translation into system F?
20:39:30 <SamB> hmm, they forgot to add a "âf" to the box above the rules for â¢poly...
20:45:38 <gwern> well, I've figured out why qthaskell will probably never show up on Hackage
20:45:48 <gwern> binding to a C++ library *sucks*
20:46:47 <gwern> you have to like go 'autoreconf; qmake; gmake; runhaskell Setup configure; runhaskell Setup build; runhaskell Setup build; runhaskell Setup install' and that probably will only work on Linux!
20:47:25 <gwern> oy gevalt! C++ is definitely going on my Bad Guys list
20:48:31 * SamB wonders how the subsumption judgement can define include a translation, since there is no code involved in a subsumption???
20:50:45 <ahunter> So, interestingly (?), if I replace <big random list> with [1..total], then each time I use an element i of the list, replace that with  fst $ next $ mkStdGen i, my performance goes way back up again.  Why?  I'm very, very unclear.
20:51:05 * SamB decides to go sleep instead of trying to understand that stuff
20:55:39 --- mode: irc.freenode.net set +o ChanServ
20:56:43 * SamB switches back to the default input method so as to stop playing with SCIM
21:10:52 <ahunter> Am I right in assuming that "foldr seq" will force a list to be fully evaluated (or, at least, evaluate each element to WHNF?)
21:11:16 <ahunter> Well, "foldr seq ()", say.
21:11:34 <Lemmih> ahunter: Yes.
21:13:31 <sclv_> ?type seq
21:13:37 <lambdabot> forall a t. a -> t -> t
21:14:20 <sclv_> ?ty foldr1 (\a-> a `seq` a)
21:14:21 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
21:14:21 <lambdabot>     Probable cause: `seq' is applied to too many arguments
21:14:21 <lambdabot>     In the expression: a `seq` a
21:14:38 <Cale> x `seq` x is always pointless
21:14:45 <sclv_> oh, right...
21:15:43 <sclv_> ?hoogle rnf
21:15:43 <lambdabot> Control.Parallel.Strategies.rnf :: NFData a => Strategy a
21:15:54 <sclv_> the easy way ^^
21:18:22 <biouser> anyone know of a latex package/command that will create a verbatim-like haskell syntax highlighting?
21:18:37 <ivanm> listings?
21:18:52 <biouser> ah, listings... let me check up on that, thnks
21:19:14 <ivanm> AFAIK, that's the default generic code pretty-print library for latex
21:19:35 <ivanm> there is valgrind, etc. but they usually require pre- or post-processing
21:23:40 <OceanSpray> guys, I've been wondering...
21:23:51 <OceanSpray> how does Haskell's pattern matching work, "under the hood"?
21:24:14 <Cale> OceanSpray: comparing integers to one another, mostly
21:24:31 <OceanSpray> Oh.
21:24:46 <OceanSpray> well, I've been wondering more.
21:25:13 <OceanSpray> pattern matching, at it's most basic, is the application of inverse functions and the checking of their domains, no?
21:26:14 <Cale> Well, sort of, but in Haskell, the patterns available to you are so limited that I'm not sure that's really the best formalism for it.
21:26:25 <bitrot> evening, #haskell-ers
21:26:40 <bd_> It's basically examining which constructor is being used, recursively, isn't it?
21:26:54 <Cale> bd_: right
21:26:55 <bitrot> I'm hung up on how to properly determine if a list of tuples all has the same second element
21:27:02 <bitrot> any ideas?
21:27:10 <Cale> bitrot: pairs?
21:27:26 <bitrot> Cale: yes.
21:27:27 <Cale> > map snd [(1,2),(3,4),(5,6)]
21:27:28 <lambdabot>  [2,4,6]
21:27:37 <bitrot> doh
21:27:39 <bd_> (length $ nub $ map snd somelist ) > 1 ?
21:27:40 <Cale> > map snd [(1,2),(3,2),(5,2)]
21:27:40 <lambdabot>  [2,2,2]
21:27:52 <OceanSpray> Now bear with me for a minnit.
21:28:11 <bd_> [] /= tail $ length $ nub $ map snd somelist <-- this would probably work better actually
21:28:26 <Cale> bd_: Don't abuse the associativity of $ :)
21:28:45 <ahunter> heh
21:28:47 <bd_> [] /= (tail . length . nub . $ map snd somelist), oops
21:29:02 <Cale> > null . drop 1 . group . map snd $ [(1,2),(3,2),(5,2)]
21:29:02 <lambdabot>  True
21:29:06 <Cale> > null . drop 1 . group . map snd $ [(1,2),(3,3),(5,2)]
21:29:06 <lambdabot>  False
21:29:16 <bd_> why drop 1?
21:29:27 <TSC> To see if there is more than one group
21:29:37 <Cale> exactly.
21:29:39 <wagle_home> > null . drop 1 . group . map snd [(1,2),(3,3),(5,2)]
21:29:39 <lambdabot>   add an instance declaration for (Num [a])
21:29:39 <lambdabot>     In the expression: 2
21:29:39 <lambdabot>     In t...
21:29:47 <ddarius> > liftM2 (all . (==)) head tail $ map snd [(1,2),(3,2),(5,2)]
21:29:47 <lambdabot>  True
21:29:51 <ddarius> > liftM2 (all . (==)) head tail $ map snd [(1,2),(3,2),(5,5)]
21:29:52 <lambdabot>  False
21:29:52 <idnar> . # heh
21:29:55 <idnar> err, . $ heh
21:29:59 <TSC> "null . drop 1" tests for a singleton or empty list
21:30:17 <bitrot> ah, I love #haskell :D
21:30:21 <OceanSpray> An unary, one-to-one function, such as a data constructor, has an inverse function that is also one-to-one and unary, aye?
21:30:24 <bd_> right, but what about null . head ?
21:30:34 <Cale> bd_: You mean null . tail ?
21:30:36 <bd_> er
21:30:37 <bd_> yes
21:30:42 <Cale> that'd work too
21:30:51 <TSC> tail doesn't work on []
21:30:52 <idnar> tail [] is an exception
21:30:56 <bd_> ah, point
21:31:10 <Cale> tail is an inherently dangerous function :)
21:31:12 <ddarius> OceanSpray: No.  If the codomain is bigger than the domain...
21:31:41 <OceanSpray> codomain?
21:31:51 <ahunter> > let ls = map snd [(1,2),(2,2),(3,2)] in (and $ map (== (head ls)) (tail ls))
21:31:52 <lambdabot>  True
21:32:02 <OceanSpray> oh.
21:32:55 <ddarius> You do have an embed-project pair though
21:33:10 <OceanSpray> well, that pretty much killed it.
21:33:36 <Cale> OceanSpray: If X and Y are any sets, and f is a function X -> Y, then X is called the domain, and Y is called the codomain. The subset of the codomain: f(X) = {y in Y : f(x) = y for some x in X} is called the range of f.
21:33:52 <Cale> (just to clear up terminology :)
21:34:31 <bitrot> thanks Cale, ddarius.
21:34:42 <OceanSpray> I was just bothered by the lack of first-class patterns.
21:34:57 <OceanSpray> having "functional" pattern-matching would be so cool.
21:35:21 <ddarius> Just combine Maybe valued functions.
21:35:40 <Cale> OceanSpray: But there are injective functions which are computationally difficult to invert.
21:35:50 <wagle_home> bisimulation patterns
21:36:25 <OceanSpray> "injective"?
21:36:35 <ahunter> OceanSpray: one-to-one, if you know that
21:37:37 <dobblego> @google injective function
21:37:38 <lambdabot> http://en.wikipedia.org/wiki/Injective_function
21:37:38 <lambdabot> Title: Injective function - Wikipedia, the free encyclopedia
21:38:24 <Cale> In fact, it can also be computationally hard to decide whether a given element is in the range of f at all, for arbitrary injective functions f.
21:39:02 <OceanSpray> that's what the type system is for, no?
21:39:10 <Cale> Hm?
21:40:39 <ahunter> OceanSpray: consider a function f x y = (uniq . sort . factor x) !! y...i.e the yth unique factor of x
21:41:10 <ahunter> for any given x, (f x) is injective--31 is either the 4th factor, or the 6th, or not a factor, but it isn't both 4th and 6th
21:41:34 <Cale> For example, consider the function  f: Integer -> Bool which, given an integer n, evaluates the condition n >= 4 and n is odd => n is expressible as a sum of two primes. Deciding whether False matches the pattern (f n) will solve Goldbach's conjecture.
21:41:50 <ahunter> otoh, asking "is 31 in the image of (f x)?" is very, very hard
21:42:08 <ahunter> Cale: ok, mine is easier to compute, you win :)
21:42:24 <OceanSpray> hm.
21:43:14 <OceanSpray> ahunter, your function isn't unary.
21:43:25 <OceanSpray> Cale, your function is not one-to-one.
21:43:36 <Cale> good point, I can make it one-to-one though
21:44:22 <ahunter> OceanSpray, (f x) is unary for any single x.  Or, just consider f x = (uniq. sort . factor 1324141341431441346575471) !! x.  Better?
21:45:40 <OceanSpray> hm.
21:46:14 <Cale> hmm, except maybe not without reducing the difficulty
21:46:45 <Cale> Might need another example for that :)
21:47:15 <OceanSpray> is ahunter's example demonstrating the codomain > range problem?
21:48:33 <Cale> > 17 * 37 * 179 * 5372503 * 2189041534727
21:48:34 <lambdabot>  1324141341431441346575471
21:48:46 <ahunter> Cale: try it again with my PGP key, I dare you :P
21:49:03 * wagle_home waits
21:49:24 <ahunter> Cale: How about f x = if (x >= 4) && (even x) && <not the sum of two primes> && (not $ or [f i | i <- [1..(x-1)]) then -1 else x
21:49:34 <adu> hi wagle_home
21:49:44 * wagle_home waves
21:50:31 <Cale> How about the function f which takes an integer n, treats it as the number of a Turing machine, and if that Turing machine halts on empty input, then it gives 2*n, otherwise 2*n-1
21:51:18 <Cale> hehe
21:51:20 <OceanSpray> Turing machines have numbers?
21:51:34 <TSC> Then can
21:51:34 <Cale> Of course, my f isn't computable, but it is injective ;)
21:52:10 <OceanSpray> Oy, forget this whole functional pattern matching idea.
21:52:23 <Cale> Well, let's see if we can come up with a good example.
21:52:51 <wagle_home> almost injective  (consider machine 0 (1 and 0) and machine 1 (2 and 1)
21:52:53 <Cale> A function which is simulataneously computable, injective, and total
21:53:03 <ahunter> Cale: What's wrong with my last example?
21:53:15 <Cale> let me look :)
21:53:33 <Cale> ahunter: I'm not sure it's injective
21:54:03 <ahunter> Cale: has to be: f x = x, unless x is the least counterexample to Goldbach, in which case f x = -1
21:54:27 <Cale> ah, I see, yes
21:54:43 <ahunter> well, technically it's only injective for x != -1, but I think I'll live
21:54:48 <Cale> You'd have to worry about where it sends -1
21:54:51 <Cale> but whatever
21:55:07 <Cale> You could say that if n is negative then it goes to n-1
21:55:11 <ahunter> For example, define it on data Nat = Zero | Succ Nat
21:55:15 <lament> turing machines have license plate numbers, but they're different in different states)
21:55:20 <ahunter> Cale: that also works
21:56:01 <OceanSpray> "<Cale> A function which is simulataneously computable, injective, and total "
21:56:16 <OceanSpray> such a function would be "pattern-matchable"?
21:56:37 <ahunter> OceanSpray: yes, I believe, but possibly in a computationally intractable way
21:56:38 <Cale> OceanSpray: still not easy
21:56:55 <Cale> OceanSpray: but yeah, those are the least properties you'd want
22:05:41 <bitrot> hmm...so what's the most sensible method of translating function composition to function application, given that: null $ drop 1 $ group $ (map snd someList)  is equivalent to null . drop 1. group . map snd $ list  ?
22:06:01 <bitrot> is it just a matter of recognizing their fixity?
22:06:35 <bitrot> keep in mind, i'm somewhat new to this ;)
22:07:00 <Cale> Yeah, $ is right associative (which is unfortunate, as left associative would be more useful)
22:07:24 <Cale> So f $ g $ h $ x is the same as  f $ (g $ (h $ x))
22:07:33 <Cale> which is the same as f (g (h x))
22:07:40 <Cale> which is the same as (f . g . h) x
22:07:40 * dolio is still waiting for Cale to switch ($) in lambdabot.
22:08:11 <dolio> I guess that's not generalization, though.
22:09:11 <bitrot> what initially confused me was the ($) in map snd $ list.  it just doesn't seem to belong there
22:09:19 <Cale> Yeah, I considered it, but it's even more confusing than the other changes I've made.
22:09:38 <dobblego> is flip ($) in the standard libraries somewhere?
22:09:49 <Cale> flip ($) isn't what we want :)
22:10:03 <dobblego> I know, but I do and it juts reminded me
22:10:07 <Cale> ah
22:10:09 <Cale> no
22:10:10 <dobblego> *just
22:10:37 <dolio> You could wrap everything in Identity and use >>=.
22:11:24 <dolio> > runIdentity (return 5 >>= (+1) >>= (*2) >>= succ)
22:11:26 <lambdabot>   Not in scope: `runIdentity'
22:12:24 <dolio> Oops, that's wrong.
22:12:53 <dolio> Those all have to be 'return . f'.
22:13:09 <bd_> Cale: why would left-associative be more useful than right for $?
22:13:46 <Cale> bd_: because while we can rewrite expressions of the form  f $ g $ h $ x as f . g . h $ x
22:14:10 <Cale> We don't otherwise have a way to remove parens from expressions like f (g x) (h y) (k z)
22:14:22 <bd_> ahh
22:14:31 <Cale> Which, if $ were left-associative, would simply be  f $ g x $ h y $ k z
22:15:02 <bd_> ic
22:15:21 <Cale> Also, f $ g $ h $ x is somewhat less easy to manipulate than f . g . h $ x
22:15:38 <dolio> It also leads to left-associative $!
22:15:40 <Cale> In the latter, g . h is effectively a subexpression
22:15:57 <Cale> But g $ h is likely to be ill typed, and is not a subexpression of the first
22:16:26 <dolio> Where, currently, if you want to strictly apply several arguments to a function, you have to write: (f $! x) $! y
22:16:38 <Cale> yes, and that's really ugly
22:17:29 <dolio> Or, even, if you want to apply any argument other than the last strictly.
22:32:58 <gwern> whew. glad I got that dbus package hacking out of the way
22:33:03 <gwern> autotools are no fun
22:33:52 <gwern> @where soc
22:33:53 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
22:44:39 <NekoIncardine> Good evening. I'm a novice learning Haskell for a school project (coming from Java, it's different, but I'm liking elements of it). I'm trying to figure out some particular questions, and figured I should give this room a look.
22:45:00 <glguy> NekoIncardine: Feel free to ask
22:45:00 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
22:45:49 <NekoIncardine> ... Man I'm not used to some of ChatZilla's quirks. I'm an average Windows user, to be honest, normally I prefer mIRC, but figured having a chat system directly connected would be better. Anyways.
22:46:22 <shachaf> edwardk: Directly connected to what?
22:46:31 <shachaf> s/edwardk/NekoIncardine/
22:47:23 <NekoIncardine> I have defined a function using the lines "columnFind :: Integer -> Integer", then "columnFind n = ((n-1) mod 9)+1". The latter line's purpose is to determine which column a particular place number out of a list of 81 such places on a 9*9 grid would belong. (Sudoku Solver, of course.)
22:48:19 <shachaf> NekoIncardine: You probaby want "(n-1) `mod` 9"
22:48:26 <NekoIncardine> ... ah.
22:48:58 <NekoIncardine> The 's' were not listed in the Haskell in 10 minutes tutorial or other sources I looked up trying to figure out modulo functions.
22:49:05 <shachaf> NekoIncardine: Any function can be turned into an infix operator by adding ``.
22:49:15 <NekoIncardine> ... ' or "?
22:49:20 <shachaf> NekoIncardine: This is just syntax sugar for "mod (n-1) 9".
22:49:28 <NekoIncardine> Ah.
22:49:29 <shachaf> NekoIncardine: No, `` are special.
22:50:15 <shachaf> '' and "" are for characters and strings, respectively (well, ' can also be used in names).
22:50:17 <bitrot> > mod 9 2
22:50:17 <lambdabot>  1
22:50:23 <bitrot> 9 `mod` 2
22:50:38 <bitrot> > 9 `mod` 2
22:50:39 <lambdabot>  1
22:53:29 <shachaf> NekoIncardine: Any operator can be turned into a function by adding parentheses, by the way:
22:53:32 <shachaf> > (+) 1 2
22:53:33 <lambdabot>  3
22:54:07 <NekoIncardine> All right.
22:56:50 <NekoIncardine> Yay. One part of the task solved... Next step, more of the Haskell tutorial to figure out types. Do tuples have to be two nodes (x,y), or could they be a larger list of nodes (a,b,c,d,e,f,g,h,i,j)?
22:57:07 <Cale> NekoIncardine: They can be larger
22:57:25 <Cale> NekoIncardine: But of course (5,6) is of a completely separate type from (5,6,7)
22:57:32 <NekoIncardine> Makes sense.
22:57:36 <bd_> And large tuples are inconvenient to work with
22:57:37 <shachaf> NekoIncardine: You probably don't want to use tuples when they get that big, though.
22:57:52 <shachaf> NekoIncardine: You can make your own datatypes very easily.
23:00:16 <NekoIncardine> True. My basic idea is to represent a tile as 10 items: one integer and nine booleans. Basically, if I'm thinking this right, that's all I need and then a little to reprsent a single square in a Sudoku, as long as I have a list of 81 such squares that comprise a full puzzle. (I tried to figure out a twos-complement based schema that would allow me to reduce that to just one integer, but I...
23:00:18 <NekoIncardine> ...found I couldn't really wrap my mind around it too well...)
23:01:21 <Cale> You might want to try an Array of Boolean values.
23:01:33 <lament> a twos-complement based schema would qualify as premature optimization
23:01:55 <NekoIncardine> So I could have a type,  SudokuTile, consisting of Integer -> boolean[9] then?
23:02:04 <Cale> 9-tuples will of course work, but you'll find yourself typing something like (a,b,c,d,e,f,g,h,i) a bunch :)
23:02:42 <NekoIncardine> True. I'm used to that kind of repetitive typing, but now htat I think about it that would involve a large number of redundant lines.
23:02:43 <lament> NekoIncardine: withou the ->
23:03:09 <Cale> The type of your array would be  Array Integer Bool
23:03:15 <lament> NekoIncardine: any sort of repetition in your code is usually an error
23:03:23 <lament> (a design flaw)
23:03:28 <Cale> (that is, an array indexed by Integers and holding Bool values)
23:03:30 <NekoIncardine> Again, most true.
23:04:32 <lament> i'm guessing it's something like Either Integer (Array Integer Bool)
23:04:59 <lament> although i guess an array of booleans is enough
23:05:01 <NekoIncardine> So I would format a single tile using the line "data Tile = Array Integer Bool", if I'm thinking this correctly?
23:05:17 <NekoIncardine> Or just "Integer (Array Bool)?
23:05:41 <Cale> data Tile = Tile Integer (Array Integer Bool) ?
23:05:52 <Cale> (you must have a data constructor)
23:06:18 <Cale> If a tile is both an Integer and an array of booleans...
23:06:21 <NekoIncardine> Hrm... I'm just trying to make sure I understand the meaning of this clearly.
23:06:42 <Cale> I'm not entirely sure I understand what you're trying to represent :)
23:06:59 <lament> NekoIncardine: is a tile an array of booleans, or an integer AND an array of booleans, or perhaps EITHER an integer OR an array of booleans?
23:07:02 <Cale> If the Integer is only for when you know for certain which number it is,
23:07:03 <NekoIncardine> "data Tile =" represents the declaration "this is a type set", that's unambiguous to me.
23:07:16 <NekoIncardine> Lament: I was working on the idea of an Integer AND an array of booleans.
23:07:25 <Cale> It means we're declaring a new datatype called Tile
23:07:31 <johnnowak> Does anyone know of a language where the assigning of types is deferred in certain cases? For example, Haskell cannot give a type to \x -> x x, but if it is later known that x is 'const', the type 'a -> b -> c -> b' can be given.
23:07:36 <Cale> NekoIncardine: What does the extra Integer mean?
23:08:12 <Cale> johnnowak: hm?
23:08:20 <NekoIncardine> The Integer would be used with two meanings; first, to indicate if a tile has been formally solved (which not only means verifying only one possibility remains, but removing that possibility from every tile in its group/row/column as well)
23:08:30 <Heffalump> johnnowak: umm, no it can't
23:08:47 <NekoIncardine> And then once it has been solved, to indicate which value it is to speed up output at the end.
23:08:59 <Cale> data Tile = Solved Integer | Unsolved (Array Integer Bool)
23:09:04 <Cale> Perhaps something like that?
23:09:11 <Heffalump> (a -> b -> a) -> (a -> b -> a) perhaps?
23:09:28 <Cale> That says that a value of our new type Tile is either of the form (Solved n) for some Integer n
23:09:44 <Cale> Or (Unsolved a) for some array from Integer to Bool named a
23:09:56 <NekoIncardine> All right... That makes a little more sense.
23:10:10 <NekoIncardine> "From integer to bool" means an array of an integer-based number of booleans then?
23:10:23 <lament> i think i'd actually store a set of integers in each tile, such that "solved" tiles contain only one element... but i never actually tried to solve sudokus
23:10:30 <Cale> Arrays in Haskell can be indexed by things other than integers if you like
23:10:45 <Cale> For example, pairs of integers are common, for 2-D arrays
23:10:57 <johnnowak> Cale: where did I lose you?
23:11:11 <Cale> johnnowak: How (\x -> x x) can be given that type.
23:12:05 <dolio> @type (\x -> x x) :: (forall a. a -> b) -> b
23:12:07 <lambdabot> forall b. (forall a. a -> b) -> b
23:12:24 <johnnowak> Cale: i'm suggesting that (\x -> x x) not be given a type
23:12:40 <johnnowak> and that you wait until you know what 'x' is
23:12:59 <Cale> But you won't know that until runtime, no?
23:13:02 <NekoIncardine> If I am thinking correctly, Solved and Unsolved would NOT need to be specified types in the Tile example. Is this accurate thinking on my part?
23:13:05 <Cale> Or just what type x is?
23:13:10 <johnnowak> Cale: just the type of x
23:13:18 <bos> is there a simple way to explain the need for FlexibleInstances?
23:13:19 <Cale> NekoIncardine: right, they're labels for the two cases
23:13:44 <bos> i can't find a way to explain them in a handful of sentences.  they struggle to fit into a single page.
23:15:08 <sjanssen> bos: to explain the need for them, or to explain why they're not in Haskell '98?
23:15:13 <johnnowak> Cale: maybe this helps:
23:15:17 <johnnowak> (define (m f) (f f))  ; deferred
23:15:17 <johnnowak> (define (id x) x)     ; a -> a
23:15:18 <johnnowak> (define (foo) (m id)) ; a -> a
23:15:21 <dolio> @type ((\x -> x x) :: (forall a. a -> b) -> b) const
23:15:22 <lambdabot>     Inferred type is less polymorphic than expected
23:15:22 <lambdabot>       Quantified type variable `a' escapes
23:15:22 <lambdabot>     In the first argument of `((\ x -> x x) ::
23:15:23 <bos> sjanssen: to explain the need.
23:15:38 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-decls
23:15:40 <lambdabot> Title: 8.6. Class and instances declarations, http://tinyurl.com/245leb
23:15:46 <dolio> @type ((\x -> x x) :: (forall a. a -> b) -> b) const 5
23:15:47 <lambdabot>     Inferred type is less polymorphic than expected
23:15:47 <lambdabot>       Quantified type variable `a' escapes
23:15:47 <lambdabot>     In the first argument of `((\ x -> x x) ::
23:15:50 <bos> sjanssen: because they cover several different cases.
23:16:12 <bos> Cale: yes, i know what they're for, but it's difficult to condense out.
23:16:44 <bos> especially since in my case, i need flexible instances because i'm using fundeps.
23:16:47 * johnnowak wonders if he's lost everyone
23:16:55 <bos> i think i'll just say "here be dragons".
23:17:07 <NekoIncardine> Now to figure out which type of Array I want to import to bring ARrays in.. *Looks through the wiki and a couple other online sources first*
23:17:20 <sjanssen> bos: perhaps start with something simple like instance Foo [Word8]?
23:17:22 <dolio> @type ((\x -> x x) :: (forall a. a -> b) -> b) (const 5) -- duh
23:17:23 <lambdabot> forall b. (Num b) => b
23:17:47 <bos> sjanssen: well, that's haring off on the wrong path.
23:18:12 <johnnowak> @type (\x -> x x) (const 5)
23:18:13 <Cale> > ((\x -> x x) :: (forall a b. a -> b -> a) -> (forall a b c. c -> a -> b -> a)) const 5 6 7
23:18:13 <lambdabot>  Parse error at "." (column 28)
23:18:13 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
23:18:13 <lambdabot>     Probable cause: `x' is applied to too many arguments
23:18:13 <lambdabot>     In the expression: x x
23:18:26 <Cale> huh.
23:18:27 <dolio> johnnowak: You don't need to defer the type of that, you just need to give it a rank 2 type.
23:18:40 <johnnowak> dolio: I'm not talking about Haskell. I'm just asking if any language defers types.
23:18:53 <dolio> Which is even decidable if you don't have polymorphic let, I think.
23:19:15 <dolio> Although throwing that away might be a pain.
23:19:19 <Cale> johnnowak: The trouble is just that type inference for higher-rank types is computationally expensive.
23:19:32 <johnnowak> Cale: the trouble with what exactly?
23:19:34 <Cale> (if it's possible at all)
23:19:55 <dolio> rank-3 and beyond is undecidable, from what I've heard, though.
23:20:13 <johnnowak> yes i know. I'm suggesting this as a way to avoid higher rank types in some cases.
23:20:40 <bos> sjanssen: thanks anyway
23:20:42 <johnnowak> if you defer the type of let 'f = (\x -> x x)', and then do 'f id', you can type 'id id' instead
23:20:45 <sjanssen> "The Haskell '98 specification is quite conservative in the form of allowed instances, instances must be of the form "(T a b ...)" where T is a type constructor and "a b ..." are unique type variables.  There is an extension called "flexible instances" that relaxes these restrictions, allowing instances for types such as "[Char]", "Either a a", etc."
23:21:02 <sjanssen> bos: ^^^ that seems sufficient to me
23:21:15 <sjanssen> unless you want to get into the really technical stuff like the coverage condition
23:21:44 <bos> sjanssen: unfortunately, it's exactly the coverage condition that demands FlexibleInstances here.
23:22:08 <sjanssen> basically "H98 instances are strict, but we can ask GHC to relax the conditions"
23:22:12 <sjanssen> mm
23:22:26 <dolio> Hum, I guess that's another typing.
23:23:00 <dolio> :t ((\x -> x x) :: (forall b. b -> b) -> b -> b) id
23:23:01 <lambdabot> forall b. b -> b
23:24:24 <NekoIncardine> Hrm... Now I have the datatype and the ability to take an arbitrary tile number and figure it's row, column, and group. That leaves only the processing method, which I'll try and work on tomorrow with my project partner. (I get the sense there's going to be a tad more involved there.)
23:25:41 <NekoIncardine> I still have a Technical Writing project to finish up as well. Thank you very much for the assistance and clarifications; things are now clearing up for my understanding of functional languages.
23:26:47 <NekoIncardine> When you're used to object-oriented work, suddenly going with a completely different toolbox is a little disorienting. I figure I can adjust to it over time. :)
23:37:30 <biouser> I am trying to do a nested loop i 1 to n, j 1 to m, k 1 to o, l 1 to p
23:38:02 <dons> use a list comprehension
23:38:24 <biouser> so I in put [4,4,4,4] and I get [(1,1,1,1),(1,1,1,2)... (4,4,4,4)]
23:38:32 <dons> > [ (i,j) | i <- [1..5], j <- [1..4]
23:38:32 <lambdabot>  Parse error at end of input
23:38:35 <dons> > [ (i,j) | i <- [1..5], j <- [1..4] ]
23:38:37 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4),(4,...
23:39:00 <biouser> very nice dons
23:39:07 <TSC> Yes, he is very nice
23:42:21 <lament> where did you put [4,4,4,4]?
23:42:41 <biouser> positions :: Hyper_dim -> [Hyper_pos]
23:42:41 <biouser> positions [n,m,o,p] = [ (i,j,k,l) | i <- [1..n], j <- [1..m], k <- [1..o], l <- [1..p] ]
23:43:42 <biouser> it's a basic little animal but it does what I wanted it to
23:44:33 <lekro> is flip id a common idiom or is it just something that lambdabot seems to like?
23:47:00 <scook0> I think you'd be more likely to write flip ($)
23:47:08 <scook0> or use a right section on ($)
23:49:20 <lispy> :t map (flip ($))
23:49:20 <lambdabot> lispy: You have 1 new message. '/msg lambdabot @messages' to read it.
23:49:21 <lambdabot> forall a b. [a] -> [(a -> b) -> b]
23:50:54 <lispy> gwern: ping?
23:51:28 <lispy> lekro: flip is not uncommon, but I find that if I'm using it a lot, I'll gave the flipped version a name
23:51:38 <dons> that's a good rule
23:51:40 <Jedai> positions [n,m,o,p] = liftM4 (,,,) [1..n] [1..m] [1..o] [1..p]
23:51:42 <dons> ?src forM_
23:51:42 <lambdabot> forM_ = flip mapM_
23:55:56 <lispy> :t map (flip ($)) [1..]
23:55:57 <lambdabot> forall a b. (Enum a, Num a) => [(a -> b) -> b]
23:56:20 <lispy> I'm baffled by that type
23:56:47 <lispy> I guess I now need to construct a list of (a -> b)
23:57:11 <lispy> and then apply the returned list of functions to those functions
23:57:50 <lament> positional arguments are the suck
23:57:55 <lispy> :t map (+1) (map (flip ($)) [1..])
23:57:56 <lambdabot> forall a b. (Enum a, Num a, Num ((a -> b) -> b)) => [(a -> b) -> b]
23:57:57 <lament> which explains flip
23:58:16 <lispy> lament: you'd prefer everything is keyword?
23:58:28 <lament> lispy: yes. See Smalltalk.
23:58:44 <lament> where they're still positional but more sanely
23:58:51 <lament> of course, doesn't work with currying
