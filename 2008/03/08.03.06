00:00:07 <goltrpoat> yeah
00:00:26 <dolio> @type \f z -> foldr f z ?l
00:00:28 <lambdabot> forall a b. (?l::[a]) => (a -> b -> b) -> b -> b
00:00:31 <goltrpoat> fax:  i'm saying it's not quite the catamorphism :)
00:00:46 <goltrpoat> yikes.
00:00:47 <faxathisia> goltrpoat: How is it not?
00:01:19 <dolio> It's the catamorphism already applied to whatever value it's supposed to represent.
00:01:42 <dolio> So True is encoded as if True, where if :: Bool -> a -> a -> a.
00:01:45 <dolio> False is if False.
00:01:50 <goltrpoat> that actually ties together everything i was missing, heh.
00:01:51 <faxathisia> I maintain that the eliminator IS the catamorphism
00:01:56 <faxathisia> the are the exact same thing..
00:02:09 <goltrpoat> fax:  sure.
00:02:10 <dolio> m :: Maybe a is encoded as \n f -> maybe n f m.
00:02:10 <faxathisia> the type as a church encoding .. is slighty different
00:02:19 <faxathisia> ok thanks, confusion is gone
00:02:51 <faxathisia> (where slighty different just means remove the first parameter)
00:03:58 <goltrpoat> thanks everyone.
00:04:35 <dolio> I don't know if that applies to coinductive types, though.
00:06:29 <dolio> You'd probably think of encoding those using unfolds.
00:09:12 <goltrpoat> it doesn't apply to coinductive types, i don't think, but i still haven't looked into that a whole lot.  i was trying to figure out how to apply LJ to recursion on inductive types, basically
00:09:32 <faxathisia> what is LJ?
00:09:33 <goltrpoat> and got side tracked for a week, which was apparently all due to missing an a.
00:09:38 <nornagon> so hey... ffi docs are a little tricky to decipher. What should I do if I want to call (from haskell) a C function that takes a function pointer as an argument?
00:09:53 <nornagon> (and then the C code calls that function)
00:11:02 <goltrpoat> fax:  http://en.wikipedia.org/wiki/Sequent_calculus
00:11:02 <lambdabot> Title: Sequent calculus - Wikipedia, the free encyclopedia
00:12:27 <dolio> In fact, that's what that blog article above seems to do.
00:12:29 <dolio> @type unfoldr
00:12:31 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
00:13:31 <goltrpoat> dolio:  yeah
00:13:42 <faxathisia> goltrpoat: I see, so what did you want to do with inductive types? (apply means what here?)
00:13:47 <dolio> Coinductive lists are 'exists b. (b -> Maybe (a,b), b)'.
00:16:54 <goltrpoat> fax:  well, the LJ axioms have this spooky correspondence to the lambda calculus axioms.  adding fix though, breaks everything:  djinn doesn't work on recursive types.
00:17:24 <faxathisia> do you know why fix breaks everything?
00:17:25 <goltrpoat> (fix is a circular argument, adding it as an axiom makes every theorem true -- hence undefined::a)
00:17:31 <faxathisia> ok yeah
00:18:19 <goltrpoat> so the natural inclination is to restrict recursion to particular operations on particular types
00:18:28 <faxathisia> goltrpoat: Not sure if this is what you mean but I have a proof of induction on N that I am very fond of
00:18:46 <faxathisia> goltrpoat: It's not in haskell though..
00:20:07 <goltrpoat> is it online somewhere?
00:20:18 <faxathisia> goltrpoat: It's of forall (P : N -> Prop), P 0 -> (forall n, P n -> P (n+1)) -> (forall n, P n)
00:20:34 <faxathisia> no it's elsewhere, I'll get it though
00:20:42 <faxathisia> goltrpoat: but it uses pattern matching
00:20:52 <faxathisia> because it's in CIC not CoC
00:21:07 <faxathisia> bbs..
00:21:49 <goltrpoat> this is why coq tutorials keep tripping me up.  "and now we use the simple recursion tactic, and voila, the subset relation is transitive"  -- wait wait, how do i write the simple recursion tactic.
00:22:36 <Cheery> in Binary, I'd need to have a way to get signed characters, shorts and integers out from string
00:23:39 <goltrpoat> not that it's a huge amount of effort, it'd be nice if they concentrated a bit less on the library though.
00:26:11 <faxathisia> goltrpoat: http://hpaste.org/6153/0/plain (might need to view source to get the formatting, it's in UTF-8 btw)
00:27:02 <faxathisia> goltrpoat: so it's a function and a fixpoint.. it's sturcturally recursive in a normalizing calculus, that's how this actually counts as a proof
00:27:38 <faxathisia> goltrpoat: pattern matching can be desugared to eliminators (catamorphims whatever you want to call it) but the problem is, where do they come from?
00:28:55 <faxathisia> goltrpoat: .. so basically that's why it's not possible to prove induction in CoC, you need to add pattern matching to the term/proof language
00:29:03 <Cheery> do you know how to convert Word8 to signed Word8 ?
00:29:15 <Cheery> ie. with bounds and all
00:31:56 <oerjan> Cheery: Int8
00:32:38 <oerjan> > 127+1 :: Int8
00:32:43 <lambdabot>  -128
00:33:23 <faxathisia> :t fromIntegral :: Word8 -> Int8
00:33:28 <lambdabot> Word8 -> Int8
00:33:37 <Cheery> :i Int8
00:33:38 <oerjan> > let x = 129 :: Word8 in (x, fromIntegral x :: Int8)
00:33:53 <lambdabot>  thread killed
00:33:59 <oerjan> there is no :i in lambdabot
00:34:02 <oerjan> > let x = 129 :: Word8 in (x, fromIntegral x :: Int8)
00:34:04 <goltrpoat> fax:  still reading, sec
00:34:12 <lambdabot>  (129,-127)
00:34:17 <dolio> faxathisia: What's the difference between CoC and CIC?
00:34:37 <Cheery> @hoogle Int8
00:34:40 <lambdabot> Data.Int.Int8 :: data Int8
00:34:47 <Cheery> oki. :)
00:35:16 <Cheery> > 40000 :: Int16
00:35:17 <lambdabot>  -25536
00:36:27 <oerjan> hm...
00:36:36 <faxathisia> dolio: I think CIC is CoC + datatypes & pattern matching
00:36:44 <oerjan> > fromIntegral (-3 :: Int8) :: Integer
00:36:45 <lambdabot>  -3
00:36:55 <oerjan> > fromIntegral (-3 :: Int8) :: Word16
00:36:56 <lambdabot>  65533
00:36:56 <wagle_home> 40000:: Bool
00:37:00 <faxathisia> dolio: You can't prove induction in CoC but you can in CIC
00:37:33 <oerjan> i see, conversion is sign-extended
00:38:29 <oerjan> hm theoretically it all passes through Integer before optimization
00:39:14 <faxathisia> dolio: on page 7 of http://www.cs.chalmers.se/~coquand/meta.pdf , that's how it's done in CoC, instead of like using data ... in Agda
00:39:36 <faxathisia> (as a couple of examples..)
00:41:13 <faxathisia> (you can do it this way in Agda as well of course, but the datatype way is kind of clearer)
00:41:20 <goltrpoat> so... wait.  we don't need pattern matching explicitly, in the syntactic sense, we need equality and we need to be able to split N, in this case, into Zero and Succ n1, right
00:42:16 <faxathisia> goltrpoat: I don't think so, what I meant is that this is simply impossible without pattern matching
00:43:06 <faxathisia> goltrpoat: I mean there are various axioms you could define it in terms of, but it's not possible without taking new axioms
00:44:17 <goltrpoat> i just meant that pattern matching desugars into simpler constituent parts
00:44:35 <goltrpoat> was wondering what the minimal set of axioms was
00:46:10 <faxathisia> pattern matching <-> catamorphism/eliminator/fold
00:47:18 <swiert> faxathisia: how would you get recursion from just pattern matching?
00:47:20 <goltrpoat> i don't follow.  pattern matching amounts to indexing a finite set of functions
00:47:40 <faxathisia> when you define a datatype like   data N = ...  you can pattern match with that, problem with defining it like (a -> a) -> a -> a is you don't get the eliminator for free
00:47:49 <oerjan> the thing is, the pattern matching in CoC also permits structural recursion
00:47:50 <faxathisia> so you need to take the fold as an axiom
00:47:52 <oerjan> iiuc
00:47:56 <goltrpoat> oerjan:  ohh
00:48:12 <oerjan> argh
00:48:15 <oerjan> i mean CiC
00:48:16 <oerjan> i think
00:48:23 <goltrpoat> yeah i figured
00:50:22 <faxathisia> swiert: oh yeah, it's a requirement to have structural recursion in the pattern match
00:50:39 <faxathisia> I'm pretty certain there is no way to define it without
00:50:41 <dolio> I assume there's a similar extension that enables guarded corecursion (or is that alco CIC?), which is what Coq is based on?
00:56:06 <goltrpoat> in a weird way, that goes back to the whole restricted fix thing i mentioned.  the solver has to do a destructuring bind somewhere, what i was working on was annotating the type with enough information to figure out what *can't* be done with the destructured data
00:56:39 <faxathisia> which solver?
00:57:09 <faxathisia> is this part of a type checker ?
00:57:54 <goltrpoat> my little project.  i want to derive, say, foldl, from (a->b->a)->a->[b]->a and some minimal amount of annotation on the type.
00:58:14 <faxathisia> @src foldl
00:58:15 <lambdabot> foldl f z []     = z
00:58:15 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
00:58:20 <faxathisia> @src foldr
00:58:20 <lambdabot> foldr f z []     = z
00:58:20 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
00:58:21 <goltrpoat> right.  minus the source.
00:58:24 <goltrpoat> :)
00:58:40 <faxathisia> @src []
00:58:40 <lambdabot> data [] a = [] | a : [a]
00:59:45 <faxathisia> :t flip foldr
00:59:48 <goltrpoat> annotations are necessary because there's any number of trivial or non-terminating solutions that satisfy the type.  weirdness is necessary because i'd like the thing to terminate when there's a solution.
00:59:49 <lambdabot> forall a b. b -> (a -> b -> b) -> [a] -> b
00:59:53 <goltrpoat> fax:  exactly
01:00:05 <goltrpoat> not flip foldr, but foldr (flip f)
01:00:07 <faxathisia> pretty confused :P
01:00:25 <faxathisia> foldr (flip f) z xs = foldl f z (reverse xs)
01:00:25 <goltrpoat> you basically need linear types.
01:00:40 <faxathisia> > let xs = [a,b,c,x,y,z] in ( foldr (flip f) z xs = foldl f z (reverse xs) )
01:00:40 <lambdabot>  Parse error at "=" (column 49)
01:00:42 <faxathisia> > let xs = [a,b,c,x,y,z] in ( foldr (flip f) z xs , foldl f z (reverse xs) )
01:00:57 <lambdabot>  thread killed
01:01:13 <goltrpoat> i think you want an actual f in there :)  preferrably one that doesn't commute
01:01:24 <faxathisia> > let xs = [a,b,c,x,y,z] in ( foldr (flip f) z xs , foldl f z (reverse xs) ) :: (Expr,Expr)
01:01:25 <lambdabot>  (f (f (f (f (f (f z z) y) x) c) b) a,f (f (f (f (f (f z z) y) x) c) b) a)
01:03:40 <goltrpoat> sec, i had a good example somewhere.
01:03:51 <faxathisia> You can't really just derive programs from types like that
01:04:35 <goltrpoat> well, sure you can.  you can derive reasonable programs from non-recursive types just fine.
01:04:36 <faxathisia> I think you really have to write the code (using lambda terms or tactics..)
01:07:12 <goltrpoat> for recursive types, there are several issues.  one's the whole non-termination bit.  the other is that f :: [a] -> [b] types the same as f . g, where g :: [a] -> [a].
01:08:30 <goltrpoat> so you need a type system that lets you disambiguate those cases to some extent.
01:10:36 <goltrpoat> preferrably without writing the entire program in the type.
01:12:51 <wagle_home> ick:
01:12:55 <wagle_home> @djinni (a->b->a)->a->[b]->a
01:12:55 <lambdabot> f _ a _ = a
01:13:05 <goltrpoat> well, djinn doesn't know what [b] is
01:13:06 <Jomyoot> Is there a guide to writing restful web app in Haskell?
01:13:18 <goltrpoat> your first argument can't be applied to anything, since it doesn't have a b
01:13:26 <goltrpoat> so the only way to get the consequent is from the second argument
01:13:41 <faxathisia> :t foldr
01:13:46 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
01:14:04 <faxathisia> :t foldl
01:14:05 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
01:15:28 <goltrpoat> fax:  you realize when i'm saying "type system," i mean something on top of F_omega, right
01:15:44 <faxathisia> You can very easily sythesize the fold (foldr) for any given algebraic type
01:15:44 <wagle_home> yeah, but it doesnt know what a is either, but that doesnt stop it
01:15:52 <goltrpoat> oh, fold was just a random example
01:15:53 <faxathisia> It's only 10 lines of code to do that
01:16:16 <faxathisia> I'm not sure if foldl is similar, does there exist a left fold for any datatype?
01:16:19 <goltrpoat> wagle:  no, it knows what a is.
01:16:25 <faxathisia> @src reverse
01:16:25 <lambdabot> reverse = foldl (flip (:)) []
01:16:30 <wagle_home> inventing the concept of an accumulator seems kinda big
01:17:49 <smg> good morning all
01:18:10 <wagle_home> 'morning
01:18:13 <sphynx> good morning
01:18:28 <faxathisia> goltrpoat: I don't know what you mean by on top and haskell is fairly different to F_omega
01:19:23 <faxathisia> isn't haskell a slightly restricted F2 with some extensions (typeclasses..)
01:19:26 <faxathisia> ?
01:19:51 <dolio> > let foldl f z l = foldr (\x g y -> g (f x y)) id l z in foldl (flip (:)) [] [1..10]
01:19:54 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
01:19:54 <lambdabot>       Expected...
01:20:26 <wagle_home> whats F_omega and F2 (i sorta know system F, but thats about subtyping, i think)
01:20:38 <goltrpoat> fax:  "on top" means "extended with" and "F_omega" means that there's no particular difference between F_n and F_omega for this application
01:21:12 <dolio> > let foldl f z l = foldr (\x g y -> g (f x y)) id l z in foldl (:) [] [1..10]
01:21:13 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
01:21:44 <goltrpoat> :t foldl (:)
01:21:45 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
01:21:45 <lambdabot>       Expected type: a -> [a] -> a
01:21:45 <lambdabot>       Inferred type: a -> [a] -> [a]
01:22:10 <faxathisia> :t foldl (flip (:))
01:22:11 <lambdabot> forall b. [b] -> [b] -> [b]
01:23:42 <faxathisia> goltrpoat: Are you going to use dependent types?
01:26:39 <goltrpoat> fax:  linear types seem to map more naturally to the problem, but i'm really not sure what i'm doing yet.
01:27:07 <Jomyoot> Is there a guide on writting a Restful server with Haskell?
01:27:38 <goltrpoat> i wrote a quick proof of concept for simple types, one's the straightforward backward chaining formulation, the other is the potentially non-terminating forward chaining formulation that makes things a lot nicer on paper
01:28:00 <goltrpoat> that was two weeks ago, i think i've mostly been reading since then.
01:29:11 <goltrpoat> i can derive const and ap and (.) like a champ though.
01:29:30 <Cale> @kind StateT
01:29:31 <lambdabot> * -> (* -> *) -> * -> *
01:29:32 <faxathisia> yeah it's quite simple for simple types :P
01:30:09 <faxathisia> should be ok for a substructural system .. I've not tried that personally though
01:31:23 <Cale> Haskell is at least F_omega, since you can have arbitrarily nested kinds.
01:32:13 <faxathisia> wouldn't that only mean haskells type system is F_omega?
01:33:08 <Cale> Well, really it's a constrained version of that, since there's no explicit type lambdas.
01:33:29 <Cale> But we have data declarations which do a similar task.
01:34:43 <smg> hello Cale
01:34:50 <Cale> hello
01:35:08 <smg> ah damn StateT is a Monad Transformer, i skipped that chapter :|
01:35:35 <wagle_home> .. hence the T
01:35:53 <smg> yeah..
01:36:40 <faxathisia> smg, There is a really good paper about Monad Transformers http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
01:36:41 <lambdabot> Title: Monad Transformers Step by Step
01:37:00 <smg> faxathisia: ah ty, i will read it
01:40:43 <goltrpoat> fax:  anyway, that was a sort of a round-about way of saying that i need to read up on CIC, since the big problem (not the solution ambiguity) basically revolves around controlling structural recursion around destructuring binds
01:41:29 <goltrpoat> induction rather.
01:42:01 <faxathisia> I can evision it being rather simple
01:42:11 <faxathisia> I'll make an example
01:44:18 <siti> parsec3 ftw :D
01:46:25 <smg> siti: what's new in it?
01:46:30 <goltrpoat> fax:  if you work through the first few examples that spring to mind, things start to blow up in very cool ways.
01:46:53 <scook0> @hoogle unsafePerformIO
01:46:55 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
01:46:55 <lambdabot> System.IO.Unsafe.unsafePerformIO :: IO a -> a
01:47:11 <siti> smg: decent documentation, bytestring support (I don't know how it works), monadic transforming? probably more
01:47:45 <smg> is monadic transforming really essential?
01:47:50 <faxathisia> goltrpoat, I'd try to do it this way http://rafb.net/p/B5IQna82.txt and see if it's possible to write any useful programs like that
01:48:30 <faxathisia> goltrpoat, with just simple types + substructal things like linearity, I think it would still be decideable but yeah, it explodes a bit so possible it would be useful as an interactive process
01:49:31 <siti> smg: to hurt your head it is ;)
01:49:36 <smg> haha :D
01:50:17 <faxathisia> without monad transformers you would have to .. implement monad transformers
01:50:32 <faxathisia> oh you mean in parsec? I don't know about that
01:51:26 <goltrpoat> fax:  well, right there you have a problem, right.  f::[a]->a is partial, so ideally we'd generate something like f xs = case xs of [] -> error "broken"; (y:ys) -> y.  that's fine.
01:51:49 <faxathisia> f should be total and always terminate
01:52:03 <faxathisia> ?djinn a -> b
01:52:03 <lambdabot> -- f cannot be realized.
01:52:12 <faxathisia> otherwise it should give up like this
01:52:46 <goltrpoat> fax:  sure, we can make f total (we can't do anything about termination)
01:52:58 <goltrpoat> fax:  but then try to reify something like map :: (a->b) -> [a] -> [b]
01:53:00 <faxathisia> you can ensure termination
01:53:03 <oerjan> smg: let's say you want to parse an interactive interpreter, that the end of each command depends on parsing, and that you want the rest of input to be available as a handle afterward.  then you are going to want a monad transforming parsec.
01:53:20 <goltrpoat> fax:  how are you going to ensure termination on map?
01:53:34 <oerjan> at least that is the case i bumped into
01:53:39 <faxathisia> well, this is in the context of inductive types
01:53:46 <goltrpoat> which is the whole point :)
01:53:51 <faxathisia> it's a coincidence these functions are useful on coinductives
01:54:07 <smg> oerjan: ah okay
01:54:17 <goltrpoat> coinductives?
01:54:32 <goltrpoat> you can write map as foldr
01:54:40 <faxathisia> map f (l = [1,2,3,4]) -- terminates, l is inductive
01:54:50 <faxathisia> map f (l = fix (1:)) -- terminates, l is coinductive
01:55:11 <faxathisia> isn't that the right meaning of the terms?
01:55:15 <goltrpoat> but map has to be reified somehow, right.  you can't do that in the language we've been discussing so far, it has no recursion facilities.
01:55:23 <goltrpoat> once you add those, you start losing those nice properties.
01:57:46 <goltrpoat> surely if we can express fold/build, then we can't tell that an arbitrary function terminates.
01:59:10 <faxathisia> goltrpoat: http://rafb.net/p/Q4TyDf52.txt
02:02:01 <goltrpoat> not following.. why is f x : ?0 the only choice?
02:02:11 <faxathisia> goltrpoat: If you only give structurally recursive options (or some given valid from the current context) then it's going to terminate on any finite data
02:02:30 <goltrpoat> the function will.  the number of solutions won't
02:02:38 <goltrpoat> (you don't even need inductive types for that)
02:02:48 <goltrpoat> the trouble with inductive types is that you can't order solutions by usefulness anymore.
02:02:52 <faxathisia> goltrpoat: you'd start with (:) ?0 ?1, the aim is to prove ?0 :: b in the context [x :: a, f :: a -> b, ...]
02:03:14 <faxathisia> goltrpoat: no but a user could choose which option to go with
02:04:00 <faxathisia> goltrpoat: then one wants to find some ?1 :: [b], but there is multiple solutions so you query the user
02:04:18 <goltrpoat> sure, but say i ask for (a->a)->[a]->[a].  solutions are:  1. f g xs = f g [] 2. f g xs = f g (f g []). 3. f g xs = f g (f g (f g [])).
02:04:30 <yitz> does anyone remember the correct cabal incantations for when you have multiple versions of ghc installed?
02:04:59 <goltrpoat> since there's no confluent algorithm for this, we can't pick an execution order that will terminate with anything useful at any point.
02:05:08 <faxathisia> goltrpoat: Exactly
02:05:20 <faxathisia> goltrpoat: That's why I'm saying that it should be an interactive process
02:05:55 <goltrpoat> oh i'm not arguing with that :)  i think you're minimizing the complexity of the issue a bit though.
02:06:39 <oerjan> you could do a breadth-first search.  in theory.
02:06:52 * faxathisia recommends depth first :P
02:07:00 * faxathisia (is a Prolog programmer)
02:07:12 <goltrpoat> depth first actually makes a huge deal of sense here, oddly enough.
02:07:20 <goltrpoat> since you can merge lazy lists.
02:07:24 <oerjan> yes, but depth-first doesn't give all solutions if there are infinite branches
02:07:34 <goltrpoat> of.. large.. sizes.
02:07:40 <faxathisia> I don't see that being a problem oerjan
02:07:51 <faxathisia> Is there any function you couldn't derive because of that?
02:08:05 <oerjan> faxathisia: "we can't pick  an execution order that will terminate with anything useful at any point."
02:08:09 <goltrpoat> i thought that was going to be a 'cut' joke.
02:08:29 <oerjan> but breadth-first allows to do all cases.  in theory.
02:08:33 <faxathisia> oerjan, ah, in that case, backtracking should be an option
02:08:50 <goltrpoat> "i don't see that being a problem,!"
02:08:50 <oerjan> depth-first is backtracking too
02:09:07 <faxathisia> exactly
02:09:23 <oerjan> and it does not give all cases if there are infinite branches
02:09:43 * oerjan thought he was making a trivial point.
02:10:45 <faxathisia> I think I'm misunderstanding someothing
02:11:15 <oerjan> your algorithm makes choices, right?  which gives you a tree, which may be infinite.
02:11:33 <oerjan> so to go through all cases you must traverse that tree.
02:11:34 <faxathisia> at every choice point, the user is asked which direction to go though
02:11:37 <goltrpoat> well, a tree would be fine
02:11:48 <goltrpoat> it's an arbitrary digraph though
02:11:55 <faxathisia> so you could reach any node which is at finite depth
02:12:42 <goltrpoat> cycles in the graph are the non-terminating programs
02:12:43 <oerjan> faxathisia: i wasn't thinking about the interactive option.  but there was a claim that you _couldn't_ get all cases automatically.  but you can with breadth-first search.
02:12:54 <faxathisia> oh ok
02:13:00 <faxathisia> yes
02:13:06 <goltrpoat> well.. the cycles and the open chains.  strictly speaking, you want the whole thing to be a chain-complete poset.
02:14:57 <goltrpoat> (i.e., not a tree even if every possible program terminates)
02:15:38 <oerjan> goltrpoat: for the purposes of the path of choices the algorithm takes, it's a tree.
02:16:08 <oerjan> a trie, even
02:17:12 <goltrpoat> it's not a tree.
02:17:25 <oerjan> depends what you mean by "it"
02:17:31 <goltrpoat> []::forall a. [a].
02:17:52 <goltrpoat> without recursive types:
02:17:55 <goltrpoat> Nothing::forall a. Just a.
02:18:06 <goltrpoat> very much not a tree.
02:18:34 <oerjan> whatever
02:18:55 <faxathisia> looks like a tree..
02:19:51 <goltrpoat> as you're searching through the witnesses for a particular type, every node has a link to a designated node whenever we're talking about a type that looks like a pointed set
02:20:10 <goltrpoat> so you have leaves with multiple parents.
02:20:39 <goltrpoat> that's why fix breaks things.
02:21:15 <faxathisia> can you show an example of that?
02:21:23 <smg> ah okay arrows are essential :)
02:21:34 <goltrpoat> with fix or without?
02:21:42 <faxathisia> without would be better
02:21:52 <smg> (***) does this really compute stuff "parallel"?
02:21:56 <smg> or only pseudoparalell?
02:21:58 <goltrpoat> my (a->a)->[a]->[a] example works
02:22:59 <goltrpoat> replace [] with any type constructor where the type has an element that doesn't require a witness of a, though
02:24:01 <oerjan> smg: depends on the arrow?
02:24:19 <dcoutts> Saizan: ah yes, good poing
02:24:34 <smg> oerjan: what does this mean?
02:24:38 <smg> the arrow must be a thread?
02:24:50 <quicksilver> smg: (***) says nothing at all about evaluation order.
02:24:57 <oerjan> > ((+1) *** (*2)) (1,3) -- not much really parallel here, in the -> arrow
02:24:57 <quicksilver> and nothing to do with threads.
02:25:01 <lambdabot>  (2,6)
02:25:07 <quicksilver> evaluation is on-demand
02:25:10 <quicksilver> as always in haskell.
02:26:31 <smg> One of the selling points of arrows is that you can use them to express parallel computation. The (***) robot is just the right tool for the job.
02:27:52 <yitz> dcoutss: when I have more than one ghc installed, how do I tell cabal which ghc-pkg to use when registering?
02:29:21 <yitz> oops, dcoutts, sorry.
02:29:47 <quicksilver> smg: it may express something of a parallel nature, but it doesn't actually evaluate anything in parallel :)
02:29:58 <dcoutts> yitz: see cabal configure --help
02:30:12 <goltrpoat> fax:  there are basically two ways to not terminate here, and one is bad, and the other is not.  if i say f :: Just a -> Just a, and the solver goes off looping over f Nothing due to a particular evaluation strategy, then we're certainly not traversing a tree of any sort.  we're just revisiting the @ f Nothing node over and over.
02:30:35 <smg> quicksilver: haha okay
02:30:50 <faxathisia> goltrpoat: That's in the case that the solver is fully automatic?
02:31:10 <goltrpoat> fax:  that's the case of it trying to return the very first result under a particular evaluation strategy.
02:31:12 <dcoutts> yitz: it's generally only necessary to specify --with-compiler=/path/to/ghc as cabal can usually figure out where ghc-pkg lives based on that
02:31:22 <yitz> saw it - couldn't tell from that.
02:31:23 <faxathisia> I don't understand
02:32:28 <yitz> ah. that's not obvious. I ran /path/to/runghc Setup.hs configure. It used the right compiler, but then the wrong ghc-pkg.
02:33:22 <dcoutts> yitz: oh that's interesting, I thought our heuristics were pretty good
02:33:25 <oerjan> goltrpoat: to try and clarify - the traversal of the tree i mean _is_ the evaluation strategy
02:33:36 <goltrpoat> but it's not a tree! :)
02:33:46 <dcoutts> yitz: can you tell me more, perhaps our heuristics could be improved
02:33:53 <goltrpoat> here's an example
02:33:55 <faxathisia> I think it is a tree
02:34:00 <faxathisia> sorry .. but that's how I see it
02:34:03 <oerjan> goltrpoat: if there is an algorithm, which makes choices, then those choices form a tree
02:34:09 <dcoutts> yitz: where was ghc and where was ghc-pkg, and which one did cabal find?
02:34:11 <yitz> Doesn't sound like a problem with the heuristics, just the help.
02:34:34 <dcoutts> yitz: what's wrong with the help?
02:35:05 <dcoutts> yitz: btw, did it detect that the version of ghc-pkg was wrong? we do have a configure check in now to make sure their versions match
02:35:14 <yitz> I have /opt/local/bin/ghc-6.8.2 (MacPorts build) and /usr/local/bin/ghc-6.6.1 (current binary release for Tiger).
02:35:24 <yitz> No, it didn't notice.
02:35:29 <quicksilver> smg: given that (***) is a method, you could override to do something genuinely parallel in an IO arrow, for example.
02:35:40 <goltrpoat> f :: Just a -> Just a, say.  let's say we start with this context:  {f:Just a->Just a, x:Just a}.  we have general recursion all of the sudden, but bear with me.  the sane traversal will choose x and say f x = x.  the wild and woolly traversal will say f ?.  the only thing that matches the ? is the x.
02:35:59 <smg> quicksilver: ah okay
02:36:11 <smg> so arrows are nothing special only functions
02:36:30 <quicksilver> well.
02:36:31 <goltrpoat> the expression itself is just growing in the general direction of f^inf(x).  the solver itself though, is basically looping over the context.
02:36:33 <quicksilver> they're not functions.
02:36:41 <faxathisia> goltrpoat: I understand
02:36:44 <quicksilver> they're an abstraction of functions, in some way
02:36:53 <smg> instance Arrow (->) where <--
02:36:53 <quicksilver> functions are arrows but not all arrows are functions.
02:37:05 <dcoutts> yitz: so where is the corresponding ghc-pkg? /opt/local/bin/ghc-pkg-6.8.2 and /usr/local/bin/ghc-pkg-6.6.1 ?
02:37:15 <yitz> yep
02:37:17 <smg> Quaver: ok
02:37:21 <smg> quicksilver: ok
02:38:01 <dcoutts> yitz: hmm, the heuristics should have found that if you specified --with-compiler=ghc-6.8.2 or --with-compiler=/opt/local/bin/ghc-pkg-6.8.2
02:39:00 <dcoutts> yitz: what version of Cabal were you using?
02:39:17 <dcoutts> the version that comes with ghc 6.8.2 or 6.6.x ?
02:39:40 <dcoutts> the one that comes with 6.8.2 does do the ghc/ghc-pkg version consistency check
02:40:50 <yitz> OK, that's fine then. Perhaps add to the help message: "give the path to a particular compiler" something about ghc-pkg also? Then I would have known that I have to use it.
02:42:17 <yitz> Dunno what version of cabal, I don't remember. How can I check?
02:43:00 <yitz> cabal-setup --version => cabal-setup: No command given (try --help)
02:43:41 <yitz> cabal-setup --version => cabal-setup:  Unrecognised command: version  (try --help)
02:46:06 <yitz> Also, we should add a few words to the bottom of the wiki page How_to_install_a_Cabal_package
02:46:53 <yitz> I would have seen that and known that I have to use "with-compiler".
02:48:53 <yondalf> @hoogle Char -> Word8
02:48:54 <lambdabot> Data.ByteString.Internal.c2w :: Char -> Word8
02:50:12 <dcoutts> yitz: oh you're using cabal-setup, so you did get the error about a version mismatch or not? I'm confused
02:50:36 <dcoutts> yitz: btw, you may like to upgrade to cabal-install and leave cabal-setup it's deprecated.
02:51:33 <yitz> Tried that at some point but couldn't satisfy all the dependencies. Maybe I could swing it now with 6.8.2.
02:52:00 <yitz> That's something else that should be mentioned on the wiki page then.
02:52:26 <yitz> No, I didn't get any version mismatch error.
02:53:15 <dcoutts> yitz: cabal-install isn't officially released, you have to use the darcs version, which is why we do not yet recommend it to the great unwashed masses, but we do recommend it to all #haskell users
02:53:23 <yitz> It just registered it to the other compiler.
02:53:24 <dcoutts> so long as they promise to report bugs :-)
02:54:01 <dcoutts> yitz: it sounds like you must have been using the Cabal from ghc-6.6.1
02:54:09 <yitz> make sense
02:54:16 <yitz> makes sense
02:54:25 <dcoutts> yitz: it's hard to tell what version of Cabal cabal-setup was using, as you noted it had no --version flag :-)
02:54:33 <dcoutts> the new cabal command line prog does of course
02:54:47 <dcoutts> $ ~/bin/cabal --version
02:54:47 <dcoutts> cabal-install version 0.4.4
02:54:47 <dcoutts> using version 1.3.7 of the Cabal library
02:55:52 <yitz> OK. Now that we have 6.8 in MacPorts, I took one step towards the modern age. As soon  as Manuel finishes the Tiger installer, I'll be there.
02:56:42 <yitz> (Or if I am forced to shell out $129 for Leopard, which actually may also happen soon.)
02:56:54 <dcoutts> yitz: Cabal and cabal-install work with ghc-6.6.x too
02:58:28 <yitz> I don't remember what went wrong when I tried it some time ago. Sorry about not reporting - I thought no one would be interested because of my old GHC.
02:59:04 <dcoutts> Cabal is expected to work with ghc 6.4+
02:59:23 <goltrpoat> yitz:  ive had a ton of problems with new packages while running 6.6.1.  more or less figured the same thing as you did.
03:02:46 <goltrpoat> the result was a) i know more about old cabal syntax than i was ever intending to learn, b) i'm running 6.8.2 now
03:04:42 <goltrpoat> i fully plan to apply this experience to my world domination plans.
03:07:10 <yitz> goltrpoat: right. I've been stuck in 6.6.1 because until today the only way to upgrade on my platform would have been a manual build. Today I built using MacPorts, but I don't want to rely on that because I don't want to have to recompile ghc all the time. But Manuel is almost done with the binary installer, so I am almost out of the woods. Now that I have a copy of 6.8.2, I can finally start working on upgrading my programs to work with it.
03:07:48 <yitz> dcoutts: with cabal-install, does one use the --with-compiler flag?
03:07:55 <goltrpoat> -nod-
03:09:05 <wli> inv :: Matrix Double -> Matrix Double -- does anyone else see a problem with this?
03:09:16 <goltrpoat> it's partial?
03:09:32 <yitz> wli: round-off error!
03:09:42 <goltrpoat> pfft.
03:09:52 <dcoutts> yitz: if the ghc on your path is not the one you want, then yes.
03:10:03 <dcoutts> yitz: by default it just looks for "ghc" on your path.
03:10:10 <yitz> and ghc-pkg
03:11:27 <dcoutts> yitz: if ghc-pkg is not explicitly specified then it guesses ghc-pkg's name and location based on the name and location of ghc
03:11:35 <goltrpoat> wli:  inv :: (Matrix m, RealFloat f) => m f -> Maybe (m f) sounds a bit better
03:12:29 <dcoutts> yitz: eg if you say cabal install foo --with-compiler=ghc-6.8.2 and cabal finds ghc-6.8.2 in /usr/local/bin/ghc-6.8.2 then it'll try looking for /usr/local/bin/ghc-pkg-6.8.2
03:12:34 <wli> goltrpoat: The lack of polymorphism sucks in various respects too, yes.
03:15:04 <yitz> goltrpoat: it's not obvious when to return Nothing. You have to watch for fp underflow, etc. Even without underflow, sometimes you'll get what looks like a result but it's actually meaningless spaghetti. fp matrix inversion is notoriously subtle.
03:15:44 <goltrpoat> it starts to depend on the application at this point, but you're right.
03:15:48 <wli> yitz: Interesting. I have direct uses for the inverse of a Vandermonde matrix, so I'm all ears to issues with floating point matrix inversion.
03:15:57 <yitz> dcoutts: that's nice.
03:16:14 <wli> yitz: More specifically a generalized Vandermonde matrix (pertinent to Hermite interpolation).
03:16:49 <goltrpoat> don't vandermonde matrices have a nice special inverse
03:17:11 <wli> goltrpoat: I thought so but I can't remember what it is.
03:17:41 <wli> s/generalized/confluent/
03:17:56 <yitz> goltrpoat, wli: vandermondes may be ok, I seem to remember inverting some of those way back when without incident...
03:19:28 <wli> My plot was to compute the Moore-Penrose pseudoinverse via the SVD anyway.
03:19:48 <goltrpoat> then why do you need the inverse
03:19:51 <goltrpoat> and.. wait
03:20:02 <goltrpoat> if you're doing moore-penrose, then why do you have an inverse to begin with
03:20:05 <wli> (Which should coincide with the actual inverse apart from differences in numerical accuracy when the matrix is nonsingular.)
03:20:42 <goltrpoat> oh so it's of full rank, you just want the least squares solution?
03:21:09 <wli> goltrpoat: Floating point error may render yield a singular approximation to a nonsingular true matrix, and the SVD is otherwise less likely to go numerically haywire.
03:21:12 <goltrpoat> SVD is a huge overkill for this
03:22:17 <goltrpoat> or maybe i'm missing something.
03:22:38 <goltrpoat> what's wrong with QR?  you'll get a solution in the least-squares sense if it's singular
03:22:39 <wli> goltrpoat: The canned subroutine makes it easy to program, so I'd rather be safe about it.
03:22:45 <goltrpoat> ah
03:23:06 <yitz> wli: look at this abstract: http://eprints.iisc.ernet.in/archive/00008723/
03:23:07 <lambdabot> Title: The Accurate Inversion of Vandermonde MatricesePrints@IISc - Open Access Archive ...
03:23:17 <wli> yitz: Thanks.
03:23:55 <goltrpoat> i just remember doing this insane thing with a numerical solver, tossing a QMR solver at it, just because i happened to be reading about it at the time
03:24:30 <goltrpoat> in context, it very much like seeing a fly on your window and calling in an air raid
03:24:34 <goltrpoat> it=it was
03:26:00 <wli> yitz: I'm not sure if the Parker algorithm does confluent Vandermonde matrices or not.
03:26:10 <goltrpoat> it worked, remarkably well, but then it turned out that 50 iterations of SSOR did the same thing but 500 times faster.
03:29:09 <wli> I need the higher derivatives of Hermite interpolation basis functions evaluated at the knots.
03:29:18 <wli> That's where this matrix inverse comes in.
03:29:20 <yitz> wli: I don't know. Google turns up a lot of recent stuff - this seems to be a hot topic.
03:30:01 <wli> yitz: I'm not likely to be able to do anything with recently-devised algorithms. I'll not likely be able to program them effectively.
03:30:17 <mkdez> hi, any any good editor for indenting haskell code? I've tryed emacs with haskell-mode and vim with some scripts but I keep having indent errors all the time. I always finish indenting the code by hand using spaces to compile it :\
03:31:54 <goltrpoat> wli:  i remember you talking about that.
03:32:01 <wli> yitz/goltrpoat: The problem sizes here are going to be ridiculously small in comparison to the asymptotic regimes here. The SVD, while it may be slower, is not likely to be substantially different for matrices of such a small size where te rest of everything is useful.
03:32:46 <goltrpoat> wli:  SVD is ridiculously robust, so it's great for proofs of concept.
03:33:02 <goltrpoat> my experience, anyway.
03:33:12 <wli> Yeah, that's what I want from the SVD.
03:34:57 <wli> goltrpoat: My progress has been preposterously slow, but at least I'm persistent.
03:38:39 <goltrpoat> can you remind me what we're talking about?  hermite basis functions differentiate rather nicely by definition
03:41:42 <goltrpoat> what i mean by that is that we tend to differentiate that type of thing analytically in CG
03:42:32 <wli> goltrpoat: Derivatives higher than those specified as the product of Kronecker deltas on knots and order of the derivative.
03:43:42 <goltrpoat> but those are finite order polynomials, right.
03:43:43 <wli> goltrpoat: If there's an analytic method of finding those I'm all ears.
03:44:03 <goltrpoat> degree.
03:44:09 <skorpan> if i have data A = A { b :: B, c :: C } and data B = B { d :: D, e :: E } and i have a function taking an A, how do i return the same A, but with an updated "d"?
03:44:20 <wli> goltrpoat: Yeah. The inverse is basically smoking out the Taylor expansions around a knot of my choosing.
03:44:21 <skorpan> currently i'm doing this with a couple of let .. in
03:44:34 <goltrpoat> wli:  but.. your taylor expansion is finite
03:45:13 <wli> goltrpoat: They'd be some real analytic function vs. polynomials if that were not the case.
03:45:23 <goltrpoat> right
03:47:01 <goltrpoat> so we have a product of some set of finite series, surely computing that product directly is faster and more accurate?
03:47:43 <wvd> hello
03:47:52 <goltrpoat> since the big terms go up front and all.
03:48:26 <wvd> I'm looking for a tutorial on the network library, specifically for writing a server as opposed to the client demonstrated in the roll your own irc-bot tutorial
03:48:38 <wli> goltrpoat: Hermite interpolation bases aren't products like Lagrange interpolation bases.
03:49:33 <wli> goltrpoat: They're weighted sums of such products whose weights are some derivative of some product evaluated at the associated knot.
03:50:29 <wli> goltrpoat: I further more suspect that using the analytic affair wouldn't be very good numerically.
03:51:13 <goltrpoat> actually, that's a good point.
03:51:20 <wvd> any links to such a tutorial that anyone knows about?
03:52:19 <scook0> skorpan: out of the box, I don't think there's an easy way to do that
03:52:22 <scook0> (which is annoying)
03:52:35 <guenni> anybody know of a haskell intro/tutorial that uses functions only instead of using data constructs?
03:52:56 <guenni> ie doing it all with functions?
03:53:08 <scook0> though there are various workarounds, such as "functional references" and "lenses"
03:54:34 <goltrpoat> i know the "analytic affair" can fail miserably in some situations, but my memory of hermite polynomials is all nice and fuzzy, so that's why i went that route.  you start adding random things at the nodes into it and things get less warm and fuzzy.
03:54:47 <byorgey> skorpan: yes, you probably want to read up on functional references.
03:54:52 <byorgey> skorpan: http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
03:54:54 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
03:55:04 <wli> Painkillers sre making me sick. Sorry.
03:55:21 <goltrpoat> you alright?
03:55:27 <wli> yeah
03:55:31 <wli> worst case I'll puke them up
03:55:46 <faxathisia> best wishes wli
03:56:05 <therp> wli: what kind of pain killers? ASS, paracetamol, ibuprofen?
03:56:18 <byorgey> skorpan: also check out the code at http://code.haskell.org/category, complete with Template Haskell deriving for functional references for record fields
03:56:19 <lambdabot> Title: Index of /category
03:56:27 <wli> oxycodone and tramadol
03:56:48 <byorgey> guenni: you mean church-encoding?
03:56:54 <goltrpoat> is oxycodone like oxycontin meets hydrocodone
03:57:09 <wvd> In my socket code, I'm doing: s <- listenOn port
03:57:13 <byorgey> hi wvd, I don't know of any tutorials like that.
03:57:28 <guenni> byorgey: yes, I suppose that's what I mean :)
03:57:31 <wvd> how do I now know when to accept a connection?
03:57:44 <therp> byorgey: that's nice (@category)
03:58:01 <byorgey> therp: yes, it is rather nice =)
03:58:28 <goltrpoat> wvd:  sec, i vaguely remember writing a chat server
03:58:43 <guenni> byorgey: I mean I do realize that the data notation does not actually introduce an additional paradigma but it just feels like as if it did
03:58:51 <byorgey> guenni: well, you could read about that in, say, TaPL
03:59:09 <guenni> byorgey: TaPL?
03:59:20 <byorgey> guenni: but I don't think there are any tutorials taking that approach, it seems sort of a silly way to introduce Haskell.
03:59:29 <byorgey> guenni: Types and Programming Languages, by Benjamin Pierce
03:59:33 <therp> wli: hmm, I have no experience with opioid based painkillers. for me, paracetamol works quite ok when I have problems with my stomach
03:59:55 <guenni> byorgey: thx, that may be a very good tip
04:00:37 <hpaste>  goltrpoat pasted "simple server" at http://hpaste.org/6157
04:00:47 <goltrpoat> wvd:  here
04:00:54 <wvd> cool
04:01:07 <wvd> thank you
04:01:41 <goltrpoat> wvd:  it'll start a session and listen on localhost:8001.  telnet to it and it'll say things here and there.
04:01:50 <smg> is CPS considered to be good programming style in haskell?
04:02:01 <wli> I'm resistant to painkillers of most or all kinds, so they have to break out harder stuff for me.
04:03:59 <hpaste>  goltrpoat pasted "simple server.. #2" at http://hpaste.org/6158
04:04:09 <goltrpoat> wvd:  sorry, forgot the imports.
04:04:43 <faxathisia> smg: LOL
04:05:19 <goltrpoat> fax:  hey, there are perfectly legitimate uses for CPS in haskell
04:05:20 <smg> faxathisia: mh?
04:05:25 <matthew-_> "you know you're in trouble when..." #8456 ...it finally compiles and you have no idea whether it actually will do what you want...
04:07:32 <byorgey> xerox++  hurrah for Parsec3!
04:07:43 <goltrpoat> matthew:  that describes the last 20 years of my life.
04:08:05 <smg> faxathisia: can you explain what makes you so excited about my question? ;-)
04:08:05 <goltrpoat> they might want to narrow it down a bit.
04:08:22 <faxathisia> smg: I just found it very amusing..
04:08:38 <faxathisia> smg: CPS is irrelevant to whether or not your code is good style btw
04:09:18 <matthew-_> goltrpoat: I see! You have led an exciting life ;)
04:09:42 <smg> faxathisia: i didn't know if CPS is relevant
04:10:39 <byorgey> smg: CPS could be considered good style, I think, but I think there are very few times when it's actually worth it
04:11:02 <byorgey> smg: and when it is, you can just use the ContT monad transformer, I think
04:11:36 <dolio> Some things can be clearer with explicit continuation passing than they are with implicit passing like Cont(T).
04:11:53 <goltrpoat> the only time it's worth it is when you're reading a felleisen paper
04:12:19 <smg> byorgey: hehe yeah they used ContT monad transformer in that example
04:12:47 <goltrpoat> at which point you have to write it in cps, because, goshdarnit, otherwise you really have no idea how to proceed.
04:12:54 <matthew-_> why do case statements not inherit the surrounding context?
04:13:20 * byorgey just realized he used 'I think' three times in the previous two lines... I think =P
04:17:01 <goltrpoat> byorgey:  i think everyone is waiting for the other shoe to drop, in a general cogito ergo sum type way.
04:17:23 <byorgey> goltrpoat: hehe
04:18:23 <dolio> "It's possible I'm wrong, but I believe it's a theorem that it's impossible to catch every bug at compile-time"
04:18:44 * faxathisia disagrees
04:19:06 <guenni> byorgey: excellent tip this book! thank you very much
04:19:16 <byorgey> guenni: you're welcome! =)
04:20:00 <byorgey> it kind of depends what you mean by 'bug', doesn't it?
04:21:09 <matthew-_> hmm. I literally no longer understand why ghc accepts this program. Quite how it works out how to satisfy these contexts is beyond me...
04:22:54 <yitz> dcoutts: http://haskell.org/haskellwiki/Talk:Cabal/How_to_install_a_Cabal_package
04:22:55 <lambdabot> http://tinyurl.com/37rwe4
04:24:10 <dcoutts> yitz: ah, now I know why it didn't complain about version mismatches, not only did cabal find the 'wrong' ghc-pkg, it also found a compatible 'wrong' ghc too.
04:24:28 <yitz> yes
04:24:32 <dcoutts> yitz: the haskell implementation used to run Setup.hs has no relation to what cabal will find on the path
04:24:40 <goltrpoat> the denotation of the word 'bug' typically depends on the program specification.  my program specification is that it's an interpreter for a turing complete language that always halts.
04:24:46 <yitz> I now realize that.
04:24:48 <dcoutts> runhugs Setup.hs would work to build a package using ghc
04:25:07 <dcoutts> (runhugs -98 probably)
04:25:34 <dcoutts> yitz: so sure, add that at the end
04:25:41 <goltrpoat> i'd also like some onion rings.
04:25:58 <yitz> ok
04:26:07 <dcoutts> yitz: if you're editing that page you could also fix the cabal-install link
04:26:13 <dcoutts> @where cabal-install
04:26:13 <lambdabot> http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
04:26:20 <yitz> ok
04:30:33 <yitz> dcoutts: someone already fixed the link
04:31:15 <dcoutts> yitz: oh, right, good :-)
04:36:12 <matthew-_> Q: So how can a module be 120 lines long and only contain 2 function? A: you just have 100 lines of type sigs and 20 lines of code...
04:40:19 <yitz> matthew-_: you obviously have never worked in a software Quality Assurance department.
04:41:41 <matthew-_> indeed not.
04:41:57 <matthew-_> I shall die happy (well, happier) if I never do
04:41:58 <Baughn> @src msum
04:41:58 <lambdabot> msum =  foldr mplus mzero
04:42:14 <faxathisia> nice implementation
04:44:40 <Baughn> @hoogle Monad m => m a -> (a -> Bool) -> [a]
04:44:41 <lambdabot> No matches, try a more general search
04:45:22 <faxathisia> filter
04:45:28 <faxathisia> :t filter
04:45:31 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
04:45:34 <faxathisia> :/
04:45:57 <Baughn> Ah. filterM.
04:46:02 <faxathisia> :t filterM
04:46:03 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
04:46:16 <faxathisia> @src filterM
04:46:16 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
04:46:20 <faxathisia> @src filter
04:46:21 <lambdabot> filter _ []     = []
04:46:21 <lambdabot> filter p (x:xs)
04:46:21 <lambdabot>     | p x       = x : filter p xs
04:46:21 <lambdabot>     | otherwise = filter p xs
04:46:28 <faxathisia> bah
04:46:35 <Baughn> ..almost
04:46:47 <faxathisia> is there a nice pointfree def of filter?
04:47:17 <Baughn> I'm looking for something that will repeat an action until its return value passes a particular test. Any ideas?
04:47:18 <faxathisia> @@ @pl @src filter
04:47:18 <lambdabot>  (line 1, column 1):
04:47:18 <lambdabot> unexpected end of input
04:47:18 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
04:47:28 <faxathisia> :t untilM
04:47:29 <lambdabot> Not in scope: `untilM'
04:47:35 <faxathisia> :t whileM
04:47:36 <lambdabot> Not in scope: `whileM'
04:47:48 <Baughn> ..you'd have thought
04:47:48 <faxathisia> I thought there was one of those that did it
04:47:59 <Baughn> I'm almost certain there is something that does it
04:48:02 <Baughn> I just can't find it
04:48:29 <Baughn> @hoogle while
04:48:29 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
04:48:29 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
04:48:29 <lambdabot> Data.List.takeWhile :: (a -> Bool) -> [a] -> [a]
04:49:28 <yitz> @pl \f -> catMaybes . map (\x -> guard (f x) >> return x)
04:49:28 <lambdabot> (catMaybes .) . map . (`ap` return) . (((>>) . guard) .)
04:52:29 <yaxu_> i remember seeing some beautiful visualisations of haskell functions, and i'm trying to find them again...  anyone know what i'm talking about?
04:54:33 <Baughn> @. pl undo do a <- foo; return (b:a)
04:54:33 <lambdabot> (b :) `fmap` foo
04:58:18 <Botje> @pl foo >>= return . (b:)
04:58:18 <lambdabot> (b :) `fmap` foo
04:58:25 <Botje> shouldn't that be liftM?
04:58:35 <Botje> :t return
04:58:39 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
04:58:40 <Botje> :t liftM
04:58:40 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
04:58:43 <Botje> :t fmap
04:58:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:58:45 <Baughn> Botje: fmap works wherever liftM does, so..
04:59:02 <Baughn> That is, there's a Functor instance for Monad
04:59:08 <Botje> i know
04:59:11 <Baughn> @src Monad fmap
04:59:11 <lambdabot> Source not found.
04:59:24 <Botje> but functors don't support do-notation, do they?
04:59:36 <Botje> @unpl (b:) `fmap` foo
04:59:37 <lambdabot> (fmap (\ a -> b : a) foo)
04:59:49 <Botje> @unpl (b:) `liftM` foo
04:59:49 <lambdabot> (liftM (\ a -> b : a) foo)
05:00:02 <Baughn> Nope. Still, why should it be liftM?
05:00:51 <Botje> because you feed in code that works on monads
05:00:56 <Botje> and get out code that works on functors
05:01:26 <Botje> @pl getLine >>= return . (b:)
05:01:26 <lambdabot> (b :) `fmap` getLine
05:01:32 * Baughn shrugs
05:01:39 <Botje> it just struck me as odd :)
05:01:40 <Toxaris> Baughn: are you sure that fmap works wherever liftM does? As I understand it, there is no connection between Functor and Monad in Haskell
05:01:43 <Botje> oh well, off to school
05:02:19 <Baughn> @instances Functor
05:02:21 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
05:02:37 * Baughn ponders
05:03:11 <Baughn> Maybe if I figured out where Functor is /defined/.. there's no functor module
05:03:36 <Toxaris> http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#Functor
05:03:37 <lambdabot> http://tinyurl.com/3dzxqb
05:04:28 <Baughn> Instances of both 'Monad' and 'Functor' should additionally satisfy the law:
05:04:28 <Baughn> > fmap f xs  ==  xs >>= return . f
05:04:30 <lambdabot>   Not in scope: `xs'
05:04:45 <yitz> @pl \f -> concat . takeWhile (not . null) . evalState (repeatM $ State (break f) >> State (span f))
05:04:46 <lambdabot> ((join . takeWhile (not . null)) .) . evalState . repeatM . ap ((>>) . State . break) (State . span)
05:04:56 <Baughn> So there isn't an actual instance for /every/ monad, but where there is, pl should work
05:05:08 <Baughn> That does imply that it assumes something not actually the case, though
05:05:10 <wli> Okay, I think the Phenergan as has kicked in. What's the word on the Hermite interpolation and/or matrix affairs?
05:05:28 <Toxaris> Baughn: sure, and there *should* be an instance for every monad, since it makes sense, but the type system isn't enforcing it
05:05:58 <Baughn> Toxaris: There is a "Monad m => Functor (WrappedMonad m)" thing, though
05:06:36 <wli> The Prelude class hierarchy is screwed up.
05:12:07 <DukeDave> Erm, have a situation where I have an 'm a' and '(a -> b)', how do I make a '(m a -> m b)'   ?
05:12:33 <DukeDave> Hoogle doesn't seem to know :(
05:12:56 <Toxaris> DukeDave: liftM or fmap or liftA or <$>
05:13:13 <Baughn> @ty liftM
05:13:14 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
05:13:18 <Toxaris> > succ <$> [1, 2, 5, 41]
05:13:19 <lambdabot>  [2,3,6,42]
05:13:58 <Baughn> @djinn Monad m => m a -> (a -> b) -> m b
05:13:58 <lambdabot> Cannot parse command
05:14:12 <Baughn> Bad djinn. No freeing.
05:14:51 <Gilly> is [..] core language or could i define my own [<>] ?
05:15:16 <Toxaris> DukeDave: but you don't need a (m a) to do so, just the (a -> b).
05:15:29 <Baughn> Gilly: Core.
05:15:30 <mux> [..] desugars to enumFrom or EnumFromTo or enumFromThenTo
05:15:52 <Toxaris> Gilly: stuff in brackets always means lists, but you can overload the meaning of enumerations [1,5..42] for your own datatypes
05:15:53 <mux> I mean [foo..bar]
05:15:59 <Gilly> ok, thanks
05:16:07 <mux> so if you have an Enum instance it just works
05:17:01 <Gilly> well :) if i wanted to construct, say, a geometric sequence [1..125] then it gets ugly because the default enumeration for numbers is in the way :)
05:17:07 <mux> > [1,3..7] == enumFromThenTo 1 3 7
05:17:08 <lambdabot>  True
05:18:17 <Baughn> @pl (\id -> if all isDigit id then getUserEntryForID id else getUserEntryForName id)
05:18:17 <lambdabot> ap (ap (if' . all isDigit) getUserEntryForID) getUserEntryForName
05:19:02 <Toxaris> Gilly: you could define a newtype Geometric a = Geometric a, an instance Num a => Num (Geometric a) and a custom instance Num a => Enum (Geometric a) to be able to write ([1..125] :: Geometric Int). but it probably is a bad idea to do so...
05:19:20 <Gilly> Toxaris: yea it probably is
05:19:30 <Gilly> :) well, nevermind, i was just curious
05:21:25 <DukeDave> Toxaris: Thanks!
05:21:38 <Toxaris> Gilly: for which geometric sequence should [1..125] stand?
05:22:00 <Gilly> Toxaris: heh, a good point.
05:22:08 <georgw> I want to try an algorithm with say 1000 different random permutations. Typically I would use for-loops in an imperative language. In Haskell, what's the right way? Passing a counter-variable to a recursive function and decrementing it on every recursion?
05:22:15 <Gilly> of course i'd go with [1,5..125] then
05:22:37 <faxathisia> georgw, define a list of 1000 permutations
05:22:42 <Toxaris> georgw: map the algorithm over a list of 1000 input data sets
05:23:02 <mux> georgw: you'd probably go with a forM/mapM on the list of random permutations
05:23:09 <georgw> I knew there was a better way. Makes sense... :-)
05:23:22 <mux> well if you do imperative stuff actually
05:24:34 <Toxaris> georgw: alternatively, if your algorithm to be tested produces it's own input (by calling randomIO or whatever), you can use replicateM to run it multiple times
05:25:55 <georgw> Toxaris: would it be more efficient to do that for 100.000 times, or can I just as well use one random call to generate 100.000 data points, and this will run memory-efficient due to lazy evaluation?
05:28:26 <Toxaris> georgw: if you use randomRs or randoms, it should work fine, I think. (but I'm not exactly sure...)
05:28:42 <georgw> Toxaris: thx, will try.
05:34:01 <Baughn> georgw: It'll work, but be aware that if you generate 50 random numbers and only use the middle 10, the first 20 will still be evaluated
05:34:47 <Baughn> (There's a random-number-generator-forking function that's meant to avoid that, but apparently it doesn't work too well)
05:35:45 <georgw> ok, that's fine. I'll use my random values efficiently.
05:37:45 <smg> -> associates to the right
05:37:46 <smg> ?
05:38:29 <quicksilver> correct.
05:41:56 <georgw> I have a long if-then-else if-then-else if-statement followed by a where indented to match with the first if, and I get a parse error. Any ideas?
05:42:13 <faxathisia> georgw: Use case instead
05:42:25 <faxathisia> (of if_then_else_)
05:42:52 <faxathisia> > case () of () | 1 == 1 -> 'a' | 1 == 2 -> 'b' | 1 == 3 -> 'c'
05:42:57 <lambdabot>  'a'
05:43:29 <quicksilver> georgw: you can't have a where on an if statement.
05:43:37 <georgw> oh, ok.
05:43:37 <quicksilver> georgw: wheres don't go on expressions.
05:43:42 <quicksilver> they go on declarations.
05:43:50 <quicksilver> the 'where' can go on the enclosing declaration
05:43:59 <quicksilver> (in which case it needs to be indented less than the first if, I imagine)
05:44:06 <matthew-_> case statements can have where's can't they?
05:44:15 <quicksilver> yes
05:44:26 <quicksilver> a case statement is for this purpose a bit like a declaration :)
05:44:32 <faxathisia> > case () of () | 1 == 1 -> x | 1 == 2 -> 'b' | 1 == 3 -> 'c' where x = 'a'
05:44:32 <lambdabot>  'a'
05:44:33 <quicksilver> at least, it uses declaration syntax.
05:44:33 <matthew-_> I see ;)
05:44:39 <quicksilver> guards + wheres.
05:44:44 <quicksilver> and pattern matches.
05:44:50 <wli> I usually do case () of _ | predA x y z -> valA | predB x y z -> valB ...
05:44:51 <faxathisia> case does everything :D
05:45:06 <faxathisia> wli: Why _ rather than ()?
05:47:22 <quicksilver> one fewer char to type?
05:48:28 <georgw> ohhh, with case it's so much more beautiful.
05:49:04 <matthew-_> case is pretty useful with existentials too
05:49:05 <wli> It emphasizes that the scrutinee is not in fact examined.
05:49:34 <faxathisia> matthew-_: Do you have an example?
05:50:12 <matthew-_> faxathisia: yep. But, to understand it, requires many many other lines of code
05:50:18 <Toxaris> > case undefined of _ -> 42
05:50:21 <lambdabot>  42
05:50:26 <Toxaris> > case undefined of () -> 42
05:50:27 <lambdabot>  Undefined
05:50:51 <matthew-_> faxathisia: I suspect there are examples in the ghc user guide
05:51:10 <georgw> Ok, it compiles. :-)
05:53:08 <vincenz> @src undefined
05:53:08 <lambdabot> undefined =  error "Prelude.undefined"
05:53:40 <zeno> existentials?
05:55:29 <quicksilver> @go existential haskell
05:55:31 <lambdabot> http://www.haskell.org/haskellwiki/Existential_type
05:55:31 <lambdabot> Title: Existential type - HaskellWiki
05:56:05 * Baughn really wishes there was some sort of proper exception hierarchy
06:03:49 <ketil> Any hackage admins around?
06:07:08 <georgw> ok, seems i messed something up in my code logic: *** Exception: Prelude.head: empty list
06:07:15 <georgw> Any easy way to find out where this occurs?
06:07:28 <georgw> (using ghci...)
06:08:00 <ketil> Replace 'head' with (\x -> case x of (y:ys) -> y)) - this will tell you the line number where the case fails.
06:08:34 <ketil> I tried to wrap this up as a library (at http://malde.org/~ketil/interlude), perhaps you'll find it useful.
06:08:46 <ketil> It's not so beautiful, though.
06:09:30 * ketil thinks the case is gratuitious - can't you use (\(x:_) -> x), he wonders?
06:09:43 <ketil> georgw, any of that help?
06:09:59 <georgw> ketil: just tried the case statement, and it works like a charm. :-)
06:10:21 <georgw> Just need to do some thinking now, why my list can be empty...
06:10:36 <smg> how would i make a function strict?
06:10:37 <smg> fix() ?
06:10:42 <Toxaris> > (\(x:_) -> x) []
06:10:57 <lambdabot>  thread killed
06:12:14 <Toxaris> smg: no, fix is something different
06:13:43 <quicksilver> smg: case is the basic haskell evaluator
06:14:09 <quicksilver> smg: most strictness come from use of case or pattern matching function definitions (which is the same thing)
06:14:19 <quicksilver> or of course, from calling other strict functions.
06:14:37 <quicksilver> f a b = a + b -- this is strict because (+) is strict, on Ints at least.
06:15:24 <quicksilver> ketil: lambda bindings are lazy, are they not?
06:15:33 <quicksilver> ketil: however, I think it might have the same effect.
06:15:53 <yitz> Toxaris: lambdabot seems to have been busy. Try again.
06:15:55 <georgw> Any clever debugging hints alike to stack traces? I have a function that always returns a nonempty list, but somehow I get an empty list out of it...
06:16:05 <quicksilver> ketil: yes, I think it does *** Exception: <interactive>:1:1-11: Non-exhaustive patterns in lambda
06:16:09 <Toxaris> > (\(x:_) -> x) []
06:16:10 <wli> \xs -> case xs of x : _ -> return x ; [] -> mzero
06:16:10 <lambdabot>   Non-exhaustive patterns in lambda
06:16:14 <quicksilver> ketil: (ie. it gives line numbers as desired)
06:18:23 <smg> quicksilver: i see
06:18:49 <ketil> I wish there was a way to "inline the errors" from these functions.  I generally use CPP, which is a mess.
06:19:24 <wli> I'd rather error handling be done using something useful, e.g. monads.
06:21:13 <quicksilver> wli: ketil is talking about programmer errors, not runtime exceptions.
06:21:21 <quicksilver> I.e. he's talking about things which really should never happen
06:21:32 <quicksilver> and the programmer wants as accurate as possible a description of where to fix.
06:21:40 <quicksilver> these shouldn't really be in error-handling monads
06:21:52 <quicksilver> that should be for "Expected" kinds of errors the program has to deal with.
06:22:01 <Shurique> how do I obtain a Fd for the functions in System.Posix.Terminal?
06:22:13 <quicksilver> @hoogle openFd
06:22:13 <lambdabot> No matches found
06:22:15 <quicksilver> hmm
06:23:08 <wli> Oh, what was that extension people want to use for nonempty lists in lieu of a nonempty list data type distinct from [ ]?
06:23:45 <quicksilver> Shurique: I can't remember. Something somewhere in system.posix I'm sure
06:23:52 <quicksilver> @hoogle Handle -> Fd
06:23:53 <lambdabot> No matches, try a more general search
06:23:59 <StarDuts> hello....
06:24:10 <Shurique> I'll keep looking then
06:24:12 <StarDuts> where i can Request Free Sgell
06:24:18 <StarDuts> where i can Request Free Shell ??
06:24:42 <georgw> Can I insert prints in functions for diagnostics?
06:24:45 <quicksilver> Shurique: Ah. http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-IO.html
06:24:46 <lambdabot> http://tinyurl.com/ypw9v7
06:24:54 <quicksilver> georgw: try Debug.Trace
06:25:02 <Shurique> oh, thanks
06:25:09 <StarDuts> hi..quicksilver,,where i can Request Free Shell ??
06:25:35 <quicksilver> StarDuts: I'm not really sure. I'm not aware of anyone giving out free shell accounts.
06:25:55 <dv\> StarDuts: try sdf.lonestar.org
06:26:13 <StarDuts> can for psyBNC ??
06:26:37 <hpaste>  ils pasted "troubles installing darcs" at http://hpaste.org/6159
06:26:56 <dv\> StarDuts: what brought you were anyway?
06:27:27 <ils> hello. I'm having troubles installing darcs. I'm using ghc-6.8.2 under gentoo. I get this error: http://hpaste.org/6159
06:27:36 <StarDuts> pleaseee give me Free shell for PsyBNC only :(
06:29:55 <quicksilver> StarDuts: this channel is for discussing the haskell programming language. Someone already pointed you towards one source of free shell accounts.
06:30:01 <quicksilver> I'm sure the google-tubes can find you others.
06:31:36 <wy> wagle_home: hey
06:31:52 <hpaste>  BoudewijnEctor pasted "Printing list of strings" at http://hpaste.org/6160
06:32:09 <BoudewijnEctor> Can someone please help me on debugging my function, which I just put on hpaste?
06:32:24 <BoudewijnEctor> I want to print a [String] by just printing each item (one at a time)
06:32:41 <BoudewijnEctor> but although I'm using a [String] Haskell seems to think I'm using a String
06:32:53 <Toxaris> BoudewijnEctor: you use [x:xs], which means: a list of exactly one element, which is again a list
06:33:11 <BoudewijnEctor> yes I want to do so
06:33:16 <quicksilver> no, you don't. ;)
06:33:24 <BoudewijnEctor> okay
06:33:26 <quicksilver> [x:xs] is a list of lists of strings.
06:33:31 <quicksilver> you just want a list of strings
06:33:34 <quicksilver> (x:xs)
06:33:38 <BoudewijnEctor> argh
06:33:41 <BoudewijnEctor> stupid of mine
06:33:44 <quicksilver> it's ok
06:33:47 <BoudewijnEctor> I could have used map too
06:33:47 <quicksilver> we've all been there :)
06:34:07 <BoudewijnEctor> yeah I know, but if feel soooo stupid sometimes  (but #haskell is a kind place)
06:34:16 <quicksilver> yes, you could write printDict l = sequence_ (map putStrLn l)
06:34:26 <BoudewijnEctor> why the sequence?
06:34:30 <quicksilver> which you could shorten to printDict l = mapM_ putStrLn
06:34:41 <quicksilver> map putStrLn will build up a list of IO actions
06:34:41 <BoudewijnEctor> instead of just : map (putStrLn) l
06:34:47 <quicksilver> you only want 1 IO action
06:34:48 <georgw> quicksilver: Debug.Trace seems to be what I need, but how can I use this within a function? Doesn't that need a do or so?
06:34:49 <BoudewijnEctor> ahh okay
06:34:57 <BoudewijnEctor> that's true, thanks for explaining
06:34:57 <quicksilver> sequence_ "joins together" the actions
06:34:57 <BoudewijnEctor> !
06:35:04 <quicksilver> georgw: it takes two parameters.
06:35:07 <BoudewijnEctor> is it a monadic function?
06:35:10 <quicksilver> :t Debug.Trace.trace
06:35:14 <Toxaris> georgw: you can just use trace in a function. it's unsafe, of course, but for debugging, it's ok
06:35:14 * BoudewijnEctor runs to hoogle
06:35:14 <quicksilver> BoudewijnEctor: putStrLn is, yes.
06:35:24 <quicksilver> @bot
06:35:24 <lambdabot> :)
06:35:25 <lambdabot> thread killed
06:35:30 <igel> Debug.trace is for debugging and nothing else
06:35:30 <quicksilver> :t Debug.Trace.trace
06:35:31 <lambdabot> forall a. String -> a -> a
06:35:40 <quicksilver> georgw: see, two paraemters ?
06:35:48 <quicksilver> georgw: the first parameter is the string to print
06:35:50 <igel> don't use it for anything else
06:35:53 <georgw> quicksilver: Yeah, got that. Use that in main, and it worked.
06:35:55 <quicksilver> the second is the 'expression'
06:35:56 <quicksilver> ;)
06:35:59 <quicksilver> good stuff.
06:35:59 <georgw> Ahh, duh!
06:36:15 <georgw> Ok, I'm not fully thinking in Haskell mode yet...
06:36:20 <quicksilver> add a b = trace "calling add now" (a+b)
06:36:23 <quicksilver> for example.
06:36:40 <georgw> quicksilver: got it now, thanks. :-)
06:36:57 <georgw> Takes some time to wrap my head around Haskell...
06:37:04 <quicksilver> well trace is a mess
06:37:10 <quicksilver> it doesn't really make sense
06:37:17 <quicksilver> it's just there for debugging and I don't use it myself
06:37:18 <kaaaen> a lifetime :)
06:37:42 <igel> trace is nice to find out about evaluation order, etc
06:37:53 <quicksilver> only if you're careful
06:37:54 <georgw> Cause it violates the philosophy? No destructive stuff in functions?
06:38:00 <igel> but it really should be removed from productive code
06:38:02 <quicksilver> it can confuse more than it elucidates.
06:38:10 <quicksilver> georgw: it violates the semantics.
06:38:15 <quicksilver> it makes you program not haskell any more :)
06:38:18 <georgw> ok.
06:38:22 <igel> georgw: it performs IO
06:38:36 <igel> and IO belongs into an IO monad
06:38:52 <georgw> I'll be tempting the Haskell gods for debugging purposes then and solemny swear to sacrifice trace on the altar of production later
06:38:55 <igel> otherwise you may get strange errors
06:39:10 <igel> :D ^^
06:39:25 <igel> well trace is not as bad as unsafePerformIO^^
06:39:37 <shepheb> @quote remember georgw I'll be tempting the Haskell gods for debugging purposes then and solemnly swear to sacrifice trace on the altar of production later
06:39:37 <lambdabot> No quotes for this person. I can't hear you -- I'm using the scrambler.
06:39:46 * shepheb fails.
06:39:53 <shepheb> @help quote
06:39:53 <lambdabot> quote <nick>
06:39:53 <lambdabot> remember <nick> <quote>
06:39:53 <lambdabot> Quote somebody, a random person, or save a memorable quote
06:40:00 <wvd> I am not happy with the way in which emacs indents my code in M-x haskell-mode
06:40:10 <shepheb> @remember georgw I'll be tempting the Haskell gods for debugging purposes then and solemnly swear to sacrifice trace on the altar of production later
06:40:10 <lambdabot> Okay.
06:40:31 <georgw> hehehe
06:40:38 <wvd> if I use do, without {, } and ;, so relying on the indentation
06:40:45 <georgw> @quote
06:40:46 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
06:41:06 <wvd> emacs moves everything over to the beginning of the second word on the previous line
06:41:48 <wvd> foo x = do then on the next line, whatever I put there will start at the same position as the x
06:42:19 <wvd> so if I write somelongfunctionname = do, it will start under the =
06:42:48 <wvd> is there some emacs setting I could set to make it always indent by a fixed amount?
06:43:02 <igel> time to propose vim ;)
06:43:05 <wvd> maybe 4 spaces for the first level, 8 for the next etc...?
06:43:11 <igel> (just kidding)
06:43:41 <wvd> its trivial to set the tabstop=4 for vi
06:43:57 <wvd> but I do like emacs a bit more
06:44:20 <igel> i don't want to start a flamewar
06:44:24 <wvd> is there a descent haskell mode bundle for textmate?
06:45:37 <wvd> because I totally dont mind using textmate, considering that I bought it specifically because emacs' php-mode (dont ask, it pays the bills) sucks
06:46:25 <swiert> has anyone here managed to build ghc from macports?
06:47:11 <monn> Hi all!
06:47:51 <wvd> there is a diskimage with a mac installer you can download from haskell.org
06:48:09 <wvd> specifically because last time I checked the macports version was broken
06:48:29 <swiert> wvd: yes. I know, but it's been fixed recently.
06:50:35 <quicksilver> wvd: you can hit <TAB> a few times to try different indentation ooptions.
06:50:54 <quicksilver> wvd: but you may prefer to try kuribas' new haskell indentation code.
06:52:30 <ilyak_> Hi everyone!
06:52:42 <ilyak_> What does it mean when function name ends with '?
06:53:07 <quicksilver> nothing much
06:53:13 <quicksilver> it's just a name
06:53:22 <ilyak_> :) What does it usually mean?
06:53:25 <quicksilver> it might mean 'new version of' or 'slight variation of' or 'helper function for'
06:53:29 <ilyak_> I see :)
06:53:33 <ilyak_> Thanks.
06:53:45 <quicksilver> in the case of foldl' it means "Strict"
06:53:58 <quicksilver> there are probably a couple of others along that line in the standard li.
06:54:05 <wvd> quicksilver: where would I find kuribas' new indentation code?
06:54:46 <shap1> @yow !
06:54:46 <lambdabot> Place me on a BUFFER counter while you BELITTLE several BELLHOPS in the
06:54:46 <lambdabot> Trianon Room!!  Let me one of your SUBSIDIARIES!
06:55:22 <shap1> Lots of new people on #haskell lately, I'm out of touch!
06:55:50 <wvd> shap1: run for the hills, haskell is the new ruby on rails ;)
06:56:12 <shap1> Sounds good to me.
06:56:23 <shap1> I'd like to get another Haskell job in a few years.
06:56:51 <mae> hi
06:57:01 <mae> anyone interested in this library i've been working on? :
06:57:02 <mae> *Xhtml> (tag "a"){href'=Just "http://google.com", children=[CDATA "My Link"]}
06:57:02 <mae> <a href="http://google.com">My Link</a>
06:57:20 <ketil> ruby on rails, haskell off road!
06:57:20 <mae> could use some help
06:57:30 <mae> its dynamically generated from the XHTML dtd
06:57:31 <shapr> mae: Er, what's your library?
06:58:17 <shapr> Haskell on Hills?
06:58:37 <shapr> ketil: Actually, I like yours very much.
06:59:01 <ketil> uh, my what?
06:59:01 <georgw> Ok, trace helped a lot. Now the code runs on simple problems. Thanks a lot for the various pointers, it's saved a couple of hours at least.
06:59:03 * ketil blushes.
06:59:06 <shapr> ketil: Haskell Off Road
06:59:07 <georgw> \me <--- happy. =)
06:59:10 <ketil> Oh, that.
06:59:11 <ketil> :-)
06:59:16 * georgw <--- happy. =)
06:59:17 <mae> shapr: what makes my library unique is that it actually statically enforces the allowed attributes from the dtd
06:59:29 <mae> for instance, http-equiv is not usable with <a>
06:59:31 <mae> *Xhtml> (tag "a"){href'=Just "http://google.com", http_equiv="blah", children=[CDATA "My Link"]}
06:59:32 <mae> <interactive>:1:42: Not in scope: `http_equiv'
06:59:35 <ketil> It just struck me that "on rails" could be perceived as a bit, well, single tracked.
06:59:47 <shapr> mae: Huh, I thought HaXml could do that.
06:59:53 <shapr> ketil: Yeah, I hadn't thought about that.
07:00:17 <mae> shapr: yeah i wanted something more like Text.Xhtml though ; )
07:00:21 <shapr> oh
07:00:39 <mae> does haxml enforce it at compile time or at runtime?
07:00:47 <shapr> I think at compile time.
07:00:54 <mae> i thought it was a validating xml parser
07:01:12 <shapr> Yeah, but it also builds up an ADT that represents a DTD.
07:01:24 <shapr> Xml2Haskell I think.
07:01:49 <ketil> mae, is using record syntax: a) reader friendly and b) not causing name clashes?
07:02:03 <ketil> mae (for somewhat larger HTML documents, that is)
07:02:08 <mae> yeah i like it ; )
07:02:16 <mae> its basically generated from ruby lol
07:02:21 <shapr> mae: On the other hand, I think HaXml doesn't handle everything DTDs can do.
07:02:22 <mae> here i'll pastie the code
07:02:29 <shapr> hpaste it?
07:02:32 <mae> you guys can tell me if i should dump it
07:02:36 <mae> or if i should keep workign on it
07:02:39 <ilyak_> How would I say "same list as l except nth element changed to m"?
07:02:49 <shapr> mae: I think you should keep working on it until it works.
07:02:56 <mae> it does work
07:02:58 <shapr> mae: Because you seem to enjoy it, and you seem to be learning stuff from it.
07:03:09 <shapr> What's not to like about that?
07:03:13 <opqdonut> ilyak_: take (n-1) list ++ [m] ++ drop (n+1) list
07:03:15 <opqdonut> one way
07:03:28 <opqdonut> using split might be nicer
07:03:36 <ilyak_> opqdonut: Isn't there a predef function somewhere?
07:03:54 <shapr> mae: Ok, write quickcheck tests for it and put it on hackage?
07:04:13 <ketil> mae: I'm with shapr.  And if the library gets dissed by some jerks on IRC, that would certainly *not* a be good reason to drop it.
07:04:28 <faxathisia> > let wobble list n m = take (n-1) list ++ [m] : drop (n+1) in wobble "test" 1 'x'
07:04:30 <opqdonut> ilyak_: no, not really
07:04:31 <lambdabot>  Couldn't match expected type `[[t]]'
07:04:32 <shapr> Wait, was I being a jerk?
07:04:38 <faxathisia> > let wobble list n m = take (n-1) list ++ [m] ++ drop (n+1) in wobble "test" 1 'x'
07:04:38 <lambdabot>  Couldn't match expected type `[a]'
07:04:48 <shapr> ketil: Hey, when's the next time you'll be in Boston?
07:04:58 <ketil> shapr no, I said *if*.
07:05:00 <ketil> :-)
07:05:00 <shapr> oh
07:05:05 <faxathisia> > let wobble list n m = take (n-1) list ++ [m] ++ drop (n+1) list in wobble "test" 1 'x'
07:05:08 <lambdabot>  "xst"
07:05:11 <shapr> Also, if someone on #haskell is being a jerk, talk to me or dons about it.
07:05:25 <ketil> shapr, Uh, when was the last time I was there?
07:05:41 <shapr> ketil: I haven't seen you for months.
07:05:49 <shapr> ketil: I figured you were being productive and busy and stuff.
07:05:54 <faxathisia> > let wobble list n m = take n list ++ [m] ++ drop (n+1) list in wobble "test" 1 'x'
07:05:55 <lambdabot>  "txst"
07:06:00 <hpaste>  mae pasted "the generator" at http://hpaste.org/6161
07:06:04 <shapr> On the other hand, I've been very busy, so if you've been here in the last two months, I might have missed it anyway.
07:06:17 * ketil is puzzled.  Have we actually met?
07:06:47 <shapr> ketil: No, and that's the problem!
07:06:49 <ketil> Or "see" as on IRC?  Busy is part of it, /&%# broken network connection is another.
07:06:49 * shapr grins
07:06:56 <benny99> hi, I'm reading "Data Types A La Carte" -- but I'm stuck at the line -- data Expr f = In (f (Expr f )) -- what does In mean ?
07:06:59 <shapr> ketil: See as in IRC.
07:07:10 <faxathisia> benny99: In is the type constructor
07:07:20 <faxathisia> benny99: The data type definition defines In
07:07:27 <benny99> ouch, thanks
07:07:39 <ketil> Anyway: Last time in Boston - 1992 or so.  Next time, well, my wife has some business there, so perhaps I'll be able to tag along at one point.  No immediate plans, though.
07:08:09 <shapr> Ok, ping me when you're in town, I'll buy you dinner and see if I can scrape up other Haskellers.
07:08:13 <faxathisia> benny99: so In :: (a -> b) -> .... wait what the hell? I can't figure that out
07:08:26 <ketil> We do have a Ph.D. position open, so unless you have the degree already, you can apply, and just /maybe/ my employer will buy you a ticket to go to Bergen.
07:08:43 <ketil> :-)
07:08:46 <shapr> I don't have a PhD yet, but neither do I have what I need to apply for a PhD.
07:08:55 <faxathisia> hmm In :: f (Expr f) -> Expr f
07:08:59 <quicksilver> a pen and paper?
07:08:59 <shapr> I do have a job I wish to keep though.
07:09:04 <shapr> quicksilver: hah
07:09:04 <benny99> faxathisia: http://lambda-the-ultimate.org/ <- data types a la carte ;)
07:09:05 <lambdabot> Title: Lambda the Ultimate | Programming Languages Weblog
07:09:18 <daf> shapr: speaking of which, we should meet up some time
07:09:19 <shapr> quicksilver: Most PhD positions require having some other degree before you apply.
07:09:25 <quicksilver> true.
07:09:29 <ketil> quicksilver, or a (half) a brain?
07:09:31 <shapr> daf: Ok, what are you doing on Saturday or Friday evening?
07:09:46 <daf> shapr: don't think I have anything planned
07:09:59 <quicksilver> @tell wvd http://kuribas.hcoop.net/haskell-indentation.el
07:09:59 <lambdabot> Consider it noted.
07:09:59 <shapr> ketil: I would be very amused to move to Norway after 2+ years in Finland and 4+ years in Sweden.
07:10:01 <ketil> shapr, seriously, a master's degree is required, yes.
07:10:05 <quicksilver> @tell wvd you left before I could answer :P
07:10:05 <lambdabot> Consider it noted.
07:10:07 <shapr> ketil: Yeah, I thought so.
07:10:11 <ketil> shapr, yes!  Collect the whole set!
07:10:13 <faxathisia> hmmm do you need a PhD in computing to get an interesting research job in programming?
07:10:28 <opqdonut> not necessarily
07:10:30 <shapr> ketil: Denmark is too expensive to live there.
07:10:43 * araujo thinks that shapr has a shaPhD instead
07:10:47 <shapr> haha
07:10:47 <daf> more expensive than Norway?
07:10:47 <ketil> faxathisia, no.  Depends a bit on what you find "interesting"
07:10:51 <opqdonut> :P
07:11:03 <ketil> About the same, I would guess.
07:11:07 <mae> here is the output
07:11:08 <mae> http://jupiter-labs.com/Tag.hs
07:11:29 <mae> and the wrapper http://jupiter-labs.com/Xhtml.hs
07:12:02 <shapr> daf: Yeah, I think Denmark is more expensive than Norway.
07:12:21 <opqdonut> well norway is pretty expensive too
07:12:25 <BMeph> shapr: To live in, or to live with? ;)
07:12:28 <opqdonut> or at least high standard of living
07:12:34 <shapr> BMeph: live IN ...
07:12:40 <BMeph> Heh-heh. :)
07:13:00 <shapr> Yeah, I know Norway has crayfish, and that's a highly profitable national resource. (Ok, and oil, and lots more)
07:13:19 <opqdonut> and Opera!
07:13:31 <BMeph> shapr: Not to mention, the place is crawling with Norwegians! :)
07:13:32 <opqdonut> and Trolltech
07:13:47 <shapr> I've heard Norwegians are expensive.
07:14:52 <quicksilver> getting a license to hunt them in expensive
07:14:56 <quicksilver> even in Finland
07:15:04 * shapr laughs
07:15:19 <shapr> I've wanted to learn Nynorsk for years.
07:15:54 <BMeph> quicksilver: It's easy to get that kind of lcense in Sweden. There, it's a State-supported activity! o.O
07:16:13 <BMeph> s/lcense/license/
07:16:35 <quicksilver> s/license/licence/
07:16:43 <quicksilver> where I come from, at least.
07:16:44 <BMeph> shapr: Wait, what's the "other" Norwegian language? :)
07:16:57 <shapr> I forget..
07:17:15 <mae> does anyone have a suggestion on a better way to write the new function or the Show Tag instance that is less verbose
07:17:16 <quicksilver> Bokmal.
07:17:20 <mae> in
07:17:25 <mae> http://jupiter-labs.com/Tag.hs
07:17:33 <quicksilver> well, as far as my limited keyboard will allow.
07:18:27 <ketil> bokml (book language) is the most used, nynorsk (new Norwegian) is less so.
07:18:45 <ketil> BMeph, unless you mean sami?
07:19:28 <joed> which is existing across scandinavias northern parts is it not?
07:19:29 <BMeph> ketil: Thanks, no, I meant bokml.
07:20:47 <ketil> joed, the people, yes.  In theory - in practice, they too move south and towards the cities.
07:21:06 <kpreid> mae: generate a function Tag -> (String, Map String String) (where the first value is the element name and the map is attribute names to values), then write Show in terms of that
07:21:17 <kpreid> mae: also your data type should be called Element, not Tag
07:21:31 <mae> ok ; )
07:21:38 <joed> ketil: true. Reindeer herding is perhaps not the source of revenue it used to be.
07:25:06 <mae> kpreid: you mean that the function will return a tuple right with attr name and value?
07:25:15 <mae> i'm a bit confused
07:25:19 <mae> what does Map mean
07:25:21 <kpreid> no, a map of attr name to attr value.
07:25:26 <kpreid> also the element name.
07:25:27 <mae> ahh ok
07:25:44 <kpreid> (see the Data.Map module. Or you could use [(String,String)] instead
07:26:32 <mae> so its job is to basically return all the attrs and values
07:26:36 <mae> that will still be pretty verbose
07:26:48 <mae> i guess theres no way to introspect on attr names?
07:26:56 <kpreid> yes, but it won't mix it up with the logic for properly printing html attribtes
07:27:26 <shapr> jfredett: Are you busy on Saturday?
07:27:33 <kpreid> you can derive Data.Generics.Data
07:27:38 <kpreid> and introspect using that
07:28:03 <mae> hmm i think that is a bit heavy handed in this case
07:28:06 <kpreid> also, why not use an existing html library?
07:28:08 <shapr> Anyone in the Boston area and wants to show up for a sorta Haskell meeting on Saturday?
07:28:18 <mae> is there any easier way to set attr defaults to Nothing?
07:28:27 <mae> or is undefined my doomed state without using glasglow exts
07:28:51 <mae> kpreid: because no html libraries i know of use the record syntax like this ; )
07:29:02 <kpreid> well, you could define one value for each element type with all members Nothing
07:29:18 <kpreid> then use record update syntax to produce your wanted elements
07:29:36 <mae> hmm ok
07:29:47 <kpreid> blankLink = Link {rel=Nothing; rev=Nothing href=Nothing}
07:29:54 <shapr> I wonder if I should ask the suspects if they want to show up.
07:29:59 <mae> oh i see
07:30:02 <kpreid> someLink = blankLink { href = Just ... }
07:30:48 <quicksilver> I think using attributes like that may be doomed to failure.
07:31:00 <quicksilver> or, at least, failure to be as convenient as you want it to me :)
07:31:08 <glen_quagmire> eval :: Val -> Val ;  eval :: Stack -> Val -> Val ;  eval :: Stack -> Queue -
07:31:10 <quicksilver> you may consider a syntax like:
07:31:15 <glen_quagmire> oh darn
07:31:36 <quicksilver> a [ href := 'blah' , content := cdata "My Text" ]
07:31:42 <glen_quagmire> eval :: Val -> Val ;  eval :: Stack -> Val -> Val ;  eval :: Stack -> Queue -> Val -> Val ; eval :: SourcePos -> Stack -> Queue -> Val -> Val ... my eval function takes more parameters. how can I manage?
07:32:03 <mae> quicksilver: remind me what := does again ; )
07:32:22 <quicksilver> nothing
07:32:24 <quicksilver> it's up to you ;)
07:32:29 <quicksilver> it's just a symbol.
07:32:33 <mae> ah nm i think i knowah
07:32:42 <mae> i get it
07:32:45 <mae> ; )
07:32:49 <quicksilver> it's a constructor (operators beginning with : are constructors)
07:32:59 <quicksilver> of some not-yet-written custom data type :)
07:33:02 <byorgey> glen_quagmire: create a custom monad (based on Reader) for the evaluation environment, perhaps?
07:33:08 <quicksilver> HtmlProperties, or something.
07:33:08 <mae> oo
07:33:28 <glen_quagmire> arg i guess i really have to learn monad for good
07:33:51 <byorgey> glen_quagmire: see the "Monad Transformers Step by Step" paper for a nice tutorial-like example of doing this sort of evaluation with monads
07:34:00 <byorgey> @go Monad Transformers Step by Step
07:34:00 <glen_quagmire> maybe haskell without monad is C without pointers
07:34:01 <lambdabot> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
07:34:01 <lambdabot> Title: Monad Transformers Step by Step
07:34:23 <faxathisia> You can implement almost all monads in haskell
07:34:29 <glen_quagmire> byorgey: thank you
07:34:45 <byorgey> glen_quagmire: more like haskell without monads is like C without for loops.  You can still do everything you want with while loops, but it's annoying.
07:34:48 <faxathisia> Is it only IO that you need implementation stuff for?
07:35:08 <byorgey> faxathisia: yup.
07:36:25 <DukeDave> Question: Is there anything 'bad' in defining a function eq = (==)
07:36:34 <DukeDave> (for purely cosmetic reasons)
07:36:53 <byorgey> DukeDave: no.
07:36:58 <glen_quagmire> (eq 1 2) -- lisp
07:37:13 <faxathisia> glen_quagmire: You should use =
07:37:23 <faxathisia> eq on numbers is not correct
07:37:36 <byorgey> DukeDave: building domain-specific languages (which is essentially what that amounts to) is a time-honored tradition in Haskell =)
07:38:01 <dcoutts_> @seen ndm
07:38:01 <lambdabot> ndm is in #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell. I last heard ndm speak 1h 29m 48s ago.
07:38:12 <DukeDave> > 1 = 2
07:38:12 <lambdabot>  Parse error at "=" (column 3)
07:38:19 <dcoutts_> ndm: could you test this for me please: http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.12.1.exe
07:38:24 <quicksilver> faxathisia: depends on your lisp dialect, does it not?
07:38:29 <dcoutts_> ndm: should work with 6.8.2
07:38:37 <DukeDave> byorgey: Sounds good to me :)
07:38:39 <quicksilver> faxathisia: I think some lisp will automatically intern numbers or otherwise arrange for that to work.
07:38:58 <faxathisia> quicksilver: It will likely work since the numbers are small but that's just a coincidence
07:39:16 <faxathisia> quicksilver: in Common Lisp.. scheme doesn't have eq and I don't know any other lisps
07:44:56 <drigz> !seen dons
07:46:27 <Saizan> @seen dons
07:46:27 <lambdabot> dons is in #haskell, #xmonad and #haskell-soc. I last heard dons speak 10h 17m 54s ago.
07:49:05 <ilyak_> And now I'm going to try writing first program utilizing IO monad :)
07:50:59 <quicksilver> main = putStrLn "Hello, ilyak_"
07:52:24 <LeCamarade> Where do I go, to get started with MetaHaskell?
07:52:55 <quicksilver> have you tried the meta-internet?
07:53:54 <LeCamarade> :o)
07:53:59 <LeCamarade> Google.
07:54:10 <quicksilver> I think it's pretty much vanished, if it ever was any more than vapour.
07:54:16 <LeCamarade> ?q=metahaskell returns ()
07:54:16 <lambdabot> Unknown command, try @list
07:54:28 <quicksilver> I think it was vapour ware or paper-ware
07:54:41 <LeCamarade> Oh.
07:54:43 <quicksilver> (that is, software which is described in a research paper as if it exists but never actually does)
07:55:11 <BoudewijnEctor> hi guys, I've got another question
07:55:12 <BoudewijnEctor> removePunctuationList :: [String] -> [String]
07:55:12 <BoudewijnEctor> removePunctuationList list = filter (not null) (map (removePunctuation) list)
07:55:19 <BoudewijnEctor> Can someone tell me what's wrong?
07:55:37 <BoudewijnEctor> the map function should create a [String] btw
07:55:42 <quicksilver> BoudewijnEctor: not null is wrong.
07:55:44 <quicksilver> > not True
07:55:47 <quicksilver> > not False
07:55:49 <quicksilver> > not null
07:55:49 <lambdabot>  False
07:55:49 <lambdabot>  True
07:55:49 <lambdabot>  Couldn't match expected type `Bool'
07:55:54 <quicksilver> ;)
07:56:02 <quicksilver> try (not . null)
07:56:05 <faxathisia> :t not.null
07:56:07 <lambdabot> forall a. [a] -> Bool
07:56:11 <BoudewijnEctor> ahhh darn
07:56:12 <faxathisia> :t filter
07:56:13 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
07:56:15 <BoudewijnEctor> thanks man :)
07:56:38 <quicksilver> LeCamarade: or, did metahaskell become TH?
07:56:44 <quicksilver> LeCamarade: that's the other possibility.
07:57:02 <LeCamarade> quicksilver: But TH doesn't let me define a syntax.
07:57:19 <ndm> dcoutts_: only have 6.6 on this machine, will test it in about half an hour when i get home
07:57:28 <LeCamarade> It only lets me generate Haskell.
07:57:34 <dcoutts_> ndm: ta
07:57:37 <quicksilver> LeCamarade: no, you're right. But my suggestion may still be true :P
07:57:59 <ndm> dcoutts_: have emailed haskell-cafe with my GSOC proposal, listing you as my mentor
07:58:00 <LeCamarade> quicksilver: Ah. The papers just changed hands and names ...
07:58:02 <ketil> How can I make a class 'derivable'?
07:58:06 <dcoutts_> ndm: oh, nice
07:58:13 <LeCamarade> If I remember well, Igloo is the TH guy?
07:58:16 <mauke> ketil: you can't
07:58:16 <dcoutts_> ndm: I suppose I'd better read it then :-)
07:58:23 <ketil> mauke, oh.
07:58:31 <quicksilver> LeCamarade: there is a paper which happens to be called 'metahaskell.ps'
07:58:45 <quicksilver> LeCamarade: which describes something which looks to me like it is the thing which later became TH>
07:58:55 <ndm> dcoutts_: preliminary proposal, it doesn't have all the required details on it for the proper application - such as my haskell experience etc
07:58:57 <LeCamarade> Hmm.
07:59:04 <quicksilver> LeCamarade: It is coauthored by Tim Sheard of OGI
07:59:16 * LeCamarade was hoping to do some unusual Haskell for tonight.
07:59:34 <quicksilver> LeCamarade: and OGI was where the metahaskell stuff was proceeding.
07:59:34 <ndm> LeCamarade: he did a lot of work on it for his phd
07:59:46 <byorgey> yes, Tim Sheard was very involved in TH
08:00:23 <faxathisia> oh he made Omega language
08:00:33 <faxathisia> (which I couldn't compile :/)
08:00:41 <quicksilver> LeCamarade: there is probably a story about how the aims and objectives of the project shifted over the years. Such things generally do :)
08:00:42 <faxathisia> but it seems interesting none-the-less
08:00:52 <quicksilver> LeCamarade: I'm only speculating and guessing from a series of google searches and papers.
08:01:07 <quicksilver> "guesstimatubing"
08:04:15 <quicksilver>  LeCamarade has quit ["Not paid to hang out at #haskell"]
08:04:18 <quicksilver> well, he should be.
08:04:24 <quicksilver> let's have a whip-round.
08:05:18 <faxathisia> payment in lambdas
08:05:20 <faxathisia> :D
08:09:08 <ilyak_> I wonder how many peole do brainfuck interpreter as a haskell exercise
08:09:17 * faxathisia one
08:09:19 <quicksilver> there is on in lambdabot
08:09:22 <quicksilver> @bf
08:09:22 <lambdabot> Done.
08:09:29 <faxathisia> lol nice work Lambdabot
08:09:42 <ilyak_> :)
08:09:52 <resiak> @bf ++++++[>+++++<-].
08:09:53 <lambdabot>  fd:23: hClose: resource vanished (Broken pipe)
08:09:57 <resiak> or, not.
08:10:04 <ilyak_> I've just wrote one, it does bottles but doesn't do mandelbrot or hanoi
08:10:12 <ilyak_> I guess that have something with IO
08:11:47 <Saizan> i think in HEAD you can define your own language with TH
08:12:03 <shapr> Wah?
08:12:14 <quicksilver> orly?
08:12:27 <ilyak_> Maybe it did something with wrap-around also...
08:12:35 <shapr> Saizan: Anymore details?
08:12:44 <Saizan> there was an announce about QuasiQuoting on the mailing list
08:13:22 <Saizan> http://www.eecs.harvard.edu/~mainland/ghc-quasiquoting/
08:13:26 <lambdabot> Title: Quasiquoting Support for GHC
08:13:31 <allbery_b> lambdabot's bf interpreter has been broken for a while
08:13:43 <quicksilver> quasiquoting doesn't let you define your own language, does it?
08:13:57 <quicksilver> not in the sense that lecamarade means?
08:14:09 <quicksilver> although it's definitely a cool thing and I'm looking forward to it.
08:14:19 <faxathisia> In the haskell logs somewhere there's an interp htat fits in  @let
08:14:34 <quicksilver> In fact, quasiquoting doesn't even require TH, I don't think.
08:14:40 <faxathisia> if someone can grep '@let bf' you can probably find it
08:15:02 <quicksilver> oh, yes it does.
08:15:04 <quicksilver> my mistake :)
08:15:11 <quicksilver> import Language.Haskell.TH.Quote
08:15:15 <Saizan> quicksilver: see the bottom of this http://haskell.org/haskellwiki/Quasiquotation
08:15:29 <quicksilver> funnily enough that's the very page I'm reading.
08:15:36 <Saizan> ok :)
08:16:32 * byorgey just realized he's eligible to apply to GSOC!! =D
08:16:51 <byorgey> this changes everything....
08:16:54 * byorgey plots
08:18:10 <ilyak_> Wow, it's 50 times slower than beef
08:22:13 <ilyak_> Wow, nope, it actually works
08:22:32 <ilyak_> It just takes forever to draw even a single mandelbrot line
08:23:18 <ilyak_> I guess the next step would be optimizing brainfuck interpreter
08:24:35 <georgw> can I use actions in the ghci console? Like generating a random number?
08:24:46 <ilyak_> georgw: yeah you can
08:25:02 <faxathisia> @die 66
08:25:02 <lambdabot> 66 => 66
08:25:06 <georgw> ilyak_: It don't seem to work for me... :-|
08:26:10 <ilyak_> georgw: putStr "FOO\n"
08:26:30 <georgw> ilyak_: ok, that one I get. How about obtaining a random number?
08:26:40 <byorgey> @die 2d6
08:26:41 <lambdabot> 2d6 => 5
08:27:11 <mauke> georgw: :m +System.Random
08:27:12 <byorgey> @type randomRIO
08:27:17 <mauke> randomIO :: IO Int
08:27:25 <mauke> randomIO :: IO Double -- etc
08:27:27 <lambdabot> thread killed
08:27:34 <byorgey> @type randomRIO
08:27:35 <lambdabot> forall a. (Random a) => (a, a) -> IO a
08:27:39 <byorgey> @type randomIO
08:27:40 <lambdabot> forall a. (Random a) => IO a
08:27:46 <ilyak_> georgw: :module Random
08:27:47 <georgw> Ok, got that. But what can I do with that IO thing? Cannot print it...
08:27:48 <BMeph> > randomRIO (1,10)
08:27:57 <ilyak_> georgw: randomIO :: IO Int
08:27:58 <lambdabot>  <IO Integer>
08:28:10 <georgw> *Main> randomRIO (1, 10)
08:28:12 <georgw> no output...
08:28:25 <kpreid> ah, ghci's dwim fails there
08:28:32 <ilyak_> georgw: Why?
08:28:32 <kpreid> enter "print it"
08:28:36 <ilyak_> It says '8' on me
08:28:39 <ilyak_> and then '4'
08:28:39 <kpreid> or randomRIO (1, 10) >>= print
08:28:54 <kpreid> version difference?
08:28:56 <byorgey> georgw: huh, it works for me
08:29:07 <georgw> kpreid: print it worked now.
08:29:07 <BMeph> Same here.
08:29:11 <byorgey> georgw: what version of ghc/ghci do you have?
08:29:22 <BMeph> ...or Hugs? ;)
08:29:30 <hpaste>  BoudewijnEctor pasted "changing spellchecker into 'online' spellchecker" at http://hpaste.org/6162
08:29:34 <BoudewijnEctor> Hi guys
08:29:44 <BoudewijnEctor> I've finished my spellchecker, but still have 1 slight problem
08:29:44 <georgw> 6.4.1
08:29:47 <byorgey> hi BoudewijnEctor
08:29:50 <ilyak_> I'm on 6.6
08:29:53 <BoudewijnEctor> Just pasted it onto past
08:29:53 <BoudewijnEctor> e
08:29:56 <BoudewijnEctor> *hpaste
08:30:02 <byorgey> georgw: yikes, that's rather old =)
08:30:10 <BoudewijnEctor> It works well now, but I need to make it 'online'
08:30:27 <georgw> Ok... should mention that to our sysadmin then...
08:30:37 <BoudewijnEctor> So it should read the text file and start checking, without completing reading the textfile allready (so it must be lazy)
08:30:49 <BoudewijnEctor> Does anyone have a suggestion about how to do so?
08:31:46 <georgw> ok, now a little bit advanced... how about an array of 10 random booleans?
08:31:47 <byorgey> georgw: 6.8.2 is the latest stable release, and 6.6.1 would be fine too (there are packages for 6.6.1 for pretty much every distro/packaging system, so should be easy for your sysadmin to upgrade)
08:32:17 <BoudewijnEctor> This is the official requirement: and make sure the spell checking has online behaviour,
08:32:17 <BoudewijnEctor> i.e., that spell checking starts already while reading the file.
08:32:19 <georgw> byorgey: Thanks for the hint, I'll let them know.
08:32:28 <BoudewijnEctor> And I don't know how to implement it properly
08:33:03 <doserj> BoudewijnEctor: readFile already does lazy IO, so I don't think you have to do sth. special
08:33:34 <drigz> > randomIO :: Bool
08:33:35 <lambdabot>  Couldn't match expected type `Bool' against inferred type `IO a'
08:33:41 <drigz> > randomIO :: IO Bool
08:33:42 <lambdabot>  <IO Bool>
08:33:50 <BoudewijnEctor> Okay, but doesn't the 'let' statement interfere with that in the spellcheck function?
08:34:21 <Jomyoot> Is there a Persistence storage for Haskell?
08:34:30 <Jomyoot> Something similiar to BerkleyDB but without that licensing would be gerat
08:34:33 <ndm> @seen edwinb
08:34:33 <georgw> drigz: thanks!
08:34:33 <lambdabot> edwinb is in #haskell. I don't know when edwinb last spoke.
08:34:58 <byorgey> do g <- getStdGen; return (take 10 $ randoms g :: [Bool])  -- georgw, something like this
08:35:27 <georgw> byorgey: Much thanks!
08:36:05 <byorgey> georgw: that's a list, not an array, but maybe that's what you meant anyway?
08:36:08 <mdmkolbe|ubuntu> (1) Is the material in SYB3 in the latest GHC? (2) If "(1)" then is there a recent FreshLib that works off of the latest GHC?
08:36:21 <byorgey> georgw: if you really actually need an array, rather than a list, you can always construct it from the list later
08:36:25 <georgw> byorgey: Yep, you read my mind correctly. :-)
08:36:30 <byorgey> georgw: ok =)
08:36:36 <doserj> BoudewijnEctor: how would it interfere? as long as removePunctuationList is lazy, I think you are fine.
08:36:38 <ndm> mdmkolbe|ubuntu: no
08:37:01 <mdmkolbe|ubuntu> ndm: no to "(1)"?
08:37:02 <ndm> mdmkolbe|ubuntu: there may be a package doing the template haskell solution on hackage though
08:37:16 <Toxaris> BoudewijnEctor: your code should process the file "online" as you wish
08:37:17 <ndm> mdmkolbe|ubuntu: yes, (1) == Just no, (2) = Nothing
08:37:19 <BoudewijnEctor> doserj, Ok if you say so. Thanks :)
08:37:36 <BoudewijnEctor> Toxaris, what do you mean ?
08:37:38 <georgw> And if I now wanted an array of arrays of Bools, would I have to call randoms repeatedly, because it's an action?
08:37:48 <drigz> my god, an interactive prompt without readline is the most infuriating thing in the world
08:38:00 <faxathisia> drigz: Yeah :S
08:38:03 <doserj> BoudewijnEctor: you don't have to trust me. Just try it out on a large text file, and watch the memory use
08:38:11 <mdmkolbe|ubuntu> ndm: thx
08:38:13 <BoudewijnEctor> Okay will do :)
08:38:27 <faxathisia> drigz: if you could interface with command line programs in a different way than a Terminal what should it be?
08:38:46 <drigz> georgw: you could just change 'take 10' to 'listArray (1,10)'
08:39:06 <drigz> faxathisia: what do you mean?
08:39:08 <Toxaris> BoudewijnEctor: I mean that your code already does what you want :) it reads a word from the textfile, removes punctuation, checks wether that word is in the dictionary. if yes, it is printed. then it reads the next word
08:39:15 <ilyak_> drigz: I thought ghci have readline
08:39:25 <ilyak_> Or you're talking about something else?
08:39:34 <drigz> ilyak_: for some reason mine doesn't
08:39:35 <faxathisia> drigz: curious about alternatives.. just wondering for other ideas
08:39:36 <drigz> or it's not working
08:39:38 <mdmkolbe|ubuntu> @src foldl
08:39:38 <lambdabot> foldl f z []     = z
08:39:38 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
08:39:46 <ilyak_> drigz: Maybe it's compiled withoud?
08:39:52 <mdmkolbe|ubuntu> @src foldr
08:39:52 <lambdabot> foldr f z []     = z
08:39:52 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:39:53 <BoudewijnEctor> Toxaris, okay thanks, will now try on a large file... :)
08:40:02 <drigz> ilyak_: i'm using an os x binary which apparently has it
08:40:20 <drigz> ilyak_: it's meant to be statically linked in, but for some reason not even backspace works
08:40:52 <ilyak_>         libreadline.so.5 => /lib/libreadline.so.5 (0xb7f88000)
08:40:58 <Toxaris> BoudewijnEctor: you can see this from the general structure of your program: printStrList . filter (...) . map (...) . words =<< readFile
08:41:03 <ilyak_> that's ldd my ghc
08:41:15 <BoudewijnEctor> Okay
08:41:30 <BoudewijnEctor> So it is correct currently :)
08:41:33 <ilyak_> my mandelbrotter is eating ram fast
08:41:38 <drigz> ilyak_: i don't know what the os x equivalent of ldd is...
08:41:54 <drigz> otool -L apparently
08:43:04 <hpaste>  mdmkolbe|ubuntu pasted "does this function exist?" at http://hpaste.org/6163
08:43:30 <mdmkolbe|ubuntu> For all you foldl experts out there, does this varient of foldl exsists anywhere already? http://hpaste.org/6163
08:43:55 <drigz> anyway, if it's statically linked as it claims, i guess ldd/otool -L wouldn't show it
08:44:08 <georgw> drigz: can I also get a list of 10 lists of 10 randoms?
08:44:10 <Toxaris> BoudewijnEctor: well, I'm not sure about the "Choose a suitable datastructure" part of the assignment :)
08:44:24 <faxathisia> mdmkolbe: Did you mean foldl' f z (x:xs) = foldl' f z' (x'++xs) where (z', x') = f x z -- ?
08:45:09 <byorgey> mdmkolbe|ubuntu: it doesn't seem like that will terminate.
08:45:18 <ilyak_> is there a brainfuck benchmark somewhere I wonder? :)
08:45:19 <byorgey> mdmkolbe|ubuntu: but perhaps you are looking for mapAccumL?
08:45:26 <byorgey> @type mapAccumL
08:45:41 <lambdabot> thread killed
08:45:49 * byorgey glares at lambdabot
08:45:58 <byorgey> @type mapAccumL
08:45:59 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
08:46:03 <byorgey> @botsnack
08:46:03 <lambdabot> :)
08:46:36 <byorgey> it lets you map over a list while carrying along an auxiliary accumulator
08:46:48 <byorgey> @where folds
08:46:48 <lambdabot> http://cale.yi.org/index.php/Fold_Diagrams
08:47:13 <Toxaris> byorgey: it will terminate if f sometimes returns (..., [])
08:47:29 <byorgey> Toxaris: oh, that's true, I had failed to appreciate the significance of the ++
08:47:34 <allbery_b> where is mapaccuml.com? :)
08:47:40 <drigz> georgw: you could always just split up a list of 100
08:47:45 <BoudewijnEctor> Toxaris, me neither. But I don't know a beter data structure
08:48:04 <Toxaris> BoudewijnEctor: do you know any data structures?
08:48:10 <drigz> > takeWhile (not.null) . map (take 10) . iterate (drop 10) $ [0..99]
08:48:13 <lambdabot>  [[0,1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18,19],[20,21,22,23,24,25,26...
08:48:15 <BoudewijnEctor> Some about Fingertrees
08:48:41 <faxathisia> > takeWhile (not.null) . map (take 0) . iterate (drop 0) $ [0..99]
08:48:42 <BoudewijnEctor> And trees , and a couple of array's
08:48:44 <lambdabot>  []
08:48:49 <faxathisia> > map (take 0) . iterate (drop 0) $ [0..99]
08:48:50 <lambdabot>  [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],...
08:48:56 <byorgey> mdmkolbe|ubuntu: hm, ok, so this is basically doing a fold over the results of a depth-first search?
08:49:13 <byorgey> mdmkolbe|ubuntu: seems to me it would be better to separate out the tree generation and the fold
08:49:13 <georgw> drigz: Ok, thanks. =) One more, if I may: the do g <- stuff works in the console, how do I put the IO [Bool] result into a variable?
08:49:24 <mdmkolbe|ubuntu> byorgey: that is not quite what I'm after.  I'm aiming for a foldl, but one of the "f" operations might add extra "work" that has to be added to the list of work
08:49:48 <mdmkolbe|ubuntu> list of work = xs
08:49:56 <georgw> drigz: In source code that is...
08:49:59 <drigz> georgw: alternatively, you could use: let tenrandoms = newStdGen >>= return . take 10 . randoms :: IO [Bool] in replicateM 10 tenrandoms
08:50:17 <Toxaris> byorgey: but the generation of the tree may depend on the intermediate folded value
08:50:26 <byorgey> mdmkolbe|ubuntu: right, I get it now
08:50:34 <byorgey> Toxaris: ah, true
08:50:36 <drigz> georgw: one downside of using random numbers in the IO monad is that any function you'll have to keep them in the IO monad the whole way through
08:50:41 <byorgey> ok, ignore me then =)
08:51:09 <drigz> so you can write pure functions that use the values and then use liftM so they can process the random numbers
08:51:40 <drigz> alternatively, you can replace newStdGen with (mkStdGen 123421) (or any hardcoded number) but the numbers will be the same every time
08:52:37 <Toxaris> BoudewijnEctor: I do not know how much effort you are supposed to invest into this assignment... but some kind of search tree may be a sensible choice for your program. maybe you are allowed to use a standard one, or you are supposed to program your own. try to analyse your program for complexity to see why it isn't exactly sensible to use a list for the dictionary :)
08:53:14 <mileswu> > map (+1) [1..10]
08:53:14 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
08:53:38 <BoudewijnEctor> Toxaris, I'm allowed to use a standard one. That's perfectly okay. It's think about a tree with a node for each letter, containing 1 node for each word
08:53:38 <mauke> > [2..11]  -- OPTIMIZED
08:53:39 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
08:53:41 <faxathisia> > (+1) . [1..10]
08:53:41 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
08:53:46 <idnar> optimalized
08:54:01 <idnar> @type (.)
08:54:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:54:07 <idnar> sneaky
08:54:36 <hpaste>  mdmkolbe|ubuntu pasted "Error message when loading SYB3" at http://hpaste.org/6164
08:54:38 <drigz> > [2..11] :: [Int] -- faster
08:54:39 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
08:55:09 <faxathisia> > read "[2,3,4,5,6,7,8,9,10,11]" -- slower .. if it even works
08:55:09 <Toxaris> BoudewijnEctor: i mean standard as in standard library. but a node for each letter sounds sensible, too.
08:55:09 <lambdabot>  Exception: Prelude.read: no parse
08:55:31 <mileswu> > (+1) . (Maybe 10)
08:55:32 <lambdabot>   Not in scope: data constructor `Maybe'
08:55:35 <BoudewijnEctor> Toxaris, do you know about a sensible datatype for doing so?
08:55:39 <mileswu> > (+1) . (Just 10)
08:55:40 <lambdabot>  Just 11
08:55:49 <mdmkolbe|ubuntu> What does this error message mean? http://hpaste.org/6164
08:56:11 <faxathisia> > Just.Nothing
08:56:11 <lambdabot>   Not in scope: data constructor `Just.Nothing'
08:56:14 <Toxaris> BoudewijnEctor: well you have to define your own algebraic data type. it's quite easy do model a tree with algebraic data types.
08:56:15 <faxathisia> :(
08:56:18 <faxathisia> > Just . Nothing
08:56:19 <lambdabot>  Nothing
08:56:36 <BoudewijnEctor> Toxaris, Yes , okay. Thanks. Will try :)
08:56:48 <drigz> > read "[2,3,4]" :: [Int] -- there you go, faxathisia
08:56:49 <lambdabot>  [2,3,4]
08:56:49 <mileswu> > Just . Just . Just . Just . Just 1
08:56:49 <lambdabot>  Just (Just (Just (Just (Just 1))))
08:57:04 <quicksilver> mdmkolbe|ubuntu: what it means is that you're trying to instantiate an 'arbitrary' type var with a 'particular' type var when the type checker thinks it should be arbitrary.
08:57:08 <faxathisia> > Just . Just $ Just . Just $ Just . 1
08:57:09 <lambdabot>   add an instance declaration for (Num (f a))
08:57:12 <quicksilver> mdmkolbe|ubuntu: i.e. you're breaking the quantification rules.
08:57:12 <mileswu> > Just . (Just 1)
08:57:13 <lambdabot>  Just (Just 1)
08:57:24 <faxathisia> > Just . Just $ Just . Just $ Just . Just $ 1
08:57:25 <lambdabot>  Just (Just (Just (Just (Just (Just 1)))))
08:57:34 <mdmkolbe|ubuntu> quicksilver: thx
08:57:50 <EvilTerran> ... has someone redefined (.) to fmap again?
08:57:54 <resiak> cale.
08:57:56 <resiak> presumably?
08:58:01 <FMota> :/
08:58:05 <faxathisia> :D
08:58:10 <resiak> I'm disappointed that he never 'fixed' $
08:58:21 <faxathisia> resaik: How?
08:58:33 <EvilTerran> @let infixl 0 $; ($) = id
08:58:34 <lambdabot> Defined.
08:58:37 <resiak> he thinks it needs the opposite associativity
08:58:37 <EvilTerran> :D
08:58:49 <EvilTerran> > (,) $ 1+2 $ 3+4
08:58:49 <lambdabot> Terminated
08:58:54 <faxathisia> > f $ g $ h $ x
08:58:55 <EvilTerran> wait what
08:58:55 <lambdabot> Terminated
08:58:59 <faxathisia> > f $ g $ h $ x :: Expr
08:59:00 <lambdabot> Terminated
08:59:07 <resiak> you destroyed the world
08:59:10 <EvilTerran> naughty bot! no cookie for you!
08:59:13 <faxathisia> > f $ (g $ (h $ x)) :: Expr
08:59:13 <lambdabot> Terminated
08:59:17 <faxathisia> hmmmmmmmmm
08:59:18 <FMota> > 10
08:59:19 <faxathisia> :?
08:59:19 <lambdabot>  10
08:59:55 <FMota> > print $ "Hello" ++ " World."
08:59:55 <lambdabot> Terminated
09:00:00 <faxathisia> lol
09:00:03 <faxathisia> :t ($)
09:00:04 <lambdabot>     Ambiguous occurrence `$'
09:00:04 <lambdabot>     It could refer to either `L.$', defined at <local>:6:12
09:00:04 <lambdabot>                           or `Data.Function.$', imported from Data.Function at State/imports.h:15:0-32
09:00:11 <mauke> @define ($)
09:00:11 <lambdabot> Undefined.
09:00:21 <mauke> :t ($)
09:00:22 <lambdabot> forall a b. (a -> b) -> a -> b
09:00:28 <FMota> > print ("Hello" ++ " World.")
09:00:28 <lambdabot>  <IO ()>
09:00:44 <faxathisia> @let data O = E
09:00:44 <lambdabot> Invalid declaration
09:01:00 <FMota> > fact 10
09:01:01 <lambdabot>   Not in scope: `fact'
09:01:25 <FMota> nvm.
09:01:32 <EvilTerran> > (,) L.$ 1+2 L.$ 3+4
09:01:33 <lambdabot>   Not in scope: `L.$'
09:01:42 <EvilTerran> oh, someone did an undef
09:01:45 <EvilTerran> @let infixl 0 $; ($) = id
09:01:45 <lambdabot> Defined.
09:01:49 <EvilTerran> > (,) L.$ 1+2 L.$ 3+4
09:01:50 <lambdabot>  (3,7)
09:03:02 <drigz> EvilTerran: i think it is best for everyone if > id $ 1 actually terminates on its own.
09:03:09 <EvilTerran> bah
09:03:11 <EvilTerran> @undef
09:03:12 <lambdabot> Undefined.
09:03:16 <EvilTerran> spoilsport.
09:03:25 <faxathisia> @let fact = product . flip take [1..]
09:03:25 <lambdabot> Defined.
09:03:28 <faxathisia> > fact 5
09:03:28 <lambdabot>  120
09:03:48 <drigz> > product . enumFromTo 1 5
09:03:48 <lambdabot>   add an instance declaration for (Enum [a], Num [a])
09:03:59 <drigz> > product $ enumFromTo 1 5
09:04:00 <lambdabot>  120
09:07:22 <mauke>  expansion
09:07:41 <smg> what's that?
09:07:42 <smg> :)
09:07:47 <smg> ny?
09:11:49 <hpaste>  Shurique pasted "Readline linking error on OSX" at http://hpaste.org/6165
09:12:00 <Shurique> any ideas?
09:12:06 <Shurique> the same program works fine when run in ghci
09:12:13 <mauke> U+0ED7 (e0 bb 97): LAO DIGIT SEVEN []
09:16:48 <Shurique> never mind, seems I had to add -framework GNUreadline to the ghc line
09:20:00 <desegnis> smg, nu is 
09:23:19 <jorick> when i do "filename <- hGetLine h", how can i make sure the filename is not ../../../foo ?
09:23:54 <hpaste>  Ilyak pasted "brainfuck interpreter" at http://hpaste.org/6166
09:24:16 <ilyak_> I wrote it today and want to ask on how to make it faster.
09:24:36 <ilyak_> I understand it's pretty dirty, but my main concern is optimization now
09:25:02 <EvilTerran> use a Data.Sequence for memory
09:25:14 <ilyak_> (But I'm also interested in ideas on refactoring in into something less hairy)
09:25:15 <EvilTerran> amortized O(n) appends to either end
09:25:18 <ilyak_> EvilTerran: I'll look there
09:25:26 <EvilTerran> alternatively, use an infinite list zipper
09:25:41 <EvilTerran> start with something like ([0..],0,[0..])
09:25:43 <ilyak_> EvilTerran: What's that?
09:26:09 <EvilTerran> then next (before,here,after:afters) = (here:before,after,afters)
09:26:23 <Toxaris> ilyak_: the problem is the mem !! (pos - 1). (!!) is generally a bad idea.
09:26:26 <EvilTerran> prev (before:befores,here,after) = (befores,before,here:after)
09:26:46 <EvilTerran> it's a very efficient way of dealing with a linear structure if you just want to step back and forth
09:26:53 <ilyak_> Toxaris: I've got the idea, but I guess my alter is much slower than !!
09:27:06 <EvilTerran> O(n) to move n steps along the structure, regardless of where in it you are
09:27:14 <ilyak_> EvilTerran: I can't say I understand you, maybe any URL on subject?
09:27:24 <EvilTerran> basically, it's all the elements before the current one, reversed; then the current one; then all the following elements
09:27:42 <EvilTerran> the preceding ones are reversed so you can get the nearest one really easily
09:28:10 <EvilTerran> and if you start with (sorry, i got this wrong the first time) (repeat 0, 0, repeat 0), that's your infinite tape all sorted out
09:28:48 <quicksilver> ilyak_: the simple quick fix is just use Data.Sequence instead of list.
09:28:57 <quicksilver> EvilTerran's zipper ideas are cool but more complex.
09:29:00 <ilyak_> quicksilver: I'll try that.
09:29:03 <EvilTerran> ...not really...
09:29:11 <quicksilver> Data.Sequence is not quite drop-in but close enough.
09:29:46 <EvilTerran> (the list of elements you get moving to the left from the current one, the current element, the list of elements to the right)
09:30:21 <EvilTerran> you can shuffle back and forth in the structure (reverse left ++ [current] ++ right), as it were, very efficiently, with no effects from the size of the structure
09:30:57 <ilyak_> Can I (x:xs) Data.Sequence?
09:31:19 <EvilTerran> not as such
09:31:27 <EvilTerran> ?hoogle a -> Sequence a -> Sequence a
09:31:28 <lambdabot> No matches, try a more general search
09:31:34 <Cale> ilyak_: (:) doesn't construct values of Seq
09:31:38 <EvilTerran> ?hoogle a -> Seq a -> Seq a -- what's it called again?
09:31:38 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-- what's '
09:31:42 <EvilTerran> ?hoogle a -> Seq a -> Seq a
09:31:42 <lambdabot> Data.Sequence.(<|) :: a -> Seq a -> Seq a
09:31:42 <lambdabot> Data.Sequence.(|>) :: Seq a -> a -> Seq a
09:31:42 <lambdabot> Data.Sequence.update :: Int -> a -> Seq a -> Seq a
09:31:44 <EvilTerran> gr
09:31:49 <Toxaris> ilyak_: I think you should learn about zippers, they are super cool, quite easy, and perfectly suited for bf interpreters :)
09:31:57 <ilyak_> Cale: How would I use that in function pattern matching?
09:32:11 <ilyak_> Can I destructure sequences?
09:32:19 <ilyak_> Toxaris: Any URLs maybe?
09:32:22 <Cale> Yeah, with viewl and viewr
09:32:26 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Sequence.html
09:32:27 <ilyak_> I just don't get them yet
09:32:28 <lambdabot> http://tinyurl.com/3dzkp8
09:32:39 <Cale> data ViewL a
09:32:39 <Cale> = EmptyL
09:32:39 <Cale> | (:<) a (Seq a)
09:32:43 <Cale> viewl :: Seq a -> ViewL a
09:32:59 <EvilTerran> ?where zipper
09:33:00 <lambdabot> I know nothing about zipper.
09:33:01 <EvilTerran> ?where zippers
09:33:02 <lambdabot> I know nothing about zippers.
09:33:09 <Cale> So, you can do something like:
09:33:15 <Saizan> ?google wikibook zipper
09:33:16 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Zippers
09:33:21 <Cale> case viewl mySeq of
09:33:23 <EvilTerran> we need views :(
09:33:25 <Cale>   EmptyL -> ...
09:33:34 <Cale>   x :< xs -> ...
09:33:49 <ilyak_> Cale: I'll try
09:33:49 <EvilTerran> then you could say foo (-> x :< xs) = ...
09:33:56 <EvilTerran> but unfortunately you can't ATM
09:34:01 <smg> uh, forall a. a -> a seems redundant why do we write forall? a -> a is enough imho :\
09:34:13 <Cale> Or at least,  foo (viewl -> x :< xs) = ...
09:34:14 <EvilTerran> smg, sometimes the forall is necessary
09:34:20 <ndm> EvilTerran: or you could use pattern guards, which are much more general, while views pretty much only get used for Data.Sequence
09:34:23 <EvilTerran> Cale, well, quite
09:34:24 <quicksilver> smg: we don't write it normally.
09:34:26 <smg> EvilTerran: necesarry?
09:34:38 <smg> o really? i thought it would be only for clarity
09:34:44 <Cale> smg: In Haskell, forall is usually implied, but it's not *really* redundant.
09:34:47 <Toxaris> ilyak_: most documents seem to be to advanced :(
09:34:49 <EvilTerran> ndm, nah, i can think of plenty of instances where views would eliminate a single-shot variable you'd need even if you had pattern guards
09:35:02 <quicksilver> I certainly don't think views are only for Data.Sequence
09:35:04 <smg> Cale: i couldn't find it in haskell 98 standard :\
09:35:08 <ndm> EvilTerran: i have yet to be convinced that anyone would use them, other than when working with data.sequence
09:35:12 <EvilTerran> pattern guards don't save you any variables, they just make the syntax nicer
09:35:15 <quicksilver> but actually I don't find case viewl myseq of ...
09:35:21 <quicksilver> to be a problem
09:35:24 <EvilTerran> ?src words
09:35:25 <lambdabot> words s = case dropWhile isSpace s of
09:35:25 <lambdabot>     "" -> []
09:35:25 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
09:35:25 <Cale> smg: Well, right, explicitly including the forall in type signatures is a GHC extension.
09:35:28 <ndm> pattern guards are 100% essential, in my opinion
09:35:42 <smg> Cale: ah okay
09:35:57 <ndm> EvilTerran: they let you have statement level choice where before you only had expression level choice
09:36:06 <EvilTerran> eh
09:36:16 <EvilTerran> you can do the same with a case/of, tupling, and lazines
09:36:18 <Cale> smg: This is because Haskell 98's type system is sufficiently simple that you can't put the foralls anywhere else, so by making them implicit, they're all forced to the beginning of the signature.
09:36:30 <smg> ooh
09:36:45 <smg> a = rigid variable then?
09:36:57 <Cale> smg: In GHC, you're allowed to put them elsewhere, for example:  f :: (forall a. a -> a) -> (Char, String)
09:37:00 <EvilTerran> words (break isSpace . dropWhile isSpace -> (w,s)) = w : words s
09:37:10 <EvilTerran> words _ = []
09:37:12 <Cale> f g = (g Char, g String)
09:37:14 <Cale> er
09:37:15 <EvilTerran> is that not pretty?
09:37:17 <Cale> duh :)
09:37:24 <smg> Cale: so what would be better? i mean i see no use for the forall statement?
09:37:25 <Cale> f g = (g 'a', g "Hello")
09:37:43 <ndm> EvilTerran: no, you can't - as soon as you move to case you have committed to an equation
09:37:52 <Cale> smg: It has two uses.
09:37:57 <EvilTerran> ndm, so bundle all the equations into the case as well
09:38:13 <ndm> EvilTerran: now you have lost the ability to have multiple equations - which i think is important
09:38:20 <EvilTerran> i admit, it'd be ugly, but pattern guards still don't save you many variable names AFAICT
09:38:21 <Cale> smg: One, it makes type variables locally scoped.
09:38:22 <ndm> although of cause you can remove all equations entirely and replace them with cfase
09:38:29 <Cale> That is, if you write:
09:38:30 <EvilTerran> multiple equations desugars to case anyway
09:38:33 <ndm> its not ugly, its loosing the separation of concerns
09:38:34 <EvilTerran> ?type \f -> (f True, f 'a')
09:38:37 <lambdabot>     Couldn't match expected type `Char' against inferred type `Bool'
09:38:37 <lambdabot>       Expected type: Char -> t
09:38:37 <lambdabot>       Inferred type: Bool -> t1
09:38:37 <Cale> f :: forall a. ...
09:38:48 <EvilTerran> ?type \f -> ((f :: forall a. a -> a) True, f 'a')
09:38:49 <lambdabot>     Inferred type is less polymorphic than expected
09:38:49 <lambdabot>       Quantified type variable `a' is mentioned in the environment:
09:38:49 <lambdabot>         f :: a -> a (bound at <interactive>:1:1)
09:38:50 <hpaste>  RFC pasted "my first program" at http://hpaste.org/6167
09:38:57 <EvilTerran> bah
09:39:17 <EvilTerran> ?type \f -> (f True, f 'a') :: (forall a. a -> a) -> (Bool, Char)
09:39:18 <lambdabot>     Couldn't match expected type `Char' against inferred type `Bool'
09:39:19 <lambdabot>       Expected type: Char -> t
09:39:19 <lambdabot>       Inferred type: Bool -> t1
09:39:19 <Cale> Then within the body of f, the type variable a will refer to that type variable, and not others.
09:39:23 <EvilTerran> grah
09:39:23 <jorick> so i made my first program but i have a little error in it because i don't sanitize input my users give me, they can read ../../..
09:39:27 <EvilTerran> i give up
09:39:30 <smg> Cale: ah okay
09:39:40 <EvilTerran> ndm, well, i feel the two extensions serve different purposes
09:39:45 <jorick> does anyone know what i could do to mak it more secure ?
09:39:53 <EvilTerran> pattern guards do all this separation of concerns stuff you like
09:40:06 <EvilTerran> and views do the eliminating of single-shot variables that *i* like
09:40:16 <quicksilver> jorick: check if the input contains dots?
09:40:17 <Cale> smg: It's sometimes important or convenient to refer to the actual type which is being used :)
09:40:19 <ndm> EvilTerran: i agree - i just think one is really useful, and have yet to be convinced on views (although a lot of convincing examples would persuade me)
09:40:23 <quicksilver> jorick: check if it contains doubledots?
09:40:28 <quicksilver> jorick: cehck for slashes?
09:40:34 <quicksilver> jorick: lots of approachs suggest themselves.
09:40:35 <Cale> smg: Another use is explicitly making parameters to a function polymorphic.
09:40:35 <EvilTerran> ndm, what did you think of my re-expression of "words"?
09:40:46 <jorick> i don't really know how to begin doing any of these things
09:40:57 <Cale> smg: Consider the function:
09:41:00 <ndm> EvilTerran: ugly - although that may be because of unfamiliarity, rather than actual ugliness...
09:41:00 <Saizan> EvilTerran: variables bound with lambdas are monomorphic
09:41:02 <EvilTerran> you could go further...
09:41:11 <EvilTerran> words (break isSpace . dropWhile isSpace -> (w, words -> ws)) = w:ws
09:41:19 <Cale> foo f = (f "Hello", f [1,2,3])
09:41:33 <Cale> It normally doesn't typecheck.
09:41:33 <EvilTerran> you still have two single-shot variables, but the original had, what, four? six?
09:41:46 <EvilTerran> 4
09:41:55 <ndm> EvilTerran: i still don't quite get how it falls through to the second equation
09:41:57 <EvilTerran> Saizan, i knew that, but i thought an explicit type sig could override that
09:42:00 <DukeDave> Is there a prelude function to split a list in to 'chunks' of size n?
09:42:03 <Cale> However, there is a type which this foo inhabits (it's just not a Haskell 98 type)
09:42:14 <EvilTerran> ndm, er... mea culpa
09:42:19 <DukeDave> Int -> [a] -> [[a]]
09:42:22 <ndm> DukeDave: no, but splitAt will give you a useful start
09:42:41 <quicksilver> DukeDave: that came up yesterday too. Funny.
09:42:41 <Cale> DukeDave: no, but  map (take n) . takeWhile (not . null) . iterate (drop n)
09:43:06 <EvilTerran> ndm, i'll get back to you. there was a nice re-expression of words using views, but it seems to escape me at the moment
09:43:12 <EvilTerran> end-of-term exhaustion, you see =/
09:43:22 <DukeDave> Cale: Ah, I went for   chunkList n xs = take n xs : chunkList n (drop n xs)  and the usual [] case
09:43:41 <DukeDave> Was sure I'd used a prelude one but no luck with Hoogle
09:44:44 <mae> how do i change associativity of <<
09:45:17 <faxathisia> infixl or infixr
09:46:04 <ndm> EvilTerran: i understand :) - a nice blog showing a list of code with views and without, showing how it is of benefit, would be really useful to convince people
09:46:06 <Cale> > unfoldr (\x -> guard (not (null x)) >> Just (splitAt 5 x)) "First you will be baked, and then there will be cake."
09:46:13 <lambdabot>  ["First"," you ","will ","be ba","ked, ","and t","hen t","here ","will ","be...
09:46:35 <quicksilver> I find that rather threatening.
09:46:40 <Cale> quicksilver: hehe
09:46:43 <sm> morning all, gwern
09:46:48 <ilyak_> How would I do a Seq similar to [0]?
09:46:52 <sm> gwern: no further news.. I'll send another mail
09:46:58 <EvilTerran> ndm, you could at least get rid of one variable with (break isSpace -> (w, ...
09:47:09 <EvilTerran> in the appropriate pattern
09:47:12 <quicksilver> ilyak_: singleton 0
09:47:22 <Cale> quicksilver: It's from the game Portal.
09:47:30 <quicksilver> Cale: does LB import Data.Sequence? Qualified?
09:47:38 <ilyak_> quicksilver: Thank you, figured that by this moment.
09:47:51 <quicksilver> Cale: it would be nice to be able to get a list of its imports, qualified and not.
09:48:00 <Cale> import qualified Data.Sequence
09:48:05 <Cale> Sure, I can provide that.
09:48:18 <quicksilver> > Data.Sequence.singleton 0
09:48:19 <lambdabot>  fromList [0]
09:49:22 <ilyak_> Couldn't match expected type `Seq Op' against inferred type `ViewL a'
09:49:31 <ilyak_> That's when I try to destructure
09:50:45 <Cale> ilyak_: You have to apply  viewl  to the sequence before pattern matching.
09:51:25 <Cale> ilyak_: The reason is that internally, sequences are not the same as lists, they're stored as trees.
09:51:54 <Cale> ilyak_: So it's a nontrivial (if inexpensive) operation to extract the leftmost element and the remainder of the list
09:52:15 <Cale> *cough* sequence
09:53:02 <Cale> hmm, I wonder how I get public_html working on code.h.o
09:53:15 <Cale> Maybe I need to be in a certain group.
09:54:26 <ilyak_> Looks like I will have to carry code pointer along with data pointer
09:54:43 <jorick> there seems to be a gap in the documentation, between the trivial and the (for me) insanely complicated
09:54:52 <ilyak_> That's like "if your function have got ten parameters then you probably forgot another two"
09:54:55 <byorgey> Cale: for some strange reason, the first time I read that as "Maybe I need to be in a certain age group."
09:55:22 <dogbite> Hi.  Does anybody have experience or advice on calling haskell code from python?
09:55:38 <ilyak_> dogbite: I've seen a primer on it
09:55:47 <dmwit> dogbite: You definitely want to go via C.
09:55:50 <Cale> dogbite: It would be similar to calling C code from python. From the Haskell side, you'd do FFI exports.
09:55:53 <ilyak_> http://wiki.python.org/moin/PythonVsHaskell
09:55:53 <lambdabot> Title: PythonVsHaskell - PythonInfo Wiki
09:56:14 <dogbite> interesting.
09:56:37 <dogbite> i'm embarassed to say i saw that link from google but
09:56:44 <dogbite> didn't read it because i wasn't intersted in a comparison
09:57:34 <Cale> That strangely seems to use a windows DLL.
09:57:44 <Cale> I'm not sure that should be necessary.
09:58:00 <dogbite> yes that's what i'm thinking.  i wouldn't operate in windows (necessarily)
09:58:11 <ilyak_> Cale: Well, I guess you can straightforwardly convert that into libdl code
09:58:19 <dogbite> libdl?
09:58:39 <smg> Cale: i see nice
09:58:46 <ilyak_> dogbite: man ldopen
09:59:02 <ilyak_> man dlopen
09:59:04 <ilyak_> damn :)
09:59:05 <dogbite> ha
09:59:27 <dogbite> okay thanks for the pointers.
09:59:35 <dogbite> i will investigate them and report back what i find
10:00:37 <ndm> dcoutts_: gtk2hs worked perfectly, release away!
10:01:32 <dmwit> "Occasionally, passengers on Git airlines build an airplane that appears to go into a tailspin. When that happens, they simply assemble a tool that lets them go back in time and change history so that it doesn't crash."
10:01:39 * dmwit chuckles
10:02:30 <ski> calling a non-current continuation ?
10:03:59 <ndm> dcoutts_: is cabal upload even half a thing, or just a joke?
10:05:57 <ndm> dcoutts_: you can now cabal install guihaskell, which i used to test gtk2hs - is a very smooth and nice experience
10:21:51 <dons> ?yow!
10:22:03 <dons> ?bot bot bot
10:22:42 <faxathisia> Edwin Meese made me wear CORDOVANS!!
10:22:44 <faxathisia> :)
10:23:31 <ski> @bot
10:23:59 <dmwit> :)
10:23:59 * faxathisia confesses.. is not actually lambdabot
10:24:25 <dmwit> Don't worry, we can take turns.  Fastest evaluator wins.
10:24:30 <faxathisia> :P
10:24:49 <byorgey> > 4987239487239487234 * 29348729387298374
10:25:07 <faxathisia> I don't even know my 7 times tables @_@
10:25:13 <dmwit>  146369142100640413086072740321957516
10:25:31 <dmwit> I cheated, though.
10:26:09 <byorgey> cheated?
10:26:15 <byorgey> You mean you have a bionic implant?
10:26:56 <dmwit> No, I have a Chinese kid in my basement.
10:27:00 <BMeph> oOH, LAMBDONICS! ;)
10:27:24 <BMeph> Hmm, I prefered the "lambdonics theory. ;p
10:27:52 * BMeph goes to look up monoghrom's cell phone #
10:33:29 <skorpan> if i have data A = A { b :: B, c :: C } and data B = B { d :: D, e :: E } and i have a function taking an A, how do i return the same A, but with an updated "d"?
10:34:15 <mrd> A doesn't have a field named "d"
10:34:31 <dmwit> f a = a { b = b a { d = 3 } }
10:34:37 <dmwit> or
10:34:42 <mrd> oh oops, didn't see the B
10:35:02 <sarehu> a { b = (b a) { d = 3 } } is needed, no?
10:36:19 <skorpan> b = (b a) { ...?
10:36:26 <skorpan> i'm not sure i understand that part
10:36:47 <dmwit> f a@(A {b = b}) = a { b = b { d = 3 } } -- probably better
10:37:20 <Toxaris> skorpan: {b = (b a) { ... means: the new b component is the old b component (that is: b a), but changed
10:37:24 <dmwit> skorpan: The bit you brought up is a record update on the "b" entry in "a".
10:37:32 <skorpan> ahh!!
10:37:33 <skorpan> true!
10:37:43 <skorpan> thanks a bunch
10:37:49 <skorpan> i'll send my christmas cards to you guys
10:38:01 <dmwit> skorpan: See also FunRefs.
10:38:21 <skorpan> lambdabot: where is funrefs?
10:38:33 <dmwit> Flattering.
10:38:36 <dmwit> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
10:42:06 <Cale> quicksilver: anyway, http://cale.yi.org/autoshare/imports
10:42:56 <glen_quagmire> let's say:  eval has to evaluate stuff using Stack.   eval :: Stack -> (Val, Stack)  does it make sense? it takes stack and returns result Value with updated Stack
10:43:26 <glen_quagmire> eval :: Stack -> Val   sounds more reasonable as long as Stack is updated as side effect
10:43:34 <dons> Cale, is the bot around?
10:43:43 <glen_quagmire> darn this is monad again
10:43:48 <Cale> Is it not?
10:43:53 <Cale> @bot
10:44:01 <Cale> well...
10:44:09 <glen_quagmire> lambdabot, "1"
10:44:13 <Cale> huh
10:44:26 <Cale> It's still running.
10:44:41 <lament> glen_quagmire: sounds like you do want a monad
10:44:54 <ski> glen_quagmire : `eval' doesn't take an expression to evaluation ?
10:44:56 <Cale> @bot
10:45:03 <lambdabot> :)
10:45:12 <ski> @yarr
10:45:18 <lambdabot> Arr! Me ship be the biggest brig in the port!
10:45:21 <glen_quagmire> ski, actually, eval :: Stack -> Queue -> Val     expression is Queue
10:45:27 <hpaste>  bh pasted "Slow primes" at http://hpaste.org/6170
10:45:43 <lament> expressions are queues? what are you evaluating?
10:45:48 <glen_quagmire> so, eval :: Stack -> Queue -> String -> (Val, Stack, Queue)   where String is function name to look up
10:46:02 <ski> glen_quagmire : ok, i think you probably want `eval :: Queue -> State Stack Val' (possibly abstracted)
10:46:11 <ski> hm
10:46:24 <ski> the whole queue isn't consumed ?
10:46:28 <glen_quagmire> 1 + 2 + 3 ==> Queue [Int 1, Ident "+", Int 2, Ident "+", Int 3]
10:46:47 <ski> what is the string argument ?
10:47:06 <glen_quagmire> "+" is identifier that i lookup for builtin functions
10:47:36 <ski> hm .. you don't think it would be simpler if you parse your token-list into an AST, first ?
10:48:16 <ski> (sorry, the string argument to *`eval'* .. not to `Ident')
10:48:17 <ilyak_> Looks like the more I optimize the more imperative features I use
10:48:24 <ilyak_> Now I have an ad-hoc state
10:49:20 <glen_quagmire> evaluation strategy:  pop queue; if function { pop stack; if need more arguments { pop queue; } }
10:49:47 <glen_quagmire> if not function { push stack  }
10:50:15 <glen_quagmire> 1 + 2 == + 1 2 == 1 2 +   basically
10:50:18 <dmwit> glen_quagmire: That doesn't look good for things like "3 + 4 * 5".
10:50:45 <glen_quagmire> 3 + 4 * 5;  7 * 5; 35
10:51:12 <dmwit> Right; I'm just saying normally if you use infix notation you also provide some standard precedence rules.
10:51:17 <glen_quagmire> + will pop stack to get 3. then pop queue to get 4. and push stack 7.
10:51:24 <dmwit> (Naturally, prefix and postfix notation don't have that problem.)
10:51:53 <glguy> Anyone know a good reference to autoconf + Haskell FFI? I need to be able to detect the name of a header file for use in foreign imports
10:51:53 <glen_quagmire> you need to parenthesize things for infix or prefix. i'm just giving user freedom of style
10:52:04 <dmwit> glen_quagmire: Ah!
10:52:19 <dmwit> glen_quagmire: What you *really* want is two separate streams, one for literals, and one for functions.
10:52:20 <glen_quagmire> they can go with lisp like: (* (+ 3 4) 5)   or postfix: 5 3 4 + *
10:52:58 <dmwit> glen_quagmire: Then you don't need any of this stack/queue business at all.
10:53:16 <dmwit> glen_quagmire: Just keep popping functions off the "function" stack until it's exhausted.
10:53:18 <glen_quagmire> dmwit, i'm not sure if I follow
10:53:50 <dmwit> 3 + 4 * 5 => ([3,4,5],[+,*]) => ([7,5],[*]) => ([35],[])
10:54:12 <glen_quagmire> dmwit, you're a prodigical genius
10:54:37 <glen_quagmire> hrm then how would partial application implemented
10:55:00 <glen_quagmire> i want to allow (+ 3) 4 * 5
10:55:09 * glen_quagmire opens up paper
10:56:23 <bos> glguy: there isn't a good reference.
10:56:31 <bos> glguy: you should do it by example.
10:57:06 <dmwit> glen_quagmire: Then it's starting to look like you need a more serious evaluation scheme.
10:57:08 <bos> glguy: e.g. the pcap library uses a tiny amount of autoconf, so it's easy to understand and adapt to your needs.
10:57:24 <dmwit> glen_quagmire: i.e. proper parsing, etc.
10:57:53 <glen_quagmire> + 3 => ([3], [+]) => ([], [(+3)])
10:58:47 <dmwit> I suppose that's possible.  How does that ever differ from just dropping the parentheses, though?
11:00:36 <glen_quagmire> this is hard. parsing + 1 2, 1 + 2, 1 2 + to yield same AST would be hard too
11:01:41 <newsham> ([3]) (\x \y x + y) ->  () (\y x+3)
11:03:15 <dmwit> newsham: eh_
11:03:18 <dmwit> ?
11:06:53 <merl> hi all )
11:07:24 <byorgey> hi merl
11:07:24 <merl> give the hand of help to haskell beginner )
11:07:26 <dmwit> Hi, merl!
11:07:37 <dmwit> What's wrong?
11:08:44 <bringert> hmm, I can't seem to find a way to get at the real argv[0]
11:08:48 <merl> mm.. i`ve tried to deal with I/O and now i`m in doubt how to make Char from IO Char.. =\ in manual they says that just var <- getChar will be enough for this =\
11:08:55 <dmwit> ?hoogle IO String
11:08:55 <lambdabot> Prelude.getLine :: IO String
11:08:55 <lambdabot> Prelude.getContents :: IO String
11:08:55 <lambdabot> System.IO.getLine :: IO String
11:09:07 <dmwit> bringert: It's like getProgramName or something.
11:09:23 <newsham> dmwit: pop top two, apply, push result, repeat?
11:09:23 <mrd> merl: preceeded by 'do', yes
11:09:28 <byorgey> merl: within a do-block, you can say  var <- someIOCharThing, and then use var anywhere later within the same do-block.
11:09:33 <ski> !hpaste
11:09:35 <dmwit> bringert: System.Environment.getProgName
11:09:36 <bringert> dmwit: System.Environment.getProgName, but that's mangled
11:09:40 <ski> @hpaste
11:09:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:09:45 <bringert> dmwit: it's just the leaf name
11:09:48 <dmwit> bringert: Oh, okay, sorry.
11:10:01 <shapr> hej bringert!
11:10:03 <ski> merl : you could provide relevant parts of your code at that paste-bin above
11:10:23 <dons> Igloo: around?
11:10:24 <ski> hiya bringert
11:10:32 <bringert> hi shapr and ski
11:10:48 <ski> er, s/bringert/shapr/ .. but hi to you too ;)
11:11:08 <bringert> there ought to be something in the unix package that gets the full path
11:12:11 <shapr> heh
11:13:38 <merl> hmm... very strange, i`ve written that do block, got var <- getChar there and returned it.. but compiler still shouts at me with wrong type-mathing.. =\
11:14:07 <byorgey> merl: can you paste your code on hpaste.org?
11:14:11 <merl> ok
11:14:20 <shapr> !paste
11:14:20 <hpaste> Haskell paste bin: http://hpaste.org/
11:14:32 <dmwit> merl: You can never return a free "Char" from an IO function.
11:14:38 <shapr> I'm still not sure whether or not hpaste is dying permanently this week.
11:14:53 <dmwit> merl: Not even with the (<-) trick; because "return" puts it back into the IO monad.
11:15:19 <dmwit> merl: Anything that wants to use a free character has to be called from within an IO do-block.
11:15:49 <merl> dmwit, ah, i see =\
11:16:09 <dmwit> merl: No, no, no, it should be, "ah, i see =D". ;-)
11:16:18 <merl> =)
11:16:41 <merl> thanks a lot )
11:17:26 <dmwit> We actually call that a feature; it enforces a separation between IO code and pure code.
11:17:47 <dmwit> When you get used to it, it can make the modularization of your code go up a lot.
11:19:47 <merl> yes, i think it can.. it`s the first functional language i deal with, and the concepts are very interesting )
11:20:37 <merl> well, go for more experiments, see you )
11:20:44 <dmwit> g'luck
11:21:36 <dons> dcoutts: around? how does one create a new code.h.o project?
11:23:38 <glguy> bos: thanks
11:23:57 <bos> np
11:24:11 <glen_quagmire> f :: A -> B -> (A, B) ;  how can I iterate f?
11:24:23 <bos> glguy: it's not exactly a directly useful answer, but it's the closest you'll get :-)
11:24:34 <glen_quagmire> (a, b) = f; f a b; is what i want to do
11:25:26 <glen_quagmire> (a', b') = f a b;   (a'', b'') = f a' b' ; ....
11:26:02 <fxr> hackage-scripts down?
11:26:08 <dons> slow, i think
11:26:31 <fxr> I'm getting "The server is temporarily unable to service your request due to maintenance downtime or capacity problems. Please try again later."
11:26:40 <olsner> CosmicRay: heh, your VCS comparison was fun
11:26:59 <ski> glen_quagmire : `curry (iterate (uncurry f))' ?
11:27:54 <ski> > curry (iterate (uncurry (\a b -> (b,1+b))) 0 1
11:27:54 <lambdabot> Unbalanced parentheses
11:28:02 <ski> > curry (iterate (uncurry (\a b -> (b,1+b)))) 0 1
11:28:06 <lambdabot>  [(0,1),(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12...
11:28:15 <ski> er
11:28:21 <ski> > curry (iterate (uncurry (\a b -> (b,a+b)))) 0 1  -- i meant
11:28:22 <lambdabot>  [(0,1),(1,1),(1,2),(2,3),(3,5),(5,8),(8,13),(13,21),(21,34),(34,55),(55,89),...
11:28:30 <CosmicRay> olsner: thanks!
11:28:55 <ski> @type let iterate2 = curry . iterate . uncurry in iterate2
11:29:02 <lambdabot> forall a b. (a -> b -> (a, b)) -> a -> b -> [(a, b)]
11:31:02 * byorgey has vague thoughts about curry/uncurry and natural isomorphisms...
11:31:16 <bos> eek! error 503 from http://hackage.haskell.org/packages/archive/pkg-list.html
11:31:47 <dons> hmm...
11:31:55 <Spockz|Uni> hello
11:32:03 <fxr> bos: I sent mail to the webmaster about that.
11:32:12 <Spockz> I've to write a function to sort a list op tupels
11:32:25 <Spockz> could someone get me on the way?
11:32:31 <olsner> ooh, has parsec 3 moved out into Text.Parsec? that's nice
11:34:19 <fxr> bos: hackage returned.
11:34:55 <bos> fxr: cool
11:35:21 <dons> so carmel.co.uk is hammering hackage atm
11:35:29 <dons> looks like a multithreaded wget or something
11:35:44 <Baughn> Spockz: Use Prelude.sort?
11:35:59 <Spockz> i've to learn how to do it myself
11:36:11 <faxathisia> @src sort
11:36:11 <lambdabot> sort = sortBy compare
11:36:15 <faxathisia> @src sortBy
11:36:15 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
11:36:22 <dons> > sort [(1,2),(2,1),(1,2),(3,4),(5,3)]
11:36:27 <Baughn> Insertion sort. Cute. -_-
11:36:33 <lambdabot>  [(1,2),(1,2),(2,1),(3,4),(5,3)]
11:36:38 <Baughn> Spockz: Then the clue is "yourself". Any of the divide-and-conquer sorting algorithms should be trivial to implement, though
11:36:47 <Baughn> Spockz: If you want a challenge afterwards, try heapsort
11:37:27 <byorgey> Does Prelude.sort really use insertion sort?  Or is that just for illustration?
11:37:33 <Baughn> byorgey: Illustration
11:37:37 <Baughn> byorgey: It's really mergesort
11:37:42 <fxr> dons: thanks
11:37:44 <byorgey> whew =)
11:38:07 <Baughn> byorgey: The @src sources are chosen more for brevity than performance or sanity
11:38:08 <profmakx> dons: Did anyone sign up yet for the SoC frag project?
11:38:18 <dons> i hope not .. it won't get funded very likely
11:38:30 <dons> applications of no specific utility to the community aren't a good idea
11:38:39 <byorgey> Baughn: yup, even foldr now! =D
11:38:43 <byorgey> @src foldr
11:38:43 <lambdabot> foldr f z []     = z
11:38:43 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:38:45 <byorgey> ahh
11:38:53 <Baughn> byorgey: That one's not so bad
11:38:59 <byorgey> Baughn: it used to be
11:39:14 <byorgey> it used to have all that 'go' stuff
11:39:15 <Baughn> byorgey: Still, it wasn't O(n^2), was it?
11:39:15 <profmakx> dons, i thought of hacking a bit with it because i will have free time during the summer. but not as SoC project but just for my enjoyment
11:39:24 <profmakx> but i want to do something "productive" ;)
11:39:48 <Baughn> profmakx: How about fixing exceptions?
11:39:58 <dons> yeah, it needs someone who'll actively work on it
11:39:59 <Baughn> I'd consider that a very useful project. ;)
11:40:18 <Baughn> @ty throw
11:40:25 <lambdabot> Not in scope: `throw'
11:40:28 <Baughn> @ty error
11:40:29 <lambdabot> forall a. [Char] -> a
11:40:40 <skorpan> this gives me a parser error: http://pastebin.com/d281229bb ... why?
11:41:02 <Baughn> Fixing it might break some old code, I see. Then again, anything using error as it is now probably /should/ break
11:42:04 <profmakx> fixing exceptions?
11:42:37 <ilyak_> I guess, making error-s universally catchable, or something?
11:42:42 <Baughn> profmakx: It's on my todo-list.. somewhere
11:42:48 <Baughn> ilyak_: No, making them /distinguishable/
11:43:07 <profmakx> ah exceptions in general, not related to frag
11:43:20 <byorgey> skorpan: hmm... are you allowed to have expressions on the left side of a -> in a case like that?
11:43:25 <byorgey> I don't think you are
11:43:38 <skorpan> byorgey: yeah, i guess that's the problem
11:43:40 <byorgey> they have to be patterns
11:43:45 <Baughn> ilyak_: There should be an exception hierarchy. In fact, probably more than one - you might want to catch "any error returned by System.Posix" as well as "Any error caused by hardware malfunctions", or whatnot
11:43:45 <skorpan> i realized as soon as i had asked the question
11:44:00 <byorgey> skorpan: hehe, that's always how it works, isn't it? =)
11:45:28 <Baughn> ilyak_: Exceptions are one place where OO inheritance and casting really /helps/
11:45:53 <skorpan> byorgey: unfortunately
11:46:25 <Baughn> As it is now, I can't distinguish between "User doesn't exist" and "something, anything else went wrong" when looking up UIDs. :/
11:46:50 <Baughn> (So I've got an "on error resume next". Pity me.)
11:47:49 <doserj> "user doesn't exist" shouldn't result in an exception
11:48:01 <Baughn> You are perfectly right
11:48:34 <Baughn> I guess System.Posix is just badly designed. Nevertheless, other things /should/ result in exceptions, and not all exceptions are automatically fatal
11:50:55 <Spockz> woozers
11:50:58 <Spockz> it works :)
11:51:17 <Spockz> now if I can write my own mergesort
11:59:32 <metlhed> )==0 && x<4000000] where f=0:1:[a+b | (a,b)<-zip f (tail f)]
12:26:45 <glen_quagmire> oh darn. when I make testcase, it works.
12:27:27 <Spockz> i've a breadth-first implemantation that does the following
12:27:27 <smg> Cale: i know could make use of the forall keyword, i created a heterogenous list
12:27:53 <Spockz> mark the elements in the tree with the depth ie: a -> (Int, a)
12:28:11 <Spockz> put all the elements in a list
12:28:39 <Spockz> order the list ascending by the depth
12:28:58 <Spockz> generate a list with all the second elements from the tupil
12:29:06 <Spockz> is there a smarter way to do this?
12:29:29 <hpaste>  glen_quagmire pasted "my new language: Staque" at http://hpaste.org/6171
12:30:48 <oerjan> Spockz: you can do it recursively without any Ints
12:31:42 <Spockz> oerjan: i've been thinking about that
12:31:48 <Spockz> but it hasn't come to mind yet
12:31:57 <oerjan> bfs trees = map roots trees ++ bfs (concatMap children trees)
12:32:05 <oerjan> *root
12:33:27 <Spockz> is children a standard function?
12:33:47 <oerjan> no, i just assumed you knew how to write root and children yourself
12:34:07 <oerjan> actually it might well be standard in Data.Tree
12:34:32 <Spockz> actually, i'm pretty new to FP
12:34:43 <Spockz> concatMap = concat.map?
12:35:02 <oerjan> essentially
12:35:09 <Spockz> so not exactly? :P
12:35:19 <oerjan> @src concatMap
12:35:19 <lambdabot> concatMap f = foldr ((++) . f) []
12:35:23 <oerjan> er
12:35:31 <twanvl> concatMap f = concat . map f
12:35:41 <oerjan> yeah
12:35:54 <faxathisia> @pl \f -> concat . map
12:35:54 <lambdabot> const (join . map)
12:35:56 <faxathisia> @pl \f -> concat . map f
12:35:56 <lambdabot> (=<<)
12:36:01 <oerjan> the @src version is written for optimal compilation
12:36:02 <faxathisia> psh
12:36:02 <lambdabot> faxathisia: You have 1 new message. '/msg lambdabot @messages' to read it.
12:36:08 <faxathisia> @messages
12:36:08 <lambdabot> dolio said 3d 9h 27m ago: If you have the time, I'd appreciate it if you'd confirm a bug for me. In my agda repository, I have Category.Functor. If I uncomment the functor laws, agda -I dies here
12:36:08 <lambdabot> with "the impossible happened." Type checking for the emacs mode dies similarly.
12:36:11 <Deewiant> concatMap = (concat .) . map
12:36:18 <faxathisia> lambdabot: You already told me this
12:36:32 <faxathisia> :t (concat .) . map
12:36:33 <oerjan> @uptime
12:36:33 <lambdabot> uptime: 1h 51m 44s, longest uptime: 1m 10d 23h 44m 29s
12:36:36 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
12:36:45 <oerjan> faxathisia: seems it was crashed in the meantime
12:37:02 <smg> @type intercalate
12:37:03 <lambdabot> forall a. [a] -> [[a]] -> [a]
12:37:27 <smg> mh where is intercalate in?
12:37:31 <Deewiant> data.list
12:37:41 <smg> Deewiant: mh i need to fully qualify it, strange
12:38:01 <smg> @type intersperse
12:38:02 <lambdabot> forall a. a -> [a] -> [a]
12:38:25 <faxathisia> IN?
12:38:29 <Deewiant> intercalate = (concat .) . intersperse
12:38:31 <oerjan> Spockz: for Data.Tree rootLabel and subForest are the fields of the constructor, and those are what i called root and children respectively
12:38:45 <smg> concat $ intersperse "," ["foo","5"]
12:38:50 <smg> Deewiant: yeah sure
12:38:51 <faxathisia> Deewiant: This  .) . pattern is great
12:39:01 <smg> faxathisia: mh
12:39:09 <Deewiant> it just confuses me personally, I don't use it :-P
12:39:16 <faxathisia> yes you do :P
12:39:17 <smg> me too
12:39:34 <faxathisia> (f .) . g = ((.).(.)) f g
12:39:43 <Deewiant> I know by heart that f x = g . h x means f = (g .) . h but I don't really understand it
12:39:57 <smg> @pl intercalate x y = concat $ intersperse x y
12:39:57 <lambdabot> intercalate = (join .) . intersperse
12:39:59 <faxathisia> @src (.)
12:39:59 <lambdabot> (f . g) x = f (g x)
12:40:27 <faxathisia> ((g .) . h) x = (g .) (h x) = g . h x
12:40:40 <smg> hehe
12:41:14 <BMeph> Deewiant: Have you checked out conal's system, of using (.), versus, er, .? ;p
12:41:17 <Spockz> oerjan: ah, thanks :D
12:41:26 <faxathisia> :t (fmap.fmap)
12:41:29 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
12:42:06 <Deewiant> BMeph: no, not really ;-P
12:42:24 <Deewiant> :t ((.).(.))
12:42:26 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
12:42:41 <BMeph> Deewiant: It really means: if f:: b -> c, then (f .) :: (a -> b) -> (a -> c)
12:43:01 <Deewiant> aye, it's a partially applied (.)
12:43:13 <Deewiant> I've just never really thought it through properly :-)
12:43:16 <oerjan> Spockz: also, levels from there is another way of doing breadth-first search
12:43:41 <Spockz> 'levels from there'?
12:43:45 <BMeph> Of course, you also get (. f) :: (c -> a) -> (b -> a), but that just looks weird to me.
12:44:18 <Deewiant> :t (. (+1))
12:44:21 <faxathisia> ((.).(.)) f g x = (((.).(.)) f) g x = (.) ((.) f) g x = (.) (f .) g x = (f .) . g x
12:44:28 <lambdabot> forall b a. (Num a) => (a -> b) -> a -> b
12:44:39 <gbacon> NSFW!
12:44:50 <cjb> forall is NSFW?
12:44:56 <apfelmus> augustss_: ping
12:45:03 <cjb> oh, I see
12:45:37 <oerjan> :t Data.Tree.levels -- Spockz
12:45:38 <lambdabot> forall a. Tree a -> [[a]]
12:45:58 <smg> hello BMeph
12:46:04 <Spockz> your kidding me :P
12:47:00 <BMeph> smg: Hey there, smg! I see you're getting this Haskell stuff down, eh? :)
12:47:06 <oerjan> Spockz: why?  obviously Data.Tree has the most common operations prewritten
12:47:33 <Spockz> oerjan: it was meant to be a joke :p
12:47:39 <smg> BMeph: hehe yes i just learned a good example for forall! how this can be good.
12:47:49 <smg> BMeph: now i'm gonna read about "phantom types"
12:48:14 <BMeph> Well, at least someone is... ;)
12:49:05 <faxathisia> @free ((.).(.))
12:49:06 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
12:49:11 <faxathisia> @free (.)
12:49:11 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
12:49:25 <Deewiant> @free fail
12:49:26 <lambdabot> Expected variable or '.'
12:49:27 <faxathisia> @let owl = ((.).(.))
12:49:27 <lambdabot> <local>:2:7:     Ambiguous type variable `f' in the constraint:       `Functo...
12:50:21 <oerjan> @let owl = ((.).(.)) where (.) = (Prelude..)
12:50:24 <lambdabot> <local>:2:28: Not in scope: `Prelude..'
12:50:29 <smg> BMeph: woot? :)
12:50:32 <oerjan> sheesh
12:50:43 <oerjan> > (Prelude..)
12:50:45 <faxathisia> @free ((. :: a -> b).(. :: c -> d))
12:50:45 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
12:50:47 <BMeph> smg: Indeed. :)
12:50:47 <lambdabot>   Not in scope: `Prelude..'
12:50:52 <faxathisia> @let owl = ((. :: a -> b).(. :: c -> d))
12:50:52 <lambdabot>  Parse error
12:50:59 <oerjan> :t (Prelude..)
12:51:01 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
12:51:01 <faxathisia> @let owl = (((.) :: a -> b).((.) :: c -> d))
12:51:03 <lambdabot> Couldn't match expected type `a2' against inferred type `a -> b'
12:51:06 <oerjan> only :t has it
12:51:16 <faxathisia> :S
12:51:19 <drigz> @let owl = ((.).(.)) where (.)
12:51:19 <lambdabot>  Parse error
12:51:26 <drigz> @let owl = ((.).(.)) where (.) = \f g x -> f (g x)
12:51:27 <lambdabot> Defined.
12:51:30 <faxathisia> ahhhh
12:51:38 <faxathisia> @free owl
12:51:39 <lambdabot> g . p = q . f => (forall x. f . f1 x = f2 (h x) . k) => g . owl p f1 y = owl q f2 (h y) . k
12:52:24 <BMeph> :t (Data.Function..)
12:52:24 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
12:53:09 <oerjan> > (Data.Function..)
12:53:09 <lambdabot>   Not in scope: `Data.Function..'
12:53:16 <BMeph> Am I just overly sensitive to such things, or is "Data.Function" kind of a goofy module name, especially for its contents?
12:53:25 <oerjan> > (Data.Function.on)
12:53:26 <lambdabot>  Add a type signature
12:53:50 <oerjan> Cale seems to have hid the original . a bit well
12:55:39 <shag> does someone know how to use the ConnWrapper from HDBC?
12:57:45 <Cale> oerjan: It's a bit tricky to hide it well enough to not get conflicts.
12:58:31 <oerjan> Cale: you could import Prelude qualified as well
13:01:00 <Cale> It is imported qualified as P
13:01:12 <oerjan> ah yes.
13:01:13 <Cale> > f P.. g :: Expr
13:01:14 <lambdabot>  Couldn't match expected type `Expr' against inferred type `a -> c'
13:01:25 <Cale> > (f P.. g) x :: Expr
13:01:25 <lambdabot>  Add a type signature
13:01:28 <Cale> hmm
13:01:42 <oerjan> i think it would be a good idea if every module which was imported with an abbreviation was also imported under its full name
13:01:42 <Cale> > (+1) P.. (*2) $ 5
13:01:57 <lambdabot>  thread killed
13:02:00 <Cale> hmm
13:02:06 <Cale> > (+1) P.. (*2) $ 5
13:02:06 <lambdabot>  11
13:02:20 <Cale> silly machine
13:02:30 <skorpan> is there any function of type IO () which works as "NOP" i.e. does nothing?
13:02:38 <Cale> skorpan: There's  return ()
13:02:54 <skorpan> ah of course
13:03:01 <Cale> (but it's not quite right to call it a function ;)
13:03:04 <skorpan> i keep thinking of "return" as an imperative return statement
13:03:26 <Cale> Yeah, it doesn't call the current continuation like the return in most imperative languages does.
13:03:29 * oerjan lends skorpan a mallet to beat out that thought
13:03:34 <doserj> don't call it return, just call it "pure"
13:03:51 <skorpan> oerjan: thanks, i'll make use of it
13:03:58 <Heffalump> I think of it as "produce"
13:04:07 <smg> someone worked with phantom types?
13:04:12 * Heffalump
13:04:33 <Cale> Actually, I think return is a more appropriate name for this than for what return does in imperative languages. All this return does is return a value, it doesn't jump somewhere else in the program.
13:04:42 <oerjan> > f (g x) :: Expr
13:04:43 <lambdabot>  Add a type signature
13:04:52 <Heffalump> well, it does return, but the scope in which it returns is a little confusing
13:04:54 <oerjan> huh
13:04:55 <Baughn> Cale: Well, it's a verb. It implies action.
13:05:06 <Heffalump> return a value to the calling context
13:05:09 <oerjan> > f (g x :: Expr) :: Expr
13:05:19 <Cale> Heffalump: right
13:05:24 <lambdabot>  thread killed
13:05:25 <Baughn> I don't /mind/ it - keeping the namespace clean is nice - but "pack" might be clearer. Or "monadize"
13:05:27 <oerjan> > f (g x :: Expr) :: Expr
13:05:28 <lambdabot>  f (g x)
13:06:06 <dons> Cale: another job for you, http://sizzlingwinnie.blogspot.com/2008/03/wohoooo-wow-cant-believe-its-about.html
13:06:08 <lambdabot> Title: Winnie, http://tinyurl.com/32mh65
13:06:15 <Cale> I'm not saying that the imperative languages shouldn't call it 'return', just that perhaps Haskell's kind of return is slightly better described by its name.
13:06:25 <dons> "Anywayz, i must confess i enjoy it sometimes, it has a kinda drilling power...ha ha ha!!! Wish i could come across anyone who's a Genius when it comes
13:06:28 <dons> to Haskell..."
13:06:47 <glen_quagmire> is there a way to test a var is Integer or Double ?
13:07:08 <dons> the type already says
13:07:08 <oerjan> glen_quagmire: :t
13:07:21 <dons> :t (1.2 :: Double)
13:07:26 <glen_quagmire> data Val = Int Integer | Float Double ;     toVal i = Int i; toVal f = Float f
13:07:29 <lambdabot> Double
13:07:49 <oerjan> glen_quagmire: you cannot do that
13:08:02 <oerjan> or wait
13:08:07 <oerjan> maybe with Typeable
13:08:38 <smg> Heffalump: kinda useful eh?
13:08:51 <dmwit> glen_quagmire: You need a class definition.
13:09:22 <dmwit> class Dynamic a where toVal :: a -> Val
13:09:26 <dmwit> (or something like that)
13:09:36 <glen_quagmire> oh darn. i need to tackle this later. thank you
13:09:52 <dmwit> instance Dynamic Double where toVal = Float -- sample instance
13:09:54 <drigz> dons: i don't know if you remember, but you helped me upgrade ghc on os x. the new ghci isn't working with readline - any advice?
13:13:18 <ndm> @seen edwinb
13:13:18 <lambdabot> edwinb is in #haskell. I don't know when edwinb last spoke.
13:14:24 <ndm> @tell edwinb are you still in st-andrews? I'm spending rather a lot of time up there nowadays - are there any fp seminars or anything going on around there? any other fun stuff going on? fancy meeting up in a pub?
13:14:24 <lambdabot> Consider it noted.
13:14:36 <Cale> dons: done
13:15:31 <bogner> how can i unapply a single patch with darcs? i can find it using darcs changes but it doesn't tell me a hash or anything to identify it by
13:16:18 <daf> darcs changes --xml will tell you the id
13:16:24 <Saizan> bogner: see unpull
13:16:27 <daf> otherwise you have to identify it by name
13:16:58 <TSC> unpull, as long as the patch exists elsewhere
13:17:18 <TSC> unrecord, if it's only local (I think)
13:18:08 <ndm> bogner: darcs unrecord, and then [n] until you hit the patch, [y], then [d]
13:18:08 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
13:18:12 <ndm> @messages
13:18:12 <lambdabot> dcoutts_ said 2d 3h 50m 17s ago: hugs has no notion of installed packages, what are we supposed to do?
13:18:16 <Saizan> they do different things, unrecord leaves the files untouched
13:18:28 <TSC> Yeah, but after unrecord you can revert
13:18:35 <ndm> dons: i did @ commands but lambdabot didn't deliver me my messages
13:19:09 <dons> ndm: probably you are not identified, so privmsgs are blocked?
13:19:12 <Shimei> Oh wow, GSOC kicked off eh?
13:19:26 <dons> getting there, Shimei
13:19:43 * faxathisia wants to do a project...
13:19:44 <ndm> dons: but it told me my messages in the public channel once i sent a normal message - and i sent hte @ commands on the public channel
13:19:48 <Shimei> Oh, still accepting the organizations. Is Haskell participating again?
13:19:52 <faxathisia> they all seemed boring though
13:19:56 * Cale wonders if the owner of http://l33tminion.livejournal.com/ comes here.
13:20:02 <Heffalump> smg: yes, definitely
13:20:07 <Cale> Looking at some of the code, it's probable ;)
13:20:27 <seydar> How do I add time to a Word32
13:20:32 <seydar> "object"
13:20:37 <Cale> He imported Control.Arrow just for (&&&)
13:20:46 <Cale> seydar: hm?
13:20:52 <Heffalump> cale: I do that
13:20:58 <Heffalump> it's very handy
13:21:01 * faxathisia has done that :P
13:21:09 <Cale> Heffalump: Yeah, it's characteristic of something which #haskell programmers would do :)
13:21:14 <seydar> I ran timeGetTime and it gave me a Word32 type. I want to add time to it
13:21:34 <Cale> seydar: It's just a number, you can use +
13:21:34 <seydar> really?
13:21:37 <Cale> I don't know what timeGetTime is though.
13:21:44 <seydar> nice. does +1 mean adding + 1 second?
13:21:51 <Cale> I have no idea :)
13:22:00 <seydar> Cale: it might be an SOE specific function
13:22:04 <matthew-_> "you know you're in trouble..." #6743 "...when you have types and/or type constraints/contexts that you have no idea how to realise."
13:22:43 <Cale> Ah, it's in Graphics.Win32.Misc
13:23:04 <Cale> Apparently it's in MilliSeconds, according to the type.
13:23:07 <Cale> timeGetTime :: IO MilliSeconds
13:23:37 <Cale> (MilliSeconds is a synonym for DWORD, which is a synonym for Word32)
13:23:38 <oerjan> > maxBound `div` 1000 :: Word32
13:23:44 <lambdabot>  4294967
13:24:25 <Cale> matthew-_: hm?
13:24:57 <seydar> ok. my life is slowly drifting to pieces because of haskell and our love hate relationship
13:25:15 <Cale> seydar: heh
13:25:20 <seydar> Haskell wants BDSM? Oh, it'll GET BDSM
13:25:28 <smg> BDSM? hrhr
13:25:55 <matthew-_> Cale: well, if you just have a load of contexts, and you want to build a value that satisfies all of those contexts, eg, a type-level map (as in Data.Map, not Data.List.map), it's not obvious how to construct such a value
13:25:57 <matthew-_> (mechanically)
13:26:50 <Cale> matthew-_: ah, indeed. The typeclass system can be surprisingly expressive at times.
13:28:45 <Spockz> @t foldl
13:28:45 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:28:54 <Spockz> @type foldl
13:28:58 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:29:14 <Cale> > foldl f z [1,2,3,4,5]
13:29:15 <lambdabot>  f (f (f (f (f z 1) 2) 3) 4) 5
13:29:23 <Cale> > foldr f z [1,2,3,4,5]
13:29:23 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 z))))
13:33:48 <BMeph> I'm pleasantly surprised by some of Paul Graham's other essays - I find myself disagreeing with him about half as much, when he doesn't bring up Lisp... ;p
13:35:03 <olsner> @type f
13:35:11 <cjb> BMeph: That's just because you aren't knowledgable enough in the other areas to realize he's totally wrong about those, too.  :)
13:35:16 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
13:35:34 <cjb> BMeph: e.g. http://www.idlewords.com/2005/04/dabblers_and_blowhards.htm
13:35:34 <lambdabot> Title: Dabblers and Blowhards
13:35:41 <BMeph> cjb: LOL, yeah, I've heard that argument in other areas, too. :)
13:36:07 <olsner> there seems to be deep magic going on, but the end result is quite illuminating
13:36:37 <olsner> (the foldl f producing a printed expression)
13:38:03 <oerjan> @instances- SimpleReflect FromExpr
13:38:03 <lambdabot> Couldn't find class `FromExpr'. Try @instances-importing
13:38:13 <oerjan> huh
13:38:35 <dmwit> olsner: No magic, there's even a blog post on it. =)
13:38:43 <oerjan> @where Expr
13:38:43 <lambdabot> I know nothing about expr.
13:38:48 <dmwit> olsner: It's just a handful of nice instances, really.
13:38:48 <oerjan> argh
13:38:51 <olsner> similar to the Printf trick?
13:38:56 <oerjan> it's forgotten it
13:39:11 <dmwit> http://twan.home.fmf.nl/blog/
13:39:12 <lambdabot> Title: 21 thoughts
13:39:17 <oerjan> @where SimpleReflect
13:39:17 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
13:39:35 <dmwit> His other blog posts are also awesome.
13:39:46 <oerjan> @where+ Expr http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
13:39:46 <lambdabot> Done.
13:43:03 <ndm> why the hell isn't that blog on planet.haskell.org - it is pretty great
13:44:34 <dmwit> ndm: Well, it only updates three or four times a year... =P
13:45:04 <ndm> dmwit: who cares - thats the great thing about rss, it tells you when something changes
13:45:11 <BMeph> Heh-heh, nice ending to the profile page of the "idlewords" author: "I'm as American as gooseberry pie."
13:47:09 <dons> Cale: Johannes needs to hear the good news about the log(n) cost of hashtables, and that log(n) is O(1) for all n :)
13:47:28 <Cale> hehe :)
13:47:58 <tromp> only for all n that are 2^O(1)  :(
13:48:49 <Cale> It's true because you don't have exponential amounts of money with which to buy memory.
13:49:11 <Cale> (though perhaps improvements in memory design will thwart you)
13:49:17 <oerjan> ah an economic truth
13:49:40 <tromp> still, 20 cache misses can be quite expensive
13:50:06 <dons> the myth of hash tables
13:50:27 <ndm> dons: its not a myth if they are well implemented in an imperative language
13:50:42 <Cale> Also, if you have a large enough amount of memory, there's no way you can address it all in O(1)
13:50:44 <ndm> Judy is very impressive
13:50:52 <Cale> So hashtables are a bit of a lie.
13:51:08 <tromp> yes, I have very good experience with Judy
13:51:27 <bringert> Cale: by that reasoning, isn't all complexity analysis a bit of a lie?
13:51:44 <bringert> Cale: for very large values of n, all sorts of things start to change
13:51:49 <Cale> Yeah.
13:52:00 <ndm> i saw a student implement insertion sort in O(n^3) today...
13:52:11 <radix> impressive
13:52:12 <dons> well, the logarithmic factors in hashtables are effectively ignored, making it a myth of O(1)
13:52:35 <bringert> dons: what are the logarithmic factors?
13:52:38 <Cale> The trouble is that you're using the behaviour as n -> infinity in order to try and say things about specific finite values of n.
13:52:48 <ndm> hashtables really are O(1), trees really are O(log n) - it just so happens that we have bad hash tables and good trees
13:53:08 <ndm> and that for small values big*O(1) > small*O(log n)
13:53:13 <bringert> Cale: ah, yes
13:53:14 <johnnowak> some hash tables have guaranteed O(1) lookup and update
13:53:28 <bringert> johnnowak: guaranteed?
13:53:34 <johnnowak> bringert: yes, see cuckoo tables
13:53:39 <bringert> johnnowak: doesn't that require perfect hash functions?
13:53:45 <johnnowak> no
13:53:51 <ndm> i thought it was guranteed amortised
13:53:53 <bringert> interesting
13:54:09 <johnnowak> ndm: lookup and update are guaranteed constant time, insertion is amortized
13:54:10 <ndm> (but kjnow nothing about cuckoo tables)
13:54:33 <ndm> update is just lookup in a destructive language
13:54:43 <johnnowak> aye
13:54:56 <ndm> i should read up on cuckoo tables though...
13:54:58 <bringert> "This displaced key is then inserted in its alternative location, again kicking out any key that might reside there, until a vacant position is found, or the procedure enters an infinite loop. In the latter case, the hash table is rebuilt using new hash functions."
13:55:01 <bringert> from wikipedia
13:55:11 <bringert> which seems to imply being able to detect infinite loops
13:55:26 <johnnowak> you don't bother detecting loops, you just fail after N tries
13:55:26 <bringert> I know, I know
13:55:33 <bringert> it's just badly written
13:55:50 <bringert> it never enters an infinite loop
13:55:54 <bringert> of course
13:55:54 <johnnowak> right
13:56:21 <apfelmus> @query lamdbabot
13:56:21 <lambdabot> Unknown command, try @list
13:57:18 <bringert> hehe, this is another gem: "The basic version of cuckoo hashing has load factor limited to 49%."
13:57:26 <bringert> I guess that should be < 50%
13:57:48 <sieni> what's the complexity of an array lookup?
13:57:56 * bringert should stop complaining and edit it
13:57:58 <sieni> it's usually taken to be O(1), but is it really?
13:57:59 * bringert won't
13:57:59 <Zao> O(1), provided you know where to look.
13:58:00 <ndm> that is very cool
13:58:14 <ndm> sieni: it is, unless you use a diff array (and abstract over cache stuff, of course)
13:58:22 <apfelmus> log(size ram)
13:58:31 <dmwit> sieni: If you know the bounds ahead of time, then it is O(1).
13:58:33 <ndm> bringert: you can make it better over a few weeks, adding extra .9's
13:58:49 <augustss_> @seen apfelmus
13:58:49 <lambdabot> apfelmus is in #haskell. I last heard apfelmus speak 27s ago.
13:59:06 <apfelmus> augustss_: hi :) i missed your pong?
13:59:07 <augustss_> apfelmus: yes?
13:59:11 <dmwit> sieni: But that is only because of the old trick that takes the overhead of representing the address and folding it into the constant factor.  This is possible because of knowing the bounds, otherwise, that's not a constant.
13:59:20 <sieni> how would you build arbitrarily sized arrays (i.e. storage units) so that you guarantee O(1) access regardless of the size
13:59:22 <augustss_> apfelmus: no, you didn't
13:59:39 <apfelmus> augustss_: :) i'm looking for a good GADT example
13:59:50 <apfelmus> more precisely,
13:59:51 <dmwit> sieni: You can't.
13:59:52 <sieni> even if you assume nice physics and all that
13:59:53 <bringert> sieni: with an infinitely wide address bus of course
14:00:01 <apfelmus> an example for using GADTs as term implementation
14:00:16 <bringert> what if it's analog?
14:00:25 <bringert> and we ignore quantum physics
14:00:25 <dmwit> sieni: Like I said, it's only O(1) *if you know the bounds*.
14:00:28 <apfelmus> augustss_: i mean, there is "enforcing invariants" and "all term implementations now possible"
14:00:30 <augustss_> apfelmus: well, i've never used GADTs in anger
14:00:49 <bringert> augustss_: you just invented them...
14:00:50 <apfelmus> a peaceful example would be fine, too ;)
14:00:54 <sieni> dmwit: I was also thinking that one would have to do some sort of binary search using the bits in the array index or something to find the actual location in the hardware or something
14:01:02 <sieni> which sounds like log(n) to me
14:01:03 <faxathisia> apfelmus: http://okmij.org/ftp/papers/tagless-final-APLAS.pdf
14:01:14 <augustss_> bringert: I just stole them from people that were never going to tell anyone about them ;)
14:01:24 <dmwit> sieni: Exactly.
14:01:41 <bringert> augustss_: the type theory guys?
14:01:48 <augustss_> bringert: yes
14:01:49 <apfelmus> faxathisia: this is more the "enforce invariants" line of example
14:01:59 <tromp> is there an easy way to resolve a pathname, so that it doesn't contain any symlinks?
14:02:05 <bringert> :-)
14:02:22 <bringert> tromp: readlink or whatevery it's called
14:02:25 <apfelmus> of the "term implementations" examples, i only now the "implement monads with constructors"
14:02:35 <tromp> readlink just follows one step
14:02:38 <bringert> tromp: but you have to do that for every component
14:02:44 <bringert> tromp: and there could be loops
14:02:49 <tromp> and you'd have to do it repeatedly
14:02:49 <faxathisia> apfelmus: What do you mean by term?
14:02:57 <tromp> in case a symlink points to another symlink
14:03:00 <apfelmus> and the "implement parser combinators with constructors" from augustss_ 94 paper
14:03:02 <allbery_b> tromp: nobody has done abs_path in haskell yet, no
14:03:09 <bringert> tromp: what if it points to itself?
14:03:32 <tromp> then you can bomb any way you like:)
14:03:46 <tromp> what language has abs_path?
14:03:50 <apfelmus> faxathisia: data Monad a where { Return :: Monad a; :>>= :: Monad a -> (a -> Monad b) -> Monad b; }
14:04:08 <faxathisia> apfelmus: looks like a type level Monad
14:04:12 <bringert> tromp: oh, see realpath(3)
14:04:19 <augustss_> apfelmus: I'm afraid I don't have any good examples for you.  I assume you've looked at Tim Sheard's examples in Omega?
14:04:22 <bringert> tromp: you could FFI that
14:04:59 <apfelmus> augustss_: hm, not enough i guess. But they're mostly of the "enforce invariants" type?
14:05:56 <tromp> is soimething like realpath available in any scripting language?
14:06:06 <apfelmus> faxathisia: nah. "term implementation" as in http://citeseer.ist.psu.edu/9202.html
14:06:07 <lambdabot> Title: The Design of a Pretty-printing Library - Hughes (ResearchIndex)
14:08:19 <apfelmus> augustss_: btw, do you remember what exactly you wanted to do with Grammar a  in your "silly type families" paper?
14:08:51 <dogbite> Hello, I asked a question earlier in the day about calling haskell from python
14:08:59 <dogbite> I got some very quick responses, pointing me to
14:09:04 <dogbite> http://wiki.python.org/moin/PythonVsHaskell
14:09:04 <lambdabot> Title: PythonVsHaskell - PythonInfo Wiki
14:09:08 <olsner> bah, Ctrl-W in the wrong window
14:09:08 <apfelmus> augustss_: something with left-factoring but I'm not sure whether this is really works
14:09:11 <dogbite> and also mentioning the dlopen module
14:09:21 <dogbite> but I have to admin, I'm still confused
14:11:18 <apfelmus> back
14:11:28 <apfelmus> (darn wireless)
14:12:04 <faxathisia> apfelmus: The point of the one I linked is not primarily to enforce ivarients
14:12:14 <faxathisia> apfelmus: but realy.. that what all data types do
14:14:50 <kib> Hi, look at http://codepad.org/ . How is this possible ?!
14:15:17 <apfelmus> faxathisia: Hm, indeed, i better take a second look. And right, all data types enforce invariants but ya' know what i mean :)
14:15:45 <gwern> kib: carefully
14:15:58 <gwern> using the same techniques as lambdabot in part
14:16:19 <kib> gwern: with all languages ?
14:16:31 <apfelmus> faxathisia: i mean, one motivation for GADTs is to make all abstract data types implementable with constructors
14:16:49 <dmwit> kib: There's an FAQ that talks about their security precautions.
14:17:07 <dmwit> http://codepad.org/about
14:17:13 <kib> dmwit: ok, I'll take a look at it
14:18:16 <kib> dmwit: written in Haskell : great !
14:18:17 <dons> the big difference is they don't use type-system based proofs of safety
14:18:26 <dons> instead, it all has to be done at runtime  :)
14:20:24 <kib> dons: ok thanks, but the project is really interesting for learning maybe.
14:22:01 <apfelmus> faxathisia: ah, i see now, oleg is using "free" variables to encode constructors
14:22:17 <faxathisia> "free"?
14:23:36 <apfelmus> well, in an expression like  add (int 1) (int 2) :: Symantic repr => repr Int
14:23:54 <apfelmus> the functions  add  and  int  are like free variables
14:24:30 <apfelmus> by plugging in the right class instance, you give them a value
14:25:05 <apfelmus> > let cons = (:); nil = []; in cons 1 (cons 2 nil)
14:25:12 <lambdabot>  [1,2]
14:25:33 <apfelmus>  let cons = (+); nil = 0; in cons 1 (cons 2 nil)
14:25:58 <apfelmus> > let cons = (+); nil = 0; in cons 1 (cons 2 nil)
14:25:59 <lambdabot>  3
14:26:00 <Saizan> what are the common applications of such expression generators?
14:26:03 <faxathisia> > foldr (+) 0 (1 : 2 : [])
14:26:04 <lambdabot>  3
14:26:06 <faxathisia> > foldr (:) [] (1 : 2 : [])
14:26:07 <lambdabot>  [1,2]
14:26:41 <apfelmus> so, the expression   cons 1 (cons 2 nil)   has the free variables  cons  and nil
14:27:03 <apfelmus> @let x = \cons nil -> cons 1 (cons 2 nil)
14:27:05 <lambdabot> Defined.
14:27:13 <apfelmus> @type x
14:27:15 <lambdabot>     Ambiguous occurrence `x'
14:27:15 <lambdabot>     It could refer to either `L.x', defined at <local>:3:0
14:27:15 <lambdabot>                           or `SimpleReflect.x', imported from SimpleReflect at State/imports.h:69:0-32
14:27:28 <apfelmus> @let myx = \cons nil -> cons 1 (cons 2 nil)
14:27:28 <Baughn> > let 1 = 2 in 1+1
14:27:32 <apfelmus> @type myx
14:27:33 <lambdabot>  2
14:27:33 <lambdabot> Defined.
14:27:35 <lambdabot> forall t t1. (Num t) => (t -> t1 -> t1) -> t1 -> t1
14:27:48 <apfelmus> > myx (:) []
14:27:49 <faxathisia> O_o
14:27:52 <lambdabot>  [1,2]
14:27:53 <faxathisia> I htought 1+1 = 4
14:28:03 <Saizan> 1 is a pattern there
14:28:04 <apfelmus> > myx (+) 0
14:28:06 <lambdabot>  3
14:28:21 <Saizan> > let x@1 = 2 in x
14:28:22 <lambdabot>   Irrefutable pattern failed for pattern (x@1)
14:28:25 <Baughn> > let 1 = x in 1+x
14:28:25 <lambdabot> Terminated
14:28:29 <apfelmus> in general  myx cons nil = foldr cons nil [1,2]
14:28:44 <Baughn> > let 1 = x in 1+x
14:28:45 <lambdabot> Terminated
14:28:59 <Baughn> ..what?
14:29:18 <Baughn> > let 1 = x; x = 3 in 1+x
14:29:19 <lambdabot>  4
14:29:43 <faxathisia> > let 1 = "What???" in 1
14:29:47 <Baughn> > let 1 = x in 1+x :: Expr
14:29:47 <lambdabot> Terminated
14:29:48 <lambdabot>   add an instance declaration for (Num [Char])
14:29:48 <lambdabot>     In the pattern: 1
14:29:48 <lambdabot>     In a...
14:29:54 <faxathisia> > let Nothing = "What???" in Nothingt
14:29:55 <lambdabot>   Not in scope: data constructor `Nothingt'
14:29:56 <faxathisia> > let Nothing = "What???" in Nothing
14:29:57 <lambdabot>  Couldn't match expected type `Maybe t'
14:30:07 <Baughn> > (let 1 = x in 1+x) :: Expr
14:30:08 <lambdabot> Terminated
14:30:35 <Baughn> > let 1 = 3.14 in (1,3.14)
14:30:39 <lambdabot>  (1,3.14)
14:30:57 <faxathisia> :/
14:31:05 <faxathisia> I don't know what is going on here
14:31:06 <Baughn> > let 1 = 3 in (1 == 3)
14:31:10 <lambdabot>  False
14:31:26 <bos> @seen CosmicRay
14:31:26 <lambdabot> CosmicRay is in #haskell-blah, #haskell and #darcs. I last heard CosmicRay speak 3h 2m 56s ago.
14:31:35 <oerjan> Baughn: apfelmus accidentally @let x, creating an ambiguity
14:31:39 <faxathisia> what is going on here?
14:32:02 <Baughn> > let 1 = nosuch43 in 1
14:32:02 <lambdabot>   Not in scope: `nosuch43'
14:32:08 <faxathisia> :t 1
14:32:10 <lambdabot> forall t. (Num t) => t
14:32:15 <apfelmus> @unlet x
14:32:15 <lambdabot>  Parse error
14:32:23 <apfelmus> > x
14:32:24 <faxathisia> > let 1 = Just 1 in 1
14:32:24 <lambdabot> Terminated
14:32:24 <lambdabot>   add an instance declaration for (Num (Maybe t))
14:32:24 <lambdabot>     In the pattern: 1
14:32:24 <lambdabot>     I...
14:32:25 <Syzygy-> @forget x
14:32:25 <lambdabot> Incorrect arguments to quote
14:32:36 <Baughn> @forget-all
14:32:36 <lambdabot> Unknown command, try @list
14:32:39 <Baughn> @forget
14:32:39 <lambdabot> Incorrect arguments to quote
14:32:42 <Syzygy-> @bloodlet x
14:32:42 <lambdabot> Unknown command, try @list
14:32:49 <Baughn> @list
14:32:49 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
14:32:50 <faxathisia> > let 1 = undefined in 1
14:32:50 <lambdabot>  1
14:33:00 <faxathisia> > let "test" = undefined in "test"
14:33:01 <lambdabot>  "test"
14:33:02 <Baughn> @undefine x
14:33:03 <lambdabot> Undefined.
14:33:22 <faxathisia> > let Just x = "test" in Just 1
14:33:22 <lambdabot>  Couldn't match expected type `Maybe t'
14:33:24 <faxathisia> > let Just x = "test" in Just x
14:33:24 <lambdabot>  Couldn't match expected type `Maybe t'
14:33:29 <faxathisia> > let Just 5 = "test" in Just 5
14:33:30 <lambdabot>  Couldn't match expected type `Maybe t'
14:33:52 <Baughn> faxathisia: No redefining constructors
14:33:53 <dons> sclv_: what's all this??
14:33:55 <dons> directoryGroup path = groupStringTemplates <$>
14:33:55 <dons>                       (fmap <$> zip . (map dropExtension)
14:33:55 <dons>                        <*> mapM (newSTMP <$$> readFile)
14:33:55 <dons>                            =<< map (path </>) . filter ((".st" ==) . takeExtension)
14:33:56 * byorgey wonders what everyone is smoking
14:33:58 <dons>                        <$> getDirectoryContents path)
14:34:02 <dons> fmap <$> zip !??
14:34:10 <byorgey> wow =)
14:34:11 <oerjan> faxathisia: let pattern equations are always lazy.  if there are no variables on the left side they will _never_ be tested at runtime.  but it still has to type correctly.
14:34:43 <oerjan> (unless you use the ! strictness extension)
14:34:44 <matthew-_> can someone run me through why newtype Foo a = F a deriving (Monad, Show) doesn't work with the Generalized... ?
14:35:04 <matthew-_> does it need context on the a ?
14:35:36 <Baughn> @ty fmap <$> zip
14:35:41 <lambdabot> forall (f :: * -> *) a b. (Functor f) => [a] -> f [b] -> f [(a, b)]
14:35:59 <dogbite> any pointers for calling haskell code from python?
14:36:05 <faxathisia> Thats crazy
14:36:05 <dogbite> sorry to ask again...
14:36:12 <Baughn> dogbite: Why would you want to?
14:36:19 <Baughn> dogbite: Well, it's usually "via C".
14:36:20 <bos> @where missingpy
14:36:20 <lambdabot> http://quux.org:70/devel/missingpy
14:36:25 <dogbite> well i really want to use numpy
14:36:40 <dogbite> but i want to do the rest of the work in haskell
14:36:42 <Baughn> Gopher? *GOPHER*?
14:36:47 <apfelmus> dogbite: i gotta go, but the example you mentioned basically goes  haskell -> c -> python
14:36:47 <dogbite> yeah, gopher
14:37:29 <dogbite> missingpy seems to be for calling python from haskell
14:37:37 <dogbite> although i'm suspicious of the gopher server.  makes no sense!
14:37:48 <bos> @where+ missingpy http://darcs.complete.org/missingpy/
14:37:48 <lambdabot> Done.
14:38:01 <bos> that url isn't the real home of missingpy anyway. the one i just added is.
14:38:36 <dogbite> oh neat!
14:38:39 <dogbite> oh
14:38:44 <dogbite> MissingPy permits you to call Python code from Haskell.  It does NOT
14:38:44 <dogbite> permit you to call Haskell code from Python.
14:39:27 <byorgey> dogbite: if you want to use numpy and do the rest in haskell, why can't you do it by calling python from Haskell?
14:39:29 <Baughn> dogbite: But you just wanted to use numpy, right?
14:39:41 <dogbite> i'm mostly interested in numpy and scipy
14:39:44 <oerjan> matthew-_: a has the wrong kind to be a monad.  and you don't have anywhere else it could be derived from
14:40:00 <CosmicRay> heh
14:40:06 <CosmicRay> that missingpy url is a bit dated
14:40:18 <dogbite> which url is dated?  the darcs one?
14:40:28 <CosmicRay> that too
14:40:36 <dogbite> do you have the latest and greatest?
14:40:39 <CosmicRay> actually no, the darcs is still current.
14:40:41 <matthew-_> oerjan: yep, ta. worked it out
14:40:52 <oerjan> matthew-_: data Foo a b = F (a b) deriving (Monad, Show) should work iiuc
14:40:55 <dons> there's also the python binding glguy wrote for hpaste, fwiw.
14:41:04 <dons> that was to enable calling pygments for all the colouring stuff
14:41:15 <dogbite> interesting
14:41:19 <dons> btw, hackage is back up.
14:41:37 <dons> there was some heavy "DoS" coming from a  couple of sites with 30-50 concurrent connections
14:41:38 <sieni> dogbite: I remember asking about why there isn
14:41:53 <sieni> 't a similar thingie for interfacing sbcl to python libraries
14:41:59 <Baughn> dogbite: User-agent? puf, perhaps?
14:41:59 <dons> so bandwidth has been limited, and only 4 concurrent connections to anonymous http stuff is allowed now.
14:42:04 <dons> ssh to darcs.h.o is unaffected
14:42:17 <dogbite> what about user-agent?
14:42:19 <Baughn> er, *dons
14:42:22 <sieni> the answer was something along the lines: "why don't you just implement the thing for sbcl directly that you need"
14:42:35 <sieni> fortunately haskell people are more enlightened
14:42:45 <faxathisia> sieni: "The answer"?
14:43:43 <sieni> faxathisia: the answer was that not interfacing to python runtime isn't desirable, because that inhibits the development of native common lisp libraries yada yada
14:44:08 <faxathisia> sieni: I'm curious where you got this answer
14:44:19 <dons> yeah, interfacing to python is useful, since there's lots of wacky libs that just aren't feasible to reimplement
14:44:22 <dons> same with C.
14:44:27 <dons> and it encourages dual use haskell
14:44:30 <dons> lowering the risk
14:44:37 <sieni> faxathisia: probably from some random person on #lisp several years ago
14:44:52 <dons> we don't want to live in an ivory tower. that's now how you make friends
14:44:55 <dogbite> i'm with dons
14:45:10 <Syzygy-> dons: I -like- my ivory tower....
14:45:18 <lament> languages are nice when they play well together :D
14:45:19 <dons> well, Syzygy- can stay up there, hacking on math stuff
14:45:19 <nornagon> hm... how can I provide a foreign C function with a callback function pointer (void(*)(void), say) into haskell?
14:45:20 <sieni> dons: and, as I noticed several years ago, that although python sucks, it has a pretty decent c interface
14:45:41 <dons> and a huge library suite for funky specialised things we can't be bothered duplicating
14:45:57 <lament> template for sieni's comments about python: <sieni> although python sucks, it has decent [feature].
14:45:58 <sieni> I'm glad that someone has noticed the same thing
14:45:59 <dons> of course, don't trust python for mission critical things, but for funny little odd jobs, a binding is fine
14:46:17 <cjb> yeah, you wouldn't want to, like, build an entire desktop system out of it :)
14:46:27 <dogbite> i'm thinking of writing something like rrule or the emacs diary in haskell
14:46:28 <bos> sieni: the c interface to python is not very nice.
14:46:32 <faxathisia> lament, lol
14:46:34 <dogbite> basically i want to specify recurring calendar events
14:46:41 <sieni> bos: it's better than the perl one!
14:46:43 <dogbite> and be able to iterate through them
14:46:47 <dogbite> and test for membership
14:47:00 <oerjan> @where ffi
14:47:00 <bos> sieni: well, yes.  but xs is self-parody.
14:47:00 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
14:47:08 <dogbite> i'm going to take the approach of looking at the elsip code for gnu claendar
14:47:17 <dogbite> and writing it in haskell
14:47:21 <dogbite> do you think that is a good approach?
14:47:23 <sieni> bos: perhaps my judgement got clouded by the sharp contrast
14:47:55 <sieni> lament: don't worry about me, I agree that I rant too much
14:48:29 <faxathisia> sieni, sent you a pm btw (didn't want to spam to channel)
14:49:00 <hpaste>  lispy pasted "Possible bug in ghc parser?" at http://hpaste.org/6173
14:49:22 <lispy> What do you guys think of that example I pasted?
14:50:51 <oerjan> topdecl  ->  data [context =>] simpletype = constrs [deriving]
14:50:51 <oerjan> simpletype  ->  tycon tyvar1 ... tyvark  (k>=0)
14:51:30 <yaxu_> http://www.dinkla.net/fp/cglib.html # nice geometry library, newly updated for latest ghc
14:51:30 <lispy> data Foo (a :: * -> *) = Foo a, is valid
14:51:31 <lambdabot> Title: Library for Geometric Algorithms in Haskell
14:51:57 <oerjan> that's an extension to allow kind annotations...
14:51:59 <lispy> oerjan: and I'm not sure, what your example is saying.  Are you saying parens are not legal strictly speaking?
14:52:05 <oerjan> yes
14:52:18 <oerjan> that's pasted from the report
14:52:35 <Baughn> lispy: How would that work? It doesn't seem to construct a concrete type..
14:52:48 <lispy> oerjan: okay.  So it's not a bug, but it's a misfeature that can come up when using conditional compilation and explicit kinding.
14:52:59 <lispy> Baughn: I just mean the syntax is valid
14:53:43 <lispy> data Foo (a :: * -> *) = Foo (a Int) -- do you prefer this one?
14:54:43 <lispy> oerjan: I'm still tempted to report it.
14:55:44 <oerjan> if you wish :)
14:56:00 <oerjan> anyway bye
14:59:36 <nornagon> addch . fromIntegral . fromEnum $ glyph c -- converting Char to Word32 is not so fun.
15:00:51 <dmwit> Yeah, conversions in general are not so fun in Haskell. =/
15:01:13 <dmwit> On the other hand, you pretty much only have to do it once per application, so...
15:01:19 <faxathisia> hey why not just write
15:01:23 <faxathisia> cast :: a -> b
15:01:37 <faxathisia> have it in a typeclasse with lots and lots of instances
15:01:55 <nornagon> that sounds like a great[1] idea, faxathisia!
15:02:04 <faxathisia> [1]?
15:02:08 <dmwit> Hell, why write my own when I can steal one from the web?
15:02:16 <faxathisia> where?
15:02:17 <dmwit> There's a footnote!
15:02:27 <dmwit> nornagon: Flip to the end, flip to the end!
15:02:28 <Baughn> dmwit: To be written when the channel ends?
15:02:42 <dmwit> faxathisia: I was just looking it up, hold on.
15:04:33 <dmwit> http://www.mail-archive.com/haskell-cafe@haskell.org/msg30573.html
15:04:35 <lambdabot> Title: Re: [Haskell-cafe] unsafePerformIO: are we safe?, http://tinyurl.com/367h3j
15:04:55 <faxathisia> that's not what I meant
15:05:00 <dmwit> I know. =)
15:05:23 <faxathisia> nornagon: What is [1]?
15:07:05 <Baughn> There is no [1]
15:07:19 <Baughn> Seems like as nice an idea as any, really. Lots of instances.
15:07:58 <nornagon> seems like it'd be a pain to maintain
15:08:15 <nornagon> every time you want to add a castable type, you have to add an instance for every other castable type
15:08:42 <Baughn> Yeah. One problem: You might have instance cast :: a -> b and cast :: b -> c, bu want cast :: a -> c
15:08:43 <dmwit> No, you just have to add an instance for a single type-pair.
15:09:09 <tromp> we alrd have restricted casts like fromInt
15:09:17 <tromp> and show
15:09:23 <dmwit> The *real* annoying thing would be having to provide type-annotations all the time for the return type.
15:09:24 <Cheery> how do I turn a String into ByteString?
15:09:27 <Baughn> Is there any way haskell could figure out that the two casts can be composed, without actually adding an instance?
15:09:36 <dmwit> Cheery: pack
15:09:41 <Cheery> :t pack
15:09:42 <lambdabot> Not in scope: `pack'
15:09:42 <faxathisia> dmwit: Why would you need to annotate?
15:09:48 <Baughn> dmwit: Half the time, that could be infered
15:09:58 <dmwit> faxathisia: Same reason you have to annotate "read" all the time.
15:09:58 <Cheery> pack had type like [Word8] -> ByteString
15:10:15 <Baughn> Cheery: A String consists of unicode letters
15:10:23 <Cheery> dmwit: again question, how to turn [Char] -> [Word8]  ?
15:10:26 <Baughn> Cheery: They won't fit into a Word8, so how exactly do you want to encode it?
15:10:27 <Saizan> Baughn: instance Cast a b, Cast b c => Cast a c where cast = cast . cast ?
15:10:34 <dmwit> :t Data.ByteString.Char8.pack
15:10:36 <Cheery> Baughn: utf8
15:10:47 <lambdabot> String -> BSC.ByteString
15:10:59 * gwern wonders why the haskell binding to curl isn't on hackage
15:11:02 <Baughn> Saizan: If you can do that.. I thought it'd run into some problem with the type system, but I don't understand it well enough to be sure
15:11:22 <Baughn> Saizan: Couldn't haskell end up trying infinite chains of casts, that way?
15:11:23 <faxathisia> undecidable instances I think
15:11:32 <Saizan> Baughn: you'd need OverlappingInstances and UndecidableInstances
15:11:45 <dmwit> Cheery: I'm pretty sure that doesn't do encoding, though.  If you want a specific encoding, you'll have to use an encoding library.
15:11:49 <Baughn> Cheery: I believe there is an utf-8 library.. somewhere
15:12:04 <Saizan> Baughn: the worst is can happen is that the typechecker won't terminate :)
15:12:16 <Baughn> Cheery: You should get the unicode point with enumFrom (I think?), though, and utf-8 isn't very hard to write an encoder for
15:12:34 <Saizan> ?hackage utf8-string
15:12:34 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string
15:12:38 <Baughn> Saizan: It'd have to do a breadth-first search of the possibilities. "Undecidable" indeed..
15:12:39 <Saizan> ?hackage iconv
15:12:39 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/iconv
15:12:47 <dmwit> ?hackage dataenc
15:12:47 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dataenc
15:12:52 <dmwit> ?hackage encoding
15:12:52 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/encoding
15:12:57 <guenni> byorgey:ping
15:13:01 <glguy> gwern: you didn't search hard enough for it
15:13:42 <gwern> @hackage curl
15:13:42 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/curl
15:14:03 <Cheery> thank you!
15:14:16 <gwern> glguy: it wasn't there when I looked!
15:15:09 <gwern> 'Fri Feb 29 11:29:50 PST 2008' <-- pretty recent
15:15:12 <Saizan> Baughn: yeah, i guess it depends from the other instances, obviously there a maximum depth, it doesn't really get in a loop
15:15:17 <glguy> gwern: it's been there since the upload date
15:15:39 <glguy> Thu Feb 28 11:00:48 PST 2008
15:16:37 * gwern last looked before then
15:18:15 <gwern> (oh well. it's good that it's there. one less hole in hackage)
15:22:31 <raf245> i have question
15:22:52 <raf245> what is haskell
15:23:13 <raf245> any one
15:23:16 <Excedrin> is something like the following defined in Parsec somewhere?  integer = many1 digit >>= return . read
15:23:17 <cjb> http://haskell.org/
15:23:17 <lambdabot> Title: Haskell Community Server
15:23:19 <tromp> some dead bloke
15:23:23 <Axioplase> raf245: a programmng language for cool people.
15:24:01 <raf245> thanks
15:25:37 <dmwit> Excedrin: See the Language section; you can grab the "integer" tokenizer from the Haskell language definition.
15:26:07 <mauke> >>= return . better written as liftM
15:27:00 <dmwit> integer (makeTokenParser haskellStyle) -- after the proper imports, T.PtP.Token and T.P.P.Language
15:27:13 <dmwit> s/PtP/P.P/
15:27:15 <wli> Excedrin: First off, you need to do something like do x <- oneOf [chr $ k + ord '0' | k <- [0..9] ; xs <- many digit ; return $ x : xs
15:27:30 <Excedrin> dmwit: I think I'd like the type to be Parser Integer (since it's used with other Parsec stuff)
15:27:34 <wli> Excedrin: Second, you need to take a potential minus sign into account.
15:27:46 <Excedrin> nah, these are positive only
15:28:00 <dmwit> Excedrin: ...it is, isn't it?
15:28:08 <wli> Excedrin: You're certainly not lexically restricting them to such.
15:28:10 <dmwit> Excedrin: The type is "CharParser st Integer" here.
15:28:19 <Excedrin> ok
15:28:22 <wli> Excedrin: You're getting natural numbers including 0 there.
15:29:17 <Cheery> aagh, I hate the ambiguous occurrence errors
15:29:20 <dmwit> You actually may want to grab the tokenizer from a different language definition.
15:29:23 <wli> Excedrin: (Using the snippet above yields only positive integers.)
15:29:30 <dmwit> > read "-    32" -- this is why I say that
15:29:35 <lambdabot>  Exception: Prelude.read: no parse
15:29:41 <dmwit> whoop, hey?
15:29:46 <dmwit> > read "-32"
15:29:47 <lambdabot>  Exception: Prelude.read: no parse
15:29:55 <dmwit> > read "-    32" :: Integer
15:29:56 <lambdabot>  -32
15:29:58 <dmwit> =/
15:31:07 <JohnMeacham> more benchmarks: http://repetae.net/computer/jhc/results2.html
15:31:07 <lambdabot> Title: nobench: Haskell implementation shootout
15:31:16 <cjb> JohnMeacham: hey hey.  has anyone looked at making ginsu use gtk2hs?  'cause, that'd be fun.
15:32:04 <dmwit> GHC looks pretty good there.
15:32:35 <dmwit> Actually, on the ones that work correctly, jhc_grin is pretty good.
15:38:30 <dons> JohnMeacham: interesting, trying a new GC?
15:39:22 <Cheery> how to isolate names from modules?
15:39:40 <Cheery> like: import Data.ByteString as ByteString
15:40:04 <dmwit> Just like that.
15:40:08 <Cheery> and when I want to get something inside that thing, I explicitly write ByteString.xxx
15:40:09 <Spockz> @source group
15:40:10 <lambdabot> group not available
15:40:26 <mauke> import qualified Data.ByteString as BS
15:40:27 <dmwit> Cheery: If you don't want the unqualified names around, use "import qualified ..."
15:42:30 <RR> cane some one help plis i need to Write a function allVars :: IntExp -> [String] that lists the names of all integer variables (constructor IntVar) occurring in an IntExp, without duplicates.
15:44:54 <nornagon> Hm, so I'm trying to bind this C line of sight library to haskell. The LoS library takes a couple of function pointers that it calls in order to determine whether a certain cell is opaque or not, and in order to apply light to a cell. How can I pass to the library a Haskell function?
15:45:28 <RR> can some one healp plis
15:45:46 <dmwit> RR: Sounds like a homework problem...
15:45:57 <dmwit> RR: What things have you tried?
15:45:58 <RR> yap m8
15:46:20 <Zao> RR: If you want to avoid duplicates, a set may be helpful in your quest.
15:46:58 <RR> mh
15:47:26 <nornagon> RR: you're better off working out your homework problems by yourself. If you just get us to solve it, then you haven't really learned anything, have you?
15:48:01 * glguy ponders
15:48:05 <faxathisia> > nub "123546798123654987"
15:48:11 <glguy> depends if he's learning to be a manager
15:48:17 <glguy> or someone who accomplishes
15:48:19 <lambdabot>  "123546798"
15:48:32 <RR> that is right but i thought i could get some tip
15:48:57 <faxathisia> RR:: Make a list with duplicates and nub it... one route
15:50:22 <RR> i am going to try it  thanks
15:51:03 <mauke> nornagon: http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise4.html#x7-170004.1.1 "wrapper"
15:51:04 <RR> what nud dos?
15:51:06 <lambdabot> Title: 4 Specification of External Entities, http://tinyurl.com/2pdya4
15:51:19 <nornagon> mauke: is 'wrapper' a special magical function?
15:51:29 <nornagon> ah, yes, it is
15:51:34 <nornagon> thanks :)
15:51:41 <nornagon> mauke++
15:51:53 <nornagon> also, heh, that's my university :)
15:52:34 <mauke> there's an example in 4.1.3
15:52:52 <nornagon> yep, found it
15:52:52 <JohnMeacham> dons: yeah
15:53:49 <RR> what nub does?
15:54:06 <faxathisia> > nub "RR:: it removes duplicates"
15:54:10 <lambdabot>  "R: itremovsduplca"
15:54:26 <nornagon> @doc nub
15:54:26 <lambdabot> nub not available
15:54:34 <nornagon> @doc Data.List
15:54:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/4/Data-List.html
15:54:35 <dmwit> ?doc Data.List
15:54:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/4/Data-List.html
15:54:42 <nornagon> jinks
15:54:50 <mauke> 404
15:54:55 <dmwit> I'll buy you a beer next time I meet you.
15:55:10 <dmwit> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
15:55:11 <lambdabot> http://tinyurl.com/yhrw65
15:55:33 <RR> can you give me example of nub? plz
15:55:34 <JohnMeacham> dons: the boehm gc is signfigantly slower, as I'd expect since it is designed to be a generic C garbage collector, but it does allow a few programs to run that die of space exhaustion with my static analysis. So now I know what programs to look at to find bugs in my static garbage collector.
15:56:02 <dmwit> RR: We've given you several examples of nub...
15:56:32 <dmwit> RR: Check for the lines that start with "> ", they're lines of Haskell.
15:56:43 <dons> JohnMeacham: or mixed region/boehm for pathological things?
15:56:45 <dmwit> RR: lambdabot's responses show what they evaluate to.
15:56:53 <dons> JohnMeacham: going to write up this stuff for ICFP sometime? :)
15:58:58 <nornagon> hm... the callback i was talking about earlier takes a void* as an argument. Can that just be a forall a. Ptr a?
15:59:30 <RR> thanks i got it is some thing lik
15:59:31 <RR> Input: nub [0,1,2,3,2,1,0]
15:59:31 <RR> Output: [0,1,2,3]
16:00:11 <JohnMeacham> dons: I can't just submit the source code? :)
16:00:20 <mauke> nornagon: I think so
16:00:33 <mauke> the FFI doesn't say what happens on systems with different pointer types
16:01:26 <faxathisia> if you are on POSIX void * is ok for function pointers
16:02:05 <mauke> are you sure POSIX doesn't just say function pointer can be converted from/to void *?
16:02:12 <mauke> this is about calling conventions
16:02:18 <nornagon> i'm not converting a funptr to void*
16:02:28 <mauke> that too :-)
16:02:44 <nornagon> the void* is an argument to the function in question
16:05:33 <JohnMeacham> some systems have different representations for pointers to different things, like a char * might have a different representation than an int *.
16:06:25 <JohnMeacham> I think they are rare enough that you don't have to worry about them much. though, different function and data pointer formats are not entirely uncommon on embedded systems.
16:06:55 <JohnMeacham> Data.Int.IntPtr is guarenteed to be able to hold any pointer type.
16:07:40 <JohnMeacham> nornagon:  'Ptr a' is perfectly fine for a function that takes 'void *'.
16:09:27 <nornagon> JohnMeacham: yay :)
16:16:26 <hpaste>  Spockz pasted "splitAtMiddle" at http://hpaste.org/6174
16:16:40 <Spockz> Is that a smart implementation?
16:17:21 <Spockz> apart from the fact that I could build a splitAt function that additionally takes the number of the middle eleemnt
16:23:00 <hpaste>  Spockz annotated "splitAtMiddle" with "improved version" at http://hpaste.org/6174#a1
16:25:57 <dons> ?users
16:25:57 <lambdabot> Maximum users seen in #haskell: 463, currently: 421 (90.9%), active: 11 (2.6%)
16:28:23 <Spockz> dons
16:28:32 <dons> Spockz
16:28:34 <Spockz> could you verify something for me?
16:28:45 <dons> maybe
16:29:03 <hpaste>  Spockz annotated "splitAtMiddle" with "testresults" at http://hpaste.org/6174#a2
16:29:14 <Spockz> in that last link
16:29:23 <Spockz> I found something curious at the bottom
16:29:30 <Spockz> same run duration
16:29:38 <Spockz> lower mem. usage on my version
16:29:47 <dons> very small duration though, so hard to reason about it
16:29:54 <dons> the startup time is around 0.08 seconds anywa
16:30:07 <Spockz> should I test with larger lists?
16:30:13 <Draggor> Hello!  I'm interested in the Google Summer of Code, and haskell looks rather interesting.  Is there anything I should know in particular?
16:30:44 <dons> Draggor: we have a Summer of Code channel, firstly
16:30:54 <dons> and a wiki with previous and new project ideas
16:31:06 <dons>  #haskell-soc
16:31:14 <Draggor> Ah ha, I should poke at those then.  A school advisor directed me here.
16:31:19 <dons> also, you'll need to be competent in haskell :)
16:31:29 <dons> yep, its a good place to start
16:31:46 <Spockz> hm :)
16:31:48 <Draggor> Well, a friend of mine and I are tackling it, and we're both lispers, so functional programming isn't completely foreign.
16:31:52 <Spockz> it seems the ghc isn't multithreaded
16:31:55 <dons> also, you pretty much need to hang  out here before and during the SoC, since getting community support is par to the process
16:32:09 <dons> Spockz: sure it is, you're just not using threads are you
16:32:16 <Spockz> i'm not
16:32:27 <Spockz> it's taking up 1.7 gigabytes of mem now
16:32:31 <Spockz> testList = [1..100000000000]
16:32:46 <dons> might be a good idea to constrain it to :: [Int]
16:32:53 <Spockz> indeed
16:32:54 <dons> but what's the large list size got to do with threads?
16:32:56 <Spockz> now it crashed :p
16:33:03 <Spockz> nothing
16:33:13 <Spockz> but I wondered about why it was so slow ;)
16:33:15 <dons> well, 1..100000000000 is a big list
16:33:23 <Spockz> of course it is :)
16:34:22 <Spockz> somehow I think a part of the processor time is used for printing to the ghci
16:34:34 <dons> yep. much of it, likely
16:34:47 <Spockz> shame :(
16:34:55 <Spockz> is there someway to mute it?
16:35:08 <dons> yeah
16:35:23 <dons> :set -fno-print-bind-contents
16:35:36 <dons> or compile the code, if you care about performance
16:35:48 <Spockz> I don't actually
16:35:49 <dons> since its kind of silly to benchmark interpreted code
16:35:51 <Spockz> it's just for fun
16:36:38 <Spockz> (27.14 secs, 1988056808 bytes)
16:36:56 <Spockz> that's builtin
16:37:18 <gnuvince_> Is there a function that times another function?
16:37:29 <Spockz> wow, and my function writes them 1 a second now :D
16:38:26 <Spockz> however
16:38:31 <Spockz> i'm going to sleep now
16:38:32 <Spockz> :w
16:43:09 <christos> hi, i m using haskell mode for emacs and I think my indentation is really wrong.. anyone facing the same problem
16:43:10 <christos> ?
16:43:36 <mauke> no, I'm free of emacs
16:47:55 <gwern> 'Apparently true: at one point Perl 6 used  U+00A5 YEN SIGN as a zip operator, for the excellent reason that this particular symbol looks like a zip. ' <-- we need this
16:48:08 <gwern> christos: haskell-mode is known to have not particularly intelligent indentation
16:48:18 <mauke> what,  isn't zip anymore?
16:48:30 <gwern> usually people keep hitting tab until it finally lines up in the semantically right position
16:48:42 <gwern> (to be fair, haskell is vastlymore hard to parse than say a lisp)
16:48:52 <gwern> http://wordaligned.org/articles/a-yen-for-more-symbols  'Sadly this witty visual pun seems to have been deprecated. All programming languages I know of are firmly stuck in the 7-bit ASCII range, where the only currency character is the good old American $ 0x24 DOLLAR SIGN. '
16:48:53 <lambdabot> Title: A yen for more symbols
16:49:05 <Cale> christos: sometimes you have to hit tab multiple times to get the indentation you're looking for, and others, it won't indent the right amount until you've typed the first keyword on the line
16:49:05 <shag> @pl  (\d r -> snd (insertDoc r d))
16:49:05 <lambdabot> (snd .) . flip insertDoc
16:49:27 <dcoutts_> dons: pong
16:49:30 <Cale> christos: Personally, I usually just put it in simple indent mode, which is much saner.
16:49:53 <lament> heh
16:50:06 <dons> dcoutts_: oh, do you know what the command to create a new project on c.h.o is?
16:50:09 <dcoutts_> @tell ndm cabal upload is supposed to work, I use it. Is it not being nice to you?
16:50:09 <lambdabot> Consider it noted.
16:50:31 <gwern> 'For a start, all/many of the key terms could be one kanji long. Maybe even whole programs. Kanji for related procedures (eg different types of sorting) could share radical strokes.' <-- I think this poster just reinvented APL
16:50:35 <dcoutts_> dons: yes, you file a ticket and an admin makes one
16:50:54 <dcoutts_> http://community.haskell.org/admin/project_request.html
16:50:55 <lambdabot> Title: Project Request
16:51:34 <BMeph> Hmm, wasn't someone complaining a few days ago about all of the "crazy" symbols that people put in their papers, when writing about math (and Haskell) topics? ;)
16:51:42 <dcoutts_> dons: or are you asking what script the admin uses to actually create a new project?
16:51:55 <nornagon> hm, can ghc do hsc2hs stuff automagically? I'm confused as to how ghc manages to build hsc files in other projects...
16:52:01 <nornagon> unless cabal does it?
16:52:06 <christos> Cale: thanks for the info, the multiple tab to get it is helpful, i will probably end up using the simple indent mode i guess
16:52:13 <gwern> I think cabal does it as part of preprocessing
16:52:35 * edwinb spots an ndm talking to him
16:52:35 <lambdabot> edwinb: You have 1 new message. '/msg lambdabot @messages' to read it.
16:52:40 <gwern> nornagon: of course, there are flags to pass GHC and suchlike, but you'd need to either watch cabal carefully or dig up old makefiles
16:52:55 <dcoutts_> nornagon: cabal does preprocessing for several common preprocessors, like hsc2hs, c2hs, alex, happy and a couple others
16:53:02 <nornagon> ah, okay.
16:53:48 <nornagon> i guess i should cabal up this stuff then, but it's really annoying to have to install a dev library every time you make a change
16:54:12 <radetsky> how do I link from a library built with cabal that I haven't installed?
16:54:47 <dcoutts_> radetsky: that's not directly supported yet
16:55:03 <lament> gwern: that blogger doesn't like fixed bikes :(
16:55:04 <radetsky> crap
16:55:13 <dons> dcoutts_: the latter, i want to just run the script (as i do already for adding project members)
16:55:15 <dcoutts_> radetsky: but you can do it by making a new package file, registering the lib in it and then telling cabal to use that package db
16:55:29 <dons> dcoutts_: useful to have someone with a US timezone who can do this :)
16:55:32 <dcoutts_> dons: do you have sudo access on the server?
16:55:36 <dons> yep
16:55:40 <dcoutts_> great
16:55:47 <dcoutts_> dons: the scripts are all in...
16:55:51 * dcoutts_ finds the dir
16:56:19 <dcoutts_> dons: /home/admin/web/admin
16:56:24 <dons> cheers
16:56:36 <dcoutts_> dons: create_project.sh
16:56:58 <dcoutts_> dons: run it with no args first for usage, then again with sudo and the appropriate args
16:57:06 <dons> excellent
16:57:21 <dcoutts_> dons: it might be an idea to make a RT ticket just for record keeping purposes
16:57:41 <dcoutts_> dons: you've got an RT account too I presume
16:57:53 <dons> yeah, but of unknown password
16:58:08 <dcoutts_> dons: you file one normally, I'll close it :-)
16:58:13 <dons> ok
16:58:29 <dcoutts_> dons: what's the new project?
16:58:38 <dons> graphmod.
16:58:55 <dons> project created. diatchki's module dependency grapher
16:58:57 <shag> even if i may show all my ignroance, but is there something like the Data.Foldable interface for the map function?
16:59:08 <Cale> shag: Functor
16:59:13 <Cale> shag: fmap
16:59:14 <dcoutts_> radetsky: btw, you'll need the development version of cabal, only it supports using arbitrary package dbs
16:59:15 <Cale> :t fmap
16:59:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:59:42 <dcoutts_> dons: sounds interesting, what does it use? ghc api?
16:59:56 <radetsky> thanks
17:00:06 <dons> dcoutts_: no, just analyses the import list itself
17:00:18 <dons> you can close the ticket now.
17:00:19 <radix> shapr's mage thing doesn't work with modern ghc. :(
17:00:41 <dcoutts_> dons: we'll need something like that in cabal for dependency chasing. So it lexes the .hs files directly itself then?
17:00:42 <shag> Cale: Ah, thanks. The name isn't that obvious as it is for fold :)
17:00:54 <dons> dcoutts_: yeah
17:01:06 <dons> the darcs repo will be up soon
17:01:12 <dons> you can have a poke around
17:01:21 <dcoutts_> dons: bsd3 hopefully so we can steal code for cabal :-)
17:01:40 <dons> yeah, definitely. galois default is bsd3
17:02:16 <dons> btw simonM is here on tuesday, so if you've ideas for things bytestring/fusion related we could have him look at ..
17:02:25 <dons> also, did you see the spec constr improvement patch today?
17:03:09 <dcoutts_> dons: not yet
17:03:47 <dcoutts_> dons: I can't think of anything immediate to look at for Simon, I'll keep it in mind
17:04:28 <dons> dcoutts_: i was thinking about branch prediction annotations
17:04:36 <dons> would be a good thing to do with some simonmar help
17:04:39 <dcoutts_> dons: ah yes
17:04:53 <dons> and other code gen magics
17:05:04 <dcoutts_> dons: and using hpc to do feedback to improve branch prediction
17:05:23 <dcoutts_> an internal plumbing for branch prediction info
17:05:36 <dcoutts_> coming from static predictions, annotations and hpc feedback
17:05:46 <dcoutts_> annotations/pragmas
17:06:32 <dcoutts_> dons: and did you hear that one of Norman Ramsey's PhD students is going to be hacking on ghc code gen for 6 months, starting next month!
17:07:40 <dons> dcoutts_: whoa!
17:07:41 <dcoutts_> he finished his PhD with Norman so must know a thing or two about code gen
17:07:46 <dons> that's blog worthy.
17:07:59 <dcoutts_> dons: get more details from SPJ
17:08:06 <dons> dcoutts_: yeah, andy gill is keen to have hpc used for htis
17:08:10 <dons> and he'll be here too
17:08:15 <dcoutts_> dons: sounds ideal :-)
17:08:43 <dons> yeah, i'd love to have nr's C-- code gen slaves work on ghc for 6 months..
17:09:04 <dcoutts_> dons: there's probably quite a bit one can glean from a simple static analysis too, eg we expect loops/recursive calls to be taken, branches to error not to be taken etc
17:09:27 <dons> dcoutts_: btw, cabal request. if you run cabal and there's no .cabal file, cabal should emit the error: "Error: there is no .cabal"
17:09:39 <dons> :)
17:09:52 <dcoutts_> dons: hmm, that applies to configure etc, not to install, at least not if you supply args
17:10:22 <dons> its just important that we work in the "there is no cabal" slogan where appropriate
17:10:27 <dcoutts_> dons: or you just mean changing the error message
17:10:29 <dcoutts_> cabal: Error Parsing: file ".cabal" doesn't exist. Cannot continue.
17:10:49 <dcoutts_> dons: haha hah I see
17:10:59 <dons> right, it should make the joke: "cabal: Error: there is no .cabal!"
17:11:12 <dons> or possibly, "ssh! there is no .cabal"
17:11:22 <dcoutts_> send a patch :-)
17:11:32 <dcoutts_> dons: and we need one up on the apt-get cow
17:11:36 <dons> actually, "there is no cabal" would make a good slogan for the hackathon tshirts
17:11:45 <dcoutts_> dons: heh, indeed
17:12:29 <dcoutts_> we need a cabal easter egg in time for easter
17:15:53 <dcoutts_> dons: btw, any progress on the cabal hacking? what issues are you looking at first? I'd especially recommend the design of the darcs/git/any-scm fields in .cabal files since you know the requirements pretty well
17:16:00 <gnuvince_> woot!
17:16:02 <gnuvince_> quickcheck++
17:16:10 <dcoutts_> gnuvince_: :-)
17:16:20 <gnuvince_> It's teaching me things I didn't know about cribbage
17:18:06 <Cale> shag: Yeah, it used to just be map
17:18:19 <dons> dcoutts_: yeah, we got swamped with deadlines in feb, but will have time this month. that's one of the goals
17:18:28 <Cale> shag: It's really unfortunate what happened to the Prelude going from Haskell 1.4 to '98.
17:18:33 <dons> gnuvince_: hehe, cool. you've got cribbage properties?
17:18:33 <dcoutts_> dons: cool
17:18:50 <gnuvince_> dons: starting to accumulate them.
17:19:15 <gnuvince_> dons: For instance, a cribbage hand can only score between 0 and 29, and 19, 25, 26 and 27 are impossible
17:19:26 <gnuvince_> I thought 23 was too, but quickCheck proved otherwise :)
17:19:32 <dons> gnuvince_: would be an interesting thing to write about: the experience of how type-based property testing made you think
17:20:05 <gnuvince_> dons: so that you can post it on reddit and get a bunch of karma points? :-D
17:20:16 <dons> oh, i don't care who gets the karma :)
17:20:18 <gnuvince_> But yes, I intend to blog about the experience.
17:20:31 <dons> just as long as wes have more material for encouraging the use of quickcheck
17:20:44 <dons> oh, while you're running the testsuite, you should try doing the same with -fhpc enabled
17:20:46 <Cale> Our quickcheck ought to adopt the same cool features of the Erlang one.
17:20:56 <dons> Cale, yes, see QC2-- it has shrinking!
17:20:57 <gnuvince_> dons: what is -fhpc?
17:21:05 <Cale> Ah, cool :)
17:21:20 <dons> gnuvince_: its the code coverage tool. it shows what code paths were run during some execution
17:21:31 <gnuvince_> ok
17:21:34 <dons> so when combined wth QuickCheck, tells you how much of your code was tested
17:21:38 <cschneid> I think I want Data.Map, but I'm not sure of the details.  I want (key, [values]), where every time I add a value, it appends to the values list.  Is there a way of doing that easily?
17:21:48 <gnuvince_> Very nice.
17:21:49 <dons> its  super easy to use, i use it by default with QC now
17:21:53 <Cale> cschneid: Yeah, that's easy with Data.Map
17:22:05 <gnuvince_> dons: does it report on stdout?
17:22:07 <dons> gnuvince_: here's the output, http://code.haskell.org/~dons/tests/pcre-light/hpc_index.html
17:22:07 <mauke> cschneid: yes, but appending to lists isn't exactly fast
17:22:15 <Cale> cschneid: But adding to the end of a list costs O(n), so you should watch out.
17:22:19 <radix> wooow, Shu-thing is really cool.
17:22:28 <dons> gnuvince_: it writes to a .tix file after the run, then you use: hpc report Foo to show the result, and hpc markup Foo to get html files
17:22:33 <mauke> M.insertWith (++) key [value]
17:22:40 <cschneid> Cale: beginning is good too.  Do I have to do a Map lookup, prepend my item, and then an insert?
17:22:43 <cschneid> mauke: or that :)
17:22:45 <gnuvince_> dons: gotcha.
17:22:50 <gnuvince_> dons: thanks for the tip.
17:23:01 <gnuvince_> (N.B. that ought to be in RWH)
17:23:03 <dons> gnuvince_: so it gives you confidence you're testing code, and also encourages to test for "can't happen" scenarios
17:23:08 <dons> gnuvince_: it is :)
17:23:56 <tromp> > :t insertWith
17:23:56 <lambdabot>   parse error on input `:'
17:24:11 <dons> i'm not sure who else is using hpc, but i'd love to see hackage in a few months filter on hpc coverage stats
17:24:20 <dons> so you could get combined coverage/testing QA metrics
17:24:58 <Cale> :t insertWith
17:25:01 <lambdabot> Not in scope: `insertWith'
17:25:05 <Cale> :t Data.Map.insertWith
17:25:11 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> M.Map k a -> M.Map k a
17:26:36 <Cale> Interestingly, this is one case where ([x]++) is more likely to work than (x:) ;)
17:27:05 <tromp> ([x]++) is (x:)
17:27:18 <tromp> what's diff?
17:27:28 <Cale> tromp: Well, really, you're going to split it up.
17:27:43 <Cale> insertWith (++) k [x]
17:27:58 <Cale> since  insertWith (:) k x  is badly typed
17:28:52 <Saizan> dons: i'm interested in including that and other cabal-related things in a SoC proposal, btw, how the discussion on using a haskell webframework instead of CGI has gone?
17:29:00 <tromp> right; you don't have ([x]++) together
17:29:30 <dons> Saizan: fastcgi is where its at, I think, but we're not sure what we'll need more than a bit of a db binding
17:30:21 <Cale> It might be nice to have an  insertWithDefault :: (Ord k) => (a -> b -> b) -> b -> k -> a -> Map k b -> Map k b
17:30:38 <lQg_> is there a function that sorts a list in reverse order?
17:30:48 <Cale> lQg_: sortBy (flip comparing)
17:30:55 <mauke> reverse . sort
17:31:04 <mauke> :t flip comparing
17:31:08 <lambdabot> forall b a. (Ord a) => b -> (b -> a) -> b -> Ordering
17:31:12 <tromp> fortunately, it combines with (f new_value old_value), so the (++) is pretty effiocient
17:31:13 <dcoutts_> Cale's is almost certainly quicker
17:31:20 <Cale> er
17:31:20 <mauke> dcoutts_: no, it's not well typed :-)
17:31:23 <Cale> flip compare
17:31:27 <lQg_> so if the list was called jsList  what would command be?
17:31:31 <FunctorSalad> is System.Process lightweight enough for making calls in a time-critical loop?
17:31:34 <Cale> :t sortBy (flip compare)
17:31:34 <dcoutts_> mauke: heh heh
17:31:35 <lambdabot> forall a. (Ord a) => [a] -> [a]
17:31:48 <Cale> > sortBy (flip compare) [5,2,6,1,7,1]
17:31:50 <lambdabot>  [7,6,5,2,1,1]
17:31:50 * wli tries to remember how the various FP priority queues work.
17:32:08 <lQg_> er no not like taht
17:32:18 <lQg_> just the order to be switched
17:32:20 <lQg_> [String]
17:32:25 <Cale> Huh?
17:32:31 <Cale> You mean you want to reverse the list?
17:32:36 <lQg_> yew
17:32:37 <radix> I think 'reverse'reverse is all lQg_ wants...
17:32:38 <Cale> > reverse [5,2,6,1,7,1]
17:32:39 <lambdabot>  [1,7,1,6,2,5]
17:32:44 <radix> err. weird typo
17:32:45 <lQg_> cool
17:37:14 <Cale> Man, shu-thing is hard.
17:38:18 <radix> Cale: yeah, have you beaten the teapot?
17:38:51 <Cale> Just started playing, haven't yet made it there.
17:49:14 <Saizan> nice, running it killed my X, unstable has become too unstable for my tastes
17:50:42 <radix> what, shu-thing? sucky. it was the only game I found on the list in the haskell.org page that actually ran well on my computer :)
17:50:57 <radix> "frag" was close to being super impressive, but there was tons of graphics corruption.
17:51:46 <SamB> I don't think I have a good enough graphics card to run any of those games
17:51:59 <radix> SamB: you'd be hard-pressed to not be able to run shu-thing.
17:52:12 <SamB> oh. does it use curses then?
17:52:23 <radix> SamB: no, opengl, but only wireframes.
17:52:29 <SamB> ah.
17:52:32 <radix> you could probably run it in software rendering mode pretty easily
17:52:45 <SamB> yes ;-)
17:52:59 <gnuvince_> Could anyone tell me what I need to modify in quickCheck (the script) to make it work with runghc?
17:53:04 <radix> even frag would probably run on a TNT2, at least as far as the complexity of graphics goes
17:53:21 <SamB> no shaders?
18:01:55 * Cale makes it possible to shoot out the enemy bullets.
18:02:39 <dcoutts_> arg! ghc-pkg is sooo slooo
18:03:44 <Saizan> the 'w' has yet to come because of slowness? :)
18:03:56 <dcoutts_> $ time ghc-pkg list > /dev/null
18:03:56 <dcoutts_> real    0m5.770s
18:04:00 <dcoutts_> Saizan: yeah :-)
18:04:35 <dcoutts_> and cabal configure has to call ghc and ghc-pkg a couple times so it really adds up
18:04:44 <Cale> Heh, the teapot is still insanely hard.
18:05:08 <faxathisia> what teapot ?
18:05:16 <Cale> faxathisia: The last boss.
18:08:01 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6175
18:08:19 <FunctorSalad> sorry, that was me :)
18:08:51 <FunctorSalad> would someone know which part of that program is slowing it down so much?
18:09:29 <FunctorSalad> (doesn't terminate after minutes. 10^6 calls should be doable faster, no?)
18:09:48 <sm> Cale: whatcha playing ?
18:09:48 <lambdabot> sm: You have 1 new message. '/msg lambdabot @messages' to read it.
18:10:54 <Cale> sm: shu-thing
18:11:07 <Cale> @where shu-thing
18:11:07 <lambdabot> I know nothing about shu-thing.
18:11:13 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Shu-thing-1.1
18:11:18 <lambdabot> http://tinyurl.com/37hl8v
18:11:44 <mauke> FunctorSalad: random idea: does replicateM_ make any difference?
18:12:38 <Saizan> dcoutts_: regarding cabal, seen the msg about my mail with the new patches? it got stuck in moderation again
18:12:54 <sm> ah, it's great fun eh
18:13:10 <sm> I'm impressed you're at the end, I thought it was unfinishable :)
18:13:22 <Excedrin> aren't there two levels?
18:13:39 <dcoutts_> Saizan: I'll fish it out of limbo^H^H^Hmoderation...
18:14:56 <Saizan> thanks :)
18:15:23 <Cale> Well, I don't know if there's anything after the teapot. I made it a bit easier by giving the player the ability to clear enemy bullets by shooting them out.
18:15:38 <dons> happy 1st birthday xmonad!
18:15:51 <dons> Tue Mar  6 17:35:27 PST 2007  Spencer Janssen <sjanssen@cse.unl.edu> * Initial import
18:15:57 <Excedrin> I've never beaten the teapot, but it didn't seem that tough to get there without cheating
18:15:59 <Cale> Actually, it would be even more awesome if the controls were mouse to aim the stream of fire, and keyboard to move.
18:16:26 <FunctorSalad> mauke: apparently not, unless I'm doing something wrong at this late hour ;)
18:16:52 <FunctorSalad> oh wait, I did do it wrong
18:16:58 <sm> aha
18:17:18 <Cale> I might see if I can implement that.
18:17:45 <Cale> I've never really done anything with OpenGL before.
18:18:01 <sclv_> dons: missed yr message. yeah. the code for that is broken atm (always looks in the program path). i have a patch but haven't pushed it to hackage yet. also probably a bit over-obfuscated because i got excited about using applicative and code golfing.
18:18:17 <sm> opengl & hopengl seem pretty nice
18:18:43 <sclv_> anyway, gotta run. cheers.
18:19:58 <FunctorSalad> mauke: yeah, slightly faster
18:20:20 <FunctorSalad> what was the difference again? replicateM_ is eager?
18:20:47 <Cale> The _ variants don't return a list of the results.
18:20:50 <mauke> replicateM_ doesn't build a list of return values
18:21:04 <FunctorSalad> oh, ok :)
18:21:59 <FunctorSalad> well I guess I should first read up on the basics of ghc optimization
18:22:33 <Saizan> FunctorSalad: you compile with -O or -O2, right?
18:22:34 <shepheb> xmonad clearly derives Functor, Monad, MonadState etc. for the X monad. when I try to do it, I get "Functor/Monad/MonadState is not a derivable class". I assume this has to do with mtl, is there a way to specify it?
18:22:41 <FunctorSalad> Saizan: -O
18:22:47 <mauke> shepheb: it's an extension
18:23:12 <FunctorSalad> and I should also try it in C, maybe running processes simply takes that long on my system :)
18:23:21 <Saizan> shepheb: you need the NewtypeDeriving extension
18:23:28 <FunctorSalad> (1.35s for 1000 iterations)
18:23:32 <mauke> shepheb: GeneralizedNewtypeDeriving
18:23:52 <shepheb> mauke, Saizan: ah, thank you.
18:33:47 <halmos> Hey, I'm new to haskell and I was wondering if anyone had any advice on what to do after working through "Programming in Haskell" by Hutton
18:34:29 <Cale> halmos: Hmm, good question, I'm not 100% sure what's covered in that book.
18:34:41 <shepheb> 1) Hang out in #haskell. 2) ??? 3) Attain demigod status. :)
18:34:43 <Cale> halmos: Is there anything in particular which you'd like to know more about?
18:37:39 <shepheb> halmos: a common value of 2) is "find a project to hack on"
18:37:56 <halmos> I'm kind of curious on how to scale up to actually writing programs that do things in haskell after doing lots of short excercises
18:37:56 <halmos> hmm
18:38:06 <shepheb> halmos: whether it's your own or an existing one.
18:38:41 <SamB> what sort of program are you fascinated by?
18:39:03 <cjb> halmos: the gtk2hs examples are concise and easy to follow
18:39:08 <cjb> so that might be a good place to go next
18:39:25 <halmos> hmm, I'll add gtk2hs to my list
18:39:42 <Cale> halmos: Probably the only serious difference between large scale programs and small scale ones in Haskell is the use of the module system, and possibly leaning on typeclasses a little harder. Other than that, it's pretty much the same, only bigger :)
18:39:52 <whee> has anyone seen this when building lambdabot? http://hpaste.org/6176
18:39:52 <halmos> I think peer to peer software sounds pretty cool
18:39:57 <cjb> halmos: e.g. http://darcs.haskell.org/gtk2hs/docs/tutorial/Tutorial_Port/chap4-1.xhtml
18:39:59 <lambdabot> http://tinyurl.com/25vzfg
18:40:06 <SamB> halmos: well, conjure could use some love
18:40:34 <Cale> whee: could you give us the output of   ghc-pkg list bytestring  ?
18:40:59 <whee> Cale: /usr/local/lib/ghc-6.8.2/package.conf: bytestring-0.9.0.1; /home/whee/.ghc/x86_64-freebsd-6.8.2/package.conf: bytestring-0.9.0.4
18:41:06 <Cale> whee: ah, okay
18:41:14 <Cale> whee: Somehow I expected this ;)
18:41:17 <Saizan> whee: that happens when you're using two packages that were built against different versions of bytestring
18:41:45 <Cale> whee: The problem is that things are getting built against two different, and slightly incompatible versions of the bytestring package.
18:42:24 <Cale> whee: My recommendation is just to stick with 0.9.0.1 for now unless you really need 0.9.0.4 for some reason.
18:42:25 <whee> Cale: I build zlib, then cabal and cabal-install, and then had cabal update things
18:42:30 <whee> think it would be zlib?
18:42:50 <Cale> Yeah, that seems likely, given the 'compress'
18:42:52 <faxathisia> @src callCC
18:42:52 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
18:43:57 <halmos> SamB: do you think conjure is something I could begin to understand if I just downloaded the sources? I'm actually new to programming in general
18:43:57 <whee> yep, zlib was it. Thanks
18:44:12 <SamB> halmos: hmm, perhaps not
18:44:35 <SamB> halmos: what have you done so far?
18:45:42 <halmos> SamB: I've done nearly all the exercises in "Programming in Haskell" by Hutton and a majority of the one exercises in "The Haskell School of Expression"
18:46:21 <halmos> but Haskell is the first programming language I'm really trying to learn, other than some experience with BASIC I have from earlier days
18:46:25 <SamB> have you written any compilers yet?
18:46:40 <halmos> nope
18:46:49 <SamB> hmm. maybe you should go learn some other languages first...
18:46:52 <halmos> I did a bit of the Scheme in 48 Hours tutorial
18:47:08 <SamB> ah, more of that would probably be a good idea ;-)
18:47:25 <faxathisia> you should certainly learn other languages but not necessarily first
18:47:38 <SamB> faxathisia: I meant, before trying to write compilers
18:47:44 * shepheb wonders how hard to grasp C's style would be for someone completely "raised" on Haskell.
18:47:44 <joed> Heh or Sams learn Java in 21 minutes. I don't see why you could not start with Haskell?
18:47:56 <faxathisia> oh right
18:48:01 <SamB> it makes little sense to write compilers when you know but one language
18:48:11 <joed> Oh, SamB sorry, yes.
18:48:39 <faxathisia> Bruce Eckel has a good book on Java that is free online
18:49:02 <Cale> halmos: Related to the mathematician? :)
18:49:06 <joed> tij edition 3 - 4 is not free. I'm not sure it is fantastic in all senses, but yes a good read.
18:49:24 <halmos> Cale: heh, a fan of the mathematician
18:49:34 <halmos> Cale: I'm studying to be a mathematical physicist
18:49:40 <Cale> ah, cool
18:49:43 <halmos> Cale: but I want to learn to do more useful things
18:50:10 <Cale> Hehe, my background (and likely future) is in pure mathematics.
18:50:43 <halmos> what type of pure math do you like?
18:50:47 <SamB> halmos: you mean like writing version control systems?
18:51:45 <Cale> halmos: Algebraic combinatorics, or more generally, something algebraic mixed with something else (algebraic topology, algebraic geometry).
18:53:02 <joed> Oil survey?
18:53:12 <halmos> Cale: ahh, that stuff is pretty cool, I was thinking of doing algebraic topology before I got sucked into analysis
18:53:40 <FunctorSalad> you can also mix algebra with analysis in functional analysis / operator theory :)
18:53:59 <halmos> Cale: that's true, functional analysis is pretty awesome, along with C-star algebras
18:54:10 <halmos> err remove the "Cale:"
18:54:14 <FunctorSalad> :)
18:54:14 <whee> oh dear, now I broke cabal somehow :) "cabal: Error Parsing: file ".cabal" doesn't exist. Cannot continue"
18:54:33 <faxathisia> what is algebra?
18:55:04 <FunctorSalad> I don't know a good definition
18:55:04 <Cale> For some reason, I didn't quite get drawn in by functional analysis quite as much. Picturing the differences between infinite dimensional spaces is a little hard for me ;)
18:55:20 <FunctorSalad> *g*
18:58:42 <Saizan> SamB: how usable is conjure right now?
18:59:04 <SamB> last I heard it was slightly bitrotted?
18:59:45 <Saizan> is this the main repo? http://darcs.haskell.org/~lemmih/conjure/
18:59:47 <lambdabot> Title: Index of /~lemmih/conjure
19:00:18 <aFlag> Hello, my question is not haskell related, but I figure many of you may know the answer; since many of you are probably involved in the academic life. How does article submition work for the main conferences in computer science? Can anyone submit an article for aproval or does one have to be afiliated with some university or have papers aproved in smaller conferences first?
19:00:19 <halmos> thinking about infinite dimensional spaces can be sort of tricky but all the proofs I've seen in functional analysis are really slick, way more slick than most real analysis proofs I see
19:00:58 <faxathisia> was very nice to see a proof that 2 exists :D
19:01:58 <alvarezp> Hello, please don't throw tomatoes at me, as I have barely started learning Haskell. -- I was wondering if it was possible to ask Haskell to define an array of four digits using numbers 1..4 in which the first two elements sum up 5 and the other two also sum up 5.
19:02:24 <mauke> lists would be easier
19:02:30 <faxathisia> [1,4,2,3]
19:02:44 <Cale> > [[x,y,z,w] | x <- [1..4], y <- [1..4], z <- [1..4], w <- [1..4], x + y == 5, z + w == 5]
19:02:47 <lambdabot>  [[1,4,1,4],[1,4,2,3],[1,4,3,2],[1,4,4,1],[2,3,1,4],[2,3,2,3],[2,3,3,2],[2,3,...
19:02:53 <alvarezp> faxathisia, hey, you're around here!
19:02:57 <faxathisia> :P
19:03:00 <alvarezp> ohub, I forgot, without repeating.
19:03:22 <Cale> > [[x,y,z,w] | x <- [1..4], y <- [1..4] \\ [x], z <- [1..4] \\ [x,y], w <- [1..4] \\ [x,y,z], x + y == 5, z + w == 5]
19:03:23 <lambdabot>  [[1,4,2,3],[1,4,3,2],[2,3,1,4],[2,3,4,1],[3,2,1,4],[3,2,4,1],[4,1,2,3],[4,1,...
19:03:42 <alvarezp> Cale, exactly!
19:03:44 <mauke> I have a monad for that
19:03:46 <Cale> Really, you probably want to write a permutations function first :)
19:04:09 <Cale> then you could just filter the list of permutations
19:04:10 <faxathisia> or select
19:04:18 <Cale> Or select, yes.
19:04:25 <faxathisia> which is basically what is unfolded thiere
19:04:31 <alvarezp> Oh my god! This is amazing!
19:04:39 <Cale> Both things which ought to be in the list library, but are not.
19:04:47 <gwern> @where conjure
19:04:47 <lambdabot> http://darcs.haskell.org/~lemmih/conjure/
19:04:55 <alvarezp> It's like telling a computer to do a human-solving-like problem and having Haskell solving it.
19:05:00 <Cale> :)
19:05:27 <mauke> *Permu> evalPermu (do x <- draw; y <- draw; guard $ x + y == 5; z <- draw; w <- draw; guard $ z + w == 5; return [x,y,z,w]) [1 .. 4]
19:05:28 <faxathisia> alvarezp: It's quite declarative.. lists are very like a simple Prolog
19:05:30 <mauke> [[1,4,2,3],[1,4,3,2],[2,3,1,4],[2,3,4,1],[3,2,1,4],[3,2,4,1],[4,1,2,3],[4,1,3,2]]
19:05:37 <alvarezp> I guess I should go read a LOT now.
19:05:38 <gwern> alvarezp: your effusions are music to our ears
19:06:47 <pjd> > [[x,5-x,y,5-x] | x <- [1..4], y <- [1..4]]
19:06:47 * SamB tosses alvarezp a delicious tomatoe
19:06:55 <lambdabot>  [[1,4,1,4],[1,4,2,4],[1,4,3,4],[1,4,4,4],[2,3,1,3],[2,3,2,3],[2,3,3,3],[2,3,...
19:07:02 <pjd> :P
19:07:13 <pjd> err
19:07:23 <pjd> > [[x,5-x,y,5-y] | x <- [1..4], y <- [1..4]]
19:07:26 <lambdabot>  [[1,4,1,4],[1,4,2,3],[1,4,3,2],[1,4,4,1],[2,3,1,4],[2,3,2,3],[2,3,3,2],[2,3,...
19:08:19 <Cale> alvarezp: But feel free to ask lots of questions here.
19:08:34 <Cale> alvarezp: This is a very beginner-friendly channel :)
19:08:39 <alvarezp> I really appreciate it. If I may tell a story?
19:08:42 <faxathisia> alvarezp: %% R = [X,Y,Z,W], [1,2,3,4] = L0, select(X, L0, L1), select(Y, L1, L2), select(Z, L2, L3), select(W, L3, []), 5 is X+Y, 5 is Z+W.
19:08:45 <Cale> Sure.
19:08:52 * SamB attempts to steal alvarezp's questions
19:09:00 <gwern> only if it is witty and not jejune
19:09:07 * alvarezp feels like it will have lots of fun in here.
19:09:27 <gwern> and it'd better not include any stale fin-de-siecle geek injokes
19:09:30 <SamB> alvarezp: you are an artificial life form?
19:09:37 <alvarezp> LOL! No...
19:09:52 <SamB> drat!
19:09:59 <gwern> SamB: no, it's just neuter
19:10:25 <mauke> A.L.V.A.R.E.Z.P.: Artificial Lifeform Viable for Assassination, Rational Exploration and Zealous Peacekeeping
19:10:30 <SamB> neuter? as in eunichs?
19:10:43 <dolio> Unix?
19:10:48 <gwern> SamB: I don't think so. neuter implies lack of gender, not lack of fertility
19:10:48 <alvarezp> Some years ago I tried to program a calculator for school classes. As in "teacher X is available Mon-Thu 9-12; teacher Y is..." + "Math 1 is 5 hours a week, biology is 2 hours/week" + We have 10 classrooms.....
19:10:49 <gwern> I think
19:10:50 <pjd> Zealous Peacekeeping?
19:10:57 <pjd> sounds exciting
19:11:14 <gwern> ie old men are eunuchized by degeneration but they aren't neuter - they are still male
19:11:14 <SamB> gwern: well, that's what they call it when you do that to CATs...
19:11:27 <gwern> @wn neuter
19:11:27 <lambdabot> *** "neuter" wn "WordNet (r) 2.0"
19:11:27 <lambdabot> neuter
19:11:27 <lambdabot>      adj 1: of grammatical gender; "`it' is the third-person singular
19:11:27 <lambdabot>             neuter pronoun" [ant: {masculine}, {feminine}]
19:11:27 <lambdabot>      2: having no or imperfectly developed or nonfunctional sex
19:11:29 <lambdabot> [5 @more lines]
19:11:43 <gwern> @wn eunuch
19:11:43 <lambdabot> *** "eunuch" wn "WordNet (r) 2.0"
19:11:43 <lambdabot> eunuch
19:11:43 <lambdabot>      n : a man who has been castrated and is incapable of
19:11:43 <lambdabot>          reproduction; "eunuchs guarded the harem" [syn: {castrate}]
19:11:46 <alvarezp> ... and I intended to program (using C) a calculator that creates the schedule for the school teachers, students, etc. I'm intending to take the challenge again, but this time I'd like to take a more "formal" approach.
19:12:01 <lispy> GNU is not eunuchs!
19:12:12 <alvarezp> I guess Haskell will allow me to do the formal analysis and definitions.
19:12:15 <gwern> ok, so alvarezp could be neuter but not an eunuch if alvarezp were female and missing stuff like the clitoris or vagina
19:12:17 <alvarezp> That's the story.
19:12:29 <mauke> yay, constraint solving
19:13:02 * alvarezp goes to look that term up on google.
19:13:30 <mauke> what, eunuch?
19:14:39 <gwern> no, contrainst solving
19:14:42 <pjd> alvarezp: constraint solving is the general name for this kind of problem, where you have a bunch of constraints (like the ones you listed) that you need to find solutions for
19:15:45 <alvarezp> pjd, I see. I guess the traditional approach is to use a tree, but it should be very difficult to find the best optimizations.
19:16:16 <glen_quagmire> using parsec, how can I parse anyChar that is not space?
19:16:22 <Cale> alvarezp: There is a sort of implicit tree described by the list comprehension.
19:16:25 <pjd> what does haskell have in the way of constraint programming?
19:17:08 <faxathisia> manyTill (char ' ') ?
19:17:20 <pjd> alvarezp: if the problem space is small enough, you can just use brute force (as with the list comprehension above)
19:17:21 <gwern> weord. hm.
19:17:30 <gwern> did FilePath change name recently to filepath?
19:17:44 <glen_quagmire> faxathisia, thanks. did not see that one
19:18:29 <Cale> noneOf " "
19:19:25 <lispy> aren't most constraint based solvers just brute force in the end?
19:19:34 <Cale> Hmm, there ought to be a general way to subtract parsers.
19:19:34 <faxathisia> lispy: No
19:19:35 <alvarezp> pjd, I think the problem will be to fill a two-dimensional list/array meaning one week full of classes (say, 12 classes per day) in the time dimension, with 15 classrooms in the space dimension.
19:19:46 <glen_quagmire> > parse (manyTill anyChar space) "" "!@$asdfa "
19:19:48 <lambdabot>   Not in scope: `anyChar'
19:20:12 <whee> glen_quagmire: I did  many1 (satisfy (not . isSpace)) for one of my parsers but it looks dumb
19:20:26 <lispy> faxathisia: when why don't we have PrologIII yet?
19:20:34 <lispy> s/when/then
19:20:37 <faxathisia> Prolog is fine
19:20:52 <alvarezp> lispy, at least prototype I tried doing in C was brute forcing, but did have some kind of optimizations that avoided brute forcing, like removing all the teachers that broke some rule before trying next iteration.
19:20:57 <SamB> prolog ... isn't that worse than brute force?
19:20:59 <glen_quagmire> > parse (noneOf " \v\f\t\r\n") "" "!@$asdfa "
19:20:59 <lambdabot>   Not in scope: `noneOf'
19:21:02 <lispy> There was a proposal for PrologIII that has a general constraint solver, but iirc, it couldn't work in practice
19:21:46 <Cale> It would be nice if we could write   anyChar <\> space
19:22:06 <alvarezp> lispy, so I think of it as a tree-walker with disappearing nodes for optimization. However, the best node to start with is the one with the least possible combinations. I'd like to know if there is a more "calculated" approach for this.
19:22:26 <nornagon> What's the difference between ST and State?
19:22:41 <Cale> p <\> q = notFollowedBy q >> p
19:22:44 <gwern> alvarezp: I'm sure there is, but you really should go through the literature
19:22:45 <faxathisia> lispy: I don't have my code here but I wrote a simple constraint solver that uses gauss elim in haskell to reverse game of life.. it takes 20 mins or so on a small grid.. same program using CLP in Prolog takes seconds
19:22:51 <lispy> alvarezp: I'm not a constraint based systems person.  I can't help.
19:23:03 <SamB> nornagon: they are bigger than the similarities
19:23:20 <gwern> alvarezp: for something like this, it's a fact of life that some smelly professor a billion years ago wrote the perfect program and described it in a research paper :)
19:23:22 <SamB> nornagon: ST is basically a safe version of IORef and IOArray ...
19:23:44 <SamB> State plumbs a variable through your program
19:24:04 <alvarezp> gwern, if only Haskell had an earth-walker to find that paper... ;-)
19:24:31 <gwern> alvarezp: nobody said perfection would be easy (to find)
19:24:35 <SamB> alvarezp: citeseer?
19:24:39 <alvarezp> gwern, it most probably is thrown at a corner of a library between 1000's of research works. :(
19:24:55 <alvarezp> SamB, thanks!
19:25:03 <nornagon> SamB: ah, okay
19:25:06 <mauke> @pl (\x y -> (length x `compare` length y) `mappend` (x `compare` y))
19:25:06 <lambdabot> ap (ap . (mappend .) . (. length) . compare . length) compare
19:25:13 <mauke> yeah ... no.
19:25:33 <lispy> what is `mappend` doing there?
19:25:39 <nornagon> SamB: so ST is sort of like State, except that you do the storing of your state yourself with IORef?
19:25:44 <SamB> nornagon: you could have written State yourself
19:25:44 <Cale> mauke: well, that first bit is "comparing length"
19:25:46 <mauke> combining Orderings
19:25:58 <SamB> you need to do dark magic to implement ST
19:26:19 <Cale> @pl (\x y -> comparing length x y `mappend` compare x y)
19:26:19 <lambdabot> ap (ap . (mappend .) . comparing length) compare
19:26:24 <SamB> nornagon: eh?
19:26:28 <Cale> still not so cute.
19:26:30 <nornagon> SamB: I'm confused :)
19:26:36 <mauke> lispy: do you know perl?
19:26:42 <SamB> nornagon: ST lets you embed imperative graph manipulations in pure code safely
19:26:47 <lispy> mauke: no, absolutely not.
19:26:52 * alvarezp is reading like crazy
19:26:59 <Cale> hmm
19:27:00 <mauke> too bad
19:27:19 <mauke> `mappend` works like || in perl there
19:27:23 <SamB> State just lets you do what you could do by passing a variable to all your functions and having them return an updated version along with the value you are actually interested in
19:27:30 <dolio> You could implement ST without black magic. Making it do efficent mutable updates is the black magic. :)
19:27:39 <lispy> mauke: why?  I'm sick of compensating for lack of static type safety, and perl is king amoung context necessary parsing
19:27:46 <faxathisia> not really
19:27:48 <faxathisia> try C
19:28:06 <SamB> dolio: well, that would be pointless
19:28:10 <nornagon> SamB: it's like... a mini IO?
19:28:16 <dolio> SamB: :)
19:28:18 <mauke> sort { length $a <=> length $b || $a cmp $b }  # perl
19:28:18 <SamB> nornagon: yes!
19:28:21 <SamB> a mini IO
19:28:25 <Cale> hmm
19:28:36 <Cale> :t liftM2 mappend (comparing length) compare
19:28:40 <SamB> one for which unsafePerformIO is not unsafe
19:28:42 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Ordering
19:28:49 <nornagon> SamB: wacky!
19:28:53 <Cale> :t (\x y -> (length x `compare` length y) `mappend` (x `compare` y))
19:28:54 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Ordering
19:28:56 <SamB> (it's called runST)
19:29:06 <nornagon> aha
19:29:13 <nornagon> so you can't do real IO in it, right?
19:29:21 <nornagon> without it being unsafe, ofc
19:29:23 <alvarezp> Ah! so "timetable" is the proper term!
19:29:24 <SamB> not without unsafeIoToST
19:29:26 <lispy> nornagon: and if you find yourself using ST inside IO and then needing IO, you can lift your ST into the IO quite efficently
19:29:40 <nornagon> i see :)
19:29:48 <Cale> That seems to work.
19:29:49 <mauke> @instances Monoid
19:29:49 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
19:29:51 <nornagon> So why's it useful?
19:29:54 <Cale> mauke: did you catch that?
19:30:10 <lispy> nornagon: a lot of times you need IO a, but you don't need input/output.
19:30:11 <SamB> nornagon: well, you won't feel dirty using it
19:30:22 <mauke> Cale: I don't understand how it works
19:30:29 <SamB> you'll merely be frustrated by how hard it is to get it to typecheck
19:30:29 <Cale> It's the ((->) e) monad
19:30:53 <nornagon> ah, so it's for when you want IORef but not hPutStrLn ;)
19:30:55 <SamB> it lets you use imperative algorithms in pure code
19:31:02 <lispy> nornagon: basically yeah
19:31:05 <nornagon> cool
19:31:12 <nornagon> thanks for taking the time to explain it :)
19:31:21 <lispy> once again, haskell is the best imperative language ;)
19:31:31 <nornagon> :P
19:31:49 <dogbite> hi all.  i'm preparing to rewrite the emacs calendar diary code in haskell
19:32:05 <dogbite> because i want recurring date rules available in haskell
19:32:13 <dogbite> does anybody think this is a bad idea?
19:32:40 <lispy> dogbite: no, but it also doesn't matter what we think.  Go make it and use it!
19:32:47 <joed> code is never a bad idea.
19:32:49 <lispy> dogbite: it's probably a nice idea
19:32:51 <dogbite> what i mean is, does this exist?
19:33:02 <joed> Does it matter :)
19:33:08 <gwern> dogbite: I've not seen anything
19:33:28 <lispy> and gwern has seen every haskell library out there lately
19:33:31 <dogbite> any general tips on translating elisp code to haskell
19:33:38 <Cale> Oh, and apparently the function monoid a bit as well :)
19:33:46 <lispy> dogbite: well, elisp has very different semantics
19:34:00 <Cale> :t liftM2 mappend
19:34:02 <dogbite> i think this code is pretty ... purely functional
19:34:05 <lispy> dogbite: and imperative code (of which elisp has quite a bit) tends to be "inside out" compared to functional code
19:34:05 <lambdabot> forall a1 (m :: * -> *). (Monad m, Monoid a1) => m a1 -> m a1 -> m a1
19:34:12 <Cale> :t liftM2 mappend compare
19:34:15 <lambdabot> forall a. (Ord a) => (a -> a -> Ordering) -> a -> a -> Ordering
19:34:30 <dogbite> what do you mean by inside-out
19:34:38 <mauke> Cale: yeah, I thought the -> Monoid did something different
19:34:54 <Cale> hmm
19:35:13 <Cale> :t  comparing length `mappend` compare
19:35:15 <mauke> :t comparing length `mappend` compare
19:35:23 <Cale> ...
19:35:24 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Ordering
19:35:24 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Ordering
19:35:36 <mauke> 
19:35:37 <Cale> So you don't even need the monad stuff :)
19:35:42 <Cale> heh
19:35:53 <Cale> Nice full-width characters.
19:36:07 <alvarezp> People, I really appreciate your help.
19:36:11 <gwern> on the other hand, I hear Common Lisp has some seriously nice calendar and time libraries
19:36:22 <SamB> @remember mauke 
19:36:22 <lambdabot> I will remember.
19:36:28 <alvarezp> Got to go, but I'll be back with a lot of questions.
19:36:29 <dogbite> yeah the thing i want is the diary
19:36:31 <Cale> gwern: We do too, but they're not well-integrated with the system library.
19:36:33 <SamB> @quote mauke
19:36:33 <lambdabot> mauke says: 
19:36:35 <dogbite> not for making a diary but for the
19:36:39 <dogbite> recurring dates
19:36:40 <SamB> @quote mauke
19:36:40 <lambdabot> mauke says: 
19:36:41 <lispy> ?src Monoid Ord
19:36:41 <lambdabot> Source not found. Maybe if you used more than just two fingers...
19:36:49 <SamB> mauke: haven't you said anything else memorable?
19:36:54 <mauke> @quote mauke
19:36:55 <lambdabot> mauke says: product `liftM` liftM read `liftM` liftM return `liftM` take 5 $ "1234567"
19:37:05 <mauke> argh, not that one again
19:37:15 <SamB> @quote mauke
19:37:15 <lambdabot> mauke says: product `liftM` liftM read `liftM` liftM return `liftM` take 5 $ "1234567"
19:37:21 <lispy> > product `liftM` liftM read `liftM` liftM return `liftM` take 5 $ "1234567"
19:37:28 <lambdabot>  120
19:37:28 <SamB> are those the only two?
19:37:33 <lispy> neat
19:37:40 <Cale> > product . (.) read . (.) return . take 5 $ "1234567"
19:37:41 <mauke> SamB: I don't think so
19:37:44 <lambdabot>  120
19:37:48 <SamB> @quote mauke
19:37:48 <lambdabot> mauke says: fmap fix return is the e^(i*pi)+1 of haskell
19:37:53 <SamB> okay, they aren't
19:37:57 <lispy> :t compare
19:38:00 <gwern> @quote explode
19:38:01 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
19:38:03 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
19:38:06 <SamB> lambdabot really needs to learn to mix it up better!
19:38:12 <lispy> ?src Monoid Ordering
19:38:12 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
19:38:16 <gwern> @quote mix
19:38:16 <lambdabot> ghc says: Can't mix generic and non-generic equations for class method
19:38:19 <lispy> ?src Moniod Ordering
19:38:19 <lambdabot> Source not found. Take a stress pill and think things over.
19:38:24 <lispy> what is mappend in again?
19:38:27 <lispy> ?type mappend
19:38:28 <lambdabot> forall a. (Monoid a) => a -> a -> a
19:38:35 <gwern> @hoogle mappend
19:38:35 <lambdabot> Data.Monoid.mappend :: Monoid a => a -> a -> a
19:38:40 <Cale> The @src plugin doesn't have everything
19:38:47 <shepheb> @yow
19:38:49 <lambdabot> Sometime in 1993 NANCY SINATRA will lead a BLOODLESS COUP on GUAM!!
19:38:51 <lispy> So how is mappend defined for ordering?
19:38:58 <lispy> I don't understand Monoid
19:39:00 <Cale> > liftM2 mappend [LT, GT, EQ] [LT, GT, EQ]
19:39:00 <lambdabot> Terminated
19:39:02 <Cale> > liftM2 mappend [LT, GT, EQ] [LT, GT, EQ]
19:39:02 <lambdabot> Terminated
19:39:10 <Cale> > liftM2 mappend [LT, GT, EQ] [LT, GT, EQ]
19:39:11 <lambdabot> Terminated
19:39:13 <Cale> ...
19:39:19 <shepheb> Cale: backticks?
19:39:25 <Cale> no
19:39:26 * gwern wonders the last time Conjure was compiled
19:39:33 <Cale> That works in my ghci session.
19:39:39 <Cale> hmm.
19:39:45 <mauke> :t (liftM2, mappend)
19:39:46 <lambdabot> forall a1 a2 r (m :: * -> *) a. (Monoid a, Monad m) => ((a1 -> a2 -> r) -> m a1 -> m a2 -> m r, a -> a -> a)
19:39:53 <Cale> Looks like I'll have to ssh into code to see what's up.
19:40:01 <shepheb> is \bot 6.8.2?
19:40:09 <lispy> ?version
19:40:10 <lambdabot> lambdabot 4p597, GHC 6.8.2 (Linux i686 2.40GHz)
19:40:10 <lambdabot> darcs get http://code.haskell.org/lambdabot
19:40:23 <mauke> lispy: mappend EQ y = y; mappend x _ = x
19:40:25 <Cale> ah
19:40:28 <Cale> Data.Generics
19:40:31 <Cale> blah
19:40:45 <lispy> mauke: and how is that useful?
19:40:49 <Cale> > liftM2 mappend [LT, GT, EQ] [LT, GT, EQ]
19:40:50 <lambdabot>  [LT,LT,LT,GT,GT,GT,LT,GT,EQ]
19:40:55 <mauke> chaining comparisons
19:41:15 <Cale> Basically, lexicographic composition.
19:41:37 <mauke> > sortBy (comparing length `mappend` compare) . filterM (const [False,True]) $ "abcdef"
19:41:38 <lambdabot>  ["","a","b","c","d","e","f","ab","ac","ad","ae","af","bc","bd","be","bf","cd...
19:41:48 <lispy> I guess the way this works is a bit too indirect and obscure for me.  I wouldn't want to maintain code that used that.
19:42:12 <Cale> It's really nice. It's exactly what you want it to mean.
19:42:15 <mauke> this sorts by length first, and lexicographically in groups of the same length
19:42:40 <Cale> Now, if only ++ was mappend ;)
19:42:49 <SamB> Cale: agreed!
19:42:51 * Cale is tempted...
19:43:02 <lispy> What, I thought (++) was the usual example of mappend
19:43:04 <SamB> tempted to do what?
19:43:09 * mauke is tempted to quote an image macro: "DO IT FAGGOT"
19:43:13 <SamB> lispy: he wants ++ to mean mappend
19:43:15 <lispy> > [1..3] `mappend` [4..6]
19:43:16 <lambdabot>  [1,2,3,4,5,6]
19:43:16 <Cale> SamB: To do the same thing I did with (.)
19:43:21 <Cale> :t (.)
19:43:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:43:29 <SamB> ah ;-)
19:43:32 <SamB> go for it
19:43:36 <Cale> okay
19:43:42 <byorgey> Cale: the more you change, the less useful it is for teaching
19:43:43 <SamB> that's a great way to see how well it would work ;-)
19:43:53 * lispy agrees with byorgey 
19:44:08 <SamB> but... Cale is teaching for the future!
19:44:08 <Cale> Well, that's somewhat true, but I'm only generalising things.
19:44:11 <byorgey> Cale: might I suggest two different evaluation indicators, like > and >> or something, one meaning 'normal' and the other meaning 'with Cale-isms'?
19:44:12 <lispy> bah, the may bugs are here...
19:44:14 <mauke> I want maximum magic
19:44:23 <SamB> how about >> means normal
19:44:29 <SamB> and > means Caley
19:44:45 <SamB> similarly, ::t means "normal type"
19:44:59 <lispy> how about :t works with /msg :)
19:45:22 <lispy> I can't think of how many times I go, /msg lambdabot :t ..., "wth??"
19:45:34 <lispy> oh, ?type...
19:45:39 <Cale> lispy: If you can figure out why it's not working, then I'd be happy to fix it :)
19:45:53 <SamB> lispy: I imagine it has to do with the filter architecture
19:46:31 <SamB> if you can figure out how to change the filter architecture so that it works right for privmsgs, by all means do so!
19:46:36 <gwern> aha, now I remember. packCStringLen :: CStringLen -> IO ByteString was originally packCStringLen :: CStringLen -> ByteString, but it was changed for safety reasons. that explains this conjure error
19:46:49 <gwern> (bytestring changes a lot, but I suppose in the name of quality)
19:47:01 <lispy> quality is good
19:47:01 <Cale> :t (++)
19:47:02 <lambdabot>     Ambiguous occurrence `++'
19:47:02 <lambdabot>     It could refer to either `L.++', defined at State/L.hs:12:0
19:47:02 <lambdabot>                           or `Data.List.++', imported from Data.List
19:47:06 <Cale> mm
19:47:23 <Cale> :t (++)
19:47:24 <lambdabot> forall m. (Monoid m) => m -> m -> m
19:47:41 <mauke> > sortBy (comparing length ++ compare) . filterM (const [False,True]) $ "abcdef"
19:47:41 <lambdabot>   Not in scope: `++'
19:47:51 <SamB> look, ma, no reboot!
19:47:58 <mauke> no success
19:47:59 <Cale> hehe, bad timing perhaps
19:48:02 <Cale> > sortBy (comparing length ++ compare) . filterM (const [False,True]) $ "abcdef"
19:48:02 <lambdabot>   Not in scope: `++'
19:48:05 <Cale> huh
19:48:07 <Cale> ...
19:48:36 <Cale> Oh, maybe I know.
19:49:00 <Cale> @undefine
19:49:00 <lambdabot> Undefined.
19:49:03 <lispy> Cale: but by the time I do enough work to explain why it's not working I'd probably be able to fix it faster than I could explain it.
19:49:06 <Cale> hmm
19:49:20 <Cale> lispy: I'd also be happy to take a patch ;)
19:49:29 <lispy> Cale: yeah, yeah... :)
19:49:32 <Cale> lispy: But otherwise, I'll try and look into it some more
19:49:47 <lispy> Cale: not a big deal.  new features are better than fix that.
19:49:52 <Cale> ah, I see what happened
19:50:17 <Cale> @undefine
19:50:18 <lambdabot> L.hs:11:7:     Ambiguous type variable `a1' in the constraint:       `Monoid a1' arising from a use of `mappend' at L.hs:11:7-13     Possible cause: the monomorphism restriction applied to the
19:50:18 <lambdabot> following:       ++ :: a1 -> a1 -> a1 (bound at L.hs:11:0)     Probable fix: give these definition(s) an explicit type signature                   or use -fno-monomorphism-restriction  L.hs:12:7:
19:50:18 <lambdabot>  Ambiguous type variable `a' in the constraint:       `Monoid a' arising from a use of `mempty' at L.hs:12:7-12     Possible cause: the monomorphism restriction applied to the following:       zero :
19:50:18 <lambdabot> : a (bound at L.hs:12:0)     Probable fix: give these definition(s) an explicit type signature                   or use -fno-monomorphism-restriction
19:50:23 <Cale> whoa :)
19:50:29 <gwern> @hoogle unsafePerformIO
19:50:29 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
19:50:29 <lambdabot> System.IO.Unsafe.unsafePerformIO :: IO a -> a
19:50:46 <Cale> @undefine
19:50:46 <lambdabot> Plugin `eval' failed with: State/Pristine.hs: copyFile: does not exist (No such file or directory)
19:50:57 <gwern> Cale: your changes will singlehandedly undo years of research into more comprehensible error messages!
19:51:02 <Cale> @undefine
19:51:03 <lambdabot> Undefined.
19:51:15 <Cale> gwern: heh
19:51:19 <Cale> > sortBy (comparing length ++ compare) . filterM (const [False,True]) $ "abcdef"
19:51:25 <lambdabot>  ["","a","b","c","d","e","f","ab","ac","ad","ae","af","bc","bd","be","bf","cd...
19:51:30 <Cale> there we go :)
19:51:46 <lispy> I have no objection to (++) replacing mappend, but I'm not comfortable having lambdabot run a customized version of Prelude.
19:52:25 <Cale> lispy: I'm sure we'd all rather see patches go directly to the Prelude, but for some reason people seem intent on "standards".
19:52:48 <SamB> well, we could have an alternate prelude package that lambdabot could use for it's prelude...
19:52:49 * Cale shakes his fist at standards.
19:53:08 <gwern> Cale: don't get angry! remember, the nice thing about standards is that there are so many to chosoe from
19:53:11 <SamB> we could call it BleedingPrelude
19:53:12 <Cale> I would really like to see a nuperfectbase package :)
19:53:13 <vinc456> is there a simple debugger that a novice could use or would i be better off tracing through my code by hand?
19:53:31 <Cale> vinc456: GHCi has one.
19:53:36 <SamB> vinc456: well, Debug.Trace might help too
19:53:57 <Cale> vinc456: But usually it's best to break things down until the parts are small and easy to test separately.
19:54:09 <lispy> I wish GHCi also had a type checking debugger.  It lets you step through the type resolution process.
19:54:26 <lispy> Cale: Do you think you could create a type checking debugger for lambdabot?
19:54:31 <lispy> That would be mega super cool.
19:54:34 <SamB> lispy: my word
19:54:35 <Cale> hehe
19:54:52 <Cale> Oh, also
19:54:54 <SamB> that would perhaps require a multi-Oleg effort
19:54:54 <Cale> :t zero
19:54:56 <lambdabot> forall m. (Monoid m) => m
19:55:11 <lispy> > zero :: Ordering
19:55:12 <lambdabot>  EQ
19:55:21 <faxathisia> just writing a typechecker might help enough to not need to see the process visually
19:55:44 <gwern> @hoogle withForeignPtr
19:55:44 <lambdabot> Foreign.ForeignPtr.withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
19:55:51 <lispy> faxathisia: how many beginners know enough about haskell's type system to write a type checker? :)
19:56:28 <Cale> Oleg can write a type checker in the type system.
19:56:31 <lispy> I would, of course, want this type checker to support everything that GHC can type check.  Some of the stuff I'm working on now with higher ranks and whatnot, is very hard to figure out at times.
19:56:53 <lispy> Cale: by writing it in prolog then translating that to type classes?
19:56:58 <Cale> hehe
19:57:05 <lispy> it's what I would try
19:57:16 <mauke> hasn't oleg written djinn in the type system?
19:57:28 <Cale> heh, he actually did something like that, I think.
19:57:49 <Cale> Basically, something which actually gave you the function of such and such type.
19:57:58 <SamB> hmm, that doesn't sound too hard
19:58:04 <lispy> Actually, I would like to spend more time learning prolog proper and also studying the mapping between prolog and haskell's type classes so that I could code up whatever I want in the type system :)
19:58:14 <shepheb> if I have two TChans, and I want to wait until either of them has data ready, is there a way to do that?
19:58:40 <shepheb> without polling, I mean.
19:59:27 <faxathisia> writing a type checker in Prolog is a very simple thing to do
20:00:03 <mauke> readTChan x `orElse` readTChan y
20:00:06 <faxathisia> for example, with a small metainterpreter you can have an interactive ?djinn + structural recursion
20:00:13 <faxathisia> write map .. fold etc in it
20:00:41 <SamB> man it took me too long to remember STM
20:00:53 <SamB> (just the three letters)
20:01:40 <shepheb> mauke: hmm. that requires them to be the same type. I guess I could work around that with Either. but if I'm doing that, why not just use on TChan?
20:02:09 <SamB> shepheb: that is for you to puzzle out
20:02:22 <SamB> we might help you if you explained your design so far
20:02:46 <shepheb> one is intended to carry information on new clients, while the other is for input from the existing clients.
20:02:59 <SamB> since when do GHC. modules get haddock pages???
20:03:10 <SamB> http://www.haskell.org/ghc/docs/latest/html/libraries/base/GHC-Conc.html#v%3AorElse
20:03:11 <lambdabot> http://tinyurl.com/ytm69k
20:04:23 <gwern> I'm always mildly amused when I run across a program defining its own 'forever'. did such a trivial function really take so long to be included in libraries?
20:04:31 <gwern> @hoogle forever
20:04:31 <lambdabot> Control.Monad.forever :: Monad m => m a -> m ()
20:04:32 <SamB> gwern: yes!
20:04:38 <lispy> gwern: yes
20:04:46 <lispy> ?src forever
20:04:46 <lambdabot> Source not found. I am sorry.
20:04:59 <gwern> a >> forever a, iirc
20:05:06 <lispy> gwern: and I think there are bad ways of doing it too.  Like ones that are not efficient
20:05:17 <SamB> lispy: what the heck?
20:05:23 <lispy> :t \a -> a >> forever a
20:05:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
20:05:48 <gwern> lispy: how would you define an inefficient forever?
20:05:51 <SamB> hey, why does that forever return a ()
20:05:54 <lispy> SamB: I maybe it was some other bug in my program.  Long time ago, I used my own forever and had horrible space leaks.
20:05:54 <SamB> that's lame
20:06:00 <gwern> (neat, conjure finally compiled)
20:06:01 <SamB> my forevers always return a
20:06:04 <gwern> @seen dons
20:06:04 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 5m 26s ago.
20:06:16 <gwern> yeah, but in which channel, lambdabot?
20:06:21 <dons> gwern: ?
20:06:32 <SamB> dons: in which channel did you last speak?
20:07:02 <gwern> dons: a number of foreignptr functions in bytestring used to take one Int, but in recent libs they take two Ints. is it bad or unsafe to update old calls to simply use the same Int twice?
20:07:15 <gwern> I didn't find any doc explanations of the change
20:07:31 <SamB> isn't one of them the offset?
20:07:47 <dons> SamB: xmonad
20:07:49 <SamB> don't they have haddock comments?
20:07:57 <dons> gwern: yes, that is wrong.
20:08:04 <dons> one is the offset. the other is the length
20:08:17 <dons> normally the offset was omitted
20:08:21 <dons> in which case it should be used as 0
20:08:25 <SamB> dons: why did you change the existing functions?
20:08:29 <dons> s/normally/previously/
20:08:30 <SamB> instead of making new ones?
20:08:45 <dons> SamB: authoratarian perogative
20:09:06 <SamB> it's really not nice to break types like that :-(
20:09:08 <dons> that was a *long* time ago, btw, 4-6 relases
20:09:13 <SamB> oh. okay.
20:09:20 <dons> so something is using very old code
20:09:20 <gwern> dons: oh dear. a good thing I decided to ask about it
20:09:21 <SamB> the longer ago this was, the better ;-)
20:09:24 <gwern> maybe improve the docs?
20:09:37 <gwern> dons: I don't think conjure is that old, apparently targeted at 6.6
20:09:58 <dons> so a couple of years ago
20:10:25 <dons> fromForeignPtr you mean?
20:10:58 <gwern> yeah
20:11:04 <SamB> who was that other guy who was trying to fix conjure?
20:11:06 <gwern> I mean, is the first one the 0, or the second?
20:11:14 <SamB> but didn't know if he was doing it right?
20:11:17 <SamB> I believe he was.
20:11:25 <SamB> he somehow knew which was which...
20:11:42 <dons> gwern:
20:11:43 <dons> -- | /O(1)/ Build a ByteString from a ForeignPtr
20:11:44 <dons> fromForeignPtr :: ForeignPtr Word8 -> Int -> Int -> ByteString
20:11:44 <dons> fromForeignPtr fp s l = PS fp s l
20:11:44 <SamB> @docs Data.ByteString
20:11:44 <lambdabot> Data.ByteString not available
20:11:54 <dons> the first is the offset
20:12:00 <dons> this should be documented
20:12:02 <SamB> intuitive ;-)
20:12:07 <SamB> but yes, documented it should be
20:12:26 <dons> ideally offset would be a different type
20:12:30 <SamB> I've always been a bit annoyed that haddock can't document argument names
20:12:54 <gwern> SamB: actually it is, because if you wanted to wrap it and repdouce the old one, you would naturally hope the first Int would be the default one, so you could do oldFromForeignPtr = fromForeignPtr 0, if you follow
20:12:56 <lispy> SamB: no I think there is a way...isn't there?
20:13:07 <gwern> there is, isn't it like @n@?
20:13:09 <SamB> though with such intuitive names as "s", I don't think it would have helped
20:13:11 <dons> gwern: so partially applly it, yeah, that's a good idea
20:13:20 <gwern> I could've sworn I've seen xmc docs name arguments
20:13:27 <SamB> gwern: I was serious that it was intuitive!
20:13:29 <mauke> newtype Arg1 a = Arg1 a; newtype Arg2 a = Arg2 a
20:14:03 <SamB> pointer and offset say where to start looking, size says when to stop
20:14:12 <SamB> perfectly intuitive
20:14:42 <gwern> SamB: I suppose if you know what pointers are
20:14:51 <SamB> eh?
20:14:55 <SamB> who doesn't?
20:15:09 * gwern only has a vague idea what pointers are
20:15:18 <SamB> gwern: oh no!
20:15:36 <SamB> we will have to send you back to CS 101 or something
20:15:42 <gwern> they redirect you to someplace else in the computer's memory. they, uh, point. or something
20:15:46 <lispy> no offense to gwern.  But I usually assume if someone doesn't have a strong understanding of pointers they are not a good programmer.
20:15:48 <gwern> and that's about all I know
20:16:06 <SamB> gwern: do you know assembly yet?
20:16:11 <gwern> lispy: would you be more charitable if haskell was my first real language?
20:16:21 <gwern> SamB: I know even less about that than C...
20:16:35 <SamB> gwern: well, you really should learn one or the other
20:17:13 <lispy> gwern: yeah, because then your explanation above of pointer is about all you need to know.  But, I don't think I'd feel comfortable letting you loose on C/C++/Java code (so I would be hesitant to work with you, a ya know in the RealWorld, where most companies don't use Haskell).
20:17:16 <SamB> the advantage to learning assembler is that a lot more of your "what" questions will have actual answers
20:17:24 <dons> that makes what gwern's doing even more inspiring
20:17:26 <mauke> a pointer is an object handle
20:17:36 <gwern> SamB: The lyf so short, the craft so longe to lerne
20:17:42 <mauke> an object is an array of bytes, usually with an interpretation
20:17:49 <mauke> that "interpretation" is called a type
20:18:15 <lispy> mauke: I would call the interprenetation a value :)
20:18:18 <mauke> actually, a pointer is a pair of an object handle and an offset
20:18:22 <mauke> hmm, yeah
20:18:37 <SamB> lispy: no, the value is what you get if you apply the interpretation to the representation
20:19:10 <lispy> SamB: okay, that may be true.  But then I still object to the interpretation being called a type.  I think of types as sets of values.
20:19:14 <mauke> no interpretation without representation! tea anyone?
20:19:21 <lispy> heh
20:19:34 <SamB> lispy: in C, they undeniably also represent mappings between values and representations
20:20:10 <gwern> mauke: words mean just what I want them to mean. the question is who is to be master, see?...
20:20:58 <SamB> gwern: well, you could learn an assembly language
20:21:14 <SamB> gwern: that is probably the quickest path to understanding what a pointer is ;-P
20:21:23 <SamB> you could learn a really small one
20:21:37 <SamB> does anyone know of any really small ones?
20:21:40 <mauke> C pointers are actually more high-level
20:21:56 <SamB> if by high-level, you mean hand-wavey
20:21:56 <SamB> yes!
20:21:56 * dolio had to learn a bit of PIC in college.
20:21:59 <mauke> in C, each object is its own segment
20:22:02 <gwern> SamB: I've heard going through Knuth is the path to enlightenment, but I keep waiting for knuth to either croak or finish
20:22:19 <lispy> I would recommend RISC
20:22:30 <SamB> if you want to grok THAT, go through some old turbo pascal programs with IDA
20:22:46 <lispy> because 1) it's real 2) it's reduced instruction set 3) it requires some cleverness to pickup the idioms
20:22:46 <SamB> you will grok very quickly ;-)
20:23:16 <SamB> gwern: I would avoid MMIX
20:23:17 <SamB> it is not fun
20:23:54 <SamB> It is a crazy architecture. The principle sane things about it are the things it can't help but be sane about without sticking out like a sore thumb...
20:24:44 <SamB> i.e., those things that are not sane about MIX by todays standards (but are fine for a teaching tool)
20:26:08 <Cale> Hmm, I wonder if I could just use the C preprocessor to get that effect.
20:26:49 <SamB> Cale: what effect?
20:26:57 <Cale> Having two evaluation contexts.
20:27:10 <SamB> you could
20:27:21 <SamB> -D is not hard
20:27:36 <SamB> #ifdef CALE
20:28:22 <mauke> oh god, that reminds me of the text adventure written in cpp error messages
20:28:44 <mauke> cc -Describe -Dungeon prog.c
20:28:46 <SamB> mauke: this will be much nicer
20:28:51 <lispy> despite the bad press report on CPP, it is actually pretty pragmatic and helpful.
20:29:03 <SamB> what bad press report?
20:29:08 <lispy> mauke: that's awesome, have a link still?
20:29:32 <lispy> SamB: compiler macros like CPP are considered evil by many.  Ever noticed Sun still hasn't provided one for Java?
20:29:35 <gwern> was MMIX the one that replaced MIX or t'other way around?
20:29:43 <lispy> gwern: yes
20:30:23 * gwern notes that lispy's answer reminds me of stallman's response when asked whether he preferred emacs or vim
20:30:28 <mauke> lispy: http://www0.us.ioccc.org/years.html#1994_westley
20:30:28 <lambdabot> Title: Previous IOCCC Winners
20:32:38 <SamB> lispy: oh, that.
20:32:44 <SamB> that's not press, per se.
20:32:51 <lispy> gwern: hmm... I have a copy of 3rd edition and it seems to use MIX
20:33:03 <SamB> the MMIX books are not yet out
20:33:06 <Cale> grr, no, this is more complicated.
20:33:19 <lispy> yeah MMIX is not out yet, SamB is right
20:33:25 <Cale> Well, I could still use the C preprocessor, but L.hs isn't recompiled with each expression.
20:33:26 <SamB> also, vol. 3 is only the 2nd edition
20:33:33 <Cale> *grumble*
20:33:40 <SamB> Cale: oh.
20:34:05 <SamB> well, you could #include the contents of L.hs in two different modules...
20:35:54 <Cale> @let data T a = Tip | Branch a (T a) (T a)
20:35:54 <lambdabot> Invalid declaration
20:36:00 <Cale> interesting.
20:36:15 <SamB> man, I HATE guess-the-verbs like this
20:37:16 <lispy> I seem to recall downloading some MIX or MMIX code from Knuth's site once.  At least I think he wrote it (it was god awful CWEB) and there was a comment that implementing the pipeline was one of the hardest things he had coded in C).
20:37:24 <lispy> Has anyone else seen something like that?
20:38:10 <lispy> it wasn't just MIX source it was the source to the MIX virtual machine
20:38:37 <dons> one year of xmonad, http://www.haskell.org/pipermail/xmonad/2008-March/005021.html
20:38:38 <lambdabot> Title: [xmonad] xmonad is one year old today
20:38:55 <dons> thanks for the encouragement, everyone here who helped!
20:38:56 <SamB> lispy: MMIXware
20:39:07 <SamB> I'm pretty sure it was MMIX
20:39:17 <SamB> I don't think MIX-era computers had any pipelines
20:39:55 <SamB> I have no frickin clue why he wrote a MMIX implementation with a frickin pipeline but no damn disk controller!
20:40:08 <lispy> lol
20:40:24 <Cale> SPJ has contributed code to xmonad?
20:40:37 <dons> yeah, before the oscon tutorial
20:40:46 <dons> he did a bit of an audit of the StackSet.hs type
20:40:46 <Cale> ah, interesting
20:40:48 <gwern> what did he add?
20:40:57 <dons> i should also inclue Wouter Swiestra there, who did Coq proofs of some of StackSet
20:41:04 <Pseudonym> Presumably, something to make the talk more interesting.
20:41:11 <glguy> yow
20:41:12 <SamB> he wanted to make sure that it was tutorial-worthy?
20:41:12 <dons> gwern: oh a bunch of refactoring to make things cleaner
20:41:23 <dons> well, more easier to grok
20:41:40 <dons> actually, i need yav's nice graphs of the xmonad source.
20:41:45 <scook0> I have an application made up of a few components, each of which will need its own little mutable state
20:42:02 <dons> scook0: well, does it have to be mutable, or just stateful?
20:42:03 <scook0> now, I could do the usual thing and use StateT or ReaderT & IORefs
20:42:19 <SamB> okay, how the heck do you dial the phone in this stupid game?
20:42:35 <scook0> but this would mean I have to update the central monad code each time I want to add a component, or change the details of one
20:42:53 <scook0> so I'm trying to find ways of making this more modular
20:43:00 <glguy> What do Ubuntu users do when they want 6.8.2?
20:43:22 <shepheb> glguy: I grabbed the binary from the GHC page, personally.
20:43:27 <dons> scook0: well, often you'll have a Types module, definining the different environments each component is run in
20:43:59 <dons> runState (runReader ..) when making a call into a module, where the core manages the state multiplexing
20:45:20 <glguy> the new hpaste code is split into different monads based on what you need to be able to do (web app, db access, page rendering)
20:45:53 <glguy> Don't know if it's a good example, but it is an example :-)
20:47:13 <scook0> my main concern is minimizing changes to the core, when I add/change a module
20:47:42 <dons> glguy: i think it is good. particularly the Storage, so you can intialise and run each component separately , and simply
20:47:42 <glguy> then it's probably worth a look
20:47:51 <glguy> the monads are particularly independent
20:48:08 <glguy> s/particularly/pretty much
20:48:10 <dons> scook0: ideally they'd be fully partioned (with types enforcing that the abstractions can't leak)
20:48:17 <glguy> the main one just has functions for lifting the others into it
20:48:33 <glguy> and the little ones go off and do their thing
20:48:39 <glguy> function*
20:48:49 <scook0> (e.g. if I decide that a pure module needs to become stateful, I don't want to have to edit the core in three different places)
20:49:36 <glguy> going from one monad to another is a bit different from notamonad to monad
20:49:36 <scook0> where's the hpaste code hosted?
20:49:37 <gwern> anyone recognize errors like these? '/usr/bin/ar: creating dist/build/libHSConjure-0.1.a
20:49:40 <gwern> dist/build/./cbits/sha1.o: In function `SHA1_Transform':
20:49:43 <gwern> sha1.c:(.text+0x0): multiple definition of `SHA1_Transform'
20:49:45 <glguy> git clone http://code.haskell.org/hpaste.git
20:50:11 <lispy> :t Word6
20:50:14 <lambdabot> Not in scope: data constructor `Word6'
20:50:16 <dons> gwern: probably you import a .h file twice
20:50:23 <lispy> ?index Word8
20:50:23 <lambdabot> Data.Word, Foreign
20:50:38 <gwern> dons: entirely possible
20:52:21 <scook0> glguy: /usr/bin/git-clone: 356: curl: not found
20:52:41 <dons> i hope every haskeller who hasn't used xmonad goes out and installs it tonight, btw :)
20:53:14 <glguy> scook0: sounds like you need to install curl to use git to pull web repos
20:53:48 <scook0> ah, I thought it was telling me curl couldn't find the URL :)
20:54:23 <gwern> speaking of curl, did y'all know the curl bindings sneaked onto hackage a few days ago?
20:54:24 <dons> no, that's a curl error
20:54:31 <gwern> I was surprised to see it there
20:54:31 <glguy> 8?
20:54:36 <dons> i think glguy knew.
20:54:37 * SamB tells cabal-get to do it
20:54:40 <scook0> seems weird that it wasn't installed as a dependency
20:54:50 <scook0> seems to be working now
20:54:50 <glguy> what distro?
20:54:51 <dons> gwern: why?
20:55:13 <scook0> (feisty-backports)
20:55:14 <gwern> dons: why was I surprised, or why were the haskell curl bindings put onto hackage?
20:55:27 <dons> former.
20:56:01 <gwern> dons: oh. I had been under the impression the curl bindings were a failed SoC, much less in a cleaned up enough state to be putable-on-hackage, much less actually on hackage
20:56:10 <gwern> also, I had actually searched hackage for them before...
20:56:12 <glguy> totally different project
20:56:15 <dons> oh, this is a different curl library
20:56:32 <dons> this is the enterprise edition of the curl library
20:56:39 <glguy> lol
20:56:39 <SamB> you mean it's nnot the HTTP library?
20:56:47 <dons> brought to you by the good folks at galois, your haskell innovators
20:56:58 * glguy mutes dons
20:57:02 <gwern> neat. suprised there was no ANN then a little
20:57:15 <dons> we're actually building up to a big release of web software
20:57:20 <dons> so likely there'll be a big announce then
20:57:25 <dons> of which curl is a sneak preview
20:57:35 <gwern> (yay! conjure now compiles from sdist tarball! now, the question is, does it work? :)
21:01:21 <glguy> *really* slow connections make me appreciate vim :)
21:01:40 <dons> hehe
21:01:53 <glguy> I have time to really optimize my keystrokes
21:02:00 <glguy> when I know I've got a couple seconds to wait
21:02:02 <glguy> for the update
21:02:57 <lispy> http://www.mutantlemon.com/omegagb/devlog/
21:02:57 <lambdabot> Title: OmegaGB Devlog
21:03:06 <lispy> someone who does game dev in haskell
21:03:11 <lispy> it's a gameboy emulator
21:03:22 <dons> SamB did that , didn't he??
21:03:29 <SamB> did not
21:03:34 <SamB> I've heard of it
21:03:38 <glguy> close enough
21:03:42 <SamB> hah
21:03:51 <dons> hmm.
21:03:57 <dons> did you do znes SamB ?
21:04:00 <dons> or some other emulator?
21:04:03 <SamB> I wrote a ZMachine interpreter but still haven't figured out how to do a status area in GTK ;-)
21:04:06 <dons> ah ha
21:04:18 <SamB> and I *am* a ZSNES committer
21:04:32 <SamB> as you can see on my ohloh profile
21:05:00 <hpaste>  gwern pasted "example conjure output" at http://hpaste.org/6177
21:05:09 <SamB> hmm, I probably should mirror ZMachine to git sometime...
21:06:04 <dons> SamB: url?
21:06:09 <lispy> It's still way to hard to find the haddock docs from a google search.
21:06:21 <lispy> I found them via a wikibook but the link was broken.
21:06:33 <lispy> Which is another bad thing.  Links should be more stable than that.
21:06:39 <gwern> ...given that I spent all evening on it, I'm a little disapointed how short my changes turn out to be
21:06:44 <gwern> lispy: you edit in the new link?
21:06:50 <SamB> http://naesten.dyndns.org:8080/repos/ZMachine/
21:06:53 <dons> gwern: short is good.
21:07:05 <dons> glguy commented that in 12 months we've averaged 3 lines a day for xmonad.
21:07:07 <lispy> gwern: sure, that's a different issue.  Links to things like documentation should not be effemeral.
21:07:09 <dons> that's actually a good thing :)
21:07:46 <gwern> lispy: I realize that but in the short term we have to updatye all the currently broken  links even if doc links right this moment became reliable
21:08:08 <scook0> links to /latest/ tend to be ephemeral without people realising
21:09:02 <glguy> dons: I don't think I noticed that
21:09:20 <gwern> what is cabal-setup? is it old an obsolete?
21:09:36 <SamB> gwern: the executable on your system?
21:09:40 <SamB> probably...
21:09:50 <SamB> the package on hackage? dunno...
21:09:53 <dons> glguy: oh , yav then.
21:10:01 <lispy> gwern: new link in place
21:10:06 <dons> all the galwegians are much the same to me
21:10:16 <lispy> BTW, this is pretty nice documentation about ST array
21:10:24 <gwern> it's just that conjure has a darcs hook which goes 'cabal-setup configure && cabal-test'
21:10:32 <gwern> and my system has no idea what this cabal-setup thing is
21:10:40 <SamB> gwern: oh.
21:10:41 <gwern> much less cabal-test
21:10:52 <SamB> gwern: replace that with the appropriate runhaskell invocation
21:11:06 * gwern figured as much
21:11:36 <SamB> cabal-setup just compiled Setup.{hs,lhs} to ./setup and ran it
21:11:53 <SamB> as far as I could see...
21:12:00 <dons> interesting, the phrase "haskell programming" has returned about 1000 hits per day more , each day, for the last 12 days
21:12:03 <dons> on google.
21:12:08 <dons> ohloh effect?
21:12:14 <SamB> dons: since?
21:12:19 <glguy> dons: Any chance you could see if master on hpaste.git compiles?
21:12:25 <SamB> I mean than?
21:12:32 <dons> SamB: since we started putting code on ohloh, so 12 days ago
21:12:38 <dons> glguy: checking
21:12:39 <SamB> ah.
21:12:52 <dons> should help tiobe's index ;)
21:12:57 <SamB> did we do that because they finally added support for counting Haskell ?
21:13:06 <dons> src/Bot.hs:24:9: Not in scope: `getConfig'
21:13:10 <dons> SamB: right
21:13:34 <glguy> dons: thanks!
21:13:38 <SamB> I hope they open up the repository-access code soon ...
21:14:22 <glguy> dons: all better?
21:14:31 <glguy> I'm going to install Fedora
21:14:38 <glguy> I didn't bring my laptop home
21:14:46 <glguy> so I can't compile without a bunch of hassle
21:14:49 <glguy> (ubuntu atm)
21:15:12 <dons> src/Main.hs:26:17: Could not find module `Codec.Binary.UTF8.Generic':
21:15:20 <glguy> Ah
21:15:27 <glguy> ok, that's something I can't fix from home :)
21:15:32 <glguy> thanks
21:15:46 <glguy> shame I didn't push that anywhere before I left
21:16:09 <nornagon> http://nornagon.net/code/hfov.tar.gz <-- This is a binding to a C library for computing coarse field of view in a 2D raster grid, suitable for use in, say, roguelikes.
21:16:30 <nornagon> http://nornagon.net/darcsweb.cgi?r=hfov <-- darcs repo
21:16:30 <lambdabot> Title: darcs - hfov
21:16:39 <scook0> heh
21:16:53 <scook0> I have a haskell port of ppfov sitting around, actually
21:17:02 <nornagon> ppfov?
21:17:20 <nornagon> oh right
21:17:27 <nornagon> precise permissive
21:17:39 <scook0> http://roguebasin.roguelikedevelopment.org/index.php?title=Precise_Permissive_Field_of_View
21:17:41 <lambdabot> Title: Precise Permissive Field of View - RogueBasin, http://tinyurl.com/2x5p6h
21:17:54 <nornagon> this algo's based on bergstrm's shadowcasting algo, i believe.
21:19:10 <gwern> nornagon: interesting. how mature is your binding?
21:19:17 <nornagon> gwern: i wrote it today :)
21:19:46 <nornagon> it'll explode hilariously if you stare at it too hard. Or generate any exceptions from within a callback.
21:19:48 <gwern> newborn eh
21:20:17 <nornagon> but other than that and a few niggling interface issues, it's usable now
21:21:54 <gwern> nornagon: I'll wait a little while before I think about cbaalizing it then
21:22:32 <nornagon> gwern: it's already cabal'd
21:22:43 <gwern> lemmih = Lennart Kolmodin right?
21:22:51 <gwern> nornagon: sure but is it hackage-able?
21:22:52 <nornagon> http://nornagon.net/hfov.gif <-- example of use :3
21:22:57 <nornagon> gwern: quite possibly not
21:23:04 <nornagon> no category, for example
21:23:15 <dons> gwern: nope.
21:23:27 <gwern> category ain't mandatory, and I'd put it in Games fwiw
21:23:31 <nornagon> also, does hackage have a version numbering system? because I'm going for "1" as the first release, "2" as the second and so on
21:23:42 <gwern> dons: oh. who is lemmih then?
21:24:01 <dons> David Himmelstrup
21:24:05 <gwern> nornagon: I think 0.1, 0.2 and so on is the usual way of things, with 1.0 representing a polished ideal endproduct
21:24:18 <lispy> Is it possible to have top level STArrays?
21:24:21 <nornagon> i don't like that system :(
21:24:48 <dons> lispy: sure.
21:24:50 <gwern> nornagon: but cabal/hackage does impose some limits on what kind of versioning you can do, dunno what exactly
21:24:52 <SamB> gwern: 1.0 is supposed to be something good enough to put in a box, or something ;-)
21:24:57 <lispy> foo :: STArray s Int Int; foo = runST (newarray (0,100) 0)
21:25:01 <lispy> That doesn't type check
21:25:16 <lispy> should be newArray, but you get the idea
21:25:24 <SamB> nornagon: just stick 0. in front of your scheme
21:25:28 <gwern> SamB: right, 'ideal endproduct', although sometimes projects get afeared of the 1.0
21:25:36 <nornagon> well i'm not doing anything wacky like calling my releases  or something
21:25:45 <SamB> gwern: most projects don't stop at 1.0
21:25:53 <lispy> dons: so do you know what I'm doing wrong there?
21:25:55 <gwern> I remember the FF guys running around like crazy during the .9 part since they couldnt avoid 1.0 anymore
21:26:03 <lispy> The type error is throwing me for a loop :)
21:26:04 <scook0> I think hackage requires dotted-numeric
21:26:16 <nornagon> aw.
21:26:21 <gwern> huh. conjure wants to send to  conjure@lists.urchin.earth.li. dudn't know conjure had its own email list
21:26:34 <dons> lispy: its not in STArray after runST
21:26:40 <dons> :t Control.Monad.ST.runST
21:26:45 * SamB doesn't tell nornagon that his scheme is probably legal, but sounds awfully inflationary
21:26:49 <scook0> gwern: that's what 0.10 is for :)
21:26:55 <lambdabot> thread killed
21:27:22 <gwern> scook0: I've always hated that convention so much
21:27:25 <lispy> dons: So the top level type needs to be something like ST s (STArray s Int Int) ?
21:27:33 <gwern> it's madness! 0.9 > 0.10
21:27:36 <nornagon> scook0: you breaked my floating point numbers :(
21:27:38 <dons> :t Control.Monad.ST.runST
21:27:39 <lambdabot> forall a. (forall s. ST s a) -> a
21:27:53 <dons> SamB: if its runST, then its not going to be of ST type.
21:27:59 <dons> lispy, sorry ^
21:28:01 <SamB> nornagon: well, you could just make sure you get a 1.0 before that point
21:28:21 <scook0> your floating-point numbers are broken by 0.1.1 anyway
21:28:31 <SamB> lispy: that type is fodder for runSTArray
21:28:42 <nornagon> this is why i prefer integer versions
21:28:47 <scook0> personally, I like the advantages of having version numbers that go past 9
21:29:03 <SamB> nornagon: these are integers
21:29:06 <SamB> with dots in between
21:29:11 <SamB> just like, oh, IP addresses
21:29:14 <nornagon> sneaky.
21:29:21 <SamB> except arbitrary-precision
21:29:25 <scook0> SamB: exactly, it makes much more sense once you realise that
21:29:37 <lispy> :t runSTArray
21:29:43 <lambdabot> Not in scope: `runSTArray'
21:29:49 <gwern> more importantly, you cannt mentally go read 0.10 :: Rational with dotted quad stuff
21:29:52 <lispy> ?hoogle runSTArray
21:29:53 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
21:30:05 <nornagon> i guess having a major and minor version does hint at how much each version has changed from the previous
21:30:12 <lispy> I was hoping to have STArray s i e at the top level
21:30:25 <lispy> ?hoogle newArray
21:30:27 <lambdabot> Foreign.Marshal.Array.newArray :: Storable a => [a] -> IO (Ptr a)
21:30:27 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
21:30:27 <lambdabot> Data.Array.MArray.newArray :: (MArray a e m, Ix i) => (i, i) -> e -> m (a i e)
21:30:41 <lispy> but newArray gives me an array in a monad
21:31:08 <lispy> thats' why I had the runST in there
21:31:11 <scook0> lispy: I'm not sure that can be done
21:31:42 <scook0> in fact, I think the whole point of the s type parameter is to prevent you from doing that sort of thing
21:32:12 <lispy> Hmm...When what did dons mean when he said yes to my question about having top level STArrays
21:33:39 <lispy> Having ST s (STArray s Int Int) at the top level isn't so bad.  I'm completely okay with that.  I just wanted to reduce to the most basic array I could.
21:33:51 <SamB> lispy: you aren't allowed to take STArrays outside of ST
21:34:03 <SamB> lispy: that violates the type of runST
21:34:20 <lispy> alright.  I'll use it this way then
21:34:55 <lispy> ?hoogle liftIO
21:34:56 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
21:34:56 <bd_> You can have ST RealWorld (STArray RealWorld Int Int) if you want to take it out of ST :)
21:35:09 <bd_> might as well use an IOArray then though
21:35:21 <hpaste>  scook0 pasted "precise permissive field of view screenshot" at http://hpaste.org/6178
21:35:22 <lispy> ?google liftST
21:35:22 <lambdabot> No Result Found.
21:35:24 <SamB> also, I might point out that runST is typed that way specifically to prevent you from doing that
21:35:34 <SamB> because it is not SAFE to do that
21:35:46 <scook0> eww, that didn't work out so well :(
21:35:57 <glguy> SamB: That sounds like ?yow output
21:36:06 <lispy> SamB: yeah, I knew runST and ST were typed to disallow unsafe things.  I just didn't realize that extracting an STArray from an ST monad was unsafe.
21:36:07 <gwern> the conjure email list bounched my patches
21:36:09 <gwern> how cruel
21:36:26 <SamB> lispy: turning it into an Array first is safe though
21:36:41 <SamB> gwern: it is?
21:36:43 <dons> lispy: if the type parameter depends on something inside the ST monad..
21:37:09 <gwern> SamB: it did
21:37:10 <SamB> gwern: I'll fix it...
21:37:11 <lispy> So let me tell you what I wanted this for.  The STArray is just the memory for a simulated machine.
21:37:21 <lispy> Using a mutable array seemed best, and I wanted to avoid IO.
21:37:32 * gwern has always depended on the kindness of strangers, SamB 
21:37:35 <bd_> lispy: Maybe use a diffarray?
21:37:36 <SamB> assuming it's the same old one
21:38:06 <lispy> bd_: no thanks, I want efficiently mutable
21:38:34 <dolio> DiffArray is efficiently mutable. Just not efficently persistent.
21:38:37 <gwern> SamB: conjure@lists.urchin.earth.li
21:39:17 <glguy> hurray for having gaim while an install runs, hurray for completed installs :)
21:39:23 <gwern> SamB: what email address should I send to?
21:39:34 <lispy> I plan on simulating the machine inside ST, so I think this is good, right and fine to use.
21:39:59 <bd_> lispy: If you're not just staying in ST or IO for the entire execution, then your 'interpreter state' data structure is pure, right? This means that in the interval between ST entries, it can be copied. So you'll need a datastructure made for that
21:40:01 <SamB> gwern: well, you could join the list I think...
21:40:35 <gwern> SamB: I dunno how to do that - I don't see any conjure homepages or mailman pages
21:40:42 <dolio> It uses an IOArray inside, and stores the changes necessary to compute older versions of the array, so if you only access the latest version, it's fine, but looking up things in old copies of the array is slow.
21:40:53 <SamB> gwern: hmm.
21:41:15 <dolio> Branching a single array in two paths is probably bad, too.
21:41:26 <SamB> http://urchin.earth.li/mailman/listinfo/conjure
21:41:28 <lambdabot> Title: Conjure Info Page
21:41:34 <bd_> dolio: I think it only hurts the first time you access it... not sure if it memoizes on read though
21:41:54 <lispy> dons: TBH, I've heard that about diff array.  But I don't really get how you would try/avoid accessing an 'old' copy.
21:42:23 <dolio> You'd use it single-threadedly, like a unique type in Clean.
21:42:30 <dolio> Only without the type system to tell you when you mess up.
21:42:48 <dolio> Just poor performance. :)
21:44:29 <syntaxfree> @seen lambdabot
21:44:29 <lambdabot> Yes, I'm here. I'm in #gentoo-uy, #rosettacode, #scannedinavian, #gentoo-haskell, ##logic, #xmonad, #unicycling, #perl6, #parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #
21:44:29 <lambdabot> haskell, #ghc and #darcs
21:45:02 <gwern> ok, my email made it to the list
21:45:11 <gwern> now the question is whether anyone will ever see it :)
21:47:22 <SamB> gwern: I just have to figure out how I stopped the torrent of moderation-related emails from that list...
21:49:58 <dmwit> ?hoogle [Either a b] -> ([a], [b])
21:49:59 <lambdabot> No matches, try a more general search
21:50:53 <syntaxfree> @free [a]->[(a,a,a)]
21:50:53 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
21:51:22 <dmwit> :t \es -> ([x | Left x <- es], [x | Right x <- es])
21:51:22 <dmwit> ?free map
21:51:25 <lambdabot> forall t t1. [Either t t1] -> ([t], [t1])
21:51:25 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
21:51:43 <dmwit> ?free map (\x  -> (x, x, x))
21:51:43 <lambdabot> Extra stuff at end of line
21:51:56 <dmwit> indeed
21:52:47 <dolio> @free foo :: [a] -> [(a,a,a)]
21:52:47 <lambdabot> $map ($map_Triple f f f) . foo = foo . $map f
21:56:18 <SamB> gwern: okay, I'm leaving the list in auto-reject mode, but now the rejection notice should include the mailman URL
21:56:19 <lQg_> how do i represent ^M or 0x0D in character escape sequence?
21:57:00 <lQg_> need to match the ^M character
21:57:18 <yondalf> lQg_: \r
21:57:23 <lQg_> kk thanks
21:57:49 <gwern> SamB: thanx
21:59:06 <SamB> gwern: I was getting an extremely high volume of spam via the moderation queue before I put it in auto-reject mode...
22:00:38 <cjb> hm, dumb data structure question -- I want to store a language-to-language dictionary in RAM and allow ajax-like searching when you type a partial string.  What's the favorite structure for that these days?
22:00:54 <dmwit> trie
22:01:22 <cjb> ok, standard non-suffix trie?
22:01:46 <cjb> I guess I could just throw these into an n-gram model or something, and have it find the partial matches for me?
22:02:10 <dmwit> You actually may want a directed a-cyclic graph for ultimate in-memory size savings.
22:02:24 <dmwit> Unfortunately, I do not have any pointers on where to look for more information.
22:03:44 <cjb> It sounds like the optimal is a "suffix tree".
22:03:48 <cjb> as distinct from a suffix trie.
22:05:03 <dons> a suffix tree is a trie like structure of the suffixes
22:05:28 <mmmpieX> a suffix array is very easy to implement, but not quite as fast to look up as a tree.
22:05:30 <cjb> dons: does it sound appropriate for storing many dictionary words to find based on any substring?
22:05:47 <dons> trees are probably easier in the haskell case, anyway
22:05:51 * cjb is looking forward to writing basic data structure stuff, it's been years.
22:05:53 <dons> data structures are a bit richer/simpler
22:06:05 <dons> cjb: sounds about right.
22:08:46 <mmmpieX> im just getting started with haskell, many of the examples Ive seen use atoi but when I use it I get an out of scope error. searched in hoogle, but no results there. does atoi exist ( Im using ghc ) or do I need to import a module?
22:08:59 <yondalf> @index atoi
22:08:59 <lambdabot> bzzt
22:09:12 <yondalf> @hoogle atoi
22:09:13 <Heffalump> use read
22:09:14 <lambdabot> No matches found
22:09:23 <faxathisia> @man atoi
22:09:23 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
22:09:33 <Heffalump> I'm not aware of an atoi, though perhaps there is one if you really want behaviour like the C function
22:09:36 <lispy> atoi is C
22:09:46 <yondalf> > (read "123") :: Int
22:09:50 <lispy> But, it's not safe C, right?
22:09:52 <lambdabot>  123
22:09:58 <lispy> oh wait, itoa is the unsafe one
22:10:02 <faxathisia> atoi is deprecated
22:10:07 <faxathisia> it's not thread safe
22:10:15 <yondalf> > show 123
22:10:19 <Heffalump> really? What the hell does it do?
22:10:30 <lambdabot>  thread killed
22:10:36 <faxathisia> turns a bit of a string to and int
22:10:40 <lispy> Heffalump: it if uses strtok then that would explain the thread-unsafety
22:10:41 <faxathisia> like
22:10:42 <mrd> static var probably
22:10:44 <Heffalump> I know that, but how does it do it unsafely?
22:10:46 <Heffalump> ah, right
22:10:48 <faxathisia> > read "123 *(@!*&#@!#" :: Int
22:10:52 <mrd> typical libc stupidity
22:10:53 <lambdabot>  Exception: Prelude.read: no parse
22:10:56 <faxathisia> eh..
22:10:58 <dolio> Sets gloal error variables?
22:11:17 <Heffalump> faxathisia: read doesn't handle prefixes
22:11:21 <wy> faxathisia: Have you tried Curry a functional logic language?
22:11:23 <Heffalump> use readS if you want that
22:11:29 <Heffalump> @type readS
22:11:33 <Heffalump> @type reads
22:11:33 <lambdabot> Not in scope: `readS'
22:11:34 <lambdabot> forall a. (Read a) => String -> [(a, String)]
22:11:35 <faxathisia> oh right
22:11:36 <faxathisia> thanks
22:11:38 <Heffalump> that, I mean
22:11:47 <dons> heya Heffalump. coming to the hackathon?
22:11:53 <Heffalump> dons: almost certainly.
22:12:02 <Heffalump> I should book flights
22:12:13 <faxathisia> no wy, it wouldn't compile for me. Certainly some very concise example code though it's impressive
22:13:00 <mrd> Haskell was almost named Curry
22:13:12 <SamB> ah, so tasty
22:13:39 <SamB> would have made the functions curry and uncurry too confusing though probably ;-)
22:13:51 <wy> I'm wondering the relation between Curry and kanren. Are they similar things?
22:13:55 <faxathisia> No
22:15:25 <faxathisia> kanren is still first order unification (in contrast to Prolog), but it's got much more rich primitives e.g. interleaving, I think curry has a few higher order things doesn't it?
22:16:21 <SamB> what does kanren taste like?
22:16:54 <faxathisia> chocolate coated aniseed
22:17:15 <wy> what does high order mean in this case?
22:20:43 <dons> Heffalump: yeah, so should i.
22:33:01 <setuid_w00t> Is it possible to write a lambda that extracts the third element from a tuple?
22:33:16 <yondalf> setuid_w00t: \(a,b,c) -> c
22:33:34 <setuid_w00t> yeah, that's it.  I didn't have the syntax quite right
22:33:39 <yondalf> in standard haskell you can't write one which works for any size, though
22:34:09 <yondalf> or better write \(_,_,x) -> x i think, i don't know if there will be warnings about unused or shadowed variables
22:34:58 <faxathisia> frst (x,_,_) = x ; scnd (_,x,_) = x ; thrd (_,_,x) = x
22:35:29 <yondalf> hmm...some people call them fst3, snd3 and trd3
22:36:59 <Androo> what should I do to make a function with type [a] -> [b] -> [(a,b)] (like zip) that only operates on lists with an equal number of elements but without using length?
22:37:31 <faxathisia> Androo: What is the complete behavior of this function?
22:37:56 <Cale> Androo: Well, you could just recurse.
22:38:32 <faxathisia> zip works on equal length lists... does it matter what happens when you use it on other sized lists?
22:38:49 <Cale> zip' [] [] = []; zip' (x:xs) (y:ys) = (x,y) : zip' xs ys
22:38:59 <Cale> That won't work for mismatched lengths.
22:39:14 <Cale> (It'll give a pattern match failure.)
22:44:00 <faxathisia> Androo: I'm curious if that was what youmeant?
22:44:47 <faxathisia> wy: I couldn't find the example.. but I was there was an example of defining a function my mapping a variable over a list (map being a higher order relation)
22:45:37 <Androo> I think I just got disconnected.  Did my question get through?
22:46:20 <SamB> your original question?
22:46:53 <glguy> Androo: what should this function do on mismatched lists?
22:46:59 <Cale> Androo: I gave a version of zip which wouldn't work on lists of not-equal length.
22:47:09 <Cale> Androo: (and otherwise operated like zip does)
22:52:37 <dogbite> quick question: how to convert an Integer to an Int?
22:52:51 <dogbite> i'm using the Date.Time.Calendar
22:53:00 <dogbite> and the year is an Integer
22:53:06 <dogbite> but the day and month is an Int
22:53:15 <faxathisia> :t fromIntegral :: Integer -> Int
22:53:18 <lambdabot> Integer -> Int
22:53:21 <dogbite> thanks
22:53:23 <faxathisia> this will work
23:01:28 <quicksilver> Cale: thanks.
23:03:57 <dogbite> toInteger $
23:03:59 <dogbite> oop
23:04:08 <dogbite> fromIntegral :: (Num b, Integral a) => a -> b
23:04:16 <faxathisia> @instances Num
23:04:17 <lambdabot> Double, Float, Int, Integer
23:04:21 <faxathisia> @instances Intergral
23:04:21 <lambdabot> Couldn't find class `Intergral'. Try @instances-importing
23:04:29 <faxathisia> that's everything it can work on
23:04:45 <dogbite> i see
23:04:53 <wagle_home> @instance Integral
23:04:54 <lambdabot> Maybe you meant: instances instances-importing
23:05:00 <wagle_home> @instances Integral
23:05:13 <dogbite> let n = 4
23:05:15 <lambdabot> Couldn't find class `Integral'. Try @instances-importing
23:05:19 <dogbite> @type n
23:05:28 <lambdabot> Expr
23:05:43 <faxathisia> :t 4
23:05:48 <lambdabot> forall t. (Num t) => t
23:05:49 <dogbite> if i use fromIntegral in an expression
23:05:54 <dogbite> then that works
23:05:59 <dogbite> but the 'Int' type doesn't stick
23:06:17 <faxathisia> :t 4 :: Int
23:06:17 <wagle_home> @let n = 4
23:06:21 <lambdabot> Defined.
23:06:21 <lambdabot> Int
23:06:26 <wagle_home> :t n
23:06:27 <lambdabot>     Ambiguous occurrence `n'
23:06:27 <lambdabot>     It could refer to either `L.n', defined at <local>:1:0
23:06:27 <lambdabot>                           or `SimpleReflect.n', imported from SimpleReflect at State/imports.h:69:0-32
23:06:49 <wagle_home> :t L.n
23:06:52 <lambdabot> forall t. (Num t) => t
23:07:25 <wagle_home> dogbite, you forgot the @ on the @let
23:08:11 <glguy> :t n
23:08:17 <lambdabot> Expr
23:08:44 <dogbite> got it
23:09:00 <dogbite> @let myint = 4
23:09:06 <dogbite> @type myint
23:09:09 <lambdabot> Defined.
23:09:12 <lambdabot> forall t. (Num t) => t
23:09:29 <faxathisia> :t 4
23:09:30 <lambdabot> forall t. (Num t) => t
23:09:57 <dogbite> this Int vs Integer is driving me crazy
23:10:13 <faxathisia> > maxBound :: Int
23:10:17 <lambdabot>  2147483647
23:10:28 <dogbite> well in my lifetime
23:10:32 <dogbite> that will be sufficient for years
23:10:33 <faxathisia> > ( 2147483647 + 3 , 2147483647 + 3 ) :: ( Int , Integer )
23:10:34 <lambdabot>  (-2147483646,2147483650)
23:10:41 <lispy> SamB: I was just looking at MIX and I'm suprised by how many instructions it has
23:11:10 <faxathisia> dogbite: Is it possible to just use Integer the whole time? It makes correctness a lot simpler
23:11:21 <faxathisia> in many cases
23:11:31 <lispy> and Integer is pretty high preformance in GHC
23:11:40 <Adamant> I want an excuse to write some code in Haskell. are there any networking/security/crypto libraries that are needed by the community?
23:11:44 <lispy> Int is faster, but, hey probably not by a lot
23:13:03 <dogbite> well
23:13:13 <dogbite> when do Int's arrise?
23:13:17 <faxathisia> :t length
23:13:22 <dogbite> what gives rise to an Int versus an Integer?
23:13:25 <lambdabot> forall a. [a] -> Int
23:13:28 <faxathisia> Cale :P
23:13:43 <faxathisia> :t let length = foldr (1+) 0 in length
23:13:45 <lambdabot> forall b. (Num b, Num (b -> b)) => [b -> b] -> b
23:13:56 <faxathisia> oops .. not quite what I meant
23:14:12 <ohub> Adamant; I would like to see SSH server/client socket :)
23:14:20 <faxathisia> why not fix length etc
23:14:30 <Adamant> you mean something like libSSH in haskell?
23:14:48 <dogbite> well i need to go all Int or all Integer
23:14:51 <Adamant> that would be a cool project actually
23:14:52 <dogbite> you guys suggest Integer?
23:15:08 <scook0> glguy: is hpaste supposed to behave correctly in the presence of unicode?
23:15:14 <wagle_home> you mean that my 32 bit machine has a bug that my 64 bit machine doesnt?  8)
23:15:40 <faxathisia> :t let length = foldr (const (1+)) 0 in length
23:15:41 <lambdabot> forall a t. (Num t) => [a] -> t
23:15:48 <faxathisia> @let length = foldr (const (1+)) 0
23:15:49 <lambdabot> Defined.
23:16:18 <sm> evening all
23:16:35 <sm> why doesn't main = interact reverse show each line of input reversed ?
23:16:53 <sm> and how would you tell it when input is finished ?
23:17:00 <lispy> SamB: I count 144 total instructions in MIX
23:17:15 <glguy> scook0: hpastetwo works with it
23:17:23 <lispy> sm: if you're using interact you're at the mercy of stdio buffering
23:17:23 <glguy> scook0: utf8-string came out after hpaste :)
23:17:31 <glguy> and hscolour fails on utf8 bytes
23:17:34 <faxathisia> dogbite: Yes
23:17:35 <lispy> sm: er stdin
23:17:42 * sm was testing in an emacs shell buffer
23:17:46 <lispy> sm: so if you use it from ghci it won't do lines
23:17:52 <sm> it prints each line of input.. just not reversed
23:18:04 <scook0> glguy: ah, just checking if I should report a bug
23:18:04 <lispy> :t interact reverse
23:18:09 <lambdabot> IO ()
23:18:12 <sm> I did switch to runhaskell
23:18:23 <glguy> scook0: old hpaste isn't "easy to build"
23:18:28 <glguy> for me at this time
23:18:42 <radetsky> anybody used the latest hscurses?
23:19:43 <radetsky> it doesn't seem to link in curses properly
23:19:57 <sm> so I'm mystified..
23:20:58 <sm> Try the experiment of going round your colleagues, inviting them to write a simple program to say, read in a string, reverse it and output it. It is shocking to discover how few of your colleagues will be able to swing round, open a file and type in such a program. -- http://the-programmers-stone.com/page/2/
23:20:58 <lambdabot> Title: The Programmers&#8217; Stone
23:21:11 * sm failed :/
23:23:18 <wagle_home> besides handling really large or infinite strings, whats hard?
23:23:32 <radetsky> gwern: you there?
23:23:43 <scook0> sm: main = interact (unlines . map reverse . lines) seems to work for me
23:24:34 <scook0> and interact reverse seems to work if you Ctrl-D at the end of your string
23:25:17 <sm> scook0: thanks, that's illuminating
23:26:12 <sm> wagle_home: without consulting docs, many might find this hard
23:27:10 <sm> ah well, I console myself that reading from keyboard is a special domain, naturally unfamilar to web developers like myself
23:27:24 <wagle_home> ah, the url seems to be talking about the stress of being put on the spot, in-person, and then not being able to program
23:27:29 <faxathisia> sm: I just write: reverse
23:27:29 <sm> and in haskell I came closest
23:27:43 <faxathisia> sm: The IO doesn't matter does it?
23:28:20 <radetsky> @seen gwern
23:28:20 <lambdabot> gwern is in #xmonad and #haskell. I last heard gwern speak 1h 30m 31s ago.
23:28:40 <wagle_home> i've lectured enough that i've gotten used to thinking/programming in front a a crowd..  first day after not lecturing for a while, my mind would go blank again
23:29:10 <wagle_home> ... of a crowd
23:29:32 <glguy> scook0: was looking at the monads in the new hpaste of any use?
23:30:41 <scook0> yeah, quite helpful actually
23:30:46 <wagle_home> <ahu> http://www.doingitwrong.com/wrong/20070526-100929.jpg
23:31:04 <sm> faxathisia: well he did say write a program to...
23:32:18 <scook0> it didn't quite address my original concern, but at least it's encapsulated a bit more
23:48:30 <Androo> how can I rewrite zip to require input lists to be of the same length, but not use the length function to do it?
23:51:33 <wagle_home> homework assignment?
23:52:17 <faxathisia> Androo: What would happen if the lists are different length?
23:53:57 <Androo> faxathisia: function would evaluate to Just(zip x y)
23:54:11 <faxathisia> Don't you mean Nothing?
23:54:12 <tibbe> can I somehow using Typeable automatically derive instances of Show for functions?
23:54:15 <faxathisia> If they are different length
23:55:15 <Androo> Nothing if x and y have a differing number of elements, right
23:56:38 <faxathisia> hmm
23:56:52 <faxathisia> what about this case?
23:57:03 <wagle_home> > do x <- Nothing ; Just x
23:57:07 <faxathisia> ziq [1..] ([1..]++[1..])
23:57:08 <faxathisia> ?
23:57:08 <lambdabot>  Nothing
