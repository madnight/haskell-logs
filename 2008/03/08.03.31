00:42:03 <hpaste>  juhe pasted "xmonad.hs" at http://hpaste.org/6750
01:24:31 <gabor_> anyone here who can say how the readline lib gets installed under cygwin?
01:25:38 <gabor_> the *haskell* readline lib
01:39:10 <cjs> Hm. So I'm implementing this network protocol, and it's got requests (and responses) such as "login", "logout", etc. etc. I need to map these to various codes, e.g., "01100" and "01102" (these sequences of bytes actually go across the wire as part of a packet). What's the typical way to do this? Have a "data RequestCode = Login | Logout" and a mapping function, "wireRequestCode Login = "01100"; wireRequestCode Logout = "01102" ?
01:40:46 <quicksilver> cjs: yes
01:40:51 <Korollary> That's called serialization. Haskell uses the Show class.
01:41:04 <quicksilver> No, it doesn't. Bad Korollary *slap*
01:41:11 <Korollary> ?
01:41:13 <quicksilver> the Show class is for debugging, not for serialisation.
01:41:14 <cjs> Mmm...I should probably keep show for user-friendly display....
01:41:36 <quicksilver> the Show class should generall produce valid haskell code, so show Login should be "Login"
01:41:41 <Korollary> Where does it say that it was for debugging?
01:41:51 <quicksilver> just there, where I wrote it down :P
01:42:01 <quicksilver> (IOW, this is my opinion. But it is strongly held)
01:42:07 <Korollary> By you
01:42:08 <cjs> Ah, valid Haskell code. Makes sense.
01:42:27 <quicksilver> it is extremely useful to have a Show which produces haskell code.
01:42:32 <quicksilver> helps you testing stuff in ghci
01:42:40 <quicksilver> and copy-pasting test cases into regression test suites
01:42:41 <quicksilver> etc.
01:42:53 <cjs> Anyway, converting stuff to wire format is fairly involved, when it comes to producing the full packet, so something tells me I want specialized functions for dealing with that kind of stuff.
01:42:53 <Korollary> also see http://code.haskell.org/binary/
01:42:54 <lambdabot> Title: Data.Binary - efficient, pure binary serialisation for Haskell
01:43:21 <cjs> Keep in mind, this is not serialized objects, this is a wire protocol.
01:43:50 <cjs> E.g., things like "source" and "dest" vary, and are reversed in requests and responses, and so on.
01:44:31 * quicksilver nnods
01:48:11 <cjs> One of the things that would be handy would be a way to convert Ints of 0-99999 to 5-char Strings holding the ASCII representation in decimal, e.g., 33 -> "00033". That's the format in which one does, e.g., request codes, source/dest addresses, message lengths, etc. Thoughts on a nice typechecked way to do that?
01:52:23 <quicksilver> cjs: take 5 . show ?
01:52:39 <quicksilver> ah.
01:52:54 <quicksilver> take 5 . show . (+100000)
01:53:03 <opqdonut> reverse.take 5.(++repeat '0'). reverse . show
01:53:05 <quicksilver> no, that's not right.
01:53:08 <TSC> printf, if you'll relax the "typechecked" requirement (:
01:53:26 <quicksilver> yeah, what opqdonut said, or similar.
01:53:32 <opqdonut> yeah
01:53:37 <opqdonut> one could just prepend 5 zeros
01:53:43 <opqdonut> instead of omega
01:53:59 <quicksilver> format | x > 0 && x < 99999 = drop 1 . show $ 100000 + x
01:54:09 <quicksilver> maybe best to have the constraints explicit
01:54:16 <quicksilver> format x | x > 0 && x < 99999 = drop 1 . show $ 100000 + x
01:54:17 <quicksilver> even
01:55:47 <opqdonut> quicksilver: yeah, and typed Integer->String
01:56:06 <opqdonut> oh well, i guess you could rely on Int being big enough
01:57:55 <cjs> I'm kinda wondering if there's a way to type it so that "format5 33" produces "00033", "format5 123456" produces a compile error, and "format5 n" forces me to write code to deal with the potential error (a la Maybe).
01:59:00 <vegai> template haskell, perhaps
02:00:07 <quicksilver> cjs: you can't get compile-time errors out of integer literals.
02:00:18 <glguy> the type of a number can't be based on its value
02:00:18 <quicksilver> cjs: (without using TH)
02:00:27 <glguy> (in Haskell's type system)
02:00:37 <cjs> Hm. I see.
02:01:15 <cjs> Well, I'm sure I'll find some solution. It's extremely important to me that I don't blow up at runtime.
02:03:30 <quicksilver> format x | x > 0 && x < 99999 = Just . drop 1 . show $ 100000 + x
02:03:35 <quicksilver> format _ = Nothing
02:03:41 <quicksilver> (format :: Int -> Maybe String)
02:03:58 <Deewiant> s/</<=/
02:04:00 <quicksilver> unsafeFormat = fromJust . format
02:04:05 <quicksilver> (if there are times when you are sure)
02:04:12 <haraldk> cjs: perhaps you could make it return some kind of pattern-matchable value so that you get an incomplete match warning if you don't have error handling in place
02:04:16 <quicksilver> Deewiant: yes :) I was too lazy to correct it.
02:04:32 <Deewiant> and why 'drop 1' instead of just 'tail'?
02:05:36 <haraldk> but of course it would be circumventable... and inconvenient for constants :-)
02:05:56 <quicksilver> Deewiant: habit.
02:06:05 <quicksilver> (possibly a bad one)
02:06:11 <cjs> Because "drop 1" removes the "1" from the front of the String! :-)
02:06:16 <quicksilver> cjs++
02:06:16 <Cale> Deewiant: drop 1 is a good habit, as tail will kill your program if passed an empty list
02:06:39 <glguy> and no one likes to find out their programs have bugs ;)
02:06:48 <Deewiant> here we know that the length of the resulting list is at least 1, though
02:06:53 <Cale> right
02:06:54 <Deewiant> (at least 6, in fact)
02:07:02 <Cale> So it doesn't actually matter in this case
02:07:15 <Deewiant> true that.
02:10:57 <quicksilver> Cale: there are cases where crashing is better than silently doing the wrong thing, too
02:11:11 <quicksilver> Cale: (q.v. dynamic languages!)
02:12:06 <quicksilver> the main reason I've become accustomed to using drop is that you can safely iterate it.
02:12:09 <quicksilver> which is a useful idiom
02:12:25 <quicksilver> > takeWhile (not.null) . map (take 3) . iterate (drop 3) $ [1..]
02:12:31 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23,...
02:12:51 <cjs> I generally prefer crashing. But I prefer the compiler telling me I need to handle an error even more.
02:13:24 <haraldk> generally? are there times you prefer silent corruption? :-P
02:13:51 <cjs> For certain pissy clients, yes. :-)
02:14:11 <quicksilver> I prefer nondeterministic code and intriguing emergent behaviour.
02:14:17 <quicksilver> "Wow! I didn't know it could do that..."
02:15:54 <cjs> Some clients refuse to accept logic. You try to explain to them that a consistent system can't be built to their requirements, they refuse to budge, so you build something that slowly corrupts itself.
02:16:03 <cjs> (Or sometimes very quickly, after a long wait.)
02:16:25 <cjs> Those are the sorts of clients from whom you can earn a lot of money doing debugging.
02:27:33 <cjs> So for parsing stuff coming back from the network, is a Parsec-kinda thing a pretty standard way to do it?
02:32:43 <cjs> Wow! Ghc shows "\001\002" as "\STX\ETX".
02:32:50 <cjs> That's pretty old-school.
02:33:03 <wagle_home> its ascii
02:33:35 <cjs> Indeed. Like, from TTY days. (Noisy buggers, they were.)
02:34:23 <solrize_> i think you should use an enumeration and an intmap
02:34:24 <wagle_home> even unicode: "... The UCS characters 0x0000 to 0x007f are identical to those of the classic US-ASCII character set ..."
02:34:44 <solrize_> or regular map
02:34:55 <wagle_home> TTY's were ebcdic or something
02:34:57 <solrize_> the idea is to have an arbitrary ordering on those codes so you can look up the strings in a table
02:37:13 <cjs> No, the traditional ASR-33 was ASCII.
02:37:43 <cjs> Well, I think that they also had other encodings available, BAUDOT or whatever, but I never saw any of those.
02:38:07 <cjs> solrize_: are you talking about my parsing?
02:38:38 <wagle_home> yeah, you are right..  i thought ascii was mid to late 1970's...
02:38:42 <solrize_> cjs yeah
02:39:16 * wagle_home reads http://en.wikipedia.org/wiki/Teletypewriter
02:39:17 <lambdabot> Title: Teleprinter - Wikipedia, the free encyclopedia
02:39:19 <cjs> Hm. But I will also have to deal with, e.g., variable length fields after the header where the first byte is an encoded length and that number of bytes after that are data.
02:39:41 <solrize_> oh, on the reading side?  use data.binary
02:40:43 <solrize_> i asked about something similar last week, specifically whether it made sense to use parsec3
02:40:57 <solrize_> the answer was that in principle parsec3 should work, but it hadn't really been tested for such things (binaries)
02:41:06 <wagle_home> there are all sorts of tools for handling marshalling data over the network
02:41:22 <quicksilver> cjs: if your parsing is not particular complex from a grammar perspective
02:41:29 <quicksilver> then Data.Binary is likely a much better match
02:41:33 <cjs> Ah!
02:41:40 <quicksilver> most over-the-wire protocols are not really complex grammars
02:41:54 <cjs> Ok. BTW, I'm not marshalling data, I'm building a protocol. There's a subtle but definite difference.
02:41:55 <quicksilver> (complex grammars arise from the desire to make something look nice to humans, generally)
02:42:07 <cjs> Yeah, the grammar for this is pretty simple, if rather dumb.
02:42:14 <wagle_home> i just never did it myself (so donot have a set of recommedations), but have watched on as a lot of other people did
02:42:14 <quicksilver> Data.Binary.Get works well for protocols
02:42:20 <cjs> (It's GL's market data/trading protocol.)
02:42:21 <quicksilver> Data.Binary is two packages, areally
02:42:29 <quicksilver> it has a low-level package Get/Put
02:42:40 <wagle_home> it handles endian stuff?
02:42:40 <quicksilver> which just deals with parsing bytes conveniently
02:42:45 <quicksilver> yes, it does.
02:42:50 <quicksilver> it has primitives for whatever endian you want
02:42:58 <quicksilver> and then there is a high-level package Binary
02:43:05 <quicksilver> which is about marshalling actual haskell types
02:43:10 <quicksilver> likely cjs wants the former not the latter.
02:44:17 <cjs> Yeah. I don't even have endian anything to deal with, bar one 16-bit LE length attribute. Everything else is ASCII.
02:44:48 <wagle_home> the tools i've glanced at seem to take whole sets of data structures and set up the marshalling and unmarhalling for you
02:45:40 <wagle_home> ..  with stubs that call in/out to your code
02:46:19 <wagle_home> but this is mostly C code support..  8/
02:46:39 <wagle_home> are there higher level tools too in haskell?
02:49:14 <solrize_> er, data.binary ?
02:49:17 <solrize_> parsec ?
02:54:30 <wagle_home> i'm talking more like "grammar generators"..  i had the feeling that you took a grammar and fed it into parsec
02:54:53 <cjs> You declare a grammar in Haskell code.
02:55:03 <solrize_> i guess i don't understand what you mean
02:55:17 <solrize_> you want to put in a diagram-like picture of the wire format and get a parser out?
02:56:51 <earthy> solrize: no. you write down the grammar, basically
02:57:06 <earthy> solrize: and the combinators 'generate' a parser from it
02:57:27 <solrize_> that doesn't sound like what wagle was asking
02:57:28 <wagle_home> no.. (i'm not entirely clear on what i'm talking about, so am seeing if anyone can fill in the blanks)..  more like hand it a datastructure, and maybe some sort of protocol description, and the thing outputs a skeleton that calls and gets called by code you write
02:57:31 <solrize_> that sounds like parsec
02:57:44 <bringert> well, with parsec you have to do a bit more than write the grammar: you have to sprinkle it with 'try' in the right places
02:57:44 <lambdabot> bringert: You have 1 new message. '/msg lambdabot @messages' to read it.
02:57:49 <solrize_> which apparently generates pretty slow parsers
02:57:59 <Peaker> how is a (-) section created?
02:58:00 <earthy> parsec slow?!
02:58:03 <earthy> the mind boggles. ;)
02:58:23 <solrize_> yeah, dons says happy generates much faster parsers
02:58:27 <Cale> Peaker: (x-)
02:58:29 <earthy> parsec doesn't use bytestring, that might account for some slowness, but in general parsec is pretty quick
02:58:38 <Cale> Peaker: (-x) isn't a section of course
02:58:55 <bringert> wagle_home: have you looked at alex/happy?
02:58:58 <solrize_> well i haven't measured it but the speeds its docs describe don't sound fast
02:59:04 <bringert> wagle_home: or BNFC for more automation
02:59:05 <Cale> Peaker: For that, you can use (+(-x))
02:59:06 <Peaker> Cale, so can't have a second-arg-bound section?
02:59:12 <wagle_home> i think i'm thinking mostly about things like rpcgen, which surely has been replaced by something else by now
02:59:13 <Peaker> Cale, ah, thanks
02:59:49 <bringert> wagle_home: I think there is some ASN.1 stuff for haskell. never used it though
02:59:53 <Cale> Or if for some odd reason it really must be - and not +, you can use the Prelude function 'subtract'
03:00:15 <Cale> Which was added as a kind of apology for that wobble in the syntax.
03:00:26 <solrize_> i notice that bytestring.lazy by default reads chunks of 64 kbytes and i've been trying to find out how to increase that amount, does anyone know?
03:00:49 <wagle_home> bringert, no, but i will
03:05:47 <wagle_home> bringert, no, i'm thinking more in terms of things that generate the grammars that get input to such things..  but if no-one knows what i'm talking about, then we should just drop it, because I dono't know that i'm talking about something that actually exists (other than some what a modern version of my vague notion of what rpcgen does)
03:05:49 <Peaker> Cale, heh
03:06:16 <Peaker> pretty cool that I can create these crazy Monad Transformer games, without even fully understanding all the intracacies, and if I satisfy the type system, it works :)
03:06:40 <wagle_home> uh..  that doesnt scan very well..  i needed to get sleep an hour ago..  i'll give up
03:06:49 <Cale> :)
03:06:55 <Cale> g'"night"
03:07:03 <Cale> (6am ;)
03:08:32 <solrize_> wagle what you're describing sounds like it takes a datatype description and makes the serialization format
03:09:10 <cjs> Gah!
03:10:03 <cjs> I must remember parens. "return (c:cs)" rather than "return c:cs". This keeps biting me.
03:10:18 <cjs> I hope that this sort of thing goes away after another week or two.
03:10:23 <quicksilver> cjs: bites most people for a while :)
03:10:26 <quicksilver> you get used to it though.
03:10:33 <cjs> What, beting bitten?
03:11:01 <cjs> Haskell: Because it feels so good when you finally get your program to compile.
03:11:50 <SamB> cjs: no, needing parens!
03:11:55 <ziman> and then it usually works well ;)
03:12:16 <zeno`> would be interesting to have not using spaces imply parens
03:12:19 <SamB> ziman: I wish you would tell JHC that
03:13:41 <Deewiant> I just automatically write "return$" nowadays
03:14:05 <quicksilver> zeno`: it's interesting but I tink I probably woudln't like it
03:14:13 <quicksilver> zeno`: semantics changing by missing out a space...
03:16:00 <zeno`> quicksilver: when can you leave spaces out anyways? just on built in stuff like : + etc?
03:18:12 <kuribas> I am reading "The Art of Computer Programming".  I wonder if haskell is has a disadvantage, because it is hard to reason about the execution (time and space) of algorithms.
03:18:12 <lambdabot> kuribas: You have 1 new message. '/msg lambdabot @messages' to read it.
03:18:36 <cjs> Is it? I thought it was supposed to be easier to reason about time and space.
03:18:38 <quicksilver> zeno`: always, around operators.
03:18:50 <quicksilver> zeno`: except '.' which is overloaded :(
03:19:10 <vegai> cjs: laziness can create surprises
03:19:48 <cjs> c.f. around Chapter 14 of Hudak, last couple of chapters of Hutton.
03:20:07 <zeno`> cjs: in the haskell book i was reading it said you have to be really careful about memory leaks
03:21:21 <cjs> Dealing with lazyness and where to use ~ was exactly what the beginning of chapter 14 in Hudak was all about, wasn't it?
03:21:46 <cjs> And Haskell doesn't "leak" per se: you still need all those values! :-)
03:22:08 <kuribas> Which book?
03:22:18 <zeno`> cjs: ah sorry havnt read it; does ~ make something strict?
03:23:00 <nominolo> no
03:23:02 <nominolo> lazy
03:23:07 <cjs> It makes a pattern lazy.
03:23:25 <nominolo> use ! ("bang") for strictness
03:23:40 <nominolo> eg. data Foo = Foo !Int
03:24:06 <Deewiant> > let ~1 + 1 = 1 in 6 + 1
03:24:07 <lambdabot>  1
03:24:13 <cjs> Actually, I've not worked my way though the examples in detail, but 14.4 seems a very good explanation of keeping at least one kind of thing (basically, a sort of deadlock that eats memory forever) from biting you.
03:24:45 <cjs> (Ironically enough, I just fixed a deadlock in my Ruby test framework for this Haskell program I'm working on.)
03:27:30 <cjs> How do I show an Int in hex?
03:27:52 <quicksilver> :t showHex
03:27:54 <lambdabot> forall a. (Integral a) => a -> String -> String
03:28:11 <cjs> Doh!
03:28:40 <quicksilver> ask and ye shall receive?
03:29:17 <cjs> Ooo...but tricky to use. It's using that ShowS thing.
03:29:48 <quicksilver> > showHex 255 ""
03:29:49 <lambdabot>  "ff"
03:29:52 <quicksilver> not *very* tricky.
03:29:53 <cjs> Oh, it's just an accumlator.
03:30:56 <Deewiant> > foldr showHex "" [0xab, 0xcd, 0x12, 0x34]
03:30:57 <lambdabot>  "abcd1234"
03:31:16 <cjs> Yeah, well, new types scare me. It's like walking down a dark alley, with all of these strange types in the shadows, wondering all the time if someone's going to whack you on the back of the head with a Monad.
03:34:16 <kuribas> dolio: ping
03:34:21 <dolio> pong
03:34:26 <quicksilver> cjs: :)
03:34:33 <kuribas> dolio: I got your message.
03:34:50 <kuribas> Can you give an example that doesn't work?
03:34:56 <dolio> What was it about? Type families?
03:35:31 <kuribas> dolio said 5d 17h 24m 39s ago: haskell-indentation doesn't like
03:35:31 <kuribas> 	    type instance declarations (it seems to be okay with type family).
03:36:00 <quicksilver> kuribas: I've been pushing your indentation mode to quite a few people who were complaining about the standard one :)
03:36:23 <dolio> I think I can give you a couple failing examples at the moment...
03:36:55 <quicksilver> kuribas: I've had a couple of "lisp max nesting exceeded" or something
03:36:58 <quicksilver> which is annoying
03:37:00 <dolio> "type instance F a = Int"
03:37:16 <kuribas> quicksilver: Hm, that's really a problem.
03:37:20 <dolio> That won't let you enter any more lines, saying "illegal token: instance"
03:38:05 <dolio> Also: class C a where data F a :: *
03:38:15 <dolio> That gets "illegal token: data"
03:38:19 <kuribas> Is that standard haskell?
03:38:44 <dolio> It's part of the new type families/associated types extension.
03:39:34 <Peaker> how do you divide a Word8 by 2? Do you have to convert it to an integral, divide, and then truncate back, and fromIntegral?
03:39:59 <quicksilver> Peaker: no.
03:40:03 <quicksilver> Peaker: `div` 2
03:40:04 <Japsu> can you bitshift word8s?
03:40:15 <quicksilver> > (125 :: Word8) `div` 2
03:40:15 <lambdabot>  62
03:40:19 <Peaker> quicksilver, thanks
03:40:21 <quicksilver> Japsu: yes. There are in Data.Bits.
03:40:22 <dolio> 'data instance ...' and 'class C a where type ...' also fail, of course. I think 'newtype' is a valid token too.
03:40:28 <Japsu> does the compiler optimize a `div` 2 into a bit shift?
03:40:30 <kuribas> dolio: Right.  I'll go through the ghc documentation to see what I have to change.
03:41:33 <quicksilver> Japsu: I suspect not.
03:41:53 <quicksilver> are bit shifts actually faster on modern CPUs anyway?
03:42:00 <dolio> I think that was it.
03:42:03 <quicksilver> surely integer division is only one cycle, too.
03:42:13 <Deewiant> integer division is many more cycles than one
03:42:17 <quicksilver> really?
03:42:18 <Deewiant> even multiplication is over 10 cycles
03:42:24 <Deewiant> division is like 30 at least, I think
03:42:30 <Japsu> on renesas H8S integer division is something like 19 cycles ;)
03:42:37 <Deewiant> okay, so around 20
03:42:42 <Japsu> dunno about x86 and the like, I've only done assembly for H8S ;)
03:42:51 <helmut> hi. since upgrading ghc6 I get messages like these:  In function `r2Xm_info':
03:42:53 <helmut> (.text+0x116ca): undefined reference to `containerszm0zi1zi0zi1_DataziIntMap_lookup_closure'
03:43:05 <Japsu> though there's a good chance I'll have to learn sparc assembly pretty soon
03:43:14 <helmut> can I do something about this?
03:43:18 <quicksilver> helmut: probably you need to recompile all your various stuff that was compiled with the old version.
03:43:20 <Peaker> division/multiplication with the SSE/MMX/3dNow extension stuff is even less than 1 tick, per word
03:43:25 <quicksilver> helmut: I'm guessing that's what that means.
03:43:31 <helmut> quicksilver: I did make clean
03:43:38 <quicksilver> other libraries you depend on though?
03:43:43 <quicksilver> stuff you've installed from hackage?
03:43:44 <helmut> mtl
03:43:48 <quicksilver> hmm
03:43:50 <helmut> everything through debian
03:43:50 <quicksilver> odd then
03:43:59 <quicksilver> should be fine :(
03:44:06 <Deewiant> http://www.agner.org/optimize/ says that the latency of a 32-bit DIV is 39 cycles
03:44:06 <lambdabot> Title: Software optimization resources. C++ and assembly. Windows, Linux, BSD, Mac OS X
03:44:09 <Deewiant> on AMD64
03:44:16 <quicksilver> Japsu: I'm not entirely sure `shiftR` will compile to the correct opcode, anyway :)
03:44:24 <helmut> quicksilver: so I can reportbug that?
03:44:34 <Deewiant> and 21 on Pentium 4
03:44:47 <quicksilver> Japsu: on the other hand, `div`2, if you go via-C, probably will :)
03:44:51 <Deewiant> whereas multiplications are around 3-5 cycles, not 10 like I said :-/
03:44:55 <quicksilver> since GCC will convert divides to shifts.
03:45:02 <quicksilver> Deewiant: interesting.
03:45:03 <Japsu> hmm
03:45:08 <SamB> I'm fairly certain that shiftR will not compile to an opcode
03:45:16 <Japsu> evil :/
03:45:38 <SamB> I should probably post the bug report I wrote in a notebook a week or so ago...
03:45:49 <quicksilver> Japsu: JaffaCake has grand plans for GHC native code gen and I think we should confidently expect it to get much better over the next 12 months.
03:45:56 <Japsu> yay \o/
03:46:10 <Peaker> quicksilver, what advantages does native code generation have over intermediate C?
03:46:17 <quicksilver> Peaker: better code.
03:46:26 <quicksilver> Peaker: C is a poor intermediate language for GHC.
03:46:37 <quicksilver> the calling conventions and register conventions are all wrong.
03:46:44 <quicksilver> GHC wants to do its own register allocation etc.
03:46:57 <SamB> the problem is actually nothing to do with the codegen -- it's to do with the inliner, and the fact that shiftR for some reason wants to do shiftL if you call it with a negative shift...
03:47:00 <Peaker> ah, I see
03:47:43 <quicksilver> there are also rumours about a student or someone working on getting sparc native codegen compiling nicely to the ultrathreaded sparc chips
03:47:47 <quicksilver> that would be shiney.
03:48:05 <SamB> (the inliner isn't smart enough to know that the conditional will dissapear if it inlines the function!)
03:48:47 <SamB> personally, I don't think that shiftL and shiftR should be trying to do anything in particular when called with negative arguments...
03:49:16 <desegnis> helmut: How do you compile the program where you get that linker error?
03:50:39 <Peaker> quicksilver, but so many of us are on x86-64...
03:51:18 <hpaste>  helmut pasted "ghc6 compile fail" at http://hpaste.org/6751
03:51:18 <cjs> Aw right! I successfully sent my first packet using Haskell.
03:51:33 <helmut> desegnis: does that contain the information you need to know?
03:51:40 <quicksilver> cjs: was it wrapped in brown paper and tied up with string?
03:52:00 <SamB> quicksilver: I'm betting it was a TCP/IP packet
03:52:09 <SamB> or, failing that, a UDP packet
03:52:15 <quicksilver> helmut: try --make instead of -package mtl?
03:52:18 <cjs> Pretty close. And it only took me, hmm....seven hours.
03:52:29 <quicksilver> and try ghc-pkg list
03:52:36 <quicksilver> (how many times does 'mtl' appear in that list?)
03:52:40 <quicksilver> or containers, indeed.
03:52:48 <cjs> helmut: Actually, a data packet on a layer above TCP.
03:52:57 <cjs> Oops, I meant SamB.
03:52:57 <desegnis> helmut: I think you're a victim of the base split. So yes, try --make or -package containers
03:53:10 <SamB> cjs: above TCP?
03:53:43 <helmut> base split?
03:54:00 <SamB> helmut: the package "base" has had some things split out of it recently
03:54:17 <helmut> ah.
03:54:19 <SamB> including bytestring (again) and some data types
03:54:37 <SamB> like Data.Set, Data.Map, Data.IntMap...
03:54:48 <cjs> SamB: Yes. A sequence of bytes, sent over TCP, that forms a single unit of data read by the remote end.
03:55:00 <SamB> (I wish they would have left Data.Map in and split out Data.HashTable instead)
03:56:25 <quicksilver> SamB: Data.HashTable is required for ghc which is why it is in base, I believe.
03:56:35 <helmut> /usr/lib/ghc-6.8.2/lib/containers-0.1.0.1/Data/IntMap.hi is contained within the ghc6 package on debian unstable
03:56:55 <quicksilver> do you have libghc6-containers-dev?
03:56:59 <quicksilver> or whatever that is called?
03:57:18 <helmut> there is no such package
03:57:30 <quicksilver> is there not?
03:57:34 <quicksilver> what's this then: http://packages.debian.org/sid/libghc6-containers-dev
03:57:36 <lambdabot> Title: Debian -- Details of package libghc6-containers-dev in sid
03:57:42 <quicksilver> oh, it's virtual.
03:57:43 <quicksilver> hmms.
03:58:06 <quicksilver> that's odd.
03:58:18 <quicksilver> looks like the debian package might be fubar?
03:58:30 <desegnis> the containers package is installed, obviously. helmut, are you willing to tell us whether what we propsed works?
03:58:37 <helmut> quicksilver: ok. ghc6 provides libghc6-containers-dev
03:58:55 <helmut> quicksilver: so to speak I have that virtual package provided
03:59:01 <quicksilver> nod
03:59:21 <helmut> desegnis: well actually it said missing input files
03:59:21 <SamB> helmut: ah, yes, the "ghc6" Debian package contains the Cabal package called "containers"
03:59:32 <helmut> $ ghc6 -Wall --make -o Foo Foo.o
03:59:32 <helmut> ghc-6.8.2: no input files
03:59:32 <helmut> Usage: For basic information, try the `--help' option.
03:59:48 <SamB> -package containers
03:59:52 <quicksilver> ghc6 --make Foo.hs
03:59:58 <quicksilver> (or -package containers)
04:00:07 <SamB> both
04:00:08 <quicksilver> personally I always use --make and never -package
04:00:09 <helmut> SamB: is right
04:00:20 <SamB> probably
04:00:27 <helmut> quicksilver: does ghc6 know how to invoke frown and alex?
04:00:36 <SamB> well, at least, you should definately mention the .hs file somehow...
04:00:56 <SamB> no, GHC doesn't invoke those
04:01:02 <helmut> quicksilver: if not I cannot switch away from make then.
04:01:20 <helmut> -package container works. thank you very much
04:01:34 <SamB> I don't know if cabal can invoke frown or not
04:01:51 <SamB> but you *can* use make with --make
04:02:05 <SamB> not that there is any need to do so
04:02:24 <desegnis> helmut: I suppose --make works only when you start from the *.hs files, not when linking already-compiled object files
04:04:03 <quicksilver> You can pass .o files to --make too
04:04:42 <SamB> well, you probably don't want to pass .o files from Haskell code in that case...
04:07:51 <kuribas> quicksilver: You can set max-lisp-eval-depth to a higher value, if necessary.
04:08:46 <kuribas> The default (300) is rather low.
04:09:08 * desegnis must go to "work" again
04:10:09 <kuribas> quicksilver: Or maybe I should set it to a higher value in haskell-indentation.El, to avoid this problem.
04:13:01 <quicksilver> kuribas: interesting. Why does it get so deeply nested?
04:13:09 <Dybber> Hi, I'm trying to install the zlib package found on the hackage website. But I get this error: Could not find module `Data.ByteString.Lazy': it is a member of package bytestring-0.9.0.4, which is hidden
04:13:25 <quicksilver> kuribas: I would have thought my code contained 10-15 nested scopes, bet definitely not 300.
04:13:41 <kuribas> quicksilver: Because I use a recursive descent parser.
04:13:54 <quicksilver> kuribas: ah.
04:14:00 <Dybber> How do I "unhide" the bytestring package?
04:14:01 <Botje> Dybber: edit the .cabal file, and add bytestring to the depends line
04:14:18 <kuribas> quicksilver: I would have thought that 300 would be enough.
04:14:47 <kuribas> quicksilver: But in some places I use tail-recursion, which isn't optimised in emacs.
04:15:03 * quicksilver nods
04:15:13 <Dybber> Botje: thanks, but now I get "Could not find module Data.ByteString.Base"
04:16:14 <Botje> you're using ghc 6.8, right?
04:16:20 <Dybber> yes
04:17:12 <Dybber> I can't load that module in ghci either
04:20:19 <Botje> odd
04:20:27 <Botje> Dybber: can you try installing the bytestring package from hackage too?
04:20:41 <Dybber> Botje: I just did that, before writing here
04:20:43 <Botje> oh
04:20:52 <Botje> it doesn't seem to export D.BS.Data either
04:22:34 <Botje> you're installing the newest version of zlib, i assume?
04:22:46 <Dybber> 0.3
04:23:08 <Dybber> I hope it is the newest, I just downloaded a tarball from hackage
04:23:17 <Botje> the newest is 0.4.0.4
04:23:37 <Botje> the tarball for that version is at http://hackage.haskell.org/packages/archive/zlib/0.4.0.4/zlib-0.4.0.4.tar.gz
04:23:44 <lambdabot> http://tinyurl.com/2jkmhf
04:23:49 <Botje> it's the "cabal source package" if you surf to http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib-0.4.0.4
04:23:52 <lambdabot> http://tinyurl.com/2yr4xl
04:24:13 <Dybber> ah thats probably it, thanks
04:24:25 <Botje> yeah
04:24:43 <Botje> because it still depends on base
04:24:47 <Botje> which was split in ghc 6.8
04:25:36 <Botje> does the newest zlib compile for you?
04:25:37 <Dybber> yes, I got it installed now
04:25:40 <Botje> :)
04:26:04 <Botje> @vixen another happy customer.
04:26:04 <lambdabot> you sir are no gentleman
04:26:42 <Botje> does cabal-install work with an old-ish version of cabal yet?
04:29:03 <Baughn> Botje: Nope. Nor will it, until the current version becomes oldish
04:29:06 <Peaker> Hmm, I finally figured out a way to create "observers" in Haskell, maybe...
04:29:31 <Peaker> Maybe something like: data ObservableValue a = Monad m => (ObservableValue a [(a -> m ())])
04:29:39 <Botje> observing variables that never change seems kind of dull.
04:29:52 <Baughn> Peaker: Mostly, you should be able to avoid them. They don't make an awful lot of sense in haskell..
04:29:55 <Peaker> Botje, they do change, the ObservableValue will sit inside a State
04:29:59 * Botje wonders if there's sensible design patterns for functional languages
04:30:06 <Botje> Peaker: yeah, i spent too long typing that ;)
04:30:28 <Peaker> Baughn, well, remember I want to do differential computations
04:30:32 <Baughn> Botje: Sure. "Extract combinator library", "make function pointsfree", "extract subfunction", "build domain-specific language"...
04:30:53 <Peaker> Baughn, maybe the a->m() should be replaced with (Diff a)->m ()
04:31:04 <Botje> Baughn: :)
04:31:18 <opqdonut> a refactoring tool for FP would be nice
04:31:21 <Baughn> Peaker: Perhaps. I think you should think about the interface you want first, though, and figure out how to best implement it later
04:31:23 <opqdonut> not that i use such things
04:31:29 <Botje> "make language interpreter","construct infinite list","tie the knot"
04:31:36 <Peaker> Baughn, well, I created a prototype declarative GUI that edits a "model" that is simply a single integer :-)
04:32:04 <Botje> "refactor NP complete problem into polynomial code" (this requires GHC 11.2, unfortunately)
04:32:06 <Baughn> Peaker: I mean the programming interface
04:32:10 <Peaker> Baughn, the "widget" showing the integer has its own mutable state as well.  So the GUI execution code lives in a monad-stack of a GUI environment, model state, view state, and a higher monad
04:32:19 <Peaker> Baughn, Well, I do have something initial going
04:32:35 <Baughn> Peaker: Wouldn't it be nice to build a GUI toolkit that can be programmed without reference to mutation?
04:32:55 <Peaker> Baughn, MyGUI.execute  (MyGUI.intEditor someInteger)  -- someInteger may be just an int, or more data about where its serialized-to/etc
04:33:07 <Peaker> Baughn, the interface has no concept of "mutations" indeed
04:33:22 <Peaker> Baughn, inside MyGUI.execute, I need state though
04:34:17 <Peaker> Baughn, now that I have a GUI going, I want to be able to animate diffs that happen
04:35:15 <Peaker> Baughn, without heuristically creating a diff based on old/new values
04:35:23 <Peaker> just see the real diff that was applied
04:36:57 <Baughn> Peaker: By the way, the IO and State monads really *are* written by use of side-effecting functions instead of threading state
04:37:21 <Baughn> Peaker: edwards is right. It may not be very clean, but it's fast, and it was possible to write before GHC achieved human-level intelligence.
04:37:45 <Dybber> Can I get ghc to show which modules is registered/installed and in which versions?
04:38:01 <Baughn> Dybber: ghc-pkg -l
04:38:31 <Dybber> thanks
04:38:34 <Peaker> Baughn, State _can_ be implemented without threading state. IO is ofcourse special. If implementations use hacks to speed things up it doesn't mean that "monads" in general hide side effects within magic primitives
04:38:52 <Peaker> Baughn, without side-effecting function, that was supposed to be
04:39:08 <Baughn> Peaker: "Monads in general" are a bit /too/ general. They may not use side-effecting functions, but they don't necessarily thread state either.
04:39:55 <Peaker> Baughn, "State" does not use "side effecting primitives" at least in theory.. optimizations can be ignored when looking at the model
04:40:48 * Botje should really work on his compiler some more
04:41:05 <Peaker> Baughn, "IO" is one specific case where it must indeed hide side-effecting primitives, but Edwards own "Actions" do that too..
04:41:17 <Peaker> Baughn, my point with Edwards was that it is my understanding that the IO monad is equivalent to his "Actions"
04:50:20 <Dybber> I get this when I try to install cabal-install (0.4.0): "Setup.lhs: At least the following dependencies are missing: zlib >=0.3, HTTP >=3000.0&&<3001.1" but I have HTTP-3001.0.4 and zlib-0.4.0.4
04:55:01 <Dybber> a --user flag fixed it
04:57:43 <cjs> Time to head home. Thanks for all of your help, guys.
05:04:00 <Cheery> what bytecode's tree-version is called?
05:04:30 <Cheery> ie. evaluable binary trees, what can I call those with short name?
05:06:29 <quicksilver> Cheery: AST representation?
05:08:35 <oToom> Hey all.
05:11:55 <yitz> hi oToom
05:12:03 <oToom> How is it going?
05:12:31 <yitz> ok tnx.
05:15:53 <oToom> gdgd
05:16:23 <oToom> 427 ppl in this chanel
05:16:30 <oToom> make that 428
05:17:15 <yitz> and counting...
05:17:20 <quicksilver> @losers
05:17:20 <lambdabot> Maximum users seen in #haskell: 472, currently: 427 (90.5%), active: 8 (1.9%)
05:17:35 <yitz> losers?
05:17:47 <Cheery> does there somewhere read the set of combinators that make SKI useful?
05:18:53 <yitz> @google haskell ski
05:18:54 <lambdabot> No Result Found.
05:20:11 <yitz> http://journal.batard.info/post/2008/02/17/ski-calculus-in-a-haskell-shell
05:20:13 <lambdabot> Title: SKI calculus in a Haskell shell - yogiblog, http://tinyurl.com/3axsoq
05:20:19 <Cheery> "SuperCombinators can rather easily be translated into C or assembly language. In this way, a FunctionalProgramming language can be implemented efficiently."
05:20:29 <Cheery> I want to know, how that is achieved!
05:21:56 <Jaak> > let a \+ b = (a, b) in 1 \+ 2
05:21:56 <lambdabot>  (1,2)
05:23:27 <yitz> > let (\+) = (,) in 1 \+ 2
05:23:27 <lambdabot>  (1,2)
05:25:24 <Jaak> > let (\\\\) = (,) in 1 \\\\ 2
05:25:24 <lambdabot>  (1,2)
05:28:25 <ukl> /server irc://irc.perl.org/#angerwhale
05:28:32 <ukl> oh dammit. sorry.
05:29:39 <yitz> > let (\\) = (,) in 1 \\ 2
05:29:39 <lambdabot>  (1,2)
05:29:45 <yitz> > let (\) = (,) in 1 \ 2
05:29:45 <lambdabot>  Parse error at ")" (column 7)
05:30:02 <Jaak> \ is reserved op
05:30:23 <Jaak> > let (:::) = (,) in 1 ::: 2
05:30:24 <lambdabot>   Not in scope: data constructor `:::'
05:30:36 <Jaak> oh, right. : is conid
05:31:08 <Jaak> or consym
05:33:04 <quicksilver> yeah, reserving \ was annoying
05:33:14 <quicksilver> what's it reserved for?
05:33:24 <Jaak> who knows... who knows... :P
05:34:54 <opqdonut> ?where slpj
05:34:54 <lambdabot> I know nothing about slpj.
05:34:59 <opqdonut> ?go slpj
05:35:00 <lambdabot> http://research.microsoft.com/~simonpj/papers/slpj-book-1987/index.htm
05:35:00 <lambdabot> Title: The Implementation of Functional Programming Languages
05:35:04 <opqdonut> Cheery: this one
05:40:49 <ndm> quicksilver: lambda
05:41:08 <quicksilver> ndm: ;)
05:50:11 * PIRAT` np: Vlado Georgiev - Nisam ljubomoran [04:48m/128Kbps/44KHz]
05:50:44 <quicksilver> Hmm. With a nick like 'PIRAT' I wonder where he gets his music ? :)
05:51:11 <yitz> @arr
05:51:11 <lambdabot> Shiver me timbers!
05:51:57 <byorgey> On the high C's ?
05:52:20 <quicksilver> *rimshot*
06:00:58 <Jaak> > lex "-1"
06:00:59 <lambdabot>  [("-","1")]
06:01:07 <Jaak> hmm
06:03:45 <ziman> > lex "return$"
06:03:45 <lambdabot>  [("return","$")]
06:03:57 <yitz> > lex "1.0"
06:03:58 <lambdabot>  [("1.0","")]
06:06:06 <yitz> > unfoldr (listToMaybe . concatMap lex . tails) "5-1"
06:06:07 <lambdabot>  ["5","-","1","","","","","","","","","","","","","","","","","","","","","",...
06:06:41 <yitz> > lex ""
06:06:41 <lambdabot>  [("","")]
06:06:45 <yitz> ah
06:07:20 <yitz> > takeWhile (not.null) $ unfoldr (listToMaybe . concatMap lex . tails) "5-1"
06:07:20 <lambdabot>  ["5","-","1"]
06:07:27 <yitz> > takeWhile (not.null) $ unfoldr (listToMaybe . concatMap lex . tails) "-1"
06:07:27 <lambdabot>  ["-","1"]
06:07:31 <quicksilver> Jaak: yes, haskell doesn't have negative numeric literals.
06:07:35 <quicksilver> Jaak: strange, isn't it? :)
06:07:43 <Peaker> I want to describe a world where I have some "mutable value" x, and a function of it  (f x).  I want (compute f f' x) to be a "lazy" expression, but when forcing it, I want it to be computed in the cheaper of two alternatives:  applying f to x, or applying f' to the differences that were applied to x since the "last time" (f x) was forced. Does this make any sense?
06:07:46 <yitz> > takeWhile (not.null) $ unfoldr (listToMaybe . concatMap lex . tails) "(5-1)"
06:07:47 <lambdabot>  ["(","5","-","1",")"]
06:07:56 <quicksilver> the "-" sign is a soruce of pain.
06:08:17 <quicksilver> Peaker: make sense? yes.
06:08:21 <quicksilver> possible in haskell? I don't think so.
06:08:22 <yitz> so "-" is either a unary or binary operator, depending on context
06:08:33 <Jaak> i figured that. got to write special case into parser
06:08:39 <quicksilver> you don't have that kind of control over how things get forced.
06:08:49 <quicksilver> you can abstract it all up to a higher level and do your "own" forcing, of course.
06:08:51 <Jaak> or does haskell handle this more gracefully?
06:09:00 <Peaker> quicksilver, yeah, I figured that, I was wondering how to do that
06:09:24 <quicksilver> Peaker: doesn't sound too difficult, just cache old values of x and f x
06:09:39 <quicksilver> Jaak: not really. "-" is a unary operator so "-5" is (negate 5)
06:09:49 <quicksilver> or actualy it's negate (fromInteger 5) IIRC.
06:10:01 <Jaak> oh
06:10:47 <quicksilver> which suggests that fromInteger is never called on negative numbers
06:10:54 <Peaker> quicksilver, I'd like f and f' to sit in a "Computation" type, so somethinglike:  data Computation a b = (a -> b) (Diff a -> Diff b)   but I have no idea how to specify Diff/etc
06:11:07 <quicksilver> > -128 :: Word8
06:11:08 <lambdabot>  128
06:11:22 <Peaker> quicksilver, I forgot a data constructor :)
06:11:40 <quicksilver> fortunately (?) no type has a bigger negative range than positive?
06:11:49 <Peaker> quicksilver, I don't really want to "force" things, but I do want to know when a value is needed so I can compute it in a cheap way
06:14:34 <Jedai> Peaker: Shouldn't you change the value stocked in a ref when you change x to f' diffX from f x ?
06:15:21 <yitz> > -1.0
06:15:21 <lambdabot>  -1.0
06:15:24 <Peaker> Jedai, I could do it inside ref's, but that's frowned upon :)
06:15:41 <yitz> so it's just negate, i think
06:16:08 <Jedai> Peaker: x is a "mutable value" you said, so there's already refs (or I don't know what you're speaking about)
06:16:58 <Peaker> Jedai, well, a "mutable value" is in "" because it may be implemented as the state of a State monad or mapped to some other idea
06:17:03 <Peaker> Jedai, I don't know how best to implement it
06:18:00 <Peaker> i guess for now I don't have to support computation-from-scratch when that's cheaper. I can do always-differential computation for now, which would simplify matters
06:18:16 <Peaker> which means I can represent a value as an infinite list of diffs, perhaps
06:18:39 <Jedai> Peaker: You could just put the f x or f' x in your state/ref when you change x (your state or whatever)
06:19:39 <Peaker> Jedai, (f x) is probably a different state/ref than x
06:20:40 <Peaker> Jedai, Well, zooming out: the idea is to be able to describe a computation graph where the "sources" of the graph can change thereby causing their dependencies to be recomputed accordingly -- all done differentially, so a change costs O(dependency changes' total size) and not O(dependencies total sizes)
06:21:09 <Peaker> Jedai, so each "computation" actually takes a diff as an input, and generates a diff as an output
06:21:18 <Jedai> Peaker: What you want to do isn't very clear... Anyway, if you can go for an infinite list of differential computation, you can probably splice in some total computation each n steps
06:21:53 <Peaker> Jedai, total computation is only desirable if O(changes' size) > O(object size) (where changes are diffs on object)
06:21:59 <Peaker> I think that should be rare
06:22:43 <Peaker> also, differential computation has an additional advantage of preserving meaningful intent across computations: A GUI can show the result of such a computation graph and see "diffs" coming that can be animated nicely, rather than simply opaque values changing
06:26:50 <kuribas> Peaker: Do you mean what this paper call incremental computing? http://www.cse.ogi.edu/~magnus/papers/icfp-2002.pdf
06:27:23 <Peaker> kuribas, I'd have to read a bit to know :-) Thanks for the ref
06:28:45 <kuribas> I was thinking about something like this to make a music notation GUI, where the program is a functional transformation from AST to music objects, and when the user changes notes or values, only the needed changes are computed.
06:28:59 <kuribas> Only it's not so easy as it sounds :)
06:36:46 <mm_freak1work> hello peopleâ€¦  may i paste haskell-unrelated stuff to hpaste.org or is there a better place to do that?
06:37:04 <opqdonut> well there are other pastebins too
06:37:19 <opqdonut> but as long as you uncheck the "announce on IRC" box it should be ok
06:38:16 <mm_freak1work> then i'll better use another service, because other people might paste stuff there not unchecking the box
06:39:01 <allbery_b> somewhat bizarrely, some folks on #openafs have been using hpaste of late
06:39:58 <yitz> @seen hpaste
06:39:58 <lambdabot> hpaste is in #haskell. I last heard hpaste speak 2h 48m 40s ago.
06:40:07 <yitz> only in #haskell for now
06:40:29 <yitz> but they can always paste things there if they'd like
06:40:32 <allbery_b> hpaste only knows how to announce to #haskell, yes
06:41:09 <yitz> I don't think #openafs is exactly slashdot
06:42:24 <Peaker> column-based PDF's are so annoying to read compared to simple HTML or such
06:43:33 <mm_freak1work> multi-column PDF is intended to be printed out
06:43:58 <Peaker> yeah, but I don't have a printer, and wouldn't want to waste paper
06:44:03 <Peaker> When I have a perfectly working monitor
06:45:22 <Peaker> Could be nice to have a format that has both the "source unformatted data" and the "layout information" required to make a PDF out of it, so one is not tied to a certain presentation to read it
06:50:00 <Peaker> are there any links to examples of pre-Monad Haskell, and how it did I/O back in those days?
06:51:33 <bvk> Is it possible to have explicit memory management in haskell, using malloc/free as in C ?
06:51:38 <bvk> just curious :)
06:51:43 <mauke> @hoogle malloc
06:51:43 <lambdabot> Foreign.Marshal.Alloc.malloc :: Storable a => IO (Ptr a)
06:51:43 <lambdabot> Foreign.ForeignPtr.mallocForeignPtr :: Storable a => IO (ForeignPtr a)
06:51:43 <lambdabot> Foreign.ForeignPtr.mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)
06:52:05 <mauke> @hoogle free
06:52:05 <lambdabot> Foreign.Marshal.Alloc.free :: Ptr a -> IO ()
06:52:05 <lambdabot> Foreign.StablePtr.freeStablePtr :: StablePtr a -> IO ()
06:52:05 <lambdabot> Foreign.Ptr.freeHaskellFunPtr :: FunPtr a -> IO ()
06:52:32 <bvk> mauke: wow, thanks
07:26:06 <Jaak> is IntMap strict?
07:26:32 <quicksilver> I would guess it's strict in spine and keys but not in values.
07:26:50 <quicksilver> that's the general pattern
07:26:59 <Jaak> hmm...
07:27:22 <Jaak> trying to find suitable container for environment
07:28:01 <marshmallows> hiya
07:28:12 <quicksilver> I wouldn't let non-strictness put you off.
07:28:19 <quicksilver> just choose to use it strictly, if that's wat you want.
07:29:43 <ski> Peaker : "Imperative functional programming" and "How to declare an imperative" at <http://homepages.inf.ed.ac.uk/wadler/topics/monads.html> has some comparisions between I/O based on monad, dialogue, continuation, side-effect formulations
07:30:01 <Vq^> Jaak: what do you mean by suitable?
07:30:07 <Peaker> ski, thanks - but what did Haskell use before IO monads?
07:30:38 <Vq^> Jaak: if you want fast lookups maybe you should check out radix-trees
07:31:13 <quicksilver> Vq^: intmaps are a kind of radix tree, aren't they?
07:32:52 <Jaak> i'm not really sure myself. something pure but with fast insert and lookup...
07:33:14 <quicksilver> I believe they are the same complexity as radix trees, anyhow
07:33:19 <allbery_b> Peaker:  main :: [Request] -> [Response]
07:33:27 <quicksilver> I.e. constant lookup
07:33:31 <quicksilver> not sure about insert/update
07:33:57 <Jaak> according to hoogle the lookup is O(min(n,W))
07:34:01 <Peaker> allbery_b, thanks. any examples of some code - with how that looked like?
07:34:11 <allbery_b> and I'm unsure it's "Haskell" -- -I think you're looking for Gofer
07:34:16 <Jaak> W is either 32 or 64, this is putting me off
07:34:20 <Peaker> allbery_b, Haskell always had monads?
07:34:55 <sclv> Peaker: as I recall, pre-monad haskell just had "interact"
07:34:58 <allbery_b> @go wearing the hair shirt
07:34:59 <lambdabot> http://research.microsoft.com/~simonpj/papers/haskell-retrospective/index.htm
07:34:59 <lambdabot> Title: Wearing the hair shirt: a retrospective on Haskell
07:35:10 <allbery_b> should answer a fair amount of that
07:35:18 <Peaker> sclv, what's "interact"?
07:35:24 <Jaak> @type interact
07:35:26 <lambdabot> (String -> String) -> IO ()
07:35:27 <shachaf> allbery_b: Isn't is [Response] -> [Request]?
07:35:36 <quicksilver> Jaak: why would O(32) put you off?
07:35:43 <matthew-_> how would you spell typeable?
07:35:49 <quicksilver> Jaak: you do know that O(32) == O(1) == O(0.000001) ?
07:36:05 <allbery_b> shachaf: hm, maybe
07:36:07 <radix> hooray constant time
07:36:18 <shachaf> matthew-_: Haskell spells it that way.
07:36:24 <Peaker> radix, awakened by the mention of radix trees? :)
07:36:27 <matthew-_> shachaf: that's good enough for me then ;)
07:36:33 <Jaak> yes, yes. but even with Data.Map my log(n) wouldnt go above 32
07:36:34 <radix> Peaker: yes, and it's bloody annoying ;)
07:36:40 <shachaf> allbery_b: After all, the program makes requests (returns them) and gets responses (as arguments).
07:36:47 <Jaak> but it comes down to which has better constant
07:36:49 <quicksilver> Jaak: true. intmap is faster though.
07:36:53 <Peaker> radix, congrats on the Twisted release, btw
07:36:57 <radix> Peaker: thanks!
07:36:59 <allbery_b> depends on what side of oit you're focusing on
07:37:09 <Jaak> anyways. it's a speudoproblem right now... i can eaily implement env with both :P
07:37:14 <shachaf> @instances-importing Data.Generics Typeable
07:37:14 <Jaak> easily*
07:37:14 <lambdabot> DataType, s a
07:37:16 <Peaker> radix, I hope my bugs in there are all ok :-)
07:37:20 <allbery_b> RealWorld# is making requests of the program, which returns responses :)
07:37:24 <quicksilver> Jaak: you may be suffering from premature optimization :)
07:37:33 <quicksilver> @quote premature
07:37:34 <lambdabot> pcrs says: Premature carriage ret
07:37:36 <shachaf> I suppose.
07:37:37 <quicksilver> @quote premature
07:37:37 <lambdabot> pcrs says: Premature carriage ret
07:37:39 <Jaak> yeah, maybe
07:37:42 * quicksilver shrugs
07:37:52 <shachaf> @quote premature.optim
07:37:52 <lambdabot> vincenz says: strict evaluation is premature optimization
07:37:54 <quicksilver> premature evil is the root of all optimization
07:37:55 <quicksilver> etc.
07:37:59 <Jaak> anyways, thanks. i'll go with IntMap now
07:40:53 <ski> Peaker : i think before haskell 1.3, there was dialogue-based I/O (like allbery_b mentioned)
07:41:33 <ski> i had some link to an old prelude source for hugs (or gofer ?) which used this, iirc .. but i can't find it atm
07:41:37 <Peaker> ski, thanks.  I ask because I am wondering about which disadvantages the simpler "stream" model has compared with the monad model
07:42:10 <ski> the direct use of dialogue I/O was brittle and noncompositional
07:42:54 <Peaker> ski, I see. I figured that was the case, but never having used it myself, I failed to convince my friend of that :-)
07:42:59 <ski> it was easy to mistakenly look at an input response before the corresponding output request had been sent, or accidentally get them out-of-synch
07:43:53 <ski> and non-compositional, since each value of type `Dialogue' (i.e. `[Response] -> [Request]') was a complete program, you couldn't specify anything to happen afterwards
07:44:27 <Peaker> ski, so you can't create "imperative subroutines" and compose those?
07:45:07 <ski> so to get reusable library functions, those would have to take continuation argument(s), that told what to do after some action was done (several continuations in the case of multiple possible results .. such as "ok/result" vs. "error")
07:45:25 <ski> e.g. something like
07:45:39 <ski> putStr :: String -> Dialogue -> Dialogue
07:45:48 <ski> getLine :: (String -> Dialogue) -> Dialogue
07:45:56 <quicksilver> and in fact if you ask the question "what should we do to make dialogues compositional" ?
07:46:05 <quicksilver> you end up with something very like the IO monad as one sensible answer.
07:46:29 <ski> using such abstractions, one wouldn't have to keep track of the representation of `Request' and `Response' by-hand
07:47:00 <Peaker> thanks! I'm convinced :)
07:47:01 <ski> so, this more or less then is (one implementation of) the continuation-based I/O variant
07:47:19 <shepheb> even the syntax starts to look similar to desugared do-notation: getLine $ \s -> ...
07:47:58 <ski> main :: Dialogue
07:47:59 <ski> main = putStr "Foo\n" (getLine (\l -> putStr (reverse l) endOfProgram))
07:48:06 <ski> endOfProgram :: Dialogue
07:48:47 <ski> Peaker : but read those two papers .. i recall that had some examples and explanations of this
07:48:55 <Saizan> s/$/>>=/ and you get a monad
07:49:12 <ski> (a continuation monad .. with `Dialogue' as the "final answer" type)
07:49:45 <Peaker> ski, the site you linked has a bunch of papers, which ones do you mean?
07:50:06 <ski> <ski> Peaker : "Imperative functional programming" and "How to declare an imperative" at ...
07:50:09 <ski> those two
07:53:08 <ski> (there should be better (i.e. more expanded) explanations of the earlier I/O styles .. but i've forgotten exactly where)
07:58:09 <shepheb> is there a list of functional pearl papers somewhere?
07:58:57 <marshmallows> @go functional pearl
07:58:59 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers/Functional_pearls
07:58:59 <lambdabot> Title: Research papers/Functional pearls - HaskellWiki
08:01:41 <ehird> Can GHC compile to DOS?
08:02:08 <Lycurgus> "DOS" ?
08:02:10 <xerox> welcome to 2008
08:02:19 <Lycurgus> do you mean Windows?
08:02:35 <ehird> No, I mean DOS.
08:02:36 <Lycurgus> if so, I believe the answer is yes.
08:02:48 <Lycurgus> otherwise prolly not.
08:02:49 <quicksilver> which version of DOS? why?
08:03:10 <Lycurgus> 3.1 would be my guess.
08:03:27 <ehird> quicksilver: as for why -- I'm trying to convince the maintainer of the C-INTERCAL intercal compiler to start using darcs. [15:57] <ais523> I do development there too, for the Windows version of C-INTERCAL
08:03:43 <ehird> C-INTERCAL supports just about all OSs out there, and loads of legacy hardware
08:03:43 <quicksilver> he's not really talking about DOS then, is he.
08:03:46 <ehird> quicksilver: No, he is.
08:03:50 <ehird> He targets DOS & POSIX
08:03:50 <quicksilver> he's talking about the windows command shel
08:03:54 <ehird> no, he's not
08:03:57 <quicksilver> "for the Windows version of C-INTERCAL" ?
08:04:01 <quicksilver> he said 'Windows'
08:04:16 <ehird> oh look hes
08:04:18 <ehird> 's here
08:04:22 <ehird> quicksilver: you are wrong :)
08:04:38 <quicksilver> I am not wrong about him saying Windows.
08:04:45 <quicksilver> or at least, that's what you said he said.
08:04:58 <Lycurgus> just that he meant it for where he want to run haskell
08:05:10 <ehird> he would need a copy of darcs for DOS
08:05:17 <ehird> because to support DOS and Windows he just develops it on DOS
08:05:23 <ehird> and it works on Windows too, mostly, because of the compatibility
08:05:24 <ais523> sorry
08:05:27 <ehird> lowest-common denominator
08:05:32 <quicksilver> ok, and I asked "which version of DOS?"
08:05:32 <ehird> ais523: correct me if i am wrong
08:06:08 <ais523> mostly NTVDM on Windows XP, because in practice people will normally run it like that
08:06:19 <Lycurgus> 6 or 7 something I think were the last.
08:06:34 <Lycurgus> I know there was a 5.
08:06:40 * ais523 has used 4 and 6
08:06:42 <ehird> ais523: I think GHC can compile to something ntvdm will accept
08:06:43 <quicksilver> No.
08:06:45 <ehird> Not sure about 4
08:06:48 <quicksilver> ghc can't compile to 16 bit
08:06:55 <quicksilver> AFAIK.
08:06:57 <ehird> quicksilver: guess he'll have to use git then :)
08:07:13 <quicksilver> maybe it could, once upon a time. But I don't recall any remotely recent use of ghc on a 16 bit platform.
08:08:44 <solrize_> there used to be a bunch of different hacks to run 32 bit code under dos
08:08:45 <quicksilver> mind you, I don't know much about ntvdm
08:08:48 <quicksilver> (= nothing)
08:09:01 <ehird> hmm
08:09:10 <ais523> quicksilver: put it this way, anything that crashes 100% of the time running tar and has to be restarted is pretty broken
08:09:26 <quicksilver> sounds broken to me :)
08:09:29 <solrize_> http://en.wikipedia.org/wiki/DOS_extender
08:09:29 <lambdabot> Title: DOS extender - Wikipedia, the free encyclopedia
08:09:49 <solrize_> http://en.wikipedia.org/wiki/DJGPP
08:09:49 <lambdabot> Title: DJGPP - Wikipedia, the free encyclopedia
08:09:54 <solrize_> yeah, that's the stuff
08:10:01 <ais523> ah yes, I use go32 already
08:10:03 <ais523> to run gcc
08:10:22 <quicksilver> if the platform can run gcc
08:10:26 <quicksilver> it can probably run ghc
08:10:32 <ais523> yes, probably
08:10:34 <quicksilver> and hence probably darcs
08:10:36 <ehird> aha
08:10:48 <ehird> hmm
08:10:54 <ehird> ais523 will have to compile his ghc himself i believe
08:11:01 <ehird> on DOS. That will be *fun fun fun*
08:11:18 <ais523> yep
08:11:51 <ehird> ais523: Just for context..
08:11:58 <ehird> Compiling GHC took me 4-6 hours on a recent mac
08:12:31 <MarcWeber> ehird: Am I right that this language is not useful for anything but having fun?
08:12:45 <ehird> MarcWeber: INTERCAL? But of course.
08:12:55 <ehird> MarcWeber: However, Knuth has written a program in it.
08:13:00 <ais523> MarcWeber: you should see my implementation of continuations in it
08:13:09 <Peaker> hehe
08:13:25 <ehird> and 'should' becomes 'will': http://filebin.ca/xwthjm/continuation.i
08:13:40 <MarcWeber> It's just .. propably more strange for a INTERCAL-C newbee than haskell :)
08:14:32 <ehird> MarcWeber: The C-INTERCAL documentation is written in Texinfo, but on the HTML output, a perl script runs through it and changes the long filenames to random ones to fit in 8-characters so it works on DOS..
08:15:27 <ais523> ehird: also fixes the TOC and works around a bug in makeinfo
08:18:30 <ttt--> what are .i files?
08:19:03 <ais523> ttt--: INTERCAL
08:19:12 <ais523> see http://intercal.freeshell.org for more information
08:19:16 <lambdabot> Title: CLC-INTERCAL
08:19:37 <byorgey> if you don't value your sanity, that is =)
08:23:13 <Peaker> @hoogle nubBy
08:23:14 <lambdabot> Data.List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
08:23:16 <Peaker> @hoogle sortBy
08:23:16 <lambdabot> Data.List.sortBy :: (a -> a -> Ordering) -> [a] -> [a]
08:23:17 <eyeris> Each monad type implements it's own liftM functions, right?
08:23:52 <byorgey> eyeris: indirectly, since each monad implements return and >>=, and liftM is implemented in terms of these
08:23:58 <byorgey> @src liftM
08:23:58 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
08:23:59 <Peaker> eyeris, no, liftM uses bind and return to "extract" and "put in" a value in a way that is general to all monads
08:24:26 <byorgey> you could also write  liftM f m1 = m1 >>= \x1 -> return (f x1)
08:24:28 <Peaker> Why are nubBy/sortBy necessary, can't we just newtype and redefine instance Eq/Ord correctly?
08:24:45 <eyeris> Ok. Thanks. That answers a bunch of other questions I had :)
08:24:51 <ehird> Peaker: and then unwrap to pass to a function?
08:24:51 <ehird> fugly
08:25:02 <byorgey> Peaker: you could, but sometimes that's annoying and too heavyweight for some one-time use.
08:25:33 <eyeris> True story here: last night I woke up in the middle of the night, after dreaming obout a family of bigfoot creatures, and wondered "Why is lift only valid for monads?" :)
08:25:42 <byorgey> hahaha
08:25:53 <Peaker> byorgey, ehird: why can't the wrap/unwrap occur automatically, according to expected types?
08:26:22 <byorgey> Peaker: but how would it know which wrapped type to expect?
08:26:36 <byorgey> sort and nub just take any instance of Ord.
08:26:39 <Peaker> byorgey, what about the unwrap?
08:27:08 <shachaf> byorgey: Isn't nub Eq?
08:27:13 <shachaf> @ty nub
08:27:15 <lambdabot> forall a. (Eq a) => [a] -> [a]
08:27:16 <byorgey> er, sorry, right
08:27:26 <byorgey> that wasn't really the point =)
08:27:51 * shachaf is reading backwards. :-)
08:28:02 <Peaker> byorgey, I see why the wrap can't be automatic, what about the unwrap?
08:28:21 <quicksilver> it could be automatic with a suitable type class
08:28:23 <shachaf> eyeris: I woke up one time and tried to fmap a function on my cat.
08:28:31 <quicksilver> I think you'd find it was clumsy in practive.
08:28:55 <byorgey> instance Functor Cat where...
08:29:04 <eyeris> shachaf I don't think my cats would appreciate that :0
08:29:08 <ehird> instance Functor Rabbit
08:29:22 <ehird> it uses continuation passing style
08:29:31 <Peaker> hmm, maybe something like:  (wrapunwrap NewTypeWithSpecialOrd sort value)  [with simpler names, ofcourse] could replace: (sortBy specialOrd value) ?
08:30:01 <shachaf> ("cat" is not an abbreviation for "category" here. :-) )
08:30:17 <ehird> nobody likes my joke
08:31:15 <byorgey> Peaker: yes, I think that could work.  But that seems way clunkier to me than just using sortBy in the first place.
08:31:16 <Peaker> s/nub/removeRepetitions could simplify a newbie's life :)
08:31:45 <Peaker> byorgey, Ofcourse, but a single wrapunwrap function could save everyone from writing *By duplicates for all their functions
08:32:41 <shachaf> Peaker: You still need to defined a newtype and instance.
08:33:27 <Peaker> shachaf, well, the newtype/instance and their use are somewhat similar to the function you need to create when passing to the funcBy, though the syntax machinery to define that is definitely less nice
08:35:21 <desegnis> Peaker: If your wrapunwrap works the way it looks like it would work, then it is less general than using sortBy, but more efficient than using sortBy.comparing
08:35:41 <Peaker> desegnis, why is it less general?
08:35:55 <desegnis> @type sortBy
08:35:56 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
08:36:04 <Peaker> @src Ord
08:36:04 <lambdabot> class  (Eq a) => Ord a  where
08:36:04 <lambdabot>     compare      :: a -> a -> Ordering
08:36:04 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
08:36:04 <lambdabot>     max, min         :: a -> a -> a
08:36:17 <Peaker> and only compare needs to be defined, right?
08:36:30 <desegnis> that function (a -> a -> Ordering) is independent of the Ord class
08:36:52 <Peaker> desegnis, yeah, but it can be put into a newtype instance of the Ord class
08:37:29 <desegnis> Of course you can always define a newtype in Ord...
08:38:13 <Peaker> that's what I meant with my wrapunwrap -- that you would give it the data constructor of a newtype-instance of whatever class the function is using. Select the function by selecting the instance, rather than by passing a function explicitly
08:38:27 <desegnis> I mean, sortBy allows/encourages a usage where you don't (want to) define a wrapping type
08:38:55 <Peaker> Is there another reason not to want to define a wrapping type except heavy syntax?
08:39:02 <desegnis> right, though mind, it wouldn't have to be a data constructor
08:39:33 <desegnis> wrapUnwrap length sort listOfString
08:39:37 <Saizan> Peaker: there are cases where you can't, you might be constructing that function at runtime, from a function that takes other arguments
08:40:17 <Peaker> desegnis, I meant for wrapunwrap to "unwrap" the result type of sort - not sure if its possible, or how you would "unwrap" the result length
08:41:10 <desegnis> Peaker, so (wrapUnwrap length sort list) should not sort the list by the length of its elements?
08:41:10 <Peaker> Saizan, oh, an instance declaration can't live in a lexical scope?
08:41:22 <desegnis> in that case I'd have misunderstood
08:41:38 <mauke> oh god, are you trying to write C++ in Haskell?
08:41:48 <Saizan> Peaker: no, they are toplevel
08:41:57 <Peaker> Saizan, I see
08:42:03 <Peaker> ok Saizan killed my idea now :)
08:42:54 <Peaker> I guess the *By function proliferation is not so bad as you just have these:
08:42:59 <Peaker> @src sort
08:42:59 <lambdabot> sort = sortBy compare
08:43:00 <yitz> Peaker: the idea of allowing lexically scoped declarations comes up often.
08:43:20 <quicksilver> but turns out to have dragons lurking within it
08:43:29 <yitz> right.
08:43:29 <Peaker> mauke, C++ in Haskell? where?
08:43:39 <yitz> probably slayable though
08:44:12 <mauke> "oh, you want to use a custom sort predicate? here, just write a 'functor' class in global scope, you can even reuse it elsewhere", etc
08:45:11 <yitz> mauke: namespace SortWrapper { wrapUnwrap :: ...}
08:45:28 <mauke> aIIRRR
08:46:20 <Peaker> mauke, I just wanted this because I find it inelegant to have sort/sortBy, nub/nubBy, for a lot of functions. Its almost a cartesian product, similarly MonadT vs Monad, etc.   But now it seems to me that Monad is just a convenience alias for MonatT ...Identity... as sort is a convenience alias for sortBy, so its not so bad
08:46:57 <Peaker> (where Monad is not to be taken literally here, but as a place-holder for various monads)
08:47:19 <ehird> Peaker is confusd, I think.
08:47:23 <ehird> *confused
08:47:26 <Peaker> ehird, why?
08:47:31 <ehird> And 'Monad' is not a convenience for 'MonadT'
08:47:33 <ehird> e.g. CGI
08:47:35 <ehird> CGI is CGIT IO
08:47:53 <Peaker> ehird, Well, I don't know all the monads, I have seen this in StateT and ReaderT
08:47:56 <byorgey> in many cases that is true, however.
08:48:06 <byorgey> I think Peaker's intuition is a good one.
08:48:12 <quicksilver> ehird: the intuition is correct
08:48:18 <quicksilver> CGI is anomalous in this respect.
08:48:57 <yitz> Parsec used to be different, now it has a transformer also
08:49:12 <quicksilver> State is isomorphic to StateT Identity, etc.
08:49:16 <allbery_b> I would agree except that I was under the impression monad transformers weren't *quite* as easy as that in some cases
08:49:30 <Peaker> from my experience, though, convenience aliases can be troublesome in that they encourage people to create functionality around them, which is then unavailable in the more general sense
08:49:31 <quicksilver> Peaker: there is, however, a quadratic blowup in the transformers which is certainly annoying.
08:49:43 <yitz> Iavor's monadlib has only the transformers, and every monad stack is based at Id.
08:49:46 <quicksilver> the quadratic number of instances of the MonadFoo classes.
08:50:00 <allbery_b> ah, maybe that wa what I was thinking of
08:50:16 <yitz> quicksilver: and the resulting recursive module dependencies, yuck
08:50:19 <Peaker> quicksilver, I don't understand why people have those - why not newtype each transformer stack and define just the lifters for each level for it?
08:50:48 <quicksilver> Peaker: because the consumer doesn't have to do anything at all, except using newtype deriving.
08:50:52 <quicksilver> so it's no work for the consumer
08:51:00 <quicksilver> it's just annoying work for the library author
08:51:02 <quicksilver> that's why.
08:52:32 <Peaker> quicksilver, I see. could be nice to find a syntax for this kind of information:  x=AMonadT (y=BMonadT view (z=CMonadT Environment m))   such that liftX, liftY, liftZ would work.  note that if AMonadT and BMonadT are the same type - then the MonadFoo class wouldn't know how to lift to the right one
08:52:48 <Peaker> s/Environment//
08:53:42 <ski> yes
08:54:06 <Peaker> I think you want to find a monad by "name" or "purpose" and not by its type
08:54:39 <quicksilver> Peaker: right.
08:54:47 <quicksilver> once you're doing stuff that clever, MonadFoo is no longer useful.
08:54:56 * ski has some ideas regardign monad syntax, which might be possible to extend in this direction ..
08:54:56 <quicksilver> You just write your own combinators instead
08:55:13 <Peaker> quicksilver, My first use of monad transformers uses a reader->state->state->m  transformer so liftState wouldn't help me
08:55:33 <Peaker> ski, what ideas?
08:55:41 <ski> (s/syntax/syntax and type system/)
08:56:11 <ski> not much ready for consumption
08:56:53 <yitz> ski: everyone's looking for that kind of stuff. we're waiting with baited breath...
08:57:10 <ski> the basic idea is just having lexically local side-effecting expressions, the side-effect being determined by a monad
08:57:15 <allbery_b> if it were baited then people would bite :)
08:57:37 <allbery_b> @web bated
08:57:39 <lambdabot> *** "Bated" web1913 "Webster's Revised Unabridged Dictionary (1913)"
08:57:39 <lambdabot> Bate \Bate\, v. t. [imp. & p. p. {Bated}; p. pr. & vb. n.
08:57:39 <lambdabot>    {Bating}.] [From abate.]
08:57:39 <lambdabot>    1. To lessen by retrenching, deducting, or reducing; to
08:57:39 <lambdabot>       abate; to beat down; to lower.
08:57:41 <lambdabot> [28 @more lines]
08:57:47 * yitz releases air, relieved
08:57:53 <Peaker> ski, without lift at all?
08:58:05 <ski> i'm not saying one *can* extend my idea to do what Peaker suggested (in some form) (or even that my basic idea will work out) .. just that it might be possible to do
08:58:14 <quicksilver> Peaker: my point is this:
08:58:31 <quicksilver> Peaker: what does MonadState give you? get, put, modify.
08:58:37 <quicksilver> they really aren't somethign to write home about
08:58:46 <quicksilver> in *real* programs you want more useful custom combinators
08:58:52 <quicksilver> which you only have to write once.
08:59:08 <quicksilver> in a way, MonadState is just an *example* of what's possible rather than a really useful set of combiantors.
08:59:15 <quicksilver> although, it's certainly useful for small/simple cases.
08:59:22 <ski> (Peaker : (speculating) probably there wouldn't be a *need* for `lift'-like functions, using this .. instead using some syntax (could maybe be new keyword `lift', though))
08:59:31 <quicksilver> (I think MonadWriter is rather more useful, actuall)
08:59:51 <quicksilver> but with MonadState you normally want some domain-specific primitives for working on particular chunks of state anywa.
08:59:54 <Peaker> quicksilver, I am not sure what Writer is useful for, yet
09:00:12 <quicksilver> I just mean, MonadWriter is a good primitive for logging (tell)
09:00:20 <quicksilver> and in many cases, tell is really all you need, for logging
09:00:22 <quicksilver> so that's fine.
09:00:30 <Peaker> I thought Writer let you destructively overwrite the state, not "add" to it?
09:00:38 <quicksilver> no, it lets you append
09:00:45 <allbery_b> no, the point of Writer is to append to state
09:00:47 <quicksilver> well, it's a Monoid
09:00:49 <ski> @type Control.Monad.Writer.tell
09:00:49 <Peaker> oh, I see
09:00:50 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
09:00:50 <allbery_b> think of it as a logging monad
09:00:54 <quicksilver> some Monoids might have destructive append
09:01:00 <quicksilver> but in general, we imagine not.
09:01:28 <ski> class (Monoid w,Monad m) => MonadWriter w m
09:01:35 <quicksilver> anyhow, my point is that put and get really aren't good enough primtiives for practical state-based monads
09:01:43 <quicksilver> you almost invariable want some higherlevel stuff
09:01:50 <quicksilver> (they're too primitive!)
09:01:53 <quicksilver> for a particular domain.
09:02:10 <quicksilver> like, in a computer game you might want "modVelocity (+5)"
09:02:26 <quicksilver> or "decreaseHP orc 5"
09:02:35 <quicksilver> (which might be state monad implemented underneath)
09:02:40 <quicksilver> using get and put explicitly is clumsy
09:02:44 <quicksilver> forces you to name the state!
09:02:59 <quicksilver> (and part of the point of using a state monad is not to introduce errors by explicitly naming the state)
09:03:03 <Peaker> quicksilver, Yeah, I have two states stacked up
09:03:09 <Peaker> quicksilver, for two states I have
09:03:11 <ski> @type (`liftM` get)
09:03:12 <lambdabot> forall a1 r (m :: * -> *). (MonadState a1 m) => (a1 -> r) -> m r
09:03:12 * quicksilver nods
09:03:13 <ski> @type (`liftM` modify)
09:03:13 <lambdabot> forall r s (m :: * -> *). (MonadState s m) => (m () -> r) -> (s -> s) -> r
09:03:24 <ski> um
09:03:30 <ski> @type \f -> (`liftM` modify f)
09:03:31 <lambdabot> forall r s (m :: * -> *). (MonadState s m) => (s -> s) -> (() -> r) -> m r
09:03:41 <Peaker> quicksilver, I was wondering how to get more interesting composite states going, I was figuring its probably just holding a composite state inside a normal State?
09:04:27 <ski> something along those lines could be more useful primitives for state (i.e. accessing, setting and modifying particular parts of the state)
09:05:18 <ski> though this should then probably be coupled with functional references, for the modifying and setting part, at lest
09:05:52 <MarcWeber> Can someone explain why line 15 compiles but not 16 ? http://rafb.net/p/xi4qs275.html
09:05:53 <lambdabot> Title: Nopaste - No description
09:06:48 <quicksilver> Peaker: that's a more common way, yes
09:06:54 <quicksilver> Peaker: although obviously they should be isomorphic.
09:07:13 <quicksilver> something esle which you want in a sufficiently large system but isn't often discussed
09:07:14 <MarcWeber> Mmmh Maybe it's not the map I'd expect
09:07:15 <Peaker> quicksilver, are there more interesting ways to do it? with other monads? I don't know many monads besides State/Reader/IO
09:07:27 <ski> get :: MonadState s m => FRef s a -> m a
09:07:31 <Peaker> quicksilver, (and the simple ones, Maybe/List/(->)/etc)
09:07:32 <quicksilver> is the ability to run a Reader action in a State Monad
09:07:35 <ski> set :: MonadState s m => FRef s a -> a -> m ()
09:07:42 <quicksilver> ski: yes, taht would be much better.
09:07:49 <ski> modify :: MonadState s m => FRef s a -> (a -> a) -> m ()
09:07:56 <ski> something like that
09:08:02 <quicksilver> definitely
09:08:04 <ski> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
09:08:04 <quicksilver> much nicer
09:08:06 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
09:08:09 <quicksilver> then you can do
09:08:17 <Peaker> well, we can use IO/IORefs for that? :)
09:08:24 <shachaf> MarcWeber: Did you import qualified Data.Map as M?
09:08:24 <quicksilver> modify (orc 1 . hp) (-5)
09:08:33 <quicksilver> where . is FRef composition
09:08:36 <quicksilver> not funciton composition.
09:08:47 <Peaker> orc?
09:09:17 <shachaf> Oh, wait, I didn't see the error.
09:09:46 <Peaker> quicksilver, is "orc" a reference to a composite value, and "hp" a relative-ref to one of its fields?
09:09:50 <quicksilver> yes
09:09:55 <vincenz> quicksilver: shouldn'it it be
09:09:57 <vincenz> hp . orc 1
09:10:04 <quicksilver> orc is a function which takes an ID and returns a reference
09:10:08 <quicksilver> vincenz: maybe. I wondered that.
09:10:15 <quicksilver> vincenz: you could define ref composition either way around :)
09:10:18 <vincenz> sure
09:10:19 <ski> Pseudonym wrote  compose :: FRef b c -> FRef a b -> FRef a c Isn't that an Arrow?
09:10:23 <Peaker> @type (.)
09:10:23 <vincenz> the atter is oo syntax
09:10:24 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:10:24 <vincenz> erm
09:10:25 <vincenz> the earlier
09:10:34 <ski> Twan wrote  Almost an arrow  Yes, it is *almost* an arrow. More about this in my next post.
09:10:35 <Peaker> quicksilver, would it be compatible with (.) type signature?
09:10:36 <vincenz> quicksilver: what if it weren't' an orc?
09:10:44 <vincenz> gobling 2 . hp
09:10:52 <ski> @type (Control.Arrow.>>>)
09:10:53 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
09:11:10 <quicksilver> Peaker: no, although perhaps we could generalise (.) so it was.
09:11:15 <Peaker> quicksilver, I see
09:11:20 <Peaker> quicksilver, why not use a different operator?
09:11:22 <MarcWeber> shachaf Yes. But I didn't import Data.List at all ..
09:11:22 <quicksilver> ski: is it, in fact an arrow?
09:11:31 <quicksilver> ski: I think not.
09:11:33 <ski> <ski> Twan wrote  Almost an arrow  Yes, it is *almost* an arrow. More about this in my next post.
09:11:35 <quicksilver> ski: it doesn't support pure.
09:11:39 <shachaf> MarcWeber: Well, map is in the Prelude.
09:11:40 <quicksilver> right.
09:11:40 <ski> indeed
09:11:49 <quicksilver> it is a Category though.
09:11:55 <quicksilver> (which is not a very useful observation)
09:11:57 <ski> another reason why `pure' should be separated out !
09:11:59 <quicksilver> just means it's something composable.
09:12:01 <vincenz> everything is a category
09:12:05 <quicksilver> ski: it already has been.
09:12:06 <shachaf> MarcWeber: Is x a list of Strings?
09:12:22 <shachaf> I suppose, yes.
09:12:25 <MarcWeber> shachaf Using import Data.List as L and using L.map has fixed it :)
09:12:35 <shachaf> MarcWeber: Huh.
09:12:40 <shachaf> MarcWeber: Where is the other map coming from?
09:12:52 <ski> quicksilver : where ?
09:13:15 <quicksilver> ski: in the base libraries HEAD, IIRC.
09:13:20 <ski> h
09:13:21 <MarcWeber> shachaf: http://rafb.net/p/pSfXtC31.html :).. I no longer do mind..
09:13:21 <ski> oh
09:13:21 <lambdabot> Title: Nopaste - No description
09:13:22 <quicksilver> ski: it was factored out to Control.Category?
09:13:35 <ski> sounds nice
09:15:16 <quicksilver> ski: http://www.haskell.org/pipermail/libraries/2007-October/008291.html
09:15:17 <lambdabot> Title: Proposal: Add Compositor class as superclass of Arrow, http://tinyurl.com/2uz643
09:15:20 <quicksilver> (thread is rather long)
09:16:10 <quicksilver> also someone (int-e?) was a bit unhappy about the incompatibility it generated.
09:16:13 <Peaker> @where Arrows
09:16:13 <lambdabot> http://www.haskell.org/arrows/
09:16:25 <quicksilver> http://www.haskell.org/pipermail/libraries/2007-November/008593.html
09:16:26 <lambdabot> Title: Control.Category in base, http://tinyurl.com/22jtop
09:26:14 <Peaker> where can I find examples of Arrows?
09:26:22 <Peaker> and of where they are useful?
09:27:20 <quicksilver> @go there and back again invertible parsers
09:27:22 <lambdabot> http://www.cs.ru.nl/A.vanWeelden/bi-arrows/
09:27:22 <lambdabot> Title: There and Back Again: Arrows for Invertible Programming
09:27:35 <quicksilver> Peaker: that's probably one of the best examples of why they are useful.
09:27:52 <Peaker> quicksilver, thanks
09:28:12 <yitz> @quote vincenz everything is a category
09:28:12 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
09:28:19 <mauke> Requires Generic Haskell 1.42, which requires GHC 6.2.2.
09:28:20 <Lemmih> Peaker: You can think of monads as containers for data. Thinking in those lines, arrows are containers for functions.
09:28:20 <mauke> It does not work with Hugs, GHCi, or GHC -fgenerics.
09:28:28 <yitz> @remember vincenz everything is a category
09:28:28 <lambdabot> Nice!
09:29:20 <quicksilver> Lemmih: I'm not really sure about that.
09:29:30 <quicksilver> a -> IO [b] is a fairly useful arrow.
09:29:36 <quicksilver> I'm not sure how that is a container for a function.
09:30:12 <Lemmih> quicksilver: Referring to (->)?
09:30:12 <Peaker> are arrows commonly used? I don't think I've seen mention of them in any of the tutorials I read so far, or various papers
09:30:20 <quicksilver> no, not at all commonly.
09:30:33 <quicksilver> HXT is just about the only "common" use I know of.
09:30:40 <quicksilver> HaXml is "sort-of-arrows".
09:30:49 <quicksilver> (hence the inspiration for HXT, AIUI)
09:30:52 <yitz> Peaker: it always seems to come up in reactive stuff
09:31:14 <yitz> fudgets, and modern derivatives
09:31:15 <quicksilver> none of the reactive frameworks are 'commonly used' according to my understanding of the community.
09:31:15 <Peaker> yitz, I am trying to work on something "reactive", if I can guess what reactive means
09:31:26 <quicksilver> and they're not all arrows.
09:31:32 <quicksilver> tangible values are not arrows, for example.
09:31:42 <yitz> not all, no, but they do come up there commonly
09:32:10 <Lemmih> quicksilver: I'm quite sure about my previous statement.
09:33:01 <quicksilver> Lemmih: I don't see how a -> IO [b] "contains" a function of type a -> b
09:33:05 <quicksilver> Lemmih: that's what I meant.
09:33:15 <tphyahoo> I get errors like ghc tagsoupDemo.hs
09:33:15 <tphyahoo> tagsoupDemo.o: In function `sID_info':
09:33:15 <tphyahoo> (.text+0x751): undefined reference to `tagsoupzm0zi5_TextziHTMLziTagSoupziParser_parseTags_closure'
09:33:27 <quicksilver> tphyahoo: ghc --make
09:33:33 <tphyahoo> but my program works fine in ghci...
09:33:51 <tphyahoo> aha. thanks quicksilver
09:34:09 <Lemmih> quicksilver: I really don't think I said that.
09:34:33 <quicksilver> " Thinking in those lines, arrows are containers for functions."
09:34:41 <Lemmih> Indeed.
09:34:46 <quicksilver> can you illustrate what you *did* mean, using a -> IO [b] as an example?
09:34:57 <sclv> the uuag parser combinators are arrows too, I think?
09:35:47 <sclv> as far as frp, I thought it was mainly yampa that went the arrows route.
09:36:04 <Lemmih> quicksilver: (->) is the arrow. It doesn't have any meta information about the function. However, a parser arrow might very well keep some meta information about the function it contains.
09:36:17 <sclv> conal's stuff as i recall tries to stick to applicatives.
09:37:27 <rog_> hello
09:37:35 <shachaf> rog_: Hello.
09:39:22 <rog_> i'm looking for a good haskell book. i'm reasonably familiar with quite a few languages (e.g. C, Lisp, ML) so i'd like something that would be a useful lasting reference. is Graham Hutton's book the one to get?
09:39:52 <dbpatterson> rog_: haskell school of expression (hudak)?
09:39:55 <gnuvince> rog_: I bought it, and it's pretty good.
09:41:36 <rog_> dbpatterson: looks interesting. your question mark indicates some doubt?
09:41:57 <Lemmih> quicksilver: (->) a (IO [b])  contains a function from 'a' to 'IO [b]'.
09:41:59 <Cale> Or maybe Bird's book? If you already know ML well, then learning Haskell should be more a process of internalisation, I'd suspect.
09:42:29 <Cale> Have you read the Gentle intro? It's rather fast, but you might be well-suited to it.
09:42:30 <Peaker> Baughn, seems that I was pointed to the right direction. This paper describes "Differential computing" as "Incremental computing", and is a pretty interesting approach to do it in Haskell  http://www.cse.ogi.edu/~magnus/papers/icfp-2002.pdf
09:43:01 <dbpatterson> rog_: question mark only questioning whether you had considered it. definitely is higher level than graham huttons book, but as someone new to haskell, it + online tutorials seem to be plenty (to get started...)
09:43:30 <ski> if `ListT' were a monad transformer, then `a -> IO [b]' would be a morphism from `a' to `b' in the kleisli category of `ListT IO' .. perhaps something like this is what Lemmih was meaning ?
09:43:57 <phlpp> lol wtf. my local linux user group announced two meetings at the same time, the ordinary meeting and a introductive report an haskell.. (they are sent automatically to the mailing list).. someone asked, if these are events for schizophrenic people or sth like that, and then someone answered "no, it's just lazy. the (most) demanded event will take part"
09:44:02 <phlpp> ;D
09:45:41 <maokt> rog_: I agree with dbpatterson.  Haskell School of Expression is good.
09:45:56 <maokt> Not as a reference, but a fun intro.
09:47:40 <Lemmih> ski: Definitely not.
09:49:39 <rog_> Cale: i had a look at the Gentle Intro when i was trying to work out how the *"!@ monads worked. to be honest, i didn't find it that great. i attained enlighenment through an wadler's "how to declare an imperative" instead
09:49:48 <rog_> s/an//
09:50:14 <Cale> rog_: I don't think the Gentle intro really talks all that much about monads.
09:50:39 <Cale> rog_: Monads are just a way to structure libraries similarly so that some general functions can be shared between them.
09:51:22 <ski> Lemmih : (no ?) .. then what ?
09:51:29 <shachaf> rog_: Hutton's book is nice, but a bit short, I think.
09:51:45 <rog_> Cale: it's got a chapter on them, which i puzzled over for quite a while, without working out a) why? or b) how can this make the IO monad work?
09:51:56 <Cale> rog_: ah
09:52:32 <mauke> IO has nothing to do with monads :-)
09:52:42 <Cale> rog_: It's perhaps interesting that you can treat those two things entirely separately.
09:53:32 <rog_> Cale: i really enjoyed the wadler paper because it showed some of the original motivations (and difficulties).
09:53:53 <rog_> mauke: but the IO monad does... no?
09:54:05 <Cale> rog_: It is an example of a monad, and that's about it.
09:54:28 <Cale> rog_: We simply define it as one so as to take advantage of the Control.Monad library.
09:54:37 <shachaf> rog_: IO is not necessarily the best example to start with, also.
09:54:43 <Cale> But it's not entirely necessary -- any combinator library would do.
09:54:44 <mauke> rog_: not really
09:55:03 <Cale> It's just that bind is a sort of natural way to glue IO actions together.
09:55:07 <rog_> Cale: but it's also the original canonical example of a monad, and one which you almost have to use to do useful stuff in haskell as far as i can see.
09:55:07 <mauke> haskell's IO system would work just the same without mentioning monads anywhere
09:55:20 <Cale> rog_: I don't find it all that canonical...
09:55:25 <mauke> you can use IO without learning anything about monads
09:55:48 <Cale> rog_: As far as monads go, it's a pretty complicated example.
09:55:51 <Lemmih> ski: I'm having a hard time understanding why I'm not being clear.
09:56:06 <yitz_> @go monads as computation
09:56:06 <dbpatterson> mauke: but you would probably think you just had to go through an inordinate amount of hand waving, no?
09:56:12 <lambdabot> http://blogs.msdn.com/dsyme/archive/2007/09/22/some-details-on-f-computation-expressions-aka-monadic-or-workflow-syntax.aspx
09:56:12 <lambdabot> Title: Don Syme's WebLog on F# and Other Research Projects : Some Details on F# Computa ...
09:56:18 <Cale> http://www.haskell.org/haskellwiki/Monads_as_computation
09:56:18 <yitz_> nah
09:56:18 <lambdabot> Title: Monads as computation - HaskellWiki
09:56:22 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
09:56:23 <lambdabot> Title: Introduction to IO - HaskellWiki
09:56:25 <EvilTerran> ?go io monad don't care
09:56:25 <yitz_> yeah!
09:56:26 <lambdabot> http://sigfpe.blogspot.com/2007/11/io-monad-for-people-who-simply-dont.html
09:56:26 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
09:56:28 <Cale> those are my tutorials :)
09:56:34 <mauke> dbpatterson: no, why?
09:56:36 <Lemmih> ski: Arrows are to functions as monads are to values. To me that's pretty clear.
09:56:43 <yitz_> @go monads as containers
09:56:45 <lambdabot> http://www.haskell.org/haskellwiki/Monads_as_Containers
09:56:45 <lambdabot> Title: Monads as containers - HaskellWiki
09:56:47 <mauke> dbpatterson: monads are the handwavy parts
09:56:56 <mauke> there is no magic here
09:57:04 <EvilTerran> "monads as sign language"
09:57:25 <shachaf> @quote think.of.a.monad
09:57:26 <lambdabot> No quotes match.
09:57:28 <Cale> Well, to understand the IO monad, you don't have to understand the monadic abstraction.
09:57:31 <dbpatterson> mauke: do notation? not being able to just use 'getChar' etc? having to pull things out to use them again? adding in IO everywhere (well, that last one is easier to understand w/o monads)
09:57:38 <Cale> You do however, have to learn about return :: a -> IO a
09:57:46 <Cale> and (>>=) :: IO a -> (a -> IO b) -> IO b
09:57:49 <rog_> my eureka moment was realising that the value returned from the io monad functions was itself a function (but executed in an imperative environment, and guaranteed sequential by the bind composition operator).
09:57:51 <mauke> dbpatterson: do notation is just syntactic sugar
09:58:09 <dbpatterson> mauke: okay, so learning >>= and >> is easier?
09:58:13 <mauke> yes
09:58:18 <mauke> definitely
09:58:55 <Cale> rog_: I wouldn't think of it as such. A value of type (IO t) is simply a description of something to do which would produce a value of type t if it were executed.
09:58:56 <dbpatterson> mauke: my opinion of course, but it seems that for someone not interested in learning anything about monads, and just doing IO, it isnt...
09:59:11 <Cale> rog_: There's not really a well-specified input there.
09:59:20 <mauke> dbpatterson: how else are you going to understand the IO system?
09:59:29 <Cale> So it's more like a procedure than a function, I suppose.
09:59:41 <Cale> A value representing a procedure.
09:59:59 <dbpatterson> mauke: perhaps I'm misunderstanding... I thought the point was to NOT understand anything, and just do things...
10:00:09 <rog_> Cale: but my difficulty with that was that there's no way to execute it...
10:00:09 <dbpatterson> (no pun intended)
10:00:28 <mauke> dbpatterson: that leads to anger, anger leads to suffering, etc
10:00:32 <Cale> rog_: The Haskell RTS is the only thing which is allowed to execute one of these, and it always executes the one called main
10:00:41 <rog_> Cale: just to check i understood, i knocked up a simple version of the IO monad in C.
10:00:44 <ski> Lemmih : probably i was too cryptic, since i agree with you on that. i was just commenting on "You can think of monads as containers for data. Thinking in those lines, arrows are containers for functions" as thinking of arrows as functions (usually) with some possibly "dynamic effect" (e.g. `ListT IO') but also possibly some "static effect" (e.g. in the case of collected static information about parser arrows) ..
10:00:52 <dbpatterson> mauke: :)
10:02:22 <tromp> i think it's fine to consider IO t values to be functions oldworld -> (newworld, value)
10:02:38 <Cale> rog_: There are a number of ways to implement that abstraction. You can even do it in a pure language, if you're willing to hand all the real work of carrying out the actions off to the runtime system
10:02:46 <mauke> tromp: I disagree, because it's impossible to shove the entire real world through a computer function
10:03:11 <Cale> rog_: If I were to do it today, I would probably implement the IO monad using a datatype (a GADT actually) that looks something like this:
10:03:15 <Cale> data IO a where
10:03:20 <Cale>    ReturnIO :: a -> IO a
10:03:22 <tromp> mauke, it needn't be feasible to be a useful abstraction:)
10:03:29 <Cale>    BindIO :: IO a -> (a -> IO b) -> IO b
10:03:37 <Cale>    GetChar :: IO Char
10:03:38 <mauke> tromp: if all you want is an abstraction, use IO
10:03:40 <mauke> it's already abstract
10:03:43 <Cale>    PutChar :: Char -> IO ()
10:03:54 <Cale>    ForkIO :: IO a -> IO ThreadId
10:04:02 <Cale>    ... and so on ...
10:04:17 <Cale> Basically, the primitive IO actions just become constructors of my datatype
10:04:30 <Cale> and so do bind and return
10:05:00 <Cale> and the RTS will just take that datastructure apart, higher-order abstract syntax and all, and carry out the effects involved (so there will be some real imperative bits there)
10:05:05 <rog_> how does that differ from the conventional IO datatype?
10:05:35 <Cale> rog_: Well, GHC cheats, and just stores a piece of impure code -- an impure Haskell function in fact.
10:05:36 <ehird> Cale: that's totally unextensible though
10:06:09 <rog_> presumably you've got to have some impure code somewhere?
10:06:19 <Cale> Well, yes
10:06:35 <Cale> rog_: My approach just makes sure that the (IO t) values themselves are pure
10:07:17 <Cale> and all the impurity ends up in the runtime system
10:07:34 <Cale> @src IO
10:07:34 <rog_> Cale: i thought they were.
10:07:34 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
10:08:10 <rog_> but you're not really allowed to look inside that, right?
10:08:20 <Cale> Whereas GHC cheats, and passes around a token value to keep data dependencies straight while using impure functions to encode the effects
10:08:25 <Cale> Right, you can't see inside it
10:08:28 <mauke> oh, that reminds me
10:08:32 <mauke> @src [] (>>=)
10:08:32 <lambdabot> m >>= k     = foldr ((++) . k) [] m
10:08:33 <Cale> But it's a somewhat different mental model.
10:08:40 <mauke> can we change that to use concatMap?
10:08:44 <Cale> mauke: Oh, yeah, I should fix that.
10:10:10 <rog_> when i "got" monads, i tried hard to think *why* i'd found them so hard to grasp. and why none of the "intro to monads" tutorials on the net had worked for me.
10:10:13 <Cale> @src [] (>>=)
10:10:13 <lambdabot> m >>= k     = foldr ((++) . k) [] m
10:10:16 <Cale> er...
10:10:24 <Cale> hmm
10:11:04 <Cale> @src [] (>>=)
10:11:10 <lambdabot> xs >>= f     = concatMap f xs
10:11:24 <mauke> @src concatMap
10:11:32 <lambdabot> concatMap f = foldr ((++) . f) []
10:11:48 <Cale> I think the list monad is my favourite example of a monad
10:11:57 <rog_> i think it was because the "value" of a monad often includes code from your own program.
10:11:57 <EvilTerran> ... shouldn't that just be "concat . map f"? fusion can take care of the details :P
10:12:19 <Cale> > do x <- [1,2,3]; y <- [4,5]; z <- [6,7,8]; return (x,y,z)
10:12:23 <lambdabot>  [(1,4,6),(1,4,7),(1,4,8),(1,5,6),(1,5,7),(1,5,8),(2,4,6),(2,4,7),(2,4,8),(2,...
10:12:31 <rog_> which is normal for haskell, i think, but a bit of a mind-stretch.
10:12:36 <Cale> rog_: A value typed in a monad
10:12:45 <Peaker> EvilTerran, Yeah I also wondered why we have concatMap instead of concat . map
10:12:56 <Cale> rog_: Yeah, it's normal for functional programming, but very unintuitive if you're used to imperative programming.
10:13:06 <EvilTerran> Peaker, well, it's cleaner to use for pointsfree programming
10:13:10 <shachaf> Peaker: (concat .) . map, you mean.
10:13:14 <EvilTerran> as concatMap = (concat .) . map, which is fugly
10:13:30 <EvilTerran> if we had .: in the standard library, tho...
10:13:32 <xerox> ?type let (.:) = (.) . (.) in concat .: map
10:13:33 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
10:13:43 * ski smiles
10:13:45 <conal> not so bad though: concatMap = (fmap.fmap) concat map
10:13:47 <shachaf> (.:) is the name people are using now?
10:13:50 <xerox> :-)
10:13:58 <rog_> Cale: more normal in non-strict functional programming. in ML for example, you *know* when you've got a piece of code - the value is of functional type.
10:14:00 <EvilTerran> shachaf, well, that's all i've seen it called
10:14:04 <ski> shachaf : afaik, i invented that name ..
10:14:09 <shachaf> @ty fmap fmap fmap concat map
10:14:10 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
10:14:11 <Cale> rog_: Say, to represent a stateful computation as a function from an initial state to a value and a final state is natural for functional programmers because prior to the State monad, that's what they'd usually code like by hand
10:14:14 <conal> or (result.result) concat map
10:14:22 <shachaf> @ty map -- Caleskell?
10:14:23 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:14:34 <Cale> rog_: You can still wrap a function inside a data constructor in ML
10:14:35 <ski> (i.e. i definitely did. but maybe others did independently ..)
10:14:43 <shachaf> Cale: You should fix that one too, if you changed (.). :-)
10:14:45 <conal> i think it's the infixness of (.) that keeps people from using compositionally.
10:15:02 <Cale> @t map
10:15:03 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:15:06 <Cale> :t map
10:15:07 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:15:19 <Cale> shachaf: Oh, you're saying I should generalise map
10:15:22 <Cale> hmm
10:15:27 <Cale> Yeah, I could do that.
10:15:32 <shachaf> Cale: Yes -- it makes even more sense than (.).
10:15:36 <xerox> It scales, (.::) = (.) . (.) . (.), (.:::) = (.) . (.) . (.) . (.)
10:15:37 <rog_> Cale: true. but you have to explicitly execute it.
10:15:41 <shachaf> (Which you could argue about.)
10:15:54 <Cale> rog_: Which you usually do in Haskell as well :)
10:16:01 <ski> conal : do you have some file available that defines `result', etc ? (or maybe you had a paper ?)
10:16:02 <xerox> Where the number of composed compositions is the number of arguments of the left hand funcion (reflected in a line of dots in the combinators)
10:16:14 <mauke> cadddddddddr
10:16:16 <shachaf> @ty let (..) = (.) . (.) in concat .. map -- Does this work, or is reserved?
10:16:17 <lambdabot> parse error on input `..'
10:16:18 <Cale> rog_: Only in the very special case of the IO monad do you hand the execution off to something else.
10:16:20 <conal> one drawback of (.:::) etc is that you miss the opportunity to mix in first and second with the (.)
10:16:25 <Twey> >  (,) 10 (3, 4)
10:16:26 <lambdabot>  (10,(3,4))
10:16:28 <conal> ski: it's in DeepArrow
10:16:34 <shachaf> @ty let (...) = (.) . (.) in concat ... map -- How about this?
10:16:34 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
10:16:42 <Twey> >  (,) (10, 3) 4
10:16:42 <lambdabot>  ((10,3),4)
10:16:45 <Twey> Hm
10:16:49 <ski> conal : which is where ?
10:16:52 <Twey> > (10, 3, 4)
10:16:52 <lambdabot>  (10,3,4)
10:16:56 <shachaf> Letting (...) = (.) (.) (.) makes a sort of sense.
10:16:57 <conal> ski: and is generalized beyond functions.
10:16:59 * Twey doesn't understand.
10:17:01 <conal> @wiki DeepArrow
10:17:01 <lambdabot> http://www.haskell.org/haskellwiki/DeepArrow
10:17:13 <mauke> > (,,) 10 3 4
10:17:13 <lambdabot>  (10,3,4)
10:17:18 <conal> ski: described in the Eros paper
10:17:22 <conal> @where Eros
10:17:22 <lambdabot> http://conal.net/papers/Eros
10:17:32 <Twey> mauke: Eh?
10:17:35 <mauke> Twey: hmm?
10:17:36 <ski> conal : yes, istr that it worked for other things, too
10:17:37 <Cale> @undef
10:17:37 <lambdabot> Undefined.
10:17:40 <Cale> :t map
10:17:41 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:17:43 <Cale> hmm
10:17:50 <conal> ski: yes, e.g., user interfaces
10:17:56 <Cale> @undef
10:17:57 <Twey> mauke: How does that work?  ,, can't be used as an operator, surely
10:17:57 <lambdabot> Undefined.
10:18:02 <Cale> :t map
10:18:02 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
10:18:05 <conal> (user interface == visualizer)
10:18:06 <Cale> what the...
10:18:16 <Cale> oh, duh
10:18:21 <mauke> Twey: no, but (,,) can be used as a function
10:18:30 <Twey> (,,) 1 2 3 doesn't map regularly to (1, 2, 3)
10:18:35 <Cale> @undef
10:18:35 <lambdabot> Undefined.
10:18:37 <Cale> :t map
10:18:38 <lambdabot>     Ambiguous occurrence `map'
10:18:38 <lambdabot>     It could refer to either `L.map', defined at State/L.hs:14:0
10:18:38 <lambdabot>                           or `Data.List.map', imported from Data.List at State/imports.h:21:0-29
10:18:40 <Twey> So , is Magic Syntax?
10:18:43 <Cale> oh, heh
10:18:46 <mauke> yes
10:18:50 <Twey> (,,,,) 1 2 3 4 5
10:18:53 <Twey> > (,,,,) 1 2 3 4 5
10:18:54 <lambdabot>  (1,2,3,4,5)
10:18:55 <Cale> @undef
10:18:55 <lambdabot> Undefined.
10:18:57 <Twey> Huh.
10:18:58 <Cale> :t map
10:18:59 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:19:02 <Cale> there we are
10:19:08 <Cale> back to Haskell 1.4 glory :)
10:19:14 <Twey> Are those defined for anything?
10:19:18 <dons> oh dear
10:19:19 <shachaf> > map map map concat map
10:19:20 <lambdabot>  Add a type signature
10:19:28 <shachaf> > map map map concat map `asTypeOf` concatMap
10:19:28 <lambdabot>  Add a type signature
10:19:37 <shachaf> @ty map map map concat map
10:19:38 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
10:19:39 <Twey> > (,,,,,,,,,,,,) 1 2 3 4 5 6 7 8 9 10 11 12 13
10:19:39 <lambdabot>  (1,2,3,4,5,6,7,8,9,10,11,12,13)
10:20:16 <Twey> :t (,)
10:20:17 <lambdabot> forall a b. a -> b -> (a, b)
10:20:21 <shachaf> Cale: Do we have Functor=>Monad or Functor=>Applicative=>Monad yet? :-)
10:20:28 <Cale> no
10:20:34 <Cale> That would screw everything up
10:20:38 <rog_> Cale: i think it's just the fact that something that looks like a simple variable can have arbitrary computational complexity to use
10:20:51 <Cale> If you try to define your own Monad class, it doesn't play well with the rest of the modules in base
10:21:28 <Cale> So if we want to do that, we'll have to start hacking on base :)
10:21:38 <shachaf> I suppose it doesn't make much of a difference for @run anyway.
10:21:47 <Cale> Who wants to set up the darcs repo? ;)
10:22:13 <lament> is there an explanation of the map/fmap/. issue somewhere?
10:22:35 <shachaf> lament: Explanation? (.) and map are both specifications of fmap.
10:22:40 <mauke> map --> fmap <-- .
10:22:44 <shachaf> > (+1) . [1,2,3]
10:22:45 <lambdabot>  [2,3,4]
10:23:30 <lament> well, the issue with them being different
10:23:32 <Jaak> @type map
10:23:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:23:51 <Cale> lament: The Haskell 98 committee was afraid of polymorphism
10:23:55 <sclv> sigh
10:24:08 <Cale> lament: Have a look at the Haskell 1.4 prelude sometime :)
10:24:11 <lament> Cale: because monads weren't as entrenched yet?
10:24:12 <sclv> ?hoogle map
10:24:12 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
10:24:12 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
10:24:12 <lambdabot> Data.ByteString.map :: (Word8 -> Word8) -> ByteString -> ByteString
10:24:23 <mauke> there is such a thing as too much polymorphism, and fmap isn't it
10:24:26 <sclv> ^^ the "real" one
10:24:31 <Deewiant> > map map map map id id id []
10:24:32 <lambdabot>  []
10:24:47 <mauke> > fmap fix return ()
10:24:47 <lambdabot>  ()
10:24:47 <dons> that's just silly
10:24:52 <shachaf> That reminds me: Can lambdabot have monad comprehensions too? And MonadZero? :-)
10:25:04 <Cale> shachaf: Contribute to GHC and it can.
10:25:33 <rog_> anyway, thanks all for the recommendations. i think i'll try the Hudak.
10:25:50 <Cale> Apart from monad comprehensions, I'd also like a flag to be able to flip the do-notation translation around.
10:26:01 <Cale> and then we can start our own new base package :)
10:26:09 <ski> @arr
10:26:10 <lambdabot> Har de har har!
10:26:13 <shachaf> Cale: Flip it around?
10:26:16 <sclv> @quote fmap
10:26:16 <lambdabot> sioraiocht says: [after fmap = (.)] omg; my life; is much happier now
10:26:20 <Cale> shachaf: So it doesn't use fail
10:26:22 <sclv> @quote fmap
10:26:22 <lambdabot> mauke says: fmap fix return is the e^(i*pi)+1 of haskell
10:26:39 <ski> or so that `fail' uses `MonadFail'
10:26:39 <shachaf> Surely that @quote means "[after (.) = fmap]"?
10:26:45 <Cale> shachaf: At the very least we should move fail into its own class, eyah
10:26:46 <Cale> yeah*
10:26:47 <Saizan> Cale: you could have a different fail in scope with -fno-implicit-prelude?
10:27:04 <shachaf> Maybe it should just be in MonadZero.
10:27:11 <shachaf> Where fail _ = mzero, by default.
10:27:33 <Cale> That's still slightly ugly, but it's tolerable :)
10:28:04 <shachaf> Cale: How would you prefer to do things? Just use mzero?
10:28:15 <Cale> shachaf: probably, yeah
10:28:49 <shachaf> But at the moment, with the way do-notation works, it has to be defined.
10:29:17 <Cale> One thing I'm sure of: using a refutable pattern match in a do-block should really result in a different class context from Monad.
10:29:26 <Saizan> well the line-number is useful for IO or other MonadErrors
10:29:50 <Cale> Saizan: that's true.
10:31:38 <roconnor> shachaf: do notation could simply throw an error on pattern match failure.
10:31:55 <roconnor> the fact that it calls fail is a convinence.
10:32:48 <roconnor> I could imagine a system where pattern matches in do-variables are not allowed unless the monad is an instance of monadzero
10:33:32 <shachaf> Perhaps it could already work that way.
10:33:44 <shachaf> (At least, given the way @undo translates do-notation.)
10:33:57 <shachaf> @undo do { x <- m; return x }
10:33:57 <lambdabot> m >>= \ x -> return x
10:34:02 <shachaf> @undo do { Left x <- m; return x }
10:34:02 <lambdabot> m >>= \ a -> case a of { Left x -> return x; _ -> fail ""}
10:34:30 <cnwdup> I've defined a type App that's essentially a ReaderT holding an environment. Now I got some functions that produce the type App Html and I thought it'd be neat to use Html operators like +++ with App Html and thus I wanted to make App an instance of HTML. Is this approach right?
10:34:57 <roconnor> shachaf: yep.  The desugaring seems to produce an expression with either a Monad or a MonadZero constraint
10:35:14 <mauke> > do { () }
10:35:14 <lambdabot>  Couldn't match expected type `t t1' against inferred type `()'
10:35:30 <Saizan> ?type do undefined
10:35:31 <lambdabot> forall (t :: * -> *) t1. t t1
10:35:42 <roconnor> I wouldn't be suprised if GHC just worked if you redid the prelude.
10:35:57 <mib_ose1bg> heys guys is it possible to used a IO Int to produce a Int
10:36:03 <shachaf> > do do do Nothing
10:36:04 <lambdabot>  Nothing
10:36:11 <lament> :t (.)
10:36:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:36:20 <shachaf> mib_ose1bg: Only if you give back an IO in the end.
10:37:22 <roconnor> mib_ose1bg: typically one doesn't produce an in.  Instead write a function Int -> IO foo that consumes your Int.  And then glue your producer (IO Int) to your consumer Int -> IO Foo with do notation do {i <- producer; consumer i}
10:37:29 <roconnor> *produce an int
10:37:56 <mib_ose1bg> i wrote a function to find the coordinate of a char, it returns a IO Int, but in order for the main function to use it, it must be a IO
10:38:01 <mib_ose1bg> what can i do?
10:38:06 <lament> haskell98's (.) is fmap in the -> monad?
10:38:16 <mauke> lament: yes
10:38:24 <mrd> lament: ((->) a)
10:38:28 <mauke> mib_ose1bg: use >>=
10:38:38 <shachaf> The (r ->) functor, anyway.
10:38:54 <roconnor> mib_ose1bg: what do you want to do with the cooridnate?  print it?
10:39:10 <lament> oh, right
10:39:26 <mib_ose1bg> yes
10:39:37 <shachaf> mib_ose1bg: Note that IO Int doesn't actually contain an Int.
10:39:48 <roconnor> do { i <- myIoInt; print i }
10:40:06 <shachaf> mib_ose1bg: It'll compute an Int if you ask it to, but the Int isn't "inside it".
10:40:09 <mib_ose1bg> ok
10:42:01 <ehird> ?type do ?a
10:42:13 <lambdabot> forall (t :: * -> *) t1. (?a::t t1) => t t1
10:42:14 <mib_ose1bg> basically the fun is like this: showCordinate n = (getpos (n,0)::IO Int) << in order the the function to execute as to be IO only, it does nothing now
10:42:17 <ehird> ?type do a
10:42:18 <lambdabot>     Couldn't match expected type `t t1' against inferred type `Expr'
10:42:18 <lambdabot>     In the expression: a
10:42:22 <ehird> ?type do foobarbaz
10:42:23 <lambdabot> Not in scope: `foobarbaz'
10:43:30 <hpaste>  Saizan pasted "-fno-implicit-prelude is enough for fail" at http://hpaste.org/6752
10:43:31 <mib_ose1bg> is it possible for to use a IO Int to process something e.g. b <- 4::IO int >> testdata !! b ???
10:44:00 <lament> 4 is not an IO Int
10:44:03 <lament> 4 is an Int
10:45:07 <lament> if you just want b to be 4, you could do "let b = 4"
10:45:59 <profmakx> lda diplom von der elitären hochschnulze zu aachen...
10:46:00 <profmakx> oder so
10:46:06 <profmakx> whups
10:46:07 <profmakx> sorry
10:47:05 <mib_ose1bg> after processing the coordinates it returns a IO Int, i want to use that value text !! (returnCordinates)
10:47:22 <mib_ose1bg> is that possible or is that an error?
10:47:23 <Nafai> Is this my best choice if want to parse e-mail messages? http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsemail-1.2
10:47:26 <mib_ose1bg> ?>>=
10:47:26 <lambdabot> Unknown command, try @list
10:47:27 <lambdabot> http://tinyurl.com/2oe689
10:47:31 <mib_ose1bg> >>=
10:47:40 <mib_ose1bg> > >>=
10:47:40 <lambdabot>   parse error on input `>>='
10:47:43 <EvilTerran> ?type (>>=)
10:47:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:47:53 <EvilTerran> ?index (>>=)
10:47:53 <lambdabot> Control.Monad, Prelude, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
10:48:02 <EvilTerran> etc
10:48:56 <EvilTerran> mib_ose1bg, i think you want "liftM (text !!) <your IO Int>
10:49:32 <EvilTerran> or, alternatively, "i <- <your IO Int>; ... text !! i"
10:49:37 <EvilTerran> in a do block
10:50:09 <Deewiant> > (Just 1) >>= return.("foo" !!)
10:50:09 <lambdabot>  Just 'o'
10:53:02 <mib_ose1bg> ok
10:53:02 <mib_ose1bg> what's >>= ??
10:53:14 <araujo> binding operator
10:53:28 <yitz_> yo Cale
10:53:36 <Cale> yeah?
10:53:50 <araujo> you can think of it like a "extract the value from the left and throw it forward to the right"
10:53:55 <araujo> mib_ose1bg, ^^
10:54:07 <Cale> mib_ose1bg: Oh, you should read my very quick tutorial :)
10:54:15 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
10:54:16 <lambdabot> Title: Introduction to IO - HaskellWiki
10:54:30 <yitz_> hi. Since IO is not available, it'd be great for these kinds of examples if the bot would have the Identity monad in scope. It's the only mtl monad that's not.
10:54:37 <Cale> mib_ose1bg: It doesn't cover all the details, but it covers the basic idea well enough to get you started.
10:54:41 <yitz_> Can you do that?
10:54:47 <Cale> yitz_: sure
10:55:00 <yitz_> thanks!
10:55:29 <vegai> > putStrLn "Foo"
10:55:30 <lambdabot>  <IO ()>
10:55:42 <vegai> heh. Cool
10:55:43 <Cale> @undef
10:55:43 <lambdabot> Undefined.
10:55:45 <lament> it would be nice to have IO, within reason
10:55:57 <lament> one-liner output should work
10:56:05 <yitz_> lament: the hackers would like that, too
10:56:06 <Cale> return 5 >>= (\x -> return (x + 5))
10:56:09 <Cale> > return 5 >>= (\x -> return (x + 5))
10:56:09 <vegai> Cale: hmm, did that define something?
10:56:09 <lambdabot>   add an instance declaration for (Show (m t))
10:56:10 <lament> and input could be always fed some dummy value, for didactic purposes
10:56:15 <Cale> > return 5 >>= (\x -> return (x + 5)) :: Identity Integer
10:56:16 <lambdabot>        add an instance declaration for (Show (Identity Integer))
10:56:18 <Cale> hmm
10:56:26 <Cale> > runIdentity (return 5 >>= (\x -> return (x + 5)))
10:56:26 <lambdabot>  10
10:56:32 <lament> yitz_: "within reason", meaning "putStr" :)
10:56:52 <Cale> lament: That would be asking for trouble, I think.
10:57:05 <Cale> :)
10:57:07 <vegai> perhaps "safe IO actions" should be in another monad :P
10:57:13 <Cale> At least without a more sophisticated IO monad.
10:57:23 <yitz_> even that - you'd have to be very careful redirecting it to IRC. Think about what you could do with it...
10:57:26 <lament> on the other hand, for didactic purposes it's perhaps even better that > putStr "hi" return an io value. That's what it's actually supposed to do
10:57:30 <Cale> See, if the IO monad were pure, we could write a pure evaluator for it :)
10:57:57 <lament> "see, putStr doesn't actually print anything"
10:58:06 <yitz_> That's why I want Identity.
10:58:14 <desegnis> vegai, and lambdabot evaluating putStrLn "hello" :: SafeIO () to "hello"? :)
10:58:15 <Cale> yitz_: That's not the same though :)
10:58:33 <yitz_> true but...
10:58:46 <Cale> yitz_: With a pure evaluator for the IO monad, you could run putStrLn, and get all the output as a String at the end.
10:58:49 <yitz_> @let putStr = runIdentity
10:58:50 <lambdabot> Defined.
10:58:54 <Cale> @undefine
10:58:55 <lambdabot> Undefined.
10:58:58 <yitz_> hehe
10:58:59 <Cale> ;)
10:59:51 <mauke> :t cat
10:59:52 <lambdabot> [Doc] -> Doc
10:59:53 <vegai> the other day, I noticed that lambdabot's command letter cannot be changed from '@'
11:00:05 <vegai> I wonder if anyone noticed and fixed it already
11:00:05 <mauke> why is that in scope?
11:00:08 <Cale> vegai: It can't?
11:00:19 <roconnor> @go 8 oz in g
11:00:20 <lambdabot> 8 ounces = 226.796185 grams
11:00:32 <vegai> Cale: yeah. It fails to start if '@' is not in the list
11:00:36 <Cale> oh
11:00:47 <vegai> I suppose something is hardcoded to expect it to be '@'
11:00:48 <mauke> > wat
11:00:49 <lambdabot>  oh god how did this get here? I am not good with computers
11:01:28 <EvilTerran> ...?
11:01:34 <EvilTerran> ?src wat
11:01:35 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
11:01:35 <lament> :t wat
11:01:36 <lambdabot> forall a. Sym a
11:01:54 <EvilTerran> ... someone's playing with \b in pm again, i suspect
11:02:08 <Jaak> \b?
11:02:12 <lament> Sym?
11:02:14 <shachaf> Jaak: Î»bot.
11:02:21 <Jaak> aah
11:02:22 <Cale> It's just a var
11:02:23 <shachaf> @ty var "a"
11:02:23 <lambdabot> forall a. Sym a
11:02:26 <yitz_> @info Sym
11:02:26 <lambdabot> Sym
11:02:48 <EvilTerran> > var "what's going on over here?"
11:02:48 <lambdabot>  what's going on over here?
11:03:08 <EvilTerran> ?index Sym
11:03:08 <lambdabot> bzzt
11:03:22 <lament> > wat + 42
11:03:22 <lambdabot>  42+oh god how did this get here? I am not good with computers
11:03:34 <EvilTerran> ah. SimpleReflect.
11:05:26 <MarcWeber> Anyone hacking on shim ?
11:05:32 <lament> > iterate tail wat
11:05:32 <lambdabot>   Not in scope: `wat'
11:05:37 <lament> too late!
11:06:21 <shachaf> > is lambdabot smart
11:06:21 <lambdabot>  Of course!
11:06:24 <mauke> @let quine = var "> quine"
11:06:25 <lambdabot> Defined.
11:06:28 <mauke> > quine
11:06:28 <lambdabot>  > quine
11:06:37 <shachaf> > lambdabot is smart
11:06:37 <lambdabot>  Agreed.
11:06:45 <shachaf> > smart lambdabot is
11:06:46 <lambdabot>  Unable to parse sentence.
11:07:05 <shachaf> ?where zap
11:07:05 <lambdabot> ?where zap
11:07:14 <mauke> @redefine world
11:07:15 <lambdabot> Undefined.
11:07:30 <yitz_> > quine "to quine a phrase"
11:07:31 <lambdabot>   Not in scope: `quine'
11:08:03 <yitz_> are we out of the twilight zone yet?
11:08:19 <yitz_> @type is
11:08:20 <lambdabot> Not in scope: `is'
11:08:24 <Baughn> @src var
11:08:24 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:08:40 <yitz_> @vixen are you smart?
11:08:40 <lambdabot> yes, i am
11:09:20 <Twey> @vixen Do you like green eggs and ham?
11:09:20 <lambdabot> i'd say i like
11:09:28 <Twey> Heh
11:09:39 <shachaf> > quine "to quine a phrase"
11:09:40 <lambdabot>  "to quine a phrase" to quine a phrase
11:10:03 <yitz_> how'd that come back?
11:10:16 <Twey> > quine "foo"
11:10:16 <lambdabot>  "foo" foo
11:10:19 <Twey> :-)
11:10:44 <EvilTerran> > var . ((++) <*> show) $ "> var . ((++) <*> show) $ "
11:10:45 <lambdabot>  > var . ((++) <*> show) $ "> var . ((++) <*> show) $ "
11:10:52 <wagle_home> > quine quine
11:10:52 <lambdabot>  Couldn't match expected type `[Char]'
11:10:59 <EvilTerran> i r teh winrar
11:10:59 <lament> haha @ "Monad transformers are like onions. At first, they make you cry but then you learn to appreciate them. Like onions, they're also made of layers."
11:11:04 <ski> > fix quine
11:11:04 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Sym a'
11:11:09 <dons> lambdabot: haha
11:11:19 <dons> lament: also haha
11:25:08 <elliottt> dcoutts_: is there a way to get cabal-install to list out the flags you can set for a package?
11:27:52 <Saizan> elliottt: what do you mean?
11:31:55 <yitz_> > "quine" `forM` (show . quine . return)
11:31:55 <lambdabot>  ["\"\"\"\"\"","\"\"\"\"e","\"\"\"\"\"","\"\"\"\" ","\"\"\"\"e","\"\"\"n\"","...
11:32:26 <EvilTerran> heh
11:33:10 <elliottt> Saizan: i'd like to be able to list flags defined in a cabal file, so that i can set them via the --flags option.  i didn't see any way to do that in the help for cabal install
11:36:36 <Vulpyne> Say you're parsing something with Parsec that may optionally exist, is [[[try (matching stuff) <|> return defaultvalue]]] a reasonable way to do it?
11:37:12 <EvilTerran> ?hoogle option
11:37:12 <lambdabot> Text.ParserCombinators.ReadP.option :: a -> ReadP a -> ReadP a
11:37:12 <lambdabot> Text.ParserCombinators.Parsec.Combinator.option :: a -> GenParser tok st a -> GenParser tok st a
11:37:12 <lambdabot> System.Console.GetOpt.Option :: [Char] -> [String] -> ArgDescr a -> String -> OptDescr a
11:37:12 <olsner> I believe there's a combinator for that
11:37:33 <yitz_> Vulpyne: you only need try if you are going to parse the same input again if it doesn't work the first time.
11:37:40 <Philippa> Vulpyne: yes, but there's a combinator for it as others're saying
11:37:44 <yitz_> s/work/match/
11:37:54 <Philippa> yitz_: which you are
11:38:05 <Philippa> in the general case, there's something else coming afterwards
11:38:09 <Vulpyne> yitz: But my optional matching part may consume some of the input, but then when it fails, I just want the default value.
11:38:12 <desegnis> yitz_: the left parser may fail, so we need try
11:38:15 <Philippa> if you know there isn't, you'd finish eof
11:38:23 <EvilTerran> option is what you want
11:38:36 <Vulpyne> Oh, thanks.
11:38:38 <Philippa> @src Text.ParserCombinators.Parsec.Combinator.option
11:38:38 <lambdabot> Source not found. You untyped fool!
11:38:45 <EvilTerran> option x p = p <|> return x
11:38:49 <Vulpyne> Dunno how I missed it.
11:38:53 <EvilTerran> so you'll still need the try
11:38:58 <sethk> I happen to be a strongly typed fool
11:40:55 <desegnis> Ah. So we have two different possible semantics for option, where Parsec chose the one without try
11:41:38 <EvilTerran> indeed. parsec doesn't do *any* implicit backtracking
11:43:29 <Nafai> byorgey: So I liked your xmonad talk!
11:44:02 <byorgey> Nafai: thanks!
11:44:26 <ceibe> hi, anyone check the SMP parallelism in GHC 6.6? using Control.Parallel module? seems that don't work, I compile with -threaded and +RTS -N2 -RTS and only one core works
11:44:26 <lambdabot> ceibe: You have 1 new message. '/msg lambdabot @messages' to read it.
11:44:26 <Nafai> I've been thinking about a new Haskell project
11:45:18 <dons> ceibe: what OS?
11:45:25 <dons> ceibe: you compile with -threaded?
11:45:31 <dons> and then run with +RTS -N2
11:45:40 <byorgey> Nafai: what's that?
11:45:58 <sethk> hello, all.  Is there a simple way to identify functions that are never called?  I did some extensive mods on something and for obvious reasons I'd prefer not to weed them out manually.
11:46:16 <byorgey> foo = undefined ?
11:46:17 <dons> sethk: yeah, firstly, ghc will do dead code elimination
11:46:25 <dons> but secondly, you can run with -fhpc  (ghc 6.8.2)
11:46:31 <byorgey> oh, sorry, *identify* functions that are never called
11:46:43 <dons> and it will generate nice coloured tables of code that was never called
11:46:44 <Nafai> byorgey: I'm getting sick of spam and such.  I've got over 13,000 since the 23rd.  Spam Assassin does a decent job, but I think I can do even better in some regards.
11:46:45 <byorgey> for some reason my brain skipped that word and supplied "define" instead =P
11:46:47 <dons> sethk: assuming you have some way to run your program exhaustively
11:46:52 <sethk> dons, great, thanks.
11:47:02 <sethk> dons, hmm., not necessarily, no.
11:47:07 <sethk> dons, so what's the ghc option?
11:47:17 <Nafai> So I want to write a program that I can pass messages to from procmail that will parse each message and store important information (to, from, subject, other headers perhaps, size, etc) in a sqlite database
11:47:19 <dons> sethk: -fhpc  at compile time
11:47:30 <sethk> dons, thanks much
11:47:33 <dons> sethk: then after the program runs, use 'hpc markup foo'
11:47:38 <dons> and you get graphs like this, http://galois.com/~dons/tmp/hpc_index.html
11:47:39 <ceibe> dons, Linux x86, I compile with: ghc -fglasgow-exts --make GCode.hs -o gcode -threaded +RTS -N2 -RTS
11:47:46 <sethk> dons, ok, thanks, I'll try it.
11:47:50 <dons> sethk: the above is for a testsuite run
11:48:00 <inimino> Nafai: have you looked at DSPAM, CRM-114, et al?
11:48:00 <dons> ceibe: you shouldn't compile with +RTS -N2
11:48:01 <sethk> dons, ok.
11:48:03 <Nafai> So then I can say "Hmm....most of my spam goes to this address" (I use a catch all for my domain, plus forward a couple of old accounts to the new domain) and then reject at smtp time based on those stats
11:48:06 <dons> you need to run the program with +RTS -N2
11:48:17 <dons> ceibe: also, always use -O or -O2 if you care about performance
11:48:29 <dons> ceibe: make sense? compile with -threaded -O2
11:48:36 <ceibe> ouch
11:48:37 <dons> then run your program as, ./a.out +RTS -N2
11:48:37 <Nafai> inimino: Not much, but I'm wanting to figure out specific things to reject even earlier
11:48:41 <byorgey> Nafai: have you read http://www.paulgraham.com/spam.html ?
11:48:41 <lambdabot> Title: A Plan for Spam
11:48:46 <Nafai> Yes
11:48:53 <byorgey> ok =)
11:48:57 <dons> ceibe: the number of cores to use is a runtime flag, not a compile time flag
11:49:02 <Nafai> I would say 97% of my spam is caught
11:49:07 <byorgey> Nafai: sounds like a cool project.
11:49:31 <Nafai> But I would like to not even have it show up in my junk folder if possible, and I have a hunch that a large portion comes from specific conditions
11:49:31 <inimino> Nafai: you can integrate any of those with popular MTAs to reject at SMTP time
11:50:23 <Cale> ceibe: If you really want to compile in some RTS flags, there's a hack for doing it, you just write a very short .c file with a string in it, and include it along with your .hs files on the ghc commandline.
11:50:56 <shachaf> > quine "cannot be quined"
11:50:57 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-hooks
11:50:57 <lambdabot>  "cannot be quined" cannot be quined
11:50:58 <dons> or use a runtime wrapper to set the flags
11:50:58 <lambdabot> Title: 5.14. Running a compiled program, http://tinyurl.com/d7dj4
11:51:16 <inimino> Nafai: there's a lot of prior art in that area, though a Haskell classifier would be a very cool project
11:52:39 <Nafai> inimino: I'm sure there are.  Again this is probably just a fun project
11:52:40 <ceibe> dons, thanks, a stupid error, the documentation is clear
11:52:46 <Nafai> Something practical to learn Haskell better with
11:52:47 <dons> great
11:52:51 <ceibe> Cale, thanks, and thanks for the other day!
11:52:59 <Cale> ceibe: no problem :)
11:54:08 <wagle_home> @src quine
11:54:08 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:54:13 <inimino> Nafai: I think it would be very cool, and have been nearly tempted to something like that myself :-)
11:55:28 <Nafai> :)
11:55:48 <Nafai> I just need to make sure I can easily parse email and also write to an sqlite database
12:02:43 <gwern> > 16 `div` 2
12:02:43 <lambdabot>  8
12:05:16 <ceibe> in any case I don't see the two cores work ;/
12:05:34 <ceibe> at least in parallel
12:06:18 <Cale> ceibe: Which system of parallelism are you using?
12:06:46 <Cale> ceibe: If you have an expression of the form (x `par` y), then evaluating it will 'spark' x before resulting in y
12:07:00 <ceibe> I'm using parMap
12:07:04 <ceibe> parMap rnf
12:07:15 <Cale> Sparking a computation just means putting it in a queue of work to be done on some processor if there is free time
12:07:34 <Cale> parMap uses par internally to spark computations for all the elements of the list
12:07:44 <Cale> (and evaluate them with the supplied strategy)
12:07:50 <lament> nice terminology
12:08:03 <mrd> sparkallel
12:08:22 <Lacrymology> excuse me, do data declarations need to be in separated files or something to be used in hugs?
12:08:24 <ceibe> Cale, iep, so the computation of each element must be done in parallel
12:08:27 <Cale> If there is no free time left, the program behaves as if it were single threaded and the elements are evaluated only on demand.
12:08:30 <ceibe> no?
12:08:51 <Cale> Lacrymology: All declarations have to be in a file which you load in hugs
12:09:05 <Lacrymology> Cale: I meant in a separate file from functions
12:09:08 <ceibe> Cale, but the other core haven't work to do
12:09:08 <Lacrymology> because I get this
12:09:09 <Cale> ceibe: well, not necessarily. It will try to do them all in parallel.
12:09:22 <Lacrymology> Hugs> :l ejs.hs
12:09:22 <Lacrymology> ERROR "ejs.hs":7 - Syntax error in input (unexpected `=')
12:09:27 <ceibe> I see a core with 100% of use and the other with 0%
12:09:34 <Cale> ceibe: Then something is wrong.
12:09:46 <Lacrymology> if the "data" declaration's on top, or "unexpected keyword data" when it's after some function
12:09:53 <Cale> Lacrymology: could you paste the file?
12:09:54 <Cale> @paste
12:09:54 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:11:04 <Lacrymology> http://pastebin.com/d4ab6f2
12:11:21 <Cale> Lacrymology: aha, it's an indentation problem
12:11:26 <Lacrymology> really?
12:11:28 <Lacrymology> indentation
12:11:30 <Lacrymology> damnit
12:11:32 <mauke> broken indentation
12:11:37 <Cale> Lacrymology: your functions should be indented the same amount as the data declaration
12:11:48 <Cale> All top level declarations should be at the same indentation level
12:12:08 <Lacrymology> I didn't know haskell cared about indentation. Thanks
12:12:14 <Cale> (apart from possibly the module decl at the top, if there is one, which can be indented less, as everything is 'inside' it
12:12:15 <Cale> )
12:12:24 <Cale> Lacrymology: Indentation is used to express block structure
12:12:27 <lament> Lacrymology: haskell cares about indentation a lot. Think Python.
12:12:34 <Cale> I also recommend not having any tab characters in your file
12:12:44 <Cale> They will undoubtedly create problems.
12:13:09 <Cale> (and editors can be configured to automatically convert them to spaces)
12:13:09 <mauke> you can make it ignore indentation by startin the while with "module Main where {" and ending with "}"
12:13:18 <mauke> but then you'll have to put a ";" after each declaration
12:13:29 <mauke> 'while'?
12:13:34 <mauke> I meant "by starting the file"
12:17:18 <ceibe> Cale, when I compile without -threaded I hope that GHC ignores parMap and other anotation for parallelism, it is?
12:17:29 <Cale> ceibe: essentially, yeah
12:17:49 <Cale> ceibe: It will certainly behave the same way, since par annotations never change the semantics.
12:18:21 <Lacrymology> ok, I'll fix my indentation. Thanks
12:18:22 <Cale> I have no idea if it affects the time, but if it does, then it does so only by a tiny amount
12:18:42 <Cale> (It probably doesn't)
12:18:47 <Lacrymology> I never programmed anything but single line functions, so I'd never ran into it before
12:19:12 <Lacrymology> so how do I define a show function for my trees?
12:19:32 <Cale> You can either simply add   deriving (Show) to the end of the data decl
12:19:39 <Cale> Or you can write an instance as follows:
12:20:04 <Cale> uh, btw, your tree type is a little bit broken
12:20:16 <Cale> the type variable a is out of scope, and this is not a tree type
12:20:37 <Cale> data Tree a = Nil | Bin a (Tree a) (Tree a)
12:20:41 <Cale> would be more suitable
12:20:50 <Cale> and if that were the case, we could write something like:
12:21:01 <Cale> instance (Show a) => Show (Tree a) where
12:21:05 <Cale>    show Nil = "Nil"
12:21:35 <lament> Lacrymology: by the way, there's #haskell.es
12:21:36 <Lacrymology> Cale: yes, I fixed that already
12:21:50 <Cale>    show (Bin x l r) = concat ["Bin ", show x, "(", show l, ") (", show r, ")"]
12:21:51 <Lacrymology> lament: I can handle english ok, but thanks =)
12:22:01 <lament> (where they would speak spanish if they ever talked at all)
12:23:10 <desegnis> (analogous to #haskell.de and probably any #haskell.xx channel that has ever existed)
12:23:41 <Lacrymology> lament: exactly why I'd rather ask here than there
12:26:08 <eyeris> `liftM id someIORef` produces a new IORef, right?
12:26:25 <eyeris> (not that I would try to do exactly that)
12:26:28 <mauke> that doesn't typecheck
12:26:33 <shachaf> eyeris: If the someIORef is in a monad.
12:26:46 <shachaf> eyeris: fmap id = id
12:26:53 <eyeris> Isn't IORef a monad?
12:26:58 <mauke> no
12:28:08 <Lacrymology> Cale: can you please check this? http://pastebin.com/d35f4d334 it won't let me load it
12:28:31 <mauke> you're trying to redefine show
12:28:34 <Lacrymology> line 2 is actually commented outw
12:28:38 <Cale> Lacrymology: Ah there are two problems
12:28:58 <ceibe> Cale, if I compile without -threaded and I see the /proc/pid/task directory there is only a thread
12:29:01 <eyeris> So IORef is just a type?
12:29:05 <Cale> Lacrymology: One is that the definition of show must be in an instance decl for the Show class
12:29:08 <mauke> eyeris: yes
12:29:08 <Cale> (Show is a typeclass)
12:29:14 <oklopol> @die 1d2
12:29:15 <lambdabot> 1d2 => 1
12:29:22 <ceibe> if I compile with -threaded and I run it with +RTS -N2 -RTS and I see /proc/pid/task directory there are 4 threads (?)
12:29:26 <eyeris> Then why do I have to use "r <- newIORef myVar"?
12:29:47 <Cale> Lacrymology: and the other is that your type signature for show is wrong (and actually, you'll have to leave it out, since it's implied by combining the class declaration with the instance declaration
12:29:55 <ceibe> but I don't see that CPU's work more
12:30:06 <Cale> show in this case will actually have type  (Show a) => Tree a -> String
12:30:21 <Lacrymology> Cale: yeah, the signature's commented out, that's not the problem
12:30:29 <Lacrymology> the problem's that other thing you said
12:30:29 <Cale> Lacrymology: let me annotate this
12:30:33 <Lacrymology> ok
12:30:33 <Cale> well, okay
12:30:36 <eyeris> Oh
12:30:47 <eyeris> I see. Because newIORef is actually IO (IORef a)
12:31:02 <ceibe> and if I run with +RTS -sstderr -N2 I see the 4 threads (I don't know why 4 if I say 2) but two of them have 0s of MTU time ?
12:31:34 <bd_> ceibe: there are some additional threads for internal use, in addition to the two user threads
12:31:37 <mauke> eyeris: yes; each invocation of newIORef has to allocate a new IORef, so it's in IO
12:32:23 <Cale> http://pastebin.com/m48a342e3
12:32:40 <Cale> Be careful, you can't both derive Show and have an explicit instance.
12:32:44 <Cale> It's one or the other
12:33:23 <ceibe> bd_, but I don't understand why I have (in theory) 4 threads running and the I have a CPU without work to do
12:33:24 <ceibe> :?
12:34:02 <bd_> ceibe: well, eg, one might be used to receive signals
12:34:16 <allbery_b> signals, FFI
12:34:43 <ceibe> bd_, well, but, in any case, at least the 2 threads that I say with -N2 must work
12:34:45 <ceibe> no?
12:34:46 <bd_> and of course there's the IO manager
12:34:52 <bd_> ceibe: sure, if you give them enough to do
12:35:05 <eyeris> Does each readIORef need to be paired with a writeIORef?
12:35:07 <Cale> ceibe: yeah
12:35:16 <ceibe> yes, it have enough to do
12:35:24 <Cale> ceibe: assuming that you can actually perform the computation in parallel
12:35:37 <ceibe> why I couldn't?
12:35:42 <Cale> If you have data dependencies which are too strong, you might kill it.
12:35:51 <ceibe> uhm
12:36:07 <ceibe> well, all computations needs to read an array
12:36:11 <ceibe> only read
12:36:34 <ceibe> but no more
12:36:39 <mauke> eyeris: no
12:36:42 <Cale> Like, if you try to spark x before y, but x actually needs y immediately to do its work, then obviously you can't do anything until y is computed
12:36:58 <mauke> eyeris: do you know OCaml?
12:37:03 <eyeris> Nope
12:37:08 <Heffalump> eyeris: no, it doesn't
12:37:11 <mauke> hmm, too bad :-)
12:37:15 <ceibe> Cale, since I'm using parMap all computations are independent of the others
12:37:19 <eyeris> haskell is my first functional language besides a tiny bit of scheme from GIMP
12:37:19 <Heffalump> they're not MVars
12:37:27 <Cale> If the array is unboxed, then all the elements of the array must be computed at the same time. If it is lazy (boxed), then they can be computed in terms of one another, or in parallel.
12:37:33 <mauke> eyeris: any assembler?
12:37:38 <eyeris> yep
12:37:42 <eyeris> a long time ago
12:37:50 <eyeris> ~10 years since I wrote any
12:37:53 <mauke> readIORef/writeIORef are like load/store instructions
12:37:57 <Cale> ceibe: If you're getting less parallelism than you expect, I can have a look
12:37:58 <ceibe> Cale, I'm using Array, inmutable and lazy
12:38:13 <eyeris> OK. That makes sense.
12:38:26 <ceibe> Cale, don't laught :P it's a very fast PoC
12:38:49 <Cale> That's all right, we all have to start somewhere :)
12:39:03 <Cale> I know that some of my early code wasn't so pretty either ;)
12:39:05 <ceibe> @paste
12:39:05 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:39:57 <hpaste>  ceibe pasted "parMap" at http://hpaste.org/6754
12:40:06 <ceibe> Cale, it is
12:40:43 <Cale> ceibe: ah, it got cut off at the bottom (hpaste has a length limitation)
12:41:05 <ceibe> ouch
12:41:23 <ceibe> well, I will remove all co* definitionts
12:41:25 <Cale> It should really warn :)
12:41:35 <Cale> you could also just annotate with the remainder
12:41:43 <ceibe> it's ugly, but if I don't use it, the definition of model is more ugly
12:42:46 <hpaste>  ceibe pasted "parMap2" at http://hpaste.org/6755
12:43:31 <Cale> and how many processors is this driving to 100% when you use -N2? Just one?
12:44:02 <ceibe> one core takes the 100% of the time
12:44:04 <ceibe> the other 0%
12:44:11 <ceibe> sometimes, but very few
12:44:25 <ceibe> the core of 100% -> 0%
12:44:29 <ceibe> and the core of 0% -> 100%
12:44:40 <ceibe> (my English is very poor :P)
12:44:44 <Cale> hmm
12:44:54 <Cale> okay, maybe you should profile this...
12:45:30 <Cale> If it turns out that all the time is spent on something like the random number generation that would be rather upsetting, but we'd know what needed fixing at least.
12:45:58 <Cale> hmm
12:46:52 <laura85> hi ^^
12:46:56 <Cale> hello :)
12:47:09 <Cale> ceibe: hmm...
12:47:27 <ceibe> Cale, uhm, if I run the program to compute the fitness of 100 chromosomes it takes less than 1 second
12:47:48 <ceibe> well, I say an stupid thing, forget
12:47:48 <ceibe> :P
12:47:54 <Cale> ceibe: Could you compile it with -prof -auto-all, and then run it with +RTS -p ?
12:48:09 <ceibe> with -threaded and -N2
12:48:12 <ceibe> or without it?
12:48:18 <Cale> Let's go without for now.
12:48:50 <laura85> the most general type of \xs -> foldr (.) id xs  is   [a->a] -> a -> a, where does the second 'a' come from?
12:49:07 <Cale> I'm not sure how well parallel profiling works as of yet, but if we get some idea of how the time is distributed on one processor, and we have the program, we can see where parallelism would work and where it wouldn't.
12:49:32 <Cale> laura85: from the fact that you have to chain together adjacent elements of the list
12:49:42 <Cale> laura85: So if you have [f, g, h] as your xs
12:49:48 <Cale> then f . g . h has to be well typed
12:49:54 <laura85> Cale: sure
12:49:55 <laura85> but
12:50:06 <laura85> Cale: i thought it's [a->a] -> a
12:50:16 <Cale> mm, nope
12:50:17 <mauke> laura85: no, it's [a->a] -> (a->a)
12:50:23 <Cale> (.) takes two functions and produces another
12:50:43 <ceibe> ok, I have the gcode.prof
12:50:50 <Cale> ceibe: can you paste that?
12:51:10 <laura85> mauke, Cale, hm ok
12:51:14 <dejones> Cale, at least according to my GSoC proposal, parallel profiling doesn't really work in Haskell.  ;)
12:51:20 <Cale> dejones: hehe
12:51:22 <hpaste>  ceibe pasted "gcode.prof" at http://hpaste.org/6756
12:51:37 <Cale> dejones: That's what was in the back of my mind when I had my doubts :)
12:51:38 <mauke> laura85: if it was [a->a] -> a, what would foldr (.) id [] return?
12:51:40 <ceibe> well I wil avoid the co*
12:51:43 <ceibe> ;/
12:51:47 <dejones> Cale  :)
12:51:47 <ceibe> will*
12:52:00 <dejones> Cale: well, we can see here that there is need for the project!
12:52:07 <Cale> dejones: yes! :)
12:52:24 <laura85> mauke, hm
12:52:33 <Cale> ceibe: So it really is fitness1pr...
12:52:37 <hpaste>  ceibe pasted "gcode.prof2" at http://hpaste.org/6757
12:52:54 <dejones> Well, back to homework for me... Cale, feel free to reply to PMs whenever you get a moment.  Thanks.
12:53:06 <Cale> dejones: oh, sorry about that
12:53:28 <Cale> dejones: I'll have a look for you in a bit
12:53:37 <dejones> Cale: Thank you.  :)
12:53:39 <gwern> @where nofib
12:53:39 <lambdabot> I know nothing about nofib.
12:54:24 <Cale> Heh, this would be easier to figure out if I actually had a multicore machine :)
12:54:24 <ceibe> iep
12:54:30 <gwern> peculiar. I have a copy of http://darcs.haskell.org/nofib but the makefile seems to be broken
12:54:31 <lambdabot> Title: Index of /nofib
12:54:39 <gwern> is nofib known to be old and buggy?
12:55:40 <ceibe> Cale, no idea why it doesn't work no?
12:56:05 <ceibe> I would try do it in ghc 6.8
12:56:25 <laura85> there are two things I absolutely didn't get. one is:  (\a b -> a (\x -> b 1))... i can't say what the most general type is.
12:57:03 <dmwit> Well, start as far in as possible.
12:57:06 <Cale> ceibe: Yeah, that's really confusing. It looks to me like it should parallelise okay.
12:57:12 <dmwit> What's the most general type of (\x -> b 1) ?
12:57:33 <bos> gwern: nofib is ancient, yes.
12:57:46 <laura85> dmwit: Num a => a -> b ?
12:58:01 <ceibe> Cale, yes, it's strange ;/
12:58:02 <dmwit> laura85: Okay, that's the type of (b).
12:58:08 <ceibe> lot of thanks anyway
12:58:12 <mauke> laura85: no, that would contrain x to be a number
12:58:22 <mauke> constrain
12:58:27 <Cale> ceibe: Try parListChunk 2 rnf
12:58:29 <dmwit> laura85: Which probably should have been my first question anyway.
12:58:29 <mcnster> @seen dcoutts_
12:58:29 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I don't know when dcoutts_ last spoke.
12:58:41 <Cale> ceibe: just out of curiosity
12:58:45 <ceibe> uhm
12:58:49 <mcnster> dcoutts_, are you awake?
12:58:54 <dmwit> laura85: Now see if you can use that type for (b) and determine the type for (\x -> b 1).
12:59:03 <Cale> er, or parListChunk 5000
12:59:12 <gwern> bos: I'm a little surprised to hear that. I could've sworn I've seen people discussing the results of nofib or saying 'work up a test we can add to nofib'
13:00:12 <bos> gwern: we had nofib back in 1993.
13:00:19 <laura85> dmwit: what does (\x -> b 1) mean?   that 1, isn't it the argument for x? or is it (b 1)?
13:00:32 <ceibe> Cale, how?
13:00:38 <dmwit> laura85: It parses as (\x -> (b 1)), so 1 is the argument to (b).
13:00:40 <desegnis> laura85: It's a lambda abstraction
13:00:52 <Cale> ceibe: parListChunk :: Int -> Strategy a -> Strategy [a]	Source
13:00:52 <Cale> Splits a list into chunks (sub-sequences) of length n, and applies a strategy sequentially to the elements in each chunk. The chunks are evaluated in parallel. This is useful for increasing the grain size.
13:01:00 <laura85> desegnis, heh i know ;-)
13:01:07 <desegnis> laura85: x is the variable to be bound, and b 1 is the body of the abstraction
13:01:08 <desegnis> eh
13:01:09 <Cale> er, ignore that "Source"
13:01:31 <desegnis> laura85, now you know for sure :P
13:01:48 <gwern> heh. nofib got two patches in 2008, one patch in 2007...
13:02:08 <gwern> wow, there are patches from 1996
13:02:10 <laura85> desegnis, err i meant, i will know it in five minutes ^^
13:02:10 <ceibe> what is Strategy [a] ?
13:02:16 <dmwit> laura85: You can always do this transformation: turn "\" into "f ", and "->" into " = ".  This creates a new function definition (possibly conflicting, but whatever).
13:02:26 <gwern> wait, what? did darcs even exist in 1996?
13:02:34 <dmwit> laura85: So, (\x -> b 1) would become (f x = b 1).
13:02:45 <laura85> dmwit, so (\x -> b) 1, 1 would be the argument for x right?
13:02:47 <ceibe> rnf fs_par ?
13:02:52 <ceibe> uhms
13:02:54 <dmwit> laura85: Exactly!
13:02:55 <ceibe> ah, well
13:02:55 <ceibe> ok
13:03:00 <FalconNL> Can anyone tell me how to set the buffering mode on ghci? "hSetBuffering stdin NoBuffering" works in Hugs but not in ghci.
13:03:00 <laura85> dmwit, great ^^
13:03:35 <laura85> dmwit, I'll try to do the whole thing again.
13:03:46 <dmwit> ok
13:04:10 <byorgey> FalconNL: hm, it should.  What exactly is it that doesn't work?
13:04:30 <FalconNL> one sec, I'll put the program on hpaste
13:05:19 <FalconNL> http://hpaste.org/6758
13:05:20 <desegnis> FalconNL: I have no buffering in ghci without saying anything, actually.
13:06:00 <FalconNL> When I run this in Hugs, run main and type a character, it is immediately doubled. In ghci, I have to press enter first
13:06:45 <desegnis> FalconNL: What platform?
13:07:07 <FalconNL> windows xp, pretty sure I'm running the december 2007 build
13:07:11 <kolmodin> dons: does xmonad work equally good with x11-1.4.1 compared to x11-1.4.2? except, naturally, for bugs fixed in 1.4.2
13:07:44 <dmwit> FalconNL: Hmm, seems to work here, what version of GHC are you on?
13:07:59 <desegnis> FalconNL: feared something like that ;), how does the program behave if compiled?
13:08:11 <laura85> dmwit, (\x -> b 1), i don't see what it does...
13:08:30 <FalconNL> dmwit: what's the command in ghci to check the version again?
13:08:37 <dmwit> laura85: Ahhh, it's sneaky, right?  Because it doesn't seem to use "x" in the right-hand side.
13:08:39 <FalconNL> desegnis: one sec, I'll check
13:08:48 <laura85> dmwit, heh right ^^
13:09:00 <dmwit> FalconNL: ghc --version, dunno about from within ghci
13:09:19 <FalconNL> never mind it's in the folder name. 6.8.2
13:09:22 <dmwit> laura85: So, if that's so, what restrictions are there on what "x" can be?
13:09:41 <laura85> dmwit, no restrictions for x?
13:09:58 <dmwit> laura85: Right!
13:10:05 <dmwit> laura85: So... now what's the type? =P
13:10:32 <laura85> dmwit, Num b => (a -> (b -> c)) ?
13:10:46 <dmwit> laura85: Close.
13:10:52 <dmwit> laura85: What's the type of (b 1)?
13:11:03 <laura85> dmwit: Num b => b->c
13:11:11 <FalconNL> desegnis: same behaviour when I compile with ghc; I have to press enter before it prints the character
13:11:12 <dmwit> laura85: No, that's the type of (b).
13:11:30 <laura85> dmwit, ooooooooh
13:11:37 <laura85> forgot that ^^
13:11:40 <dmwit> =)
13:12:14 <Botje> FalconNL: you need to disable buffering on stdout too
13:12:21 <laura85> dmwit, b 1 :: c
13:12:28 <dmwit> laura85: right
13:12:31 <Botje> otherwise it'll wait for a newline or 4096 bytes, whichever comes first
13:12:56 <laura85> dmwit:   so (\x -> b 1) is  a -> c
13:13:03 <dmwit> laura85: Perfect!
13:13:18 <ceibe> Cale, =
13:13:22 <ceibe> fs_par2 = parListChunk 2 rnf l `seq` l
13:13:22 <ceibe> 	where
13:13:22 <ceibe> 		l = List.map fitness1pr cs
13:13:30 <ceibe> if I do it well..
13:13:31 <laura85> dmwit, far from it, but ok :P
13:13:43 <FalconNL> Botje: nope, still the same behaviour
13:14:25 <Cale> ceibe: yeah, or maybe set the chunk size much larger
13:14:32 <Cale> and see what happens then
13:14:34 <desegnis> FalconNL, duh. File a bug report? (I hate those moments.)
13:14:43 <Cale> ceibe: It's a little unintuitive to say the least.
13:15:11 <Cale> ceibe: The real solution to problems like this is data parallelism, but that's not going to be until at least ghc 6.10
13:15:20 <FalconNL> Is 6.8.2 the latest version or is there a beta somehwere?
13:15:27 <laura85> dmwit: (\a b -> a (\x -> b 1))   ::   Num a =>              ((a -> c)-> d)   -> (a -> b) -> d ?
13:15:41 <Cale> FalconNL: there's a beta, but I wouldn't usually recommend using it unless you're a developer.
13:15:57 <Cale> FalconNL: rather there's an alpha
13:16:09 <Cale> (whatever is in the darcs repository)
13:16:13 <dmwit> laura85: Getting closer... =P
13:16:15 <dblhelix> FalconNL: you are from holland?
13:16:24 <ceibe> Cale, you solve my problem again :P
13:16:28 <FalconNL> dblhelix: yup
13:16:34 <ceibe> now I divide the reponse time by 2
13:16:36 <dmwit> laura85: You should notice that the input to the function "a" is the *output* of the function "b".
13:16:38 <Cale> ceibe: That working for you? Nice.
13:16:47 <dblhelix> FalconNL: you don't happen to be a utrecht student, do you? :-)
13:16:52 <ceibe> I put a chunk size of 200
13:16:53 <Cale> ceibe: The problem was that scheduling all the sparks was eating up your parallelism.
13:17:01 <FalconNL> dblhelix: nope, Eindhoven :)
13:17:07 <roconnor> @time FalconNL
13:17:08 <lambdabot> Local time for FalconNL is maandag 31 maart 2008 22:17:09
13:17:39 <laura85> dmwit: (\a b -> a (\x -> b 1))   ::   Num a =>  ((b -> c)-> d)  -> (a -> b) -> d ?
13:17:40 <tromp> @time tromp
13:17:43 <lambdabot> Local time for tromp is Mon Mar 31 16:17:40 2008
13:17:54 <dblhelix> FalconNL: a okay, one of Rik van Geldrop's?
13:18:23 <dmwit> laura85: That looks right!  Check it in ghci.
13:18:57 <Botje> FalconNL: i found a post on haskell-cafe that might help
13:18:57 <ceibe> Cale, iep, I though that GHC will do it for me, group the tasks
13:19:07 <FalconNL> dblhelix: no, I'm a PhD student, doing Haskell in my spare time. I wanted to start on a roguelike game, but that get annoying quickly if you have to press enter after each command
13:19:22 <FalconNL> *gets
13:19:28 <dmwit> laura85: Oogh, ghci disagrees.
13:19:37 <laura85> dmwit, but Hugs said ok ^^
13:19:45 <Japsu> whoa
13:19:47 <dblhelix> FalconNL: ah, kosmikus is implementing such a game with his students in an afp course
13:19:48 <Japsu> @time Japsu
13:19:51 <lambdabot> Local time for Japsu is Mon Mar 31 23:19:53 2008
13:19:53 <laura85> dmwit, wait no
13:19:54 <roconnor> @type setBuffering
13:19:56 <Japsu> yeah, just as I thought, CTCP TIME
13:19:58 <lambdabot> Not in scope: `setBuffering'
13:20:03 <roconnor> @hoogle buffering
13:20:03 <lambdabot> System.IO.NoBuffering :: BufferMode
13:20:03 <lambdabot> System.IO.LineBuffering :: BufferMode
13:20:03 <lambdabot> System.IO.BlockBuffering :: Maybe Int -> BufferMode
13:20:16 <Botje> FalconNL: http://www.haskell.org/pipermail/haskell-cafe/2007-December/037141.html # does this help?
13:20:18 <lambdabot> Title: [Haskell-cafe] Unbuffered character IO under Windows XP?, http://tinyurl.com/3xj72w
13:20:19 <roconnor> @hoogle BufferMode -> IO ()
13:20:19 <lambdabot> System.IO.hSetBuffering :: Handle -> BufferMode -> IO ()
13:21:33 <roconnor> what's wrong with hSetBuffering stdin NoBuffering ?
13:21:54 <Botje> for one, it doesn't seem to be working for FalconNL :)
13:22:05 <FalconNL> roconnor: nothing, except that apparently it doesn't work with ghc(i) 6.8.2 on windows xp
13:22:35 <laura85> dmwit, right it says , Num a => ((b -> c) -> d) -> (a -> c) -> d. But,  b :: Num a => a -> b,   b 1 :: b,
13:22:36 <roconnor> really
13:22:37 <roconnor> ugh
13:23:33 <laura85> dmwit, that second argument, is it 'b' itself?
13:23:50 <dmwit> laura85: Don't panic; with that labeling, we actually have (b :: Num a => a -> c), not (a -> b).
13:23:55 <dmwit> laura85: yes
13:24:23 <laura85> dmwit, ah ok
13:26:36 <monochrom> hrm, when has the Gentle Introduction become an e-book? :)
13:27:12 <malsyned> What's the accepted way to indent chained if/then/else blocks?
13:27:31 <mrd> case () of _ | ... -> ...
13:28:09 <byorgey> oh good =)
13:28:13 <monochrom> I think any indentation that the haskell compiler likes is ok.
13:28:42 * byorgey covers his embarrassment at talking in the wrong channel by distributing apple-cinnamon lambdas
13:28:55 <malsyned> mrd: that's kinda ugly.  full of placeholders.
13:29:00 <mrd> i know
13:29:25 * mrd plans to secretly insert "cond" into haskell'
13:29:45 <mrd> if-then-else is ugly and won't line up the way you want
13:29:53 <byorgey> @seen waern
13:29:53 <lambdabot> I haven't seen waern.
13:30:10 <ahunter_> mrd: do you advocate using case t of True -> ... False -> ... instead?
13:30:28 <dmwit> No, use "bool" instead. ;-)
13:30:30 <dmwit> :t bool
13:30:30 <lambdabot> Not in scope: `bool'
13:30:32 <mrd> hehe
13:30:45 * monochrom advocates case t of False -> ... True -> ...
13:30:46 <mrd> actually i sometimes tell my friend not to be afraid to use case with bools
13:30:50 <ahunter_> @src bool
13:30:50 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:31:00 <mrd> really, it's more consistent that way
13:31:07 * monochrom further advocates randomly choosing between "False first" and "True first".
13:31:09 <dmwit> bool a b p = if p then a else b
13:31:10 <ahunter_> dmwit: I see no "bool" here
13:31:12 <ahunter_> ah
13:31:19 <mrd> aka if'
13:31:26 <dmwit> It's a rotated if'
13:31:29 <mrd> ah yea
13:31:42 <mrd> it's vaguely in the spirit of Church booleans
13:31:53 <dmwit> It's the catamorphism on booleans.
13:32:01 <dmwit> err,
13:32:03 <dmwit> I really want
13:32:11 <dmwit> bool b a p = if p then a else b
13:32:28 <mrd> > [False ..]
13:32:29 <lambdabot>  [False,True]
13:35:46 <rnorris> does ghc provide a way for a child thread to get a handle to its parent (other than by passing it to forkio)?
13:36:23 <dons> rnorris: only by passing it in
13:36:29 <dons> no magic backchannels
13:36:41 <dons> rnorris: often a Channel or MVar is passed instead
13:37:00 <yitz_> or: fromJust $ (guard ... >> return ...) `mplus` (guard ... >> return ...) `mplus` ...
13:37:01 <dons> you'd probably only pass the tid if you were using async exceptions for communication?
13:37:56 <laura85> hmmmmm, how do i get:  (\x ->( \y -> x y)) ?
13:38:00 <rnorris> i'm trying to do inheritable threadlocals, so it would be nice to be able to call myThreadId >>= parentThreadId or someting like that
13:38:19 <rnorris> but i can work around it. probably not possible anyway without leaking threads since i have to hang onto ids
13:38:20 <malsyned> laura85: \x y -> x y
13:38:20 <mrd> laura85: you just typed it
13:38:28 <mrd> or that for short
13:38:33 <rnorris> thanks dons
13:39:32 <malsyned> @pl lauraThing x y = x y
13:39:32 <lambdabot> lauraThing = id
13:39:45 <mrd> @src ($)
13:39:45 <lambdabot> f $ x = f x
13:39:46 <dibblego> what is a paper that explains how pure code leads to better composition?
13:41:15 <yitz_> dibblego: how about spj's stm paper?
13:41:23 <dibblego> yitz_, hmm, perhaps
13:41:46 <yitz_> it's imperative. but he explicitly emphasizes that point.
13:41:58 <dibblego> yitz_, yes, he does, thanks
13:42:25 <laura85> malsyned, mrd:  didn't know the short form ^^, and saw something like (a->b) -> (a -> b), which is correct but confusing (better without optional parantheses)
13:42:32 <gwern> I feel a little bit productive; I cleaned up hogg to use cabal conditionals and work by default with 6.8, instead of the malarkey of 'edit the cabal file and uncomment this and that'
13:42:58 <laura85> shesh, parachute, i meant parenthesis
13:43:49 <Heffalump> I don't suppose anyone has tried template haskell and type families together?
13:43:49 <gwern> what does conrad parker go by on #haskell?
13:44:13 <dons> Heffalump: evil
13:44:19 <Heffalump> not at all
13:44:25 <Heffalump> I just want to automate some boilerplate production.
13:44:35 <Heffalump> I just have a nasty feeling from an experiment that it doesn't work properly.
13:44:38 <dons> generate type families automagically?
13:44:54 <dons> TH wouldn't have AST nodes for those guys
13:44:55 <Heffalump> just an class instance
13:46:10 <Heffalump> hmm, yes, you're right
13:46:12 <Heffalump> grmph.
13:46:15 <malsyned> laura85: that function is really a no-op, though.  What do you need such a thing for?
13:46:25 <Heffalump> that's going to make this significantly less usable :-(
13:47:35 <laura85> malsyned, oh it's just a type inference exercise
13:50:16 <Heffalump> http://hackage.haskell.org/trac/ghc/ticket/1673 :-(
13:50:17 <lambdabot> Title: #1673 (Template Haskell support for type families) - GHC - Trac
13:52:28 <gwern> fun. hogg wants a http library which is different from the hackage HTTP of the same name it seems
13:56:40 <laura85> hm, is    x . y  ==  x y  in Haskell?
13:56:48 <Cale> laura85: nope
13:56:52 <Cale> (f . g) x = f (g x)
13:57:00 <Cale> and not  (f g) x
13:57:03 <realspace> Hello all. Is their a fmod() like function in haskell?
13:57:29 <Cale> fmod...
13:58:02 <Cale> hmm, I don't think it's in the base library, but you could write one
13:58:22 <mcnster> @src ($!)
13:58:22 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
13:58:29 <realspace> I didn't found fmod and hoogle didn't know it. sad.
13:59:01 <ArcSin_> Hey can anyone tell me how to compose a list of two arbitrary constants a &b that looks like this: [a, a+b, a+b+b, a+b+b+b, .. ]  ..(I'm so bad with sums))
13:59:28 <tromp> [a,a+b..]
14:00:03 <tromp> > let (a,b) = (3,2) in [a,a+b..]
14:00:04 <lambdabot>  [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,5...
14:00:24 <dolio> @seen dmwit
14:00:25 <lambdabot> dmwit is in #xmonad, #haskell-blah and #haskell. I last heard dmwit speak 21m 1s ago.
14:00:32 <shachaf> > iterate (+2) 3
14:00:32 <lambdabot>  [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,5...
14:00:47 <ArcSin_> Thanks =]
14:00:48 <dmwit> pong
14:01:06 <dolio> dmwit: How's my sharing? Did I succeed?
14:01:13 <dmwit> ooh!
14:01:17 <dmwit> Let me take a look. =)
14:01:30 <tromp> > enumFromBy 3 2
14:01:30 <lambdabot>   Not in scope: `enumFromBy'
14:01:39 <tromp> > enumFromBy 3
14:01:40 <lambdabot>   Not in scope: `enumFromBy'
14:01:42 <tromp> > enumFrom 3
14:01:45 <lambdabot>  [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,3...
14:01:53 <tromp> > enumFromTo 3 10
14:01:54 <lambdabot>  [3,4,5,6,7,8,9,10]
14:02:01 <tromp> > enumFromToBy  3 10 2
14:02:01 <lambdabot>   Not in scope: `enumFromToBy'
14:02:41 <dolio> dmwit: Sorry about the unsafePerformIO, but I was failing for a while, and wanted to make sure it wasn't some translation to monadic style that was messing me up. Then I figured out that 'k' trick, and didn't feel like translating back.
14:02:53 <tromp> > enumFromThen 3 5
14:02:54 <lambdabot>  [3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,5...
14:03:05 <dmwit> dolio: No problem, that's really secondary, I think. =)
14:05:20 <gwern> bleh. my mind is failing me - what's Bjorn Bringert's nick here?
14:05:34 <mrd> probably bringert
14:05:40 <dolio> @seen Bringert
14:05:40 <lambdabot> I saw Bringert leaving #ghc and #haskell 2h 6m 54s ago, and .
14:08:40 <gwern> ah. tab completion failed me for a comprehensible reason then
14:09:27 <dmwit> dolio: Interesting.  So it is essentially the dynamic-programming version, but explicitly computing which cells of the array need to be computed?
14:09:40 <dmwit> (And therefore not creating the array.)
14:10:39 <dolio> dmwit: Yeah, it's similar to how you can do dynamic programming for fibonaccis by passing along fib (n-1) and fib (n-2), because that's all you ever need.
14:10:50 <gwern> @tell Bringert I've sent some patches for the lazy HTTP library you maintain. maybe you could upload it to hackage for hogg to use
14:10:50 <lambdabot> Consider it noted.
14:11:07 <dolio> Only in this case, to compute sized n, you only ever need sized (n/2) and sized (n/2 - 1).
14:11:35 <dmwit> right
14:11:42 <dmwit> It's pretty clever.
14:12:10 <dolio> It took me forever to get the right code, until I realized it was analogous to that id on integers above it.
14:12:18 <dejones> dolio, dmwit: can I see the code you two are discussing?  I'm curious about dynamic programming solutions.
14:12:19 <dejones> :)
14:12:27 <dmwit> http://hpaste.org/6683
14:12:29 <dejones> ty
14:12:53 <dolio> Checking/figuring out that id function was much easier than trying to figure out if the tree builder was right. :)
14:13:01 * dejones wants Chris Okasaki's "Purely Functional Data Structures" 
14:13:13 <dmwit> dolio: =)
14:13:21 <cjb> dejones: I heard that most of the examples aren't in Haskell.
14:13:33 <cjb> but that probably doesn't make it much less interesting :)
14:13:36 <dolio> There's an appendix in the back with Haskell.
14:13:45 <dejones> cjb: Haskell in the appendix.
14:13:48 <dolio> But most of it is ML with an added notation for laziness.
14:13:49 <dons> and there's a library of them implemented.
14:13:50 <cjb> Yeah.
14:13:53 <dmwit> ML is close enough to Haskell that it doesn't matter.
14:13:54 <cjb> Oh, cool.
14:14:00 <dons> it really would make more sense to do it in Haskell,
14:14:07 * cjb bought _Beautiful Code_ today, belatedly.
14:14:09 <dons> given its about guaranteed pure, mixed strict and lazy structures
14:15:12 <bos> the okasaki book is essential reading.
14:15:24 <ArcSin_> Are there any functions in the prelude to denote the whole and fractional parts of a Double?
14:15:26 <gwern> dons: did you read okazaki's blog post about the 10th anniversary? he explained why he didn't use haskell then
14:15:31 <dolio> dmwit: Anyhow, I haven't checked if it gets maximal sharing, as comparing against your solution is somewhat non-trivial, since the integers at each node aren't necessarily the same.
14:15:31 <dejones> dons, Okasaki explains here why he went with ML: http://okasaki.blogspot.com/search/label/functional%20programming
14:15:32 <lambdabot> Title: Teaching, Playing, and Programming: functional programming
14:15:36 <dmwit> ArcSin_: floor/ceiling?
14:15:38 <dons> yep, i know.
14:15:49 <dejones> :
14:15:50 <Heffalump> Beautiful Code has a chapter about generating bytecode to manipulate images in a really hacky way.
14:15:51 <dejones> :)
14:15:54 <gwern> dejones: bah!
14:15:57 <dejones> lol
14:16:02 <bos> okasaki's blog almost makes up in thoughtfulness for morons like steve yegge.
14:16:19 <bos> beautiful code is not a very well named book.
14:16:21 <Heffalump> it's a shame that got in when you consider how much nicer conal (et al)'s work in that area is
14:16:35 <dons> i don't buy the argument for not using haskell though, in okasaki's book
14:16:39 <bos> "code that i am inexplicably attached to".
14:16:53 <dons> i guess there were no bang patterns,
14:17:03 <dons> but then there are no lazy patterns in ML either
14:17:09 <gwern> anyway, so I have here two libraries, HTTP1 and HTTP1. the latter is strict. they both provide the same module names, but I'd rather differentiatethem someway so you can install them simultaneously; I considered renaming 'Network.Stream' to 'Network.Strict.Stream'. what do y'all think?
14:17:10 <dons> i think its more about what continent he was in
14:17:19 <conal> Heffalump: thanks!
14:17:23 <ArcSin_> dmwit: ceiling only gives me one digit after the decimal point =[
14:17:27 <gwern> (not in '96/7, I suppose...)
14:17:35 <cjb> bos: because it's not beautiful, or it's not code, or both?  :)
14:17:39 <dejones> dons, I see.  At least he did put Haskell in the appendix.  ;)
14:17:48 <dmwit> > let f x = (floor x, x - floor x) in f pi
14:17:49 <lambdabot>  Add a type signature
14:17:51 <bos> cjb: there's a lot of non-beautiful stuff in that book.
14:17:55 <dmwit> > let f x = (floor x, x - floor x) in f pi :: (Double, Double)
14:17:55 <Heffalump> conal: honestly, "how much nicer" isn't much of a compliment here :-)
14:17:55 <lambdabot>   add an instance declaration for (Integral Double)
14:17:56 <lambdabot>     In the expression:
14:17:56 <lambdabot>   ...
14:17:57 <dons> that's right. i guess it was even prior to H98, so the future was not clear
14:18:01 <bos> like the chapter on subversion's internals, which are horrible.
14:18:02 <dons> that was the end of the ML golden age
14:18:04 <dmwit> > let f x = (floor x, x - floor x) in f pi :: (Int, Double)
14:18:04 <lambdabot>   add an instance declaration for (Integral Double)
14:18:04 <lambdabot>     In the expression:
14:18:04 <lambdabot>   ...
14:18:08 <cjb> haha
14:18:08 <Heffalump> (although it is independently nice, certainly)
14:18:09 <dmwit> oh
14:18:19 <gwern> bos: that's because it's not *for* you, just like Jersey Girl is not *for* critics
14:18:26 <dmwit> > let f x = (floor x, x - fromIntegral (floor x)) in f pi
14:18:26 <dons> bos, you don't like svn's elegant patch theory? ;)
14:18:27 <lambdabot>  (3,0.14159265358979312)
14:18:33 <gwern> 'Haskell killed the ML star'?
14:18:42 <dmwit> ArcSin_: Like that?
14:18:45 <cjb> They should call it "Code That Is Thought To Be Beautiful By Some People, Who Are Admittedly Rather Biased".
14:18:58 <bos> frankly, even the haskell chapter is no great shakes.
14:18:59 <Botje> gwern: go with Network.Stream and Network.Stream.Strict
14:19:18 <gwern> (hm, 'Haskell killed the ML star' *almost* scans right. 'Haskell's Killed the ML Star'? 'Laziness killed the ML Star'?)
14:19:19 <ArcSin_> oh you guys are so smart =]
14:19:21 <Botje> in analogy with ByteString
14:19:37 <gwern> Botje: so suffixes are more common?
14:19:49 <bos> cjb: how go things in laptop land?
14:20:06 <dmwit> gwern: Haskell's killed the Old ML Star
14:20:07 <ahunter_> Laziness killed the O'Caml Star scans quite well, fwiw
14:20:08 <Botje> gwern: to me, it suggests that one can be replaced by the other
14:20:09 * bos was briefly seized with enthusiasm for the idea of packaging up GHC for the OLPC, then got over it quickly.
14:20:45 <Botje> anyone here at AOSD08?
14:20:52 <Botje> phil wadler is talking on friday *dances*
14:21:03 <bos> Botje: i don't think we believe in aspects.
14:21:08 <Peaker> Laziness killed the old ML star,   monads came and broke ...?
14:21:14 <Botje> heh.
14:21:24 <thorkilnaur> dcoutts_, Back from vacation now, anything I can do for you?
14:21:25 <dejones> Peaker: broke the purity...?  :P
14:21:28 <Peaker> heh
14:21:31 <dons> I didn't know people still wrote papers about aspects. that was so 2005
14:21:44 <Botje> actually, if i understood correctly, phil is going to compare aspects to monads
14:21:56 * Heffalump is an author on lots of papers about aspects dated 2005
14:22:09 <dons> right, Heffalump's crew being prime suspects
14:22:11 <tromp> monads preserve purity...
14:22:11 <bos> dons: once an idea makes it out of the labs and into large companies, it becomes the domain of architecture astronauts and snake oil salesmen, who will do anything to keep it alive so they can earn their consulting fees.
14:22:23 <Heffalump> well, they're still at it. Just without me.
14:22:26 <oklopol> @die 1d6
14:22:27 <lambdabot> 1d6 => 1
14:22:28 <dons> `architecture astronauts' is such an awesome title
14:22:43 <Heffalump> oh, I seem to be on lots of papers about aspects dated 2006 too.
14:22:50 <dejones> tromp: maybe, monads protect purity is better?
14:22:59 <Botje> dons: because you're floating high above what you're building? or because your suit might get some nuclear waste in it?
14:23:38 * Heffalump disappears
14:23:39 <gwern> actually, suffixes isn't a good choice - if it's Network.Stream and Network.Strict.Stream you can just create a Strict/ and move the files into the directory
14:23:50 <tromp> maybe, dejones
14:24:20 <dejones> kayess___ what is going on with all these reconnects...?
14:25:14 <gwern> dmwit: 'Haskell's killed the Old ML Star' doesn't scan right - 4 syllables after 'the', instead of the 3 of 'video star'
14:25:47 <dmwit> ...what?
14:26:09 <dmwit> I think you better count the syllables in "video star" again.
14:26:20 <gwern> dmwit: we're parodying the title of 'Video Killed The Radio Star', first video shown on MTV, by swapping in Haskell and ML
14:26:20 <Twey> There are three
14:26:45 <dmwit> "ra-di-o star" is four syllables
14:26:45 <idnar> 'video star' has 4 syllables
14:26:49 <gwern> what? video is two
14:26:52 <Twey> 'Video killed the radio star' -- vid-e-o killed the rad-i-o star
14:26:59 <idnar> or vi-de-o
14:26:59 <dejones> video = 3
14:27:05 <dejones> vid-e-o :D
14:27:08 <tromp> ra-di-o
14:27:14 * dejones votes for vid-e-o
14:27:20 <Twey> Consonants to taste :-P
14:27:26 <tromp> vi-de-o
14:27:28 <gwern> who pronounces it 'e-o'?
14:27:32 <dmwit> dolio++ neat sharing solution
14:27:34 <dejones> Twey: you can be a rapper now!
14:27:38 <Twey> Everyone :-\
14:27:41 <Twey> Haha, dejones
14:27:44 <Twey> I tried that once
14:27:48 <ahunter_> listening to song suggests vi-de-o
14:27:49 <dejones> lol
14:27:55 <Twey> Rapping in an upper-class accent really doesn't work :-P
14:28:38 <dejones> Twey: English rapper, hehe:  http://youtube.com/watch?v=d-MYVv4tgQc
14:28:39 <lambdabot> Title: YouTube - Dan Le Sac vs Scroobius Pip 'Thou Shalt Always Kill'
14:28:50 <gwern> Twey: if a synthezied stephen hawking voice can rap, you can rap in that accent
14:28:53 <ahunter_> dejones: if there's an algorithm, YO! I'll solve it!  Check out the syntax while GHC evaluates it?
14:29:12 <gwern> ahunter_: the chorus maybe, but not the buggles lead singer
14:29:15 <ahunter_> hmm, it's hard to make Ice Ice Baby good, even with Haskell
14:29:24 <dejones> ahunter_: oh my... hhaha
14:30:16 <Twey> ahunter_: :-D
14:33:23 <dejones> kayess: you're signed on 3 times... lol
14:33:29 <dejones> having some serious connection issues?
14:35:50 * dejones kicks kayess
14:35:51 <dejones> heh
14:41:19 <wagle> <djwong> "Gradually refract the code base."
14:44:02 <Twey> Refract?  :-D
14:44:12 <EvilTerran> i prefer to reflect the code acid
14:47:05 <Peaker> @msg kuribas The "Incremental Computing" paper you linked me to is inspiring and very cool. However, the "Differential Computing" I had in mind is a bit more than that - its not only that dependent values are recomputed when needed, but also that instead of an opaque "replace-value" event for observed values, I want to have "diffs" apply to object, and their observers to process these diffs and generate new diffs. These diffs should prefer
14:47:05 <Peaker> ably also apply to observable composite objects, and broken down into more primitive changes for observers that don't recognize them
14:47:05 <lambdabot> Not enough privileges
14:47:47 <shapr> Peaker: try @tell
14:47:50 <shapr> @msg is different.
14:47:54 <Peaker> ah, thanks
14:48:44 <hpaste>  ArcSin_ pasted "fromIntegral??" at http://hpaste.org/6759
14:49:09 <jewel> what is this incremental computing paper?
14:49:30 <Peaker> http://www.cse.ogi.edu/~magnus/papers/icfp-2002.pdf
14:50:26 <Peaker> jewel, If you want to describe a world with mutable entities, where some of these entities compute their value from others, you want dependent values recomputed upon changes.. An example is a spreadsheet
14:50:31 <gwern> @tell Bringert also, patches for the strict version. honestly, the strict and lazy libraries should just be merged, there's an incredible amount of duplication going on there afaic
14:50:31 <lambdabot> Consider it noted.
14:50:37 <Peaker> With a proper computing architecture (not today's), a build system would be replaced by that too
14:51:02 <Peaker> (If instead of files, we had these "mutable objects")
14:52:02 <ehird> is Peaker talking crap again? :-P
14:52:10 <Peaker> ehird, Why thank you
14:52:17 <ehird> :D
14:52:52 <Peaker> ehird, I think you're the only hostile person I've encountered in #haskell :P
14:52:59 <monochrom> Why do people have so much opinion?
14:53:16 <ehird> haha, Peaker, i was joking
14:53:28 <ehird> but your 'remove names' idea was crap ;)
14:53:42 <luqui> I'm trying to do project euler problem 67 purely (http://projecteuler.net/index.php?section=problems&id=67)
14:53:43 <lambdabot> Title: Problem 67 - Project Euler
14:53:48 <Peaker> ehird, Its not my idea, its Jonathan Edwards idea, and I think its great :)
14:53:59 <luqui> and I know I can do it if I store the numbers in an array
14:54:10 <luqui> but I'm wondering if its possible to put the triangle into a tree with a lot of sharing
14:54:14 <Peaker> ehird, "removing names" is a bad way to put it - names become mere comments, that's all
14:54:15 <dons> ehird: please be nice. no swearing.
14:54:30 <dons> we need more shapr around
14:54:37 <luqui> I've actually done that part, but I can't figure out how to map the solution over that tree so that it doesn't take exp. time
14:55:15 <monochrom> luqui: I suggest http://www.haskell.org/haskellwiki/Dynamic_programming_example  it is still pure.
14:55:15 <lambdabot> Title: Dynamic programming example - HaskellWiki
14:55:57 <ehird> dons: i can't remember the last time cee are [star] pee was considered swearing..
14:56:02 <monochrom> dons: I think ehird and Peaker are getting along fine, enjoying each other. :)
14:56:33 <dons> i just noticed the mood is a bit different recently
14:56:42 <dons> didn't we have a similar conversation yesterday?
14:56:59 <monochrom> No, yesterday's was not similar.
14:57:28 <Dybber> wow, cabal-install is nice :-), although it is a bit of problem that you can't use it when you install it :-D
14:57:44 <shapr> dons: hiya!
14:57:52 <dons> hey shapr.
14:57:53 <bos> lookit! insta-shapr!
14:57:57 * dons bounces!
14:58:03 <dejones> did someone cabal-install shapr?
14:58:03 <dejones> :P
14:58:10 <Nafai> w00t
14:58:14 <dons> see, this here guys is how you be shapr. no one bounces like shapr bounces
14:58:15 <gwern> @hoogle readPackageDescription
14:58:15 <lambdabot> Distribution.PackageDescription.readPackageDescription :: Verbosity -> FilePath -> IO GenericPackageDescription
14:58:20 * shapr bounces
14:58:25 <dons> ?yow!
14:58:25 <lambdabot> This is a NO-FRILLS flight -- hold th' CANADIAN BACON!!
14:58:28 <Saizan> Dybber: i guess there'll be binary packages when we'll have a proper release
14:58:38 <shapr> ehird, Peaker be nice!
14:58:45 <miloshh> does --prefix work with cabal-install?
14:58:54 <monochrom> Anyway I disagree that swearing is inconsistent with friendliness.
14:59:02 <luqui> monochrom, thanks, but that's the way I know how to do it :-).  I'm wondering if its possible to use the sharing in the tree's construction during the computation
14:59:04 <monochrom> It depends on who swears to whom.
14:59:10 <shapr> I think swearing is inconsistent to friendliness for the most part.
14:59:34 <Saizan> miloshh: every flag you would pass to 'Setup configure' also works for cabal-install
14:59:36 <monochrom> *for the most part* is key, IOW, exceptions should be allowed on a case-by-case basis.
15:00:01 <monochrom> Real friends tell each other "your idea is crap lol" all the time.
15:00:03 <shapr> Yeah, but the general rule that swearing is not allowed here is a good rule.
15:00:09 <shapr> @users
15:00:09 <lambdabot> Maximum users seen in #haskell: 483, currently: 468 (96.9%), active: 21 (4.5%)
15:00:14 <Dybber> Saizan: ok, it took me some time to get it working, I don't know if it is a bug, but I had too version of bytestring installed and it wouldn't compile with the cabal-file. I had the 6.8.2 version + the latest installed, removing the latter again made it work.
15:00:28 <monochrom> If you want to ban swearing, that is another rule, not part of friendliness.
15:00:28 <miloshh> Saizan: thanks, very nice
15:00:38 <luqui> monochrom, for example, let s = ...; t = Node 0 s s.   Is it possible to map over the tree such that the function is only called once for s?
15:00:51 <bos> swearing is inconsistent with friendliness if you don't know people well, and it's prone to miscommunication in a text-only medium.  it's fine to call your best buddy a tool over a beer, in fact it might be mandatory.
15:01:08 <ddarius> We have youngin's who might never have watched television!
15:01:29 <monochrom> luqui: I think it's possible. I haven't thought about it.
15:01:36 <Saizan> Dybber: that's a known problem, you probably had some of the libraries compiled against the old bytestring
15:01:37 <ddarius> bos: You're such a bottle opener.
15:02:02 <laura85> good night ^^
15:02:04 <shapr> It's easy to misunderstand across a text medium.
15:02:07 <bos> i prefer to think of myself as a cork.
15:02:13 <Saizan> Dybber: there's a GSoC project to work on that
15:02:14 <Dybber> Saizan: yes, it could look like that from the error-messages
15:02:17 <shapr> g'nite laura85
15:04:31 <bododo> hi folks :)
15:04:37 <monochrom> Anyway if you want the channel rule to mandate that everyone say only nice complimentary things to each other, then don't call it "friendliness", since that is both dishonest about what you really mean and ambiguous as in other people think it means something else.  Call it "everyone should speak politely, conservatively, reclusively, political correctly", since that's what you really mean.
15:04:46 <bododo> this is my first time here
15:05:03 <olsner> bododo: today is a good day to learn haskell!
15:05:10 <Peaker> monochrom, I think there's a logical leap between not swearing and saying only complimentary things
15:05:49 <gwern> monochrom: and then we can rewrite the #xkcd bot so conversation is always novel & interesting!
15:05:49 <mcnster> hi.  is there any way to supress compilation msg "Warning: No explicit method nor default method for `Foo.dummy' In the instance declaration for `Bar Baz`?
15:05:59 <gwern> *rewrite in lambdabot
15:06:08 <bododo> olsner: :) yes I think too (because everyday is a good day to start learning it) what's your reason?
15:06:23 <mcnster> (using gtk2hs)
15:06:49 <cjb> I want to write a cute gtk2hs app, possibly displaying some function of laziness.  But I don't know what.
15:06:57 <Saizan> mcnster: put dummy = error "dummy not defined"
15:07:17 <dejones> cjb: serpenski triangles?
15:07:22 <bododo> I one studied functional and logic programming in university, but that's hum... about 12 years now :(
15:07:31 <shapr> monochrom: 'be nice' is a good rule.
15:07:33 <bododo> s/one/once
15:07:39 <dejones> cjb: sierpinksi, rather
15:07:43 <shapr> monochrom: That's what I really mean, at least.
15:08:06 <monochrom> "nice" is also ambiguous, mind you.
15:08:13 <shapr> Not for me :-)
15:08:17 <monochrom> actually, worse. it's vague.
15:08:31 <bododo> any straight forward, concise and easy tuto I can start with? :)
15:08:45 <mcnster> Saizan, the gtk2hs module where dummy is defined does not export it :(
15:08:56 <monochrom> Well whatever.  Clearly you police really want rules to be vague so you can label anything you like.
15:08:59 <Mr_Awesome> bododo: on being nice?
15:09:06 <shapr> monochrom: Anything can be subject to misinterpretation.
15:09:11 <Mr_Awesome> ;)
15:09:15 <bododo> Mr_Awesome: :)
15:09:18 <bododo> good point! :)
15:09:39 <monochrom> That's a lame excuse.  Some things are less misinterpreted than others.
15:09:40 <bododo> Mr_Awesome: if learning haskell is being nice, then yes!
15:09:54 <shapr> monochrom: And you're right, I'm the channel police, and since I don't think that being nice and respectful is possible to thoroughly quantify, I do in fact think that vague definitions are better.
15:10:05 <Mr_Awesome> bododo: i believe it they are in fact equivalent. youre in luck!
15:10:41 <bododo> great! Mr_Awesome ! help me touch the beauty
15:10:50 <clanehin> Griefers are always looking for loopholes around any precisely stated system of rules.
15:10:55 <cjb> I think we can say "People should behave in a manner that approximates polite friendliness", and be comfortable that we are not in fact asking people to be friendly, and that it's still a good idea.
15:11:04 <shapr> clanehin: Yeah, you got it.
15:11:27 <Nafai> Hey shapr!
15:11:30 <shapr> monochrom: If you'd like more detail on these ideas, check out the "poisnous people" presentation.
15:11:32 <shapr> hiya Nafai!
15:11:47 <olsner> bododo: heh, me getting into haskell was mostly coincidence... I had a perl script that was too slow and I didn't want to learn perl.. so I read a tutorial, rewrote it in haskell, joined #haskell, and here I am
15:12:06 <shapr> salut bododo!
15:12:09 <Saizan> mcnster: are you sure you're supposed to instance that class?
15:12:13 <shapr> bododo: Welcome to #haskell!
15:12:27 <bododo> shapr: merci ! :)
15:12:28 <Mr_Awesome> bododo: if youre familiar with functional programming at all, id go with the gentle introduction to haskell. otherwise, just try out various ones on haskell.org. thats what i did
15:12:38 <bododo> olsner: was it "hard"?
15:12:39 <mcnster> Saizan, yep!
15:12:51 <Nafai> How are you?
15:12:56 <shapr> monochrom: http://video.google.com/videoplay?docid=-4216011961522818645
15:12:57 <lambdabot> Title: How Open Source Projects Survive Poisonous People (And You Can Too)
15:13:04 <bododo> Mr_Awesome: I've done some lisp in university.
15:13:17 <shapr> Nafai: Doing fine, resting from a busy weekend.
15:13:35 <Mr_Awesome> well, give it a try. it was always my personal favorite. if its not gentle enough, try something else
15:13:52 <lament> me getting into haskell was mostly coincidence too... I was walking down a street and got hit by a vegetable cart and knocked unconscious... when i regained concsiousness, i was in #haskell
15:14:00 <shapr> lament: Cool!
15:14:06 <bododo> so you huys, think I can be a haskeller like you in say... a week? two? three? :)
15:14:17 <bparkis> a kind of fun thing to do is to get a large body of text and compute the probability that one word will be followed by another, then generate random sequences of words
15:14:19 <shapr> bododo: You can be one right now! It involves learning lots of cool stuff.
15:14:25 <bparkis> based on those 2 word probabilities
15:14:37 <Mr_Awesome> all it takes to be a haskeller is enthusiasm and optimism
15:14:42 <shapr> bparkis: I saw a hidden markov model that was just released recently.
15:14:44 <shachaf> bododo: You can only be a Haskeller like yourself. :-)
15:14:44 <bparkis> because the end product makes no sense but sounds a lot like the original body of text
15:14:46 <bododo> shapr: And I'm reaaly wiling to learn :)
15:14:51 <shapr> bododo: Awright!
15:14:57 <lament> all it takes to be a haskeller is to eat Oleg's brain
15:15:00 <bparkis> so what I am looking for is something that will do this only better, more professionally
15:15:00 <shapr> eek!
15:15:02 <bparkis> just for fun
15:15:10 <bododo> shachaf: this is a haskell spirit? :)
15:15:10 <shapr> bparkis: Check out the hmm lib on hackage?
15:15:11 <bparkis> that will take a text and generate stuff that ALMOST seems to make sense
15:15:18 <bparkis> but doesn't
15:15:44 <shachaf> @@ bparkis: Regarding your earlier question: Have you seen (@wiki Meta-tutorial)?
15:15:44 <lambdabot> Plugin `compose' failed with: Unknown command: ""
15:15:54 <wagle> so i have to kill my parent process then syscall exit before i can be a haskeller?
15:15:55 <shachaf> bododo: Regarding your earlier question: Have you seen (@wiki Meta-tutorial)?
15:16:02 <shachaf> @wiki Meta-tutorial
15:16:02 <lambdabot> http://www.haskell.org/haskellwiki/Meta-tutorial
15:16:06 <bparkis> which earlier question shachaf?
15:16:10 <bparkis> oh
15:16:13 <shachaf> bparkis: Sorry, wrong nick.
15:16:31 <bododo> actually, I've done the same experience with python, I joined #python and with some nice folk's encouragements, like you just did, I believe I can make anything I want with python now... so heck! let's jump in! :)
15:16:48 <bododo> shachaf: not yet, actually
15:16:52 <shachaf> Oh, it was the question mark.
15:17:23 <shachaf> @karma+ @@
15:17:23 <lambdabot>  @@'s karma raised to 1.
15:17:43 <EvilTerran> heh
15:17:44 <Peaker> monochrom, btw: As a newbie in this channel, my general experience was extremely positive, so I am not sure if there are rules being enforced, or if rules are just unnecessary...
15:17:48 <olsner> @karma @@
15:17:48 <lambdabot>  @@ has a karma of 1
15:17:52 <bododo> @karma- @@
15:17:52 <lambdabot>  @@'s karma lowered to 0.
15:17:55 <olsner> @karma @pl
15:17:55 <lambdabot>  @pl has a karma of 0
15:17:57 <olsner> @karma pl
15:17:57 <lambdabot> pl has a karma of 1
15:18:03 <shachaf> @karma- @@
15:18:03 <lambdabot>  @@'s karma lowered to -1.
15:18:07 <shachaf> @karma+ @
15:18:07 <lambdabot>  @'s karma raised to 1.
15:18:10 <shachaf> @karma+ @@
15:18:10 <lambdabot>  @@'s karma raised to 0.
15:18:20 <bododo> @karma+100 @@
15:18:20 <lambdabot> Unknown command, try @list
15:18:21 <shachaf> @karma ?
15:18:21 <lambdabot> ? has a karma of -1
15:18:24 <shachaf> Huh.
15:18:28 <bododo> ouch! :p
15:18:37 <shachaf> @karma java
15:18:38 <lambdabot> java has a karma of -22
15:18:39 <olsner> Peaker: usually, they're not necessary, haskellers are inherently nice
15:18:56 <bododo> :)
15:18:57 <shachaf> It comes from the Oleg brain nibbles, I think.
15:19:00 <shapr> monochrom: What do you think about that video?
15:19:08 <bododo> thank you all guys! :)
15:19:25 <dolio> People do occasionally get banned.
15:19:29 <dolio> @protontorpedo
15:19:29 <lambdabot> is haskell able to outdo perl or python for web?
15:19:31 <bododo> see you in a week, I'll come with the basic knowledge to bother you more :)
15:19:39 <shapr> Peaker: There are rules being enforced.
15:19:48 <shapr> Peaker: And I'm glad to hear that your experience has been positive!
15:19:48 <ddarius> with a shotgun...
15:19:50 <dolio> @keal
15:19:50 <lambdabot> my very first computer was an 80-0840
15:19:54 <dolio> @palomer
15:19:54 <lambdabot> Brump!
15:20:03 <bododo> @list
15:20:03 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
15:20:30 * ddarius isn't particularly good at the "being nice" thing.
15:20:52 <olsner> hmm, but were those trolls actually haskellers?
15:20:59 <bododo> is this bot written in haskell?
15:21:05 <wagle> @nice +15 ddarius
15:21:05 <lambdabot> unexpected "+": expecting number
15:21:08 <ddarius> Smerdyakov is a better example.
15:21:15 <dolio> palomer was, allegedly.
15:21:17 <ddarius> But that was pre most of you.
15:21:28 <olsner> @palomer
15:21:28 <lambdabot> As someone who's studied GADTs, I've never found a use for them.
15:21:29 <lament> smerdyakov is not a haskeller
15:21:43 <shachaf> bododo: Yes.
15:21:47 <ddarius> lament: He was more of an MLer, true, but still
15:21:48 <lament> he's a whatchumacaller
15:21:57 <bododo> shachaf: nice to hear this
15:22:28 <lament> ddarius: i haven't experienced him in this channel, but he's a bit of a legend around freenode anyway
15:22:35 <bododo> see you guys! and again thanks! :)
15:22:48 <ehird> is there a library for delimited continuations?
15:22:59 <ddarius> lament: He is?  I only know of him on IRC from when he was in #haskell.
15:22:59 <monochrom> @package CC-delcont
15:22:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/CC-delcont
15:23:09 <lament> ddarius: he would occasionally show up in #python to talk about how static typing was the only way to program.
15:23:20 <Excedrin> I don't think Smerdyakov was a troll, his anti-homework argument makes sense to me
15:23:27 <cjb> lament: I've done that before.  :)
15:23:51 <lament> he's more of a nut than a coscious troll
15:23:59 <Twey> Heh
15:24:22 <Peaker> Excedrin, anti-homework argument?
15:24:26 <dolio> Like Xah Lee?
15:24:27 <ehird> are these delimited continuations serializable in any way? (yeah, yeah, i already know the answer ;p)
15:24:38 <monochrom> Not at the moment.
15:24:39 <lament> ehird: No :)
15:24:45 <dolio> No, they are not serializable. They're built out of functions. :)
15:24:47 <TSC> No one is like Xah Lee
15:25:05 <ddarius> Excedrin: The issue with Smerdyakov was that he seemed to view himself as unattainably better than 99% of the people in #haskell and that if you weren't at his "level" there was no hope for you.
15:25:05 <Excedrin> Peaker: basically that people asking for homework help shouldn't be, and it's unethical to help them on irc
15:25:15 <ehird> dolio: would it be possible to build a delimited continuation library not built n functions? :P
15:25:21 <ehird> Excedrin: I agree
15:25:36 <Peaker> Excedrin, does that happen often?
15:25:52 <lament> ddarius: isn't everybody like that?
15:25:54 <ehird> Peaker: very
15:26:00 <ddarius> lament: No.
15:26:05 <Excedrin> Peaker: yea, people pop in, ask for some help with a trivial problem, get help and split
15:26:17 <Peaker> Excedrin, that doesn't necessarily indicate homework?
15:27:03 <Excedrin> well, Smerdyakov would ask them first if it was homework, if they said yes, then he'd explain why he won't help them and that they should be getting help from their professor or a TA or whatever
15:27:21 <dolio> ehird: I don't see how you'd do it in ordinary Haskell without writing an interpreter for another language with serializable continuations.
15:27:53 <dolio> ehird: Maybe if you hooked into the runtime system, you could make seralizable delimited continuations for IO.
15:28:20 <dolio> Save and restore whatever stack is used and whatnot.
15:28:22 <ddarius> lament: While probably more than 1% of the people here think of themselves as better than 99% of the people here, the difference is that most of the more "capable" people here are more than happy to help others get better and they (often) do so without being condescending.
15:28:25 <dolio> Although that's a big job.
15:28:25 <dons> serialising delimited continuations ,eh?
15:28:28 <dons> that's kinda cool
15:28:35 <dons> you'd need to reflect them into data though
15:28:58 <ddarius> dons: And then refract them into zippers !
15:29:28 * Twey grins.
15:30:55 <lament> *head explodes*
15:31:26 <malsyned> Is there a function in the standard library that will take two lists like ["1", "2", "3", "4"] and ["a", "b", "c"] and return ["1", "a", "2", "b", "3", "c"] ?
15:31:40 <monochrom> If you do it for a week, you won't notice the head explosions anymore.
15:32:47 <malsyned> If I were to give such a function a name, it would be something like "interleave", but I could find no such thing via hoogle
15:32:48 <mauke> > concat $ zipWith (\x y -> [x, y]) ["1", "2", "3", "4"] ["a", "b", "c"]
15:32:49 <lambdabot>  ["1","a","2","b","3","c"]
15:33:31 <malsyned> > [[x, y] | x <- ["1", "2", "3", "4"] | y <- ["a", "b", "c"]]
15:33:31 <lambdabot>  Parse error at "|" (column 37)
15:33:37 <ddarius> > concat $ transpose [["1","2","3","4"], ["a","b","c"]
15:33:38 <lambdabot>  Parse error at end of input
15:33:42 <ddarius> > concat $ transpose [["1","2","3","4"], ["a","b","c"]]
15:33:42 <lambdabot>  ["1","a","2","b","3","c","4"]
15:34:14 <malsyned> Is what I did not the syntax for parallel comprehensions?  or is that extension not turned on in lambdabot?
15:34:15 <ddarius> Not quite the specification.  No gold star for me.
15:34:28 <ddarius> malsyned: It's not turned on.
15:34:37 <ddarius> malsyned: Anyway, zipWith is usually more compact
15:34:38 <malsyned> ddarius: right.  I need it to drop excess, so I can give an infinite list as one of the args.
15:35:40 <ddarius> > concat $ transpose [[0..],[11,22,33]]
15:35:40 <lambdabot>  [0,11,1,22,2,33,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,2...
15:35:42 <hpaste>  ArcSin_ annotated "fromIntegral??" with "Can Anyone clarify that I do not need an instance declaration to make this work" at http://hpaste.org/6759#a1
15:35:44 <lament> join is shorter than concat :)
15:36:50 <ddarius> transpose is an under-utilized function
15:37:24 <ehird_> cc-delcont doesn't compile
15:37:31 <monochrom> how come?
15:37:49 <chessguy> @pl \x -> \k -> k x
15:37:49 <lambdabot> flip id
15:37:52 <ehird_> it wants -xflexibleinstances
15:37:56 <ehird_> and cabal says 'go to hell'
15:38:01 <ehird_> and doesn't give it them
15:38:02 <ehird_> :)
15:38:18 <monochrom> You using 6.8.2?  I'll try it.
15:38:18 <_roconnor> A lie group is a manifold?
15:38:47 <lament> @pl \x y -> [x, y]
15:38:47 <lambdabot> (. return) . (:)
15:38:56 <lament> ugh
15:39:42 <EvilTerran> > ((++) `on` return) 1 2
15:39:42 <lambdabot>   add an instance declaration for (Monoid (m a))
15:39:44 <olsner> woot, c++0x is supposedly having monads
15:39:53 <EvilTerran> > ((Prelude.++) `on` return) 1 2
15:39:53 <lambdabot>   Not in scope: `Prelude.++'
15:39:56 <EvilTerran> gah
15:40:01 <ddarius> roconnor: According to wikipedia
15:40:01 <EvilTerran> > ((++) `on` return) 1 2 :: [Int]
15:40:02 <lambdabot>  [1,2]
15:40:09 <EvilTerran> lambdabot, that any better?
15:40:09 <monochrom> ehird_: on ghc 6.8.2 I get no error.
15:40:14 <ehird_> Control/Monad/CC.hs:83:0:
15:40:14 <ehird_>     Illegal instance declaration for `MonadReader r (CCT ans m)'
15:40:14 <EvilTerran> er, lament
15:40:15 <lament> EvilTerran: yes
15:40:24 <ehird_> lambdabot: HELLO
15:40:30 <ehird_> <lambdabot> HOW DO YOU FEEL ABOUT HELLO
15:40:34 <EvilTerran> ?vixen hello
15:40:34 <lambdabot> how're you?
15:40:48 <EvilTerran> ?vixen just lovely thanks. yourself?
15:40:48 <lambdabot> my pleasure
15:40:51 <dolio> ehird_: What version of GHC are you running?
15:41:11 <chessguy> @quote hello
15:41:12 <lambdabot> erg0t says: <erg0t> @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.   <lambdabot>  Hello World!
15:41:50 <Twey> @bf  ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
15:41:50 <lambdabot> Done.
15:41:55 <opqdonut> ?quote ghc
15:41:55 <lambdabot> ghc says: Can't represent Oxford brackets
15:41:58 <Twey> :-(
15:42:02 <ehird_> err, gosh, brainfuck runs a brainfuck program
15:42:03 <ehird_> how amazing
15:42:18 <opqdonut> ?quote ehird
15:42:18 <lambdabot> No quotes match. Wrong!  You cheating scum!
15:42:21 <opqdonut> :(
15:42:21 <lament> it runs a brainfuck program and then doesn't display the output?
15:42:26 <ehird_> dolio: .
15:42:27 <lament> very useful
15:42:31 <ehird_> lament: I meant, that quote
15:42:34 <gwern> hm. has anyone heard of a 'HxmlToolbox'?
15:42:38 <ehird_> it's not ... interesting... or suprising
15:42:42 <gwern> lament: it allows for insane optimizations though
15:42:49 <Saizan> gwern: HXT?
15:42:58 <lament> gwern: hardly.
15:43:09 <gwern> if you scrap the requirement for IO, you can get O(1) *everything*!
15:43:09 <ehird_> Hmm, is there a Haskell lib generating HTML/XML that encodes validity information into the typesystem?
15:43:12 <ehird_> If not, I must write one!
15:43:17 <gwern> Saizan: that would make sense
15:43:18 <Saizan>  @bf is probably being spellcorrected to something else now
15:43:19 <lament> gwern: that's not true.
15:43:25 <ddarius> ehird_: There is.
15:43:32 <ehird_> ddarius: Is there? damnit that sounded fun
15:43:32 <lament> gwern: you need to preserve non-termination
15:43:35 <ehird_> I was going to make it XML
15:43:40 <ehird_> and you could specify your own validity information
15:43:41 <ehird_> for dialects
15:43:48 <cadabra> data A = B | C | D.    Can I get a list of constructors for A?
15:43:52 <monochrom> check out both hxt and haxml.  there may be others.
15:44:23 <ehird_> oh well
15:44:26 <cadabra> specifically [B, C, D]
15:44:27 <ehird_> guess i'll have to write my own
15:44:29 <ddarius> cadabra: I think you may be able to if you derive Data (or you could manually write such a type class).
15:44:32 <ehird_> since all the others MUST COMPLETELY SUCK
15:44:33 <gwern> yeah, it's HXT. just neversaw the acronym expanded before
15:44:38 <ehird_> HARD
15:44:44 <ehird_> because i didn't write them, obviously
15:44:50 <ehird_> now i shall do the dumb approach!
15:44:54 <lament> how come you didn't write haskell either?
15:45:02 <ehird_> (CanContain a b)
15:45:06 <ehird_> 'a' can contain a 'b'
15:45:08 <ehird_> a typeclass.
15:45:24 <cadabra> ddarius: I'm kinda new to Haskell. What do you mean?
15:45:31 <Saizan> ehird_: see WASH, it has that
15:45:33 <monochrom> Template Haskell (TH) may get you the constructors.
15:45:33 <roconnor> apparently I didn't know what a Lie group was
15:45:42 <ehird_> Saizan: meh :)
15:45:44 <gwern> lament: you simply randomly go into an infinite loop. for all values of brainfuck program, it is observationally indistinguishable
15:45:59 <ddarius> roconnor: Apparently.  I just didn't remember if it was merely a topological group or a group object in the category of manifolds.
15:46:02 <ehird_> hm
15:46:07 <ehird_> i don't think my typeclass needs anything
15:46:08 <ehird_> convenient
15:46:19 <roconnor> ddarius: I always thought it was a topological group
15:46:31 <ehird_> class (IsXml p, IsXml c) => CanContain p c
15:47:07 <lament> gwern: that's cheating.
15:47:20 <lament> gwern: If your brainfuck program doesn't have any loops, it should obviously terminate.
15:47:24 <gwern> I'm a little confused. is cpphs part of GHC, or does GHC just bundle a snapshot?
15:47:29 <malsyned> cadabra: what you're trying to do is reflection into the type system.  That's not, by default, possible at run time in Haskell, but have a look at the Data.Typeable docs (http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html) for creating classes that you can do that to.
15:47:32 <lambdabot> http://tinyurl.com/ylclo5
15:47:33 <ddarius> cadabra: I'm suspecting that you may be approaching the issue you are having from perhaps the wrong (or less than useful in Haskell) direction.  It's not common to want what you want.
15:47:36 <ehird_> lament: maybe the machine is infinitely slow, sometimes
15:48:35 <lament> ehird_: ah, that could happen.
15:48:38 <gwern> lament: yeah, I'm cheating. but if you could know before hand for all programs whether they halt and if so in how much time, then you have the halting problem licked; otherwise for some programs you couldn't tell an 'honest' brainfuck interpreter from a real one looping or taking a long time
15:49:08 <joricj> i'm trying to do a regular expression: mkRegex "/^[^\s]( [^:][^\s]+)*(:[^\r]*)?$/"
15:49:21 <EvilTerran> cadabra, if you tack "deriving (Bounded, Enum)" onto your type, [minBound .. maxBound] :: [YourType] will do what you want
15:49:23 <lament> gwern: exactly why you can't have O(1) everything
15:49:31 <ddarius> joricj: Escape you backslashes
15:49:39 <EvilTerran> cadabra, if none of your constructors have parameters, that is
15:49:41 <joricj> oh
15:49:47 <Twey> Esape,, you foul backslashes!
15:50:06 <EvilTerran> joricj, is the string really meant to have "/" at each end?
15:50:07 * gwern defines my interpreter to have all O(1) operations but with constants greater than the lifespan of the universe
15:50:07 * Twey tpyse lwle.
15:50:09 <cadabra> EvilTerran: that's what I want :)
15:50:19 <ehird_> instance (CanContain a b) => CanContain a [b]
15:50:21 <ehird_> i think that's right.
15:50:28 <Twey> gwern: Hahaha
15:50:35 <ehird_> wait, no..
15:50:37 <ehird_> hmm
15:50:43 <ehird_> embedding this into the type system is non-trivial :(
15:50:51 <ddarius> gwern: So it's a ruby interpreter?
15:50:57 <EvilTerran> cadabra, but if there's parameters involved, you'd need to resort to something like ddarius' Data suggestion
15:51:12 <ehird_> @remember * gwern defines my interpreter to have all O(1) operations but with constants greater than the lifespan of the universe    <ddarius> gwern: So it's a ruby interpreter?
15:51:12 <lambdabot> It is forever etched in my memory.
15:51:14 <joricj> EvilTerran: yeah i'm noticing that too now :D
15:51:25 <EvilTerran> :D
15:51:27 <joricj> to put a literal \r (carriage return), do i use \\\\r?
15:51:30 <ehird_> @quote ruby
15:51:30 <lambdabot> LoganCapaldo says: ruby isn't trying to out-python python, its trying to out-smalltalk perl :)
15:51:40 <monochrom> @quote gwern defines my interpreter
15:51:40 <lambdabot> No quotes match. Where did you learn to type?
15:51:46 <EvilTerran> joricj, nah, just "\r" should do
15:51:50 <monochrom> @quote gwern
15:51:50 <lambdabot> gwern says: <jfoutz> is clean typed? <gwern> I hear some people dictate down their clean programs through voice recognition programs
15:51:55 <ehird_> @quote ruby
15:51:55 <lambdabot> LoganCapaldo says: ruby isn't trying to out-python python, its trying to out-smalltalk perl :)
15:51:57 <ehird_> eh
15:51:59 <ehird_> i got it in /msg
15:52:05 <ehird_> [23:51] <lambdabot> * says: gwern defines my interpreter to have all O(1) operations but with constants greater than the lifespan of the universe    <ddarius> gwern: So it's a ruby interpreter?
15:52:07 <dolio> @quote *
15:52:07 <lambdabot> * says: gwern defines my interpreter to have all O(1) operations but with constants greater than the lifespan of the universe    <ddarius> gwern: So it's a ruby interpreter?
15:52:07 <ehird_> * says isn't perfect
15:52:08 <EvilTerran> joricj, i'd expect it to be able to deal with stuff like actual newlines in the regex in the sensible way
15:52:33 <EvilTerran> ?help quote
15:52:33 <lambdabot> quote <nick>
15:52:33 <lambdabot> remember <nick> <quote>
15:52:33 <lambdabot> Quote somebody, a random person, or save a memorable quote
15:52:40 <opqdonut> ?quote
15:52:41 <lambdabot> shachaf says:  monochrom: Emacs is also a joke. :-)
15:52:42 <gwern> ddarius: if you can't constructively prove my interpeter has non-O(1) operations, then did the tree really fall?
15:52:43 <ddarius> @help forget
15:52:44 <lambdabot> forget nick quote.  Delete a quote
15:52:58 <EvilTerran> ... so ?quote * recalls the last @remember?
15:53:05 <opqdonut> no
15:53:08 <opqdonut> a random one
15:53:11 <opqdonut> ?quote
15:53:11 <lambdabot> tomasz says: After all, return is only a fancy name for liftM0 :-)
15:53:18 <EvilTerran> it seems to be always recalling the last one...
15:53:20 <EvilTerran> ?quote *
15:53:20 <lambdabot> * says: gwern defines my interpreter to have all O(1) operations but with constants greater than the lifespan of the universe    <ddarius> gwern: So it's a ruby interpreter?
15:53:20 <opqdonut> hmm, that's a good one
15:53:28 <ehird_> * means i didn't give a name
15:53:47 <opqdonut> ah, "?quote *" missed the star  there
15:53:53 <EvilTerran> oh, yeah, i missed that too
15:53:55 <EvilTerran> :P
15:53:56 <ddarius> ehird_: You gave it a name: *
15:53:58 <dolio> No, you gave a name of '*'.
15:54:05 <ehird_> ohhh i see
15:54:14 <ehird_> (<<<) html :: (CanContain TagHtml a) => a -> TagHtml    -- hee
15:54:26 <ehird_> i ... think
15:55:09 <gwern> ehird_ CanContain CheezBurger?
15:55:18 <EvilTerran> ?where lambdacats
15:55:18 <lambdabot> http://arcanux.org/lambdacats.html
15:55:21 <gwern> *ehird_cat
15:55:42 <ehird_> heh
15:55:43 <EvilTerran> hm... need moar lambdacats
15:55:45 <ehird_> can you have `` for types?
15:55:51 <ehird_> (TagHtml `CanContain` a) => ...
15:56:01 <EvilTerran> ehird_, indeed you can. it may be a ghc extension, tho
15:56:08 <ehird_> (+++) html :: (a `CanFollow` TagHtml) => ...
15:56:32 <EvilTerran> ?type (&&&)
15:56:33 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:56:41 <gwern> EvilTerran: seriously, you can? MADNESS
15:56:52 <ehird_> para <<< [strong "hello ", "world"] :: TagP       -- should the type here be more specific than TagP?
15:56:54 * ddarius misses the good old days when efficiently putting pixels on the screen was easy.
15:57:18 <EvilTerran> ?type (&&&) :: Arrow (~>) => (a ~> b) -> (a ~> c) -> a ~> b c
15:57:19 <lambdabot>     Kind error: `b' is applied to too many type arguments
15:57:19 <lambdabot>     In the type `b c'
15:57:19 <lambdabot>     In the type `a ~> b c'
15:57:21 <ddarius> EvilTerran: It's certainly not Haskell 98.
15:57:27 <EvilTerran> ?type (&&&) :: Arrow (~>) => (a ~> b) -> (a ~> c) -> a ~> (b, c) -- eveb
15:57:28 <lambdabot> forall (~> :: * -> * -> *) a b c. (Arrow ~>) => ~> a b -> ~> a c -> ~> a (b, c)
15:57:42 <EvilTerran> hehe, that's broken
15:58:03 <EvilTerran> ddarius, i knew infix classes weren't h98, but wasn't sure about types. good to know.
15:58:18 <ehird_> ?type (>>=) :: (a `Monad`) => (a -> b `Monad`) -> (b `Monad`)
15:58:19 <lambdabot> parse error on input `)'
15:58:21 <ehird_> aww
15:58:26 <ehird_> you can do postfix operators in ghc
15:58:29 <ehird_> so i figured maybe types..
15:58:38 <EvilTerran> you can't have type sections, AFAIK
15:58:41 <opqdonut> `` doesn't work on types
15:58:46 <opqdonut> and sections neither
15:58:47 <opqdonut> iirc
15:58:50 <EvilTerran> because (`Foo` a) would be a type lambda
15:59:02 <opqdonut> mhmm
15:59:02 <ehird_> whoa, oops
15:59:08 <EvilTerran> opqdonut, `` does work on types. some library has a `O` for type composition
15:59:17 <opqdonut> oh, okay
15:59:29 <EvilTerran> but, as ddarius mentioned, it's not h98
15:59:34 <opqdonut> ah
15:59:40 <ehird_> type composition...?
15:59:43 <EvilTerran> i think both ghc and hugs do it right, tho
16:00:02 <EvilTerran> ehird_, ([] `O` Maybe) Int being isomorphic to [Maybe Int]
16:00:18 <EvilTerran> (or, in general, (f `O` g) a ~~ f (g a)
16:01:06 <ehird_> does HaXml generate XML?
16:01:09 <ehird_> I want a type-safe XML generator
16:01:32 <EvilTerran> http://hackage.haskell.org/packages/archive/category-extras/0.1/doc/html/Control-Functor.html <- la
16:01:35 <lambdabot> http://tinyurl.com/38u55c
16:01:36 <ehird_> type O a b c = a (b c)
16:01:39 <ehird_> right?
16:01:58 <EvilTerran> newtype, so you can partially apply it in instances and whatnot
16:02:04 <ehird_> @. pl djinn (a -> b -> c) -> (c -> d) -> a -> b -> d
16:02:04 <lambdabot> f = flip ((.) . (.))
16:02:18 <ehird_> oh, oops
16:02:21 <ehird_> ?type (.) . (.)
16:02:22 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
16:02:26 <EvilTerran> but it's the same idea
16:02:28 <ehird_> O `O` O
16:02:30 <ehird_> :D
16:02:34 <EvilTerran> O dear...
16:02:42 <ehird_> yeah
16:02:48 <EvilTerran> ... unfortunately, we don't have kind polymorphism, so that wouldn't work
16:02:52 <ehird_> well phoo
16:02:57 <ehird_> but yeah
16:03:01 <ehird_> type-safe xml generation
16:03:02 <ehird_> does it exist?
16:03:06 <EvilTerran> O :: (* -> *) -> (* -> *) -> * -> *
16:03:07 <ehird_> like the stuff i made up there
16:03:16 <EvilTerran> ?type (.) -- kinda reminiscent of this
16:03:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:03:23 <EvilTerran> ...cheeky
16:03:32 <ehird_> O :: forall k. (k -> k) -> (k -> k) -> k -> k
16:03:34 <ehird_> right?
16:03:35 <ehird_> :D
16:03:42 <EvilTerran> no, the kind has to be *
16:03:45 <ehird_> yeah
16:03:47 <ehird_> but i mean
16:03:52 <ehird_> if we had kind polymorphism
16:03:59 <ehird_> i guess you can drop the forall
16:04:04 <EvilTerran> ah, yes. er, i guess that would work
16:04:12 <ehird_> O :: (k -> k) -> (k -> k) -> k -> k
16:04:17 <fophillips> Does `con ns : head ns : say (drop (con ns) ns)` calculate `con ns` twice, or does it use the previously computed values? where con :: [a] -> Integer
16:04:21 <ehird_> so k can be *, * -> *
16:04:21 <ehird_> etc
16:04:28 <ehird_> hmm
16:04:29 <ehird_> maybe:
16:04:40 <ehird_> O :: (k -> l) -> (l -> m) -> k -> m
16:04:44 <ehird_> that's even more inasne
16:04:45 <ehird_> no? :D
16:04:50 <EvilTerran> fophillips, that'll probably be calculated twice, altho that's (of course) an implementation detail
16:05:17 <ehird_> hmm
16:05:17 <EvilTerran> ehird_, i guess so... not sure if those two parameters are the right way round, mind, but i get the idea
16:05:21 <dmwit> fophillips: let-float the con call, and you'll be good in just about any implementation
16:05:21 <ehird_> wouldthat work? yeah, it would
16:05:28 <ehird_> EvilTerran: is that likely to be added, ever?
16:05:29 <EvilTerran> ?type (id.) . (.)
16:05:30 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:05:34 <EvilTerran> bah.
16:05:42 <ehird_> ?type \f g x -> f (g x)
16:05:43 <lambdabot> forall t t1 t2. (t1 -> t2) -> (t -> t1) -> t -> t2
16:05:50 <EvilTerran> clever :P
16:05:57 <dmwit> ehird_: Probably (k -> l) -> (m -> k) -> (m -> l), no?
16:06:08 <ehird_> O :: forall k l m. (l -> m) -> (k -> l) -> k -> m
16:06:09 <EvilTerran> kind polymorphism... could theoretically be added, but i don't think there's much call for it
16:06:14 <ehird_> dmwit: wrong
16:06:20 <ehird_> i just translated (.)s signature
16:06:23 <EvilTerran> most things don't make sense to be kind polymorphic
16:06:23 <ehird_> so it Must Be Right
16:06:24 <ehird_> :p
16:06:32 <ehird_> EvilTerran: but it's fun to bend your mind with
16:06:36 <dmwit> ehird_: um
16:06:43 <dmwit> ehird_: Yours and mine are equivalent up to names...
16:06:46 <EvilTerran> ehird_, you said the same thing...
16:06:48 <ehird_> dmwit: I know that
16:06:50 <ehird_> it was a joke
16:06:50 <ehird_> :<
16:06:54 <dmwit> oh =P
16:07:08 <labacathoo> hello
16:07:08 <ehird_> challenge
16:07:10 <ehird_> what the hell is this:
16:07:15 <ehird_> ? :: forall k. k
16:07:24 <EvilTerran> Î±-equivalence FTW
16:07:28 <EvilTerran> ehird_, that's _|_
16:07:36 <ehird_> EvilTerran: Even as a kind?
16:07:37 <ehird_> Hmm
16:07:42 <ehird_> If kinds are the types of types
16:07:45 <ehird_> Then what's the type of kinds?
16:07:45 <dmwit> labacathoo: Hiya!
16:07:49 <ehird_> Friendlies?
16:07:52 <dmwit> superkind
16:08:02 <labacathoo> hi, i'm here for the same reason as fophillips
16:08:03 <ehird_> dmwit: do those exist
16:08:03 <ehird_> :p
16:08:09 <ehird_> actually, i guess there's only about 3 of those
16:08:09 <fophillips> o_o
16:08:20 <ehird_> and that they only become useful with kind variables
16:08:20 <EvilTerran> ehird_, but you just said kinds are a variety of type, so they'd just have kinds themselves...
16:08:21 <brad_larsen> does ($!) involve seq?
16:08:23 <ehird_> like i mentioned
16:08:26 <EvilTerran> ?src ($!)
16:08:26 <lambdabot> Source not found. I feel much better now.
16:08:28 <ehird_> EvilTerran: that's true
16:08:30 <labacathoo> who said it would be calculated twice???
16:08:32 <ehird_> hmm
16:08:33 <dmwit> brad_larsen: yes
16:08:34 <dolio> Some languages have an infinite hierarchy of sorts.
16:08:42 <ehird_> kind polymorphism on ($) would be fun
16:08:48 <ehird_> because of the # kind
16:09:00 <dolio> 2 : Int, Int : Set, Set : Set1, Set1 : Set2, ...
16:09:01 <EvilTerran> ehird_, indeed, if you had turtles all the way down, you'd eliminate the kind/type distinction altogether
16:09:04 <dolio> In Agda.
16:09:13 <ehird_> Yeah
16:09:15 <ehird_> that would be nice
16:09:23 <ehird_> esp. if everything in the typesystem was in the kind system
16:09:29 <ehird_> You could have a mindbending type stack
16:09:39 <brad_larsen> I'm trying to improve the memory usage in my program, hunting space leaks that may or may not exist
16:09:45 <brad_larsen> dmwit: thank you
16:09:52 <EvilTerran> and then you might as well eliminate the type/value distinction as well, and land slap-bang in dependent typing
16:09:55 <lament> dolio: not sure what the point of it is
16:09:56 <ehird_> anyway, is that xml thing that i mentioned existant?
16:10:02 <ehird_> EvilTerran: Nahh, i like values
16:10:33 <lament> dolio: as contrasted with python's: type(2)==int; type(int)==type, type(type)==type
16:10:47 <Dybber> What does this mean: cabal install hstringtemplate --user
16:10:48 <Dybber> cabal: user error (Unresolved dependencies: hstringtemplate -any)
16:10:57 <dolio> lament: That isn't sound.
16:11:14 <ehird_> lament: i hate that
16:11:17 <ehird_> type(X) = X is broken
16:11:18 <augustss> dolio: in python you have other problems
16:11:19 <ehird_> in all cases
16:11:22 <ehird_> that's like having X = [X]
16:11:51 <ehird_> Dybber: capitalize it right
16:11:55 <dmwit> ehird_: I think this depends on your schema, amirite?
16:12:00 <brad_larsen> now, if I put ($!) in between some list operations...
16:12:06 <lament> ehird_: and X = [X] is wrong why?
16:12:08 <augustss> besides type :: type can be sound, it depends on what else you have
16:12:09 <EvilTerran> ehird_, hence agda's trickery with suffixes, i guess
16:12:09 <ehird_> dmwit: Of course. That's why it would be extensible.
16:12:14 <dmwit> ehird_: For example, there is a type-safe HTML/XHTML generator.
16:12:22 <ehird_> dmwit: You could define some instances and shizz and it'd know about it
16:12:24 <brad_larsen> say, for simple example, map (*2) $! filter even [1..100]
16:12:26 <ehird_> XHTML would just be a special case
16:12:30 <Dybber> ehird_: thanks :)
16:12:30 <spx2_> hello
16:12:35 <ehird_> Someone tell lament why (X = [X]) is horribly broken..
16:12:42 <EvilTerran> brad_larsen, $! only forces the outermost constructor
16:12:45 <ehird_> as well as recursive types i ngeneral
16:12:48 <brad_larsen> is the ($!) going to prevent the compiler from inlining the two?
16:12:52 <lament> recursive types are broken?
16:12:54 <dolio> I suppose.
16:12:56 <EvilTerran> so it'll only push your list as far as [] or (_:_)
16:13:07 <brad_larsen> EvilTerran: can you expand?
16:13:12 <EvilTerran> expand?
16:13:15 <augustss> ehird_: it's not horribly broken
16:13:27 <brad_larsen> EvilTerran: tell me more.  I don't quite understand.
16:13:34 <ehird_> listSeq :: [a] -> [a]; listSeq [] = []; listSeq xss@(x:xs) = x `seq` listSeq xs `seq` xss
16:13:38 <dolio> I don't actually have an example of where T : T is a problem, I've just read that it's important for the soundness of certain type systems.
16:13:41 <dolio> Like Coq.
16:13:43 <ehird_> augustss: OK, but it's not wise.
16:13:47 <dolio> Or Agda.
16:14:01 <augustss> ehird_: i agree that it has practical problems
16:14:05 <dmwit> brad_larsen: seq only evaluates things to their first constructor.  For lists, [] and (:) are the constructors.
16:14:11 <EvilTerran> brad_larsen, ok... conventional strictness annotations or whatever (including seq and $!) only force their parameter as far as the first constructor
16:14:17 <ehird_> http://hackage.haskell.org/packages/archive/baskell/ This has rectypes though
16:14:19 <dolio> The lambda cube doesn't seem to have such an infinite hierarchy (it seems to cut off at square), but I'm not sure what's different there.
16:14:19 <lambdabot> Title: Index of /packages/archive/baskell
16:14:21 <ehird_> fun to play with
16:14:27 <brad_larsen> :t ($!)
16:14:28 <EvilTerran> and don't evaluate any of the parameters of the constructor strictly
16:14:28 <lambdabot> forall a b. (a -> b) -> a -> b
16:14:28 <dmwit> brad_larsen: If you want deeper evaluation (i.e. the evaluation of the entire spine, or the evaluation of the spine and all the values), you need to do something sneakier.
16:14:40 <EvilTerran> (except strict parameters, but their part of the type decleration)
16:14:47 <ehird_> @djinn ((->) r)
16:14:47 <lambdabot> Cannot parse command
16:14:52 <dmwit> brad_larsen: There's a module to import to do that kind of thing.
16:14:56 <ehird_> @type \!x -> x
16:14:57 <lambdabot> parse error on input `\!'
16:15:05 <EvilTerran> if you want to force a whole list, there's various ways of doing that in Control.Parallel.Strategies
16:15:10 <ehird_> > let seq !x y = y in undefined `seq` 2
16:15:10 <lambdabot>  Parse error in pattern at "in" (column 18)
16:15:12 <ehird_> hmph
16:15:13 <ehird_> well
16:15:16 <ehird_> seq !a b = b
16:15:18 <ehird_> so there
16:15:21 <labacathoo> if a function uses the same function with the same paramiters multiple times, is the calculation made only once or multiple times?
16:15:30 <brad_larsen> dmwit: i don't think i need a module for that, not yet.  trying to wrap my head around the strictness stuff.
16:15:50 <EvilTerran> brad_larsen, see http://www.haskell.org/ghc/docs/latest/html/libraries/parallel/Control-Parallel-Strategies.html#6 if you've got the stomach for it
16:15:51 <lambdabot> http://tinyurl.com/2acvow
16:15:55 <bos> labacathoo: multiple times
16:15:55 <ehird_> baskell is really fun actually
16:16:03 <ehird_> but you can have the whole lambda calculus in it
16:16:07 <ehird_> lament: Basically the problem is
16:16:10 <ehird_> once you get recursive types
16:16:11 <ahunter> labacathoo: you can let or where bind it to avoid that, though
16:16:16 <ehird_> a = a -> a is everything in the lambda calculus
16:16:21 <ehird_> so strong typing is broken
16:16:25 <bos> labacathoo: the compiler does almost no constant subexpression elimination for you
16:16:30 <labacathoo> ahunter: it is "where" binded
16:16:51 <ahunter> not the function, the application
16:17:05 <bos> if the application of the function is let- or where-bound, it will only be evaluated at most once
16:17:12 <EvilTerran> "... repeated ... repeated ... where repeated = f x
16:17:16 <ehird_> bos: that is NOT specified
16:17:18 <brad_larsen> so in my contrived example, the ($!) is forcing what?  the `map (*2)' and the `filter even [1..100]'?
16:17:23 <EvilTerran> instead of just "... f x ... f x ..."
16:17:24 <ehird_> all that is specified is non-strict evaluation
16:17:45 <ehird_> I want call-by-referenskell
16:17:46 <EvilTerran> brad_larsen, it's forcing the outermost constructor of the list (filter even [1..100])
16:17:46 <ehird_> :)
16:17:52 <ehird_> @name
16:17:52 <lambdabot> Local time for ehird_ is Tue Apr 1 00:17:52 2008
16:17:54 <ehird_> hmmm
16:17:58 <bos> ehird_: i know. in practice, that's what you get.
16:18:00 <ehird_> i wanted the projname generator
16:18:14 <ahunter> ehird_: ghc, at least, produces a single evaluation in that case, iirc (modulo some cases with parallelism and the like)
16:18:32 <EvilTerran> brad_larsen, so before control passes to map, the list expression is evaluated until it becomes apparent whether it's a [] or a (:)
16:18:36 <EvilTerran> but no further
16:19:01 <dmwit> brad_larsen: (Which doesn't buy you very much, in this case.)
16:19:04 <labacathoo> bos + ahunter: thanks
16:19:34 <brad_larsen> EvilTerran: so, at most 1 element in the list in this case
16:19:54 <hpaste>  ArcSin_ annotated "fromIntegral??" with "Instance Integral Double" at http://hpaste.org/6759#a2
16:19:57 <dolio> lament: The general problem people have with recursive types is that they type a lot of typos and such that would have been caught otherwise.
16:20:05 <dolio> At least, from what I've seen.
16:20:07 <dmwit> brad_larsen: No, it doesn't force any elements.
16:20:19 <dmwit> brad_larsen: Well, it forces elements only incidentally by the call to filter.
16:20:55 <dmwit> brad_larsen: For example, (f $! [g 5, g 6]) would not evaluate (g 5) or (g 6) before (f) got called.
16:21:25 <joricj> oh waw, my irc server is really starting to look like it might work
16:21:32 <joricj> i can connect and join channels :D
16:21:40 <dmwit> joricj: Sweet!
16:21:44 * brad_larsen must cogitate...
16:21:56 <ehird_> hmm
16:21:58 <ehird_> POLL:
16:22:04 <ehird_> my `papply` is now ($*)
16:22:14 <ehird_> it's a nicer version of the `par` primitive
16:22:17 <ehird_> based on functions
16:22:18 <ehird_> but:
16:22:22 <ehird_> which is better:
16:22:35 <ehird_> ($*) f a = a `par` f a
16:22:35 <ehird_> OR
16:22:41 <brad_larsen> what about bang patterns?  If I have a function that takes a list as an argument with a bang on it, how far is that list forced?
16:22:44 <ehird_> ($*) f a b = a `par` b `par` f a b
16:22:54 <bos> brad_larsen: same way
16:22:55 <joricj> yeah i'm thrilled actually :D going to keep learning and working on it and rewriting it untill it's perfect
16:22:58 <shachaf> brad_larsen: To the [] or (_:_).
16:23:01 <bos> brad_larsen: just to the first list constructor
16:23:02 <augustss> ehird_: i want them all!
16:23:37 <ahunter> ehird_ can't you get the second one with f $* a $* b?
16:23:43 <ehird_> ahunter: that's what i thought
16:23:44 <ehird_> okay then
16:24:08 <ehird_> what about this:
16:24:19 <ehird_> spike [] = []; spike xss@(x:xs) = x `par` spike xs `par` xss
16:24:22 <ehird_> what should I call that?
16:24:27 <dolio> lament: Like, if you're writing some function "foo base_case = return bar ; foo inductive_case = ... >> foo ...", and you forget the 'return' in the base case, instead of getting an error that will alert you to your mistake, it'll probably have a correct recursive type.
16:24:28 <brad_larsen> and datatypes with strict members?  e.g. we have `data TwoListHolder a = TwoListHolder ![a] ![a]'  Same thing?
16:24:41 <labacathoo> :reload
16:25:12 <ahunter> ehird: I think the last par there isn't useful if I understand correctly
16:25:20 <dmwit> brad_larsen: yes
16:25:27 <dmwit> brad_larsen: It's very consistent. =P
16:25:37 <ehird_> ahunter: why not?
16:25:38 <brad_larsen> dmwit: i'm beginning to see that
16:25:43 <augustss> ahunter: that's right, the last par does nothing
16:25:48 <ehird_> ahunter: it's what makes it work
16:25:53 <ehird_> ahunter: spike should behave like id on lists
16:25:55 <ahunter> ehird: sorry, misread it.  otoh, isn't it still the same as parMap (roughly?)
16:26:02 <brad_larsen> thank you all.  will probably be back later when i'm sure i have a space leak. :-)
16:26:05 <ehird_> ahunter: I don't know, is that in .Strategies?
16:26:16 <ehird_> I don't like C.P.Strategies, it's quite complex
16:26:20 <ahunter> @src parMap
16:26:20 <ehird_> I like simple primitives
16:26:20 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
16:26:21 <ehird_> like $*
16:26:32 <brad_larsen> :t seq
16:26:33 <lambdabot> forall a t. a -> t -> t
16:26:38 <ahunter> ehird_: yeah, it's in c.p.s
16:26:46 * dolio goes to dinner.
16:27:09 <ehird_> actually
16:27:10 <dons> ehird_: its really simple!
16:27:11 <ehird_> with $* and spike
16:27:14 <ehird_> I think parMap could be made
16:27:16 <dons> it just adds `par` and `rnf`
16:27:18 <ahunter> I don't know c.p.s. well at all, so you tell me whether or not it's different, but it seems nominally the same...
16:27:19 <ehird_> dons: but my primitives are nicer :(
16:27:21 <dons> so nice and pure.
16:27:27 <dons> ehird_: where's your library?
16:27:31 <ehird_> dons: ~/
16:27:39 <dons> ok. so it doesn't exist then
16:27:42 <ehird_> its only a few functions right now
16:27:43 <ehird_> :)
16:27:49 <ehird_> $* is pure too
16:27:53 <ehird_> f $* a = a `par` f a
16:27:58 <ehird_> @src ($!)
16:27:58 <lambdabot> Source not found. My mind is going. I can feel it.
16:28:01 <ehird_> hmm
16:28:01 <ehird_> well
16:28:02 <ehird_> :)
16:28:13 <ahunter> OK, now lambdabot is just lying
16:28:18 <dons> i like C.P.S , only about 15 years of reserach went into it, and a very nice paper goes along too
16:28:19 <ehird_> it's to `par` as $! is to `seq`
16:28:27 <ehird_> dons: bah :)
16:28:36 <dons> isn't your $* already defined?
16:28:41 <ehird_> dons: don't think so
16:28:48 <ehird_> but the point is
16:28:51 <ehird_> I use it as a primitive
16:28:53 <ehird_> instead of `par`
16:28:57 <ehird_> since its more useful in most cases
16:28:57 <dons> why is that good?
16:30:03 <dons> isn't that $| ?
16:30:12 <dons> :t (Control.Parallel.$|)
16:30:13 <lambdabot> Not in scope: `Control.Parallel.$|'
16:30:22 <dons> -- | Sequential function application. The argument is evaluated using
16:30:22 <dons> --   the given strategy before it is given to the function.
16:30:22 <dons> ($|) :: (a -> b) -> Strategy a -> a -> b
16:30:23 <dons> f $| s  = \ x -> f x `demanding` s x
16:30:27 <dons> :t $!
16:30:28 <lambdabot> parse error on input `$!'
16:30:31 <dons> :t ($!)
16:30:32 <lambdabot> forall a b. (a -> b) -> a -> b
16:30:41 <dons> -- | Parallel function application. The argument is evaluated using
16:30:41 <dons> -- the given strategy, in parallel with the function application.
16:30:41 <dons> ($||) :: (a -> b) -> Strategy a -> a -> b
16:30:42 <ehird_> YAH well :(
16:30:42 <dons> f $|| s = \ x -> f x `sparking` s x
16:30:43 <dons> or perhaps
16:30:45 <ehird_> i like myyyyy stuff
16:30:46 <ehird_> it
16:30:48 <ehird_> 's cuddly
16:30:53 <dons> isn't it the same?
16:30:56 <dons> just that it doesn't exist?
16:31:16 <ahunter> well, it's the same modulo the whole strategy thing, yes
16:31:16 <ahunter> ?
16:31:16 <ehird_> btw
16:31:17 <ehird_> parMap f xs = map f (spike xs)
16:31:40 <dons> parMap :: Strategy b -> (a -> b) -> [a] -> [b]
16:31:40 <dons> parMap strat f xs = map f xs `using` parList strat
16:31:42 <ahunter> or alternativeyl, isn't spike = parMap id? :P
16:31:48 <ehird_> ahunter: that's true
16:31:49 <dons> so that's got the nice annotating property
16:31:52 <ehird_> which is nicer, though, is the point
16:31:55 <ahunter> which seems like better parallelism
16:32:36 <ehird_> heh
16:32:42 <ehird_> ($*) ($*) == ($*$
16:32:45 <ehird_> :t ($) ($)
16:32:46 <lambdabot> forall a b. (a -> b) -> a -> b
16:32:47 <ehird_> cute
16:33:23 <idnar> :t ($)
16:33:24 <lambdabot> forall a b. (a -> b) -> a -> b
16:33:37 <ehird_> flip ($*) ($*) (const 2)      -- this is '2' but takes a while to get there
16:33:41 <ehird_> slow loops!
16:33:47 <EvilTerran> :t id `asTypeOf` ($)
16:33:48 <lambdabot> forall a b. (a -> b) -> a -> b
16:33:52 <idnar> :t ($*) ($*)
16:33:53 <lambdabot> Not in scope: `$*'
16:33:53 <lambdabot> Not in scope: `$*'
16:33:56 <ehird_> :t asTypeOf
16:33:57 <lambdabot> forall a. a -> a -> a
16:34:09 <ehird_> :t ($) `asTypeOf` id
16:34:10 <lambdabot> forall a b. (a -> b) -> a -> b
16:34:11 <EvilTerran> > f `id` x
16:34:12 <lambdabot>  Add a type signature
16:34:14 <ehird_> @src asTypeOf
16:34:14 <lambdabot> asTypeOf = const
16:34:14 <dmwit> :t asTypeOf id asTypeOf
16:34:15 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
16:34:15 <lambdabot>     Probable cause: `asTypeOf' is applied to too few arguments
16:34:15 <lambdabot>     In the second argument of `asTypeOf', namely `asTypeOf'
16:34:19 <EvilTerran> > f `id` x :: Expr
16:34:20 <lambdabot>  f x
16:34:20 <ehird_> asTypeOf = const
16:34:20 <ehird_> heh
16:34:23 <ehird_> cute
16:34:33 <ehird_> :t asTypeOf `asTypeOf` id
16:34:34 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
16:34:34 <lambdabot>     Probable cause: `id' is applied to too many arguments
16:34:34 <lambdabot>     In the second argument of `asTypeOf', namely `id'
16:34:36 <ehird_> :t asTypeOf `asTypeOf` const id
16:34:36 <brad_larsen> :i par
16:34:37 <lambdabot> forall a. a -> a -> a
16:34:48 <dmwit> ehird_: I think that dates back to before type annotations.
16:34:58 <dmwit> ehird_: asTypeOf was a compiler primitive.
16:35:06 <EvilTerran> f $ x = f x  =>  ($) f x = f x  =>  ($) f = f = id f  =>  ($) = id
16:35:06 <dons> no.
16:35:13 <dons> its just a simple function  :)
16:35:17 <dons> ?src asTypeOf
16:35:17 <lambdabot> asTypeOf = const
16:35:27 <dmwit> Well, the type of "asTypeOf" was primitive, no?
16:35:29 <dons> but it does predate ubiquitous lexically scoped annotations
16:35:35 <dons> no, why would it be.
16:35:37 <dmwit> Without annotations, how else would you get that?
16:35:45 <dons> via the type of asTypeOf
16:35:48 <dons> :t asTypeOf
16:35:48 <lambdabot> forall a. a -> a -> a
16:35:55 <dons> the 'a' constraint
16:35:57 <EvilTerran> dmwit, i seem to recall it's useful where you'd want ScopedTypeVariables
16:36:04 <idnar> :t const
16:36:04 <lambdabot> forall a b. a -> b -> a
16:36:05 <dons> -- | 'asTypeOf' is a type-restricted version of 'const'.  It is usually
16:36:05 <dmwit> > let f = const in f f f
16:36:05 <dons> -- used as an infix operator, and its typing forces its first argument
16:36:05 <dons> -- (which is usually overloaded) to have the same type as the second.
16:36:05 <dons> asTypeOf                :: a -> a -> a
16:36:05 <lambdabot>  Add a type signature
16:36:08 <dons> asTypeOf                =  const
16:36:26 <dons> so unlike const, the second arg has to unify with the first
16:36:26 <ehird_> > const `const` asTypeOf
16:36:26 <lambdabot>  Add a type signature
16:36:28 <ehird_> :t const `const` asTypeOf
16:36:28 <lambdabot> forall a b. a -> b -> a
16:36:32 <ehird_> heh
16:36:32 <dons> but its a noop otherwise
16:36:42 <ehird_> @hoogle (a -> [b]) -> [a] -> [b]
16:36:43 <lambdabot> Prelude.concatMap :: (a -> [b]) -> [a] -> [b]
16:36:43 <lambdabot> Data.List.concatMap :: (a -> [b]) -> [a] -> [b]
16:36:43 <lambdabot> Control.Parallel.Strategies.parFlatMap :: Strategy [b] -> (a -> [b]) -> [a] -> [b]
16:36:52 <ehird_> @hoogle ([a] -> b) -> [a] -> [b]
16:36:52 <lambdabot> No matches, try a more general search
16:36:57 <ehird_> :)
16:36:58 <dmwit> dons: yes... I think we're agreeing very hard here.
16:37:04 <dons> so hard
16:37:05 <ehird_> agreeing ANGRILY
16:37:12 <dons> damn straight!
16:37:19 <EvilTerran> ehird_, that sounds like it might be co-bind in the [] comonad
16:37:31 <ehird_> EvilTerran: comonads scare me
16:37:45 <idnar> they're just like monads
16:37:47 <idnar> except upside-down
16:37:50 <shachaf> EvilTerran: [] is a comonad?
16:38:00 <EvilTerran> i'm guessing here :P
16:38:04 <idnar> wouldn't that be (a, [a])?
16:38:10 <idnar> or... something
16:38:14 <shachaf> Comonad's have coreturn :: [a] -> a
16:38:26 <dmwit> :t \f -> join . map (return . f)
16:38:27 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m) => (a1 -> a) -> m a1 -> m a
16:38:28 <shachaf> So that doesn't make sense.
16:38:39 <shachaf> (Streams are comonads, though.)
16:38:42 <dmwit> oops
16:38:47 <dmwit> :t \f -> join . map (f . return)
16:38:49 <lambdabot> forall a a1 (m :: * -> *) (f :: * -> *). (Functor f, Monad m, Monad f) => (m a1 -> f a) -> f a1 -> f a
16:38:50 <ehird_> wait
16:38:51 <ehird_> wait a second
16:38:56 <ehird_> I think I can specify comonads right here
16:39:02 <EvilTerran> http://hackage.haskell.org/packages/archive/category-extras/0.1/doc/html/Control-Comonad.html declares a Comonad instance for their Stream type, which i thought might work similarly to a list one
16:39:04 <lambdabot> http://tinyurl.com/3bbvta
16:39:05 <ehird_> let's call the comonad m
16:39:08 <ehird_> coreturn :: m a -> a
16:39:13 <ehird_> cobind :: a -> (m a -> b) -> b
16:39:16 <ehird_> am i right?
16:39:23 <ehird_> i actually just guessed that, but it seems right
16:39:24 <idnar> shouldn't it be w?
16:39:24 <shachaf> ehird_: m a -> (m a -> b) -> m b
16:39:26 <EvilTerran> extract :: w a -> a
16:39:28 <EvilTerran> duplicate :: w a -> w (w a)
16:39:28 <EvilTerran> extend :: (w a -> b) -> (w a -> w b)
16:39:34 <ehird_> shachaf: ah, ok
16:39:35 <shachaf> ehird_: In a monad, "wrapping" is easy, "extracting" is hard.
16:39:42 <shachaf> In a comonad, it's the opposite.
16:39:45 <shachaf> (Right?)
16:39:50 <ehird_> I.. think so
16:39:50 <dmwit> Supposedly.
16:39:56 <idnar> cobind :: (w a -> b) -> w a -> w b
16:39:56 <ehird_> What is USEFUL?
16:39:59 <ehird_> about them
16:40:08 <ehird_> I mean, what can I write with them?
16:40:09 <dmwit> Time to pull out sigfpe's blog!
16:40:17 <idnar> @type (>>=)
16:40:17 <ehird_> oh joy
16:40:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:40:21 <ehird_> @type (=<<)
16:40:22 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
16:40:25 <ehird_> oh
16:40:28 <ehird_> @type (<<=)
16:40:28 <idnar> er yeah, that one
16:40:29 <lambdabot> Not in scope: `<<='
16:40:30 <ehird_> @type (>>=)
16:40:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:40:32 <ehird_> bah
16:41:14 <Cale> ehird_: They're a shape which can show up in the combining functions in a combinator library, and in some cases they generalise cellular automata.
16:41:14 <shachaf> ehird_: Cobind is sometimes called (=>>), I think.
16:41:28 <ehird_> @type (=>>)
16:41:28 <lambdabot> Not in scope: `=>>'
16:41:30 <dmwit> http://sigfpe.blogspot.com/2006/12/evaluating-cellular-automata-is.html
16:41:31 <lambdabot> Title: A Neighborhood of Infinity: Evaluating cellular automata is comonadic, http://tinyurl.com/2e55ly
16:41:33 <EvilTerran> check the link i gave above
16:41:37 <EvilTerran> http://tinyurl.com/3bbvta
16:41:37 <Cale> yes, that's a good example
16:42:13 <EvilTerran> stepCell :: Neighbourhood Cell -> Cell
16:42:17 <Cale> hmm, I wonder where I put my proof regarding a large family of similar comonads...
16:42:35 <EvilTerran> instance Comonad Neighbourhood where extract = stepCell -- amirite?
16:43:09 <ehird_> hmm
16:43:12 <ehird_> is there an IO comonad
16:43:13 <ehird_> :D
16:43:20 <idnar> OI? *efg*
16:43:33 <ehird_> idnar: TV uses something called OI to do with IO
16:43:35 <Cale> No, not really.
16:43:41 <ehird_> wonkyPutStr :: OI String -> ()
16:43:42 <ehird_> heh
16:43:46 <Cale> Well, not a safe one.
16:43:49 <idnar> ehird_: no no
16:43:52 <idnar> OI () -> String
16:43:54 <ehird_> Cale: unsafe sounds good :D
16:43:56 <idnar> ehird_: :D
16:43:56 <ehird_> idnar: lmao
16:44:04 <EvilTerran> instance Comonad IO where extract = unsafePerformIO; duplicate = return; extend = (return.) -- do not want
16:44:08 <Cale> You'd have to be able to duplicate the world in order to make it really a comonad.
16:44:08 <ehird_> idnar: getLine :: OI String -> ()
16:44:20 <ehird_> Cale: Well, unsafeInterleaveIO might kind of help
16:44:21 <Cale> that is, arbitrarily many times
16:44:25 <Pseudonym> Cale: I'm not so sure about that.
16:44:25 <Cale> Not quite.
16:44:37 <Pseudonym> I _suspect_ the problem is that functions like getCharOI have the wrong type.
16:44:47 * Pseudonym has put a lot of thought to this lately for some reason
16:45:03 <dmwit> ehird_: wonkyPutStr :: OI () -> String -- =P
16:45:11 <ehird_> dmwit: idnar beat you
16:45:16 <dmwit> oh
16:45:21 <dmwit> Yeah, by quite a lot.
16:45:27 <Pseudonym> contravariantPutStr :: OI () -> String
16:46:07 <EvilTerran> coPutStr?
16:46:13 <EvilTerran> kaputStr?
16:46:36 <ehird_> @type extend
16:46:37 <lambdabot> Not in scope: `extend'
16:46:58 <EvilTerran> ehird_, it's defined in that Control.Comonad module i linked above
16:47:35 <ahunter> OK, I just realized I'm not sure: is it just a convention that types/tycons are capitalized and values aren't, or is the language aware of it?  I thought the language was aware, but I'd think we could get better parsing if that's the case.
16:47:48 <ehird_> ahunter: yes
16:47:51 <ehird_> its aware of it
16:47:57 <ehird_> Abc in type = Abc type
16:48:00 <ehird_> a in type = type variable a
16:48:04 <ehird_> Abc in code = Abc constructor
16:48:06 <ehird_> abc in code = various
16:48:18 <ehird_> $ cabal install category-extras
16:48:18 <ehird_> cabal: user error (Unresolved dependencies: category-extras -any)
16:48:19 <ehird_> mooo
16:48:38 <ehird_> :(
16:49:01 <Saizan> ehird_: cabal update?
16:49:16 <ahunter> ehird_: I'd think that hopefully the parser would be smart enough to deal with something like a function equation "foo Nothing = 0 \n foo Just x = x, instead of needing the parenthezation--my guess, though I admit I'm can't produce a grammar out of my hat, is that recognizing that would be practical
16:49:22 <dmwit> ehird_: Are you on Dvorak?
16:49:45 <ehird_> dmwit: No, but I want to be at some point N
16:49:49 <ehird_> Why?
16:49:50 <Saizan> ahunter: Just could be a singleton constructor
16:49:52 <EvilTerran> ahunter, it's a consistency thing, i guess
16:49:52 <ehird_> my typos?
16:50:03 <dmwit> ehird_: I just thought "mooo" was an odd typo for "booo", yeah.
16:50:09 <ehird_> dmwit: nah, that was on purpose
16:50:17 <dmwit> (And 'm' happens to be next to 'b' on Dvorak.)
16:50:18 <ehird_> i was being a distressed cow
16:50:27 <ArcSin_> Is there anyone out there who may be able to explain why I need to add in instance declaration in
16:50:30 <hpaste>  ArcSin_ pasted "Instance Declaration " at http://hpaste.org/6760
16:50:42 <EvilTerran> ahunter, actually, now i think about it, the parse has to happen before the compiler has information about the arity of constructors
16:51:02 <ehird_> ahunter: It might be pattern matching on Just
16:51:04 <ehird_> even if that makes no sense
16:51:08 <mauke> ArcSin_: you probably just need to fix the error
16:51:19 <ehird_> ahunter: Basically, haskell code is parsed
16:51:22 <ahunter> EvilTerran: true, I suppose, but many languages make "parsing" decisions like that
16:51:23 <ehird_> ahunter: THEN we look at the prelude
16:51:26 <ehird_> and see that Just has one argument
16:51:32 <ehird_> Haskell is already hard enough to parse
16:51:41 <ehird_> ahunter: What if you redefine Just?
16:51:41 <EvilTerran> ahunter, well, we want as simple a language as possible :P
16:51:44 <ehird_> As a zeroadic
16:51:48 <ehird_> It's unpredictable
16:51:48 <ahunter> true :P
16:51:49 <EvilTerran> ?type (^) -- ArcSin_
16:51:50 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
16:51:53 <ehird_> Kind of like the Perl divide-or-regexp stuff
16:52:10 <ehird_> makes code confusing
16:52:11 <EvilTerran> ArcSin_, the second parameter to (^) has to be of an Integral type
16:52:21 <EvilTerran> ?type (**) -- ArcSin_, i think you want this instead
16:52:21 <lambdabot> forall a. (Floating a) => a -> a -> a
16:52:25 <ahunter> ehird_: I buy the simplicity argument.  I was just noting that I think it's decidable in reasonable time, even with arbitrary user-specified constructors.
16:52:36 <ahunter> so, no, I don't care if you redefine just.
16:52:42 <ehird_> ahunter: Sure, but it means a program can be valid in two cases and to different things in both
16:52:44 <ehird_> That is just terrible
16:53:02 <ehird_> @src IO
16:53:02 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
16:53:18 <ehird_> unsafePerformIO (IO a) = snd (a undefined)
16:53:19 <ehird_> :p
16:53:40 <ahunter> ehird_: if you're redefining Just to have different arity, you get what's coming to you :P
16:53:42 <ehird_> oh damn
16:53:47 <ehird_> you'd need a # kind undefined
16:53:55 <EvilTerran> ehird_, you can't have an undefined in an unb- yeah.
16:54:10 <ehird_> :(
16:54:15 <ehird_> EvilTerran: nothing you can do is there :P
16:54:28 <dmwit> > length "oxed type" - length "- yeah."
16:54:29 <lambdabot>  2
16:54:46 <ehird_>     No instance for (Functor OI)
16:54:48 <ehird_> damn :(
16:56:44 <nornagon> itym IO
16:56:57 <ehird_> nornagon: definately not
16:57:03 <ehird_> OI is the IO comonad!
16:57:07 <ehird_> :D
16:57:14 <nornagon> I .. see!
16:57:30 <dmwit> itym epytwen OI
16:58:00 <ehird_> IO newtype myti?
16:58:00 <EvilTerran> dmwit, no fair only counting the "." on one of them :P
16:58:08 <ehird_> newtype OI a = OI (IO a)
16:58:08 <ehird_> :p
16:58:12 <ehird_> hmm
16:58:15 <ehird_> someone write a program using OI!
16:58:17 <dmwit> EvilTerran: good point =)
16:58:18 <ehird_> :D
16:58:43 <EvilTerran> OI think not
16:58:55 <monochrom> @quote IO
16:58:55 <lambdabot> ghc says: Kind signature on data type declaration has non-* return kind
16:59:05 <monochrom> @quote IO
16:59:05 <lambdabot> osfameron says: hombre!  functional programming, he tiring!
16:59:10 <ehird_> @quote OI
16:59:11 <lambdabot> monochrom says: All numbers just sit there doing nothing.
16:59:16 <ehird_> @quote OI
16:59:16 <lambdabot> dibblego says: I'm glad I googled it before going to see the doctor
16:59:18 <ehird_> @quote OI
16:59:18 <lambdabot> vincenz says: Does a cow have least-fixed-point-nature?
16:59:20 <ehird_> bah
16:59:25 <EvilTerran> ?quote \<IO\?
16:59:25 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
16:59:29 <EvilTerran> ?quote \<IO\>
16:59:29 <lambdabot> ricky_clarkson says: I think IO should be called Kansas.
16:59:32 <monochrom> I don't understand how to use @quote
16:59:34 <EvilTerran> even
16:59:39 <dmwit> ?quote \CIO
16:59:39 <lambdabot> stepcut says: endo-hylo-cata-ana-expi-ali-docious
16:59:45 <EvilTerran> monochrom, they're POSIX regexes
16:59:48 <ehird_> @quote \<OI\>
16:59:48 <lambdabot> johnnowak says: Oi I need a break. I just tried to read 'Oxford' as a hexidecimal.
16:59:49 <EvilTerran> ?quote \<OI\>
16:59:49 <lambdabot> johnnowak says: Oi I need a break. I just tried to read 'Oxford' as a hexidecimal.
16:59:52 <ehird_> @quote \<OI\>
16:59:52 <lambdabot> johnnowak says: Oi I need a break. I just tried to read 'Oxford' as a hexidecimal.
16:59:54 <monochrom> @quote IO,
16:59:54 <lambdabot> chessguy says: dolio, hyperbole is the worst form of linguistic expression ever invented
16:59:54 <ehird_> hah
17:00:00 <monochrom> @quote IO,\ IO
17:00:00 <lambdabot> No quotes for this person. BOB says:  You seem to have forgotten your passwd, enter another!
17:00:08 <chessguy> eh?
17:00:08 <ehird_> instance Monad DolIO
17:00:15 <dmwit> ?quote IO,.IO
17:00:15 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
17:00:16 <monochrom> haha
17:00:36 <ArcSin__> > let c=1; d=2; e=3   in (1 + ((d*0.01)/e))^(c*d)
17:00:37 <lambdabot>  1.0133777777777777
17:00:45 * ehird_ is trying to do putStrOI
17:00:50 <ehird_> putStrOI :: OI () -> String
17:00:53 <ehird_> this may take a while
17:00:54 <ehird_> :d
17:00:55 <EvilTerran> > e -- your value for e is wrong
17:00:56 <lambdabot>  e
17:01:05 <EvilTerran> huh
17:01:05 <EvilTerran> > exp 1
17:01:06 <lambdabot>  2.718281828459045
17:01:08 <ehird_> haha
17:01:11 <EvilTerran> :P
17:01:14 <ehird_> > a
17:01:14 <lambdabot>  a
17:01:18 <ehird_> > exp e
17:01:18 <lambdabot>  exp e
17:01:21 <EvilTerran> damn those rounding errors, eh ;)
17:01:26 <ehird_> haha
17:01:28 <ehird_> actually
17:01:30 <ehird_> its very precise
17:01:33 <ehird_> e = e
17:01:36 <ehird_> no lossage at all
17:01:38 <EvilTerran> > (f &&& g) x :: Exp
17:01:38 <lambdabot>   Not in scope: type constructor or class `Exp'
17:01:40 <monochrom> foldl1 f [a,b,c,d,e]
17:01:42 <mauke> > (sin e)^2
17:01:42 <lambdabot>  sin e * sin e
17:01:43 <monochrom> > foldl1 f [a,b,c,d,e]
17:01:44 <lambdabot>  f (f (f (f a b) c) d) e
17:01:44 <dmwit> I don't think \<\> is  POSIX.
17:01:58 <ehird_> > iterate f f
17:01:59 <lambdabot>  Add a type signature
17:02:02 <EvilTerran> > (f &&& g) x :: Expr
17:02:02 <lambdabot>  Couldn't match expected type `Expr' against inferred type `(c, c')'
17:02:07 <ehird_> [] should be a typeclass
17:02:07 <ehird_> :-P
17:02:18 <ehird_> > iterate (f :: a -> b) (f :: [a])
17:02:19 <lambdabot>        add (SimpleReflect.FromExpr [a]) to the context of
17:02:19 <lambdabot>         the polymor...
17:02:22 <EvilTerran> dmwit, well, it's most definitely not PCRE, so i figured it was POSIX. i may be wrong.
17:02:25 <ehird_> > let f = undefined in iterate (f :: a -> b) (f :: [a])
17:02:25 <lambdabot>  Undefined
17:02:29 <shachaf> > (f &&& g) :: (Expr,Expr)
17:02:30 <lambdabot>  Couldn't match expected type `Expr' against inferred type `(c, c')'
17:02:31 <EvilTerran> > fix f
17:02:31 <lambdabot>  Add a type signature
17:02:32 <ehird_> > iterate undefined undefined
17:02:33 <lambdabot>  Undefined
17:02:36 <ehird_> > fix iterate
17:02:37 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
17:02:37 <lambdabot>       Expected...
17:02:37 <shachaf> > (f &&& g) x :: (Expr,Expr)
17:02:38 <lambdabot>  (f x,g x)
17:02:40 <EvilTerran> > fix f :: Expr
17:02:41 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
17:02:49 <ehird_> expr is such fun
17:02:51 <ahunter> Ok, I'm stupid: what's the right way to write this: Just x <- y `mplus` (Just default)
17:02:52 <EvilTerran> > iterate f f :: Expr
17:02:52 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
17:02:55 <ehird_> > f fix :: Expr
17:02:55 <lambdabot>  Add a type signature
17:02:58 <EvilTerran> > iterate f f :: [Expr]
17:02:59 <lambdabot>  [f,f f,f (f f),f (f (f f)),f (f (f (f f))),f (f (f (f (f f)))),f (f (f (f (f...
17:03:12 <ehird_> > iterate f f f f f :: [Expr]
17:03:13 <lambdabot>  Couldn't match expected type `a -> a1 -> a2 -> [Expr]'
17:03:15 <Saizan> ahunter: omit the first Just
17:03:39 <ahunter> Saizan: I want to pattern match against the contents.
17:03:48 <EvilTerran> ahunter, if you don't want to be using Maybe as a monad, "fromMaybe default y" is also good
17:03:51 <dmwit> ahunter: fromMaybe
17:03:53 <ahunter> that is, I want type Maybe a -> a -> a
17:03:56 <ahunter> ah
17:03:57 <monochrom> What's wrong with  Just x <- y `mplus` (Just default)  ?
17:03:57 <ahunter> ok, thx
17:03:59 <EvilTerran> ?index fromMaybe
17:03:59 <lambdabot> Data.Maybe
17:04:05 <Pseudonym> > fix f :: Expr
17:04:06 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
17:04:06 <dobblego> ?hoogle Maybe a -> a -> a
17:04:07 <lambdabot> Data.Maybe.fromMaybe :: a -> Maybe a -> a
17:04:07 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
17:04:07 <lambdabot> Data.Maybe.maybe :: b -> (a -> b) -> Maybe a -> b
17:04:42 <mauke> :t do { Just x <- ?y `mplus` Just ?default; return x }
17:04:43 <lambdabot> forall t. (?default::Maybe t, ?y::Maybe (Maybe t)) => Maybe t
17:04:47 <shachaf> @let asE :: Expr -> Expr; asE = id
17:04:47 <lambdabot> Defined.
17:04:49 <dmwit> :t \x -> maybe x id
17:04:50 <lambdabot> forall a. a -> Maybe a -> a
17:04:53 <shachaf> > asE $ fix f
17:04:53 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
17:05:09 <shachaf> @ty fromMaybe
17:05:10 <lambdabot> forall a. a -> Maybe a -> a
17:05:13 <mauke> :t do { Just x <- ?y `mplus` Just ?default; x }
17:05:14 <lambdabot> forall t. (?default::Maybe (Maybe t), ?y::Maybe (Maybe (Maybe t))) => Maybe t
17:05:19 <dmwit> mauke: It's a case, not a do?
17:05:25 <dmwit> oh
17:06:14 <BahamutX> Hi, im a new user to haskell. I have a .hs file that I found in a document but it won't work. If someone could come in private and help me, it would be really appreciated :)
17:06:23 <ArcSin__> > let c=1; d=2; e=3  in (((1 + ((d*0.01)/e))^(c*d)))
17:06:23 <lambdabot>  1.0133777777777777
17:06:41 <dobblego> BahamutX, why private? just ask your question
17:06:50 <mauke> > let c=1; d=2; e=3  in (((1 + ((d*0.01)/e))^(c*d))) :: Rational
17:06:51 <lambdabot>  22801%22500
17:06:54 <ArcSin__> let c=1; d=2; e=3 in (replicate (floor c) ((1 + ((d*0.01)/e))^(c*d)))
17:07:02 <BahamutX> just because i'd feel it would be complex, but maybe it isnt... lemme see
17:07:08 <shachaf> BahamutX: Could you @paste it?
17:07:10 <shachaf> @paste
17:07:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:07:22 <BahamutX> the whole file?
17:07:28 <BahamutX> or the erronous line?
17:07:35 <ehird_> whole
17:07:37 <Pseudonym> How big is the file?
17:07:38 <shachaf> BahamutX: Either, depending on how big it is. :-)
17:07:40 <dobblego> how about the error message too?
17:07:43 <BahamutX> 17 line
17:07:48 <Pseudonym> 17 line is fine.
17:07:52 <Pseudonym> Paste the error message too.
17:07:53 <joricj> getting a list from a Data.Map, is that blazingly fast? will the list be sorted?
17:07:57 <shachaf> @@ Sure, @paste the file and the message.
17:07:57 <lambdabot>  Sure, Haskell pastebin: http://hpaste.org/new
17:07:58 <Pseudonym> If it was 200 lines, we might be in trouble.
17:07:58 <BahamutX> its an undefined variable
17:08:05 <BahamutX> ok, here comes the file
17:08:24 <BahamutX> -- brit2dice.hs
17:08:29 <BahamutX> mmm, bad paste
17:08:36 <Pseudonym> @paste
17:08:36 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:08:39 <Pseudonym> You saw that, right?
17:08:50 <Pseudonym> It announces in this channel when you paste.
17:09:16 <ahunter> @src assert
17:09:16 <lambdabot> Source not found. I've seen penguins that can type better than that.
17:09:28 <hpaste>  (anonymous) pasted "Brit2dice" at http://hpaste.org/6761
17:09:41 <mauke> that code looks bad
17:09:43 <dons> assert :: Bool -> a -> a
17:09:43 <dons> assert pred r = r
17:09:59 <BahamutX> that brit2dice was mine
17:10:12 <dons> ahunter: its actually in GHC.Prim (primitive)
17:10:13 <Pseudonym> mauke: It's not as bad as it looks, I suspect.
17:10:23 <Pseudonym> I think it's mostly the tuples that make it hard to read.
17:10:27 <ehird_> BahamutX was about to paste the whole file
17:10:30 <ehird_> xD XD XD
17:10:34 <BahamutX> error at line 17 : undefined variable "fromInt"
17:10:44 <ehird_> BahamutX: no such thing as fromInt
17:10:52 <BahamutX> I changed while trying it
17:10:55 <shachaf> BahamutX: You probably mean fromIntegral.
17:10:59 <ehird_> that code
17:11:00 <mauke> Pseudonym: I'm pretty sure it is
17:11:01 <ehird_> is horrific
17:11:01 <BahamutX> but it should befromInt, not fromDouble
17:11:14 <Pseudonym> BahamutX: First comment about style.
17:11:18 <ehird_> yeah
17:11:20 <BahamutX> its not MY code :P
17:11:20 <Pseudonym> You're overusing tuples big time.
17:11:21 <ehird_> f(a,b,c,)
17:11:23 <ehird_> totally crap
17:11:26 <Pseudonym> Yeah.
17:11:26 <ehird_> :/
17:11:28 <ehird_> never seen code like that
17:11:30 <ehird_> horrific
17:11:36 <ehird_> whoever wrote it knows little haskell :)
17:11:37 <Pseudonym> OK, if it's not your code, you are forgiven. :-)
17:11:40 <ehird_> looks like an ocaml reject actually
17:11:41 <shachaf> <BahamutX> Hi, im a new user to haskell. I have a .hs file that I found in a document but it won't work. If someone could come in private and help me, it would be really appreciated :)
17:11:51 <ehird_> functional ocaml
17:12:16 <Pseudonym> shachaf: There's no shame in trying to understand someone else's code as an aid to learning.
17:12:29 <Pseudonym> It's unfortunate when the code that you're trying to understand is crap.
17:12:30 <shachaf> Pseudonym: ?
17:12:39 <shachaf> Pseudonym: I meant the "found in a document".
17:12:43 <BahamutX> it don't want to understand it as much as using it
17:12:43 <Pseudonym> Ah, right.
17:12:58 <dons> ehird_: you shouldn't talk like that to newbies
17:13:13 <BahamutX> document is http://pulsiphergames.com/sweepofhistory/britdice.pdf
17:13:16 <dons> "17:11  ehird_> totally crap" is unacceptable
17:13:29 <Pseudonym> dons: To be fair, he's talking about the person who wrote the code, who almost certainly isn't here.
17:13:34 <ehird_> dons: wasn't talking to the newbie
17:13:37 <ehird_> i knew it wasn't his code
17:13:39 <ehird_> i was talking to the code
17:13:43 <Pseudonym> But yes, this is a time for constructive criticism.
17:13:48 <BahamutX> you pick on code... come on ;)
17:13:50 <ehird_> :/
17:13:59 <dons> still, that's not ok. we've a channel philosophy about not behaving like that
17:14:06 * Pseudonym nods
17:14:09 <dobblego> BahamutX, programmers have a hard time detaching self-worth from code
17:14:17 <EvilTerran> ... that philosophy's sure been coming up a lot recently
17:14:18 <mauke> from 2005 ... impressive
17:14:19 <BahamutX> hehe, that I know
17:14:24 <ahunter> @pl f x = g (h x)
17:14:25 <lambdabot> f = g . h
17:14:26 <sethk> dons, right, and anybody who doesn't follow the code is a      hmm.    wait, that might not follow the code either  :)
17:14:35 <EvilTerran> maybe we should put "be nice" in the topic
17:14:45 <dons> it shouldn't come to that.
17:14:49 * EvilTerran goes to bed
17:14:54 <dons> the culture is self selecting, and correcting
17:14:56 <BahamutX> im using Hugs by the way, if it matters about anything
17:15:04 <dons> if anyone's in doubt about how the channel was organised, see http://haskell.org/haskellwiki/IRC_channel#Principles
17:15:06 <lambdabot> Title: IRC channel - HaskellWiki
17:15:14 <Pseudonym> BahamutX: There is only one place where that matters, and that's the quality of your error messages.
17:15:20 <dons> the goal is to be overwhelmingly friendly.
17:15:23 <shachaf> BahamutX: That @paste compiles, by the way, if you just change fromDouble to fromIntegral.
17:15:24 <Pseudonym> Most people find Hugs error messages slightly unhelpful in some circumstances.
17:15:27 <BahamutX> ok
17:15:29 <sethk> dons, and it's appreciated
17:15:34 <dons> n.b "Low to zero tolerance for ridiculing"
17:15:48 <Pseudonym> BTW, it probably also compiles if you do the following:
17:15:53 <Pseudonym> 1. Remove the fromDouble call
17:15:56 <BahamutX> basically I want to use the program to calculate dice statistic for this game
17:15:59 <Pseudonym> 2. Replace the / with %
17:16:05 <Pseudonym> 3. import Rational
17:16:10 <Pseudonym> Or Data.Ratio or whatever.
17:16:13 <ehird_> i only criticize ideas & code
17:16:16 <ehird_> not people
17:16:29 <ehird_> i had already seen him saying the code was not his
17:16:29 <Pseudonym> And that has the benefit that it'll give you an exact answer.
17:16:33 <ehird_> and it was merely very bad
17:16:59 <sethk> ehird_, it's simpler to just be a bit less strong in the language, then you don't have to explain why it was ok
17:17:06 <BahamutX> do I remove the ( ) with the fromDouble which was a fromInt?
17:17:17 <BahamutX> guessing so but making sure
17:17:23 <Pseudonym> BahamutX: Whose solution are you trying?
17:17:27 <glen_quagmire> > fromDouble 0.345
17:17:27 <lambdabot>   Not in scope: `fromDouble'
17:17:39 <shachaf> There is no fromDouble.
17:17:42 <Pseudonym> You don't _have_ to remove the parenthesis in the sense that it'll still work.
17:17:51 <BahamutX> ok, what I thought
17:17:52 <Pseudonym> But it's considered bad style to leave it in.
17:17:54 <shachaf> BahamutX: What if you just change the "fromDouble" to a "fromIntegral"?
17:18:11 <Pseudonym> shachaf: Then the code will still require improvement.
17:18:36 <shachaf> Pseudonym: That's true.
17:18:49 <dmwit> I think the code was probably written to resemble as closely as possible the math equations above, even down to syntax and variable names.
17:18:51 <BahamutX> seems to work with the fromIntegral, I got a Main>
17:19:10 <dmwit> This doesn't necessarily mean that this style is a good one to emulate on your own, though.  =)
17:19:22 <BahamutX> from there I just call the function with the parameters I guess?
17:19:29 <dmwit> yep
17:19:36 <shachaf> BahamutX: Parameter.
17:19:55 <shachaf> BahamutX: That function only has one argument, which is a tuple.
17:20:12 <BahamutX> doesnt p0 takes like 6 arguments?
17:20:19 <Pseudonym> The thing that surprises me about this code is that it uses bizarre guard structure and tuples everywhere, but there is a memoising CAF.
17:20:32 <glen_quagmire> does haskell have casting operator along typeclass hierarchy?
17:20:33 <shachaf> BahamutX: It takes one argument, which holds 6 values.
17:20:47 <dmwit> glen_quagmire: Data.Dynamic is the closest.
17:20:50 <Pseudonym> BahamutX: The one argument is a six-element tuple.
17:20:54 <dmwit> glen_quagmire: (Which does no casts, in fact.)
17:20:57 <shachaf> BahamutX: The standard way to define it, in Haskell, would be "f a1 a2 a3 a4 a5 a6".
17:21:06 <shachaf> (That's still one argument, but never mind that. :-) )
17:21:16 <dmwit> glen_quagmire: So... no, not really.  Everything is very explicit.
17:21:19 <BahamutX> ok cool, got the thing to work
17:21:20 <BahamutX> :)
17:21:24 <BahamutX> thanks a lot folks
17:21:38 <shachaf> BahamutX: It still needs improvement, as Pseudonym said.
17:21:50 <shachaf> BahamutX: Did you get it from a public document?
17:21:54 <BahamutX> yeah
17:22:00 <BahamutX> I just want to use it to calculate stuff
17:22:04 <shachaf> BahamutX: Where is that?
17:22:06 <BahamutX> and then im done with the code so
17:22:10 <dmwit> He pasted the link above.
17:22:16 <BahamutX> http://pulsiphergames.com/sweepofhistory/britdice.pdf
17:22:24 <shachaf> Oh.
17:22:26 * shachaf missed that.
17:23:53 <BahamutX> *waves*
17:24:15 <ehird_> grr, I want a type repl
17:24:16 <MarcWeber> @seen beschmi
17:24:16 <lambdabot> I haven't seen beschmi.
17:24:20 <ehird_> :t shows the kind
17:24:20 <lambdabot> Not in scope: `the'
17:24:20 <lambdabot> Not in scope: `kind'
17:24:26 <ehird_> and I can expand out 'type's
17:24:29 <ehird_> :(
17:24:57 <dmwit> ehird_: It sometimes helps to implement some (faulty) functions as "undefined" temporarily.
17:25:00 <Staz> cool, my "Haskell School of Expression" book finally arrived in the mail :)
17:25:12 <dmwit> ehird_: That at least lets things type-check, and you can see what GHC thinks of your types.
17:25:19 <ehird_> dmwit: I still want a type REPL, for type plays
17:25:26 <ehird_> dmwit: I'm defining a lot of Prelude functions in the type system
17:26:42 <ehird_> 'fix' is a bit hard. ;)
17:27:44 <joricj> if i have an array of strings, which do not contrain newlines, how can i read and write them to file?
17:27:52 <hpaste>  Pseudonym annotated "Brit2dice" with "Slightly better code" at http://hpaste.org/6761#a1
17:28:05 <dmwit> joricj: Actually an array, or just a list?
17:28:07 <dmwit> :t unlines
17:28:08 <lambdabot> [String] -> String
17:28:18 <joricj> a list :D
17:28:34 <joricj> :t lines
17:28:35 <lambdabot> String -> [String]
17:28:38 <joricj> awesome
17:28:40 <dmwit> joricj: unlines will put in newlines, concat will not.
17:28:53 <joricj> how do i handle the reading and writing to file part?
17:29:02 <ehird_> there's type system lists
17:29:06 <ehird_> err
17:29:09 <ehird_> type system numbers
17:29:11 <joricj> (i think most if not all my code is in IO)
17:29:11 <ehird_> is ther any type system lists?
17:29:12 <dmwit> :t fPutStr
17:29:13 <lambdabot> Not in scope: `fPutStr'
17:29:17 <dmwit> :t hPutStr
17:29:17 <lambdabot> Not in scope: `hPutStr'
17:29:18 <mauke> :t writeFile
17:29:19 <lambdabot> FilePath -> String -> IO ()
17:29:19 <Pseudonym> The code would be further improved by using better names than "qa" and "qd".
17:29:23 <mauke> :t readFile
17:29:23 <lambdabot> FilePath -> IO String
17:29:30 <dmwit> Yeah, those are more convenient.
17:29:39 <joricj> wow that's so awesome
17:29:44 <joricj> thx guys
17:29:55 <ehird_> :/
17:30:05 <joricj> if the file doesn't exist, does it return [] or an error?
17:30:21 <joricj> or throw an error
17:30:31 <dmwit> It throws an exception for reads, creates the file for writes.
17:30:46 <joricj> how do i catch and transform the exception into a []?
17:30:54 <dmwit> :t catch -- maybe?
17:30:55 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
17:31:09 <ehird_> i guess not
17:31:12 <mauke> readFile "foo" `catch` (\_ -> return [])
17:31:33 <joricj> i'm familiar with exceptions in general (scheme, c++), but this is my first time in haskell :D
17:31:40 <joricj> thx mauke
17:32:00 <mauke> catch takes two arguments, a code block and an exception handler
17:32:38 <joricj> ah, i can see how that works
17:32:45 <joricj> it's a monad, no?
17:32:51 <dmwit> hum
17:32:52 <mauke> what, IO? yes
17:33:24 <joricj> yes, well ... the way that the exception is thrown etc the way it works, it has to do with monads, no?
17:33:29 <Saizan> ehird_: sure, data Cons a b; data Nil
17:33:34 <mauke> not really
17:33:39 <joricj> hmm
17:34:02 <Saizan> ehird_: as for fix you can have data Mu f = f (Mu f)
17:34:19 <Saizan> err, with a constructor
17:34:21 <mauke> it has to do with how >>= is implemented, which belongs to the monad interface
17:34:22 <ehird_> Saizan: yeah
17:34:32 <ehird_> you want:
17:34:34 <ehird_> Fix :: forall a. (a -> a) -> a
17:34:40 <ehird_> but you can only have:
17:34:41 <ehird_> Fix :: forall a. (Fix a -> b) -> Fix a
17:34:48 <ehird_> err, add b to that forall
17:35:24 <ehird_> i think that's right at leas
17:35:25 <ehird_> t
17:38:48 <ehird_> hmm
17:38:54 <ehird_> i think i've done the 'main' things that operate just on functions
17:39:08 <ehird_> Id,App,O,O2,Flip,Fix
17:39:13 <ehird_> i don't think much else is useful in the type system
17:40:54 <ehird_> hm
17:40:59 <ehird_> Fix can't be used with type synonyms
17:41:07 <ehird_> why can't you partially apply them. damn stupid
17:41:09 <ehird_> :(
17:41:45 <ahunter> @pl f x a b= g (h x) a (k x) b
17:41:45 <lambdabot> f = ap (flip . g . h) k
17:41:52 <ahunter> @type ap
17:41:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:42:47 <joricj> how can i catch a ctrl^c thrown to my program, and have it execute some code (writeChan hub "archive") and gracefully shutdown?
17:43:02 <mauke> set a signal handler for SIGINT
17:43:16 <mauke> or keyboardInterrupt or whatever it's called in haskell
17:43:45 <Pseudonym> @type app
17:43:46 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
17:43:47 <joricj> thx, google will show the rest :D
17:44:52 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Signals.html
17:44:54 <lambdabot> http://tinyurl.com/34y959
17:45:16 <joricj> a global variable is somethings like "hub = unsafePerformIO newChan", no?
17:45:34 <joricj> http://therning.org/magnus/archives/285 <- i found this to be helpful
17:45:35 <lambdabot> Title: therning.org/ magnus » Blog Archive » Signals in Haskell
17:45:37 <gwern> @undo selectSearchBrowser engine  = do browser <- getBrowser; selectSearch browser engine
17:45:37 <lambdabot> selectSearchBrowser engine = getBrowser >>= \ browser -> selectSearch browser engine
17:46:29 <gwern> @pl selectSearchBrowser engine = getBrowser >>= \ browser -> selectSearch browser engine
17:46:29 <lambdabot> selectSearchBrowser = (getBrowser >>=) . flip selectSearch
17:46:55 <gwern> @undo selectSearchBrowser engine  = do browser <- getBrowser; selectSearch engine browser
17:46:55 <lambdabot> selectSearchBrowser engine = getBrowser >>= \ browser -> selectSearch engine browser
17:47:26 <gwern> @pl selectSearchBrowser engine = getBrowser >>= \ browser -> selectSearch engine browse
17:47:26 <lambdabot> selectSearchBrowser = (getBrowser >>=) . const . flip selectSearch browse
17:47:50 <gwern> that's even worse >.<
17:52:06 <augustss> @pl selectSearchBrowser engine = getBrowser >>= \ browser -> selectSearch engine browser
17:52:06 <lambdabot> selectSearchBrowser = (getBrowser >>=) . selectSearch
17:53:25 <joricj> <interactive>: Control.Concurrent.STM.atomically was nested <--- is that a bad thing?
17:53:28 <ahunter> @djinn (a -> Bool) -> [a]  -> Bool
17:53:28 <lambdabot> f _ _ = False
17:54:05 <mauke> joricj: yes
17:54:53 <joricj> damnit
17:55:10 <joricj> omg how am i going to track this down
17:55:52 <mauke> how did you manage to nest atomically? the type system should prevent that
17:56:44 <joricj> i don't know
17:56:57 <joricj> i'm gonna see, maybe it works :D
17:57:25 <joricj> hrm
17:57:27 <joricj> guess not
17:59:25 <siponen> Hmm... Am I imagining things or has this community quadrupled since I last was here...
17:59:42 <siponen> (Some weeks ago that is)
17:59:54 <shachaf> siponen: Each person here split into four.
18:00:07 <shachaf> We're like bacteria.
18:00:36 <siponen> But the nice kind? The ones that help you digest things?
18:00:59 <shachaf> siponen: Most people here, yes.
18:01:14 <siponen> haskellofilus-B
18:01:14 <shachaf> And some others make things for you to digest. :-)
18:01:21 <mauke> @lusers
18:01:22 <lambdabot> Maximum users seen in #haskell: 483, currently: 430 (89.0%), active: 14 (3.3%)
18:01:23 <lament> we help you digest things by making your head explode!
18:06:05 <TomMD> I certainly don't help people digest things - infact, I'm beginning to think I'm the opposite.
18:06:15 <mauke> laxative?
18:06:41 <gwern> @undo promptSearch config engine = do browser <- liftIO getBrowser; promptSearchBrowser config browser engine
18:06:41 <lambdabot> promptSearch config engine = liftIO getBrowser >>= \ browser -> promptSearchBrowser config browser engine
18:07:00 <gwern> @pl  promptSearch config engine = liftIO getBrowser >>= \ browser -> promptSearchBrowser config browser engine
18:07:00 <lambdabot> promptSearch = ((liftIO getBrowser >>=) .) . flip . promptSearchBrowser
18:07:04 <TomMD> mauke: No, I'm more like the bone in the samon you ate last night ;-)
18:10:07 <joricj> aha i fixed it i think
18:12:12 <siponen> Are list comprensions good or bad? Atleast they invite me to write everything inside them so I can think of writing for-loops :)
18:12:55 <dobblego> siponen, thinking in terms of for-loops is bad
18:13:42 <ddarius> I tend not to use list comprehensions.
18:14:02 <mauke> dobblego: why?
18:14:35 <dobblego> mauke, because it implies imperative code, which deviates from the actual requirement
18:15:03 <mauke> could be a pure for-loop
18:15:10 <dobblego> no such thing
18:15:41 <mauke> (loop for i from 0 to 9 collecting (* i i))
18:15:47 <hpaste>  yoshi pasted "In Desperate Need of Assistance.." at http://hpaste.org/6762
18:15:55 <dobblego> ok, your definition is broader than the one I was using :)
18:16:10 <joricj> a haskell program ends when the "main" thread ends, right? even if child threads are still running?
18:16:14 <dobblego> oh wait, that's not pure anyway
18:16:18 <mauke> yoshi: you're still using ^
18:16:20 <ddarius> > map (join (*)) [0..9]
18:16:21 <lambdabot>  [0,1,4,9,16,25,36,49,64,81]
18:16:24 <dobblego> that is
18:16:51 <nornagon> > let for = flip map in for [0..9] (\i -> i * i)
18:16:52 <lambdabot>  [0,1,4,9,16,25,36,49,64,81]
18:17:10 <yoshi> mauke, yes, there doubles. I want to square them...?
18:17:28 <mauke> yoshi: c*d doesn't look like 2
18:17:28 <nornagon> :t (^)
18:17:29 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
18:17:35 <nornagon> :t (**)
18:17:35 <lambdabot> forall a. (Floating a) => a -> a -> a
18:17:37 <nornagon> :t (^^)
18:17:38 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
18:17:52 <dmwit> ?instances Fractional
18:17:52 <lambdabot> Double, Float
18:18:01 <nornagon> ?instances Floating
18:18:01 <lambdabot> Double, Float
18:18:02 <lament> ooh, ?instances
18:18:14 <nornagon> you probably want **
18:18:14 <lament> ?instances Functor
18:18:14 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
18:18:25 <dmwit> What does (^^) do?
18:18:42 <nornagon> @src (^^)
18:18:42 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
18:18:46 <mauke> same as ^ but allows negative exponents
18:18:51 <dmwit> ah
18:18:54 <lament> how come so few functor instances?
18:19:06 <mauke> > x ^^ (-3)
18:19:07 <lambdabot>  recip (x * x * x)
18:19:11 <nornagon> lament: doesn't look like a few to me
18:19:18 <nornagon> @src (^)
18:19:18 <lambdabot> Source not found.
18:19:20 <lament> where's all the data structures?
18:19:38 <ddarius> @instances-importing Data.Tree Functor
18:19:39 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Tree, Writer w, WriterT w m, []
18:19:48 <lament> oh
18:20:24 <siponen> @src (^_^)
18:20:24 <lambdabot> Source not found.
18:20:30 <siponen> :(
18:20:48 <siponen> It doesn't do anime-smileys yet?
18:21:02 <lament> it's included in next version of ghc
18:22:17 <yoshi> mauke; Can haskell not make an implicit substitution of the Doubles c & d into into (c*d)? Plus (c*d) is in parentheses, shouldn't it have higher order?
18:22:36 <mauke> yoshi: what does that have to do with squaring?
18:23:48 <yoshi> mauke, (c*d) = some number, so (....)^(c*d) or (....)^(a number)
18:23:59 <yoshi> is a number
18:24:20 <mauke> squaring is multiplying something by itself
18:26:38 <yoshi> yeah, and if (c*d) was 2 then thats exactly what would happen..
18:26:57 <mauke> not quite
18:27:07 <mauke> because it doesn't compile, because you're using ^
18:27:49 <yoshi> I still don't get why that is..
18:28:23 <mauke> because ^ requires its right operand to be an integer
18:28:28 <mauke> c and d are doubles
18:28:35 <yoshi> > 2^3
18:28:36 <lambdabot>  8
18:28:55 <yoshi> let x=2; y=3 in x^y
18:28:58 <Saizan> > 2^(3::Double)
18:28:58 <lambdabot>   add an instance declaration for (Integral Double)
18:28:58 <lambdabot>     In the expression: 2 ...
18:29:01 <mauke> > 2^3.5
18:29:01 <lambdabot>  Add a type signature
18:30:17 <yoshi> let x=2; y=3 in x^(fromIntegral y)
18:30:25 <yoshi> > let x=2; y=3 in x^(fromIntegral y)
18:30:26 <lambdabot>  8
18:30:31 <yoshi> > let x=2; y=3 in x^(y)
18:30:32 <lambdabot>  8
18:30:37 <yoshi> i don't get it?
18:31:12 <mauke> get what?
18:32:14 <yoshi> wait: why cant I have a fraction in the exponent?
18:32:32 <mauke> because then ^ wouldn't work for any numeric type
18:32:36 <yoshi> > 2^(1/2) == sqrt 2
18:32:36 <lambdabot>  Add a type signature
18:32:49 <Igloo> You probably want (**)
18:32:49 <lambdabot> Igloo: You have 1 new message. '/msg lambdabot @messages' to read it.
18:33:09 <TSC> > 2 ** 0.5
18:33:09 <lambdabot>  1.4142135623730951
18:33:17 <SamB> yoshi: have you ever tried to use sqrt at an integral type?
18:33:19 <mauke> > 2**(1/2)
18:33:19 <lambdabot>  1.4142135623730951
18:33:38 <mauke> > sqrt (length "hi")
18:33:39 <lambdabot>   add an instance declaration for (Floating Int)
18:33:39 <lambdabot>     In the expression: sqrt ...
18:34:52 <yoshi> no, but why would the designers of haskell not make '^' work for fractional integers
18:35:09 <mauke> "fractional integers"?
18:35:30 <TSC> Rationals, I guess
18:35:33 <mauke> > cycle "oxymor"
18:35:33 <lambdabot>  "oxymoroxymoroxymoroxymoroxymoroxymoroxymoroxymoroxymoroxymoroxymoroxymoroxy...
18:35:43 <SamB> yoshi: because ^ is for all kinds of numbers
18:35:58 <MyCatVerbs> > cycle "ke"
18:35:59 <lambdabot>  "kekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekek...
18:36:17 <mauke> not the terrible kekide chain!
18:37:04 <MyCatVerbs> That one's a dehydration polymer, right?
18:37:11 <MyCatVerbs> Er, condensation polymer, even.
18:37:27 <MyCatVerbs> But I can't remember what the groups eliminated are.
18:38:59 <MyCatVerbs> Ah, right. The 'k's drop off. That is, each "kek" drops one 'k' in the process of forming the chain.
18:39:07 <MyCatVerbs> So in practice, it's more like...
18:40:14 <MyCatVerbs> > 'K' : concatMap tail (repeat "kek")
18:40:15 <lambdabot>  "Kekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekek...
18:46:27 <Beelsebob> MyCatVerbs: ? why not just 'K' : concat (repeat "ek")
18:46:55 <mauke> > 'K' : cycle "ek"
18:46:55 <lambdabot>  "Kekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekekek...
18:47:09 <Beelsebob> that too
18:47:11 <siponen> BEcause "ek"s don't exist naturally or moething I guess...
18:47:56 <Beelsebob> on the other hand, "ke"s do... so 'K' : (tail $ cycle "ke")
18:48:00 <MyCatVerbs> Beelsebob: because that doesn't correctly model the condensation polymerisation process, wherein "kek"s each shed a 'k' in order to become part of the polykekekekektide chain.
18:48:08 <Beelsebob> ah, I see
18:49:17 <dejones> kayess is still reconnecting / disconnecting... can someone temporarily ban him or something?
18:49:21 <dejones> he's been doing it for hours...
18:49:35 <dejones> the cycle just repeats
18:49:37 <joricj> c:t twice
18:49:39 <joricj> :t twice
18:49:40 <lambdabot> Not in scope: `twice'
18:54:05 * dejones wishes he could ban kayess....
18:54:09 --- mode: ChanServ set +o Cale
18:54:14 --- kick: kayess_____ was kicked by Cale (Cale)
18:54:16 <dejones> get'em Cale.  :)
18:54:34 --- kick: kayess was kicked by Cale (Cale)
18:54:46 <Cale> Hopefully that will do until his client is fixed.
18:54:51 <mauke> wtf?
18:54:52 --- mode: Cale set -o Cale
18:55:00 <mauke> how is that going to help?
18:55:01 <dejones> Cale, his IP Address keeps changing, so you'll have to ban chatzilla@ppp-124*asianet.co.th  ;)
18:55:21 <Cale> A lot of IRC clients have auto-rejoin
18:55:26 <dejones> yea.
18:55:37 <dejones> need a temporary ban... like 12 hrs or something :)
18:55:44 <Cale> But they won't rejoin after a kick (any IRC client which does that is severely broken)
18:55:55 <dejones> hehe
18:55:55 <Cale> So hopefully this will do.
18:56:00 <dejones> :)
18:56:10 <dejones> thanks Cale.
18:59:59 <MyCatVerbs> Cale: I've seen people script their IRC clients to automatically permaban anyone whose client immediately rejoins after being kicked. :)
19:02:43 <idnar> a lot of people's IRC clients rejoin after a kick :(
19:02:52 <SamB> Cale: of course, that only works if he was actually still connected when you did it
19:03:20 <gwern> @undo raiseVar getvar = do var <- liftIO getvar; runOrRaise var (className =? var)
19:03:20 <lambdabot> raiseVar getvar = liftIO getvar >>= \ var -> runOrRaise var (className =? var)
19:03:21 <Cale> SamB: Yes, of course.
19:03:42 <MyCatVerbs> idnar: mIRC doesn't by default, and if anyone manages to find an IRC client that sucks more then mIRC then it's their own damn fault.
19:04:03 <idnar> MyCatVerbs: but it has an option to do it :P
19:04:08 <SamB> MyCatVerbs: does it have a checkbox to enable the behaviour?
19:04:13 <idnar> (and a lot of people have it turned on)
19:04:30 <SamB> if it has, some twit (me, for instance!) will surely check it
19:06:06 <MyCatVerbs> idnar: indeed. But it isn't on by default.
19:07:56 <MyCatVerbs> idnar: mIRC, even bloody mIRC comes with sane-ish settings out of the box. It'd be nice if people didn't actually manage to do worse.
19:09:04 * MyCatVerbs slaps the thoughtpolice upside the head with 1984.
19:09:21 <MyCatVerbs> REPENT, DAMN YOU! Also find a better ISP, please.
19:09:55 * SamB slaps MyCatVerbs with a PDF of Brave New World
19:11:44 * monochrom slaps people randomly with the HTML file of A Gentle Introduction.
19:11:52 <MyCatVerbs> SamB: I still can't quite bring myself to sympathise with the author's assumption that a society composed entirely of alphas is intrinsically doomed to fail.
19:12:14 <SamB> MyCatVerbs: note that I have not yet read it
19:12:24 <monochrom> I am convinced. Who washes the street?
19:12:34 <wolverian> http://www.warmenhoven.org/blog/38
19:12:36 <lambdabot> Title: Eric Warmenhoven 6c » Rewriting as a learning tool
19:12:42 <monochrom> OTOH, composed of entirely alphas and robots is ok.
19:12:49 <MyCatVerbs> SamB: ah. It's good. A rather more nuanced (dys|u)topia than most.
19:12:52 <SamB> for some reason, I downloaded a PDF from wowio and never read it
19:13:07 <monochrom> (The alphas wash the street, the robots do the thinking and ruling.)
19:13:29 <SamB> perhaps because computers suck for reading novels???
19:13:44 <MyCatVerbs> monochrom: I will, if it be necessary.
19:14:02 <SamB> monochrom: yoou have to call them droids if they get to be in charge
19:14:15 <MyCatVerbs> monochrom: I don't see that a properly functioning human should ever have any idea of a particular field of work being "beneath" themselves.
19:14:39 <MyCatVerbs> SamB: that or Aintellects.
19:14:43 <monochrom> No, not beneath, but everyone has only finite time.
19:15:06 <SamB> MyCatVerbs: even jobs my computer already does?
19:16:05 <SamB> or ... can I think of particular fields of work as being too boring for me to do?
19:16:47 <MyCatVerbs> SamB: sure, even jobs your computer already does.
19:16:55 <siponen> I can. And I still hang at IRC in the middle of the local night...
19:17:07 <MyCatVerbs> SamB: however, your computer already does them. So there's no need for you to do them, so you can move on to more interesting jobs.
19:17:11 <siponen> There is something wrong here...
19:17:26 <SamB> MyCatVerbs: so... building the locate database is not beneath me?
19:18:01 <MyCatVerbs> SamB: however, if your computer couldn't and those jobs were necessary then, well, someone would have to do them.
19:18:31 <SamB> hmm, I think I would just get slocate working again ;-)
19:18:34 <idnar> MyCatVerbs: the idea that a field of work is "beneath" you amounts to saying that "someone" should be "someone else"
19:18:51 <idnar> because, you know, someone should do it, just not me
19:19:24 <MyCatVerbs> SamB: it'd be a waste of time if you didn't have your computer anyway. But aside from that, hundreds of thousands of people have spent entire careers as clerks, prior to the invention of valves and transistors. Are you saying that there is something wrong with what they did?
19:20:07 <SamB> perhaps not...
19:20:16 <joricj> @hoogle isPrefix
19:20:16 <lambdabot> Data.List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
19:20:16 <lambdabot> Data.ByteString.isPrefixOf :: ByteString -> ByteString -> Bool
19:20:16 <lambdabot> Data.ByteString.Char8.isPrefixOf :: ByteString -> ByteString -> Bool
19:20:27 <SamB> maybe I sshould instead say that I am incapable of such boring work
19:20:43 <glen_quagmire> > isPrefixOf "a"
19:20:44 <lambdabot>  <[Char] -> Bool>
19:20:44 <MyCatVerbs> SamB: yeah, that's fair enough.
19:20:56 <glen_quagmire> > isPrefixOf "a" "aA"
19:20:57 <lambdabot>  True
19:21:13 <glen_quagmire> > id
19:21:13 <lambdabot>  Add a type signature
19:21:23 <glen_quagmire> > id :: Int -> Int
19:21:23 <lambdabot>  <Int -> Int>
19:21:31 <glen_quagmire> wow <this is nice>
19:22:00 <Excedrin> hundreds of thousands of people have spent entire careers as serfs
19:22:52 <glen_quagmire> > let {a = undefined; b = 1;} in b
19:22:52 <lambdabot>  1
19:23:10 <glen_quagmire> > let {a = undefined; b = head a;} in b
19:23:11 <lambdabot>  Undefined
19:24:06 <monochrom> I'm just glad lambdabot does a lot for us.
19:24:14 <glen_quagmire> some people live in excel, some in emacs...
19:24:37 <MyCatVerbs> Some people live in real REPLs, where set difference is only a \\ away.
19:24:45 <travisbrady> glen_quagmire: thousands live in excel
19:25:15 <glen_quagmire> excel is a better programming environment than eclipse
19:25:19 <SamB> excel makes a horrible OS
19:25:29 <monochrom> what is "better"?
19:25:56 <glen_quagmire> intuitive functional programming with advanced macro capability
19:26:04 <MyCatVerbs> idnar: mmmmmfair 'nuff, but to drag this back to my original assertion that a predominantly-alpha society need not collapse: if the road needs sweeping and no one else on the island is less qualified than you to perform some other task which is also necessary then why should you not sweep the road?
19:26:15 <SamB> glen_quagmire: too bad the macros are nowhere near functional!
19:26:31 <glen_quagmire> excel is strongly typed i think
19:26:43 <glen_quagmire> it gives me #VALUUE!  or #NAME!
19:27:26 <SamB> MyCatVerbs: I would make a robot
19:27:43 <SamB> then I could write compilers instead of sweeping the road
19:28:22 <monochrom> You could hack robot code instead of sweeping the road.
19:28:34 <monochrom> Software engineering is self-fulfilling. :)
19:28:38 <SamB> that, too!
19:29:01 <glen_quagmire> i prefer to be a raggae singer than to be a software developer
19:29:31 <monochrom> After you have software, you can make IDE for software.  Then you can make IDE for IDE for software...
19:29:34 <SamB> oh, btw, the compiler writing? that was going to be ffor fun
19:29:54 <MyCatVerbs> SamB: sure, but that's merely sidestepping the issue by eliminating this instance of it entirely.
19:30:23 <glen_quagmire> programmers are fed up rock stars of their own world
19:30:24 <monochrom> Not entirely.  Robots are general-purpose too.
19:31:20 <monochrom> They wash the street, then they wash the toilet, then they cook your dinner.  They forget to wash their hands in-between, heh.
19:31:40 <joricj> my program is finished! when i do "echo main | ghci server.hs" it works, but how can i compile it? "ghc server.hs" gives tuns of errors
19:31:52 <Excedrin> ghc --make server.hs
19:31:57 <MyCatVerbs> monochrom: ah, so there's a use for software engineering. ;)
19:32:35 <monochrom> "Master, I have cleaned the toilet, and BTW tonight you have sushi for dinner!"
19:32:55 <SamB> hahahah
19:33:00 <Nafai> I'm looking for the FilePath module
19:33:03 <Nafai> For Shim
19:33:18 <SamB> wtih a siide order of food poisoning, yes?
19:33:29 <Nafai> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/filepath-1.1.0.0 <- I installed this
19:33:30 <lambdabot> http://tinyurl.com/ypc7sc
19:33:57 <mauke> :t maxBy
19:33:58 <lambdabot> Not in scope: `maxBy'
19:34:00 <Nafai> But Shim's setup is still claiming it isn't installed
19:34:02 <mauke> :t maximumBy
19:34:03 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
19:34:34 <monochrom> Which one is the greater evil, toilet germs getting on your sushi, or the chlorate bleach used for killing germs getting on your sushi? ...
19:35:12 <dobblego> the former
19:37:31 <glen_quagmire> define evil. it is two syllable word.
19:37:54 <glen_quagmire> i know one syllable words only
19:38:13 <monochrom> I guess you'll also ask about sushi.
19:38:40 <glen_quagmire> sushi is one syllable in japanese
19:38:43 <glen_quagmire> oh i  give up
19:38:48 <monochrom> haha
19:38:57 <hpaste>  mm_freak pasted "Small echo server behaving strangely" at http://hpaste.org/6763
19:39:06 <wagle_home> 2 morae
19:39:25 <mm_freak> see the pasteâ€¦  the echo server works perfectly fine for small amounts of data
19:40:12 <mcnster> @seen dcoutts_
19:40:12 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I don't know when dcoutts_ last spoke.
19:40:21 <mm_freak> but as soon as the data gets larger than a few hundred kilobytes it stops workingâ€¦  it eats full CPU time, until the other end closes the connection
19:40:29 <wagle_home> lines can be broken across packets
19:41:08 <mm_freak> wagle_home: it does that for /dev/urandom too, where a line break occurs every 256 characters in average
19:41:21 <mm_freak> and it does that with NoBuffering as well
19:41:49 <mm_freak> i've tried using hGetBuf/hPutBuf, but that didn't change anything
19:41:59 <mm_freak> (besides being a bit faster)
19:42:04 <allbery_b> os buffers full?  I would have it echo each individual line
19:42:21 <allbery_b> instead of HGetContents all at once
19:42:32 <mm_freak> allbery_b: isn't that exactly what it does?  hGetBuf is supposed to return a lazy list
19:42:38 <mm_freak> uhm
19:42:41 <mm_freak> hGetContent i mean
19:42:45 <mm_freak> +s
19:43:07 <wagle_home> you are forking a lot..  what happens to the parents?
19:43:21 <monochrom> I'll try mm_freak's code.
19:43:25 <mm_freak> i'm forking for each connection
19:43:32 <allbery_b> but you HPutStr itn as a lump
19:43:38 <mm_freak> monochrom: you'll have to add a few bitsâ€¦  i can paste the full code if you like
19:43:46 <allbery_b> I could see that reacting in several different ways, nto sure which is true here
19:43:49 <monochrom> Don't worry, I can strip it down.
19:43:51 <allbery_b> also that fork behavior is bad
19:44:07 <allbery_b> either doubkle fork or have the parent reap occasionally; you will otherwise run out of processes
19:44:20 <mm_freak> allbery_b: it works fine with netcatâ€¦  it echoes each line as soon as it arrives
19:44:40 <mm_freak> and the forkIO method (cheap concurrency) seems to be the preferred method to handle clients
19:45:06 <allbery_b> hm, forkIO is green threads not processes.  never mind me
19:45:08 <monochrom> @hoogle forever
19:45:08 <lambdabot> Control.Monad.forever :: Monad m => m a -> m ()
19:45:12 <allbery_b> it should do the rightthing
19:45:57 <mm_freak> the code you see works perfectly fine, as long as the source message is smaller than a few hundred kilobytes
19:47:17 <wagle_home> a while back, i got weird behavior when the (short!) source message was split into 2-3 packets
19:47:53 <mm_freak> monochrom: try NoBufferingâ€¦  it's safer, though a bit less performant
19:48:46 <gwern> @where soc
19:48:46 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
19:48:55 <allbery_b> it's TCP, packet fragmentation and multiple packets should be ebtirely transparent
19:49:01 <adu> :)
19:49:23 <adu> i want to do SOC
19:49:58 <wagle_home> allbery_b, not fragmentation, tcp deciding to transmit before the user process got done doing the (apparently) 3 write syscalls
19:50:27 <gwern> allbery_b: you go to CMU?
19:50:32 <gwern> er. wrong chan
19:50:38 <allbery_b> wagle_home: should still be transparent
19:50:57 <allbery_b> packets should be entirely transparent in TCP, the application should only see a stream
19:51:18 <monochrom> mm_freak: I did the following.  I commented out the hSetBuffering line altogether.  (I also hard code port number 9413.)  Then I run: tar -c haddock-0.9 | nc -q 2 localhost 9413 > xxx .  Finishes fine in a second or two.  The resulting file is 10MB.
19:51:22 <trie> What is the best way to upgrade a package from hackage installed with "cabal install"?
19:51:38 <wagle_home> the write tcpdump wrote and closed, and ACK's from the reader resulted in it sending RESET's
19:51:51 <wagle_home> the write tcp >stack< wrote and closed, and ACK's from the reader resulted in it sending RESET's
19:52:10 <wagle_home> you'd think it would be transparent, but it wasnt
19:52:11 <mm_freak> monochrom: ah ok, many thanksâ€¦  it seems to be a netcat-related issue
19:52:47 <allbery_b> hm, that sounds buggy
19:53:09 <allbery_b> if it wrote and closed, the close shouldn't have completed until everything was acked
19:53:28 <wagle_home> i just report the facts, m'am
19:53:36 <allbery_b> FIN with the wrong sequence number would be rejected with a retransmit request
19:53:50 <wagle_home> but, as i said, this was a while back (12 years?)
19:54:06 <gwern> trie: there isn't really so far as I know; you just unregister the package and reinstall; but you might try a 'cabal install foo-3000'
19:56:00 <gwern> it was fun. those KGB guys are spryer than they look
19:56:12 * gwern will never get the hang of these split screens
19:56:14 <monochrom> mm_freak: I now turn on line-buffering, recompile, and tar -c haddock-0.9 | nc -q 2 localhost 9413 > xxx again.  Same happy ending.
19:57:01 <trie> gwern: Thanks! cabal install foo--version worked.
19:57:35 * monochrom now contemplates the unthinkable.
19:58:35 <gwern> monochrom: good thing it's not the inconceivable, or you'd be in trouble
19:59:20 <monochrom> wget 'http://www.haskell.org/ghc/dist/6.8.2/maeder/ghc-6.8.2-i386-unknown-linux.tar.bz2' -O - | nc -q 2 localhost 9413 > xxx   bwahahahaha
19:59:21 <lambdabot> http://tinyurl.com/2n42ez
19:59:57 <monochrom> The echo daemon isn't using much CPU.
20:00:01 <mm_freak> monochrom: i figured netcat was the sinnerâ€¦  it doesn't close the connections, if -q is not specified
20:00:16 <monochrom> Oh, haha, that's right.  OK, I'll stop.
20:04:44 <monochrom> When you have success, doing something like  ... | nc -q 2 localhost 9413 | nc -q 2 localhost 9413 | ...  for real awesomeness. :)
20:06:41 <mm_freak> hehe
20:08:21 * SamB wonders what that will do
20:09:07 <monochrom> It asks the echo daemon to do twice the work.
20:09:44 <monochrom> It opens two connections to the daemon.  You feed stuff to the first, get stuff out, now feed that to the second, get stuff out...
20:10:56 <mm_freak> i wonder whether such a clean code is possible in any other language
20:10:56 * SamB wonders what is taking hp2ps so long
20:10:59 <mm_freak> other than Clean =)
20:11:22 <monochrom> I heard Erlang is also quite ok.
20:11:26 <SamB>  12735 naesten   30   5 32228  30m  400 R 38.5  6.0   6:25.68 hp2ps
20:12:15 * SamB thinks they ought to have a way to insert markers into heap profiles programmatically
20:12:34 <mm_freak> monochrom: erlang is strict
20:12:59 <Twey> Strict?
20:13:23 <mm_freak> AFAIK it doesn't have such things as lazy lists
20:17:44 <Nafai> So, basic question.  This line: "import Text.ParserCombinators.Parsec ( parse )" means that I only import parse from Text.ParserCombinators.Parsec, right?
20:19:10 <wagle_home> cdr' x = case x of (Suspension t) -> t () ; v -> v
20:19:45 <wagle_home> more work if you want eval-once
20:20:04 <wagle_home> hmm..  lazy lists in fortran..
20:20:44 <SamB>  12735 naesten   30   5 38564  36m  396 R 39.2  7.2   9:43.73 hp2ps
20:20:52 <trie> Nafai: correct.
20:30:46 <adu> hey
20:31:26 <Nafai> Hi adu
20:31:30 <adu> how do I get my name in the "Interested Students" section here:
20:31:32 <adu> http://hackage.haskell.org/trac/summer-of-code/ticket/1561
20:31:34 <lambdabot> Title: #1561 (Cleanup, document and improve the GHC API) - Haskell.org Google Summer of ...
20:36:33 <Nafai> Too bad there wasn't GSOC back when I was in university
20:37:36 <Pseudonym> Wouldn't have mattered to me, since it's term time in the southern hemisphere.
20:37:59 <Pseudonym> Though I'm not sure that anyone would have wanted the sort of code that I wrote as an undergrad.
20:38:22 <Nafai> Heh
20:43:52 <SamB> wow, hp2ps has been crunching for nearly 20 minutes of cpu time...
20:46:13 <ahunter> @pl f a b = g b [] (h a)
20:46:13 <lambdabot> f = flip (flip g []) . h
20:50:49 <travisbrady_> anyone know of a Haskell equivalent of python's os.walk?
20:54:17 <glen_quagmire> @hoogle walk
20:54:18 <lambdabot> No matches found
20:55:40 <Eelis> Data.Tree provides a tree with values at the nodes. is there a tree type with values at the leafs in the hierarchical libraries somewhere?
21:00:48 <dons> http://people.debian.org/~igloo/popcon-graphs/index.php?packages=ghc6%2Cocaml&show_installed=on&want_legend=on&want_ticks=on&from_date=2007-01-01&to_date=&hlght_date=&date_fmt=%25Y-%25m&beenhere=1
21:00:50 <lambdabot> Title: popcon graph, http://tinyurl.com/3db3q7
21:00:58 <dons> ghc is (finally) more popular than ocaml on debian. woot
21:01:12 <dons> Igloo: ^ :)
21:06:09 <dolio> Eelis: Just at the leaves?
21:08:56 <Nafai> Anyone familiar with hsemail?
21:09:20 <Nafai> I'm trying to understand some of the basics of how it uses Parsec
21:10:01 <Nafai> Well, actually: http://cryp.to/hsemail/docs/Text-ParserCombinators-Parsec-Rfc2822.html#v%3Amessage
21:10:03 <lambdabot> http://tinyurl.com/2jpkq3
21:10:34 <Nafai> I'm trying to understand that type of message as it is used with parse from Parsec
21:10:36 <adu> wow
21:10:41 <Nafai> What's 'a' in this context?
21:11:11 <adu> Nafai: : I know Parsec
21:11:45 <Nafai> Prelude Text.ParserCombinators.Parsec Text.ParserCombinators.Parsec.Rfc2822> :t parse
21:11:48 <Nafai> parse :: GenParser tok () a -> SourceName -> [tok] -> Either ParseError a
21:11:48 <adu> Nafai: 'a' is the state type
21:12:10 <Nafai> So is that just implicit?
21:12:20 <adu> in that, 'a' is the parser-result-type
21:13:13 <adu> Nafai: no its generic
21:13:28 <adu> you have to provide your own parser-result-type
21:14:09 <Eelis> dolio: yes
21:14:49 <Eelis> dolio: e.g.  data Tree a = Leaf a | Split [Tree a]
21:14:56 <Nafai> adu: So the "message" from that above link is used as the first parameter to parse
21:14:57 <dolio> Eelis: Data.Sequence is kind of like that internally, although it's presented like a list, of course.
21:15:09 <Eelis> dolio: right. i really need a tree :)
21:15:21 <dolio> Ah. I don't think there's anything like that, then.
21:15:22 <Eelis> i'm using the definition i just gave, but i'm getting bored defining utilities for it
21:15:27 <Nafai> adu: message has a in it's type as well
21:15:41 <Eelis> dolio: ok, pity
21:15:42 <adu> Nafai: type CharParser st a = GenParser Char st a
21:15:46 <adu> Nafai: so yes
21:16:24 <Nafai> I guess I'm still learning how to read the type definitions
21:16:39 <adu> Nafai: how well do you understand Haskell/Parsec?
21:17:02 <Nafai> Parsec, not at all other that what it is
21:17:20 <Nafai> Haskell, still learning, and I really haven't looked at it for a couple months :/
21:19:34 <adu> Nafai:  there are 2 wonderful documents about Parsec http://legacy.cs.uu.nl/daan/parsec.html
21:19:35 <lambdabot> Title: Parsec
21:19:51 <adu> I would read both "parsec" and "parsec-paper"
21:20:06 <Nafai> Thanks
21:20:25 <adu> Btw, "parsec-paper" is in the "technical report" section
21:23:26 <adu> Nafai: do you know Lisp/Scheme?
21:23:43 <Nafai> Yes
21:24:45 <adu> expr = between (string "(") (string ")") (many expr)
21:25:32 <adu> that would be a really crappy lisp parser in Parsec
21:26:43 <adu> wb Cale
21:28:38 <Nafai> dons: Around?
21:28:53 <adu> expr = between (string "(") (string ")") (many $ lexeme expr) <|> naturalOrFloat <|> stringLiteral <|> identifier
21:28:58 <adu> but that would probably work better
21:37:10 <hpaste>  dons pasted "(no title)" at http://hpaste.org/6764
21:42:26 <lament> spam title: "Your prompt response is highly imperative."
21:43:42 <inimino> a commentary on shell usage perhaps?
21:48:16 <lament> it makes sense for response, clearly an IO action, to be imperative...
21:48:26 <Nafai> Anyone familiar with hsemail?  I'm running up against my Haskell knowledge in using it :/
21:51:05 <Nafai> If you parse, using message as the type, you get a list of Fields (if I'm understanding it correctly)
21:51:16 <Nafai> I'm unsure of how to extract out of there just the fields I want
21:56:04 <Nafai> Oh my!  Someone wrote a version of Java for shapr! http://technomancy.us/107
21:56:06 <lambdabot> Title: new project - Technomancy
21:59:11 <bos> @hoogle liftIO
21:59:11 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
22:05:13 <bos> i love refactoring code in haskell.
22:05:47 <bos> it's taken me about ten minutes to convert some crummy code from using the IO monad and an explicit piece of threaded state to a state transformer.
22:06:18 <dolio> Is that good or bad?
22:07:33 <bos> well, it's code that i haven't thought about in six weeks, and the conversion was simply a matter of fixing type signatures and removing variables and adding a few lifts until it all compiled again.
22:07:35 <bos> so very good.
22:07:48 <bos> just follow the breadcrumb trail left by the compiler.
22:07:54 <dolio> Heh.
22:08:07 <dolio> It is nice how that often works out.
22:08:49 <ahunter> OK, so IIRC, there's an implict Eq instance somewhere for tuples if all the components are Eq...suppose that type Foo = (Bar, Baz, Quux) and those three are all Eq.  Can I write my own Eq instance for Foo, which does something different, or will that conflict?
22:09:12 <Pseudonym> That will conflict.
22:09:20 <Pseudonym> Because there's already an Eq instance for 3-tuples.
22:09:28 <bos> it's not an implicit instance, it's defined in Prelude.
22:09:36 <bos> unfortunately, you can't make it go away.
22:09:46 <Riastradh> Why don't you introduce a new type, rather than a type alias?
22:09:47 <bos> instances have this infectious nature.
22:09:48 <ahunter> Rats.  Though if Quux, say, wasn't Eq, then I'd e OK?
22:10:01 <Pseudonym> Having said that... it _might_ work if you -fallow-something-instances.
22:10:08 <ahunter> Riastradh: I could do that, but this is a relatively lightweight system and I'd like to keep it simple.
22:10:14 <Cale> ahunter: If you want to write your own instance, don't use 3-tuples, just create your own type.
22:10:15 <Pseudonym> There are precedents.
22:10:29 <Pseudonym> For example, the Show instance for [Char] is not the same as the instance for [a].
22:10:30 <bos> cale is of course correct.
22:10:30 <Cale> data Foo = F Bar Baz Quux
22:10:39 <ahunter> Cale: suppose I'll do that, thne
22:10:42 <Riastradh> Why does introducing type aliases make anything simpler, ahunter?
22:10:57 <ahunter> Riastradh: no constructors to introduce and remove
22:11:31 <bos> hmm. the one nasty thing about my nice monad transformer wrapper IO monad is dealing with forkIO.
22:11:45 <bos> forkIO wants an IO action, and i've carefully hidden IO.
22:11:55 <Pseudonym> You have IO as a monad transformer?
22:12:05 <bos> no, it's at the bottom of the stack.
22:12:09 <Pseudonym> Ah, right.
22:12:12 <Pseudonym> That makes more sense.
22:12:19 <bos> as in newtype H a = H (StateT AppState IO a)
22:12:19 <Pseudonym> @hoogle MonadIO
22:12:19 <lambdabot> Control.Monad.Trans.MonadIO :: class Monad m => MonadIO m
22:12:26 <Pseudonym> Like that?
22:12:29 <bos> yes.
22:12:58 <bos> i can get the state out using get and simply rewrap things on the other side of forkIO, but that's fugly.
22:14:11 <bos> oh well. i'll confine the ugly with forkH :: H () -> H ThreadId
22:18:16 <dolio> The difference between Show [Char] and Show [a] isn't due to overlapping instances, though, no? It's done through showList.
22:22:03 <dolio> data Foo = Foo ; instance Show Foo where { show _ = "I'm a Foo!" ; showList _ s = "I'm a Foo list!" ++ s }
22:22:21 <dolio> *Main> show [Foo] ==> "I'm a Foo list!"
22:22:59 <dolio> hpaste.org appears to be dead.
22:27:34 <glguy> seems ok now at least
22:31:26 <moconnor> Would anyone here with an ACM membership be willing to download the PDF of "Smalltalk-80: the language and its implementation" and give it to me?  The URL is: http://tinyurl.com/2vxmhn
22:31:29 <lambdabot> Title: Smalltalk-80
22:33:00 <moconnor> (it now occurs to me some might think I'm kidding. I'm not, I just don't have an ACM membership and it's $57 on amazon)
22:33:08 <dolio> Apparently it's just me, then.
22:35:48 <Cale> moconnor: It'll just be a couple minutes. I'm using a proxy that's in Australia :)
22:35:51 <Jedai> moconnor: Don't you just need a free ACM Web Account ?
22:36:21 <Jedai> Cale: Don't bother then, I'll have it in 20 s
22:36:43 <moconnor> thanks!
22:38:37 <Cale> http://cale.yi.org/autoshare/small-goldberg.pdf
22:40:09 <Riastradh> Personal politics about `intellectual property' (whatever that means) aside, are you folks not concerned about copyright violations in public IRC channels?
22:40:38 <Eelis> no
22:40:49 <Jedai> Riastradh: I think moconnor was mistaken anyway, apparently, a free Web account was enough to get this book...
22:40:53 * wagle_home turns purple trying to suck from cale's tiny straw..  8)
22:41:53 <Riastradh> Hm.  I wasn't aware that there were free accounts.
22:42:32 <Cale> wagle_home: Yeah, my upload bandwidth isn't great. ~150KiB/s
22:42:41 <moconnor> Jedai: I didn't read the page too closely, I thought everything on ACM cost money.  Thanks for the the tip!
22:42:48 <moconnor> Cale: Thank you!
22:43:37 * roconnor applies european fair use for research
22:44:03 <Jedai> Riastradh: Apparently there are (I have the minimum account myself, and my school probably has the better account)
22:44:57 <Jedai> moconnor: If you're in an university or school, ask them if they have an ACM account and how you could use it
22:45:06 <shachaf> Cale: You run both lambdabot and lambdabot2, right?
22:45:12 <Cale> shachaf: yeah
22:45:16 <lament> isn't there a ton of completely free smalltalk books anyway?
22:46:07 <Cale> shachaf: I don't run them on my machine though
22:46:57 <Jedai> The Bluebook is freely available at plenty other locations too
22:46:57 <lament> damn, so it wasn't you i was hacking all this time?
22:47:32 <Riastradh> OK.
22:55:24 <vegai> dons: are you awake?
22:56:30 <wagle_home> @seen dons
22:56:30 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 21m 52s ago.
23:12:49 <adu> has everyone seen http://www.youtube.com/ ?
23:12:59 <adu> its rickroll hell
23:13:24 <blarz> lol
23:13:48 <adu> must be 04-01 thing
23:14:15 <blarz> right
23:14:26 * dolio isn't seeing it.
23:14:40 <adu> click on any featured video, the result is the same
23:14:50 <dolio> Ah.
23:15:02 <dolio> Nice.
23:15:18 <dolio> I like the metal rickroll, myself.
23:15:23 <adu> heh
23:15:48 <dolio> http://au.youtube.com/watch?v=6EvO_466ChA
23:15:49 <lambdabot> Title: YouTube - Rickroll metal remix
23:20:22 <Cale> http://uk.youtube.com/watch?v=5uZr3JWYdy8
23:20:23 <lambdabot> Title: YouTube - Mario PaintRoller'd
23:20:45 <dolio> Awesome.
23:22:54 <dolio> I didn't realize you could do flats and sharps.
23:25:25 <Cale> I don't think that's the original Mario Paint actually.
23:26:17 <dolio> Possibly. I wonder if I still have my SNES mouse...
23:27:01 <dolio> I guess that "Download/Upload Songs" wouldn't make must sense in the original mario paint.
23:29:18 <dobblego> ?src Ord Maybe
23:29:18 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
23:30:01 <dmwit> I'm sure it's the derived instance.
23:30:01 <dobblego> how do you get a type-class instance for a type?
23:30:15 <dobblego> ah yes
23:30:21 <dmwit> ?src Maybe Ord
23:30:21 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
23:30:31 <Cale> ?src Maybe (<)
23:30:32 <lambdabot> Source not found. Maybe you made a typo?
23:30:35 <shachaf> dobblego: As dmwit said, it's derived.
23:30:48 <dobblego> yeah, didn't think of that, cheers
23:30:58 <dmwit> Oh, yeah, you have to specify a function. =P
23:31:18 <shachaf> > (compare Nothing Nothing, compare Nothing (Just 0), compare (Just 0) (Just 0), compare (Just 0) (Just 1))
23:31:18 <lambdabot>  (EQ,LT,EQ,LT)
23:31:29 <shachaf> It would be
23:31:32 <shachaf> @src Maybe compare
23:31:32 <lambdabot> Source not found. :(
23:31:35 <shachaf> If anything.
23:41:43 <Japsu> let j = Just 0 in map (uncurry compare) (replicateM 2 [j, Nothing])
23:41:45 <Japsu> > let j = Just 0 in map (uncurry compare) (replicateM 2 [j, Nothing])
23:41:46 <lambdabot>  Couldn't match expected type `(a, a)'
23:41:55 <Japsu> blast it
23:46:21 <dmwit> > let j = Just 0 in map (\[a, b] -> compare a b) (replicateM 2 [j, Nothing])
23:46:22 <lambdabot>  [EQ,GT,LT,EQ]
23:47:44 <shachaf> Well, comparing (Just 0) and (Just 0) isn't helpful.
23:48:34 <dmwit> > map (\[a, b] -> compare a b) (replicateM 2 [Nothing, Just 0, Just 1])
23:48:34 <lambdabot>  [EQ,LT,LT,GT,EQ,LT,GT,GT,EQ]
23:49:02 <Japsu> we need a function called "luncurry"
23:49:38 <Japsu> @let luncurry f [a, b] = f a b
23:49:38 <lambdabot> Defined.
23:49:49 <dmwit> =(
23:49:55 <Japsu> > map (luncurry compare) (replicateM 2 [Nothing, Just 0, Just 1])
23:49:56 <lambdabot>  [EQ,LT,LT,GT,EQ,LT,GT,GT,EQ]
23:49:59 <Japsu> ^________^
23:50:52 <Jedai> @ty zipWithM
23:50:52 <dmwit> > let l = [Nothing, Just 0, Just 1] in liftM2 compare l l
23:50:53 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
23:50:53 <lambdabot>  [EQ,LT,LT,GT,EQ,LT,GT,GT,EQ]
23:51:07 <dmwit> Japsu: I prefer mine to yours.
23:51:57 <Japsu> dmwit: I concur.
23:52:39 <shachaf> Just False, Just True might make more sense.
23:53:16 <dmwit> Sure, but it's (slightly) less obvious that we want (False < True).
23:53:57 <Jedai> @src Monad ((->) r) >>=
23:53:57 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
23:54:07 <dmwit> ?src (->) (>>=)
23:54:07 <lambdabot> f >>= k = \ r -> k (f r) r
23:54:42 <Cale> > ((*2) >>= (+)) 5
23:54:43 <lambdabot>  15
23:54:57 <Jedai> (liftM2 compare =<< id) [Nothing, Just 0, Just 1]
23:55:02 <Jedai> > (liftM2 compare =<< id) [Nothing, Just 0, Just 1]
23:55:03 <lambdabot>  [EQ,LT,LT,GT,EQ,LT,GT,GT,EQ]
23:55:13 <dmwit> > join (liftM2 compare) [Nothing, Just 0, Just 1]
23:55:14 <lambdabot>  [EQ,LT,LT,GT,EQ,LT,GT,GT,EQ]
23:55:23 <dmwit> ?src join
23:55:23 <lambdabot> join x =  x >>= id
23:55:24 <dmwit> =)
23:55:45 <dmwit> The let-binding was for readability.
23:57:40 <dmwit> > ((+) ++ (*)) 5 10
23:57:40 <lambdabot>  Add a type signature
23:57:49 <dmwit> :t (++)
23:57:50 <lambdabot> forall m. (Monoid m) => m -> m -> m
23:58:10 <Jedai> > 5 ++ 10
23:58:11 <lambdabot>  Add a type signature
23:58:23 <dmwit> > ((+5) ++ (*10)) 3
23:58:23 <lambdabot>  Add a type signature
23:58:27 <dmwit> hum
23:58:30 <dmwit> ?instances Monoid
23:58:31 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
23:58:38 <dmwit> ah
23:58:56 <Jedai> dmwit: Too many different Monoid on Num...
23:59:01 <dmwit> yup
23:59:48 <Jedai> > Sum 5 ++ Sum 10
23:59:49 <lambdabot>  Sum {getSum = 15}
