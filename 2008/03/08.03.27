00:03:37 <AMcBain> why doesn't "(length list) div i" work? list being something like [1,2,3] and i an int?
00:03:45 <bd_> `div` not div
00:03:49 <bd_> or div (length list) i
00:03:59 <AMcBain> oh!
00:04:01 <bd_> the `` make it an infix operator :)
00:04:22 <bd_> (which works on any function without any need to predeclare, unless you want to override precedence or something)
00:04:23 <AMcBain> Neat.
00:07:38 <AMcBain> Hm. Not sure I did this right then. I'm trying to convert a value from 0 to 8 into an x and y value of 0 to 2 (for either).
00:08:03 <AMcBain> I used mod and div, but I can't quite get it right (which is which)
00:09:46 <svat> (x,y) = n `divMod` 3, for example. The "mod" number is for the nested level (does that make sense?)
00:10:45 <svat> AMcBain: what x and y do you want the number 1 to be assigned, for example?
00:11:14 <AMcBain> Well the Scheme program used 0-indexed lists if that is what you mean ...
00:12:23 <svat> AMcBain: yes, same here, but which of x and y did you use for the indices in the top-level list and which one for indices within the nested lists?
00:13:05 <AMcBain> Oh, y goes down (rows) and x is across (columns)
00:13:47 <svat> and your lists go the same way too? Just say what pairs you want to assign to values 0 to 8 :)
00:14:26 <AMcBain> divMode doesn't seem to be it ... if I do "9 `divMod` 8" I should get a y of 3, but I get (1,1)
00:14:32 <svat> Do you want (0,0), (0,1), (0,2), (1,1), (1,2)... or (0,0), (1,0), (2,0), (0,1), (1,1)... ?
00:15:17 <AMcBain> I want it so that when I put in 0 1 or 2 I get a y of 0 and an x of 0 1 or 2 etc ...
00:15:19 <svat> Why should you get 3? 9 `divMod` 8 is (1,1) indeed -- 9 `div` 8 is 1 and 9 `mod` 8 is 1.
00:15:32 <AMcBain> 3 4 5 would have a y of 2
00:15:43 <AMcBain> 6 7 8 being y of 3.
00:15:57 <AMcBain> assuming I was passed a 3x3 board
00:16:08 <svat> your y takes values in 1 2 3, and your x in values in 0 1 2?
00:16:17 <AMcBain> no
00:16:52 <svat> aren't you indexing from 0? Your y will always be <3.
00:16:53 <AMcBain> If I input a value from 0 to list size - 1, I need to get back distinct x and y values (column and row)
00:17:40 <AMcBain> And the y value will be from 0 to outerlist length - 1 and for simplicity, the x value will have the same range (I'm not dealing with mishappen boards)
00:17:50 <AMcBain> misshapen*
00:18:13 <svat> Exactly, so both x and y range from 0 to (N-1).
00:18:16 <svat> that is what `divMod` 3 will do, but you need to sort out which is the column and which is the row. Just think carefully, or look at some examples.
00:18:44 <AMcBain> well I tried some examples but it returned some weird stuff.
00:19:08 <svat> You were doing divmod 8, not 3.
00:20:09 <AMcBain> Ah I got it. "i `divMod` n" does what I need. I was doing the reverse earlier. (n then i)
00:20:36 <svat> good, then.
00:20:46 <svat> I looked at the game just now :)
00:22:03 <svat> It reduces to a system of linear equations over F_2, but that may not be the best/nicest way to solve it.
00:22:09 <AMcBain> It is slightly addicting. I know the patterns, so when I hit them, I can easily win. Thing is, the program doesn't know that :P They are usually solvable in 10 moves or less, some 13.
00:22:31 <svat> You never need more than 9 moves.
00:23:00 <AMcBain> Well maybe if I made smarter choices to get to a pattern I recognize, sure ...
00:23:02 <AMcBain> :)
00:23:42 <svat> You can prove that you'll never need more than 9 moves -- think about whether the order of the clicks matters, and whether it can be useful to click the same button more than once.
00:24:24 <svat> But you should probably get back to translating your current existing working solution, instead of trying to come up with a new solution whose implementation might introduce bugs :)
00:24:49 <AMcBain> yup
00:25:11 <AMcBain> I already had to disable part of the program to get a reasonable answer (with the prof's permission)
00:25:40 <svat> Will you always be given a 3x3 board, or could it be an nxn board for large n?
00:25:56 <AMcBain> Well I think we can hard code for 3, but I designed it to take n.
00:26:24 <AMcBain> I checked against both a fully "on" board and a fully "off" board and took the solution with the least number of moves. However, that means it spends forever in the "on" part if I send in an easy "off" solution. So I commented it out for now.
00:26:39 <svat> If your assignment only asks for 3, then there is a simple brute-force solution that always finds the shortest answer, which is guaranteed to be <=9 moves :)
00:27:02 <AMcBain> I'm sure, but I like scalability.
00:27:46 <AMcBain> Too bad I didn't think of this sooner, because I wrote a Widget once that was a lights out game (though I only recognized fully off to fully on as a solution) and I wanted a way to solve it and show the steps ...
00:28:32 <AMcBain> It doesn't work any more, they engine upgraded, and I think some cheats I used to animate the pieces now fail ... but now it has Canvas and more potential ...
00:28:37 <AMcBain> the*
00:29:02 <svat> so where are you with your Scheme->Haskell translation currently? :)
00:30:05 <AMcBain> Well I have to do flip/click/swap and expand n, and process. Then the rest should just fall into place I hope.
00:30:31 <AMcBain> I suppose I should tackle "flip".
00:31:30 <svat> It might be a good idea to tackle the hardest parts first, writing them in terms of functions that you will define later -- you might discover that you don't need to write some of those.
00:33:11 <AMcBain> Actually, most of flip (called click in the haskell program) will move over nicely.
00:36:23 <Twey> Eh?
00:36:28 <Twey> @type click
00:36:31 <lambdabot> Not in scope: `click'
00:36:40 <Twey> @type flip
00:36:41 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
00:38:34 <AMcBain> flip is what I called it in Scheme, but apparently there is already a flip in Haskell, so I have ot call it something else.
00:51:00 <Twey> AMcBain: Indeed
01:06:16 <AMcBain> hm ... round is giving me issues. "No instance for (RealFrac Int) arising from use of `round' at ..."
01:06:56 <sjanssen> you can't round an Int
01:07:54 <AMcBain> Ugh. Well from what I can see from the math functions, Haskell took typing just one step further than was really necessary. Ick.
01:09:07 <AMcBain> I suppose what I was trying to see was if it divided evenly, and there are other ways to do that. like mod.
01:09:41 <Cale> Fractional division also doesn't work with Int
01:09:47 <Cale> > (3 :: Int) / 5
01:09:48 <lambdabot>   add an instance declaration for (Fractional Int)
01:09:48 <lambdabot>     In the expression: (3 ...
01:09:59 <Cale> (you must use div or quot)
01:11:03 <AMcBain> I removed all my division in favor of mod.
01:11:18 <AMcBain> All I needed was to see if it divided evenly.
01:11:35 <AMcBain> So, afaik, click is now done :)
01:17:54 <AMcBain> expandn done. Next to tackle process :-/
01:21:00 <solrize> Safe manual memory management using ownership types: Possible to implement as a library using monads
01:21:08 <solrize> (from someone's language checklist, re haskell)
01:21:10 <solrize> true ?
01:22:29 <solrize> the interaction between modules and type classes is rather poor. For example, all instance declarations are global.
01:22:34 <solrize> ?????  ouch!!
01:26:56 <AMcBain> Question: From this paste: http://paste.lisp.org/display/58065 Inside "process" (towards the bottom) how would I do the inner let? It comes right after an "else" so ...
01:27:35 <solrize> what's wrong with that?
01:28:03 <AMcBain> well it doesn't like the let, because I have an if after it ... hm. Do I need a ; ?
01:28:22 <solrize> if 2+2==5 then "oh nooes" else let x="hooray! " in (x++x++x)
01:28:26 <solrize> > if 2+2==5 then "oh nooes" else let x="hooray! " in (x++x++x)
01:28:28 <lambdabot>  "hooray! hooray! hooray! "
01:29:00 <AMcBain> Ah, the in did it.
01:29:06 <Cale> > let x = 2 + 2 in if x == 5 then "oh nooes" else let x = "hooray! " in (x++x++x)
01:29:07 <lambdabot>  "hooray! hooray! hooray! "
01:31:46 <quicksilver> solrize: there are deep reasons why instances are global. May of us would love lexically scoped instances but there be dragons...
01:33:02 <solrize> sigh, there's a lot of proposed python improvements that are impossible because python painted itself into a corner with its indentation-based syntax (example: lambdas with statements inside).  maybe haskell has done the same thing with its type system.
01:33:23 <solrize> i remember some paper saying haskell typeclasses are isomorphic to ml functors
01:34:15 <quicksilver> I think isomorphic is an unintuitive way of putting it.
01:34:26 <quicksilver> they are equally expressive in some abstract sense
01:34:36 <quicksilver> but the encodings are un-natural
01:34:50 <quicksilver> so they feel rather different in practice
01:35:59 <solrize> makes sense
01:36:39 <quicksilver> after all, haskell and perl are isomoprhic in the sense that they are both turing complete.
01:37:05 <quicksilver> but that's not a very useful sense of 'isomorphic' :)
01:37:14 <solrize> that's not an isomorphism, it doesn't preserve homomorphisms :)
01:37:19 <solrize> err
01:37:35 <solrize> you know what i mean
01:38:27 <quicksilver> it preserves some structures.
01:38:39 <quicksilver> it preserves semantics, which is a useful structure.
01:38:45 <quicksilver> it would preserve certain kinds of composition
01:38:50 <quicksilver> (unix pipe composition)
01:39:29 <solrize> what happened to that nubgames guy who wrote a bunch of good blog posts about haskell?  they're gone now.
01:40:54 <edwardk> solrize: the safe memory management stuff sounds like someone either reinventing regions or trying to reinvent c++ style memory management ;)
01:42:02 <solrize> hmm, could be
01:44:53 <AMcBain> How would I do my main file? http://hpaste.org/6654
01:44:59 <AMcBain> This doesn't seem to "fly"
01:45:24 <solrize> put the import at the top of the file
01:45:34 <AMcBain> Before the module?
01:45:39 <solrize> hmm actually i'm not sure
01:46:34 <solrize> i just annotated to put in a "main"
01:47:42 <Cale> What's the type of sol?
01:48:47 <solrize> might be easier to put everything in one file, for a little thing like this
01:49:17 <AMcBain> Argh. It doesn't like my putStr line ...
01:49:57 <solrize> yeah it's not clear what you're trying to do
01:50:03 <solrize> your original version doesn't define any functions
01:50:16 <solrize> my annotation defines "main" but the types underneath are messed up
01:50:31 <sombresoul> hi all, could somebody tell me, where i`m wrong http://hpaste.org/6653 =\
01:51:38 <solrize> err, what is the problem, sombresoul ?
01:52:05 <sombresoul> ghc: Couldn't match expected type `BS.ByteString' \ against inferred type `Data.ByteString.Lazy.Internal.ByteString' \ In the first argument of `BS.append', namely `z' \ In the expression: BS.append z zs \ In the definition of `do_rearr': \ do_rearr (x : xs) \ = BS.append z zs \ where \ z = encode (x) \ zs = do_rearr xs
01:52:28 <sombresoul> =\
01:52:59 <solrize> say ":t encode" with that encryption module loaded
01:54:43 <sombresoul> emm.. encode - it`s Data.Binary function
01:54:43 <solrize> well see what its type is
01:54:49 <sombresoul> for making ByteString from integral
01:55:08 <sombresoul> encode :: (Binary a) => a -> Data.ByteString.Lazy.Internal.ByteString
01:55:22 <sombresoul> decode :: (Binary a) => Data.ByteString.Lazy.Internal.ByteString -> a
01:55:45 <AMcBain> Argh! I'm one line away from being done. Can I paste it and get some help as to why it has an error with a certain line?
01:55:47 <Cale> sombresoul: Try importing Data.ByteString.Lazy instead
01:55:56 <Cale> AMcBain: sure
01:58:11 <sombresoul> Cale, wow, thanks) you`re mage )
01:58:12 <AMcBain> http://hpaste.org/6655 Error is towards the top. You know the input from the main I posted (which works now)
01:59:54 <Cale> AMcBain: What's the type of process?
01:59:55 <AMcBain> It seems to be a mismatched type error of some sort, but I thought I was pretty good about my inputs ...
01:59:55 <AMcBain> process is a function.
01:59:58 <Cale> of what type?
02:00:06 <AMcBain> Huh? functions can have a type?
02:00:30 <Cale> all functions have types
02:00:34 <Cale> :t length
02:00:36 <lambdabot> forall a. [a] -> Int
02:00:37 <AMcBain> Or does it need to be defined before I use it.
02:00:39 <AMcBain> ?
02:00:45 <ski> usually not
02:00:50 <Cale> The order of declarations doesn't matter
02:00:52 <solrize> the compiler usually can figure out the type for you
02:00:57 <Cale> can I see the definition of process?
02:01:04 <AMcBain> Uh ... where did process go?
02:01:10 <AMcBain> (I just noticed it was missing too)
02:01:21 <Cale> Probably cut off. Hpaste limits lengths of pastes
02:01:25 <Cale> (in an annoying way)
02:01:28 <solrize> however it helps a lot to figure out and annotate the top level functions in a program
02:02:03 <AMcBain> http://hpaste.org/6655#a2
02:02:44 <Cale> okay...
02:03:01 <Cale> offsol :: Int -> [[Bool]]
02:03:26 <AMcBain> Oh damn.
02:03:34 <AMcBain> I changed my mind twice and went back to 1 and 0 ...
02:03:41 <AMcBain> forgot to update everything ..
02:04:06 <AMcBain> Wow it compiles now.
02:04:58 <AMcBain> It works!
02:05:01 <AMcBain> Sweet!
02:05:04 <AMcBain> Thank you all!
02:05:07 <solrize> cool :)
02:05:30 <solrize> that is a neat thing about haskell, once you get the compiler to stop complaining the program generally works
02:05:45 <AMcBain> I think overall, I only ended up with one stupid function. I didn't quite like putting invert back.
02:06:36 <solrize> you could break out those nested ifs into "case" expressions
02:07:35 <AMcBain> well I suppose, but it works, so I'm going to leave it. But I will consolidate some other small functions like getxy into invert, as that's the only place I use it,
02:08:04 <AMcBain> on second thought, it looks nicer if I don't.
02:10:16 <AMcBain> Well it's already code commented (as well as the scheme was) so I'll finish "packaging it up" tomorrow into the professors preferred format. As for right now, I get to go to sleep. :)
02:10:27 <AMcBain> Thanks a lot.
02:10:32 <solrize> that click function is incomprehensible, can you compute the row and column and put them into a let or something?
02:11:39 <AMcBain> Well the idea was that click was still operating under the 2d-board-as-a-single-list-number input.
02:11:59 <AMcBain> Otherwise those invert( invert( lines would have x and y in them and be super long.
02:12:35 <Cale> AMcBain: The nice thing about Haskell's type system is that while it might "get in your way" for a bit, usually your program will work once it typechecks.
02:12:44 <AMcBain> But it is also due to me converting it that way from my shuffle homework ...
02:12:48 <AMcBain> Seems so.
02:13:41 <Cale> This is true to varying degrees depending on how much you lean on it, but it really does eliminate about 90% of the dumbest things which would be runtime bugs in most languages.
02:14:19 <solrize> maybe something like:       let (row, column) = i `divMod` (length list)
02:15:28 <AMcBain> well what is amazing to me is just how many languages Kate has some kind of syntax interaction for, whether it be recognizing comments or highlighting the other end of a parenthesis pair ...
02:17:08 <tennin> one lesson I quickly learned when I started actually doing work with Haskell is that taking time to set up proper datatypes for your stuff is always always always worth it, no matter how much of a stupid scripting task it is
02:20:20 <AMcBain> I'm just glad I finished. This professor is a hard grader, and I didn't really have the option of turning in the assignment in Scheme. (he would take it, but major point hit) Though at least turning it in in Scheme was better than not turning it in at all (that would cost a -3 points ....) :P
02:24:41 <DRMacIver> dcoutts_: Next problem. :) THe latest parser appears to be barfing on non-ascii characters (problem shows up with the author name of hsx. Presumably others).
02:25:04 <AMcBain> night
02:25:30 <mgdtgd> is there a simple way to install ghc6.8 on debian etch? I already added haskell-unsafe to my sources.list, but I can't find a 6.8 package
02:26:01 <Cale> mgdtgd: I'd probably go with the generic linux binary from the GHC website
02:26:32 <mgdtgd> should I remove the 6.6 package beforehand?
02:26:51 <Cale> It shouldn't really matter, but it might be slightly confusing to have both.
02:32:54 <mgdtgd> it takes my poor old Pentium II forever to unzip it...
02:42:14 <cjs_> You think that's bad, see how long it takes to build ghc from source.
03:04:15 <solrize> it only took a few minutes to build ghc from source on the midrange box i'm using now
03:04:18 <solrize> building gcc takes hours
03:09:19 <quicksilver> that can't have been a full build?
03:09:24 <quicksilver> that sounds really odd
03:09:33 <quicksilver> ghc took 8 hours on my G4
03:09:40 <quicksilver> on my current machine it takes a good 40 minutes IIRC
03:09:43 <quicksilver> and this is a fast machine
03:10:17 <solrize> hmm maybe more than a few minutes, but not hours or anything like that
03:10:22 <Baughn> runplugs: /tmp/MpehV17370.o: unknown symbol `__stginit_oeiszm0zi1_MathziOEIS_' <-- Any idea what causes this?
03:10:27 <solrize> gcc was ridiculous
03:10:41 <solrize> because i had to keep rebuilding it in order to run its tests
03:11:01 <doserj> Baughn: you don't have the oeis package installed
03:11:08 <solrize> set aside a day to hack on it, type "svn update" first thing in the morning, and the whole day was blown :(
03:11:29 <Baughn> /home/svein/.ghc/x86_64-linux-6.8.2/package.conf: (...) oeis-0.1
03:11:46 <solrize> but that was with a 512 meg machine that was swapping its brains out
03:12:23 <Baughn> doserj: That's a "yes, I do"
03:12:32 <doserj> :)
03:12:33 <solrize> http://reddit.com/r/programming/info/2xlwd/comments/c2xorw  hmm
03:16:15 <Baughn> doserj: Moreover, checking the installed .o file reveals that the symbol does exist. Not suprising, all things considered.
03:24:40 <MarcWeber> @seen beschmi
03:24:40 <lambdabot> I haven't seen beschmi.
03:27:00 <Cale> solrize: I'm not sure that I completely agree with that comment. Space leaks are fairly rare, strictness annotations usually don't add much weight when you need them, and generally fix the problem in a fairly permanent way. (Unless GHC starts doing significant amounts of common subexpression elimination, which doesn't seem too likely.)
03:27:47 <solrize> i've had space leaks but i'm not used to laziness
03:27:50 <ertai> @where stream
03:27:50 <lambdabot> I know nothing about stream.
03:27:54 <ertai> @where stream fusion
03:27:55 <lambdabot> I know nothing about stream.
03:27:57 <ertai> @where stream-fusion
03:27:58 <lambdabot> I know nothing about stream-fusion.
03:28:00 <ertai> @where fusion
03:28:01 <lambdabot> I know nothing about fusion.
03:28:14 <matthew-_> @where fission
03:28:14 <lambdabot> I know nothing about fission.
03:28:23 <ertai> :)
03:28:27 <Cale> @google stream fusion Don Stewart
03:28:32 <lambdabot> http://portal.acm.org/citation.cfm?id=1291220.1291199
03:28:32 <lambdabot> Title: Stream fusion
03:29:04 <ertai> I'm wondering if http://www.cse.unsw.edu.au/~dons/code/streams/list where uptodate repos
03:29:06 <lambdabot> Title: Index of /~dons/code/streams/list
03:29:29 <quicksilver> Cale: rare is in the eye of the beholder.
03:29:31 <solrize> i'm pretty bothered by strings being lists of chars, so we end up with bytestring and its reimplementation of a lot of basic list functions that were supposedly polymorphic.  bytestring is great work but that it's needed is a sign of breakage
03:29:42 <quicksilver> cale: that is, things are rare until they keep happening to you :)
03:29:55 <solrize> clean has a primitive string type and that probably helps it with some benchmarks
03:30:38 <solrize> dons has a good paper on stream fusion, if you're looking for that
03:31:09 <solrize> with dcouts and someone whose irc name i don't know
03:31:13 <solrize> http://www.cse.unsw.edu.au/~dons/papers/CLS07.html
03:31:14 <lambdabot> Title: Stream Fusion: From Lists to Streams to Nothing at All
03:31:16 <solrize> if that person is on irc :)
03:31:44 <Cale> quicksilver: Well, I wouldn't expect an average of more than one space leak per moderate-sized project. Let's say 1000 lines of Haskell, and once you involve the profiler, they're usually not so hard to track down.
03:32:09 <opqdonut> yeah, the profiler is great
03:32:14 <Cale> Usually the fix involves using foldl' somewhere.
03:32:21 <opqdonut> once you learn how all the different flags work
03:32:32 <solrize> :t maximum'
03:32:34 <lambdabot> Not in scope: `maximum''
03:32:38 <solrize> :t minimum'
03:32:39 <lambdabot> Not in scope: `minimum''
03:32:40 <solrize> hmm
03:32:46 <opqdonut> Cale: i became a proponent of writing implicit folds explicitly after one such case
03:32:49 <opqdonut> :)
03:33:34 <Cale> Accumulating parameters and lazy state are the usual suspects.
03:33:49 <Cale> (and left folds tend to capture a lot of that)
03:34:40 <opqdonut> sometimes lazy fields in records are the culprit too
03:35:14 <Cale> Yeah, when you're doing lots of updates to the record fields.
03:47:56 <solrize> whats the diff btw an implicit fold and an explicit one?
03:49:46 <Cale> solrize: by implicit one, he means a recursive function which could be expressed as a fold (but isn't)
03:49:51 <opqdonut> yeah
03:50:03 <solrize> you mean explicit recursion instead of a fold?
03:50:12 <solrize> heh i always heard that was an antipattern
03:50:21 <opqdonut> which one?
03:50:43 <opqdonut> i probably should've said "express catamorphisms as folds" or something ;)
03:51:33 <solrize> gaaah i look up catamorphism in wikipedia and it says something about initial algebras
03:51:40 <solrize> i click on that and it's off in the weeds
03:51:44 <Baughn> > let x=x in [1,2,3,x] -- So that works.. any other edge cases I should look at?
03:51:45 <Cheiron>  [1,2,3,Exception: <<loop>>
03:51:46 <lambdabot>  Exception: <<loop>>
03:52:12 <opqdonut> edge cases of what?
03:52:20 <Baughn> Lambdabot evaluation
03:52:25 <opqdonut> ah
03:52:30 <Baughn> Places where it doesn't quite work like ghci
03:56:28 <inca0> Hello, I run into problems when installing wxhaskell. Is there someone who could help me a bit?
04:13:52 <mgdtgd>  why is it that character sets always cause the most cryptic problems?
04:14:43 <mgdtgd> I want to look up some rows in a utf8 postgres database
04:15:05 <Baughn> mgdtgd: Because not everyone agrees to use utf8. Also, unicode is a mess.
04:15:18 <mgdtgd> it works when I filter for a word without umlauts
04:15:22 <Baughn> Although, miraculously, not more messy than natural languages are to begin with
04:15:26 <mgdtgd> it breaks for words with umlaut
04:15:44 <mgdtgd> and I've tried everything!
04:15:49 <solrize> mgdtgd i had a problem like that because of lack of nkfc normalization
04:16:53 <mgdtgd> nginn karet foundation for cambodia? north korea freedom coalition? nelson knights football club?
04:17:28 <solrize> i forget what it stands for
04:17:36 <DRMacIver> Hm. Yesterday I wrote a Python program which calls out to a Haskell program. Today people are talking about a SoC project for a Python-Haskell bridge. Nice. :)
04:17:39 <solrize> it means there's a codepoint for letter with umlaut
04:18:05 <solrize> but you can also represent the letter as the non-umlauted version composed with the umlaut as a separate code
04:18:05 <solrize> "composing diacritic"
04:18:40 <mgdtgd> oh dear
04:18:59 <solrize> http://en.wikipedia.org/wiki/Unicode_normalization
04:19:00 <lambdabot> Title: Unicode normalization - Wikipedia, the free encyclopedia
04:19:00 <pjd> mgdtgd: http://en.wikipedia.org/wiki/Unicode_normalization
04:19:00 <lambdabot> Title: Unicode normalization - Wikipedia, the free encyclopedia
04:19:07 <solrize> nfkc i meant
04:19:28 <mgdtgd> the really strange thin is that inserting works just fine. without UTF8.String magic.
04:20:03 <solrize> i think it's best to normalize before doing anything else with the strings
04:20:12 <solrize> i forget which normalization is the one you want
04:20:22 <solrize> are you having a bug where some accented characters work and others don't?
04:20:39 <mgdtgd> no, they all cause SqlErrors
04:20:39 * SamB wonders who the heck anonymous is
04:21:07 <solrize> samb, on this channel/
04:21:29 <solrize> ?
04:21:33 <SamB> solrize: no, the one that decided that the church of scientology is going down
04:21:39 <solrize> oh
04:21:40 <mgdtgd> looking for an ü produces ERROR:  invalid byte sequence for encoding "UTF8": 0xe3bc64
04:21:43 <solrize> what brought that up?
04:21:46 <Baughn> SamB: Well, I'm one
04:22:32 <mgdtgd> ö is the  same thing, but with 0xe3b66c
04:22:33 * SamB was reading about it on the megatokyo board, and thought #haskell would know -- doesn't #haskell know everything?
04:22:38 <solrize> i'll guess that's a composed diacritic
04:22:45 <solrize> 4chan.org i think, samb
04:22:55 <Baughn> SamB: Anonymous isn't a group. Anonymous is in your own heart.
04:23:36 <SamB> Baughn: oh. I didn't know my heart made youtube videos!
04:23:59 <Baughn> SamB: That'd be other peopl's hearts, I imagine
04:24:32 <SamB> oh ;-)
04:24:40 <mgdtgd> now if I do a decodeString before passing it to HDBC I get 0xf66c6c25...
04:24:54 <SamB> good, because I it would be pretty crazy if my heart was more up-to-date on the news than I was
04:25:56 <pjd> mgdtgd: that error message is correct
04:25:58 <DRMacIver> wikipedia actually has a good article on them. But the summary version is that they're a 4chan joke which seems to somehow have turned serious.
04:26:10 <DRMacIver> This is unsettling to say the least. :)
04:26:21 <pjd> ü and ö should be c3bc and c3b6 respectively
04:26:29 <SamB> I dunno. Is it that unsettling if they take down the CoS?
04:26:40 <Baughn> DRMacIver: It caused people to think. When you think about the CoS, you get angry.
04:26:48 <mgdtgd> pjd: now if I knew why they aren't
04:26:58 <ToRA> mgdtgd: what happens if you use encodeString?
04:27:07 <mgdtgd> 0xe383e2
04:27:11 <DRMacIver> Yes and no. I agree very strongly with what they're doing. I'm a little nervous about them as a group.
04:27:23 <SamB> Baughn: that's why the CoS discourages thinking?
04:27:30 <Baughn> They aren't a group. They're a bunch of individuals with almost zero coordination who happen to have the same goals.
04:27:33 <mgdtgd> when looking for böll
04:27:41 <solrize> http://python.org/doc/lib/module-unicodedata
04:27:42 <Baughn> SamB: Presumably
04:27:43 <lambdabot> Title: 4.9 unicodedata -- Unicode Database
04:27:43 <DRMacIver> That's a group in my books. :)
04:27:52 <SamB> yeah, my books also
04:27:56 <DRMacIver> It may not be an organised one, but nevertheless.
04:28:11 <Baughn> No, no. They're a set, not a group. ^_^
04:28:11 <SamB> like a really well-compartmentalized resistance!
04:28:24 <SamB> *groan*
04:28:50 <pjd> mgdtgd: well, it doesn't seem to be (de)composition
04:29:09 <pjd> in decomposed form, those are 6fcc88 and 75cc88
04:30:47 <mgdtgd> i've put this line into my function:
04:30:49 <mgdtgd>     writeFile "./err.log" ((show aName)++" "++(show $ toSql aName)++" "++(show $ toSql $ decodeString aName)++" "++(show $ encodeString aName))
04:30:56 <mgdtgd> aName is the string
04:31:18 <mgdtgd> this is what it produces:
04:31:18 <mgdtgd> "b\195\182ll" SqlString "b\195\182ll" SqlString "b\246ll" "b\195\131\194\182ll"
04:31:50 <SamB> huh. my urxvt displays the diaeresis off-center when I use the decomposed version
04:32:59 <mgdtgd> i think "b\246ll" should work
04:33:08 <mgdtgd> but it doesn't...
04:33:33 <Deewiant> Ä Ä
04:33:44 <Deewiant> same here, off-center
04:33:51 <SamB> hmm, apparantly using zero-width characters confuses my shell or it's libraries
04:34:17 <mgdtgd> ah the joys of international charactersets
04:34:35 <mgdtgd> it would have been easier to convert all languages to ascii
04:34:38 <Deewiant> I honestly wonder what the point of decomposition is
04:35:21 <mgdtgd> maybe it has something to do with the client_encoding option in postgres?
04:35:22 <SamB> Deewiant: well, so fonts don't need to contain all variants of everything is probably part of it
04:35:22 <pjd> Deewiant: to have n+m+... codepoints instead of n*m*...
04:35:43 <mgdtgd> i've set it to utf8
04:35:45 <SamB> or did you mean "What is the point of combining characters"
04:35:46 <desegnis> mgdtgd: 246 is the (not encoded) Unicode code point for ö
04:35:57 <mgdtgd> hm
04:35:59 <solrize> http://en.wikipedia.org/w/index.php?title=This_Is_Sp%C4%B1n%CC%88al_Tap&redirect=no
04:36:00 <lambdabot> http://tinyurl.com/2kjnwv
04:36:04 <SamB> U+F6 is the codepoint
04:36:23 <solrize> so you can have an umlauted n like that :)
04:36:30 <mgdtgd> f6 = 246
04:36:32 <SamB> possibly I need more zeros for the totally official syntax
04:37:04 <SamB> oh, wait, desegnis didn't say what I thought he said
04:37:12 <SamB> the "not" threw me
04:37:19 <Deewiant> okay, so what's the point of having composed characters, then? ;-)
04:37:25 <desegnis> SamB, heh, ok
04:37:38 <SamB> Deewiant: well, like pjd said
04:38:15 <Deewiant> SamB: I mean, why have Ä as its own codepoint when you can use the combining ¨
04:38:30 <Deewiant> historical reasons, I know that, but is there a good reason?
04:38:45 <pjd> Deewiant: the small number of precomposed characters are a practical concession, i think
04:39:00 <desegnis> mgdtgd: encodeString and decodeString are not the best thing for type safety... Ideally, [Char] would always store Unicode, and for byte sequences we'd use [Word8] or ByteString. But maybe the db lib you use does not allow this clean distinction
04:39:25 <pjd> to ease transition and such, and allow common programs to get by with little or no support for composition
04:41:58 <mgdtgd> type safety wouldn't matter much if it worked...
04:42:29 <mgdtgd> I don't really understand why I need UTF8.String at all
04:42:44 <mgdtgd> after all I put stuff in the database without using functions from there
04:42:52 <mnislaih> Igloo: have you noticed that Glome runs in constant space with +RTS -N2
04:43:02 <mgdtgd> why shouldn't I get it out without using them
04:43:18 <mnislaih> Igloo: I am testing with your version here
04:43:40 <desegnis> mgdtgd: I mean, with that distinction in types, you *would* know from the types when you have to encode or decode
04:43:58 <mgdtgd> desegnis: ah, of course
04:44:18 <mnislaih> Igloo I am using (parmap rnf) and ' forever $ display scene' to make sure
04:44:44 <mnislaih> so, this means the memory leak is an RTS thing ?
04:46:48 <desegnis> mgdtgd: If the problem is rooted in how HDBC handles SqlString, you may try to circumvent the problem by using SqlByteString, and do explicit conversions
04:58:23 <mgdtgd> aha! using fromString from Data.ByteString.UTF8 eliminates the SqlError!
04:58:39 <mgdtgd> unfortunately no rows are returned
04:58:53 <SamB> mgdtgd: is that surprising in any way?
04:59:13 <mgdtgd> I expected one returned row
04:59:31 <SamB> your DBMS probably doesn't support comparing unicode strings in a reasonable way
04:59:57 <mgdtgd> that's not an answer I want to hear
05:00:19 <SamB> well, did you use the exact same characters that appear in the DB?
05:00:23 <mgdtgd> LIKE has to work with utf8 on postgres 8.1
05:00:58 <mgdtgd> i think so
05:06:17 <mgdtgd> how would I normally get a ByteString out of a String?
05:06:27 <mgdtgd> without unicode magic
05:11:54 <Baughn> mgdtgd: Unicode magic.
05:13:03 <Baughn> You need something that will turn a String into [Word8] of some description. writeFile (or friends) will do that, but doing it without the file.. well, there should be a way. Whatever putChar does, I suppose.
05:14:39 <mgdtgd> fromString turns my "%böll%" to "%bÃ£Â¶ll%" no wonder no rows are returned
05:16:52 <Baughn> mgdtgd: As a sanity check, what does writeFile do?
05:17:32 <quicksilver> ehm
05:17:37 <quicksilver> writeFile doesn't do anything clever.
05:17:59 <quicksilver> mgdtgd: pack and unpack, normally
05:18:05 <quicksilver> if it's a word8 ByteString, then
05:18:21 <quicksilver> pack . map (fromIntegral.fromEnum)
05:18:22 <quicksilver> say
05:18:35 <Baughn> writeFile does necessarily turn a String into a byte array
05:18:43 <quicksilver> yes, but not in a clever way.
05:18:48 <quicksilver> just by using fromEnum/toNum.
05:18:51 <quicksilver> toEnum.
05:19:01 <Baughn> Are you saying it stores ucs-32?
05:19:16 <mgdtgd> writefile does: %bÃ¶ll%
05:20:16 <Baughn> mgdtgd: Is that correct?
05:20:52 <mgdtgd> i think so
05:21:10 <mgdtgd> Ã¶ should be ö when read as utf8
05:21:37 <mgdtgd> yes they are
05:22:09 <quicksilver> Baughn: no, it stores 8-bit truncated unicode
05:22:16 <quicksilver> Baughn: which is almost, but not quite, 8859-1
05:22:30 <quicksilver> (if you're asking the question I think you are)
05:23:49 <Baughn> quicksilver: How.. interesting
05:24:36 <Baughn> quicksilver: Yes, that was what I was asking. I didn't consider the possibility that writeFile might be lossy.
05:29:18 <quicksilver> Baughn: the entire haskell IO infrastructure is lossy.
05:29:21 <quicksilver> it's a bit strange.
05:29:25 <quicksilver> there are proposals to change it.
05:33:51 <mgdtgd> shouldn't encodeString.decodeString = id ?
05:37:12 <mm_freak_work> hello people
05:37:22 <opqdonut> hi
05:37:57 <mm_freak_work> does GHC optimize an IArray into a mutable array, when it makes sense?
05:38:21 <quicksilver> no
05:38:24 <opqdonut> mmm no
05:38:30 <mm_freak_work> ok, thanks
05:38:37 <opqdonut> some extra copying happens anyway
05:40:19 <mgdtgd> i've had enough of this. i'll just replace every umlaut with an underscore and be done with it
05:52:43 <DRMacIver> Hm. Idle thought. TagSoup is basically an inverse CPS transform of a SAX parser, isn't it?
05:52:55 <quicksilver> I don't think so, no.
05:53:02 <quicksilver> SAX parsers understand nesting, don't they?
05:53:21 <DRMacIver> I don't think so. Maybe I've misunderstood what SAX involves
05:54:03 <quicksilver> hmm, yes, you're right.
05:54:06 <quicksilver> I think it is quite similar.
05:54:43 <hansfbaier> DRMacIver: what is a cps transform?
05:54:58 <DRMacIver> Continuation passing style
05:55:14 <hansfbaier> DRMacIver: thanks!
05:55:26 <DRMacIver> I'm not sure I could produce an adequate explanation of it offhand. :)
05:56:23 <hansfbaier> DRMacIver: never mind, can look it up. Know what CPS is, just the acronym..
05:56:23 <DRMacIver> Basically my observation is that in tag soup you pattern match on tag starts | text | tag ends, and in SAX you pass functions (returning something in a state monad) which deal with each of the cases tag start, text and tag end
05:56:31 <DRMacIver> ok. :)
05:57:00 <hansfbaier> DRMacIver: if you want to keep track of nesting in SAX you might want to use stacks.
05:57:06 <DRMacIver> Right.
05:57:29 <DRMacIver> I know how to keep track of nesting in a SAX parser. I'm just saying that it doesn't handle it out of the box.
05:57:36 <DRMacIver> Which is the same as tag soup
05:58:01 <DRMacIver> I'm not sure if what I'm saying is actually true in any formal sense. But it seems intuitively right.
05:58:11 <quicksilver> of course you could choose to use tagsoup in a precisely SAX fashion if you like
05:58:21 <quicksilver> haskell makes inversion of control a much simpler thing than Java :)
05:58:26 <DRMacIver> Yeah. You could certainly build a SAX parser on top of tag soup.
05:58:31 <DRMacIver> It really does.
05:59:03 <DRMacIver> But you'd need some form of continuations to build tag soup on top of a SAX parser (which is what I was thinking about how to do when I came up with this idea actually)
06:00:48 <Igloo> mnislaih: Hmm, that's even more interesting
06:01:12 <mnislaih> ah Igloo : I just replied to the mail thread
06:01:25 <mnislaih> yes, it is
06:01:58 <DRMacIver> Also I've just rewritten the only Haskell code we were using at work in python. Sigh. :)
06:01:59 <Igloo> If there were 2 clobks it might make more sense, but there are 16  :-)
06:02:00 <mnislaih> I don't know how par is implemented or where, but this hints at a memory leak in its implementation
06:02:09 <Igloo> Err, blocks
06:51:23 <ADEpt> can someone enlighten me: why encode/decode from Data.Binary take/return internals of ByteString, and not ByteString proper? Am I missing something obvious?
06:52:07 <quicksilver> they don't return internals
06:52:11 <quicksilver> it just feels that way
06:52:17 <quicksilver> because of how the module imports are returned.
06:52:34 <quicksilver> (it's a problem with error message generation, really)
06:53:06 <ADEpt> quicksilver: care for a quick look at hpaste?
06:53:19 <quicksilver> the most likely problem is that Data.Binary uses lazy BS
06:53:22 <quicksilver> and you have imported strict BS
06:53:26 <quicksilver> and that's the mismatch
06:53:26 <ADEpt> quicksilver:  http://hpaste.org/6653
06:53:50 <quicksilver> import qualified Data.Bytestring.Lazy as BS
06:53:50 <ADEpt> quicksilver: Lazy BS are imported. Error is:     Couldn't match expected type `BS.ByteString'
06:53:50 <ADEpt>            against inferred type `Data.ByteString.Lazy.Internal.ByteString'
06:53:50 <ADEpt>     In the first argument of `BS.append', namely `z'
06:53:53 <quicksilver> and try that :)
06:54:16 <ADEpt> quicksilver: that's already there
06:54:21 <kosmikus> ADEpt: not in your paste
06:54:26 <ADEpt> oh
06:54:32 <ADEpt> anyway, it doesnt help
06:54:59 <Gilly> any ideas how to do this faster: stuff = stuff' [1..] [0,0..] where stuff' (x:xs) (y:ys) = y : stuff' xs (map (\(z,y) -> if z `mod` x == 0 then y + x else y) (zip xs ys))
06:55:20 <Gilly> it produces a list of sum of proper divisors of natural numbers
06:55:52 <Gilly> the problem is i'd require a bit more than the first 5000 numbers or so in a reasonable time :)
06:56:07 <quicksilver> ADEpt: what error do you get if you change it to that?
06:56:12 <kosmikus> ADEpt: are you sure? Data.ByteString.Lazy.ByteString and Data.ByteString.Lazy.Internal.ByteString are the same type ...
06:56:45 <ADEpt>     Couldn't match expected type `BS.ByteString'
06:56:45 <ADEpt>            against inferred type `bytestring-0.9.0.1:Data.ByteString.Lazy.Internal.ByteString'
06:56:45 <ADEpt>     In the first argument of `BS.append', namely `z'
06:56:45 <ADEpt>     In the expression: BS.append z zs
06:56:45 <ADEpt>     In the definition of `do_rearr':
06:57:04 <ADEpt> So, error stays the same.
06:57:09 <kosmikus> looks like you're using two different versions of the bytestring package
06:57:15 <kosmikus> one that binary is compiled with
06:57:20 <kosmikus> and one you're importing directly
06:57:24 <quicksilver> yes, that is what I was about to guess.
06:57:46 <quicksilver> note the version number in the error message
06:57:58 <quicksilver> what does ghc-pkg list say about your bytestring version?
06:57:59 <ADEpt> :( explicit package version should have tipped me earlier ...
06:58:16 <ADEpt> indeed, I have two version. But I dont imagine how ..
06:58:28 <quicksilver> you should probaly recompile data.binary
06:58:34 <quicksilver> that will then hopefully pick up the new version
06:58:36 <ADEpt> anyway, thanks!
06:58:41 <doserj> Gilly: trying every number as a divisor is wasting many cycles. use prime factors
06:58:43 <quicksilver> (or does data.binary have a versioned dependency?)
06:58:51 <kosmikus> ADEpt: as a quick test, you can try to call ghc with -package bytestring-0.9.0.1 and see if it works then
06:59:32 <Gilly> doserj: i'm not trying every number as a divisor afaik. i am constructing the list from begin to end
06:59:56 <Gilly> doserj: first i add 1 to every element in the list, then i move to 2 and add that to every second element and so on
07:00:39 <Gilly> i guess i'll have to resort to starrays :/
07:02:17 <ADEpt> kosmikus: i've hided "the other" bytestring package and it works. Thank you!
07:03:10 <quicksilver> \o/
07:03:39 <doserj> Gilly: you can try making it strict in y, to get some improvement.
07:04:41 <doserj> (inside the map)
07:05:10 <Gilly> doserj: hmm, how do i accomplish that?
07:06:05 <doserj> e.g., \(z,y) -> y `seq` if ...
07:06:43 <Gilly> same difference
07:07:22 <doserj> then you probably have to think about your algorithm
07:08:01 <Gilly> yea... i guess those zips and maps are going to kick the stack a bit :) i'll try to implement the same using starrays
07:12:02 <desegnis__> Gilly: Are you sure your function is correct, though? take 10 stuff = [0,1,1,3,1,6,1,7,4,8], and that doesn't look like the sums of proper divisors of [0..9] really
07:12:28 <desegnis__> oh wait
07:12:38 <Gilly> for 1 the sum of proper divisors is 0, for 2 it's 1, for 3 it's 1, for 4 it's 1+2 = 3 and so on
07:13:04 <desegnis__> ah, it's [1..8], not [0..9], of course :)
07:13:21 <desegnis__> sry
07:13:30 <Gilly> yea, i guess i did it right mathematically :)
07:14:23 <desegnis__> sure
07:14:48 <Gilly> just not very efficient :P
07:18:51 <doserj> Gilly: how far do you have to go? sum $ map (sum.properDivisors) [1..50000] takes less than 20secs here (in ghci, using only lists and trial divisions)
07:20:42 <Gilly> doserj: 1000000
07:24:00 <doserj> Gilly: and you have to sum them all up?
07:24:09 <Gilly> no
07:24:14 <Gilly> i just have to have them :)
07:24:14 <EvilTerran> there's gotta be some really cunning algorithm for that
07:25:17 <dcoutts_> DRMacIver: re utf8, yes I've got a fix for that too
07:25:44 <quicksilver> I believe it's probalby faster to generate primes and prime factorise the numbers
07:25:53 <quicksilver> (and derive the divisors from the prime factors)
07:26:36 <opqdonut> Gilly: projecteuler?
07:27:15 <DRMacIver> dcoutts_: Thanks
07:27:17 <Gilly> opqdonut: actually yes
07:27:32 <Gilly> i think my method should work fine on C arrays :P
07:27:32 <dcoutts_> DRMacIver: I can now cabal list ok, I'm pushing the patches now...
07:28:44 <opqdonut> Gilly: you can probably take a shortcut by factoring the number
07:28:46 <dcoutts_> DRMacIver: the hsx package sneaked in after I'd added strict utf8 checking but before we'd updated the hackage version of cabal to enforce the check
07:29:17 <dcoutts_> DRMacIver: once we get hackage updated all uploaded packages will have to have valid utf8 .cabal files
07:33:02 <Gilly> http://hpaste.org/6657 <- this equivalent C code runs really fast
07:33:27 <Gilly> should also explain the algorithm rather clearly :)
07:34:30 <DRMacIver> dcoutts_: Thanks again. :)
07:34:53 <DRMacIver> dcoutts_: I'll check that it's working for me when I get home.
07:35:06 <doserj> Gilly: I guess you actually need more than only arr[284] at the end :)
07:35:16 <Gilly> yes :)
07:36:43 <doserj> Gilly: using this algorithm with a container structure like Data.Map should be within an order of magnitude of the C-code, i think (given sufficient strictness)
07:37:32 <Gilly> hmm
07:37:58 <quicksilver> looks like a good case for Data.Sequence perhaps, since you're doing lots of updates.
07:38:22 <quicksilver> but it might be simpler just to use an array, if an array is what you want
07:38:34 <Gilly> array will be what i want yea...
08:08:01 * byorgey hands out honey oat lambdas
08:08:44 <bogner> honey oat lambdas: healthy AND functional!
08:08:55 <skorpan> dc-Ankan: hej
08:23:02 <dancor> why doesn't this compile: import Control.Applicative hiding (`<|>`)
08:23:33 <Deewiant> my guess is that the syntax is wrong, you want ((<|>))
08:23:38 <dancor> ah, tx
08:23:45 <Deewiant> `` makes a non-infix function infix
08:23:57 <Deewiant> <|> is already infix, we want to specify it as non-infix so (<|>)
08:24:04 <svat> So, what would be a good way to solve the game that AMcBain was doing here yesterday? http://www.abeautifulmind.com/games/blackout/index.html
08:24:05 <lambdabot> Title: A Beautiful Mind :: Blackout
08:25:06 <svat> In principle, it can be solved in O(n^3) for an nxn board because it's just solving a system of linear equations... but that's probably a messy way to do it.
08:26:43 <quicksilver> to solve the game, or to code it?
08:27:05 <quicksilver> because solving it is more maths than programming, surely?
08:28:03 <quicksilver> the solution to it follows by observing that if you can affect set X and set Y, you can affect symettric different of X and Y
08:28:08 <svat> I don't believe there would be any nice way to express the solution to an arbitrary board position -- no "closed form", so to speak.
08:28:35 <svat> so it must involve programming?
08:28:59 <svat> quicksilver: without affecting X and Y?
08:29:03 <doserj> svat: you can also observe that ordering doesn't matter
08:29:11 <quicksilver> svat: es.
08:29:12 <quicksilver> yes
08:29:24 <quicksilver> move X followed by move Y affects (sym diff X Y)
08:29:26 <svat> doserj: yes, I got so far as observing that ordering doesn't matter, so each button is clicked on at most once.
08:29:47 <quicksilver> then you need to check if "single squares" lie in the clouse under symettric difference
08:29:51 <quicksilver> which I strongl suspect they do
08:29:58 <quicksilver> then it's "obvious" than any position is solvable
08:30:02 <quicksilver> and you can construct a way to do it
08:30:11 <svat> yes, how? :)
08:30:22 <quicksilver> just by adding together all the single square flips
08:30:28 <doserj> (mod 2)
08:30:29 <quicksilver> once you've proved you can flip any chose single square
08:30:31 <quicksilver> it's obvious
08:30:49 <quicksilver> (searching for a minimal number of moves solution would be much harder)
08:30:55 <svat> doserj: so for each square, depending on what you want it to be, you can write down a constraint saying that the sum of all its neighbours should be 0 or 1. (mod 2)
08:31:34 <svat> quicksilver: yes, I was speaking about constructing a minimal (or any?) solution, not proving that it can be solved.
08:31:42 <quicksilver> any is easy.
08:31:45 <quicksilver> minimal is hard.
08:31:53 <doserj> quicksilver: are you sure?
08:31:54 <quicksilver> (my proof that it can be solved was constructive)
08:32:02 <quicksilver> doserj: of which part?
08:32:09 <doserj> that minimal is hard
08:32:14 <quicksilver> no, I'm not sure.
08:32:19 <svat> quicksilver: no, that wasn't a proof -- when you change something you might end up affecting things you don't want to change.
08:32:35 <svat> Actually there might be a neat way to solve this in Prolog :)
08:32:38 <quicksilver> svat: do you understand what I meant by symettric difference?
08:33:23 <svat> quicksilver: yes, I do. But when you flip X and then Y, you have affected X\Y and Y\X, but not the symmetric difference
08:33:29 <svat> Oh sorry
08:33:30 <svat> right
08:33:37 <quicksilver> X\Y and Y\X is the symmetric difference :)
08:33:56 <quicksilver> and you understand that if I had a way of flipping squares one by one, it would be easy?
08:34:18 <quicksilver> so the question that remains is "do all the single squares lie in the symmetric-difference-closure of the given moves"
08:34:35 <svat> Yes...
08:34:39 <quicksilver> which doing some examples in my head I suspect is true by I haven't checked properly.
08:35:49 <quicksilver> middle square certainly does
08:35:56 <quicksilver> so do all the corner squares
08:35:58 <quicksilver> that's enough
08:36:00 <quicksilver> the answer is yes :)
08:36:21 <yuriyp> it was mentioned many times that HPC can monitor coverage of QuickCheck tests
08:36:30 <yuriyp> But how is it done in reality?
08:36:35 <doserj> next question: how many sets of tiles are there, such that fliping all of them doesn't change the board
08:36:49 <yuriyp> I am asking since HPC requires compiled program and QuickCHeck is using bare source
08:37:14 <quicksilver> you write a compiled program which runs all your quickcheck checks?
08:37:20 <quicksilver> (and sends the output to stdout, persumably)
08:37:23 <quicksilver> and you run HPC over that.
08:37:57 <dcoutts_> erm, hpc is more like profiling
08:38:07 <dcoutts_> you build your program using -fhpc
08:38:28 <dcoutts_> then when you run the program (that runs all the QC tests) it writes out the hpc profile
08:38:45 <dcoutts_> then you use the hpc tool to generate coverage reports from the profile data
08:39:00 <svat> quicksilver: but would this enumeration of the closure of the symmetric difference operation be polynomial-time for an n×n board?
08:39:52 <quicksilver> svat: yes, I'm sure it is at worst quadratic
08:40:01 <quicksilver> I haven't run through a larger board in my head though
08:40:23 <yuriyp> quicksilver: dcoutts_: so basically I will need to call my tests directly without using quickCheck script?
08:41:08 <dcoutts_> yuriyp: I don't know what the quickCheck script does, but yes you need to run a compiled program that runs all your tests
08:42:08 <yuriyp> quicksilver: dcoutts_: but in this case how do I itereate over all prop_*? Or do I need to call quickCheck on each of defined prop_* explicitely?
08:42:35 <dcoutts_> yuriyp: we usually use a driver script that calls each of the properties
08:43:01 <dcoutts_> eg see the QC test driver in xmonad or bytestring
08:43:30 <yuriyp> dcoutts_: thanks for pointing me in right direction. will do
08:49:04 <ertai> @src on
08:49:04 <lambdabot> (*) `on` f = \x y -> f x * f y
08:50:31 <quicksilver> that's an awesome definition for showing off haskell syntax :)
08:50:33 <svat> Does that mean it only works with (*), or does * stand for an arbitrary function?
08:50:46 <quicksilver> it stands for an arbitrary function
08:50:49 <quicksilver> just like f does
08:50:59 <mauke> it only works with functions called f
08:50:59 <svat> Ok, awesome then :)
08:56:06 <glen_quagmire> > (on (+ 1) id) 1 2
08:56:07 <lambdabot>      Occurs check: cannot construct the infinite type: b = b -> c
08:56:07 <lambdabot>     Probabl...
08:56:40 <mauke> > on (+) id 1 2
08:56:41 <lambdabot>  3
09:00:44 <malcolmw> > sortBy (compare `on` snd) [(1,2),(4,1)]
09:00:45 <lambdabot>  [(4,1),(1,2)]
09:03:13 <Baughn> @. djinn type on
09:03:14 <lambdabot> f a b c _ = a (b c) (b c)
09:03:42 <Baughn> lambdabot: ..bad bot
09:07:09 <desegnis> Is it advisable today to use the ByteStringized Network.HTTP by nominolo and Jonas Ådahl?
09:07:35 <nominolo> desegnis: no
09:08:35 <nominolo> desegnis: would curl work for you? http://hackage.haskell.org/cgi-bin/hackage-scripts/package/curl-1.3.1
09:08:36 <lambdabot> http://tinyurl.com/36p9nd
09:08:42 <desegnis> nominolo, a pity. I guess the reason is that it isn't tested thoroughly?
09:08:57 <ahunter> http://www.haskell.org/pipermail/haskell-cafe/2006-December/020107.html is this the best way to measure execution time (writing benchmarks, etc.)
09:08:58 <lambdabot> Title: [Haskell-cafe] "computational time" always 0.0 in this example..., http://tinyurl.com/2kon2o
09:09:13 <nominolo> yeah, i got a strictness bug report a while ago
09:09:22 <nominolo> also we leak sockets
09:09:45 <nominolo> also the header-parsing is still string-based
09:10:00 <nominolo> (i guess that's where the strictness bug comes from)
09:10:27 <nominolo> unfortunately, i don't have the time to work on it.  it'd be a decent SoC-project, though
09:11:04 <desegnis> nominolo, what string data type does the curl binding use?
09:11:18 <desegnis> Not ByteString, I guess?
09:11:31 <nominolo> it should.  that was the goal at least
09:12:30 <desegnis> ah, but I don't find the word ByteString in the code :)
09:12:54 <nominolo> or, that was the goal of the SoC project last year.  but it seems that not the package that came out of that effort
09:13:25 <ertai> @pf \x y -> (x, f y)
09:13:25 <lambdabot> Maybe you meant: bf pl
09:13:31 <ertai> @pl \x y -> (x, f y)
09:13:31 <lambdabot> (. f) . (,)
09:13:42 <dolio> fmap f
09:13:53 <desegnis> hmm
09:14:01 <dolio> Or, if you already have the pair, that is.
09:14:32 <Deewiant> second f
09:14:33 <ertai> dolio: ((,) a) is a functor, but here it's the second
09:14:33 <dolio> @type \f -> uncurry (fmap f)
09:14:34 <lambdabot> forall a b b1. (a -> b) -> (b1 -> a, b1) -> b
09:14:45 <ertai> @type second
09:14:46 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
09:14:59 <Deewiant> @ty second id
09:15:00 <lambdabot> forall a d. (d, a) -> (d, a)
09:15:00 <dolio> > fmap (+1) (1,2)
09:15:01 <lambdabot>  (1,3)
09:15:15 <Deewiant> O_o
09:15:34 <gwern> @where glome
09:15:35 <lambdabot> I know nothing about glome.
09:15:38 <ertai> dolio: you're right, that's the opposite that would'n work
09:15:39 <Deewiant> @src ((,)) fmap
09:15:39 <lambdabot> Source not found. Where did you learn to type?
09:15:40 <dolio> fmap for the (,) w functor is second.
09:15:41 <gwern> nominolo: I think the curl binding on hackage predates the SoC attempt
09:15:46 <Deewiant> @src ((,) a) fmap
09:15:46 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
09:16:02 <ertai> thanks all
09:17:05 <gwern> @where+ glome http://syn.cs.pdx.edu/~jsnow/glome/
09:17:05 <dolio> @src (,) fmap
09:17:05 <lambdabot> It is stored.
09:17:05 <lambdabot> fmap f (x,y) = (x, f y)
09:17:34 <dolio> @type uncurry . fmap ?f
09:17:41 <lambdabot> forall a b c a1. (?f::a1 -> b -> c) => (a -> a1) -> (a, b) -> c
09:17:55 <dolio> @type curry . fmap ?f
09:17:56 <lambdabot> forall a b a1 b1. (?f::a1 -> b1) => ((a, b) -> a1) -> a -> b -> b1
09:18:11 <nominolo> gwern: i see
09:18:16 <dolio> @type curry (fmap ?f)
09:18:16 <lambdabot> forall b b1 a. (?f::b -> b1) => a -> b -> (a, b1)
09:18:21 <dolio> There we are.
09:20:34 <Jaak> what a strange syntax is that?
09:20:55 <Jaak> useful
09:21:48 <byorgey> Jaak: implicit parameters.
09:22:17 <byorgey> a little-known feature of ghc that no one uses much except as a sneaky way to do type inference with lambdabot.
09:22:40 <Jaak> got to remember this
09:23:18 <dolio> Yeah. Don't use implicit parameters as actual implicit parameters, though. :)
09:23:33 <quicksilver> they serve as a hook into GHC's type inference
09:23:47 <quicksilver> allowing you to ask it questions like "which type do you infer for this subexpression"
09:23:59 <quicksilver> (that's not their original purpose ;)
09:24:29 <dolio> Their original purpose is to be like dynamically scoped variables.
09:24:35 <dolio> Only they aren't, exactly.
09:24:48 <glen_quagmire> > let f a ?b = a + b in f 1
09:24:48 <lambdabot>  Parse error in pattern at "in" (column 20)
09:25:24 <dolio> > let f a = a + ?b in f 1
09:25:24 <lambdabot>  Parse error at "?b" (column 15)
09:25:39 <dolio> Yeah, that's not going to get through the extra @eval parser.
09:26:21 <mauke> @eval no.
09:33:19 <schemelab> MyCatVerbs: ping?
09:33:55 <dolio> @type let x = (let ?p = 1 in \n -> n + ?p) in x
09:33:56 <lambdabot> forall a. (Num a) => a -> a
09:34:06 <dolio> That's the key, I think.
09:34:30 <dolio> x doesn't depend on an implicit parameter ?p.
09:51:05 <mm_freak_work> i'm confused…  do i use MArray for mutable arrays or is it better to use IOArray, STArray or StorableArray?
09:51:51 <mauke> isn't MArray just a generic interface for all types of mutable arrays?
09:51:55 <ddarius> MArray is a common interface for those.
09:52:22 <mm_freak_work> ah, ok…  that's clears things up
09:52:36 <dons> yeah, just pick one type. they share the same interface
09:53:27 <mm_freak_work> suppose i'm working outside of the IO monad and i need an array of 256 bytes, which i'll pass on and manipulate recursively
09:53:33 <mm_freak_work> what's the way to go?
09:53:46 <dons> outsidoe of iO, 256 bytes? do you need to mutate it?
09:53:47 <mauke> outside of IO + mutability means ST
09:53:53 <mm_freak_work> dons: yes
09:53:54 <dons> how about an IntMap ?
09:54:17 <dons> you want to thread it through pure code?
09:54:31 <mm_freak_work> dons: really?  i need to access _and_ manipulate by index
09:54:39 <dons> right
09:54:54 <mm_freak_work> i don't want to thread it
09:55:14 <dons> i guess i'd need to see the code, but I'd start with an IntMap
09:55:24 <mm_freak_work> in the ideal case it's a single array in memory, corresponding to C's char [256]
09:55:47 <mm_freak_work> and in C i'd pass pointers to that array
09:56:02 <mm_freak_work> (uint8_t instead of char, to be more precise)
09:56:56 <mm_freak_work> dons: still IntMap?
09:57:26 <mm_freak_work> i'll only access by index…  a lookup will never be necessary, and speed is of importance
09:58:07 <mm_freak_work> (i'd show you code, but there isn't any yet)
09:58:59 <ddarius> mm_freak_work: You mean you'll only access it sequentially?  Or what do you mean by "access by index" if not "lookup"?
09:59:11 <dons> ok, if spee is of all importance, then you need to be in IO or ST
10:00:27 <mm_freak_work> ddarius: like in C: array[i]
10:00:50 <mm_freak_work> there'll never be a lookup in the sense of a 'search'
10:01:06 <roconnor> @type mapM
10:01:10 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
10:02:32 <mm_freak_work> that's why IntMap doesn't appear appropriate to me…  i'll try STArray
10:04:54 <ddarius> mm_freak_work: I doubt IntMap has any particular support for searching values.  However, it should support sparse keys which is presumably unnecessary for you.
10:05:18 <mm_freak_work> ddarius: searching by key i mean
10:05:30 <mm_freak_work> array lookup by index is O(1), and that's just what i need
10:07:31 <ddarius> "searching" by key would just be a lookup which would just be the same as indexing an array.  If I remember correctly, IntMap lookup is O(log log n), so asymptotics are hardly an issue it's constant factors that would be a problem.
10:08:25 <wli> O(lg(lg(n))) is pretty good.
10:08:46 <roconnor> average case
10:09:24 <roconnor> interpolation searching I assume.
10:12:20 <mm_freak_work> STArray gives me O(1) lookup and in an optimized case costs only a single instruction =)
10:12:24 <mib_w9qikmrh> hey guys i am creating a propercase function that updates all the '"i" in a text and the first char after a fullstop, but it seems to be giving me some trouble
10:13:27 <Botje> what do you have so far?
10:13:36 <mib_w9qikmrh> gonna post what i have
10:13:59 <mib_w9qikmrh> gonna post the code i have
10:14:11 <Botje> k
10:14:18 <Botje> use hpaste or paste.lisp.org :)
10:14:28 <mm_freak_work> many thanks people…  evening =)
10:14:56 <mib_w9qikmrh> just post it
10:18:32 <ehird> is haskelldb still dead? :)
10:18:53 <Botje> mib_w9qikmrh: hmm, hpaste seems to be down, can you give the url?
10:19:05 <mrd> ehird: it's not dead, just resting
10:19:23 <mib_w9qikmrh> ok
10:19:37 <mib_w9qikmrh> http://hpaste.org/6659
10:19:43 <ehird> which is best to use for new apps: takusen or hdb?
10:20:22 <catface> can someone help me with a simple typeclasses problem at http://hpaste.org/6660?
10:20:30 <Lemmih> ehird: I'd recommend hsql with static SQL.
10:20:52 <ehird> Lemmih: You of little types.
10:21:00 <ehird> & a fetish for ugly languages :D
10:21:12 <ehird> @hoogle [a] -> a -> a -> [a]
10:21:13 <lambdabot> No matches, try a more general search
10:21:17 <ehird> @type ap
10:21:18 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
10:22:03 <Botje> mib_w9qikmrh: can you annotate that paste and show how you expect xchange to be used?
10:23:12 <ehird> @type (\ f l -> do { o <- f; r <- l; return (o r)})
10:23:13 <lambdabot> forall (t :: * -> *) t1 t2. (Monad t) => t (t1 -> t2) -> t t1 -> t t2
10:24:12 <mauke> @src liftM2
10:24:12 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
10:24:23 <ehird> yes
10:24:23 <shapr> @paste
10:24:23 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:24:25 <shapr> hmm
10:24:36 <skorpan> does anyone know if there is any swedish term for "purely functional"?
10:24:48 <lament> @shapr
10:24:48 * lambdabot throws some pointy lambdas at
10:24:54 <ehird> is there any takusen examples anywhere?
10:24:54 <shapr> bwahaaa
10:24:59 <shapr> lament: Who came up with that?
10:25:04 <mauke> @shapr lament
10:25:04 <mib_w9qikmrh> ok
10:25:04 * lambdabot hits lament with a hammer, so he breaks into a thousand pieces
10:25:05 <ehird> skorpan: 'delicious'
10:25:18 <ehird> @ehird I wonder
10:25:18 <lambdabot> Unknown command, try @list
10:25:21 <ehird> d'aww
10:25:29 <mauke> @shapr ehird
10:25:29 * lambdabot activates her slap-o-matic...
10:25:37 <mdmkolbe|ubuntu> Is there a good link describing what the lambda-k and lambda-i calculuses are? (Google's failed me b/c of the greek characters.)
10:25:43 <byorgey> shapr: I think your nick gets spell-corrected to 'slap'
10:25:59 <shapr> Amusing
10:26:11 <shapr> skorpan: funktionel sprak is about my limit.
10:26:13 <lament> lambdabot's spell correction is way too aggressive
10:26:25 <byorgey> how's it going, shapr?  don't see you around here as much these days =)
10:26:34 <mauke> s/ggressiv/wesom/
10:26:37 <skorpan> shapr: "funktionellt språk" :) i want to add the "purely" adjective
10:26:40 <shapr> byorgey: busy
10:26:41 <lament> (what is the command that i actually wanted called?)
10:26:48 * shapr fixes hpaste
10:26:52 <skorpan> lament: M-x flyspell
10:27:17 <lament> no, the command that summons shapr
10:27:17 <byorgey> get-shapr
10:27:24 <mauke> @get-slap
10:27:24 <lambdabot> shapr!!
10:27:27 * shapr snickers
10:27:35 <ehird> @get-foo
10:27:35 <lambdabot> Unknown command, try @list
10:27:38 <ehird> heh
10:27:39 <lament> ah
10:27:44 <mdmkolbe|ubuntu> Is there a good link describing what the lambda-k and lambda-i calculuses are? (Google's failed me b/c of the greek characters.)
10:27:45 <ehird> @get-milk
10:27:45 <lambdabot> Unknown command, try @list
10:27:56 <mdmkolbe|ubuntu> @get-ehird
10:27:56 <lambdabot> Unknown command, try @list
10:28:08 <hpaste>  (anonymous) annotated "propercase" with "(no title)" at http://hpaste.org/6659#a1
10:28:30 <ehird> so anyone re: hdb/takusen
10:30:10 <Botje> mib_w9qikmrh: okay. so instead of tracking the last character, why not track if you're at the first character after a period (or start of string)?
10:31:07 <hpaste>  glen_quagmire annotated "(no title)" with "(no title)" at http://hpaste.org/6660#a1
10:31:19 <glen_quagmire> catface: that's for you
10:31:33 <glen_quagmire> i just put some pragmas and it compiled
10:32:47 <catface> thanks
10:33:41 <ehird> :/
10:34:40 <mib_w9qikmrh> well like in microsoft word, the first char in a line is converted to uppercase
10:35:55 <roconnor> @go 1 EUR in USD
10:35:55 <lambdabot> 1 Euro = 1.5688 U.S. dollars
10:36:41 <hpaste>  Botje annotated "propercase" with "(no title)" at http://hpaste.org/6659#a2
10:37:06 <Botje> mib_w9qikmrh: check that. I'm afraid i left your post at the top of mine, ignore that :)
10:37:18 <catface> glen_quagmire: did the 'comp id (+) 3 4' call work?
10:37:40 <EvilRanter> glen_quagmire, i'm pretty sure FunctionalDependencies
10:37:41 <EvilRanter>  implies MultiParamTypeClasses
10:37:41 <EvilRanter> . i think FlexibleInstances does too, and it might imply FunctionalDependencies
10:37:41 <EvilRanter>  too
10:37:48 <EvilRanter> whups. newlines.
10:38:01 <gbacon> @inf
10:38:01 <lambdabot> Maybe you meant: bf id kind ring unpf wn
10:38:11 <EvilRanter> @help wn
10:38:11 <lambdabot> I perform dictionary lookups via the following 13 commands:
10:38:11 <lambdabot> all-dicts ... Query all databases on dict.org
10:38:11 <lambdabot> devils ...... The Devil's Dictionary
10:38:11 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
10:38:11 <lambdabot> elements .... Elements database
10:38:13 <lambdabot> [9 @more lines]
10:38:14 <EvilRanter> ah
10:38:23 <EvilRanter> @help ring
10:38:23 <lambdabot>  @ring <user>, CSE phonebook
10:38:54 <gbacon> I sent Cale a patch that lets lambdabot talk to bls.gov's inflation calculator
10:39:07 <gbacon> kind of depressing
10:39:11 <gbacon> kind of very depressing
10:39:38 <EvilRanter> glen_quagmire, "The -XFlexibleInstances flag loosens these restrictions considerably. Firstly, multi-parameter type classes are permitted..." - ok, so MPTCs, but not fundeps
10:40:31 <mib_w9qikmrh> i doesn't seem to be uppercasing after the .
10:40:33 * ehird wonders, is there a generic 'fail'?
10:40:37 <ehird> like
10:40:38 <opqdonut> what's the actual problem with MPTCs? i've heard there are some aspects of their type inference that are not agreed upon?
10:40:51 <ehird> thing :: (FailingMonad m a) => a -> m b
10:41:05 <opqdonut> :t fail
10:41:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
10:41:07 <catface> can anyone get that comp id (+) 3 4 call to work?
10:41:08 <ehird> class (Monad m) => FailingMonad m a where thing :: a -> m b
10:41:10 <ehird> to be precise
10:41:18 <ehird> class (Monad m) => FailingMonad m a where thing :: forall a. a -> m b
10:41:19 <EvilRanter> opqdonut, i think people just get antsy about fundeps, because they're more logic programming than functional programming
10:41:19 <ehird> no, wait
10:41:20 <ehird> not forall
10:41:26 <ehird> class (Monad m) => FailingMonad m a where thing :: a -> m b   -- there
10:41:36 <glen_quagmire> catface: sorry. i misunderstood your question. comp id (+) 3 4 doesn't work for me
10:41:37 <EvilRanter> ?hoogle MonadError
10:41:37 <lambdabot> Control.Monad.Error.Class.MonadError :: class Monad m => MonadError e m
10:41:46 <EvilRanter> ?src MonadError
10:41:46 <lambdabot> class (Monad m) => MonadError e m | m -> e where
10:41:46 <lambdabot>     throwError :: e -> m a
10:41:46 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
10:41:59 <EvilRanter> ehird, does that suit?
10:42:05 <glen_quagmire> EvilRanter, catface i'm too much of a noob to see what's goin on
10:42:16 <ehird> EvilRanter: should do, but i remembered i'm not in a monad
10:42:17 <ehird> silly me
10:42:17 <ehird> :D
10:42:46 <catface> thanks anyway
10:44:23 <ehird> hmm
10:44:30 <ehird> you can serialize Cont continuations can't you?
10:45:40 <Lemmih> ehird: There's no standard way of serializing functions.
10:49:52 <mib_w9qikmrh> it doesn't seem to be working as it should
10:50:25 <skorpan> @pl \to -> not $ makesCheck from to (player piece) game
10:50:25 <lambdabot> not . flip (flip (makesCheck from) (player piece)) game
10:50:28 <skorpan> wow
10:51:12 <roconnor> wow?
10:51:46 <lament> ffi code has so much monad stuff in it :(
10:52:02 <glen_quagmire> can fibonacci number function turned into tail recursion?
10:52:40 <lament> glen_quagmire: can fibonacci number function be expressed with a loop?
10:52:40 <roconnor> glen_quagmire: yes
10:52:47 <skorpan> roconnor: my assumption about what lambdabot would generate was correct
10:53:07 <roconnor> glen_quagmire: I think every recursive function can be turned into tial recursion.
10:53:28 <roconnor> hmm
10:53:33 <lament> roconnor: i woludn't go as far.
10:53:37 <ahunter> roconnor: true, but in many cases, you pretty much have to convert to CPS
10:53:57 <glen_quagmire> fib 36 takes long time to compute
10:54:00 <ehird> Lemmih: Hmm, you're right. But a Cont monad which can serialize is not hard, I think..
10:54:14 <ahunter> glen_quagmire: how are you computing it?
10:54:21 <ehird> you use (>>=) to build up a list. Then the continuation is just an integer index.
10:54:32 <ehird> 'run' just starts from that element of the list, and runs each action in turn from there
10:54:35 <ehird> I *think*
10:54:44 <glen_quagmire> naively. in my lisp interpreter
10:54:45 <Deewiant> > let fibs = fix ((0:) . scanl (+) 1) in fibs !! 36
10:54:46 <lambdabot>  14930352
10:54:57 <ehird> So if I write this where would it go? Control.Monad.Cont.Serializable?
10:55:06 <roconnor> ehird: that doesn't sound like a continuation at all.
10:55:14 <ehird> roconnor: well, yeah, it is...
10:55:17 <ehird> if you store the list along with it
10:55:20 <ehird> which isn't the important bit
10:55:28 <ehird> if you have
10:55:31 <ehird> [foo,bar,baz]
10:55:43 <ehird> then a continuation at one point might be [bar,baz]
10:55:45 <glen_quagmire> > let { fib 0 = 1; fib 1 = 1; fib n = fib (n - 1) + fib (n - 2); } in fib 36
10:55:47 <lambdabot>  24157817
10:55:48 <ehird> if foo is a callCC
10:55:56 <ehird> which can be reduced to 1
10:55:58 <Deewiant> glen_quagmire: fib 0 = 0 :-)
10:56:00 <ehird> as the 'starting index'
10:56:12 <ahunter> Deewiaqnt: depends on the definiton
10:56:36 <roconnor> fib  0 = 0 is the definition.
10:56:40 <ahunter> glen_quagmire: that's an extremely expensive way to calculate fibonacci numbers.  try using an iteration
10:56:43 <ehird> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-Cont.html this is pretty trivial
10:56:43 <Deewiant> ahunter: of course, you can start from 3 and 5 if you feel like it :-P
10:56:44 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/33vlgl
10:56:45 <ehird> I bet I can do it
10:57:17 <ahunter> roconnor: eh, mathematically, F_0 = 0  and f_0 = 1 both get substantial use
10:57:36 <dolio> > let fib = fib' (0,1) ; fib' (l,r) 0 = l ; fib' (l,r) n = fib' (r, l+r) (n-1) in fib 36
10:57:36 <lambdabot>  14930352
10:57:38 <roconnor> I've never seen f_0 = 1
10:57:41 <Deewiant> I've always seen only f_0 = 0
10:58:06 <roconnor> ehird: I don't see what lists have to do with continuations.
10:58:07 <monochrom> The advantage of f_0=0 is that it keeps everyone happy.
10:58:20 <ahunter> *shrug* check the right discrete math/combinatorics work
10:58:49 <roconnor> ahunter: I prefer to simiply not believe you. :)
10:58:52 <roconnor> *simply
10:58:56 <ehird> roconnor: uhh, very simple
10:59:02 <ehird> if you transform (a >>= b >>= c) into [a,b,c]
10:59:07 <dolio> It probably depends on whether you typically index your sequences starting with 1 or 0.
10:59:09 <hpaste>  lament pasted "Is this what FFI-using code is supposed to look like?" at http://hpaste.org/6663
10:59:10 <ehird> now, if we have
10:59:18 <ehird> (callCC blah >>= b >>= c) -> [callCC blah, b, c]
10:59:33 <ehird> then 'blah's continuation can be represented by that list, paired with '1' (the starting index of the continuation)
10:59:45 <monochrom> Why list?
11:00:09 <ehird> monochrom: simplest way to reason about it -- 'starting index' etc
11:00:35 <roconnor> ehird: what about the continiuatons generated by Cont?
11:00:43 <ehird> roconnor: what about them
11:01:01 <roconnor> how are you going to serialize them?
11:01:09 <ehird> roconnor: you won't. you'll use this monad instead.
11:01:41 <ehird> however, if you want to emulate it's callCC it's not hard
11:01:49 <roconnor> ehird: So your monad is different from Cont?
11:02:01 <ehird> the function to pass is something like (\x -> runContOn lst myIndex x)
11:02:06 <ehird> where lst, myIndex, etc. come from the monad
11:02:38 <ehird> callCC f = do ci <- currentIndex; l <- myList; f (runContOn l ci)
11:02:48 <roconnor> ehird: but there is no general way from Cont to your representation.
11:02:50 <ehird> currentIndex :: (SuperContMonad m) => m Int
11:03:23 <ehird> roconnor: well, duh
11:04:35 <glen_quagmire> hah (fib 36) still runs without output
11:04:52 <glen_quagmire> i declare fib 36 to be bottom
11:06:52 <Lemmih> > fib 36
11:06:53 <lambdabot>  24157817
11:06:53 <lament> fib N is defined to be fib (N-1) + fib (N-2) for N > 1, N < 36. For N >= 36, fib N is defined to be bottom.
11:06:53 <dolio> OMG, Lisp is slow, use Haskell!
11:07:44 <monochrom> dumb algorithm is slow. use fast algorithm.
11:08:38 <dolio> Write you naive fibonacci in assembly for maximum performance!
11:08:38 <opqdonut> :D:D
11:08:51 <opqdonut> ?remember monochrom dumb algorithm is slow. use fast algorithm
11:08:51 <lambdabot> Done.
11:09:08 <glen_quagmire> optimization is evil of all roots
11:10:14 <opqdonut> evil is the optimixation of all roots
11:11:43 <glen_quagmire> for some computers (especially 32bits), fib 24 is bottom
11:12:41 <glen_quagmire> no i'm wrong. bottom is conceptual thing. not machine dependent
11:14:12 <byorgey> fib 24, fib 36, and fib 100000 are not bottom, since given enough time + memory they would compute a value.
11:14:24 <roconnor> What is a free monad?
11:14:51 <byorgey> a ploy to get people hooked on Haskell
11:14:55 <byorgey> "the first monad is free..."
11:15:17 <Baughn> Don't. You'll get them banned.
11:15:35 <glen_quagmire> http://www.alpheccar.org/en/posts/show/86
11:15:36 <lambdabot> Title: Coproduct of free monads and web development
11:15:51 <glen_quagmire> free monad is related to HTML
11:16:06 <dolio> It's like a term algebra.
11:17:11 <dolio> Where you have constructors corresponding to return, bind, etc.
11:17:12 <dolio> I think, at least.
11:17:53 <roconnor> dolio: what ehird has reminds me a lot of what I think a free monad would be.
11:18:20 <dolio> data MyMonad a where Return :: a -> MyMonad a ; Bind :: MyMonad a -> (a -> MyMonad b) -> MyMonad b ; ...
11:19:16 <roconnor> dolio: a naive mapping of operators to constructors would seem to not capture as much of the equivalence relation on Monads as one might be able to.
11:20:34 <dolio> I'm not sure exactly what you mean.
11:21:06 <dc-Ankan> @pl let k = do x <- getChar; putChar x; in let s = do k; s in s
11:21:06 <lambdabot> (line 1, column 35):
11:21:06 <lambdabot> unexpected ";"
11:21:06 <lambdabot> expecting pattern or "="
11:23:01 <skorpan> @pl \x -> something (snd x) $ map (\t -> concat $ fst t) ls
11:23:01 <lambdabot> flip something (map (join . fst) ls) . snd
11:33:53 <ehird> roconnor: free monad?
11:42:09 <roconnor> ehird: yeah, I'm not exactly sure what it is, but what you are doing makes me think "free monad"
11:42:41 <roconnor> I glanced through http://www.alpheccar.org/en/posts/show/86
11:42:43 <lambdabot> Title: Coproduct of free monads and web development
11:42:54 <roconnor> but it didn't really explain anything to me when I skimmed it.
11:46:00 <ehird> hmm, why isn't there an STT
11:46:01 <ehird> :(
11:46:15 <roconnor> STT?
11:46:24 <ehird> roconnor: ST, as a transformer
11:47:49 <byorgey> isn't there some reason ST has to be the base monad in a stack of transformers?  like IO?
11:48:14 <Baughn> There is. It does Evil Things.
11:48:40 <ahunter> Like what?
11:48:50 <Baughn> Mutating memory
11:49:22 <Botje> IM IN UR MEMORIEZ, MUTATING.
11:49:34 <ahunter> Oh, it actually is implemented that way?  I had thought that State s a = s -> (a,s)
11:49:39 <b_jonas> but it's already an S transformer
11:49:48 <dolio> The explanation of free monads is in the Data Types a la Carte paper, I think.
11:49:55 <lament> Katie stood there, mutating quietly.
11:50:02 <b_jonas> STT would be like ErrorTT
11:50:16 <byorgey> ahunter: yes, State is that way, but ST is very different from State
11:50:19 <dolio> And ST isn't a transformer because it has to ensure linear access to the implicit heap, which can't be done as a transformer.
11:50:51 <dolio> For instance, STT [] would probably be bad.
11:51:54 <b_jonas> by linear, you mean array-like (as opposed to linear-time)
11:51:56 <b_jonas> ?
11:52:04 <dolio> I mean like linear logic.
11:52:12 <ahunter> effectively, each ref only use once
11:52:22 <ahunter> *each variable
11:52:25 <dolio> Like uniqueness typing in Clean.
11:52:37 <b_jonas> eek
11:52:42 <b_jonas> oh, I see
11:52:46 <b_jonas> that kind of linear
11:52:46 <Baughn> You could presumably write a STT yourself, though
11:54:22 <b_jonas> using a StateT Map or StateT IntMap or something?
11:54:43 <dolio> @go monad own mutable adt
11:54:45 <lambdabot> http://citeseer.ist.psu.edu/chen97rolling.html
11:54:45 <lambdabot> Title: Rolling Your Own Mutable ADT --- A Connection between Linear Types and Monads -- ...
11:55:08 <ehird> STT would be very possible ofc
11:55:15 <ehird> it would just use up a lot of space storing all previous values for time-travel :)
11:55:36 <dolio> Well, yeah, you could make STT but it'd lose mutable update.
11:55:42 <dolio> Which is kind of the point of ST.
11:56:20 <ehird> dolio: well, no.
11:56:23 <ehird> you could do STT
11:56:26 <ehird> it would just time-travel to previous values
11:56:33 <SyntaxNinja> @seen dons
11:56:33 <lambdabot> dons is in #ghc, #xmonad, #haskell-soc and #haskell. I last heard dons speak 42s ago.
11:56:45 <dons> yo, on my way SyntaxNinja
12:12:24 <dons> http://reddit.com/info/6dmow/comments/ xmonad the video
12:13:43 * mrd waits for xmonad the flamethrower
12:13:52 <gnuvince> dons: is that the presentation you did a while back?
12:14:07 <dons> nope, that's byorgey's new one
12:14:12 <gnuvince> cool
12:14:12 <dons> from fringedc last week
12:15:40 <roconnor> I assume FringDC isn't a folk music festival?
12:16:48 <byorgey> roconnor: it would be awesome if I had sung a song about xmonad at a folk music festival though =)
12:17:06 <byorgey> roconnor: it's a DC-area group dedicated to non-mainstream programming languages
12:19:02 <gnuvince> byorgey: was Rich Something (Clojure guy) there?
12:19:13 <byorgey> gnuvince: I don't know
12:19:41 <zeesh> Hi there everyone
12:19:56 <byorgey> gnuvince: there's one point where the camera pans briefly around the dark room... =)
12:20:02 <byorgey> hi zeesh
12:20:09 <zeesh> i need someone to help me with soem haskell programming and i am willing to pay
12:20:42 <sarehu_> with sexual favors?
12:20:44 <zeesh> its an assignment i have and if someone is intrested in helping me out with it i am ready to pay
12:20:54 <zeesh> no with money
12:21:02 <zeesh> not with sexual favors
12:21:26 <zeesh> so anyone who is intrested plz pm me or email me at mastmunda_z@hotmail.com
12:21:34 <gwern> zeesh: what is the point of paying for an education and not doing the work yourself?
12:21:35 <sarehu_> sigh
12:22:13 <zeesh> well gwern u r absolutely right abt tht but if u have been in a hospital for two weeks and still not recovered, some desperate measures have to be taken
12:22:25 <zeesh> and bcoz a lot rides on my this assignment thus i cannot miss on it
12:22:32 <gwern> like speaking to your professors...
12:22:36 <zeesh> i did
12:22:46 <gwern> 'halp! i can has halp pls?'
12:22:46 <roconnor> zeesh: less rides on this assignment than you think.
12:22:48 <zeesh> its the last assignment and the main project
12:22:53 <zeesh> so it has to be done
12:23:00 <zeesh> well 30% aint less my friend
12:23:29 <roconnor> It's just one course; it's not like failing the course will destroy your life.
12:23:32 * gwern attempts to think of an appropriate \b\ism. Epic fail? Zeesh cat is sheesh? ur doing it wrong?
12:23:35 <dons> zeesh: if you were in hospital, you can generally get exemption under special circumstances
12:23:49 <roconnor> that too
12:23:49 <zeesh> i know
12:24:00 <zeesh> thnku for pointin tht out
12:24:06 <zeesh> i have done tht too
12:24:10 <zeesh> but i still wanna do it
12:24:19 <roconnor> ?
12:24:27 <zeesh> i still wanna do the assignment
12:24:34 <dons> asking here is a bad idea, since generally we either know, or are, your professors, when it comes to haskell stuff
12:24:43 <gwern> roconnor: well, it's possible that it'd set off a chain of consequences. makes zeesh fail thecourse, pushing him below a GPA, ending a scholarship he needs, making it financially impossible to attend, forcing him into dead-end job to pay off debts related to failed college stint, and so on
12:25:06 <zeesh> hahahahahah
12:25:15 <zeesh> tht could probably happen
12:25:32 <roconnor> well, you don't /really/ need a degree to get a programming job.
12:25:46 <zeesh> hhahahah yup true tht
12:26:02 <zeesh> well thnku for ur time everyone
12:26:05 <zeesh> have a good one
12:26:25 <dolio> dons communes with all the people in the world using Haskell using a large geodesic dome he built.
12:26:37 <gwern> in the US, two weeks in the hospital could mess you up pretty bad financially
12:26:40 <zeesh> but in case someone decides to make some money the email address is mastmunda_z@hotmail.com
12:27:06 <lament> u of montreal? i want to go there
12:27:11 <roconnor> I'm a little torn, 'cause the free market person in me thinks that zeesh doing the work is isomorphic to zeesh hiring someone to do the work.
12:27:22 * paolino istigate lamdabot to write to zeesh
12:27:43 <lament> roconnor: i would have no qualms helping him
12:27:50 <hhg> roconnor: maybe he can get a job as a programmer proxy and personally outsource his job to other people on the internet
12:27:58 <roconnor> hhg: exactly
12:28:01 <lament> no time ATM, though (and scared of online transactions)
12:28:02 <gwern> dolio: it's a large geodesic dome! so large it implements Fuller's cloud nine concept; and then #haskellers board it and it becomes Don Stewart's Flying Circus!
12:28:09 <roconnor> hhg: which is kinda like what a manager does.
12:28:10 * gwern notes that my joke was unexpected. and now for something copletely different
12:28:27 <lament> nobody... expects... gwern's jokes?
12:28:36 <hhg> roconnor: but first he has to learn correct spelling and change his email address, otherwise no one will take him seriously
12:28:39 <hhg> roconnor: hehe, true
12:28:46 <sarehu_> I just wish it wasn't described as "helping," speaking in code like that
12:29:01 <gwern> lament: they don't. did you?
12:29:15 <monochrom> It would suck if managers spelt and spoke like that.
12:29:38 <roconnor> lament: how much would you charge?  I'm thinking $200 an hour, but maybe I'm selling myself short.
12:29:50 <lament> it's "help" and not "work for" because the monetary compensation is likely to be below minimum wage
12:30:00 <lament> roconnor: hah
12:30:04 <roconnor> oh man
12:30:12 <roconnor> $200 an hour isn't below minimum wage.
12:30:23 <EvilTerran> "i can pay you... $10.34, and this stick of gum i found in my pocket
12:30:28 <monochrom> us$200 is selling short.  cdn$200 is much better. :)
12:30:37 <gwern> depends on how hard the problem is and how interesting. if it'd be useful to others, I'd give'im a discount for making it Free :)
12:30:41 <EvilTerran> @go 200 CAD in USD
12:30:42 <lambdabot> 200 Canadian dollars = 196.7536 U.S. dollars
12:30:47 <monochrom> See? :)
12:30:48 <EvilTerran> ...
12:30:54 <monochrom> err, nevermind :)
12:30:55 <hhg> @go 200 USD in ISK
12:30:56 <lambdabot> 200 U.S. dollars = 15,093.2005 Iceland kronur
12:30:59 <lament> a last assignment in a haskell course? it's unlikely to be particularly interesting or particularl hard
12:31:03 <EvilTerran> @go 1 GBP in USD
12:31:04 <lambdabot> 1 British pound = 2.0023 U.S. dollars
12:31:10 <EvilTerran> yay, that one still works
12:31:14 <wolverian> @goo 200 CAD in EUR
12:31:15 <lambdabot> 200 Canadian dollars = 125.416624 Euros
12:31:31 <roconnor> lament: oh, so I could be done in a hour... maybe less?
12:31:44 <monochrom> You can see I haven't been following the financial news lately :)
12:31:44 <gwern> lament: I'm thinking of emailig just to find out what the problem is. I'm kind of curous now
12:31:49 <roconnor> Do I need to institude some minimum number of hours?
12:31:56 * roconnor has never worked as a contractor before.
12:32:14 <lament> now, guys, please, form an orderly queue
12:32:50 <roconnor> zeesh is going to play us against each other.
12:32:55 <roconnor> we need to form a union!
12:33:03 <gwern> lament: only if the queue can be folded!
12:33:08 <\z> @go 200 USD in INR
12:33:08 <lambdabot> 200 U.S. dollars = 8,017.96023 Indian rupees
12:33:14 <\z> @go 200 INR in USD
12:33:15 <lambdabot> 200 Indian rupees = 4.9888 U.S. dollars
12:33:17 <gwern> roconnor: programmers? unionize? you'll sooner see cats stage a strike
12:33:20 <roconnor> perhaps a disjoint union.
12:33:28 <roconnor> or a coproduct.
12:33:35 <paolino> uhm a hotmail address for an haskeller  is not fair
12:33:40 <roconnor> or a cooproduct.
12:33:45 <roconnor> coop
12:33:50 <gwern> (a walkabout strike, I mean, not a sitin strike. cats do those all the time)
12:33:58 <roconnor> coopr
12:34:21 <roconnor> gwern: I don't think the wheat farmers go on strike.
12:34:54 <gwern> paolino: what would you prefer? gmail?
12:35:16 <ehird> hotmail? eek
12:35:18 <gwern> paolino: if he were much of a haskeel programmer, he wouldn't be so far behind he needs to hire someone....
12:35:39 <ehird> hm
12:35:43 <ehird> zeesh ain't a haskeller
12:35:50 <ehird> from a quick glance ;)
12:35:56 <roconnor> he is a haskell manager.
12:35:59 <lament> i really don't understand what the big issue is
12:36:07 * gwern looks forward to this year's april 1st RFC
12:36:08 <lament> so he wants somebody to do his homework for him. So what?
12:36:17 <ehird> lament: so he shouldn't ask in #haskell
12:36:17 <paolino> how is it , someone study haskell not being an haskeller ?
12:36:29 <ehird> paolino: because they're avoiding studying haskell and getting someone else to do it for them ;)
12:36:40 <lament> ehird: where else would he find people able to do it?
12:36:46 <roconnor> ehird: Why can people offer jobs on #haskell?
12:36:56 <roconnor> or should we make #haskell-jobs?
12:37:04 <paolino> seriously, what kind of study has haskell inside ?
12:37:22 <lament> ehird: if i had an actual haskell job to offer, and mentioned it here, would you be terribly upset?
12:37:27 <shapr> paolino: How do you define a Haskeller?
12:37:54 <gwern> it's a defection from the educational system; you are cooperating in devaluing the worth of a degree, which affects people other than the contractor and hirer
12:38:09 <sarehu> that's a great business plan.  make a language and market it as difficult and confusing, then charge people to do their homework for them
12:38:28 * shapr boings tiredly
12:39:21 <paolino> shapr: haskeller is someone who liked to stay above zero floor once he reached first floor
12:39:56 <shapr> I don't understand.
12:40:03 <roconnor> gwern: if you hire someone who delegates all the work to other people, isn't that observationally equivalent to hiring someone who knows haskell?
12:40:27 <lament> that's what's known as "referential transparency"
12:40:34 <roconnor> :D
12:40:39 <dcoutts_> depends what you're observing
12:41:05 <dcoutts_> if you're only looking at the work done, or the stuff learnt by a particular individual
12:41:23 <gwern> roconnor: not necessarily, if you assume that person A is given access to internal data they are not allowed to redistribute to other peoples B, C, and D
12:41:26 <roconnor> dcoutts_: what is this ``individual'' you speak of?
12:41:40 <dcoutts_> roconnor: it has object semantics, not value semantics
12:41:45 <dcoutts_> weird I know
12:41:52 <roconnor> that's fucked up
12:41:53 <Jedai> roconnor: Unfrotunately, referencial transparency isn't very valued in the real world, we live in IO
12:41:58 <lament> gwern: so you're saying you can't implement security in haskell?
12:41:59 <gwern> IP law! god's greatest gift to lawyers
12:42:16 <shapr> gwern: Is that what net neutrality is all about?
12:42:23 <Jedai> roconnor: ie, performance and quality of the code is observable
12:42:48 <roconnor> gwern: I don't find your A  and B, C, D argument very compelling.
12:43:05 <gwern> lament: code has color!
12:43:10 <lament> indeed, we already know the person A is a dirty cheat
12:43:21 <lament> so he would have no problems distributing private data to B, C and D
12:43:22 <shapr> gwern: Haskell code is a pleasing red.
12:43:22 <paolino> an haskeller is a one way valve slave
12:43:34 <shapr> C# code is a stoic blue.
12:43:42 <shapr> Java is pus yellow :-/
12:43:45 <gwern> shapr: heh. I was referencing http://ansuz.sooke.bc.ca/lawpoli/colour/2004061001.php
12:43:48 <lambdabot> Title: What Colour are your bits?
12:43:48 <roconnor> Jedai: right and if zeesh constantly delagates to people who produce quality code, then zeesh is effectively a quality haskell programmer.
12:44:06 <gbacon> where's that picture with the funny mashup of all the different metaphors used in monad tutorials?
12:44:24 <gbacon> a monad is a spacesuit with a basket of apples that can create tickets...
12:44:50 <Jedai> roconnor: I guess so, but isn't it better to directly employ those people then ?
12:44:58 <gwern> lament: not in full normal haskell; as a constructive proof, I proffer lambdabot...
12:45:28 <roconnor> Jedai: possibly.  Depends if zeesh is doing some quality work in mapping problems to programmers.
12:45:36 <lament> shapr: do you really think so?
12:46:03 <shapr> lament: Those are my colors.
12:46:22 <shapr> Different types have their own colors as well.
12:46:22 <lament> note that we're assuming that zeesh gets somebody good to do his assignment for him; otherwise, he still fails and nothing changes (except he loses money)
12:46:22 <roconnor> @quote comonad
12:46:22 <Jedai> roconnor: I guess if he really manage to always find good Haskell programmer for the task fast, then he is really a pearl (but I doubt zeesh has the connections for that yet) ^^
12:46:22 <gwern> shapr: do your colors run?
12:46:24 <lambdabot> sethg says: I feel like I still don't understand comonads.  Maybe I just need a Zen comaster to hit me with a costick and then I'll become coenlightened.
12:46:34 <shapr> Much like letters and numbers each have colors, and other connotations.
12:46:38 <shapr> gwern: Not so much.
12:46:39 <roconnor> @quote island
12:46:40 <lambdabot> ghc says: Unable to mmap( MAP_FIXED ) for Jump Islands
12:46:46 <roconnor> @quote island
12:46:46 <lambdabot> ghc says: Unable to mmap( MAP_FIXED ) for Jump Islands
12:46:56 <ehird> we don't live in IO
12:46:59 <lament> shapr: what about colorforth? :) and have you adjusted syntax highlighting to fit those colors?
12:47:01 <roconnor> where is that quote about comonads and islands?
12:47:09 <ehird> IO is the interface to US
12:47:16 <ehird> we're just a weird StateT with  ST in there somewhere
12:47:23 * mrd lives in the ST RealWorld
12:47:26 <ehird> many fictional universes are the same with an added Cont in there
12:47:36 <roconnor> @quote nuclear
12:47:36 <lambdabot> dons says: Binkley: yes, I'd love to see 'monads as nuclear waste' illustrated through dance, to something by Kate Bush
12:47:44 <shapr> lament: Nah, my syntax highlighting is adjusted to take advantage of the fact that I'm easily distractable. http://www.scannedinavian.com/~shae/Test_TutorRing.hs.html
12:47:45 <lambdabot> Title: Test_TutorRing.hs
12:47:58 <roconnor> @quote nuclear
12:47:58 <lambdabot> cjeris says: instance (TicTacToe a) => (GlobalThermonuclearWar a) where ...
12:48:04 <shapr> But most people just scream about their eyes burning.
12:48:07 <lament> i don't live in a monad. monads are a weird category-theory abstraction that's very far from the way the world works.
12:48:16 <shapr> @quote
12:48:16 <lambdabot> ozone says: when will bytestring be O(1) for all operations?
12:48:25 <dcoutts_> hah
12:48:27 <lament> shapr: wow, that's pretty painful to look at :)
12:48:47 <ehird> shapr: that's nice
12:48:48 <ehird> but painful
12:48:55 <shapr> lament: Works nicely for me. But no one else seems to want to look at it :-)
12:48:56 <ehird> tone it down a lil'
12:49:16 <roconnor> @quote sea
12:49:17 <lambdabot> Tac-Tics says: Haskell is 50% style and 60% research... and -10% code bloat
12:49:17 * shapr nominates ST Simon
12:49:26 <roconnor> @quote zoo
12:49:26 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
12:49:39 <shapr> ehird: There is a toned down version, sandalwood.
12:49:39 <roconnor> lambdabot isn't so good at remembering things is she?
12:49:42 <lament> shapr: especially the string literals are almost physically painful to look at
12:50:08 <shapr> lament: Thing is, I am easily distractable, so certain information just leaps into my head automatically. This color theme takes advantage of that.
12:50:24 <Saul_> Blurgh I need dependent types and extensible records for my project :S
12:50:33 <ilyak_> Hi *
12:50:37 <shapr> @quote dependent types
12:50:37 <lambdabot> No quotes for this person. Just try something else.
12:50:43 <shapr> @quote toke
12:50:43 <lambdabot> Heffalump says: (re the RealWorld# token) The compiler knows that it can implement the token using the  arrow of time
12:50:46 <shapr> @quote toked
12:50:46 <lambdabot> shapr says: I've toked on so many lambdas I'm getting dependent types
12:50:53 <ilyak_> Do I understand correctly that one can not do anything meaningful in >> operator
12:51:03 <shapr> ilyak_: Er, what?
12:51:05 <ilyak_> Because types of a and b are unknown
12:51:14 <shapr> !paste
12:51:15 <hpaste> Haskell paste bin: http://hpaste.org/
12:51:18 <shapr> Ok, still up.
12:51:21 <roconnor> Saul_: Oleg can do that.
12:51:42 <shapr> lament: ADHD can be an advantage if you do it right!
12:51:49 <Saul_> roconnor: Can it do all the other tricks that Haskell can do though?
12:51:53 <lament> > putStr "hi" >> putStr "bye"
12:51:54 <lambdabot>  <IO ()>
12:52:21 <ilyak_> IO's >> is black magic
12:52:21 <lament> Saul_: oh, it can do absolutely everything
12:52:21 <shapr> Oleg solves type problems by lifting them into the untyped world of the types themselves!
12:52:23 <roconnor> Saul_: er, I meant the person, not the language.
12:52:28 <lament> Saul_: in the type system
12:52:35 <shapr> @users
12:52:35 <lambdabot> Maximum users seen in #haskell: 472, currently: 458 (97.0%), active: 24 (5.2%)
12:52:52 <lament> shapr: it's a very sad type system where types are untyped
12:53:28 <shapr> I think you run into Russel's Paradox if types are also typed.
12:53:40 <shapr> And thus Epigram does not have general recursion.
12:53:41 <ilyak_> For example, I wanted to do a collector monad which is like Collector a >> Collector b = Collector a ++ b
12:53:56 <ehird> shapr: I want a turtle-type-system language
12:54:01 <ehird> values are just type-0s
12:54:04 <roconnor> shapr: if you startify the type levels, everything is good.
12:54:06 <shapr> argh
12:54:11 <lament> shapr: well, types are even typed in haskell
12:54:14 <roconnor> it's types all the way up.
12:54:15 <ehird> and a type-N's type is a type-(N+1)
12:54:19 <ilyak_> But I can't do that because I can't fixate a and b to be arrays
12:54:20 <shapr> lament: You're being kind...
12:54:20 <Saul_> Yeah well I'd rather not hack away in the typesystem, but have something that's actually handy
12:54:21 <Botje> shapr: your color-scheme aside, that remote function intrigues me
12:54:35 <Botje> do you know some keywords for variable argument functions in haskell?
12:54:37 <lament> shapr: have you looked at pure type systems?
12:54:41 <roconnor> Saul_: didn't Oleg develop a library for extensable records?
12:54:50 <lament> shapr: you CAN have an infinite tower of types but you lose type checking
12:55:07 <roconnor> lament: you don't lose type checking.
12:55:10 <cjb> "didn't Oleg develop.." ~= "Can Haskell do.."
12:55:11 <shapr> lament: Nah, Ed is encouraging me to do so, I'll probably get into it soon.
12:55:15 <shapr> cjb: hah!
12:55:24 <shapr> @remember cjb "didn't Oleg develop.." ~= "Can Haskell do.."
12:55:24 <lambdabot> Nice!
12:55:26 <lament> roconnor: just type inference?
12:55:46 <shapr> Botje: polyvariadic typeclasses, I think.
12:55:47 <Saul_> roconnor: I don't know
12:55:47 <roconnor> Type inference I'm not sure of.  It's pretty easy to lose.
12:55:49 <gwern> @quote develop
12:55:50 <lambdabot> lispy says: the biggest reason most developers i know don't fix a bug is because they don't know it exists yet
12:56:16 <gwern> @quote develop
12:56:16 <lambdabot> cjb says: "didn't Oleg develop.." ~= "Can Haskell do.."
12:56:25 <lament> roconnor: i think you might lose typechecking too. I'm talking about pure type system with an infinite number of "sorts"
12:56:33 <Botje> shapr: thanks! i'll google that a bit
12:56:34 <shapr> Are there any options other than HM for type inference?
12:56:41 <lament> shapr: yes.
12:56:42 <Botje> anything beats classifying design patterns *zzz*
12:57:11 <lament> shapr: eg Haskell, which is way more than HM
12:57:13 <roconnor> lament: I know.  But coq has type checking, infinite number of types, and I'm moderatly sure it can be viewed as a PTS.
12:57:40 <ehird> lament: if you have a default type at the top, then you can build in typechecking for that
12:57:43 <lament> shapr: the paper in this page gives a nice (i think) overview of type systems culminating with PTS: http://people.cs.uu.nl/johanj/MSc/jwroorda/
12:57:44 <shapr> Botje: That polyvariadic args trick is from bringert's code.
12:57:44 <lambdabot> Title: Pure Type Systems for Functional Programming
12:57:46 <ehird> and if you can't do typechecking at one level do it one up
12:57:52 <ehird> which will provide the means to do it at that level
12:57:57 <shapr> lament: Ah, thanks. I'll try to read that on the flight to Vegas tonight.
12:58:08 <roconnor> vegas baby!
12:58:13 <roconnor> @vixen vegas baby!
12:58:14 <lambdabot> Why is magenta on blues clues a boy while blue is a girl? what has this world come to and what is wrong with the government, blues clues should be stopped while its ahead!!
12:59:03 <dolio> You're like a big bear, man!
13:00:15 <Botje> shapr: OH GOD THE FIRST HIT IS OLEGS SITE!
13:00:22 <Botje> *ahum*
13:00:31 <Botje> I meant, "yay, reading material"
13:00:43 * shapr snickers
13:00:54 <dolio> HList is essentially extensible records.
13:00:57 <b_jonas> lol
13:01:00 <dolio> And polymorphic variants.
13:01:21 <shapr> @seen bringert
13:01:22 <lambdabot> I saw bringert leaving #ghc and #haskell 11h 3m 11s ago, and .
13:02:02 <shapr> Botje: The polyvariadic args idea is also used in a printf implementation, and some other places.
13:02:02 <byorgey> @remember Botje [on googling for polyvariadic typeclasses] OH GOD THE FIRST HIT IS OLEGS SITE! / *ahum* / I meant, "yay, reading material"
13:02:02 <lambdabot> Done.
13:02:16 <Botje> shapr: yes, that's what led me to the question :)
13:02:20 <b_jonas> someone just asked on another channel for a free C implementation of some new kind of balanced trees
13:02:30 <b_jonas> I guess there's already a haskell implementation out there
13:02:31 <shapr> What new balanced trees?
13:02:46 <b_jonas> left-leaning red-black trees
13:03:11 <bos> left-leaning RB trees aren't very interesting in haskell.
13:03:15 <b_jonas> and I don't know what those are
13:03:21 <b_jonas> and don't even care
13:03:21 <bos> their primary motivation is to make implementation of RB trees easier.
13:03:38 <bos> however. RB trees are as easy to implement in haskell as falling off the proverbial log scale.
13:03:43 <ilyak_> Who the hell is Oleg?
13:04:05 <b_jonas> if simpler implementation is the only advantage, I don't need another balanced tree
13:04:05 <Jaak> god?
13:04:05 <bos> ilyak_: google for "oleg haskell"
13:04:22 <ilyak_> bos: It googles to a lot of trash
13:04:33 <mrd> ?go oleg haskell
13:04:33 <ilyak_> maillis postings, lj post, etc etc
13:04:34 <lambdabot> http://okmij.org/ftp/
13:04:34 <lambdabot> Title: This FTP site
13:04:38 <mrd> that's it
13:04:46 <shapr> Hiya mrd!
13:04:48 <Jaak> ilyak_: first like is correct.. what more do you need
13:04:51 <mrd> hey
13:04:56 <shapr> mrd: So you're moving out here, yeah?
13:05:03 <mrd> yup! I agreed
13:05:10 <byorgey> mrd: where?
13:05:13 <shapr> Yay, more people for a Cambridge Haskell User's Group!
13:05:15 <EvilTerran> ?go oleg
13:05:17 <lambdabot> http://www.olegproducts.com/
13:05:17 <lambdabot> Title: Oleg Saxophones, Flutes, Woodwind Ligatures and Accessories
13:05:25 <b_jonas> wait,
13:05:25 <resiak> ?go go oleg rangers
13:05:25 <mrd> chug chug chug chug
13:05:26 <lambdabot> No Result Found.
13:05:27 <EvilTerran> hm. not quite. i think he's on the first page, though
13:05:29 <b_jonas> that's oleg's site?
13:05:29 <shapr> resiak: argh!
13:05:32 <b_jonas> I never knew
13:05:37 <shapr> @quote oleg
13:05:38 <lambdabot> cjb says: "didn't Oleg develop.." ~= "Can Haskell do.."
13:05:39 <shapr> @quote oleg
13:05:39 <lambdabot> Cale says: Oleg can bend spoons with his mind, in the type system, in Haskell 98.
13:05:41 <shapr> @quote oleg
13:05:41 <lambdabot> OlegFacts says: Oleg can make total functions partial
13:05:43 <shapr> @quote oleg
13:05:43 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
13:05:49 <shapr> Oleg is famous :-)
13:05:51 <b_jonas> I had that http://okmij.org/ftp/ in my core bookmarks for long
13:05:51 <lambdabot> Title: This FTP site
13:05:52 <byorgey> oh, yes, oleg makes saxophones in his spare time, doesn't everyone know that?
13:06:13 <shapr> See, now my algorithms are O(leg) N!
13:06:26 <roconnor> N factorial?
13:06:30 <shapr> Too bad his last name is actually Kiselyov...
13:06:44 <dolio> @remember OlegFacts Oleg makes saxophones in his spare time.
13:06:44 <lambdabot> Okay.
13:06:53 <shapr> O(leg) N is the complexity where you just ask Oleg for the answer.
13:07:00 <bos> can oleg do it? the answer is YES!
13:07:06 <shapr> I've done that before, the major user complexity involves trying to understand the answer.
13:07:09 * mrd hasn't heard anyone put a problem as Oleg-hard yet
13:07:12 <shapr> hah
13:07:15 <idnar> hahaha
13:07:25 <roconnor> I think someone should change @faq to say yes, Oleg can do that.
13:07:29 * shapr laughs
13:07:36 <cjb> now I want to join a complexity discussion on the Haskell lists just so that I can use all these phrases!
13:07:38 <byorgey> ilyak_: Oleg also has a unit named after him, the Oleg, which measures amounts of type-hackery
13:07:44 * shapr snickers
13:07:45 <ilyak_> :)
13:07:52 <shapr> @quote milli
13:07:52 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
13:07:53 <dolio> Apparently Oleg helped author The Reasoned Schemer.
13:08:04 <byorgey> most programs that mere mortals write measure about two or three milli-Olegs
13:08:06 <roconnor> ``ML type systems are measured in nano-Olegs.''
13:08:10 <shapr> ouch
13:08:11 <mrd> some problems might be non-deterministic Oleg-hard
13:08:14 <bos> oleg has his fingers in many functional pies.
13:08:23 <shapr> This is a funny discussion :-)
13:09:05 <shapr> I met Oleg at ICFP. Still don't understand what he said to me though.
13:09:27 <EvilTerran> it may've been a programming koan
13:09:30 <shapr> Could be.
13:09:36 <roconnor> it isn't what he said that is important, it is the type of thing he said.
13:09:46 <dolio> @quote cornered
13:09:47 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
13:09:53 <shapr> On the good side, when you put in enough time to really understand what Oleg says, it's perfectly clear.
13:09:55 <mrd> they type of things he said is dependent on its value
13:10:08 <roconnor> oh
13:10:12 <EvilTerran> "what is the fixedpoint of one hand clapping?"
13:10:19 <byorgey> so you have to do type inference on what Oleg says?
13:10:29 <shapr> I just have to do lots of background reading.
13:10:30 <roconnor> > mfix oneHandClapping
13:10:30 <lambdabot>   Not in scope: `oneHandClapping'
13:10:38 <EvilTerran> byorgey, and considering all the extensions he uses...
13:10:55 <shapr> Speaking of which, what's the name of the updated Barendregt paper?
13:11:08 <shapr> Like the twentieth anniversary of the Lambda Cube paper?
13:11:44 <byorgey> -XAllowInconceivableInstances
13:12:03 <ehird> does oleg have the whole of that ftp thing?
13:12:07 <ehird> it has cool scheme stuff too
13:12:09 <Deewiant> -foleg-exts
13:12:18 <mrd> it's all oleg. and his collaborators.
13:12:22 <ehird> never knew who the guy running it was, though. it's pretty anonymous. just tons of FP gems
13:13:23 <shapr> PostScript documents don't work so well on win32 :-(
13:13:42 <mrd> @go gsview
13:13:43 <lambdabot> http://pages.cs.wisc.edu/~ghost/gsview/
13:13:43 <lambdabot> Title: GSview
13:15:00 <Cale> -XAllowInstancesOnlyOlegWouldLove
13:15:33 <shapr> mrd: Ah, thanks!
13:15:53 <Excedrin> what do #haskell folks think about languages like K and J?
13:16:07 <Excedrin> well specifically, the syntax
13:16:26 <shapr> sorear: Looks to me like the biggest regular problem with hpaste is that it loses connection but doesn't die. Could you change your crontab to stop and restart hpaste every 24 hours?
13:17:01 <shapr> Of course, the other big problem is that it doesn't whack the archives dir.
13:17:03 <mrd> i added a thread to an IRC bot like hpaste that would have it check for activity every 10 minutes and restart itself if none was found
13:17:16 <mrd> just an MVar with a timestamp
13:17:18 <Jedai> Excedrin: Nice, worse than Perl obfuscated programs !! ^^
13:17:29 <shapr> mrd: Want to fix hpaste? :-)
13:17:46 <shapr> Excedrin: Yeah, I agree with Jedai, cool language, obfuscated syntax.
13:17:54 <Jedai> Excedrin: I think you won't get an unanimous response to this question here
13:17:59 <shapr> Admittedly, if you want the most bang per byte...
13:18:00 <mrd> @go hpaste source code
13:18:02 <lambdabot> http://www.scannedinavian.com/~eric/hpaste-devel/
13:18:02 <lambdabot> Title: Index of /~eric/hpaste-devel
13:18:21 <shapr> mrd: I think there's a more recent hpaste on code.haskell.org, but I'm not totally sure about that.
13:18:23 <Cale> I think it would be nice to see something like them, but with everything sanely named.
13:18:25 <shapr> dons should know.
13:18:54 <Jedai> Excedrin: They're fun language to play, but I wouldn't write a serious program in them
13:19:06 <mrd> unless its changed drastically, it should be pretty much the same. my bot was based on hpaste originally.
13:19:50 <Excedrin> Jedai: I'm not looking for anything unanimous; I'd much rather see lots of different opinions
13:20:54 <mrd> code.h.o/hpaste.git?
13:21:02 <mrd> time to learn git..
13:23:09 <mrd> shapr: where is Allston?
13:24:07 <rolly1975> hi
13:24:12 <rolly1975> i have a problem
13:24:17 <rolly1975> with type checking
13:24:28 <rolly1975> i am trying to do a simple example
13:24:31 <rolly1975> from Project Euler
13:24:38 <roconnor> ?paste
13:24:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:24:52 <roconnor> you can paste haskelly stuff there to show us.
13:25:03 <hpaste>  rory pasted "(no title)" at http://hpaste.org/6665
13:25:52 <rolly1975> basically my issue is with the commented out lines (the factors function)
13:25:57 <EvilTerran> "sieve (x:xs) i = x : sieve ( filter (\x -> mod x i /= 0) xs ) (i+1)
13:25:57 <EvilTerran> " looks wrong
13:26:13 <EvilTerran> er... no, never mind
13:26:27 <rolly1975> hmm, the sieve bit seems to be working, but its definitely not optimal ;-)
13:26:39 <EvilTerran> [1..floor(sqrt(n))] -- this is the problem
13:26:41 <rolly1975> factors takes an Integer argument (n)
13:26:46 <Deewiant> :t floor
13:26:46 <EvilTerran> you can't take the sqrt of an integer
13:26:48 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
13:26:48 <gwern> what's wrong with it?
13:26:48 <rolly1975> right
13:26:52 <gwern> seems to work
13:27:00 <rolly1975> in an imperative language, i would cast
13:27:02 <EvilTerran> ?type sqrt
13:27:16 <lambdabot> forall a. (Floating a) => a -> a
13:27:16 <EvilTerran> ?type fromIntegral
13:27:16 <rolly1975> what do you do in this case in Haskell?
13:27:17 <lambdabot> forall a b. (Num b, Integral a) => a -> b
13:27:20 <EvilTerran> ...
13:27:22 <EvilTerran> ?bot
13:27:23 <lambdabot> :)
13:27:37 <roconnor> rolly1975: we use the fromIntegral function often.
13:27:37 <TSC> Convert the integer into a Double, usually
13:27:46 <EvilTerran> however, using floats here is a bit ugly
13:27:54 <roconnor> okay, we desparately need to add an integer square root function to the standard lib.
13:28:00 <rolly1975> ah, so fromIntegral is what I need
13:28:03 <rolly1975> great
13:28:06 <rolly1975> thx a lot guys
13:28:14 <EvilTerran> i'd suggest writing it as takeWhile (\i -> i^2 < n) [1..]
13:28:14 <shapr> mrd: Allston?
13:28:28 <EvilTerran> (instead of [1..floor(sqrt(n))])
13:28:40 <Deewiant> rolly1975: btw, you realize that '[p | p <- foo]' is equivalent to just 'foo', right? :-)
13:28:43 <roconnor> rolly1975: EvilTerran makes a good point about avoing floats.
13:28:52 <rolly1975> EvilTerran: thx, thats a good suggestion
13:28:56 <EvilTerran> > takeWhile (\i -> i^2 < 200) [1..]
13:28:56 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14]
13:29:06 <EvilTerran> actually, that should be <=
13:29:10 <EvilTerran> but still
13:29:16 <rolly1975> Deewiant: yes.....now ;-)
13:29:19 <rolly1975> thx
13:30:03 <EvilTerran> > nubBy (\x y -> y `mod` x == 0) [2..]
13:30:04 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
13:31:54 <EvilTerran> > let primesIn (x:xs) = x : primesIn (filter (\x y -> y `mod` x /= 0) xs) in primesIn [2..]
13:31:54 <lambdabot>      The lambda expression `\ x y -> y `mod` x /= 0' has two arguments,
13:31:54 <lambdabot>     b...
13:32:15 <EvilTerran> > let primesIn (x:xs) = x : primesIn (filter ((/= 0).(`mod` x)) xs) in primesIn [2..]
13:32:15 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
13:32:26 <EvilTerran> (same algorithm, more intuitive way of writing it)
13:32:38 <rolly1975> EvilTerran: that's lovely...very nce
13:32:56 <EvilTerran> @unpl (/= 0).(`mod` x)
13:32:56 <lambdabot> (\ e -> (mod e x) /= 0)
13:33:16 <EvilTerran> or (\y -> y `mod` x /= 0), if you prefer
13:33:46 <Botje> ah
13:33:51 <Botje> a freshly exploded brain
13:33:58 <Botje> time to go do some stupid work now
13:34:04 <Twey> Hehe
13:34:11 <rolly1975> that would be mine ;-)
13:34:15 * EvilTerran offers round the nachos
13:34:57 <rolly1975> although i think that happened earlier today when i finally figured out how the one-line inifinite fib function works
13:35:04 <EvilTerran> good, innit?
13:35:18 <Botje> does the 5-second rule still count for brain?
13:35:19 <Deewiant> > fix ((`ap` tail) . (. head) . liftM2 (.) (:) . (. (filter . ((0 /=) .) . flip mod)) . (.)) [2..]
13:35:20 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
13:35:50 <dolio> > nubBy(((>1).).gcd)[2..]
13:35:50 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
13:38:04 <skorpan>  that one's a classic
13:40:07 <rolly1975> whats nubBy?
13:40:09 <Gilly> um, why is map (3 - ) [1,2,3,4,5] => [2,1,0,-1,-2] and map ((-) 3) [1,2,3,4,5] => [2,1,0,-1,-2] but map (3 `mod`) [1,2,3,4,5] => [0,1,0,3,3] and map (`mod` 3) [1,2,3,4,5] => [1,2,0,1,2] ?
13:40:33 <elliottt> rolly1975: it removes elements in a list that satisfy a predicate
13:40:38 <elliottt> :t nubBy
13:40:39 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
13:40:40 <rolly1975> aha
13:40:45 <rolly1975> thx
13:40:48 <Deewiant> > nubBy (==) [1,1,2,2,3,3,4]
13:40:49 <lambdabot>  [1,2,3,4]
13:40:54 <elliottt> np :)
13:41:26 <Deewiant> Gilly: (3 -) and ((-) 3) are the same function
13:41:34 <DRMacIver> dcoutts_: cabal install works great now. Thanks.
13:41:36 <Gilly> that's how it appears :P
13:41:38 <Deewiant> > (3 -) 5
13:41:38 <lambdabot>  -2
13:41:43 <Deewiant> > ((-) 3) 5
13:41:44 <lambdabot>  -2
13:41:46 <dcoutts_> DRMacIver: great
13:41:52 <Deewiant> > (- 3) 5
13:41:52 <lambdabot>   add an instance declaration for (Num (t -> a))
13:41:55 <Deewiant> > (subtract 3) 5
13:41:56 <Cale> > nubBy (\x y -> y `mod` x == 0) [2..]
13:41:56 <lambdabot>  2
13:41:56 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
13:42:00 <byorgey> Gilly: ((?) x) is always equal to (x ?)
13:42:07 <DRMacIver> For what it's worth, the error messages aren't super informative, but it was relatively easy to figure out what was going on.
13:42:29 <Deewiant> Gilly: because of the unfortunate fact that (- 3) doesn't parse to what one might expect, we have the function 'subtract'.
13:42:43 <rolly1975> i dont know whats going on with this : @unpl (/=0).(`mod` x), but i think if i ever understand it, i'll be well on my way :-)
13:42:45 <Gilly> ah, thanks for clarifying.
13:42:48 <Cale> It parses to what I think most people would expect ;)
13:43:04 <Cale> rolly1975: hm?
13:43:13 <Deewiant> I'd expect (-3) and (- 3) to be two different things, but I guess I'm not most people then :-)
13:43:14 <Vq^> why not use a similar notation as the inverse of a scalar?
13:43:17 <Vq^> 1/x
13:43:19 <Cale> @unpl (/=0).(`mod` x)
13:43:19 <lambdabot> (\ e -> (mod e x) /= 0)
13:43:21 <Vq^> 0-x
13:43:35 <DRMacIver> (when an install fails I mean)
13:43:39 <dcoutts_> DRMacIver: please do report bugs giving the error you encountered and the error message you would have preferred.
13:43:48 <Deewiant> @unpl (`mod` x)
13:43:48 <lambdabot> (\ a -> mod a x)
13:43:55 <DRMacIver> dcoutts_: Sure. Where do I report them?
13:44:03 <Cale> rolly1975: unpl adds parameters back into a points-free function in order to express it as a lambda
13:44:03 <Vq^> maybe thats a question for #math as well ...
13:44:10 <dcoutts_> @where cabal
13:44:10 <lambdabot> http://www.haskell.org/cabal
13:44:13 <Cale> @unpl mod
13:44:13 <lambdabot> mod
13:44:18 <Cale> @unpl f . g
13:44:18 <lambdabot> (\ c -> f (g c))
13:44:30 <Cale> @unpl f . (`g` x)
13:44:30 <lambdabot> (\ d -> f (g d x))
13:44:33 <DRMacIver> ok. I should have figured that one out. :-)
13:44:45 <Cale> @unpl (f .) . (`g` x)
13:44:45 <lambdabot> (\ e j -> f (g e x j))
13:44:45 <dcoutts_> DRMacIver: the cabal site links to the trac: http://hackage.haskell.org/trac/hackage
13:44:47 <lambdabot> Title: Hackage - Trac
13:44:56 <Cale> It selects strange parameter names :)
13:45:11 <Cale> @unpl ((f .) .) . g
13:45:11 <lambdabot> (\ e j m -> f (g e j m))
13:45:17 <Cale> @unpl ((f .) .) . (. g)
13:45:18 <lambdabot> (\ h k n -> f (h (g k) n))
13:45:48 <dcoutts_> DRMacIver: it's not that I don't know the error messages are bad, but having a report stating that along with a suggestion means that other hackers can pick up the report and have a go
13:45:55 <DRMacIver> Sure. :)
13:46:16 <rolly1975> Cale: wow. thanks! ok, need to lie down for a bit now :-) Whats the significance of the '@' ? (sorry, im a n00b)
13:46:53 <dcoutts_> @arr!
13:46:53 <lambdabot> Yeh scurvy dog...
13:47:02 <dcoutts_> rolly1975: @ is just a prefix to lambdabot commands
13:47:08 <rolly1975> ah, got it ;-)
13:47:12 <dcoutts_> rolly1975: though @ is also used in haskell pattern syntax
13:47:28 <DRMacIver> dcoutts_: Oh. Actually, I just fail at reading error messages.
13:47:37 <rolly1975> yeah, i thought i did see that earlier...what does it mean in that context?
13:47:54 <dcoutts_> DRMacIver: doesn't matter, if it's not clear or if it's misleading, or badly formatted, report it.
13:47:58 <DRMacIver> dcoutts_: The message was fine. It just started about 5 lines earlier than I thought it did.
13:48:05 <DRMacIver> I'm not quite sure how I managed that. :-)
13:48:26 <dcoutts_> DRMacIver: so it's not clearly distinguishable from the preceding build log?
13:48:44 <monochrom> When lambdabot was still a dial-up modem in its previous life, you would use AT to prefix commands to it.  Now it's @.
13:49:14 <dcoutts_> DRMacIver: well if you think it's not worth it then well, next time, there certainly are cases of poor error messages.
13:49:25 <rolly1975> actual AT commands?
13:49:30 <rolly1975> cool :-)
13:49:52 <DRMacIver> dcoutts_: Hm. Maybe. I think what was happening was that my eyes were being drawn to "failed during the configure step. The exception was: exit: ExitFailure 1" and ignoring the previous build log which is where the actually useful information was
13:50:08 <DRMacIver> I will file this, but as super low priority. :)
13:50:26 <dcoutts_> that's fine
13:52:48 <DRMacIver> Hm.
13:53:02 <DRMacIver> No, on second thoughts this really was just me being lame. But I'll bear it in mind for the future
13:53:33 <dcoutts_> DRMacIver: thanks
13:53:44 <Excedrin> +++@H0
13:57:25 <gwern> given a record, with, say, 10 val=Strings, is there any way to  turn it into [String] where each entry is "val=string'?
13:58:04 <gwern> or would turning a field name into a string be too meta- to do easily in haskell?
13:58:31 <elliottt> gwern: you can do it with generics easily if you've got a Data instance for your record
13:59:10 <gwern> (generics? so I guess not; back to [(String, String)] then)
13:59:27 <elliottt> zipWith (\x y -> x ++ "=" ++ y) (constrFields $ toConstr r) (gmapQ gshow r)
13:59:30 <elliottt> something like that
14:02:05 <gwern> @pl autoprocMain rules = autoprocMessage >> (putStrLn $ showProcmailrc defaultVariables $ concatMap generate $ execWriter rules)
14:02:05 <lambdabot> autoprocMain = (autoprocMessage >>) . putStrLn . showProcmailrc defaultVariables . (generate =<<) . execWriter
14:02:47 <DRMacIver> Hm. If I wanted to just download a file from Haskell, is there actually any better way to do so than shell out to wget?
14:03:04 <DRMacIver> I assume there must be given the fact there are a number of programs which do it. :)
14:03:19 <monochrom> download with http?
14:03:23 <DRMacIver> Yes
14:03:37 * monochrom whispers "the http package" and hides
14:04:34 <gwern> shelling out would be the laziest quickest way I know of
14:04:43 <gwern> @pl autoprocMain rules vars = autoprocMessage >> (putStrLn $ showProcmailrc vars $ concatMap generate $ execWriter rules)
14:04:43 <lambdabot> autoprocMain = (((autoprocMessage >>) . putStrLn) .) . flip showProcmailrc . (generate =<<) . execWriter
14:04:59 <gwern> @pl autoprocMain rules vars = putStrLn $ showProcmailrc vars $ concatMap generate $ execWriter rules
14:04:59 <lambdabot> autoprocMain = (putStrLn .) . flip showProcmailrc . (generate =<<) . execWriter
14:05:23 <DRMacIver> monochrom: None of them appear all that suitable to be honest. Although I probably will end up using one, yes
14:05:36 <gwern> @pl autoprocMain vars rules = putStrLn $ showProcmailrc vars $ concatMap generate $ execWriter rules
14:05:36 <lambdabot> autoprocMain = (putStrLn .) . (. ((generate =<<) . execWriter)) . showProcmailrc
14:05:50 <gwern> that's a little better
14:06:17 <monochrom> Right, the current state of http support is premature.
14:06:23 <glguy> you are trying to mask the meaning of the function?
14:06:26 <glguy> maybe try shorter names
14:07:34 <gwern> no, I was trying to see how to convert the $s to .s
14:07:49 <gwern> problem is, 'autoprocMain vars rules = autoprocMessage >> (putStrLn ○ showProcmailrc vars ○ concatMap generate ○ execWriter rules)
14:07:51 <gwern> doesn
14:07:52 <gwern> t work
14:07:59 <monochrom> For the moment I still recommend shelling out to wget or curl or binding to libcurl because they implement http and https fully, e.g., decryption, compression, chunk encoding, proxies, cookies.
14:08:01 <ahunter_> @src replicateM
14:08:01 <lambdabot> replicateM n x = sequence (replicate n x)
14:08:21 <DRMacIver> monochrom: It doesn't appear to be obvious how to do it with the curl bindings actually
14:08:23 <glguy> putStrLn ○ showProcmailrc vars ○ concatMap generate ○ execWriter $ rules
14:08:40 <gwern> however, '(putStrLn ○ showProcmailrc vars ○ concatMap generate $ execWriter rules)' does work
14:08:42 <gwern> hm
14:08:43 <DRMacIver> In particular they're string centric
14:08:51 <DRMacIver> And what I want to download is binary
14:09:16 <gwern> as does '((putStrLn ○ showProcmailrc vars ○ concatMap generate ○ execWriter) rules)'
14:09:38 <glguy> which is the $less version of what I pasted
14:10:02 <gwern> glguy: yeah, I guess. I still have trouble with the intricacies of how . and $ interact
14:10:10 <gwern> more and more I come to believe as Cale...
14:10:31 <glguy> that seems like a good example of when breaking the expression up a bit helps clarity
14:10:51 <daf> mmm, . vs. $ is interesting
14:11:24 <elliottt> :t (.) . ($)
14:11:28 <lambdabot> forall (f :: * -> *) a b. (Functor f) => (a -> b) -> f a -> f b
14:11:31 <gwern> sometimes I wonder if maybe $ should be scrapped; . can do the role fine in a lot of cases
14:11:55 <glguy> not in $ \ this -> case
14:12:18 <glguy> which is important for avoiding the line of lisp code at the end of your functions
14:12:24 <daf> yeah, for those it's like an inside-out parenthesis
14:14:47 <roconnor> $ is the same as . in logic. It means to parenthesis everything to the right.
14:14:57 <dolio> Oh, a big circle.
14:15:08 <dolio> Evidently most of my fonts are lacking that.
14:15:13 <roconnor> $ should be renamed . and I could live with . being renamed `fmap`.
14:15:17 <gbacon> @ty (.) . (.)
14:15:18 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
14:15:27 <ahunter_> @type (.)
14:15:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:15:30 <ahunter_> @type fmap
14:15:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:15:36 <glguy> lambdabot is broken at the moment
14:15:41 <glguy> that's not the type of (.)
14:15:46 <ahunter_> I didn't think so
14:16:05 <gbacon> how do you tell lambdabot to forget lets? @clear?
14:16:07 <gbacon> @clear
14:16:07 <lambdabot> Messages cleared.
14:16:11 <glguy> ?undefine
14:16:12 <lambdabot> Undefined.
14:16:19 <glguy> I don't think that's a normal let
14:16:26 <gbacon> @ty (.)
14:16:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:16:42 <glguy> That's hard coded in to make lambdabot less useful as a teaching tool
14:16:44 <dolio> Cale put it in there specifically.
14:16:53 <roconnor> :/
14:16:55 <Cale> heh
14:16:59 <gbacon> glguy: :-)
14:17:03 <roconnor> @undo Cale
14:17:03 <lambdabot> Cale
14:17:10 <roconnor> damn
14:17:31 <Cale> heh
14:18:14 <roconnor> Cale: plz just write your own Haskell report so we call forget about all this Haskell prime slowness.
14:18:22 <Cale> roconnor: :)
14:18:30 <roconnor> I mean why not?
14:18:37 <Cale> #haskell should work on Haskell 2
14:18:49 <ahunter_> Cale, I am curious--I can see off the top of my head that (.) can work as fmap, but why precisely did you set it up here?  For funsies, or is there a purpose?
14:18:57 <Cale> Mostly for fun
14:19:08 <Cale> and so that we can explore the consequences of it
14:19:30 <edwardk> cale: mostly that you run into a lot more stuff needing type signatures as i recall from when i was playing with it
14:20:16 <Cale> I've found it not so bad. The only case where you end up needing an explicit type signature is when the type of the end of a chain of (.)'s can't be determined
14:20:25 <edwardk> But its a lot of fun i'll admit
14:20:30 <edwardk> yeah
14:21:15 <Cale> (++) for monoid is really quite nice
14:21:24 <edwardk> that one i agree completely on.
14:21:32 <ahunter_> @type (++)
14:21:33 <lambdabot> forall m. (Monoid m) => m -> m -> m
14:21:36 <ahunter_> oh, that is set up here, cool
14:21:40 <dolio> > zero ++ zero
14:21:40 <lambdabot>  ()
14:21:50 <edwardk> cale: this from an alternate prelude?
14:21:55 <ahunter_> Has this been proposed for Haskell' or similar?
14:22:14 <Cale> edwardk: I just import the Prelude hiding a few things, which I replace.
14:22:18 <Cale> @undefine
14:22:18 <lambdabot> Undefined.
14:22:25 <ahunter_> @type (++)
14:22:25 <lambdabot> forall m. (Monoid m) => m -> m -> m
14:22:56 <edwardk> cale: yeah, i went whole hog down the path of redefining everything in most general terms, but the number of typeclasses you have to define gets prohibitive when you want to take it to pathological extremes.
14:22:57 <Cale> > sortBy (comparing length ++ compare) (words "here is a bunch of words to be sorted by length and then alphabetically")
14:22:58 <lambdabot>  ["a","be","by","is","of","to","and","here","then","bunch","words","length","...
14:23:13 <resiak> > EQ ++ GT
14:23:14 <lambdabot>  GT
14:23:17 <resiak> nice
14:23:21 <Botje> WOAH
14:23:22 <vincenz> that's not it
14:23:24 <Botje> Cale: that's so cool.
14:23:44 <vincenz> > (\x -> EQ) ++ (\x -> GT) :: Int -> Ord
14:23:44 <lambdabot>      Class `Ord' used as a type
14:23:44 <lambdabot>     In the type `Ord'
14:23:44 <lambdabot>     In the type `Int ->...
14:23:47 <vincenz> > (\x -> EQ) ++ (\x -> GT) :: Int -> Ordering
14:23:48 <lambdabot>  <Int -> Ordering>
14:23:54 <gnuvince_> :t comparing
14:23:55 <resiak> *blink*
14:23:56 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
14:24:09 <resiak> what on earth is the Monoid instance?
14:24:18 <vincenz> probably something like
14:24:19 <Cale> It's the lifting instance, twice.
14:24:26 <vincenz> instance Monoid b => Monoid (a->b) where
14:24:28 <Cale> and then the instance for Ordering
14:24:36 <vincenz>   f ++ g = \x -> f x ++ g x
14:24:56 <resiak> very nice.
14:24:56 <idnar> > ((\x -> EQ) ++ (\x -> GT) :: Int -> Ordering) LT
14:24:56 <idnar> er
14:24:57 <stepcut> Is there some program which is ideally suited to making category theory diagrams like these, http://byorgey.wordpress.com/2008/02/13/patch-theory-part-ii-some-basics/
14:24:57 <lambdabot>  Couldn't match expected type `Int' against inferred type `Ordering'
14:24:58 <lambdabot> Title: Patch theory, part II: some basics  blog :: Brent -> [String], http://tinyurl.com/2zlo9h
14:24:59 <idnar> > ((\x -> EQ) ++ (\x -> GT) :: Int -> Ordering) 5
14:25:00 <lambdabot>  GT
14:25:08 <idnar> > ((\x -> EQ) ++ (\x -> GT) :: Int -> Ordering) 0
14:25:08 <lambdabot>  GT
14:25:13 <Cale> stepcut: yes, xy-pic in latex
14:25:24 <vincenz> I don't get the monoid instance on Ordering, tho
14:25:26 <vincenz> > LT ++ GT
14:25:27 <lambdabot>  LT
14:25:28 <idnar> does that value (the function from Int to Ordering) actually do anything useful?
14:25:29 <vincenz> > LT ++ EQ
14:25:29 <lambdabot>  LT
14:25:35 <vincenz> > GT ++ LT
14:25:36 <lambdabot>  GT
14:25:38 <vincenz> o.O
14:25:45 <Jaak> @type (++)
14:25:46 <lambdabot> forall m. (Monoid m) => m -> m -> m
14:25:47 <glguy> takes the first non-EQ
14:25:50 <Jaak> oh i see
14:25:51 <vincenz> glguy: ah
14:25:54 <Jaak> must be new thing
14:25:54 <vincenz> glguy: dictionary sorting
14:26:21 <glguy> > mconcat [ EQ, EQ, GT, LT]
14:26:22 <lambdabot>  GT
14:26:26 <vincenz> which is very ery very wrong!!!!
14:26:27 <Cale> vincenz: If x and y are two orderings, then x ++ y will pick x unless x is EQ in which case it will result in y
14:26:32 <vincenz> it's VERY VERY VERY wrong
14:26:39 <vincenz> x ++y != y ++x
14:26:41 <Cale> No it's not.
14:26:52 * stepcut checks out xy-pic
14:26:53 <Cale> Uh, that doesn't hold for list concatenation either
14:26:59 <glguy> (++) isn't commutative anyway
14:27:00 <vincenz> Cale: yeah I thought about that too late
14:27:06 * vincenz shuts up
14:27:13 <glguy> > Just 1 ++ Just 2
14:27:13 <lambdabot>  Add a type signature
14:27:15 <Cale> The important things are that it's associative and has an identity
14:27:17 <glguy> > Just 1 ++ Just 2 :: Just Int
14:27:17 <lambdabot>   Not in scope: type constructor or class `Just'
14:27:20 <glguy> > Just 1 ++ Just 2 :: Maybe Int
14:27:21 <lambdabot>   add an instance declaration for (Monoid Int)
14:27:21 <lambdabot>     In the expression: Just 1 ...
14:27:33 <glguy> oh, I guess that only works out for mplus
14:27:38 <vincenz> > Just LT ++ Just GT
14:27:39 <lambdabot>  Just LT
14:27:39 <Cale> > Just (Sum 1) ++ Just (Sum 2)
14:27:39 <lambdabot>  Just (Sum {getSum = 3})
14:28:02 <vincenz> > Just (Product 2) ++ Just (Product 3)
14:28:02 <lambdabot>  Just (Product {getProduct = 6})
14:28:10 <wagle_home> > Just GT ++ Just LT
14:28:10 <lambdabot>  Just GT
14:28:15 <gwern> @seen lispy
14:28:15 <lambdabot> lispy is in #haskell, #darcs, ##logic, #ghc and #haskell-blah. I last heard lispy speak 16h 15m 7s ago.
14:28:30 <glguy> > maybe 0 ($ 3) $ Just (Endo (+1)) ++ Just (Endo (*2))
14:28:30 <lambdabot>  Couldn't match expected type `a -> b'
14:28:42 <glguy> runEndo?
14:28:50 <dolio> apEndo
14:28:55 <dolio> Maybe two ps.
14:28:56 <wagle_home> > GT ++ LT
14:28:56 <vincenz> :t Endo
14:28:57 <lambdabot>  GT
14:28:57 <lambdabot> forall a. (a -> a) -> Endo a
14:28:59 <glguy> > maybe 0 (($ 3) . runEndo) $ Just (Endo (+1)) ++ Just (Endo (*2))
14:28:59 <lambdabot>   Not in scope: `runEndo'
14:29:02 <glguy> :t apEndo
14:29:03 <lambdabot> Not in scope: `apEndo'
14:29:11 <gwern> @tell lispy I'm sending some patches to fix up the environmental variables not being configurable issue I mentioned; I think I'm going to upload it to hackage as well
14:29:11 <lambdabot> Consider it noted.
14:29:14 <glguy> ?hoogle endo
14:29:15 <lambdabot> Data.Monoid.Endo :: newtype Endo a
14:29:15 <lambdabot> Data.Monoid.Endo :: (a -> a) -> Endo a
14:29:15 <lambdabot> Data.Monoid.appEndo :: Endo a -> a -> a
14:29:19 <Cale> stepcut: there's also http://www.monad.me.uk/diagrams/
14:29:19 <lambdabot> Title: Commutative Diagrams in TeX
14:29:24 <glguy> > maybe 0 (($ 3) . appEndo) $ Just (Endo (+1)) ++ Just (Endo (*2))
14:29:25 <lambdabot>  7
14:30:54 <dolio> So many monoids.
14:31:25 <vincenz> uncountably many
14:31:45 <gwern> @ask lispy also, why is http://www.codersbase.com/Autoproc dead? the code has that hardwired in as the hompage
14:31:45 <lambdabot> Consider it noted.
14:31:53 <dibblego> ?type (*)
14:31:54 <lambdabot> forall a. (Num a) => a -> a -> a
14:33:14 <dolio> I was thinking, the one for Monoid b => a -> b could be generalized to monads: instance Monad m, Monoid b => Monoid (m b) where zero = return zero ; (++) = liftM2 (++)
14:33:36 <dolio> But that of course doesn't agree with Monoid b => Monoid (Maybe b)
14:34:46 <Syzygy-> dolio: Do you want liftM2 ++ or do you want mplus there?
14:35:00 <Syzygy-> Then again, that would no longer be Monad =>
14:35:19 <dolio> Yeah, MonadPlus has another monoid structure.
14:35:40 <Arnfreth> how do I read arrow keys from getChar?
14:36:17 <dabblego> is there an English name for (<*>)? apply?
14:36:24 <Arnfreth> and backspace for that sake?
14:36:27 <dolio> All monads are monoids when parameterized by (), which is the monoid of effects, more or less.
14:36:42 <Twey> @type (<*>)
14:36:43 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:36:52 <dolio> But you can replace () by any monoid and get a monoid, too, I think.
14:37:05 <gwern> @tell lispy  http://hackage.haskell.org/cgi-bin/hackage-scripts/package/autoproc-0.1
14:37:05 <lambdabot> Consider it noted.
14:37:20 * gwern is going to leave lispy alone now :)
14:37:44 <lament> gwern: thanks for the colour of bits article, really interesting
14:38:13 <roconnor> > sortBy (compare ++ comparing length ) (words "here is a bunch of words to be sorted by length and then alphabetically")
14:38:14 <lambdabot>  ["a","alphabetically","and","be","bunch","by","here","is","length","of","sor...
14:38:33 <roconnor> > sort (words "here is a bunch of words to be sorted by length and then alphabetically")
14:38:33 <lambdabot>  ["a","alphabetically","and","be","bunch","by","here","is","length","of","sor...
14:38:46 <roconnor> duh
14:40:33 <Cale> > sortBy (compare ++ flip comparing length) (words "a b ab cab abra cad abracadabra")
14:40:34 <lambdabot>  Couldn't match expected type `[a] -> Int'
14:40:40 <Cale> > sortBy (compare ++ flip (comparing length)) (words "a b ab cab abra cad abracadabra")
14:40:40 <lambdabot>  ["a","ab","abra","abracadabra","b","cab","cad"]
14:40:48 <Cale> nope :)
14:41:00 <Twey> Oh
14:41:01 <Twey> Uh
14:41:06 <Cale> compare is total already, so there's nothing which can be done :)
14:41:08 <Twey> compare ++ flip?
14:41:24 <Cale> (++) is the monoid operation
14:41:40 <Cale> In this case, the monoid is (a -> a -> Ordering)
14:42:11 <Cale> > sortBy (comparing length ++ compare) (words "a b ab cab abra cad abracadabra")
14:42:11 <lambdabot>  ["a","b","ab","cab","cad","abra","abracadabra"]
14:44:40 <Twey> Hmm
14:44:49 <Twey> @type (++)
14:44:49 <lambdabot> forall m. (Monoid m) => m -> m -> m
14:45:17 <Twey> > length 'a'
14:45:17 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
14:45:48 <Twey> > (length) ["Foo"]
14:45:48 <lambdabot>  1
14:45:55 <Twey> > (length . head) ["Foo"]
14:45:55 <lambdabot>  3
14:46:00 <Twey> > (length ++ head) ["Foo"]
14:46:00 <lambdabot>  Couldn't match expected type `Int' against inferred type `[Char]'
14:46:14 <gwern> lament: you're welcome. I think it's the best single explanation for normal people of why computer people dislike IP law
14:46:15 <gwern> https://secure.wikimedia.org/wikipedia/en/w/index.php?title=Emacs&curid=345593&diff=201323930&oldid=201236381 <-- dammit, we need some official emacs support for darcs!
14:46:18 * Twey concludes that he doesn't get it.
14:46:19 <lambdabot> http://tinyurl.com/2nfgng
14:46:22 * Twey will look it up later.
14:46:34 <Twey> gwern: Why? :-P
14:48:11 <gwern> Twey: because it's unfair *mercurial and bazaar* gets support but we don't
14:49:32 <Twey> gwern: I'm sure it'll be in Yi
14:50:22 <roconnor> wait for darcs 2
14:50:26 <gwern> Twey: bah. I can't even compile yi
14:51:17 <Twey> gwern: Yes, well, it's not done yet, is it?  :-P
14:51:45 <gwern> why? darcs 2 doesn't change the interface much if at all I thought
14:52:07 <roconnor> oh i don't know
14:52:25 <roconnor> it adjusts semantics somewhat.
14:52:33 <roconnor> maybe it isn't a big deal.
15:02:43 <byorgey> stepcut: I used inkscape to make those diagrams, but that was just so they'd look pretty
15:03:00 <stepcut>  byorgey: I was afraid you were going to say that :)
15:03:12 <stepcut> they are quite pretty though
15:03:14 <byorgey> if you specifically just want to make commutative diagrams then I'd go with one of the other suggestions people have made.
15:03:24 <byorgey> stepcut: why afraid? =)
15:03:55 <ehird_> I wonder if there is a DB layer for haskell that is almost totally transparent.
15:03:57 <stepcut> byorgey: because, that is too much work to use in scratch notes
15:04:17 <ehird_> Like, you just add a line saying that SuchAndSuch, a data/newtype, is serializable
15:04:24 <byorgey> stepcut: ah, hehe, indeed
15:04:25 <ehird_> and then you get the query functions on it
15:05:01 <stepcut> byorgey: btw, you might be interested in this paper: http://citeseer.ist.psu.edu/berlage94selective.html
15:05:02 <lambdabot> Title: A Selective Undo Mechanism for Graphical User Interfaces Based On Command Object ...
15:05:10 <ehird_> & you just add one function call to load all the persistant objects at startup
15:05:18 <ehird_> maybe not even in a db
15:05:24 <ehird_> maybe literally serialize them in some efficient form
15:05:27 <ehird_> so you can serialize anything
15:05:54 <Saizan> ehird_: use the derive package to derive Binary instances for your types and you're done.
15:06:21 <stepcut> byorgey: although it is talking about non-linear undo, it is basically the same problem as collaborative editting
15:06:57 <stepcut> byorgey: this paper as well, http://citeseer.ist.psu.edu/564700.html
15:06:59 <lambdabot> Title: Recognizing Creative Needs in User Interface Design (ResearchIndex)
15:07:09 <ehird_> Saizan: hardly efficient, though.
15:07:24 <Saizan> ehird_: why?
15:07:26 <byorgey> stepcut: cool, thanks
15:07:38 <ehird_> Saizan: because you can't do operations like on an RDBMS
15:07:42 <stepcut> byorgey: and, probably this one, but I have not finished reading it yet, http://citeseer.ist.psu.edu/4467.html
15:07:42 <lambdabot> Title: Undoing Actions in Collaborative Work - Prakash, Knister (ResearchIndex)
15:07:46 <ehird_> all the searching stuff etc
15:08:19 <Saizan> ehird_: ah, your last lines seemed to imply you didn't need that
15:08:41 <ehird_> Saizan: [22:04] <ehird_> and then you get the query functions on it
15:08:50 <ehird_> Saizan: I was thinking something like the Smalltalk object databases
15:09:07 <stepcut> byorgey: a collaborative text editor, even if used by a single person, can work well as an exporative editor with automatic revision control, disguised as a nicer undo/redo system
15:09:24 <stepcut> at least, that is my hypothesis
15:09:28 <ehird_> I'd be able to stop fussing over HaskellDB/Takusen and start gaping at the awesomeness of the Advanced Technologie in my system
15:09:45 <ehird_> right after i get serializable continuations, of course
15:10:14 <stepcut> ehird_: have you seen mobile haskell ? They talk about serializing thunks for sending over the network -- but you could save them to disk instead
15:10:29 <ehird_> stepcut: Not sure if that would be practical for a web app framework
15:10:48 <ehird_> It might be if I use delimited continuations.
15:11:14 <gwern> oh if only we had clean's dynamics! serialization of functions and graphs ftw
15:11:32 <stepcut> ehird_: :p
15:11:45 <ehird_> I know SISC and some other stuff have serializable continuations
15:12:04 <byorgey> stepcut: definitely.  I know I would love such an editor.
15:12:41 <stepcut> ehird_: if you want to serialize functions, then I think you need to do something like mobile haskell does.
15:13:20 <stepcut> byorgey: :p
15:13:31 <solrize> a more powerful type system and proof-carrying code would be cool
15:14:50 <ehird_> stepcut: i dont think sisc serializes functions
15:15:03 <notagirl> @google sisc
15:15:06 <lambdabot> http://sisc-scheme.org/
15:15:06 <lambdabot> Title: SISC - Second Interpreter of Scheme Code
15:15:17 <byorgey> stepcut: ?
15:16:10 <stepcut> byorgey: s/:p/me too./
15:16:25 <byorgey> stepcut: hehe, ok =)
15:16:57 <stepcut> ehird_: what about WASH-style continuations ?
15:18:00 <ehird_> stepcut: what is that
15:18:42 <stepcut> ehird_: see section 4, http://www.informatik.uni-freiburg.de/~thiemann/WASH/draft.pdf
15:19:51 <ehird_> i forgot how pretentious WASH is. it can't settle to be a haskell library, it has to 'use haskell as its embedded language'
15:19:52 <ehird_> :)
15:19:59 <stepcut> ;)
15:21:22 <ehird_> it's a good thing my library will REVOLUTIONIZE WEB PROGRAMMING
15:21:28 <ehird_> and nobody will use BAD FRAMEWORKS anymore
15:21:36 <lament> FINALLY
15:21:43 * Twey grins.
15:21:45 <notagirl> web will die
15:21:55 <ehird_> notagirl: no hardly, it'll just be called neweb
15:21:56 <Twey> Please gods make it soon
15:21:57 <Randroid> Wow! I've been waiting for this since I last sliced bread.
15:22:00 <ehird_> oldweb is doubleplusungood
15:22:10 <lament> Web 3.0 right?
15:22:20 <lament> Web Omega
15:22:25 <Arnfreth> does anybody here know how I clear a line without jumping to a new one?
15:22:27 <stepcut> ehird_: btw, based on your initial statement, "I wonder if there is a DB layer for haskell that is almost totally transparent. Like, you just add a line saying that SuchAndSuch, a data/newtype, is serializable"
15:22:29 <Arnfreth> in stdout
15:22:30 * Twey is still waiting for Web 2.0.
15:22:32 <notagirl> acid3 test killed the web
15:22:38 <stepcut> ehird_: That largely describes HAppS
15:23:05 <ehird_> stepcut: does it? ok, i'll rip off their ideas
15:23:17 <dcoutts_> Arnfreth: you'll have to look at ANSI terminal codes
15:23:27 <lekro> Arnfreth: the easiest way is probably to print '\r'
15:23:29 <ehird_> notagirl: are you aiming for incoherency? :p
15:23:38 <byorgey> Arnfreth: you can probably do something like print out a bunch of backspaces and then print a bunch of spaces over the line
15:23:41 <lekro> Arnfreth: this doesn't clear the line, though
15:23:49 <lekro> Arnfreth: only jumps to the beginning
15:23:49 <dolio> I write all my code in google-emacs and use the google haskell compiler to build it.
15:23:50 <ehird_> actually, i'll probably be the first framework that supports templates seamlessly with continuations & callbacks
15:23:53 <ehird_> not quite sure how yet
15:23:54 <ehird_> but hey
15:23:55 <byorgey> it's ugly though =(
15:23:55 <Arnfreth> okay, I'll try my way around
15:24:02 <Arnfreth> thanks a lot
15:24:08 <ehird_> Arnfreth: try this:
15:24:08 <Arnfreth> what about the arrow keys?
15:24:09 <lament> ehird_: sounds like it will REVOLUTIONIZE EVERYTHING
15:24:13 <lament> ehird_: *yawn*
15:24:16 <lament> :D
15:24:21 <Arnfreth> are they defined in the ansi terminal codes as well?
15:24:24 <ehird_> well, i'm too lazy, but..
15:24:32 <ehird_> Arnfreth: \r, 80 ' ', \r
15:24:44 <ehird_> lament: well, it'll revolutionize MY BLAG
15:24:45 <ehird_> :p
15:24:49 <Botje> ... BUT WILL IT HAVE ROUNDED CORNERS?
15:25:07 <lament> if lively kernel didn't revolutionize web, nothing ever will!
15:25:12 <Arnfreth> ehird_, as in putStr "\r, 80 ' ', \r" ???
15:25:12 <notagirl> what's null character?
15:25:12 <stepcut> ehird_: Here is a simple example, the 'state' is just a page view counter in this case, but it could be anything: http://src.seereason.com/homepage-haaps/src/SimpleState.hs
15:25:15 <lament> (and lively kernel didn't, because it sucks)
15:25:16 <ehird_> Botje: rounded corners are so web 2.0
15:25:20 <Arnfreth> I'm sorry if I'm sounding a little lost here
15:25:26 <notagirl> like, I want to putStr 'something that'll not do anything'
15:25:26 <ehird_> minimalist = web 3.0
15:25:34 <stepcut> ehird_: the app uses write-ahead logging, so if you kill the app and restart it, it will remember where it left off
15:25:35 <lament> lynx!
15:25:37 <ehird_> Arnfreth: no, 80 spaces
15:25:45 <Arnfreth> ah
15:25:47 <Jedai> Arnfreth: putStr $ '\r' : replicate 80 ' ' ++ "\r"
15:25:53 <Arnfreth> gotcha
15:26:06 <stepcut> ehird_: you just work with the normal data haskell structures in memory, and the write-ahead disk logging is completely transparent
15:26:11 <ehird_> whatever lively kernel is it must suck because it is not MY AWESOME FRAMEWORK
15:26:17 <ehird_> stepcut: defn: write-ahdead disk logging
15:26:22 <notagirl> f printNewLine str = do { putStr str;  if printNewLine then putChar '\n' else putChar ' ?? ' }
15:26:37 <lament> ehird_: do have a look: http://research.sun.com/projects/lively/
15:26:37 <lambdabot> Title: Sun Labs Lively Kernel
15:26:43 <stepcut> ehird_: and, you don't have to marshall to/from SQL. You just do, $(deriveSerialize ''MyDataType)
15:26:50 <ehird_> lament: eww. pretends the web is something it's not
15:27:04 <ehird_> continuations arguably do that too but in a transparent way that doesn't affect the user experience in any way but positively
15:27:08 <ehird_> (if you mix it with enough REST)
15:27:09 <lament> ehird_: no it doesn't.
15:27:17 <vss> hi
15:27:32 <ehird_> stepcut: soo.. what is write-ahead disk logging
15:27:33 <ehird_> :D
15:27:41 <stepcut> ehird_: it writes a file to disk describing the change it is going to make to the database before it makes the change
15:27:58 <ehird_> stepcut: so it uses a regular RDBMS?
15:27:58 <notagirl> it's '\&'
15:27:59 <lament> ehird_: it doesn't pretend, it actually changes web into something it usually isn't
15:28:06 <notagirl> > length "\&"
15:28:07 <lambdabot>  0
15:28:08 <stepcut> ehird_: if it loses power, when it comes back online, it just reads the log and reconstructs the state
15:28:11 <vss> got confused, I have a simple function which is supposed to be partially defined at this point (during development):
15:28:11 <ehird_> lament: that's not what i want.
15:28:12 <notagirl> haha i'm a hacker!
15:28:25 <stepcut> ehird_: no, it has it's own system
15:28:25 <ehird_> lament: i want a way to write normal web apps (well, slightly sweeter) with nicer prorgamming
15:28:26 <vss> open :: FilePath -> AccessMode -> Stor
15:28:26 <vss> open fn WMode = Stor
15:28:33 <ehird_> stepcut: okay
15:28:37 <ehird_> stepcut: can it do functions :p
15:28:51 <vss> data AccessMode = RMode | WMode | MMode
15:29:04 <stepcut> ehird_: no. It could if someone added a function to serialize thunks (such as what mobile Haskell does), but that requires compiler level support
15:29:29 <ehird_> stepcut: oh well
15:29:29 <vss> now, when I call (open "tmp" MMode), it returns Stor. why? I expected a patter match failure and exception
15:29:40 <ehird_> stepcut: it truly is impossible to serialize continuations without finding functions in the way. sigh
15:32:03 <stepcut> ehird_: as far as I know, that is true. That is were scheme and clean currently win out. But, it is not fundamentally at odds with Haskell, it is just not available in a mainline compiler yet
15:32:31 <Arnfreth> another question: how do I make backspace work?
15:32:36 <dolio> Just wait until the Clean compiler gets Haskell 98 support. :)
15:32:58 <ehird_> stepcut: is there literally no way now or can I roll my own Cont that lets you do it?
15:33:06 <Arnfreth> as in, I'm about to write stuff to getLine, but haven't pressed enter, and I want to delete the last character
15:33:21 <Arnfreth> is there an ANSI code that deletes a character?
15:33:28 <ehird_> Arnfreth: \8
15:33:40 <Arnfreth> thanks, I'll try!
15:34:18 <Arnfreth> It doesn't do me good :/
15:34:31 <ehird_> actually, i think on its release my framework will be one of the few continuation-based webframeworks that are actually designed & usable for real stuff
15:34:33 <stepcut> ehird_: As far as I know, there is currently no way -- but I am not an expert in this area.
15:34:36 <ehird_> along with Seaside and maybe one other
15:34:39 <lament> is the clean compiler getting haskell 98 support any time soon? :)
15:34:48 <ehird_> stepcut: Assuming I have access to the original source code, maybe it would be easier
15:34:56 <stepcut> lament: it was announced that it is in progress
15:35:04 <lament> wow
15:35:04 <stepcut> lament: but they didn't say anything about soon ;)
15:36:25 <lament> bah, clean doesn't even have an irc channel
15:37:51 <ehird_> :/
15:38:00 <stepcut> ehird_: maybe you could do something limited using template haskell and the GHC API. All the arguments to the function would have to be fully evaluated and serializable. Though, I am not sure if that would end up being much better than what WASH does
15:38:39 <ehird_> stepcut: fully evaluated shouldn't really be a problem
15:38:42 <ehird_> and nor should serializable
15:40:36 <ehird_> stepcut: what does WASH do to serialize them?
15:41:44 <stepcut> ehird_: read/show I believe
15:43:30 <ehird_> stepcut: Continuations? Uhh, how is that possible?
15:43:53 <stepcut> ehird_: you should read the paper perhaps
15:44:10 <ehird_> stepcut: started, got lost in its verbosity
15:44:58 <ddarius> Damn papers having words in them.
15:45:10 <lament> http://wiki.clean.cs.ru.nl/Projects
15:45:11 <lambdabot> Title: Projects - clean
15:45:35 <ehird_> ddarius: hehe
15:46:09 <Arnfreth> Since I'm on a question streak tonight, I might as well continue...
15:46:13 <Arnfreth> When I'm writing to a socket (an irc channel to be precise) I can only write one word
15:46:19 <Arnfreth> the rest disappears
15:46:30 <Arnfreth> and I'm not exactly sure why this happens
15:46:36 <Botje> the IRC RFC specifies it
15:46:43 <Botje> if you want more than one word, put a : in front
15:46:52 <Botje> PRIVMSG #channel :I like cookies
15:47:12 <Arnfreth> i see, thanks a lot
15:47:13 <ehird_> @type callCC
15:47:14 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
15:47:30 * ehird_ is implementing Amb in haskell for no reason
15:47:32 <Arnfreth> looks like I'll have to look into the IRC RFC a little more
15:47:37 <ehird_> type Amb a = ContT () (State [Point a]) a
15:47:47 <ehird_> type Amb a = StateT [Point a] (Cont ()) a
15:47:53 <ehird_> can't decide which, both is causing problems
15:48:19 <hpaste>  jamii pasted "Soc example 1" at http://hpaste.org/6667
15:49:00 <Ben`> how can I find the sqrt of an Integer?
15:49:04 <dolio> They're the same.
15:49:18 <dolio> Kind of an mtl bug, of sorts.
15:49:23 <yitz> > sqrt 2
15:49:24 <lambdabot>  1.4142135623730951
15:49:28 <ehird_> dolio: Really? Alright.
15:49:33 <ehird_> dolio: Which would be more sensible?
15:49:53 <Ben`> > sqrt (2 :: Integer)
15:49:54 <lambdabot>   add an instance declaration for (Floating Integer)
15:49:54 <lambdabot>     In the expression: s...
15:50:10 <yitz> > sqrt $ fromIntegral 2
15:50:11 <lambdabot>  1.4142135623730951
15:50:12 <Jedai> Ben`: sqrt . fromIntegral
15:50:18 <Ben`> thanks
15:50:29 <dolio> I don't know. I suppose it doesn't really matter. If they were made different, then StateT s (Cont r) would be able to backtrack state changes.
15:50:38 <dolio> But that isn't how it's implemented.
15:51:50 <vincenz> ehird_: bit more info?
15:52:03 <ehird_> vincenz: amb(a,b,c,...) returns one of its arguments
15:52:10 <ehird_> it avoids letting amb() be called
15:52:25 <ehird_> if amb() is called, it will tweak the other amb's return values into all the permutations until amb() is not called
15:52:30 <ehird_> if it exhausts all possibilities, it dies
15:52:37 <vincenz> < ehird_> can't decide which, both is causing problems
15:54:13 <dolio> It'll probably be easier to implement that using both a success and failure continuation.
15:54:40 <dolio> Otherwise you'll probably have to muck around with callCC.
15:55:05 <ehird_> yeah
15:55:18 <ddarius> data AmbSig term = Fail | Amb term term; type AmbMonad = FreeMonad AmbSig; -- QED
15:55:38 <ehird_> amb []     = backtrack
15:55:38 <ehird_> amb (x:xs) = callCC $ \exit -> do
15:55:39 <ehird_>                callCC $ \k -> do addPoint k; exit x
15:55:39 <ehird_>                amb xs-
15:55:43 <ehird_> that's my 'amb'
15:55:53 <ehird_> the trick is getting the others to work :)
15:56:05 <ehird_> addPoint should add one of amb's continuations to the monad's internal state
15:58:27 <ehird_> woot
15:58:29 <ehird_> think i got it
15:58:30 <hpaste>  vss pasted "why no pattern match failure?" at http://hpaste.org/6669
16:00:43 <monochrom> That's interesting, vss.
16:01:39 <vss> monochrom: it's ghci 6.6
16:02:28 <ehird_> @type runCont
16:02:30 <mib_4dcel60t> does anyone know how to implement a findReplaceDialog in wxhaskell, any help would be appreciated
16:02:30 <ehird_> @type runStateT
16:02:31 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
16:02:32 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
16:02:45 <mib_4dcel60t> i just can't seem to understand the haddock
16:02:49 <ehird_> odd
16:02:51 <ehird_> runAmb :: Amb a b -> b
16:02:52 <ehird_> runAmb = runCont . evalStateT []
16:02:56 <ehird_> type Amb a = StateT [Point a] (Cont ())
16:02:59 <ehird_> and yet i get an  error
16:03:01 <monochrom> I'm on ghc 6.8.2 and I can get an error as expect.  However I don't recall 6.6 letting it through.
16:03:03 <ehird_> probably something obvious
16:03:13 <vincenz> :t runCont
16:03:14 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
16:03:33 <monochrom> Make sure you have saved, reloaded, etc. :)
16:03:34 <dolio> @type flip runCont id . flip evalStateT []
16:03:35 <lambdabot> forall a a1. StateT [a1] (Cont a) a -> a
16:03:44 <ehird_> oh, of course
16:04:19 <vss> monochrom: I did. If I change to 'data Stor = Stor Integer', all works
16:04:24 <ehird_> dolio: wait no
16:04:27 <ehird_> it's (Cont ())
16:04:32 <ehird_> and 'a' might not be ()
16:04:38 <ehird_> oh
16:04:40 <ehird_> that's my own fault
16:04:41 <ehird_> heh
16:04:42 <dolio> Oh, well, then you need an a -> ().
16:04:53 <ehird_> dolio: Well, no. I want to extract the value.
16:05:00 <yitz> vss: I just added "deriving Show" to Stor, and then it fails.
16:05:26 <ehird_> I want runAmb :: a -. b
16:05:27 <dolio> Amb probably needs an extra parameter.
16:05:28 <yitz> I'm on 6.8.2
16:05:29 <ehird_> with the amb above
16:05:38 <yitz> this looks like a bug
16:05:42 <ehird_> dolio: Three? Bah.
16:05:46 <ehird_> It works fine right now, I just can't run it :D
16:05:47 <dolio> Amb r a b
16:05:54 <dolio> runAmb :: Amb b a b -> b
16:06:05 <vss> yitz: yep, same here
16:06:08 <ehird_> dolio: r is the hidden b param
16:06:22 <ehird_> it's (Amb type result)
16:06:28 <ehird_> where 'type' is the type of the values you're amb-ing
16:06:50 <ehird_> example :: Amb Integer (Integer,Integer)   -- I have this
16:06:50 <ehird_> the idea is to get (Integer,Integer) out of that
16:06:51 <monochrom> vss: ghc 6.6.1 gives an error too.
16:07:33 <dolio> Actually, maybe you could do: Amb a b = Amb (forall r. StateT [Point a] (Cont r) b)
16:07:42 <vss> monochrom: ok, I guess 6.6 is too old :-) thanks
16:07:51 <yitz> vss: well, i guess i can see the logic. ghci sees that it's going to need to print the type and complains, before it even attempts the pattern match. Really weird though.
16:07:53 <dolio> Not sure about that, though.
16:08:42 <yitz> vss: wh? 6.8.2 does not give an error
16:09:38 <monochrom> ??  6.8.2 does give an error.
16:09:38 <lambdabot>  6.8.2 does give an error.
16:09:57 <monochrom> lambdabot agrees with me?!
16:10:06 <vincenz> keep on dreaming
16:10:13 <monochrom> Never trust a computer when it agrees. :)
16:11:30 <ddarius> Computers.  Nothing but a bunch of 1 men
16:11:48 <ehird_> runAmb :: Amb a r r -> r
16:11:51 <ehird_> 'Arr! ...r'
16:12:03 <idnar> Control.Arrow.arr
16:12:07 <yitz> monochrom: not a pattern match failure. it complains that Stor doesn't have a Show instance.
16:12:23 <yitz> ?Arr
16:12:23 <lambdabot> I'll keel haul ya fer that!
16:12:24 <monochrom> That's right, it happens in both 6.6.1 and 6.8.2.
16:12:27 <ehird_> my only problem now is that since 'amb' in my Amb Integer returns an Integer, I can't use it as an arbitary 'a'
16:12:29 <ehird_> when backtracking
16:12:31 <ehird_> i need do do like
16:12:34 <ehird_> do amb []; return (0,0)
16:12:36 <ehird_> for a dummy
16:13:42 <mib_4dcel60t> anyone knows wxhaskell?
16:13:44 <yitz> vss: is the behavior different in 6.6?
16:14:00 <monochrom> But the claim is "Stor" is successfully printed.  This implies the pasted code forgets a Show instance for Stor, and that if you fill that in, there is still no pattern error.
16:14:53 <yitz> oh, i see. that would be bad.
16:14:56 <ehird_> the basic problem is:
16:15:00 <ehird_> amb :: [a] -> Amb a r a
16:15:06 <ehird_> expand..
16:15:10 <vss> yitz: what exactly?
16:15:11 <ehird_> [Integer] -> Amb Integer r Integer
16:15:24 <ehird_> and thus it can't be used as an 'anything'
16:15:47 <yitz> vss: do you actually have "deriving Show" for Stor, or instance Show Stor?
16:16:26 <vss> yitz: with "deriving" it failed on pattern match; with "instance Show Stor" it didn't
16:16:26 <ehird_> zook :: Amb a r b
16:16:27 <ehird_> zook = do backtrack; return undefined
16:16:30 <ehird_> but then that's not in 'amb'
16:16:54 * yitz tries instance Show Stor
16:17:07 <dolio> What's your current Amb definition?
16:17:12 <ehird_> newtype Point a r = Point (() -> Amb a r a)
16:17:12 <ehird_> type Amb a r = StateT [Point a r] (Cont r)
16:17:38 <dolio> Oh, I was thinking with the extra parameter, actually.
16:17:53 <ehird_> That is.
16:17:55 <ehird_> It is used like:
16:17:58 <ehird_> type Amb a r b = StateT [Point a r] (Cont r) b
16:18:11 <ehird_> In every type signature, 'r' is never specified. It is just 'r'.
16:18:20 <dolio> Oh, right, I see.
16:18:24 <ehird_> It helps the continuations float about in whimsical-land.
16:18:30 <yitz> ok, no error. *Stor> open "foo" RMode
16:18:30 <yitz> Stor
16:18:34 <ehird_> Amb a r r -> r    -- this is when it's specified
16:18:41 <dolio> Yeah, it's only used at the end.
16:18:44 <ehird_> and even then it has no effect, it just forces r so that runCont is happy
16:18:50 <dolio> When you want to get out of CPS.
16:18:55 <yitz> monochrom: no error in 6.8.2
16:19:37 <dolio> Well, as I said, you could try: newtype Amb s a = Amb { unAmb :: forall r. StateT [s] (Cont r) a }
16:19:49 <dolio> Monad is definable for that, at least.
16:20:20 <ehird_> dolio: Does that help with my (amb []) typing problem?
16:20:25 <dolio> I'm not sure about callCC, though.
16:20:32 <ehird_> And I want to avoid ghc exts
16:21:14 <hpaste>  yitz annotated "why no pattern match failure?" with "added a Show instance" at http://hpaste.org/6669#a1
16:25:00 <hpaste>  ehird pasted "amb in Haskell: done, apart from being able to s/zook/amb []/g" at http://hpaste.org/6670
16:25:23 <ehird_> hmm
16:25:24 <ehird_> points take ()
16:25:27 <ehird_> so i don't need that previous undefined
16:25:28 * ehird_ fixes
16:25:56 <hpaste>  ehird annotated "amb in Haskell: done, apart from being able to s/zook/amb []/g" with "ok, now REALLY almost done :p" at http://hpaste.org/6670#a1
16:28:24 <ehird_> interesting
16:28:28 <ehird_> i recreated the list monad :p
16:28:40 <ehird_> for the 'factor' example,
16:28:55 <dolio> Yeah.
16:28:57 <ehird_> remove all 'amb's, and change 'zook' with '[]'
16:29:05 <ehird_> then change 'runAmb' to 'head'
16:29:16 <ehird_> dolio: Even so, the implementation itself is pretty interesting, wouldn't you say?
16:29:39 <dolio> Yeah, I'm a fan of continuations.
16:30:46 <ehird_> Especially since the continuations I have there don't look like imperative programming (which a lot of continuations in haskell do)
16:31:01 <ehird_> dolio: Is the 'zook' -> 'amb []' thing possible and still have it type properly?
16:32:19 <dolio> Hmm.
16:33:59 <skorpan> wow.. i'm reading dons' code for hmp3 at the moment and i must say it's extremely well written.
16:34:09 <mib_4dcel60t> i create a replace function but it doesn't seem to work the way it should, can i get some help
16:34:13 <skorpan> even i understand most of it
16:34:49 <ehird_> dolio: I am not convinced it is.
16:35:15 <ehird_> because it would make the ambs on actual arrays meaningless
16:35:19 <ehird_> Unless, that is..
16:35:19 <hpaste>  n00b pasted "repace function " at http://hpaste.org/6671
16:35:28 <ehird_> ..I can get backtrack to return something arbit- no, that won't work
16:35:31 <ehird_> amb's type constraints still apply
16:36:18 <ehird_> amb :: [b] -> Amb a r b
16:36:21 <ehird_> yessss
16:36:42 <ehird_> i am so damn clever
16:37:06 <hpaste>  ehird annotated "amb in Haskell: done, apart from being able to s/zook/amb []/g" with "yesss" at http://hpaste.org/6670#a2
16:37:24 <ehird_> hmm, is the order of parameters to Amb as nice as they could be? opinions welcome
16:37:37 <lament> what i don't understand is how can web frameworks NOT be continuation-based
16:37:40 <mib_4dcel60t> could anyone take a look at my replace please and tell me whats the err
16:37:48 <lament> ...and yet pretty much none of them are
16:37:55 <ehird_> hmm, oops
16:38:08 <ehird_> change [a] to [b]
16:38:10 <ehird_> in amb
16:39:20 <ehird_> factor was wrong too, oops
16:39:53 <ehird_> @djinn (Monad m) => [m a] -> m [a]
16:39:56 <ehird_> @hoogle (Monad m) => [m a] -> m [a]
16:39:57 <lambdabot> Prelude.head :: [a] -> a
16:39:57 <lambdabot> Prelude.last :: [a] -> a
16:39:57 <lambdabot> Data.List.head :: [a] -> a
16:40:01 <ehird_> bah.
16:40:01 <glguy> sequence
16:40:04 <ehird_> oh
16:40:04 <ehird_> of course
16:40:22 <yitz> lament et al.: i've been looking for years for something that continuations are useful for in haskell. so far, there's always a monad that makes it much simpler. do you think web frameworks is the example i've been looking for?
16:40:26 <ehird_> glguy: just trying to extend 'factor' to an arbitarily large number of factors :D
16:40:36 <ehird_> [23:37] <lament> what i don't understand is how can web frameworks NOT be continuation-based
16:40:37 <ehird_> i agree
16:40:41 <ehird_> it's so convenient
16:40:43 <dons> yitz: i think i agree. :)
16:40:46 <ehird_> & makes web apps so much more interactive
16:40:50 <ehird_> yitz: http://seaside.st
16:40:54 <dons> in Data.Binary we started with a ContT
16:40:59 <dons> but ended up with a simpler monada
16:41:09 <ehird_> but ofc you can implement it as a monad
16:41:13 <ehird_> it'll just be almost identical to Cont/ContT
16:41:13 <Jedai> mib_4dcel60t: What's the problem ?
16:41:21 <ddarius> yitz: You can just package continuations up in a monad so that's always true.
16:41:30 <yitz> ehird: apt-get is busy, my browser is down. what is it?
16:41:37 <ehird_> yitz: a continuation based web framework.
16:41:39 <ehird_> it is very good.
16:41:52 <ehird_> the only stable, production-usable one out there, really. Used in real environments
16:41:54 <yitz> ddarius: i don't mean MonadCont, I mean non-continuation.
16:41:54 <ehird_> Smalltalk.
16:42:01 <yitz> ah
16:42:48 <ddarius> yitz: Many of the uses of continuations are to model other side-effects, e.g. exceptions, concurrency, non-determinism.
16:43:03 <ddarius> yitz: If you only want one, then continuations are overkill.
16:43:15 <ehird_> anyone have comments on the order of Amb arguments?
16:43:23 <ehird_> right now it's Amb STATE r RESULT
16:43:25 <ehird_> where 'r' is always 'r'
16:43:32 <ehird_> STATE is the types you call amb with
16:43:41 <ehird_> in (amb [1,2,3]) STATE = (Num a) => a
16:43:51 <ehird_> RESULT is the final value, e.g. for my factor example (Integer,Integer)
16:43:51 <yitz> ddarius: but continuations seem so convoluted. all those things can be modeled so nicely in a monad. why continuations?
16:44:05 <ehird_> yitz: because with e.g. seaside it really is pure continuations
16:44:09 <ehird_> not used to emulate other things
16:44:11 <lament> continuations are convoluted???
16:44:16 <ehird_> and a monad emulating it would just be reinventing continuations
16:44:28 <lament> continuations should be really simple to anybody who ever used a web app
16:44:37 <yitz> ehird_: i view it the other way around
16:45:03 <ehird_> yitz: you haven't tried seaside, you have no podium on which to comment on
16:45:13 <ehird_> lament: Exactly!! The back button is a continuation.
16:45:27 <vincenz> My life is one big continuation
16:45:37 <ddarius> yitz: Continuations are one effect that can be used to model many (with shift/reset or state, any).  They are expressive and they allow you to model these things without making global changes to your code unlike monads.
16:45:55 <yitz> ehird_ i'll look at it later, thanks.
16:45:57 <ddarius> However, usually in any particular application you only need a few rather specific effects.
16:46:13 <vincenz> ddarius: the modelling of shift/reset in terms of continuations is somewhat flawed iirc
16:46:42 <ehird_> I think I'll change (Amb STATE r RESULT) into (Amb r STATE RESULT)
16:46:45 <yitz> ddarius: i would agree with your statement completely if you interchange continuation <-> monad :)
16:47:21 <vincenz> yitz: monads are just a way to sequence acctions...
16:47:58 <ehird_> if you want ghc dependency you can then do:
16:48:01 <lament> ehird_: but really, the kind of control that the back button allows is only a small subset of what continuations can do... no?
16:48:01 <ddarius> yitz: A monad isn't an effect it is used to model them and monadic style is a global transformation.
16:48:09 <ehird_> type Amb' = forall r. Amb r
16:48:24 <ddarius> yitz: I can express Prolog in Scheme with a couple of macros and some library routines (using call/cc and state).  I can't do that in Haskell.
16:48:31 <vincenz> ehird_: Hmm, what is that useful for?
16:48:42 <ehird_> vincenz: what, amb?
16:48:47 <vincenz> no the forall bit
16:48:52 <vincenz> seems a bit redundant
16:48:56 <ehird_> vincenz: oh. because type Amb' = Amb r won't work
16:48:59 <ehird_> obviously.
16:49:05 <ehird_> all type variables on the RHS must appear on the LHS
16:49:07 <vincenz> type Amb' r = Amb r
16:49:07 <ehird_> unless used in a forall
16:49:10 <ehird_> uhh
16:49:12 <ehird_> that's just Amb
16:49:13 <ehird_> :-)
16:49:20 <vincenz> ah :)
16:49:23 <ehird_> vincenz: the point is, you always pass a type variable as the first argument to Amb
16:49:26 <bd_> type Amb' = Amb r isn't useful though, because you can't do anything meaningful with the value in it :)
16:49:31 <ehird_> Amb r Integer (Integer,Integer) -- for instance
16:49:41 <ehird_> it's the argument to Cont
16:49:53 <yitz> ddarius: continuations are not any less global than monads - you have to add a function parameter to every function. For monads, you just use m a instead of a as your return types.
16:49:58 <ehird_> so Amb' Integer (Integer,Integer) is a bit clearer
16:50:15 <ehird_> type Amb' a b = forall r. Amb r a b -- need this actually
16:50:17 <dolio> yitz: He's talking native continuations.
16:50:18 <ddarius> yitz: -CPS- isn't any less global.  call/cc is very local.
16:51:07 <ehird_> hmm
16:51:10 <ehird_> I wonder if AmbT is possible
16:51:10 <yitz> ddarius: yes, you're forced to use continuations in scheme, because it doesn't have support in the type system to do monads directly like in haskell.
16:51:15 <ehird_> just change the Cont to a ContT
16:51:17 <yitz> call/cc eww
16:51:17 <ehird_> coool
16:51:26 <ehird_> yitz: you are talking nonsense
16:51:30 <ehird_> Just pointing that out.
16:51:32 <monochrom> I think one can prove that web browsing with random access to history checkpoints is equivalently to callcc.
16:51:37 <yitz> :)
16:51:45 <ddarius> yitz: In Scheme there is no reason to use monads.
16:51:54 <ehird_> monochrom: Ah, yes.
16:51:57 <ehird_> But.. back buttons have a dropdown
16:52:00 <ehird_> Which provides recent entries
16:52:05 <ehird_> So they're expiring continuations, I guess.
16:52:14 <ehird_> But yeah, the History pane is callcc.
16:52:25 <ehird_> Well, a weird, mutable call/cc since the web is mutable.
16:52:36 <monochrom> Yes, the dropdown provides random access to history checkpoints.  Also you can re-invoke the same checkpoint over and over.
16:52:48 <ivanm> ddarius: so is that a reason to envy or pity schemers? :p
16:54:08 <ddarius> ivanm: Depends on your tastes.
16:54:20 <ivanm> heh
16:54:22 <lament> ehird_: the thing about call/cc is that it returns a value from the future into the past
16:54:34 <lament> ehird_: using the history button doesn't do that - it simply brings you back to the past
16:54:34 <ehird_> FooT's are FooT m a, right?
16:54:42 <ehird_> Where m is the inner monad and a the result type.
16:54:45 <vincenz> yep
16:54:49 <ehird_> Then it's (AmbT r m a)
16:54:56 <lament> ehird_: so i don't think you need call/cc
16:55:20 <ehird_> lament: well, no
16:55:25 <ehird_> i don't travel in time when i use the history
16:55:25 <ehird_> :)
16:55:40 <ddarius> I do.
16:55:43 <ddarius> Whee!
16:56:05 <ehird_> Heh.
16:56:41 <ddarius> Unfortunately my time machine is stuck in 2nd gear.
16:56:48 <ehird_> Gosh, type synonym transformers are brain breaking.
16:56:48 <ivanm> what kind of time machine do you use?
16:56:56 <ehird_> ivanm: TARDIS Model M+
16:57:14 <lament> ehird_: yeah, very funny, but i'm still right :)
16:57:39 <ehird_> Hmm.
16:57:46 <ehird_> the (Monad m) => should be in the T definition right?
16:58:11 <monochrom> The web site asks you to fill in a form and hands you a continuation C.  You don't fill in the form now.  You save the continuation.  You examine some other part of the web site.  Then you re-invoke C and fill in the form.  From the POV of C, it is receiving a return value (what you enter into the form) from the future, and also possibly dependent on what you saw when you visited the other parts of the website.
16:58:23 <Saizan> ehird_: no, in the Monad instance
16:58:32 <ehird_> Saizan: its a type synony,
16:58:34 <ehird_> m
16:58:44 <ehird_> newtype AmbT r m a = StateT [Point r m a] (ContT r m) a
16:58:55 <ehird_> callPoint :: (Monad m) => Point r m a -> AmbT r m b -- I have to do this to use e.g. 'return'
16:59:05 <ehird_> err
16:59:07 <ehird_> s/newtype/type
16:59:08 * ddarius never saw any reason or benefit to invoking a "time travel" metaphor for continuations.
16:59:11 <Saizan> that's how it works :)(
16:59:17 <ehird_> Saizan: alrighty
16:59:33 <monochrom> And besides, I think the view "continuation receives stuff from the future" is misleading.  It sounds catchy but it is wrong.
16:59:54 <lament> monochrom: how is it wrong?
16:59:54 <ddarius> It's obviously wrong.
16:59:56 <monochrom> It is like the nuclear waste monad story.
17:00:18 <lament> how's the nuclear waste monad story wrong? :)
17:00:23 <monochrom> How about this: How is it right?
17:00:30 <yitz> ok, then. how about continuations as "warm fuzzy things" then?
17:00:39 <ehird_> callPoint :: (Monad m) => Point r m a -> AmbT r m b
17:00:39 <ehird_> callPoint (Point f) = f () >> return undefined
17:00:42 <ehird_> doesn't work, damnit
17:00:43 <ehird_> :(
17:00:47 <monochrom> Only a Jedi mind trick would cause anyone to believe it.
17:00:49 <ehird_>     Couldn't match expected type `b' against inferred type `a'
17:02:36 <lament> monochrom: giving a value to a continuation is like going back in time to when that continuation was the current continuation, and putting that value there.
17:03:02 <Saizan> ehird_: haven't you left out a type parameter when going from Amb to AmbT?
17:03:17 <ehird_> HAHAHAH
17:03:22 <ehird_> callPoint :: (Monad t1) =>
17:03:22 <ehird_>              Point t t1 t2 -> StateT [Point t t1 t2] (ContT t t1) t3
17:03:32 <ehird_> that contains my AmbT synonym
17:03:35 <ehird_> but when I specify that...
17:03:35 <ehird_> :D
17:03:50 <monochrom> OK, but then my explanation of the web site behaviour shows that it is your time travel story.
17:03:53 <ehird_> type AmbT r m a = StateT [Point r m a] (ContT r m) a
17:03:56 <ehird_> callPoint :: (Monad m) => Point r m a -> AmbT r m b
17:04:00 <ehird_> callPoint :: (Monad t1) =>
17:04:01 <ehird_>              Point t t1 t2 -> StateT [Point t t1 t2] (ContT t t1) t3
17:04:07 <ehird_> good luck how figuring out that only the second callPoint works
17:04:37 <monochrom> Or perhaps web site behaviour together with user behaviour.
17:04:54 <ehird_> anyone know why the thing breaks it
17:04:55 <ehird_> ?
17:05:23 <ddarius> monochrom: I think you missed something in that first sentence.
17:05:33 <monochrom> What did I miss?
17:05:42 <ehird_> seriously, what the hell
17:05:46 <ehird_> a TYPE SYNONYM is breaking this
17:05:47 <ddarius> I don't know, but the sentence makes no sense to me currently.
17:05:58 <monochrom> Which sentence?
17:06:11 <lament> monochrom: i'm not sure if it's necessary to think of filling a form as passing a value to a continuation.
17:06:11 <ddarius> [19:03] <monochrom> OK, but then my explanation of the web site behaviour shows that it is your time travel story.
17:06:30 <ehird_> oh, i see
17:06:38 <ehird_> goddamn
17:06:59 <monochrom> Alright. lament says that continuation is time travel.  So I say that web site is doing time travel too.
17:07:04 <ehird_> since I have the 'a' in my definition
17:07:09 <ehird_> and Point's contained function
17:07:11 <ehird_> returns AmbT r m a
17:07:18 <ehird_> I cannot (>>) an AmbT r m a and an AmbT r m b
17:07:19 <lament> monochrom: if we associate continuations with each _displayed web page_, then we don't need to bring values from the future
17:07:22 <ehird_> since they are different types
17:07:28 <ehird_> in Amb I left out that param because it was implicit
17:07:34 <ehird_> but I can't do that for a transformer
17:07:34 <ehird_> :(
17:07:41 <EvilTerran> ... you should be able to
17:07:49 <lament> monochrom: filling out a form is just passing input to the program. No calling of continuations involved.
17:07:53 <ehird_> EvilTerran: wanna see my code?
17:07:56 <EvilTerran> instance Monad m => Monad (AmbT r m) where ...
17:07:57 <Saizan> ehird_: use type AmbT r m a = StateT [Point r m a] (ContT r m)
17:08:04 <ehird_> EvilTerran: it's a type synonym, damnit
17:08:06 <lament> monochrom: it's _quite_ possible that i am on crack.
17:08:18 <monochrom> It is never necessary to think of X as Y.  Never.  This doesn't contradict that X and Y may still be equivalent.
17:08:27 <Saizan> ehird_: and  Monad (AmbT r m a)
17:08:28 <ehird_> Saizan: and define Point?
17:08:30 <EvilTerran> ehird_, ah, there's your problem. you'll need a newtype at least for that.
17:08:35 <yitz> We just switched to daylight savings time (summer time) ten minutes ago. Someone here called call/cc, and now I'm out an hour of sleep.
17:08:43 <Saizan> ehird_: Point stays the same
17:08:53 <ehird_> Saizan: Then AmbT is not applied enough arguments
17:08:58 <ehird_> newtype Point r m a = Point (() -> AmbT r m a) -- current defn
17:08:58 <EvilTerran> lament, i think it's just different ways of looking at the same issue
17:09:27 <Saizan> newtype Point r m a = Point (() -> AmbT r m a a)
17:09:43 <lament> EvilTerran: no, because my original point was that something weaker than full call/cc could possibly suffice
17:09:47 <ehird_> @hpaste
17:09:47 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:09:55 <EvilTerran> if servers supported it, you could write "do formResult <- sendFormPage; sendReplyPageTo formResult
17:10:03 <Saizan> ehird_: as i was trying to say earlier, Amb had 3 type parameters, when you add the m one, you must have 4 type parameters now.
17:10:17 <hpaste>  ehird pasted "wtfness" at http://hpaste.org/6672
17:10:26 <EvilTerran> perhaps. i'm not getting involved.
17:10:31 <ehird_> EvilTerran: yes! you CAN do that!
17:10:35 <ehird_> it's called a continuation web server
17:10:54 <monochrom> I want to once again emphasize that it is the web server that experiences time travel, not the user.
17:10:56 <EvilTerran> ooh, ooh, i want one
17:11:10 <ehird_> EvilTerran: what's more they work over multiple tabs, etc
17:11:31 <ehird_> EvilTerran: also, you know when you try an action on a website and it fails because you need a login? well, normally they shoot you back to the index
17:11:36 <ehird_> with a continuation server, it can just continue the action
17:11:40 <ehird_> because it does something like:
17:11:49 <ehird_> 'blah blah ... if not logged in, do login ... blah blah'
17:11:56 <ehird_> and because the continuation is captured, it returns fine
17:12:13 <ehird_> basically, not only do continuation servers make the programming behind the app nicer, they improve user experience too
17:12:47 <lament> in theory, anyawy
17:13:22 <hpaste>  Saizan annotated "wtfness" with "this typechecks" at http://hpaste.org/6672#a1
17:13:30 <ehird_> Saizan: I just got whsat you were saying
17:13:30 <lament> in practice it's like... slow :)
17:13:31 <ehird_> thanks!
17:13:36 <ehird_> lament: slow? hardly
17:13:44 <monochrom> How do you know it's slow?
17:13:50 <ehird_> only if you do a 'copy the whole stack' continuation
17:13:52 <ehird_> which is retarded :)
17:14:24 <lament> http://www.seaside.st is slow, therefore continuation-based web frameworks are all slow!
17:14:35 <ehird_> lament: hehe :)
17:14:39 <ehird_> seaside's host probably sucks
17:14:43 <ehird_> + the page is a  bit heavy on the styling
17:14:46 <ehird_> seaside itself is blazing
17:14:52 <ddarius> Smalltalk is slow therefore all object-oriented languages are slow.
17:15:05 <monochrom> Where the hell is "st" anyway?
17:15:06 <lament> also, seaside website is pretty terrible for navigation because all URLs look like "http://www.seaside.st/?7&_k=SVhWSPSA&_n&_s=dNvqOgzRvDRgcQdk"
17:15:12 <ehird_> monochrom: smalltalk extension is '.st'
17:15:13 <vincenz> A porsche standing in my garage is slow, hence all porsches are slow
17:15:15 <ehird_> :)
17:15:16 <dolio> Smalltalk isn't that slow, is it?
17:15:21 <dolio> You'd have better luck with Ruby.
17:15:23 <lament> which does NOT improve the user's experience
17:15:24 <gnuvince_> dolio: which Smalltalk?
17:15:30 <ehird_> lament: _k is the continuation id. You need that if not doing a POST
17:15:33 <ehird_> _s is the session
17:15:39 <ehird_> the first bit is the numbered actin on the page
17:15:40 <dolio> Any of them?
17:15:41 <ehird_> It's not pretty, for sure.
17:15:48 <ehird_> It can be made nicer.
17:15:49 <dolio> Maybe Squeak is slow, I don't know.
17:15:56 <monochrom> Woah?!  You mean one can register a "xxx.st" domain?
17:15:57 <ehird_> But eventually unless you make everything POSt you need at least one id in the url
17:16:01 <lament> ehird_: right, just that you were talking about "user's experience"
17:16:01 <vincenz> dolio: it is rumored to be
17:16:02 <ehird_> monochrom: It's some country.
17:16:14 <lament> dolio: yes, squeak is slow.
17:16:23 <monochrom> Well, that is why I asked "where the hell is st"!!!
17:16:25 <ehird_> lament: my framework's stuff will look more like http://seaside.st/counter/@1F65A8D9F5
17:16:29 <ehird_> which is far prettier
17:16:42 <ehird_> a bit ugly, but let's put it this way: the case for GET continuations is few and far between
17:16:50 <ehird_> most of the time you'll either be making form transactions nicer or doing REST
17:17:02 <ehird_> for the remaining cases, a little id on the end of the url -- like the one i showed -- is fine
17:18:05 <lament> ehird_: does that mean you can't bookmark anything, because that continuation will expire?
17:18:23 <vincenz> continuations should be used sparingly
17:20:08 <ddarius> Values should be used sparingly.  Continuations should be used willy-nilly.
17:21:02 <ehird_> lament: let's run through the cases:
17:21:07 <EvilTerran> lament, why must continuations expire?
17:21:18 <ehird_> REST - a persistant resource, no continuations. Bookmarks FINE.
17:21:25 <ehird_> POST continuations - you can't bookmark POSTs anyway
17:21:35 <EvilTerran> for a bit of the site that would otherwise be bookmarkable, you could serve the same continuation to everybody
17:21:56 <ehird_> GET continuations - Please see above: these are quite rare. eventually it must expire yes (Unless you can serialize them somehow), but things that could logically be bookmarked should probably be REST.
17:22:06 <ehird_> EvilTerran: that defeats the point
17:22:19 <EvilTerran> which point?
17:22:30 <ehird_> type AmbT r m a = StateT [Point r m a] (ContT r m)
17:22:30 <ehird_> type Amb r a b = AmbT r Identity a b
17:22:32 <ehird_> I think that is correct..
17:22:37 <ehird_> EvilTerran: Of continuation servers
17:23:03 <EvilTerran> i mean, you could use different continuations for everyone for bits where it actually matters
17:23:13 <ehird_> EvilTerran: That's just using no continuation until you need it.
17:23:22 <ehird_> The 'REST' part of my classifications.
17:23:25 <EvilTerran> i'm just trying to wedge RESTful stuff into the continuation style
17:23:27 <ehird_> Besides, the 'actually matters' part can cost memory.
17:23:36 <ehird_> EvilTerran: My framework will be REST+Continuation
17:23:49 <EvilTerran> oh, you're making a framework? cool
17:23:53 <ehird_> in Haskell, yeah
17:24:01 <EvilTerran> sorry, i wandered into the middle of this conversation, and don't really know what's going on ;)
17:24:08 <ehird_> Neither do I! :D
17:24:26 <EvilTerran> where am i again? ... and who are you people?!
17:24:55 <EvilTerran> WHAT'RE YOU DOING IN MY COMPUTER?! D:
17:25:02 <ehird_> type AmbT r m a = StateT [Point r m a] (ContT r m)
17:25:02 <ehird_> type Amb r a = AmbT r Identity a
17:25:08 <ehird_> why does that not work like my original Amb?
17:25:08 <ehird_> :(
17:25:37 <EvilTerran> what was your original Amb again?
17:26:47 <ehird_> EvilTerran: http://hpaste.org/6670#a2
17:26:51 <ehird_> but in amb's type, change [a] to [b]
17:27:58 <Saizan> mmh
17:28:42 <ehird_> hmm
17:28:48 <ehird_> I should have AmbT r a m b
17:28:54 <ehird_> where a = state
17:28:57 <ehird_> m = inner monad (obviously)
17:28:57 <EvilTerran> well, lessee... Amb r a  =  AmbT r Identity a  =  StateT [Point r Identity a] (ContT r Identity)
17:28:58 <ehird_> b = return
17:29:02 <ehird_> StateT follows that convention
17:29:11 <sphynx> hi!
17:29:20 <sphynx> How can I load into ghci .hsc module?
17:29:26 <EvilTerran> ... have you changed the definition of Point?
17:29:43 <sphynx> I have one .hsc in imports, but GHCi could not find it
17:29:48 <ehird_> newtype Point r a m = Point (() -> AmbT r a m a)
17:29:56 <ehird_> (I just switched around a and m. Please ignore)
17:30:18 <sphynx> maybe I should provide some option to GHCI?
17:31:02 <EvilTerran> this is getting too long and complicated for me at this hour... i'm gonna tag Saizan in again :P
17:31:11 <hpaste>  ehird pasted "AmbT + problem" at http://hpaste.org/6673
17:31:12 <Saizan> sphynx: you need to use a preprocessor on it first
17:31:25 <ehird_>     Couldn't match expected type `Identity'
17:31:25 <ehird_>            against inferred type `(,) Integer'
17:31:26 <ehird_> is an error
17:31:49 <sphynx> Saizan: how could I do this? :)
17:31:49 <Saizan> EvilTerran: hey, we're in the same timezone, i think :D
17:31:49 <stepcut> I need a Sequence data-type that supports efficient insertion and deletion for a simple text editor. Do I just want the String zipper, or is there something better in hackage ?
17:31:50 <EvilTerran> yes it is :)
17:31:52 <sphynx> Saizan: hsc2hs?
17:32:20 <ddarius> stepcut: Data.Seq
17:32:21 <EvilTerran> i've been on my feet for hours today, tho. too much unaccustomed exercise for a pasty geek like myself.
17:32:27 <EvilTerran> @localtime
17:32:27 <EvilTerran> @localtime Saizan
17:32:28 <ehird_> ahh
17:32:29 <lambdabot> Local time for Saizan is Fri Mar 28 01:33:25 2008
17:32:30 <lambdabot> Local time for EvilTerran is Fri Mar 28 00:35:12
17:32:30 <ehird_> my runAmbT
17:32:31 <ehird_> is all wrongy
17:32:34 <ehird_> but I can't seem to fix it
17:32:37 <Saizan> sphynx: yes
17:32:54 <EvilTerran> ... even later. um, ok, i fail.
17:33:17 <sphynx> Saizan: ok, thanks!
17:33:27 * Saizan wants a darcs pull from pastes
17:33:39 <ehird_> :/
17:33:52 <stepcut> ddarius: I was looking at Data.Sequence, but I did not see how to do insertion/deletion. Just updates, and appending to the beginning/end. Did I miss something ?
17:34:35 <ehird_> nobody? :p
17:35:12 <ehird_> @type runContT
17:35:13 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
17:35:29 <ehird_> Hmm.
17:35:32 <ehird_> I just cannot figure out what to do.
17:35:44 <ehird_> runAmbT :: (Monad m) => AmbT r a m (m r) -> m r -- the only type I can get for runAmbT
17:35:45 <ahunter> @type comparing (length ++ compare)
17:35:46 <lambdabot>     Couldn't match expected type `Int'
17:35:46 <lambdabot>            against inferred type `[a] -> Ordering'
17:35:46 <lambdabot>     Probable cause: `compare' is applied to too few arguments
17:35:49 <ehird_> but of course runIdentity . runAmbT doesn't work
17:36:34 <vincenz> @type (comparing length ++ compare
17:36:35 <lambdabot> parse error (possibly incorrect indentation)
17:36:37 <vincenz> @type (comparing length ++ compare)
17:36:38 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Ordering
17:36:39 <ddarius> stepcut: insert x sq = let (before, after) = splitAt n sq in before >< singleton x >< after
17:36:56 <ahunter> @type comparing
17:36:57 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
17:37:01 <vincenz> Cale: ping
17:37:06 <Cale> pong
17:37:07 <ehird_> :/
17:37:16 <Saizan> ehird_: runAmbT a = runContT (runStateT a []) (return . fst)
17:37:21 <ahunter> @src Ordering
17:37:21 <lambdabot> data Ordering = LT | EQ | GT
17:37:24 <vincenz> Cale: what version of stdlibs intrduces that generalized ++ ?
17:37:33 <Cale> vincenz: lambdabot's
17:37:37 <vincenz> oh
17:37:38 <vincenz> :|
17:37:44 <der_eq> I've got a tricky problem concerning type families and functional dependencies: http://hpaste.org/6674 any solutions to this?
17:37:47 <ddarius> Cale is trying to stoke a revolution.
17:37:53 <vincenz> He''s right to do so
17:37:55 <vincenz> Cale++
17:37:55 <SamB> Cale: and of course you actually have a GHC tree that implements this version?
17:38:04 <Cale> SamB: no
17:38:08 <vincenz> SamB: that or he just has overloaded prelude
17:38:14 <Cale> I just have L.hs import the prelude hiding some stuff
17:38:28 <Cale> and define my fancy versions of (++) and (.) in there.
17:38:34 <SamB> actually that was an attempt at a hint ;-)
17:38:43 <vincenz> uhuh :)
17:39:03 <ehird_> Saizan: Uhh
17:39:04 <ehird_> how about
17:39:11 <ehird_> runAmbT a = runContT (evalStateT a []) return
17:39:42 <ehird_> but yay
17:39:43 <ehird_> now it works
17:39:46 <ehird_> Hmm
17:39:52 <ehird_> Is there a ListT in the standard libraries?
17:39:58 <vincenz> ehird_: yeah
17:40:02 <ehird_> If not, I just kinda created it, since Amb is []
17:40:02 <vincenz> @hoogle ListT
17:40:03 <lambdabot> Control.Monad.List.ListT :: newtype ListT m a
17:40:03 <lambdabot> Control.Monad.List.ListT :: m [a] -> ListT m a
17:40:03 <lambdabot> Language.Haskell.TH.ListT :: Type
17:40:14 <ehird_> heh :D
17:40:18 <Saizan> ehird_: return will give you an infinite type
17:40:24 <ehird_> Saizan: No. It worked.
17:40:28 <ehird_> runAmbT :: (Monad m) => AmbT r a m r -> m r
17:40:32 <ehird_> RAMMRR!!!
17:40:43 <vincenz> you mean
17:40:44 <ehird_> Anyway, the cool thing about Amb/AmbT is the implementation
17:40:45 <vincenz> RAMRMR
17:40:47 <ehird_> It's nice and concise
17:41:08 <ehird_> & it uses 'undefined' to work around type constraints, so it's also an amusing little hack
17:41:14 <SamB> what's Amb/AmbT?
17:41:16 <Cale> ListT is not really a monad transformer though
17:41:29 <ehird_> SamB: implements the 'amb' operator
17:41:30 <vincenz> Cale: it has a T
17:41:42 <ehird_> http://www.randomhacks.net/articles/2005/10/11/amb-operator
17:41:44 <ehird_> in short:
17:41:45 <lambdabot> Title: McCarthy's Ambiguous Operator
17:41:48 <ehird_> amb(a,b,c,...) picks an argument
17:41:50 <Cale> Yeah, it looks like a monad transformer, it just doesn't satisfy the required properties :)
17:42:00 <SamB> vincenz: but it lacks some identites
17:42:00 <Cale> (specifically, that applying it will result in a monad)
17:42:01 <ehird_> amb will avoid amb() at all costs
17:42:04 <ehird_> if it gets called with no arguments
17:42:11 <ehird_> it selects another value for all the ambs it can
17:42:18 <ehird_> once it's tried all permutations and still gets called with 0 arguments, it dies
17:42:20 <Cale> I find that characterisation of amb strange.
17:42:49 <ehird_> factor a = do x <- amb [2..]; y <- amb [2..x]; if x*y == a then return (x,y) else amb []
17:42:54 <guenni> does anybody here know how to rewrite this to make ghc accept this: fix = \f -> (\x -> f (\y -> x x y)) (\x1 -> f (\y1 -> x1 x1 y1))?
17:43:11 <SamB> ehird_: that last scenerio sounds almost ill-typed
17:43:14 <ehird_> if x*y isn't a, then amb gets called with no arguments (really, the empty list), panics, and tries another value for one of its amb
17:43:17 <ehird_> SamB: almost.
17:43:22 <SamB> perhaps I've been playing with epigram too much lately
17:43:24 <vincenz> guenni: no wy hose
17:43:25 <Cale> > let factor a = do x <- [2..]; y <- [2..x]; if x * y == a then return (x,y) else []
17:43:25 <lambdabot>  Parse error at end of input
17:43:28 <Cale> > let factor a = do x <- [2..]; y <- [2..x]; if x * y == a then return (x,y) else [] in factor 12
17:43:29 <ehird_> amb :: [b] -> Amb r a b
17:43:34 <lambdabot> Terminated
17:43:40 <ehird_> SamB: 'r' is passed to Cont, it's always that type variable
17:43:43 <ehird_> now, amb is inferred as:
17:43:47 <ehird_> amb :: [a] -> Amb r a a
17:44:03 <ehird_> since the second param to Amb is the type of the amb'd values in the monad.
17:44:10 <Cale> > head $ let factor a = do x <- [2..]; y <- [2..x]; if x * y == a then return (x,y) else [] in factor 12
17:44:11 <lambdabot>  (4,3)
17:44:13 <ehird_> but, since amb [] = backtrack
17:44:19 <ehird_> callPoint (Point f) = f () >> return undefined
17:44:21 <ehird_> that's the main magic
17:44:27 <Cale> It's the list monad :)
17:44:28 <ehird_> that allows it to be anythign
17:44:28 <SamB> ehird_: I meant trying to run amb []
17:44:32 <ehird_> Cale: Yes, pretty much
17:44:37 <SamB> by itself...
17:44:44 <ehird_> SamB: And expecting it to be (Integer,Integer)?
17:44:49 <ehird_> Yes, but note that [] is of type [a]
17:45:06 <ehird_> and amb has a 'return undefined' at one point that lets it pretend that amb :: [b] -> Amb r a b
17:45:08 <SamB> as I mentioned, I've been playing with epigram
17:45:10 <ehird_> It's hard to explain, easy to read.
17:45:11 <Saizan> ehird_: oh, you used evalState, that really threw me off at this hour :)
17:45:21 <SamB> where vhead vnil *is* ill-typed
17:46:12 <Cale> I tend to think of amb as simply "try all possibilities". The characterisation as "trying to avoid calling amb with an empty list" seems unintuitive. Of course, if you call amb with an empty list, there are no possibilities and you backtrack, but saying it the other way around is odd. :)
17:46:55 <Cale> (specifically because you're not really avoiding calling amb with an empty list, it's just that when that happens, you backtrack
17:47:09 <Cale> )
17:47:20 <hpaste>  yoshi pasted "Question About Lists & Strings" at http://hpaste.org/6675
17:47:35 <ddarius> I think of amb as sum and sequencing as multiplication.  The final result is then the algebraic result.
17:47:45 <ehird_> Cale: Yeah..
17:47:55 <ehird_> I guess it's just, if you look at my factor program
17:48:05 <ehird_> and you run through it without skipping around (i.e. do a, then b, then c)
17:48:14 <ehird_> then amb 'looked into the future'
17:48:27 <ehird_> and picked values from the two lists that stop (amb [])
17:48:30 <ehird_> and yes, Amb is the list monad
17:48:35 <ehird_> but the implementation is the interesting bit
17:48:42 <ehird_> and besides, if ListT isn't a real transformer, AmbT definately is
17:48:55 <ehird_> factorIO :: Integer -> AmbT r IO Integer (Integer,Integer)
17:48:57 <ehird_> wonder why that doesn't work
17:48:59 <ehird_> oh
17:49:04 <ehird_> factorIO :: Integer -> AmbT r Integer IO (Integer,Integer)
17:49:05 <ehird_> :)
17:49:20 <ehird_> eeek
17:49:24 <ehird_> I have to stop using a type synonym
17:49:30 <ehird_> you need 2 'lift's to get paste the ContT
17:49:31 <Cale> hmm
17:49:47 <Cale> How are you implementing AmbT? Have you checked the monad laws?
17:50:08 <Cale> (There are ways to get nondeterminism transformers, but it's really easy to mess up.)
17:50:08 <ehird_> newtype Point r a m = Point (() -> AmbT r a m a)
17:50:08 <ehird_> type AmbT r a m = StateT [Point r a m] (ContT r m)
17:50:09 <ehird_> type Amb r a = AmbT r a Identity
17:50:19 <ehird_> It may be totally wrong, but it seems to work fine
17:50:23 <ehird_> my noisy factor works, for example
17:50:24 <SamB> *seems*?
17:50:28 <ehird_> also, Amb is the same as before
17:50:47 <SamB> aren't you supposed to prove the laws?
17:50:54 <ehird_> SamB: Laziness! :D
17:50:56 <Cale> hmm
17:51:13 <ehird_> Anyway, before any of you do anything, i'm redoing Amb/AmbT as newtypes
17:51:15 <ehird_> to avoid lift $ lift
17:51:18 <Cale> Well, ContT and StateT are monad transformers, so yeah
17:51:24 <Cale> It must be a monad.
17:51:28 <ehird_> Hmm. I have no idea what MonadTrans contains.
17:51:30 <ehird_> Odd!
17:51:33 <ehird_> @info MonadTrans
17:51:34 <lambdabot> MonadTrans
17:51:37 <SamB> then, try to convince Epigram that the standard algorithm for "reverse" returns a list of the same size
17:51:39 <ehird_> urg
17:51:39 <Cale> it has lift
17:51:41 <ehird_> that always happens
17:51:42 <Cale> (just lift)
17:51:50 <ehird_> Cale: oh cool
17:51:51 <ehird_> @type lift
17:51:52 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
17:52:02 <ehird_> well that can't be that hard!
17:52:13 <Saizan> @info do x <- m; return (f x)
17:52:13 <lambdabot> m >>= \ x -> return (f x)
17:52:34 <ehird_> uh, yes..
17:52:39 <Saizan> ehird_: lift = lift . lift in your case
17:52:45 <ehird_> Saizan: haha
17:52:51 <ehird_> Saizan: but i'm using a newtype now
17:53:11 <Saizan> lift = Contructor . lift . lift
17:53:27 <SamB> only s/Contructor/Point/
17:53:46 <ehird_> newtype AmbT r a m b = AmbT (StateT [Point r a m] (ContT r m) b)
17:53:50 <SamB> erg, wait
17:53:53 <ehird_> and Constructor is now AmbT
17:54:04 <ddarius> Transformers! Monads in disguise!
17:54:13 * SamB grabbed the only newtype constructor
17:54:31 <Saizan> ... "more than meets the eye!"
17:54:54 <ehird_> Hmm
17:54:59 <ehird_> Do I need an instance Monad AmbT too?
17:55:25 <ehird_> (>>=), return and fail is the complete definition if I'm not mistaken
17:55:45 <Saizan> you can just derive it if you allow GeneralizedNewtypeDeriving
17:55:57 <ehird_> Saizan: Trying to go for 0 ghc exts here
17:56:40 <ehird_> Ooh, not sure how to go from a MonadTrans to the Monad I need
17:56:45 <ehird_> that's something I havent considered before
17:57:02 * ehird_ has never ever ever written a monad transformer in his life :<
17:57:02 <Saizan> uh?
17:57:22 <Saizan> instance Monad m => Monad (AmbT m)
17:57:33 <ehird_> instance (Monad m) => Monad (AmbT r a m)
17:57:34 <ehird_> actually
17:57:35 <ehird_> :)
17:57:44 <Saizan> right :)
17:57:52 <ehird_> Saizan: should the a be before the m?
17:57:54 <ehird_> StateT has that
17:58:06 <ehird_> and I just put r at the front because it's the lonely runt variable that nobody should have to think about too much
17:58:26 <Saizan> ehird_: a transformer has to be of kind (* -> *) -> * -> *
17:58:32 <SamB> ehird_: well, you can't put anything after the m
17:58:44 <SamB> except the value type
17:58:54 <SamB> which doesn't show up in Monad instance heads, obviously
17:59:01 <ehird_> Saizan: you're right. so it's good
17:59:31 <ehird_> what IS (AmbT r a m)'s "return" though?
17:59:49 <Saizan> AmbT . return :)
17:59:59 <ehird_> yep
17:59:59 <SamB> return x = amb [x] ?
18:00:00 <ehird_> got that
18:00:02 <ehird_>     Could not deduce (MonadState [Point r a1 m] (AmbT r a1 m))
18:00:03 <ehird_>       from the context (Monad m)
18:00:03 <ehird_>       arising from a use of `get' at /home/ehird/ambt.hs:20:22-24
18:00:14 <ehird_> SamB: i'm not defining a monad using amb, i'm defining the monad that lives inside amb
18:00:31 <ehird_> amb :: [b] -> AmbT r a m b
18:00:37 <SamB> doesn't it have an "amb" method?
18:00:43 <ehird_> SamB: ??
18:00:59 <ehird_> SamB, amb uses functions in the Amb monad
18:00:59 <SamB> don't tell me there isn't a class for Amby things?
18:01:07 <ehird_> um no
18:01:12 <ehird_> i think you fundamentally misunderstand this :)
18:01:18 <ddarius> ehird_: The type of return is b -> AmbT r a m b, the type of amb . (:[]) is b -> AmbT r a m b
18:01:34 <ehird_> ddarius: But amb depends on 'return'.
18:01:45 <SamB> ehird_: oh.
18:01:50 <SamB> whatever
18:01:58 <ddarius> ehird_: That should be an equation that holds though.
18:02:30 <ehird_>     (AmbT a) >>= b = AmbT $ a >>= b   -- I am so silly, I didn't see the basic error in this for aaages
18:05:13 <TomMD> ehird_: Thanks for that snipit - I'll post that on my cube at work to keep managers away.
18:05:21 <ehird_> heh
18:05:32 <efdetonator> Does anyone now a good tutorial or book about haskell?
18:05:42 * ehird_ ponders the correct (>>=)
18:05:57 <TomMD> efdetonator: I used 'Yet Another Haskell Tutorial' when learning.
18:06:20 <TomMD> efdetonator: And I felt really comfortable with the STM papers by SPJ et al.
18:06:29 <ehird_> Hmm
18:06:31 <ehird_> I really don't know.
18:06:32 <Saizan> ehird_: the result of b is wrapper in the newtype constructor
18:06:35 <lament> efdetonator: read YAHT, except the monads chapter. For monads, ask Cale.
18:06:42 <ehird_> Saizan: yeah
18:06:47 <ehird_> Amb a >>= b = ...
18:06:50 <TomMD> Also, the "Probabalistic Functional Programming" of the "Functional Pearls" is good.
18:07:01 <ehird_> I need to get myself an (m b) out of that a
18:07:04 <ehird_> and pass it over to b
18:07:08 <lament> efdetonator: if you're comfortable with your intelligence, read "gentle introduction"
18:07:10 <ehird_> what do I do? runContT?
18:07:11 <ehird_> that seems wrong
18:07:17 <efdetonator> TomMD: thanks for the help :)
18:07:22 <TomMD> np
18:07:29 <efdetonator> lament: haha yeah I'm quite comfortable =]
18:07:30 <lament> efdetonator: (it's for geniuses)
18:07:49 <ehird_> gentle introduction, eek
18:07:50 <ehird_> no no no :D
18:07:54 <efdetonator> lament: then I'm going to check it
18:08:06 <TomMD> 'gentle introduction' assumes previous experience with a functional language.
18:08:21 <SamB> TomMD: such as scheme?
18:08:22 <lament> it does? it sort of explains everything
18:08:23 <Saizan> ehird_: (Amb a) >>= b = Amb $ do x <- a; let Amb b' = b a in b' <- something like that
18:08:38 <TomMD> Well, thats always been my impression.  YMMV
18:08:45 <ehird_> no
18:08:49 <ehird_> Scheme won't be good for gentle
18:08:52 <ehird_> more like... Miranda
18:08:53 <ehird_> that's about it :)
18:09:04 <lament> heh heh
18:09:05 <SamB> how come I don't remember any problems then?
18:10:16 <ehird_>     Occurs check: cannot construct the infinite type:
18:10:16 <ehird_>       a = StateT [Point r a1 m] (ContT r m) a
18:10:19 <TomMD> Has anyone written a tutorial for the 'working Haskell programmer' that includes Cabal, hoogle, etc?  That would be a fun thing to point people toward.
18:10:23 <ehird_> Saizan failz! :D
18:10:37 <ehird_> but I know why
18:10:38 <ehird_> very simple
18:10:51 <lament> TomMD: hopefully real world haskell :)
18:11:15 <ddarius> AmbT m >>= f = AmbT $ m >>= runAmbT . f  for some appropriate runAmbT function.
18:11:18 <ehird_>     (AmbT a) >>= b = AmbT $ do x <- a; let AmbT r = b x in r
18:11:22 <TomMD> I was going to acknowledge that, but I figured I'd ask about the tutorial.
18:11:25 <ehird_> ddarius: heck no, that woul make stuff crazy
18:11:26 <solrize> http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html#JFP06a
18:11:28 <lambdabot> Title: Publication-Abstracts by Martin Erwig, http://tinyurl.com/2bmnd4
18:11:36 <solrize> Probabilistic Functional Programming in Haskell
18:11:47 <Jedai> ehird_: any ML language should be sufficient for the Gentle
18:11:53 <lament> there's http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
18:11:55 <lambdabot> Title: How to write a Haskell program - HaskellWiki
18:12:01 <Saizan> ehird_: like ddarius said but with unAmbT (Amb x) = x
18:12:15 <ddarius> (Which is what Saizan said, but more verbosely.)
18:13:28 <ehird_>     AmbT a >>= b = AmbT $ a >>= (\(Amb x) -> x) . f
18:13:29 <ehird_> :)
18:13:44 <ehird_> err
18:13:45 <ehird_> b
18:13:50 <Saizan> :D
18:14:01 <ehird_> there shoudl be a nice thing for that
18:14:10 <ehird_> extract (Amb x) foo
18:14:16 <ehird_> or something
18:14:17 <ehird_> I don't know
18:14:17 <Saizan> actually you could do like mtl does and define your newtype with a record field
18:14:23 <Saizan> ?src State
18:14:24 <lambdabot> Source not found. My brain just exploded
18:14:26 <ehird_> oh, yes
18:14:26 <Saizan> ?src StateT
18:14:26 <lambdabot> Source not found. Wrong!  You cheating scum!
18:14:28 <ehird_> i should probably do that
18:14:34 <ddarius> Define AmbT as newtype AmbT type params = AmbT { unAmbT :: definition }
18:14:40 <ehird_> yes.
18:15:11 <ddarius> :t id :: type -> type
18:15:12 <lambdabot> parse error on input `type'
18:15:28 <ddarius> Are there any possible ambiguities?
18:15:59 <ddarius> > ord 'x'
18:16:00 <lambdabot>  120
18:16:02 <ddarius> > ord'x'
18:16:02 <lambdabot>   Not in scope: `ord'x''
18:16:03 <ddarius> Yay
18:16:35 <ehird_> hmm
18:16:41 <ehird_> I need an instance MonadState for AmbT
18:16:46 <ehird_> so I can use 'get' and put etc simply
18:16:54 <ehird_> ?src MonadState
18:16:55 <lambdabot> Source not found. Just what do you think you're doing Dave?
18:16:56 <ddarius> So write one.
18:17:01 <ehird_> ?src Control.Monad.State.MonadState
18:17:01 <lambdabot> Source not found. :(
18:17:07 <ehird_> ?die die die
18:17:07 <lambdabot> unexpected "d": expecting number
18:17:20 <wagle_home> > ord'x'
18:17:20 <lambdabot>  121
18:17:32 <encryptio> :t (,,)
18:17:33 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
18:18:04 <ehird_> > ord'x'
18:18:04 <lambdabot>  121
18:18:10 <ehird_> weiiird
18:18:15 <ehird_> > ord'x'
18:18:16 <lambdabot>  121
18:18:18 <sarehu> > ord 'x'
18:18:18 <lambdabot>  120
18:18:20 <ddarius> Not really.
18:19:37 <ehird_> Hmm..
18:19:54 <ehird_> I don't know how to define 'get' when I have newtype AmbT r a m b = AmbT { unAmbT :: StateT [Point r a m] (ContT r m) b }
18:20:01 <ehird_> I guess... lift get
18:20:18 <wagle_home> @undefine ord'x'
18:20:18 <lambdabot> Undefined.
18:20:23 <wagle_home> > ord'x'
18:20:23 <lambdabot>   Not in scope: `ord'x''
18:20:24 <ehird_> sheesh
18:20:28 <ehird_> I need XFlexibleInstances for monadstate
18:20:52 <ddarius> Among other things.
18:20:55 <EvilTerran> what aspect of it?
18:21:11 <EvilTerran> don't you need overlappinginstances for monadstate, too?
18:21:16 <ddarius> No
18:22:39 <ehird_> Hm wait, no.
18:22:43 <ehird_> I can't do "lift"
18:22:47 <ehird_> Since that's the AmbT's lift.
18:22:49 <ehird_> Eurgghh!!!
18:22:54 <ehird_> I don't think this is possible
18:23:51 <SamB> ehird_: tried "deriving MonadState"?
18:24:09 <ehird_> SamB: nah, i think i have another way
18:24:27 <hpaste>  ehird pasted "problem + description" at http://hpaste.org/6676
18:24:32 <SamB> not that that proves much, since, you know, newtype deriving is apparantly not 100% safe...
18:25:29 <ddarius> It should just be lift get and lift . put
18:26:00 <ehird_> ddarius: See my paste
18:27:24 <ddarius> Actually, you don't even want to expose get and put.
18:28:27 <ddarius> privateGet = AmbT get
18:28:39 <ddarius> privatePut = AmbT . put
18:29:43 <ehird_> ddarius: Where is that, though?
18:29:44 <ehird_> Toplevel?
18:29:52 <ddarius> Sure
18:30:17 <ddarius> What you -do- want is to make monads transformed by your monad transformer instances of MonadPlus.
18:30:36 <ddarius> @src MonadPlus
18:30:36 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
18:31:35 <ehird_>     Could not deduce (MonadState
18:31:35 <ehird_>                         a1 (StateT [Point r a1 m] (ContT r m)))
18:31:35 <ehird_>       from the context (Monad m)
18:31:35 <ehird_>       arising from a use of `get' at /home/ehird/ambt.hs:22:14-16
18:31:47 <ehird_> ambGet :: (Monad m) => AmbT r a m a; ambGet = AmbT get     -- the defn
18:32:20 <Saizan> the last a is wrong..
18:32:42 <Saizan> use [Point r a m]
18:32:53 <ehird_> oh, of course
18:32:54 <ehird_> thanks
18:33:59 <ehird_> @type callCC
18:34:01 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
18:34:10 <ehird_> does every monad transformer require repetitive wrappers like this btw? :P
18:34:46 <Cale> ehird_: Normally you newtype the result.
18:35:05 <ehird_> Cale: Yes.
18:35:10 <Cale> ehird_: (and use newtype deriving to get instances of Functor and Monad)
18:35:13 <ehird_> So they just directly do 'AmbT get' in their code?
18:35:25 <ehird_> Oh, I don't have a Functor instance. Should I?
18:35:33 <Cale> No, you want to hide the implementation
18:35:45 <ehird_> so.. ambCallCC
18:35:47 <ehird_> & co
18:35:49 <Cale> Ideally, users of the library won't actually know that the monad transformer was used to build it.
18:35:54 <ehird_> Oh, of course
18:35:57 <ehird_> I mean inside the transformer's code
18:36:00 <ehird_> ambPut = AmbT . put
18:36:02 <ehird_> I have some like that.
18:36:06 <ehird_> to use internally
18:36:11 <Cale> oh, there will be some lifting/wrapping
18:36:16 <ehird_> ok
18:36:21 <ehird_> so i shouldn't do "foo <- AmbT get"
18:36:26 <ehird_> in my internal code..
18:36:29 <ehird_> I should use a wrapper like that?
18:37:16 <Cale> Well, in your internal code, it doesn't matter quite so much, but it helps to export suitable wrapped things.
18:37:29 <ehird_> Oh.
18:37:31 <ehird_> Well nobody will use these
18:39:05 <ehird_>     where ambCC f = AmbT $ callCC $ \k -> f (AmbT . k)
18:39:07 <ehird_> i think that's right
18:41:06 <ehird_> hmm, no
18:41:08 <ehird_> because it's a StateT
18:41:11 <ehird_> anyone know what to do?
18:41:35 <ehird_>           ambCC f = AmbT $ return $ callCC $ \k -> f $ AmbT . k
18:41:36 <ehird_> getting there
18:42:31 <ehird_>           ambCC f = AmbT $ return $ callCC $ \k -> unAmbT $ f $ AmbT . k
18:42:33 <ehird_> damnit, infinite type
18:43:12 <ehird_> nobody alive :) Cale? Saizan?
18:43:28 <Cale> hello
18:43:32 <ehird_> hehe
18:43:41 <ehird_> ambCC :: ((t -> AmbT r a m t1) -> AmbT r a m t) -> AmbT r a m t
18:43:42 <ehird_> is my aim
18:43:48 <ehird_> so just like callCC, but in AmbT
18:46:09 <ehird_> aha
18:46:11 <ehird_> ambCC :: (Monad m) => ((t -> AmbT r a m t1) -> AmbT r a m t) -> AmbT r a m t1
18:47:00 <pantsd> Does haskell do automatic memoization?
18:47:11 <ehird_> pantsd: no
18:47:36 <hpaste>  ehird pasted "Amb & AmbT, completely working" at http://hpaste.org/6677
18:47:52 <ehird_> 41 lines
18:47:53 <ehird_> not bad at all
18:47:57 <ehird_> and it's a real transformer unlike listt
18:48:48 <pantsd> ehird_: Would it be a reasonable idea to write my program first, then profile & memoize if necessary or is memoizing existing code a pain?
18:49:37 <ehird_> pantsd: former
18:49:39 <ehird_> oh crap
18:49:48 <ehird_> > runAmb $ (return 2 >>= return) >>= return -- OK
18:49:48 <lambdabot>   Not in scope: `runAmb'
18:49:53 <ehird_> > runAmb $ (return 2) >>= (\x -> (return x) >>= (return 2)) -- ERROR
18:49:53 <lambdabot>   Not in scope: `runAmb'
18:49:54 <ehird_> :(
18:49:58 <ehird_> do I not obey the monad laws?
18:50:11 <Japsu> You're no monad! :<
18:50:48 <ehird_> just askin'
18:50:52 <ehird_> oh wait
18:50:52 <ehird_> duh
18:51:10 <ehird_> nope
18:51:12 <ehird_> I obey the monad laws
18:51:38 <ehird_> So wait
18:51:42 <ehird_> someone tell me why ListT isn't a proper monad?
18:51:55 <ehird_> Then I can be infinitely superior by having something equiv. to the list monad, but as a real transformer
18:52:19 <patperry> does anyone have opinions on which database library is the best?  I'm a little overwhelmed by the wiki ( http://www.haskell.org/haskellwiki/Libraries_and_tools/Database_interfaces )
18:52:20 <lambdabot> Title: Applications and libraries/Database interfaces - HaskellWiki, http://tinyurl.com/3cppux
18:54:38 <solrize> man those all look like layers over various sql monstrosities
18:55:04 <solrize> i was just asking over in #happs if anyone had implemented persistent functional maps on disk
18:56:55 <ehird_> would it be OK to add a page about amb to the haskell wikki?
18:56:57 <ehird_> or is that bad form..
18:59:45 <Excedrin> solrize: isn't that MACID?
18:59:52 <solrize> what's that?
19:00:04 <Excedrin> part of Happs
19:00:24 <solrize> that uses an in memory structure with serial logging, so its max size is limited by ram
19:01:45 <ehird_> Oh well: http://www.haskell.org/haskellwiki/Amb
19:01:46 <lambdabot> Title: Amb - HaskellWiki
19:01:48 <gridlock> so, if i wanted to access an sqlite DB from haskell, what package should i go about using ?
19:01:59 <gridlock> looking at hackage there seem to be a few
19:03:21 <ehird_> ambCC is pretty crazy
19:03:22 <ehird_> ambCC f = AmbT $ callCC $ \k -> unAmbT $ f $ AmbT . k
19:04:16 <hpaste>  dolio pasted "delimited continuations" at http://hpaste.org/6678
19:04:35 <dolio> Oops.
19:05:13 <dolio> I meant to annotate something else with that.
19:05:20 <dolio> Anyhow: ehird_ ^^
19:06:00 <ehird_> dolio: Coool! How easy do you think it would be to take that and maybe make those delimited continuations serializable?
19:06:04 <ehird_> Surely easier than ordinary continuations..
19:06:16 <ehird_> If I could do that then my web framework should be set to go
19:06:23 <dolio> ehird_: Those aren't any different than Cont.
19:06:26 <ehird_> Darn.
19:06:27 <ehird_> :(
19:06:36 <ehird_> OK, would some implementation of delimited continuations be serializable?
19:07:16 <dolio> Well, I doubt you'd be doing that sort of thing without hooks into the runtime or something.
19:07:28 <ehird_> Darn.
19:07:33 <ehird_> So serializing continuations is a dead end?
19:07:44 <dolio> Continuation monads (delimited or otherwise) in haskell are based on functions.
19:07:50 <dolio> At least, all the ones I've seen are.
19:09:11 <ehird_> Yes. But could you make one that wasn't?
19:09:28 <ehird_> Hmm
19:09:30 <EvilTerran> it'd be tantamount to serialising functions
19:09:33 <ehird_> Where's that WASH paper again?
19:09:46 <ehird_> I think I could make it.. more Haskelly, but still work
19:10:19 <dolio> I don't really know. I mean, serializing a continuation is like serializing the runtime state of your program.
19:10:35 <ehird_> Yeah.
19:10:37 <ehird_> WASH does that.
19:10:37 <EvilTerran> dolio, hence my comment
19:10:57 <ehird_> I think you could actually dump the tree as code.
19:10:59 <ehird_> Like
19:11:02 <ehird_> do foo; bar; baz
19:11:06 <ehird_> could get dumped to
19:11:10 <ehird_> (if foo callCCs):
19:11:17 <dolio> The 'easiest' way I could think of to make serialable continuation is to write an interpreter, and serialize whatever data structure you use for that. :)
19:11:28 <ehird_> (((bar :: Web a) >>= (baz :: Web a)) :: Web a)
19:11:35 <ehird_> And then read that  back in appropriately.
19:12:17 <EvilTerran> one of the talks at last year's AngloHaskell was about just-in-time haskell compilation within normal haskell, iirc. it might be possible to adapt whatever that used.
19:12:23 <ehird_> but yeah
19:12:24 <ehird_> WASH paper
19:12:27 <sm> good evening all
19:13:25 <sm> how would I make a list comprehension where one of the conditions is a monadic function ?
19:14:18 <sm> eg I have a prime test which returns IO Bool, I'd like use it as a condition
19:14:56 <ddarius> You don't.
19:15:06 <sm> ack
19:15:10 <Heffalump> if the prime test is "morally" pure, use unsafePerformIO
19:15:42 <solrize> probabalistic test with a RNG ?
19:15:49 <Twey> 'Morally' poor?  O.O
19:15:52 <Twey> Er
19:16:04 <Twey> pure**
19:16:15 <sm> I'm practicing with some SICP exercises.. yes, it's the probabilistic prime test in ch. 1
19:16:36 <sm> so search_for_primes (l,h) = return [x | x <- range (l,h), odd x, prime x]  just isn't going to work eh
19:16:41 <Heffalump> hmm, that's a bit dubious
19:17:05 <solrize> you could pass a bound (pure) stdgen into the test
19:17:26 <sm> true solrize
19:17:34 <Heffalump> a pure function has no observable side-effects on its environment (for some definition of "observable" that generally excludes memory and CPU usage but includes most other stuff), and returns the same result for the same inputs every time.
19:18:05 <Heffalump> so an IO function that satisfies those properties is a good candidate for unsafePerformIO
19:18:39 <solrize> what if it does actual i/o that could potentially fail?  is it ok to raise an exception out of that "pure" func?
19:18:48 <ehird_> i really need that wash paper link
19:18:53 <ddarius> @where wash
19:18:53 <lambdabot> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
19:19:36 <ehird_> no
19:19:38 <ehird_> the wash continuation paper
19:19:51 <Japsu> @go the wash continuation paper
19:19:53 <lambdabot> http://books.google.com/books?id=1hsAAAAAMAAJ&pg=PA256&lpg=PA256&dq=the+wash+continuation+paper&source=web&ots=5FVeRu2zpM&sig=H_nEpqoaKhURzy7SbCpljEa2mrE&hl=en
19:19:53 <lambdabot> Title: The Annals of Philosophy - Google Book Search
19:20:06 <Japsu> fail
19:20:21 <ehird_> bah
19:21:44 <sm> Heffalump: so, would getStdRandom be considered morally pure ? My guess: its side effect is updating the seed, and calling this any old time won't affect the quality of your random numbers, so.. yes it is ?
19:22:13 <gwern> @seen lispy
19:22:13 <lambdabot> lispy is in #haskell, #darcs, ##logic, #ghc and #haskell-blah. I last heard lispy speak 21h 9m 5s ago.
19:23:01 <EvilTerran> sm, no, that's not morally pure, i'd sat
19:23:02 <EvilTerran> *say
19:23:26 <EvilTerran> i'd use "morally pure" to mean "returns the same result every time, even though it may do impure stuff under the hood"
19:23:31 <ehird_> oh come on :(
19:24:36 <EvilTerran> representing a set as a list that moves elements to the start as you look at them, say, would give impure code (as the layout of the tree changes as you look at it), but would be "morally pure" as you couldn't tell without looking at either the source or running times
19:24:56 <ehird_> i really can't find it
19:24:57 <EvilTerran> er, s/tree/list/
19:24:59 <ehird_> & i don't have logs
19:24:59 <ehird_> @logs
19:24:59 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
19:26:00 <sm> ok, I see the distinction. Would you say it's also safe to use in this special case, as I am guessing ?
19:26:13 <sm> it does seem to work nicely, but...
19:27:32 <Saizan> sm: the overall type of search_for_primes is in IO?
19:27:48 <sm> yes it is, search_for_primes :: (Integer,Integer) -> IO [Integer]
19:28:20 <sm> because it calls (eventually) random n = getStdRandom (randomR (1,n))
19:29:19 <hpaste>  sm pasted "sicp exercises" at http://hpaste.org/6679
19:29:30 <Heffalump> in practice, if you don't mind your entire program being a bit impure, I shouldn't worry too much about using unsafePerformIO on your probabilistic tester.
19:29:56 <gwern> why not make the generator an argument and keep it pure?
19:30:12 <Heffalump> gwern: how do you thread a generator through a list comprehension?
19:30:53 <sm> Heffalump: it's good enough for now I think - just trying to build a sense of when it's really safe, and when not
19:31:02 * sm 's first real use of unsafePerformIO
19:31:05 <gwern> desugar it into a filter and think harder
19:31:14 <adu> hello my fellow haskellers
19:31:44 <TomMD> hello adu
19:32:24 <adu> TomMD: are you in Maryland?
19:32:39 <TomMD> Yep
19:32:40 <Heffalump> the most unsafe use of it I am aware of is using it to implement unsafeCoerce
19:32:56 <adu> TomMD: me too! did you go to FringeDC?
19:33:03 <TomMD> Yep
19:33:14 <adu> TomMD: me too! i probably saw you there
19:33:18 <TomMD> Probably
19:33:25 <TomMD> Did you eat afterward?
19:33:28 <adu> yup
19:33:30 <TomMD> What table?
19:33:39 <adu> the one closest to the door
19:33:42 <adu> not the wall
19:33:46 <TomMD> Ahh - I was at the wall.
19:33:49 <adu> ahh
19:34:17 <TomMD> Are you in DC?
19:34:21 <adu> no MD
19:35:11 <TomMD> We should setup a HUG in our area.
19:35:26 <adu> so I've been trying to learn about the internals of GHCI, I'm wondering if its possible to embed it
19:35:47 <adu> TomMD: most def
19:35:58 <sm> thanks all
19:36:29 <Heffalump> adu: you've looked at ghc-api?
19:36:35 <adu> nope
19:36:37 <adu> i well
19:38:07 <Heffalump> I don't know much about it, but AFAIK that would be the first port of call
19:38:24 <TomMD> Does it require System.IO or is it pure?
19:38:49 <adu> Heffalump: ok, thanks
19:38:55 <TomMD> I don't know of any shell that is pure, though shellac requires only minimal work to make it so.
19:40:32 <baz123> Guys check this new forum out:  www.psnhome.com  Probably the best damn site ive ever seen!  Hope too see you more mature guys come along!!! :)
19:41:00 <Saizan> sm: have you considered search_for_primes (l,h) = filterM prime [x | x <- range (l,h), odd x] ? it won't be as lazy as before though, since it will produce all the list before you can see the head
19:42:03 <gwern> adu: the GHC API is painful, and the only docs arebasically the sources to GHC, so it might make more sense to do a shell-call
19:42:51 <TomMD> @seen
19:43:03 <adu> gwern: that is unnacceptable for 2 reasons: I would learn less, and it would be slower, which are my 2 reasons for doing this
19:43:27 <gwern> adu: what do you want to do anyway?
19:43:45 <gwern> and adu, this might not be a subject worth learning about as the GHC API is in flux
19:44:38 <glen_quagmire> a bit of off topic: where can I learn about implementing type inferences in haskell for free?
19:44:42 <adu> doesn't matter
19:45:10 <EvilTerran> that seems perfectly on-topic to me
19:45:35 <adu> glen_quagmire: very on topic
19:45:46 <byorgey> hey adu, great to see you in #haskell =)
19:45:50 <Saizan> glen_quagmire: "for free"?
19:46:16 <gwern> adu: sure it does. depending on what you want to do, you might find one of the GHC API wrappers on hackage to be very educational, or you might be even more interested by xmonad or yi or hs-plugins
19:46:26 <adu> glen_quagmire: as far as I know type inferencing is an application of prolog/logic compiler type thing
19:46:41 <EvilTerran> you can do clever things with GADTs, i think
19:46:44 <adu> glen_quagmire: do you know how prolog works?
19:47:04 <adu> byorgey: hey!
19:47:19 <adu> byorgey: I actually am here more often than #xmonad
19:47:24 <Saizan> yeah, it's easy to write da gadt for simply typed lambda calculus that just reports the type of the term
19:48:00 <byorgey> adu: oh, really? my fault.  I guess I just didn't remember seeing you here before. =)
19:48:19 <adu> byorgey: its ok :)
19:53:10 <sm> Saizan: no I hadn't, that's exactly the sort of thing I had in mind first. Cool.
19:53:35 <dolio> @seen kuribas
19:53:35 <lambdabot> I saw kuribas leaving #haskell 1d 1h 46m 58s ago, and .
19:55:27 <adu> ppl are insane:
19:55:29 <adu> http://shreevatsa.wordpress.com/2008/02/07/haskellpythonruby-quine/
19:55:30 <lambdabot> Title: {Haskell,Python,Ruby} quine  The Lumber Room, http://tinyurl.com/378hm6
20:10:43 <glen_quagmire> Saizan, adu i was  away sorry.  yan free as in "i don't want to buy a book"..   and I don't know prolog
20:11:15 <adu> glen_quagmire: its ok
20:11:24 <glen_quagmire> @google GADT
20:11:25 <lambdabot> http://en.wikibooks.org/wiki/Haskell/GADT
20:11:40 <eyeris> I am trying to build gtk2hs 0.9.12.1. I'm getting the error "ghc-6.8.2: unknown package: glib-0.9.12.1" but I thought that glib was part of the gtk2hs distribution. Looking in the glib directory though, there is no Makefille, just a very simple glib.cabal file. Do I have to build a separate glib haskell package?
20:12:07 <adu> glen_quagmire: the 2 programming languages that would help you the most in understanding type inferencing I think are Prolog and perhaps WAM
20:12:28 <adu> maybe even Coq
20:12:33 <adu> or Mercury
20:13:11 <glen_quagmire> oh thank you
20:13:54 * dolio just got excited about a sound Typeable via GADTs, but then he realized it wasn't going to work.
20:14:18 <adu> but thats more about inferencing in general, type inference is just an application
20:20:19 <ddarius> @where thih
20:20:19 <lambdabot> I know nothing about thih.
20:20:27 <ddarius> @google "Typing Haskell in Haskell"
20:20:28 <lambdabot> http://citeseer.ist.psu.edu/424440.html
20:20:28 <lambdabot> Title: Typing Haskell in Haskell - Jones (ResearchIndex)
20:22:30 <solrize> @tell byorgey talk to benny99 about your idea of a gobby clone if you're still interested
20:22:31 <lambdabot> Consider it noted.
20:23:14 <mgsloan> ooh, gobby clone would indeed be interesting
20:23:28 <solrize> http://byorgey.wordpress.com/2008/02/04/gobby-haskell-and-patch-theory/
20:23:29 <lambdabot> Title: Gobby, Haskell, and patch theory  blog :: Brent -> [String], http://tinyurl.com/yq6oxz
20:24:22 <solrize> @tell benny99 this might interest you: http://byorgey.wordpress.com/2008/02/04/gobby-haskell-and-patch-theory/
20:24:22 <lambdabot> Consider it noted.
20:24:37 <mgsloan> yeah, I actually wrote a comment on that back when it was written :)
20:24:47 <solrize> oh cool ;)
20:28:51 <dolio> Huh...
20:29:12 <solrize> :t System.IO.hGetChar
20:29:14 <lambdabot> GHC.IOBase.Handle -> IO Char
20:29:23 <nornagon> [motoko:~] ghci -x hs /dev/stdin
20:29:24 <solrize> why is it that Handle is a primitive type instead of a type class?
20:29:26 <nornagon> *** Exception: /dev/stdin: hFileSize: inappropriate type (not a regular file)
20:29:30 <nornagon> ^- :(
20:31:42 <mofmog> hey, which ncurses library should I use?
20:31:58 <mofmog> i want to do something graphical but i dont want to deal with a gui
20:32:07 <mofmog> and by graphical i mean colored text
20:34:04 <adu> http://citeseer.ist.psu.edu/cardelli88basic.html
20:34:06 <lambdabot> Title: Basic Polymorphic Typechecking - Cardelli (ResearchIndex)
20:34:17 <glen_quagmire> adu: thanks
20:34:27 <gwern> @wn pullulate
20:34:29 <lambdabot> *** "pullulate" wn "WordNet (r) 2.0"
20:34:29 <lambdabot> pullulate
20:34:29 <lambdabot>      v 1: be teeming, be abuzz; "The garden was swarming with bees";
20:34:29 <lambdabot>           "The plaza is teeming with undercover policemen"; "her
20:34:29 <lambdabot>           mind pullulated with worries" [syn: {teem}, {swarm}]
20:34:31 <lambdabot> [8 @more lines]
20:34:38 <gwern> mofmog: we have more than one?
20:34:53 <glen_quagmire> ddarius: thank you
20:36:08 <mofmog> gwern: apparently
20:36:17 <mofmog> there's one that dons worked on and some other one
20:37:45 <gwern> oh. there's a minimalist binding which you find a number of places, there's the one inside Mage, and there's hscurses
20:38:20 <adu> glen_quagmire: let me know what you find, I actually don't know anything about type inference :)
20:39:48 <solrize> wikipedia has a simple explanation of naive hindley-milner but someone here (maybe quicksilver?) said coding it the naive way takes exponential time and you have to do a lot of careful memoization to get something useable
20:41:05 <glen_quagmire> adu: ddarius's link seem like a jackpot.  and http://notvincenz.blogspot.com/2008/01/simple-type-inference-in-haskell.html
20:41:06 <lambdabot> Title: lambda.oasis: SImple Type Inference in Haskell, http://tinyurl.com/2ldfa6
20:45:41 <solrize> http://www.laserpirate.com/tinyml.html
20:45:42 <lambdabot> Title: Tiny ML
20:45:50 <solrize> TinyML - Lexer, Parser, Interpreter, and Type Checker in Under 700 Lines of SML
20:46:05 <glen_quagmire> yay
20:46:18 <glen_quagmire> i can implement python interpreter in 1 line of python
20:46:23 <solrize> lol
20:46:46 <glen_quagmire> line = raw_input(">>> "); eval(line); or something
20:47:01 <solrize> yeah i don't think sml has eval :)
20:47:21 <solrize> i wrote a fairly usable lisp (including a gc and so forth) in about 1 kloc of C
20:47:35 <glen_quagmire> while 1: print eval(raw_input('>>> '))
20:47:41 <solrize> so 700 lines of ml should be able to do at least as much, especially if the interpreter sits inside the ml runtime
20:48:11 <glen_quagmire> great!
20:49:06 <glen_quagmire> my lisp in haskell currently has many bugs related to environment (variable bindings)
20:49:56 <cjb> glen_quagmire: import code; code.InteractiveConsole()
20:50:45 <solrize> you've seen spj's book on FPL implementation?
20:52:26 <glen_quagmire> cjb: lol
20:52:32 <glen_quagmire> solrize: i have tutorial version of the book
20:52:49 <solrize> there's a different version?  interesting.  i only saw the online pdf
20:52:56 <solrize> it was pretty readable and demystified haskell a lot
20:56:51 <Cale> byorgey: You should have done a demo layout which kept windows off the left side of the screen!
21:02:39 <gwern> > 2^5
21:02:40 <lambdabot>  32
21:03:30 <glen_quagmire> > let d f = f . f in (d d d d) (+ 1) 2
21:03:30 <lambdabot>  65538
21:03:43 <glen_quagmire> > 2^16
21:03:44 <lambdabot>  65536
21:07:08 <nornagon> grr, is it really so complicated to get at the local time in haskell?
21:07:21 <solrize> system.time ?
21:08:01 <nornagon> ah
21:08:04 <nornagon> that's a bit easier
21:08:07 <nornagon> i was looking at data.time
21:08:08 <nornagon> :/
21:10:06 <adu> nornagon: theres also Time.getClockTime
21:11:02 <nornagon> @index lookup
21:11:02 <lambdabot> Data.HashTable, Data.IntMap, Data.Map, Data.List, Prelude
21:11:16 <nornagon> :t Prelude.lookup
21:11:16 <adu> :t getCPUTime
21:11:18 <lambdabot> Not in scope: `getCPUTime'
21:11:18 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
21:11:48 <adu> :t System.CPUTime.getCPUTime
21:11:49 <lambdabot> IO Integer
21:12:48 <adu> :t System.Time.getClockTime
21:12:49 <lambdabot> IO System.Time.ClockTime
21:16:43 <gwern> > 2^20 -- how many distinct items are needed to defeat 20 questions?
21:16:43 <lambdabot>  1048576
21:18:51 <gwern> > 3^20 -- but then again, you don't have to answer just yes/no, but N/A etc
21:18:51 <lambdabot>  3486784401
21:22:56 <MagicDuck> has anybody here had any experience with the D programming language
21:23:18 <Cale> > 5*3^(20-1)
21:23:19 <lambdabot>  5811307335
21:23:56 <MagicDuck> there is little documentation on the web about it...
21:24:03 <Cale> MagicDuck: Not extensive, but I've looked at it briefly.
21:24:42 <MagicDuck> do you think it's vaporware?
21:24:53 <Cale> No, it's not vaporware.
21:25:01 <solrize> huh?  no it has a significant following
21:25:11 <solrize> there may be more D users than haskell users
21:25:13 <solrize> digitalmars.com iirc
21:25:27 <adu> MagicDuck: no, but I've read a little about it
21:25:41 <solrize> i haven't tried to use it but read the docs long ago
21:25:57 <MagicDuck> I got the impression it's a better C++
21:26:04 <adu> MagicDuck: its basically C/C++ with better pointers
21:26:19 <Cale> and better templates, apparently
21:26:46 <adu> I personally think D should've been more like Oz
21:27:13 <MagicDuck> Oz, haven't heard of that one ... gonna look it up :)
21:27:29 <adu> MagicDuck: I could name quite a few langs you've never heard of!
21:27:34 <Cale> I think D is trying to appeal to people who are C++ users, but are rightfully annoyed by all the things which C++ does in a kludgey way.
21:27:46 <solrize> the CTM book uses oz
21:27:56 <adu> MagicDuck: don't lookup Oz, lookup "Oz Mozart" you'll get better results
21:28:00 <solrize> it's supposed to be an important book
21:28:01 <Cale> Oz is very different from this part of the design space
21:28:03 <solrize> mozart-oz.org iirc
21:28:30 <solrize> it's sort of a bastardize mix of concurrent and logic programming languages
21:28:37 <adu> yeah :)
21:28:58 <adu> my only complaint is that it uses {f x} application notation
21:29:09 <MagicDuck> hey, have you guys heard of REBOL, it's really cool
21:29:19 <Cale> D would not be particularly challenging to pick up for someone who knows C and Java, say.
21:29:21 <adu> yup
21:29:37 <Cale> But I think Oz would be somewhat more of an uphill climb :)
21:29:43 <solrize> rebol?  cobol with regexps?  :shrug:
21:30:05 <adu> MagicDuck: whats rebol like?
21:30:27 <solrize> http://en.wikipedia.org/wiki/Rebol
21:30:28 <lambdabot> Title: REBOL - Wikipedia, the free encyclopedia
21:30:51 <solrize> uggh
21:31:16 <MagicDuck> no, rebol is entirely different - you get to create dialects
21:31:49 <Cale> Rebol is nothing like Cobol, as far as I can tell
21:32:00 <solrize> that was a joke, i'm reading about it on wiki
21:32:09 <MagicDuck> It was created Carl Sassenrath, who worked for Amiga, from a mixture of languages
21:32:14 <adu> I like the idea of "dialecting"
21:32:41 <MagicDuck> and it has this really powerul ideas of words and blocks
21:32:49 <adu> like mozart --withapply="()" hehehe
21:33:33 <Cale> There's something eerily forthish about it
21:35:33 <Cale> (but it's clearly not a stack language)
21:37:59 <runar> I have a function for merging two (sorted) infinite lists. Is it possible to fold a merge over an infinite list of infinite lists?
21:38:29 <Cale> runar: Probably not.
21:38:39 <runar> :-(
21:38:46 <adu> why wouldn't that work?
21:38:50 <Cale> Well, theoretically speaking what would it do?
21:39:07 <Cale> Let's say I hand you an infinite list of infinite lists
21:39:16 <Cale> What's the first element of the result?
21:39:22 <adu> wouldn't ((x:xs):ys) work on that kind of thing?
21:39:54 <TSC> Wasn't there a thread on -cafe about this?
21:39:59 <Cale> You will have to keep looking to see if there might be an infinite list somewhere out there which has a smaller element.
21:40:24 <runar> Cale, you're totally right, as usual.
21:40:28 <ddarius> Indeed.  The first element would be, minimum . map head
21:41:17 <Cale> If you could guarantee something about how the infinite lists were sorted to begin with, then maybe you could do it.
21:41:54 <Cale> But just saying that they're sorted lexicographically won't be enough, I don't think.
21:42:08 <Cale> hmm
21:44:10 <roconnor> @free (.)
21:44:10 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
21:44:16 <roconnor> @free .
21:44:16 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
21:44:37 <roconnor> @free (\a b x -> a (b x))
21:44:37 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
21:45:55 * Twey blinks.
21:46:16 <Twey> @free 1 == 1
21:46:16 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
21:46:16 <shachaf> @free dot :: (b -> c) -> (a -> b) -> (a -> c)
21:46:16 <lambdabot> g . k = p . f => f . q = f1 . h => g . dot k q = dot p f1 . h
21:46:18 <runar> What I'm trying to do is: for any list of primes ps, yield all the numbers that are not divisible by any prime not in ps.
21:46:23 <Twey> Ah
21:46:46 <runar> but I don't want to yield the same number twice.
21:48:15 <bd_> > (\ps -> filter (\n -> all (\p -> n `mod` p /= 0) ps) [2..]) [2,3]
21:48:16 <lambdabot>  [5,7,11,13,17,19,23,25,29,31,35,37,41,43,47,49,53,55,59,61,65,67,71,73,77,79...
21:48:21 <bd_> > (\ps -> filter (\n -> all (\p -> n `mod` p /= 0) ps) [2..]) [2,3,5]
21:48:22 <lambdabot>  [7,11,13,17,19,23,29,31,37,41,43,47,49,53,59,61,67,71,73,77,79,83,89,91,97,1...
21:48:52 <bd_> > [ n | n <- [1..], all (\p -> n `mod` p /= 0) [2,3,5] ]
21:48:53 <lambdabot>  [1,7,11,13,17,19,23,29,31,37,41,43,47,49,53,59,61,67,71,73,77,79,83,89,91,97...
21:49:02 <bd_> well, 2.. rather
21:49:09 <bd_> but that's one way to do it :)
21:50:06 <bd_> > foldl (\l p -> filter ((/= 0) . (`mod` p)) l) [2..] [2,3,5]
21:50:07 <lambdabot>  [7,11,13,17,19,23,29,31,37,41,43,47,49,53,59,61,67,71,73,77,79,83,89,91,97,1...
21:50:22 <bd_> no idea if that's any faster
21:50:27 <bd_> maybe if you have a lot of primes to filter for
21:56:42 <roconnor> Before teaching programmers haskell maybe we should lie and say we aren't writing programs, but formal specifications.
21:56:55 <Cale> hehe
21:57:05 <roconnor> we can say the type checker checks consistency of the spec
21:57:17 <roconnor> and at the very end surprise them by running it.
21:57:21 <Cale> hehe
21:57:32 <roconnor> that may get them out of impertive thinking
21:57:36 <roconnor> but maybe not
21:57:54 <Cale> Yeah, at the end of the course, whip out the Haskell compiler and actually run the specification for something :)
21:59:28 <adu> heh
21:59:29 <mofmog> oh god the hscurses website is down
21:59:30 <mofmog> -_
21:59:48 <adu> maybe its only accepting connections from w3m
22:00:16 <Twey> Maybe it's only accepting connections from one copy of w3m
22:00:24 <adu> lol
22:00:27 <Twey> Which is downloading the whole site repeatedly
22:00:37 <Twey> (wasn't me :<)
22:00:50 <adu> hehe
22:01:16 <elaforge> I'm trying to write an undo system and I'm getting stuck on the types.
22:01:24 <elaforge> it seems like it should be simpler than I'm making it
22:01:33 <adu> elaforge: it probably is
22:01:35 <elaforge> So I have Actions, which are things that get run in IO and should be undoable.
22:01:35 <elaforge> The thing is, to get an undo action from an action, you sometimes need to look
22:01:35 <elaforge> at the world before the action is run, and sometimes afterward.  So I thought
22:01:35 <elaforge> I would have one function "run :: Action -> IO (a, Action)" where fst is thereturn type and snd is the undo action.
22:01:42 <elaforge> Unfortunately that fails to typecheck, I suppose because 'a' is a different
22:01:42 <elaforge> specific type depending on Action, not really "any type".  So I thought of
22:01:42 <elaforge> going typeclass for Actions and writing:
22:01:59 <elaforge> class Actionable act res | act -> res where     run :: Actionable a b => act -> IO (res, a)
22:02:12 <elaforge> sorry, cut and paste is sucking :(
22:02:18 <elaforge> Unfortunately I get in a mess with the return action... since I don't know the
22:02:18 <elaforge> type *it* will return I guess.
22:02:18 <elaforge>      
22:03:12 <elaforge> the problem here is that Actions can return values when you run them
22:03:26 <elaforge> but they also need to return a undo Action
22:03:30 <adu> are you storing this in an undo list?
22:03:37 <elaforge> that's the idea
22:03:53 <adu> something like [Action]?
22:04:03 <elaforge> yep
22:04:18 <adu> so whats the data declaration for 'Action'?
22:04:22 <adu> is it big?
22:04:33 <elaforge> maybe eventually
22:05:05 <adu> do you need to store the return values in the list too? or only store the undo?
22:05:18 <elaforge> store the undo, return the value to the caller
22:05:46 <elaforge> (I haven't gotten to the storage detail yet, I imagine some kinda [Action] [Action] zipper or something)
22:06:23 <adu> so are you doing "do (ret, undo) <- actionThing"?
22:06:53 <adu> i've been using IORef's for that sort of thing
22:06:55 <elaforge> more or less
22:07:05 <elaforge> in my case it looks like
22:07:13 <elaforge> ret <- wact (some_act arg arg)
22:07:30 <elaforge> where wact is lifting some_act into IO
22:07:48 <elaforge> then wants to stick the (act, undo) in a Writer, and return ret
22:08:29 <elaforge> do_write (Action.Writer (act, op)) = do
22:08:29 <elaforge>     -- Get the action needed to undo this.
22:08:29 <elaforge>     undo_act <- Trans.liftIO (Undo.undo_action act)    State.modify (add_action act undo_act)
22:08:29 <elaforge>     -- Actually do it.
22:08:29 <elaforge>     Trans.liftIO op
22:08:35 <adu> like "undo <- readIORef undoList; writeIORef undoList (undo:undos)"
22:08:52 <elaforge> sure, adding to a list is easy
22:09:15 <adu> "undo:undos <- readIORef undoList; writeIORef undoList (undos)"
22:09:20 <elaforge> the problem is that do_write above runs undo_action before doing the op
22:09:46 <elaforge> but if I write (undo_act, res) <- run_and_undo the typechecker is unhappy
22:10:58 <elaforge> I wind up with
22:11:00 <elaforge> run :: Act -> IO (a, Act)
22:11:06 <elaforge> which doesn't go
22:12:00 <elaforge> then I thought "maybe I could use gadts to get the type of 'a' from the case on Act" but that's when I thought I was thinking too hard :)
22:12:10 <adu> liftIO doesn't lift into IO, it lifts out-of IO
22:13:24 <elaforge> sorry, got the terminology messed up
22:13:37 <adu> its ok, I'm confused
22:14:03 <elaforge> I think the storage of the actions is irrelevant
22:14:09 <elaforge> the difficulty comes before that
22:14:11 <elaforge> running them
22:15:02 <adu> so is it a type problem or an order-of-eval problem?
22:15:05 <elaforge> I can't even write "run :: Act -> IO a"
22:15:06 <elaforge> type problem
22:16:07 <adu> hmm
22:16:37 <elaforge> so what I'm actually doing is like "run :: (Act, IO a) -> IO a
22:16:53 <elaforge> where Act "promises" to be the action that IO a represents
22:17:06 <adu> so is "run" defined in terms of "do_write"?
22:17:28 <elaforge> then I can turn Act inside out and store it
22:17:38 <elaforge> the "run" above isn't implemented at all currently :)
22:17:47 <adu> oic
22:18:04 <elaforge> "do_write" is what I have that does work, but has to generate the undo action with no access to the return value of the action
22:19:10 <elaforge> oh sorry, the *second* 'run' (Act, IO a) -> IO a *is* do_write
22:19:25 <hpaste>  runar pasted "Hamming problem" at http://hpaste.org/6680
22:19:43 <elaforge> but naturally since 'a' is anything, I can't do anything with it except return it
22:20:09 <runar> What I pasted works, but doesn't seem very elegant.
22:20:52 <adu> elaforge: how is 'Undo.undo_action' implemented?
22:21:43 <elaforge> currently, a case on Action that looks at its args and app state and generates another Action
22:22:16 <adu> hmm ok
22:22:17 <elaforge> but I get stuck as soon as it needs to look at the return value of the action
22:22:40 <elaforge> eg CreateThingy arg -> DestroyThingy created_thingy
22:23:00 <adu> elaforge: I think it would be easier if your actions took at least one argument
22:23:03 <elaforge> where the IO represented by CreateThingy will return the thingy
22:23:20 <elaforge> well, they all do, of various types
22:23:29 <adu> hmm
22:23:41 <elaforge> data Act = This Int Bool | That String
22:23:42 <adu> so what type do you want 'do_write' to be?
22:24:08 <adu> ooo 'do_write' == 'run'?
22:24:37 <elaforge> Act -> (return_val, Act)
22:24:39 <elaforge> yeah
22:24:47 <elaforge> but I think I'd need
22:24:57 <elaforge> Act return_val -> (return val, Act <what?>)
22:25:35 <elaforge> the other approach I tried is with an Actionable existential type, so I could any type that supported run
22:25:45 <elaforge> but that also broke as soon as I needed to get a polymorphic return val out
22:26:37 <hpaste>  adu pasted "run" at http://hpaste.org/6681
22:26:53 <adu> is that what you mean?
22:27:21 <roconnor> Can I do derivingTranversable and Foldable?
22:28:04 <hpaste>  adu annotated "run" with "run - different?" at http://hpaste.org/6681#a1
22:28:13 <adu> or is that what you mean?
22:28:29 <elaforge> closer to the second
22:28:30 <elaforge> only
22:28:51 <dobblego> roconnor, {-# OPTIONS_GHC -XGeneralizedNewtypeDeriving #-}
22:28:52 <elaforge> if undo_action runs the act, I can't run it again with liftIO op
22:29:37 <adu> so is this about the order-of-eval issue now?
22:30:41 <elaforge> well, sorta I guess.  hang on, I'm trying to think of a better way to present this
22:32:50 <roconnor> dobblego: oh, does that work?
22:32:52 <roconnor> nice
22:33:03 <dobblego> roconnor, copy/pasted from a working source file ;)
22:33:09 <adu> elaforge: also, for the type issue, you could use Dynamic if needed
22:33:44 <elaforge> yeah, but then every time the caller gets a return val they have to cast, runtime type errors, etc.
22:35:11 <roconnor> dobblego: I guess this solves a lot of the problems that generic programming would be used for.
22:35:57 <roconnor> does traversable give you mapM?
22:36:09 <dolio> Yes.
22:36:22 <roconnor> foldM?
22:36:32 <roconnor> @hoogle foldM
22:36:33 <lambdabot> Control.Monad.foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
22:36:33 <lambdabot> Control.Monad.foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
22:36:33 <lambdabot> Data.Foldable.foldMap :: (Foldable t, Monoid m) => (a -> m) -> t a -> m
22:36:35 <dolio> You get foldM from foldable, I think.
22:36:45 <roconnor> oh right
22:36:50 <hpaste>  elaforge annotated "run" with "<?> is the probem" at http://hpaste.org/6681#a2
22:37:00 <elaforge> ok, I tried to boil it down
22:37:02 <dolio> Traversable gets you mapM (traverse) and sequence (sequenceA)
22:37:29 <dolio> And Foldable gets you the _ versions of those.
22:37:59 <elaforge> I'm by no means married to the big union type for Act, or the Writer hack
22:47:01 <hpaste>  elaforge annotated "run" with "more elegant, still bad types" at http://hpaste.org/6681#a3
22:52:19 <elaforge> so it makes me think I need an explicit association between an Action and its return type
22:52:46 <elaforge> which gets me into fundep territory or maybe gadts
22:52:58 <elaforge> so maybe it really *is* that complicated :(
22:55:32 <adu> elaforge: hmm
22:55:44 <elaforge> but lots of people do undo without exploding their heads
22:55:57 <adu> elaforge: I'm having a problem with mkthing name = return (Thing name)
22:56:03 <adu> ghci chokes
22:56:15 <elaforge> really?  mine doesn't
22:56:27 <dobblego> let mkthing name = return (Thing name)
22:56:33 <elaforge> that should be trivial...
22:56:39 <dobblego> let mkthing = return . Thing
22:57:07 <elaforge> what's the error?
22:58:41 <adu> elaforge: well thats the thing it doesn't say theres an error with 'mkthing' I always says theres an error with whatever is after it
22:58:56 <elaforge> data Act = ...?
22:59:01 <adu> I've tried rearranging the code you game me several times, and it allways complains about the line after mkthing
22:59:09 <elaforge> and you're pasting into a file and doing :l?
22:59:22 <adu> no when i move data Act above it, then it complains about the '=' in 'newtype Writer a ='
22:59:32 <adu> yes
22:59:35 <adu> :load test.hs
22:59:44 <elaforge> what's the error msg?
22:59:47 <Cale> can we see the file?
23:00:00 <elaforge> http://hpaste.org/6681#a3
23:00:03 <JoshTriplett> I wanted to make some helpers for Database.HDBC, to make it easier to use toSql and fromSql on sets of columns.  So I created a class SqlTypes, with functions toSqlValues and fromSqlValues that convert to/from [SqlValue], and made instances for tuples of various arities.
23:00:14 <JoshTriplett> I also made "instance SqlType a => SqlTypes a", to handle the case of a single value.
23:00:23 <elaforge> maybe a tab/space thing?
23:01:01 <JoshTriplett> But Database.HDBC has an "instance Show a => SqlType a" which uses show to convert to a string.
23:01:14 <JoshTriplett> So I end up with overlapping instances for tuples, because you can show tuples.
23:01:15 <Cale> I just get a type error from that code.
23:01:22 <elaforge>     Couldn't match expected type `()' against inferred type `Thing'
23:01:28 <elaforge> that one?
23:01:28 <hpaste>  adu annotated "run" with "my run" at http://hpaste.org/6681#a4
23:01:31 <Cale> yep
23:01:35 <elaforge> yeah, that's the problem :)
23:01:49 <JoshTriplett> I can't use -foverlapping-instances because Database.HDBC doesn't, and I don't think I can hide the instance when importing Database.HDBC.
23:01:51 <elaforge> I don't think I can have 'a' in the return type
23:01:53 <JoshTriplett> Any suggestions on how to fix this problem?
23:02:04 <Cale> some of your explicit type signatures are wrong
23:02:18 <Cale> do_write :: Writer -> IO a
23:02:21 <Cale> that's a kind error
23:02:31 <Cale> (Writer isn't applied to enough type parameters)
23:02:41 <elaforge> oh in adu's version?
23:02:50 <Cale> run :: Act -> IO (a, Act)
23:02:59 <Cale> that's just a plain type error
23:03:03 <adu> ah
23:03:32 <elaforge> Cale, yeah, that's the issue, I want a polymorphic return type
23:03:38 <Cale> That a means "absolutely any type whatsoever".
23:03:48 <Cale> So the only thing it could produce is the undefined value.
23:04:16 <elaforge> so my second example lets me do the act and generate the undo at once, but not actually use the returned val
23:04:22 <adu> i give up, I'm learning Rebol
23:04:25 <Cale> heh
23:04:41 <elaforge> my first example lets me use the returned val, but not pass the returned val to make the undo
23:05:09 <Cale> hmm
23:05:24 <elaforge> then my attempted version with fundep to capture the Act->return_val relationship also had a problem
23:05:31 <Cale> I haven't really been following this conversation closely... you're constructing a mechanism for undo?
23:05:38 <elaforge> yeah, trying to :)
23:05:50 <elaforge> basically, I want to say
23:05:59 <Cale> Okay. So you have some state, and presumably a list of previous values of that state.
23:06:03 <elaforge> val <- do_some_action arg arg arg
23:06:21 <elaforge> and then someone will note that I did some action with the given args, and what to do to undo that
23:06:52 <elaforge> the state is really big, so I was thinking of storing the actions, rather than copies of the state
23:07:13 <Cale> Okay, well, the IO monad doesn't come with information about what to do in order to undo arbitrary IO actions, so you'll have to specialise things.
23:07:31 <elaforge> right, so I have an Action type
23:07:50 <elaforge> that maps to each of the things I can do
23:08:13 <Cale> Okay
23:08:15 <elaforge> I have a smallish vocabulary of actions
23:08:35 <elaforge> that take various arg types, and return various vals
23:08:59 <elaforge> actually, I can *almost* get them to never have return vals, which would solve my problem :/
23:09:09 <Cale> hmm
23:09:14 <Cale> How would that fix things?
23:10:02 <Cale> You'll want to build up a log of the actions which you'd taken as the computation progresses. You already have an abstract representation of those, and a representation of how to invert them, as well as presumably a way to turn them into IO actions.
23:10:15 <hpaste>  JoshTriplett pasted "overlapping instances problem" at http://hpaste.org/6682
23:10:34 <elaforge> then my "run" function is "Act -> IO Act", not "Act -> IO (a, Act)"
23:10:45 <elaforge> cale, right
23:11:11 <elaforge> the issue is inverting them sometimes needs the result of the action (i.e. CreateThing -> DestroyThingy thing)
23:11:17 <Cale> It should not be Act -> IO (a,Act) anyway -- I don't think that means at all what you think it does :)
23:11:32 <elaforge> Cale, well right, I know what I *wish* it meant though :)
23:11:48 <Cale> You might want a GADT
23:11:58 <elaforge> haskell uses magic dependent type technology to figure out 'a' based on Act
23:12:01 <elaforge> heh
23:12:05 <Cale> So that it would be something like  Act a -> IO (a, Act a)
23:12:20 <elaforge> heh, out comes the magic dependent type tech :)
23:12:29 <Cale> and a value of type Act a is an action which when carried out produces a value of type a
23:12:41 <elaforge> yeah, that sounds right
23:13:08 <elaforge> then Act looks like what?  = CreateThing String :: String -> Thing" ?
23:13:20 <Cale> data Act a where
23:13:35 <Cale>    CreateThing :: String -> Act Thing
23:13:50 <Cale>    DestroyThing :: Thing -> Act ()
23:14:02 <elaforge> oh this is looking promising
23:14:29 <elaforge> now when I case switch in 'run' I'm specializing the return type
23:14:33 <elaforge> lemme try writing run with that
23:15:32 <Cale> and you might have something like   run :: Act a -> IO a
23:15:48 <elaforge> what about the undo action?
23:16:36 <elaforge> specifically, the undo action, which will return yet another type...
23:16:38 <Cale> well, you might want that as well :)
23:16:42 <Cale> oh
23:17:01 <elaforge> if CreateThing undoes to DestroyThing, that's Thing -> ()
23:17:07 <Cale> perhaps something like  undo :: Act a -> Act ()
23:17:12 <Cale> hmm
23:17:22 <Cale> not quite :)
23:17:32 <Cale> ah, I see the problem
23:18:02 <elaforge> I wind up with Act a -> IO (a, Act <?>)
23:18:14 <elaforge> previously I had tried to hide stuff in an existential type
23:18:36 <Cale> Well, let's look at another approach perhaps...
23:18:38 <elaforge> but if it's the return value, I can't get it back out, since it'll still be 'a'
23:19:05 <Cale> When we're logging what's happened, we really don't care about the return types.
23:19:22 <elaforge> mmmm, yeah
23:19:58 <Cale> You need the return types in order to be able to directly turn log events into full fledged actions which can return values, but maybe it's better to give that up in favour of just being able to carry the side effects out without getting the result.
23:20:13 <Cale> (because if you're just undoing something, you don't care about the result)
23:21:07 <elaforge> well, I do need the result to generate the undo.  so if I undo Create, I need to generate a Destroy to redo
23:21:43 <Cale> well, that's possible, but you can't actually return the result while you're at it :)
23:21:51 <Cale> You just return the undo action.
23:22:11 <elaforge> yeah... that was my first version, maybe it's still the best
23:22:13 <Cale> So we have:   undo :: Act -> IO Act
23:22:24 <elaforge> I have to figure out how to do without the return val though
23:22:34 <Cale> (or something like that)
23:22:36 <elaforge> how do I do
23:22:45 <elaforge> thing <- create_thing blah
23:22:51 <elaforge> frobnicate thing
23:23:00 <elaforge> where both 'create' and 'frobnicate' get logged for undoing
23:23:01 <Cale> make a separate createThing
23:23:24 <Cale> which does the IO and stores the appropriate action in a log.
23:23:43 <Cale> (maybe using a StateT over IO to maintain that log)
23:23:51 <elaforge> sure, that's what I have
23:23:54 <Cale> okay
23:24:02 <elaforge> (using your web page for help, btw :)
23:24:09 <Cale> ah, cool :)
23:24:15 <JoshTriplett> elaforge: Do you intend to allow undoing things only in order?
23:24:16 <elaforge> so then I have
23:24:23 <elaforge> create_thing blah
23:24:26 <elaforge> frobnicate <what?>
23:24:54 <elaforge> JoshTriplett: yes, to get to act 0, you have to undo [n,n-1..0]
23:25:00 <JoshTriplett> elaforge: OK.
23:25:21 <elaforge> JoshTriplett: well, eventually I'd like to have checkpoints and stuff, but first things first :)
23:25:54 <elaforge> so if create_thing stuck the created thing into an environment maybe I could say
23:25:58 <elaforge> create_thing "name"
23:26:03 <elaforge> frobnicate (get "name")
23:26:28 <elaforge> but I think whoever runs and logs create_thing will have the same trouble getting the return val
23:26:32 <JoshTriplett> elaforge: You can return the created thing to the caller, and use state to stuff the undo action in the state.
23:27:16 <elaforge> JoshTriplett, but that's what I can'd do, since the return type is polymorphic
23:28:08 <elaforge> only way out I can think of so far is dynamic types
23:28:15 <Cale> elaforge: but for undoing, you shouldn't care about the return value, should you?
23:28:46 <elaforge> Cale, but I think I have to.  undoing CreateThing needs something to pass to DestroyThing
23:29:03 <JoshTriplett> elaforge: Internally, yes...
23:29:16 <JoshTriplett> type UndoableIO a = StateT [IO ()] IO a
23:29:35 <Cale> But it doesn't have to return that value, it returns an Act
23:29:42 <elaforge> hmm, maybe I have DestroyThing take a string, not a thing, and then it looks that up internally
23:29:49 <JoshTriplett> (temporarily giving an example without using Act here...)
23:30:01 <JoshTriplett> createThing :: String -> UndoableIO Thing
23:30:48 <elaforge> Cale, so how would the "create >>= frobnicate" example look then?
23:31:21 <Cale> elaforge: It should look the same, as this would all be going on inside create
23:31:50 <JoshTriplett> createThing s = do thing <- actuallyCreateThing s ; modify ((actuallyDestroyThing thing):) ; return thing
23:33:00 <JoshTriplett> Notice that the caller of createThing just gets back a Thing in the monad, and the details of undoing, including the thing needed to undo, appear in the monad.
23:33:39 <elaforge> ok, so now if I do the undo, how do I redo that?
23:34:13 <elaforge> I can invert with createThing, but if actuallyDestroyThing is IO (), I can't invert it back again...
23:35:04 <JoshTriplett> OK, how about this...
23:36:06 <elaforge> Cale, but "frobnicate" wants a thing, not an Act describing how to make the thing...
23:36:20 <elaforge> or how to unmake it, rather
23:36:36 <Cale> elaforge: sure, and createThing will return that
23:36:52 <Cale> elaforge: But that's not what goes in the log. An Act goes in the log.
23:37:02 <Cale> (or perhaps just an IO action with type IO ()
23:37:04 <Cale> )
23:37:09 <elaforge> Cale, hmm, I'm not getting it.  could you sketch out the 'run' function?
23:37:38 <elaforge> or sorry, the implementation for createThing
23:37:48 <Cale> Read what JoshTriplett just wrote
23:38:06 <elaforge> ah ok, the one that stores IO ()
23:38:19 <elaforge> I think I get in trouble when I want to undo the undo then
23:38:56 <Cale> Well, you might have to be careful about which log you're writing into.
23:39:33 <Cale> Have you seen MonadUndo by the way?
23:39:45 <Cale> It's not exactly what you want here, but it might give some ideas.
23:39:57 <elaforge> yeah, but I might understand it better now
23:40:07 <adu> did someone say my name?
23:40:09 <Cale> It's like a State monad which keeps track of the state.
23:40:37 <adu> oh, 'Mon_adU_ndo' i guess my client matches case insensitive...
23:40:43 <elaforge> where you have a complete copy of the state at every point?
23:40:44 <elaforge> haha
23:40:49 <JoshTriplett> !hoogle Monad m => m a -> m ()
23:41:06 <elaforge> you need a name with more qs and z's in it
23:42:23 <JoshTriplett> Given a "m a", how do I ignore the a and get a "m ()"?
23:42:37 <elaforge> (>> return ()) ?
23:42:41 <Cale> adu: and whitespace insensitive
23:42:52 <JoshTriplett> elaforge: That'll work, I guess.
23:42:55 <Pseudonym> fmap (const ()) m
23:43:11 <Pseudonym> :t fmap (const ()))
23:43:13 <lambdabot> parse error on input `)'
23:43:17 <Pseudonym> :t fmap (const ())
23:43:18 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f ()
23:43:21 <Cale> elaforge: yeah, though in practice that might not be so bad, since nearby states probably share a lot of structure in a lot of programs
23:43:47 <JoshTriplett> typeUndoableIO a = StateT ([(IO (), IO ())], [(IO (), IO ())]) IO a
23:43:47 <JoshTriplett> createThing s = do thing <- actuallyCreateThing s ; (undo, undone) <- get ; put ((actuallyCreateThing s >> return (), actuallyDeleteThing thing):undo, undone)
23:43:51 <JoshTriplett> How about that?
23:44:10 <adu> Cale: true
23:44:31 <elaforge> Cale, unfortunately restoring a complete state from scratch means creating a bunch of windows and calling a bunch of gui functions...
23:45:10 <Pseudonym> If you can use pure functional undo (i.e. no trailing), it's usually worth it.
23:45:29 <JoshTriplett> Then: undo :: UndoableIO () ; undo = do ((d,u):undo, undone) <- get ; u ; put (undo, (d,u):undone)
23:45:43 <elaforge> Pseudonym, "no trailing" means series of snapshots, rather than a serias of actions?
23:45:58 <JoshTriplett> And: redo :: UndoableIO () ; redo = do (undo, (d,u):undone) <- get ; d ; put ((d,u):undo, undone)
23:46:08 <JoshTriplett> Ugly as heck, but won't that work?
23:46:14 <elaforge> JoshTriplett, ok hang on lemme copy and reformat and digest
23:46:42 <JoshTriplett> elaforge: You keep two stacks of actions, which consist of an IO () to undo and an IO () to redo.
23:46:57 <JoshTriplett> elaforge: When you do something, you push what you did and what undoes it onto the undo stack.
23:47:07 <JoshTriplett> elaforge: When you want to undo it, run the undo action and move it to the undone stack.
23:47:21 <JoshTriplett> elaforge: To redo it, run the redo action and move it back to the undo stack.
23:47:24 <elaforge> and then to redo you just reverse
23:47:25 <elaforge> nice
23:47:41 <JoshTriplett> elaforge: Presumably when you do a new action you drop the undone stack, actually.
23:48:05 <elaforge> well, I'm actually keeping a tree, so not so in this case
23:48:14 <elaforge> but it should stil work, I think
23:48:22 <JoshTriplett> elaforge: That really depends.
23:48:39 <JoshTriplett> elaforge: On if you can safely go back and do something else in the middle.
23:48:50 <elaforge> oh... right, why I wanted Actions is because they're serializable
23:48:59 <elaforge> it's hard to save IO () to disk :(
23:49:16 <JoshTriplett> elaforge: "do undo ; someAction ; redo" might always work.
23:49:27 <JoshTriplett> *might not
23:49:47 <elaforge> right, in your example, someAction would put you on a different branch, so redo wouldn't apply
23:50:02 <elaforge> if you do redo at a node, you have to specify what branch to take
23:50:07 <JoshTriplett> Oh, fun.
23:50:16 <JoshTriplett> Sounds really interesting and really painful.
23:50:23 <JoshTriplett> elaforge: What use case do you have again?
23:50:31 <elaforge> haha, and I thought "it'll be easy" :)
23:50:38 <Cale> http://uk.youtube.com/watch?v=b5-hU53El3U -- hehe, my favourite LRR video
23:50:39 <lambdabot> Title: YouTube - LoadingReadyRun - Holiday
23:50:52 <elaforge> undo, redo, don't lose data, don't have explicit save
23:51:05 <JoshTriplett> elaforge: Document editor of some kind?
23:51:12 <elaforge> yeah, for music
23:51:15 <JoshTriplett> elaforge: Ah.
23:51:25 <JoshTriplett> elaforge: I can see why a complete copy of the state seems problematic.
23:51:33 <Cale> (I uploaded it to youtube since it requires something like the mplayer plugin to view otherwise.)
23:51:36 <elaforge> hence the lots of data... there could be a big stream of control data
23:51:37 <JoshTriplett> elaforge: Though good luck undoing anything that throws away data.
23:51:48 <JoshTriplett> elaforge: decimate, for instance.
23:51:56 <JoshTriplett> elaforge: Or resample.
23:52:08 <elaforge> JoshTriplett, that's why none of my action primitives do that, except Destroy* which has to save it in the undo
23:52:31 <JoshTriplett> elaforge: So, if you wanted to add any destructive action, you'd just make the undo action "replace state with this"?
23:52:58 <Pseudonym> elaforge: Sorry, yes, "pure functional" means a series of snapshots.
23:53:16 <elaforge> Cale, oh btw on the subject of your newtype deriving monad transformer page, while it shows how to make a nicely encapsulated monad stack, can you use the same thing to make it a monad transformer?
23:53:20 <Pseudonym> In Haskell, you can usually share bits of a data structure between versions.
23:53:25 <Cale> elaforge: yeah
23:53:34 <Cale> elaforge: You can see that in MonadUndo
23:54:06 <JoshTriplett> Pseudonym: Though in fairness it seems unlikely that you could share bits of an audio file data structure.
23:54:14 <elaforge> JoshTriplett fortunately I'm not working with audio data.  but if I were I'd just save the old version of the file on disk, like audio editors do
23:54:15 <Pseudonym> Why not?
23:54:23 <Pseudonym> You'd need to store it in a rope-like data structure.
23:54:29 <elaforge> err, copy-on-write I mean
23:54:35 <JoshTriplett> Pseudonym: OK, I guess you could do that, sure.
23:54:55 <elaforge> Cale, cool I'll study that when trying to transformerize my own
23:55:33 <Pseudonym> In addition, if your editor is 100% nonlinear, then you only need to undo/redo the _operations_, not the audio streams.
23:55:58 <JoshTriplett> Would someone mind taking a look at the overlapping instances problem in http://hpaste.org/6682?lines=true ?
23:56:30 <elaforge> Pseudonym, right, that's the plan
23:56:58 <Cale> JoshTriplett: both of your instances apply to that call
23:57:04 <JoshTriplett> Cale: Yeah, I realize that.
23:57:10 <Cale> JoshTriplett: So it's saying "I can't decide which to use"
23:57:24 <JoshTriplett> Cale: Because Database.HDBC has an instance of SqlType a for any Show a.
23:57:33 <JoshTriplett> Cale: Which I don't want, but AFAIK can't get rid of.
23:58:00 <JoshTriplett> Cale: And tuples form instances of Show.
23:58:10 <elaforge> Pseudonym, so if I had all state in haskell (currently it's in mutable c++ structures which haskell queries), that would be cool
23:58:25 <JoshTriplett> Cale: So (a, b) matches both instances if Show a, Show b and SqlType a, SqlType b.
23:58:34 <JoshTriplett> Cale: So how do I fix this problem?
23:58:36 <elaforge> Pseudonym, to update the gui I'd have to do some kind of compare and only update the bits that changed...
23:58:44 <JoshTriplett> Cale: I can't use -foverlapping-instances because Database.HDBC doesn't.
23:59:00 <Cale> You would probably have to use -XIncoherentInstances
23:59:08 <JoshTriplett> Cale: And as far as I know I can't hide the problematic instance declaration in Database.HDBC.
23:59:13 <elaforge> and then use something like a DiffArray version of Data.Map ...
23:59:35 <elaforge> or maybe Map shares a lot after a normal insert
