00:00:10 <Cale> JoshTriplett: I don't think that Database.HDBC expects you to define your own instances of SqlType
00:00:21 <Cale> er...
00:00:26 <JoshTriplett> Cale: I didn't define instances of SqlType.
00:00:31 <Cale> I see...
00:00:32 <elaforge> but it would make going to an arbitrary past state the same as restoring a snapshot, which I would like
00:00:34 <JoshTriplett> Cale: I defined an instance of SqlTypes.
00:00:40 <JoshTriplett> Cale: instances, rather.
00:00:47 <Cale> Right... two overlapping instances
00:00:56 <Cale> Can you somehow make them not overlap?
00:01:04 <Cale> Like, introduce a newtype wrapper?
00:01:17 <JoshTriplett> Cale: I want both.  I just don't want the one derived from Show that Database.HDBC defines.
00:01:26 <JoshTriplett> Cale: What do you mean?
00:02:04 <Cale> newtype Single a = Single a
00:02:16 <Cale> instance SqlType a => SqlTypes (Single a) where
00:02:18 <Cale>   ...
00:02:28 <JoshTriplett> Yeah, I thought about that.
00:02:46 <JoshTriplett> Cale: But then callers have to do Single foo <- ... rather than foo <- ...
00:02:58 <JoshTriplett> Cale: I can live with that, but I really don't want to have to.
00:03:25 <Cale> Note also that even if you could hide all the instances of SqlType coming from Database.HDBC, it wouldn't help you
00:03:28 <elaforge> Cale, JoshTriplett: thanks for your help guys
00:03:35 <elaforge> I still don't have an answer, but it's clarified the issues for me :)
00:03:52 <Cale> Like, even if Database.HDBC didn't actually define any instances of SqlType, your instances still overlap.
00:04:01 <JoshTriplett> Cale: Not as far as I can tell.
00:04:19 <JoshTriplett> Cale: A tuple wouldn't form an instance of SqlTypes unless it formed an instance of SqlType.
00:04:44 <JoshTriplett> Cale: And it only does *that* because Database.HDBC defines an instance of SqlType for anything in Show, such as tuples.
00:05:01 <Cale> However, you can never know whether that tuple might eventually be made an instance of SqlType in a future module.
00:05:10 <elaforge> Pseudonym, I'm gonna try thinking about how to store all the state in snapshots haskell and always update the gui from a snapshot
00:05:11 <JoshTriplett> Cale: "don't do that then"? :)
00:05:30 <JoshTriplett> Cale: I have no issues with making that the problem of anyone who makes tuples an instance of SqlType.
00:05:31 <Cale> So GHC doesn't actually use the typeclass contexts when deciding whether the instance matches.
00:05:48 <Cale> The instance must match or not based solely on the part after the =>
00:06:06 <JoshTriplett> Cale: *What?*
00:06:13 <JoshTriplett> Cale: OK, that seems painful...
00:06:24 <Cale> (and then the preconditions are checked)
00:06:31 <JoshTriplett> Cale: Why would it care about instance declarations not visible at the point it makes a call?
00:06:48 <Cale> They might be visible in the caller of that code
00:06:59 <JoshTriplett> Cale: Right, so why not complain there, rather than in my module?
00:07:37 <JoshTriplett> Cale: Complain if you attempt to use a tuple as a SqlTypes *if you have an instance declaration for SqlType (...tuple...)*.
00:07:41 <Cale> For example, if I write some polymorphic code which uses show, then I would hope it's still usable with instances that aren't visible from inside my code.
00:07:51 <Cale> right?
00:08:27 <JoshTriplett> Cale: Right, but if you use show, then your function has a type with "Show a => ...".
00:08:34 <Cale> Yep.
00:08:49 <JoshTriplett> Cale: So the caller of that function knows it needs a Show, so it can decide at call time if it has overlapping instances of Show.
00:09:27 <JoshTriplett> Cale: Why wouldn't that work?
00:09:29 <Cale> So, okay, let's suppose for now that there are no visible instances of SqlType (at all), and we're compiling a module which contains a polymorphic function:
00:10:03 <JoshTriplett> Cale: OK.  That function has type SqlTypes a => ... a ..., right?
00:10:07 <Cale> foo :: (SqlTypes a) => [[SqlValue]] -> [a]
00:10:10 <Cale> right
00:10:20 <Cale> and foo looks like
00:10:37 <Cale> foo xs = map fromSqlValues xs
00:10:55 <JoshTriplett> Cale: OK.
00:11:47 <Cale> Okay, so we can assume that there's an instance of SqlTypes for a, and compiling this is pretty straightforward
00:11:59 <Cale> (because we'll be handed a dictionary)
00:12:27 <JoshTriplett> Cale: Right.  I have some rudimentary understanding of dictionaries and the transformation to remove classes.
00:12:40 <JoshTriplett> Cale: (*very* rudimentary)
00:13:48 <Cale> Okay, now let's say foo gets used polymorphically to produce something which we know is a list of pairs.
00:14:11 <Cale> But we still don't have any visible instances of SqlType
00:14:47 <JoshTriplett> Cale: We'd have to to call foo, right?
00:14:52 <Cale> Yeah...
00:14:59 <Cale> say we do something like
00:15:23 <Cale> bar = foo [[someSqlValue, someOtherSqlValue]]
00:15:37 <JoshTriplett> Cale: Alright.
00:15:57 <Cale> and we're compiling this module, so we have to pick an instance to pass to foo
00:16:05 <JoshTriplett> Cale: So bar has type SqlTypes a => [a], right?
00:16:25 <Cale> hmm, perhaps better:
00:17:06 <Cale> hmm, did I pick a bad example? :)
00:17:22 * dons now has 10k reddit karmas. do i get a prize? :|
00:17:23 <Cale> oh, we have your instances...
00:17:51 <JoshTriplett> Cale: Anything calling foo either needs a concrete type (and thus an instance of SqlTypes) or a polymorphic type (and thus a "SqlTypes a =>", so it has a dictionary).
00:17:55 <Cale> JoshTriplett: that's indeed the inferred type
00:17:58 <JoshTriplett> Cale: Right?
00:18:32 * JoshTriplett hands dons a "go visit the big blue room" award.
00:18:36 <Cale> It could also just have a SqlType context
00:18:37 <dons> hehe
00:18:47 <hpaste>  dmwit pasted "question about sharing" at http://hpaste.org/6683
00:18:51 <solrize> hey dons, is there a way to crank up the buffer size of bytestring lazy io to a much larger amount, like 10 meg?  that is to avoid seek latency when munching a lot of disk files simultaneously
00:18:51 <Cale> for example:
00:19:02 <Cale> bar :: (SqlType a) => [a]
00:19:03 <JoshTriplett> Cale: Sure, and then it can derive a SqlTypes instance from the instances I gave.
00:19:12 <JoshTriplett> Cale: Yeah, that works.
00:19:16 <dmwit> I've been working through Chris Okasaki's book, and came up with a long-ish question.
00:19:22 <Cale> bar :: (SqlType (a,b), SqlType a, SqlType b) => [(a,b)]
00:19:42 <Cale> (this is a dumb example that I've worked myself into, but this is the idea)
00:19:52 <JoshTriplett> Cale: That brings me back to "don't do that then". :)
00:19:54 <dmwit> It has to do with sharing in a really simple tree structure.
00:20:06 <Cale> Okay, let's pick a better example...
00:20:15 <JoshTriplett> Cale: At that point, bar should generate a warning.
00:20:27 <solrize> oh it does say there is a way
00:20:35 <Cale> You can end up with pretty insane and incoherent things like this.
00:20:55 <Cale> Oh, I could steal an example from the GHC user guide :)
00:21:58 <Cale> JoshTriplett: You also have the general problem that you could commit to some polymorphic instance, compile the code, and then later on, a less polymorphic instance gets defined
00:22:06 <Cale> (which is actually a better match)
00:22:09 <JoshTriplett> Cale: By the way, -XIncoherentInstances worked.
00:22:12 <JoshTriplett> Cale: Thanks for that.
00:22:12 <Cale> yeah
00:22:24 <JoshTriplett> Cale: I feel somewhat uncomfortable using it, but I'll live. :)
00:22:26 <Cale> It'll work, it's just somewhat dangerous :)
00:22:36 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#undecidable-instances
00:22:38 <lambdabot> Title: 8.6. Class and instances declarations, http://tinyurl.com/245leb
00:22:39 <JoshTriplett> Cale: Define "dangerous"?
00:23:20 <JoshTriplett> Cale: What example did you want me to see in that section?
00:23:36 <Cale> Have a look at section 8.6.3.3
00:23:40 <Cale> on overlapping instances
00:24:09 <Cale> It'll give a good example of some possible overlapping instances and how the various available flags cause the example to be treated
00:24:24 <hpaste>  vegai's sample pasted "buggy xmonad.hs" at http://hpaste.org/6684
00:25:57 <Cale> Oleg found a way to use Incoherent instances along with Data.Dynamic to break the soundness of the ST monad.
00:26:19 <Cale> (and sneak out references to state)
00:26:30 <JoshTriplett> Cale: Run.
00:26:36 <JoshTriplett> Cale: Er, Fun.
00:26:41 <Cale> You can define an instance of Typeable for a
00:26:52 <Cale> which of course horribly overlaps with everything
00:27:06 <Cale> but you have Incoherent instances turned on, so that's okay
00:27:36 <Cale> Then you make a newSTRef and apply toDyn to it, which uses that instance to make it into a Dynamic
00:28:06 <Cale> then you can return it from the ST code just fine
00:28:19 <adu> i like toDyn :)
00:28:25 <Cale> and later on, use fromDyn to cast it back and read it
00:28:28 <JoshTriplett> Cale: By the way, this whole issue came up because we originally tried to use Data.Generics to convert any "Data a" into a [SqlValue], but ran into the problem that you can't turn an instance-polymorphic function into a query.
00:28:58 <JoshTriplett> Cale: So you saying "Typeable" brought out a shudder before you even got to the details. :)
00:28:58 <dmwit> :t toDyn
00:28:59 <lambdabot> forall a. (Typeable a) => a -> Dynamic
00:29:14 <JoshTriplett> Dynamic roughly means "variant"?
00:29:23 <adu> roughly
00:29:32 <Cale> :t fromDyn
00:29:32 <lambdabot> forall a. (Typeable a) => Dynamic -> a -> a
00:29:37 <Cale> :t fromDynamic
00:29:38 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
00:29:50 <Cale> (kind of crufty naming scheme)
00:29:58 <adu> i like fromDynamic :)
00:30:18 <dmwit> :t \x -> fromMaybe x . fromDynamic
00:30:18 <Cale> > fromDynamic (toDyn (5 :: Integer)) :: Maybe String
00:30:19 <lambdabot> forall a. (Typeable a) => a -> Dynamic -> a
00:30:20 <lambdabot>  Nothing
00:30:21 <JoshTriplett> Cale: So, by definition, fromJust . fromDynamic . toDyn == id, assuming instances of Typeable?
00:30:25 <Cale> > fromDynamic (toDyn (5 :: Integer)) :: Maybe Integer
00:30:26 <lambdabot>  Just 5
00:30:52 <JoshTriplett> :t fromJust . fromDynamic . toDyn
00:30:53 <lambdabot> forall a a1. (Typeable a1, Typeable a) => a1 -> a
00:30:55 <Cale> yes, except that...
00:31:03 <Cale> well, look at that type :)
00:31:14 <JoshTriplett> Cale: Yay for dynamic type confusion.
00:31:18 <dmwit> > (fromJust . fromDynamic . toDyn $ 5) :: String
00:31:19 <lambdabot>  Exception: Maybe.fromJust: Nothing
00:31:22 <JoshTriplett> Cale: a1 == a, but the compiler doesn't know that.
00:31:29 <Cale> No, they might not be equal
00:31:32 <dmwit> right
00:31:39 <Cale> In which case you get a runtime error from the fromJust
00:32:02 <Cale> fromDynamic . toDyn is a typesafe cast
00:32:06 <JoshTriplett> :t (fromJust . fromDynamic . toDyn) :: (Typeable a => a -> a)
00:32:07 <lambdabot> forall a. (Typeable a) => a -> a
00:32:19 <JoshTriplett> > ((fromJust . fromDynamic . toDyn) :: (Typeable a => a -> a)) 5
00:32:19 <lambdabot>  Parse error at "=>" (column 50)
00:32:20 <Cale> *that* would be id, indeed
00:32:26 <JoshTriplett> Cale: OK, I see.
00:32:38 <JoshTriplett> Cale: fromDynamic . toDyn == cast
00:32:42 <Cale> :t cast
00:32:43 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
00:32:54 <Cale> yep
00:33:02 <JoshTriplett> Cale: And (fromJust . cast) :: (Typeable a => a -> a) == id
00:33:09 <Cale> yep
00:33:12 <dmwit> Does anybody have a few minutes to look at my hpaste?
00:33:31 <shapr> Cale: When do you sleep?
00:33:45 <dmwit> ?localtime Cale
00:33:45 <lambdabot> Local time for Cale is Fri Mar 28 03:32:37
00:33:53 <Cale> shapr: Approximately whenever I'm tired :)
00:33:57 <shapr> heh, ok then
00:34:01 <shapr> @localtime shapr
00:34:10 <JoshTriplett> Cale: So, it seems to me that the problem there doesn't lie with incoherent instances.
00:34:19 <shapr> Bah, pidgin doesn't do ctcp
00:34:25 <Cale> Often from about 5am to sometime in the early afternoon
00:34:31 <JoshTriplett> Cale: It lies with the unsafeCoerce underneath Dynamic/Typeable/etc.
00:34:34 <dmwit> shapr: Do the CTCP reply yourself. ;-)
00:34:54 <Cale> JoshTriplett: Except that Dynamic is actually safe on its own
00:35:11 <dmwit> What unsafeCoerce?
00:35:13 <Cale> JoshTriplett: and ST is safe on its own, and even with Dynamic
00:35:26 <shapr> dmwit: pidgin doesn't support /ctcp either :-(
00:35:34 <Cale> dmwit: There's an unsafeCoerce inside the implementation of Dynamic
00:35:35 <quicksilver> dmwit: the one in the implementation of Data.Dynamic
00:35:42 <JoshTriplett> dmwit: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Dynamic.html
00:35:42 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2sddx7
00:35:43 <adu> just typr CTCP 127.0.0.1 234.456.345.567 data...
00:35:48 <Cale> but it doesn't actually matter, since it's not exposed
00:36:09 <dmwit> Huh, interesting.
00:36:09 <quicksilver> Data.Dynamic is safe to use in pure haskell but it is not possible to *write* it in pure haskell.
00:36:18 <solrize> what exactly is 'typable' ?
00:36:26 <Cale> The typesafe cast which is exposed is normally harmless. It's only when you write an instance of Typeable which overlaps with everything that you can abuse it like that.
00:36:33 <JoshTriplett> solrize: "Thing you can ask for the type of".
00:36:35 <shapr> adu: That works for pidgin?
00:36:42 <Cale> :t typeOf
00:36:42 <lambdabot> forall a. (Typeable a) => a -> TypeRep
00:36:46 <adu> shapr: actually, no
00:36:49 <shapr> oh
00:36:50 <Cale> > typeOf "hello"
00:36:51 <lambdabot>  [Char]
00:36:55 <solrize> yow
00:37:00 <shapr> @yow !
00:37:01 <lambdabot> I have a TINY BOWL in my HEAD
00:37:03 <solrize> looks dynamic already :)
00:37:15 <Cale> > cast "hello" :: Maybe Integer
00:37:16 <lambdabot>  Nothing
00:37:19 <Cale> > cast "hello" :: Maybe String
00:37:19 <lambdabot>  Just "hello"
00:37:20 <dmwit> > typeOf 3
00:37:20 <lambdabot>  Integer
00:37:34 <adu> > typeOf [toDyn 1, toDyn "Hi"]
00:37:34 <lambdabot>  [Dynamic]
00:37:41 <bd_> :t cast
00:37:42 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
00:37:49 <quicksilver> solrize: it's not really dynamic, in that the type information is gleaned at compile time not runtime.
00:37:51 <dmwit> :t unsafeCoerce
00:37:52 <lambdabot> Not in scope: `unsafeCoerce'
00:37:55 <Cale> > map fromDynamic [toDyn 1, toDyn "Hi"] :: [Maybe String]
00:37:56 <lambdabot>  [Nothing,Just "Hi"]
00:38:04 <Cale> > map fromDynamic [toDyn 1, toDyn "Hi"] :: [Maybe Integer]
00:38:04 <lambdabot>  [Just 1,Nothing]
00:38:06 <dmwit> ?index unsafeCoerce
00:38:07 <lambdabot> bzzt
00:38:07 <solrize> toDyn v = Dynamic (typeOf v) (unsafeCoerce v)
00:38:10 <quicksilver> solrize: but it's a strikingly useful simile :)
00:38:16 <solrize> hmm
00:38:32 <Cale> You're not meant to look at the implementation of toDyn ;)
00:38:40 <adu> lol
00:38:54 <Cale> In some sense, it's a primitive.
00:38:54 <solrize> the unsafecoerce is needed because you might have  (map toDyn xs)  where xs is polymorphic
00:39:01 <solrize> hm
00:39:19 <solrize> wow that's ugly
00:39:49 <solrize> i mean one notion of polymorphism is it guarantees you're not relying on properties of the monomorphic type
00:40:00 <Cale> No, if xs is polymorphic, it's not Typeable
00:40:01 <solrize> but then there's this reflection-like hack
00:40:24 <solrize> hmm
00:40:40 <adu> then it'd be Typeable1
00:41:06 <JoshTriplett> Cale: Actually, I just realized something: you said you can't define "instance Typeable a" because it overlaps with everything, but what stops you from making "instance Typeable (ST Foo)"?
00:41:12 <solrize> so why is the unsafecoerce there/
00:41:13 <Cale> adu: uh...
00:41:13 <solrize> ?
00:41:39 <JoshTriplett> Cale: And how would you define the "instance Typeable a" to begin with?
00:41:47 <Cale> solrize: Because you need to store values of different types in the data.
00:42:02 <Cale> solrize: You're throwing away the polymorphic parameter.
00:42:04 <solrize> yeah, why not a sum type?
00:42:07 <solrize> or a gadt even?
00:42:15 <Cale> That would be one huge sum type
00:42:23 <Cale> (it would be infinitely large)
00:42:25 <dmwit> solrize: How do you define such a sum type without knowing all the possible instances ahead of time?
00:42:39 <adu> lol
00:42:42 <solrize> hmm
00:42:43 <quicksilver> nonetheless, that is precisely what this models.
00:42:48 <quicksilver> it models an open sum type.
00:43:06 <quicksilver> as long as the Typeable instances cooperate, to make sure the tags are distinct.
00:43:14 <Cale> JoshTriplett: it hardly matters :)
00:43:19 <Cale> instance Typeable a where
00:43:19 <Cale>    typeOf _ = mkTyConApp (mkTyCon "Anything goes") []
00:43:34 <Cale> JoshTriplett: Of course, normally, that would be rejected :)
00:43:52 <Cale> and even with just ordinary overlapping instances, it'd never be used
00:44:11 <JoshTriplett> Cale: OK, so what stops you from doing this:
00:44:11 <JoshTriplett> instance Typeable (ST a) where
00:44:11 <JoshTriplett>     typeOf _ = mkTyConApp (mkTyCon "go nuts") []
00:44:15 <JoshTriplett> Cale: Er...
00:44:25 <JoshTriplett> s/ST a/ST SomeType/
00:44:43 <Cale> Oh, you could do that. You'll end up with a monomorphic 's' parameter
00:44:44 <solrize> data Dynamic a = Dynamic Int Int | Dynamic Float Float | Dynamic Func (Dynamic x) (Dynamic y)
00:44:50 <solrize> i don't knwo the syntax but something like that
00:44:52 <Cale> and then your STRefs will be unusable
00:45:12 <Cale> (because they absolutely must remain polymorphic in order to be used)
00:45:20 <JoshTriplett> Cale: I don't know the reason for that. :)
00:45:28 <JoshTriplett> Cale: Could you please elaborate?
00:45:30 <Cale> It's how the ST monad works :)
00:45:33 <Cale> :t runST
00:45:34 <lambdabot> forall a. (forall s. ST s a) -> a
00:45:47 <solrize> @hoogle Obj
00:45:47 <lambdabot> GHC.Dotnet.Object :: data Object a
00:45:47 <lambdabot> Distribution.Simple.Utils.objExtension :: String
00:45:47 <lambdabot> GHC.Dotnet.unmarshalObject :: Addr# -> Object a
00:45:55 <Cale> runST *insists* that the ST computation you pass it has a type which is polymorphic in s
00:46:05 <Cale> :t newSTRef
00:46:06 <lambdabot> Not in scope: `newSTRef'
00:46:12 <Cale> :t Data.STRefnewSTRef
00:46:13 <lambdabot> Couldn't find qualified module.
00:46:15 <Cale> :t Data.STRef.newSTRef
00:46:15 <JoshTriplett> :t runST
00:46:16 <lambdabot> forall a. (forall s. ST s a) -> a
00:46:16 <lambdabot> forall a s. a -> ST s (GHC.STRef.STRef s a)
00:46:24 <JoshTriplett> That got confusing...
00:46:25 <JoshTriplett> :t runST
00:46:26 <lambdabot> forall a. (forall s. ST s a) -> a
00:46:26 <solrize> @hoogle Any
00:46:27 <lambdabot> Data.Monoid.Any :: newtype Any
00:46:27 <lambdabot> Data.Monoid.Any :: Bool -> Any
00:46:27 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
00:46:27 <Cale> :t Data.STRef.writeSTRef
00:46:28 <lambdabot> forall s a. GHC.STRef.STRef s a -> a -> ST s ()
00:46:35 <solrize> @src Any
00:46:35 <lambdabot> Source not found. Where did you learn to type?
00:46:51 <Cale> So, you see, that s parameter is the same on the STRefs and on the computations that work with them.
00:46:54 <JoshTriplett> Cale: OK.
00:47:02 <JoshTriplett> Cale: So why can't you write this then:
00:47:05 <Cale> So if you have an STRef which is of type, say  STRef () Integer
00:47:11 <Cale> then you can never actually use it
00:47:30 <Cale> because if you tried to, say, read it, it would force your ST computation to be in the monad ST ()
00:47:39 <Cale> and then runST would refuse to run it.
00:47:49 <JoshTriplett> Cale: I see.
00:47:53 <Cale> (because it's not polymorphic)
00:48:07 <JoshTriplett> Cale: And you can't write "instance Typeable (ST a)" without qualifying a with a typeclass, right?
00:48:17 <JoshTriplett> Cale: And qualifying it would again make runST reject it.
00:48:39 <Cale> Er, you mean STRef s a ?
00:48:49 <dmwit> solrize: And when I later define data Foo = ..., and want instance Typeable Foo?
00:48:50 <JoshTriplett> Cale: Yeah, oops.
00:49:03 <dmwit> solrize: Your sum type can't really account for user-defined types...
00:49:08 <solrize> hmm
00:49:28 <ski> solrize : what do you mean by that `data Dynamic a = ...' ?
00:49:32 <solrize> there could be some TH hack to get the primitive-typed values out...
00:49:32 <bd_> Hm, it wouldn't hurt the semantics of ST if it was defined as data Typeable a => ST a = ..., would it?
00:49:52 <ski> @kind ST
00:49:53 <lambdabot> * -> * -> *
00:50:09 <ski> bd_ : you're missing one type parameter
00:50:10 <JoshTriplett> Cale: Or more broadly, what in general stops me from defining an instance of Typeable that uses the "go nuts" approach you suggested and results in letting you write unsafeCoerce?
00:50:25 <bd_> er, oops
00:50:27 <Cale> hmmm
00:50:32 <bd_> but, well, same idea
00:50:46 <JoshTriplett> Cale: Assuming you intentionally write a Typeable that doesn't follow the rules for defining an instance of Typeable.
00:50:54 <JoshTriplett> Cale: Namely providing a unique TypeRep.
00:51:04 <ski> bd_ : i think you then with the current system couldn't have `instance Monad (ST s)'
00:51:24 <ski> (same issue as with `instance Monad Set')
00:51:31 <dolio> instance Typeable (STRef s a) where typeOf _ = typeOf () -- GHC Approves
00:51:36 <bd_> you could do instance Typeable s => Monad (ST s) with proper extensions, couldn't you?
00:51:41 <JoshTriplett> :info IORef
00:51:51 <JoshTriplett> @kind IORef
00:51:52 <lambdabot> Not in scope: type constructor or class `IORef'
00:51:59 <JoshTriplett> Oh, right, lambdabot doesn't like IO.
00:52:15 <bd_> dolio: you can do that, but then cast can brean type safety (= crash possibility if you use cast unsafely)
00:52:17 <ski> bd_ : why would you want `Typable s =>' ?
00:52:21 <Cale> Hmm, this is interesting...
00:52:33 <JoshTriplett> Cale: What?
00:52:47 <dolio> bd_: Yeah, I know.
00:52:55 <bd_> ski: So you can cast STRefs to Dynamic... but on second thought, actually that would allow leakage
00:53:03 <ski> @kind Data.IORef.IORef
00:53:04 <lambdabot> * -> *
00:53:05 <Cale> It appears that I actually *can* put a leak in ST like that, but updates don't seem to take effect...
00:53:07 <ski> JoshTriplett :
00:53:10 <ski> ^
00:53:24 <JoshTriplett> :info Data.IORef.IORef
00:53:38 <ski> bd_ : why would you want to cast the `s' part (as opposed to the `a') part of `ST s a' ?
00:53:38 <JoshTriplett> @info Data.IORef.IORef
00:53:38 <lambdabot> Data.IORef.IORef
00:53:48 <ski> bd_ : s/ST/STRef/
00:54:04 <bd_> ski: I was trying to avoid creating a leak, but I think it's actually not possibly anyway
00:54:10 <bd_> possible*
00:54:16 <JoshTriplett> Cale: I assume by "create a leak in ST" you mean "write unsafePerformST"?
00:54:21 <bd_> since the whole point is you can't tell if two ST instances have the same 's' type
00:54:32 <JoshTriplett> Cale: Or similar?
00:55:12 <Cale> JoshTriplett: I mean swindling out a polymorphic STRef
00:55:24 <Cale> hmm
00:56:23 <Cale> oh, nice
00:56:32 <Cale> We can write unsafeCoerce like this.
00:56:40 <JoshTriplett> Cale: Yeah, I figured that.
00:57:08 <JoshTriplett> Cale: Mind pasting your definition?
00:57:32 <dolio> Nobody liked my safe but useless Typeable using type families? :)
00:57:42 <dolio> I guess it's a bit late.
00:57:53 <dons> dolio: i thought it was awesome
00:57:58 <Cale> instance Typeable (STRef s a) where
00:57:58 <Cale>     typeOf _ = mkTyConApp (mkTyCon "go nuts") []
00:57:58 <Cale> leak :: a -> STRef s b
00:57:58 <Cale> leak x = fromDyn (runST (fmap toDyn (newSTRef x))) undefined
00:57:58 <Cale> unsafeCoerce x = runST (readSTRef (leak x))
00:58:02 <dons> countering the oleg with a dashing gadt
00:58:09 <olsner> hmm, discovering more ways of writing unsafeCoerce doesn't actually sound good
00:58:27 <JoshTriplett> Cale: Good thing lambdabot doesn't allow you to write instance declarations. :)
00:58:38 <dons> for good reason..
00:58:47 <JoshTriplett> dons: Such as the above. :)
00:58:54 <Cale> JoshTriplett: You could do worse with bad instances of Ix
00:59:11 <Cale> Well, maybe not worse...
00:59:23 <dons> heh
00:59:29 <dons> there's worse than unsafe coerce?
00:59:51 <Cale> dons: Well, there's writing all over memory.
00:59:57 <Japsu> there's also unsafePerformIO
00:59:59 <dons> alwaysUnsafeCoerceAndInterleaveIOAndRandomllyLaunchMissles?
01:00:20 <dolio> dons: I don't think it actually works well enough at being Typeable to necessarily 'counter' oleg. :)
01:00:25 <bd_> dons: So, GHC on the DS9000? :)
01:00:35 <dons> ghc 6.12 has this primitive
01:01:01 <JoshTriplett> Cale: You could do that, or almost anything else, with unsafeCoerce.  Imagine unsafeCoerce :: ByteString -> (a -> b), assuming you know enough about GHC's internal data structures to construct the ByteString to pass...
01:01:06 <Cale> hmm, so it seems that Dynamic is fundamentally evil :)
01:01:15 <adu> dons: lolol
01:01:15 <JoshTriplett> Cale: "duh"?
01:01:24 <JoshTriplett> Cale: ;)
01:01:36 <dons> JoshTriplett: yeah, i wrote an obfuscated haskell winner based on this
01:01:39 <Cale> JoshTriplett: Well, you'd think there was a safe way to do that. :)
01:01:57 <dolio> Cale: You don't even need Dynamic. Just Typeable: http://okmij.org/ftp/Haskell/types.html#unsound-typeable
01:01:58 <lambdabot> Title: Haskell Programming: Types
01:01:59 <dons> its fun traversing heap structures with unsafeCoerce#
01:01:59 <JoshTriplett> Cale: So, in other words, you can already write unsafeCoerce using just a bad instance of Typeable, no -XIncoherentInstances needed.
01:02:11 <dons> just need to do your own dereferencing to have a ball
01:02:41 <JoshTriplett> dons: Fun!
01:02:47 <Cale> JoshTriplett: right
01:03:20 <JoshTriplett> Cale: So, in light of that, does that still make -XIncoherentInstances "dangerous"?
01:03:28 <JoshTriplett> Cale: Or just potentially confusing? :)
01:03:40 <Cale> That's a good question :)
01:03:49 <Cale> It's at the very least potentially confusing.
01:03:55 <JoshTriplett> Cale: I buy that. :)
01:04:02 <JoshTriplett> dolio: Thanks for that example.
01:04:35 <JoshTriplett> dons: I didn't even know an obfuscated haskell contest existed. :)
01:04:44 <Heffalump> incoherent instances aren't dangerous at runtime, I don't think
01:05:29 <JoshTriplett> Can incoherent instances cause the compiler to break, or just to notice a problem and complain?
01:05:51 <JoshTriplett> I noticed that GHC has a maximum recursion depth so it doesn't loop on undecidable instances.
01:05:52 <Cale> I think this is evidence enough that Typeable should not be a typeclass.
01:06:06 <Heffalump> I've managed to make ghc (6.9) stack overflow with dodgy code
01:06:13 <Heffalump> but I think that was a bug
01:06:27 <Heffalump> JoshTriplett: I think they can just cause it to pick something you weren't expecting
01:06:40 <JoshTriplett> Heffalump: Which seems bad enough.
01:06:54 <Heffalump> sure, but it can't cause a segfault
01:06:54 <JoshTriplett> Heffalump: I really just want an option to say "pick this one, ignore that one".
01:07:38 <JoshTriplett> Heffalump: Really, this entire problem would go away if I could "import Database.HDBC hiding (someinstance)".
01:08:13 <Heffalump> can't you just use a newtype wrapper?
01:08:17 <Heffalump> that's the usual thing to do
01:09:24 <JoshTriplett> Heffalump: Yes, sure.  I just didn't want all the callers to have to write Unary foo <- ... rather than foo <- ...
01:09:40 <JoshTriplett> Heffalump: http://hpaste.org/6682?lines=true for the context, BTW.
01:09:53 <elaforge> is there some clever way to efficiently diff functional data structures?
01:10:09 <elaforge> like a Map that kept checksums in its nodes or something?
01:10:58 <JoshTriplett> elaforge: You could theoretically make a diff more efficient by checking for object equality before checking for actual equality.
01:11:18 <elaforge> well, except pointer comparison isn't functional
01:11:31 <Heffalump> you could enumerate the basic types in your SqlTypes a instance
01:11:32 <piojo> i don't know whether this contains the cleverness you seek, but Set and Map have a "difference" function. i don't know what you would do besides compare their elements...
01:11:47 <Heffalump> I think overlapping instances always picks the most specific, anyway, so that should be enough, shouldn't it?
01:12:12 <Heffalump> (by enumerate the basic types I mean copy out the instance once per type)
01:12:23 * Heffalump has to go
01:12:24 <quicksilver> Cale: meaning, Typeable should be a compiler primitive rather than a typeclass?
01:12:30 <Cale> quicksilver: yeah
01:12:42 <quicksilver> Cale: yes, I think that's obviously better, but this way was much easier :)
01:12:49 <Cale> Of course.
01:12:53 <elaforge> piojo, oh right, that's true, but the docs say it's linear with the size of the maps, not with the size of the diff
01:13:16 <quicksilver> Cale: and it was an interesting exercise in what you can do without actually adding type reps to the compiler.
01:13:23 <elaforge> I'd think theoretically if I had a checksum in each node I could get down to log n -ish?
01:13:32 <quicksilver> (although arguably it's cheating since in practice we use deriving Typeable which *is* in the compiler)
01:14:07 <JoshTriplett> quicksilver: Right.  The whole problem goes away if you proscribe "instance Typeable ...".
01:14:19 <JoshTriplett> quicksilver: In favor of "deriving Typeable".
01:14:57 <Cale> Yeah, I was just thinking that as well. We could just disallow explicit definition of instances of Typeable
01:15:58 <piojo> elaforge: if you can hash the data, it would seem like you could get it down to max(log(elements), diff size), if you stored the checksums hierarchically (with a top level for all the data in the whole DS)
01:16:41 <JoshTriplett> @pl \(x,y) -> (x,2*y)
01:16:41 <lambdabot> second (2 *)
01:16:49 <JoshTriplett> Ah, good, pl knows about first and second.
01:16:54 <JoshTriplett> @pl \(x,y) -> (2*x,3*y)
01:16:55 <lambdabot> (2 *) *** (3 *)
01:16:57 <Cale> http://www.boasas.com/?c=935
01:16:58 <elaforge> piojo, I also do lots of in order traversal, hence the interest in a tree or heap
01:16:58 <lambdabot> Title: Boy on a Stick and Slither
01:17:22 <elaforge> sounds like I'd be rolling my own though...
01:17:46 <JoshTriplett> @pl \(x,y) -> (2*y,3*x)
01:17:46 <lambdabot> uncurry (flip ((,) . (2 *)) . (3 *))
01:18:12 <JoshTriplett> @unpl uncurry (flip ((,) . (2 *)) . (3 *))
01:18:12 <lambdabot> uncurry (\ h c -> ((,)) (2 * c) (3 * h))
01:18:42 <JoshTriplett> Heh.  unpl could use a bit of work there. :)
01:19:24 <JoshTriplett> But still impressive.
01:19:37 <JoshTriplett> (\(x,y) -> (2*y,3*x)) (10, 20)
01:19:41 <JoshTriplett> > (\(x,y) -> (2*y,3*x)) (10, 20)
01:19:41 <lambdabot>  (40,30)
01:19:59 <piojo> elaforge: i really don't know. your idea reminds me of skip lists and quad-trees, though (where each node also includes a hash that describes all the elements below it). perhaps these ideas could be integrated into a DS you like, but it would likely be a lot of work
01:20:01 <JoshTriplett> > ((2*) *** (3*)) (10, 20)
01:20:02 <lambdabot>  (20,60)
01:20:20 <JoshTriplett> > ((2*) `flip (***)` (3*)) (10, 20)
01:20:20 <lambdabot>  Parse error at "(***)..." (column 13)
01:20:28 <JoshTriplett> :t (***)
01:20:29 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
01:20:35 <elaforge> piojo, yeah, it's beginning to smell like a rat hole.  ok thanks!
01:20:45 <JoshTriplett> > flip (***)
01:20:46 <lambdabot>  Add a type signature
01:20:48 <elaforge> night everyone
01:20:50 <JoshTriplett> :t flip (***)
01:20:51 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b' c' -> a b c -> a (b, b') (c, c')
01:21:10 <dmwit> > (flip (***) (2*) (3*)) (10, 20)
01:21:11 <lambdabot>  (30,40)
01:21:25 <dmwit> Back-ticks don't take complex expressions, only identifiers.
01:21:31 <JoshTriplett> dmwit: Ah.
01:21:33 <dmwit> This is to prevent nesting issues.
01:21:50 <JoshTriplett> dmwit: Clearly Haskell needs $(). :)
01:22:11 <dmwit> Yes, people have proposed `( )` kinds of things. =)
01:22:39 <JoshTriplett> > uncurry . flip (,)
01:22:39 <lambdabot>  Couldn't match expected type `b -> c'
01:22:45 <JoshTriplett> > uncurry $ flip (,)
01:22:46 <lambdabot>  Add a type signature
01:22:49 <JoshTriplett> :t uncurry $ flip (,)
01:22:50 <lambdabot> forall a b. (a, b) -> (b, a)
01:23:04 <JoshTriplett> (uncurry $ flip (,)) (1,2)
01:23:06 <JoshTriplett> > (uncurry $ flip (,)) (1,2)
01:23:06 <lambdabot>  (2,1)
01:23:55 <JoshTriplett> > ((uncurry $ flip (,)) . (flip (***) (2*) (3*)))(1,2)
01:23:56 <lambdabot>  (4,3)
01:24:27 <JoshTriplett> > (\(x,y) -> (2*y,3*x)(1,2)
01:24:27 <lambdabot> Unbalanced parentheses
01:24:30 <JoshTriplett> > (\(x,y) -> (2*y,3*x))(1,2)
01:24:31 <lambdabot>  (4,3)
01:24:47 <dmwit> > uncurry (flip (,)) . (3*) *** (2*) $ (1, 2)
01:24:47 <lambdabot>   add an instance declaration for (Num (a, b))
01:24:55 <dmwit> > (uncurry (flip (,)) . (3*) *** (2*)) (1, 2)
01:24:55 <lambdabot>   add an instance declaration for (Num (a, b))
01:25:01 <dmwit> um
01:25:44 <JoshTriplett> > (uncurry (flip (,)) . ((3*) *** (2*))) (1, 2)
01:25:45 <lambdabot>  (4,3)
01:25:59 <JoshTriplett> dmwit: *** and . don't have the precedence you apparently expected.
01:26:11 <JoshTriplett> dmwit: Or *** didn't anyway.
01:26:14 <dmwit> > uncurry (flip (,)) . ((3*) *** (2*)) $ (1, 2) -- yes, apparently
01:26:14 <lambdabot>  (4,3)
01:26:37 <dmwit> I guess I actually can see reasons for either precedence order.
01:27:54 <JoshTriplett> dmwit: I almost always parenthesize expressions used as operands.
01:28:05 <JoshTriplett> dmwit: Including function calls.
01:28:29 <JoshTriplett> dmwit: With the exception of the right operand to $, since I treat $ as "giant left parenthesis".
01:28:44 <JoshTriplett> dmwit: But other than that I just don't make any assumptions about precedence at all.
01:29:36 <dmwit> Yeah, that's a pretty good thing for readability in many cases.
01:30:52 <JoshTriplett> > runST (do modify (*2)) 10
01:30:52 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `()'
01:31:12 <JoshTriplett> :t runST
01:31:13 <lambdabot> forall a. (forall s. ST s a) -> a
01:31:21 <JoshTriplett> :t evalST
01:31:21 <lambdabot> Not in scope: `evalST'
01:31:31 <quicksilver> JoshTriplett: modify is a method of State not ST.
01:31:40 <JoshTriplett> quicksilver: Oops, thanks.
01:31:52 <JoshTriplett> > runState (do modify (*2)) 10
01:31:53 <lambdabot>  ((),20)
01:32:08 <JoshTriplett> :t runState
01:32:10 <lambdabot> forall s a. State s a -> s -> (a, s)
01:34:06 <JoshTriplett> dons: Other than Typeable, what instances make it dangerous for lambdabot to permit instance declarations?
01:38:15 <dmwit> > runState (modify (*2)) 10 -- do is nilpotent for one-line blocks
01:38:16 <lambdabot>  ((),20)
01:38:55 <JoshTriplett> dmwit: I started out with a multi-line block and ended up deleting all but one line; forgot the do. :)
01:39:24 <dmwit> heh =)
01:40:03 <ski> `nilpotent' ?
01:40:31 <dmwit> Has no effect... I think.
01:40:55 <dmwit> Ah, nope, wrong word.
01:41:00 <Twey> Opposite of 'omnipotent'
01:41:01 <Twey> :-)
01:41:23 <Twey> Omnipotent = can do anything
01:41:29 <Twey> Nilpotent = can't do anything
01:41:56 <vegai> omnimpotent?
01:42:32 <Twey> Haha
01:42:35 <ski> for rings, `nilpotent x' means `exists n. x^n = 0'
01:42:55 <dmwit> right, I just meant identity
01:42:59 <ski> (there's also a `nilpotent' for groups, but somehow i don't think that's what you meant, either)
01:43:05 <dmwit> That's what I get for trying to sound smart. =P
01:43:54 <Twey> I think 'superfluous' would have served you better in that regard :-)
01:45:43 <quicksilver> do is also idempotent
01:45:50 <quicksilver> > do do do "be do"
01:45:51 <lambdabot>  "be do"
01:46:51 <Twey> Hahaha
01:51:56 <Baughn> > do do do [2]
01:51:57 <lambdabot>  [2]
02:05:09 <olsner> hmm, I wonder what the minimum set of stack primitives is that can be combined to perform any stack shuffling operation
02:07:09 <JoshTriplett> olsner: Define "stack shuffling operation".  Given a stack [a], you want to produce another stack [a] with arbitrarily reordered elements?
02:07:35 <olsner> yeah, like that
02:08:18 <JoshTriplett> olsner: You'll also need some criteria for "minimum", since I can easily define several single primitives that will work but not necessarily look minimalistic.
02:08:37 <ivanm> assuming you mean a standard CS stack where you pop, push and peek... you'd need some other kind of storage item to do the actual shuffling, would you not?
02:09:19 <JoshTriplett> olsner: pick :: Integer -> [a] -> [a] would work by itself, for instance.
02:09:34 <JoshTriplett> olsner: Where pick 4 [1,2,3,4,5,6,7] = [4,1,2,3,5,6,7]
02:10:07 <ivanm> JoshTriplett: yes, but you can't do that in a stack, can you?
02:10:08 <olsner> well, it is the same problem as finding the minimal instruction set for a computer, so it's very open-ended and has many answers ;-)
02:10:22 <JoshTriplett> ivanm: Depends on your primitives. :)
02:10:53 <ivanm> JoshTriplett: last I heard, you can only access the elements in a stack via the top item
02:10:54 <JoshTriplett> ivanm: If you take a strict definition of "stack" that only allows push and pop, then unless you have auxiliary storage you can't arbitrarily reorder.
02:10:58 <ivanm> i.e. push, pop and peek
02:11:04 <olsner> ivanm: the idea is to find some other set of {pop,push,peek} that is can do anything, for some definition of anything
02:11:05 <ivanm> JoshTriplett: that was my point
02:12:05 <JoshTriplett> olsner: If I can assume one element of auxiliary storage to hold the result of pop or a data item to feed to push, then you don't need peek.
02:12:25 <JoshTriplett> olsner: Or do you want pop to not return the item?
02:12:50 <olsner> well, I was thinking about stack in the context of a stack-based virtual machine
02:12:53 <ivanm> JoshTriplett: IIRC, you normally have it not return the value of the last item in functional implementations...
02:13:28 <JoshTriplett> olsner: Ah.  So, for instance, you might want to know what minimum instruction set you need?
02:14:22 <ivanm> olsner: I'd think a swap function... swap the top two elements or something
02:14:27 <olsner> yeah, I want some small set of beautiful primitives that still allows me to express any kind of shuffling I might need
02:14:37 <ivanm> so with two stacks, that might be enough
02:14:56 <olsner> yes, but that requires two stacks
02:15:09 <olsner> otherwise you could only shuffle to a maximum depth of 2
02:15:17 <ivanm> so you want no external storage area?
02:15:24 <ivanm> i.e. not a stack? :p
02:15:54 <ivanm> you just have some generic ordered data structure that you want to shuffle the contents of?
02:16:13 <JoshTriplett> olsner: OK.  So you want a machine with one stack, no external storage, and a set of elegant stack operations, and you want Turing completeness?
02:16:32 <JoshTriplett> olsner: Or you just want the ability to shuffle the stack arbitrarily?
02:16:34 <olsner> ah, sounds about right ;-)
02:20:12 <JoshTriplett> olsner: In the absence of external storage, unless you can have random access to the stack or some kind of "roll the entire stack" operation, you can't turn that into a Turing-complete machine.
02:20:56 <JoshTriplett> olsner: http://en.wikipedia.org/wiki/Computability_theory_%28computer_science%29#Power_of_pushdown_automata
02:20:57 <lambdabot> http://tinyurl.com/yuqr6n
02:21:33 <olsner> you can probably get by with a SET primitive that takes an index and a data item and replaces the item n items from the top, and a GET primitive that takes an index and copies it to the top of the stack
02:21:33 <olsner> if those take their operands from the stack rather than the instruction stream, you'd probably also want a PUSH <constant> instruction
02:22:54 <Svrog> olsner: have you by any chance looked at the concatenative language message board? they discuss things like that every once in a while although more in the context of joy and joy-like languages
02:23:45 <olsner> Svrog: didn't even know it existed :P link?
02:24:06 <Svrog> http://tech.groups.yahoo.com/group/concatenative/
02:24:07 <lambdabot> Title: concatenative : Discuss the concatenative variety of computer languages: Joy, Fo ...
02:39:02 <Svrog> olsner: http://tunes.org/~iepos/joy.html
02:39:04 <lambdabot> Title: The Theory of Concatenative Combinators
02:39:53 <ertai> does someone know where find the funny poster about haskell being 100% pure (with a big logo (:=))
02:40:27 <olsner> ooh, nice! Svrog++
02:43:33 <steven_ashley> has anyone managed to get haskelldb to compile on ghc 6.8.2?
02:43:55 <solrize_> i thought that one-stack machines could recognize context-free languages but not unrestricted languages.  therefore, not turing complete.
02:44:29 <steven_ashley> the cabal file had some deps missing, ive added those and also 'PatternSignatures' but now im getting 'type variables not in scope' errors :(
02:45:11 <olsner> solrize_: not without extending the machine, no
02:46:42 <solrize_> http://reddit.com/r/programming/info/6di0y/comments/
02:47:43 <solrize_> m4dc4p 6 points 1 day ago * [-]
02:47:43 <solrize_> I have to pick strong typing. When I make a type opaque, it's opaque. No reflection BS allows me to get inside and screw with it. Beautiful.
02:47:43 <solrize_> permalink
02:47:46 <solrize_> haha
02:59:41 <DRMacIver> Hm. The dependencies in whatever version of hackage cabal install is using are a bit messed up.
02:59:56 <DRMacIver> (It doesn't seem to correspond to the website version either)
03:29:42 <mcnster> any ppl familiar with gtk2hs awake?
03:30:00 <quicksilver> sure dcoutts_ never sleeps :P
03:31:02 <ivanm> quicksilver: but he sometimes works
03:31:05 <ivanm> @localtime dc-Ankan
03:31:07 <lambdabot> Local time for dc-Ankan is Fri Mar 28 11:31:56 2008
03:31:08 <ivanm> whoops
03:31:13 <ivanm> @localtime dcoutts_
03:31:13 <lambdabot> Local time for dcoutts_ is Fri Mar 28 10:31:12
03:31:22 <ivanm> @seen dcoutts_
03:31:22 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts_ speak 11h 25m 34s ago.
03:32:13 <mcnster> i'm trying to make "a <- objectCreateAttribute (toGObject o)" and i'm getting a type error
03:35:07 <hpaste>  (anonymous) pasted "miodowe" at http://hpaste.org/6685
03:35:14 <u_quark> has anyone used XSLT with the HXT package ? (or in general XSLT with haskell ?)
03:36:14 <earthy> u_quark: HAppS does XSLT, IIRC
03:36:31 <earthy> http://code.google.com/p/happs/wiki/WhyXslt
03:36:31 <lambdabot> Title: WhyXslt - happs - Google Code
03:36:48 <earthy> (yes, those docs suck)
03:37:20 <quicksilver> mcnster: "a type error" doesn't tell me much...
03:39:01 <u_quark> yes but with xsltproc or something...
03:39:07 <u_quark> not pure haskell :P
03:43:58 <kryptos23> Hi... does the GHC compiler not support primMinInt,primMaxInt?
03:45:00 <quicksilver> :t primMinInt
03:45:05 <lambdabot> Not in scope: `primMinInt'
03:45:07 <quicksilver> @hoogle primMinInt
03:45:07 <lambdabot> No matches found
03:45:15 <quicksilver> kryptos23: I am not familiar with those names.
03:45:26 <quicksilver> kryptos23: where do they come from?
03:45:51 <kryptos23> quicksilver > i have just started out with haskell road to math,login and prog... its been used in that book
03:46:01 <quicksilver> sounds like they're some obsolete hugs thing.
03:46:06 <quicksilver> > (minBound :: Int)
03:46:08 <lambdabot>  -2147483648
03:46:13 <quicksilver> would be the modern equivalent
03:46:35 <kryptos23> i see. is there so much of a difference between the 2 compilers?
03:46:51 <quicksilver> they both support a common standard
03:46:59 <quicksilver> (primMinInt is not part of that standard)
03:47:11 <quicksilver> they also both support some extensions.
03:47:17 <quicksilver> GHC many many more than hugs.
03:47:29 <kryptos23> hmm... thnx quicksilver
03:51:36 <MaSSaSLaYeR> morning
04:21:57 * wli realizes it might take a while to take 50 . map (fst . head) . groupBy ((==) `on` (floor . snd :: (Integer, Rational) -> Integer)) $ iterate (\(n, x) -> let n' = n + 1 in (n', x + recip (fromInteger n') :: Rational)) (1, 1)
04:29:45 <wli> There must surely be a more efficient algorithm.
04:33:24 <byorgey> > exp 50
04:33:25 <lambdabot>  5.184705528587072e21
04:33:25 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
04:33:33 <byorgey> yeah, that would take a while =)
05:03:03 <EvilTerran> morning folks
05:03:30 <ivanm> evening EvilTerran
05:09:59 <dozer> is thre a preferred librafry for talking to relational databases from haskell?
05:11:32 <quicksilver> I'm sure various people prefer various ones.
05:11:44 <dozer> oops -wrong irc server :)
05:11:47 <quicksilver> I think HDBC might be the "simplest" FSOV simplest.
05:13:18 <tcr> Could it be that lookupBy was a late addition to List?
05:14:34 <quicksilver> :t lookupBy
05:14:36 <lambdabot> Not in scope: `lookupBy'
05:15:07 <quicksilver> tcr: I think it was one of those mysterious functions which was in haskell 1.3 but not in haskell98 for unknown reasons.
05:53:09 <dancor> (_,_,_,pid) <- runInteractiveProcess "find" [somedir]; waitForProcess pid
05:53:18 <dancor> that hangs even on not-very-big dirs
05:53:28 <dancor> i guess some output buffer is filling up?
05:53:37 <mauke> yes
05:53:44 <dancor> what is the right way to do it
05:54:03 <dancor> i do want the output.  i had been doing o <- hGetContents out, after the wait
05:54:19 <mauke> write a C function that forks, redirects io channels and execs
05:54:35 <dancor> really?
05:54:51 <quicksilver> a simpler solution is just not to waitForProcess
05:54:57 <quicksilver> just hGetContents out
05:55:06 <quicksilver> and you will block, if necessary, until the find gets going
05:55:30 <dancor> hmhm though things get ugly if you actually want to check for ExitFailure
05:55:40 <quicksilver> yes, that's true.
05:55:52 <quicksilver> you have to shovel output into a buffer somewhere
05:55:59 <quicksilver> if you want to check for exitfailure before processing it
05:56:27 <quicksilver> (if you don't shovel the output, the "find" will get suspended when the buffer fills)
05:56:33 <quicksilver> that's the "lazy IO of unix pipes)
05:56:53 <quicksilver> unix pipes do a kind of lazy IO which is implemented by limited size buffers and process suspension
05:57:12 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Process.html#v%3AforkProcess
05:57:15 <lambdabot> http://tinyurl.com/obhpz
05:57:21 <dancor> quicksilver: how can i shovel it, just doing hGetContents out first doesn't cut it
05:58:03 <quicksilver> no, because hGetContents is BROKEN, DANGEROUSE and KILLS BABIES
05:58:14 <dancor> quicksilver: but what isn't broken
05:58:21 <quicksilver> use something strict, like hGetContents from strict bytestring
05:58:32 <quicksilver> which has the advantage of not taking up loads of space with a big String :)
06:00:06 <dancor> loldoc:  foldl' is like foldl, but strict in the accumulator. Though actually foldl is also strict in the accumulator.
06:00:24 <dancor> i really feel like i understand the function now
06:00:47 <wolverian> um, so they're different, except they're not?
06:00:55 <quicksilver> foldl' stops runaway thunks in the accumulator
06:00:59 <dafra> foldl is strict  too ? what's the point of foldl' then ?
06:01:14 <wolverian> @src foldl'
06:01:14 <lambdabot> foldl' f a []     = a
06:01:14 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
06:01:21 <mauke> > foldl (flip const) undefined [1,2,3]
06:01:22 <lambdabot>  3
06:01:23 <dancor> i guess it is a backwards compability thing
06:01:30 <wolverian> @src foldl
06:01:30 <lambdabot> foldl f z []     = z
06:01:30 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
06:01:34 <dancor> i'm looking at http://haskell.org/ghc/docs/latest/html/libraries/bytestring/src/Data-ByteString.html#foldl'
06:01:35 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/3beq8y
06:01:39 <mauke> doesn't look strict to me
06:01:40 <wolverian> um, that's not strict
06:02:12 <dancor> i guess it's just to copy all the funcs
06:03:34 <quicksilver> whether or not foldl is strict in the accumulator depends if 'f' is strict in its left parameter.
06:03:41 <quicksilver> as mauke's example showed rather clearly
06:04:07 <quicksilver> > foldl' (flip const) undefined [1,2,3]
06:04:08 <lambdabot>  3
06:04:10 <mauke> my example was Data.List.foldl
06:04:13 <quicksilver> quite
06:04:22 <quicksilver> it's true for foldl' and fold
06:04:25 <quicksilver> both versions
06:04:35 <quicksilver> the difference between them isn't precisely strictness in the accumulator
06:05:14 <Saizan> we could say it as "foldl' is strict in the partial results" ?
06:05:44 <quicksilver> something like that, perhaps.
06:05:56 <quicksilver> but it's only strict in the result of 'f'
06:05:59 <opqdonut> "foldl' doesn't construct huge chunks"
06:06:01 <quicksilver> never in the parameters to 'f'
06:06:04 <quicksilver> that's up to f
06:06:10 <quicksilver> (whether f is strict in its own parameters)
06:06:55 <Saizan> except that those are not disjoint sets
06:07:39 <wolverian> can you write foldl' with bang patterns?
06:08:00 <Saizan> sure
06:08:45 <Saizan> foldl' f a (x:xs) = let !a' = f a x in foldl' f a' xs
06:08:54 <wolverian> yes, I just realised that :)
06:08:55 <wolverian> thanks
06:09:27 <opqdonut> well bang patterns + let are equivalent with seq :)
06:09:28 <wolverian> I kind of want to write foldl' !(f a x) xs there..
06:09:34 <opqdonut> yeah
06:09:44 <Saizan> foldl' f !a (x:xs) = foldl' f a' xs -- this is stricter
06:10:02 <wolverian> Saizan, yeah, I was initially thinking of that and confusing myself.
06:11:46 <opqdonut> Saizan: yeah, that forces the initial value
06:11:50 <opqdonut> and foldl' doesn't
06:12:07 <opqdonut> (as quicksilver's flip const -example shows)
06:12:42 <wolverian> hm, is visual haskell dead?
06:12:50 <Zao> A bit stale.
06:13:01 <Twey> What's a bang pattern?
06:13:05 <Zao> wolverian: There's some ancient source out, so you could always try porting it.
06:13:08 <wolverian> Twey, http://www.haskell.org/ghc/docs/latest/html/users_guide/bang-patterns.html
06:13:10 <lambdabot> Title: 8.10. Bang patterns, http://tinyurl.com/2orsdy
06:13:10 <Twey> o.@
06:13:16 <wolverian> Zao, I'm not that interested. :)
06:13:18 <Twey> wolverian: Thanks
06:16:08 <dcoutts_> DRMacIver: hmm? you were saying something about hackage/cabal-install dependencies?
06:17:28 <DRMacIver> dcoutts_: Currently network-minihttp refers to tagsoup 0.5 when the latest version in hackage is 0.4, and it doesn't build against the version of ByteString it claims to require.
06:18:21 <dcoutts_> DRMacIver: aye, there's no enforcement at the moment to make sure that dependencies are actually on hackage, we have to rely on maintainers
06:18:28 <DRMacIver> ok
06:18:33 <DRMacIver> I assumed it was something like that.
06:18:38 <dcoutts_> one day...
06:18:46 <DRMacIver> It wasn't intended as a critique of cabal, just "hm, that's a bit broken" :)
06:19:04 <dcoutts_> DRMacIver: the solution is to ping the maintainer
06:19:15 <dcoutts_> well, the short term solution anyway
06:19:25 <dcoutts_> the long term solution is to help us hack on hackage
06:19:35 <dcoutts_> to do QA enforcement :-)
06:22:06 <DRMacIver> Applying the longer term solution unfortunately has a hard dependency on my "stop sucking at Haskell" plan, which I seem to have trouble getting around to.
06:22:27 <dcoutts_> :-)
06:22:31 <dancor> maybe you can solve them simultaneously
06:24:46 <DRMacIver> I think that's a losing plan. :)
06:25:11 <DRMacIver> I wouldn't want to work on tool support without a better grasp of how to actually develop applications in the language.
06:29:06 * dancor tries to decide if there is a simple kwlr way to split a ByteString at every '\0' than converting to String
06:30:40 <dancor> indeed, split.
06:30:59 <quicksilver> how could converting to string help?
06:31:21 <dancor> quicksilver: i have written the func for [a] already before
06:31:25 <quicksilver> oh, I see
06:31:26 * quicksilver nods
06:31:42 <quicksilver> @hoogle Data.ByteString.split
06:31:43 <lambdabot> No matches, try a more general search
06:31:48 <quicksilver> :t Data.ByteString.split
06:31:51 <lambdabot> Word8 -> BSC.ByteString -> [BSC.ByteString]
06:31:59 <quicksilver> :t Data.ByteString.split 0
06:32:00 <lambdabot> BSC.ByteString -> [BSC.ByteString]
06:32:08 <quicksilver> that's probably what you need
06:32:19 <dancor> oh cool i didn't know 0 would cast to Word8
06:32:26 <quicksilver> 0 is a generic Num
06:32:31 <quicksilver> Word8 is an instance of Num
06:33:37 <MyCatVerbs> Also Bits. ^_^
06:41:25 <matthew_-> how do you make a recursive function polymorphic
06:41:26 <matthew_-> ?
06:41:34 <quicksilver> hmm
06:41:46 <quicksilver> how do you *not* make a recursive function polymorphic?
06:41:46 <matthew_-> like, f :: a -> b where b can vary in different cases
06:42:01 <quicksilver> blink matthew_-
06:42:08 <quicksilver> what kind of polymorphism is that?
06:42:13 <matthew_-> scary?
06:42:16 <quicksilver> (and what does it have to with recursion)
06:42:22 <matthew_-> f calls itself
06:42:26 <matthew_-> but yes, I see your point
06:42:46 <matthew_-> grr, this is going to have to be a type class then.
06:42:59 <quicksilver> well that's how we managed polymorphism in haskell, isn't it?
06:43:21 <matthew_-> heterogeneous lists are a pita at times
06:43:28 <matthew_-> you can't write natural recursive functions on them
06:44:05 <quicksilver> that's because they aren't (natural) recursive types, right?
06:44:23 <matthew_-> indeed
06:44:24 <quicksilver> depending to a large extent what you think 'natural' means.
06:44:33 <matthew_-> indeed
06:44:36 <quicksilver> but recursive functions and recursive types are closely linked.
06:45:27 <matthew_-> actually, what I'm doing here is trying to write a function which is actually dependently typed
06:45:36 <matthew_-> so it's hardly surprising it's not working out for me
06:47:26 <quicksilver> you can do some symbol encodings of dependent types
06:47:43 <quicksilver> for example, can you recast f :: a -> b as f :: a -> t a
06:47:57 <ask42> Hello! I'd like to do something like "x <- (\_ -> myMonadicFunc) (replicate myInt 1)", that is, call a monadic function "myInt" times and collect the results in a list. The code looks too complicated for this simple task but I haven't found a more clever function in the prelude. Has anybody a hint how to do it more elegant?
06:47:58 <quicksilver> if you can 'hide the dependency' in a real typeconstructor 't'
06:48:10 <quicksilver> ask42: replicateM
06:49:06 <ask42> quicksilver: Thanks, I must have been blind! This is exactly what I need.
06:49:08 <quicksilver> :)
06:49:10 <Peaker> @src replicateM
06:49:10 <lambdabot> replicateM n x = sequence (replicate n x)
06:49:18 <quicksilver> well it's not in the prelude, I don't think
06:49:23 <quicksilver> it's in Control.Monad?
06:49:26 <quicksilver> @index replicateM
06:49:26 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
06:49:36 <quicksilver> which might be how you missed it.
06:52:09 <dino-> :t replicateM
06:52:10 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
06:54:40 <Peaker> why are things defined in the stdlib in more than 1 module?
06:55:08 <byorgey> Peaker: they're not, it's just that sometimes they're imported and re-exported from multiple modules.
06:55:21 <Peaker> byorgey, why do they get re-exported?
06:55:28 <byorgey> for convenience, I guess
06:55:48 <byorgey> i.e. if you want Control.Monad.Reader, chances are you'll want a bunch of stuff from Control.Monad too, so Reader re-exports it
06:56:38 <byorgey> and if you then imported Control.Monad too, you won't get any conflicts or anything, so it doesn't lead to any problems
06:57:01 <Peaker> what if you use the multiply-exported symbol? Doesn't it yell at you that its ambiguous?
06:57:13 <kosmikus> it's not ambiguous
06:57:19 <byorgey> no, I think it's smart enough to realize that it actually isn't ambiguous.
06:57:30 <kosmikus> each symbol is identified by the module it's defined in
06:57:44 <kosmikus> so if you import an entity via multiple paths, that's ok
06:57:56 <quicksilver> although occasionally that leads to annoying error messages
06:58:08 <quicksilver> just because the place the user thinks the symbol lives isn't where it *really* lives
06:58:17 <kosmikus> quicksilver: like the package version conflict we had yesterday?
06:58:20 <Peaker> I remember getting weird errors for multiply defines stuff
06:58:21 <quicksilver> (Data.ByteString.Internal.ByteString for example)
06:58:24 <Peaker> (that I did not define)
06:58:30 <quicksilver> Peaker: yes, but this *isn't* multiply defined.
06:58:37 <quicksilver> Peaker: the compiler knows they are really the same definition.
06:58:56 <quicksilver> it's different if you import Data.Foldable and the Prelude, say, because those are actually different symbols with the same name.
06:59:32 <kosmikus> the compiler usually gives the entity name in error messages, i.e. the module something is actually defined in
06:59:36 <Peaker> I see.. It could be cool to have a Python-like module system
06:59:39 <kosmikus> that can be confusing because it's not the module you have imported
06:59:42 <quicksilver> kosmikus: yes, which is annoying. a little bit.
06:59:49 <quicksilver> Peaker: python-like in what way?
07:00:09 <kosmikus> but it's correct in the sense that if you know it behaves that way, it actually tells you what the entity is
07:00:20 <Peaker> quicksilver, Discourage "import *", make the simple syntax import qualified
07:00:25 <kosmikus> and where you have to look for it
07:00:42 * quicksilver shrugs
07:00:48 <quicksilver> trivial syntax change doesn't seem very important :)
07:01:03 <quicksilver> certainly I wouldn't want to import everything qualified, that makes everything look ugly.
07:01:24 <kosmikus> no, I think it's far more valuable to be able to specify type signatures in import and export lists
07:01:38 <ertai> > 1 + 2 :: Expr
07:01:42 <lambdabot>  1 + 2
07:02:17 <ertai> > 1 + (\x -> x) 2 :: Expr
07:02:18 <lambdabot>  1 + 2
07:02:24 <kosmikus> ertai: what's Expr?
07:02:25 <Saizan> kosmikus: what do you mean?
07:02:33 <pjd> lambdabot: where expr
07:02:43 <pjd> lambdabot: expr?
07:02:46 <ivanm> @where expr
07:02:47 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
07:02:50 <Saizan> ?where expr
07:02:50 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
07:02:52 <pjd> d'oh
07:02:55 <kosmikus> Saizan: it'd be nice if you could document the interface you're exporting in the export list, and similarly document the interface you expect in the import list.
07:03:31 <kosmikus> Saizan: would also make it easier to spot errors when library versions change.
07:03:37 <pjd> >> foldr f x [1..5] :: Expr
07:03:37 <kosmikus> optional, of course
07:03:42 <pjd> > foldr f x [1..5] :: Expr
07:03:42 <lambdabot>  f 1 (f 2 (f 3 (f 4 (f 5 x))))
07:04:00 <Peaker> quicksilver, remove the "module X where" -- "file is module" is a nice relationship
07:04:24 <Peaker> quicksilver, ugly? why is Monad.blah ugly?
07:04:33 <quicksilver> it's visual noise
07:04:45 <ertai> Is there some kind of released implementation of these Expr reflection things?
07:04:48 <kosmikus> re Expr: cool. somehow I remember though that I've seen this before, a few years ago. don't remember where ...
07:04:49 <Peaker> quicksilver, The thing is - once people build their code to be imported unqualified - they repeat the namespace information in each name, so you get Monad.doMonadStuff instead of Monad.doStuff
07:04:57 <Saizan> kosmikus: it'd require editor support, it's already a pain to keep import lists updated if you explicitly import every symbol like in cabal
07:05:05 <quicksilver> Peaker: sometimes you do, often you don't.
07:05:25 <quicksilver> Peaker: it makes perfect sense for certain modules to be designed to be imported qualified.
07:05:33 <quicksilver> Peaker: ByteString is, for example.
07:05:38 <Peaker> quicksilver, if you build your names under the assumption that they will be used qualified - then you can use much shorter names, so eventually you get the nice without the bad
07:05:42 <quicksilver> Peaker: but it makes sense for other modules not to.
07:05:51 <quicksilver> like Control.Monad and Data.List
07:05:53 <Peaker> quicksilver, when does it not make sense?
07:05:55 <quicksilver> I really don't want to have to write
07:06:02 <quicksilver> Monad.replicateM and List.find
07:06:17 <mauke> import qualified Control.Monad as M
07:06:21 <mauke> M.replicate
07:06:26 <Peaker> import Moand as M ; M.replicate  is basically the same as replicateM, except you know where its coming from
07:06:33 <quicksilver> true.
07:06:39 <Peaker> which is a real advantage
07:06:46 <quicksilver> possibly not a great example.
07:06:54 <quicksilver> I do find the . to be very ugly, too.
07:06:57 <Saizan> i think Data.List is a good example
07:07:00 <quicksilver> because . means function composition, damn it.
07:07:04 <Peaker> what's in Data.List?
07:07:07 <pjd> operators present a bit of a problem
07:07:13 <ski> yes
07:07:17 <Peaker> quicksilver, I am new in Haskell, dot means member selection to me :)
07:07:31 <quicksilver> foo A.<$> bar A.<*> baz
07:07:34 <quicksilver> is pretty ugly :)
07:07:40 <Peaker> damn syntax sucks. We need to move on to a UI editor for Haskell :-)
07:08:06 <Saizan> Peaker: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
07:08:10 <lambdabot> http://tinyurl.com/yhrw65
07:08:14 <pjd> quicksilver: Unicode middle dot, ho!
07:08:33 <Peaker> yeah operators are a problem: Maybe they should simply be imported explicitly into the namespace
07:09:00 <Peaker> but the problem we're solving here is really because our editor is too stupid to show us where stuff is coming from
07:09:19 <pjd> yeah
07:09:21 <Peaker> a lot of the Data.List stuff is in the Prelude, isn't it?
07:09:23 <quicksilver> ghci can tell me though
07:09:27 <quicksilver> that's good enough for me
07:09:42 <quicksilver> (load the file into ghci and then :i <symbol>)
07:09:45 <Peaker> good enough is the enemy of perfect
07:09:52 <quicksilver> of course it would be nicer in the editor
07:10:23 <Peaker> I want to create a Haskell editor in Haskell that is not textual - but I am too new
07:10:29 <Peaker> yet :-)
07:12:01 <Saizan> Peaker: have you designed the UI?
07:14:07 <Peaker> Saizan, I have designed one for C editing - and have a little demo of that working (in Python), but was realizing that I am creating a half-assed FP to do it - so decided to see how real FP's do it
07:14:36 <Peaker> Saizan, I think that the tough part is the platform to do it - and then creating multiple alternate UI's for experimentation should be easy
07:14:51 <Peaker> (if the UI platform is done well)
07:15:07 <Peaker> I think existing ones (e.g Gtk+ et al) are horrible
07:15:37 * Peaker has to go
07:29:43 * byorgey distributes raspberry-ginger lambdas
07:30:17 <quicksilver> mmmm
07:51:49 <ehird> crap -- i don't understand my amb code from yesterday
07:52:03 <ehird> yesterday it was a neat hack, now it looks like regular dense haskell code to me
07:54:36 <ski> ehird : continuation monad ?
07:56:43 <MyCatVerbs> ehird: no comments?
07:56:58 <quicksilver> comments are obsolete
07:57:01 <quicksilver> types are the new comments
07:58:10 <ertai> does someone know why GHC still warn me about cases that cannot happens http://hpaste.org/6687#a0
07:58:25 <MyCatVerbs> quicksilver: not if your types are sufficiently complicated that you need comments to explain them.
07:58:49 <MyCatVerbs> quicksilver: or are you going to start adding kind declarations and using *those* to document the types? :)
07:58:59 <quicksilver> ertai: I imagine the warning is not clever enough to understand GADTs
07:59:11 <kosmikus> MyCatVerbs: exactly, that's what kinds are for ;)
07:59:16 <quicksilver> ertai: still, you should report a bug
07:59:22 <quicksilver> ertai: it should be fixable at least in simple cases like that.
08:00:37 <ertai> quicksilver: I thought that was a critical point of GADTs to avoid useless checks, and so to integrate well with pattern matching
08:00:45 * ertai will report a bug
08:00:57 <quicksilver> ertai: there is already a bug.
08:01:22 <quicksilver> ertai: http://hackage.haskell.org/trac/ghc/ticket/2006
08:01:24 <lambdabot> Title: #2006 (unreachable GADT pattern clauses show up as warnings with -Wall) - GHC -  ...
08:02:10 <ertai> quicksilver: ok
08:02:29 <ertai> arg they "need a volunteer"...
08:04:49 <ehird> ski: what about it?
08:04:52 <ehird> MyCatVerbs: I just joined
08:05:36 <ehird> here is Amb (equiv. []) and AmbT (equiv. a real ListT), the code I was talking about: http://www.haskell.org/haskellwiki/Amb
08:05:37 <lambdabot> Title: Amb - HaskellWiki
08:05:38 <ehird> it's easily readable
08:05:44 <ehird> just from a distance it looks dense :)
08:05:55 <ehird> and dolio's way cool delimited continuations version: http://hpaste.org/6678
08:06:20 <ehird> ambCC hurts my brain just because it's tedious
08:07:44 <ehird> oh and http://therning.org/magnus/archives/249 the thing about ListT there is a non-issue with AmbT and it would work fine, without any unsafe* functions
08:08:45 <Saizan> can you really define delimited continuations with only Cont? why is CC-delcont so complicated then?
08:09:31 <ehird> Saizan: beats me..
08:10:21 <Saizan> i guess the latter has more features
08:10:59 <ehird> hmm
08:11:05 <ski> Saizan : if you want multiple orthogonal delimit-points, it gets more complicated
08:11:08 <ehird> is (unsafePerformIO . unsafeInterleaveIO) different frm unsafePerformIO?
08:11:48 <ski> (some such is needed for compositionality of different code using delimited continuations, and which should not disturb each other)
08:12:31 <Saizan> ski: ah, thanks
08:18:59 <Saizan> ski: and in this case it doesn't matter because there's only one reset at the end?
08:19:11 <Eelis> i need a Haskell binding for DCOP. anybody aware of work on such a thing?
08:19:39 <ehird> actually my amb code is kinda strange
08:19:46 <ehird> using 'return undefined' to let 'amb []' be well-typed in all cases
08:19:57 <opqdonut> :o
08:20:11 <opqdonut> details?
08:20:42 <dozer> Running my code in RandT g (WriterT (DList Int) IO) a runs in crazy time, while my code in RandT g (IO) a runs in happy time, even if I don't call 'tell' once
08:20:51 <dozer> is this a known thing?
08:21:36 <ehird> opqdonut: http://www.haskell.org/haskellwiki/Amb
08:21:37 <lambdabot> Title: Amb - HaskellWiki
08:21:45 <ehird> if you get rid of the 'return undefined' trickery and let amb's type be inferred
08:21:50 <ehird> amb :: [a] -> Amb r a a
08:21:52 <ski> Saizan : yes, all the `reset's and `shift's are intended for the same control purpose
08:21:59 <ehird> 'a' si the 'amb argument type'
08:22:03 <ehird> But..
08:22:07 <ehird> if you do return undefines
08:22:11 <ehird> you can get amb :: [b] -> Amb r a b
08:22:21 <ehird> where b is either a, or 'undefined's type
08:22:33 <u_quark> > putStrLn "lala"
08:22:35 <lambdabot>  <IO ()>
08:23:15 <ehird> i'm currently renaming 'AmbT r a m b' to 'AmbT r s m a'
08:23:19 <ehird> it's more accurate, and State uses it
08:24:26 <Saizan> dozer: Writer adds some overhead even when you don't use it, unrolling your monad stack and/or CPS transform it can help
08:24:33 <quicksilver> dozer: that surprises me superficially. Does Writer.Strict help?
08:25:06 <dozer> Saizan: it is defo a complexity blowup, not a cnst overhead
08:25:14 <dozer> quicskilver: from the bundeld mtl?
08:25:58 <quicksilver> dozer: yes
08:26:10 <quicksilver> Control.Monad.Writer.Strict
08:26:29 <quicksilver> since ghc 6.6, at least
08:27:09 <Saizan> dozer: well it has to mappend a mempty for every return that's used in your term
08:28:28 <ski> ehird : i think you can use `deriving Monad' on `AmbT', instead of the explicit trivial `instance Monad (AmbT r s)'
08:28:34 <ehird> http://www.haskell.org/haskellwiki/Amb update
08:28:35 <lambdabot> Title: Amb - HaskellWiki
08:28:39 <ehird> ski: is that h98?
08:28:44 <ski> no
08:29:07 <ehird> there you go then :)
08:29:13 <ehird> there's a reason I don't use 'forall r.' in that
08:29:23 <ehird> i wanted to see if the stuff like 'amb []'s type could be done in pure h98
08:29:39 <ski> np. just knee-jerk reaction :)
08:29:48 <ehird> type AmbT' s m a = forall r. AmbT r s m a
08:29:56 <ehird> type Amb' s a = AmbT s Identity a
08:30:01 <ehird> for ghc weenies
08:30:02 <ehird> :D
08:30:32 <ski> s/AmbT s Identity/AmbT' s Identity/
08:31:09 <ehird> err yes
08:31:09 <ehird> thanks
08:31:23 <ehird> ski: i was really suprised when factorIO worked first time
08:31:29 <ski> (is there a point to using `() -> ' in `Point' ?)
08:31:29 <ehird> and did exactly what i expected it to
08:31:40 <ehird> ski: yes. callCC continuations are stored in it
08:31:44 <ehird> @type callCC
08:31:46 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
08:31:55 <ehird> if I didn't restrict to () i'd have to add another param and that eventually leads to infinite params
08:31:57 <ehird> but..
08:32:01 <ehird> I could store (cont ()), couldn't I?
08:32:06 <ski> sure
08:32:09 <ehird> thanks!
08:33:19 <ski> (btw, i'd s/s/r/ or s/s/o/ ..)
08:34:26 <ehird> ski: and hmm your thing actually seems to make the code uglier :)
08:34:31 <ehird> and well
08:34:38 <ehird> 'r' is the 'permanently uninstated' variable
08:34:42 <ehird> some mtl thing uses 'r'
08:34:48 <ehird> dunno why you say r or o though...
08:34:52 <ehird> i chose 's' for 'amb state'
08:35:11 <ski> `r' for "final _r_esult"
08:35:35 <ski> i've seen `r' and `o' used for the type of the final result in continuation things
08:35:39 <ski> and that's what this is
08:35:47 <ehird> ski: no, not quite
08:35:51 <ehird> well, maybe
08:36:01 <ehird> it's from (ContT r m)
08:36:07 <ehird> because ContT is defined as 'ContT r m'
08:36:20 <ehird> i just viewed it as a 'floaty abouty' which eventually ends up == 'a'
08:36:23 <ehird> but you'e right..
08:36:34 <ehird> ski: wait, s isn't final result
08:36:41 <ehird> example :: Amb r Integer (Integer,Integer)
08:36:46 <ehird> s is just the type of the arguments passed to amb
08:37:35 <ehird> hmm wait
08:37:36 <ehird> it's not even that
08:37:38 <ski> hm
08:37:40 <ehird> with my special 'amb', you can pass any argument
08:37:46 <ehird> so wait..
08:37:50 <ehird> s is another uninstated type variable..
08:37:59 <ehird> thanks!
08:38:02 <ehird> this could be a lot nicer..
08:38:08 <ehird> (Polymorphic 'amb', that is so awesome)
08:38:19 <ski> polymorphic in what sense ?
08:38:24 <ehird> ski: this
08:38:35 <ehird> do x <- amb [1,2,3]; y <- amb [4,5,6]; z <- amb ['a','b','c']
08:38:37 <ehird> that actually works right now
08:38:41 <ehird> because of my amb type
08:38:44 <ehird> thanks to 'return undefined'
08:39:03 <ehird> originally, amb :: (Monad m) => [s] -> AmbT r s m s
08:39:07 <ehird> but since I haev that trick
08:39:09 <ehird> I think I can deplete s
08:40:29 <ehird> oh jeez, it works!
08:40:47 <ehird> newtype AmbT r m a = AmbT { unAmbT :: StateT [AmbT r m r] (ContT r m) a }
08:41:13 <ski> ehird : probably you are right that `s' is not the result type
08:41:28 <ski> however, there's something irking me with this code
08:42:00 <ski> i'm not convinced yet that `s' in `AmbT r s m a' is needed
08:42:05 <ehird> ski: look above, jeez
08:42:08 <ehird> i just removed the s
08:42:18 <ehird> and 'r' isn't the result type, really
08:42:35 <ehird> it's the thing we pass around so that ContT &co. are happy with a type variable when really we just pass dummys like 'undefined'
08:42:44 <ehird> runAmb :: Amb r r -> r, though
08:42:50 <ehird> so i guess it IS the result type, eventually
08:42:54 <ski> i'm not sure `undefined' is needed, either
08:43:05 <ski> ehird : right
08:43:41 <ehird> ski: undefined is for amb's type
08:43:42 <ehird> anyway
08:43:43 <ehird> http://www.haskell.org/haskellwiki/Amb
08:43:44 <lambdabot> Title: Amb - HaskellWiki
08:43:47 <ehird> now with one less type parameter
08:45:03 <Saizan> i think you're using undefined somewhere where you could 'abort'
08:45:21 <ehird> Saizan: is that a ContT thing?
08:45:25 <ehird> @type abort
08:45:26 <lambdabot> Not in scope: `abort'
08:45:28 <ehird> @type Control.Monad.Cont.abort
08:45:29 <lambdabot> Not in scope: `Control.Monad.Cont.abort'
08:45:32 <Saizan> not defined
08:45:38 <ehird> define it?
08:45:39 <oklopol> @die 1d2
08:45:39 <lambdabot> 1d2 => 1
08:45:53 <Saizan> ?type let abort x = Cont \_ -> x
08:45:54 <lambdabot> parse error on input `\'
08:45:58 <Saizan> ?type let abort x = Cont \_ -> x in abort
08:45:59 <lambdabot> parse error on input `\'
08:46:04 <Saizan> ?type let abort x = Cont $ \_ -> x in abort
08:46:05 <lambdabot> forall r a. r -> Cont r a
08:46:24 <ehird> Saizan: surely thats just a verbose way of saying 'undefined'
08:46:29 <ehird> since 'undefined = undefined'
08:46:38 <ehird> (well, when used as a dummy)
08:46:44 <Saizan> eh?
08:46:45 <ehird> i don't see how it's more elegant, anyawy
08:46:46 <ehird> *anyway
08:46:57 <Saizan> it's not undefined at all
08:46:58 <ehird> esp. using the Cont constructor
08:47:13 <ehird> Saizan: 'undefined' can mean 'undefined' and 'a dummy value of any type' ;)
08:47:33 <Saizan> ehird: i know.
08:47:43 <ski> (Saizan : ty .. i was thinking of `abort')
08:48:07 <Saizan> ehird: but abort is not using a dummy value
08:48:07 <ehird> so, why would abort be nicer?
08:48:16 <ski> ehird : have you yet tried an example with no solution ?
08:48:19 <ehird> Saizan: but (amb [])s return IS a dummy value.
08:48:31 <ehird> ski: it'll print out 'amb tree exhausted'.
08:48:42 <ehird> Saizan: since you can never get the value, since it's already jumped somewhere else
08:48:54 <ehird> so just returning a dummy value to satisfy the type system is IMO the right thing
08:49:08 <quicksilver> cleaner to use
08:49:13 <quicksilver> error "Actually, you can't do this"
08:49:22 <ehird>                  [] -> fail "amb tree exhausted"
08:49:31 <quicksilver> or error "AmbT : My brain exploded"
08:49:37 <ehird> unsolvable problems are already handled, as you can see above
08:49:42 <ehird> quicksilver: error? hardly, fail
08:49:53 <ehird> ambt errors should be handleable :D
08:50:07 <ehird> but whatever, i can't see why I'd want abort in this case
08:50:22 <ehird> when 'undefined' fills the defined purpose of (amb [])s return value
08:50:24 <ehird> i.e. a dummy
08:50:33 <quicksilver> ehird: undefined is defined as 'error "Undefined"'
08:50:47 <oklopol> @die 1d2
08:50:47 <lambdabot> 1d2 => 1
08:50:47 <quicksilver> ehird: so error is what you are using now.
08:50:57 <ehird> quicksilver: yes, but hidden under the veil of 'an undefined value'
08:51:05 <quicksilver> I'm just suggesting that if you are using error anyway, you might as well choose a sensible message
08:51:05 <ehird> it would work equally well if someone did 'undefined = undefined'
08:51:13 <Saizan> ehird: exactly, if you're jumping somewhere else just ignore your current continuation rather than feeding it a random value
08:51:17 <ehird> what i'm saying is that it doesn't care what 'undefined' is, as long as it's of type 'a'
08:51:21 <ahunter> Hmm.  So I want to spawn a thread with an IO action, let it calculate, and in the spawning thread, wait for it to finish--I don't need any data, I just want to wait for it.  Is there a better way to do this than passing the new thread a MVar () to put something in?
08:51:48 <quicksilver> ahunter: why bother with a new thread at all, if you're just going to wait for it? :)
08:52:21 <ahunter> Well, more accurately, new thread*s*...I'm splitting up computation and then waiting for it to finish.
08:52:40 <quicksilver> MVar () is the answer then, yes.
08:52:51 <quicksilver> Mvar () is a nice simple waiting construct.
08:53:04 <dozer> k, running with Strict.WriterT rather than Lazy.WriterT seems to have fixed it
08:53:12 <ski> ehird : i think `[AmbT r m r]' is actually a kludge here, for what you want to do
08:53:28 <ahunter> OK.  I'm a bit surprised there isn't a joinThread :: ThreadID -> IO () function somewhere, though...
08:53:34 <ski> i think the Right Thing is to use `[forall b. AmbT r m b]'
08:53:37 <dozer> I can't help feeling there is a buglet here though - why would using WriterT and never calling tell at all lead to mappend being called, ever?
08:53:40 <ski> (though, you wanted H98 ..)
08:54:05 <ehird> ski: well, it's not a kludge
08:54:10 <ehird> because you can end up havnig 'forall r.'
08:54:17 <ski> you're using `undefined'
08:54:24 <ehird> ahunter: surely yu could define that
08:54:58 <ski> ehird : i don't see how `forall r. ' fits into this
08:55:11 <ahunter> ehird: I'm not sure how, at least at that type signature...the way I see to do this is to pass an extra parameter to the thread, which I can't do after the fact (so to speak)
08:55:29 <quicksilver> dozer: have you had a look at the source?
08:55:45 <ehird> ski: Take a look at the last snippit here: http://www.haskell.org/haskellwiki/Amb
08:55:45 <lambdabot> Title: Amb - HaskellWiki
08:55:52 <Saizan> dozer: return x = WriterT $ return (mempty,x)
08:56:15 <ski> ehird : ok .. well, i wasn't talking about that
08:56:19 <Saizan> ?type \x -> WriterT $ return (mempty,x)
08:56:20 <lambdabot> forall (m :: * -> *) a w. (Monad m, Monoid a) => w -> WriterT w m a
08:56:35 <ehird> the polymorphic amb thing is really cool though
08:56:36 <ehird> :)
08:56:36 <ski> ehird : i was talking about the ugly `; return undefined', which shouldn't be needed
08:57:04 <ehird> ski: I don't see any way to remove it in h98
08:57:06 <ski> really, just the `f' should give you polymorphic monad return type, there
08:57:09 <ehird> apart from replacing it with something equivilant
08:57:35 <ehird> though
08:57:37 <ehird> newtype AmbT r m a = AmbT { unAmbT :: StateT [AmbT r m a] (ContT r m) a }
08:57:39 <ehird> maybe that would work
08:57:43 <ehird> hmm
08:57:43 <ehird> no
08:57:48 <ski> no
08:58:13 <ski> ehird : i con't either think of a H98 solution .. i'm just stating that i think the current one is a kludge
08:58:18 <ehird> yeah
08:58:24 <ehird> first person to think of an h98 solution gets cookies
08:58:24 <ehird> :P
08:58:24 <ski> s/con't/can't/
08:58:35 <ehird> ski: it's an elegant kludge, though
08:58:39 <ehird> not some horrific thing
08:58:40 <roconnor> I want a cookie!
08:58:46 <roconnor> what's the problem?
08:59:03 <ehird> roconnor: http://www.haskell.org/haskellwiki/Amb
08:59:04 <lambdabot> Title: Amb - HaskellWiki
08:59:10 <ehird> '; return undefined' is a kludge in ski's mind
08:59:14 <ehird> and my use of r in AmbT is too
08:59:15 <ehird> i agree
08:59:16 <skorpan> "some" isn't a preserved word, is it?
08:59:29 <ehird> newtype AmbT r m a = AmbT { unAmbT :: StateT [forall b. AmbT r m b] (ContT r m) a }
08:59:30 <ski> roconnor : rework ehird's `backtrack' at <http://www.haskell.org/haskellwiki/Amb> to not require the ugly `; return undefined'
08:59:31 <ehird> is correct
08:59:32 <skorpan> ah, no, my bad... i was silly.
08:59:36 <ehird> but i can't use forall
08:59:39 <ehird> since i want h98
08:59:44 <ski> ehird : *nod*
08:59:57 <ehird> which isn't just arbitary really
09:00:05 <ehird> ghc's type extensions let you do just about anything
09:00:10 <ehird> so 'amb' wouldn't be interesting at all
09:00:19 <ehird> Hmm. AmbT might be a monoid..
09:00:28 <gbacon> you get amb for free with the list monad
09:00:49 <ehird> gbacon: I know that
09:00:52 <ehird> my page even says it
09:00:55 <ehird> reading helps :)
09:01:06 <ehird> gbacon: What's interesting about mine is the implementation, and AmbT
09:01:14 <ehird> ListT is too strict, isn't always a monad, etc
09:01:15 <ski> ehird : i had problems with "needless" `undefined' as well, in a monad that provided (cooperative) threads, as well .. however they disappeared when i s/()/Void/
09:01:19 <ehird> AmbT is fully OK
09:01:23 <gbacon> I did read, but only about the last four lines of the window :-)
09:01:33 <ehird> ski: and Void isn't h98 either! suprise :)
09:01:41 <dozer> quicksilver: yeah - I see where the mappend calls are comming from - it just seems a bit broken somehow
09:02:09 <ski> ehird : well, i didn't care there .. it ought to be H98, imo ;)
09:02:44 <dozer> quicksilver: you sort of want the mzero cases to be dealt with eagerly and the rest lazily
09:03:23 <Saizan> dozer: you can avoid unnecessary mempty and mappends if you use forall r. ContT r Writer and write a proper tell
09:03:27 <ehird> ski: Indeed but it isn't
09:03:37 <ehird> So yes, I'm quite interested in a h98 ';return undefined'less amb
09:04:33 <dozer> Saizan: Begads! If I have to do something that scary just to use WriterT-like functionality, then things are decidedly not optimal
09:04:40 <roconnor> what's up with (() -> AmbT r m r) in addPoint?
09:04:48 <Saizan> ski: Void + void :: Void -> a?
09:04:49 <ehird> @type callCC
09:04:53 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
09:05:05 <ehird> roconnor: callCC's continuation takes an argument (like all continuations) but we aren't interested in its value
09:05:07 <ehird> so we pass it ()
09:05:09 <Saizan> dozer: very simple, but it should be in the stdlibs probably :)
09:05:13 <ehird> so the thing we get as an argument is..
09:05:33 <ehird>                ambCC $ \k -> do addPoint $ k (); exit x
09:05:37 <ehird> if you do that you don't need addPoint's type
09:05:52 <dozer> Saizan: if that's the only sane way to use a lazy writerT, then shouldn't that just be a typedef for ...Lazy.WriterT?
09:05:53 <ski> roconnor : the argument comes directly from `callCC' .. i suppose one could move the application with `()' into the call site of `addPoint'
09:06:00 <roconnor> ok okay
09:06:58 <ehird> hmm
09:07:03 <ehird> more evidence that the return undefined is a kludge
09:07:09 <ehird> if you remove the type signature
09:07:16 <ehird> '    Inferred type is less polymorphic than expected'
09:07:23 <ski> Saizan : in my case, i always discarded the top-level continuation .. i didn't need to actually use `void' anywhere
09:07:27 <ehird>         backtrack :: forall t. AmbT r m t     -- it thinks this
09:07:33 <ehird> which is the 'correct' h98 solution
09:07:42 <ehird> ski: would 'abort' be more elegant?
09:07:45 <ehird> i don't really think so
09:08:13 <ski> Saizan : though i suppose i could've used it in `topCont :: ((Void,State),[Thread]) -> IO ()', instead of using `error'
09:08:44 <ski> ehird : well, at least `abort' could possibly be total (would it be ?)
09:09:32 <ehird> hmm
09:09:39 <ehird> what's abort's argument supposed to be?
09:09:45 <ehird> (& i'm still not convinced its more elegant)
09:09:47 <quicksilver> dozer: it's not entirely clear to me that lazy writer or state are ever sane.
09:10:04 <roconnor> is AmbT really a monad transformer?
09:10:32 <dozer> quicksilver: you kind of want it to be strict in the 'state' parameter and lazy in the 'value' parameter
09:10:57 <ski> roconnor : it's just composition of `StateT ...' and `ContT ...', no ?
09:10:58 <dozer> quicksilver: so that everything gets threaded in a timely manner
09:11:10 <ski> abort :: r -> AmbT r m a  -- something like this
09:11:17 <roconnor> ski: oh right, duh
09:11:40 <dozer> quicksilver: at least, strict engouh to know the emediate constructor/tag of the 'state'
09:12:41 <ski> abort r = AmbT (lift (\k -> return r))  -- i think
09:13:05 <ski> er, `ContT' should be in there, around the lambda
09:13:15 <roconnor> sound this be made an instance of MonadPlus?
09:13:19 <roconnor> should
09:16:23 <ski> it would be interesting to see how this code would look using `ReaderT' instead of `StateT' ..
09:17:14 <ski> @unmtl StateT x (ContT o m) a
09:17:14 <lambdabot> x -> (a -> x -> m o) -> m o
09:17:16 <ski> @unmtl ContT o (ReaderT x m) a
09:17:17 <lambdabot> (a -> x -> m o) -> x -> m o
09:17:58 <Saizan> the problem is that f will ignore its continuation but we don't know it when we use it, so we've to ignore the continuation for it, passing id as a "fake" one
09:18:02 <roconnor> those look isomorphic
09:18:11 <ski> indeed
09:18:39 <quicksilver> @unmtl StateT x m a
09:18:39 <lambdabot> x -> m (a, x)
09:18:50 <ski> state over continuations is more or less the same as continuations over environment
09:18:55 <quicksilver> @unmtl ContT o m
09:18:55 <lambdabot> err: `ContT o m' is not applied to enough arguments, giving `/\A. (A -> m o) -> m o'
09:19:00 <quicksilver> @unmtl ContT o m a
09:19:00 <lambdabot> (a -> m o) -> m o
09:19:01 <ttt--> hi, what does !a mean in a type signature?
09:19:11 <roconnor> ContT ReaderT seems simpler to understand.
09:19:13 <ski> (the question is what "more or less" means more precisely :)
09:19:53 <ski> ttt-- : do you mean a datatype definition ?
09:22:35 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6689
09:25:41 <ehird> is there a tutorial for variadic haskell functions anywhere?
09:25:42 <ehird> using the :: trick
09:25:53 <ehird> list ... :: [a] -> [...] :: [a] would be nifty
09:25:54 <bogner> is it just me or is ghc 6.8 like 100 times faster than 6.6? i just upgraded, and it's amazing
09:26:02 <ehird> I know I need some kind of typeclass
09:26:10 <dolio> It did get faster.
09:26:21 <bogner> i'm pleased.
09:26:36 <roconnor> @type callCC
09:26:40 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
09:27:12 <ehird> roconnor: you still pondering? ;)
09:27:26 <dolio> Also, my Amb is haskell98. :)
09:27:33 <ahunter> http://hpaste.org/6689 So I want to use this to time IO actions, but I'm slightly worried about laziness here...
09:27:52 <roconnor> ehird: I think I see the prob. you want addPoint :: (Monad m) => (() -> forall b. AmbT r m b) -> AmbT r m ()
09:27:59 <ehird> dolio: Yours? Where?
09:28:06 <roconnor> but that isn't H'98
09:28:09 <dolio> The one with delimited continuations.
09:28:12 <ehird> roconnor: Yes
09:28:18 <ehird> dolio: Ah, yes. That is true.
09:28:19 <ehird> But even so.
09:28:20 <ehird> :)
09:28:25 <ehird> Can you do AmbT with it? eh? ;)
09:28:55 <dolio> Probably. I just need to write the delimited operators for ContT.
09:29:16 <dolio> roconnor: Oh, that looks like MonadCont done right, with polymorphic callCC.
09:29:24 <roconnor> ehird: this seems like exactly the thing that H'98 is bad at.
09:29:44 <ehird> roconnor: which is why I'm interested in it
09:30:07 <roconnor> Oleg can probably do it. :P
09:30:09 <ehird> roconnor: the current one works. it has one kludge, the undefined thing
09:30:13 <ehird> apart from that it's idiomatic and all that shazz
09:31:01 <roconnor> ehird: oh, I missed the part where we decided it was a kludge.
09:32:07 <ehird> roconnor: well, ski did :)
09:32:12 <ehird> the 'undefined' is fine IMO
09:32:19 <roconnor> oh okay
09:32:24 <ehird> it's 'the return value of this doesn't matter, it's undefined, you can't get at it anyway
09:32:40 <ehird> maybe the forall would be marginally more elegant but not that much so
09:32:44 <quicksilver> which is why I would prefer error "You can't actually get here"
09:32:49 * quicksilver shrugs
09:32:55 <ehird> quicksilver: but undefined is that error :)
09:33:02 <quicksilver> not to the programmer
09:33:03 <ehird> getting at the (amb []) return value is ndefined
09:33:04 <quicksilver> (code reader)
09:33:06 <ehird> *undefined
09:33:09 <ehird> since it's impossible
09:33:10 <ehird> :)
09:33:11 <Saizan> so in (shift f), f takes the continuation till the enclosing reset and can "run" it seeing the result, and the result of f becomes the result of reset?
09:35:01 <ehird> hmm, I don't think my 'list ...' is impossible
09:36:07 <roconnor> I like:
09:36:09 <roconnor> ambCC $ \exit -> do
09:36:09 <roconnor>                ambCC $ \k -> addPoint k >> exit x
09:36:17 <roconnor> that's pretty cool.
09:36:25 <Saizan> yup
09:36:27 <yuriyp> @hoogle (a, b, c) -> c
09:36:27 <lambdabot> No matches, try a more general search
09:36:33 <yuriyp> @hoogle (a, b, c) -> a
09:36:34 <lambdabot> No matches, try a more general search
09:36:40 <eyeris> What does it mean for a package to be hidden? I get the error "Could not find module `Text.ParserCombinators.Parsec': it is a member of package parsec-2.1.0.0, which is hidden"
09:36:49 <roconnor> good example of confusing CallCCs :D
09:37:26 <Saizan> eyeris: you're building a cabal package? you need to add that package to the build-depends: field in .cabal
09:37:42 <roconnor> I'm with ski on rewriting it as ContT ReaderT.  I'd like to see that.
09:38:04 <eyeris> Saizan trying to build yi :)
09:38:04 <ehird> roconnor: amusingly the main structure of that callCC is borrowed from a *ruby* version of all things
09:38:13 <ehird> you wouldn't think it would translate to pretty, non-imperative looking haskell
09:38:14 <ehird> but you'd be wrong
09:38:17 <ehird> original: http://www.randomhacks.net/articles/2005/10/11/amb-operator
09:38:17 <lambdabot> Title: McCarthy's Ambiguous Operator
09:38:25 <ehird> obviously they don't need the exit continuation in theirs because ruby has 'return'
09:38:29 <roconnor> ruby has callCC?
09:38:36 <ehird> roconnor: yep
09:38:42 <ehird> roconnor: it's full continuations, too
09:38:46 <Jaak> ruby++
09:38:49 <ehird> well, you can't call them in a thread other than the one they were created in
09:38:55 <ehird> but async forever, amirite ;)
09:38:58 <roconnor> what do you mean by full continuations?
09:39:10 <ehird> roconnor: can be called from any stack
09:39:13 <ehird> i.e. not downwards-only
09:39:16 <ehird> also, reusable
09:39:29 <ehird> ruby started out as matzlisp, so it's hardly suprising
09:39:40 <ehird> apparently rubinius will support calling continuations across threads
09:39:42 <ehird> i look forward to that
09:40:19 <quicksilver> yuriyp: there are no ternary tuple operators in core
09:40:31 <quicksilver> yuriyp: although they are probably in the next release of Data.Tuple
09:40:43 <quicksilver> yuriyp: in the meantime just use (\(x,_,_) -> x) ;)
09:40:46 <roconnor> the ruby code looks simpler.
09:40:46 <quicksilver> or name it yourself
09:41:03 <yuriyp> quicksilver: thanks :-)
09:42:19 <ehird> roconnor: yes, it does
09:42:26 <ehird> it isn't monadic, obviously
09:42:27 <hpaste>  dolio annotated "delimited continuations" with "AmbT" at http://hpaste.org/6678#a1
09:42:29 <ehird> so you don't get AmbT
09:42:33 <ehird> because that would make no sense :)
09:42:41 <roconnor> oh right
09:43:26 <ehird> btw: i am tempted to work on a prolog embedding in haskell now :D
09:43:44 <ehird> PrologT IO
09:43:49 <eyeris> How can I force cabal to reinstall a package that is already installed and up to date?
09:43:54 <ehird> also known as DirtyStinkyRegularProlog
09:44:07 <roconnor> ehird: we already have LogicT, which I think does what you want.
09:44:12 <ehird> eyeris: first, do something pointless. then, you've already done something pointless
09:44:17 <ehird> eyeris: cabal uninstall, cabal install.
09:44:17 <dolio> Incidentally, this sort of Amb stuff along with various fair choice stuff is implemented in logict.
09:44:22 <ehird> roconnor: did I write it?
09:44:33 <dolio> @hackage logict
09:44:33 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/logict
09:44:40 <Saizan> ehird: there's no cabal unisntall
09:44:42 <ehird> no, it's obviously useless
09:44:42 <ehird> :D
09:44:54 <ehird> Saizan: ok, 'cabal burn in hell no uninstall command wtf'
09:45:15 <ivant> hi
09:45:29 <ivant> why can't I declare type W a = (a, String) and then
09:45:45 <ivant> do instance Monad W where ...?
09:45:51 <Saizan> eyeris: why do you want that? however you can ghc-pkg unregister pkgname
09:45:56 <ehird> ivant: it's a type synonym.
09:45:59 <dolio> You can't partially apply type synonyms.
09:46:04 <hpaste>  gamehack pasted "getopt in haskell" at http://hpaste.org/6690
09:46:32 <ehird> gamehack, congrats for wasting your time.
09:46:35 <ehird> Getopt is in stdlib.
09:46:42 <eyeris> Saizan: I want to expose parsec, but ghc-pkg expose parsec-2.1.0.0 doesn't seem to be working (yi build still complains that it is not exposed)
09:46:48 <ehird> And use heirarchical packages.
09:46:48 <ivant> is there way around it (other than declaring newtype?)
09:47:06 <Saizan> @where cabal-faq
09:47:06 <lambdabot> http://haskell.org/haskellwiki/Cabal/FAQ
09:47:37 <Saizan> eyeris: you don't have to expose it. http://haskell.org/haskellwiki/Cabal/FAQ
09:47:39 <lambdabot> Title: Cabal/FAQ - HaskellWiki
09:48:10 <eyeris> I see
09:48:46 <dolio> ehird: You just wasted your time, AmbT is already on hackage. :)
09:49:06 <Saizan> eyeris: however building yi can be not trivial
09:49:26 <ehird> dolio: Where?
09:49:36 <dolio> It's in the logict package, called LogicT.
09:49:46 <ehird> Yeah, and Amb is already in the core.
09:49:49 <ehird> That's not the point. :-)
09:50:04 <Saizan> eyeris: i used this guide the last time http://www.nobugs.org/developer/yi/building.html
09:50:05 <lambdabot> Title: Building Yi
09:50:08 <eyeris> Saizan I've noticed :) I've already had to update it to use Regex > 0.72...
09:50:09 <ehird> the point of mine is
09:50:13 <ehird> 1. implementation
09:50:17 <ehird> 2. somethign
09:50:37 <Saizan> eyeris: i'm not sure that was the right thing to do..
09:51:53 <dolio> It also has fair choice, fair conjunction, logical conditional/soft cut, and pruning.
09:53:22 <eyeris> Saizan quite possibly, but it was a small change, and it was easier than getting the old regex libraries to install
09:54:24 <ttt--> @hoogle calCC
09:54:25 <lambdabot> No matches found
09:54:34 <ttt--> @type callCC
09:54:35 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
09:54:35 <Saizan> @hoogle callCC
09:54:35 <lambdabot> Control.Monad.Cont.Class.callCC :: MonadCont m => (a -> m b -> m a) -> m a
09:54:38 <ttt--> @hoogle callCC
09:54:38 <lambdabot> Control.Monad.Cont.Class.callCC :: MonadCont m => (a -> m b -> m a) -> m a
09:55:08 <george--> join #nonlogic
09:55:10 <george--> sorry
09:55:46 <Saizan> spam?
09:58:11 <Baughn> Missing /
10:03:38 <gast> hi, has anyone used haskell in a start-up ? if so, what were your experiences.
10:05:19 <astrolabe> gast: Have you come across Joel Reymont?
10:06:03 <astrolabe> He wrote a lot about his experiences.  He had mixed feelings I think.
10:06:06 <gast> astrolabe: no. someone who has succeded with haskell in a startup?
10:06:15 <gast> ah, ok. thanks.
10:06:21 <astrolabe> You should find stuff here http://wagerlabs.com/
10:06:23 <lambdabot> Title: Tenerife Skunkworks
10:07:22 <gnuvince> Although he succeeded in OCaml/Haskell/Erlang/Factor/K/Q/Lisp/Forth
10:07:23 <gnuvince> ;)
10:08:09 <byorgey> I don't think Joel Reymont is particularly representative =)
10:08:17 <astrolabe> Yeah.  He seems to be a bit of a programming language tigger.
10:08:33 <astrolabe> But do you know of any other start-up haskellers?
10:08:53 <byorgey> ...
10:09:01 <byorgey> astrolabe: wanna start a startup?
10:09:04 <gast> seems like he is an expert for trying out every language... :)
10:09:12 <ehird> joel reymont is an idiot
10:09:16 <astrolabe> byorgey: What shall we do?
10:09:19 <ehird> his twitter at one point was priceless
10:09:24 <ehird> the one page, only a few messages,
10:09:32 <ehird> documented 3-4 languages in 5 days
10:09:36 <vincenz> ehird: yeah, "tried this, tried that, tried that.."
10:09:40 <vincenz> :D
10:09:44 <ehird> each time he completely abandoned the previous one and decided that the newer one was infinitely better
10:09:46 <byorgey> astrolabe: why, write awesome software in Haskell that everyone wants, of course =)
10:09:53 <vincenz> ehird: with emphasis on infinitely :)
10:10:05 <ehird> vincenz: HASKELL IS MY FUTURE.
10:10:06 <ehird> ...
10:10:07 <ehird> K IS MY FUTURE>
10:10:07 <vincenz> ehird: it was like "ZOMG! lisp is WAY better than haskell"!
10:10:13 <astrolabe> ehird: I think you're unkind.  I think he's very productive, but he wants things to work now, even if he doesn't understand how to make them work.
10:10:14 <ehird> I remember one was like
10:10:16 <vincenz> "ZOMG! lisp sucks, K is what I need!"
10:10:20 <ehird> 'Ocamlp4 has quotations. What to do?!'
10:10:35 <ehird> 'some language has got a feature already in my current one HELP THIS IS A CRISIS WHAT DO I DO?'
10:10:41 <vincenz> astrolabe: you can't figure out how things work based on one day
10:10:46 <ehird> 1 day later: 'ocamlp4 totally r0x0r. Hsakell sux'
10:10:47 <vincenz> astrolabe: learning the way of a language takes weeks if not months
10:10:56 <gast> how long have  you astrolabe/byorgey been working with haskell?
10:11:06 <astrolabe> vincenz: I agree.  Especially haskell.
10:11:19 <gast> vincenz: if not years.... :)
10:11:22 <vincenz> t's not just the syntax, it's the libraries, the idioms, the way of doing things
10:11:37 <byorgey> gast: I've been working seriously with Haskell for about 1 year, although I'd done a bunch of other stuff with FP before that
10:11:37 <astrolabe> gast: A few years, playing at home, sometimes getting to use it at work.
10:11:58 <astrolabe> gast: I think we were kidding about the start-up.
10:12:12 <byorgey> gast: where by "working" I mean "playing", I unfortunately don't get to use it at work =(
10:12:24 <gast> are you not allowed?
10:12:55 <byorgey> gast: well, it's not even enough of an option to ask whether it's allowed or not.  government and all that.
10:13:16 <gast> ok.
10:13:23 <byorgey> just trying to get a compiler installed on the servers would be a three-year process =)
10:13:56 <byorgey> requiring forty-five signatures, a contingency plan, and a five-hundred-page document
10:14:09 <astrolabe> gast: My opinion (which is not expert) is that committing to haskell would be a bit of a risk.  A lot of things you could do very efficiently, and have excellent expressive and refactorable code, but the meta-language stuff (libraries,debuggers etc.) is not quite there yet.
10:14:56 <byorgey> but on the other hand, doing a startup in and of itself is already way more of a risk than using Haskell =)
10:15:00 <astrolabe> gast: On the other hand, you'd have a blast.
10:15:33 <astrolabe> The language is fun, the community is fantastic.
10:15:54 <gast> i was thinking about how hard (for example galois.com) it is for a company to find people who code in haskell
10:16:02 <ehird> i've been using haskell for peanuts amuont of time :p
10:16:17 <ehird> i tried learning it first late '06 i think
10:16:42 <quicksilver> galois in particular doesn't seem to find it that hard :)
10:16:46 <astrolabe> gast: I think if they set up in the right place, or allow remote-working, it could be ok.
10:16:47 <quicksilver> but I think it gets the cream of the crop.
10:16:54 <gast> now imagine if you want to start a startup in haskell.... you have to find people who are willing to take the risk of a startup.._and_ who want to use haskell...
10:17:00 <ahunter> gast: I've heard companies (Jane Street, iirc) argue that yes, it's harder to find people who code in the cool languages, but the people they find are better--cuts out a lot of the Java idiots
10:17:45 <quicksilver> anyone who is basically a good programmer and a smart person should be able to pick up haskell on the job easily enough, if they become part of a team who already use it effectively.
10:17:46 <cnwdup> How is Haskell behaving as CGI in Web Applications? At least google tells me, it is possible. Or am I misleading?
10:18:23 <jaj> cnwdup: yup it's possible
10:18:24 <gast> there is a very good introduction to cgi with haskell
10:18:25 <astrolabe> quicksilver: Yes, but I think you do need to be smart.
10:18:31 <gast> on haskell org
10:18:34 <ehird> cnwdup: Possible, but you should totally not do cgi.
10:18:34 * astrolabe flatters himself
10:18:36 <ehird> fastcgi! or scgi!
10:18:38 <ehird> or something.
10:18:44 <quicksilver> astrolabe: I personally do no hire programmers who I don't believe to be smart :)
10:18:48 <ehird> I would plug my webframework here except it's still only in my head
10:19:03 * quicksilver plugs ehird's head in here.
10:19:07 <gnuvince> quicksilver: do you hire programmers who believe they are smart?
10:19:08 <byorgey> ZZZAP
10:19:31 <ehird> gnuvince: he only hires self-deprecating programming
10:19:38 <cnwdup> Thanks. I think I'll look that guide on haskell.org up.
10:19:42 <ehird> then they have to constantly update
10:19:44 <ehird> :p
10:19:45 <gast> does anyone now a web-application which uses cgi? where does one use it and where not?
10:20:02 <gast> it's very good.
10:20:05 <ehird> gast: cgi is pretty outdated... nobody sane really uses it any mre
10:20:08 <elliottt> ehird: i've been using fastcgi/cgi a lot recently, and it seems to work reasonably well
10:20:11 <ehird> how is cgi very good?
10:20:15 <ehird> elliottt: fastcgi is good
10:20:18 <ehird> cgi is nothing like fastcgi
10:20:20 <roconnor> quicksilver: are you hiring?
10:20:24 <quicksilver> gnuvince: I find that's useful too.
10:20:26 <gast> elliott: for what ?
10:20:28 <gast> :)
10:20:33 <quicksilver> roconnor: yes, but I'm hiring Perl programmers atm :P
10:20:35 <elliottt> ah, work things, mostly
10:20:48 <jaj> cnwdup: you can also do fastcgi in haskell
10:20:54 <elliottt> also i've been rewriting my website using that and HDBC
10:20:57 <cnwdup> I would consider fastcgi over cgi for sure. My question was mainly facing using haskell for web sites like php or perl.
10:21:04 <ehird> scgi is my personal favourite
10:21:08 <ehird> cnwdup: well, don't do that
10:21:13 <ehird> structuring an app like php tag soup is a crazy idea
10:21:19 <roconnor> quicksilver: crap
10:21:27 <elliottt> actually, the addition of HStringTemplate makes web development in haskell really easy :)
10:21:34 <ehird> use some kind of model/view seperation, whether it's component/task, model/view/controller, or whatever
10:21:57 <ehird> elliottt: i must say that i never really liked stringtemplate. it wouldn't fit into my framework, anyway. i need the helpers to integrate properly
10:22:13 <elliottt> ah
10:22:34 * matthew_- swears at the context reduction stack
10:22:40 <jaj> elliottt: yeah I plan to write a blog using fastcgi, HStringTemplate and haskelldb. but I have a hard time figuring out how to use haskelldb
10:22:48 <cnwdup> ehird: Is this explained on haskell.org? Currently I'm reading Practical web programming in Haskell.
10:22:55 <gast> i'm curious: what's _your_ main reason _not_ to start a startup?
10:23:03 <elliottt> jaj: HDBC is much easier
10:23:10 <gast> mine: don't see any. :)
10:23:11 <elliottt> haskelldb seems a little out of date
10:23:14 <ehird> cnwdup: Just seperate your html-generation code from the code of the data types you use and the code of the web business logic.
10:23:19 <ehird> haskelldb is dead, yeah
10:23:31 <ehird> i'm considering a non-rdbms thing for mine
10:23:33 <roconnor> I blog using Haskell/opensp
10:23:34 <ehird> pure haskell
10:23:47 <roconnor> I just upload my posts to my webserver
10:23:53 <roconnor> i don't have comments
10:24:01 <gast> who uses happs? i got the examples working yesterday and it seems to me very cool.
10:24:08 <ehird> my fw will abstract cgi/fcgi/etc
10:24:23 <ehird> inc. a mini purehaskell server for development
10:24:24 <astrolabe> gast: I suspect things aren't very startup-friendly here (UK) compared to the US.  I'm concerned about losing my career (such as it is) and my house.
10:24:29 <elliottt> ehird: i've been having similar thoughts.  basically just a load of support libraries on top of fcgi
10:24:36 <roconnor> comments are dumb; I just link back to referer if people have anything to say.
10:24:37 <ehird> hopefully also an IO () of a prog reading argv etc to provide a nice commandline interface
10:24:42 <glen_quagmire> roconnor, can I read your blog?
10:24:45 <ehird> so you don't have to handle that in your app
10:24:55 <roconnor> glen_quagmire: http://r6.ca/blog/
10:24:55 <lambdabot> Title: Russell O&#8217;Connor&#8217;s Blog
10:25:07 <ehird> i have considered handling comments as a special case of trackback
10:25:15 <ehird> so: give them their own url, and simulate a ping from there
10:25:16 <Lemmih> gast: See #happs
10:25:18 <glen_quagmire> roconnor, thank you.
10:25:20 <ehird> (on my server)
10:25:31 <gast> astrolabe: ok, that seems reasonable. btw I'm from germany not from US
10:25:47 <roconnor> glen_quagmire: http://r6.ca/blog/feed.atom
10:26:20 <astrolabe> gast:  :) Sorry.  Also, my work is quite interesting, I can't think of a start-up idea that is both likely to succeed and interesting.
10:27:24 <ehird> roconnor: 'But perhaps dink is more of an audiophile, and the compression quality of MP3 is superior to that of Ogg Vorbis.' haha :)
10:27:46 <ehird> vorbis at a bitrate below an mp3 can generally exceed the mp3's quality
10:28:08 <ehird> (also: most audiophile stuff is supernatural junk. the preceeding claim has been backed up by proper ABX double-blind tests, however)
10:28:13 <jaj> elliottt: could you point me to some documentation or examples on hdbc?
10:28:14 <ehird> [this is offtopic, yes]
10:28:28 <glen_quagmire> i don't know about atom feeds and stuff (new to the internet)
10:28:39 <Baughn> MP3 has certain troublesome characteristics that makes ogg better than mp3 at /any/ quality. Or, that is, mp3 will always have flaws where ogg/aac won't.
10:28:56 <quicksilver> gast: I woudl concur that happs is very cool
10:29:01 <roconnor> ehird: yeah, I didn't believe MP3 was superiour to Ogg, but I don't know too much about their compression details.
10:29:05 <quicksilver> gast: I think it's only flaw is that is is in some places too cool :)
10:29:18 <glen_quagmire> mp3 is not free. it must be good
10:30:16 <ehird> glen_quagmire: new to the internet? tee hee :)
10:30:18 <roconnor> simply stripping audio frames out of another standard always yeilds /wonderful/ formats.
10:30:26 <dcoutts_> mnislaih: I removed a couple of the reqArg'' optArg'' variants, seemed we didn't need them, just wanted to check it with you though
10:30:48 * ehird used to use FLAC, until he became a mac idiot, and now I use ALAC for itunesness
10:30:50 <glen_quagmire> i heard compressions are about structured matrices
10:30:53 <ehird> flac is a better format, but i like itunes.
10:31:06 <ehird> it's not like i'm going to lose quality converting between them now is it :)
10:31:11 <mnislaih> dcoutts_: yeah, that's true. I put them there just in case, but they turned out to be unnecessary
10:31:18 <Cheery> Does there exist something like incomplete types in haskell?
10:31:27 <Cheery> via some extension for instance
10:31:36 <Cheery> say, I have a thing like:
10:31:36 <glen_quagmire> @google haskell incomplete types
10:31:38 <lambdabot> http://www.cs.york.ac.uk/fp/HaXml/icfp99.html
10:31:38 <lambdabot> Title: Haskell and XML: Generic Combinators or Type-Based Translation?
10:32:05 <Cheery> data Sampo a = OK a | Fail Error | Warn Warning
10:32:29 <glen_quagmire> i think that's fine
10:32:51 <glen_quagmire> you don't have to use type paramater for all data constructors
10:32:54 <Cheery> now, I'd want to just define there are Errors and Warnings, then add constructors when appropriate
10:33:26 <quicksilver> start with data Error = Error
10:33:29 <quicksilver> and add stuff later?
10:33:36 <quicksilver> (I'm not sure I understand your question)
10:33:46 <ehird> oooo, wait a sec
10:33:49 <ehird> is there a web TV?
10:34:03 <Cheery> quicksilver: it'd be appropriate to add constructors in an another file where the data Error is actually defined
10:34:11 <dcoutts_> mnislaih: great, fewer '''s are less scary
10:34:13 <dcoutts_> :-)
10:34:15 <glen_quagmire> data Bad = Err | Warn        data All a = Ok a | NoGood Bad   ?
10:34:36 <ehird> data Ungood = Err | Warn    data All a = Good a | DoublePlus Ungood
10:34:45 <Cheery> rather I'd look for something like this:
10:35:03 <quicksilver> Cheery: yes, well you can put the error datatype in another file, that's not a problem.
10:35:10 <Cheery> data Error
10:35:22 <Cheery> reg Error = FooBarFailure
10:35:30 <Cheery> reg Error = Boom
10:35:32 <Cheery> etc.
10:35:35 <Saizan> ah, you want extensible variants..
10:35:52 <Saizan> you can't do that in haskell.
10:35:53 <Cheery> you call them that?!
10:36:22 <quicksilver> why is that better than data Error = FooBarFailure | Boom ?
10:36:22 <roconnor> this is the expression problem isn't it?
10:36:22 <Saizan> i'm not sure, but they are called something like that
10:36:22 <quicksilver> (I actually can think of some reasons, but I'm trying to understand your reason)
10:36:48 <quicksilver> you can encode  an extensible variant as a typeclass
10:36:54 <Cheery> quicksilver: to have an appropriate error handling
10:36:57 <quicksilver> but it's not clear to me that that is really what you want here :)
10:37:06 <ehird> Cheery: typeclass
10:37:14 <dons> hey guys, re. galois, the problem is that we get *too* many applications from qualified haskell programmers, atm
10:37:25 <byorgey> is haskell.org down?
10:37:25 <dons> there's a serious over supply of haskell programmres
10:37:28 <ehird> byorgey: yep
10:37:32 <quicksilver> sort them by irc-nick-length
10:37:33 <ehird> dons: news to me
10:37:33 <dons> byorgey: grr!
10:37:35 <quicksilver> hire the shortest.
10:37:49 <roconnor> w00t I'm really short!
10:37:54 <dons> ehird: well, hiring rates from haskell places aren't widely publicised.
10:38:05 <ehird> i have 'rice'
10:38:05 <dons> we do, sadly, have to turn away many excellent hackers
10:38:06 <ehird> hire me!
10:38:17 <roconnor> quicksilver: oh shortest nick :/
10:38:24 <byorgey> hahaha
10:38:29 <ehird> i almost got a one-char nick at one point
10:38:29 <dons> also, people overestimate how hard it is to train up a haskell hacker
10:38:33 <ehird> but i'll just haev to settle for 'rice'
10:39:07 <Cheery> quicksilver, would you like to see what would I actually do if I had that in haskell?
10:39:18 <Cheery> that'd may explain what I'm after
10:39:20 <quicksilver> Cheery: yes, that might help me understand
10:39:20 <ehird> Cheery: typeclasses
10:39:41 <vegai> serious oversupply of haskell programmers? That's odd
10:39:54 <ro> not much demand I guess
10:39:55 <dons> vegai: there's more by far than jobs available
10:40:04 <dons> so if you want one, they're easy to find
10:40:13 <lament> that's because the number of jobs available is like.. 2
10:40:16 <dons> if we had , say, another 1000 positions filled, then things would get tricky
10:40:25 <dons> well, its 10-20, i'd say, lament
10:40:32 <dons> not counting academia
10:40:33 <lament> worldwide?
10:40:34 <jaj> is http://www.haskell.org/ down?
10:40:37 <dons> yeah
10:40:41 <lament> painful
10:40:47 <dons> let me mail hudak
10:40:54 <vegai> that'd be a nice thing to throw at the face of my employer
10:41:25 <dons> vegai: i think its a common refrain from cufp, that there's always more people who you have to turn away, than you'd like
10:41:25 <vegai> their favourite 1st retort to "let's use haskell" is "there's no-one we can employ who knows that"
10:41:35 <dons> yeah, that's just false.
10:41:37 <dons> ?users
10:41:37 <lambdabot> Maximum users seen in #haskell: 472, currently: 458 (97.0%), active: 24 (5.2%)
10:41:46 <dons> there's more people in here than in #ruby
10:42:01 <elliottt> how many are there?
10:42:16 <vegai> there's the difference that 99% of haskell programmers actually are here :-P
10:42:21 <ehird> dons: the chan is #ruby-lang
10:42:28 <dons> yes, we optimise the community resources better
10:42:32 <dons> ehird: right,that's the one.
10:42:35 <dons> #haskell's way bigger
10:42:37 <ehird> still 50 more in here though
10:42:38 <ehird> no
10:42:46 <ehird> 383 vs 457
10:42:49 <ehird> well, not 50
10:42:49 <dons> its been larger for the last 18 months or so
10:42:51 <ehird> but not 458357345345
10:43:02 <dons> > 383 / 457 * 100
10:43:05 <ehird> besides, 'active' is higher for #ruby-lang
10:43:05 <lambdabot>  83.80743982494529
10:43:21 <dons> so 20%  more potential employees
10:43:23 <dons> :)
10:43:34 <ehird> data [] a = [] | (:) { head :: a, tail :: [a] }       -- why isn't this the prelude definition? it includes head and tail
10:43:39 <jaj> you recruting? :)
10:43:51 <dons> jaj, always.
10:44:01 <dons> see the industry page on haskell.org too -- once its up
10:44:06 <ehird> oh you can't give a custom error
10:44:06 <dons> there's a job advert a week, approx
10:44:24 <lament> is ICFP open to everybody?
10:44:28 <dons> yes
10:44:48 <lament> sweet! i live a short ferry ride away from victoria
10:44:49 <dons> ok. admins notified re. haskell.org
10:45:00 <dons> lament: oh, interesting!
10:45:08 <dons> maybe we can run a hackathon there
10:46:18 <Igloo> lament: Note that you need to pay to attend, though
10:46:50 <Igloo> Does anyone know what time haskell.org died a few days ago?
10:47:05 <Cheery> http://codepad.org/8XOXuKzf
10:47:15 <Cheery> quicksilver: there you go
10:47:37 <quicksilver> Cheery: I would parameterise the type by the warning and error types, personally
10:47:41 <Igloo> Seems even deader this time round
10:47:51 <quicksilver> data MayFail w e a = OK a | Fail e | Warning w
10:48:00 <dons> i pinged paul, Igloo. so many the yale admins can wake it up
10:48:37 <Cheery> quicksilver: but then you hit problems with multiple kinds of errors
10:48:44 <Igloo> dons: Isn't John the one to talk to?
10:48:48 <Cheery> and multiple kind of warnings
10:49:12 <dons> Igloo: Paul's been effective in getting yale guys to reboot things over the past 2 years, i've seen
10:49:12 <Igloo> Right, can't log in this time, so it's down to them, anyway
10:49:18 <Igloo> OK
10:50:16 <Cheery> I remember there were some good resource that told about different kind of type systems
10:50:29 <quicksilver> Cheery: then you can use an existential
10:50:42 <quicksilver> Cheery: Fail (exists e . Error e => e)
10:50:43 <quicksilver> basically
10:50:49 <quicksilver> but I seriously doubt that's a useful thing.
10:51:14 <lament> different kinds of type systems, different sorts of kind sysetms, and different types of value systems
10:51:16 <quicksilver> I acknowledge I'm not being helpful here but my strong instinct is that what you are trying to do is not a good thing to aim for.
10:51:29 <ehird> http://codepad.org/wDP8GFx6 cuts off my damn output
10:51:43 <quicksilver> it is *better* to have type information about the kinds of ways something can fail.
10:52:24 <awesame> ehird: weird.  I don't see a timeout there.  I'll take a look...
10:52:27 <Cheery> quicksilver: but how do you handle the different kinds of type information then?
10:52:51 <quicksilver> Cheery: in what circumstance? there is no problem with your liftF. that works fine.
10:52:57 <mm_freak_work> f (T x) = g x   -- can i write f as a lambda expression?
10:53:04 <quicksilver> Cheery: your div' would get a type indicating what kinds of errors it can return
10:53:07 <quicksilver> that seems fine too, to me.
10:53:14 <Deewiant> mm_freak_work: \(T x) -> g x
10:53:25 <Cheery> quicksilver: well, think about doing an (.) for those errors
10:53:43 <mm_freak_work> thank you  i missed the parenthesis
10:53:58 <byorgey> Cheery: for representing multiple kinds of errors, you make your own data type.
10:54:04 <quicksilver> Cheery: you need to define a sensible way of combining errors, yes.
10:54:11 <quicksilver> but that holds true in any similar system.
10:54:16 <byorgey> data MyErrors = BadString String | Abort | OtherError
10:54:23 <ehird> I still want a deconstruction syntax
10:54:32 <quicksilver> the existential works and is close to what you're asking for.
10:54:35 <ehird> Maybe hijack the forall kind syntax for no real reason
10:54:36 <ehird> Like:
10:54:36 <quicksilver> I'm not sure it's a good idea.
10:54:42 <ehird> (x :: T *)
10:54:44 <Cheery> ie, that you could combine: (MayFail b -> MayFail c) -> (MayFail a -> MayFail b) -> (MayFail a -> MayFail c)
10:54:53 <quicksilver> throwDyn is based on the existential approach.
10:54:54 <ehird> (T x :: T *) -> x
10:55:00 <ehird> (T x y z :: T _ * _) -> y
10:55:17 <ehird> (x :: T _ * _) -> (\(T _ x _) -> x) x
10:55:17 <Cheery> quicksilver: yes, but came to think your stuff.
10:56:17 <Cheery> assuming there would be: type ArithmeticMayFail a = MayFail a ArithmeticFailure ArithmeticWarning
10:56:54 <ehird> nobody likes my idea :D
10:56:57 <Cheery> and: type TakingDogToWalkMayFail = etc...
10:57:32 <Cheery> then you would combine those in manner like earlier.
10:57:35 <ehird>     AmbT a >>= b = AmbT $ a >>= unAmbT . b
10:57:36 <ehird> ===>
10:58:01 <ehird>     AmbT a >>= b = AmbT $ a >>= (\x -> b :: AmbT *)
10:58:03 <Cheery> what would be the Error and Warning in MayFail c?
10:58:05 <ehird> ok admittedly that's not a good example
10:58:06 <ehird> but still
10:58:17 <Cheery> for me, this comes to mind:
10:58:39 <mm_freak_work> a few days ago i would implement the "object pool" in a game as a list of:  data Object = A | B | C | 
10:58:41 <Cheery> MayFail [c], where c can contain both TakingDogToWalkMayFail, and ArithmeticMayFail
10:59:19 <mm_freak_work> now i'm going to implement it instead as:  data Object = forall a.  (Drawable a, ) => Object a
10:59:22 <Cheery> hm, that's still not satisfying me
10:59:31 <mm_freak_work> what's the better approach in your opinions?
10:59:58 <Peaker> mm_freak_, why do you specify the "forall a." prefix, isn't it redundant?
11:00:21 <ehird> Peaker: do I know you from somewher?
11:00:35 <Peaker> ehird, I don't know..
11:00:35 <ehird> mm_freak_work: wow, unicode ellipsis. :)
11:00:40 <ehird> Peaker: aha! #python
11:00:40 <Peaker> ehird, I am not good with names
11:01:16 <quicksilver> mm_freak_work: another alternative is data Object s = { draw :: Object s -> IO (), move :: Object s -> Int -> IO (), state :: s }
11:01:20 <Peaker> ehird, yeah, I'm trying to figure out if I can transition from Python to Haskell, but its not easy to leave something you're proficient with .. :)
11:01:28 <mm_freak_work> Peaker: no, the forall is exactly the point
11:01:29 <quicksilver> mm_freak_work: which is, essentially, explicit dictionaries
11:01:48 <quicksilver> mm_freak_work: but it frees you from the pain of writing instances
11:01:56 <quicksilver> and frees from OO-style bundling into classes
11:01:58 <ehird> quicksilver: congrats, you just invented an object system
11:01:59 <ehird> :D
11:02:11 <quicksilver> data Object s = { draw :: s -> IO (), move :: s -> Int -> IO (), state :: s }
11:02:19 <ehird> Peaker: good luck with that :)
11:02:21 <quicksilver> ehird: right, but a much more capable one than the java one.
11:02:28 <mm_freak_work> quicksilver: that's ok  clean code is more important to me, and i'd like to write each object type (of which there will be a lot) as an own module
11:02:30 <ehird> Peaker: you CAN use both, y'know ;)
11:02:37 <quicksilver> it's more like javascript or a prototype-based language.
11:02:42 <ehird> quicksilver: well, hardly
11:02:49 <ehird> in a prototype system, Object :: Object
11:02:57 <quicksilver> ehird: ?
11:02:57 <ehird> or rather
11:03:02 <ehird> Object :: Object
11:03:07 <ehird> Object clone :: <Object clone>, Object
11:03:17 <mm_freak_work> quicksilver: though you're missing the constructor name
11:03:19 <ehird> quicksilver: Object has to be a first class value that is-a Object
11:03:19 <quicksilver> that's just one way of representing the type stystem.
11:03:20 <Peaker> ehird, heh, yeah - and I will still use Python for short-term work, but I have an ambitious plan to rebuild the software world which is basically my only serious hobby project at the moment - and I think Haskell is (at least close to being) the right base for that
11:03:24 <ehird> and you can clone it to get-a Object
11:03:38 <quicksilver> ehird: 'more like'
11:03:44 <ehird> Peaker: it's TUNES all over again. see you in a decade, still having no work done :D
11:03:52 <quicksilver> the point is, this is a system where you can clone objects and alter single methods.
11:03:56 <ehird> quicksilver: yeah, i guess so
11:04:02 <Peaker> ehird, heh, I read about Tunes, they had a different idea, from what I gathered
11:04:03 <quicksilver> which you can't do in a java-like OO.
11:04:09 <Peaker> ehird, I have simpler ideas, I believe
11:04:12 <quicksilver> it frees you from being bound to classes.
11:04:18 <lament> Peaker: have you looked at the Reinventing Computing project?
11:04:21 <quicksilver> classes are sometimes a frustrating unit of abstraction.
11:04:32 <Peaker> lament, I may have - I will look it up again..
11:04:42 <ehird> quicksilver: smalltalk-80's object system is love though. classes aren't all bad.
11:04:53 <quicksilver> obsession with classes is all bad.
11:04:59 <ehird> yes
11:05:10 <lament> Peaker: it's headed by alan kay. OLPC is related in spirit.
11:05:13 <quicksilver> many of the ills of java come from the class being (in some sense) the only abstraction in town.
11:05:20 <ehird> quicksilver: smalltalk-80 is obsessed with objects, and classes are objects, but the objects are lightweight enough as to be OK
11:05:33 <ehird> cloneIORef r = readIORef r >>= newIORef    -- this should be stdlib, maybe
11:05:40 <quicksilver> of course it *is* a universal abstraction. But it leads to extremely verbose solutions to simple problems.
11:05:47 <ehird> quicksilver: not in smalltalk! :p
11:05:55 <quicksilver> no, I was talking about java.
11:05:57 <Peaker> lament, it seems interesting - but again not exactly the approach I'm taking
11:06:01 <ehird> yea
11:06:01 <quicksilver> IORefs are disgusting.
11:06:09 <quicksilver> I never use them except at the "top-leve"
11:06:16 <lament> quicksilver: don't blame OOP for the faults of Java
11:06:20 <quicksilver> lament: indeed I wasn't.
11:06:22 <mm_freak_work> that's actually pretty cool
11:06:25 <ehird> quicksilver: IORefs are good if you're implementing an imperative language (obviously, living inside IO). heh
11:06:38 <quicksilver> lament: I was blaming obsession with classes for the faults of Java.
11:07:01 <lament> Peaker: what kind of revolution can be done with Haskell?
11:07:10 <lament> quicksilver: smalltalk is equally obsessed with classes...
11:07:23 <mm_freak_work> data Object = forall a. Drawable a => DrawableObj a | forall a. Intelligent a => IntelligentObj a | 
11:07:27 <quicksilver> lament: I don't know enough smalltalk to commentin a useful way.
11:08:36 <quicksilver> lament: but I understand that it supports, at least, anonymous function literals as first class.
11:08:47 <quicksilver> lament: whereas java forces you to use an anonymous class to do that.
11:08:57 <quicksilver> lament: that's the kind of thing I mean by 'obsessed with classes'
11:08:58 <ehird> quicksilver: yes, but they become an instance of a class
11:08:59 <ehird> :D
11:09:22 <ehird> the point is java's syntax & semantics for classes&objects is really heavyweight
11:09:26 <ehird> smalltalk's is almost invisible
11:09:29 <quicksilver> yes
11:09:53 <Peaker> lament, I think that a good UI around an FP language can be used as a general desktop user interface. Add to that network transparency, use an obj-cap security model (language-enforced) and a couple of other interesting features (and get rid of MMU use, processes, kernels, ACL's, etc), and you have a much simpler yet more powerful computing world
11:10:10 <araujo> ehird, I wouldn't say that
11:10:16 <dons> anyone know if the code for "A deterministic Multi-way Rendezvous Library for Haskell", using STM and MVars is available online?
11:10:20 <dons> sounds like a useful librayr
11:10:21 <lament> smalltalk is such a wonderful language. too bad all implementations suck.
11:10:25 <mm_freak_work> i wonder if someone wrote a real game in haskell
11:10:29 <araujo> lament, agreed
11:10:29 <quicksilver> myself I don't find OO to be a good basis for whole-language design, though.
11:10:31 <Peaker> lament, An FP language can run as it is being edited (e.g subtext), and if used on high-level-enough objects, it can be a nifty user interface, to non-programmers too
11:10:34 <mm_freak_work> a real-time opengl game, that is
11:10:37 <araujo> lament, we need a Haskell interpreter
11:10:41 <dons> mm_freak_work: frag is a real game
11:10:43 <quicksilver> I think FP is a much better basis.
11:10:49 <lament> Peaker: why FP?
11:10:50 <quicksilver> and small amounts of OO are useful when they're useful.
11:10:51 <dons> soft real time
11:10:56 <araujo> OO can be seen like just an extension of FP
11:10:57 <quicksilver> mm_freak_work: Frag
11:11:05 <lament> araujo: a haskell interpreter of smalltalk?
11:11:06 <Peaker> lament, because FP is the only way you can run the code as it is being edited - and show all the intermediate results of all computations
11:11:09 <araujo> lament, yeah
11:11:15 <araujo> lament, that'd be nice
11:11:16 <lament> Peaker: sorry?
11:11:29 <Peaker> lament, Have you seen Subtextual's demos?
11:11:32 <lament> Peaker: in smalltalk, you "run the code as it is being edited" all the time
11:11:43 <Peaker> lament, With Smalltalk, you edit a text file, and later you run it
11:11:48 <lament> you can edit the source of live objects
11:11:49 <mm_freak_work> indeed
11:11:54 <lament> have you ever used smalltalk?
11:11:57 <Peaker> lament, yes
11:12:02 <lament> it doesn't even have files
11:12:12 <Peaker> lament, You edit text, nonetheless
11:12:18 <quicksilver> mm_freak_work: http://209.85.135.104/search?q=cache:VWSqylAt930J:www.haskell.org/haskellwiki/Applications_and_libraries/Games+http://www.haskell.org/haskellwiki/Applications_and_libraries/Games&hl=en&ct=clnk&cd=1&client=safari
11:12:19 <lambdabot> http://tinyurl.com/327y4e
11:12:32 <quicksilver> mm_freak_work: (unwieldy URL because haskell.org is down)
11:12:38 <araujo> lament, so far, the implementation more hackable is gnu-smalltalk
11:12:56 <lament> araujo: it seems gnu-smalltalk is actually getting active again
11:13:04 <araujo> lament, quite a lot
11:13:05 <Peaker> lament, I believe that editing programs/semantic models by editing their serialization/encoding in a textual format is a poor way to modify programs
11:13:19 <araujo> lament, they have recently added seaside support and all
11:13:30 <ehird> Peaker: it's the most convenient
11:13:36 <mm_freak_work> i'll have a closer look at it, when i'm at home  here i'm using arch linux, which is a PITA for programmers
11:13:37 <ehird> esp. because people like to format stuff in custom ways
11:13:46 <ehird> so many people have tried before you believe me :)
11:14:02 <Peaker> ehird, There are few systems that try otherwise, and most attempts have had horrible UI's. With a good UI, it is very easy to be at worst as bad as a text editor
11:14:08 <lament> Peaker: a) it's the most convenient b) the step from text to AST is not very big at all. For example, in Squeak, you can choose from one of several alternate syntaxes for the same underlying code.
11:14:32 <lament> also there's Lisp
11:14:35 <ehird> i am going to try seaside&gnu smalltalk
11:14:44 <ehird> btw: semi-structural editing is the way to go
11:14:47 <ehird> things like paredit
11:15:01 <ehird> you can't make your document syntactically invalid (mismatched parens etc) but you can format it as you like
11:15:04 <lament> ehird: visual studio is <3
11:15:17 * araujo thinks lispy was working on a smalltalk haskell interpreter
11:15:20 <Peaker> lament, Lisp is also edited via editing serialization.  Editing serialized formats add a whole class of errors (syntax errors) and seriously impedes the editor's ability to be smart
11:15:39 <ehird> lament: eurgh
11:15:45 <Peaker> lament, It is much much easier for a non-textual editor to be smart and useful to the programmer than it is for a textual editor
11:15:48 <ehird> Peaker: lisp is all about serialization
11:15:49 <ehird> anyway
11:15:50 <ehird> PAREDIT!
11:16:00 <Peaker> ehird, Lisp is all about serialization? why do you say that?
11:16:03 <lament> Peaker: there's been many experiments with editing lisp as an AST.
11:16:13 <lament> Peaker: it's clearly the best language for that.
11:16:23 <Peaker> ehird, lament : Would you say Excel is a less convenient way to program than editing a text serialization of the same information?
11:16:23 <lament> and... well... they all failed, because editing text is still nicer
11:16:46 <ehird> Paredit paredit paredit
11:16:47 <Peaker> lament, editing a program as an AST is a poor way to edit a program
11:16:55 <ehird> you still have control over the text but you can't do silly things like (...
11:16:57 <ehird> and other stuff
11:16:59 <Peaker> lament, A schematic table, for example, may be a much nicer UI to do so
11:16:59 <ehird> srsly, paredit
11:17:17 <Peaker> ehird, lament : I wouldn't say that Excel failed, too, and its a non-textual (or semi-textual) programming editor
11:17:44 <Peaker> If you generalize Excel - you can make it a powerful programming platform
11:17:54 <lament> there's also been many experiments with "visual programming languages" including the haskell thing
11:18:19 <lament> somehow they all managed to fail, which suggests that the underlying problem is extremely hard
11:18:33 <ehird> excel sucks
11:18:34 <Peaker> lament, I have an easy way to "prove" that non-textual programming is at worst as bad as a text editor - and that is simply a non-textual editor that looks and feels like a text editor, but offers more advanced refactoring features and such
11:18:49 <Peaker> ehird, Excel has many technical problems - do you refer to those?
11:18:52 <lament> Peaker: right. visual studio.
11:18:54 <ehird> Peaker: no
11:19:06 <ehird> Peaker: anyway, shush and paredit before blabbing any more :)
11:19:08 <Peaker> lament, Visual Studio is still a text editor - and thus it takes them years and years and they STILL can't get refactoring done right
11:19:28 <lament> visual studio is far more than a text editor. Particularly with Resharper.
11:19:38 <lament> it does a lot of code analysis
11:19:40 <baaba> that's a poor argument if you mean visual c++
11:20:19 <Peaker> lament, Yeah - but its _much_ more difficult for Visual Studio to do smart code analysis because it has to serialize/deserialize it from text constantly. Its also extremely slow because of that - to the point of almost being impractical to use on large projects (at least with these features enabled)
11:20:32 <lament> Peaker: the reason they don't have decent refactoring built-in is because they don't want to drive companies making refactoring tools (Resharper) out of business
11:20:42 <Peaker> lament, It also means it has to deal with temporarily incorrectly encoded programs
11:20:54 <lament> Peaker: i believe that's the root of the problem
11:20:55 <Peaker> lament, Why does emacs have none of those features, 20 years later?
11:21:06 <ivant> @src msum
11:21:06 <lambdabot> msum =  foldr mplus mzero
11:21:07 <ehird> Peaker: PAREDIT DAMNIT
11:21:14 <ehird> programs are always syntactically correct with it
11:21:16 <lament> Peaker: why? because Stallman has just discovered IDEs several days ago
11:21:22 <Peaker> ehird, I'm looking it up
11:21:35 <ehird> Peaker: http://mumble.net/~campbell/emacs/paredit.el
11:21:43 <ehird> debian: paredit-el
11:21:48 <Peaker> ehird, then the next step is to drop the textual encoding altogether - aside from potentially using it as a temporary rendering until people get used to better editing UI's
11:21:50 <lament> Peaker: http://lists.gnu.org/archive/html/emacs-devel/2008-03/msg02254.html
11:21:51 <ehird> docs in the header of the file
11:21:51 <lambdabot> Title: Neat features in Eclipse editor, http://tinyurl.com/2jscuk
11:22:00 <ehird> Peaker: no. having control over formatting is useful
11:22:05 <Peaker> lament, Stallman does not control emacs completely -
11:22:07 <ehird> Peaker: and just try paredit, seriously
11:22:24 <lament> Peaker: anyawy. I think we got to the root of the problem when you mentioned temporarily incorrect programs.
11:22:35 <Peaker> ehird, getting a good programming editor is only a first stage - it should be good enough that non-programmers should be able to use it as a desktop interface
11:22:39 <lament> Peaker: because i think those are ESSENTIAL to a human.
11:22:51 <lament> Peaker: if you disallow them, you make editing a LOT harder
11:22:57 <Peaker> lament, Ofcourse - but logically incorrect, not syntatically incorrect
11:23:13 <Peaker> lament, Any examples of _syntatically_ incorrect programs you would want to go through?
11:23:28 <lament> Peaker: sure - a half-typed line :)
11:23:33 <Stinger_> stallman doesnt control emacs at all anymore iirc
11:23:37 <lament> int ma
11:23:37 <mm_freak_work> evening!  again many thanks  i love the haskell community for being the most helpful programmer community in IO =)
11:23:55 <Peaker> lament, With my editor, it would take much less work to create that variable
11:24:08 <ehird> Peaker: try paredit, don't talk about this until you do
11:24:22 <Peaker> ehird, I'm sorry, but I think I am allowed to take a look at it in my spare time :)
11:25:50 <Peaker> lament, you use "enter" for "insert a new statement here" - and then you get a <MissingStatement> node in your semantic model, for which the GUI widget opens up an incremental search - you type "ma", and you get some variables with "ma" in their name, you type or choose "C-l" (create new variable by this name, local). It automatically creates the definition in the function, with a <TypeYetUnknown> tag.  If you use "=" it puts it in an Assi
11:25:50 <Peaker> gnNode with a <MissingValue> on the other side. Then you use "5" on the MissingValue and it automatically fills the missing type above.
11:26:01 <ehird> Peaker: well, you should research it before  trying to discuss this
11:26:07 <Peaker> ehird, I am looking it up
11:26:15 <ehird> not look it up .. use it :)
11:26:20 <ehird> i gave youa url, too
11:26:36 <Peaker> ehird, According to the description, it seems to be a kludge that emulates a symptom of the system I am proposing, with only few of the benefits
11:26:40 <hpaste>  (anonymous) annotated "Return clause inference" with "(no title)" at http://hpaste.org/6691#a1
11:26:42 <ehird> Peaker: hardly
11:26:48 <ehird> it's proper pseudo-structural editing
11:26:49 <ehird> and it works great
11:26:57 <vegai> Peaker: what are the benefits?
11:27:05 <Peaker> ehird, what languages is it usable for?
11:27:08 <lament> Peaker: sounds like regular text editing but with more key presses :)
11:27:10 <ehird> Peaker: lisps
11:27:16 <ehird> Peaker: read the docs
11:27:18 <ehird> well
11:27:21 <ehird> you can use it in non-lisps
11:27:23 * mrd uses paredit all the time, but don't try telling that to emacs haters
11:27:24 <Peaker> lambdabot, far fewer key presses actually, do you want me to create a comparison table and show you? :)
11:27:26 <ehird> but itll require some customization
11:27:45 <ehird> Peaker: lambdabot disagrees with you.
11:28:16 <lament> Peaker: unlekely to be fewer key presses than with Intellisense :)
11:28:35 <ehird> Peaker: let's try:
11:28:52 <Peaker> vegai, A) you can run the program as it is being edited, significantly easing the use of abstractions, the learning curve, and debugging. B) you dismantle the presentation from the encoding of the program yielding: C) choose a view of your liking - if you prefer seeing functions inline or outside, its a view preference D) A chinese and American can edit the same program in different languages [names are just comments, and a variable can ha
11:28:52 <Peaker> ve several translations], and many many more
11:28:56 <ehird> <ENTER> 'm' 'a' 'r' 'k' <C-l> '=' '5'
11:28:57 <Peaker> oops
11:29:09 <Peaker> lament, With intellisense too, I've used that slow-ass hack :-
11:29:09 <ehird> 'i' 'n' 't' ' ' 'm' 'a' 'r' 'k' ' ' '=' ' ' '5'
11:29:11 <Peaker> lament, :-)
11:29:14 <ehird> but there's an impoertant thing
11:29:15 <lament> you can already run the program as it is being edited
11:29:18 <ehird> yours doesn't save TIME
11:29:21 <lament> you don't need a non-textual editor for that
11:29:22 <joricj> how do i store a collection of objects which aren't of the same type but *are* instances of the same class?
11:29:23 <ivant> @src map
11:29:23 <lambdabot> map _ []     = []
11:29:23 <lambdabot> map f (x:xs) = f x : map f xs
11:29:25 <ehird> the latter can be typed linearly
11:29:28 <ehird> no brain context switching
11:29:31 <Peaker> ehird, And you get to place it inside the expression you want to use - which saves a bunch of keypresses too
11:29:34 <ehird> the former requires more thinking and switching modes
11:29:53 <dolio> joricj: You'd have to use an existential type.
11:29:53 <ehird> Peaker: the latter is better
11:29:57 <vegai> Peaker: not exactly the same, but perhaps you might find Ted Nelson's Zigzag fascinating
11:29:58 <Peaker> ehird, You create the variable as part of any expression you need it in - no need to move to the right context for defining variables. Fewer context switches actually
11:30:21 <ehird> Peaker: it brings up a contextual search, you have to remember that C-l makes a new local
11:30:21 <ehird> etc
11:30:25 <ehird> it certainly does context switch
11:30:37 <joricj> dolio: what's that?
11:30:45 <Peaker> ehird, You have to remember where to declare variables, and the syntax, and I have to remember a single key press for the same
11:30:56 <Peaker> ehird, I think my system requires fewer context switches
11:30:57 <dolio> joricj: data ClassType = forall a. Class a => Constructor a ; list :: [ClassType]
11:31:04 <ehird> Peaker: 'int x = y'
11:31:05 <ehird> how hard
11:31:24 <Peaker> ehird, No, "ctrl-left, up, up, right, int x = y, down down, ... back to where I was"
11:31:31 <Peaker> ehird, then "x" again
11:31:47 <Peaker> ehird, or repeating the name you have just declared, actually
11:31:51 <ehird> Peaker: errrrrr
11:31:53 <Peaker> ehird, not a 1-letter thing, usually
11:32:12 <ehird> <C-p><C-d><Enter>int x = y<C-o>
11:32:14 <Peaker> with M-x, takes at least 3-4 redundant key presses, in addition to the navigation to the right place
11:32:15 <ehird> imaginary keybindings
11:32:20 <ehird> C-p == 'push location:'
11:32:27 <ehird> C-d == 'definition zone'
11:32:34 <ehird> C-o == 'pop location'
11:32:34 <Peaker> ehird, So now you have to remember syntax AND a bunch of keybindings :-)
11:32:38 <vegai> you could also use a pointing device
11:32:39 <Peaker> ehird, I have to remember just the key bindings
11:32:49 <ehird> Peaker: If you have to learn how it works, you have to learn how it works!
11:32:51 <ehird> Brilliant
11:32:53 <Peaker> ehird, and I only have key bindings that make sense - not ones that do utterly illogical things
11:32:56 <ehird> vegai: exactly
11:33:05 <ehird> mice are only slow if you are incompetent with them
11:33:06 <Peaker> vegai, a pointing device is extremely slow compared to a "c-l"
11:33:16 <ehird> Peaker: so you need to improve your mice skills
11:33:17 <vegai> Peaker: that's not what the plan 9 folks thought
11:33:27 <ehird> vegai: Plan 9! I like you <3
11:33:28 <vegai> I think they have actually researched it
11:33:33 * vegai smirks
11:33:38 <dolio> joricj: list = [Constructor foo, Constructor bar, Constructor baz, ...] -- where foo bar and baz don't have to have the same type
11:33:39 <Peaker> ehird, Moving the hand to a mouse, and moving the cursor to the right spot (requiring computer feedback from screen), and then back to keyboard is more time and mental effort than C-l"
11:33:52 <Peaker> vegai, researched what?
11:33:55 <ehird> Peaker: uhhh you suck at using a mouse
11:34:23 <ehird> Peaker: you still have to memorize syntax with yours. it just happens to be a syntax with loads of control characters layering over ANOTHER syntax that you also must understand to read it
11:34:29 <ehird> reading and writing the same syntax is better than 2 seperate ones
11:34:42 <Peaker> ehird, I can compete, I press C-a C-b C-c or C-d based on a flashing point in screen and you have to click it - who will be faster?
11:34:44 <ehird> Besides, why does the language require explicit types, and declarations to be at the start of the function?
11:34:51 <ehird> Hardly a good language.
11:34:52 <dolio> joricj: But once you do that, you can't get foo, bar or baz back at their original types. You can only use them through functions that operate on any member of Class.
11:34:56 <Peaker> ehird, there is ONLY the keyboard binding syntax, no "layers" of syntax
11:35:10 <ehird> Peaker: So when I look at it in the screen, I see keys?
11:35:15 <ehird> I doubt I would see 'C-l' in my program.
11:35:22 <ehird> I would see another syntax, the syntax that your syntax layers upon
11:35:23 <Peaker> ehird, actually, my demo editor for C did not present the declarations - but obviously would allow you to show/hide them as a _view_ choice
11:35:36 <Peaker> ehird, once you disconnect the presentation from the edited code, you can have interesting features more easily
11:35:37 <vegai> Peaker: I tried to look it up for you, but their wiki seems to be down .. *tsk*
11:35:43 <vegai> ok, not down. Just a bit slow
11:36:14 <vegai> stop browsing plan 9 wiki, #haskell! :P
11:36:21 <Peaker> ehird, What's shown on screen is disconnected from the internal representation of the program - and configurable. I can edit others' programs the way I like, rather than the way they like
11:36:40 <lament> Peaker: you can already disconnect the presentation from the edited code in lisp and smalltalk
11:36:42 <Peaker> ehird, I can inline functions or out-line them as a presentational thing. Its not a "syntax" really
11:36:42 <ehird> Peaker: your idea is very misguided, especially when people want to discuss code
11:36:45 <ehird> they can't discuss it easily
11:36:47 <ehird> esp. IRL
11:36:58 <ehird> not really interested in this discussion though!
11:37:03 <Peaker> ehird, why? People discuss entities by their names, from my experience
11:37:05 <Peaker> ehird, ok
11:37:08 <Peaker> lament, How can you do that?
11:37:14 <shag> hm, what happened to haskell.org? seems to be down for me ...
11:37:29 <ivant> @hoogle %
11:37:29 <lambdabot> Data.Ratio.(%) :: Integral a => a -> a -> Ratio a
11:37:34 <vegai> shag: I concur
11:37:39 <lament> Peaker: by converting into AST and back invisibly.
11:37:54 <Peaker> lament, also, remember that a better/faster "intellisense" is just the first step in my plan - the idea is to generalize it to be a user interface that gives users all the power of a programming language, without the learning curve
11:37:57 <ehird> Peaker: and because people look at each others code IRL
11:37:59 <ehird> isn't that suprising?
11:38:07 <Peaker> ehird, are you interested in the discussion or not?
11:38:11 <ehird> also, Peaker -- your user interface will have a huge learning curve
11:38:14 <ehird> you just don't realise it
11:38:29 <Peaker> ehird, how so?
11:38:36 <dmwit> People who have nothing better to do!
11:38:42 <dmwit> I have a question on sharing.
11:38:50 <Peaker> ehird, The UI is self-explaining - showing all possible keybindings/etc.  I have given the very initial demo to people and they were using it in minutes
11:38:52 <mrd> i like learning curves
11:38:56 <dmwit> It's longish, so I hpaste'd it last night: http://hpaste.org/6683
11:39:32 <ehird> Peaker's idea will not work. now i want to talk about interesting things! :)
11:39:47 <vegai> Peaker: ok, not a real paper, but something: http://plan9.bell-labs.com/wiki/plan9/Mouse_vs._keyboard/index.html
11:39:47 <dmwit> ehird: I have an interesting question! =)
11:39:51 <lambdabot> Title: Mouse vs. Keyboard (Plan 9 wiki), http://tinyurl.com/yc33pc
11:40:11 <ehird> dmwit: no idea sorry :D
11:40:17 <dmwit> =P
11:40:40 <dmwit> This stupid book is too hard for me. =P
11:40:45 <Peaker> ehird is wrong :)
11:40:56 <ehird> Peaker is wrong >:E
11:41:20 <vegai> Peaker: their claim (which I'm ambivalent about) is that a mouse feels slower because using it works on another cognitive level
11:41:31 <ehird> is anyone interested in a Web interface for TV?
11:41:52 <vegai> but is actually faster and allows richer interactions
11:42:04 <Peaker> vegai, anecdotally, I know many programmers, most of which are keyboard users. The few mouse users I know are impressively fast with the mouse, and yet still much slower than the keyboard users at getting most editing tasks done
11:42:10 <vegai> but perhaps it's wrong to compare acme with Visual Studio or beyond
11:42:17 <ehird> acme<3
11:43:27 <vegai> it's quite probable though that the keyboard/mouse input bandwidth is not your major bottleneck
11:43:36 <vegai> unless it's java you're writing
11:43:39 * vegai flees!
11:43:44 <Peaker> vegai, ofcourse sometimes it isn't. When it is, the keyboard is better. When it isn't, it doesn't matter
11:43:57 <ToRA> Peaker: are you talking about some existing real software or something hypothetical?
11:44:03 <ToRA> (sorry for jumping in mid-way through)
11:44:14 <dons> its simple though: the keyboard gives you O(1) indexing, while the mouse is continuous, and you've got to traverse N pixels to get anything done
11:44:23 <ehird> nobody web+tv?
11:44:40 <ehird> dons: you must move N milimeters to get to any key
11:44:43 <Peaker> ToRA, keyboard vs mouse is real. Programming UI is mostly hypothetical as I don't think anyone has created anything good enough yet. I have a tiny but IMO interesting demo of the general idea I'm persuing
11:44:49 <dmwit> Well, badly designed interfaces can be bad for both mouse and keyboard.
11:44:50 <ehird> the mouse and the keyboard can reduce the N dramatically
11:45:12 <dmwit> So you might as well compare interfaces designed well for the keyboard and interfaces designed well for the mouse.
11:45:19 <Peaker> the keyboard can be used from muscle memory, without closing a longer feedback loop with the computer
11:45:27 <vegai> depends on the task. Copypasting text from one position to another is faster in acme than any keyboard interface
11:45:37 <vegai> in acme with a mouse, that is
11:45:38 <dons> yeah, there's no muscle memory with the mouse, really
11:45:44 <dons> that's a huge issue, in fact
11:46:13 <pfoetchen> I don't think that the time you move your mouse realy has so much impact on the overall coding speed...
11:46:19 <dmwit> Mice don't have muscle memory as much, but they do involve the spatial memory.
11:46:25 <pfoetchen> most time is passed thinking or typing...
11:46:26 <vegai> pfoetchen: unless java!
11:46:31 <pfoetchen> ok ;)
11:46:37 <dmwit> Also, I tend to agree with pfoetchen. =)
11:46:50 <joricj> oh noes! Record update for the non-Haskell-98 data type `HubState' is not (yet) supported (it's an existential)
11:47:13 <lament> mice and theremins don't have muscle memory.
11:47:15 <Maddas> What do you mean with 'mice don't have muscle memory'?
11:47:26 <vegai> I hear java programmers are paid based on their WPM
11:47:48 <Maddas> What about things like mouse gestures? Is there anything that inherently prevents you from building muscle memory with a mouse?
11:48:07 <LeCamarade> Which is the commonest stack-based hardware architecture?
11:48:15 <LeCamarade> At least one GCC targets?
11:48:16 <dolio> joricj: Record update with existential types in general would be tricky.
11:48:26 <ehird> -- nobody i guess
11:48:33 * LeCamarade knows this is #haskell, but still.
11:49:04 <vegai> Maddas: ever played Arx Fatalis?
11:50:17 <ehird> nobodyyy? :(
11:52:04 <dmwit> ehird: What kind of people are you looking for?
11:52:11 <dmwit> Oh, web+tv.
11:52:39 <dmwit> ehird: I guess there's lots of web+tv interfaces sort of pre-made now; youtube et al.
11:54:27 <u_quark> is there a monadic version of until ?
11:54:43 <dons> not in the base library
11:54:52 <dons> they're easy to write though. just recuse until 'when' holds
11:55:35 <ehird> dmwit: oh, no.
11:55:40 <ehird> dmwit: I meant a web interface for TV
11:55:43 <ehird> (Tangible Values)
11:55:53 <dmwit> Oh!
11:55:55 <dmwit> heh
11:56:04 <dmwit> Yes, that's much more interesting.
11:56:24 <lament> haha
11:56:26 <ehird> dmwit: Indeed. But it's hard to decide if I want it to be like the GUI one, the CLI one, or something entirely different.
11:56:39 <ehird> i guess if a browser is powerful enough (ajax etc) I can completely mimic the gui interface.
11:56:41 <ehird> That would be interesting.
11:56:49 <lament> yay, haskell.org is back
11:56:53 <ehird> The CLI one would be a bit unwebby though, and I can't really think how to wedge TV stuff into something entirely different
11:58:26 <u_quark> ok tnx dons
11:59:11 <ivant> @hoogle newVar
11:59:11 <lambdabot> No matches found
11:59:25 <Maddas> vegai: Nope, I haven't.
11:59:47 <ehird> anyone have thoughts?
12:00:54 <paczesiowa> is it normal to have two different versions of one package (bytestring) registered with ghc?
12:01:36 <dcoutts_> paczesiowa: it's not uncommon
12:01:59 <gwern> can cause problems tho
12:02:17 <paczesiowa> I get GHCi runtime linker: fatal error, how is that for a problem:>
12:02:46 * gwern acknowledges that that would seem to be such a problem
12:03:09 <paczesiowa> I suppose, I should unregister old one?
12:03:58 <byorgey> the problem is most likely that some packages have been built using one version, and other packages have been built using the other
12:04:09 <gwern> wut byorgey said
12:04:12 <byorgey> then when you try to use them together, bam, linking errors =(
12:04:40 <ehird> nobody?
12:04:42 <paczesiowa> so unregister, and rebuild all the packages, got it
12:04:43 <byorgey> so just unregistering the old one won't fix it, unfortunately, you may have to rebuild some things afterwards as well
12:04:47 <byorgey> yup =)
12:05:32 <gwern> heh. when ehird was talking about TV, I thought he meant Tangible Variables
12:06:02 <paczesiowa> Values?
12:07:37 <dcoutts_> paczesiowa: the new cabal detects inconsistent deps that leads to the problem
12:08:23 <paczesiowa> dcoutts_: I think I found the problem, unmerging =bytestring-0.9.0.1 doesn't unregister that from ghc
12:09:23 <paczesiowa> dcoutts_: unmerging 0.9.0.4 does unregister, so I think it is ebuild's problem
12:09:24 <dcoutts_> paczesiowa: bytestring-0.9.0.1 is bundled with ghc
12:09:36 <dcoutts_> the ebuild cannot unregister the built-in one
12:09:52 <dcoutts_> besides it'd be a very ban plan
12:10:04 <dcoutts_> since there are undoubtedly other installed packages that use it
12:11:05 <ehird> gwern: I did, tangible values
12:11:17 <ehird> [i assume you typod]
12:13:52 <paczesiowa> so what should I do? I can't delete old bytestring, if I have both it fails to link. is the only solution to use the old one and rebuild all the packages with old one and mask new version?
12:14:21 <dcoutts_> paczesiowa: you can either rebuild things against the old or new
12:14:43 <dcoutts_> there's no problem leaving the old one installed if it's not being used
12:15:17 <dcoutts_> besides unregistering it would not change the fact that existing packages depend on it
12:15:31 <dcoutts_> though unregistering it would point out exactly which packages did depend on it
12:15:42 <dcoutts_> they'd all be marked as broken in the ghc-pkg list output
12:15:59 <paczesiowa> with parens?
12:16:05 <dcoutts_> with {}'s
12:16:06 <dcoutts_> but be warned, the ghc package uses bytestring-0.9.0.1 and it cannot be rebuilt
12:17:35 <mcnster> hi.  any gtk2hs geniui here?
12:17:51 <dcoutts_> mcnster: dunno about geniui, but maintainer, yes.
12:18:08 <hpaste>  ehird pasted "tv + web example" at http://hpaste.org/6692
12:18:16 <paczesiowa> dcoutts_: I think I had everythink rebuilt, but I'll try again
12:18:17 <ehird> view here: http://hpaste.org/6692/0/plain
12:18:20 <ehird> :)
12:18:42 <dcoutts_> paczesiowa: ghc-pkg field foobar depends  will tell you exactly what foobar depends on, including versions
12:18:47 <ehird> compare: http://www.haskell.org/sitewiki/images/6/65/ShoppingPr.png and http://hpaste.org/6692/0/plain
12:19:40 <mcnster> :) dcoutts_, i'm looking at *.ModelView.Custom store, and wondering if i can use it to implement a store on an inductive graph?
12:20:14 <dcoutts_> mcnster: hmm, tell me more about the data you're trying to visualise
12:20:20 <ehird> comments are welcome
12:20:50 <paczesiowa> dcoutts_: but I don't know which package pulls old bytestring, ghc-updater doesn't want to rebuild anything
12:20:57 <dcoutts_> mcnster: of course we can only display trees, so if you've got a graph it'd have to be some tree/forest
12:21:14 <dcoutts_> paczesiowa: no, gentoo doesn't know about versions of ghc libs
12:21:38 <dcoutts_> paczesiowa: building using the latest cabal would tell you
12:21:57 <dcoutts_> it'd give you a warning during configure about what packages are depending on inconsistent versions of dependencies
12:21:58 <mcnster> dcoutts_, sh3 assembler.  nodes would have opcodes, basic block definitions, etc, and edges would represent control flow
12:22:37 <ehird> nobody's interested :D
12:22:59 <dcoutts_> mcnster: you don't want to display it as a general graph? like using graphviz. I've used graphviz in a gtk2hs gui before (for results of constraint style typing analysis)
12:23:33 <paczesiowa> dcoutts_: I don't need/use cabal, I have simple Main.hs file (should I hpaste it?) which compiles&runs fine, but when I run main in ghci it fails to link
12:23:34 <dcoutts_> mcnster: it's not clear to me how you want to map your graph into a tree
12:24:05 <dcoutts_> paczesiowa: you'll notice that it fails while loading the second copy of bytestring
12:24:11 <paczesiowa> dcoutts_: yes
12:24:33 <dcoutts_> paczesiowa: perhaps you can work out which packages have not loaded yet, since it's one of those that depends on the other version of bytestring
12:24:56 <dcoutts_> paczesiowa: you should find it works fine when you link normally using ghc --make
12:24:57 <mcnster> dcoutts_, i want the interface to be a large flat list that i can scroll around and annotate with comments, variable naming, etc
12:25:23 <dcoutts_> paczesiowa: since the ordinary static linker doesn't mind if the fps C functions are defined multiple times, but ghci's linker doesn't like it at all
12:25:37 <mcnster> dcoutts_, so not really a tree at all--more like a ListStore
12:25:40 <dcoutts_> mcnster: oh, just a flat list
12:25:45 <dcoutts_> that's much easier then
12:26:48 <dcoutts_> mcnster: so you just make a store with the type of your custom data and then you set up some mappings from your custom data to display/view attributes
12:27:23 <dcoutts_> the mapping can be arbitrary haskell functions, though often they're just field accessors
12:27:35 <dcoutts_> mcnster: have you looked at the demos?
12:27:50 <mcnster> dcoutts_, that's what i tried to do, but i ran into some problems
12:28:00 <mcnster> none of the demos use CustomStores
12:28:55 <ehird> @type foldl ($)
12:28:59 <lambdabot>     Occurs check: cannot construct the infinite type: b = a -> b
12:28:59 <lambdabot>     Probable cause: `$' is applied to too many arguments
12:28:59 <lambdabot>     In the first argument of `foldl', namely `($)'
12:29:03 <ehird> @type foldl (>>=)
12:29:04 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> m b
12:29:27 <dcoutts_> mcnster: ah, right so you want a mutable store so you can make changes to it using the gui
12:29:33 <dcoutts_> mcnster: that's harder
12:29:36 <mcnster> particularly, i am puzzled by the CustomTreeNodeImplementation row type.  customTreeNodeGetRow hastype (TreeIter -> IO row).  how would it actually get the row?
12:29:44 <ehird> > fodll (>>=) [1,2,3] [return,return,return]
12:29:45 <lambdabot>   Not in scope: `fodll'
12:29:49 <ehird> > foldl (>>=) [1,2,3] [return,return,return]
12:29:51 <lambdabot>  [1,2,3]
12:29:52 <paczesiowa> dcoutts_: I think ghc package is the only thing that needs old bytestring, so if I need ghc(through hs-plugins) I can't do anything, right?
12:29:59 <ehird> > foldl (>>=) [1,2,3] [return . (2+)]
12:30:00 <lambdabot>  [3,4,5]
12:30:12 <ehird> @hoogle (Monad m) => m b -> [b -> m b] -> m b
12:30:12 <lambdabot> No matches, try a more general search
12:30:18 <ehird> humph
12:30:20 <ehird> it looks... kinda useful
12:30:21 <ehird> :D
12:30:24 <dcoutts_> paczesiowa: right, except go back to using the old bytestring everywhere, or use ghc --make (though hs-plugins always uses the ghci linker)
12:30:38 <dcoutts_> mcnster: so custom models have to do lots of stuff with mapping TreeIters to locations in your custom data structure
12:30:51 <ehird> @type foldl (>>=) xs $ map (const return) xs
12:30:52 <lambdabot> Not in scope: `xs'
12:30:52 <lambdabot> Not in scope: `xs'
12:30:56 <ehird> @type \xs -> foldl (>>=) xs $ map (const return) xs
12:30:57 <lambdabot> forall a. [a] -> [a]
12:31:00 <dcoutts_> mcnster: which is a bit of a pain since TreeIters are a fixed 96bit type
12:31:02 <ehird> hmmm what
12:31:14 <ehird> shouldn't that be [m b] -> m [b]
12:31:18 <paczesiowa> dcoutts_: thanks
12:31:47 <ehird> anyone have opinions on that tv+web?
12:31:58 <ehird> http://www.haskell.org/sitewiki/images/6/65/ShoppingPr.png (gui) vs http://hpaste.org/6692/0/plain (web)
12:32:27 <mcnster> dcoutts_, at this point, i am lost.  are my TreeIter's mapping into foreign space?
12:32:30 <gwern> @seen dons
12:32:30 <lambdabot> dons is in #ghc, #xmonad, #haskell-soc and #haskell. I last heard dons speak 37m 13s ago.
12:34:00 <dcoutts_> mcnster: TreeIters are a gtk type that are used to index into your model, so custom stores have to be able to look things up using these TreeIters like pointers into the structure
12:34:23 <dcoutts_> mcnster: eg for a simple list we just use the TreeIter as an index into the list, for trees it's more complex
12:34:52 <dcoutts_> mcnster: then you have to fill out a TreeModelIface with all the operations that the view needs to be able to access your model
12:35:37 <mcnster> dcoutts_, is this done in haskell or C?
12:35:54 <dcoutts_> mcnster: Haskell, see ModelView/ListStore.hs.pp
12:36:42 <ehird> nooobody?
12:36:53 <mcnster> dcoutts_, looking...
12:38:00 <ehird> :(
12:39:21 <mcnster> dcoutts_, this gives me something to chew on.  thanks much :)
12:39:25 <gwern> @ask dons I'm taking your suggestion about splitting out hmp3's curses binding as a portable curses library; I'm calling it 'nanocurses'.  what was it portable to besides Ncurses, Ocurses, and Irix? and do you want to be listed as maintainer?
12:39:25 <lambdabot> Consider it noted.
12:39:29 <dcoutts_> mcnster: np
12:45:20 <ehird> Surely this stuff must interest something :D
12:46:06 <gwern> @seen SamB
12:46:06 <lambdabot> SamB is in #xmonad, #perl6 and #haskell. I last heard SamB speak 17h 56m 38s ago.
12:46:55 <gwern> @ask SamB do you think maybe an upload of ZMachine to Hackage would be alright? I don't think my crash bug is going to get fixed, going by Igloo's comments: http://hackage.haskell.org/trac/ghc/ticket/2164
12:46:55 <lambdabot> Consider it noted.
12:47:34 <ehird> hmm
12:47:37 <ehird> Interface.TV.Web, right?
12:50:20 <Cale> ehird: This is conal's TV stuff?
12:50:35 <Cale> ehird: I didn't know that there was a web version of that :)
12:50:54 <ehird> Cale: Nope, I'm writing one
12:50:57 <ehird> And yep, conal's
12:51:11 <ehird> This GUI: http://www.haskell.org/sitewiki/images/6/65/ShoppingPr.png will look like this: http://hpaste.org/6692/0/plain
12:51:29 <ehird> Err, use firefox for that. Konqueror makes it really 0-width
12:51:30 <ehird> I will fix that.
12:52:08 <ehird> btw: i want to include a simple haskell webserver for development
12:52:20 <ehird> I just need something that lets me handle a GET or POST request.
12:52:31 <ehird> And provides easy access to e.g. POST form data.
12:56:10 <ehird> :/
12:57:04 <ehird> no? :)
12:57:44 <dafra> :)
12:57:49 <dafra> that works
12:58:12 <gwern> @hoogle (<+>)
12:58:12 <lambdabot> Did you mean: (<+>)
12:58:12 <lambdabot> Prelude.undefined :: a
12:58:12 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
12:58:57 <mauke> @hoogle <+>
12:58:57 <lambdabot> Control.Arrow.(<+>) :: ArrowPlus a => a b c -> a b c -> a b c
12:58:58 <lambdabot> Language.Haskell.TH.PprLib.(<+>) :: Doc -> Doc -> Doc
12:59:45 <ehird> sheesh :p
13:00:48 <gwern> @hoogle DocLike
13:00:48 <lambdabot> No matches found
13:01:21 <gwern> hm. so meachem has his own little parser library
13:02:15 <ehird> Oh come on, am I not alive? :p
13:02:50 <ehird> Hmm. iblechbot{,_} seems to be a logbot.
13:02:52 <ehird> Is that allowed?
13:02:57 <ehird> (albeit private)
13:03:52 <gwern> mauke: boy, it sure is quiet in here eh?
13:03:59 <gwern> @quote empty
13:03:59 <lambdabot> ghc says: Empty record update
13:04:41 <ehird> @quote tv
13:04:41 <lambdabot> mikaeli says: hmm, one national tv station I was watching while eating breakfast crashed with bsod. I guess that's what you get for running windows in production use
13:04:47 <ehird> @quote tv
13:04:47 <lambdabot> mikaeli says: hmm, one national tv station I was watching while eating breakfast crashed with bsod. I guess that's what you get for running windows in production use
13:04:52 <ehird> @quote tangible values
13:04:52 <lambdabot> No quotes for this person. My mind is going. I can feel it.
13:04:59 <ehird> @quote web
13:04:59 <lambdabot> qwe1234 says: good lord, help me. i feel like i'm trapped in a website full of elizabots.
13:05:09 <ehird> well that was a successful lambdaspam.
13:05:33 <gwern> dammit meachem, if you're going to make ginsu depend on other repos, make those repos cabal packages and do it right! don't leave big gaping emptiness in the repo so it doesn't build >.<
13:05:37 <cnwdup> Mh, is anyone using lighttpd with haskell's fastcgi module? lighttpd's configuration isn't working for me (http://mult.ifario.us/p/wiring-haskell-into-a-fastcgi-web-server) and the log doesn't help either.
13:05:38 <lambdabot> Title: wiring-haskell-into-a-fastcgi-web-server
13:06:05 <gwern> actually, what the hell is ginsu and why am I trying to compile it?
13:07:15 <gwern> l'Ginsu is a client for the gale chat system. It is designed to be powerful and above all stable, as well as having a quick learning curve. ' <-- ah
13:08:22 <gwern> ah. and gale itself is some sort of encrypted IRC/IM
13:09:03 <gwern> @hoogle UArray
13:09:03 <lambdabot> Data.Array.Unboxed.UArray :: data UArray i e
13:09:03 <lambdabot> Data.Array.ST.STUArray :: data STUArray s i a
13:09:03 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
13:09:14 <Eelis> a "quick curve" eh.
13:09:19 <olsner> heh, yeah, is a "quick curve" one that goes up fast?
13:09:52 <gwern> the question is, which has a quicker curve, vi, emacs or yi?
13:10:40 <skorpan> i'd say emacs
13:10:46 <skorpan> it also has the longest one
13:10:51 <skorpan> quickest and longest
13:10:53 <skorpan> (and thickest)
13:10:54 <mauke> http://mauke.ath.cx/stuff/img/lol,internet/curves.jpg
13:11:29 <skorpan> emacs has a nyquist learning curve
13:12:12 <skorpan> http://www.prosoundweb.com/install/sac/n26_4/nyquist/fig2.gif
13:12:38 <dons> Igloo: "   Hi Don.  Apparently it's not Haskell -- there was a power failure on
13:12:39 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:12:39 <dons>    campus that has brought most of the network down, although my connectivity
13:12:39 <dons>    seems Ok.  They are working on it."
13:12:47 <mrd> are we still talking about curves
13:13:08 <Igloo> dons: Hmm, OK, thanks
13:16:33 <dafra> hi all, newbie needs help with ST stuff
13:16:44 <paczesiowa> (hs-plugins question) why subsequent calls to load_ don't reload ? do I have to use reload and carry around those Module-wrappers ?
13:17:01 <dafra> can a STUArray live outside a monad ?
13:17:09 <thoughtpolice> paczesiowa: yes; you can carry around a Module and then call unloadAll (iirc that's the name) and then load_ again
13:18:02 <thoughtpolice> unloadAll will unload that modules and all accompanying ones (basically all the ones that were compiled if you called makeAll on some function)
13:19:22 <ehird> nobody?
13:19:45 <byorgey> dafra: sure, you could pass an STUArray around outside a monad, but you can't actually do anything with it outside a monad (other than just pass it along as-is)
13:21:26 <dafra> thanks byorgey, but how to do it ? Which value for the first type parameter ?
13:22:05 <Cale> That's not true actually. You can't usefully return an STUArray from a runST.
13:22:23 <Cale> You can however use runSTUArray
13:22:34 <Cale> Which will produce a UArray
13:22:34 <mrd> unsafeFreeze!
13:22:56 <mrd> runSTUArray just does an unsafeFreeze
13:23:00 <Cale> Better to use the safe wrapper though
13:23:09 <mrd> there's no reason
13:23:22 <mrd> the only reason to use the safe wrapper is if you are going to modify the STUArray after freezing it
13:23:23 <dafra> can teh array be unfrozen after that ?
13:23:55 <Cale> Why use unsafe operations when you don't have to?
13:24:06 <Jaak> faster?
13:24:11 <mrd> because it's much faster, and there's nothing unsafe about it
13:24:17 <Cale> It's not any faster though.
13:24:22 <mrd> it doesn't copy
13:24:29 <Cale> runSTUArray just calls unsafeFreeze
13:24:33 <mrd> right
13:24:37 <Cale> It just does so in a way which is safe.
13:25:00 <Philippa> and the fact it's already verified to be so is a good enough reason to use the safe wrapper
13:25:03 <mrd> hmm? you can't use runSTUArray if you are returning more than just an array.  otherwise, sure.
13:25:05 <ski> mrd : methinks Cale meant that `runSTUArray' *was* the safe wrapper
13:25:14 <Cale> Yes.
13:25:30 <mrd> @hoogle freeze
13:25:30 <lambdabot> Data.Array.MArray.freeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
13:25:30 <lambdabot> Data.Array.MArray.unsafeFreeze :: (Ix i, MArray a e m, IArray b e) => a i e -> m (b i e)
13:25:37 <mrd> thought you were talking about ^ freeze
13:26:41 <dafra> how to put a frozen STArray back into  monad ? (and freaze it again, and so on)
13:26:42 <ski> (.. there ought to be some way to freeze multiple things at the same time)
13:26:48 <ski> @hoogle thaw
13:26:48 <lambdabot> Data.Array.MArray.thaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
13:26:48 <lambdabot> Data.Array.MArray.unsafeThaw :: (Ix i, IArray a e, MArray b e m) => a i e -> m (b i e)
13:26:54 <ski> dafra : ^
13:27:17 <dafra> thaw ?
13:27:25 <dons> http://reddit.com/info/6drwn/details more xmonad stories
13:27:28 <Cale> There ought to be a  runSTArray' :: Ix i => (forall a. ST s (STArray s i e, a)) -> (Array i e, a)
13:27:33 <ski> (.. using a `runST..'-thing, i mean)
13:27:46 <Cale> and of course the same for unboxed arrays
13:28:19 <Cale> What the heck is castSTUArray for?
13:28:45 <Cale> It looks like some hideous combination of unsafeCoerce with array operations :)
13:29:02 <Jaak> dons: "Error establishing a database connection"
13:29:10 <Jaak> the reddit effect?
13:29:18 <mrd> yea, i use unsafeFreeze to implement runSTArray' basically.  it's really not unsafe, the only requirement is that you do not modify the array after calling it.
13:30:10 <Cale> mrd: That requirement is the unsafe bit ;)
13:31:31 <paczesiowa> thoughtpolice: thanks, do you know why can't I just use load_ again and forget that modulewrapper? I don't care if it gets recompiled unnecessary
13:32:28 <Cale> mrd: But runSTUArray' would be safe again, so I wonder why it's not in the library.
13:33:36 <visq> hi all, does someone know if (!) should be avoided as a user defined operator ? haddock 2 doesn't like it.
13:34:23 <allbery_b> ! is a strictness annotation
13:34:35 <visq> yes I know, but Data.Array uses ! as well
13:34:55 <paczesiowa> that depends on -XBangPatterns I think
13:34:56 <Cale> visq: I don't see any reason why it shouldn't be...
13:36:00 <visq> It's for an expression language, so a ! i ==> (ArrayAccess a i)
13:36:18 <Cale> Er, okay, yeah, if you have BangPatterns turned on, it will be a problem. Otherwise, it should be okay.
13:36:26 <ehird> Nobody cares about TV+web?
13:36:26 <dons> Jaak: scary
13:36:29 <ehird> (tangible values, web interface)
13:36:43 <Cale> ehird: Uh, I think it would be cool?
13:37:19 <lament> ehird: give a use case for it. Remote configuration of stuff?
13:37:36 <lament> Web 4.0?
13:37:57 <ehird> lament: You know. Tangible Values!
13:37:59 <ehird> Except on the web.
13:38:00 <ehird> Thingy.
13:38:07 <ehird> Cale: Comments on the example?
13:38:14 <lament> that... does not sound like a use case :)
13:38:18 <ehird> gui: http://www.haskell.org/sitewiki/images/6/65/ShoppingPr.png web: http://hpaste.org/6692/0/plain
13:38:43 <Cale> I get "URL Not Found or Bad Body"
13:38:52 <Cale> When I click on OK
13:39:17 <ehird> Cale: That might be because it's just the html example.
13:39:20 <thoughtpolice> paczesiowa: well, hs-plugins load facilities directly interface with the RTS linker, and at a guess I would say the linker has no primitive to reload; only load and unload
13:39:22 <Cale> ;)
13:39:25 <ehird> Cale: And is abusing hpaste's 'raw' feature. :p
13:39:32 <ehird> the source contains a comment
13:39:36 <ehird> really a question
13:40:15 <lament> i didn't realize hpaste's raw behaved that way. There's some potential for abuse.
13:40:16 <thoughtpolice> paczesiowa: but then again this is just only a guess
13:40:32 <visq> Cale: Why should this be a problem with bang patterns ? As ! isn't a constructor, i won't use it in patterns, right ?
13:40:40 <ehird> lament: Yep
13:40:48 <ehird> lament: Though the only cookies hpaste stores is the username.
13:40:50 <thoughtpolice> the RTS might have a primitive to reload, but if a module is already loaded and you try to load it again it will simply ignore it
13:41:03 <ehird> lament: And nobody 'trusts' a page just  because it's on hpaste
13:41:17 <dons> hs-plugins makes loading idempotent
13:41:19 <Cale> visq: If you write x ! y = ...  without bang patterns, you're defining the function (!). If you write it with bang patterns, you're defining the function x
13:41:23 <dons> the rts makes it an error
13:41:31 <thoughtpolice> dons: that clears it up then :)
13:41:59 <visq> ok, I can't use infix notation for the function definition.
13:42:11 <thoughtpolice> dons: duplicate symbol err at a guess?
13:42:33 <dons> yep
13:44:57 <paczesiowa> thoughtpolice, dons: thanks
13:51:00 <visq> Cale: Thanks, but it seems to be a bug in haddock 2.0.
13:51:16 <Cale> visq: yeah, that seems likely
13:51:22 <visq> Works fine with 0.8, but the latter doesn't support bang patterns (coincidence ;))
13:52:09 <gwern> hm. so 'x ! y' is different from 'x !y' but 'x + y' is the same as 'x +y'?
13:53:07 <visq> yes, in function definitions, with bang patterns enabled
13:54:06 <visq> but usually you won't redefine (!) anyway
13:54:10 <gwern> man. we should just make the haskell grammar enforce spaces between infix operators and other stuff
13:54:19 <gwern> too many edge cases
13:55:48 <Philippa> actually that's not a grammatical issue: it's the lexer that'd have to sort it out
13:56:29 * gwern stands corrected; I know nothing about parsing and that sort of thing, I'm afraidf
13:56:52 <visq> ah, x ! y isn't different from x !y
13:57:11 <visq> both are rejected with -fbang-patterns
13:57:24 <visq> and you have to use (!) x y = ...; sorry
13:58:52 * gwern groans. and if I suggested that sort of thing be cleaned up, I know it'd get shouted down because it'd break stuff like 'x+x', and no one cares enough to make it an option or something
13:58:57 <gwern> what an unsatisfactory situation
13:59:19 <mauke> Bigger is just something you have to live with in Java. Growth is a fact of life. Java is like a variant of the game of Tetris in which none of the pieces can fill gaps created by the other pieces, so all you can do is pile them up endlessly.
13:59:31 <Cale> ahaha
13:59:42 <Cale> @remember mauke Java is like a variant of the game of Tetris in which none of the pieces can fill gaps created by the other pieces, so all you can do is pile them up endlessly.
13:59:42 <lambdabot> Done.
14:00:01 <mauke> I didn't come up with it
14:00:38 <ahunter> Who did?
14:00:39 <gwern> sounds like a Yegge quote
14:00:55 <ahunter> Agreed, though could be from a number of his pieces
14:01:01 <mauke> I got it from /prog/
14:01:12 <dons> mauke: cute
14:01:13 <EvilTerran> i've seen it on TDWTF, i think
14:02:21 <ehird> anyone know who runs codepad.org?
14:02:26 <ehird> OT i know
14:03:09 <gwern> the geordi fellows
14:03:17 <gwern> the two show up here on occasion
14:03:25 <ehird> ah
14:03:34 * gwern can't remember their names offhand, but the logs no doubt will lay all bare
14:03:35 <ehird> awesame answered a question about it before iirc
14:03:44 <mauke> eelis?
14:03:46 <ehird> and he's in here, #geordi and #pylons
14:03:52 <ehird> so that seems like a decent bet
14:03:59 <gwern> awesame sounds like one of them
14:04:02 <ehird> whois sez Steven Hazel
14:04:36 <Eelis> yes, awesame wrote codepad.org
14:06:04 <ehird> okay
14:06:21 <ehird> awesame: http://codepad.org/09A2RJCH what's in this that it doesn't want to run?
14:07:46 <dons>   http://reddit.com/info/6ds1t/comments/ -- xmonad article back up
14:08:41 <mauke> argh, horrible code
14:08:45 <ehird> oh, anyone interested in the web framework i talked about yesterday: it will include a dsl for generating javascript
14:08:49 <ehird> mauke: sure, sure :)
14:08:52 <ehird> mauke: i wrote it in 2 minutes
14:08:55 <ehird> it's a cute hack.
14:08:57 <mauke> you did?
14:09:00 <ehird> yes
14:09:02 <mauke> stop using feof. now.
14:09:03 <skorpan> if i want a datatype "data A a = B a | C" where a must be instance of Eq, how do i do that? GADTs?
14:09:04 <dons> ehird: we've got one of those already!
14:09:13 <ehird> dons: yeah, but it doesn't do continuations
14:09:17 <dons> ah
14:09:18 <ehird> or quite a few other things i wan
14:09:19 <ehird> t
14:09:22 <dons> HJScript ?
14:09:28 <dons> HJavaScript?
14:09:34 <ehird> i'm inspired mainly by parenscript
14:09:46 <ehird> i will probably have to do some typesystem hackery; this should be possible:
14:09:48 <dons> more web support is always good
14:10:00 <ehird> do foo <- jsPrompt "abcdef"; jsAlert ("Hello, " ++ foo)
14:10:03 <paczesiowa> skorpan: existensial types
14:10:09 <ehird> oh yeah, and this:
14:10:18 <ehird> do foo <- jsHaskell (2+2); jsAlert (show foo)
14:10:21 <paczesiowa> existential I mean
14:10:25 <ehird> will compile down to a non-blocking ajax request
14:10:27 <ehird> :D
14:10:37 <paczesiowa> skorpan: http://www.haskell.org/haskellwiki/Existential_type there is example with Show
14:10:38 <lambdabot> Title: Existential type - HaskellWiki
14:10:51 <ehird> also, it will do tail call optimization
14:11:04 <ehird> foo(a,b,c); in tail -> setTimeout(function () { foo(a,b,c); }, 0);
14:11:09 <ehird> assuming the return value is () or something
14:11:16 <ehird> I may convert to CPS for TCO with returns
14:11:45 <idnar> ehird: that setTimeout transform doesn't look like an optimization to me
14:11:54 <skorpan> thanks paczesiowa
14:12:05 <ehird> idnar: um, yes
14:12:09 <ehird> it doesn't use up stack.
14:12:12 <ehird> setTimeout returns immediately.
14:12:14 <ehird> then the function returns
14:12:17 <idnar> I mean, it avoids blowing the stack, but it introduces confusing non-determinism into the code, and makes it slower
14:12:28 <ehird> idnar: hardly any non-determinism
14:12:35 <ehird> anyway, scheme->js compilers do that
14:12:39 <ehird> they work fine
14:12:39 <idnar> ehird: arbitrary code can be run before the tail call happens
14:12:44 <Saizan> skorpan: you don't need existential types in your case, since the 'a' is also a parameter of your type
14:13:00 <ehird> idnar: it's a good thing you can't mutate stuff in haskell then.
14:13:22 <idnar> ehird: but presumably you're doing IO at some point
14:13:42 <ehird> idnar: ok, so just synchronize it right
14:13:46 <ehird> well-written code will not have a problem
14:13:46 <paczesiowa> Saizan: but how to forbid calling constructors with non-Eq types?
14:14:09 <Saizan> data A a = Eq a => B a | C
14:14:18 <idnar> ehird: well, it shouldn't be the programmer's problem anyway
14:14:26 <idnar> ehird: your use of the word "optimization" just bugged me
14:14:33 <paczesiowa> Saizan: goow to know
14:14:37 <paczesiowa> *good
14:14:50 <paczesiowa> skorpan: listen to Saizan, not me:P
14:14:55 <ehird> idnar: tons of ->JS compilers do it
14:15:01 <ehird> anyway
14:15:04 <ehird> if I convert to CPS
14:15:04 <paczesiowa> skorpan: I just realised how stupid I am
14:15:08 <ehird> nothing else will run until the call does
14:15:10 <ehird> you'd do
14:15:17 <idnar> an explicit trampoline seems like a better idea to me than relying on setTimeout, but I guess that has tricky issues of its own
14:15:26 <ehird> setTimeout(function () { func(a,b,c,k); /* k is our continuation */ }, 0);
14:15:35 <Saizan> having (A a) won't imply Eq a though, or shouldn't in h98 at least
14:15:40 <ehird> then the call stack immediately goes to 0
14:15:43 <ehird> and goes to 1 again with func
14:15:48 <ehird> eventually goes to 0 when that one calls k
14:15:50 <ehird> then 1 again in k
14:15:51 <ehird> etc
14:16:30 <idnar> ehird: the main issue is that when you yield control back to the browser, arbitrary code can be run due to network/UI/etc. events
14:16:38 <idnar> as long as you're wrapping all of that, you can do the right thing
14:17:09 <idnar> but you might have to worry about the performance hit
14:17:23 <idnar> incidentally, most ->JS compilers are pretty broken :P
14:17:39 <trez> skorpan: how did the project go?
14:17:54 <Peaker> woah, gmail in firefox 3.0b is so fast! I always thought the network was the bottleneck, appearantly it was firefox...
14:18:11 <skorpan> trez: i got a 3 already but if i fix it up a bit until monday night i'll get a 4
14:18:15 <skorpan> trez: how did yours go?
14:18:16 <idnar> Peaker: didn't Fx3 change some network behaviour defaults?
14:18:40 <skorpan> i'll probably be assisting the introductory course on fp next semester
14:18:40 <Peaker> idnar, I don't know...
14:18:56 <trez> skorpan: got G which I'm glad with :)
14:19:02 <skorpan> :)
14:19:13 <skorpan> did you pass the exam?
14:19:18 <trez> no way :)
14:19:34 <skorpan> i heard only 12 people passed the exam.. unfortunately i wasn't one of them.
14:19:49 <trez> hehe
14:20:20 <ehird> idnar: so what SHOULD I do, then? :)
14:21:00 <idnar> ehird: get someone to fix the web :P
14:21:14 <idnar> ehird: but failing that, you're probably stuck with this sort of workaround
14:21:30 <ehird> idnar: Yeah, i want continuations built into the web somehow :p
14:24:41 <darrint> hey
14:24:49 <darrint> wrong channel
14:28:31 <darrint> Could someone elaborate on how exception predicates Control.Exception.asyncExceptions do what they do? The implementation doesn't appear to match the source code. http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Exception.html#ioErrors
14:28:32 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/3al3yh
14:32:43 <Cale> darrint: The implementation doesn't match the source code?
14:32:59 <darrint> Sorry. I meant the behavior I see doesn't seem to match the source code.
14:33:06 <Cale> darrint: hmm...
14:33:13 <Cale> darrint: Can you give an example?
14:33:24 <dolio> darrint: That's inside an '#ifdef __NHC__' block.
14:33:30 <dolio> The ones for GHC are elsewhere.
14:33:45 <paczesiowa> :t reload
14:33:48 <lambdabot> Not in scope: `reload'
14:34:35 <darrint> dolio: I see now. But #ifndef __NHC__ ones  don't look much better... but maybe I need to look closer.
14:35:00 <dolio> darrint: They at least have two cases each. :)
14:35:01 <darrint> Oh. I get it. Duh. Thanks.
14:35:19 <dolio> Apparently NHC only throws IOErrors.
14:35:23 <darrint> Much thanks. I can sleep at night now. :-)
14:38:40 <dons> ?time kosmikus
14:38:44 <lambdabot> Local time for kosmikus is Fri Mar 28 22:38:41 2008
14:40:38 <yav> does anyone know how to control the size of verbatim fonts in lhs2tex?
14:41:29 <MarcWeber> @seen beschmi
14:41:29 <lambdabot> I haven't seen beschmi.
14:45:29 <shapr> @seen simonpj
14:45:29 <lambdabot> I haven't seen simonpj.
14:47:14 <toyvo> I'm using the following modules: erc-track-mode, erc-track-minor-mode, erc-stamp-mode, erc-ring-mode, erc-readonly-mode, erc-pcomplete-mode, erc-noncommands-mode, erc-nickserv-identify-mode, erc-netsplit-mode, erc-message-english-flood-strict-mode, erc-menu-mode, erc-match-mode, erc-irccontrols-mode, erc-fill-mode, erc-button-mode, erc-autojoin-mode!
14:47:33 <Saizan> wrong channel?
14:48:24 <toyvo> not exactly, just hit a wrong command. sorry. my first time with this IRC client.
14:48:35 <toyvo> How do I use LambdaBot?
14:48:42 <mauke> @help
14:48:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:48:57 <EvilTerran> you can talk to her via pm, if you're identified
14:49:36 <toyvo> It's a she then.  OK.
14:49:50 <dancor> @pl \ x -> f (== x)
14:49:50 <lambdabot> f . (==)
14:49:54 <dancor> rite.
14:50:06 <dejones> @seen Cale
14:50:06 <lambdabot> Cale is in #haskell-overflow, #ghc and #haskell. I last heard Cale speak 16m 53s ago.
14:50:12 <Cale> hey
14:50:14 <awesame> ehird: looks like fgets uses dup internally, which isn't allowed
14:50:17 <dejones> hey Cale.
14:50:18 <dejones> :)
14:50:26 <dejones> I put you in my GSoC Student App
14:50:26 <dejones> hehe
14:50:30 <Cale> heh
14:50:36 <Cale> Am I signed up as a mentor?
14:50:42 <dejones> lol, nope
14:50:46 <EvilTerran> @vixen a/s/l?
14:50:46 <lambdabot> 19/f/California
14:50:56 <dejones> Cale: I wouldn't do that to ya without your permission, hehe
14:51:01 <Cale> heh
14:51:13 <dancor> @pl \ x -> f (== x . fst)
14:51:13 <lambdabot> f . (==) . (. fst)
14:51:18 <dancor> weird
14:51:18 <dejones> Cale: I put in there a "Thank you Cale!" when I mentioned that #haskell IRC channel is quite helpful, hehe.
14:51:33 <awesame> ehird: maybe I could safely allow dup, I'll have to think about it
14:51:34 <dejones> Cale: Just a small joke to make the Student app more interesting.  ;)
14:51:34 <Cale> I signed up a few years back but didn't end up working on anything. (But I still got the free shirt!) What's the project you're interested in doing?
14:51:38 <Cale> ah
14:51:39 <Cale> okay
14:52:09 <dejones> Cale: http://www.haskell.org/pipermail/haskell-cafe/2008-March/041061.html -- here's my updated brief proposal sent to haskell-cafe.
14:52:10 <ehird> awesame: as long as you memlimit it should be fine
14:52:10 <lambdabot> Title: [Haskell-cafe] Re: GSoC Project Proposal: Parallel Profiling Tools for GHC., http://tinyurl.com/3ac54t
14:52:37 <dejones> Cale: I think it is quite appropriate for me since I am not a Haskell expert, but more experienced at C, which this project will require.  :)
14:52:46 <kosmikus> dons: pong?
14:52:54 <dons> yav: kosmikus is here!
14:53:02 <Cale> Ah, that looks interesting, but I'd probably not be a great mentor for it, since I don't really know a lot about the GHC internals :)
14:53:14 <Heffalump> kosmikus: did you find someone to take over the HCAR?
14:53:22 <dejones> Cale: lol.  Yeah, Simon Marlow is the mentor for that project.
14:53:31 <Cale> ah, yeah, I was about to say that he'd be ideal
14:53:32 <yav> hey kosmikus, is there a way to control the size of verbatim fonts in lhs2tex?
14:53:37 <kosmikus> Heffalump: you want to do it?
14:53:51 <Heffalump> not really, but if there's a real shortage of volunteers I'll consider it
14:53:52 <dejones> Cale: Definitely.  Do you get to review the submitted student apps?
14:53:58 <kosmikus> yav: verbatim fonts?
14:54:05 <Heffalump> how much time does it take up?
14:54:06 <Cale> dejones: If I was signed up I probably could.
14:54:12 <yav> the haskell code (when generated with verbatim)
14:54:12 <dejones> lol
14:54:12 <kosmikus> Heffalump: funny that you ask. I've found someone interested just today.
14:54:36 <dejones> Cale: hehe.  it's alright, I just wanted you to see my "Thank you" to you in my student app.  ;)
14:54:44 <Cale> ah, cool :)
14:55:33 <kosmikus> yav: it's just using the standard TeX font sizes. so you should be able to use TeX commands to change it.
14:57:40 <ehird> sheesh
14:58:24 <Heffalump> kosmikus: well, let me know if it falls through
14:58:50 <kosmikus> Heffalump: thanks, I will. you'll be at Hac4, right?
15:00:08 <Heffalump> yep
15:01:24 <kosmikus> great
15:01:29 <kosmikus> me too
15:03:59 <yav> kosmikus: could you elaborate on the tex commands that i need to use?
15:06:29 <golubovsky> @seen ehird
15:06:29 <lambdabot> ehird is in #haskell. I last heard ehird speak 8m 49s ago.
15:06:53 <golubovsky> Hi all, Dimitry here
15:07:04 <Cale> hello
15:07:07 <ehird> golubovsky: hello
15:07:10 <ehird> that's the first time i've been @seen
15:07:32 <golubovsky> ehird: you mentioned the Javascript thing: are you interested (I am the developer)?
15:07:55 <ehird> golubovsky: perhaps? :p
15:08:43 <golubovsky> Well, I rarely have time to IRC, but watch logs. Could you send me e-mail to golubovsky at gmail dot com if you have questions?
15:08:46 <dancor> if i have multiple executables in my .cabal file that all depend on some file MyLib.hs, then MyLib.o is created anew for each one
15:08:56 <dancor> am i just doingitwrong, or is this a "feature"
15:09:26 <ehird> golubovsky: I do not know what you are talking about. :(
15:10:36 <golubovsky> I saw you (or at least someone put ehird in author field) tried a couple examples (both with errors) on Yhc web service
15:10:39 <Cale> ehird: Dmitry is the person working on the Haskell to Javascript compiler, iirc.
15:11:34 <thoughtpolice> dancor: it's the way cabal builds things
15:12:55 <kosmikus> yav: something like \small if you want it smaller or \large if you want it larger?
15:13:20 <Cale> heh, whoa
15:13:44 <Cale> Let me see if I can get this bug in the RPN calculator example to happen again. Something went nuts :)
15:13:45 * kosmikus will be away for a while now ...
15:14:07 <Cale> Yep.
15:14:48 <Cale> Put a couple of 2's on the stack, then rapidly click the + button a few times, and then it won't actually stop doing the addition.
15:14:54 <golubovsky> Cale: what bug? (I only tested in Firefox)
15:15:04 <yav> ksmikus: do i need to place that around each code block??? or is there a way to set a global option
15:15:10 <Cale> (it'll go into an infinite loop of addition)
15:15:57 <golubovsky> Cale: just tried 1 ^ 2 +, it did not hang.
15:16:15 <toyvo> are continuations in YHC->JS compiler actually done via window.setTimeout?
15:16:21 <Cale> Rapidly click the + button about 3 or 4 times.
15:16:34 <Cale> and it'll do way more than 3 or 4 additions :)
15:16:46 <Cale> hmm, it doesn't always happen
15:16:59 <golubovsky> toyvo: threads (continuatio-based) are done via  setTimeout, yes. No other way afaik
15:18:03 <golubovsky> cale: OK, got it. After about 15 presses on plus it went wild.
15:18:30 <golubovsky> Thanks for reporting. I'll take a look what's happening.
15:19:13 <golubovsky> All, sorry. I have to disconnect. If there are any questions please post in Cafe or in Yhc list
15:19:20 <golubovsky> Bye
15:28:07 <ehird> oh my thing isnt hs->js
15:28:12 <ehird> it's hs dsl which gens js
15:30:48 <darrint> Does the use of a typeclass in a data declaration always make deriving Eq not work?
15:32:07 <allbery_b> darrint: I think you need to force an Eq constraint on the typeclass member
15:32:23 <allbery_b> otherwise the compiler can't prove that it is possible to derive Eq
15:32:52 <toyvo> ehird: I need to look it up. Interesting.
15:33:15 <darrint> allbery_b: If I use no class constraint at all it works. This doesn't. data Msg i = (Eq i) => Msg i
15:33:54 <allbery_b> hm.  I'm not sure that can work in Haskell98.  GADTs do, I think
15:34:20 <darrint> hm. How would that work?
15:34:51 <Syzygy-> darrint: Shouldn'
15:35:03 <roconnor> > approxRational (toRational (1/sqrt 2)) (1/10)
15:35:06 <lambdabot>  2%3
15:35:10 <Syzygy-> darrint: Shouldn't it be more like data (Eq i) => Msg i = Msg i ?
15:35:26 <allbery_b> {-# LANGUAGE GADTs #-} data Msg i where Msg :: Eq i => i -> Msg i -- or something similar
15:35:51 <allbery_b> Syzygy-: doesn't that get you into "it can check it when creating a value but can't use it to deconstruct a value"?
15:36:04 <roconnor> > toRational (1/sqrt 2)
15:36:04 <Syzygy-> allbery_b: Possible.
15:36:05 <lambdabot>  6369051672525773%9007199254740992
15:36:10 <darrint> allbery_b: I thikn Syzygy-'s is what I needed.
15:36:22 <darrint> thanks for helping both of you.
15:37:55 <darrint> What I can't imagine is why the comiler accepted the first form. What could i possibly have expressed?
15:40:31 <roconnor> @check \x -> cos x = 1 - sin(x/2)^2
15:40:32 <lambdabot>  Parse error at "=" (column 13)
15:40:38 <roconnor> @check \x -> cos x == 1 - sin(x/2)^2
15:40:40 <lambdabot>  Falsifiable, after 1 tests: -1.0
15:40:51 <roconnor> @check \x -> cos x == 1 - 2*sin(x/2)^2
15:40:51 <lambdabot>  Falsifiable, after 3 tests: 1.5
15:41:00 <roconnor> cos 1.5
15:41:03 <roconnor> > cos 1.5
15:41:04 <lambdabot>  7.07372016677029e-2
15:41:17 <roconnor> > 1 - 2*sin(1.5/2)^2
15:41:18 <lambdabot>  7.073720166770303e-2
15:41:21 <mud-rb_> it's cos^2 x + sin^2 x = 1
15:42:51 <Jedai> @check \x -> abs( cos x - (1 - sin(x/2)^2) ) <= 0.00001
15:42:52 <lambdabot>  Falsifiable, after 0 tests: -3.25
15:43:11 <Jedai> @check \x -> abs( cos x - (1 - 2 * sin(x/2)^2) ) <= 0.00001
15:43:12 <lambdabot>  OK, passed 500 tests.
15:43:20 <Jedai> @check \x -> abs( cos x - (1 - 2 * sin(x/2)^2) ) <= 0.0000001
15:43:20 <lambdabot>  OK, passed 500 tests.
15:43:44 <kosmikus> yav: try with the following line:
15:43:46 <kosmikus> yav: %subst verbatim a = "\begin{tabbing}\tt\small'n" a "'n\end{tabbing}'n"
15:43:58 <roconnor> @check \x -> abs (cos x - 1 - 2*sin(x/2)^2) < sqrt (encodeFloat 1 (-floatDigits x))
15:43:59 <lambdabot>  Falsifiable, after 0 tests: -3.0
15:44:01 <kosmikus> yav: after %include lhs2TeX.fmt
15:44:14 <roconnor> @check \x -> abs (cos x - (1 - 2*sin(x/2)^2)) < sqrt (encodeFloat 1 (-floatDigits x))
15:44:14 <lambdabot>  OK, passed 500 tests.
15:44:16 <kosmikus> yav: and replace \small by the size command you want
15:46:30 <yav> ksmikus: this seems to work only for the first line in code blocks
15:50:26 <mithraic> Does anyone know of a simple, decent, pure Javascript syntax highlighter for Haskell?
15:52:55 <yav> kosmikus:  did i do something wrong?
16:05:12 <gwern> mithraic: not off hand. the closest I can suggest is the javascript highlighter from http://johnmacfarlane.net/repos/highlighting-kate
16:05:13 <lambdabot> Title: Index of /repos/highlighting-kate/
16:05:14 <gwern> which is derived from the kate editor
16:06:01 <mithraic> Thanks, gwern. Will check it out.
16:06:38 <mithraic> I have a hacked-up keyword-and-strings only version of http://code.google.com/p/syntaxhighlighter/ at the moment.
16:06:39 <lambdabot> Title: syntaxhighlighter - Google Code
16:27:12 <Peaker> "cabal: ghc version >=6.2 is required but the version of /usr/bin/ghc could not be determined."  can't it call /usr/bin/ghc --version ?
16:47:15 <Lemmih> Peaker: What does /usr/bin/ghc --version say?
16:47:37 <Peaker> $ /usr/bin/ghc --version -> The Glorious Glasgow Haskell Compilation System, version 6.8.2
17:03:07 <JoshTriplett> Cale: By the way, we figured out a good solution to our instances problem from yesterday.
17:03:35 <JoshTriplett> Cale: Rather than defining an instance of SqlTypes a for any SqlType a, we just defined one for the couple of types we cared about, such as String and Integer.
17:21:41 <Botje> @vixen did zombies take over?
17:21:41 <lambdabot> first you tell me.
17:22:49 <TomMD> A Friday night and people have better things to do than #haskell?  I guess thats a good sign.
17:23:36 <monochrom> Yeah, the better thing is reading haskell-cafe.
17:23:38 <Botje> it's saterday morning here :)
17:24:44 <Jaak> morning?
17:24:55 <Jaak> @localtime
17:24:58 <lambdabot> Local time for Jaak is Sat Mar 29 02:24:02 2008
17:25:38 <monochrom> Indeed good morning Jaak. :)
17:26:25 <TomMD> And those US West coasters are probably just getting home from work.  Not that anyone on the west coast uses Haskell...
17:26:31 * sebell is waiting for potatoes to cook
17:27:10 <lament> i'm still at work
17:27:14 <lament> (west coast)-
17:27:39 <TomMD> lament: But do you program Haskell at work?
17:27:45 <JoshTriplett> TomMD: *raises a hand*
17:27:54 <JoshTriplett> TomMD: (West coast here too.)
17:28:01 <sebell> Me too -- and I'm at least in the Rocky Mountains...
17:28:12 <TomMD> If you program Haskell at work then you really can't call it work, can you?
17:28:28 <sebell> TomMD: Meetings. Definitely work :)
17:28:37 <TomMD> Sure, but meetings /= Haskell
17:28:55 <TomMD> Heck, one is a variable while the other is a type!
17:28:58 <lament> TomMD: no :(
17:30:14 <kpreid> @pl map fst . filter snd . zip xs
17:30:14 <lambdabot> map fst . filter snd . zip xs
17:30:42 <kpreid> any way to make that prettier?
17:30:46 <Peaker> ./cabal --version => cabal-install version 0.4.4 using version 1.3.7 of the Cabal library    and   ./cabal install yi => Setup.hs:25:35: Not in scope: `buildVerbose'   and a bunch of other symbosl
17:31:09 <kpreid> I have a list of values and a list of booleans, and I want to select only the items with a corresponding true boolean
17:31:35 <mauke> filter, zip
17:31:44 <Botje> that's pretty much the only way
17:31:51 <Botje> you could use a parallel list comprehension, if you want
17:31:58 <mauke> actually, concatMap + zip
17:32:38 <JoshTriplett> kpreid: @pl \xs -> map fst . filter snd . zip xs
17:32:43 <JoshTriplett> @pl \xs -> map fst . filter snd . zip xs
17:32:43 <lambdabot> ((map fst . filter snd) .) . zip
17:32:48 <EvilTerran> [x | (True, x) <- zip bools vals]
17:32:51 <JoshTriplett> Ugly though.
17:32:53 <EvilTerran> is how i'd write it
17:33:00 <kpreid> JoshTriplett: that's no shorter in context
17:33:15 <JoshTriplett> kpreid: mapMaybe.
17:33:23 <JoshTriplett> kpreid: That'll do what you want.
17:33:25 <Peaker> what does @pl do?
17:33:32 <TomMD> pointless
17:33:33 <Riastradh> It's pointless.
17:33:34 <kpreid> EvilTerran: I like. too bad I'd have to add \vals ->
17:33:35 <EvilTerran> ?hoogle mapMaybe
17:33:35 <lambdabot> Data.Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
17:33:35 <lambdabot> Data.Map.mapMaybe :: Ord k => (a -> Maybe b) -> Map k a -> Map k b
17:33:35 <lambdabot> Data.IntMap.mapMaybe :: (a -> Maybe b) -> IntMap a -> IntMap b
17:33:44 <Peaker> pointless what?
17:33:48 <Peaker> @pl 5*5
17:33:49 <lambdabot> 25
17:33:53 <Peaker> expands things?
17:34:07 <kpreid> Peaker: it removes points, a.k.a. variable bindings
17:34:14 <mauke> @pl \x -> f x x
17:34:14 <lambdabot> join f
17:34:19 <kpreid> @pl \a b -> a + b
17:34:19 <lambdabot> (+)
17:34:22 <TomMD> Peaker: In otherwords it will try and turn your equation from an: func arg = func1 (func2 arg) to a func = func1 . func2 format.
17:34:23 <EvilTerran> ?type (catMaybes.) . zipWith ((>>).guard)
17:34:26 <lambdabot> forall b. [Bool] -> [Maybe b] -> [b]
17:34:27 <Peaker> Ah, thanks
17:35:05 <Peaker> how does it work?
17:35:13 <kpreid> I think I'll stick with what I have; none of the others happen to fit as well
17:35:13 <TomMD> quickly and correctly.
17:35:14 <EvilTerran> ?type (catMaybes.) . zipWith (((>>).return.).guard)
17:35:15 <lambdabot>     The operator `.' [infixr 9] of a section
17:35:15 <lambdabot>         must have lower precedence than the operand `(.)' [infixr 9]
17:35:15 <lambdabot>         in the section: `((>>) . return .)'
17:35:22 <EvilTerran> hm. never mind.
17:35:23 <JoshTriplett> kpreid: One moment please.
17:35:26 <kpreid> Peaker: it has a bit collection of rules
17:35:37 <Peaker> kpreid, oh, it knows "join" specifically, for example?
17:35:37 <Jedai> Peaker: It's a pun on "pointfree style" which is a style where you avoid "point" (parameters) in your functions (leading to a filter-like impression), its detractors call this style "pointless"
17:35:42 <kpreid> Peaker: a *complete* collection, though
17:35:48 <Peaker> kpreid, I thought it looked for code isomorphisms
17:36:00 <kpreid> Peaker: first it eliminates the lambdas, then it optimizes the result
17:36:14 <kpreid> things like join are done by the optimizer
17:36:23 <kpreid> Peaker: I also wrote @unpl which does the inverse
17:36:31 <Botje> @pl \(x,y) -> (x+1,y)
17:36:31 <lambdabot> first (1 +)
17:36:37 <TomMD> @unpl filter
17:36:37 <lambdabot> filter
17:36:49 <Peaker> @src first
17:36:49 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:36:54 <TomMD> @unpl map (+1) . filter (==1)
17:36:55 <lambdabot> (\ e -> map (\ a -> a + 1) (filter (\ b -> b == 1) e))
17:37:00 <TomMD> eep
17:37:15 <Peaker> but "pointless" seems like a bad name as it seems to convert everything to use compositions?
17:37:16 <Jedai> Peaker: first comes from Control.Arrow
17:37:18 <mauke> the problem is that unpl doesn't look at types and so doesn't collapse monadic ops
17:37:24 <kpreid> Peaker: different sense of "point"
17:37:39 <kpreid> mauke: patches welcome!
17:37:57 <mauke> @. unpl pl \x -> f x x
17:37:57 <lambdabot> (f >>= \ a -> a)
17:38:02 <Riastradh> Peaker, read the dot `.' in compositions as the small circle often found in mathematical notation.
17:38:07 <Jedai> Peaker: A "point" in a function is an explicit parameter like xs in "squareList xs = map (^2) xs"
17:38:37 <mauke> @. unpl pl \x -> f (g x x)
17:38:37 <lambdabot> (\ c -> f ((g >>= \ d -> d) c))
17:38:41 <Peaker> Jedai, ah, ok
17:38:42 <Jedai> Peaker: The pointfree translation remove the point : "squareList = map (^2)"
17:38:46 <JoshTriplett> > let f = catMaybes $ zipWith (\x y -> if x then Just y else Nothing) in f [True, False, True] [1,2,3]
17:38:47 <lambdabot>  Couldn't match expected type `[Maybe a]'
17:38:53 <roconnor> @check \n d -> abs (ln (n/d) - (2*atanh((n-d)/(n+d)) < sqrt (encodeFloat 1 (-floatDigits x))
17:38:53 <lambdabot> Unbalanced parentheses
17:39:01 <roconnor> @check \n d -> abs (ln (n/d) - (2*atanh((n-d)/(n+d))) < sqrt (encodeFloat 1 (-floatDigits x))
17:39:01 <lambdabot> Unbalanced parentheses
17:39:09 <roconnor> @check \n d -> abs (ln (n/d) - (2*atanh((n-d)/(n+d)))) < sqrt (encodeFloat 1 (-floatDigits x))
17:39:10 <lambdabot>   Not in scope: `ln'
17:39:23 <roconnor> @check \n d -> abs (log (n/d) - (2*atanh((n-d)/(n+d)))) < sqrt (encodeFloat 1 (-floatDigits x))
17:39:23 <lambdabot>   add an instance declaration for (RealFloat Expr)
17:39:27 <Peaker> why is catMaybes needed? Can't sequence be used?
17:39:39 <roconnor> Expr?
17:39:46 <Riastradh> `ln'?
17:39:53 <kpreid> @type sequence
17:39:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:40:13 <roconnor> @check \(n::Double) (d::Double) -> abs (log (n/d) - (2*atanh((n-d)/(n+d)))) < sqrt (encodeFloat 1 (-floatDigits x))
17:40:13 <lambdabot>  Parse error in pattern at "(d::D..." (column 14)
17:40:28 <roconnor> @check \n d -> abs (log (n/d) - (2*atanh((n-d)/(n+d)))) < (sqrt (encodeFloat 1 (-floatDigits x))::Double)
17:40:28 <lambdabot>   add an instance declaration for (RealFloat Expr)
17:40:29 <Jedai> let f = catMaybes . zipWith (\x y -> if x then Just y else Nothing) in f [True, False, True] [1,2,3]
17:40:34 <Peaker> > catMaybes [Just 5, Just 6]
17:40:35 <lambdabot>  [5,6]
17:40:37 <Jedai> > let f = catMaybes . zipWith (\x y -> if x then Just y else Nothing) in f [True, False, True] [1,2,3]
17:40:37 <lambdabot>  Couldn't match expected type `[Maybe a]'
17:40:40 <Peaker> > sequence [Just 5, Just 6]
17:40:41 <lambdabot>  Just [5,6]
17:40:43 <Peaker> oh
17:41:06 <Peaker> > catMaybes [Nothing, Just 5]
17:41:07 <lambdabot>  [5]
17:41:11 <JoshTriplett> > let f bools items = catMaybes $ zipWith (\x y -> if x then Just y else Nothing) bools items in f [True, False, True] [1,2,3]
17:41:11 <lambdabot>  [1,3]
17:41:23 <JoshTriplett> kpreid: Does that do what you want?
17:41:25 <Jedai> > let f xs ys = catMaybes $ zipWith (\x y -> if x then Just y else Nothing) xs ys in f [True, False, True] [1,2,3]
17:41:25 <lambdabot>  [1,3]
17:41:27 <Peaker> catMaybes is really filterNothings isn't it?
17:41:36 <kpreid> JoshTriplett: yes, but that's not exactly shorter or nicer :-)
17:41:39 <JoshTriplett> Peaker: That and it removes the Just from the Justs.
17:41:45 <kpreid> JoshTriplett: here's the program:
17:41:48 <JoshTriplett> kpreid: Fair enough.
17:41:49 <Peaker> catMaybes [Nothing::Maybe Int]
17:41:52 <Peaker> > catMaybes [Nothing::Maybe Int]
17:41:53 <lambdabot>  []
17:41:54 <kpreid>  continuous = null . dropWhile not . dropWhile id . dropWhile not
17:41:55 <kpreid>  ncs xs = map (map fst . filter snd . zip xs) $ filter (not.continuous) $ mapM (const [False,True]) xs
17:41:58 <roconnor> @type \n d -> abs (log (n/d) - (2*atanh((n-d)/(n+d)))) < (sqrt (encodeFloat 1 (-floatDigits x))::Double)
17:41:59 <lambdabot>     No instance for (RealFloat Expr)
17:41:59 <lambdabot>       arising from a use of `floatDigits' at <interactive>:1:74-86
17:41:59 <lambdabot>     Possible fix: add an instance declaration for (RealFloat Expr)
17:42:11 * roconnor hates Expr
17:42:18 <JoshTriplett> > @pl \bools items -> catMaybes $ zipWith (\x y -> if x then Just y else Nothing) bools items
17:42:18 <lambdabot>  Parse error at "@pl" (column 1)
17:42:21 <JoshTriplett> @pl \bools items -> catMaybes $ zipWith (\x y -> if x then Just y else Nothing) bools items
17:42:21 <lambdabot> (catMaybes .) . zipWith (flip flip Nothing . (. Just) . if')
17:42:26 <mauke> roconnor: then don't use x
17:42:33 <roconnor> oh right
17:42:35 <JoshTriplett> OK, that didn't get better. :)
17:42:36 <roconnor> thanks
17:42:40 <roconnor> @type \n d -> abs (log (n/d) - (2*atanh((n-d)/(n+d)))) < (sqrt (encodeFloat 1 (-floatDigits n))::Double)
17:42:41 <lambdabot> Double -> Double -> Bool
17:42:52 <roconnor> @check \n d -> abs (log (n/d) - (2*atanh((n-d)/(n+d)))) < (sqrt (encodeFloat 1 (-floatDigits n)))
17:42:52 <lambdabot>  Falsifiable, after 0 tests: -0.5, 1.0
17:42:56 <dino-> Not just filter Nothings but also unpack the values from the Just
17:43:29 <roconnor> @check \n d -> abs (log (n/d) - (2*atanh(((n-d)/(n+d))^2))) < (sqrt (encodeFloat 1 (-floatDigits n)))
17:43:30 <lambdabot>  Falsifiable, after 0 tests: -1.5, 2.0
17:43:38 <Peaker> yeah, I see..
17:43:49 <roconnor> oh right
17:44:08 <roconnor> @check \n d -> 0 < n && 0 < d ==> abs (log (n/d) - (2*atanh((n-d)/(n+d)))) < (sqrt (encodeFloat 1 (-floatDigits n)))
17:44:09 <lambdabot>  Arguments exhausted after 295 tests.
17:44:25 <Peaker> catMaybes -> extractJustValues ?
17:44:45 <Peaker> any "yi" users here?
17:45:36 <Jedai> Peaker: Yes, extractJustValues describes what it does
17:46:14 <kpreid> catMaybes xs = [x | Just x <- xs]
17:46:19 <kpreid> @src catMaybes
17:46:19 <lambdabot> catMaybes ls = [x | Just x <- ls]
17:46:22 <kpreid> hah
17:46:54 <Peaker> why does that not fail on failed pattern matches on Nothing?
17:47:05 <Peaker> failures in list comprehensions just call List.fail (e.g []) ?
17:47:18 <kpreid> yes
17:47:21 <Peaker> cool
17:47:59 <dino-> Ah, and the comprehension just conses those in. neat  I didn't know that's how that was defined.
17:48:00 <kpreid> > let catMaybes xs = [x | Just x <- xs] in catMaybes [Nothing,Just 1]
17:48:01 <lambdabot>  [1]
17:48:02 <Peaker> why would the cabal build of "yi" fail on the lack of the symbol "buildVerbose"?   (./cabal --version => cabal-install version 0.4.4 using version 1.3.7 of the Cabal library)
17:48:07 <kpreid> > let catMaybes xs = [x | ~(Just x) <- xs] in catMaybes [Nothing,Just 1]
17:48:08 <lambdabot>   Irrefutable pattern failed for pattern (Data.Maybe.Just x)
17:48:15 <kpreid> Peaker: tada, failure
17:48:16 <mauke> > (\xs -> do Just x <- xs; return x) [Just 1, Nothing, Just 2, Nothing]
17:48:16 <lambdabot>  [1,2]
17:48:33 <Peaker> kpreid, what does ~ do again?
17:48:42 <kpreid> Peaker: it makes the pattern behave like a let-bound pattern
17:48:54 <Peaker> kpreid, ah
17:49:05 <kpreid> makes it matched "lazily" or "assume it succeeds"
17:50:49 <Peaker> kpreid, thanks
17:51:11 <Peaker> does "yi" support advanced Haskell editing features?  using type knowledge to suggest meaningful/callable functions, etc?
17:52:23 <allbery_b> I think that's planned but not implemented yet ("coders wanted")
17:53:58 <kpreid> http://www.rosettacode.org/wiki/Non_Continuous_Subsequences#Haskell -- I looked at the first version of this and thought "there's got to be a better way"
17:54:00 <lambdabot> Title: Non Continuous Subsequences - Rosetta Code, http://tinyurl.com/3drgkg
17:54:02 <kpreid> so I wrote it
18:06:15 <Peaker> Haskell needs docstrings
18:06:40 <Peaker> does ghci have a @src equivalent?
18:06:49 <Igloo> No
18:07:03 <Igloo> :i will tell you which module it's defined in, though
18:07:08 <allbery_b> not directly.  (does goa work these days?)
18:07:15 <Igloo> Oh, wait, :list will work for interpreted code
18:09:26 <Peaker> Could be nice to have Python's help() equivalent
18:09:43 <dons> i agree.
18:09:56 <dons> get the haddocks in ghci, that'd be nice
18:10:00 <dons> people keep asking for help()
18:11:46 <lament> docstrings are the best feature of python
18:12:04 <mauke> > help map
18:12:04 <lambdabot>  DENIED.
18:12:11 <lament> (also of lisp, i suppose)
18:12:19 <Jaak> @type help
18:12:20 <lambdabot> forall t a. t -> Sym a
18:12:25 <Jaak> uh...
18:12:37 <dino-> What is this docstring?
18:13:18 <lament> dino-: a string that you can put in a function (or in other things) to describe its purpose.
18:13:32 <lament> dino-: later you can access it using the help() function.
18:13:43 <dino-> I guess many many years of Java got me used to keeping HTML API docs open a lot.
18:14:17 <allbery_b> I think that would be Hard for Haskell, unless maybe by teaching ghc/i about haddock markup
18:14:36 <Peaker> kpreid, took me a few minutes to decipher what you were doing there (being a Haskell newbie and all :-).. That's pretty awesome :)
18:14:43 <lament> haskell doesn't _have_ docstrings, so of course it's hard
18:15:27 <dino-> But you're saying this help() is called at runtime?
18:15:40 <lament> it's usually called from the REPL
18:16:20 <Peaker> dino-, in Python, yes. In Haskell, it can be either a ghci :func or a runtime
18:17:30 <Peaker> dino-, lots of Python editors also show you the docstring of a function when you are typing a call to it
18:17:36 <Peaker> dino-, which is a nice quick reference
18:17:37 <allbery_b> in haskell your choices are to teach ghci about haddock markup or having modules optionally export a _help_strings :: String -> Maybe String or similar
18:17:52 <dino-> That part, what you said there, could probably be done with the existing Haddock comments.
18:18:00 <dino-> diving into them in an editor
18:18:18 <Peaker> dino-, Intellisense/Visual Studio does this for C/C++ code, so yeah
18:18:48 <allbery_b> emacs' cperl-mode does something similar based on perldoc
18:24:36 <smtms> win 1
18:38:57 <hpaste>  dolio annotated "question about sharing" with "sharing O(log n)?" at http://hpaste.org/6683#a1
18:40:05 <dolio> @seen dmwit
18:40:05 <lambdabot> I saw dmwit leaving #xmonad and #haskell 6h 41m 41s ago, and .
18:52:28 <roconnor> > 68*atan(1/23) + 32*atan(1/182) + 40*atan(1/5118) + 20*atan(1/6072)
18:52:28 <lambdabot>  3.141592653589793
18:52:58 <phlpp> lol
18:53:32 <dolio> @tell dmwit I've annotated your sharing question with a solution I'm not at all confident in, but it looked like to got the right answer for the few data points I tested. :)
18:53:33 <lambdabot> Consider it noted.
18:57:04 <roconnor> > 176*atan(1/57) + 28*atan(1/239) - 48*atan(1/682) + 96*atan(1/12943)
18:57:05 <lambdabot>  3.141592653589793
18:58:44 <ari> > pi
18:58:45 <lambdabot>  3.141592653589793
18:58:52 * ari tips hat
19:00:46 <roconnor> ari: ah, much shorter.
19:06:11 <dolio> > 176*atan(1/57) + 28*atan(1/239) - 48*atan(1/682) + 96*atan(1/12943) == pi
19:06:14 <lambdabot>  False
19:06:36 <Peaker> floats suck :-(
19:07:34 <Peaker> too bad math is so undecidable
19:08:41 <mud_rb__> are those actually equal?
19:10:09 <roconnor> it is my definition of pi.
19:10:45 <mud_rb__> haha, is it exact though, or a reasonable approximation?
19:10:51 <Peaker> I donno, but if you used an integral on the area of a half circle of radius=1, and compared that to half pi that wouldn't work either
19:11:46 <roconnor> it is exact by definition. :P
19:11:48 <Peaker> what's the integral of y=sqrt (1 - (x^2)) ?
19:12:09 <roconnor> over what bounds?
19:12:40 <Peaker> I just want an expression +C.. such that deriving it will yield that
19:12:45 <Peaker> but you can use -1..1
19:12:51 <Peaker> that should be pi/2
19:13:01 <EvilTerran> ask mbot in a private message or something
19:13:35 <Peaker> EvilTerran, I don't know how
19:13:48 <EvilTerran> (is that the one that does maple or mathematica or something? i forget)
19:14:07 <phlpp> \int sqrt (1 - x^2)) = \int (1-x^2)^0.5 = (2/3)*(1-x^2)^1.5
19:14:10 <phlpp> ?
19:14:21 <phlpp> -2/3
19:14:37 <phlpp> na, that's wrong :o
19:15:29 <Peaker> y=sqrt (1-x^2) defines a half circle of radius=1 around 0,0.  (x^2+y^2=1).  so the integral of it -1..1 should yield pi/2
19:15:57 <phlpp> Peaker:
19:15:59 <phlpp> 03:15:11 <mbot> phlpp: (x*Sqrt[1 - x^2] + ArcSin[x])/2
19:16:10 <Peaker> that's cheating, it put trig in there :)
19:16:27 <mud_rb__> haha, trig is indeed cheating
19:17:03 <Peaker> phlpp, how does deriving that yield back our original expression?
19:21:37 <phlpp> 03:20:45 <phlpp> @math Integrate[Sqrt[1-x^2], {x, -1, 1}]
19:21:38 <phlpp> 03:20:50 <mbot> phlpp: Pi/2
19:41:21 <roconnor> > iterate (\b -> b/2 + 1/b) 2
19:41:23 <lambdabot>  [2.0,1.5,1.4166666666666667,1.4142156862745099,1.4142135623746899,1.41421356...
19:45:07 <TomMD> How does one re-export a function that is from another module?
19:45:49 <dolio> Add it to your module's export list.
19:46:13 <joricj> how do you deal with "many-to-many" relations in haskell? suppose i have a list of names and there favorite color ... i'd like to be able to add (name,color), remove name or remove color and query both (name,*) and (*,color)
19:46:53 <dons> module M ( Prelude.sin ) where
19:46:54 <dons> import qualified Prelude
19:46:54 <dons> ?
19:46:57 <Jaak> > iterate (\b -> b/2 + 1/b) 2 :: [Ratio Int]
19:46:57 <lambdabot>  Exception: arithmetic overflow
19:47:10 <Jaak> wha...
19:47:15 <SamB> well, you simply implement a relational algebra system...
19:47:15 <lambdabot> SamB: You have 1 new message. '/msg lambdabot @messages' to read it.
19:47:15 <dons> joricj: use the BiMap data structure?
19:47:19 <SamB> @messages
19:47:19 <lambdabot> gwern asked 7h 24s ago: do you think maybe an upload of ZMachine to Hackage would be alright? I don't think my crash bug is going to get fixed, going by Igloo's comments: http://hackage.haskell.org/
19:47:19 <lambdabot> trac/ghc/ticket/2164
19:47:24 <dons> or perhaps just one (or two) Data.Maps ?
19:47:30 <TomMD> Hummm, OK, so it worked when I used to qualifier but not the full module name (Catagory.Module.function)
19:47:39 <SamB> @tell gwern sure, what the heck?
19:47:39 <lambdabot> Consider it noted.
19:47:45 <joricj> there's a BiMap ?!!! perfect! ^_^
19:47:59 <dons> there's lots of libraries these days :)
19:48:04 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/bimap
19:48:09 <SamB> hmm. I think I used the wrong punctuation
19:48:17 <hpaste>  morrow pasted "paying the bills" at http://hpaste.org/6697
19:48:31 <gwern> SamB: what d'you mean by that?
19:48:31 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
19:48:41 * gwern disdains to reply
19:49:06 <SamB> I meant sure! what the heck!
19:49:28 <gwern> oh, alright. I guess I'll do that when I get tahoe straighted nout
19:49:30 <SamB> that is, "sure letts try that and see what happens"
19:49:47 <SamB> tahoe, eh??
19:50:25 <SamB> would that be the lake, or the distributed filesystem?
19:50:39 <ddarius> SamB: gwern's Chevy Tahoe's alignment is off
19:50:50 <gwern> yeah. reddit post; I've long meant to find a viable distributed filesystem to back up on, and tahoe is the most viable I've seen in a while
19:51:15 <SamB> ddarius: you had me for about 11 seconds there!
19:51:21 <joricj> dons: it seems BiMap is one-to-one
19:51:24 <gwern> ddarius: I always said Chevy's can't be trusted, but I bought one anyway because it was a steal - yeah, it turned out to be a steal of my sanity!
19:52:05 <gwern> SamB: no one seems to be awake in #tahoe tho
19:52:29 <SamB> when did it become #tahoe?
19:52:51 <SamB> it was #mnet the last I noticed it, but I glance at my channel bar and I see I am now in #tahoe
19:52:58 <gwern> dunno, but you seem to be there
20:03:14 <gwern> SamB: how do you stand python? it seems so buggy and unreliable!
20:03:35 <Jaak> buggy and unreliable?
20:03:43 <Jaak> where the hell do such claims come from?
20:03:47 <cjb> gwern: by having good automated test cases, usually
20:03:51 <SamB> Jaak: not itself
20:04:06 <allbery_b> haskell users with the usual grouses about dynamicaly typed languages?
20:04:12 <SamB> Jaak: gwern is having crazy import-related problems...
20:04:30 <cjb> Jaak: it can't find very basic errors until entering the containing methods at runtime, which leads to unreliable use for large applications.
20:04:32 <Jaak> i might agree that it's quite easy to write buggy code in python, sure
20:04:33 <gwern> Jaak: I am having odd problems with installation where I have a python thingy which needs allmydata and pyutils - but those two seem to uninstall each other...
20:04:34 <cjb> (such as the OLPC UI.)
20:05:11 <gwern> (I don't know if it's python's fault per se, but until I know otherwise I'm gonna blame python and interpretation)
20:05:33 <Jaak> ah, okay
20:05:39 <ddarius> gwern: I'd blame the entire field of programming just to be safe.
20:05:55 <Jaak> yes, knuth is the devil
20:05:56 <SamB> programming isn't even a monoid
20:05:59 <gwern> freaking computers! if computers didn't exist I wouldn't have all these problems
20:06:12 * gwern thinks that covers all my bases :)
20:06:27 <SamB> does it cover base -3?
20:07:32 <gwern> it covers all bases expressible in ZMF set theory
20:08:08 <sfultong> hey.... if I recursively add elements at the end of a list with ++ [a], is ghc smart enough to do it in one pass?
20:08:22 <SamB> sfultong: of course not
20:08:30 <SamB> cabal install dlist
20:08:31 <sfultong> damn...
20:08:46 <sfultong> oh no! not installing a new library... :(
20:08:49 <sfultong> hehe
20:08:57 <SamB> it's tiny!
20:09:20 <SamB> it MIGHT have as many as two modules in it
20:09:35 <sfultong> two is two too many
20:09:44 <SamB> or as few as one
20:11:32 <ddarius> Then just import Data.Monoid and use Endo [a], mappend, and mempty
20:11:55 <SamB> really, it's micer with the wrapper!
20:12:05 <hpaste>  gwern pasted "tahoe" at http://hpaste.org/6699
20:12:05 <SamB> s/micer/nicer/
20:12:21 <ddarius> Otherwise, just write the efficient solution as it's likely just as easy.
20:12:35 <SamB> ddarius: you think so?
20:12:35 <sfultong> yeah, there must be a better way to do this...
20:16:44 <hpaste>  gwern annotated "tahoe" with "install" at http://hpaste.org/6699#a1
20:19:26 <sfultong> alright, I feel like I should be able to figure out a concise way of solving my problem myself, but out of curiosity I'll see if anyone else can solve it without much thought...
20:19:57 <gwern> man, hpaste needs to allow longer pastes
20:20:51 <sfultong> I want to write a function that will find the "best" value in a list, modify that best value somehow, and return the list with that one value modified...
20:21:21 <dons> sfultong: break ?
20:21:52 <clanehin> I have a theory that almost any typeclass that has more than one function, should probably be divided into two typeclasses, one for each function.  Wishing for MEmpty and MAppend typeclasses . . .
20:22:22 <lament> clanehin: that's exactly what Clean does, i think.
20:22:39 <SamB> clanehin: why the heck?
20:22:41 <lament> a class in clean is just an ad-hoc polymorphic function.
20:22:42 <sfultong> dons: break won't find a "best" value, though... it'll only find a first value matching certain criteria
20:22:46 <Saizan> foo [] = []; foo (x:xs) | best x = mod x : xs | otherwise = x : foo xs
20:23:16 <dons> sfultong: where criteria == best
20:23:17 <allbery_b> partition, or findIndex?
20:23:26 <dons> sfultong:  i'm assuming you've some fitness predicate?
20:23:30 <Saizan> sfultong: oh, best needs the rest of the list to decide?
20:23:37 <dons> ah
20:23:38 <sfultong> yeah
20:23:44 <dons> sortBy
20:24:01 <dons> anyway, this seems pretty simple, no?
20:24:16 <clanehin> SamB: sometimes I just want a function that always returns mempty, for some type that can be empty, for example.
20:24:20 * SamB likes urxvt's handling of screen immensely
20:24:40 <Saizan> screen the program?
20:24:44 <SamB> yes
20:24:51 <sfultong> dons: I thought it should be simple, but it's become embarrassingly hard from my point of view
20:25:30 <sfultong> I mean, I could write something, but I feel like I'm missing something elegant and concise
20:25:41 <SamB> comonads?
20:25:42 <SamB> zippers?
20:25:50 <sfultong> yeah, I might need a zipper
20:26:23 <sfultong> although I've never used a zipper, and I know even less about comonads
20:26:52 <Saizan> sfultong: how do you find the best?
20:27:20 <sfultong> selectAndModify :: (a -> a -> Bool) -> (a -> a) -> [a] -> [a]
20:27:23 <solrize_> i'd pick the best pair out of zip xs [0..]   then use the index to go back and replace that element of the original list
20:27:56 <sfultong> solrize_: I was thinking I'd do that, but it seems not elegant enough :-P
20:29:06 <sfultong> so the first argument would return if one element was better than another
20:30:53 <SamB> hmm, I seem to have got kind inference working properly in my JHC tree now...
20:31:19 <SamB> now all I have to do is figure out what is going wrong with this type error:
20:31:41 <Cale> sfultong: Do you want to modify all the elements which are maximal?
20:31:53 <Cale> sfultong: Or just the first maximal element?
20:31:56 <hpaste>  SamB pasted "jhc type error" at http://hpaste.org/6700
20:33:16 <dolio> Awesome.
20:33:53 <Saizan> that's a normal jhc type error?
20:34:03 <sfultong> Cale: I don't need a maximal, I need a "best".... otherwise I'd just use break as has already been suggested
20:34:17 <Cale> hm?
20:34:31 <Cale> Well, presumably you're handing this function some ordering
20:34:46 <Cale> What if the "best" element occurs multiple times?
20:35:20 <sfultong> oh, right.... silly me
20:35:28 <Cale> Does the function get applied to all the elements which are 'best', or does it get applied to just the first?
20:35:30 <allbery_b> sfultong: without some clue as to what constitutes "best", it may be difficult to help you
20:35:41 <Saizan> with only (a -> a -> Bool) you can get only one
20:35:44 <sfultong> just the first element
20:35:46 <sfultong> yeah
20:36:12 <sfultong> ignore what I said to Cale at first, it was a burst of stupidity :-P
20:36:16 <eyeris> Cale: In "The Monadic Way", part 6.1, in the def
20:36:18 <eyeris> erm
20:36:20 <eyeris> ignore that
20:36:22 <eyeris> haha
20:36:40 <eyeris> answered my own question, forgot that was in the buffer :)
20:37:04 <lament> The Monadic Way, book 7, 29:46
20:37:28 <sfultong> in the beginning, there was mzero
20:38:23 <allbery_b> and the Monad moved across the face of the deep and separated the pure from the impure?
20:39:10 <lament> sounds like you _could_ use a zipper here but that would be exactly why people think functional programming is weird and unnecessarily obfuscated.
20:40:06 <sfultong> lament: yeah, I don't want to prove them right
20:40:13 <Saizan> sfultong: however you traverse your list as a zipper i.e. a pair (elements before reversed, elements after) and when you find a temporary maximal you store the whole zipper at that point in an accumulator, so at the end of the list maximal you just unzip that accumulator applying the modify function
20:40:56 <Saizan> there's a "maximal" too much
20:41:26 <lament> it's actually not so bad since it gives you modification of the element in a very natural way
20:41:52 <allbery_b> (come to think of it, that's not a bad characterization of tahor vs. tamei in their religious senses)
20:44:01 <Cale> modifyBest (<=) f [] = []
20:44:01 <Cale> modifyBest (<=) f xs
20:44:01 <Cale>     = let (uss,(v:vs):vss) = break (\(t:ts) -> all (<= t) ts) (tails xs)
20:44:01 <Cale>       in map head uss ++ f v : vs
20:44:13 <Cale> I'm sure you could do better.
20:44:47 <sfultong> Cale: neat
20:45:00 * ddarius wonders how fast J's viewrgb verb is.
20:45:11 <sfultong> I thought I might get a tails usage in a solution :)
20:46:42 <Cale> That is O(n^2) though
20:47:00 <sfultong> 0(n^2) is good enough for me
20:48:35 <sfultong> if IO was an instance of MonadPlus, what do you think mzero would be? :)
20:48:39 <Saizan> we should have a function that returns all the possibile positions of a zipper for a list in the stdlib, that this would be a foldl
20:48:44 <ddarius> IO is an instance of MonadPlus
20:48:45 <Cale> If you're doing a lot of this, I wouldn't use lists.
20:49:02 <sfultong> ddarius: huh, interesting.... what is mzero?
20:49:04 <Cale> Saizan: hm?
20:49:38 <allbery_b> :t mzero
20:49:40 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
20:49:54 <ddarius> @src IO mzero
20:49:54 <lambdabot> mzero       = ioError (userError "mzero")
20:49:55 <sfultong> but specific to IO...
20:49:58 <sfultong> ah!
20:50:11 <sfultong> that's cheating :(
20:50:41 <Cale> @src IO mplus
20:50:41 <lambdabot> m `mplus` n = m `catch` \_ -> n
20:50:45 <allbery_b> MonadPlus is for any monad which has a null case and one or more non-null cases (think of it as a monadic generalization of mempty/mappend from Monoid)
20:50:54 <ddarius> Saizan: That would be close to the comonadic dup (dual to join) for the comonad the zipper induces.
20:51:10 <Cale> Really, IO is a MonadElse
20:51:19 <ddarius> MonadOrElse
20:51:24 <Cale> yeah
20:51:42 <Cale> Depending on what we want to call that :)
20:51:59 <sfultong> IO mplus is vicious
20:52:12 <Cale> It's actually quite good :)
20:52:37 <sfultong> blunder past exceptions
20:52:48 <Cale> No, catch exceptions and do something else.
20:52:49 <allbery_b> I have a program which uses that idiom regularly... the hard way, since the installed ghc doesn't have instance MonadPlus IO
20:53:04 <Cale> It just ignores the value of the exception.
20:53:12 <allbery_b> basiclaly, call something like getHostByName and substitute a default if it fails
20:54:03 <Cale> Or read from the first file for which opening it succeeds :)
20:54:33 <dolio> > let zoom c f [] = [] ; zoom c f l@(x:_) = let (_,i,l') = foldr (\(x,j) (b,k,xs) ->  let x' = if j == i then f x  else x in if c x b then (x,j,x':xs) else (b,k,x':xs)) (x,0,[]) (zip l [0..])  in l' in zoom (<) (+1) [1..20]
20:54:34 <lambdabot>  [2,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
20:54:39 <dolio> > let zoom c f [] = [] ; zoom c f l@(x:_) = let (_,i,l') = foldr (\(x,j) (b,k,xs) ->  let x' = if j == i then f x  else x in if c x b then (x,j,x':xs) else (b,k,x':xs)) (x,0,[]) (zip l [0..])  in l' in zoom (>) (+1) [1..20]
20:54:40 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,21]
20:54:45 <SamB> blunder *around* exceptions, not *past* them
20:54:47 <Saizan> ddarius: yeah, fromZip . dup . toZip
20:54:52 <SamB> just like the list monad ;-)
20:56:59 <Cale> msum . map (`openFile` ReadMode) $ ["foo.dat", "bar.dat", "baz.dat"]
20:58:34 <dons> cute msum use
20:58:57 <adu> hi
20:58:57 <lambdabot> adu: You have 1 new message. '/msg lambdabot @messages' to read it.
20:59:41 <dons> MonadPlus IO eh?
21:00:03 <sfultong> what's the status of haskell prime?
21:00:14 * allbery_b had been wondering how to optimize that.  admittedly in the ghc that doesn't have the MonadPlus...
21:00:32 <dons> its active, at the moment. work is underway over the next couple of months to finish some things off
21:02:28 <adu> oooo i have a message :)
21:03:10 <hpaste>  dolio pasted "zoom with nicer formatting" at http://hpaste.org/6701
21:03:53 * dolio likes tying knots.
21:05:37 <hpaste>  morrow pasted "aks primality test (currently partial)" at http://hpaste.org/6702
21:19:42 <nornagon> @index pseq
21:19:42 <lambdabot> GHC.Conc
21:21:44 <rhz> I'm trying to use GHC.PArr with GHC 6.8.1. It doesn't seem to be using both my cpus. Anyone know how to get it to do this?
21:21:58 <adu> The 2 things I'd like to see in Haskell' are arbitrary-precision floats and (***)
21:22:45 <noecksit_> hello, i made a small tic-tac-toe game in haskell
21:22:54 <noecksit_> using the gtk bindings
21:23:00 <adu> I love tic-tac-toe, is it 3D?
21:23:06 <noecksit_> where could i submit it?
21:23:14 <noecksit_> adu: no it is 2d
21:23:14 <dons> noecksit_: to hackage.haskell.org please :)
21:23:15 <adu> well, theres a hackage thing
21:23:30 <adu> ya that
21:23:34 <dons> ensure that's its cabalised, and then everyone can download and use it  :)
21:23:37 <Cale> noecksit_: You could make a cabal-package for it and upload it to hackage
21:24:20 <noecksit_> i was thinking of putting it on the overlay in gentoo, would that be allright?
21:24:53 <dons> well, if its on hackage, then people can add it to all the distros.
21:25:08 <noecksit_> oh ok
21:25:10 <dons> can it'll be installable with: cabal install tictactoe
21:25:27 <dons> you can put it under the 'Games' category
21:25:54 <adu> so If I cabalize a BigFloat package and a Tetration package, i can upload too? :)
21:26:08 <ddarius> adu: There are several exact real arithmetic libraries out there for Haskell.
21:26:12 <noecksit_> its not really that useful or important, but it could be nice if u want to look at minimax
21:26:21 <adu> ddarius: really? where?
21:26:39 <noecksit_> and it follows the "Why FP matters" paper with implementation
21:27:21 <TomMD> Does the Network.Socket code work find on Windows?  Even AF_UNIX?
21:27:26 <TomMD> s/find/fine
21:27:45 <allbery_b> hm, does Windows *have* AF_LOCAL?
21:28:01 <allbery_b> (AF_LOCAL being the platform-independent blessed name for AF_UNIX)
21:28:48 <ddarius> http://www.haskell.org/haskellwiki/Applications_and_libraries/Mathematics#Real_and_rational_numbers
21:28:49 <lambdabot> Title: Applications and libraries/Mathematics - HaskellWiki, http://tinyurl.com/37jtrh
21:28:52 <TomMD> allbery_b: Network.Socket doesn't have AF_LOCAL so I think not.
21:29:11 <Svrog> rhz: have you compiled your code with -threaded? and ran the binary with say -N2?
21:29:22 <Svrog> test +RTS -N2
21:29:22 <hpaste>  povman pasted "Fun with types" at http://hpaste.org/6703
21:29:45 <povman> interesting problem here :) how can I define newEditorState?
21:30:06 <allbery_b> TomMD: it may well refer to it as AF_UNIX.  I expect Windows documentation, if it supports that type at all, does *not* call it AF_UNIX :)
21:30:35 <adu> ocool, I've used BigFloat, but i've never heard of all those others
21:32:03 <allbery_b> (generally non-unix/posix systems that support AF_LOCAL have a compatibility #ifdef)
21:32:24 <rhz> Svrog: yes
21:32:30 <Svrog> ah
21:33:00 <SamB> hmm, JHC can't handle irrefutable patterns in lambdas???
21:33:20 <SamB> JHC is needs better test coverage...
21:33:33 <adu> but still... none of them to arbitrary-precision matrices... :(
21:34:16 <adu> the formula I'm using this for requires arbitrary-precision matrices
21:34:38 <SamB> why would windows support unix domain sockets?
21:35:11 <eyeris> SamB: interoperability requirements from the anti-trust settlements?
21:35:26 <allbery_b> easier portability.  (it would be AF_LOCAL in any case)  think of it as a socket interface to windows mailboxes
21:35:30 <eyeris> When did they get them?
21:35:39 <SamB> do they have them?
21:35:45 <hpaste>  povman annotated "Fun with types" with "shorter version" at http://hpaste.org/6703#a1
21:35:56 <eyeris> Oh, I assumed from your question that you thought they did :)
21:36:27 <SamB> no, I just think it would be odd if they did ;-)
21:36:52 <allbery_b> OS/2 did, I presume NT3.1 rertained them.  after that?  no idea
21:37:46 <noecksit_> what would be the reason that people would prefer darcs over git?
21:38:15 <povman> noecksit_: it's written in haskell
21:38:20 <eyeris> noecksit_ interactive by default, simpler mental model
21:38:47 <eyeris> povman they started with darcs before git was stable?
21:39:09 <eyeris> that was to noecksit_ :)
21:39:33 <noecksit_> eyeris: does it have as good support for branching as git?
21:39:34 <povman> i was quite confused :)
21:39:56 <eyeris> noecksit_ It has the same system for branching
21:40:02 <noecksit_> eyeris: i wouldnt know
21:40:17 <SamB> noecksit_: last I checked, git was hideously complicated
21:40:20 <eyeris> Merging is different enough that the goodness of each is really not comparable
21:40:49 <SamB> at least, it has a multitude of commands....
21:41:03 <SamB> and it seems like you actually need a lot of them
21:41:09 <SamB> a lot of the time
21:41:39 <povman> is anyone good at Dynamic? I need to define newEditorState: http://hpaste.org/6703#a1
21:41:55 <noecksit_> SamB: it is very flexible, and you only need to use a small subset of them
21:42:05 <dolio> povman: I'm looking, but I'm not sure there's a way to do it.
21:42:26 <SamB> darcs doesn't seem to have anywhere near as many commands in the first place...
21:42:33 <noecksit_> so is darcs more like svn or like git or neither?
21:42:53 <SamB> and you only need, what, 6 for basic usage?
21:43:39 <bd_> noecksit_: pretty much neither
21:43:42 <noecksit_> but i do have to admit that they dont make some things intuitive, like reverting back to an old commit
21:43:59 <bd_> svn/git are based on managing trees - snapshots of the repository contents
21:44:00 <eyeris> git has a lot of commands
21:44:09 <eyeris> but you can get by with just commit
21:44:14 <bd_> whereas darcs works with a set of patches which are applied according to a partial order to reconstruct a tree
21:44:22 <SamB> eyeris: eh?
21:44:53 <eyeris> SamB: unless you are a maintainer, and have to merge a bunch of other people's changes, it's commit 90% of the time
21:45:02 <eyeris> with some rebasing thrown in
21:45:02 <povman> dolio: what if the output were Dynamic as well?
21:45:10 <noecksit_> bd_: oh ok
21:45:14 <SamB> eyeris: what the heck is rebasing?
21:45:15 <eyeris> at least, that's been my experience
21:45:18 <SamB> well actually I think I can guess
21:45:21 <eyeris> but I work on very small teams
21:45:27 <SamB> but it sounds like "darcs pull"
21:45:32 <bd_> SamB: rebase takes your changes, turns them into a set of patches, then applies them somewhere else
21:46:14 <bd_> SamB: eg, if you've been developing on your private branch, based on a commit X on the main branch, and now you want to make them be based on the latest upstream revision, you do `git rebase origin' or similar to reapply it there
21:46:34 <eyeris> exactly
21:46:36 <bd_> You can also do git rebase --interactive to do more advanced things (editing patches, merging patches, reordering...)
21:46:40 <bd_> (or dropping)
21:46:41 <dolio> eyeris: Well, it's more like, you have to cast to some concrete type in the middle, you can't just say, 'try to cast to the same type, and use that in the existential'.
21:46:45 <SamB> noecksit_: I think darcs is possibly the only VCS whose manual contains a section explaining it in terms of quantum mechanics
21:46:48 <dolio> Er, povman, my bad.
21:46:53 <bd_> It's often used to avoid cluttering history with pointless merges
21:47:06 <SamB> noecksit_: does that sound cool, or does that sound cool?
21:47:18 <mud-rb_> SamB: is that a positive or a negative?
21:47:19 <dolio> povman: So I think you'll have to enumerate all the possible types in that function.
21:47:30 <dolio> But then, I'm not necessarily an expert.
21:47:41 <SamB> mud-rb: well, I think it's nice
21:47:52 <SamB> I like the darcs model, after all
21:48:08 <mud-rb_> SamB: it sounds cool, but possibly scary, haha
21:48:13 <eyeris> I like darcs more than git personally, but I think that's just because I rarely work with more than 2 other people.
21:48:28 <eyeris> Where I am familiar with their patch recording habits, etc
21:48:30 <povman> dolio: you mean instead of Dynamic?
21:48:31 <bd_> the thing I don't much like about the darcs model is it seems to me that you can end up with a history containing completely untested repo states. Eg, Consider two branches, one with patches A,B,C, and one with X,Y,Z.
21:48:40 <scook0> I like the idea of git, but can't yet bring myself to actually use it
21:48:49 <bd_> If you merge the two, you might end up with A,X,B,C,Y,Z. Does A,X,B really work? Who knows?
21:48:58 <scook0> because I'm too attached darcs record
21:49:00 <povman> dolio: Editor's will be loaded with hs-plugins
21:49:00 <SamB> bd_: who cares?
21:49:10 <bd_> SamB: someone trying to track down where a bug was introduced :)
21:49:19 <SamB> hmm
21:49:25 <bd_> It just doesn't seem to me to reflect reality very much.
21:49:34 <SamB> so what would you like?
21:49:46 <bd_> Well, the git model of snapshotting repository state seems nice ;)
21:49:51 <dolio> povman: I mean, you'll have to try to cast to Editor Double and Double, and then Editor String and String, and so on, and build EditorStates in each of those branches.
21:49:55 <dolio> povman: I think, at least.
21:49:57 <eyeris> bd_ So when just merge X, test. Merge Y, test. Merge Z, test.
21:49:57 <SamB> I suppose it does work well for that...
21:50:00 <bd_> git-rebase is basically the darcs model, in git, available /on demand/
21:50:20 <dolio> povman: Or use Dynamic everywhere, and have an Editor Dynamic.
21:50:24 <bd_> eyeris: You've tested A,X,B,C, not A,X,B :)
21:50:31 <SamB> I demand the darcs model at all times!
21:50:36 <scook0> I do wish darcs had some of the auxiliary features of git
21:50:48 <scook0> like stash, and in-tree branches
21:51:00 <bd_> SamB: What does darcs do better, from the user's POV? >.>
21:51:01 <SamB> hmm, stash would be cool
21:51:04 <povman> dolio: ech. looks like i have to give up trying to be pure :)
21:51:08 <noecksit_> SamB : sounds cool
21:51:11 <SamB> bd_: well, having less commands
21:51:15 <eyeris> bd_ right, but hopefully you've tested A, B, C before you merge in X
21:51:23 <scook0> I hate it whenever I have to make a new repo to perform some manipulation
21:51:27 <bd_> SamB: hah :)
21:51:28 <dolio> povman: I've not done much Dynamic related stuff, so you should take me with a grain of salt.
21:51:31 <eyeris> I'm assuming here that A, B, and C are my patches
21:51:38 <bd_> SamB: Most of them aren't meant to be used by the user :)
21:51:48 <scook0> e.g. the only way I've found to do a "deep revert" is to clone, obliterate, revert, and then pull and resolve
21:51:49 <bd_> eyeris: Oh, sure, but X isn't. How do you know A,X,B,C works?
21:51:52 <SamB> bd_: they should be named better, then
21:52:00 <SamB> like git_dark_foo
21:52:04 <eyeris> bd_ test?
21:52:17 <bd_> eyeris: Now what about A,X,B?
21:52:22 <SamB> or does git use dashes? I forget...
21:52:23 <scook0> "deep rollback", I should say
21:52:25 <eyeris> bd_ Are you meaning that A,X,B,C works when compiled or that it clobbers the files?
21:52:42 <bd_> SamB: I think they're moving toward that gradually - a lot of commands are being transformed from (very complex) shell script into C
21:52:45 <eyeris> bd_ you can unrecord C before merging X if you want to test A, X, B
21:53:09 <eyeris> or, rather, pull A, B into a new repo but not C, or however you care to get just A, B
21:53:14 <bd_> eyeris: I mean that nobody's going to take the effort to test every combination of patches during a merge, and if you're trying to bisect to find a bug, this can bite you
21:53:41 <bd_> SamB: anyway, hiding commands is really your shell's command completion's job :)
21:53:54 <SamB> bd_: I didn't say hidden
21:54:01 <bd_> git --help hides the dark magic in fact
21:54:03 <SamB> I just think it would be nice if they were marked
21:54:15 <SamB> so that you could skip them...
21:54:27 <eyeris> bd_ Oh, I see what you are getting at. Can't you just record a patch that depends on X, Y, and Z and merge that, giving you A, B, C, (X * Y * Z)?
21:54:33 <SamB> anyway, since when is my shell supposed to know git?
21:54:57 <eyeris> SamB: since programmable completions became commonplace... around 1999?
21:54:57 <bd_> eyeris: Do people actually do that on every merge? And if so, why not just use a DVCS which does that by default?
21:55:07 <bd_> SamB: many do these days :)
21:55:15 <SamB> does git come with zsh completion files?
21:55:42 <bd_> I don't know if git comes with zsh completion or vice versa, but git completes nicely in zsh for me - however the git plumbing is exposed when completing for command name
21:55:47 <eyeris> bd_: no they don't, but that's not the problem you proposed. Your problem was essentially "how do you bisect the repo after you merge X, Y, Z in and find a bug"
21:55:54 <eyeris> so no, not for every merge
21:56:15 <eyeris> but once you find a bug, you can rollback, make the depend-patch and remerge
21:56:18 <eyeris> and test again
21:56:24 <bd_> eyeris: Well, the issue is: Person A does the merge, person B needs to bisect. Person B has no idea the merge happened.
21:56:53 <eyeris> bd_ but why is person A merging stuff into person B's repo?
21:56:54 <bd_> They just see a repository with all six patches.
21:57:03 <bd_> eyeris: Person A is upstream, person B pulls from it and finds a bug.
21:57:12 <SamB> (Where person A and person B are possibly the same person)
21:57:19 <eyeris> Right, pulling = merging, essentially
21:57:26 <SamB> (yes, this happens!)
21:57:27 <eyeris> so person B did know the merge happened
21:57:37 <bd_> No, person B has no idea that the A,B,C+X,Y,Z merge happened
21:57:39 <SamB> eyeris: heck no
21:57:42 <bd_> person B gets all six at the same time
21:58:02 <SamB> also, person A could have a lousy memory
21:58:19 <bd_> and while in a set of just six patches it's manageable, what about a bisection over a dozen merges and a few hundred patches?
21:58:30 <eyeris> bd_ you lost me. How does person B not see the X,Y,Z patch in the pull?
21:58:42 <bd_> eyeris: They see A,X,B,C,Y,Z in the pull.
21:58:53 <eyeris> Oh, I see what you mean
21:58:59 <bd_> Now, A, AB, ABC, X, XY, XYZ have been tested. But say AXB fails to build...
21:59:07 <SamB> bd_: of course, usually if you merge XYZ into ABC, you get ABC XYZ
21:59:18 <bd_> oh? is that guarenteed?
21:59:19 <eyeris> They don't know how each of X, Y, and Z were applied by person A
21:59:39 <SamB> bd_: well, no, but it tends to happen...
21:59:47 <bd_> hmmm
21:59:50 <eyeris> No, it's not garanteed, but it's the current implementation.
22:00:18 <bd_> I thought it just sorted by date or something :) Still, it makes me nervous that you can theoretically extract a never-before-seen working copy without explicitly asking for it...
22:00:47 <SamB> isn't that the nature of cherry-picking?
22:00:57 <eyeris> bd_ I don't think there is a situation where person B should be pulling more than a handful of patches from person A and still be responsible for finding the bugs caused by person A's merging. That's insane.
22:00:58 <bd_> SamB: Sure, but the key is you should be aware of what's happening
22:01:14 <bd_> eyeris: Responsible? No. Wanting to file a good bug report? Sure.
22:01:27 <bd_> Maybe it's a bug that only happens on their OS/distro/hardware.
22:01:51 <SamB> eyeris: the bugs aren't considered to be caused by the merging, but there may be certain combinations of patches that are not sensible...
22:01:57 <bd_> No project of moderate size can be completely debugged by their maintainer :)
22:02:12 <SamB> which will make it harder to find the bug one is actually seeking
22:02:49 <bd_> anyway, there's nothing wrong with 'bag of patches' as a /tool/, IMO, but I don't feel it should be default, or forced.
22:02:51 <SamB> I will admit that git's linear model is a win in this case
22:03:23 <SamB> though I don't think git can automatically run the test?
22:03:32 <eyeris> SamB absolutely it's better. But I just don't think it's hard to do in darcs.
22:03:37 <bd_> SamB: it can
22:03:41 <bd_> git bisect run
22:04:00 <SamB> oh they added that?
22:04:03 <SamB> nice.
22:04:11 <bd_> it's in 1.5.4.3 anyway
22:04:30 <SamB> easier than making darcs know which patches to unpull ;-)
22:04:55 <bd_> anyway, I don't really understand why a patch-calculus model is considered better in practice...
22:05:51 <eyeris> bd_ who thinks it is?
22:06:05 <bd_> presumably the darcs devs? :)
22:06:28 <eyeris> bd_ it definitely has some advantages
22:06:46 <eyeris> but didn't darcs get stable before git was even started?
22:06:52 <eyeris> I think that had more to do with it
22:06:55 <bd_> could be
22:07:09 <eyeris> notice the distinct lack of darcs development over the last year :)
22:07:13 <TomMD> Well, I've got a basic IPC library built.  Anyone care to see it on Hackage? (release early, hope to release often)
22:07:29 <allbery_b> er?  darcs2 has been in development and is currently in testing
22:07:39 <eyeris> really?
22:08:04 <dons> yeah, really.
22:08:05 <allbery_b> yes.  I saw some email about resolving some unexpected slowness
22:08:11 <dons> the list has got quite active the last 3 months
22:08:18 <dons> darcs2 candidates on darcs.net
22:08:23 <adu> TomMD: IPC? sure!
22:08:40 <dons> git was originally considered a filesystem backend to darcs, fwiw
22:08:45 <dons> back when linus hung out on darcs@
22:12:05 <Jedai> > (^2) . [1..4]
22:12:09 <lambdabot>  [1,4,9,16]
22:12:17 <Jedai> :t (.)
22:12:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:15:27 <shachaf> lambdabot is really turning into Caleskell, isn't it?
22:15:37 <shachaf> (Where can I get a copy? :-) )
22:19:29 <miloshh> Jedai: what's going on there? seems like fmap to me, rather than (.)
22:19:41 <TomMD> adu: IPC has been uploaded to Hackage.  It is so simple it might be kindof stupid right now.  It uses Network.Socket to accept or connect to named AF_UNIX datagram sockets.
22:20:07 <Jedai> miloshh: (.) is redefined in lambdabot, to fmap (with a Functor for functions)
22:20:11 <Cale> miloshh: But (.) is fmap, for one particular functor :)
22:20:30 <Cale> So I generalised the notation a little bit :)
22:20:40 <TomMD> There is a 'Data.Queue' which is used to buffer all sends and receives.  It uses a phantom data type to ensure the high level function are used with the correct (input and output) queues.
22:20:46 <miloshh> Cale: that never occured to me, thanks :)
22:21:07 * allbery_b wonders how long before LB translates do notation in terms of MonadZero
22:21:12 <Cale> [It's the functor ((->) e)]
22:21:14 * dons isn't sure why it would be generalised in #haskell of all places
22:21:39 <Svrog> Data.Queue sounds a bit too general for something like IPC imo
22:21:48 <Cale> dons: Yeah, we're usually so opposed to generality here :)
22:21:59 <dons> its not haskell :(
22:22:19 <dons> it'd be cool if you could introduce the extensions with some other prompt
22:22:19 <shachaf> dons: That's what you get for letting Cale run lambdabot.
22:22:22 <Cale> Sure it is. It's Haskell with one or two of the Prelude functions generalised :)
22:22:30 <miloshh> ok, (->) is not really a type
22:22:35 <shachaf> dons: You should've known it'd happen. :-)
22:22:40 <miloshh> i mean a type constructor
22:22:43 <roconnor> @type (++)
22:22:45 <shachaf> miloshh: Why not?
22:22:45 <lambdabot> forall m. (Monoid m) => m -> m -> m
22:22:46 <dons>  > for haskell,  and $ or something for haskell-cale
22:22:48 <Cale> miloshh: It's a type constructor constructor :)
22:23:08 <Jedai> miloshh: (->) is a type constructor, why not ?
22:23:20 <TomMD> Non-Haskell making it into lambdabot?  Humm... I wonder how hard it would be to write a specware plugin.
22:23:27 <Jedai> miloshh: It construct a type
22:23:28 <adu> TomMD: cool!
22:23:42 <shachaf> TomMD: lamdabot has had @unlambda, @bf, and others for some time.
22:23:58 <shachaf> TomMD: (I don't think they work anymore, though.)
22:24:15 <allbery_b> it's just using prefix notation to describe the section (e ->), i.e. functions from a single argument to something unspecified
22:24:47 <miloshh> JJedai: OK, but can be consumed by other type constructors in legal haskell?
22:25:00 <allbery_b> combine this with automatic currying (so any function that's not a CAF is ultimately a 1-argument function) and yoy get something fairly interesting
22:25:03 <Cale> dons: I was actually going to do that with the C-preprocessor, but that actually turns out not to be enough, because of the way that L.hs doesn't seem to get recompiled.
22:25:08 <Jedai> miloshh: Of course, how else would Cale do it ?
22:25:37 <Jedai> miloshh: In fact, you already have a ((->) e) monad in the standard library
22:25:39 <Cale> miloshh: (->) is just as good a type constructor as Either, for example
22:25:40 <miloshh> ok, cool, i thought he extended the syntax...
22:25:59 <Cale> @kind Either
22:26:00 <lambdabot> * -> * -> *
22:26:04 <Cale> @kind (->)
22:26:04 <lambdabot> ?? -> ? -> *
22:26:14 <allbery_b> no, that is standard syntax.  just a bit odd looking
22:26:35 <Cale> Of course, it has a slightly strange kind, due to various sorts of unboxed types.
22:26:40 <nornagon> i think ?? and ? are compiler stuff showing through
22:26:41 <allbery_b> the list and tuple constructors in prefix form also look rather odd
22:26:42 <Jedai> miloshh: Nope, lambdabot is written in Haskell and '>' compute Haskell (with some definition changed from the Prelude)
22:27:12 <Jedai> > (,,,) 1 2 3 4
22:27:14 <lambdabot>  (1,2,3,4)
22:27:20 <Cale> Note that wherever I changed definitions from the Prelude ones, I only generalised things.
22:27:31 <Cale> So programs which worked before should still work.
22:28:00 <allbery_b> barring unexpected reactions to polymorphism
22:28:25 <Cale> Well, there's a slight possibility that you need to add a type signature.
22:28:34 <Cale> But it seems those don't come up so much.
22:28:45 <TomM1> Back! As I was saying before my brick decided to brick.  Yes, Data.Queue is quite general for an ipc library - it is actually a very simple wrapper to dlist.  I just needed something I decided to export what I built - if someone wants it in a different package I'd be fine with adding a dependency and removing it from IPC.
22:29:47 <Cale> In the case of (.), the functor is determined by the type of the last element in the chain of (.)'s, and usually you know if that's a function or a list or whatnot. In the case of (++), generalised to monoids, it's also typically already known what type you mean.
22:30:17 <Jedai> > Nothing ++ Just True
22:30:18 <lambdabot>   add an instance declaration for (Monoid Bool)
22:30:18 <lambdabot>     In the expression: Nothin...
22:30:29 <TomM1> > (\_ -> "Pong") "Ping"
22:30:29 <lambdabot>  "Pong"
22:30:36 <Jedai> > Nothing ++ Just []
22:30:36 <lambdabot>  Just []
22:30:51 <Cale> > Nothing ++ Just [1,2,3]
22:30:51 <lambdabot>  Just [1,2,3]
22:30:58 <Cale> > Just [1,2] ++ Just [1,2,3]
22:30:58 <lambdabot>  Just [1,2,1,2,3]
22:31:04 <miloshh> :t (++)
22:31:05 <lambdabot> forall m. (Monoid m) => m -> m -> m
22:31:41 <Cale> > sortBy (comparing length ++ compare) (words "this is a bunch of words to be sorted by length and then alphabetically")
22:31:41 <lambdabot>  ["a","be","by","is","of","to","and","then","this","bunch","words","length","...
22:32:11 <Cale> (that's one of my favourite examples ;)
22:32:22 <Jedai> I like this one too
22:33:22 <miloshh> ok, i don't parse that one, but i'll think about it
22:33:35 <Cale> There's a lifting instance for functions
22:33:44 <Cale> (f ++ g) x = f x ++ g x
22:33:52 <Twey> Nobody's solved this yet?
22:33:57 <Jedai> And an instance for Monoid Ordering
22:33:58 <Cale> and there's an instance for Ordering
22:34:07 <Twey> Y'all were discussing it last night too :-P
22:34:24 <Cale> Such that EQ ++ y is y, and x ++ y = x otherwise
22:35:28 <Cale> So,  (comparing length ++ compare) x y = (comparing length x ++ compare x) y = comparing length x y ++ compare x y
22:35:44 <Cale> and so if the lengths are equal, we compare the strings normally
22:35:55 <Cale> Otherwise, we just take the result of comparing the lengths
22:36:06 <Svrog> TomM1: i was actually referring to the name Data.Queue, not that it's in the ipc package
22:36:57 <Svrog> it may even already be used by something else - i just checked edison docs and it doesn't seem to have a module named that way but i wouldnt be surprised if something else did
22:37:28 <TomM1> Svrog: Fair point.  I might move it into System.IPC.Queue based on that.
22:37:39 <Cale> Monoids are astoundingly important to programming, and show up just about everywhere, so I think they deserve a good notation :)
22:37:49 <TomM1> Odd that my former self hasn't been dropped yet.
22:38:08 <Cale> mappend is an ugly name, ++ is much easier on the eyes :)
22:38:38 <miloshh> Cale: so what do i have to import to make this work?
22:39:07 <Cale> miloshh: Well, Data.Monoid defines mappend. In lambdabot, I've redefined (++) to be mappend
22:40:02 <Cale> (you can do that by importing the Prelude hiding ((++)) and then defining (++) for yourself
22:40:04 <Cale> )
22:40:22 <miloshh> thanks, got it
23:59:03 <ddarius> This site is cool.
23:59:05 <ddarius> http://www.cs.berkeley.edu/b-cam/PapersPage.html
23:59:05 <lambdabot> Title: BCAM - Papers
