00:02:38 <solrize> http://cr.yp.to/daemontools/supervise.html
00:03:04 <solrize> http://cr.yp.to/daemontools.html   we use this stuff where i work
00:06:23 <solrize> luqui still here?
00:18:53 <luqui> solrize, ping
00:19:03 <solrize> luqui, http://luqui.org/papers/implied_odds.pdf  => 404
00:19:35 <luqui> solrize, thanks, I think I still have that kickin' around...
00:19:40 <solrize> np
00:28:46 <solrize> http://freeshells.ch/~revence/myths.txt   this is kind of funny
00:30:20 <solrize> http://freeshells.ch/~revence/no-c.txt  this too
00:30:46 <glguy> http://projecteuler.net/index.php?section=problems&id=185 (solvable in 20 seconds with list monad, thanks Haskell)
00:30:56 <lambdabot> Title: Problem 185 - Project Euler
00:34:35 <solrize> Some people seem stuck up on the whole malloc/free thing. They think it makes
00:34:35 <solrize> them `The Big Guys' to be micro-managing their memory allocations. Please. It
00:34:35 <solrize> makes you stupid, not cool. If every program you write carries with it a
00:34:35 <solrize> custom-made garbage collector, why don't you quit the project and build this one
00:34:35 <solrize> _tool_, and then come back to the project?
00:38:13 <johnnowak> there's something that'll never convince anyone of anything
00:38:46 * Maddas thinks the myths.txt would turn him away rather than to haskell, if anything
00:39:00 <johnnowak> aye
00:39:00 <solrize> maddas yes true, but it was funny
00:39:04 <solrize> and i think the c one is mostly true
00:39:11 <faxathisia> glguy: gotta do it in < 1 min :P
00:39:13 <Maddas> (not just for the writing style, but also for the technical explanations)
00:39:15 <faxathisia> oops
00:39:23 <faxathisia> I read 2 mins not 20 seconds somehow..
00:39:30 <glguy> common mistake
00:39:35 <faxathisia> hehe
00:39:38 * faxathisia hides
00:40:57 <Maddas> no-c.txt also directly contradicts myths.txt :-)
00:42:04 <johnnowak> solrize: which parts are true? the part about "speed" completely ignores that speed does matter if the difference is large enough, the part about every type cast being an error is wrong, the idea that fold can't get by with function pointers is silly, there are plenty of legitimate applications for C besides language runtimes, gc is not acceptable in all cases, etc
00:42:47 <solrize> well, he's got the right attitude towards c anyway
00:43:05 <johnnowak> he clearly doesn't
00:43:13 * Maddas doesn't think that text has the right attitude towards anything he read in it so far :-)
00:45:21 <glguy> what we need is more advocacy and less coding
00:45:36 <glguy> or..
00:45:37 <glguy> wait..
00:45:38 * Maddas raises an eyebrow
00:46:04 <glguy> I remember now
00:46:05 <solrize> hehe
00:46:09 <Maddas> glguy: :-)
00:46:17 <glguy> what we need is less advocacy and more coding
00:46:35 <Maddas> Those texts aren't really advocacy as much as rants.
00:46:50 <solrize> yeah
00:46:54 <glguy> I'm using the word loosely
00:47:23 <solrize> i still like the c one, even though my main objection to c probably comes down to lack of pointer checking
00:47:49 <faxathisia> and ridiculous language constructs
00:48:15 <johnnowak> faxathisia: what's "ridiculous"?
00:48:31 <quicksilver> a full-grown man wearing a chicken suit to work?
00:48:36 <johnnowak> that's ridiculous
00:48:39 <Maddas> What if he works for KFC?
00:48:41 <johnnowak> unless.. yes.
00:49:15 <Maddas> Granted, if all KFC employees wore chicken suits...
00:49:31 * Maddas pictures board meetings
00:49:53 <johnnowak> employees accidently cooking each other
00:49:56 <solrize> what's the simplest way to print a number in hex?
00:50:05 <quicksilver> :t showHex
00:50:07 <faxathisia> @hoogle hex
00:50:08 <lambdabot> Text.ParserCombinators.Parsec.Char.hexDigit :: CharParser st Char
00:50:08 <lambdabot> Text.ParserCombinators.Parsec.Token.hexadecimal :: TokenParser st -> CharParser st Integer
00:50:08 <lambdabot> Numeric.showHex :: Integral a => a -> ShowS
00:50:11 <lambdabot> forall a. (Integral a) => a -> String -> String
00:50:21 <solrize> hmm
00:50:21 <quicksilver> > showHex 999 ""
00:50:23 <lambdabot>  "3e7"
00:50:35 <faxathisia> > showHex 12246029
00:50:36 <lambdabot>  <[Char] -> [Char]>
00:50:44 <faxathisia> > showHex 12246029 "what is this bit for?"
00:50:45 <lambdabot>  "badc0dwhat is this bit for?"
00:50:56 <solrize> > showHex 9
00:50:57 <lambdabot>  <[Char] -> [Char]>
00:50:59 <faxathisia> hmmm.. I guess that's a good idea
00:51:13 <faxathisia> O(1) 'append'
00:51:14 <solrize> why not just use ++ directly?
00:51:22 <faxathisia> solrize: ++ is O(n)
00:51:30 <faxathisia> or is it? :S
00:51:35 <solrize> lazy evlauation
00:51:40 <faxathisia> so what?
00:51:41 <Maddas> Does that change anything, though?
00:51:45 <johnnowak> > showList ["inside"] "outside"
00:51:45 <lambdabot>  "[\"inside\"]outside"
00:51:47 <faxathisia> does that make it not O(n)
00:51:52 <quicksilver> yes, it does.
00:52:07 <quicksilver> it's a little bit hard to convince yourself why, but it does.
00:52:19 <solrize> "foo" ++ "bar"    =>   the ++ is O(1)
00:52:30 <faxathisia> > show ("foo" ++ "bar")‚Ä®
00:52:30 <lambdabot>  Illegal character ''\128''
00:52:30 <lambdabot>  at "Ä®" (column 23)
00:52:32 <quicksilver> solrize: no, it's not. It's O(left list)
00:52:33 <johnnowak> solrize: how is it O(1)?
00:52:45 <quicksilver> assuming you bother to consume it, of course
00:52:53 <quicksilver> if you don't consume it, it's O(0)
00:53:04 <quicksilver> like many things lazily evaluated :)
00:53:14 <Maddas> quicksilver: That's just a constant factor away of O(n^2)!
00:53:18 <Maddas> :-P
00:53:40 <quicksilver> a constant factor of 0, yes :)
00:54:41 <solrize> suppose you've got a function  hexify :: Integer -> String
00:54:49 <solrize> i.e. like showHex iwthout the 2nd arg
00:54:52 <solrize> without
00:54:57 <faxathisia> :t hexify = showHex ""
00:54:58 <lambdabot> parse error on input `='
00:55:11 <faxathisia> :t let hexify = showHex "" in hexify :: Integer -> String
00:55:12 <lambdabot>     Couldn't match expected type `Integer'
00:55:12 <lambdabot>            against inferred type `String'
00:55:12 <lambdabot>       Expected type: Integer -> String
00:55:17 <faxathisia> bah...
00:55:22 <solrize> > let hexify = (flip showHex) ""
00:55:22 <lambdabot>  Parse error at end of input
00:55:22 <faxathisia> flip showHex
00:55:56 <solrize> > let hexify n = showHex n "" in (hexify 23) ++ "skiddoo"
00:55:57 <lambdabot>  "17skiddoo"
00:56:07 <solrize> > let hexify n = showHex n "" in (hexify 35) ++ "skiddoo"
00:56:07 <lambdabot>  "23skiddoo"
00:56:23 <solrize> i don't see how that was faster than showHex 35 "skiddoo"
00:56:46 <solrize> slower
00:56:56 <faxathisia> there is like another layer of consing
00:56:59 <faxathisia> :t (++)
00:57:00 <lambdabot> forall m. (Monoid m) => m -> m -> m
00:57:05 <faxathisia> @src (++)
00:57:05 <lambdabot> (++) []     ys = ys
00:57:05 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
00:57:16 <solrize> well that's O(1)
00:57:21 <quicksilver> no, it's not.
00:57:23 <quicksilver> it's O(n).
00:57:27 <quicksilver> well, O (left list)
00:57:28 <solrize> hmm
00:57:34 <faxathisia> lol Cale
00:57:35 <quicksilver> it traverses the left list one cell at a time.
00:57:40 <faxathisia> the types are out of sync
00:58:11 <faxathisia> with @src
00:58:30 <quicksilver> yes, Cale is playing with (.) and (++)
00:58:34 <quicksilver> btu that doesn't affect @rc
00:58:36 <quicksilver> @src
00:58:36 <lambdabot> src <id>. Display the implementation of a standard function
00:59:03 <faxathisia> yes but :t and @src are out of sync
00:59:12 <quicksilver> yup.
00:59:18 <quicksilver> that's what I said :P
00:59:36 <quicksilver> @src is a static list, it's unaffected by lambdabot definitions.
00:59:36 <lambdabot> Source not found. It can only be attributed to human error.
01:00:58 <faxathisia> I know
01:01:02 <faxathisia> I'm saying .. that sucks :D
01:01:22 <faxathisia> It's not even type checked let alone against with lambdabot
01:01:33 <faxathisia> even foldr was wrong before because it wasn't type chekced
01:02:47 <Cale> faxathisia: It's just a text file.
01:02:58 <faxathisia> It's a gzip ?
01:03:05 <Cale> It used to be a gzip
01:04:13 <solrize> what if i want to print a 16-bit hex as  0023 or something like that?  i could write some special code for it but it looks like this is an underrepresented area...
01:05:38 <faxathisia> > printf "%.4x" 35 :: String
01:05:39 <lambdabot>  "23"
01:05:42 <faxathisia> O_o
01:05:45 <faxathisia> > printf "%4x" 35 :: String
01:05:45 <lambdabot>  "  23"
01:05:52 <faxathisia> > printf "%0.4x" 35 :: String
01:05:53 <lambdabot>  "23"
01:06:23 <Cale> > showHex 35 ""
01:06:24 <lambdabot>  "23"
01:08:01 <Jedai> > printf "%04x" 35 :: String
01:08:02 <lambdabot>  "0023"
01:08:15 <solrize> oh cool!
01:08:21 <solrize> > printf "foo"
01:08:21 <lambdabot>  Add a type signature
01:08:31 <solrize> > printf "foo"::String
01:08:32 <lambdabot>  "foo"
01:08:38 <solrize> printf "foo"::Int
01:09:13 <Jedai> solrize: printf use the type expected for him to either produce a String or just print it on stdout
01:09:30 <solrize> printf "foo" :: IO ()
01:09:37 <yitz> @seen dcoutts___
01:09:37 <lambdabot> I haven't seen dcoutts___.
01:09:57 <yitz> I guess it's like tuples, it only goes up to a certain dimension.
01:09:58 <solrize> jedai, thanks.  like that?
01:10:03 <Jedai> Which is why it asked a signature here since it don't have the context to decide which is appropriate.
01:10:36 <Jedai> > let s = printf "foo" in putStr (uppercase s)
01:10:37 <lambdabot>   Not in scope: `uppercase'
01:10:44 <Jedai> > let s = printf "foo" in putStr (upperCase s)
01:10:44 <lambdabot>   Not in scope: `upperCase'
01:10:53 <Jedai> @hoogle upper
01:10:53 <lambdabot> Text.ParserCombinators.Parsec.Char.upper :: CharParser st Char
01:10:53 <lambdabot> Data.Char.UppercaseLetter :: GeneralCategory
01:10:53 <lambdabot> Data.Char.isUpper :: Char -> Bool
01:10:55 <Maddas> > (printf "foo" ) ++ "bar"
01:10:56 <lambdabot>  "foobar"
01:10:59 * wli dumps the SVD and analytically diagonalizes the matrix involved outright.
01:11:11 <yitz> :t toUpper
01:11:12 <lambdabot> Char -> Char
01:11:29 <Jedai> > let s = printf "foo" in putStr (map toUpper s)
01:11:30 <lambdabot>  <IO ()>
01:12:07 <yitz> Jedai: I guess it printed on lambdabot's screen.
01:12:48 <Jedai> yitz: I don't think so, Lambdabot has some defense against doing anything in IO
01:13:24 <Jedai> yitz: since it could be used to hack the server (maybe)
01:13:51 <yitz> Jedai: right, I wasn't serious. Put another way: lambdabot's screen is otherwise known as "/dev/null".
01:14:48 <Jedai> yitz: Ok, well I don't know if stdout for lambdabot is actually redirected to /dev/null... ;-)
01:16:59 <allbery_b> hm
01:17:09 <glguy> oh?
01:17:09 * allbery_b runs his in screen, so he can if needed pop a console
01:17:38 <allbery_b> ...and can see (sort of) when it's gone awol on a bad url again, or just hit the heap limit
01:22:59 <solrize> @hoogle printf
01:23:00 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
01:23:00 <lambdabot> Text.Printf :: module
01:23:00 <lambdabot> Text.Printf.PrintfType :: class PrintfType t
01:24:13 <Cale> yitz: It didn't even conceptually do that much. Basically, it built for you the IO action for printing some string on the screen, but didn't execute it.
01:24:29 <solrize> Text.Printf> printf "%04x" 35 :: String
01:24:29 <solrize> ERROR - Cannot justify constraints in type annotation
01:24:37 <Cale> > putStrLn "Hello" `seq` ()
01:24:38 <lambdabot>  ()
01:24:50 <Cale> evaluating an IO action doesn't cause it to actually happen.
01:25:26 <solrize> what causes it to happen then?
01:25:35 <solrize> you have to bind it /
01:25:37 <solrize> ?
01:25:56 <Cale> The Haskell runtime executes the IO action called main.
01:26:20 <Cale> (or in ghci, if you write an IO action, GHCi will cause it to execute)
01:26:45 <Cale> main in turn will be built up of smaller IO actions.
01:28:01 <Cale> In the context of a do-block, you can think of  v <- x  as meaning "execute x, capturing the result in v", but of course, the do-block as a whole does nothing but describe an action. Evaluating the do-block doesn't execute it.
01:28:42 <luqui> cabal-install is b0rken!
01:28:49 <luqui> when I try to install anything it says: cabal: dist/Conftest.c: openFile: does not exist (No such file or directory)
01:28:58 <solrize> cale, this brings up the question, why does forkIO make its action happen?
01:29:47 <Cale> solrize: It doesn't. It transforms an action x into another action which, when executed, starts a new thread in which it executes x
01:30:07 <Cale> :t forkIO
01:30:07 <lambdabot> Not in scope: `forkIO'
01:30:08 <solrize> hmm ok, so i have to sequence the differnt forks
01:30:17 <Cale> :t Control.Concurrent.forkIO
01:30:18 <lambdabot> IO () -> IO GHC.Conc.ThreadId
01:33:44 <Cale> If you have a lot of very similar threads to create, you might use mapM or forM
01:34:02 <solrize> yeah
01:34:23 <solrize> i just have 4 threads and they're all different, i put them into a do block
01:34:59 <wli> It's (1/2) * diag(diag(pascal(n)), diag(pascal(n))) * J(n) where pascal(n) is a vector with the n-th row of pascal's triangle along the diagonal, diag(v) is a potentially block diagonal matrix with diagonal entries corresponding to the vector v, and J(n) is the exchange matrix, whose nonzero entries are all 1's along the southwest-to-northeast diagonal.
01:35:42 <Cale> forM [1..100000] $ \n -> forkIO (print n) -- this is lots of fun to watch
01:36:03 <solrize> haha
01:37:21 <Cale> better to make it a forM_ of course, as ghci likes to also print the *result* of the IO action these days
01:37:28 <Cale> (I actually really hate that)
01:38:31 <solrize> yeah, [(),(),...]
01:38:48 <Cale> In this case, it'll be a list of ThreadId values.
01:39:21 <Cale> (of course, useless, since by the time it prints them, all the threads will have finished)
01:46:15 <yitz> luqui: time to raise the cabal-install emergency alarm. dcoutts!
01:47:29 <yitz> @seen dcoutts
01:47:29 <lambdabot> I saw dcoutts leaving #gentoo-haskell, #haskell-soc, #haskell-overflow, #haskell and #ghc 33m 51s ago, and .
01:47:37 <yitz> @seen dcoutts_
01:47:37 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #haskell and #ghc. I don't know when dcoutts_ last spoke.
01:47:46 <yitz> @seen dcoutts__
01:47:46 <lambdabot> dcoutts__ is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow and #haskell-soc. I don't know when dcoutts__ last spoke.
01:49:18 <wagle_home> @seen light
01:49:18 <lambdabot> I haven't seen light.
01:50:56 <ertai> @seen anyone
01:50:56 <lambdabot> I haven't seen anyone.
01:52:40 <yitz> Cale: one of the first lines in my dot-ghci is :set -fno-print-bind-result
01:53:20 <Cale> yitz: mine too, but it seems not to listen to me quite a lot of the time
01:53:28 <yitz> just before :set -fno-monomorphism-restriction :)
01:53:46 <Cale> also -fglasgow-exts and -farrows
01:54:01 <yitz> :set -package mtl
01:54:04 <faxathisia> ?where arrows
01:54:04 <lambdabot> http://www.haskell.org/arrows/
01:54:13 <Cale> That shouldn't be required.
01:55:04 <yitz> maybe not. I just upgraded to 6.8 a few days ago. it couldn't seem to find mtl, so I paniced and put that in
01:55:21 <Cale> Strange.
01:56:11 <Cale> Prelude> :m + Control.Monad.State
01:56:11 <Cale> Prelude Control.Monad.State> runState (return 5) 0
01:56:11 <Cale> Loading package mtl-1.1.0.0 ... linking ... done.
01:56:11 <Cale> (5,0)
01:56:23 <Cale> Mine does it on the fly.
01:56:26 <yitz> to do that, I also ended up with all kinds of debris like -XFlexibleInstances
01:56:53 <Cale> This is 6.8.2?
01:57:01 <yitz> yes, via MacPorts
01:57:07 <Cale> hmm
01:57:21 <Cale> There's a lot of strange stuff with the Mac GHC.
01:57:35 <yitz> maybe I don't need it anymore, I'll try taking it out later, if I have some time.
01:57:40 <faxathisia> with GHC on mack I got the same behavior as Cale
01:57:41 <Cale> btw, why didn't you just get the binary from the GHC website?
01:57:48 <faxathisia> I compiled it myself though because macports is bad
01:57:54 <faxathisia> mac*
01:58:06 <yitz> there is no binary available yet for Tiger. Manuel is working on it.
01:58:16 <faxathisia> you can just compile it
01:58:24 <Cale> Um, yes there is.
01:58:28 <yitz> I did. Using MacPorts
01:58:33 <Cale> http://haskell.org/ghc/dist/6.8.2/maeder/ghc-6.8.2-i386-apple-darwin.tar.bz2
01:58:37 <lambdabot> http://tinyurl.com/3xs9fx
01:58:47 <Cale> http://haskell.org/ghc/dist/6.8.2/maeder/ghc-6.8.2-powerpc-apple-darwin.tar.bz2
01:58:48 <lambdabot> http://tinyurl.com/39n28a
01:58:53 <yitz> Cale: are you sure that works for Tiger?
01:58:54 <Cale> those are for Tiger
01:59:13 <Cale> At least, they're explicitly labelled as such.
01:59:37 <Cale> http://haskell.org/ghc/dist/mac_frameworks/mac_e.htm -- you'll also need a couple frameworks from here
01:59:37 <lambdabot> Title: frameworks for Macintosh
02:00:13 <yitz> OK. Well, Manuel is working on an installer. That the Right Way to do it (and I'm sure Manuel's build won't have anything weird about it).
02:06:16 <faxathisia> I think the right way is to just compile the source
02:10:45 <Baughn> @instances MonadError
02:10:45 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
02:10:51 <Baughn> @src MonadError
02:10:51 <lambdabot> class (Monad m) => MonadError e m | m -> e where
02:10:51 <lambdabot>     throwError :: e -> m a
02:10:51 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
02:11:58 <Baughn> ..the tutorials didn't mention /this/.
02:12:06 <Baughn> OKay, I can use that..
02:26:02 <solrize> hmm, my ghc 6.8.2 installation doesn't have the Network module?
02:38:49 <luqui> how do I uninstall a package
02:39:08 <luqui> in particular, I have quickcheck-2.0 installed, and I want to get rid of it in favor of 1.1
02:42:43 <georgw> In function type declarations, can I already specify the variable names?
02:42:56 <faxathisia> no
02:43:13 <georgw> rlsSackB :: Int -> [Int] -> [Bool] -> [Int] -> ResultSack    <----- I can never remember what is what...
02:43:39 <faxathisia> rlsSackX :: Int -- Some comment
02:43:47 <luqui> you can document parameters (pretty common practice), or you can newtype some of those things
02:43:49 <faxathisia>       -> [Int] -- More remarks..
02:44:13 <georgw> faxathisia: so you split it up over a few lines?
03:01:38 <mnislaih> how come there is no readListBy :: ReadS a -> ReadS [a] in Text.Read? We have a readListDefault, so it makes sense to have a By variant which generalizes or replaces it
03:02:02 <faxathisia> :t map readS
03:02:04 <lambdabot> Not in scope: `readS'
03:02:55 <mnislaih> I want to be able to parse lists, i.e. "[foo,bar]", out of a parser for foos and bars
03:07:17 <luqui> does quickcheck have some sort of existential?  I have a property that says approximately "sometimes the answer comes out 4"
03:07:28 <luqui> (that was just an example)
03:10:40 <mnislaih> I hear smallcheck has some form of existentials, but never actually used it
03:11:52 <malcolmw> quickcheck cannot do existentials for a good theoretical reason
03:13:39 <yitz> mnislaih: what would be the separators between list elements in the source string?
03:14:29 <mnislaih> yitz: my proposal is that readListBy behaves exactly as readListDefault already does, only it takes an explicit ReadS a instead of extracting it from a Read instance
03:14:43 <mnislaih> the separators being commas in that case
03:15:42 <smg> is it inperformant to read all content of the file with getContents?
03:17:29 <yitz> smg: if you need performance, use ByteStrings.
03:19:29 <m_abuse> lo
03:20:12 <smg> yitz: ah thanks i forgot about
03:24:20 <m_abuse> ok, im fairly new to haskell and functional programming in general
03:24:41 <m_abuse> i need to have a task run in a regular interval
03:24:51 <m_abuse> say every 10 mins
03:24:59 <yitz> mnislaih: readListDefault is just a mechanism used by GHC for defining the readList method for some Read instances.
03:25:02 <oerjan> @hoogle threadDelay
03:25:03 <lambdabot> GHC.Conc.threadDelay :: Int -> IO ()
03:25:03 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
03:25:20 <oerjan> m_abuse: ^
03:25:26 <m_abuse> :-)
03:25:32 <m_abuse> thx
03:25:41 <mnislaih> yitz: I disagree. It is exported by the Text.Read module, so everybody is free to use it.
03:26:16 <yitz> mnislaih: so I think what you want is readList with the Read instance provided as a parameter, rather than having to actually declare an instance. Is that right?
03:26:51 <mnislaih> exactly. Since local instances aren't available in Haskell, I'll pass it a function
03:27:00 <yitz> The docs for that module say explicitly that this stuff is GHC only, and used only for that purpose internally. Why they exposed the guts, I don't know.
03:28:48 <yitz> data ReadWrapper a = RW (ReadS a) a; instance Read (ReadWrapper a) where ...
03:29:05 <oerjan> yitz: problem is there is nowhere to pass in the function :(
03:29:18 <yitz> yes there is - use a wrapper
03:29:30 <oerjan> no
03:29:54 <luqui> malcolmw, I'm willing to believe that, but... what is the reason?
03:29:58 <mnislaih> I could use a newtype wrapper around my type, and replace its Show instance with mine, but that doesn't work in general
03:30:16 <mnislaih> if the type is not under my control, e.g. in a polymorphic function in a library
03:30:20 <luqui> malcolmw, I can see how maybe it would cause the test to fail sometimes and succeed others depending on whether it found one, but that's the case for universals too
03:30:42 <oerjan> the problem is readsPrec etc. does not take any argument you can use
03:31:50 <yitz> I see.
03:32:41 <oerjan> there really should be some way to define local instances - if only for equally local newtypes
03:35:47 <ketil> Whut?  When trying to insert a DEPRECATED pragma, I get an error, saying that the file name doesn't match module 'Main'.  Is this a known issue?
03:37:30 <oerjan> what does your PRAGMA look like?
03:37:50 <oerjan> (and where do you put it?)
03:38:18 <DukeDave> dons: Sorry I disappeared previously.. I'll try and pull that latest darcs to try now :)
03:39:45 <oerjan> ketil: if you are trying to deprecate a whole module, it doesn't make sense for it to be the Main one, i think
03:40:06 <oerjan> otherwise you may have some syntax error?  hpaste.
03:56:49 <yitz> Hi DukeDave. Any progress?
04:01:52 <Cheery> @type fix
04:01:54 <lambdabot> forall a. (a -> a) -> a
04:02:11 <faxathisia> fix f = f (fix f)
04:02:15 <Cheery> > fix (*2)
04:02:17 <lambdabot>  Exception: <<loop>>
04:02:23 <luqui> > fix (1:)
04:02:23 <faxathisia> > fix (1 :)
04:02:24 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:02:25 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:02:26 <faxathisia> heh
04:02:59 <Cheery> so fix is the Y-combinator
04:03:06 <luqui> yeps
04:03:12 <faxathisia> No
04:03:21 <Cheery> na?
04:03:34 <faxathisia> You cannot type the y combinator in haskell
04:03:35 <luqui> well, it's not the cbv y combinator
04:03:58 <luqui> i.e. it's not:  \f -> (\x -> f (x x)) (\x -> f (x x))
04:04:01 <luqui> but it is still a Y combinator
04:04:11 <luqui> i.e. observationally equivalent
04:04:11 <faxathisia> It's not a combinator
04:04:18 <luqui> faxathisia, ??
04:04:34 <faxathisia> fix f = f (fix f)
04:04:41 <faxathisia> fix is not a bound variable
04:04:55 <osfameron> I thought it was described as a fixed-point combinator ?
04:05:12 <luqui> oh you seem to have a more specific definition of combinator than I do
04:05:24 <ziman> > fix (\x -> 4 / x)
04:05:24 <lambdabot>  Exception: <<loop>>
04:05:26 <faxathisia> :t (\m->((\x->x x) (\y->(m (y y)))))
04:05:27 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
04:05:27 <lambdabot>     Probable cause: `x' is applied to too many arguments
04:05:27 <lambdabot>     In the expression: x x
04:05:36 <faxathisia> Y combinator can't type
04:05:45 <luqui> that is only one implementation of the fixpoint combinator
04:05:45 <Cheery> hm. y-combinator whas that mockingbird mockingbird spicied and flavoured
04:06:10 <luqui> perhaps I am mistaken if wikipedia is correct :-)
04:06:59 <luqui> okay, fine, it is a fixpoint function, and it is observationally equivalent to the Y combinator.  there.  whew.
04:07:06 <quicksilver> yeah.
04:07:17 <quicksilver> the point is, the Y combinator doesn't need to use recursion.
04:07:20 <quicksilver> that's why it's clever.
04:07:23 <quicksilver> fix isn't clever at all.
04:07:27 <quicksilver> not remotely.
04:07:30 <quicksilver> it's just recursion.
04:07:50 <luqui> but HM can't type any functions that recurse without using recursion
04:08:01 <Cheery> hm. why can't you type Y-combinator in haskell?
04:08:13 <Cheery> because you'd otherwise need to accept infinite types?
04:08:26 <quicksilver> Cheery: because it uses its arguments at multiple types.
04:08:33 <luqui> yeah I think that is basically what it boils down to...
04:08:53 <Cheery> and why fix's type signature is (a -> a) -> a ?
04:09:00 <quicksilver> that's a strange question.
04:09:27 <quicksilver> why is anything type signature what it is? because it is...
04:09:40 <quicksilver> fix takes one argument of type a -> a and returns a ?
04:09:44 <luqui> Cheery, but it's a fixed point function
04:09:53 <luqui> it finds the fixed point of a function...
04:10:23 <luqui> give it a function, it gives you an argument for which the function doesn't change the argument.  sounds like (a -> a) -> a to me...
04:10:58 <Cheery> > fix ('a':)
04:10:58 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
04:11:01 <malcolmw> luqui: sorry, fire alarm.  QuickCheck tests random values, but an existential simply says there is some value for which the property holds.  You have no guarantee of finding that value by random sampling
04:11:10 <Cheery> @type ('a':)
04:11:11 <lambdabot> [Char] -> [Char]
04:11:30 <Cheery> > ('a':) "rgh"
04:11:31 <lambdabot>  "argh"
04:11:36 <luqui> malcolmw, you have no guarantee of finding a breakage case for a universal either...
04:11:47 <malcolmw> luqui: whereas a universal quantification says that the property holds for all values, so any random value will work
04:11:51 <luqui> malcolmw, though I suppose it is more catastrophic for a good test to fail than vice versa
04:12:58 <Cheery> > ('a':) ('a':)
04:12:59 <lambdabot>  Couldn't match expected type `[Char]'
04:13:05 <malcolmw> luqui: so given enough random values, you can persuade yourself that the error case is very rare
04:13:16 <Cheery> > (('a':) . ('a':)) "rgh"
04:13:17 <lambdabot>  "aargh"
04:13:47 <malcolmw> luqui: but given enough random values with an existential, you may never be satisfied, because you still have not found the one validating case
04:14:03 <Cheery> I don't remember the function now...
04:14:12 <Cheery> it was a fix with count
04:14:29 <Cheery> @hoogle (a -> a) -> a
04:14:29 <lambdabot> Data.Function.fix :: (a -> a) -> a
04:14:30 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
04:14:30 <lambdabot> Control.Monad.State.Class.modify :: MonadState s m => (s -> s) -> m ()
04:14:36 <luqui> malcolmw, yeah, I guess it only made sense in my (somewhat odd) context.  I'm writing functions that generate distributions of values, and I needed to make sure that some values came up sometimes...
04:14:36 <Cheery> @hoogle Int -> (a -> a) -> a
04:14:37 <lambdabot> No matches, try a more general search
04:14:58 <quicksilver> Cheery: you can, incdentally, type the Y combinator via a data type with some wrapping unwrapping
04:15:05 <luqui> malcolmw, any idea for a good way to test that?
04:15:19 <DukeDave> yitz: No I'm afraid not, I've posted a mail (and an update about 30 seconds go) to cafe..
04:15:26 <Cheery> quicksilver..
04:15:45 <DukeDave> Do we know if cafe echoes your mail back to you though because I haven't got a copy back off the mailing list
04:16:10 <yitz> I don't see the new posting either.
04:16:26 <DukeDave> Hum, its up here: http://www.haskell.org/pipermail/haskell-cafe/2008-March/040433.html
04:16:28 <lambdabot> Title: [Haskell-cafe] Re: Constructing Data.Map from ByteString, http://tinyurl.com/2a94uw
04:16:34 <Cheery> need to wonder about that some dark evening
04:16:50 <oerjan> Cheery: maybe you are confusing with replicate?
04:16:57 <Cheery> nope
04:17:01 <Cheery> @type replicate
04:17:02 <lambdabot> forall a. Int -> a -> [a]
04:17:18 <Cheery> @type repeat
04:17:19 <lambdabot> forall a. a -> [a]
04:17:20 <yitz> DukeDave: no need to panic, you won't need C++ for sure :)
04:17:26 <oerjan> or perhaps iterate + !! ?
04:17:33 <malcolmw> luqui: use SmallCheck instead of QuickCheck. It's very similar, but does exhaustive testing up to some depth bound, which you can iteratively increase.  And it allows the expression of existentials.
04:17:34 <nornagon> @doc Num
04:17:35 <lambdabot> Num not available
04:17:37 <Cheery> @type iterate
04:17:38 <nornagon> @index Num
04:17:38 <lambdabot> forall a. (a -> a) -> a -> [a]
04:17:38 <lambdabot> Prelude
04:17:51 <ziman> >fix (*0)
04:17:54 <DukeDave> yitz: I don't know, this is a work project & it needs to get done  *_*
04:17:56 <Cheery> iterate neither seems correeect
04:18:04 <ziman> > fix (*0)
04:18:05 <lambdabot>  Exception: <<loop>>
04:18:22 <DukeDave> If I can't fit the whole Map in memory then performance will be unacceptable
04:18:37 <yitz> I never measured the overhead in Data.Map, but there will definitely be some. It is a tree built up out of lists; lists have a few bytes of overhead for each node.
04:19:03 <ndm> luqui: or use lazysmallcheck, its on hackage and runs about twice as fast as smallcheck, but no existentials
04:19:03 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
04:19:04 <oerjan> Cheery: iterate and !!
04:19:07 <DukeDave> I could put up with a 10/15% mark up over a C++ implementation but 5 times the size of the data set is a little too much!
04:19:07 <ndm> @messages
04:19:07 <lambdabot> dcoutts_ said 4d 10h 28m 58s ago: cabal upload is supposed to work, I use it. Is it not being nice to you?
04:19:16 <quicksilver> yitz: sure, but I really don't think it should be this much.
04:19:16 <Cheery> @type !!
04:19:17 <oerjan> :t \f x n -> iterate f x !! n
04:19:18 <lambdabot> parse error on input `!!'
04:19:18 <lambdabot> forall a. (a -> a) -> a -> Int -> a
04:19:24 <Cheery> @type (!!)
04:19:25 <lambdabot> forall a. [a] -> Int -> a
04:19:53 <Cheery> [1,2,3] !! 2
04:19:55 <DukeDave> yitz: I was going to do some memory overhead testing this morning using Ints but have to do some 'real work' first..
04:19:56 <yitz> So for now, why now just read the bytes into memory - a UArray, or even a Ptr to raw memory. (are your keys sorted?)
04:20:21 <Cheery> hehe. oerjan, really interesting
04:20:38 <DukeDave> yitz: I'm intrigued, I've neither heard of UArray nor Ptr!   (keys are not sorted)
04:20:42 <yitz> You can move back to something more pure later, if you don't let the low-level interface escape to the rest of your program.
04:20:58 <Cheery> > iterate ('a':) "rgh" !! 50
04:20:58 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaargh"
04:21:20 <ndm> if you are globbing massive amounts of data at a seriously low level, i'd just use C
04:21:21 <Cheery> need to remember that for next time when I really mess up
04:21:28 <yitz> Cheery: not very nice, what did lambdabot ever do to you?
04:21:30 <ndm> unless the processing calls out for Haskell
04:21:46 <oerjan> is there a Beast in here?
04:21:50 <ndm> @let doh = iterate ('a':) "rgh" !! 50
04:21:51 <lambdabot> Defined.
04:21:59 <ndm> Cheery: now you don't have to remember so much
04:22:02 <Cheery> > print "doh"
04:22:02 <lambdabot>  <IO ()>
04:22:05 <ndm> > doh
04:22:06 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaargh"
04:22:13 <DukeDave> yitz: I'll blast through my morning updates (which won't take long because it's my Haskell code ;) and then get reading up on UArray & Ptr
04:23:24 <mauke> > False ++ True
04:23:25 <lambdabot>   add an instance declaration for (Monoid Bool)
04:23:25 <lambdabot>     In the expression: False ...
04:23:37 <nornagon> Is there a way to express a list of exactly 16 elements in the type of some value?
04:23:42 <ndm> @type (++)
04:23:42 <lambdabot> forall m. (Monoid m) => m -> m -> m
04:23:43 <Cheery> there's an another thing I'd like about
04:24:06 <nornagon> apart from, you know, foo :: (a,a,a,...,a) or anything equally horrible
04:24:33 <Cheery> > ('g':) (iterate ('o':) "rgh" !! 60)
04:24:34 <lambdabot>  "goooooooooooooooooooooooooooooooooooooooooooooooooooooooooooorgh"
04:24:39 <opqdonut> nornagon: type-level arithmetic
04:24:45 <nornagon> actually i think i want an MArray, now that I think about it. It's to represent the memory of a toy microprocessor
04:24:48 <Cheery> urps. meant.
04:24:55 <nornagon> opqdonut: sounds like way too much effort :)
04:25:00 <Cheery> > ('g':) (iterate ('o':) "gle" !! 80)
04:25:00 <lambdabot>  "goooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo...
04:25:06 <Cheery> > ('g':) (iterate ('o':) "gle" !! 70)
04:25:07 <lambdabot>  "goooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooogle"
04:25:38 <Cheery> @let google = ('g':) (iterate ('o':) "gle" !! 60)
04:25:38 <lambdabot> Defined.
04:26:05 <Cheery> @let googleit = unwords [google, "it"]
04:26:05 <lambdabot> Defined.
04:26:13 <Cheery> > googleit
04:26:13 <lambdabot>  "goooooooooooooooooooooooooooooooooooooooooooooooooooooooooooogle it"
04:26:28 <ndm> > 'h' : tail google
04:26:29 <lambdabot>  "hoooooooooooooooooooooooooooooooooooooooooooooooooooooooooooogle"
04:28:38 <desegnis> nornagon: If you'd want a really comfortable way to express this, you'd need dependant types, which we don't have in Haskell
04:29:01 <nornagon> ah :(
04:29:22 <nornagon> I'll go for the ugly ol' IOUArray Int Int, then, because I'm after speed
04:29:57 <nornagon> (i plan on exhaustively checking a certain function on the entire Int space)
04:30:02 <nornagon> Int32, that is
04:30:15 <desegnis> nornagon: In Haskell you'd have to model the 16 somehow with the type system, which can only be done slightly more elegantly than with a 16-tuple
04:30:16 <yitz> @let yell x=let{(a,b)=break(`elem`"aeiou")x;(c,d)=splitAt 1 b}in a++concat(replicate 50 c)++d
04:30:17 <lambdabot> Defined.
04:30:27 <Cheery> > yell
04:30:28 <lambdabot>  <[Char] -> [Char]>
04:30:33 <Cheery> > yell "a"
04:30:34 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
04:30:35 <yitz> > yell "stop"
04:30:35 <lambdabot>  "stoooooooooooooooooooooooooooooooooooooooooooooooooop"
04:30:47 <Cheery> > yell "foobar"
04:30:48 <lambdabot>  "fooooooooooooooooooooooooooooooooooooooooooooooooooobar"
04:30:52 <Cheery> > yell "fbar"
04:30:53 <ziman> lol
04:30:53 <lambdabot>  "fbaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaar"
04:31:06 <nornagon> > yell "ftgn"
04:31:07 <lambdabot>  "ftgn"
04:31:11 <ziman> > yell lol
04:31:12 <lambdabot>   Not in scope: `lol'
04:31:17 <ziman> > yell "lol"
04:31:18 <lambdabot>  "looooooooooooooooooooooooooooooooooooooooooooooooool"
04:31:26 <hallongrottan> lol
04:31:47 <trez> now that's useful!
04:31:48 <Cheery> implicitly useful and important function
04:32:09 <nornagon> provably useful
04:32:15 <mejja> hallongrottan: snuskhummer ;-)
04:32:19 <Botje> > "spart" ++ yell "a"
04:32:20 <lambdabot>  "spartaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"
04:32:24 <hallongrottan> mejja: lol va?
04:32:25 <hallongrottan> aha
04:32:27 <hallongrottan> lol
04:32:53 <hallongrottan> mejja: well, it wasnt meant to be, really. I just made it up like to joke with skorpan, sort of
04:33:38 <pejo> hallongrottan, how does hallongrottan relate to skorpan?
04:34:16 <hallongrottan> pejo: hallongrotta is a pastry, aswell as skorpor
04:34:22 <hallongrottan> in swedish
04:53:48 <skorpan> yell "fuck"
04:53:52 <skorpan> > yell "lol"
04:53:56 <lambdabot>  "looooooooooooooooooooooooooooooooooooooooooooooooool"
04:53:56 <skorpan> > yell "fuck"
04:53:57 <lambdabot>  "fuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuck"
04:54:08 <czShadoW> :src yell
04:54:13 <skorpan> > /whois jpy
04:54:13 <lambdabot>   parse error on input `/'
04:54:17 <skorpan> > /whois jyp
04:54:17 <lambdabot>   parse error on input `/'
04:54:24 <skorpan> wow
04:54:32 <skorpan> that was silly
04:54:43 <hallongrottan> skorpan: sup?
04:54:48 <ibid> :yell "whatever"
04:54:57 <skorpan> hallongrottan: nothing much
04:55:02 <ibid> > yell "whatever"
04:55:03 <lambdabot>  "whaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaatever"
04:55:07 <ibid> hah
04:55:19 <skorpan> > yell "lambda"
04:55:40 <lambdabot>  "laaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaambda"
04:55:49 <ibid> > yell "grr!"
04:55:50 <lambdabot>  "grr!"
04:55:53 <ibid> h√∂
04:55:55 <smg> mh
04:56:05 <skorpan> > "it's over NINE THOUS" ++ yell "AND"
04:56:05 <lambdabot>  "it's over NINE THOUSAND"
04:56:06 <ibid> > yell "aa!"
04:56:06 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa!"
04:56:12 <smg> i have doClose handl1 handl2 = hClose handl1 ; hClose handl2
04:56:24 <smg> i tried to do doClose = map (hClose)
04:56:26 <DQuest> > yell "Wadler!"
04:56:27 <lambdabot>  "Waaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaadler!"
04:56:30 <smg> but this will give me a type error
04:56:41 <quicksilver> smg: yes, because map wants a list of parameters.
04:56:42 <ibid> smg: mapM_ perhaps?
04:56:47 <DQuest> see, I'd have expanded the e rather than the a there.
04:56:51 <idnar> > "it's over NINE THOUS" ++ yell "and"
04:56:52 <lambdabot>  "it's over NINE THOUSaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaand"
04:57:02 <smg> ah mapM_
04:57:09 <quicksilver> smg: try : doClose h1 h2 = mapM_ hClose [h1,h2]
04:57:41 <DukeDave> ghci question.. When issuing a do notation bind like 'x <- f y' can I say "please don't call show on the x"?
04:57:52 <quicksilver> DukeDave: there is an option for it
04:58:11 <DukeDave> quicksilver: Google was fruitless :|
04:58:29 <Jedai> smg: "map action xs" gives you [IO a] (which is not an action), while "mapM action xs" gives IO [a] which is one
04:58:31 <yitz> :set -fno-print-bind-result
04:58:55 <Jedai> smg: and mapM_ throws away the result if you only care about the effects
04:58:58 <DukeDave> yitz: You're just my favourite at the moment :D
04:58:59 <smg> quicksilver: yeah doClose mapM_ (hClose) works
04:59:01 <quicksilver> DukeDave: hmm. maybe there isn't.
04:59:07 <smg> Jedai: i know :] but ty
04:59:11 <DukeDave> quicksilver: yitz got it,
04:59:16 <quicksilver> ah
04:59:35 <yitz> DukeDave: It's in my .ghci file.
05:00:54 <smg> can we simplify this: do { args <- getArgs; arg1 !! 3} ?
05:01:14 <quicksilver> (!!3) <$> getArgs
05:01:28 <quicksilver> assuming 'arg1' was a typo.
05:01:30 <dcoutts> yitz: pong
05:01:40 <yitz> DukeDave: btw, now that I think of it, a Ptr makes no sense. If a UArray doesn't work, then just read it in as one huge ByteString.
05:01:48 <yitz> dcoutts: pong
05:01:57 <yitz> dcoutts: uh, ping
05:01:58 <dcoutts> luqui: use the latest development version of Cabal and cabal-install
05:02:27 <yondalf> @src (<$>)
05:02:27 <lambdabot> f <$> a = fmap f a
05:02:52 <yondalf> @src (IO a) fmap
05:02:53 <lambdabot> Source not found. I am sorry.
05:02:58 <yondalf> @src IO fmap
05:02:58 <lambdabot> fmap f x = x >>= (return . f)
05:03:04 <dcoutts> yitz: oh, looks like you just wanted me to talk to luqui
05:03:12 <yondalf> is this true for all monads?
05:03:15 <yitz> yes. thanks
05:03:34 <oerjan> yondalf: yep
05:03:50 <mauke> @src liftM
05:03:50 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
05:03:55 <yondalf> oerjan: thanks
05:04:17 <Gilly> hmh, there are at least 3 alternatives for sql database connectivity on hackage, hsql, haskelldb and hdbc, any ideas which i should use?
05:04:46 <quicksilver> write your own with a different API from all three
05:04:47 <quicksilver> !
05:04:47 <yondalf> what was the other function (besides <$>) that we use if we want to apply a two-argument function to two monadic values?
05:04:53 <quicksilver> yondalf: liftM2
05:04:57 <quicksilver> or <$> <*>
05:05:01 <quicksilver> depending what you meant :)
05:05:04 <Gilly> quicksilver: :)
05:05:06 <yondalf> quicksilver: yup, looking for <*>
05:05:09 <yitz> Gilly: don't forget takusen
05:05:21 <yondalf> @src (<*>)
05:05:21 <lambdabot> Source not found. Just try something else.
05:05:30 <oerjan> @src Applicative
05:05:30 <lambdabot> class Functor f => Applicative f where
05:05:30 <lambdabot>     pure  :: a -> f a
05:05:30 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
05:06:19 <yondalf> i think i'll just switch with liftM and friends for now...not so conceptually mind-boggling :-P
05:06:24 <quicksilver> Gilly: hdbc is the most "practically oriented" I think.
05:06:44 <quicksilver> Gilly: takusen has IMO a cleaner design.
05:06:58 <quicksilver> hsql is not very actively maintained right now.
05:07:02 <smg> btw is it good to use local function declarations?
05:07:19 <quicksilver> I think local functions are good. yes.
05:07:27 <yitz> quicksilver: does anyone support MySQL? Weird that this seems rare.
05:07:30 <smg> ah but i can't declare the type of it local
05:07:35 <quicksilver> smg: you can.
05:07:47 <SamB> quicksilver: you can't always!
05:07:52 <quicksilver> let f :: Int -> Int ; f x = x + 1
05:07:54 <quicksilver> SamB: true.
05:07:59 <smg> ah i can really cool thank you
05:08:25 <quicksilver> smg: normally you would use a newline, not a ;
05:08:38 <quicksilver> yitz: I can't think of any reason why anyone would use mysql.
05:08:38 <SamB> smg: sometimes it is impossible to give a type signature to a local function in Haskell 98, because you would need scoped type variables...
05:08:41 <oerjan> yondalf: btw (<*>) = ap for Monads
05:08:42 <Gilly> ok, thanks yitz, quicksilver :)
05:08:48 <quicksilver> yitz: :P
05:09:17 <yitz> quicksilver: I can. A customer uses it and wants me to access their DB.
05:09:19 <SamB> yitz: sqlite is reportedly more robust
05:09:20 <quicksilver> but my understanding is that hdbc - odbc - mysql is supposed to work.
05:09:42 <SamB> but admittedly will not access existing mysql databases
05:09:55 <yitz> I like postgresql, personally, but I'm not always the one who chooses.
05:10:11 <yitz> quicksilver: odbc. yuck.
05:10:41 * quicksilver shrugs.
05:10:46 <quicksilver> mysql. yuck.
05:10:48 <quicksilver> it's up to you :P
05:11:13 <yitz> quicksilver, the db is not up to me. the driver is.
05:11:31 <SamB> hmm. why does xterm not respond while I run cat /dev/zero...
05:11:37 <quicksilver> SamB: sqlite doesn't support foreign key constraints AIUI.
05:11:49 <quicksilver> SamB: this doesn't strike me as 'robust' ;)
05:11:54 <SamB> foreign key constraints?
05:14:53 <Baughn> SamB: "If you insert a row with column foo=x, there must be another row with column bar=x in table baz"
05:15:06 <Baughn> SamB: Basically. Though it gets more complex.
05:15:12 <SamB> oh
05:15:38 <smg> SamB: oh i see
05:23:54 <bitshifter> So, I'm having trouble getting cabal to run haddock.  It claims it can't find the program, but when I run runhaskell Setup.lhs haddock -v3 the first thing it says is that it finds haddock and it's correct version.
05:24:03 <bitshifter> Is there something I need to do?
05:24:29 <dcoutts> bitshifter: ah, you're getting that too
05:24:44 <dcoutts> bitshifter: it's hard to reproduce, so don't clean yet
05:24:57 <dcoutts> last time we never managed to track it down
05:25:11 <dcoutts> bitshifter: so can you tell me what you did to get to this situation?
05:25:27 <dcoutts> where you starting from a clean tree, did you recently install haddock or upgrade it?
05:25:35 <bitshifter> I was trying to build the docs for xmonad
05:25:47 <dcoutts> ok
05:25:49 <bitshifter> haddock wasn't installed so I ran cabal install haddock
05:26:08 <bitshifter> then I may or may not have reconfigured my xmonad tree
05:26:13 <dcoutts> bitshifter: ah ok, and then ran cabal haddock again
05:26:26 <bitshifter> Yep
05:26:30 <dcoutts> bitshifter: I'd expect you to get that behaviour if you had not reconfigured
05:26:50 <dcoutts> bitshifter: as you note, there is code there to try and find haddock even if it had not previously been configured
05:26:53 <bitshifter> So, why would it find haddock and then complain that it couldn't find it.
05:26:59 <dcoutts> bitshifter: but as you also note, it' doesn't work :-)
05:27:11 <bitshifter> Ahh, well, that's terribly confusing.
05:27:17 <shepheb> oh, yeah, I couldn't figure that out a while back too.
05:27:18 <dcoutts> yes, sorry
05:27:24 <bitshifter> np
05:27:28 <dcoutts> bitshifter: I fixed it in the dev version, but should should find that configuring again fixes it
05:27:39 <dcoutts> should should / you should
05:27:57 <bitshifter> I'm not a stranger haskell, but cabal and cabal-install are still something of a mystery to me,
05:28:30 <dcoutts> bitshifter: report bugs and confusion, it's the only way we'll know how to improve the user interface and experience
05:28:49 <bitshifter> I just ran into it.
05:28:55 <dcoutts> bitshifter: thanks for confirming the scenario that lead to that problem
05:29:13 <dcoutts> I'm confident it's fixed in the darcs version
05:29:17 <bitshifter> Np.  Should I fill out a bug-report?
05:30:32 <dcoutts> bitshifter: not for that one, it's already fixed
05:31:33 <bitshifter> alright.
05:31:34 <dcoutts> bitshifter: but if you find anything else then yes, check the list of current bugs/requests and and your comments or file a new ticket
05:31:44 <dcoutts> and/add
05:32:02 * dcoutts is making double word typos this morning
05:32:23 * dcoutts clearly needs more tea
05:33:23 <bitshifter> I once had a jar of food grade caffine powder.  I was never brave(foolish?) enough to try it.
05:34:12 <opqdonut> wow, where'd you get that?
05:34:49 <opqdonut> i know quite a few people who use caffeine pills but powder would be the ultimate thing :P
05:35:55 <bitshifter> biology lab.  Certain specimens are put in a caffeine solution for reasons I no longer remember.
05:36:50 <yitz> bitshifter: beware cans of powder from the biology lab.
05:37:11 <bitshifter> Indeed, this one was sealed from the manufacturer
06:02:41 <MarcWeber> dcoutts: Is there a general way of finding libraries? (the way takusen has implemented it ?)
06:03:03 <dcoutts> MarcWeber: I'm not sure exactly what you mean
06:03:12 <dcoutts> you mean finding C libraries?
06:04:18 <dcoutts> it's rather tricky to find C libs in general since you don't know where they are installed, if the lib uses pkg-config then it's easy and Cabal supports that directly
06:05:51 <MarcWeber> dcoutts: http://rafb.net/p/yJ4aJr24.html line 84 for sqllib . In this case there is a strange find exe and use "bin" (??) directory as lib directory.
06:05:52 <lambdabot> Title: Nopaste - No description
06:06:21 <MarcWeber> dcoutts: I don't say it's easy but cabal could provide this kind of find exe and append ../lib directory or such stuff
06:06:40 <MarcWeber> Because This is a trouble you get whenever using any kind of ffi for libs you haven't written
06:06:59 <dcoutts> MarcWeber: to be honest I'd never seen that style for finding libs before, takusen is the only one that does that as far as I know
06:08:12 <dcoutts> MarcWeber: I suspect it's because takusen is developed on windows and that trick probably works there
06:08:33 <dcoutts> because the db libs get installed all relative to some common root
06:08:53 <dcoutts> ie we find an exe on th %PATH% and then the lib dir is next to it
06:09:02 <dcoutts> that doesn't work on unix the layout is not the same
06:09:03 <gbacon> yikes, does darcs remove uncontrolled files on a pull?
06:09:36 <idnar> I've never seen it do that
06:11:31 <dcoutts> MarcWeber: so what I'd suggest for the takusen Setup.hs and .cabal is to use flags and not to filter the exposed modules in the Setup.hs
06:12:07 <dcoutts> MarcWeber: it can use its current method of finding the exes etc, but there is better code to use to do that
06:12:46 <dcoutts> cabal already exports stuff for declaring programs and how to find them
06:13:24 <dcoutts> MarcWeber: the main thing I can't see how to do portably is how to make the selection of which backends to use automatic
06:13:28 <yitz> gbacon: here's how it can happen:
06:14:19 <dcoutts> MarcWeber: in cabal-1.4 I might do it by adjusting the default values of the flags, but that code is not exposed in cabal-1.2
06:15:10 <dcoutts> MarcWeber: I looked at the takusen Setup.hs and .cabal for a while the other day, I'm sure the Setup.hs can be cut to a quarter of the length but I don't see a nice way to do what they're trying to do
06:15:24 <yitz> you add a file foo a repo, then remove it. In the meantime, a copy of the repo which has never seen foo, has a file named foo unkown to darcs. If you now pull patches to the copy without being careful, you'll obliterate the local foo.
06:16:15 <RayNbow> http://eigenclass.org/hiki/warm-fuzzy-things-for-random-simulations <-- this somehow reminded me of Gen :p
06:16:20 <lambdabot> Title: eigenclass - Warm fuzzy things for random simulations, http://tinyurl.com/yuhhwm
06:18:06 <yitz> gbacon: that's why you're given the chance to accept or decline each patch when you pull.
06:18:12 <gbacon> yitz: I pulled the latest lambdabot and built it
06:18:26 <gbacon> I lost my private .rc file
06:18:43 <yitz> ouch.
06:18:47 * gbacon nods
06:19:05 <faxathisia> ?where hpaste3
06:19:05 <lambdabot> I know nothing about hpaste3.
06:19:08 <faxathisia> ?where hpaste2
06:19:08 <lambdabot> I know nothing about hpaste2.
06:19:53 <dcoutts> Saizan: so you've tested the root-cmd stuff right? the code looks ok to me so as long as you say you've tested it, then I'll apply it.
06:20:12 <Saizan> dcoutts: yes, with various packages
06:20:19 <dcoutts> Saizan: great
06:20:21 <yitz> gbacon: could it be that there was no rc file in the repo before you pulled, and they added one in the meantime? That would explain it.
06:20:43 <yitz> even if we explain it, that's a small consolation.
06:20:54 <gbacon> yitz: there are a couple in the repo but with different names
06:23:08 <yitz> I tried once to build lambdabot, but there were too many deps. I decided I'll just use the one here.
06:23:27 <gbacon> yitz: false alarm; I have two local lambdabot repos
06:23:37 <yitz> yay!
06:23:57 <gbacon> it's still early in the morning here
06:26:16 <nominolo> hm, what is a good name for flip foldMap ?
06:26:33 <yondalf> @src foldMap
06:26:33 <lambdabot> Source not found. Take a stress pill and think things over.
06:26:40 <nominolo> :t foldMap
06:26:41 <lambdabot> Not in scope: `foldMap'
06:26:54 <nominolo> foldMap :: Monoid m => (a -> m) -> t a -> m
06:27:32 <mauke> what is t?
06:27:42 <doserj> Foldable t
06:27:45 <nominolo> oh, right.  Foldable t
06:28:03 <yondalf> hmm...why must m be a monoid?
06:28:19 <yondalf> @src Foldable
06:28:19 <lambdabot> Source not found. Take a stress pill and think things over.
06:28:49 <nominolo> i find runWriter $ for (...) $ \x -> ... kind of ugly
06:29:22 <nominolo> yondalf: it combines the results
06:29:53 <quicksilver> nominolo: foldOver? foldFor?
06:30:15 <quicksilver> foldOver tree (\e -> [e])
06:30:17 <quicksilver> looks OK to me.
06:30:38 <nominolo> hm, yes.  looks ok
06:30:45 <yondalf> foldWith?
06:30:55 <yondalf> @hoogle With
06:30:55 <lambdabot> Foreign.Marshal.Utils.with :: Storable a => a -> (Ptr a -> IO b) -> IO b
06:30:55 <lambdabot> Foreign.ForeignPtr.withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
06:30:55 <lambdabot> System.IO.withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
06:31:45 <yondalf> nominolo: withFoldable?
06:32:08 <nominolo> "with" suggests some combination function parameter
06:32:38 <yondalf> well, there is a function parameter which is the last parameter...what do you mean by combination though?
06:32:44 <MarcWeber> dcoutts: so there are two problems here: find the libs and not expose modules which aren't used (eg if no oracle is installed don't compile the oracle stuff)
06:32:48 <nominolo> > Map.singleton 'a' 4 `mappend` Map.singleton 'a' 5
06:32:49 <lambdabot>   Not in scope: `Map.singleton'
06:33:01 <MarcWeber> dcoutts: The latter is solved by hsql by providing backends, right?
06:33:10 <nominolo> > M.singleton 'a' 4
06:33:11 <lambdabot>  fromList [('a',4)]
06:33:17 <nominolo> > M.singleton 'a' 4 `mappend` M.singleton 'a' 5
06:33:18 <lambdabot>  fromList [('a',4)]
06:33:30 <dcoutts> MarcWeber: right
06:33:33 <nominolo> oh, not good
06:33:41 <mauke> @src Map mappend
06:33:41 <lambdabot> Source not found.
06:33:49 <yondalf> @src M.mappend
06:33:50 <lambdabot> Source not found. Where did you learn to type?
06:34:04 <dcoutts> MarcWeber: and it basically takes the same approach for finding the cflags etc to use for the C libs, it runs some custom code and writes out a .buildinfo file
06:34:56 <MarcWeber> dcoutts: I see that there is no other way then learning cabal properly now. It bites me too often :)
06:35:34 <dcoutts> MarcWeber: writing custom Setup.hs scripts is a black art, the rest of Cabal is simple by comparison
06:36:05 <MarcWeber> dcoutts: something like this would be a dead simple configuration http://rafb.net/p/ISyvEo63.html
06:36:05 <lambdabot> Title: Nopaste - No description
06:36:05 <dcoutts> MarcWeber: because nobody has ever figured out and written down what API Setup scripts need or want
06:36:57 <dcoutts> MarcWeber: I don't think it's something we'd provide because it's more than a bit specialist and it would not work on unix for most packages
06:37:15 <dcoutts> MarcWeber: but we do provide code to take a set of cflags and turn them into a BuildInfo
06:37:34 <dcoutts> which should help for calling these foo_config programs
06:38:44 <dcoutts> MarcWeber: that, and it would not be clear when we'd found the lib, they're named differently on every platform
06:39:55 <dcoutts> MarcWeber: anyway, the actual code to find it doesn't seem to me to be the hard part
06:41:06 <dcoutts> MarcWeber: we do provide a way to declare extra program and then for them to be requried as "build-tools:" which can also be conditional
06:42:18 <MarcWeber> dcoutts: named differently? you mean sqlite3 is called SQlITE3.34.dll on windows?
06:43:05 <MarcWeber> dcoutts: Maybe the right way to go is look at tools such as cmake how they solve this cross platform trouble.
06:44:46 <dcoutts> MarcWeber: the lib naming conventions are quite variable, eg even on windows something named 'foo' might be found as foo.a foo.lib, libfoo.a libfoo.dll foo.dll and probably others too! :-)
06:46:09 <MarcWeber> dcoutts: So why not allow them all and use the first one? I mean libfoo and foo will (hopefully) contain the same contents if found
06:46:48 <dcoutts> MarcWeber: I have no confidence we'd know all the variations, the proper way to find a lib is to ask the linker and give it your search path.
06:47:32 <dcoutts> MarcWeber: though with that way we never find out where the lib is, we just know the search path to use to use it again
06:47:52 <dcoutts> MarcWeber: that's what autoconf does when it tells you its looking for libfoo
06:48:01 <MarcWeber> dcoutts: So hei, we dont' have t ofind the libs, we only have to find all search paths? That's all about: the package info which search path to use.
06:48:30 <dcoutts> right, but knowing the search path often means finding some foo_config program
06:49:34 <quicksilver> and foo_config programs where invented precisely because this problem is so fakking hard :P
06:49:41 <dcoutts> eg running mysql_config --libs and mysql_config --cflags
06:49:59 <dcoutts> quicksilver: and pkg-config was invented because there are too many foo_config programs :-)
06:50:09 <dcoutts> and... Cabal supports pkg-config directly
06:50:34 <dcoutts> sqlite3 uses pkg-config for its config
06:50:41 <dcoutts> sadly mysql and postgresql do not yet
06:51:00 <dcoutts> so we still have to call their silly config programs, but it's not that hard
06:52:02 <dcoutts> MarcWeber: btw, that's the right way to find the sqlite flags on unix, to use pkg-config, finding the sqlite3 binary tells you nothing about where the libs are installed
06:52:35 <dcoutts> though that may work ok on windows where you can guarantee some fixed relative path between the .exe and the libs
06:52:37 <MarcWeber> dcoutts: in my case it does :)
06:53:15 <dcoutts> @hpaste
06:53:15 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:53:40 <hpaste>  dcoutts pasted "suggested Takusen.cabal" at http://hpaste.org/6279
06:54:45 <hpaste>  dcoutts annotated "suggested Takusen.cabal" with "Setup.hs snippet" at http://hpaste.org/6279#a1
06:56:04 <dcoutts> MarcWeber: so that style gives much cleaner and shorted Setup.hs, what it doesn't give is automagically discovering the right flags to use
06:56:11 <dcoutts> though potentially it could do
06:56:27 <dcoutts> if we made available build-tools affect the configuration choice
06:56:39 <dcoutts> nominolo: we could do that couldn't we?
06:57:09 <nominolo> dcoutts: hm?
06:57:29 <dcoutts> nominolo: see the above hpaste
06:57:53 <dcoutts> nominolo: we'd want to pick the oracle flag if we can find the sqlplus build-tool
06:58:10 <dcoutts> nominolo: we could look for all build tools first and pass in the results, like we do for available packages
06:58:29 <nominolo> dcoutts: yup.
06:58:38 <nominolo> dcoutts: it also only needs to be done once
06:58:50 <dcoutts> nominolo: and indeed for pkgconfig-depends too
06:59:30 <dcoutts> we'd just flatten, find all the possibly wanted build tools and pkgconfig packages, try to find them all and pass them back when we finalise
06:59:54 <nominolo> we can map over the package structure
07:00:04 <nominolo> we can also add a fold
07:01:09 <nominolo> flatten is really only meant for external tools
07:01:15 <dcoutts> ok, yes
07:01:38 <MarcWeber> dcoutts: I've seen and read it. Now I'm reading the cabal documentation again
07:03:28 <nominolo> dcoutts: how is PkgConfig-Depends: sqlite3 different from Build-Tools: sqlite3 ?
07:03:53 <nominolo> dcoutts: also why is sqlite a build tool?
07:04:56 <dcoutts> nominolo: pkgconfig is the unix pkg-config program
07:05:14 <dcoutts> $ pkg-config --modversion sqlite3
07:05:14 <dcoutts> 3.5
07:05:29 <dcoutts> it's a tool to tell you all sort of useful stuff about c libs
07:05:44 <nominolo> yep, but why is sqlite3 a build tool, then?
07:05:51 <dcoutts> like their version, the C flags and linker flags you need to use them
07:06:03 <dcoutts> nominolo: and build-tool is a required program
07:06:14 <dcoutts> it must be declared as a known program to Cabal
07:06:32 <dcoutts> there's a list of built-in ones and it's expendable in the Setup.hs
07:06:47 <nominolo> ok, so the point is to let cabal check for the program
07:06:54 <dcoutts> right
07:06:57 <nominolo> although it won't use it during the build process
07:07:33 <dcoutts> well, the post-conf hook probably will, to interrogate it to find the clfags etc
07:07:46 <dcoutts> when you declare a Program you specify how to find it, the default is to look on the path
07:07:59 <smg> haha!
07:08:01 <dcoutts> that's what a simpleProgram "foobar" does
07:08:20 <smg> i implemented zipWith3... but now i see there is already zipWith3 :(
07:08:37 <dcoutts> @src zipWith3
07:08:37 <lambdabot> Source not found. stty: unknown mode: doofus
07:08:38 <nominolo> smg: always ask hoogle first :)
07:08:45 <glen_quagmire> > zipWith3 [1,2,3] "hello" [4,5]
07:08:46 <lambdabot>  Couldn't match expected type `a -> b -> c -> d'
07:09:08 <nominolo> :t (,,)
07:09:09 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
07:09:49 <glen_quagmire> > zipWith3 (,,) [1,2] "hello" [3,4]
07:09:50 <lambdabot>  [(1,'h',3),(2,'e',4)]
07:10:05 <gnuvince> :t (,,)
07:10:06 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
07:10:19 <gnuvince> > (,,) 1 2 3
07:10:19 <lambdabot>  (1,2,3)
07:10:23 <gnuvince> damn...
07:10:33 <glen_quagmire> > [,,] 1 2 4
07:10:33 <lambdabot>  Parse error at ",,]" (column 2)
07:10:44 <joricj> > : 1 2
07:10:44 <lambdabot>   parse error on input `:'
07:10:49 <faxathisia> hehe
07:10:52 <joricj> > (:) 1 2
07:10:53 <lambdabot>   add an instance declaration for (Num [t])
07:11:00 <shepheb> > (:) 1 [2]
07:11:01 <faxathisia> > ((:).(:[])) 1 2
07:11:02 <lambdabot>   add an instance declaration for (Num [[a]])
07:11:02 <lambdabot>  [1,2]
07:11:19 <faxathisia> > (((.).(.))(:)(:[])) 1 2
07:11:20 <lambdabot>  Couldn't match expected type `(->) t' against inferred type `[]'
07:11:43 <faxathisia> @pl \x y -> x : y : []
07:11:43 <lambdabot> (. return) . (:)
07:11:52 <faxathisia> :/
07:12:09 <glen_quagmire> base function of ==, <=, ... these is compare.  is there a base function for + - * / div ...etc?
07:12:10 <faxathisia> > ((.(:[])).(:)) 1 2
07:12:11 <lambdabot>  [1,2]
07:12:28 <glen_quagmire> like, i can implement ==, < , and other comparison operators using compare function
07:12:48 <glen_quagmire> how can I implement arithmetic operators using a base function? if there is one
07:13:23 <nominolo> glen_quagmire: see the instances for Num
07:13:38 <glen_quagmire> > let myEq a b = compare a b `elem` [EQ]  in "hey" `myEq` "hey"
07:13:38 <lambdabot>  True
07:14:12 <faxathisia> @let arithmo = \x y -> [x+y,x-y,x*y,x/y]
07:14:12 <lambdabot> Defined.
07:14:29 <faxathisia> > let x + y = arithmo x y !! 0 in  3 + 5
07:14:30 <lambdabot>  8.0
07:15:39 <glen_quagmire> :t [(+), (-), (*), (/), div]
07:15:40 <lambdabot> forall a. (Fractional a, Integral a) => [a -> a -> a]
07:15:51 <glen_quagmire> oh ExistentialType
07:16:16 <glen_quagmire> > [False, 1 == 1]
07:16:17 <lambdabot>  [False,True]
07:16:27 <glen_quagmire> when is 1 == 1 evaluated?
07:16:39 <quicksilver> glen_quagmire: when it tries to print 'True'
07:16:56 <glen_quagmire> > [False, 1 == 1, True] !! 3
07:16:56 <lambdabot>  Exception: Prelude.(!!): index too large
07:16:58 <quicksilver> that wasn't an existential type, btw.
07:17:01 <glen_quagmire> > [False, 1 == 1, True] !! 2
07:17:02 <lambdabot>  True
07:17:16 <faxathisia> > [False, undefined, True] !! 2
07:17:16 <lambdabot>  True
07:17:18 <glen_quagmire> > [False, trace "here" False, True] !! 2
07:17:19 <lambdabot>   Not in scope: `trace'
07:17:22 <ToRA> :t mapM ($) . mapM ($) [(+),(-),(*),(/)]
07:17:23 <lambdabot> forall a. (Fractional a) => a -> a -> [a]
07:18:27 <glen_quagmire> quicksilver: what was it? how was lambda bot able to store  [(+), (-), (*), (/), div]   ?
07:19:04 <quicksilver> it was a type.
07:19:09 <quicksilver> not an existential type.
07:19:11 <quicksilver> just a type :P
07:19:27 <quicksilver> all those operators have the same type (or can do, at least)
07:19:30 <quicksilver> so you can put them in a list.
07:19:41 <glen_quagmire> > let a =  [(+), (-), (*), (/), div]  in (a !! 0) 1 2
07:19:41 <lambdabot>  Add a type signature
07:19:51 <quicksilver> of coues, it's not a very useful type
07:19:55 <quicksilver> because it has no members :(
07:20:10 <quicksilver> there is no standard instance which is Fractional + Integral both.
07:20:10 <idnar> > let a =  [(+), (-), (*), div]  in (a !! 0) 1 2
07:20:10 <lambdabot>  3
07:20:25 <quicksilver> the problem is just because you have (/) and div both.
07:20:28 <glen_quagmire> that restricts for only Integrals
07:21:00 <glen_quagmire> i would want to do   (listOfOperators !! n) Fractional Fractional too
07:21:15 <idnar> > let a =  [(+), (-), (*), (/)]  in (a !! 0) 1 2
07:21:16 <lambdabot>  3.0
07:22:17 <cin> > let a =  [(+), (-), (*), div]  in (a !! 0) 1 2
07:22:17 <lambdabot>  3
07:23:03 <ketil> @seen oerjan
07:23:04 <lambdabot> I saw oerjan leaving #haskell 2h 7m 22s ago, and .
07:23:29 <faxathisia> :t arithmo
07:23:30 <lambdabot> forall a. (Fractional a) => a -> a -> [a]
07:23:53 <glen_quagmire> > arithmo :: Expr
07:23:54 <lambdabot>  Couldn't match expected type `Expr'
07:23:59 <glen_quagmire> > arithmo :: [Expr]
07:24:00 <lambdabot>  Couldn't match expected type `[Expr]'
07:24:01 <faxathisia> glen_quagmire: You can make a typeclass
07:24:14 <faxathisia> > arithmo x y
07:24:15 <lambdabot>  Couldn't match expected type `Double' against inferred type `Expr'
07:24:26 <faxathisia> ah that can't work
07:24:39 <faxathisia> @let arithmo = \x y -> [x+y,x-y,x*y,x/y] :: Expr -> Expr -> [Expr]
07:24:40 <lambdabot> <local>:6:0:     Multiple declarations of `L.arithmo'     Declared at: <local...
07:24:43 <faxathisia> @undef
07:24:43 <lambdabot> Undefined.
07:24:44 <faxathisia> @let arithmo = \x y -> [x+y,x-y,x*y,x/y] :: Expr -> Expr -> [Expr]
07:24:44 <lambdabot> Couldn't match expected type `Expr -> Expr -> [Expr]'
07:25:20 <quicksilver> > x / y
07:25:21 <lambdabot>  x / y
07:25:33 <quicksilver> > [x+y,x-y,x*y,x/y]
07:25:33 <lambdabot>  [x + y,x - y,x * y,x / y]
07:25:39 <quicksilver> > \x y -> [x+y,x-y,x*y,x/y]
07:25:40 <lambdabot>  <Double -> Double -> [Double]>
07:25:44 <quicksilver> > \x y -> [x+y,x-y,x*y,x/y] :: Expr
07:25:45 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
07:25:50 <glen_quagmire> > [x+y,x-y,x*y,x/y, div x y]
07:25:51 <lambdabot>  [x + y,x - y,x * y,x / y,x `div` y]
07:26:00 <quicksilver> > (\x y -> [x+y,x-y,x*y,x/y]) :: Expr
07:26:01 <lambdabot>      The lambda expression `\ x y -> ...' has two arguments,
07:26:01 <lambdabot>     but its type...
07:26:08 * quicksilver shrugs
07:26:12 <ToRA> > (mapM id . mapM id [f,g,h]) x y :: [Expr]
07:26:13 <lambdabot>  [f x y,g x y,h x y]
07:26:41 <cin> does this Expr fancy stuff work for all letters or names?
07:26:45 <cin> > foo / bar
07:26:45 <lambdabot>   Not in scope: `bar'
07:26:50 <faxathisia> > y e s
07:26:50 <lambdabot>  Couldn't match expected type `Expr -> Expr -> t'
07:26:57 <quicksilver> just the single character letters
07:27:01 <cin> > y * a * y
07:27:02 <lambdabot>  y * a * y
07:27:12 <faxathisia> > iterate (1+) 6
07:27:12 <lambdabot>  [6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,3...
07:27:25 <quicksilver> > iterate (1+) 6 :: Expr
07:27:26 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[t]'
07:27:29 <quicksilver> > iterate (1+) 6 :: [Expr]
07:27:30 <lambdabot>  [6,1 + 6,1 + (1 + 6),1 + (1 + (1 + 6)),1 + (1 + (1 + (1 + 6))),1 + (1 + (1 +...
07:27:39 <faxathisia> > flip concatMap
07:27:40 <lambdabot>  Add a type signature
07:29:50 <gnuvince> > foldl1 (^) [2..4]
07:29:51 <lambdabot>  4096
07:29:58 <gnuvince> > foldr1 (^) [2..4]
07:29:59 <lambdabot>  2417851639229258349412352
07:30:14 <faxathisia> ^ is not associative
07:30:47 <gnuvince> i know.
07:30:56 <faxathisia> > ( foldl1 (^) [2..4] , foldr1 (^) [2..4] ) :: ([Expr],[Expr])
07:30:56 <lambdabot>   add an instance declaration for (Integral [Expr])
07:30:57 <gnuvince> just wanted to see the difference
07:30:59 <faxathisia> :/
07:31:18 <faxathisia> > ( foldl1 (^) [x,y,z,w] , foldr1 (^) [x,y,z,w] ) :: ( [Expr] , [Expr] )
07:31:18 <lambdabot>  Couldn't match expected type `[Expr]' against inferred type `Expr'
07:31:26 <faxathisia> > ( foldl1 (^) [2..4] , foldr1 (^) [2..4] ) :: (Expr,Expr)
07:31:26 <lambdabot>  (2 * 2 * 2 * (2 * 2 * 2) * (2 * 2 * 2 * (2 * 2 * 2)),2 * 2 * (2 * 2) * (2 * ...
07:31:39 <faxathisia> huh that sucked
07:31:47 <faxathisia> > ( foldl1 (^) [x,y,z,w] , foldr1 (^) [x,y,z,w] ) :: ( Expr , Expr )
07:31:48 <DukeDave> Does anyone have a tutorial on Data.Map ?
07:31:52 <lambdabot> Terminated
07:32:33 <cin> dukedave: have you looked through the documentation?
07:33:22 <cin> dukedave: ( http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html )
07:33:23 <lambdabot> http://tinyurl.com/2mpwee
07:33:30 <DukeDave> As in http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html?
07:33:31 <lambdabot> http://tinyurl.com/2dua7p
07:33:40 <DukeDave> Ah :)
07:34:04 <DukeDave> Looking for something a little more tutorially, for my friend who's one Haskell day 2 ..
07:34:34 <nominolo> @instances-importing Monoid
07:34:34 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
07:34:59 <nominolo> > mempty :: ([Int], Map Int Char)
07:34:59 <lambdabot>   Not in scope: type constructor or class `Map'
07:35:05 <nominolo> > mempty :: ([Int], M.Map Int Char)
07:35:06 <lambdabot>  ([],fromList [])
07:35:46 <nominolo> > ([4::Int], ['a']) `mappend` ([6],"b")
07:35:46 <lambdabot>  ([4,6],"ab")
07:36:23 <yitz> DukeDave: tutorials usually focus more on lists, that's a more common and basic type. Once you've got that, the API docs for Data.Map should be fine.
07:37:17 <EvilTerran> > ([4::Int], ['a']) ++ ([6],"b")
07:37:18 <lambdabot>  ([4,6],"ab")
07:37:58 <EvilTerran> > succ . [1..5]
07:37:58 <lambdabot>  [2,3,4,5,6]
07:38:05 <EvilTerran> eeeeheheheh
07:38:29 <nominolo> earthy: did someone overload (++) ?
07:38:30 <cin> @hoogle succ
07:38:31 <lambdabot> Prelude.succ :: Enum a => a -> a
07:38:31 <lambdabot> GHC.Conc.alwaysSucceeds :: STM a -> STM ()
07:38:31 <lambdabot> System.Exit.ExitSuccess :: ExitCode
07:38:36 <nominolo> er EvilTerran
07:38:48 <EvilTerran> yeah... i think it was Cale
07:39:06 <nominolo> @info (++)
07:39:06 <lambdabot> (++)
07:39:17 <nominolo> @index (++)
07:39:17 <lambdabot> Data.List, Prelude
07:39:29 <nominolo> (++) = mappend ?
07:39:36 <yitz> > "a"++"b"
07:39:36 <lambdabot>  "ab"
07:39:54 <nominolo> > Nothing ++ Just 5
07:39:54 <lambdabot>  Add a type signature
07:39:58 <yitz> Nothing ++ Just 2
07:40:00 <nominolo> > Nothing ++ Just (5::Int)
07:40:00 <lambdabot>   add an instance declaration for (Monoid Int)
07:40:00 <lambdabot>     In the expression: Nothing...
07:40:04 <yitz> > Nothing ++ Just 2
07:40:04 <lambdabot>  Add a type signature
07:40:14 <EvilTerran> ?type (++)
07:40:15 <lambdabot> forall a. [a] -> [a] -> [a]
07:40:18 <EvilTerran> ?type (.)
07:40:19 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
07:40:28 <nominolo> > Nothing ++ Just 5 :: Maybe Int
07:40:28 <lambdabot>   add an instance declaration for (Monoid Int)
07:40:28 <lambdabot>     In the expression: Nothing...
07:40:33 <EvilTerran> hm
07:40:44 <yitz> > Nothing ++ Just "a"
07:40:45 <lambdabot>  Just "a"
07:40:57 <nominolo> instance Monoid a => Monoid (Maybe a) ???
07:40:58 <EvilTerran> > succ . [1..5] -- if that's the type of (.), why did this work a minute ago?
07:40:58 <lambdabot>  [2,3,4,5,6]
07:41:02 <nominolo> why that?
07:41:04 <xif> "The Cabal is only one contribution to the larger goal. In particular, the Cabal says nothing about more global issues such as how authors decide where in the module name space their library should live; how users can find a package they want; how orphan packages find new owners; and so on."
07:41:09 <xif> what is that project?
07:41:18 <EvilTerran> nominolo, it mappends the inner values of two Justs
07:41:41 <EvilTerran> nominolo, you may want First or Last
07:41:45 <nominolo> uhuh
07:41:53 <nominolo> i hate this wrapper stuff
07:42:00 <cin> > [1..5] >>= return . succ
07:42:01 <lambdabot>  [2,3,4,5,6]
07:42:07 <EvilTerran> i know. there's gotta be a better way of doing that.
07:42:25 <xif> I mean, what is that large project of which Cabal is a part?
07:42:31 <nominolo> it's like explicit type signatures
07:42:31 <EvilTerran> extend the type system sufficiently ;)
07:42:44 <nominolo> xif: Cabal is not part of anything
07:42:51 <nominolo> xif: but i guess you mean hackage
07:42:53 <Gilly> I'd like to read a 64 bit unsigned integer from a binary file (I got the handle) but I don't know how to do that, any advice?
07:43:34 <yitz> > mappend Nothing (Just (2::Int))
07:43:34 <Gilly> It seems I'd have to use hGetBuf but how would I construct a suitable pointer?
07:43:34 <lambdabot>   add an instance declaration for (Monoid Int)
07:43:35 <lambdabot>     In the expression: mappend...
07:43:42 <nominolo> Gilly: Data.Binary
07:43:51 <faxathisia> > Just . Nothing
07:43:51 <lambdabot>  Nothing
07:44:03 <EvilTerran> > mappend Nothing (Just (Sum 2))
07:44:03 <lambdabot>  Just (Sum {getSum = 2})
07:44:10 <nominolo> so (.) = fmap now?
07:44:21 <EvilTerran> > Nothing ++ Just (Sum 2) ++ Just (Sum 3)
07:44:22 <lambdabot>  Just (Sum {getSum = 5})
07:44:31 <faxathisia> :D
07:44:36 <faxathisia> yes
07:44:55 <EvilTerran> this may only last 'til someone does an @undef, i'm not sure how exactly Cale changed things
07:45:10 <xif> nominolo: that's right, thanks.
07:45:17 <faxathisia> @undef wont change it
07:45:18 <lambdabot> Undefined.
07:45:25 <EvilTerran> ?type (++)
07:45:26 <lambdabot> forall m. (Monoid m) => m -> m -> m
07:45:35 <faxathisia> @src (++)
07:45:35 <lambdabot> (++) []     ys = ys
07:45:35 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
07:45:35 <nominolo> ?type (.)
07:45:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:45:38 <EvilTerran> apparently not.
07:45:38 <faxathisia> ^ this is stupid
07:45:43 <faxathisia> having @src out of sync
07:45:49 <EvilTerran> well, ?src works with a static database
07:46:03 <faxathisia> editable database
07:46:09 <EvilTerran> it'd be nice if it could spot you @let'ing things and temporarily update the @src for it
07:46:12 <Gilly> nominolo: ah, thanks, looks nice
07:46:34 <nominolo> now we need a cute symbol for mempty
07:46:43 <EvilTerran> 0
07:46:44 <faxathisia> √∏ ?
07:47:01 <EvilTerran> []
07:47:06 <faxathisia> > mempty :: [()]
07:47:06 <lambdabot>  []
07:47:07 <nominolo> yeah, but 0 is already is part of Num (kind of)
07:47:16 <faxathisia>  why not [] ?
07:47:26 <EvilTerran> but [] was gonna be mzero
07:47:38 <nominolo> @index mzero
07:47:38 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
07:48:04 <nominolo> @let o = mzero
07:48:04 <lambdabot> <local>:1:4:     Ambiguous type variable `m' in the constraint:       `MonadP...
07:48:13 <nominolo> @let o = mempty
07:48:13 <lambdabot> <local>:1:4:     Ambiguous type variable `a' in the constraint:       `Monoid...
07:48:17 <EvilTerran> DMR?
07:48:21 <EvilTerran> ?type mzero
07:48:22 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
07:48:26 <nominolo> D?
07:48:31 <EvilTerran> ?let o :: (MonadPlus m) => m a; o = mzero
07:48:32 <lambdabot> Defined.
07:48:36 <EvilTerran> "dreaded" :P
07:48:57 <nominolo> FMR
07:49:07 <EvilTerran> er... "friendly"?
07:49:17 <EvilTerran> > () ++ ()
07:49:18 <lambdabot>  ()
07:49:18 <nominolo> the other F-word
07:49:20 * EvilTerran giggles
07:49:45 <nominolo> > o ++ M.singleton 'a' "bb"
07:49:46 <lambdabot> Terminated
07:49:54 <nominolo> > o ++ M.singleton 'a' "bb"
07:49:55 <lambdabot> Terminated
07:49:58 <nominolo> wtf?
07:50:22 <yitz> > M.singleton 'a' "bb"
07:50:23 <lambdabot>  fromList [('a',"bb")]
07:50:30 <piotrsz> > 1 + 1
07:50:31 <lambdabot>  2
07:50:45 <yitz> > o :: M.Map Char String
07:50:45 <lambdabot> Terminated
07:50:47 <nominolo> > Sum o ++ Sum 2
07:50:47 <lambdabot> Terminated
07:50:54 <piotrsz> > [x | x<-[1..10]
07:50:54 <lambdabot>  Parse error at end of input
07:50:55 <nominolo> :t o
07:50:55 <lambdabot>     Ambiguous occurrence `o'
07:50:55 <lambdabot>     It could refer to either `L.o', defined at <local>:1:27
07:50:55 <lambdabot>                           or `SimpleReflect.o', imported from SimpleReflect at State/imports.h:68:0-32
07:51:03 <nominolo> oh, i see
07:51:12 <piotrsz> > [x | x <- [1..10]]
07:51:12 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
07:51:40 <nominolo> > foldr f o [1..3]
07:51:41 <lambdabot> Terminated
07:51:49 <nominolo> > x
07:51:49 <ketil> I would like to try to build my library against a specific (older) version of another library - is there some cabal magic that does this?
07:51:50 <lambdabot>  x
07:51:59 <piotrsz> > [x | x <- [1..10], x `mod` 2]
07:51:59 <lambdabot>   add an instance declaration for (Integral Bool)
07:52:00 <lambdabot>     In a list comprehension...
07:52:06 <nominolo> ketil: not yet
07:52:20 <piotrsz> > [x | x <- [1..10], x `mod` 2 == 0]
07:52:21 <lambdabot>  [2,4,6,8,10]
07:52:23 <ketil> nominolo, can I ghc-pkg hide the newer one, then?
07:52:41 <yitz> > [x | x <- [1..10], even x]
07:52:41 <piotrsz> :t print
07:52:41 <lambdabot>  [2,4,6,8,10]
07:52:42 <lambdabot> forall a. (Show a) => a -> IO ()
07:52:48 <nominolo> ketil: yes it can.  but i think cabal ignores this, atm.  that's probably a bug, though
07:52:56 <piotrsz> :t (?)
07:52:57 <lambdabot> Not in scope: `?'
07:53:03 <piotrsz> :t ($)
07:53:04 <lambdabot> forall a b. (a -> b) -> a -> b
07:53:10 <nominolo> ketil: this feature is planned for Cabal 1.4, though
07:55:28 <nominolo> ketil: http://hackage.haskell.org/trac/hackage/ticket/224
08:06:20 <roconnor> @type find
08:06:21 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
08:06:29 <roconnor> @type index
08:06:29 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
08:06:37 <ketil> nominolo, thanks.  I ended up just =='ing the version in my cabal file.
08:06:52 <roconnor> @hoogle a -> [a] -> Int
08:06:52 <lambdabot> No matches, try a more general search
08:07:00 <ketil> (maybe the 'bot could announce hackage uploads here? :-)
08:07:16 <sm> that would be nice
08:07:28 <nominolo> ketil: yeah that's the workaround for now
08:07:33 <sm> I think
08:07:42 * nominolo agrees
08:09:08 <quicksilver> ketil: the problem is that hackage uploads normally come at around 800 all in one go
08:09:08 <roconnor> @hoogle Maybe a -> Bool
08:09:09 <lambdabot> Data.Maybe.isJust :: Maybe a -> Bool
08:09:09 <lambdabot> Data.Maybe.isNothing :: Maybe a -> Bool
08:09:13 <quicksilver> ketil: when gwern is in the mood :)
08:09:27 <roconnor> @hoogle Maybe a -> a
08:09:28 <lambdabot> Data.Maybe.fromJust :: Maybe a -> a
08:09:28 <lambdabot> Data.Maybe.fromMaybe :: a -> Maybe a -> a
08:09:28 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
08:12:18 <Toxaris> maybe \bot could detect unfruitful discussions and point to new lib's for alternative discussion topics
08:15:38 <yitz> :t elemIndex
08:15:39 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
08:20:27 <tensh> are you doomed to run ghc 6.4.2 if you want to use wxhaskell?
08:21:41 <roconnor> I run wxhaskell with ghc 6.6.1
08:22:34 <conal> tensh: i use wxhaskell + ghc 6.8.2 on windows
08:22:37 <tensh> you're not using gentoo and got it via emerge I suppose?
08:23:19 <conal> roconnor: why still 6.6.1?  i ask because i'm wondering how long to keep 6.6 compat.
08:24:27 <paolino> is there a way to have a break which takes one more element ?
08:24:33 <conal> roconnor: (i mean why 6.6.1 instead of 6.8+)
08:24:55 <roconnor> conal: because that is the release that Ubuntu Gusty has.
08:25:10 <tensh> conal: what text editor are you using?
08:25:14 <conal> roconnor: oh, thanks.
08:25:18 <conal> tensh: emacs
08:25:43 <tensh> okay... might have to try out vim for windows ;)
08:26:15 <tensh> this is getting ridiculous
08:26:46 <tensh> ghc takes ages to compile and this is like the 4th time I do it
08:27:07 <conal> tensh: why 4?
08:27:17 <ohub> why do you compile it? Isn't there a binaries for your arch?
08:27:24 <shepheb> hmm. is there a way to double-buffer a drawing area in gtk2hs/cairo? the flickering is a pain.
08:27:46 <tensh> conal: I'm trying to get it to work with wxhaskell, and I'm not very good with emerge
08:27:57 <dcoutts> shepheb: it's double buffered by default, perhaps you're doing direct drawing rather than only drawing in the onExpose method?
08:28:04 <tensh> ohub: maybe, I didn't even know you could get that
08:29:04 <dcoutts> shepheb: the proper way is to invalidate the widget and let it get redrawn, you respond to the onExpose signal to actually do the drawing
08:29:07 <shepheb> dcoutts: hmm. onExpose logs a message that eventually causes another thread to draw. it's a white background and a grid right now, and I see the gray window background, then white, then the grid drawing.
08:29:12 <luqui> tensh, try installing wxhaskell using cabal
08:29:22 <dcoutts> shepheb: no you must draw in the onExpose itself
08:29:29 <shepheb> hmm, okay.
08:29:31 <paolino> @type  \t -> app. (first (++)) . break t
08:29:32 <luqui> tensh, the gentoo ebuild was broken for me too, but the cabal version installed cleanly
08:29:32 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:29:34 <dcoutts> shepheb: otherwise you do not get the benefit of the double buffering
08:29:45 <tensh> luqui: cool, I'll check it out
08:29:57 <shepheb> hmm. tricky concurrency, since the drawing is based on state.
08:30:05 <shepheb> tricky concurrency, since the drawing is based on state. thanks.
08:30:14 <ketil> Ever google for "ghc bugs"?  Perhaps even feeling lucky?
08:30:14 <shepheb> sorry, having some network trouble
08:30:24 <ketil> The top hit is: http://www.dcs.gla.ac.uk/fp/software/ghc/ghc-bugs.html
08:30:25 <lambdabot> Title: GHC Bugs Page
08:30:33 <ketil> What *is* it with haskell and google page rank?!
08:31:46 <nominolo> @pl \g f a bs -> f bs a f
08:31:46 <lambdabot> const (flip =<< (flip .) . flip)
08:31:52 <nominolo> @pl \g f a bs -> g f bs a f
08:31:52 <lambdabot> (flip . (flip .) . flip =<<)
08:32:24 <nominolo> @pl \f a bs -> g f bs a
08:32:24 <lambdabot> flip . g
08:32:39 <nominolo> :t flip . foldM
08:32:40 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> [b] -> a -> m a
08:33:07 <idnar> ketil: what else would ghc get you besides haskell?
08:33:35 <ketil> idnar: the point is that the page has been entirely irrelevant since about 1983.
08:33:41 <Deewiant> ketil: it helps that most of the pages on GHC's Trac are just "Custom Query - GHC - Trac"
08:33:53 <quicksilver> I think ketil refers to the fact that google consistently returns the wrong hits for haskell stuff :)
08:33:57 <roconnor> ketil: that was the last time there were bugs in GHC.
08:34:00 <roconnor> :P
08:34:00 <ketil> So I cannot for the life of me imagne who still links to it, and for what purpose.
08:34:03 <ketil> roconnor, :-)
08:34:07 <idnar> ketil: oh, right
08:34:12 <Deewiant> O_o GHC 2.08
08:34:23 <ketil> quicksilver, exactly right.
08:34:29 <quicksilver> ketil: nothing links to it, apparently.
08:34:39 <quicksilver> http://www.google.com/search?q=link:http://www.dcs.gla.ac.uk/fp/software/ghc/ghc-bugs.html
08:34:42 <lambdabot> Title: link:http://www.dcs.gla.ac.uk/fp/software/ghc/ghc-bugs.html - Google Search, http://tinyurl.com/3xj6xr
08:35:21 <yitz> paolino: you can trick groupBy into doing it for 2 elements. For more than that, you can group the whole list into groups of n, use break, and then concat all the pieces back together.
08:36:03 <yitz> @let groupsOf n = takeWhile (not . null) . map fst . tail . iterate (splitAt n . snd) . (,) []
08:36:04 <lambdabot> Defined.
08:36:12 <yitz> > groupsOf 3 [1..10]
08:36:13 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
08:36:26 <ketil> quicksilver, er.  So why does it - apparently - rank higher than the tons and tons of other pages mentioning bugs and ghc?
08:36:41 <quicksilver> ketil: no idea. If I knew how google ranking worked that precisely I'd be a millionaire :)
08:36:49 <ketil> google made a nice search engine in the nineties, but seems to have moved on to more interesting projects since then.
08:36:50 <idnar> maybe www.dcs.gla.ac.uk has a really high pagerank for unrelated reasons
08:37:03 <paolino> yitz: I'm needing something simpler I think
08:37:18 <quicksilver> yitz: I think takeWhile (not.null) . map (take n) . iterate (drop n) is more attractive
08:37:18 <yitz> that's good :)
08:37:45 <shepheb> dcoutts: can I block the onExpose thread until the drawing is done?
08:37:58 <yitz> quicksilver: sure is.
08:38:17 * quicksilver is allergic to fst and snd :)
08:38:29 <paolino> \t zs -> let (xs,ys) = break t zs in xs ++ head ys
08:38:45 <dcoutts> shepheb: you can, but don't block too long or the UI will appear to have frozen
08:38:59 <paolino> it's just break breaks too early
08:39:06 <shepheb> dcoutts: hopefully it will be pretty snappy. worth a try, since that's by far the simplest way.
08:40:26 <yitz> paolino: often I'll have things like let (x, _:ys) = break ... But only if I'm *sure* that I'll find it.
08:40:43 <quicksilver> me too.
08:40:46 <quicksilver> win 12
08:41:56 <paolino> is that the same as mine ?
08:42:55 <paolino> mmh, mine doesn't typecheck :)
08:43:12 <yitz> @pl \n -> takeWhile (not.null) . map (take n) . iterate (drop n)
08:43:12 <lambdabot> (takeWhile (not . null) .) . ap ((.) . map . take) (iterate . drop)
08:43:35 <paolino> @type \t zs -> let (xs,ys) = break t zs in xs ++ [head ys]
08:43:35 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:44:21 <paolino> > (\t zs -> let (xs,ys) = break t zs in xs ++ [head ys]) (==5) [1..]
08:44:21 <lambdabot>  [1,2,3,4,5]
08:45:13 <luqui> you have a bug
08:45:21 <luqui> (\t zs -> let (xs,ys) = break t zs in xs ++ [head ys]) (==5) [1..4]
08:45:29 <luqui> > (\t zs -> let (xs,ys) = break t zs in xs ++ [head ys]) (==5) [1..4]
08:45:29 <lambdabot>  Exception: Prelude.head: empty list
08:45:40 <paolino> my list is infinite
08:45:47 <yitz> @pl \n->takeWhile(not.null).map fst.tail.iterate(splitAt n.snd).(,)[]
08:45:47 <lambdabot> ((takeWhile (not . null) . map fst . tail) .) . (. (,) []) . iterate . (. snd) . splitAt
08:46:03 <paolino> and contains that element
08:46:12 <yitz> quicksilver: ok, still nicer, but I never did like those aps.
08:46:26 <glen_quagmire> can I say monad is a typeclass that comes with two operations: return , (>>=) ?
08:46:47 <luqui> glen_quagmire, that's what I'd say
08:46:53 * glen_quagmire writes tutorial of monad
08:46:57 <luqui> lol
08:47:09 <faxathisia> yes but there is a condiction
08:47:17 <faxathisia> return and >>= have to satisf
08:47:22 <glen_quagmire> monadic laws 1,2,3
08:47:35 <faxathisia> what are they?
08:47:56 <glen_quagmire> i forgot.   return f == f      .. etc
08:48:07 <Toxaris> people have to pass a short test on #haskell before being allowed to write a monad tutorial
08:48:08 <faxathisia> ?
08:48:12 <yitz> * glen_quagmire and faxathisia co-author a monad tutorial
08:48:27 <Dybber> I would say a monad is return, bind and a type, not a typeclass.
08:48:32 <desegnis> return x >>= f   =   f x
08:48:43 * luqui never got his monad-tutorial-writing rite of passage
08:48:57 <Toxaris> I would say a monad is a concept from CT, and Monad is a Haskell typeclass
08:48:58 <faxathisia> thank you desegnis
08:49:04 <desegnis> t >>= return   =   t
08:49:14 <luqui> to make up for it, I'm giving a monad-tutorial talk at the CS colloquium 8-p
08:49:15 <glen_quagmire> return a >>= f == f a; f >>= return == f; f >>= (\x -> g x >>= h) == (f >>= g) >>= h
08:49:22 <tromp> > return 3 >>= (+1)
08:49:23 <lambdabot>   add an instance declaration for (Num (m b))
08:49:33 <shepheb> does verbally teaching handful of converts about monads count?
08:49:49 <DQuest> One thing that caused me trouble with understanding monads is that I didn't understand the type system properly
08:50:01 <shepheb> I probably need more scale.
08:50:21 <DQuest> I actually got it when I read about how types work and saw an example with applicative functors
08:50:40 <tromp> > return 3 >>= (1+)
08:50:41 <lambdabot>   add an instance declaration for (Num (m b))
08:50:44 <yitz> > runIdentity (return 3 >>= return . (+1))
08:50:44 <lambdabot>   Not in scope: `runIdentity'
08:50:46 <roconnor> DQuest: where did you see that?
08:50:55 <yitz> > Control.Monad.runIdentity (return 3 >>= return . (+1))
08:50:55 <lambdabot>   Not in scope: `Control.Monad.runIdentity'
08:51:05 <yitz> > Control.Monad.Identity.runIdentity (return 3 >>= return . (+1))
08:51:05 <lambdabot>   Not in scope: `Control.Monad.Identity.runIdentity'
08:51:29 <tromp> @where runIdentity
08:51:29 <lambdabot> I know nothing about runidentity.
08:51:34 <shepheb> dcoutts: seems to be working, much smoother. a little stutter is much less distracting than seeing it redraw the grid.
08:51:37 <yitz> wtf?
08:51:51 <luqui> @hoogle runIdentity
08:51:51 <lambdabot> Control.Monad.Identity.runIdentity :: Identity a -> a
08:51:58 <luqui> hmm
08:52:04 <dcoutts> shepheb: aye
08:52:10 <quicksilver> it must not import Control.Monad.Identity
08:52:16 <roconnor> Identity isn't in the imports.
08:52:20 <roconnor> I ran into that problem before. :(
08:52:25 <shepheb> dcoutts: thanks again.
08:52:31 <yitz> @slap lambdabot
08:52:31 * lambdabot hits lambdabot with a hammer, so he breaks into a thousand pieces
08:52:34 <dcoutts> shepheb: np
08:52:37 <yitz> oops
08:52:50 * Toxaris plans to write an applicative functor tutorial at some point which provides enough background to understand monads without any tutorial, just by looking at the type of (>>=) or join
08:53:27 <luqui> one could interpret that as.... one-upping the monad tutorial writers
08:53:34 <luqui> you trying to pick a fight Toxaris?
08:53:56 <faxathisia> You need to look at rules too
08:56:35 <Toxaris> luqui: well I believe that people have different learning needs. there may be people who wants to learn about a quite specific, complicated abstraction with a lot of laws first, then generalize this in the direction of more abstract, easier to understand and more ubiquitous abstractions. but for me at least, it's the other way around... ;)
08:56:41 <quicksilver> the rules of applicative functors are arguably simpler to understand/motivate.
08:57:07 <quicksilver> that could be an advatnage of going that way
08:57:25 <earthy> you know, all that monad tutorial shit
08:57:47 <earthy> and we still don't have any good tutorials on how to write larger scale interesting programs in haskell
08:58:05 <faxathisia> earthy: it's pretty easy ?
08:58:09 <quicksilver> I haven't seen a good tutorial on writing a larger scale interesting program in any language.
08:58:10 <faxathisia> Just keep writing code
08:58:21 <quicksilver> larger scale programs are almost by definition a bit too large for tutorials :)
08:58:28 <Toxaris> on the other hand, if you go the Functor-Applicative-Monad road, you have to study a long tutorial including examples etc. before you can use the full power of monads.
08:59:16 <earthy> oh well, I like what Bryan, Don and John are doing with Real World Haskell
08:59:47 <quicksilver> me too.
08:59:52 <quicksilver> Or, I like what I hope they are doing P)
09:02:28 <pejo> quicksilver, there's beta-chapters available!
09:04:33 <quicksilver> pejo: I know, I didn't find time to read them, or not much.
09:04:38 <ToRA> random question: is x `seq` x always the same (modulo unsafeP..IO) as x?
09:05:14 <quicksilver> ToRA: yes.
09:05:32 <ToRA> quicksilver: ta
09:05:50 <quicksilver> ToRA: "x `seq` x is x, unless x is _|_, in which case it is x"
09:06:00 <quicksilver> ToRA: follows from the definition nicel :)
09:09:39 <georgw> Why can I not reuse member names in data types? e.g. have one itemlist::[Item] in one data type and the same in another data type?
09:09:48 <georgw> Error: Multiple declarations of `Main.itemlist'
09:10:12 <Deewiant> because that's just sugar for "itemList :: Foo -> [Item]; itemList (Foo i) = i"
09:10:18 <Deewiant> it's all in the global namespace, unfortunately
09:11:08 <ToRA> you can to some degree in ghc if you have separate modules...
09:11:10 <ToRA> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields
09:11:12 <lambdabot> Title: 8.3. Syntactic extensions, http://tinyurl.com/y6v6by
09:11:15 <georgw> But it should be able to keep them apart, because it can check the type of Foo, no? For one it should be Foo -> [Item] and for the other Bar -> [Item]
09:11:42 <Baughn> georgw: It should. This wart is very well known.
09:11:43 <Deewiant> you can't overload functions in Haskell without using type classes
09:11:57 <Baughn> georgw: The only reason it's still there is that nobody can decide what the perfect solution is
09:11:58 <ToRA> ghc will let you in a module that imports 2 definitions module use ambiguous record names in non-ambiguous situations
09:12:24 <Baughn> Deewiant: Right, but field names could be syntactic sugar for an instance declaration. ;)
09:12:37 <quicksilver> Deewiant: of course it's not *just* sugar for that. that's *part* of what it's sugar for.
09:12:39 <Deewiant> Baughn: yes, they could, but they aren't. :-)
09:12:43 <georgw> Ok, I see. So the easiest workaround (and probably safest) is to pick different names...
09:12:54 <Deewiant> quicksilver: true, poor wording on my part.
09:13:00 <Baughn> georgw: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields <-- This probably does what you want
09:13:01 <lambdabot> Title: 8.3. Syntactic extensions, http://tinyurl.com/y6v6by
09:13:04 <yitz> Baughn: field names could be all kinds of syntactic sugar. It just isn't yet.
09:13:30 <quicksilver> I'm not sure if I'd want every record label to introduce a hidden type class
09:13:38 <quicksilver> that sounds fairly heavyweight
09:13:39 <Deewiant> georgw: What I do is prefix (a part of) the data type's name to each field name
09:13:43 <quicksilver> would be interesting to play with.
09:14:00 <quicksilver> georgw: or, if they're "big" types, put them in separate modules.
09:14:07 <Jomyoot> How do I print UTF8 without having it show "\3615\3627\3585\3604"
09:14:29 <quicksilver> Jomyoot: use utf8string or compactstring or encoding.
09:14:32 <georgw> Ok, I'll stick to prefixing then. It's reasonably small.
09:15:17 <Baughn> quicksilver: There should be *some* way of fixing the problem that doesn't mean you lock haskell to a single bad solution forevermore
09:15:49 <quicksilver> Baughn: I don't disagree in principle. It just remains for someone to take a good idea and implement it :)
09:28:24 <Jomyoot> does Database.HSQL automatically handle UTF8?
09:28:26 <Jomyoot> it appears so
09:28:30 <Jomyoot> really confused
09:33:27 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6281
09:33:50 <roderyk> http://hpaste.org/6281   << can someone explain how to make that "work"? :)
09:34:05 <roderyk>     Non type-variable argument in the constraint: Ord (a, b)
09:34:05 <roderyk>     (Use -XFlexibleContexts to permit this)
09:34:44 <roderyk> maybe this is already built-in / there is a better way?
09:35:47 <glen_quagmire> > let sortElem1 (x,_) (y,_) | x<y = LT |otherwise = GT in sortElem1 (1,4) (2,4)
09:35:49 <roderyk> oh, I see... Just (Ord a) is needed.
09:35:52 <lambdabot>  LT
09:36:14 <glen_quagmire> i usually don't write type declarations until compiler forces me to
09:37:10 <roderyk> it helps when trying to understand type systems :)  I see where my logic was wrong
09:42:02 <Jomyoot> Is HSQL the typical choice for working with MYSQL?
09:42:52 <glen_quagmire> :t (|)
09:42:52 <lambdabot> parse error on input `|'
09:44:49 <Jomyoot> Anyone uses HSQL?
09:48:57 <glen_quagmire> i never used database with haskell.    http://haskell.org/haskellwiki/Applications_and_libraries/Database_interfaces
09:49:03 <lambdabot> Title: Applications and libraries/Database interfaces - HaskellWiki, http://tinyurl.com/32a6lg
10:06:21 <georgw> I'm trying to tidy up code by using where clauses, but it seems I there are certain variables I cannot access from within there, is that normal?
10:06:48 <tensh> @karma
10:06:48 <lambdabot> You have a karma of 0
10:06:52 <tensh> :)
10:06:55 <MarcWeber> georgw: A use case would help us to help you :)
10:07:02 <sebell> georgw: Yeah, hpaste!
10:07:29 <georgw>   putStrLn $ "Folding solution: "
10:07:29 <georgw>                ++ show (stepper (SackState initsack initItems initvalues)  (Dataset thelist thedist manyrandoms capacity))
10:07:29 <georgw>                    where initsack = Knapsack 0 0 []
10:07:29 <georgw>                          initItems = replicate itemcount False -- 100 should be itemcount
10:07:29 <georgw>                          initvalues = [0]
10:07:30 <georgw>                          thedist = 5
10:07:39 <quicksilver> georgw: where clauses scope over the equation they are attached to.
10:07:39 <sebell> @hpaste
10:07:39 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:07:53 <quicksilver> inclusing all guards if appropriate.
10:07:59 <faxathisia> tensh++
10:08:09 <quicksilver> you can't attach a where clause to an expression.
10:08:17 <quicksilver> so that "where" isn't attached to the putStrLn
10:08:23 <georgw> Ahh.
10:08:28 <quicksilver> it must be attached to the enclosing defintion
10:08:30 <tensh> faxathisia: does that increase it?
10:08:48 <mauke> @karma tensh
10:08:48 <lambdabot> tensh has a karma of 1
10:08:59 <tensh> cool :)
10:09:06 <georgw> quicksilver: Does that mean I cannot access variables higher up in a where?
10:09:17 <quicksilver> no, not necessariy
10:09:25 <quicksilver> it means you need to explain a bit more what your code does.
10:09:26 <quicksilver> :P
10:09:34 <quicksilver> "variables higher up" reall isn't very clear.
10:09:41 <quicksilver> it's best to talk of enclosing scopes
10:10:19 <georgw> I have a let .... in main where itemcount is defined. Now I want to use that itemcount to derive initItems as shown above
10:10:49 <georgw> And I want it to be somewhat tidy. If I replace "initItems" by what I have set it to in the where, it all works.
10:10:50 <EvilTerran> > let { xs = zip ys zs where { ys = 1 : zs; zs = 0 : ys } } in xs
10:10:51 <lambdabot>  [(1,0),(0,1),(1,0),(0,1),(1,0),(0,1),(1,0),(0,1),(1,0),(0,1),(1,0),(0,1),(1,...
10:11:12 <faxathisia> > fix ((1,0):(0,1):)
10:11:13 <lambdabot>      The operator `:' [infixr 5] of a section
10:11:13 <lambdabot>         must have lower precede...
10:11:22 <EvilTerran> everything defined in a where{} can see everything else defined in the same where{}
10:11:27 <faxathisia> > fix (((1,0):).((0,1):))
10:11:27 <lambdabot>  [(1,0),(0,1),(1,0),(0,1),(1,0),(0,1),(1,0),(0,1),(1,0),(0,1),(1,0),(0,1),(1,...
10:11:40 <EvilTerran> and nothing that had its name shadowed by something in the where{}
10:11:47 <quicksilver> georgw: why not put all those other things in a let too?
10:11:53 <quicksilver> georgw: mixing lets and wheres leads to confusin :)
10:12:02 <EvilTerran> faxathisia, yes, but i'm demonstrating mutual recursion in a where{} block here
10:12:05 <wieczyk> > :t 1
10:12:05 <lambdabot>   parse error on input `:'
10:12:11 <EvilTerran> ?type 1
10:12:12 <lambdabot> forall t. (Num t) => t
10:12:14 <georgw> quicksilver: Yeah, that sounds like a plan... :-)
10:12:21 <quicksilver> the where is probably attaching to your entire "main" definition
10:12:21 <glen_quagmire> oh   f :: String -> String   then f can't use getLine at all
10:12:41 <quicksilver> as such, it can't "see" any local variables defined in mini-scopes inside main
10:12:44 <quicksilver> like lets, for example.
10:12:44 <wieczyk> > f :: d -> c
10:12:44 <lambdabot>        add (SimpleReflect.FromExpr c, Show d) to the context of
10:12:44 <lambdabot>         the p...
10:12:47 <glen_quagmire> IO monad is a trap!
10:13:28 <georgw> quicksilver: ok, I see.
10:29:43 <Cale> :t zero
10:29:44 <lambdabot> forall m. (Monoid m) => m
10:29:59 <byorgey> > [3,4] ++ zero
10:29:59 <lambdabot>  [3,4]
10:30:03 <byorgey> huzzah! =)
10:30:13 <byorgey> Cale++
10:30:14 <dejones> > zero ++ zero
10:30:14 <lambdabot>  ()
10:30:17 <dejones> i win!
10:30:23 <byorgey> hah!
10:30:30 <dejones> get lower than that!
10:30:31 <dejones> ;)
10:30:33 <Gilly> where is liftIO defined?
10:30:37 <byorgey> :t \cale -> (cale++)
10:30:38 <lambdabot> forall m. (Monoid m) => m -> m -> m
10:30:39 <mauke> @index liftIO
10:30:39 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
10:30:44 <dejones> byorgey: n1
10:30:45 <Cale> In Control.Monad.Trans
10:30:48 <Gilly> Thanks.
10:32:41 <quicksilver> > succ zero
10:32:42 <lambdabot>  Exception: Prelude.Enum.().succ: bad argument
10:32:49 <quicksilver> !!!
10:32:57 <quicksilver> interesting exception :)
10:33:06 <dejones> :t zero
10:33:07 <idnar> heh
10:33:07 <lambdabot> forall m. (Monoid m) => m
10:33:16 <dejones> hmm
10:33:19 <idnar> zero is not the successor of any natural number
10:33:22 <idnar> :t succ
10:33:23 <lambdabot> forall a. (Enum a) => a -> a
10:33:29 <Saizan> > succ 1
10:33:29 <lambdabot>  2
10:33:30 <mauke> > getSum $ succ zero
10:33:30 <lambdabot>   add an instance declaration for (Enum (Sum a))
10:33:34 <idnar> succ zero :: Int
10:33:35 <quicksilver> I suspect () is an instance of Enum
10:33:36 <idnar> > succ zero :: Int
10:33:36 <lambdabot>   add an instance declaration for (Monoid Int)
10:33:42 <idnar> > succ zero :: Sum Int
10:33:42 <lambdabot>   add an instance declaration for (Enum (Sum Int))
10:33:42 <lambdabot>     In the expression: suc...
10:33:43 <quicksilver> and it's using that one.
10:33:47 <quicksilver> > fromEnum ()
10:33:47 <idnar> argh!
10:33:48 <lambdabot>  0
10:33:53 <mauke> > [() ..]
10:33:54 <lambdabot>  [()]
10:34:30 <idnar> hmm, so I guess () is the only type with an instance of both Monoid and Enum?
10:34:50 <glen_quagmire> @hoogle zero
10:34:52 <lambdabot> Control.Arrow.zeroArrow :: ArrowZero a => a b c
10:34:52 <lambdabot> Prelude.isNegativeZero :: RealFloat a => a -> Bool
10:34:52 <lambdabot> Control.Monad.mzero :: MonadPlus m => m a
10:35:12 <dolio> No. () is just the default.
10:36:50 <quicksilver> idnar: haskell never does that kind of search.
10:37:09 <idnar> quicksilver: what kind of search?
10:37:20 <quicksilver> "there is only one instance of Foo and Bar, so this must be that"
10:37:26 <quicksilver> violates the open class assumption.
10:37:28 <idnar> quicksilver: oh, right
10:37:38 <lament> shim at all usable?
10:37:41 <idnar> but are there any other instances of both classes?
10:37:47 <quicksilver> it always just generates the type "Foo a, Bar a => a"
10:37:53 <quicksilver> I can't think of any I must admit
10:37:57 <quicksilver> @instances Monoid
10:37:58 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
10:38:09 <idnar> @instances Enum
10:38:09 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
10:38:19 <quicksilver> > succ zero :: Maybe ()
10:38:20 <lambdabot>   add an instance declaration for (Enum (Maybe ()))
10:38:20 <lambdabot>     In the expression: su...
10:38:25 <quicksilver> nice try :-S
10:38:28 <idnar> heh
10:38:39 <mauke> > succ zero :: Ordering
10:38:40 <lambdabot>  GT
10:38:46 <mauke> BIATCH
10:38:53 <idnar> oh nice
10:38:57 <idnar> I didn't spot that one
10:40:22 <dejones> mauke: the added "BIATCH" really does it.  ;)
10:40:25 <dejones> hehe
10:48:24 <wieczyk> > f :: x -> y -> z
10:48:24 <lambdabot>        add (SimpleReflect.FromExpr z, Show y, Show x) to the context of
10:48:24 <lambdabot>      ...
10:48:29 <wieczyk> f :: x -> y -> z
10:48:33 <wieczyk> :t f
10:48:34 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
10:54:59 <dons> ?yow!
10:55:00 <lambdabot> What GOOD is a CARDBOARD suitcase ANYWAY?
10:56:31 <lament> wow, shim actually works!
10:56:36 <shepheb> I suppose guard does something uncouth in IO, like calling fail (and thus error)?
10:56:53 <byorgey> @src guard
10:56:53 <lambdabot> guard True  =  return ()
10:56:53 <lambdabot> guard False =  mzero
10:57:15 <byorgey> @src IO mzero
10:57:15 <lambdabot> mzero       = ioError (userError "mzero")
10:57:22 <Cale> shepheb: It throws an exception.
10:57:24 <byorgey> looks like =)
10:57:37 <Cale> mplus catches the exception :)
10:57:39 <quicksilver> shepheb: it's not all that uncouth.
10:57:45 <Cale> @src IO mplus
10:57:45 <lambdabot> m `mplus` n = m `catch` \_ -> n
10:57:53 <byorgey> ah, I see, nice
10:57:55 <quicksilver> exceptions in IO are a fairly comfortable notion
10:58:04 <quicksilver> and they do look like a monadplus instance of sorts
10:58:21 <quicksilver> catching asychronous exceptions, which occurred in pure code, in IO is a bit more weird :)
10:58:35 <Cale> They're really a MonadOr instance, like Maybe is ;)
10:58:39 <quicksilver> sure.
10:58:45 <quicksilver> but we call that monadplus at the moment.
10:58:46 <quicksilver> :)
10:59:32 <quicksilver> the denotation of an exception in pure code is supposed to be _|_ and catching it is a weird thing to be able to do.
10:59:44 <quicksilver> the denotation of an exception in IO code could be something concrete.
10:59:55 <quicksilver> and it doesn't violate anything if you imagine it is.
11:04:06 <Gilly> hmh, in Data.Time UTCTime isn't an instance of Typeable which makes takusen complain when trying to get it out of it, is this desirable?
11:04:33 <dons> yeah, that's annoying.
11:04:38 <dons> i've hit the missing Typeable elsewhere
11:04:41 <dons> let's add that!
11:04:53 <tensh> could somone point me to an article that explains the "m e | m -> e" stuff in "class Monad m => MonadReader m e | m -> e where"?
11:05:29 <dons> so that's a functional dependency
11:05:36 <dons> probably the best place to look is the ghc users guide
11:05:45 <dons> do you need a link?
11:06:03 <tensh> http://www.haskell.org/ghc/docs/latest/html/users_guide/ ?
11:06:03 <lambdabot> Title: The Glorious Glasgow Haskell Compilation System User's Guide, Version 6.8.2
11:06:12 <dons> yep, in there. look for type system extensions
11:06:33 <tensh> thanks :)
11:06:47 <quicksilver> tensh: it means "for any particular "m", there is only one "e""
11:06:54 <quicksilver> tensh: i.e. "m" determines "e"
11:06:56 <dons> Cale, mark carrol back on haskell, http://reddit.com/info/6boq3/comments/
11:07:16 <Cale> dons: cool
11:07:37 <quicksilver> Cale, dons: catching up on the -cafe I was amused to noticed that "Doubting Haskell" wasn't a troll after all.
11:07:43 <tensh> quicksilver: ok... now I just gotta understand exactly what "m" would be ;)
11:07:44 <dons> quicksilver: :)
11:07:48 <quicksilver> it was so beautifully formed I was almost disappointed :)
11:07:52 <lament> does nobody use shim? If so, how come? It seems to work pretty well so far.
11:07:57 <quicksilver> some people use shim.
11:08:00 <Cale> quicksilver: This is why you always have to assume that it's not a troll :)
11:08:04 <quicksilver> I must admit I haven't tried it yet.
11:08:14 <tensh> but the explanation on that page seems pretty good
11:08:18 <quicksilver> Cale: If I reply, I always reply under that assumption.
11:08:39 <quicksilver> Cale: if I merely gossip on IRC, I permit more irony and hyperbole :P
11:08:51 <Cale> hehe
11:09:03 <quicksilver> lament: /me makes a mental note to try shim soon.
11:09:11 <sebell> Haven't tried it either. Still using haskell-mode and comint
11:09:22 <dolio> That mail is old. Arguing about proper Ord instances is the new hotness.
11:09:38 <Gilly> dons: were you serious or am i missing something? :) I got this bad feeling I am. Could someone explain?
11:10:01 <quicksilver> Gilly: he was serious. Dons is a big fan of improving the libraries.
11:10:06 <quicksilver> Gilly: and he has a commit bit, too :P
11:10:08 <dons> Gilly: I'm serious that the missing Typeable instance is annoying
11:10:10 <lament> quicksilver: it might need some screwing around with cabal file to compile.
11:10:15 <dons> it broke some code at work the other day
11:10:16 <quicksilver> bos: no longer 1337? :(
11:10:20 <Gilly> ok so we could fix it :)
11:10:20 <lament> it's starting to bitrot :(
11:10:22 <dons> so I'll fix it this afternoon
11:10:35 <lament> quicksilver: but don't let that deter you :D
11:10:43 <quicksilver> dons++ # getting things done
11:10:47 <Gilly> i was just thinking that maybe i was missing some reason why we couldn't make utctime an instance of typeable :P
11:11:01 <quicksilver> haskell-comment-syntax-- -- it looks stupid in karma oneliners.
11:11:11 <dons> Gilly: not that I know of.
11:11:43 <Gilly> heh, i don't much know even what 'typeable' means in this context so i really am/was not sure
11:13:17 <quicksilver> it means that GHC carefully builds a run-time representation of the type
11:13:27 <quicksilver> which can be used for Cunning Evil Tricks.
11:13:30 <dons> just sent in a formal proposal to add a few missing Data.Tuple things too, fwiw
11:13:32 <quicksilver> like marshalling/demarshalling.
11:13:36 <dons> fst3,snd3,thd3 and swap
11:13:49 <quicksilver> I dislike foo3
11:13:51 <quicksilver> :)
11:13:55 <faxathisia> aww dons why not call them frst scnd thrd?
11:13:59 <dons> the names are canonical
11:14:02 <quicksilver> I find code that uses them unclear
11:14:13 <quicksilver> but I don't think that's enough reason to argue against them :)
11:14:20 <dolio> How about proj3_n! :)
11:14:21 <faxathisia> it doesn't matter I guess..
11:14:38 <dons> dolio is in the libraries "Generalists" faction
11:14:39 <quicksilver> I still don't have DukeDave's reply to his own message on -cafe.
11:14:41 <quicksilver> that's very odd.
11:14:47 <dons> those who seek always to generalise every submission :)
11:14:53 <dolio> Hehehe.
11:15:33 <quicksilver> in fact, I see adam Langley and Philip Armstrong have replied too
11:15:33 <dons> the other faction being the "Conservationists" who wish to keep base as is, forever immutable
11:15:33 <quicksilver> I don't have those either.
11:15:34 <Gilly> quicksilver: ah ok
11:15:41 <dcoutts_> dons: they are annoying :-)
11:15:42 <quicksilver> I think the mailing lists are running slow :P
11:15:42 <quicksilver> or my email is bork.
11:15:49 <dolio> Actually, I'd vote for type classes 'class ProjN t e | t -> e where projN :: t -> e', except putting functional dependencies in Data.Tuple is probably a no no.
11:16:05 <dcoutts_> dons: but at least it's easy to bypass their objections because they're not about the content of the proposal
11:16:05 <dons> luckily, the Generalists are easily distracted, and the Conservationists have little power
11:16:29 <dcoutts_> heh heh :-)
11:16:30 <dons> btw, Simon Marlow is here today :) and looking for things to hack on.
11:16:33 <dcoutts_> yay
11:16:38 * dons smells concurrent GC in the works!
11:16:48 <dcoutts_> as opposed to parallel?
11:16:59 <dons> oh, parallel, yes.
11:17:12 <dons> concurrent is the too costly one, iirc
11:17:14 <dcoutts_> he was telling us about the preliminary results the other day, sounds good
11:17:17 <dcoutts_> dons: right
11:17:19 <dons> yeah
11:17:31 <dolio> Oh, and what about curry3/uncurry3, or would that go in Data.Function?
11:17:31 <dcoutts_> at least on x86, synchronisation costs are high
11:17:43 <faxathisia> currry/uncurrry
11:17:49 <dolio> Heh.
11:17:50 <dons> dolio: yeah, I'm not sure there. I've never seen them used.
11:17:51 <quicksilver> dons: Adam Langely reports that DukeDave's code runs in vastly reduced memory with Lazy Bytestrings. Why would that be?
11:17:52 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6282
11:18:01 <wieczyk> Hi
11:18:04 <quicksilver> dons: I thought reading in one huge file as one huge strict bytestring would work fairly well?
11:18:05 <dons> quicksilver: hmm. where's this thread?
11:18:09 <wieczyk> could someone help with understanding haskell types (http://hpaste.org/6282) ?
11:18:12 <dolio> Yeah. I suppose they'd be less useful.
11:18:14 <quicksilver> dons: http://www.haskell.org/pipermail/haskell-cafe/2008-March/040438.html
11:18:16 <lambdabot> Title: [Haskell-cafe] Constructing Data.Map from ByteString, http://tinyurl.com/3dgvpv
11:18:42 <dons> hmm, haven't seen that mail yet.
11:18:47 <dons> i wonder if my mail behaving
11:18:54 <quicksilver> dons: I also haven't seen it.
11:19:03 <quicksilver> dons: I think the list server is not behaving.
11:19:07 <dons> hmm
11:19:15 <dons> where's simon marlow. oh,  right here!
11:19:25 <faxathisia> wieczyk: a -> b and x -> y are the same types
11:19:33 <quicksilver> dons: takeWhile and dropWhile don't copy, do they? in strict BS?
11:19:42 <dons> right
11:19:58 <quicksilver> and neither does lines, or break?
11:20:01 <wieczyk> faxathisia: thanks, but why they is changing c=z, and typing a->z instead of a->c ?
11:20:04 <quicksilver> I don't understand, anyhow :)
11:20:10 <dons> right, but lines allocates a bunch of list nodes
11:21:10 <quicksilver> true.
11:21:29 <Jedai> wieczyk: In short, the name of the types variables don't matter at all, and :t don't remember them from one time to the following.
11:21:36 <quicksilver> anyhow, I don't understand why Lazy BS would drop the overhead from 10x to 1.2x
11:21:39 <quicksilver> something is suspicious.
11:21:57 <dons> yeah.
11:21:58 <dcoutts_> quicksilver: I don't see it either
11:22:08 <dons> i'd like to have people testing with the latest bytestring darcs though
11:22:23 <wieczyk> Jedai: ok, that haskell is not rememebring my type "foreach type x" as my char 'x', but is only rememebring 'foreach someone type'
11:22:23 <dons> since that fixed an inlining issue that triggered particular performance issues with Maps
11:23:01 <dcoutts_> quicksilver: if the lines are short then the size of the bytestring descriptors will dominate
11:23:09 <dcoutts_> quicksilver: that's my suspicion
11:23:19 <dcoutts_> but that would not explain the lazy bytestring difference
11:23:34 <Jedai> wieczyk: Also your functions are completely weird, they have strange types (that shows their definitions have issues but you probably only did that to test I suppose)
11:23:39 <dcoutts_> DukeDave: ping
11:24:14 <dcoutts_> it's 40bytes overhead for a ByteString on a 64bit machine
11:24:42 <wieczyk> Jedai: yes, only for tests to have x y z in type names.
11:25:12 <MarcWeber> How does hsql compare to takusen? HaskellDB is nice but you can't create sophisticated queries, right?
11:27:22 <DukeDave> dcoutts_: Here
11:27:37 <dcoutts_> DukeDave: so you're using 32 or 64 bit machine?
11:28:20 <wieczyk> Jedai: if i have my function h, and i want to check if h == f.g, it is ok if i only check types, and told that h is :: x -> y -> z, but f.g is x -> z and because types are different that we dont need check code. ?
11:28:27 <dcoutts_> DukeDave: and your file format it lines with: key \tab value right?
11:28:36 <dcoutts_> DukeDave: and how long are the lines usually?
11:28:43 <dons> DukeDave: i'm looking at it right now too.
11:29:07 <shapr> hi dons!
11:29:07 <dons> DukeDave: what size file is good to test with? 40M? with 2 words, tab separated, per line?
11:29:10 <wieczyk> Jedai: or i should not check types but check only code. (using definition of (.))
11:29:11 * shapr hugs dons
11:29:12 <dons> heya shapr
11:29:24 <shapr> How's code?
11:29:30 <dons> zippy!
11:29:34 <shapr> Yow!
11:29:36 <DukeDave> dcoutts_: 32bit, and yes it's  "key\tvalue\n"
11:29:50 <Jedai> wieczyk: Comparing functions is a dangerous business, the only sane way to do it is observationnal equality, but of course, if they're not of the same type they are different
11:29:51 <kalmar> ?src any
11:29:51 <lambdabot> any p =  or . map p
11:30:12 <dons> DukeDave: is there some threshold where the memory use suddenly kicks in ? also, which ghc version are you using?
11:30:17 <dcoutts_> DukeDave: so you're looking at 64 bytes overhead per line/key-value pair
11:30:38 <dcoutts_> DukeDave: so how does that compare with the average line length?
11:30:51 <Jedai> wieczyk: Anyway 'function' is not a type and you can only compare two values which are of the same type
11:31:15 <dcoutts_> DukeDave: it's 6 words for the Map node and 5 words each for the ByteStrings, so it's (5+5+6) * 4bytes
11:31:25 <Jedai> wieczyk: so comparing h :: x -> y -> z and f.g :: x -> z doesn't have any sense
11:31:34 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6283
11:32:20 <jgerman> noob question incoming.. why doesn't this work?     myAvg :: [Int] -> Int
11:32:20 <jgerman>     myAvg xs = floor (sum xs / length xs)
11:32:25 <DukeDave> dons: I did I bunch of testing last night, I'm just typing up and will drop it on hpaste (5 mins)
11:32:32 <wieczyk> Jedai: hmm ok, one question more. But functions are 'first citizen'. And because -> is right-assoc, that it is never possible to do that -> z from f.g:: is (y->z) from h:: ?
11:32:38 <faxathisia> :t \ xs -> floor (sum xs / length xs)
11:32:39 <lambdabot>     No instance for (RealFrac Int)
11:32:39 <lambdabot>       arising from a use of `floor' at <interactive>:1:8-33
11:32:39 <lambdabot>     Possible fix: add an instance declaration for (RealFrac Int)
11:33:01 <faxathisia> :t \ xs -> floor (sum xs / genericLength xs)
11:33:03 <dcoutts_> DukeDave: with an average line length of 13 you'd observer a 5x memory blowup
11:33:03 <lambdabot> forall a b. (Integral b, RealFrac a) => [a] -> b
11:33:07 <Jedai> jgerman: because length returns an Int, and (/) went a RealFrac (Double or Float mainly)
11:33:12 <hpaste>  dons pasted "testing.." at http://hpaste.org/6284
11:33:32 <faxathisia> :t \ xs -> sum xs `div` length xs
11:33:32 <lambdabot> [Int] -> Int
11:33:39 <dons> DukeDave: can you just look at that ^^ should i be forcing the Map more than the above?
11:33:59 <dons> since I'm seeing memory use proportional to the file size, using 6.8.2 and latest bytestring
11:34:03 <dons> ghc -O2
11:34:44 <Jedai> wieczyk: Yes, in certain case, but the fact that h signatures is more defined shows that "at best" it does a subset of f.G
11:34:51 <dons> break (/= '\t') looks like split '\t'
11:35:13 <DukeDave> dons: On it..
11:35:19 <Jedai> wieczyk: What are you trying to do anyway ?
11:35:56 <dcoutts_> dons: the overhead looks very low there. A 19.8M file and only 23M heap? how long are the lines?
11:35:58 <wieczyk> Jedai: Ok, thanks for information. Well i am learnign a haskell on my univ. And i have easy exercise, but i wanted to know more about haskell general types.
11:35:59 <DukeDave> dcoutts_: Interesting, my line length isn't far off that
11:36:13 <dons> dcoutts_: the dictionary.
11:36:21 <dons> so maybe ~6-8 on average
11:36:34 <dcoutts_> dons: we'd expect a much bigger factor heap use
11:36:38 <dons> but i'm thinking the Map isn't forced...
11:36:42 <dcoutts_> heh
11:36:45 <dcoutts_> try that
11:36:45 <wieczyk> Jedai: because i am fresh in functional programming (only half of year in ocaml programming, and whole life in C/C++) that functional language types are something new for me :)
11:37:00 <dcoutts_> dons: the Map itself is strict, so just seq it or ask for it's size
11:37:03 <tibbe> dons: what's the best way to split a BS on '?' and not keep the separator?
11:37:12 <dons> split ?
11:37:15 <dons> or something like it
11:37:18 <faxathisia> wieczyk: What would you like to know?
11:37:34 <dons> dcoutts_: yeah ...
11:37:39 <dcoutts_> DukeDave: I was just doing 64bytes overhead / 5  because you said you were seeing a 5x memory blowup
11:37:46 <Jedai> wieczyk: You know that the only function that populate x -> z and x -> y -> z are undefined ?
11:37:50 <jgerman> ty for the answers :)
11:37:58 <dons> dcoutts_: so 2x. 150M file, 345M heap
11:38:07 <dons> oh, just jumped to 414M
11:38:11 <dcoutts_> dons, DukeDave: bytestring has very high overhead for small strings
11:38:20 <dcoutts_> dons: especially on 64bit machines
11:38:48 <dcoutts_> dons: for unicode strings I'm not going to use ForeignPtr which will save some
11:38:55 <tibbe> dons: I want a splitOnFirst :: Word8 -> ByteString
11:39:06 <tibbe> -> (ByteString, ByteString)
11:39:10 <dons> :t head . Data.ByteString.split '?'
11:39:11 <tibbe> Maybe
11:39:11 <lambdabot>     Couldn't match expected type `Word8' against inferred type `Char'
11:39:11 <lambdabot>     In the first argument of `BS.split', namely '?'
11:39:11 <lambdabot>     In the second argument of `(.)', namely `BS.split '?''
11:39:17 <dons> :t head . Data.ByteString.Char8.split '?'
11:39:18 <lambdabot> BSC.ByteString -> BSC.ByteString
11:39:34 <dcoutts_> dons: but even so, we have a header word, a pointer to a byte array and two ints
11:39:51 <hpaste>  dons annotated "testing.." with "force the map" at http://hpaste.org/6284#a1
11:39:52 <tibbe> dons: I want the head and tail but I must check the length of the list, it's not that I can't do it, it's just annoying
11:40:44 <dons> dcoutts_: oh, but we do see better use with lazy bytestring...
11:40:49 <dcoutts_> dons: for a lazy bytestring we could make it the same size as a strict one if we could pack two half size ints into the space for one
11:40:58 <dons> hmm, i bet its a strictness issue
11:41:26 <dons> since the lazy bytestring is showing 128M use for a 150M string. the elems not forced?
11:42:10 <dcoutts_> dons: I don't understand that, the Map should force everything
11:42:18 <dcoutts_> it's strict in the keys
11:42:48 <dons> yeah, not the elems though. hmm
11:42:50 <dcoutts_> it's possible the elems are not being forced
11:42:52 <dcoutts_> right
11:43:04 <dcoutts_> but I'd not expect the thunk to be much smaller than the evaluated data
11:43:53 <dcoutts_> anyway the whole string has to be in memory so getting less than the size of the file sounds like it ought to be impossible
11:44:36 <dons> even if i walk the elems, its stays at 128M. mega weird
11:44:44 <shapr> Any idea why ghci ignores spaces on win32? I'm trying to use ghci from inside xemacs
11:44:46 <dons> is that 150M-cost of tabs/newline
11:45:02 <DukeDave> dons: Right I'm on the same page as you now, your annotation, forcing the Map produces my previous results..
11:45:14 <shapr> I get - :load "c:\Documents and Settings\serisson\Translation.hs"  \n can't find file: c:Documents and SettingsserissonTranslation.hs
11:45:20 <dons> DukeDave: right. and do you get good numbers using lazy ByteStrings?
11:45:47 <shapr> DukeDave: Hey, do you work at last.fm?
11:45:57 * shapr likes last.fm
11:46:14 <dcoutts_> dons: it may be interesting to add a more limited unicode string type for small strings that do not provide iteration facilities (ie no substring) but are memory efficient and have fast Eq/Ord, useful for tokens in maps
11:46:30 <dons> dcoutts_: yeah. agreed.
11:46:34 <dons> not pinned
11:46:54 <dcoutts_> that too, but I was planning to make the general unicode strings unpinned too
11:47:07 <dons> DukeDave: what numbers do you need to see here?
11:47:26 <dcoutts_> it'd just be a newtype wrapped bytearray so only 2 words overhead
11:47:41 <tomd123> does anyone know if there will be a mentor available for this project? http://hackage.haskell.org/trac/summer-of-code/ticket/71
11:47:42 <lambdabot> Title: #71 (NES emulator) - Haskell.org Google Summer of Code - Trac
11:47:45 <DukeDave> dons: No, in disagreement with this cafe mailing: http://www.haskell.org/pipermail/haskell-cafe/2008-March/040438.html
11:47:47 <lambdabot> Title: [Haskell-cafe] Constructing Data.Map from ByteString, http://tinyurl.com/3dgvpv
11:47:54 <DukeDave> I see hardly any change
11:47:59 <DukeDave> shapr: Sure do :)
11:48:52 <shapr> DukeDave: Does last.fm use Haskell any?
11:48:55 <dons> DukeDave: so what kind of numbers do you need?
11:49:03 <dons> are the current results unacceptable?
11:49:42 <lament> how would i go about running an action every N milliseconds? Is it better to have the main loop in C and run a haskell callback in a separate thread?
11:49:42 <DukeDave> dons: Well I have a 600MB file containing the k/v pairs, I'd like to be able to keep the whole Map in memory while I parse another (considerably larger) file
11:49:42 <dcoutts_> DukeDave: so these keys are all general strings, not integers or something? I think given the bytestring overhead for small strings it's just not an appropriate representation for your map
11:49:49 <DukeDave> shapr: They do since I joined a few weeks ago ;)
11:49:54 <shapr> Awesome!
11:50:18 <DukeDave> Hence why I really want to make this work in Haskell
11:50:46 <DukeDave> dcoutts_: The keys are acually Data.Word s
11:50:47 <dcoutts_> lament: just forkIO a thread and have it wait for a while run the action and wait again
11:50:53 <dcoutts_> DukeDave: ahh
11:51:08 <dcoutts_> DukeDave: so have you considered parsing the keys and using an IntMap?
11:51:31 <dcoutts_> DukeDave: should give lower memory overhead for the keys and faster lookups
11:51:42 <dons> oh, IntMap should help here.
11:51:53 <dons> and copying elems from the lazy bytestring
11:51:59 <DukeDave> Aha, I'd never heard of IntMap
11:52:02 <dons> so we have minimal memory pinned
11:52:10 <dcoutts_> DukeDave: Int and Word are always the same size so you can convert without loss of information
11:52:40 <DukeDave> My rational was that by loading the whole text file in to memory, the map would just operate pass by reference?
11:52:42 <lament> dcoutts_: how do i wait?
11:52:43 <dons> DukeDave: so a 600M \t separated word file needs to fit in memory in a map, basically
11:52:47 <wieczyk> Jedai: yes.
11:52:55 <DukeDave> dons: That's the challenge
11:52:58 <dons> and we can hash the keys?
11:53:24 <wieczyk> faxathisia: well, is hard to ask. It coould be nice, if you will tell me about some good paper where i can read about this 'type calculus'
11:53:29 <kalmar> if they're Data.Word, why not IntMap
11:53:34 <kalmar> ?
11:53:36 <dcoutts_> DukeDave: your rational made sense, there is no copying of the data going on, just the information to track all the short substrings starts to dominate
11:53:46 <dons> ah, the keys are integer strings, currently?
11:53:54 <lament> dcoutts_: i hoogled i swear :)
11:53:56 <DukeDave> We can, although I tried using a HashTable with HashInt and still had dire performance
11:54:14 <dons> HashTable's not much fun. it rarely beats IntMap
11:54:30 <dcoutts_> lament: see Control.Concurrent threadDelay and friends
11:54:32 <dons> DukeDave: so in the file, the keys are integer strings?
11:55:28 <kalmar> oh dcoutts_ already suggested IntMap, woops
11:55:34 <lament> dcoutts_: thanks!
11:56:11 <dcoutts_> DukeDave: so with an IntMap we'd get 3 or 5 words overhead for each IntMap node and 5 words overhead for the ByteString value
11:56:22 <DukeDave> dons: Yes they are, but they can go to unsigned int size
11:56:27 <dons> ok.
11:56:56 <dcoutts_> DukeDave: so that brings it down from 64bytes per k/v pair to 36bytes
11:57:47 <dcoutts_> DukeDave: so that'd still be a 2-3x memory blowup
11:57:51 <DukeDave> And for the value we're saying use lazy ByteStrings and copy
11:57:58 <dcoutts_> if the lines are ~13 chars long
11:58:06 <dcoutts_> DukeDave: do not copy
11:58:20 <dcoutts_> DukeDave: then you do not get any of the sharing benefits
11:58:35 <dcoutts_> and you have to allocate separate pinned byte arrays for every value, it'd be terrible
11:59:04 <DukeDave> Roger that
11:59:18 <dcoutts_> the overhead for unshared bytestrings is much worse than for shared ones
11:59:45 <dcoutts_> DukeDave: here's another possibility...
11:59:50 <DukeDave> ... Listening
11:59:53 <dcoutts_> DukeDave: it's a little harder but not too bad
12:00:27 <dcoutts_> DukeDave: use an IntMap to offset/lengths into the single strict ByteString
12:00:41 <DukeDave> dcoutts_: Now we're talking :)
12:01:00 <dcoutts_> DukeDave: the question is how to store the offset + length pairs
12:01:09 <DukeDave> Can I then hold the whole file in memory I just grab what I need
12:01:11 <DukeDave> ?
12:01:31 <dcoutts_> DukeDave: right
12:02:30 <dcoutts_> DukeDave: I mean that's also what's happening with your current ByteString substring solution but the administrative overhead for remembering all the substrings is rather high
12:02:53 <dcoutts_> and we can take advantage of the fact that they're all substrings into the same big ByteString
12:03:10 <dcoutts_> the main question is how to encode the length + offset pair
12:03:37 <dcoutts_> it's not impossible to encode it into a single Word
12:03:44 <dcoutts_> using a bit of bitshifting
12:04:03 <DukeDave> Can I not have IntMap (Word, Word) ?
12:04:10 <dcoutts_> you can
12:04:13 <dons> oh, the second field is also Word?
12:04:17 <dons> now we're getting interesting..
12:04:27 <DukeDave> No, value field is string
12:04:37 <dcoutts_> DukeDave: but that costs 3 words for the (,) and 2 each for each Word
12:04:58 <dcoutts_> so that's 7 which is worse than the ByteSting which was 5 remember
12:05:04 <kalmar> (# Int, Int #)?
12:05:10 <kalmar> can you store those in a map?
12:05:15 <dcoutts_> kalmar: nice but cannot be stored in a Map
12:05:22 <dcoutts_> because it does not have kind *
12:05:36 <DukeDave> Ack, I have to go guys :|
12:05:36 <kalmar> data Pair = P !Int !Int with -funbox-strict-fields?
12:05:55 <dejones> DukeDave: Are you Dave Tapley from the haskell-cafe mailing list?
12:06:03 <DukeDave> dejones: I am
12:06:19 <DukeDave> I should co-sign with DukeDave really
12:06:20 <dons> DukeDave: i'll see if I can get the IntMap going
12:06:22 <dejones> DukeDave: Ahh.. I was trying to make sure I was understanding the context of this discussion.  :)
12:06:37 <DukeDave> Good times :)
12:06:52 <kalmar> dcoutts_: my second suggestion would still have overhead from the P node, right?
12:07:00 <DukeDave> dons: Sounds excellent, I'll get on it as soon as I get back from this 'work obligation'
12:07:08 * DukeDave is glad for #haskell logs
12:07:12 <kalmar> would it be any better than (Int, Int)?
12:07:28 <Cale> You could, however, box the unboxed pair, and then store that in a Map
12:07:33 <dcoutts_> DukeDave: kalmar yes
12:07:35 <dcoutts_> oope
12:07:36 <Cheery> how long the lambdabot keeps it's bindings?
12:07:39 <Cheery> > duh
12:07:39 <lambdabot>   Not in scope: `duh'
12:07:42 <dcoutts_> kalmar: yes that's 3 words
12:07:52 <Cheery> > yell "foobar"
12:07:52 <lambdabot>   Not in scope: `yell'
12:07:54 <ziman> > yell "more"
12:07:54 <lambdabot>   Not in scope: `yell'
12:07:58 <Cheery> :/
12:08:09 <Cheery> not infinitely long I see.
12:08:35 <notsmack> Cheery: i think they're manually reset every once in a while
12:08:44 <dcoutts_> DukeDave: as kalmar suggests, use: data SubStr = SubStr {-# UNPACK #-} !Int {-# UNPACK #-} !Int
12:08:48 <kalmar> dcoutts_: I see where you're going with bitshifting, if there is a known limit on length of substrings
12:08:52 <dons> lunch
12:09:36 <Cale> Er... maybe you couldn't.
12:10:09 <Cale> It seems that you can't include unboxed pairs as arguments to data constructors, because they're required to have function types.
12:10:19 <Cale> @kind (->)
12:10:20 <lambdabot> ?? -> ? -> *
12:10:21 <dcoutts_> DukeDave: it has only 3 words overhead, so that's 12 bytes, so combined with the other 16 from the IntMap node you get 28 bytes overhead per line, which is about 2x the line length so that's 3x the filesize overall.
12:11:13 <dejones> dcoutts_: what does the ! mean in the "!Int" above?
12:11:21 <dcoutts_> dejones: strict field
12:11:21 <Cale> dejones: Strict.
12:11:34 <kalmar> dejones: that the field is strict
12:11:36 <dcoutts_> dejones: SubStr _|_ a = _|_
12:11:57 <dejones> lol
12:12:08 <Cale> It means that when the application of the constructor to its argument is evaluated, the argument will be evaluated up to determining its own top-level constructor.
12:13:02 <lament> what's a good name for an object that wraps an (x,y) pair array as if it were a continuous function?
12:13:31 <Zao> lament: interpol
12:13:35 <dejones> Cale: why is the "strict" useful?
12:14:04 <lament> Interpol :D
12:14:41 <dejones> dcoutts_: Sorry, I'm a Haskell noob.  I have no idea what SubStr _|_ a = _|_ --- I thought _ was the bottom? or catch-all?
12:14:43 <Cale> dejones: Well, if the fields are small once evaluated, like, say, Integers are, it prevents the constructor from hanging on to large expressions.
12:15:00 <Cale> _|_ is ascii art for the symbol for bottom.
12:15:08 <dejones> lol
12:15:25 <Cale> (which looks like an upside-down stylised T)
12:15:27 <dcoutts_> dons: it seems to me that it's not impossible to have a heap representation where some heap objects omit a header word if they only ever appear in a monomorphic strict field inside another constructor, like Map nodes.
12:15:53 <kalmar> dejones: where bottom is a value that diverges... an infinite loop
12:16:11 <kalmar> (my terminology may be off)
12:16:49 <Cale> The notation comes from order theory or lattice theory, where you have a top and bottom element. The ordering in question here is the ordering of definedness.
12:16:52 <dolio> ‚ä•
12:17:02 <dolio> ‚ä§
12:17:03 <Cale> dolio's found the unicode :)
12:17:18 <dejones> Cale: So, with strict, we are attempting to enforce that the expression is using the simplest constructor?
12:17:23 <gnuvince> You see unicode characters?
12:17:33 <dejones> dolio: n1.  :)
12:17:33 * gnuvince sees backslash u22a4
12:17:40 <dcoutts_> gnuvince: set your client to use utf8
12:17:47 <Cale> dejones: Well, normally, when you apply a constructor to some parameters, those parameters are not evaluted.
12:17:54 <gnuvince> dcoutts_: I would, but I can, because my OS doesn't support utf8
12:18:00 <dejones> Cale: Oh.. the laziness?
12:18:12 <Cale> dejones: yeah
12:18:34 <Cale> dejones: For instance, if I write  factorial 1000 : factorial 2000 : []
12:19:04 <dejones> Cale: then is the strict kinda like "coercion" in other languages?  Making sure that the parameters are actually constructed at evaluation?
12:19:07 <Cale> and, say I use a case expression to pattern match on that:
12:19:18 <Cale> case factorial 1000 : factorial 2000 : [] of
12:19:20 <Cale>   [] -> ...
12:19:28 <Cale>   (x:xs) -> ...
12:19:47 <Cale> maybe I just return 0 in either case :)
12:19:58 <Cale> factorial 1000 won't get evaluated
12:20:18 <dolio> > product [1..1000]
12:20:19 <lambdabot>  4023872600770937735437024339230039857193748642107146325437999104299385123986...
12:20:41 <Cale> What'll happen is that a cons will be constructed with pointers to effectively the expressions (factorial 1000) and (factorial 2000 : [])
12:21:06 <MyCatVerbs> @hoogle Parser a -> Parser (Maybe a)
12:21:06 <lambdabot> No matches, try a more general search
12:21:40 <dolio> @hoogle f a -> f (Maybe a)
12:21:40 <lambdabot> Prelude.id :: a -> a
12:21:40 <lambdabot> Data.Function.id :: a -> a
12:21:40 <lambdabot> GHC.Exts.breakpoint :: a -> a
12:22:00 <dolio> @type optional
12:22:01 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f (Maybe a)
12:22:19 <dejones> Cale: then the case will return 0, so no need to evaluate factorial 1000?
12:22:23 <Cale> right
12:22:35 <wieczyk> liesen:
12:22:38 <Cale> Only if x is later pattern matched against will the factorial 1000 be evaluated.
12:22:40 <wieczyk> aaah sorry ;p
12:22:53 <dejones> Cale: but, how would "strict" help with that?
12:23:06 <dejones> Cale: it is forcing the evaluation of the parameters?
12:23:07 <Cale> dejones: It isn't so much helpful in this case
12:23:21 <Cale> But if, say, we used a strict list type:
12:23:39 <Cale> data SList a = SNil | SCons !a !(List a)
12:23:43 <Cale> er
12:23:45 <MyCatVerbs> Ahhhh, \f -> option Nothing (Just <$> f) -- did it ^_^
12:23:45 <Cale> data SList a = SNil | SCons !a !(SList a)
12:24:08 <dejones> ok
12:24:34 <Cale> Then SCons (factorial 1000) (SCons (factorial 2000) SNil) when pattern matched against, would evaluate both factorial 1000 and factorial 2000
12:25:20 <Cale> In this case, we expect the value of factorial 1000 to take much more memory than the expression factorial 1000, so it wouldn't be helpful.
12:26:00 <dejones> Right.
12:26:09 <Gilly> When I use Network module to create a server-client system, how do I perform a non-blocking accept?
12:26:26 <Cale> But in many cases, expressions are larger than the result of evaluating them, in which case, making things strict can help reduce memory consumption.
12:26:33 <dolio> It's useful in the SubStr !Int !Int case because you can store the Ints directly in the memory allocated for SubStr, instead of storing pointers to heap allocated Ints.
12:26:44 <Cale> Well, that's a GHC-ism :)
12:26:46 <Cale> but yeah
12:26:51 <dolio> Hence the {-# UNPACK #-} pragmas.
12:27:28 <Gilly> I tried to convert it into a handle using Network.Socket's socketToHandle but then realized that the socket is unusable after that so I can't accept anyways after I read the positive status using hReady from System.IO :P
12:27:53 <Cale> If you have strict-field unpacking turned on, because the semantics are such that the Ints are always evaluated when the constructor is built, the constructor might as well include the Ints directly in its structure, rather than holding pointers to them.
12:27:54 <dejones> Interesting stuff.  Thanks Cale and dolio.
12:28:15 <Cale> (because they'll never be expressions, only values)
12:28:19 <MyCatVerbs> This reminds me. Is it impossible to have strict fields when you're using record syntax?
12:28:27 <Cale> No, it's still possible
12:28:45 <Cale> The syntax is the same, just stick a ! before the type.
12:29:02 <dolio> data Foo = { field1 :: !Bar, field2 :: !Baz }
12:29:22 <Cale> Forgot the data constructor
12:29:28 <dolio> Oh, right.
12:29:53 <dolio> Perhaps I am subconsciously longing for first-class extensible records.
12:31:43 <dolio> Not sure where you'd UNPACK there. Between the :: and the !, I guess?
12:32:37 <dcoutts_> dolio: yep
12:36:36 <smg> whyc can't all irc channels be like haskell :|
12:37:05 <macondo> I've always said the Haskell community is great
12:37:10 <dejones> smg: seriously.  this channel is immensely useful + helpful.
12:37:42 <smg> indeed, and people are smart and friendly
12:37:55 <MyCatVerbs> @pl \f g -> f >>= \x -> g >>= \y -> return (x,y)
12:37:56 <lambdabot> liftM2 (,)
12:38:03 * MyCatVerbs facepalms, again.
12:38:56 <dejones> I really enjoy watching Simon Peyton-Jones talks.  :)
12:39:15 <dejones> His knowledge is -immense-
12:39:21 <dolio> He's always very upbeat.
12:39:35 <dejones> Yeah, definitely.
12:41:34 <dolio> @quote simonpj
12:41:35 <lambdabot> simonpj says: Maybe if I had an Oleg implant I could express all this in the type system
12:41:57 <dejones> lol
12:42:05 <dejones> dolio: was Simon actually in this channel?
12:42:22 <dolio> I don't think so.
12:42:33 <dolio> Stuff by him is pulled from the mailing list or videos.
12:42:34 <gbacon> @help remember
12:42:34 <lambdabot> quote <nick>
12:42:34 <lambdabot> remember <nick> <quote>
12:42:34 <lambdabot> Quote somebody, a random person, or save a memorable quote
12:42:40 <smg> excuse who is simonpj?
12:42:53 <dejones> smg: Simon Peyton-Jones.
12:43:19 <smg> ah, that microsoft guy
12:43:58 <Botje> @quote
12:43:58 <lambdabot> wilx says: I mean, besides the murders, it all looks so nice.
12:43:59 <dejones> Yeah, One of the Haskell designers and GHC developer.  ;)
12:44:19 <Cale> smg: He is *the* Haskell guy.
12:44:47 <dolio> There's the other Simon, but he's less high profile.
12:45:46 <dejones> dolio: Simon Marlow, I believe.
12:45:54 <dolio> Yeah.
12:45:58 * tibbe will attend Hac4, woho!
12:46:08 <dejones> It's quite interesting that functional programming has been around so long and it is coming full-circle back to functional programming...
12:46:29 <Cale> dejones: Sorry? :)
12:46:49 <dolio> He's not an Original Haskell Guy like SPJ, though, I guess.
12:46:59 <dolio> At least, his name isn't on the 1.0 report.
12:47:09 <dejones> Cale: Lisp so long ago was popular... then C/C++ and Java these days... now Haskell, F#, etc. are becoming popular again to attempt to solve concurrency issues.
12:47:24 <Cale> ah
12:47:25 <mrd> Lisp wasn't FP
12:47:30 <dejones> Just interesting that it is coming full-circle.
12:47:43 <dejones> mrd: well, not purely functional, right?
12:47:44 <dejones> ;)
12:48:01 <Cale> Lisp was sort of FP, for its time.
12:48:11 <dolio> Scheme was probably closer.
12:48:16 <dejones> True.
12:48:18 <Cale> Yeah, Scheme is closer.
12:48:20 <mrd> I would trace the interest in functional "programming" to the 70s
12:48:27 <opqdonut> yeah but scheme is so much younger
12:49:27 <mrd> still over 30 years old
12:49:48 <dolio> Man, there's a guy with just one name on the 1.0 report. :)
12:50:38 <mrd> old LISP 1.5 code is incredibly imperative, if you look at it, not to mention the "lambdas" weren't properly implement
12:50:41 <Cale> hehe, "Arvind"
12:50:44 <phlpp> @src isPrime
12:50:44 <lambdabot> Source not found. My brain just exploded
12:51:18 <phlpp> @ho isPrime
12:51:18 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
12:51:25 <phlpp> @hoogle isPrime
12:51:25 <lambdabot> No matches found
12:51:26 <phlpp> :>
12:51:29 <phlpp> hm, okay
12:55:17 <dolio> phlpp: There was a page a while back with a bunch of stuff like that written in Haskell, but I don't seem to have a link to it anymore.
12:56:22 <phlpp> dolio: i just thought there was sth. in prelude ;)
12:56:25 <oerjan> isPrime is rather complicated, especially if you want it to work for big numbers (might require random number generation for efficiency...)
12:56:30 <dolio> Oh, found it.
12:56:41 <dolio> http://www.polyomino.f2s.com/david/haskell/numbertheory.html
12:56:42 <lambdabot> Title: Basic Number Theory in Haskell
12:57:45 <phlpp> okay, thanks
12:58:53 <mrd> i once implemented miller-rabin in haskell, but for smaller numbers a prime sieve is faster
12:59:50 <byorgey> anyone have any idea what might cause an 'arithmetic overflow' error?
13:00:01 <byorgey> I'm not necessarily sure it's coming from Haskell, but...
13:00:45 <byorgey> xmonad crashes and all I know is that it says 'arithmetic overflow' at the end of ~/.xsession-errors
13:00:50 <dolio> His 'isPrime' actually uses trial division for n < 500 million, and Miller-Rabin for numbers larger than that.
13:01:30 <Cale> Prelude> :m + Control.Exception
13:01:30 <Cale> Prelude Control.Exception> throw (ArithException Overflow)
13:01:30 <Cale> *** Exception: arithmetic overflow
13:02:06 <nominolo> @seen kolmodin
13:02:06 <lambdabot> kolmodin is in #gentoo-haskell, #haskell, #ghc and #darcs. I last heard kolmodin speak 1h 33m 14s ago.
13:02:11 <byorgey> Cale: ok, but what might actually cause that exception to be thrown?
13:02:30 <Cale> I'm not sure.
13:02:44 <mrd> > 1000000000000 + 1000000000000000000000 :: Int
13:02:44 <lambdabot>  -1287319552
13:02:58 <Cale> (NOTE: GHC currently does not throw ArithExceptions except for DivideByZero).
13:03:14 <byorgey> Cale: right, that's what I thought
13:03:15 <Cale> (from the documentation)
13:03:28 <nominolo> > 42 / 0 `catch` show
13:03:29 <lambdabot>  Couldn't match expected type `IO a' against inferred type `String'
13:03:41 <nominolo> > show (42 / 0) `catch` show
13:03:41 <lambdabot>  Couldn't match expected type `IO a' against inferred type `String'
13:03:44 <byorgey> and at any rate, it doesn't say '*** Exception: arithmetic overflow', just 'arithmetic overflow'
13:04:04 <Cale> Prelude Control.Exception> print (ArithException Overflow)
13:04:04 <Cale> arithmetic overflow
13:04:07 <Cale> like that?
13:04:35 <Cale> Does xmonad run from inside GHCi?
13:04:46 <Cale> You might be able to use the GHCi debugger to track it down.
13:05:25 <Cale> er, hmm
13:05:34 <Cale> Maybe not if it's not actually throwing the exception.
13:05:50 <byorgey> Cale: I can't figure out how to run it from within GHCi, since it wants to open an X display.
13:06:01 <byorgey> it just quits and says something like userError (open display)
13:06:02 <Cale> export DISPLAY=:0
13:06:20 <Cale> (at least, that's usually the name of the display)
13:06:21 <byorgey> seems like I've tried that before, but I'll try again
13:06:41 <byorgey> hm, maybe I have to stop gdm first
13:07:01 <byorgey> Cale: do I have to compile it with special flags to use the debugger? I forget
13:07:03 <Cale> I don't actually know xmonad all that well. I tried it for a couple of hours and then decided that tiling wasn't for me :)
13:07:14 <Cale> nope
13:07:25 <pastorn> what's the name of the compiler devoted to generating fast/small code?
13:07:27 <byorgey> Cale: heh, that's fine.  I don't think this error has too much to do with xmonad per se. =)
13:07:28 <Cale> :set -fbreak-on-exception
13:07:34 <mrd> pastorn: jhc?
13:07:37 <byorgey> ah, cool
13:07:41 <pastorn> mrd: thanks
13:07:49 <pastorn> @where jhc
13:07:49 <lambdabot> http://repetae.net/john/computer/jhc/
13:08:19 <Cale> Heh, GHC doesn't do such a bad job either.
13:08:31 <mrd> not on the "small" front
13:09:08 <Cale> Well, it's not horrible in that regard. Its biggest infelicity is the large constant term in code size caused by not splitting out the runtime system.
13:09:38 <pastorn> Cale: what do you mean by "runtime system"?
13:09:47 <Maddas> I thought mrd was reenforcing your statement that it didn't do such a bad job on the "small" front...
13:10:27 <mrd> pastorn: GC, threads, and the basic apparatus which supports your compiled haskell code
13:10:50 <pastorn> GC being short for...?
13:10:54 <Cale> Maddas: hehe, I read it as (not "doesn't do a bad job") == "does a bad job"
13:10:54 * mrd blinks
13:10:57 <mrd> garbage collection
13:11:01 <pastorn> oh
13:11:35 <quicksilver> DukeDave: reading scrollback I'm glad to see your problem got some interesting analysis :)
13:27:10 <wli> Mgccl: How about 251 = 6^3 + 3^3 + 2^3 = 5^3 + 5^3 + 1^3?
13:27:39 <tromp> l
13:30:25 <Baughn> > sum $ map (^3) [6,3,2,5,5,1]
13:30:25 <lambdabot>  502
13:30:45 <Baughn> > sum $ map (^3) [6,3,2]
13:30:45 <lambdabot>  251
13:30:50 <Baughn> > sum $ map (^3) [5,5,1]
13:30:51 <lambdabot>  251
13:31:01 <wli> Baughn: The smallest number representible as a sum of three cubes two different ways. Actually meant for #math.
13:32:02 <dolio> @remember ndm As always, the most useful thing in the error message is the line number.
13:32:02 <lambdabot> Done.
13:32:14 <wli> > Data.Map.toAscList . head . dropWhile (Data.Map.null) . (Data.List.map) (Data.Map.filter (\xs -> case xs of _ : _ : _ -> True ; _ -> False)) $ scanl (flip (\x@(i, j, k) -> let p :: Int = 3 ; n = i^p + j^p + k^p in Data.Map.insertWith (++) n [x])) Data.Map.empty [(i, j, k) | n <- [(3 :: Integer) ..], i <- [1 .. n - 2], j <- [1 .. i], let k = n - i - j, i + j + k == n, i >= j, j >= k, i >= 1, j >= 1, k >= 1]
13:32:14 <lambdabot>  Parse error at "=" (column 186)
13:32:25 <tromp> maybe quickcheck can find such a number
13:32:39 <nominolo> or sparsecheck
13:32:57 <wli> > Data.Map.toAscList . head . dropWhile (Data.Map.null) . (Data.List.map) (Data.Map.filter (\xs -> case xs of _ : _ : _ -> True ; _ -> False)) $ scanl (flip (\x@(i, j, k) -> let p = 3 :: Int ; n = i^p + j^p + k^p in Data.Map.insertWith (++) n [x])) Data.Map.empty [(i, j, k) | n <- [(3 :: Integer) ..], i <- [1 .. n - 2], j <- [1 .. i], let k = n - i - j, i + j + k == n, i >= j, j >= k, i >= 1, j >= 1, k >= 1]
13:32:58 <lambdabot>   Not in scope: `Data.Map.empty'
13:33:02 <Cale> Here's a fun question: Is 6 the difference of two perfect powers?
13:33:20 <wli> Cale: Define perfect power.
13:33:27 <tromp> 6 = 6^1-0^1
13:33:35 <Cale> n^m with n and m integers, and m >= 2
13:34:32 <wli> Cale: No problem. Generate (h, i, j, k) quadruplets fairly, then filter for h^i == j^k + 6
13:34:56 <dmwit> That algorithm only terminates if there's a solution.
13:35:09 <dmwit> You can never (correctly) answer no that way, even if "no" is the right answer.
13:35:43 <oerjan> well n cannot be 2 or 3, i figure
13:35:50 <tromp> no, Cale
13:36:24 <dmwit> tromp: They could have different values for "m"... do you have a proof of "no"?
13:37:05 <tromp> oh, i overlooked different m:(
13:37:21 <oerjan> Cale: is the answer known?
13:37:28 <Cale> oerjan: I don't think so.
13:37:44 <dmwit> Cale: That's evil.
13:37:48 <wli> dmwit: Sorry, I thought it was to construct it.
13:42:09 <oerjan> > Data.Set.fromList [m1^n1 - m2^n2 | m1 <- [2..100], m2 <- [2..100], n1 <- [2..6], n2 <- [2..6]]
13:42:09 <lambdabot>   Not in scope: `Data.Set.fromList'
13:42:23 <oerjan> @hoogle fromList
13:42:23 <lambdabot> Data.HashTable.fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
13:42:23 <lambdabot> Data.Set.fromList :: Ord a => [a] -> Set a
13:42:23 <lambdabot> Data.Sequence.fromList :: [a] -> Seq a
13:42:28 <Cale> > S.fromList [m1^n1 - m2^n2 | m1 <- [2..100], m2 <- [2..100], n1 <- [2..6], n2 <- [2..6]]
13:42:30 <lambdabot>  fromList [-999999999996,-999999999992,-999999999991,-999999999984,-999999999...
13:42:30 <oerjan> o_O
13:42:40 <oerjan> oops
13:42:43 <Cale> > 6 `S.member` S.fromList [m1^n1 - m2^n2 | m1 <- [2..100], m2 <- [2..100], n1 <- [2..6], n2 <- [2..6]]
13:42:44 <lambdabot>  False
13:42:58 <tromp> hmm, how best to define ordered list of perfect powers?
13:43:02 <oerjan> > Data.Set.fromList [abs(m1^n1 - m2^n2) | m1 <- [2..100], m2 <- [2..100], n1 <- [2..6], n2 <- [2..6]]
13:43:03 <lambdabot>   Not in scope: `Data.Set.fromList'
13:43:09 <oerjan> > S.fromList [abs(m1^n1 - m2^n2) | m1 <- [2..100], m2 <- [2..100], n1 <- [2..6], n2 <- [2..6]]
13:43:10 <lambdabot>  fromList [0,1,2,4,5,7,8,9,11,12,13,15,16,17,18,19,20,21,22,23,24,25,27,28,29...
13:43:15 <dmwit> tromp: With a bit of diagonalization, I suppose.
13:43:30 <oerjan> conspicuous absense there...
13:43:36 <dmwit> Yeah, 3.
13:43:41 <dmwit> 3 = 2^2 - 1^2.
13:44:02 <Cale> > S.fromList [abs(m1^n1 - m2^n2) | m1 <- [1..100], m2 <- [1..100], n1 <- [2..6], n2 <- [2..6]]
13:44:03 <lambdabot>  fromList [0,1,2,3,4,5,7,8,9,11,12,13,15,16,17,18,19,20,21,22,23,24,25,26,27,...
13:44:14 <tromp> 2 = 1^3 - (-1)^3
13:44:48 <wli> > let f n = head [(h, i, j, k) | s <- [(6 :: Int) .. ], h <- [1 .. s - 5], i <- [2 .. s - h], j <- [1 .. s - h - i], k <- [2 .. s - h - i - j], h^i == j^k + n] in f 7
13:44:48 <lambdabot>  (2,3,1,2)
13:44:49 <oerjan> m^2-n^2 will give a lot
13:44:53 <dmwit> 2 = 3^2 - 2^3 -- pretty!
13:45:03 <Heffalump> and untrue..
13:45:10 <dmwit> oerjan: Yeah, at the very least all the odd integers are generated that way.
13:45:11 <pastorn> i need a function :: URL -> IO String
13:45:31 <dmwit> Heffalump: Oy, that's a typo for 1 = ...
13:45:48 <Cale> dmwit: What about 29?
13:45:57 <dmwit> Cale: What about it?
13:46:02 <wli> > let f n = head [(h, i, j, k) | s <- [(6 :: Int) .. ], h <- [1 .. s - 5], i <- [2 .. s - h], j <- [1 .. s - h - i], k <- [2 .. s - h - i - j], h^i == j^k + n] in f 29
13:46:02 <lambdabot>  (15,2,14,2)
13:46:14 <dmwit> Cale: Try finding (n+1)^2 - n^2.
13:46:14 <Cale> er...
13:46:17 <Heffalump> > 15^2 - 14^2
13:46:18 <lambdabot>  29
13:46:18 <Cale> right
13:46:23 <tromp> > 3^2 - 2^3
13:46:23 <lambdabot>  1
13:46:34 <Cale> Of course :)
13:47:15 <tromp> is there an log function from Integer to Int?
13:47:32 <oerjan> > S.fromList [abs(m1^n1 - m2^n2) | m1 <- [2..100], m2 <- [2..100], n1 <- [2], n2 <- [2]]
13:47:33 <lambdabot>  fromList [0,5,7,9,11,12,13,15,16,17,19,20,21,23,24,25,27,28,29,31,32,33,35,3...
13:47:34 <xerox> Discrete log is a great problem :-)
13:47:45 <oerjan> oops
13:47:48 <dmwit> :t floor . log . fromIntegral
13:47:49 <lambdabot> forall b a. (Integral a, Integral b) => a -> b
13:47:54 <oerjan> > S.fromList [abs(m1^n1 - m2^n2) | m1 <- [1..100], m2 <- [1..100], n1 <- [2], n2 <- [2]]
13:47:55 <lambdabot>  fromList [0,3,5,7,8,9,11,12,13,15,16,17,19,20,21,23,24,25,27,28,29,31,32,33,...
13:48:11 * Cale was confusing things with consecutive perfect powers for a bit :)
13:48:46 <MyCatVerbs> Gah.
13:48:47 <xerox> tromp: and that one is the only solution to x^p - y^q = 1 with p,q primes and x,y integers! (result from 2007)
13:49:15 <MyCatVerbs> Is there any way of having parsec parsers drop useless spaces without having to shove "spaces" combinators in all over the place?
13:49:40 <dmwit> MyCatVerbs: Ugh, my number one desire, too.
13:49:42 <opqdonut> xerox: wow, it's proved?
13:49:49 <xerox> Yup!
13:50:00 <dmwit> opqdonut: Check the restrictions, they're pretty strong. =P
13:50:06 <Cale> Yeah, Catalan's conjecture was proven just recently.
13:50:06 <opqdonut> dmwit: ah, okay
13:50:07 <MyCatVerbs> dmwit: hah!
13:50:17 <oerjan> ooh
13:50:19 <xerox> In the same day I came across a book that said "the only /known/ solution is ..." and another with "It was recently proved that ..." :-D
13:50:33 <Cale> It's now Mihailescu's theorem
13:50:38 <xerox> Right.
13:50:41 <dmwit> heh
13:51:05 <xerox> Cohen's Springer Number Theory book (vol II) has got all the gory details.
13:51:23 <MyCatVerbs> In that case, is there any information online about, say, working out types and constructors for token streams that doesn't lead to a complete and utter mess?
13:51:34 <Cale> It's still open whether each number occurs as a difference of perfect powers only finitely many times.
13:52:03 <MyCatVerbs> Last time I tried to model a seperate lexer and parser in Haskell, I ended up with a combinatorial explosion of different, almost-useless types. Total goddamn mess. x_x
13:52:17 <Cale> (possibly 0)
13:52:39 <Cale> MyCatVerbs: That shouldn't generally be the case.
13:52:50 <Cale> MyCatVerbs: You'll have one token type, and then your parse tree type.
13:52:54 <MyCatVerbs> Cale: presumably I'm doing it wrong. Care to correct me?
13:53:01 <MyCatVerbs> Cale: so just one gigantic disjoint union type?
13:53:20 <Cale> Yeah. Usually it's not *horribly* large.
13:53:45 <MyCatVerbs> Cale: is it usually a good idea to put in a seperate "keyword" type?
13:54:00 <Cale> I usually wouldn't, but you could.
13:54:09 <Cale> You could even just have a case  Keyword String
13:54:42 <Cale> for things which the lexer recognised as keywords.
13:54:45 <MyCatVerbs> Cale: and also operators and expressions. Just stick them in, too?
13:55:02 <Cale> Expressions are a parsed construct, generally.
13:55:36 <Cale> Operator symbols go in your token type, and get parsed into expressions.
13:56:20 <Cale> Once you have an appropriate token type, it's even possible to do lexing by abusing parsec :)
13:57:05 <Cale> (Just build a very simple kind of parser which does almost no backtracking and gives a stream of Tokens
13:57:07 <Cale> )
13:57:42 <hpaste>  dons pasted "IntMap/ByteString/parser" at http://hpaste.org/6285
13:58:12 <dons> DukeDave: there's an example using IntMap, which seems to be *much* faster at least, than Map. also allocates about half of the best Map solution we've seen
13:58:13 <Cale> By the way, it's a good idea to include SourcePos values inside your Token values.
13:58:22 <dons> would be interesting to know if that's viable
13:58:31 <Cale> It's easy to do this by using getPosition
13:58:56 <dcoutts_> dons: do you need to unroll the lines and break '\t' code?
13:59:08 <Cale> Then, when you're building basic token parsers, you have a suitable extractor to use as a parameter to toekn
13:59:09 <dcoutts_> dons: does it gain much over mapping over lines?
13:59:10 <Cale> token*
13:59:14 <dons> it allocated half as much if i did that, than building up the list with liens
13:59:29 <Cale> :t Text.ParserCombinators.Parsec.Prim.token
13:59:30 <lambdabot> forall tok a st. (tok -> String) -> (tok -> Text.ParserCombinators.Parsec.Pos.SourcePos) -> (tok -> Maybe a) -> Text.ParserCombinators.Parsec.Prim.GenParser tok st a
14:00:18 <Cale> You generally use token to build up a number of primitive parsers for matching single tokens, and then use those to build the rest of your parser.
14:01:07 <dons> dcoutts_: btw, it seems there's no way currently to get the break/ breakChar specialisations from .Char8
14:01:47 <dcoutts_> dons: oh, that's a shame, and we don't export the breakChar right because we want to keep the api clean and use the specialisation?
14:01:49 <dcoutts_> dons: why isn't it working?
14:02:04 <dons> we don't export breatByte, so there's no rules in Char8 to match it
14:02:16 <dons> if you use break ((==) 10) though, its fine
14:02:25 <wli> For discrete log, one could naively do something like discreteLog :: Integer -> Integer -> Integer -> Maybe Integer ; discreteLog modulus base x = let u # v = (u * v) `mod` modulus in Data.Map.lookup x . last $ unfoldr (\(m, (k, y)) -> case Data.Map.lookup y m of Nothing -> let m' = Data.Map.insert y k m in Just (m', (m', (k + 1, y # base))) ; Just _ -> Nothing) (Data.Map.empty, (0, 1))
14:02:26 <dcoutts_> hmm
14:02:33 <dons> so maybe breakByte et al should be in internal
14:02:40 <dons> and exported to both ByteString and Char8
14:02:41 <roconnor> oh, I like autosterograms!
14:02:45 <dons> then both can have the same rules
14:02:54 <dons> while neither export it
14:03:21 <dons> since breakByte isn't exported anyway, it won't break any code I suspect
14:03:21 <dcoutts_> dons: it's not very satisfying, adding more stuff to .Internal
14:03:22 <roconnor> what a pretty lambda!
14:03:31 <roconnor> http://cdsmith.files.wordpress.com/2008/03/lambda_field.png
14:03:44 <dons> dcoutts_:  well, currently breakByte et al are just floating in ByteString
14:03:52 <dcoutts_> dons: people do import stuff from .Internal even though we tell them not to
14:04:17 <dmwit> roconnor: Damnit, I can never see those things
14:04:18 <dons> the other way would be to duplicate and specialise just those functions with memchr specialisations
14:04:42 <dons> i note wwe already do that for filter.
14:05:05 <dons> filterChar is defined in .Char8 just for the rewrite rule
14:06:38 <dons> dcoutts_:  so how about I do that, for break, span, intercalate
14:06:52 <dons> its only those three, and really only break and span that have useful specialisations
14:07:26 <dcoutts_> dons: hmm
14:07:56 <dons> so these will fire:
14:07:57 <dons> "FPS specialise break (x==)" forall x. break ((==) x) = breakByte x
14:07:57 <dons> "FPS specialise break (==x)" forall x. break (==x) = breakByte x
14:08:13 <dons> which uses memchr
14:09:15 <dcoutts_> dons: why doesn't Char8.break inline to break and then that rule fires?
14:09:35 <dcoutts_> break f = B.break (f . w2c)
14:09:50 <dcoutts_> oh, it's because it's not of the form (x==)
14:10:02 <dcoutts_> because of the w2c
14:10:39 <dcoutts_> dons: so perhaps we just need a rule like...
14:11:25 <dcoutts_> forall c. C.break (==c) = B.break (==(w2c c))
14:11:56 <dcoutts_> dons: then it should match the breakByte rule
14:15:26 <skorpan> if i have a function which returns IO (A,B) and want to pass the B as the second argument to another IO function, how do i do that?
14:15:32 <skorpan> without "do"
14:15:54 <Baughn> @undo do (a,b) <- foo; bar b
14:15:54 <lambdabot> foo >>= \ (a, b) -> bar b
14:15:58 <skorpan> oh and yeah, the second function takes three arguments
14:16:04 <Baughn> @. pl undo do (a,b) <- foo; bar x y b
14:16:04 <lambdabot> bar x y . snd =<< foo
14:16:06 <skorpan> Baughn: ah, true
14:16:12 <skorpan> ahhhhh
14:16:16 <skorpan> sweet code
14:16:18 <skorpan> thanks a lot
14:16:26 <Baughn> I'm as surprised as you are
14:16:33 <glguy>  @undo isn't a literal translation, but gets you most of the way
14:16:36 <Baughn> @pl producing readable code? Never happens.
14:16:36 <lambdabot> (line 1, column 39):
14:16:36 <lambdabot> unexpected "."
14:16:36 <lambdabot> expecting variable, "(", "!!", white space, operator or end of input
14:16:36 <lambdabot> ambiguous use of a right associative operator
14:17:20 <roconnor> @go 1 CAD in USD
14:17:20 <lambdabot> 1 Canadian dollar = 1.009897 U.S. dollars
14:17:36 <dons> dcoutts_: btw, have we thought about using the cheaper unsafeDupableIO for allocating bytestrings?
14:17:51 <kolmodin> ?seen nominolo
14:17:51 <lambdabot> nominolo is in #haskell-soc, #ghc and #haskell. I last heard nominolo speak 45m 11s ago.
14:17:52 <tromp> @go 1EUR in USD
14:17:53 <lambdabot> 1 Euro = 1.53700 U.S. dollars
14:18:00 <dons> it looks like we've found an issue where update frame squeezing doesn't happen, and we get a space leak, due to the use of unsafePerformIO
14:18:05 <dcoutts_> dons: we've not, but we should
14:18:06 <nominolo> kolmodin: hi there
14:18:24 <kolmodin> nominolo: hia
14:18:24 <dcoutts_> dons: how does that happen?
14:18:27 <nominolo> kolmodin: what is Haste? it's part of your hac4 projects
14:18:40 <tromp> what does @go stand for?
14:18:46 <tromp> google?
14:18:55 <nominolo> tromp: it spell-corrects to @google
14:18:58 <dcoutts_> dons: so that means that we're getting duplication anyway even though unsafePerformIO is supposed to stop it?
14:19:04 <tromp> @go tromp
14:19:04 <lambdabot> No Result Found.
14:19:11 <nominolo> @go 42
14:19:12 <lambdabot> http://en.wikipedia.org/wiki/The_Answer_to_Life,_the_Universe,_and_Everything
14:19:12 <lambdabot> Title: Answer to Life, the Universe, and Everything - Wikipedia, the free encyclopedia
14:19:14 <kolmodin> nominolo: it's a (dead) haskell IDE written in haskell
14:19:17 <dcoutts_> dons: and this is happening only with -threaded and using multiple threads at runtime?
14:19:18 <dons> we'd get duplication if two threads touched a pack or a call to singleton, for example
14:19:25 <nominolo> kolmodin: and you want to revive it?
14:19:29 <Maddas> @goggle 1CAD in CHF
14:19:30 <lambdabot> 1 Canadian dollar = 1.03120584 Swiss francs
14:19:32 <kolmodin> nominolo: not really :)
14:19:43 <tromp> @go nulkukel
14:19:45 <kolmodin> nominolo: it should be written from scratch
14:19:45 <lambdabot> http://www.cwi.nl/~tromp/
14:19:45 <lambdabot> Title: John Tromp HomePage
14:19:47 <dons> dcoutts_: this program, http://hpaste.org/6247
14:19:48 <kolmodin> nominolo: using gtk
14:19:48 <roconnor> 1 global currency!
14:20:07 <dcoutts_> dons: then unsafeDupableIO would make it worse, we'd get unsharing more often
14:20:12 <nominolo> kolmodin: better help with Yi, Shim+Yi, VisualHaskell+Yi, or even the eclipse plugin
14:20:14 <dons> build/foldr puts it in a form where the unsaferPerformIO marked stack frames don't get squeezed, and it leaks.
14:20:25 <dons> which wouldn't happen with unsafeDupableIO
14:20:28 <kolmodin> nominolo: or leksah
14:20:44 <nominolo> kolmodin: or that.  though, i'd rather prefer Yi :)
14:20:49 <dons> dcoutts_: right, unsafeDupableIO is the old unsafePerformIO we used
14:20:50 <kolmodin> nominolo: anyway, haste is not a project I'm looking to hack on
14:21:04 <tromp> > 275*1.5
14:21:05 <lambdabot>  412.5
14:21:32 <dcoutts_> dons: I don't follow. What is causing a leak? and how would allowing more duplication help it?
14:21:37 <nominolo> kolmodin: k
14:21:40 <pastorn> what is the default encoding for haskells Char type?
14:21:54 <dons> dcoutts_: oh, so if you use the new unsafePerformIO, update frame squeezing doesn't happen, from what SimonM says.
14:21:58 <dcoutts_> pastorn: there is no encoding, a Char is a Unicode code point.
14:22:10 <dons> which means you can write loops now that stack overflow, where they used not to
14:22:12 <pastorn> "code point"?
14:22:31 <dons> but apparently the old unsafePerformIO, aka dupable IO works.
14:22:34 <dcoutts_> dons: right, the new smp-safe unsafePerformIO does not give you tail recursion
14:22:39 <dons> yeah
14:22:43 * kolmodin read SimonM as the Simon Monad
14:22:51 <kolmodin> doh
14:22:55 <kolmodin> :)
14:22:56 <dons> there was a thread about this recently
14:23:09 <dons> so that's what's hitting this code too, http://hpaste.org/6247
14:23:22 <dons> so did the smp version affect us?
14:23:25 <wy> hey
14:23:31 <dcoutts_> dons: but are any of the unsafePerformIO's we use, used in a tail recursion position where that'd make a difference?
14:23:33 <wy> I just found this thing: http://cag.csail.mit.edu/ps3/lectures/6.189-lecture8-streamit.pdf
14:23:54 <dons> dcoutts_: i think we have an example, yes.
14:23:58 <wy> I wonder if we have some theoretical category for this kind of language?
14:23:58 <dons> but i'm testing...
14:24:00 <dcoutts_> dons: or you're saying it can only happen when we fuse
14:24:15 <dons> ah, that may be the situation, yes.
14:24:22 <dons> here its build/foldr fusing
14:25:01 <dons> simon says hi!
14:25:06 <dcoutts_> hi simon!
14:25:07 <wy> It looks like monads or arrows?
14:25:20 <wy> where is simon?
14:25:23 <dcoutts_> dons: is he going to turn up here at all?
14:25:34 <dons> in #haskell ?
14:25:42 <dcoutts_> or #ghc, yes
14:26:00 <wy> maybe he already has a secrete nick somewhere?
14:26:10 <dcoutts_> dons: in that hpaste the S.singleton isn't used in a tail recursion so I don't see how the unsafePerformIO could get in the way
14:26:24 <wy> hey could you guys have a look at the language I mentioned?
14:26:35 <dcoutts_> @src unsafePerformIO
14:26:35 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
14:26:38 <dcoutts_> bah
14:26:56 <dcoutts_> unsafePerformIO a = unsafeDupableIO (noDup >> a)
14:27:19 <dcoutts_> dons: so my understanding was that the (noDup >> a) can prevent the tail call optimisation
14:27:26 <wy> It looks very much like monads
14:27:44 <dcoutts_> but that's not what's going on in these examples for S.singleton
14:28:09 <dcoutts_> I can't think of a single example where we allocate in a recursion
14:28:12 <dons> dcoutts_: right, the current unsafePerformIO is the noDup one
14:28:37 <dons> we'd want to revert to unsafeDupablePerformIO
14:28:46 <dcoutts_> dons: but why, that's the Q.
14:28:47 <wy> @users
14:28:47 <lambdabot> Maximum users seen in #haskell: 463, currently: 456 (98.5%), active: 17 (3.7%)
14:29:21 <dons> ah, because we have at least one real program now that's stack overflowing due to this
14:29:23 <dcoutts_> I can see an argument that it's probably safe and it's cheaper so...  but I don't buy the argument about update frames
14:29:23 * wli golfs it down to discreteLog modulus base x = Data.Map.lookup x . snd $ until (uncurry $ Data.Map.member . fst) (((((`mod` modulus) . (base *)) *** (+1)) . fst) &&& uncurry (uncurry Data.Map.insert)) ((1, 0), empty) in discreteLog
14:29:36 <dcoutts_> dons: you'll have to show me or explain it, I don't see how it can happen
14:29:46 <dons> so the program i pasted manifests it
14:30:01 <dcoutts_> dons: the enc x = S.singleton x `seq` [x]
14:30:06 <dons> where build/foldr produces a funky continuation passing filter loop, that's consumes stack
14:30:10 <dons> when it shouldn't
14:30:22 <dons> right, that's the boiled down version of a utf8 decoer
14:31:01 <dcoutts_> dons: I don't see how the allocation gets involved in any loop
14:31:51 <dcoutts_> dons: the allocation looks local to each iteration
14:32:21 <dcoutts_> so the body of the unsafePerformIO should only span one iteration
14:32:42 <dons> let me see if this fixes it
14:34:17 <dons> yeah, that fixes the overflow
14:34:25 <dons> using unsafeDupablePerformIO for unsafeCreate
14:34:40 <dcoutts_> I don't understand it
14:35:09 <dons> did you look at the loop form that's created after fusion?
14:36:43 * dcoutts_ does ghc -O2 -c stack.hs -ddump-simpl
14:38:35 <sebell> z/quit
14:39:18 <dcoutts_> dons: so the enc bit calls unsafeDupablePerformIO and noDuplicate# but I don't see any recursive calls within it or any continuations
14:39:55 <dcoutts_> enc_rmZ :: GHC.Base.Char -> GHC.Base.String
14:40:43 <dcoutts_> dons: it doesn't take any continuations and it does not call any other top level values
14:41:16 <dons> i thought enc was used by the buidl/foldr-d filter, which called a continuation
14:41:29 <dons> filterFB c p x r | p x       = x `c` r | otherwise = r
14:41:49 <dons> is the f/b encoding of filter, which in turn calls enc
14:41:56 <dcoutts_> perhaps I'm seeing different core to you
14:42:01 * dcoutts_ checks which rules fired
14:42:57 <dons>     1 ++
14:42:58 <dons>     1 SPEC GHC.Base.$f10
14:42:58 <dons>     2 eftChar
14:42:58 <dons>     1 filter
14:42:58 <dons>     2 fold/build
14:43:00 <dons>     1 foldr/augment
14:43:03 <dons>     4 ord#
14:43:04 <dcoutts_> I get the same
14:43:06 <dons> where 1, filter. "filter"     [~1] forall p xs.  filter p xs = build (\c n -> foldr (filterFB c p) n xs)
14:43:12 <dons> puts it into that filterFB guy
14:44:08 <dcoutts_> dons: what do you actually see in the core?
14:45:04 <dons> http://galois.com/~dons/tmp/Z.hcr
14:45:15 <dons> that's with DupableIO in bytestring
14:45:31 <dcoutts_> right
14:46:04 <olsner> GullibleIO?
14:47:03 <gwern> Good news, everyone! SmallCheck is now on Hackage: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/smallcheck-0.2.1
14:47:08 <lambdabot> http://tinyurl.com/2ooluz
14:47:24 <dcoutts_> dons: so the core I see is the same but with one extra noDuplicate# s_a11b of __DEFAULT
14:48:38 <dcoutts_> dons: ask Simon, I can't explain the behaviour, the noDuplicate# case appears to scope over no tail calls
14:49:02 <glguy> mv *
14:49:05 <glguy> is a destructive force
14:49:44 <dons> interesting
14:50:33 <olsner> if you're lucky, you have a folder the comes last in the alphabet
14:50:56 <olsner> *that, -in, *alphabetical order
14:52:03 <dons> dcoutts_: but do you see any reason not to switch bytestring to DupableIO ?
14:52:15 <dons> or do we need further insights from simon?
14:52:21 <dcoutts_> dons: I think we should understand the reasons for doing so
14:52:39 <dcoutts_> dons: there are good reasons, but this looks like we do not understand noDuplicate# or a ghc bug
14:52:43 <dons> ok. at least now we're in a position to make a bug report about the behaviour
14:52:57 <dcoutts_> dons: in either case we should find out before proceeding
14:52:57 <dons> and then see if simon can clarify what's happening
14:53:00 <dcoutts_> right
14:53:05 <dons> ok. i'll create a ticket
14:53:18 <dons> i do like the fact that unsafeCreate l f = unsafeDupablePerformIO (create l f) fixes it :)
14:53:48 <bos> what does the Dupable indicate, anyway?
14:54:12 <dcoutts_> dons: we can also double check with Simon that our rational for why our use of dupable is safe is correct
14:54:21 <dons> "This version of 'unsafePerformIO' is slightly more efficient,
14:54:22 <dons> because it omits the check that the IO is only being performed by a
14:54:22 <dons> single thread. "
14:54:37 <dons> that's the old behaviour of unsafePerformIO , in fact
14:54:41 <dcoutts_> bos: the IO action might get duplicated and run multiple times for the same thunk
14:55:03 <dcoutts_> dons: no, unsafePerformIO has not really changed it's just that now we have the SMP runtime
14:55:18 <bos> dcoutts_: ah
14:55:19 <dons> well, unsafePerformIO has a new definition too
14:55:23 <dons> unsafePerformIO m = unsafeDupablePerformIO (noDuplicate >> m)
14:55:26 <dcoutts_> dons: unsafePerformIO did not previously duplicate an IO action for a thunk
14:55:33 <dons> but yeah, the smp runtime revealed this issue
14:55:40 <dons> in the context of getContents, iirc
14:55:57 <dcoutts_> right, so the semantics of unsafePerformIO stay the same and we get a new less safe version, unsafeDupablePerformIO
14:56:12 <dcoutts_> let thunk = unsafeDupablePerformIO a in ...
14:56:21 <dcoutts_> 'a' might get run more than once
14:56:22 <oerjan> but getContents uses unsafeInterleaveIO doesn't it?
14:56:22 <dons> ah right, so the smp runtime meant that you could now have separate threads in parallel duplicating an action
14:56:31 <dcoutts_> oerjan: same issue
14:56:37 <dcoutts_> dons: yep
14:56:40 <dons> unsafeDupableInterleaveIO :: IO a -> IO a
14:56:57 <dons> see.. on so many levels IO isevil
14:57:05 <oerjan> except with unsafeInterleaveIO you _expect_ more of a guarantee
14:57:16 <oerjan> (at least i did)
14:57:17 <dcoutts_> oerjan: yeah
14:57:19 * Baughn certainly has the impression that he's been hearing the language of mordor lately
14:58:00 <wli> Hmm, how do you take a subarray derived from a given array by restricting the range of indices?
14:58:50 <dons> the noDuplciate primop has a cost though
14:58:56 <dcoutts_> dons: sure
14:58:57 <dons> Ensures that the suspensions under evaluation by the current thread
14:58:57 <dons> are unique; that is, the current thread is not evaluating anything
14:58:57 <dons> that is also under evaluation by another thread that has also executed
14:58:57 <dons> 'noDuplicate'.
14:58:57 <dons> This operation is used in the definition of 'unsafePerformIO' to
14:58:59 <dons> prevent the IO action from being executed multiple times, which is usually
14:59:02 <dons> undesirable.
14:59:04 <dons> -}
14:59:07 <dons> noDuplicate :: IO ()
14:59:09 <dons> noDuplicate = IO $ \s -> case noDuplicate# s of s' -> (# s', () #)
14:59:17 <dons> the 'unique' here is interesting.. i wonder if we can use that for other magics
14:59:46 <dcoutts_> dons: so if it is safe to duplicate our IO actions and they're not enormously expensive then it's probably faster to allow the occasional duplication
15:00:25 <dons> right.
15:00:56 <dons> our Eq doesn't rely on pointer equivalence
15:01:02 <dcoutts_> right
15:01:05 <dcoutts_> I think it is safe to duplicate them
15:01:24 <oerjan> dons: er, so noDuplicate checks more than exactly the thunk it is currently entering?  isn't that expensive?
15:01:26 <dcoutts_> additional unsharing is safe, additional sharing is unsafe
15:01:34 <dons> it has to at least mark slots on the stack
15:01:35 <dcoutts_> for memory allocations
15:01:50 <dons> and that prevents (currently) update frame squeezing of those guys
15:02:39 <dcoutts_> dons: it'd be interesting to get a clarification on that from Simon
15:03:01 <dons> right, so we'll do that via the bug report for this program
15:03:15 <dcoutts_> dons: perhaps it is the case that using noDuplicate# in a loop -- even if it does not scope over the tail of the loop -- prevents whatever
15:03:45 <dons> ok. bbl
15:03:50 <dcoutts_> dons: I'm not sure I understand update frame squeezing and how it relates to tail calls and stack use
15:15:31 <Baughn> > [(a,b,c) | a <- [1..2] | b <- [1..3] | c <- [1,4,5]]
15:15:31 <lambdabot>  Parse error at "|" (column 24)
15:15:38 <Baughn> > [(a,b,c) | a <- [1..2] | b <- [1..3] ]
15:15:38 <lambdabot>  Parse error at "|" (column 24)
15:15:47 <mauke> no parallel comprehensions
15:16:30 <dolio> @type [(a,b) | a <- [1..] | b <- [1..]]
15:16:32 <lambdabot> forall t t1. (Enum t1, Num t1, Enum t, Num t) => [(t1, t)]
15:17:44 <Baughn> ..that's odd
15:18:10 <dolio>  > tries uses its own parser before handing off to ghc.
15:18:21 <dolio> Er, ignore that 'tries'.
15:18:47 <Saizan> also, it doesn't have -fglasgow-exts enabled, while :t does
15:18:48 <dolio> > let f (n+1) = n in f 3
15:18:48 <lambdabot>  Parse error in pattern at "in" (column 17)
15:19:07 <opqdonut> this is quite nice too
15:19:11 <opqdonut> > '('
15:19:12 <lambdabot>  '('
15:19:25 <opqdonut> hmm, it threw a mismatched parenthesis error before
15:19:44 <dolio> It's learning on its own!
15:19:50 <QtPlatypus> > (
15:19:50 <lambdabot> Unbalanced parentheses
15:20:02 <dolio> > 1 -- (
15:20:02 <lambdabot>  1
15:20:05 <oerjan> it doesn't have n+k patterns iirc
15:20:17 <Baughn> > 1 {- (
15:20:17 <lambdabot>  Unterminated nested comment at "1" (column 1)
15:20:21 <Baughn> > 1 {- ( -}
15:20:22 <lambdabot>  1
15:20:46 <oerjan> the broken parenthesis check was removed
15:21:06 <mauke> :t (.).(.)
15:21:07 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
15:21:08 <oerjan> (i think it was subsumed by the ordinary pass through Language.Haskell...)
15:21:44 <olsner> wow, -fvia-c is slow
15:24:56 <olsner> and doesn't make this particular program much faster
15:25:31 <mofmog> so my toy calc program http://codepad.org/OcVi62Cp has the error: http://codepad.org/bG0jR8UK
15:25:36 <dolio> Isn't -fvia-c only recommended for floating-point heavy stuff these days?
15:25:46 <mofmog> This is my first "real" program in haskell and i think it shows i'm misunderstanding fundametal
15:27:15 <gwern> dolio: -fvia-c also seems to be necessary for linking to ncurses
15:27:16 <mofmog> it's a strange hybrid of the calc program i wrote in scheme, Write your own scheme interpreter in 48 days and def macro's tutorial
15:27:23 <dolio> Ah.
15:27:31 <mauke> mofmog: yeah, (.) is function composition
15:28:08 <mofmog> i want it to parse and thenreturn the data type operat
15:28:29 <mofmog> i think that's what def macro was doing with liftM(Number.read) -- i shamelessly stole that from him
15:29:00 <mauke> oh, you also don't understand what liftM does
15:29:22 <mofmog> it lets a function work on the data inside a monad right?
15:29:33 <mauke> right
15:29:43 <mofmog> unless i'm mixing things up again *sigh*
15:29:48 <mauke> except there is no monadic data in line 22
15:29:59 <mauke> and oneOf "..." is not a function
15:30:01 <mofmog> well i thought parsers were monads
15:30:07 <mauke> yes
15:30:31 <mauke> liftM <function> <parser>
15:30:37 <mauke> you only have liftM <function>
15:30:53 <mofmog> ok, so say i get a successful parse of "+-*/"
15:31:15 <mofmog> how do i get "+" or "-" for example and shove it into being an Operat type
15:31:33 <mauke> liftM Operat (oneOf "+-*/")
15:31:40 <mofmog> ah
15:31:43 <mauke> except that doesn't typecheck because oneOf returns a Char
15:31:58 <mauke> liftM (\c -> Operat [c]) (oneOf "...")
15:32:16 <mauke> or if you want to be 1337, liftM (Operat . return) $ oneOf "+-*/"
15:32:47 <mofmog> what if i slapped braces around (oneOf "+-*/") ?
15:33:10 <mauke> huh?
15:33:28 <mofmog> wait no that's silly
15:33:41 <astrolabe> As in [22:31] mauke: liftM Operat (oneOf "+-*/")
15:33:57 <mofmog> []'s
15:34:00 <astrolabe> or you meant {}?
15:34:04 <oerjan> although it _would_ accidentally work if you used mapM instead of liftM ...
15:34:30 <mauke> mofmog: [oneOf ...] is a list of parsers, not a parser returning a list
15:34:42 <oerjan> mapM Operat [oneOf "+-*/"]
15:34:46 <mauke> you need liftM or equivalent to mess with the return value
15:34:52 <oerjan> that may be a bit obfuscated though
15:34:57 <mauke> :t mapM
15:34:58 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:35:01 <oerjan> oh wait
15:35:05 <mofmog> goddang monads hiding data and stuff
15:35:06 <oerjan> forget it
15:35:09 <mauke> type error
15:35:25 <oerjan> the [ ] and Operat get in the wrong order then
15:35:38 <astrolabe> mofmog: I found it really helpful to learn what ghc means by 'expected type' and 'infered type'.  Also to use :t in ghci.
15:35:38 <mauke> parseOperat = do { op <- oneOf "+-*/"; return (Operat [c]) }
15:35:42 <byorgey> liftM (Operat . (:[])) $ oneOf "+-*/"  -- use the robot monkey operator!
15:36:08 <mauke> ‚Äòreturn‚Äô is easier to type than ‚Äò(: [])‚Äô
15:36:18 <byorgey> so? (:[]) looks cooler =P
15:37:14 <oerjan> mofmog: for your other error, the problem is that the Left and Right case branches actually do have different types
15:37:25 <Zao> (:[]) is the robotic monkey operator.
15:37:37 <mauke> :t pure
15:37:38 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
15:37:42 <Zao> Oh, it was said just above. I'm lazy in evaluating chat.
15:38:18 <mofmog> oerjan: yeah i got that one
15:38:22 <mofmog> ok let's fire up this baby
15:38:24 * byorgey orders his flying robotic monkeys to tickle Zao
15:38:46 <Zao> byorgey: Good think I'm inside my radioactive spacesuit monad.
15:38:52 <DukeDave> dons: Excellent, I'm heading home now but I'll have a look shortly & let you know how it fairs on my full data set tomorrow morning (GMT)
15:38:56 <byorgey> hehe
15:38:59 <byorgey> -- XXX TODO: add documentation
15:39:07 <byorgey> uh, oops, sorry =)
15:39:14 <mofmog> > :t 3.458539
15:39:14 <lambdabot>   parse error on input `:'
15:39:23 <Zao> byorgey: How did you get your hands on my code?
15:39:35 <oerjan> mofmog: btw we have our own pastebin that's particularly nice for channel discussions - it allows annotating pastes, and announces them to the channel
15:39:38 <oerjan> @paste
15:39:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:40:01 <EvilTerran> :t 3.458539 -- is how we do that on the channel, mofmog
15:40:03 <lambdabot> forall t. (Fractional t) => t
15:40:06 <mofmog> hmm, it seems using integers for numbers is making the interpreter sad
15:40:09 <mauke> hpaste has a few severe problems, though
15:40:12 <EvilTerran> ?type 3.458539 -- also this works
15:40:13 <lambdabot> forall t. (Fractional t) => t
15:40:25 <mofmog> due to the / function
15:40:26 <oerjan> mauke: hm?
15:40:29 <mauke> it silently truncates pastes, and it never deletes any
15:40:39 <mofmog> errrrrrrr lesee, what should i use to represent all reals
15:40:46 <mofmog> or at least, rationals
15:40:47 <oerjan> yeah.  how is the replacement coming?
15:40:53 <mauke> mofmog: Rational
15:41:06 <mauke> or Double if you want floating point numbers
15:41:12 <EvilTerran> ?src Rational
15:41:12 <lambdabot> type Rational = Ratio Integer
15:44:30 <hpaste>  mofmog pasted "calc apply/eval" at http://hpaste.org/6288
15:44:47 <mofmog> ^^ i get some error about fractional
15:44:58 <mofmog> i'm guessing because it outputs different types?
15:45:05 <mofmog> OH
15:45:07 <mofmog> nvm
15:45:08 <mofmog> i got it
15:45:17 <mofmog> it should return a CalcVal
15:49:30 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6289
15:49:34 <tromp> perfect powers wld be easy to express in terms of merge of infinitely many lists
15:51:00 <Maddas> tromp: Infinitely long ones, I hope!
15:51:20 <EvilTerran> i think the way to do it would be much the same as enumerating Q^{+}
15:51:43 <tromp> map (\n map (^n) [2..]) [1..]
15:52:04 <EvilTerran> > 1 : [x^n | x <- [2..], n <- [2..x]]
15:52:05 <lambdabot>  [1,4,9,27,16,64,256,25,125,625,3125,36,216,1296,7776,46656,49,343,2401,16807...
15:52:05 <tromp> merge $ map (\n -> map (^n) [2..]) [1..]
15:52:18 <EvilTerran> or by diagonalisation
15:52:34 <EvilTerran> it's harder if you want to omit duplicates
15:52:39 <RayNbow> @src readLn
15:52:39 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
15:52:47 <tromp> i want the result to be ordered, without duplicates
15:53:22 <EvilTerran> then, yes, merging an infinity of infinite lists is probably necessary. should be possible, with a careful algorithm
15:53:45 <tromp> yes, knowing that each is ordered, and the heads of all lists are ordered
15:54:10 * oerjan recalls discussing that on #haskell before
15:54:21 <oerjan> there might even be something on hpaste
15:55:11 <Cheery> http://img401.imageshack.us/my.php?image=churchsignjr4.jpg
15:58:54 <Cheery> http://img175.imageshack.us/content.php?page=done&l=img175/3609/churchsigney7.jpg
15:58:57 <lambdabot> Title: ImageShackÆ - Done, http://tinyurl.com/2qnw4x
15:59:20 <Cheery> http://img175.imageshack.us/img175/3609/churchsigney7.jpg
15:59:33 <EvilTerran> Cheery, why on earth are you posting C++ propaganda to #haskell?
15:59:37 <Cheery> (irony, if somebody doesn't understand)
16:00:29 <Cheery> EvilTerran: is this propaganda, I thought it is antipropaganda
16:00:38 <dolio> Is qwe1234 chief pastor?
16:00:58 <tromp> > (1.85/1.75)**3
16:00:59 <lambdabot>  1.1814110787172012
16:01:02 <Baughn> Cheery: No, it's just incomprehensible
16:01:06 <Cheery> http://img341.imageshack.us/my.php?image=churchsignuu9.jpg
16:02:47 <mofmog> so i have eval val@(CalcLs x:xs) = apply (eval x) $ map eval xs where CalcLs contains [CalcVal]
16:03:17 <mofmog>  Couldn't match expected type `CalcVal' against inferred type `[a]'
16:03:52 <Toxaris> mofmog: you want val@(CalcLs (x:xs))
16:04:21 <Toxaris> mofmog: val@(CalcLs x:xs) is parsed as val@((CalcLs x):xs)
16:04:37 <mofmog> oh
16:04:38 <mofmog> right
16:04:51 <mofmog> now it's complaining that x is a CalcVal and not a [Char]
16:05:05 <oerjan> Cheery: fake irony is not irony
16:05:11 <mofmog> even though x should be an Operat which is defined to contain a string
16:05:13 <mofmog> 0_0
16:05:20 <oerjan> at least not of the kind intended
16:05:44 <Cheery> oerjan: somehow it is often used in posters and such
16:05:45 <mofmog> i think about 95% of my errors in haskell are due to having trouble with the type system
16:06:13 <mofmog> i guess it prevents DAV's or something
16:06:29 <Cheery> mofmog: what sort of troubles?
16:06:54 <EvilTerran> the same thought errors that cause static errors in haskell would cause unexpected behaviours at runtime in languages with less expressive type systems
16:07:13 <mofmog> here, let me paste the code i have currently and the errors i'm getting
16:07:20 <mofmog> they all center on the part where eval calls apply
16:07:42 <hpaste>  mofmog pasted "(no title)" at http://hpaste.org/6290
16:08:08 <Toxaris> mofmog: what's the type of apply?
16:08:10 <hpaste>  mofmog pasted "errors" at http://hpaste.org/6291
16:08:35 <mofmog> it should be Operat -> CalcLs -> CalcVal i guess
16:08:47 <mofmog> takes an operator, a list of arguments
16:08:47 <oerjan> mofmog: the nice thing about that is that often once it types, it is correct
16:09:00 <Toxaris> mofmog: sounds sensible, but you use literal strings in the equations for apply
16:09:17 <Toxaris> mofmog: so it's type is bound the be apply :: String -> something
16:09:32 <mofmog> yeah, but i defined Operat to contain strings
16:09:37 <mofmog> so i figured that should work...
16:09:40 <Cheery> it's not always correct when it types
16:09:52 <mofmog> unless I should explicitly say Operat "+"
16:09:53 <mofmog> ?
16:09:59 <mofmog> in the pattern matchin
16:10:00 <Cheery> but at least you learn to reason better over your programs _in any language_
16:10:01 <oerjan> mofmog: you have to include the Operat yes
16:10:01 <Toxaris> mofmog: yes you should :)
16:10:37 <pastorn> @hoogle zipWithM
16:10:38 <lambdabot> Control.Monad.zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
16:10:38 <lambdabot> Control.Monad.zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
16:10:38 <lambdabot> Data.Generics.Twins.gzipWithM :: Monad m => GenericQ (GenericM m) -> GenericQ (GenericM m)
16:10:44 <mofmog> i think the liftM with the foldr's are a little goofy
16:11:03 <mofmog> but they're the only way i can think of of getting numbers out of the Number datatype
16:12:08 <Toxaris> mofmog: what do you mean by Number datatype?
16:12:17 <mofmog> er constructor?
16:12:26 <Toxaris> mofmog: I see only a Number constructor, which is one of the constructors for the CalcVal datatype
16:12:33 <mofmog> yes that's what i meant
16:12:48 <Toxaris> liftM will not help you here
16:13:21 <idnar> I guess gzipWithM has nothing to do with compression
16:13:22 <mofmog> hmm
16:13:33 <mofmog> some sort of map?
16:13:57 <pastorn> how do i rename files?
16:14:17 <pastorn> system $ "mv " seems like the wrong way
16:14:26 <mofmog> map (\(Number a) -> a) a
16:14:28 <mofmog> or something like that
16:14:34 <roconnor> @hoogle rename
16:14:34 <lambdabot> Language.Haskell.TH.Lib.rename :: Pat -> Q ([(Name, Name)], Pat)
16:14:34 <lambdabot> System.Directory.renameDirectory :: FilePath -> FilePath -> IO ()
16:14:34 <lambdabot> System.Directory.renameFile :: FilePath -> FilePath -> IO ()
16:14:42 <roconnor> System.Directory.renameFile
16:14:47 <pastorn> cool
16:15:29 <roconnor> @karma+ hoogle
16:15:29 <lambdabot> hoogle's karma raised to 4.
16:15:52 <Toxaris> mofmog: yes something in this direction. it has to be something CalcVal-specific, which specifies what to do with each constructor. your idea will extract the double our of Numbers, and produce a runtime-error if anything different is encountered
16:16:14 <mofmog> well at that point they should all be numbers
16:16:16 <Toxaris> mofmog: which is probably fine for a toy program
16:16:52 <mofmog> is map (\(Number inside) -> inside) a propper  haskell?
16:16:53 <Toxaris> mofmog: they should all be numbers? so "(* (+ 1 1) 2)" is not allowed?
16:16:58 <mofmog> well
16:17:06 <mofmog> (+ 1 1) is evaluated beforehand
16:17:12 <mofmog> or at least it should have been
16:17:13 <mofmog> heh
16:17:27 <mofmog> at the base cases it should be an Operat working on what should be numbers
16:17:40 <Toxaris> mofmog: hmm yes it is, by the "$ map eval xs" in eval
16:18:16 <Toxaris> mofmog: so your program crashes only if the user types invalid programs, which may be ok, since invalid programs are supposed to crash
16:19:23 <dons> Heffalump: I worry a bit that jdh is going around speaking to places (BarCap, anygma) about what tools to use.. :(
16:19:25 <Toxaris> > map (\(Just inside) -> inside) [Just "works", Just "fine", Nothing]
16:19:26 <lambdabot>   Non-exhaustive patterns in lambda
16:19:47 <Toxaris> > map (\(Just inside) -> inside) [Just "works", Just "fine"]
16:19:48 <lambdabot>  ["works","fine"]
16:20:30 <Toxaris> why is the result of my previous expression not ["works","fine", Non-exhaustive patterns ...]?
16:21:02 <mofmog> because it doesnt know what to do with nothing
16:21:07 <EvilTerran> \b doesn't show any of a result if there's any bottoms in it
16:21:46 <mofmog> apply (Operat "+") a = Number $ foldr (+) 0 $ (map (\(Number a) -> a) a) <-- this is what i have so far for +
16:21:50 <Toxaris> mofmog: well, no reason to throw away the first two list entries. try it with ghci.
16:21:54 <EvilTerran> while ghci gets part-way through displaying the output before finding the bottom
16:22:27 <mofmog> i find myself just copy and pasting code for the other functions
16:23:03 <mofmog> i think i can generalize this later on, but for now i'm just going to focus on getting this thing to work I guess
16:23:56 <mofmog> yay now it only complains that there is no "show" method for the calcval constructor
16:23:58 <mofmog> i know how to fix that
16:24:00 * mux reads on wikipedia that people have proved that some specific kind of neural network with rational valued weights has the full power of a universal turing machine, and that using irrational values results in a machine with trans-turing power
16:24:18 <mux> I wonder what thell is trans-turing power
16:24:20 <mofmog> trans-turing power?
16:24:21 <mux> it sure sounds nice
16:24:32 <mofmog> i knew he was gay but transexual also?
16:24:49 <byorgey> it can solve the halting problem, I guess
16:24:54 <tromp> > 10^4*3600*24*365
16:24:54 <mofmog> goes to show that great people come from all backgrounds
16:24:55 <lambdabot>  315360000000
16:25:00 <Baughn> mofmog: http://en.wikipedia.org/wiki/Turing_oracle
16:25:01 <tromp> > ln 0.5
16:25:02 <lambdabot>   Not in scope: `ln'
16:25:12 <tromp> > Math.ln 0.5
16:25:12 <lambdabot>   Not in scope: `Math.ln'
16:25:14 <Baughn> *mux, rather
16:25:21 <EvilTerran> > log 0.5
16:25:22 <lambdabot>  -0.6931471805599453
16:25:22 <Toxaris> mofmog: it sometimes help to use two types: data Term and data Value, and a function eval :: Term -> Value. then you have the guarantee that the result of eval doesn't contain unevaluated expressions.
16:25:29 <EvilTerran> > log (exp 1)
16:25:29 <lambdabot>  1.0
16:25:33 <tromp> thx
16:25:35 <EvilTerran> > exp 1
16:25:36 <lambdabot>  2.718281828459045
16:26:01 <Toxaris> mofmog: and you can handwaive about semantic domains while explaining your code to people :)
16:26:19 <mux> Baughn: wow, looks nice
16:26:44 <Baughn> mux: Of course there are no irrational numbers in reality
16:26:53 <Baughn> Probabl
16:27:11 <pastorn> @hoogle toLower
16:27:11 <lambdabot> Data.Char.toLower :: Char -> Char
16:27:18 <mofmog> Toxaris: but eval is recursive onto itself in a way. If I did that, eval would be working with both terms AND values would it not?
16:27:22 <mofmog> in the input
16:27:45 <Toxaris> i'm not sure, but an irrational number is equivalent to an infinite stream of digits, e.g., information. wouldn't it be possible to choose that irrational number which digit stream encodes the solution of the halting problem. of course, it is not possible to compute that number ... :(
16:27:46 <mofmog> well not now i guess
16:28:10 <mofmog> but if it gets more complex that situation could arise
16:28:10 <Toxaris> mofmog: eval is a fold over the term structure
16:28:42 <mofmog> well if i say add evaluations for lambdas, i will ask it to return its body which is a term and not a value
16:29:00 <mofmog> (lambda (x) (+ x 2)) shoved into eval should return (+ x 2)
16:29:07 <Toxaris> data Value = ... | Closure Term | ...
16:29:24 <mofmog> mutually recursive data types i see
16:29:32 <mofmog> well not mutually
16:29:40 <wli> Baughn: Numbers of all kinds are no more than mental constructs used to model the world, including natural numbers, cardinal numbers, and ordinal numbers.
16:29:43 <Toxaris> data Term = ... | Literal Value | ...
16:29:58 <mofmog> sorry i've been reviewing tree structures all day for my midterm tommorow
16:30:05 <mofmog> i really shouldn't be working on calc
16:30:10 <Baughn> wli: They work suspiciously well, if so
16:30:41 <wli> Baughn: If they worked poorly, they would've been dropped in favor of a more suitable mental construct.
16:32:15 <hpaste>  dons annotated "IntMap/ByteString/parser" with "actually use an IntMap" at http://hpaste.org/6285#a1
16:33:11 <mib_v256971w> can a virus be written in haskell?
16:33:17 <Adamant> yes
16:33:23 <Saizan> ?faq
16:33:23 <lambdabot> The answer is: Yes! Haskell can do that.
16:33:29 <QtPlatypus> Toxaris: That number exists its just not computable.  Most of the real's are uncomputable
16:33:39 <pastorn> Saizan: lovely <3 <3
16:33:51 <pastorn> @hoogle URL
16:33:51 <lambdabot> Distribution.InstalledPackageInfo.pkgUrl :: InstalledPackageInfo_ m -> String
16:33:51 <lambdabot> Distribution.PackageDescription.pkgUrl :: PackageDescription -> String
16:33:59 <pastorn> @hoogle URI
16:33:59 <lambdabot> No matches found
16:34:01 <tromp> not just most, 100% of them:)
16:34:05 <pastorn> @hoogle http
16:34:05 <lambdabot> No matches found
16:34:19 <pastorn> i need URL -> String
16:34:24 <pastorn> what am i looking for?
16:34:34 <QtPlatypus> tromp: That stament always bothers me.
16:34:51 <tromp> if you pick random real in [0,1]
16:34:58 <tromp> the with prob 1, it's uncomputable
16:35:14 <QtPlatypus> tromp: Yes but I can find examples of computable reals.
16:35:30 <mib_v256971w> is there any notes on where i can actually write a virus for haskell, just a project
16:35:44 <tromp> i bet you cant find any example of uncomputable one:)
16:35:47 <Adamant> I don't think any VX'ers use Haskell
16:35:51 <oerjan> mib_v256971w: probably.  i am not going to tell you.
16:35:54 <allbery_b> pastorn: uriToString?
16:36:08 <QtPlatypus> tromp: caitan's omega.
16:36:13 <Cheery> mib_v256971w: what sort of virus?
16:36:13 <allbery_b> (which actually produces a ShowS, see shows)
16:36:25 <tromp> ah, you know your stuff:)
16:36:33 <tromp> Chaitin
16:36:34 <Cheery> virus _with_ haskell or virus _for_ haskell?
16:36:53 <Cheery> virus for haskell would be simple, try out unsafeIO -stuff
16:37:02 <mib_v256971w> writing a virus with haskell
16:37:10 --- mode: ChanServ set +o allbery_b
16:37:13 <Cheery> with haskell.. that's interesting concept
16:37:14 <Adamant> besides, writing viruses is illegal in some jusrisdictions and a bad idea in others unless you know how to keep the virus from escaping, which is 1. hard and 2. something I'm pretty sure you don't know right now
16:37:55 <pastorn> allbery_b: dunno... all i want to do is to download a file through HTTP
16:38:02 <Toxaris> Adamant: interesting. how is "a virus" defined in those jurisdictions? by purpose or by behaviour?
16:38:17 <Adamant> no idea
16:38:54 <oerjan> Toxaris: probably by some legislators so incompetent that the actual definition technically includes all programs :D
16:39:03 <Toxaris> in my eyes, it's a bad idea to forbid to write certain kinds of programs. it's like "you are not allowed to think about ..."
16:39:06 <olsner> what's wrong with {-# LANGUAGE MonomorphismRestriction #-}?
16:39:23 <oerjan> olsner: sure you don't want No in front?
16:39:23 <Toxaris> oerjan: or all text files?
16:39:39 <Adamant> I don't think the program can't be written, you're just taking a risk it will get loose and be on your head if it's discovered
16:39:39 <oerjan> Toxaris: might be stretching it :D
16:39:48 <tensh> what's the real difference in http://hpaste.org/6292 ? what's the gain from using the second method
16:39:51 <tensh> ?
16:39:56 <olsner> oerjan: that's what I tried first, but only MonomorphismRestriction is listed in --supported-languages
16:40:09 <Adamant> even experienced VX'ers get infected by their own stuff sometimes.
16:40:15 <EvilTerran> olsner, i think that's an error in --supportedlanguages
16:40:30 <Cale> tensh: StateT is a monad transformer.
16:40:35 <Toxaris> tensh: StateT is a generalization of State
16:40:38 <Cale> tensh: It turns monads into other monads.
16:40:42 <olsner> I always get "cannot parse LANGUAGE pragma"
16:40:49 <tensh> Cale: ahh, I see
16:40:56 <Toxaris> tensh: StateT Identity  is  isomorphic to State, but you can use other values for m and produces other things
16:41:01 <oerjan> olsner: all can be given with No in front, i think
16:41:09 <Toxaris> tensh: e.g. StateT IO  which is like State and IO in one monad combined
16:41:14 <tensh> Toxaris: thanks, that makes it a lot clearer
16:41:32 <Cale> StateT over [] is fun :)
16:41:33 <tensh> Toxaris: so basicly it's kind of like a wrapper?
16:41:39 <Toxaris> tensh: yes exactly
16:41:40 <olsner> hmm, with a No in front of it, the point of the error has moved to the end of the line, but the same error message
16:41:44 <Cale> It's like a function on monads :)
16:41:48 <tensh> awesome
16:41:51 <Adamant> there was a college that taught virus writing as part of a security course, but they had a air-gapped media-gapped private network they were ruthless about keeping clean and which were totally wiped at the end.
16:41:56 <tensh> I've been thinking about it for a long time ;)
16:41:59 <EvilTerran> olsner, what error?
16:42:06 <Toxaris> tensh: you can use many of these transformers to add the capabilities your need and mix together exactly the monad you want
16:42:14 <olsner> EvilTerran: Inflate.hs:25:39: cannot parse LANGUAGE pragma
16:42:58 <mib_v256971w> when i say virus, not anything serious, just wanna shutdown my friends computer and do some stuff, kinda a bet
16:43:04 <EvilTerran> that's funny. {-# LANGUAGE NoMonomorphismRestriction #-} works for me
16:43:17 <EvilTerran> and that's how it's listed in Distribution.Extension
16:43:33 <tensh> Toxaris: do you any good rules of thumb for making up good combinations?
16:43:33 <Cale> Once you have the monad you want, you can then wrap that in a newtype, and use newtype-deriving to get the instances of Functor, Monad and whatever else you want. This gives you the ability to further restrict the operations that the monad transformers give you.
16:43:35 <oerjan> olsner: paste the actual first line of the file?
16:43:40 <tensh> +know
16:43:59 <Cale> Also, it gives an opportunity to reduce the amount of explicit lifting which will be needed later.
16:44:14 <mib_v256971w> can't find any notes on the unsafeIO thing
16:44:23 <Toxaris> tensh: there is a nice tutorial about monad transformers somewhere
16:44:32 <EvilTerran> mib_v256971w, knowing how to write a virus in C and knowing haskell should be enough. hardware-hacky stuff really isn't where the quirks of haskell shine.
16:44:55 <Cale> tensh: Well, layering a StateT over a list monad effectively gives you nondeterminism with a state that backtracks when the rest of the computation does. It's handy for solving puzzles or discrete optimisation problems.
16:44:56 <tromp> > exp -0.5
16:44:57 <lambdabot>   add an instance declaration for (Fractional (a -> a))
16:45:01 <olsner> copy-pasting the same set of language pragmas into a new file doesn't reproduce the message
16:45:04 <tromp> > exp (-0.5)
16:45:05 <lambdabot>  0.6065306597126334
16:45:26 <oerjan> olsner: oh wait LANGUAGE pragmas have to be first in the file
16:45:28 <tensh> Cale: ahh, I see
16:45:32 <oerjan> just noticed your line no
16:45:50 <wli> It's easy enough to encode irrational numbers of various forms. data Number = Plain Rat | Sum [(Rat, Number)] | Radical { order {- the n of the n-th root -} :: PositiveNat, radicand {- the stuff under the radical -} :: Number } ; data Rat = Rat { numerator :: Z, denom :: PositiveNat } ; data Z = Zero | NegNat PositiveNat | PosNat PositiveNat ; data PositiveNat = One | TwoN PositiveNat | TwoNPlusOne PositiveNat
16:45:53 <olsner> oerjan: but it worked for the other eight language pragmas!
16:45:56 <tensh> good you mentioned the StateT because that's the only one I have some understanding for at this moment :)
16:46:10 <Toxaris> tensh: http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
16:46:12 <lambdabot> Title: Monad Transformers Step by Step
16:46:14 <Cale> mib_v256971w: You shouldn't need it, even for a virus. unsafePerformIO is a (somewhat dangerous) way to add new features to Haskell's evaluation model.
16:46:39 <tensh> Toxaris: awesome, thanks
16:47:02 <EvilTerran> i would note, however, that neither script kiddies nor trolls seem to last here very long. :)
16:47:27 <wli> You might want to have the order be one less than the actual order of the root so that order 1 is not representible.
16:47:29 <Cale> tensh: Once you understand how monad transformers work, I have an article (http://cale.yi.org/index.php/How_To_Use_Monad_Transformers) about how best to apply them.
16:47:35 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
16:47:38 <mib_v256971w> so what do i need for a virus or to write functions that can access a computers hardware / software?
16:47:51 <EvilTerran> and you seem to be both.
16:48:14 <tensh> Cale: thanks, I'll definitely check it out later
16:48:17 <Cale> mib_v256971w: The standard IO functions should work. You might also make use of the foreign function interface API, which provides low-level access to memory.
16:48:33 <Cale> mib_v256971w: Do you already know Haskell at all?
16:48:35 <wli> Well, I forgot products, but it's obvious enough.
16:48:54 * roconnor thinks about the HIO monad from House.
16:48:59 <pastorn> @hoogle toLower
16:49:00 <lambdabot> Data.Char.toLower :: Char -> Char
16:49:26 <wli> Someoe remind me what the alternative to a specific data structure for nonempty lists is supposed to be again.
16:49:53 <Cale> wli: Lists?
16:50:11 <roconnor> (a,[a]) ?
16:50:13 <Cale> (which just happen to be nonempty)
16:50:20 <Cale> Or that.
16:50:24 <wli> Cale: There was something strange like having the constraint in the type.
16:50:38 <oerjan> olsner: LANGUAGE is a file-header pragma (see Section 8.12, .Pragmas.).
16:50:56 <oerjan> "Certain pragmas are file-header pragmas. A file-header pragma must precede the module keyword in the file. "
16:51:10 <olsner> oerjan: the only thing preceding it is language pragmas and a comment
16:51:17 <olsner> changing the comment removes the error
16:51:22 <mib_v256971w> nope, but i need a common interest to start learning
16:51:28 <mib_v256971w> thanks Cale
16:51:57 <Cale> mib_v256971w: Then I'd recommend just starting with one of the tutorials. Haskell is a very different language from most imperative or OO languages.
16:52:05 <oerjan> olsner: paste?
16:52:11 --- mode: allbery_b set -o allbery_b
16:52:12 <roconnor> mib_v256971w: http://ogi.altocumulus.org/~hallgren/ICFP2005/
16:52:13 <lambdabot> Title: A Principled Approach to Operating System Construction in Haskell
16:52:14 <oerjan> probably some syntax problem...
16:52:20 <roconnor> ``We describe a monadic interface to low-level hardware features that is a suitable basis for building operating systems in Haskell.
16:52:20 <Cale> mib_v256971w: YAHT and the Wikibook are good places to start
16:52:27 <Cale> @where yaht
16:52:27 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
16:52:30 <Cale> @where wikibook
16:52:30 <lambdabot> http://en.wikibooks.org/wiki/Haskell
16:52:56 <mib_v256971w> thanks man
16:52:57 <roconnor> ``The interface has been implemented on bare IA32 hardware using the Glasgow Haskell Compiler (GHC) runtime system.
16:53:04 <Toxaris> would a Haskell virus be able to infect a non-Haskell program? how to make it independent of the RTS?
16:53:12 <Cale> mib_v256971w: If you don't mind paying, Graham Hutton also has an excellent introduction to the language as a dead tree book.
16:53:16 <wli> There's an analogous nit centering around something akin to Either like data AtLeastOne t t' = JustLeft t | JustRight t' | Both t t'
16:53:32 <Cale> http://www.cs.nott.ac.uk/~gmh/book.html
16:53:33 <lambdabot> Title: Programming in Haskell
16:53:44 <Saizan> wli: data Empty; data NonEmpty; data List f a where Nil :: List Empty a; Cons :: a -> List x a -> List NonEmpty a
16:53:57 <Cale> If you're getting the e-book, watch out, the viewer doesn't run on Linux.
16:54:22 <hpaste>  olsner pasted "Comment causes error" at http://hpaste.org/6293
16:54:24 <idnar> data MaybeEitherWhoKnows l r = Nothing | JustLeft l | JustRight r | Both l r
16:54:55 <Toxaris> idnar: why not (Maybe l, Maybe r)?
16:54:56 <wli> idnar: Not useful; that's isomorphic to (Maybe l, Maybe r)
16:55:12 <olsner> removing the first three lines of the comment (the "hello world, etc, copyright" part) fixes the error
16:55:21 <idnar> that was tongue-in-cheek
16:55:39 <idnar> but I admit I hadn't thought of a tuple of Maybe
16:55:58 <Saizan> data List a = One a | Cons a (List a)
16:56:18 <wli> I guess there's a dual AtMostOne t t' = Neither | LeftJust t | RightJust t'
16:56:33 <oerjan> olsner: that's bizarre
16:56:33 <idnar> wli: isn't that Maybe Either t t'?
16:56:39 <olsner> oerjan: yep ;-)
16:56:48 <wli> idnar: Yeah.
16:56:49 <oerjan> no stray special characters?
16:56:56 <mib_v256971w> so this green card thing, does it work goood?
16:58:23 <Cale> mib_v256971w: I'm not sure how well-maintained it is.
16:58:28 <wli> Saizan: I typically use data NonEmptyList t = NELUnit t | NELCons t (NonEmptyList t)
16:59:03 <wli> Saizan: With corresponding Functor and Monad instances with fail left undefined.
16:59:10 <Cale> mib_v256971w: The plain FFI api is usually quite good for calling into C code, or exporting Haskell functions. If you have a lot of marshalling to do, there's a tool called c2hs which is fairly popular.
16:59:11 <oerjan> olsner: and you say it gives an error only at NoMonomorphismRestriction?
16:59:26 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffi.html
16:59:27 <lambdabot> Title: The Haskell 98 Foreign Function Interface 1.0 An Addendum to the Haskell 98 Repo ...
16:59:32 <olsner> oerjan: yep, it worked fine until I added that exact pragma
16:59:33 <Cale> that describes FFI in Haskell
17:00:00 <olsner> commenting that line also removes the error
17:00:08 <Cale> There might also be some FFI-specific tutorials hanging around...
17:00:35 <Cale> http://haskell.org/haskellwiki/FFI_Introduction
17:00:37 <lambdabot> Title: FFI Introduction - HaskellWiki
17:00:40 <Cale> http://haskell.org/haskellwiki/Blog_articles/FFI
17:00:40 <lambdabot> Title: Blog articles/FFI - HaskellWiki
17:00:44 <oerjan> olsner: better report a bug...
17:01:31 <wli> Saizan: Mutatis mutandis for MonadPlus vs. mzero and Monoid vs. mempty.
17:01:32 <olsner> minimum change to fix it seems to be to remove the two trailing periods, the comma and "8 Simon" :P
17:02:48 <Stwange> do all Turing machines operate on finite languages? The closest I can find on wikipedia is that they operate on recursively enumerable and halt if they accept, and I don't see how they could halt on an infinite language so I'm guessing they do, but I can't actually find a definition that says they do
17:03:04 <mrd> no, finite languagse are all decidable
17:03:16 <roconnor> Stwange: they operate on finite alphabets
17:03:36 <Stwange> a finite strings, but not necessarily finite languages
17:03:41 <Toxaris> Stwange: do you mean "language" in the computability theory sense?
17:03:45 <Stwange> ah yeah that makes sense.... {0,1}* is infinite
17:03:51 <mrd> indeed, but regular
17:03:52 <Stwange> yeah Toxaris
17:04:29 <mofmog> why doesn't main = putStr "CALC> " >> (getLine >>= putStrLn . showNumber . eval . readVal >> main) show a "CALC>" prompt
17:04:34 <Stwange> thanks :)
17:04:39 <mofmog> it onlpy prints CALC after the input
17:04:40 <Toxaris> Stwange: so you know that turing machines don't "operate" on languages, but "accept" languages. they can accept infinite languages because they only need to accept one word at a time...
17:04:51 <allbery_b> mofmog: need to disable buffering
17:04:55 <roconnor> mofmog: what version are you using?
17:04:59 <allbery_b> or flush before the getLine
17:04:59 <mofmog> uh latest ghc
17:05:06 <mofmog> ah ok
17:05:15 <wli> mofmog: hSetBuffering stdin NoBuffering
17:05:24 <dcoutts> mib_v256971w: I used to work for an AV company and wondered about what a virus in Haskell would look like
17:05:29 <roconnor> I thought they changed GHC to do no buffering on stdio?
17:05:44 <Stwange> thanks Toxaris
17:05:57 <mib_v256971w> well i am gonna be writing one
17:06:02 <dcoutts> mib_v256971w: I think one could write a very interesting self-modifying virus but it'd be pretty big
17:06:03 <olsner> hah! I found it
17:06:12 <wli> mofmog: hSetBuffering stdout NoBuffering rather.
17:06:23 <olsner> the 1k mark happened to fall just inside the NoMonomorphismRestriction pragma
17:06:33 <olsner> it's http://hackage.haskell.org/trac/ghc/ticket/1736
17:06:35 <mofmog> i just used hFlush stdout
17:06:36 <lambdabot> Title: #1736 (GHC doesn't spot OPTIONS_GHC pragmas after 1k of comments) - GHC - Trac
17:06:44 <mofmog> ugh
17:07:14 <fracture> noob question:
17:07:19 <Toxaris> olsner: crazy...
17:07:19 <dcoutts> mib_v256971w: I'd have it use a dissasembler to break the binary down into basic blocks then lay the basic block graph out again in a different order, and rearange the dependency graph within each basic block and apply various other identity transformations
17:07:23 <mib_v256971w> i heard about wxhaskell, can be used to write like a notepad like the boring old one in windws
17:07:23 <fracture> how do I get the sqrt of a integer as an integer?
17:07:32 <fracture> tried (floor $ sqrt x) but no dice...
17:07:37 <wli> mofmog: hFlush stdout after putStr "CALC> " might help, as well as hSetBuffering stdin LineBuffering or hSetBuffering stdin NoBuffering (depending on how conservative you want to be).
17:07:47 <dons> "    *  the Clean Compiler
17:07:47 <dons> We are adding a new front-end to the Clean compiler that will accept Haskell '98 source code.
17:07:48 <mrd> > floor $ sqrt 4
17:07:49 <lambdabot>  2
17:07:49 <roconnor> fracture: do you want it to work on large integers?
17:07:50 <dons> Good news for many people, we hope.
17:07:52 <dons> Not only there will be another Haskell '98 compiler, which should be one that compiles fast and produces efficient code. "
17:07:59 <fracture> yeah
17:08:07 <dcoutts> dons: that'd make for an interesting comparison
17:08:08 <Yaroslv1> is there a nice intro to Haskell's basic structural functions somewhere? (ie, nest, fold, etc)
17:08:17 <roconnor> fracture: as far as I know, such an operation isn't part of the standard library :(
17:08:23 <fracture> oh
17:08:26 <hpaste>  mofmog pasted "Error with compound statements" at http://hpaste.org/6294
17:08:29 <mib_v256971w> seens like u have a wide knowledge of viruses dcoutts
17:08:29 <dcoutts> dons: hopefully we can get the backend improved enough first :-)
17:08:34 <mofmog> so um
17:08:35 <mrd> :t floor $ sqrt 4
17:08:36 <lambdabot> forall b. (Integral b) => b
17:08:41 <dcoutts> mib_v256971w: I did work for an AV company
17:08:45 <mofmog> my calc program sort of dies whenever i use a compound statement
17:08:45 <mrd> :t floor . sqrt
17:08:46 <lambdabot> forall b a. (Floating a, Integral b, RealFrac a) => a -> b
17:08:57 <mrd> :t floor . sqrt . fromIntegral
17:08:59 <lambdabot> forall b a. (Integral a, Integral b) => a -> b
17:09:00 <mofmog> or a list for that matter
17:09:15 <mrd> how about that, fracture?
17:09:27 <roconnor> fracture: as mrd illustrates  floor . sqrt . fromIntegral $ x will work for relatively small integers
17:09:37 <fracture> doesn't work in this situation, but not sure why
17:09:41 <roconnor> fracture: but to goes via floating point.
17:10:01 <mib_v256971w> so can wxhaskell write a boring old notepad or not
17:10:05 <mib_v256971w> ???
17:10:10 <roconnor> @go haskell integer square-root
17:10:11 <mofmog> more specifically: Stack space overflow: current size 8388608 bytes.
17:10:11 <mofmog> Use `+RTS -Ksize' to increase it.
17:10:11 <lambdabot> http://www.codecodex.com/wiki/index.php?title=Calculate_an_integer_square_root
17:10:11 <lambdabot> Title: Calculate an integer square root - Find and Write Source Code at CodeCodex
17:10:18 <Toxaris> mib_v256971w: I would think so, but I didn't try
17:10:44 <wli> mofmog: Something like main = hSetBuffering stdin LineBuffering >> let repl = putStr "CALC> " >> hFlush stdout >> (getLine >>= putStrLn . showNumber . eval . readVal >> repl) in repl
17:10:51 <mofmog> i dont think that part is the problem
17:11:02 <mofmog> but ill give it a shot
17:11:04 <roconnor> ugh, don't use that haskell function form codecodex!
17:11:11 <roconnor> how awful
17:11:29 <mib_v256971w> oh
17:11:30 <fracture> ugh
17:11:31 <fracture> that works
17:11:35 <fracture> but yes, awful..
17:12:38 <wli> mofmog: I'd probably write it as something like main = do hSetBuffering stdin LineBuffering ; repl where repl = do putStr "CALC> " ; hFlush stdout ; s <- getLine ; putStrLn . showNumber . eval $ readVal s ; repl
17:13:55 <Toxaris> mofmog: have you checked that your parser works correctly?
17:14:30 <soto> Can anyone give me a high level comparison of Haskell HTML scrapers compared to, say, Ruby's Hpricot?
17:14:33 <roconnor> fracture: there is a function I know from: http://darcs.augustsson.net/Darcs/CReal/CRealI.hs
17:14:47 <roconnor> floorsqrt :: Integer -> Integer
17:14:47 <roconnor> floorsqrt x = until satisfy improve x
17:14:47 <roconnor>               where improve y = floor ((y*y+x)%(2*y))
17:14:47 <roconnor>                     satisfy y = y*y <= x && x <= (y+1)*(y+1)
17:14:54 <Toxaris> mofmog: I'm not sure about the mutual recursion of parseList and parseVal
17:15:08 <roconnor> however I have no licence for you to use it
17:15:27 <mofmog> Toxaris: nope!
17:15:38 <mofmog> i think that might be the source of the trouble
17:16:13 <roconnor> hmm floor ((y*y+x)%(2*y)) is kinda inefficent
17:16:23 <mofmog> well let's step through (+ 2 2)
17:16:30 <roconnor> I'd do ((y*y+x)`div`(2*y))
17:16:47 <Cale> soto: I don't know anything about Hpricot, so I can't really give a comparison there, but there are HXT and HaXml for parsing and working with XML (and HTML)
17:16:52 <allbery_b> parseNumber vs. parseList?  sae that one myself
17:16:53 <wli> roconnor: floor $ (y + (x/y)) % 2 ?
17:17:18 <roconnor> @check \x y -> (x`div`y) == floor (x%y)
17:17:19 <lambdabot>  Exception: divide by zero
17:17:31 <roconnor> @check \x y -> y/=0 ==> (x`div`y) == floor (x%y)
17:17:31 <lambdabot>  OK, passed 500 tests.
17:17:36 <Cale> soto: There's also a TagSoup library which does much less actual analysis, but might be useful for certain kinds of applications, as it can process the HTML as a stream, and keep memory usage down.
17:17:44 <roconnor> wli: % does a gcd
17:17:58 <mofmog> ( => + 2 2) => (Operat 2) (Number 2) (Number 2) => ) => [Operat 2, Number 2, Number 2]
17:17:58 <roconnor> which is kinda expensive
17:18:00 <mofmog> or at least
17:18:02 <mofmog> that's what it should do
17:18:03 <mofmog> huh
17:18:14 <wli> roconnor: Well, maybe slower than div, but sure.
17:18:19 <roconnor> especially when you are just going to do a div anways
17:18:52 <soto> Cale: Thanks I have a list from haskell.org and have seen your suggestions. I was just wondering how 'productive' they are.
17:19:06 * allbery_b looks again and goes "duh"
17:19:22 <soto> Cale: HXT and HaXml are higher level than tagsoup?
17:19:29 <roconnor> fracture: maybe if you replace improve y with ((y*y+x)`div`(2*y)), then you can use it for free :)
17:19:41 <fracture> heh ;)
17:19:46 <soto> Cale: (What exactly do you mean by doing less analysis?)
17:19:46 <allbery_b> mofmog: parseVal can invoke parseList, which as its first action will invoke parseVal.  this is an infinite loop
17:19:51 <fracture> I think I'm actually reworking this without a sqrt (not sure yet)
17:19:57 <Cale> soto: Yeah, they actually do verification and build a tree of the XML
17:19:58 <allbery_b> which will run out of stack
17:20:06 <roconnor> fracture: that could be good
17:20:07 <fracture> interesting stuff though
17:20:20 <roconnor> The sad thing is that GMP's square root ought to be exposed.
17:20:33 <mofmog> allbery: but the second parseval shouldn't invoke parseList again unless there is another list inside
17:20:48 <Cale> soto: which is then manipulated using various combinators (say, for finding all the A tags, for example, and then applying some other transformation on them)
17:21:16 <mofmog> unless parsec <|> means "try ALL of these"
17:22:11 <Toxaris> mofmog: parsec's <|> means "try them one after another until you find the first which seems to work"
17:22:13 <soto> Cale: Can you recommend one of the other?
17:22:13 <Cale> soto: Or, for instance, finding all the A tags which are immediately inside SPAN tags having a given class.
17:22:24 <allbery_b> mofmog:  but if you have an undelimited list, there is no way to distinguish whether a b c is a single list or two lists
17:22:30 <allbery_b> in the parser
17:22:49 <mofmog> well that's why i have oneOf "(" there i guess
17:22:55 <Cale> soto: I don't have any real experience with HaXml or TagSoup, but I've used HXT, and that was great, if a little bewildering at first.
17:23:01 <mofmog> unless that doesnt really detect the ()'s\
17:23:04 <soto> Cale: Thanks.
17:23:16 <allbery_b> but that comes *after* the bare parseList
17:23:18 <Toxaris> mofmog: you could delete the "<|> parseList" line. what is it good for?
17:23:33 <allbery_b> (also, you want `char '('', not `oneOf "("')
17:23:36 <mofmog> oh
17:23:36 <mofmog> haha
17:23:39 <mofmog> ok that was utterly retarded
17:23:45 <mofmog> i need rest
17:24:45 <mofmog> YES
17:24:45 <Toxaris> mofmog: the parser never reaches the "oneOf "(", because the endless loop parseList <-> parseVal is entered before oneOf "(" is tried
17:24:46 <mofmog> it works
17:24:48 <mofmog> perfectly
17:24:51 <mofmog> yeah i saw
17:25:05 <mofmog> i thought you meant the parseList INSIDE the do statement
17:25:06 <mofmog> sorry sorry
17:25:52 <Toxaris> mofmog: there are not statements :) even do-expressions are expressions
17:26:27 <mofmog> wow
17:26:37 <mofmog> thanks for sticking with me guys it works like how i wanted it to work now
17:26:38 <mofmog> ^_^
17:26:52 <hpaste>  lament pasted "No instance for (Num a)" at http://hpaste.org/6295
17:26:58 <allbery_b> that's what we're here for
17:27:18 <lament> can somebody look at my paste? i don't get how class context declarations work
17:27:18 <Toxaris> lament: you misunderstood context clauses in data declarations
17:27:31 <Toxaris> lament: they are useless
17:27:59 <lament> but but but
17:29:07 <Cale> lament: The Num constraint on the data declaration only constrains the type of the Foo constructor.
17:29:24 <Cale> lament: It doesn't actually let you carry instances around in the values.
17:29:32 <Cale> (as it should)
17:29:48 <Cale> GHC has an extension which will let you do this (6.8)
17:29:57 <Cale> data Foo a where
17:30:04 <Cale>    Foo :: (Num a) => a -> Foo a
17:30:13 <Cale> Will actually mean what you want it to.
17:30:28 <lament> this kinda seems like a bug in haskell :)
17:30:41 <allbery_b> to you and many others
17:30:43 <roconnor> lament: i'm pretty sure you are right.
17:30:44 <Cale> Yep
17:31:25 * lament tries with extension
17:32:14 <Cale> It's explicitly referred to as the "stupid context" in the GHC source code.
17:32:47 <lament> oh, i don't even have ghc 6.8, laame.
17:32:50 <redleafgr> well-described
17:33:33 <lament> Cale: but the extension actually seems like the constraint is only on foo constructor, and not on the whole type
17:33:47 <Cale> dcStupidTheta :: ThetaType
17:33:57 * gwern is the one?
17:33:58 <gwern> http://cdsmith.files.wordpress.com/2008/03/lambda_field.png  <-- I can see the lambdas
17:34:11 <Cale> (a field of the MkData constructor of the DataCon type)
17:34:21 <lament> Cale: and it seems like a constraint on the _type_ is what i actually want
17:34:33 * Cale is stereoblind, and so stereograms don't work for him.
17:34:49 <chris2> gwern: neeeeat
17:34:57 <gwern> Cale: weird. how did that happen?
17:35:00 <roconnor> no 3-D movies for cale.
17:35:02 <gwern> I've never heard of being stereoblind
17:35:03 <Cale> lament: There's no way to constrain the kind of the type constructor.
17:35:06 <idnar> stereoscopic image?
17:35:10 <idnar> ah, yes
17:35:24 <redleafgr> a lambda footprint
17:35:26 <redleafgr> nice
17:35:28 <Cale> gwern: I don't know. Something broken about the way my brain processes the data from my eyes.
17:36:04 <lament> i guess it all makes sense. I don't like how there's standard haskell, and usable haskell (ghc).
17:36:17 <gwern> Cale: but stereoblindness according to WP is more general. do you not have depth perception?
17:36:25 <roconnor> lament: haskell prime is supposed to solve this problem
17:36:43 <allbery_b> H98 is usable, just requires more work.  ISTR Oleg showing how to do this in H98
17:36:45 <Cale> gwern: That's right. I have to infer depth from other cues.
17:36:58 <Cale> gwern: (Like shadows and size)
17:37:06 <lament> hmm
17:37:07 <allbery_b> huh.  I often have trouble with stereograms but that's a different issue
17:37:21 <hpaste>  (anonymous) annotated "No instance for (Num a)" with "one option" at http://hpaste.org/6295#a1
17:37:28 <lament> i have no doubt that oleg can do anything
17:37:57 <lament> once he implemented scheme in scheme... in the type system
17:37:59 <gwern> ?olegfacts
17:37:59 <lambdabot> Unknown command, try @list
17:38:09 <gwern> ?oleg
17:38:09 <lambdabot> Defined.
17:38:13 <allbery_b> heh
17:38:20 <Cale> Oleg can bend spoons with his mind, in the type system, in Haskell 98.
17:38:35 <gwern> Cale: how terrible. so I guess stuff like archery is out for you then
17:38:48 <gwern> http://cdsmith.files.wordpress.com/2008/03/chess_field.png <-- I see it, I just have no idea what it is
17:38:52 <Cale> gwern: Yeah, pretty much.
17:38:58 <dons> anyone else getting -cafe@ mail today?
17:39:16 <Cale> gwern: It might explain why I spend all my time staring at 2-dimensional objects.
17:39:23 <gwern> dons: I've gotten some
17:39:24 <Cale> (like monitors)
17:39:44 <gwern> Cale: compensating for your disadvantages is a smart thing to do
17:39:59 <shepheb> @remember Cale Oleg can bend spoons with his mind, in the type system, in Haskell 98.
17:39:59 <lambdabot> Done.
17:40:06 <gwern> @quote Oleg
17:40:06 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
17:40:37 <shepheb> @quote duck
17:40:37 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
17:40:40 <idnar> heh
17:40:40 <allbery_b> my eyes don't quite point the same place, so for nearby stuff (like stereograms) I have trouble seeing them, but for distance viewing the effect is minimal
17:40:45 <Cale> On the other hand, I have comparatively little trouble picturing 4 and higher-dimensional objects.
17:40:52 * shepheb 's shot in the dark fails.
17:40:58 <Cale> Infinite dimensional is a bit difficult still though.
17:42:30 <gwern> what hackage category makes sense for a theorem prover, hm..
17:42:56 <Plouj> oh my gosh, I just figured out these exercises by accident: http://paste.lisp.org/display/57221
17:42:59 <gwern> Math maybe
17:43:02 <Plouj> oops
17:43:22 <gwern> ?hpaste
17:43:22 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:43:56 <Cale> Plouj: Your solution using do-notation doesn't.
17:43:57 <hpaste>  Plouj pasted "exercises" at http://hpaste.org/6296
17:43:59 <hpaste>  (anonymous) annotated "No instance for (Num a)" with "(no title)" at http://hpaste.org/6295#a2
17:44:10 <Cale> Plouj: ah, there you go :)
17:44:53 <Plouj> but I feel so bad because I got it by accident and don't really know why it works all that well
17:45:02 <dmwit> That last one doesn't look right.
17:45:13 <Plouj> humm
17:45:19 <Plouj> maybe I pasted the wrong code!
17:45:19 <dmwit> You probably want "many1 digit >>= return . Number . read".
17:45:22 <Plouj> see, I can't even tell
17:46:25 <hpaste>  Plouj annotated "exercises" with "exercises" at http://hpaste.org/6296#a1
17:46:35 <Cale> If you write  x >>= return . f, you should usually turn that into  fmap f x
17:46:45 <dmwit> Plouj: Yeah, that looks better. =)
17:46:53 <Plouj> humm
17:47:04 <dmwit> But I agree that the original "liftM" version is nicer to read.
17:47:04 <Plouj> so I can get rid of that lambda function, eh dmwit
17:47:18 <Plouj> I think I should get rid of the lambda function because the tutorial hasn't taught me that yet
17:47:20 <dmwit> Plouj: Yes, but then the ($) has to turn into a (.).
17:47:58 <Plouj> cool
17:48:09 <Cale> Or if you have a composition following a bind, another good option is to use the flipped over version of bind:
17:48:21 <Cale> return . Number . read =<< many1 digit
17:48:22 <glen_quagmire> i prefer do notation because it looks like C code and makes me feel like i'm in charge.
17:49:09 <dmwit> I prefer do notation only when there are a lot of bindings, or some binding gets used a lot of times.
17:49:30 <Toxaris> > do { let x = "hello"; let y = "world"; return $ x ++ " " ++ y } $ undefined
17:49:30 <lambdabot>  Parse error at "let" (column 23)
17:50:05 <Plouj> lol, tell me none of this because it confuses me!
17:50:11 <Toxaris> > do { let {x = "hello"}; let {y = "world"}; return $ x ++ " " ++ y } $ undefined
17:50:12 <lambdabot>  "hello world"
17:50:15 <dmwit> > do { let { x = "hello"; y = "world" }; return $ x ++ " " ++ y } $ undefined
17:50:15 <lambdabot>  "hello world"
17:50:34 <Plouj> I'm still at the excercises section of http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
17:50:37 <lambdabot> http://tinyurl.com/2yojoc
17:50:40 <Toxaris> dmwit: yeah figured that out, but my version is more like c :9
17:50:45 <dmwit> =)
17:51:05 <dmwit> I was just trying to see if I could get it to run; don't think of it as me trying to one-up you. =P
17:51:20 <hpaste>  lament annotated "No instance for (Num a)" with "Oleg's solution for haskell98" at http://hpaste.org/6295#a3
17:51:36 <lament> Oleg is a nut.
17:56:24 * pastorn is implementing ID3 in haskell
17:56:42 <pastorn> so i have data Tag = Tag { artist :: String ...}
17:56:44 <dons> pastorn: cool
17:56:50 <pastorn> but how do i do with years
17:57:16 <pastorn> i haven't looked at the ID3 documents yet, but i'm guessing it's 4 x Word8
17:57:28 <dons> probably nice to prevent a Haskellish type though
17:57:42 <pastorn> and type Year = Y Word8 Word8 Word8 Word8 seems stupid
17:57:48 <dons> yeah
17:57:55 <dons> won't scale :)
17:58:11 <pastorn> how do i force it to 4 bytes?
17:58:48 <tromp> Year = Y Word32 :)
17:58:52 <pastorn> haha
17:58:57 <pastorn> tromp: you're awesome
17:59:23 <pastorn> Words are treated as unsigned, right?
17:59:32 <dcoutts> Word32 vs Int32
17:59:37 <tromp> the others are Int32 ...
17:59:42 <pastorn> ??
17:59:48 <tromp> yes
17:59:50 <pastorn> @hoogle 32
17:59:50 <lambdabot> Hoogle Error: Parse Error: Unexpected character '32'
17:59:54 <pastorn> @hoogle Word32
17:59:54 <lambdabot> Data.Word.Word32 :: data Word32
17:59:57 <tromp> Words are unsigned
17:59:58 <pastorn> @hoogle Int32
17:59:58 <lambdabot> Data.Int.Int32 :: data Int32
18:00:02 <pastorn> oh, ok
18:00:17 <pastorn> well, negative years... is that something one would use
18:00:35 <pastorn> pre-christ musical recordings are probably quete rare
18:00:47 <pastorn> *quite*
18:01:31 <pastorn> > (maxBound :: Int, maxBound :: Int32, maxBound :: Word32)
18:01:32 <lambdabot>  (2147483647,2147483647,4294967295)
18:01:36 <mrd> my year system is in the negative -- years until haskell takes over the world
18:01:51 <idnar> mrd: what year is it currently?
18:02:05 <mrd> i don't know, but it's definitely BH
18:02:05 <sebell> mrd: Might need Int64 for that
18:02:32 <pastorn> shit... i'll need to make an int -> word32 function with bitshifting...
18:02:35 <pastorn> or something
18:03:09 <mrd> :t fromIntegral :: Int -> Word
18:03:10 <lambdabot> Int -> Word
18:03:22 <pastorn> i'll need bitwise or and to do << 8
18:03:30 <mrd> @doc Data.Bits
18:03:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/4/Data-Bits.html
18:03:31 <glen_quagmire> > (1 :: Word32) + 2
18:03:32 <lambdabot>  3
18:03:33 <pastorn> this is gonna hurt
18:03:40 <glen_quagmire> > (1 :: Word32) - 2
18:03:41 <lambdabot>  4294967295
18:03:57 <pastorn> http://haskell.org/ghc/docs/latest/html/libraries/4/Data-Bits.html <-- 404
18:03:59 <mrd> pastorn: fromIntegral will convert between integral types too
18:04:04 <lambdabot> http://tinyurl.com/2tboc9
18:04:07 <idnar> > fromIntegral (5 :: Int) :: Word32
18:04:08 <lambdabot>  5
18:04:30 <pastorn> mrd: i don't want converting, i want to have 4xWord8 to represent years
18:04:45 <glen_quagmire> pastorn: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
18:04:46 <lambdabot> http://tinyurl.com/vdtn4
18:05:05 <pastorn> so in a word32 the first 8 bits would be one number, then next 8 the next number and so on
18:05:19 <mrd> use shiftL and .|.
18:05:23 <glen_quagmire> (1 :: Word8, 0 :: Word8, 0 :: Word8, 0 :: Word8)   ?
18:05:56 <glen_quagmire> or,  data Year = Year [Word8]   provide accessor functions
18:06:00 <sebell> Why???
18:06:16 <glen_quagmire> maybe make it into monad and arrow and other professional stuff
18:06:19 <pastorn> then again... being unable to force type sizes seems kinda stupid
18:06:29 <pastorn> or am i missing some really good point?
18:06:58 <glen_quagmire> how do you write type Year to binary file?
18:06:58 <mrd> wouldn't Data.Binary have a nice instance for Word32
18:07:04 <mrd> bigendian i suppose
18:07:10 <pastorn> glen_quagmire: i will be using HTTP-Simple in this project... professional isn't really what i'm looking for
18:07:28 <glen_quagmire> in that function, figure out that year field is always set to proper size, endian, word algined, network safe...etc
18:08:04 <glen_quagmire> does haskell have serialize?
18:09:00 <pastorn> or maybe i can have som initTag with (year = mkEmptyArray 4)
18:09:31 <pastorn> this is getting out of hand...
18:10:10 <Toxaris> pastorn: shouldn't you represent the information with a suitable Haskell type (e.g. Int) and convert it to ID3 format during serialization?
18:10:28 <glen_quagmire> haskell needs beans, serialize, thread monitor, object factory, patterns..etc
18:10:45 <mrsolo> right..
18:11:00 <glen_quagmire> then researchers willl move onto other language
18:11:01 <Zao> glen_quagmire needs a Java debrainwashing, it sounds to me :)
18:11:19 <pastorn> Toxaris: that's ONE way to do it - but it's not the right way
18:11:27 * pastorn is unreasonably stubborn
18:11:42 <sebell> pastorn: Data.Binary comes with quite a few instances
18:11:44 * mrsolo agrees with zao
18:12:07 <glen_quagmire> i think monad is JavaBeans. same pattern so that libraries can communicate
18:12:12 * wli ponders type-level arithmetic for arrays for the linear algebra stuff needed.
18:12:15 <sebell> pastorn: What is the ID3 representation of a year?
18:12:25 <pastorn> whut?
18:13:38 <pastorn> sebell: i actually haven't gotten that far, this discussion is more spawned from curiosity than need
18:14:12 <sebell> pastorn: So why would you be inclined to use a ridiculous representation like [Word8]?
18:14:19 <Cale> glen_quagmire: Not quite the same thing, but yeah, I suppose the ideas are related. Basically, give libraries a common interface so that a polymorphic API of common functions can work in the context of any one of them.
18:15:21 <glen_quagmire> my to be written monad tutorial will compare it to JavaBeans haha
18:15:50 <pastorn> sebell: how would you represent the YEAR field in a tag like ID3 then?
18:15:58 <EvilTerran> my planned monad tutorial wil compare them to cardboard box forts
18:16:28 <lament> my plannet monad tutorial will compare them to group sex
18:16:31 <lament> *planned
18:16:41 <glen_quagmire> my monad tutorial will explain all secretes of the universe and more
18:16:48 <Cale> One difference between our monadic approach and JavaBeans is that saying that the Java language (as far as I know) has no explicit representation of that fact, and there are no APIs which work in a standard way across all JavaBeans (apart from perhaps Serializable, but that's another thing)
18:16:49 <gwern> I intend to write a monad tutorial where you write functions by planning a real time strategy game. which I intend to write
18:16:53 <pastorn> why can's someone make a haskell tutorial like that ruby comic?
18:17:02 <sebell> pastorn: If I wanted to use 4 bytes, I would use a standard unsigned integer across those 4 bytes. (IE: Word32)
18:17:07 <EvilTerran> lament, intimidating at first, but fun and educational once you get into the swing of it?
18:18:10 * pastorn ignores this for a while and tries to get cabal working instead...
18:19:57 <glen_quagmire> is monadic generalization different from generic functions?
18:20:58 <Toxaris> glen_quagmire: what are you talking about?
18:21:32 <glen_quagmire> i think typeclass is more powerful than monads. using a typeclass, i can give the class more operations where monads allow me only 2 operations: return, >>=
18:21:48 <EvilTerran> ...what
18:22:06 <glen_quagmire> oh darn i need to go bakc and read monad tutorial
18:22:22 <pastorn> @hoogle Ord a => [a] -> [a]
18:22:22 <lambdabot> Data.List.sort :: Ord a => [a] -> [a]
18:22:22 <lambdabot> Data.List.insert :: Ord a => a -> [a] -> [a]
18:22:22 <lambdabot> Prelude.tail :: [a] -> [a]
18:22:40 <Toxaris> glen_quagmire: well, Monad *is* a typeclass
18:22:43 <glen_quagmire> monad is the only typeclass that has special syntax for it: do notathin
18:22:49 <roconnor> @src monad
18:22:49 <lambdabot> Source not found. Just what do you think you're doing Dave?
18:22:53 <roconnor> @src Monad
18:22:54 <lambdabot> class  Monad m  where
18:22:54 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
18:22:54 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
18:22:54 <lambdabot>     return      :: a -> m a
18:22:54 <lambdabot>     fail        :: String -> m a
18:23:19 <Toxaris> glen_quagmire: there is also Enum, Arrow, that new thing about Strings, MonadFix, ...
18:23:40 <pastorn> best implementation EVAR: isMP3 fp = map toLower (take 4 (reverse fp)) == "3pm."
18:24:16 <glen_quagmire> i think i can't finish my monad tutorial tonight.
18:24:30 <dibblego> pastorn, what are you writing?
18:24:46 <pastorn> @paste
18:24:46 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:25:13 <Toxaris> glen_quagmire: you are right, it is important to see that Monad is just *one* typeclass, and there are other ones, and sometimes you need to define your own. some of the perceived benefits of monads are in reality benefits of typeclasses
18:26:33 <glen_quagmire> if users can add new syntax for their typeclass, it might be chaotic or good
18:26:50 <Toxaris> pastorn: are you aware of Data.List.isSuffixOf?
18:27:08 <Toxaris> glen_quagmire: I think it would be great!
18:27:12 <roconnor> arrows got their own syntax.
18:27:34 <glen_quagmire> <?phpMonad if ( 1 == "1" ) echo "hello"; ?>
18:27:52 <gnuvince_> > let isMP3 f = map toLower (take 4 (reverse fp)) == "3pm." in isMP3 "foo.mp3"
18:27:55 <lambdabot>   Not in scope: `fp'
18:28:03 <gnuvince_> > let isMP3 f = map toLower (take 4 (reverse f)) == "3pm." in isMP3 "foo.mp3"
18:28:04 <lambdabot>  True
18:28:28 <hpaste>  pastorn pasted "dischogs" at http://hpaste.org/6297
18:29:21 <mux> it seems lambdabot from darcs needs Data.Number.Symbolic from the numbers package but it doesn't enforce the dependency
18:29:59 <pastorn> Toxaris: no, but this is just a VERY temporary implementation... it will likely be :: FilePath -> IO Bool later on
18:30:22 <pastorn> (as in ACTUALLY checking the file)
18:31:16 <Toxaris> pastorn: shouldn't the user provide a pattern for the files to be processed?
18:31:25 <Toxaris> pastorn: with "*.mp3" as a sensible default
18:31:49 <roconnor> let isMP3 f = System.FilePath.takeExtension f == ".mp3"
18:31:51 <pastorn> Toxaris: did i mention that i started making this about 2 hours ago?
18:32:20 <pastorn> all in due time...
18:32:29 <roconnor> let isMP3 f = map toLower (System.FilePath.takeExtension f) == ".mp3"
18:33:13 <Toxaris> pastorn: keep cool, I'm just proposing things :) did you consider a graphical interface which renders the mp3 contents as 3d animations while processing?
18:33:15 <pastorn> @hoogle takeExtension
18:33:16 <lambdabot> System.FilePath.Windows.takeExtension :: FilePath -> String
18:33:16 <lambdabot> System.FilePath.Posix.takeExtension :: FilePath -> String
18:33:16 <lambdabot> System.FilePath.Windows.takeExtensions :: FilePath -> String
18:33:24 <Toxaris> pastorn: ;)
18:33:55 <pastorn> Toxaris: yes, that's next on my todolist, right before imlementing f :: FilePath -> IO Tag
18:37:20 <mux> does anyone know how runplugs actually works? in RunPlugs.hs it generates an import list referencing various modules from external packages, but then at run time I have a linker error suggesting it didn't pass the appropriate -package flags
18:37:24 <mux> ie:
18:37:26 <mux> runplugs: /tmp/MsFTK39781.o: unknown symbol `__stginit_oeiszm0zi1_MathziOEIS_'
18:37:26 <mux> runplugs: user error (resolvedObjs failed.)
18:37:48 <mux> the OEIS package is installed and working fine
18:38:50 <whee> mux: I have a similar problem, except it complains about a bytestring symbol :|
18:39:28 <mux> which one?
18:39:47 <mux> mmm, this is weird, I see the -package oeis in the code actually
18:39:52 <mux> no -package numbers though
18:40:03 <whee> I don't have the error handy, it's an install at work
18:40:21 <whee> I've tried recompiling every package that cabal installed and no luck
18:41:35 <gwern> good news, everyone! folkung, equinox, and paradox are now on hackage!
18:42:59 * dolio is getting stonewalled by Agda's type system.
18:44:25 <scriptdevil> i just tried a crazy line and it was accepted by the repl. The statement was 'let a:[] = take 4 [1,3..]'
18:44:38 * shepheb imagines a "The PACKAGER" superhero persona for gwern. reaches into his .cabal belt, packages the bad guys, and uploads them to a cell.
18:44:43 <scriptdevil> how does this work? what is a's type?
18:45:15 <EvilTerran> a :: Num a => a
18:45:24 <EvilTerran> a:[] is exactly the same as [a]
18:45:38 <allbery_b> scriptdevil: it's pattern matching
18:45:49 <Lemmih> scriptdevil: It only works because Haskell is lazy.
18:45:52 <EvilTerran> take 4 [1,3..] = [1,3,5,7]
18:46:19 <jleedev> > let [a] = take 4 [1,3..] in a
18:46:19 <lambdabot>   Irrefutable pattern failed for pattern [a]
18:46:21 <allbery_b> ah, yes, and it's lazy, so only if you use a will it report the pattern match failure
18:46:37 <scriptdevil> yeah.. thats what i got :(
18:46:38 <EvilTerran> what you wrote is the same as "let [a] = [1,3,5,7]" - equivalently, "let a:[] = 1:3:5:7:[]", or "let (a, []) = (1, [3,5,7])"
18:47:18 <EvilTerran> it only actually works out if the pattern matches when it's forced to evaluate a
18:47:50 <EvilTerran> > let (a, []) = (1, [3,5,7]) in a -- is this one the same? i'm not sure, suddenly
18:47:51 <lambdabot>   Irrefutable pattern failed for pattern (a, [])
18:47:54 <EvilTerran> cool
18:48:07 <glen_quagmire> > let (undefined, a) = (undefined, 1)  in a
18:48:07 <lambdabot>  1
18:48:19 <Cale> > let (a,~[]) = (1,[3,5,7]) in a
18:48:19 <lambdabot>  1
18:48:26 <EvilTerran> glen_quagmire, bear in mind that that one's re-binding "undefined" to a circular reference
18:48:32 <EvilTerran> as let{} is recursive definitions
18:48:49 <glen_quagmire> > let (_, a) = (undefined, 1)  in a
18:48:50 <lambdabot>  1
18:48:54 <EvilTerran> > let a : ~[] = [1..] in a
18:48:55 <lambdabot>  1
18:49:08 <glen_quagmire> does ~[] mean any list?
18:49:18 <Cale> ~[] matches any list
18:49:22 <EvilTerran> the ~ puts off matching of part of a pattern until one of the variables in that part of the pattern is evaluated
18:49:25 <Cale> It's equivalent to _
18:49:27 <scriptdevil> well.. i was actually trying to write a substring comparer...  So i did something like this checkSub x a:x:b = checkSub x b : x : [].. It puts all the repeat substrings.. I did the terminating conditions too.
18:49:38 <EvilTerran> so, yes, ~({anything with no variables}) is just the same as _
18:50:18 <EvilTerran> scriptdevil, er, you can't use the same variable twice in one pattern-match.
18:50:37 <EvilTerran> also, i hope you mean "checkSub x (a:x:b) = ..."
18:50:46 <scriptdevil> EvilTerran: make it  x and y in the
18:50:49 <gwern> (http://www.cs.chalmers.se/~bringert/darcs/ <-- oh god, I'm never going to finish packaging stuff am I)
18:50:50 <lambdabot> Title: Index of /~bringert/darcs
18:50:51 <EvilTerran> (well, not, because of the repeated (x)s, but it's a bit closer to right ;])
18:50:53 <scriptdevil> EvilTerran: yep
18:50:57 <mrsolo> perfomance wise, is there a difference between take 4 [1..] and say take 4 [1..10]?
18:51:04 <scriptdevil> i did not paste what i wrote.. :)
18:51:06 <mrsolo> s/difference/huge difference/
18:51:11 <Cale> mrsolo: No.
18:51:13 <allbery_b> shouldn't be
18:51:13 <EvilTerran> mrsolo, not a significant one, no
18:51:20 <EvilTerran> if anything, the first will be a little better
18:51:22 <Cale> mrsolo: In fact, [1..] is probably faster
18:51:28 <mrsolo> why is that?
18:51:36 <scriptdevil> mrsolo: haskell is lazy
18:51:36 <EvilTerran> because it saves a check to see if it's done for each cell
18:51:38 <allbery_b> no terminating check?
18:51:38 <scriptdevil> :P
18:51:40 <Cale> mrsolo: Because it doesn't have to test the end of list condition every time
18:51:41 <Toxaris> I would say that take 4 [1..] should be a lot fastser
18:52:00 <Toxaris> counter + increment  vs  counter + increment + comparision
18:52:00 <mrsolo> ah
18:52:07 <EvilTerran> > dropWhile (<10^6) [0..]
18:52:08 <Cale> Not significantly. It's only getting 4 elements :)
18:52:08 <lambdabot>  [1000000,1000001,1000002,1000003,1000004,1000005,1000006,1000007,1000008,100...
18:52:11 <mux> yay
18:52:11 <EvilTerran> > dropWhile (<10^12) [0..]
18:52:11 <Toxaris> that's 30% extra work
18:52:15 <lambdabot> Terminated
18:52:15 <mux> I seem to have a working workaround
18:52:18 <EvilTerran> > dropWhile (<10^9) [0..]
18:52:22 <lambdabot> Terminated
18:52:26 <EvilTerran> > dropWhile (<10^7) [0..]
18:52:29 <lambdabot>  [10000000,10000001,10000002,10000003,10000004,10000005,10000006,10000007,100...
18:52:35 <EvilTerran> > dropWhile (<10^7) [0..10^8]
18:52:38 <lambdabot>  [10000000,10000001,10000002,10000003,10000004,10000005,10000006,10000007,100...
18:52:49 <Toxaris> or 50% extra work?
18:52:52 <EvilTerran> hm. i'll fiddle with this in private, see if i can find the sweet spot :P
18:52:52 <Toxaris> whatever
18:53:14 <mux> I needed that to have runplugs working :
18:53:17 <mux> -                         ")") context ["-O","-fasm","-fextended-default-rules","-package oeis"] [] []
18:53:20 <mux> +                         ")") context ["-O","-fasm","-fextended-default-rules"] ["/usr/home/mux/.ghc/i386-freebsd-6.8.2/package.conf"] []
18:53:38 <mux> it seems unsafeEval_ wouldn't find the user-installed packages otherwise
18:54:48 <jleedev> > do { a@'l' <- "hello world"; return a }
18:54:49 <lambdabot>  "lll"
18:55:38 <mux> I need to talk to dons about this
18:56:46 <scriptdevil> EvilTerran: can comp x:[] = []; comp x a:x:b = x: comp x b;  execute?
18:57:08 <EvilTerran> you still lack brackets and have that duplicated name
18:57:51 <scriptdevil> EvilTerran: well.. put the brackets.. But i am trying to match x in another string
18:57:53 <EvilTerran> comp [x] = []; comp x (a:y:bs) = y : comp x bs -- is this what you mean?
18:57:54 <scriptdevil> so will it work?
18:58:25 <scriptdevil> nope :(
18:58:33 <Toxaris> scriptdevil: no it will not work. you cannot use the same variable name twice in a pattern. you have to use the  (==)  operator if you want to check for equality
18:58:37 <EvilTerran> explain to me what this is meant to do. what does (comp 'l' "hello world") do?
18:59:11 <EvilTerran> is it "lll"?
18:59:33 <scriptdevil> Toxaris: is there a substring locater in haskell.. of course there will be... :)
18:59:43 <Cale> isInfixOf
18:59:45 <EvilTerran> there's isInfixOf
18:59:49 <Cale> (In Data.List)
19:00:12 <scriptdevil> EvilTerran:  it does ['l' : 'l': 'l']
19:00:13 <Toxaris> Cale: isInfixOf is no "substring locator"
19:00:16 <Cale> If you want to know *where* it's located, that's also not so hard.
19:00:28 <EvilTerran> Cale++ , you're awfully quick there. i was half-way through typing "?index isInfixOf" there.
19:00:34 <EvilTerran> scriptdevil, which is also "lll"
19:00:45 <scriptdevil> yeah :D
19:00:46 <EvilTerran> well, aside from your broken syntax
19:01:01 <scriptdevil> but err ['l','l','l'
19:01:03 <Cale> > findIndices (isPrefixOf "abra") (tails "abracadabra")
19:01:04 <lambdabot>  [0,7]
19:01:06 <EvilTerran> you either meant ['l', 'l', 'l'] or ('l' : 'l' : 'l' : [])
19:01:09 <scriptdevil> sorry.. kept pressing the wrong key
19:01:31 <Toxaris> Cale: nice. once again, tails wins.
19:01:42 <Cale> Too bad Sonic!
19:01:44 <scriptdevil> EvilTerran, Cale, thanks.. will use isInfixOf :D
19:02:00 <EvilTerran> scriptdevil, but what you're asking for really isn't finding substrings...
19:02:28 <Cale> scriptdevil: are you just looking for whether a given element occurs in a list?
19:02:29 <scriptdevil> Evil: It finds if a given string is a subastring
19:02:40 <Cale> There's also elem
19:02:45 <scriptdevil> Cale: yeah.. but this element is a string by itself
19:02:50 <Cale> > 'l' `elem` "Hello world!"
19:02:51 <lambdabot>  True
19:02:53 <Cale> > 'f' `elem` "Hello world!"
19:02:54 <scriptdevil> and a part of another string
19:02:54 <lambdabot>  False
19:02:56 <EvilTerran> what, comp? because that behaviour is far removed from sublist location
19:03:07 <EvilTerran> no matter how i try to fix it
19:03:22 <scriptdevil> hmmm.. i am new to haskell :P
19:03:37 <scriptdevil> ok.. thanks ... gotta rush to coll :D this is not homework btw
19:03:39 <Cale> scriptdevil: tails is an incredibly useful list function
19:03:44 <EvilTerran> i'm sure it's not.
19:03:48 <Cale> > tails "Hello world!"
19:03:49 <lambdabot>  ["Hello world!","ello world!","llo world!","lo world!","o world!"," world!",...
19:03:56 <scriptdevil> suber
19:03:58 <SamB> Cale: for a moment I thought you said incrementally
19:03:58 <scriptdevil> super
19:03:59 <scriptdevil> :D
19:04:01 <tromp_> >  tails "tails"
19:04:02 <lambdabot>  ["tails","ails","ils","ls","s",""]
19:04:16 <scriptdevil> ok.. i am off :D tada
19:04:19 <Cale> Together with things which work on prefixes, it's useful for finding substrings.
19:04:49 <Cale> Or for instance, doing a map over the list, where you want the map to not only depend on the element at an index, but successive elements too.
19:04:54 <SamB> Cale: apparantly not a very good algorithm though?
19:04:57 * EvilTerran quite often uses something like [match | Right match <- map (parse parsecParser file) (tails string)]
19:05:07 <dolio> > findIndex (isPrefixOf "ll") (tails "hello world")
19:05:08 <lambdabot>  Just 2
19:05:16 <SamB> (as far as the searching goes)
19:05:19 <Cale> SamB: It's equivalent to the naive nested loops algorithm with early breakouts.
19:05:34 <Cale> > > map (sum . take 3) (tails [1..10])
19:05:34 <lambdabot>   parse error on input `>'
19:05:35 <SamB> well, yeah, the naive part is the part I was getting at ;-)
19:05:38 <Cale> > map (sum . take 3) (tails [1..10])
19:05:38 <lambdabot>  [6,9,12,15,18,21,24,27,19,10,0]
19:05:52 <SamB> apparantly there are better ways to do linear searches?
19:05:54 <EvilTerran> > sum . take 3 . tails [1..10]
19:05:54 <lambdabot>  [6,9,12,15,18,21,24,27,19,10,0]
19:05:56 <EvilTerran> >:)
19:06:11 <Toxaris> SamB: depends on input
19:06:11 <Cale> indeed :)
19:06:31 <EvilTerran> it does make a perverse kind of sense, that, but it will confuse the newbies.
19:06:57 <SamB> Man, I don't remember much of what I'd heard about fuun2rna implementations...
19:07:27 <tensh> Toxaris: that article about monad transformers was great... I learned a lot!
19:07:44 * EvilTerran also notes that fmap appears to be associative
19:07:56 <mae> wasn't there an illustrated version of the monad laws somewhere...
19:08:05 <SamB> EvilTerran: it wouldn't be a very good idea to try naming it (.) if it weren't, would it?
19:08:11 <EvilTerran> indeed :D
19:08:16 <gwern> the clean compiler is going to accept haskell 98? http://wiki.clean.cs.ru.nl/Latest_developments
19:08:16 <gwern> interesting. wonder if they fixed the license yet...
19:08:29 <lambdabot> Title: Latest developments - clean
19:08:39 * EvilTerran likes the >=> version of the monad laws the best
19:08:46 <SamB> gwern: nobody told them that 1.4 + FFI is better yet?
19:09:05 <SamB> oh, + hierarchical modules
19:09:52 <EvilTerran> "(>=>) is associative. return is both a left and a right identity of it."
19:10:23 <SamB> what the heck is fishy?
19:10:34 <dolio> Most of the "1.4 is better" is in the libraries, though.
19:10:47 <EvilTerran> in symbols, "f >=> (g >=> h) = (f >=> g) >=> h; (return >=>) = (>=> return) = id"
19:10:54 <EvilTerran> ?src (>=>)
19:10:54 <lambdabot> Source not found. Sorry.
19:10:54 <SamB> dolio: possibly, but wired-in-tightly libraries...
19:11:06 <dolio> The main niggle to do with the compiler is pattern matching using Monad instead of MonadZero.
19:11:14 <araujo> hello
19:11:22 <EvilTerran> SamB, (f <=< g) x = f =<< g x, and similarly for >=>
19:11:28 <EvilTerran> it's in the 6.8 Control.Monad
19:11:31 <wli> dolio: It sure stopped me cold.
19:11:43 <Toxaris> EvilTerran: is >=> like >>> but for Monads?
19:11:51 <EvilTerran> zackly
19:11:52 <SamB> hmm, can you implement Haskell 98 and Haskell 1.4 libraries using the same core methods using class aliases?
19:12:00 <wli> SamB: No.
19:12:14 <wli> SamB: They fucked monad comprehensions.
19:12:20 <EvilTerran> :O
19:12:23 <SamB> wli: hmm, true.
19:12:41 <SamB> you'd need some kind of option for that...
19:14:02 <wli> There are a bunch of primitive operations whose types are off but I'm not sure if that touches on 1.4 vs. 98.
19:14:17 <dolio> They might be optimistic to say "Clean users can make use of Haskell libraries," though.
19:15:22 <dons> its kind of an interesting concession, after all those years of keeping clean separate
19:15:33 <SamB> dolio: certainly optimistic
19:15:41 <dons> if only it'd been folded into the haskell standard originally, we'd have two good compilers now.
19:15:51 <SamB> though apparantly optimism is a healty trait in functional programmers?
19:15:57 <wli> I tried to reinstate monad comprehensions. I failed miserably.
19:16:04 <SamB> dons: would we?
19:16:17 <wli> SamB: I'm a pessimist. What's that make me? A logic programmer?
19:16:17 <SamB> wli: in GHC?
19:16:24 <wli> SamB: Yeah.
19:16:35 <SamB> well, there's your problem right there ;-)
19:16:44 <dmwit> wli: Why did you fail?  SPJ has said a patch to GHC that puts them back in would be accepted...
19:16:55 <SamB> dmwit: presumably GHC won
19:17:08 <edwinb> nothing wrong with dangerous over-optimism ;)
19:17:12 <Cale> I'm incredibly bewildered by GHC.
19:17:15 <edwinb> we'd never get anything done otherwise
19:17:18 <edwinb> or I wouldn't, anyway
19:17:19 <wli> dmwit: I didn't even come remotely close to figuring out what on earth I had to do to in the code.
19:17:25 <dmwit> oh
19:17:25 <Cale> wli: same here
19:17:41 <dmwit> Yeah, okay, GHC is pretty good, huh?
19:17:54 <SamB> wli: well, now that GHC typechecks monadic code based on the methods, that should help...
19:18:01 <dmwit> s/good/hairy/
19:18:14 <mae> so clean will take over haskelll ; )
19:18:19 <wli> ghc kicked my arse.
19:18:25 <Cale> I'd also be up for implementing extensible records if I had the first clue about how GHC worked. The commentary is all pretty general, and there's a hell of a lot of stuff which seems underdocumented.
19:18:44 <SamB> try implementing things in JHC instead
19:19:12 <hrehf> http://sidewayspony.com/images/trough/production/2008/mar/11/76471_orig_tail_recursion.jpg
19:19:13 <hrehf> ;)
19:19:14 <lambdabot> http://tinyurl.com/2vh9vt
19:19:48 <Cale> heh
19:20:22 <EvilTerran> it's a kitteh ouroboros!
19:20:43 * wli wants a polymorphic SPARSEPACK...
19:21:04 <wli> ... and that with type-level arithmetic for linear algebra indexing etc.
19:21:44 <Saizan> ?where jhc
19:21:45 <lambdabot> http://repetae.net/john/computer/jhc/
19:22:23 <wli> LAPACK doesn't seem to be very useful for polynomials with integer coefficients (and for that matter, it lacks any sort of fraction-free Gaussian elimination or similar).
19:24:02 <mofmog> So I set my professor
19:24:08 <mofmog> mind you, this guy was given props in SICP
19:24:20 <mofmog> my calculator program and he said, "Well Haskell looks great and all but it looks so verbose"
19:24:24 <gwern> mofmog: impressive
19:24:38 <gwern> wait, verbose compared to what?
19:24:43 <mofmog> probably Scheme
19:25:10 <gwern> SamB: perhaps once they have a solid '98, they'll add on backwards stuff?
19:25:34 <gwern> SamB: although I suspect once they have '98, they'll wantto instead add in extensions...
19:25:53 <SamB> gwern: I thought 1.4 was an extension of 98
19:26:05 <SamB> are you telling me 1.4 was developed BEFORE 98?
19:26:12 <EvilTerran> ... yeeees
19:26:13 * SamB pretends to not know that it was
19:26:17 <gwern> SamB: I thought so
19:26:36 <Toxaris> mofmog: did you try to abstract some common patterns from your program?
19:26:36 <SamB> really, it would make more sense the other way...
19:26:51 <gwern> hrehf: you'll love the lambdacats then
19:26:57 <gwern> @where lambdacats
19:26:57 <lambdabot> http://arcanux.org/lambdacats.html
19:27:40 <dmwit> I'm sure that's where he got it from...
19:28:09 * dolio likes imperative cat.
19:28:21 <hrehf> gwern ok, some of those rock =D
19:28:22 <hrehf> http://arcanux.org/lambdacats/static.jpg
19:29:59 <gwern> for my money, the best one is either SPJ cat or 'help, trappd in IO monad'
19:33:07 <scook0> does anyone know of a good name for the comonadic equivalent of Reader?
19:33:26 <scook0> (i.e. the comonad with operation wask :: Foo r a -> r)
19:33:43 <dibblego> how would I ask lambdabot for Maybe's mempty/mappend source?
19:33:46 <mofmog> toxaris: not yet. Cleaning up apply is my next project
19:33:50 <EvilTerran> ?src Maybe mappend
19:33:50 <lambdabot> Source not found. My pet ferret can type better than you!
19:34:01 <EvilTerran> like that. but it doesn't work.
19:34:08 <dmwit> mempty = Nothing
19:34:10 <dibblego> ;)
19:34:10 <EvilTerran> ?src [] mzero
19:34:10 <lambdabot> mzero = []
19:34:15 <EvilTerran> ?src Maybe mzero
19:34:15 <lambdabot> mzero = Nothing
19:34:28 <Toxaris> mofmog: that may explain why it looks verbose at the moment.
19:34:37 <mofmog> well i did tell him that apply was ah ack
19:34:40 <dmwit> mplus a b = listToMaybe $ catMaybes [a, b]
19:34:42 <dibblego> ?src Maybe mempty
19:34:42 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
19:34:59 <dmwit> (Not the actual source.)
19:35:09 <solrize> > [1..5] >> ['a'..'d']
19:35:10 <lambdabot>  "abcdabcdabcdabcdabcd"
19:35:21 <Toxaris> mofmog: and the parser is verbose compared with a lisp meta-interpreter, wich needs no parser at all
19:35:22 <EvilTerran> mplus a b = maybe b Just a, i think
19:35:40 <dolio> scook0: '(,) r' isn't good enough? :)
19:35:42 <dmwit> Oh, you might be right.
19:35:54 <mofmog> toxaris: well i needsome way of converting it into lists don't I?
19:35:56 <dmwit> mplus a b = liftM2 mplus a b -- something like this?
19:36:01 <wli> Fangz: x^3 + x^2 + x + 1 + x^{-1} + x^{-2} + x^{-3} = p((x+1/x)/2) where deg(p)=3, for instance (there's another way to do it so you solve a cubic first, too).
19:36:12 <EvilTerran> @check \a b -> maybe b Just a == a `mplus` (b :: Maybe Int)
19:36:13 <lambdabot>  OK, passed 500 tests.
19:36:29 <EvilTerran> or it may just be written as a pattern-match. that'd be simpler. :P
19:36:34 <wli> It's all about the periods, yes.
19:36:40 <dmwit> > Just [3] `mplus` Just [4]
19:36:40 <lambdabot>  Just [3]
19:36:47 <scook0> dolio: ((->)r) is to Reader as ((,)r) is to ???
19:36:55 <mofmog> oh you mean metacircular? yeah. that shit is easy
19:37:20 <dolio> scook0: Yeah, I don't know. I think it's usually called Reader as well.
19:37:32 <dolio> scook0: Or Environment or something.
19:38:09 <scook0> oh, Environment sounds interesting
19:38:15 <Toxaris> mofmog: yes I mean
19:38:27 <scook0> maybe I'll see how that works out
19:38:31 <EvilTerran> ... what exactly does co-reader do?
19:39:17 <dolio> Same thing as reader, more or less, only it's a comonad.
19:40:01 <EvilTerran> i'd just call it CoReader, tbh
19:40:17 <SamB> dolio: what does it look like?
19:40:21 <fracture> is there an easy way to get an integer type that behaves modulo some arbitrary value?
19:40:30 <fracture> like for mod 12 arithmetic, etc?
19:40:32 <EvilTerran> fracture, sadly not
19:40:35 <fracture> aw :(
19:41:09 <dolio> CoReader r a = (r,a) ; counit (r,a) = a ; coextend f p@(r,_) = (r,f p)
19:41:10 <SamB> fracture: yes! you just have to write your own datatype using a type-level encoding of that arbitrary value
19:41:29 <Toxaris> SamB: "easy way"?
19:41:29 <dmwit> I don't know, a Num instance probably isn't *that* hard to write.
19:41:31 <SamB> that is, you can write a datatype that will do that
19:41:33 <dolio> coask (r,_) = r
19:41:33 <dmwit> Easy, but tedious.
19:41:36 <SamB> Toxaris: it is easy
19:41:37 <EvilTerran> it'd be nice if you could supply a function (Foo -> Foo) to a deriving clause that got applied to the result of all the derived functions
19:41:42 <EvilTerran> but sadly there's no such thing
19:41:47 <SamB> fracture: there are, iirc, libraries for this
19:41:55 <SamB> (type-level arithmatic, that is)
19:41:56 <fracture> SamB:  I'm thinking more like C++ style... typedef modnum<123> fooT;
19:42:03 <fracture> (except haskelly)
19:42:07 <fracture> but that level of "easy"
19:42:12 <fracture> ah?
19:42:16 <SamB> sadly we do not have numeric literals in the typesystem
19:42:26 <SamB> however you could whip something up using TH
19:42:37 <fracture> what's TH?
19:42:45 <SamB> (to obtain the desired type-level encoding)
19:42:45 <fracture> (I'm a total noob, btw)
19:42:50 <EvilTerran> SamB, it's not easy in the same way "newtype Mod12 = Mod12 Int deriving (Integral, Num) via (\Mod12 x -> Mod12 (x `mod` 12))" would be
19:42:54 <gwern> fracture: templatehaskell
19:42:56 <SamB> fracture: well, are you a quick learner?
19:42:58 <dmwit> Template Haskell may be a reasonable way to do it.
19:43:03 <fracture> ah
19:43:04 <gwern> haskell metaprogramming, somewhat equivalent to lisp macros
19:43:11 <fracture> interesting
19:43:38 <Toxaris> EvilTerran: that's an interesting idea for an extension
19:43:45 <SamB> fracture: the point of that would be that it would let you convert 123 to a (much uglier) type-level representation
19:43:53 <fracture> (readin' about th)
19:44:12 <EvilTerran> Toxaris, eh. about the only interesting use of it i can think of is numbers restricted to a range, mind.
19:44:15 <SamB> you don't need TH to solve the PROBLEM, TH would just make the solution more palatable syntactically
19:44:48 <fracture> got ya
19:45:08 <fracture> I need to read more about the type system I think, first
19:45:14 <fracture> dunno how to implement a new Num type
19:45:45 <SamB> anybody know any good papers on things like type-level arithmatic off hand?
19:46:26 <solrize> i just saw one last night but you've probably seen the basic ones
19:46:28 <EvilTerran> well, oleg's are always good for getting the old braincells working
19:46:41 <SamB> where is the "oleg" category on hackage?
19:46:50 <wli> I just want static bounds checking on linear algebra.
19:46:54 <solrize> http://www.haskell.org/haskellwiki/Type_arithmetic
19:46:55 <lambdabot> Title: Type arithmetic - HaskellWiki
19:47:15 <EvilTerran> we should give him a top-level in the heirarchy to himself
19:47:26 <EvilTerran> Oleg.TypeLevelNumbers, Oleg.HList... :P
19:47:58 <SamB> I was looking for type-int, and found it in "data"... sigh.
19:48:07 <SamB> didn't remember the name, obviously...
19:48:51 <wli> SamB: What package did you get that from? I don't have Data.TypeInt here.
19:49:41 <Toxaris> EvilTerran: if we had a sensible Num hierarchy, a lot more types would be somewhat like Num
19:49:50 <EvilTerran> mmm
19:49:55 <Toxaris> EvilTerran: and consider term normalization
19:50:07 <EvilTerran> true
19:50:24 <Toxaris> I discussed quotient types with someone some days ago, it may even have been you...
19:50:33 <EvilTerran> not i, said the pig
19:50:35 <EvilTerran> ;)
19:50:57 <Toxaris> (that is, someone asked about how to implement quotient types in haskell, and i proposed smart constructors)
19:51:23 <SamB> wli: type-int is a package on hackage
19:51:28 <SamB> in the data category
19:51:35 <SamB> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/type-int-0.4
19:51:41 <lambdabot> http://tinyurl.com/2v7ko3
19:52:07 <wli> I guess it's not gentooized.
19:52:21 <SamB> just cabal install it
19:52:51 <dibblego> @check \a b -> listToMaybe (catMaybes [a, b]) == if isJust a then a else b
19:52:52 <lambdabot>  OK, passed 500 tests.
19:52:52 <gwern> @seen shapr
19:52:52 <lambdabot> I saw shapr leaving #ghc, #haskell-blah and #haskell 5h 45m 13s ago, and .
19:52:53 <Toxaris> EvilTerran: I think it should be newtype Mod12 = Mod12 Int deriving ... via (mod 12). no need for wrapping / unwrapping, there is only one constructor anyway
19:52:57 <SamB> Igloo: what are your plans wrt. debianizing cabal-install?
19:53:15 <SamB> because that would obviously make it a lot easier to install cabal-install
19:53:27 * wli is clueless as to how to cabal-install things.
19:53:30 <SamB> given that you almost need to have it installed to install it
19:53:32 <Toxaris> EvilTerran: and Mod12 15 should yield (Mod12 3)
19:53:39 <dcoutts> wli: it's easy once you have cabal-install :-)
19:53:40 <Toxaris> magically :)
19:53:44 <dcoutts> wli: cabal install foobar
19:53:44 <dibblego> ?check \a b -> a ++ b == a `mappend` b
19:53:45 <lambdabot>  OK, passed 500 tests.
19:53:56 <SamB> dcoutts: you are the gentoo guy right?
19:53:58 <EvilTerran> mmm, true
19:54:01 <dcoutts> SamB: yep
19:54:08 <SamB> have you gentooized it?
19:54:08 <dcoutts> SamB: it'd be easier to package cabal-install once it's released
19:54:14 <dcoutts> no, it's not been released
19:54:17 <Toxaris> EvilTerran: consider newtype Ratio a = Ratio (a, a) via (uncurry gcd)
19:54:18 <SamB> oh.
19:54:21 <dcoutts> there is no tarball
19:54:23 <EvilTerran> i just said the first thing that came in to my head, i'm not surprised it could be refined somewhat :)
19:54:24 <SamB> why is that a problem?
19:54:46 <SamB> you could tar up the darcs repository or something...
19:54:46 <dcoutts> SamB: distros generally want a release and a tarball
19:54:52 * wli emerges cabal-darcs
19:54:53 <dcoutts> what version number would that be?
19:55:08 <dcoutts> no, that way leads to insanity
19:55:22 <dcoutts> there's a good reason distros ask for releases and tarballs
19:55:29 <SamB> just use 0.0.<the date and time you pulled, in UTC>
19:55:43 <wli> dcoutts: No idea.
19:55:46 <SamB> or tag the repository first
19:56:07 <SamB> (possibly both)
19:56:13 <dcoutts> SamB: we're working towards a Cabal-1.4 release and a corresponding release of cabal-install
19:56:20 <SamB> oh, very well.
19:56:41 <dcoutts> SamB: we've got a list of milestone bugs if you want to help it happen quicker
19:56:50 <SamB> it has bugs?
19:57:31 <SamB> is this in the "hackage" track?
19:57:35 <dcoutts> SamB: right
19:57:42 <dcoutts> http://hackage.haskell.org/trac/hackage/query?status=new&status=assigned&status=reopened&group=component&milestone=Cabal-1.4&order=priority
19:57:51 <lambdabot> Title: Custom Query - Hackage - Trac, http://tinyurl.com/25boef
19:58:13 * dcoutts plans to punt #24
19:58:26 <dcoutts> and #56
19:59:03 <SamB> why are you punting #24?
19:59:12 <dcoutts> nobody seems to care
19:59:17 <SamB> ah.
19:59:28 <dcoutts> if you want to fix it, it shouldn't be that hard
19:59:38 <SamB> this was not reported by a user of such a platform?
19:59:51 <dcoutts> well such users are few and far between
20:00:04 <dcoutts> and they're used to hardship
20:00:05 <SamB> because if it was, that could be construed as caring
20:00:22 <dcoutts> then one of them should fix it :-)
20:00:33 <SamB> hmm, point
20:00:45 <SamB> they ARE after all used to that sort of thing...
20:00:48 <dcoutts> it's now relatively easy, just consult the output of  ghc --info
20:01:07 <dcoutts>  ,("Have interpreter","YES")
20:01:35 <SamB> why does trac uses such crazy dates?
20:01:45 <dcoutts> probably just tack that list of attributes into the Compiler structure and then consult it in the appropriate place
20:01:56 <dcoutts> SamB: crazy?
20:02:02 <SamB> they are in little-endian
20:02:16 <SamB> well, actually mixed
20:02:17 <Cale> SamB: what crazy dates?
20:02:21 <dcoutts> 30/12/07 03:37:40
20:02:24 <dcoutts> looks ok to me
20:02:27 <SamB> day of month first, year last
20:02:36 <Cale> That's normal.
20:02:36 <SamB> should be 2007-12-30
20:03:14 <dcoutts> SamB: that might sort better but it's not the standard written convention
20:03:24 <SamB> who has a standard?
20:03:31 <dcoutts> what everyone writes
20:03:40 <Saizan> europeans at least
20:03:42 <SamB> in the US the standard is 12/30/2007
20:03:52 <SamB> 2007-12-30 OUGHT to be standard
20:04:01 <wagle_home> there's a sometime format of 10-Dec-2008, but someone got confused and thought it a good idea to use the month number
20:04:02 <cjb> it is the ISO standard.
20:04:04 <dcoutts> that's the crazy middle endian US convention :-)
20:04:18 <dcoutts> month-day-year wtf?
20:04:23 <dcoutts> I never understood it
20:04:27 <cjb> http://en.wikipedia.org/wiki/ISO_8601
20:04:27 <lambdabot> Title: ISO 8601 - Wikipedia, the free encyclopedia
20:04:31 <SamB> I don't understand ours either
20:04:43 <wagle_home> hey, its like the english system of measurement!
20:04:56 <SamB> wagle_home: what?
20:05:01 <dcoutts> which is also bonkers
20:05:08 <wagle_home> EVERYONE should use pounds, miles, feet, etc
20:05:08 <SamB> we don't do anything wierd with the digit order do we?
20:05:12 <EvilTerran> i think it comes from saying "March twelfth, oh-eight" or whatever
20:05:38 <wagle_home> evil europeans even use . in 2,000,000.00
20:05:43 <dcoutts> EvilTerran: I don't, I say the twelfth of march :-)
20:05:53 <EvilTerran> i know, but some do
20:05:59 <dcoutts> aye
20:06:31 <dcoutts> anyway, I was trying to encourage SamB to help us reach the Cabal-1.4 milestone, not slag off the silly US date system
20:06:38 <SamB> well, we could hijack DNS names and call it "30.12.2007.time."
20:07:03 <wagle_home> i'm geeky enough to think the metric system is cool, but i never learned it in my gut..  i think in miles, feet, pounds, etc..  sigh
20:07:17 <SamB> I do not think in miles
20:07:31 <SamB> they are a very unfamiliar unit to me
20:07:37 <gwern> Stupid americans. I hate us so much! -Homer
20:07:47 * EvilTerran thinks in inches, feet, and miles
20:07:50 <wagle_home> lol
20:08:04 <dcoutts> wagle_home: I think in a weird mixture of the two depending on the thing I'm measuring
20:08:20 <mrsolo> it is easier to think in metric system
20:08:33 <mrsolo> hard to relate to anybody in u.s. though
20:08:48 <dibblego> which is easier :)
20:08:48 <SamB> wait, why am I letting you distract me from sleeping and/or implementing class aliasses and/or writing a datatype for fracture ?
20:08:57 <wagle_home> took chemistry, everything was metric, but coulda just as well been in foobars
20:09:48 <SamB> probably the datatype is easier
20:10:11 <fracture> samb: was mainly curious (solved my prob in another language)
20:10:30 <fracture> (although if there is a decent way I'd love to see what it is)
20:13:03 <gwern> SamB: what program is fracture?
20:13:35 <gwern> oh.=, wait, fracture is an IRcer. maybe I need to get some sleep
20:13:36 <dmwit> gwern: ...
20:13:54 <SamB> darnit
20:14:04 <SamB> this type-int package is missing a module!
20:14:14 <SamB> how did hackage not catch this?
20:14:31 <SamB> it ran haddock, it could have checked that too...
20:15:32 <SamB> (either that, or type-int is just not correctly packaged...)
20:15:53 <fracture> I am a perl script that asks random questions about haskell.
20:16:01 <fracture> err ... n/m
20:16:08 <SamB> yeah, really
20:16:10 <fracture> what program is gwern?
20:16:15 <SamB> you can't write a script that well in perl
20:16:21 <fracture> hah
20:16:21 <Saizan> SamB: the log is listed under build failure
20:16:27 <SamB> Saizan: oh.
20:16:39 <SamB> why is there not a flag next to it in the package list?
20:17:02 <SamB> does hackage email maintainers when that happens?
20:17:40 <gwern> fracture: I am the queen's dog at Kew \ pray tell me sir, whose dog are you?
20:17:56 <gwern> SamB: I don't think it does, although it's a good idea
20:18:10 <Saizan> SamB: see http://hackage.haskell.org/trac/hackage/ticket/56
20:18:12 <lambdabot> Title: #56 (hackageDB should not accept a package if it is not installable) - Hackage - ...
20:18:32 <dolio> Bah, does ./configure from autoconf have no way of using programs installed in ~ for building?
20:18:53 <Saizan> a build failure might just means a missing C library or something like that
20:20:02 <Toxaris> how is the application of a type constructor expressed in natural language? I know "lists of integers" or "integer lists", but how do you pronounce "Maybe Integer"?
20:20:05 <SamB> well, if it fails while compiling *haskell*
20:20:08 <Saizan> but it could make a bunch of sanity checks on the .cabal file, in this case it'd require dependency analysis which cabal still lacks
20:21:53 <monochrom> Toxaris: That is the same as: "what is the natural language word for Maybe?"  And it shows that natural language is doomed.
20:22:32 <Toxaris> too bad :(
20:22:48 <monochrom> SML and OCaml calls it "option".  Perhaps you can say "option of integer", "integer option".
20:23:19 <monochrom> Anyway, natural language is not supposed to be expressive.
20:24:02 <Toxaris> I want to explain (fmap :: (a -> b) -> (Maybe a -> Maybe b)) in similiar words as map is explained
20:24:22 <dolio> Clearly it's "the tagged union of integer and unit."
20:24:29 <Toxaris> "map transforms a function on values to a function on lists of these values"
20:24:42 <dolio> :)
20:24:44 <monochrom> It helps that "option" is a noun like "list".
20:24:54 <Toxaris> "mapMaybe transforms a function on values to a function on options of these values" :(
20:25:20 <monochrom> But you need to first say "I define 'option' to mean so-and-so".
20:25:25 <Toxaris> (hmm, mapMaybe is a temporary name here)
20:25:51 <Toxaris> ... to a function on possible values
20:25:59 <dmwit> > 128 * 3
20:25:59 <lambdabot>  384
20:26:08 <monochrom> The point of moving to a formal language is that all natural languages are incomplete and inconsistent.  Can't explain shit in it.
20:26:11 * Toxaris finally started it's "from Functor to Monad"-tutorial
20:26:59 <Toxaris> maybe I need a different example then Maybe if I want to stay with natural language
20:27:18 <monochrom> Only use of natural languages is you use it to bootstrap your formal language, since they are so widely installed.  Just like bootstrapping a haskell compiler from C.
20:27:34 <mrsolo> you just explained things in english
20:28:00 <monochrom> Anyway, for something as basic as Maybe, I don't see why "option" doesn't work.
20:28:39 <Toxaris> hmm. maybe optional.
20:28:52 <BMeph> Toxaris: I'd sub "a possible" for the Maybe. :)
20:29:07 <Toxaris> foo transforms functions on values into functions on optional values
20:29:10 <monochrom> IIUC "stock option" is in every sense "Maybe Stock".
20:29:22 <Maddas> Why not just call it 'Maybe Integer'?
20:29:40 <Maddas> It needn't be unambiguous.
20:29:55 <Toxaris> Maddas: I'm talking about a polymorphic function and try to avoid the quantification
20:29:57 <Maddas> When talking to Haskell programmers, the context should make your usage clear soon enough :-)
20:30:46 <Toxaris> monochrom: the problem with "stock option" is that it is an unusual compound with the semantic head not in the last position
20:31:06 <Toxaris> monochrom: I want a optional stock, not a stokish option
20:31:23 * Toxaris thinks too much about language
20:31:45 <monochrom> "integer list"? "stock option"?  I don't see the problem.
20:31:52 <Maddas> Toxaris: Did you try looking at what popular Haskell texts use?
20:32:44 <Toxaris> I see.
20:32:54 <Toxaris> Maddas: good idea.
20:33:14 <Maddas> There might even be existing conventions :-)
20:33:34 <gwern> @tell shapr check your email for patches; also: <http://hackage.haskell.org/cgi-bin/hackage-scripts/package/FermatsLastMargin-0.1>
20:33:34 <lambdabot> Consider it noted.
20:33:52 <Toxaris> (I mean: I see that list and option are used in the same way; not: but I see a problem)
20:34:21 <monochrom> It's the whole point of fmap. :)
20:35:23 <monochrom> Anyway, intuition is a hinderance to learning.
20:36:20 * Maddas disagrees.
20:36:34 <solrize> Maybe can be explained as a list with at most one element
20:36:41 <solrize> either [] or [x]
20:36:41 <Maddas> Developing intuition is often my main goal in learning.
20:37:01 <monochrom> Of course, I mean past intuition, not future intuition.
20:37:22 <Maddas> It can be a hindrance, it certainly doesn't have to be.
20:37:23 * cjb disagrees maximally.
20:37:27 <allbery_b> ==monochrom --- but be careful about the intuitiions you develop, they may interfere with future learning
20:38:01 <Maddas> Try teaching advanced calculus to someone with no mathematical intuition :-)
20:38:18 <monochrom> Cale does that to teens all the time.
20:38:36 <monochrom> Cale testifies it's so much easier.
20:38:51 <Toxaris> "past intuition", "future intuition"?
20:38:53 <Maddas> Easier than what?
20:39:10 <Cale> Uh, it's easier than teaching mathematics the wrong way.
20:39:12 * Maddas suspects his math courses made him better at learning related topics, not worse. Experience has not proven me wrong yet.
20:39:27 <Cale> Which is what most highschool "mathematics" courses do.
20:39:30 <Maddas> Learning conceptually different topics, of course, require different concepts (by definition :-))
20:40:17 <Maddas> Cale: Right, bad teaching can be worse than no exposure.
20:43:03 <OceanSpray> alright, I got a [[Double, Double, Double]]
20:43:22 <dmwit> [(Double, Double, Double)] ?
20:43:28 <OceanSpray> where the tuples are RGB values
20:43:35 <OceanSpray> what's the easiest way to put that into a bitmap?
20:43:46 <OceanSpray> whoops
20:43:53 <Cale> Reading the scrollback, intuition isn't a hindrance though. It's an incredibly powerful tool, once it's well-shaped.
20:43:59 <OceanSpray> [[(Double, Double, Double)]]
20:44:32 <dmwit> I'm sure there's a library call for that, not sure which image-related libraries there are, though.
20:44:45 * Maddas agrees
20:46:44 <dmwit> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Graphics
20:46:49 <lambdabot> http://tinyurl.com/yqov7f
20:47:42 <dmwit> In particular, SDL-image looks promising for your needs.
20:47:55 <dmwit> Oh, hm, maybe not.
20:49:44 <dmwit> Does it specifically need to be a bitmap, or is displaying it enough?
20:50:54 <wli> concave: What do you get for (e^z - 1)*(e^(2*z) + e^z + 1)?
20:51:17 <Toxaris> Maddas: some Haskell texts define Maybe with different wording, e.g. data Nullable = ... or data Optional = ... or data Option = ... . does this suggest that Maybe is a bad name, or is it just bad for learners?
20:51:43 * Maddas wouldn't assume it suggests either, but he doesn't recall thos etexts
20:51:47 <Maddas> Recall reading those texts, that is.
20:51:58 <Maddas> Use whatever works best for your purposes :-)
20:52:07 <Toxaris> or are tutorials trying to use new names to avoid name clashes when learners try to compile those data definitions
20:52:21 <OceanSpray> dmwit, displaying is fine, too
20:52:27 <OceanSpray> I just need to get SOME sort of image.
20:52:44 <SamB> they should just call it Maybe'
20:52:51 <SamB> with Just' and Nothing'
20:53:32 <OceanSpray> The Imlib package (version 0.1.1)
20:53:36 <SamB> or perhaps simply point out soon after that Haskell actually has Maybe already...
20:53:38 <OceanSpray> Uploaded by	CaleGibbard
20:53:41 <Toxaris> I'll assume knowledge of Prelude.Maybe, but use "optional a" as natural language equivalent for Maybe a
20:54:11 <Cale> OceanSpray: yeah, that's mine.
20:54:18 <OceanSpray> what's it do?
20:54:28 <Cale> It's a binding to Imlib2
20:54:34 <Toxaris> thanks monochrom and Maddas for discussion
20:54:35 <OceanSpray> oh.
20:54:48 <monochrom> you're welcome
20:55:02 <Cale> It's not as nice as it could be though. You're reminding me that I should finish my new version of it.
20:55:06 <solrize> toxaris, best to stay away from analogies and just the standard terms.  eliminate a layer of indirection.
20:55:52 <Toxaris> solrize: well, I'm not writing a tutorial for people who understand things by looking at the code
20:56:07 <Toxaris> and the haskell report
20:56:28 <solrize> yeah, i'd say introduce the terms and explain what they mean, then use them
20:56:32 <mofmog> is it bad that im procrastinating for my CS midterm by working on a haskell project?
20:56:53 <SamB> mofmog: hmm, define bad
20:56:57 <OceanSpray> oy, library hunting is tedious
20:57:05 <SamB> I think I'm going to reboot.
20:57:11 <mofmog> "message passing? Data directed? Tree recursion? Who needs that, I'm working on my interpreter"
20:57:21 <SamB> emacs isn't working right and I can't figure out why...
20:57:29 <mofmog> use vim probelm solved
20:57:36 * mofmog puts on a fire retardant suit
20:58:08 <Toxaris> mofmog: I try to use Haskell for stuff i have to learn
20:58:38 <tensh> making the following to an instance of monad wouldn't make any sense, right?   newtype B m a = MkB (m (a, B m a))
20:58:59 <tensh> I'm thinking it wouldn't because of the recursive definition
20:58:59 <OceanSpray> screw it, I'm just going to write directly to a bitmap.
20:59:17 <monochrom> You need tree recursion for your interpreter.  You further need message passing if your interpreter is parallelized.
20:59:29 <Cale> OceanSpray: You could use my Imlib library to write a png, for example.
20:59:41 <OceanSpray> oh?
20:59:48 <monochrom> And last but not least, most Haskell implementations execute code in a data-driven way.
20:59:52 <mofmog> monochrom: it doesnt help if i forget how to do it in scheme
20:59:59 <Toxaris> tensh: List is recursive and a monad
21:00:12 <tensh> oh, true
21:00:30 <tensh> alright, need to think some more then
21:00:31 <tensh> ;)
21:00:45 <Toxaris> tensh: is m supposed to be a monad?
21:00:54 <tensh> yes
21:01:55 <Cale> OceanSpray: yeah, there's a createImageUsingArray :: Array (Int,Int) ImlibColor -> IO ImlibImage
21:02:08 <Cale> OceanSpray: You'd use that, then contextSetImage
21:02:25 <Cale> and then saveImage
21:02:34 <OceanSpray> though the function names are quite informative,
21:02:44 <OceanSpray> the documentation is... scant.
21:03:06 <Cale> Yeah, the version which isn't finished has documentation.
21:03:18 <Cale> also, even better names
21:03:34 <Cale> But it's tedious to write. :)
21:03:45 <mofmog> a lot of libraries it seems are out of date
21:03:48 <Toxaris> tensh: return is obvious: return x = MkB (return (x, return x)). that is: a pure, infinite stream of x's
21:03:52 <mofmog> or not in a state of constant updating
21:04:35 * monochrom constantly runs "touch" over his project files and creates new releases.
21:05:00 <tensh> Toxaris: ahh, I got lost at the second argument in the tuple
21:05:18 <tensh> it feels strange that return would yield two different results on the same line
21:05:27 <Toxaris> tensh: well, it's your crazy type, isn't it :)
21:05:54 <Toxaris> tensh: it's m's return and B m's return
21:06:08 <tensh> well, it belonged to an exercise, though there are no answers
21:06:11 <SamB> arg, emacs is still doing it...
21:06:33 <tensh> which is half good, half bad I guess ;)
21:06:39 <Toxaris> tensh: oh, so I shouldn't have given you the answer?
21:06:45 <bos> @seen dons
21:06:45 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 43m 14s ago.
21:06:58 <tensh> Toxaris: I'm not gonna turn them in or anything... it's just for learning
21:07:24 <tensh> I should've thought of it though, since I wrote lift for it
21:07:40 <monochrom> http://hpaste.org/5833 is also crazy in the same vein.
21:07:51 <tensh> and pretty much did the same thing there (for constant lift)
21:08:25 <tensh> well thanks :)
21:10:28 <joe_b> good evening
21:10:39 <OceanSpray> "Setup.lhs: At least the following dependencies are missing:
21:10:39 <OceanSpray>     X11 -any
21:10:39 <OceanSpray> "
21:10:49 <OceanSpray> oy, what's up with that?
21:11:18 <monochrom> You need an "X11" package.  hackage probably has it.
21:11:34 <monochrom> building xmonad?
21:11:44 <OceanSpray> oh, X11 for Haskell, not X11 itself.
21:11:47 <OceanSpray> nvm
21:11:51 <joe_b> any particularly ghc-savvy people present?
21:13:30 <joe_b> im messing around with the ffi and exporting haskell as a c library
21:13:59 <joe_b> but to link in the haskell .o's, gcc complains about defined symbols
21:14:11 <OceanSpray> #ghc ?
21:14:32 <joe_b> oh! is there a ghc channel? great!
21:14:42 <gwern> joe_b: I sometimes find -fvia-C a useful option to try for link errors
21:15:13 <joe_b> thanks gwern
21:15:28 <joe_b> ill go bug the ghc-ers now
21:20:01 <OceanSpray> oy, arrays are confusing.
21:20:32 <joe_b> me again, the ghc people aren't responsive
21:20:44 <jeffz> irc can take some hours or days sometimes
21:21:26 <joe_b> oh
21:22:11 <joe_b> so is there anyone here now who has played with ghc and ffi and haskell exported as a library?
21:23:06 <jeffz> joe_b: as well as here, there's also a ghc mailing list for users to ask questions and haskell.cafe is also popular
21:24:06 <mofmog> how do i make an associated list?
21:24:23 <mofmog> i want to link together a string and a function inside some sort of list. I was thinking of using tuples inside an array
21:24:41 <Toxaris> mofmog: why not tuples inside a list
21:24:42 <monochrom> [("monochrom", 1), ("mofmog", 0)]
21:24:56 <Cale> Or a Data.Map
21:25:05 <joe_b> how efficient an implementation do you need?
21:25:07 <mofmog> er list
21:25:11 <mofmog> not very
21:25:33 <monochrom> Data.Map is preferable not just for speed, but also for a better API.
21:25:59 <monochrom> [("monochrom", 1), ("mofmog", 0)]  is not very well supported by Data.List functions.
21:25:59 <mofmog> so i want to write a fuction that takes the assoc list, a key and output the value in the least amount of code
21:26:22 <monochrom> Data.Map has lookup for exactly that.
21:26:28 <mofmog> alright ill look into
21:26:29 <monochrom> Data.List doesn't, IIRC.
21:26:52 <Toxaris> > lookup "monochrom" [("monochrom", 1), ("mofmog", 0)]
21:26:53 <lambdabot>  Just 1
21:27:00 <Toxaris> > lookup "toxaris" [("monochrom", 1), ("mofmog", 0)]
21:27:01 <lambdabot>  Nothing
21:27:05 <Toxaris> it does
21:27:48 <monochrom> Darn.
21:27:50 <Toxaris> but Data.Map is easy and better :)
21:28:16 <Toxaris> > Data.Map.lookup "monochrom" (fromList [("monochrom", 1), ("mofmog", 0)])
21:28:16 <lambdabot>   Not in scope: `fromList'
21:28:20 <Toxaris> > Data.Map.lookup "monochrom" (Data.Map.fromList [("monochrom", 1), ("mofmog", 0)])
21:28:21 <lambdabot>   Not in scope: `Data.Map.fromList'
21:28:23 <Toxaris> :(
21:28:42 <joe_b> is it hpaste that lets you run haskell in here?
21:28:57 <OceanSpray> joe_b, no, it's lambdabot
21:29:12 <joe_b> how do i use it?
21:29:24 <OceanSpray> @index fromList
21:29:24 <lambdabot> Data.HashTable, Data.IntMap, Data.IntSet, Data.Map, Data.Set
21:29:29 <joe_b> (sorry for the n00b questions)
21:29:40 <OceanSpray> huh, that's weird.
21:29:50 <mofmog> well aparently i can't have a string and a function inside a tuple
21:29:51 <Toxaris> > "just write '> ' followed by an expression to be evaluated, joe_b"
21:29:51 <lambdabot>  "just write '> ' followed by an expression to be evaluated, joe_b"
21:30:14 <Toxaris> mofmog: sure you can.
21:30:35 <joe_b> > (2, (\x-> x*x))
21:30:36 <lambdabot>  (2,<Integer -> Integer>)
21:30:40 <joe_b> cool
21:30:46 <monochrom> [("monochrom", (+ 1)), ("mofmog", id)]
21:31:09 <Toxaris> > lookup "succ" [("succ", succ), ("pred", pred), ("id", id)] 41
21:31:09 <lambdabot>  Couldn't match expected type `t1 -> t'
21:31:43 <joe_b> succ 41
21:31:48 <joe_b> > succ 41
21:31:48 <lambdabot>  42
21:32:17 <Toxaris> > lookup "succ" [("succ", succ), ("pred", pred), ("id", id)] <*> Just 41
21:32:18 <lambdabot>  Just 42
21:32:47 <sclv> oh that's pretty cute.
21:32:50 <joe_b> what is <*>?
21:32:56 <sclv> ?ty ap
21:32:57 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:33:07 <sclv> that
21:33:39 <sclv> ?src ap
21:33:39 <lambdabot> ap = liftM2 id
21:33:42 <sclv> or that.
21:34:23 <joe_b> ah, i get it, im still very new to monads
21:35:18 <OceanSpray> sometimes, like right now, I miss C-style for-loops.
21:35:46 <Toxaris> OceanSpray: what's wrong with Haskell-style maps?
21:36:19 <OceanSpray> I'm trying to create an array right now, not a map.
21:36:34 <OceanSpray> OH
21:36:40 <OceanSpray> the map function, you mean
21:36:44 <joe_b> > map succ [1..10]
21:36:45 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
21:37:06 <joe_b> much preferred to a for loop, imo
21:37:29 <cjb> I've been writing list comprehensions (with no lvalue) in python, instead of using for loops
21:37:32 <joe_b> but i write a lot of c-style code these days
21:37:34 <cjb> it's probably bad.
21:37:45 <cjb> ie. [function(x) for x in list].
21:38:05 <cjb> well, I suppose that's not actually "instead of for loops".
21:38:18 <lament> cjb: i don't think it's bad in the sense of being unidiomatic
21:38:28 <Cale> joe_b: You could use forM for a foreach-style loop.
21:38:42 <cjb> lament: pylint warns me "statement has no effect", which I think means it expected an lvalue.
21:38:49 <cjb> (and is untrue.)
21:38:51 <lament> cjb: yeah but pylint is on crack
21:38:53 <Cale> joe_b: You could also design your own C-style loop, but Haskell's mutation primitives aren't really convenient enough to make it worthwhile.
21:39:38 <joe_b> Cale: thanks, but i meant im writing lots of java, javascript, c#, etc., not c-style in haskell
21:41:07 <lament> dostoyevsky's like that.
21:41:14 <lament> wrong window!
21:41:38 <joe_b> good night folks
21:45:01 <solrize> joe_b:
21:45:15 <solrize> > do { i <- [1..10]; return (i*i) }
21:45:16 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
21:47:21 <Toxaris> > join (*) <$> [1..10] -- so much easier
21:47:21 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
21:47:33 <mofmog> egh
21:47:39 <mofmog> lookup returns a maybe
21:47:39 <solrize> baffle
21:47:41 <Cale> > map (^2) [1..10]
21:47:41 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
21:47:47 <mofmog> how do i de monadify something
21:48:05 <Cale> mofmog: You mean how do you pattern match against a Maybe value?
21:48:26 <Cale> You typically use case
21:48:34 <Cale> You could also use the function maybe
21:48:38 <Cale> :t maybe
21:48:39 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
21:49:17 <Toxaris> :t (.)
21:49:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:49:29 <Toxaris> > join (*) . [1..10] -- shorter
21:49:29 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
21:49:38 <Cale> > (^2) . [1..10]
21:49:39 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
21:49:56 <mofmog> getFunc (Operat a) =  lookup a func
21:50:00 <mofmog> func is a list of tuples
21:50:08 <mofmog> but this returns a Maybe
21:50:14 <Cale> Right, as it should.
21:50:17 <mofmog> i want the thing inside the maybe to be returned
21:50:27 <Toxaris> mofmog: what should happen if it is Nothing?
21:50:28 <Cale> and if the thing isn't found?
21:50:36 <Toxaris> mofmog: that is, if the operator is not found in the list?
21:50:37 <mofmog> well then the program crashes oh well
21:50:45 <Cale> fromJust
21:50:55 <mofmog> i see what you guys mena though
21:50:58 <Cale> > fromJust (Just 5)
21:50:58 <lambdabot>  5
21:51:01 <Cale> > fromJust Nothing
21:51:02 <lambdabot>  Exception: Maybe.fromJust: Nothing
21:51:48 <Toxaris> > fromMaybe (error "no such operator") (Just 5)
21:51:49 <lambdabot>  5
21:51:54 <Toxaris> > fromMaybe (error "no such operator") Nothing
21:51:55 <lambdabot>  Exception: no such operator
21:52:01 <solrize> > succ . [1..10]
21:52:02 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
21:52:03 <OceanSpray> > flatten [[1, 2], [3, 4]]
21:52:04 <Toxaris> slightly better imho
21:52:04 <lambdabot>  Couldn't match expected type `Tree a' against inferred type `[a1]'
21:52:17 <solrize> huh?  that doesn't happen in my ghci
21:52:17 <Cale> > concat [[1,2],[3,4]]
21:52:18 <lambdabot>  [1,2,3,4]
21:52:37 <Cale> solrize: (.) is redefined in lambdabot to be more general
21:52:42 <solrize> oh
21:53:06 <mofmog> where is fromJust?
21:53:13 <mofmog> :src fromJut
21:53:15 <mofmog> er
21:53:17 <Cale> Ordinarily, (.) takes two functions and composes them. You'll get an error from that since [1..10] isn't a function
21:53:18 <solrize> @hoogle fromJust
21:53:18 <lambdabot> Data.Maybe.fromJust :: Maybe a -> a
21:53:31 <solrize> cale, yeah, that's hwat i expected, i was surprised when lambdabot mapped it
21:53:38 <solrize> so i tried it in ghci and got a different result
21:54:17 <Cale> solrize: In lambdabot, (.) is defined to be the same as fmap, which is a generalised version of map.
21:54:21 <Cale> :t (.)
21:54:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:54:54 <Cale> When f = (t ->), effectively, you have  (.) :: (a -> b) -> (t -> a) -> (t -> b)
21:54:58 <OceanSpray> I need some sort of map function for arrays
21:55:00 <Cale> which is the usual function composition
21:55:07 <Cale> @hoogle map
21:55:07 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
21:55:07 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
21:55:07 <lambdabot> Data.ByteString.map :: (Word8 -> Word8) -> ByteString -> ByteString
21:55:08 <solrize> uh, (fmap (*2) (*3) 5) is a type error
21:55:16 <dolio> @instances Functor
21:55:16 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:55:38 <Cale> solrize: Unfortunately, the instance isn't in the prelude.
21:55:38 <solrize> hmm
21:55:39 <Cale> solrize: Import Control.Monad.Instances
21:55:44 <solrize> oh ok
21:55:44 <OceanSpray> nvm, I found Data.Array.amap
21:55:52 <dolio> @instances-importing Data.Array Functor
21:55:53 <lambdabot> ((,) a), ((->) r), Array i, Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
21:55:57 <Cale> OceanSpray: yeah, sorry about that :)
21:56:08 <OceanSpray> @index amap
21:56:08 <lambdabot> Data.Array.IArray, Data.Array.Unboxed, Data.Array.Diff
21:56:08 <solrize> Prelude> :m Control.Monad.Instances
21:56:09 <solrize> Prelude Control.Monad.Instances> (fmap (*2) (*3)) 9
21:56:09 <solrize> 54
21:56:17 <solrize> wow!  now i have no idea how that happened... :)
21:56:36 <Cale> instance Functor ((->) e) where
21:56:41 <Cale>   fmap f g = f . g
21:56:47 <solrize> hm ok
21:57:02 <solrize> cool
21:57:07 <dolio> > (+1) . listArray (1,10) [1..10]
21:57:07 <lambdabot>  array (1,10) [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11)]
21:57:20 <roconnor> instance Function (e ->)  is easier for humans to parse
21:57:30 <Cale> roconnor: But doesn't parse in GHC.
21:58:40 <sclv> simon just made a proposal about changing infix constructor syntax though, no?
21:58:50 <Cale> Did he?
21:59:00 <Cale> I haven't been keeping up with haskell-cafe
21:59:13 <dolio> Yeah. He wants to write 'data a + b = Left a | Right b'.
21:59:18 <dolio> Instead of :+:.
21:59:21 <sclv> Subject: RE: [Haskell-cafe] Where does ~> come from?
22:01:20 <sclv> probably for helping new foax to understand ((->) e) alone, it might be worth it?
22:01:23 <Cale> I rather like ~> as a type variable though.
22:01:40 <sclv> yeah, there are downsides too...
22:01:58 <sieni> foax?
22:02:23 <sclv> the colon does make things feel more complicated than they need to be on the other hand.
22:02:44 <Cale> Yes.
22:02:44 <sclv> foax = a folksy way of saying foax.
22:02:48 <solrize> i really hate when there is a succession of little changes.  they all blur together after a while.  better to keep things backwards compatible, and eventually do a big redesign that makes all the incompatible changes in one shot
22:03:01 <sieni> sclv: sorry, I don't speak internets
22:03:17 <sclv> sieni: not internets, i think. picked it up from pynchon, actually...
22:03:18 <Cale> solrize: But often it's hard to tell whether any one change would be really good.
22:03:38 <dolio> Yeah, getting rid of operator variables would be kind of a pain.
22:03:41 <Cale> solrize: So if you go and change everything at once, you end up having a hard time telling which things worked.
22:03:47 <solrize> true
22:04:00 <sclv> i'd actually like to see the : gone from data constructors too, but might be missing something?
22:04:22 <solrize> but that's experimental languages are for.  i realize haskell was supposed to BE an experimental language, but it's too late
22:04:34 <Cale> Meh, it's still experimental :)
22:05:00 <Cale> If changes get into GHC, they're essentially accepted.
22:05:19 <sclv> the thing being, i guess, you can always define a function without the : that's a partially applied data constructor, but can't do the same with type constructors.
22:05:20 <dolio> As long as Haskell uses certain characters to distinguish constructors from regular functions, infix constructors are going to need something like :.
22:05:57 <Cale> Maybe at the type level, the lexical distinction between constructors and variables isn't the right way to go...
22:06:16 <sclv> for some reason, an infix data constructor feels like its always a function to me, while a prefix one feels different... totally arbitrary though... maybe has to do with usage?
22:06:17 <Cale> Or perhaps it should just be inverted...
22:06:36 <Cale> like :~> could be used as a variable, whereas ~> would be a constructor
22:07:12 <sclv> well, that would be sane, but utterly confusing...
22:07:57 <waterson> hey there! i'm stumbling through the ffi and was wondering if anyone had a few moments to answer questions?
22:08:28 <Cale> waterson: sure
22:08:33 <solrize> why does ghc make such huge binaries?  i.e. instead of using the c runtime like jhc does?
22:08:43 * sclv wants keyboards with broken bars handy.
22:09:01 <Cale> solrize: It doesn't dynamically link against its runtime.
22:09:09 <sclv> solrize: jhc can get away with that because with whole program analysis it resolves way more stuff at compile time.
22:09:14 <solrize> hmm ok
22:09:16 <Cale> solrize: Purely for the reason that nobody's bothered to implement that.
22:09:30 <waterson> Cale: i've got a C struct that I need to populate before making a call.
22:09:44 <Cale> solrize: Also, GHC has a threading system and so on.
22:09:52 <BMeph> Anyone know off-hand what the smallest GC-ing runtime is? Any how we can (ab)use it to improve GHC? ;)
22:10:11 <waterson> Cale: it seems that the way to do this is to write a wrapper function that takes all values as arguments, and copies these into the struct, then do the "real" call?
22:10:12 <Cale> waterson: Usually you write a Storable instance for some Haskell datatype which corresponds to the C type.
22:10:12 <solrize> bmeph you mean for haskell?
22:10:23 <waterson> Cale: ahh...
22:14:42 * waterson reads.
22:14:42 <scook0> waterson: tools like hsc2hs and c2hs can help with peeking and poking struct fields
22:14:43 <BMeph> solrize: I mean, the smallest-known garbage-collecting runtime for any language.
22:14:43 <scook0> (e.g. for implementing Storable)
22:14:43 <sclv> BMeph: what about piggybacking off of clean? :-)
22:14:43 <solrize> hmm, javacard can run in a few k
22:14:43 <BMeph> Making it work for Haskell would be a separate exercise. :)
22:14:43 <solrize> actually the static code is bigger than a few k, but not by that much.  j2me is maybe 50k.  the hedgehog lisp runtime is about 20k
22:14:43 <solrize> hedgehog lisp is a cool little language, purely functional
22:14:43 <Cale> Haskell binaries would have to get up to around 50mb before I even noticed they were a little large :)
22:14:43 <solrize> has generational gc
22:14:43 * sclv imagines D would be pretty sweet.
22:14:43 <Cale> There's a lot of stuff in GHC's runtime.
22:14:43 <BMeph> ^^ -- you have generational GC, sol? ;)
22:14:43 <Cale> GC, threading, STM, parallelism...
22:14:43 <adu> Are tuples Typeable?
22:14:43 <Cale> adu: yep
22:14:43 * BMeph has pondered a Haskell impl. using D's runtime engine.
22:14:43 <solrize> but can't the linker tell statically whether threading, STM, etc. are actually being used?
22:14:43 <sclv> pure programs also tend to have different gc profiles than imperative ones as i recall.
22:14:43 <OceanSpray> Cale, what is ImlibColor
22:14:43 <OceanSpray> ?
22:14:43 <Cale> OceanSpray: a Haskell datatype
22:14:43 <OceanSpray> oy
22:14:43 <Cale> I believe the fields go ARGB, but they might also be RGBA
22:14:51 <wli> What's A?
22:14:54 <Cale> alpha
22:15:06 <Cale> for partial transparency
22:15:10 <adu> wli: better known as opacity
22:15:17 <OceanSpray> is 0 or 1 opaque?
22:15:34 <adu> OceanSpray: its up to you
22:15:55 <Cale> adu: This is an external library.
22:15:59 <adu> o hehe
22:16:01 <adu> sory
22:16:25 <Cale> I believe 255 is opaque, I might be wrong...
22:16:39 <Cale> I'd have to go look up the Imlib 2 documentation to be sure.
22:17:35 <Cale> ah, A is last.
22:18:37 <Cale> er, no
22:18:39 <Cale> heh
22:18:43 <Cale> data ImlibColor = ImlibColor Word32 Word32 Word32 Word32 deriving (Show, Eq) -- alpha, red, green, blue
22:18:50 <solrize> Concurrent threads don't carry on running when GHCi is waiting for input.
22:18:50 <solrize>     No, they don't. This is because the Haskell binding to the GNU readline library doesn't support reading from the terminal in a non-blocking way, which is required to work properly with GHC's concurrency model.
22:19:00 <solrize> why not run readline in a separate OS thread?
22:19:08 <gwern> Cale: someone needs some type synonynms!
22:19:32 <wli> solrize: I've been burned by that, too.
22:19:42 <Cale> gwern: It's the old version of my library, and I'm not maintaining it :)
22:19:57 <Cale> gwern: But I've still got to release the new version :)
22:20:02 * gwern wuz jes' sayin'
22:20:07 <gwern> Cale: you naughty person
22:20:14 <gwern> I hope the code is clearer in the new one
22:20:22 <Cale> Yeah, also there's Haddock.
22:20:39 <OceanSpray> " Couldn't match expected type `GHC.Word.Word32'
22:20:39 <OceanSpray>            against inferred type `Double'
22:20:39 <OceanSpray>     In the second argument of `ImlibColor', namely `(r * 255)'"
22:21:02 <Cale> OceanSpray: right. round will work.
22:21:11 <Cale> :t round
22:21:13 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
22:21:53 <gwern> wait - Cale, didn't you tell me a while back you had no unreleased libraries or apps?
22:21:57 * gwern feels lied to
22:22:02 <mofmog> so apparently ^ doesnt work on doubles
22:22:06 <Cale> gwern: It's not usable yet.
22:22:36 <Cale> gwern: I have about 50% of the API bound. It's just so incredibly tedious to do.
22:22:45 <Cale> (especially with documentation)
22:23:04 <gwern> Cale: so... you're either a liar or lazy?
22:23:05 <OceanSpray> "/usr/bin/ld: cannot find -lImlib2
22:23:05 <OceanSpray> "
22:23:11 <Cale> gwern: hm?
22:23:25 <Cale> gwern: I have *lots* of code which I haven't released.
22:23:36 <Cale> gwern: Most of it is in a not-so-usable form.
22:23:36 * gwern was joking, sheesh
22:23:59 <Cale> You've already got everything of mine which is remotely releasable :)
22:24:17 <OceanSpray> oh wow
22:26:54 <OceanSpray> well, I do have an image, but...
22:26:55 <gwern> well, if you say so
22:26:55 <Cale> OceanSpray: perhaps try permuting the channels.
22:26:55 <Cale> OceanSpray: what did you save as?
22:26:55 <OceanSpray> >> saveImage "out.png"
22:26:55 <Cale> okay
22:26:55 <Cale> What did you get?
22:26:55 <OceanSpray> that works?
22:26:55 <OceanSpray> some weird lookin' thing
22:26:55 <Cale> It should, after the contextSetImage
22:26:55 <Cale> Can I see it?
22:26:55 <OceanSpray> I need some place to put it
22:26:55 <OceanSpray> or...
22:27:02 <Cale> don't know if DCC will work, we can try it :)
22:27:05 <Cale> ...
22:27:08 <Cale> doesn't seem to be
22:27:11 <OceanSpray> orz
22:28:30 <OceanSpray> http://img32.picoodle.com/img/img32/4/3/11/t_outm_13eb862.png
22:28:40 <Cale> okay
22:28:46 <Cale> What's it supposed to look like?
22:29:08 <OceanSpray> I have a sphere and a plane, both 0.5 reflective, and the camera is facing the plane with the sphere behind the camera
22:29:25 <OceanSpray> two lights, one at the origin, one right in front of the plane.
22:29:37 <Cale> hmm
22:30:00 <OceanSpray> hey, at least I got something.
22:30:09 <OceanSpray> but this ain't what it's supposed to look like.
22:30:36 <Cale> do some tests with all red, all green and all blue images, just to make sure
22:30:43 <mofmog> what does  No instance for (Integral Float)
22:30:43 <mofmog>  mean
22:30:59 <Cale> mofmog: Usually that you tried to use a Float as an integer-like thing.
22:31:13 <Cale> mofmog: What are you trying to do?
22:31:37 <mofmog> \(x:y:xs) -> (mod (truncate x) (truncate y))
22:31:45 <mofmog> where x and y should come in as floats
22:31:45 <Cale> :t truncate
22:31:46 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
22:32:01 <Cale> hmm
22:32:17 <Cale> :t \(x:y:xs) -> (mod (truncate x) (truncate y))
22:32:18 <lambdabot> forall t b. (Integral b, RealFrac t) => [t] -> b
22:32:23 <Cale> Well, that's not the problem.
22:32:51 <hpaste>  mofmog pasted "code" at http://hpaste.org/6298
22:33:15 <OceanSpray> http://img155.imageshack.us/img155/4268/outqb7.png
22:33:16 <mofmog> the error is:arising from use of `mod' at calcsrc.hs:67:35-57
22:33:21 <OceanSpray> this is what I got with blue.
22:33:24 <wli> Is there supposed to be a binary or script with the filename "cabal" ?
22:33:43 <Cale> OceanSpray: okay, are red and green right?
22:33:53 <OceanSpray> somewhat
22:34:07 <Cale> OceanSpray: hmm
22:34:24 <Cale> OceanSpray: one of the channels is alpha, and you'll get a black image like that if you use it.
22:34:28 <gwern> wli: there should be <pkgname>.cabal and a Setup.[l]hs if packaged normally
22:34:39 <Cale> hmm
22:34:43 <wli> gwern: For the cabal distro package itself?
22:34:51 <Cale> It *really* looks like alpha is the first channel.
22:35:04 <Cale> Let me try :)
22:35:17 <OceanSpray> you want the source?
22:35:31 <OceanSpray> @hpaste
22:35:31 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:35:39 <gwern> wli: I think cabal is cabalized
22:35:50 <wli> gwern: I'm trying to invoke it.
22:35:56 <OceanSpray> And chickens come out of eggs.
22:35:59 <gwern> at least, I've always installed cabal from its darcs repo through cabal
22:36:26 <hpaste>  OceanSpray pasted "raytracer" at http://hpaste.org/6299
22:36:32 <wli> I emerged cabal. I don't see any executable file named "cabal" on my system.
22:36:46 <glguy> (it doesn't come with one)
22:36:59 <hpaste>  OceanSpray annotated "raytracer" with "continued" at http://hpaste.org/6299#a1
22:37:18 <gwern> wli: oh, you need to runhaskell Setup <command>
22:37:24 <gwern> unless it's a quite recent cabal
22:37:38 <OceanSpray> Cale, there it is.
22:37:39 <wli> gwern: I emerged current darcs.
22:38:27 <gwern> gentoo?
22:38:30 <wli> Yes.
22:38:47 * gwern will try an emerge of dev-haskell/cabal-darcs-0 then too
22:39:30 <wli> It seems to emerge okay. It's just not obvious what on earth to do with it. There's no program called "cabal" to invoke.
22:40:25 <OceanSpray> have you looked in places other than /usr/bin ?
22:40:31 <Cale> OceanSpray: hmm
22:40:38 <Cale> OceanSpray: Okay, it's ARGB for sure.
22:41:00 <wli> OceanSpray: I've been looking.
22:41:27 <Cale> OceanSpray: I don't see anything obviously wrong with your imlib code.
22:41:31 <OceanSpray> oh?
22:41:56 <mofmog> geez, why the heck is ghc yelling at me
22:41:57 <mofmog> -_-
22:42:14 <wli> OceanSpray: Just a couple of weird things under hugs packaging and doc directories.
22:42:18 <Cale> What is viewTrace giving you there?
22:42:28 <glguy> cabal doesn't come with an executable, even in darcs
22:42:41 <glguy> the Cabal.cabal only lists the library
22:42:42 <OceanSpray> Cale, what do you mean?
22:42:43 <wli> Then I'm utterly clueless as to what cabal is.
22:42:44 <Cale> (that is, look at the individual array elements and check that they're actually blue)
22:42:55 <glguy> wli: cabal is a library used ot build packages
22:43:06 <glguy> wli: individual packages that use it will provide a "Setup.hs"
22:43:10 <glguy> which is a stub program
22:43:15 <Cale> OceanSpray: what colour are your lights?
22:43:19 <glguy> which runs a main function from the library
22:43:24 <glguy> that handles builds and installs
22:43:31 <wli> Then what's all this stuff about cabal-install etc.?
22:43:38 <OceanSpray> hold on, lemme try another render
22:43:38 <glguy> that's a different project
22:43:45 <Cale> OceanSpray: A perfectly blue surface will absorb all red and green light.
22:43:48 <gwern> glguy: are you sure? I have darcs cabal installed, i often run 'cabal check', and 'which cabal' gives me '/home/gwern/bin/bin/cabal', '/home/gwern/bin/bin/cabal: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), for GNU/Linux 2.6.9, dynamically linked (uses shared libs), not stripped'
22:43:50 <glguy> it's a different tool that installs packages using the cabal stuff
22:43:57 <gwern> I am pretty sure there is a cabal executbale
22:44:08 <glguy> gwern: not in the cabal repository
22:44:14 <glguy> gwern: might be osmething with cabal-install
22:44:21 <glguy> but that's an independent project
22:44:31 <wli> I don't have a cabal executable to invoke with "cabal install cabal-install"
22:44:46 <gwern> wli: bootstrapping is always a difficult problem...
22:44:47 <Cale> I'll try your code now :)
22:45:21 <glguy> wli: I came late to the discussion, what are you trying to do?
22:45:43 <OceanSpray> http://img258.imageshack.us/img258/1977/outpq0.png
22:45:59 <OceanSpray> this is what I got with a blue sphere right in front of the camera, white light
22:45:59 <Cale> OceanSpray: looking sane :)
22:46:14 <hpaste>  solrize pasted "should this really be IO?  and how do i quickcheck it?" at http://hpaste.org/6300
22:46:44 <glguy> gwern: http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
22:46:46 <lambdabot> Title: CabalInstall - Hackage - Trac
22:46:48 <dibblego> solrize, why use return there?
22:46:51 <glguy> gwern: that's what provides the "cabal" executable
22:46:56 <Nafai> Interesting...the Clean compiler can compile Haskell 98 code
22:47:00 <OceanSpray> red and green work out fine.
22:47:07 <solrize> dibblego how else do i lift the value to IO?
22:47:26 <dibblego> solrize, you can put it in IO further up e.g. when you print the result?
22:47:28 <solrize> heh, the 13/-13 should say k /-k
22:47:41 <dibblego> solrize, shouldn't encrypt/decrypt be pure?
22:47:42 <solrize> dibblego i'm wondering about this
22:47:51 <solrize> dibblego, i'm not sure they should be pure, see the comment
22:47:57 <Cale> solrize: Encryption with a real algorithm *would* be referentially transparent, it would just take an input stream of randomly generated values.
22:48:00 <solrize> encryption is not pure
22:48:01 <dibblego> solrize, I would suggest no
22:48:22 <Cale> solrize: Yes it is, it is a mathematical function.
22:48:22 <dibblego> why not?
22:48:29 <Cale> solrize: All mathematical functions are pure.
22:48:46 <solrize> cale, no, really, it's not a mathematical function, if i encrypt the word "cheese" 20 times then i want to get back 20 different results
22:48:53 <Cale> No you don't.
22:48:53 <solrize> or else the attacker can tell that the plaintext was the same every time
22:49:09 <solrize> decryption is in some sense pure
22:49:09 <glguy> solrize: it's pure because the key is ont of hte function parameters
22:49:22 <Cale> You could never decrypt it then.
22:49:34 <dibblego> solrize, if it weren't pure, you couldn't decrypt
22:49:42 <glguy> turning meaningful data into random data doesn't need purity though :)
22:49:42 <dibblego> solrize, in which case, it is not encryption
22:49:42 <solrize> cale yes of course i could decrypt it, the decryption function is many-to-one
22:49:45 <Cale> Any "random" data should be viewed as an *input* to the algorithm.
22:49:51 <dibblego> solrize, therefore, encryption is pure. - QEA
22:50:09 <solrize> cale, ok, so encryption should take its random IV as an input arg
22:50:18 <Cale> Yeah.
22:50:34 <OceanSpray> It seems that I have my x and y pixels mixed up.
22:50:36 <solrize> but i think encryption still is not pure, because the function might do i/o
22:50:38 <dibblego> what is it you put at the end of a reductio ad absurdum? QE? something
22:50:51 <solrize> maybe i should use unsafePerformIO for that?
22:51:31 <glguy> solrize: it sounds like you are getting ahead of yourself here
22:51:49 <Cale> solrize: It really shouldn't do I/O
22:52:14 <solrize> cale yes the i/o is because the actual encryption might be done by a separate hardware device
22:52:25 <Cale> solrize: Well, in that case, that's I/O.
22:52:28 <solrize> yes :)
22:52:31 <Cale> But it's not exactly your code.
22:52:32 <wli> dibblego: "... which is absurd."
22:52:34 <dibblego> solrize, in which case, the sending and reading of the data is in IO
22:52:46 <solrize> cale yeah i just wrote trivial example code
22:52:49 <dibblego> wli, there is a QE? (B maybe?)
22:53:07 <Cale> solrize: If you're implementing crypto, you'll have it be pure.
22:53:13 <solrize> dibblego i think you'd just conclude "which is absurd, so the premise must be false, QED"
22:53:15 <dibblego> wli, it is QEA
22:53:25 <solrize> cale so how would i do the i/o ?
22:53:26 <dibblego> * quod est absurdum (Q.E.A.)
22:53:29 <wli> dibblego: There's no QED variant that I'm aware of. I've never seen QEA.
22:53:40 <Cale> solrize: If you're communicating with Mr. Crypto, then you'd be in IO.
22:53:45 <solrize> yes
22:53:45 <dibblego> I was right first time ;)
22:53:57 <Cale> There's a difference between the two.
22:54:01 <glguy> solrize: which has nothing to do with crypto algorithms :)
22:54:28 <solrize> well, i want an application to be able to say "encrypt this string" without knowing whether there's i/o under the hood, or just a subroutine
22:54:31 <Cale> You can't tell what Mr. Crypto is doing, and it might not be referentially transparent, so it doesn't get as nice a type.
22:54:36 <solrize> i.e. i'm tryign to write an API, not an algorithm
22:55:12 <solrize> mr. crypto might be returning AES(k,x) which is a pure function , but evaluated on the remote hardware
22:55:43 <Cale> Okay, in that case, you might import the necessary FFI calls as pure, or use unsafePerformIO somewhere.
22:56:13 <Cale> But otherwise, you'd just use IO.
22:56:14 <solrize> i think i wouldn't need ffi, right?  it would just be normal unix i/o
22:56:21 <Cale> Possibly.
22:57:18 <Cale> Also, I'd recommend using Data.ByteString for this.
22:57:18 <solrize> ok, so the way the function is written, it uses IO, hmm i think i see the answer to my next question about how to quickcheck
22:57:40 <solrize> cale, yeah, i should use data.bytestring, i'm not seriously coding yet, just tryign to get a sense of what the thing will eventually look like
22:57:52 <solrize> this will be similar to a python lib i wrote a while back
22:57:54 <Cale> There might be a quickcheck which allows for IO, but the usual one doesn't.
22:57:58 <solrize> but with types ;)
22:58:13 <solrize> is it possible to compare two IO strings ?
22:58:32 <Cale> No, you have to execute them first, and compare the results.
22:58:45 <solrize> you can execute an io string?
22:58:52 <shachaf> @ty liftM2 (==)
22:58:54 <lambdabot> forall a1 (m :: * -> *). (Monad m, Eq a1) => m a1 -> m a1 -> m Bool
22:59:12 <Cale> A value of type (IO String) is an action, which if executed, would produce a string.
22:59:24 <solrize> wow
22:59:27 <solrize> Prelude Control.Monad> liftM2 (==) ((return 3)::IO Int)  (return 4)
22:59:27 <solrize> False
22:59:32 <solrize> cool i had no idea i could do that
22:59:36 <solrize> it solves my problem i guess
22:59:40 <shachaf> @src liftM2
22:59:40 <solrize> and i can quickcheck that
22:59:40 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
23:00:03 <Cale> liftM2 just constructs the action which runs the two actions and applies the function to them.
23:00:07 <solrize> > liftM2 (==) ((return 3)::IO Int)  (return 4)
23:00:08 <lambdabot>  <IO Bool>
23:00:10 <gwern> HUnit might be enough - iirc, it allows IO
23:00:18 <solrize> > print $ liftM2 (==) ((return 3)::IO Int)  (return 4)
23:00:19 <lambdabot>  <IO ()>
23:00:21 <solrize> hah
23:00:47 <Cale> lambdabot won't execute the IO action, only (possibly) evaluate it and then print a thing showing its type.
23:00:51 <shachaf> > liftM2 (==) (return 3 :: Maybe Int) (return 4)
23:00:51 <lambdabot>  Just False
23:01:36 <ohub> @where plugins
23:01:36 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
23:01:43 <Cale> IO actions are effectively inert under usual Haskell evaluation.
23:02:44 <Cale> There are various devices for combining them, but other than that, they just sit there. The only action which really executes in a compiled Haskell program is main, which is itself going to be built up from other IO actions.
23:02:59 <Cale> (and that's done by the runtime system)
23:03:19 <shachaf> Cale: Just sit there, as opposed to any other Haskell value? :-)
23:03:19 <solrize> right i guess i can't actually execute the IO String except in the IO monad
23:03:27 <BMeph> Heh - languages that use "quoting" were obviously trying to invent the IO monad, before they understood monads. :)
23:03:31 <Cale> Well, you can't look at them.
23:04:08 <Cale> shachaf: Normally, haskell expressions evaluate down to values. In the case of IO, it's not really possible to tell the difference between "evaluated" and "not evaluated"
23:04:21 <Cale> solrize: right.
23:04:53 <shachaf> Cale: They only evaluate down to values when an IO action tells them to. :-)
23:04:57 <gwern> @where haskelldb
23:04:57 <lambdabot> http://haskelldb.sourceforge.net/
23:05:38 <Cale> shachaf: Well, when the runtime system decides it needs to execute one. But it's essentially like all the primitive IO actions are constructors, and so is bind.
23:05:55 <OceanSpray> I can sort of see where the problem is...
23:06:04 <Cale> OceanSpray: hmm?
23:06:39 <Cale> OceanSpray: Let me see if I can construct one of my favourite scenes. :)
23:06:49 <OceanSpray> http://img139.imageshack.us/img139/3926/outrd2.png
23:07:00 <OceanSpray> see all that red noise?
23:07:07 <OceanSpray> that's where shadows are supposed to be.
23:07:28 <Cale> mm
23:07:38 <solrize> hmm, looks like my ghc installation is missing a bunch of libraries.  i wonder if i did a reduced install or something.  i don't have quickcheck :(
23:07:52 <Cale> OceanSpray: looks like maybe you're producing values larger than 1
23:08:01 <Cale> or perhaps negative values?
23:08:09 <OceanSpray> somehow, when a ray hits somewhere that is supposed to be occluded from a light by the same object it hits, I get that.
23:08:16 <OceanSpray> negative values?
23:08:22 <OceanSpray> what would that give me?
23:08:23 <Cale> Well, I'm not sure :)
23:08:32 <Cale> Oh, you'd get very large crap.
23:08:53 <Cale> > round (-2.5) :: Word32
23:08:54 <lambdabot>  4294967294
23:08:57 <Cale> like that
23:09:02 <OceanSpray> I see now.
23:09:12 <OceanSpray> :t abs
23:09:13 <lambdabot> forall a. (Num a) => a -> a
23:09:25 <Cale> (don't ask why Imlib2 uses Word32's for colour values, when it only really needs Word8's)
23:09:25 <OceanSpray> well, no
23:09:36 <Cale> You just want to clip.
23:09:42 <OceanSpray> yes
23:09:44 <Cale> max 0 (min 255 x)
23:09:57 <Cale> Or,  max 0 (min 1 x)
23:11:52 <OceanSpray> ah, much better.
23:12:16 <OceanSpray> http://img291.imageshack.us/img291/6369/outok9.png
23:12:18 <solrize> prop_RevRev xs = reverse (reverse xs) == xs
23:12:18 <solrize>   where types = xs::[Int]
23:12:29 <OceanSpray> but the reflections are still weird.
23:12:32 <solrize> what is the purpose of the "where" clause instead of just using a type annotation on prop_RevRev ?
23:13:20 <Cale> solrize: It's perhaps more convenient to let type inference do the rest of the work.
23:13:36 <solrize> hmm ok
23:16:06 <solrize> the manual is pretty good
23:17:38 <Cale> OceanSpray: can I have your current code?
23:17:45 <OceanSpray> sure
23:18:11 <OceanSpray> @hpaste
23:18:11 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:18:52 <hpaste>  OceanSpray annotated "raytracer" with "all that's changed." at http://hpaste.org/6299#a2
23:19:59 <Cale> hmmm...
23:22:20 <lekro> OceanSpray: I haven't read through everything but when you check a reflected ray for intersections with objects do you get intersections with the object that's responsible for the ray as well?
23:22:34 <lekro> OceanSpray: because then there might be a numerical issue
23:22:41 <OceanSpray> huh?
23:23:04 <OceanSpray> yeah, I check for reflections against every object.
23:23:06 <lekro> OceanSpray: like, your reflected ray starts exactly at some point on the surface of an object A.
23:23:16 <lekro> mathematically, there is an immediate hit at t = 0
23:23:23 <OceanSpray> I discard that.
23:23:29 <lekro> but numerically it might turn out to be at t = 1e-20
23:23:56 <OceanSpray> you're right.
23:23:58 <OceanSpray> shit.
23:25:15 <lekro> maybe I'm wrong, but checking for equality (what <= is in this case basically) with Doubles can be dangerous.
23:26:20 <OceanSpray> I replaced 0 with 1e-5
23:26:29 <OceanSpray> that fixed the reflections.
23:26:54 <lekro> good :)
23:27:33 <OceanSpray> what should the error ideally be?
23:27:46 <wli> This is why intervals with probability distributions on them would come in handy.
23:27:57 <wli> (a) you can disprove equality in the event the intervals are disjoint
23:29:16 <wli> (b) you can use statistical tests for probability of equality instead of pulled-out-of-your-arse numerical tolerances
23:30:07 <lekro> OceanSpray: another thing with your code: you are doing shadow ray intersections for lighting. but if the shadow ray and the normal vector point in different directions (i.e., their scalar product is negative), you probably don't want to test for intersections at all
23:30:29 <lekro> because the surface is facing away from the light source anyway
23:30:58 <Cale> heh, this scene is really taxing :)
23:31:08 <Cale> I hope I don't just get blackness this time
23:31:15 <Cale> ah, good :)
23:31:22 <Cale> check this out...
23:31:49 <Cale> http://cale.yi.org/autoshare/out.png
23:31:52 <Cale> Still lots of noise.
23:31:56 <OceanSpray> oh wow.
23:34:18 <solrize> does quickcheck actually care that the test function is called prop_whatever ?  i.e. is it using some kind of introspection like JUnit to find those tests?
23:34:35 <Cale> solrize: Only the quickcheck shell script does.
23:34:48 <solrize> ic, i didn't know about the shell script.  maybe there's some more docs around
23:34:51 <bos> does Setup.hs configure --user imply --prefix=$HOME?  i don't think it does.
23:34:53 <solrize> thanks
23:35:03 <glguy> bos doesn't
23:35:10 <bos> glguy: ok, thanks
23:35:39 <solrize> http://www.google.com/search?q="switch+from+python+to+haskell"  gets only one hit...
23:35:43 <Cale> hmm
23:35:51 <Cale> there's something odd about your view function, I think
23:35:51 <lament> that's because python is so much better!
23:35:59 <Cale> er, "newView"
23:36:05 <solrize> lament :)
23:36:18 <Cale> Maybe I'm just being dumb...
23:36:33 <dons> solrize: its an historical thing due to early QuickCheck having a standalone tool that scanned for prop_ functions
23:36:37 <glguy> solrize: and 0 hits the other way around
23:37:06 <dons> hey, john g. switched from python to haskell :)
23:37:14 <dons> and glguy's going the other way!
23:37:21 <solrize> hey dons :)
23:37:33 * glguy is out!
23:37:40 <lament> i switch from python to haskell and back about every 5 minutes
23:37:49 <lament> without writing a single line of code!
23:37:52 <dons> heh. you'll be trapped in a monad soon. no way out!
23:38:03 <solrize> dons i have a question about your multicore fibonacci thing, have you tried it with the cutover cranked up from 35 to maybe 38 or so, with 2 cores?  it looked like the 2-core speedup was pretty small
23:38:24 <lament> dons: nooo! i'll just use python's introspection to get me out.
23:38:28 <dons> only on a 4 core.
23:38:46 <dons> you can't call into python though. the types will prevent you
23:38:54 <solrize> dons i mean when you used -N2
23:39:15 <dons> oh, so it was something like 72 42 27 22s from 1 .. 4 cores
23:39:33 <solrize> 72 user, i.e. about 36 real x 2 cores
23:39:39 <solrize> no wait
23:39:48 <dons> no, wall clock
23:39:56 <solrize> naive = 39 sec
23:40:00 <dons> yeah
23:40:09 <solrize> N2 = 138 sec
23:40:15 <solrize> wait that's with no cutover
23:40:33 <solrize> cutoff=35 => 72 sec
23:40:41 <solrize> with N2
23:40:54 <solrize> arggh
23:40:56 <solrize> 37.866
23:40:57 <adu> are Haskell 'let's like let, let* or letrec in Scheme?
23:41:06 <dons> adu, yeah
23:41:14 <dons> letrec
23:41:15 <solrize> so slightly beating naive, that's what i remembered, so i wondered if it could do better with a slightly higher cutoff
23:41:17 <Cale> adu: letrec
23:41:17 <faxathisia> adu letrec
23:41:21 <adu> dons: ok
23:41:25 <solrize> and less thread creation
23:41:33 <lekro> not that I need it right now but is there a way to let the runtime figure out an appropriate number for -N?
23:41:45 <dons> solrize: possibly? i'm sure there's a bunch of tiny things you could tune to optimally parallelise it :)
23:41:52 <dons> lekro: there's a hook these days
23:42:04 <dons> so if you've some code that can figure out N, you can tell the rts
23:42:20 <dons> you can always find out N from the rts
23:42:27 <dons> s/always/also/
23:43:01 <OceanSpray> yo Cale
23:43:02 <lekro> what's this hook called?
23:43:04 <OceanSpray> http://pastebin.ca/939369
23:43:05 <solrize> is `par` actually launching new OS threads, or is it somehow making sparks and feeding them to long-running threads?
23:43:15 <dons> lekro: hmm, i've not tried it. check the mailing list.
23:43:24 <dons> solrize: sparks. feeding them to your N os threads
23:43:32 <dons> basically, thunks in a list in the runtime
23:43:40 <dons> that threads pick up and run as needed
23:43:41 <solrize> that makes sense
23:44:22 <OceanSpray> lekro, I followed your advice, but it produced a different image.
23:44:23 <solrize> still i'd hope for a lot more speedup with the right parameters
23:44:36 <Cale> cool :)
23:44:50 <dons> solrize: yeah, if you can keep your N threads running at full space, and not spark more than needed
23:44:55 <OceanSpray> only slightly modified.
23:45:04 <dons> i think a lot of parallel magic is hunting down the right magic strategy
23:45:25 <solrize> well simply cranking the cutoff slightly higher would make less sparks, so i wondered if that would improve it
23:45:40 <dons> would be interesting to identify the optimal par strategy for fibonacci :)
23:45:45 <solrize> hee
23:46:08 <adu> how do you replace the n-th element of a list?
23:46:15 <dons> its a bit like strictness hints
23:46:32 <dons> there's a lot of possible reduction orders, some better than others. you can always play the game of find the best reduction strategy
23:46:37 <dons> and now ... in parallel!
23:46:51 <faxathisia> @hoogle index
23:46:51 <lambdabot> Data.Ix.index :: Ix a => (a, a) -> a -> Int
23:46:51 <lambdabot> Data.ByteString.index :: ByteString -> Int -> Word8
23:46:51 <lambdabot> Data.Sequence.index :: Seq a -> Int -> a
23:46:54 <lekro> OceanSpray: different in what sense? I guess you don't even need this check now that you fixed that numerical error
23:46:57 <dons> haskell's just a cute notation for programming threads :)
23:47:01 <solrize> dons, hmm, yeah i guess it's complicated
23:48:09 <lekro> OceanSpray: and scalarProduct normal shadowRay <= 0 might have again the same issues with equality on Doubles
23:48:19 <dons> well, at least we get to choose, eh, solrize ?
23:48:26 <dons> what is needed is some profile guided feedback
23:48:29 <dons> about what thunks cost what
23:48:30 <OceanSpray> yes...
23:48:35 <dons> then use that to work out what to spark
23:48:36 <faxathisia> :t let modify list idx f = take idx list ++ [f (list !! idx)] ++ drop (idx+1) list in modfif
23:48:37 <lambdabot> Not in scope: `modfif'
23:48:41 <solrize> wow, that would be really cool
23:48:45 <faxathisia> @let modify list idx f = take idx list ++ [f (list !! idx)] ++ drop (idx+1) list
23:48:45 <lambdabot> Defined.
23:48:56 <faxathisia> > modify [1,2,3] 1 (+5)
23:48:56 <lambdabot> Terminated
23:49:11 <faxathisia> adu: I thought.. you could do it like that..
23:49:31 <adu> faxathisia: I suppose so, I thought there must be a combinator for that...
23:49:39 <adu> like (//) for arrays
23:49:52 <faxathisia> what should it be
23:50:11 <lekro> OceanSpray: the last time I wrote a raytracer I just ignored that and claimed it to be a feature: "doubly illuminated surfaces". ;)
23:50:21 <OceanSpray> lol
23:50:42 <lekro> OceanSpray: you should only see a difference when you have non-closed objects anyway
23:51:13 <lekro> OceanSpray: otherwise the shadow ray will be inside the object and eventually hit the object again
23:51:18 <faxathisia> adu: let (list,idx) >-- f = take idx list ++ [f (list !! idx)] ++ drop (idx+1) list
23:51:25 <faxathisia> > ([1,2,3], 1) >-- (+1)
23:51:25 <faxathisia> [1,3,3]
23:51:25 <lambdabot>   Not in scope: `>--'
23:51:34 <Cale> hmm
23:52:23 <OceanSpray> those artifacts on the left are really weird.
23:52:42 <lekro> OceanSpray: what image are you referring to?
23:53:01 <OceanSpray> oh whoops
23:53:28 <OceanSpray> http://img505.imageshack.us/img505/6458/outie6.png
23:54:43 <OceanSpray> I'm going to sleep
23:55:01 <OceanSpray> thank you and goodnight.
23:55:04 <Cale> OceanSpray: Hmm, if I want the camera to look from (1,1,1) toward (0,0,0), that would be Ray (1,1,1) (-1,-1,-1), no?
23:55:45 <faxathisia> seems you lack a variable? (where is up?)
23:55:56 <Cale> I don't care which way is up :)
23:56:02 <faxathisia> hehe
23:56:11 <Cale> (I'm talking about the parameter to the newView function)
23:58:57 <BMeph> > mapX gcd id [20,19..1]
23:58:58 <lambdabot>  [1,2,1,4,5,2,1,4,1,10,1,4,1,2,5,4,1,2,1]
23:59:19 <faxathisia> @src mapX
23:59:19 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
23:59:22 <Cale> aha!
23:59:25 <Cale> There was a bug :)
23:59:40 <Cale> er..
23:59:58 <adu> faxathisia: i think i got it
