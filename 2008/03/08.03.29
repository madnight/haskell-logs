03:38:30 <desegnis> For the first time I succeeded in compiling wxhaskell, but now I get errors when linking Hello World... Probably a versioning issue. Anybody willing to make guesses?
03:39:36 <hpaste>  desegnis pasted "wxhaskell linker error" at http://hpaste.org/6705
03:42:08 <kowey> desegnis: have a look at http://www.haskell.org/haskellwiki/WxHaskell/Install
03:42:08 <lambdabot> Title: WxHaskell/Install - HaskellWiki
03:42:15 <kowey> what version of wxhaskell?
03:42:26 <kowey> 0.10.3 no longer requires the --with-opengl flag
03:43:03 <kowey> ah! 0.10.2 (sorry, I didn't notice)... yes, please upgrade
03:43:50 <desegnis> kowey: Ah, I didn't notice there's a new version available (got 0.10.2 from hackage)
03:44:01 <desegnis> Alright, I'll try that
03:44:34 <kowey> yep! (nb, if you're installing via cabal-install, you may have to sudo cabal install wxcore (I forget why))
03:45:17 <desegnis> ah, I found the notice on the wiki page you mentioned :)
03:46:50 <desegnis> Turns out I just needed to cabal update
03:48:24 <kowey> see also Autoforms, XTC and wxFruit, which all seem to work fine from cabal (with my 'sudo' caveat for wxcore)
03:49:04 <kowey> haven't yet worked out why Phooey/GuiTV doesn't work for textEntry (it does for the slider widget) under MacOS X
03:49:23 <desegnis> Hm, I used cabal fetch and built manually because cabal install would just do the configure step for me
03:49:38 <kowey> ah, you need the latest version of cabal-install (see the wiki page)
03:49:46 <kowey> I don't really know why, but it fixes the problem
03:50:31 <desegnis> ah, heh, versioning hell in ghc-cabal-wx-gtk land :)
03:51:11 <kowey> I'm really glad it exists anyway (despite these hiccups).... one day installing Haskell stuff is going to be super-easy for the masses
03:51:17 * Baughn wonders if cabal should have a separate API-version tag
03:51:29 <hcube> hi, i have questions: where can i find papers about lazy functional language compilation. i've found one it's about GRIN (Graph Reduction Internal Notation), but it is from 1999, is there any newer one ?
03:52:15 <desegnis> kowey, d'oh, I'm realizing there's an up-to-date *.deb package out there :)
03:52:39 <kowey> err, yes! sorry I should have pointed that out
03:52:50 <kowey> note the version for ghc 6.8.2 and ghc 6.6
03:52:57 <desegnis> bah, once I'm compiling, I'll compile up to the end
03:53:22 <kowey> (we haven't yet sent out our official release announcement, but after many dormant years, there is indeed a new official wxhaskell release)
03:53:27 <MarcWeber> @seen beschmi
03:53:27 <lambdabot> I haven't seen beschmi.
03:53:57 <hcube> and i'd like to participate to gsoc 2008, which haskell idea is for newbies ?
03:54:27 <hcube> i know haskell, and i have solid programming experienece
03:56:41 <desegnis> hcube, I think the application deadline is on Monday or so? hurry up :)
03:57:19 <desegnis> hcube, and see #haskell-soc (there are some useful links in its topic)
04:04:32 <desegnis> kowey: Whooey, success! thanks
04:04:59 <kowey> great! bug reports (and samples - see bugs/) always welcome
04:21:01 <rhz__> Does anyone know how to use par to generate multiprocessor utilising binaries?
04:24:26 <desegnis> rhz__: Consider http://haskell.org/ghc/docs/latest/html/users_guide/using-smp.html
04:24:28 <lambdabot> Title: 5.12. Using SMP parallelism, http://tinyurl.com/34yvow
04:25:27 <desegnis> That page is about the needed ghc and RTS flags
04:27:35 <rhz__> desegnis: I know. I've been using those flags but it doesn't seem to make any difference
04:28:35 <qwr> ,,,,,,,,,,,,343
04:28:36 <qwr> 1',-2-+
04:28:41 <desegnis> rhz__: Does it make a difference for the nfib example in the ghc manual?
04:28:44 <qwr> damn
04:30:29 <desegnis> rhz__: Or can you reproduce the example on dons' blog?
04:30:30 <rhz__> i'll see..
04:34:27 <rhz__> yes the nfib example does appear to use both cpus
04:34:43 <rhz__> i guess i was doing something wrong..
04:38:14 <rhz__> but I don't see what.
04:53:52 <rhz__> ah got it.
04:54:13 <matthew-_> grr. -i doesn't like ~/
04:56:33 <quicksilver> ~/ is your shells responsibility
04:56:38 * quicksilver isn't sure what matthew-_ means by -i
04:56:58 <matthew-_> ghci -i~/foo does not work ghci -i/home/matthew/foo does work
04:57:10 <quicksilver> that's your shell's responsibility
04:57:15 <matthew-_> yeah, fair enough
04:57:17 <quicksilver> try leaving a space between the i and the ~
04:57:28 <matthew-_> nah, then ghc misinterprets it
04:57:33 <matthew-_> it treats it as a module name
04:57:48 <matthew-_> -i exists on its own to empty the import dir list
04:57:55 * quicksilver nods
04:58:45 <visq> hi, I'd need some hints for improving a DSL for generating SMT problems
04:59:02 <visq> It's for the yices SMT solver
04:59:11 <Heffalump> SMT?
04:59:21 <visq> My current attempt is at http://www.sivity.net/projects/yices-hs/browser/BinarySearch1.pdf?format=raw, if someone has some time for a quick look
04:59:28 <lambdabot> http://tinyurl.com/34vuvs
04:59:38 <visq> Sat Modulo Theories
05:00:01 <visq> http://yices.csl.sri.com/index.shtml
05:00:02 <lambdabot> Title: Yices: An SMT Solver
05:01:37 <Heffalump> you seem to have to use a lot of strings, which is a shame
05:02:05 <Heffalump> couldn't you deduce the assertPostcondition strings from the actual post conditions and the variable names you have already supplied?
05:02:21 <visq> Ah yes, that's an good idea, thanks
05:02:50 <visq> Strings are somewhat sensible for variables as I want to produce a human-readable file
05:03:07 <Heffalump> having to give concrete names to variables is a nuisance. We wound up using a pre-processor to insert those automatically on one project I've worked on.
05:03:26 <Heffalump> which is also a pretty poor solution, but more user-friendly
05:05:01 <Heffalump> we also hid the standard boolean operators and implemented our own type class that was overloaded on the return type too
05:06:09 <visq> Unfortunately I didn't manage to type the DSL's expressions
05:06:13 <Heffalump> what is the type of declareVariable?
05:06:17 <Heffalump> ah, I was about to ask about that.
05:06:28 <visq> It has uninterpreted functions, anonymous records and tuples, recursive datatypes
05:06:32 <Heffalump> if you can embed them in Haskell types then type inference would remove the need for intType etc
05:06:44 <Heffalump> "uninterpreted functions"?
05:08:30 <visq> well, they represent an arbitrary function without fixed meaning
05:09:45 <visq> constraints are used to restrict the possible behaviour of the function
05:10:53 <Heffalump> I still don't follow
05:11:35 <visq> ok, a SMT problem would e.g. be (define f::int->int) (assert (f 0) 0)
05:11:57 <visq> This is satisfiable, and every interpretation in which f(0) = 0 is a model
05:12:39 <Heffalump> ah, I see
05:12:54 <visq> But the behaviour of f is unspecified in general, so f is called an uninterpeted function
05:13:07 <visq> while (*) or (+) are interpreted functions
05:13:17 <Heffalump> and your DSL is for defining the functions and the constraints?
05:13:45 <visq> Yes, look at the end of the pdf. There is the generated program resulting from 'BinarySearch'
05:14:10 <Heffalump> what are push and pop?
05:14:20 <visq> context save and restore
05:14:28 <visq> the solver is incremental
05:14:40 <visq> and supports backtracking to a previous state
05:15:32 <visq> Using haskell datatypes for recursive datatypes, records and tuples would be worth trying
05:16:17 <Heffalump> you can represent functions abstractly too, but you obviously can't apply them directly then
05:16:55 <visq> Still, I didn't manage to type record expressions. Hint ?
05:17:01 <Heffalump> but actually you might be able to turn the abstract ones into real functions by eta-expanding them
05:17:19 <Heffalump> what do your record expressions look like?
05:17:30 <visq> functions are not so hard, but anonymous records are
05:17:31 <Heffalump> Haskell lacks extensible records so it might be tricky.
05:17:45 <Heffalump> HaskellDB makes an attempt, though it's a bit ugly.
05:18:09 <Heffalump> what are the field selectors, strings?
05:18:10 <visq> (define r::(a::int b::int)) (assert (0 = (select a r)))
05:18:20 <visq> yes
05:18:43 <Heffalump> haskellDB makes you declare them as datatypes first
05:18:47 <visq> and records are anonymous, like tuples
05:19:07 <Heffalump> you could always just encode them as tuples
05:19:13 <Heffalump> where you store the fields too
05:19:20 <Heffalump> but you wouldn't get much type safety then
05:20:06 <visq> yes. the language is typesafe, just the DSL isn't.
05:21:02 <Heffalump> well, it's just that you'd lose the safety of having GHC check the record usage for you
05:21:21 <Heffalump> you could always decide to force people to declare Haskell records if they want to use records in the DSL
05:21:27 <visq> Right
05:21:44 <Heffalump> then with an appropriate typeclass you could generate the field names for the anonymous ones in the target language
05:24:04 <visq> I'll try it, thanks a lot. But I think I will keep string names for variables, preprocessing is to much effort.
05:25:21 <Heffalump> fair enough
05:26:17 <visq> Did you like the operators chosen, like === ?
05:27:12 <Heffalump> whatever suits you, really. As I said, one option is to hide and redefine the "normal" operators.
05:28:39 <visq> ok
05:31:41 <visq> same project, slightly different aspect: Is there a portable way to strip symbols from a library (get rid of gmp symbols) ?
05:32:08 <Heffalump> strip isn't portable?
05:32:38 <visq> (the program) strip didn't work for me
05:33:05 <Heffalump> no idea then
05:33:32 <visq> i had to extract the static archive, and the link again, with gmp symbols hidden, and then strip non-exported symbols from the library
05:33:56 <visq> its one way to get gmp-dependent libraries running with ghc
05:34:09 <Heffalump> without them sharing the same gmp as ghc?
05:34:14 <vixey> @@ @pl ?djinn (a,b,c,d)->((d,c),(b,a))
05:34:14 <lambdabot>  (line 1, column 16):
05:34:14 <lambdabot> unexpected "="
05:34:14 <lambdabot> expecting variable, "(", operator or end of input
05:34:18 <vixey> @. @pl ?djinn (a,b,c,d)->((d,c),(b,a))
05:34:18 <lambdabot> Plugin `compose' failed with: Unknown command: "@pl"
05:34:23 <visq> yes
05:34:38 <visq> you link gmp statically and then strip the gmp symbols
05:34:51 <visq> i did it for the yices and parma polyhedral library libs
05:34:54 <Heffalump> there's some recent work on refactoring how ghc and gmp interact (to make it easier to use something else) that might be of some help
05:35:02 <Heffalump> but that's just a stab in the dark
05:35:44 <visq> well, I doubt there is a clean solution using system's gmp library...
05:36:21 <visq> as the allocator function is shared. But I'm interested in news !
05:37:20 <Heffalump> the refactoring might make it easier for your stripping process to fit in
05:37:32 <Heffalump> again I'm speculating wildly
05:38:08 <kpreid> vixey: no prefixes
05:38:13 <kpreid> @. pl djinn (a,b,c,d)->((d,c),(b,a))
05:38:13 <lambdabot> (line 1, column 16):
05:38:13 <lambdabot> unexpected "="
05:38:13 <lambdabot> expecting variable, "(", operator or end of input
05:38:38 <kpreid> vixey: (also often doesn't work because the syntax doesn't fit what pl knows)
05:38:47 <vixey> ok
05:39:12 <kpreid> @ djinn (a,b,c,d)->((d,c),(b,a))
05:39:15 <kpreid> @djinn (a,b,c,d)->((d,c),(b,a))
05:39:16 <lambdabot> f (a, b, c, d) = ((d, c), (b, a))
05:39:26 <kpreid> yeah, pl doesn't know >2-tuples
05:39:45 <visq> As far as I know, stripping is the only viable solution so far. Let's hope for improvements ...
05:40:10 <Peaker> hey hey this is a family channel
05:40:30 <Heffalump> so I shouldn't be IRCing just wearing a towel?
05:40:54 <Peaker> we don't need to know *that* :)
05:41:19 <Heffalump> I was just thinking about getting dressed, if that helps.
05:42:36 <vixey> ?djinn Maybe (Maybe (Maybe (Maybe (Maybe a)))) -> Maybe a
05:42:36 <lambdabot> f a =
05:42:36 <lambdabot>     case a of
05:42:36 <lambdabot>     Nothing -> Nothing
05:42:36 <lambdabot>     Just b -> case b of
05:42:36 <lambdabot>               Nothing -> Nothing
05:42:38 <lambdabot>               Just c -> case c of
05:42:40 <lambdabot>                         Nothing -> Nothing
05:42:42 <lambdabot>                         Just d -> case d of
05:42:44 <lambdabot>                                   Nothing -> Nothing
05:42:46 <lambdabot>                                   Just e -> e
05:43:04 <Heffalump> eww
05:43:09 <Heffalump> someone teach djinn about monads!
05:43:36 <Heffalump> @. pl djinn Maybe (Maybe (Maybe (Maybe (Maybe a)))) -> Maybe a
05:43:36 <lambdabot> (line 3, column 13):
05:43:36 <lambdabot> unexpected ">" or "-"
05:43:36 <lambdabot> expecting variable, "(", operator or end of input
05:43:44 <Heffalump> oh well
05:43:54 * Heffalump recommends join :-)
05:43:56 <olsner> or teach pl about case?
05:44:05 <Heffalump> yeah, that too
05:44:05 <vixey> :t (join.join.join)
05:44:07 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m (m (m a))) -> m a
05:44:24 <vixey> oh
05:44:58 * Peaker is trying to create the infrastructure required to have this work: someInteger = makeInt 5 ; myGui = widgetEditing someInteger ; main = guiMainLoop myGui
05:44:59 <vixey> :t case (join.join.join) of Nothing -> Nothing ; Just e -> e
05:44:59 <lambdabot>     Couldn't match expected type `m (m (m (m a))) -> m a'
05:44:59 <lambdabot>            against inferred type `Maybe a1'
05:44:59 <lambdabot>     In the pattern: Nothing
05:45:12 <vixey> :t \x -> case (join.join.join) x of Nothing -> Nothing ; Just e -> e
05:45:13 <lambdabot> forall a. Maybe (Maybe (Maybe (Maybe (Maybe a)))) -> Maybe a
05:45:21 <vixey> can you do it shorter?
05:45:41 <Heffalump> vixey: join.join.join.join ?
05:45:53 <olsner> :t join.join.join.join :: Maybe (Maybe (Maybe (Maybe (Maybe a)))) -> Maybe a
05:45:53 <lambdabot> forall a. Maybe (Maybe (Maybe (Maybe (Maybe a)))) -> Maybe a
05:46:09 <Heffalump> or do you actually want the constrained type?
05:46:35 <Peaker> why is it more constrained than join.join.join.join ?
05:47:04 <olsner> join.join works on any monad, the above only on Maybe
05:47:09 <Heffalump> Peaker: why is what more constrained, the one with the explicit case?
05:47:18 <Peaker> Heffalump, yeah
05:47:21 <Peaker> oh
05:47:22 <Peaker> I see
05:47:34 <Heffalump> so about your infrastructure, I don't follow what you are trying to do
05:47:37 <Peaker> you can use join.join... and constrain the type with a type tag?
05:47:39 <vixey> : Just.fromJust.fromJust.fromJust.fromJust.fromJust
05:47:44 <vixey> :t Just.fromJust.fromJust.fromJust.fromJust.fromJust
05:47:45 <lambdabot> Couldn't find qualified module.
05:47:54 <Peaker> Heffalump, I'm trying to create a declarative GUI thing
05:48:03 <vixey> :t (.)(Just)(fromJust.fromJust.fromJust.fromJust.fromJust)
05:48:04 <lambdabot> forall a. Maybe (Maybe (Maybe (Maybe (Maybe a)))) -> Maybe a
05:48:31 <Peaker> Heffalump, I declare the existance of a "mutable" int, and that there is a widget that edits it (which should be an integer editing widget, ofcourse)..
05:51:17 <Peaker> Heffalump, The idea is to later have richer data structures that can be edited, [de]serialized from files, etc
05:51:29 <Peaker> Heffalump, later those data structures are supposed to be a running Haskell program :-)
05:52:00 <ndm> Peaker: i looked into that kind of thing previously, its a nice idea
05:52:00 <Heffalump> oh, right.
05:52:14 <Heffalump> so a two stage sort of thing?
05:52:24 <Peaker> ndm, a declarative GUI like that you mean?
05:52:28 <Peaker> Heffalump, hah :-)
05:52:30 <ndm> Peaker: yes
05:52:37 <Heffalump> Peaker: hah?
05:52:58 <Heffalump> two-stage in the sense that you build a GUI using haskell and then run it as a separate stage
05:53:01 <ndm> Peaker: the idea was within PropLang, to have a property based workflow for the long running application windows, and a dialog one based on populating type structures for the second one
05:53:04 <Heffalump> which may or may not be Haskell
05:53:31 <ndm> i.e. when writing a text editor, the main window would be property based, the find dialog would be type population, like you are suggesting
05:53:31 <Peaker> Heffalump, I thought you meant something else (that first stage is to edit an int, then the second, a running Haskell program) and you made me laugh out quite badly :)
05:53:49 <ndm> @where proplang
05:53:49 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/proplang
05:54:00 <Peaker> Heffalump, well, ideally it would be running as Haskell too -> guiMainLoop would create a mainloop of type IO () from a GUI ()
05:54:14 <ndm> i never got the type editor off the ground in proplang, but did have a version in C# knocking around
05:54:55 <Peaker> ndm, I don't know if I like the idea of "dialogs" in a UI very much
05:55:10 <vixey> related http://www.youtube.com/watch?v=faJ8N0giqzw
05:55:11 <lambdabot> Title: YouTube - Tangible Functional Programming
05:55:39 <ndm> Peaker: they can be dialog widgets as panes in an interface, same thing at the coding level
05:56:07 <Heffalump> Peaker: you might be able to overload Num and avoid the need for makeInt
05:56:43 <Peaker> Heffalump, ok - I am wondering about how to do it at all..
05:56:48 <Peaker> Heffalump, being a newbie sucks :)
05:57:05 <Peaker> ndm, sounds cool-  though probably more of a challenge in Haskell than C# or such
05:57:21 <Heffalump> Peaker: I might be able to give you something useful to read on the subject on Thursday or so.
05:57:28 <Peaker> ndm, at least for those of us (me) who were conditioned in imperative languages for years
05:57:40 <Peaker> Heffalump, would be great, thanks
05:57:49 <ndm> Peaker: not really, C# required loads of reflection, and the combinators suffered horribly by not having high-order functions or the same level of type safety
05:58:02 * ndm smells an ICFP paper...
05:58:11 <Heffalump> just an experience report
05:58:19 <ndm> cool :)
05:58:22 <Heffalump> Peaker: you should look at Conal Elliott's paper from last ICFP, too
05:58:46 <vixey> and the presentation by Conal that I linked
05:59:00 <Heffalump> oh yes, I missed you doing that
05:59:03 <Peaker> "Functional Reactive Animation"?
05:59:09 <Heffalump> that's his older stuff, though also relevant
06:00:13 <phlpp> Peaker: you were btw. right
06:00:30 <Heffalump> he has a very declarative approach to doing things which is very nice, but perhaps not suited to everybody
06:00:35 <phlpp> Peaker: Integral[Sqrt[1-x^2], {x, -1, 1}] = Pi/2
06:01:02 <Peaker> phlpp, but its not very useful of that integral puts trig. into the equation :)
06:01:55 <phlpp> Peaker: indeed
06:02:24 <phlpp> Peaker: differentiating leeds to another integral :]
06:02:28 <vixey> hey!
06:02:48 <vixey> did anyone read this? http://portal.acm.org/citation.cfm?id=1244404
06:02:51 <lambdabot> Title: A reversible programming language and its invertible self-interpreter
06:02:55 <phlpp> 14:01:57 <phlpp> @math Integrate[Sqrt[1-x^2],x]
06:02:55 <phlpp> 14:01:59 <mbot> phlpp: (x*Sqrt[1 - x^2] + ArcSin[x])/2
06:02:55 <phlpp> 14:02:09 <phlpp> @math D[(x*Sqrt[1 - x^2] + ArcSin[x])/2, x]
06:02:56 <phlpp> 14:02:10 <mbot> phlpp: (1/Sqrt[1 - x^2] - x^2/Sqrt[1 - x^2] + Sqrt[1 - x^2])/2
06:03:38 <vixey> because I wrote an interpreter in Haskell for the language described in the paper but the self interpreter presented doesn't work :P
06:04:24 <vixey> I bet the paper is wrong..
06:04:59 <Peaker> arrg, ACM requires registration
06:05:06 <matthew-_> and money
06:05:19 <Heffalump> my work paid for a subscription :-)
06:05:34 <Heffalump> if you're at a uni they may well have a institutional DL subscription, too
06:05:50 <Heffalump> vixey: how do you know your interpreter isn't wrong? :-)
06:06:04 <vixey> Heffalump: It typechecks!
06:06:09 <Heffalump> I see...
06:06:23 <vixey> (also it does every other program I tried correctly)
06:07:17 <Peaker> vixey, thanks
06:07:59 <Heffalump> mail the authors
06:08:16 <Heffalump> they'd be pleased you're trying it
06:53:52 <Zao> http://www.gamedev.net/community/forums/topic.asp?topic_id=488374
06:53:53 <lambdabot> Title: Atanua - real time logic simulator - GameDev.Net Discussion Forums
06:53:53 <Zao> Neat.
06:54:07 <Zao> Oops, wrong channel :)
07:01:13 * EvilTerran reads it anyway
07:02:34 <Peaker> vixey, I am watching the video - its very cool - I see it as the same idea as subtext
07:02:55 <Peaker> vixey, if you generalize a bit - and its basically what I want to do too (so far)
07:09:51 <dcoutts> Lemmih, ping
07:09:59 <Lemmih> dcoutts: pong.
07:10:41 <kolmodin> hia
07:10:56 <dcoutts> Lemmih, I'm thinking of taking a tour on my way to Hac4 in Gothenburg
07:11:16 <dcoutts> since I will happen to be in northern France on the 7th
07:11:24 <kolmodin> oh, neat
07:11:33 <Lemmih> dcoutts: Oh, wanna come visit me in Copenhagen/Landskrona?
07:11:34 <dcoutts> Lemmih, and was thinking it'd be fun to drop in on kosmikus you and kolmodin
07:11:40 <dcoutts> and beg some floor space?
07:11:48 * dcoutts will bring his sleeping bag
07:12:06 <dcoutts> Lemmih, I'd love to, yes
07:12:22 <kolmodin> :)
07:12:44 <dcoutts> Lemmih, I've only ever zipped through Copenhagen before, was in the train station for half an hour and never saw the city
07:13:59 <kolmodin> I've only gone through too, as I recall it
07:14:07 <dcoutts> kolmodin, so if it's ok with you I might turn up a day early
07:14:31 <kolmodin> on the 10th?
07:14:42 <syntaks> I am trying to construct a record in an IO action, and one of the (pure) functions used for initializing a filed can throw an exception. The IO exception in which all of this is happening is set up to catch and handle that exception, but the exception is never caught... could it be, that it is not possible to catch exceptions that are thrown in a type constructor?
07:15:07 <syntaks> . o O (hopefully somebody can parse that question :) )
07:15:17 <dcoutts> kolmodin, maybe or possibly 9th? depends on timing
07:15:35 <dcoutts> kolmodin, I'll try and work out a schedule
07:16:02 <kolmodin> dcoutts: it's ok by me, but so far I have only taken one day off, the 11th
07:16:11 <glen_quagmire> > let g f = f . f in (g g g g g) (+ 1) 0
07:16:11 <lambdabot>  Exception: stack overflow
07:17:16 <Deewiant> > let g f x = f $! f x in (g g g g g) (+1) 0
07:17:16 <dcoutts> kolmodin, that's no prob, I'll not get in your way, I'll go talk to bringert, or just go to the fun fair :-)
07:17:22 <lambdabot> Terminated
07:17:34 <kolmodin> :D
07:17:45 <dcoutts> Lemmih, kolmodin, oh, gotta disappear for a sec and change computers...
07:18:39 <glen_quagmire> Use `+RTS -Ksize' to increase it.    are these ghc flags?
07:18:44 <Heffalump> yes
07:18:49 <Heffalump> no
07:18:58 <Heffalump> they're RTS flags that you pass to a GHC-compiled executable
07:19:11 <Heffalump> +RTS ... -RTS, the ... affects the RTS
07:19:33 <Peaker> vixey, but his prototype GUI is *horrible* :)
07:19:45 <glen_quagmire> Heffalump, oh thank you!
07:19:52 <Heffalump> Peaker: just in terms of look and feel?
07:19:59 <Peaker> Heffalump, yeah
07:20:09 <Heffalump> glen_quagmire: so while you can pass them to GHC, because GHC is compiled by itself, it won't help your program run any better
07:20:19 <Peaker> Heffalump, space-wasting, mouse-based, overlapping windows, that connect with unclear quirky jumps...
07:20:22 <Heffalump> Peaker: ok, but that's not the point (as I'm sure you realise)
07:20:43 <Peaker> Heffalump, ofcourse! I love that idea - its exactly what I want to do, and I think its exactly the same idea as Subtext
07:20:57 <glen_quagmire> wow this takes forever to run
07:21:06 <Peaker> Heffalump, I just think I can create a GUI that I, and probably many other programmers would prefer
07:21:09 <Heffalump> glen_quagmire: you might have an infinite loop that's eating memory
07:21:14 <Heffalump> Peaker: sounds good!
07:21:34 <glen_quagmire> let g f x = f $! f $! x in (g g g g g) (+1) 0
07:21:40 <Peaker> Heffalump, I wonder if he and Jonathan Edwards realize they're working on the same thing
07:21:49 <Heffalump> who?
07:22:04 <Heffalump> I assume you don't mean the British triple-jumper :-)
07:22:51 <Botje> @src ($!)
07:22:51 <lambdabot> Source not found. :(
07:22:56 <Botje> you fail it, \bot
07:24:01 <Peaker> Heffalump, my experience is that when people see Subtext/these efforts, their reaction is "their gui superficially sucks, this proves its impossible to create a gui more usable than a text-based coding process"
07:24:59 <Botje> i rather liked subtextual
07:25:04 <skorpan> @pl dropWhile (current /=) (cycle (map (name) $ players game)) !! 1
07:25:04 <lambdabot> dropWhile (current /=) (cycle (map name (players game))) !! 1
07:25:08 <Peaker> Heffalump, some of the friends I show subtext to :)
07:25:42 <Jaak> that looks stupid
07:26:02 <skorpan> is there any way in which i can simplify that? i have a list of strings and a "current" string: i want to return the string which follows the current string in the list as if the list were cyclic
07:27:04 <Jaak> you hit a nasty bug if no current is found
07:27:18 <skorpan> yes, but rest assure that it is found
07:27:43 <Jaak> i that case it actually looks okay
07:28:00 <skorpan> cool
07:28:08 <skorpan> i was thinking i had missed a nice preludic function
07:28:30 <Jaak> @type find
07:28:31 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
07:28:37 <Jaak> @type lookup
07:28:38 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
07:28:44 <Botje> let ring = cycle $ map name players game in fromJust $ lookup current $ zip ring $ tail ring
07:28:51 <Botje> but it's probably not worth it :)
07:29:07 <Jaak> yeah, it's ugly
07:29:07 <Botje> let ring = cycle $ map name players game in snd $ fromJust $ lookup current $ zip ring $ tail ring
07:29:08 <skorpan> probably not no :)
07:29:12 <Botje> so not really worth it :P
07:29:44 <Jaak> @type join (++)
07:29:45 <lambdabot> forall m. (Monoid m) => m -> m
07:30:22 <Jaak> <3 the general (++)
07:30:44 <Jaak> @instance Monoid
07:30:44 <lambdabot> Maybe you meant: instances instances-importing
07:30:49 <Jaak> @instances Monoid
07:30:49 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
07:31:09 <kpreid> Is this some new GHC thing, or did someone @let (++)?
07:31:10 <Jaak> @type (*2) ++ (+1)
07:31:11 <lambdabot> forall a. (Monoid a, Num a) => a -> a
07:31:41 <Botje> kpreid:  I believe it's in the base lambdabot prelude
07:36:06 <Twey> Er
07:36:20 <Twey> binary42: Fix that will you?  :-\
07:36:53 <Lemmih> dcoutts: I'm not sure how much floor space I have in Copenhagen.
07:37:41 <dcoutts> Lemmih, I'm only small :-) a corner would be fine, I don't need a bed or anything.
07:38:05 <adiM> Is there some function to pretty print an array?
07:38:06 <cnwdup> http://rafb.net/p/hjJF8q60.html Compiling this gives error message (1), compiling it with line 9 uncommented gives error message (2). Do I have to add instance declarations for Monad, MonadIO and MonadReader manually as well? Compiling errors: http://rafb.net/p/nklvy065.html
07:38:07 <lambdabot> Title: Nopaste - Main.hs
07:38:50 <Igloo_> dcoutts: Have you tried Thorkil too? He might have more comfortable space
07:38:54 <cnwdup> Or is it save to activate XGeneraliedNewtypeDeriving? And if it is how do I enable this extension?
07:39:11 <Lemmih> dcoutts: What dates?
07:40:09 <Deewiant> cnwdup: pass -XGeneralizedNewtypeDeriving on the command line to GHC, like it says :-)
07:40:17 <dcoutts> Lemmih, just working it out exactly, it'd probably be either the night of the 7th or 8th
07:40:42 <cnwdup> Deewiant: I can't set this option in Main.hs, can I?
07:41:24 <Deewiant> cnwdup: there's a pragma for it, put {-# LANGUAGE GeneralizedNewtypeDeriving #-} (probably) at the top of the file
07:41:35 <Deewiant> if it's not that, it's in the GHC manual somewhere
07:41:42 <Saizan> it's that.
07:42:00 <dcoutts> Lemmih, or possibly the 6th, depends if kosmikus will let me stay for a day or not :-)
07:42:17 <dcoutts> Igloo, good point
07:42:28 <dcoutts> @seen thorkilnaur
07:42:28 <lambdabot> thorkilnaur is in #haskell-soc, #haskell-overflow, #haskell-blah, #darcs, #ghc and #haskell. I don't know when thorkilnaur last spoke.
07:42:28 <cnwdup> Deewiant: Thanks
07:43:10 <syntaks> I'm having a problem with handling exception in a ctor... http://hpaste.org/6707
07:43:31 <syntaks> could this be brought to work, so that test evaluates to Nothing?
07:44:01 <EvilTerran> you need to force the pattern-match in head inside the catch
07:44:06 <EvilTerran> > catch
07:44:07 <lambdabot>  Add a type signature
07:44:07 <yuriyp> @where atan
07:44:07 <lambdabot> I know nothing about atan.
07:44:13 <yuriyp> @where tan
07:44:13 <lambdabot> I know nothing about tan.
07:44:13 <EvilTerran> ?type catch
07:44:14 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
07:44:19 <EvilTerran> ?hoogle tan
07:44:20 <lambdabot> Prelude.tan :: Floating a => a -> a
07:44:20 <lambdabot> Prelude.tanh :: Floating a => a -> a
07:44:20 <lambdabot> Prelude.atan :: Floating a => a -> a
07:44:28 <EvilTerran> ?index atan
07:44:28 <lambdabot> Prelude
07:44:40 <yuriyp> thanks :-)
07:45:00 <EvilTerran> syntaks, exception handling with catch is always gonna be a bit of a funny business in haskell
07:45:22 <EvilTerran> as lazy evaluation can make it hard to tell when something that throws an exception is going to be forced
07:45:43 <Heffalump> anyone use mapException regularly?
07:45:51 <EvilTerran> ?hoogle mapException
07:45:52 <lambdabot> Control.Exception.mapException :: (Exception -> Exception) -> a -> a
07:46:20 <syntaks> EvilTerran, oh, so because of lazyness in my case, the exception occurs when the surrounding action has already been executed but the invalid call to head only occurs when I try to show the results?
07:46:26 <EvilTerran> yeah
07:47:14 <EvilTerran> syntaks, in general, it's better to avoid exceptions where you can
07:47:20 <syntaks> can I make it strict somehow, so that the thunk gets evaluated in the action?
07:47:31 <Heffalump> x == x is a good way of doing that if your datatype implements Eq
07:47:36 <Heffalump> as is show x == show x if it implements Show
07:47:38 <EvilTerran> you can do what you've got there neater, by, eg, using the Maybe monad
07:47:44 <Heffalump> depends how much inefficiency you can tolerate
07:48:13 <Heffalump> you then need to use a seq to ensure that those are actually evaluated
07:48:16 <EvilTerran> test :: Maybe Rec; test = do a <- head []; return Rec{a = a}
07:48:23 <EvilTerran> > do a <- head []; return Rec{a = a}
07:48:25 <lambdabot>   Not in scope: data constructor `Rec'
07:48:55 <EvilTerran> > do a <- head []; return a
07:48:55 <lambdabot>   add an instance declaration for (Show (t t1))
07:49:02 <EvilTerran> > do a <- head []; return a :: Maybe Int
07:49:04 <lambdabot>  Exception: Prelude.head: empty list
07:49:09 <EvilTerran> um
07:49:15 <EvilTerran> sorry, i'm getting confused
07:49:17 <Heffalump> head doesn't just work in the Maybe monad by magic..
07:49:22 <EvilTerran> > do a:_ <- []; return a :: Maybe Int
07:49:22 <lambdabot>  Couldn't match expected type `[]' against inferred type `Maybe'
07:49:35 <EvilTerran> oh, sod it, i give up. my haskell brain is offline today.
07:49:37 <Heffalump> you're still confused
07:49:48 <Heffalump> > do a:_ <- return [] ; return a :: Maybe Int
07:49:49 <lambdabot>  Nothing
07:49:54 <EvilTerran> "haskell EvilTerran is offline for maintenance. we apologise for the inconvenience"
07:50:21 <EvilTerran> > (listToMaybe [], listToMaybe [1..])
07:50:22 <lambdabot>  (Nothing,Just 1)
07:50:46 <EvilTerran> syntaks, so what you want is "fmap Rec . listToMaybe"
07:51:17 <syntaks> the reason why I think I need to use exception is that the constructor calls will be occuring recursively... and when it fails somewhere I want to propagate it up so that the enclosing IO action can catch it
07:52:27 <EvilTerran> syntaks, can you perhaps use functions throughout that return Just x (and Nothing on failure) instead of ones that just return x (and throw exceptions on failure)?
07:52:43 <EvilTerran> it's a much more haskell-y solution. catch is a bit of an ugly hack.
07:53:07 <EvilTerran> with those, my original blabbering about the Maybe monad would actually make sense :)
07:53:29 <EvilTerran> listToMaybe, for example, is the Maybe-returning version of head
07:53:38 <EvilTerran> ?src listToMaybe
07:53:38 <lambdabot> listToMaybe []        =  Nothing
07:53:38 <lambdabot> listToMaybe (a:_)     =  Just a
07:53:49 <syntaks> foir instance I'd have data Rec{a::Int, b::Maybe Rec} and when something goes wrong when initializing b it should be set to nothing, however when something goes wrong for a, the whole thing should be nothing
07:54:11 <Twey> > head []
07:54:12 <lambdabot>  Exception: Prelude.head: empty list
07:57:07 <syntaks> EvilTerran, and then, if whatever should become a in the Rec that will be b in the enclosing Rec cannot be read, the outermost Rec should again be Nothing
07:57:45 <syntaks> EvilTerran, so I need this 'bubble up' behavior, which so far I know only from exceptions
07:57:55 <EvilTerran> yeah, definitely a job for the Maybe monad/functor/applicative/etc
07:58:25 <EvilTerran> using Maybe as a monad is basically like having one exception (called Nothing)
07:58:46 <EvilTerran> but with far, FAR nicer semantics than haskell exceptions proper
07:59:15 <syntaks> I know Maybe... but haven't used the Maybe _monad_ yet...
07:59:28 <vixey> :t (>>=)
07:59:28 <EvilTerran> ?go you could have invented monads
07:59:29 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:59:29 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
07:59:29 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
07:59:49 <vixey> > Just 1 >>= Just
07:59:50 <lambdabot>  Just 1
08:00:04 <vixey> > (Nothing::Maybe Integer) >>= Just
08:00:06 <Heffalump> I don't think Haskell exceptions have _bad_ semantics
08:00:06 <lambdabot>  Nothing
08:00:16 <Heffalump> they are just different in terms of implicitness and catchability
08:00:27 <Heffalump> and an efficient evaluation model
08:01:04 <EvilTerran> well, yes, but it's better to use something else when you can, IMO
08:01:40 <Heffalump> I think it depends on the situation.
08:02:00 <EvilTerran> ok, how about this situation?
08:03:05 <Heffalump> there's not enough code to have a decent opinion
08:03:35 <Heffalump> it's a trade-off between overhead at the sites that *might* throw (and intermediate code that calls those sites) and overhead when you want to catch
08:03:46 <EvilTerran> you're optimising prematurely
08:03:52 <Heffalump> who is?
08:04:02 <EvilTerran> you - you're going on about performance
08:04:39 <Heffalump> well, I guess the code could be reinterpreted in the Identity monad if you wanted to recover the performance later
08:04:41 <EvilTerran> the way i see it, there's really no need to drop down into the muddy waters of evaluation order, and the IO monad, in this instance
08:05:10 <Heffalump> but generally the situation where every little bit of code would be slower if you do it one way, is one where you _should_ think about optimisation early
08:05:26 <Heffalump> but instead you end up in the muddy waters of having a monad everywhere
08:06:02 <syntaks> Heffalump, that was one of the reasons why I ended up with exception...
08:06:15 <EvilTerran> from how i interpreted what syntaks was saying, it sounded like he'd have the IO monad everywhere if he was doing it with classical exceptions
08:06:15 <syntaks> I'll put up a better example of what I am trying to do...
08:07:17 <Heffalump> the IO monad would be at the top-level
08:10:54 <syntaks> EvilTerran, Heffalump, http://hpaste.org/6709 ... this might explain better what I am trying to achieve
08:11:54 <Heffalump> ok, for that I think you should definitely use the Maybe monad as EvilTerran suggested
08:12:01 <syntaks> I have fields that are Maybes and those can fail... but whenever something fails that is not a Maybe, it should bubble up to the next possible maybe
08:12:11 <Heffalump> because you need to catch failures at every level
08:12:47 <Jaak> data Rec = Rec { a :: Int; b :: Maybe Rec} deriving Show
08:13:09 <Jaak> but isn't this isomorphic to [Int]?
08:13:39 <Heffalump> yes, but it may be a simplified example or there may be usability benefits from that presentation
08:14:17 <syntaks> its simplified
08:14:17 <Jaak> oh, intOk is Maybe Int. so: data Rec = Rec { a :: Maybe Int; b :: Maybe Rec} deriving Show
08:15:04 <syntaks> Jaak, that should just illustrate, that whatever initializes a may fail, but the type of a should not be Maybe
08:15:29 <syntaks> instead, I want to propagate the failure up to the next level and either handle it there or propagate further up
08:16:00 <hpaste>  EvilTerran annotated "recursive ctors" with "a couple of ways of doing it" at http://hpaste.org/6709#a1
08:16:24 <syntaks> Jaak, so there is a type error in the example for illustrative purpose
08:16:36 <forkiliens> hello everybody
08:17:11 <EvilTerran> i'd go for the latter of the two
08:17:22 <Jaak> ofc there is
08:17:39 <hpaste>  Jaak annotated "recursive ctors" with "moo" at http://hpaste.org/6709#a2
08:19:25 <syntaks> Jaak, that would make a :: Maybe Int, which is what I am trying to avoid
08:19:37 <forkiliens> how do i read a string from the type IO Exitcode ?
08:20:10 <Jaak> EvilTerrans annotation looks nice then
08:20:32 <Jaak> it's kind of strange thing to do... tho'
08:20:37 <Peaker> the tutorials don't cover the "Data" modules and various stdlib things - where's a good source to read about them?
08:20:37 <Heffalump> forkiliens: "read a string"?
08:20:48 <Heffalump> the haddock
08:20:52 <joricj> how can i create a mutex that i can pass around in IO?
08:20:53 <Heffalump> I don't think there's much more docs
08:20:59 <Heffalump> joricj: MVar?
08:21:32 <syntaks> I'll try to work from that second one, EvilTerran
08:21:36 <syntaks> thanks everyone
08:21:38 <EvilTerran> :)
08:21:41 <joricj> Heffalump: wow that's perfect!
08:22:24 <Heffalump> joricj: if you're not already aware of it, take a look at STM in case that fits your application, cos it's much nicer
08:22:33 <Heffalump> but it's rather different to a mutex-based approach
08:23:05 <joricj> okay i will do that
08:23:21 <forkiliens> heffalump: system "ls"
08:23:35 <forkiliens> hefalump: then read the output.
08:23:49 <Heffalump> forkiliens: an ExitCode is just an exit code, i.e. a number
08:23:51 <EvilTerran> i think the function you're using doesn't capture the output
08:24:11 <EvilTerran> there's neater ways of getting file listings than that, too
08:24:33 <EvilTerran> System.Directory, iirc
08:24:41 <EvilTerran> getDirectoryContents :: FilePath -> IO [FilePath]
08:25:26 <EvilTerran> forkiliens, have a look at http://www.haskell.org/ghc/docs/latest/html/libraries/directory/System-Directory.html
08:25:27 <lambdabot> http://tinyurl.com/2vu2vv
08:25:28 <forkiliens> evilTerran: i'm not using "ls", it was just to illustrate. i'm using another program
08:25:39 <forkiliens> evilterran: thanks.
08:25:47 <EvilTerran> ... one whose functionality definitely isn't covered in some haskell library?
08:25:56 <forkiliens> texvc
08:26:01 <EvilTerran> ok
08:26:27 <EvilTerran> http://www.haskell.org/ghc/docs/latest/html/libraries/process/System-Process.html may do what you want
08:26:27 <lambdabot> http://tinyurl.com/2uqkc5
08:26:37 <EvilTerran> runInteractiveCommand or runInteractiveProcess
08:26:45 <forkiliens> thanks very much.
08:27:52 * EvilTerran has been over-exposed to perl, and is used to people doing horrible things like for(`ls $pathToSomewhere`) ... :P
08:29:39 <forkiliens> :)
08:29:46 <araujo> morning
08:30:20 <byorgey> morning araujo, morning all =)
08:30:44 <araujo> morning byorgey :-)
08:30:59 * byorgey doles out pumpkin-applesauce-chocolate chip lambdas
08:33:35 <hpaste>  Jaak annotated "recursive ctors" with "I like this more" at http://hpaste.org/6709#a3
08:44:45 <Peaker> how do I find a list of exported names from a module?
08:44:58 <Peaker> ghci/lambdabot
08:48:34 <byorgey> Peaker: in ghci, use :browse
08:51:35 <Peaker> thanks
08:54:10 <SamB> do irrefutable patterns do anything in lambdas?
08:54:29 <Saizan> SamB: they defer evaluation
08:54:45 <EvilTerran> > (\(_:_) -> True) []
08:54:46 <lambdabot>   Non-exhaustive patterns in lambda
08:54:49 <EvilTerran> > (\~(_:_) -> True) []
08:54:50 <lambdabot>  Parse error at "->" (column 10)
08:54:59 <EvilTerran> > (\ ~(_:_) -> True) [] -- ahem
08:54:59 <lambdabot>  True
08:55:23 <Peaker> defer it forever, in this case?
08:55:27 <EvilTerran> so, only if you don't use any variables bound inside the ~(...)
08:55:43 <EvilTerran> seeing as they can't affect branching
08:56:09 <EvilTerran> that'll be the only difference
08:56:35 <rolly1975> does anyone know how i get my types correct in the following code?
08:56:37 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6710
08:56:46 <SamB> > (\ ~(_,x) -> ((),x)) undefined
08:56:46 <lambdabot>  Undefined
08:56:55 <SamB> > fst $ (\ ~(_,x) -> ((),x)) undefined
08:56:55 <lambdabot>  ()
08:57:03 <rolly1975> Im still getting used to the type system in haskell
08:57:12 <mauke> rolly1975: yeah, move the division to the end and use `div` instead of /
08:57:21 <mauke> / is for fractional numbers, not integers
08:57:41 <rolly1975> mauke: ah...i see. thanks a lot, that makes sense
08:57:43 <EvilTerran> sumdiff2 n = n * (3*(n^3)+2*(n^2)-(3*n)-2) `div` 12
08:57:57 <spoon> You guys are quick
08:58:01 <spoon> I have a question about existential types
08:58:33 <rolly1975> thx guys
08:58:33 <EvilTerran> you can drop some brackets, too - "n * (3*n^3 + 2*n^2 - 3*n - 2) `div` 12"
08:59:56 * SamB found out that JHC doesn't support irrefutable patterns in lambdas
08:59:56 <spoon> I have an existential list that can holds anything of class Daemon, but I get an ambiguous type variable error when I attempt to create this with the empty list
09:00:20 <spoon> I can change the rest of the program so I have NoDungeons too
09:00:28 <spoon> *NoDaemons
09:00:47 <spoon> But I was wondering if theres anyway of getting this to treat it like the empty list without changing the data type
09:00:55 <spoon> data Daemons =  forall i. Daemon i => Daemons [i]
09:01:27 <SamB> I discovered this in trying to get Control.Arrow to compile...
09:01:57 <SamB> after much work to get the typechecker to admit it
09:02:09 <EvilTerran> spoon, how're you using your empty list? "ambiguous type variable" sounds like a Dreaded Monomorphism Restriction problem
09:02:22 <desegnis> spoon: better hpaste complete code + error message
09:02:36 <EvilTerran> (of course, i may be barking up completely the wrong tree)
09:02:40 <spoon> ok!  I thought i'd better explain what I'm on about cus first it's pretty weird
09:02:57 <EvilTerran> ?paste
09:02:57 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:03:09 <spoon> ok thanks
09:03:31 <spoon> Ha, it's on the laptop
09:03:52 <SamB> thankfully the MR can be turned off, but I'm not sure that that is the problem here
09:04:20 <SamB> also, I don't think that type will do what you want
09:04:36 <SamB> you probably want to have more than one type of Daemon in the list?
09:04:46 <SamB> I think you want something like this
09:04:54 * EvilTerran was thinking it should be "data Daemons = Daemons (forall i. Daemon i => i)"
09:05:28 <SamB> data Daemon = forall t . Daemonic t => Daemon t
09:05:41 <EvilTerran> or "data Daemons where Daemons :: Daemon i => i -> Daemons", with GADTs
09:05:58 <EvilTerran> or something.
09:05:59 <SamB> yeah, GADT syntax is WAAAY easier to write
09:06:05 <EvilTerran> wait, i see what SamB's talking about
09:06:13 <EvilTerran> yeah, you need the forall inside the list constructor
09:06:47 <SamB> but GHC's typesystem doesn't support foralls in that position...
09:07:05 <EvilTerran> "data Daemon = Daemon (forall t. Daemonic t => t); type Daemons = [Daemon]"
09:07:19 <SamB> EvilTerran: oh, is that the syntax?
09:07:38 <SamB> I think the GADT syntax is probably a better idea
09:07:47 <mauke> that looks wrong
09:07:48 <spoon> I see what you mean, hey I'm a bit silly and left the code at the other side of the house.
09:08:09 <EvilTerran> i think so, yeah. iirc, the forall goes in the bit that's a type - in one of the constructor's parameters, rather than before the constructor name itself
09:08:10 <mauke> (forall t. Daemonic t => t) doesn't seem like it contains any value other than bottom
09:08:24 <SamB> spoon: so SSH over there already
09:08:24 <EvilTerran> mauke, but you can use the class methods of Daemonic on any such t
09:08:47 <spoon> Hey wait, I'm all slow, I'll try a few things out and come back later...
09:08:48 <mauke> yeah, but where do you get such a t?
09:09:03 <EvilTerran> hm.
09:09:06 <SamB> mauke: oh, I meant "exists"
09:09:23 <EvilTerran> i think that's the data decleration syntax being quirky
09:09:45 <EvilTerran> data Daemon where Daemon :: Daemonic t => t -> Daemon -- means the same thing, unless i'm mistaken
09:09:48 <spoon> It looks like you're saying to put the existential data, which enforces the class, inside a list, rather than existentially define a list over the class...
09:09:49 <SamB> yes, using "forall" to mean "exists" in particular places is really odd
09:09:53 <Baughn> Sanity check: The RTS' deadlock detection /is/ a debugging feature, and any program relying on it is essentially erronous - right?
09:10:11 <SamB> spoon: sure, unless you want only one kind of Daemon in any given list
09:10:12 <mauke> no, it means data Daemon where Daemon :: (forall t. Daemonic t => t) -> Daemon
09:10:34 <EvilTerran> i blame parameter types being contravariant :P
09:10:47 <SamB> mauke: well, see, I'm blaming the "forall means exists sometimes" thing for my getting it wrong
09:10:58 <SamB> EvilTerran: eh?
09:11:15 <SamB> EvilTerran: if they weren't, how the heck would you type build?
09:11:23 <mauke> forall never means exists :-)
09:11:31 <rolly1975> what would be a nice way to get the gcd of a list of integers?
09:11:31 <EvilTerran> i mean, that's why forall seems to (but doesn't) mean exists in some places
09:11:37 <SamB> mauke: explain the forall syntax for existentials
09:11:38 <rolly1975> the following doesnt seem to work
09:11:44 <hpaste>  rolly1975 pasted "(no title)" at http://hpaste.org/6711
09:11:47 <EvilTerran> > gcd [12, 16, 23]
09:11:47 <lambdabot>   add an instance declaration for (Integral [t])
09:11:53 <EvilTerran> > gcd [12, 16, 24] :: Int
09:11:54 <lambdabot>  Couldn't match expected type `Int'
09:12:00 <EvilTerran> um
09:12:02 <EvilTerran> ?type gcd
09:12:03 <lambdabot> forall a. (Integral a) => a -> a -> a
09:12:03 <mauke> > foldl1' gcd [12, 16, 24]
09:12:04 <lambdabot>  4
09:12:04 <rolly1975> ah
09:12:07 <EvilTerran> ah, yes.
09:12:12 <rolly1975> i tried gcd [1.10]
09:12:19 <desegnis> > foldl' gcd 1 [12, 16, 24]
09:12:19 <lambdabot>  1
09:12:22 <desegnis> er
09:12:27 <rolly1975> gcd [1..10]
09:12:30 <rolly1975> i mean
09:12:32 <rolly1975> and i got
09:12:40 <spoon> Right thanks... If you're curious why I'm trying to make this, it's an abstract animation engine, with libraries to make writing Daemons etc easy.  I want to hide representation as much as possible so I don't have to force users to write software through my weird data declarations and instead use some weird class thing instead... woo go Haskell
09:12:40 <SamB> spoon: for convenience, you could then make an instance Daemonic Daemon
09:12:46 <rolly1975> No instance for (Integral [t])
09:12:54 <spoon> bye!
09:13:06 <Jaak> @type gcd
09:13:07 <lambdabot> forall a. (Integral a) => a -> a -> a
09:13:15 <EvilTerran> rolly1975, yeah, looking at the types of things helps. as you can see above, i made the same error :P
09:13:19 <EvilTerran> ?src gcd
09:13:19 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
09:13:19 <lambdabot> gcd x y = gcd' (abs x) (abs y)
09:13:19 <lambdabot>    where gcd' a 0  =  a
09:13:19 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
09:13:26 <SamB> @tell spoon oh, did you only want one type of daemon then? well then the first idea was fine...
09:13:26 <lambdabot> Consider it noted.
09:13:50 <EvilTerran> SamB, doh :)
09:13:51 <SamB> @tell spoon I thought you were writing a game ;-)
09:13:51 <lambdabot> Consider it noted.
09:13:53 <rolly1975> EvilTerran: thx
09:14:04 <desegnis> rolly1975: For the solution, see mauke, in case you didn't notice (I didn't first :)
09:14:40 <rolly1975> desegnis: thanx, got it.
09:14:42 <rolly1975> thx mauke
09:15:51 <mauke> SamB: data T = forall a. C a means C has the type C :: forall a. a -> T
09:15:59 <mauke> but don't ask me why
09:16:42 <mauke> so unC (C x) = x would have the type exists a. T -> a, which isn't valid code :-)
09:17:28 <SamB> so the field could be said to have type exists a. a?
09:17:35 <mauke> yes
09:17:46 <rolly1975> just curious: when would i use foldl vs foldr? is their any situations where it would be important to choose l vs r?
09:17:52 <SamB> of course, if you use the same variable in multiple field types, it gets wierder
09:17:53 <mauke> but instead of saying that, you simply add a forall to the constructor type
09:18:10 <mauke> rolly1975: you use foldr for infinite lists
09:18:27 <mauke> foldl always looks at all list elements before returning
09:18:40 <mauke> oh, and you never use foldl; it's either foldr or foldl'
09:19:13 <shachaf> forall a. a -> T === (exists a. a) -> T, yes?
09:19:13 <SamB> well, they say that foldl *might* be useful for *something*.
09:19:15 <SamB> in theory.
09:19:36 <rolly1975> mauke: ah, so thats the connection...but whats foldl'?
09:19:38 <EvilTerran> a non-associative operation that isn't strict in its first parameter?
09:19:59 <mauke> rolly1975: a foldl that's strict in the accumulator ... kind of
09:20:16 <SamB> well, you could use it to implement reverse ?
09:20:23 <rolly1975> foldl works for me but not foldl' .. is it in another module i need to load?
09:20:24 <mauke> it forces the accumulator at each reduction step
09:20:32 <mauke> @index foldl'
09:20:32 <lambdabot> Data.List
09:20:41 <SamB> not that I see any point in doing it that way...
09:20:45 <V|ghter> http://www.to-6.net/?id=70179036
09:20:45 <lambdabot> Title: Die Ex
09:20:56 <SamB> I think that would just waste space
09:21:15 * EvilTerran waits for the k-line
09:21:27 <SamB> EvilTerran: but such a thing is possible
09:21:44 <SamB> EvilTerran: it is even possible that it be useful!
09:21:51 <EvilTerran> indeed
09:22:03 <shachaf> @src reverse
09:22:03 <lambdabot> reverse = foldl (flip (:)) []
09:22:13 <EvilTerran> ta-dah!
09:22:21 <SamB> why do they use foldl and not foldl'?
09:22:32 <EvilTerran> > take 10 . foldl (flip (:)) [] $ undefined:[1..10]
09:22:32 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
09:22:36 <EvilTerran> > take 10 . foldl' (flip (:)) [] $ undefined:[1..10]
09:22:36 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
09:22:39 <EvilTerran> huh
09:22:51 <EvilTerran> > take 10 . foldl' (flip (:)) undefined $ [1..10]
09:22:52 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
09:23:06 <SamB> see, the items aren't touched by the foldl
09:23:09 <SamB> or the foldl'
09:23:13 * EvilTerran thinks
09:23:23 <desegnis> @src foldl'
09:23:24 <lambdabot> foldl' f a []     = a
09:23:24 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
09:23:34 <SamB> well, at least, that isn't the accumulating paramter
09:23:37 <EvilTerran> i'd've expected that to force the undefined... ah, i see why.
09:23:41 <desegnis> a' is a list in this case
09:23:53 <EvilTerran> it doesn't force the initial accumulator
09:24:02 <SamB> in any case, I see little benefit in using foldl in this case...
09:24:09 <mauke> the foldl thing is just the prelude definition of reverse
09:24:12 <mauke> reverse l =  rev l []
09:24:12 <mauke>   where
09:24:12 <mauke>     rev []     a = a
09:24:12 <mauke>     rev (x:xs) a = rev xs (x:a)
09:24:33 <EvilTerran> but we like our pointfree one-liners!
09:24:35 <SamB> oh, and foldl' isn't available in the prelude I guess?
09:24:41 <EvilTerran> ?index foldl'
09:24:42 <lambdabot> Data.List
09:24:50 <rolly1975> ok, last dumb question: why does foldl' gcd 1 [1,4] work but foldl' gcd 1 [1..4] fail?
09:24:53 <mauke> er, wait
09:25:12 <EvilTerran> > foldl' gcd 1 [1..4]
09:25:13 <lambdabot>  1
09:25:14 <mauke> I meant "the report definition"
09:25:21 <EvilTerran> looks right to me
09:25:25 <Heffalump> they both work for me
09:25:43 <EvilTerran> ... is the gcd of [] defined?
09:26:09 <mauke> INFINITE
09:26:10 <rolly1975> sorry all, i was being very dumb
09:26:15 <rolly1975> it works ok
09:26:24 <EvilTerran> mauke, so that's a no, then? :P
09:26:46 <EvilTerran> in which case, it should be "foldl1' gcd [your list here]"
09:27:04 <mauke> gcd (gcd' []) n == n forall n
09:27:06 <Peaker> is it ok to say that Reader is like State without a "put"?
09:27:10 <mauke> I don't think such a number exists
09:27:15 <mauke> Peaker: yes
09:27:25 <Peaker> mauke, thanks
09:27:28 <EvilTerran> or a modify
09:27:36 <EvilTerran> (but that's written in terms of put anyway)
09:27:41 <mauke> well, Reader still lets you locally override the state
09:27:43 <mauke> :t local
09:27:44 <lambdabot> forall r (m :: * -> *) a. (MonadReader r m) => (r -> r) -> m a -> m a
09:27:56 <SamB> mauke: well, in certain representations there may be a suitable value
09:27:58 <mauke> but changes don't propagate upwards
09:28:03 <SamB> a suitably infinite value
09:28:09 <shachaf> Peaker: State is like a Reader with a put. :-)
09:28:17 <SamB> however, these representations would only work for multiplication...
09:28:23 <Peaker> shachaf, Ok, thanks :)
09:30:05 * SamB wonders what let means in Jhc's E language -- doesn't remember...
09:30:34 <Peaker> so many cool ideas, but IMO, such misleading names :)
09:33:30 <Heffalump> shachaf: State is Writer over (a -> a)
09:36:15 <Peaker> liftIO is specifically implemented in each transformer to specifically let you access the IO Monad? Isn't that inelegant/ad-hoc?
09:36:59 <Saizan> (s -> s,a) ~ s -> (s,a) ? it doens't look right
09:37:15 <Lemmih> Peaker: Feel free to use lift instead.
09:38:02 <rolly1975> @src lcm
09:38:02 <lambdabot> lcm _ 0     =  0
09:38:02 <lambdabot> lcm 0 _     =  0
09:38:02 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
09:38:09 <Heffalump> Saizan: oh, good point. I withdraw that.
09:38:26 <Heffalump> Peaker: in a sense, yes, but in another sense it provides a consistent way to access IO.
09:38:39 <Heffalump> whereas the number of lifts is dependent on the height of the stack, if you don't use a newtype somewhere.
09:39:56 <rolly1975> @src quot
09:39:56 <lambdabot> Source not found. Wrong!  You cheating scum!
09:40:54 <Peaker> Lemmih, well, counting "lift"s hard-codes the structure of the stack and is also ugly
09:40:54 <matthew-_> @hoogle fixIO
09:40:55 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
09:41:06 <Peaker> @src fixIO
09:41:06 <lambdabot> Source not found. It can only be attributed to human error.
09:41:32 <matthew-_> oh boy, so that's only slightly magic then
09:41:37 <matthew-_> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/System-IO.html#fixIO
09:41:38 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/32bgdz
09:42:10 <Lemmih> Peaker: Indeed, which is why the common case of accessing IO is encapsulated in MonadIO.
09:43:11 <Peaker> Lemmih, what about my monads though?
09:43:18 <shachaf> Heffalump: Writer is State - Reader (sort of). :-)
09:43:29 <Saizan> one could have all the IO primitives as class methods, but considering fffi they are a bit much :)
09:43:38 <Heffalump> shachaf: hmm.
09:43:48 <shachaf> State = s -> (s,a), Reader = s -> a, Writer = (s,a)
09:44:07 <Lemmih> Peaker: Tough luck. Invent a more powerful type-system (:
09:44:11 <Saizan> tell doens't overwrite the state
09:44:20 <Saizan> but yeah, you could
09:44:25 <Heffalump> matthew-_: I think it amounts to fixIO k = return (fix (unsafePerformIO . k)), but with the explicit blackholing mentioned.
09:44:36 <Saizan> it's just that Writer is used with a more structured s
09:45:07 <shachaf> Writer wouldn't be that interesting if it kept overwriting the s. :-)
09:46:17 <Heffalump> as Saizan pointed out when correcting me, State is strictly more general than any combination of Writer and Reader as it allows you to interact with the state at intermediate points
09:47:16 <shachaf> Oh, I missed a bit of this conversation, sorry.
09:49:40 <newsham> hi
09:49:58 <guenni> does anybody here have a good reference to some place that explains what types are?
09:50:10 <Peaker> does State have something like "local"?
09:50:28 <newsham> guenni: there's some math oriented stuff that talks about meanings of types
09:50:42 <newsham> ie. types as sets of all posisble values that a var could take on.
09:50:47 <Heffalump> Peaker: don't think so, but you can simulate it yourself with get and put
09:50:56 <guenni> newsham: good, could you point me there
09:51:02 <newsham> i :: Int   -->     i \elementof { ... }
09:51:17 <newsham> guenni: one that I liked is the z-notation book
09:51:32 <Heffalump> types aren't quite sets, but I don't really understand why
09:51:43 <guenni> well if types would only meant sets I could live with that, but they also seem to be used to define structures as well
09:51:43 <Heffalump> since I don't understand either formal set theory or formal type theory
09:52:03 <newsham> lemme find url
09:52:05 <EvilTerran> ?type \x m -> do old <- get; put x; m; put old
09:52:06 <lambdabot> forall (t :: * -> *) s t1. (MonadState s t) => s -> t t1 -> t ()
09:52:20 <guenni> and I just can't make that link
09:52:24 <desegnis> Heffalump: Types aren't sets because sets are a mathematical structure, whilst types are merely syntactical
09:52:26 <EvilTerran> hm, close
09:52:41 <EvilTerran> ?type \x m -> do old <- get; put x; y <- m; put old; return y
09:52:41 <lambdabot> forall (t :: * -> *) t1 s. (MonadState s t) => s -> t t1 -> t t1
09:52:45 <newsham> http://www.usingz.com/text/zedbook.pdf
09:53:07 <Peaker> @src fix
09:53:08 <lambdabot> fix f = let x = f x in x
09:53:19 <newsham> zedbook is readable if you dont have previous set theory experience
09:53:32 <guenni> newsham: thx
09:53:42 <Peaker> I don't understand that definition of fix - how can it ever terminate?
09:53:50 <EvilTerran> because of laziness
09:53:56 <desegnis> Heffalump, that is, types say something about terms, not about data
09:53:58 <newsham> peaker: same way recursion can terminate -- you hit a base case that doesnt recurse further
09:54:05 <EvilTerran> fix (1:)  -->  let x = 1:x in x
09:54:12 <byorgey> fix IS recursion =)
09:54:28 <Peaker> oh, thanks
09:54:48 <desegnis> Peaker: The easier definition (only less efficient) is fix f = f (fix f)
09:54:56 <Heffalump> desegnis: I'm none the wiser
09:55:05 <newsham> consider:   \f n -> if n == 0 then 1 else n * f (n - 1)
09:55:06 <guenni> newsham: what is the Z stuff?
09:55:10 <Peaker> desegnis, why is it less efficient?
09:55:16 <byorgey> > let f _ 0 = 1; f g n = n * g (n - 1) in fix f 5
09:55:16 <lambdabot>  120
09:55:20 <Heffalump> the nice thing about laziness is it makes control structures first class
09:55:21 <newsham> if you do:    func <anyfunc> 0   the <anyfunc> is never used
09:55:30 <Heffalump> in most languages only if then else and case are lazy
09:55:38 <Heffalump> and you can't build anything on top of them
09:55:41 <desegnis> Peaker, I forgot
09:55:50 <newsham> guenni: its a language for writing formal specs
09:56:06 <newsham> but the book about it gives a good overview of lots of underlying concepts which arent zed specific
09:56:30 <byorgey> Peaker, desegnis: it's probably to do with memory usage
09:56:34 <guenni> newsham: thx again
09:57:01 <newsham> ?let fact = \f n -> if n == 0 then 1 else n * f (n - 1)
09:57:02 <lambdabot> Defined.
09:57:07 <newsham> > fix fact 5
09:57:08 <lambdabot>  120
09:57:24 <Heffalump> it's less efficient because fix f is repeatedly reconstructed and evaluated
09:57:30 <newsham> > (fact.fact.fact.fact.fact.fact.fact.undefined) 5
09:57:31 <lambdabot>  <Integer -> Integer>
09:57:32 <Heffalump> in fix f = let x = f x in x
09:57:59 <EvilTerran> fix (\twoTo i -> if i > 0 then 2 * twoTo (i-1) else 1) n --> let { x = (\twoTo i -> if i > 0 then 2 * twoTo (i-1) else 1) x } in x n --> let { x i = if i > 0 then 2 * x (i-1) else 1 } in x n
09:58:00 <Heffalump> x becomes a single thunk and then the evaluator just follows it round and round in circles as needed
09:58:01 <newsham> hmm.. what did I botch?
09:58:13 <desegnis> Heffalump: Put another way, since types are merely a method to forbid certain terms/programs (because they don't typecheck), they don't really correspond to anything. Sets, on the other hand, may contain anything you like
09:58:35 <mauke> > (fact.fact.fact.fact.fact.fact.fact undefined) 5
09:58:35 <lambdabot>  Couldn't match expected type `Integer -> Integer'
09:58:46 <mauke> oh, right
09:58:56 <EvilTerran> > (fact.fact.fact.fact.fact.fact.fact) undefined 5
09:58:57 <lambdabot>  120
09:59:08 <newsham> > (fact.fact.fact) undefined 5
09:59:10 <lambdabot>  Undefined
09:59:14 <Heffalump> desegnis: I'm still none the wiser :-)
09:59:23 <EvilTerran> > (fact.fact.fact.fact.fact.fact.fact.fact) undefined 5
09:59:23 <newsham> fix fact gives you the   (fact.fact.fact.fact.fact. .... )
09:59:23 <Heffalump> a set contains a bunch of values, as does a type
09:59:24 <lambdabot>  120
09:59:35 <desegnis> Heffalump, well never mind, it's hard to express :)
09:59:42 <Heffalump> the fact that types can't contain other types is part of it, I know
09:59:49 <mauke> > fix (fact.)
09:59:50 <lambdabot>        add an instance declaration for (Show (f (Integer -> Integer)))
10:00:20 <EvilTerran> > fix (fact.) undefined 5
10:00:21 <lambdabot>  120
10:00:27 <newsham> heff: there are restrictions in some type systems to make the manageable.
10:00:33 <Heffalump> but you could model that by having a set of all values and restricting types to be a subset of that set
10:00:48 <Heffalump> or even perhaps a partition of that set
10:00:55 <eyeris> Does anyone know the gtk2hs signal for when the selection changes in a GtkTreeView control?
10:01:08 <newsham> > fact undefined 0
10:01:09 <lambdabot>  1
10:01:12 <newsham> > fact undefined 1
10:01:12 <lambdabot>  Undefined
10:01:21 <newsham> > fact (fact undefined) 1
10:01:21 <lambdabot>  1
10:01:26 <mauke> > help fact
10:01:27 <lambdabot>  DENIED.
10:01:29 <newsham> > fact (fact (fact undefined)) 2
10:01:30 <lambdabot>  2
10:03:31 <syntaks> Heffalump, EvilTerran, that Maybe monad stuff you cam up with a few hours ago is working out really great... I already said thanks... but thanks again! ;)
10:03:39 <desegnis> Heffalump, I wouldn't consider it right to say that a type contains a bunch of values, since that's exactly what a set is supposed to do
10:03:49 <EvilTerran> syntaks, :)
10:03:50 <desegnis> It's a useful intuition to think of types as sets
10:04:03 <byorgey> > help help
10:04:04 <lambdabot>  DENIED.
10:04:05 <desegnis> But that's only due to sets being more concrete than types
10:04:08 <byorgey> hehe
10:04:28 <EvilTerran> syntaks, that's the magic of monads - we can embed all that funky stuff like side-effects, exceptions and whatnot in our nice, simple base language
10:04:32 <Heffalump> what do sets specify that types don't, then?
10:04:44 <ari> :t fact
10:04:46 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
10:04:55 <Heffalump> syntaks: you're welcome, though EvilTerran did all the work
10:04:56 <mauke> > fact id 5
10:04:57 <lambdabot>  20
10:05:23 <byorgey> :t help
10:05:24 <lambdabot> forall t a. t -> Sym a
10:05:24 <EvilTerran> you can, if you so desire, look at imperative programs as being like haskell programs that're always in the IO monad, or ErrorT IO if they have exceptions, or ...
10:05:29 <EvilTerran> Heffalump, :)
10:05:36 <byorgey> wtf is help?
10:05:42 <EvilTerran> ?index help
10:05:42 <lambdabot> bzzt
10:05:51 <byorgey> @src help
10:05:51 <EvilTerran> ?src ErrorT
10:05:51 <lambdabot> Source not found. Are you on drugs?
10:05:51 <lambdabot> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
10:05:52 <mauke> > fact help 1
10:05:52 <lambdabot>  Couldn't match expected type `Integer'
10:06:12 <byorgey> @index Sym
10:06:12 <lambdabot> bzzt
10:06:17 <desegnis> A set is, well, a bunch of distinguishable values of our imagination. A type is just a label put onto a term, independent of what the term means
10:06:31 <Heffalump> you're not relating the two concepts
10:06:55 <desegnis> You could imagine a type system for working with sets, of course
10:07:04 <Heffalump> can you find some concrete property or statement that is true of one and not of the other?
10:07:08 <desegnis> (As opposed to a type system for working with computer data)
10:07:27 <desegnis> Hm
10:08:52 <newsham> n :: Int   -->     n \elementof [MININT .. MAXINT]
10:08:54 <newsham> whats the problem?
10:09:29 <desegnis> Maybe: There's a union of sets, not of types.
10:10:01 <Heffalump> even with union types? :-)
10:10:50 <desegnis> Those are disjoint unions, I guess?
10:10:50 <newsham> n \elementof { True, False }
10:11:00 <Heffalump> no, I don't mean disjoint unions
10:11:05 <newsham> n \elementof { Nothing, Just Int }
10:11:14 <Heffalump> I mean something which isn't tagged
10:11:26 <Heffalump> so in particular Union Int Int ~= Int
10:11:27 <newsham> thats set cross product
10:11:41 <Heffalump> no, that's product, not sum
10:11:42 <newsham> like tuples
10:12:19 <newsham> "Union Int Int" ->  Int x Int ?
10:12:28 <newsham> I must not be understanding yoru example
10:12:31 <desegnis> Ah. I didn't know such things exist out there
10:12:33 <Heffalump> this is an imaginary non-Haskell type
10:12:44 <Heffalump> I'm not certain they do exist, but why shouldn't they?
10:12:55 <Heffalump> and I think they do, there is literature about sum typing.
10:13:21 <kosmikus> Heffalump means that x \in Union A B if x \in A or x \in B
10:13:39 <Heffalump> right
10:14:20 <desegnis> Bah, I still insist on types not being the same as sets :-P
10:14:50 <kosmikus> desegnis: then replace \in by \hastype
10:14:52 <newsham> i'm sure some of the text here would have the answer :)
10:14:53 <newsham> http://www.cs.uu.nl/wiki/Techno/ProgrammingLanguageTheoryTextsOnline
10:14:54 <lambdabot> http://tinyurl.com/37xq5g
10:15:13 <augustss> nothing wrong with union types
10:15:19 <syntaks> erm, is it by intention, that there is no read function returning a maybe? like readm :: Read a => String -> Maybe a
10:15:32 <newsham> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/  <-onlinebook on type theory
10:15:33 <lambdabot> Title: Type Theory and Functional Programming
10:15:37 <desegnis> kosmikus: Then I get an analogy to set unions, but I don't get sets
10:15:40 <syntaks> or is it just that I'm not looking hard enough?
10:16:01 <Heffalump> syntaks: isn't Maybe an instance of Read?
10:16:22 <desegnis> syntaks: I think there's reads :: Read a => String -> [a]
10:16:22 <Heffalump> instance (Read a) => Read (Maybe a) -- Defined in GHC.Read
10:16:30 <Heffalump> so just use read
10:16:36 <kosmikus> I don't think syntaks is looking for that
10:16:48 <Heffalump> oh, something that might fail?
10:16:54 <kosmikus> right
10:16:55 <newsham> this book defines a type as a proposition and a value of that type as a proof.
10:17:02 <syntaks> > (read "x") :: Maybe Int -> *** Exception: Prelude.read: no parse
10:17:02 <lambdabot>  Parse error at "***" (column 28)
10:17:04 <newsham> p : P    p is a proof of proposition P
10:17:04 <Heffalump> then yes, use reads and take the first element if there is one
10:17:05 <kosmikus> I think the best option there is to use reads
10:17:06 <desegnis> syntaks: The empty list then means the same as Nothing
10:17:12 <Heffalump> and insist on the second-element of the tuple being ""
10:17:52 <syntaks> I built my own as readm str = listToMaybe [y | (y, _) <- reads str]
10:17:57 <newsham> "central to the type theory is the duality betwen propositions and types, proofs and elements: a proof of a proposition T can be seen as a member of the type T, and conversely."
10:18:06 <desegnis> syntaks, (I got the type wrong, though)
10:18:06 <syntaks> but this feels like it should already be there :)
10:18:18 <Saizan> you can interpret the type P as { x in Terms | x is a proof of P }
10:18:25 <Heffalump> syntaks: you should make that be (y, "") <- ..., unless you really do want to just read prefixes
10:18:34 <desegnis> syntaks: The read/reads system does feel a little antique
10:18:51 <Heffalump> perhaps overloading in a monad a la Map.lookup would be better
10:20:11 <newsham> hmmm this looks like a good book
10:20:38 <syntaks> Maybe is in Read, but not the way one would hope :)
10:20:55 <syntaks> > (read "Just 1") :: Maybe Int
10:20:55 <lambdabot>  Just 1
10:21:09 <syntaks> grr
10:22:56 <desegnis> newsham, thanks for the book reference, looks useful
10:23:42 <Heffalump> I still don't know why types aren't sets, though :-)
10:24:13 <augustss> types have more structure than sets
10:24:36 <newsham> > readDec "123abc"
10:24:37 <lambdabot>  [(123,"abc")]
10:25:11 <Heffalump> can't you express that as a relationship between sets, though?
10:25:34 <newsham> > do { [n,""] <- readDec "123"; return n }  :: Just Int
10:25:34 <lambdabot>   Not in scope: type constructor or class `Just'
10:25:40 <newsham> > do { [n,""] <- readDec "123"; return n }  :: Maybe Int
10:25:40 <lambdabot>  Couldn't match expected type `Maybe t'
10:26:13 <newsham> > do { let [n,""] = readDec "123"; return n }  :: Maybe Int
10:26:13 <lambdabot>  Parse error at "}" (column 43)
10:26:48 <mauke> > do { let {[n,""] = readDec "123"}; return n }  :: Maybe Int
10:26:48 <lambdabot>  Couldn't match expected type `[Char]'
10:27:29 <newsham> > do { let [(n,"")] = readDec "123"; return n }  :: Maybe Int
10:27:29 <lambdabot>  Parse error at "}" (column 45)
10:27:38 <newsham> > do { let {[(n,"")] = readDec "123"}; return n }  :: Maybe Int
10:27:39 <lambdabot>  Just 123
10:27:45 <newsham> > do { let {[(n,"")] = readDec "1x23"}; return n }  :: Maybe Int
10:27:46 <lambdabot>   Irrefutable pattern failed for pattern [(n, "")]
10:27:52 <newsham> blah :)
10:28:14 <Heffalump> don't use let, use <- return
10:28:38 <newsham> > case readDec "1234" of [(n,"")] -> Just n; _ -> Nothing
10:28:39 <lambdabot>  Just 1234
10:28:46 <newsham> > case readDec "12x34" of [(n,"")] -> Just n; _ -> Nothing
10:28:47 <lambdabot>  Nothing
10:29:08 <Heffalump> > do { [(n, "")] <- return (readDec "1x23") ; return n } :: Maybe Int
10:29:08 <lambdabot>  Nothing
10:29:22 <guenni> newsham: hope you don't mind, what made you read the book, I have never come accross it before?
10:29:40 <newsham> guenni: i was interested in zed
10:30:00 <guenni> newsham: thx
10:30:13 <newsham> guenni: if you want something more rigorous: http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
10:30:14 <lambdabot> Title: Type Theory and Functional Programming
10:43:30 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6712
10:51:21 * ehird is toying with variadic functions
10:51:23 <ehird> trying the most basic one:
10:51:26 <ehird> argc :: Integer => 0
10:51:31 <ehird> argc a :: Integer => 1
10:51:33 <ehird> argc a b :: Integer => 2
10:51:35 <ehird> and so on
10:51:43 <ehird> i'm trying to do it with the minimum extensions
10:51:50 <Heffalump> you don't need any, do you?
10:51:55 <ehird> Heffalump: dunno
10:51:56 * SamB wonders when he will be able to use gold
10:51:57 <ehird> we'll see
10:52:00 <ehird> class ArgcType a where argc :: a
10:52:02 <ehird> that's my base
10:52:02 <Heffalump> oh, perhaps you do need FlexibleInstances
10:52:06 <ehird> yes
10:52:08 <ehird> flexibleinstances
10:52:18 <ehird> instance ArgcType Integer where argc = 0
10:52:22 <Heffalump> no, you shouldn't
10:52:38 <ehird> and that's as far as I've got
10:52:47 <ehird> because I need to somehow inductively define the function case
10:52:50 <Heffalump> just add an increment routine to ArgcType too
10:53:00 <ehird> instance (ArgcType r) => ArgcType (a -> r)
10:53:03 <ehird> is the best I've got
10:53:05 <Heffalump> class ArgcType a where argc :: a ; increment :: a -> a
10:53:23 <ehird> ahh
10:53:24 <Saizan> Text.Printf is h98, s0
10:53:24 <ehird> i see.
10:53:27 <Saizan> so
10:53:58 <SamB> except the small matter of the . in the module name ;-)
10:54:05 <Heffalump> :-)
10:54:24 <ehird> with 'increment'
10:54:24 <ehird> instance (ArgcType r) => ArgcType (a -> r)
10:54:27 <ehird> is still correct, yes?
10:54:29 <Heffalump> actually I don't think that type works since argc isn't of type a -> r
10:54:35 <SamB> but of course that is easily fixed, and happily you don't need to fix it
10:54:39 <Heffalump> I think you need to fix on your return type as Integer
10:54:43 <ehird> Heffalump: can't be, for the 0 case
10:54:51 <ehird> and if I fix on the return type, then that only handles 1 argument
10:54:52 <ehird> not 2, 3..
10:55:00 <Heffalump> oh, never mind, I'm confused
10:55:09 <Heffalump> yes, I think that instance is still right.
10:55:15 <Heffalump> But increment isn't that simple.
10:55:21 <ehird> yes
10:55:23 <Heffalump> oh, perhaps it is, cos you can just lift it each time.
10:55:26 <ehird> it seems like it must be polymorphic
10:55:28 <ehird> to a -> Integer
10:55:30 <ehird> and a -> r
10:55:38 <Heffalump> argc _ = increment argc
10:55:57 <ehird> increment :: (ArgcType r) => (a -> r) -> a -> r
10:55:59 <ehird> for my type
10:56:11 <Heffalump> right, and you have r -> r
10:56:18 <ehird> yeah
10:56:44 <Heffalump> so increment f n = increment (f n)
10:56:58 <SamB> eh?
10:56:59 <Heffalump> this seems a bit convoluted.
10:57:03 <ehird> aha
10:57:05 <SamB> no kidding
10:57:05 <ehird> that increment is genious
10:57:05 <ehird> :)
10:57:10 <ehird> yeah
10:57:14 <ehird> increment is superflouous
10:57:16 <ehird> I'm sure I can remove it
10:57:19 <Heffalump> I'm sure there's a simpler way, but I'm lazy and cba to work it out.
10:57:24 <Heffalump> You just need a better type for argc.
10:57:33 <ehird> Heffalump: Well, argc must be able to be a plain Integer.
10:57:38 <ehird> So I can't do (a -> r)
10:57:58 <Heffalump> but you could make argc implemented in terms of something that's actually in the class.
10:58:36 <ehird> yes, that's true
10:58:40 <ehird> ok, i'll just have argc' :: a -. r
10:58:46 <ehird> hm
10:59:10 <ehird> @paste
10:59:10 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:59:27 <hpaste>  ehird pasted "saving argc here while i mess it up" at http://hpaste.org/6713
11:00:19 <Heffalump> wow, doesn't your filesytem have cp? :-)
11:01:00 <matthew-_> DRM at work
11:01:28 <ehird> Heffalump: terminal is in the background
11:01:29 <ehird> :P
11:01:54 <joricj> "instance Eq (Buffer a) where" gives me an error, why?
11:02:14 <Heffalump> what error?
11:02:46 <joricj> The instance type must be of form (T a b c) where T is not a synonym, and a,b,c are distinct type variables)
11:02:58 <joricj> oh wait, maybe i have to use data instead of type
11:03:18 <joricj> oh no then i have to rewrite everything
11:03:33 <Heffalump> what is Buffer defined as?
11:03:50 <Heffalump> it is possible to disable that error with a GHC extension, but it is probably not a good idea
11:03:58 <joricj> type Buffer a = ( Int, TChan a, TMVar Int, TMVar Bool)
11:05:03 <Heffalump> ok, then if you want a different Eq to the default you need to use a newtype/data
11:05:32 <Heffalump> there may not be a default one because TChan and TMVar may well not have Eq instances, but that'll be for good reason
11:05:43 <Heffalump> I think you should define your own type, it'll avoid trouble later
11:06:25 <joricj> yeah i'm gonna do that now
11:06:38 * Corun wonders if anyone here knows a good free ftp server to download anime off of
11:06:48 <joricj> what's like the golden rule of when to use "type" and when to use "data"
11:06:48 <Zao> Corun: Find store, insert coin.
11:06:55 <opqdonut> Corun: bittorrent :>
11:07:03 <newsham> type just gives a new name to an existing type
11:07:07 <newsham> data creates a new type
11:07:10 <opqdonut> warez ftp usually isn't open
11:07:16 <Heffalump> joricj: use type for a quick shorthand
11:07:16 <opqdonut> but this is offtopic
11:07:16 <newsham> and newtype is kinda half way between :)
11:07:28 <Heffalump> use data/newtype for something more long-lived/widely used
11:07:41 <opqdonut> type should only be used for simple aliases
11:07:43 <olsner> ehm, has the ByteString lines function disappeared?
11:08:08 <Heffalump> changing from one to the other isn't so onerous, given that the type system will tell you where you forgot
11:08:50 <dcoutts_> olsner: it's in the .Char8 modules, since treating something as lines means considering it as ASCII text
11:09:01 <dcoutts_> lines isn't something you do to binary data
11:09:12 * ehird is now tackling (build a b c) => [a,b,c]
11:10:03 <olsner> oh, I see
11:10:21 <EvilTerran> ?type (.return).(:)
11:10:22 <lambdabot> forall a. a -> a -> [a]
11:10:25 <olsner> sounds like a good thing to do actually
11:10:37 <Heffalump> ehird: that'll be harder since you requre them all to be the same type
11:10:55 <ehird> Heffalump: yep
11:11:00 <Heffalump> you'll need some extensions for that if you want to also make it polymorphic over the type.
11:11:04 <ehird> oh
11:11:06 <Heffalump> (I think)
11:11:08 <ehird> then i'll just build lists of integers
11:11:17 <Heffalump> I don't know how else you could constrain it.
11:11:30 <EvilTerran> > ((.return).(:)) x y
11:11:31 <lambdabot>  [x,y]
11:11:39 <ehird> > ((.return).(:)) x y z
11:11:40 <lambdabot>  Couldn't match expected type `t -> t1' against inferred type `[a]'
11:11:40 * EvilTerran wanders off, mumbling to himself
11:11:44 <ehird> qed
11:11:52 <EvilTerran> i know, i wasn't aiming for that
11:12:08 <EvilTerran> i was just reminding myself of the two-item version before going for the three-item one
11:13:53 <Heffalump> there's probably some trick with join and return.
11:14:09 <Heffalump> @type join return
11:14:10 <lambdabot> forall a. a -> a
11:14:18 <Heffalump> @type join . return
11:14:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
11:14:22 <Heffalump> hmph
11:14:38 <Heffalump> oh, join is the wrong way round
11:14:45 <Heffalump> silly me
11:17:07 <keir> is there a good description of the haskell type system somewhere? I can't seem to find anything good at haskell.org or via google. I'm looking for gory details.
11:18:12 <shachaf> keir: In the report?
11:18:15 <opqdonut> the ghc manual? the haskell raport?
11:18:17 <opqdonut> ?go slpj
11:18:19 <lambdabot> http://research.microsoft.com/~simonpj/papers/slpj-book-1987/index.htm
11:18:19 <lambdabot> Title: The Implementation of Functional Programming Languages
11:18:23 <opqdonut> or that
11:18:49 <cjb> also e.g. http://c2.com/cgi/wiki?HindleyMilnerTypeInference
11:18:49 <lambdabot> Title: Hindley Milner Type Inference
11:19:03 <joricj> is there any way to close a TChan?
11:19:22 <keir> cool, thanks
11:23:00 <ehird> i wonder if I can do prime :: ... -> Bool
11:23:13 <ehird> equiv. to 'prime? my argc'
11:24:18 <Feuerbach> ehird: what's the problem?
11:25:14 <ehird> Feuerbach: what do you mean?
11:25:19 <ehird> just playing around with variadic functions? :)
11:25:23 <ehird> i.e.
11:25:32 <ehird> (prime :: Bool) => False
11:25:36 <ehird> (prime a b :: Bool) => True
11:26:06 <Feuerbach> ah, you mean variadic functions
11:26:31 <newsham> whats the mechanism that makes that work?
11:26:35 <Feuerbach> I thought you're talking about prime numbers
11:26:47 <xerox> hehe yeah it is indeed possible
11:27:06 <Feuerbach> see Text.Printf for example
11:27:14 <xerox> although not quite efficient in general.
11:27:51 <ehird> i am talking about prime numbers
11:27:59 <ehird> 'prime
11:28:06 <ehird> ', when called with a number of arguments that is prime,
11:28:10 <ehird> as a Bool, is True
11:28:12 <ehird> otherwise, it is False
11:28:25 <quicksilver> it would be simple enough to build a function which calls 'isPrime :: Int -> Bool'
11:28:32 <quicksilver> with an integer based on the number of args it has.
11:28:47 <quicksilver> (so yes, what you ask for is certainly possible)
11:29:32 <ehird> quicksilver: that's true
11:30:07 <ehird> hmm. I want to implement a language in Haskell that supports serialization of most everything (functions, continuations, etc)
11:30:11 <ehird> either scheme or smalltalk
11:30:32 <SamB> oh, you mean imagization?
11:30:56 <ehird> SamB: no, that's seperate from what i said before
11:30:57 <ehird> haha
11:31:05 <ehird> and pretty much imagization, but of seperate objects
11:31:07 <ehird> so:
11:31:18 <ehird> (serialize (lambda (x) (+ x 1)))
11:31:19 <Cale> It would be *really* cool if we could serialise unevaluated things.
11:31:21 <ehird> would serialize a closure
11:31:30 <ehird> SISC can do that, so it's obviously quite possible
11:31:36 <ehird> or, for smalltalk:
11:31:39 <Cale> Say, like infinite lists.
11:31:43 <ehird> [ :x | x + 1 ] serializeTo: stdout
11:31:55 <ehird> the smalltalk would look nicer, the scheme easier to implement :)
11:32:02 <SamB> Cale: well, it would be very unsafe
11:32:12 <Cale> SamB: oh?
11:32:23 <SamB> what if there was an unsafe{Perform,Interleave}IO in there somewhere?
11:32:32 <Cale> SamB: It would not be performed.
11:32:39 <ehird> SamB: that's called the "do not try stupid things" rule
11:32:43 <Cale> SamB: (until the thing came back out of the file)
11:32:44 <ehird> so, it would do something
11:32:50 <SamB> Cale: well, that was my point!
11:33:05 <ehird> I want serialization of functions though
11:33:09 <shachaf> SamB: Besides, the serialization isn't the unsafe thing, unsafePerformIO is. :-)
11:33:13 <Cale> SamB: But presumably that call to unsafePerformIO is actually safe, and it doesn't matter when we call it :)
11:33:15 <ehird> I know you will never be able to serialize e.g. sockets
11:33:17 <ehird> and so that would be hard
11:33:21 <ehird> Answer: carefully delimited continuations
11:33:23 <Cale> ehird: Why not?
11:33:28 <SamB> shachaf: it's far more unsafe if it later gets performed on a completely different computer!
11:33:29 <ehird> Cale: You can't serialize a socket.
11:33:30 <ehird> That makes no sense.
11:33:51 <Cale> ehird: You can certainly do it. It just might not be open when you deserialise it later.
11:34:11 <shachaf> Sure, but unsafePerformIO is a way of saying "trust me".
11:34:33 <shachaf> It's your own fault if it gets used in an odd way later on. :-)
11:34:45 <Cale> SamB: The point of unsafePerformIO is that it's dangerous and you're supposed to check that it doesn't really matter when the IO gets done.
11:34:50 <ehird> Cale: Well, no, that actually makes no sense :)
11:34:58 <ehird> It would have to serialize the very connection itself.
11:35:21 <keir> i apologize if this is a stupid question. Does haskell have 'interfaces' in the sense of java? i.e. where there is set of function signatures which may have multiple implementations?
11:35:22 <SamB> Cale: but... it's not your fault if someone crazy tries to perform the computation in an entirely different process!
11:35:31 <newsham> but if you thikn of a type as a promise, and you have a file which promises that its pure, and you load it up, and your promise is broken because of an unknown unsafeperofmormio
11:35:44 <shachaf> SamB: It's their fault.
11:35:53 <newsham> things from files/net/etc can be untrusted things
11:35:56 <dons> keir: yeay, type classes
11:36:00 <newsham> you would like to have good promises about them
11:36:08 <SamB> see, this is why I say that the serialization wouldn't be safe
11:36:08 <shachaf> SamB: Sorry, I misunderstood.
11:36:27 <shachaf> SamB: It is your fault -- you're the one who used an unsafe function.
11:36:40 <Cale> SamB: If you're really worried about it, then the serialiser could just throw an exception if it bumped into an unsafePerformIO
11:36:54 <SamB> Cale: or have an option to do so...
11:36:57 <Cale> SamB: But I don't see it as very important to worry about that :)
11:36:58 <newsham> cale: yah, thats prob an appropriate solution
11:37:00 <ehird> Correct me, but if you could serialize functions you could serialize thunks
11:37:05 <keir> dons, ok. so you define a type class that is for a function that maps between high level types? then there can be multiple implementations?
11:37:13 <ehird> So you get serializable continuations ANd infinite lists and god knows what.
11:37:23 <ehird> Serialization would, of course, be automatic on all types. :D
11:37:24 <SamB> perhaps I should have said "readFile"
11:37:32 <ehird> serialize :: a -> ByteString
11:37:36 <SamB> *now* what do you say?
11:37:37 <Cale> I'd really like something which let me take an arbitrary IO action and write it to a file as an executable.
11:37:45 <ehird> deserialize :: ByteString -> a    -- not type safe, but what the heck
11:37:55 <ehird> Cale: If you had those two built-ins, you could do it
11:38:02 <dons> keir: a type class lets you define a generic operation, and then you can instantiate it to different types, yes.
11:38:03 <Cale> ehird: Not quite.
11:38:06 <ehird> Well, and some kind of compiler interface.
11:38:06 <SamB> Cale: that's crazier than a way to get GDB to dump a core that can be resumed from!
11:38:09 <Cale> ehird: yeah
11:38:10 <ehird> But you could do this:
11:38:24 <ehird> compile = serialize
11:38:26 <ehird> run = deserialize
11:38:33 <ehird> then, a runner's main:
11:38:50 <ddarius> Clean can serialize arbitrary values.
11:38:50 <ehird> main = run "serialized code"
11:38:58 <ehird> ddarius: Yeah this is pretty much that
11:39:11 <Cale> SamB: You'd presumably just produce a copy of the running program with a copy of the current heap and a call to run that IO action at the start.
11:39:13 <ehird> deserialize's type, while certainly quite unsafe, should not cause that many problems
11:39:14 <SamB> ddarius: what happens when you serialize an OS handle of some kind?
11:39:24 <ehird> I mean, you'd still get type errors in most cases
11:39:32 <Cale> So you wouldn't even need to embed a whole compiler to do it.
11:39:38 <newsham> sin = deserialize data TypeSafe :: Int -> Int
11:39:51 <Cale> Just a bit of machinery for operating on the existing compiled program.
11:39:52 <newsham> should give me a promise that sin is of type Int -> Int and cannot perform side effects
11:39:57 <ddarius> SamB: The same thing that happens in every other language that supports these things.
11:40:01 <newsham> err probably Double -> Double :)
11:40:19 <SamB> ddarius: which is?
11:40:33 <ehird> newsham: that's too complex
11:40:45 <newsham> why?
11:40:50 <ehird> foo :: ByteString -> Int -> Int; foo = deserialize
11:40:52 <ehird> voila, type-safe
11:41:12 <ehird> yes, of course 'serialize' and 'deserialize' would be highly magic specially-handled stuff
11:41:19 <ehird> but the outward interface is elegant and type-safe for the most part
11:41:30 <newsham> samb: you are basically supporting the same features as process migration.  ie you could wrap up your whole program at any point, serialize it, ship it across the net, and have someone else unserialize it and continue your process
11:41:32 <ehird> (since type inferrence will find out what kind of type you want the deserialized value to be)
11:41:33 <ddarius> SamB: The value that represents the handle gets serialized and when it is deserialized it is (most likely) no longer relevant and you'll end up with some kind of error when you attempt to use it.
11:41:50 <ehird> deserializeNum :: (Num a) => ByteString -> a
11:42:01 <ehird> deserializeMyDataType :: ByteString -> MyDataType
11:42:04 <ehird> etc etc etc
11:42:38 <SamB> ddarius: ah.
11:43:30 <ehird> ddarius: does clean have continuations?
11:43:51 <SamB> ehird: why do you ask?
11:44:03 <ddarius> SamB: You could, as newsham says, add support for localizing and migrating such resources.  An interesting recent paper uses modal logic for that in the context of the type system for an ML based language.
11:44:07 <Cale> ehird: Perhaps  serialise :: (Typeable a) => a -> ByteString,  deserialise :: (Typeable a) => ByteString -> Maybe a
11:44:12 <ddarius> ehird: Clean is pretty much just like Haskell.
11:44:25 <ehird> Cale: No, no. That's not automatic enough. :-)
11:44:39 <ehird> + you can't do a lot of magical things with it
11:44:46 <Cale> huh?
11:44:57 <Cale> You can serialise almost everything with that.
11:44:57 <ehird> Anyway, the cases where 'deserialize' would be non-type-safe are few and far between.
11:45:02 <Cale> Just not polymorphic values.
11:45:04 <ehird> Cale: Functions?
11:45:08 <Cale> yes, of course
11:45:15 <ehird> hmm
11:45:19 <ehird> is that implementable, right now?
11:45:41 <Cale> Almost, except for the actual serialisation, you might need some lower level stuff for that.
11:45:45 <ehird> Ah.
11:45:47 <ehird> Damn.
11:46:09 <Cale> also, you'd want to follow the closure pointers around
11:46:39 <ehird> Cale: Well, exactly.
11:46:47 <ehird> The typeable stuff in yours is just an illusion
11:46:47 <ehird> :p
11:46:58 <Cale> hm? It's just the mechanism for storing the type
11:47:12 <Cale> So that when we get the thing out again, we know that we have the right type of thing.
11:47:25 <ehird> there's no typeable for functions is there?
11:47:31 <ehird> Cale: Will that work across processees?
11:47:33 <Cale> :t toDyn ((*2) :: Int)
11:47:34 <lambdabot>     The section `(* 2)' takes one argument,
11:47:34 <lambdabot>     but its type `Int' has none
11:47:34 <lambdabot>     In the first argument of `toDyn', namely `((* 2) :: Int)'
11:47:35 <ehird> Computers?
11:47:38 <Cale> :t toDyn ((*2) :: Int -> Int)
11:47:39 <lambdabot> Dynamic
11:47:46 <Cale> :t fromDynamic (toDyn ((*2) :: Int -> Int))
11:47:47 <lambdabot> forall a. (Typeable a) => Maybe a
11:47:49 <ehird> @type toDyn
11:47:50 <lambdabot> forall a. (Typeable a) => a -> Dynamic
11:48:03 <ehird> @hoogle (Typeable a) => a -> Dynamic
11:48:03 <lambdabot> Data.Dynamic.toDyn :: Typeable a => a -> Dynamic
11:48:18 <Cale> :t fromJust (fromDynamic (toDyn ((*2) :: Int -> Int)) :: Maybe (Int -> Int)) 5
11:48:19 <lambdabot> Int
11:48:22 <Cale> > fromJust (fromDynamic (toDyn ((*2) :: Int -> Int)) :: Maybe (Int -> Int)) 5
11:48:23 <lambdabot>  10
11:48:35 <Cale> > fromJust (fromDynamic (toDyn ((*2) :: Int -> Int)) :: Maybe (Float -> Float)) 5
11:48:35 <lambdabot>  Exception: Maybe.fromJust: Nothing
11:48:53 <opqdonut> ah, that's the way it works
11:53:52 <ehird> fromDynamicM :: (Monad m, Typeable a) => Dynamic -> m a
11:53:52 <ehird> fromDynamicM d =
11:53:52 <ehird>     case fromDynamic d of
11:53:52 <ehird>       Just a -> return a
11:53:52 <ehird>       Nothing -> fail "fromDynamicM: can't deserialize value"
11:53:56 <ehird> uhh, that's bigger than it looked
11:53:57 <ehird> :)
11:54:12 <ehird> *** Exception: user error (fromDynamicM: can't deserialize value)     -- oddly shows up like this
11:55:03 <matthew-_> so this is brilliant. If I :t someExpr in ghci then it works. If I paste someExpr into the loaded .hs and reload, ghci blows up with a huge type error
11:56:07 <keir> is my understand that haskell's type system makes something like e.g. c++ templates irrelevant?
11:56:10 <ehird> hmm
11:56:18 <ehird> all I have to implement is a Dynamic serialize
11:56:20 <keir> *correct
11:56:21 <dons> keir: its more expressive, and safer, yeah
11:56:24 <ehird> I wonder if Derive will do it for me :p
11:56:30 <ddarius> dons: It's less expressive
11:56:41 <ddarius> Or at best, differently expressive
11:56:47 <dons> ddarius: how much of the type system are you including?
11:57:08 <matthew-_> how can this happen?
11:57:11 <ddarius> dons: All of Haskell 98 at least.
11:57:17 <dons> is C++ template metaprogramming also turing complete?
11:57:21 <ddarius> dons: Yes
11:57:24 <shachaf> matthew-_: @paste?
11:57:30 <dons> ah ok. so they're both scary
11:57:35 <ehird> hmm
11:57:41 <ehird> I just have to make it derive Binary methinks
11:57:41 <dons> the h98 type system is rarely used
11:57:42 <ehird> :p
11:57:46 <matthew-_> shachaf: yeah, it's huge
11:58:04 <ddarius> dons: The things that make Haskell's type system Turing complete are rarely used as well.
11:58:12 <ddarius> And are explicit extensions.
11:58:20 <shachaf> matthew-_: So can you @paste someExpr and the error? :-)
11:58:28 <Cale> keir: Haskell 98's type system isn't Turing complete like C++ templates are, but it already covers over 90% of everything you'd want to do with templates.
11:58:32 <matthew-_> shachaf: the error is about 3000 lines long
11:58:33 <dons> but does haskell's type system make C++ template irrelevant? yes
11:58:44 <dons> since there's no reason to add templates
11:58:46 <shachaf> @paste someExpr, then? :-)
11:58:46 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:58:56 <Cale> keir: GHC's type system with extensions is Turing complete, and you can do everything in it which you can do with C++ templates, but it's slightly clearer.
11:59:00 <dons> and its conflating code generatoin and typing anyway
11:59:07 <ddarius> Cale: Not always.
11:59:20 <Cale> ddarius: an example?
11:59:24 <ddarius> dons: C++'s type language is a lazy functional one.
11:59:48 <K0MPR3SS0R> hey its me again
11:59:52 <dons> didn't know it was lazy, but yes, the general rule that all languages approach purely functional ones in the limit :)
11:59:53 <K0MPR3SS0R> how you all doing?
11:59:55 <ddarius> Cale: Write factorial using C++ templates and Haskell type classes.  Other than some arbitrary verbosity, it's clearer in C++.
11:59:55 <ehird> Haskell -> C++ templates compiler :D
11:59:57 <EvilTerran> oh it's him again
11:59:58 <hpaste>  matthew-_ pasted "weird ghc bug?" at http://hpaste.org/6714
12:00:08 <ehird> 'him'?
12:00:12 <ddarius> ehird: I did a very cut down sort of thing as one of my earliest Haskell projects.
12:00:23 <EvilTerran> ehird, yeah. no girls on the internets.
12:00:58 <Cale> matthew-_: What errors?
12:01:02 <allbery_b> matthew_: add the errors as an annotation?  but I think there are known cases of that
12:01:08 <Cale> matthew-_: and how are you putting that in the file?
12:01:14 <allbery_b> the ghci prompt is not quite the same as a program
12:01:15 <Cale> f n = runInterleaved ...
12:01:17 <Cale> or:
12:01:20 <Cale> f = \n -> ...
12:01:28 <matthew-_> tried both
12:01:35 <matthew-_> and the errors are no such instance errors
12:01:43 <shachaf> Cale: <matthew-_> shachaf: the error is about 3000 lines long
12:01:48 <Cale> Is there anything else in your file?
12:01:57 <matthew-_> yes
12:02:12 <matthew-_> eg distributePids and makeMesh
12:02:19 <Cale> But presumably only the definitions which are in scope in GHCi?
12:02:24 <ddarius> dons: While I wouldn't want to add it to Haskell (and it wouldn't really fit anyway), there are some things C++ templates can do readily that would be rather awkward for Haskell.  (And templates are only part of C++'s type system.)  That said, the reason templates were added to C++ was to support parametric polymorphism and Haskell certainly does a better job at that.
12:02:24 <matthew-_> correct
12:02:29 <matthew-_> there's nothing that's hidden
12:02:39 <Cale> hmm
12:02:51 <dons> ddarius: yeah, i can imagine there are different strong and weak points
12:02:57 <matthew-_> I'm wondering if the presence of the extra func someExpr is influencing the type checker
12:03:07 <matthew-_> so it's actually an ordering bug in the type chekcer
12:03:16 <Cale> extraFunc?
12:03:21 <Cale> er
12:03:24 <Cale> duh
12:03:27 <Cale> someExpr?
12:03:48 <Cale> (clearly the coffee has not yet taken effect!)
12:03:54 <matthew-_> the thing I pasted!
12:04:09 <Cale> oh, that's what you named it
12:04:12 <Cale> okay
12:04:36 <Cale> can I see the first 5 or 10 lines of the first error?
12:04:59 <matthew-_> yeah, the first few are overlapping instance errors
12:05:00 <allbery_b> MMR vs. lambda / named function distinction?
12:05:10 <matthew-_> then you get down to the crux of the matter which is the missing type instances
12:05:19 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6715
12:05:25 <hpaste>  matthew-_ annotated "weird ghc bug?" with "first error" at http://hpaste.org/6714#a1
12:05:30 <K0MPR3SS0R> hi
12:05:34 <K0MPR3SS0R> i posted that on hpaste
12:05:36 <Cale> matthew-_: Oh, it may have something to do with the way that GHCi defaults types then
12:05:43 <K0MPR3SS0R> I need help with my BST for deleting a node
12:05:56 <K0MPR3SS0R> I have a count value and a character at each node
12:06:01 <hpaste>  matthew-_ annotated "weird ghc bug?" with "...then eventually" at http://hpaste.org/6714#a2
12:06:20 <K0MPR3SS0R> if I delete a value at the node, and that node has children, I want to rearange the BST so that it is still valid
12:06:33 <newsham> kompresor does not dance
12:06:37 <K0MPR3SS0R> and I need to make sure that the count value is also preserved
12:06:42 <K0MPR3SS0R> eheheh newsham
12:06:47 <K0MPR3SS0R> wow
12:06:56 <K0MPR3SS0R> very few people know of that song
12:07:20 <newsham> tis a shame
12:08:07 <ehird> hey, i know it
12:08:14 <ehird> whois K0MPR3SS0R
12:08:26 <ehird> eh
12:08:26 <ehird> :D
12:08:26 <Cale> matthew-_: Try adding  {-# LANGUAGE ExtendedDefaultRules #-}  to the top of your file
12:08:28 <Cale> matthew-_: and see if it helps ;)
12:08:29 <K0MPR3SS0R> ?
12:08:44 <Cale> K0MPR3SS0R: he mistyped a command :)
12:08:45 <ehird> we need an: -fallow-stupid-instances
12:08:54 <ehird> then an -fallow-evil-instances
12:08:57 <ehird> and an -fallow-drunk-instances
12:09:03 <K0MPR3SS0R> alrighty so uhmm can someone help me figure this out?
12:09:09 <K0MPR3SS0R> http://hpaste.org/6715
12:09:16 <Cale> K0MPR3SS0R: yep, if you'll just hold on a sec
12:09:20 <K0MPR3SS0R> sure np
12:09:33 <matthew-_> Cale: no dice. Sorry.
12:09:37 <Cale> matthew-_: hmm
12:10:12 <Cale> matthew-_: So let's see what this type error is saying. It's saying that there's a choice between two instances and it doesn't know which one to use.
12:10:23 <newsham> http://www.youtube.com/watch?v=Y-2vVKEMoPY
12:10:24 <lambdabot> Title: YouTube - Kompressor - K Is For Kompressor (Kompressor Is For DJ Lee M
12:10:31 <matthew-_> yeah, but those are never the main issue
12:10:44 <matthew-_> IME they always disappear if you can satisfy the instances
12:10:59 <matthew-_> and the instance says it's trying to pull a value out of an empty list
12:11:09 <matthew-_> which clearly is correct that there's no instance to do that
12:11:20 <matthew-_> so quite why it thinks it wants to index an empty list is beyond me
12:11:35 <matthew-_> esp seeing as in ghci directly, it doesn't
12:11:38 <Cale> matthew-_: sorry?
12:11:43 <matthew-_> TyListIndex
12:11:47 <K0MPR3SS0R> I have kompressor cd and tshirt
12:12:04 <matthew-_> class TyListIndex lst idx res | lst idx -> res where
12:12:07 <matthew-_> ...
12:12:26 <Cale> matthew-_: Oh, you're referring to the later error.
12:12:28 <matthew-_> yep
12:12:50 <ehird> where is unsafeCoerce again?
12:12:58 <Cale> What happens if you turn on incoherent instances?
12:13:00 <EvilTerran> ?hoogle unsafe
12:13:00 <lambdabot> Language.Haskell.TH.unsafe :: Safety
12:13:00 <lambdabot> Language.Haskell.TH.Lib.unsafe :: Safety
12:13:00 <lambdabot> System.IO.Unsafe :: module
12:13:03 <Cale> Does the program work?
12:13:07 <EvilTerran> ?hoogle+
12:13:07 <lambdabot> Data.ByteString.Unsafe :: module
12:13:07 <lambdabot> Language.Haskell.TH.Unsafe :: Safety
12:13:07 <lambdabot> Language.Haskell.TH.Syntax.Unsafe :: Safety
12:13:10 <EvilTerran> hm
12:13:13 <EvilTerran> ?hoogle coerce
12:13:14 <lambdabot> Unsafe.Coerce :: module
12:13:14 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
12:13:24 <Cale> Or you probably still get the second type error?
12:13:30 <matthew-_> Cale: I'd hope not...
12:14:01 <matthew-_> ..., no type checker still blows up in the same way
12:14:08 <Cale> hmm
12:14:08 <matthew-_> in this particular file, I have no extensions turned on
12:14:10 <ehird> @. hoogle type ap
12:14:11 <lambdabot> Hoogle Error: Parse Error: Unexpected character '* -> *) a '
12:14:15 <ehird> Awww
12:14:18 <ehird> @type ap
12:14:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:14:25 <ehird> @hoogle m (a -> b) -> m a -> m b
12:14:25 <lambdabot> Prelude.asTypeOf :: a -> a -> a
12:14:25 <lambdabot> Prelude.const :: a -> b -> a
12:14:25 <lambdabot> Prelude.seq :: a -> b -> b
12:14:29 <ehird> fff
12:14:30 <Cale> matthew-_: It still asks you to turn on incoherent instances?
12:14:43 <Cale> matthew-_: (that is, you still get the first type error?)
12:14:47 <matthew-_> correct
12:14:54 <Cale> Okay, that's strange...
12:15:02 <matthew-_> because it wants it turned on in a different module
12:15:07 <Cale> ah, okay
12:15:17 <Cale> Well, what if you turn it on there?
12:15:37 <matthew-_> it's not going on there
12:15:43 <Cale> uh, all right
12:15:46 <matthew-_> those modules are well tested and are known correct
12:16:35 <Cale> So the problem is that idx' doesn't have a specific enough type.
12:16:51 <Cale> Isn't a specific enough type, rather
12:16:56 <matthew-_> the problem is that ghci is capable of correctly typing it when typed in, but not when it's in a file.
12:17:01 <Cale> In what expression, I'm not sure.
12:17:38 <matthew-_> no, the idx is irrelevant. The Nil shows that it's trying to index an empty list, which it should clearly never do
12:17:49 <Cale> matthew-_: Yeah, but GHCi can be much more relaxed about various things than GHC (though I would usually think the extended default rules would cover it)
12:18:09 <Cale> matthew-_: I'm still looking at the first error.
12:18:13 <matthew-_> oh I see
12:18:16 <EvilTerran> @check (==)
12:18:17 <lambdabot>  OK, passed 500 tests.
12:18:20 <EvilTerran> :D
12:18:25 <oerjan> o_O
12:18:29 <oerjan> :t (==)
12:18:30 <lambdabot> forall a. (Eq a) => a -> a -> Bool
12:18:33 <matthew-_> it wants idx' to be less than 4
12:18:36 <Cale> @check \x y -> x == y
12:18:37 <lambdabot>  OK, passed 500 tests.
12:18:37 <oerjan> oh, right
12:18:41 <EvilTerran> oerjan, extended defaulting. it's defaulting to ()
12:18:44 <Cale> @check \x y -> x == (y :: Int)
12:18:45 <lambdabot>  Falsifiable, after 0 tests: -1, 1
12:18:54 <oerjan> i realized that a second later :D
12:18:59 <Jaak> @scheck (==)
12:19:01 <lambdabot>   Completed 1 test(s) without failure.
12:19:06 <ehird> Process haskell segmentation fault (core dumped)
12:19:07 <ehird> yaaay
12:19:07 <Jaak> :)
12:19:14 <matthew-_> hmm. actually I could rewrite those two instances so that they don't rely on overlapping instances
12:19:18 <matthew-_> a la the hlist paper
12:19:29 * ehird is trying (object in) -> (opaque object out)
12:19:36 <ehird> and making the object in be a Dynamic
12:19:40 <ehird> and then deriving a Binary instance for the out
12:19:55 <oerjan> ehird: ouch
12:20:00 <ehird> oerjan: you betcha
12:20:07 <ehird> but I think ghc exposes just enough internals to do that
12:20:26 <ehird> anyone in the know: tell me if this is impossible
12:20:47 <Cale> ehird: How are you deriving the Binary instance?
12:21:05 <Cale> and have you written any instances of Typeable by hand?
12:21:10 <oerjan> ehird: i don't think you can get a class for something in a Dynamic but i may be wrong
12:21:21 <ehird> Cale: I tried derive(1) at first but obviously that's not going to work
12:21:32 <Cale> derive?
12:21:37 <oerjan> (other than Typeable)
12:21:39 <ehird> Cale: so I guess I'm going to try dumping the internal memory representation
12:22:04 <ehird> maybe something under Foreign will help for that
12:22:17 <Cale> K0MPR3SS0R: okay, so you're removing a node from a counted BST?
12:23:28 <Cale> K0MPR3SS0R: So the count goes down by 1 for every node which is between the removed node and the root, right?
12:24:49 <ehird> making a (Binary Any) may be the thing to do
12:25:54 <Cale> ehird: The problem will almost certainly be that you won't generally be able to deserialise values in any program other than the one which created them, if that.
12:26:16 <Cale> (garbage collection makes it even less likely that pointers will point to the right place)
12:26:48 <ehird> Cale: I guess so. It's just a toy.
12:27:33 <matthew-_> Cale: rewriting those instances hasn't helped
12:27:39 <Cale> matthew-_: hmm
12:27:56 <ehird> How do I make my own TypeRep? :/
12:28:27 <Cale> ehird: Usually you derive Typeable
12:30:32 <matthew-_> ghc is taking about a minute to type check this
12:30:51 <matthew-_> hmm, I've also switched to use a different way of finding SmallerThan and still no joy
12:31:12 <ehird> Cale: NMT :)
12:31:14 <ehird> (not my type)
12:32:14 <Cale> matthew-_: What is all this type level programming for?
12:32:24 <matthew-_> oh it's my session type stuff
12:32:42 <matthew-_> Cale: have you seen http://www.wellquite.org/sessions/tutorial_1.html ?
12:32:43 <lambdabot> Title: Well Quite
12:32:45 <ehird> Cale: Basically I'm trying to derive (Typeable Any).
12:32:45 <ehird> :D
12:33:09 <Cale> matthew-_: nope
12:33:23 <matthew-_> then do so ;)
12:34:35 <SamB> what's a good way to pretty print tuples?
12:35:04 <gwern> SamB: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ZMachine-0.0
12:35:06 <lambdabot> http://tinyurl.com/2r9vl5
12:35:17 <SamB> gwern: how is that going to help me pretty print tuples?
12:35:53 <gwern> :)
12:36:24 <ehird> nobody?
12:36:44 <SamB> what is Any?
12:41:57 <matthew-_> grr, why does ghci not understand !-2
12:42:13 <mauke> what's !-2?
12:42:19 <matthew-_> !! of !!
12:42:27 <matthew-_> it's a bashism
12:42:34 <matthew-_> I'm not really ranting
12:42:36 <ehird> err, what
12:42:41 <mauke> oh, I don't use history expansion
12:42:46 <ehird> SamB: any is in GHC.Prim
12:42:57 <matthew-_> it's just one of those things which you think should be readline but it's actually bash
12:43:00 <ehird> SamB: it is 'data Any a' but you use it as 'Any'
12:43:07 <ehird> SamB: it tells the compiler it is not a data.
12:43:09 <ttt--> how come haskell is so difficult
12:43:13 <ehird> SamB: you can unsafeCoerce# to and from it safely.
12:43:20 <ehird> ttt--: it isn't
12:43:22 <SamB> ... oh
12:45:44 <dons> ttt--: yeah, its pretty easy -- we teach it to beginner programmers. its just different to imperative languages, so you can't reuse previous experience as much
12:46:04 <ehird> hmm. in most languages (that can handle it), a basic OS (level of 'Hello, world!') is pretty simple, you write some asm to get it up and running, then implement a small amount of runtime (in the language) to get the language actually working, then use some low level functions to push and poke memory
12:46:12 <ehird> it would be significantly harder in haskell, wouldn't it?
12:46:19 <ehird> because even things like laziness require lots of support
12:46:40 <dons> compiled graph reduction is a bit hard
12:46:49 <dons> it took till the 80s to work out how to compile it
12:47:09 * dcoutts_ prepares Cabal-1.4 release candidate and cabal-install snapshot
12:47:11 <matthew-_> so, like, half the history of computing...
12:47:16 <dons> then again, compiled dynamic languages are also a bit hard, it seems
12:47:27 <ehird> what i'm saying is -- in quite a lot of langugages (e.g. D) you can get an OS running in ~300 lines of that language
12:47:28 <dons> matthew-_: well, say, 10 years.
12:47:28 <ehird> and some asm
12:47:33 <dons> mid 70s to mid 80s
12:47:34 <ehird> with haskell it woudl be substantially harder, wouldn't it?
12:48:02 <dons> what are you trying to do? write a kernel?
12:48:05 * dcoutts_ ponders if he should announce Cabal-1.4 release candidate to haskell-cafe or just libraries list...
12:48:09 <ehird> dons: no, just curious
12:48:16 <ehird> if i can get 'hello world' displaying on the screen from haskell i'll be happy
12:48:31 <ehird> obviously there'd be no prelude or anything fancy like that
12:48:41 <ehird> but i'm wondering just how much you'd need to bootstrap to get it running on the bare metal
12:48:45 <ehird> just the minimum, of course
12:48:47 <dons> people write little compilers like this all the time.
12:48:56 <matthew-_> gosh, I actually hit a runtime infinite issue, rather than a compile time infinite issue
12:49:00 * matthew-_ is shocked
12:49:09 <Cale> matthew-_: hm?
12:49:18 <ehird> dons: I meant with ghc
12:49:19 <ehird> :-)
12:49:27 <matthew-_> for about the past month, I've been wrestling with "Infinite Type" issues
12:49:35 <matthew-_> now I just wrote an infinite loop ;)
12:49:53 <dons> ehird: oh, using ghc, check out hop and house.
12:49:59 <dons> they bootstrap the ghc runtime on bare metal
12:50:04 <Cale> matthew-_: I think the session types tutorial clearly proves that you're insane :)
12:50:13 <Cale> It's a neat idea though.
12:50:17 <ehird> dons: I also meant from scratch, for toying-around purposes :)
12:50:32 <matthew-_> Cale: so long as the latter is the case, I don't mind the former being the case either ;)
12:50:45 <Peaker> ehird, to get an Intel OS that displays "Hello world" on the screen, you need a very tiny piece of ASM writing Hello world to video memory in a boot sector :-)
12:50:58 <Peaker> ehird, I wrote a toy kernel for Intel x86-32 6-7 years ago
12:51:01 <ehird> Peaker: gosh, really
12:51:04 <ehird> Peaker: I know that of course
12:51:06 <ehird> this is #haskell
12:51:13 <ehird> in C you don't need any bootstrapping at all
12:51:22 <Peaker> ehird, Not sure what you meant by "Hello world" displaying on screen, that's all
12:51:26 <ehird> you just write a linker script, a tiny bit of asm, and a _main function
12:51:34 <ehird> then you grab the (unsigned char *) of the screen
12:51:44 <ehird> loop through "Hello, world!" and dump it there, with some flags &'d to it
12:51:49 <ehird> then you loop forever.
12:51:52 <Peaker> ehird, its (screen_char *) :-)
12:52:02 <Cale> ehird: Have you seen the work on writing operating systems in Haskell?
12:52:08 <ehird> with e.g. D you have to implement 100-200 lines of boilerplate
12:52:21 <ehird> I was asking how much that would be with Haskell, I imagine much more and much more difficult stuff
12:52:24 <ehird> Cale: nope :(
12:52:29 <Peaker> ehird, why does D require more boilerplate than plain C?
12:52:34 <Cale> http://ogi.altocumulus.org/~hallgren/ICFP2005/
12:52:36 <lambdabot> Title: A Principled Approach to Operating System Construction in Haskell
12:53:03 <cjb> I think they took down the website etc for that
12:53:03 <Cale> http://programatica.cs.pdx.edu/House/
12:53:04 <lambdabot> Title: House
12:53:22 <ehird> Peaker: D is object oriented
12:53:26 <cjb> guess not :)
12:53:32 <ehird> to get it to compile you need to write a basic skeleton of Object
12:53:39 <ehird> soon after that you'll need to impl. memory allocation & a gc
12:53:45 <allbery_b> D is the new COBOL?
12:53:50 <ehird> Cale: dons told me about hash
12:53:53 <ehird> err
12:53:53 <ehird> house
12:53:55 <ehird> heh
12:54:04 <ehird> but yeah, I meant from scratch
12:54:20 <Cale> How is this not from scratch?
12:54:43 <ehird> Cale: the house people already did the hard runtime work
12:54:49 <Cale> Oh, okay
12:55:03 <Cale> Well, I was thinking that you would follow their example :)
12:55:04 <ehird> i was specifically asking how hard it would be to write the boilerplate :)
12:55:13 <ehird> And also I was wondering if you could do it without modifying ghc
12:55:24 <ehird> maybe with -fno-implicit-prelude and a thousand other flags you could convince it
12:56:36 <Cale> convince it to do what?
12:56:57 <ehird> Cale: not use its own runtime
12:57:06 <Cale> Oh, no, that's impossible.
12:57:29 <K0MPR3SS0R> Hi cale, sorry was gone for a few mins
12:57:36 <Cale> K0MPR3SS0R: hi
12:57:49 <ehird> Cale: Darn.
12:57:56 <ehird> Cale: presumably the runtime depends on things.
12:58:04 <K0MPR3SS0R> uhmm to answer your question, the count keeps track of duplicates, so if there are two leters a , then only one node containing a will have a count of 2
12:58:17 <Cale> K0MPR3SS0R: ah, okay
12:58:34 <Cale> K0MPR3SS0R: That's a different interpretation than I was thinking of :)
12:58:36 <K0MPR3SS0R> so when I start deleting , and I delete a letter b that has a count of only 1, then the whole node should dissapear
12:58:41 <Cale> K0MPR3SS0R: right.
12:59:11 <K0MPR3SS0R> when that happens, I have a problem of rearanging the bst so that it is valid and preserves the count
12:59:24 <K0MPR3SS0R> I beleive the problem is in the join2 function
12:59:28 <Cale> K0MPR3SS0R: So your problem is in merging the trees.
12:59:32 <K0MPR3SS0R> yes
12:59:43 <K0MPR3SS0R> i dont know how to do it
13:00:01 <K0MPR3SS0R> I think its just missing a small thing
13:00:43 <Der_Paps`> hello
13:00:45 <thoughtpolice> ehird: have you seen kinetic?
13:00:47 <Cale> K0MPR3SS0R: Okay. So you have to pick a root for your new tree.
13:01:01 <Cale> K0MPR3SS0R: This might as well just be the root of the first tree.
13:01:14 <K0MPR3SS0R> right
13:01:18 <thoughtpolice> ehird: http://www.ninj4.net/kinetic/
13:01:19 <lambdabot> Title: Kinetic Operating System
13:01:27 <Cale> K0MPR3SS0R: The count on it will be the count on the root of the first tree, plus the count of that node in the second tree.
13:01:32 <thoughtpolice> there's a link in there about how to get haskell running on the bare iron
13:01:35 <Cale> (so you do a lookup)
13:02:02 <Peaker> I think if you write an OS in Haskell, you might as well drop all the kernel/user mode stuff, and just use type safety instead
13:02:07 <thoughtpolice> of course with the new concurrency primitives they're cooking up for GHC, haven't they talked about making a version of the runtime that you can link with to go on the bare metal too?
13:02:13 <Der_Paps`> Just a short question: Is there a way to execute an external command and read back in the result (what it displays on stdout, not the error code)?
13:02:17 <Peaker> and use type safety to enforce security too, instead of access control lists, etc. Simplify eeverything
13:02:20 <omg911> how can i use the strictness op on a constructor with record fields? ie such as data T = T {x::!Int, y::!Int}
13:02:31 <K0MPR3SS0R> why should the counts be added?
13:02:55 <K0MPR3SS0R> im not combining the count of two letters, the count is only there to tell how many of that type of letter there is
13:02:55 <Cale> Der_Paps`: yeah, there's stuff in System.Process for that iirc, but it might be easier to use HSH
13:03:17 <Cale> @where HSH
13:03:17 <lambdabot> http://software.complete.org/hsh
13:03:19 <Heffalump> omg911: why would you need to? The constructor is strict already.
13:03:20 <K0MPR3SS0R> lets just say that the count should be bound to each letter, and not touched, when moving a letter node you move the count with it
13:03:38 <ehird> the pointer stuff in GHC.Prim, is it usable?
13:03:50 <K0MPR3SS0R> i should have made a tupple tree instead
13:03:56 <K0MPR3SS0R> would have been easier
13:04:01 <Cale> K0MPR3SS0R: But if you're merging the two trees, taking their union, then the count of 'a' in the union had better be the count of 'a' in the first tree, plus the count of 'a' in the second, no?
13:04:06 <K0MPR3SS0R> then each node would be dealt with atomicity
13:04:11 <Der_Paps`> Cale: thanks
13:04:34 <thoughtpolice> Der_Paps`: if you want a code example
13:04:47 <omg911> Heffalump: i don't understand constructors are lazy by default no? ... stackoverflow is killing my app, i thinnk it's because of thunks building up
13:04:50 <thoughtpolice> Der_Paps`: er, well, more like a function to just do it easily
13:05:05 <thoughtpolice> here: http://github.com/thoughtpolice/infinity/tree/master/Infinity/Util.hs
13:05:07 <lambdabot> Title: Secure Git hosting and collaborative development &mdash; GitHub, http://tinyurl.com/2wtrcp
13:05:25 <Heffalump> unless I'm confused, if T x y is demanded, then x and y will be evaluated too.
13:05:31 <Cale> Der_Paps`: oh, that URL appears to suck
13:05:40 <Heffalump> Of course you might have thunks that construct T x y that haven't yet been evaluated.
13:05:54 <Cale> Der_Paps`: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HSH-1.2.5
13:05:56 <lambdabot> http://tinyurl.com/2vux4s
13:06:00 <Heffalump> omg911: you have !s in your data declaration which makes the fields strict
13:06:02 <Der_Paps`> thoughtpolice: thank you
13:06:14 <Der_Paps`> i'll investigate the two options
13:06:22 <omg911> Heffalump: my example is a syntax error in ghc
13:07:30 <ehird> @hoogle Int -> Int#
13:07:30 <lambdabot> Hoogle Error: Parse Error: Unexpected character '>'
13:07:31 <ehird> :(
13:07:34 <Heffalump> put a space between :: and !
13:07:43 <Cale> Der_Paps`: runInteractiveProcess in System.Process does what you need, but it does it in a very awkward fashion, so you'll certainly want *some* kind of wrapper. thoughtpolice's utility library there has a decent one for small uses, and HSH provides a pretty thorough way to construct shell pipelines and so on.
13:07:58 <Cale> K0MPR3SS0R: does that make sense?
13:08:30 <omg911> Heffalump: sigh you know how much time i spend on this... thx man
13:08:40 <thoughtpolice> Cale: to be quite honest I pulled that run function from lambdabot pretty much verbatim, so it might not fit his use; HSH is probably a better option
13:08:46 <Cale> K0MPR3SS0R: I would think that you'd want the law to hold that  buildn (x ++ y) == join2 (buildn x) (buildn y)
13:09:24 <Der_Paps`> Cale: since i'll just call a programm and what to read all it's output (no input after the process has started) i think the infinity wrapper will work
13:09:34 <Der_Paps`> hsh however looks very interessting
13:10:04 <ehird> how do i get an Int#?
13:10:20 <ddarius> @src Int
13:10:21 <lambdabot> data Int = I# Int#
13:10:31 <Cale> Der_Paps`: It seems that John's website got replaced with something silly, and most of the information about HSH which was there is now missing.
13:10:53 <Cale> Der_Paps`: thankfully it's preserved in the Haddock: http://hackage.haskell.org/packages/archive/HSH/1.2.5/doc/html/HSH.html
13:10:56 <lambdabot> http://tinyurl.com/37xkzf
13:11:09 <SamB> who's website?
13:11:12 <K0MPR3SS0R> thankx cale
13:11:20 <K0MPR3SS0R> ill try something,
13:11:27 <K0MPR3SS0R> ill see if it works
13:11:48 <Der_Paps`> Cale: there is the wiki @ http://software.complete.org/software/wiki/hsh
13:11:49 <lambdabot> Title: HSH - WikiStart - Software.Complete.Org
13:12:12 <Der_Paps`> Cale: not realy checked it out yet, will do after toying a bit around
13:13:59 <ehird> ddarius: hmm
13:14:00 <ehird> so
13:14:10 <ehird> unboxInt# (I# a) = a
13:15:35 <Der_Paps`> but well, another question: is there a way to nicely read ogg vorbis/ mp3 /etc tags of files in haskell, some library bindings?
13:16:37 <ehird> @hoogle I#
13:16:37 <lambdabot> Hoogle Error: Parse Error: Unexpected character '>'
13:16:39 <ehird> hmm
13:16:40 <ehird> where is I#
13:16:40 <ehird> :(
13:17:00 <shachaf> Der_Paps`: Perhaps hmp3 does it?
13:17:04 <ddarius> @index I#
13:17:04 <lambdabot> GHC.Exts
13:17:35 <ehird> aha
13:17:36 <ehird> thanks
13:17:37 <ehird> :)
13:18:01 <ehird>     Top-level bindings for unlifted types aren't allowed:
13:18:05 <ehird> :(
13:18:25 <Heffalump> they'd be strict, if they were
13:18:30 <Heffalump> which would have semantic problems
13:18:43 <shachaf> Der_Paps`: Or maybe hpodder.
13:18:45 <ehird> there's no lifted version of Addr#, though
13:18:53 <ehird> still, () -> Addr# should work
13:18:56 <Heffalump> wrap it in a datatype?
13:19:02 <ehird> Heffalump: nope, that won't work
13:19:08 <ehird> oh
13:19:12 <dons> ehird: Ptr
13:19:13 <ehird> unless I do some kind of kind = #
13:19:15 <ehird> thing
13:19:15 <dons> ?src Ptr
13:19:15 <lambdabot> data Ptr a = Ptr Addr#
13:19:16 <Heffalump> ok, I'm not familiar with unlifted types anyway
13:19:24 <ehird> dons: hmm, ok. any dependencies?
13:19:30 <dons> GHC.Ptr
13:19:39 <ehird> dons: does that depend on a lot?
13:19:54 <dons> well, you see the definition there, so no :)
13:20:03 <ehird> I mean, GHC.Ptr
13:20:14 <dons> i shouldn't imagine so
13:21:36 <Cale> Der_Paps`: actually, perhaps :)
13:21:39 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hogg-0.3.0
13:21:41 <lambdabot> http://tinyurl.com/33tjct
13:22:00 <ehird> oh no, and now I need bitwise stuff
13:22:04 <ehird> this just keeps getting funner and funner
13:22:21 <dons> i think you should familiarise yourself with the primops file :)
13:23:36 <Der_Paps`> Cale: found that to, seems to be just a ogg stream editor, no vorbis tag reader (haven't read the source yet, tried myself with binary reading ... but i kind of gave up, whan't some results now ;))
13:26:57 <matthew-_> Cale!
13:27:03 <matthew-_> if I turn on -XNoMonomorphismRestriction then it's fine
13:27:45 <shachaf> matthew-_: But you tried it with "f n =", you said, right?
13:27:45 <ehird> dons: I see nothing to do bitwise OR there
13:27:58 <dons> `xor` in Data.Bits?
13:28:08 <Der_Paps`> shachaf: hmp3 is just a mpg321 frontend, but hpodder seems (according to the cangelogs) write tags, im investigating this, thank you
13:28:19 <matthew-_> shachaf: yeah, it's something that's going on inside where there's a lambda pattern where the type is entirely existentially hidden
13:28:26 <ehird> dons: Data.Bits have any dependencies? :p
13:28:31 <ehird> besides
13:28:32 <ehird> xor is ^
13:29:22 <mauke> @let (.^.) x = xor x
13:29:23 <matthew-_> or maybe it's actually due to something that's implied by NoMono...
13:29:24 <lambdabot> Defined.
13:29:35 <mauke> :t (.^.)
13:29:36 <lambdabot> forall a. (Bits a) => a -> a -> a
13:30:03 <ehird> uhh
13:30:04 <ehird> :t xor
13:30:05 <lambdabot> forall a. (Bits a) => a -> a -> a
13:30:11 <ehird> anyway
13:30:13 <ehird> I want |
13:30:13 <ehird> not ^
13:30:23 <mauke> :t (.|.)
13:30:24 <lambdabot> forall a. (Bits a) => a -> a -> a
13:31:41 <ehird> and what does data.btis depend on? :/
13:32:29 <mauke> nothing, I think. it came with my ghc
13:33:40 <ehird> i mean, libc &co
13:34:43 * dcoutts_ announces Cabal-1.4 RC1 + cabal-install snapshot
13:37:42 <ehird> my code is peppered with #s
13:37:43 <ehird> :D
13:38:10 <ehird> aha
13:38:11 <ehird> you can't do:
13:38:12 <ehird> I# $
13:38:22 <ehird> because ($) uses kind *
13:38:23 <ehird> not #
13:39:21 <ehird>    Couldn't match expected type `IO ()'
13:39:21 <ehird>            against inferred type `State# d -> State# d'
13:39:24 <ehird> blargl ;)
13:42:43 <ehird> wonder how I could do that
13:42:44 <ehird> :/
13:42:54 <ehird> I can construct the IO easily
13:43:00 <ehird> but how do I get the initial state?
13:43:02 <forkiliens> hi everyone
13:44:08 <hpaste>  K0MPR3SS0R annotated "(no title)" with "(no title)" at http://hpaste.org/6715#a1
13:44:18 <K0MPR3SS0R> ok
13:44:32 <K0MPR3SS0R> im trying to create a BST from a string
13:44:37 <K0MPR3SS0R> and creating tupples at each node
13:44:46 <K0MPR3SS0R> whats wrong with my code?
13:45:24 <monochrom> why (a,a)?
13:45:25 <mauke> data Tree2 (a,a)? isn't that a syntax error?
13:45:46 <ehird> hmmmmmmmmm...
13:45:53 <ehird> how do I construct a (# a, b #)?
13:46:01 <monochrom> I believe you should s/(a,a)/a/ throughout.
13:46:15 <K0MPR3SS0R> (a,a) because its a tupple at each node...?
13:46:15 <matthew-_> does λb donCr stuff?
13:46:31 <K0MPR3SS0R> yeah its a syntax error mauke
13:46:45 <K0MPR3SS0R> but should I just leave it as a instead?
13:47:00 <K0MPR3SS0R> just trying to make tupples at the nodes
13:47:04 <K0MPR3SS0R> dunno how to do it
13:47:32 <mauke> ins2 looks ok; just remove the tuples from the data definition
13:47:51 <monochrom> ehird: There is no polymorphic (# a, b #).  But you can have monomorphic types inside there, e.g., (# 'a', True #) :: (# Char, Bool #).
13:47:54 <K0MPR3SS0R> and replace by a single a?
13:48:06 <mauke> yes
13:48:11 <ehird> monochrom: Well, yes, of course.
13:48:16 <ehird> monochrom: But that's a syntax error
13:48:27 <monochrom> need -fglasgow-exts or something.
13:48:36 <K0MPR3SS0R> then I get an error at my ins2 function
13:48:48 <mauke> what's the error?
13:48:50 <K0MPR3SS0R> Inferred type is not general enough
13:48:54 <mauke> right
13:49:02 <monochrom> You can haz (a,a) for ins2.
13:49:03 <K0MPR3SS0R> *** Expected type : Char -> Tree2 (a,a) -> Tree2 (a,a)
13:49:03 <K0MPR3SS0R> *** Inferred type : Char -> Tree2 (Char,Char) -> Tree2 (Char,Char)
13:49:17 <mauke> your type signature promises things the code can't keep
13:49:27 <monochrom> Ah, you also put Char there.
13:49:52 <K0MPR3SS0R> ahh yes
13:49:55 <monochrom> ch is Char. Then you see to it that ch gets into a tuple.
13:49:55 <ehird> Prelude Main> main
13:49:55 <ehird> Segmentation fault (core dumped)
13:49:59 <ehird> well, that's a good sign
13:50:04 <ehird> it DOES try to modify arbitary memory.
13:50:40 <monochrom> Then you also see to it that the number 1 gets into another component of the tuple too.
13:50:53 <monochrom> This function is hardly polymorphic.
13:51:11 <K0MPR3SS0R> well basically each tupple is supposed to be a letter and a number (c, 2)
13:51:21 <K0MPR3SS0R> so (Char, Integer)
13:51:23 <mauke> then why did you write (a,a) in the type signature?
13:51:33 <K0MPR3SS0R> I tried Char Integer and I got errors
13:51:36 <monochrom> because new to haskell.
13:51:50 <mauke> what errors?
13:52:03 <K0MPR3SS0R> ok well leme rebuild it and ill tell you what errors
13:52:20 <monochrom> I think he means he tried ins2 :: Char -> Tree2 Char Integer -> Tree2 Char Integer.
13:52:26 <ehird> ok, now to see how many million dependencies i have
13:52:47 <monochrom> ehird: sorry, I can't help with segfaults :)
13:53:12 <ehird> @hpaste
13:53:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:53:24 <ehird> monochrom: of course it segfaults, its meant to be os-level ;)
13:53:25 <K0MPR3SS0R> ok if I change my type signature to : ins2 :: Char -> Tree2 (Char, Integer) -> Tree2 (Char, Integer)
13:53:32 <K0MPR3SS0R> it gives same error as before
13:53:40 <K0MPR3SS0R> *** Expected type : a -> Tree2 (Char,Integer) -> Tree2 (Char,Integer)
13:53:40 <K0MPR3SS0R> *** Inferred type : Char -> Tree2 (Char,Integer) -> Tree2 (Char,Integer)
13:53:46 <hpaste>  ehird pasted "Just a *few* dependencies!... time()? wtf." at http://hpaste.org/6716
13:53:52 <monochrom> Use the inferred type.
13:53:53 <mauke> K0MPR3SS0R: that's not the same message
13:53:58 <K0MPR3SS0R> well similar
13:55:05 <ehird> Heh. With -fno-implicit-prelude, how do you do integer literals?
13:55:08 <ehird> I'm fine with them being Int#.
13:55:11 <monochrom> ghc error messages are so good, they're even trying to tell you how to rewrite your programs! :)
13:55:26 <K0MPR3SS0R> maybe I should use ghc instead
13:55:35 <K0MPR3SS0R> stupid hugs pissing me off
13:55:36 <monochrom> Oh, that was not from ghc?
13:55:44 <SamB> ehird: well, I expect they call whatever fromInteger is in scope
13:55:48 <SamB> with a Prelude.Integer
13:55:50 <monochrom> then I have to correct myself.
13:55:55 <monochrom> hugs error messages are so good, they're even trying to tell you how to rewrite your programs! :)
13:55:59 <K0MPR3SS0R> lol
13:56:05 <olsner> K0MPR3SS0R: since your type is written data Tree2 (a,a), you're saying that both elements have to be of the same type
13:56:07 <ehird> SamB: They do. So what do I do? :P
13:56:11 <mauke> fromInteger = id
13:56:16 <dons> dcoutts_: i feel this shouldn't be fatal.
13:56:17 <dons> 13:55  sjanssen> 400 Error in upload
13:56:17 <dons> 13:55  sjanssen> 'ghc-options: -fhpc' is not appropriate for a distributed package.
13:56:20 <Heffalump> ehird: import the Prelude?
13:56:27 <Heffalump> hiding whatever you don't actually want?
13:56:29 <dons> dcoutts_: since its used if you enable -f testing
13:56:37 <K0MPR3SS0R> well I changed it to  data Tree a
13:56:40 <SamB> ehird: you make sure there is one that accepts Prelude.Integer in scope?
13:56:43 <ehird> Heffalump: but the Prelude has quite a few dependencies it seems :)
13:56:50 <K0MPR3SS0R> since its a syntax error
13:56:52 <ehird> SamB: that's hardly the point
13:56:56 <Heffalump> import the relevant bits of GHC directly?
13:57:05 <ehird> heh
13:57:10 * ehird goes a-searchin'
13:57:36 * Heffalump is guessing
13:57:41 <SamB> you would "import qualified" some module that exports the things you want to use from the normal libraries
13:57:42 <dcoutts_> dons: hmm
13:57:51 <dons> dcoutts_: perhaps -fhpc should be something cabal knows about
13:57:53 <SamB> Prelude, for instance
13:58:00 <dons> configure -f testing -hpc
13:58:04 <dcoutts_> dons: it is, it specifically rejects it :-)
13:58:07 <olsner> K0MPR3SS0R: did you replace (a,a) in this part too? "... | Root (a,a) (Tree2 (a,a)) (Tree2 (a,a))"
13:58:21 <dons> well, that'll discourage use, won't it ? :)
13:58:43 <dcoutts_> dons: we want to build hpc coverage into cabal anyway, not ad-hoc per package
13:58:44 <ehird> SamB: no prelude
13:58:51 <SamB> ehird: eh?
13:58:53 <dons> dcoutts_: so -Werror is a warning?
13:58:57 <dons> but -fhpc is fatal?
13:58:57 <SamB> ehird: what do you mean?
13:59:03 <SamB> what are you trying to do?
13:59:10 <dcoutts_> dons: I thought -Werror was fatal too
13:59:16 <dons> hmm, maybe you're right
13:59:38 <dcoutts_> yes, it's fatal
13:59:40 <hpaste>  monochrom annotated "(no title)" with "happy now?" at http://hpaste.org/6715#a2
13:59:41 <EvilTerran> are we talking about {-# LANGUAGE NoImplicitPrelude #-}; import qualified Prelude as P --?
13:59:41 <dcoutts_> as it should be
14:00:17 <K0MPR3SS0R> yes olsner
14:00:25 <K0MPR3SS0R> I replaced all of them
14:00:34 <dcoutts_> dons: if we can work out some code to detect if a ghc option is being used, guarded by a flag that will never automatically default to true and allow some flags in that case, then it'd be fine
14:00:34 <olsner> and the error you get now is?
14:01:05 <K0MPR3SS0R> its a syntax error at the data Tree2 declaration
14:01:15 <K0MPR3SS0R> for some reason I cant use (a,a) as a type
14:01:47 <dcoutts_> dons: basically we havn't worked out yet how to deal with options that you'd only want to use in a development build
14:02:14 <dcoutts_> dons: but allowing things later is better imho than letting hackage fill with packages with terrible QA
14:02:31 <dcoutts_> people put some pretty silly things in their .cabal files
14:02:33 <ehird> EvilTerran: no
14:02:41 <ehird> we're talking about noimplicitprelude.
14:03:05 <dons> dcoutts_: yeah, agreed
14:03:26 <dcoutts_> dons: in the worst case you just have to make some edits to the .cabal file before you release, compared to what's in your ordinary darcs development version
14:04:34 <K0MPR3SS0R> geez olsner, I fixed it by completely removing the types: data Tree2 = Empty | Root (Char, Integer) Tree2 Tree2
14:04:38 <dcoutts_> dons: of course, if they're useful to every package then we should add it as a feature that can be used uniformly for all packages. I think hpc and other profiling things fall into that category.
14:04:39 <K0MPR3SS0R> and it works...
14:04:46 <EvilTerran> ehird, well, i got the first half right...
14:05:09 <ehird> EvilTerran: :D
14:05:17 <ehird> I just need a way to get meself an Int# out of thin air
14:05:25 <ahunter> @type guard
14:05:26 <Heffalump> ehird: 5# ?
14:05:26 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
14:05:29 * Heffalump is guessing
14:06:26 <ehird> Heffalump: doubt it
14:06:35 <allbery_b> actually I think that's right
14:06:35 <EvilTerran> ehird, ... any particular reason?
14:06:55 <monochrom> Int# is a name provided by one of the GHC.* modules.
14:07:03 <allbery_b> it may need to be typed (e.g. (5# :: Int#))
14:07:04 <ehird> EvilTerran: trying to get the dependency list to a one I can implement in C to try and munge a single haskell program to work on the bare metal :p
14:07:07 <EvilTerran> and doesn't (\(I# x) -> ...) work?
14:07:10 <ehird> monochrom: that doesn't help me if '5' doesn't work
14:07:26 <ehird> '5' doesn't work because there's no fromInteger, which is in Prelude
14:07:30 <EvilTerran> (with {-
14:07:33 <EvilTerran> er
14:07:41 <EvilTerran> # HashPatterns #-}
14:07:44 <monochrom> OK, just making sure you aren't getting bitten by "Int# not found"
14:07:47 <EvilTerran> er, no, MagicHash
14:07:52 <monochrom> s/bitten/bit/  # damn english
14:08:07 * EvilTerran likes that extension name
14:08:10 <allbery_b> hm?   bitten is fine there
14:08:22 <mauke> bite, bit, bitten
14:08:48 <monochrom> well, damn english anyway :)
14:08:49 <ehird> 5# works
14:08:57 <ehird> so I can't use Data.Bits any more
14:09:05 <ehird> .|. and .&. need Int# versions. what fun
14:10:19 <monochrom> .|. presumes type class.  type class presumes boxed types IIUC.  5# is not of a boxed type (the whole point of #).
14:11:22 <EvilTerran> can you do those with the FFI and some C wrapper functions?
14:11:24 <monochrom> Somewhere in GHC.* there are bitwise operators for 5#.
14:11:41 * EvilTerran can't remember if parameters to FFI imports have to be boxed
14:11:58 <monochrom> @src (.|.) Int
14:11:58 <lambdabot> Source not found. :(
14:11:59 <allbery_b> see souce code link for Data.Bits
14:12:11 <allbery_b> @source Data.Bits
14:12:11 <lambdabot> http://darcs.haskell.org/packages/4/Data/Bits.hs
14:12:21 <allbery_b> hm, is that right?
14:12:22 <ehird> yeah can't find it in GHC.*
14:12:40 <allbery_b> Data/Bits.hs shows primitives and#, or#, etc.
14:12:40 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Bits.html
14:12:42 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/3yyvyq
14:13:21 <mauke> whoa, (I# x#) .&.   (I# y#)  = I# (word2Int# (int2Word# x# `and#` int2Word# y#))
14:13:43 <ehird> and#
14:13:45 <ehird> thanks.
14:14:05 <idnar> what is I#?
14:14:10 <ehird> this stuff is deliciously evil
14:14:13 <ehird> idnar: Int's type constructor
14:14:15 <allbery_b> Int constructor
14:14:17 <ehird> data Int = I# Int#
14:14:26 <idnar> ah
14:14:43 <ehird> my program seems to be written in Hashkell
14:14:44 <ehird> :-D
14:14:45 <monochrom> So I made a typo when I said Int# is about boxing.  I meant I#.
14:14:49 <idnar> ehird: hahaha
14:15:25 <ehird> and# is for words
14:15:26 <ehird> :(
14:15:36 <idnar> I guess that's what all the int2Word is about
14:15:40 <allbery_b> note the coercions
14:15:41 <ehird> yeah
14:16:09 <idnar> is there a C# type constructor somewhere?
14:16:15 <idnar> er
14:16:17 <ddarius> @src Char
14:16:17 <lambdabot> data Char = C# Char#
14:16:26 * Twey thought this was the wrong channel for a moment.
14:16:27 <idnar> aha, of course
14:16:28 <mauke> :t C#
14:16:29 <lambdabot> Not in scope: data constructor `C#'
14:16:30 <ehird> construct C#
14:16:31 <ehird> :D
14:16:37 <idnar> also I guess I meant data constructor
14:16:40 <ehird> Hmm
14:16:45 <allbery_b> :t GHC.Prim.C#
14:16:45 <lambdabot> Not in scope: data constructor `GHC.Prim.C#'
14:16:46 <ehird> I should pepper this with strictness annotations
14:16:56 <ehird> Maybe if everythign is strict it'll drop the thunk dependencies. /wishful
14:17:22 <ehird> I find the fact that you can't use ($) with unboxed stuff amusing though.
14:17:33 <mauke> kind error, no?
14:17:38 <ehird> magic hashed things having a different kind is logically sound but weird in practice
14:17:40 <EvilTerran> make a ($#) :S
14:18:02 <ehird> heh
14:18:03 <ehird> maybe
14:18:08 <ehird> woot
14:18:09 <ehird> it compiles
14:18:11 <ehird> no prelude!
14:18:23 <ehird> WTF NO LESS DEPENDENCIES.
14:18:35 <ehird> I guess I could start with disabling bignums, and thus no gmp. Can you do that?
14:19:03 <EvilTerran> which dependency were you expecting to get rid of by divorcing the prelude?
14:19:15 <allbery_b> some of that is going to be the rts machiney
14:19:19 <allbery_b> machinery
14:19:53 <ehird> EvilTerran: dunno. :-)
14:20:03 <ehird> allbery_b: I doubt the timer stuff is required
14:20:09 <ehird> And I don't think gmp would be required if I didn't use bignums
14:20:14 <ehird> There will obviously be dependencies, though
14:22:47 <ehird> So hm.
14:23:24 <ddarius> The Berkeley Computer Animation and Modeling section is awesome.
14:23:36 <wli> Who calls them bignums anyway?
14:24:02 <wli> I've figured out people mean arbitrary-precision arithmetic by it.
14:24:09 <mauke> lisp, perl
14:24:52 <ehird> they've always been called bignums
14:25:35 <arussel> hi, is there a imap mail client or library  in haskell ?
14:27:54 <EvilTerran> ISTR whoever thought them up made a library called "bignum"
14:28:08 <allbery_b> doesn't look like it
14:29:19 <forkiliens> how do i import  two modules in ghci such that i can use both?
14:29:20 <Peaker> @hoogle (a->Bool) -> [a] -> [a] -> [a]
14:29:21 <lambdabot> No matches, try a more general search
14:29:33 <Peaker> Hmm, I need a split (like filter, but returns two lists)
14:29:56 <allbery_b> partition?
14:29:58 <forkiliens> i tried :     :m System
14:30:06 <forkiliens> and then:    :l MyModule
14:30:16 <allbery_b> forkiliens: :m +modukle
14:30:28 <allbery_b> :t partition
14:30:29 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
14:30:33 <forkiliens> thanks allbery_b
14:30:46 <brianski> howdy... is there a bot here that lets you search for patterns, ie 1,1,2,3,5,8 will tell you fibonacci and give you some more info, etc.
14:30:55 <mauke> @oeis 1,1,2,3,5,8
14:30:55 <lambdabot> Fibonacci numbers: F(n) = F(n-1) + F(n-2), F(0) = 0, F(1) = 1, F(2) = 1, ...
14:30:55 <lambdabot> [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
14:31:00 <forkiliens> cool
14:31:12 <forkiliens> @oeis 1 4 9 16
14:31:12 <lambdabot> The squares: a(n) = n^2.
14:31:12 <lambdabot> [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,48...
14:31:16 <forkiliens> wow
14:31:19 <ehird> @oeis 0 -1 -2 -3
14:31:20 <lambdabot> Mertens's function: Sum_{1<=k<=n} mu(k), where mu = Moebius function (A008683).
14:31:20 <lambdabot> [1,0,1,1,2,1,2,2,2,1,2,2,3,2,1,1,2,2,3,3,2,1,2,2,2,1,1,1,2,3,4,4,3,2,1,1,2,1,...
14:31:20 <brianski> oeis, that's it
14:31:22 <brianski> thanks
14:31:24 <ehird> heh
14:31:26 <ehird> oeis failed :D
14:31:34 <ehird> @oeis 10 9 8 7 6 5
14:31:35 <lambdabot> Triangle T(n,k) = n-k, n >= 0, 0<=k<=k. Integers m to 0 followed by integers ...
14:31:35 <lambdabot> [0,1,0,2,1,0,3,2,1,0,4,3,2,1,0,5,4,3,2,1,0,6,5,4,3,2,1,0,7,6,5,4,3,2,1,0,8,7,...
14:31:41 <ehird> cute
14:31:59 <Peaker> allbery_b, thanks
14:31:59 <forkiliens> very cool
14:32:09 <Peaker> Can @hoogle be made to look for isomorphic types as well?
14:32:51 <Spieleguru> http://sexy-lena.com/?uid=22035
14:32:54 <lambdabot> Title: Meine Ex Nackt!!!
14:33:08 <ehird> data Value = ... | forall a. Foreign a
14:33:11 <ehird> I didn't know you could do that
14:33:13 <ehird> that's nice
14:34:06 <ehird> kinda hard to write a deForeign though
14:34:08 <ehird> :-P
14:34:56 <ehird> in fact, impossible
14:35:48 <ehird> yep
14:35:50 <ehird> definately impossible
14:35:54 <mauke> deForeign :: Value -> (forall a. a -> b) -> b
14:36:02 <mauke> deForeign (Foreign x) f = f x
14:38:14 <ehird> oh clever
14:38:39 <ehird> but normally when you stuff something into foreign storage you have a specific type in mind :)
14:38:42 <ehird> so Data.Dynamic will help
14:40:24 <ehird> hmm
14:40:30 <ehird> maybe using that isn't such a great ide
14:40:30 <ehird> a:)
14:40:53 <ddarius> ehird: Foreign :: (exists a. a) -> Value.  exists a. a is isomorphic to ()
14:41:26 <ehird> ddarius: Yep.
14:41:30 <ehird> data Value = Foreign Dynamic
14:41:34 <ehird> toForeign a = Foreign (toDyn a)
14:41:36 <ehird> fromForeign (Foreign d) = fromJust (fromDynamic d)
14:41:50 <ehird> Maybe less 'cool factor', and certainly a bit weird, but it works
14:41:58 <SamB> hmm. apparantly if I start screen over ssh initially, it doesn't get reniced...
14:42:47 <ehird> Damnit.
14:42:49 <ehird> I can't derive Read
14:42:53 <ehird> Because you can't Read dynamics.
14:43:52 <SamB> can you show them?
14:43:59 <ehird> ?
14:44:31 <ehird> actually, to hell with Dynamic
14:44:42 <ehird> my requirements are too specific
14:44:44 <SamB> or, oh, Python or something like that
14:44:49 <ehird> (the object must be serializable)
14:45:11 <SamB> you can still use Typeable
14:46:36 <hpaste>  (anonymous) annotated "exception in ctor" with "(no title)" at http://hpaste.org/6707#a1
14:47:52 <ehird> @index ap
14:47:52 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
14:47:52 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
14:48:04 <ehird> @hoogle ap
14:48:04 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
14:48:04 <lambdabot> Prelude.appendFile :: FilePath -> String -> IO ()
14:48:04 <lambdabot> System.IO.appendFile :: FilePath -> String -> IO ()
14:50:05 <ehird> Oooh, damn, this is bad..
14:50:10 <ehird> I need to be able to serialize circular lists.
14:50:26 <ddarius> Just preserve sharing.
14:50:38 <luqui> j #mozilla
14:52:14 <Saizan> ddarius: there's no way to do that for plain lists, right? you need the sharing to be explicit
14:52:24 * SamB wonders how hard it would be to convince a pretty-printer that line breaks were more desirable at higher levels of the syntax tree...
14:52:37 <ehird> jeez why isn't fix/ap in Prelude
14:52:59 <ehird> @hoogle (a->a)-.a
14:52:59 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-.a'
14:53:01 <ehird> @hoogle (a->a)->a
14:53:01 <lambdabot> Data.Function.fix :: (a -> a) -> a
14:53:01 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
14:53:01 <lambdabot> Control.Monad.State.Class.modify :: MonadState s m => (s -> s) -> m ()
14:53:12 <ehird> @type ap
14:53:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:53:20 <Saizan> @type app
14:53:21 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
14:53:22 <ehird> @hoogle (Monad m) => m (a -> b) ->m a-> m b
14:53:22 <lambdabot> Prelude.asTypeOf :: a -> a -> a
14:53:22 <lambdabot> Prelude.const :: a -> b -> a
14:53:22 <lambdabot> Prelude.seq :: a -> b -> b
14:53:32 <Saizan> ehird: that's mfix
14:53:39 <ehird> no, that's ap
14:53:40 <ehird> :|
14:53:45 <ehird> withou the foralls
14:54:10 <ehird> ddarius: that doesn't help.
14:54:10 <Peaker> Looking at Control.Monad.ap, what would be a typical case where you have an m (a -> b) ?
14:54:11 <ehird> :)
14:54:17 <Saizan> ah ok, i thought you meant them to be connected
14:54:19 <ehird> Peaker: lists
14:54:43 <ehird> > ap [(4*),(2*)] [1,2,3]
14:54:44 <lambdabot>  [4,8,12,2,4,6]
14:54:45 <mauke> > ap [succ,(*2),(^2)] [2,3,4]
14:54:46 <lambdabot>  [3,4,5,4,6,8,4,9,16]
14:54:53 <Peaker> ehird, ah, I see, thanks
14:54:57 <ehird> never seen an ap without a list
14:55:15 <Peaker> I can't think of an IO (a->b)
14:55:21 <Saizan> Peaker: it's useful to generalize liftM2
14:55:27 <ehird> Peaker: return (const 2)
14:55:28 <mauke> also, liftM4 f w x y z == return f `ap` w `ap` x `ap` y `ap` z
14:55:28 <ehird> heh
14:55:37 <shachaf> ehird: ap is sometimes called (<*>), in Applicative.
14:55:37 <ehird> > ap (return (const 2)) getLine
14:55:38 <lambdabot>  <IO Integer>
14:55:38 <Peaker> ehird, as in, a useful one :-)
14:55:42 <ehird> > ap (return (++)) getLine
14:55:42 <lambdabot>  <IO ([Char] -> [Char])>
14:55:46 <ehird> hmm
14:55:52 <ehird> oh
14:55:56 <ehird> > ap (return ("prefix" ++)) getLine
14:55:56 <lambdabot>  <IO [Char]>
14:55:58 <ehird> hehe
14:56:00 <ehird> @pl ap (return ("prefix" ++)) getLine
14:56:00 <lambdabot> ("prefix" ++) `fmap` getLine
14:56:04 <ehird> @. unpl pl ap (return ("prefix" ++)) getLine
14:56:04 <lambdabot> (fmap (\ a -> "prefix" ++ a) getLine)
14:56:12 <ehird> so yeah.
14:56:29 <ehird> fmap f x = ap (return f) x
14:56:35 <ehird> @type \f x -> ap (return f) x
14:56:36 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b) -> m a -> m b
14:56:37 <shachaf> > getZipList $ ZipList [succ,(*2),(^2)] <*> ZipList [2,3,4]
14:56:38 <ehird> @type fmap
14:56:38 <lambdabot>  [3,6,16]
14:56:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:56:45 <ehird> ah
14:56:49 <ehird> fmap works on functors too
14:56:49 <ehird> but eh
14:56:55 <ehird> does ap work on functors?
14:57:04 <mauke> no
14:57:07 <shachaf> ehird: No, but (<*>) works on Applicatives.
14:57:15 <ehird> @src fmap
14:57:15 <lambdabot> Source not found. You type like i drive.
14:57:16 <shachaf> ehird: Functors only have fmap.
14:57:20 <shachaf> @src Maybe fmap
14:57:20 <lambdabot> fmap _ Nothing       = Nothing
14:57:20 <lambdabot> fmap f (Just a)      = Just (f a)
14:57:23 <shachaf> @src [] fmap
14:57:23 <lambdabot> fmap = map
14:57:48 <ehird> Hmm
14:57:55 <ehird> I think I have to make my own serialization format
14:58:02 <ehird> Or at least my own Binary instance, which would be painful
14:58:02 <ehird> Joy!
14:58:12 <ddarius> You'll have to get at some of the underlying details to be able to support it for arbitrary values.
14:58:40 <ehird> i need to come up with a good function to identify circular structures
14:58:44 <ehird> that will return useful information for it
14:58:51 <ehird> but since you can have nested circular structures it ain't that easy
14:59:13 <ehird> indeed, just writing a lisp printer that can do #n=(...#n#...) syntax isn't a walk in the park
14:59:16 <ehird> arbitary serialization? Ow.
15:00:10 <SamB> hmm, does anyone know how to configure urxvt to display these properly:
15:00:21 <SamB> →
15:00:45 <mauke> what do you see instead?
15:00:52 <SamB> ∀
15:01:01 * shachaf isn't seeing that properly. :-)
15:01:04 <SamB> I see a really pathetic thing that looks like an underscore
15:01:05 <shachaf> What is it supposed to be?
15:01:14 <mauke> U+2192 (e2 86 92): RIGHTWARDS ARROW [→]; U+2200 (e2 88 80): FOR ALL [∀]
15:01:20 <SamB> and in the case of the forall, I see a little over half of a forall
15:01:26 <shachaf> Hmm, odd.
15:01:28 <shachaf> This? →
15:01:51 <SamB> (that is, the right leg is missing...)
15:01:57 <SamB> shachaf: yes, that
15:01:58 <shachaf> I can see it when I type it into irssi, but not in the display area.
15:01:59 <mauke> might be a font issue
15:02:08 <SamB> it most certainly is!
15:02:28 <mauke> the first entry in my font list is xft:fixed:size=13
15:02:48 <SamB> because I'm sure those glyphs are representations of the correct character, but they sure don't look like they fit in with the others...
15:03:12 <mauke> ctrl+shift+mouse over should tell you which font it uses
15:03:19 <mauke> er, button1
15:03:46 <shachaf> This is odd.
15:03:59 <SamB> no wonder, it used courier new for the function arrow...
15:04:12 <shachaf> It's not using the same font in the bottom part (where I enter my messages) and in the top part (where messages are displayed).
15:04:18 * SamB is glad he installed the all-bells-and-whistles version of urxvt
15:04:33 * shachaf thinks this might be irssi's fault -- this particular server has had a lot of Unicode trouble.
15:04:40 <shachaf> (Perhaps this should be in #-blah?)
15:05:32 <SamB> um, but need these for working on JHC!
15:06:04 <mauke> so fix your font list
15:07:33 <SamB> mauke: what exactly does your urxvt report for those two glyphs?
15:07:52 <SamB> I want to make sure I even have that font
15:08:23 <Peaker> The State monad has just one big value, I am toying with a "widget set" where each widget wants to have its own mutable "data" - should I use IORefs, a composite value with State or is there a nicer way?
15:09:25 <SamB> some sort of IO-based thing, probably newtyped somehow?
15:09:36 <allbery_b> State with a record
15:09:40 <allbery_b> :t gets
15:09:41 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
15:09:47 <Peaker> maybe I need to have a big composite model that I am viewing anyhow, so I can just have a (State Model) where Model holds the stuff the gui edits, including gui information
15:09:56 <allbery_b> (used as (gets recordselector))
15:10:13 <Peaker> allbery_b, where Map.lookUp would typically be used?
15:10:23 <allbery_b> record, not Map
15:10:34 <Peaker> allbery_b, where can I read about records?
15:11:02 <allbery_b> data MyState = MyState (a :: Int, b :: String, ...); ... do x <- gets a; ...
15:11:30 <allbery_b> hm, I did that wrong as usual
15:11:38 <allbery_b> MyState { a :: Int, ... }
15:12:05 <Peaker> oh
15:12:14 <Peaker> allbery_b, but it seems to be general enough to be given any function..
15:12:23 <Peaker> allbery_b, including a map lookup, if the state happens to be a map
15:13:03 <mauke> SamB: it says "fixed-13:minspace=True"
15:13:50 <allbery_b> sure
15:32:09 <hpaste>  matthew-_ pasted "parallel 8 queens checker" at http://hpaste.org/6717
15:33:32 <cjb> huh.  is it necessary to be so explicit about the distribution?
15:34:54 <matthew-_> cjb: sorry, was that to me?
15:34:59 <cjb> yeah.  :)
15:35:10 <matthew-_> you mean you read and understood that?
15:35:16 <cjb> I'm not experienced with Haskell; I was just hoping there might be ..
15:35:17 <cjb> .. no.
15:35:33 <matthew-_> ok, sorry, continue
15:35:42 <solrize_> what's with all the consing instead of using haskell lists?
15:36:08 <matthew-_> I need heterogenous lists that reflect in their type their values
15:36:27 <cjb> I guess I can just be quiet.  :)  I was wondering if any of your coordinating results was encapsulated in anything like Data.Parallel.Strategies or such.
15:36:45 <solrize_> i don't understand it at all but it looks pretty cool :)
15:36:52 <matthew-_> cjb: ahh I see. the ordering on the result is a pain
15:37:19 <matthew-_> cjb: I have a multireceive construct, but I'd have to write a type class to actually use it
15:37:30 <matthew-_> the problem is that effectively, I need a full dependent type system
15:37:42 <matthew-_> as the type is dependent on the input from the user
15:38:05 <matthew-_> and so the recursion to build the multireceive construct is bounded dynamcially, not statically
15:38:22 <matthew-_> I could get round it with a type class but it would look fuglier
15:39:33 <hpaste>  greendemon pasted "monad trouble" at http://hpaste.org/6718
15:39:46 <greendemon> Can someone help with my monad trouble?
15:39:56 <greendemon> I'm trying to create a monad for practice
15:40:38 <greendemon> quiz.hs:13:15:
15:40:39 <greendemon>     Kind mis-match
15:40:39 <greendemon>     Expected kind `* -> *', but `Debuggable' has kind `*'
15:40:39 <greendemon>     In the instance declaration for `Monad Debuggable'
15:40:48 <greendemon> What is a kind mismatch?
15:41:01 <Peaker> greendemon, the type of your type
15:41:14 <matthew-_> @kind Maybe
15:41:15 <lambdabot> * -> *
15:41:22 <matthew-_> @kind Maybe Int
15:41:23 <lambdabot> *
15:41:27 <matthew-_> @kind []
15:41:28 <lambdabot> * -> *
15:41:31 <matthew-_> @kind [] Int
15:41:32 <lambdabot> *
15:41:33 <Peaker> greendemon, Your Debuggable has to be parameterized for any type to be a Monad
15:41:35 <matthew-_> @kind [Int]
15:41:35 <lambdabot> *
15:41:46 <SamB> mauke: this "xft:fixed:size=13" looks distinctly odd here...
15:42:17 <SamB> the characters look to be square -- or wider
15:42:25 <kbateman> It needs to be like "type Debuggable a = Writer Int a"
15:42:55 <kbateman> wait, I'm wrong....
15:43:32 <greendemon> Ok, but then I get a different error:
15:43:41 <greendemon> `Debuggable' is not applied to enough type arguments
15:43:41 <greendemon>     Expected kind `*', but `Debuggable' has kind `* -> *'
15:43:56 <dons> xmonad 0.7 is out! http://reddit.com/info/6dvnx/comments/
15:44:03 <mauke> SamB: http://img207.imageshack.us/img207/1333/screenshotiq7.png
15:45:15 <SamB> mauke: and you didn't specify cell size somehow?
15:45:31 <mauke> that's what the size=13 is for
15:45:39 <mauke> no, I didn't do anything
15:46:09 <SamB> and that size refers to vertical or horizontal size?
15:46:38 <SamB> in what units?
15:46:39 <mauke> no idea; it's the "font size"
15:46:41 <monochrom> @pasta
15:46:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:46:55 <SamB> as if there was only one!
15:47:15 <SamB> X has 2 dimensions of font size in, what, two different units of measurement?
15:47:54 <solrize_>     On the fly updating to xmonad 0.7 is supported. You should be able
15:47:54 <solrize_>     to upgrade to xmonad 0.7 from 0.6 and earlier, transparently,
15:47:54 <solrize_>     without losing your session. Load the new code with mod-q and enjoy.
15:48:09 <solrize_> wow, erlang watch out :)
15:48:17 <SamB> solrize_: hah, not yet
15:48:19 <monochrom> 13 mm x 0.000001 AU ? :)
15:48:33 <SamB> monochrom: wrong two
15:48:33 <ddarius> xmonad doesn't do anything like what Erlang does unless something has changed dramatically.
15:48:39 <Peaker> Hmm, to stack up a bunch of monads, only the outer-most is a transformer, and the inner ones are just normal monads, right?  I currently have a: "type Action = Reader.ReaderT Environment", to add a State monad too, I would use Reader instead of ReaderT?
15:48:41 <SamB> I think it's pixels and points or something like that
15:48:50 <ddarius> solrize_: hsplugins though...
15:48:51 <solrize_> ddarius it was a reference to erlang's hot patching
15:49:00 <SamB> solrize_: xmonad is more like irssi
15:49:01 <ddarius> solrize_: I know what you were referring to
15:49:24 <monochrom> Peaker: no, all but one are transformers.
15:49:41 <ddarius> All "on the fly" upgrading to xmonad 0.7 means is that they didn't change the serialized state format
15:49:45 <dons> ddarius: since all the state is serialisable, you can transparently upgrade from version to version
15:49:52 <Peaker> monochrom, Ah, that makes more sense, I guess, especially as the one inside is IO..
15:49:53 <hpaste>  greendemon annotated "monad trouble" with "monad trouble" at http://hpaste.org/6718#a1
15:49:55 <dons> well, it does change, but can be merged
15:50:40 <greendemon> Ok, now my monad type can be parameterized,
15:50:41 <greendemon> quiz.hs:3:14:
15:50:41 <greendemon>     `Debuggable' is not applied to enough type arguments
15:50:41 <greendemon>     Expected kind `*', but `Debuggable' has kind `* -> *'
15:50:41 <greendemon>     In the instance declaration for `Show Debuggable'
15:50:49 <greendemon> Almost the exact opposite error
15:50:59 <mauke> yes, because Debuggable is not a type
15:51:07 <mauke> it's a type constructor
15:51:11 <monochrom> "instance Monad Debuggable" is right.  "instance Show Debuggable" is wrong.
15:51:29 <Peaker> greendemon, what are you working on?
15:51:42 <greendemon> I'm just trying to create a monad to see if I can
15:51:58 <greendemon> Sort of a cheap Writer Monad
15:52:02 <mauke> why don't you let the compiler derive Show for you?
15:52:16 <SamB> mauke: it can't can it?
15:52:17 <monochrom> I wonder why you need Show.
15:52:24 <SamB> oh, wait, yes it can ...
15:52:26 * SamB silly
15:52:38 <SamB> it just won't work unless the value also has Show, duh...
15:52:44 <greendemon> I don't, need Show, but that's not where the error points I don't think
15:53:00 <hpaste>  glen_quagmire annotated "monad trouble" with "do it this way" at http://hpaste.org/6718#a2
15:53:18 <glen_quagmire> that's for you greendemon
15:53:18 <monochrom> "instance Show a => Show (Debuggable a) where ..."  do this.
15:53:34 <monochrom> Yeah.
15:54:11 <glen_quagmire> => this means something that i don't know
15:54:31 <glen_quagmire> A => B  probably means for all A, B
15:54:46 <glen_quagmire> or, given A, B
15:54:47 <EvilTerran> except in class declerations, then it means the opposite
15:54:52 <thoughtpolice> greendemon: you have 'data Debuggable a' but you do instance Show Debuggable; Debuggable as a type is parametrized (hence it has kind * -> *), so instead you need an 'instance Show a => Show (Debuggable a)'
15:55:20 <greendemon> Ok, that worked
15:55:26 <greendemon> Thanks
15:55:43 <Cale> It's a way to apply class constraints to the type variables in scope, so they only range over the types which satisfy the conditions before the =>
15:55:47 <Cale> (basically)
15:55:52 <thoughtpolice> the reason you need the Show constraint on a is because you use show on that particular type in your declaration of 'show', so it gives an implication that 'a' must be an instance of Show as well
15:55:57 <monochrom> Just treat => as punctuation.  The whole point of programming languages not being English is that you can't explain in English, a messed up language.
15:56:29 * EvilTerran likes Cale's explanation. that works in class decls, too.
15:56:32 <greendemon> That makes sense
15:56:37 <glen_quagmire> class constraints, word of the day
15:57:02 <monochrom> GHC 9.99 will have class actions.
15:57:20 <greendemon> So why must a monad be paramaterized for all types?
15:57:31 <greendemon> just out of curiousity
15:57:49 <glen_quagmire> probably because  it's class Monad m where ..
15:58:02 <monochrom> Because of >>=
15:58:03 <glen_quagmire> no i take it back
15:58:10 <thoughtpolice> greendemon: because monads are 'unrestricted,' meaning you can't imply constraints on their values, although there are olegian solutions out there. at least that's as far as I understand it
15:58:16 <glen_quagmire> Monad typeclass' functions are polymorphic
15:59:00 <glen_quagmire> for example, return :: a -> m a   .   so you need to make Debuggable's return to have type   a -> Debugguble a
16:00:20 <hpaste>  kbateman annotated "monad trouble" with "rewritten in State monad" at http://hpaste.org/6718#a3
16:01:12 <greendemon> Kind of wierd though.  It seems like functions usually don't mind if the argument types are stricter
16:01:21 <greendemon> I guess classes are different
16:02:34 <glen_quagmire> what's the difference of using monad transformer and making your data type instance of Monad?
16:02:48 <EvilTerran> ?type return -- is why
16:02:49 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
16:03:04 <EvilTerran> the definition of the class says that's "forall a", with no constraints on a
16:04:22 <EvilTerran> and an instance decleration has to be as general as the class its instantiating, otherwise code that works on "TheClass a => a" won't necessarily work on your instance of TheClass
16:04:45 <monochrom> There are two kinds of democracies.  One kind really allows anyone to run for president.  The other allows only one person to run for president, but it says it's still democratic because you can still vote for him.
16:04:57 <greendemon> I see
16:05:09 <monochrom> When you implement a monad, you have to implement the first kind of democracy, not the second false kind.
16:05:21 * EvilTerran looks askance at monochrom
16:05:35 <EvilTerran> dude, weird analogy
16:06:14 <monochrom> When you're thinking "I want my monad to restrict to one type", it is the same as "you are allowed to vote for anyone, but it has to be him".
16:06:35 <EvilTerran> incidentally, the Olegian hack others mentioned involve making two classes:
16:07:04 <EvilTerran> class Return m a where return :: a -> m a; class Bind m a b where (>>=) :: m a -> (a -> m b) -> m b
16:07:08 <Twey> Heh
16:07:11 <kbateman> That's why I wrote it as "type Debuggable a = State String a".  You want the String to be fixed, but you have to let that last a type be anything.
16:07:19 <Twey> 'They can have any colour so long as it's black'
16:07:26 <EvilTerran> you can then restrict any of the type variables as you see fit
16:07:50 <greendemon> interesting
16:07:55 <glen_quagmire> oh transformers are onion wraps. while monad instance is an onion with 1 layer
16:08:10 <glen_quagmire> but the layer might include the universe
16:08:16 <EvilTerran> a popular example being "instance Ord a => Return Set a where return = singleton; instance (Ord a, Ord b) => Bind Set a b where {whatever this bit is}"
16:08:17 * Twey grins.
16:09:24 <EvilTerran> you can, in fact, kinda use these definitions in GHC, with -XNoImplicitPrelude. I think it's still broken in places, though.
16:09:48 <replica> the Data.Time lib is giving me a headache... could someone please tell me how to get output equivalent to `date -R` (i.e. rfc822/2822)?
16:09:57 <forkiliens> do you know of any elegant method to print sth. like (((x+2*x)-3))^2 with only the necessary brackets?
16:10:19 <EvilTerran> (you'd want to have instance Monad m => Return m a where { return = Prelude.return } and instance Monad m => Bind m a b where { (>>=) = (Prelude.>>=) }, so the existing monads would still work
16:10:21 <greendemon> Ok, another question: some people mentioned having my class automatically derive show?
16:10:27 <greendemon> How does that work?
16:10:37 <EvilTerran> forkiliens, that sounds like how showsPrec would work
16:10:44 <EvilTerran> *works
16:10:48 <glen_quagmire> data Debuggable a = ... deriving (Show)   ?
16:10:55 <monochrom> Yeah.
16:11:06 <glen_quagmire> how can I make sure type varialbe a to be Show?
16:11:16 <forkiliens> evilterran: should i look up showsPrec?
16:11:23 <glen_quagmire> data (Show a) => Debuggable a = ...  deriving (Show) ?
16:11:25 * glen_quagmire tries
16:11:45 <monochrom> when deriving, you don't need your own (Show a)=>
16:11:50 <Heffalump> it'll automatically be part of the instance generated by the compiler
16:12:00 <Heffalump> the Show a constraint, that is
16:12:02 <glen_quagmire> oh cool
16:12:27 <glen_quagmire> data A a = A a, now i can wrap anything in A
16:12:39 <EvilTerran> forkiliens, alternatively, you have showProd (Times a b) = showProd a ++ "*" ++ showProd b; showProd (a@Plus _ _) = "(" ++ showSum a ++ ")" -- kinda thing
16:12:39 <greendemon> that is AWESOME!
16:12:52 <greendemon> I may never derive Show on my own again!
16:13:03 <EvilTerran> greendemon, do you mean instantiate?
16:13:14 <greendemon> How does it do that?
16:13:24 <ehird> greendemon: internal compiler stuff
16:13:26 <EvilTerran> forkiliens, kinda like a recursive grammar, only backwards
16:13:26 <forkiliens> evilterran: thank you. i will see, if it helps me.
16:13:31 <ehird> the compiler knows your data structures :)
16:13:31 <forkiliens> ok
16:13:34 <greendemon> Perhaps instantiate is the correct word
16:13:36 <thoughtpolice> greendemon: it's covered in the haskell 98 report
16:13:51 <ehird> on a similar topic, if I'm making a general data type -- what is the stuff to derive which may be useful later?
16:13:52 <ehird> i am guessing:
16:13:57 <ehird> (Show, Read, Typeable, Data)
16:13:58 <EvilTerran> forkiliens, that being kinda like "product ::= product * product | (sum)"
16:14:01 <ehird> maybe ,Eq
16:14:02 <greendemon> Does only Show do this, or do other classes?
16:14:15 <EvilTerran> the report says, one sec
16:14:19 <thoughtpolice> greendemon: the H98 report defines several classes in which automatic instantitation should be possible
16:14:25 <glen_quagmire> Show, Monad, Functor, Traversable, MonadState, MonadError, MonadIO, ...
16:14:26 <thoughtpolice> Enum, Show, Eq, etc. etc.
16:14:33 <ehird> you can derive Monad?!
16:14:34 <ehird> wowzers
16:14:46 <EvilTerran> ?where+ deriving http://www.haskell.org/onlinereport/derived.html
16:14:46 <lambdabot> Done.
16:14:49 <EvilTerran> there
16:14:52 <thoughtpolice> yay :)
16:14:53 <dibblego> where is the latest QuickCheck source?
16:15:02 <thoughtpolice> dibblego: http://code.haskell.org/QuickCheck iirc
16:15:03 <lambdabot> Title: Index of /QuickCheck
16:15:07 <thoughtpolice> that's 2.0
16:15:08 <ehird> @index Data
16:15:08 <lambdabot> Data.Generics.Basics, Data.Generics
16:15:11 <ehird> hmm
16:15:14 <ehird> where's the Data class?
16:15:28 <dibblego> thoughtpolice, cheers - does 2.0 have the 'variant' function described in the paper (I'm trying to understand it)
16:15:47 <EvilTerran> ehird, i think it's in Data.Generics
16:16:12 <thoughtpolice> dibblego: not sure off hand
16:16:19 <Peaker> how do I nest monad transformers in one another? if I try to use a transformer type as the type argument for another transformer type, I need to repeat the "a" (contained type) in both transformers
16:16:22 <dibblego> thoughtpolice, no prob, cheers
16:16:36 * EvilTerran looks... it's defined in Data.Generics.Basics - http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Generics-Basics.html#Data
16:16:37 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2pfswp
16:21:24 <ehird> @hoogle DataType -> [String]
16:21:24 <lambdabot> No matches, try a more general search
16:21:27 <ehird> @hoogle DataType -> a
16:21:27 <lambdabot> No matches, try a more general search
16:21:45 <ehird> hmm
16:21:58 * ehird is wondering about the most correct way to model something like Scheme objects in a haskell environment
16:22:06 <ehird> you can make all object's IORefs to the base type
16:22:12 <ehird> and the base type's fields to be IORefs
16:22:23 <ddarius> There is no one correct way.
16:22:25 <ehird> but then you can't e.g. use parsec, you need to be in IO (admittedly, the interp code will be in IO)
16:22:35 <EvilTerran> Peaker, you wrap your base monad in one transformer, leaving off the final type parameter
16:22:37 <ehird> another way is to make the type pure, then use IORefs as e.g. function arguments
16:22:43 <ehird> which works pretty well
16:22:54 <ehird> the final way is to use an array of Integer -> base type
16:23:03 <ehird> and store Integers in your type -- i.e. manual pointer-ing
16:23:09 <EvilTerran> Peaker, then wrap the resulting monad in another transfomer, *then* stick the final type parameter on the end
16:23:15 <kbateman> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
16:23:16 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
16:23:23 <ehird> actually, Scheme requires you to be able to compare locations
16:23:26 <ehird> so maybe the last way is the best
16:23:27 <EvilTerran> ?unmtl StateT Int (ReaderT String IO) a
16:23:27 <lambdabot> Int -> String -> IO (a, Int)
16:23:29 <Peaker> EvilTerran, I am trying: type Action st m a = State.StateT st (Reader.ReaderT Environment m a)
16:23:31 <ehird> kbateman: si48h is not scheme
16:23:35 <EvilTerran> that's what one looks like
16:23:51 <EvilTerran> type Action st m a = State.StateT st (Reader.ReaderT Environment m) a
16:23:52 <ehird> ?unmtl StateT [AmbT r m r] (ContT r m) a
16:23:52 <lambdabot> [AmbT r m r] -> (a -> [AmbT r m r] -> m r) -> m r
16:23:54 <kbateman> That's a scheme implementation in haskell
16:24:00 <ehird> kbateman: You are incorrect.
16:24:09 <ehird> language with parentheses and some familiar names != scheme
16:24:17 <kbateman> but...but... the title! :)
16:24:23 <EvilTerran> Lemmih, remember you're always wrapping a monad itself - something that expects one type parameter
16:24:29 <ehird> some of scheme's stuff is very finnicky
16:24:30 <ehird> e.g. eq?
16:24:35 <EvilTerran> the "m" in return :: m a -> a
16:24:37 <ehird> for eq?, you need to be able to compare exact locations
16:24:40 <EvilTerran> er, a -> m a. but still.
16:24:40 <Peaker> EvilTerran, thanks!
16:24:48 <ehird> every (cons a b) is unique
16:24:50 <EvilTerran> :)
16:24:54 <ehird> and eq? differenciates between them
16:24:57 <ehird> so you can't use a functional structure
16:25:07 <SamB> ehird: this hardly matters if you can't assign to them ;-)
16:25:08 <Lemmih> EvilTerran: What?
16:25:17 <ehird> SamB: Then, uh, it's not Scheme.
16:25:23 <EvilTerran> IO is a monad, (StateT st IO) is a monad, ReaderT env (StateT st IO) is a monad...
16:25:24 <kbateman> There's an 'internal' pointer equality function in ghc, I forget what it is...
16:25:29 <ehird> Aiming for R5RS here..
16:25:40 <ehird> kbateman: That would be hardly helpful
16:25:43 <EvilTerran> (IO a) is *not* the type of a monad, it's the type of a monadic values
16:25:44 <SamB> ehird: you aim so low!
16:25:47 <ehird> It's the pointers in the world of scheme.
16:25:48 <EvilTerran> s/values/value/
16:25:52 <ehird> SamB: R5RS is a very nice language
16:25:54 <kpreid> ehird: there's a major scheme impl that recently went to immutable conses...:)
16:26:10 <ehird> kpreid: I like programs that can do stuff
16:26:10 <ehird> :p
16:26:18 <EvilTerran> Lemmih, er, does that make sense?
16:26:21 <SamB> I bet they do to
16:26:24 <SamB> too
16:26:44 <SamB> but apparantly changing conses isn't one of those things they truly like their programs to be able to do
16:27:20 <ehird> I want to be able to serialize at the level of SISC
16:27:29 <ehird> it can serialize continuations, as well as regular functions too
16:27:31 <ehird> even primitives
16:27:44 <Lemmih> EvilTerran: Did you type my nick in error?
16:28:16 <EvilTerran> Lemmih, oh, sorry. I meant Peaker. you're the same length and colour in my client.
16:28:19 <EvilTerran> <_< >_>
16:28:32 <EvilTerran> EvilTerran--
16:28:44 <Peaker> EvilTerran, it does clear it up a bit, thanks
16:28:57 <ehird> I think how SISC does it is that each native procedure is in a special table of primitives
16:29:02 <ehird> of symbol -> java func
16:29:07 <ehird> and those are seperate from the toplevel bindings
16:29:09 <EvilTerran> Peaker, ah, thank fortune it made sense, even if i was talking to the wrong person :P
16:29:13 <ehird> so the 'primitives' table is immutable
16:29:37 <Peaker> EvilTerran, now I am wondering how to run a StateT-containing-Reader-containing-IO.. runStateT takes the arg for the statet, but not the one for the reader
16:29:54 <Peaker> containing readert that is
16:30:17 <EvilTerran> ?type runStateT
16:30:18 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
16:30:32 <ehird> hmm
16:30:37 <ehird> but how does it handle an ffi..
16:30:38 <EvilTerran> so runStateT will return a (Reader.ReaderT Environment m)
16:30:49 <EvilTerran> so pass this to runReaderT, and that'll give back something in m
16:30:54 <EvilTerran> s/return a/return something in/
16:31:09 <ehird> Hmm
16:31:11 <Peaker> EvilTerran, oh, cool
16:31:28 <ddarius> ehird: If you CPS transform, serializing continuations is just serializing closures.
16:31:29 <ehird> Does it seem to anyone like the last array-based solution is the best?
16:31:33 <ehird> Because I thought of a problem with that.
16:31:40 <ehird> You need to mutate it. So you still can't use parsec.
16:31:43 <ehird> ddarius: Yes
16:31:54 <ehird> ddarius: I will be using ContT, so basically the same
16:32:13 <ehird> But yeah, thoughts on the 'how to represent the mutable values while still using parsec' thing are welcome
16:32:28 <EvilTerran> Peaker, a popular way of abstracting all this away - and eliminating all those nasty calls to lift - is to newtype your fully-transformed monad and define versions of all the functions that're lifted appropriately, as well as an appropriate "run" function
16:32:53 <EvilTerran> then hide all this in one module, and use your monad as if it weren't build from transformers
16:32:59 <Peaker> EvilTerran, Isn't that boiler-plate'ish though?
16:33:20 <EvilTerran> if you're just using standard STM transformers, i think they have magic lifting because of cunningness wit hthe instance declerations
16:33:28 <EvilTerran> so that's not necessary
16:33:42 <EvilTerran> it is boiler-plate-ish, but it's better than repeating yourself
16:33:46 <Peaker> EvilTerran, I think I understand. Thanks.  Now I need to play around with it to see that I really do
16:33:58 <ddarius> ehird: Parsec is a parser library.  Usually you deal with semantic things later.
16:34:14 <ddarius> ehird: That said, Parsec3 is a monad transformer.
16:34:25 <ehird> ddarius: Aha, but code is data. this is scheme
16:34:26 <ehird> :)
16:34:38 <ehird> Basically, I am implementing the READ procedure.
16:34:46 <ehird> this reads one datum from a port,
16:34:49 <ehird> into a scheme object.
16:35:01 <ehird> EVAL then interprets that datum as a program.
16:35:02 <ddarius> ehird: Code is data in every language and there doesn't need to be anything particularly special about parsing Scheme.
16:35:31 <ehird> To be honest, readtable support would be nice.
16:35:38 <ehird> Maybe I'll ditch Parsec.
16:35:47 <ehird> What joy this is :)
16:36:53 <ehird> ddarius: OK, but I need to use the same data type to represent the data and the code.
16:36:57 <ehird> And as data it must be mutable.
16:37:10 <SamB> ehird: you could have an AST type that corresponds with the pure types of scheme values -- in particular, those allowable in read
16:37:35 <glen_quagmire> if (f p1 p2 p3) is same as (((f p1) p2) p3), can I say f is being curried?
16:37:42 <SamB> (I am fairly certain that scheme syntax does not admit loops in the syntax tree, the way Common Lisp's does?)
16:37:52 <ehird> SamB: it does if the reader is decent
16:37:57 <ehird> #1=(a . #1#)
16:38:00 <SamB> it does?
16:38:03 <ehird> SamB: Besides, that's a Really Bad Idea.
16:38:11 <ehird> That means I need to reify data into an AST in 'eval'.
16:38:17 <ehird> That is just a really awkward way to implement Scheme.
16:38:18 <SamB> okay, so it DOES admit loops in the syntax tree
16:38:20 <ehird> Esp. with macros.
16:38:25 <ehird> You want to make the data structurse the same.
16:38:28 <ehird> SamB: Well, not in R5RS
16:38:32 <SamB> oh, okay.
16:38:33 <ehird> But everything supports it
16:38:39 <SamB> you said you were going for R5RS
16:38:53 <SamB> I was going to say you should have a post-processing step after parsing
16:39:17 <SamB> where you actually bring the syntax into the image
16:39:20 <ehird> hahaha eww
16:39:25 <ehird> that's an awful idea :)
16:39:37 <SamB> how so?
16:39:49 <SamB> alternatively, you could build a monadic computation that would do this
16:40:27 <SamB> but I bet that makes it a lot harder to debug your parser!
16:40:46 <ehird> yeah
16:40:52 <ehird> SamB: I don't want indirection, anyway.
16:40:54 <ehird> That's just duplication.
16:40:58 <SamB> it isn't
16:41:10 <SamB> having a pure AST type makes it easy to debug the parser
16:41:45 <ddarius> SamB: Forget debug, it makes it easier to write in the first place
16:41:53 <ehird> SamB: So my base data types will be pure.
16:41:58 <ehird> So how do I layer the state on top of that?
16:42:02 <SamB> ddarius: well, I know that, but ehird doesn't seem to think so
16:42:27 <yuriyp> @pl gw_iterate p1 p2 pts = next_pt : gw_iterate p2 next_pt pts where next_pt = gw_next_pt p1 p2 pts
16:42:27 <lambdabot> (line 1, column 74):
16:42:27 <lambdabot> unexpected "="
16:42:27 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>" or end of input
16:42:34 <SamB> besides, thats when I *do* my debugging
16:42:45 <SamB> hopefully
16:42:54 <yuriyp> @pl next_pt : gw_iterate p2 next_pt pts where next_pt = gw_next_pt p1 p2 pts
16:42:54 <lambdabot> (line 1, column 51):
16:42:54 <lambdabot> unexpected "="
16:42:54 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>" or end of input
16:44:00 <yuriyp> @pl gw_next_pt p1 p2 pts : gw_iterate p2 (gw_next_pt p1 p2 pts) pts
16:44:00 <lambdabot> gw_next_pt p1 p2 pts : gw_iterate p2 (gw_next_pt p1 p2 pts) pts
16:46:29 <MyCatVerbs> dons: is Galois named after Evariste Galois, out of curiosity?
16:47:18 <SamB> mauke: I ended up just following the advice in README.Debian and using the font that makes it look like uxterm...
16:47:41 <Heffalump> mycatverbs: yes (indirectly, in the sense that it was originally named Galois Connections after the mathematical structure named after Galois)
16:48:00 <MyCatVerbs> Heffalump: spiffy, thanks.
16:48:10 <SamB> does Galois have a Field Hockey team?
16:48:27 <dons> MyCatVerbs: yeah
16:48:30 <dons> SamB: no
16:48:35 <SamB> dons: why not?
16:48:37 <dons> indoor soccer though
16:48:44 <dons> field hockey's a bit hard in portland
16:48:56 <SamB> no excuse for avoiding the pun!
16:49:15 <SamB> you could ... play it ... indoors! or something
17:00:09 <schemelab> MyCatVerbs: ping?
17:01:51 <MyCatVerbs> schemelab: pong!
17:02:04 <schemelab> MyCatVerbs: your email is broken
17:02:54 <hpaste>  metaperl pasted "broken email" at http://hpaste.org/6719
17:03:25 <schemelab> MyCatVerbs: check that out - http://hpaste.org/6719
17:04:47 <MyCatVerbs> schemelab: ...that isn't my email address.
17:04:56 <schemelab> oh
17:05:57 <schemelab> no wonder you didnt get my email
17:06:40 <EvilTerran> just as well, seeing as it'll get picked up by spammers posted un-obfuscated on the web like that
17:18:30 <EvilTerran> ch-ch-ch-CHANNELFRAG
17:18:44 <gwern> dons: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/nanocurses-1.5.1 <-- per your suggestion, I split out the Curses.hsc in hmp3 to its own nanocurses package. I dunno if you want to make hmp3 use it though since you seem to depend on a lot of configure-defined variables in hmp3...
17:18:49 <lambdabot> http://tinyurl.com/3c5lsq
17:18:58 <dons> gwern: interseting!
17:19:18 <dons> gwern: Console.* would have been the appropriate namespace
17:19:31 <dons> do you have to hand the hierarchichal module namespace guide?
17:19:53 <gwern> dons: yes, but hscurses is already using the UI.* naming scheme
17:20:19 <ehird> UI.Console.*
17:20:27 <ehird> UI.Console.Curses
17:21:12 <dons> gwern: also, you forked it, so you should be listed as the maintainer
17:21:19 <gwern> we need more standard module names I'll agree (but I'm going to have dinner now that I've uploaded it)
17:21:19 <dons> it shouldn't link to my homepage either
17:21:32 <dons> does it build?
17:22:53 <gweiqi> is curses unix only?
17:24:20 <dons> effectively
17:24:34 <gweiqi> darn
17:24:53 <gweiqi> i've been hoping for cross-platform curses for a long time
17:26:28 <gweiqi> for now, my curses are limited to, "@#%$ you windows!"
17:27:18 <cjb> gweiqi: Did you know that your nick contains the Chinese word for for the game of Go?
17:27:35 <cjb> I thought I'd point it out, seeing as how we're a channel of vegetarian Go players.
17:27:38 <gweiqi> cjb: intentionally
17:27:48 <cjb> cool.  do you play online?
17:28:02 <gweiqi> well, i have a kgs account, but hardly play online anymore
17:28:08 <gweiqi> i prefer playing with my friends in person
17:28:24 <cjb> Ah, lucky.  :)  I'm still struggling with KGS.
17:28:29 <gweiqi> struggling how?
17:28:30 <cjb> You get.. a different type of game there.
17:28:38 <gweiqi> that's the main reason i don't like playing there
17:28:53 <cjb> Yeah.  But my friends are lazy and don't want to play in person.  :)
17:28:56 <gweiqi> they're all overplaying-blitz-crazy psychos
17:29:02 <cjb> And Massachusetts has this awful club situation.
17:29:03 <cjb> indeed!
17:29:12 <gweiqi> which MA club?
17:29:26 <cjb> the Mass Go Association; charges ~$150/year membership.
17:29:36 * SamB loves being able to use grep on .hp files
17:29:39 <gweiqi> oh, in summerville?
17:29:43 <cjb> because they rent a 24-hour space despite only having a few people show up one or two nights a week.
17:29:44 <cjb> Yup, that's the one.
17:29:51 <gweiqi> i hate that place
17:30:05 <cjb> It's idiotic.  They could just ask MIT for a room.
17:30:09 <gweiqi> yeah, really
17:30:16 <cjb> Where do you live?
17:30:16 <gweiqi> they pay their own rent for no purpose
17:30:18 <gweiqi> CT
17:30:23 <cjb> Ah, cool.
17:30:38 <cjb> The purpose is that it was the founder's dying wish to have a 24 hour place for Go players to congregate.
17:31:09 <gweiqi> i see
17:31:10 <cjb> Unfortunately, this was not a dying wish accompanied with money, so the same few people end up writing checks to cover the rent shortfall every year.  Dying wishes can be kind of.. rude.
17:31:44 <cjb> (And meanwhile people show up and see the membership fee and decide never to come back.)
17:31:50 <gweiqi> i'd rather choose smarter alternatives than follow somebody to the grave
17:32:08 <cjb> yeah.  it's not very politically correct to say that, sadly.
17:32:22 <gweiqi> yeah, i'm not very polite i guess
17:32:36 <gweiqi> do you go to the congresses?
17:32:52 <cjb> Not lately.. I went to the Oza last year.
17:33:12 <gweiqi> i see
17:33:17 <gweiqi> or do you mean this year
17:33:21 <gweiqi> or 2 years ago
17:33:31 <cjb> Hm, maybe it was two years ago.  In NYC.
17:33:39 <gweiqi> ah, ok
17:33:42 <gweiqi> yeah, i was there
17:33:54 <gweiqi> i don't suppose you've heard of empty sky?
17:34:00 <cjb> Yup, I have.
17:34:04 <gweiqi> that's my club
17:34:20 <cjb> Ooh.  :)
17:34:56 <gweiqi> and I'm "Ubiquity" on kgs
17:35:19 <cjb> Ah, I've seen you around.  Kosai.
17:35:24 <gweiqi> cool
17:58:31 * SamB eagerly awaits GOLD
17:58:57 <ddarius> Why?
17:58:58 <ehird> GOLD = 4
17:59:11 <SamB> ddarius: because it is faster than ld
17:59:34 <SamB> and I hope it doesn't use as much memory
18:00:09 <ehird> 'vegetarian Go players' -- what if I eat meat and don't play Go? am I not in #haskell any more? ;)
18:00:24 <ehird> unsafeKillAnimal >>= tastyEatAnimal
18:00:53 <EvilTerran> `catch` \PetaTakesException -> ...
18:01:16 <Cale> Mmm... spicy baconator
18:01:58 <ehird> EvilTerran: PetaTakesException was demoted from Exception to Whine before the first standard was released.
18:02:33 <ehird> This is because one of the wiser committe members changed the PETA type to 'data PETA' after it was decided that having any PETA in the system would be a disgrace.
18:03:57 <nanothief> I always thought that PETA was a misspelling of PITA
18:04:08 <ehird> no, PITY
18:04:17 <ehird> they named themselves after what everyone else did to them
18:04:20 * allbery_b wonders if it's too late tolobby for the peta- prefix to be changed from macro to micro
18:05:28 <allbery_b> and, I don't pity them in ther least.  you pretty much have to choose to make yourself *that* stupid
18:06:28 <ehird> haha
18:06:32 <olsner> what's PETA?
18:06:43 <ehird> olsner: people for the ethical treatment of animals
18:06:48 <olsner> oh
18:06:56 <Cale> Oh awesome, the chipotle ranch sauce contains egg and milk. This thing is the most delicious way to eat as many animal products as possible since the turducken.
18:07:00 <ehird> though i prefer 'insane idiots who like doing ridiculous stunts and caring more about animals than humans'
18:07:01 <dons> error: wrong channel?
18:07:04 <allbery_b> except they're usually far from ethical
18:07:09 <allbery_b> toward people *or* aminals
18:07:12 <ehird> dons: shush you :)
18:07:12 <allbery_b> animals
18:07:14 <allbery_b> feh
18:07:20 <dons> no, seriously. wrong channel guys
18:07:21 <ehird> allbery_b: that's true, they don't care much about either
18:07:31 <ehird> dons: cjb started it :<
18:07:34 <allbery_b> yeh, this probably belongs in -blah
18:09:02 <allbery_b> Cale: add honey?
18:13:40 <Nafai> I'm watching byorgey's talk on xmonad + haskell
18:13:53 <Nafai> He mentioned something about strictness annotations (!, I think?)
18:14:20 <Nafai> So does that mean for a data constructor that you are specifying that the argument *must* be evaluated at that time, and not lazily?
18:14:36 <monochrom> Yes.  For example http://www.vex.net/~trebla/haskell/strict-field.html
18:14:36 <Jaak> > let foo !x = 1 in foo (sum [1..])
18:14:37 <lambdabot> Title: What does the strictness flag do in data types?
18:14:39 <lambdabot>   Not in scope: `foo'
18:15:28 <Nafai> Cool, thanks
18:15:50 <monochrom> Still not exactly at the time you build a value, but certainly still earlier than laziness would do it.
18:17:11 <hpaste>  morrow pasted "Re: [Haskell-cafe] Generating a random list " at http://hpaste.org/6720
18:17:23 <Cale> Nafai: It means that when the application of the constructor to its arguments is evaluated, then the arguments are evaluated as well.
18:17:51 <gweiqi> at pattern-match time
18:18:04 <Cale> Right, that's the only time evaluation ever happens, really.
18:18:38 * Nafai nods
18:18:40 <Nafai> Makes sense
18:18:48 <Cale> So even if you only match against the constructor, the fields will be evaluated then as well.
18:23:30 <ehird> > let foo (!x) = 1 in foo [1..]
18:23:30 <lambdabot>  Parse error in pattern at "in" (column 18)
18:23:39 <ehird> > let foo = (\(!x) = 1) in foo [1..]
18:23:39 <lambdabot>  Parse error in pattern at "=" (column 18)
18:23:48 <ehird> language.haskell don't know bout mah bang-patterns
18:24:10 <Cale> Not only that, but -XBangPatterns isn't turned on.
18:27:53 <glen_quagmire> > let twice f = f . f in twice twice twice twice (+ 1) 0
18:27:54 <lambdabot>  65536
18:28:13 <glen_quagmire> what is twice . twice ?
18:28:59 <mauke> four times
18:29:15 <Cale> Well, (twice . twice) f = twice (twice f) = twice (f . f) = (f . f) . (f . f)
18:30:57 <glen_quagmire> is that normal order evaluation?
18:31:07 <Cale> No, but it doesn't matter here :)
18:31:38 <Cale> Normal order would have reduced  twice (twice f)  to  twice f . twice f
18:32:05 <glen_quagmire> oh thank you
18:39:21 <ehird> > let twice = f . f in twice twice
18:39:22 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr (f a))
18:39:27 <ehird> > let twice = f . f in twice twice :: Expr
18:39:27 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr (f a))
18:39:33 <ehird> > let twice f = f . f in twice f :: Expr
18:39:34 <lambdabot>  Couldn't match expected type `Expr' against inferred type `b -> b'
18:39:47 <ehird> > let twice f = f . f in twice f x :: Expr
18:39:47 <lambdabot>  f (f x)
18:39:51 <ehird> > let twice f = f . f in twice twice f x :: Expr
18:39:52 <lambdabot>  f (f (f (f x)))
18:39:58 <ehird> coool
18:41:54 <ddarius> "Figure 7: A cartoon character being dismembered by a red torture device."
18:46:12 <glen_quagmire> > let t f = f . f in t t t t f x :: Expr
18:46:13 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
18:46:21 <glen_quagmire> > let t f = f . f in t t t f x :: Expr
18:46:22 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f x)))))))))))))))
18:46:59 <shachaf> > fix f :: Expr
18:46:59 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
18:47:22 <glen_quagmire> hrm, 2, 4, 16, 65536
18:47:46 <ehird> ddarius: Hahah. Source?
18:47:51 <glen_quagmire> is this ackerman function?
18:48:05 <shachaf> Tetrations!
18:48:11 <ehird> glen_quagmire: ackermann function has two arguments for one
18:48:13 <ehird> ;)
18:48:34 <glen_quagmire> http://research.att.com/~njas/sequences/?q=2%2C+4%2C+16%2C+65536&language=english&go=Search
18:48:36 <lambdabot> Title: 2,4,16,65536 - OEIS Search Results, http://tinyurl.com/3xoc6z
18:48:50 <ehird> @oeis 2 4 16 65536
18:48:51 <lambdabot> a(0) = 0; for n >= 0, a(n+1) = 2^a(n). This is the Ackermann function A_3(n+1...
18:48:51 <lambdabot> [0,1,2,4,16,65536]
18:48:54 <ehird> who needs google
18:48:55 <ehird> you have lambdabot
18:48:58 <glen_quagmire> twice is a bottom!
18:49:13 <ehird>    a(0) = 0; for n >= 0, a(n+1) = 2^a(n). This is the Ackermann function A_3(n+1)
18:49:21 <ehird> so this function is A(3,n+1)
18:49:26 <Cale> > let t f = f . f in (t . t t) f
18:49:26 <lambdabot>  Add a type signature
18:49:29 <Cale> > let t f = f . f in (t . t t) f :: Expr
18:49:30 <lambdabot>  Couldn't match expected type `Expr' against inferred type `b -> b'
18:49:36 <Cale> > let t f = f . f in (t . t t) f x :: Expr
18:49:36 <lambdabot>  f (f (f (f (f (f (f (f x)))))))
18:49:37 <shachaf> The Ackermann sequence is 1, 2+2, 3*3, 4^4, 5^^5, etc., right?
18:49:42 <ehird> > let t f = f . f in scanl f x :: Expr
18:49:43 <lambdabot>  Couldn't match expected type `Expr'
18:49:43 <Cale> > let t f = f . f in (t t . t) f x :: Expr
18:49:44 <lambdabot>  f (f (f (f (f (f (f (f x)))))))
18:49:49 <ehird> > let t f = f . f in iterate f x :: Expr
18:49:50 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[Expr]'
18:49:54 <ehird> dfgjhddddddjkhsldg
18:49:56 <ehird> > let t f = f . f in iterate f x :: [Expr]
18:49:57 <lambdabot>  [x,f x,f (f x),f (f (f x)),f (f (f (f x))),f (f (f (f (f x)))),f (f (f (f (f...
18:50:04 <ehird> urgh
18:50:07 <ehird> this won't be easy
18:50:08 <ehird> :)
18:50:09 <Cale> > let t f = f . f in (t t . t) f x == (t . t t) f x
18:50:10 <lambdabot>  True
18:50:24 <mauke> > help t
18:50:31 <lambdabot>  DENIED.
18:50:44 <ehird> > let t f = f . f; lst f x = f x : lst (f.f) x in lst t x :: [Expr]
18:50:46 <lambdabot>  Couldn't match expected type `Expr' against inferred type `b -> b'
18:50:52 <ehird> Blaaaaaaurghll.
18:50:54 <ddarius> ehird: http://www.cs.berkeley.edu/b-cam/Papers/obrien-2002-GMA/index.html
18:50:55 <lambdabot> Title: Graphical Modeling and Animation of Ductile Fracture, http://tinyurl.com/2k4ouf
18:51:10 <ehird> Whoever wishes to get this working has my respect :p
18:51:44 <ehird> > let t f = f . f; lst f x = f x : lst (t f) x in lst t x :: [Expr]
18:51:45 <lambdabot>  Couldn't match expected type `Expr' against inferred type `b -> b'
18:51:49 <ehird> whuttt
18:51:52 <ehird> ?type let t f = f . f; lst f x = f x : lst (t f) x in lst t x
18:51:53 <lambdabot>     Couldn't match expected type `b -> b' against inferred type `Expr'
18:51:53 <lambdabot>     In the second argument of `lst', namely `x'
18:52:25 <ehird> > let t f = f . f; lst f g = g x : lst (t f) g in lst t f
18:52:25 <lambdabot>  Add a type signature
18:52:29 <ehird> > let t f = f . f; lst f g = g x : lst (t f) g in lst t f :: [Expr]
18:52:30 <lambdabot>  [f x,f x,f x,f x,f x,f x,f x,f x,f x,f x,f x,f x,f x,f x,f x,f x,f x,f x,f x...
18:52:37 <ehird> Ahh bagurlugal!!
18:52:50 <ehird> > let t f = f . f; lst f = f x : lst (t f) in lst t f :: [Expr]
18:52:50 <lambdabot>  Couldn't match expected type `Expr' against inferred type `b -> b'
18:52:55 <monochrom> I think lambdabot feels the same about you.
18:53:07 <ehird> monochrom: Likely
18:53:20 <ehird> > let t f = f . f; lst f g = g x : lst (f f) (f g) in lst t f :: [Expr]
18:53:20 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
18:53:20 <lambdabot>     Probab...
18:53:27 <ehird> Okay, right, someone fix that :p
19:14:59 <hpaste>  (anonymous) pasted "Trim space problem" at http://hpaste.org/6721
19:15:23 <Larose> Is there a better way to write http://hpaste.org/6721 ?
19:18:16 <ski> @type let t f = f . f; lst :: (forall a . (a -> a) -> (a -> a)) -> (Expr -> Expr) -> [Expr]; lst f g = g x : lst (f f) (f g) in take 10 $ lst t f :: [Expr]
19:18:17 <lambdabot> [Expr]
19:18:19 <ski> > let t f = f . f; lst :: (forall a . (a -> a) -> (a -> a)) -> (Expr -> Expr) -> [Expr]; lst f g = g x : lst (f f) (f g) in take 10 $ lst t f :: [Expr]
19:18:19 <lambdabot>  Parse error at "." (column 35)
19:19:15 <Cale> Larose: you could at least use dropWhile
19:19:24 <ski> ehird : i think that would work, except LBs `eval' doesn't seem to like the rank-2 signature (but it's fine with `type')
19:19:25 <Cale> > dropWhile isSpace "   hello there   "
19:19:27 <lambdabot>  "hello there   "
19:19:35 <Larose> Yeah, I just find the solution with dropWhile
19:20:44 <Cale> > let dropWhileEnd f = reverse . dropWhile f . reverse in dropWhileEnd isSpace . dropWhile isSpace $ "   hello there   "
19:20:44 <lambdabot>  "hello there"
19:21:30 <Larose> http://en.wikipedia.org/wiki/Trim_(programming)#Haskell
19:22:07 <Cale> yeah, that's a nice way to put it
19:22:17 <Larose> yep
19:23:53 <ski> @type help
19:23:54 <lambdabot> forall t a. t -> Sym a
19:24:01 <ski> @src Sym
19:24:01 <lambdabot> Source not found. The more you drive -- the dumber you get.
19:24:06 <ski> @index Sym
19:24:06 <lambdabot> bzzt
19:24:27 <Cale> > map head . takeWhile (any (not . isSpace)) . tails . dropWhile isSpace $ "    hello   "
19:24:27 <lambdabot>  "hello"
19:24:38 <Cale> hmm
19:24:39 <Cale> > map head . takeWhile (any (not . isSpace)) . tails . dropWhile isSpace $ "    hello"
19:24:40 <lambdabot>  "hello"
19:24:44 <Cale> okay, good :)
19:25:31 <Cale> That'll tend to be reasonable as well.
19:26:24 <macondo> poor lambdabot
19:26:45 <Cale> macondo: are you one of those bots again?
19:27:01 <macondo> Cale: I'm pretty human
19:27:14 <opqdonut> (does he pass the turing test?)
19:27:26 <Cale> macondo: Hehe, why are you saying 'poor lambdabot'?
19:27:37 <ari> @go how i failed the turing test
19:27:39 <lambdabot> http://www.blogcadre.com/blog/jason_striegel/how_i_failed_the_turing_test_2005_09_04_13_26_29
19:27:39 <lambdabot> Title: How I failed the Turing test | BlogCadre
19:27:56 <macondo> Cale: does not compute
19:28:08 <Larose> > map head . takeWhile (any (not . isSpace)) . tails . dropWhile isSpace $ "    he llo"
19:28:09 <lambdabot>  "he llo"
19:28:13 <Cale> (there's an annoying bot which tends to open up with 'poor <nick>' where <nick> is the name of someone who recently talked)
19:28:30 <macondo> Cale: just kidding, I don't know why I said taht
19:28:53 <Cale> macondo: heh, it's all right :)
19:28:55 <macondo> Really? wow I wasn't aware of that bot but it certainly is quite stupid
19:29:17 <lozza> Hey, just wondering if anyone could point in the right direction for using a tree structure in haskell?? I've looked at some of the docs that define what a tree is but it doesn't really specify how I'm meant to put data in.
19:29:37 <Cale> Yeah, it usually has the username "WP-Gast".
19:29:52 <Cale> lozza: You build values using the data constructors
19:29:57 <Cale> For example, if you have the type:
19:30:07 <Cale> data Tree a = Leaf | Branch a (Tree a) (Tree a)
19:30:14 <Cale> then, for instance
19:30:39 <Cale> Branch 5 (Branch 3 (Branch 1 Leaf Leaf) Leaf) (Branch 7 Leaf Leaf)
19:30:42 <Cale> Is a tree.
19:31:00 <Cale> You can then write functions which pattern match against tree constructors:
19:31:04 <Cale> size Leaf = 0
19:31:15 <Cale> size (Branch x l r) = 1 + size l + size r
19:31:41 <lozza> Oh okay, they didn't really have an example in any of the docs. Thanks heaps.
19:32:37 <Cale> bst [] = Leaf; bst (x:xs) = let (ls, rs) = partition (<= x) xs in Branch x (bst ls) (bst rs)
19:33:04 <Cale> There's a naive way to turn a list into a binary search tree.
19:34:55 <gwern> ever since I started uploading packages, I've gotten so much more spam
19:39:43 <gwern> (man. this python business makes me appreciate haskell and cabal more)
19:40:00 <Plareplane> does anyone find it amusing that installing ubuntu hardy's ghc package pulls in hugs?
19:40:26 <gwern> Plareplane: why on earth does it do that?
19:40:46 <Plareplane> ghc6 depends on haskell-utils depends on hugs
19:41:11 <Plareplane> haskell-utils did not used to depend on hugs
19:41:28 <Plareplane> (i'm not sure why it does now or why it didn't before)
19:44:02 <Cale> We should really hang out with the MOTU Haskell people more...
19:44:17 <glen_quagmire> > 2^65536
19:44:19 <lambdabot>  2003529930406846464979072351560255750447825475569751419265016973710894059556...
19:47:15 <gwern> Cale: the who?
19:47:33 <glen_quagmire> what is a good optimization flags that can calculate (twice twice twice twice twice) (+ 1) 0 , which is 2^65536
19:47:33 <Plareplane> apparently, it's a temporary bug introduced to fix another problem and should go away soon
19:47:39 <Cale> gwern: The people who maintain the Ubuntu universe packages for Haskell.
19:47:56 <Cale> (a.k.a. Masters Of The Universe)
19:48:02 <gwern> Cale: ah. what a strange acronym tho
19:55:09 <Svrog> why is it strange? they're obviously motu fans :)
19:55:58 <SamB> can you think of a better thing to call them?
19:56:48 <gwern> SamB: 'Universe maintainers'
19:56:59 <SamB> that sounds even sillier
19:57:09 <radix> maybe not sillier, but definitely not as catchy. :)
19:57:41 <SamB> those are the people who fix bugs in the laws of physics, eh?
19:58:07 <luqui> glen_quagmire, I don't think you'll find any
19:58:28 <gwern> SamB: oh sure. the next release will remove some arbitrary constants like the planck limits, and will redfine pi to be the easier to compute with '3'
19:58:29 <glen_quagmire> lucca, yah i tried -O2 and -O3
19:58:50 <glen_quagmire> > length $ show (2^65536)
19:58:51 <lambdabot>  19729
19:58:54 <glen_quagmire> this is instant
19:59:05 <luqui> glen_quagmire, the compiler does not usually go so far as to apply numeric algebra
19:59:17 <SamB> gwern: that will mess everything up
19:59:25 <luqui> so you'll have to do _something_ 2^65536 times, which will easily last you to the heat death of the universe
19:59:28 <SamB> then pi won't be transcendental anymore
19:59:46 <gwern> SamB: what's so bad about that?
20:00:06 <luqui> seems like an advantage to me :-)
20:00:07 <SamB> I'm sure it must be bad
20:00:24 <SamB> Cale: can you think of a reason?
20:00:33 <gwern> let us make all mathematics discrete!
20:00:35 <Svrog> gwern: http://en.wikipedia.org/wiki/Masters_of_the_universe <-- in the unlikely case you didn't know of masters of the universe
20:00:57 <SamB> this is almost worse than python 3000!
20:01:06 <gwern> (we shall ban mathematics dealing with infinities and continuums and suchlike magic, as spoiling our calculations)
20:01:33 <SamB> much much worse than DST changes by congress
20:01:36 <gwern> Svrog: I know the phrase from a song in a Highlander movie and a derogatory way of referring to wall street hotsots. is there any more to it than that?
20:01:46 <SamB> will probably crash sattelites
20:02:05 <Svrog> 80s cartoon "he-man and the masters of the universe"
20:02:27 <gwern> By the power of greyskull! I had no idea 'masters of the universe' referred to the he-man universe
20:02:35 <gwern> really, I didn't
20:02:36 <Svrog> hehe
20:04:03 <gwern> 'Natural numbers are enumerable. Also, they form a monoid, because an associative addition operator with zero as identity can be defined.' <-- my god, this pdf sounds like Cale
20:11:14 <ddarius> gwern: Natural numbers are the archetype for monoids.
20:20:10 <monochrom> There is a strong sense for that statement.  Something about representation functor.
20:25:40 <mattr__> hi all - how do I get ghci to use only haskell98 features?
20:38:27 <dcoutts> mattr__, that's almost what it does by default
20:39:09 <dcoutts> the main difference is ghci uses extended defaulting and gives access to many more modules than in H98
20:39:51 <dcoutts> you can turn extended defaulting off and you can restrict the module namespace to be just those in the haskell98 package
20:44:23 <mattr__> hmmm
20:44:45 <mattr__> I am looking at a paper by Mark Jones where he does first class polymorphism
20:45:06 <mattr__> ( I think that is kinda rank-n polymorphims - yeah?)
20:45:35 <mattr__> and all the examples are type checked/inferred just fine in ghc!?!?!?
20:48:13 <dcoutts> mattr__, that doesn't seem right, do you have an example? does it work the same in a ordinary compiled module?
20:49:17 <dibblego> ?type \p v -> if p then v else mzero -- is this function in the standard library?
20:49:17 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Bool -> m a -> m a
20:49:19 <hpaste>  mattr__ pasted "straight from Jones' paper to ghc" at http://hpaste.org/6722
20:50:08 <mattr__> well, I added the extra param on data Monad....
20:50:28 <mattr__> but I think that is fine
20:51:33 <hpaste>  mattr__ pasted "ghci's reponse (that code is in a BooleanPlay module)" at http://hpaste.org/6723
20:52:02 <Cale> mattr__: what is surprising about this?
20:52:06 <Cale> mattr__: Which paper?
20:52:37 <mattr__> Cale, "First-class Polymorphism with Type Inference"
20:53:27 <mattr__> Cale, I am trying to understand how to type higher-order polymorphism
20:53:34 <mattr__> so i am working through that paper
20:53:40 <Cale> mattr__: That code is supposed to work.
20:53:57 <mattr__> and that code is given as an example of higher-order polymorphism
20:54:16 <mattr__> so I thought I would bung it in haskell98 (which does not have higher order poly, right?)
20:54:22 <mattr__> and see what errors I got
20:54:28 <mattr__> I am still fairly new to this
20:54:33 <Cale> oh, you didn't copy the code exactly
20:54:38 <mattr__> so I am probably just missing something obvious
20:54:42 <Cale> You added the parameters a and b
20:54:45 <mattr__> yeah - I added the type params
20:54:51 <Cale> which defeats the whole point
20:54:56 <mattr__> but the paper says they are implicit front-most universals
20:55:03 <Cale> yeah
20:55:05 <mattr__> which is what adding them does, isn't it?
20:55:09 <Cale> So what you really want is:
20:55:29 <Cale> data Monad m = forall a b. MkMonad (a -> m a) (m a -> (a -> m b) -> m b)
20:55:38 <Cale> (which will also work in GHC)
20:55:50 <dcoutts> then ghc(i) will complain :-)
20:55:57 <dcoutts> because that's no longer H98
20:56:07 <Cale> It'll complain until you add the appropriate extension
20:56:35 <mattr__> so how are `data Monad m a b = ...` and `data Monad m = forall. a b. ...` different?
20:57:08 <mattr__> btw: I am glad you guys are here to point this out or I would have spent all afternoon on the wrong track!
20:57:10 <Cale> In the latter case, a value of type Monad m (which satisfies a few laws) is a witness that m is a monad.
20:57:25 <Cale> and that's all it can be
20:57:51 <Cale> In the case data Monad m a b, you can for example, have things like Monad State Char Integer
20:58:03 <dcoutts> mattr__, one way is to consider the type of the constructor MkMonad
20:58:09 <Cale> Which would not really be enough to turn State into a full monad.
20:58:54 <noecksit_> hello, i am trying to build my package using cabal, however it depends three other files, particularly pics for the gui and a .glade file that i am using
20:58:58 <Cale> (I should probably be using State s or something, but perhaps you get the idea)
20:59:08 <dcoutts> (your version) MkMonad :: forall m a b. (a -> m a) (m a -> (a -> m b) -> m b) -> Monad m a b
20:59:14 <noecksit_> how may i include these files in the instalation?
20:59:25 <mattr__> Cale, I am a little lost, give me 5 mins thinking time and perhaps I will....
20:59:35 <dcoutts> (paper version) MkMonad :: forall m a b. (a -> m a) -> (m a -> (a -> m b) -> m b) -> Monad m
21:00:08 <dcoutts> a and b never appear in the result type, they get swallowed
21:00:30 <dcoutts> noecksit_, extra-data-files: foo.glade
21:01:26 <dcoutts> noecksit_, oops, extra-source-files, or data-files, depending on the purpose
21:01:38 <noecksit_> dcoutts : aha, thanx
21:02:09 <dcoutts> noecksit_, for future reference, check the cabal manual
21:02:38 <Cale> Oh, actually this isn't the type you really want... but I suppose it's the type which the paper would give you anyway.
21:03:31 <mattr__> dcoutts, Cale: I am getting closer to understanding this, thanks for the two good explanations, but I am still not quite there
21:03:33 * ddarius was about to say.
21:03:36 <Cale> What you'd *really* want is: data Monad2 m = Monad2 (forall a. a -> m a) (forall a b. m a -> (a -> m b) -> m b)
21:03:47 <ddarius> Cale: There you go.
21:04:01 <mattr__> the point of Jones's paper is that it allows nested quantifiers, but monad m doesn't use them?
21:04:02 <Cale> But I'm not so sure that works prior to GHC 6.8
21:04:12 <Cale> (I'd have to get 6.6 and test it.)
21:04:27 <mattr__> ah - cale's latest one uses nested
21:04:32 <mattr__> let me ponder that.....
21:05:20 <Cale> That last one just might be what the paper is giving you...
21:05:23 <Cale> I'm not sure.
21:05:36 <Cale> (I'd have to read the paper carefully to know)
21:05:44 <mattr__> Cale, the paper is not clear on that
21:05:52 <mattr__> re-reading it, you might be right
21:06:07 <Cale> oh, yes, that actually is
21:06:14 <mattr__> why is the Monad2 version the one I want?
21:06:25 <Cale> Look on page 23
21:06:26 <Cale> er
21:06:26 <Cale> 2
21:06:29 <Cale> heh
21:06:46 <Cale> C :: forall a. (Q x. τ) -> T a
21:07:01 <mattr__> yep
21:07:02 <Cale> Where Q is some quantifier
21:07:15 <mattr__> in that part he is talking about the power he is about to unlock
21:07:42 <mattr__> the ability to work with nested quantifiers by "moving" them all out the front
21:07:59 <mattr__> so I was expecting all the examples to have these types
21:08:14 <Cale> In particular, if Q is forall, so that you're required to pass the constructor a polymorphic value, then that's exactly the sort of thing which Monad2 is an example of.
21:08:42 <mattr__> I guess MkMonad (a -> m a) (m a -> (a -> m b) -> m b)
21:08:48 <Cale> Unfortunately, the notation he chooses doesn't really make it clear after that point that this is what is meant.
21:09:15 <mattr__> must be MkMonad (forall. a -> m a) (forall. a b. m a -> (a -> m b) -> m b)
21:09:19 <mattr__> when I was reading it as..
21:09:58 <mattr__> forall. a b m. MkMonad (a -> m a ) (m a -> (a -> m b) -> m b)
21:10:18 <mattr__> kinda...
21:10:23 <mattr__> now I see my error!
21:10:26 <Cale> Right, the question is whether  MkMonad :: forall m a b. (a -> m a) -> (m a -> (a -> m b) -> m b) -> Monad m, or is it  MkMonad :: forall m. (forall a. a -> m a) -> (forall a b. m a -> (a -> m b) -> m b) -> Monad m
21:10:39 <Cale> and those are very very different types
21:11:00 <mattr__> I think the paper is unclear in the notation, but the first one is what it must be since that is what he is talking about
21:11:12 <mattr__> and you say that is what you actually need for monads?
21:11:13 <SamB> ???
21:11:19 <Cale> In the first case, for any individual value of type Monad m, we know that there is some a and b which the value was constructed with
21:11:30 <ddarius> Cale: The example makes it clear
21:11:39 <SamB> which first one?
21:11:48 <Cale> But in the second case, the functions passed *must* be polymorphic in a and b
21:11:56 <mattr__> samb the first version of MkMonad :)
21:12:08 <Cale> and this is much more likely what is meant in the paper, since the existential makes no sense
21:12:19 <Cale> MkMonad :: forall m. (forall a. a -> m a) -> (forall a b. m a -> (a -> m b) -> m b) -> Monad m
21:12:25 <Cale> (this is the version which makes sense)
21:12:27 <SamB> I think you guys are each speaking of a different first/second one
21:12:45 <Cale> MkMonad :: forall m a b. (a -> m a) -> (m a -> (a -> m b) -> m b) -> Monad m -- this version does not make sense
21:13:02 <mattr__> cale: you have convinced me
21:13:39 <mattr__> but now I am left wondering *how* the forall. m a b one is wrong
21:13:52 <mattr__> or perhaps I don't need to understand that just now :)
21:14:22 <SamB> mattr__: well, if I hand you a value of that type...
21:14:29 <SamB> I have already chosen "a" and "b"
21:14:38 <SamB> how will that be of any use to you ?
21:15:04 <mattr__> can't you hand me another value if I need different types?
21:15:12 <SamB> no!
21:15:16 <mattr__> why not
21:15:19 <mattr__> ?
21:15:19 <SamB> you only get one per monad!
21:15:27 <mattr__> one value per monad?
21:15:34 <SamB> yes!
21:15:50 <mattr__> hmm, I believe you, but I don't understand why you are right :)
21:16:59 <SamB> oh, besides, I never bothered to tell you which types a and b are!
21:18:28 <mattr__> thinking hard
21:19:09 <SamB> with the other one... *you* may pick whatever a and b you like
21:19:23 <mattr__> on both versions I am stuck with whatever m you give me?
21:19:24 <SamB> I've only picked m (but I told you what it was)
21:20:11 <mattr__> so , Monad m = MkMonad forall. a b. (......
21:20:13 <mattr__> is silly
21:20:28 <mattr__> Monad m a b = MkMonad ...... is not great
21:20:37 <bd_> Are we assuming dependent types here or something?
21:20:43 <mattr__> and Monad m = MkMonad (forall. a ...
21:20:46 <mattr__> is best?
21:21:00 <mattr__> bd_: higher order types
21:21:00 <SamB> bd_: is System F dependantly typed?
21:21:06 <bd_> ah okay
21:21:21 <bd_> SamB: I don't know, I was just thinking that it couldn't possibly work in GHC as is
21:21:42 <mattr__> was my summary accurate?
21:21:46 <SamB> bd_: isn't that how GHC works?
21:21:49 <mattr__> kinda accurate?
21:22:07 <bd_> you'd need a runGenMonad :: GenMonad r -> (forall a. a -> m a) -> (forall a b. m a -> (a -> m b)) -> r
21:22:10 * SamB might be wrong about the part where he told mattr__ what type m was
21:22:10 <bd_> or something
21:22:25 <SamB> yeah, I don't think you need to know what type m is...
21:22:29 <bd_> runGenMonad :: GenMonad r -> (forall a. a -> m a) -> (forall a b. m a -> (a -> m b)) -> (m r -> x) -> x even
21:22:35 <SamB> since you, you know, have the methods right there
21:23:24 <mattr__> samb: then I can right functions that use the monad
21:23:32 <mattr__> but I still don't know which one it is?
21:24:00 <SamB> er, yeah.
21:24:26 <Cale> It will make the monad boring though
21:24:31 <SamB> if you know which it is, you don't need that value anyway, since you can find the methods...
21:24:43 <Cale> Since you'll only have return and bind
21:24:54 <Cale> So it'll be indistinguishable from the identity monad then.
21:25:16 <SamB> Cale: well, look on the bright side
21:25:23 <SamB> at least it doesn't have fail!
21:25:27 <Cale> hehe
21:25:57 <mattr__> so, what is wrong with Monad m a b = MkMonad ....?
21:26:34 <Cale> mattr__: well, if a and b are not polymorphic, you end up with not a complete monad.
21:26:57 <mattr__> I see, when I try to put something useful, I will get a type error
21:27:20 <mattr__> I might be ok for a while, then I will try a particular monad I really want and get told off by the type system
21:27:51 <mattr__> ?
21:28:26 <SamB> mattr__: eh?
21:28:28 <Cale> Well, if you have a value of type  Monad Maybe String Integer
21:28:33 <Cale> then that's not a whole monad
21:28:39 <SamB> if you know the monad already, I can't give you one of those
21:28:45 <Cale> It's just a strange little piece of a monad.
21:29:11 <Cale> You'll have the section of return :: String -> Maybe String
21:29:32 <Cale> and you'll have the section of (>>=) :: Maybe String -> (String -> Maybe Integer) -> Maybe Integer
21:29:39 <Cale> and not the rest of it
21:30:31 <Cale> Worse, there might not even be a natural extension of those functions to a monad, for instance, if the Maybe Integer was constructed by fmap length on the Maybe String that came in as the first parameter
21:30:52 <mattr__> grrr, I am getting lost again
21:30:59 <mattr__> sometimes you guys are the best
21:30:59 <Cale> Okay...
21:31:06 <mattr__> and sometimes I feel silly :)
21:31:10 <Cale> Let's have a look at what a monad really is.
21:31:14 <mattr__> I guess both those times are the same :)
21:31:17 <Cale> It's a type constructor m
21:31:26 <Cale> together with *polymorphic* functions:
21:31:29 <Cale> return :: a -> m a
21:31:40 <Cale> and (>>=) :: m a -> (a -> m b) -> m b
21:31:51 <mattr__> yep
21:31:58 <Cale> So that return has to work for any type a
21:32:06 <Cale> Not just some specific type, like String
21:32:16 <mattr__> right,
21:32:28 <Cale> and this polymorphism restricts how return can be written
21:32:35 <Cale> (and how bind can be written, of course)
21:32:54 <SamB> it's a bit like the type of the old "build" function in GHC.List...
21:33:22 <mattr__> what do you mean by the polymorphism restricts how return can be written?
21:33:24 <Cale> It's quite a lot like that -- that uses this kind of polymorphism as well (though not at the data constructor level)
21:33:45 <Cale> mattr__: Well, consider the monomorphic function:
21:34:02 <Cale> return' x = if x == "hello" then Nothing else Just x
21:34:31 <Cale> There is no polymorphic function return such that at the type String, return x = return' x for all Strings x.
21:35:10 <mattr__> right, because it is polymorphic, it can't inspect it's value
21:35:14 <Cale> right
21:35:15 <mattr__> I get it
21:35:32 <SamB> at least, not unless your monad is the BlackHole monad...
21:35:36 <dolio> Cale: Oh, that reminds me, you suggested that typeable become a compiler primitive, but would a pseudo typeclass Typeable stay around to signal the breach in polymorphism?
21:35:43 <SamB> data BlackHole a = BlackHole
21:35:51 <Cale> This actually has the effect of forcing the type system to verify a bunch of the monad laws (the naturality conditions)
21:36:26 <Cale> dolio: Effectively, yeah.
21:36:27 <SamB> instance Monad BlackHole where return _ = BlackHole; _ >>= _ = BlackHole
21:36:46 <Cale> dolio: Though I thought about it some more and it's possible even that's unnecessary.
21:36:51 <ddarius> SamB: Which isn't a "notion of computation" a la Moggi.
21:36:53 <SamB> that follows the monad laws, does it not?
21:37:00 <ddarius> SamB: It does.
21:37:02 <noecksit_> hello, does the position of keywords in a cabal file matter?
21:37:02 <Cale> dolio: If it was a language feature, you could even make polytypes typeable.
21:37:08 <bd_> SamB: undefined >>= return is not undefined
21:37:14 <SamB> it could hardly break them!
21:37:18 <noecksit_> i keep getting the error that it couldnt find "build-type"
21:37:28 <SamB> bd_: where does that show up in the monad laws?
21:37:34 <noecksit_> unknown field
21:37:37 <bd_> SamB: x >>= return is equivalent to x, right?
21:37:40 <dolio> Cale: Yeah, that could be nice.
21:37:41 <bd_> even is x is _|_
21:37:59 <SamB> well, okay, so add a forcing in >>=
21:38:15 <dolio> I should go read about how Clean does that stuff.
21:38:36 <bd_> SamB: (return []) >>= (\l -> head l `seq` return ())
21:38:46 <dolio> Although apparently the generics section of the report I have is 'to be done'.
21:39:07 <mattr__> dolio: I am keen to see how clean does generics
21:39:15 <bd_> SamB: since return x >>= y  === y x, we should have this become head [] `seq` return (), which is undefined.
21:39:30 <mattr__> cale: where were we....?
21:39:35 <SamB> it would have been a monad had I written it in a total language!
21:39:37 <bd_> SamB: since we actually have a data dependency here though, your blackhole monad really does need to pass values around :)
21:39:53 <bd_> SamB: total languages cannot be turing complete, as nontermination is the bottom as well
21:40:13 <SamB> so?
21:40:37 <bd_> Well, if you're okay with that, then you can indeed have a blackhole monad in a non-turing complete language :)
21:41:33 <Cale> mattr__: So while it does *sort of* work to have  data Monad m a b,  in the sense that this is a more general type constructor than you need, it doesn't *quite* express things as closely as you'd hope for.
21:41:34 <dolio> Languages that are only turing complete through a monadic sublanguage are the future. :)
21:41:58 <mattr__> cale: I think you have filled in enough gaps for me to move forward
21:42:04 <SamB> Cale: sometimes you need a specific type, not a general one ;-)
21:42:09 <SamB> sometimes the reverse
21:42:09 <mattr__> you are today's hero I think :)
21:42:20 <SamB> this exemplifies BOTH
21:42:44 <mattr__> how do people work this stuff out when they don't have Cales around to help?
21:42:51 <ddarius> Read.
21:43:03 <Cale> Find Cales?
21:43:18 <mattr__> ddarius: cheeky :)
21:43:44 <mattr__> ddarius: it was reading that got me in this mess :)
21:43:48 <SamB> play with --dump-iface? read the GHC manual? read lots of papers?
21:43:58 <SamB> read the GHC sources?
21:44:05 <ddarius> mattr__: And reading will get you out of it (though then into bigger messes)
21:44:16 <mattr__> :)
21:44:22 <ddarius> SamB: Yes.
21:44:33 <ddarius> In whatever proportions you desire.
21:44:40 <SamB> mattr__: yes, maybe you'll end up trying to plug giant holes in Jhc, for instance
21:44:43 <noecksit_> hello, would it be possible for someone to add me to hackage.haskell.org with username & password?
21:45:12 <ddarius> http://hackage.haskell.org/packages/accounts.html
21:45:13 <lambdabot> Title: HackageDB: User accounts
21:45:22 <mattr__> jhc?
21:45:35 <SamB> mattr__: a somewhat holey Haskell compiler
21:45:43 <dolio> Clean's dynamics do seem nicer than Data.Dynamic from the overview.
21:45:52 <mattr__> where is it from?
21:45:53 <noecksit_> yeah, im looking at it, i need to send an email? would it take a long time?
21:45:54 <dolio> Assuming I understand the latter.
21:46:32 <mattr__> is data.dynamic the work of the data-type generic folk or is it older than that?
21:47:11 <gwern> dolio: as far as I know, Data.Dynamic is just a pussy sort of type thing, while clean's dynamics are the awesome seralize-functions-to-disk stuff, along with the pussy sort of type thing for reading the serializations back in
21:47:36 <SamB> grrr
21:47:37 <ddarius> mattr__: When you read the first sentence of this: http://mekentosj.com/papers/ and laugh, then you may have started reading enough.
21:47:38 <lambdabot> Title: mekentosj.com | Introducing Papers... Your personal library of science
21:47:50 <SamB> what debian package is supposed to provide the sendmail command...
21:47:57 <ddarius> dolio: They damn well better be.
21:48:16 <dolio> gwern: Well, yeah, Data.Dynamic is an attempt to add dynamics without adding compiler support (other than the deriving in GHC, I guess).
21:48:22 <mattr__> ddarius: thanks to bibdesk, I am past that particular mire :)
21:48:43 <mattr__> 110 fully annotated papers and counting
21:48:43 <ddarius> mattr__: I'm specifically referring to the "dozens"
21:48:57 <mattr__> ha!
21:49:00 <mattr__> now I see
21:49:09 <ddarius> mattr__: I'm at around 2000
21:49:11 <mattr__> cale fried my brain :)
21:49:18 <mattr__> 2000 - well that explains it!
21:49:34 <gwern> dolio: Data.Dynamic is fail then. I WANT MAH SERIALIZATIONS
21:49:53 <mattr__> gwern: write them
21:49:58 <mattr__> they are really easy
21:50:12 <gwern> mattr__: of arbitrary functions? not really
21:50:18 <mattr__> I believe johan juering has a paper with heaps of examples
21:50:22 <mattr__> of functions?
21:50:27 <mattr__> ah, that might be harder
21:50:45 <ddarius> gwern: Clean's Dynamics can handle polymorphism as well
21:51:23 <gwern> ddarius: you're not helping here -_-
21:51:32 <dolio> gwern: Yeah. For instance, someone was in here yesterday asking how they could take two dynamics and put them in an existential like: 'data Foo = forall a. Foo a (Bar a)', and I don't think there's a nice way to do that with Data.Dynamic.
21:52:01 <ddarius> gwern: Well I hear tell of a Haskell (98) frontend for the Clean compiler so such things may well be supported via that.
21:52:11 <SamB> there aren't really nice ways to do much of anything with Data.Dynamic unless you have a guess about the type of the thing inside...
21:52:27 <dolio> Yeah, that was my advice.
21:52:42 <dolio> Try casting them to all the types you might receive, and build it case by case.
21:52:51 <dolio> Which sucks, but that's about all you get.
21:53:29 <dolio> ddarius: ls **/*.pdf | wc -l => 689  Apparently I'm a lightweight.
21:53:33 <gwern> ddarius: if I'm gonna use the clean compiler, I might as well just program in Clean directly and get the better performance
21:53:55 <ddarius> gwern: You'd still get the better performance using the Haskell front-end.
21:54:13 <ddarius> dolio: Do you have ps to?
21:54:22 <ddarius> +o
21:54:46 <dolio> ddarius: Not many. I usually run ps2pdf, because my postscript reader (the KDE one) sucks.
21:55:04 <ddarius> dolio: I am (now) a big fan of evince.
21:56:22 <SamB> oh, apparantly /var was just full, sendmail wasn't missing or anything...
21:56:36 * SamB cleaned the apt cache out to fix this
21:59:13 * ddarius goes back to reading a paper that uses the word "fireball" repeatedly.
22:00:38 <SamB> can someone explain to me the type error here?
22:00:41 <SamB> Instance@.iControl.Arrow.+++.Control.Arrow.Kleisli :: Π(f0∷* → *).∀a.∀b.∀c.∀d.Control.Arrow.Kleisli f0 a b → Control.Arrow.Kleisli f0 c d → Control.Arrow.Kleisli f0 (Prelude.Either a c) (Prelude.Either b d)
22:00:41 <SamB> Instance@.iControl.Arrow.+++.Control.Arrow.Kleisli = λ(f0∷* → *).Λa.Λb.Λc.Λd.λ(Control.Arrow.251_f∷Control.Arrow.Kleisli f0 a b).λ(Control.Arrow.252_g∷Control.Arrow
22:01:04 <ddarius> "However, the reasons for simulating explosions, combustion, detonation, and supersonic flow in engineering differ significantly from those in computer graphics."
22:01:26 <SamB> oh wait, those aren't both type signatures...
22:06:23 <gwern> (huh. I only have 432 pdfs)
22:08:22 <gwern> well, night
22:18:06 <tharinduj> hi
22:20:41 <gwern> @seen igel
22:20:41 <lambdabot> I saw igel leaving #haskell and #gentoo-haskell 1d 7h 43m 19s ago, and .
22:40:21 <mattr__> what is the current best way to get a recent ghc version of PPC leopard?
22:40:47 <mattr__> the best I can manage so far is 6.4.1
22:40:58 <mattr__> which is not good enough to compile the code I have :(
22:43:26 <dons> mattr__: there's ghc ports to ppc/recent mac osx
22:43:28 <dons> does that help?
22:43:55 <mattr__> you mean use `ports install`?
22:44:05 <mattr__> sorry `port install`
22:46:14 <dcoutts> dons, is your blogging software available? it's the system based on darcs right?
22:46:19 <mattr__> last time I tried that it didn't work and the port file hasn't been updated since I last tried
22:46:53 <dons> dcoutts: its  just blosxom and darcs
22:46:56 <dons> no custom software
22:46:59 <mattr__> ghc downloads page only has PPC/tiger and Intel/Lepoard
22:47:02 <dons> and i'd probably look for something else now
22:47:14 <dons> blosxom's a bit old fashioned
22:47:36 <dons> mattr__: hmm, for 6.8.2 ?
22:47:47 <mattr__> well, any 6.6+
22:47:51 <dcoutts> dons, I guess I'm looking for something that uses static html+css on the server side
22:47:56 <mattr__> but I suspect only 6.8.2 2 will do
22:48:03 <dons> mattr__: there's was a recent 6.8.2 announcement for ppc/mac os x
22:48:07 <mattr__> the trac site tells me there is a fix in head
22:48:08 <dons> maybe check the mailing list arcvhies
22:48:13 <mattr__> ooh - that is what I need
22:48:14 <dons> dcoutts: ok. well blosxom does
22:48:17 <mattr__> will do
22:48:19 <mattr__> thanks
22:49:00 <dcoutts> dons, so what would you pick if you were choosing now?
22:49:14 <hpaste>  dibblego pasted "what does this compile-error mean?" at http://hpaste.org/6724
22:50:19 * SamB wonders why he has MetaVars left over after type inference...
22:50:20 <shachaf> dibblego: Just what it says?
22:50:29 * SamB goes to bed...
22:50:34 <dibblego> shachaf, complaining about the use of String instead of [Char]?
22:50:46 <dibblego> if I change it to [Char], I get the same message
22:51:13 <Nafai> Is there a decent interface to sqlite from Haskell?
22:51:32 <shachaf> Well, -XTypeSynonymInstances will work.
22:51:37 <mattr__> nafai: only the generic sql bindings
22:51:43 <shachaf> Otherwise you'll probably need -XFlexibleInstances.
22:51:48 <dibblego> shachaf, but I don't understand why it is complaining; what's wrong with using [Char]?
22:51:51 <mattr__> I think most of them support sqlite
22:51:52 <bd_> dibblego: No, there's a slightly different error with [Char]
22:52:04 <dibblego> bd_, there is, thanks; I hadn't noticed
22:52:16 <shachaf> dibblego: "(All instance types must be of the form (T a1 ... an) where a1 ... an are distinct type *variables*"
22:52:29 <shachaf> dibblego: Char is not a variable.
22:52:33 <dons> dcoutts: hmm. not sure. probably one of the online systems
22:52:44 * Nafai looks for the sql bindings
22:52:57 * dcoutts doesn't trust anything written in php
22:53:16 <dibblego> shachaf, are you saying it's not possible to provide an instance for [Char] with H98?
22:53:56 <shachaf> That does seem a bit odd, since Strings have their own Show instance, after all.
22:53:59 <shachaf> @where report
22:53:59 <lambdabot> http://www.haskell.org/onlinereport/
22:54:08 <mattr__> dons: how long ago did you see the post, was it on haskell-cafe?
22:54:16 <dcoutts> dons, we used WordPress for gtk2hs, but it gets so many security problems and is a pita to upgrade if you've got any customization
22:54:38 <dons> hmm, i wonder if there's some nice hosted one, that you don't have to maintain
22:54:44 <dcoutts> dons, I think such problems are inherent with any php system
22:54:50 <dons> yep
22:55:08 <Cale> :t showList
22:55:11 <lambdabot> forall a. (Show a) => [a] -> String -> String
22:55:23 <Cale> That's a method of the Show class.
22:55:24 <dibblego> ?instances Show
22:55:24 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
22:55:34 <Cale> So you can override the behaviour for lists.
22:55:40 <Cale> (which is what H98 does)
22:55:59 <shachaf> Oh.
22:56:09 <shachaf> That's a bit cheating, isn't it?
22:56:16 <Cale> yes, but it works
22:56:38 <shachaf> Sure, but not for my own data List a.
22:56:45 <Cale> right
22:59:45 <dibblego> cheers
23:01:18 <mattr__> Nafai: http://www.nabble.com/How-to-program-with-sqlite--to16221380.html
23:01:19 <lambdabot> Title: Nabble - How to program with sqlite?
23:02:31 <Nafai> mattr__: Thanks!
23:06:10 <Jedai> shachaf: Couldn't you use the same trick with another typeclass ? Kindof MyShow, with a showMyList method and then instance (MyShow a) => Show (List a) where show = showMyList ?
23:06:22 <shachaf> Jedai: Sure, you could.
23:06:29 <shachaf> Jedai: But it won't be the regular Show.
23:06:48 <shachaf> Jedai: Which is much more standard than the regular list.
23:07:28 <shachaf> Oh, hmm.
23:07:57 <shachaf> Sorry, I didn't finish reading. :-)
23:08:01 <shachaf> Would that work?
23:08:33 <Jedai> Well, you would have Show instance for all the list of a where a is an instance of MyShow
23:09:00 <Jedai> Which means you wouldn't have a show automatically but that would be better than nothing
23:10:43 <Jedai> Another idea would be to use showList in the show of your instance Show (List a), is it possible (can you do a conversion from your List to one or more than one list ?)
23:11:04 <Jedai> It's a generalized List version with ordinal, isn't it ?
23:12:16 <shachaf> Jedai: If I have a List.
23:12:24 <shachaf> Jedai: But this could be for a lot of types.
23:14:32 <Jedai> shachaf: You can generate the code for all the normal types, and for a user defined type, the user only has to define an instance of MyShow for his type
23:15:23 <Jedai> On the other hand, how do you show you List anyway ?
23:46:02 <luqui_> > map (take 10) $ mfix (\x -> [0:x,1:x])
23:46:04 <lambdabot>  [[0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,1,1,1]]
23:46:11 <luqui_> I don't understand that one bit
23:47:34 <bd_> hm, shouldn't that be an infinite type?
23:47:37 <bd_> oh, mfix
23:47:43 <bd_> :t mfix (\x -> [0:x, 1:x])
23:47:44 <lambdabot> forall t. (Num t) => [[t]]
23:47:55 <bd_> hm
23:47:55 <allbery_b> made sense to me
23:48:14 <allbery_b> (which surprises me a bit)
23:48:52 <dolio> Apparently the fixpoint of a nondeterministic computation is the nondeterministic choice between the fixpoint of each branch.
23:48:54 <dolio> Or something like that.
23:52:35 <allbery_b> I don't see any nondeterminism there
23:53:16 <dolio> You can look at lists as nondeterministic computation.
23:53:18 <allbery_b> as long as every element follows the head-must-reduce rule, doesn;'t matter if you build a list, a tuple, a Data.Map, ...
23:53:24 <dolio> With the result being a list of the successes.
23:54:33 <dolio> Or, the list monad, I suppose.
23:55:19 <dolio> From the inside 'do x <- l ; ...' looks like one x is selected nondeterministically from many possibilities l.
23:56:34 <allbery_b> hm, I was assuming no monad involved (although I guess mfix does assume a monad(
23:56:38 <bd_> > [[],[]] >>= \x -> [0:x,1:x]
23:56:39 <lambdabot>  [[0],[1],[0],[1]]
23:56:55 <bd_> > [[],[]] >>= \x -> [0:x,1:x] >>= \x -> [0:x,1:x]
23:56:56 <lambdabot>  [[0,0],[1,0],[0,1],[1,1],[0,0],[1,0],[0,1],[1,1]]
23:57:08 <bd_> > [[],[]] >>= \x -> [0:x,1:x] >>= \x -> [0:x,1:x] >>= \x -> [0:x,1:x]
23:57:08 <lambdabot>  [[0,0,0],[1,0,0],[0,1,0],[1,1,0],[0,0,1],[1,0,1],[0,1,1],[1,1,1],[0,0,0],[1,...
23:57:11 <bd_> hmm
23:57:27 <dolio> > mdo x <- [0:x, 1:x] ; return x
23:57:27 <lambdabot>  Parse error at "<-" (column 7)
23:57:46 <allbery_b> no mdo in @run
23:57:55 <dolio> Yeah, yeah. @run is no fun. :)
23:59:43 <dolio> > [ (x,y) | x <- [1..10] | y <- [11..20] ]
23:59:43 <lambdabot>  Parse error at "|" (column 24)
23:59:58 <dolio> Doesn't let you do any fun stuff.
