00:00:05 <solrize_> works!  thanks
00:00:11 <Cale> :)
00:00:27 <solrize_> is there a way to read n bytes from a file handle?  system.io doesn't describe one except with foreign pointers
00:00:28 <boyscared> like with (+), which needs an instance for a particular type...
00:00:40 <Cale> boyscared: In contrast to that, with typeclasses, the decision as to which type to use can be deferred to the caller's type.
00:00:51 <Cale> For example:
00:00:57 <Cale> :t let double x = x + x in double
00:00:58 <lambdabot> forall a. (Num a) => a -> a
00:01:13 <Cale> So now double is a polymorphic function as well.
00:01:40 <Cale> With ad-hoc polymorphism, the type of + would have to be fixed at the call-sit.e
00:01:54 <Cale> s/.e/e./
00:02:43 <boyscared> i think i need more type theory study... but, thanks, that helps
00:02:57 <Cale> At least, that's according to my own view of things.
00:03:14 <Cale> I'm not sure ad-hoc polymorphism actually has a real formal definition.
00:03:25 <Cale> (that's more widely accepted)
00:03:53 <boyscared> this seems to kinda differ with what i learned so far today, but that might be because i learned it wrong
00:04:17 <solrize_> is there something like ByteString for unicode?
00:04:56 <Cale> boyscared: A lot of people refer to typeclass polymorphism as ad-hoc polymorphism because the title of the paper introducing typeclasses was titled "How to make ad-hoc polymorphism less ad-hoc."
00:05:23 <boyscared> according to this: http://en.wikipedia.org/wiki/Type_polymorphism#Ad-hoc_polymorphism
00:05:24 <lambdabot> http://tinyurl.com/ywzw7f
00:05:29 <Cale> But the solution is different enough from typical ad-hoc polymorphism that I think it's confusing to glom them together under the same name.
00:05:46 <boyscared> that seems to say type classes are ad-hoc
00:05:55 <hpaste>  calvins annotated "A question of types" with "Simplified type question" at http://hpaste.org/6406#a1
00:06:21 <Cale> Oh, I thought I fixed that error.
00:08:05 <dmwit> :t fromIntegral
00:08:06 <lambdabot> forall a b. (Num b, Integral a) => a -> b
00:08:21 <dmwit> :t fromRational
00:08:21 <lambdabot> forall a. (Fractional a) => Rational -> a
00:08:43 <dmwit> :t toInteger
00:08:44 <lambdabot> forall a. (Integral a) => a -> Integer
00:08:59 <dmwit> calvins: Not really.
00:09:30 <dmwit> calvins: You'll have to write one that potentially upcasts the first argument, and one that potentially upcasts the second argument.
00:09:44 <calvins> dmwit: you mean two different functions?
00:10:01 <Cale> I really wish they hadn't named the paper that.
00:10:03 <dmwit> calvins: Alternatively, you can define a class that defines a new function "mult" and flesh it out.
00:10:09 <dmwit> calvins: Right.
00:10:17 <calvins> yeah, i though of defining a new class, but really didn't want to do that
00:10:30 <calvins> is there no way to do it with one function and without a new type class?
00:10:36 <dmwit> correct
00:10:39 <Cale> It's a clever title, but something like "A system for restricted parametric polymorphism" would have caused a whole lot less confusion.
00:10:57 <boyscared> all of wadler's paper titles apparently have to be amusingly titled
00:11:02 <dmwit> calvins: Although the class should not be too bad; two instances would be enough to handle everything you have there.
00:12:09 <Cale> boyscared: Any value of type, say, Eq a => ...a... could be reflected in a system without typeclasses (or any form of ad-hoc polymorphism at all) with a type like (a -> a -> Bool) -> ...a...
00:12:44 <Cale> boyscared: In general, you could just pass around tuples consisting of the class methods.
00:12:52 <calvins> dmwit: can you state how you know it won't work? what the technical issue is?
00:13:05 <Cale> boyscared: and all you need is ordinary parametric polymorphism
00:13:19 <calvins> the best I got through experimentation was always returning a list of floating, even when the two real types were integral
00:13:25 <dmwit> calvins: The technical issue is that the Floating/Integral classes do not provide enough functions to convert between them.
00:13:36 <calvins> but obviously I'd like integral output in that case
00:15:18 <calvins> damn, i thought there would be some ghc extension -ftype-magic that would work
00:19:10 * Cale looks at calvin's problem
00:19:49 <Cale> Yes, it's possible
00:20:15 <dmwit> !
00:20:24 <Cale> Just make a 3-parameter typeclass with a functional dependency.
00:20:30 <dmwit> Oh, yeah.
00:20:45 <Cale> class Times a b c | a b -> c where
00:20:53 <dmwit> That's what I suggested, too, though with less detail. =)
00:20:55 <Cale>    times :: a -> [b] -> [c]
00:21:22 <dmwit> or even times :: a -> b -> c
00:21:26 <boyscared> Pierce's "Types and Programming Languages" seems to have little to say about type classes
00:21:26 <Cale> sure
00:21:31 <calvins> Yeah, I'm in the process now of making "class (Real a, Real b, Real c) => Mult a b c where ...", how is that different from what you suggested cale?
00:21:50 <calvins> haven't seen functional dependencies before
00:21:57 <boyscared> maybe that's in advanced topics :\
00:22:07 <calvins> does your suggestion provide something additionally to my simple 3-param type class?
00:22:28 <Cale> calvins: It allows the compiler to infer the result type.
00:23:16 <calvins> hmmm, that sounds very promising; guess I will look and see what functional dependencies are
00:23:31 <Cale> a b -> c just means that a and b completely determine c
00:23:34 <Cale> (together)
00:23:56 <Cale> So that for any given pair (a,b) of types, there can be only one instance Times a b c
00:24:13 <Cale> and the compiler is allowed to infer c when it finds that instance
00:24:43 <dmwit> > 10 ^ 7 :: Int
00:24:44 <lambdabot>  10000000
00:25:11 <dmwit> > (10 ^ 7 * 4) `div` (2 ^ 20)
00:25:12 <lambdabot>  38
00:25:22 <calvins> so does that mean that I would have to define fewer instances? where currently i'm having to define "Float -> Float -> Float", "Float -> Int -> Float", ad nauseum
00:25:24 <dmwit> That's not too bad.
00:25:38 <dmwit> It should.
00:25:49 <Cale> No, it would just mean that when you go to use the instances, you need fewer explicit type signatures.
00:25:51 <dmwit> For example, you could define (Integral a) => a -> Float -> Float.
00:26:19 <dmwit> Or even (Integral a, Floating b) => a -> b -> b.
00:26:24 <Cale> Oh, you could use Overlapping instances to do that...
00:26:34 <Cale> or... well, one of those extensions
00:26:49 <dmwit> Would you even need overlapping instances?
00:27:01 <dmwit> Oh, the compiler doesn't know if something could be both Integral and Floating, huh?
00:27:08 <Cale> right
00:27:20 <yitz> just tried cabal install lambdabot. It failed to install plugins.
00:27:23 <Cale> and it doesn't know that Float will never be Integral
00:27:30 <dmwit> yeah
00:27:43 <Cale> yitz: yeah, you need a version of plugins that for whatever reason isn't on hackage
00:28:03 <Cale> http://code.haskell.org/~dons/code/hs-plugins/
00:28:03 <lambdabot> Title: Index of /~dons/code/hs-plugins
00:28:09 <Cale> that one :)
00:28:10 <calvins> is there a way to define an instance that takes two floating args, possibly different, and returns the appropriate floating arg? So a float and a double would return a double, but two floats would return a float
00:28:13 <yitz> Cale: tnx
00:28:45 <Cale> calvins: Well, it might not be just one instance...
00:28:49 <calvins> without defining all permutations
00:28:56 <Cale> I don't think so, no.
00:29:22 <calvins> okay, i'll hack up something ugly and then come back and see if y'all have any suggestions
00:29:38 <Cale> calvins: Are you sure that you need this kind of polymorphism?
00:29:51 <Cale> calvins: What's wrong with doing explicit numeric conversions?
00:31:06 <yitz> Cale: the lambdabot package should depend on the right version of plugins.
00:31:16 <Cale> yitz: that's true.
00:31:40 <calvins> Cale: the problem is that i want a single function to be able to handle either arg being integral or floating and return floating unless both args are integral
00:31:52 <yitz> also - plugins needs a darcs tag. leave a msg for dons on these issues?
00:32:45 <dmwit> At some point, you have to ask yourself which is more painful: explicit conversions, or all the instances for the typeclass you would need to eliminate explicit conversions.
00:33:41 <calvins> dmwit: yeah, but i'd rather a bit of pain up front and then have the function be much easier to use each time via just adding the appropriate type signature, rather than forcing conversion every time it's used
00:33:44 <Cale> calvins: Why not just force all the types to be the same, and then convert some of the input types beforehand...
00:33:59 <calvins> Cale: then i'd have to force everything to float
00:34:05 <calvins> to floating, i mean,
00:34:19 <Cale> Unless they were both integral, or both floating point...
00:34:26 <calvins> and wouldn't be able to have nice integral result types when i'm only dealing with integral types
00:34:29 <Cale> Well, and the same :)
00:34:34 <Cale> For instance
00:34:38 <calvins> yeah, but i want to be able to use one of each
00:34:47 <Cale> times :: Num a => a -> [a] -> [a]
00:34:53 <Cale> so you'd have
00:35:02 <Cale> times :: Int -> [Int] -> [Int]
00:35:08 <Cale> times :: Integer -> [Integer] -> [Integer]
00:35:11 <Cale> and so on
00:35:39 <Cale> you'd only ever have to convert one of the parameters, unless you wanted the result to be different from either of the input types
00:35:52 <dmwit> (The advantage of this approach is that the "times" Cale is describing is *very* easy to write. ;-)
00:36:16 <calvins> so how would I be albe to do "times (1::Int) [1.0]"?
00:36:31 <dmwit> times (fromIntegral 1) [1.0]
00:36:38 <Cale> times (fromIntegral (1::Int)) [1.0]
00:37:17 <dmwit> ?pl \x -> zip x (tail x)
00:37:17 <lambdabot> ap zip tail
00:37:26 <dmwit> bwuh
00:37:30 <dmwit> :t ap
00:37:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:37:44 <dmwit> oh
00:37:46 <dmwit> neat!
00:37:48 <Cale> (e -> a -> b) -> (e -> a) -> e -> b
00:39:11 <pjd> :t zip <*> tail
00:39:12 <lambdabot> forall b. [b] -> [(b, b)]
00:39:23 <dmwit> :t (<*)
00:39:24 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
00:39:33 <dmwit> :t (<$>)
00:39:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
00:39:58 <dmwit> (<$>) = fmap?
00:40:02 <pjd> yep
00:40:09 <dmwit> I guess there's not so many functions with that type. =P
00:40:39 <pjd> (<*>) = ap
00:40:40 <pjd> (but more general)
00:40:46 <dmwit> oh
00:40:52 <dmwit> Yeah, okay.
00:40:55 <pjd> :t (<*>)
00:40:55 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
00:41:20 <calvins> hmmm, i don't like Cale's suggestion, because then if given a Float and [Integer], i have to map fromIntegral over the list, which seems like too much hassle for the client of the function
00:42:00 <calvins> i'd really like them to be able to pass whatever and "just have it work", so I guess I'm back to the type class solution with lots of instances.
00:45:06 <Cale> calvins: I suppose. It's what everybody does though.
00:45:21 <Cale> calvins: Numeric conversions are not usually something to be taken lightly like that.
00:45:47 <Cale> You can seriously break things by converting Integer to Float, for instance.
00:46:02 <Cale> (you get strange rounding)
00:46:28 <calvins> yeah, that's true, safer to keep it all integral whenever possible
00:47:20 <yitz_> Cale: oof. darcs version of plugins is not installing, it's confused about what Cabal modules to use.
00:47:36 <Cale> yitz_: Yeah, I've only tried it with 1.2.3.0
00:47:49 <Cale> (which is what comes with 6.8.2)
00:48:55 <yitz_> I guess this will have to wait until dons wakes up.
00:49:43 <yitz_> @seen dons
00:49:43 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 1702398823
00:49:50 <yitz_> hmm.
01:00:02 <dons> nice xmonad review, http://dev.compiz-fusion.org/~wfarr/viewpost?id=5 :)
01:00:03 <lambdabot> Title: wfarr : See You Later wmii. Why, Hello There xmonad!
01:00:22 <dmwit> On compiz-fusion.org?
01:00:42 <dons> yeah! woot.
01:01:50 <dmwit> "The modules are perhaps the best bit of documentation I've seen in any code, ever."
01:01:52 <dmwit> nice!
01:02:11 <dons> yay haddock.
01:02:46 <solrize_> cool
01:02:47 <yitz> hey dons, I tried installing lambdabot. no go.
01:03:06 <dons> hey yitz. maybe talk to Cale, he's the maintainer now. fwiw, i built it from source yesterday ok.
01:03:22 <dons> are you using hs-plugins from code.haskell.org ?
01:03:27 <yitz> trying to. it won't build.
01:03:31 <solrize_> do you need an enormous screen to use xmonad?  i don't think i could live w/o overlapping windows
01:03:31 <Cale> hehe
01:03:41 <dons> "I've never had to restart it for anything but user error "
01:03:53 <dmwit> solrize_: nah
01:03:53 <dons> solrize_: i use it on 1024x768
01:03:54 <solrize_> hmm
01:03:57 <dmwit> solrize_: I use it on my laptop (1024x768) all the time.
01:04:26 <dons> tiling really comes into its own on large screens, on small ones, you can use overlapping (i.e. fullscreen, or partially tiled) to keep the screen filled
01:04:37 <solrize_> xmonad supports overlapping?
01:04:40 <dons> yeah
01:04:55 <solrize_> oh cool!
01:04:58 <dons> 'full' for example, is good on laptops
01:05:09 <solrize_> it's advertised as a tiling wm, so i stayed away from it because i figured it couldn't overlap
01:05:10 <dons> you get the fullscreen clients on each workspace
01:05:28 <solrize_> i typically have two xterms, a browser and irc or something open
01:05:34 <dons> oh, perhaps check the screenshots, for an idea of how it works, http://haskell.org/haskellwiki/Xmonad/Screenshots
01:05:35 <lambdabot> Title: Xmonad/Screenshots - HaskellWiki
01:05:35 <unenough> how do i get only the latest version from a remote darcs repo?
01:05:36 <solrize_> and they won't all fit on the screen w/o overlap
01:05:50 <dmwit> unenough: darcs pull
01:05:54 <unenough> thx
01:05:58 <dons> solrize_: right, so you'd put the browser on workspace 2, irc on 3, and maybe split your terms 50/50 horinzontally
01:06:02 <dmwit> unenough: Unless you've never "darcs get"ed, in which case use that.
01:06:18 <unenough> ah, that was exactly what i'm trying to avoid!
01:06:27 <yitz> darcs get --partial
01:06:29 <dmwit> darcs get --partial
01:06:50 <unenough> i tried that already, it's still very very slow
01:06:52 <dmwit> That will try to get it, but with a smaller history.
01:06:54 <solrize_> workspace, you mean flip back and forth between virtual screens?  i like to be able to see them all simultaneously
01:07:05 <solrize_> hmm which of those screen shots shows overlap?
01:07:12 <dmwit> unenough: Oh, the repository you're pulling from may be experiencing the dreaded exponential merger problem.
01:07:13 <unenough> i just want a COPY of the latest version
01:07:26 <unenough> i don't want ANY patches/history
01:07:33 <dmwit> unenough: You should report the problem to the repository owner and see if they can fix it. =P
01:07:46 <unenough> it's http://darcs.haskell.org/cabal-install/
01:07:48 <lambdabot> Title: Index of /cabal-install
01:07:49 <dmwit> unenough: Well, scp will work for just the code.
01:07:56 <unenough> ok
01:08:20 <dons> or just darcs get --partial it, and hope it was recently tagged
01:08:37 <solrize_> oh ok, the atomb-apple one shows overlap
01:08:41 <solrize_> looks ok
01:08:42 <solrize_> nice
01:08:46 <unenough> show should I tell? it's the cabal-install repository
01:08:58 <unenough> --partial still has about 350 patches
01:09:09 <unenough> 396 to be exact
01:09:20 <dons> that's typical, unenough
01:09:30 <unenough> well, then darcs sucks
01:09:47 <dons> heh. you're checking out a repo. this is how repos work :)
01:09:55 <dons> wait for cabal-install to be released on hackage.
01:09:56 <unenough> dons, not in bzr
01:10:05 <dmwit> darcs trades off the first-access-time for some really nice features, I think.
01:10:12 <unenough> such as?
01:10:16 <solrize_> checking out a repo should pull something like a tarball
01:10:19 <dons> cherry picking, in particular
01:10:27 <unenough> bzr has that
01:10:45 <dons> its not bzr, its fairly different, much more like git, if you know that.
01:11:10 <unenough> i've heard of git but know nothing about it (nor do i do about darcs)
01:11:27 <solrize_> git is supposed to be super fast
01:11:30 <dons> anyway, its good practice in technical forums not to say things suck on day one :)
01:11:53 <dons> darcs is pretty good, which is why its used a fair bit.
01:11:53 <unenough> that is correct ;)
01:12:02 <dmwit> It has really nice merge capabilities, a nicely interactive interface, better than file-level control of commits...
01:12:19 <dmwit> I always miss the last one in other VCSen.
01:12:40 <unenough> but besides being stupid, it does cause people to defend to the point that you don't think it sucks anymore :)
01:12:58 <dmwit> It has a pretty solid patch theory that lets you amend old patches without screwing up the most recent ones, too, that's useful at times.
01:13:40 <dons> yeah, i miss hunk-wise records.
01:13:52 <dmwit> Patch commutativity is pretty neat in a bunch of ways, though most of them come back to really smart cherry-picking.
01:14:04 <unenough> ok, now you got me interested
01:14:17 <dons> undoing a patch: darcs computes the inverse patch and applies that
01:14:43 * pjd pipes up: hg!
01:14:43 <unenough> that's cool - just like a patch theory Peaker and I invented
01:14:46 <dmwit> Because of commutativity, you can (to some extent) undo patches other than the most recent one.
01:15:03 <unenough> probably more mature than ours, though ;)
01:15:05 <scook0> yeah, not so much in my experience :/
01:15:10 <pjd> which has a record extension for darcs-style interactive commits
01:15:12 <dons> there's a nice paper on the patch theory
01:15:12 <dmwit> scook0: Really?
01:15:22 <dmwit> scook0: I've had great luck with it. =P
01:15:36 <dmwit> dons: Oh?  Other than the wiki-book thing?
01:16:10 <solrize_> i saw a .ppt about how darcs uses gadt's to ensure correctness of the patch algebra operations
01:16:14 <scook0> sometimes I wish I could have the features/model of git, with the UI of darcs
01:16:15 <solrize_> that was cool
01:16:25 <unenough> dons, where?
01:16:55 <dons> looking ...
01:17:06 <dons> http://people.cs.uu.nl/andres/VersionControl.html
01:17:07 <lambdabot> Title: A Principled Approach to Version Control
01:17:09 <unenough> every time i walk into #haskell i find that i have been trying to re-invent the wheel ;)
01:17:10 <solrize_> http://groups.google.com/group/fa.haskell/browse_thread/thread/366357eebbccaa91
01:17:12 <lambdabot> Title: Parody of Darcs patch theory from 1981 - fa.haskell | Google Groups, http://tinyurl.com/2ofqmm
01:17:35 <dons> most ideas have a phd student attached to them somewhere
01:17:50 <dons> you should expect that someone's thought about it, and written two papers on the topic
01:18:12 <dmwit> ?remember dons most ideas have a phd student attached to them somewhere
01:18:12 <lambdabot> It is stored.
01:19:48 <unenough> dons, i guess i did expect that but never knew the terminology used to even know where to look
01:19:59 <unenough> we called it "delta arithmetic"
01:20:30 <unenough> but i'm pretty sure it was in a different direction
01:21:47 <yitz> unenough: darcs patch theory was inspired by quantum mechanics (commuting/non-commuting operators...)
01:21:52 <unenough> the delta-arithmetic idea is to represent semantic changes, not changes in representations
01:22:09 <TSC> How can I force evaluation of a Data.Map map?
01:22:27 <yitz> TSC: insertWith'
01:22:28 <unenough> as in, a delta (or patch) would represent "add item to list" rather than "this blob of binary has changed"
01:22:31 <TSC> Ah, thanks
01:23:17 <redleafgr> is there a standard way to compose a unary and binary function? ie. I want to express something like (+1) . flip const (in order to dump the first argument, and increment the second)
01:23:34 <yitz> redleafgr: (.).(.)
01:24:01 <yitz> :t (.).(.)
01:24:02 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
01:24:04 <pjd> a.k.a. dot, or (.:)
01:24:42 <pjd> you can stack it any number of times;  (.).(.).(.) composes a unary and trinary function, and so on
01:24:50 <yitz> (.).(.) :: (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
01:24:51 <redleafgr> damn, nice
01:24:52 <redleafgr> thanks
01:25:35 <yitz> there's some other name for it - "owl eyes" or something
01:26:50 <yitz> @seen dons
01:26:52 <dmwit> yitz: I think you misspelled "boobs" there.
01:27:05 <yitz> dmwit: ahem
01:27:11 <lambdabot> Plugin `seen' failed with: too few bytes. Failed reading at byte position 32761
01:27:17 <dons> ah, the @seen state looks corrupted, Cale
01:27:33 <Cale> dons: so I just delete it?
01:27:44 <dons> or darcs revert if its saved.
01:27:53 <dons> it must have got killed at some point, while saving
01:27:56 <Cale> hmm
01:28:03 <dons> try the console version to check
01:28:12 <Cale> Is it okay to run both lambdabots out of the same directory?
01:28:55 <dons> not really, no.
01:29:01 <dons> they'll race to write files
01:29:01 <Cale> ah, that might be it
01:29:15 <dons> i always ran them in separate repos
01:29:20 <Cale> So I should probably just duplicate the whole thing then. Yeah.
01:30:17 <unenough> dons, we weren't so stupid after all. darcs still manages patches at the "symptomatic" level and not at the semantic level (you need a semantic editor or a very smart parser for that)
01:30:40 <unenough> but i'm sure there's a lot to learn about how the conflicts are handled, and the formalization
01:31:11 <yitz> unenough: darcs uses an interactive interface to group changes semantically.
01:31:55 <Cale> @seen Cale
01:31:55 <yitz> @seen lambdabot
01:31:56 <unenough> yitz, but does it can't really understand the semantics of the change
01:32:02 <lambdabot> You are in #ghc and #haskell. I last heard you speak just now.
01:32:08 <lambdabot> Yes, I'm here. I'm in #scala, #darcs, #jhc, #ghc and #haskell
01:32:26 <Cale> @seen lambdabot
01:32:34 <yitz> Cale: #haskell-es?
01:32:34 <lambdabot> Yes, I'm here. I'm in #perl6, #parrot, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #scala, #darcs, #jhc, #ghc and #haskell
01:32:50 <Cale> yitz: lambdabot2 should be joining that
01:33:02 <yitz> @seen lambdabot2
01:33:02 <lambdabot> lambdabot2 is in #gentoo-uy. I don't know when lambdabot2 last spoke.
01:33:12 <Cale> heh
01:33:15 <Cale> whoops :)
01:33:31 <Cale> (they shouldn't both be in it :)
01:34:41 <unenough> i'm guessing darcs can't understand that two changes are non-conflicting because even if they produce different binary results they still have the same semantic meaning
01:35:34 <yitz> Cale: there's a way to promote Haskell. Have lambdabot randomly join other channels.
01:35:40 <dons> i don't know of any semantically aware rcs systems, unenough
01:35:57 <unenough> dons, we are working on one (now taking a break to learn haskell)
01:36:11 <dons> i think it was considered for darcs, with the replace function (replaces tokens, and could be generalised to arbitrary rewriting)
01:37:24 <yitz> unenough: do mean understand file formats, and parse them to see which changes are related?
01:37:31 <unenough> yitz, no
01:37:59 <dmwit> unenough: That's an undecidable problem, so no.
01:38:06 <pjd> dons: token replace is scary
01:38:17 <yitz> unenough: "semantics" means "metadata", really. so where are you getting it?
01:38:30 <unenough> yitz, i mean, that when you edit your list (as an example) by adding an element, the semantic editor will put down that change as a "ListInsertItem" delta (an action really)
01:39:01 <unenough> since you wouldn't be editing text anyway, its' trivial to understand the semantics of the change
01:39:12 <unenough> (i'm talking about a semantic editor)
01:39:18 <yitz> pjd: it's nice, but it makes too many patches not commute anymore.
01:39:48 <yitz> unenough: ah, vc for semantic data?
01:39:56 <unenough> after i'll learn haskell i'll be able to state that in terms of haskell functions
01:40:20 <unenough> yitz, yes, vc for the semantic structure of the code (or anything else that has semantic structure)
01:40:40 <yitz> unenough: like rdf, or n3, or topic maps
01:40:54 <unenough> didn't hear of any of those...enlighten me?
01:41:05 <yitz> semantic web stuff.
01:41:34 <yitz> ways of representing semantics. ontologies, etc.
01:41:43 <unenough> not exactly
01:42:42 <unenough> yitz, like storing the tree/DAG of actions that are performed on some initial ("source") data
01:43:09 <unenough> but the actions are semantic, and are specific to the source data type
01:43:11 <yitz> unenough: you say "vc for the semantic structure of the code". where do you get that semantic structure from?
01:43:27 <unenough> yitz, by editing code in a semantic editor.
01:43:56 <unenough> if i add a new function in the code, the semantic editor adds a new function in the semantic tree it holds
01:44:22 <yitz> the vc know how to parse this tree?
01:44:25 <unenough> and it then appends the "add new function" action to the current vc branch
01:45:34 <unenough> yitz, it doesn't need to parse anything, it's just a set of objects. the vc has the tree of modifications that were performed on the tree, so it can "change" from one version to another by applying (or applying the reverse) of each modification
01:45:38 <yitz> unenough: what if I add a function to the code, and also edit the docs, and 3 other kinds of files. You can't handle that unless all of it is understood by the editor, right?
01:46:13 <yitz> unenough: well, ok, but it could easily be serialized as rdf.
01:46:20 <unenough> yitz, that is correct, it only handles semantic changes that are in its scope. but ultimately the whole system will use that
01:46:47 <unenough> yitz, yes but serialization is really (somewhat trivial) a by-product
01:46:52 <yitz> until you get to that eventuality, the vc is of limited use.
01:47:16 <unenough> yitz, A. i'm working on it, B. even for just code, it would be great
01:48:00 <unenough> the model we conjured isn't good enough though, it needs a re-think
01:49:12 <unenough> there is a problem with high-level changes vs. low-level changes. the vc should be able to group changes on the highest semantic level (eg. "add function"), but somehow also be able to understand the low-level implications ("add item to list")
01:49:27 <yitz> unenough: these semantic things often have trouble beating raw search. semantic web vs. google is kind of like bambi meets godzilla.
01:50:26 <unenough> that's because nobody really uses that stuff
01:50:48 <unenough> but a VC is something that YOU use, you don't need the whole world to support it
01:51:13 <unenough> (and if you'll ask Peaker he'll start going on why google is also to be replaced, but i'm skeptical)
01:52:49 <yitz> it theoretically would be better to have a semantically aware vc. but if you can already semantically group changes into a meaningful patch, tag it with meaningful text, search on that, flexibly re-order, etc. the semantically aware vc is going to have to be really good to beat that.
01:53:49 <yitz> unenough: darcs can output everything in xml, so it might be a good back-end for this. or even write it in Haskell and interface directly.
01:54:55 <unenough> yitz, i don't think it will be hard to beat, once it works. it's the design that's not so simple.
01:55:13 <unenough> and yes, we'll probably write it in haskell eventually, i just started learning haskell yesterday :)
01:56:14 <inimino> unenough: that sounds similar to something I am working on
01:56:32 <unenough> inimino, really? what
01:58:02 <inimino> unenough: it's an editor, but rather than storing a text file it stores the list of actions used to create it
01:58:49 <inimino> I say "list" but once you have undo it becomes a tree
01:58:49 <unenough> a text editor?
01:58:57 <inimino> yes
01:59:17 <unenough> cool, i was thinking of implementing that as an example for the vc once it works
01:59:41 <unenough> but arbitrary text has only semantics of "add/del character","copy","paste"
02:00:01 <unenough> maybe without copy
02:00:22 <inimino> right, unless you add something on top
02:00:34 <inimino> like a parser
02:00:45 <unenough> why not do it the other way round?
02:00:51 <unenough> instead of having to parse
02:01:39 <inimino> I'm doing it that way because I want something I can write e.g. English in
02:01:42 <unenough> you could edit for example, haskell code directly ("add item to list", "define function", "apply function")
02:02:04 <unenough> inimino, ok that makes sense
02:02:39 <inimino> but coming from the other end does have some appeal
02:02:58 <inimino> have you seen subtext?
02:03:06 <unenough> inimino, sure :) that's what started all this
02:03:20 <unenough> Peaker saw it and "had a vision"
02:03:20 <pjd> wooh, subtext
02:03:23 <inimino> ah :-)
02:03:25 <inimino> hehe
02:03:32 <unenough> that was like 3 years ago already
02:04:02 <inimino> I have been working on mine since before that...
02:04:45 <unenough> cool. and also subtext is really cool, even though when i first saw it i wasn't impressed because of the horrible gui and the "toy examples"
02:04:59 <unenough> i didn't realize its consequences
02:05:10 <inimino> right
02:05:49 <unenough> inimino, do you deal with merging?
02:06:12 <unenough> and do you have "scopes" of undo/redo?
02:06:18 <inimino> only in trivial cases
02:06:33 <inimino> scopes?
02:06:40 <unenough> the scope feature is the major problem in our design
02:07:10 <unenough> scope of undo means that you can undo a change "locally" (inside a block) without affecting the rest of history
02:07:25 <inimino> ah
02:08:06 <yitz_> unenough: in other words, you want to be able to decompose a patch into scopes?
02:08:06 <inimino> I would treat that as just applying the inverse of the original action
02:08:10 <unenough> we haven't solved that at all
02:09:05 <inimino> it's best to treat history as immutable
02:09:52 <unenough> inimino, you have to take into account that maybe some other actions have occured outside the scope but AFTER this action you are undoing
02:10:08 <unenough> yitz_, i'm not sure
02:10:28 <unenough> the problem is more in the design and less in theory
02:12:05 <inimino> unenough: if all your actions are invertible, then you can get the effect of local undo without changing history at all
02:12:11 <unenough> i think it boils down to allow the user to undo changes in the same level of groupings that he performed them
02:12:25 <unenough> inimino, all our actions are invertible :)
02:12:39 <inimino> ok :-)
02:13:41 <inimino> so you can just extend the current branch as though the user manually undid those changes
02:13:49 <unenough> we have a "arithmetic" of changes that's pretty cool. d1 + d2 = d = applying action d1 and then d2. -d = (-d2) + (-d1)
02:14:12 <unenough> but that's just syntax
02:14:13 <inimino> cool.
02:14:40 <inimino> it's just a convenience feature, yes
02:16:29 <unenough> the cool part is that d1 + (-d1) = 0
02:18:33 <inimino> have you written anything up yet?
02:19:37 <unenough> yes, we had a couple of re-writes even, but now we are pausing to learn haskell because we are approaching stuff that resembles a functional language
02:19:59 <inimino> ok
02:20:30 <unenough> for example, a change on a list "add item to list" could be seen as a simple the cons function
02:20:50 <unenough> a simple/simply
02:21:53 <inimino> are you going to support an existing language or something else?
02:30:48 <unenough> unenough, our demo is C, we were going to do c#/java for popularity, but now maybe we'll switch to haskell
02:31:05 <unenough> oops inimino not unenough :)
02:31:35 <unenough> the project is still in infancy
02:32:33 <araujo> Haskell is also popular!! ... among the cool kids that is
02:32:36 <araujo> :-)
02:34:16 <inimino> ok :-)
02:44:44 <Beelsebob> What is the traditional way of getting happy bootstrapped?
02:50:21 <Heffalump> a butterfly
02:50:43 <Beelsebob> hmm? to create a small magnetic storm over my hard drive that flips the relevant bits?
03:10:00 <smg> > let is_ordered = foldr1 (<) in is_ordered [1..10]
03:10:01 <lambdabot>   add an instance declaration for (Num Bool)
03:10:01 <lambdabot>     In the expression: 1
03:10:34 <Heffalump> you need an && in there somewhere
03:10:46 <Heffalump> < isn't a reduction operator
03:10:56 <smg> reduction operator? :]
03:10:58 <Heffalump> and it won't do the right thing anyway
03:11:06 <mauke> a -> b -> b
03:11:08 <Heffalump> something like +, of type a -> a -> a
03:11:14 <smg> ah
03:11:15 <Heffalump> that is also associative
03:11:26 <Heffalump> so that you can compute the sum of a list in all sorts of different ways
03:11:38 <smg> hehe ok
03:11:49 <mauke> :t and . ap (zipWith (<)) tail
03:11:50 <lambdabot> forall a. (Ord a) => [a] -> Bool
03:11:53 <Heffalump> > let is_ordered xs = and (zipWith (<) xs (tail xs)) in is_ordered [1..10]
03:11:54 <lambdabot>  True
03:12:01 <TSC> :t \xs -> zipWith (<) xs (tail xs)
03:12:02 <mauke> > and . ap (zipWith (<)) tail $ [1 .. 10]
03:12:02 <lambdabot> forall a. (Ord a) => [a] -> [Bool]
03:12:03 <lambdabot>  True
03:12:09 <mauke> > and . ap (zipWith (<)) tail $ []
03:12:10 <lambdabot>  True
03:12:13 <Heffalump> oh, ap, evil
03:13:04 <mauke> I never know which one is >>= and which one is ap, until I remember that ap = S
03:14:47 <yitz_> ap is cool. but for real software, i'd use Heffalump's.
03:15:55 <adajo> hi, a ghci question. Is it possible to profile a program from within ghci? I was looking for some way to quickly count how many times a top-level definition was called.
03:16:23 <mauke> liftM2 (zipWith (<)) id tail -- most obvious
03:16:24 <yitz_> > let is_ordered = (== 1) . length . groupBy (<) in is_ordered [1..10]
03:16:24 <lambdabot>  True
03:16:34 <Baughn> adajo: There's always trace
03:16:40 <mauke> > groupBy (<) []
03:16:41 <lambdabot>  []
03:16:59 <yitz_> > let is_ordered = (<= 1) . length . groupBy (<) in is_ordered [1..10]
03:16:59 <lambdabot>  True
03:17:04 <yitz_> ok?
03:17:25 <mauke> > null . drop 1 . groupBy (<) $ 1 : [0 ..]
03:17:25 <lambdabot>  False
03:17:34 <smg> mauke: ap = function application?
03:17:44 <mauke> smg: lifted function application
03:17:49 <Baughn> @src groupBy
03:17:49 <lambdabot> groupBy _  []       =  []
03:17:49 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
03:17:49 <lambdabot>     where (ys,zs) = span (eq x) xs
03:17:56 <mauke> ap f g x = f x (g x)
03:17:56 <smg> mauke: interesting
03:18:01 <yitz_> ah, yes, null . drop 1. much better.
03:19:03 <adajo> Baughn: thanks, I just stumbled upon trace, I don't know what it means that trace isn't safe though...
03:19:06 <yitz_> > groupBy (<) $ concat [[1..3],[2..5]]
03:19:07 <lambdabot>  [[1,2,3,2,3,4,5]]
03:19:11 <mauke> hmm, or ap f x = \e -> f' x' where f' = f e; x' = x e
03:19:15 <mauke> except that doesn't work
03:19:18 <pjd> adajo: trace is a side effect
03:19:21 <smg> Heffalump: that code was cool
03:19:49 <smg> mauke: yours is also fine but :)
03:19:51 <Baughn> adajo: It uses unsafePerformIO. It's safe enough, though.
03:19:52 <Heffalump> adajo: it's only unsafe in that the way it prints out stuff might be a bit unpredictable
03:19:59 <smg> :t ap
03:20:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
03:20:01 <yitz_> > groupBy (<) $ concat $ [1..3]++[2..5]
03:20:02 <lambdabot>   add an instance declaration for (Enum [a], Num [a])
03:20:15 <Heffalump> smg: it's a very standard trick (as you might guess from the number of people that stated essentially the same code at the same time :-)
03:20:17 <pjd> :t (<*>)
03:20:18 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
03:20:23 <yitz_> > groupBy (<) $ [1..3]++[2..5]
03:20:23 <lambdabot>  [[1,2,3,2,3,4,5]]
03:20:27 <smg> Heffalump: that ap stuff?
03:20:29 <Baughn> adajo: It'll print things in the order that your program actually executes them, which may be unexpected in interesting ways
03:20:33 <yitz_> wh?
03:20:39 <Heffalump> not ap, zipWith xs (tail xs)
03:20:47 <Heffalump> ap was just a way to shorten that even more
03:20:48 <adajo> Heffalump: great. that will do. I don't really care about the order things happen.
03:20:49 <smg> Heffalump: ah yes i know it from my fibonacci function
03:21:24 <mauke> haha
03:21:27 <Heffalump> adajo: you might also find strings interleaved with each other
03:21:28 <smg> > let fib = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ] in fib 10 -- a nicer fibonacci
03:21:29 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `[a]'
03:21:40 <Heffalump> if evaluating one string causes something else to get evaluated in the middle
03:22:39 <pjd> > let fib = 1:1:[ a+b | a <- fib | b <- tail fib ] in fib 10
03:22:39 <lambdabot>  Parse error at "|" (column 32)
03:22:45 <pjd> doy
03:22:53 <smg> > let is_ordered_rev xs = and (zipWith (<) xs (tail xs)) . flip in is_ordered [1..10]
03:22:54 <lambdabot>   Not in scope: `is_ordered'
03:22:59 <smg> > let is_ordered_rev xs = and (zipWith (<) xs (tail xs)) . flip in is_ordered_rev [1..10]
03:22:59 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `Bool'
03:24:16 <smg> > take 10 $ (\x -> 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]) -- a nicer fibonacci
03:24:16 <lambdabot>   Not in scope: `fib'
03:24:17 <adajo> Baughn: yes, I see that now. I wrote a small lambda evaluator and things look weird indeed :)
03:24:44 <smg> > let fib = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ] in take 10 $ fib
03:24:44 <lambdabot>  [1,1,2,3,5,8,13,21,34,55]
03:24:47 <smg> ! :)
03:25:37 <mauke> > fix (join (.) (1 :) . ap (zipWith (+)) tail)
03:25:38 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
03:25:46 <mauke> HAX
03:26:46 <smg> mauke: hahahaha
03:26:51 <yitz_> > all (null.drop 1) . groupBy (>) $ [1,2,3,2,3,4]
03:26:51 <lambdabot>  False
03:26:57 <smg> i like your code but it's too complicated for me at that time :)
03:27:01 <yitz_> > all (null.drop 1) . groupBy (>) $ [1..10]
03:27:01 <lambdabot>  True
03:27:11 <mauke> @unpl fix (join (.) (1 :) . ap (zipWith (+)) tail)
03:27:12 <lambdabot> fix (\ g -> ((\ a b c -> a (b c)) >>= \ h -> h) (\ d -> 1 : d) (((zipWith (+)) >>= \ k -> tail >>= \ j -> return (k j)) g))
03:27:18 <mauke> hmm...
03:27:33 <smg> xD
03:27:58 <mauke> @. redo unpl fix (join (.) (1 :) . ap (zipWith (+)) tail)
03:27:58 <lambdabot> fix (\ g -> (do { h <- (\ a b c -> a (b c)); h}) (\ d -> 1 : d) ((do { k <- (zipWith (+)); j <- tail; return (k j)}) g))
03:28:21 <smg> :t fix
03:28:21 <lambdabot> forall a. (a -> a) -> a
03:28:50 <mauke> @src fix
03:28:50 <lambdabot> fix f = let x = f x in x
03:29:01 <mauke> magic, ladies and gentlemen
03:30:06 <smg> mauke: are you studying CS?
03:30:08 <ziman> lovely :)
03:30:49 <mauke> no
03:31:55 <smg> hehe
03:35:56 <vincenz> http://abaababa.blogspot.com/2008/02/monads-are-class-of-hard-drugs.html
03:35:57 <lambdabot> Title: Abaababa: Monads are a class of hard drugs, http://tinyurl.com/2kdlnx
03:37:16 <scook0> heh
03:38:11 <scook0> there are some valid points in there, and some not-so-valid ones
03:38:38 <marshmallows> funny
03:39:19 <marshmallows> slightly confusing wording "... in practice, GHC, as a compiler, is very slow. Haskell programs, unless written very carefully, do get quite slow..." do they mean the compiler is slow or generates slow code?
03:40:02 <scook0> -fvia-C can be slow to compile
03:40:03 <integral> the first sentence says that GHC is slow, the second says that the compiled programs are slow
03:40:26 <scook0> though to be honest, I don't have many reference points for language compile times
03:42:03 <allbery_b> Xmonad doesn't require the latest ghc, as he says.  I suspect it won't work with 6.4.x though, and that would be fairly slow (6.6 and 6.8 both got significant speedups)
03:43:00 <smg> @src all
03:43:00 <lambdabot> all p =  and . map p
03:43:07 <allbery_b> integral:  both are true, somewhat vacuously (since ghc is used to build itself, if ghc produces slow programs, it will itself be slow)
03:43:26 <Heffalump> allbery_b: does speed matter with xmonad?
03:43:53 <allbery_b> in fact if he's stuck on 6.4.1, lots of things will be massively painful.  would also explain why he had Cabal issues since he'd need to update that too
03:44:08 <allbery_b> Heffalump:  not really
03:44:42 <allbery_b> his comments about xmonad do suggest he's using ghc 6.4.1 though
03:44:50 <scook0> the anti-monad stuff doesn't seem much more coherent than typical monad-bashing
03:44:56 <smg> @src map
03:44:56 <lambdabot> map _ []     = []
03:44:56 <lambdabot> map f (x:xs) = f x : map f xs
03:45:21 <marshmallows> :t let map f = foldr (x xs -> f x : xs) in map
03:45:22 <lambdabot> parse error on input `->'
03:45:22 <desegnis> Heffalump: In my experience a cheap on-board graphics card does not make you notice xmonad speed problems
03:45:26 <marshmallows> :t let map f = foldr (\x xs -> f x : xs) in map
03:45:26 <lambdabot> forall a a1. (a -> a1) -> [a1] -> [a] -> [a1]
03:45:42 <marshmallows> :t let map f = foldr (\x xs -> f x : xs) [] in map
03:45:43 <lambdabot> forall a a1. (a -> a1) -> [a] -> [a1]
03:45:58 <resiak> since when do you need type signatures to use IO actionsâ€½
03:46:00 <allbery_b> xmonad doesn't do a whole lot visually, so its performance is not affected by video card speed
03:46:07 <marshmallows> resaik: lol
03:46:31 <allbery_b> (windows might draw slowly but that won't be affected by xmonad, but by the applications that own the windows)
03:47:19 <pjd> "The essence of monads is to use abstract types to enclose a mutable state" ... "The essence of monads is to use abstract types to enclose a mutable state"
03:47:22 <pjd> argh
03:47:43 * allbery_b considers a monadic cluebat
03:49:02 <desegnis> allbery_b: Yeah I mean, when I perform an xmonad action like window resizing, then the redrawing is what I perceive as slow, not the work actually done by xmonad
03:49:09 <pjd> oops, pasted the same quote twice
03:49:21 <pjd> second one should have been "Monads are a typing trick to ensure proper linear usage of some updateable resource in a functional language."
03:50:01 <smg> @src dropWhile
03:50:02 <lambdabot> Source not found. My pet ferret can type better than you!
03:50:04 <smg> mh?
03:50:16 <jql> so, monads are the curtain behind which the Great and Powerful Wizard of Oz resides? :)
03:51:11 <allbery_b> smg:  @src database is not comprehensive
03:54:45 <scook0> "The essence of monads is endofunctors, eta, and mu." -- doesn't have quite the same ring to it
03:57:05 <pjd> lifting and unlifting
03:59:24 <scook0> lifting and unlifting reminds me of "Haskell is not not ML" ... hmm
04:04:12 <smg> allbery_b: k
04:04:41 <allbery_b> at a guess you can find it somewhere in
04:04:44 <allbery_b> @where report
04:04:44 <lambdabot> http://www.haskell.org/onlinereport/
04:05:01 <allbery_b> since the appendices include listings of the standard Prelude
04:05:35 <smg> @src uncurry
04:05:35 <lambdabot> uncurry f p = f (fst p) (snd p)
04:05:41 <smg> mh. is that correct?
04:05:45 <marshmallows> :t uncurry
04:05:46 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
04:05:48 <marshmallows> :t curry
04:05:49 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
04:06:08 <smg> @src curry
04:06:08 <lambdabot> curry f x y = f (x, y)
04:06:10 <scook0> @. djinn type uncurry
04:06:10 <lambdabot> f a (b, c) = a b c
04:06:13 <scook0> @. djinn type curry
04:06:14 <lambdabot> f a b c = a (b, c)
04:06:34 <smg> i thought curry would transform a function with a pair of arguments to a function with one argument which returns a function
04:06:43 <smg> so curry f (a,b) = f a b
04:07:00 <marshmallows> @. pl djinn (a -> b -> c -> d -> e -> f) -> ((((a, b), c), d), e) -> f
04:07:01 <allbery_b> it does
04:07:01 <lambdabot> f = (`ap` snd) . (. fst) . (`ap` snd) . (. fst) . (`ap` snd) . (. fst) . (`ap` snd) . (. fst)
04:07:09 <scook0> your description contradicts your example
04:08:06 <allbery_b> ((a,b) -> c) -> a -> b -> c parses as ((a,b) -> c) -> (a -> (b -> c))
04:08:35 <marshmallows> -> is right associative
04:08:45 <smg> i know all what you're saying
04:08:52 <smg> but @src curry seems strange then
04:09:39 <scook0> curry f = \x y -> f (x, y)
04:09:43 <scook0> does that make more sense?
04:10:01 <smg> mh
04:10:02 <smg> @src curry
04:10:02 <lambdabot> curry f x y = f (x, y)
04:10:04 <marshmallows> scook0: I prefer the types for describing what curry/uncurry do
04:10:14 <marshmallows> the actual code is not as good
04:10:30 <smg> looks like curry would return a function with a tuple (x,y) as argument??
04:10:32 <scook0> I was responding to "but @src curry seems strange then"
04:10:47 <smg> i undrestand the types etc curry/uncurry but @src curry mh mh
04:10:49 <allbery_b> no, it's right
04:10:52 <smg> confuses me
04:11:02 <allbery_b> given the type, the code has to be "backwards"
04:11:22 <scook0> remember that in the source for curry, f is a function that takes a tuple argument
04:11:25 <allbery_b> because it has to take the a -> b -> c form and pass it to f as f (a,b)
04:11:39 <marshmallows> just ignore the source completely, the type is what matters
04:13:19 <yitz_> > let { curry :: ((a,b)->c)->a->b->c; curry=undefined} in curry id
04:13:20 <lambdabot>  Add a type signature
04:13:50 <marshmallows> :t undefined :: pinkelephants
04:13:51 <lambdabot> forall pinkelephants. pinkelephants
04:19:57 <smg> hehe
04:25:57 <Baughn> :t 2 + 3 :: handkerchief
04:25:58 <lambdabot>     Could not deduce (Num handkerchief) from the context ()
04:25:58 <lambdabot>       arising from the literal `2' at <interactive>:1:0
04:25:58 <lambdabot>     Possible fix:
04:28:16 <Baughn> :t undefined $ 2 + 3 :: handkerchief
04:28:17 <lambdabot> forall handkerchief. handkerchief
04:28:33 <Baughn> @ty undefined $ 2 + 3 :: handkerchief
04:28:34 <lambdabot> forall handkerchief. handkerchief
04:28:56 <Baughn> ..how odd.
04:29:09 <pjd> heh
04:29:53 <marshmallows> @ty (undefined :: ?huh) $ 2 + 3 :: handkerchief
04:29:54 <lambdabot> parse error on input `)'
04:30:09 <marshmallows> @ty (( undefined :: ?x ) $ 2 + 3) :: handkerchief
04:30:10 <lambdabot> parse error on input `)'
04:30:30 <marshmallows> @ty (( ?undefined ) $ 2 + 3) :: handkerchief
04:30:32 <lambdabot>     Could not deduce (?undefined::a -> handkerchief2)
04:30:32 <lambdabot>       from the context ()
04:30:32 <lambdabot>       arising from a use of implicit parameter `?undefined'
04:30:50 <pjd> :t let forAll = forAll in forAll :: forAll
04:30:51 <lambdabot> forall forAll. forAll
04:33:24 <Baughn> :t let forall = forall in forall :: forall
04:33:25 <lambdabot> parse error (possibly incorrect indentation)
04:34:18 <Baughn> > let x = (1:x) in x
04:34:19 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:34:35 <pjd> > fix (1:)
04:34:36 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:34:40 <marshmallows> > [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
04:34:40 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
04:34:44 <marshmallows> awwww...
04:35:25 <smg> :p
04:35:28 <smg> how about
04:35:32 <smg> > [1..]
04:35:33 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
04:35:36 <smg> :)
04:35:38 <smg> ah damn
04:35:39 <Baughn> > [1,1..]
04:35:39 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:35:40 <smg> > iterate 1
04:35:40 <lambdabot>   add an instance declaration for (Num (a -> a))
04:36:09 <smg> > repeat 1
04:36:09 <RayNbow> > map (const 1) [1..]
04:36:09 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:36:10 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:36:18 <marshmallows> > [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
04:36:18 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:36:21 <smg> > iterate (id) 1
04:36:21 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:36:24 <smg> :)
04:36:51 <RayNbow> > zipWith (-) [2..] [1..]
04:36:52 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:41:18 <Baughn> > zipWith (*) [0..] [1..]
04:41:19 <lambdabot>  [0,2,6,12,20,30,42,56,72,90,110,132,156,182,210,240,272,306,342,380,420,462,...
04:42:10 <scook0> @oeis 0 2 6 12 20
04:42:10 <lambdabot> Oblong (or pronic, or heteromecic) numbers: n(n+1).
04:42:10 <lambdabot> [0,2,6,12,20,30,42,56,72,90,110,132,156,182,210,240,272,306,342,380,420,462,5...
04:42:34 <smg> hehe
04:42:39 <marshmallows> > (zipWith (*) `ap` tail) [0..]
04:42:40 <lambdabot>  [0,2,6,12,20,30,42,56,72,90,110,132,156,182,210,240,272,306,342,380,420,462,...
04:42:49 <smg> haha `ap` :)
04:43:05 <marshmallows> :t join
04:43:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
04:43:09 <marshmallows> :t (`ap` id)
04:43:10 <lambdabot> forall b a. (a -> a -> b) -> a -> b
04:43:37 <Baughn> :t ap
04:43:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
04:43:54 <marshmallows> :t (`ap` mzero)
04:43:55 <lambdabot> forall (m :: * -> *) a b. (MonadPlus m) => m (a -> b) -> m b
04:44:01 * Baughn groans. Monads. That figures.
04:46:56 <allbery_b> Baughn: (Control.Applicative.<*>) ?
04:47:24 <Baughn> allbery_b: Haven't used it
04:47:37 <marshmallows> :t (<*>)
04:47:38 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
04:47:39 <Baughn> For `ap` id, I suppose it uses the (->) monad or some such..
04:47:40 <allbery_b> <*> is ap but with applicative functors
04:47:52 <Baughn> allbery_b: Haven't used /those/
04:47:59 <marshmallows> @intances Applicative
04:48:00 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
04:48:15 <allbery_b> @instances-importing Control.Applicative Applicative
04:48:15 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
04:48:23 <Baughn> @src (->) return
04:48:23 <lambdabot> return = const
04:48:49 <allbery_b> applicative functors are simpler than monads, they're just functors with a few extra constraints
04:48:56 <Baughn> @src (->) (>>=)
04:48:56 <lambdabot> f >>= k = \ r -> k (f r) r
04:49:07 <allbery_b> @go Applicative Programming with Effects
04:49:12 <lambdabot> http://www.soi.city.ac.uk/~ross/papers/Applicative.html
04:49:12 <lambdabot> Title: Applicative Programming with Effects
04:49:17 <pjd> > zipWith (*) =<< (recip.) $ [1..]
04:49:18 <lambdabot>  [1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0...
04:50:32 <b_jonas> hmm
04:51:14 <smg> > rotate [0,1]
04:51:15 <lambdabot>   add an instance declaration for (Bits [t])
04:51:25 <Baughn> > ((+1) >>= (,)) 2
04:51:26 <lambdabot>  (3,2)
04:51:31 <Baughn> @redo ((+1) >>= (,)) 2
04:51:31 <lambdabot> (do { a <- (+ 1); (,) a}) 2
04:51:56 <RobHu> If I type something like square x = x * x in to ghci it says parse error on input `='. What do I need to do differently?
04:52:08 <Baughn> RobHu: let square x =...
04:52:13 <RobHu> great thanks
04:52:26 <Baughn> RobHu: The ghci toplevel is effectively an IO do-block
04:52:53 <RobHu> OK, that means nothing to me yet - I'm watching a lecture introducing haskell, and I wanted to follow along
04:54:02 <Baughn> RobHu: The implication is that you can use the same syntax in any /other/ do-block
04:54:10 * Heffalump realises that he was just reading an LJ comment by RobHu. Small world and all.
04:54:13 <Baughn> RobHu: Or use "foo <- readFile "foo"" in ghci
04:54:22 <RobHu> ok
04:54:29 <RobHu> Heffalump: Were you? :)
04:54:34 <Heffalump> on atreic's LJ.
04:54:38 <RobHu> ah
04:54:41 <RobHu> Who are you on LJ?
04:54:43 <Heffalump> hsenag
04:54:49 <RobHu> I have not encountered you
04:55:06 <Heffalump> I've seen you on several of my friends posts, I think. But I don't say much.
04:55:30 <RobHu> ok :)
05:01:18 <RobHu> ok, so if I do let len [] = 0 that's fine, but if I do let len (x:xs) = 1 + len (xs) it seems to wipe out the earlier definition. Do all the repl haskell implementations do this? What am I doing wrong?
05:01:48 <Saizan> let len [] = 0; len (x:xs) = 1 + len xs
05:01:58 <Saizan> you've to use a single let statement
05:02:13 <Saizan> like that ^^^^
05:02:18 <RobHu> mmmmm ok
05:02:26 <marshmallows> RobHu: You can write your code in a file len.hs
05:02:30 <marshmallows> then go :load len
05:02:38 <RobHu> I think I need to learn how to get ghci running in an emacs buffer
05:02:50 <Saizan> ?where haskell-mode
05:02:50 <lambdabot> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
05:02:56 <RobHu> thanks ^_^
05:03:42 <Saizan> however yes, ghci is mainly for evaluating expression, rather than definitions
05:59:01 <Beelsebob> What's the traditional way of bootstrapping Happy?
05:59:18 <Beelsebob> The only version I see available for download is 1.17, which requires happy to build
06:01:42 <Heffalump> from a binary dist, I guess
06:01:51 <Beelsebob> there is none for my platform
06:01:59 <Beelsebob> (OS X/x86)
06:02:11 <Heffalump> copy the generated files from another platform, presumably
06:02:14 * Heffalump doesn't know, though
06:02:24 <Beelsebob> :/
06:02:36 <Beelsebob> yeh, that would work... if I had another platform about the place
06:03:14 <ivanm> Beelsebob: looking at the gentoo ebuild... it doesn't seem to require happy :s
06:03:44 <Beelsebob> hmm, wonders if something is going sqewif on OS X then
06:03:46 <Beelsebob> LappyBob-2:happy tatd2$ runhaskell Setup.lhs build
06:03:46 <Beelsebob> Preprocessing executables for happy-1.17...
06:03:46 <Beelsebob> Setup.lhs: The program happy is required but it could not be found
06:03:56 <ivanm> that's weird...
06:04:01 <ivanm> @where happy
06:04:02 <lambdabot> http://www.haskell.org/happy/
06:04:05 <Heffalump> happy does require happy, AFAIK
06:04:11 <Heffalump> the ebuild probably includes some generated files
06:04:32 <ivanm> nope
06:04:36 <ivanm> not that I can find
06:04:38 * Heffalump is just making an attempt at producing some generated files for Beelsebob
06:04:49 <Beelsebob> :) that would be really usefuly
06:04:51 <Beelsebob> useful*
06:05:17 <Heffalump> I'd prefer the butterfly approach, but I think it might take a while.
06:05:39 <ivanm> Beelsebob: which version of ghc do you have?
06:05:58 <Beelsebob> 6.8.2
06:06:15 <ivanm> Beelsebob: did you try via makefile instead of via cabal?
06:06:23 <ivanm> maybe try autoconf on it first?
06:06:32 <Beelsebob> no, I haven't, I didn't even realise there was one there... sec
06:06:53 <ivanm> the ebuild runs autoconf
06:07:12 <Beelsebob> autoconf has no input file, make complains that the mk directory doesn't exist
06:07:32 <allbery_b> autoreconf
06:07:39 <ivanm> that's what I meant ;-)
06:08:00 <Beelsebob> allbery_b: no configure files of any kind there
06:08:04 <allbery_b> (which runs all the stuff needed before autoconf, like aclocal)
06:08:11 <allbery_b> hm
06:08:33 <ivanm> Beelsebob: in the doc folder
06:09:08 <Beelsebob> okay, well, configuring works in there
06:09:12 <Beelsebob> but make still fails
06:09:17 <ivanm> OK, not make
06:09:22 <ivanm> its autoreconf, then cabal
06:09:35 <allbery_b> that makefile only builds docs
06:09:39 <allbery_b> no makefile at the top level?
06:09:44 <Saizan> Beelsebob: use the package from hackage, it works fine.
06:09:50 <ivanm> they don't use make anymore
06:09:55 * ivanm lied before :p
06:10:04 <Beelsebob> hehe
06:12:04 <Beelsebob> Saizan: using cabal, yes?
06:12:14 <Saizan> yes
06:12:37 <Beelsebob> yep, that's building, cheers very much :)
06:13:10 <Saizan> :)
06:16:49 <juhe> I'm trying to find out, where the withTempFile function is defined, any idea?
06:17:05 <mauke> @hoogle withTempFile
06:17:05 <lambdabot> No matches found
06:18:00 <juhe> yep... I tried that as well :-|
06:18:39 <mauke> where did you see it?
06:18:59 <ivanm> @hoogle temp
06:19:00 <lambdabot> Distribution.Extension.TemplateHaskell :: Extension
06:19:00 <lambdabot> Language.Haskell.Extension.TemplateHaskell :: Extension
06:19:00 <lambdabot> System.IO.openTempFile :: FilePath -> String -> IO (FilePath, Handle)
06:19:00 <juhe> I'm playing - well wanted to play - with hsgnutls
06:19:19 <juhe> and it seems it wasn't adjusted to 6.8
06:19:37 <juhe> because I guess it worked with 6.6 (but it's just a guess)
06:23:18 <Saizan> juhe: there's openTempFile http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v%3AopenTempFile
06:23:21 <lambdabot> http://tinyurl.com/sbkmj
06:23:50 <allbery_b> I don't think there's ever been a standard withTempFile
06:24:02 <allbery_b> (I just checked MissingH, not there either)
06:24:29 <juhe> ok, I'll check the link, however it seems I'll need to adjust the original code so I wanted to know what the withTempFile function does.
06:25:54 <juhe> I've googled and found this: http://darcs.haskell.org/cabal/_darcs/patches/20080222205215-adfee-56b9e8ba515f704cab881a24b8927c5088b216cd.gz
06:25:57 <lambdabot> http://tinyurl.com/2txg4s
06:27:02 <juhe> It seems it is related to cabal (also hsgnutls uses cabal for build) - I'll look at cabal sources...
06:27:59 <skorpan> i need to generate a list, given an x, s.t. list = [x, x+1, x+2 .. x+6, x-1, x-2, .. x-6]
06:28:03 <skorpan> any ideas?
06:28:18 <resiak> Currently the fuse binding's module name is just HFuse; where would the right location be?  System.Fuse?  System.Posix.Fuse ?
06:28:20 <ivanm> skorpan: enum then map + x to it?
06:28:26 <ivanm> or just enum, dir
06:28:43 <marshmallows> > (map (x+) [0..6]) ++ (map (x-) [1..6])
06:28:44 <lambdabot>  [x + 0,x + 1,x + 2,x + 3,x + 4,x + 5,x + 6,x - 1,x - 2,x - 3,x - 4,x - 5,x - 6]
06:28:48 <skorpan> > let x = 0 in [x-6..x+6]
06:28:48 <lambdabot>  [-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6]
06:28:49 <ivanm> > let listGen x -> enumFromTo x (x-6) in listGen 10
06:28:49 <lambdabot>  Parse error at "->" (column 15)
06:28:50 <marshmallows> > map (x+) [0..6] ++ map (x-) [1..6]
06:28:50 <lambdabot>  [x + 0,x + 1,x + 2,x + 3,x + 4,x + 5,x + 6,x - 1,x - 2,x - 3,x - 4,x - 5,x - 6]
06:28:56 <ivanm> > let listGen x = enumFromTo x (x-6) in listGen 10
06:28:57 <lambdabot>  []
06:29:17 <ivanm> > let listGen x = enumFromThenTo x -1 (x-6) in listGen 10
06:29:17 <lambdabot>        add an instance declaration for
06:29:18 <lambdabot>       (Num (t -> t -> [t]), Num (t -> ...
06:29:26 <ivanm> whatever it is :p
06:29:27 <skorpan> thanks, but i figured it out :)
06:29:34 <skorpan> let x = 0 in [x-6..x+6] did it
06:29:39 <skorpan> the order doesn't matter
06:29:41 <ivanm> heh
06:29:43 <ivanm> ahhh, k
06:29:46 <skorpan> :)
06:30:04 <xerox> > [(+),(-)] <*> [x] <*> [1..6]
06:30:04 <lambdabot>  [x + 1,x + 2,x + 3,x + 4,x + 5,x + 6,x - 1,x - 2,x - 3,x - 4,x - 5,x - 6]
06:30:46 <marshmallows> :D
06:30:48 <marshmallows> cool
06:30:56 <xerox> ^_^
06:31:19 <ivanm> xerox: show off :p
06:31:24 <Botje> xerox: you scare me.
06:31:30 <xerox> :(
06:34:03 <jyp> > (x +) <$> [(-6)..6]
06:34:04 <lambdabot>  [x + (-6),x + (-5),x + (-4),x + (-3),x + (-2),x + (-1),x + 0,x + 1,x + 2,x +...
06:35:49 <skorpan> is there any predefined function which checks that an Int is between two other Ints?
06:36:00 <oerjan> inRange
06:36:02 <EvilTerran> ?hoogle inRange
06:36:02 <lambdabot> Data.Ix.inRange :: Ix a => (a, a) -> a -> Bool
06:36:02 <lambdabot> Distribution.Version.withinRange :: Version -> VersionRange -> Bool
06:36:17 <skorpan> > inRange (0,8) 7
06:36:17 <lambdabot>  True
06:36:21 <skorpan> > inRange (0,8) 8
06:36:22 <lambdabot>  True
06:36:24 <skorpan> cool, thanks
06:36:50 <EvilTerran> > [(x,y,z,inRange (x,y) z) | x <- [LT ..], y <- [LT ..], z <- [LT ..]] -- not just for Ints, either
06:36:51 <lambdabot>  [(LT,LT,LT,True),(LT,LT,EQ,False),(LT,LT,GT,False),(LT,EQ,LT,True),(LT,EQ,EQ...
06:37:09 <EvilTerran> ?src Ordering
06:37:09 <lambdabot> data Ordering = LT | EQ | GT
06:37:34 <oerjan> though not for Ord, sadly
06:38:22 <oerjan> it behaves differently on tuples than what an Ord version would
06:39:08 <skorpan> http://hpaste.org/6408
06:39:50 <EvilTerran> ?type uncurry $ ((. (<)) . liftA2 (&&) (<)
06:39:51 <lambdabot> parse error (possibly incorrect indentation)
06:39:58 <EvilTerran> ?type uncurry $ (. (<)) . liftA2 (&&) (<)
06:39:59 <lambdabot>     Couldn't match expected type `Bool'
06:39:59 <lambdabot>            against inferred type `a -> Bool'
06:39:59 <lambdabot>     Probable cause: `<' is applied to too few arguments
06:40:01 <EvilTerran> bah
06:40:02 <oerjan> skorpan: things are in scope only to the right
06:40:04 <marshmallows> I was thinking
06:40:13 <oerjan> so put the tests last
06:40:20 <skorpan> oerjan: ah, so i should move the two inRange to the right of the x1 <- []..
06:40:22 <EvilTerran> ?pl \(lo,hi) it -> lo < it && it < hi -- my pl-fu is weak today
06:40:23 <lambdabot> uncurry ((. flip (<)) . ap . ((&&) .) . (<))
06:40:26 <EvilTerran> ew
06:40:32 <marshmallows> :t \ min max -> uncurry (&&) . ((< max) &&& (> min))
06:40:34 <lambdabot> forall b. (Ord b) => b -> b -> b -> Bool
06:40:39 <xerox> ?type (. uncurry enumFromTo) . elem
06:40:40 <lambdabot> forall a. (Eq a, Enum a) => a -> (a, a) -> Bool
06:40:52 <xerox> hm
06:41:01 <EvilTerran> marshmallows, yeah, i was aiming for an even less pointful version of that
06:41:06 <marshmallows> hehe
06:41:34 <EvilTerran> :t \lo hi -> liftA2 (&&) (lo<) (hi>)
06:41:35 <lambdabot> forall a. (Ord a) => a -> a -> a -> Bool
06:41:52 <xerox> right.
06:41:54 <EvilTerran> :t uncurry $ \lo -> liftA2 (&&) (lo<) . (>)
06:41:55 <lambdabot> forall a. (Ord a) => (a, a) -> a -> Bool
06:42:30 <EvilTerran> :t uncurry $ (. (>)) . liftA2 (&&) . (<)
06:42:31 <lambdabot> forall a. (Ord a) => (a, a) -> a -> Bool
06:42:33 <EvilTerran> gotcha
06:42:46 <oerjan> there was some weird trick with compare
06:43:01 <EvilTerran> ?type compare
06:43:02 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
06:43:24 <xerox> how straightforward it is to build lambdabot nowadays?
06:44:30 <oerjan> > [((/= x) `on` compare) 3 7 | x <- [0..10]]
06:44:31 <lambdabot>  Couldn't match expected type `b -> c' against inferred type `Bool'
06:44:46 <yitz_> xerox: I just tried and couldn't do it. dons claims he did it yesterday.
06:44:47 <oerjan> > [((/=) `on` compare x) 3 7 | x <- [0..10]]
06:44:48 <lambdabot>  [False,False,False,True,True,True,True,True,False,False,False]
06:45:09 <yitz_> xerox: you need dons' darcs version of the plugins package.
06:45:54 <Saizan> ?where hs-plugins
06:45:54 <lambdabot> http://code.haskell.org/~dons/code/hs-plugins
06:46:56 <oerjan> (it fails if the endpoints are equal though)
06:47:27 * desegnis_ just ordered a copy of Types and Programming Languages and hopes it will pay off :)
06:47:36 <juhe> The withTempFile is defined in cabal module Distribution.Compat.TempFile, however when I include it, cabal is unhappy and  sayint that "it is hidden (in package Cabal-1.2.3.0)". How can I make it unhidden?
06:47:53 <juhe> s/sayint/saying/
06:48:04 <_qq> hi, one question from a not yet TH user: can TH be used to detect (and then probably remove) left recursion from parsec functions?
06:48:13 <Saizan> juhe: put Cabal in build-depends
06:48:39 <desegnis_> juhe: Cabal hides all packages, even if they are "exposed", except if they are mentioned in the build-depends field of the .cabal file
06:48:49 <xerox> yitz_: thanks
06:49:31 <juhe> Well I tried that, but cabal still refuses to work, I think this is more problematic, because the function is used in Setup.lhs
06:49:54 <desegnis_> juhe: Did you try to add the exact version?
06:50:03 <Saizan> _qq: you'd have to quote a lot of your code i think
06:50:04 <juhe> nope, will try with the version
06:50:18 <oerjan> _qq: sounds tricky (although i don't know TH).  left recursion can happen nested, and you also need to detect prior parsers that can parse empty strings.
06:50:22 <juhe> ... same story
06:50:23 <desegnis_> juhe: Only to be considered if there are different Cabals floating around, of course
06:51:09 <desegnis_> juhe: Wait, you said you use that function from Setup.lhs?
06:51:35 <juhe> yes, it is used from Setup.lhs (the hsgnutls library)
06:52:14 <Saizan> ah then build-depends is not relevant
06:52:21 <desegnis_> juhe: Then this is probably Cabal versioning hell
06:52:23 <oerjan> this together with the fact Parsec parsers have no requirement to be context-free...
06:52:36 <EvilTerran> _qq, it'd be possible, but you'd either be at risk of false positives or false negatives (or both)
06:52:50 <juhe> desegnis_: yes, i'll probably rewrite the part of code in order to workaround it...
06:53:01 <EvilTerran> _qq, and it'd be a lot easier to adapt something like ndm's Catch, i suspect
06:53:15 <_qq> Saizan: well I'd have to work into TH I guess to understand what you mean with "quote", but I imagine with TH I could somehow get the grammar tree from the functions and then apply just textbook algos
06:53:15 <desegnis_> juhe: try -package when you run the Setup, or use ghc-pkg to expose the Cabal version you need
06:53:54 <EvilTerran> _qq, as Catch detects whether the "error" function can be thrown by your code, via evaluating undefineds or pattern-match failures or explicit calls to error or whatever
06:54:14 <Saizan> _qq: with TH you can use special brackets like [d| <code here> |] which return the AST of the code
06:54:29 <_qq> EvilTerran: ok, I'll have a look at Catch too
06:54:53 <EvilTerran> _qq, so you could probably adapt it to do something similar to detect whether a Parsec parser can left-recurse. it wouldn't help you eliminate it, but i think you could majorly re-hack it to detect it
06:55:03 <EvilTerran> ?where Catch
06:55:04 <lambdabot> http://www.cs.york.ac.uk/~ndm/projects/catch.php
06:56:17 <EvilTerran> _qq, the thing is, it's difficult (as hinted by oerjan) 'cos arbitrary haskell code can be part of a Parsec parser, so a complete solution would solve the halting problem
06:56:29 <EvilTerran> i suspect
06:56:43 * oerjan suspects that too
06:57:28 <oerjan> maybe if you restricted it to only the Applicative/Alternative subset of combinators...
06:58:30 <oerjan> (where one parser cannot influence the next)
06:58:40 <Saizan> oerjan: you can still have arbitrary non-parsec haskell code
06:59:14 <oerjan> Saizan: yes, but it would only affect the returned result, not the actions performed
06:59:33 <EvilTerran> but you could detect all *potential* left-recursion with something catch-esque. Catch itself often flags potential problems that can't actually happen, which is unfortunately a necessary side-effect of ensuring it'll terminate ;)
06:59:58 <_qq> oh boy, a quick idea turns into a can of worms, I'm not going to solve the halting problem :-)
07:00:37 <oerjan> _qq: better read up on chainl instead ;)
07:01:07 <_qq> oerjan: yes, back to hand refactoring then
07:01:15 <Saizan> foo m p = if halts m then p else pzero; foo m p is a parsec parser
07:01:34 <EvilTerran> _qq, it'd be perfectly possible to confirm that a parser *cannot* left-recurse, but there'll still be some that don't left-recurse that your program will think might left-recurse
07:01:59 <EvilTerran> and eliminating them'd be another two or three cans of worms
07:02:28 <EvilTerran> Saizan, sure, if you can implement "halts" :P
07:03:23 <Saizan> EvilTerran: just wait forever :) that was my point :)
07:03:52 * oerjan wonders if you could instead automatically refactor a Parsec parser to check whether it is left-recursing at runtime (with some memoizing)
07:05:42 * Beelsebob ponders
07:05:48 <Beelsebob> I'm parsing a lisp like language
07:06:06 <Beelsebob> at the moment, applications only have a single argument
07:06:22 <_qq> oerjan: something like "I've been here before without eating a Token"
07:06:31 <oerjan> _qq: exactly
07:06:33 <Beelsebob> but I'd like the parser to be somewhat more clever, and parse (x y z) as ((x y) z)
07:06:40 <EvilTerran> oerjan, i was thinking that, too. but i think it'd be limited simiarly to ghc's blackhole detection
07:06:52 <Beelsebob> but I can't think of the BNF to express that in a general case
07:06:54 <Beelsebob> any hints?
07:06:55 <marshmallows> you should parse (x y z) as [x,y,z]
07:06:57 <EvilTerran> altho you could make it overzealous rather than conservative
07:06:58 <marshmallows> or whatever
07:07:19 <EvilTerran> Beelsebob, well, you're basically parsing it into a binary tree, then, aren't you?
07:07:23 <Beelsebob> marshmallows: in my language, I expect (x y z) to mean x applied to y and z
07:07:46 <EvilTerran> expr ::= expr expr | token
07:08:13 <Beelsebob> well yes, but that doesn't encompas two things -- first, applications have to have brackets round them
07:08:19 <EvilTerran> whether (x y z) == ((x y) z) isn't really something you can express in BNF
07:08:21 <Beelsebob> and second, left associativity
07:08:25 <EvilTerran> as far as i know
07:09:09 <Beelsebob> well, okay, sorry, I'd like to parse (x y z) into App (App x y) z
07:09:19 <Beelsebob> as opposed to App x (App y z)
07:09:23 <oerjan> Beelsebob: you can have a production for an "unfinished" list
07:09:37 <Beelsebob> oerjan: hmm?
07:09:56 <oerjan> so list ::= unflist ')',  unflist ::= '(' | unflist expr
07:10:14 <marshmallows> Don't you really want to parse it as (Cons (Symbol "x") (Cons (Symbol "y") (Cons (Symbol "z") Nil))) ?
07:10:32 <Beelsebob> I don't want any conses at all
07:10:35 <Beelsebob> this is not a list
07:10:38 <Beelsebob> it is an application
07:10:42 <EvilTerran> marshmallows, these represent function application, not lists
07:10:46 <marshmallows> weird take on lisp
07:10:56 <marshmallows> normally code is lists
07:10:56 <oerjan> Beelsebob: i believe that ^^ should give the parsing you want
07:11:19 <Beelsebob> oerjan: yeh, I think it does
07:11:21 <Beelsebob> thanks a lot
07:11:46 <oerjan> Beelsebob: although it is left-recursive so you'll need to change it again if you use Parsec
07:12:00 <Beelsebob> no, happy
07:12:04 <ivan_> hello my haskell friends, i need to know the correct definition of abs for a polynomial, i have to make my polynomial as an instance of Num, my polynomial is represented as a [Doubles]
07:12:07 <Beelsebob> so I'll let it deal with it :)
07:12:27 <EvilTerran> ah, yes. happy excels at left-recursion over right-recursion, even, i believe
07:12:43 <oerjan> ivan_: ouch, i don't think the abs of a polynomial is a polynomial
07:13:00 <marshmallows> what is the abs of a polynomial?
07:13:03 <EvilTerran> ivan_, i agree with oerjan. it strikes me as being prone to discontinuities
07:13:05 <oerjan> i guess you could just abs each coefficient
07:13:43 <EvilTerran> assuming you mean pointwise abs-ing, which'd make sense
07:13:56 <marshmallows> abs = undefined ?
07:13:58 <oerjan> as long as you don't expect it to have any other particular meaning for anything non-constant
07:14:19 <oerjan> yeah, undefined is a definite possibility :)
07:14:29 <EvilTerran> ivan_, if you're writing a Num instance, you could just make abs = error "does not make sense for this type"
07:14:39 <ivan_> EvilTerran: yes i believe so too, so can i just ignore the abs and set it as undefined or what should i do =)
07:15:00 <marshmallows> Beelsebob: Anyway I just find that an odd parse since the syntax and semantics of some code are usually two different things
07:15:07 <ivan_> EvilTerran: but when is abs used i am using the ordinary operations on my polynomial + - *
07:15:35 <EvilTerran> ivan_, well, if you define meanings for each of the other methods, abs will never be used unless you call it directly
07:15:46 <EvilTerran> even if you don't do so, i suspect
07:15:46 <Beelsebob> marshmallows: hmm? All I'm trying to get is narry applications
07:16:02 <EvilTerran> (but you'll have to. never mind, ignore me)
07:16:11 <Beelsebob> (if true "it's true" "it's false") instead of (((if true) "it's true") "it's false")
07:16:16 <marshmallows> It seemed like you wanted your parser to do currying
07:16:22 <ivan_> EvilTerran: okay thx, this is for a project, i hope they dont tear mee down because of this =)
07:16:28 <Beelsebob> marshmallows: indeed I do
07:16:41 <EvilTerran> i doubt it, ivan_. give a descriptive error message, it'll be fine. :)
07:17:25 <marshmallows> I'd say that's a slightly tricky thing to do without reward, if your parser returned a read expression (a list) then you could write a function 'prepare' or somesuch that did currying, took macros into account .. etc..
07:17:38 <EvilTerran> marshmallows, i think he has it working now anyway. :P
07:17:49 <Beelsebob> marshmallows: there won't be any macros here at all
07:17:56 <Beelsebob> it's a really really simple language
07:18:02 <xerox> ivan_: it makes sense to use abs = degree ? it has some nice properties
07:18:10 <ivan_> EvilTerran: it works like a charm, now i can type x^3 + 5 +2 - 1 and get polynomials =)
07:18:16 <EvilTerran> whee
07:18:17 <marshmallows> ok but in general, it's nice to have code which can be generalized
07:18:18 <Beelsebob> in fact, it's entire syntax consists of application, lambda expressions, letrec, identifiers, strings and numbers
07:18:35 <marshmallows> booleans?
07:18:45 <ivan_> xerox: yea that could be a nice usage =)
07:18:46 <Beelsebob> nope
07:18:52 <Beelsebob> booleans are lambda expressions
07:18:54 <xerox> ivan_: is it parametrizable by the field of its coefficients?
07:19:03 <delYsid> How would I write a function that caluclates the real duration of a note given the rational and the number of dots?
07:19:10 <skorpan> you fool ivan_!
07:19:11 <delYsid> I am talking musical notation here?
07:19:14 <Beelsebob> true is a built in that's bound to (\t -> (\f -> t)) marshmallows
07:19:19 <ivan_> xerox: yeas, least sign, to most
07:19:23 <marshmallows> ok
07:19:47 <xerox> ivan_: sorry? I mean, can I have polynomials over finite fields with your code?
07:20:16 <Beelsebob> marshmallows: I'm doing a bit of re-implementing of a final year project
07:20:30 <Beelsebob> so far 4600 lines of C -> 83 lines of Haskell
07:20:40 <marshmallows> hehehe
07:20:43 <marshmallows> This is good
07:21:11 <ivan_> xerox: yes you define 1 + x^3 as [1,0,0,1]
07:21:43 <ivan_> xerox: is that what you mean?
07:21:46 <xerox> no.
07:22:04 <ivan_> give me an example then =)
07:22:07 <xerox> I want the entries of your list to belong to structures like Z/Zp
07:22:15 <xerox> ...and not just R.
07:22:29 <oerjan> delYsid: 2 - 2^^(-n) gives the adjustment i think
07:22:46 <oerjan> http://en.wikipedia.org/wiki/Note_value
07:22:46 <lambdabot> Title: Note value - Wikipedia, the free encyclopedia
07:23:38 <oerjan> (to be multiplied by the original)
07:24:15 <ivan_> xerox: no it just works for real
07:40:54 <fasta> Setup.lhs: At least the following dependencies are missing: base -any
07:41:46 <fasta> How can base-any be missing?
07:42:14 <fasta> I have base-3.0 according to ghc-pkg list
07:49:45 <Saizan> fasta: weird, which package?
07:50:02 <fasta> Saizan: an old test package of my own
07:50:20 <fasta> Saizan: it worked the last time (months ago)
07:51:02 <Saizan> can you paste the .cabal file?
07:53:17 <fasta> Saizan: http://paste.debian.net/51306
07:54:47 <fasta> Another issue is the use of pkg-config. Is that still not possible in Cabal? It seems one would need to dynamically generate a Cabal file and run that to make it work.
07:57:43 <Saizan> fasta: i'm pretty sure you can access pkg-config from cabal
07:58:06 <unenough> ffmpeg has the messiest code i've ever seen
07:58:17 <Saizan> however that .cabal file works in cabal head
07:58:24 <unenough> maybe i'll re-implement it in haskell...but then again, patent problems.
07:58:28 <fasta> Saizan: I am also not sure of what version of Cabal I am running. I requested that feature and it was implemented in a development version, but I haven't done a lot with Cabal for some time.
07:59:02 <fasta> unenough: the patent problems won't be larger in Haskell.
07:59:18 <EvilTerran> unenough, don't look at the mplayer source, then. your head will explode.
07:59:30 <Twey> Heh
07:59:30 <unenough> yes, but it's not worth spending time on a project with problems from the beginning
07:59:39 <unenough> EvilTerran, my head has already IMploded from ffmepg
08:00:18 <fasta> unenough: there are no such patent problems in Europe, yet.
08:00:38 <Saizan> fasta: it also works with Cabal-1.2.3.0, which is the one that comes with 6.8.2 iirc
08:00:44 <unenough> yet
08:01:16 <Beelsebob> has anyone got any experience of calling python from Haskell?
08:01:38 <fasta> unenough: your actions might influence these processses
08:02:09 <fasta> processes*
08:02:44 <fasta> Saizan: I run a non-released version from dec. 2007
08:04:09 <fasta> Is there any Linux distribution with GHC-6.8?
08:04:36 <Saizan> gentoo, maybe?
08:05:00 <fasta> I guess FreeBSD has it too (yes, I know that's not Linux).
08:05:04 <Twey> Gentoo ~arch has it at least
08:05:43 <skorpan> arch has it
08:05:43 <Twey> Yeah, only ~arch
08:05:48 <skorpan> arch linux that is
08:06:27 <unenough> ubuntu+1 but with dependency problems
08:06:42 * Saizan is happy with releases on haskell.org/ghc
08:06:56 <resiak> Debian Sid
08:07:12 <Saizan> resiak: in the main repos?
08:08:10 <Twey> Sid is unstable, so yeah, probably
08:08:54 <fasta> Yes, unstable has it.
08:09:23 <desegnis_> fasta: Ubuntu Hardy, to be released next month, will have 6.8.2 in the repositories
08:09:51 <fasta> If everyone could just use the same distribution... :)
08:11:31 <mae> hello my people
08:11:52 <mae> power to the people!
08:12:07 <Mike41> HELLO
08:15:24 <Mike42> HELLO
08:15:37 <marshmallows> HI
08:19:50 <mae> we will overcome the oppressors my brothers
08:19:58 <mae> C++, Java, FORTRAN
08:20:07 <mae> we will bring power to the people!
08:20:09 <marshmallows> I'm glad you didn't list ALGOL
08:20:37 <fasta> kick/ban?
08:25:05 <EvilTerran> Mike41, are you actually going to say anything relevant, or just shout greetings?
08:25:59 <fasta> EvilTerran: same for mae...
08:26:17 <marshmallows> fasta, not sure if you are helping SNR
08:26:33 <fasta> marshmallows: define SNR and we can talk
08:26:35 --- mode: ChanServ set +o allbery_b
08:27:36 <fasta> marshmallows: well?
08:28:15 <oerjan> @go SNR
08:28:16 <lambdabot> http://en.wikipedia.org/wiki/Signal-to-noise_ratio
08:28:16 <lambdabot> Title: Signal-to-noise ratio - Wikipedia, the free encyclopedia
08:29:49 <oerjan> and mae may be a regular
08:29:52 <fasta> marshmallows: I haven't _ever_ seen you talk here.
08:30:23 <mae> yeah i'm pretty regular all right, as long as i take my metamucil and prune juice
08:30:50 <oerjan> mae: ok now you are _really_ not helping :D
08:30:58 <fasta> That seems a very bot like response.
08:31:20 <oerjan> marshmallows had a long on-topic conversation earlier
08:32:55 <mae> oerjan: ;) i think everyone could use a good purging every now and then, luckily, thats why i'm a firm believer in haskell. no sideffect enemas needed, no imperative blockage! just pure organic functional goodness, whole grain high order functions, and vitamin monad
08:37:48 <mae> so, anyone play with happs lately? it uses a ton of ghc extensions but is has a heart of gold
08:41:47 <shevy> are monads like the mojo of a haskell program?
08:42:54 <mae> thats an interesting argument
08:43:09 <roconnor> shevy: not really
08:43:11 <mae> i would say, the mojo simply is
08:43:23 <mae> as in, implicitly it is there
08:44:35 <mae> because a programmer has to, in the first place, have a gargantuan amount of mojo to create something useful/practical with haskell in the first palce
08:44:36 <mae> place *
08:45:04 <shevy> hehe
08:45:12 <mae> so the mojo of the programmer shines forth through the code, haskell is transparent and anti-magical / anti-climactic
08:46:04 <mae> if you give a haskell interpreter to a dolt, you will simply note that the primitive programmer will curse and bang his hands primitively on the keyboard in frustratikonm
08:47:07 <mae> so mojo in the first place and haskell programs _with_ mojo, are circular dependencies
08:47:45 <mae> so in short, if you don't have mojo, haskell will not create any mojo for  you, but will tell you to your face what an idiot you are
08:48:04 <mae> at least thats how i feel when the inferencing engine screams at me ; )
08:48:37 <gour> hi, i plan to work on bindings for ephemeris (planetary positions) library. any suggestion for appropriate category?
08:49:16 --- mode: allbery_b set -o allbery_b
08:50:08 <mae> shevy: shall we blog battle this ot conversation out? enguarde ye brigande!
08:50:26 <shevy> i am kinda overwhelmed already
08:50:33 <roconnor> gour: "physics" perhaps for now?
08:51:11 <roconnor> gour: and certainly "Foreign"
08:53:03 <gour> roconnor: hmm, i was thinking about eg. astronomy, but there is no foreign in hacakge :-/
08:53:08 <gour> *hackage
08:53:19 <roconnor> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Foreign
08:53:22 <lambdabot> http://tinyurl.com/yqov7f
08:53:32 <roconnor> astronomy sounds better than physics
08:54:24 <gour> strange...i missed it somehow
08:54:36 <gour> so Foreign.Astronomy...thanks
08:55:07 <roconnor> gour: oh wait, are you looking for hackage categories, or module namespaces?
08:55:20 <gour> both
08:56:15 <roconnor> I don't know what would make a good name space.   Maybe Ephemeris
08:56:31 <gour> roconnor: ahh, you think about Foreign as hackage category and Astronomy for namespace
08:57:02 <roconnor> I was thinking about Foreign and Astronomy as categories, and wasn't thinking namespace at all.
08:57:14 <gour> huh
08:57:31 <roconnor> hackage packages can have more than one category
08:57:39 <gour> then i'll go with Astronomy as hackage category
09:02:34 <Cheery> is it possible to convert haskell programs into joy?
09:02:49 <Cheery> I mean, do you know the exact algorithm for that?
09:04:35 <Cheery> it's an attracting approach
09:05:06 <marshmallows> approach to what?
09:06:12 <Cheery> to executing better fp languages
09:07:29 <marshmallows> I don't understand
09:08:37 <roconnor> what is joy?
09:08:57 <marshmallows> the language which put me off stacky languages forever
09:22:37 <petekaz> Got a question on how to report errors.
09:22:42 <petekaz> http://hpaste.org/6412
09:23:14 <petekaz> I am writing a simple csv parser, and in the 'parse' function, I call 'error' in two places.
09:23:38 <marshmallows> @instances MondError
09:23:38 <lambdabot> Couldn't find class `MondError'. Try @instances-importing
09:23:40 <marshmallows> @instances MonadError
09:23:41 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
09:23:42 <petekaz> But this just seems wrong, so I thought I'd try to make my parse function work with Either.
09:23:49 <marshmallows> @src MonadError
09:23:49 <lambdabot> class (Monad m) => MonadError e m | m -> e where
09:23:49 <lambdabot>     throwError :: e -> m a
09:23:49 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
09:24:03 <marshmallows> petekaz: You could perhaps use this instead?
09:24:24 <petekaz> But the Either code makes everything look messy and now my code stack overflows.
09:24:42 <petekaz> I don't understand marshmallows.
09:28:13 <marshmallows> wy, did you see my invite?
09:28:30 <wy> marshmallows: what invite?
09:29:08 <Saizan> petekaz: Either is a monad, so you could use that to ease the messiness, as for the stack overflow it's another matter
09:29:44 <petekaz> Saizan: it's the 'case' statements in the above paste in the 'parse' function that I dislike.
09:29:52 <petekaz> How do I clean that up?
09:30:37 <petekaz> My code works well (no stack overflow) until I added the Either monod.
09:30:41 <petekaz> s/monod/monad
09:31:06 <nolrai_> can I use cabal to instal the parsec libs?
09:31:09 <Toxaris> petekaz: you could use the monadic interface of either to avoid the case statements (that's one of the points of the monadic interface)
09:31:46 <petekaz> Could you show me how one of the parse statements should look?
09:31:50 <Toxaris> petekaz: but if you're new to monads, it may be a good idea to do something about the stack overflow first, since the explicit but ugly version may be easier to debug for a start
09:32:40 <petekaz> instead of http://hpaste.org/6412#a1, what would it look like?
09:33:26 <Saizan> petekaz: http://hpaste.org/6412#a2
09:33:31 <petekaz> Toxaris: I think 'error' is more appealing right now, no stack overflows and code looks nicer :-)
09:34:10 * Toxaris writes a short example for petekaz 
09:34:18 <skorpan> anyone familiar with vty here? i get: game: user error (clrscr realloc)
09:34:27 <nolrai_> isnt error just either?
09:34:36 <petekaz> I had that at first, but I goofed as I thought I needed to have "Right r <- parse [] rest
09:35:07 <Saizan> petekaz: or even 'fmap (reverse current :) (parse [] rest)'
09:35:25 <Saizan> ?type error -- nornagon
09:35:26 <lambdabot> forall a. [Char] -> a
09:35:32 <Saizan> err, nolrai_
09:36:54 <nolrai_> saizan: yes?
09:37:08 <petekaz> so where does the stack overflow get introduced now?  Every place I had 'Right $ somethnig' I tried to change it to 'Right $! something'
09:37:26 <Saizan> nolrai_: error is not the same as either in this context
09:38:39 <nolrai_> Why not? (and we are talking about Error and Either, right, not the functions?)
09:39:50 <Saizan> nolrai_: because we're talking of error the function, see the paste :)
09:39:51 <desegnis> nolrai_: Different names, different types, different behaviour. So they are not the same ;)
09:40:01 <Toxaris> hpaste failed to announce my annotation of petekaz' hpaste at http://hpaste.org/6412#a3
09:40:10 <nolrai_> ah
09:40:26 <nolrai_> Are there any good tutorials on arrows?
09:41:18 * kowey hangs his head (the wikibook one isn't too helpful, because I never got around to working them out myself)
09:41:31 <solrize_> i was about to say the wikibook isn't that bad
09:41:58 <petekaz> Toxaris: I like the <$>!
09:42:41 <kowey> I only got as far as knowing how to use the arrow operators for tuple-hacking
09:42:49 <Saizan> petekaz: unsing Either makes it stricter since you've to know that the rest of the parse succeeded before you can cons anything to it, instead with error the head of the list can be consumed before entering the recursive call
09:43:20 <kowey> and shakily understanding the point of the arrow-based parsers (very shakily)
09:43:20 <Saizan> petekaz: so the aim is to recover laziness, not to make things stricter
09:43:40 <petekaz> Saizan: which is the reason I wrote this.  All the CSV parsec parsers had to consume all of the input first, I needed something that could work lazily.
09:44:02 <nolrai_> kowey: and thats exactly what i want to look at.
09:44:27 <kowey> well, give it a try, then : http://en.wikibooks.org/wiki/Haskell/Understanding_arrows
09:44:27 <lambdabot> Title: Haskell/Understanding arrows - Wikibooks, collection of open-content textbooks
09:44:28 <petekaz> because I have some very large csv files, and they have quoted cells that extend lines so the usual trick of feeding lines to parsec doesn't work.
09:44:36 <kowey> it doesn't really tell you how to make use of arrows (yet)
09:44:47 <kowey> and please improve it
09:45:10 <petekaz> Saizan: so how do I recover laziness while having some decent error reporting mechanism?
09:45:18 <petekaz> or do I just stick with 'error'?
09:45:23 <kowey> see also http://en.wikibooks.org/wiki/Haskell/Arrows (which comes right before it and introduces the notation)
09:45:23 <lambdabot> Title: Haskell/Arrows - Wikibooks, collection of open-content textbooks
09:45:39 <kowey> unfortunately, we haven't really linked up the two chapters yet
09:47:21 <nolrai_> kowey++
09:48:40 <Saizan> petekaz: i guess you could use an internal Writer to accumulate partial results
09:49:15 <mnislaih> @seen dcoutts_
09:49:15 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-overflow, #ghc and #haskell. I don't know when dcoutts_ last spoke.
09:49:45 <Saizan> petekaz: so it becomes parser :: String -> String -> ErrorT String (Writer [String]) ()
09:50:18 <petekaz> I guess I better read that page on how to use monad transformers now :-)
09:50:37 <petekaz> I'll stick with the 'error' for now, this suddenly has become very complicated.
09:50:43 <Saizan> but i suggest parser :: String -> String -> ErrorT String (Writer (Endo [String]) ()
09:51:01 <marshmallows> I thought Monad Transformer stacks made code a lot simpler in my cases
09:51:20 <marshmallows> petekaz: This is a good text about it http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
09:51:26 <lambdabot> Title: Monad Transformers Step by Step
09:51:43 <petekaz> marshmallows: thanks.
09:52:57 <marshmallows> has anyone written a WAM or BAM is haskell?
09:53:00 <marshmallows> in*
09:53:03 <Saizan> but i guess there's a way to rearrange recursion and keep using simple Either
09:58:35 <petekaz> maybe I should just have a function that will read the next row from a file handle in a strict manner.
09:59:09 <marshmallows> how about a lazy list of lines?
09:59:22 <marshmallows> then that function is easy to write: tail
09:59:43 <marshmallows> or head&&&tail or something
10:00:24 <Toxaris> petekaz: what is the general structure of your data? a csv with very large cells including \n in quoted cells? and you want to process that to a [[String]]-table?
10:00:30 <Saizan> ?src span
10:00:30 <lambdabot> Source not found.
10:00:40 <Saizan> ?src break
10:00:40 <lambdabot> break p =  span (not . p)
10:01:45 <Saizan> ?check \xs p -> span p (xs :: [Int]) == (takeWhile p xs, dropWhile (not . p) xs)
10:01:47 <lambdabot>  Falsifiable, after 0 tests: [1], <Int -> Bool>
10:02:02 <Saizan> ?check \xs p -> break p (xs :: [Int]) == (takeWhile p xs, dropWhile (not . p) xs)
10:02:03 <lambdabot>  Falsifiable, after 2 tests: [1,2], <Int -> Bool>
10:02:29 <RayNbow> http://www.foomongers.org.uk/videos/spj-typedriventestinginhaskell.html <-- hmm, does anyone recognize the shell/editor SPJ is using in this presentation?
10:02:31 <petekaz> Okay, here is what I was trying to accomplish: I have a 50MB csv log file that does have rows with some quoted cells that extend over multiple lines.  I just want to selectively read the file, and pull out some rows that match some criteria.
10:02:31 <lambdabot> Title: Type-driven testing in Haskell (Simon Peyton Jones), http://tinyurl.com/2u2mtq
10:02:50 <RayNbow> (somewhere between the 30th and 40th minute)
10:03:30 <petekaz> So here is some sample input: http://hpaste.org/6412#a4
10:04:05 <petekaz> I want to print a row out that parses the cell with the key=value statements.
10:05:32 <petekaz> and this is my desired output: http://hpaste.org/6412#a5
10:06:26 <petekaz> And, yes, the keys will be the same across multiple entries in the log, so I could easily just use a regexp to do this, but I thought it would be a good learning experienc.
10:08:34 <Lycurgus> there's no known attempt to rework yi as an emacs mode is there? Or other high function haskell emacs mode?
10:08:59 <petekaz> And before this code, I had played around with versions that use foldl', foldr, oleg like enumerator, etc ... so I could see how each did not work (stack overflows, using too much memory, etc ...).
10:09:34 <Toxaris> petekaz: I would either write a simple parser which searchs for ", name=value"-lines
10:09:40 <petekaz> those are here: http://hpaste.org/6412#a6  But in the end, the code we've been looking at seemed to work the best, small memory footprint, and was lazy.
10:11:14 <petekaz> Toxaris: Yeah, I could do that, but I thought I'd first just write the csv parser as I could not find any lazy ones out there.  All of the parsec ones read everything into memory first, and then the other csv parsers I found don't handle the case where quoted cells extend over multiple lines.
10:11:28 <Toxaris> petekaz: or I would write a csv parser with a lazier type then String -> Either String [[String]], e.g. String -> [Either String [String]] or even String -> [[Either String String]]
10:11:44 <Philippa> petekaz: you can probably run the parsec ones with parsec3 and an appropriate stream and get lazy input that way
10:12:20 <petekaz> Philippa: parsec3 does not require all of the input to be read into memory first?
10:12:25 <Philippa> right
10:12:27 <Saizan> Philippa: won't it consume all the input before you can look at the result anyway?
10:12:28 <petekaz> Great!
10:12:36 <Toxaris> petekaz: what's the problem with loading 50MB into memory, maybe as a strict bytestring to avoid [Char] overhead? do you plan to use this code on your cellphone?
10:13:00 <Philippa> Saizan: Not as much as you'd think, though IIRC the many combinator's strict which does suck
10:13:05 <petekaz> Toxaris: what happens if the file sizes get larger and larger, I want something that can handle it efficiently.
10:13:20 <Toxaris> petekaz: :)
10:15:06 <petekaz> Learning haskell is a funny thing.  This lazy vs strict vs performance of one's program adds a whole other dimension to things.  My brain is hurting.
10:16:17 <gwern> correctness, then performance
10:17:21 <petekaz> Philippa: so parsec3 is kinda lazy?
10:17:22 <Philippa> gwern: we're talking about a problem where correctness is well understood and performance is still trickier than it probably should be to obtain
10:17:41 <Philippa> parsec3 is parameterised on the input stream and can make lazier use of it as a result
10:17:43 <solrize_> programs that are supposed to be fast, are incorrect if they are slow :)
10:17:46 <Philippa> though the [] stream is no lazier
10:17:48 <petekaz> this would be a good excuse to learn how to use parsec.
10:18:13 <solrize_> petekaz i thouhgt you WERE using parsec
10:18:14 <Philippa> the other problem (and it's a much bigger one) is that the many combinator is still strict with no lazy version. IMO a lazy version should be added
10:18:20 <gwern> Philippa: ah
10:18:38 <solrize_> last nite i was looking at a haskell packrat parser
10:18:51 <Saizan> Philippa: why is it strict?
10:18:53 <solrize_> and thinking maybe it makes more sense than parsec for some languages
10:19:19 <Philippa> Saizan: you get a potential memory leak otherwise
10:19:38 <petekaz> solrize_: no, I had read that parsec would read all of my input into memory first which is not desired as the log files could get very large.
10:19:40 <Philippa> solrize: sure. Parsec'll parse anything, but it won't necessarily be the most efficient way to do it
10:20:22 <Philippa> FWIW, with a hand-cranked 'many' xerox had parsec3 w/a lazy bytestring using a v.small heap on large data
10:20:46 <solrize_> cool
10:20:56 <solrize_> is there any way to use bytestrings on unicode ?
10:21:06 <Toxaris> *CSV> csv "a, \"12\n34\n56\", c\n1,2,3"
10:21:06 <Toxaris> [["a"," \"12"],["34"],["56\""," c"],["1","2","3"]]
10:21:17 <Toxaris> petekaz: I don't understand what your csv functions does ...
10:21:19 <gwern> solrize_: not yet, iirc
10:21:28 <solrize_> gwern :(
10:21:36 <solrize_> thanks
10:21:41 <petekaz> Toxaris: which one?  my very first post?
10:21:55 <marshmallows> > fix (show.(:[]))
10:21:56 <lambdabot>  "[\"[\\\"[\\\\\\\"[\\\\\\\\\\\\\\\"[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"[\\\\\\\...
10:22:00 <Toxaris> petekaz: both from your first post, with respect to the example I just posted here
10:22:05 <gwern> I've heard people suggest it as a SoC project, but I wouldn't hold my breath
10:22:36 <Toxaris> petekaz: I expected [["a", "12\n34\n56", "c"], ["1", "2", "3"]]
10:22:46 <Saizan> solrize_: just handle encodings yourself, there's also a library somewhere
10:22:47 <petekaz> Toxaris: oh, get rid of the whitespace around the commas.
10:23:02 <solrize_> saizan i guess i could look for a lib, but it's a messy subject
10:23:44 <solrize_> and the encoding library would have to be written with the same kinds of tricks as the bytestring lib to not be slow
10:24:02 <gwern> something about Word8 not including enough bytes to handle all unicode points, and bytestring not handling the variable encoding of utf-8 or something...
10:25:02 <Saizan> well it really depends on what operations you need on a "unicode" bytestring
10:25:32 <Peaker_> the visualized social network is cool, does it look for nicks that said stuff to other nicks at least once?
10:25:45 <Saizan> e.g. length should return the number of charaters rather than octects? than it's trickier
10:26:07 <Saizan> Peaker_: yes
10:27:00 <solrize_> saizan i guess normalizing them to NFKC would be a start
10:27:19 <solrize_> i have a bunch of data that uses a mixture of accented codes, and composed diacritics
10:28:57 <skorpan> is there any way in Vty to simply clear the screen and output a simple image with the rest of the window filled with "empty"?
10:29:02 <nolrai_> when I try to install any cabal packages I get the folowing message:
10:29:35 <nolrai_> <interactive>: /usr/local/lib/Cabal-1.2.3.0/ghc-6.8.2/HSCabal-1.2.3.0.o:
10:29:44 <nolrai_> unknown symbol `prettyzm1zi0zi0zi0_TextziPrettyPrintziHughesPJ_lvl19_closure'
10:30:00 <nolrai_> ghc-6.8.2: unable to load package `Cabal-1.2.3.0'
10:30:16 <atp> that's not a very pretty symbol, eh
10:30:26 <nolrai_> any ideas?
10:30:35 <atp> no clue :(
10:30:41 <nolrai_> atp: no its not.
10:31:23 <esteth> how would i "typecast" a String to a num ?
10:31:32 <mauke> esteth: read
10:31:45 <Deewiant> RayNbow: looks like emacs, but I'm not sure as I don't use it myself
10:32:14 <Baughn> nolrai_: I see a lot of those. I think it may be due to a version mismatch somewhere, but typically my solution is to wipe and reinstall.
10:32:25 <Baughn> Keeping cabal-install around makes that a lot faster these days. ;)
10:32:27 <esteth> mauke: Thanks :)
10:32:33 <nolrai_> reinstall how much?
10:32:45 <Baughn> GHC, and all haskell libraries
10:32:47 <nolrai_> arrg thats what im trying to install
10:33:05 <nolrai_> (cabal-install - that is)
10:33:28 <Baughn> nolrai_: And you had to install a newer version of cabal to do it, yes?
10:33:51 <nolrai_> well no.
10:35:06 <nolrai_> Ive only installed cabal once, yesterday. so unless it changed since then?
10:35:17 <Baughn> It comes with ghc, you know
10:35:32 <Baughn> *Any* manual install of cabal can cause trouble. Though lots of people claim it won't.
10:35:37 <nolrai_> cabal does?
10:35:55 <Baughn> More generally, updating packages - especially if you keep the old version around
10:36:52 <nolrai_> does cabal-install help with that problem?
10:36:52 <Baughn> ALthough I'm not sure about what caused your problem
10:37:00 <Baughn> No, it just makes reinstalls faster
10:37:43 <Baughn> It seems to be missing a symbol from the Text.PrettyPrint.HughesPJ package.. have you updated anything /at all/?
10:37:50 <Baughn> Since you installed ghc, I mean
10:38:34 <Baughn> nolrai_: What does ghc-pkg|grep pretty say?
10:38:42 <nolrai_> well ive been installing the packages that cabal-install needs is it posible that one of them was already there and got messed up?
10:38:57 <Baughn> I.. don't /think/ so...
10:39:17 <Baughn> nolrai_: See, this is why my solution is "wipe and reinstall". I don't really understand the issues.
10:39:51 <Baughn> nolrai_: Are you using a self-installed copy of ghc, or something from your distro?
10:40:11 <Baughn> nolrai_: Oh, right. ghc-pkg -l|grep pretty
10:40:20 <nolrai_> ubuntu is still like 6.3 or somthing so its self installed
10:41:27 <nolrai_> oh well, what exactly do I need to wipe before reinstalling?
10:42:02 <Baughn> nolrai_: Unless you installed anything /else/ in there, "sudo rm -r /usr/local/*; rm -r ~/.ghc ~/.cabal" should do
10:42:26 <nolrai_> thanks
10:42:45 <Baughn> nolrai_: Hm. Say, you haven't altered your umask (from the default 0022), have you?
10:43:20 <nolrai_> I dont know what that is so i would guess no, but..
10:43:39 <Baughn> It'll tell you if you run umask
10:44:07 <nolrai_> its 0022.
10:44:30 <Baughn> Shouldn't be any issues from /that/, then
10:46:46 <nolrai_> and now i cant find where i installed ghc
10:47:15 <Baughn> You installed it in /usr/local, I should hope
10:47:46 <nolrai_> no its not there, i used the defaults.
10:48:29 <Baughn> The default puts it in /usr/local. Which you just deleted, right?
10:49:10 <nolrai_> but when it tryed to delete it it wasnt there and i can still run ghci.
10:49:25 <Baughn> Hm. Run which ghci
10:49:58 <nolrai_> your right its the old one 6.6.
10:50:07 <Baughn> Where is it?
10:50:35 <nolrai_> No idea
10:50:45 <Baughn> That's what which tells you
10:51:25 <nolrai_>  "/usr/bin/ghci"
10:51:35 <Baughn> ...I was afraid of that.
10:51:57 <Baughn> Okay. Now, hopefully it's in there because you've installed ubuntu's ghc package - you can uninstall that
10:52:21 <Baughn> If you say you installed ghc manually, you may have had /two/ copies installed. That could definitely cause trouble.
10:53:01 <nolrai_> that makes sense.
10:53:39 <Baughn> If you actually managed to install manually in /usr, you'll need to reinstall the /os/ to make sure it's clean. (Okay, not need, really..)
10:53:54 <Baughn> That's very unlikely, though, since you'd have to pass --prefix=/usr to the installer
10:54:50 <nolrai_> yeah i had ubuntus ghc installed and now that thats uninstalled it cant run ghci.
10:55:04 <nolrai_> so am i clean to reinstall ghc 6.8?
10:55:04 <Baughn> Or ghc, right?
10:55:12 <Baughn> If ghc is also gone, then yes
10:55:40 <nolrai_> yep "command not found".  Thanks a bunch!
10:55:47 <nolrai_> Baughn++
11:07:07 <skorpan> is there any difference in using "let" vs "where"?
11:07:20 <skorpan> is it only that "where" is only evaluated if it is needed?
11:07:36 <monochrom> let is too
11:07:38 <mauke> they're functionally equivalent
11:07:49 <skorpan> okay thanks
11:08:06 <monochrom> let is an expression.  where is something attached to a definition.
11:12:33 <ilyak_> How should I say \x -> x - 1?
11:12:45 <marshmallows> subtract 1
11:12:56 <mauke> pred
11:13:09 <monochrom> subtract 1 is more faithful.
11:13:11 <ilyak_> orly
11:13:26 <monochrom> :type [\x -> x - 1, subtract 1]
11:13:30 <monochrom> @type [\x -> x - 1, subtract 1]
11:13:31 <lambdabot> forall a. (Num a) => [a -> a]
11:13:37 <monochrom> @type [\x -> x - 1, pred]
11:13:38 <lambdabot> forall a. (Enum a, Num a) => [a -> a]
11:13:42 <monochrom> see?
11:13:52 <mauke> therefore pred is better!
11:13:55 <marshmallows> :t pred
11:13:57 <lambdabot> forall a. (Enum a) => a -> a
11:13:58 <marshmallows> :t subtract 1
11:14:00 <lambdabot> forall t. (Num t) => t -> t
11:14:02 <marshmallows> :t \x -> x - 1
11:14:03 <lambdabot> forall a. (Num a) => a -> a
11:14:44 <mauke> > pred pi
11:14:44 * monochrom practices type-oriented programming, is sensitive to subtle type differences.
11:14:44 <lambdabot>  2.141592653589793
11:14:59 <mauke> > pred 'Ï€'
11:15:00 <lambdabot>  Improperly terminated character constant at "'Ï€'" (column 6)
11:15:28 <mauke> > pred '\x3C0'
11:15:29 <lambdabot>  '\959'
11:15:50 <Syzygy-> > pred 'x'
11:15:51 <lambdabot>  'w'
11:21:42 <akor_> trying to learn haskell... why does evaluating fibonacci sequence become so slow after say fibo 30.. ive defined it as fibo n = fibo (n-2) + fibo (n-1)
11:22:19 <akor_> would think its still quite simple what ghci has to do ?
11:22:22 <Baughn> akor_: Haskell doesn't automatically memoize, and you're calculating it very inefficiently
11:22:22 <xerox> That is because the call tree becomes huge as your n increases.
11:22:26 <smg> uh
11:22:26 <marshmallows> akor: because it's recomputing so much
11:22:29 <smg> @type (+++)
11:22:30 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
11:22:34 <smg> @type (<|>)
11:22:35 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
11:22:43 <mauke> akor_: because 2^30 is a really big number
11:22:51 <Baughn> > let fib 0 = 1; fib n = fib (n-2
11:22:51 <lambdabot> Unbalanced parentheses
11:23:10 <mauke> Baughn: needs more base cases
11:23:12 <Baughn> > let fib 0 = 1; fib 1 = 1; fib n = fib (n-2) + fib (n-1) in fib 4 :: Expr
11:23:13 <lambdabot>  1 + 1 + (1 + (1 + 1))
11:23:19 <Baughn> > let fib 0 = 1; fib 1 = 1; fib n = fib (n-2) + fib (n-1) in fib 8 :: Expr
11:23:20 <lambdabot>  1 + 1 + (1 + (1 + 1)) + (1 + (1 + 1) + (1 + 1 + (1 + (1 + 1)))) + (1 + (1 + ...
11:23:31 <Baughn> It'd be nice to get more output
11:23:39 <marshmallows> @more Baughn
11:23:47 <marshmallows> ok that doesn't work.
11:23:48 <Twey> > let fibs = [ a + b | a, b <- zip fibs (tail fibs)] in take 10 fibs
11:23:49 <lambdabot>  Couldn't match expected type `Bool' against inferred type `Expr'
11:23:55 <Twey> :<
11:23:58 <smg> so <|> is chocie for parsers
11:24:01 <mauke> Twey: ( )
11:24:01 <xerox> It's fibs time!
11:24:02 <smg> what is +++ ?
11:24:04 <Twey> > let fibs = [ (a + b) | (a, b) <- zip fibs (tail fibs)] in take 10 fibs
11:24:05 <lambdabot>  Exception: <<loop>>
11:24:11 <Twey> Argh.  Yeah.
11:24:12 <hallongrottan> haha
11:24:16 <Baughn> smg: Concatenation, iirc
11:24:17 <monochrom> akor_: we all love haskell, but nothing in the world can mitigate blatantly stupid algorithms.
11:24:18 <akor_> huh :P
11:24:18 <Twey> No looping in lambdabot.
11:24:21 <Baughn> smg: "First this, then that"
11:24:23 <mauke> > fix (join (.) (1 :) . ap (zipWith (+)) tail)
11:24:23 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
11:24:33 <Twey> Why is there no looping in lambdabot?
11:24:34 <marshmallows> > map fst $ iterate (uncurry (+)) $ (0,1)
11:24:34 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a, a)
11:24:35 <lambdabot>       Expec...
11:24:46 <mauke> Twey: ?
11:24:46 <smg> Baughn: so also a parser thing?
11:24:49 <xerox> > fix (join (.) (1:) . ap (zipWith (+)) tail) !! 10000
11:24:50 <lambdabot>  5443837311356528133873426099375038013538918455469596702624771584120858286562...
11:24:51 <Baughn> akor_: Your fib implementation will run just as slowly in haskell as it would in (nearly) any other language
11:24:57 <Baughn> smg: Possibly. I could be mistaken.
11:25:01 <smg> k
11:25:01 <marshmallows> > map fst $ iterate (\x,y->(y,x+y)) $ (0,1)
11:25:01 <lambdabot>  Parse error at ",y->(..." (column 22)
11:25:04 <Heffalump> Twey: lambdabot is telling you that your code has an infinite loop
11:25:05 <marshmallows> > map fst $ iterate (\x y->(y,x+y)) $ (0,1)
11:25:05 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1
11:25:05 <lambdabot>     Probab...
11:25:13 <Baughn> smg: I do know that several other libraries also define (entirely different) +++ operators
11:25:17 <marshmallows> > map fst $ iterate (\(x,y)->(y,x+y)) $ (0,1)
11:25:17 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:25:17 <Heffalump> mainly because you forgot the 0:0 at the front.
11:25:28 <monochrom> There is also one based on scanl
11:25:32 <smg> (+++) first apply parser 1 if it fails apply parser 2
11:25:40 <smg> but isn't that the same aus using <|> ?
11:25:47 <Twey> > let fibs = 0 : 1 : [ (a + b) | (a, b) <- zip fibs (tail fibs)] in take 10 fibs
11:25:53 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
11:25:53 <akor_> yeah i guess i dont understand how it tries to evaluate it
11:25:55 <Twey> Ah
11:26:02 <Twey> Heffalump: Oh, OK.
11:26:07 <Deewiant> > let f = scanl (+) 1 f in f
11:26:14 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
11:26:21 <Deewiant> d'oh
11:26:24 <Twey> Why has no-one yet defined the ++++++++++++ operator, I wonder.
11:26:25 <marshmallows> > iterate (join (+)) 1
11:26:35 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
11:26:39 <xerox> > let fibs = scanl (+) 1 (1 : fibs) in fibs
11:26:40 <Deewiant> > let f = 0:scanl (+) 1 f in f
11:26:45 <wagle_home> ++++++++++++
11:26:54 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
11:26:56 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:27:12 <wagle_home> @karma ++++++++++
11:27:12 <lambdabot> ++++++++++ has a karma of 2
11:27:14 <Twey> Deewiant: Nice
11:27:34 <Deewiant> @pl f = 0:scanl (+) 1 f
11:27:34 <lambdabot> f = fix ((0 :) . scanl (+) 1)
11:27:35 <marshmallows> > extendSequence [0,1]
11:27:36 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:27:47 <Deewiant> marshmallows: cheater :-)
11:27:53 <Twey> @src extendSequence
11:27:53 <lambdabot> Source not found. Are you on drugs?
11:27:57 <Twey> Wassat?
11:28:02 <marshmallows> magic.
11:28:03 <Deewiant> Twey: it looks in OEIS
11:28:07 <marshmallows> > extendSequence [2,3,5,7]
11:28:22 <Deewiant> > extendSequence [1,11,21]
11:28:25 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
11:28:27 <lambdabot>  [1,11,21,31,41,51,61,71,81,91,2,12,22,32,42,52,62,72,82,92,3,13,23,33,43,53,...
11:28:31 <Twey> Oh, heh
11:28:38 <Deewiant> > extendSequence [1,11,21,1211]
11:28:38 <lambdabot>  [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,1321131112311...
11:28:50 <Twey> Why is the Fibonacci sequence the logical choice for [0, 1]?
11:29:00 <mauke> @help oeis
11:29:01 <lambdabot> oeis <sequence>. Look up a sequence in the Online Encyclopedia of Integer Sequences
11:29:24 <mauke> @oeis 1 3
11:29:28 <Twey> There's no sequence [0..] in the OEIS?
11:29:32 <lambdabot> Triangular numbers: a(n) = C(n+1,2) = n(n+1)/2 = 0+1+2+...+n.
11:29:34 <lambdabot> [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
11:29:49 <Twey> > extendSequence [0..]
11:29:54 <Twey> Er
11:29:55 <Deewiant> > extendSequence $ replicate 10 0
11:29:55 <lambdabot> Terminated
11:29:56 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
11:30:02 <Twey> No, that's not what I meant to do.  Heh
11:30:11 <smg> <Baughn> smg: I do know that several other libraries also define (entirely different) +++ operators <-- hehe
11:30:15 <smg> you read what i had written?
11:30:18 <Deewiant> > describeSequence $ replicate 10 0
11:30:19 <lambdabot>  Just "The characteristic function of 0: a(n) = 0^n."
11:30:25 <smg> (+++) first apply parser 1 if it fails apply parser 2
11:30:34 <smg> but that is exactly that was <|> does imho
11:31:12 <Baughn> smg: I don't see a +++ operator in the parsec documentation at all..
11:31:18 <ilyak_> Is there a function Int -> a -> [a] which repeats a Int times?
11:31:23 <akor_> with my definition.. how does it try to evaluate eg. fibo 4 ?
11:31:27 <marshmallows> ilyak: Yes
11:31:30 <ilyak_> oh, replicate
11:31:31 <marshmallows> ilyak: Deewiant just used it
11:31:32 <Deewiant> @ty replicate
11:31:33 <lambdabot> forall a. Int -> a -> [a]
11:31:34 <Deewiant> :-)
11:31:40 <Baughn> @hoogle Int -> a -> [a]
11:31:41 <lambdabot> Prelude.replicate :: Int -> a -> [a]
11:31:41 <lambdabot> Data.List.replicate :: Int -> a -> [a]
11:35:06 <smg> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-ParserCombinators-ReadPrec.html#v%3A%2b%2b%2b
11:35:07 <lambdabot> http://tinyurl.com/3a6z64
11:35:42 <Baughn> smg: Aha.
11:36:03 <Baughn> smg: Well, it doesn't do the same as <|> at all, then
11:36:41 <Toxaris> smg: there is not <|> for ReadPrec, is there?
11:36:57 <Toxaris> smg: so stating that (+++) == (<|>) doesn't make sense, since there's not <|>
11:37:53 <Toxaris> smg: but Parsec's (<|>) should do the same thing as ReadPrec's (<++)
11:38:26 <Toxaris> smg: and ReadPrec's (<++) can be expressed in Parsec as   a <++ b = try a <|> b
11:39:03 <SamB> ????
11:39:04 <byorgey> the 'try' is important though
11:39:41 <roconnor> @seen dons
11:39:41 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 10h 3m 30s ago.
11:39:59 <byorgey> smg: if you have a <|> b in Parsec, if a consumes any input and then fails, it doesn't backtrack.  so b won't match even if it could have.
11:40:01 <smg> i see thank you
11:40:20 <byorgey> whereas a +++ b tries them in parallel
11:40:20 <smg> byorgey: ah what can i use then to backtrack?
11:40:26 <byorgey> smg: 'try'
11:40:28 <smg> k
11:40:35 <smg> ty
11:41:08 <byorgey> it's a subtle difference but important =)
11:42:19 <roconnor> where can a paste images?
11:42:35 <solrize_> er, imageshack.us ?
11:42:36 <roconnor> I've been working on a GHC logo idea
11:43:06 <solrize_> upload to haskell wiki
11:43:10 <SamB> you could also upload to wiki, yes
11:43:17 <SamB> wiki is probably better
11:44:01 <SamB> since, you know, the image will stay there as long as you want...
11:45:56 <roconnor> http://img219.imageshack.us/img219/8290/lambdabpkr6.png
11:46:09 <roconnor> Actually, I'm not to sure I'm happy with the concept
11:46:24 <solrize_> interesting
11:46:36 <roconnor> but I thought I'd try it out.
11:46:41 <monochrom> nice connotation!
11:47:15 <roconnor> monochrom: yeah, I was thinking GHC, reliability, strong, etc.
11:47:16 <monochrom> "this is about calculated engineering, not about feeling good with your intuition"
11:47:52 <solrize_> i thought it was about typed lambda calculus, since it has all those typography measurements on the lambda :)
11:48:08 <roconnor> solrize_: :)
11:48:24 <roconnor> solrize_: nope, I was aiming for "blueprint"
11:49:15 <solrize_> that too :)
11:49:31 <monochrom> The ambiguity is ok.
11:49:37 <roconnor> yep!
11:51:22 <monochrom> Everyone sees "haskell is quantifiable in some way", then recalls the miserable unquantifiability in mainstream software work, and perceives Haskell is trying to make a difference here.
11:52:18 <Philippa> monochrom: but it /is/ about intuition. Well-founded intuition.
11:54:44 <monochrom> well, my point this time is it is not about feeling good.
11:54:59 <solrize_> but it feels good
11:55:08 <solrize_> my head hurts, but in a good way :)
11:55:20 <monochrom> that's a side effect
11:56:57 <joricj> what's the fastest way to put ghci into an eternal loop from the prompt? (least keystrokes)
11:58:08 <conal> joricj: fix (1+) ?
11:58:13 <monochrom> ghci is in an eternal loop already.
11:58:19 <conal> :) !
11:58:27 <conal> lol -- good one monochrom
11:58:45 <conal> monochrom: fewer keystrokes than mine.
11:59:21 <wagle_home> shouldnt fix (2 *) :: Int == 0?
11:59:28 <gwern> heh. haddock doesn't like this import: 'import Control.Compose (Unop, (:.) (..), inO2, Monoid_f (..))'
11:59:43 <conal> gwern: which haddock?
11:59:53 <Toxaris> @type fix (2 *)
11:59:54 <lambdabot> forall t. (Num t) => t
12:00:03 <gwern> conal: I have no idea... I have several verions installed
12:00:11 <Toxaris> > 0 * undefined
12:00:12 <lambdabot>  Undefined
12:00:38 <Toxaris> wagle_home: (*) is strict in both arguments, even if one of them is 0
12:00:40 <solrize_> hey augustss do you still use harpy ?
12:00:44 <monochrom> I can foresee objections to my solution.  One can argue that ghci doesn't loop there.  It blocks on an I/O call.  The OS loops but ghci doesn't.  But I have a new answer to fix that.
12:00:46 <conal> gwern: my haddock 2.0 likes it fine, but earlier haddocks definitely don't.
12:00:49 <wagle_home> 256 * 256 * 256 * 256 :: Int
12:00:55 <wagle_home> > 256 * 256 * 256 * 256 :: Int
12:00:55 <lambdabot>  0
12:01:04 <wagle_home> > 256 * 256 * 256 * 256 * 256 :: Int
12:01:05 <lambdabot>  0
12:01:20 <wagle_home> i said "shouldnt" not "does"
12:01:39 <gwern> presumably it's using my haddock-2.0.0.0, but configure claims it's using my old system-installed 0.9
12:02:41 <monochrom> Run ghci with: ghci < /dev/zero.  Then ghci loops.  Since entering " < /dev/zero" isn't normally counted as entering stuff into ghci, it is still 0 keystrokes. :)
12:03:20 <Synth-c> @help
12:03:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:03:37 <Synth-c> @list
12:03:37 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
12:03:44 <monochrom> There are other fun aspects of ghci < /dev/zero .  Try to type ":quit", type Ctrl-C. :)
12:03:49 <Toxaris> wagle_home: fix produces the fixpoint in the semantics sense, not the fixpoint of some Int sequence. it doesn't matter what the argument to f returns, but whether it evaluates it's argument
12:04:31 <monochrom> http://www.vex.net/~trebla/haskell/fix.xhtml
12:04:49 <roconnor> http://haskell.org/haskellwiki/Haskell_logos#GHC_logo
12:04:50 <lambdabot> Title: Haskell logos - HaskellWiki
12:04:51 <conal> wagle_home: still, the fix you're talking about is very fun also.
12:04:55 <Synth-c> @help unlambda
12:04:55 <lambdabot> unlambda <expr>. Evaluate an unlambda expression
12:05:13 <Synth-c> @help compose
12:05:13 <lambdabot> . <cmd1> <cmd2> [args].
12:05:13 <lambdabot> . [or compose] is the composition of two plugins
12:05:13 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
12:05:48 <conal> Toxaris: wagle_home's answer *is* a fixpoint in the semantics sense.  just not the *least* fixpoint.
12:05:59 <Synth-c> @help pl
12:05:59 <lambdabot> pointless <expr>. Play with pointfree code.
12:06:09 <conal> and the semantics of fix is usually taken to be the least fixpoint.
12:06:11 <Synth-c> @help pl map map
12:06:11 <lambdabot> pointless <expr>. Play with pointfree code.
12:06:20 <Synth-c> @hpl <map map>
12:06:20 <lambdabot> (line 1, column 1):
12:06:20 <lambdabot> unexpected "<"
12:06:20 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
12:06:24 <Synth-c> @pl <map map>
12:06:24 <lambdabot> (line 1, column 1):
12:06:25 <lambdabot> unexpected "<"
12:06:25 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
12:06:32 <Synth-c> @pl map map
12:06:32 <lambdabot> map map
12:06:39 <EvilTerran> Synth-c, you can play with lambdabot via pm, too
12:06:59 <roconnor> Who came up with the Cabal logo?  It's pretty well designed.
12:07:07 <Synth-c> ok, will do
12:07:12 <Synth-c> thanks
12:07:47 <gwern> roconnor: wasn't it cale?
12:07:54 <gwern> I seem to remember him in conjunction with't
12:07:59 <xerox> Yup.
12:08:18 <roconnor> okay.  I'll leave it to cale to come with with a proper GHC logo then.
12:09:06 <Toxaris> conal: ok I see.
12:09:22 <roconnor> Who wouldn't want to unpack a little box with a star on it!
12:09:38 <conal> i love the t-shirt designs fritz ruehr came up with, including some pretty funny & risque ones
12:10:44 <b_jonas> there's a cabal logo? where?
12:10:56 <gwern> now why would configure with --user options and so on pick the system haddock and not my local haddock? hmph
12:11:09 <roconnor> http://haskell.org/haskellwiki/Haskell_logos#Cabal
12:11:11 <lambdabot> Title: Haskell logos - HaskellWiki
12:11:30 <Toxaris> wagle_home: if fix (2 *) should be 0, what should fix (1 *) be?
12:12:35 <b_jonas> roconnor: thanks
12:12:37 <gwern> what is that cabal logo? two quadrilaterals next to a star? it's somewhat attractive, but I don't understand it
12:12:56 <atp> it looks like a box with a star in it to me
12:12:56 <roconnor> gwern: I see it as a box with a star on it.
12:13:09 <atp> so it's like you're unpacking the starry-goodness
12:13:41 <roconnor> it also a little bit like a star with an arrow beside it
12:14:08 <gwern> ' it has a tree on top! use the star and you'll be fighting off Old Ones with your bare hands!' 'Star!' 'Tree!'.... 'Tenctacles!!! Tentacles'
12:14:34 <chessguy> what an interesting conversation to walk in on
12:14:40 <gwern> (''A Shoggoth on the Roof'' is my favorite musical, sry)
12:14:52 <conal> fritz's logos (filtered): http://www.willamette.edu/~fruehr/logos/intro.html .
12:14:53 <lambdabot> Title: Proposed Haskell Merchandise Logo Designs
12:15:10 <gwern> chessguy: oh, you should've been here earlier for the human cheese and the twincest disucssions!
12:15:34 <gwern> wait, that was #wikipedia wasn't it? nm then
12:18:47 <atp> haha... "is that a banana in your pocket or are you just programming with catamorphisms?"
12:19:09 <atp> that's got to be just about the most geeked out PL theory tee slogan i've ever had the pleasure of seeing advertised
12:19:48 <Twey> Hahahaha
12:20:44 <atp> i think if i ever wore a t-shirt with a slogan like that on it i would either get stoned or die from quizzical look overload
12:21:27 <Twey> It would be worth it if you ever encountered someone who knew what you were talking about though :-P
12:21:54 * marshmallows wonders how many of thhe 457 users here understand it..
12:22:30 * Twey had to look it up.
12:22:32 <atp> i think that on #haskell, that ratio is probably much higher than on pretty much any other channel
12:23:07 <Twey> Aye
12:23:15 <atp> plus, that paper is sort of a classic...
12:23:20 * Twey nods.
12:23:39 <byorgey> http://arcanux.org/lambdacats/catamorphism.png  =)
12:23:39 <Twey> The proportion of plebs like me is relatively low here :-P
12:23:47 <atp> http://citeseer.ist.psu.edu/meijer91functional.html
12:23:48 <lambdabot> Title: Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire (Research ...
12:23:58 <Twey> Hahaha
12:24:02 <gwern> 'do you have eye problems, or did you eat too many bananas?'
12:24:58 <atp> byorgey: is that your cat?
12:25:11 <byorgey> atp: nope, I'm allergic =P
12:25:20 <Twey> Heh
12:25:22 <byorgey> atp: just a random picture I found by googling for 'banana cat' =)
12:25:30 <atp> it's pretty amusing
12:26:48 <gwern> that one is so geeky. so, you need to be familiar with lolcats; FP; esoteric -morphisms like catamorphisms *and* their nicknames, and be able to pull it all together for a sight pun
12:26:50 <gwern> dizzying
12:27:09 <atp> and yet we all got it
12:27:10 <monochrom> Don't forget to browse the rest of http://arcanux.org/lambdacats/ . Many insider haskell jokes.
12:27:12 <esteth> How do i make a pattern for case that does something like case x of 1 or 2 or 3 -> "one two or three"
12:27:12 <Twey> > @pl \x -> x
12:27:12 <lambdabot>  Parse error at "@pl" (column 1)
12:27:15 <Twey> @pl \x -> x
12:27:15 <lambdabot> id
12:27:26 <Twey> :-(
12:27:32 <marshmallows> It's a cat with a bannaskin on it's head
12:27:32 <Twey> That's cheating, lambdabot
12:27:34 <Twey> :-P
12:27:41 <marshmallows> there is no one who wont find it funny :P
12:27:53 <Twey> Hahaha
12:27:54 <atp> twey: s k k?
12:28:11 <byorgey> esteth: you can't do that with case.  use a guard instead.
12:28:14 <marshmallows> s k s too
12:28:15 <gwern> monochrom: been there, done that; I helped improve the wording of one, and suggested a version of Serious Cat
12:28:19 <Twey> atp: I was trying to trick lambdabot into attempting to @pl id.
12:28:20 <atp> marshmallows: s k _
12:28:36 <byorgey> foo | x `elem` [1,2,3] = "one two or three"  | otherwise = "something else"
12:28:40 <atp> so, k is const in haskell, what is s called?
12:28:43 <vininim> lol
12:28:45 <Twey> I was curious as to what the result would be.
12:28:53 <byorgey> atp: s is called ap.
12:28:59 <byorgey> @type ap
12:29:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:29:05 <byorgey> well, in the (r ->) monad
12:29:18 <atp> right
12:29:21 <marshmallows> :t ap :: (a -> b -> c) -> (a -> b) -> (a -> c)
12:29:22 <lambdabot> forall a b c. (a -> b -> c) -> (a -> b) -> a -> c
12:30:08 <gwern> @pl id x = id $ ((id . id . id . id . id) (id x))
12:30:09 <lambdabot> id = fix (ap (.) ((.) =<< ap (.) (ap (.) (ap (.) (join (.))))))
12:30:17 <esteth> byorgey: Thanks, i'll go read up on guards
12:30:18 <atp> haha
12:30:41 <marshmallows> :t ((.) =<<)
12:30:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (f a -> a -> b) -> f a -> f b
12:30:52 <atp> > ap (.) (const) (const) "hi"
12:30:52 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> b
12:30:52 <lambdabot>     Probabl...
12:30:54 <marshmallows> :t (.) =<< ap
12:30:55 <lambdabot> forall a. (a -> a -> a) -> a -> a -> a
12:31:05 <atp> hm
12:31:20 <marshmallows> > (((.) =<< ap) (+)) 3 5
12:31:20 <lambdabot>  13
12:31:34 <atp> hm
12:31:35 <skorpan> how do i enter character no 196 from the ascii table in a haskell character?
12:31:43 <skorpan> the extended ascii table that is
12:31:56 <skorpan> doing a curses-like GUI here
12:32:04 <atp> isn't it the same as in C?
12:32:07 <skorpan> \196?
12:32:14 <Toxaris> > ord '\196'
12:32:15 <lambdabot>  196
12:32:21 <marshmallows> > '\xC4'
12:32:22 <lambdabot>  '\196'
12:32:22 <skorpan> chr '\196'
12:32:27 <skorpan> > chr '\196'
12:32:28 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
12:32:33 <skorpan> > chr 196
12:32:33 <lambdabot>  '\196'
12:32:37 <skorpan> hmmm...
12:32:45 <skorpan> now i need to find a font which supports that. :)
12:33:14 <conal> atp: in a simpler & more general setting (applicative functors), k = pure, and s = (<*>)
12:33:28 <atp> skorpan: have you taken a look at dons' console mp3 player?
12:33:34 <conal> atp: you can think of AFs as simply being the generalization of k & s
12:33:47 <skorpan> atp: i haven't!
12:33:48 <monochrom> 196 is clearly not ascii.  Perhaps you mean unicode.
12:33:51 <skorpan> where can i find that?
12:33:55 <skorpan> monochrom: it's from the extended ascii table
12:34:02 <atp> monochrom: i think he means the old extended set from the ibm days
12:34:03 <skorpan> it goes up to 255
12:34:12 <atp> monochrom: with the double lines and things
12:34:16 <skorpan> exactly
12:34:25 <skorpan> the "warez nfo file" type of ascii
12:34:31 <monochrom> Haskell delibrately does unicode instead of that.
12:34:34 <SamB> skorpan: there is no "The extended ascii table"
12:34:42 <SamB> oh, you mean some IBM codepage?
12:34:51 <SamB> Well... you'll have to figure out the translation to unicode
12:34:59 <skorpan> http://en.wikipedia.org/wiki/Extended_ASCII
12:35:00 <lambdabot> Title: Extended ASCII - Wikipedia, the free encyclopedia
12:35:10 <skorpan> that's what i mean.
12:35:19 <skorpan> i don't care what you call it, as long as you understand what i mean :)
12:35:21 <atp> skorpan: dons' program has a simple binding to curses, it's a pretty easy read
12:35:23 <monochrom> â•â•‘â•’â•“
12:35:36 <skorpan> atp: thanks, but i'm doing vty instead of curses. is that a problem here?
12:35:40 <monochrom> those are U+2550, U+2551, U+2552, U+2553 from unicode
12:35:47 <atp> skorpan: http://www.cse.unsw.edu.au/~dons/hmp3.html
12:35:48 <lambdabot> Title: hmp3 - curses/ncurses mp3 player
12:35:52 <skorpan> thanks
12:35:56 <atp> i don't know, i have very little experience with anything but curses
12:36:01 <atp> and even then not much
12:36:08 <skorpan> looks hot
12:36:16 <atp> it's nice, and dons writes very readable code
12:36:33 <Saizan> skorpan: you probably just need to convert your string to utf8
12:37:24 <skorpan> wow, a lot of deps missing for me to use hmp3
12:37:33 <skorpan> zlib >=0.4, binary >=0.4, pcre-light >=0.3, mersenne-random >=0.1
12:37:34 <skorpan> :)
12:37:49 <atp> i haven't actually tried to build it in a long time, i just studied the code
12:38:01 <atp> it's a fairly old program iirc
12:38:15 <skorpan> it is
12:46:42 <skorpan> i wonder if there are chess symbols in unicode :)
12:47:12 <marshmallows> There are
12:47:22 <skorpan> there ARE!
12:47:23 <skorpan> awesome
12:47:25 <skorpan> http://en.wikipedia.org/wiki/Chess_symbols_in_Unicode
12:47:25 <lambdabot> Title: Chess symbols in Unicode - Wikipedia, the free encyclopedia
12:47:52 <atp> you should probably provide more generic symbols for people who don't have the necessary fonts though
12:47:59 <atp> i mean, as an option
12:48:06 <skorpan> atp: of course
12:48:08 <atp> unless you don't care :)
12:48:12 <atp> which is perfectly valid
12:48:13 <skorpan> however, this is only for my advanced functional programming course
12:48:25 <skorpan> it would impress the hell out of my teacher
12:48:29 <marshmallows> advanced fp is writing chess? :S
12:48:38 <atp> what school, skorpan ?
12:48:39 <marshmallows> heheh
12:48:42 <skorpan> marshmallows: i'm making an embedded language for describing any board game
12:48:43 <skorpan> atp: chalmers
12:48:53 <skorpan> marshmallows: chess is just an example
12:49:04 <dons> audreyt: is there a flippi repo somewhere?
12:49:36 <skorpan> it seems my font doesn't fully support unicode
12:49:41 <atp> most don't
12:49:46 <atp> unicode is huge
12:49:50 <skorpan> yes, i know :/
12:50:03 <atp> ms arial covers much of it, but badly
12:50:35 <monochrom> ubuntu 7.10 has chess symbols out of the box
12:50:44 <skorpan> it has to be monospaced and support chess symbols :/
12:50:47 <skorpan> monochrom: which font?
12:51:04 <marshmallows> why don't you just use ascii art
12:51:24 <skorpan> marshmallows: that's what i did, and it looked pretty .. well, shitty, excuse my french
12:51:24 <atp> marshmallows: that's so 80s :)
12:51:46 <monochrom> DejaVu Sans.  But I am not supposed to know.  It works out of the box, or rather the CD.
12:51:49 * atp is french...
12:51:58 <skorpan> monochrom: hm, i actually have that font...
12:52:03 <skorpan> atp: excuse my excuse my french
12:52:10 <atp> i wasn't offended :)
12:52:14 <monochrom> You just ask for U+2654 and you get white king.
12:52:22 <skorpan> will try.
12:53:01 <atp> is deja vu sans monospace?  does it have the other glyphs he needs?
12:53:02 <Cheery> lambda calculus can be executed with supercombinators, in quite tame manner
12:53:06 <monochrom> U+2654 white chess king: â™”
12:53:10 <atp> ooo
12:53:13 <atp> i can see that
12:53:15 * Twey too.
12:53:20 * Twey has every font in Portage.
12:53:22 <Cheery> me too
12:53:23 <atp> i'm using SimHei
12:53:24 * Twey cackles evilly.
12:53:31 <Cheery> but it looks like a skull for me
12:53:32 <monochrom> deja vu sans is not monospace.
12:53:36 <Twey> I have no ideo what that ended up getting rendered as.
12:53:38 <atp> but who knows what gtk is choosing
12:53:40 <Twey> idea**
12:53:45 <Twey> Yeah, as atp said
12:54:05 <monochrom> But there is always deja vu sans mono
12:54:11 <skorpan> URxvt.font: -*-dejavu sans mono-medium-r-*-*-17-*-*-*-*-*-*-*
12:54:16 <skorpan> i seem to have problems with that
12:54:19 <skorpan> my terminal won't even launch
12:54:21 <atp> gtk is cool, except it is annoying inconsistent when it picks glyphs in the han block
12:54:31 <Cheery> â™”â™”â™” pirate theme.. :P
12:54:41 <atp> skorpan: it's not a truetype font?
12:54:49 <skorpan> atp: ah!
12:54:49 <Cheery> is there a true skull in unicode glyphs?
12:54:51 <skorpan> of course
12:55:05 <atp> skorpan: i was about to say, it's pretty rare that you have an ap that uses the old school x fonts :)
12:55:36 <Cheery> yes it has: â˜ 
12:55:39 <skorpan> okay awesome, i can see it too!
12:55:43 <atp> haha
12:55:46 <skorpan> too bad dejavu sans mono is so huge
12:56:06 <atp> skorpan: perhaps you should just write a real GUI for it
12:56:14 <marshmallows> Can you choose which Unicode symbols are upper or lower case in ghc?
12:56:15 <skorpan> atp: no way josÃ©!
12:56:16 <atp> skorpan: or you could make it web based using HAppS
12:56:22 <atp> that would be pretty neat
12:56:28 <monochrom> atp: probably not gtk's fault.  look under /etc/fonts/conf.d .  It lets the Japanese Kochi fonts take precedence.  (Note it also covers much Chinese.)  IMO bad idea.  But you can edit it.
12:56:29 <marshmallows> or operator symbols.. etc..
12:57:04 <Cheery> hm. I wonder whether freenode net can handle unicode in names
12:57:10 <atp> monochrom: yeah.  i get lots of japanese glyphs when i'm reading chinese
12:57:13 <marshmallows> It doesn't allow it
12:57:21 <atp> monochrom: i'll take a look at that, thanks for the pointer
12:57:29 <Twey> atp: That's a Unicode thing
12:57:40 <Cheery> too bad. :(
12:57:45 <atp> Twey: no, it's actually a glyph-selection thing
12:57:56 <Twey> atp: Japanese kanji, Chinese hanzi and Korean hanja share codepoints
12:58:02 <atp> twey: so?
12:58:12 <atp> twey: only japanese people complain about that
12:58:16 <Cheery> I'd have liked from â˜  as character that adds after when nicks conflict
12:58:17 <monochrom> Kochi covers much Chinese but not all.  Then fall-over to "AR PL Uni".  Thus the inconsistency.
12:58:28 <atp> yeah, i'd like it to default to simsun
12:58:30 <Twey> So, evidently your Japanese font has a higher priority than your Chinese font
12:58:35 <skorpan> atp: the project is just the embedded language, so i won't be too overambitious
12:58:41 <gwern> man, â™ž is almost unreadable at small sizes
12:58:48 <atp> looks good to me :)
12:58:52 <Twey> Me too
12:58:53 <gwern> if I didn't know that was 'black knight', I'd never guess
12:58:55 <monochrom> To make things more confusing, "AR PL Uni" covers Japanese too.
12:59:36 <Twey> gwern: It's particularly confusing to me because it's white.  :-)
12:59:36 <atp> monochrom: well, there are some very badly designed unifonts designed by people who can't read chinese (or japanese, or whatever)
12:59:43 <monochrom> IOW it's almost impossible to specify "if it's Hiragana or Katakana, use Kochi; if it's Han, use AR PL Uni".
12:59:47 <atp> monochrom: they just try to cover every codepoint
13:00:08 <Twey> Heh
13:00:11 <gwern> Twey: nice
13:00:14 <Twey> Crayon Han characters
13:00:25 <atp> i can't read japanese so i don't care much about that... when i'm forced to try i just pretend it's chinese anyway, and hope that there are a lot of characters
13:00:34 <atp> sometimes i can figure it out
13:01:31 <dons> nice xmonad review, http://reddit.com/r/programming/info/6ca8r/details
13:01:35 <Cheery> does there exist something similar to prolog as there is for lambda calculus? things like what supercombinators are?
13:01:53 <marshmallows> Cheery: WAM, VAM, TUAM..
13:02:06 <atp> hey dons, do you read phdcomics?
13:02:15 <Cheery> what do they practically exploit in making prolog fast?
13:02:39 <Botje> indexing
13:03:12 <dons> atp, sometimes
13:03:17 <monochrom> "answer set programming" is a nice generalization of prolog
13:03:23 <Cheery> what is fastest from those?
13:03:47 <monochrom> You can also try first-order logic plus the "closed-world assumption".
13:03:58 <marshmallows> Cheery: The WAM is some VM which has a close mapping to Prolog but can also be implemented efficiently, the VAM and others are similar but of course try to improve where it can be done
13:04:48 <atp> dons: the reason i ask is because i've noticed that you post zillions of (great) haskell articles to reddit and it reminded me of the whole "grad students surfing the web" meme in phdcomics :)
13:05:08 <kowey> maybe there  should be a collection of extensions xmonad-boring that just gives you a standard (non-tiling) window manager
13:05:23 <atp> why would you want a non-tiling windowmanager
13:05:27 <atp> i mean, rather
13:05:33 <atp> why would you want xmonad to be non-tiling?
13:05:39 <atp> there are lots of great non-tiling window managers out there
13:05:50 <kowey> eh, just to show that it's possible, I guess
13:06:08 <kowey> it slices, it dices
13:06:42 <Cheery> hm, I actually hate the concept of windows for every program
13:06:42 <monochrom> dons is beyond "grad student surfing the web".  he causes more stuff to appear on the web and also more grad students to surf the web and for longer.  he's infectious and exponential-growing.
13:06:54 <Cheery> even more I hate the concept that they must be visible all the time
13:07:14 <kowey> and also some users might like the idea of tiling some stuff, but not most of it
13:07:27 <atp> monochrom: i think dons may be single-handedly responsible for the huge non-pl-functional-languages-geek surge of interest in haskell that's happening at the moment
13:07:30 <monochrom> Just wait until dons post the "The Ring" video to youtube. :)
13:08:04 <atp> initially audreyt and pugs were a big part of it but these days i'd have to say it's pretty much all dons
13:09:05 <gwern> wonder what happened to audreyt. (s)he posted flippi to hackage recently, but pugs seems bogged down
13:09:14 <monochrom> "after you watch this video, you must both: (1) tell other people to watch it, and (2) write some haskell code.  Or else you'll die in 48 hours.  For 48-hour help on writing haskell code, see 'scheme in haskell in 48 hours' "  :)
13:09:16 <gwern> dunno if they managed to even transition to ghc 6.8.x yet...
13:09:32 <atp> gwern: i'm pretty much she would rather be called just she than (s)he...
13:09:48 <atp> s/much/sure
13:10:46 <atp> monochrom: hehe
13:10:54 <Cheery> I were thinking about a safe format to transfer programs from untrusted authors
13:11:03 <njbartlett> Apparently SPJ gave a talk at QCon on friday, and he was the star of the show. Can't wait to see the video...
13:11:41 <Cheery> what I were first thinking is that it should be simple and easy to typecheck
13:12:03 <Cheery> so thought about just storing some spines in a file
13:12:12 <marshmallows> Cheery: You have heard about proof carrying code?
13:12:20 <Cheery> nope
13:12:31 <Cheery> what sort of stuff that is?
13:12:52 <TomMD> Coq?
13:12:54 <marshmallows> supplying type judements which express "this program does not go wrong"
13:13:06 <marshmallows> not really Coq
13:13:35 <Cheery> what sort of things they are?
13:13:38 <marshmallows> more commen in typed assembly languages, byte code languages..
13:14:23 <Cheery> I were thinking about doing this for such binary trees, that aren't anymore used in haskell thought (so I've read)
13:14:49 <Cheery> this because I thought it'd be simple to provide multiple FPL on that
13:16:21 <skorpan> it's crazy how productive you can get while listening to this song: http://md5.se/h/048/
13:16:23 <lambdabot> Title: IDOL 2006
13:19:27 <Cheery> marshmallows: but proof carrying code seems to be a widely thought out concept
13:19:42 <marshmallows> is that a bad thing? :P
13:20:07 <Cheery> well, it means that I don't know whether my system is an another one
13:20:44 <Cheery> I were thinking about embedding sort of type signatures associated to those binary trees
13:21:44 <Cheery> effectively providing code that is 'proof-carrying' in the sense it uses restricted interfaces and is type-checked
13:22:16 <byorgey> Cheery: I think proof-carrying code is exactly what you are thinking of.
13:22:19 <Cheery> with 'proof' existing from type checking along the program
13:22:37 <vincenz> byorgey: congrats
13:23:58 <Cheery> do you think it is a good idea?
13:25:16 <Cheery> or is there something even simpler than such trees embedded with a 'proof'
13:25:53 <Cheery> it is a stupid thing to ask, I know.
13:26:19 <marshmallows> something simpler.. that still acheives what?
13:26:56 <Cheery> achieves being able to do PPC for a program
13:27:54 <Cheery> basically achieves the stuff that it could be used as the next javascript
13:28:12 <byorgey> vincenz: thanks =)
13:29:26 <b_jonas> Cheery: I thought lua was the next java-script
13:29:54 <Cheery> thought, before this I'm going to look into yet that logic programming -stuff, to find out simple way to implement it
13:30:09 <Cheery> while still being relatively efficient
13:30:25 <marshmallows> what logic programming stuff are you doing?
13:31:10 <Cheery> type inferencing, yes, I could do some simpler tool for that, but logic programming is practical in general
13:31:37 <Cheery> you can express nice things through that
13:31:56 <Twey> Cheery, have you had a look at Curry?
13:32:01 <Cheery> for instance, in describing crippled protocols, prolog goes better than haskell
13:32:07 <Cheery> Twey: nop
13:32:22 <Twey> It implements Prolog-like constraint programming, among other things
13:32:37 <marshmallows> I thought curry used narrowing?
13:32:41 <marshmallows> or something somewhat different
13:32:54 <marshmallows> as well as higher order support (am I right about that?)
13:33:05 * Twey has no idea.
13:33:23 <marshmallows> :(
13:35:26 <dons> atp: oh, i use rss
13:36:19 <kjdf> what happens when a pattern binding fails inside a monad?
13:36:40 <kjdf> when I do, for example, "Just x <- Nothing"
13:36:43 <dons> an exception will be thrown
13:36:45 <kpreid> calls fail
13:36:45 <Botje> fail is called
13:36:52 <dons> > case Nothing of Just x -> x
13:36:52 <lambdabot>   Non-exhaustive patterns in case
13:37:02 <kpreid> @src Maybe fail
13:37:02 <lambdabot> fail _      = Nothing
13:37:03 <int-e> @undo do Just x <- undefined; undefined
13:37:04 <lambdabot> undefined >>= \ a -> case a of { Just x -> undefined; _ -> fail ""}
13:37:11 <kpreid> @src Identity fail
13:37:11 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
13:37:11 <marshmallows> > do Just x <- [Nothing, Just 3, Nothing, Just 6] ; return k
13:37:12 <marshmallows> > do Just x <- [Nothing, Just 3, Nothing, Just 6] ; return x
13:37:13 <lambdabot>  [k,k]
13:37:13 <lambdabot>  [3,6]
13:37:33 <marshmallows> > [ x | Just x <- [Nothing, Just 3, Nothing, Just 6] ]
13:37:34 <lambdabot>  [3,6]
13:38:16 <Cheery> curry seems curious thing
13:38:50 <dolio> > catMaybes [Nothing, Just 3, Nothing, Just 6]
13:38:50 <lambdabot>  [3,6]
13:39:23 <madhadron> I've just finished a draft of a brief introduction to Haskell.  Is it appropriate to post such things directly to the haskell.org wiki?
13:41:36 <byorgey> madhadron: sure.
13:42:08 <Cheery> people who make the closed-world assumption in real life are usually annoying
13:42:21 <Cheery> and they are often called religious
13:43:28 <conal> Cheery: what's the closed-world assumption?
13:44:02 <marshmallows> anything you can't prove to be true is false
13:44:16 <marshmallows> like negation by failure
13:44:38 <conal> oh.  thanks.
13:44:52 <conal> i'm glad to have a name for that assumption.
13:45:34 <Heffalump> surely religion doesn't fit well with that, given that it's based on things you can't prove to be true?
13:45:47 <conal> is it the same assumption as saying something is impossible when really the person simply doesn't have a clue how to do it?
13:46:49 <conal> i often run into the latter, including on this channel.
13:46:50 <dolio> I thought 'religious' usually went with 'anything you can't prove to be false is true.' :)
13:46:55 <dons> interesting, a new wiki project written in haskell, http://latexki.nomeata.de/
13:46:57 <lambdabot> Title: The Latexki Latex Wiki Wiki - index
13:47:00 <dons> for collaborating on latex
13:47:00 <dolio> Although, perhaps not 'anything' but specific things. :)
13:48:20 <Cheery> Heffalump: yep, it's the another class of people, science-religious
13:48:38 <glen_quagmire> I am using Reader monad to store environment (String, Val). how can I loop so that the environment persists?  I am doing   interpret str = case runEvaluator emptyEnv $ parse str of ....
13:48:39 <conal> and what about the "if you can't measure it, it doesn't exist"?
13:49:00 <marshmallows> conal: finitists maybe?
13:49:00 <Heffalump> can you give a more specific example of that?
13:49:15 <glen_quagmire> so, when I call interpret another time, it starts with emptyEnv again
13:49:25 <Gilly> dons: did they show you the two ways of calculating pythagorean triplets (using the same algorithm) resulting interestingly different running times?
13:49:41 <Heffalump> Gilly: yes
13:49:44 <roconnor> dons: my first attempt at a logo. http://haskell.org/haskellwiki/Haskell_logos#GHC_logo
13:49:45 <lambdabot> Title: Haskell logos - HaskellWiki
13:49:59 <Gilly> Heffalump: ah, great... was the solution found?
13:50:13 <marshmallows> hehe I like how you sneak in >>= roconnor
13:50:44 <Heffalump> no, but the main point was to make sure that someone involved with stream fusion was aware of it
13:50:50 <Heffalump> (for me, anyway)
13:50:53 <Gilly> :)
13:50:59 <Cheery> naturally, science-religious and religious people do not often go together
13:51:14 <byorgey> glen_quagmire: in that case, I think you want State instead of Reader.
13:51:25 <Gilly> yea i was just double-checking the thing :) it left me nerving
13:51:34 <Cale> glen_quagmire: The point of the reader monad is that the environment never really changes.
13:51:38 <dons> oh, interesting roconnor . blueprints eh?
13:51:44 <Cheery> science-religious are doing closed-world assumption, and religious people are doing coclosed-world assumption.
13:52:15 <ptolomy2> A combination of gnu screen, a simple shell script that runs my unit tests and acceptance tests every time a file changes, and vim make my haskell coding experience oh-so-agileful.
13:52:17 <Heffalump> I don't assume a closed world, but I refuse to accept any specialised claims about the nature of the world outside.
13:52:19 <marshmallows> Would a JVM is Haskell be very fast?
13:52:30 <Cale> Cheery: "science-religious"?
13:52:35 <marshmallows> (I am not writing a JVM just wondering)
13:52:46 <glen_quagmire> oh thanks Cale , byorgey
13:52:56 <Philippa> Cale: "Anything science hasn't shown to be true is false", I'm guessing. Too many doctors have that one
13:52:56 <njbartlett> marshmallows: No it wouldn't
13:53:00 <retarded> if you are banned from somewhere or not wanted for whatever reason how do you go there again and get something?
13:53:14 <dolio> @where uvm
13:53:14 <lambdabot> I know nothing about uvm.
13:53:21 <ptolomy2> Philippa: Strong scientism, yes?
13:53:27 <byorgey> retarded: go there again and give something first?
13:53:45 <Cale> I'm not sure that I'd refer to that as a religion...
13:53:46 <ptolomy2> However, science hasn't proven that anything science hasn't proven to be true is false..
13:53:59 <Cale> Science hasn't proven anything.
13:54:13 <Philippa> ptolomy2: no, something stronger/stupider than strong scientism
13:54:19 <ptolomy2> Oh. Eesh.
13:54:21 <Cheery> Cale: in lack of better name I called it that
13:54:23 <b_jonas> well, I've been kicked from a bookstore once because I was reading, the clerk said I could come back if I wanted to actually buy something
13:54:30 <b_jonas> I won't return there if I want to buy
13:54:35 <resiak> It's kind of depressing that gcc can warn about passing the wrong arguments to printf at compile time, but ghc cannot :)
13:54:41 <tromp> science has proven some true things to be unprovable
13:54:51 <Botje> resiak: gcc cheats.
13:54:56 <marshmallows> tromp: Do you mean maths?
13:54:57 <b_jonas> resiak: lol
13:55:08 <tromp> sure, math is subset of science
13:55:09 <Cale> Mathematics is not a science :)
13:55:10 <resiak> Botje: regardless, it still does a better job :)
13:55:12 <roconnor> dons: I bet Cale can design a better logo
13:55:15 <Philippa> retarded: if it's something of yours, send a friend to pick it up. If it's not something of yours, accept the situation
13:55:19 <marshmallows> I disagree strongly tromp
13:55:22 <Botje> resiak: heh. no argument there :)
13:55:30 <monochrom> Nice that gcc tries to do that, but you know it can't do it perfectly.
13:55:48 <tromp> i call myself computer scientist
13:55:48 <dolio> GHC can do it if you write printf in template haskell. :)
13:55:51 <monochrom> Anyway if you throw some TH to the problem, you can also do it.
13:55:52 <Cale> Mathematics does not require or heavily rely upon the scientific method, and is thus not a science.
13:55:56 <dolio> Although that can look ugly.
13:55:57 <resiak> of course.  perhaps first-class format strings would be a good idea? :)
13:55:59 <Cheery> math is same as applying creativity to simple ideas
13:56:06 <ptolomy2> gcc treats a lot of C functions as primitives.
13:56:12 <b_jonas> Cale: hmm
13:56:17 <njbartlett> http://www.wellingtongrey.net/miscellanea/archive/2007-01-15%20--%20science%20vs%20faith.png
13:56:19 <lambdabot> http://tinyurl.com/2mulhc
13:56:23 <marshmallows> resiak: Check out the type safe continuation based printf
13:56:32 <marshmallows> http://www.lri.fr/~sozeau/repos/coq/misc/shiftreset/GenuineShiftReset.html
13:56:40 <resiak> how many olegs are involved
13:56:46 <marshmallows> exactly 1
13:57:10 <njbartlett> marshmallows: Oh wait, did you say a JVM *in* Haskell? Or do you mean running Haskell under JVM?
13:57:19 <marshmallows> Implement a JVM in haskell
13:57:24 <marshmallows> then run java bytecode in it
13:57:43 <Heffalump> njbartlett: will there be a LHUG talk this month? If not, organising a pubmeet might be a good idea.
13:57:44 <Cheery> njbartlett: the faith -program would be simple to implement in imperative languages, while science -program relies on laziness
13:57:44 <byorgey> marshmallows: there's no reason that couldn't be fast.
13:57:48 <njbartlett> marshmallows: Ah I see. It could be reasonably fast yes.
13:57:48 * ptolomy2 suspects that Haskell isn't a great language for writing language runtimes that require performance and control.
13:57:56 <marshmallows> as fast as a C implementation?
13:58:13 <ptolomy2> well, "as much performance and control as possible".
13:58:44 <vincenz> Kom op konijntje doe maar wiebele, wiebele
13:58:47 <njbartlett> marshmallows: It would be as fast as a not-very-good C implementation. The problem is you're competing against existing JVMs which have been optimized incrementally for about 10 years now. So they're very fast. You're not going to get close.
13:58:50 <vincenz> Kom op konijntje doe maar wiebele, wiebele, huppel
13:58:51 <madhadron> Is there some policy on posting documents on the haskell.org wiki?
13:58:57 <marshmallows> ah ok
13:59:16 <marshmallows> thanks very much
13:59:28 <njbartlett> Heffalump: You're right. I spoke to Lennart, he's going to do the talk that he didn't get to do at QCon. But aside from that I haven't had much luck finding speakers
13:59:31 <madhadron> Haskell related documents, obviously
14:00:04 <monochrom> Likely the C code in a fast JVM is tailored for the C compiler used.
14:01:02 <Cale> madhadron: Go right ahead.
14:01:21 <njbartlett> monochrom: Yeah, the Sun JVM contains a fair amount of assembly too
14:01:23 <Cale> madhadron: Oh, they have to be licensed appropriately
14:01:25 <monochrom> When that happens, it is more like "written in this dialect of C" than "written in C".
14:01:39 <Cale> madhadron: There's a 'simple permissive license' which everything on the wiki is under
14:01:42 <dons> Philippa: is there a repo for flippi that audreyt's working in?
14:01:49 <retarded> do you think people who banned me remember that they banned me?
14:01:55 <Philippa> dons: no idea
14:02:06 <Philippa> retarded: I think you just reminded everyone
14:02:12 --- mode: ChanServ set +o vincenz
14:02:16 <Philippa> incidentally, ban evasion ought to be worthy of another ban...
14:02:35 <madhadron> Cale, Yup, just found it.  Alright, yet another introduction to Haskell goes into the wild...
14:02:44 <monochrom> And if that is acceptable (sure it is), what stops one from writing Haskell code tailored for yhc, and having yhc specialized for churning out a fast JVM?
14:02:59 <Philippa> dons: I'm thinking I should probably leave it unmaintained at this point unless anyone actually wants to pick it up, anyway
14:03:22 <Philippa> and perhaps (on a similarly unmaintained basis) release something with the plugin system
14:03:34 <resiak> marshmallows: my head hurts :(
14:04:23 <esteth> hm. How would i get ghci to tell me the type of the :+ complex-number-constructer?
14:04:48 <marshmallows> :t (:+)
14:04:50 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
14:05:08 <esteth> ahh, didn't realise you needed the brackets. Thanks marshmallows :)
14:05:38 <byorgey> @src filter
14:05:38 <lambdabot> filter _ []     = []
14:05:38 <lambdabot> filter p (x:xs)
14:05:38 <lambdabot>     | p x       = x : filter p xs
14:05:38 <lambdabot>     | otherwise = filter p xs
14:05:45 <atp> esteth: in general you can make any infix operator polish by putting parenthesis around it
14:06:07 <marshmallows> filter p = fold (\x ys -> if p x then x : ys else ys)[]
14:06:10 <retarded> do you think people who banned me remember that they banned me?
14:06:20 <vincenz> Ok, I was waiting, but that does it
14:06:21 <marshmallows> retarded: I think this is #haskell
14:06:27 --- mode: vincenz set +b *!*i=sucka@*.cpe.net.cable.rogers.com
14:06:27 --- kick: retarded was kicked by vincenz (vincenz)
14:06:31 --- mode: vincenz set -o viphak
14:06:33 --- mode: vincenz set -o vininim
14:06:35 --- mode: vincenz set -o vincenz
14:06:48 <atp> thanks, vincenz
14:07:01 <vincenz> stoopid tab-complete :)
14:07:10 <Heffalump> :-)
14:07:12 <b_jonas> I thought he's stop cross-posting after warned him
14:07:17 <conal> vi is popular on this channel
14:07:27 <marshmallows> vi the editor?
14:07:28 <conal> vincenz, vininim, viklund, viphak
14:07:33 <b_jonas> I have a /deopme alias
14:07:33 <marshmallows> oh right hehe
14:07:33 <atp> haha
14:08:27 <Botje> THIS .. IS .. #HASKELL!
14:08:30 * Botje runs
14:08:32 <conal> (no member names start with "emacs")
14:09:15 <vincenz> conal: well that requires 10 fingers
14:09:33 <dons> Philippa: did you see the 0.4 and 0.5 releases on hackage?
14:09:41 <conal> vincenz: at least!
14:10:33 <atp> conal: or yi, for that matter
14:11:15 <madhadron> If anyone is sufficiently bored, I'd appreciate comments on http://haskell.org/sitewiki/images/2/2d/Introduction.pdf
14:13:12 <b_jonas> (conal: two nicks start with joe)
14:13:28 <atp> hehe
14:14:00 <cjb> What's the name of the Haskell blog engine?
14:14:08 <Jaak> @type let t t = t in t
14:14:09 <lambdabot> forall t. t -> t
14:14:33 <marshmallows> :t \t t -> t
14:14:34 <lambdabot>     Conflicting definitions for `t'
14:14:34 <lambdabot>     In a lambda abstraction
14:14:43 <marshmallows> :t \t -> t
14:14:44 <lambdabot> forall t. t -> t
14:15:04 <Philippa> dons: I saw 0.04 and 0.05, yeah. 0.04 is broken
14:15:09 <TomMD> madhadron: I don't have to be bored for that!
14:16:37 <atp> sigh, xmonad is borked on debian testing
14:16:40 <Axioplas2> madhadron: page 6 [] is particualrly
14:16:47 <Axioplas2> typo there.
14:16:55 <madhadron> thanks
14:17:40 <Cale> cjb: Hope?
14:17:48 <madhadron> You'll probably find more, as I'm going to do the thorough proofread for language and style tomorrow.
14:18:06 <marshmallows> How much data definitions could you infer?
14:18:37 <marshmallows> I mean you can infer types but what about inferring: data List a = Nil | Cons a (List a) from a bit of code?
14:19:20 <Cale> Pattern matching in Haskell is actually top to bottom.
14:19:37 <Cale> marshmallows: You can never be sure that you have the whole thing...
14:19:41 <Philippa> marshmallows: you couldn't
14:19:55 <Philippa> rather, there's good odds you'd just infer a rather broken "Universe" type
14:20:11 <dons> atp, how?
14:20:12 <marshmallows> I see
14:20:31 <dons> atp, this is super important. we need to chase it up, if that's the acse
14:20:42 <Cale> madhadron: So for example, in the definition  fac 0 = 1; fac n = n * fac (n-1), I can't swap the order of the declarations. (Though obviously, I understand what you're getting at :)
14:21:06 <madhadron> Cale, You're right, I should clarify that.
14:21:20 <dons> atp, http://packages.debian.org/sid/xmonad ?
14:21:22 <lambdabot> Title: Debian -- Details of package xmonad in sid
14:21:24 * marshmallows offers some n+k patterns to everyone :P
14:21:33 <madhadron> However, aside from multiple variations for a particular function, is there any other place that ordering will make a difference?
14:21:35 <bitrot> madhadron: on page 1, s/ridiculos/ridiculous/
14:22:05 <dons> atp, looks like we'll have powerpc soon ,http://buildd.debian.org/pkg.cgi?pkg=xmonad
14:22:06 <lambdabot> Title: buildd.debian.org: xmonad in the unstable wanna-build databases
14:24:06 <dons> atp, more info please!
14:25:14 <Cale> madhadron: Of course, there's a sense in which ordering of computation can be imposed by data dependency or by explicit construction (as in the IO monad, where it doesn't matter the order in which IO computations are evaluated, but their execution occurs in a specific order.)
14:26:04 <madhadron> Cale, I've pointed out both of those, though possibly not in the best positions.  The IO comes later, but is there a place you think data dependency would sit particularly well?
14:26:32 <Cale> Well, I haven't read much more than the first couple pages yet :)
14:26:38 <madhadron> fair 'nuff
14:27:09 <Cale> It might also be worth talking about the one order in which all the implementations evaluate Haskell code most of the time.
14:27:34 <Cale> (Which is lazy evaluation -- outermost leftmost reducible expressions first)
14:28:21 <Cale> The advantage of this order is that if any order of evaluation terminates, then this one will, and will produce the same value.
14:28:33 <tromp> completely off-topic... does anyone have experience with online tax filing?
14:28:38 <Cale> Actually, lazy evaluation is a little more than that, as it implies sharing.
14:28:52 <madhadron> Cale, Though from the point of view of writing code it makes no difference except that you don't have to worry as much about nontermination
14:29:01 <Cale> madhadron: Right.
14:29:13 <madhadron> So I suspect that stressing it in the very beginning is incidental.
14:29:17 <Cale> yeah
14:29:41 <Cale> madhadron: The important point is really that if any order of evaluation would terminate, then a valid Haskell implementation must terminate.
14:29:51 <madhadron> Though I have included the classic Fibonacci one-liner, after which you either accept lazy evaluation or go insane.  Or both.
14:30:01 <Cale> I don't know if that's worth stating explicitly :)
14:30:31 <madhadron> Cale, If this were chapter 1, I think it's worth stating in chapter 2.
14:30:36 <b_jonas> madhadron: just because I accept lazy evaluation, I don't neccesarily understand the weight of full lazy evaluation
14:31:48 <Cale> Yeah, there are practical details like how recursive functions can build up large expressions in their accumulating parameters which might be important to talk about in chapter 2 :)
14:32:16 <madhadron> b_jonas, Certainly.  But I don't expect a first year physics student to calculate scattering cross sections either.
14:32:39 <Cale> madhadron: You got foldr and foldl backwards.
14:32:49 <Cale> madhadron: foldr is the one which works on infinite lists.
14:32:52 <dons> Igloo: so i've had two reports now that xmonad's not installable on debian due to unsatisfied dependencies. is this known?
14:32:55 <madhadron> Damnit!
14:32:59 <Cale> > foldr (:) [] [1..]
14:33:01 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
14:33:03 <dons> Igloo: or not configurable?
14:33:08 <Cale> > foldl (flip (:)) [] [1..]
14:33:11 <madhadron> That will teach me to write about Haskell after spending three months writing Java.
14:33:11 <lambdabot>  Terminated
14:33:37 <Cale> madhadron: I have some nice diagrams here: http://cale.yi.org/index.php/Fold_Diagrams
14:33:38 <lambdabot> Title: Fold Diagrams - CaleWiki
14:34:20 <glguy> > foldl const 0 [1..]
14:34:22 <lambdabot> Terminated
14:34:42 <Cale> > foldl (flip const) 0 [1..]
14:34:45 <lambdabot>  Terminated
14:35:05 <Igloo> dons: On what platform?
14:35:16 <Cale> (really, it's glguy's which "should" be 0)
14:35:32 <dons> Igloo: amd64? (maybe others)
14:35:48 <Cale> I ran into a similar problem once when multiplying an infinite sequence of 1's ;)
14:35:57 <glguy> > foldl f a [b,c,d]
14:35:58 <lambdabot>  f (f (f a b) c) d
14:36:08 <madhadron> There, thanks to the glory of search and replace, they are fixed.
14:36:09 <glguy> explains why it won't return
14:36:10 <Igloo> dons: Hmm, should be fine AFAIK
14:36:15 <dons> Igloo: atp and yigal both have reported that they can get the binary, but not the deps for configuration
14:36:32 <Igloo> dons: Which deps?
14:36:33 <marshmallows> > foldr (flip f) a (reverse [b,c,d])
14:36:34 <lambdabot>  f (f (f a b) c) d
14:37:01 <Cale> madhadron: hehe, I'm not sure that'll work. You had the definitions of foldl and foldr right.
14:37:06 <dons> Igloo: let me grab the reporter from #xmonad
14:37:13 <dons> atp: also, around? Igloo's right here.
14:37:19 <Cale> madhadron: It's just that it's foldr which you usually want because it works lazily.
14:37:34 <madhadron> Ah, yes, I see.  And thanks to the glory of undo...
14:37:42 <marshmallows> madhadron: You might want to say  foldr f z (reverse xs) = foldl (flip f) z xs
14:38:03 <marshmallows> for finite lists
14:38:32 <dons> ah yigal. good
14:38:32 <madhadron> That's useful.  Thanks.
14:38:35 <b_jonas> marshmallows++
14:38:38 <b_jonas> nice one
14:38:46 <dons> yigal: can you just explain to Igloo what the problem is?
14:38:54 <marshmallows> :)
14:39:43 <yigal> Igloo: what is going on with xmonad dev. packages in debian?
14:39:51 <Cale> actually, that works for all lists, since if xs is infinite, then reverse xs is undefined, and so the LHS is undefined, and the foldl is folding over an infinite list, so it's undefined too.
14:40:02 <dons> yigal: can you explain the symptoms perhaps?
14:40:25 <dons> so you need libghc6-xmonad-dev et al ?
14:40:27 <Cale> You have to be careful about where you put the flip and reverse though :)
14:40:45 <Cale> foldr f z xs == foldl (flip f) (reverse xs)  isn't true for all lists :)
14:40:49 <monochrom> don't reverse your flip or flip your reverse
14:41:01 <Cale> er, missed a z
14:41:07 <Cale> foldr f z xs == foldl (flip f) z (reverse xs)  isn't true for all lists :)
14:41:19 <monochrom> don't reverse or flip your composition of reverse and flip
14:41:25 <Cale> foldl f z xs == foldr (flip f) z (reverse xs)  is true though
14:41:39 <oerjan> it's true for exactly those lists that are either bottom or has a definite finite length, i guee
14:42:04 <Igloo> yigal: What's the problem, exactly?
14:42:05 <oerjan> *have, guess
14:42:06 <Cale> oerjan: the foldr one? Yeah.
14:42:12 <yigal> Igloo: I am unable to install libghc6-xmonad-{contrib-dev,xmonad-prof,xmonad-dev} do to dependency issues
14:42:29 <yigal> Igloo: sorry a little garbling of package names
14:43:12 <oerjan> since if it is not bottom then foldr ... isn't, while if it is not of finite length then foldl ... is bottom
14:43:28 <dons> 14:16:37 <atp> sigh, xmonad is borked on debian testing
14:43:55 <yigal> Igloo: this is the error http://rafb.net/p/sCUM8I57.html
14:43:55 <lambdabot> Title: Nopaste - debian package problem
14:44:28 <yigal> Igloo: at least for attempting to install libghc6-xmonad-dev
14:44:39 <yigal> Igloo: I am on amd64 platform
14:45:17 <Igloo> yigal: You're trying to use the unstable xmonad packages with the stable ghc6 packages, or something
14:45:29 <Cale> madhadron: A sometimes useful way to look at it is that in a certain sense, foldr is O(1), since it immediately returns the application of f to some arguments and is finished (ignoring the fact that there's a call to foldr in one of those arguments). On the other hand, foldl immediately calls itself until it reaches the end of the list.
14:45:46 <madhadron> Well, strictly foldl f z xs => foldr (\x y -> f y x) z (reverse xs)
14:46:14 <Cale> hm?
14:46:34 <Cale> Is there any situation where foldl f z xs can be defined but foldr (flip f) z (reverse xs) is not?
14:47:00 <madhadron> No
14:47:02 <yigal> Igloo: never mind, I am a fool
14:47:11 <madhadron> brb, phone
14:47:13 <Cale> They're identical, semantically.
14:47:17 <opqdonut> > foldr f [a,b,c,d]
14:47:18 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr [Expr])
14:47:27 <opqdonut> > foldr f z [a,b,c,d]
14:47:28 <lambdabot>  f a (f b (f c (f d z)))
14:47:51 <Cale> SimpleReflect does more evaluation than perhaps it should ;)
14:47:51 <dons> yigal: ok, so what was the issue?
14:48:12 <dons> now, if only we can find out what atp was experiencing
14:48:13 <Cale> That really goes to  f a (foldr f z [b,c,d])
14:48:17 <dons> thanks Igloo!
14:48:25 <oerjan> > foldr f z [var $ 'x':show n | n <- [1..]]
14:48:25 <lambdabot>  f x1 (f x2 (f x3 (f x4 (f x5 (f x6 (f x7 (f x8 (f x9 (f x10 (f x11 (f x12 (f...
14:48:27 <Cale> and it's f which is evaluated next
14:49:01 <malsyned> Does anybody know if rspBody in a Network.HTTP Response is a lazy string?
14:49:04 <Cale> foldr will only get called again if f demands to see its second parameter
14:49:34 <yigal> dons: I have apt pinning in general to lenny, and asked that unstable libghc6-xmonad-dev be installed but it wouldn't automatically install unstable and required that I manually install the dependencies
14:49:51 <b_jonas> > foldr id (replicate f)
14:49:51 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr Int)
14:49:59 <monochrom> malsyned: IIRC it is not lazy.  But long time ago.
14:50:02 <b_jonas> > foldr id (repeat f)
14:50:02 <lambdabot>  Add a type signature
14:50:06 <b_jonas> > foldr id (replicate 10 f)
14:50:06 <lambdabot>  Add a type signature
14:50:07 <dons> yigal: ok. so are you able to proceed now?
14:50:07 <yigal> dons: in this case ghc6 6.8
14:50:14 <b_jonas> > f f
14:50:14 <lambdabot>  Add a type signature
14:50:15 <Cale> b_jonas: not enough parameters
14:50:17 <oerjan> btw clearly [x1 ..] should be equivalent to that list
14:50:25 <yigal> dons: absolutely with my tail between my legs but a working xmonad :)
14:50:27 <b_jonas> > foldr1 id (replicate 10 f)
14:50:27 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
14:50:27 <lambdabot>     Probabl...
14:50:34 <b_jonas> Cale: thanks
14:50:38 <b_jonas> > foldr1 id (repeat f)
14:50:39 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
14:50:39 <lambdabot>     Probabl...
14:50:39 <opqdonut> btw why is there a foldl' but no foldr'?
14:50:46 <oerjan> hm wait that would mean defining a lot of variables
14:50:58 <oerjan> > [var "x1" .. ] -- this, then
14:50:59 <lambdabot>  Exception: Data4-32: Non-exhaustive patterns in function fromEnum
14:51:07 <malsyned> monochrom: do you know if there is a way to get an HTTP body lazily?  I'd like to be able to throw a percentage indicator or something up.
14:51:10 <dolio> @hoogle foldr'
14:51:11 <lambdabot> Data.Foldable.foldr' :: Foldable t => (a -> b -> b) -> b -> t a -> b
14:51:11 <lambdabot> Data.ByteString.foldr' :: (Word8 -> a -> a) -> a -> ByteString -> a
14:51:11 <lambdabot> Data.ByteString.Char8.foldr' :: (Char -> a -> a) -> a -> ByteString -> a
14:51:14 <dons> yigal: great!
14:51:19 <opqdonut> oh
14:51:20 <b_jonas> oerjan: don't you mean (map var ["x1" ..])
14:51:21 <monochrom> No, I don't know.
14:51:23 <yigal> Igloo: thanks for the work
14:51:28 <marshmallows> would foldr' f xs = foldr f (head xs) (tail xs)
14:51:33 <marshmallows> is that a sensible def.?
14:51:34 <Igloo> yigal: np
14:51:35 <opqdonut> but yeah i guess i realized why foldr' doesn't make that much sense
14:51:52 <opqdonut> marshmallows: you're thinking foldr1
14:51:59 <marshmallows> oh..
14:52:03 <marshmallows> :t foldl'
14:52:04 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:52:09 <marshmallows> @src foldl'
14:52:09 <lambdabot> foldl' f a []     = a
14:52:09 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
14:52:14 <marshmallows> oh right ok
14:52:25 <marshmallows> foldr is sort of already like that isn't it?
14:52:25 <oerjan> b_jonas: heh, that might be a bit hard
14:52:34 <Cale> foldr1 f z [x] = x; foldr1 f z (x:xs) = f x (foldr1 f z xs)
14:52:40 <oerjan> but not impossible perhaps
14:52:46 <b_jonas> oerjan: why? it just needs an Enum instance for Strings
14:52:51 <b_jonas> that's not hard
14:52:51 <Cale> marshmallows: like what?
14:52:59 <marshmallows> strictish
14:53:03 <Cale> Oh, no
14:53:09 <Cale> Not at all, it's as lazy as can be.
14:53:13 <oerjan> hm indeed i was thinking it would be for all lists but that is unnecessary
14:53:24 <marshmallows> since it works on infinite lists
14:53:24 <Cale> It doesn't even make much sense to strictify it.
14:53:33 <opqdonut> for lists
14:53:36 <b_jonas> though now I think of it again, [x1 ..] could work too
14:53:40 <dolio> @src foldr'
14:53:40 <lambdabot> Source not found. Just what do you think you're doing Dave?
14:53:44 <b_jonas> (provided x1 is predefined)
14:53:45 <opqdonut> which brings us back to me realizing why
14:53:47 <b_jonas> > x1
14:53:48 <lambdabot>   Not in scope: `x1'
14:53:57 <opqdonut> :)
14:54:35 <b_jonas> though of course [x ..] could work as well
14:54:46 <glen_quagmire> > [x..]
14:54:47 <lambdabot>  Exception: not a number
14:54:49 <oerjan> opqdonut: yeah foldl' for lists was added because foldl is useless for them, while foldr' would be useless; for a general Foldable it could just as well go the other way
14:54:51 <b_jonas> in my compiler where I need to generate unique variable names but wanted them to be readable as well,
14:54:56 <dolio> foldr' f z (x:xs) = let z' = foldr' f z xs in z' `seq` f x z' ?
14:55:03 <opqdonut> oerjan: yes, exactly
14:55:03 <b_jonas> I used numbering like X, X1, X2, ... if the prefix was X
14:55:32 <opqdonut> oerjan: is there really any case where it's wise to use foldl and not foldl'?
14:55:41 <opqdonut> (except bottoms in the way)
14:55:41 <b_jonas> (unless X ends in a digit or underscore)
14:56:28 <marshmallows> gensym :: State [String] String = do (g:gs) <- get ; put gs ; return g
14:56:28 <oerjan> opqdonut: rumor says so :)
14:56:39 <marshmallows> that's how I did it, with withGensyms freshVariables = flip evalState freshVariables
14:57:13 <oerjan> opqdonut: perhaps if you are building something which is actually intended to be used lazily
14:57:34 <Cale> dolio: Yes, I suppose. You'd pretty much never want that though.
14:58:04 <madhadron> Cale, alright what I meant with the => in place of the == was that there are defined partial evaluations with foldr that are not defined with foldl
14:58:24 <madhadron> But I'm not sure how to state it in predicate calculus in a sensible manner
14:58:52 <b_jonas> marshmallows: but as I said, I wanted meaningful variable names
14:59:01 <Cale> madhadron: ah, but in the case of those particular expressions, it doesn't apply, since 'reverse' is sitting there making any infinite list into an undefined one.
14:59:10 <b_jonas> so a (usually meaningful) prefix is supplied to gensym by the caller
14:59:12 <madhadron> Ah, good point.
14:59:15 <marshmallows> yes, vars = ["x","y","z","w","v","k","r","p"] ++ map (("x"++) . show) [1..]
14:59:20 <madhadron> So, yes, completely equivalent where defined.
14:59:25 <b_jonas> that's _not_ meaningful
14:59:34 <Cale> madhadron: and undefined for the same things, in that case
14:59:37 <b_jonas> the prefix depends on the context
14:59:38 <marshmallows> yes it is
14:59:42 <marshmallows> it does
15:00:06 <b_jonas> how?
15:00:16 <Peaker> hey, is my description of monads accurate? http://rafb.net/p/GoAvjI92.html
15:00:16 <lambdabot> Title: Nopaste - Another description of monads?
15:00:17 <marshmallows> use several.. greek letters for types and so on
15:00:57 <madhadron> Does the everywhere operator in predicate calculus imply equality about where things are bottom as well?
15:01:11 <b_jonas> do you created several functoins for each prefix? I see
15:01:20 <Cale> > let vars = [replicateM n ['a'..'c'] | n <- [1..]] in vars
15:01:21 <lambdabot>  [["a","b","c"],["aa","ab","ac","ba","bb","bc","ca","cb","cc"],["aaa","aab","...
15:01:33 <Cale> > let vars = concat [replicateM n ['a'..'c'] | n <- [1..]] in vars
15:01:33 <lambdabot>  ["a","b","c","aa","ab","ac","ba","bb","bc","ca","cb","cc","aaa","aab","aac",...
15:01:53 <b_jonas> for reference, here's where I generated such symbols: http://www.math.bme.hu/~ambrus/pu/olvashato/
15:01:55 <lambdabot> Title: Olvashato compiler
15:02:11 <TSC> Peaker: It looks reasonable to me
15:02:19 <Cale> madhadron: everywhere operator?
15:02:21 <Peaker> TSC, thanks
15:02:26 <madhadron> Peaker, Well, actually it's a correspondence between an algebra and the free algebra of some kind generated by the objects in the original algebra...
15:02:45 <madhadron> Cale, [...] in Dijkstra's notation
15:02:58 <TSC> Peaker: Your description of the associativity law is a bit confusing unless you already know it (:
15:02:58 <Cale> hmm
15:02:59 <Peaker> madhadron, what is "free algebra"?
15:03:12 <madhadron> Peaker, I apologize, I was being an ass.
15:03:21 <Peaker> TSC, I am going to write a Python Monad class unit-test as a way to describe Monads for Python programmers :)
15:03:43 <malsyned> How do I get Cabal >=1.3.7 (required by cabal-install)?  The version being served up by HackageDB is 1.2.3.0
15:04:34 <Cale> Peaker: I'm not sure your terminology is spot on there...
15:04:52 <Cale> Peaker: The term 'monad' refers to a type constructor.
15:05:10 <Cale> (which has particular operations satisfying some laws)
15:05:23 <madhadron> Peaker, I think you have the shape right in your head, but the words aren't clear yet.
15:05:24 <Cale> But if you say, X is a monad, you're implying that X is a type constructor.
15:06:07 <Peaker> Cale, yeah I should be more accurate about that, I'm just going to do the Pythonic "equivalent" of the laws as a "unit test" for a Monad class
15:06:11 <Cale> A value of type X a in that case is called a computation in the monad X, or just a 'computation' or 'action', or 'monadically typed value'
15:06:26 <Cale> But never itself a monad.
15:06:49 <madhadron> Peaker, Actually, the free algebra definition clarifies things a bit.
15:06:57 <Cale> return x >>= f  ==  f x
15:06:59 <madhadron> The idea is that you have some algebra where you're working.
15:07:08 <madhadron> It has a set of operations among its elements.
15:07:20 <madhadron> Now throw away all the operations and take nothing but the elements.
15:07:31 <Cale> x >>= return  ==  x
15:07:32 <Peaker> Cale, the value is not a monad, the type constructor is a monad, right?
15:07:38 <Cale> Peaker: right
15:07:40 <madhadron> Can you build an algebra of some other type in a unique way on those elements?
15:07:52 <marshmallows> that's cool b_jonas
15:07:53 <Cale> Peaker: so monads really are something which exist at the level of types
15:08:17 <Peaker> madhadron, I can build one that has an operation ignore_args
15:08:24 <Peaker> madhadron, Not sure what the restrictions are
15:08:33 <madhadron> Peaker, Oh, no, you'd never actually program this way
15:08:39 <madhadron> But as a picture of what's going on it helps
15:09:13 <madhadron> Anyway, it turns out you can add a well defined set of stuff to those elements to get a "free algebra" --- basically the least structured algebra of the class you're after
15:09:46 <madhadron> Free algebras are nice because you can always get other, smaller algebras out of them by putting equivalence relations (== algebraic rules) on them.
15:09:50 <Peaker> madhadron, When you say "define an algebra", do you mean just define a set of operations that will be happy to take these elements as arguments? Ignore_args won't do?
15:09:51 <b_jonas> thanks
15:10:11 <madhadron> Peaker, Right, a set of operations with the algebraic properties you want
15:10:36 <Peaker> madhadron, what are the properties that I want? :)
15:10:59 <madhadron> Peaker, We're in category theory here.  We don't speak of properties.  That's a question you ask of universal algebra. (:
15:11:16 <madhadron> But the point is that category theory says you can build this thing (universal algebra tells you how to use it)
15:11:22 <madhadron> And the construction also gives you something else...
15:11:38 <madhadron> A function connecting this new algebra to the original thing before you threw away its structure
15:12:01 <madhadron> So you can write down things in the original algebra, and this function will carry them to appropriate structures in the new algebra
15:12:04 <madhadron> This function is the monad
15:12:41 <Peaker> madhadron, I don't understand - you said I define an algebra with "properties I want", which would they be?
15:12:52 <madhadron> Peaker, Well, here's a little more concrete example
15:13:09 <madhadron> We begin with a space of things which we'll think of as functions
15:13:46 <madhadron> We define an operation of composition among them, and an operation of combining them into new functions
15:14:00 <madhadron> Which satisfy some axioms to make things behave nicely
15:14:14 <madhadron> Then we throw those operations away, we're left with this pile of scrap
15:14:27 <Peaker> madhadron, what's the difference between composition and "combining"?
15:14:39 <madhadron> Peaker, Sorry, composition is applying a function to something
15:14:48 <madhadron> Combining is building a new function out of another function
15:14:52 <Peaker> composition as in: f . g ?
15:15:34 <madhadron> Peaker, Don't take this too literally. It's just to try to make clear what the monad is.
15:15:35 <Peaker> if you throw the operations away, you are left with f and g, and the result of f . g ?
15:15:42 <madhadron> Right
15:15:47 <Peaker> Yeah, but I thought we were grounding the abstraction with an example :)
15:16:20 <madhadron> A sketched example, which I can't produce the details for at 11PM
15:16:35 <madhadron> Anyway, you drop the operations, now say you want to go to another space entirely
15:16:42 <oerjan> b_jonas: olvashato means "able to read"?
15:16:47 <madhadron> Say, the space of ordered sequences of operations
15:17:17 <b_jonas> oerjan: readable
15:17:19 <dmwit> This explanation is really hard for me to understand, and I use monads every day...
15:17:24 <oerjan> oh
15:17:33 <madhadron> dmwit, It was probably a mistake.
15:17:48 <madhadron> dmwit, It's a gorgeously clear thing, corresponding to two paragraphs in MacLane
15:18:00 <madhadron> And it's probably pedagogically useless
15:18:20 <b_jonas> the story behind the name is that this homework was scored both by automatic tests and manually evaluating coding style
15:18:33 <madhadron> So for functions f,g,h, I can form a product fgh which means execute them in that order
15:18:34 <b_jonas> so the compiler is supposed to output readable prolog and readable sml
15:18:52 <madhadron> Which is distinct from fhg or gfh
15:18:55 <oerjan> heh
15:19:07 <b_jonas> thus, the common language that can only the common ground of those is called readable
15:19:27 <b_jonas> but later it turned out the the original source is more readable than what it's got compiled to (for me at least)
15:19:33 <b_jonas> luckily the name suits that as well
15:19:52 <madhadron> And if we made the operations really well defined, we would get a nice algebra of ordered sequences of functions.
15:19:58 <b_jonas> the teacher said it's a matter of what you're used to and that he could read the prolog code easier than the origianl
15:20:10 <b_jonas> (despite that it's not indented properly)
15:20:22 <b_jonas> but I think he hasn't seen the parts with higher-order functions
15:20:25 <madhadron> And there is a unique way of defining a useful function from our original algebra of functions to this new space of ordered sequences.
15:21:09 <b_jonas> I didn't have time to do the indenter properly
15:21:17 <madhadron> ...I'm going to stop babbling now.  Biologists shouldn't explain category theory to anyone.
15:21:30 <monochrom> haha
15:21:43 <b_jonas> I'm breaking the output to lines because the requirement was <72 characters per line iirc
15:22:04 <b_jonas> which is riddiculously little
15:23:21 <oerjan> i think that was sort of a standard (for email?)  it fit on an 80 character terminal even if quoted a few times
15:24:03 <b_jonas> oerjan: yeah
15:24:13 <dmwit> I try to write my code to 80-character margins.
15:24:15 <b_jonas> or maybe they printed it in three columns or something
15:24:25 <b_jonas> I usually write in 100 character margins
15:24:28 <marshmallows> I just want my code to fit on my screen
15:24:34 <b_jonas> but actually requiring that is just evil
15:24:55 <b_jonas> it makes the code uglier than if I wrap in whatever way I think I should
15:25:34 <Peaker> Here's something that might help us Pythoneers with monads: http://rafb.net/p/ivw8jR23.html
15:25:35 <lambdabot> Title: Nopaste - Fake unit tests for "Monad classes" in Python
15:26:14 <dons> has anyone used eclipsedarcs?
15:27:01 <b_jonas> there's also a smaller problem with readability, namely the compiler doesn't move unpacking data or constructors to the function head, but always writes it as a separate if/case statement
15:27:04 <dmwit> Peaker: They are just the monad laws in Python form?
15:27:14 <Peaker> dmwit, Yeah :)
15:27:19 <Peaker> dmwit, (I think)
15:27:19 <dmwit> =)
15:27:21 <madhadron> Peaker, Cale was right, though.  'build' is the monad.
15:27:33 <Cale> uh, what?
15:27:34 <Peaker> madhadron, build is "return" ?
15:27:54 <madhadron> Cale, Did I just put words in your mouth?  Sorry.
15:27:57 <Cale> build is return, not the monad itself :)
15:28:20 <madhadron> Peaker, Well, yes, but you don't have a type constructor here.
15:28:21 <Cale> build will have a type forall a. a -> M a, for some M. That M is the monad.
15:28:56 <dmwit> Peaker: Yup, those look right to me.
15:29:04 <Peaker> madhadron, well, Python's container classes are implicitly "polymorphic", and not created by a constructor for each specific type
15:29:49 <madhadron> Peaker, Alright.
15:29:58 <b_jonas> wait
15:30:08 <b_jonas> module names are not required to start with a capital?
15:30:08 * dmwit waits
15:30:30 <oerjan> b_jonas: yes they are
15:30:56 <madhadron> Yup, there are.  That's a mistake.
15:31:09 <b_jonas> ok
15:31:56 <b_jonas> also, on the same page 3
15:32:12 <b_jonas> "Nothing else in the language can."
15:32:21 <b_jonas> data constructors start with a capital letters too
15:32:46 <madhadron> Yes, that's also true.  But I think that qualifies as a "lie to children."
15:33:12 <madhadron> Since the document doesn't cover ADTs.
15:33:15 <oerjan> > (Maybe.maybe) 1 (const 2) Nothing
15:33:15 <lambdabot>   Not in scope: `Maybe.maybe'
15:33:20 <oerjan> eep
15:33:22 <b_jonas> madhadron: even with 'True' on the same page?
15:33:48 <b_jonas> change it to 'otherwise' then :)
15:33:57 <b_jonas> or just '1 == 1'
15:34:18 <dmwit> > maybe 1 (const 2) Nothing
15:34:19 <lambdabot>  1
15:34:28 * oerjan gives up finding a counterexample with hierarchical module name
15:34:29 <madhadron> No, I'll just change the statement about capitalization somehow.
15:34:58 <oerjan> dmwit: the point was to demonstrate that this was different from (maybe.maybe)
15:35:06 <dmwit> o
15:35:45 <dmwit> I think that doesn't prove anything, since there is no standard "maybe" module.
15:36:08 <oerjan> um it proves that the lower case is used for something else
15:36:19 <dmwit> I mean, everybody acknowledges that Haskell is case-sensitive; we're just wondering if lower-case modules are even possible.
15:36:21 <b_jonas> dmwit: even if there was, you'd still have to import it
15:36:27 <oerjan> and that the capitalization is required to disambiguate which namespace you mean
15:36:33 <dmwit> (But yes, I think we know that they are not possible, just by testing with the compiler. =)
15:37:07 <b_jonas> so are they not possible both by the 98 standard, and by the hierarchical expansion?
15:37:08 <madhadron> The compiler says no.
15:37:10 <dmwit> oerjan: It doesn't prove that lower case is used for something else... does it?
15:37:27 <b_jonas> dmwit: it's used for composition
15:37:35 <b_jonas> as in the (.) operator
15:37:36 <dmwit> Yes, I know.
15:37:38 <oerjan> dmwit: it proves that the interpretation of word1.word2 depends on the case of word1
15:37:59 <b_jonas> oerjan: are you sure it doesn't just depend on whether word1 is imported as a module?
15:38:07 <oerjan> b_jonas: yes
15:38:08 <dmwit> I don't think it proves that in the absence of a lower-cased module and the presence of doubt over the possibility of a lower-cased module.
15:38:17 <dmwit> But it hardly matters in the end, I guess. =P
15:38:38 <madhadron> I've rewritten the section where the capitalization comes after pointing out True and False, so I include data constructors in the list of capitalized things.
15:38:39 <oerjan> b_jonas: this is part of lexical analysis, which doesn't even need to know which modules are imported
15:38:43 <cjb> http://article.gmane.org/gmane.comp.lang.haskell.cafe/34503 is the blog engine I was looking for earlier, btw
15:38:46 <lambdabot> Title: Gmane -- Mail To News And Back Again
15:38:53 <b_jonas> dwmit: sure. I'll just keep using uppercase module names and spaces around the dot operator anyway
15:39:02 <dmwit> =)
15:39:42 <b_jonas> (at least where it's next to alnum chars)
15:40:28 <oerjan> > Just.id $ 3
15:40:28 <lambdabot>   Not in scope: `Just.id'
15:40:32 <oerjan> > Just .id $ 3
15:40:33 <lambdabot>  Just 3
15:40:55 <b_jonas> oerjan: that doesn't really prove it
15:41:09 <b_jonas> it could still depend on whether you import it just from looking those
15:41:28 <oerjan> hm
15:43:42 <oerjan> i cannot recall any actual ambiguity where the same fully qualified thing is both a module and a constructor
15:44:08 <oerjan> (data constructor)
15:45:18 <oerjan> b_jonas: hm wait it actually _does_ prove it, because Just.id is not interpreted as Just . id even though the Just module is nonexistent
15:46:11 <oerjan> well i guess theoretically it _could_ be that the module Just existed but exported no id
15:46:41 <b_jonas> hmm
15:46:44 <b_jonas> yes, you're right
15:46:46 <oerjan> ok no way to show it with that error message
15:47:13 <oerjan> since you cannot distinguish a nonexisting module from one that simply does not export something
15:47:14 <b_jonas> I too think there's no conflict with the exiting library, but you could easily define a constructor that's clashing with something
15:47:51 <oerjan> it would require a module that is a prefix of another.  some of those exist.
15:49:06 <oerjan> ah perhaps
15:49:14 <b_jonas> no, it wouldn't
15:49:14 <oerjan> :t Data.Time.LocalTime
15:49:15 <lambdabot> Couldn't find qualified module.
15:49:16 <b_jonas> like,
15:49:24 <oerjan> darn
15:49:44 <oerjan> :t Data.Time.LocalTime.LocalTime
15:49:45 <lambdabot> Couldn't find qualified module.
15:49:51 <oerjan> hmph
15:50:05 <b_jonas> import List; data Foo = List x;
15:50:09 <oerjan> that would have been an example if lambdabot imported it
15:50:18 <b_jonas> then how's you parse 'List.foo'
15:50:23 <oerjan> @hoogle LocalTime
15:50:23 <lambdabot> Data.Time.LocalTime :: module
15:50:23 <lambdabot> Data.Time.LocalTime.LocalTime :: data LocalTime
15:50:23 <lambdabot> Data.Time.LocalTime.LocalTime :: Day -> TimeOfDay -> LocalTime
15:50:28 <b_jonas> it could be the foo function from List, or List . foo
15:51:00 <oerjan> b_jonas: i _think_ LocalTime there is an example
15:51:15 <oerjan> it is reexported from Data.Time according to haddock
15:51:22 <b_jonas> wow
15:51:24 <b_jonas> I see
15:52:11 <b_jonas> still, these will never surpass the stupid parsing of perl
15:54:15 <dmwit> Isn't there a proof somewhere that parsing perl is an undecidable problem?
15:54:39 <oerjan> yes i think it was mentioned here before
15:54:49 <dmwit> http://www.perlmonks.org/?node_id=663393
15:55:08 <oerjan> purely compile-time parsing, that is
15:55:23 <dmwit> yeah
15:55:32 <dmwit> And that's just the parsing phase.
15:55:34 <marshmallows> I would not call that a proof
15:55:39 <marshmallows> merely an observation
15:55:45 <dmwit> At least Haskell's undecidability comes after parsing.
15:56:13 <oerjan> dmwit: erm you have not heard of the interaction between layout and definable precedence? :)
15:56:33 <dmwit> guess not =P
15:56:59 <b_jonas> perl is much worse than undecidable
15:57:00 <oerjan> someone made a local fixity declaration such that it is in scope at a point exactly if it isn't
15:57:14 <dmwit> Yikes!
15:57:15 <b_jonas> oerjan: yeah, that's what they say
15:57:16 <marshmallows> There is nothing bad about undecidable
15:57:19 <oerjan> iirc the hearsay :)
15:57:24 <b_jonas> I wonder how that could be true
15:57:33 <b_jonas> do fixity declarations act upwards?
15:57:34 <dmwit> marshmallows: Nothing... except possible non-termination, I guess.
15:57:51 <marshmallows> non termination is fine
15:57:57 <madhadron> I'm sure it could be true.  What I want to know is what the poor compiler DOES when it finds it.
15:58:14 <madhadron> Crashing would be too mundane.  I'm sure it creates a bubble universe.
15:58:37 <oerjan> b_jonas: it's because of that strange point in the report (which _no_ compiler implements) that says a nonassociative operator can affect whether an expression ends.  this can also trigger the layout rule to insert a }.
15:58:49 <b_jonas> > let { x = 100 - 10 - 1; infixr 6 -; } in x
15:58:50 <lambdabot>   Not in scope: `-'
15:58:57 <dmwit> Undecidability, the electronic version of, "This sentence is false."
15:59:08 <b_jonas> > let { x = 100 - 10 - 1; infixr 6 -; (-) = (Prelude.-) } in x
15:59:09 <lambdabot>  91
15:59:13 <b_jonas> > let { x = 100 - 10 - 1; infixl 6 -; (-) = (Prelude.-) } in x
15:59:14 <lambdabot>  89
15:59:20 <b_jonas> so it does work backwards
15:59:35 <b_jonas> than yes, I can imagine it's possible
15:59:54 <oerjan> b_jonas: the fixity declaration must be in the same block as the operator definition
16:00:49 <b_jonas> if I omit the fixity declaration but have a definition for the operator, does it revert to infixl 9 or does it inherit fixity from the outer block?
16:01:45 <oerjan> i think it reverts
16:02:25 <oerjan> > let { (-) = (Prelude.-) } in 3-2*4
16:02:25 <lambdabot>  4
16:02:59 <oerjan> > let { (-) = (Prelude.-) } in x-y*z
16:02:59 <lambdabot>  (x - y) * z
16:06:04 <b_jonas> I see
16:06:11 <b_jonas> oerjan: thanks for the example
16:06:26 <oerjan> Expr is really useful :)
16:06:39 <b_jonas> yeah
16:06:55 <oerjan> twanvl++
16:07:09 <b_jonas> no wonder why perl gives an example like that for operator overloading
16:07:15 <b_jonas> symbolic expressions
16:14:29 <sek> sorry to bug #haskell since this is a bit technical, but i'm trying to find a formula for the series 20, 90, 125, 195, 230... ie increments of 70 and then 35 and then 70 and so on, starting at 20. The best i've gotten is:
16:14:31 <sek> > map (\i -> 20 + 70*(floor $ 0.5*i) + 35*(ceiling $ 0.5*i)) [0..7]
16:14:32 <lambdabot>  [20,55,125,160,230,265,335,370]
16:14:43 <sek> which is increments of 35 and then 70 and then 35
16:15:37 <sek> @oeis [20, 90, 125, 195, 230]
16:15:37 <lambdabot> Sequence not found. Sorry about this, I know it's a bit silly.
16:16:10 <sarehu> > concat . iterate (map (+ 105)) $ [20,90]
16:16:11 <lambdabot>  [20,90,125,195,230,300,335,405,440,510,545,615,650,720,755,825,860,930,965,1...
16:16:15 <sek> oO
16:16:24 <oerjan> > scanl (flip (($).(+))) 20 $ cycle [70,35]
16:16:25 <lambdabot>  [20,90,125,195,230,300,335,405,440,510,545,615,650,720,755,825,860,930,965,1...
16:16:45 <sek> anything i can write down mathematically? Hence why i was trying with floor and ceiling
16:17:04 <oerjan> oh
16:17:11 <oerjan> (-1)^n is good for that
16:17:18 <sek> not that those two aren't great:)
16:17:36 <astrolabe> You could use a cosine(pi*n)  ugly though.  oerjan's is nicer.
16:18:00 <twanvl> or use: f(2k) = something; f(2k+1) = something else
16:18:07 <sek> so using an indicator function is inevitable?
16:18:29 <madhadron> Yes.  You have to select at least one of the set of even or odd integers.
16:18:56 <madhadron> You could get away with selecting just one by having it select a multiplication by two, but that isn't going to add much clarity.
16:19:02 <sek> Hmm, i thought so too initially, but then the one i came up seems to be able to alternate, but alternates the wrong way
16:19:19 <sarehu> > [29.75 + 52.5*n + 9.75*(-1)^n | n <- [0..]]
16:19:19 <lambdabot>  Add a type signature
16:19:27 <sarehu> > [29.75 + 52.5*n + 9.75*(-1)^n | n <- [0..]] :: [Double]
16:19:28 <lambdabot>   add an instance declaration for (Integral Double)
16:19:29 <idnar> @oeis 20 90 125 195 230
16:19:29 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
16:19:36 <sarehu> > [29.75 + 52.5*n + 9.75*(-1)**n | n <- [0..]]
16:19:37 <lambdabot>  [39.5,72.5,144.5,177.5,249.5,282.5,354.5,387.5,459.5,492.5,564.5,597.5,669.5...
16:19:51 <sarehu> > [29.75 + 52.5*n - 9.75*(-1)**n | n <- [0..]]
16:19:52 <lambdabot>  [20.0,92.0,125.0,197.0,230.0,302.0,335.0,407.0,440.0,512.0,545.0,617.0,650.0...
16:19:54 <idnar> hmm
16:19:57 <sarehu> er, close
16:20:03 <sarehu> fiddle the numbers
16:20:08 <ziman> > let s = 20:90:[105+x|x <- s] in take 20 s
16:20:09 <lambdabot>  [20,90,125,195,230,300,335,405,440,510,545,615,650,720,755,825,860,930,965,1...
16:20:32 <sek> heh a plethora of haskellian wonders
16:21:15 <sarehu> > fix ((20:) . (90:) . map (105+))
16:21:16 <lambdabot>  [20,90,125,195,230,300,335,405,440,510,545,615,650,720,755,825,860,930,965,1...
16:21:23 <idnar> > (70 + 35) / 2
16:21:24 <lambdabot>  52.5
16:21:31 <ziman> > let s = 20:90:map (+105) s in take 20 s
16:21:31 <lambdabot>  [20,90,125,195,230,300,335,405,440,510,545,615,650,720,755,825,860,930,965,1...
16:21:37 <idnar> > (70 - 35) / 2
16:21:38 <lambdabot>  17.5
16:21:51 <idnar> > 20 - 17.5
16:21:52 <lambdabot>  2.5
16:22:23 <madhadron> let s = map (\x -> 20 + 35*(1 + x `mod` 2)) [1..]
16:22:27 <idnar> > map (\n -> 2.5 + 52.5*n - (17.5)*(-1)**n) [0..]
16:22:28 <lambdabot>  [-15.0,72.5,90.0,177.5,195.0,282.5,300.0,387.5,405.0,492.5,510.0,597.5,615.0...
16:22:39 <glen_quagmire> is there a way to run hoogle offline? I need to go to a place without the Internet connection
16:22:41 <idnar> > map (\n -> 2.5 + 52.5*n - (17.5)*(-1)**(n+1)) [0..]
16:22:41 <lambdabot>  [20.0,37.5,125.0,142.5,230.0,247.5,335.0,352.5,440.0,457.5,545.0,562.5,650.0...
16:22:53 <idnar> oh oops
16:23:05 <idnar> > map (\n -> 37.5 + 52.5*n - (17.5)*(-1)**(n)) [0..]
16:23:05 <lambdabot>  [20.0,107.5,125.0,212.5,230.0,317.5,335.0,422.5,440.0,527.5,545.0,632.5,650....
16:23:28 <idnar> argh what
16:23:31 <oerjan> fiddling the numbers is proving remarkably awkward :D
16:23:36 <sek> hehe
16:23:43 * idnar wonders how he got that wrong
16:24:20 <idnar> > map (\n -> 52.5*n + (17.5)*(-1)**n) [0..]
16:24:20 <lambdabot>  [17.5,35.0,122.5,140.0,227.5,245.0,332.5,350.0,437.5,455.0,542.5,560.0,647.5...
16:24:36 <glen_quagmire> w00t found hoogle source code
16:24:40 <idnar> > 52.5 + 17.5
16:24:41 <lambdabot>  70.0
16:24:48 <idnar> > 35 - 17.5
16:24:48 <lambdabot>  17.5
16:25:20 <idnar> > map (\n -> 52.5*(n + 1) + (17.5)*(-1)**n) [0..]
16:25:21 <lambdabot>  [70.0,87.5,175.0,192.5,280.0,297.5,385.0,402.5,490.0,507.5,595.0,612.5,700.0...
16:25:35 <oerjan> > map (\n -> 52.5*n) [0..]
16:25:36 <lambdabot>  [0.0,52.5,105.0,157.5,210.0,262.5,315.0,367.5,420.0,472.5,525.0,577.5,630.0,...
16:25:53 * idnar is not thinking clearly about this
16:26:11 <oerjan> 20,90,125
16:26:23 <marshmallows> > [0.0,52.5..}
16:26:23 <lambdabot>  Parse error at "}" (column 12)
16:26:28 <marshmallows> > [0,52.5..]
16:26:28 <lambdabot>  [0.0,52.5,105.0,157.5,210.0,262.5,315.0,367.5,420.0,472.5,525.0,577.5,630.0,...
16:27:09 <oerjan> > 90-52.5
16:27:09 <lambdabot>  37.5
16:27:43 <oerjan> > (20+37.5)/2
16:27:44 <lambdabot>  28.75
16:27:59 <ivant> @seen dons
16:27:59 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 57m 47s ago.
16:28:42 <oerjan> > map (\n -> 28.75+52.5*n - 8.75*(-1)**n) [0..]
16:28:42 <lambdabot>  [20.0,90.0,125.0,195.0,230.0,300.0,335.0,405.0,440.0,510.0,545.0,615.0,650.0...
16:28:53 <sek> yay!
16:28:54 <idnar> what is 8.75?
16:29:01 <idnar> oh, 17.5 / 2
16:29:02 <idnar> duh.
16:29:20 <idnar> > map (\n -> round $ 28.75+52.5*n - 8.75*(-1)**n) [0..]
16:29:21 <lambdabot>  [20,90,125,195,230,300,335,405,440,510,545,615,650,720,755,825,860,930,965,1...
16:29:33 <sek> thanks to everyone
16:29:40 <Cale> @oeis 20,90,125,195,230
16:29:41 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
16:30:07 <marshmallows> what is that sequence about?
16:30:26 <marshmallows> > describeSequence [20,90,125,195,230]
16:30:27 <lambdabot>  Nothing
16:30:48 <oerjan> > map (\n -> (115 + 210*n - 39*(-1)**n)`div` 4) [0..]
16:30:49 <lambdabot>  Add a type signature
16:30:55 <oerjan> > map (\n -> (115 + 210*n - 39*(-1)^n)`div` 4) [0..]
16:30:56 <lambdabot>  [19,91,124,196,229,301,334,406,439,511,544,616,649,721,754,826,859,931,964,1...
16:31:03 <madhadron> Howabout...
16:31:03 <oerjan> oops
16:31:10 <marshmallows> what's this for?
16:31:12 <madhadron> map (\x -> 20 + 35*floor(x/2) + 70*floor((x+1)/2)) [0..]
16:31:29 <sek> the context it arose is slightly complicated and quite irrelevant to anything to do with haskell
16:31:29 <oerjan> > map (*4) [28.75, 52.5, 8.75]
16:31:30 <lambdabot>  [115.0,210.0,35.0]
16:31:36 <oerjan> oh
16:31:41 <oerjan> > map (\n -> (115 + 210*n - 35*(-1)^n)`div` 4) [0..]
16:31:42 <lambdabot>  [20,90,125,195,230,300,335,405,440,510,545,615,650,720,755,825,860,930,965,1...
16:32:25 <marshmallows> ohh
16:32:26 <marshmallows> 20, 90, 125, 195, 230... ie increments of 70 and then 35 and then 70
16:32:57 <ziman> > take 20 $ foldr (\(x,y)->((x:).(y:))) [] $ zip [20,125..] [90,195..]
16:32:58 <lambdabot>  [20,90,125,195,230,300,335,405,440,510,545,615,650,720,755,825,860,930,965,1...
16:33:08 <marshmallows> > reverse $ foldr (\x ys -> x+70+35:x+70:ys) 20 $ []
16:33:08 <lambdabot>   add an instance declaration for (Num [a])
16:33:31 <marshmallows> > reverse $ foldr (\x ys -> x+70+35:x+70:ys) [] $ 20
16:33:31 <lambdabot>   add an instance declaration for (Num [a])
16:33:49 <marshmallows> > reverse $ foldr (\x ys -> (x+70+35):(x+70):ys) [] $ 20
16:33:49 <lambdabot>   add an instance declaration for (Num [a])
16:34:14 <madhadron> ziman, Very nice.
16:34:33 <oerjan> marshmallows: reversing an infinite list?
16:34:41 <oerjan> er wait
16:35:00 <Botje> marshmallows: flip the arguments
16:35:24 <marshmallows> > concatMap (\x -> [x+70,x+70+35]) 20
16:35:24 <lambdabot>   add an instance declaration for (Num [a])
16:35:43 <marshmallows> > let xs = concatMap (\x -> [x+70,x+70+35]) 20:xs in xs
16:35:43 <lambdabot>   add an instance declaration for (Num [a])
16:36:11 <marshmallows> > let xs = concatMap (\x -> [x+70,x+70+35]) (20:xs) in xs
16:36:14 <lambdabot>  [90,125,160,195,195,230,230,265,265,300,265,300,300,335,300,335,335,370,335,...
16:36:40 <marshmallows> I give up..
16:36:49 <oerjan> > fix ((20:).concatMap (\x -> [x+70,x+70+35]))
16:36:50 <lambdabot>  [20,90,125,160,195,195,230,230,265,265,300,265,300,300,335,300,335,335,370,3...
16:40:05 <oklopol> can i do randomization with lambdabot?
16:40:12 <oklopol> my current choisemaker bot is offline
16:40:15 <oklopol> *usual
16:40:25 <marshmallows> !die 1d666
16:40:29 <marshmallows> @die 1d666
16:40:29 <lambdabot> 1d666 => 461
16:40:40 <oklopol> thanks
16:40:41 <marshmallows> @. brain
16:40:41 <lambdabot> Not enough arguments to @.
16:40:43 <marshmallows> @brain
16:40:43 <lambdabot> Brain! Brain! You aren't going to leave me!!!???You know what happened to Jerry Lewis after Dean Martin left him!!!
16:40:52 <oklopol> @die 1d2
16:40:52 <lambdabot> 1d2 => 2
16:40:58 <Botje> marshmallows: thanks for reminding me!
16:41:05 <Botje> i still have 30ish episodes of pinky & brain to see :)
16:41:06 <Cale> > random (mkStdGen 42) :: Bool
16:41:07 <lambdabot>  Couldn't match expected type `Bool'
16:41:12 <Cale> err...
16:41:14 <Cale> :t rando
16:41:15 <lambdabot> Not in scope: `rando'
16:41:15 <Cale> :t random
16:41:16 <lambdabot> forall g a. (RandomGen g, Random a) => g -> (a, g)
16:41:16 * oklopol is watching scrubs
16:41:23 <Cale> > random (mkStdGen 42) :: (Bool, StdGen)
16:41:24 <lambdabot>  (True,1720602 40692)
16:41:28 <oklopol> 2 indicated another episode
16:43:25 <Toxaris_> > tail . concatMap (take 2) . iterate (drop 3) $ [-15, 20 ..]
16:43:25 <lambdabot>  [20,90,125,195,230,300,335,405,440,510,545,615,650,720,755,825,860,930,965,1...
16:46:09 <Toxaris_> > scanl (+) 20 . cycle $ [70, 35]
16:46:10 <lambdabot>  [20,90,125,195,230,300,335,405,440,510,545,615,650,720,755,825,860,930,965,1...
16:46:49 <ivant> @ty scanl
16:46:50 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
16:47:01 <oerjan> oh right ($) = id
16:47:45 <glen_quagmire> type I a = Identity a   ;  type S a = StateT String I a   -- what's wrong with this?
16:47:46 <ziman> Toxaris_, nicee :)
16:48:01 <Botje> glen_quagmire: it probably wants (I a)
16:48:08 <ivant> > scanl (+) 20 $ cycle [70, 35]
16:48:08 <lambdabot>  [20,90,125,195,230,300,335,405,440,510,545,615,650,720,755,825,860,930,965,1...
16:48:23 <SamB> no wonder Data.HashTable is so slow
16:49:07 <SamB> each hashtable holds pointers to a hash function and a comparison function!
16:49:22 <glen_quagmire> Expected kind `* -> *` but `I a` has kind *
16:49:36 <SamB> i.e.., the compiler can't optimize the calls!
16:50:34 <glen_quagmire> oh StateT's type is not what i was thinking
16:50:39 <dons> SamB: that's right.
16:50:47 <dons> SamB: just moving them to a type class would likely help a lot
16:50:59 <SamB> yeah
16:51:00 <dons> easy job if you'd like to try
16:51:14 <SamB> too bad that would change the interface
16:51:44 <dons> doesn't matter. just make a package
16:51:59 <dons> we're keen to remove HashTable.hs from base anyway, i've no idea why its there
16:51:59 <SamB> dons: that won't make Jhc compile base any faster, unfortunately
16:52:10 <SamB> well, right now Data.Typeable is using it
16:52:21 <SamB> or was it Data.Dynamic?
16:52:38 <dons> no, really?
16:52:40 <gwern> I find this http://latexki.nomeata.de/ thing dons posted to proggit confusing. the svn repo is just a mess of .hs files and and text and python
16:52:42 <lambdabot> Title: The Latexki Latex Wiki Wiki - index
16:52:48 <SamB> yes, really!
16:52:56 <dons> SamB: i think it uses a hashtable in the runtime
16:52:59 <SamB> I'm not sure if that's why it's still there
16:53:01 <dons> unless you can persuade me otherwise
16:53:03 <bakert> process library, anyone?
16:53:08 <SamB> dons: what?
16:53:08 <dons> i'm almost certain its never used HashTable.hs
16:53:15 <dons> bakert: the process library perhaps?
16:53:21 <SamB> dons: then why did Jhc complain that it was missing!
16:53:26 <bakert> dons: where can i get it?
16:53:29 <dons> SamB: there's a hashtable in the runtime for generating types.
16:53:40 <SamB> what runtime?
16:53:44 <SamB> Jhc doesn't have any runtime
16:53:45 <dons> bakert: its in the core libraries. but you should be able to find it on hackage.
16:53:45 <glen_quagmire> Prelude Control.Monad.State Control.Monad.Identity>   -- ghci prompt looks like this. Is there a way to import modules to ghci (preferably qualified) but not show what's imported in the prompt?
16:53:55 <dons> SamB: oh, jhc might have a variant that uses hashtable.hs
16:54:12 <shachaf> glen_quagmire: :set prompt?
16:54:17 <SamB> actually, I think I overwrote one of Jhc's files...
16:54:20 <bakert> dons: hmm ... my 6.6 install is complaining it doesn't have it installing darcs-graph.  will check hackage.. thanks.
16:54:45 <glen_quagmire> shachaf: oh thank you
16:54:59 <shachaf> glen_quagmire: use %s for the imports.
16:55:16 <gwern> SamB: how can jhc not provide runtimes? is the GC being integrated into the program itself in some clever way?
16:55:21 <shachaf> It would be nice if it could show the primary module ("Prelude", "*Main") but not the rest of it.
16:55:47 <SamB> gwern: first of all, JHC doesn't have a GC right now
16:55:54 <SamB> it's supposedly using region inference
16:56:11 <gwern> SamB: that, uh, sounds dangerous. no GC...
16:56:27 <bakert> hmmm ... something gone a bit skewiff methinks ... asking for directory and time now
16:56:29 <SamB> perfectly safe!
16:56:31 <bakert> old-time
16:56:32 <gwern> @seen gwern
16:56:32 <lambdabot> You are in #xmonad and #haskell. I last heard you speak just now.
16:56:33 <SamB> just not very efficient
16:56:37 <sek> oerjan, i'm having a hard time figuring out how you picked what you picked. I'm working out the same kind of sequence but for starting value 56, and successive increments of 21 and 84
16:56:41 <gwern> heh
16:56:59 <sek> > map (\n -> 40.25 + 52.5*n - 21*(-1)**n) [0..]
16:56:59 <lambdabot>  [19.25,113.75,124.25,218.75,229.25,323.75,334.25,428.75,439.25,533.75,544.25...
16:57:27 <sek> scanl (+) 56 . cycle $ [21, 84]
16:57:29 <hasenov__> sorry for having two identities
16:57:33 <sek> > scanl (+) 56 . cycle $ [21, 84]
16:57:34 <lambdabot>  [56,77,161,182,266,287,371,392,476,497,581,602,686,707,791,812,896,917,1001,...
16:58:01 <hasenov__> ello
16:58:10 <hasenov__> test
16:59:41 <glen_quagmire> type I a = Identity a; type S a = StateT (const I (a, String))   how can I do this?
17:00:15 <gwern> so latexki.hs has an 'import Latex', but Latex.hs has for its contents '\begin{eqnarray*} i_w\cdot\psi_v\cdot N_w&=&\psi_w\cdot i_w\cdot N_w\\ &=&\psi_w\cdot i_w\cdot\sum_{\sigma\in G_w}\sigma\\ &=&\psi_w\cdot\sum_{\sigma\in G_w}\sigma\\ &=& i_w\cdot N_w\cdot\psi_w. \end{eqnarray*}'
17:00:20 <gwern> wtf?
17:00:58 <allbery_b> supposed to be Latex.lhs ?
17:01:22 <Botje> glen_quagmire: you need to put parens around the I
17:01:27 <gwern> allbery_b: even so, how could that possibly be haskell code? it doesn't look right to me at all, even assuming Latex.lhs
17:01:41 <allbery_b> it
17:01:44 <gwern> and greeping, I see no 'module Latex' anywhere
17:01:44 <allbery_b> s not
17:01:48 <allbery_b> look for \begin{code}
17:01:55 <allbery_b> (latex-style literate haskell)
17:02:02 <gwern> dons: did you manage to run latexki?
17:02:11 <oerjan> glen_quagmire: i think you are hitting the "type synonyms must be fully expanded" restriction. try type I = Identity
17:02:15 <oklopol> @die 1d2
17:02:15 <lambdabot> 1d2 => 2
17:02:37 <oklopol> why do bots always want me to watch tv shows all night...
17:03:10 <Botje> so you won't resist as much when they take over
17:03:41 <gwern> rotting your brain makes you that much more dependent on them
17:03:46 <NikkiA> oklopol: you could always exert some independent thinking over the bot :P
17:03:47 <gwern> speaking of which, think I
17:03:54 <gwern> ll go watch some simpsons now
17:04:05 <oerjan> sek: ok first step is to find the _average_ increase, which goes on the *n.  so (21+84)/2 = 52.5
17:04:15 <sek> yeah
17:04:38 <marshmallows> @dye 99d66
17:04:38 <lambdabot> Maybe you meant: dice type
17:04:41 <marshmallows> @die 99d66
17:04:41 <lambdabot> 99d66 => 3398
17:04:52 <NikkiA> (excuse me for not talking much, i feel like a complete retard when it comes to programming in haskell so far :)
17:05:06 <Botje> NikkiA: IRC is built on idlers :)
17:05:18 <NikkiA> Botje: true
17:06:00 <sek> oerjan, for the first one you seem to have used (inc1 +2*base + (inc1+inc2)/2)/2
17:06:32 <glguy> seems like STUArrays are 10x slower than IOUArrays
17:07:03 <oerjan> My next realization was to find out what the first value would have been if it had the *opposite* (-1)^n adjustment.  so, 77 - 52.5 = 24.5.  Then take the average of this with the actual first value, (24.5+56)/2 = 40.25
17:07:13 <oerjan> that becomes the constant term
17:07:49 <sek> yep, what my formula gives
17:08:14 <sek> > map (\n -> 40.25 + 52.5*n - 21*(-1)**n) [0..]
17:08:15 <lambdabot>  [19.25,113.75,124.25,218.75,229.25,323.75,334.25,428.75,439.25,533.75,544.25...
17:08:22 <oerjan> then subtract the actual first value from the constant term to get the (-1)^n adjustment.  56 - 40.25 = 15.75
17:08:34 <sek> ooh, was getting the last one wrong. I see
17:08:40 <sek> > map (\n -> 40.25 + 52.5*n - 15.75*(-1)**n) [0..]
17:08:40 <lambdabot>  [24.5,108.5,129.5,213.5,234.5,318.5,339.5,423.5,444.5,528.5,549.5,633.5,654....
17:09:01 <marshmallows> > map (-0.5^n) [0..]
17:09:01 <lambdabot>   add an instance declaration for (Fractional (a -> b))
17:09:05 <oerjan> > map (\n -> 40.25 + 52.5*n + 15.75*(-1)**n) [0..]
17:09:05 <lambdabot>  [56.0,77.0,161.0,182.0,266.0,287.0,371.0,392.0,476.0,497.0,581.0,602.0,686.0...
17:09:08 <marshmallows> > map ((-0.5)^n) [0..]
17:09:08 <lambdabot>   add an instance declaration for (Fractional (a -> b))
17:09:13 <marshmallows> > map (\n->(-0.5)^n) [0..]
17:09:13 <lambdabot>  [1.0,-0.5,0.25,-0.125,6.25e-2,-3.125e-2,1.5625e-2,-7.8125e-3,3.90625e-3,-1.9...
17:09:24 <sek> i see. Thanks alot, once again
17:09:27 <marshmallows> > map (\n->(0:+1)^n) [0..]
17:09:27 <lambdabot>  [1.0 :+ 0.0,0.0 :+ 1.0,(-1.0) :+ 0.0,-0.0 :+ (-1.0),1.0 :+ -0.0,0.0 :+ 1.0,(...
17:10:04 <augustss_> it's a fluke that (-1)**n works
17:12:23 <EvilTerran> > map ((-1)**) [0..]
17:12:24 <lambdabot>  [1.0,-1.0,1.0,-1.0,1.0,-1.0,1.0,-1.0,1.0,-1.0,1.0,-1.0,1.0,-1.0,1.0,-1.0,1.0...
17:13:24 <glen_quagmire> oerjan: thank you . that fixed it.
17:13:36 <EvilTerran> @check liftA2 (||) (1==) (-1==) . ((-1)**) :: Int -> Bool
17:13:36 <lambdabot>   add an instance declaration for (Floating Int)
17:13:48 <EvilTerran> @check liftA2 (||) (1==) (-1==) . ((-1)**) . floor :: Float -> Bool
17:13:49 <lambdabot>  Add a type signature
17:15:12 <augustss_> The default implementation of ** is in terms of log and exp.  But ghc calls the C function pow for **, and pow handles some extra cases
17:15:43 <EvilTerran> ohh, *that*'s what you meant. never mind me.
17:19:14 <SamB> @hoogle fixIO
17:19:14 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
17:19:37 <oerjan> @src IO mfix
17:19:37 <lambdabot> mfix = fixIO
17:20:06 <oerjan> @src MonadFix
17:20:06 <lambdabot> class (Monad m) => MonadFix m where
17:20:06 <lambdabot>     mfix :: (a -> m a) -> m a
17:20:31 <SamB> I'm actually trying to get Control.Monad.Fix to compile in Jhc
17:23:48 <oklopol> @die 1d2
17:23:48 <lambdabot> 1d2 => 2
17:23:50 <oklopol> :o
17:23:58 <oklopol> i want to sleep!
17:24:04 <oklopol> hmm...
17:24:21 <oklopol> it *is* one two-sided die right?
17:24:26 <oerjan> yes
17:24:30 <oklopol> good, good
17:24:33 <roconnor> @die 1d1
17:24:33 <lambdabot> 1d1 => 1
17:24:41 <oklopol> @die 2d§
17:24:41 <lambdabot> unexpected "\167": expecting number
17:24:43 <oklopol> @die 2d1
17:24:43 <lambdabot> 2d1 => 2
17:24:48 <roconnor> @die 1d0
17:24:48 <lambdabot> 1d0 => 1
17:24:52 <roconnor> :/
17:25:21 <marshmallows> @die 22153454d0
17:25:21 <lambdabot> 22153454d0 => -26965397022934738615939577861835371004269...
17:25:24 <marshmallows> @die 2215344354d0
17:25:24 <lambdabot> 2215344354d0 => -26965397022934738615939577861835371004269...
17:25:29 <marshmallows> @die 2d0
17:25:29 <lambdabot> 2d0 => 2
17:30:56 <glen_quagmire> let's say you have a type YourType.  now you wrap it in various monads, what would you call it?  YourTypeM ?
17:31:47 <bd_> what does the monad do?
17:31:54 <bd_> is the question you should be asking...
17:32:07 <glen_quagmire> i'm wrapping it in Identity, ErrorT, StateT  currently
17:32:26 <bd_> I mean, what's YourType in the monad anyway? A state for StateT? A ReaderT context? The ErrorT error type? :)
17:33:12 <oklopol> @die 1d2
17:33:12 <lambdabot> 1d2 => 1
17:33:43 * oerjan notes that oklopol is fresh out of coins ;)
17:33:44 <roconnor> ErrorStateYourType
17:34:05 <glen_quagmire> do you use ide with renaming capability?
17:34:15 <bd_> the monads are being composited for some purpoe, and it' often good to just name the monad after what it does, not what it's made out of
17:34:17 <glen_quagmire> naming is so hard
17:34:29 <roconnor> let's go shopping instead
17:34:52 <bd_> glen_quagmire: They say there are only two hard problems in computer science: Cache invalidation and naming things.
17:35:02 <glen_quagmire> Val is values for my language.  I wrap it in Error, State..  so that functions can throw errors..etc
17:35:21 <bd_> glen_quagmire: Well, then you have SomeMonad Val, right?
17:35:27 <bd_> SomeMonad has nothing inherently to do with Val
17:35:35 <bd_> you could call it InterpM or something
17:36:02 <glen_quagmire> Interperter Monad?
17:36:37 <bd_> sure
17:36:51 <bd_> or EvalM or something
17:37:03 <bd_> because it's going to be holding more than just Val at points I expect.
17:37:08 <glen_quagmire> :t liftM
17:37:08 <Philippa> I've tended to go with Eval
17:37:08 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:37:09 <bd_> (), for one
17:37:21 <Toxaris_> I would call it Interp or Eval or whatever without M.
17:37:54 <Toxaris_> the M suffix is typically used to name a monadified version of a normally nonmonadic function
17:37:58 <Toxaris_> e.g. mapM vs. map
17:38:34 <Toxaris_> but there's no reason to name a type constructor differently if it's a monad instance (e.g. it's Maybe and not MaybeM)
17:39:49 * Cale is starting to see that our problem now is not bad monad tutorials, but bad monad transformer tutorials.
17:40:06 <marshmallows> @go monad transformers step by step
17:40:12 <lambdabot> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
17:40:12 <lambdabot> Title: Monad Transformers Step by Step
17:40:13 <Cale> Even that one.
17:40:46 <glen_quagmire> i was reading that one. i was stuck at how to define a variable and call eval function with the modified state
17:40:50 <marshmallows> how?
17:41:10 <Cale> It seems that almost every reasonably complete monad transformer tutorial doesn't actually tell you a good way to use monad transformers in a whole program, it just discusses how they work and how they can be used to build up monads.
17:41:28 <marshmallows> that one does..
17:41:46 <Cale> People are left with the impression that it's actually expected that you write code where the types involve large stacks of monad transformers everywhere.
17:41:56 <SamB> I guess I should have finished mine
17:41:58 <glen_quagmire> that one just lets you do runEval8 example  or something
17:42:16 <SamB> it was going to walk through the process of implementing a BF interpreter...
17:42:20 <Cale> You really need newtype deriving to make monad transformers practical.
17:42:27 <SamB> using as many cool features as possible
17:42:30 <marshmallows> what does that do?
17:43:23 <Cale> newtype MyMonad a = MM (StateT MyState (ReaderT MyEnv IO) a) deriving (Functor, Monad)
17:43:27 <Cale> Something like this.
17:43:48 <Cale> You wrap the stack of transformers up, and hide the fact that you're using monad transformers.
17:43:57 <Toxaris_> marshmallows: newtype Eval a = StateT Heap ReaderT Environment Identity a deriving (Functor, Monad, MonadState Heap, MonadReader Environment)
17:44:20 <SamB> yes. because you ARE going to change the stack
17:44:21 <Cale> You then, typically, implement operations for your monad in terms of the various things in the transformer stack, and the data constructor for your newtype
17:44:26 <dons> Cale: agreed.
17:44:37 <Cale> But you *hide* the newtype data constructor behind a module boundary.
17:44:49 <Cale> So the rest of the program doesn't see how your monad is built up.
17:44:50 <dons> people are entirely scared and unsure about simple things like ReaderT .. (StateT .. (IO
17:44:59 <Cale> And they should be.
17:45:28 <dons> also, there's an ongoing issue of people not knowing what features they need aheda
17:45:33 <Cale> You should never actually see that type outside of the context of that one (usually pretty small) library you're building.
17:45:34 <dons> and then running into a refactoring session
17:45:55 <Cale> Yes, and abstracting using newtype deriving helps make that much much simpler.
17:46:24 <Cale> Because you only have a limited set of primitives which need to be reimplemented when you change your monad's representation.
17:46:47 <Cale> Rather than having to change the number of lifts everywhere throughout your program.
17:47:38 <Cale> I suppose one way to put it is that the existing monad transformer tutorials teach the science of monad transformers, but not the engineering.
17:48:52 <Cale> That Monad Transformers Step by Step article can at least be commended for using type declarations, but it really ought to be using newtypes.
17:49:08 <Toxaris_> Maybe it predates newtype deriving?
17:49:11 <Peaker> it could be nice to have an editor feature that lets you type an expression that yields some value, and then use a key that shows you all existing functions that can be used on that type -- inspired by the OO editor feature of showing all methods of an instance as you type the instance (dot)
17:49:13 <Cale> That's possible.
17:49:30 <marshmallows> would it be improved at all if it did use newtype?
17:49:36 <dons> newtype deriving Monad, MonadState et al is really important, I think, and fairly new
17:49:36 <Cale> Or possibly the author wanted to stay Hugs-compatible. I'm not sure that Hugs implements newtype deriving.
17:49:43 <Cale> marshmallows: Yeah.
17:49:47 <dons> perhaps its time for a monad transformers tut for the last 2000s
17:50:23 <glen_quagmire> realworldhaskell will include transformer chapter probably
17:50:33 <scook0> it's funny, I always considered newtype-deriving the "obvious" way to use monad transformers
17:50:41 <scook0> because I picked it up from pugs
17:50:49 <Cale> scook0: That's good! :)
17:50:59 <SamB> Cale: well, I would tend to use newtype derivings sparingly...
17:51:04 <Cale> scook0: It seems that a lot of people miss this fact and paint themselves into a corner.
17:51:19 <Cale> and then blog about how monads are unusable
17:51:49 <scook0> it's a bit unusual, the fact that I (and others) learned haskell in the context of modifying a big program
17:51:52 <dons> Cale, also, MLers in particular are looking for excuses :)
17:52:03 <scook0> rather than puttering around with small ones
17:52:19 <redleafgr> I'm having a type issue while trying to instance a Vector class with a tuple: http://hpaste.org/6416 Probably because my function def isn't polymorphic enough...
17:52:24 <redleafgr> I think what would fix this is somehow being able to specify a conversion from s to any of a, b, or c in the function def, but I don't know how to express that for general Num types... anybody have an idea what I should do?
17:52:28 <scook0> I think it was about two years before I actually tried to *write* a haskell program :)
17:52:34 <Cale> dons: It's strange. Most of the MLers who I met in real life were quite comfortable and happy with monads in ML.
17:52:54 <Cale> dons: In fact, one of them had used monads in Maple :)
17:52:58 <marshmallows> use (Num e) => Vector (e, e, e)
17:52:59 <dons> heh wow
17:53:27 <redleafgr> something like fromNum
17:53:40 <redleafgr> I know that if I change s to be an Integer, and use fromInteger in all the multiplies, it works...
17:53:47 <augustss_> newtype deriving is a scary feature
17:53:57 <augustss_> but very handy
17:54:04 <dons> handy and scary, yep.
17:54:17 <oerjan> redleafgr: having scale work for all Num s is a bit much to ask
17:54:26 <dons> it only has to be fairly simple though, some of the magic / cunning deriving is rarely used i think
17:54:34 <scook0> newtype would be much less useful without deriving
17:54:44 <glen_quagmire> it seems like transformers are defined like:  MonadNameT = { runMonadNameT ::  blah blah }
17:54:49 <augustss_> but the way it's done in ghc isn't sound
17:54:52 <glen_quagmire> ^ newtype
17:54:53 <oerjan> redleafgr: there is no way to convert a _general_ Num to any other numeric type
17:55:03 <scook0> or, more precisely, you would be discouraged from using it if you had to write the boilerplate yourself
17:55:04 <redleafgr> hmm
17:55:27 <dons> augustss_: aren't there derivings ghc can do, that can't be written ?
17:55:37 <nominolo> what's so scary?
17:55:38 <augustss_> dons: exactly
17:55:39 <redleafgr> oerjan: what would you recommend instead, scrapping the tuple idea and using a more specific data type where all 3 fields are of the same type as s?
17:55:40 <dons> that's scary.
17:55:54 <oerjan> redleafgr: you can use Integral s  and fromIntegral, or Real s and RealToFrac (but that requires Fractional on the instances)
17:55:54 <kpreid> scook0: sometimes you write a newtype just to be able to define an instance which *isn't* the obvious derived one...
17:56:07 <lament> Cale: write a monad transformers tutorial using newtype deriving!
17:56:16 <EvilTerran> augustss_, dons - can you give an example?
17:56:25 <oerjan> that's the most polymorphic version i can think of
17:56:25 <scook0> speaking of newtype-deriving ... I always wondered what happens in the overlap between regular-deriving and newtype-deriving
17:56:32 <scook0> does the regular derivation always win?
17:56:33 <augustss_> EvilTerran: there's an open bug report about it
17:56:39 <EvilTerran> ok
17:56:41 <redleafgr> oerjan: yeah, i'd rather use reals than integers, of course
17:57:09 <scook0> kpreid: sure, but if you want to write your own MonadState instance, it sucks to have to write Monad as well
17:57:11 <solrize_> i think those tutorials need to be written like calculus texts, with lots of pencil and paper exercises that are just pure calculation
17:57:14 <Cale> lament: I wrote a sort of separate tutorial called "How to use monad transformers", but it starts from the assumption that you already know what monad transformers are about.
17:57:27 <Cale> lament: and just talks about using them correctly in a larger scale program
17:57:40 <augustss_> newtype deriving was broken before the internal switch to F_C, after the switch it's broken in a different way
17:57:52 <augustss_> But as long as you use it wisely it works
17:58:17 <Cale> Hmm, that's interesting
17:58:32 <Cale> What derivings can it do which are broken?
17:58:49 <augustss_> Let me see if I can find the bug report
17:59:32 * SamB attempts to get Jhc to stop trying to rename (->)
17:59:46 <augustss_> basically, it introduces rewrite rules that invalidate the soundness proof of F_C
17:59:51 <oerjan> scook0: regular deriving wins but they are only different for Read and Show iirc
18:00:09 <redleafgr> marshmallows: that doesn't seem to work because the rigid variable s still doesn't match e...
18:00:16 <scook0> oerjan: ah, good, that was more-or-less my assumption
18:01:22 <SamB> you can use newtype derivings and associated types to implement Unsafe.Coerce
18:01:23 <augustss_> http://hackage.haskell.org/trac/ghc/ticket/1496
18:01:24 <lambdabot> Title: #1496 (Newtypes and type families combine to produce inconsistent FC(X) axiom se ...
18:01:50 <SamB> well, sorear can anyway
18:02:44 <oerjan> redleafgr: another option would be to make Vector a multiparameter class with a functional dependency, so the scalar type is determined by the vector type
18:03:02 <oerjan> class Vector s a | a -> s where
18:04:28 <redleafgr> hmm
18:04:36 <redleafgr> what does the | a -> s notation mean, exactly?
18:04:54 <Cale> redleafgr: It says that the type a uniquely determines the type s
18:05:20 <Cale> redleafgr: So for any a, there is at most one instance Vector s a
18:05:32 <Cale> and the compiler is allowed to use that instance to infer s from a
18:05:40 <Cale> (if it exists)
18:06:04 <Baughn> What happens if you lie?
18:06:27 <Cale> If you try to define more than one instance for a given a, it'll call you on it, and not compile the program.
18:06:36 <redleafgr> hmm
18:06:38 <glen_quagmire> newtype deriving is extension feature
18:06:59 <redleafgr> this seems to give an error: instance (Num s, Num a) => Vector s (a, a, a) where
18:07:02 <oerjan> glen_quagmire: yeah, not in H98
18:07:05 <redleafgr> am i specifying this incorrectly?
18:07:19 <redleafgr> do i have to include the | a -> s on the instance as well?
18:07:48 <oerjan> redleafgr: that violates the restriction that a determines s
18:07:58 <Toxaris_> redleafgr: you probably want instance Num a => Vector (a, a, a) a where
18:08:05 <redleafgr> so i'm overspecifying it, i see
18:08:08 <Cale> uh
18:08:09 <redleafgr> i have to make it more specific
18:08:16 <Cale> Num a => Vector a (a,a,a)
18:08:22 <redleafgr> right
18:08:23 <redleafgr> thanks
18:08:28 <Peaker> anyone knows how to tell emacs haskell mode to indent a Haskell region? I added a new do around my code..
18:08:32 <Cale> But you may need some more extensions for that
18:08:41 <Cale> I'm not sure.
18:08:42 <redleafgr> that seems to work
18:08:46 <Cale> okay, good :)
18:08:50 <oerjan> redleafgr: now you _could_ leave out the functional dependency altogether, although that can sometimes force you to give annoying type annotations in other places
18:08:56 <redleafgr> actually
18:09:03 <redleafgr> i had fglasgow-exts already set
18:09:07 <redleafgr> and if i take it away, i get an error
18:09:07 <roconnor> augustss_: that reminds me of how inductive families are incompatible with extensional equality
18:09:13 <xd> generally its C-c C-q
18:09:27 <roconnor> augustss_: http://logical.futurs.inria.fr/cocorico/extensional_equality
18:09:29 <lambdabot> Title: extensional_equality - Cocorico!
18:09:33 <oerjan> then you would be able to do instance (Real s, Fractional a) => Vector s (a,a,a) where
18:09:39 <Peaker> xd:  Its undefined here
18:09:48 <oerjan> (since realToFrac can be used to convert)
18:09:53 <redleafgr> right
18:09:56 <redleafgr> that's very cool
18:10:08 <xd> M-x indent-region if its not bound in whatever mode you are in
18:10:55 <Peaker> xd: That messes stuff up, I just want to put stuff under a do, not have the effect of indenting each line to the deepest possible position
18:11:40 <redleafgr> finally, things seem to work... thanks guys
18:12:02 <xd> dunno i'm not familiar with the haskell mode, just working from experience with other language modes
18:12:09 <Peaker> xd: oh, thanks
18:12:13 <Peaker> nobody here uses emacs's haskell mode?
18:12:19 <redleafgr> i do
18:12:45 * edwardk waves hello.
18:12:51 <roconnor> augustss_: actually, nevermind. isInt :: c Int -> c Moo is a bizarre judgement
18:12:53 <Peaker> redleafgr, if you add a do around a piece of do-code, how do you re-indent the wrapped code?
18:12:53 <redleafgr> but mostly just for coloring and indenting
18:13:08 <redleafgr> Peaker: can you give an example of what you mean?
18:13:11 <Peaker> do you press tab on each line the right amount of times, spaces, record a macro?
18:13:27 <TSC> open-rectangle would be good for that
18:13:34 <redleafgr> i usually just hit tab until it looks right
18:13:52 <Peaker> redleafgr, well, I wrote an eventLoop action that did a bunch of stuff, and recursed to itself. I want to change it to be of the form: forever $ do  {indented old code here}
18:14:02 <Peaker> redleafgr, on each line you want to re-indent? I have a bunch of lines in eventLoop
18:14:44 <redleafgr> haha, i guess i'm either very patient, or not proficient enough in emacs to do it better
18:14:52 <redleafgr> but yeah, i just hit tab manually
18:15:08 <redleafgr> it would be nice if the mode were smarter
18:15:09 <TSC> Try M-x indent-rigidly
18:15:14 <redleafgr> hmm
18:15:25 <Peaker> TSC, that's better!
18:15:35 <TSC> Usually bound to C-x TAB
18:15:44 <Peaker> TSC, yep. Though it seems to be unaware of Haskell
18:15:49 <Peaker> but good enough
18:15:57 <redleafgr> nice
18:15:59 <redleafgr> didn't know about that one
18:16:00 <TSC> indent-rigidly is unaware of everything
18:16:03 <TSC> That's why it's rigid
18:18:28 <Peaker> I want a semantic editor for Haskell
18:18:46 <Peaker> which sounds over my head as a Haskell project as of yet, maybe a good way to start :)
18:19:58 <atp> wasn't there one written in haskell recently
18:20:04 <atp> some swedish word, i forget
18:20:07 <Peaker> atp, really?  Where
18:20:14 <atp> yeah... hmm
18:20:32 <solrize_> if swedish probably chalmers :)
18:21:01 <atp> no
18:21:04 <malsyned> with cabal-install, is there a way to resolve "Could not find ...: it was found in multiple packages" conditions?
18:21:10 <atp> it was like lahkse or something like that
18:21:22 <Peaker> atp, what kind of editor was it?
18:21:38 <atp> an integrated development environment
18:21:40 <gwern> so, I've been wondering about something. suppose I wanted to have a program which takes Haskell expressions or modules and then passes them to GHCi; except that it modifies the grammar such that f.g is distinct from f . g, and a single identifier. how would I go about this?
18:21:45 <gwern> atp: leksah?
18:21:49 <atp> yeah!
18:21:52 <atp> that's what it was
18:21:56 <gwern> 'leksah [0.1, 0.1.1] Haskell IDE written in Haskell
18:21:57 <Peaker> atp, I want one where the program is not edited like a big text string..
18:22:27 <atp> yeah, i understand what you mean, like those lisp machine editors
18:22:36 <atp> i don't know if leksah does that or not
18:22:41 <gwern> or heck, just have a GHCi where f-g is a legal function name and not a subtraction expression... that would be nice
18:22:45 <gwern> anyone know?
18:22:46 <atp> (my guess is not, it's harder to do with haskell than with lisp)
18:23:02 <Peaker> atp, Lisp machine editors?
18:23:13 <atp> subtraction is one of the most annoying things about haskell :/
18:23:33 <Peaker> atp, its not hard - just store the program as a semantic model, and have the UI bound to semantic manipulations of it, rather than textual manipulations
18:23:35 <malsyned> atp: here here
18:24:09 <malsyned> is there a channel I should be asking Cabal questions in?
18:24:18 <atp> Peaker: yeah.  you could have it all work with a zipper
18:24:26 <atp> Peaker: it would be cool, you should work on it
18:24:28 <gwern> atp: actually, the grammar of infix operators is even more annoying for me. it's impossible to definee 'c++ :: String -> IO ()', for example, if you wanted a shell script
18:24:57 <atp> gwern: yeah... this is the problem with not programming in scheme or forth :)
18:24:58 <gwern> and god forbid you should want to run 'mozilla-firefox :: String -> X ()'!
18:25:01 <Peaker> atp, I do want to - that's why I'm learning Haskell. I started writing such an editor in Python and decided that I was implementing a half-arsed FP, so better yet learn a real FP
18:25:38 <gwern> atp: not at all, it'd be easy to fix. just require infix operators to have a space before and after; mozilla-firefox then is clearly distinct from mozilla - firefox
18:25:40 <atp> Peaker: well, good luck!  like you said, it's not conceptually difficult, but the devil as always is in the details
18:26:01 <edwardk> gwern: i suppose i should actually get around to merging all of those patches you sent me. =) nice to meet you
18:26:07 <Peaker> atp, I have only written a single Haskell program so far, and that is an SDL mainloop that draws the screen white and waits for a quit event :-)
18:26:19 <gwern> edwardk: obviously I should remember who you are...
18:26:27 * gwern can't though
18:26:36 <edwardk> the guy who wrote type-int
18:27:03 <gwern> edwardk: oh, so from a while ago
18:27:07 <atp> gwern: that would invoke the ire of all those programmers raised on C who think that whitespace should be seen and not heard
18:27:09 <gwern> edwardk: did you ever update type-int?
18:27:14 <atp> gwern: they already complain enough about layout
18:27:51 <edwardk> not yet. i just got an environment set up that i could work with haskell on again the other day, after much prompting by shapr.
18:28:00 <gwern> atp: but this gets in the way of my planned shell, badly. I had a neat system for defining everything in $PATH as a haskell function String -> String, and that totally borked my plan!
18:28:20 <gwern> obviously g++ messes it up, but lots and lots of programs have dashes in their names
18:28:21 <atp> gwern: maybeYouShouldJustEmbraceCamelCaseForEverything
18:28:31 <gwern> edwardk: that's good
18:28:33 <Peaker> how do I get the function name of the (+) method for Integer's?
18:28:34 <gwern> atp: yes, and then I
18:28:42 <gwern> d have to do that for -. +, ...
18:28:45 <marshmallows> Peaker: + is the name
18:28:57 <marshmallows> :t (+) :: Integer -> Integer -> Integer
18:28:58 <lambdabot> Integer -> Integer -> Integer
18:29:07 <Peaker> marshmallows, its the name of the method, but at least in theory, the instance declaration of Integer as Num should specify a specific function for (+) does it have a name?
18:29:14 <marshmallows> +
18:29:19 <atp> Peaker: no, it doesn't need to, you're confused :)
18:29:35 <Peaker> marshmallows, what about the float addition, then? Its the same method, but not the same function
18:29:44 <marshmallows> It's called + as well
18:29:50 <atp> muahaha
18:29:58 <marshmallows> Since it's a typeclass you have the same name with multiple implementations
18:30:02 <gwern> Peaker: type clases mon
18:30:03 <Peaker> (+) refers to the method which automatically "finds" the right function for the type being used
18:30:13 <atp> Peaker: no, that's not really how it works
18:30:14 <marshmallows> it happens that theses implementations are part of the compiler
18:30:25 <marshmallows> so you can't view them (unless you read the compiler source code)
18:30:29 <idnar> Peaker: every implementation of (+) is named (+)
18:30:34 <SamB> atp: isn't it?
18:30:38 <Peaker> atp, What do you mean?  I can declare Peaker type to be an instance of Num and specify (+) to be mapped to the function PeakerAdd
18:30:48 <oerjan> Peaker: the method may be defined as (+) in the instance declaration.  there is no need for it to declare any other name
18:30:50 <marshmallows> You have to call is peakerAdd
18:30:52 <atp> SamB: no, internally the compiler actually passes needed functions defined by a typeclass in as parameters iirc
18:30:55 <Peaker> idnar, I thought you can't have differing functions under the same name
18:30:56 <marshmallows> PeakerAdd would be a type constructor
18:31:12 <SamB> atp: Peaker described the way it works well enough
18:31:13 <Peaker> ignore my wrong casing :-)
18:31:19 <oerjan> Peaker: you can just as equally define it anonymously
18:31:25 <SamB> in an iplementation-neutral way
18:31:27 <idnar> Peaker: well, you can think of them as different cases of the same function
18:31:32 <Peaker> oerjan, Yeah, I am wondering if there's a name for the Int/Float/etc + functions
18:31:46 <marshmallows> Peaker: The are called +
18:31:49 <idnar> but anyhow, you could define it like
18:31:54 <idnar> (+) = IntPlus
18:31:55 <oerjan> Peaker: perhaps internally in the compiler, but nothing exported
18:31:58 <idnar> err, intPlus
18:31:58 <SamB> Peaker: in Haskell, they all have the same name
18:32:02 <idnar> but normally you wouldn't
18:32:22 <Peaker> SamB, But I am not allowed to define two functions with differing types, on the same name
18:32:33 <SamB> Peaker: yes you are
18:32:38 <SamB> but you need to use a typeclass
18:32:56 <dibblego> ?type (+)
18:32:57 <lambdabot> forall a. (Num a) => a -> a -> a
18:32:58 <idnar> something like "(+) :: Integer -> Integer -> Integer" will always be the (+) function for Integer, though
18:33:10 <SamB> in fact, GHC bundles the methods of an instance into a record ...
18:33:16 <SamB> and Jhc just passes the type
18:33:35 <idnar> Peaker: you might want to think of it as defining multiple implementations for the same function, not defining different functions
18:33:38 <oerjan> @src Int (+)
18:33:38 <lambdabot> Source not found. My brain just exploded
18:33:52 <SamB> @src Int +
18:33:52 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
18:33:54 <Peaker> idnar, Well, isn't it right to make a method/function distinction?
18:33:55 <SamB> @src +
18:33:55 <lambdabot> Source not found.
18:33:57 <SamB> @src + Int
18:33:58 <lambdabot> Source not found. Where did you learn to type?
18:34:03 <SamB> @src (+) Int
18:34:03 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
18:34:09 <atp> Peaker: it's not really very productive
18:34:10 <SamB> @src dave
18:34:11 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
18:34:12 <idnar> are they called methods in Haskell?
18:34:13 <oerjan> SamB: the type _does_ go first
18:34:13 <malsyned> So, Data.ByteString is in package 'base', but utf8-string-0.3 depends on 'bytestring', so cabal-install is installing it every time I try to install utf8-string, then complaining about finding Data.ByteString in multiple packages.
18:34:26 <atp> idnar: i don't think so
18:34:26 <Peaker> idnar, SamB : Such that (+) is a method, not a function, and its bound to a function according to the specific type (in the case of Integer/Float/etc, its bound to an anonymous function)
18:34:27 <malsyned> Anybody know enough about cabal to help me get past this?
18:34:31 <atp> method sounds very OO-like
18:34:45 <idnar> Peaker: anyhow, they don't behave any differently
18:34:45 <gwern> malsyned: you are using 6.6.x?
18:34:50 <oerjan> idnar: yes method is used some places in the report
18:34:52 <dons> malsyned: right, so utf8-string isn't 6.6.x friendly?
18:34:54 <Peaker> idnar, atp: According to the tutorials I read, func-like declations inside where clauses in classes are declarations of "methods"
18:34:55 <idnar> (+) is a function of type (Num a) => a -> a -> a
18:35:06 <atp> Peaker: (+) is a function.  method doesn't really mean anything important in haskell
18:35:09 <malsyned> gwern: yes
18:35:15 <dons> malsyned: one soln is to upgrade. but also, you could remove the 'bytestring' dependency from the .cabal file
18:35:20 <atp> Peaker: that is to say, the distinction is not productive
18:35:23 <Peaker> atp, I could make out at least one important difference
18:35:24 <SamB> atp: sure it does
18:35:32 <dons> malsyned: i'll just fix the darcs repo now
18:35:41 <Peaker> atp, A function will always apply the same code to my arguments, a method will apply different code depending on the type of the arguments
18:35:54 <gwern> malsyned: well, there you go. as dons says, upgrade your ghc, or 'downgrade' your copy of the package. the author didn't use the flags to auto-downgrade
18:35:56 <malsyned> dons: could, but that kinda defeats the purpose of cabal-install, no?  I'll probably wind up deleting the dependency and building manually.  thanks.
18:36:07 <SamB> Peaker: well, really you have to look at the type to see that...
18:36:26 <atp> Peaker: i suppose...
18:36:36 <malsyned> All of this module churn between add-ons and 'base' seems like a compatibility nightmare.
18:36:37 <dons> malsyned: due to the .cabal file not being 6.6 friendly, there's no much option here
18:36:39 <Peaker> SamB, yeah, but (+) means very different things, and differing code on different types. a function will always mean the same thing
18:36:41 <gwern> malsyned: yes, but given that you're supposed to be using the darcs of cabal-install as development is active and fast, you should also be using 6.8.x
18:36:43 <idnar> Peaker: a function with a type class constraint might transitively apply different code
18:36:58 <atp> Peaker: but what about functions that apply other functions, that could be different?
18:37:04 <SamB> malsyned: it'll improve matters once the churn settles down
18:37:07 <oerjan> @src Complex +
18:37:07 <lambdabot> Source not found. You untyped fool!
18:37:08 <idnar> Peaker: if I write myplus :: (Num a) => a -> a -> a; myplus a b = a + b
18:37:14 <dons> malsyned: tends to be ok -- type checking and purity seems to keep things working :)
18:37:15 <gwern> malsyned: oh, it is. but most packages are updated now, I think
18:37:19 <idnar> Peaker: myplus is a normal function, but it behaves exactly the same as (+)
18:37:20 <Peaker> idnar, true, but the function code itself is not - so I think it makes sense to distinguish methods from functions
18:37:32 <lament> Cale: what do you mean when you say (in the monad transformers article) "there are other solutions to the problems that monad transformers solve"?
18:37:33 <idnar> Peaker: ok
18:37:42 <malsyned> gwern: am using darcs of cabal-install.  I suppose I should upgrade ghc.  but you know - ug.
18:38:01 <gwern> malsyned: you'll have to do it eventually you know. why not know?
18:38:03 <gwern> *now
18:38:05 <Peaker> atp, if a function applies other _methods_ then it will always run, but the methods inside it will be polymorphic to the types
18:38:06 <idnar> Peaker: well, I don't think that's generally a very important distinction, but I guess in cases where it is, then that terminology would be useful
18:38:13 <augustss_> it makes sense to distinguish methods, at least when you add instances, because the methods are the functions you need to provide in the instance declaration
18:38:16 <Cale> lament: Well, for one, there's what are called distributive laws. These haven't been played with very much.
18:38:50 <Cale> lament: There are also other ways to get compositionality of effects, let me see if I can find a particular paper on one of them.
18:38:54 <Peaker> anyhow, I guess the specific implementations of + for the various int/float/etc are anonymous (the tutorial implied they weren't)
18:39:05 <malsyned> gwern: because I had hoped to play with xmonad sometime today, with the minimum amount of yak shaving
18:39:13 <lament> Cale: but monad transformers are the only approach used in practice?
18:39:22 <Cale> lament: Just at present.
18:39:40 <Cale> lament: The others haven't been explored nearly as much as they probably deserve.
18:40:01 <atp> Peaker: out of curiosity, why would you want a float or integer specific add?
18:40:01 <gwern> malsyned: xmonad needs bytetring?
18:40:11 <malsyned> gwern: xmonad-contrib does.
18:40:48 <malsyned> gwern: or rather, xmonad-contrib requires utf8-string, which claims to need bytestring
18:41:12 <Peaker> atp, I don't want them, I was wondering if a difference is shown in their types, if they are methods or functions
18:42:05 <gwern> huh. when did utf8-string get added as a dependency?
18:42:30 <gwern> dons: is utf8-string a new dep? that means I can use it in my modules...
18:44:37 <malsyned> dons: when I take out the bytestring dep in utf8-string, I get to the build step, but then "Not in scope: IO.withBinaryFile"
18:44:39 <Cale> I wish google didn't suck at searching for punctuation.
18:46:00 <SamB> me too
18:46:29 <TomMD> @go >>= return .
18:46:30 <lambdabot> http://en.wikipedia.org/wiki/Return
18:46:36 <dons> malsyned: gimme a sec. i'll get it building.
18:46:42 <Peaker> I _hope_ its not some guy who is thinking he's fixing your punctuation as a favor, but that their indexing simply doesn't support it. The first would be depressing
18:46:42 <malsyned> dons: thx
18:46:47 <gwern> y'know, latexki would be so incredibly kickass if it were backed by Darcs
18:47:18 <Cale> I'm looking for the paper which discusses a method for composing monadic effects, and has types that look like  M (A :+: B :+: C) t
18:48:24 <Cale> aha
18:48:35 <Cale> http://www.alpheccar.org/en/posts/show/86 -- shows an application of the technique
18:48:36 <lambdabot> Title: Coproduct of free monads and web development
18:48:39 <Cale> http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf
18:52:59 <lament> is that the paper?
18:53:14 * oerjan tried parsing that as Copproduct of (free monads and web development)
18:53:39 * oerjan wonders if something is wrong with his keyboard
18:53:53 <dons> malsyned: it depends on things in newer versions of bytestring
18:54:03 <Cale> lament: Yeah
18:54:12 <dons> you'll need ghc 6.8.2, or else ask glguy to backport (or you could do the backport)
18:54:56 <Cale> lament: That's about composing what are called free monads (which you can think of as monads which are purely syntax to be later interpreted)
18:56:56 <malsyned> dons: The state of the art in Haskell sure does move fast.  I guess it's time to bite the bullet and compile ghc for a few hours.
18:57:45 <dons> malsyned: it just uses some things from the new bytestring api
18:57:51 <dons> which is about a year old now
18:57:57 <dons> so yeah, why not grab a binary of ghc
18:58:00 <dons> no need to build it.
18:58:02 <lament> malsyned: people have put themselves in a really difficult position and now are inventing tricky ways of getting out :)
18:58:07 <dons> (why do people insist on building ghc?)
18:58:34 <dons> lament: not in this case. it just uses uncons which is from the 0.9 bytestring api
18:58:59 <hasenov> hello, i have a question that involves states, and im not sure how to implement it
18:59:24 <gwern> @hoogle inotify
18:59:24 <lambdabot> No matches found
18:59:46 <malsyned> hasenov: ask away
18:59:56 <gwern> @hoogle System.INotify
18:59:56 <lambdabot> No matches, try a more general search
19:00:01 <hasenov> i have tree (not binary) that i map the function getValue to, and that function in the beginning gets an identifier
19:00:18 <gwern> ah, must be from the hinotify package
19:00:36 <hasenov> the identifier then propagates down to all the other values of the mapping
19:01:24 <dino-> Not sure what platform you guys are talking, but installing the generic binary ghc 6.8.2 on Debian recently was extremely easy.
19:01:32 <hasenov> could i use a monad for it, or could i simply have pattern match the identifier, and if its nothing, set it to the correct one, otherwise, use it
19:01:51 <edwardk> Anyone bored and want to poke at a toy low-level-intermediate-representation i started putting together the other day? http://comonad.com/haskell/lir/Lir.hs
19:02:27 <edwardk> right now its basically a simple ssa-like parse tree using higher order abstract syntax
19:02:39 <edwardk> and it probably uses way too many comonads
19:02:41 <hasenov> but actually idk, because im not sure how to pass the value around using the map
19:03:07 <hasenov> wouldve been so easy if i had a global variable :)
19:03:28 <TomMD> @where dynamic
19:03:28 <lambdabot> I know nothing about dynamic.
19:03:30 <edwardk> right now its all in one file until i'm sure i actually want to do this this way
19:03:36 <TomMD> @where dynamictypes
19:03:36 <lambdabot> I know nothing about dynamictypes.
19:03:39 <TomMD> @where dynamictyping
19:03:39 <lambdabot> I know nothing about dynamictyping.
19:03:44 <hasenov> should i post my code on hpaste?
19:03:53 <malsyned> hasenov: yes, please
19:04:22 <edwardk> anyways right now what i'm trying to do is figure out what the right monad would be to move the examples at the very end of the file into a nice monadic syntax.
19:05:03 <solrize_> to use te haskell typechecker ?
19:05:05 <solrize_> the
19:07:23 <edwardk> its basically one step above an assembler (register assignment hasn't been done, and peephole optimization, etc)
19:08:35 <oerjan> solrize_: i don't understand your question
19:08:55 <Peaker> augustss_, reading your blog again, I don't see that while is defined? is it supposed to be whileM?
19:08:57 <hasenov> hello, did anyone find my code?
19:09:11 <oerjan> hm, hpaste bot is down?
19:09:23 <hasenov> oh..
19:09:49 <malsyned> hasenov: link?
19:09:58 <hasenov> hpaste.org/6418
19:10:03 <solrize_> oerjan, i'm wondering why use this approach instead of simply putting some more convenient asm syntax in a string, and parsing it
19:10:18 <hasenov> hpaste.org/6417
19:10:21 <Peaker> hmm, where is whileM defined?
19:10:32 <Peaker> and why can't I import anything in ghci?
19:10:33 <solrize_> peaker, control.monad i'd expect
19:10:50 <oerjan> solrize_: oh you were commenting on edwardk
19:10:54 <hasenov> getValue is the function i want to recurse the tree with
19:10:57 <edwardk> solerize: ahh
19:10:59 <solrize_> oerjan, yes
19:11:06 <edwardk> solerize: sorry didn't catch you were talking to me =)
19:11:38 <solrize_> edwardk, this stuff interests me but i don't understand it
19:11:47 <Peaker> solrize_, how do I find it?
19:11:51 <hasenov> however, as of right now, it alternates the current move, i need to have it set from the beginning of the convertion of myTree to (getValue myTree) if that makes sense
19:12:07 <edwardk> solrize: basically its so i can use this as the back end of a compiler. this isn't quite an assembler, its one step before hand, its like writing an assembler without caring which registers you have available. its a classing 'lir' for a compiler in ssa form
19:12:53 <Botje> hasenov: any (==True) === or
19:13:13 <edwardk> its about as low as i'm willing to go and run an interpreter over if need be, and even if generating a string of assembly for an assembler you have to represent that code in some form before you feed it to the assembler
19:13:24 <Botje> foldr (\x y -> if x then (1+y) else (0+y)) 0 === sum . map fromEnum
19:13:44 <Peaker> I see references to whenM/whileM everywhere, do they exist in the stdlib somewhere?
19:13:48 <malsyned> hasenov: where does getValue come from?  I don't see it defined.
19:14:03 <hasenov> malsyned : from DataTypes.hs
19:14:52 <hasenov> Botje : oh, i didnt know about that function, i thought there was only ||
19:14:52 <edwardk> solrize: this is probably not the easiest implementation of this idea, but it lets me not have to deal with variable names (thanks to HOAS) and lets me fold over the data easily thanks to the catamorphism stuff
19:16:06 <oerjan> hasenov: note that Tree is an instance of both Foldable and Traversable
19:16:28 <solrize_> peaker, import Control.Monad
19:16:49 <oerjan> as well as a Monad itself
19:16:57 <Peaker> solrize_, I import it, and whenM/whileM are still not in scope
19:17:04 <solrize_> @hoogle whileM
19:17:04 <lambdabot> No matches found
19:17:16 <oerjan> hasenov: i don't understand what you mean to do with that passed in extra value
19:17:21 <Peaker> @hoggle whenM
19:17:21 <lambdabot> No matches found
19:17:33 <solrize_> http://www.google.com/search?q=whenm+whilem
19:17:34 <lambdabot> Title: whenm whilem - Google Search
19:18:03 <oerjan> hasenov: do you mean to combine the getValues of all the Tree elements somehow?
19:18:27 <hasenov> oerjan: i dont know if ure familiar with minimax but thats what this is
19:19:10 <oerjan> oh so you want to get a value for each branch, which is the max or min of its children?
19:19:20 <hasenov> oerjan : no, i want the first current move to propagate down through the lifespan of the calculation
19:19:21 <edwardk> i have some old minimax/alphabeta/negascout/MTD(f) code lying around here somewhere
19:19:44 <edwardk> hasenov: what was the main question?
19:19:49 * oerjan doesn't understand a word you are saying :(
19:20:13 <solrize_> > whenM :: (Monad m) => m Bool -> m () -> m ()
19:20:13 <solrize_> > whenM b f = b >>= \b' -> when b' f
19:20:14 <lambdabot>  Parse error at "=" (column 11)
19:20:14 <lambdabot>   Not in scope: `whenM'
19:20:25 <hasenov> yeah, i want to get a value for each branch, which is the max or min of its children
19:21:03 <hasenov> however, the way i have it setup right now, i am getting the static value of the current move, if that makes sense
19:21:33 <hasenov> so with each ply traversed, it alternates between O and X
19:22:20 <hasenov> however, i need it to be calculated in terms of O or X, whichever way was started from the beginning of the traversal
19:22:32 <hasenov> so i think i might need to use a fold, im not sure
19:22:47 <hasenov> edwardk: do u know what i mean?
19:23:07 <oerjan> hm
19:23:23 <edwardk> hasenov: did you paste the code somewhere?
19:23:32 <hasenov> yeah
19:23:39 <hasenov> hpaste.org/6417
19:23:41 <hasenov> hpaste.org/6418
19:25:14 <edwardk> i did this quite a bit differently as i recall, twisting my brain around your version
19:25:48 <hasenov> lol, im a haskell beginner
19:26:36 <hasenov> its probably not the easiest or most efficient way at all
19:26:45 <edwardk> its not bad code, its just that as a third party, i need to figure out both the model of what you are doing and try to figure out what if any of it is broken at the same time. ;)
19:27:52 <wy> The most interesting sentence I've read today: "time is a side effect"
19:28:01 <monochrom> haha
19:28:40 <solrize_> http://cryp.to/blockio/fast-io.html    wow this stuff is really good
19:28:41 <lambdabot> Title: Fast I/O in Haskell
19:28:49 <edwardk> is this intended to be a tic-tac-toe player or something when its done? or is that just what you are using to test the semantics of the game engine?
19:29:18 <hasenov> k, i will explain if u want, TableMove contains list of lists, which is a 3x3 matrix of a tic tac toe table, a list of the moves which is the history
19:29:41 <hasenov> edwardk : yes it is, ill start with tic-tac-toe and go to smthing more complex
19:30:16 <hasenov> the possibilities of the moves are 0..8
19:30:22 <edwardk> hasnov: then in that case you may want to give a lot of consideration to your board rep when you move to a more complicated game. this will get expensive fast if you do something like chess =)
19:31:12 <hasenov> umm, i havent really thought of that yet
19:31:26 <edwardk> ok, call me slow, but where is the board scoring function?
19:31:47 <hasenov> glad u asked that, it is getValue
19:32:09 <hasenov> it takes tableMove as paramter and returns a static evaluation of the current position
19:32:24 <hasenov> which is Float
19:33:45 <edwardk> ok, so TableMove is something like [[Just X, Nothing, Nothing], [Just X, Nothing, Just O],[Nothing,Nothing,Nothing]] ?
19:34:28 <edwardk> oh and the list of integers that generated it and whose turn it is?
19:34:58 <hasenov> yes, except it is more, for that example it would be TableMove [[Just X,Nothing,Nothing],[Just X,Nothing,Just O],[Nothing,Nothing,Nothing]] [0,3,5] (Just X)
19:35:11 <edwardk> ah i see now, just so you could use the reverse and transpose hackery
19:36:12 <edwardk> and the Eq instance compares two tables as being in the same equivalence class if you can rotate/flip one to get the other
19:36:25 <MyCatVerbs> My memory sucks. Is (->) left or right associative, please?
19:36:29 <edwardk> cute, expensive, but cute.
19:36:38 <edwardk> a -> b -> c == a -> (b -> c)
19:36:46 <hasenov> yea, i make use of symmetries
19:37:26 <MyCatVerbs> edwardk: thank you.
19:37:59 <dons> aja's .NET bridge for Haskell thesis is up, http://reddit.com/info/6cb8l/comments/ :)
19:38:05 <dons> now, just to get hold of the code.
19:38:57 <gwern> who is Conal Elliot on #haskell? conal, right?
19:39:13 <dons> yep
19:39:17 <hasenov> edwardk : so do u see what im trying to accomplish?
19:39:20 <gwern> @seen conal
19:39:20 <lambdabot> I saw conal leaving #haskell and #ghc 1h 6m 57s ago, and .
19:39:33 <edwardk> hasenov: i'm getting the idea
19:40:28 <gwern> phooey
19:40:33 <gwern> not long ago then
19:40:42 <idnar> "and ." ?
19:40:54 <edwardk> i don't like your getValue evaluator
19:41:10 <gwern> dons: anyway, what do you think of latexki? think it could be done with a darcs backend?
19:41:17 <edwardk> it seems to me that its asking the wrong question relative to every one of these i've seen
19:42:01 <hasenov> huh?
19:42:03 <edwardk> or maybe i'm just misparsing it
19:42:07 <adu> hi
19:42:19 <dons> gwern: what would be the benefit of the darcs backend? or, would a general interface to rcs backends make more sense?
19:42:21 <edwardk> the comment i agree with, the code i'm not parsing properly =)
19:42:29 <dons> isn't the main issue going to be merging, gwern ?
19:42:35 <dons> so you'd pick the one that was smartest/fastest
19:43:09 <hasenov> the comments are outdated, sorry, please dont read them
19:43:16 <gwern> dons: I think the issue actually is the web interface to the repo; svn apparently has something fancy going on
19:43:43 <hasenov> its sorta like that, but theres more functionality
19:43:52 <edwardk> dumb hack thoughts. your Xs and Os could be replaced with -1 and 1, then you keep track of the current player as a 'sign' that you multiply the value of the board by. and 'getOtherMove' becomes stupidly simple
19:44:19 <gwern> dons: well, as I understand latexki, everything is maintained inside the svn repo, so it'd be like any other repo but the web interface would have the commit bit
19:44:51 <solrize_> most wikis use database backends, i wonder if using rcs might make more sense
19:45:19 <edwardk> also: are you just doing minimax and not alpha-beta/negascout?
19:45:28 <edwardk> i noticed a distinct lack of pruning
19:46:18 <solrize_> maybe rcs systems can't handle the very large numbers of pages found in some wikis
19:46:22 <hasenov> edwardk : in the code i posted im not using alpha-beta, i have another version where i am, but i dont understand it
19:46:57 <gwern> solrize_: scaling is an issue. any rcs would have trouble with the 2.2 million mainspace 'files' of the english wikipedia
19:47:03 <hasenov> edwardk : and one of the reasons i dont understand it is because the underlying code is not correct, which im trying to fix
19:47:10 <gwern> but large wikis aren't all that common, imo
19:47:15 <solrize_> and there's a bunch of metadata that also has to live in the db and an rcs could not handle that so well
19:47:20 <edwardk> hasenov: ah
19:47:24 <solrize_> or if you want to represent semantics from individual documents
19:48:11 <gwern> solrize_: but a rcs gets you all the dvcs goodness - you get real histories and branching, not the shit mediawiki or other wikis provide, you get dirt-cheap mirrors, many easy methods of access, and so on
19:48:28 <solrize_> gwern hmm true
19:48:35 <edwardk> looking to see if i can find a fairly ugly one-liner alpha-beta that i wrote a while back
19:49:03 <hasenov> edwardk : this is straight from "Why Functional Programming Matters" by John Hughes @ www.math.chalmers.se/~rjmh/Papers/whyfp.html
19:49:31 <malsyned> hm.  how do I reregister a package I installed with cabal-install and then unregistered with ghc-pkg?
19:49:31 <gwern> dancing with the devil - so true
19:49:44 <hasenov> edwardk : the paper explains alpha-beta, but its not right because of my underlying issue
19:50:04 <solrize_> is there some reasonable ffi interface between ghc and ocaml?  preferably one that plays nice with the ghc type system
19:51:07 <edwardk> at first glance i'd say you're making it too complicated =)
19:52:03 <hasenov> well of course, i know i am, this is my first big program in a functional language..
19:52:17 <edwardk> ah
19:52:59 <Cale> Hehe, one of the reasons listed for not retargeting a Haskell compiler to generate .NET CIL is "Enormity of the task". Somehow I don't think that word means what they wanted it to mean, though I suspect it's still appropriate :)
19:53:51 <Cale> (this is in the "Dancing with the Devil" thesis by Andrew Appleyard)
19:53:58 <dmwit> enormity: vastness of size or extent
19:54:02 <dmwit> Is that not what they meant?
19:54:32 <solrize_>      2. That which is enormous; especially, an exceeding offense
19:54:32 <solrize_>         against order, right, or decency; an atrocious crime;
19:54:32 <solrize_>         flagitious villainy; an atrocity.
19:54:32 <solrize_>         [1913 Webster]
19:54:34 <solrize_> dict.org
19:54:35 <Cale> That is what they meant, it's not really what the word is supposed to mean.
19:54:40 * gwern doesn't get it. why is this man laughing?
19:55:07 <Cale> {dag}3. Excess in magnitude; hugeness, vastness. Obs.; recent examples might perh. be found, but the use is now regarded as incorrect.
19:55:11 <solrize_>        3: the quality of extreme wickedness
19:55:11 <solrize_>        4: an act of extreme wickedness
19:55:22 <Cale>    2. Deviation from moral or legal rectitude. In later use influenced by ENORMOUS 3: Extreme or monstrous wickedness.
19:55:36 <Cale>   b. concr. A breach of law or morality; a transgression, crime; in later use, a gross and monstrous offence.
19:55:56 <gwern> hm. I've never used enormity except in its size sense - 'the enormity of his crimes became clear during the trial'
19:56:12 <hasenov> edwardk : so for what im trying to do, i would need to fold it, i think, with the initial value being the currentMove, and then function being applied is (: . getValue)?
19:56:26 <Cale> Enormity of crimes is appropriate, but doesn't really refer just to their size.
19:57:55 <solrize_> is that fast-io page basically similar to bytestring?  the doc explanation is very good
19:58:57 <gwern> always thought it did. goes to show I need to read more dictionaries
19:59:15 <dons> solrize_: which fast-io page?
20:00:38 <gwern> @tell conal I've sent you patches for reactive and typecompose - I think you should update the hackage packages, since they don't seem to work together (reactive uses DistribM or something which only seems to be in the unreleased 0.4 of TypeCompose)
20:00:38 <lambdabot> Consider it noted.
20:01:44 <gwern> (now back to ZMachine
20:05:05 <roconnor> @go 1 EUR in USD
20:05:06 <lambdabot> 1 Euro = 1.5594 U.S. dollars
20:05:35 <roconnor> @go 1 CAD in USD
20:05:35 <lambdabot> 1 Canadian dollar = 1.014405 U.S. dollars
20:06:00 <gwern> lambdabot: why do you lie? what makes you lie?
20:06:12 <hasenov> however, apparently, Data.Tree are instances of Foldable
20:06:34 <kbateman> @go 1 gallon in liters
20:06:35 <lambdabot> 1 US gallon = 3.78541178 liters
20:06:49 <kbateman> @go 1 mile per gallon in furlongs per hogshead
20:06:55 <lambdabot> 1 mile per gallon = 504 furlongs per hogshead
20:07:31 <malsyned> join #xmonad
20:07:39 <malsyned> oooh, fail
20:07:42 <gwern> hasenov: makes sense. depth-first I'd guess?
20:07:50 <hasenov> does that mean that i may do foldr on them already without defining anything extra?
20:08:17 <hasenov> gwern: yeah
20:08:32 <gwern> hasenov: so far as I know, the point of Foldable is to make folds on other stuff as easy as on lits
20:08:59 <gwern> *lists
20:09:02 <Cale> hasenov: You can use the foldr function which is in Data.Foldable, but not the one in the Prelude.
20:10:29 <hasenov> hmm, ok, what is the difference?
20:10:33 <hasenov> Cale?
20:10:34 <Cale> The type
20:10:36 <Cale> :t foldr
20:10:37 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
20:10:41 * dolio still thinks it's cute that Data.Foldable.foldr :: (a -> b -> b) -> b -> t a -> b
20:10:42 <Cale> :t Data.Foldable.foldr
20:10:43 <lambdabot> forall a b (t :: * -> *). (Data.Foldable.Foldable t) => (a -> b -> b) -> b -> t a -> b
20:11:13 <scook0> is Data.Foldable really just a toList typeclass in disguise?
20:11:18 <scook0> or does it have some additional meaning?
20:11:20 <Cale> Sort of, yes.
20:12:08 <Cale> Because a list is isomorphic to its right fold
20:13:25 <solrize_> is there a reason to not have something like unfoldr that doesn't need a Maybe?  i.e. it generates an infinite lazy list, you use takewhile to get it to stop
20:13:35 <dolio> Although that type isn't great for arbitrary algebraic datatypes.
20:14:55 <Cale> solrize_: I've sometimes liked  unfoldr' p f g = map f . takeWhile p . iterate g
20:14:56 <dolio> That's just 'unfoldr (Just . f)'.
20:15:36 <gwern> @undo do [story] â† getArgs; startStory story
20:15:36 <lambdabot>  Illegal character ''\134''
20:15:36 <lambdabot>  at "†" (column 13)
20:15:39 <solrize_> dolio good point
20:15:47 <gwern> @undo do [story] <- getArgs; startStory story
20:15:47 <lambdabot> getArgs >>= \ a -> case a of { [story] -> startStory story; _ -> fail ""}
20:15:48 <Cale> But the translation between that and the usual unfoldr is a little awkward.
20:16:33 <solrize_> cale that verison is a bit more awkward, i think, separating f and g like that
20:16:48 <Cale> Sometimes it's just what you want though.
20:16:54 <solrize_> true
20:17:53 <Cale> > let unfoldr' p f g = map f . takeWhile p . iterate g in unfoldr' (/= 0) (`mod` 2) (`div` 2) 5073
20:17:54 <lambdabot>  [1,0,0,0,1,0,1,1,1,1,0,0,1]
20:18:57 <solrize_> heh
20:19:33 <Cale> > let unfoldr' p f g = map f . takeWhile p . iterate g in unfoldr' (not . null) (takeWhile (/=',')) (drop 1 . dropWhile (/=',')) "this,is,comma,separated"
20:19:33 <agl> I have a small example which will cause the threaded RTS to call a finialiser on a ForeignPtr before the last reference has gone out of scope. That's a GHC bug, right?
20:19:34 <lambdabot>  ["this","is","comma","separated"]
20:20:05 <Cale> agl: Seems like it would be, yeah.
20:20:45 <agl> Cale: would you like to check it out before I send an email to cafe and (maybe) make a fool of myself?
20:20:52 <Cale> sure
20:20:55 <Cale> @hpaste
20:20:55 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:22:07 <dolio> That second one is more a symptom that using Maybe to indicate stopping isn't very handy.
20:23:04 <agl> Cale, thanks: see hpaste.org (top three pastes)
20:23:09 <dolio> Since otherwise you could do something like: unfoldr null (second tail . span (/=','))
20:24:21 <Cale> agl: btw, you can just pass .c files to ghc.
20:25:02 <dolio> Of course, the first would also be: unfoldr (==0) (swap . flip divMod 2)
20:25:06 <agl> Cale, thanks. Somewhere in my head I knew that, it's just force of habit ;)
20:25:27 <dolio> Which shows that swap is missing. :)
20:26:13 <Cale> agl: hmm, okay, let's see what this code is doing :)
20:26:20 <dolio> @type swap
20:26:21 <lambdabot> Not in scope: `swap'
20:26:26 <dolio> @let swap (a,b) = (b,a)
20:26:27 <lambdabot> Defined.
20:26:30 <dolio> @type swap
20:26:30 <lambdabot> forall t t1. (t, t1) -> (t1, t)
20:27:26 <agl> Cale, the TVar is just to have the thread holding the fp reference killed because it gets blocked forever (as all other references to the TVar are out of scope)
20:27:40 <dolio> @let stopAt p f x = if p x then mzero else return (f x)
20:27:40 <lambdabot> Defined.
20:28:00 <agl> Cale, then we catch that exception and call _use on the foreign value. However, the GC has already collected it
20:28:16 <dolio> > unfoldr (stopAt (==0) $ swap . flip divMod 2) 5073
20:28:17 <lambdabot>  [1,0,0,0,1,0,1,1,1,1,0,0,1]
20:28:56 <dolio> > unfoldr (stopAt null $ second (drop 1) . span (/=',')) "this,is,comma,separated"
20:28:57 <lambdabot>  ["this","is","comma","separated"]
20:30:06 <Cale> ah, I see.
20:30:25 <dolio> > unfoldr (stopAt null $ (.) (drop 1) . span (/=',')) "this,is,comma,separated"
20:30:25 <lambdabot>  ["this","is","comma","separated"]
20:31:03 <Cale> agl: you could also replace that do-block with 'atomically retry'
20:31:49 <Cale> It's really interesting that the finaliser is being called.
20:31:51 <oerjan> dolio: argh!
20:32:01 * oerjan took a while
20:32:26 <dolio> Which part didn't you like? :)
20:32:26 <gwern> @seen SamB
20:32:26 <lambdabot> SamB is in #xmonad, #perl6 and #haskell. I last heard SamB speak 1h 46m 26s ago.
20:32:38 <oerjan> the (.) :)
20:32:43 <Cale> Because clearly there's another reference to fp in the exception handler...
20:32:50 <dolio> Oh. :)
20:33:03 <oerjan> hm
20:33:06 <dolio> > unfoldr (stopAt null $ (drop 1 .) . span (/=',')) "this,is,comma,separated"
20:33:07 <lambdabot>  ["this","is","comma","separated"]
20:33:19 <agl> Cale, good point. Anything to make a test case shorter..
20:33:20 <oerjan> hey i was going to do that!
20:34:16 <agl> Cale, so I should send an email to cafe about it?
20:34:37 <TomMD> Anyone know _how_ to use "withSocketsDo" ?  Should it just be in 'main = withSocketsDo' or should it be used on the actual function that uses the sockets?
20:34:46 <agl> Cale, (obviously, this is actually a distillation of a real issue for me.)
20:34:55 <Cale> Yeah, see if anyone who knows the runtime system better can figure out what's going on.
20:34:56 <TomMD> I'm on a *nix box here so I don't have a great way to test.
20:35:09 <agl> TomMD, main = withSocketsDo main'
20:35:18 <gwern> @src forever
20:35:19 <lambdabot> Source not found. Take a stress pill and think things over.
20:35:24 <agl> TomMD, then have the real main in main'
20:35:27 <hasenov> ive been thinking and thinking, and am still not sure how to fold the Tree together
20:35:34 <TomMD> agl: sounds good - thanks!
20:35:38 <gwern> @hoogle forever
20:35:38 <lambdabot> Control.Monad.forever :: Monad m => m a -> m ()
20:35:41 <Cale> TomMD: It doesn't really matter. It's just a hook for windows machines to set up and shut down the sockets library.
20:36:02 <gwern> @src Control.Monad.forever
20:36:02 <lambdabot> Source not found. Where did you learn to type?
20:36:04 <chessguy> @type f x = x >> f x
20:36:05 <lambdabot> parse error on input `='
20:36:06 <TomMD> Cale: Ok - I guess that means I shouldn't call it on every individual use of the socket ;-)
20:36:30 <hasenov> since i would be returning a Node from the first fold, but that is not the attribute that i need to feed into the next move
20:36:44 <dolio> @type fix . (>>)
20:36:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
20:36:53 <chessguy> hasenov, whatcha trying to do?
20:37:05 <edwardk> cale: i'm being a moron and can't figure out what monad something i'm beating my head against should be... guess i stayed away from haskell for too long. got a sec?
20:37:12 <Cale> sure
20:37:17 <edwardk> http://comonad.com/haskell/lir/Lir.hs
20:37:22 <edwardk> look way at the bottom
20:37:29 <edwardk> the expressions there look awfully monadic
20:37:50 <edwardk> i just can't figure out what i should do to throw them into a monadic syntax
20:38:02 <Cale> ah, the examples?
20:38:04 <edwardk> yeah
20:38:05 <hasenov> chessguy: take a look at hpaste.org/6417 & hpaste.org/6418
20:38:24 <Cale> Well, it's probably some suitable free monad.
20:38:32 <edwardk> basically would like to make those using a monadic syntax without giving up all the plumbing of the hoas stuff
20:38:33 <edwardk> yeah
20:38:43 <hasenov> im trying to map a tree but pass the current move from one evaluation to the next
20:38:47 <edwardk> i thought it was Id for a while (hell it might be)
20:39:01 <gwern> @pl decodePaddr x = return ((fromIntegral x)*4)
20:39:01 <lambdabot> decodePaddr = return . (4 *) . fromIntegral
20:39:02 <chessguy> heuristics for tic tac to?
20:39:19 <hasenov> chessguy : i think the correct name is minimax
20:39:24 <gwern> @pl decodePaddr x = return $ (fromIntegral x)*4
20:39:24 <lambdabot> decodePaddr = return . (4 *) . fromIntegral
20:39:29 <chessguy> oh, that's not heuristics then
20:39:45 <gwern> @pl decodePaddr x = return $ fromIntegral x * 4
20:39:45 <lambdabot> decodePaddr = return . (4 *) . fromIntegral
20:39:56 <chessguy> hasenov, so what seems to be the problem
20:40:06 <Cale> hmm
20:40:06 <edwardk> cale: any thoughts on particulars?
20:40:19 <dolio> edwardk: Looks vaguely like continuation passing.
20:40:31 <dolio> Of some sort.
20:41:15 <hasenov> chessguy: i need to evaluate all the nodes using the function getValue, which takes a table and returns a number which is the static evaluation of its position
20:41:40 <chessguy> hasenov, yes, i'm very familiar with how minimax/negamax/alphabeta work
20:41:54 <edwardk> dolio: yeah, well, i'm using a HOAS representation, for a near-assembler so every term is like having both App and Lam in one (to keep you from branching) the rep is very much in the spirit of CPS, if only because its for SSA and SSA and CPS are interchangeable =)
20:41:55 <oerjan> edwardk: (Flagged reg (Lir a) -> Lir a) -> Lir a  is just about Cont (Lir a) (Flagged reg (Lir a))
20:41:57 <hasenov> chessguy: so i use a map to convert a tree of possible positions into a tree of possible values
20:42:15 <edwardk> oerjan: good point
20:42:50 <chessguy> hasenov, sure
20:43:04 <chessguy> but you're wondering how to get back to the actual move then?
20:43:12 <hasenov> chessguy : oh ok, what im doing is during each ply, im switching between O and X
20:43:22 <chessguy> right
20:43:51 <edwardk> oerjan: i think that was the key insight. i had looked at Cont before but i hadn't realized it should just be the tail end of the operation (duh)
20:44:11 <edwardk> so i have to rewire a half dozen of those, and the whole thing should work in the Cont monad
20:44:11 <hasenov> chessguy : that is, when I am evaluating a move, i am switching during each ply between the evalation of X and O
20:44:12 <edwardk> thanks
20:44:54 <chessguy> hasenov, hang on a second, what's the actual problem you're having? code not compiling? bad output? test not passing?
20:44:58 <hasenov> chessguy : what i need to do, is during the whole evalation of a tree, to have only X or only O as being evaluated, if that makes sense
20:45:36 <hasenov> chessguy : bad output, not doing what its supposed to be doing, misreading the algorithm
20:45:47 <chessguy> hasenov, that's not what you need to do, if i understand what you want to do correctly
20:45:53 <chessguy> just negate the score for one or the other
20:46:55 <hasenov> negate? what do u mean?
20:46:57 <chessguy> from the looks of things, you're making things too complicated already
20:47:08 <hasenov> ok
20:48:15 <edwardk> oerjan: so something like arith :: (HasReg reg1 reg, HasReg reg2 reg, IntReg reg) => ArithOp -> reg1 (Lir a) -> reg2 (Lir a) -> Cont (Lir a) (Flagged reg (Lir a))
20:48:24 <hasenov> i know i need to evaluate at each value, but my evaluation switches at each ply based on the currentMove
20:48:50 <chessguy> sure
20:49:01 <oerjan> edwardk: yeah
20:49:08 <edwardk> hasenov: just keep track of a current sign and multiply it by the result
20:49:15 <hasenov> i know exactly what i need to do, i just dont know how to do it because im not familiar with the language
20:49:38 <edwardk> oerjan: now i just need to figure out how to get the code of arith to actually fit that type ;)
20:51:09 <oerjan> edwardk: arith op a b = Cont (roll . LArith op (getReg a) (getReg b))  perhaps
20:51:27 <edwardk> heh i just converged on that same answer
20:51:53 <hasenov> edwardk : u mean replacing, the Maybe Moves, with positives or negative ints? ok then, how would i keep track of the sign? wouldnt i need to pass it around to getValue?
20:54:51 <hasenov> im thinking that getValue needs to return a tuple of the evaluation of the move along with the current move
20:55:24 <hasenov> which would then would be fed into the next evaluation, and so on, but that sounds very much like the monad examples to me
20:57:00 <chessguy> well, we can't have that. sheesh, soon people will think that monads are practical instead of just cool theoretical things to talk about
20:57:24 <edwardk> oerjan: HLT and JMP are still messing with me but it looks like the right idea
20:58:15 <hasenov> well actually, me asking about whether i should use monads was my first question on here
20:58:53 <chessguy> join the crowd
20:58:58 <hasenov> since i need to pass state around
20:59:13 <gwern> @seen SamB
20:59:13 <lambdabot> SamB is in #xmonad, #perl6 and #haskell. I last heard SamB speak 2h 13m 12s ago.
20:59:48 <gwern> guess he's gone for the night then
20:59:57 <hasenov> if this was an imperative language id use a global variable, since in here there are no global variables i need to pass the state around
20:59:57 * gwern wanted to ask about ZMachine
21:00:00 <chessguy> actually, i've found that for simple stuff like this, using State as opposed to handling it yourself is roughly the same
21:00:15 <chessguy> not that i'm any kind of expert
21:00:56 <hasenov> but i dont know what monad i need to use, because obviously i cant write a line that includes all the nodes in a tree
21:01:48 <hasenov> would it be the State Monad/
21:02:06 <oerjan> @src Cont return
21:02:07 <lambdabot> return a = Cont ($ a)
21:02:08 <chessguy> for handling state? yes
21:02:54 <chessguy> @type ($)
21:02:55 <lambdabot> forall a b. (a -> b) -> a -> b
21:03:08 <edwardk> am trying something like Cont (roll . const HLT) or something
21:03:55 <edwardk> am still elbows deep in changing all the type signatures and plumbing the monad through the code
21:04:53 <oerjan> i would think hlt would be an escaping action of sort...
21:04:53 <gwern> 'Though a superhero, Bruce Schneier disdains the use of a mask or secret identity as â€™security through obscurityâ€™.'
21:05:09 <edwardk> and it looks like i'd benefit a lot from a combinator that did foo x = Cont (roll . x)
21:05:21 <edwardk> @pl \x -> Cont (roll . x)
21:05:21 <lambdabot> Cont . (roll .)
21:06:56 <oerjan> edwardk: well you are using const hlt in an example, would imagine that changing to Cont (const hlt)
21:07:07 <oerjan> and then you could call that hlt instead
21:07:24 <edwardk> yeah
21:07:35 <oerjan> and similarly for jmp
21:07:36 <edwardk> the const hlt thing is coz it should be running under >> not >>=
21:07:47 <oerjan> yeah
21:07:56 <edwardk> and i just didn't have the syntactic hooks in my previous version
21:09:23 <edwardk> i think it needs the roll though coz Lir a = Rec LirF a  has the form Rec ((LirF a -> a) -> a) though, hrmm, that also looks like a Cont
21:10:09 <edwardk> i wonder if i missed something fundamental on that definition for Rec
21:15:33 <hasenov> could anyone point me to a good tutorial on the State monad?
21:16:54 <solrize_> is there a more direct way to read n bytes from a filehandle than (replicate M $ hGetChar) ?
21:17:07 <solrize_> replicateM n   that is
21:18:13 <solrize_> :t replicateM 3 $ hGetChar
21:18:14 <lambdabot> Not in scope: `hGetChar'
21:20:59 <solrize_> are [m a] and m [a] the same type?
21:21:08 <mauke> no
21:21:14 <solrize_> i didn't think so
21:21:14 <mauke> unless m = []
21:21:18 <solrize_> m = IO
21:21:44 <edwardk> oerjan: ideas on the jcc stuff? that Cont is also giving me trouble
21:22:29 <solrize_> hm i just made a paste but it dind't announce?
21:22:35 <solrize_> http://hpaste.org/6424
21:22:48 <mauke> bot is down
21:23:24 <Cale> solrize_: what are you confused about?
21:23:39 <mauke> the -> monad
21:23:41 <solrize_> i tihnk the type of randomnbytes should be Int -> [IO Char]
21:23:53 <solrize_> and the :t in the paste seems to confirm this
21:23:58 <solrize_> but the type annotation works
21:23:59 <mauke> it doesn't
21:24:10 <Cale> solrize_: So randombytes takes an Int and produces a list of IO actions?
21:24:13 <mauke> :t replicateM 3 $ hGetChar
21:24:14 <lambdabot> Not in scope: `hGetChar'
21:24:20 <mauke> :t replicateM 3 $ IO.hGetChar
21:24:21 <lambdabot> GHC.IOBase.Handle -> [IO Char]
21:24:26 <mauke> :t replicateM 3 $ IO.hGetChar ?hh
21:24:27 <Cale> solrize_: If that's what you want, then a single do-block like that won't really do so well.
21:24:27 <lambdabot> (?hh::GHC.IOBase.Handle) => IO [Char]
21:24:38 <mauke> spot the difference
21:24:38 <solrize_> cale what's weird is it typechecks and works
21:24:46 <solrize_> hmm
21:24:53 <Cale> solrize_: What typechecks and works?
21:25:00 <mauke> Cale: randombytes
21:25:10 <Cale> yes, of course it does.
21:25:24 <Cale> You know that String = [Char], right?
21:25:27 <solrize_> yes
21:25:50 <mauke> his confusion is about omitting the handle arg to hGetChar, causing replicateM to use the (e ->) monad
21:25:50 <Cale> It takes an Int, and gives an IO action producing a list of characters when run.
21:26:03 <Cale> oh
21:26:14 <solrize_> ohhhh    hmm
21:26:27 <Cale> (He didn't say anything about that :)
21:26:45 <mauke> the code in the paste was obvious enough
21:26:57 <Cale> I suppose I'm not confused by it enough :)
21:27:04 <mauke> heh
21:27:12 <solrize_> ok, so (hGetChar hh) is an IO action      :: [IO Char]
21:27:33 <solrize_> oops IO Char
21:27:40 <solrize_> hGetChar hh  :: IO Char
21:27:55 <solrize_> so replicating it is not [IO Char] ?
21:27:56 <Cale> replicateM in the ((->) e) monad has type  Int -> (e -> a) -> e -> [a]
21:28:29 <solrize_> it's the ->e   monad that's being replicated ?
21:28:58 <Cale> replicateM is being used in the (->) e monad.
21:29:03 <edwardk> oerjan: that worked remarkably well, cleaning up the last case or two now
21:29:10 <Cale> Because you're passing it a function and not an action in the IO monad
21:29:29 <solrize_> :t (replicateM n)
21:29:30 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
21:29:30 <lambdabot>     In the first argument of `replicateM', namely `n'
21:29:36 <solrize_> :t (replicateM Int)
21:29:37 <lambdabot> Not in scope: data constructor `Int'
21:29:40 <solrize_> :t (replicateM n::Int)
21:29:41 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
21:29:41 <lambdabot>     In the first argument of `replicateM', namely `n'
21:29:43 <Cale> :t (replicateM 5)
21:29:44 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m [a]
21:30:07 <Cale> When m = (->) e, we have that as   (e -> a) -> e -> [a]
21:30:39 <solrize_> but the arg to (replicateM) is clearly (hGetChar hh)
21:30:42 <solrize_> no?
21:30:44 <Cale> no
21:30:48 <Cale> It's hGetChar
21:30:53 <Cale> which is not an IO action
21:31:04 <Cale> it's a function taking handles and producing IO actions
21:31:14 <solrize_> the $ is supposed to get the rest of the expression ?
21:31:14 <edwardk> @pl \x y -> x (runCont y id)
21:31:14 <lambdabot> (. flip runCont id)
21:31:18 <edwardk> blech
21:31:23 <Cale> $ is not magic
21:31:24 <mauke> solrize_: which call to replicateM are you talking about?
21:31:28 <Cale> It's just function application
21:31:31 <solrize_>     replicateM n $ hGetChar hh
21:31:39 <mauke> yes, that one's ok and uses IO
21:31:39 <Cale> oh
21:31:45 <Cale> *that* one is in IO
21:31:49 <solrize_> that's not the same as   replicateM n (hGetChar hh)    ?
21:31:52 <Cale> The one in your GHCi session isn't.
21:31:57 <Cale> *Main Control.Arrow> :t replicateM 3 $ hGetChar
21:31:58 <Cale> replicateM 3 $ hGetChar :: Handle -> [IO Char]
21:31:59 <oerjan> edwardk: for the jcc, i think Lir a -> Lir a  is closest to Cont (Lir a) ()
21:32:02 <Cale> that one isn't in IO
21:32:11 <solrize_> right
21:32:18 <Cale> does that make sense now?
21:32:24 <oerjan> essentially the argument is missing because the action is returning ()
21:32:34 <solrize_> yeah i'm trying to see the type of the version with hh
21:32:38 <Cale> okay
21:32:47 <edwardk> oerjan: yeah, i was going there then i backed away to see if i could get the rest working and just stubbed it with an undefined ;)
21:32:52 <edwardk> everything else works so far though
21:32:55 <Cale> replicateM :: Int -> IO a -> IO [a]
21:33:09 <Cale> replicateM n :: IO a -> IO [a]
21:33:17 <solrize_> ok
21:33:20 <edwardk> http://comonad.com/haskell/lir/LirCont.hs
21:33:21 <Cale> replicateM n (hGetChar hh) :: IO [a]
21:33:24 <Cale> er
21:33:27 <Cale> replicateM n (hGetChar hh) :: IO [Char]
21:33:29 <solrize_> hmm ok
21:33:44 <edwardk> i had to make the $$ a little more magical to handle the continuation but meh it is clean syntactically
21:33:56 <solrize_> ok i think i get it now.  thanks.
21:33:57 <Cale> and a do-block always has the type of the last statement in it.
21:34:27 <Cale> Basically, replicateM is just a repeating loop.
21:34:33 <edwardk> i don't see a way around the magical $$ function without wrapping the do block in parentheses
21:34:43 <Cale> It produces an action which runs the action n times and collects a list of the results.
21:34:48 <solrize_> right i got confused because i thought the result of replicateM Int (m a)   was [m a]  instead of m [a]
21:34:52 <solrize_> yeah
21:35:01 <Cale> uh, what?
21:35:05 <Cale> No, it wasn't.
21:35:19 <Cale> It always gives you an m [a]
21:35:22 <solrize_> right
21:35:24 <Cale> It's just a matter of which m :)
21:35:30 <Cale> (and which a)
21:35:36 <solrize_> i got confused by the ->e version
21:35:40 <Cale> okay
21:35:50 <Cale> You see how the (e->) version works now?
21:35:53 <solrize_> i'm surprised there's nothing in System.IO to just read n chars?  is what i did a lot slower?
21:36:12 <Cale> That's a reasonable way to read n characters.
21:36:16 <solrize_> actually i don't undersand the (e->) version but that seems like a separate item on my stack ;)
21:36:17 <edwardk> oerjan fixed it
21:36:30 <solrize_> ok i guess there is some buffering under the covers
21:36:47 <Cale> Essentially, in the (e->) monad, replicateM n f x = replicate n (f x)
21:37:00 <Cale> > replicateM 5 (2*) 10
21:37:01 <lambdabot>  [20,20,20,20,20]
21:37:14 <oerjan> edwardk: you can also edit the last TODO ;)
21:37:28 <solrize_> yeah, what i mean is i have to work out the monad laws for ->
21:37:37 <solrize_> brb'
21:37:44 <Cale> solrize_: Well, I don't know about that. If you want really high efficiency, use Data.ByteString
21:37:55 <edwardk> hahaha
21:39:09 <edwardk> now i just need to come up with some creative type alias to clean up the signatures
21:39:43 <gwern> @tell SamB I've seent you a number of ZMachine patches. I'd like to add it to Hackage, but my testing has a problem - I can't seem to actually do any typing/input. is this a known problem, or can you type and play the provided .z5s just fine?
21:39:43 <lambdabot> Consider it noted.
21:40:01 <edwardk> maybe add a typeclass that contains Lir a  so that can go down one character per occurence and simplify Cont (Lir a) (Flagged Reg8 (Lir a)) with some alias
21:40:51 <dmwit> gwern: You should have ?ask'd that. ;-)
21:41:09 <solrize_> cale yeah i'm going to rewrite this stuff with bytestring, which however also seems to have no way to read n chars
21:41:14 <edwardk> :1
21:41:14 <edwardk> :w
21:41:19 <solrize_> i may write a RNG with the state monad, using stdgen doesn't seem like the right thing
21:41:48 <Cale> solrize_: But it does block-buffered IO
21:41:52 <edwardk> oerjan: i was mostly having fun with the fact that there are so many comonad readers in that particular implementation ;)
21:41:54 <solrize_> bytestring?  yeah
21:42:12 <solrize_> but, i'd hope that reading n bytes would do a memcpy or something
21:42:22 <gwern> dmwit: why? what does ?ask do that's different from @tell?
21:42:24 <solrize_> well i guess replicateM does something reasonable
21:42:59 <dmwit> gwern: Oh, it's just vanity, ?ask just uses the text, "two hours ago, gwern asked ..." rather than "two hours ago, gwern said ...".
21:43:30 <oerjan> edwardk: maybe type ContL f a = Cont (Lir a) (f (Lir a)) ?
21:43:42 <solrize_> btw i'm still hosed getting ghc to find the crypto lib that i installed last night, any further thoughts?
21:44:40 <oerjan> (or was that what you meant?)
21:45:05 <sclv> watching spj on type-driven testing now. its v. nice but man is he hung up on this launching missiles story. sort of freaks me out...
21:45:10 <solrize_> haha
21:45:14 <edwardk> oerjan: sounds pretty good and yeah thats basically where i'm going with this
21:45:48 <solrize_> there was a paper (maybe his) with missile examples, that had a footnote saying those objecting to actual missiles should read the paper as if it were about a video game, with the missiles being game objects
21:46:10 <solrize_> oh wait that was hudak's prototyping paper
21:46:15 <sclv> seriously i love the talks but i'm going to have nightmares about impure languages and dr. strangelove.
21:46:29 <solrize_> lol
21:46:57 <scook0> sclv: purity of essence?
21:47:10 <solrize_> hehe
21:47:31 <sclv> haha exactly. fluoride and side effects.
21:48:04 <gwern> our precious referential transparencies. the communists are mutating our water to corrupt them!
21:48:55 <oerjan> edwardk: it's a bit weird that.  it is almost as if that f is the real return value of some monad, but it has the wrong kind
21:49:36 <edwardk> oerjan but i'm actually thinking something like creating a class that contains (Lir a) and trying to cut the signatures down from
21:49:36 <edwardk> sse :: (HasReg reg1 RegXmm, HasReg reg2 RegXmm) => SseOp -> reg1 (Lir a) -> reg2 (Lir a) -> Cont (Lir a) (RegXmm (Lir a)) to sse :: (HasReg reg RegXmm, HasReg reg2 RegXmm, IsLir t) => reg1 t -> reg2 t -> Cont t (RegXmm t)
21:49:54 <edwardk> or something similar
21:50:00 <gwern> does Adam Langley ever show up here?
21:50:18 <Cale> Quite confidently yes :)
21:50:27 <oerjan> oh
21:50:54 <Cale> @seen agl
21:50:54 <lambdabot> I saw agl leaving #haskell 1h 2m 1s ago, and .
21:50:59 <Cale> gwern: ^^
21:51:13 <gwern> ah. I was trying ad*
21:52:03 <gwern> @ask agl Any chance you could change the Category: on your network-rpca package to be 'Network' and not 'Networking'? (consistency with the other 20 or so packages)
21:52:03 <lambdabot> Consider it noted.
21:52:36 <adu> whats the difference between a type class and an interface?
21:53:08 <gwern> alright. how aout 'Nils Anders Danielsson'? he ever here?
21:53:20 <solrize_> edwardk maybe you want to have your own type system for the assembler instead of using haskell combinators
21:53:24 <Cale> adu: a Java interface?
21:53:27 <solrize_> adu, haskell type classes are sort of like java interfaces
21:53:47 <solrize_> they're more general though
21:53:51 <adu> yes, the java kind
21:54:00 <solrize_> they can select on the return type, not just the arg types
21:54:08 <edwardk> solirize: i will add a 'valid' check for any stuff i can't do in the type system but the type system makes a good sanity check
21:54:14 <adu> solrize: ooo good one!
21:54:48 <mauke> also, constructor classes
21:55:15 <adu> what's a constructor class?
21:55:19 <Cale> and all the typeclass extensions, like multiparameter typeclasses and type families and so on.
21:55:21 <solrize_> and for some of them (e.g. monads) there is syntax sugar in the language, that relies on the typeclass (do notation, [...] for lists, etc.)
21:55:35 <Cale> adu: a typeclass which abstracts over a type constructor rather than a type
21:55:43 <Cale> adu: a good example is Functor
21:55:48 <Cale> class Functor f where
21:55:58 <Cale>   fmap :: (a -> b) -> f a -> f b
21:56:13 <adu> o
21:56:28 <solrize_> monad is another example
21:56:31 <Cale> For example, the type constructor for lists is an instance, with fmap just being the usual map function
21:56:57 <Cale> The type constructor ((->) e) is also an instance, with function composition being the fmap
21:57:04 <mauke> instances are independent of data declarations
21:57:04 <adu> so 1-parameter type classes where the type variable is not used as a type constructor are similar to Java interfaces...
21:57:19 <Cale> adu: Oh, also they're open.
21:57:21 <mauke> in java you have to specify what you implement right in the class definition
21:57:24 <adu> open?
21:57:40 <Cale> adu: So you can invent a new class and make an old datatype an instance of it without changing the datatype
21:57:58 <Cale> and add new instances at any time for any existing classes and datatypes
21:58:04 <Cale> (without changing them)
21:58:40 <Cale> iirc, when you create a Java interface, Java classes must explicitly be declared to implement it in their definitions
21:58:52 <mauke> you can't do this in java: f :: (Show a, Num a) => a -> String
21:59:17 <sclv> mauke: don
21:59:19 <Cale> Oh, that's another good point :)
21:59:32 <sclv> erm don't generics get you that in java?
22:00:17 <Cale> I don't know the Java generics system very well, but can you insist that a type variable ranges only over types which implement a given interface?
22:00:30 <sclv> as I recall they've got lots of irritating limits due to lack of erasure, but that's not among them.
22:00:54 <adu> i dunno Java all that well, I know Haskell better than Java, I think...
22:00:58 <Cale> But pre-generics, you couldn't even express something like that.
22:01:14 <bos> Cale: yes, you can.
22:01:21 <Cale> You could just refer to a type by the interface, and there was no way to express that something had to be part of two interfaces.
22:01:43 <mrd> <A implements Foo> or something
22:01:49 <Cale> ah, okay, good
22:02:22 <sclv> s/lack of erasure/insistence on erasure/
22:02:30 <Cale> Oh, there's another difference. In Haskell, typeclasses are *only* used to restrict the quantification of type variables.
22:02:42 <mrd> there's only a problem with erasure because java is originally broken
22:02:45 <Cale> In Java, interfaces are also used as if they were types.
22:03:03 <sclv> right: in Java every interface is at once a typeclass and an existential wrapper to it.
22:03:11 <adu> heh interesting
22:03:36 <adu> seperations...
22:04:01 <Cale> But yeah, they're attacks on many of the same problems.
22:04:11 <solrize_> if arrows had been figured out a lot earlier, would haskell look the way it does now?
22:04:29 <adu> i don't think so
22:04:44 <sclv> lots of things are more naturally monads than arrows though, no?
22:04:45 <Cale> Probably pretty similar. There might be arrow combinators in the Prelude instead of out in a library.
22:04:59 <sclv> even though, yes, that means they also can be arrows...
22:05:00 <Cale> Monads are usually nicer than arrows, when you can get them.
22:05:04 <adu> I think "do" and "mdo" would have been combined somehow
22:05:38 <sclv> except mdo isn't as general as do either though...
22:06:07 <adu> and I don't like (x >- f -> y) notation, or whatever
22:06:26 <sclv> adu: what would you prefer?
22:06:35 <adu> visual programming
22:06:36 <adu> hehe
22:06:58 <adu> like Pd, Gstreamer, QuartzComposer
22:06:59 * sclv dies a little.
22:07:10 <adu> noooo
22:07:12 <adu> don't die
22:07:56 <adu> maybe I just haven't used Arrows enough to fully appreciate their beauty :)
22:07:59 <sclv> a nice visual interface-creator built on top of high level haskell gtkish packages would be super nice though.
22:09:05 <adu> plus, I think the official Arrow class shouldn't be tied to the 2-tuple type
22:11:15 <adu> I think if there is one thing only Haskell can do it is to make everyone afraid of tuples.
22:12:08 <adu> because most newbies I see using tuples usually get the responses "you could use a list" or "you could use a data type"
22:12:10 <jql> (I 'refuse' 2 #be (intimidated))
22:12:23 <adu> heh
22:12:34 <oerjan> @remember adu I think if there is one thing only Haskell can do it is to make everyone afraid of tuples.
22:12:34 <lambdabot> Done.
22:12:38 <edwardk> http://comonad.com/haskell/lir/Lir.hs is about as clean as i think i can make it oerjan
22:13:03 <edwardk> i could go add a type Kont f a = Cont a (f a) or something
22:13:05 <edwardk> but thats about it
22:13:29 <gwern> @quote typle
22:13:29 <lambdabot> No quotes match. stty: unknown mode: doofus
22:13:30 <edwardk> and it only saves like 3-4 characters and isn't useful on every signature
22:13:35 <gwern> @quote tuple
22:13:35 <lambdabot> ghc says: Illegal unboxed tuple type as function argument
22:13:47 <gwern> @quote tuple
22:13:47 <lambdabot> ghc says: Illegal unboxed tuple type as function argument
22:13:57 <gwern> hm.
22:14:00 <gwern> @quote tuples
22:14:00 <lambdabot> adu says: I think if there is one thing only Haskell can do it is to make everyone afraid of tuples.
22:14:13 <adu> :)
22:14:41 <gwern> weird. I assumed lambdabot was matching on substrings, but I guess it's actually doing == on a list of lists, perhaps Strings ran through 'words'
22:15:03 <mauke> @quote aske
22:15:03 <lambdabot> glguy says: dons: one meteor could wipe out the Haskell IRC bot community!
22:15:22 <edwardk> :w
22:15:31 <mauke> :q
22:15:37 <edwardk> =)
22:15:40 <edwardk> wrong window =)
22:16:00 <sclv> :q!
22:16:00 <gwern> gah. so then why didn't the 'tuples' quote shown up on 'tuple'?
22:16:06 <sclv> :q!!!!!
22:16:22 <oerjan> @quote tuple
22:16:23 <lambdabot> ghc says: CPR Analysis tried to take the lub of a function and a tuple
22:16:25 <oerjan> @quote tuple
22:16:25 <lambdabot> ghc says: Illegal unboxed tuple type as function argument
22:16:36 <oerjan> @quote tuple
22:16:36 <lambdabot> adu says: I think if there is one thing only Haskell can do it is to make everyone afraid of tuples.
22:16:40 <oerjan> finally
22:16:55 * gwern is confuzzled
22:16:55 <pjd> @quote afraid
22:16:55 <lambdabot> adu says: I think if there is one thing only Haskell can do it is to make everyone afraid of tuples.
22:16:59 <oerjan> gwern: maybe there are just many more quotes with just tuple
22:17:47 <gwern> oerjan: ah, but when I did @quote tuple, I got the same quote back twice; that argues against that
22:18:08 <oerjan> oh well
22:18:18 <mauke> welcome to randomness
22:18:49 <sclv> @quote random
22:18:49 <lambdabot> sioraiocht says: was dons PhD in writing random haskell libraries?
22:19:13 <gwern> mauke: no, random would be abruptly discussing twincest; or exploding whales; or human cheese; or any number of bizarre topics (many with Wikipedia articles)
22:19:20 <gwern> (not all, though; we used to have [[Human cheese]] but it got deleted)
22:19:28 <mauke> twincest is over in #C++
22:19:33 <gwern> heh. I've sometimes wondered that about dons myself
22:19:54 * jql checks human soap, though
22:19:54 <gwern> mauke: not #C#?
22:20:03 <mauke> I don't think so
22:20:26 <jql> yep, wiki documents human soap
22:20:33 <solrize_> What's the difference between ST and State ?
22:20:33 * jql is disgusted. :(
22:20:34 <mauke>  twincest!~river@clematis.knams.wikimedia.org
22:20:57 <gwern> jql: I just redirected it to [[Soap made from human corpses]]
22:21:01 <sclv> isn't twincest when c# programmers migrate to java?
22:21:18 <gwern> mauke: twincest is an old old #wikipedia injoke...
22:21:28 <mauke> solrize_: State gives you a single implicit mutable variable
22:21:41 <dolio> State is for passing threaded state through a series of functions in lieu of extra arguments/tupled return types...
22:21:52 <mauke> solrize_: ST on the other hand is a limited version of IO. it lets you create/use as many mutable variables as you want, but you have to pass them around explicitly
22:21:56 <dolio> And ST is for algorithms that need mutable updates.
22:22:04 <jql> ugh, wikipedia is a den of filth, these days. :)
22:22:14 <gwern> 'Later, when human bodies were indeed being plundered for products (hair for felt and insulation, for example), there are indications that some German scientists experimented with making soap from human fat. Professor Rudolf Spanner produced somewhere between 10 and 100 kg of soap from corpses from the mental hospital in Konradstein (now Kocborowo), a prison in KÃ¶nigsberg, and the Stutthof concentration camp. According to Spanner's ...
22:22:21 <gwern> ... post war testimonies the soap was used only for injections into joint ligaments.' <-- I actually find their use to be the most bizarre part
22:22:27 <dolio> (With performance you'd expect from actual mutable update.)
22:26:01 <solrize_> hmm, i think i want State, though the idea is to do something like what IO does
22:26:47 <dolio> ST is essentially a slimmed down version of IO.
22:27:03 <dolio> Where you just get the equivalent of IORef and IOArray, but not all the actual IO stuff.
22:27:21 <solrize_> where do the ST actions come from?
22:27:31 <oerjan> @src ST
22:27:31 <lambdabot> newtype ST s a = ST (STRep s a)
22:27:39 <oerjan> @src STRep
22:27:39 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
22:27:46 <oerjan> @src IO
22:27:47 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
22:27:54 <solrize_> what's State#  ?
22:27:58 <oerjan> they are the same as IO under the hood
22:28:35 <oerjan> an internal ghc type
22:28:38 <dolio> Conceptually, what ST does is enforce linear access of some hidden 'heap' value, such that it's safe to mutably update the heap.
22:28:43 <solrize_> so i want to have a function that increments a counter every time i call it
22:28:50 <solrize_> can i do that with ST?
22:29:05 <oerjan> just one counter?
22:29:06 <dmwit> yep
22:29:16 <dmwit> But State would be just as good for that  application.
22:29:25 <solrize_> essentially yeah, one counter; i could use a tuple if i needed more than one, i presume
22:29:41 <mauke> or a record
22:29:54 <dolio> Although in practice, it's just a token, and mutable update to actual memory and such is what's done, I think.
22:30:02 <solrize_> is it like IO, i.e. i'm protected from getting the internal counter out?
22:30:12 <dmwit> :t runST
22:30:13 <lambdabot> forall a. (forall s. ST s a) -> a
22:30:16 <dmwit> ;-)
22:30:34 <solrize_> s is the internal state
22:30:39 <dmwit> yes
22:30:40 <oerjan> > runState (replicateM 10 $ do c <- get; put (c+1); return c) 0
22:30:41 <lambdabot>  ([0,1,2,3,4,5,6,7,8,9],10)
22:31:06 <solrize_> can you do that with ST ?
22:31:13 <mauke> > execState (replicateM 10 $ modify succ) 0
22:31:14 <lambdabot>  10
22:31:32 <solrize_> @source modify
22:31:32 <lambdabot> modify not available
22:31:36 <dmwit> modify succ -- nice
22:31:37 <solrize_> @src modify
22:31:38 <lambdabot> Source not found. That's something I cannot allow to happen.
22:31:39 <oerjan> > runST
22:31:39 <lambdabot>        add an instance declaration for (Typeable (forall s. ST s a))
22:31:50 <dmwit> modify f = get >>= put . f -- solrize_
22:32:01 <solrize_> yeah , just making sure
22:32:28 <mauke> > runST (do v <- newSTRef 0; replicateM_ 10 $ modifySTRef succ; readSTRef v)
22:32:28 <lambdabot>   Not in scope: `readSTRef'
22:32:54 <mauke> > runST (do v <- Data.STRef.newSTRef 0; replicateM_ 10 $ Data.STRef.modifySTRef succ; Data.STRef.readSTRef v)
22:32:54 <lambdabot>   Not in scope: `Data.STRef.readSTRef'
22:32:56 <oerjan> > runST (do r <- newSTRef 0; replicate 10 $ do c <- readSTRef r; writeSTRef r (c+1); return c)
22:32:56 <lambdabot>   Not in scope: `writeSTRef'
22:33:06 <oerjan> gah
22:33:27 <dmwit> ?hoogle ST s s
22:33:30 <lambdabot> Data.STRef.readSTRef :: STRef s a -> ST s a
22:33:30 <lambdabot> Control.Monad.ST.unsafeInterleaveST :: ST s a -> ST s a
22:33:30 <lambdabot> Control.Monad.ST.unsafeIOToST :: IO a -> ST s a
22:33:52 <dmwit> Well, you have the right name. =/
22:34:13 <oerjan> > runST (do r <- newSTRef 0; replicate 10 $ do c <- readSTRef r; Data.STRef.writeSTRef r (c+1); return c)
22:34:13 <lambdabot>   Not in scope: `Data.STRef.writeSTRef'
22:34:29 <oerjan> apparently not imported
22:34:29 <solrize_> so if i want to call this counter incrementing function inside an IO action, i have to put StateT around the action?
22:36:20 <oerjan> essentially (runStateT or friends)
22:36:49 <solrize_> ok, i'm still a little hazy about State vs ST
22:36:56 <solrize_> but it looks like ST has no get/put
22:37:12 <solrize_> it just arranges for sequencing
22:37:21 <dmwit> ST has readSTRef/writeSTRef.
22:37:33 <dmwit> (Basically, you are left to managing your pointers yourself.)
22:37:57 <solrize_> hmm those are not in the docs
22:38:18 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-STRef.html#1
22:38:20 <solrize_> so i use some malloc-like thing to get the memory slot ?
22:38:21 <lambdabot> http://tinyurl.com/2xk8oz
22:38:21 <oerjan> solrize_: Data.STRef
22:38:26 <solrize_> oh ok
22:38:52 <dmwit> solrize_: newSTRef, which is still a huge improvement over malloc.
22:39:23 <solrize_> this doesn't look so bad, get/put could just be sugar around that
22:40:16 <solrize_> the main thing i care about is that the stref contents are impossible to duplicate outside of the action that creates the stref
22:40:19 <oerjan> well you could make a MonadState instance that way i guess
22:40:50 <solrize_> not sure what that is
22:41:11 <oerjan> @src MonadState
22:41:11 <lambdabot> Source not found. My pet ferret can type better than you!
22:41:24 <oerjan> it's the class in which get and put are defined
22:41:40 <solrize_> ok
22:41:50 <solrize_> well if/when i write the code i'll ask folks here to look at it
22:42:02 <dmwit> I guess I don't really have enough scrollback to see the motivation for using STRef... why do you want it?
22:42:07 <oerjan> main instances are State and StateT, but also the other monad transformers when wrapped around one of those
22:42:19 <Cale> You need to explicitly pass around STRefs, whereas in the State monad, the state is global.
22:42:26 <solrize_> dmwit, i have a function and want to make sure it never gets called twice with the same arg
22:43:01 <dmwit> hum
22:43:11 <dmwit> What should be the behavior if that happens?
22:43:22 <solrize_> massive lossage.  nuclear war etc.
22:43:26 <solrize_> :)
22:43:50 <Heffalump> solrize_: you'd need to either write your entire program in ST, or use an unsafePerformIO and a global.
22:44:37 <solrize_> well i could put the function in IO, but i think i can put it in ST and then instantiate it when i need it
22:45:12 <solrize_> so i'd have a wrapper for the function with an internal state that gets incremented on every call
22:45:16 <solrize_> in ST
22:45:36 <Heffalump> sure, it's just that you can't keep that state around after you leave ST.
22:46:29 <solrize_> well i can keep it around in IO
22:47:07 <solrize_> but my idea is if i want to use the function again after leaving ST, then just make a new state initialized from /dev/urandom in IO, with a long enough string that duplication is near-impossible
22:47:31 <solrize_> that's why that stuff earlier about replicateM and random bytes
22:47:37 <bos> why would you want to have a pure function that you can call only once?
22:47:49 <solrize_> the function is impure
22:48:09 <solrize_> it's an encryption function, if i encrypt the word "cheese" three times i have to be guaranteed to get a different answer each time
22:48:26 <bos> but you want it to pretend to be pure?
22:48:30 <pjd> solrize_: salt?
22:48:53 <solrize_> no it absoutely shouldn't be pure, if it's pure then the compiler might optimize calls away
22:49:04 <pjd> solrize_: salt!
22:49:05 <solrize_> pjd, yes, the function has to put a random salt in with the plaintext
22:49:28 <solrize_> encrypt plain = encrypt' salt plain
22:49:32 <solrize_> where the salt has to be different every time
22:49:42 <bos> so it's an impure function ... i'm not getting what's difficult about ensuring that it's only called once?
22:49:54 <gwern> an encryption function is a one-ton-one mapping from input to output, is it not? if output is smaller than input, it has to be a hash, and by the pigeonhole, you can't really do a expansion which isn't secretly 1-1
22:50:04 <solrize_> it can be called multiple times, it's just that any specific value of salt must be used only once
22:50:13 <gwern> solrize_: if you use unsafePerformIO, the issue with compilers is inlining, which can be prevented with pragmas
22:50:22 <bos> and it's embedded in IO?
22:50:25 <solrize_> gwern, encryption is one-to-many, the output is longer than the input
22:50:44 <pjd> solrize_: how does encrypt generate the salt?
22:50:54 <solrize_> an rng seeded from /dev/urandom
22:50:57 <Cale> solrize_: I would make it a pure function, taking the salt as a parameter. Then, in the rest of my program, I would have a sequence of distinct salts to be used.
22:51:05 <pjd> solrize_: then the result will just be in IO
22:51:08 <solrize_> cale, how do you make sure the salts are distinct?
22:51:16 <Cale> solrize_: By construction.
22:51:22 <solrize_> what do you mean by that?
22:51:29 <pjd> and yeah, note that urandom is not necessarily distinct, by definition
22:51:52 <pjd> but randomness is what you want out of a salt, not distinctiveness
22:51:53 <gwern> solrize_: why would output be longer? suppose you are using onetime-pad encryption - you have a 10meg long file, you xor it against 10megs of pad, and you get an ecnrypted 10meg file
22:51:56 <Cale> Well, [1..] :: [Integer], for example, is a list where no two elements are equal.
22:51:56 <solrize_> well in a cryptographic sense, it's distinct, read 20 bytes out and the collision probability is basically zero
22:52:14 <solrize_> gwern, if i encrypt the word "cheese" three times, i want three distinct outputs that each uniquely decrypt back to "cheese"
22:52:56 <pjd> solrize_: what's the problem?
22:53:25 <solrize_> pjd, the problem is encryption basically works by attaching a unique salt to the plaintext, then running the combination through a pure function
22:53:33 <solrize_> and i want to use the type system to guarantee that the salts are unique
22:53:44 <pjd> solrize_: you mean random?
22:53:51 <dmwit> I don't think the level of uniqueness you're requiring is really what salts are about.
22:53:51 <solrize_> random is ok
22:53:55 <pjd> right
22:53:58 <Cale> If you wanted to ensure that the results obtained from /dev/urandom were distinct, you could read that file as a lazy stream, possibly transform it a bit (so that you're reading longer chunks for instance), and then apply nub
22:54:31 <Cale> But you'll pay for it of course :)
22:54:33 <solrize_> cale i'm using unique sloppily, if the salts are 20 byte random strings there's an approx 2**-160 chance of getting a duplicate and i treat that as zero
22:54:39 <Cale> okay
22:54:51 <pjd> so from what you describe, encrypt plain = do { salt <- getRandom; return encrypt' salt plain }
22:55:04 <solrize_> pjd, yeah, basically
22:55:11 <Cale> So do that :)
22:55:21 <gwern> solrize_: why do you want that property?
22:56:49 <solrize_> gwern, semantic security, to not leak info about the plaintext.  say you want to tell your friend privately what you had for breakfast today ("eggs").  You encrypt it and send "ladscownenc" (the encryption of eggs).  the next day you have eggs again.  If you send the same encrypted string again, the opponent can't tell what you had for breakfast, but he learns that you had the same thing two days in a row
22:57:02 <solrize_> therefore you must encrypt "eggs" to one string today and a different string tomorrow
22:57:25 <solrize_> the cryptography saying is "a good disguise does not reveal the person's height" ;-)
22:58:07 <Cale> solrize_: So you'll just have an encrypt which is in the IO monad that reads a salt from /dev/urandom, and a pure one which takes the salt as a parameter
22:58:39 <gwern> solrize_: I see. and he's doing this by adding in a salt; but when considering the salt as a third thing, isn't it pure anyway?
22:58:46 <solrize_> cale, yeah, that is reasonable, i was thinking /dev/urandom is kind of slow but i could instead have an ST state initialized from urandom and then do a crypto computation on it
22:59:03 * glguy feels like he's in groundhog day
22:59:06 <Cale> solrize_: Yeah, you could also use StdGens
22:59:09 <solrize_> gwern, yes, there is a pure function underneath, but i want an API that takes care of ensuring the random or unique salts
22:59:25 <solrize_> cale, stdgens are pure, i thought; it's possible to use one twice
22:59:25 <pjd> solrize_: if that's what you want to protect against, a counter is simpler, and truly distinct
22:59:49 <pjd> (predictability of the counter is not a problem in that scenario)
22:59:52 <solrize_> pjd, yeah, but then i have to transform the counter to a salt, which again requires some state from IO
23:00:03 <pjd> no, the counter *is* the salt :)
23:00:10 <Cale> solrize_: Well, you get a new StdGen with each random, and you update your state with that, say.
23:00:23 <Cale> solrize_: and you can seed it from /dev/random, for instance.
23:00:52 <solrize_> cale the point is that i want to wrap up the StdGen in some kind of monad so it can't escape to the caller of encrypt
23:01:06 <Cale> solrize_: Luckily, I've already done that ;)
23:01:13 <solrize_> :)
23:01:21 <pjd> solrize_: as far as i know it's fairly common for crypto protocols to use counters this way
23:01:26 <solrize_> pjd, yes
23:01:29 <Cale> http://www.haskell.org/haskellwiki/New_monads/MonadRandom
23:01:29 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
23:01:37 <pjd> so you don't need IO/urandom at all
23:02:14 <solrize_> pjd i do need something like urandom because if i start counting from 0, i might do that twice
23:02:28 <bos> MonadRandom is dead sexy. if only we had a decent splittable source of random numbers, so performance wasn't silly bad.
23:02:30 <pjd> solrize_: persist the counter
23:02:42 <solrize_> pjd, yes, that's what this discussion is about :)
23:02:52 <solrize_> bos, any cryptographic RNG should be splittable
23:02:56 <pjd> no, urandom is a completely different thing
23:03:12 <pjd> you don't need any random numbers to persist the counter
23:03:39 <solrize_> persist the counter, like in a disk file or something?
23:03:48 <pjd> yes
23:03:54 <pjd> or, for example, use the current time
23:03:55 <solrize_> then it can be copied and re-used
23:04:09 <pjd> what, by accident? :)
23:04:12 <solrize_> really, urandom is the right way to do this
23:04:55 <pjd> solrize_: for the problem you defined, urandom is more complicated and less reliable
23:05:18 <solrize_> it's like unique mac addresses on ethernet cards, when manufacturers try to assign them as serial numbers, they always screw up and duplicating them, it's much better to just assign them randomly and make them long enough that the collision probability is near zero
23:05:31 <solrize_> pjd, there's protocols that need random looking iv's
23:05:43 <pjd> sure
23:05:43 <solrize_> and urandom is much more reliable than a disk file :)
23:06:11 <pjd> you can still just use the current time
23:06:14 <Cale> Heh, produce a really big disk file by flipping coins.
23:06:26 <solrize_> pjd i can't use the current time, it could be re-used if the clock gets set back
23:06:32 <Cale> To be *really* sure that it's random ;)
23:06:33 <solrize_> daylight savings time :)
23:06:57 * glguy wonders if it is a bug that "otherwise" highlights green in hpc markup
23:06:58 <pjd> solrize_: that's the wrong "current time"
23:07:04 <solrize_> there's a paper by don davis about how disk seek latency is random because it's affected by chaotic airflow inside the drive :)
23:07:22 <pjd> you'll want to use the epoch, for example
23:07:29 <solrize_> pjd, really, urandom is better
23:07:32 <glguy> (I recognize that that just means otherwise always evaluates True, but that hardly seems interesting, more like s omething hpc should know about)
23:08:11 <solrize_> there's a system call that can set the clock backwards but none that runs urandom backwards :)
23:08:18 <pjd> solrize_: not for what you described, but suit yourself :)
23:08:40 <pjd> solrize_: urandom has to be initialized like everything else
23:08:55 <solrize_> pjd, urandom is continuously updated by random events in the kernel
23:09:05 <solrize_> and in some cases from external hardware RNG's
23:09:21 <solrize_> once your system has been running for a little while urandom is pretty good
23:09:29 <edwardk> pjd: /dev/urandom is constantly updated by far better sets of random churn events than you are likely to come up with (or have access to) within your own code
23:09:43 <pjd> edwardk: i understand how it works
23:10:06 <pjd> edwardk: the problem in question doesn't require random numbers, though, but distinct numbers
23:10:10 <pjd> like an incrementing counter
23:10:20 <edwardk> then i'm not sure how you could advocate using a replayable persisted counter then, ah
23:10:48 <edwardk> then i guess i missed something. thats what i get for going off to code and poking my nose in ;)
23:11:35 <pjd> solrize_: if nothing else, an argument against using urandom for this is wasting valuable entropy :)
23:11:36 <solrize_> anyway cryptography generally accepts that q**2/2**n = 0 when q is small and n is large :)
23:11:50 <solrize_> yes there's an entropy shortage :)
23:12:11 <edwardk> oerjan: still around?
23:12:19 <solrize_> urandom actually is a cryptographic PRNG seeded from system entropy, so the main reason to not use it on every encryption operation is the system call overhead
23:12:23 <oerjan> yeah barely
23:12:46 <edwardk> http://comonad.com/haskell/lir/Lir.hs is i think the last change i'll make for the night
23:12:48 <solrize_> so does anyone have any idea why ghc doesn't find the hackage crypto library?
23:13:41 <edwardk> i realized that the newtype Rec f a = Rec ((f a -> a) -> a) elimination form used by the fegaras sheard was the same form as all of the continuations ;)
23:14:00 <edwardk> so type Rec w a = Cont a (w a)
23:14:11 <oerjan> heh
23:14:16 <edwardk> and a few changes to roll and place, and now everything uses Cont! =)
23:14:23 <glguy> unsafeRead / unsafeWrite -> slower code than readArray writeArray?
23:14:29 * glguy wonders if RULES are to blame
23:14:54 <edwardk> and the result types are expressed as 'Rec RegXmm a' since i encapsulated the 'Lir a' terms into a typeclass
23:15:02 <edwardk> which is pretty clean i think
23:16:06 <edwardk> and then a catamorphism over that Rec type is just 'cata f x = runCont x f'
23:16:22 <edwardk> @pl \f x -> runCont x f
23:16:22 <lambdabot> flip runCont
23:16:25 <edwardk> thats what i thought =)
23:17:34 <solrize_> is there a way to tell (other than code inspection) that a State monad doesn't export its state ?
23:18:53 <pjd> solrize_: aren't you reading from urandom?
23:18:55 <bos> solrize_: it's hard to tell what you're asking.
23:19:21 <solrize_> i mean, if I have a value like Just 3,  I can pattern match or use fromJust to get the 3 out
23:19:57 <solrize_> but there could be some other type with internal variables that are inaccessible
23:20:25 <solrize_> so i'm asking if the type system has a way to know whether a variable is encapsulated
23:20:40 <solrize_> if that makes sense
23:20:40 <pjd> solrize_: if this is for the encrypt function, you should not need State
23:20:54 <edwardk> @pl \fa wa -> Flagged (ReaderCT fa wa)
23:20:54 <lambdabot> (Flagged .) . ReaderCT
23:21:23 <solrize_> i was actually wondering about it with regard to MonadRandom
23:21:34 <solrize_> yeah i think the simplest way to implement encrypt is to put it in IO
23:21:41 <bos> solrize_: you couldn't do it in general.
23:21:51 <solrize_> hmm ok
23:22:02 <edwardk> @pl \x -> foo (bar x) (baz x)
23:22:02 <lambdabot> liftM2 foo bar baz
23:22:17 <adu> hmm
23:22:33 <adu> I think i'm starting to see why Arrows are difficult
23:22:52 <adu> you can't do them with Monads
23:23:20 <mauke> :t Kleisli
23:23:21 <lambdabot> forall a (m :: * -> *) b. (a -> m b) -> Kleisli m a b
23:23:22 <solrize_> i think i can understand MonadRandom if i squint at it enough :)
23:23:32 <Cale> adu: There are some arrows which are not monads, but all monads can be made into arrows.
23:23:37 <glguy> well, you can do monads with arrows, but you can do arrows with monads
23:23:41 <mauke> :t runKleisli
23:23:42 <lambdabot> forall (m :: * -> *) a b. Kleisli m a b -> a -> m b
23:23:59 * glguy isn't sure what that has to do with the difficulty though
23:24:10 <adu> Cale: right, what I just realized was that not all Arrows are Monads
23:24:24 <Cale> yeah
23:24:56 <solrize_> hmm, where does MonadRandom use arrows?  it imports Control.Arrow
23:25:07 <dmwit> What's the difference between "arr" and "pure"?
23:25:18 <mauke> dmwit:
23:25:25 <glguy> dmwit: spelling
23:25:31 <dmwit> heh
23:25:38 <oerjan> dmwit: nothing, but pure clashes with Control.Applicative
23:25:40 <solrize_> anyway, bos, i think i can write you a splittable RNG if you want one, whose splittability is mathematically provable up to the security assumptions behind AES
23:25:43 <dmwit> I really like mauke's answer.
23:25:59 <slava> oerjan: the same function has two names because of a name clash? interesting
23:26:17 <oerjan> slava: i don't know if the name clash came first
23:26:52 <dolio> pure and arr in Arrow are way older than Applicative.
23:26:53 <glguy> tab-completion strikes again?
23:27:01 <glguy> oh, nvm
23:27:33 <dmwit> No, that was a real (if cryptic) answer. =)
23:27:59 <oerjan> data Mu
23:30:10 <solrize_> oh!  it works now
23:39:09 <slava> so how does @pl work?
23:39:40 <solrize_> @pl x + x**2
23:39:40 <lambdabot> x + x ** 2
23:39:53 <solrize_> @pl f x = x**2
23:39:53 <lambdabot> f = (** 2)
23:40:16 <solrize_> @pl f a = g a a a a
23:40:16 <lambdabot> f = join (join (join g))
23:40:34 <slava> does it just have a large set of hard-coded rewrite rules?
23:40:42 <slava> how does it know about join, liftM2, and so on?
23:40:45 <solrize_> i think it's doing something much fancier
23:41:03 <mauke> solrize_: why?
23:41:21 <slava> @pl f (g x) (h y)
23:41:21 <lambdabot> f (g x) (h y)
23:41:39 <slava> @pl \(x,y) -> f (g x) (h y)
23:41:39 <lambdabot> uncurry ((. h) . f . g)
23:41:49 <solrize_> why do i think it's fancier?  i got that impression from one of the haskell.org articles, i forget which
23:42:16 <slava> @pl \x -> f (g x) (h x) (i x)
23:42:16 <adu> I was wondering if this is vaugely correct: (-<) = runKleisli?
23:42:16 <lambdabot> ap (liftM2 f g h) i
23:42:33 <slava> @src ap
23:42:34 <lambdabot> ap = liftM2 id
23:42:48 <solrize_> :t id
23:42:49 <lambdabot> forall a. a -> a
23:42:57 <solrize_> id only takes one arg, how can it be liftm2'd ?
23:43:02 <slava> @src liftM2
23:43:02 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
23:43:11 <solrize_> hmm ok
23:43:11 <mauke> solrize_: try to understand (flip id) first :-)
23:43:17 <solrize_> :t (flip id)
23:43:18 <lambdabot> forall b c. b -> (b -> c) -> c
23:43:27 <solrize_> hmm
23:43:40 <slava> @src flip
23:43:40 <lambdabot> flip f x y = f y x
23:44:03 <slava> @pl \x -> x (f x)
23:44:03 <lambdabot> ap id f
23:44:24 <solrize_> hmm ok
23:44:36 <adu> :t runKleisli
23:44:37 <lambdabot> forall (m :: * -> *) a b. Kleisli m a b -> a -> m b
23:45:01 <solrize_> ((flip id) sqrt) x =
23:45:41 <dolio> adu: Vaguely.
23:45:45 <adu> :t (-<)
23:45:47 <lambdabot> Not in scope: `-<'
23:45:53 <dolio> -< is syntax.
23:46:00 <adu> yeah, i thought so
23:46:34 <crutcher> hi. I've tied myself in knots trying to grok Monads, and I just don't think I can put it off any longer. So let me ask this absurd question: What's a good resource / approach for learning Monads?
23:46:42 <solrize_> hahahahahahahahahahahhaa
23:47:01 <solrize_> there's 8 million monad tutorials in the naked city
23:47:06 <crutcher> yeah, I know.
23:47:16 <crutcher> and the more I read, the more confused I get.
23:47:30 <crutcher> I'm looking for exercises, not tutorials, but I don't seem to find any.
23:47:37 <solrize_> crutcher that's a good point
23:47:53 <solrize_> if you use python i found the "monads as containers" one to be helpful
23:48:08 <crutcher> I'm _extremely_ tired of the nuclear waste metaphor
23:48:13 <solrize_> yeah :)
23:48:20 <solrize_> dons had a good take-off on that one
23:48:25 <adu> crutcher: I've never heard of the nuclear waste metaphor
23:48:36 <solrize_> robots in space suits handling nuclear waste on assembly lines
23:48:41 <solrize_> adu it's from the wikibook
23:48:48 <scook0> as far as tutorials go, I like sigfpe's, and I hear wadler's original paper is good too
23:49:56 <crutcher> read it. it presents like a cooking show. when you read it, you get a series of steps which you are told logically follow.
23:49:59 <slava> i found the source to @pl but it's not clear what's going on because it re-invents a haskell parser and prettyprinter
23:50:01 <crutcher> but not why
23:50:14 <slava> and most of the code seems to be boilerplate
23:50:21 <slava> rules.hs is the interesting part it seems
23:50:29 <crutcher> clearly, people write code using monads, and design new monads.
23:50:43 <crutcher> I'd really like a tutorial on the reasoning processes used
23:50:47 <solrize_> wadler's paper is good for motivating
23:50:53 <solrize_> but doesn't have exercises
23:51:02 <solrize_> bos if you're still around, please put lots of exercises in your book
23:51:25 <solrize_> it's not enough to explain the calculus chain rule by differentating sin(cos(x)) with one or two more examples
23:51:25 <oerjan> @help tell
23:51:25 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
23:51:37 <solrize_> there has to be dozens of exercises that are calculational
23:51:42 <Cale> http://www.haskell.org/haskellwiki/Monads_as_Computation -- this is still rather abstract, but it's my attempt at explaining what monads are really for in programming.
23:51:43 <lambdabot> Title: Monads as computation - HaskellWiki
23:52:01 <solrize_> the one i'm looking for explains the list monad in terms of python lists
23:52:10 <adu> crutcher: which monads have you grok'ed so far?
23:52:32 <crutcher> well, I can use the IO, list, and maybe monads.
23:52:34 <solrize_> yeah, this one i think.  http://lukeplant.me.uk/blog.php?id=1107301643
23:52:35 <lambdabot> Title: Understanding Monads Via Python List Comprehensions
23:52:43 <crutcher> but I don't feel like I understand them.
23:52:51 <adu> crutcher: imho, IO monads are easier to understand than list monads
23:53:01 <glguy> Anyone know if the fix for the Ord instance of Word*'s went into STABLE or just HEAD?
23:53:04 <Cale> (I'd like to think that my monad tutorials are better than most, and the one I just linked to was more a message to the monad tutorial authors than to people learning monads.)
23:53:18 <solrize_> crutcher the other article i found very helpful is http://en.wikibooks.org/wiki/Haskell/Category_theory
23:53:27 <Cale> adu: You're the opposite of me.
23:53:28 <crutcher> this is stupid, but the best I could say is that when I understand a programming concept, it has this shape that fits in my head. and Monads don't have that shape yet.
23:53:37 <Cale> The list monad is very very simple.
23:53:46 <Cale> The IO monad is tremendously complicated.
23:53:47 <solrize_> since it explained how it is that (m a) is a separate copy of the whole type system
23:53:49 <adu> Cale: theres just too many combinatorics happening in list monads
23:54:04 <Cale> and yet, the IO monad is familiar from imperative programming
23:54:08 <Cale> but the list monad isn't
23:54:17 <solrize_> ultimately from looking at it a lot of different ways, there's a kind of unification that takes place
23:54:40 <crutcher> Cale: I'll read your tutorial, don't see any exercises in it though. That would help.
23:55:03 <Cale> crutcher: Okay, are you familiar with data types?
23:55:41 <Cale> crutcher: Consider:  newtype State s a = S (s -> (s,a))
23:55:46 <crutcher> yeah. and parsers, and combinators, and I've been working through Davies book on FP, and I've got a few Payton books on the way
23:55:53 <crutcher> but monads, eh?
23:56:14 <adu> crutcher: ulimately, "Monad" is just an interface, an interface that has at least 3 implementations, one for "Maybe", one for "[]" and one for "IO". To really understand monads, you need to understand each implementation separately, then realise that they could theoretically have the same interface, then accept that they do.
23:56:18 <Cale> crutcher: We're going to think of a value of type State s a, as something which does some work on a state value of type s, as it produces a value of type a
23:56:36 <Cale> crutcher: Implement return and >>= so as to make this into a monad :)
23:57:16 <Cale> There are actually a few choices for how to implement >>=
23:58:43 <crutcher> Cale: I've worked through the type algebra on this multiple times. I've almost got the defs memorized. It just doesn't seem to fit. I'm looking for a set of monads to implement untill it does.
23:58:43 <Cale> The one we want is the one that preserves the illusion that the state is being sequentially updated.
23:59:00 <Cale> Oh, a parsing monad is also really enlightening.
23:59:08 <solrize_> crutcher, try implementing Maybe
23:59:38 <Cale> newtype Parser a = P {runParser :: String -> [(String, a)]}
23:59:58 <crutcher> yeah, I wrote a CPP parser using Parsec
