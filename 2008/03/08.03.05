00:00:07 <joha2> ddarius, siti: just goes to show that I've much to learn. Thanks for your advice
00:00:35 <siti> yeah haskell takes some time to learn but once you have learnt it reasonably well it's very very nice to use :)
00:01:06 <faxathisia> dependent types
00:01:55 <joha2> siti: I'm using lisp a lot, but felt I've to know something about Haskell as well. The concepts are similar, but the Haskell syntax is hard
00:02:25 <siti> ok it's probably much easier coming from a lisp background though
00:02:41 <siti> I came from a fully imperative background
00:03:12 <joha2> siti: yeah, in that case it should take a while before things click into place
00:03:31 <siti> it's not just about the syntax with haskell, that is reasonably easy. it's more about learning the type system and common functions/idioms
00:03:43 <ddarius> joha2: There are a lot of things that are very different between Lisp and Haskell.
00:03:56 <faxathisia> what's the name of ::?
00:04:04 <faxathisia> copula?
00:04:21 <ddarius> faxathisia: It doesn't have an accepted name.  It has some accepted readings.
00:05:50 <xpika> what does the --partial mean in darcs get --partial?
00:06:09 <siti> get only the patches required to construct the repo
00:06:16 <xpika> faxathisia: i call it colon colon
00:06:18 <siti> e.g. you won't have all the history
00:06:26 <faxathisia> xpika: lol
00:06:57 <wagle_home> could call it big colon
00:07:02 <xpika> spaceship zoooom <=>
00:07:09 <wagle_home> err  large colon
00:07:18 <glguy> has type?
00:07:54 <faxathisia> glguy, yeah that's how I read it, I think copula is a fair enough technical name though?
00:09:51 <dolio> Unicode calls it "proportion" apparently.
00:10:11 <faxathisia> I guess that comes from the ratio stuff
00:10:16 <ddarius> faxathisia: For what purpose?
00:10:55 <faxathisia> ddarius, I just saw this proof of induction for natural numbers which was defined using pattern matching
00:11:34 <faxathisia> before I thought you could just desugar any pattern match into the catamorphism call but it seems like that could be false
00:12:52 <faxathisia> so I guess the purpose is to find what the meaning of pattern matching is, but is there some generalization of disjunction elimination which fits?
00:13:34 <ddarius> I was referring to the "copula" stuff, but writing tail in terms of foldr is a bad idea.  However, if you have an initial algebra semantics for a dependent type then Lambek's lemma gives you pattern matching.
00:13:42 <ddarius> faxathisia: Dependent sum elimination.
00:18:07 <faxathisia> Lambek's lemma is something fin category theory?
00:19:23 <ddarius> Yes
00:25:20 <dmwit> Okay, my professor needs to stop using "functional" when he means "working".  I get so excited every time, and then I'm crushed when I realize we aren't going to drop Java on the floor.
00:26:04 * faxathisia did a years worth of Java homework without using any loops, just recursion
00:26:23 <cin> stick it to the man, yeah
00:26:24 <faxathisia> I think I at least can give the marker a headache ..
00:31:34 <olsner> new Cons( ) is enough to make any normal man cry, and any lisper cry of joy
00:31:48 <rethiak> faxathisia: always a great idea to make the person giving scores hate you :)
00:35:17 <faxathisia> http://www.cs.nott.ac.uk/~nxg/Tlca07.hs
00:37:05 * glguy writes all his loops in C and calls out to them via the ffi
00:37:12 <faxathisia> hahaha
00:37:29 <faxathisia> I can imagine someone who dislike recursion doing this
00:38:19 <ddarius> while :: IO Bool -> IO () -> IO ()
00:39:01 <glguy> :t until
00:39:10 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
00:39:11 <glguy> I know it's not the same, but I just remembered to share
00:39:36 <wagle_home> pinskia> http://www.youtube.com/watch?v=JP_3WnJ42kw
00:39:36 <lambdabot> Title: YouTube - Humanity Lobotomy - Second Draft
00:40:00 <dolio> until is underused.
00:40:18 <glguy> until was probably the last function in base I found out about :)
00:40:40 <ddarius> :t showIntAtBase
00:40:45 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
00:41:02 <dons> hmm. the most obscure base functions eh?
00:41:08 <faxathisia> @src showIntAtBase
00:41:08 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
00:41:12 <dons> glguy: how about getTag ?
00:41:23 <quicksilver> :t getTag
00:41:24 <dolio> @type getTag
00:41:25 <lambdabot> Not in scope: `getTag'
00:41:25 <lambdabot> Not in scope: `getTag'
00:41:37 <dons> :t GHC.Base.getTag
00:41:38 <lambdabot> forall a. a -> GHC.Prim.Int#
00:41:57 <faxathisia> > GHC.Base.getTag GHC.Base.getTag
00:41:58 <lambdabot>   Not in scope: `GHC.Base.getTag'
00:42:03 <dolio> Bah, that's borderline cheating. :)
00:42:04 <dons> :t GHC.Base.inline -- another one
00:42:09 <lambdabot> forall a. a -> a
00:42:15 <dons> :t GHC.Base.lazy
00:42:16 <lambdabot> forall a. a -> a
00:42:23 <quicksilver> I don't think that's what glguy meant by base.
00:42:29 <Lemmih> JHC vs. GHC benchmarks: http://repetae.net/computer/jhc/results.html
00:42:30 <lambdabot> Title: nobench: Haskell implementation shootout
00:42:47 <dons> I agree, though, until is (close to) the least used Prelude function
00:43:04 <faxathisia> can't imagine how to use until..
00:43:09 <dons> :t until
00:43:10 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
00:43:26 <quicksilver> > until (<10) (/2) 800
00:43:27 <lambdabot>  6.25
00:43:46 <dons> its an odd one.
00:43:48 <ddarius> It's another under-appreciated unfold
00:44:04 <dons> ah yes, good point.
00:44:07 <quicksilver> it's pretty close to the head . takeWhile p . iterate f
00:44:10 <quicksilver> that you see sometimes
00:44:15 <dolio> People usually seem to go with 'takeWhile p . iterate f' instead.
00:44:20 <glguy> dons: I've added everything but the Storage backend for session variables
00:44:26 <faxathisia> > until ((<10).length) (():) []
00:44:27 <lambdabot>  []
00:44:28 <dons> sweet
00:44:30 <faxathisia> > until ((>10).length) (():) []
00:44:31 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),()]
00:44:33 <dons> "I've written some Erlang and much more Haskell. My take so far is that Erlang is good for teaching you how to fish, Haskell is good for teaching you about procuring food (including fish)."
00:44:36 <glguy> so user-preferences and logins will be supportable
00:44:48 <dolio> Er, dropWhile.
00:45:15 <glguy> > replicate 10 ()
00:45:16 <lambdabot>  [(),(),(),(),(),(),(),(),(),()]
00:45:21 <glguy> > replicate 11 ()
00:45:22 <lambdabot>  [(),(),(),(),(),(),(),(),(),(),()]
00:45:55 <glguy> > until even (`div` 2) 234798234224777
00:45:57 <lambdabot>  117399117112388
00:46:03 <dolio> jhc seems to be quite impressive when it works.
00:46:20 <dons> yeah. i think john should write a paper about it..
00:46:28 <ddarius> Which language is good at giving you a fish?
00:46:54 <dons> something with lots of libraries?
00:46:56 <dolio> Around 400 times faster at 'atom'.
00:47:12 <ddarius> Java
00:47:23 <wagle_home> ruby on rails..  you start with a fish, and then...
00:47:42 <glguy> atom?
00:48:28 <dolio> Huh, according to the source Hugs is 20x faster than GHC at that benchmark.
00:53:37 <RayNbow> http://www.xs4all.nl/~weegen/eelis/geordi/ <-- damn, this site isn't IE friendly... (yeah, I'm a lazy bastard that's usually too lazy to start FF or something :p)
00:53:45 * RayNbow blames the MIME type :p
01:37:36 <kuribas> Does any haskell compiler use partial evaluation as an optimisation?  (For example for deforestation).
01:39:27 <Lemmih> kuribas: Could you be more specific?
01:41:01 <kuribas> For example fusing (map f . map g) into a function using (f. g)
01:41:38 <faxathisia> (map f . map g) => map (f . g) ?
01:41:41 <oerjan> ghc does that, but not with partial evaluation
01:41:42 <quicksilver> kuribas: that's not really partial evaluation.
01:41:46 <quicksilver> kuribas: but yes, it does it.
01:41:51 <quicksilver> via a system of rewriting rules.
01:42:19 <kuribas> quicksilver: Yes, but I mean without rewriting rules, but using partial evaluation.
01:42:38 <kuribas> Using the definition of map.
01:42:50 <quicksilver> the definition of map would not give rise to that fusion.
01:43:01 <faxathisia> kuribas: That's non trivial
01:43:21 <quicksilver> the definition of map would lead the the naive operation, with the intermediate list being constructed.
01:43:26 <quicksilver> @src map
01:43:26 <lambdabot> map _ []     = []
01:43:27 <lambdabot> map f (x:xs) = f x : map f xs
01:43:37 <faxathisia> kuribas: Try to produce a proof that map f . map g = map (f . g), and also, how could the compiler know which one is better?
01:43:38 <quicksilver> ^^ the definition of map forces that extra (:) to actually exist.
01:43:50 <quicksilver> you need a rewrite to get rid of the intermediate (:).
01:44:09 <kuribas> I am looking at a way of using partial evaluation to remove intermediate structures.
01:44:22 <quicksilver> kuribas: GHC does some very, very limited partial evaluation. It will inline functions and substitute "constant cases"
01:44:38 <faxathisia> kuribas, read about supero it can do some of these things
01:44:42 <quicksilver> (case True of True -> x ; False -> y) will compile to just (y)
01:45:15 <Lemmih> quicksilver: Really? (:
01:45:46 <kuribas> quicksilver: Yes, so I am wondering if you use constraints on expressions and partial evaluation, you can get rid of more intermediate expressions.
01:45:47 <Vq^> quicksilver: thats a bit of a surprise :o)
01:46:19 <quicksilver> kuribas: certainly you can. GHC doesn't do anything very sophisticated along those lines.
01:46:44 <quicksilver> Lemmih: well, it doesn't in hugs :) Not all compilers do this optimisation.
01:46:52 <quicksilver> And you need to inline to expose most cases of it.
01:47:04 <quicksilver> mind you, you need to inline to trigger most of ghc's intersting optimisations.
01:47:31 <doserj> quicksilver: I guess Lemmih expected it to compile to x, not to y
01:47:32 <Lemmih> quicksilver: I hope it compiles to 'x' in the compilers that do this optimization.
01:48:07 <oerjan> @quote pedantic
01:48:07 <lambdabot> No quotes match. Are you on drugs?
01:48:17 <quicksilver> oh.
01:48:20 <quicksilver> good point :)
01:48:23 <dolio> @quote qwe1234
01:48:23 <lambdabot> qwe1234 says: i can program in assembly as well as i can program in c++
01:48:32 <kuribas> quicksilver: I am interested to write a partial evaluator that does these kind of optimisations (while limiting the possible exponential growth of code size).
01:48:45 <quicksilver> kuribas: it's a very interesting area of research.
01:48:54 <quicksilver> kuribas:  you might like to read about ndm's supercompiler, supero.
01:49:01 <quicksilver> which is one approach to partial evaluation.
01:49:13 <quicksilver> You might also like to explore jhc, which has a very clever optimiser in some ways.
01:49:35 <kuribas> I see, maybe supero does what I had in mind.
01:54:32 <kuribas> Wouldn't it be easy to add it to ghc?
01:54:41 <faxathisia> kuribas: Do it
01:56:49 <kuribas> Right :)
01:59:05 <quicksilver> kuribas: short answer : no.
01:59:11 <quicksilver> partial evaluation is hard.
01:59:18 <quicksilver> People have spent years and years studying it :)
01:59:38 <quicksilver> I don't mean to say it's impossible. Ndm is basing his phd thesis on supero. But it's definitely not "easy" ;)
02:00:34 <kuribas> What are the difficulties?
02:00:44 <kuribas> Termination?
02:03:21 <quicksilver> That would be one of the key points, yes.
02:03:36 <quicksilver> If your compiler is capable of evaluating arbitrary code at compile-time, then it may not halt.
02:03:39 <ndm_> kuribas: termination is solved, see the supero paper
02:03:45 <ndm_> or rather, kind of solved
02:03:46 <quicksilver> non-halting compilers are normally frowned upon.
02:03:57 <ndm_> (supero didn't solve it, but stole the answer from a previous paper)
02:04:08 <wagle_home> jit isnt frowned upon..  8)
02:04:09 <faxathisia> not halting on a valid program is def. a bug
02:04:54 <ndm_> is jhc terminating?
02:06:25 <ndm_> there are still various problems in supercompilation - the compile times are too high (i have a probably fix), the handling of let is only briefly touched upon (supero is the only work on let), it needs adding to GHC
02:06:43 <ndm_> there is also issues regarding strictness and unboxing, and back end code generation issues
02:06:58 <ndm_> (i have a good three years of work to do on it if anyone has the funding...)
02:08:53 <faxathisia> ndm: Do you think supercompilation is a good idea as a tool in theorem proving too?
02:09:18 <faxathisia> I saw an example of this on rubrication
02:09:18 <ndm_> faxathisia: yesl, without a doubt
02:10:07 <ndm_> faxathisia: theorem proving will require bits from several domains, i'd say that a good theorem prover would have a supercompilation front end and a catch-like back end
02:10:56 <glguy> If the compiler compiler compiles compilers, who compiles compiler compilers?
02:11:07 <kuribas> ndm_: Something I was thinking about is using constraints on expressions to eliminate code or intermediate expressions.  Does you compiler do that too?
02:11:19 <ndm_> kuribas: no
02:14:15 <kuribas> For example in a branch (case f x of {True -> E1; False -> E2}), to keep the information that f x is True in E1.
02:16:45 <quicksilver> kuribas: is that an interesting optimisaton? Are there classes of real programs for which (f x) is likely to occur in E1?
02:16:49 <quicksilver> This is a bit like CSE.
02:17:00 <quicksilver> And CSE is a problem with lazy evaluation, in principle.
02:17:50 <kuribas> quicksilver: Yes, in a recursive step for example.
02:18:52 <quicksilver> CSE can increase sharing.
02:18:58 <quicksilver> And increasing sharing can lead to space leaks.
02:19:09 <quicksilver> (I'm not trying to put you off. Just pointing out some of the complex issues)
02:21:14 <Lemmih> kuribas: I think GHC does something like that already.
02:22:51 <Lemmih> (case f x of a @ {True -> ...; False -> ...}), ghc knows that 'f x' can be replaced by 'a' and that 'a' is constant in both cases.
02:23:40 <kuribas> Lemmih: Hm, interesting.  What about constructors with variables?  Like Cons a b | Nil ?
02:24:42 <Lemmih> (case f x of { Red -> ..; _ -> case f x of {Red -> "known dead case"} })
02:25:37 <Lemmih> kuribas: 'a' would be statically marked as 'Cons a b' in one case and 'Nil' in the other.
02:25:46 <ndm_> kuribas: but case f x is ineffcient already, so would be expanded out
02:26:22 <ndm_> (at least in supercompilation)
02:26:45 <Lemmih> kuribas: A lot of it is described here: http://research.microsoft.com/~simonpj/Papers/inlining/
02:26:45 <lambdabot> Title: Simon Peyton Jones: papers
02:27:50 <kuribas> Lemmih: I'll look into it.
02:35:38 <skorpan> off-topic: is i++ valid C++ if i is double?
02:35:51 <faxathisia> skorpan lol
02:36:25 <dolio> i++ is valid C++ no matter what i is, no?
02:36:44 <skorpan> even bool?
02:36:47 <faxathisia> Frog i;
02:36:54 <skorpan> true++;
02:37:04 <faxathisia> i++; is only valid if you define ++ for that class
02:37:07 <faxathisia> what nonsense
02:37:10 <skorpan> but i guess 1++ isn't valid either.
02:37:19 <Vq^> > succ 0.2
02:37:20 <dolio> Well, true is a constant.
02:37:26 <skorpan> so is 1
02:37:26 <lambdabot>  1.2
02:37:34 <dolio> But i isn't.
02:37:38 <skorpan> indeed.
02:37:50 <skorpan> i'm hungry
02:38:02 <dolio> I suppose it depends on what you mean by valid, too.
02:38:15 <skorpan> valid C++.
02:38:36 <dolio> As faxathisia said, it will probably fail to compile if there's no ++ operator defined for whatever type i is.
02:38:50 <quicksilver> "i" has to be an lvalue.
02:38:53 <skorpan> yes, but what i'm asking is what the _standard_ says about the ++
02:39:01 <quicksilver> (that's why 1++ is not valid)
02:39:16 <kuribas> I++ is syntactic sugar for i += 1
02:39:16 <quicksilver> if "i" is an lvalue, then ++ is valid as long as it's defined for that type.
02:39:23 <quicksilver> kuribas: actually it's not.
02:39:28 <kuribas> no?
02:39:30 <quicksilver> no.
02:39:34 <quicksilver> it's a separate operator.
02:39:41 <wagle_home> will --pedantic cause compiler to obey the standard exactly?
02:39:46 <quicksilver> i++; is allowed to denote "fire nuclear strike at kuribas"
02:39:54 <quicksilver> that's a perfectly sensible semantics in C++.
02:40:04 <kuribas> Lol
02:40:09 <dolio> Is it a different operator that ++i, too? I forget.
02:40:12 <daniel_larsson> For liberal definitions of "sensible" :)
02:40:13 <quicksilver> dolio: yes.
02:40:18 <dolio> Nice.
02:40:24 <quicksilver> ++i and i++ may do entire different things.
02:40:31 <daniel_larsson> They should
02:40:35 <quicksilver> ++i may, to continue the same example, cover dolio with custard.
02:40:39 <skorpan> they always do entirely different things
02:40:46 <quicksilver> not entirely different, no.
02:40:56 <quicksilver> normally they both increment.
02:40:57 <daniel_larsson> No, but different :)
02:41:02 <faxathisia> hehe
02:41:02 <quicksilver> the difference is just in when.
02:41:08 <quicksilver> however they *may* do entirely different things.
02:41:22 <skorpan> they always do entirely different things
02:41:27 <quicksilver> to answer skorpan's first question, yes.
02:41:31 <quicksilver> i++ is valid if i is double.
02:41:36 <wagle_home> ++i will take the picture after, and i++ will take the before picture
02:42:09 <daniel_larsson> wagle_home: not "will", but "should"
02:42:26 <quicksilver> as far as I can recall, you cannot by overloading alter the "after picture before picture" aspect of the behaviour.
02:42:34 <quicksilver> but you certainly can alter what it actually does.
02:43:00 <daniel_larsson> The "after" and "before" is just what your operator function chose to return
02:43:10 <quicksilver> oh, is it?
02:43:13 <quicksilver> ah, then you can.
02:43:19 <dolio> g++ allows ++ on bools.
02:43:37 <faxathisia> :t succ
02:43:48 <wagle_home> i lose my willing suspension of disbelief about language standards when we start talking about nuclear strikes and covering-with-custard..  (mmmm  custard)
02:43:52 <lambdabot> forall a. (Enum a) => a -> a
02:44:01 <quicksilver> daniel_larsson: no, you're wrong.
02:44:05 <quicksilver> daniel_larsson: operator++ is void.
02:44:09 <quicksilver> daniel_larsson: it doesn't return anything.
02:44:17 <daniel_larsson> Hmm, then that is changed
02:44:30 <quicksilver> well maybe the docs I'm reading are wrong.
02:44:33 <daniel_larsson> Or I'm just muddled
02:44:37 <quicksilver> I just took a promising google hit and believed it :)
02:44:50 <ndm_> daniel_larsson: my recollection is that you can't change the ordering
02:44:51 <daniel_larsson> Which is entirely possible :)
02:45:17 <Adamant> wagle_home: you may not use Java in the production of nuclear weapons, while Haskell has no similar restrictions. I think we know what OS evil overlords will choose.
02:45:24 <ndm_> and that in C++ one ordering (post) requires the invokation of the copy constructor
02:45:28 <Adamant> blah, language
02:45:33 <quicksilver> ++i; compiles to (pseudo code) (i.operator++(), return i)
02:45:45 <wagle_home> Adamant, haskell?
02:45:46 <quicksilver> while i++; compiles to (return i, i.operator++(0))
02:46:25 <quicksilver> ndm_: does it use the copy constructor? or does it just schedule the call for after the expression has been used? :)
02:46:29 * quicksilver is sure he doesn't know.
02:46:54 <ndm_> quicksilver: are you suggesting C++ uses lazy evaluation?
02:47:01 <quicksilver> ndm_: no. I'm suggest his:
02:47:03 <faxathisia> good luck to anyone wanting to write correct programs in C++ :S
02:47:04 <ndm_> (it wouldn't surprise me if it was in C++)
02:47:05 <baaba> for fundamental types, it's a "side-effect" which is guaranteed to occur before the next sequence point
02:47:07 <faxathisia> I think they will really need it..
02:47:21 <baaba> for user-defined types, it simply does whatever you define it to do
02:47:25 <quicksilver> callfunction(i++); --> compiles to --> callfunction(i); i.operator++(0);
02:47:33 <wagle_home> wouldnt the OS evil overlords be upset if they didnt know when the forces of freedom would be covered with custard or covered with nuclear strikes?
02:47:42 <quicksilver> ndm_: i.e you could just "put the operator++ call" after the i is used.
02:47:47 <ndm_> reading the C++0x standard proposals scares me a lot - its like C++ but more evil
02:47:48 <quicksilver> instead of having to take a copy of i,
02:48:00 <dolio> Considering i++ on objects is a faux pas among C++ people, I imagine it does copying.
02:48:24 <ndm_> quicksilver: that assumes the correct semantics of copying, i'm not sure if that is allowed in C++
02:48:36 <quicksilver> I'm not sure either.
02:48:45 <quicksilver> I note that callfunction(i) is a copy constructor anyway
02:48:52 <quicksilver> unless that function has reference prototype.
02:48:59 <quicksilver> and I wonder why I stopped using C++ ;)
02:49:40 <ndm_> all i know is that somewhere someone will have written a program that absolutely depends on whatever the answer is
02:50:01 <baaba> that's undefined behavior
02:50:09 <baaba> and compilers will warn, if not give an error
02:50:20 <daniel_larsson> Hmm... http://www.parashift.com/c++-faq-lite/operator-overloading.html#faq-13.14
02:50:22 <lambdabot> Title: [13] Operator overloading &nbsp;Updated!&nbsp;, C++ FAQ Lite, http://tinyurl.com/4kzk3
02:50:22 <quicksilver> baaba: what is?
02:50:22 <baaba> at least modern compilers - for older ones who knows :)
02:50:33 <baaba> using those such that the answer depends on how it works
02:50:43 * wagle_home patents the ++i behavior of his old 486, now a custard making machine
02:50:59 <daniel_larsson> here they return values. Maybe this changed in a recent C++ standard. It was years ago I fiddled with C++
02:51:16 <Igloo> SamB: I'd guess at a few times a day. You could find out by doing some grep etc on the mailing list archive index
02:51:18 <quicksilver> daniel_larsson: yes, you were right.
02:51:19 <daniel_larsson> But I guess we're going slightly off topic :)
02:51:25 <quicksilver> daniel_larsson: I must have been reading old stuff.
02:51:30 <quicksilver> daniel_larsson: the danger of random googling :)
02:51:33 <wagle_home> ... and sets up a RIAA like political machine to thwart anyone who wants to change that behavior
02:51:34 <daniel_larsson> hehe
02:51:41 <ndm> SamB: hello?
02:51:45 <ndm> @seen SamB
02:51:45 <lambdabot> SamB is in #haskell-blah, #perl6, #haskell and #darcs. I last heard SamB speak 5h 52m 45s ago.
02:52:06 <wagle_home> now *I* and going off topic..  language design (C++) seems relevant
02:52:13 <wagle_home> s/and/am
02:54:04 <quicksilver> C++ semantics is quite interesting.
02:54:14 <quicksilver> I like to recall how fragile it is to remind myself how much I prefer haskell :)
02:54:59 <dolio> I don't know, it's usually clearer and more type safe than haskell. :)
02:55:28 <nornagon> @index modify
02:55:28 <lambdabot> Control.Monad.State, Control.Monad.RWS
02:55:42 <nornagon> :t Control.Monad.State.Modify
02:55:45 <nornagon> er.
02:55:45 <lambdabot>     Not in scope: data constructor `Control.Monad.State.Modify'
02:55:47 <nornagon> :t Control.Monad.State.modify
02:55:49 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
03:01:07 <nornagon> how come that function's not mentioned in @doc Control.Monad.State.Lazy?
03:01:24 <nornagon> oh ah, it's in State.Class
03:03:25 <quicksilver> yes, the preferred way to use the MTL monads is via the associated classes
03:03:35 <quicksilver> then you don't need to worry about how 'deeply buried' your transformer is.
03:04:15 <faxathisia> If you wanted to write a type checker for a dependent typed language where would you start?
03:04:22 <oerjan> @hoogle modify
03:04:22 <lambdabot> Control.Monad.State.Class.modify :: MonadState s m => (s -> s) -> m ()
03:04:22 <lambdabot> Data.IORef.modifyIORef :: IORef a -> (a -> a) -> IO ()
03:04:22 <lambdabot> Data.STRef.modifySTRef :: STRef s a -> (a -> a) -> ST s ()
03:04:27 <quicksilver> by reading some of conor's papers
03:04:44 <faxathisia> ok and then?
03:05:06 <quicksilver> do you have a particular language in mind?
03:05:13 <quicksilver> or do you also want to write a new language too?
03:05:28 <faxathisia> yeah I wanted to check COC and then maybe CIC if it worked out
03:05:32 <nornagon> quicksilver: I don't understand what you mean by a deeply buried transformer...
03:05:41 <quicksilver> nornagon: ErrorT StateT IO
03:05:47 <quicksilver> nornagon: StateT ErrorT IO
03:05:50 <nornagon> sure... but why's that relevant?
03:05:50 <quicksilver> nornagon: StateT IO
03:05:53 <faxathisia> I took 6 attempts though without success so I'm wondering where other people would start
03:05:58 <quicksilver> nornagon: well, 'modify' works in all three
03:06:04 <quicksilver> nornagon: that's the point of the class.
03:06:05 <nornagon> oh.
03:06:10 <nornagon> @src modify
03:06:11 <lambdabot> Source not found. My pet ferret can type better than you!
03:06:25 <nornagon> @src Control.Monad.State.modify
03:06:25 <lambdabot> Source not found.
03:06:38 <oerjan>  @src never takes module qualifiers afaik
03:06:46 <nornagon> oh.
03:07:07 <nornagon> anyway, how does modify manage that?! wouldn't you need to know exactly how many times to apply 'lift'?
03:07:09 <oerjan> it just leaks like a sieve, omits big functions, and is outdated.
03:07:24 <quicksilver> nornagon: by having instances for LOTS of cases
03:07:31 <nornagon> ah.
03:07:36 <quicksilver> nornagon: there is a modify instance for StateT M with modify = lift . modify
03:07:39 <quicksilver> erm
03:07:41 <quicksilver> that's not right
03:07:49 <quicksilver> StateT M has a basic definition of modify
03:07:53 <quicksilver> cos you're "at the right level"
03:07:55 <oerjan> there _would_ be, if that wasn't overlapping
03:08:10 <oerjan> it would be a good default
03:08:18 <quicksilver> but then (MonadState m) => FooT m has an instance
03:08:21 <quicksilver> modify = lift . modify
03:08:23 <quicksilver> (basically)
03:08:31 <quicksilver> and that instance is repeated for all sensible FooT
03:08:34 <oerjan> er i mean, not for StateT.  it would be a good default for all the other transformers
03:08:47 <oerjan> oh and modify is not a method
03:08:59 <oerjan> it's built from get and put
03:09:08 <quicksilver> yes, you would wish you could write (MonadState m, MonadTrans t) => MonadState (t m) where modify = lift . modify
03:09:17 <quicksilver> oerjan: ah ok. But that's not the main point :)
03:09:34 <quicksilver> unfortunately you can't do that because the overlaps don't resolve the way you would want them too.
03:09:37 <quicksilver> which is a shame.
03:09:46 <quicksilver> so you need an instance for each FooT instead.
03:10:29 <oerjan> i had an idea the other day - it would have been nice to have instances in class definitions
03:11:06 <oerjan> then you could do things like class MonadTrans t where ... ; instance MonadState m => MonadState (t m) where ...
03:11:28 <oerjan> and it should resolve like defaults
03:12:09 <oerjan> (that instance is withing the first where block, in case that isn't clear)
03:12:13 <oerjan> *within
03:12:38 <oerjan> also then you could have class Arrow a where ... instance Applicative (a b) where ...
03:12:53 <oerjan> and (&&&) would be Applicative, = liftA2 (,)
03:13:14 <quicksilver> oerjan: hmm. that sounds rather interesting.
03:13:22 <oerjan> this sort of assumes class aliases at the bottom
03:13:28 <quicksilver> oerjan: I have a horrible suspicion there is a problem that isn't immediately apparent, though.
03:13:49 <oerjan> probably :/
03:13:57 <quicksilver> certainly people *really* want to be able to write
03:14:04 <quicksilver> instance (Bar a) => Foo a
03:14:11 <quicksilver> that comes up regularly here
03:14:16 <quicksilver> and it never means quite what they want.
03:14:38 <quicksilver> the monadtrans/monadstate issue is just a more fiddly example.
03:14:42 <quicksilver> and higher kinded.
03:14:45 <oerjan> the thing is there are two different kinds of resolutions already supported - the one for instances and the one for class defaults
03:14:49 <quicksilver> yes.
03:15:04 <quicksilver> that's a very good point.
03:15:11 <oerjan> so why not have a variant of the first that behaves like the second
03:15:14 <faxathisia> maybe I'll try LF it should be easier than CoC
03:15:19 <yondalf> @hoogle b -> (a, b) -> (a, b)
03:15:20 <lambdabot> No matches, try a more general search
03:16:01 <yondalf> is there any function such that: fn 1 ("a", 2) == ("a", 1)? i.e. replaces second element of pair
03:16:16 <dolio> @type second . const
03:16:18 <faxathisia> > second (subtract 1) ("a", 2)
03:16:19 <oerjan> > second (const 1) ("a", 2)
03:16:20 <lambdabot> forall b d a. a -> (d, b) -> (d, a)
03:16:21 <lambdabot>  ("a",1)
03:16:21 <lambdabot>  ("a",1)
03:16:33 <yondalf> dolio: thanks
03:16:43 <yondalf> @index second
03:16:43 <lambdabot> Control.Arrow
03:17:32 <dolio> > (fmap . const) 2 ("a", 1)
03:17:36 <lambdabot>  ("a",2)
03:18:29 <quicksilver> it just happens that the functor instance for (,) is in the second parameter.
03:18:45 <quicksilver> Well, it doesn't really "just happen"; it's because that's the only way we can partially apply the type.
03:21:37 <pjd> @djinn c -> (a,b) -> (a,c)
03:21:37 <lambdabot> f a (b, _) = (b, a)
03:22:00 <ndm> @seen dcoutts
03:22:00 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #ghc, #haskell-overflow and #haskell-soc. I don't know when dcoutts last spoke.
03:22:08 <oerjan> @@ @pl @djinn c -> (a,b) -> (a,c)
03:22:08 <lambdabot>  f = (`ap` snd) . (. fst) . (const .) . flip (,)
03:22:12 <quicksilver> heh
03:22:13 <oerjan> eep
03:22:17 <quicksilver> you beat me to it :)
03:22:21 <quicksilver> that's what I was just typing.
03:22:49 <faxathisia> :t ?f . (. ?g)
03:22:56 <lambdabot> forall b a b1 (f :: * -> *). (Functor f, ?g::f a, ?f::f b1 -> b) => (a -> b1) -> b
03:23:01 <faxathisia> :t (?f .) . ?g
03:23:02 <oerjan> @pl \(x,_) -> (x,y)
03:23:02 <lambdabot> flip (,) y . fst
03:23:02 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, ?g::f1 (f a), Functor f, ?f::a -> b) => f1 (f b)
03:23:04 <dolio> Heh.
03:23:34 <dolio> > (+1) . [0..9]
03:23:36 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
03:23:54 <oerjan> faxathisia: evil eldritch beings have replaced . by fmap in lambdabot
03:24:04 <faxathisia> :t ?f . (. ?g .) . ?h
03:24:05 <lambdabot> parse error on input `)'
03:24:05 <oerjan> or maybe it was Cale.
03:24:18 <faxathisia> :t ?f . (. (?g .)) . ?h
03:24:19 <lambdabot> forall b b1 a b2 (f :: * -> *) (f1 :: * -> *). (Functor f1, ?h::f1 (f b2 -> b1), Functor f, ?g::a -> b2, ?f::(f a -> b1) -> b) => f1 b
03:25:08 <oerjan> :t (Prelude..)
03:25:09 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
03:25:11 <pjd> > (*2) . [1..]
03:25:12 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
03:25:23 <pjd> \o/
03:26:00 <faxathisia> @hoogle [a] -> (a -> Bool) -> ([a],[])
03:26:00 <lambdabot> No matches, try a more general search
03:26:01 <faxathisia> @hoogle [a] -> (a -> Bool) -> ([a],[a])
03:26:01 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
03:26:01 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
03:26:01 <lambdabot> Data.List.span :: (a -> Bool) -> [a] -> ([a], [a])
03:26:22 <yondalf> @hoogle Int -> Int -> [a] -> [a]
03:26:22 <lambdabot> No matches, try a more general search
03:26:38 <yondalf> @hoogle (Int, Int) -> [a] -> [a]
03:26:39 <lambdabot> No matches, try a more general search
03:26:47 <oerjan> yondalf: a hunch, use drop and take
03:26:50 <faxathisia> :t const (const id)
03:26:51 <lambdabot> forall a b b1. b1 -> b -> a -> a
03:27:05 <yondalf> oerjan: thanks, there's no more general function?
03:27:20 <oerjan> don't think so
03:27:23 <sstipic> hi
03:27:35 <sstipic> I have one question.
03:27:37 <yondalf> @src [a]
03:27:37 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
03:27:38 <faxathisia> :t (.(.))
03:27:39 <lambdabot> forall b a b1 (f :: * -> *). (Functor f) => ((f a -> f b1) -> b) -> (a -> b1) -> b
03:27:45 <oerjan> @src []
03:27:45 <lambdabot> data [] a = [] | a : [a]
03:27:49 <quicksilver> yondalf: you're after "sublist" ?
03:27:54 <quicksilver> yondalf: if so, take + drop is the way.
03:28:12 <yondalf> quicksilver: yes, "sublist"...okay, take and drop it is then
03:28:22 <sstipic> how can I install cabal package in untarred ghc directory?
03:28:23 <oerjan> sstipic: as they say in #math, don't ask to ask, just ask :)
03:29:04 <sstipic> I don't want to install cabal package on the system
03:29:48 <Lemmih> sstipic: configure with a prefix and then install with --user.
03:29:53 <quicksilver> well, you can install it as a user, rather than globally.
03:29:59 <quicksilver> ah. as Lemmih says.
03:30:14 <sstipic> tnx
03:32:37 <yondalf> @hoogle Int -> [a] -> [[a]]
03:32:37 <lambdabot> No matches, try a more general search
03:32:47 <yondalf> @hoogle groupBy
03:32:47 <lambdabot> Data.List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
03:32:47 <lambdabot> Data.ByteString.groupBy :: (Word8 -> Word8 -> Bool) -> ByteString -> [ByteString]
03:32:47 <lambdabot> Data.ByteString.Char8.groupBy :: (Char -> Char -> Bool) -> ByteString -> [ByteString]
03:33:00 <yondalf> @src groupBy
03:33:00 <lambdabot> groupBy _  []       =  []
03:33:00 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
03:33:00 <lambdabot>     where (ys,zs) = span (eq x) xs
03:33:43 <yondalf> hmm...is there a function to, say, f 2 [1..10] -> [[1,2], [3,4], [5,6], [7,8], [9,10]]?
03:34:34 <faxathisia> chunk
03:34:39 <yondalf> @src chunk
03:34:39 <lambdabot> Source not found. My pet ferret can type better than you!
03:34:50 <yondalf> @hoogle chunk
03:34:52 <lambdabot> Data.ByteString.Lazy.Internal.chunk :: ByteString -> ByteString -> ByteString
03:34:52 <lambdabot> Data.ByteString.Lazy.Internal.Chunk :: ByteString -> ByteString -> ByteString
03:34:52 <lambdabot> Data.ByteString.Lazy.Internal.chunkOverhead :: Int
03:36:07 <quicksilver> yondalf: no.
03:36:16 <quicksilver> yondalf: it is also commonly requested :)
03:36:19 <yondalf> quicksilver: okay, thanks...better write my own then
03:36:22 <oerjan> > let chunk n = takeWhile (not.null) . unfoldr (Just . splitAt n) in chunk 3 ['a'..'z']
03:36:27 <lambdabot>  ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz"]
03:37:03 <quicksilver> > takeWhile (not.null) . map (take 3) . iterate (drop 3) $ ['a'..'z']
03:37:04 <lambdabot>  ["abc","def","ghi","jkl","mno","pqr","stu","vwx","yz"]
03:37:15 <quicksilver> if you don't like unfoldr ;)
03:37:29 <faxathisia> @src unfoldr
03:37:29 <lambdabot> unfoldr f b  = case f b of
03:37:29 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
03:37:29 <lambdabot>    Nothing        -> []
03:37:56 <faxathisia> :t drop
03:37:58 <lambdabot> forall a. Int -> [a] -> [a]
03:38:38 <quicksilver> > map (take 3) . until null (drop 3) $ ['a'..'z']
03:38:38 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
03:39:03 <quicksilver> gah. that's no good :)
03:39:16 <yondalf> @src until
03:39:16 <lambdabot> until p f x | p x       = x
03:39:16 <lambdabot>             | otherwise = until p f (f x)
03:39:24 <quicksilver> I'd quite like there to be a version of unfoldr which never terminates.
03:39:30 <quicksilver> the 'Just' part is annoying.
03:39:41 <quicksilver> don't want to fold my termination condition into the unfoldr.
03:40:10 <oerjan> there might not always be a way to detect it on the result of unfoldr
03:40:12 <pjd> quicksilver: there's the alternate definition of foldr that uses a predicate instead of the Maybe
03:40:20 <yondalf> will anyone be adding chunk to the ghc hierarchical libraries soon or something?
03:40:43 <quicksilver> yondalf: shouldn't think so, since it's so easy to define. But you could make the case to libraries@ if you want :)
03:41:21 <quicksilver> If you do, my preference for a name is "chunksOf"
03:41:28 <quicksilver> chunksOf 5 ['a'..'z']
03:41:36 <faxathisia> should send a grep of the logs though
03:41:44 <faxathisia> because it really is asked for a lot :P
03:41:46 <yondalf> @src last
03:41:46 <lambdabot> last [x]    = x
03:41:46 <lambdabot> last (_:xs) = last xs
03:41:46 <lambdabot> last []     = undefined
03:42:02 <faxathisia> last = head . reverse
03:42:04 <pjd> splitAtEvery ?
03:42:26 <yondalf> @src splitAtEvery
03:42:26 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
03:42:30 <quicksilver> that would be more consistent, yes.
03:42:35 <quicksilver> I still prefer chunksOf :)
03:42:44 <dolio> splitAtEvery is a little long.
03:42:59 <faxathisia> why not just chunks?
03:43:01 <pjd> splitsAt
03:43:21 <yondalf> quicksilver: well, many of the prelude functions are easy to define, but it's convenient to have them e.g. id
03:43:26 <quicksilver> yondalf: you're right.
03:43:33 <quicksilver> it's not a consistent argument.
03:43:43 <quicksilver> you have to draw the line somewhere, it's not remotely obvious where.
03:45:16 <yondalf> @hoogle updateState
03:45:16 <lambdabot> Text.ParserCombinators.Parsec.Prim.updateState :: (st -> st) -> GenParser tok st ()
03:45:22 <faxathisia> http://www.lfcs.inf.ed.ac.uk/reports/91/ECS-LFCS-91-162/ looks interesting
03:45:22 <lambdabot> Title: A Framework for Defining Logics
03:46:09 <cpriester> Hello.
03:46:31 <yondalf> @index get
03:46:31 <lambdabot> Control.Monad.State, Control.Monad.RWS, Graphics.Rendering.OpenGL.GL.StateVar, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT, Text.ParserCombinators.ReadP, Distribution.
03:46:31 <lambdabot> Compat.ReadP, Text.ParserCombinators.ReadPrec, Text.Read
03:47:11 <cpriester> Is there any way to get Data.ByteString lazy-evaluated, so that i can use getContents and mapM_ (putStr . ...)?
03:47:23 <cpriester> It works well, if i use getContents from prelude.
03:47:38 <oerjan> cpriester: Data.ByteString.Lazy
03:47:49 <cpriester> I tried that, but it did not work.
03:47:59 <cpriester> I need to read blockwise input.
03:48:22 <quicksilver> lazy bytestring's getcontents does its IO lazily.
03:48:35 <quicksilver> although it makes its own decision about what one chunk should be.
03:48:37 <yondalf> :t maybe
03:48:40 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:48:45 <quicksilver> maybe you should be more explicit about 'doesn't work' ?
03:49:29 <cpriester> Can i paste code somewhere?
03:49:35 <quicksilver> !hpaste
03:49:40 <quicksilver> @where hpaste
03:49:40 <lambdabot> I know nothing about hpaste.
03:49:46 * quicksilver laughs
03:49:49 <quicksilver> http://hpaste.org/
03:49:49 <cpriester> :)
03:50:26 <hpaste>  cpriester pasted "(no title)" at http://hpaste.org/6122
03:50:32 <cpriester> http://hpaste.org/6122
03:50:33 <cpriester> Ok.
03:50:41 <cpriester> This one should read block for block.
03:50:45 <doserj> @paste is the magic word...
03:50:45 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:50:53 <quicksilver> ;)
03:50:59 <cpriester> And not wait for the whole input.
03:51:08 <yondalf> @hoogle Int -> m a -> m [a]
03:51:08 <lambdabot> No matches, try a more general search
03:51:20 <quicksilver> cpriester: well, it waits for as much input as lazy bytestring wants to wait for.
03:51:34 <quicksilver> cpriester: lazy bytestring doesn't do nonblocking IO, per se.
03:51:38 <quicksilver> it has a fixed chunksize.
03:51:45 <quicksilver> I'm not sure what, offhand. 8k?
03:52:00 <quicksilver> hmm. That's not very clear. lazy bytestring can have chunks of any size.
03:52:01 <yondalf> :t replicate
03:52:03 <lambdabot> forall a. Int -> a -> [a]
03:52:12 <quicksilver> However lazy bytestring getContents makes a chunk size decision for you.
03:52:16 <quicksilver> and uses blocking IO.
03:52:28 <quicksilver> it won't "return quickly" on a partial read.
03:53:32 <cin> free haskell web hosting would kick ass
03:53:43 <DukeDave> Okay guys, it's my first chance to get Haskell into my new job... Task involves processing a large data set, currently stored in a text file.
03:53:46 <DukeDave> Any suggested reading?
03:54:02 <byorgey> DukeDave: what kind of processing?
03:54:05 <yondalf> DukeDave: parsec, if you need parsing
03:54:24 <DukeDave> Mm, more aggregation
03:54:36 <quicksilver> I'm not sure there is specially anything to read
03:54:40 <quicksilver> it "sounds" like simple list processing.
03:54:47 <quicksilver> mind you, you haven't told us much about it :)
03:55:10 <DukeDave> quicksilver: Yes, I'm just at the start myself so you know as much as me ;)
03:55:39 <cpriester> Hm, i tried redirection from a fifo to stdin, and the program exists, after writing a word to that fifo? is that correct?
03:55:44 <DukeDave> So, I always see people discussing bytestrings in here, they're.. faster ?
03:56:25 <matthew_-> DukeDave: they're a different thing from String
03:56:52 <cpriester> I think, it should read, until the fifo is destroyed.
03:56:53 <matthew_-> but if you need speed and ByteString does what you want, then yes, they will be faster than just using String
03:57:40 <byorgey> DukeDave: ByteStrings store and manipulate strings as actual byte arrays, rather than a list of Char.
04:00:44 <smg> hi :)
04:00:53 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6124
04:01:30 <smg> strange thing happend, i inlined my fibonacci function and it had better performance :]
04:01:30 <cpriester> Is there a way to modify the chunk size of getContents?
04:01:36 <smg> even it's recursive
04:02:13 <ndm> smg: why is that a surprise?
04:02:37 <ndm> smg: GHC won't inline recursive functions, but sometimes there is a benefit from it
04:03:02 <quicksilver> cpriester: I don't think so, no. I don't think you should be using lazy IO for your task.
04:03:20 <cpriester> Why not?
04:03:27 <quicksilver> if you want careful nonBlocking IO then you should use nonblocking IO specifically.
04:03:53 <quicksilver> lazy IO is semantically broken and this is highlighted when you try to tweak its behaviour in detail.
04:04:19 <quicksilver> it is only suitable for "unix pipe like" behaviour where you only expect weak guarantees on how/when the data arrives.
04:04:42 <smg> ndm: yeah sometimes but in general it should be stupid to inline recursive functions, hehe
04:05:21 <DRMacIver> Is that really true? Inlining a few steps of the recursion seems as likely to be a good idea as inlining ever is.
04:05:33 <cpriester> Well, it didnt behave like i thought, in my unix pipe. The program terminated, although the pipe still exists.
04:06:08 <smg> DRMacIver: but i inline the whole function :)
04:06:09 <ndm> DRMacIver: its stupid to do because you end up non-terminating the compiler, but in general its a good idea and is essentially loop unrolling
04:06:16 <cpriester> i did "mkfifo test" "./main < test" and in another shell "echo hello > test"
04:06:23 <ndm> i.e. the exp3_8 benchmark goes 4 times faster if you inline it 2 steps
04:06:29 <DRMacIver> ndm: Hm. Why do you end up non-terminating the compiler?
04:06:32 <smg> ndm: ah so inlining means -funroll-loops?
04:06:41 <cpriester> Why did the Program terminate after reading "hello"?
04:06:44 <DRMacIver> smg: Hm. How do you mean?
04:06:44 <smg> i thought otherwise :/
04:06:48 <ndm> smg: in the recursive case they are similar
04:07:11 <ndm> DRMacIver: you don't necessarily, but the design of GHC is such that it would
04:07:16 <DRMacIver> Oh, ok.
04:07:21 <smg> ndm: hehe i just was surprised because i expected that the inline would make it slower ;-)
04:07:31 * DRMacIver knows nothing about the design of GHC so will take that on faith. :)
04:07:41 <ndm> smg: very rarely would that happen, very often it will go faster
04:07:54 <ndm> DRMacIver: read the JFP paper on GHC inlining, its all in there, in considerable detail
04:08:01 <ndm> (including how to get GHC to non-terminate)
04:08:33 <smg> hehe
04:08:43 <smg> ndm: wow cool then the wiki was wrong
04:09:00 <DRMacIver> ndm: My compiler-fu is really weak. :)
04:09:10 <ndm> smg: which bit of the wiki?
04:09:37 <smg> The INLINE pragma can be used for this purpose; but not for recursive functions, since inlining them forever would obviously be a bad idea.
04:09:49 <smg> Performance/GHC
04:09:53 <cpriester> quicksilver: what did you mean with semantically broken?
04:10:27 <pejo> ndm, is that the "Secrets of the ghc inliner .."-paper?
04:10:35 <smg> ndm: i will inspect the code with --ddump-simpl :)
04:10:38 <ndm> pejo: yep
04:10:44 <quicksilver> cpriester: it conceals IO within pure values, which breaks the point of pure values.
04:10:48 <smg> btw in general ($!) is a good idea?
04:10:55 <smg> i couldn't figure out of the wiki
04:11:01 <quicksilver> cpriester: your mkfifi symptom just shows that you don't understand mkfifo, I think.
04:11:12 <ndm> smg: inlining recursive functions? probably not worth it - only if you have a severe bottle neck
04:11:30 <quicksilver> cpriester: when the writer one end closes, the session is over.
04:11:52 <smg> ndm: hehe i see
04:11:59 <pjd> cpriester: imagine a file changes, while you read it with lazy I/O
04:12:40 <ndm> smg: its not something that many people have worked on, it is possibly a good idea, but no one knows the details
04:12:44 <pjd> you get inconsistent results, based on when exactly the reads are evaluated
04:13:10 <pjd> the reading is a side effect breaking referential transparency
04:13:38 <smg> ndm: i guess the optimize flags of ghc will be enough?
04:13:54 <smg> ndm: because all that "hand" optimization is a bit tricky
04:14:12 <ndm> smg: yes
04:15:09 <smg> ndm: i know now the basics of hand optimization but i guess the compiler will do a better job in general, but INLINE, NOINLINE, and UNPACK pragma are good ;-)
04:15:31 <ndm> smg: i never even bother with -O2, performance never matters enough to me
04:15:48 <smg> ndm: :)
04:16:23 <smg> -O2 -funfolding-use-threshold=16 -optc-O3 -optc-ffast-math -funbox-strict
04:17:03 <smg> Data.ByteString and newtype performs also better than normal Strings and data
04:18:39 <smg> ndm: maybe i should switch to channel #ghc :]
04:19:00 <ndm> smg: not really, thats more for developing GHC
04:19:06 <smg> ah okay
04:20:09 <smg> premature optimization is the root of all evil :)
04:20:19 <smg> but nevertheless optimization is interesting, hehe
04:22:08 <smg> real	0m0.596s -> after optimization
04:22:22 <smg> real	0m1.296s -> before
04:23:52 <yondalf> iterate (+1) 1
04:23:57 <yondalf> > iterate (+1) 1
04:24:03 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
04:24:40 <cpriester> what about using hGet? Would that do the thing?
04:25:06 <cpriester> There is no real describtion, but it takes an Int. Is that the amount of Bytes to read?
04:25:36 <quicksilver> :t hGet
04:25:39 <lambdabot> Not in scope: `hGet'
04:25:47 <quicksilver> the bytestring hGet, you mean?
04:25:53 <quicksilver> yes, that would solve it.
04:26:04 <quicksilver> not the mkfifo/broken pipe problem though :)
04:26:06 <cpriester> Ok. Then i will use it. Thank you.
04:26:10 <quicksilver> that's just how fifos work.
04:26:48 <cpriester> Yes, i saw it. I tried with a C prog. But when do they get eof? it is not described in the manpage.
04:28:06 <quicksilver> they get sigpipe I believe
04:28:13 <quicksilver> I could be wrong though.
04:28:24 <quicksilver> I've not used them in my own programs.
04:28:32 <yondalf> @src fromJust
04:28:32 <lambdabot> fromJust Nothing  = undefined
04:28:32 <lambdabot> fromJust (Just x) = x
04:28:36 <cpriester> sigpipe would be mentioned on stderr, wouldnt it?
04:29:31 <cin> sigpipe causes a program to end, iirc
04:29:54 <pjd> fromJust = maybe undefined id
04:30:03 <quicksilver> if you launch a program from your shell you shell might choose to remark on the exit code
04:30:11 <quicksilver> (which would indicate sigpipe)
04:30:17 <quicksilver> but other than that, no.
04:30:20 <cpriester> Well, it is not terminated in my case; so it does not get sigpipe.
04:30:30 <quicksilver> I thought you said it was terminated?
04:30:39 <quicksilver> 12:06 < cpriester> Why did the Program terminate after reading "hello"?
04:30:56 <pjd> that sounds like it needs a punchline
04:31:05 <cpriester> :)
04:31:38 <cin> "To get to the other side"
04:31:39 <cpriester> in tthe C prog: while (cin >> str) cout << str; cout << "end!\n";
04:31:47 <cpriester> And you will see, that "end" is printed.
04:32:01 <cin> that is c++
04:32:08 <cpriester> Yes, i know.
04:32:42 <cpriester> But the + lies so far away on my keyboard :)
04:32:54 <cin> yes, why bother
04:35:08 <cpriester> But you can see, that the program is not aborted.
04:41:13 <quicksilver> cpriester: ah ok. It's just eof then.
04:42:51 <cpriester> Yes, but when exactly will the process receive eof?
04:43:15 <cpriester> When all procesees finished writing to that pipe?
04:43:20 <quicksilver> not all, no.
04:43:23 <quicksilver> just one.
04:43:26 <quicksilver> afaik
04:43:33 <quicksilver> I don't think fifos are many to many
04:43:36 <quicksilver> I think they're one to one
04:43:39 <quicksilver> maybe I misunderstood them.
04:44:36 <jacobian_> I'm wondering stylistically about using zip without option type.  I've been bitten a few times checking list equality over a zip.  Checking the length duplicates a test, it seems more natural for zip to have an option type.
04:44:59 <cpriester> Ah, you are right. If i try to read with more processes, it fails.
04:45:25 <smg> btw good morning quicksilver
04:46:40 <haraldk> I have just made an unhappy discovery
04:46:57 <haraldk> that O'caml isn't Haskell
04:47:29 * oerjan gasps
04:47:34 <smg> haraldk: lol
04:47:44 <haraldk> no really
04:47:48 <smg> who needs O'caml?
04:48:14 <smg> when haskell and erlang exist? :)
04:48:22 <haraldk> I got to work on an inherited ocaml program recently, since I'm the only one who has done functional programming on the house
04:48:27 <oerjan> jacobian_: we've been dabbling with zipWithDefaults here occasionally
04:49:28 <quicksilver> ocaml definitely has its points when what you want is a strict functional language which produces fast code.
04:49:33 <quicksilver> but some little details about it annoy me
04:49:38 <quicksilver> constructors not being functions, for one.
04:49:44 <quicksilver> the value restriction for another.
04:49:47 <haraldk> Yes, I found out that too :-)
04:50:15 <haraldk> but my main gripe is the lack of a big, well-documented standard library
04:50:18 <pjd> what's the value restriction, in one sentence, in Haskell terms?
04:50:26 <haraldk> do all Ocaml-programmers roll their own?
04:50:38 <quicksilver> pjd: foo = bar . baz
04:50:43 <quicksilver> pjd: is illegal in ML.
04:50:49 <slarba> hmm. what's the best way to do the following: I want to express DHCP dialog as a function so that when that function needs an UDP message, the continuation is saved and when next message arrives, the continuation is restarted
04:50:54 <quicksilver> you have to write "foo x = (bar . baz) x"
04:51:17 <slarba> like web continuations a la plt scheme webserver
04:51:24 <pjd> quicksilver: "values can not be defined to functions"?
04:51:44 <oerjan> pjd: actually it just prevents polymorphism
04:51:48 <haraldk> or foo = function x -> bar . baz x ?
04:52:08 <quicksilver> oerjan: ah, is it only a problem in the case that foo is polymorphic?
04:52:13 <quicksilver> ok.
04:52:16 <quicksilver> quite often they are, though.
04:52:22 <quicksilver> especially when you're working with combinators.
04:52:30 <quicksilver> it really bites you when you try to define parser combinators.
04:52:46 <ceibe> hi, someone uses HughesPJ pretty-printer?
04:52:46 <lambdabot> ceibe: You have 1 new message. '/msg lambdabot @messages' to read it.
04:53:17 <haraldk> I realise it's the wrong channel, but do anyone know of a Ocaml variant of python's range function? like, [n..m] only eager?
04:53:17 <slarba> nextMessage <- callCC $ \cc -> save cc here and return immediately
04:53:24 <oerjan> foo is monomorphic unless the right side of foo = ... is of one of the recognized syntactic forms that cannot have side effects when evaluated
04:53:40 <slarba> but the problem is that callCC must return the message
04:53:54 <oerjan> quicksilver: it's to prevent the ML equivalent of unsafePerformIO type unsafety
04:54:21 <quicksilver> ah, now I understand.
04:54:25 <jacobian_> when do you need unsafePerformIO?
04:54:29 <quicksilver> Interesting. I never understod the problem properly.
04:54:29 <pjd> so the value restriction is kind of a wider version of the monomorphism restriction?
04:54:37 <quicksilver> it's closely related, yes.
04:55:01 <quicksilver> although as oerjan has just explained there is a much better "reason" for it in ML
04:55:08 <quicksilver> since expressions can have side effects.
04:55:48 <pjd> in that case, why are monomorphic expressions allowed?
04:55:53 <pjd> can't they have side effects too?
04:56:04 <jacobian_>     val r = ref(fn x => x);
04:56:04 <jacobian_>     r := (fn x => x+1);
04:56:04 <jacobian_>     !r true;
04:56:27 <jacobian_> That's the simplest example I know of why we need the value restriction
04:57:12 <oerjan> jacobian_: and that's essentially equivalent to the unsafePerformIO example
04:57:37 <jacobian_> in the presence of references the meaning of the type variable changes by context in such a way that you can't prevent unsafe access to memory if you don't restrict to monomorphic expressions.
04:57:52 <smg> it snows!
04:57:53 <smg> :)
04:58:34 <oerjan> pjd: side effects + careless polymorphism allows you to read and set a mutable variable at different types, breaking type safety
04:59:19 <pjd> ah, ok
04:59:29 <pjd> zany
05:02:44 <quicksilver> exercise to the reader: in the absence of reference types, but in the presence of side-effects and ML polymorphism, do you stil need the value restriction?
05:05:54 <wy> morning!
05:11:15 <pjd> what would ".depend-BASE: openFile: resource busy (file is locked)" mean while building GHC?
05:12:28 <pjd> while doing: ../compiler/stage1/ghc-inplace -M -optdep-f -optdep.depend-BASE  -osuf o -I../includes [...]
05:13:49 <DukeDave> In ghci can I set :e load the last edited file in the case that I don't pass any files?
05:17:37 <Saizan> there's :r that reloads the last loaded file
05:18:30 <DukeDave> I'd like to reopen the last edited file (in the editor specified with :set editor)
05:19:28 <ski> quicksilver : how do you mean ? .. like "val set_global : 'a -> unit; val get_global : unit -> 'a" ?
05:19:49 <ski> (quicksilver : or what kind of side-effects did you had in mind ?)
05:22:33 <Larose> How can I declare "foo", a type, that could take any integer value between 5 and 10 ?
05:23:52 <Saizan> Larose: not so easily, but maybe you want an enum? data Foo = A | B | C | D | E deriving (Enum)
05:24:05 <Deewiant> data Foo = Five|Six|Seven|Eight|Nine|Ten
05:24:13 <matthew_-> can we extend foo@ syntax to the type level please
05:24:14 <matthew_-> ?
05:24:30 <matthew_-> It's not pleasant having to endless duplicate the same types...
05:24:36 <Larose> But if I want between 10 and 1000 for example, is there another way than typing each number ?
05:24:36 <idnar> I wasn't aware there was pattern matching on types
05:25:04 <Eelis> RayNbow: get a modern browser :)
05:25:10 <Saizan> matthew_-: can't you do something with "type"?
05:25:37 <matthew_-> idnar: eg instance Foo (Cons x (Cons y Nil)) (Cons x (Cons y Nil)) where ...
05:25:56 <matthew_-> would be nicer as instance Foo z@(Cons x (Cons y Nil)) z where ...
05:26:40 <Eelis> gwern: i'm reluctant to put geordi on hackage, because (1) installing geordi is a real chore (because it involves setting up a chroot for gcc to compile in); (2) it's such an extremely specialized application, it doesn't really make much sense as a library; (3) i like just pushing patches without having to worry about version numbers (geordi has no version number)
05:26:43 <matthew_-> Saizan: I'm not sure how type aliases would help here
05:27:24 <dolio> type TwoList x y = Cons x (Cons y Nil)
05:27:35 <matthew_-> yeah, but it's still not as nice
05:27:54 <Eelis> gwern: i'm glad to hear the "darcs is not yet aware of executability" is not (or no longer) the case. i'll make use of that, thanks.
05:28:04 <Deewiant> Larose: not AFAIK, just use an Int and make sure it's within the constraints on input/output or something
05:28:48 <Larose> Deewiant: Yes, I think that will be my solution
05:29:05 <Saizan> Larose: you can use a newtype without exporting the constructor and provide only a function :: Int -> YourNewtype that checks the range
05:29:59 <Larose> Saizan: Ok, I'll check this solution too, thanks!
05:31:12 <Thomas2_> matthew_-: eww @ haskell embedding of dependant types
05:31:45 <matthew_-> it's not dependant types
05:33:30 <Thomas2_> you have to admit, that's what it looks liek
05:34:08 <Thomas2_> I know you can't actually embed dependant types in Haskell, but if you try, you end up with something that looks an awful lot like what you have
05:34:10 <matthew_-> nope. I don't see any values
05:34:14 <matthew_-> I only see types
05:34:51 <Thomas2_> you have an extremely literal mind
05:36:21 <matthew_-> Thomas2_: possibly. But what I'm proposing here is simply additional syntax. It doesn't alter the power of the type system nor require any modifications to the type system at all. It's just syntactic convenience
05:38:26 <Thomas2_> matthew_-: oh, sure, I know.
05:38:56 <shapr> @yow !
05:38:56 <lambdabot> Where does it go when you flush?
05:39:25 <shapr> radix: You called?
05:39:32 <Thomas2_> i'm not offended by that, I just don't understand the fascination building term-like types so that you can do dependant-like typing tricks in haskell
05:41:41 <matthew_-> Thomas2_: the haskell type system is incredably powerful. It's useful to exploit it.
05:41:54 * matthew_- groans at his inability to spell
05:43:12 <Thomas2_> i'm wondering whether i've been misspelling "dependant" the whole time
05:43:13 <Thomas2_> ah well
05:43:52 <matthew_-> seems to be a latin vs french issue
05:45:41 <smg> $ is lazy and $! is non-lazy? True || FalsE?
05:46:28 <shepheb> smg: to be fully pedantic, $ is non-strict, and $! is strict. but you're right.
05:46:45 <smg> oh
05:46:48 <shepheb> oh, and $! is only strict on the right
05:47:01 <smg> shepheb: thank you
05:47:03 <shepheb> @ src ($!)
05:47:08 <shepheb> @src ($!)
05:47:08 <lambdabot> Source not found. :(
05:47:23 <vincenz> @src ($$$)
05:47:23 <lambdabot> Source not found. stty: unknown mode: doofus
05:47:33 <smg> @type ($!)
05:47:37 <lambdabot> forall a b. (a -> b) -> a -> b
05:47:37 <smg> @type ($)
05:47:38 <lambdabot> forall a b. (a -> b) -> a -> b
05:48:13 <shepheb> can \bot have a race condition with that sort of thing?
05:51:22 <smg> shepheb: btw i should prefer $! if on right hand side there is a function? otherwise no $!?
05:52:04 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6125
05:52:11 <shepheb> smg: you generally want $. using strict arguments to functions and $! is more of a performance tuning thing.
05:53:00 <smg> shepheb: yeah :)
05:54:07 <georgw> Ok... another newbie question: How do I wrie a proper output function? Say I want to output a custom data structure. Do I write a function that does lots of prints? Or should I write a fuction that returns a string and use it in conjunction with print? Also, is it possible to override the default behavior of "show"? I.e. instead of "deriving Show" can I say how a show to that data type should behave differently?
05:55:13 <Lemmih> georgw: Write a custom pretty-printing function.
05:55:28 <Eelis> gwern: regarding (2), note that geordi is really extremely C++-oriented. the vast majority of the code is things like gcc error filters, a nice C++ prelude, convenient C++-like request syntax, et cetera. in addition, the actual supervisor makes all kind of assumptions about gcc behavior; it definitely is _not_ a general purpose supervisor.
05:56:01 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6126
05:56:09 <shepheb> georgw: you can definitely define instance Show A where ... for your type.
05:56:15 <Saizan> georgw: bettwer to write a function that returns a string and use putStr separaterly, it's also more reusable that way
05:58:15 <georgw> Thank you. :-) Trying it now. :-)
06:00:01 <smg> i understood monads, haha.
06:01:04 <cpriester> quicksilver: I now tried to use hGet, but it still waits for the whole input. Is that possible?
06:01:10 <SamB> it took me a while to stop trying to figure out what monads *are*
06:01:10 <lambdabot> SamB: You have 1 new message. '/msg lambdabot @messages' to read it.
06:03:44 <shapr> @quote
06:03:45 <lambdabot> monochrom says: Monad theory is abstract common sense.
06:03:50 <shapr> Yay!
06:03:52 <SamB> @tell ndm hmm, sorry... but you also commented it out wrong in the crontab
06:03:52 <lambdabot> Consider it noted.
06:04:01 <SamB> @tell ndm I fixed that
06:04:01 <lambdabot> Consider it noted.
06:04:41 <SamB> @tell ndm either that or nano is going crazy...
06:04:42 <lambdabot> Consider it noted.
06:05:16 <shapr> @quote ndm
06:05:16 <lambdabot> ndm says: This was not said by me
06:07:11 <SamB> <lambdabot> ndm said 3h 8m 40s ago: you messed it up somehow - i'm now getting cron reports for GHC very regularly!
06:07:32 * SamB tried to mirror the GHC repository in hashed format
06:08:34 <SamB> ... using ndm's account on darcs.h.o
06:10:11 <georgw> Hmm... I start liking this language. :-)
06:10:36 <smg> georgw: when did you started?
06:10:43 <shapr> I started liking Haskell too.
06:10:56 <shapr> @quote
06:10:56 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
06:10:58 <smg> btw: MonadPlus is nothing more than monads with mplus and mzero?
06:10:59 <shapr> aww
06:11:05 <ivan_> hi, is there any standard lib in haskell for polynomial computation?
06:11:42 <georgw> Well, I looked at Haskell briefly a year ago and found it very interesting. Now I have an assignment in bio-inspiered optimization and thought I'd take the chance on the "Choose a programming language" part.
06:12:18 <georgw> So right now the challenge is to climb the learning curve fast enough to meet the deadlines. ;-)
06:12:23 <SamB> georgw: well... I'm not sure if it's a good idea to use haskell for an assignment like that.... how long until it is due?
06:12:31 <ivan_> georgw: why not use matlab?
06:12:59 <georgw> Due Friday.
06:13:22 <ivan_> hi, is there any standard lib in haskell for polynomial computation?
06:13:28 <georgw> But it's a very simple knapsack problem, would take half an hour do code up in C.
06:13:57 <ivan_> georgw: well then haskell is fine =)
06:14:07 <idnar> @vixen who missed me?
06:14:07 <lambdabot> i dunno, who?
06:14:12 <hpaste>  Larose pasted "Modifying without updating everything?" at http://hpaste.org/6129
06:14:15 <georgw> And without a challenge I probably would not cough up the time to really understand it. ;-)
06:15:02 <georgw> Ah, by the way, especially for the knapsack stuff the stack might be a problem, right? Do I have to be careful how to structure the recursion? I read something about CPS, will I need that?
06:15:06 <Baughn> @src replicate
06:15:06 <lambdabot> replicate n x = take n (repeat x)
06:15:55 <SamB> what exactly is a knapsack problem?
06:15:56 <glen_quagmire> Larose: you're not updating name there.
06:16:06 <Baughn> georgw: The haskell memory manager is /usually/ sufficiently smart. When it isn't, the reasons are hard to understand. I'm not helping, am I?
06:16:08 <SamB> is it like advent on the ICFP two summers ago?
06:16:15 <georgw> http://en.wikipedia.org/wiki/Knapsack_problem
06:16:35 <SamB> Baughn: what does that have to do with stack smashing?
06:16:43 <georgw> combinatorial optimization.
06:16:48 <Larose> glen_quagmire: But I'm force to get it and set it, I would like to don't care about the name and justs modifying the balance
06:17:28 <Saizan> Larose: deposit p m = p{ balance = ((balance p) + m) }
06:17:31 <Baughn> SamB: Everything, if you for example expect things like 'sort (take 100000 randomNumbers)' to work
06:18:06 <SamB> georgw: what? bricks with money in them?
06:18:25 <Larose> Saizan: thanks!
06:18:39 <Baughn> That the random number generator's numbers depend on the ones before them makes perfect sense. That sort would start with the /last/ one - perhaps not so much.
06:19:01 <georgw> Baughn: As an engineer I have gotten used to not understand stuff. ;-)
06:19:24 <georgw> SamB: Yup. CS people use bricks to store their money.
06:19:32 <ivan_> SamB: knapsack is if u have a list of [(value,weight)] and u want to put the elements into a bag of size W and u want to maximaize the value in the bag, how should u choose the elements
06:19:43 <SamB> georgw: never heard of it before!
06:19:58 <SamB> ivan_: yeah, the wikipedia illustration made that clear ;-)
06:20:04 <ivan_> =)
06:20:42 <SamB> it's got a backpack that says "15 kg" and a few bricks with dollar amounts and weights on them ;-)
06:20:43 <georgw> SamB: It's quite a standard problem. Much like the dining philosophers.
06:21:12 <SamB> now why they use dollar amounts and metric weights...
06:22:40 <SamB> georgw: so how many bricks do you have to choose from?
06:23:14 <georgw> SamB: n. ;-)
06:23:30 <SamB> n!
06:23:38 <SamB> oh wait, no, that's a lot bigger than n
06:23:41 <georgw> SamB: for illustration we have examples for n = 4, 8, 12, 16, 100.
06:24:00 <glen_quagmire> you have to choose combinatio of items to maximize profit
06:24:06 <ivan_> try to to this with a set of 100000 elements =)
06:24:17 <georgw> SamB: And for n = 100 it would take quite some time to try out all combinations, hence random methods.
06:24:31 <ivan_> georgw: u can use dynamic programming
06:24:41 <smg> > let py = [1..] >>= \x -> [x..] >>= \y -> [y..] >>= \z -> guard(x^2+y^2==z^2) >>= \_ -> return (x,y,z)
06:24:41 <lambdabot>  Parse error at end of input
06:24:44 <SamB> oh, I love dynamic programming
06:25:24 <shapr> Me too!
06:25:26 <Deewiant> > let py = [1..] >>= \x -> [x..] >>= \y -> [y..] >>= \z -> guard(x^2+y^2==z^2) >>= \_ -> return (x,y,z) in take 10 py
06:25:28 <shapr> It's DYNAMIC!
06:25:31 <lambdabot> Terminated
06:25:45 <SamB> it's much more fun than using a dynamic programming language ;-P
06:25:52 <Deewiant> smg: fix your code :-)
06:26:02 <georgw> ivan_: Used that once for ACM programming contest problems and liked it. :-)
06:26:11 <shapr> ivan_: Isn't there an easy solution to the knapsack algorithm?
06:26:31 <SamB> anyway, it's really easy in Haskell...
06:26:33 <smg> Deewiant: hehe just unsugaring the list comprehension
06:26:36 <ivan_> hmmm dunno, think knapsck is NP problem or am i wrong?
06:26:40 <Toxaris> georgw: do you search the optimal solution or just a good solution?
06:26:59 <glen_quagmire> knapsack has no deterministic polynomial solution yet
06:26:59 <smg> > findPythagorasTriple = [ (x, y, z) | z <- [1..], x <- [1..z], y <- [x..z], x^2 + y^2 == z^2 ]
06:26:59 <lambdabot>  Parse error at "=" (column 22)
06:27:18 <explisixjelly> let's check out that list monad thing.
06:27:26 <smg> > let findPythagorasTriple = [ (x, y, z) | z <- [1..], x <- [1..z], y <- [x..z], x^2 + y^2 == z^2 ] in (take 10 $ findPythagorasTriple)
06:27:26 <georgw> Toxaris: well, depends on the problem size and algorithm. Usually good is good enough and that's where you can find interesting efficient solutions.
06:27:26 <lambdabot>  [(3,4,5),(6,8,10),(5,12,13),(9,12,15),(8,15,17),(12,16,20),(7,24,25),(15,20,...
06:27:30 <drigz> is anyone here using the latest .dmg ghc binary on os x?
06:27:30 <ivan_> a good solution is just to sort the list with highest weight first and take =)
06:27:40 <explisixjelly> I'm already a heavy user of State monads and Error monads and the like, but the List Monad...
06:27:56 <Toxaris> i would consider the DP solution to be "easy". shouldn't be more then, say, three lines in Haskell
06:28:02 <SamB> ivan_: highest WEIGHT first?
06:28:07 <georgw> ivan_: greedy algorithm... grab by value.
06:28:09 <glen_quagmire> i pass everything around as arguments. and never use monad except putStrLn
06:28:34 <Deewiant> @undo findPythagorasTriple = [ (x, y, z) | z <- [1..], x <- [1..z], y <- [x..z], x^2 + y^2 == z^2 ]
06:28:34 <lambdabot> findPythagorasTriple = concatMap (\ z -> concatMap (\ x -> concatMap (\ y -> if x ^ 2 + y ^ 2 == z ^ 2 then [(x, y, z)] else []) [x .. z]) [1 .. z]) [1 ..]
06:28:35 <ivan_> georgw: yea thats right wrong by my, the ratio of course
06:28:53 <georgw> So, I need a coffee. Thanks for the input. Getting an answer here usually spares me an hour of searching. :-)
06:28:55 <Deewiant> smg: ^ now just replace concatMap with (>>=) :-)
06:28:57 <SamB> someone should clarify this section in the wikipedia article...
06:29:08 <SamB> http://en.wikipedia.org/wiki/Knapsack_problem#Greedy_approximation_algorithm
06:29:09 <lambdabot> http://tinyurl.com/cy43f
06:29:16 <Toxaris> yes, it's not possible to understand it as it is
06:29:17 <matthew_-> SamB: it could be worse, they could use old english pounds
06:29:18 <SamB> lambdabot: that is NOT going to work
06:29:28 <SamB> matthew-_: old?
06:29:50 <SamB> matthew-_: did they have a different symbol for them once?
06:29:52 <matthew_-> pounds, shillings, farthings etc etc 240d to a pound
06:30:00 <smg> Deewiant: haha @undo i did not know
06:30:10 <matthew_-> I think the pound symbol was the same, but it was d and not p (pence)
06:31:07 <matthew_-> 12 shillings to a pound I think. there were 6 pence pieces too. Hmm.
06:31:20 <SamB> well, I think it would make more sense to have them labeled in pounds...
06:31:40 <SamB> since the british actually use metric
06:32:06 <Philippa> that's still a mixed deal
06:32:09 <matthew_-> only for some things.
06:32:15 <Philippa> I know I still buy drinks in pints and not just in the pub, for example
06:32:16 <Toxaris> SamB: where is it stated the "$" means US Dollar here?
06:32:29 <matthew_-> yep, drinks are in pints, unless you're in a german pub.
06:32:31 <SamB> Toxaris: nowhere, actually.
06:32:47 <matthew_-> height tends to be commonly in ft and inches and weight tends to be in st and lbs
06:32:59 <Cheery> is it possible to give default values for data?
06:33:01 <ivan_> so is there any polynomial lib in haskell, for computing polynomials?
06:33:05 <SamB> okay...
06:33:06 <matthew_-> though it's always taught in metric and in any official document you'll see it in metric
06:33:09 <jaj> matthew_-: if you're in a bavarian pub drinks are in liter
06:33:17 <SamB> so euros then?
06:33:21 <matthew_-> jaj: indeed
06:33:54 <Cheery> say, does map have some good syntax?
06:34:06 <Toxaris> SamB: "$" is a well-known currency sign over the world, and kg is well-known mass unit, so i think the choice of "$" and "kg" is fine here. the unit signs are not used to define a real problem, but just to make clear which number stands for costs and which for weight
06:34:09 <Vq^> Cheery: good?
06:34:17 <Cheery> which would allow you to write something like: [width=640, height=480]
06:34:24 <Cheery> ie. the object Map
06:34:25 <Toxaris> SamB: it's a picture, not an assigment :)
06:34:37 <SamB> Toxaris: yeah, it didn't bother me until I thought too hard about it ...
06:34:46 <Vq^> Cheery: fromList is quite close to that
06:35:12 <Vq^> Cheery: [("width",640),("height",480)]
06:35:31 <SamB> what is up with the british using pounds and pounds for weight and money?
06:35:33 <matthew_-> or, if width and height are functions, you could drop the quotes ;)
06:35:37 <Cheery> in other hand, I could just give a thing like [Width 640, Height 480]  and parse that
06:35:42 <matthew_-> SamB: we're special.
06:36:11 <matthew_-> SamB: and you never see "pounds" for weight - you'll see lbs. And you'll only see  for money
06:36:12 <Cheery> or, [(Width, 640), (Height, 480)]
06:36:24 <Philippa> I dunno, I see squid for cash
06:36:31 <matthew_-> or GBP or UKP
06:36:38 <SamB> Cheery: have you seen the := from gtk2hs?
06:36:39 <matthew_-> or Beer Tokens
06:36:51 <Cheery> nop
06:36:56 <Cheery> SamB: what does it do?
06:37:11 <SamB> Cheery: it lets you write lists like this:
06:37:26 <SamB> [width := 100, color = blue]
06:37:29 <SamB> er.
06:37:32 <SamB> [width := 100, color := blue]
06:37:51 <SamB> I'm not sure about those exact names... but that is the sort of thing it does
06:38:01 <georgw> Ok, me again: let h::[Int] = (map read . lines) s
06:38:08 <SamB> also, it is type safe!
06:38:22 <georgw> ghci does not like it: Illegal signature in pattern: [Int], Use -fglasgow-exts to permit it
06:38:30 <SamB> not sure how relevant that is right now
06:38:42 <georgw> What would be a clean way then?
06:38:43 <SamB> georgw: that just means that such code is not standard Haskell
06:38:50 <matthew_-> georgw: yeah, explicit type sigs will upset ghc until you enable extensions
06:39:01 <SamB> you can still use it, if you turn on the extension
06:39:04 <matthew_-> you want PatternSignatures
06:39:08 <matthew_-> iirc
06:39:23 <smg> rigid variable?
06:39:25 <georgw> Is there a clean way of doing this? Or should I use extensions?
06:39:28 <smg> what does this mean?
06:39:34 <Toxaris> georgw: you can use the type signature on an expression if you want to avoid extensions (but there's no need to avoid this extension)
06:39:36 <SamB> smg: full type error please?
06:39:45 <matthew_-> either :set -XPatternSignatures or add to the top of your file {-# LANGUAGE PatternSignatures #-}
06:39:51 <Toxaris> let h = ((map red . lines) s) :: [Int]
06:40:01 * Baughn is stunned by the speed of AES encryption. So much for having an unencrypted "performance" option..
06:40:03 <Deewiant> or let h :: [Int]; h = ...
06:40:12 <SamB> Baughn: is it faster than not?
06:40:18 <matthew_-> AES is quite fast.
06:40:33 <matthew_-> I can think of slower ciphers
06:40:43 <SamB> is it faster than SHA-256?
06:40:44 <Baughn> SamB: It's faster than fast ethernet
06:40:50 <smtms> :-)
06:40:55 <Syzygy-> SamB: SHA-256 isn't a cipher.
06:41:01 <SamB> I'm aware
06:41:17 <georgw> Deewiant: cool, that seems like the simplest solution. :-)
06:41:22 <Cheery> btw.
06:41:27 <Cheery> in other hand, I could do thing like:
06:41:40 <matthew_-> and it'll also depend on the mode you're using. some modes will allow better parallelism than others
06:41:55 <matthew_-> so talking about the speed of AES on its own is fairly silly
06:42:13 <Cheery> windowsettings = width 640 . height 480
06:42:16 <Cheery> then do:
06:42:23 <Baughn> matthew_-: Well, it's for a network filesystem. "Faster than fast ethernet" is a reasonable benchmark
06:42:32 <matthew_-> oh sure.
06:42:34 <Cheery> expose $ windowsettings window
06:42:45 <Cheery> where expose would do the magic. :)
06:43:16 <matthew_-> Baughn: the advantage of it being widespread is that there are hand tuned assembly versions and also dedicated hardware implementations available which can make it go very very fast
06:43:24 <matthew_-> (for common configurations)
06:43:49 <Cheery> I actually think I'll do this
06:43:50 <Adamant> AES was selected largely because it is fast.
06:43:57 <Cheery> since it seems the best thing I can do.
06:44:21 <Baughn> Also because it's secure, I should hope. Given that, what else /is/ there?
06:44:22 <SamB> matthew-_: that has to do with more than just it's being widespread though doesn't it?
06:44:27 <matthew_-> is AES a fiestal cipher?
06:44:34 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6130
06:44:39 <SamB> fiestal?
06:44:40 <matthew_-> Baughn: well, all of the finalists are argueably "secure"
06:44:53 <Baughn> SamB: Not /just/ that. AES is based on (relatively) simple math, which is why it's easy to implement in hardware
06:44:55 <smtms> feistel?
06:44:59 <Adamant> Baughn - Serpent is probably more secure, but has undergone less vetting since AES is THE cipher to crack down.
06:45:00 <Cheery> is there some init/destruction  routines for modules?
06:45:08 <matthew_-> smtms: yep, that's what I meant ;)
06:45:10 <Adamant> no, it's SP Network
06:45:15 <Adamant> not Feistel
06:45:24 <matthew_-> ahh.
06:45:26 <Cheery> so that I could program the Xlib module to open and destroy the display when you import it
06:45:32 <Baughn> Adamant: When it comes to encryption, anything is an improvement on NFS
06:45:35 <matthew_-> Serpent is MUCH slower though
06:45:42 <matthew_-> and the thinking was that it was overengineered
06:45:48 <Adamant> yeah, except for hardware implimentations
06:45:55 <Adamant> all depends on how secure you want to be
06:46:22 <hpaste>  tha pasted "(no title)" at http://hpaste.org/6131
06:46:28 <matthew_-> well, everyone is "concerned" that there's an algebraic representation of AES. I'm not sure anyone's worked out how to exploit it yet though
06:47:06 <Cheery> thought, in other hand I could just do a thing like: expose (window $ defaultscreen display)
06:47:36 <Adamant> the best attack against AES and Serpent is XSL, which doesn't actually do much in reality, and is currently completely theoretical. some people think with the overhead for doing XSL, it won't be any better in actuality than brute force.
06:47:48 <SamB> matthew-_: I'm not seeing how an algebraic representation necessarily makes it easier to break
06:47:59 <SamB> or is any reasonable cause for concern at all
06:48:00 <Adamant> SamB - more tools to bring to bear
06:48:34 <SamB> are you saying that that makes it easier to understand or something?
06:48:50 <Adamant> basically, you now get a lot of algebraic theory that you can now apply
06:48:55 <Baughn> It /could/ make it easier to eventually prove that it's unbreakable. Sooner or later that will have to happen.
06:49:02 <Adamant> to cryptanalytic attacks.
06:49:11 <SamB> Baughn: can that be proven?
06:49:28 <Adamant> AES is probably not unbreakable.
06:49:48 <Adamant> you need a information-theoretic approach for a unbreakable cipher like the OTP
06:49:57 <Adamant> modern ciphers are based on computational complexity
06:50:01 <matthew_-> it's certainly not a perfect cipher
06:50:23 <matthew_-> OTP is proveably the only perfect cipher isn't it?
06:50:31 <Adamant> perfect secrecy yes.
06:50:35 <SamB> why say "perfect"
06:50:38 <Baughn> SamB: The way I see it.. it's either breakable, or not
06:50:46 <SamB> OTP has tons of drawbacks
06:51:01 <Adamant> but it's level of secrecy isn't one of them
06:51:04 <Baughn> SamB: It may be the case that it can't be /proven/ to be unbreakable, but I can't see why that would be
06:51:19 <SamB> most of them having to do with "how do we distribute new codebooks"
06:51:49 <matthew_-> SamB: yeah, I once came up with the idea of compression of the codebook... :(
06:51:56 <SamB> hah!
06:52:08 <Adamant> yeah, that one wouldn't work too well. :)
06:52:09 <Baughn> That is, there might be a proof for some (possibly unknown) encryption system that any possible solution would require exponential time in any turing machine. That'D count as "unbreakable", until someone invents a quantum computer.
06:52:12 <matthew_-> to quote a certain TV programme: "Egg and my face were in alignment"
06:52:14 <SamB> I was thinking more like "how do we prevent codebooks from falling into the wrong hands?"
06:52:35 <matthew_-> encryption?
06:52:42 <Baughn> matthew_-: Well, the codebooks would be incompressible. That's a problem..
06:52:47 <SamB> matthew_-: heh
06:52:49 <quicksilver> Baughn: i find it hard to imagine such a proof.
06:52:51 <Baughn> matthew_-: So make random /compressed/ codebooks, then decompress them
06:52:54 <Adamant> quantum computer are Turing reducible, they just give speedups.
06:52:56 <matthew_-> Baughn: yeah, that's kinda where I was going ;)
06:53:02 <SamB> Baughn: you are SILLY
06:53:05 <Baughn> Adamant: Yeah. Exponential speedups, in some cases. ;)
06:53:05 <Philippa> quicksilver: we've proven problems to be in EXPTIME before, y'know
06:53:26 <quicksilver> Philippa: it's hard to imagine such a proof for something like "discrete logarithm" though.
06:53:28 <Adamant> you'd need a hypercomputer to break exponential time algorithms.
06:53:32 <Baughn> Nope
06:53:47 <Baughn> You need a hypercomputer to solve problems that /can't be solved on a turing computer/
06:54:00 <Baughn> For something that's just in exptime, a Very Fast turing computer will do
06:54:02 <Adamant> yeah, actually you are right
06:54:25 <quicksilver> Philippa: because you'd have to somehow rule out the possibility that in the future we'd discover new facts about natural numbers.
06:54:37 <matthew_-> this is the difference between NPC and Undecideable right?
06:54:54 <quicksilver> Philippa: and experience is that we quite often discover new facts about natural numbers (which occasionally lead to new algorithms to do stuff)
06:54:57 <Baughn> matthew_-: Yes
06:55:28 <Baughn> matthew_-: Or, more precisely, between "intractable" and "undoable"
06:55:35 <matthew_-> gotcha
06:56:20 <Baughn> matthew_-: It's (very theoretically) possible to build a turing computer that will do an /infinite/ amount of computation in finite time - but it /still/ can't solve (most) of those problems
06:56:57 <Baughn> http://www.frc.ri.cmu.edu/~hpm/project.archive/general.articles/1991/TempComp.html <-- Have details. It's fun.
06:56:59 <lambdabot> Title: TempComp.ht, http://tinyurl.com/2jhdv5
06:58:26 <hpaste>  tha annotated "(no title)" with "(no title)" at http://hpaste.org/6131#a1
06:59:11 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6132
07:08:23 <SamB> @tell ndm okay, I'm trying this again with --quiet
07:08:23 <lambdabot> Consider it noted.
07:13:30 <Baughn> @hoogle evaluate
07:13:30 <lambdabot> Control.Exception.evaluate :: a -> IO a
07:15:46 <gbacon> ok, scary experience.. usually when a Haskell program typechecks, it also runs correctly!
07:16:01 <gbacon> pugs is compiling again with ghc-6.8.2, but it's not happy :-(
07:16:51 <gnuvince_> gbacon: I think unless audreyt returns to pugs, the project is gonna be pretty much stalled.
07:17:37 <gbacon> gnuvince_: where's your sense of optimism? :-)
07:19:07 <quicksilver> my understanding is that pugs (ab)uses a lot of obscure GHC features.
07:19:30 <quicksilver> as such it goes well beyond haskell and confidence of it running with newer ghc versions, or just because it compiles, decreases.
07:30:51 <Lemmih> Audrey left the pugs project?
08:00:14 <DukeDave> @hoogle tokens
08:00:15 <lambdabot> Text.ParserCombinators.Parsec.Prim.tokens :: Eq tok => ([tok] -> String) -> (SourcePos -> [tok] -> SourcePos) -> [tok] -> GenParser tok st [tok]
08:01:59 <DukeDave> Shouldn't "tokens isSpace = words" on http://haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString-Lazy-Char8.html#15 actually read "splitWith isSpace = words" ?
08:02:01 <lambdabot> http://tinyurl.com/yoq7wt
08:14:55 <Toxaris> DukeDave: that would not be correct. look at the source of words.
08:15:23 <BMeph> Y'know, if Lisp were nothing but the macros, it would've been much more fun to use. Maybe that's how we should sell Haskell to PG... ;)
08:15:42 <quicksilver> Toxaris: yes but it's very odd that the haddock refers to a function 'tokens' which doesn't exist :P
08:16:09 <Toxaris> quicksilver: well, but replacing nonsense documentation by wrong documentation doesn't help, does it=
08:16:14 <quicksilver> no.
08:21:31 <Toxaris> quicksilver, DukeDave: tokens is defined in Data.ByteString, but commented out
08:21:49 <Toxaris> tokens f = P.filter (not.null) . splitWith f
08:30:09 <gnuvince_> I want to try and add some quickchecks to my program, but am unsure as to how to proceed.  Besides the simple character example on the wiki, is there a place with more information on using quickcheck?
08:32:21 <quicksilver> gnuvince_: the quickcheck manual?
08:33:52 * SamB wonders if it is a bad idea to build GHC and JHC at the same time
08:38:44 <Saizan> hacking on cabal makes you wish for globals, read-only at least
08:39:05 <shag> which of the avaliable DB interface should i use? i only need quick and easy access to a sqlite db
08:39:49 <Saizan> HDBC probably
08:40:13 <shag> yea, thats what i am thinking, too
08:40:39 <gwern> 'I left out darcs because it appears to have some serious performance issues (at least I've read so multiple times; however this information might be outdated or the issue might get fixed in the future) and 3 systems are already more than enough for a side-by-side comparison. Also i don't have a clue about Haskell' <-- ow
08:41:08 <Saizan> from where?
08:41:16 <gwern> http://demod.org/blog/2008/03/a_simplistic_comparison_of_distributed_revision_control_systems_by_example
08:41:19 <lambdabot> Title: A Simplistic Comparison of Distributed Revision Control Systems by Example [demo ..., http://tinyurl.com/yun7z8
08:42:15 <DukeDave> What is the most sensible way to do  ByteString -> Integer
08:42:22 <mauke> const 0
08:42:46 <Saizan> DukeDave: there's readInt in .Char8, if that's what you are asking
08:42:56 <DukeDave> mauke: I'm intrigued?
08:43:17 <flux> a shame, the comparison could've used darcs' way of doing things
08:43:38 <DukeDave> Saizan: Excellent, thanks
08:45:07 <hpaste>  pozorvlak pasted "Templated argument-munging function" at http://hpaste.org/6134
08:47:23 <hpaste>  pozorvlak annotated "Templated argument-munging function" with "Justification and links" at http://hpaste.org/6134#a1
08:56:57 <hpaste>  tha pasted "xmonad.hs 0.1.0.0" at http://hpaste.org/6135
09:05:01 <hpaste>  (anonymous) annotated "xmonad.hs 0.1.0.0" with "(no title)" at http://hpaste.org/6135#a1
09:09:04 <explisixjelly> I'm still not sure how to "interleave" two datatypes
09:09:25 <explisixjelly> I have a syntax tree and want to annotate, for example, the position in the source file where it occured.
09:09:38 <explisixjelly> the naive approach would be:
09:10:17 <mrd> data Loc a = L SrcSpan a, perhaps
09:10:18 <explisixjelly> data Expression = Atom | Plus SourceAnnotatedExpression SourceAnnotatedExpression | UnaryMinus SourceAnnotatedExpression
09:10:43 <explisixjelly> mrd, yeah, something like that
09:10:56 <mrd> that's lifted from GHC
09:11:16 <explisixjelly> what's "SrcSpan"?
09:11:19 <quicksilver> explisixjelly: you will hear arguments for data Expression a = Atom a | Plus a (Expression a) (Expression a)
09:11:21 <Baughn> "type AnnotatedExpression = (Expression, (Maybe Annotation))"?
09:11:30 <mrd> something representing a location
09:11:34 <quicksilver> explisixjelly: that is, give your ADT a type parameter.
09:11:48 <mrd> that's not bad either
09:11:49 <quicksilver> explisixjelly: you can instantiate that parameter to () to give the type Expression () of 'plain expressions'
09:11:56 <mrd> you can also do a type param for variable-type
09:12:04 <quicksilver> or to 'Expression SourceLoc' for 'expressions with source locs'
09:12:04 <explisixjelly> quicksilver, ah. so the annotation is the type parameter?
09:12:07 <quicksilver> yes
09:12:11 <explisixjelly> quicksilver, that's good. for some reason, I didn't think about that yet.
09:12:14 <quicksilver> or to 'Expression Type' for expressions with types.
09:12:19 <quicksilver> or to .... etc etc.
09:12:32 <explisixjelly> quicksilver, yes. yes, that's cool...
09:12:32 <quicksilver> IIRC this technique is suggested in one of SPJ's books.
09:12:56 <explisixjelly> quicksilver, thanks a lot.
09:13:19 <matthew_-> you know, is quite annoying when GHC's brain explodes
09:13:30 <matthew_-> I tend to rather hope that GHC is the one that actually knows what's going on
09:13:49 <quicksilver> matthew_-: let binding an existential?
09:13:54 <quicksilver> matthew_-: or something more sinister?
09:14:01 <quicksilver> knowing matthew_-'s code, it will be something more sinister.
09:14:08 <slarba> what the heck... does anyone have a hunch why ghci first performs :cd ~/.cabal/ when started from haskell-mode
09:14:12 <matthew_-> I kinda delegate to GHC in that respect. When its brain explodes too, it's game over...
09:14:23 <matthew_-> quicksilver: no, currently it's just an existential problem
09:14:25 <mrd> slarba: sounds screwy, what version?
09:14:38 <quicksilver> the new haskell-mode tries to :cd to the right place
09:14:45 <slarba> haskell-mode 2.4
09:14:50 <quicksilver> when you C-c C-l a piece of code in a new project
09:14:55 <quicksilver> it can find dependent modules
09:15:02 <quicksilver> (in old versions you had to :Cd by hand)
09:15:11 <quicksilver> maybe part of that code is broken, or just surprising.
09:15:21 <byorgey> matthew_-: I thought that was Simon's brain, rather than ghc's that is exploding?
09:23:43 --- mode: irc.freenode.net set +o ChanServ
09:24:13 <explisixjelly> matthew_-, ah, nice. will keep that in mind. thanks.
09:27:41 <byorgey> I think it's very nice.
09:27:46 <byorgey> er, mischan, sorry
09:29:56 <morner> okay, hideous newbie question time: how would I go about constructing a byte buffer from, say, a list of Int-formatted byte values? i'm attempting to write the .bmp-export code for a simple raytracer, but i've no idea how System.IO.hPutBuf is actually used
09:30:18 <taruti> morner: Data.Binary might help you.
09:30:31 <morner> google code search is peppered with $s and @s and other symbols which i've never encountered :(
09:30:39 <quicksilver> morner: don't use System.IO.hPutBuf, it's ugly :)
09:30:51 <morner> taruti: okay, i'll take a look at that
09:31:02 <quicksilver> either use Data.Binary, which is moderately high level
09:31:07 <quicksilver> or use ByteString directly.
09:32:01 <morner> googling on haskell is very strange
09:32:09 <Baughn> morner: It takes a raw memory pointer. You almost certainly don't want to do that.. use bytestrings, which have a far nicer interface
09:32:38 <morner> half of the results are invariably research papers discussing how to actually solve problems
09:32:56 <mae> hello gents and gentle ladys
09:32:56 <opqdonut> morner: use Foreign.Marshal if you want to do it that way
09:33:05 <morner> as opposed to, you know, code snippets
09:33:24 <morner> opqdonut: i'll look into Data.Binary, it sounds like the most correct way
09:34:20 <Baughn> morner: Data.ByteString.putStr is fairly exactly equivalent to hPutBuf, and you can use pack to stick your list into the bytestring. Or use bytestring all along..
09:34:53 <Eelis-> dons: heh, thanks (for the reddit post)
09:35:10 <Baughn> morner: It's a nice interface on top of bytestrings. I'd prefer to understand how the system it uses works first, but of course that isn't strictly necessary.
09:36:08 <Baughn> morner: It solves the problem of how to encode your data more than how to write it to file, though, which is what you asked about
09:36:31 <Dybber> explisixjelly: I solved the problem I should use Data.ByteString.Lazy.Char8 instead. Hoogle cuts of the last parts of long module names, therefore I didn't see it :-)
09:36:52 <explisixjelly> Dybber, aaah %)
09:37:10 <explisixjelly> Dybber, good observation. I will keep that in mind when encountering long module names on hoogle
09:38:19 <Baughn> quicksilver: Binary would probably be faster than Parsec even when using equivalent parsers, right?
09:41:06 <quicksilver> Baughn: Binary isn't a parser.
09:41:23 <quicksilver> it doesn't have any combinators :)
09:41:33 <quicksilver> it just decodes bytes.
09:41:39 <quicksilver> if that's all you need, then yes, it will be much faster.
09:41:51 <explisixjelly> as opposed to decoding qbits?
09:42:01 <quicksilver> :P
09:42:06 <quicksilver> as opposed to making choices.
09:42:59 <Baughn> quicksilver: The "get" instance definitely /is/ a parser, if a simplistic one
09:43:51 <Baughn> quicksilver: But yes, speed is the most important thing for me right now. I'm trying to win a speed contest against java. :P
09:44:34 <quicksilver> Baughn: you take my point.
09:44:42 <quicksilver> Baughn: it's not a general parser library.
09:44:47 <quicksilver> because it's unable to make choices.
09:45:15 <quicksilver> you can make your own choices, within your get instances, of course.
09:45:21 <quicksilver> but there's no built-in magic for that.
09:45:23 <Baughn> It's unable to backtrack, yes. Point taken.
09:45:33 <quicksilver> people have talked about building parser combinators on top of binary.
09:45:58 <quicksilver> but the comparison "Data.Binary vs Parsec" is a bit apples vs oranges.
09:46:29 <Baughn> It would have been nice to show the power of parsec simultaneously, especially if it turned out to be approximately as fast
09:46:51 <Philippa> quicksilver: that's precisely the reason to make it though, especially as parsec3 ought to be reasonably usable to parse binary stuff in a pinch
09:47:54 <Baughn> I've already used parsec to help me reverse-engineer binary formats. Chances are I don't /need/ it, but it definitely helped
09:50:37 <Philippa> Baughn: it'd be much appreciated if someone attacked binary parsing with parsec3, FWIW
09:55:49 <Saizan> is there a way to ask for the path the current program was invoked as, so i can re-exec it? System.Environment.getProgName is not so helpful
09:55:59 <smg> do i really need arrows?
09:56:10 <glguy> nope
09:56:11 <byorgey> smg: yes, without arrows you will die
09:56:16 <Baughn> smg: Nope, but you may end up reinventing them
09:56:40 <glguy> though it isn't likely ;)
09:56:43 <Philippa> smg: to do what?
09:56:59 <smg> Philippa: hehe in generell
09:57:03 <gwern> Saizan: yes
09:57:22 <Philippa> in general, the only thing you can't build yourself instead in Haskell is the IO monad
09:57:23 <byorgey> smg: who cares if you need them?  they are interesting =)
09:57:28 <smg> haha
09:57:46 <Baughn> smg: Once you stop learning you will die. Therefore..
09:57:56 <Saizan> gwern: how? :)
09:57:57 <glguy> spend time learning something useful
09:58:09 <Baughn> Right, like cooking
09:58:10 <gwern> Saizan: are you on linux?
09:58:10 <smg> Baughn: haha
09:58:20 <byorgey> see, glguy and I have completely different philosophies of learning, apparently ;)
09:58:22 <gwern> you can query /procfs for the info
09:58:31 <Saizan> gwern: not necessarily, this is for cabal-install
09:58:34 <smg> i will read about arrows but only a bit
09:58:39 <gwern> Saizan: unfortunately, I know of no portable way to do it
09:59:00 * gwern a while ago had the same exact question; I wanted it for ghc
09:59:01 <jhm`> @pl f a (x,y) = (x, a y)
09:59:01 <lambdabot> f = (`ap` snd) . (. fst) . flip ((.) . (,))
09:59:09 <pejo> Saizan, there isn't a portable way to find that stuff out.
09:59:30 <Philippa> smg: I'd suggest reading enough to be able to read something in arrow notation and then leaving it for now
09:59:42 <Philippa> if you're writing something that might make a good arrow you'll probably have some idea that it might
09:59:48 <Philippa> because it'll feel "like a monad, but not quite"
09:59:57 <Baughn> gwern: argv[0] is supposed to contain the exact filename, but I have no idea how to access it in haskell
10:00:03 <Saizan> pejo: something that will at least work on general unix?
10:00:06 <glguy> getArgs
10:00:09 <smg> Philippa: i see
10:00:16 <gwern> Saizan: the best I could suggest is to find the prefix cabal is installing into and extrapolate from there
10:00:16 <glguy> ?index getArgs
10:00:16 <lambdabot> System.Environment
10:00:21 <Baughn> gwern: It's the same string you passed to exec to load the program in the first place, so..
10:00:24 <pejo> Saizan, nope.
10:00:26 <smg> Baughn: do x <- getArgs; x !! 0
10:00:40 <pejo> Saizan, the program you are running might not even exist any longer.
10:00:41 <Saizan> getArgs gives the arguments, iirc
10:00:44 <gwern> Baughn: I thought that only include the basename,? ie /bin/echo would appear to busybox inspecting argv[0] as 'echo'
10:00:45 <Baughn> smg: That appears to be missing the first one
10:00:48 <Saizan> pejo: yeah, i know that
10:01:08 <Baughn> gwern: Nope, it's the exact same string that was passed to exec
10:01:51 <Baughn> gwern: Technically that's up to the caller, as it can be different from the program that's actually /executed/, but by convention it shouldn't be
10:02:13 <gwern> Saizan: if baugh is write, I guess there is away; at least, now you know to ask 'how do I get argv[0] in haskell?'
10:02:16 <Baughn> gwern: In other words, if your shell passes only the basename, it's broken
10:02:27 <Jedai> jhm`: This function is Control.Arrow.second
10:02:33 <Eelis> gwern: (did you get my messages?)
10:02:37 <Baughn> gwern: (Unless it's in your path. You need to search the path.)
10:03:09 <gwern> Eelis: message?
10:03:15 <Baughn> Saizan: And te answer is "System.Environment.getProgName"
10:03:18 <Deewiant> Baughn: there's a getProgramName or something somewhere
10:03:22 <Deewiant> yeah, that one :-)
10:03:23 <Saizan> Baughn: no, it's not.
10:03:32 <Eelis> gwern: sounds like you didn't, then :)
10:03:34 <gwern> ...but Saizan already saud getProgName didn't work
10:03:40 <Baughn> Saizan: What does it return?
10:03:56 <Saizan> Baughn: that gives only the basename, as in the documentation
10:04:02 <gwern> besides, according to http://www.haskell.org/haskellwiki/Simple_unix_tools getProgName returns only the basename
10:04:03 <lambdabot> Title: Simple Unix tools - HaskellWiki
10:04:04 <Baughn> Saizan: Oh.
10:04:18 <smg> > x =<< getArgs
10:04:18 <gwern> note that the final section is matching on 'blank', not a substring
10:04:20 <lambdabot>   Not in scope: `getArgs'
10:04:27 <smg> > x =<< System.getArgs
10:04:27 <lambdabot>   Not in scope: `System.getArgs'
10:04:30 <smg> -.-
10:04:44 <Eelis> gwern: i'm reluctant to put geordi on hackage, because (1) installing geordi is a real chore (because it involves setting up a chroot for gcc to compile in); (2) it's such an extremely specialized application, it doesn't really make much sense as a library; (3) i like just pushing patches without having to worry about version numbers (geordi has no version number)
10:04:49 <Eelis> gwern: regarding (2), note that geordi is really extremely C++-oriented. the vast majority of the code is things like gcc error filters, a nice C++ prelude, convenient C++-like request syntax, et cetera. in addition, the actual supervisor makes all kind of assumptions about gcc behavior; it definitely is _not_ a general purpose supervisor.
10:04:52 <Deewiant> Saizan: you want the full path, or what?
10:04:54 <Eelis> gwern: i'm glad to hear the "darcs is not yet aware of executability" thing is not (or no longer) the case. i'll make use of that, thanks.
10:05:07 <Baughn> @hoogle argv
10:05:08 <lambdabot> No matches found
10:05:29 <Saizan> Deewiant: yes, so i can be able to invoke it again
10:05:42 <gwern> Eelis: oh. yeah, you should update your page to have the darcs get use the       --set-scripts-executable       make scripts executable
10:05:42 <Deewiant> Saizan: you can't get that reliably in any language, I don't think
10:05:54 <Deewiant> Saizan: if the user runs "../foo" you get ../foo in argv[0]
10:06:09 <Baughn> Deewiant: Yes, which suffices to find the program
10:06:19 <Eelis> gwern: oh. i can't configure that as part of the repository somehow?
10:06:23 <Deewiant> Baughn: getProgName gives only "foo" in that case?
10:06:24 <Baughn> Deewiant: You just have to implement the same search algorithm as the shell
10:06:29 <Saizan> Deewiant: best than "foo" which gives me no hope to find it
10:06:36 <Deewiant> Saizan: oh, darn. :-(
10:06:40 <gwern> Eelis: I suspect the recipient has to specificablly enable for ecurity reasons
10:06:46 <Baughn> Deewiant: Well, getProgName yes. I was complaining about "In any language"
10:06:48 <DukeDave> Anyone here have experience with DrIFT ?
10:06:49 <Eelis> gwern: i see :/
10:06:55 <cjb> on Linux, there's /proc/$pid/exe
10:07:01 <DukeDave> I can't seem to make sense of it
10:07:13 <cjb> (symlink to the running binary)
10:07:16 <gwern> Eelis: it'd be bad if a simple download dumped fully executable malicious programs onto your system without you specificall sayiong
10:07:23 <Baughn> cjb: As a bonus, that can't be spoofed; argv[0] can be. Though perhaps that's a minus.
10:07:31 <Deewiant> Baughn: in "any language", you can use system() or something like that to run argv[0] and it should work
10:07:36 <Saizan> (err, "better")
10:07:43 <Eelis> gwern: i disagree, this is the standard for things like tarballs
10:08:09 <Deewiant> Saizan: maybe you can hack something based on the source: http://haskell.org/ghc/docs/latest/html/libraries/base/src/System-Environment.html#getProgName
10:08:11 <lambdabot> http://tinyurl.com/2nccy5
10:08:30 <MyCatVerbs> @pl \f m -> m >>= (return . f)
10:08:31 <lambdabot> fmap
10:08:34 <MyCatVerbs> Heh.
10:08:54 <Baughn> Saizan: You'd have to alter ghc a bit, but that should work easily enough
10:09:04 <Baughn> Saizan: How badly do you need this? Can't you just re-invoke main?
10:09:05 <pejo> Deewiant, why would system() on argv[0] always work? It supposedly executes stuff with sh(1) according to my manpage.
10:09:22 <gwern> Eelis: well, you could ask the darcs devs why not the default
10:09:27 <opqdonut> is hGetLine as lazy as hGetContents?
10:09:30 <gwern> the manual doesn't seem to say
10:09:38 <Baughn> opqdonut: Nope
10:09:55 <Saizan> Baughn: i need this so i can use sudo or similar to gain root privileges in the middle of execution
10:10:01 <Eelis> gwern: perhaps i will. anyway, i'll use --set-scripts-executable for now.
10:10:14 <Deewiant> pejo: unless your shell has odd path expansion stuff that sh doesn't, it should work, I think
10:11:02 <gwern> Eelis: it's possible no one has complained yet
10:12:17 <pejo> Deewiant, pretty much anything is more advanced than sh on certain platforms. Solaris is a brilliant example.
10:12:18 <gwern> http://bugs.darcs.net/issue556 'This is not the only bad default in Darcs; --set-scripts-executable
10:12:19 <lambdabot> Title: Issue 556: wishlist: default repository for darcs pull and push - Darcs bug trac ...
10:12:21 <gwern> and --look-for-adds both enable behaviour that other version control
10:12:24 <gwern> systems consider dead obvious.
10:12:30 <smg> @pl  \f m -> fmap (join f) m
10:12:30 <lambdabot> fmap . join
10:12:47 <pejo> Saizan, can't you do it the other way around? Start as root and drop privileges for your 'worker threads'?
10:13:46 <Deewiant> pejo: aye, but do you in general run programs with commands that sh doesn't understand?
10:14:52 <smg> @pl join (fmap g m)
10:14:52 <lambdabot> g =<< m
10:16:31 <pejo> Deewiant, does system(3) pass on environment variables, or give fresh new ones?
10:16:31 <byorgey> @seen dcoutts
10:16:31 <lambdabot> dcoutts is in #gentoo-haskell, #haskell, #haskell-overflow, #haskell-soc and #ghc. I don't know when dcoutts last spoke.
10:16:34 <audreyt> Philippa: I've modernised Flippi a bit; you mind if I cabalize it and upload to hackage, or should I darcs send?
10:16:54 <Deewiant> pejo: I'm not sure, but I think it inherits them from the current program.
10:16:58 * gwern has a sudden sense of deja vu :)
10:17:23 <gwern> audreyt: how did you work around the type errors for xhtml/html?
10:18:17 <Eelis> gwern: thanks for looking that up
10:18:39 <matthew_-> lol! never seen this one before:     mp  not in scope because it has a wobbly type (solution: add a type annotation)
10:18:50 <matthew_-> "wobbly type"!!
10:19:05 <gwern> aren't wobbly types internal to ghc?
10:19:16 <Philippa> audreyt: do whatever you want so long as I don't have to maintain it :-)
10:19:47 <Philippa> out of interest, which version did you branch from? There're some weird ones floating around in the ether that never quite got released per se
10:20:36 <pejo> matthew, I think ndm had the same problem. Search the archives for ghc-users, SPJ answered it iirc.
10:20:57 <dons> Eelis: :)
10:20:58 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
10:21:14 <Saizan> matthew_-: are you using pattern guards?
10:21:20 <DukeDave> Do we not use paste.lisp.org in here anymore?
10:21:27 <dons> no, we use hpaste.org
10:21:35 <dons> a paste bin for the 21st century
10:21:45 <matthew_-> Saizan: nope
10:21:46 <dons> ?paste
10:21:46 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:21:59 <hpaste>  DukeDave pasted "DrIFT" at http://hpaste.org/6137
10:22:14 <Baughn> How is hpaste superior?
10:22:15 <DukeDave> Much cleaner than pastebin
10:22:31 <dons> also a lot simpler now.
10:22:34 <Saizan> Baughn: it has a type signature!
10:22:45 <cjb> codepad.org is useful in that it runs your code too, so people can see what doesn't work about it or something.
10:22:47 <DukeDave> So, can someone push that through DrIFT and see if it works?
10:22:47 <dons> finally, hpaste is under active dev, its getting user accounts, multiple languages, rss feeds...
10:23:03 <Baughn> Ah. That'd do it.
10:23:16 <dons> cjb: yeah, i'm thinking we should use codepad as a web service to provide an 'eval' button
10:23:36 <cjb> dons: why not just use codepad?  :)
10:23:54 <DukeDave> It just doesn't add anything :(
10:24:07 <dons> we've our own haskell-tailored site
10:25:26 <morner> okay, new crisis: i now have a (working, on my linux box) Data.ByteString test program, but it won't link on my mac
10:26:00 <morner> it compiles as far as the .o stage, but then ld emits a bunch of undefined symbol errors
10:26:46 <smg> cjb: that's cool
10:27:37 <smg> cjb: that's awesome ;-)
10:28:31 <Baughn> morner: Can I see the errors?
10:29:40 <Philippa> assuming I need to do it on both windows and *nix, what's the current story for calling code from dynamically-discovered libraries?
10:29:56 <Philippa> (the use case'd be an FFI for a language with an interpreter in Haskell)
10:30:48 <morner> Baughn: http://hpaste.org/6138
10:30:54 <dcoutts_> byorgey: pong
10:31:03 <byorgey> hey dcoutts_
10:31:21 <morner> flagerent abuse of hpaste >_<
10:31:31 <byorgey> dcoutts_: I'm looking into the paragraph-reflow thing now.
10:31:43 <dcoutts_> byorgey: oh, nice
10:31:45 <Baughn> morner: You haven't updated bytestring on your own since installing ghc? Or left an old installation in place?
10:32:01 <byorgey> dcoutts_: at what points would a package's text description get printed?
10:32:19 <Baughn> morner: That sort of thing happens to me once in a while. As it's solved by a slash-and-burn reinstall of ghc (and libraries), I don't know how to do it /nicely/
10:32:26 <morner> i don't *think* so, but it's possible that i've done something silly
10:32:49 <byorgey> dcoutts_: I mean, what are all the situations in which it could be printed
10:32:50 <dcoutts_> byorgey: currently it's just in the list and when we print an InstalledPackageInfo file when registering
10:32:51 <morner> i'll try the slash-and-burn
10:32:57 <morner> bandwidth is cheap
10:33:01 <Baughn> morner: Delete /usr/local/*, ~/.ghc, ~/.cabal, etc. etc., and make sure you /clean/ any libraries before rebuilding and installing
10:33:14 <audreyt> Philippa: I based it on the latest release (0.03); I'll check darcs tomorrow but need to sleep :) bbl
10:33:25 <Baughn> morner: Substituting wherever you installed ghc for /usr/local/, of course
10:33:25 <Philippa> the darcs is down AFAIK :-)
10:33:26 <byorgey> dcoutts_: ok, and it's important that the InstalledPackageInfo file can be read back in?
10:33:32 <Philippa> 'night
10:33:52 <dcoutts_> byorgey: we currently print the synopsis not the description but there's no reason we shouldn't have an extended info output mode that does print the full description
10:34:09 <dcoutts_> byorgey: right, the InstalledPackageInfo file is what is given as input to ghc-pkg
10:34:18 <morner> it will be nice when macports gets a ghc port which actually builds
10:34:22 <dcoutts_> byorgey: and it's what you see when you do ghc-pkg describe foo
10:34:29 <Baughn> morner: The main cause seems to be not cleaning a library source dir before reusing it after upgrading ghc
10:34:48 <byorgey> dcoutts_: ok, got it
10:34:52 <Baughn> morner: It'd be nice, except it'll be permanently half a year behind. :/
10:35:19 <dcoutts_> byorgey: to be honest it's probably not worth doing it when printing the InstalledPackageInfo files
10:35:28 <dcoutts_> byorgey: only when we're printing it for humans to read
10:35:30 <byorgey> dcoutts_: hmm, strange.  I have a package here I'm using for testing, and it seems to be displaying the description under 'Synopsis:' when I do cabal list
10:35:33 <pejo> morner, they announced 6.8.2 today.
10:35:36 <byorgey> dcoutts_: ok, right.  agreed.
10:35:44 <morner> pejo: in macports?
10:35:54 <morner> that is interesting
10:35:55 <pejo> morner, yes. On ghc-users.
10:36:08 <pejo> morner, no luck with leopard/ppc though, if you're using that.
10:36:12 <dcoutts_> byorgey: right, when there is an installed package that is not available on hackage then we have to print the installed package's description since in that case there is no separate synopsis
10:36:31 <morner> leopard's the 10.5 one, isn't it
10:36:42 <morner> i think i'm on that
10:36:43 <byorgey> dcoutts_: oh, interesting, why is that?  I have a synopsis: field in the .cabal file
10:36:48 <morner> c'est la vie
10:36:59 <pejo> Baughn, I don't think it's fair to generalize that it's always 6 months behind. It was fairly quick with 6.6.
10:37:16 <dcoutts_> byorgey: the InstalledPackageInfo simply doesn't have a synopsis, only the description
10:37:36 <byorgey> dcoutts_: ah, ok
10:37:50 <Baughn> pejo: Regardless. Except for some utility software, I've found that it's generally easier to install everything myself than to fight with a package system
10:37:54 <dcoutts_> byorgey: so when we print package info we combine the info from the available and installed packages, we take the info from the hackage index in preference to the local info where it's available
10:38:00 <Baughn> Gentoo worked nicely. If only I could use it. :/
10:38:19 <dcoutts_> byorgey: you can see it in the Hackage.List.mergePackageInfo function
10:38:23 <byorgey> dcoutts_: ok, I see.
10:38:26 <dcoutts_>     synopsis          = combine Available.synopsis latestAvailableDesc
10:38:26 <dcoutts_>                                 Installed.description latestInstalled,
10:41:42 <byorgey> dcoutts_: so, just to make sure I have this straight, at this point the only thing we want to reflow is the synopsis output in 'cabal list'?
10:41:55 <dcoutts_> byorgey: I guess so
10:42:06 <byorgey> adding an option to also print out descriptions is also a possibility but that's an orthogonal issue
10:42:11 <dcoutts_> byorgey: right
10:42:46 <dcoutts_> byorgey: a full listing might also display what things it depends on, what modules it exposes etc
10:43:04 <dcoutts_> byorgey: more like a nicely formatted version of ghc-pkg display foo
10:43:05 <byorgey> dcoutts_: ok, I'll send a patch soon -- maybe I'll look into adding such an option later.
10:43:13 <dcoutts_> byorgey: great
10:46:18 * glguy wants to be able to filter the package list of hackage by license
10:46:33 <Baughn> Is anyone working on having cabal-install autogenerate debian packages? Or, in general, packages?
10:46:49 <lispy> that would be a nice SoC project, I would imagine
10:47:12 <lispy> OTOH, I could be wrong, I don't really know what it entails.
10:47:29 <gwern> Baughn: doesn't jp goerzen have stuff to do that?
10:47:57 <Baughn> I don't know. It just struck me as a good idea two minutes ago
10:48:30 <dons> Baughn: there's some cabal2deb tools already
10:49:41 <dcoutts_> Baughn: there are already tools used by the distro maintainers to generate native package descriptions from cabal packages
10:49:52 <dcoutts_> at least for gentoo, .deb and rpm
10:50:00 <Baughn> I guess that's a "Yes", then. Thanks
10:50:18 <Cheery> where to file proposals into haskell language?
10:50:24 <Cheery> I'd have this one:
10:50:44 <Cheery> with openedFile do { ... }
10:50:50 <Cheery> or actually
10:50:53 <Baughn> Cheery: Already exists
10:50:58 <Cheery> huh?
10:51:02 <Baughn> System.IO.withFile
10:51:06 <Cheery> can I write that just like so?
10:51:10 <gwern> any idea how to fix a link error like '/home/gwern/bin/lib/hscurses-1.2/ghc-6.8.2/libHShscurses-1.2.a(CursesHelper.o): In function `siDu_info':
10:51:11 <dcoutts_> glguy: you can :-) the license is in the metadata in the hackage index, however you have to write the tool to do the filtering :-)
10:51:14 <gwern> (.text+0x7c5): undefined reference to `LINES'
10:51:16 <gwern> ? hscurses installed fine
10:51:20 <Cheery> I thought I must write something like withFile "" $ do
10:51:22 <Baughn> Cheery: You should check the documentation, but yes, very nearly
10:51:56 <Baughn> Cheery: ..oh, an already open handle? Use finally to close it. Or use withfile to begin with.
10:52:14 <Cheery> finally?
10:52:15 <dcoutts_> did anyone notice that C++ is gaining lambda functions?
10:52:23 <dcoutts_> <>(int x, int y) -> int {int z = x + y; return z + x;}
10:52:41 <Cheery> dcoutts_: nobody cares because C++ sucks
10:52:43 <Baughn> dcoutts_: Why not? It has everything /else/, except simplicity.  ;)
10:52:44 <dcoutts_> which translates as \x y -> let z = x + y in x + y
10:53:15 <Cheery> sorry from being in right
10:53:27 <Baughn> Cheery: Control.Exception.finally - runs some code (like hClose) even if an exception is caught, which sounds like what you want
10:53:38 <Cheery> oi!
10:53:40 <Deewiant> dcoutts_: yeah, it's ripping everything it can from D. :-)
10:53:51 <dcoutts_> Deewiant: and java and c# it seems
10:53:51 <Baughn> Cheery: Once you have that, withHandle is a one-liner
10:53:54 <glguy> dcoutts_: would it be more feasible to print the license off to the right on the main page
10:53:57 <glguy> rather than filtering?
10:54:02 <Cheery> Baughn: thank you!
10:54:07 <dcoutts_> glguy: you mean on the hackage web page?
10:54:10 <glguy> yeah
10:54:49 <Cheery> Baughn: I have another question from same thing
10:54:52 <Baughn> Cheery: The lesson is "It already exists". As for your original question, once you're more experienced and have something you're very sure is an improvement, propose a patch to the ghc maintainers. It might eventually make it into Haskell''. ;)
10:55:14 <dcoutts_> glguy: it would be possible, we have to make a comprimise at some point about how much info we cram in. You can certainly propose it on the cabal-devel list and even better, send a patch or make a mockup showing what it'd look like.
10:55:22 <glguy> kk
10:55:30 <Cheery> do you guys have something like init/shutdown hooks for those modules?
10:55:51 <Baughn> Cheery: That implies global state. You do not want global state.
10:55:53 <dcoutts_> Cheery, Baughn: surely for a withHandle you want to use bracket?
10:55:57 <Cheery> say, I'd want to import MyModule, and if the person uses it, he would init/shutdown that stuff anyway
10:55:58 <Baughn> Cheery: What are you thinking of, exactly?
10:56:14 <Cheery> like openDisplay and closeDisplay in Xlib
10:56:17 <Baughn> Cheery: Use explicit functions. He might want to use two /separate/ contexts
10:56:33 <Baughn> Cheery: Like having multiple X servers
10:57:07 <dcoutts_> Cheery: if you only expose withDisplay then people have to use it in a block-structured way, see cairo for example.
10:57:55 <Baughn> dcoutts_: bracket would be nice if you can open the file at the same time. Cheery apparently has a handle from another function somewhere that he wants to be sure is closed
10:58:10 <dcoutts_> oh, fair enough
10:58:59 <Cheery> hm. do you have a 'finally' -clause that'd do it's stuff when things are garbage collected?
10:59:01 * Baughn wonders why evaluate is in control.exception instead of control.concurrent
10:59:04 * glguy wonders why cabal installs 64-bit libs in the 32-bit lib directory
10:59:21 <Cheery> thought, it'd be quite hostile thing.
10:59:40 <Baughn> Cheery: Such things exist, but they're only useful for FFI resources so the finalizers are in that library
11:00:15 <Baughn> Cheery: Anything /not/ FFI-based gets collected. Including handles, apparently, but I don't know if that's haskell or just ghc
11:00:17 <dcoutts_> glguy: we just follow the autoconf defaults, we know nothing of distro-specific conventions
11:00:25 <Cheery> Baughn: can I control it so that all Windows would be gc:ed before closeDisplay?
11:00:33 <dcoutts_> glguy: you can of course use --libdir=/usr/local/lib64 or whatever
11:00:34 <Baughn> Cheery: No
11:00:47 <glguy> dcoutts_: thnx
11:01:00 <Baughn> Cheery: But you could use it to make sure that displays get closed at some point after you lose its handle
11:01:02 <Cheery> thought I'm not sure how Xlib works in this manner.. can I destroy windows after display is done for good?
11:01:12 <Cheery> hm.. except.. of course
11:01:39 <Baughn> Cheery: It's a /fallback/, though. You don't normally want to use it; it's there in case of emergency.
11:01:39 <Cheery> data Window = Window DisplayHandle WindowHandle
11:01:49 <Cheery> but I guess this neither makes it sure
11:02:16 <Baughn> Finalizers just say "if this resource is ever /lost/, this is how we garbage-collect it. Eventualy. Maybe."
11:02:21 <Baughn> There is nothing remotely like a guarantee in there
11:02:46 <Baughn> In fact, it would make sense in some scenarios for a finalizer to terminate your program with extreme prejudice
11:05:40 <Cheery> "The XCloseDisplay function closes the connection to the X server for the display specified in the Display structure and destroys all resources the client has created on this display"
11:06:24 <Cheery> " Therefore, these windows, resource IDs, and other resources should never be referenced again or an error will be generated."
11:06:42 <Baughn> Cheery: That's the X api, yes. What about it?
11:07:33 <byorgey> @pl \x y -> (x /= ".") && (y /= ".")
11:07:33 <lambdabot> (. ("." /=)) . (&&) . ("." /=)
11:07:44 <Cheery> Baughn: so this means, if I add it so that the things that depend on the Display structure will live, I think I can do it like this
11:07:57 <cdsmithus> Suppose I have a finite set S of elements, and a list tuples defining a binary relation R on S, and want to find the equivalence classes of S relative to the transitive, symmetric, reflexive closure of R.  Does anyone have code to do this?
11:07:58 <byorgey> ah, "." `notElem` [x,y]   =)
11:08:22 <Cheery> Baughn: since Xlib does not _require_ that I close all the windows when I exit the building
11:08:33 <Cheery> it closes them anyway
11:08:54 <Cale> cdsmithus: Prof. Wolfram Kahl does, but I don't know if he's released that code.
11:08:55 <Cheery> I'm lucky. :)
11:08:58 <jsnx> cdsmithus: i don't have any code for that
11:08:58 <lambdabot> jsnx: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:09:10 <Cale> cdsmithus: There's also a Data.Rel available somewhere, let me look it up.
11:09:31 <Baughn> Cheery: Yeah. That's basically garbage-collection on part of the X server; closedisplay /closes the connection/; if they were to remain valid after that, that would be a memory leak /in the server/.
11:09:53 <cdsmithus> Cale: Thanks!  I have something kludged up using Data.Graph and scc, but it's very slow.  I did it because it only took about 2 minutes to write.
11:10:17 <jsnx> lambdabot: @tell Philippa no joke -- i'm trying to write a chinese dictionary, and i want to have a big static list of characters, so i'm writing it in C; i'd like it to work on windows, so i can show it to my friends
11:10:17 <lambdabot> Consider it noted.
11:10:28 <byorgey> @pl \x y -> "." `notElem` [x,y]
11:10:28 <lambdabot> (("." `notElem`) .) . (. return) . (:)
11:10:51 <Cheery> Baughn: Why Xlib is so clean anyway? things buildt on it look annoying to handle
11:11:04 <Cheery> but the interface seems this far very nice
11:11:10 <Cheery> I thought it is hell
11:11:12 <Baughn> Cheery: Eleventh-system effect
11:11:23 <Baughn> Cheery: They tried hard to be clean. They just didn't quite succeed all the time.
11:11:28 <Philippa> jsnx: *nod* - people like ndm or dcoutts would have a better idea of how to make it work
11:11:28 <lambdabot> Philippa: You have 1 new message. '/msg lambdabot @messages' to read it.
11:11:44 <Baughn> Cheery: Remember, it's X*11*. There were ten more before it.
11:12:04 <Cheery> I didn't know that! :D
11:12:07 <Baughn> Cheery: Anyway, when it comes to closedisplay, they really had no choice whatsoever
11:12:07 <jsnx> Baughn: no
11:12:13 <Baughn> Cheery: It couldn't possibly act otherwise
11:12:13 <jsnx> Baughn: W came before
11:12:35 <jsnx> the eleven is to turn it up
11:13:12 <Cheery> Baughn: what is the Eleventh-system effect?
11:13:12 <dcoutts_> jsnx: is this the large constant problem?
11:13:27 <jsnx> dcoutts_: no, not this time
11:13:31 <Baughn> Cheery: Something I invented. Second-system effect is real; look that up first
11:13:42 <jsnx> dcoutts_: it's the compile cabal package with c on windows problem
11:13:48 <Cheery> how that explains why those things buildt on top of Xlib seem ugly compared to the lib itself?
11:14:00 <jsnx> dcoutts_: (it is a side effect of my investigations of the large constant problem)
11:14:02 <dcoutts_> jsnx: cabal uses ghc as the C compiler on windows
11:14:11 <Baughn> jsnx: There have been eleven versions of X, at least. Yes, W came before X.. lots of history here
11:14:30 <jsnx> Baughn: okay, maybe you're right -- i will go check wikipedia
11:14:38 <jsnx> dcoutts_: you mean gcc?
11:14:40 <Baughn> jsnx: http://en.wikipedia.org/wiki/X11#History
11:14:46 <Baughn> Cheery: I think the best way to find out that is for you to use it yourself. ;)
11:14:53 <Baughn> Cheery: It isn't as nice as it appears on the surface
11:14:54 <dcoutts_> jsnx: what is the problem? there are a few packages that do successfully use c-sources in a .cabal package on windows (eg zlib)
11:15:00 <Cale> cdsmithus: Sigh, it seems to have started bitrotting, but you can get the UMinho libraries here: http://wiki.di.uminho.pt/twiki/pub/Research/PURe/PUReSoftware/UMinhoHaskellSoftware-1.0.zip
11:15:01 <lambdabot> http://tinyurl.com/3bkefo
11:15:14 <dcoutts_> jsnx: no, I mean ghc. ghc calls gcc to compile C code and passes some extra flags.
11:15:20 <cdsmithus> Cale: Okay, thanks.  I'll take a look.
11:15:25 <Cale> cdsmithus: It contains Data.Relation.* which consists of a bunch of libraries for working with relations in different forms.
11:15:26 <Baughn> Cheery: A large part of that is because it's designed as a concurrent interface, without using any of the nice modern concurrency abstractions we have today
11:15:44 <Baughn> Cheery: (Eg. to deal with lots of latency)
11:15:47 <ptolomy> All Praise Be To GHC 6.8.2! Yea Verily, After My Upgrade From 6.6, My Programmes Performance Hath Doubled!
11:15:55 <dcoutts_> ptolomy: :-)
11:16:06 <Cale> cdsmithus: I know that Dr. Kahl has a much richer version of this, but I don't know when he plans to release it, if ever.
11:16:16 <MyCatVerbs> ptolomy: what, really? Damn, nice.
11:16:23 <olsner> Xlib is pretty neat, but only if you disregard that *doing anything* with it requires registering umpteen "atoms" and setting magic properties to magic values on magic windows (and it's all also some kind of bastardized P2P system)
11:16:54 <dcoutts_> olsner: looked at xcb?
11:16:55 <jsnx> dcoutts_: oh, interesting -- okay, well, that's enough to get me started
11:16:59 <cdsmithus> Cale: Okay, this is great!  I am just going to use it for a few days.  If I end up fixing stuff in this, is there an active maintainer?
11:17:12 <Cale> cdsmithus: I don't know.
11:17:14 <ptolomy> My standard benchmarks went from 1.22s and 4.2s to 0.76s and 2.79s.
11:17:15 <Cale> http://wiki.di.uminho.pt/twiki/bin/view/Research/PURe/PUReSoftware#Download
11:17:17 <lambdabot> http://tinyurl.com/2vmnbu
11:17:22 <Cale> That's where I got it from.
11:17:25 <cdsmithus> Cale: Okay, thanks for your help
11:17:46 <ptolomy> not quite a doubling, but an improvement greater than any that I could've gotten by just about any change to my code.
11:17:56 <gwern> ptolomy: imagine how much faster your programs would run if you switched to a simpler heliocentric algorithm!
11:18:04 <ptolomy> Never!
11:18:40 <Zao> Are there any plans to add a -pgm setting to GHC for picking the C++ compiler?
11:18:56 <gwern> but ptolomy - we've observed the parallax of the stars!
11:19:38 <Baughn> gwern: I tell you, the heliocentric view is wrong. We're *really* all circling around a giant black hole that has never been directly observed
11:19:55 <wli> There is no center.
11:20:54 <gwern> Baughn: you newtonist
11:21:02 <gwern> give up your fantasies of absolute space or time, man!
11:21:17 <gwern> ich ein bin Macher
11:21:28 <Cheery> Baughn: so we're all circling around a software manager who's simply one big hole?
11:21:49 <Cheery> ****hole
11:21:53 <Baughn> Cheery: Repent your sins, for the crunch time is nigh
11:22:27 <olsner> dcoutts_: isn't xcb just a newer API for exactly what xlib does? isn't the difficult part with X11 programming still just deciding what the heck to tell xlib to send to the server?
11:22:58 <Cheery> Baughn: do you eat cheerios for breakfast then?
11:22:59 <dcoutts_> olsner: yes but the x protocol is rather nicer for concurrency than the xlib wrapper over it
11:23:44 <pcc1> it seems that ghc will only search for .hi files in the current directory despite specifying a -hidir
11:24:02 <dcoutts_> olsner: xcb makes it possible to use X in a multi-threaded way sanely and it's consistent with being async in design where as xlib has some bits which are sync apis
11:24:19 <dcoutts_> olsner: generally xcb is nicer all round and the new version of xlib use xcb underneath
11:24:38 <gwern> wasn't sjanssen writing an xcb binding for haskell?
11:24:47 <dcoutts_> pcc1: -hidir is for where to put .hi files, not where to look for them
11:24:59 <dcoutts_> gwern: I thought so
11:24:59 <gwern> 'Massey and others have worked to prove key portions of XCB formally correct, using Z notation. (Xlib has long been known to contain errors.)'
11:25:31 <pcc1> oops disregard question
11:25:46 <ptolomy> Hm. What with Bytestring.findSubstrings having been deprecated, what should I be using?
11:25:55 <Cheery> so xcb has really replaced xlib?
11:26:07 <dcoutts_> ptolomy: there's a separate package on hackage
11:26:12 <ptolomy> Ah.
11:26:23 <ptolomy> That's mildly inconvenient.
11:26:24 <Cheery> there's lots of documentation about xlib so I read that first, I think I'm interested to look into xcb after it
11:26:27 <ptolomy> though I'm sure well justified.
11:26:47 <dcoutts_> Cheery: it's going that way, it's just a matter of getting apps to start migrating, xlib using xcb underneath makes it possible to transition in pieces
11:27:14 <Cheery> on one xcb page, there were a mentioning that it has small footprint, and in next a picture from a cat that has quite big footprint
11:27:41 <Cheery> dcoutts_: but that never happens if gtk and stuff stays on top of xlib
11:28:00 <dcoutts_> Cheery: I'm sure gtk+ will move to using xcb directly eventually
11:28:18 <Cheery> wondering... does haskell have xcb bindings?
11:29:45 <Cheery> second system effect is quite clear on computer gaming and their endless sequels
11:30:21 <dcoutts_> Cheery: ask sjanssen. It's possible to make a really nice interface to hide the async aspect of the X protocol, you can have: do result <- someXcbThing; and your thread only blocks to wait for the reply when you demand the result.
11:30:51 <allbery_b> sjanssen was working on it but is currently not able to work on stuff like this
11:31:19 <Cheery> sjanssen doesn't seem to be on this channel now, ok, I'll ask him
11:33:09 <Philippa> Cheery: no, in general games don't have second system effect as such
11:33:28 <Philippa> for example, it's not Advance Wars 2 that people tend to reckon jumped the shark - it's Advance Wars DS
11:33:49 <gwern> awars 2 was great, althouh the co powers might've been a little unbalanced
11:33:56 <Cheery> yeh, it's Nth system effect
11:34:09 <gwern> a well-timed co power could basically totally destroy you...
11:34:26 <Philippa> Cheery: it's an entirely different effect. Second system is something specific, and doesn't apply to the third
11:34:29 <Cheery> second version may be great, but third version is mostly quite bad
11:34:46 <Cheery> and getting worse after that
11:34:58 <Cheery> megaman series suffers from this thing. :)
11:39:17 * gwern still hasn't figured out this link error with hscurses
11:40:05 <Cheery> @seen sjanssen
11:40:05 <lambdabot> I haven't seen sjanssen.
11:40:38 <shepheb> Cheery: he's been off the net for a couple of weeks, and likely to be for a couple more.
11:40:54 <Cheery> @seen Cheery
11:40:54 <lambdabot> You are in #xmonad and #haskell. I last heard you speak just now.
11:41:16 <gwern> what's up with sjanssen?
11:41:48 <shepheb> gwern: I don't know any details, but he said he'd be mostly off the net for some weeks a while ago.
11:42:22 <gwern> huh. wonder if classes are pressing
11:43:24 <byorgey> dcoutts_: sent
11:43:41 <dcoutts_> byorgey: ta
11:44:41 <dcoutts_> byorgey: if you want to fix up ugly output, I recently made the logging functions wrap text, but lots of calls to die,notice,warn,info etc still use hard-coded \n line breaks
11:46:43 <olsner> argh, I seem to still have O(n^2) space leaks in my inflate
11:47:37 <olsner> nah, probably only O(n), but still... it should be constant-space
11:51:57 <byorgey> dcoutts_: ah, ok
11:59:13 <dcoutts_> dons: the geordi thing is pretty cool, it does all the ptracing in Haskell
11:59:21 <gwern> @seen dark
11:59:21 <lambdabot> I haven't seen dark.
11:59:44 <dcoutts_> dons: sadly it does not ptrace across fork()s so I cannot use it in cabal for testing
12:00:46 <dcoutts_> but that's ok, I've already got haskell code to run processes using the strace program and post-process in the strace output
12:01:05 <lispy> hm...I tihnk I want a syntatic feature that doesn't exist
12:01:06 <dcoutts_> for cabal we just want to know what files were read/written, it's not a security measure
12:01:18 <gwern> still haven't heard from dark about mage's license. guess I'll have to depend on that offhand comment in the logs about it being bsd
12:02:50 <lispy> oh, no it does work!  yay
12:03:24 <lispy> > do { foo@(Just x) <- return 1; return x } :: [Int]
12:03:27 <lambdabot>   add an instance declaration for (Num (Maybe Int))
12:03:32 <gwern> @seen Tchakkazulu
12:03:32 <lambdabot> I haven't seen Tchakkazulu.
12:03:45 <lispy> or well, what I have locally works the way I want
12:03:55 <lispy> that is, you can use @-patterns with do-notation
12:04:34 <Stinger> a <- is just a let expression iirc
12:04:41 <Baughn> @undo do foo@(Just x) <- return 1; return x }
12:04:41 <lambdabot>  Parse error at "}" (column 39)
12:04:43 <Baughn> @undo do foo@(Just x) <- return 1; return x
12:04:43 <lambdabot> return 1 >>= \ a -> case a of { foo@(Just x) -> return x; _ -> fail ""}
12:04:55 <gbacon> @choose 1 2 3
12:04:55 <lambdabot> 1 2 3
12:05:20 <gbacon> @choose "1\n2\n3\n"
12:05:20 <lambdabot> "1\n2\n3\n"
12:05:32 <gbacon> > lines "1\n2\n3\n"
12:05:33 <lambdabot>  ["1","2","3"]
12:06:02 <lispy> > lines "1\n2\n3\n\n"
12:06:04 <lambdabot>  ["1","2","3",""]
12:06:15 <lispy> > unlines ["1","2","3",""]
12:06:16 <lambdabot>  "1\n2\n3\n\n"
12:06:33 <lispy> > unlines ["1","2","3"]
12:06:34 <lambdabot>  "1\n2\n3\n"
12:06:40 <ivan_> hi, is it possible to make an instance of RealFloat with a data type that builds up math expr including a variable?
12:07:16 <lispy> ivan_: I've done something similar with some of the other numeric classes.
12:07:35 <lispy> ivan_: I'm not sure if RealFloat offers some hidden problem though.
12:07:40 <Baughn> ivan_: I don't see why not, though you might want to use a proper math library (or write one)
12:08:18 <lispy> Baughn: the nice thing about using the prelude though, is that your edsl looks like haskell and takes advantage of all the already written prelude math functions
12:08:25 <lispy> I was doing this with Excel formula syntax
12:08:28 <lispy> it was quite handy
12:08:37 <ivan_> i want to implement a representation of laplace transfor where s is the variable and the variable is later on transformed to a complex j*w, i have to somehow use the complex library ist this even possible or do i have to create my own complex type
12:09:25 <sclv> foax here seen the h-store paper? http://db.cs.yale.edu/hstore/vldb07hstore.pdf
12:09:51 <ivan_> or could i just represent the type with the variable hidden, and when returning the complex part i can evaluate it as i want?
12:10:46 <lispy> ivan_: If you made your variable an instance of the right numeric classes I would expect that you can build up expressions or functions and then later evaluate them however you see fit.
12:11:01 <ivan_> sorry droped the connection
12:11:21 <lispy> ivan_: then I will repeat myself
12:11:24 <lispy> ivan_: If you made your variable an instance of the right numeric classes I would expect that you can build up expressions or functions and then later evaluate them however you see fit.
12:12:02 <ivan_> the complex lib uses RealFloat as instance, if i want to use the complex lib does my data type has to be an instance of RealFloat?
12:12:11 <hallongrottan> ivan_: doing programming project, are you?
12:12:19 <ivan_> lol, yes
12:12:21 <hallongrottan> sweet
12:12:21 <sclv> stonebreaker & co. advocating essentially distributed stm as a better mechanism than dbms' for most OLTP
12:12:31 <lispy> ivan_: I haven't tried this with Complex/RealFloat, but yes, that sounds right.
12:13:14 <ivan_> lispy: Complextype is defined as data (RealFloat a) => Complex a
12:14:03 <ivan_> so my question is does that RealFloat a constratin mean that if i want to use Complex my data type has to be an instance of RealFloat
12:14:06 <lispy> Oh, that's really too bad.  There are other, non-real based types of complex numbers :(
12:15:16 <lispy> ivan_: what you want to focus on, is creating some data types to represent your expressions.  Then, make these datatypes instances of the right numeric classes with properly defined operations.
12:15:40 <lispy> ?type sqrt
12:15:43 <lambdabot> forall a. (Floating a) => a -> a
12:15:53 <allbery_b> welcome to the sadness that is the numeric part of the prelude
12:16:06 <lispy> > sqrt (0 :+ 1)
12:16:09 <lambdabot>  0.7071067811865476 :+ 0.7071067811865475
12:16:33 <lispy> ivan_: notice that sqrt didn't require Complex in it's signature
12:16:34 <MyCatVerbs> > sqrt ((-1) :+ 0)
12:16:35 <lambdabot>  0.0 :+ 1.0
12:16:45 <ivan_> lispy: i saw now that complex is an instance of Num Float .... and so on
12:16:55 <MyCatVerbs> > iterate sqrt $ (-1) :+ 0
12:16:56 <lambdabot>  [(-1.0) :+ 0.0,0.0 :+ 1.0,0.7071067811865476 :+ 0.7071067811865475,0.9238795...
12:17:02 <lispy> ivan_: right, so make similar instances for your types
12:17:45 <ivan_> i have alredy made an instance of Num a, but when using complex it complains about that my type is not an instance of RealFloat
12:18:58 <ivan_> lispy: back again
12:20:05 <lispy> ivan_: I can't tell when you leave, and I get bored with repeating myself.  So if you think you missed something, please check the logs.  The url is in the topic.
12:20:43 <shapr> ivan_: You could read the logs?
12:21:50 <dcoutts_> byorgey: for some reason the attachment was scrubbed:
12:21:51 <dcoutts_> http://haskell.org/pipermail/cabal-devel/2008-March/002344.html
12:22:05 <dcoutts_> byorgey: so I'll have to wait 'til I get home to apply the patch
12:22:26 <dcoutts_> unless you want to do a darcs send -o file and post that somewhere
12:35:34 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6142
12:38:01 <Rinn> What? No, I would never do a thing like that.
12:38:37 <oerjan> That's good to know.
12:50:38 <byorgey> dcoutts_: oh!  no, it's just that I'm dumb and forgot to actually attach the patch file =P
12:50:50 <dcoutts_> byorgey: oh ok :-)
12:50:56 <byorgey> I don't have my mail set up right to be able to have darcs send automatically
12:52:06 <byorgey> dcoutts_: resent
12:52:55 <dcoutts_> cheers
13:00:23 <Dave_Herman> @pl \a b -> a >> b >>= return
13:00:23 <lambdabot> flip flip return . ((>>=) .) . (>>)
13:01:25 <oerjan> >>= return is a nop
13:01:31 <Dave_Herman> :)
13:01:50 <olsner> hah! it seems to run in reasonable amounts of memory now... at the cost of unreasonable amounts of time :(
13:02:35 <Cale> olsner: What are you writing?
13:02:46 <olsner> Cale: an un-deflater
13:03:55 <TSC> An inflater?
13:04:15 <olsner> yeah
13:04:52 <oerjan> the clue to inflation is to make it faster than light
13:05:36 <olsner> hmm, the change in behaviour was due to a bug rather than a problem solved :(
13:06:04 <olsner> but it type-checks! how can it *possibly* be wrong?
13:08:38 <gwern> are there any guides anywhere on how to update stuff using FiniteMap?
13:08:58 <gwern> olsner: not enough types
13:09:49 <gwern> that's always the answer to runtime bugs in haskell - needs moar typebell
13:10:36 <Lemmih> gwern: Import Data.Map and let the compiler errors guide you.
13:11:00 <olsner> I think I'd need dependent typing to represent the kind of checks that would catch this bug
13:13:35 <gwern> yay, mage is now teh cabalized
13:13:42 <gwern> time to de-FiniteMap it
13:14:49 <nornagon> record syntax sucks. :(
13:15:26 <dcoutts_> byorgey: perhaps you can help me on my campaign to eliminate parseReadS from cabal's parsers
13:15:39 <dcoutts_> byorgey: it is really bad for forwards compatibility
13:15:59 <byorgey> dcoutts_: what's parseReadS?
13:16:05 <dcoutts_> I'll email the cabal list with my plan
13:16:20 <dcoutts_> byorgey: it's a ReadP parser that uses the Read instance
13:16:28 <byorgey> oh, I see
13:16:32 <dcoutts_> byorgey: we currently use it for parsing enumerations
13:16:46 <dcoutts_> byorgey: like compiler flavour, license, extensions
13:16:54 <byorgey> yes, I can see why we'd want to get rid of that
13:17:04 <dcoutts_> byorgey: but it's really bad because we cannot add new enum values without breaking the parser
13:17:22 <dcoutts_> it does not degrade gracefully
13:17:28 <byorgey> and it makes it hard to gracefully deal with erroneous values, too, doesn't it?
13:17:38 <dcoutts_> yeah
13:18:24 <dcoutts_> byorgey: the worst example is adding new extensions, it totally breaks parsing for older cabal versions when the encounter a new unknown extension
13:18:37 <byorgey> yeah, that sucks.
13:19:14 <dcoutts_> so my plan is this
13:19:15 <__lf> @pl c f x = not (f x)
13:19:15 <lambdabot> c = (not .)
13:19:28 <__lf> (is there a way to ask lambdabot in private?)
13:19:44 <dcoutts_> byorgey: we add a more liberal parser for these things, but we do not accept any new values
13:19:45 <Stinger> /msg lambdabot "stuff"
13:19:58 <__lf> Stinger: i tried but it doesn't answer
13:20:00 <dcoutts_> byorgey: eg we'd parse "ghc" as OtherCompiler "ghc" rather than as GHC
13:20:11 <dcoutts_> byorgey: then we just make hackage reject OtherCompiler _
13:20:14 <Stinger> it opens a new chat window for me in xchat
13:20:16 <byorgey> dcoutts_: yeah, that sounds good.
13:20:34 <gwern> interesitng. finitemap had an addlisttofm function, but I can't find any equivalent in data.map for 'Map k a -> [(k, a)] -> Map k a'
13:20:46 <dcoutts_> byorgey: but in future when we add new enum values, old cabal versions will parse it as OtherCompiler "yhc" and not break horribly
13:20:49 <byorgey> __lf: it might only respond if you are registered.
13:20:51 <oerjan> __lf: to send /msg on freenode you need to be registered
13:21:03 <Stinger> really? I dont usually register
13:21:09 <__lf> ok, that makes sense
13:21:15 <oerjan> oh wait
13:21:36 <oerjan> lambdabot _tries_ to set an option to accept anyhow, but sometimes fail, iirc
13:21:51 <allbery_b> recipients can tell nickserv to let them receive /msg from anyone (which requires the recipient to be registered)
13:21:57 <allbery_b> hm
13:21:59 <__lf> aha
13:22:02 <allbery_b> I thought it was sticky
13:22:02 <__lf> lambdadot can receive but can't send
13:22:09 <allbery_b> oh, right
13:22:14 <allbery_b> it's only one way
13:22:38 <allbery_b> so the recipient would also have to declare... which requires nickserv to know about them, i.e. they must be registered... round and round we go
13:22:40 <Stinger> I dunno, seems to work ok for me (not registered currently)
13:22:42 <__lf> so lambdadot gets the friendly registration reminder
13:22:45 <allbery_b> ah
13:22:53 <gwern> @hoogle Ord key => Map key elt -> key -> Map key elt
13:22:53 <lambdabot> Did you mean: Ord key => Map Key Elt -> Key -> Map Key Elt
13:22:53 <lambdabot> Data.Map.delete :: Ord k => k -> Map k a -> Map k a
13:22:53 <lambdabot> Data.Map.insert :: Ord k => k -> a -> Map k a -> Map k a
13:24:08 <MyCatVerbs> @pl \ f g -> f >>= \a -> g >>= \b -> return (a:b)
13:24:08 <lambdabot> liftM2 (:)
13:24:36 <MyCatVerbs> @src liftM
13:24:36 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
13:24:44 <MyCatVerbs> @src liftM2
13:24:45 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:25:26 <dcoutts_> byorgey: I'm not sure the reflowing is working, what does cabal list --installed base produce for you?
13:25:29 <pjd> liftM2 f x y = liftA2 f x y = f <$> x <*> y
13:25:45 <__lf> @src (<*>)
13:25:45 <lambdabot> Source not found. :(
13:25:53 <allbery_b> gwern: M.union . M.fromList -- ?
13:25:55 <MyCatVerbs> pjd: is that <$> from Control.Applicative?
13:25:59 <pjd> yep
13:26:05 <byorgey> dcoutts_: hmm... what's wrong with it?
13:26:15 <pjd> MyCatVerbs: it's the same as fmap/liftM
13:26:33 <pjd> (conceptually)
13:26:47 <pjd> and <*> is `ap`
13:27:24 <hpaste>  dcoutts pasted "reflowing descriptions in cabal list output" at http://hpaste.org/6143
13:27:25 <MyCatVerbs> > sequence ["ab","cd"]
13:27:27 <lambdabot>  ["ac","ad","bc","bd"]
13:27:37 <gwern> allbery_b: I think I found a compatibility file someone wrote implementing finitemap in terms of map so I'll crib from that
13:27:38 <dcoutts_> byorgey: ^^ see the hpaste
13:27:41 <oerjan> gwern: just use foldl' + insert i think - fromList uses that anyhow
13:28:02 <byorgey> dcoutts_: hmm... you're right
13:28:08 <pjd> MyCatVerbs: in short, <$> is application for when the right side is a functor, and <*> is application for when both sides are
13:28:22 <pjd> f <$> x == pure f <*> x
13:28:32 <MyCatVerbs> pjd: oooooooooh.
13:28:37 <dcoutts_> byorgey: you can use the wrapLine if you like, I've gotta go, I've pushed the patch anyway since it was an improvement on the previous output
13:28:39 <byorgey> dcoutts_: hmm... I think there's something about how the pretty-print library works that I don't understand
13:28:46 <MyCatVerbs> pjd: I think you just saved me quite a lot of headachin' there.
13:28:51 <byorgey> dcoutts_: ok, see you later.  I'll fiddle =)
13:29:22 <MyCatVerbs> > sequence ["ab","cd","ef"]
13:29:23 <lambdabot>  ["ace","acf","ade","adf","bce","bcf","bde","bdf"]
13:29:39 <__lf> wow
13:29:47 <MyCatVerbs> > sequence ["abc","de","fg"]
13:29:48 <lambdabot>  ["adf","adg","aef","aeg","bdf","bdg","bef","beg","cdf","cdg","cef","ceg"]
13:30:43 <MyCatVerbs> > sequence (map Just [1..10])
13:30:45 <lambdabot>  Just [1,2,3,4,5,6,7,8,9,10]
13:30:52 <pjd> (,) <$> ["hello","howdy"] <*> ["world","pardner"]
13:30:56 <pjd> > (,) <$> ["hello","howdy"] <*> ["world","pardner"]
13:30:57 <lambdabot>  [("hello","world"),("hello","pardner"),("howdy","world"),("howdy","pardner")]
13:35:04 <MyCatVerbs> pjd: it's vaguely annoying how these things all sort of come together in sudden chunks rather than smoothly. :)
13:35:16 <pjd> > foldr (:) [] ['a','d','f']
13:35:17 <lambdabot>  "adf"
13:35:39 <pjd> > foldr (liftA2 (:)) (pure []) ["abc","de","fg"]
13:35:40 <lambdabot>  ["adf","adg","aef","aeg","bdf","bdg","bef","beg","cdf","cdg","cef","ceg"]
13:35:57 <MyCatVerbs> Who in the name of Kleisli is this person Kleisli, anyway? :)
13:36:15 <luqui> does anyone know when STM support was first introduced into the haskell libraries?
13:36:32 <luqui> (just the year will suffice)
13:37:33 <__lf> is there a nice idiom for  "sequence_ (replicate n x)"
13:37:47 <olsner> replicateM_ iirc
13:37:53 <__lf> d'oh
13:37:55 <__lf> thanks :)
13:38:10 <nornagon> @src replicateM_
13:38:10 <lambdabot> replicateM_ n x = sequence_ (replicate n x)
13:38:57 <MyCatVerbs> @src replicate
13:38:57 <lambdabot> replicate n x = take n (repeat x)
13:39:04 <kalmar> ?. pl src replicateM_
13:39:05 <lambdabot> (line 1, column 1):
13:39:05 <lambdabot> unexpected end of input
13:39:05 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
13:39:17 <__lf> i love that "make infinitely many, then take n of them" approach
13:39:47 <byorgey> __lf: yep, it's a very nice approach indeed =)
13:39:48 <MyCatVerbs> sequence . repeat $ putStrLn "BASIC drools, Haskell rules."
13:39:56 <dons> luqui:
13:39:57 <oerjan> kalmar: @. doesn't work with @src for some reason
13:39:58 <dons> Fri Jan  7 03:37:02 PST 2005  simonmar * [project @ 2005-01-07 11:37:02 by simonmar] Add unsafeIOToSTM
13:40:10 <byorgey> __lf: decoupling generation from consumption
13:40:17 <luqui> dons, thanks!
13:40:30 <gwern> gah.. this error look familiar to anyone? 'gcc: dist/build/mage/mage-tmp/curses_wrapper.o: No such file or directory
13:40:31 <MyCatVerbs> ^^ I should get that printed up on a shirt to counterbalance all the lamers in the "10 PRINT \"BASIC RULES\" \n GOTO 10" shirts
13:40:39 <glguy> birkenfeld: you about?
13:40:45 <gwern> src/curses_wrapper.h is listed in the c-sources:
13:40:59 <oerjan> MyCatVerbs: you mean forever
13:41:00 <dons> luqui: also, precisely,
13:41:02 <dons> Tue Dec 14 07:59:08 PST 2004  simonmar * [project @ 2004-12-14 15:59:08 by simonmar] Add basic libraries for STM (Software Transactional Memory).
13:41:15 <gwern> (how galling that the makefile works when cabal doesn't)
13:43:27 <gwern> I am also confused by the command the makefile runs, 'ghc -O -fvia-C -Wall -ffi --make Main.hs -odir build -hidir build -o mage -lncurses '-#include "curses.h"'', which makes no mention of curses_wrapper.h
13:44:57 <MyCatVerbs> oerjan: let forever = sequence . repeat in forever (putStrLn "Fuck BASIC.") -- ?
13:45:06 <oerjan> :t forever
13:45:20 <oerjan> @bot
13:45:20 <lambdabot> :)
13:45:21 <lambdabot> thread killed
13:45:25 <oerjan> :t forever
13:45:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
13:45:39 <__lf> oerjan: 'forever' is too easy to read for a t-shirt. you want foldr1(>>))[1..]>>[print "foo"]) or something
13:46:05 <oerjan> putStr . unlines . repeat
13:46:12 <dons> ?src forever
13:46:12 <lambdabot> Source not found. Maybe if you used more than just two fingers...
13:46:24 <oerjan> MyCatVerbs: sequence_ essentially
13:46:38 <oerjan> dons: ?src for 6.8 functions?  optimist...
13:46:50 <MyCatVerbs> oerjan: oh of course. But would it really make all that much difference?
13:47:13 * MyCatVerbs presumes it'd cause the program to waste some time GCing, but aside from that, any issues?
13:47:13 <oerjan> MyCatVerbs: i expect sequence would eventually run out of memory/stack
13:47:13 <glguy> MyCatVerbs: language..
13:47:34 <oerjan> with an infinite list, and IO
13:48:34 <oerjan> because it is probably not clever enough to recognize that the collected results will never be used
13:49:42 <olsner> I believe I've reached the maximum nesting depth of my brain [(Word, [(Word, (a, (Int, a1)))])]
13:50:09 <__lf> olsner: you need to break the stack in the middle
13:50:14 <oerjan> max 7 items, or something like that
13:51:08 <__lf> I would have given up and started naming stuff one or two levels ago :)
13:51:17 <junmin> hello all, i defined 0 as a number of church zero = \f -> (\x -> x), but when i run ghci, and type zero, it return me an error message ttp://rafb.net/p/HnWM4w29.html .. ading "deriving Show" is not working
13:51:28 <__lf> junmin: you can't print a function
13:51:49 <olsner> hmm, and now I've got something that takes a function taking that type
13:52:25 <Baughn> oerjan: There was a case of a sequence memory leak here a few days ago, but this makes me wonder now - exactly what pointer is keeping the GC from collecting? Or does it get stacked?
13:52:52 <gwern> @seen dcoutts_
13:52:52 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell, #haskell-overflow and #ghc. I last heard dcoutts_ speak 24m 15s ago.
13:53:17 <oerjan> @src sequence
13:53:17 <lambdabot> sequence []     = return []
13:53:17 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
13:53:17 <lambdabot> --OR
13:53:17 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
13:53:49 <oerjan> Baughn: in order to know that it can drop v it needs to know that it will never reach the return
13:54:18 <oerjan> unless it has a special check for infinite lists that is not going to happen...
13:55:45 <Cheery> does haskell have some tool to keep a table about reserved identifiers?
13:56:07 <Baughn> oerjan: It makes me sad that the details of haskell's runtime system will probably remain a mystery to me for the next few months
13:56:19 <Lemmih> Cheery: Say again?
13:56:24 <oerjan> Cheery: Parsec has
13:56:58 <oerjan> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#ParsecToken
13:57:00 <lambdabot> http://tinyurl.com/2p5p89
13:57:10 <gwern> gah. I guess I'll drop this cabal build problem until someone like dcoutts shows up
13:57:29 <oerjan> the reservedNames field of LanguageDef
13:57:37 <dcoutts> @yarr!
13:57:37 <lambdabot> Gangway!
13:57:45 <dcoutts> gwern: what problem? :-)
13:59:07 <Cheery> well, thing like, I have numbers from N to N+Y
13:59:20 <gwern> dcoutts: check out mage on hackage and my scrollback
13:59:26 <Cheery> I'd need to keep bookkeeping about which numbers are reserved
13:59:26 <Baughn> oerjan: Instead of detecting infinite lists, it should be possible to detect that sequence's return value is never used
13:59:30 <oerjan> Baughn: i could also imagine it doing something backward with rules... turning sequence into sequence_ if the resulting value is never used
13:59:35 <gwern> dcoutts: I had a header, curses_wrapper.h, which just isn't getting included in dist/ when I build
14:00:03 <oerjan> Baughn: yeah, say sequence l >> x ==> sequence_ l >> x
14:00:08 <Baughn> oerjan: Pure code would do that, right? Or at least, laziness would prevent it from being constructed in the first place
14:00:12 <gwern> dcoutts: I've been trying various permutations of extra-source-files, c-sources, includes: etc and haven't had any successfuly builds despite a simle makefile which builds and links fine
14:00:55 <oerjan> Baughn: if you mean non-monadic code
14:01:46 <gwern> dcoutts: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mage-1.0
14:01:47 <dcoutts> gwern: c-sources: blah.h is definitely wrong
14:01:48 <lambdabot> http://tinyurl.com/3ysth9
14:02:37 <Baughn> oerjan: I'm thinking out loud, trying to figure out how haskell could be implemented. Problem is, except "with the utmost difficulty" I'm not getting very far
14:02:50 <oerjan> heh
14:04:01 <oerjan> Cheery: oh so you don't mean specifically for a parser... try Data.Set, or Data.Map if you want to include additional data with each number.
14:05:34 <oerjan> Cheery: Data.Map is the most common way of doing tables in Haskell
14:06:37 <oerjan> actually for Ints there is a more effective Data.IntMap
14:06:51 <luqui> Cheery, one of my favorite ways to keep track of unique identifiers as numbers is to store a free list
14:07:07 <luqui> pull from the free list when you need one, push on to the front when you're done
14:07:10 <luqui> and initialize to [1..]
14:07:15 <luqui> (that last part is the cool part)
14:08:08 <dcoutts> gwern: use extra-source-files: src/curses_wrapper.h to get the .h file into the sdist .tar.gz and use include-dirs: src so that the .h file will be found via simply "curses_wrapper.h"
14:08:33 <dcoutts> gwern: look at the FFI decls, they say:
14:08:33 <dcoutts> foreign import ccall unsafe "curses_wrapper.h" getx :: WINDOWptr -> IO CInt
14:09:01 <dcoutts> oh, wait they're just wrong
14:09:07 <dcoutts> they do not name any C function
14:09:25 <dcoutts> just the header file, unless that's a legal contraction that I've never seen before
14:09:38 <dcoutts> anyway, so that means they expect curses_wrapper.h to be on the include search path
14:10:03 <dcoutts> so since that .h file lives in src/ then you have to use include-dirs: src
14:11:50 <gwern> dcoutts: hm. I think I see
14:12:14 <gwern> it doesn't know to look locally, so you have to specofy that
14:12:19 <wagle> :t [1..] !! 3000
14:12:20 <lambdabot> forall t. (Enum t, Num t) => t
14:12:46 <wagle> i wanna know why the type cant be Int?
14:13:01 <oerjan> of course it can
14:13:12 <oerjan> Int is both an Enum and a Num
14:13:25 <dcoutts> gwern: once you start pre-processing there's really no such thing as local
14:13:40 <wagle> its gotta decide if i try to take the maxBound::Int'th element
14:13:55 <dcoutts> gwern: local .h files are different to . being on the include search path
14:14:20 <oerjan> wagle: that test is included in the Enum instance
14:14:46 <dcoutts> gwern: I think 'local' doesn't work for ghc anyway since it compiles it's .c files in a temp dir so that's never next to the 'local' .h files
14:14:51 <oerjan> > length [1::Int ..]
14:14:53 <wagle> @instances Enum
14:14:54 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
14:14:54 <lambdabot> Terminated
14:15:05 <oerjan> a bit too big perhaps
14:15:12 <wagle> yeah
14:15:22 <oerjan> > [maxBound-10 ::Int ..]
14:15:23 <lambdabot>  [2147483637,2147483638,2147483639,2147483640,2147483641,2147483642,214748364...
14:15:28 <oerjan> > [maxBound-3 ::Int ..]
14:15:28 <lambdabot>  [2147483644,2147483645,2147483646,2147483647]
14:15:37 <gwern> dcoutts: ok, I'll try that
14:16:09 <wagle> yeah, but you told it which type
14:16:25 <oerjan> sure
14:16:37 <oerjan> there are many types that could fit otherwise
14:16:58 <wagle> > maxBound :: Int
14:16:59 <lambdabot>  2147483647
14:17:06 <oerjan> > [maxBound-3 ::Int64 ..]
14:17:07 <lambdabot>  [9223372036854775804,9223372036854775805,9223372036854775806,922337203685477...
14:17:18 <dcoutts> gwern: hmm, I get lots of linker errors and I was getting an undeclared c error too
14:17:28 <dcoutts> gwern: try building with --ghc-option=-fvia-C
14:17:39 <wagle> > [2147483645..]
14:17:40 <lambdabot>  [2147483645,2147483646,2147483647,2147483648,2147483649,2147483650,214748365...
14:18:03 <oerjan> wagle: Integer is the default though
14:18:10 <dcoutts> gwern: do you not need to link to with the curses lib?
14:18:21 <oerjan> but that's not Bounded
14:18:21 <luqui> > [maxBound-3 :: Integer .. ]    -- :-p
14:18:21 <lambdabot>   add an instance declaration for (Bounded Integer)
14:18:30 <wagle> yeah, i know
14:18:46 <oerjan> > maxBound
14:18:47 <lambdabot>  ()
14:18:48 <dcoutts> gwern: yes, you need extra-libraries: curses or it doesn't even link
14:19:23 <dcoutts> gwern: did you bother compiling it before uploading to hackage ;-)
14:20:02 <wagle> i guess i was scratching my head over the fact that Integer being a default isn't indicated in the type
14:20:19 <oerjan>  :t doesn't do defaulting
14:20:20 <olsner> in a where clause, how can I refer to type variables in the type of the top-level function?
14:21:12 <mauke> can't
14:21:13 <oerjan> olsner: you need an extension (ScopedTypeVariables ?)
14:21:39 <oerjan> and the type declaration for the top-level function must include foralls
14:21:40 <olsner> is it in ghc?
14:21:42 <wagle> yeah..  i said "scratching my head" to indicate my puzzlement as to whether not showing defaults is right or wrong
14:21:51 <luqui> olsner, and then in that case, any variable you introduce explicitly with "forall" can be used in the rest of the function definition
14:22:08 * luqui doesn't like defaulting
14:22:27 <oerjan> i think if you introduce one with forall you must introduce all iirx
14:22:29 <oerjan> *c
14:22:35 <luqui> oerjan, yeah...
14:22:56 <olsner> thanks! I'll try
14:22:57 <oerjan> > typeOf [1..]
14:23:01 <lambdabot>  [Integer]
14:23:10 <gwern> dcoutts: I did, but I was using the makefile for convenience
14:23:31 <wagle> :t typeOf
14:23:33 <lambdabot> forall a. (Typeable a) => a -> TypeRep
14:24:18 <oerjan> needs to be monomorphic (after defaulting) for typeOf though
14:24:32 <oerjan> > typeOf id
14:24:35 <lambdabot>  Add a type signature
14:24:47 <oerjan> > typeOf (+1)
14:24:49 <lambdabot>  Integer -> Integer
14:25:00 <wagle> > typeOf typeOf
14:25:01 <lambdabot>  Add a type signature
14:25:15 <wagle> @instances Typeable
14:25:16 <lambdabot> Couldn't find class `Typeable'. Try @instances-importing
14:25:33 <oerjan> @instances- Data.Typeable Typeable
14:25:33 <lambdabot> s a
14:25:42 <oerjan> heh
14:26:18 <oerjan> Typeable may be a bit special
14:26:24 <olsner> hmm, this doesn't work: buildTable :: forall a . (Eq a, Show a) => [(Int,a)] -> PrefixTable a
14:26:32 <olsner> parse error on input `=>'
14:26:52 <mauke> needs more extensions
14:27:50 <olsner> what was the flag to list all available language flags again?
14:28:55 * oerjan saw that earlier today and promptly forgot it again
14:28:56 <olsner> or do I need glasgow-exts?
14:29:02 <gwern> dcoutts: hm. you've gotten it to build through cabal? could you hpaste your .cabal version? I've followed your suggestions and it winds up with link errors
14:29:22 <oerjan> it's weird that ScopedTypeVariables isn't enough...
14:29:42 <olsner> ah, ghc --supported-languages
14:30:07 <olsner> oh, forgot to write LANGAUGE :P
14:30:22 <oerjan> s/AU/UA/
14:30:38 <rnorris> anyone out there ever added an instance MonadError to CCT? ... thought I'd check before diving into it. CCT is scary voodoo
14:52:13 <dcoutts> gwern: did you tell it to link with curses?
14:52:45 <gwern> dcoutts: I have the 'extra-libraries:     curses' field in the execuitable section
14:56:34 <dcoutts> gwern: I think it's because curses.h is a pita and uses macros which change the C function names
14:56:49 <dcoutts> gwern: it works for me -fvia-C and fails otherwise
14:58:27 * gwern will try fvoac
14:59:40 <dcoutts> gwern: yeah, the curses.h file is full of crap
14:59:49 <dcoutts> #define NCURSES_ACS(c)  (acs_map[NCURSES_CAST(unsigned char,c)])
14:59:52 <dcoutts> for example
14:59:59 <dcoutts> there's no way to link to that using:
15:00:05 <dcoutts> foreign import ccall unsafe "curses.h & ACS_UARROW" acs_uarrow :: Ptr ChType
15:00:08 * gwern deosn't know enough C to appreciate the crappinbess of that
15:00:45 <dcoutts> gwern: the Haskell FFI can reference ABI linker symbols, not arbitrary C expressions
15:01:27 <dcoutts> similarly this will not work:
15:01:29 <dcoutts> #define xwattrset(win,at) wattrset((WINDOW *)(win),(at))
15:01:45 <dcoutts> you cannot use the Haskell FFI to import xwattrset because there is no xwattrset
15:01:51 <dcoutts> there is only wattrset
15:02:16 <gwern> looks like -fvia-c errors during linking with: In file included from /usr/lib64/ghc-6.8.2/include/Stg.h:150,
15:02:19 <gwern> from /tmp/ghc923760_0/ghc923760_0.hc:3:0:
15:02:22 <gwern> /tmp/ghc923760_0/ghc923760_0.hc: In function sQnT_ret:
15:06:29 <dcoutts> gwern: can you hpaste the rest of the error
15:06:42 <dcoutts> gwern: and you did clean and rebuild right?
15:06:49 <dcoutts> after adding ghc-options: -fvia-C
15:07:19 <gwern> dcoutts: sure, and yes
15:09:21 <dcoutts> gwern: btw, this is going to break horribly when ghc stops supporting compiling via C
15:09:56 <gwern> dcoutts: I'm still wondering how the makefile works so smoothly, personally
15:10:15 <dcoutts> gwern: I cannot see the makefile so I can't say
15:10:21 <hpaste>  gwern pasted "mage makefile" at http://hpaste.org/6144
15:10:30 <DRMacIver> Syzygy-: What's the "wrong datatype" status message about? :)
15:10:34 <gwern> it uses -fvia-c yes
15:11:29 <dcoutts> gwern: and also it uses -lncurses '-\#include "curses.h"'
15:12:23 <dcoutts> which corresponds to extra-libraries: curses and includes: curses.h
15:12:48 <gwern> hm. not the wrapper
15:13:03 <dcoutts> gwern: no, that's not needed by client code
15:15:23 <gwern> and that does indeed do the trick
15:16:42 <olsner> argh, I just refactored my program into oblivion out of confusion about what it should be doing... too tired to code!
15:16:57 <dcoutts> gwern: you can drop the -O2 btw
15:17:39 <dons> -O2 forever!
15:17:44 <dons> long live -O2!
15:17:54 <dons> end discrimination against -O2 *now*!
15:18:11 <smg> -O2 is good -O3 sucks
15:18:39 <gwern> dcoutts: what's so bad abolut -O2?
15:19:03 <olsner> what's wrong with -O2?
15:19:05 <dcoutts> gwern: it takes ages to compile and for most code doesn't make it go faster
15:19:13 <smg> mh.
15:19:15 <dcoutts> gwern: and it prevents users choosing
15:19:23 * gwern refuses to believe that! what's good for the shootout is good for the gander
15:19:30 <dcoutts> cabal already lets people choose what optimisation level you want
15:19:41 <dcoutts> cabal install foobar -O2
15:19:44 <dcoutts> cabal install foobar -O0
15:19:51 <dcoutts> and the default is -O1
15:20:24 <dcoutts> if you override that by putting ghc-options: -O or -O2 then the user doesn't get the choice any more
15:20:27 <smg> mh if COMPILE time matters -O2 isn't good
15:20:36 <smg> but if COMPILE time does not matter i choose -O2
15:21:02 <dcoutts> for some packages -O2 is totally justified because they're using techniques that need optimisations that only apply at -O2
15:21:11 <dcoutts> but for most packages it's not worth it
15:21:32 <dcoutts> -O2 is where the ghc hackers put experimental stuff they don't really expect people to use
15:21:47 <smg> haha so what's in -O3 then? :]
15:21:50 <dcoutts> things that have not got a proven time/space tradeoff
15:21:55 <dcoutts> smg: there is none
15:22:02 <olsner> is -O3 still "no optimization"?
15:22:09 <dcoutts> olsner: no, it's caped at 2
15:22:17 <dcoutts> so -O3 = -O2
15:22:18 <smg> ah no one needs -O3
15:22:28 <olsner> I guess that applies to -O1337 too?
15:22:53 <smg> olsner: sure
15:22:59 <gwern> good new, everyon!
15:23:05 <gwern> you can now cabal install mage
15:23:53 <Saizan> what is it?
15:24:20 <vincenz> Anyone use GHC on mac?
15:28:49 <gnuvince_> @src (>>)
15:28:49 <lambdabot> m >> k      = m >>= \_ -> k
15:28:57 <gnuvince_> @src (>>=)
15:28:57 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
15:34:18 <dons> i'm not sure we have numbers on -O2 not helping most code
15:34:26 <dons> i don't think we know do we?
15:34:39 <dons> i suppose i could do nobench at -O and -O2 and compare
15:37:51 <Mr_Awesome> @src [] (>>=)
15:37:51 <lambdabot> m >>= k     = foldr ((++) . k) [] m
15:37:59 <Mr_Awesome> @src Maybe (>>=)
15:37:59 <lambdabot> (Just x) >>= k      = k x
15:38:00 <lambdabot> Nothing  >>= _      = Nothing
15:38:31 <Mr_Awesome> @src IO (>>=)
15:38:31 <lambdabot> m >>= k     = bindIO m k
15:42:00 <bla123> i looked for pcres on hackage and was surprised to find 3: pcre-light, pugs-hsregex and regex-pcre. any recommendations?
15:42:08 <dons> pcre-light
15:42:15 <dons> smallest, and i'm happy to answer questions
15:42:24 <dons> it has less magics than regex-pcre though
15:42:36 <bla123> is it stable? why are there so many? they look very similar
15:42:40 <dons> pugs-hsregex is obsolete, and was merged into regex-pcre
15:42:47 <dons> pcre-light is stable, yeah. so is regex-pcre
15:43:08 <bla123> what is better about pcre-light then?
15:43:09 <dons> regex-pcre has a more complex interface, and is less tested than pcre-light, imo (i'm the pcre-light author)
15:43:24 <dons> smaller, 100% code coverage, used in other projects
15:43:45 <dons> we use pcre-light in some commercial stuff, fwiw.
15:43:47 <bla123> dons: thanks, that was a very helpful and fast answer
15:43:48 <dons> :)
15:44:13 <dons> i'd say, try pcre-light, if it doesn't have some of the fancier matching magic you'd like, try regex-pcre.
15:44:14 <bla123> ok, i guess its radiation hard then
15:44:19 <dons> probably pcre-light will be fine.
15:44:30 <bla123> ok, thanks
15:45:18 <dcoutts> dons: you're not still using cabal-setup are you?
15:45:33 <dons> i am, yes.
15:45:37 <dons> but an older build
15:46:37 <dcoutts> dons: get with the programme!
15:47:00 <dcoutts> dons: cabal does all that cabal-setup used to do, with nicer defaults and all the other goodness
15:47:40 <travisbrady> dons: if i'm going to handle pretty large chunks of data is it potentially inefficient to use interact from the ByteString lib?
15:47:45 <dons> dcoutts: 1.4.x from darcs?
15:48:09 <dcoutts> dons: yes, Cabal 1.3.x from darcs and cabal-install also from darcs
15:48:11 <dons> travisbrady: hmm. for trivial things, lazy bytestring interact would be ok.
15:48:18 <dons> dcoutts: ok. will do.
15:48:39 <travisbrady> dons: thank you.  for larger/more complex things I should look into doing chunked reading?
15:49:00 <dcoutts> dons: once you've got it, try cabal list xmonad :-) and if you're a bash user try the command line completion
15:49:04 <dons> no no, lazy bytestrings handle that for you,travisbrady
15:49:11 <dons> but you might want to decouple reading and writing
15:49:20 <dons> dcoutts: ok. sounds fun!
15:49:46 <travisbrady> dons: ahhh, awesome!
15:50:33 <smg> yeah bytestrings ftw
15:52:41 <gnuvince_> @seen Jedai
15:52:41 <lambdabot> Jedai is in #perl6 and #haskell. I last heard Jedai speak 5h 50m 14s ago.
15:53:02 <Jedai> gnuvince_: Yes ?
15:53:38 <MarcWeber> Igloo: do you have a somall example how to use your PostgreSQL C bindings?
15:53:53 <gnuvince_> Jedai: nothing, just checking :)
15:54:10 <rnorris> vincenz: (half an hour later) yes, i use ghc on a mac
15:55:51 <Igloo> MarcWeber: http://urchin.earth.li/darcs/ian/bark/ uses it
15:55:52 <lambdabot> Title: Index of /darcs/ian/bark
15:57:19 <MarcWeber> Igloo: You haven't added pq as needed lib to the cabal file. Is this intentionally?
15:57:21 <dons> git ghc up to 2001-03-15
15:57:56 <Igloo> MarcWeber: To which cabal file?
15:58:06 <MarcWeber> Igloo: of PostgreSQL
15:58:18 <MarcWeber>   echo \"extra-libraries: pq\" >> PostgreSQL.cabal
15:58:29 <Igloo> MarcWeber: Where are you looking?
16:00:26 <MarcWeber> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/PostgreSQL-0.2 @Igloo
16:00:28 <lambdabot> http://tinyurl.com/3bj8ew
16:02:11 <Igloo> MarcWeber: Hmm, no idea, sorry
16:02:42 <malsyned> Is there a function that takes two lists and returns True if the first is a subsequence of the second?
16:02:47 <malsyned> in the prelude?
16:03:02 <Saizan> ?index isInfixOf
16:03:02 <lambdabot> bzzt
16:03:21 <Saizan> ?type Data.List.isInfixOf
16:03:22 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
16:03:26 <malsyned> Saizan: thanks
16:03:53 <MarcWeber> Igloo: bark seems to use SQLite3. Never mind thanks for your replying
16:04:24 <Igloo> Hmm, I wonder what I made the postgres bindings for then
16:07:50 <mae> is there an equivalent to this ruby ["foo","bar"].join(',')
16:07:58 <mae> in haskell ; )
16:08:12 <smg> maybe
16:08:25 <Saizan> intercalate
16:08:37 <smg> mae: unwords ["foo", "bar"] ?
16:08:42 <Saizan> > intercalate "," ["foo","bar"]
16:08:43 <lambdabot>  "foo,bar"
16:08:45 <smg> > unwords ["foo", "bar"]
16:08:45 <lambdabot>  "foo bar"
16:08:48 <smg> ah damn
16:08:51 <gnuvince_> Lists are a Monad instance?
16:08:52 <smg> intercalate is more generel
16:08:53 <malsyned> concat $ intersperse "," ["foo", "bar"]
16:08:57 <smg> gnuvince_: true
16:09:01 <mae> ah ok
16:09:02 <gnuvince_> smg: thanks.
16:09:05 <mae> perf
16:09:09 <mae> ty
16:09:12 <malsyned> oh.  hah.  I just gave the definition of intercalate
16:09:17 <gnuvince_> smg: that explains something that had been mothering me.
16:09:22 <smg> malsyned: haha
16:09:24 <gnuvince_> bothering*
16:09:36 <smg> gnuvince_: yeah lists are monads that screw me up too last night
16:09:53 <malsyned> I seriously thought "intercalate" was a joke until I hoogled it.
16:10:04 <smg> gnuvince_:
16:10:11 <smg> type at ghci :info []
16:10:14 <smg> @info []
16:10:14 <lambdabot> []
16:10:24 <smg> oh lambdabot won't do it
16:10:32 <smg> malsyned: why?
16:10:44 <malsyned> smg: because it's a silly-sounding word.
16:11:05 <smg> mh, i learned many "silly-sounding" words in the last 14 days :))
16:11:25 <smg> join "," ["foo","bar"] :)
16:11:36 <smg> gnuvince_: you like it? :)
16:11:43 <Cale> > intercalate ", " (words "this is a bunch of words")
16:11:44 <lambdabot>  "this, is, a, bunch, of, words"
16:11:58 <smg> Saizan: you know also the inverse element of intercalate?
16:12:01 <Cale> join is taken, for a more important function
16:12:20 <Cale> :t join
16:12:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:12:23 <Saizan> smg: it's not anywhere in the stdlib
16:12:48 <smg> Saizan: ?
16:12:59 <pjd> @check (\f g xs -> ((f <$> g) <$> xs) == (f <$> (g <$> xs))) :: (Int -> Int) -> (Int -> Int) -> [Int] -> Bool
16:13:00 <lambdabot>  OK, passed 500 tests.
16:13:02 <smg> join + fmap will be >>= :)
16:13:15 <Saizan> smg: oh, wait, inverse element?
16:13:17 <pjd> @check (\f g xs -> ((f <$> g) <$> xs) == (f <$> (g <$> xs))) :: (String -> String) -> (String -> String) -> Maybe String -> Bool
16:13:18 <lambdabot>  OK, passed 500 tests.
16:13:28 <gnuvince_> smg: like "it"?
16:13:37 <smg> gnuvince_: you have ghci?
16:13:41 <gnuvince_> Yes
16:13:51 <smg> gnuvince_: type in it :info []
16:14:00 <smg> you will see that list is a moand
16:14:06 <gnuvince_> Ah
16:14:20 <smg> Saizan: yeah i want to go back from "foo,bar" to ["foo", "bar"]
16:14:28 <dino-> Interesting that I can use intercalate here but must qualify with Data.List in ghci on my system.
16:14:58 <mae> any way to ask haskell what the attributes of a datatype are
16:15:02 <smg> dino-: mh import Data.List (intercalate) as intercalate ?
16:15:03 <dino-> I mean, use here without full module name.
16:15:11 <smg> mae: :type foo ?
16:15:25 <mae> in ghci or is that compiled..
16:15:35 <dino-> smg: ya, I know how, I was wondering why it's in the global namespace here right now.
16:15:44 <dino-> Did somebody instruct lammy to load it?
16:15:55 <smg> Saizan: is there something?
16:16:03 <mae> ifor instance, a type that has named fields
16:16:07 <mae> how do i get the names
16:16:30 <pjd> @check (\f m -> (f =<< m) == join (f <$> m)) :: (Int -> [Int]) -> [Int] -> Bool
16:16:33 <lambdabot>  OK, passed 500 tests.
16:16:43 <smg> maybe Cale knows :)
16:17:07 <malsyned> mae: you're looking for run-time introspection?
16:18:08 <smg> Saizan: ? :)
16:18:11 <Saizan> smg: no, there isn't, you can look at the source for words or lines to implement it
16:18:32 <smg> Saizan: ah okay
16:18:41 <smg> but wait.. i tard, i already implemented it
16:18:41 <smg> lol
16:21:12 <Saizan> smg: it's a bit funny since that function is asked for at least twice a week, but there isn't one in the libraries since we can't agree on which variant to include :)
16:22:59 <hpaste>  (anonymous) pasted "split for fun and non profit" at http://hpaste.org/6145
16:23:28 <smg> here it is @ the paste
16:25:29 <vincenz> rnorris: 6.8.2?
16:25:35 <BMeph> smg: Cute - now re-do it so it'll split a list up on a choice of delimiters... ;)
16:25:55 <rnorris> vincenz: yes
16:26:08 <smg> BMeph: ok
16:26:12 <vincenz> rnorris: it easy to do?
16:26:17 <rnorris> easy to set up?
16:26:21 * vincenz nods
16:26:29 <rnorris> there's a pre-built binary
16:26:51 <rnorris> just download it and then sudo runghc Setup.hs install
16:26:54 <rnorris> something like that
16:27:03 <rnorris> you can build it from nothing but it takes a long time
16:28:06 <vincenz> ah, great
16:28:07 <smg> BMeph: this then would be an apropriate split?
16:28:15 <rnorris> it's at http://haskell.org/ghc/download_ghc_682.html#macosxintel
16:28:20 * vincenz is considering getting a macbook, so wanted to make sure that was on hassle
16:28:22 <rnorris> (also ppc if you have an old one)
16:28:23 <vincenz> s/on/no
16:28:24 <rnorris> oh
16:28:32 <rnorris> yeah i'm running it on a macbook as we speak
16:28:39 <vincenz> Thanks for the input
16:28:41 <rnorris> np
16:31:42 <BMeph> smg: I don't see how anything could be an INappropriate split, unless it doesn't work as advertized.
16:33:16 <BMeph> smg: I'd put the delimiter char(s) as the first argument, and the string to split last - and I'd just use lists, in case someone wanted to split something besides strings... ;)
16:36:22 <BMeph> smg: I'd also blatantly rip off the code used for words and lines (in fact, I did)... ;)
16:41:10 <andyjgill> Hey, has anyone installed readline on cygwin, with ghc-6.8.2?
16:42:05 <smg> BMeph: hehe okay
16:42:19 <smg> BMeph: can you show me yours?
16:42:25 <ddarius> @src words
16:42:25 <lambdabot> words s = case dropWhile isSpace s of
16:42:25 <lambdabot>     "" -> []
16:42:25 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
16:43:06 <smg> @src unwords
16:43:07 <lambdabot> unwords [] = ""
16:43:07 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
16:43:11 <smg> haha
16:43:24 <smg> better than mine
16:44:46 <BMeph> smg: Coming right up... :)
16:45:05 <smg> hehe thanks
16:45:10 <smg> btw source for words looks strange?
16:45:16 <smg> what should s' be?
16:45:20 <smg> it's never defined
16:46:26 <Cale> smg: yes it is
16:46:36 <Cale> smg: It's the variable bound by the case expression.
16:46:47 <Socrates`> :r
16:46:50 <Socrates`> Huzzah.
16:46:51 <Socrates`> Go me
16:46:53 <smg> Cale: ooh?
16:47:05 <Cale>     s' -> ...
16:47:08 <smg> Cale: how could i figure out?
16:47:32 <Cale> Figure out what?
16:47:49 <gwern> @hoogle CInt -> Int
16:47:50 <lambdabot> No matches, try a more general search
16:47:53 <smg> what is s'? :)
16:48:18 <gwern> :info CInt
16:48:35 <Cale> smg: You could look at the case expression and see where it gets bound?
16:48:47 <hpaste>  BMeph pasted "splitWith/divvyWith" at http://hpaste.org/6146
16:49:16 <smg> ah
16:49:22 <smg> Cale: i also could have named s' foobarfoo?
16:50:06 <Cale> sure
16:50:29 <BMeph> smg: There you go. Next, I'll work up some nice demonstrative examples in action. :)
16:50:35 <smg> BMeph: hehe
16:50:37 <Cale> It's s' because it's the same as s with all the spaces at the beginning removed.
16:51:17 <smg> ah
16:55:14 <hpaste>  BMeph annotated "splitWith/divvyWith" with "added usage" at http://hpaste.org/6146#a1
16:55:44 <smg> BMeph: nice
16:55:58 <BMeph> Thanks. :)
16:56:20 <smg> np
16:57:00 <BMeph> Now, to think of a good name for the unlines derivative...
16:59:35 <TomMD> Its odd, the first time you, as a former C coder, read some C and refactor it using the Haskell equivilent in your head.
16:59:46 <gwern> is passing an Int to something with a CInt type sig a type error?
16:59:59 <dons> yep
17:00:09 <dons> TomMD: :)
17:00:14 <BMeph> gwern: Um, why would it Not be? :)
17:00:34 <dons> CInt isn't isomorphic to Int, after all
17:00:57 <gwern> dons: they aren't? don't they both have the max/min bound issue from fitting in a machine word?
17:01:14 <dons> hmm?
17:01:18 <dons> int /= long
17:01:22 <BMeph> Cale: Will Haskell 2 have a Contract mechanism for classes? :)
17:01:34 <gwern> @pl timeout n = timeout_c (fromIntegral n)
17:01:34 <lambdabot> timeout = timeout_c . fromIntegral
17:01:44 <BMeph> (as in "design-by")
17:01:53 <TomMD> In particular, I was looking at five lines of a for loop and a trailing if thinking  "This could be done in two lines... mapM_ ... when ..."
17:02:23 <BMeph> TomMD: Heh-heh. :)
17:04:34 <gwern> (I've always wondered how design by contract might really differ from strongly typed total functional programming)
17:09:19 <gwern> @pl mvaddch l m n ch = mvaddch_c (fromIntegral l) (fromIntegral m) (fromIntegral n) ch
17:09:19 <lambdabot> mvaddch = flip flip fromIntegral . ((.) .) . (. fromIntegral) . mvaddch_c . fromIntegral
17:10:49 <hpaste>  BMeph annotated "splitWith/divvyWith" with "...and a quasi-inverse" at http://hpaste.org/6146#a2
17:12:57 <BMeph> gwern: From what I'm thinking of, DbC lets you do stunts like qcheck, which I think is a bit more specific.
17:13:07 <smg> gn8
17:13:10 <smg> BMeph etc :)
17:13:22 <BMeph> smg: /salute
17:19:35 <gwern> BMeph: hm. set a contract that a function's output must pass a 1000 QC tests? it'd be interesting how you'd do that in the type system
17:25:04 <talentless> does anyone have any thoughts on why ':m Control.Monad.State' wouldn't work in ghci 6.6.1?
17:26:44 <TomMD> talentless: You need to install the mtl library
17:27:32 * dcoutts battles with takusen's Setup.hs and .cabal file
17:28:00 <talentless> TomMD: thanks got it
17:28:01 <dcoutts> if you ever want to see really horrible Haskell code, find a long Setup.hs file :-)
17:28:30 <ddarius> dcoutts: Why is it horrible?
17:28:53 <gwern> dcoutts: I die a little everytime I download a project and see build-type:Custom/a-long-Setup.hs
17:29:24 <dcoutts> ddarius: it copies lots of internal cabal code into it, it modifies the exposed modules list and several other nasties
17:29:31 <dcoutts> gwern: yeah
17:30:10 <ddarius> dcoutts: What are the pressures that lead to that?
17:30:42 <dcoutts> ddarius: sure, I'm not really blaming them, most of the reasons are because Cabal didn't/doesn't provide the stuff they needed
17:31:04 <gwern> ddarius: just, stuff. for example, every project touching the GHC API usually ends up with a custom Setup,hsm since they need to find GHC's library directory at run or compile-time
17:31:23 <dcoutts> and partly because nobody knows what Setup.hs scripts are supposed to do, what apis are ok to use etc
17:31:46 <TomMD> I just copy other peoples Setup.hs and it works great...
17:34:56 <gwern> TomMD: only simple ones, I hope...
17:35:07 <lispy> Yeah, the time I use cabal seriously I had to basically write my own make rules in Setup.hs
17:35:35 <dcoutts> lispy: that's the kind of thing that makes me cry :-)
17:35:56 <lispy> dcoutts: then fix cabal to allow me to use TH correctly :)
17:36:17 <dcoutts> lispy: which bug is that? I mean which trac ticket?
17:36:22 <lispy> dcoutts: I was using TH + the H98 parser to parse in a module and generate code for my unit tests to work correctly
17:36:51 <lispy> dcoutts: I never submitted one because it just seemed like something cabal was never meant to do
17:36:55 <dcoutts> lispy: we can bump the priority of a ticket if it's causing people particular problems, it's hard to know sometimes which ones are really serious
17:37:01 <dcoutts> lispy: oh I see
17:37:25 <lispy> dcoutts: I doubt i even have my setup.lhs anymore...would be interesting to see exactly what I had in there
17:37:44 <dcoutts> lispy: so was it a bug or just a general lack of features?
17:37:45 <lispy> I just remember, it was a bit of black magic
17:38:08 <lispy> dcoutts: lack of features.  I mean, I was using TH + H98 parser to get lisp style code generation at compile time
17:38:27 <lispy> dcoutts: so of course something like cabal doesn't have features for that
17:38:32 <dcoutts> right, basically writing a custom pre-processor
17:38:56 <dcoutts> we do have a pre-processor abstraction which can be extended in the Setup.hs with additional pre-processors
17:39:14 <dcoutts> and then cabal handles the make style thing of re-running the pre-processor when the source file changes
17:39:22 <hpaste>  lispy pasted "Setup.lhs" at http://hpaste.org/6147
17:39:44 <lispy> dcoutts: ah, this was prior to the most recent GSoC
17:40:12 <lispy> dcoutts: and here is an explanation of my pre-processor: http://blog.codersbase.com/2006/09/01/simple-unit-testing-in-haskell/
17:40:14 <lambdabot> Title: dagit.o  Blog Archive  Simple Unit Testing in Haskell, http://tinyurl.com/h6k97
17:40:32 <dcoutts> lispy: ah, so that one is wanting to build .dlls, we have a ticket for that, you might like to check it's accurate
17:41:00 <gwern> dagnabit. porting hetris to hscurses is harder than I'd like
17:41:28 <dcoutts> lispy: http://hackage.haskell.org/trac/hackage/ticket/148
17:41:29 <lambdabot> Title: #148 (Cabal should be able to produce DLLs in Windows) - Hackage - Trac
17:41:30 <lispy> dcoutts: yeah, looking at that, I do see that really I'm just dealing with the dll construction.  So maybe it wasn't TH related as I remembered.
17:42:00 <lispy> dcoutts: well, this is for a prototype, and I've been given the official word from management not to use Haskell anymore.  So, I'm not too worried about cabals support of dlls at the moment.
17:42:16 <dcoutts> lispy: ah, that's a shame :-)
17:43:10 <gwern> lispy: why'd they crack down?
17:43:11 <lispy> dcoutts: I don't know how to read trac tickets.  Is milestone _|_ someone's cute idea of saying never?
17:43:21 <dcoutts> lispy: basically, yes.
17:43:48 <dcoutts> lispy: no fixed milestone, not because we do not want it, but because there is no plan for how to get there
17:43:55 <lispy> gwern: I get that question as often as I mention that they said no.  I really should blog about it.  Basically, I'm the only one here that knows Haskell and I don't work in isolation.
17:44:14 <dcoutts> lispy: because nobody has volunteered or suggested a solution or really made any kind of a fuss about it
17:44:30 <gwern> oh. a reasonable reason to stop you. haskell too often makes something a 1-bus failure point
17:44:45 <lispy> dcoutts: I'd rather see ghc support shared objects consistently on all platforms before I use them anywhere.
17:44:58 <lispy> gwern: 1-bus?
17:45:06 <dcoutts> lispy: my main question is what would you expect the interface to the feature to be, how would you specify you're trying to build a dll
17:45:27 <gwern> a saying - a part of a project is robust based on how many buses would have to take out an egineer before no one understood it
17:45:44 <dons> hehe
17:45:45 <dcoutts> lispy: though note that building a shared lib is not necessarily the same as building a dll that you expect to use as a plugin in someother C system
17:45:47 <gwern> if you're the only person who understands the haskell code, then it only takes 1 bus to render the code unmaintainable
17:45:49 <lispy> dcoutts: in my case, I wanted 1 dll (let me specify the entry points somewhere) and nothing else.  so like an application target.
17:46:04 * dons is happy to work at a place where if we took out 10 engineers, there'd still be another 10 that could hack the haskell :)
17:46:19 <dcoutts> lispy: since the latter wants a full standalone dll that links in the rts and all other dependent haskell libs, it's more like a final .exe but as a .dll
17:46:44 <dons> we have discussions about whether using applicative functors is a good idea, and yeah, it *improves* maintainability :)
17:46:45 <dcoutts> lispy: exactly, an application target. So how would we say in a .cabal file that that's what we wanted?
17:46:59 <redleafgr> what is an applicative functor
17:47:02 <gwern> 'Linking dist/build/hetris/hetris ... \ /home/gwern/bin/lib/hscurses-1.2/ghc-6.8.2/libHShscurses-1.2.a(Curses.o): In function `r6kU_info': \ (.text+0x11f64): undefined reference to `hs_curses_color_pair' \collect2: ld returned 1 exit status' <-- any ideas anyone?
17:47:25 <dons> these guys, redleafgr http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
17:47:26 <lambdabot> http://tinyurl.com/yrwujr
17:47:38 <redleafgr> thanks
17:47:39 <dons> a weaker-than-monad, stronger-than-functor
17:47:43 <lispy> dcoutts: well, I've only used cabal a little bit, and often my .cabal files were generated for me.  So, I don't really feel that qualified to talk about .cabal format (plus it was a moving target back then and has probably changed a bunch.)
17:47:57 <lispy> dcoutts: I was happy to write the .c wrapper that started/stopped the rts
17:48:08 <lispy> dcoutts: I just wanted a build system that gave me a .dll instead of a .exe
17:48:11 <Saizan> dons: for which kinds of tasks?
17:48:13 <lispy> dcoutts: does that help?
17:48:26 <lispy> dcoutts: And I'd be happy to tell the build system what my entry points are, etc
17:48:47 <gwern> I think I have an idea; the ffi says 'foreign import ccall unsafe "HSCurses.h hs_curses_color_pair" colorPair  Pair  ChType' but when I go to look at HSCurses.h I see no color stuff. could this be the reason?
17:48:50 <dcoutts> lispy: a bit, I don't think we need to know the entry points
17:49:11 <lispy> dcoutts: well, I think ghc needs to know them
17:49:14 <lispy> dcoutts: at least on win32
17:49:15 <dcoutts> lispy: I guess really it's a whole other class/kind/type of build, it's not a library and not an executable
17:49:35 <dcoutts> lispy: really? don't we just export everything if nothing is listed specifically?
17:49:40 <lispy> It's like an executable but without a 'main' and requiring special flags to ghc
17:50:18 <lispy> dcoutts: My memory is hazy, as I've shown already, but I thought I had to create a .def file for the dll to have the right things available to the application I used the dll in.
17:51:17 <dcoutts> lispy: as I understand it a .def file is optional, but I'm not sure of the details when it comes to ghc and dlls
17:52:19 <lispy> dcoutts: I can no longer build/test this code, but I thought I tried it without the .def and the application that loaded the dll failed to find the entry point
17:53:15 <lispy> dcoutts: It's probably been a year since or more since I worked on this code.
17:53:40 <lispy> dcoutts: I wasn't dissatisfied with cabal, actually I was quite happy that it allowed me to write arbitrary code in Setup.lhs so I could get it working.
17:54:15 <lispy> dcoutts: sometimes when I have a deadline to meet, being able to fudge it temporarily is the best answer.
17:54:34 <dcoutts> lispy: I think to support it properly we need a new class of target, since it's not obvious how to shoehorn it into a lib or exe
17:54:46 <lispy> dcoutts: Right, I totally agree.
17:55:44 <lispy> dcoutts: But, in some ways, people should either stop building shared objects with ghc or more people should do it.  The stuff that is there doesn't seem to be robust.  It currently only works on windows and only if you're building just one monolithic dll for your entire application.
17:56:10 <dcoutts> lispy: it now works on osx and linux to build haskell shared libs
17:56:26 <dcoutts> lispy: what doesn't work on windows yet is building haskell shared libs
17:56:47 <dcoutts> lispy: what does work is building a whole haskell syatem as a statically linked dll
17:57:45 <lispy> dcoutts: I looked at the ghc docs (the ones published on their website) just last week and they claimed that linux and osx do not support .so's.  Do you mean something different when you say "shared libs"?
17:57:51 <dcoutts> lispy: it may well be in future that if haskell shared libs work, that it could double for the latter task, though then you'd be dealing with a dozen or more .dlls rather than one big statically linked one
17:58:20 <dcoutts> lispy: I mean .so's yes, it's not a stable feature in 6.8 yet, it'll be more solid in 6.10
17:58:57 <dcoutts> the feature is present in 6.8 but not really ready to be used, cabal has some support for building that way too
17:58:58 <lispy> Well, this is good news.  I had an idea for a hobby project where the lack of .so's stopped me from doing it the obvious way (and I have yet to find time to do it any way...0
17:59:36 * BMeph is happy that his workplace is a 1-bus place for Java code...unfortunately, it's because there's too much coding done in VB. :(
18:04:36 <gwern> GOT VER DAMMT
18:04:47 <gwern> so, hetris won't compile due to linkage errors
18:04:47 <lispy> gwern: sorry?
18:04:58 <gwern> on sheer whim, I went and reinstalled hscurses with -fvia-c
18:05:08 <gwern> because I couldn't think of anything cleverer to do
18:05:15 <gwern> and then hetris compiled -fasm!
18:05:23 <gwern> goddamn ncurses
18:05:37 <lispy> BMeph: have you written a static type checker for your VB code or considered it?  The last time I had to do VB here, I was seriously considering writing a modified H-M type checker for VB.
18:06:32 <lispy> I'm also considering the possibility of doing this for python as that seems to be the language that management wants us to standardize on.
18:06:57 <lispy> In the python case, it will probably need some type annotations added, I'm thinking these could be added as special comments in the source
18:07:30 <BMeph> lispy: Ooh, that sounds wicked...alas, I'm proficient enough to (barely) follow the engineers' logic, I never got much into VB.
18:07:38 * lispy has a lot of reservations about writing production quality code in a dynamic language
18:08:11 <sarehu> it happens
18:08:12 <lispy> BMeph: Oh, what do you use at work then?  I got the impression you use VB mostly.
18:09:00 <lispy> BMeph: maybe you meant, you write in Java and the engineers write in VB
18:09:48 <BMeph> lispy: Well, at work I do electronics testing, and hack on my downtime. I work with most of the engineers that program in the company, though.
18:11:41 <TomMD> Any interest in a DHT in Haskell?
18:11:51 <lispy> what is DHT+
18:11:52 <TomMD> I'm contemplating a new project.
18:11:54 <BMeph> I'd love to use my programming skills at work for work, but mostly it's just pointing out stuff that the engineers need to fix.
18:11:58 <TomMD> @google pastry p2p
18:11:59 <lambdabot> http://research.microsoft.com/~antr/Pastry/
18:11:59 <lambdabot> Title: Pastry - A scalable, decentralized, self-organizing and fault-tolerant substrate ...
18:12:17 <TomMD> lispy: thats a good example ^^^
18:12:20 <glen_quagmire> Dramatic Haskell Toilet
18:12:57 <TomMD> BMeph: Sounds like you should send me an application :-P
18:12:57 <glen_quagmire> distributed hash table
18:13:04 <TomMD> s/application/resume/
18:14:10 <BMeph> TomMD: Interesting - I have an uncle who lives in Baltimore - most of my family is in VA and FL, though.
18:14:27 <TomMD> VA isn't far.
18:14:37 <glen_quagmire> send me your resume too. in latex. so that i can use it to write my resume
18:14:44 <TomMD> Do you consider that a benefit or drawback? ;-)
18:14:46 <BMeph> Currently, I'm in San Diego, CA, so I'd have to really impress you guys... ;)
18:15:18 <TomMD> need my e-mail address?
18:15:53 <BMeph> TomMD: Sure - the worst you could do is say "No," right? ;)
18:16:07 <lispy> TomMD: It's hard for me to really understand what it is from that webpage.  but, it looks like distributed rpc or something.
18:16:26 <mauke>     No instance for (Data.String.IsString [a])
18:16:29 <TomMD> Thats just a side interest.
18:16:29 <mauke> WHAT
18:16:37 <BMeph> Dazzling Hat Trick? ;)
18:16:48 <TomMD> I once was a fan of distributed systems.  Still like them a lot, but never really worked in them.
18:16:52 <lispy> Distributed Haskell toolkit? is that what you meant by DHT?
18:17:15 <TomMD> lispy: sorry, glen won the prize.
18:17:41 <lispy> the toilet guess?
18:17:46 <wagle_home> dramatic haskell toilet?
18:17:49 <TomMD> Distributed Hash Table.
18:17:49 <glen_quagmire> disturbed hard teens
18:18:02 <TomMD> Of coarse, glen tries hard to stick with his namesake.
18:18:10 * lispy nods
18:18:24 <Saizan> ?google wikipedia DHT
18:18:25 <lambdabot> http://en.wikipedia.org/wiki/D.H.T.
18:18:25 <lambdabot> Title: DHT - Wikipedia, the free encyclopedia
18:18:58 <lispy> DHT...deployed in the internet...but we already have perl... ;)
18:19:14 <Saizan> it was my last exam final project, in java, sigh
18:19:31 <TomMD> Saizan: You made a DHT in Java?  Did you go to Rice by any chance?
18:20:18 <radix> oh, DHT. That reminded me of DMT.
18:20:44 <radix> and then I thought of shpongle. o/` divine moments of truth, total and utter cosmic stuff o/`
18:21:59 <Saizan> TomMD: yes, but it wasn't anything serious, we had barely 2 weeks for that project. is Rice a university? if so no
18:22:52 <lispy> DMT = dave mathews troupe? ;)
18:23:09 <TomMD> Saizan: 2 weeks of Java... sounds like hell.  Yes, Rice University was what I was talking about.
18:23:18 <radix> or Dimethyltryptamine
18:23:29 <wagle_home> Direct Monad Transformer
18:23:48 <gwern> Daunting're Monad Transformers :)
18:23:59 <glen_quagmire> transformers have type :: a -> a
18:24:12 <mauke> Delicious Morsel Treats
18:24:41 <lispy> s/Morsel/Monad
18:24:50 <Saizan> TomMD: 2 weeks of concurrency-heavy Java, it's like a countable infinity of hells
18:24:54 <lispy> Mmm....Monads, with lambda sauce!
18:29:19 <dcoutts> Saizan: hmm, that's an interesting point, could we use copy + register instead of calling install --only ?
18:33:02 <dcoutts> Saizan: we can talk about it tomorrow
18:33:04 <dcoutts> g'night folks
18:36:08 <conal> Don't Malign Types
18:37:18 <lispy> heh, and DHT is Don't Hate Types
18:44:42 <lispy> So, in the explicit kind notation, there are only two valid tokens, right?
18:44:46 <lispy> and they alternate?
18:45:41 <gwern> anyone have any spare time? maybe you could cabal-update and try a cabal install of hetris?
18:45:43 <lispy> So, why not have a simpler syntax that exploits this.  I get sick of counting the number of stars or arrows to know which kind I'm dealing with.
18:46:26 <SamB> hello, people.
18:46:37 <lispy> SamB: hello, person.
18:46:58 <gwern> SamB: greetings fellow human
18:47:27 <mauke> @kind (->)
18:47:30 <lambdabot> ?? -> ? -> *
18:47:50 <lispy> mauke: so you can have more than just * and ->?
18:48:04 <mauke> ghc can :-)
18:48:05 <lispy> or is that even a kind that you can be explicit about?
18:48:27 <lispy> something like *(4) instead of * -> * -> * -> * would be nice
18:48:36 <SamB> lispy: haven't you heard of unboxed types yet?
18:48:51 <SamB> you didn't think they were the same kind of type as boxed types, did you?
18:48:55 <dolio> What would (* -> *) -> (* -> *) -> * -> * be in that notation?
18:49:17 <lispy> dolio: oh, good point
18:49:21 <glen_quagmire> ??? ?? ??? ? ? ? ? ??  ?
18:49:21 <dolio> (*(2))(3)?
18:49:51 <lispy> SamB: I don't know what you're on about.  Please explain :)
18:49:59 <SamB> glen_quagmire: you seem to have forgotten the arrows
18:50:03 <gwern> (whew. there go my patches to hscurses. stefan's going to have a fun time going through all 22 :)
18:50:30 <SamB> lispy: well, GHC uses the kind system to keep you from doing thingss with unboxed types that you shouldn't
18:50:46 <SamB> it has a semilattice of kinds
18:50:53 <SamB> or something like that
18:51:20 <lispy> SamB: a boxed type is anything I create with 'data', so what is an unboxed type?
18:51:26 <SamB> jhc is thrashing atm
18:51:35 <SamB> when it stops I'll explain more...
18:51:54 <SamB> oh, unboxed types are things like Int#
18:51:59 <dolio> Unboxed data isn't stored on the heap, as I recall.
18:52:13 <SamB> @src Int
18:52:13 <lambdabot> data Int = I# Int#
18:52:19 <SamB> @src Integer
18:52:19 <lambdabot> data Integer = S# Int#
18:52:19 <lambdabot>              | J# Int# ByteArray#
18:52:25 <dolio> Or, isn't a pointer to heap data, I suppose.
18:53:14 <SamB> actually, GHC has to seperate the *unlifted* types from the lifted types
18:53:24 <dolio> If you use unbox-strict-fields it'll still be on the heap, but will be stored directly in the enclosing structure, rather than the structure storing pointers to the values.
18:53:25 <SamB> ByteArray# is an unlifted but boxed type
18:53:41 <awesame> does anyone know how to use Network.Socket's setSocketOpt to set socket timeouts?
18:54:02 <SamB> unlifted types don't have _|_
18:54:07 <awesame> my guess at how to use that is complaining about an invalid parameter, and documentation seems to be sparse
18:54:30 <awesame> (the guess was: "setSocketOption sock RecvTimeOut 30")
18:54:46 <lispy> SamB: lifted?
18:54:49 <lispy> SamB: in what sense?
18:55:18 <mauke> awesame: what's the error message?
18:55:54 <awesame> mauke: setSocketOption: invalid argument (Invalid argument)
18:56:10 <mauke> :-|
18:56:42 <lispy> ?hoogle setSocketopt
18:56:42 <lambdabot> No matches found
18:56:46 <awesame> I found some stuff on the web about that function being impossible to use to set timeouts as of a couple years ago, so that's not too promising
18:57:23 * dolio can never find the types that use the ! kind when he wants to.
18:57:54 <awesame> this seems to imply that I need more than an int, at least: http://permalink.gmane.org/gmane.comp.lang.haskell.libraries/7514
18:57:54 <lambdabot> Title: gmane.comp.lang.haskell.libraries
18:59:00 <lispy> awesame: if you fire up ghci what is the type of that function?
18:59:22 <mauke> awesame: right, setSocketOption is broken
18:59:34 <clanehin> what is this while doing heap profiling?  stg_ap_2_upd_info
19:00:06 <hpaste>  SamB pasted "extract from compiler/types/Type.lhs" at http://hpaste.org/6148
19:00:13 <lispy> clanehin: My guess is that is part of ghc's run-time system.
19:00:55 <SamB> hrmm, yes, it's a semilattice
19:01:21 <lispy> I don't know what an unboxed tuple is
19:01:30 <SamB> http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html#glasgow-unboxed
19:01:31 <lambdabot> Title: 8.2. Unboxed types and primitive operations, http://tinyurl.com/y59rbr
19:01:31 <awesame> lispy: setSocketOption :: Socket -> SocketOption -> Int -> IO ()
19:01:36 <lispy> Is that (Int#,Int#) or (a ,# b) ?
19:01:54 <mauke> (# a, b #)
19:01:56 <SamB> http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html#unboxed-tuples
19:01:57 <lambdabot> Title: 8.2. Unboxed types and primitive operations, http://tinyurl.com/y59rbr
19:03:42 <dolio> SamB: Is the ! kind gone? The things I thought used it seem to use # these days.
19:04:01 <SamB> dolio: I don't remember one of those
19:04:25 <SamB> I do, however, have a really bad memory for some things...
19:04:31 <lispy> what is the least upper bound of *,# mean?
19:04:53 <SamB> well, in this case, it means it includes things in * and things in #
19:05:26 <dolio> SamB: I think some of the byte array types had kinds like ! -> # or something. Of course, I couldn't tell you what ! actually was.
19:05:39 <SamB> http://en.wikipedia.org/wiki/Semilattice
19:13:37 <wagle_home> hey, wow, i guessed what an unboxed tuple was
19:14:20 * SamB is really surprised sometimes what people don't know
19:14:56 <lispy> SamB: well, in my defense, I just don't have a need for unboxed types.  They are a bit more low level than I tend to operate.
19:16:14 <lispy> "In particular, the IO and ST monads use unboxed tuples to avoid unnecessary allocation during sequences of operations." <-- I will admit though, that's pretty sweet.
19:16:49 <SamB> I guess I'm the only one here who felt the need to read GHC.IO in an effort to understand monads?
19:17:15 <lispy> SamB: Yeah, I read 'tackling the awkward squad' instead
19:22:03 * SamB thinks it would be nice if darcs2 used files with an extension appropriate to their actual format...
19:23:59 <lispy> SamB: what do you mean?
19:25:12 <SamB> Line-based text data: text/plain
19:25:16 <SamB> \037\213\b\000\000\000\000\000\000\003m\221\273N\3030\024\206\367<\305/1\204B\033\222\320J\264\022\022\v\202\211\016\224\001U\fNr\232\230&vd;T\025\342\3359\356\205\002\255\344\301\262}\276\377\342\371\2745\372\235r\207;\244q|=\210\307\203d
19:25:28 <SamB> excerpt from wireshark outputt...
19:26:54 <lispy> SamB: um, all I see is a mess of \037\213\b\000 ...
19:27:14 <gwern> ok. so besides ginsu and mage, does anyone know of any haskell programs or libraries with a curses binding?
19:27:29 <gwern> (ie. haskell stuff using ncurses but not hscurses)
19:28:06 <SamB> what programs use hscurses?
19:28:19 <gwern> SamB: hetris right now...
19:28:38 <SamB> what does hmp3 use ? I forget.
19:28:41 * gwern plans to make ginsu and mage use hscurses soon, though! I just don't have time to do a second port today
19:28:50 <gwern> SamB: dunno. I'll go check
19:29:37 <SamB> but whatever hmp3 uses I think it should be left using that
19:30:03 <gwern> why?
19:30:25 <SamB> well, because I'm pretty sure if dons wanted to use hscurses he has done so ;-)
19:31:19 <gwern> don't be so sure. dons intends a lot of things which don't necessarily happen, and hscurses was hardly usable recently
19:32:21 <awesame> hm, why can't I "import Posix"?
19:32:37 <awesame> in ghc 6.6.1
19:32:43 <gwern> awesame: because it's a Haskell98 module and hierarchical modules are better?
19:32:50 <gwern> try System.Posix mebbe
19:33:04 <gwern> (and why are you using an old ghc anyway)
19:33:30 <awesame> good question
19:35:58 <SamB> yuo could also use -package haskell98...
19:36:03 * gwern awaits the answer with curiosity and bated breath
19:36:08 <SamB> if there is such a thing as Posix
19:36:12 * gwern thwacks SamB. no no!
19:36:34 <SamB> but really, gwern's idea is much better
19:36:35 <gwern> oh, there's a Posix alright. I've removed many a 'import Posix' in my time
19:36:49 <SamB> since you are not some student living in 1999
19:36:49 <awesame> I learned about this Posix thing because the docs I found on Network say I should use it
19:37:03 <Cale> Posix is certainly not a Haskell 98 module though.
19:37:06 <awesame> however, System.Posix seems good
19:37:54 <gwern> Cale: really? then where be its origins, from beyond what pale bourne come it?
19:38:10 <SamB> gwern: it  is a pre-heirarchicaal non-standard module
19:38:12 <Cale> I've never seen it.
19:38:35 <gwern> *comes it
19:38:37 <SamB> must be, since you've removed it's imports and I've never heard of it before
19:39:01 <Cale> As far as I know, it's never been a module which has come with GHC>
19:39:05 <awesame> where do I go for good documentation on the standard modules modern ghc users would use?
19:39:14 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
19:39:14 <awesame> (other than #haskell...)
19:39:30 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html
19:39:31 <SamB> the only non-heirarcal modules I can think of off the top of my head are Numeric, Prelude, and Foreign...
19:39:34 <gwern> awesame: just go with the standard libraries Cale linked ya to
19:39:41 <gwern> SamB: System
19:39:53 <gwern> which got split into System.Environment, System.Exit, and I think System.io
19:39:56 <awesame> oh, this is excellent
19:39:58 <SamB> gwern: is that one too?
19:39:59 <awesame> thanks Cale
19:40:03 <Cale> No problem.
19:40:10 <awesame> someone please tell google about these docs
19:40:19 <SamB> well, the ones I mentioned just now are still in use
19:40:31 <SamB> not deprecatted
19:41:08 <awesame> although, the bottom of this page http://www.haskell.org/ghc/docs/latest/html/libraries/network/Network.html
19:41:09 <lambdabot> http://tinyurl.com/2znny8
19:41:15 <awesame> is where I learned about Posix
19:41:22 <gwern> strangely, I don't think I've ever since 'Numeric' imported
19:41:29 <gwern> SamB: Foreign got split up too iirc
19:41:48 <SamB> gwern: Foreign is still there, even if it has been split up...
19:41:58 <Cale> Hey, that's funny :)
19:42:11 <Cale> There's an import Posix in the comment there :)
19:42:40 <gwern> hah. so there is
19:42:47 <gwern> '>  import Posix
19:42:47 <gwern> >  main = do installHandler sigPIPE Ignore Nothing; ...
19:42:47 <lambdabot>  Parse error at "=" (column 6)
19:43:26 <lispy> awesame: there is a way to submit urls to google
19:44:00 <lispy> awesame: http://www.google.com/addurl/
19:44:00 <lambdabot> Title: Add your URL to Google
19:44:22 <gwern> could haskell.org/s robots.txt be excludiong ot?
19:44:55 <lispy> perhaps, I think they excluded the wiki at some point (probably still do).  I think they had semi-valid reasons, but IMO it makes the wiki useless.
19:45:17 <lispy> If google can't find it, does it exist?
19:45:30 <gwern> I thought we fixed it for the wiki at least
19:45:48 <awesame> I can get to those docs through google, I was just complaining because they weren't prominent enough in some of my searches
19:45:55 <SamB> I believe we unexcluded the wiki
19:46:02 <SamB> I'll check the current exclusions
19:46:13 <gwern> http://haskell.org/robots.txt <-- no, it only disallows some wiki pages
19:46:20 <gwern> seems to say nothing abuot ghc/*
19:47:39 <sclv_> those docs are completely what make intermediate haskell possible, as far as i'm concerned, and especially the source links are amazingly helpful.
19:47:44 <adu> lispy: lol
19:48:01 <gwern> ok, so there's another ncurses music player, minstrel
19:48:10 <gwern> so that gives me mage, minstrel, hmp3 and ginsu
19:48:27 <gwern> (we haskellers seem to like reimplementing curses bindings...)
19:48:41 <awesame> sclv_: oh, there's a source link up top!
19:48:54 <ddarius> awesame: Just browse haskell.org.  It's not -that- badly organized.
19:48:58 <wagle_home> and the emacs non-overlapping windows
19:49:01 <SamB> gwern: the principle wikipages disallowed are the special ones
19:49:17 <SamB> at one point the entire wiki was disallowed
19:49:27 <gwern> SamB: right, I was around for that discussion
19:49:52 <SamB> which left a gaping hole in some search engine's databases that probably took weeks to fully recover
19:49:55 <SamB> if it has
19:50:05 <ddarius> I imagine it has for google.
19:50:21 <SamB> one hopes!
19:50:33 <gwern> yeah, it's recovered by now. I've seen haskell wiki pages as hits
19:50:51 <SamB> gwern: that doesn't mean it's fully recovered ;-)
19:51:33 <awesame> ddarius: yeah, that seems to be going okay
19:51:48 <awesame> looks like I need to abandon my usual strategy of letting google decide which docs I should be reading
19:52:13 <rnorris> never question google. they're listening
19:52:26 <gwern> SamB: once google's spidered it, all's that really left is for the pageranks to recover as influence propagates during google's daily and weekly processing of the database</shrug>
19:52:55 <SamB> yeah, how many months ago did I come up with the fix for robots.txt?
19:53:25 <SamB> to keep that stupid chinese "googlebot" from spidering all the history pages
19:53:32 <cschneid> how heavily should I be using tupples?  It just seems like every problem I want to tie two pieces of info together, I grab one.  Is that recommended, or is there another structure I should use
19:53:38 <lispy> Okay, step #2 then, is to link to it from youtube and your blogs.
19:53:43 <SamB> including the diffs
19:53:53 <faxathisia> sounds fine cschneid
19:54:00 <lispy> cschneid: I'd have to see examples of your code to be able to judge.
19:54:29 <ddarius> cschneid: For small things it may be okay.  Oftentimes it's helpful to make an explicit type for type safety.
19:54:31 <gwern> SamB: sounds like a cure worse than the disease
19:54:33 <lispy> cschneid: if you using things bigger than 3-tuples it's probably time to start using data types
19:54:40 <gwern> for that matter, are there any backups for the wiki?
19:54:58 <SamB> gwern: you mean of the SQL database?
19:55:02 <SamB> the PHP scripts?
19:55:07 <SamB> both of the above?
19:55:22 <gwern> SamB: the database, in either SQL tables, xml'd wikitext, or HTML dumps
19:55:26 <SamB> I don't have any answers to either question...
19:55:46 <lispy> SamB: this darcs get is still happening
19:55:52 <cschneid> ddarius, lispy: that's an area I haven't gotten to yet :)  I'll be sure to check that out later
19:56:02 * gwern sighs. I guess I'm too used to [[WP:DUMP]] on WP. why should I expect a small wiki to have a solid dump and diostribution setup?
19:56:13 <SamB> lispy: oh, you probably need to use --lazy or something if you are using HEAD
19:56:45 <lispy> SamB: lol, you could have warned me, I typed exactly what you pasted :)
19:56:53 <SamB> I'm NOT using head
19:57:18 <SamB> apparantly pre3 defaults to and lacks --lazy
19:57:35 <gwern> yeah. some people prevailed on roundy
19:58:05 <gwern> to0 change it though. they said it'd be confusing and lead to breakage to be lazy all the time
19:58:23 <SamB> maybe it should go "OMG that inventory is huge! did you want to pass --lazy?"
19:58:42 <lispy> SamB: but, lazy easily causes breakage
19:58:46 <ddarius> Maybe it should do what I tell it!
19:59:06 <SamB> lispy: you know, as a y/n option
19:59:19 <lispy> SamB: just set something in your darcs defaults if you like lazy
19:59:29 <gwern> interactiveness makes scripting jesus cry
19:59:34 <SamB> lispy: so is their a --strict
19:59:35 <SamB> ?
19:59:43 <SamB> er.
19:59:44 <SamB> there.
19:59:59 <lispy> SamB: --lazy/--complete
20:00:16 <SamB> --strict should be a synonym for --complete
20:00:23 <ddarius> Hmm... this push is taking a while..
20:00:30 <ddarius> --eager
20:00:47 <lispy> That feature is new enough that you could send in patches
20:00:54 <lispy> And get the name changed.
20:01:18 <SamB> hasn't --complete been an antonym for --partial since forever?
20:01:28 <SamB> or is that a ./darcs-all ism?
20:01:37 <lispy> although, 'darcs get --complete' makes a bit more sense than 'darcs get --eager'
20:01:44 <radetsky> gwern: are you familiar with the wAddStr-at-bottom-of-term bug in hscurses?
20:02:22 <lispy> lazy/strict and lazy/eager really only make sense to haskell folks
20:02:36 <gwern> radetsky: no. I assume that you are about to enlighten me to my dismay?
20:03:12 <radetsky> I'm not sure about the dismay part
20:03:44 <radetsky> but when you do wAddStr and you are at the end of the line, you push the cursor off the term, causing the program to crash
20:04:19 <radetsky> stefan's example program avoids this by putting a "dummy line" line on the last line, but I don't think this is an acceptable solution
20:04:27 <scook0> radetsky: oddly enough, I ran into this just yesterday :)
20:04:49 <radetsky> (see line 210 of ContactManager.hs)
20:04:56 <scook0> and it's not hscurses-specific
20:05:27 <radetsky> I see no reference to it in any of the ncurses manpages
20:05:40 <radetsky> anyway, I will be unresponsive for a little while
20:05:52 <gwern> hm. how peculiar
20:06:09 <gwern> strikes me as kind of shoddy, but by this point my opinion of ncurses is low
20:06:25 <scook0> heh
20:06:30 <faxathisia> ncurses is not useful
20:06:53 <scook0> faxathisia: what would you suggest as an alternative?
20:07:22 <radetsky> faxathisia: ncurses rocks your face off
20:07:30 <radetsky> never speak ill of it again
20:08:00 <scook0> incidentally, I also recently discovered that gnome-terminal doesn't support combining characters
20:08:04 * gwern steers between the rock of radetsky and the maw of faxathisia
20:08:36 <scook0> I hate ncurses, but I'm not aware of any reasonable alternative
20:08:47 <scook0> (for my particular purposes, anyway)
20:10:03 <bockmabe> radetsky, I'm also a fan.
20:10:37 <faxathisia> <canvas> + javascript is an alternative to ncurses
20:11:10 <Mr_Awesome> or you could reinvent the wheel
20:11:22 <gwern> faxathisia: your ideas fascinate me. how do I run <canvas> + javascript on my terminals?
20:11:37 <faxathisia> lynx :P
20:11:47 <faxathisia> nah, my point was use a webbrowser instead of a terminal
20:12:14 * gwern is abstemious, and so will not excorciate that suggestion as it deserves
20:13:51 <bockmabe> gwern: nice vocabulary :-)
20:15:09 <gwern> bockmabe: I have never been one to bamboozle with insults when I could with words
20:15:43 <solrize_> hey is there any way to set the listening host in the network module?
20:16:01 <gwern> one of these days I need to learn an ML. their module system is supposed to be even more awesome thn haskell typeclasses
20:16:02 <lispy> w3m-img is pretty impressive, speaking of terminal based browsers (that one can actually render images in line)
20:16:04 <solrize_> it looks like i can do it in Network.Socket but that module is a lot more complex in general
20:17:03 * BMeph suspects gwern never uses a big word, when a diminutive one will suffice
20:17:58 * lispy like big word
20:18:06 <gwern> BMeph: only ostensibly, since short ones can be even more awesome if they're way obscure
20:18:09 <Mr_Awesome> gwern: dont believe it
20:18:17 <gwern> my favorite short word is 'yclept'
20:18:39 <BMeph> I'm fond of "lusk," myself. :)
20:18:53 <gwern> (needless to say, for obscure short words, you need to go hunting around in words of saxon or nordic extraction)
20:19:01 <faxathisia> divisibisity
20:19:10 <faxathisia> oops.
20:19:24 <gwern> BMeph: nice. what does that one mean?
20:20:16 <lispy> ?all-dicts lusk
20:20:16 <lambdabot> *** "Lusk" gcide "The Collaborative International Dictionary of English v.0.48"
20:20:16 <lambdabot> Lusk \Lusk\ (l[u^]sk), a.
20:20:16 <lambdabot>    Lazy; slothful. [Obs.]
20:20:16 <lambdabot>    [1913 Webster]
20:20:16 <lambdabot>  
20:20:18 <lambdabot> [33 @more lines]
20:20:49 <BMeph> gwern: It's...there you go. ;)
20:20:57 * gwern should look that up in my OED sometime to see its etymology
20:24:51 <oklofok> >>> [1..10]
20:24:53 <oklofok> > [1..10]
20:24:58 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
20:25:22 <ddarius_> @mn yclept
20:25:22 <lambdabot> *** "yclept" wn "WordNet (r) 2.0"
20:25:22 <lambdabot> yclept
20:25:22 <lambdabot>      See {clepe}
20:25:37 <ddarius> @wn clepe
20:25:37 <lambdabot> No match for "clepe".
20:25:45 <ddarius> Thanks.
20:25:51 <faxathisia>   See {Wild goose chase}
20:25:53 <oklofok> > let r = [1..10] in r>>=(\a->r>>=(b->(a,b)))
20:25:53 <lambdabot>  Parse error at "->(a,..." (column 35)
20:26:35 <gwern> heh heh.
20:26:42 <faxathisia> > zip [1..10] [1..10]
20:26:50 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
20:27:20 <faxathisia> > join zip [1..10]
20:27:21 <gwern> yclept is my favorite because it simultaneously uses an obsolete bit of english, and applies it to an obsolete word, but is still seen
20:27:21 <oklofok> was going for cartesian product
20:27:22 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
20:27:36 <ddarius> > join (liftM2 (,)) [1..10]
20:27:39 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,2),(2...
20:27:59 <gwern> to give you an idea, it was revived in the 1500s by an author who wanted a very obscure word, and has been thus used since by mean authors
20:28:09 <lispy> that join (liftM2 ...) makes me think you could use `ap` but I dunno.
20:28:22 <faxathisia> @src liftM2
20:28:22 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
20:28:24 <faxathisia> @src ap
20:28:24 <lambdabot> ap = liftM2 id
20:28:34 <faxathisia> @src join
20:28:34 <lambdabot> join x =  x >>= id
20:28:35 <ddarius> lispy: The join is in a different monad than the liftM2
20:28:57 <lispy> ddarius: yeah, join is the reader monad, righT?
20:29:02 <ddarius> Hai
20:29:03 <faxathisia> I doubt it
20:29:16 <oklofok> can you do the cartesian product my way, but so that it works?
20:29:31 <ddarius> oklofok: All you needed was a 'return'
20:29:37 <oklofok> oh, right
20:29:37 <faxathisia> > let r = [1..10] in r>>=(\a->r>>=(\b->(a,b)))
20:29:39 <lambdabot>  Couldn't match expected type `[b]' against inferred type `(a, a1)'
20:29:40 <ddarius> and a \b
20:29:42 <faxathisia> > let r = [1..10] in r>>=(\a->r>>=(\b->return(a,b)))
20:29:44 <oklofok> > let r = [1..10] in r>>=(\a->r>>=(b->return (a,b)))
20:29:44 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,2),(2...
20:29:44 <lambdabot>  Parse error at "->ret..." (column 35)
20:29:49 <oklofok> > let r = [1..10] in r>>=(\a->r>>=(\b->return (a,b)))
20:29:51 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,2),(2...
20:30:04 <adu> my favorite is 'rythms'
20:30:14 <adu> no vowels
20:30:20 <lispy> ?undo do { let a = [1..10]; let b = [1..10]; return (a,b) }
20:30:20 <oklofok> right, i actually realized right away that it needs the return, but couldn't figure the parse error out
20:30:20 <lambdabot>  Parse error at "let" (column 23)
20:30:23 <faxathisia> @undo [ (a,b) | a <- r , b <- r ]
20:30:23 <lambdabot> concatMap (\ a -> concatMap (\ b -> [(a, b)]) r) r
20:30:26 <lispy> > do { let a = [1..10]; let b = [1..10]; return (a,b) }
20:30:26 <lambdabot>  Parse error at "let" (column 23)
20:30:31 <lispy> hmmvvv
20:30:37 <faxathisia> (>>=) = flip concatMap
20:30:38 <gwern> adu: my understanding was that whether 'y' was a vowel was contextual
20:30:55 <ddarius> let {a = [1..10]};
20:31:14 <adu> gwern: while that might be true, it is globally considered a semi-vowel, so not a true vowel
20:31:16 <lispy> > do { let {a = [1..10]}; let {b = [1..10]}; return (a,b) }
20:31:17 <lambdabot>        add an instance declaration for (Show (t ([t1], [t2])))
20:31:19 <ddarius> Damn push.
20:31:33 <lispy> duh
20:31:38 <ddarius> Yeah...
20:31:42 <gwern> 'The letter Y was originally established as a vowel. In the standard English language, the letter Y is traditionally regarded as a consonant, but as a survey of almost any English text, including this one, will show, Y more commonly functions as a vowel. In many cases, it is known as a semivowel (a type of consonant).'
20:31:47 <lispy> > do { a <- [1..10]; b <- [1..10]; return (a,b) }
20:31:50 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,2),(2...
20:31:55 <lispy> ?undo do { a <- [1..10]; b <- [1..10]; return (a,b) }
20:31:55 <lambdabot> [1 .. 10] >>= \ a -> [1 .. 10] >>= \ b -> return (a, b)
20:32:09 <gwern> wikipedia always has so much linguistics-cruft :)
20:32:40 <bockmabe> gwern, it appears that that is partially your fault :-)
20:33:15 <gwern> bockmabe: I swear, I've only added *dirty* stuff, like how 'quaint' can mean 'cunt/vagina'
20:33:26 <bockmabe> hoho
20:33:27 <gwern> classy interesting stuff like that! not dry as dust stuff on what 'y' is
20:33:54 <gwern> (shoot. I just gave away one of my crown gems of trivia.)
20:34:41 <bockmabe> LOLRZ
20:35:51 <vinc456> what does Prelude's const function stand for?
20:35:57 <faxathisia> constant
20:36:16 <Riastradh> Consternation.
20:36:22 <faxathisia> > map (const 5) [3,5,8,6,4,1,9,7]
20:36:24 <lambdabot>  [5,5,5,5,5,5,5,5]
20:36:55 <gwern> constituent
20:37:27 <faxathisia> ...that's a brilliant word Riastradh
20:37:37 <gwern> constipation?
20:38:11 <lispy> > ($) (const True) undefined
20:38:12 <gwern> construal, constrict... could be a lot of words
20:38:16 <lambdabot>  True
20:38:27 <lispy> and that my friends is what we call lazy!
20:38:50 <faxathisia> > map (const 5) [3,5,8,last [1..],4,1,9,7]
20:38:53 <lambdabot>  [5,5,5,5,5,5,5,5]
20:38:54 <dolio> > id id id id id id id id (const True) undefined
20:38:56 <lambdabot>  True
20:39:00 <faxathisia> Now That's what I call lazy '96
20:39:03 <ddarius> mmm ... I guess I'm glad my push didn't go through.
20:39:41 <lispy> > repeat id (const True) undefined
20:39:43 <lambdabot>  Couldn't match expected type `(b -> Bool) -> a -> t'
20:40:05 <dolio> Or, alternatively.
20:40:10 <dolio> > id id id id id id id id const True undefined
20:40:12 <lambdabot>  True
20:40:23 <lispy> what was that function that went [a -> a] -> a -> a
20:40:36 <faxathisia> :t foldr (.) id
20:40:37 <gwern> @hoogle [a -> a] -> a -> a
20:40:37 <lispy> We had some nice simple version like a foldr ($) or something
20:40:38 <lambdabot> No matches, try a more general search
20:40:40 <lambdabot> forall a. [a -> a] -> a -> a
20:40:58 <lispy> > foldr (.) id (repeat id) (const True) undefined
20:41:02 <Cale> :t sequence
20:41:02 <lambdabot>  Exception: <<loop>>
20:41:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
20:41:11 <faxathisia> ?djinn Maybe (a -> a) -> a -> a
20:41:11 <lambdabot> f a =
20:41:11 <lambdabot>     case a of
20:41:11 <lambdabot>     Nothing -> \ b -> b
20:41:11 <lambdabot>     Just c -> c
20:41:19 <dolio> @type appEndo . mconcat . map Endo
20:41:23 <lambdabot> forall a. [a -> a] -> a -> a
20:41:29 <lispy> ?type foldr (.) id (repeat id) (const True) undefined
20:41:33 <lambdabot> Bool
20:41:38 <dino-> > sum $ map (const 1) "foobar"
20:41:40 <lambdabot>  6
20:41:44 <lispy> ?check foldr (.) id (repeat id) (const True) undefined == True
20:41:47 <lambdabot>  Exception: <<loop>>
20:41:54 <Cale> :t foldr (.)
20:41:58 <lambdabot> forall b (f :: * -> *). (Functor f) => f b -> [b -> b] -> f b
20:42:05 <Cale> :)
20:42:50 <faxathisia> :t (.(.(.(.(.(.))))))
20:43:05 <lambdabot> thread killed
20:43:09 <faxathisia> :p
20:43:19 <lispy> faxathisia: whoa
20:43:19 <solrize_> :t (.)
20:43:22 <Cale> :t (.(.(.(.(.(.))))))
20:43:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:43:26 <lambdabot> forall b b1 b2 b3 b4 a b5 (f :: * -> *). (Functor f) => ((((((f a -> f b5) -> b4) -> b3) -> b2) -> b1) -> b) -> (((((a -> b5) -> b4) -> b3) -> b2) -> b1) -> b
20:43:42 <Cale> (code.h.o is flaky sometimes)
20:44:08 <Cale> :t (.).(.)
20:44:12 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
20:45:23 <lispy> Since when was (.) defined on functors?
20:45:24 <faxathisia> I wish there was another way to write (.).(.)
20:45:32 <Cale> lispy: Since I generalised it ;)
20:45:34 <lispy> I thought it was just f . g x = f (g x)
20:45:37 <faxathisia> There should be an operator that does this
20:45:47 <Cale> lispy: It is, in the Prelude :)
20:45:51 * ddarius needs to figure out how to write a modern .cabal file.
20:45:53 <lispy> ?src (.)
20:45:54 <lambdabot> (f . g) x = f (g x)
20:45:54 <Cale> (f . g) x = f (g z)
20:46:00 <faxathisia> (f . g) x = f (g x)
20:46:00 <Cale> er, x ;)
20:46:05 <faxathisia> you can't write f . g x = f (g x)
20:46:07 <ddarius> :t Prelude..
20:46:11 <ddarius> :t (Prelude..)
20:46:13 <lambdabot> parse error on input `Prelude..'
20:46:15 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
20:46:35 <Cale> (a ->) is a functor, so there's a nice generalisation.
20:46:50 <faxathisia> @instances Functor
20:46:51 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
20:47:10 <Cale> (specifically, (.) = fmap)
20:47:12 <faxathisia> > [f,g,h] . [x,y,z]
20:47:14 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
20:47:20 <Cale> > f . [x,y,z]
20:47:21 <lambdabot>  Add a type signature
20:47:25 <Cale> > f . [x,y,z] :: [Expr]
20:47:28 <lambdabot>  [f x,f y,f z]
20:47:40 <faxathisia> :t ?g f [x,y,z]
20:47:43 <lambdabot> forall t a. (SimpleReflect.FromExpr a, ?g::a -> [Expr] -> t) => t
20:47:55 <Cale> > f . (x,y) :: (Expr, Expr)
20:47:57 <lambdabot>  (x,f y)
20:47:57 <faxathisia> I think that . is still using Functor
20:48:08 <Cale> faxathisia: hm?
20:48:10 <faxathisia> oh.. I see
20:48:33 <faxathisia> :t (.)
20:48:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
20:49:04 <faxathisia> > Just . Nothing
20:49:06 <lambdabot>  Nothing
20:49:22 <Cale> It's my (not so subtle) way of abusing the fact that I run lambdabot now in order to spread propaganda regarding the future of the Prelude ;)
20:49:25 <faxathisia> what else can you do with it..
20:49:42 <Cale> Well, anything you could do with fmap or liftM.
20:49:47 <faxathisia> Cale, Do you have a Prelude.hs?
20:49:57 <Cale> No, this is just being done in L.hs
20:50:03 <dolio> > (,) . [1..3] <*> [4..6]
20:50:05 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
20:50:10 <faxathisia> It would be nice to see
20:50:13 <faxathisia> if you do make one
20:50:42 <faxathisia> cool
20:51:10 <faxathisia> :t ((.).(.)) ((,) .) (<*>)
20:51:13 <lambdabot> forall b (f :: * -> *) a b1. (Applicative f) => f (a -> b1) -> f a -> f (b -> (b1, b))
20:53:31 <faxathisia> > ((<*>).((,).)) [1,2,3] [66,88,99]
20:53:34 <lambdabot>  [(1,66),(1,88),(1,99),(2,66),(2,88),(2,99),(3,66),(3,88),(3,99)]
20:56:10 <faxathisia> Cale, you have to use @ty not :t in PM with lambdabot
20:56:26 <faxathisia> (it sucks :/)
20:56:44 <Cale> Yeah, I noticed with mbot that some of the non-@-prefixed commands don't work.
20:56:53 <Cale> I'm not entirely sure why that would be.
20:58:40 <vinc456> i'm working through a book and one of the examples define the following function: percent n m = (fromInt n / fromInt m) * 100
20:59:06 <vinc456> fromInt doesn't seem to be defined
20:59:07 <faxathisia> I think you should use fromIntegral instead of fromInt..
20:59:22 <gwern> no. fromInt used to be in the Integral class, but was subsumed under fromIntegral
20:59:32 <gwern> vinc456: by any chance, was this book written in the '90s?
21:00:09 <vinc456> no, it's Graham Hutton's Programming in Haskell, written in 2007
21:00:10 <Cale> Actually, wasn't it in Num?
21:00:44 <gwern> Cale: I thought it was Integral, but it's been a while since I dealt with old code using fromInt so I won't contest the point
21:00:49 <faxathisia> :t let percent n m = (fromIntegral n / fromIntegral m) * 100 in percent
21:00:52 <lambdabot> forall a a1 b. (Integral a1, Fractional b, Integral a) => a -> a1 -> b
21:01:09 <faxathisia> :t let percent n m = 100 * n / m in percent
21:01:13 <lambdabot> forall t. (Fractional t) => t -> t -> t
21:01:20 <Cale> vinc456: That's really strange. fromInt is pre-Haskell-98
21:02:03 <gwern> http://www.cs.nott.ac.uk/~gmh/book.html <-- says 2007
21:02:03 <lambdabot> Title: Programming in Haskell
21:02:05 <gwern> how odd
21:02:09 <gwern> maybe it's in errata
21:02:31 <gwern> 'Page 44. The library function fromInt has been replaced by a more general function called fromIntegral. (*) '
21:02:33 <faxathisia> :t let (*) `on` f = \x y -> f x * f y ; percent n m = 100 * n / m in  percent `on` fromIntegral
21:02:36 <lambdabot> forall t t1. (Integral t1, Fractional t) => t1 -> t1 -> t
21:05:28 <ddarius> So should I put parsec3 on Hackage as a new version of the parsec package or as a separate package?
21:06:44 <gwern> ddarius: how does it differ from the presumed parsec2?
21:08:02 <SamB> ddarius: who made parsec3?
21:09:04 <ddarius> gwern: There are interface breaking changes though they are relatively minor (from the outside) unless you are doing something weird.  The modern modules are Text.Parsec, there is a "compatibility" tree at Text.ParserCombinators.Parsec which is not perfect, but according Antione Latter can be used with nearly everything on Hackage and the things it doesn't work with need very minor changes.
21:09:13 <ddarius> SamB: Paolo Martini (xerox)
21:09:26 <Cale> Actually, I can't even find a reference to fromInt in the Haskell 1.0 prelude.
21:09:30 <SamB> ddarius: well, can you get a word to daan?
21:09:48 <SamB> Cale: tried 0.9?
21:09:48 <gwern> ddarius: any worse than various bytestring or cabal updates?
21:09:53 <SamB> or wasn't there one?
21:09:58 <gwern> (or Data.Set changes)
21:09:58 <Cale> There wasn't one.
21:10:20 <ddarius> SamB: Unlikely.  I've tried emailing him for other aspects with no response.
21:10:27 <Cale> Well, there were implementations of Haskell before that, but 1.0 was the first report.
21:10:43 <gwern> ddarius: might be politer to send him an ultimatum
21:10:43 <wy> I looked at some shoot out. It seems clean compiles into slightly better code
21:10:44 <SamB> ddarius: appoint xerox the new maintainer then, and ask him what he thinks?
21:11:12 <gwern> aw but heck, why would you listen to*me* about politness and uploading? :)
21:12:31 <ddarius> SamB: I have talked with xerox and talked about taking maintainership for parsec3.  As for his opinion on whether it should be a new version or a completely new package I doubt he has any special insight.
21:12:52 <SamB> how radical are the changes?
21:13:21 <dolio> Parse transformer, arbitrary stream input type...
21:13:33 <SamB> hmm. wait, cabal allows multiple versions of the same package anyway...
21:13:56 <ddarius> In practice, you should be able to use parsec3 for most things via the compatibility modules with no or very minor changes unless you were doing something unusual.  Using the newer modules would require very little work to port to if the compatibility modules work fine.
21:14:19 <andyjgill> Does anyone know if the is a .dot output library for Haskell? Or what a good name for one might be?
21:14:28 <SamB> how much will break ?
21:14:48 <ddarius> andyjgill: Data.Graph.Inductive or whatever it is called has DOT output.
21:15:20 <SamB> if the answer is "everything", it should probably be a new package
21:15:42 <andyjgill> Ahh. The Graphviz output, thanks ddarius
21:16:39 <ddarius> SamB: According to Antoine Latter, there are only few packages on hackage that don't build against the compatibility modules and only for very minor things (and he has patches to fix them)
21:17:15 <SamB> ddarius: and these compatability modules are named the same as the old modules?
21:17:20 <ddarius> Yes.
21:17:32 <SamB> in that case, parsec it should be!
21:18:00 <gwern> good grief, just upload it as parsec already and send off the ANN
21:18:24 <gwern> this is all just software, nobody's gonna die if the right choice was to name it parsec3 instad of parsec-3.0
21:18:52 <SamB> I'm fairly certain that parsec-3.0 is the correct choice in this case ;-)
21:19:34 <ddarius> It very likely (hopefully!) should be the right direction.
21:19:49 <SamB> I hope those patches won't lead to the packages not building with prior versions of parsec?
21:21:15 <vinc456> stupid question, but did people complain when fromInt was removed from Prelude?
21:21:30 <vinc456> since it might have broke old code
21:21:39 <ddarius> The old code was already broken
21:21:47 <ddarius> I'm getting to the point where the released version is going to be more current than the darcs repo.
21:22:03 <Cale> vinc456: There were only maybe a few hundred Haskell programmers back then, and that's being generous.
21:22:18 <Cale> vinc456: This was pre-standardisation Haskell.
21:22:34 <gwern> vinc456: I doubt it. it's a very simple fix, and people had a lot more to worry about as far as breakage went
21:22:43 <gwern> for example, tons of parsing code was broken by MonadZero
21:22:50 <SamB> ddarius: eh?
21:23:00 <gwern> and I mean pretty broken, not something you could fix with a search-and-replace
21:23:03 <SamB> ddarius: push patches!
21:23:31 <vinc456> how many haskell programmers are there now?
21:23:31 <Cale> Well, that was Haskell 98. As far as I can tell, fromInt wasn't even in Haskell 1.0
21:23:33 <scook0> @hoogle mzero
21:23:33 <SamB> or at least send them to a mailing list...
21:23:34 <lambdabot> Control.Monad.mzero :: MonadPlus m => m a
21:23:34 <ddarius> SamB: Something is causing my darcs push to take forever and I may not have an internet connection for a (hopefully) short bit (a few days) tomorrow.
21:24:48 <Cale> Is haskell.org slow for anyone else?
21:25:13 <vinc456> Cale: yep
21:25:24 <ddarius> It seems fine for me other than pushing and I suspect that's not bandwidth.
21:25:27 <SamB> darcs.haskell.org is slow
21:25:43 <ddarius> Or maybe not.
21:26:06 <ddarius> hackage.haskell.org is fine...
21:26:21 <dons> yeah, haskell.org is slow (yale). hackage is a different machine (galois)
21:26:27 <SamB> it doesn't seem to be low on RAM, the CPU is mostly idle
21:28:09 <SamB> hackage.h.o and darcs.h.o appear to be the same machine
21:28:33 <dons> darcs seems fine
21:28:50 <SamB> does it normally take that long to log in?
21:29:09 <SamB> actually, it is pretty snappy once logged in...
21:35:00 <ddarius> Let's see if this works.
21:41:51 <sclv_> ?src ap
21:41:51 <lambdabot> ap = liftM2 id
21:42:34 <faxathisia> ap = liftM2 ($)
21:42:47 <wagle_home> :t ap
21:43:02 <sclv_> ok. say I have a monad m. and I want to write an applicative instance for (r->m)...
21:43:02 <lambdabot> thread killed
21:43:18 <sclv_> pure is const . return.
21:43:24 <sclv_> what's (<*>) going to be?
21:43:28 <sclv_> fmap ap isn't right.
21:43:31 <ddarius> ap
21:43:32 <wagle_home> :t ap
21:43:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:44:03 <dolio> pure = return, (<*>) = ap
21:44:28 <ddarius> @src ReaderT return
21:44:28 <lambdabot> Source not found. :(
21:44:29 <faxathisia> :t (<*>)
21:44:31 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
21:44:38 <dolio> Oh, wait.
21:44:58 <sclv_> right -- its a monad inside an unwrapped reader monad.
21:45:12 <sclv_> there's an easy answer i'm sure, trying to work the types out now.
21:45:49 <sclv_> of course in the end the real answer will probably be "wrap it in another readerT and get applicative for free"
21:47:16 <dolio> One of the papers on applicative functors should probably explain how to define pure and ap for the composition of two applicative functors.
21:48:05 <sclv_> ?ty \c -> ap a (b c)
21:48:09 <lambdabot>     Couldn't match expected type `m (a -> b)'
21:48:09 <lambdabot>            against inferred type `Expr'
21:48:09 <lambdabot>     In the first argument of `ap', namely `a'
21:48:49 <sclv_> ?ty \ a b c -> ap a (b c)
21:48:51 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => m (a -> b) -> (t -> m a) -> t -> m b
21:49:02 <sclv_> whee!
21:49:17 <sclv_> ?pl \ c -> ap a (b c)
21:49:17 <lambdabot> ap a . b
21:49:28 <sclv_> and that would be the ticket.
21:50:07 <faxathisia> :t \a b -> ap a . b
21:50:09 <ddarius> Hmm.  It seems my patch is just problematic.
21:50:18 <dolio> Or you could just use TypeCompose.
21:50:22 <lambdabot> thread killed
21:50:25 <faxathisia> :t \a b -> ap a . b
21:50:32 <lambdabot> forall (m :: * -> *) a b (f :: * -> *). (Functor f, Monad m) => m (a -> b) -> f (m a) -> f (m b)
21:50:57 <sclv_> oh yeah, its not quite right still i guess..
21:51:23 <sclv_> ?ty \ a b c -> ap (a c) (b c)
21:51:28 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => (t -> m (a -> b)) -> (t -> m a) -> t -> m b
21:51:40 <sclv_> ?pl \ c -> ap (a c) (b c)
21:51:40 <lambdabot> liftM2 ap a b
21:51:44 <sclv_> there we go.
21:51:53 <faxathisia> :t liftM2 ap a b
21:51:55 <lambdabot>     Couldn't match expected type `m (m1 (a -> b))'
21:51:55 <lambdabot>            against inferred type `Expr'
21:51:55 <lambdabot>     In the second argument of `liftM2', namely `a'
21:52:26 <dolio> pure = O . pure . pure ; (<*>) = inO2 (liftA2 (<*>))
21:53:04 <faxathisia> what's O?
21:53:22 <dolio> Type composition constructor.
21:53:59 <dolio> (g `O` f) a = g (f a)
21:54:15 <dolio> And if g and f are applicative functors, so is (g `O` f)
21:55:44 <sclv_> I thought it was :. now instead of `O`
21:55:52 <lQg_> how do i compare strings?
21:56:01 <faxathisia> lQg_: == < and >
21:56:10 <faxathisia> > "this" `compare` "that"
21:56:11 <lQg_> kk
21:56:13 <lambdabot>  GT
21:56:16 <faxathisia> it works too..
21:56:20 <lQg_> kk
21:56:23 <faxathisia> LT | EQ | GT
21:56:23 <dolio> Yeah. But the value-level constructor is still O, aparrently.
21:59:30 <SamB> (g `O` f) a = g (f a) -- that can't be
21:59:35 <sclv_> sigh. now i'm getting kind mismatches.
22:00:06 <dolio> That's effectively what it is.
22:01:40 <wagle_home> >t O
22:01:44 <dolio> newtype (g :. f) a = O { unO :: g (f a) }
22:02:05 <sclv_> how do I even write this???
22:02:14 <sclv_> ?kind Int -> Maybe a
22:02:16 <lambdabot> Not in scope: type variable `a'
22:02:23 <sclv_> ?kind Int -> Maybe
22:02:26 <lambdabot>     `Maybe' is not applied to enough type arguments
22:02:26 <lambdabot>     Expected kind `?', but `Maybe' has kind `* -> *'
22:02:38 <faxathisia> :t const Nothing :: Int -> Maybe a
22:02:40 <SamB> ?kind Int -> Maybe ?a
22:02:40 <lambdabot> forall a. Int -> Maybe a
22:02:42 <lambdabot> parse error on input `?a'
22:02:54 <SamB> ?kind Int -> Maybe Int
22:02:56 <lambdabot> *
22:03:03 <faxathisia> type Foo a = Int -> Maybe a
22:03:07 <faxathisia> can you do this?
22:03:13 <faxathisia> Foo :: Int -> Maybe
22:03:17 <faxathisia> I don't know if that works
22:03:22 <sclv_> so say I'm writing an instance of applicative for (Int -> Reader Int String) as a simple case.
22:03:35 <SamB> faxathisia: that won't work!
22:03:45 <faxathisia> :(
22:03:48 <sclv_> that's got a kind * so I really need to drop the String and get a kind *->* but obv just dropping the string doesn't cut it.
22:03:53 <faxathisia> How to do it
22:04:22 <dolio> sclv_: You can't do that. You need newtypes for that.
22:04:33 <sclv_> sigh. ReaderT it is.
22:04:40 <dolio> Or full type-level lambda expressions, which Haskell doesn't have.
22:04:53 <sclv_> exactly what I wanted. :-(
22:05:09 <sclv_> its silly, because its obviously something that can be expressed.
22:05:23 <sclv_> we just don't have the machinery to say it.
22:05:42 <dolio> TypeCompose is probably as close as you'll get.
22:06:11 * sclv_ also wants partially applied type synonyms.
22:06:23 <sclv_> and that's just the sane requests!
22:06:25 <SamB> sclv_: the compiler has a hard enough time doing type inference as it is
22:06:34 <faxathisia> why not have type level lambdas?
22:06:46 <faxathisia> you could add that pretty easy I think
22:06:48 <dolio> You could go write your program in Coq or something and extract to Haskell.
22:06:55 <SamB> faxathisia: including inference?
22:06:56 <sclv_> SamB: these don't add complexity, just expressivity to the already existing machinery.
22:07:12 <faxathisia> SamB: No, inference would not generate any lambdas
22:07:24 <SamB> sclv_: my understanding is that most times when you do that it makes inference harder
22:07:28 <faxathisia> just use the exact same inference we do currently
22:07:35 <SamB> you think so?
22:07:41 <SamB> well, make it so!
22:07:47 <SamB> what are you waiting for?
22:08:08 <SamB> the usual syntax is /\a ->
22:08:12 * sclv_ first wants to finish the darn project that's sparking all these issues.
22:08:36 <sclv_> pointfree types would be pretty awesome though.
22:08:56 <sclv_> type level Flip and all!
22:09:26 <faxathisia> hmmmmmmm
22:09:32 <sclv_> type MapOfStrings = Flip Map String
22:09:37 <dolio> For one, type level lambdas give you the (/\a -> a) monad, which I seem to recall SPJ saying made type inference difficult.
22:10:08 <faxathisia> who needs type inference, justn write all your programs in the type system
22:10:37 <SamB> don't you especially need type inference for that to be possible?
22:10:44 <wagle_home> there needs to be a book: Basic Simple Haskell Type Theory
22:10:55 <SamB> or:
22:11:01 <SamB> basic olegery
22:11:02 <mae> what are the valid characters for a function name
22:11:26 <SamB> mae: alphanumeric, _, and '
22:11:29 <SamB> OR
22:11:45 <faxathisia> really nice that you can use ' in identifier namse
22:11:48 <SamB> an operator name
22:11:56 <mae> ic
22:12:01 <SamB> also, you can't begin with anything but a lowercase or _
22:12:11 <sclv_> here's another example where I want type lambdaish things or a subset:
22:12:45 <sclv_> Reader (Maybe a) -- i want to make this alternative, but can't, I think...
22:12:57 <sclv_> i'd need to make it ReaderT (Maybe a), no?
22:13:26 <dolio> MaybeT (Reader r) a
22:13:53 <sclv_> yeah, or that.
22:14:20 <dolio> MaybeT Reader = Reader (Maybe a), ReaderT Maybe = Maybe (Reader a).
22:14:23 <faxathisia> type Foo a = Int -> Maybe a -- what's wrong with this?
22:14:24 <sclv_> so if I want all my precioussss alternative instances to simply my syntax I have to go through and change the transformer stack for my whole program again.
22:15:12 <sclv_> fax: if I put just Foo in an instance declaration, I get an error that its not applied to enough arguments...
22:15:35 <sclv_> i'd need /
22:15:36 <dolio> Right, you need to make Foo a newtype, not a type.
22:15:48 <sclv_> er./\a -> Foo a
22:16:12 <sclv_> at which point I have dirty newtypes fouling up my pretty pretty syntax.
22:16:17 <faxathisia> newtype Foo a = Int -> Maybe a -- what's wrong with this?
22:16:18 <faxathisia> ?
22:16:23 <mae> how does the @ operator work
22:16:38 <faxathisia> mae: How is it defined?
22:16:43 <mae> not sure
22:16:45 <faxathisia> oh you mean
22:16:59 * sclv_ might bite the bullet and use newtypes after all that whining anyway.
22:17:07 <dolio> Where? You should be able to define the usual functions for it, and then need to use runFoo at the end.
22:17:13 <faxathisia> > let f foo @ (x,y) = [foo, x, y] in f (3,6)
22:17:17 <lambdabot>      Occurs check: cannot construct the infinite type: t = (t, t1)
22:17:17 <lambdabot>       Expe...
22:17:27 <faxathisia> > let f foo @ (x,y) = (foo, x, y) in f (3,6)
22:17:28 <mae> ohh
22:17:28 <lambdabot>  ((3,6),3,6)
22:17:34 <mae> so you give an identifier and a pattern
22:17:35 <mae> for something
22:17:36 <mae> right
22:17:37 <faxathisia> mae: That thing?
22:17:43 <sclv_> think of it as "as" instead of "at"
22:18:00 <faxathisia> It just means the thing before the @ is bound to the entire object
22:18:15 <faxathisia> > let f (a,b) @ (c,d) = (a, b, c, d) in f (3,6)
22:18:16 <lambdabot>  Parse error at "@" (column 13)
22:18:19 <faxathisia> :(
22:19:02 <sclv_> dolio: yeah. just want to explore the solution space fully at this point. ~600 lines of code, changing the transformer stack type is not trivial at this point...
22:19:13 <sclv_> i should have probably gone for a MaybeT earlier on.
22:19:29 <SamB> sclv_: should have abstracted it!
22:19:43 <SamB> I'm always doing that too ;-)
22:19:46 <sclv_> it was! behind a type synonym... :-(
22:19:54 <SamB> that one also!
22:21:40 <dolio> You shouldn't even have to mention what specific monad you're using in most functions, should you? It should just be: 'foo :: (Alternative m, MonadReader r m) => stuff-involving-m'.
22:24:06 <sclv_> well, lesson learned.
22:24:43 <ddarius> darcs troubles solved
22:26:32 <SamB> troubles?
22:26:33 <sclv_> I do have to say though, newtype deriving ftw!
22:27:38 * SamB wonders why darcs.h.o has darcs 1.0.9rc1 installed...
22:34:29 <ddarius> For a second I thought I didn't know my Hackage password
22:35:08 * dolio doesn't know his.
22:35:47 <SamB> I forget mine :-(
22:36:37 <sclv_> wow! newtype successfully deployed. :-) that wasn't too painful.
22:36:48 <ddarius> Hackage doesn't yet generate haddock?
22:37:00 <SamB> ddarius: wait a couple of weeks
22:37:14 <SamB> it does not happen immediately, but someone will make it happen sometime
22:37:54 <ddarius> cool
22:50:29 <lQg_> does hGetLine work with files?
22:51:01 <faxathisia> I think so...
22:51:04 <dolio> @type hGetLine
22:51:08 <lambdabot> Not in scope: `hGetLine'
22:51:11 <dolio> I don't see why it wouldn't.
22:51:12 <faxathisia> doesn't it just work on the current IO steam
22:51:37 <faxathisia> lQg_: http://www.zvon.org/other/haskell/Outputio/hGetLine_f.html
22:51:37 <lambdabot> Title: Haskell : hGetLine
22:51:44 <faxathisia> look at the example
22:51:58 <lQg_> kk
22:52:41 <lQg_> do i have to close file after?
22:53:38 <lQg_> kk guess not
22:53:59 <radetsky> for anyone who's still keeping score, you can in fact do in plain curses what causes hscurses to die
22:55:23 <Cale> lQg_: you probably should close the filehandle when you're done with it.
22:59:35 <SamB> man, jhc's libs still have the cycle of death...
22:59:56 <ddarius> Parsec 3 released
23:04:39 <SamB> well, it seems to be a cycle of less death than before
23:07:41 <goltrpoat> potentially dumb question -- when church encoding an inductive type, the type constructor is normally translated as an existential:  List a = Nil | Cons a (List a) ==> type List a = forall b. b -> (a -> b -> b) -> b.
23:08:08 <goltrpoat> now, if you move the b to the left hand side, intuitively it should be less general
23:08:24 <ddarius> That's a universal
23:09:03 <goltrpoat> but i can't come up with an example, and this leads to something very weird if you take an arbitrary function type in two arguments and "de-encode" the consequent as a data type
23:10:17 <faxathisia> you can't do this with polymorphic lambda calculus can you?
23:10:27 <goltrpoat> (as in, it feels like i'm skolemizing a random variable just because it's the consequent, and i can't tie that back to logic in any reasonable sense of the word)
23:10:29 <faxathisia> I mean you get type errors eventually right?
23:11:03 <goltrpoat> no, you get useful types.  i just don't understand why i'm getting them.
23:11:32 <faxathisia> data Nat = Z : Nat | S : Nat -> Nat goes to b -> (a -> b) -> b right?
23:11:52 <ski_> `Z : Nat' ?
23:12:03 <faxathisia> oops ::
23:12:09 <ski_> oh, i see
23:12:58 <lQg_> @hoogle closeFile
23:12:58 <SamB> lapsing into ML?
23:13:03 <lambdabot> No matches found
23:13:07 <ski_> indeed
23:13:23 <lQg_> @hoogle openFile
23:13:23 <ddarius> goltrpoat: Look at second order logic.
23:13:23 <lambdabot> System.IO.openFile :: FilePath -> IOMode -> IO Handle
23:13:33 <goltrpoat> fax:  it goes to a -> (a -> a) -> a i think, otherwise exponentiation stops being Nat -> Nat -> Nat
23:13:39 <ski_> goltrpoat : what do you mean by "if you move the b to the left hand side, intuitively it should be less general" ?
23:13:48 <faxathisia> ok
23:13:50 <lQg_> @hoogle Handle -> IOMode
23:13:51 <lambdabot> No matches, try a more general search
23:13:56 <lQg_> @hoogle Handle ->
23:13:56 <lambdabot> No matches, try a more general search
23:14:02 <lQg_> @hoogle Handle
23:14:02 <lambdabot> System.IO.Handle :: data Handle
23:14:02 <lambdabot> Control.Exception.handle :: (Exception -> IO a) -> IO a -> IO a
23:14:02 <lambdabot> System.IO.HandlePosn :: data HandlePosn
23:14:06 <lQg_> bah
23:14:08 <lQg_> i give up
23:14:21 <ski_> goltrpoat : not universally quantifying ?
23:14:24 <goltrpoat> ski:  right
23:14:38 <faxathisia> goltrpoat: but in haskell can you define zero and succ.. and succ (succ (succ (succ zero))) :: Nat ?
23:14:52 <faxathisia> I thought it gives a type error
23:15:22 <ski_> zero :: (a -> a) -> a -> a
23:15:37 <ski_> succ :: (forall a. (a -> a) -> a -> a) -> (a -> a) -> a -> a
23:16:14 <faxathisia> ohh..
23:16:15 <goltrpoat> Nat is probably not the best example, since b is forced to a if you want exponentiation (otherwise it types fine with b->(a->b)->b, i think)
23:16:18 <faxathisia> Wow clever
23:16:29 <faxathisia> I had no idea that was possible
23:16:50 <faxathisia> I think that trick should generalize to any albraic type then
23:17:19 <goltrpoat> oh it does
23:19:22 <goltrpoat> (although what happens with coinductive types is still breaking my brain)
23:19:44 <faxathisia> what coinductive types?
23:20:21 <goltrpoat> data Complete a = Leaf a | Complete (a,a)
23:20:34 <faxathisia> how is that coinductive?
23:21:21 <faxathisia> data Term a = Var a | Lam (Term (Maybe a)) | App (Term a) (Term a) -- is this coinductive too?
23:21:36 <goltrpoat> yes, as i far as i understand
23:21:53 <goltrpoat> that was actually the working example in a paper i was reading the other day
23:22:10 <faxathisia> I thought it was somethign else
23:22:51 <faxathisia> http://www.iis.sinica.edu.tw/~scm/2007/encoding-inductive-and-coinductive-types-in-polymorphic-lambda-calculus/
23:22:53 <lambdabot> Title: Encoding Inductive and Coinductive Types in Polymorphic Lambda Calculus | Niche  ..., http://tinyurl.com/2nx4su
23:25:02 <goltrpoat> oh heh.  that was actually the other question i was going to ask, why does the church encoding for lists look like fold and not like build
23:25:09 <goltrpoat> thanks
23:25:48 <faxathisia> this is very interesting
23:25:52 <faxathisia> I did not know about this
23:26:40 <sclv_> every time I think I get haskell, I try to do something more outlandish and feel my brain breaking all over again...
23:26:42 <sclv_> :-)
23:26:59 <faxathisia> sclv: Examples?
23:27:22 <sclv_> I got the newtype working, and then the MaybeT spliced in. Now I
23:27:51 <dmwit> His brain broke.
23:28:09 <sclv_> I'm going to try to add some phantom types to my code tomorrow, and switch over to some new stuff with my readerT and local to wrap the unwrapped bit...
23:28:40 <sclv_> each piece makes sense on its own, but putting them all together is sort of a challenge.
23:29:17 <sclv_> its not the type of thing i could have ever contemplated in another language at all -- the phantom types will probably be a real hassle.
23:29:27 <sclv_> I always expect more from the typechecker than it can give.
23:29:46 <sclv_> my darcs repo is sort of littered with failed experiments in polymorphism at the moment.
23:31:47 <sclv_> if I just wanted to do stuff instead of write a fancy clean interface, this would be cake...
23:32:12 <faxathisia> :t ?a `undefined` "b
23:32:14 <faxathisia> :t ?a `undefined` ?b
23:32:15 <lambdabot> forall t t1 t2. (?b::t1, ?a::t) => t2
23:32:15 <lambdabot> lexical error in string/character literal at end of input
23:32:28 <sclv_> writing with others in mind is nice because it just sort of forces you into way more discipline.
23:33:23 <goltrpoat> so this is what i'm trying to reconcile in my head:  data Proof a where Witness = a -> Proof a; IndStep = (a -> Proof a) -> a -> Proof a (a "de-encoding" of fix :: ((a->b)->a->b)->a->b), obviously works)
23:33:38 <goltrpoat> now add another constructor to it:  Peirce :: ((Proof a -> a) -> Proof a) -> Proof a
23:34:00 <faxathisia> goltrpoat: shouldn't be data Proof a where Witness : a -> Proof a ?
23:34:03 <faxathisia> ugh
23:34:05 <faxathisia> I mean ::
23:34:26 <goltrpoat> now, prove (Witness x) = x; prove (IndStep f x) = proof (f x); prove (Peirce p) = prove (p prove)
23:34:45 <faxathisia> should you have :: instead of = ?
23:35:00 <goltrpoat> and i've just typed peirce's law:  map2 f [] = Witness []; map2 f (x:xs) = Peirce (\p -> return (f x : p (map2 f xs)))
23:35:32 <faxathisia> can you hpaste this?
23:35:36 <goltrpoat> yeah, sorry.
23:36:41 <hpaste>  goltrpoat pasted "eh." at http://hpaste.org/6150
23:37:56 <ski_> faxathisia,goltrpoat : haskell `data' makes no difference between inductive and coinductive
23:38:14 <ski_> what may differ is the intention of the programmer
23:38:17 <goltrpoat> basically, it looks like the process i'm using to treat functions as church encodings is pulled out of thin air, but it ends up in things that behave reasonably well
23:38:37 <goltrpoat> ski:  i don't think anyone claimed that it did :)
23:38:56 <ski_> <faxathisia> data Term a = Var a | Lam (Term (Maybe a)) | App (Term a) (Term a) -- is this coinductive too?
23:39:04 <ski_> <goltrpoat> yes, as i far as i understand
23:39:13 <Cale> http://news.uns.purdue.edu/images/+2008/jiang-bacteriophage.jpg -- A bacteriophage at a resolution of 4.5 angstroms.
23:39:50 <goltrpoat> ski:  church encoding coinductive types is weird
23:40:01 <goltrpoat> ski:  faxathisia's Term is coinductive
23:40:01 <faxathisia> What is a coinductive type?
23:40:36 <ski_> coinductive types are greatest solutions to recursive type equations
23:40:48 <ski_> (inductive are the least solutions)
23:40:49 <sclv_> faxathisia: I think its being used as another term for codata here?
23:40:55 <faxathisia> ok
23:40:59 <faxathisia> so in haskell for example
23:41:01 <faxathisia> @src []
23:41:01 <lambdabot> data [] a = [] | a : [a]
23:41:07 <faxathisia> this is both ?
23:41:29 <goltrpoat> that's an inductive type in that definition, as i understand
23:41:32 <faxathisia> because you write 1 : 2 : 3 : [] or you can write fix (1:) ?
23:41:39 <goltrpoat> right
23:41:43 <ski_> faxathisia : if what we intend by that type is all finite lists of values of type `a', then that is inductive
23:41:52 <ski_> induction works on inductive types
23:41:58 <faxathisia> left is as an inductive and right is used as a coinductive?
23:42:11 <faxathisia> but really... it's more correct in this case to say it's neither
23:42:12 <sclv_> induction here meaning, erm, structural recursion?
23:42:21 <ski_> yes
23:42:25 <faxathisia> ok
23:42:54 <piojo> Hi, everyone. I'm having trouble with STArrays whose type is not fully specified. Could anybody give me a pointer on how to declare these? (short paste: http://hpaste.org/6151 )
23:43:19 <ski_> the inductive solution to `Stream a = (a,Stream a)' is the empty type, hence it is not very useful
23:43:31 <ski_> the coinductive solution to that equation is however useful
23:44:11 <ski_> regarding `foldr' and `build', note that
23:44:52 <ski_>   type ChurchList a = forall b. (a -> b -> b) -> b -> b
23:45:14 <ski_>   foldr :: [a] -> ChurchList a  -- module argument order
23:45:25 <ski_>   build :: ChurchList a -> [a]
23:45:33 <ski_> these two are inverses
23:45:41 <goltrpoat> sure
23:45:54 <goltrpoat> foldr cons nil and xs (:) []
23:46:14 <Cale> piojo: You likely don't want the STArray to have an unknown type, you want the elements to have the same type as the elements of xs.
23:47:22 <Cale> piojo: In order to refer to that type variable, you can use the scoped type variables extension, simply by explicitly writing  sortList :: forall a. Ord a => [a] -> [a]
23:47:29 <sclv_> piojo: in any case, don't you want to be working in the ST monad to begin with?
23:47:47 <Cale> and then in the body of sortList, the tyvar a will be bound to that type
23:48:17 <sclv_> if you do it all in the ST monad with a top level type signature, the other types should work themselves out on their own...
23:48:21 <piojo> sclv_: well, i'm going to write quicksort, and i thought it would be nice to make it work on any MArray (when my design becomes a bit less convoluted / when things start working)
23:48:33 <Cale> (but yes, you should be doing this in the ST monad, your arr is actually an action, which when executed in the ST monad will produce an array from xs)
23:49:43 <sclv_> piojo: so give the top level sort an [Int]->[Int] type signature, and do everything inside a runST or runSTArray
23:49:58 <Cale> sclv_: uh, no
23:49:59 <sclv_> then when you want to switch, just generalize that top level signature...
23:50:10 <Cale> er...
23:50:23 <piojo> sclv_: i would rather have a method underneath that does the heavy lifting for all variations of this sort
23:50:31 <Cale> Why would you not give the sort a general type signature to begin with?
23:50:52 <sclv_> well, yeah, there's that too...
23:51:22 <piojo> Cale: i'm still messing around, trying to make things work. i'm not really being careful about design
23:51:23 <dmwit> > let s i (p:g:t) = s i (p`i`g:s i t); s o w = w; p e t = head (s e t) in p (*) [1..10]
23:51:23 <lambdabot>  3628800
23:51:42 <dmwit> Just for fun. =)
23:51:55 <sclv_> ?hoogle runSTArray
23:51:55 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
23:52:05 <goltrpoat> ski:  i guess to answer my question then, lists just happen to be both?  i'm still not sure what the property for "both" is, since the type isn't exactly foldr
23:52:08 <faxathisia> woah!
23:52:31 <sclv_> ^^should make yr. messing around simpler...
23:53:36 <piojo> sclv_: i know about runSTArray, but i still can't create STArrays with type (Ord a), I've only made it work with Int
23:54:02 <sclv_> piojo: I'
23:54:27 <sclv_> erm, I'm probably being dense here, but it seems to me that you're thinking of this funny.
23:54:34 <goltrpoat> ski:  i mean, i know what the property is, but i don't know how that ties into the fact that the encoding looks almost like a foldr.
23:54:41 <piojo> Cale: "sortList :: forall a. Ord a => [a] -> [a]" generates a parse error on "=>"
23:55:07 <hpaste>  Cale pasted "general layout for sorting in ST" at http://hpaste.org/6152
23:55:09 <faxathisia> goltrpoat: Do you know how to derive the fold for any algebraic datatype?
23:55:14 <piojo> sclv_: you are likely right, or we're misunderstanding each other. (i frequently think funny in haskell)
23:55:26 <Cale> piojo: {-# LANGUAGE ScopedTypeVariables #-}
23:55:37 <Cale> (or -fglasgow-exts)
23:55:59 <piojo> Cale: thanks, that did it
23:56:04 <sclv_> you'll never create an STArray with type (Ord a) -- you'll write a function that creates an STArray with a specific type.
23:56:18 <sclv_> the function is polymorphic, the array you create isn't.
23:56:28 <piojo> sclv_: yeah, i was just trying explain it lazily. sorry
23:56:32 <goltrpoat> fax:  in the sense that the type has a reasonable catamorphism?  sure
23:56:34 <dolio> goltrpoat: Isn't the Church encoding for any datatype effectively its eliminator?
23:56:44 <Cale> sclv_: see my paste
23:57:02 <faxathisia> fold = eliminator = catamorphism
23:58:23 <dmwit> I wonder if there's any work done on "name propogation" or so.
23:58:32 <dmwit> (sp? propagation?)
23:58:34 <piojo> Cale and sclv_, thank you both. I can resume playing now... and if what you've told me enables me to compile the quicksort in the wiki, i'll fix it there. (i haven't looked, but your language pragma might be what was missing from the example)
23:58:37 <goltrpoat> dolio:  well, you  can't unify the church encoding of [a] with foldr on a, right.  you get b=[b].  so it's not quite the eliminator.
23:59:10 <faxathisia> goltrpoat: What's the eliminator if not the catamorphism?
23:59:36 <Cale> piojo: actually, you don't need the pragma, you only need it to give an explicit type signature to the action which constructs the array for you
23:59:53 <Cale> piojo: (for instance, the code I just hpasted doesn't need it)
23:59:55 <dolio> [a] = forall b. (a -> b -> b) -> b -> b, right?
