00:00:23 <dolio> It even disallows n+k patterns.
00:04:48 <bd_> @src mfix
00:04:48 <lambdabot> Source not found. Take a stress pill and think things over.
00:04:52 <bd_> @src mfix []
00:04:52 <lambdabot> Source not found. Sorry.
00:05:41 <glguy> ?src [] mfix
00:05:41 <lambdabot> mfix f = case fix (f . head) of
00:05:41 <lambdabot>            []    -> []
00:05:41 <lambdabot>            (x:_) -> x : mfix (tail . f)
00:08:28 <dcoutts> @tell bringert on second thoughts I could do a short informal whiteboard talk about a dependency/make-like monad/edsl for doing parallel incremental computations
00:08:28 <lambdabot> Consider it noted.
00:18:16 <solrize_> @src Data.ByteString.Lazy.hGet
00:18:16 <lambdabot> Source not found. You type like i drive.
00:18:54 <solrize_> @hoogle defaultChunkSize
00:18:54 <lambdabot> Data.ByteString.Lazy.Internal.defaultChunkSize :: Int
00:19:09 <solrize_> > Data.ByteString.Lazy.Internal.defaultChunkSize
00:19:09 <lambdabot>      Not in scope: `Data.ByteString.Lazy.Internal.defaultChunkSize'
00:19:37 <solrize_> dcoutts if you're still here, do you know where that is defined?
01:03:57 <hawkerb> is there any haskell tutorial for programmers coming from OO world? :-)
01:04:05 <solrize_> hmm
01:04:14 <solrize_> there's something called "haskell for c programmers"
01:04:27 <solrize_> http://www.haskell.org/~pairwise/intro/intro.html
01:04:27 <lambdabot> Title: Haskell for C Programmers
01:04:38 <desegnis> Haskell from the OO world is about the same as Haskell from the procedural world
01:04:39 <hawkerb> wonderful, thanks guys
01:06:11 <Twey> OO is, basically, organisation of procedural code
01:06:13 <solrize_> http://haskell.org/haskellwiki/Tutorials   several others
01:06:15 <lambdabot> Title: Tutorials - HaskellWiki
01:08:19 <solrize_> http://www.md.chalmers.se/~rjmh/Papers/whyfp.html   <--- you should read this to get a sense of what you're getting into, even though it's not about haskell.  the examples use a now-obsolete forerunner of haskell so it's mostly about the ideas that haskell tries to enable
01:08:21 <lambdabot> Title: Why Functional Programming Matters
01:10:51 <hawkerb> thanks, it definitly seems to be more for me then gentle introduction
01:13:36 <solrize_> haskell definitely has a steep learning curve
01:14:53 <solrize_> the hughes paper is academic and motivational though.  skip ahead to the numerical example (p.7) if you're into that
01:16:26 <Twey> hYes, it does
01:16:39 * Twey is *still* on it :-(
01:16:58 <hawkerb> one question - haskell is a static language and doesn't have 'eval' function (like script languages - ruby, python, php..) ? how is then possible that programs like ghci works ?
01:17:12 <solrize_> eh?  the same way that gcc works
01:17:28 <hawkerb> I mean ghci, interpreter, not compiler
01:17:39 <hawkerb> I haven't seen C interpreter except csh
01:17:52 <solrize_> oh.  hmm.  through some hack, more or less.
01:17:59 <Feuerbach> hawkerb: it compiles your program and runs it :)
01:18:19 <hawkerb> oh, that what I was afriad :) thanks
01:18:45 <johnnowak> hawkerb: are you suggesting that you couldn't have an interpreter for a language like Scheme if it didn't expose some 'eval' function?
01:19:34 <allbery_b> ghc can compile to bytecode instead of machine code.  ghci and runhaskell/runghc both use that
01:19:39 <johnnowak> there's nothing to be "afraid" of. ghci isn't doing anything fundamentally different from a python repl.
01:19:47 <dons> hawkerb: there are 'eval' functions for haskell
01:19:54 <dons> :t System.Eval.Haskell.eval
01:19:55 <lambdabot> forall a. (Typeable a) => String -> [System.Eval.Utils.Import] -> IO (Maybe a)
01:19:57 <hawkerb> oh, there are?
01:20:10 <dons> and similar ones in ghci for turning strings into HsValues
01:20:19 <dons> just because there's a type system doesn't mean there's no eval :)
01:20:40 <allbery_b> and the same machinery used by ghci is available via the GHC API to implement eval, on-the-fly typing, etc.
01:21:04 <hawkerb> that's cool
01:21:10 <dons> its just not a common feature of haskell programming -- metaprogramming tends to be a bit dicey with serious static typing
01:21:32 <johnnowak> although there's certainly no reason it should be
01:22:03 <dons> > 1+2 -- btw, lambdabot uses an eval
01:22:05 <lambdabot>  3
01:23:04 <hawkerb> > let { a = 1; b =1; } in a + b
01:23:04 <lambdabot>  2
01:23:09 <Cale> hawkerb: There are C interpreters, of which csh isn't one :)
01:23:45 <hawkerb> yes, I 've heard there are some, but never really used them
01:24:00 <Twey> Why would anyone?  :-\
01:24:00 <Cale> It would be perhaps a bit silly to do so.
01:24:07 <hawkerb> exactly
01:24:08 <Twey> Indeed
01:24:34 <nornagon> well
01:24:41 <nornagon> i often want to test bits of C behaviour
01:24:42 <Cale> The whole point of programming in C is to have a fairly low-level representation of the machine which is still high level enough to be remotely portable.
01:24:56 <nornagon> and i have to write a whole foo.c to do it
01:24:59 <nornagon> which is a bit annoying
01:25:19 <Cale> A C repl would be interesting :)
01:25:51 <dolio> @goo c repl
01:25:52 <nornagon> i think such a thing exists.
01:25:53 <lambdabot> http://neugierig.org/software/c-repl/
01:25:53 <lambdabot> Title: c-repl
01:26:25 <nornagon> neat
01:26:31 <Cale> Nice, and they're managing the source with darcs as well ;)
01:26:35 <dolio> Heh.
01:26:56 <nornagon> @go cint interpreter
01:26:57 <lambdabot> http://directory.fsf.org/project/CINT/
01:26:57 <lambdabot> Title: CINT - Free Software Directory - Free Software Foundation
01:27:33 <allbery_b> why not?  if #c++'s bot can be written in haskell...
01:28:05 <AndreWe_> @index unique
01:28:06 <lambdabot> bzzt
01:28:22 <AndreWe_> How do I use the unique function?
01:28:33 <nornagon> huh, c-repl's even in apt :)
01:28:37 <Twey> It's called 'nub'
01:28:41 <Twey> But... er... you're gone
01:28:49 <Twey> Oh no
01:28:53 <Twey> Misread a name change
01:29:03 * Twey blinks blearily at the terminal.
01:29:07 <AndreWe> Sorry, what does nub stand for, Twey?
01:29:13 <Twey> AndreWe: I have no idea
01:29:16 <allbery_b> it's an English word
01:29:25 <Twey> > nub [1, 2, 3, 3, 5, 4, 5]
01:29:25 <lambdabot>  [1,2,3,5,4]
01:29:35 <allbery_b> @web nub
01:29:38 <lambdabot> *** "Nub" web1913 "Webster's Revised Unabridged Dictionary (1913)"
01:29:38 <lambdabot> Nub \Nub\, v. t. [Cf. {Knob}.]
01:29:38 <lambdabot>    To push; to nudge; also, to beckon. [Prov. Eng.]
01:29:38 <lambdabot>  
01:29:38 <lambdabot> *** "Nub" web1913 "Webster's Revised Unabridged Dictionary (1913)"
01:29:40 <lambdabot> [3 @more lines]
01:29:46 <allbery_b> @more
01:29:46 <lambdabot> Nub \Nub\, n.
01:29:46 <lambdabot>    A jag, or snag; a knob; a protuberance; also, the point or
01:29:46 <lambdabot>    gist, as of a story. [Colloq.]
01:29:57 <allbery_b> ^^^ that
01:30:05 <AndreWe> Thanks, Twey, I thought it was an abbreviation.
01:30:07 <Twey> Aha
01:30:28 <Twey> 3: the choicest or most essential or most vital part of some idea or experience; "the gist of the prosecutor's argument"
01:30:39 <allbery_b> "the nub of the matter" --- an obsolete phrase
01:30:41 <AndreWe> Is there some kind of time complexity available for nub?
01:30:47 <solrize_> i wonder if there's a way to rewrite nub to notice if it's getting an ord instance and use an n log n algorithm instead of quadratic if it can
01:30:48 <Twey> Not that obsolete, now you mention it
01:30:51 <solrize_> andrewe, yeah, nub is quadratic
01:30:54 <solrize_> because it only uses eq
01:31:07 <solrize_> @src nub
01:31:07 <lambdabot> nub = nubBy (==)
01:31:10 <solrize_> @src nubby
01:31:10 <lambdabot> Source not found. stty: unknown mode: doofus
01:31:14 <solrize_> @src nubBy
01:31:14 <lambdabot> nubBy eq []             =  []
01:31:14 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
01:33:07 <AndreWe> Great.
01:33:14 <AndreWe> It's such a terse definition.
01:33:22 <AndreWe> That's what I really like about Haskell.
01:33:41 <dons> ?pl \ y -> not (eq x y)
01:33:41 <lambdabot> not . eq x
01:34:14 <solrize_> @src (/=)
01:34:14 <lambdabot> x /= y = not (x == y)
01:34:21 <solrize_> @src (==)
01:34:21 <lambdabot> x == y = not (x /= y)
01:34:35 <solrize_> uh
01:34:49 <solrize_> :t (==)
01:34:50 <lambdabot> forall a. (Eq a) => a -> a -> Bool
01:34:56 <solrize_> :t (/=)
01:34:57 <lambdabot> forall a. (Eq a) => a -> a -> Bool
01:34:59 <Cale> solrize_: Those are the default implementations
01:35:17 <Cale> solrize_: Any correct instance of Eq will define at least one of the two explicitly.
01:35:18 <solrize_> oh i see
01:35:22 <allbery_b> so you can provide one of them and the Eq class defines the other
01:35:25 <allbery_b> or you can provide both
01:35:28 <solrize_> got it
01:36:29 <paolino> goodness from classes
01:38:46 <paolino> it's good there is haskell in the foreground windows when I see what happens in italy in the background ones
01:43:29 <Kilzool> Key: 4266 Can all talk now
01:43:50 <dons> wrong channel, Kilzool
01:44:05 <dolio> @b52s
01:44:05 <lambdabot> Girl from Ipanema, she goes to Greenland
01:44:12 <dons> heh
01:46:59 <dolio> Quite a video for that one.
01:47:18 <nornagon> @vixen asl?
01:47:18 <lambdabot> 19/f/California
01:47:35 <Twey> Haha
01:47:48 <nornagon> @vixen are you cute?
01:47:48 <lambdabot> i'd like to think i'm pretty
01:47:57 <nornagon> @vixen what are you wearing?
01:47:57 <lambdabot> nothin but my ol tank top and a pair of shorts :)
01:48:49 <dolio> @girl19
01:48:49 <lambdabot> LOL
01:51:07 <dolio> It doesn't have the guy talking over the music, either.
01:51:11 <dolio> Barely a B52s song.
01:52:30 <hawkerb> does haskell support inifinte precission arithmetic by default ?
01:52:45 <Cale> hawkerb: Yes.
01:52:55 <solrize_> > product [1..100]
01:52:55 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
01:52:55 <dolio> For integers.
01:52:58 <Cale> hawkerb: For integers and rationals at least.
01:52:58 <solrize_> 100 factorial
01:53:15 <Cale> (but arbitrary precision floating point isn't there)
01:53:29 <dons> though i've got a partial binding to lib mpfr if you need it
01:53:41 <dolio> Oh, yeah, there's Rational, too, although that's not as default as Integer.
01:53:48 <dons> default(Rational)
01:53:50 <dons> now it is :)
01:53:55 <dolio> :)
01:54:05 <hawkerb> cool, one more thing. when I use print my program compiles and work, but when I use putStr it doesn't compile :)
01:54:16 <dons> putStr only works on strings
01:54:22 <dons> print works on any type supporting Show
01:54:24 <dons> :t print
01:54:25 <lambdabot> forall a. (Show a) => a -> IO ()
01:54:27 <dons> :t putStrLn
01:54:28 <lambdabot> String -> IO ()
01:54:39 <dons> so print 1 is ok, but putStr 1, no.
01:54:43 <Cale> print = putStrLn . show
01:55:00 <hawkerb> right, simple :) can I easily convert int to string?
01:55:07 <dons> via show
01:55:08 <dons> > show 1
01:55:09 <lambdabot>  "1"
01:55:09 <Cale> yeah, that's the job of show
01:55:14 <dons> > read (show 1) :: Int
01:55:14 <lambdabot>  1
01:55:22 <Cale> > show [1,2,3]
01:55:23 <lambdabot>  "[1,2,3]"
01:55:43 <dons> > show (Left (Right (Left (Right (Just "whoa")))))
01:55:43 <lambdabot>  "Left (Right (Left (Right (Just \"whoa\"))))"
01:55:47 <hawkerb> perfect, thank you guys a lot, I am back to learning
01:56:13 <Cale> > show 1.2566e-6
01:56:14 <lambdabot>  "1.2566e-6"
01:58:39 <Cale> show (show (show ())
01:58:41 <Cale> > show (show (show ())
01:58:41 <lambdabot> Unbalanced parentheses
01:58:44 <Cale> > show (show (show ()))
01:58:45 <lambdabot>  "\"\\\"()\\\"\""
01:59:13 <Cale> > let x = show x in x
01:59:14 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
01:59:30 <yuriyp> @src iterate
01:59:31 <lambdabot> iterate f x =  x : iterate f (f x)
02:03:42 <yuriyp> iterate f x =  x : iterate f (f x)
02:09:50 <hawkerb> what's the difference between: fun1( fun2 1 2) and fun1(fun2(1 2)), except that that second form don't compile? :) does it make a tuple or something ?
02:10:06 <Cale> hawkerb: that's applying 1 as a function to 2
02:10:12 <Cale> (the second form)
02:10:18 <hawkerb> oh
02:10:44 <Cale> But if there's no instance of Num for functions, there's no way to interpret that 1 as a function, so the compiler shouts at you
02:12:08 <hawkerb> yes, I understand now, can I somehow use arguments in parenthesis? or I should always type without them?
02:12:44 <allbery_b> without them unless precedence gets in the way
02:13:08 <hawkerb> but this means, that most inner function is always without them ?
02:13:12 <solrize_> > plus 3 2
02:13:15 <lambdabot>   Not in scope: `plus'
02:13:18 <solrize_> > add 3 2
02:13:19 <lambdabot>   Not in scope: `add'
02:13:24 <nornagon> > (+) 3 2
02:13:25 <lambdabot>  5
02:13:58 <solrize_> > sqrt 2
02:13:59 <lambdabot>  1.4142135623730951
02:13:59 <johnnowak> hawkerb: haskell uses parentheses *only* for grouping. you don't write 'foo(bar baz)', you'd write 'foo (bar baz)'
02:14:07 <solrize_> > sqrt (2)
02:14:07 <lambdabot>  1.4142135623730951
02:14:17 <johnnowak> where the parens just enforce that bar is applies to baz first
02:14:25 <allbery_b> curried functions are a feature of haskell, you can pass around "incomplete" function calls and apply them later
02:14:41 <johnnowak> the dual-use of parentheses in most languages for both grouping and application is terrible
02:15:40 <hawkerb> I see, thanks
02:15:52 <allbery_b> > map ((+) 1) [1..5]
02:15:52 <lambdabot>  [2,3,4,5,6]
02:16:02 <nornagon> > map (+ 1) [1..]
02:16:03 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
02:16:17 <allbery_b> partial application of (+) (as a function; nornagon's section syntax is more common but amounts to the same ting)
02:26:00 <hawkerb> damn, I love lazy evaluation, it's just amazing :)
02:27:08 <Cale> hawkerb: Yeah, it's really nice. In a certain sense it turns data structures into control structures.
02:28:05 <Cale> Where other languages have loops, Haskell has lists, and higher-order functions which operate on those.
02:29:43 <Twey> Haha
02:29:51 <Twey> So, Haskell is the anti-Lisp?  :-P
02:30:49 <vegai> you mean lisp doesn't have lists? :)
02:31:37 <Cale> It has lists, but they typically aren't lazy ones (the lazy ones are too verbose to use like that), so you don't quite use them in quite the same way that you do in Haskell.
02:32:27 <Cale> You might, but much of the time, clever Haskell code turns into something really stupid in a strict language. (and vice versa)
02:32:31 <Twey> Lisp uses code as data... Cale is portraying Haskell as using data as code
02:33:40 <Cale> Er, with regard to that last comment, I mean, if you take some piece of Haskell code which uses lazy lists, and you replace those with strict lists, even if the code still terminates, it's not always a good idea.
02:34:05 <Cale> and that prevents you from using lists as control structures a lot of the time
02:38:28 <hawkerb> is somewhere out there a list of big apllications written in haskell ?
02:38:37 <DRMacIver> ["ghc"]
02:38:46 <DRMacIver> *cough* Ok, that's a little unfair. :)
02:38:48 <Twey> Hahaha
02:38:54 <Twey> Yes
02:39:00 <Twey> GHC isn't pure Haskell.  :-P
02:39:01 <Cale> http://haskell.org/haskellwiki/Applications_and_libraries
02:39:02 <lambdabot> Title: Applications and libraries - HaskellWiki
02:39:16 <Cale> That includes lots of libraries though
02:39:40 <Cale> and doesn't include work that's been done by private companies
02:40:27 <hpaste>  DRMacIver pasted "Build failure on xmonad" at http://hpaste.org/6727
02:41:35 <Cale> By the way, if you're looking for libraries and applications (but more libraries than applications), Hackage is a good place to start
02:41:37 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html
02:41:54 <DRMacIver> oops. Didn't mean to announce that in here.
02:42:02 <DRMacIver> though if anyone here knows what's going on that would be appreciated. :)
02:46:57 <DRMacIver> Hm. Can I persuade cabal upgrade to upgrade only a specific package?
02:51:40 <solrize_> @hoogle modexp
02:51:40 <lambdabot> No matches found
02:51:43 <solrize_> @hoogle modExp
02:51:43 <lambdabot> No matches found
02:51:46 <solrize_> @hoogle expMod
02:51:47 <lambdabot> No matches found
02:51:55 <solrize_> @hoogle exp
02:51:55 <lambdabot> Prelude.exp :: Floating a => a -> a
02:51:55 <lambdabot> Language.Haskell.TH.Exp :: data Exp
02:51:55 <lambdabot> Language.Haskell.TH.Syntax.Exp :: data Exp
02:52:15 <solrize_> @hoogle Integer -> Integer -> Integer -> Integer
02:52:16 <lambdabot> No matches, try a more general search
02:53:15 <solrize_> @hoogle Integral a => a -> a -> a -> a
02:53:16 <lambdabot> No matches, try a more general search
02:54:48 <Cale> DRMacIver: Someone else would know better, but you could either try passing the name of a package, or just do a cabal install (which I think installs the newest version now), and if that still doesn't work, you can use  packagename-<version>
02:55:16 <DRMacIver> No, if you try to do cabal install with something already installed it doesn't do anything even if it's an earlier version.
02:55:21 <Cale> okay
02:55:22 <DRMacIver> Passing the name of the package doesn't do anything either.
02:55:32 <Cale> So perhaps you have to specify the version number...
02:55:37 <DRMacIver> I'll see about doing the version number, yeah
02:55:56 <DRMacIver> Nope.
02:56:14 <Cale> huh. I seem to remember at least that working.
02:56:23 <DRMacIver> Oh, hm. Wait.
02:56:32 <solrize_> hackage trac is down or very slow
02:56:35 <solrize_> crashed
02:56:43 <solrize_> Trac detected an internal error: database is locked
02:56:47 <DRMacIver> No, sorry. That does work.
02:56:55 <monkeylice> DCC SEND ESJKFHLSKJLKAJSDLKSJFLSKGH
02:57:33 <DRMacIver> Related question: How on earth do I remove installed packages?
02:57:56 <Cale> DRMacIver: There isn't a really acceptable way, but you can ghc-pkg unregister them.
02:58:12 <Cale> (which isn't quite the same as removing them, as the files will still be there)
02:59:04 <DRMacIver> That just confuses poor cabal-install
02:59:30 <Cale> oh?
02:59:46 <Cale> You should probably talk to dcoutts about this :)
02:59:49 <DRMacIver> Now the package isn't registered and cabal insists that they're still installed.
02:59:52 <DRMacIver> Yes, I will.
03:00:13 <DRMacIver> Not being able to remove or force a refresh of a package is a huge problem. :-/
03:00:24 <Cale> He actually knows how things work. I've just used it to install a few packages from time to time, and not the latest version either.
03:00:29 <desegnis> Hm, should real uninstall be accomplished by ghc-pkg or cabal-install?
03:00:47 <desegnis> (Does either even track installed files?)
03:00:57 <DRMacIver> cabal install does
03:01:01 <DRMacIver> Which is the root of my problem.
03:01:23 <desegnis> hm
03:01:30 <DRMacIver> (Also, as a result, I now no longer have a working window manager as soon as I restart. Hurray)
03:02:24 <Cale> DRMacIver: hmm
03:02:37 <DRMacIver> (I mean, I can fix that. But it's going to be a nuisance)
03:02:39 <desegnis> Huh? What did tricker that?
03:02:47 <DRMacIver> I upgraded to xmonad 0.7
03:02:55 <Cale> DRMacIver: It should usually be okay to have multiple versions of a package installed, as long as you don't try to use two versions of the same package at the same time
03:02:59 <desegnis> Hm, I did the same, and it worked for me
03:03:03 <DRMacIver> But xmonad-contrib 0.7 doesn't seem to work with cabal install.
03:03:14 <DRMacIver> Or at least my package list breaks it in some subtle way
03:03:26 <DRMacIver> And in trying to fix this I seem to have made things worse. :)
03:04:29 <paczesiowa> do any of you have some spare code of treeviews laying around, so I could look and learn? I have no idea how to iterate through every (no matter selection) node in treestore
03:04:56 <desegnis> Hm, I realize xmonad 0.7 is the only registered version here. Strange
03:07:38 <desegnis> paczesiowa: I guess you need the ContainerClass functions
03:08:22 <desegnis> containerForeach sound good at least
03:09:36 <desegnis> Although, wait, that may not be it at all. Stupd gtk API
03:15:01 <paczesiowa> desegnis: I don't think that's what I need. there are things called TreeIter, but they look awfully lowlevel (using treeModelIterNext, which can fail inside Maybe, and it only works for children, not siblings)
03:15:15 <desegnis> yeah, I realized
03:15:32 <desegnis> You know, I fear there just is nothing less low-level
03:16:15 <paczesiowa> I want smth high-level, like fmap
03:16:59 <desegnis> File a bug report :)
03:17:09 <paczesiowa> it's probably a feature
03:17:27 <paczesiowa> so we all can practice coding up monadic bfs/dfs :>
03:17:33 <desegnis> I don't think so, I think it's an artifact of the original API
03:17:42 <desegnis> bfs?
03:17:50 <desegnis> brain-fuck-style?
03:18:01 <paczesiowa> breadth first search
03:18:09 <desegnis> ah :)
03:20:32 <desegnis> Even the API docs are a little ambiguous. What does "Retrieve an iterator to the next child." mean? The sibling at the next position? A child node, where "next" refers to some magical hidden counter?
03:20:57 <desegnis> Er, I'm not really of any help today.
03:21:15 <paczesiowa> at least, you're not asleep:>
03:38:28 <paczesiowa> damn, gtk has gtk_tree_model_foreach (), in GtkTreeModel, but there is no equivalent in gtk2hs's TreeModel module:/
03:42:01 <desegnis> ouch!
03:42:58 <paczesiowa> C-api is higher level:D
03:44:49 <magnusth> I've managed to use HXT to filter out the links in a HTML file, but the result is still of type XMLTree, what I'd really like would be a [String]... any suggestions on how to do it?
03:45:55 <paczesiowa> >>> getAttrValue "href"
03:46:37 <paczesiowa> assuming you only have nodes with <a> tags
03:47:36 <Heffalump> is HXT good for screenscraping, or does it only work on well-formed HTML?
03:47:40 <Heffalump> s/well-formed/valid/
03:47:54 <paczesiowa> it works with broken html too
03:48:03 <magnusth> yes, I got that far, but how do I actually run the Monad to get that out?  currently I'm using runX which forces me to stick something like mkText after the getAttrValue "href"
03:48:23 <Heffalump> cool, so I can try either tagsoup or that when I need to
03:48:40 <paczesiowa> at least it's good enough to get images out of every frontpage-made pr0n site:>
03:50:49 <hpaste>  magnusth pasted "hxt, getAttrValue "href"" at http://hpaste.org/6729
03:51:21 <hpaste>  Paczesiowa pasted "hxt html links" at http://hpaste.org/6730
03:51:54 <paczesiowa> don't mkText, that turns String into XmlNode
03:55:32 <magnusth> paczesiowa: yes, but my problem is that evaluating "foo "test.html" in ghci doesn't print a list of strings it complains that there's no instance of (Show (IOSLA (XIOState s) b String))
03:55:40 <magnusth> can I get the ti
03:55:59 <magnusth> can I get the type of "foo" to be String -> [String] easily?
03:56:26 <paczesiowa> runX $ foo "test.html"
03:56:29 <magnusth> ah, stupid me
03:56:31 <paczesiowa> but you must be inside IO
03:56:36 <magnusth> yes, just tested that myself, haha
03:56:56 <paczesiowa> or use unsafePerformIO (but you don't want that)
03:57:45 <magnusth> paczesiowa: being inside IO is no problem for me, thanks... all I had really done was misplace a ')'
04:26:40 <u_quark> can anyone explain (ghc-wise) what's the difference between "boot libraries" and "standard libraries" exactly ?
04:28:52 <kosmikus> u_quark: libraries required to build ghc itself vs. libraries required to be present by the Haskell standard?
04:28:54 <yitz> u_quark: boot libraries are what ghc (or whatever other compiler) requires in order to be compiled and then run
04:29:47 <Lycurgus> booting is booting in other words
04:30:10 <yitz> u_quark: standard libraries - I'm not sure if it really has a fixed definition anymore, there is an attempt to deprecate that concept. Instead, lots of libraries are in Hackage and you pick what you need.
04:30:31 <yitz> there may be more than one that provides the same functionality.
04:31:08 <u_quark> ... there are some libs that came along with GHC right ?
04:31:30 <yitz> the idea is that in the future, one or more "ghc distributions" will arise. each distribution will have its target audience, and can define its own set of "standard libraries".
04:31:54 <yitz> that said, the Haskell 98 report does list a few libraries, with their APIs, as part of that standard.
04:31:56 <u_quark> :O omg....
04:32:30 <solrize_> yitz the deprecation is a dumb idea, there's nothing wrong with hackage but it's not a substitute for a real library
04:33:56 <yitz> solrize_: I agree. But the "standard" used to be determined by the GHC team, and they found themselves making decisions based on their own needs rather than the common good. So they don't want to take responsibility anymore.
04:34:35 <yitz> solrize_: so far, no one has stepped up yet to provide a "ghc distribution". do you wanna do it?
04:34:48 <u_quark> lol
04:35:51 <solrize_> yitz in principle i wouldn't mind participating in something like that, but i'm not at the technical level with haskell that it would need
04:36:22 <yitz> solrize_: I think it needs more management skills than technical.
04:36:32 <yitz> solrize_: and time
04:36:35 <solrize_> hmm
04:37:25 <solrize_> nah the technical skill has to be there
04:37:51 <yitz> solrize_: if there are specific technical questions, there are plenty of people willing to help, including both Simons. You can't beat that for a support team! The problem is that it just takes a lot of resources to set something like that up.
04:38:14 <solrize_> resources?  it would take a web site, but haskell.org is already there
04:38:18 <yitz> the ghc doesn't have time anymore, just the compiler more than keeps them busy
04:38:27 <yitz> human resources.
04:38:59 <solrize_> yes.  human resources that understood how to evaluate haskell code and test it and review patches and merge them etc.
04:40:00 <solrize_> sort of like the linux kernel guys.  they don't exactly write or maintain the code but they impose some reasonable standards on its quality
04:40:12 <yitz> solrize_: right. probably it would take a lot of people, not one. so someone needs to have high-level vision, motivate people, etc.
04:40:22 <solrize_> yeah
04:41:17 <solrize_> i don't know about "a lot", python.org has maybe a half dozen committers who are pretty active and some more who are less active
04:41:33 <solrize_> similarly with the apache projects, gcc, etc.
04:41:58 <u_quark> the base lib is ... ?
04:42:21 <u_quark> the base lib is ... ?
04:42:22 <yitz> u_quark: I hope that answers your question. :)
04:42:27 <solrize_> http://haskell.org/ghc/docs/latest/html/libraries/
04:42:40 <u_quark> yitz: more or less... thanks!
04:44:36 <yitz_> solrize_: in the Python tree, see Misc/ACK, do wc -l there.
04:44:51 <solrize_> url?
04:45:27 <solrize_> anyway a big list of names is unsurprising since python has been around for a long time and many people have been involved over the years
04:47:16 <yitz_> solrize_: http://svn.python.org/view/python/trunk/Misc/ACKS?rev=62000&view=auto
04:47:19 <lambdabot> Title: Repository - markup - projects: python/trunk/Misc/ACKS, http://tinyurl.com/3a8xuc
04:47:51 <yitz_> solrize_: true.
04:47:56 <solrize_> hey i'm in there :)
04:48:03 <yitz_> me too :)
04:48:38 <solrize_> anyway that's a list of everyone who's ever contributed any kind of patch (i'm not sure anything i did even ever made it in, i mostly posted whiney bug reports)
04:48:54 * EvilTerran may or may not be in the "minor contributors" for the perl CGI module (only one of the most used perl modules ever, and part of the standard library) for finding a bug
04:49:05 <solrize_> the main thing a library should have is a smallish set of committers who are very skilled and well respected
04:49:37 <EvilTerran> "hey, guys, er... you seem to be substituting part of the query string into a regex, and you're not escaping it first"
04:49:49 <EvilTerran> s/query string/URL/ or something
04:49:53 <solrize_> yow
04:50:04 <solrize_> injection attack?
04:50:16 <EvilTerran> fortunately, perl is remarkably idiot-proof, and this just caused an error
04:50:27 <yitz_> solrize_: right. for a distro, you also need that (at any given time), plus lots of people at the interface between all the libraries and the core distro team.
04:50:44 <EvilTerran> this came up when i was trying to have a URL with *s in it, and i got an error from having two next to each other
04:51:00 <solrize_> i'm not sure what you mean by the lots of people at the interface
04:51:01 <EvilTerran> or +s or something. i forget.
04:51:35 <EvilTerran> (haskell is also idiot-proof - they catch fire on contact)
04:52:03 <EvilTerran> :D
04:52:22 <yitz_> solrize_: people who understand something about both the distro (its complex graph of dependencies, and the reasoning behind them) and the specific library and its versions.
04:54:00 <solrize_> hmm for something like ghc i'd hope it wouldn't be that complex
04:54:11 <solrize_> the dep. graph i mean
04:55:25 <solrize_> it's not like a linux distro
04:55:38 <solrize_> there's the compiler and there would be a bunch of reasonably orthogonal library packages
04:55:49 <yitz_> maybe not. but people already run into a lot of trouble with it.
04:55:59 <yitz_> and it's growing fast.
04:57:00 <solrize_> version N of any package should work properly with version N-1 of all the other packages
04:57:21 <solrize_> trouble in the base lib.?  or hackage?
04:57:34 <yitz_> i guess it's not the graph that's complex. rather the algorithm to give it a globally consistent labeling of version numbers. :)
04:58:57 <solrize_> take a snapshot every so often and assign an integer to it
04:59:08 <yitz_> e.g., there are cycles in the graph. so you have to upgrade all those packages atomically. etc.
04:59:16 <yitz_> right
05:00:39 <solrize_> no cycles allowed except by special arrangement, packages A and B can have a dependency if A and B's maintainers both agree on it and the library commiter agrees it's worth the headache
05:00:41 <yitz_> think Debian stable, but not nearly as complicated. so you won't need hundreds of people and a whole bureaucracy, like they do.
05:00:47 <solrize_> right yeah
05:01:29 <solrize_> i mean, there's a snapshot of the library called version N, containing packages A,B,C,D....
05:01:32 <yitz_> solrize_: you can't enforce rules like that. each package decides its own dependencies. you are given the graph after the fact.
05:01:58 <solrize_> packages get tested against the last snapshot
05:02:44 <yitz_> ok, whatever, there are various methodologies possible. you decide. :)
05:02:45 <solrize_> what i mean is given library version N, any patch to package A cannot depend on version N+1 of package B except by special arrangement
05:03:20 <solrize_> yeah, in practice it tends to be looser than this even on big projects like gcc
05:03:43 <solrize_> python's libs are simpler than hackage
05:03:54 <yitz_> solrize_: you say that it cannot. but what if in fact it does? so, you remove that package from the distro. but let's say the package is essential.
05:03:54 <solrize_> cpan is a big mess
05:04:17 <solrize_> you don't remove it, you just keep shipping the old version
05:04:47 <yitz_> solrize_: i like the python autocratic method, it works well. but for haskell it would be a bigger job. no one wants to be bdfl.
05:05:13 <yitz_> cpan is indeed a mess. haskell is becoming like it. that's why we need distro(s).
05:05:51 <solrize_> guido mostly only dictates the language implementation, the libraries are mostly looked after by tim, raymond, martin, and a few others
05:06:29 <unenough> dons: are you cons + 1 ?
05:06:32 <yitz_> he used to rule more directly over the libs also. he still steps in now and then when needed.
05:06:56 <solrize_> so in the above scenario, you reject the patch to A because it depends on B(N+1), but you accept B(N+1) since it doesn't have such dependencies.  Now you can put the patched A in to release N+2 since B(N+1) is available
05:06:58 <yitz_> fred drake
05:07:05 <solrize_> yeah
05:07:23 <solrize_> fred mostly takes care of docs, i think
05:08:17 <yitz> i just got an xml-related ticket of mine assigned to him.
05:08:37 <solrize_> could be
05:09:31 <yitz> solrize_: but then release N+1 is not usable, because it's missing A.
05:09:44 <solrize_> it's not missing A, it still has version N
05:10:23 <yitz> it may depend on B<=N
05:10:57 <solrize_> B should not make backwards incompatible changes without arrangement
05:11:10 <yitz> well, anyway, this is a well-known problem, just need someone to be solving it all the time.
05:11:13 <solrize_> yeah
05:11:18 <yitz> B should not be, but they did.
05:11:35 <solrize_> right, this is why the library committers have to be on top of things technically and can't just be managers
05:12:49 <solrize_> really what's happening is haskell was a research language that only fairly recently escaped from the lab
05:13:17 <yitz> solrize_: so the maintainers of A and B are both technically competent, but they are pointing fingers at each other. your move.
05:13:18 <solrize_> so it's in a rapid growth and instability phase
05:13:42 <MarcWeber> @seen beschmi
05:13:43 <lambdabot> I haven't seen beschmi.
05:14:28 <solrize_> if they're both aware of what's going on, then they can agree on a pair of new versions that work together, so take both changes
05:15:25 <solrize_> i think this isn't too big a problem in glibc because it doesn't change that fast
05:15:51 <solrize_> and the python lib simply doesn't have enough stuff
05:16:01 <yitz> solrize_: sorry i keep getting disconnected.
05:16:10 * yitz looks at channel logs...
05:16:12 <solrize_> example to look to might be something like j2se/j2ee
05:16:24 <solrize_> i don't have any idea where the code for that comes from or how they manage it
05:17:18 <solrize_> for gcc you sort of have to stay on top of the trunk and make sure your patch works with that day's build, which means you need fast hardware (on my box it takes around 6 hours to build the compiler and run all the tests)
05:17:41 <yitz> gcc or ghc?
05:17:44 <solrize_> gcc
05:17:58 <yitz> 6 hrs? oh, the tests.
05:18:28 <solrize_> builds compilers for all languages twice (bootstrap self-compilation)
05:18:35 <AtheeNa> hello im a beginner to haskell... can someone help me?
05:18:40 <solrize_> welcome
05:19:51 <solrize_> anyway as you say this is an old problem, i've never been in the middle of it so maybe my ideas are not that clueful
05:19:53 <yitz> solrize_: any large system is like this. any company that develops software has people that do this also. they need tech knowledge, but at least important that they can manage the people issues.
05:20:11 <solrize_> right
05:20:18 <yitz> that's why guido was so successful.
05:21:17 <AtheeNa> how to remove a hyphen in a word - the hyphen should be at the last character of the word?
05:21:20 <yitz> hi AtheeNa. wassup?
05:21:27 <solrize_> sure, and his technical ability was a big part of the respect that he got
05:21:50 <yitz> solrize_: yeah. so the skills are not orthogonal. :)
05:22:05 <solrize_> atheena, you mean turn "word-" into "word" ?
05:22:16 <AtheeNa> hi yitz..i really dont understand the syntax in haskell..
05:22:20 <AtheeNa> yes
05:22:37 <yitz> AtheeNa: or "two-words" into ["two-", "words"] maybe?
05:22:56 <AtheeNa> it's "word-" to "word"
05:23:09 <Deewiant> > init "word-"
05:23:13 <lambdabot>  "word"
05:23:19 <solrize_> atheena the simplest approach is to reverse the word and then build the new one without the hyphen
05:23:21 <solrize_> then reverse again
05:23:22 <yitz> AtheeNa: have you given it a try yet?
05:23:31 <ksandstr> 1) determine if the last character is a hyphen, 2) if so, drop the last character
05:24:07 <solrize_> this is for a homework?  we're happy to give suggestions but probably shouldn't just write out the code :)
05:24:38 <solrize_> ksandstr's method also works, using the "length" and "take" functions
05:24:43 <AtheeNa> yes.my logic is there... but i cant put in haskell syntax... i have function called lastHyphen :: lastChHyphen :: Word -> Bool
05:24:44 <AtheeNa> lastChHyphen a = last a == '-'
05:24:45 <yitz> 1) determine if you are on the last character 2) if not, just pass it through 3) if so, pass it through only if not a hyphen
05:24:52 <ksandstr> the amusing thing is of course going from the imperative description to a nice and small function
05:25:26 <yitz> > let lastChHyphen a = last a == '-' in lastChHyphen "word-"
05:25:27 <lambdabot>  True
05:25:31 <yitz> good!
05:25:34 <AtheeNa> yes
05:25:36 <AtheeNa> but..
05:25:37 <solrize_> atheena do you know the !! operator?  how to get to the 5th char, for example?
05:25:52 <AtheeNa> no..
05:25:55 <solrize_> :t last
05:25:56 <lambdabot> forall a. [a] -> a
05:26:15 <solrize_> > "hello there" !! 7
05:26:15 <lambdabot>  'h'
05:26:26 <solrize_> > "hello there" !! 8
05:26:26 <lambdabot>  'e'
05:26:30 <AtheeNa> ooo
05:26:31 <solrize_> > "hello there" !! 3
05:26:32 <lambdabot>  'l'
05:26:43 <yitz> AtheeNa: are you given just a single word as input, no spaces?
05:26:52 <byorgey> why would AtheeNa need the !! operator for this problem?
05:26:53 <solrize_> oh there's also a built in "last" function, i didn't know that :)
05:27:12 <yitz> @index last
05:27:12 <lambdabot> Data.List, Prelude
05:27:22 <byorgey> AtheeNa: your lastChHyphen is good, now you can write  removeHyphen w = if lastChHyphen w then ? else ?
05:27:29 <byorgey> you fill in the ? =)
05:27:57 <AtheeNa> the mission is to remove right...so i have to built another function called removeHyphen?
05:28:01 <solrize_> !! was because i didn't know there was last
05:28:24 <byorgey> hehe, ok =)
05:28:29 <solrize_> @src last
05:28:29 <lambdabot> last [x]    = x
05:28:29 <lambdabot> last (_:xs) = last xs
05:28:29 <lambdabot> last []     = undefined
05:28:53 <yitz> > last []
05:28:54 <lambdabot>  Exception: Prelude.last: empty list
05:29:09 <EvilTerran> ?src foldr1
05:29:09 <lambdabot> foldr1 _ [x]    = x
05:29:09 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
05:29:09 <lambdabot> foldr1 _ []     = undefined
05:29:10 <AtheeNa> removeHyphen = Word -> Word removeHyphen w = if lastChHyphen w then drop ?? w
05:29:19 <AtheeNa> ?? <-- i must use int
05:29:19 <lambdabot>  <-- i must use int
05:29:27 <EvilTerran> heh
05:29:30 <EvilTerran> ?bot
05:29:30 <lambdabot> :)
05:29:34 <AtheeNa> hehe
05:29:35 <ksandstr> not like a bit has a lot of wis anyhow.
05:29:40 <ksandstr> *bot
05:29:43 <yitz> It's not fair that lambdabot insults me when I type the @src command wrong, but I can't insult it when it has a mistake in the source.
05:30:23 <EvilTerran> @vixen you're a blithering idiot
05:30:23 <lambdabot> you sound like an awesome guy... are you single?
05:30:26 <EvilTerran> :D
05:30:44 <EvilTerran> @vixen sorry, you're not my type
05:30:44 <lambdabot> it's okay, i forgive you
05:31:11 <EvilTerran> @vixen i don't date idiots, blithering or otherwise
05:31:11 <lambdabot> you seem smart to me
05:31:44 <byorgey> AtheeNa: do you know about the init function?
05:31:49 <byorgey> > init "abcde"
05:31:50 <lambdabot>  "abcd"
05:31:52 <EvilTerran> ?src init
05:31:52 <lambdabot> init [x]    = []
05:31:52 <lambdabot> init (x:xs) = x : init xs
05:31:52 <lambdabot> init []     = undefined
05:32:02 <yitz> it's the dual of "last"
05:32:02 <AtheeNa> init?
05:32:24 <AtheeNa> but it has to meet the lastHyphen condition before i can use init ?
05:32:34 <AtheeNa> so..
05:32:40 <AtheeNa> no need to use drop?
05:32:45 <yitz> > let x = "abcdefg" in (init x, last x)
05:32:45 <lambdabot>  ("abcdef",'g')
05:32:50 <EvilTerran> indeed not
05:32:59 <EvilTerran> id there a (init &&& last) function?
05:33:03 <EvilTerran> *is
05:33:11 <solrize_> init pushes all but the last char on the stack?  Hmm
05:33:25 <solrize_> > (init &&& last) "abcdefg"
05:33:25 <lambdabot>  ("abcdef",'g')
05:33:26 <yitz> stack?
05:33:32 <solrize_> well
05:33:41 <solrize_> not tail recursive
05:34:10 <AtheeNa> ooo..
05:34:21 <AtheeNa> ok..i got what u all mean..
05:34:21 <solrize_> anyway don't worry about that, just do the most straightforward thing
05:34:22 <EvilTerran> > let initLast [x] = ([],x); initLast (x:xs) = (x:in,la) where (in, la) = initLast xs in initLast "abracadabra"
05:34:22 <lambdabot>  Parse error at "in,la..." (column 49)
05:34:28 <solrize_> don't use &&& it's advanced :)
05:34:51 <EvilTerran> whaaa?
05:35:05 <AtheeNa> haha..i cant be too advanced..later i have to explain to my lecturer
05:35:19 <yitz> umm AtheeNa, please excuse us, we're getting off track a little...
05:35:25 <solrize_> yeah sorry :)
05:35:32 <Deewiant> EvilTerran: 'in' is a keyword :-)
05:35:38 <EvilTerran> oopsie
05:35:39 <Deewiant> > let initLast [x] = ([],x); initLast (x:xs) = (x:ini,la) where (ini, la) = initLast xs in initLast "abracadabra"
05:35:39 <lambdabot>  ("abracadabr",'a')
05:35:55 <EvilTerran> > let initLast [x] = ([],x); initLast (x:xs) = (x:i,l) where (i,l) = initLast xs in initLast "abracadabra"
05:35:56 <lambdabot>  ("abracadabr",'a')
05:36:02 <EvilTerran> ah, beaten to the punch
05:36:10 <idnar> heh
05:36:36 <solrize_> anyway what evilterran is doing is kind of complicated, i'd write something simpler
05:36:37 <AtheeNa> dropHyphen a =  if lastChHyphen then init a else return a is this right or wrong?
05:36:48 <ksandstr> nearly right
05:36:51 <yitz> try it! (use > at the beginning)
05:37:22 <AtheeNa> try it where? here?
05:37:32 <solrize_> > 3 + 5
05:37:33 <lambdabot>  8
05:37:42 <solrize_> you can type stuff starting with ">" and lambdabot will run it
05:37:52 <AtheeNa> > dropHyphen a =  if lastChHyphen then init a else return a
05:37:52 <lambdabot>  Parse error at "=" (column 14)
05:38:00 <yitz> > init "AtheeNa, you can also talk to lambdabot"
05:38:01 <AtheeNa> ??
05:38:02 <lambdabot>  "AtheeNa, you can also talk to lambdabo"
05:38:07 <EvilTerran> ">" only does expressions
05:38:31 <solrize_> > let  dropHyphen a =  if lastChHyphen then init a else return a
05:38:31 <lambdabot>  Parse error at end of input
05:38:33 <EvilTerran> not bindings, but you can get the same effect with "let <binding> in <expression using binding>"
05:38:35 <AtheeNa> wow.. i should have known about this channel earlier...
05:38:38 <solrize_> > let  dropHyphen a =  if lastChHyphen then init a else return a in dropHyphen "word-"
05:38:38 <lambdabot>   Not in scope: `lastChHyphen'
05:38:43 <solrize_> hmm
05:38:44 <yitz> > let dropHyphen a =  if lastChHyphen then init a else return a in dropHyphen "word-"
05:38:44 <lambdabot>   Not in scope: `lastChHyphen'
05:38:58 <EvilTerran> AtheeNa, you can also talk to the bot via pm, if you're identified to services
05:39:08 <paczesiowa> why use return?
05:39:29 <yitz> @let lastChHyphen a = last a == '-'
05:39:29 <lambdabot> Defined.
05:39:33 <yitz> > let dropHyphen a =  if lastChHyphen then init a else return a in dropHyphen "word-"
05:39:34 <lambdabot>  Couldn't match expected type `Bool'
05:39:44 <EvilTerran> > let dropHyphen a =  if lastChHyphen then init a else a in dropHyphen "word-"
05:39:44 <lambdabot>  Couldn't match expected type `Bool'
05:39:47 <yitz> there we go. that's a real error message.
05:39:53 <EvilTerran> ah
05:40:05 <solrize_> see this is getting messy and complicated because of the requirement to put all the stuff into one expression
05:40:12 <solrize_> it's easiest to break it into several expressions
05:40:19 <yitz> use @let
05:40:26 <ksandstr> i'd use a pattern guard to do the iffing, because if-then-else tends to get long
05:40:42 <yitz> a guard, not a pattern guard.
05:40:48 <ksandstr> sorry. yes.
05:40:48 <solrize_> @let lastChHyphen w = (last w == '-')
05:40:49 <lambdabot> <local>:4:0:     Warning: Pattern match(es) are overlapped              In th...
05:41:14 <solrize_> :t lastChHyphen
05:41:15 <lambdabot> [Char] -> Bool
05:41:32 <yitz> the problem with @let is that if you make a mistake, @undef erases everything and you have to start from scratch.
05:42:22 <yitz> AtheeNa: just to clarify: "@let" and ">" are for the bot, they are not Haskell syntax.
05:43:39 <AtheeNa> i've learn about pattern guard.. but how to use it in replace for if-then-else
05:44:50 <Jaak> > let if' b t f = case b of { True -> t; False -> f} in (if' True 1 2, if' False 1 2)
05:44:51 <lambdabot>  (1,2)
05:45:07 <solrize_> jaak :(
05:45:13 <Jaak> ?
05:45:29 <Jaak> oh, guard
05:45:34 <yitz> > let yummy x | x == "pizza" = True | otherwise = False in yummy "anchovies"
05:45:35 <lambdabot>  False
05:45:38 <solrize_> i think just extract the init and last into two different variables, then use an if expression
05:45:59 <solrize_> oh ok, pattern guard is ok too
05:46:19 <Jaak> meh, it's all just syntactic sugar for case anyways
05:46:44 <yitz> Jaak: guards can make code look really readable.
05:46:59 <Jaak> sometimes
05:47:05 <Deewiant> I prefer if-then-else to guards in almost all cases
05:47:07 <yitz> hence - maintainable
05:47:20 <yitz> Deewiant: I avoid them like the plague.
05:47:20 <Jaak> if-then-else is quite ugly in haskell, imo
05:47:33 <matthew_-> yeah, the only advantage is that it works in do notation
05:47:43 <matthew_-> though there a case with guards is still preferable
05:47:56 <Jaak> i have never used nested ifte in haskell
05:47:59 <yitz> matthew_: in do notation there is when, unless, guard.
05:48:12 <Deewiant> nested if-then usually looks nicer as guards, of course
05:48:46 <Deewiant> but when the guard is something like foo x | p x = ... | otherwise = ... I definitely find if-then-else nicer
05:48:51 <ksandstr> if-then-else wouldn't be so bad, if lines using it didn't turn into uneditable 180-character monsters
05:48:53 <Jaak> yeah
05:49:21 <EvilTerran> > fromMaybe <*> ((>>) <$> guard.((&&)<$>not.null<*>(=='-').last) <*> return.init) $ "abracadabra-"
05:49:21 <lambdabot>  "abracadabra"
05:49:32 <desegnis_> The only not-so-nice thing I find about Deewiant's last example is that "otherwise" is a long word to type
05:49:37 <EvilTerran> > fromMaybe <*> ((>>) <$> guard.((&&)<$>not.null<*>(=='-').last) <*> return.init) $ "bleem fleem"
05:49:37 <lambdabot>  "bleem fleem"
05:49:43 <desegnis_> Otherwise, I mostly prefer guards
05:49:45 <EvilTerran> > fromMaybe <*> ((>>) <$> guard.((&&)<$>not.null<*>(=='-').last) <*> return.init) $ ""
05:49:46 <lambdabot>  ""
05:49:49 <Jaak> @src otherwise
05:49:49 <lambdabot> otherwise = True
05:49:53 * EvilTerran wanders off, humming to himself
05:49:59 <Jaak> you can just use True instead :P
05:50:01 <matthew_-> desegnis_: that's why emacs has M-/
05:50:06 <desegnis_> Jaak, true, but writing True looks stupid
05:50:13 <Jaak> indeed :P
05:50:16 <solrize_> oh this is probably a good time to tell atheena about pastebin :)
05:50:34 <ksandstr> hey true, the definition that forces something that uses "last" isn't compatible with ""
05:50:38 <yitz> > fromMaybe <*> ((>>) <$> guard.((&&)<$>not.null<*>(=='-').last) <*> return.init) $ "Quit it, EvilTerran"
05:50:39 <lambdabot>  "Quit it, EvilTerran"
05:50:46 <EvilTerran> i'm just playing!
05:50:48 <desegnis_> matthew_-, is that for inserting a template?
05:50:53 <EvilTerran> let me have my fun! :(
05:51:01 <yitz> :)
05:51:04 <matthew_-> it's what Eclipse calls Hippy Complete
05:51:05 <ksandstr> the solution that uses two reverses is looking nicer all the time
05:51:17 <matthew_-> complete the current word finding the nearest completion from all open buffers
05:51:43 <solrize_> emacs does that
05:51:56 <desegnis_> Ah, like C-x C-i in Vim (one of those vim commands that looks like you're using the wrong editor :)
05:52:05 <solrize_> lol
05:52:11 * EvilTerran quite likes the (fromMaybe <*>) idiom, though
05:52:33 <Deewiant> @ty (fromMaybe <*>)
05:52:34 <lambdabot> forall a. (a -> Maybe a) -> a -> a
05:52:38 <yitz> :t (<*>)
05:52:39 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
05:52:54 <yitz> :t fromMaybe
05:52:55 <lambdabot> forall a. a -> Maybe a -> a
05:53:00 <solrize_> ugh
05:53:03 <EvilTerran> (fromMaybe <*> f) x -- if (f x) is (Just y), evaluates to y. otherwise evaluates to x.
05:53:44 <EvilTerran> I'm using (<*>) as the S combinator - "before-and-after"
05:53:57 <EvilTerran> (f <*> g) x = f x (g x)
05:53:58 <ksandstr> sounds like one of those things that should really have a proper name
05:54:04 <yitz> fromMaybe <*> f = flip fromMaybe . f
05:54:12 <yitz> ?
05:54:25 <EvilTerran> yitz, no, join (flip fromMaybe . f)
05:54:41 <EvilTerran> (fromMaybe <*> f) x = fromMaybe x (f x)
05:55:06 <yitz> ah, x appears twice.
05:55:21 <EvilTerran> indeed - see how i defined <*> above
05:55:42 <desegnis_> > ap fromMaybe return 5
05:55:43 <lambdabot>  5
05:55:45 <EvilTerran> note this is just one of the definitions of <*> - specifically, the one for "instance Applicative (e ->)"
05:56:30 <EvilTerran> and, on that hairy line above, i was using <*> in the (e ->) instance *and* in the Maybe instance
05:56:37 <EvilTerran> :D
05:57:07 <desegnis_> > ap fromMaybe (const Nothing) 5
05:57:07 <lambdabot>  5
05:57:35 <EvilTerran> as desegnis_ is demonstrating, <*> is also called `ap` - for Applicatives that are also Monads, anyway.
05:57:49 <EvilTerran> ?src ap
05:57:49 <lambdabot> ap = liftM2 id
05:57:51 <yitz> > (unwords  . map (fromMaybe <*> lookup $ [("red", "rouge")]) . words) "The is a red apple."
05:57:52 <lambdabot>  Couldn't match expected type `Maybe a'
05:58:28 <desegnis_> Funny the name "ap" should look so applicative :)
05:58:34 <yitz> > (unwords  . map (fromMaybe <*> flip lookup  [("red", "rouge")]) . words) "This is a red apple."
05:58:34 <lambdabot>  "This is a rouge apple."
05:59:13 <Deewiant> > (unwords  . map (fromMaybe <*> flip lookup  [("apple", "banana")]) . words) "This is a red apple."
05:59:14 <lambdabot>  "This is a red apple."
05:59:23 <EvilTerran> > (unwords  . map (fromMaybe <*> lookup $ [("red", "rouge")]) . words) "The is a red apple."
05:59:23 <lambdabot>  Couldn't match expected type `Maybe a'
05:59:31 <EvilTerran> ups, copy-paste error
05:59:33 <EvilTerran> > (unwords  . map (fromMaybe <*> (`lookup` [("red", "rouge"), ("green","vert")])) . words) "The is a red apple. The other one is green."
05:59:33 <lambdabot>  "The is a rouge apple. The other one is green."
05:59:38 <EvilTerran> bah. full-stops.
05:59:41 * EvilTerran goes to have lunch
06:00:07 <basti_> hi people. what is the situation of haskell as an interactive-website language?
06:00:15 <desegnis_> EvilTerran, enjoy your meal
06:00:32 <desegnis_> basti_: You mean, for ajay things?
06:00:39 <desegnis_> ajax
06:00:44 <basti_> no i mean for PHP-like things
06:00:51 <basti_> server side scripting
06:01:02 <basti_> i saw HSP, but it appears a little out of maintenance
06:01:06 <desegnis_> Oh, you can use Haskell as CGI or FastCGI language without severe problems
06:01:14 <yitz> basti_: lately we got a port of StringTemplate
06:01:35 <yitz> it's really cool
06:01:35 * basti_ looks up StringTemplate
06:01:39 <desegnis_> ah, HSP was interesting wrt mixing HTML with Haskell code
06:02:07 <yitz> StringTemplate keeps things neater though
06:02:13 <basti_> i don't need strict templating like in PHP - i think it's evil
06:02:25 <yitz> strict?
06:02:26 <basti_> the good thing in php is the short testing cycle
06:02:45 <solrize_> basti, happs,org if you want something super powerful but complex
06:02:49 <basti_> templating as in <% here comes the code %>  - as opposed to getTemplate('name'); applyTemplate
06:03:46 <solrize_> happs just uses xsl, tosses the template problem to someone else :)
06:04:15 <basti_> th most important thing to me would be to test code without a manual compile
06:04:27 <yitz> right. so HSP is inspired by JSP/ASP which also inspired PHP. StringTemplate is intentionally much more restricted, so you don't get arbitrary code interspersed with your HTML
06:05:01 <basti_> StringTemplate seems very useful.
06:07:41 <desegnis_> Is StringTemplate kind of an enhanced printf?
06:10:34 <AtheeNa> guys --> what is the error here --> dropHyphen a = [a | a == lastChHyphen = init a, | otherwise = a]
06:10:52 <yitz_> > dropHyphen a = [a | a == lastChHyphen = init a, | otherwise = a]
06:10:53 <lambdabot>  Parse error at "=" (column 14)
06:10:59 <AtheeNa> it says errors Syntax error in expression (unexpected `=')
06:11:11 <yitz_> > let dropHyphen a = [a | a == lastChHyphen = init a, | otherwise = a] in dropHyphen "word-"
06:11:11 <lambdabot>  Parse error at "=" (column 43)
06:11:32 <AtheeNa> hmm??
06:11:54 <yitz_> ah. you use guards when defining functions, not in a list comprehension.
06:12:25 <desegnis_> AtheeNa: You're constructing a list? [...] is for lists only.
06:12:49 <yitz_> ie a list of words. you have just a single word. so, just a function
06:13:11 <yitz_> ie take out the [ and ]
06:13:40 <yitz_> look at this example i gave you before:
06:13:59 <desegnis_> take out the = [a, rather
06:14:15 <yitz_> > let yummy x | x == "pizza" = True | otherwise = False in yummy "anchovies"
06:14:16 <lambdabot>  False
06:14:33 <AtheeNa> remove [ ]
06:14:37 <AtheeNa> ok ok..
06:14:40 <yitz_> > let yummy x | x == "pizza" = True | otherwise = False in yummy "pizza"
06:14:41 <lambdabot>  True
06:14:43 <xerox> btw yummy = (== "pizza")
06:15:21 <yitz_> xerox: after AtheNa gets the required function, we'll apply @pl to it. :)
06:15:33 <yitz_> xerox: after AtheeNa gets the required function, we'll apply @pl to it. :)
06:16:15 <yitz_> @pl \x -> let yummy x | x == "pizza" = True | otherwise = False in x
06:16:15 <lambdabot> (line 1, column 19):
06:16:15 <lambdabot> unexpected "|"
06:16:15 <lambdabot> expecting pattern or "="
06:16:56 <yitz_> then again, maybe we won't
06:21:35 <basti_> hstringtemplate complains about Data.Time being hidden, which it isnt: ghc-pkg list => "ll-2.1, time-1.1.1, unix-2"
06:21:55 <basti_> does that have to do with changes from ghc 6.6 to ghc 6.8?
06:22:08 <paczesiowa> basti, yes. you have to modify cabal file
06:22:21 <paczesiowa> basti add Data.Time to deps
06:22:34 <paczesiowa> ot time
06:22:36 <paczesiowa> *or
06:23:09 <basti_> frankly speaking, it sucks to demand the newest version of everything for any package.
06:23:28 <basti_> this is a surefire way to scare off everybody.
06:23:41 <yitz> basti_: this gets back to our discussion about the need for a ghc distribution
06:24:57 <paczesiowa> is it possible to retrieve action bound to signal (e.g. to button onClicked) directly from that button, without storing ConnectId objects?
06:25:08 <basti_> I think I'll compile ghc 6.8 plus all of the hackage repository, because i'm not keen on manually retrieving 20 packages and manipulating them
06:25:37 <paczesiowa> basti_: wait, you have 6.6?
06:25:42 <basti_> yep
06:25:45 <yitz> basti_: what
06:25:55 <yitz> what's your platform?
06:26:03 <basti_> debian linux
06:26:30 <paczesiowa> basti_: that problem usually surfaces when you use 6.8 and package hasn't been updated to use new cabal
06:26:40 <yitz> basti_: i pin all ghc-stuff to unstable in my /etc/apt/preferences.
06:26:46 <paczesiowa> basti_: it should be fine with 6.6
06:26:56 <basti_> "should" is the problem here, i guess.
06:26:58 <yitz> then i get 6.8.2 automatically
06:27:23 <basti_> yitz: how do i mark up "all ghc-stuff" as "load from unstable"
06:27:30 <yitz> one sec...
06:28:46 <hpaste>  yitz pasted "get 6.8.2 on Debian testing" at http://hpaste.org/6731
06:29:35 <yitz> you may need other packages, but you get the idea
06:30:48 <basti_> it's what i thought, i need to mark up every single package. but thanks anyway
06:31:18 <basti_> i take any bet that this will result in something being marked as "broken" and apt not being able to handle the upgrade.
06:31:20 <yitz> basti_: i tried using libghc* but it didn't work.
06:31:39 <matthew_-> how can I write a Show instance that reflects a type?
06:32:14 <yitz> basti_: works for me. the only things that come up broken are other things with libghc6 in the name. I just add them.
06:32:21 <matthew_-> eg data Foo x = FC x and then Show (Foo x) such that if x :: Int then it prints out "Foo Int", or in general, if x :: t it prints out "Foo t"
06:32:23 <yitz> wish there were a neater way though.
06:32:24 <basti_> we'll see.
06:34:33 <basti_> package management has gone to a point where it's more economical to build everything yourself.
06:34:51 <basti_> mathrick: i do not think this is possible.
06:35:04 <paczesiowa> matthew_-: have you seen this http://okmij.org/ftp/Haskell/types.html#class-based-dispatch ?
06:35:07 <lambdabot> Title: Haskell Programming: Types
06:39:48 <ttt--> @src instanceof
06:39:49 <lambdabot> Source not found.
06:43:41 <yitz> > tyConString $ typeRepTyCon $ typeOf (undefined :: Int)
06:43:42 <lambdabot>  "Int"
06:44:02 <yitz> matthew_-: ^
06:45:50 <ttt--> how come there is no way to write Int in stead of typeOf (undefined :: Int)
06:47:31 <yitz> I think the mechanism was really designed for casting, not so much for naming types.
06:47:50 <yitz> @index tyConString
06:47:50 <lambdabot> Data.Typeable, Data.Dynamic, Data.Generics.Basics, Data.Generics
06:48:03 <Lemmih> ttt--: There's no data constructor named 'Int' and, if there were, it certainly wouldn't be of type TypeRep.
06:49:24 <ttt--> what type would it?
06:49:28 <ttt--> be*
06:49:41 <basti_> hvac is missing a dependency/check on whether the file fcgiapp.h and the corresponding library is installed
06:51:08 <yitz> basti_: while installing hstringtemplate, or unrelated?
06:53:02 <basti_> yitz: unrelated to hstringtemplate itself - it's in hvac. i don't know if you can even mark up this dependency.
06:56:09 <Lemmih> ttt--: It doesn't exist so we don't know.
06:56:46 <Lemmih> ttt--: Define 'data MyInt = Int' and it'll have the type 'MyInt'.
06:57:10 <EvilTerran> Lemmih, you need a constructor there
06:57:36 <Lemmih> EvilTerran: Int is the constructor.
06:58:06 <EvilTerran> ... oh, ok. weird. whatever floats your boat, i guess.
06:58:45 <Lemmih> EvilTerran: I'm using it to show the different namespaces of data constructors and type constructors.
06:58:56 <EvilTerran> ahh
07:00:08 <EvilTerran> note to self: read scroll-back before you jump in
07:04:32 <yitz> basti_: I see hvac is not in hackage yet.
07:05:06 <yitz> basti_: yeah, binary deps are still a bit weak in cabal. there are trac tickets for it.
07:05:25 * basti_ nods
07:15:59 <basti_> $ ghc6 --make -threaded examples/hvac-board.hs -package hvac-0.1
07:16:03 <basti_>     Could not find module `Network.Frameworks.HVAC.FastCGI':
07:16:06 <basti_>       it is hidden (in package hvac-0.1)
07:17:23 <basti_> besides, HVAC is not hidden by default.
07:18:11 <yitz> maybe ghc-pkg expose
07:18:59 <desegnis_> basti_: Do you have multiple versions of that package installed? --make might be confused by that
07:21:14 <hpaste>  basti_ pasted "ghc-pkg output" at http://hpaste.org/6732
07:22:27 <yitz> basti_: do you have more than one ghc on your system?
07:22:47 <Igloo> And is the module listed as an exposed-module in the Cabal file?
07:23:15 <basti_> i do, but i just looked and found that the ghc i use for compiling touches the very same package.conf that ghc-pkg accesses
07:24:16 <basti_> Igloo: it is not.
07:26:09 <Igloo> That's your problem, then
07:26:49 <basti_> hm
07:28:50 <basti_> indeed. after putting the module into "exposed", the error disappears
07:29:09 <ceibe> hi!, can someone help me with parsec?
07:29:09 <lambdabot> ceibe: You have 1 new message. '/msg lambdabot @messages' to read it.
07:40:16 <TomMD> OK, who uploaded a package so popular to cause hackage to be unreachable?
07:40:50 <Jaak> xmonad?
07:41:06 <EvilTerran> @quote meta-ask
07:41:06 <lambdabot> No quotes match.
07:41:09 <EvilTerran> hm
07:41:28 <TomMD> @quote C++
07:41:29 <lambdabot> lambdabot says: i 4M THe cooLES+ bo+ e\/eR
07:41:44 <EvilTerran> @remember meta-ask Don't ask to ask, ask!
07:41:44 <lambdabot> It is forever etched in my memory.
07:42:10 <olsner> @quote c\+\+
07:42:11 <lambdabot> vincenz says: [on C++]  it's easy to pick up like being a mortician is easy to pick up. technically there's no challenge but you have to look at corpses every day
07:42:21 * EvilTerran directs ceibe to that advice - what seems to be the problem?
07:42:43 <opqdonut> @quote [ ][Cc][ ]
07:42:43 <lambdabot> No quotes for this person. I feel much better now.
07:42:57 <olsner> @quote <c>
07:42:57 <lambdabot> No quotes match. I've seen penguins that can type better than that.
07:43:01 <EvilTerran> @quote \<C\>
07:43:01 <olsner> @quote \<c\>
07:43:01 <lambdabot> qwe1234 says: you cannot write a lisp compiler that is as good as a C compiler
07:43:01 <lambdabot> qwe1234 says: For the majority of tasks, C++ templates produce code that is clearer and better type-checked [than Haskell].
07:43:05 <opqdonut> ah
07:43:07 <opqdonut> pcre?
07:43:07 <ceibe> well, the problem is to parse languages where you can't ignore newlines
07:43:34 <EvilTerran> opqdonut, no, in PCRE, \ followed by punctuation is never magic. that's POSIX.
07:43:35 <Jaak> better type checked? sounds like load of bullshit
07:43:51 <opqdonut> EvilTerran: oh, okay
07:44:00 * EvilTerran far prefers the pcre version
07:44:01 <ceibe> the parsec lexeme's parsers ignore newlines, so it isn't valid for some languages
07:44:28 <olsner> Jaak: qwe1234 is one of the old #haskell trolls, so that's probably why it's quoted :P
07:44:29 <ceibe> I look for it in google and I only found a discussion where someone suggests to pre-process the input to change \n to another character
07:44:41 <ceibe> I don't know if could be a better solution
07:44:53 <EvilTerran> alphanumeric or non-alphanumeric and escaped? not magic. otherwise, maybe magic.
07:44:56 <ceibe> someone had the same problem?
07:45:20 <EvilTerran> ceibe, you can write a lexer yourself that takes newlines into account
07:46:04 <EvilTerran> data Token = ... | NEWLINE | ...; and then include those in the lexer output
07:48:01 <ceibe> uhm yes, perhaps will be a good solution
07:49:01 <ceibe> altought Token parsec module could be more flexible :P
07:52:14 <EvilTerran> i don't really grok that module myself, as i've never sat down and tried to use it
07:52:39 <EvilTerran> all the lexers i've written are simple enough that i can write them straight in parsec without using it
07:52:44 <EvilTerran> ah well
07:52:45 <EvilTerran> away!
07:54:42 <ceibe> well, always is good to dont' have to write you the lexer if you can avoid it
08:18:21 <AtheeNa> helo..can anyone tell me what is this error ERROR file:.\t.hs:38 - Missing binding for variable "makeIndex" in type signature
08:18:56 <skorpan> AtheeNa: paste your code at http://hpaste.org
08:19:52 <u_quark> how do we call here in haskell the () unit ? (not the type the value) ?
08:20:13 <shachaf> u_quark: You can call it that. :-)
08:20:58 <shachaf> u_quark: (At least some other people do also.)
08:21:01 <u_quark> :) yes but whats the trend in haskell ?
08:21:20 <resiak> "coin"?
08:21:38 <resiak> [i think unit is the most common pronounciation]
08:21:51 * shachaf reads it as "()", which is probably pronounced as a sort of grunt.
08:22:05 <skorpan> i pronounce it as "unit"
08:22:39 <skorpan> that's actually the only pronounciation of it that i have heard
08:22:48 <u_quark> ok tnx
08:22:55 <unenough> how about "blaaarggh"?
08:26:33 <Otoom> Hey all im new
08:26:36 <Otoom> Here and to haskell
08:26:59 <Otoom> i hope to learn something about it though, just one thing. i cant seem to compile my first pro
08:27:05 <Otoom> says something about not being in scope
08:27:10 <Otoom> ghc no in scope
08:27:15 <Otoom> o not in scope
08:27:20 <Otoom> hello not in scope
08:27:25 <Otoom> hello.hs not in scope
08:27:26 <cjb> Otoom: please paste your code here:  http://hpaste.org
08:27:26 <lambdabot> cjb: You have 1 new message. '/msg lambdabot @messages' to read it.
08:27:27 <Otoom> or something
08:27:40 <Otoom> the code is fine
08:27:49 <Otoom> my code is
08:27:52 <cjb> solrize_: Yes, was me.
08:28:07 <Otoom> main = putStrLn "hello"
08:28:23 <mauke> what commands are you executing?
08:28:27 <mauke> what's the exact error message?
08:28:32 <Otoom> hold on
08:28:34 <Otoom> ill do it again mate
08:28:55 <cjb> Otoom: ghc -o hello hello.hs
08:29:05 <Otoom> yes that is what i am doing
08:29:12 <cjb> works here.
08:29:39 <Otoom> C:\Documents and Settings\Ant>ghci
08:29:39 <Otoom> GHCi, version 6.8.2: http://www.haskell.org/ghc/  :? for help
08:29:39 <Otoom> Loading package base ... linking ... done.
08:29:39 <Otoom> Prelude> ghc -o hello hello.hs
08:29:39 <Otoom> <interactive>:1:0: Not in scope: `ghc'
08:29:40 <Otoom> <interactive>:1:5: Not in scope: `o'
08:29:40 <lambdabot> Title: The Glasgow Haskell Compiler
08:29:42 <Otoom> <interactive>:1:7: Not in scope: `hello'
08:29:44 <Otoom> <interactive>:1:13: Not in scope: `hello'
08:29:46 <Otoom> <interactive>:1:19: Not in scope: `hs'
08:29:48 <Otoom> my error
08:29:53 <cjb> You type it from the shell prompt, not the ghci prompt.
08:29:58 <mauke> Otoom: no one said to run 'ghci'
08:30:00 <mib_5nmel4yx> pl problem1 = sum (multiples3or5 [1..1000])
08:30:07 <Otoom> oh
08:30:13 <cjb> And please don't paste in here -- paste at http://hpaste.org
08:30:39 <oToom> cjb are you mod or admin or something?
08:31:15 <cjb> no.
08:32:41 <mib_5nmel4yx> @pl
08:32:41 <lambdabot> (line 1, column 1):
08:32:41 <lambdabot> unexpected end of input
08:32:41 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
08:33:00 <mib_5nmel4yx> @pl problem1 = sum (multiples3or5 [1..1000])
08:33:00 <lambdabot> problem1 = sum (multiples3or5 [1..1000])
08:33:15 <mib_5nmel4yx> @pl div3or5 x = div5 x || div3 x
08:33:15 <lambdabot> div3or5 = liftM2 (||) div5 div3
08:33:27 <oToom> can i ask what sort of stuff can be done in haskell
08:33:38 <oToom> can it interact with the internet in some way? like sockets?
08:33:41 <mauke> sure
08:33:45 <oToom> really?
08:33:53 <oToom> can it make things like irc bots?
08:33:57 <oToom> cuz i love making them
08:33:58 <Deewiant> @faq can Haskell make irc bots?
08:33:58 <lambdabot> The answer is: Yes! Haskell can do that.
08:34:05 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/network/Network-Socket.html
08:34:07 <cjb> oToom: lambdabot is a haskell irc bot
08:34:08 <lambdabot> http://tinyurl.com/fkdb4
08:34:20 <shachaf> @go roll your own irc bot
08:34:21 <lambdabot> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
08:34:22 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
08:34:40 <oToom> cjb nice thanks
08:34:47 <mib_5nmel4yx> @pl divn n x = x `mod` n == 0
08:34:47 <lambdabot> divn = flip flip 0 . ((==) .) . flip mod
08:35:39 <oToom> i have compiled my first app
08:35:41 <Deewiant> @pl divn n x = (x `mod` n) == 0
08:35:41 <lambdabot> divn = flip flip 0 . ((==) .) . flip mod
08:35:41 <oToom> but no .exe ;P
08:36:51 <hpaste>  atheena pasted "toLower" at http://hpaste.org/6733
08:36:56 <sfultong> fmap inc (1,2)
08:36:59 <sfultong> > fmap inc (1,2)
08:37:00 <lambdabot>   Not in scope: `inc'
08:37:04 <sfultong> > fmap succ (1,2)
08:37:05 <lambdabot>  (1,3)
08:37:07 <cjb> oToom: I don't know how Windows works, sorry.
08:37:17 <oToom> u run Linux?
08:37:21 <cjb> yeah
08:37:33 <oToom> ah damn
08:37:41 <oToom> looks like haskell is oput the window
08:37:43 <oToom> cya guys
08:37:53 <mauke> oToom: what did you get instead?
08:38:01 <Deewiant> so much for patience :-P
08:38:08 <cjb> he sent a privmsg saying he got a .o and a .hi
08:38:09 <u_quark> ...
08:38:19 <sfultong> how come fmap succ (1,2) doesn't work in ghci (6.8.2)?
08:38:19 <Deewiant> which is odd
08:38:27 <Deewiant> cjb: because that generates a .exe here, on windows
08:38:32 <cjb> huh.
08:38:47 <Deewiant> maybe he misspelled the -o or something
08:38:52 <Deewiant> and there's always ghc --make, of course.
08:39:05 <atp> i guess we'll never know, he only stuck around for 10 seconds
08:39:06 <ari> sfultong: instance Functor ((,) t) is in Control.Monad.Instances
08:39:36 <ari> Well, in 6.8.1 anyway
08:39:43 <TomMD> It still is, ari, I just tested it.
08:39:46 <sfultong> ari: ah, thanks... I also wonder why the implementation only applies the function to the first value in the tuple
08:40:28 <sfultong> I mean, if you do fmap f (1,2), wouldn't you expect it to do (f 1, f 2)?
08:40:31 <Jedai> sfultong: Because the second value isn't always of the right type...
08:40:38 <sfultong> oh... right... hehe
08:40:41 <sfultong> silly me
08:40:44 <Heffalump> he didn't use -c or something, did he?
08:40:46 <TomMD> sfultong: It applies to the second.  I guess thats just how the mtl guys thought it would be most useful / sensable.
08:40:48 <Heffalump> ghc works fine on Windows for me
08:40:58 <Jedai> Heffalump: He probably used -c...
08:41:41 <Deewiant> probably
08:41:49 <Jedai> ?instances MonadState
08:41:49 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
08:42:18 <sfultong> well, a type for a monotypal tuple would be nice... instead of having to use arrows to fool around with function pairing and such
08:43:06 <sfultong> I guess using lists is probably just as easy
08:43:15 <Jedai> sfultong: You can write it, of course it won't have tuple syntax
08:43:37 <Jedai> data Pair a = a :!: a
08:44:16 <sfultong> has anyone ever declared functions pattern-matched in lists?  I think it's kinda neat...
08:44:22 <Jedai> instance Functor (Pair a) where fmap f (Pair a b) = Pair (f a) (f b)
08:44:29 <AtheeNa> how to detect a suffix in a word...
08:44:40 <AtheeNa> cats change to cat
08:44:56 <sfultong> > let [add1, add2] = map (+) [1,2]
08:44:56 <lambdabot>  Parse error at end of input
08:45:14 <sfultong> hehe, too much for lambdabot to handle
08:45:24 <Deewiant> > let [add1, add2] = map (+) [1,2] in (add1, add2)
08:45:24 <lambdabot>  (<Integer -> Integer>,<Integer -> Integer>)
08:45:32 <Deewiant> sfultong: you need 'in'
08:45:39 <sfultong> oh, err... silly me
08:45:48 <sfultong> :let [add1, add2] = map (+) [1,2]
08:45:52 <Jedai> @hoogle suffix
08:45:52 <lambdabot> Data.List.isSuffixOf :: Eq a => [a] -> [a] -> Bool
08:45:52 <lambdabot> Data.ByteString.isSuffixOf :: ByteString -> ByteString -> Bool
08:45:52 <lambdabot> Data.ByteString.Char8.isSuffixOf :: ByteString -> ByteString -> Bool
08:46:16 <Deewiant> Otoom: ghc -o should work fine and create a .exe
08:46:19 <Jedai> AtheeNa: isSuffixOf ?
08:46:43 <AtheeNa> Jedai : ok i try
08:46:49 <AtheeNa> any examples
08:47:09 <Deewiant> > "foo" `isSuffixOf` "barfoo"
08:47:10 <lambdabot>  True
08:48:39 <AtheeNa> ok..then if i have something like suffixes for plural 'sses', 'zzes','oes"...i use case?
08:49:01 <jaj> I just downloaded HDBC-1.1.4 and it errors out with "Setup.lhs: HDBC.cabal:18: 'Executable' stanza starting with field 'cabal-version'" when I try to build it
08:49:17 <Jedai> AtheeNa: You want to know if a word is plural ?
08:49:19 <mauke> jaj: your Cabal is too old
08:49:27 <AtheeNa> Jedai : yes..
08:49:48 <jaj> thanks mauke
08:49:57 <Deewiant> > map ($ "foobar") (map isSuffixOf ["foo","bar"])
08:49:58 <lambdabot>  [False,True]
08:50:05 <AtheeNa> i need to treat a word cats as cats.. glasses as glass
08:51:44 <Otoom> Deewiant it doesnt create an .exe
08:51:45 <Jedai> AtheeNa: That's another problem, you'll need a Map (or a Trie) for that
08:51:50 <sfultong> too bad spoken languages aren't subjected to survival of the fittest
08:51:53 <Otoom> hey thoughtpolice
08:51:54 <AtheeNa> Tree?
08:52:05 <thoughtpolice> hi Otoom
08:52:09 <AtheeNa> oh my god..im just a beginner ..:(
08:52:10 <hpaste>  tr pasted "(no title)" at http://hpaste.org/6735
08:52:10 <Otoom> how r u?
08:52:20 <thoughtpolice> Otoom: sleepy
08:52:21 <Deewiant> Otoom: it does here, just fine
08:52:22 <Jedai> Otoom: try "ghc --make yourScript.hs"
08:52:45 <Otoom> thoughtpolice do you come on here oftne?
08:52:48 <Otoom> often*
08:52:52 <Jedai> AtheeNa: A Trie is a letter tree
08:53:26 <Jedai> AtheeNa: But we can start by using a Map (which is in the standard lib)
08:53:32 <Otoom> Jedai okay ill try that hold onm
08:54:00 <AtheeNa> Jedai : Map?... u mean map [somthing] <-- like this
08:54:02 <Jedai> AtheeNa: Do you have a dictionary with plural -> singular associations ?
08:54:11 <AtheeNa> oh..
08:54:37 <AtheeNa> u mean .. singular - plural..
08:54:37 <Jedai> AtheeNa: No, I mean Data.Map.Map, a dictionary
08:54:55 <AtheeNa> err..jedai...no
08:55:07 <thoughtpolice> Otoom: yes, it's a very nice channel. :)
08:55:09 <Otoom> its complaining something about main
08:55:22 <Otoom> and kl i may get coming here often then
08:56:10 <Jedai> Otoom: main is the function that will get run in a Haskell program, if you don't have a main in your source, then you can't compile it to an executable
08:56:14 <mauke> if you want singular->plural, there's a prewritten perl module for that
08:56:28 <Otoom> but i do
08:56:40 <Otoom> haha wait, would help if i was compiling the correct thing
08:56:50 <AtheeNa> mauke .. i cant use it... my lecturer asked me to do it in haskell.
08:56:51 <Deewiant> Otoom: -o would also compile about main
08:57:15 <Otoom> do u have to sve the file in the ghc folder?
08:57:21 <Otoom> or can i save it in my documents somewherE?
08:57:32 <Deewiant> it can be anywhere, doesn't matter
08:57:38 <Otoom> --make worked.
08:57:43 <Otoom> thanks
08:57:44 <Jedai> AtheeNa: Ok, if you don't have a dictionary, I guess you're supposed to do it with approximative functions
08:57:48 <mauke> Otoom: did you get a file called "hello" the first time?
08:57:55 <shachaf> Otoom: Are you running ghc in the directory it's installed in?
08:58:05 <Otoom> wait ppl
08:58:08 <Otoom> i have got it to compile
08:58:17 <Otoom> just doesnt stay open :O
08:58:21 <Otoom> ^^
08:58:27 <mauke> run it from a terminal
08:58:55 <Otoom> yhyh i kno
08:59:00 <Otoom> but is there no way of pausing it?
08:59:14 <TomMD> Otoom: Thats just a windows setting.  You can A) Run from terminal B) Change the windows settings to leave the term open C) Make your program delay or block.
08:59:23 <shachaf> Otoom: You can, but you should just run it from a terminal.
08:59:26 <Jedai> Otoom: end your main by getLine
08:59:27 <TomMD> Otoom: You could wait for keyboard input or just delay for some amount of time.
08:59:46 <mauke> Otoom: import System.Cmd; then put system "PAUSE" at the end of main
08:59:57 <Otoom> system commands suck
08:59:59 <mauke> this approach has the advantage of not working in linux
09:00:03 <Otoom> so no sorry mauke
09:00:04 <shachaf> mauke: Rather than getLine? Why?
09:00:15 <shachaf> Otoom: What's wrong with system?
09:00:28 <Deewiant> slow as turtles on windows
09:00:42 <Otoom> And its bad habbits.
09:00:46 <shachaf> Deewiant: This doesn't need to be fast; that's the point. :-)
09:00:48 <mauke> Deewiant: ... you want to optimize "Hit any key to continue ..."?
09:01:00 <Deewiant> no, I'm just talking about system in general :-)
09:01:02 <TomMD> Or just make it portable
09:01:13 <mauke> Otoom: it's not a bad habit
09:01:26 <shachaf> Otoom: So just run it from a terminal until you figure out how to make it pause.
09:01:53 <shachaf> Using a terminal for this is a good thing, even in Windows.
09:02:02 <TomMD> mauke: I think the Haskell community is lucky d o n s doesn't take the same non-portable attitude.
09:02:14 <mauke> TomMD: I want it to be non-portable
09:02:24 <TomMD> I could tell
09:02:25 <mauke> that's the whole point
09:02:48 <mauke> I don't want random programs to tell me "Hit any key to continue" when I run them in bash
09:02:58 <Otoom> http://www.coderprofile.com/source-code/341/projecteuler-questions-12356-in-haskell
09:03:00 <Otoom> He has no mains.
09:03:01 <lambdabot> Title: Coder Profile :: Source Code :: ProjectEuler Questions 1,2,3,5,6 in Haskell, http://tinyurl.com/33gpxg
09:03:12 <ari> mauke: ... That's pretty twisted
09:03:25 <thoughtpolice> Otoom: you can load files into GHCi and execute arbitrary functions
09:03:37 <Otoom> i kno that part
09:03:38 <shachaf> Otoom: You shouldn't be looking at the answers, anyway. :-)
09:03:47 <Otoom> what answers?
09:03:49 <shachaf> Otoom: main is for running a program directly.
09:03:55 <TomMD> Otoom: He isn't compiling it - he is probably just running the individual functions from ghci.
09:04:09 <Otoom> oh kk
09:04:31 <Otoom> haskell is confusing lmao
09:04:40 <mauke> no, it isn't
09:04:47 <Otoom> tis to me
09:04:54 <shachaf> Otoom: You are confused, then. :-)
09:04:57 <mauke> what programming languages do you know? :-)
09:05:04 <Otoom> perl, c++, php,
09:05:09 <sfultong> procedural programming is confusing, and unconfusing is difficult
09:05:27 <mauke> you could do the same thing in C++; write code without main and run it from a debugger
09:08:30 <Jedai> Otoom: In Haskell you have a REPL (Read Eval Print Loop), which is pretty useful for development
09:08:42 <resiak> hrm.  i don't suppose anyone has looked into making hpaste work in xmpp chat rooms?
09:08:46 <ehird> so I was coonsidering working on that serialize/sdeserialize built in pair
09:08:56 <shachaf> resiak: "work"?
09:09:04 <shachaf> resiak: You mean, the hpaste bot?
09:09:07 <resiak> shachaf: right
09:09:27 <shachaf> resiak: Not really, as far as I know; do you want it to?
09:09:39 <resiak> shachaf: i do!
09:09:54 <resiak> but don't have time to fix it up myself at the moment
09:10:04 <shachaf> resiak: You can always paste the link, and #haskell is the "official" place for it.
09:10:21 <resiak> shachaf: oh, this is for hosting an hpaste for a different project
09:10:37 <shachaf> resiak: Oh, sorry, I misunderstood.
09:11:04 <resiak> shachaf: where the xmpp muc is increasingly used alongside the IRC channel, but right now the pastebot only does IRC announcements.
09:11:12 <shachaf> resiak: Aren't there IRC-XMPP gateways that you can use?
09:11:32 <resiak> shachaf: probably
09:11:44 <Heffalump> why is XMPP useful?
09:12:17 <resiak> more useful than IRC, you mean?
09:12:17 <shachaf> Heffalump: Because resiak is already using XMPP, I guess?
09:12:55 <EvilTerran> because XML!
09:13:21 <kpreid> XMPP doesn't punt on encodings, doesn't have a line-length limit
09:13:35 <kpreid> doesn't divide the world into networks
09:13:38 <Heffalump> resiak: yeah
09:13:49 <matthew-_> does "Peano Numbers" refer exclusively to data Nat = Zero | Succ Nat or to any means to represent Natural Numbers?
09:14:13 <Heffalump> isn't punting on encodings a good thing?
09:14:14 <resiak> no=
09:14:16 <kpreid> no
09:14:17 <Baughn> matthew-_: It refers to unary, pretty much
09:14:22 <matthew-_> thank you
09:14:25 <resiak> xmpp is utf-8.  there is no problem ever again.
09:14:41 <Baughn> matthew-_: http://en.wikipedia.org/wiki/Peano_numbers <-- Here, have the details. It's all very cute.
09:14:41 <Heffalump> yerright
09:15:41 <resiak> Heffalump: xmpp has richer statuses, support for proper rosters/buddy lists without polling or non-standard server extensions...
09:15:46 <skorpan> @pl \m -> case m of { Capture _ to -> to == m; EnPassant _ to -> to == m }
09:15:46 <lambdabot> (line 1, column 17):
09:15:47 <lambdabot> unexpected "{"
09:15:47 <lambdabot> expecting variable, "(", operator or end of input
09:16:01 <shachaf> Weren't there only 5 axioms?
09:16:01 <EvilTerran>  @pl can't do pattern-matching
09:16:09 <skorpan> EvilTerran: i see
09:16:12 <resiak> Heffalump: there's no reason I can see why its multi-user chats couldn't be used as better IRC channels, barring a lack of tools like pastebots
09:16:37 <EvilTerran> skorpan, precisely, in fact, because it's impossible to make code like that pointfree without helper functions that themselves aren't
09:16:46 <Baughn> skorpan: Nor is there any reasonable way to rewrite pattern-matching pointslessly
09:16:46 * shachaf thinks something Obby-ish should be integrated into something #haskell-ish.
09:17:24 <Heffalump> I'm not convinced that making things more complicated is "better".
09:17:37 <ehird> xmpp is useless
09:17:39 <ehird> irc won
09:17:52 <skorpan> why is it called pointless?
09:18:13 <EvilTerran> skorpan, however, if Capture and EnPassant are record constructors with the second parameter having the same field name (say, "to") in both, you can write it as (==m).to
09:18:15 <ukl> f x = x + 2
09:18:19 <shachaf> skorpan: "Point-free", where the named arguments are called points.
09:18:21 <ukl> x could be a point
09:18:28 <matthew-_> some one should implement a new IM system on top of AMQP
09:18:28 <ukl> f = (+ 2)
09:18:31 <ukl>  no x, no point
09:18:33 <skorpan> okay i get it
09:18:36 <Deewiant> skorpan: http://en.wikipedia.org/wiki/Pointless_topology
09:18:40 <skorpan> i thought the points referred to were the periods
09:18:44 <EvilTerran> matthew-_, ooh, ooh, or on top of DNS! :D
09:18:49 <matthew-_> then you could do guaranteed delivery and all sorts of other useful features
09:18:56 <matthew-_> EvilTerran: my suggestion was sane :)
09:18:56 * EvilTerran runs away cackling
09:19:17 <EvilTerran> i, on the other hand, are clearly insane
09:19:22 <EvilTerran> cosane?
09:19:32 <EvilTerran> s/are/am/
09:19:40 <matthew-_> EvilTerran: Cale called me clearly insane yesterday
09:19:44 <resiak> Heffalump: people glue things onto the side of IRC (like polling-free buddy lists) because they want "more complicated" features; xmpp has all this stuff, and you can just ignore it if you don't care
09:19:51 <matthew-_> he'd just read my session type tutorial. He may be right
09:20:07 <Heffalump> what's a polling-free buddy list?
09:20:13 <Baughn> Sadly, xmpp uses an incredibly inefficient encoding. It probably doesn't /matter/, but it makes my hackles raise
09:20:19 <Baughn> Heffalump: A push-based buddy list
09:20:30 <Heffalump> ...?
09:20:33 <matthew-_> you don't have to poll the server to find your buddies' statae
09:20:34 <Baughn> Heffalump: "Don't ask me when I log on, I'll tell you"
09:20:38 <resiak> Heffalump: a list of people you're interested in, with their statuses
09:20:39 <Heffalump> ah, right.
09:20:46 <ehird> Baughn: UTF-8 won too
09:20:49 <resiak> ditto, statuses of people in your chatroom
09:20:53 <ehird> better luck next time!
09:21:08 <Baughn> ehird: UTF-8 is a decent compromise with ascii. I don't dislike it.
09:21:09 <matthew-_> does anyone know of a jabber client that actually supports chat rooms?
09:21:20 <matthew-_> mcabber does, but I've not seen anything else
09:21:24 <ehird> Baughn: Internally, UTF-16, externally, UTF-8
09:21:30 <shachaf> matthew-_: Pidgin, no?
09:21:31 <ehird> That' pretty much the only choice nowadays
09:21:40 <ehird> matthew-_: Well, kopete does..
09:21:52 <ehird> Baughn: And IRC, too.
09:21:55 <matthew-_> ok, I must have missed those then
09:21:59 <Heffalump> I don't really see how #haskell (for example) would be improved by any of this. Or indeed that place over there <--
09:22:01 * shachaf doubts it's very good at it, though; Pidgin's IRC client is unbearable.
09:22:37 <darrint> If I use :: notation to disambiguate the type of an expression in a function, is there a way I can refer to type variables in the function definition?
09:22:39 <ehird> shachaf: indeed
09:22:48 <ehird> darrint: There are no first-class types
09:22:50 <ehird> What do you want to do?
09:22:59 <mauke> darrint: not in H98
09:23:05 <Baughn> darrint: Scoped typing's a ghc extension
09:23:09 <shachaf> darrint: There's a -X option.
09:23:22 <shachaf> -XScopedTypeVariables
09:23:26 <darrint> non H98 is ok for this function. I'll look that up now.
09:24:06 <Baughn> ehird: My problem with xmpp (or, really, xml) is that it's fairly easy to make an extensible binary protocol. I've seen a number of them, and with proper documentation, there's no /need/ for xml.
09:24:29 <Baughn> ehird: Look at MKV, for example
09:25:09 <ehird> Baughn: MKV is nice
09:25:17 <ehird> Baughn: XML is indeed the wrong solution to a lot of problems
09:25:22 <ehird> But the right solution to others
09:25:36 <Baughn> What is it the right solution for, pray tell?
09:25:46 <ehird> Baughn: Lots of things.
09:25:50 <ehird> XML is a useful format.
09:26:03 <Heffalump> it's good for saving people from ad-hoc formats
09:26:57 <dfeuer> LUMP
09:27:27 <resiak> shachaf: ironically, the "other project" whose pastebot i was referring to is pidgin ;-)
09:27:46 <Baughn> Heffalump: So how about ASN.1? ^_^
09:27:49 <ahunter> ehird: A professor of mine likes to say that XML solved a solved problem, syntax
09:28:08 <resiak> matthew-_: Gossip and Empathy both do xmpp chats
09:28:35 <ehird> ahunter: for every situation, there is a short one-liner that is witty, amusing, and false
09:28:53 <dfeuer> Yes, and it's just as easy to make a lousy ad-hoc XML format as a lousy ad-hoc non-XML format, no
09:28:54 <dfeuer> ?
09:29:02 <ehird> dfeuer: Of course.
09:29:03 <Heffalump> baughn: looks quite like XML
09:29:26 <Heffalump> just with different delimiters
09:29:27 <ahunter> ehird: true, but I happen to agree with her.  Yeah, the syntax is now solved--we can use XML, and that means I Know How To Parse That.
09:29:32 <Baughn> Heffalump: Right, but it's considerably easier to parse, and can be parsed in a tenth of the time. It also results in files a tenth of the size..
09:29:37 <ahunter> ...that's the only thing it gives me.
09:29:51 <Baughn> Heffalump: Also, unlike XML, asn.1 allows you to skip unwanted subtrees with ease
09:29:53 <kpreid> ahunter: I think that's a big thing (not that it's exclusive to XML)
09:30:01 <Heffalump> why is that hard in XML?
09:30:13 <Baughn> Because XML subtrees don't specify byte offsets to the next subtree
09:30:27 <kpreid> not having to write a parser for some format means I can stuff it in a generic parser, get back a tree, and pick out the bits I'm interested in. O(k) rather than O(n) work
09:30:44 <ahunter> kpreid: eh, it's a big thing, but it shouldn't be.  Parsers are easy.  If we want a complicated human readable format, learn yacc, it's not that hard.  If not, hell, sexps are just like XML formatwise, absolutely trivial to parse, and are much smaller and cleaner
09:30:49 <ehird> Baughn: suprise! xml isn't a binary format
09:30:50 <dfeuer> Isn't the big selling point of XML that it's simpler than SGML?
09:30:55 <matthew-_> but n is succ . succ . succ $ k
09:30:55 <ehird> a lot of uses of it are, but they are idiotic
09:30:59 <ehird> good xml is mostly human readable
09:31:08 <Baughn> ehird: My complaint exactly
09:31:11 <ahunter> readable, maybe. Editable hell no.
09:31:21 <ehird> ahunter: Strange. I seem to get along fine.
09:31:35 <kpreid> ahunter: you underestimate the work of writing a parser, even with yacc/parsec/your-favorite-parser-gen, compared to using an available genric parser
09:31:42 <ehird> Same way editing Lisp without a decent editor is uneditable, of course..
09:31:54 <kpreid> and sexps aren't standardized
09:31:59 <kpreid> (would be great if they were ,though!)
09:32:14 <dfeuer> sexps aren't standardized?
09:32:29 <dfeuer> I think there are two standards for sexps....
09:32:35 <dfeuer> Pretty similar.....
09:32:39 <ahunter> kpreid: If I'm writing a format that needs yacc, it's because I'm putting lots of thought into something humans can write, there's no reason to do so otherwise.  In that case, I'm ok putting a few hours into the grammar.
09:33:09 <kpreid> ahunter: I'm talking about the user that wants to process data in an existing format, not designing a new format
09:33:39 <ehird> @type runIO
09:33:41 <lambdabot> Not in scope: `runIO'
09:33:46 <ahunter> ic...though in theory, shouldn't there be an existing parser? :P  I know that's not really an answer, but I hope you vaguely see my point.
09:34:00 <Baughn> ehird: It's called "unsafePerformIO"
09:34:10 <ehird> Baughn: yes I know I know :)
09:34:10 <kpreid> ahunter: doesn't help if the existing parser doesn't run on the platform I'm using
09:34:17 <ehird> but ghc's primitive runtime has a funcftion called that
09:34:49 <kpreid> ahunter: whereas a generic format (xml, json, asn-1, whatever) is more likely to have parsers already written
09:34:51 <ahunter> kpreid: on the other hand, it means parsing the format is a (hopefully, mostly) solved problem, means that writing your copycat parser will be much easier
09:35:29 <kpreid> ahunter: but if I don't *have* to write a copycat parser, that's even better.
09:36:05 <Baughn> None of which has any bearing on using a nice, standardized binary format instead of XML. *shrug*
09:36:06 <ahunter> kpreid: true.  That is the attraction of generic formats.  How about sexprs?
09:36:22 <kpreid> ahunter: well, nobody does it. other than that, can't say much against it!
09:36:54 <ahunter> kpreid: heh.
09:37:05 <kpreid> ahunter: if there was a movement to writing CL or Scheme (or whatever) sexp parsers in many languages, well, ding, problem solved
09:37:17 <ahunter> wouldn't it be nice...
09:37:44 <kpreid> (note that CL's built-in parser is unsuitable, so there are zero, not one, instances as yet)
09:37:49 <kpreid> (dunno about Scheme)
09:38:22 <EvilTerran> at least s-exps are a little more standard than, say, CSV
09:39:26 <EvilTerran> for data serialization, you'd only need a subset, anyway - ()s, c-style ""s, maybe a number format or two, dotted-pair if you're feeling picky...
09:40:08 <kpreid> might as well use JSON then
09:40:16 <kpreid> it's already got a movement
09:40:34 <ahunter> JSON's not bad
09:40:38 <EvilTerran> s-exps do kinda have a movement. they just don't, er, *move* much :P
09:40:50 <kpreid> har
09:40:51 * EvilTerran is a proponent
09:42:08 <EvilTerran> JSON's relatively very new, tho, so i guess still have the initial momentum of "hey look at this cool format we just thought up!"
09:42:38 <ehird> json is pretty widely used
09:42:52 <ehird> kpreid: scheme has things like `abc -> (backquote abc)
09:42:55 * kpreid likes the sexp idiom of operator/tag followed by args
09:42:58 <ehird> and ,@abc -> (unquote-splice abc)
09:43:09 <EvilTerran> also JSON came at a good time to ride the XML backlash
09:43:13 <kpreid> ehird: yes; I'm not sure how that relates?
09:43:26 <EvilTerran> ehird, you don't really need those for serialization, anyway
09:44:04 <EvilTerran> seeing as i'd expect something serialized to be parsed as if it were already wrapped in a '(...)
09:45:20 <obk> If you want a human readable serialization format there's always YAML (which is a superset of JSON so you can start with that). If you don't care about human readability, what is wrong with XML?
09:45:30 <Riastradh> (UNQUOTE, not BACKQUOTE, and UNQUOTE-SPLICING, not UNQUOTE-SPLICE.)  Omitting that notation from reading is trivial; omitting that notation from the standard writer is non-trivial.
09:45:52 <Riastradh> obk, extreme overcomplexity of the definition, and extreme overimmensity of the serialized data.
09:46:19 <EvilTerran> and s-exps are significantly easier to parse than YAML
09:46:29 <obk> Riastradh: JSON definition is as simple as it gets, the the data is pretty compact
09:46:32 <EvilTerran> once you agree on a standard, anyway...
09:46:34 <Riastradh> Easier to edit, too, if I may say so myself...
09:46:52 <Baughn> obk: I believe that was a complaint about XML, not JSON
09:46:57 <EvilTerran> also, some people find whitespace-sensitivity squicky
09:47:16 <obk> It isn;t worse than Haskell indentation rules :-)
09:47:28 <Baughn> It couldn't possibly be. *shudder*
09:47:36 <obk> Anyway, the point is the driving requirements
09:47:47 <Riastradh> If ASN.1 had a readable definition, then it would be a much more palatable approach to any of this.  But the specification was written for and by ISO bureaucrats and lawyers, unfortunately.
09:47:50 <obk> If human readability is not a concern, XML will work
09:48:00 <obk> You have a zillion tools and it is very mainstream
09:48:18 <Deewiant> funny how I've never found the haskell indentation rules problematic at all
09:48:41 <obk> If human readability is a concern, then (what with humans being so quirky) you end up with something like YAML. Instead of plunging into it, you can start with JSON
09:48:43 <Baughn> Riastradh: So how about the definition at http://www.matroska.org/technical/specs/index.html ?
09:48:44 <lambdabot> Title: Matroska Format Specifications
09:49:03 <Baughn> Riastradh: It's not asn.1, but it /should/ be sufficient, if only people would use it
09:49:14 <Riastradh> I like the name.
09:50:03 <obk> Shudder - that reminds me of the dark ages of EDI
09:50:06 <ahunter> Deewiant: they aren't usually a problem.  Every so often, they get annoying.  Especially when haskell-mode is just plain wrong...for example, it Very Much Wants to line up a "then" directly below the corresponding "if", which I believe is incorrect (and which GHC doesn't seem to like.)
09:50:12 <skorpan> is it possible to create a datatype which works like: data A d = MyB | MyC | d
09:50:26 <skorpan> i.e. without a specific constructor for "d"
09:50:33 <Deewiant> ahunter: switch to Vim and you'll be fine ;-)
09:50:46 <mauke> skorpan: no
09:50:52 <skorpan> okay
09:50:52 <EvilTerran> skorpan, no, otherwise the typechecker couldn't tell if something was going to be of type d, A d, A (A d), A (A (A d)) ...
09:50:56 <Riastradh> However, I don't immediately see any indication that the Matrioshka format solves the problems that ASN.1 was designed to solve -- namely, separating the structural description from the actual encoding.
09:51:57 <Baughn> Riastradh: EBML, not matroska. And it doesn't, but it'd make a good start if you wanted to make one that did.
09:52:00 <Riastradh> I didn't look very hard, but I was distracted by the immediate deluge of binary descriptions.
09:52:57 <Baughn> Riastradh: It does allow you to parse arbitrary EBML code into a tree, although the identifiers won't be named usefully. The rest is a simple matter of inventing a metadata format
09:53:19 <EvilTerran> skorpan, there are olegian hacks to do something similar to what you want, but they're only really viable as curiosities, not as idioms for production code
09:54:11 <EvilTerran> (extensible alternations, in the style of HList-esque extensible records)
09:56:51 <EvilTerran> you'd wind up with something like "data MyB = MyB; data MyC = MyC; type A d = MyB `Or` MyC `Or` d" - and then actually getting values out would be a nightmare
09:57:39 <Saizan> there are Type Indexed Coproducts in the HList paper, but they use Dynamic
09:59:40 <EvilTerran> ?where hlist
09:59:40 <lambdabot> http://homepages.cwi.nl/~ralf/HList
10:11:06 <skorpan> lol
10:19:50 <gwern> I forget, does darcs support symlinks?
10:23:24 <kpreid> gwern: not last time I noticed
10:23:33 <kpreid> it would just follow them
10:30:46 <gwern> hm. next question, can you do the -- ^ haddock syntax with 'type' types?
10:33:19 <sfultong> > [x | x <- y, y <- [[0,1],[1,2]]]
10:33:20 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Expr'
10:33:59 <sfultong> > [x | x <- y, y <- [[0,1],[2,3]]]
10:34:00 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Expr'
10:34:02 <Otoom> lambdabot is good
10:34:03 <shachaf> sfultong: You have to bind y before x.
10:34:20 <sfultong> > [x | y <- [[0,1],[2,3]], x <- y]
10:34:22 <lambdabot>  [0,1,2,3]
10:34:25 <sfultong> heh, thanks
10:34:32 <sfultong> it's always some stupid error on my part
10:34:36 <shachaf> Of course, this is pointless.
10:34:44 <mauke> > concat [[0,1],[2,3]]
10:34:45 <lambdabot>  [0,1,2,3]
10:35:22 <shachaf> It's just a long way of writing (>>= id), or join, or concatMap id, or concat.
10:37:08 <sfultong> sure, but something like it will be useful for my ... uses
10:38:29 <Jedai> sfultong: Sure, but just remember that list comprehension aren't always the best (and easiest to read) solution
10:38:45 <sfultong> pffft, readable code
10:38:58 <darrint> yay for scoped typing.
10:39:15 <sfultong> if I wanted people to be able to read my code, I wouldn't be using haskell
10:39:24 <mauke> sfultong: that's the spirit!
10:39:51 <Jedai> Strangely I find Haskell code to be very readable
10:40:41 <Jedai> But then I'm easily bored when in another language I realize that the 20 lines I just read could have been expressed in one in Haskell...
10:41:12 <sfultong> yes, but of the number people who can read haskell is a very small subset of people who can read programming code
10:41:16 <gnuvince_> powerful combinators == less code
10:42:10 <Jedai> sfultong: Well, given the proportion of Haskell coders / programmers, this isn't really a surprise
10:42:13 <Heffalump> Haskell code can be quite intricate
10:42:14 <ehird> @src ap
10:42:14 <lambdabot> ap = liftM2 id
10:42:30 <ehird> @unpl liftM2 id
10:42:30 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
10:42:31 <sfultong> I find haskell pleasant to read as well... although in general I'm terrible at reading comprehension for other people's code
10:42:34 <ehird> @. redo unpl liftM2 id
10:42:34 <lambdabot> (\ d e -> do { b <- d; a <- e; return (b a)})
10:42:36 <Heffalump> and I sometimes find other people's code hard to read purely because of the Haskell combinators or tricks they've used
10:42:43 <ehird> @src [] >>=
10:42:43 <lambdabot> Source not found. You type like i drive.
10:42:48 <ehird> :/ whut
10:42:52 <ehird> @src >>= []
10:42:52 <lambdabot> Source not found. That's something I cannot allow to happen.
10:42:56 <mauke> @src [] (>>=)
10:42:56 <lambdabot> m >>= k     = foldr ((++) . k) [] m
10:42:58 <ehird> ah
10:42:58 <Deewiant> @src [] (>>=)
10:42:59 <ehird> thanks
10:42:59 <lambdabot> m >>= k     = foldr ((++) . k) [] m
10:43:21 <Heffalump> but generally I find that comprehension problems are to do with what they are actually doing, not how they are doing it - and then the extra concision of Haskell makes it easier to work stuff out
10:43:51 <resiak> why is [] >>= defined directly in terms of foldr, not with concat and map?
10:44:04 <ehird> \d e -> foldr ((++) . \ b -> foldr ((++) . \ a -> return (b a)) e) d
10:44:06 <ehird> @unpl \d e -> foldr ((++) . \ b -> foldr ((++) . \ a -> return (b a)) e) d
10:44:07 <lambdabot> \ d e -> foldr (\ g -> (++) (foldr (\ j -> (++) (return (g j))) e)) d
10:44:08 <sfultong> yeah, by the time you understand what they are doing, you already understand how... assuming no comments
10:44:13 <shachaf> resiak: Some sort of efficiency thing, I think.
10:44:25 <mauke> @src concatMap
10:44:25 <lambdabot> concatMap f = foldr ((++) . f) []
10:44:26 <ttfh> goodevening
10:44:26 <resiak> yeah, but i would kind of hope that the compiler could sort that out
10:44:27 <shachaf> resiak: It could just as easily be (flip concatMap)
10:44:30 <resiak> well yes
10:44:37 <resiak> ditto for concatMap
10:44:47 <mauke> @src concat
10:44:48 <lambdabot> concat = foldr (++) []
10:44:50 <Deewiant> (>>=) = flip (=<<)
10:44:56 <Heffalump> resiak: it might fuse better
10:44:59 <ehird> @pl \d e -> foldr (\g -> (++) $ foldr (\j -> (++) $ return $ g j) e) d
10:45:00 <lambdabot> flip (foldr . ((++) .) . flip (foldr . (((++) . return) .)))
10:45:02 <ehird> @. unpl pl \d e -> foldr (\g -> (++) $ foldr (\j -> (++) $ return $ g j) e) d
10:45:02 <lambdabot> (\ b c -> foldr (\ w -> (++) (foldr (\ z -> (++) (return (w z))) c)) b)
10:45:05 <resiak> Heffalump: hrm, fair enough
10:45:06 <ehird> good
10:45:11 <mauke> that's not an issue in lambdabot, though
10:45:14 <Jedai> @src concatMap
10:45:14 <lambdabot> concatMap f = foldr ((++) . f) []
10:45:20 <ehird> > let ap d e -> foldr (\g -> (++) $ foldr (\j -> (++) $ return $ g j) e) d in ap [(2+),succ] [1,2,3]
10:45:20 <lambdabot>  Parse error at "->" (column 12)
10:45:24 <ehird> hmph
10:45:26 <mauke> lambdabot's @src is purely virtual anyway
10:45:43 <Heffalump> but you would think concatMap could have been used, as the inliner would operate anyway
10:45:43 <gwern> huh. I guess Haddock really doesn't handle documenting parameters to 'type' declarations
10:45:55 <sfultong> I think that having operators/functions that are flipped versions of other operators/functions is bad karma
10:46:06 <sfultong> that is, in the standard
10:46:30 <ttfh> does anyone have a nice example of a haskell program with a space leak?
10:46:47 <sfultong> how was what went into prelude determined, anyway?
10:47:00 <shachaf> gwern: From xmonad: "-- | Virtual workspace indices\ntype WorkspaceId = String"
10:47:10 <shapr> ttfh: try mapping open and read over a bunch of files
10:47:13 <Deewiant> ttfh: powerset [] = [[]]; powerset (x:xs) = xss ++ map (x:) xss where xss = powerset xs
10:47:19 <shachaf> Oh, parameters.
10:47:33 <shachaf> Never mind, I guess.
10:47:50 <gwern> shachaf: yeah, as in the -- ^ stuff
10:47:57 * gwern has emailed Waern about it
10:48:27 <gwern> the manual simply omits any mention or example of 'type', so I wonder if it was an oversight. how often do people try to annotate type aliases anyway?
10:48:48 <ehird> gwaern
10:49:48 * gwern chuckles manically. soon Waern shall fall into my trap, and I will assimilate him as so many others - creating - Gwaern!
10:50:03 <ttfh> shapr, Deewiant: thanks
10:50:06 <paczesiowa> @seen dcoutts_
10:50:07 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #ghc and #haskell. I last heard dcoutts_ speak 20h 39m 20s ago.
10:50:31 <monochrom> Often people use self-documenting type variable names in type aliases, e.g., "type Marry john mary a = ReaderT john (Writer mary) a".
10:51:01 <ehird> monochrom: real men use single-character
10:51:05 <ehird> type variables
10:51:05 <hasenov> hello, how easy is it to call c functions from haskell?
10:51:06 <ehird> :)
10:51:11 <ehird> hasenov: quite
10:51:17 <hasenov> is it as easy as python?
10:51:18 <Jedai> hasenov: Not too hard
10:51:30 <shachaf> ehird: Can they use any Unicode character they want, though?
10:51:35 <monochrom> That is irrelevent.
10:51:48 <cnwdup> Is the word ID anything special in Haskell? data Post = Post { ID :: Int } doesn't compile, data Post = Post { foo :: Int } does.
10:52:05 <shachaf> cnwdup: "foo" is lower-case.
10:52:06 <Deewiant> cnwdup: it starts with a capital letter
10:52:07 <dons> cnwdup: ID isn't a constructor
10:52:11 <ehird> shachaf: maybe not :(
10:52:19 <cnwdup> Ahh, thanks.
10:52:57 <hasenov> ghc in itself is written in C so it shouldnt be too hard
10:53:04 <hasenov> at least i thinl
10:53:08 <Jedai> cnwdup: record label must start with a lowercase letter
10:53:08 <ehird> hasenov: ghc is written in haskell
10:53:12 <ehird> also, what kind of thing is that
10:53:19 <ehird> how does that make sense at all
10:53:21 <ehird> ghc is just a compiler
10:53:30 <cnwdup> Jedai: I know. Well, at least in general. Somehow I forgot it in case of ID. O:
10:54:20 <hasenov> really? wouldn't some part need to be written in some other language?
10:54:29 <ehird> hasenov: no
10:54:36 <ehird> hasenov: and ghc uses ghc extensions
10:54:38 <hasenov> or assembly maybe
10:54:39 <ehird> so you need ghc to compile ghc
10:54:54 <ehird> the runtime system of ghc is written in C, that implements all the IO builtins etc
10:54:59 <ehird> but the compiler itself is haskell
10:55:03 <mauke> I've written compilers in Perl
10:55:14 <ehird> if you want to *compile* ghc, you have to get a binary of ghc, then compile ghc with that ghc
10:55:16 <mauke> (technically)
10:55:17 <sfultong> hasenov: the very first version of a compile has to be written in a different language... but after that, you can reimplement the compiler to compile in your new compile
10:55:22 <hpaste>  magnusth annotated "hxt html links" with "more hxt troubles" at http://hpaste.org/6730#a1
10:55:28 <ehird> if you want to port it to a new platform, you have to cross-compile a ghc on your platform
10:55:36 <ehird> and then if you want compile ghc with the cross-compiled ghc on your new platform
10:55:52 <hasenov> sfultong : oh ok, that makes sense
10:56:22 <sfultong> and don't ask why I left the 'r' off of "compiler"
10:56:30 * magnusth is still having problems with HXT :(
10:56:46 <sfultong> maybe I subconsciously want to be seen as not having English as my first language
10:56:51 <Jedai> What is the tool most in favor to translate C to Haskell ? hsc2c ?
10:57:14 <EvilTerran> ... that doesn't translate C to haskell
10:57:30 <EvilTerran> (does it?)
10:57:33 <ehird> EvilTerran: no
10:57:33 <hasenov> Jedai : im looking at c2hs right now
10:57:37 <Jedai> Well nopt "translate", but do all the binding sugar
10:57:45 <ehird> Jedai: oh, then c2hs or hsc2c or whatever
10:57:46 <sfultong> c to haskell sounds like it would be ugly
10:57:48 <shachaf> EvilTerran: It translates hsc to Haskell. :-)
10:57:53 <shachaf> (hsc2hs does, anyway.)
10:57:53 <ehird> hsc2c you just write a special looking haskell file
10:57:56 <ehird> that isn't really haskell
10:57:57 <EvilTerran> people use a mixture of c2hs and hsc2hs
10:57:58 <ehird> but looks like it
10:58:01 <mauke> hsc2hs just lets you get C-specific numbers into your haskell programs
10:58:02 <ehird> and it binds-er-up
10:58:12 <mauke> like enum values and struct member offsets
10:58:24 <EvilTerran> i think some people use both, even
11:04:05 <mauke> @hoogle (a -> b) -> (a,a) -> (b,b)
11:04:11 <lambdabot> No matches, try a more general search
11:04:22 <shachaf> @ty join (***)
11:04:23 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
11:04:49 <mauke> :t (&&&)
11:04:50 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
11:05:32 <Jedai> > join (***) (+2) (1,3)
11:05:33 <lambdabot>  (3,5)
11:09:49 * ddarius has never needed anything other than the raw FFI
11:10:05 <dons> no hsc2hs?
11:10:35 <dons> if you're communicating any non-primitive data , wrappers are almost essential if its to be portable
11:11:44 <araujo> @pl (\ (_,_,x) -> x)
11:11:44 <lambdabot> (line 1, column 8):
11:11:44 <lambdabot> unexpected ","
11:11:44 <lambdabot> expecting operator or ")"
11:11:44 <lambdabot> ambiguous use of a non associative operator
11:11:47 <araujo> bug?
11:12:01 <mauke> pl can't deconstruct arbitrary types
11:12:02 <Deewiant> araujo: lambdabot can't handle triples or bigger
11:12:07 <ttt--> what do the stars (*) mean in :t (&&&) ?
11:12:09 <araujo> :-(
11:12:12 <Deewiant> or pl rather, yes
11:12:23 <shachaf> ttt--: Kinds.
11:12:31 <araujo> @pl (\ (_, x) -> x)
11:12:31 <lambdabot> snd
11:12:35 <shachaf> @ty (&&&)
11:12:36 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
11:12:46 <shachaf> ttt--: Actually, I don't see any "(*)"s.
11:12:48 <Deewiant> araujo: the simple reason being that there's no such function (often called 'thd' or 'trd') in the prelude
11:12:58 <araujo> Deewiant, yeah
11:13:09 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6736
11:13:10 <shachaf> Deewiant: If there was, how would you call the functions to get the first and second members?
11:13:11 <araujo> I was wondering if lambdabot could come up with something interesting
11:13:26 <Deewiant> shachaf: fst3, snd3, trd3 is the naming scheme I use
11:13:43 <Deewiant> shachaf: and, IIRC a GHC bug report, they're coming to Data.Tuple
11:14:01 * araujo will write his own thrd , frth , fith
11:14:06 <Deewiant> araujo: it's such a basic function that you can't simplify it any further
11:14:10 <araujo> off to eat
11:14:17 <shachaf> You can also use type classes to use the same name for n-sized tuples.
11:14:49 <Deewiant> true, but then you'd have to hide fst and snd from the prelude.
11:18:21 <Otoom> the haskell bot on the wilki is awsome
11:18:23 <Otoom> just thought ide say
11:22:34 <skorpan> if i have a State which has return type A, is there any way to return some sort of "Nothing" without defining the return type to "Maybe A"?
11:22:52 * SamB wishes emacs had fasl
11:22:55 <EvilTerran> no
11:22:56 <shachaf> skorpan: Why would there be?
11:23:06 <mauke> you can return undefined as long as you don't look at it
11:23:30 <EvilTerran> you may be able to return mzero or mempty or something
11:23:30 <skorpan> shachaf: because it would suit my needs very well, that's why.
11:23:53 <SamB> skorpan: you could use an ErrorT or a MaybeT
11:24:06 <skorpan> SamB: i do use ErrorT!
11:24:14 <skorpan> ErrorT (StateT something something..)
11:24:28 <EvilTerran> so... use that?
11:24:31 <skorpan> but i don't wish to report the "nothing" is an error
11:24:36 <SamB> well, catch it!
11:24:39 <SamB> or something
11:24:39 <skorpan> it's just that it shouldn't return anything relevant
11:24:47 <SamB> what are you trying to do ?
11:24:49 <EvilTerran> then use maybe! that's what it's there for!
11:24:53 <skorpan> EvilTerran: thanks
11:24:59 <skorpan> SamB: a chess game to put it short
11:25:05 <ahunter> can we see the code on hpaste?
11:25:19 <skorpan> the code is way too long for anyone to care to look at
11:25:22 <skorpan> thanks for the help anyways
11:25:35 <SamB> maybe just the types?
11:25:38 <skorpan> it would simply take too long to explain all the relevant parts of the context
11:25:45 <SamB> the types wouldn't be so long ;-)
11:25:56 <skorpan> which types do you want?
11:26:19 <skorpan> currently i am already using Maybe
11:26:24 <skorpan> never mind, really, thanks :)
11:27:35 * magnusth has finally found hasAttrValue
11:27:53 <EvilTerran> ?hoogle hasAttrValue
11:27:54 <lambdabot> No matches found
11:28:05 <EvilTerran> quoi?
11:29:35 * SamB wonders what shell variable stores number of arguments
11:29:49 <Igloo> $#
11:30:06 <SamB> cool
11:36:02 <SamB> why does hp2ps format graphs in *seascape* rather than landscape?"
11:36:29 <idnar> seascape?
11:36:47 <SamB> idnar: green at top, blue at bottom -- upside-down landscape
11:37:07 <SamB> also, a menu item in gv
11:38:04 <idnar> ah
11:42:53 <SamB> man, retainer profiling *is* slow
11:43:17 <dons> have you profiled it?
11:44:05 <SamB> dons: you must be joking
11:44:14 <SamB> dons: the manual *says* it's slow
11:44:24 <dons> yeah, you should profile it
11:44:27 <dons> and find out why.
11:44:31 <SamB> I can't think of how it couldn't be slow
11:44:31 <magnusth> EvilTerran: part of HXT
11:44:41 <SamB> I mean, it seems fairly obvious when you think about it...
11:44:41 <dons> oh well, no icfp paper for SamB
11:45:07 <SamB> not that there is no way to make it fast, but *I* am not the genious to find it by setting out to find it
11:45:23 <magnusth> EvilTerran: I've been trying to find a way of extracting all links on a page that match a certain patter (in this case end in .mp3)
11:45:34 <SamB> maybe I'll find it by accident ;-P
11:45:46 <magnusth> and hasAttrValue seems to be the solution to it
11:46:15 <SamB> dons: can YOU think of a fast way trace the wrong way on a digraph?
11:46:33 <dons> well, we've new tracing tools in ghc
11:46:44 <dons> so i'd not be surprised if there weren't new tricks
11:47:02 <SamB> you think the log is going to help with calculating retainers?
11:47:11 <SamB> that tiny thing?
11:47:22 <dons> hmm?
11:47:30 <SamB> what new tools were you thinking of?
11:47:40 <dons> no, i'm making a point that its about time you wrote some packages, or worked on ghc things you're complaining about
11:47:51 <SamB> hey, I'm working on JHC!
11:47:58 <dons> good! when's the release?
11:48:02 <SamB> release?
11:48:16 <EvilTerran> HANDBAGS AT DAWN
11:48:19 <EvilTerran> (sorry)
11:48:31 <SamB> er... wouldn't a bug tracker be more useful at this point?
11:48:46 <Twey> EvilTerran: Laff
11:48:51 <dons> you could have set up a bug tracker in the time to write that sentence
11:48:59 <SamB> I wasn't meaning to complain
11:49:08 <SamB> it's along the lines of "they weren't kidding!"
11:50:27 <AtheeNa> help me please.. how to treat a plural word with s, sses, oes, xes ?
11:50:47 <EvilTerran> AtheeNa, with a dictionary with that information in it
11:50:51 <EvilTerran> ?go princeton wordnet
11:50:52 <lambdabot> http://wordnet.princeton.edu/
11:50:52 <lambdabot> Title: WordNet - Princeton University Cognitive Science Laboratory
11:50:58 <EvilTerran> that might have something
11:50:59 <SamB> AtheeNa: what word?
11:51:12 <monochrom> Eh?  Haskell knows no plural/singular. :)
11:51:52 <AtheeNa> like cats -> cat.. the program need to detect the word with s or sses etc..and return as singular
11:52:21 <SamB> hah
11:52:26 <AtheeNa> i tried with the isSuffixOf..
11:52:42 <SamB> never gonna work!
11:52:54 <Deewiant> english is too irregular for that too work in 100% of cases
11:52:56 <SamB> my spellchecker isn't even certain about these things
11:52:57 <Deewiant> er
11:52:58 <Deewiant> s/too/to/
11:53:24 <monochrom> hehe, best to use lookup table.
11:53:45 <Twey> AtheeNa: http://www.haskell.org/haskellwiki/Applications_and_libraries/Linguistics#Parsing_natural_languages
11:53:47 <lambdabot> Title: Applications and libraries/Linguistics - HaskellWiki, http://tinyurl.com/2aaeeg
11:53:53 <AtheeNa> dictionary?..lookuptable?
11:54:29 <SamB> AtheeNa: dictionary was because we didn't realize you wanted to do it in a program... for you to look the word up in yourself
11:54:33 <Deewiant> i.e. keep a mapping of words to words "cats" -> "cat", "glasses" -> "glass"
11:55:10 <EvilTerran> SamB, i was thinking of a computer-readable dictionary for the program to use, actually...
11:55:26 <SamB> oh really?
11:55:27 <monochrom> dictionary and computer play well together.
11:55:30 <SamB> any examples?
11:55:47 <monochrom> /usr/share/dict
11:55:56 <EvilTerran> as i mentioned above, princeton wordnet may have that information in it
11:55:58 <SamB> monochrom: that doesn't have word formation info does it?
11:56:01 <SamB> EvilTerran: oh.
11:56:03 <SamB> sorry!
11:56:06 * SamB got confused
11:56:06 <monochrom> dict.org at port 2628 or something
11:56:19 <SamB> I mean, in machine readable form
11:56:42 * monochrom resists to harp on "humans are machines too" :)
11:56:44 <SamB> actually I think my /usr/share/dict has nothing but the Devil's Dictionary
11:56:57 <shachaf> monochrom: No you didn't.
11:57:10 <SamB> shachaf: mention /= harp on
11:57:24 <monochrom> Haha, people argue on what I mean. :)
11:57:50 <Otoom> Here is to the haskell beginners: http://i28.tinypic.com/2dw4xa9.jpg
11:57:55 <Otoom> It is a userbar i made.
11:58:05 <Otoom> It does have a slight border.
11:58:18 <Otoom> Enjoy.
11:58:22 <EvilTerran> ... indeed, wordnet seems to have info on pluralisation
11:58:23 <dons> Otoom: heh cool
11:58:48 <ehird> Otoom: the idea of that is.. really tacky
11:58:48 <Otoom> No problem.
11:58:53 <Otoom> And how?
11:58:55 <Twey> Heh
11:58:58 <ehird> userbars are silly :/
11:59:12 <Otoom> For you they may be.
11:59:18 <monochrom> What is a userbar?
11:59:21 <ehird> 'HEY GUYS! I USE THIS BAND OF TOILETROLL! And I'll let you know through gradients and Silkscreen.'
11:59:35 <Otoom> Holy crap.
11:59:35 <ehird> Otoom: Also, the text on yours is compltely unreadable.
11:59:44 <Otoom> No it isnt, You need glasses.
11:59:44 <SamB> couldn't we just put a "powered by haskell" logo on our homepages?
11:59:47 <Otoom> I see it perfrectly.
11:59:56 <mauke> not enough contrast
12:00:04 <ehird> Otoom: Suprise -- not everyone has the contrast at ridiculous levels
12:00:15 <ehird> SamB: Even that's pretty cheesy, but less so than userbars
12:00:18 <Otoom> Nor do i.
12:00:22 <Otoom> Ill change it then.
12:00:23 <ehird> Which are more commonly found in the horror known as 'forum signatures'
12:00:26 <ehird> Or 'blog sidebars'
12:00:44 <monochrom> Please don't pick on Otoom's ridiculously designer-wannabe choice of colours.
12:00:52 <glguy> What is a "user bar"?
12:01:02 <Otoom> Designer wanna be?
12:01:04 <SamB> ehird: well, the latter aren't a horror necessarily
12:01:13 <Otoom> Ill have you know i have done some cool shit, and been paid for it.
12:01:29 <dons> Otoom: thanks, I apologies for the strange negativity in here.
12:01:36 <glguy> yeah, wtf guys?
12:01:45 <EvilTerran> do watch your language, tho
12:01:46 <dons> http://haskell.org/haskellwiki/IRC_channel
12:01:47 <lambdabot> Title: IRC channel - HaskellWiki
12:01:56 <dons> To maintain the friendly, open culture, the following is required:
12:01:57 <dons> * Low to zero tolerance for ridiculing questions. Insulting new users is unacceptable
12:02:04 <ehird> i didn't insult anyone
12:02:10 <ehird> i merely questioned the idea of userbars
12:02:33 <glguy> What is a userbar?
12:02:38 <dons> no need to rehash, just keep in mind the shapr ideology of ubiquitous friendliness
12:03:10 <dons> ehird: you were very rude, fwiw.
12:04:01 <monochrom> Eh? I thought mine was the most outrageous. :)
12:04:08 <dons> monochrom is always very rude
12:04:15 <Otoom> http://i27.tinypic.com/2enq3ck.jpg
12:04:25 <Otoom> Maybe the writing is slighlty easier the read on that one
12:04:35 <shachaf> glguy: "Userbars are small rectangular images that are designed to be put in an Internet forum signature block." -- I hadn't come across the term before either.
12:04:41 <Heffalump> Otoom: what is it?
12:04:49 <Otoom> Here a sig i made.
12:04:49 <Otoom> http://i26.tinypic.com/2vuy7bo.jpg
12:04:58 <Heffalump> eww, forums :-)
12:05:01 <Otoom> brb
12:05:02 <resiak> Otoom: i can't help thinking that having the text in the same green as the circle to the left would be more readable
12:05:38 <Heffalump> I guess if it's just a signature readability doesn't matter too much.
12:05:40 * EvilTerran looks at the conversation and thinks <<loop>>
12:05:59 <shachaf> Perhaps some of this should be in #-blah?
12:06:22 <monochrom> But if it mentions Haskell, we do care what other people think of it when they see it.
12:06:55 <dons> any haskell appearences in new forums is good
12:07:03 <dons> helps us to be less insular
12:07:04 <glguy> if it's a personal signature, we shouldn't care what people think
12:07:09 <glguy> it's not representative of the whole
12:07:49 <glguy> anyone that makes a judgment about a programming language because of a user's signature...
12:07:53 <dons> heh
12:07:54 <glguy> :-D
12:07:59 <Heffalump> :-)
12:08:04 <glguy> That person can go be a Ruby programmer!
12:08:04 <monochrom> is a real world person.
12:08:09 <dons> btw, xmonad 0.7 is out
12:08:10 <dons> woot woot
12:08:21 <Heffalump> it's a 1000 lines though :-)
12:08:29 <mauke> dons: you misspelled my name again! :-D
12:08:30 <monochrom> Sorry, I disbelieve in tiling window managers.
12:08:34 <EvilTerran> glguy, have you *seen* some of the sig images ruby programmers use? they're *awful*!
12:08:34 <Heffalump> I'm sure that counts as a negative milestone somehow.
12:08:42 <dons> heh
12:08:48 <olsner> old news! xmonad's been on reddit all day ;-)
12:08:53 <dons> monochrom: there existence is irrefutable
12:08:57 <ddarius> Cut it back down to ~100 and maybe I'll upgrade
12:09:07 <glguy> EvilTerran: I don't frequent many forums beyond Reddit :-)
12:09:08 <dons> though the mailing list is still backed up
12:09:10 <Heffalump> olsner: dons might only just have got up
12:09:30 <dons> http://article.gmane.org/gmane.comp.lang.haskell.cafe/38167
12:09:31 <Heffalump> how many lines is it without comments?
12:09:31 <lambdabot> Title: Gmane -- Mail To News And Back Again
12:09:46 <Deewiant> Heffalump: except that dons was the one who posted the Reddit article :-P
12:09:47 <kaol> one day I'll have to see if I could make xmonad work like my fvwm
12:09:50 <dons> Heffalump: oh, its about 1k loc, 1k comments. and 8k code/comments in the extension lib
12:10:00 <ddarius> kaol: You can.
12:10:03 <Heffalump> oh, right
12:10:29 <Heffalump> proof that feature creep happens to the best of WMs
12:10:48 <dons> hah
12:10:56 <dons> we just removed some more features from the core
12:11:05 <dons> so the core is likely to stabilise around 1k i think
12:11:13 <shachaf> dons: But you're going to add avoidStruts into it, no?
12:11:16 <dons> while you'll just see more and more options in the extension lib
12:11:20 <dons> shachaf: extension lib
12:11:31 <dons> well, we'll see. that's a debate to have
12:11:39 <dons> auto struts would be nice in the core :)
12:11:50 <dons> (its hard to imagine someone not wanting it)
12:12:01 <ddarius> What would that do?
12:12:12 <dons> oh, just handle all the dock and menu apps.
12:12:20 <ddarius> Oh.  I don't want it.
12:12:21 <dons> reserving space. this is done in an extension currently
12:12:31 <dons> well, you don't use them, so that's fine
12:12:35 <dons> but if you did, they should work
12:12:43 <dons> and more people use them than not, it seems
12:16:51 <Heffalump> what's a strut?
12:17:07 <dons> little boxes that dock apps and menu bars live in
12:17:10 * SamB asks GHC for 200 characters of cost center stack...
12:17:26 <Heffalump> SamB: you mean the text that appears in heap profiles?
12:17:31 <Heffalump> if so, how do you do that?
12:17:33 <dons> there's a bug you could fix
12:17:40 <Heffalump> dons: how do those differ from normal windows?
12:17:55 <SamB> Heffalump: well, ./target +RTS --help gives usage information
12:18:09 <SamB> -L200 appears to be the way I do that
12:18:37 <Heffalump> what GHC version?
12:19:15 <SamB>  ,("GHC version", "6.8.2")
12:19:54 <SamB>  ,("RTS way", "rts_p")
12:20:17 <Heffalump> SamB: ooh, thanks. I never noticed that before
12:20:25 <Heffalump> must be new in 6.8 since a 6.6 binary doesn't have it.
12:20:25 <SamB> the --help thing?
12:20:29 <SamB> or the -L?
12:20:31 <Igloo> It's new in 6.8.something
12:20:36 <SamB> I never looked for -L before
12:20:40 <SamB> that I can recall
12:20:45 <Heffalump> the -L
12:20:45 <Igloo> Ravi made it
12:21:00 <SamB> quite handy when using the heap profiler for debugging, though
12:21:07 <Heffalump> *very* handy!
12:21:13 <Heffalump> I've been cursing the lack of such an option for months.
12:22:22 <SamB> now I know the exact call chain responsible for this rogue MetaVar
12:28:04 <jeffwheeler> I'm following the Haskell wikibook, but I can't figure out one of the solutions. I came to the same solution as is posted here: http://en.wikibooks.org/wiki/Haskell/Solutions/Understanding_monads, but it seems to always generate the same first two numbers.
12:28:06 <lambdabot> http://tinyurl.com/2pw54r
12:29:31 <TheLorax> just starting out with haskell, I keep getting this "No instance for (Show ([a] -> a))"
12:29:36 <TheLorax> not sure what it means
12:29:49 <hpaste>  jeffwheeler pasted "Random list generator" at http://hpaste.org/6738
12:29:52 <shachaf> TheLorax: You're trying to print a function.
12:30:03 <shachaf> TheLorax: Try applying it to an argument (a list).
12:30:26 <TheLorax> shachaf, I wanted to declare a function x, like so \x -> x + 1
12:30:39 <shachaf> TheLorax: let f = \x -> x + 1, perhaps?
12:30:42 <jeffwheeler> There's my version of the same solution, which is slightly prettier, but still produces the same problem.
12:30:44 <shachaf> TheLorax: If you're using ghci.
12:31:01 <TheLorax> shachaf yes, ghci
12:31:03 <shachaf> TheLorax: (Or let f x = x + 1, to avoid the monomorphism restriction.)
12:31:44 <TheLorax> shachaf, yeah that reminds me. when I do that I get "prase error on input `='"
12:31:50 <shachaf> TheLorax: Are you using let?
12:32:10 <shachaf> TheLorax: In ghci (which is sort of like do-notation), you have to use let to bind variables.
12:32:28 <TheLorax> shachaf, ah ok. thanks
12:33:38 <TheLorax> when should I use brakets for functions? I can f 5, but not f f 5, but f (f(5)) is ok...
12:33:49 <mauke> never
12:33:53 <Heffalump> f (f 5) is the minimal bracketing
12:33:59 <Heffalump> you can also use f $ f 5
12:34:06 <mauke> you should put brackets around expressions, not "for functions"
12:34:18 <Heffalump> function application has highest precedence and associates to the left
12:34:26 <Heffalump> so f f 5 = (f f) 5
12:34:43 <TheLorax> ok
12:34:48 <TheLorax> thanks
12:35:32 <Jedai> ($) is an useful operator to avoid lisp-like parenthese hell
12:35:49 <Dybber> I read about some blog software written in Haskell for some weeks - maybe a month - ago with a funny name, but I can't it anymore, does anyone know what I'm talking about? I think the name was something like "perpub..."
12:36:02 <mauke> http://mauke.ath.cx/stuff/lisp/implinest.lisp
12:36:45 <Jedai> TheLorax: it associates to the right and have a very weak priority
12:37:01 <DRMacIver> Dybber: perpubplat
12:37:20 <TheLorax> Jedai, I'll keep that in mind. but the fewer symbols for now the better :)
12:37:53 <Dybber> DRMacIver: that's it, thanks
12:38:11 <DRMacIver> No problem
12:38:36 <ehird> mauke: is that meant to be ugly lisp
12:38:43 <ehird> parens on lines of their own, aaag
12:39:01 <mauke> ehird: just use lisp for a week. you'll see, the parens become practically invisible
12:39:09 <mauke> just follow the beautiful indentation
12:39:24 <gweiqi> is there a very easy way to compile a haskell binary which also dynamically reads from a config file also written in haskell at runtime?  sort of mixing both worlds
12:39:29 <ehird> mauke: i assume you're being sarcastic and know that good-looking lisp looks nothign like that
12:39:34 <vegai> if parens are invisible, what is $
12:39:49 <mauke> "good-looking lisp"? you must be joking, good sir
12:40:14 <ehird> I think mauke is either extremely troll-like regarding Lisp and has never looked at a real lisp program, or all the programs in that lisp directory are jokes
12:40:33 <ehird> http://mauke.ath.cx/stuff/lisp/add.lisp NOBODY writes parentheses like this (let's ignore the obviously intentional program structure)
12:40:55 <mauke> the add* things are just variations of the same program, written in different styles
12:41:14 <mauke> I think add-2.lisp is the "canonical" style
12:41:24 <monochrom> gweiqi: possible, but not very easy.  One way involves calling up ghc as a library.  haddock 2.0.0.0 does that, for example.
12:41:31 <ehird> mauke: parentheses should never be on a line of their own
12:41:38 <mauke> ehird: why not?
12:41:43 <ehird> mauke: because it's fugly
12:41:44 <gweiqi> monochrom: is there a standard way to do that?
12:41:46 <ehird> and unreadable
12:41:51 <mauke> ehird: so is )))))))))))))))))))))))
12:42:20 <mrd> ehird: he's trolling
12:42:34 <monochrom> I don't know what "standard" means.  Very few people do it now, at any rate.
12:42:53 <DRMacIver> gweiqi: Depends what you need to do. The approach xmonad takes is that the "application" becomes a library and the configuration code calls the library. When changing the configuration the application is restarted, serializing its state and passing it to the new instance.
12:43:15 <DRMacIver> This is pretty simple but doesn't work for a large class of potential use cases. :)
12:43:21 <gweiqi> hmm
12:43:24 * ptolomy is busy
12:43:31 <mauke> re: the program structure, it was originally written in perl: http://mauke.ath.cx/stuff/perl/add.pl
12:43:46 <mauke> the point of implinest.lisp is to show how to define a $-like operator for lisp's syntax
12:44:03 <ehird> mrd: good :p
12:44:38 <gweiqi> DRMacIver: it sounds like a good thing for me to try... so the majority of the application is first compiled into library form? (not entirely sure what this would be or how that's done)
12:44:56 <mauke> mrd: I'm just sick of lispers telling me to "just use lisp for a week, you won't even see the )))))) anymore"
12:45:36 <SamB> mauke: I could sell you a used .el file that would deliver on this claim
12:45:46 <Twey> Hah
12:45:49 <monochrom> just use haskell for a week. you won't see the brain explosions anymore.
12:45:51 <DRMacIver> gweiqi: Yep. XMonad is conceptually a library for building window manager in Haskell, and is compiled as such, not a window manager itself. It just happens to be a very easy library to get started with. :)
12:46:05 <SamB> it uses shading instead of parens
12:46:34 <mauke> if parens are so invisible, why complain about where you put them?
12:46:53 <SamB> well, because of the ugly shading that results ;-)
12:47:02 <DRMacIver> Because newlines aren't invisible? :)
12:47:02 <mauke> (the indentation and code structure is perfectly fine otherwise)
12:47:15 <SamB> mauke: besides, most lispers aren't talking about that .el file when they make the claim
12:47:36 <SamB> and... I don't actually use that .el file ever
12:48:01 <gweiqi> DRMacIver: what exactly is the library form of haskell code, and how do i make ghc spit that out?
12:48:29 <SamB> gweiqi: something called "cabal" makes GHC do that
12:49:26 <DRMacIver> gweiqi: Um. Pass. :) I'll let someone else explain that, as I'm not super clear on how packaging works in Haskell.
12:52:01 <gweiqi> SamB: so it's not the .hi or .o files?  It's another kind?
12:52:23 <SamB> gweiqi: well, it's more than that
12:52:53 <SamB> before cabal, it was a pain to create installable packages
12:53:14 <gweiqi> so what extra thing does it do?
12:54:18 <SamB> well, it passes some magig flags to GHC, generates a package configuration file, and actually makes all the stuff get installed...
12:54:29 <SamB> *magic
12:55:19 <gweiqi> and the difference with installing plain source is that it's much faster to compile against these packages?
12:55:25 <Cale> gweiqi: Well, there are some .o, .a and .hi files which go into the ghc-<version>/lib directory, and then there is a package.conf file which contains information about the installed packages which needs updating
12:55:31 <SamB> you can't just install the source for GHC
12:55:32 <Cale> I'm not sure if there's anything more than that.
12:56:04 <SamB> did I also mention that cabal supports installing packages for hugs at negligable extra cost (besides the need to write hugs-compatible code)
12:56:14 <gweiqi> cool
12:56:22 <SamB> at least, it is supposed to
12:56:31 <SamB> haven't actually *tried* it
12:57:00 <SamB> and there is a program cabal-get which can install packages from hackage
12:57:14 <SamB> of course, just to be confusing, the executable is named cabal
12:57:33 <DRMacIver> cabal install rather than cabal get
12:58:03 <SamB> oh. was that the name of the program?
12:58:22 <SamB> cabal-get install would have made perfect sense to me...
12:58:44 <dbpatterson> SamB: too much debian for you :)
12:58:45 <DRMacIver> The program itself is called cabal. But the package name and name its usually called by is cabal-install
12:58:53 <MarcWeber> :) @ SamB
12:58:58 <SamB> drbean: I did say it was confusing
12:59:06 <Heffalump> hopefully at some point it'll all end up in one application, though
12:59:08 <SamB> er.
12:59:10 <SamB> DRMacIver:
12:59:53 <SamB> well, for the gentoo users, we could also have a binary called cabbage
13:00:17 <Heffalump> lol
13:07:56 <TheLorax> is there any difference between the way I have to type commands in ghci and feeding files into ghc?
13:08:07 <Cale> yes
13:08:16 <Cale> ghci largely wants expressions
13:08:29 <Cale> (which it evaluates for you and prints out the results)
13:08:43 <TheLorax> "filter even [1,2,3,4,5,6,7] works in the iterpeter, but not from a file.
13:08:49 <Cale> In .hs files is where you actually write your program, which will consist of declarations
13:09:07 <Cale> So if you want a compiled program which prints the result of that expression, you'll need to write:
13:09:15 <Cale> main = print (filter even [1,2,3,4,5,6,7])
13:09:50 <Cale> (the main IO-action is what gets evaluated and then executed in a compiled Haskell program)
13:10:09 <Cale> :t print
13:10:10 <lambdabot> forall a. (Show a) => a -> IO ()
13:10:22 <TheLorax> so main is like main in C?
13:10:25 <Cale> yeah
13:10:32 <Cale> print takes any showable value and produces an action for printing it on the screen
13:10:39 <TheLorax> ah
13:10:45 <TheLorax> ok, thanks
13:11:10 <glen_quagmire> runStateT  how can I explain meaning of these run functions for monad transformers?
13:11:17 <Cale> If you want to know how to chain larger IO actions together, I have a short tutorial about that.
13:11:19 <glen_quagmire> are they unwrapping the monad?
13:11:52 <SamB> unwrapping the computation
13:12:00 <SamB> well, in some cases
13:12:03 <TheLorax> Cale, sure. I'll give it a read
13:12:12 <TheLorax> Cale, what's the link ?
13:12:17 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
13:12:17 <lambdabot> Title: Introduction to IO - HaskellWiki
13:12:19 <SamB> I suppose the run ones generally are
13:12:26 <TheLorax> Cale, thanks
13:13:23 <glen_quagmire> i start with IO monad and wrap it up using transformers.  i just use liftIO to use IO commands. I am not sure about meaning of "lifting"
13:13:42 <Cale> glen_quagmire: liftIO turns IO actions into actions in your transformed monad
13:13:50 <glen_quagmire> i mean, lifting sounds like peeling a layer of transformers
13:14:07 <Cale> You can imagine your transformed monad as "above" the IO monad
13:14:15 <glen_quagmire> Cale, oh yah. type signature definitely says that
13:14:20 <Cale> and lifting carries computations from the IO monad up to the new one
13:14:38 <glen_quagmire> ha! excellent
13:16:18 <Cale> lift just lifts things by one level between the different monads along the way, and liftIO lifts things all the way from IO up to wherever you might be.
13:16:53 <Cale> (which in the case that you have 3 monad transformers, allows you to hide that fact, and write liftIO instead of lift . lift . lift
13:16:55 <Cale> )
13:17:57 <Cale> In a real application where you want things to stay maintainable, I highly recommend wrapping the stack of transformers in a newtype and using GHC's newtype-deriving extension to derive instances of Functor and Monad (and maybe some others too)
13:17:58 <glen_quagmire> main function is IO monad. i run my monad using runStateT ...etc.  core of my monad is IO.
13:18:08 <Otoom> How did did it take some people to learn Haskell?
13:18:14 <glen_quagmire> is it a sandwich?  main  |  mymonads ... | IO
13:18:19 <Otoom> As i have learned C++ before hand.
13:18:31 <SamB> Otoom: that won't be much help!
13:18:43 <Peaker> Cale, what is Functor useful for in this case?
13:18:49 <Cale> Otoom: It took me about 2 months to get to the point where I could say "yeah, I can use this for real problems", and about a year before I was comfortable.
13:18:50 <shachaf> Peaker: fmap. :-)
13:19:03 <glen_quagmire> <$>
13:19:08 <Peaker> shachaf, yeah, I mean why does a stack of transformers want to support fmap?
13:19:29 <shachaf> Peaker: For the same reason any monad would want to support fmap.
13:19:45 <glen_quagmire> liftIO $ putStrLn $ show <$> doThingsInMonad
13:19:45 <Peaker> shachaf, I am new :-) Why is that? I haven't seen that yet
13:19:56 <Otoom> well, i like doing things on ProjectEuler.net
13:19:57 <Cale> Otoom: This was at a time when I could pick up Ruby in about a week. It's not that Haskell is harder, it's just very different, so you have to learn to think in a different way about the problem of writing programs.
13:20:02 <shachaf> Peaker: fmap is like map, generalized to any Functor (or Monad).
13:20:08 <shachaf> > fmap (+1) [1,2,3]
13:20:08 <lambdabot>  [2,3,4]
13:20:11 <shachaf> > fmap (+1) (Just 4)
13:20:11 <lambdabot>  Just 5
13:20:15 <glen_quagmire> main function is IO. my monad has IO in the core. I run my monad in main. head hurts
13:20:15 <shachaf> > fmap (+1) Nothing
13:20:16 <lambdabot>  Nothing
13:20:16 <Cale> Otoom: If you're mathematically minded, you probably will like Haskell :)
13:20:31 <Otoom> Good.
13:20:36 <Peaker> shachaf, Yeah I know - but what would fmap do on an IO monad, just bind it to a lifted (a->b) mapper?
13:20:44 <Peaker> @src IO fmap
13:20:44 <Cale> glen_quagmire: Okay, so you have something like the StateT MyState IO monad
13:20:44 <lambdabot> fmap f x = x >>= (return . f)
13:20:45 <Otoom> What was the best / easiest tutorial you read?
13:20:55 <Peaker> yep, it seems so :)
13:20:59 <shachaf> Peaker: If you have an IO a, and an (a -> b), and you want an IO b, you'd use fmap. :-)
13:21:04 <Cale> Otoom: The standard recommendations these days are YAHT and the wikibook
13:21:08 <Cale> @where yaht
13:21:08 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
13:21:11 <Cale> @where wikibook
13:21:11 <lambdabot> http://en.wikibooks.org/wiki/Haskell
13:21:12 <shachaf> Rather than do { x <- m; return (f x) }
13:21:21 <Otoom> YAHT/?
13:21:34 <Cale> "Yet another Haskell tutorial"
13:21:37 <shachaf> There's also the RWH /.
13:21:40 <Cale> I just gave a link to it there :)
13:21:40 <ahunter> I really liked Gentle Introduction
13:22:07 <Peaker> shachaf, I see now - fmap f monad  seems equivalent to (liftM f) monad, isn't it?
13:22:19 <mauke> liftM == fmap
13:22:27 <shachaf> Peaker: Yes, fmap = liftM for real Monads.
13:22:27 <Cale> Otoom: Those two should do well up until you get to monads and/or IO, at which point I'd recommend asking again -- there are better tutorials geared specifically to that.
13:22:32 <Peaker> oh
13:22:44 <Peaker> so I understand :)
13:22:50 <idnar> Peaker: (liftM f) monad is equivalent to liftM f monad ;)
13:23:08 <Cale> Peaker: sorry about ignoring your question for a moment there -- I see others have answered it :)
13:23:25 <Peaker> So why does instantiating Monad not auto-instantiate/derive Functor always?
13:23:30 <Peaker> Cale, no problem :)
13:23:44 <Cale> Peaker: also, be careful, 'monad' refers to the type constructor, not the individual actions.
13:23:54 <idnar> Monad should subclass Functor
13:24:09 <Cale> Peaker: It's because there's a subclass constraint missing in the Haskell 98 spec.
13:24:14 <Otoom> thank you.
13:24:18 <Otoom> Cale:
13:24:20 <shachaf> Applicative, actually. :-)
13:24:31 <Peaker> Cale, oh - so Monad should be subclassing Functor as idnar  says?
13:24:36 <Cale> Otoom: also, feel free to ask questions here as you learn
13:24:40 <idnar> Peaker: well, probably what shachaf said
13:24:41 <SamB> Cale: also, implementing sublcasses doesn't cause superclasses to be implemented
13:24:54 <Cale> SamB: right, but you can always just write:
13:24:56 <Peaker> also, why do we need liftM rather than just fmap?
13:25:00 <Cale> instance Functor M where
13:25:03 <Cale>    fmap = liftM
13:25:10 <shachaf> Peaker: Using fmap would introduce a Functor constraint.
13:25:11 <SamB> true enough
13:25:22 <shachaf> So you'd have to write (Functor m, Monad m) => ... if you used both.
13:25:23 <Cale> (even with that constraint!)
13:25:31 <Peaker> shachaf, yeah, but I could have Monad subclass Functor
13:25:37 <shachaf> Peaker: It should.
13:25:43 <shachaf> Peaker: It just doesn't. :-)
13:25:45 <Cale> Peaker: right, in that case, liftM wouldn't be so necessary
13:25:52 <Peaker> shachaf, backwards compatibility troubles already? :-)
13:25:56 <Cale> Peaker: except as an easy way to implement fmap
13:26:02 <shachaf> Peaker: "already"?
13:26:04 <SamB> I don't see why we don't just make it happen
13:26:17 <Peaker> shachaf, well, its new as far as languages go
13:26:23 <Cale> SamB: There are too many people who complain about small changes like this :)
13:26:27 <shachaf> Peaker: Haskell?
13:26:28 <SamB> since anything that would break is considered quite bad style
13:26:33 <Peaker> shachaf, its use of Monads, isn't it?
13:26:37 <Cale> SamB: dons is already upset with me for changing the things in lambdabot :)
13:26:40 <SamB> and it might find some bugs
13:26:41 <shachaf> Peaker: Well, maybe.
13:26:48 <SamB> Cale: that's different
13:26:49 <glen_quagmire> run :: MyMonad a -> IO (Either Err a, MyState) .. can I say run function takes computations defined in MyMonad and runs them in IO monad by unwrapping MyMonad, which has IO in the core?
13:26:49 <Peaker> how about a "from __future__" here?
13:27:04 <Peaker> import Future(MonadFunctor)
13:27:04 <shachaf> Peaker: Haskell 98 is from 10 years ago, and it's been using monads for some time before that.
13:27:09 <Cale> glen_quagmire: roughly, yes
13:27:10 <SamB> those things can and will break good code
13:27:24 <Peaker> or "-fglasgow-monads"
13:27:26 <glen_quagmire> Cale, thank you
13:27:38 <Cale> glen_quagmire: It takes MyMonad computations and runs them in the IO monad.
13:27:43 <SamB> this change would ONLY break code where Monad was implemented but Functor was not
13:27:52 <SamB> which is not kosher
13:28:04 <Japsu> module __future__ where class MonadFail a = ...
13:28:15 <SamB> why, the other year I noticed that TH's Q monad wasn't a Functor...
13:28:22 <idnar> heh, python style
13:28:23 <glen_quagmire> so, there's no unwrapping. only lift is possible.
13:28:24 <Cale> glen_quagmire: How it does this isn't really so important, but yeah, usually it just deconstructs the value, because the representation is straightforward that way.
13:28:43 <Cale> You have implementations like:
13:28:51 <SamB> Japsu: that would almost work... if _ was a capital letter!
13:28:57 <Peaker> with a warning-release, backwards compatibility in new language releases is not so bad
13:29:03 <Peaker> especially stdlib changes
13:29:04 <Cale> newtype StateT s m a = StateT { runStateT :: s -> m (a,s) }
13:29:35 <TheLorax> Cale, so I chaining functions in main, but what about defining then using those functions in main?
13:29:41 <TheLorax> so I understand***
13:29:45 <SamB> Peaker: how do you deprecate not writing an instance of Functor for every instance of Monad?
13:30:01 <Cale> TheLorax: IO actions are values just like any others, so you can make definitions:
13:30:10 <Cale> echo = getLine >>= putStrLn
13:30:11 <Peaker> SamB, if it can find an instance of one but not an instance of the other?
13:30:15 <Cale> main = echo >> echo
13:30:24 <Peaker> SamB, Or do many people separate those into modules they don't necessarily import?
13:30:24 <SamB> Peaker: you want to do this in the COMPILER?
13:30:48 <Peaker> SamB, perhaps with the aid of the compiler
13:31:11 <Peaker> SamB, I am not sure about the best technical way to do it
13:31:12 <SamB> well, can you think of a general way to implement that sort of warning?
13:31:25 <SamB> are there a lot of classes missing superclasses?
13:31:27 <Cale> I say we should just break the world every once in a while and have people fix things. We should believe more strongly in the changes we'd like to introduce. :)
13:31:38 <SamB> Cale: that's what I'm saying
13:31:41 <TheLorax> Cale, so no "let" from inside files?
13:31:56 <Peaker> I am all for breaking the world when required.. but if a warning release is possible, its even better
13:32:02 <SamB> the really nice thing about this is that theres nothing to stop you writing code that works for pre-broken-world compilers
13:32:02 <Cale> TheLorax: right -- well, not at the top-level anyway
13:32:08 <Cale> TheLorax: you could also write:
13:32:15 <shachaf> TheLorax: ghci is sort of like do-notation inside a file.
13:32:19 <Cale> main = let echo = getLine >>= putStrLn
13:32:21 <SamB> if you just make Monad a subclass of Functor
13:32:28 <Cale>        in echo >> echo
13:32:35 <Cale> Or:
13:32:50 <Cale> main = do let echo = getLine >>= putStrLn
13:32:58 <Cale>           echo
13:32:59 <Cale>           echo
13:33:06 <TheLorax> Cale, just like SML!
13:33:18 <Cale> Yeah, we have let expressions too :)
13:33:25 <Cale> We also have 'where'
13:33:30 <Cale> main = echo >> echo
13:33:36 <Cale>   where echo = getLine >>= putStrLn
13:34:03 <Cale> Which, as opposed to being part of expression syntax, is part of the syntax of declarations, and it scopes over guards (once you know what those are)
13:34:14 <Peaker> too many syntaxes for the same thing :)
13:35:03 <Cale> It's good, they tend to help the author of a module express things in a way which makes the most sense for reading.
13:35:34 <Cale> Sometimes the big picture is the most important thing and the details are less important, in which case 'where' tends to read nicely.
13:36:07 <Cale> Sometimes the details are what really matters, and they're being put together in some trivial boring way in which case let is better :)
13:36:31 <lament> where can lead to lots of pain
13:36:39 <lament> much moreso than let
13:36:42 <Cale> oh?
13:36:48 <lament> i mean reading the code
13:36:55 <Cale> I don't know...
13:37:03 <ddarius> I've never had any where induced trouble reading code
13:37:09 <Peaker> Cale, I think having more syntax also makes things in general harder to parse, even in the common case where the extra syntaxes are not used
13:37:10 <Cale> If you give poor names to things perhaps...
13:37:13 <Jaak> i've always found where to be cleaner
13:37:23 <Peaker> Cale, it doesn't necessarily offset that disadvantage by making some corner cases easier to read
13:37:24 <Cale> Peaker: for humans or for machines?
13:37:32 <Peaker> Cale, I believe in correlation between the two
13:37:33 <Jaak> separates the local declarations from the main body nicely
13:37:39 <Cale> Peaker: I don't :)
13:37:49 <Peaker> Cale, ease of parsing by a human and by a machine is correlated, with some exceptions ofcourse
13:37:58 <Cale> Peaker: there are notations which are really really easy for humans to parse, but for machines are very difficult
13:38:20 <Peaker> Cale, example?
13:38:25 <mauke> for the opposite, see ))))))))))))))))))))))))
13:38:31 <Cale> mauke: hehehe
13:38:44 <Peaker> well, I said correlated, not identical :-)
13:38:52 <Peaker> A big grammar file is harder for a human as well as a computer
13:38:54 <mauke> for some reasons I find nested parentheses really hard to parse, even in C
13:39:15 <mauke> I use them only when needed
13:39:31 <Twey> Mm I like Lisp's syntax, it's very minimal.
13:39:47 <Cale> Things which require lots of nesting are easy for machines but not for humans. Things which require lots of context, but not necessarily much nesting are easier for humans, but harder for machines.
13:39:54 <Cale> (For example, mathematics.)
13:40:10 * Twey nods.
13:40:10 <Peaker> Cale, yeah, but some things that are harder for a human are also harder for a computer
13:40:13 <ddarius> (or natural language)
13:40:20 <Cale> Indeed
13:40:32 <Cale> Peaker: some, sure.
13:40:49 <mauke> the perl parser uses heuristics for some constructs to figure out what the programmer may have meant :-)
13:40:53 <lament> Cale: where is nesting. let is context.
13:40:53 <Peaker> Cale, disambiguating an expression from a lot of possible grammars, as opposed to few.  Having the ambiguity go deeper into the expression, instead of being resolved early
13:41:06 <ddarius> If there are lower bounds on the amount of computation required to parse something, it is not going to go away for human.s
13:41:06 <Cale> lament: No, it's the other way around :)
13:41:09 <yitz> dons: I just used google to go to the xmonad page, and i forgot to use "i'm feeling lucky". i see that xmonad is now a "distinguished page", with special links to "guided tour", "gnome with xmonad", etc.
13:41:09 <laura85> hi ^^
13:41:26 <Cale> laura85: hello :)
13:41:52 <dons> yitz: ah, that's what it's called.
13:41:54 <ddarius> yitz: xmonad.org is hard to remember?
13:41:57 <dons> yitz: do you know how that comes about?
13:42:06 <dons> since i wondered why we've now got this special menu status :)
13:42:07 <glen_quagmire> can I say that lifted IO actions, which are in above layers, are performed as run function peels layers?
13:42:08 <yitz> i don't know, that's what i call them
13:42:18 <dons> someone at google uses xmonad? :)
13:42:24 <mauke> glen_quagmire: unlikely
13:42:25 <yitz> but it's definitely special.
13:42:29 <mauke> glen_quagmire: pure code can't perform IO
13:42:50 <Peaker> Cale, The "Perl" way of syntax keeps a LOT of ambiguity floating around way deep into an expression
13:42:57 <shachaf> dons: Yes.
13:43:00 <yitz> could be that's it. anyway, they clearly consider it important enough to treat it manually.
13:43:02 <shachaf> dons: gaal does, at least.
13:43:15 <dons> mm. didn't know that.
13:43:22 <dons> so i wonder how these indices are created
13:43:23 <Cale> Well, they're both ways of introducing context, I'd say, but 'let' puts the context first, and 'where' puts it after.
13:43:24 <Peaker> Cale, You have to disambiguate expressions from a grammar forest instead of a grammar tree :-)
13:43:40 <Cale> Peaker: yeah
13:43:41 * shachaf was there when he installed it. :-)
13:45:18 <Cale> Sometimes it's nice to know the big picture first, before seeing the details.
13:45:42 <Cale> Sometimes the details don't even make very much sense without knowing that!
13:45:55 <glen_quagmire> hrm. so liftIO is just to make the types correct
13:46:31 <Cale> glen_quagmire: It adds structure
13:46:50 <Cale> glen_quagmire: It introduces all the extra structure required by the various monad transformers.
13:47:13 <Cale> But in some sense, that structure is provided in a way which is as simple as possible.
13:47:37 <Cale> For instance, if you lift an IO action up to StateT s IO, you won't get something which fiddles with the state.
13:48:04 <Cale> But you will get an action that passes the state along internally.
13:48:19 <Cale> In that case, you'd have something like
13:48:39 <Cale> liftIO x = StateT (\s -> do v <- x; return (s,v))
13:49:25 <Peaker> The nice thing about not having preprocessor macros in a language - is that transforming its syntax should be a piece of cake. One could have variants of Haskell where only the syntax differs probably easily
13:49:55 <TheLorax> what is the "|" in this list definition? "fib             = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]"
13:50:10 <Cale> Peaker: Indeed someone wrote a lispish frontend for GHC :)
13:50:16 <roconnor> There is already a typeset version of Haskell source for publications.
13:50:28 <Cale> TheLorax: Do you know in mathematics the set comprehension notation?
13:50:35 <TheLorax> Cale, no
13:50:44 <Cale> {x : x is an integer and x <= 10}
13:50:47 <Peaker> Cale, cool, and if its a 2-way convertor from normal .hs syntax, then you can share/edit the code with others who prefer a differing syntax
13:50:57 <Cale> Is the set of integers x which are less than or equal to 10
13:51:02 <Peaker> Cale, a revision-control convertor plugin could make syntax a presentation issue in that way
13:51:06 <Cale> In Haskell, we use a similar notation for lists
13:51:07 <roconnor> Peaker: that's exactly what I want in a new langauge!
13:51:16 <TheLorax> Cale, ok, yeah. I just didn't know that's what it was called.
13:51:29 <Cale> The | separates the term which is being constructed from the conditions and generators
13:51:31 <Peaker> roconnor, well, Subtext/etc take it further..
13:51:41 <Peaker> roconnor, and even names become a presentational thing
13:51:42 <ddarius> roconnor: Why do you need a new language?
13:51:54 <TheLorax> Cale, k, I think I get that. thanks
13:52:12 <Cale> So that reads as fib is the list which starts with 1 and 1 and is followed by the list of values a + b where (a,b) is taken from the list which results from zipping together fib with its tail.
13:52:13 <Otoom> how are for loops done in haskell?
13:52:28 <Cale> Otoom: They're done using lists.
13:52:29 <Peaker> Otoom, what kind of "for loop"?  there's map, mapM/forM_
13:52:39 <Otoom> like errr
13:52:45 <Otoom> have you been on projecteuler?
13:52:51 <Otoom> the first question on there.
13:52:58 <Otoom> go from 1...999
13:53:13 <Otoom> if cnt % 3==0
13:53:13 <Peaker> Otoom, A for-loop where the computation on each element is completely independent would use map - where one which is dependent will probably use mapM
13:53:30 <roconnor> ddarius: dependent types.
13:53:39 <ddarius> Otoom: The only way to loop in Haskell is via recursion.  There are, however, many combinators that capture patterns of recursion conveniently.
13:53:39 <Cale> > sum [n | n <- [1..1000], n `mod` 3 == 0 || n `mod` 5 == 0]
13:53:40 <lambdabot>  234168
13:53:43 <Otoom> Haskell confuses me :P
13:53:45 <Peaker> Otoom, one that just wants to bind together a bunch of monadic computations will use mapM_/forM_
13:53:46 <roconnor> Peaker: what is subtext?
13:54:15 <ddarius> http://subtext.org/
13:54:19 <Otoom> btw, whats another easy language to learn? that can compile to .exe
13:54:19 <lambdabot> Title: subtext.org
13:54:23 <Peaker> roconnor, www.subtextual.org - its an attempt to disconnect the program (the semantic model, graph of composed entities) from its serialization to a backend (syntax, text files).
13:54:26 <Cale> Otoom: You want to sum the list of values n from 1 up to 1000 for which n `mod` 3 is 0 or n `mod` 5 is 0. Right?
13:54:26 <conal> Otoom: also see foldr/foldl for dependent and functional (no IO)
13:54:54 <Cale> > sum [n | n <- [1..10], n `mod` 3 == 0 || n `mod` 5 == 0]
13:54:54 <lambdabot>  33
13:55:09 <roconnor> Peaker: awesome. ... bad website but awesome.
13:55:19 <Cale> oh, less than 10 ;)
13:55:24 <Otoom> Cale: yes
13:55:25 <Cale> > sum [n | n <- [1..9], n `mod` 3 == 0 || n `mod` 5 == 0]
13:55:26 <lambdabot>  23
13:55:31 <Cale> so up to 999
13:55:33 <roconnor> Peaker: oh, I scroll down
13:55:34 <Cale> > sum [n | n <- [1..999], n `mod` 3 == 0 || n `mod` 5 == 0]
13:55:35 <lambdabot>  233168
13:55:45 <Cale> and there's the solution to the problem :)
13:55:50 <Peaker> roconnor, then you can have multiple front-ends/GUIs that edit the same program, and many interesting features
13:56:07 <Otoom> Haskell is too hard for me guys.
13:56:29 <Cale> That Haskell code says "sum the values of the list whose elements n are drawn from the list [1..999], and are such that n `mod` 3 is 0 or n `mod` 5 is 0
13:56:35 <Peaker> Otoom, Heh, if you give up that easily, all languages will be too hard for you :)
13:56:47 <Otoom> Nope C++ i found easy.
13:56:48 <Otoom> PHp
13:56:49 <Otoom> Perl
13:56:53 <Otoom> But haskell is weird.
13:56:57 <shachaf> Otoom: That's good.
13:56:58 <Otoom> And all tuts are confusing.
13:57:01 <Peaker> Otoom, Haskell is definitely weird from a C++'ish standpoint
13:57:05 <Otoom> Im dislexic and i find it very hard.
13:57:13 <shachaf> Otoom: What's the point in learning an easy language?
13:57:17 <shachaf> Otoom: You don't learn much.
13:57:37 <Peaker> Otoom, I found getting into Haskell pretty hard because of A) bad distibution/dependency hell,  B) Confusing syntax.   C) new concepts.    But after a week A/B went away, and C became easier with a week or two of reading
13:57:42 <Otoom> If i found a decent none long tutorial i would read it.
13:57:50 <Otoom> Reading from a computer screen is also very hard.
13:58:03 <Peaker> Otoom, You can buy a book
13:58:16 <ddarius> Or a printer...
13:58:17 <Otoom> Thats money consuming :S
13:58:19 <Cale> Otoom: Graham Hutton's book is probably the one you want
13:58:23 <Otoom> Print about 132 pages off?
13:58:26 <Otoom> i dont think so :P
13:58:29 <Cale> @google Graham Hutton Haskell book
13:58:31 <lambdabot> http://www.cs.nott.ac.uk/~gmh/book.html
13:58:31 <lambdabot> Title: Programming in Haskell
13:58:34 <Peaker> Otoom, I prefer reading from screen than from a book
13:58:35 <shachaf> Yes, Hutton's book is good (if a bit short).
13:58:37 <Cale> yep, that one :)
13:58:50 <Otoom> Peaker: I have problems from reading from screen
13:58:53 <Otoom> distraction
13:58:56 <Otoom> bordem
13:58:59 <Otoom> whereas
13:59:09 <Otoom> with a book, i can sit down a read it in like a corner
13:59:12 <Otoom> away from everything
13:59:16 <Otoom> no distractions.
13:59:49 <Otoom> Ill buy a book
13:59:54 <Otoom> With my dads money :P
13:59:57 <dons> maybe buy a book?
13:59:59 <dons> there's lots
14:00:04 <ddarius> Otoom: Why do you want to learn Haskell anyway?
14:00:08 <Cale> dons: that's what he's saying :)
14:00:26 <Otoom> ddarius: its different and i like the sound of it, what it can do etc.
14:00:37 <Cale> Otoom: another way to solve the problem would be to use the function 'filter'
14:00:56 <Otoom> hay?
14:01:05 <Cale> Otoom: filter takes a predicate (which is a function that produces Boolean values), and a list
14:01:10 <roconnor> Cale, remember, we are supposed to say that Haskell is a program specification language; don't tell new users the code is executable until they are ready. ;)
14:01:20 <Cale> and it produces a list of elements of that list which make that predicate true
14:01:29 <Cale> For example...
14:01:39 <ehird> haskell can't do anything more than other languages
14:01:42 <ehird> its not super turing
14:01:43 <ehird> :)
14:01:45 <Cale> > filter even [2,6,1,2,4,1,7,32,14,15]
14:01:46 <lambdabot>  [2,6,2,4,32,14]
14:01:51 <Otoom> > sum problem1 = sum (filter multiples [1..999])
14:01:51 <Otoom> multiples n | rem n 5 == 0 = True
14:01:51 <Otoom>                   | rem n 3 == 0 = True
14:01:51 <Otoom>                   | otherwise      = False
14:01:51 <lambdabot>  Parse error at "=" (column 14)
14:01:54 <Otoom> hmm
14:01:59 <Cale> So here, filter has picked out just the even elements of the list.
14:01:59 <Otoom> not  mine :p
14:02:12 <Jaak> @paste
14:02:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
14:02:13 <Cale> yeah
14:02:20 <Jaak> use that, thanks
14:02:46 <cjb> or http://codepad.org/, which runs it too
14:03:19 <dbpatterson> I'm getting an error building HDBC-sqlite3, ghc 6.8.2.20080221, debian unstable - pasted error
14:03:21 <hpaste>  dbpatterson pasted "HDBC sqlite error" at http://hpaste.org/6740
14:04:03 <ehird> Otoom: > = only one line
14:04:30 <ehird> > sum problem1 = sum (filter multiples [1..999]) where multiples n | rem n 5 == 0 = True | rem n 3 == 0 = True | otherwise = False
14:04:30 <lambdabot>  Parse error at "=" (column 14)
14:04:34 <ehird> oh
14:04:35 <ehird> of course
14:04:38 <Otoom> ^^
14:04:45 <ehird> wait..
14:04:48 <ehird> 'sum problem1'?
14:04:49 <ehird> wtfff
14:04:52 <shachaf> Only one expression.
14:05:05 <shachaf> Otoom: @run evaluates expressions.
14:05:21 <Otoom> Cale: how would i compile this
14:05:22 <Otoom> sum [n | n <- [1..999], n `mod` 3 == 0 || n `mod` 5 == 0]
14:05:27 <shachaf> ("sum problem1 = sum ..." doesn't make much sense anyway...)
14:05:28 <Otoom> > sum sum [n | n <- [1..999], n `mod` 3 == 0 || n `mod` 5 == 0]
14:05:29 <lambdabot>  Couldn't match expected type `[a]'
14:05:33 <opqdonut> does ghc compile specialized versions of polymorphic functions?
14:05:44 <Otoom> > sum sum [n | n <- [1..999], n `mod` 3 == 0 || n `mod` 5 == 0]
14:05:45 <lambdabot>  Couldn't match expected type `[a]'
14:05:49 <dons> opqdonut: yeah
14:06:00 <opqdonut> does the manual have something on this?
14:06:00 <Cale> Otoom: For compiling, you'd write   main = print (sum [n | n <- [1..999], n `mod` 3 == 0 || n `mod` 5 == 0])   into, say, Problem1.hs
14:06:14 <Otoom> thank you.
14:06:18 <Cale> Otoom: Then you'd run   ghc -o Problem1 Problem1.hs
14:06:21 <Otoom> nah
14:06:23 <Otoom> ide
14:06:30 <Otoom> ghc --make problem1.hs
14:06:31 <Cale> Otoom: You could also use ghci
14:06:32 <Otoom> :)
14:06:38 <Cale> That also works :)
14:06:49 <Cale> In ghci, you could just type the expression:
14:06:51 <opqdonut> dons: would JIT-compiling specialisations be useful?
14:06:51 <Otoom> yh -o doesnt work for me
14:06:52 <Cale> sum [n | n <- [1..999], n `mod` 3 == 0 || n `mod` 5 == 0]
14:07:02 <Otoom> u missed the >
14:07:14 <shachaf> Otoom: No, you wouldn't type that in ghci.
14:07:17 <Twey> ||?
14:07:30 <Twey> @type ||
14:07:31 <opqdonut> :t (||)
14:07:32 <lambdabot> parse error on input `||'
14:07:32 <lambdabot> Bool -> Bool -> Bool
14:07:35 <Otoom> oh sorry i thought u were trying to sum it in here Cale
14:07:36 <Twey> @type (||)
14:07:36 <opqdonut> lambdabot is your friend :)
14:07:37 <lambdabot> Bool -> Bool -> Bool
14:07:38 <opqdonut> that's boolean or
14:07:44 <Twey> Oh, it does exist.
14:07:49 <Twey> @type or
14:07:49 <lambdabot> [Bool] -> Bool
14:07:54 <Twey> Huh.
14:07:59 <Twey> @src or
14:07:59 <lambdabot> or    =  foldr (||) False
14:07:59 <opqdonut> :)
14:08:00 <olsner> or is || on a list
14:08:05 * Twey nods.
14:08:09 <opqdonut> || is a binary operation of course
14:08:09 <Twey> 'kay
14:08:16 <Twey> Aye
14:08:21 <dbpatterson> any ideas about sqlite error?
14:08:24 <dons> opqdonut: hmm. i doubt it. so much is known statically. maybe for the bytecode interpreters?
14:08:28 <Jaak> > or True : undefined
14:08:29 <dbpatterson> `CStmt' has no constructors (-XEmptyDataDecls permits this)
14:08:29 <lambdabot>  Couldn't match expected type `[Bool]' against inferred type `Bool'
14:08:33 <opqdonut> dons: ok
14:08:34 <Jaak> > or (True : undefined)
14:08:34 <lambdabot>  True
14:08:57 <Otoom> i cant wait to get my haskell book :)
14:09:02 <Twey> > or (undefined : undefined)
14:09:03 <lambdabot>  Undefined
14:09:06 <TomMD> Just one haskell book?
14:09:10 <Twey> Eh?
14:09:11 <Otoom> atm yes
14:09:15 <Otoom> Programming in Haskell
14:09:21 <Twey> :t Undefined
14:09:22 <lambdabot> Not in scope: data constructor `Undefined'
14:09:25 <Twey> :t undefined
14:09:26 <lambdabot> forall a. a
14:09:33 <Jaak> @type defined -- :P
14:09:33 <Twey> Huh.
14:09:34 <lambdabot> Not in scope: `defined'
14:09:36 <TomMD> I'm just waiting for Real World Haskell.
14:09:44 <Twey> undefined is of type Anything.  o.@
14:10:05 <Jaak> kind of makes sense, doesn't it?
14:10:13 <Peaker> solve Haskell's dependency hell on major OS's in use today, add docstrings/interactive help, and you can touch an order of magnitude more users, IMO :)
14:10:14 * Twey nods.
14:10:17 <Twey> Vaguely
14:11:15 <matthew-_> another day, another sessions release
14:11:52 <dons> why do you do so many releases?
14:11:52 <TomMD> Peaker: I'm not clear on what you mean, could you explain?
14:11:53 <Cale> Peaker: eek!
14:12:02 <matthew-_> dons: release often
14:12:10 <matthew-_> tis a strategy
14:12:33 <SamB> strategy for what?
14:12:39 <matthew-_> development
14:12:39 <Cale> Peaker: You're saying you'd like to see the backwards compatibility issues get 10 times worse?
14:12:40 <Cale> :)
14:12:46 <Peaker> Cale, :-)
14:13:03 <matthew-_> and potentially getting someone to add the ability to delete versions from hackage
14:13:17 <Peaker> Cale, I am not saying whether or not wide spread adoption is a good thing, but I think that as a newbie I am much less qualified to answer Haskell questions but possibly more qualified about barriers of entry that newbies hit :)
14:13:30 <SamB> matthew-_: what a worthy endeavour!
14:13:58 <monochrom> Some barriers are desirable.
14:14:06 <roconnor> Peaker: what OS do you use?  Installing GHC on (k)ubuntu was a snap for me.
14:14:11 <Peaker> roconnor, Ubuntu
14:14:20 <Peaker> roconnor, No cabal-install, few libraries available
14:14:21 <roconnor> oh
14:14:31 <matthew-_> SamB: :)
14:14:35 <SamB> hey, at least he's not complaining about the need for a brain
14:14:39 <roconnor> oh, you are talking about installing libs rather than installing ghc?
14:14:56 <darrint> Is there an example for doing a number of successive operations returning Maybe but within an IO monad?
14:14:59 <SamB> Peaker: well, we don't have cabal-install in debian either
14:15:06 <SamB> Peaker: maybe after it is *released*?
14:15:06 <TomMD> Once Cabal-install gets distributed with GHC this complaint will probably die.
14:15:17 <roconnor> Peaker: or are you talking about installing hackage packages?
14:15:39 <Peaker> roconnor, yeah, Ubuntu doesn't package a lot of Hackage stuff and there's no cabal-install so its back to the 90's :-)
14:15:54 <SamB> at least, that's what they told me when I complained that it wasn't in debian
14:16:08 <Peaker> (configure;build;install tarballs manually resolving version dependency hell)
14:16:14 <SamB> "wait until we do a release, then we'll put it in debian too"
14:16:23 <roconnor> Peaker: Ah okay.  Well I think you will find that we all agree that this is a problem, and it is being worked on.
14:16:47 <monochrom> This one takes time and people.
14:16:56 <SamB> Peaker: you know, if you just grin and bear it for the time it takes to get cabal-install going, you won't have to do it again
14:17:18 <Peaker> SamB, I just had to do it again today, at work's computer :)
14:17:28 <SamB> Peaker: you should have copied the binary!
14:17:32 <EvilTerran> darrint, if each action needs to do IO, something like MaybeT is probably useful
14:17:36 <Peaker> SamB, Also, I tried installing ghc-6.8 thinking I'd get better compatibility, then re-done it a third time because 6.6 appearantly has better
14:17:49 <Peaker> SamB, well, not all of it ofcourse, but lots of annoying work :)
14:17:50 <monochrom> Sadly, ubuntu 7.10 is still at ghc 6.6.1.
14:18:16 * SamB <3 Igloo
14:18:17 <roconnor> monochrom: sad, but understandable.
14:18:28 <darrint> EvilTerran: MaybeT exists?
14:18:35 <ehird> MaybeT? ahahahahah
14:18:40 <thoughtpolice> darrint: check hackage
14:18:46 <ehird> we need an Awesome monad
14:18:52 <ehird> which is completely unpredictable
14:18:59 <ehird> and nobody really can follow through functions using it
14:19:01 <SamB> ehird: breaks monad laws
14:19:06 <ehird> IOT should be in there somewhere
14:19:06 <ehird> ;)
14:19:16 <ehird> SamB: Surely you can make a monad lawic MaybeT
14:19:19 <monochrom> Yeah, if one doesn't mind using 6.6.1 for now, ubuntu 7.10's apt-get works great.
14:19:24 <yitz> ehird: MonadRandom
14:19:36 <SamB> ehird: being completely unpredictable would break the monad laws!
14:19:49 <roconnor> ExitT is probably more useful than MaybeT
14:19:59 <ehird> SamB: haha
14:20:12 <ehird> roconnor: is that like, restricted IO with only systemExit
14:20:13 <ehird> :p
14:20:16 <monochrom> ehird: You should look up "probability monad".
14:20:20 <Otoom> I have orded the book just!
14:20:23 <darrint> roconnor: If it sounds like its name it's exactly what I'm wanting.
14:20:24 <ehird> yitz: It adds transformers randomly
14:20:24 <Otoom> 1-2 business dayts!
14:20:26 <Otoom> :)
14:20:28 <ehird> monochrom: I didn't mean like that. heh.
14:20:29 <shachaf> Otoom: Which book?
14:20:32 <shachaf> Otoom: Hutton's?
14:20:34 <Otoom> Yes.
14:20:41 <SamB> probabalistic monads aren't complately unpredictable
14:20:43 <Otoom> Is that bad?
14:20:49 <SamB> they are like quantum mechanics!
14:20:51 <monochrom> The beauty of probability monads is they are unpredictable but they still satisfy the monad laws!
14:21:08 <Otoom> shachaf: is it a good book for a starter?
14:21:13 <monochrom> Oh, nothing is "completely" unpredictable.
14:21:14 <shachaf> Otoom: Yes, it's a nice one.
14:21:23 <__pao__> quick question... how do I check efficiently if a list has at least 1 el?
14:21:28 <TheLorax> what's wrong with doing this? "merge (x:xs, y:ys) = x+y >> print ("Cool")"?
14:21:28 <Otoom> shachaf: thanks for the help on picking it
14:21:36 <shachaf> __pao__: not . null
14:21:41 <SamB> monochrom: well, for one thing, those things would have no applications if they weren't somewhat predictable...
14:21:54 <shachaf> TheLorax: What is it supposed to do?
14:21:59 <shachaf> TheLorax: What's its type?
14:22:07 <roconnor> ehird: not a system exit, just a "I'd like to stop now" command that well stops the monad; ignores the rest of the commands.
14:22:07 <__pao__> shachaf: thanks
14:22:08 <SamB> after all, they are used to predict something else
14:22:11 <thoughtpolice> Otoom: i've heard pretty good things, I have a copy of "Haskell -- the craft of functional programming" myself, which is good introductory material I think.
14:22:11 <shachaf> TheLorax: You can't do IO in an arbitrary function, it ahs to return IO.
14:22:21 <TheLorax> shachaf, takes the first element in list one and list two and then prints cool
14:22:23 <monochrom> Suppose I ask you to predict my actions in the next few minutes.  Here is one thing you can predict: my actions must not defy the laws of physics.
14:22:31 <roconnor> I think ExitT and MaybeT are isomorphic
14:22:34 <mauke> TheLorax: "takes" is not an action
14:22:40 <Otoom> Guys i kno i probably shouldn't advertise my site or anything, but its just started, DoxCoding.com Join if you wish.
14:22:45 <shachaf> TheLorax: If it's in IO, it should use return.
14:22:45 <SamB> monochrom: heck, try an electron!
14:22:47 <roconnor> but ExitT uses continuations and probably runs faster in the common case.
14:22:49 <__pao__> shachaf 0 < length l was overkill
14:23:00 <SamB> except then we need a quantum monad
14:23:11 <shachaf> __pao__: Except with lazy naturals and genericLength. :-)
14:23:15 <SamB> which allows the wave function to interfere
14:23:30 <TheLorax> shachaf, can you give me an example?
14:23:35 <monochrom> Anyway, "completely unpredictable" does not exist.  So a probability monad (or anything at all) is not obliged to be "completely unpredictable".
14:23:38 <darrint> @ty ExitT
14:23:39 <lambdabot> Not in scope: data constructor `ExitT'
14:23:44 <shachaf> TheLorax: I'd recommend you stay awy from IO for a while.
14:23:55 <TheLorax> shachaf. k
14:23:59 <Peaker> can code isomorphisms be found automatically?
14:24:17 <dbpatterson> errm, another error in Sqlite3 -  parse error on input `import' in the foreign import ccall unsafe "sqlite3.h sqlite3_errmsg"  line - ideas?
14:24:18 <monochrom> The most you can require is "uniform distribution over its domain".
14:24:32 <SamB> monochrom: my understanding is that the point of a probability monad is to predict probability distributions using ... er ... what kind of integration is that again?
14:24:35 <lament> Peaker: "is this program isomorphic to a program that halts"?
14:24:38 <darrint> @hoogle ExitT
14:24:39 <lambdabot> No matches found
14:24:40 <TheLorax> shachaf, last question, return passes values through >>=?
14:24:46 <ddarius> SamB: stochastic?
14:24:48 <monochrom> Measure theory in general.
14:24:53 <ddarius> Lebesgue?
14:24:58 <__pao__> shachaf: really? can you provide a pointer to "lazy naturals"? has it anything to do with [0..] ?
14:25:12 <jgrimes> monte carlo integration?
14:25:13 <shachaf> data Nat = Z | S Nat
14:25:24 <monochrom> When you run a probability monad in monte-carlo simulation mode, it is random.
14:25:37 <SamB> isn't lebasgue just a nicer formulation of the usual kind of integration?
14:25:46 <SamB> monte-carlo, yes
14:26:00 <Peaker> lament, I see. I guess I should sharpen my understanding of the word.  I thought it just meant that the programs have the same structure, only with differing names, and perhaps with some trivial "refactorings" mapping them to each other (sub-expression->function)
14:26:12 <SamB> that was the world
14:26:16 <SamB> err. word.
14:26:21 <SamB> damn swapping
14:26:24 <monochrom> Ah, I see.
14:26:32 <shachaf> TheLorax: (>>=) and return are separate functions, and IO is probably not the best place to start looking at them.
14:26:34 <yitz> SamB it's not the usual kind of integration, but it agrees where naive integration seems to make sense.
14:26:45 <ddarius> SamB: No.  There are Lebesgue integrable things that are not Riemann integrable.
14:26:48 <Peaker> lament, it could be interesting to find such similar structures, can canonize it to a form that expands all functions to their expressions, except recursions (which can be canonize to occur at some canonical point)
14:26:54 * ddarius prefers the Daniell integral.
14:26:56 <ehird> Otoom: "I know I shouldn't, but I will anyway"
14:27:03 <Otoom> yh
14:27:10 <Otoom> sorry
14:27:11 <Peaker> lament, Maybe pieces of code are equivalent, except they live inside a limited type, rather than a more generic one
14:27:21 <unenough> There is the gauge integral
14:27:23 <monochrom> But monte-carlo integration gives you an answer that is unpredictably different from the correct answer. :)
14:27:27 <SamB> is lebasgue the one with lub/glb ?
14:27:28 <ehird> I doubt many people here will want to join a site about c++ and asm anyway ;)
14:27:28 <Peaker> unenough, what's that?
14:28:24 <unenough> It's similar in form to the Reimann integral but allows a much bigger class of functions to be integrable.
14:28:26 <ddarius> ehird: C++ and assembly are some of my favorite languages and are in the top 3 most used languages for me.
14:28:36 <ehird> ddarius: 'many' keywrod
14:28:38 <ehird> *keyword
14:28:45 <unenough> So much bigger, that i think it contains all of lebesgue-integral functions, if I am not mistaken.
14:28:54 <unenough> (that is, real functions)
14:29:00 <monochrom> I hope the third one of ddarius's is Haskell. :)
14:29:01 <ddarius> ehird: That said, you are correct that I don't have any desire to join a site about them.
14:29:19 <ehird> ddarius: Less a site with a few short tutorials and little else, I might add..
14:29:33 <solrize_> http://en.wikipedia.org/wiki/Daniell_integral
14:29:33 <lambdabot> Title: Daniell integral - Wikipedia, the free encyclopedia
14:29:34 <yitz> ddarius: most used language for me is Postscript. I use it whenever I print something.
14:29:40 <nornagon> C++ and assembly are the worst languages ever, and are among the top 3 most used languages for me. :(
14:29:43 * monochrom uses computers but doesn't join a computer club. :)
14:29:48 <SamB> yitz: you write a program every time you print something?
14:29:53 <ddarius> ehird: I am a member of programmersheaven.com, but I haven't been there in like six years.
14:30:04 <lament> programmer shaven
14:30:10 <unenough> heh
14:30:12 * ddarius needs to shave.
14:30:16 <yitz> SamB yes. usually generated by automated tools though. Like OOo.
14:30:25 <lament> ddarius: clearly, if you haven't done it in six years :)
14:30:36 <SamB> yitz: that doesn't count as writing postscript!
14:31:03 <EvilTerran> you probably use more javascript than postscript, by that metric
14:31:04 <monochrom> Oh! I think sometimes I look up SQL syntax and end up in programmersheaven.com .
14:31:13 <yitz> In fact, Postscript is probably the most widely used programming language in the world.
14:31:58 <unenough> If I am not totally stupid, the reimann integral defines the "small distance" for the rectangle in terms of a number, but the gauge integral does it in terms of a gauge function
14:32:04 <SamB> yitz: next to x86 machine language, p-code, and CLR...
14:32:26 * yitz actually does write programs in Postscript from time to time.
14:32:37 <lament> SamB: and don't forget z-code!
14:32:37 * ddarius is #11 in the Top Replier list on programmersheaven.com
14:32:49 <yitz> but much less often, now that we have cairo in haskell.
14:32:49 <lament> and of course javascript.
14:32:52 <bd_> yitz: but not the most widely manually written :)
14:32:59 <SamB> lament: the majority of windows users do not use Z-code programs!
14:33:06 <yitz> bd_ awww
14:33:15 <ehirDoxCoding> oops
14:33:16 <ehirDoxCoding> :|
14:33:20 <shachaf> Z-code as in Z-machine?
14:33:36 <ddarius> ehird: How'd you manage that?
14:33:42 <ehird> ddarius: middle button = paste
14:33:57 <Twey> Heh
14:34:16 <ehird> ehird the Ox, coding
14:34:43 <yitz> SamB you're right, now that so many web pages obscure themselves with self-modifying code, I guess JavaScript wins now.
14:34:48 <monochrom> Where can I find out more about Z-code?  Do I just google for it?
14:34:57 <ddarius> @google zcode
14:35:06 <lambdabot> http://www.ifarchive.org/indexes/if-archiveXgamesXzcode.html
14:35:07 <lambdabot> Title: Index: if-archive/games/zcode
14:35:09 <shachaf> Is this Z-code as in Infocom, or something else?
14:35:15 <lament> the last time i accidentally pasted stuff, my girlfriend and best friend left me, i got fired, my parents commited suicide and my cat got ran over by a car
14:35:15 <ehird> shachaf: infocom
14:35:31 <ehird> ddarius: THAT programmers heaven? Oh jeez, that site is full of crap
14:35:34 <thoughtpolice> lament: tragic. :(
14:35:49 <ehird> lament: my clipboard should have big 'ARE YOU SURE' dialogs on pasting
14:35:57 <thoughtpolice> people should know of the deadly possibilities of copy and paste.
14:36:00 <ddarius> ehird: It was better years and years ago, but yes, it was going rather downhill rather quickly before I left.
14:36:03 <monochrom> lament: I don't see there is anything more you can lose by pasting stuff again...
14:36:24 <Peaker> Pasting isn't a problem. Cut&Pasting is great :)
14:36:33 <ehird> ddarius: His life
14:36:43 <ehird> Peaker: Not if you have classified stuff on there
14:36:47 <ehird> :p
14:36:51 <misterPhyrePhox> how "unsafe" is unsafePerformIO? if i want to make a global mutable variable, is var = unsafePerformIO $ newIORef 0 OK?
14:36:55 <yitz> ehird: the worst is when something slides off the end of your mouse while dragging it across the file system tree, and you can't find where it landed.
14:36:59 <Twey> ehird: I suffer from an extremely sensitive mousewheel.  :-(
14:37:11 <bd_> misterPhyrePhox: Only if var is at the toplevel, and you have a NOINLINE annotation for it
14:37:18 <ehird> misterPhyrePhox: No. It is not.
14:37:20 <ehird> That is a bad idea.
14:37:21 <Twey> yitz: I therefore don't use GUI apps :-P
14:37:25 <ehird> Encapsulate it in a StateT
14:37:32 <ehird> bd_: you're solving his request, not his problem
14:37:39 <Otoom> Cya guys.
14:37:40 <yitz> Twey: the solution is xmonad :)
14:37:42 <Twey> For file management, that is.
14:37:43 <Otoom> I will be back tomorrow :)
14:37:46 <bd_> ehird: It's necessary in some (rare!) cases. Eg, the GHC IO manager ;)
14:37:49 <Twey> xmonad does file management?
14:37:55 <misterPhyrePhox> ehird: i know i can't use State for this
14:38:01 <ehird> bd_: Do you think misterPhyrePhox is in one of those?
14:38:06 <misterPhyrePhox> bd_, what does the NOINLINE annotation do?
14:38:07 <ehird> Answer: no. There will be a better way.
14:38:08 <bd_> Who knows?
14:38:14 * Twey grins.
14:38:16 <ehird> misterPhyrePhox: What is your situation? Why does State not suffice?
14:38:17 <yitz> Twey: it allows you to use X easily without ever touching the mouse.
14:38:29 <Twey> 'kay.
14:38:32 * Twey installs.
14:38:36 <bd_> misterPhyrePhox: makes sure GHC only evaluates it once... provided you abide by other restrictions (ie, it's basically only useful for making completely global variables)
14:38:55 <misterPhyrePhox> bd_, ok, i see, thanks
14:39:02 <ehird> misterPhyrePhox: Please answer my question
14:39:41 <monochrom> It is unsafe because there is a way to use it plus IORef to cast Int to Either String Bool.
14:39:58 <misterPhyrePhox> ehird, i'm writing an object oriented toy langage. an object is data Object = Object { slots :: HashTable String Slot, protos :: IORef [Object] }. i want to have an object :: Object that is the root of the class heirarchy and is global
14:40:09 <bd_> monochrom: it's also unsafe because the evaluation order is not defined
14:40:15 <ehird> Someone tell misterPhyrePhox that this is DEFINATELY the wrong way to go about it..
14:40:27 <lament> misterPhyrePhox: Slate?
14:41:07 <SamB> self?
14:41:10 <monochrom> I think that is a much lesser evil in comparison because I have already given up expecting any evaluation order. :)
14:41:52 <bd_> monochrom: well, if you are imagining some sort of evaluation order, unsafePerformIO can be quite... unsafe
14:41:57 <Twey> Heh
14:42:01 <ehird> oh come on nobody's kicking misterPhyrePhox until he uses something better
14:42:02 <bd_> or even evaluation count
14:42:07 <monochrom> Yes, imaginations are unsafe.
14:42:08 <ehird> whats wrong with you people :p
14:42:16 <bd_> ehird: He's in IO anyway.
14:42:28 <monochrom> He's in OOP anyway.  <duck>
14:42:31 <bd_> as long as he follows the rules for safely making a global ...
14:42:42 <SamB> monochrom: he's going to need to duck more than you
14:42:50 <monochrom> haha
14:42:53 <SamB> with all that duck-typing <duck>
14:43:29 <gwern> @seen thayer
14:43:30 <lambdabot> I haven't seen thayer.
14:44:50 <ehird> bd_: But .. StateT!!!!
14:45:10 <bd_> and Data.Map butstill
14:45:26 <monochrom> A global object is the root of all evil.
14:45:58 <misterPhyrePhox> i don't see how StateT could help, or why i would use Data.Map when everything about objects is inherintly stateful
14:46:08 <roconnor> monochrom: what if it is static?
14:46:11 <misterPhyrePhox> i knew i should've written this in lisp ;)
14:46:20 <ehird> misterPhyrePhox: stateT of the global object
14:46:22 <ehird> = no IORef, no IO
14:46:29 <monochrom> Then it's static evil.
14:46:38 <ehird> and pure functional languages can be pure..
14:46:42 <ehird> errcan be OOP
14:46:44 <EvilTerran> misterPhyrePhox, using StateT allows you to approximate a global in a safe way
14:47:08 <EvilTerran> misterPhyrePhox, and everything about haskell is inherently stateless, hence our love for immutable objects
14:47:46 <SamB> yes, they tell me a lot of OO calculi are pure
14:47:54 <misterPhyrePhox> lol
14:48:02 <SamB> what?
14:48:11 <ddarius> If you are writing an interpreter for this language, there is no reason to use a global variable to do what you want.
14:48:22 <SamB> you probably thinks OO calculi have something to do with Calculus, don't you?
14:49:12 <misterPhyrePhox> SamB, i didn't know there was any mathematical basis for OOP, i thought you were making a joke
14:49:26 <ddarius> misterPhyrePhox: There is no accepted one.
14:49:46 <ehird> Haskell slogan: 'OOP is mathematically unsound!'
14:49:54 <SamB> ther are mathematical formulations, but none is a "basis"
14:50:02 <misterPhyrePhox> yeah
14:50:06 <misterPhyrePhox> clearly an inferior paradigm!
14:50:25 <SamB> well, possibly its not even just one paradigm
14:50:30 <petekaz> How do I make 'Right (count+1, row:acc)' be strict?
14:50:51 <petekaz> I tried 'Right $! (count+1, row:acc)' but that did not do it.
14:51:12 <ehird> 'object-oriented programming is an extraordinarily bad idea which could have only originated from california.' - djikstra
14:51:13 <opqdonut> petekaz: count `seq` row `seq` acc `seq` Right (count+1, row:acc)
14:51:20 <opqdonut> or something like that
14:51:22 <SamB> opqdonut: that won't do it
14:51:27 <opqdonut> forcing the tuple is not enough
14:51:28 <ehird> QUEUE EE DEE!
14:51:28 <opqdonut> SamB: oh?
14:51:38 <SamB> you need let bindings for those two expresisons in the tuple
14:51:44 <opqdonut> ah, of course
14:51:46 <SamB> then you can `seq` those
14:51:49 <opqdonut> yes
14:52:20 <SamB> well, actually, maybe you shouldn't bother with the row:acc one
14:52:21 <petekaz> I used the ! pattern where it is being consumed, and that worked, but I wanted to learn how to do it the standard way.
14:52:27 <SamB> but you might want to seq row
14:52:35 <EvilTerran> count `seq` row `seq` acc `seq (Right $! ((,) $! count+1) $! row:acc)
14:52:39 <Jedai> opqdonut: Actually just use Data.Parallel.Strategies.rnf
14:52:49 <opqdonut> another option, yes
14:52:55 <opqdonut> tho that'll force the list too i guess?
14:53:16 <Jedai> opqdonut: Yes, but you can create a strategy more suited to your need
14:53:22 <opqdonut> of course
14:53:35 <petekaz> EvilTerran: is there a version that is easier on the eyes for a newbie?
14:53:53 <opqdonut> use let
14:53:58 * petekaz realizes why the ! pattern was invented
14:54:08 <EvilTerran> yeah, use let
14:54:25 <petekaz> what would that look like?
14:54:28 <EvilTerran> or Parallel.Strategies, as mentioned above
14:54:34 <Jedai> ?source Data.Parallel.Strategies
14:54:34 <lambdabot> Data.Parallel.Strategies not available
14:54:39 <opqdonut> wouldn't "let !a = count+1; !b = row:acc in Right(a,b)" work?
14:54:42 <EvilTerran> isn't it Control. ...?
14:54:51 <Jedai> ?source Control.Parallel.Strategies
14:54:51 <lambdabot> http://darcs.haskell.org/packages/4/Control/Parallel/Strategies.hs
14:55:00 <SamB> opqdonut: you kids with your newfangled extensions!
14:55:04 <EvilTerran> ?docs  Control.Parallel.Strategies
14:55:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/4/Control-Parallel-Strategies.html
14:55:06 <opqdonut> SamB: :P
14:55:14 <hpaste>  Peaker pasted "Why the error?" at http://hpaste.org/6741
14:56:14 * SamB is, of course, kidding. he wants to implement class aliases after he gets (->) working in JHC...
14:56:18 <thoughtpolice> opqdonut: yeah that'll work
14:56:32 * Peaker reannounces the hpaste question
14:56:50 <hpaste>  paolino pasted "dep-exp2" at http://hpaste.org/6742
14:56:58 <opqdonut> SamB: class aliases?
14:57:11 <Peaker> why does runAction create an infinite type?
14:57:21 <opqdonut> Peaker:
14:57:24 <opqdonut> :t runStateT
14:57:24 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
14:57:31 <SamB> @google class aliases repetae
14:57:32 <opqdonut> see the tuple there?
14:57:32 <lambdabot> http://repetae.net/recent/out/classalias.html
14:57:32 <lambdabot> Title: Class Alias Proposal for Haskell
14:57:40 <Jedai> let strat (x,y) = rwhnf x `seq` rwhnf y in Right $! (count +1, a:b) `using` strat
14:57:47 <Peaker> opqdonut, yeah
14:57:51 <darrint> @hoogle (a-> m b) -> (m a -> m b)
14:57:52 <lambdabot> No matches, try a more general search
14:57:53 <opqdonut> :t evalStateT --  you probably want this
14:57:54 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m a
14:57:54 <SamB> beware: some of the code on that page is wierd
14:57:59 <SamB> doesn't match the rest
14:58:02 <opqdonut> :t execStateT -- or this
14:58:03 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m s
14:58:06 <Peaker> opqdonut, thanks
14:58:09 <opqdonut> np :)
14:58:25 <SamB> I only noticed this when it refused to parse
14:59:16 <Jedai> Right $! (count +1, a:b) `using` seqPair rwhn rwhnf
15:00:17 <Jedai> I think this one is nicer
15:00:27 <petekaz> thank.
15:00:30 <petekaz> thanks.
15:00:46 <opqdonut> SamB: yeah, class aliases are the way to go
15:02:34 <opqdonut> how would one go about implementing vector arithmetic in haskell? having (*) "overloaded" to types Num -> Vector -> Vector and Num -> Num -> Num would be nice
15:02:45 <opqdonut> (where Num would really mean Scalar)
15:02:52 <SamB> I really wish John would sort out this big snarl around Prelude in the jhc library...
15:02:54 <ddarius> opqdonut: It's been done several times.
15:03:06 <ehird> opqdonut: instance Num Vector
15:03:27 <opqdonut> one would need something like "class (Module a b) where (*) :: a->b->b"
15:03:33 <opqdonut> ehird: not enough
15:03:42 <opqdonut> (*) wants the arguments to be the same type
15:03:50 <opqdonut> ddarius: yeah, so i'd think
15:04:11 <opqdonut> but i really can't see how it could be done without clashing badly with prelude's numeric classes
15:05:10 <ddarius> @google site:haskell.org inurl:pipermail "Jerzy Karczmarczuk" vector
15:05:11 <lambdabot> No Result Found.
15:05:43 <opqdonut> ah, http://haskell.org/haskellwiki/Functional_dependencies has some nice examples
15:05:45 <lambdabot> Title: Functional dependencies - HaskellWiki
15:05:55 <opqdonut> yeah, it requires fundeps
15:07:30 <ehird> opqdonut: try it!
15:07:38 <ehird> just import prelude hiding + * etc
15:07:46 <ehird> then do a Num instance for it
15:07:48 <ehird> voila, drop-in
15:08:11 <opqdonut> hmm? Num instance for what?
15:08:25 <opqdonut> one can't get cross-type multiplications with Num
15:08:38 <opqdonut> the wikipage i pasted has a pretty nice implementation with fundeps
15:09:36 <lament> personally i'd be fine with having a different function for scalar-vector multiplication
15:09:54 <lament> the overloading that happens in math there is exactly the kind of overloading that haskell is supposed to prevent
15:10:05 <opqdonut> well fundeps make it typesafe
15:10:07 <lament> unless you treat your nums as vectors of 1 element
15:10:14 <lament> which is also possible
15:10:16 <opqdonut> but yeah, it isn't really a problem
15:10:22 <opqdonut> just aesthetical reasons
15:10:35 <lament> instance Vector Num
15:11:00 <ehird> yeah
15:11:02 <ehird> instance Vector num
15:11:06 <ehird> thats what i meant
15:11:08 <lament> that won't work
15:11:15 <ehird> why not
15:11:19 <lament> overlapping instances
15:11:24 <ehird> err
15:11:26 <lament> * for Num
15:11:28 <ehird> that was a typo
15:11:31 <ehird> I meant Num
15:11:31 <ehird> ofc
15:11:37 <ehird> err, wait
15:11:39 <ehird> you are right
15:11:40 <ehird> ok
15:11:43 <ehird> instance Vector Integer
15:11:44 <ehird> etc
15:11:45 <ehird> :p
15:12:09 <lament> you still get overlapping instances
15:12:18 <lament> when you multiply two integers, are they numbers or are they vectors?
15:12:32 <lament> er, not overlapping instances, overlapping classes i guess?
15:14:00 <ehird> lament:
15:14:17 <ehird> (*) :: (Vector a b c) => a -> b -> c
15:14:25 <ehird> or smth
15:14:43 <lament> ehird: that's fine. But * is already defined for numbers.
15:16:27 <ehird> lament: import Prelude hiding ((*))
15:16:38 <ehird> that's what i'm saying
15:16:41 <ehird> replace *,+,etc
15:16:52 <lament> ugly
15:17:17 <opqdonut> that's what i was saying earlier
15:17:28 <opqdonut> it can be done (with fundeps) but it clashes with the prelude Num
15:17:48 * EvilTerran looks at the foobar2000 SDK
15:17:51 <EvilTerran> ouch, C++
15:18:01 <EvilTerran> so much for getting it talking to haskell without too much pain
15:18:33 <ehird> fb2k is cool
15:18:37 <ehird> but .. windoze
15:18:43 <ehird> EvilTerran: of course c++ its a windows app
15:18:59 <EvilTerran> i guess i could make a generalised wrapper with some extern "C" {...} nonsense for loading up haskell object files
15:19:04 <EvilTerran> ehird, that's a complete non-sequiteur
15:19:29 <ehird> EvilTerran: mfc
15:19:43 <EvilTerran> still
15:20:06 <s710b> does somebody know a understandable guide/book for fixed point semantics?
15:20:42 <opqdonut> s710b: read up on domain theory
15:20:58 <opqdonut> but the easiest way to think of fix is that it iterates f starting from bottom
15:21:01 <Peaker> EvilTerran, I have newtype'd my monad transformer stack as you suggested yesterday -- how can I define multiple lift functions for each of the monads in the stack, where my newtype is not a MonadTrans instance?
15:21:18 <opqdonut> so f (f (f ...(f undefined) ... ))
15:21:54 <opqdonut> Peaker: you don't need to
15:21:58 <EvilTerran> Peaker, is your newtype a transformer or a monad or what?
15:21:59 <opqdonut> just use lift and type accordingly
15:22:02 <kosmikus> s710b: I'm not sure if you'd count Mitchell: "Foundations of Programming Languages" as understandable
15:22:18 <Peaker> my newtype is a monad, built from a stack of transformers: newtype Action model m a = Action (State.StateT model (Reader.ReaderT Environment m) a)
15:22:19 <Peaker>         deriving (Monad, Functor, MonadTrans)
15:22:33 <Peaker> opqdonut, I don't want users of Action to know what transformers are inside it
15:22:41 <EvilTerran> Peaker, generally, you should be able to write wrappers for, say, the get of your StateT, that unwrap the newtype, do the lifted get, then wrap the result again
15:22:44 <Peaker> also, I cannot use lift on Action
15:23:01 <Peaker> Oops, "deriving MonadTrans" is wrong
15:23:09 <s710b> kosmikus: ill look into it, thanks
15:23:41 <ehird> Peaker: instance StateMonad Action
15:23:57 <EvilTerran> ehird, but he may not want to expose that Action is a StateMonad
15:24:06 <ehird> EvilTerran: for 'get'..
15:24:27 <EvilTerran> he may not want users of the monad getting and putting themselves without going through his wrapper functions
15:25:51 <Peaker> thanks EvilTerran , I think I understand how to do it, lets see if I really do...
15:26:18 <EvilTerran> ?type get
15:26:19 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
15:26:33 <s710b> opqdonut: i already read some papers about it, but it seems im too stupid to understand (and my teacher is too stupid to explain ;) )
15:27:27 * EvilTerran thinks...
15:27:48 <ddarius> Watch out!
15:27:49 <EvilTerran> i *think* you want actionGet = Action (lift get)
15:28:00 <EvilTerran> say
15:29:27 <EvilTerran> ?type lift
15:29:27 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
15:29:35 <EvilTerran> jibbuns crings
15:30:00 <Peaker> EvilTerran, yep. actionGet is called getModel though (My "state" is the "model" the GUI is editing)
15:30:04 <Peaker> thanks!
15:30:09 <EvilTerran> yaay :)
15:32:05 <Peaker> I added a (Monad m)=> to the newtype: newtype (Monad m) => Action model m a ...   so I wouldn't have to repeat that m is a monad whereever I put a type signature that contains Action, but it seems to still fail to understand "m" is a monad whereever its a type-arg to Action, any idea why?
15:33:37 <Peaker> For example: getModel :: Action model m model ; getModel = Action (State.get)
15:33:56 <ehird> Peaker: what is your app?
15:33:57 <ehird> curious
15:34:02 <Peaker> Shouldn't the above save the need for (Monad m)=> in getModel?
15:34:10 <Peaker> ehird, I am trying to create a declarative GUI framework
15:34:46 <Peaker> ehird, Example program: "MyGUI.execute (MyGUI.widgetEditing (MyGUI.makeModel 5))"
15:34:53 <Peaker> (main equals that)
15:35:19 <ehird> data MyMonad a where Bind :: MyMonad a -> (a -> MyMonad b) -> Mymonad b; Return :: a -> MyMonad a
15:35:24 <ehird> ^^ type system monad, right?
15:35:28 <ehird> Peaker: wow, ugly :)
15:35:36 <Peaker> ehird, heh why ugly?
15:36:12 <Peaker> ehird, a model would in a non-toy program encapsulate a file or other storage format for it, as well as a serializer/deserializer
15:36:16 <EvilTerran> Peaker, that problem with constraints is because constraints in data and newtype decls don't do what you expect
15:36:26 <EvilTerran> much to everyone's chagrin
15:36:55 <Peaker> I see, what does that (Monad m)=>  in the newtype mean?
15:37:01 <ehird> anyone?
15:37:03 <dolio> That's why you use GADTs. :)
15:37:22 <Peaker> ehird, I generally want to take any data-type and auto-deduce a GUI for it later
15:37:27 <conal> Peaker: declarative in what sense?  "Action" doesn't sound like what i think of as declarative (simple, pure semantics).
15:37:39 <Peaker> conal, Action is part of the implementation
15:37:46 <conal> Peaker: oh, cool.
15:38:03 <Peaker> conal, I am trying to get something like: "main = MyGUI.execute (MyGUI.widgetEditing (MyGUI.makeModel 5))"  to work
15:38:56 <Peaker> conal, I am a Haskell newbie, though :)  I am more comfortable with monads now, but transformers make me think for a few minutes before I can do anything with them :)
15:39:04 <conal> Peaker: neat.  thetallguy is very interested in automatically synthesized GUIs also.  you might catch him on #haskell sometime.  you might also like Eros.
15:39:23 <ehird> Peaker: Tried TV?
15:39:30 <Peaker> conal, Yeah, I saw Eros - its very cool and similar to what I want.
15:39:39 <Peaker> ehird, nope, what's that?
15:40:02 <Peaker> btw: I don't think I can create a better declarative GUI than others -- its mainly educational for me at this stage, I'm learning a lot
15:40:16 <Peaker> maybe when I am a more proficient Haskeller I can, hopefully
15:40:21 <ehird> Peaker: wiki it
15:40:35 <ehird> Peaker: basically it's a meta-interface-builder thingy.
15:40:40 <conal> Peaker: careful around monads.  they can make effectful computations into first class values and so prettier to manipulate, but they're still imperative and have the usual associated drawbacks.
15:40:42 <ehird> it can do gui or console, and you can expand it to just about anything
15:41:14 <conal> Peaker: monads is a nice tool for non-effectful types too.
15:41:26 <Peaker> conal, Well, if I can get the API to work correctly, with a horrible implementation using horrible imperative style, I can get feedback about how to improve it later :)
15:41:54 <Peaker> conal, I have come from years and years of imperative programming background - my first Haskell program was Python-in-Haskell, with ugly IORef's/etc :)
15:42:04 <conal> Peaker: yeek!
15:42:22 <EvilTerran> eeegad
15:42:23 <Peaker> conal, but with a bit of feedback I replaced it all with lazy infinite lists, and a nicer forM_
15:42:33 <conal> Peaker: wonderful!
15:42:47 <conal> Peaker: now see if you can eliminate the forM_
15:43:56 <Peaker> conal, its a screen saver thing that jumps text around the screen
15:44:06 <Peaker> conal, (bouncing off the edges)
15:44:20 <Peaker> conal, I use forM_ on the infinite positions list for the mainloop, not sure how I could eliminate it
15:44:35 <ehird>     GADT pattern match in non-rigid context       -- whut
15:44:39 <Absolute0> Can haskell do comparisons?
15:44:46 <hpaste>  Peaker pasted "Bouncing Text Screen Saver" at http://hpaste.org/6743
15:44:48 <Botje> @faq Can haskell do comparisons?
15:44:48 <lambdabot> The answer is: Yes! Haskell can do that.
15:44:49 <ehird> Absolute0: No. It is impossible to compare two things in Haskell.
15:44:55 <ehird> These feature was deemed to complex for new users.
15:45:01 <ehird> :)
15:45:05 <Botje> :)
15:45:06 <Absolute0> ehird: are you being sarcastic?
15:45:07 <ehird> Define what you mean by 'comparisons'
15:45:14 <ehird> Absolute0: Key is in your name.
15:45:16 <ehird> Absolutely.
15:45:24 <Peaker> conal, I'd be very glad to get feedback about that paste about how to eliminate the forM_, though!
15:45:30 <vincenz> > 4 < 3
15:45:31 <lambdabot>  False
15:45:36 <Absolute0> ehird: I am writing a fib function
15:45:37 <Absolute0> let fib n = if n <2 n else fib(n-1) + fib(n-2)
15:45:39 <vincenz> < "abc" < "abd"
15:45:44 <vincenz> > "abc" < "abd"
15:45:44 <lambdabot>  True
15:45:46 <Absolute0> <interactive>:1:22: parse error on input `else'
15:45:51 <ehird> Absolute0: you missed a 'then'
15:45:57 <Absolute0> hmm
15:45:58 <Absolute0> :)
15:46:03 <ehird> let fib n = if n < 2 then n else fib (n-1) + fib (n-2)
15:46:07 <Absolute0> thanks :)
15:46:12 <ehird> Absolute0: also note how I do f (a) instead of f(a)
15:46:16 <vincenz> > let fib n = if n < 2 then n else fib (n-1) + fib (n-2) in fib 4
15:46:16 <lambdabot>  3
15:46:19 <ehird> function calls aren't f(arg,arg) in haskell
15:46:21 <ehird> they're func arg arg
15:46:31 <ehird> you just need to (...) the arithmetic because otherwise it would do '(fib n) - 1' etc
15:46:33 <Peaker> > let fib n = if n < 2 then n else fib (n-1) + fib (n-2) in fib 30
15:46:34 <lambdabot>  832040
15:46:38 <vincenz> Absolute0: I would also use case analysis, not an if
15:46:41 <Peaker> I thought that would be tougher than that
15:46:43 <vincenz> more idiomatic
15:46:50 <ehird> vincenz: Oh come on, he's a newbie. cut him some slack :)
15:46:50 <vincenz> fib n | n < 2 = ..
15:46:59 <Absolute0> vincenz: I am using haskell for only 5 minutes..
15:47:00 <vincenz> ehird: I wanna train em early on :)
15:47:00 <Absolute0> :P
15:47:05 <Absolute0> Let the fun begin!!
15:47:07 <vincenz> Absolute0: It wasn't criticism, just a suggestion :)
15:47:36 <vincenz> Since you're here, might as well poor as much info into you as possible :)
15:47:52 <Absolute0> vincenz: and its much appreciated.
15:48:10 <shachaf> > fix ((1:) . scanl (+) 1)
15:48:25 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
15:48:26 <ehird> is there a page about GADT monads anywhere?
15:48:28 <ehird> i'm interested in them
15:48:35 <Botje> vincenz: I found case analysis to be slower (at least on ghc 6.6) than an if-test
15:48:45 <ehird> trying to formulate State as a GADT ;)
15:48:51 <Absolute0> Can haskell be used as an alternative to my regular oop languages? Or is it used for completely different things?
15:48:52 <vincenz> Botje: I don't think utmost efficiency is important at this stage tho
15:49:00 <vincenz> Botje: case-analysis is more idiomatic and more legible
15:49:08 <Peaker> ehird, can you give me a wiki link for TV? its a bit of a problematic term to search :)
15:49:13 <Absolute0> For some reason i feel like the creaters of haskell came from Java :)
15:49:18 <vincenz> Absolute0: Certainly, but it will take a vastly different approach at solving problems
15:49:19 <Absolute0> StrPrntLN
15:49:21 <Botje> i agree, but not if you're micro-benchmarking stuff
15:49:27 <shachaf> @wiki TV
15:49:27 <lambdabot> http://www.haskell.org/haskellwiki/TV
15:49:33 <ddarius> Absolute0: Java didn't exist when Haskell was invented.
15:49:39 <Botje> and i thought fac | n > 2 = ... | otherwise = would be the same as an if .. then
15:49:40 <darrint> Absolute0: As an object guy I'd recommend you approach it with your object brain turned off.
15:49:42 <roconnor> Absolute0: maybe they came from Modula
15:49:46 <vincenz> Botje: Oh, that was side-inof, I thought you were disagreeing on telling him to use that :)
15:49:48 <Peaker> oh, thanks
15:49:54 <vincenz> Botje: that's interesting
15:50:07 <vincenz> Botje: I guess an if is slightly stricter?
15:50:10 <Absolute0> darrint: i learned functional programming in Programming Languages 101 :)
15:50:19 <Absolute0> we useds prolog..
15:50:25 <Absolute0> *used
15:50:34 <ddarius> Prolog is logic programming, not functional programming.
15:50:37 <Botje> yes. only thing I can think of is the overhead of setting up the match failed handler
15:50:40 <Absolute0> ouch
15:50:45 <Absolute0> scheme?
15:50:47 <darrint> Absolute0: Then approach it with your prolog brain on. You'll like the list monad.
15:50:50 <Botje> but surely ghc should see that match is total, so i don't know what happened.
15:50:51 <ehird> Absolute0: Scheme is kind of functional
15:50:54 <ehird> Not purely, though
15:51:04 <ehird> Absolute0: You can use Haskell for practical stuff to be sure.
15:51:05 <Peaker> ehird, oh, those TV - that's basically the Eros techtalk - yeah, I like that. I don't like the actual UI though
15:51:11 <vincenz> You can't get more functional than haskell :)
15:51:17 <Absolute0> so haskell has no imperative stuff whatsoever?
15:51:20 <Peaker> ehird, Maybe I'm replicating the TV effort, badly, but I'm sure to learn a lot from it :-)
15:51:23 <ehird> Absolute0: Yes and no.
15:51:28 <vincenz> It does, they're stuck inside warm fuzzy things called "monads"
15:51:40 <Absolute0> I thought its impossible to exclude imperative code completely.
15:51:40 <conal> Peaker: looked at your hpaste.  it might be about as functional as you can get until you introduce some types to model geometry and events.
15:51:42 <ehird> Absolute0: Yes, technically, haskell has no side effects. No, in reality, Haskell programs can do input/output and even boring things like web servers or what not
15:51:51 <darrint> warm and fuzzy indeed.
15:52:13 <ehird> Absolute0: There's a special warm and fuzzy thing called a Monad. There's a magical monad -- IO -- which a program written in C hijacks and performs its dirty work for it.
15:52:20 <ehird> So it's kind of a technicality, but a correct one.
15:52:30 <Absolute0> hijacks?
15:52:30 <Absolute0> :)
15:52:31 <ehird> But things like e.g. global state are handled by clever monads inside Haskell.
15:52:31 <Peaker> conal, Can you elaborate?
15:52:36 <Peaker> conal, Thanks for taking the time look, btw
15:52:44 <ehird> Absolute0: taps in to its bind stream and evilly performs the actions basically
15:52:52 <Cale> heh
15:52:53 <vincenz> like launching nuclear missiles
15:52:56 <Cale> It's not that bad
15:53:04 <conal> Peaker: have you seen Fran and other FRP (functional reactive programming) systems?
15:53:22 <Peaker> conal, Don't think so, I've only seen Eros
15:53:30 <Absolute0> the benchmark tests on the haskell site rate gcc #1 :)
15:53:31 <Cale> Absolute0: Basically, in Haskell, we represent computations which might perform side effects by values of a certain type
15:53:35 <Peaker> ehird, btw: Eros is pretty much the same as Subtext...
15:53:47 <Peaker> ehird, (with a different UI)
15:54:13 <Cale> Absolute0: and the Haskell runtime system looks at one of these values (called main), and carries out the instructions in it
15:54:13 <TheLorax> can anybody see the syntax error on this last line here? http://rafb.net/p/HuepK114.html
15:54:13 <Cale> Absolute0: (which might entail side effects)
15:54:14 <lambdabot> Title: Nopaste - tmp.hs
15:54:32 <Cale> These side-effecting computations can involve pure computations as part of their work, of course.
15:54:39 <Absolute0> basically everything in haskell is recursive..
15:55:00 <Absolute0> can i code a looped version of fib?
15:55:07 <Absolute0> the recursive one is slow as expected.
15:55:07 <Cale> Absolute0: At some level, recursion is there, but you actually try to avoid it in favour of higher-order functions.
15:55:19 <shachaf> TheLorax: merge is defined as having one argument.
15:55:20 <conal> Peaker: check out http://conal.net/Fran/tutorial.htm.  Though the library is seriously bit-rotten, the tutorial will give you a feel for the FRP paradigm and functional graphics.  then see http://haskell.org/frp for many more refs.
15:55:21 <lambdabot> Title: Composing Reactive Animations
15:55:24 <shachaf> TheLorax: But you're giving it two.
15:55:35 <TheLorax> shachaf, I ment to define it with two
15:55:35 <shachaf> TheLorax: (Right now it's getting a tuple.)
15:55:37 <Cale> Yeah, you can write a tail-recursive version, or else a memoised version
15:55:45 <ehird> Absolute0: A while back someone though haskell was 'primitive' because it had no for loop. A for loop is a pretty low-level thing. Haskell allows you to build abstractions and use them just like for loops.
15:55:51 <shachaf> TheLorax: You want something like "merge arg1 arg2 =" -- no parentheses.
15:55:55 <ehird> So haskell programs express what you mean, not how (Ideally, of course.)
15:55:57 <Cale> Absolute0: One of the funnest ways to implement the Fibonacci sequence is using a lazy list
15:55:59 <shachaf> TheLorax: Function application is just a space in Haskell, also.
15:56:00 <Peaker> conal, thanks!
15:56:01 <TheLorax> shachaf, ok. thank you.
15:56:12 <Absolute0> Cale: mind giving an example?
15:56:23 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
15:56:24 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
15:56:25 <shachaf> TheLorax: So you'd say "print (f a b)" instead of "print(f a b)", "merge a b" instead of "merge(a,b)", and so on.
15:56:40 <Cale> So here, we have a recursively defined list
15:56:43 <shachaf> TheLorax: Also, you might want to use a case for the comparison, instead of ifs.
15:56:47 <Cale> Its first two elements are 0 and 1
15:56:55 <Jedai> Absolute0: Your fib is slow because of the algorithm, not because it's recursive
15:56:57 <ehird> conal:  http://conal.net/Fran/gifs/leftRightCharlotte.gif hahahahah
15:56:59 <ehird> that really amuses me
15:57:01 <conal> Peaker: my pleasure.  for more papers on animation, graphics, and functional reactivity, see http://conal.net/papers/.  after the wednesday icfp paper deadline, i'd be glad to chat more about FRP.
15:57:01 <lambdabot> Title: Conal Elliott&#146;s Publications
15:57:05 <Cale> and what follows is the list you get when you add fibs elementwise to its own tail
15:57:09 <Absolute0> Jedai: well yeah.
15:57:10 <TheLorax> shachaf, you mean the | thing?
15:57:13 <ehird> Absolute0: you calculate everything twice, obviously
15:57:16 <Cale> So the next element is 0 + 1
15:57:19 <ehird> Absolute0: since you do everything -1 then everything -2
15:57:24 <shachaf> TheLorax: That also works.
15:57:35 <Peaker> conal, ok, great, me too
15:57:36 <Absolute0> ehird: Jedai Been there done that. :)
15:57:52 <Jedai> ehird: Nope, he calculate everything much more than twice (else it would be pretty fast)
15:57:55 <ehird> Absolute0: Yeah, well, your program is slow because you told it to do slow things. :p
15:57:58 <ehird> Jedai: Yeah, that's what I meant
15:58:34 <Jedai> Absolute0: Do you understand Cale solution, it's pretty nice :-)
15:58:40 <ehird> Absolute0: In haskell, the implementation details are not the things you worry about (until you need serious performance, and normally someone's got their hands dirty for you already in that case). You worry about the efficiency of the algorithms themselves: what you're telling the computer to calculate.
15:58:54 <conal> Peaker: btw, thanks for the SDL example.  i want to make a new functional animation library, as well as a library for non-traditional GUIs, and SDL is probably a good foundation.
15:59:02 <Absolute0> Jedai: not at the moment :)
15:59:09 <TheLorax> shachaf, I removed the brakets around the merge definition, along with the , but now it says there is a parseing error in the pattern.
15:59:16 <SamB> personally, I would be happy if JHC had unfunny performance
15:59:26 <Absolute0> hava haskell? :)
15:59:35 <ehird> Absolute0: JHC = haskell in java yeah
15:59:43 <ehird> Absolute0: BTW, you are using GHC, right?
15:59:46 <ehird> Not hugs.
15:59:48 <SamB> what?
15:59:52 <Cale> Absolute0: In order to understand the performance of Haskell programs, a good starting point is to understand what lazy evaluation really is.
15:59:55 <ehird> SamB: isn't it?
15:59:55 <SamB> JHC has nothing to do with Java!
15:59:58 <ehird> oh?
16:00:01 <ehird> then i am mistaken
16:00:03 <Peaker> conal, no problem, I don't think existing GUI frameworks are usable, keyboard-wise, so I have long decided to build all my UI's on top of SDL or something at that layer
16:00:14 <Absolute0> ehird: yeah
16:00:22 <SamB> John's Haskell Compiler
16:00:27 <ehird> Absolute0: good. ghc can do some crazy optimizations when you need it :)
16:00:28 <Cale> People will tell you that lazy evaluation means that nothing is computed until it can be determined that it's really needed, but this isn't a terribly clear way to put it.
16:00:36 <Absolute0> ehird: hugs is not recommened?
16:00:47 <SamB> haskell->java indeed!
16:00:53 <Peaker> Cale, does lazy evaluation _guarantee_ that something won't be computed if its not needed?
16:00:53 <shachaf> Absolute0: Probably not.
16:00:55 <SamB> hahahaha, that would run so slow!
16:00:58 <ehird> Absolute0: Well, there's nothing wrong with hugs. It just doesn't support a lot of the ghc extensions.
16:01:07 <Cale> Peaker: In some sense.
16:01:10 <Peaker> acleI
16:01:12 <ehird> Absolute0: & iirc it isn't that actively developed.
16:01:12 <Peaker> oops
16:01:17 <ehird> Also, ghc is much faster, being a full compiler.
16:01:26 <Absolute0> I hope i dont get fired for learning haskell at my job :)
16:01:40 <Cale> Peaker: In the sense that expressions won't be evaluated until you pattern match against their values (at which point you really must evaluate them)
16:01:42 <Peaker> Cale, a threaded implementation might guess which lazy thunk is going to get used to make use of idle processors
16:01:44 <thoughtpolice> and let's not mention that with GHC you get access to pretty much anything that's on hackage
16:01:49 <Absolute0> I am bored most the time, figured i'd learn something...
16:01:55 <Cale> Peaker: Right, but that wouldn't be lazy evaluation.
16:02:11 <Peaker> Cale, does Haskell disallow that kind of optimization?
16:02:15 <Cale> No
16:02:25 <Cale> Because Haskell doesn't actually say that it's lazily evaluated.
16:02:35 <Cale> The Haskell report says that evaluation is non-strict
16:02:55 <Peaker> not guaranteed to be strict or lazy, that is?
16:03:02 <Cale> which just means that if the lazy program terminates and produces a result, your Haskell program should also terminate and produce the same result
16:03:18 <Cale> There are lots of orders of evaluation which will work.
16:03:29 <Cale> Strict evaluation however, won't.
16:03:39 <conal> but speculative could
16:04:03 <Cale> What strict evaluation does is that whenever you have a function application (f x), first x is evaluated, then f, and then x is substituted into the body of f.
16:04:08 <Absolute0> Do you have to be more intellectual to code in haskell as opposed to a more standard language like C++/C? :P
16:04:33 <Cale> Absolute0: Well, no, but becoming more intellectual is an inintended side effect, perhaps :)
16:04:44 <conal> Absolute0: perhaps you have to like thinking better than copy & paste.
16:04:45 <Absolute0> unintended
16:04:46 <baaba> or at least becoming more pretentious ;)
16:05:05 <Absolute0> conal: you never copy and paste!
16:05:10 <Cale> So that's strict evaluation... let's do my favourite example
16:05:18 <Cale> We have the function double x = x + x
16:05:21 <Absolute0> unless its hyperlinks
16:05:22 <Absolute0> :)
16:05:28 <Cale> and we'll evaluate double (double 5)
16:05:35 <Cale> So, under strict evaluation, we have:
16:05:38 <Cale> double (double 5)
16:05:41 <Cale> -> double (5 + 5)
16:05:45 <Cale> -> double 10
16:05:47 <Cale> -> 10 + 10
16:05:48 <Cale> -> 20
16:05:55 <Cale> Innermost-first.
16:06:12 <Absolute0> isn't that old-school recursion?
16:06:19 <Cale> Nothing recursive there.
16:06:26 <Peaker> Absolute0, no function is calling itself
16:06:29 <Absolute0> ok plain function nesting.
16:06:36 <Absolute0> :)
16:06:42 <Cale> yeah, note that we evaluate the *inner* double first
16:06:51 <Cale> So this is what C, C++, Java, etc. all do.
16:06:58 <Absolute0> Cale: right.
16:06:58 <Cale> Also, ML, and many other functional languages
16:07:21 <Cale> Under outermost-first evaluation, we'd get this:
16:07:24 <Cale> double (double 5)
16:07:26 <ddarius> Every language except for Clean and Curry (and Haskell of course) pretty much.
16:07:30 <Cale> -> double 5 + double 5
16:07:37 <Cale> -> (5 + 5) + double 5
16:07:41 <Cale> -> 10 + double 5
16:07:45 <Cale> -> 10 + (5 + 5)
16:07:45 <Absolute0> oh la la :)
16:07:48 <Cale> -> 10 + 10
16:07:49 <Cale> -> 20
16:07:58 <Cale> Same result, but look! We wasted some steps
16:08:04 <Cale> We computed double 5 twice
16:08:17 <Cale> So to prevent this, lazy evaluation adds an optimisation
16:08:36 <Cale> It says that if a parameter to a function occurs multiple times in the body, the evaluation of the copies is shared.
16:08:54 <Cale> If you'll allow me to use let ... in ... syntax to represent this sharing, we have:
16:08:59 <Cale> double (double 5)
16:09:05 <Cale> -> let x = double 5 in x + x
16:09:12 <Cale> -> let x = 5 + 5 in x + x
16:09:12 * vincenz is rivetted as he listens to Cale talking about Haskell like a sports-commentator on an intense and closely-tied match
16:09:17 <Cale> -> let x = 10 in x + x
16:09:22 <Cale> -> 20
16:09:50 <Absolute0> -> is an indent?
16:09:53 <Cale> Really, you'd use a pointer or something, so the two x's would point to the same thing, and when that thing is evaluated and updated with the result, it gets shared.
16:10:03 <Cale> -> means "evaluates to"
16:10:07 <Absolute0> ah
16:10:09 <Absolute0> and in?
16:10:10 <Peaker> I have opened wiktionary twice because of #haskell today already...
16:10:31 <Absolute0> ~in
16:10:32 <Cale> let <decls> in <expr>
16:10:44 <Cale> is syntax for making the declarations <decls> available for use in <expr>
16:10:46 <Absolute0> for i in 100?
16:10:52 <Cale> So we have some constant x here
16:11:02 <Cale> and once it's evaluated, we don't evaluate it ever again
16:11:02 <EvilTerran> > let x = 10 in x+x
16:11:03 <lambdabot>  20
16:11:11 <EvilTerran> it's a local nam
16:11:13 <EvilTerran> e
16:11:13 <Cale> Does that make sense?
16:11:20 <Absolute0> ah i see
16:11:23 <EvilTerran> or rather, let/in is for introducing local names
16:11:37 <Absolute0> i in 100
16:11:42 <Absolute0> same concept :)
16:11:45 <Cale> Really, this is a bit of a scam -- a real Haskell implementation would use a pointer.
16:11:50 <EvilTerran> the bindings declared after the let are visible in the expression after the in
16:12:01 <Peaker> conal, I'm just skimming through that tutorial, but it seems pretty damn cool ;)
16:12:17 <Absolute0> is "i in 100" equivalent to i = 100 in C?
16:12:17 <Cale> And in the expression x + x, you'd have a function call for (+), and then two pointers pointing to the same x
16:12:23 <thoughtpolice> hm, i'm reading through TAPL and i'm at the point about polymorphism/type-variables etc, but what's meant by "substitution instance" exactly? i.e. if o = [X -> Y, Z -> Nat] and you have a type T and map type variables to concrete types, i.e. o(T), is "o(T)" a substitution instance? i feel i'm mainly getting stuck on jargon now (stupid)
16:12:26 <ehird> Absolute0: 'let i = 100 in 100' is '100'
16:12:36 <ehird> Absolute0: 'let i = 100; j = 500 in i+j' is '100+500'
16:12:53 <Cale> But I'm using the Haskellish notation to hide those implementation details :)
16:13:09 <Peaker> Absolute0, let a = 5 in a*a   is sort of like:   const int a = 5;   (a*a)   in C
16:13:33 <ddarius> thoughtpolice: Presumably it's the substitution o applied to T.
16:13:35 <conal> Peaker: :)
16:13:39 <Cale> You could, if you really wanted to, have a Haskell evaluator which did this, and it would be totally appropriate in that it would get the right results. It would just be a bit slow constant-factor wise.
16:14:05 <Cale> But since that's just a constant factor, this is a really effective way to understand the performance of Haskell programs.
16:14:21 <Cale> Of course, GHC might do more optimisation still, but this is a good first approximation.
16:14:25 * ddarius will write a Haskell implementation that uses call-by-name and has no tail-call optimization.
16:14:50 <conal> Peaker: btw, i'm not satisfied with the eros UI either.  i want to revisit it soon.
16:15:02 <thoughtpolice> ddarius: okay thanks, i'm trying to work my way through the constraint-based typing section and i'm needing to backtrack and refine my thoughts a little
16:15:03 <Cale> Absolute0: So the important thing here is that if you have the expression f (g (h x)), it's f which gets called first
16:15:17 <Absolute0> i see
16:15:18 <Cale> and g (h x) gets spliced into the body of f
16:15:36 <conal> Peaker: my puzzle is how to get the complete generality of programming with a friendly & guessable UI.
16:15:37 <Absolute0> I think i learned that at one point.
16:16:01 <Absolute0> Cale: Have you written any applications in haskell that I can see?
16:16:02 <Cale> So it's really not all that magical, even though it can seem that way :)
16:16:28 <Cale> I don't have a lot online, but perhaps you could look at Nymphaea.
16:16:43 <Peaker> conal, Well, I think the overlapping-windows/MDI style UI is horribly wasteful in screen-space.. Also I think that any significant change in the screen status must animate so the user is not disoriented
16:16:55 <ehird> ddarius: Would call by name haskell even WORK? :p
16:17:01 <Peaker> conal, the MDI style also requires tedious space management by the user
16:17:05 <Cale> It's slightly messy in its current state, as I think I was in the middle of adding some features when I stopped working on it :)
16:17:10 <conal> Peaker: i'm totally with you on both points.
16:17:21 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/nymphaea-0.2
16:17:23 <lambdabot> http://tinyurl.com/2mba99
16:17:26 <Absolute0> ~Nymphaea
16:17:29 <Absolute0> !Nymphaea
16:17:37 <Cale> I gave a link there
16:17:41 <Cale> @hackage nymphaes
16:17:41 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/nymphaes
16:17:44 <Cale> @hackage nymphaea
16:17:44 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/nymphaea
16:17:46 <Cale> hmm
16:17:51 <Peaker> conal, btw: have you seen Jonathan Edwards' efforts on Subtext?
16:17:56 <Cale> heh, that actually does work :)
16:17:58 <ddarius> ehird: Sure.
16:18:21 <conal> Peaker: i've looked.  so far, i haven't found the semantic model.
16:18:27 <Cale> It's an L-system fractal generator which uses the Cairo graphics library.
16:18:37 <Absolute0> Cale: I looked at the source of the game frag and it's completely unreadable.
16:18:40 <Cale> Oh, you'll need Gtk2Hs to run it...
16:18:48 <Peaker> conal, Subtext 2 is more focused on the schematic table UI. I think Subtext 1 is a poorer UI but is more interesting language-wise
16:18:54 <thoughtpolice> ddarius: in terms of the constraint sets which is where i'm getting stuck, do we say that the substition o unifies an equation S = T, if o(S) = o(T), i.e. the substition applied to both types (that have type variables) yields the same type?
16:19:04 <Cale> Absolute0: Well, you'll have to understand Arrows to approach it...
16:19:05 <ehird> Absolute0: Don't look at frag: it's micro-optimized.
16:19:12 <Cale> Absolute0: and it was written by a beginner too :)
16:19:14 <conal> Peaker: i'll look again.
16:19:18 <Peaker> conal, Subtext 1 is divided into two flash demos, first is about an FP he created, which is unfortunately not statically typed
16:19:22 <Cale> (relatively speaking of course)
16:19:22 <Absolute0> Cale: does it run well?
16:19:32 <Absolute0> I haven't had the luck to run it.
16:19:34 <Peaker> conal, The second demo of Subtext 1 adds "Actions" which are very similar to values of IO Monads
16:19:36 <Cale> Frag? It runs fine on my machine, last I tried it.
16:19:38 <thoughtpolice> or is my thinking totally out of whack?
16:19:39 <ehird> Absolute0: The game itself is apparently good.
16:19:42 <ehird> But the code..
16:19:51 <Cale> ehird: It's not *so* terrible
16:19:54 <Absolute0> Are there any binaries for it?
16:19:58 <Cale> I don't know...
16:20:24 <Peaker> conal, In order to introduce side effects. The cool thing about Edwards' actions is that he has a widget displaying them that lets the user "expand" the "hypothetical futures" that could execute if the action is "invoked"
16:20:45 <Peaker> conal, So you can browse a tree of hypothetical futures, and the pasts
16:20:49 <Cale> It's not really fleshed out as a game, and the controls could use a little work, but it's a good proof of concept.
16:21:13 <conal> Peaker: sounds cool.  though i'm no fan of IO.  i like to know what things mean.
16:21:23 <Cale> I bet someone like conal could come up with an even better proof of concept ;)
16:21:27 <Peaker> conal, Well, IO is a problem that must be solved somehow :-)
16:21:46 <conal> Peaker: or maybe it's a solution rather than a problem.
16:21:51 <conal> (my perspective)
16:22:40 <Peaker> conal, perhaps, its indeed not the focus of Subtext, however I do think that the hypothetical-future thing is a very cool visualization of IO monads :)
16:22:57 <conal> neat.  i'll check it out.
16:24:16 <Absolute0> Anyone knows what package might Array (required by frag) be packaged in in a distro such as debian?
16:25:00 <Cale> Absolute0: oh, uh, which version of GHC is that?
16:25:06 <Absolute0> 6
16:25:09 <Cale> array got separated out in 6.8
16:25:21 <Cale> In 6.6 it was still in base
16:25:43 <Absolute0> 6.6.1
16:25:47 <Cale> mm
16:25:48 <Absolute0> i guess i dont need it :)
16:26:05 <ddarius> thoughtpolice: Yes.
16:26:21 <Cale> You might have a better time upgrading to 6.8, but you could try removing array from the list of dependencies inside the .cabal file
16:27:15 <Cale> gwern: Did you know that hackage failed to compile your frag package?
16:27:47 <Absolute0> is 10645 lines considerd little or a lot of code for a game like Frag? :P
16:27:52 <gwern> Cale: I did not
16:28:02 <Cale> Absolute0: That is a lot of Haskell code.
16:28:15 <gwern> Absolute0: it's basically reimplementing Quake III; how many lines is the Quake III engine
16:28:15 <Absolute0> Is it a lot for a game?
16:28:19 <Cale> Absolute0: Though if you're counting the generated bits, you probably shouldn't
16:28:27 <Jedai> Absolute0: I don't think it's a lot for such a game
16:28:35 <Cale> Absolute0: the .as files generate similarly named .hs files
16:28:35 <gwern> FPSs are not marvels of concision
16:28:51 <Absolute0> Cale: find . -exec cat {} \;|wc -l in src/
16:29:12 <Cale> I can imagine doing a full featured FPS in under 1000 lines, with a nonexistent 3D library :)
16:29:15 <gwern> Cale: so hackage is just choking on the haddocks?
16:29:30 <Cale> gwern: I don't know. I just noticed the build failure flag there.
16:29:32 <Jedai> Absolute0: Especially as there's plenty of "library" material in it, which could probably be abstracted away, I think the core of the code is actually very small compared to the same thing in other languages
16:29:44 <gwern> Cale: bah, I can write a entire full-featured window manager is one line (if you'll let me use the xmonad library...)
16:29:53 <Cale> gwern: This is true.
16:30:12 <Absolute0> Jedai: Would you say the same about the time it took to actually code it? :)
16:30:24 <Cale> But I mean the stuff which is specific to the game itself and not stuff that deals with reading arcane model formats and such.
16:30:31 <Absolute0> maybe each line took days to figure out. :P
16:30:33 <gwern> Jedai: I don't doubt that, but I wouldn't want to do it. muns did an impressive job in writing frag, but it's not the most refined jewel of code I've ever seen
16:30:50 <Cale> Absolute0: If you're careful, you can be really concise and clear in Haskell.
16:31:09 <Absolute0> Does being careful involve a lot of work?
16:31:10 <Cale> Absolute0: I did some work for McMaster university as a summer job at one point
16:31:15 <gwern> Absolute0: no, muns didn't have days to spend on each line (although some of it is in fact ripped out of some old FRP library)
16:31:28 <Jedai> Absolute0: Depends on the developer, but for experimented haskeller, writing in Haskell is frequently faster than in "lesser" languages. On the other hand frag wasn't done by en experienced Haskell developer
16:31:37 <Cale> Absolute0: I wrote a pipeline scheduler for PPC + Altivec assembly in Haskell
16:31:52 <Cale> Absolute0: It came to about 1200 lines, of which 50% was documentation
16:32:19 <Absolute0> newer languages such as Ruby and python seem to make similar claims. :)
16:32:19 <Cale> and according to my supervisor, who was an expert C programmer, would have easily been 50000 lines of C.
16:32:27 <SamB> contrast with Python, where if you are careful, you won't get name errors
16:32:54 <darrint> When ghci says: <interactive>: <<loop>> that means I broke something?
16:32:58 <Cale> Absolute0: Of course, I spent about 3 weeks writing almost no code at all
16:33:01 <Absolute0> Cale: so then its 600 lines of code. :)
16:33:05 <Cale> Absolute0: right
16:33:27 <Cale> Absolute0: and then about 1 week writing it out and debugging
16:33:33 <thoughtpolice> ddarius: okay; sorry to be a bother but just as an example, say o = [X -> Bool, (Y->Y) -> Bool, Z -> Nat], S = X -> Nat, T = (Y->Y) -> Z, o would unify the equation S = T since o(S) == Bool -> Nat == o(T) == Bool -> Nat, correct?
16:33:39 <Baughn> darrint: Yes. You get that from code like "let x=x in x"
16:33:39 <Saizan> darrint: evaluating an expression?
16:33:41 <Jedai> Absolute0: I know Python and Ruby, and I can tell you that Haskell is actually more expressive, and having the compiler do a lot of the unit testing you would have to do in Ruby and Python make the development actually faster
16:33:44 <Cale> debugging was made much much simpler by the type system
16:34:09 <Baughn> darrint: Or, less obviously, "let fibs = 1 : zipWith (tail fibs) fibs in fibs"
16:34:17 <SamB> Cale: so what did you do during those first three weeks?
16:34:19 <Cale> I even had some logic errors in my register allocator caught by the type system.
16:34:20 <darrint> Saizan: The expression is just the invocation of go which has type IO LocalNode
16:34:29 <Cale> SamB: Thought about the algorithm.
16:34:44 <Jedai> Absolute0: Note that in Haskell you also have a REPL, you have an excellent time traveling debugger, ...
16:34:45 <SamB> did you scribble things on pieces of paper?
16:34:46 <Absolute0> What about scala vs. Haskell? :P
16:34:47 <Cale> SamB: Most of my work was on a whiteboard, and the good ideas went into the documentation which I wrote.
16:34:58 <Cale> (In LaTeX)
16:35:04 <ddarius> thoughtpolice: Except that (Y->Y) -> Bool is unlikely to be a substitution (usually only variables are substituted for), yes.
16:35:08 <Saizan> darrint: well as Baughn is saying that's an exception thrown when ghc can detect a loop
16:35:12 <darrint> Ok. The problem I have is I'd like to invoke the debugger since this is happening withi IO, but ghci is catching the error immediately and won't let me debug. Any way to insist on looping?
16:35:15 <gwern> hm. it appears to be impossible to search in google for $BROWSER
16:35:19 <SamB> caaloh, you scribbled on the wall
16:35:25 <SamB> er, Cale
16:35:31 <dobblego> Absolute0, Scala's type system is not as clever or powerful and is much more verbose (to appease the Java stoopids)
16:35:34 <Cale> SamB: essentially, yes.
16:35:36 <SamB> that's pretty mmuch the saem thing as piecess of paper
16:35:42 <Cale> SamB: right
16:35:51 <Cale> SamB: In fact, paper was often involved as well :)
16:36:05 <thoughtpolice> ddarius: okay, I was just trying to think up something right quick; thanks a bunch. :)
16:36:07 <Absolute0> Alright guys you've convinced me!
16:36:20 <Absolute0> I am officially learning Haskell. :P
16:36:37 <glen_quagmire> jave + eclipse can't be beaten
16:36:41 <Cale> Absolute0: Martin Odersky clearly knows what he is doing with Scala, and it's a decent language. It's limited in various ways relative to Haskell, but also has some pretty cool features.
16:36:43 <ddarius> dobblego: There are many things Scala's type system can do that Haskell's can't (and vice versa)
16:36:47 <SamB> oh no!
16:36:54 <dobblego> ddarius, s/many/few
16:36:56 <SamB> I forgot to make sure I learned haskell officially
16:37:13 <ddarius> SamB: Now you won't get credit for it.
16:37:17 <Cale> SamB: Learning it unofficially doesn't count!
16:37:18 <Absolute0> Cale: what is haskell limited in?
16:37:21 <dobblego> also, Scala's type inferencer is a joke in comparison to Haskell
16:37:27 <SamB> how do I learn it officially?
16:37:39 <Absolute0> glen_quagmire: Java + IDEA ftw!
16:37:43 <glen_quagmire> SamB: you start to blog about it
16:37:46 <Baughn> darrint: Ah. Debugging, the eternal thorn in my side - I don't think that's possible (yet), but I could be wrong.
16:38:03 <Baughn> darrint: To the degree you /can/ get backtraces, you should be able to trace this exception just like any other one
16:38:09 <Cale> Absolute0: Well, it doesn't really have a record system, or variants. (Though there are things which mimic records in a pale sort of way.)
16:38:14 <ddarius> dobblego: Scala's type inferencer is trying to solve a harder problem in a more hostile environment.
16:38:15 <SamB> does twitter posting count?
16:38:28 <Cale> Absolute0: That would be one of my top priorities for additional language features.
16:38:32 <dobblego> ddarius, I understand that, but even then, it fails miserably in some areas
16:38:43 <ddarius> dobblego: I'm sure it could be better.
16:38:47 <glen_quagmire> haskell learning plan ==> monad tutorial ==> XML ==> web app ==> back to java
16:38:51 <Absolute0> Cale what is a record system or variants? :)
16:39:00 <dobblego> ddarius, we whinge about it all the time in #scala if you're interested ;)
16:39:27 <ddarius> dobblego: I'm sure Scala's type system has an employment theorem.
16:39:38 <darrint> Baugh: What's next for me to try? Right now ghci only outputs the loop message. Is there another command or setting I need to know?
16:39:43 <Cale> Absolute0: Well, records are values which hold a bunch of labelled fields of various types, and which can be easily extended to include additional data without affecting code that doesn't need to know about that new data.
16:40:06 <Cale> Absolute0: Like the rows of a database, essentially.
16:40:20 <Absolute0> and variants?
16:40:26 <Cale> Haskell has product types, but they're very rigid.
16:41:08 <Absolute0> Cale: you mean like a "struct" in C?
16:41:19 <Absolute0> or objects? :)
16:41:20 <Cale> Absolute0: yes, that would be a relevant comparison
16:41:28 <Cale> In Haskell, we can write, for instance:
16:41:47 <Cale> data Person = P { name :: String, age :: Integer }
16:41:53 <Jedai> Absolute0: Well struct in C are ok (we have record) but objects aren't
16:41:59 <Baughn> darrint: http://haskell.org/haskellwiki/Debugging <-- Read this, in particular section 6
16:42:00 <lambdabot> Title: Debugging - HaskellWiki
16:42:02 <Cale> But then name and age become functions specific to the type Person.
16:42:11 <Cale> (and so can't be reused for other record types)
16:42:16 <SamB> there, I made a twitter post about Haskell. is it official yet?
16:42:58 <Baughn> SamB: No. You must deny all your heathen languages and take only Haskell to be your god.
16:43:00 <Cale> specifically, name and age become functions of types  Person -> String and Person -> Integer
16:43:02 <Absolute0> SamB: where?
16:43:02 <darrint> Baughn: Sweet. That should be more fun than playing the comment stuff out game. Much thanks.
16:43:05 <Cale> (respectively)
16:43:14 <Jedai> Absolute0: We would like to create a "data Child = C {  name :: String, age :: Integer, mother :: Person }" and be able to give it to function that takes Person
16:43:50 <SamB> Baughn: you hush
16:44:05 <SamB> programming language of choice, sure
16:44:12 <SamB> well, for most things
16:44:14 <Jedai> Absolute0: There's lot of propositions to add this kind of functionality, the only problem is agreeing on which proposition to implement...
16:44:24 <SamB> I'll still be writing C programs in C for the foreseeable future!
16:44:37 <Baughn> darrint: Note that the ghci debugger acts differently* on compiled and interpreted code. There should be some way of forcing it to interpret, but for now, make sure there aren't any compiled files lying around for it to read (unless you're sure that code works and want higher speed.)
16:44:56 <SamB> they tend to either be too long-winded in Haskell or require overly-clever tricks (see augustss' blog)
16:44:58 <Baughn> darrint: * for values of "differently" meaning "not at all"
16:45:30 <Cale> Absolute0: Variants are values which can be any one of a number of types, and are labelled in a similar way to records. When functions match on variants, they always define a fall-through case because they can't possibly cover all the possibilities. These are typically useful for exceptions, where you'd like to always be able to extend the system with new cases, while keeping the existing code working, doing some defa
16:45:31 <Cale> ult thing for values it doesn't know about.
16:45:35 <Absolute0> SamB: C programs in C? :P
16:45:50 <Cale> Absolute0: So these are the 'open' versions of the kinds of types Haskell already has.
16:46:16 <Cale> Haskell datatypes are 'closed' in the sense that you define them once, and can't extend them easily without modifying all your code.
16:46:23 <Cale> This is usually a good thing, but sometimes gets in the way.
16:46:47 <Cale> (In that it gets you to think about the additional cases or values you added)
16:46:58 <Absolute0> I need to save this whole irc session, I am too tired to think :(
16:47:00 <darrint> Baughn: Does the debugger follow threads after forkIO?
16:47:10 <Baughn> Absolute0: If you *do* need an extensible datatype for some reason, there are several methods - existentials, to begin with.
16:47:16 <Baughn> darrint: No idea
16:47:21 <Cale> That's what I'd say is Haskell's largest limitation, at least that I can see, at the moment.
16:47:33 <glen_quagmire> typeclasses are similar to java
16:47:43 <Absolute0> Cale: join the team and change it as you like. :)
16:47:59 <Absolute0> it is open source is it not?
16:48:00 <Cale> Absolute0: Well, yeah, I would except that I don't understand GHC :)
16:48:06 <glen_quagmire> limitation of haskell as i see it is: it's hard
16:48:12 <Cale> I've been looking at the GHC source code a bit lately.
16:48:17 <Cale> glen_quagmire: hehe
16:48:18 <Baughn> Cale: To be fair, C structs aren't extendable either, and ADTs are at about that level of sophistication.
16:48:21 <Cale> glen_quagmire: It's just different :)
16:48:26 <Cale> Baughn: oh, yes
16:48:32 <byorgey> Cale: what's the ghc source like?  scary? =)
16:48:43 <Cale> I was saying that C structs are similar to Haskell's datatypes with only one case.
16:48:49 <ddarius> byorgey: Go look for yourself.
16:48:51 <Cale> byorgey: It's pretty scary.
16:48:58 <byorgey> ddarius: hehe, I know
16:49:01 <Baughn> It just doesn't seem to fit with haskell. The *rest* of the language is a joy to use; data statements make me want to cry.
16:49:11 <SamB> see, there is a reason why I hack on jhc
16:49:15 <Cale> I think there may even still be some code in there which uses monads, but was written prior to the Monad typeclass.
16:49:21 <byorgey> woah
16:49:22 <Absolute0> every sys admins nightmare: http://mistywindow.net/wp-content/uploads/2007/11/yellow-cable-wall.jpg :)
16:49:23 <lambdabot> http://tinyurl.com/2kf6d7
16:49:26 <Peaker> Baughn, because of the typical repeat of the type/data constructor?
16:49:36 <Cale> Absolute0: ahahaha!
16:49:46 <SamB> this way I can think "was this written by some kind of deranged monkeys?"
16:49:49 <Baughn> Peaker: No, that's fine. No, because of the namespace pollution from accessors
16:50:06 <darrint> I am so freaking cool. I'm debugging my code by putting print statements in. :-D
16:50:08 <Peaker> Baughn, Ah, I use tiny modules for namespacing - seems to work nicely
16:50:14 <ddarius> Cale: If the used the Monad class you wouldn't be able to build it with a pre-Monad version of GHC.
16:50:15 <Baughn> Absolute0: Whoa. I can only assume they're labeled.
16:50:16 <Peaker> Baughn, and I import everything qualified
16:50:17 <SamB> rather than "I'll never be smart enough to understand this stuff"
16:50:22 <Peaker> Baughn, Or with an explicit symbol list
16:50:34 <glen_quagmire> can you define multiple modules in one file? that might solve namespace pollution
16:50:35 <Cale> ddarius: haha
16:50:42 <araujo> hello
16:50:46 <Baughn> Peaker: That's *a* solution, but it smells of workaround.
16:51:05 <Peaker> Baughn, Ofcourse you also plain-old namespace-prefix 'em with the data's name
16:51:06 <SamB> Baughn: what about ADTs makes you want to cry exactly?
16:51:13 <SamB> oh, the namespace stuff
16:51:18 <lament> preventing namespace pollution is the best feature of OO languages
16:51:20 <lament> foo.bar()
16:51:30 <SamB> yeah, that does get a bit annoying
16:51:35 <Baughn> SamB: I keep wanting to use generic names for accessors. The language is statically typed - the compiler should be able to figure out which one I mean.
16:51:41 <SamB> but what can you do?
16:51:43 <ehird> lament: Haskell dose that..
16:51:44 <ehird> :p
16:51:45 <ehird> *does
16:51:47 <Peaker> Namespaces and names are artifacts of serializing program graphs into a textual medium
16:52:00 <Peaker> names are a hack :)
16:52:00 <SamB> Peaker: um, no
16:52:04 <SamB> names are needed
16:52:05 <lament> a language without namespaces is unusable
16:52:14 <SamB> we wouldn't understand the code with no names
16:52:14 <Peaker> SamB, why?
16:52:17 <lament> haskell sort of has them with modules
16:52:22 <Baughn> Peaker: Frail human intellects
16:52:23 <Peaker> if names are comments, then there are no name collisions
16:52:26 <SamB> if we didn't need names, we'd do like a compiler and use x21516
16:52:31 <SamB> for a name
16:52:39 <wagle_home> thats a name
16:52:42 <Peaker> SamB, Names currently are both comments and a way to link graph entities - they should become only the first
16:52:48 <wagle_home> program with diagrams
16:52:55 <SamB> (you have no way of knowing that I didn't copy and paste that from JHC output)
16:52:58 <Peaker> that way you don't need namespacing rules /etc
16:53:02 <Baughn> SamB: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields <-- Well, you can do this, but it isn't quite enough
16:53:02 <lambdabot> Title: 8.3. Syntactic extensions, http://tinyurl.com/y6v6by
16:53:08 <ehird> darrint: Seen Debug.Trace?
16:53:35 <glen_quagmire> data A a = A { age :: Int }     let foo = A 15 in foo.age
16:53:39 <Cale> Peaker: I disagree. :)
16:53:45 <ehird> SamB: Peaker says that variable namse should be translatable
16:53:48 <darrint> ehird: I think it's happening in a thread, so I'm figuring out how to get that behavior at a ghci prompt now. Then the normal break/trace stuff might work.
16:53:49 <glen_quagmire> (A 15).age
16:53:50 * lament wants foo.bar
16:53:57 <ehird> and that the program should look like how a user likes looking at programs
16:53:59 <Peaker> Cale, elaborate? :)
16:54:06 <ehird> I said that was a headache for collaboration. He ignored me.
16:54:08 <lament> (foo is a value of which bar is a field)
16:54:13 <SamB> Peaker: I don't really want to participate in programming projects with people who don't understand english
16:54:21 <Baughn> glen_quagmire: That will break all sorts of code that uses "head.sort" or whatever
16:54:22 <glen_quagmire> . is composition
16:54:28 <glen_quagmire> haha
16:54:32 <Peaker> ehird, I didn't ignore you - you can simply either fix the discussion medium to fix the names, or use a canonical one for discussions
16:54:46 <ehird> Peaker: So now you have to understand 2 syntaxes & variable names
16:54:48 <Peaker> SamB, do you want to be able to use API's designed by people who don't know English?
16:54:53 <wagle_home> hmm..  is a name a way to refer to something that you didnt know about (or didnt exist) when you were created?
16:54:54 <darrint> ehird: NIce though. Might need that later.
16:55:08 <glen_quagmire> let's think of a way of using monads for namespace pollution solution
16:55:09 <SamB> Peaker: not really
16:55:14 <Peaker> ehird, With the second option, possibly - or you give up communication with them. Currently, you simply can't use Chinese API's
16:55:22 <SamB> I wouldn't be able to read the documentation then
16:55:29 <Baughn> Peaker: If they don't know english, their comments will be useless to me
16:55:31 <ehird> darrint: It's very simple. 'import Data.Trace', then 'trace a b == b' but you get a printed out somehow
16:55:32 <Peaker> SamB, No, documentation would be written by Chinese who know English
16:55:37 <Cale> Peaker: Names are how we introduce abstraction. Sure, we're really manipulating code-graphs, and sometimes that's a useful way to look at things, but those code graphs are a total mess if you strip out the names, or even if you just change the names randomly.
16:55:42 <ehird> Peaker: This is why most APIs are in English. Suprise!
16:55:54 <ehird> Peaker: So yours makes the situation worse.
16:55:55 <SamB> Peaker: you can't write APIs in chinese
16:55:57 <Peaker> Baughn, yeah - but you can see comments written by those  who know English and Chinese
16:56:01 <Cale> Peaker: The fact that I can refer to 'map' and learn only once what that means is important.
16:56:17 <Cale> Or 'filter', say.
16:56:20 <Peaker> ehird, Well, most APIs are in English, because of names :-)
16:56:21 <Baughn> Peaker: Sounds like a recipe for disaster to me. I'd rather work with people willing to spend the time to learn english
16:56:27 <lament> you mean Prelude.map and Prelude.filter :)
16:56:47 <SamB> why can't the people who know english and chinese just write the program in the first place?
16:56:48 <glen_quagmire> > Prelude . map (+ 1) [1]
16:56:49 <lambdabot>   Not in scope: data constructor `Prelude'
16:56:55 <Baughn> Peaker: Otherwise /they/ won't be able to use /our/ APIs. Programming is, happily, mostly a one-language world - let's keep it that way.
16:56:56 <Cale> And I might generalise it at some point, say to fmap, but if someone changed the name to qulb, I'd have a hard time locating it.
16:57:01 <lament> or even Data.List.Map... haskell is a mess
16:57:04 <Peaker> Cale, Names are used to link the graph AND to comment on the meaning.  I agree we need the latter, but the former need not be done by names
16:57:10 <SamB> or at least translate it, in it's entirety, into english before inflicting it upon me
16:57:18 <Cale> Peaker: why not do it with names?
16:57:22 <lament> > Prelude.map (+ 1) [1]
16:57:23 <lambdabot>  [2]
16:57:26 <Baughn> glen_quagmire: That case is disambiguated by capitalization
16:57:32 <Cale> Peaker: It's the most natural thing we all do in natural languages.
16:57:52 <Cale> Peaker: Using arrows or something would result in this: http://mistywindow.net/wp-content/uploads/2007/11/yellow-cable-wall.jpg
16:57:53 <lambdabot> http://tinyurl.com/2kf6d7
16:57:54 <Peaker> Baughn, its already not that way - and you are excluded from some API's, and the phenomena is growing.  e.g: Python3 now has unicode identifiers
16:57:57 <Peaker> Baughn, for that purpose
16:57:59 <lament> Cale: :D
16:58:03 <glen_quagmire> oh so dot accessor only works for Cap.Cap.Cap.notCap
16:58:08 <Peaker> Cale, I don't propose displaying it with arrows
16:58:13 <Cale> I submit Subtext 1 as an example of how much of a mess that becomes :)
16:58:14 <SamB> Cale: ooooh, spaghetti!
16:58:19 <glen_quagmire> :t (Prelude.)
16:58:21 <lambdabot> Not in scope: data constructor `Prelude'
16:58:27 <darrint> Well, I now know for sure, ghci's debugger does not trace into threads. I do have a backtrace now. Thanks all.
16:58:31 <Peaker> Cale, we shouldn't use names for that because it makes renaming difficult and  it requires namespacing rules
16:58:47 <Cale> Renaming should be difficult.
16:58:50 <Peaker> Cale, And it binds the program to just one name, not allowing alternate names to exist in differing presentations, etc
16:59:09 <SamB> Peaker: that generally confuses me
16:59:10 <Peaker> Cale, Subtext 1 is presented as a mess, but obviously you can render a Subtext program with a C syntax :-)
16:59:22 <lament> Peaker: creating alternate names for stuff is really easy.
16:59:37 <lament> you could write a program to generate wrapper modules for you.
16:59:42 <Cale> Peaker: Of course, if you start using names to make the links again, then you'll be okay :)
16:59:59 <Cale> (It'll just be a fairly simple functional programming language)
17:00:13 <Baughn> Peaker: How are you going to serialize source code like this? GUIDs?
17:00:14 <Peaker> Cale, Whether you use names or links and names as comments is a technical detail, if you don't use the extra features allowed by the disconnect
17:00:21 <Peaker> Baughn, I don't know, does it matter?
17:00:29 <Baughn> Peaker: Yes.
17:00:34 <ehird> Baughn: He doesn't want to serialize it. He wants an editor that operates on the AST directly, too.
17:00:38 <Peaker> lament, I don't think that's easy or manageable
17:00:39 <SamB> anyway, I would refuse to use a language with no names
17:00:44 <ehird> Baughn: His usage case for it was really context-switch-ful and awkward
17:00:54 <ehird> Peaker: Neither is your idea
17:00:54 <Baughn> Peaker: Eventually, someone on *another computer* will want to read your source. ^^;
17:01:03 <lament> Peaker: better than having graphical source code :)
17:01:06 <Peaker> ehird, there's a difference between an AST and a semantic model
17:01:07 <Cale> Naming things is a very very powerful technique for understanding.
17:01:14 <Baughn> ehird: The editor is a very good idea. A very old one, of course, but still good.
17:01:33 <SamB> the Smalltalk idea of having translations for symbols into different languages was better
17:02:03 <glen_quagmire> i wonder how non english speakers program in a language where variables should be written in english alphabet
17:02:07 * Baughn wouldn't mind if non-english languages were simply outlawed by the new world order
17:02:07 <Peaker> lament, "Non-textual" is often confused with "graphical". "non-textual" just means the code is not edited in a serialized form.. Typically you edit it when serialized to text, but instead you should be able to edit it in any number of presentations/serializations - whatever fits the current task
17:02:08 <Cale> It's almost the only technique we really have.
17:02:18 <lament> glen_quagmire: with difficulty.
17:02:36 <Peaker> lament, for example, you should be able to, with a click of a button, show/hide type declarations, switch between exception-handling view and normal view, flow chart view, etc.
17:02:41 <SamB> glen_quagmire: they either drop the accents (if they use the same basic letterforms) or they use english
17:02:53 <lament> Cale: yes. Hence, haskell is evil.
17:02:59 <Cale> lament: How so?
17:03:06 <Peaker> Cale, Names will remain, they will simply serve only as comments rather than links
17:03:08 <monochrom> No one types in code serially anyway.
17:03:10 <Baughn> glen_quagmire: If they intend for anyone other than themselves to read it, they'll use english. For extra job security they might avoid it.
17:03:13 <lament> Cale: i love how in python the _default_ import of modules is qualified, and unqualified imports are strongly discouraged.
17:03:16 <SamB> glen_quagmire: to compensate, they write the comments in some encoding that nobody else can read
17:03:26 <Peaker> lament, Ditto!
17:03:35 <ehird> Peaker: We name things in real life. Why make a programming language offensive to humans?
17:03:36 <Cale> I really dislike that :)
17:03:38 <Peaker> lament, import * is almost frowned upon
17:04:06 <lament> ehird: we also constantly do "side-effects" in real life.
17:04:09 <Peaker> ehird, In natural language, we are limited to a serialized textual form, in computing, we aren't
17:04:10 <Cale> I would rather use module context to determine what names mean.
17:04:17 <SamB> well, Python doesn't have checking for ambiguous names...
17:04:22 <ehird> Peaker: Natural language is.. pretty natural.
17:04:30 <SamB> due to the imperative nature of it's imports
17:04:32 <Peaker> Cale, Having a really simple editor search reveal where each name is coming from is a _really_ useful feature
17:04:33 <Cale> It's already painful enough to have to use M.fromListWith and so on.
17:04:38 <ehird> lament: Yes, but it's useful to abstract them with a formal basis.
17:04:47 <Peaker> ehird, its limited to the medium that its transmitted in
17:04:52 <Cale> Of course, I think using '.' as module path separator was a huge mistake also
17:04:53 <lament> Cale: the beauty of that approach is that you can easily name similar-behaving functions in different modules the same.
17:04:54 <glen_quagmire> how do you say functional programming in chinese?
17:04:59 <Peaker> ehird, And often we don't use names and instead use diagrams, when we can
17:05:07 <Cale> If we'd chosen something like | then it would maybe be a little more tolerable to read.
17:05:09 <ehird> Peaker: then why do we write and talk with the same language serialized in different forms?
17:05:15 <ehird> because we decided it was Good.
17:05:21 <Peaker> ehird, We don't always do that
17:05:25 <ehird> Cale: How about.. suprise - '/'?
17:05:27 <Peaker> ehird, Why are diagrams used?
17:05:28 <ehird> Data/Map
17:05:32 <Cale> ehird: division?
17:05:35 <Peaker> ehird, And visualizations?
17:05:36 <lament> Cale: which you can do in haskell, but it gets unpleasant because you have to _know_ when there's a potential conflict, and do something about it, even when you're not using the same-named functions.
17:05:46 <Peaker> ehird, if natural language fits all purposes well?
17:06:03 <Cale> lament: The compiler will tell you
17:06:15 <darrint> Annnnd there's my problem. Thanks again all.
17:06:23 <Cale> darrint: hm?
17:06:28 <lament> Cale: sure, but i shouln't worry about that.
17:06:29 <monochrom> "multiply x by y into z" was as close to natural language as programming got to.  (hint: it became a laugh stick)
17:06:33 <SamB> lament: I don't think the compiler cares about *potential* conflicts
17:06:42 <SamB> in fact, I know it doesn't
17:06:48 <Cale> lament: and you shouldn't
17:06:48 <darrint> Cale: A few folks were helping me with the debugger and loop detection.
17:06:55 <Peaker> ehird, if you're willing to accept that textual serialization is not the best medium to communicate everything, even not all programs, then a natural consequence is that you would want to be able to view, at least part of the time, your programs in non-textual form
17:06:57 <Cale> lament: Let the compiler complain and then fix it :)
17:07:00 <SamB> it only cares when you *use* the conflicting names
17:07:00 <ddarius> monochrom: There's Inform 7 or whatever.
17:07:18 <SamB> ddarius: that *is* the name
17:07:27 <ddarius> SamB: Yay me
17:07:28 <SamB> I think I prefer Inform 6 ;-)
17:07:30 <lament> Cale: i don't know. It seems dirty.
17:07:32 <laura22> hm the most general type of \x y z -> head (map x y) y  is: (a -> [a] ->b) -> [a] -> c -> b. how come?
17:07:33 <Peaker> ehird, the only possible way to have multiple views of the same program, is one where the program presentation is disconnected from its content
17:07:51 <SamB> lament: that's the same thing we have a typesystem for
17:07:55 <lament> Reading inform 7 source code is unpleasant because it gets into the "uncanny valley"
17:07:58 <Peaker> ehird, And even if you do prefer the textual presentation - it is still possible to use that exclusively (and you still gain the advantages of a smarter editor)
17:07:59 <monochrom> Don't get me wrong.  It was awefully successful.  Precisely because it appealed to managers' love of natural language, it was widely adopted.  And precisely because of the same reason, we real programmers regret it or laugh at it.
17:08:15 <Cale> lament: Of course, you eventually figure out that some modules can't be imported unqualified, like Data.Map, but for the most part, it's not worth worrying about.
17:08:17 <SamB> lament: hmm, I haven't read too much of it
17:08:29 <SamB> I tried to port the Ruins example though
17:08:31 <Peaker> ehird, (and collaboration on the same program with people who prefer to view it differently, too)
17:08:36 <lament> SamB: the problem is, it VERY OBVIOUSLY is still a programming language
17:08:49 <SamB> apparantly Ruins is an example of all the crazy tricks you can do in Inform 6
17:08:50 <ehird> [01:07] *** laura22 is now known as laura85.
17:08:51 <ehird> funniest thing all day
17:08:52 <SamB> well, a lot of them
17:09:01 <idnar> given how hard it is to use natural language for communicating with *humans*, it seems obvious that using it for communicating (FSVO "communicating") with a computer would be disastrous
17:09:05 <lament> but it looks like english, except with really odd sentences since it's not actually english
17:09:08 <adu> Baughn: there is no new world order
17:09:10 <Cale> Peaker: While I agree about being able to represent programs in multiple ways, I really consider names to be far more important than you're giving them credit for.
17:09:14 <SamB> it doesn't include changing parsable names dynamically
17:09:23 <laura85> ehird, heh ^_^ indeed
17:09:40 <Peaker> Cale, Names serve multiple purposes. Nobody disputes their importance as comments
17:09:53 <Baughn> adu: That's what they all say - right before the /screaming/ starts!
17:10:08 <idnar> There are only two hard things in Computer Science: cache invalidation and naming things.
17:10:09 <Peaker> Cale, However, whether or not you use the name or a link to represent the connection is a technical detail until you start doing fancy stuff like renames, where links are much easier
17:10:12 <Peaker> Cale, (and other things)
17:10:12 <laura85> seriously, i have no idea how why that's the most general type...
17:10:29 <dobblego> when quickcheck performs shrinking on a type, such as [Int], it may shrink the head value while a property falsifies, but the property may hold for some values, in which case, removing the head value would be another way to shrink as if it were traversing a tree; but the interface for shrinking does not seem to permit this - has this been discussed before?
17:10:37 <adu> Baughn: :P
17:10:38 <Cale> laura85: why what's the most general type?
17:10:40 <monochrom> Anyway, by harping on "natural language" and even "even managers can write programs because it's so... natural!" you can successfully sell your language.  You can also sell snake oil.  (Same difference.)
17:10:55 <Peaker> Cale, why do you dislike dot as a module separator? Because it looks like composition?
17:11:00 <Cale> Peaker: yes
17:11:05 <adu> Baughn: I think you are the NWO
17:11:06 <laura85>  Cale, \x y z -> head (map x y) y  :: (a -> [a] ->b) -> [a] -> c -> b
17:11:10 <lament> monochrom: please don't confuse natural-language PLs with Cobol.
17:11:15 <laura85> Cale, but I don't see it :(
17:11:18 <Cale> Peaker: composition is by far the most frequently used operator symbol for me
17:11:23 <Peaker> Cale, I see
17:11:25 <lament> monochrom: Cobol doesn't suck because it tries to use natural language. Cobol sucks because it sucks.
17:11:38 <Cale> laura85: okay
17:11:46 <Peaker> Cale, Use View->Options, "Module lookup syntax", replace "dot" with "|" :-)
17:11:53 <glen_quagmire> natural languages are products of evolution. programming languages are products of Microsoft
17:11:57 <Peaker> Cale, futuristic, ofcourse :)
17:12:10 <Cale> laura85: So you're taking the head of a list (map x y)
17:12:18 <Cale> laura85: and then applying that to the value y
17:12:28 <Cale> laura85: So the list must have functions inside it
17:12:31 <Peaker> Cale, its another example of why presentation ought to be disconnected from the content :)
17:12:52 <Cale> laura85: also, because map is applied to x and y, x must be a function, and y must be a list
17:13:32 <ehird> laura85: what's z for
17:13:55 <Cale> laura85: So, let's suppose that x :: A -> B, and y :: [A] (note they must be the same A, since we're mapping that function over the list)
17:14:14 <Cale> Then map x y :: [B]
17:14:38 <Cale> But  head (map x y) must itself be a function which can be applied to y
17:14:49 <Cale> So B = [A] -> C, for some type C
17:15:05 <Cale> and there are no more constraints on these parameters
17:15:26 <lament> glen_quagmire: programming languages are also products of evolution.
17:15:33 <ehird> Cale: Can you be my evaluation engine & type inferrer
17:15:36 <ehird> you are very good at it
17:15:46 <Cale> So we have that x :: a -> ([a] -> c)
17:15:52 <Cale> and y :: [a]
17:15:58 <Cale> and z can be anything at all
17:16:05 <Cale> and the result will be of type c
17:16:19 <Cale> laura85: does that clear things up?
17:16:32 <laura85> Cale, still reading ^^
17:16:53 <monochrom> Cale and lambdabot are now one.
17:17:12 <Cale> Mwahahaha! We are unstoppable!
17:17:23 <shachaf> That explains all the changes in lambdabot.
17:17:26 <shachaf> @ty (.)
17:17:27 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:17:33 <monochrom> Don't forget Cale's mbot in #math.  He can integrate calculus too.
17:18:12 <ehird> Cale: Please evaluate (let forever a = a >> forever a in forever (return 2))
17:18:18 <monochrom> onoes
17:18:19 <Cale> % Integrate[Sqrt[Cos[x]],x]
17:18:21 <ddarius> Cale is now known as SkyNet
17:18:22 <mbot> Cale: 2*EllipticE[x/2, 2]
17:18:41 * ehird waits. and waits. some more.
17:19:09 <monochrom> I think that if you wait, you lose. :)
17:19:26 <Cale> % DSolve[y''[x] + y'[x] + y[x] == 0, y[x], x]
17:19:28 <mbot> Cale: {{y[x] -> (C[2]*Cos[(Sqrt[3]*x)/2])/E^(x/2) + (C[1]*Sin[(Sqrt[3]*x)/2])/E^(x/2)}}
17:19:29 <ddarius> ehird: That's an ambiguously typed expression
17:19:38 <Jedai> @ty \x y -> head (map x y) y
17:19:39 <lambdabot> forall a t. (a -> [a] -> t) -> [a] -> t
17:19:41 <mbot> forall a t. (a -> [a] -> t) -> [a] -> t
17:19:43 <Cale> hehe
17:19:48 <Cale> mbot: @part #haskell
17:19:59 <TheLorax> % 1/0
17:20:03 <ehird> ddarius: I know, I was waiting for Cale to tell me that
17:20:03 <ehird> :D
17:20:06 <TheLorax> pwned
17:20:17 <Cale> % 1/0
17:20:18 <mbot> Cale:
17:20:18 <mbot>                                  1
17:20:18 <mbot> Power::infy: Infinite expression - encountered.
17:20:18 <mbot>                                  0
17:20:18 <mbot> ComplexInfinity
17:20:25 <Cale> mbot: @part #haskell
17:20:37 <ddarius> Power::infy?
17:20:43 <idnar> @type (let forever a = a >> forever a in forever (return 2)
17:20:44 <lambdabot> parse error (possibly incorrect indentation)
17:20:46 <Cale> ddarius: The name of the exception.
17:20:48 <idnar> @type let forever a = a >> forever a in forever (return 2)
17:20:49 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b
17:20:52 <monochrom> That's a cool error message!
17:21:04 <ddarius> Yes, but why is it called _Power_::infy
17:21:15 <Cale> ddarius: because 1/0 is the same as Power[0,-1]
17:21:23 <lament> also why is it called "infy"
17:21:27 <monochrom> It says "1 over 0" but also uses the "over" line to say something. :)
17:21:42 <ddarius> lament: They ran out of i's and t's and n's.
17:22:08 <monochrom> This is nifty and infy.
17:22:17 <ehird> mbot - mathematica?
17:22:29 <ehird> I hate mathematica :( (and Wolfram is really, really pretentious)
17:22:29 <lament> monochrom: it's just a preview of the capabilities of Peaker's future language
17:22:37 <Cale> % FullForm[Hold[1/0]]
17:22:37 <monochrom> haha
17:22:39 <mbot> Cale: FullForm[Hold[1/0]]
17:22:44 <Cale> oh, d'oh
17:22:45 <Cale> hehe
17:22:46 <ehird> lament: customizable divide-by-zero behaviour
17:22:50 <Cale> I have it applying InputForm
17:22:52 <ehird> and customizable ascii-art 1/0 display
17:22:53 <Cale> So you can't see :)
17:23:16 <Cale> But it would have printed  Hold[Times[1,Power[0,-1]]]
17:23:25 <Cale> mbot: @part #haskell
17:23:44 <laura85> Cale, thanks a lot ^^
17:23:50 <Cale> laura85: No problem :)
17:23:56 <mauke> :t State
17:23:57 <lambdabot> forall s a. (s -> (a, s)) -> State s a
17:25:07 <mauke> > execState (replicateM 3 (State $ splitAt 2)) [0 .. 9]
17:25:07 <lambdabot>  [6,7,8,9]
17:25:13 <mauke> > evalState (replicateM 3 (State $ splitAt 2)) [0 .. 9]
17:25:13 <lambdabot>  [[0,1],[2,3],[4,5]]
17:27:45 <Jedai> @hoogle execState
17:27:45 <lambdabot> Control.Monad.State.Lazy.execState :: State s a -> s -> s
17:27:45 <lambdabot> Control.Monad.State.Strict.execState :: State s a -> s -> s
17:27:45 <lambdabot> Control.Monad.State.Lazy.execStateT :: Monad m => StateT s m a -> s -> m s
17:28:09 <Jedai> @hoogle runState
17:28:09 <lambdabot> Control.Monad.State.Lazy.runState :: State s a -> s -> (a, s)
17:28:09 <lambdabot> Control.Monad.State.Strict.runState :: State s a -> s -> (a, s)
17:28:09 <lambdabot> Control.Monad.State.Lazy.runStateT :: StateT s m a -> s -> m (a, s)
17:28:50 <Jedai> @hoogle evalState
17:28:50 <lambdabot> Control.Monad.State.Lazy.evalState :: State s a -> s -> a
17:28:50 <lambdabot> Control.Monad.State.Strict.evalState :: State s a -> s -> a
17:28:50 <lambdabot> Control.Monad.State.Lazy.evalStateT :: Monad m => StateT s m a -> s -> m a
17:34:55 <Peaker> what are the Lazy/Strict variants of state? What part are they lazy/strict about?
17:35:13 <byorgey> Peaker: the state. =)
17:35:30 <Peaker> why would you want "strict state"?
17:35:39 <Peaker> or.. when is there a noticeable difference?
17:35:47 <byorgey> well, you could imagine a situation where you are making a bunch of updates to the state
17:35:54 <byorgey> but you don't actually need the value until much later
17:36:15 <byorgey> if you were using lazy state, it would just build up a huge thunk and only evaluate it much later, when the value was actually needed
17:36:45 <byorgey> using strict state would ensure that each update to the state is evaluated right away, which could result in better memory usage
17:36:50 <Cale> Of course if you prefer, you can use the term 'expression' in place of 'thunk'. :)
17:37:18 <Peaker> but the multiple state overrides would mean that the old state that was overridden goes into nowhereland, so the compiler can throw away its thunk?
17:37:34 <Cale> Peaker: Suppose that the new state is based on the old one.
17:37:42 <Peaker> Ah, I see
17:37:45 <Cale> Peaker: For example, if we repeatedly add 1 to the state
17:37:47 <byorgey> for example, you might say 'modify (+1)'
17:37:52 <Cale> without observing the result
17:37:57 <Peaker> In my ideal fantasy world, the compiler would know what should be strict alone :-)
17:38:23 <Cale> Peaker: and the real world isn't *so* far away, the compiler does do strictness analysis which is often good enough
17:38:55 <Cale> Peaker: But if you care very strongly that it be strict, you can use the strict version, and it'll make sure.
17:39:17 <Peaker> well, I guess the "right" way to solve the inefficiencies of laziness is to have the program specification prove which stuff will surely be evaluated eventually so they can be made strict
17:39:20 * monochrom tries to think of examples to show the difference, and also to show what they don't do.
17:39:28 <Peaker> (if their result is smaller than the inputs)
17:39:54 <Cale> Peaker: Right, it's just often hard to know that without actually doing the evaluation.
17:40:44 <Peaker> let the human prove it
17:40:48 <Cale> So you make a guess which is usually lazier than necessary, and then profile, and then strictify things if necessary.
17:41:30 <SamB> Peaker: rather than proving that, maybe it's a good idea to prove what won't do much harm to evaluate
17:42:00 <SamB> perhaps empirically!
17:42:12 <ehird> hmm
17:42:17 <ehird> let's implement call-by-future haskell
17:42:23 <ehird> y/n
17:42:24 <Peaker> SamB, well, the factors are: A) cost of evaluation, B) cost of deferring evaluation->cost of living input sizes C) cost of result storage.  If the compiler can be proven all of these, it can make the informed decision
17:42:40 <SamB> Peaker: another is D) is it safe to evaluate these?
17:42:43 <Peaker> SamB, it could start evaluating and "give it a shot" :-)
17:42:54 <Peaker> SamB, what would it mean that it is unsafe?
17:43:12 <SamB> well, if they might be _|_
17:43:20 <SamB> (reasonably)
17:43:25 <ehird> Hmm
17:43:27 <Peaker> SamB, Well, you can be lazy about doing something with the error
17:43:31 <ehird> What about call by reference-skell
17:43:31 <ehird> :D
17:43:33 <Peaker> SamB, but be strict about getting the error
17:43:41 <TheLorax> what is hamming :: [Integer]?
17:44:09 <TheLorax> type definition?
17:44:10 <SamB> Peaker: anyway, what you describe is probably on the order of figuring out how to parallelize a computation
17:44:20 <dobblego> TheLorax, "hamming is of type List of Integer"
17:44:30 <Cale> TheLorax: all numbers of the form 2^i 3^j 5^k
17:44:39 <Cale> oh, the type
17:44:44 <Cale> It's a list of integers, yeah
17:44:55 <TheLorax> I found this on the net but I don't see how it works
17:44:56 <TheLorax> hamming
17:44:56 <TheLorax>   = 1 : merge (map (2*) hamming) (merge (map (3*) hamming) (map (5*) hamming))
17:45:00 <Peaker> SamB, if you have two algorithms, who have differing O() on the inputs, and you are unsure which is better, you can just run them both in parallel until one is done.. Maybe similarly, as another strategy, you can try to evaluate "in the background", so if its cheap, you can throw away the inputs. The size of the result can also be known incrementally as you are evaluating
17:45:05 <hpaste>  monochrom pasted "C.Monad.State Lazy vs Strict" at http://hpaste.org/6744
17:45:19 <Cale> TheLorax: merge is a function which takes two infinite sorted lists and merges them into one infinite sorted list
17:45:31 <Peaker> SamB, (Strictness may harm memory use if the output size is larger than the inputs)
17:45:40 <Cale> TheLorax:  map (2*) is a function which multiplies all the elements of a list by 2
17:45:58 <Cale> The 1 : at the start means that the first element of the list hamming is 1
17:46:18 <Cale> and so the elements are lazily computed
17:46:32 <Cale> When you ask for the second element of the list, what happens? Well
17:46:36 <monochrom> Peaker: that is an example of State.Lazy vs State.Strict, and also what both don't do.
17:46:44 <TheLorax> ok, so say we start at 1, then the first map make sit a two?
17:46:48 <Cale> merge will need to know the first element of each of the lists it's merging
17:46:50 <TheLorax> makes it
17:46:53 <Cale> right
17:47:03 <Cale> So the first element of map (2*) hamming is 2
17:47:05 <TheLorax> and what about the next map?
17:47:17 <TheLorax> will it take 1 again?
17:47:22 <Cale> and the first element of map (3*) hamming is 3
17:47:34 <Peaker> monochrom, hmm.. Haskell seems to be an amazing platform to research interesting ideas :)
17:47:37 <Cale> and similarly, the first element of map (5*) hamming is 5
17:47:55 <TheLorax> and  the first merge merges 2 into the list 1?
17:48:01 <Cale> and merge has the behaviour that the first element of the list it produces is the least of the first elements of the lists that it is merging
17:48:02 <laura85> good night ^^
17:48:12 <Cale> laura85: g'night!
17:48:25 <Cale> So the next element of hamming is then 2
17:48:44 <Cale> and now, we can calculate the next element of map (2*) hamming, it must be 4
17:49:12 <TheLorax> but wait, at this point hamming is only 1,2
17:49:17 <Cale> right
17:49:20 <TheLorax> because there was only one merge
17:49:21 <Cale> and 2*2 = 4
17:49:24 <TheLorax> so where is the 4 coming from?
17:49:26 <TheLorax> ohh
17:49:39 <Cale> and the second element of map (3*) hamming is then 6
17:49:40 <TheLorax> what happend to the 1?
17:49:51 <TheLorax> merge ignores it?
17:49:55 <Cale> Oh, it's there
17:50:21 <Cale> But we're merging the lists which are produced from hamming by multiplying all the elements by 2, 3, and 5 respectively.
17:50:32 <Cale> The first element of hamming is 1
17:50:35 <TheLorax> ok, I think I see it now
17:50:42 <Cale> and then the following elements are given by the result of that merging
17:51:13 <Cale> To really see it, we should perhaps really put a definition of merge up here and try doing the evaluation very carefully by hand
17:51:18 <Cale> But that's the basic idea.
17:51:36 <TheLorax> Cale, I wrote my own merge. so I got htat part
17:51:43 <Cale> You start out knowing the first element, and the tail is this expression, but to know the first element of the tail only requires knowing the first element of the list.
17:52:18 <Cale> and then to know the next element of the tail, you need the next element of the list as well, but you can compute that
17:52:25 <Cale> So the whole thing unravels like that.
17:53:08 <TheLorax> yeah. definitely hard to follow the first time.
17:53:11 <Jedai> Expressing the same in an imperative language is pretty complicated and much more difficult to factorize in some functions like merge and map
17:53:21 <Cale> Perhaps easier is the Fibonacci sequence
17:53:33 <TheLorax> Cale, got that one.
17:53:34 <Cale> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
17:53:34 <Peaker> nice. I have an "int editor" declarative GUI working :)
17:53:34 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:53:35 <TheLorax> :)
17:53:36 <Jedai> Try doing it, and you'll appreciate Haskell more...
17:55:29 <TheLorax> Cale, I just tried take 10 hamming and it gave me [1 through 10]
17:56:06 <TheLorax> http://rafb.net/p/axAR4g26.html
17:56:07 <lambdabot> Title: Nopaste - tmp.hs
17:57:16 <mauke> whoa, that merge is weird
17:57:27 <Peaker> is it blasphemous to use bzr on Haskell programs? :-)
17:57:35 <TheLorax> I haven't managed to break it
17:58:03 <Cale> TheLorax: is 7 there?
17:58:31 <TheLorax> oh, sorry, didn't notice it isn't
17:58:43 <Jedai> take 10 hamming give me : [1,2,3,4,5,6,8,9,10,12]
17:58:52 <TheLorax> yeah
17:59:28 <Jedai> TheLorax: merge is slightly clearer if you use "case compare x y of"
18:00:27 <Jedai> TheLorax: Also, merge xs [] == xs, no need to continue to merge
18:00:36 <Jedai> @where hpaste
18:00:36 <lambdabot> I know nothing about hpaste.
18:00:41 <Cale> > let (x:xs) /\/ (y:ys) = case compare x y of LT -> x : (xs /\/ (y:ys)); EQ -> x : y : (xs /\/ ys); GT -> y : ((x:xs) /\/ ys) in let hamming = 1 : (map (2*) hamming /\/ map (3*) hamming /\/ map (5*) hamming in hamming
18:00:41 <lambdabot> Unbalanced parentheses
18:00:56 <Cale> > let (x:xs) /\/ (y:ys) = case compare x y of LT -> x : (xs /\/ (y:ys)); EQ -> x : y : (xs /\/ ys); GT -> y : ((x:xs) /\/ ys) in let hamming = 1 : (map (2*) hamming /\/ map (3*) hamming /\/ map (5*) hamming) in hamming
18:00:57 <lambdabot>  [1,2,3,4,5,6,6,8,9,10,10,12,12,12,15,15,16,18,18,18,20,20,20,24,24,24,24,25,...
18:01:01 <Cale> oh, right
18:01:05 <Cale> > let (x:xs) /\/ (y:ys) = case compare x y of LT -> x : (xs /\/ (y:ys)); EQ -> x : (xs /\/ ys); GT -> y : ((x:xs) /\/ ys) in let hamming = 1 : (map (2*) hamming /\/ map (3*) hamming /\/ map (5*) hamming) in hamming
18:01:05 <lambdabot>  [1,2,3,4,5,6,8,9,10,12,15,16,18,20,24,25,27,30,32,36,40,45,48,50,54,60,64,72...
18:01:42 <Jedai> also try using http://hpaste.org/ for your paste, it's much more user-friendly (syntax coloration, annotation, ...) and it's in Haskell
18:02:04 <TheLorax> Jedai, is there a command line tool like nopaste for it?
18:02:34 <Jedai> Good question, is there ?
18:02:40 <Saizan> no
18:02:45 <Jedai> If not, I could write it
18:02:47 <Saizan> only an emacs function
18:02:47 <TheLorax> I love my nopaste
18:02:56 <mauke> I've written a script
18:03:48 <mauke> http://rafb.net/p/n9tv5548.html
18:03:48 <lambdabot> Title: Nopaste - No description
18:04:25 <TheLorax> *saved
18:05:22 <Jedai> mauke: Nice :-)
18:08:23 <monochrom> Cale: loving /\/ operator :)
18:08:29 <monochrom> s/loving/lovely/
18:08:50 <Cale> :)
18:10:23 <Jedai> I usually use /\/ for an interleave operator (used to create a non-memory leaking powerset for example)
18:10:48 <joricj> is there a document that stands out in explaining how exceptions work in haskell ?
18:11:21 <SamB> @google a semantics for imprecise exceptions
18:11:22 <lambdabot> http://research.microsoft.com/~simonpj/Papers/imprecise-exn.htm
18:11:22 <lambdabot> Title: Simon Peyton Jones: papers
18:11:27 <SamB> joricj: that one
18:11:37 <joricj> thanks man :D
18:11:48 <Cale> joricj: Well, I would at least recommend having a quick look through the documentation for Control.Exception
18:11:52 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
18:11:53 <lambdabot> http://tinyurl.com/sqmlj
18:11:59 <Cale> On top of whatever else you find :)
18:11:59 <SamB> yes, that too ;-)
18:12:15 <SamB> I assumed he was looking for theory
18:12:50 <mattr__> how do I get cabal to honour `ghc-options: "main-is Mac.parrot"`
18:13:14 <joricj> yeah i wanted to know how it worked :D
18:13:20 <mattr__> it insists on me giving it a main-is option
18:13:25 <mattr__> and then it uses this instead
18:13:36 <SamB> --main-is?
18:13:42 <mattr__> grrrr
18:13:45 <mattr__> I am such a twit
18:14:49 <mattr__> hmm, didn't help though
18:14:59 <SamB> too bad
18:15:04 <monochrom> I learned everything from Cale's url.
18:15:33 <SamB> monochrom: you never read the paper?
18:15:44 <monochrom> No.
18:16:42 <SamB> the paper somehow ends up assigning a semantics to nontermination that results in *any* exception being a valid result of nonterination...
18:16:48 <SamB> er. nontermination...
18:16:48 <monochrom> OK I lied.  I learned everything from the url plus a bit of experimentation.  All issues on semantics, evaluation order, ... were thus cleared up.
18:17:14 <monochrom> Well, that is expected.
18:17:46 <SamB> well, personally I'd only expect either one of those <<loop>> things or ... nothing
18:18:03 <SamB> or maybe a stack overflow or OOM
18:18:53 <monochrom> Both denotational semantics (the FP world) and weakest preconditions (the IP world) have a long tradition of lumping 1/0, infinite loop, and assertion failures all together as a single _|_ (FP) or abort (IP).
18:19:42 <SamB> maybe you should read the paper
18:19:50 <monochrom> why?
18:19:56 <SamB> it doesn't quite do that
18:21:57 <joricj> what's denotational semantics? is that the theory behind haskell?
18:22:17 <SamB> Haskell doesn't have semantics!
18:22:27 <SamB> only toy languages have semantics ;-)
18:22:31 <joricj> oh
18:22:37 <monochrom> No, not saying it does exactly that.  But you see the spirit: what you feel to be different things are lumped together.
18:22:38 * SamB is half-kidding
18:22:53 <SamB> monochrom: it makes a bit of sense
18:23:22 <SamB> it's a bit like a contradiction being able to lead to any conclusion, I guess?
18:23:33 <monochrom> It is a simplification.
18:23:48 <Cale> Haskell used to have a formal semantics
18:23:53 <Cale> Back in version 1.0
18:24:05 <Cale> But for some reason, they didn't keep it up.
18:24:13 <monochrom> The native people near North Pole have 13 words for snow.  We have about 2: ice and snow.
18:24:18 <SamB> yeah, they threw it out in Haskell 95 ;-P
18:25:00 <monochrom> The native people near North Pole really care about snow.  They see distinctions.  To us they seem to be just splitting hairs.
18:25:07 <Cale> monochrom: Well, it does have something to do with the fact that they speak an agglomerative language
18:25:18 <Baughn> monochrom: Sleet, sludge, hail, powder snow..
18:25:22 <wagle> talk to a skier
18:25:38 <Baughn> monochrom: And 13? There are that many just in plain norwegian. Inuits and the like have /more/.
18:25:44 <Cale> So all the various adjectives you could apply to snow get glommed in and treated as part of the word.
18:26:06 <SamB> Cale: but also to do with the various types of snow
18:26:09 <SamB> and ice
18:26:15 <SamB> that they have to distinguish between
18:26:27 <SamB> even down here in PA we know that not all snow is the same!
18:26:45 <monochrom> Suppose you really care about pathalogical programs, or programs that just shouldn't be written ever.  You really care about different modes of failures, errors, exceptions, infinite loops that don't consume more memory, infinite loops that consume more memory, infinite loops that don't produce more output, infinite loops that produce more output...
18:27:08 <monochrom> But suppose you don't.  Then you prefer to use one single _|_ to stand for them all.
18:27:54 <wagle> hmm..  how many words do we have for the missing parts of a partial function?
18:28:16 <wagle> darn, i'm always behind
18:29:13 <wagle> i care about the different sorts of "bottom"
18:29:51 <wagle> glomming them all together leads to really twisty logic
18:29:57 <SamB> monochrom: basically, they let _|_ stand for the union of all possible exceptions with nontermination
18:30:05 <monochrom> Yes, you always define your theory to emphasize what you care and shove under the carpet what you don't care.
18:30:28 <SamB> (their semantics assigns sets of exceptions to each expression that does not return a value)
18:30:33 <monochrom> Either that, or you run out of coffee so you just say you don't care.
18:32:17 <SamB> that is, _|_ means the set of all possible values of Exception
18:32:29 <SamB> I checked -- there is a NonTermination constructor!
18:35:19 <monochrom> A nice attraction of having one single _|_ is that it reuses existing math.  However, we really only use that math for suprema; we quite never talk about infima.  Thus there is actually no harm having multiple _|_s and deviate from existing math.
18:36:03 <SamB> monochrom: the lovely thing about their formulation is they still have just the one _|_ -- but it is only one of many Bad values
18:37:22 <SamB> each Bad value carries a set of exceptions, with _|_ carrying all possible exceptions, and the exception that a program catches is arbitrarily chosen from the set...
18:37:55 <SamB> this properly models the possible orders in which an exception could be evaluated
18:39:25 <SamB> they couldn't find a consistant way to give a loop loop the value Bad {NonTermination}, only a way to give it the value Bad ~{}
18:39:46 <SamB> that is, _|_
18:41:15 <SamB> of course, actual implementations can just arbitrarily carry *one* exception, which is a heck of a lot more efficient than calculating all sensible exceptions
18:41:41 <SamB> ... and you can't calculate all sensible exceptions for loop
18:42:44 <monochrom> No wonder they call it imprecise.
18:43:25 <SamB> indeed
18:43:54 <SamB> but it's imprecise in a very precise way!
18:45:01 <wagle_home> i read a book that made a big distinction between: precise (lots of significant digits) and accuracy (close to the truth)
18:46:26 <SamB> wagle: in the context of specifications, is truth relevant?
18:46:49 <wagle_home> hmm..  http://en.wikipedia.org/wiki/Accuracy_and_precision
18:47:11 <wagle_home> mathematical truth?
18:47:20 <SamB> anyway, I think this semantics is close to the way GHC implements exceptions ...
18:47:23 <wagle_home> i was paraphrasing on the fly
18:47:44 <SamB> so what would accurate exceptions be?
18:48:23 <monochrom> You read a good book.  precision and accuracy are supposed to be different.  too many people confuse them.
18:49:25 <wagle_home> i dont think i understand exception enough....  i know how to implement them, but..
18:50:00 <monochrom> When looking at a specification alone, probably there is only precision, no accuracy to talk about, since it is looked at alone, no comparison.
18:50:34 <SamB> I know the difference between precision and accuracy
18:50:55 <monochrom> "the output should be 4" is more precise than "the output should be a number".  IOW simply means more specific, narrower.
18:51:02 <Cale> Heh, "mathematical truth"
18:51:12 <wagle_home> haha
18:51:19 <SamB> they teach that in chemistry, among other classes
18:51:42 <monochrom> But no one really looks at a specification in isolation.  You always compare a specification to your unstated goals, or to an alleged implementation.
18:52:01 <wagle_home> you can be precise with a wrong answer..  dont thing you can be accurate with a wrong answer
18:52:10 <wagle_home> you can be precise with a wrong answer..  dont >think< you can be accurate with a wrong answer
18:52:13 <SamB> monochrom: well, when you are comparing it to goals, "accuracy" isn't the word that comes to mind
18:52:25 <SamB> "faithfulness", maybe
18:52:44 <monochrom> That's just different cultures using different wordings to mean the same thing.
18:52:57 <SamB> you can't be accurate with a wrong answer
18:53:09 <SamB> you CAN be accurate with an answer that is so vague that it is no good to anyone
18:53:31 <Cale> wagle_home: Of course you can be accurate with a wrong answer. It depends on what it is that you're trying to measure.
18:53:44 <SamB> Cale: what the heck?
18:53:51 <monochrom> I.e., if you insist, I can switch to talking about how precision and faithfulness are different...  Same discussion and examples.
18:53:56 <SamB> that's not the wrong answer, that's the wrong question
18:54:03 <Cale> Suppose that I'm trying to measure the length of a rod, and to do this, I use a thermometer, and I get the same result 4 times in a row.
18:54:16 <SamB> again, wrong question!
18:54:31 <Cale> I have a very accurate result which is completely incorrect.
18:54:33 <idnar> SamB: the right answer to the wrong question is the wrong answer to the right question
18:54:41 <SamB> Cale: completely irrelevant
18:54:55 <monochrom> Just change the semantics of "length".
18:55:11 <SamB> besides, you have only convinced me that it is a precise answer
18:55:34 <clanehin> Cale: to drop some pedantry, isn't that "precision," while accuracy does in fact refer to correctness?
18:56:04 <Cale> clanehin: okay, the fact that I got the same result is precision
18:56:09 <SamB> clanehin: pedantic is just the thing for this conversation
18:56:21 <idnar> I would say that accuracy pertains to what you are attempting to measure
18:57:02 * clanehin remembers this conversation from high school physics.
18:57:45 <SamB> anyway, I believe the technical term for what you have when you attempt to measure length with a thermometer is "stupidity"
18:57:55 <Cale> hehe
18:58:23 <clanehin> SamB: I was just searching my head for technical term.
18:58:30 <SamB> unless, of course, you happen to know the distance between the lines on the thermometer
18:58:49 <SamB> in which case, "macgyver" comes to mind
18:59:36 <shachaf> "That rod is 15 thermometers long." -- seems like it could be reasonably accurate.
18:59:46 <dolio> Huh, so that's what Oleg looks like.
18:59:54 <SamB> or, yes, the length of the entire thing
19:00:07 <SamB> but attempting to use the fluid level in the thermometer to measure length????
19:00:15 <monochrom> What, Oleg looks like 15 thermometers?
19:00:27 <monochrom> No wonder he can hack Haskell types.
19:00:30 <dolio> No, there's a video of him posted to reddit.
19:00:38 <monochrom> w00t
19:01:00 <shachaf> "At 25C, that rod is 20 fluid-levels long"?
19:01:31 <clanehin> The example I remember of "precise" but not "accurate" is something along the lines of, the pencil weighs 12.76386153009 tons.
19:02:03 <shachaf> clanehin: 12.7638615300*8* tons, you mean.
19:02:24 <monochrom> looks older than I expect :)
19:02:35 <clanehin> shachaf: eh, darn, I probably forgot to callibrate the scale.
19:02:41 <shachaf> "That pencil weighs 15 thermometers."
19:02:47 <Cale> Well, I suppose my point is that you can attempt to measure something which is really not at all the thing that you want to measure, and you'll be answering some question, but not the question which you really wanted to answer.
19:03:39 <Cale> and it's not so much a matter that this introduces bias into your calculations, but that you've gone and done something entirely ridiculous
19:03:55 <SamB> well, sure
19:04:27 <SamB> if you at least measures something that is correlated with what you intended to measure, that's innacurate...
19:04:35 <SamB> if not, that's wildly innacurate
19:04:54 <ahunter_> @type (++)
19:04:57 <lambdabot> forall m. (Monoid m) => m -> m -> m
19:05:13 <dolio> People seem to be taking lots of flash photos. They must want to brag to their friends that they were in the same room as he was.
19:05:13 <SamB> Cale: hmm, you really ought to put some kind of warning on that...
19:05:15 <clanehin> Wait.  So it's possible to, like, screw up?   :)
19:05:29 <SamB> ahunter: that isn't the type of Prelude.++
19:05:38 <SamB> @type Prelude.++
19:05:39 <lambdabot> parse error on input `Prelude.++'
19:05:41 <monochrom> Yes, if you write an implementation that is irrelevant to a specification, or a specification that is irrelevant to your real goals, they are inaccurate too.
19:05:42 <Jedai> I'm sorry, but using the fluid of a thermometer to measure a length doesn't seems that screwed up
19:05:43 <monochrom> Accuracy always means you have something to compare to.
19:05:43 <SamB> @type (Prelude.++)
19:05:44 <lambdabot> forall a. [a] -> [a] -> [a]
19:06:03 <wagle_home> lambdabot understands calaskel
19:06:22 <SamB> Jedai: how do you use it?
19:06:27 <Jedai> After all, the thermometer gives you the current temperature by doing the inverse
19:06:45 <wagle_home> oops: calaskell
19:06:51 <SamB> I still think using the graduation lines would be more sensible
19:07:51 <Jedai> SamB: If we're looking after sensible of course... We shouldn't use a thermometer in the first place !!
19:08:14 <wagle_home> if you stick the rod somewhere with a nice temperature gradient, you can measure its length..  think of carbon dating
19:08:33 <Cale> wagle_home: hehe, good point :)
19:09:02 <Cale> Accuracy is a really funny thing to talk about.
19:09:21 <Cale> because it gets into the whole mess of what you really mean and what "really exists"
19:09:25 <SamB> well, did you here about the student with the exam question about how to measure the height of a building using a barometer?
19:09:33 <Cale> Even though all we have are our subjective observations.
19:10:20 <ddarius> SamB: yes
19:10:31 <wagle_home> maybe "susceptibility to scientific consensus"?
19:10:32 <Cale> Do objects *really* even have lengths. It seems that they do, and we build that into our physical model, but it's almost a meaningless question to ask.
19:11:06 <Jedai> Yep, anyway, just by knowing which fluid you're using and having a temperaturSamB: The one where he throws the barometer from the roof and measure the time it takes to get to the ground ?
19:11:25 <Jedai> Oups, mixed messages... ^^
19:11:29 <SamB> Jedai: I think that was one of many solutions he gave
19:11:46 <Cale> I think that was the expected solution.
19:11:48 <SamB> his first solution, I think, was to use it to weight a string
19:11:50 <Cale> Er, no
19:11:51 <SamB> Cale: no!
19:11:52 <wagle_home> hmm..  or a 1.000 foot long thermometer
19:11:56 <Cale> The expected one was pressure.
19:12:01 <SamB> using the barometric pressure was of course expected
19:12:03 <Cale> yeah
19:12:03 <Jedai> SamB: I really liked this joke when I first heard it :-)
19:12:13 <SamB> I mean, why else specify that it was a barometer?
19:12:26 <wagle_home> precision
19:12:27 <SamB> only one of the other solutions used it as a barometer
19:12:44 <wagle_home> , meaningless
19:12:47 <SamB> (the one where you ask the janitor to tell you in return for the baromter)
19:14:13 <SamB> my favorite two were: give it to the janitor in exchange for him telling you the height of the building, and using the shadows of the barometer and building
19:14:19 <wagle_home> i have a phrase for referring to measuring something that you dont understand: "bogons per second"
19:15:00 <monochrom> why per second?
19:15:16 <monochrom> (or should I just laugh?)
19:15:16 <SamB> it sounds funnier that way
19:16:12 <wagle_home> well, (1) it adds a little bit of "legitimacy" to the word bogons, and (2) in the original situation i was getting "errors per second" with NO definition of what an "error" was
19:16:38 <wagle_home> so i renamed errors to bogons
19:17:15 <monochrom> ah
19:18:06 <joricj> "filter (\x -> not x == 1) list", how can i rewrite the lambda to be "pointfree"?
19:18:37 <joricj> > (not . (== 1)) $ 1
19:18:37 <lambdabot>  False
19:18:42 <joricj> > (not . (== 1)) $ 2
19:18:43 <lambdabot>  True
19:18:46 <joricj> ah
19:19:00 <Saizan> (/= 1)
19:19:21 <thoughtpolice> @pl \x -> not x == 1
19:19:21 <lambdabot> (1 ==) . not
19:19:32 <thoughtpolice> or what Saizan said
19:19:52 <Saizan> well,  \x -> not x == 1 is just wrong
19:19:54 <shachaf> joricj: "not x == 1" is probably not what you want.
19:20:03 <shachaf> joricj: Since it parses as "(not x) == 1".
19:20:15 <joricj> yeah i'm using /= now :D
19:20:35 <ahunter_> Erm, is there a built in function to take N random numbers from a generator, and return the new generator state?  easy to write with recursion and next, but seems there *should* be a builtin
19:20:39 <joricj> where are the rules on "what goes first"?
19:20:52 <hpaste>  SamB pasted "how do you like this testcase?" at http://hpaste.org/6745
19:21:38 <Saizan> ahunter_: ther's a function to get an infinite list, randomRs
19:22:26 <ahunter_> Saizan: yeah, but I need the result of the generator to continue pulling numbers from
19:22:28 <solrize_> :t iterateM_
19:22:29 <lambdabot> Not in scope: `iterateM_'
19:22:35 <solrize_> :t replicateM_
19:22:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
19:22:47 <ahunter_> oh, I suppose I could use split, then, though
19:22:56 <EvilTerran> ?type get
19:22:57 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
19:22:59 <dons> more hvac stuff, http://reddit.com/r/programming/info/6dywv/comments
19:23:03 <dons> sclv++
19:23:09 <SamB> so, who likes my testcase?
19:23:14 <EvilTerran> ?type randomR
19:23:15 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> (a, g)
19:23:17 <SamB> who hasn't a clue what its for?
19:23:25 <EvilTerran> ?type random
19:23:26 <Saizan> SamB: for JHC?
19:23:27 <lambdabot> forall g a. (RandomGen g, Random a) => g -> (a, g)
19:23:31 <SamB> yes, for JHC
19:23:45 <EvilTerran> ?src State
19:23:45 <lambdabot> Source not found. That's something I cannot allow to happen.
19:23:55 <joricj> SamB: i don't have a clue
19:23:56 * EvilTerran blinks
19:24:13 <Lemmih> SamB: What testcase?
19:24:22 <SamB> http://hpaste.org/6745
19:24:23 <Cale> :t \n -> runState (replicateM n (State random))
19:24:24 <lambdabot> forall s a. (RandomGen s, Random a) => Int -> s -> ([a], s)
19:24:29 <Saizan> SamB: kind inference?
19:24:29 <EvilTerran> ?type State random
19:24:30 <lambdabot> forall s a. (RandomGen s, Random a) => State s a
19:24:40 <SamB> Saizan: yeah, it's for kind inference...
19:24:45 <EvilTerran> Cale, argh, you stole my punchline :(
19:25:04 <Cale> EvilTerran: sorry about that :)
19:25:11 <Lemmih> SamB: Looks good. Verify with hpc?
19:25:14 <SamB> oh great...
19:25:16 <EvilTerran> ahunter_, Cale's got what you want
19:25:21 <SamB> I just found a serious problem
19:25:38 <Cale> The replicateM in the continuation passing monad is also handy
19:25:39 <EvilTerran> although you may find it clearer to just do bog standard recursion
19:26:01 <ahunter_> woot, thanks
19:26:16 * EvilTerran blinks at Cale 
19:26:16 * EvilTerran head asplode
19:26:20 <Cale> :t \x n -> runCont (replicateM n (Cont x))
19:26:21 <lambdabot> forall a r. ((a -> r) -> r) -> Int -> ([a] -> r) -> r
19:26:35 <solrize_> samB that thing looks neat even though i don't understand it.  what is it testing?
19:26:39 <Cale> It's useful in conjunction with 'with-' style functions
19:27:15 <Boudewijnector_> Hi Guys, I'd like to program a kind of iteration but don't know how to do it. I'd like to do this: l  = [1..x] , and r = [0..l] (x is a parameter for my function). Then, I'd like to call a function f (using r and l as parameters, and a list L). The function returns the List again, and the updated list should be fed into the new iteration. Can anyone give  me a hint?
19:27:22 <Cale> :t withArray
19:27:23 <lambdabot> Not in scope: `withArray'
19:27:37 <Cale> :t Foreign.Marshal.Array.withArray
19:27:38 <lambdabot> forall a b. (Foreign.Storable.Storable a) => [a] -> (GHC.Ptr.Ptr a -> IO b) -> IO b
19:27:41 <Cale> Like that one
19:28:03 <BoudewijnEctor> Hi Guys, I'd like to program a kind of iteration but don't know how to do it. I'd like to do this: l  = [1..x] , and r = [0..l] (x is a parameter for my function). Then, I'd like to call a function f (using r and l as parameters, and a list L). The function returns the List again, and the updated list should be fed into the new iteration. Can anyone give  me a hint?
19:28:23 <Cale> (actually, the unravelled mapM is a little more useful for that one)
19:28:35 <joricj> BoudewijnEctor: use recursion
19:28:52 <BoudewijnEctor> joricj: yes, but how to do it smartly?
19:28:57 <BoudewijnEctor> r depends on l
19:28:59 <ahunter_> foldr
19:29:02 <BoudewijnEctor> and l depends on the parameter
19:29:06 <Cale> BoudewijnEctor: how is the new list fed into the new iteration?
19:29:09 <SamB> I guess I was just wondering what people think of the idea of just taking the code that a compiler fails on, and distilling it to a sketch that the compiler still fails on...
19:29:16 <BoudewijnEctor> furthermore I should pass the result of the function, into the next iteration too
19:29:27 <BoudewijnEctor> Cale : parameter
19:29:38 <Cale> BoudewijnEctor: it's r or l?
19:29:49 <Cale> and hey there's a type error
19:29:52 <ahunter_> foldr f L [(l,r) | l <- [1..x], r <- [1..l]], if I read you right
19:29:56 <Cale> l  = [1..x] , and r = [0..l]
19:29:57 <Cale> ?
19:30:01 <Cale> That cannot be
19:30:02 <BoudewijnEctor> Cale, not it's not
19:30:06 <BoudewijnEctor> it's a different list ;)
19:30:09 <Cale> Since l is a list
19:30:11 <BoudewijnEctor> Yes I know
19:30:24 <BoudewijnEctor> r = [0.. max (l) ]
19:30:39 <Cale> Which is x?
19:30:40 <joricj> :t max
19:30:40 <BoudewijnEctor> no not even that
19:30:40 <lambdabot> forall a. (Ord a) => a -> a -> a
19:30:48 <ahunter_> > let f = (:)
19:30:49 <lambdabot>  Parse error at end of input
19:30:49 <BoudewijnEctor> r = 0.. current version of l
19:30:56 <Cale> current version?
19:30:56 <Saizan> SamB: the right thing to do? with a comment about the feature being tested
19:30:56 <BoudewijnEctor> it's a double nested loop indeed
19:31:00 <BoudewijnEctor> yes
19:31:05 <Cale> What does that mean?
19:31:08 <BoudewijnEctor> I take l, and iterate it
19:31:11 <Cale> l <- [0..x] ?
19:31:17 <BoudewijnEctor> then I take r and iterate it within l
19:31:18 <Cale> er, or [1..x]
19:31:21 <SamB> at least finding that the MetaVar is leaking from kind inference will help...
19:31:25 <Cale> So this is a list comprehension?
19:31:48 <joricj> > [ (x,y) | x <- [1..4], y <- [1..x] ]
19:31:48 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(4,4)]
19:31:49 <Cale> [ ... | l <- [1..x], r <- [0..l], ...]
19:31:57 <BoudewijnEctor> like this: for (int l = 1 ; l <x ; l++)  { for (int r = 0; r <l ; r++)  { f (r,l) } }
19:32:01 <BoudewijnEctor> that's the C equivalent
19:32:19 <SamB> now I don't have to look through all that *type* inference code for the problem ;-)
19:32:22 <Cale> [ f r l | l <- [1..x-1], r <- [0..l-1]]
19:32:39 <BoudewijnEctor> Cale yes
19:32:50 <Cale> and then what?
19:32:53 <BoudewijnEctor> But I need to call a function with a third parameter
19:32:54 <BoudewijnEctor> a list
19:33:04 <BoudewijnEctor> and the function returns the list with some additions
19:33:17 <BoudewijnEctor> and the list (inc. additions) should be fed into the new iteration
19:33:25 <Cale> Okay, so we now have a list of the appropriate functions which you'd like to chain together.
19:33:37 <BoudewijnEctor> Yes
19:33:39 <Cale> foldr (.) id
19:33:43 <Cale> will compose these functions
19:33:47 <BoudewijnEctor> Why?
19:33:50 <BoudewijnEctor> i know . and id
19:33:53 <BoudewijnEctor> and foldr
19:33:59 <BoudewijnEctor> but why does this work?
19:34:03 <joricj> wow
19:34:19 <Cale> because we have a bunch of functions which we'd like to successively apply to something
19:34:24 <adu> its magic
19:34:25 <Cale> which is the same as applying their composite
19:34:29 <BoudewijnEctor> Yes
19:34:38 <Cale> So we fold function composition over the list.
19:34:41 <BoudewijnEctor> But how does the resulting list get updated?
19:34:45 <Cale> updated?
19:34:46 <joricj> > (foldr (.) id [ (+1), (+2), (+3) ]) 0
19:34:47 <lambdabot>  6
19:34:54 <Cale> It doesn't get updated.
19:34:55 <joricj> wooow
19:34:56 <BoudewijnEctor> YEs
19:35:02 <Cale> Each function produces a new list.
19:35:06 <Cale> from the previous one
19:35:13 <BoudewijnEctor> Ok that's fine too
19:35:18 <nolrai_> @pl \(a1, _) (a2, _) -> a1 == a2
19:35:18 <lambdabot> (`ap` snd) . (. fst) . (const .) . (==) . fst
19:35:21 <Cale> These lists share structure whenever they can
19:35:33 <Cale> But that depends on what f is doing
19:35:43 <nolrai_> @pl f (a1, _) (a2, _) = a1 == a2
19:35:43 <lambdabot> f = (`ap` snd) . (. fst) . (const .) . (==) . fst
19:35:52 <EvilTerran> ?type uncurry (==) . (fst *** fst)
19:35:52 <adu> BoudewijnEctor: updates? whats an update? I've been in Haskell-land for so long, I've forgotted what an update is...
19:35:52 <lambdabot> forall b a b1. (Eq a) => ((a, b), (a, b1)) -> Bool
19:35:53 <SamB> Lemmih: okay, I'm just going to compile jhcp && run the regression tests profiling for TMetaVar allocation cost center stacks
19:36:08 <SamB> overnight
19:36:12 <EvilTerran> nolrai_, that's what you want, i think
19:36:13 <BoudewijnEctor> adu: i'm quite new to haskell (half a year) so I just speak to imperatively ;)
19:36:18 <nolrai_> thanks
19:36:20 <SamB> well, hmm, or maybe it won't take that long
19:36:22 <BoudewijnEctor> *too
19:36:31 <EvilTerran> (***) is in Control.Arrow, with a scarey type that specialises nicely
19:36:42 <adu> BoudewijnEctor: in Haskell-land, when a=5, then a=5... forever
19:36:42 <EvilTerran> actually, wait a moment
19:36:48 <BoudewijnEctor> Cale, do you know a nice example on how to do so?
19:36:50 <SamB> scary?
19:36:55 <EvilTerran> nolrai_, which version of the compiler are you using?
19:37:08 <BoudewijnEctor> adu, I know , but it's 4;35 in the morning out here
19:37:15 <adu> BoudewijnEctor: IORef
19:37:17 <nolrai_> 6.8.2
19:37:29 <EvilTerran> ok, use Data.Function.on
19:37:32 <SamB> BoudewijnEctor: forever includes 4:35 AM
19:37:35 <EvilTerran> (==) `on` fst
19:37:38 <BoudewijnEctor> adu: no way, I prefer to use an ordinary list
19:37:43 <EvilTerran> ?src on
19:37:43 <lambdabot> (*) `on` f = \x y -> f x * f y
19:37:53 <joricj> > (,) 1 2
19:37:53 <lambdabot>  (1,2)
19:37:59 <joricj> > (1,)
19:37:59 <lambdabot>  Parse error at ")" (column 4)
19:38:00 <nolrai_> thats what i was thinking of.
19:38:22 <EvilTerran> ?hoogle comparing
19:38:22 <lambdabot> Data.Ord.comparing :: Ord a => (b -> a) -> b -> b -> Ordering
19:38:24 <Saizan> > (,) 1
19:38:25 <lambdabot>  Add a type signature
19:38:29 <EvilTerran> ?hoogle equating
19:38:29 <lambdabot> No matches found
19:38:31 <Saizan> ?ty (,) 1
19:38:32 <lambdabot> forall t b. (Num t) => b -> (t, b)
19:38:38 <nolrai_> > (,) (,) (:)
19:38:39 <lambdabot>  Add a type signature
19:38:50 <nolrai_> @ty (,) (,) (:)
19:38:51 <lambdabot> forall a b a1. (a -> b -> (a, b), a1 -> [a1] -> [a1])
19:39:00 <EvilTerran> i've seen "equating = ((==)`on`)", like "comparing = (compare`on`)", but it's not in the stdlibs
19:39:29 <adu> BoudewijnEctor: you'll like this one:
19:39:33 <adu> > let update xs f i = elems (a//[(i::Int,f$a!i)]) where a = listArray (1, length xs) xs in update [1,2,3,4] (+5) 2
19:39:34 <lambdabot>  [1,7,3,4]
19:39:50 <joricj> > let f x y l = (x,y):l in (foldr (.) id [ f x y | x <- [1..5], y <- [1..x] ]) []
19:39:51 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(4,4),(5,1),(5,2),(5,...
19:40:05 <nolrai_> what file is `on` in?
19:40:25 <EvilTerran> i said earlier - scroll up :P
19:40:39 <nolrai_> thanks
19:40:51 <EvilTerran> :)
19:41:44 <BoudewijnEctor> adu, I think you're actually misunderstanding me. I'd like to run this function (just giving it's signature) rowFOV :: ShadowList -> Int -> Int -> ([Bool],ShadowList)  where the result ShadowList should be passed to the next run of the function, and the 2 int's are the r and l values
19:42:37 <adu> BoudewijnEctor: wouldn't that just be rowFOV (snd (rowFOV ...))
19:42:44 <Volatile> Hm, any mentor here who wants to look at the GSoC application I just submitted?
19:43:07 <BoudewijnEctor> adu, yes but i don't know r and l on prior
19:43:14 <BoudewijnEctor> so need to keep it dynamically ;)
19:43:26 <BoudewijnEctor> and start on the r =0 and l = 1
19:43:26 <adu> BoudewijnEctor: what are r and l?
19:43:26 <ddarius> Volatile: #haskell-soc would be preferable.
19:43:34 <adu> oh
19:43:35 <joricj> (snd . (+2)) (1,3)
19:43:37 <joricj> > (snd . (+2)) (1,3)
19:43:38 <lambdabot>   add an instance declaration for (Num (a, b))
19:43:39 <BoudewijnEctor> the row and line of the coordinates in my game
19:43:50 <joricj> > ((+2) . snd) (1,3)
19:43:51 <lambdabot>  5
19:43:56 <BoudewijnEctor> the function is a field-of-vision algorithm
19:43:58 <Volatile> ddarius; oh
19:44:00 <Volatile> thx
19:44:57 <Cale> BoudewijnEctor: If you reorder the parameters, it becomes simpler
19:45:07 <BoudewijnEctor> Cale, like what?
19:45:11 <Cale> BoudewijnEctor: Put the ShadowList last
19:45:13 <BoudewijnEctor> Moving the list to the back?
19:45:16 <BoudewijnEctor> ok
19:45:43 <BoudewijnEctor> makes sense indeed. Do you understand what I'm trying to accomplish?
19:45:48 <Cale> So that after applying the first two parameters (which you know), the function becomes of type ShadowList -> ([Bool], ShadowList)
19:45:56 <Cale> I think I do.
19:46:19 <Cale> Though I'm not entirely certain I understand completely.
19:46:20 <BoudewijnEctor> Ok
19:46:27 <BoudewijnEctor> rowFOV :: Int -> Int ->  ShadowList ->([Bool],ShadowList)
19:46:31 <BoudewijnEctor> Current function :)
19:46:34 <BoudewijnEctor> ok
19:46:47 <BoudewijnEctor> what part do you don't get, Cale?
19:46:54 <Cale> So you're effectively going to chain a bunch of these rowFOV's together
19:47:05 <BoudewijnEctor> yes
19:47:07 <adu> uncurry (rowFOV EmptyShadow) :: (Int, Int) -> ([Bool], ShadowList)
19:47:08 <Cale> and are you going to collect up the [Bool] lists?
19:47:13 <nolrai_> is there a way to get all vaules which are rpeated in a list (sort of the opposit of nub)?
19:47:14 <Cale> Or do those get thrown away?
19:47:14 <BoudewijnEctor> each for a row in the 2-dimensional game
19:47:27 <BoudewijnEctor> No
19:47:37 <BoudewijnEctor> The FOV algorithm determines whether a tile is visible
19:47:47 <BoudewijnEctor> the [Bool] just show's it for each tile
19:47:52 <Cale> okay
19:48:00 <BoudewijnEctor> rowFOV computes visibility for one row
19:48:12 <BoudewijnEctor> so justs returns a 1-dimensional list
19:48:22 <BoudewijnEctor> FOV will call rowFOV for each row ;)
19:48:30 <Cale> nolrai_: well, you can apply group
19:48:43 <adu> so its actually rowFOV :: [Shadow] -> Int -> Int -> ([Bool], [Shadow])?
19:48:44 <Cale> nolrai_: and then filter the result, and map head
19:49:05 <Cale> nolrai_: You could even have something like:
19:49:06 <BoudewijnEctor> adu, just moved the Shadow-list to the back. But yes
19:49:25 <adu> BoudewijnEctor: ok
19:49:29 <BoudewijnEctor> And: type ShadowList = [Pos] , and type Pos = (Int,Int)
19:49:34 <Cale> > let erode = concatMap (drop 1) . group in erode "mississippi"
19:49:35 <lambdabot>  "ssp"
19:49:38 <Cale> er...
19:49:46 <Cale> no, that's not quite what we want :)
19:49:52 <Cale> > let erode = concatMap (drop 1) . group . sort in erode "mississippi"
19:49:53 <lambdabot>  "iiipsss"
19:50:15 <joricj> :t group
19:50:16 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
19:50:23 <Cale> > group "mississippi"
19:50:24 <lambdabot>  ["m","i","ss","i","ss","i","pp","i"]
19:50:31 <Cale> > group . sort $ "mississippi"
19:50:32 <lambdabot>  ["iiii","m","pp","ssss"]
19:50:53 <BoudewijnEctor> Cale, can you give me some more clues?
19:50:55 <Cale> Of course, if you want to keep them in order...
19:51:12 <nolrai_> Cale: thats perfect!
19:51:13 <Cale> BoudewijnEctor: okay
19:51:25 <adu> BoudewijnEctor: foldr (snd . (rowFOV 1 0)) EmptyShadow [Shadow]?
19:51:42 <adu> that might be wrong
19:51:45 <Cale> er...
19:52:05 <Cale> You're calling rowFOV with lots of different parameters
19:52:16 <BoudewijnEctor> me or adu?
19:52:18 <adu> he said it was (rowFOV :: Int -> Int -> [Shadow] -> ([Bool], [Shadow]))
19:52:24 <Cale> BoudewijnEctor: you
19:52:37 <BoudewijnEctor> Adu, Yup
19:52:40 <BoudewijnEctor> Cale, Yup
19:52:43 <Cale> adu: I don't think he wants to fix the first two parameters at 0 and 1
19:52:53 <BoudewijnEctor> Cale, indeed
19:52:54 <adu> o
19:53:10 <BoudewijnEctor> I do have an imperative code snippet of this algoritm
19:53:13 <adu> BoudewijnEctor: what are the paremeters based on?
19:53:17 <BoudewijnEctor> would you like to see it?
19:53:19 <adu> lets see it
19:53:30 <BoudewijnEctor> ok, wait a minute
19:53:34 <Cale> foldr (.) id [snd . rowFOV r l | r <- [0..x], l <- [0..r]]
19:53:40 <Cale> I think this is the function that you want.
19:53:42 <adu> BoudewijnEctor: do you know hpaste.org?
19:53:49 <BoudewijnEctor> adu, yes
19:53:50 <Cale> Or something close to it.
19:53:56 <Cale> BoudewijnEctor: do you understand that code?
19:53:57 <BoudewijnEctor> but it's in PDF, with latex signs
19:54:01 <joricj> hah, that function is excactly what i proposed earlier :D
19:54:05 <BoudewijnEctor> Cale more or less
19:54:10 <Cale> BoudewijnEctor: okay
19:54:15 <Cale> BoudewijnEctor: Is it right?
19:54:23 <joricj> except without the snd :/
19:54:49 <BoudewijnEctor> adu, http://www.cs.uu.nl/wiki/pub/Afp/ProgrammingTask/Practicum.pdf it's on the 5th page
19:54:52 <Cale> Of course, if you want to siphon off the [Bool], you'll need something a little fancier, because ordinary composition doesn't let you do that.
19:55:03 <BoudewijnEctor> Cale, yes i'd like to ;)
19:55:07 <Cale> Okay
19:55:10 <BoudewijnEctor> that's why it's in there
19:55:21 <Cale> So you need to replace composition with another operation which captures the lists
19:55:40 <BoudewijnEctor> on page 5 of the pdf i justed linked, there's an imperative version in metacode of the algorithm
19:55:46 <joricj> BoudewijnEctor: wow that assignment looks AWESOME
19:55:53 <BoudewijnEctor> and I'm currently struggling with the for loops
19:55:57 <joricj> i have to do pacman in scheme for crying out loud!
19:55:59 <BoudewijnEctor> joircj, yes it's hard
19:56:08 <Cale> That is,  (b -> (l,c)) -> (a -> (l,b)) -> (a -> (l,c))
19:56:20 <Cale> Will be the type of your enhanced composition
19:56:21 <SamB> hmm. so the character limit on twitter posts is 140...
19:56:30 <BoudewijnEctor> Cale okay
19:56:43 <Cale> Let's call it combine
19:56:46 <BoudewijnEctor> ok
19:56:50 * SamB tries to remember this so that he can use the char counter on his cellphone to reliably determine how much he can fit in a twitter post
19:57:08 <BoudewijnEctor> combine ::  (b -> (l,c)) -> (a -> (l,b)) -> (a -> (l,c))
19:57:11 <SamB> oh, btw, my twitter is at http://twitter.com/naesten if anyone cares
19:57:13 <lambdabot> Title: Twitter / naesten
19:57:15 <shachaf> That roguelike looks just like Nethack.
19:57:18 <gwern> Cale: btw, I fixed Frag's haddock docs
19:57:30 <BoudewijnEctor> shachaf, nethack is a roguelike
19:57:36 <shachaf> BoudewijnEctor: I know.
19:57:36 <Cale> combine f g a = let (l,b) = g a; (l',c) = f b in (l' ++ l, c)
19:57:40 <gwern> SamB: bizarrely, CVS $ID stuff messes up haddock...
19:57:45 <gwern> even in comments! I know
19:57:48 <shachaf> BoudewijnEctor: I mean, the same characters/colors.
19:57:52 <Cale> BoudewijnEctor: see how that works?
19:57:57 <SamB> gwern: where did you find some?
19:58:01 <gwern> and *apparently* '-- *' is not kosher
19:58:06 <BoudewijnEctor> Cale, not at all
19:58:08 <gwern> SamB: in Frag...
19:58:13 <Cale> BoudewijnEctor: Okay
19:58:25 <Cale> BoudewijnEctor: So the idea is that combine f g will be a function
19:58:30 <Cale> and when applied to x
19:58:37 <gwern> wait, what's this roguelike people're discussing?
19:58:41 <Cale> What will it do? It will apply g to x
19:58:51 <BoudewijnEctor> Yes
19:58:52 <Cale> and get some 'log', along with a result
19:58:56 <Cale> (l,b)
19:59:13 <Cale> and then it will take that result b, apply f to it
19:59:14 <adu> i get how everything works execpt the (l' ++ l, c) part
19:59:16 <Cale> and get another log
19:59:20 <Cale> and another result
19:59:22 <shachaf> gwern: http://www.cs.uu.nl/wiki/pub/Afp/ProgrammingTask/Practicum.pdf
19:59:34 <BoudewijnEctor> Cale, okay I see
19:59:37 <nolrai_> @ty foldr
19:59:37 <Cale> and it will concatenate the logs, and return the final result
19:59:38 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
19:59:45 <gwern> books are program now? WHAT A WORLD WE LIVE IN
19:59:57 <adu> lol
20:00:02 <BoudewijnEctor> Thanks Cale
20:00:03 <joricj> BoudewijnEctor: in what year are you in college?
20:00:10 <hpaste>  eyeris pasted "How can I get castToListStore into the binding of portStore?" at http://hpaste.org/6746
20:00:12 <BoudewijnEctor> 5th university
20:00:17 <BoudewijnEctor> but first year in haskell course
20:00:23 <joricj> oh ok
20:00:24 <SamB> that looks like the "cheap graphics" version of nethack!
20:00:24 <nolrai_> @ty foldr Data.Map.insert (empty)
20:00:25 <lambdabot>     Occurs check: cannot construct the infinite type:
20:00:25 <lambdabot>       b = M.Map a b -> M.Map a b
20:00:25 <lambdabot>     Probable cause: `M.insert' is applied to too few arguments
20:00:29 <BoudewijnEctor> Only did Java\C previously, so I'm spoiled
20:00:31 <Cale> BoudewijnEctor: This is actually quite a lot like what's called the writer monad.
20:00:39 <shachaf> SamB: "cheap graphics"?
20:00:39 * gwern wants it for hackage now
20:00:45 <adu> I wish I could take a course in Haskell
20:00:46 <shachaf> SamB: As opposed to DEC/IBM?
20:00:52 <Cale> BoudewijnEctor: and in fact, we could leverage the writer monad for this, but I think it's perhaps best to leave that aside for now
20:00:53 <BoudewijnEctor> Cale, let me have a look at that monad
20:00:53 <SamB> shachaf: yup
20:00:54 <nolrai_> @ty foldr (uncurry Data.Map.insert) (empty)
20:00:55 <lambdabot> forall a b. (Alternative (M.Map a), Ord a) => [(a, b)] -> M.Map a b
20:01:05 <BoudewijnEctor> Yes i think so too, monads are scary
20:01:06 <SamB> or, these days, UTF-8 would work ...
20:01:13 <Cale> BoudewijnEctor: We will also need to replace id with another function
20:01:23 <BoudewijnEctor> why?
20:01:31 <Cale> because it's no longer the right type
20:01:41 <adu> BoudewijnEctor: Monad isn't scary, IGetHashTable is scary
20:01:43 <Cale> The function we need to replace it with is very simple though
20:01:50 <Cale> id' x = ([], x)
20:01:56 <eyeris> Could someone take a look at my paste and show me how I can clearly and concisely cast the return from treeViewGetModel with castToListStore?
20:02:16 <Cale> So it looks like one of these rowFOV functions now, but gives an empty log and doesn't change the result
20:02:30 <BoudewijnEctor> you mean, in this foldr (.) id [snd . rowFOV r l | r <- [0..x], l <- [0..r]] ?
20:02:33 <Cale> yeah
20:02:36 <BoudewijnEctor> Ok
20:02:39 <Cale> We replace (.) with combine
20:02:44 <BoudewijnEctor> wait, let me first move it into the code
20:02:44 <Cale> and id with this id'
20:02:46 <joricj> :t combine
20:02:47 <lambdabot> Not in scope: `combine'
20:02:53 <Cale> and we'll get rid of the snd
20:03:00 <Cale> because we're keeping that information now
20:03:06 <joricj> @src combine
20:03:06 <lambdabot> Source not found. Wrong!  You cheating scum!
20:03:07 <Cale> joricj: look above
20:03:11 <gwern> hm. are 'functional arrays' really so bad?
20:03:17 <Cale> gwern: hm?
20:03:42 <hpaste>  BoudewijnEctor pasted "(no title)" at http://hpaste.org/6747
20:03:50 <gwern> Cale: the pdf strongly reccomends against functional arrays
20:03:53 <adu> combine :: (t1 -> ([a], t2)) -> (t -> ([a], t1)) -> t -> ([a], t2)
20:04:07 <BoudewijnEctor> Just pasted my complete code
20:04:07 <atp> gwern: if you have to update them at all frequently they are
20:04:13 <Cale> oh, immutable arrays?
20:04:15 <gwern> on the other hand, if this is a class assignment, I guess there's not much chance of the haskell community getting a nice roguelike out of it
20:04:36 <Cale> gwern: I don't think they're so bad, especially if you use the unboxed ones.
20:04:37 <atp> gwern: functional arrays are best when you need O(1) access to data without update
20:04:42 <BoudewijnEctor> I can use functional arrays, it's ok
20:04:49 <joricj> oh ok
20:04:54 <adu> BoudewijnEctor: where can I take a Haskell course like you? :)
20:05:00 <SamB> is this the algorithm wanted for field of view? http://roguebasin.roguelikedevelopment.org/index.php?title=Precise_Permissive_Field_of_View
20:05:02 <lambdabot> Title: Precise Permissive Field of View - RogueBasin, http://tinyurl.com/2x5p6h
20:05:07 <BoudewijnEctor> Utrecht University, Netherlands
20:05:11 <Cale> Data.Map actually is probably a better idea
20:05:19 <adu> o, ic, very far
20:05:21 <shachaf> They seem to do a lot of functional things.
20:05:24 <BoudewijnEctor> It's a master course
20:05:42 <joricj> damnit, i'm gonna do my masters there ... im in brussels now (VUB)
20:05:46 <BoudewijnEctor> I'm not allowed to copy stuff from the internet
20:05:57 <joricj> i'm TIRED of scheme and java jeezes
20:06:08 <SamB> BoudewijnEctor: you aren't allowed to use algorithms from the literature?
20:06:12 <BoudewijnEctor> joricj: utrecht is nice indeed.
20:06:32 <BoudewijnEctor> Samb: I am, but I don't want to copy it... I want to learn from it.
20:06:35 <SamB> note that this is not code, but rather a description in english
20:06:42 <SamB> with pictures
20:06:50 <clanehin> gwern: I noticed you make a comment some time ago about roguestar, for which I have been able to resume work in the last few months
20:07:10 <gwern> wait what?
20:07:14 <gwern> clanehin == dark?
20:07:18 <SamB> BoudewijnEctor: go ahead and give it a look
20:07:19 <BoudewijnEctor> SamB: i know how it works, it's just hard to translate it into haskell
20:07:26 <clanehin> gwern: what?
20:07:27 <joricj> there should be a realtime roguelike MMORPG written in haskell
20:07:32 <adu> joricj: Just (let it = be <-)
20:07:44 <adu> joricj: YA! i wanna write one!
20:07:48 <gwern> oh, sorry
20:07:49 <shachaf> joricj: Realtime roguelikes don't work very well, as far as I've seen.
20:07:53 <joricj> me too
20:07:55 <shachaf> (I might've seen the wrong ones, though.)
20:07:56 <BoudewijnEctor> Cale to continue from this point?
20:07:57 <gwern> clanehin: I got roguestar confused with mage
20:08:04 <joricj> all the noobies should come together and write it
20:08:12 <gwern> clanehin: ok, that's good to hear
20:08:14 <adu> joricj: do you wanna write a Hakell front-end to CrystalSpace?
20:08:20 * gwern goes to d/l the patches
20:08:24 <clanehin> gwern: no, I only heard of that from your work on it
20:08:32 <joricj> i don't know CS, lemme do a quick google
20:08:51 <shachaf> clanehin: Roguestar was that OpenGL thing, wasn't it?
20:09:00 <clanehin> shachaf: yes
20:09:15 * gwern truly did very little work on roguestar although I've always intended to try to turn it into a nethack competitor
20:09:28 <adu> joricj: while OGRE and others have hundreds of functions, CrystalSpace has hundreds of classes, and THOUSANDS of functions to choose from
20:09:38 <shachaf> gwern: A graphical game?
20:09:47 <cdsmithus> Is it considered appropriate to post job openings on haskell-cafe?
20:09:54 <gwern> shachaf: roguestar is nicely split between an engine and a frontend
20:10:07 <shachaf> OK, that sounds better. :-)
20:10:08 <solrize_> there's a roguelike game called ZapM?  That's played by doing the zap operation on an arbitrary monad?
20:10:10 <gwern> shachaf: so far as I know, there's nothing to say you couldn't write a curses frontend instead of an opengl one
20:10:16 <shachaf> So there could be a text front-end?
20:10:16 <SamB> BoudewijnEctor: I really don't think these algorithms are the same
20:10:21 <joricj> adu: i dunno i'm looking at it and it looks 3D
20:10:33 <BoudewijnEctor> SamB I don't think so either
20:10:45 <SamB> though, based on the pictures, I'm almost absolutely certain that they compute the same thing
20:11:06 <BoudewijnEctor> Yup, but I should stick to the shadow-casting method
20:11:11 <BoudewijnEctor> as described in the PDF
20:11:15 <joricj> i'd like a simple 2D world where the focus is on writing programs to do farming etc
20:11:48 <joricj> so that the players would actually write programs to play
20:11:50 <adu> joricj: maybe we could write an Atlas implementation in Haskell...
20:11:54 <adu> http://worldforge.org/
20:11:55 <gwern> solrize_: ZapM wouldn't be a bad haskell roguelike name
20:11:56 <lambdabot> Title: The WorldForge Project
20:11:56 <ddarius> cdsmithus: If it's Haskell related, sure.
20:12:01 <Cale> It's really funny that the PDF gives an imperative specification of the algorithm
20:12:25 <ddarius> Cale: It makes sense.
20:12:26 <BoudewijnEctor> Cale, I think that's done on purpose. You need to keep quite some things in mind when programming it
20:12:31 <adu> joricj: or we would make a Haskell language binding to the VIP protocol
20:12:31 <adu> http://interreality.org/
20:12:33 <lambdabot> Title: Interreality Project - Virtual Object System
20:12:38 <solrize_> gwern yeah i saw on that page that ZapM already exists
20:12:48 <solrize_> maybe there could be a haskell version of it called ZapM_
20:12:52 <joricj> adu: wow there's really a lot out there!
20:12:59 <cdsmithus> ddarius: Thanks.  Some mailing lists or newsgroups are hostile toward them; I don't want to upset anyone.
20:13:43 <gwern> Cale: but if it gave a high-level declarative specification, everybody would simply copy it into their programs...
20:13:52 <Cale> gwern: that's true :)
20:14:03 <adu> joricj: no, thats just the cream of the crop
20:14:11 <adu> http://secondlife.com/
20:14:12 <adu> http://www.planeshift.it/
20:14:14 <lambdabot> Title: PlaneShift - A 3D Fantasy MMORPG
20:14:18 <adu> http://www.opencroquet.org/index.php/Main_Page
20:14:18 <lambdabot> Title: Main Page - Croquet Consortium
20:14:21 <Cale> I suppose it better prepares people for the ICFP
20:14:36 <gwern> (I've followed Thousand Parsecs for awhile)
20:14:37 <joricj> ive never played anything like that actually... second life i heard good things about it because the player can also program stuff
20:14:38 <Cale> Which seems to love this kind of imperative specification :)
20:15:02 <joricj> it would be cool to see how that works: writing a mmorpg where the client can program his behaviour
20:15:17 <ddarius> Cale: Most algorithm textbooks give imperative specifications.
20:15:25 <BoudewijnEctor> Cale yes it probably does... the author likes ICFP
20:15:32 <adu> joricj: but I think VOS should have a Haskell binding regardless of any MMORPG...
20:16:01 <BoudewijnEctor> I'm going to get some coffe (0515 AM out here), can you help me a bit more in a few minutes, Cale?
20:16:07 <Cale> BoudewijnEctor: sure
20:16:11 <BoudewijnEctor> Thanks
20:16:17 <Cale> I'm just sitting here watching physics lectures otherwise :)
20:16:19 <joricj> i dunno, i haven't looked in to it. either way i doubt i'm gonna be of much help but i'd sure would like to follow it happening
20:16:32 <ddarius> Cale: Which lectures?
20:16:45 <Cale> ddarius: The ones by Walter Lewin at MIT
20:17:55 <ddarius> Cale: Electricity and Magnetism?  And if so, how are they?
20:17:58 <joricj> when you use the actor model, is it generally used in such a way that you have a diffrent message type for all actors or do you create one mother type of all messages that will be sent around?
20:18:04 <adu> joricj: I'm very interested in an interoperable 3D internet. VRML has failed, and I think of all the projects trying to fill its void, that VOS/Interreality has the best approach.
20:18:27 <Cale> ddarius: Well, I'm just on to the Vibrations and Waves ones now. They're all quite fun actually. The demonstrations are quite fun.
20:18:43 <Cale> and he's a good speaker
20:20:27 <joricj> adu: yeah i think lots can be done with that. i'm currently working on an IRC-like service (as a first project to get to know haskell) and iam thinking of maybe adding roguelike things to it later (eg: you message a service and it gives you your FOV, you message other services to access your motor/gun, using services takes up energy, ...)
20:20:29 <Cale> The formalism is a bit loose, but you can generally expect that from physics lectures at this level, and it doesn't hurt too badly.
20:20:41 <adu> joricj: and imho, the runner-ups are: OpenCroquet, 2nd best. and Second life, is either 3rd best or just another game...
20:20:44 <SamB> actually, looking at the PDF more closely, I think it isn't the permissive FOV that is wanted...
20:21:30 <gwern> joricj: funny you mention IRC stuff. Today I was just looking at the Barracuda adhoc IRC/chat system in Haskell
20:21:51 <joricj> it already exist?! :(
20:21:57 <ddarius> @where barracuda
20:21:57 <lambdabot> I know nothing about barracuda.
20:22:05 <ddarius> @google barracuda chat haskell
20:22:06 <lambdabot> http://haskell.org/gtk2hs/archives/2008/02/24/barracuda-p2p-chat/
20:22:06 <lambdabot> Title: Gtk2Hs  Blog Archive  Barracuda P2P Chat
20:22:14 <gwern> joricj: well, tecnically it's not really IRC
20:22:44 <ddarius> @where+ barracuda http://sep07.mroot.net/
20:22:44 <lambdabot> Done.
20:22:47 <gwern> the darcs repo was put online for me and I was poking around
20:22:58 <gwern> 'snice, for example, it has a fork of hsgnutls
20:23:12 <gwern> which was on my list of things to do but I had been daunted by some of the dependencies
20:23:26 <gwern> (although I'm annoyed it exposed a bug in haddock 2)
20:28:40 <BoudewijnEctor> Im back
20:28:56 <Cale> hi
20:29:02 <BoudewijnEctor> Cale, where to start modifying my crappy code?
20:29:50 <Cale> Well, that function FOV will be a problem, since functions are not allowed to start with capital letters. :)
20:30:04 <Cale> You might want to fill in rowFOV
20:30:13 <BoudewijnEctor> ok , s/FOV/fov/g
20:30:25 <Cale> and you have my combine, it might be best to lay that out a little more nicely
20:30:45 <Cale> and you'll need that starting function which does not much
20:30:46 <BoudewijnEctor> in what sense?
20:31:03 <Cale> I'll make a paste
20:31:10 <BoudewijnEctor> Cale, thanks
20:31:26 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/6747#a1
20:32:03 <BoudewijnEctor> ok that makes sense too
20:32:50 <Cale> Depending on what order you want those extra lists in, you might like to concatenate them in the other order
20:33:43 <Cale> Also, you might want to do something to rowFOV so as to wrap the resulting list in a list (as the sole element), which will keep the lists from separate calls to rowFOV separate in the result
20:33:48 <BoudewijnEctor> Yes, But i still have to think about that (and talk to the other guys about their way of structuring the levels) , but I'd like to focus on getting this algorithm to work at hand
20:34:02 <BoudewijnEctor> Cale why?
20:34:32 <Cale> Well, you're going to get one long list of Bools this way, and it might be tricky to interpret
20:34:38 <Cale> But we'll see :)
20:34:44 <nolrai_> are hashtables in the standard libs?
20:34:46 <BoudewijnEctor> Well yes
20:34:56 <Cale> nolrai_: Sort of, but don't use them.
20:35:00 <Cale> nolrai_: Use Data.Map
20:35:05 <nolrai_> ok
20:35:06 <BoudewijnEctor> Cale, I was going to make  a [[Bool]] by :'ing each resulting [Bool]
20:35:22 <BoudewijnEctor> and each [Bool] just describes one row
20:35:29 <Cale> nolrai_: Data.Hashtable really really sucks performance-wise, and it's in IO, so there's no benefit to using it.
20:35:48 <nolrai_> yeikes
20:35:58 <ahunter> TheLorax: type annotation
20:36:00 <Cale> nolrai_: It's purely historical.
20:36:01 <lament> Cale: is it in the library because people kept asking for hashtables?
20:36:07 <ahunter> erm, ignore that
20:36:13 <Cale> lament: It's in there because it's older than Data.Map
20:36:21 <Cale> lament: and for a long time GHC used it
20:36:28 <Cale> I'm not sure if it still does...
20:37:44 <BoudewijnEctor> Cale, is the fov function currently correct?
20:37:45 <Cale> BoudewijnEctor: yeah, so if you wrap those in an extra [], and concatenate them, it has the same effect
20:37:54 <Cale> BoudewijnEctor: not quite
20:38:03 <Cale> BoudewijnEctor: that's the one which is throwing away the [Bool]s
20:38:11 <Cale> uh oh
20:38:16 <BoudewijnEctor> Yup
20:38:18 <Cale> It's got the combine there
20:38:27 <Cale> But you don't want that snd anymore
20:38:37 <Cale> and the id needs to become (\x -> ([],x))
20:39:16 <BoudewijnEctor> 	foldr (combine) (\x -> ([],x)) [rowFOV r l | r <- [0..x], l <- [0..r]]	 is better?
20:39:24 <Cale> yeah
20:39:42 <Cale> and maybe you want to make rowFOV either return a singleton list of lists of bools
20:39:50 <Cale> Or else do something like
20:40:00 <Cale> second (:[]) . rowFOV r l
20:40:04 <Cale> er
20:40:06 <Cale> first rather
20:40:08 <BoudewijnEctor> Well , why would I want to do so?
20:40:30 <Cale> Because the ++ in the definition of combine is going to concatenate your lists of Bools
20:41:03 <Cale> and that's not *quite* what you want, most likely
20:41:32 <Cale> You really want to concatenate the list of lists of bools coming from the various calls to rowFOV
20:41:36 <BoudewijnEctor> Cale yes that's true... changed rowFOV :: Int -> Int ->  ShadowList ->([[Bool]],ShadowList)
20:41:38 <BoudewijnEctor>  
20:42:17 <Cale> So there's an option there as to how it should be done -- either in the code for rowFOV, or the code for fov, but yeah
20:42:24 <Cale> That will do :)
20:42:33 <BoudewijnEctor> *O*
20:42:49 <Cale> and now you just apply that composed function to an initial state
20:42:58 <Cale> Which is the empty list
20:43:51 <Cale> You could also do this problem just with recursion, but I think this way of looking at it is nicer.
20:44:09 <BoudewijnEctor> Yes but where?, in fov to create the "shadows = [] " ?
20:44:19 <Cale> hm?
20:44:26 <BoudewijnEctor> Where to do so?
20:44:35 <Cale> Where to introduce recursion?
20:44:47 <BoudewijnEctor> No, Cale>	and now you just apply that composed function to an initial state
20:45:17 <joricj> BoudewijnEctor: how are you representing your world, nested lists?
20:45:17 <Cale> ah, the expression   foldr combine (\x -> ([],x)) [rowFOV r l | r <- [0..x], l <- [0..r]]
20:45:20 <Cale> is a function
20:45:29 <BoudewijnEctor> joricj: yup
20:45:34 <Cale> and you want to apply that function to the empty ShadowList
20:45:49 <joricj> the assignment specifically warns against them y'know :D
20:46:45 <Cale> So I don't know what the blockPos and maxline values are...
20:47:18 <BoudewijnEctor> blockPos == The tiles which block light (like walls), and maxlines == maximum viewing distance
20:48:33 <Cale> and, presumably you'
20:48:44 <BoudewijnEctor> joricj, yes we know. THe other guys are refactoring it already
20:48:44 <Cale> you'll need the blockPos information in rowFOV?
20:48:57 <BoudewijnEctor> Yes
20:48:57 <Cale> Is x the maximum viewing distance here?
20:49:11 <joricj> BoudewijnEctor: this is a group assignment?
20:49:17 <BoudewijnEctor> Cale, yes
20:49:38 <BoudewijnEctor> joricj: Yes, but our teacher created a solution in 3 three days on his own
20:50:54 <Cale> So it takes a little getting used to, but rather than looping, in functional programming we usually use higher order functions which operate on lists in various ways.
20:51:39 <Cale> You can usually think of the lists as the indices over which you're iterating, and higher order functions are then the loop bodies.
20:51:42 <BoudewijnEctor> Cale I know, but I just had a single crash-course on Haskell... and know I'm just experiencing a lack of experience
20:51:58 <BoudewijnEctor> So I tend to think too much like a C programmer
20:52:13 <Cale> BoudewijnEctor: This solution isn't the most beginner-oriented I'm afraid, but it's a good one to think about :)
20:52:34 <BoudewijnEctor> lol I'm going to edit my code
20:52:37 <gwern> man, wdired-mode in Emacs is such a win
20:52:44 <BoudewijnEctor> to incorporate your changes
20:53:02 <Cale> and you can think about what might happen if you started to abstract over this idea of enriching function composition like that
20:53:33 <Cale> and that is one way to approach the idea of monads and arrows
20:53:47 <BoudewijnEctor> Yes I see
20:53:53 <ddarius> and comonads
20:54:00 <BoudewijnEctor> Let me try to get that code to run
20:54:02 <lament> redefine the semicolon!!!
20:54:06 <Cale> and yeah, all the other kinds of interesting functors :)
20:55:41 <lament> Cale: hey, is there a monad tutorial that actually expands on the "redefining the semicolon" explanation?
20:55:52 <Cale> lament: hmm...
20:55:56 <lament> cause that could actually work
20:56:23 <joricj> heh thats a cool way to look at monads
20:56:26 <dolio> dons likes that phrase, so he might know of one.
20:56:39 <dolio> Or, the phrase "programmable semicolon" specifically.
20:56:41 <Cale> lament: Well, you might have a look at my "Monads as Computation", though it doesn't directly use that phrase.
20:56:42 <lament> i thought dons preferred the oranges and nuclear waste explanation
20:56:51 <ddarius> apples
20:57:02 <Cale> apples and blueberries ;)
20:57:05 <clanehin> I assume that was meant as a joke . . .
20:57:38 <Cale> The nuclear waste one is terrible, because it gives the dangerous name to the wrong stuff
20:57:55 <Cale> In  (IO a)  it's not the 'a' which is scary.
20:57:56 <lament> Cale: i don't think it's quite explicit enough
20:58:02 <lament> Cale: (monads as computation)
20:58:13 <ddarius> Cale: It's terrible because it totally misses the point.
20:58:14 <Cale> lament: It needs more examples.
20:58:22 <Cale> ddarius: and yes, it totally misses the point :)
20:58:43 <BoudewijnEctor> Cale thanks for the help. I'm going to try to get 3 hours of sleep (it's 6:00 AM out here)
20:58:50 <BoudewijnEctor> I'll spam you again later on this day :+
20:58:58 <Cale> BoudewijnEctor: see you around :)
20:59:08 <BoudewijnEctor> Thanks you really helped me :)
20:59:11 <Cale> My monads as computation, I think actually gets the point right, but it's not a complete tutorial :)
20:59:52 <Cale> For that, I'd direct someone at, say, All About Monads, which doesn't really make the point so clear, but at least covers a lot of ground
20:59:56 <lament> Cale: i think it's not explicit enough about what the hell monads do; it talks about it but in a rather wishy-washy way
21:00:11 <Cale> lament: But they do very different things.
21:00:18 <lament> (i mean the first two paragraphs of "Motivation"
21:01:06 <Cale> Oh
21:01:11 <Cale> That's not even really about monads
21:01:18 <lament> exactly
21:01:20 <Cale> That's about combinator libraries.
21:01:23 <lament> exactly
21:01:32 <lament> and then the third paragraph starts with "Such a library will have some representation of primitive computations, and some ways to glue those computations together into more complex ones."
21:01:44 <lament> which is a more complicated way of saying "monads are a way to redefine the semicolon"
21:01:49 <Cale> Not quite :)
21:01:56 <lament> but by that time, the reader is sort of lost already :)
21:02:27 <Cale> For example, in a parsing library, you have some way to construct the alternation between two parsers, and some way to construct their concatenation
21:02:38 <Cale> and only one of those could possibly be the semicolon :)
21:02:48 <Cale> (usually we pick concatenation)
21:03:00 <lament> alternation and concatenation - isn't that what all of programming is about? :)
21:03:10 <Cale> Or in a drawing library, well, maybe "on top of" is the semicolon, but it's not terribly clear.
21:03:19 <ddarius> lament: Yes!  All programming is a trivial subset of REs.
21:03:48 <Cale> Heh, it's sad but true :)
21:03:57 <dolio> No wonder they're so popular.
21:03:58 <Cale> but also false :)
21:04:05 <lament> ddarius: or just logic. (alternation = or. concatenation = and)
21:04:23 <Cale> and various other monoids :)
21:04:38 <ddarius> Rings no?
21:04:43 <lament> is that a monoid? not a ... groupoid or something?
21:04:56 <lament> ringoid
21:05:01 <ddarius> lament: It's two monoids.
21:05:08 <lament> (take any word, add 'oid' at the end)
21:05:11 <Cale> Well, rings are just pairs of monoids which fit together in a nice way
21:05:26 <Cale> But in general, there are lots of monoids in programming which show up all over the place.
21:05:39 <lament> structures with both "or" and "and" are clearly common enough to deserve a better name than 'pair of monoids')
21:05:51 <ddarius> Lattice
21:06:04 <Cale> Well, yes.
21:06:17 <Cale> But say, function composition.
21:06:26 <Cale> Doesn't quite fit into that picture
21:06:28 <lament> algebraic datatypes are like that too, right
21:06:39 <lament> foo | (bar, baz)
21:06:47 <Cale> yeah, there are lots of ringoid sorts of things
21:07:03 <ddarius> There are lots of algebraic structures of many types.
21:07:41 <ddarius> Free pointed magmas, free monoids, many, many other monoids, semigroups, categories, lattices and posets.
21:07:45 <Cale> But things which are explicitly monoids seem to crop up way more than in the rest of mathematics even. Maybe that's just my strange perspective.
21:08:16 <ddarius> Cale: Monoids are very simple.  Most of the things I listed above include being a monoid (or something close) in their definition.
21:08:47 <Cale> ddarius: By 'explicitly monoids' I mean 'monoids and not obviously something else which is well studied'
21:08:56 <lament> if you have "stuff" and doing "something" to "stuff" produces more "stuff", you have a monoid
21:09:19 <Cale> lament: not quite
21:09:19 <lament> and since most "somethings" are complex enough, there's no reason for this "something" to induce more structure than "no structure at all"
21:09:24 <lament> hence, explicitly monoid
21:09:43 <hpaste>  atheena pasted "suffix" at http://hpaste.org/6748
21:09:49 <Cale> A monoid M is a set of things with an associative operation and an identity.
21:09:53 <ddarius> Cale: Many algebraic structures that CS gives rise to don't neatly fall into the "standard" ones.  Also, many of the "explicit" monoids that come up are very closely related to the function composition monoid (though that isn't very surprising given it's significance.)
21:10:58 <Cale> ddarius: Yeah, I won't contest that.
21:11:00 <lament> Cale: right, so "something" acts a bit like concatenation
21:11:07 <Cale> ddarius: It's probably because of the practical influence :)
21:11:17 <lament> we smoosh stuff together to get more stuff
21:11:26 <Cale> lament: ah, your "stuff" was plural in one place
21:11:31 <Cale> I see :)
21:11:34 <lament> yeah :D
21:11:53 <lament> smooshing together tends to be associative
21:12:41 <lament> (i'm not saying every monoid operation acts like concatenation, but it seems the most natural way of getting one)
21:13:29 <Cale> ddarius: Mathematicians seem to shy away from things which have little recognisable structure to them, whereas CS people have lots of practical motivation to study some things which don't necessarily come with a whole lot of algebraic structure.
21:13:31 <ddarius> list concatenation is the multiplication of the free monoid.
21:14:02 <Cale> (and so anything you can get is nice)
21:14:04 <ddarius> Cale: It doesn't "obviously" come with "nice" structure.  Usually there is quite a bit of structure available.
21:14:45 <ddarius> And every monoid is the image of some monoid homomorphism from a free monoid.
21:16:04 <Cale> I really like the classification of regular languages as the preimages of subsets of finite monoids under homomorphisms from a free monoid.
21:16:40 <Cale> That makes them seem far less arbitrary to me.
21:18:37 * lament somehow suspects that "concatenation" and "choice" are fundamentally different even if both are "simply monoids"
21:18:46 <gwern> everybody! Throw your arms up in the air like you just don't care!
21:19:18 <dolio> @b52s
21:19:18 <lambdabot> It's a dreary downtown day, but at the end of my 40 foot leash is my little friend quiche.
21:19:27 <Cale> lament: choice is commutative
21:19:33 <Cale> (for one)
21:19:46 <lament> true
21:21:35 <AtheeNa> hello anyone can tell me what is my error here.. Syntax error in expression (unexpected `}', possibly due to bad layout)
21:22:11 <Cale> AtheeNa: That can be caused by quite a few syntax problems... the first thing to check are that there are no tab characters in your file
21:22:42 <shachaf> AtheeNa: There was a '}' where it wasn't expected. :-)
21:22:44 <dolio> There's kind of a lot wrong with your paste.
21:22:54 <dolio> If you'll excuse my bluntness.
21:22:57 <Cale> oh, there's a paste?
21:23:01 <dolio> But I'm sure we can help fix it.
21:23:06 <AtheeNa> see..hehe..i dont if this right.. im still a beginner in haskell
21:23:18 <AtheeNa> repSuffix :: Word -> Word
21:23:18 <AtheeNa> repSuffix a = replace a [b isSuffix a]
21:23:29 <dolio> http://hpaste.org/6748
21:23:38 <Cale> dolio: yeah, I found it :)
21:23:39 <AtheeNa> i tried
21:23:41 <AtheeNa> but i's the same
21:23:44 <lament> right, so there's "choice out of many items" - it's commutative because the items are not actually ordered, and it's associative because it's really an operation on many items, not two
21:24:04 <Cale> AtheeNa: hmm...
21:24:07 <AtheeNa> where b d = case d of
21:24:17 <AtheeNa> "s" -> ""
21:24:21 <lament> and there's "concatenation" - it's associative because it's again on many items, and non-commutative because the items are ordered
21:24:24 <Cale> AtheeNa: This code is supposed to replace the appropriate suffix of the word it's given?
21:24:39 <AtheeNa> "sses" -> "ss"
21:24:43 <lament> so really there's two operations - "ordered" and "unordered" :)
21:24:44 <Cale> okay
21:24:46 <Jedai> AtheeNa: There's a guard completely out of the blue...
21:24:51 <Cale> AtheeNa: I think I get it.
21:25:02 <AtheeNa> u mean [ ]
21:25:08 <Cale> AtheeNa: I would start out by writing a function which takes just one suffix, and one replacement for it
21:25:13 <Cale> AtheeNa: and a string
21:25:15 <Jedai> AtheeNa: This is not even remotely working code
21:25:28 <Cale> AtheeNa: and makes the appropriate replacement if that suffix is there
21:25:39 <Cale> AtheeNa: and otherwise, it leaves the string alone
21:26:06 <Jedai> Cale: I think a Maybe would be better here, so we know if it did the replacement
21:26:15 <Cale> Jedai: perhaps...
21:26:39 <AtheeNa> cale : previously i work like this
21:26:40 <AtheeNa>   | isSuffixOf "xes" word = init word
21:26:40 <AtheeNa> 	| (isSuffixOf "oes" word | | isSuffixOf "ches" word) = init word
21:26:40 <AtheeNa> 	| otherwise = word
21:27:04 <AtheeNa> but that one is deleting ..but i cant replace..
21:27:16 <AtheeNa> i thought i would do another function..
21:27:25 <Jedai> Cale: And complexity-wise we should reverse the word before carrying operations
21:27:29 <Cale> Well, you want to concatenate the result of that with the new suffix
21:27:37 <Cale> Jedai: let's ignore that for now :)
21:27:47 <Jedai> Cale: Guess so ^^
21:27:49 <Cale> (since it's just confusing, and these are short strings :)
21:28:04 <Cale> Premature optimisation is the root of all evil ;)
21:28:06 <AtheeNa> but how.. so using replace is not a good idea..
21:28:18 <AtheeNa> how should i do it?
21:28:34 <Cale> AtheeNa: Well, there are a number of approaches you could take...
21:29:21 <AtheeNa> do u have any example u can give... i try to do the rest..
21:29:22 <Cale> AtheeNa: I really think it will be easier to worry about one pair of suffixes at a time.
21:29:44 <AtheeNa> meaning i have to do it one at a time..
21:29:47 <Cale> AtheeNa: and you'll probably want to also report whether the replacement was made, when it is made
21:30:36 <Cale> Once you have those, you just have to think about a way to chain a bunch of those functions together so as to try all the possible replacements
21:31:00 <AtheeNa> so i have to split..the functions... one is to checksuffix and one replacesuffix..
21:31:14 <Cale> That might be a good idea, yeah.
21:31:59 <Cale> and don't forget about functions like map, filter and foldr
21:32:56 <bos> @where monadlib
21:32:56 <lambdabot> http://www.cse.ogi.edu/~diatchki/monadLib/
21:33:01 <Cale> Or possibly list comprehensions
21:33:13 <AtheeNa> chkSuffix :: Word -> Word
21:33:14 <AtheeNa> chkSuffix a = b isSuffix a
21:33:14 <AtheeNa>      where b d =  (c== 's')
21:33:18 <AtheeNa> would this be fine?
21:33:21 <bos> @where+ monadlib http://www.galois.com/~diatchki/monadLib/
21:33:22 <lambdabot> Done.
21:33:28 <Cale> Don't forget the backticks `
21:33:56 <shachaf> And the "Of", and the fact that b is a function.
21:33:57 <Cale> > "sses" `isSuffixOf` "seamstresses"
21:33:57 <lambdabot>  True
21:34:05 <AtheeNa> ooo
21:34:11 <Cale> Or:
21:34:17 <Cale> > isSuffixOf "sses" "seamstresses"
21:34:18 <lambdabot>  True
21:34:23 <Cale> which is the same
21:34:36 <AtheeNa> oh yeah..thanx shachaf..cale.. i try it now
21:35:03 <cjs> Given the string "8080", how do I turn it into a Network.PortNumber to which I can apply Network.connectTo?
21:35:27 <cjs> I am not clear on the meaning of the PortNumber data definition.
21:35:42 <Cale> You might consider a list comprehension like [replaceSuffix suf repl word | (suf,rep) <- replacements, suf `isSuffixOf` word]
21:35:46 <Cale> er
21:35:47 <shachaf> cjs: fromIntegral?
21:35:55 <Cale> [replaceSuffix suf repl word | (suf,repl) <- replacements, suf `isSuffixOf` word]
21:35:56 <shachaf> @src Integral
21:35:56 <lambdabot> class  (Real a, Enum a) => Integral a  where
21:35:56 <lambdabot>     quot, rem, div, mod :: a -> a -> a
21:35:56 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
21:35:56 <lambdabot>     toInteger           :: a -> Integer
21:36:05 <shachaf> @src Num
21:36:05 <lambdabot> class  (Eq a, Show a) => Num a  where
21:36:05 <lambdabot>     (+), (-), (*)           :: a -> a -> a
21:36:05 <lambdabot>     negate, abs, signum     :: a -> a
21:36:05 <lambdabot>     fromInteger             :: Integer -> a
21:36:05 <Cale> AtheeNa: see how that will work?
21:36:16 <Cale> AtheeNa: I'm not sure if you know about list comprehensions yet...
21:36:44 <cjs> shachaf: Thanks!
21:36:49 <shachaf> cjs: PortNumber is an Integral, so fromIntegral will turn an Integral into it.
21:37:01 <AtheeNa> cale: i've learn but still not use to it
21:37:01 <Cale> AtheeNa: But basically, you'd have a list of replacements, and this comprehension will look through that list looking for ones where the suffix is a suffix of the word in question, and produce the replacement.
21:37:21 <Cale> AtheeNa: So you'll get a list of all the possible ways to replace the suffix.
21:37:35 <Cale> (because more than one might match, or none might match)
21:37:47 <Cale> and once you have that list, it's easy
21:37:57 <cjs> That seems weird terminology. (read "17" :: Int) is already an Integral, right?
21:38:07 <shachaf> cjs: Yes.
21:38:12 <Cale> You either pick the first element, say, or if the list is empty, return the original word unchanged.
21:38:15 <shachaf> @ty fromIntegral
21:38:16 <lambdabot> forall a b. (Num b, Integral a) => a -> b
21:38:28 <daniel_larsson> Someone familiar with the pureMD5 library on hackage?
21:38:28 <shachaf> fromIntegral turns an Integral into a Num.
21:38:31 <ddarius> lament: Usually there's a unit and zero structure as well and a distributive rule.
21:38:54 <sjanssen> @src PortNumber
21:38:54 <lambdabot> Source not found. Maybe if you used more than just two fingers...
21:39:17 <cjs> Hm. But doesn't the "Integral PortNumber" instance let you just use an Integral directly? Or is that not what it means? How does one figure out that one needs a Num as the argument to the PortNumber constructor?
21:39:30 <lament> ddarius: the two operations don't necessarily have to go together but sure
21:39:34 <shachaf> newtype PortNumber = Network.Socket.PortNum GHC.Word.Word16
21:39:34 <cjs> @ty PortNumber
21:39:35 <lambdabot> Not in scope: data constructor `PortNumber'
21:39:49 <shachaf> cjs: No, it means it's an instance of the class Integral.
21:40:11 <lament> ddarius: unit choice is just "a really crappy choice". Unit for concatenation is just "nothing". Distributive law is trickier to explain
21:40:19 <shachaf> cjs: You can say "8080 :: PortNumber" (with the implicit fromIntegral), but you can't use an Integer in place of it.
21:40:30 <shachaf> cjs: Just like you can't use an Integer in place of an Int.
21:41:01 <ddarius> lament: Well the fact that "concatenation" distributes over "choice" gives an "additive" natural to choice and a "multiplicative" one to concatenation.
21:41:22 <lament> ddarius: also, if you treat the operations as acting on any number of arguments, you don't really need the units
21:41:23 <ddarius> s/natural/nature
21:41:23 <cjs> shachaf: ok, I get that then; the instance declarations are just what I thought. But in the ghc library docs, I see only "data PortNumber" and the instance declarations, nothing else.
21:41:41 <ddarius> lament: They're still there, just as the operation acting on zero arguments.
21:41:44 <cjs> @ty Network.PortNumber
21:41:45 <lambdabot> Network.Socket.PortNumber -> Network.PortID
21:41:59 <ddarius> This is related to unbiased multicategories.
21:42:01 <lament> ddarius: right
21:42:07 <roconnor> AHHHHHHHHH! Delimited continuations!
21:42:10 <lament> units themselves only become important if you have inverses as well
21:42:15 * roconnor 's head explodes
21:42:20 <lament> which you don't
21:42:44 <ddarius> roconnor: Delimited continuations are fun.
21:42:47 <roconnor> @check \x -> 1*x == x
21:42:48 <lambdabot>  OK, passed 500 tests.
21:42:48 <shachaf> \bot should have :i.
21:42:58 <ddarius> shachaf: Implement it.
21:43:00 <cjs> Oh, wait, is this because Network.PortNumber is really Network.Socket.PortNumber?
21:43:04 <roconnor> ddarius: they look pretty awesome
21:43:53 <Cale> AtheeNa: Let me know if that goes well or not, or if you keep getting stuck...
21:44:16 <roconnor> ddarius: control kinda confuses me.
21:44:25 <Cale> AtheeNa: If you need help with the syntax, there's a tour of just the syntax here: http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html
21:44:26 <ddarius> roconnor: The control operator you mean?
21:44:27 <lambdabot> Title: Tour of the Haskell Syntax
21:44:42 <roconnor> ddarius: yes
21:44:55 <roconnor> ddarius: shift is moderately close to callCC.
21:44:58 <ddarius> roconnor: So the one with the dynamic prompts?
21:45:07 <roconnor> I guess
21:45:11 * ddarius prefers shift/reset.
21:45:17 <roconnor> is CC-delcont safe?
21:45:26 <ddarius> Why wouldn't it be?
21:45:45 <cjs> shachaf: I guess I just don't get where the PortNumber constructor comes from.
21:45:45 <Cale> I've yet to see a really convincing use case for delimited continuations -- they're structurally interesting, but I haven't thought of a place to make use of them.
21:45:55 <roconnor> Hmm, I remember vague worries about calling things that are out of scope.
21:46:12 <shachaf> cjs: data PortID = ... | PortNumber PortNumber | ...
21:46:26 <shachaf> cjs: The type and the constructor aren't the same.
21:46:47 <roconnor> hmmm, it requires UndecidableInstances?
21:46:55 <lament> Cale: many people say that about haskell :)
21:47:15 <Cale> lament: hehe
21:47:18 <ddarius> Cale: They are a very powerful hammer for implementing effects, but unless you are going to make that power available to your users, usually you can just "directly" implement the effect with the relevant monad.
21:48:30 <ddarius> Cale: shift/reset are much more compelling as built-in (side-effecting) operations of a language rather than being used via monads.
21:48:30 <roconnor> Cale: aren't they used to make zippers from arbitrary folds?
21:48:33 <Cale> ddarius: It would be neat to see some effects which are easier to implement starting with delimited continuations and then restricting that.
21:48:50 <cjs> Oh, ok, I see that. So "PortNumber x" was using PortID's PortNumber constructor. Now where again did we figure out it wants a Num?
21:49:12 <shachaf> cjs: newtype PortNumber = Network.Socket.PortNum GHC.Word.Word16
21:49:20 <Cale> roconnor: I have no idea.
21:49:25 <shachaf> cjs: instance Num PortNumber
21:49:28 <ddarius> Cale: I suspect whether an implementation was "easier" or not would depend on your familiarity with delimited continuations and whatever method you used.
21:49:35 <roconnor> ddarius: aren't they used to make zippers from arbitrary folds?
21:50:10 <roconnor> http://hackage.haskell.org/packages/archive/CC-delcont/0.2/doc/html/Control-Monad-CC-Cursor.html
21:50:12 <lambdabot> http://tinyurl.com/2py47o
21:50:15 <ddarius> roconnor: They can be used to turn an internal iteration into an external one, yes, but only if the "fold" is monadic.
21:50:21 <roconnor> Implements various cursor datatypes for iterating over collections
21:50:49 <roconnor> ddarius: oh, the fold has to be monaid so that it supports the del-continuation monad?
21:50:55 <roconnor> @monadic
21:50:55 <lambdabot> Unknown command, try @list
21:50:59 <roconnor> *monadic
21:51:01 <roconnor> bah
21:51:49 <roconnor> iterator :: (Foldable t, MonadDelimitedCont p s m) => t a -> m (Iterator m a)
21:53:09 <cjs> Ah! So I'm really calling fromIntegral :: (Integral a) => a -> PortNumber
21:53:23 <Cale> cjs: most likely :)
21:53:30 <Cale> cjs: Or something even more restricted in type
21:53:58 <lament> in other languages you usually cast "to" stuff :)
21:53:59 * roconnor can't wait to solve a problem with delimited continuations
21:54:00 <Cale> cjs: fromIntegral is generally the thing to use for numeric conversions between integer-like types.
21:54:09 <cjs> Got it. (Again.) This use of type inference to select functions polymorphic on return type is taking some getting used to.
21:54:13 <Cale> cjs: and of course, from integer-like types to anything else
21:54:27 <Cale> (like Integer -> Float)
21:55:09 <Cale> You sometimes need realToFrac, to go between various fractional types, and apart from that, you have round, floor and ceiling
21:55:14 <lament> :t fromIntegral
21:55:14 <lambdabot> forall a b. (Num b, Integral a) => a -> b
21:55:29 <ddarius> roconnor: Things typically handled well with CPS such as concurrency, coroutines, backtracking are handled very nicely with delimited continuations.  The turning inside-out of an iterator is an example of this.
21:55:41 <Cale> Most of the other functions can be safely ignored :)
21:55:46 <cjs> What does the "forall a b." do?
21:55:49 <Cale> (with regard to converting between numbers)
21:56:07 <Cale> Oh, GHC likes to explicitly quantify what types the variables range over.
21:56:12 <roconnor> ddarius: yeah, it was shouting coroutines too me.
21:56:19 <lament> cjs: the same thing it would do in math. It means the function works for any a, b such that (Num b, Integral a)
21:56:27 <roconnor> ddarius: too bad the producer/consumer stuff is largely handled by laziness.
21:56:38 <Cale> So it's saying, for any types a and b, if b is an instance of Num and a is an instance of Integral, then it can take a to b
21:57:13 <lament> cjs: the forall part is implicit whenever you have a polymorphic type
21:57:22 <lament> i'm not sure why lambdabot makes it explicit
21:57:58 <ddarius> lament: GHC does when you have some flag set.
21:58:06 <Cale> It's because -fglasgow-exts is on
21:58:17 <cjs> Ah, so it's always been there for polymorphic stuff. Ok.
21:58:23 <lament> but the signature would still be valid without the forall
21:58:29 <Cale> yeah
21:58:36 <Cale> When you write:
21:58:40 <Cale> length :: [a] -> Integer
21:58:48 <Cale> It really means:
21:58:54 <Cale> length :: forall a. [a] -> Integer
21:58:56 <cjs> Right; I see that the source code in the Prelude doesn't have the forall.
21:59:06 <Cale> Yeah, Haskell 98 didn't even let you write it.
21:59:12 <ddarius> doesn't
21:59:22 <lament> didn't. it's dead now :)
21:59:26 <cdsmithus> Maybe I'm just weird, but I always make sure -fglasgow-exts is on when teaching Haskell with GHCi, just so I get the explicit forall.  I find it helps people understand polymorphic functions.
21:59:54 <ddarius> I think them being there is helpful as well.
22:00:40 <Cale> Because of the way that it's implied like that, it (basically) only matters to write the forall when you're putting the forall elsewhere in the type signature.
22:00:46 <Cale> For example...
22:00:49 <cjs> It makes me want to try defining a type signature using thereexists.
22:01:00 <Cale> f :: (forall a. [a] -> Integer) -> String
22:01:07 <ddarius> hbc has free existentials, usually written as 'exists'
22:01:40 <Cale> Which means that it's required that the function you pass to f be polymorphic
22:01:45 <ddarius> f :: exists a. ([a] -> integer) -> String
22:02:34 <Cale> hmm...
22:03:52 <lament> ddarius: what does that mean?
22:04:00 <cdsmithus> ddarius: but would you ever want such a variable in a positive position?  I can't imagine what good it would do?
22:04:05 <ddarius> lament: The same thing as Cale's type signature.
22:04:22 <ddarius> cdsmithus: "such a variable"?
22:04:37 <cdsmithus> ddarius: an existentially quantified variable
22:04:45 <ddarius> Note that GHC doesn't support this syntax
22:04:46 <Cale> hmm, is that really the same?
22:05:10 <Cale> I suppose it is...
22:05:18 <lament> it probably is, because ghc page on this explains why ghc doesn't have exist
22:05:47 <Cale> That means that there is some a for which f can take a function of type ([a] -> Integer) and produce a String, but we have no idea what that is.
22:05:49 <ddarius> cdsmithus: Why not?  Universally quantified types readily appear in both positive and negative positions.
22:05:57 <dolio> @quote simonpj existentials
22:05:58 <lambdabot> simonpj says: My brain is too small to figure out the consequences of adding first-class existentials to Haskell
22:05:59 <Cale> So it's only valid to apply it to a polymorphic function
22:06:03 <dolio> Isn't that the reason? :)
22:06:23 <Cale> But it appears to say a little more than the (forall a. [a] -> Integer) -> String
22:06:46 <Cale> because in that type, you're explicitly stating that the only type which is acceptable is the polymorphic one
22:07:01 <ddarius> Cale: Yes, it seems to say that [a] -> Integer will only be used at one type whereas yours seems to allow it to be instantiated at multiple types.
22:07:11 <Cale> Whereas in the existential version, it seems to say that some monotype would be okay, we just don't know which.
22:07:15 <Cale> yeah
22:08:04 <ddarius> There are some quantifier motions which are not applicable in intuitionistic logic, but I never remember exactly which aren't.
22:09:14 <cdsmithus> ddarius: well, I was wrong anyway.  The easy way to see that is that in your example, a occurs in a positive context (double negated).
22:13:24 <cdsmithus> I was just thinking that I don't know how to use a function with type (exists a. Int -> a), for example.  So a exists.  Unless I know it, how does that help?
22:13:47 <Cale> cdsmithus: Your intuition is correct, that's pretty useless
22:13:51 <bd_> f someInt `seq` somethingElse <-- see if it's _|_?
22:14:04 <bd_> I suppose `seq`'s not needed as such
22:14:13 <Cale> cdsmithus: However, if you move the quantifier out a little, and include a tuple of other functions, it can become useful.
22:14:33 <Cale> exists a. (Int -> a, a -> a, a -> String)
22:14:52 <Cale> for example
22:15:06 <cdsmithus> Cale: Right, so my problem was that I grabbed onto the wrong characteristic (a in a positive position), and assumed that was why it was useless.
22:16:47 <Cale> In fact, this is how I think about object oriented programming
22:17:36 <Cale> What is an object? Well, it's something of some type which I don't know, it's hidden from me, but I have a bunch of messages I can send to it, and a way to create it.
22:18:18 <Cale> So in a certain sense, OO programming is all about using existentials, and functional programming is all about using universals.
22:19:12 <cdsmithus> Cale: Certainly interesting stuff; though a little deep for me after midnight.
22:28:33 <sckot> hullo
22:29:02 <Cale> hello
22:29:22 <sckot> i've got a newbie question, though it may be complicated
22:29:27 <Cale> sure
22:29:49 <sckot> ok --
22:29:57 <Cale> Feel free to ask all the questions you like here. It's usually a pretty effective way to learn :)
22:29:57 <sckot> i've been trying to learn haskell,
22:30:03 <sckot> thanks
22:30:17 <sckot> originally I bought SOE
22:30:28 <sckot> and i've been running into trouble there
22:30:46 <Cale> Do you have the SOE library working?
22:30:47 <sckot> i read the gentle introduction, the hhg2h, and some other web tutorials
22:30:57 <sckot> but i can't get the GLFW working.
22:31:01 <sckot> i'm on openbsd
22:31:05 <Cale> hmm...
22:31:12 <sckot> and there isn't a port for obsd|glfw
22:31:17 <Cale> dons: You're an openbsd user right?
22:31:18 <sckot> i wrote a quick and dirty one
22:31:21 <sckot> but i'm
22:31:22 <sckot> yeah
22:31:26 <sckot> dons is here? cool
22:31:31 <sckot> i was going to email him
22:31:57 <Cale> Is GLFW the SOE graphics library?
22:32:01 <sckot> i wrote a port for glfw, but i may have screwed up the shared library code
22:32:03 <sckot> yeah
22:32:16 <Cale> Okay. You can also get that in source form from Hackage.
22:32:18 <sckot> there's a wrapper for g2kH or something
22:32:18 <Cale> iirc.
22:32:37 <sckot> but i got it working enough to build some C stuff
22:32:38 <Cale> hmm
22:32:47 <sckot> but when i try to run hs I get linking errors
22:32:55 <Cale> oh
22:33:02 <Cale> are you compiling with --make ?
22:33:09 <sckot> and on the one hand, I don't expect to be able to troubleshoot FFS library errors
22:33:18 <sckot> before learning the language proper
22:33:23 <sckot> *tried it
22:33:34 <Cale> Often linking errors are just the result of not having the right package options.
22:33:39 <sckot> but i worked through several other web tutorials
22:33:41 <Cale> and --make is pretty good at guessing
22:33:46 <sckot> yeah
22:33:55 <sckot> i think i either need to find someone who knows how to do
22:34:03 <sckot> an obsd-specific workaround
22:34:04 <Cale> So try that...
22:34:06 <sckot> or i screwed up my port
22:34:15 <sckot> s'why i'm here
22:34:23 <Cale> also, I'm pretty sure there's an soe package which actually comes with GHC
22:34:28 <cjs> Can you paste the errors?
22:34:31 <Cale> (let me check)
22:34:36 <sckot> sure, just a moment
22:34:36 <Cale> @paste
22:34:36 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:34:39 <cjs> (I mean to a paste site; not here!)
22:34:43 <uebayasi> hey
22:34:46 <sckot> oh, ok
22:34:51 <sckot> how do i use it
22:35:01 <cjs> Uebayasi-san!
22:35:01 <sckot> sorry, again newbie question, i'm sure
22:35:04 <uebayasi> AsiaBSDCon 2009 is over.  it was just great. :)
22:35:17 <sckot> k
22:35:25 <Cale> hmm... maybe it's not there anymore in 6.8...
22:35:35 <Cale> grumble :)
22:36:10 <Cale> oh, hmm.
22:36:22 <Cale> I didn't know that SOE did 3D stuff.
22:36:35 <hpaste>  sckot pasted "soe-trouble" at http://hpaste.org/6749
22:37:15 <sckot> does that help?
22:37:22 <sckot> it seems like a linking error.
22:37:22 <Cale> oh, hmm
22:37:34 <cjs> Ten bucks says it's an rpath problem.
22:37:40 <sckot> rpath?
22:37:42 <Cale> rpath?
22:39:07 <cjs> You want me to debug this here, or by /msg? I'm not sure it's so terribly interesting...
22:39:20 <hpaste>  (anonymous) annotated "Random list generator" with "(no title)" at http://hpaste.org/6738#a1
22:39:42 <Cale> cjs: go for it :)
22:40:02 <Cale> cjs: There's not a whole lot else going on at the moment :)
22:40:10 <cjs> Anyway, paste up "ldd usr/local/lib/GLFW-0.3/ghc-6.6.1/HSGLFW-0.3.o" and also "readelf -d" on it.
22:42:00 <cjs> Typically what happens to me when I'm seeing messages like this is that the linker options are borked; it's getting a -L that allows it to find the shared libraries upon which the shared library being built depends, but not the -R (-w,lR, or whatever it is when given to gcc instead of ld) options that tell it to embed that information in the shared lib so that ld.so can find it.
22:42:30 <cjs> I could be wrong, of course, and just blinded by all the pain and misery this has caused me over the years. :-)
22:42:36 <sckot> i don't have a /usr/local/lib/GLFW*, aside from /usr/local/lib/glfw.a
22:43:01 <sckot> running find again from / ...
22:43:10 <sckot> i know i had a ghc path
22:43:31 <sckot> but yes, absolutely a linker issue. :/
22:43:53 <cjs> Oh, wait, I misread that; it's a .o it's talkinga about, not a .so.
22:44:21 <cjs> Although it's giving you a rather interesting path to a .o file....
22:44:22 <sckot> it's half having trouble with a linker and local enviro on obsd, half wishing i could get it right once and for all so i could port it and document it and spare other people the trouble
22:45:49 <sckot> i've goh /usr/local/lib/libglfw.a, /usr/local/isclude/GL/glfw.h,
22:46:00 <cjs> It's got to be loading a shared lib from somewhere....
22:46:05 <sckot> and docs
22:46:09 <sckot> a .so?
22:46:20 <cjs> I'd think so.
22:46:33 <sckot> the install / readme for glfw said that it preferred to avoid using shared libs.
22:47:06 <sckot> OTOH porting the core for a (cool) language i'm still learning is probably a crapshoot.
22:48:25 <cjs> Hm. Well, it could be building the .hs files on the fly, or loading the .o files on the fly somehow; I've not looked very deeply into that side of how ghc works. But almost certainly your OpenGL is a shared lib, right? What would it be statically linked to?
22:48:29 <sckot> i should probably email dons -- obsd-specific help would win big here
22:48:43 <sckot> not sure.
22:48:55 <cjs> You know, you could always set LD_PRELOAD to load your opengl lib.
22:49:03 <sckot> k.
22:49:23 <sckot> i've mostly worked with python and scheme, CL, emacs lisp
22:49:33 <cjs> Also, ktrace -i -t n will give you a good idea of what it's looking for and where.
22:49:35 <sckot> which, among other things, does avoid the whole
22:49:52 <sckot> troubleshooting linking errors skillset :/
22:50:01 <sckot> k
22:50:52 <sckot> i didn't have any trouble getting the glfw example c programs to build, though...
22:50:56 <cjs> Oh, hmm....looks like it did load OpenGL ok, it's just the GLFW.
22:51:05 <sckot> yeah
22:52:17 <cjs> It's really looking like it can't find the GLFW shared libs themselves, then, just the Haskell interface to them.
22:53:09 <sckot> yeah.
22:53:09 <cjs> ktrace the nami calls, figure out where it's looking for what, and tweak LD_LIBRARY_PATH and you've got a short term solution.
22:53:17 <sckot> nami?
22:53:36 <sckot> (i'll try to get ahold of dons.)
22:54:07 <sckot> (getting a solid port of glfw would probably help across the board, anyway. better yet having a SOE subpackage.)
22:55:06 <Cale> sckot: If you get Gtk2Hs working, there's also a Gtk2 port of the 2D SOE library.
22:55:29 <sckot> just 2d?
22:55:43 <Cale> Well, I think so...
22:56:12 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/soegtk-0.9.12.2
22:56:14 <lambdabot> http://tinyurl.com/3be5hd
22:56:37 <sckot> k, just wondered. (the \bot wrapper is nice. :) )
22:57:17 <Cale> It uses Cairo, so it should be rather pretty for that stuff :)
22:58:17 <Cale> But I didn't even know that SOE did any 3D stuff until you mentioned it, since I've only looked at that book rather briefly and the 2D library is all I'd ever seen.
22:58:45 <cjs> I've read through large chunks of the book, and I don't recall any 3D stuff.
22:58:50 <sckot> i work with 3d, so i was curious
22:59:04 <brad_larsen> anyone have a prefix dictionary / trie that works on ByteStrings w/o packing/unpacking all the time?
22:59:20 <sckot> though i do more algorithms and devilish details than the actual graphics level stuff
22:59:56 <cjs> sckot: nami is the tracing of the name -> i-node mapping stuff. If you ktrace nami, you'll get a list of all of the filenames the program is attempting to access. Extremely handy in situations like this.
23:00:15 <sckot> ok. good to know. thanks.
23:00:44 <Cale> sckot: There's a more direct OpenGL binding which comes with some distributions of GHC.
23:01:06 <sckot> i'm going to sign off (late here), see if i can get ahold of dons for the obsd stuff
23:01:08 <Cale> (and GLUT as well)
23:01:29 <Cale> sckot: cool, he should hopefully be able to help :)
23:01:29 <sckot> and then i'll have more interesting haskell questions, i'm sure :)
23:01:33 <Cale> :)
23:01:37 <sckot> not just the basic learning toolkit
23:01:43 <sckot> and thanks for your time
23:01:52 <sckot> have a good night, afternoon, both
23:02:33 <cjs> No problem. Make a dontation to NetBSD if you liked my help. :-)
23:02:39 <Cale> hehe
23:03:13 <uebayasi> just fyi - yamt@ has filed a report about ghc + ld(1) on NetBSD
23:06:38 <cjs> Ah, yes, Yamamoto-san the PR machine.
23:14:09 --- mode: irc.freenode.net set +o ChanServ
23:18:32 <cjs> Right; socket() versioning problem fixed in the NetBSD package.
23:23:54 <cjs> http://www.netbsd.org/cgi-bin/query-pr-single.pl?number=38345
23:23:56 <lambdabot> Title: NetBSD Problem Report #38345: 81 link errors when using ghc-6.8.2nb1 package 67
23:24:23 <cjs> Interesting. It works ok with ghci and runghc; it's just ghc itself that has the problem.
23:53:31 <sclv> @seen basti
23:53:31 <lambdabot> I haven't seen basti.
23:53:35 <sclv> @seen basti_
23:53:35 <lambdabot> I saw basti_ leaving #haskell-blah and #haskell 7h 19m 41s ago, and .
23:55:58 <nolrai_> @ty foldM
23:56:02 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
23:56:33 <slava> @src foldM
23:56:33 <lambdabot> foldM _ a []     = return a
23:56:33 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
23:56:47 <slava> @src foldl
23:56:47 <lambdabot> foldl f z []     = z
23:56:47 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
23:57:04 <slava> interesting
