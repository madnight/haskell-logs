00:00:32 <scook0> there's a great big article somewhere about the design rationale behind a common lisp time library
00:00:38 <scook0> it's interesting reading
00:01:04 <Excedrin> http://naggum.no/worse-is-better.html
00:01:05 <lambdabot> Title: Worse is Better
00:01:11 <Excedrin> ^- CL time stuff
00:02:30 <scook0> that doesn't look like the right article
00:02:32 <Excedrin> http://naggum.no/lugm-time.html <- oops this is the right one
00:02:32 <lambdabot> Title: A Long, Painful History of Time
00:03:01 <scook0> yep
00:04:12 <solrize> http://cr.yp.to/libtai.html         haskell should have something like this
00:04:30 <solrize> http://cr.yp.to/proto/utctai.html  see also.
00:04:55 <solrize> http://groups.google.com/group/comp.lang.lisp/msg/9a30c508201627ee    and this is my favorite naggum rant :)
00:04:57 <lambdabot> Title: S-exp vs XML, HTML, LaTeX (was: Why lisp is growing) - comp.lang.lisp | Google G ..., http://tinyurl.com/kvdyx
00:06:48 <cjs_> I'm mystified by my failure with "do t <- readTime defaultTimeLocale "%F" "2008-04-07"; putStrLn (show t); return ()"
00:06:59 <cjs_> "No instance for (ParseTime (IO t))"?
00:07:57 <dmwit> do { locale <- defaultTimeLocale; let t = readTime locale "%F" "2008-04-07"; putStrLn (show t) }
00:07:59 <solrize> defaultTimeLocale ... is in IO
00:08:05 <solrize> yeah
00:08:27 <dmwit> or...
00:08:36 <dmwit> ?hoogle defaultTimeLocale
00:08:36 <lambdabot> System.Locale.defaultTimeLocale :: TimeLocale
00:08:41 <dmwit> ah
00:08:53 <dmwit> Never mind, then it's just:
00:09:07 <dmwit> do { let t = readTime defaultTimeLocale "%F" "2008-04-07"; putStrLn (show t) }
00:09:13 <solrize> hmm
00:09:22 <dmwit> i.e. (readTime ...) is a pure function.
00:09:53 <dmwit> There are better ways of doing it, but that should suffice for now.
00:10:03 <oerjan> also, putStrLn (show ...) = print ...
00:10:16 <dmwit> yeah, so it can be just
00:10:22 <dmwit> print (readTime ...)
00:10:49 <dmwit> This is just getting shorter and shorter! =)
00:11:39 <oerjan> @quote two.lines
00:11:39 <lambdabot> qwe1234 says: so, to summarize: laziness per your definition is a form of syntactic sugar that saves one or two lines of code while making programs slower.  whoop de doo
00:11:45 <oerjan> @quote two.lines
00:11:45 <lambdabot> ddarius says: "Oh no! My code is more than two lines!  There must be a better way!"
00:12:13 <oerjan> @quote hypermonad
00:12:14 <lambdabot> No quotes match. :(
00:12:20 <oerjan> @quote hyper-monad
00:12:21 <lambdabot> jcreigh says: I've found learning Haskell makes me feel vastly inferior to Haskell coders. ("Oh,", they say, "That's just a fold over the hyper-monad fluxbox list. Here's the one-line replacement
00:12:21 <lambdabot> for your entire program.")
00:12:43 <lispy> heh
00:12:50 <lispy> I *love* the fluxbox!
00:14:04 <Twey> :-D
00:15:15 <dmwit> ?quote melt.?.away
00:15:15 <lambdabot> No quotes match.
00:15:19 <dmwit> ?quote melt
00:15:19 <lambdabot> dons says:  its like you can really see the guy's brain melting
00:15:53 <dmwit> ?quote melted.down
00:15:53 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
00:16:46 <cjs_> So this should work? main = do print (readTime defaultTimeLocale "%F" "2008-04-07")
00:17:22 <taruti> try it?
00:17:42 <cjs_> Ambiguous type variable `t' in the constraints: `ParseTime t' arising from a use of `readTime'...
00:18:01 <taruti> main = do print (readTime defaultTimeLocale "%F" "2008-04-07" :: ZonedTime)
00:18:21 <taruti> (or UTCTime, or whatever you prefer)
00:18:57 <cjs_> Phew!
00:20:19 <cjs_> So is that because readTime is polymorphic on the return value?
00:21:18 <solrize> is there such a thing as a Haskell / ML  ffi ?
00:21:41 <solrize> or a way to compile ML into GHC Core...
00:27:53 <quicksilver> solrize: ML doesn't exist.
00:28:12 <dancor> i installed ghci-on-acid but it doesn't install an executables and ghci is the same and doesn't do e.g. :pl
00:28:13 <quicksilver> solrize: the correct question to ask is "what is the SML (or ocaml) FFI like?"
00:28:19 <dancor> anyone know anything about goa
00:28:37 <quicksilver> solrize: anyhow, there isn't a direct FFI I'm aware of, you're stuck going via C.
00:29:35 <solrize> quicksilver, yeah, any ML probably has its own runtime system that would have to be active at the same time as haskell's
00:29:41 <solrize> dueling gc's
00:30:21 <solrize> is there a way to make a type X that represents a pure value, but there is no constructor for it outside the IO monad?
00:30:37 <solrize> yeah i guess so
00:30:46 <solrize> (answering own question)
00:30:52 <solrize> by writing a module for it
00:30:57 <solrize> and not exporting the pure constructor
00:31:32 <Stinger> what is the purpose of such a type?
00:31:33 <dmwit> dancor: Wasn't there something you had to put in your ~/.ghci or something?
00:31:53 <dmwit> I never got lambdabot to build, so I don't know for sure, but I seem to recall there were some manual steps required.
00:32:01 <scook0> Data.Unique is one example
00:32:08 <oerjan> Data.Unique works exactly that way
00:32:14 <oerjan> bah :)
00:32:43 <solrize> oh cool
00:32:43 <solrize> thanks
00:33:29 <dolio> Man, now I can't see "dancor" without thinking of lispy saying that sounded like a Star Wars monster.
00:34:46 <Saul_> dolio: I was thinking the same thing just now, only I wasn't around when lispy said it :)
00:35:49 <Saul_> Well actually I was thinking about the magic card
00:36:12 <dolio> [Tue Mar 18 2008] [02:16:03] <lispy> "Luke, It's a dancor, get out of there!"
00:42:46 <lispy> gwern: hm...I can't apply your patches...I keep getting an error about it being corrupted by a mailer.  This is odd.
00:42:59 <lispy> I haven't had this problem with gmail in the past.
00:43:07 <dancor> dmwit: ah, dot-ghci in the tar.gz
00:45:26 <dancor> @djinn a -> [a]
00:45:27 <lambdabot> -- f cannot be realized.
00:45:32 <dancor> why isn't it repeat
00:45:33 <lispy> what is an easy way to look at the character codes at the end of your lines in linux?
00:45:36 <dmwit> djinn doesn't do lists
00:45:43 <dmwit> ?djinn-env
00:45:43 <lambdabot> data () = ()
00:45:43 <lambdabot> data Either a b = Left a | Right b
00:45:43 <lambdabot> data Maybe a = Nothing | Just a
00:45:43 <lambdabot> data Bool = False | True
00:45:43 <lambdabot> data Void
00:45:45 <lambdabot> type Not x = x -> Void
00:45:47 <lambdabot> class Eq a where (==) :: a -> a -> Bool
00:45:47 <dancor> @djinn a -> (a, a)
00:45:49 <lambdabot> f a = (a, a)
00:45:56 <dmwit> ?help djinn
00:45:57 <lambdabot> djinn <type>.
00:45:57 <lambdabot> Generates Haskell code from a type.
00:45:57 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
00:46:01 <dmwit> ?list
00:46:01 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
00:46:23 <dmwit> ?djinn-add data List a = Cons a (List a) | Nil
00:46:26 <dolio> @djinn-add type Cont r a = (a -> r) -> r
00:46:26 <lambdabot> Cannot parse command
00:46:35 <dmwit> ?djinn a -> List a
00:46:36 <lambdabot> Cannot parse command
00:46:36 <lambdabot> -- f cannot be realized.
00:46:37 <dancor> so why doesn't it do lists?  is it too hard or actually impossible
00:46:45 <dolio> It doesn't do recursive types.
00:47:15 <dmwit> ?help fptools
00:47:15 <lambdabot> fptools <lib>. Lookup url of ghc base library modules
00:47:20 <dmwit> huh
00:47:28 <wagle_home>  ?djinn-add data List a = Nil | Cons a (List a)
00:47:34 <wagle_home> ?djinn-add data List a = Nil | Cons a (List a)
00:47:35 <lambdabot> Error: Recursive types are not allowed: List
00:47:35 <dmwit> ?help learn
00:47:36 <lambdabot> learn. The learning page url
00:47:42 <dmwit> ?learn
00:47:43 <lambdabot> http://www.haskell.org/learning.html
00:48:13 <wagle_home> it prefers the first constructor
00:48:36 <wagle_home> (iirc)
00:49:37 <dancor> do you think djinn will ever do lists
00:52:21 <wagle_home> @ho djinn
00:52:22 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
00:52:32 <wagle_home> @go djinn
00:52:34 <lambdabot> http://en.wikipedia.org/wiki/Genie
00:52:34 <lambdabot> Title: Genie - Wikipedia, the free encyclopedia
00:52:39 <wagle_home> bah
00:52:50 <dmwit> ?where djinn
00:52:51 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
00:52:57 <dmwit> That's not all that helpful.
00:53:29 <wagle_home> i havent read it, so i cannot say h9ow hard lists are
00:53:37 <dancor> who's working on a conversational ai for \bot
00:53:56 <oerjan> @vixen Do you know anything about that?
00:53:57 <lambdabot> yeah, i know
00:54:13 <wagle_home> @vixen faq
00:54:13 <lambdabot> I have 2 c what u look like.. u have pic?? URL?? NOT a fake please.. ill know!
00:54:29 <wagle_home> awww
00:54:44 <dmwit> @vixen Wait a second... are you a bot?
00:54:44 <lambdabot> no, why? do i seem "botty"?
00:54:57 * wagle_home wanted vixen to say "yes, i can do that!"
00:56:00 <wagle_home> @vixen Wait a second... are you a naught?
00:56:01 <lambdabot> i truely am
00:56:29 <dmwit> ?vixen-on
00:56:30 <lambdabot> Not enough privileges
00:56:32 <dmwit> aww
00:56:43 <dmwit> Probably for the best.
00:56:45 <oerjan> extremely naughty in fact
00:56:51 <Mr_Awesome> dmwit: hurry, go get some more privileges!
00:57:57 <wagle_home> <peterz> http://icanhascheezburger.files.wordpress.com/2008/03/funny-pictures-catfish-fishcat.jpg
00:58:11 <dmwit> lambdabot> What do you think of Foucault's theory of binary constructs as an imprisoning limitation on power imposed by arbiters?
01:01:12 <wagle_home> lambdabot: What do you think of Foucault's theory of binary constructs as an imprisoning limitation on power imposed by arbiters?
01:01:47 <dmwit> No, \bot said that to me.
01:02:00 <wagle_home> @vixen What do you think of Foucault's theory of binary constructs as an imprisoning limitation on power imposed by arbiters?
01:02:00 <lambdabot> maybe. do you?
01:02:28 <dmwit> ?vixen What are you thinking about?
01:02:28 <lambdabot> yes, i am
01:02:35 <dmwit> ?vixen what are you thinking about
01:02:38 <lambdabot> i dunno, was i doing that?
01:02:38 <dmwit> ?vixen what are you thinking about
01:02:38 <lambdabot> i dunno, was i doing that?
01:02:43 <oerjan> @brain
01:02:43 <lambdabot> Whuu... I think so, BrainPan! But if running shoes had little feet, wouldn't they need their own shoes?
01:02:50 <wagle_home> @vixen Wait a second... are you a naugh?
01:02:50 <lambdabot> i truely am
01:02:53 <wagle_home> @vixen Wait a second... are you a naugh?
01:02:53 <lambdabot> yes, i am
01:02:57 <wagle_home> @vixen Wait a second... are you a naugh?
01:02:58 <lambdabot> yes, i am
01:03:01 <wagle_home> sigh
01:03:14 <dmwit> ?vixen I've been thinking.
01:03:15 <lambdabot> What do you think of Foucault's theory of binary constructs as an imprisoning limitation on power imposed by arbiters?
01:03:34 <dmwit> Her responses are strongly keyword-based.
01:03:36 <oerjan> o_O
01:03:58 <wagle_home> @vixen Wait a second... are you a naughty bot?
01:03:58 <lambdabot> no, how dare you ask if i'm a bot!
01:04:07 <wagle_home> @vixen Wait a second... are you a naughty bot?
01:04:07 <lambdabot> no, why? do i seem "botty"?
01:04:15 <wagle_home> yeha
01:04:21 <wagle_home> yeah, even
01:04:50 <oerjan> @vixen Are you a fxuffohgnap?
01:04:51 <lambdabot> i think you know the answer to that one, silly
01:05:21 <dmwit> @vixen a/s/l
01:05:21 <lambdabot> 19/f/California
01:05:25 <dmwit> hot!
01:05:27 <wagle_home> @vixen do you love oerjan?
01:05:28 <lambdabot> i wouldn't say i do love...
01:27:07 <wagle_home> oh well
01:56:22 <stevan> good morning. how can i implement this function properly: modifys k v = modify $ \s -> s { k = v }
01:56:58 <opqdonut> that's about as elegant as you can get
01:57:04 <opqdonut> ah, i see
01:57:10 <opqdonut> you need fst-level accessors
01:57:16 <opqdonut> there's a library for that
01:57:19 <opqdonut> i'll try to google
01:59:44 <opqdonut> http://www.opensubscriber.com/message/haskell-cafe@haskell.org/5137557.html
01:59:46 <lambdabot> Title: [Haskell-cafe] Extended functionality for record field accessors, http://tinyurl.com/2vavhk
01:59:51 <opqdonut> that's kinda like it, but not quite
02:00:11 <opqdonut> oh, well, that's pretty much it
02:00:22 <opqdonut> but there's a proper (packaged, documented) version too
02:00:28 <opqdonut> stevan: you following me?
02:01:45 <stevan> yeah, i was googling myself. thanks.
02:09:11 <dmwit> ?where fref
02:09:11 <lambdabot> I know nothing about fref.
02:09:17 <dmwit> ?where funref
02:09:17 <lambdabot> I know nothing about funref.
02:09:41 <dmwit> stevan: http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
02:09:43 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
02:13:17 <stevan> interesting, thanks.
02:28:12 <Esteth> Can anyone reccomend a resource for finding out how to use monads for state? Everything i read seems to be "this is how monads are defined, lets define a new monad..."
02:28:25 <dmwit> ?go all about monads
02:28:26 <lambdabot> http://www.haskell.org/all_about_monads/
02:28:26 <lambdabot> Title: All About Monads
02:28:29 <dmwit> ?docs State
02:28:29 <lambdabot> State not available
02:28:55 <Esteth> Thanks :)
02:29:03 <dmwit> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State-Lazy.html
02:29:04 <lambdabot> http://tinyurl.com/2sjf3c
02:29:08 <quicksilver> Esteth: are you happy with the notion of s -> (a,s) as a model for state?
02:29:32 <quicksilver> Esteth: basically you could add a parameter to every function, and also an extra return value to every function.
02:29:37 <quicksilver> that's the basic model
02:29:45 <quicksilver> all monads do is provide a way to hide the details
02:29:47 <quicksilver> (Which is good!)
02:29:56 <opqdonut> yath or some such basic text has the "construction" of State
02:30:36 <dmwit> The "debuggable functions" from YCHIMAMYAD are also closely-related to State.
02:30:42 <dmwit> ?go you could have invented monads
02:30:43 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
02:30:43 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
02:32:03 <Esteth> quicksilver: ahh, right. So instead of passing every function that needs to know what the name of the user is the name, we hide it and let the compiler do it for us?
02:32:26 <dmwit> Kind of, yes.
02:32:35 <pjd> Esteth: is the name of the user something you'll be modifying?
02:32:53 <pjd> if not, you don't need the whole State monad;  you can use the simpler Reader monad
02:33:25 <dmwit> To be honest, the Reader monad never really made sense until I understood the State monad.
02:33:38 <dmwit> So if he's still learning, it might make sense to use State anyway.
02:33:38 <Esteth> pjd: It was a theoretical example, but in practice, probably not. The reader monad gives me "global" variables then?
02:33:55 <dmwit> Esteth: Global immutable variables.
02:34:01 <mauke> read-only
02:34:01 <pjd> Esteth: yes, it lets you read from an environment, basically
02:34:10 <Esteth> I probably want to understand state anyway, so if it helps me understand reader, then that can only be good :)
02:34:19 <dmwit> Esteth: (With the possibility for local changes that are guaranteed not to leak out.)
02:34:41 <Esteth> dmwit / pjd : Ok
02:34:47 <mauke> actually, only a single "variable"
02:35:08 <mauke> you can locally override it, but you can't change it for your caller
02:35:09 <dmwit> tuples => moral equivalent of multiple variables
02:35:20 <mauke> hmm, this is a lot like unix environment variables
02:35:42 <mauke> why didn't anyone tell me?!
02:35:47 <pjd> Reader is a subset of State, so i'm not sure why you'd want to tackle State first
02:35:53 <dmwit> We thought you knew!
02:36:24 <dmwit> Primes are a subset of integers, why would you want to tackle integers first?
02:36:47 <pjd> dmwit: not quite, primes are integers with extra properties
02:37:05 <dmwit> ...you're saying the primes are not a subset of the integers?
02:37:46 <pjd> dmwit: what you need to understand primes is certainly not a subset of what you need to understand integers
02:37:53 <dmwit> Reader is State, but with the extra property that you can't write.
02:38:08 <mauke> no, State is Reader with the extra property that you can change the value
02:38:27 * dmwit shrugs
02:38:40 <dmwit> For me, not all conceptually smaller things are easier to understand
02:38:42 <dmwit> .
02:38:59 <pjd> dmwit: put another way, understanding State presupposes understanding Reader
02:39:23 <pjd> so once you've done the work to understand State, you already understand Reader
02:39:36 <pjd> but you can do Reader first, to understand half of State
02:39:41 <dmwit> I don't really agree.
02:50:12 <Spark> small things that are not easy to understand are interesting though
02:50:28 <Spark> usually it's just a case of getting over your preconceptions though
02:50:35 <Spark> then they become easy to understand like everything else
02:50:46 <quicksilver> I also don't particularly agree with pjd
02:50:49 <quicksilver> on either point
02:51:01 <quicksilver> I don't think understanding State presupposes understanding Reader
02:51:10 <quicksilver> and I don't think understanding reader first is terribly helpful.
02:51:21 <quicksilver> I think reader is actually too simple to serve as a useful example of a monad
02:51:30 <quicksilver> people's first reaction is oftne "Why bother"
02:52:11 <opqdonut> yep
02:52:17 <opqdonut> i'm of the same mind
02:52:17 <stevan> i think the easiest way to get started is some small examples, so that you can play around with it and get a feel for how it works. flip runState 0 $ modify (+1)
02:52:34 <opqdonut> playing around with the IO monad turned out really helpful
02:52:51 <opqdonut> just by looking at the types and the intuitive semantics of >> and >>=
02:55:57 <Esteth> hm. If i do "f = do ..." which monad am i using to sequence the stuff?
02:56:08 <opqdonut> any monad
02:56:18 <opqdonut> :t do return undefined
02:56:18 <osfameron> whichever the first expression starts with
02:56:21 <lambdabot> forall a (t :: * -> *). (Monad t) => t a
02:56:48 <quicksilver> Esteth: the type checker wil try to work it out.
02:57:08 <quicksilver> Esteth: if the type checker finds no reason to choose a particular monad, then you have written a "polymorphic" function which works in any monad.
02:57:29 <quicksilver> :t do { return 1 }
02:57:30 <lambdabot> forall t (t1 :: * -> *). (Monad t1, Num t) => t1 t
02:57:30 <Esteth> quicksilver: Ahh, ok
02:57:33 <quicksilver> ^^ any monad
02:57:40 <quicksilver> :t do { Just 5 ; return 1 }
02:57:41 <lambdabot> forall t. (Num t) => Maybe t
02:57:45 <quicksilver> ^^ forced into Maybe.
02:58:34 <skorpan> ^^ is a manga smiley, no?
02:58:49 <quicksilver> yes, but it's also an up arrow
02:58:53 <Esteth> Ok. I should probably have thought of :t'ing a do block to see what type i get :)
02:58:56 <skorpan> fsck manga.
02:59:47 <dmwit> 2 blocks are missing!
02:59:53 <pjd> quicksilver: maybe i should have said "includes" rather than "presupposes"
02:59:55 <dmwit> You must remount with -ro.
03:00:54 <dmwit> skorpan: http://www.ee.ryerson.ca/~elf/hack/ugvs.html
03:00:55 <lambdabot> Title: Hacker's Wisdom: The Unix Guru's View of Sex
03:02:13 <skorpan> dmwit: ooooh yeaaaah... giggidy giggidy
03:02:54 <skorpan> i'm not sure it's supposed to be #!/bin/ssh though
03:03:08 <dmwit> Oh no, that's quite intentional.
03:03:13 <dmwit> ssh!
03:03:27 <dmwit> ;-)
03:03:53 <skorpan> that's so lame :/
03:04:00 <skorpan> sex should be loud
03:04:13 <dmwit> heh
03:04:18 <skorpan> and it should have been some "make; make love" in there
03:04:41 <skorpan> then perhaps "make clean" afterwards
03:20:06 <oklofok> @die 1d2
03:20:06 <lambdabot> 1d2 => 1
03:38:41 * SamB wonders why sort has been invoked as root...
03:38:41 <lambdabot> SamB: You have 1 new message. '/msg lambdabot @messages' to read it.
03:38:47 <SamB> @messages
03:38:47 <lambdabot> gwern said 7h 22m 33s ago: btw, I added an strace of the zmachine crash: http://hackage.haskell.org/trac/ghc/attachment/ticket/2164/zmachine.strace
03:54:11 <SL> hello. I am having problems writing a type signature for http://hpaste.org/6497
03:54:20 <SL> it should be an IArray
03:55:14 <Jaak> @type listArray ((0,0), (1,1))
03:55:15 <lambdabot> forall t t1 e. (Ix t1, Ix t, Num t1, Num t) => [e] -> Array (t, t1) e
03:55:28 <Jaak> @type listArray ((0,0), (1,1)) [0..3]
03:55:29 <lambdabot> forall t t1 t2. (Ix t1, Ix t, Enum t2, Num t2, Num t1, Num t) => Array (t, t1) t2
03:55:40 <Jaak> @type listArray ((0,0), (1,1)) [0..3] :: IArray (Int, Int) Int
03:55:41 <lambdabot>     Not in scope: type constructor or class `IArray'
03:55:45 <smg> good morning at all.
03:56:00 <Jaak> just give it explicit sype signature
03:56:03 <Jaak> type*
03:56:10 <smg> what library is suggested to build simple guis in haskell?
03:56:10 <SamB> SL: you perhaps should not be importing anything from Data.Array itself?
03:56:21 <Jaak> gtk2hs
03:56:22 <SamB> @hoogle IArray
03:56:22 <lambdabot> Data.Array.IArray :: module
03:56:22 <lambdabot> Data.Array.IArray.IArray :: class IArray a e
03:56:38 <Jaak> atleast that's my preference
03:56:51 <SL> thought it has type IArray (Int, Int) Int
03:56:57 <SamB> you could either import Data.Array.IArray, or if you wanted some specific array type besides Array, just import the appropriate module...
03:57:03 <SL> but IArray is not a type constructor
03:57:15 <SamB> IArray is a typeclass
03:57:20 <SamB> not a type constructor
03:58:16 <smg> gtk2hs?
03:58:27 <Jaak> smg: google
03:58:32 <Jaak> first result
03:58:35 <SamB> @where gtk2hs
03:58:36 <lambdabot> http://haskell.org/gtk2hs/
03:58:38 <SamB> or that
03:58:43 <SamB> @go gtk2hs
03:58:44 <lambdabot> http://www.haskell.org/gtk2hs/
03:58:44 <lambdabot> Title: Gtk2Hs
03:58:49 <SamB> take your pick ;-)
03:58:54 <Jaak> ah. right, right
03:59:07 <SL> SamB, type IArray a e => a (Int, Int) e does not work
03:59:26 <SamB> SL: what happens if you try that?
03:59:48 <smg> no, i wanted to know if gtk2hs is appropriate
03:59:58 <SamB> smg: why not?
04:00:06 <Jaak> define: appropriate
04:00:10 <SL> SamB, Could not deduce (IArray a Int) from the context (IArray a e) arising from use of `listArray'
04:00:42 <atsampson> I assume this isn't the intended behaviour:
04:00:45 <atsampson> Prelude Data.Int> (minBound :: Int32) `rem` (-1)
04:00:45 <atsampson> Floating point exception
04:00:46 <SamB> SL: you must be trying to treat the array as an array of Int
04:01:13 <SamB> did it say which code wanted the IArray a Int context?
04:01:15 <mauke> atsampson: it is, kind of
04:01:47 <atsampson> I'd sort of like it to do something other than just crashing the interpreter/my compiled program ;)
04:01:48 <SamB> mauke: but FPE?
04:01:56 <smg> Jaak: smg> what library is suggested to build simple guis in haskell?
04:02:00 <mauke> SamB: that's normal for integer arithmetic
04:02:00 <smg> Jaak: ;-)
04:02:02 <SamB> atsampson: what is `rem`
04:02:12 <mauke> SamB: remainder
04:02:14 <SamB> mauke: yeah, yeah...
04:02:16 <atsampson> it's in Integral
04:02:31 <SamB> atsampson: is that with Int or Integer?
04:02:47 <mauke> Int32
04:02:54 <atsampson> it's with Int32 on both sides
04:02:55 <SamB> oh, right, you said alrady
04:03:06 <smg> didn't we have this rem thing yesterday? :P
04:03:09 <SamB> maybe you should use mod or soemthing
04:03:26 <mauke> atsampson: I get "*** Exception: arithmetic overflow" in 6.8.2
04:03:38 <SamB> atsampson: what would you want to happen instead?
04:03:44 <atsampson> no, because it's doing constant folding in an occam compiler, and the operator it's evaluating is remainder, not modulo ;)
04:03:53 <atsampson> I'd actually expect it to return 0
04:04:08 <mauke> it's performing the actual division first, which throws
04:04:14 <quicksilver> > -5 `rem` -1
04:04:15 <lambdabot>      precedence parsing error
04:04:15 <lambdabot>         cannot mix `rem' [infixl 7] and prefix ...
04:04:23 <quicksilver> > (-5) `rem` (-1)
04:04:25 <lambdabot>  0
04:04:29 * quicksilver nods
04:04:46 <SamB> mauke: hmm
04:05:06 <SamB> so... if everything else `rem` -1 returns 0...
04:05:19 <atsampson> mauke: ah, I'm using 6.6 here -- I get an exception with 6.8.1 too, so I guess it's been fixed; sorry!
04:05:37 <SamB> atsampson: so you actually think that's an improvement?
04:05:46 <atsampson> well, it's definitely an improvement over crashing
04:05:48 <atsampson> ;)
04:06:01 <SamB> I bet that's just a signal handling improvement
04:06:37 <quicksilver> it doesn't crash my 6.6.1, by the way
04:07:33 <SamB> hmm, it doesn't crash GHCi here...
04:07:43 <SamB> er. wait
04:07:48 <SamB> I ran the wrong expression
04:08:51 <smg> Jaak: i guess glade is good for me i don't want to bother with GUI i want to bother with algorithms :]
04:09:42 <hpaste>  Jaak annotated "(no title)" with "(no title)" at http://hpaste.org/6497#a1
04:10:02 <Jaak> then write console applications
04:10:28 <smg> Jaak: sure, but my users want a gui so ... :)
04:12:04 <Jaak> if your users are using windows then better go with wx
04:12:29 <SamB> what users?
04:12:54 <Jaak> um? the ones who want the gui?
04:13:16 <SamB> smg: who use your programs?
04:13:52 <oklofok> @t (%)
04:13:52 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
04:14:05 <oklofok> > (%) 1 2
04:14:06 <lambdabot>  1%2
04:14:10 <oklofok> ah
04:14:20 <Jaak> > (%) 2 4
04:14:20 <lambdabot>  1%2
04:14:27 <oklofok> > (%) 1 2 * (%) 4 3
04:14:28 <lambdabot>  2%3
04:14:34 <smg> SamB: linux
04:14:48 <Jaak> > (1/2 * 4/3) :: Ratio Int
04:14:49 <lambdabot>  2%3
04:15:09 <Jaak> gtk2hs is just fine then
04:15:15 <smg> hehe ok
04:15:17 <Jaak> glade is overkill for simple gui
04:16:55 <opqdonut> > map (approxRational pi.(10^^).negate) [1..]
04:16:56 <lambdabot>  [16%5,22%7,201%64,333%106,355%113,355%113,75948%24175,100798%32085,103993%33...
04:17:07 <opqdonut> ^_^
04:17:11 <dmwit> > 1 % 2 -- nicer syntax than (%) 1 2
04:17:12 <lambdabot>  1%2
04:17:47 <dmwit> :t approxRational
04:17:48 <lambdabot> forall a. (RealFrac a) => a -> a -> Rational
04:18:32 <byorgey> huh, I've never heard of approxRational before
04:18:49 <byorgey> > approxRational 0.1234 0.1
04:18:50 <lambdabot>  1%5
04:18:50 <opqdonut> :)
04:18:58 <byorgey> > approxRational 0.1234 0.01
04:18:59 <lambdabot>  1%8
04:19:35 <skorpan> does the "main" function always have to be :: IO ()?
04:19:55 <dmwit> skorpan: Yes, except in GHC, where it's allowed to be :: IO a.
04:20:03 <quicksilver> skorpan: I think it's probably allowed to be IO a, but the return value is thrown away
04:20:06 <quicksilver> so it's just a convenience.
04:20:14 <skorpan> okay, well i'm using GHC, so i should be fine then
04:20:25 <SamB> quicksilver: except that's not what GHC does
04:20:26 <SamB> is it?
04:20:31 <quicksilver> is it not?
04:20:40 <SamB> doesn't GHC print it?
04:20:41 <quicksilver> what does it do?
04:20:45 <quicksilver> ghci prints it
04:20:47 <quicksilver> GHC doesn't though
04:20:49 <skorpan> i don't really care about the return value tbh, i just want to be able to get out of the IO monad
04:20:56 <quicksilver> (a compiled program doesn't print its result)
04:21:06 <SamB> quicksilver: have you tried it with any type besides IO ()?
04:21:14 <quicksilver> I think so.
04:21:14 <SamB> it clearly doesn't print it in the IO () case
04:21:51 <byorgey> skorpan: you can't get out of the IO monad.  but you can call pure functions from within main.
04:22:14 <quicksilver> skorpan: in what sense do you want to 'get out of' it?
04:24:50 <atsampson> hm -- the instance of Integral for Int32 actually checks for minBound `rem` -1 and throws an overflowError
04:48:13 <drFetch> > fix show
04:48:13 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
04:48:50 <kpreid> > show (fix :: String -> String)
04:48:51 <lambdabot>  Couldn't match expected type `String'
04:49:02 <kpreid> > show (fix :: (String -> String) -> String)
04:49:03 <lambdabot>  "<([Char] -> [Char]) -> [Char]>"
05:00:53 <rlblaster> Hi! I'm very interested in Haskell (after some years of C coding), and begin learning it this day. Seems pretty cool. So my question: Can I apply to SOC to make an IDE or game in Haskell for example, even if I don't have much experience with it?
05:01:01 <rlblaster> *began
05:01:35 <quicksilver> well, anyone can apply
05:01:55 <Baughn> rlblaster: You'd be very unlikely to get in, I suspect
05:01:56 <quicksilver> the question is, will you be able to convince the committee that your application is one of the best?
05:03:07 <quicksilver> if you want to get a haskell-based SOC proposal accepted, you should probably get hacking quickly
05:03:15 <quicksilver> to convince people that you have the necessary skills
05:03:22 <quicksilver> (but you don't have long...)
05:04:12 <rlblaster> Well, I'm next to the computer 25 hours per day, I'll try to grasp the basics and make some demos.
05:04:30 * quicksilver nods
05:07:11 <Peaker_> isn't SOC closed for proposals this year?
05:08:07 <quicksilver> not as far as I know
05:08:26 <rlblaster> Students can not yet apply.
05:08:40 <Zao> The deadline for mentoring orgs is around now though, I believe.
05:08:49 <resiak> the mentoring organisations were announced a couple of days ago
05:08:59 <quicksilver> we are an mentoring org.
05:09:08 <quicksilver> that bit is done.
05:09:21 <quicksilver> I thought students were free to submit proposals until the end of March.
05:09:26 <quicksilver> (that's still not very long, though)
05:10:32 <rlblaster> "Officially" the students can begin to apply next Monday, if I remember correctly.
05:10:55 <quicksilver> but students should not wait until then to discuss their proposal
05:11:09 <quicksilver> they should be contacting the haskell community ASAP for feedback + to build up a good proposal
05:11:12 <quicksilver> AIUI.
05:13:07 <dcoutts> @seen mnislaih_
05:13:07 <lambdabot> mnislaih_ is in #haskell and #ghc. I last heard mnislaih_ speak 16h 43m 51s ago.
05:13:21 <rlblaster> How many students have done this?
05:13:28 <rlblaster> Or is this trade secret? :)
05:13:59 <quicksilver> I don't know
05:14:08 <quicksilver> because there are more channels of communication than I monitor
05:14:15 <quicksilver> I have only seen one proposal on -cafe
05:16:32 <adiM> @pl horizon network = maximum (map fst network)
05:16:32 <lambdabot> horizon = maximum . map fst
05:46:15 <tromp> > 78476/49994
05:46:16 <lambdabot>  1.5697083650038004
06:02:20 <drFetch> whenever i quit my server to edit some code, do ":r" and ":main" i get the error: "<interactive>: bind: resource busy (Address already in use)". how do i get haskell to release the serversocket after pressing ^C?
06:02:47 <quicksilver> drFetch: Ah. You've stumbled on a dark corner.
06:03:02 <quicksilver> drFetch: when your main thread terminates, in ghci, you get the prompt back.
06:03:03 <drFetch> haha, another one!
06:03:07 <quicksilver> but your other threads are not terminated.
06:03:16 <quicksilver> if one of your other threads is still holding open that socket...
06:03:19 <quicksilver> you get the problem you describe.
06:03:20 <drFetch> ah, like in drscheme
06:03:31 <opqdonut> or the thread has terminated but the socket wasn't closed properly
06:03:36 <opqdonut> and it's in TIME_WAIT or something
06:03:42 <quicksilver> for ghci development, you want a way to kill all your threads at the end of main.
06:04:00 <drFetch> opqdonut: i put the loop in a bracket
06:04:32 <drFetch> quicksilver: but will that code (killing all threads at the end of main) run when i press ^C?
06:06:09 <drFetch> i don't use stdin so i'm tempted to also forkIO the main control loop, wait for a line of input and than run all the shutdown code but it seems like a hack :/
06:08:25 <vegai> oy, lambdabot is still rather difficult to build ;-/
06:09:26 <Baughn> Actually, I should probably ask. Are the Data.Map operation asymptotic bounds amortized or worst-case?
06:09:58 <opqdonut> amortized i'd think
06:10:11 <opqdonut> or hmm, might even be asymptotic
06:10:32 <Baughn> I was asking whether they were asymptotic amortized or asymptotic worst-case. ;)
06:10:42 <psofa> hello! i want to create a func that returns both Booleans and Integers.Can anyone point me to the right and most painless direction?
06:11:04 <opqdonut> Baughn: asymptotic worst-case i'd think
06:11:06 <Baughn> And yes, amortized is quite possible. It's just that (barring evil code) they /can't/ be amortized in a pure, strict language. Of course, haskell isn'T strict.
06:11:09 <opqdonut> based on how it is implemented
06:11:13 <kpreid> psofa: ... -> Either Bool Integer
06:11:14 <tromp> return a pair (Int, Bool)
06:11:25 <Baughn> opqdonut: Hm. I'll try reading the code again.
06:11:38 <psofa> thanks to both :)
06:11:46 <opqdonut> you se balancing only has be done on the path from the changed node to the root
06:11:47 <kpreid> psofa: evidently your request was ambiguous. you want them at the same time or one or the other??
06:11:52 <kpreid> s/\?\?/?/
06:11:55 <opqdonut> thus O(logn)
06:12:21 <psofa> actually only one at a time
06:12:29 <psofa> but i could live with the pair :)
06:12:42 <kpreid> well, you want Either then
06:12:51 <kpreid> or you can define your own type...
06:12:55 <kpreid> @src Either
06:12:55 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
06:12:59 <kpreid> eh?
06:13:08 <kpreid> anyway, data Either a b = Left a | Right b
06:13:38 <tromp> does the caller know what he's getting back?
06:13:44 <kpreid> sure
06:13:54 <kpreid> *any* ordinary data type lets you find that out
06:14:21 <kpreid> pattern match it
06:14:37 <tromp> no, i mean before seeing the rsult
06:14:51 <opqdonut> kpreid: well the constructors might be hidden :)
06:15:06 <psofa> hes getting just an Either right?
06:15:08 <kpreid> point
06:15:19 <kpreid> tromp: oh, misunderstood
06:15:21 <tromp> if u return pair, the caller wldnt know whether to use Int or Bool part?
06:15:58 <psofa> my caller will be able to know which one to use :)
06:19:56 <quicksilver> drFetch: it will if you install a sigint handler, maybe?
06:20:04 <quicksilver> drFetch: I'm actually not sure what ^C does in GHCI.
06:23:33 <drFetch> quicksilver: i'm still struggling with how to deal with this issue, i don't feel like quitting and restarting ghci everytime, but i noticed you create your own :commands
06:24:09 <drFetch> so i'm looking into that, maybe i can make a command which does killing all the threads, :r and :main in one time
06:24:37 <drFetch> or maybe it exists and i look over it i mean i can't believe i'm the first one with this problem
06:25:16 <quicksilver> it doesn't exist.
06:25:32 <quicksilver> there is no way to kill all threads, without storing them all somewhere, by teh way :)
06:25:38 <kpreid> psofa: if the caller already knows, then maybe it ought to be two different functions, or a typeclass
06:25:42 <drFetch> damnit!
06:25:44 <quicksilver> after all, how would you know which threads belong to you and which to the interpreter itself?
06:26:03 <quicksilver> but it's really not very hard just to modify your 'main' to kill all its threads when it dies
06:26:07 <quicksilver> so that's what I'd suggest.
06:26:49 <drFetch> but i would have to store a list of all the client threads, no?
06:26:52 <quicksilver> yes
06:27:15 <psofa> kpreid, two diff funcs is a nogo, as for typeclass im not sure i know what it is, though it sounds like the Either solution which seems to work ok for now
06:27:15 <quicksilver> any solution to this problem will involve that.
06:27:29 <kpreid> psofa: why is it 'a nogo'?
06:27:32 <quicksilver> that's probably not a bad thing.
06:27:56 <psofa> because ill need to carry around two functions
06:28:09 <psofa> :)
06:28:33 <drFetch> yes but it's so much code (it would probably take me a day to write), i think i'm just going to close and restart ghci everytime
06:28:39 <quicksilver> drFetch: I reported a bug on it: http://hackage.haskell.org/trac/ghc/ticket/1399
06:28:41 <lambdabot> Title: #1399 (better support for developing threaded applications in ghci) - GHC - Trac
06:28:48 <quicksilver> drFetch: I day? it should take 10 minutes.
06:28:55 <drFetch> waw cool :D
06:29:04 <quicksilver> drFetch: every time you call forkIO, store the threadID in a list.
06:29:06 <quicksilver> how hard is that?
06:29:07 <quicksilver> :P
06:29:10 <drFetch> im very new to this
06:37:32 <jekor> I'm trying to install hs-plugins and I'm getting: "src/Language/Hi/Binary.hs:90:7:
06:37:32 <jekor>     Could not find module `Data.Array.Base':
06:37:32 <jekor>       it is a member of package array-0.1.0.0, which is hidden"
06:37:56 <jekor> ghc-pkg list shows array-0.1.0.0, any idea of what's going on?
06:38:19 <opqdonut> cabal hides stuff that is not listed explicitly as a dep
06:38:24 <opqdonut> or something like that
06:38:45 <Gilly> yea, try to add it manually to the .cabal file
06:39:00 <therp> has anyone studied the FizzBuzz example in the haskell type system http://blog.omega-prime.co.uk/2008/02/27/ ? I wonder why (Sub b Z a) is required in "instance (Sub b Z a)=> ModIter Z Z b Z" ? ModIter Z Z b Z is always valid in my opinion without this premise
06:39:02 <lambdabot> Title: 25 :: (Bloggable a) => a -> IO () 1 5d » 2008 » February » 27
06:39:11 <jekor> OK, I'll try that, thanks.
06:48:27 <jekor> Seems to have worked, thanks.
06:55:56 <psofa> how can i get an element of some data without doing result d = y where d = MyData y?
06:56:14 <psofa> its kindof annoying :)
06:57:11 <doserj> result (MyData y) = y
06:58:01 <doserj> or use data MyData x = MyData { myData:: x }
06:59:25 <Cale> Or  result d = case d of MyData y -> y
06:59:39 <svahn> So many lines of code. ;)
07:00:12 <Cale> Just different ways to express pattern matching
07:04:24 <dozer> :t a . b
07:04:27 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `Expr'
07:04:27 <lambdabot>     In the first argument of `(.)', namely `a'
07:20:11 <psofa> print (case result of Left y -> y
07:20:11 <psofa> 	   			 Right y -> y)
07:20:41 <psofa> whats wrong with that :( (except from ident)
07:21:02 <opqdonut> it's probably not well-typed :)
07:21:15 <opqdonut> unless result :: Either a a
07:21:46 <psofa> result :: Either Bool Integer
07:22:10 <psofa> but print can get both Ints and Bools so whats wrong?
07:22:10 <opqdonut> psofa: you probably want: case result of Left y -> print y; Right y -> print y
07:22:20 <opqdonut> psofa: yes but that case-expression has no valid type
07:22:27 <opqdonut> because Bool!=Int
07:22:28 <Lemmih> psofa: All subexpressions must be well-typed.
07:22:39 <psofa> lol i hate IT
07:22:51 <opqdonut> :O
07:22:53 <psofa> these nights i cant sleep i swear
07:23:16 <psofa> i see haskell all night
07:23:34 <dolio> Clearly we need some first class existential types for that. :)
07:24:28 <opqdonut> :)
07:24:50 <opqdonut> "print :: (forall a. Show a => a) -> IO ()" ?
07:25:55 <dolio> I was thinking 'case result of Left y -> y ; Right y -> y :: exists a. Show a => a' or something like that.
07:27:25 <edwardk> dolio: box it up in a data type or something data Showable a = Showable (forall a. Show a => a) then define the trivial instance for Show for Showable, instance Show Showable where show (Showable x) = show x
07:27:36 <dolio> Although that may not be the right form. I seem to recall that you don't use 'Class a => a' with exists.
07:27:37 <opqdonut> :9
07:28:12 <edwardk> but i stepped in in the middle and don't know what the original purpose was
07:28:30 <pjd> psofa: one way to understand what's wrong with that code is that print (case result of Left y -> y; Right y -> y) only involves one instance's print method
07:28:42 <opqdonut> the original problem was a type error :P
07:28:46 <dolio> edwardk: The original purpose was to avoid writing 'print' twice, so writing Showable twice is probably no better. :)
07:28:48 <pjd> but Bool and Integer need different print methods
07:28:50 <edwardk> for that matter the other day i was able to wrap a forall quantification in a newtype (not that I understand why it works)
07:28:53 <edwardk> dolio: ah =)
07:29:16 <pjd> so that's why you need to print them each inside the body of the case
07:29:24 <edwardk> i was thinking this was more like a printf issue, etc, blech
07:30:42 <dolio> Oh, that might explain it.
07:30:47 <pjd> psofa: so modulo polymorphism, you can think of the code as: case result of Left y -> printBool y; Right y -> printInteger y
07:31:16 <dolio> I do seem to recall the syntax someone used was more like 'exists a. Show a * a' which is like a product of a type and its class.
07:31:32 <psofa> well i seem to understand the well-typed subexpression rule better
07:32:28 <edwardk> dolio: that seems like a strange way to denote an existential to me. at least using a class in that way
07:32:50 <dolio> Well, I am working from a very hazy memory here.
07:33:12 * byorgey hands out blueberry lambdas
07:34:05 <psofa> opqdonut, btw your suggestion doesnt seem to work either :(
07:34:37 <opqdonut> another type error?
07:34:44 <edwardk> exists a. (a,(a -> String)) would be more sensible, or sigma a. (a -> String) or whatever, but iirc haskell just gets existentials in the form of forall quantification in data types, no?
07:34:51 <opqdonut> or which suggestion? the first one?
07:35:09 <psofa> opqdonut, the first one
07:35:17 <opqdonut> error please?
07:35:23 <psofa> after that line i stopped undestanding :P
07:35:34 <psofa> densem.hs:194:26:
07:35:34 <psofa>     Couldn't match expected type `(Var -> Either a Bool, [Char])'
07:35:34 <psofa>            against inferred type `Either a1 b'
07:35:34 <psofa>     In the pattern: Left y
07:35:34 <psofa>     In a case alternative: Left y -> print y
07:35:55 <psofa> the same one actually
07:35:59 <opqdonut> you have a type error somewhere else, then
07:36:10 <opqdonut> could you paste the code somewhere?
07:36:46 <psofa> oh crap
07:36:50 <psofa> im so sorry
07:36:57 <psofa> found it
07:37:09 <psofa> :)
07:37:21 <opqdonut> :)
07:37:27 <Le-Chuck_ITA> sorry to disturb with category theory. Do somebody know a reference for "accessible functors have final coalgebras"?
07:37:58 <dolio> edwardk: Yeah, although it's: data Existential = forall a. Constructor a-expr
07:38:45 <edwardk> er yeah, i threw the a after Showable by mistake =)
07:39:34 <dolio> Or if you're a GADT fan, just 'data Existential where Constructor :: a-expr -> Existential'
07:39:35 <edwardk> the newtype i was using i had to put the forall inside because i wanted an actual universal quantification, which is what boggled me that it worked
07:40:24 <edwardk> newtype FooAll = FooAll (forall a. Foo a) was the version that boggled me that i could define a Show instance for, etc.
07:40:43 * dcoutts_ tries to implement an exception monad using continuations
07:40:44 <dolio> Hmm.
07:40:46 <edwardk> shapr pulled that one out of his behind and i was rather surprised when it worked
07:42:00 <edwardk> but the a there is universal coz its on the right hand side of the constructor, whereas the one on the left hand side of the constructor is an existential. this is one case where i wish they had just added an exists keyword to the language rather than overload forall for its opposite
07:42:31 <dozer> edwardk: I sympathise
07:42:34 <dolio> Yeah.
07:43:31 <dolio> You could reuse it elsewhere, too like, apparently, 'runST :: forall a. exists s. ST s a -> a'
07:44:01 <edwardk> especially because in the data type for the functor that i universally quantify that way, i use the existential forall for other functors, whee
07:44:33 <dozer> it is kind of rude to overload forall to implement exists without providing negation :)
07:45:13 <edwardk> well, you have negation. data Void a; type Not a = a -> Void
07:45:14 <edwardk> =)
07:45:20 <dolio> Although, I suppose that use is a first class existential, not merely adding a new keyword for introducing existential data types.
07:46:10 <edwardk> though since Void is inhabited by bottom, its not all THAT useful in the logic that is haskell, but hey
07:46:43 <dolio> And apparently first class existentials in the Haskell type system make SPJ's head explode (or did in 2004, at least).
07:49:36 <hpaste>  jekor pasted "help please?" at http://hpaste.org/6499
07:49:52 <edwardk> well, i seem to recall their being issues with strong vs. weak existentials that cause all sorts of fun correctness issues when dropped in a type system.
08:05:44 <dozer> ouch - missmatches between Int and Integer in my code are being painful to fix
08:06:09 <Lemmih> dozer: Sprinkle fromIntegral?
08:06:31 <dozer> Lemmih: yeah, in all the 'right' places though
08:06:37 <kpreid> dozer: stop using Int?
08:06:52 <dozer> kpreid: things like replicateM in the libs are defined in terms of Int
08:07:22 <kpreid> bleh
08:10:28 <dozer> so now I have lots of "fromInteger $ toInteger foo" calls
08:10:37 <dozer> :t fromIteger . toInteger
08:10:38 <lambdabot> Not in scope: `fromIteger'
08:10:47 <dozer> :t fromInteger . toInteger
08:10:48 <lambdabot> forall a a1. (Integral a1, Num a) => a1 -> a
08:11:00 <vincenz> dozer: that's easy to fix
08:11:16 <vincenz> cast = fromInteger . toInteger
08:11:19 <vincenz> "cast foo"
08:12:10 <quicksilver> erm
08:12:17 <quicksilver> @src fromIntegral
08:12:17 <lambdabot> fromIntegral = fromInteger . toInteger
08:12:21 <vincenz> :P
08:12:22 <quicksilver> this has a name already :)
08:12:27 <vincenz> I like mine better
08:12:35 <vincenz> or even better
08:12:38 <vincenz> let int = fromIntegral
08:12:40 <vincenz> then you can do
08:12:43 <vincenz> (int) foo
08:12:47 <vincenz> :P
08:12:52 <quicksilver> ;)
08:14:43 <skorpan> is there any data structure in haskell which is a sort of circular list?
08:15:03 <skorpan> i want to use it for passing the turn to the next player in a game
08:15:10 <vincenz> skorpan: sure
08:15:16 <byorgey> > cycle [1,2]
08:15:16 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
08:15:20 <vincenz> circular_list = cycle ..
08:15:24 <vincenz> byorgey was faster
08:15:36 <skorpan> hm... i wonder how i should use that...
08:15:40 <byorgey> cycle actually creates a circular list in memory
08:15:52 <vincenz> skorpan: pass it as a parameter
08:15:56 <dozer> I think some variation on let-polymorphism is preventing me using 'cast' freely
08:16:15 <vincenz> dozer: @hpaste says more than a 1000-chatlines
08:16:18 <byorgey> doTurn (player:turns) = ....  doTurn turns
08:16:30 <vincenz> or even btter
08:16:31 <skorpan> i'll try to work on it, thanks..
08:16:42 <vincenz> doTurn(Byorgey:turns) = lose ... doTurn turns
08:16:47 <byorgey> hahaha
08:16:50 <vincenz> doTurn (Vincenz:turns) = win .. doTurn turns
08:25:29 <JohnMeacham> dozer: probaby the monomorphism restriction. just use 'fromIntegral'.
08:25:57 <dozer> JohnMeacham: yeah
08:25:59 <JohnMeacham> among other things, it has lots of rewrite rules associated with it so often gets optimized away.
08:29:01 <nolrai_> > runState (return undefined; put 1.0; return 'c')
08:29:01 <lambdabot>  Parse error at ";" (column 27)
08:29:29 <nolrai_> > runState (do {return undefined; put 1.0; return 'c'}) 2.0
08:29:29 <lambdabot>  ('c',1.0)
08:30:00 <stevan> i can't get the echo example to work: http://cgi.cse.unsw.edu.au/~dons/blog/2007/11/26 ... Ambiguous type variable `a' in the constraint: Show a' arising from a use of `echo' Probable fix: add a type signature that fixes these type variable(s)...
08:30:01 <lambdabot> Title: Haskell hacking
08:30:24 <drFetch> @src fix
08:30:24 <lambdabot> fix f = let x = f x in x
08:32:02 <quicksilver> stevan: yeah, that example doesn't look complete. It never forces the type to be anything in particular.
08:32:17 <quicksilver> stevan: presumably a real program would actually *put* something in the MVar somewhere.
08:32:22 <quicksilver> and then the type would be forced.
08:33:51 <byorgey> stevan: it looks like that code is not intended to actually be run, it's just a direct translation of the Erlang code shown above (which also does nothing useful).
08:34:03 <byorgey> stevan: try the fibonacci code shown below.
08:35:19 <dozer> programming in MonadRandom is realy nice
08:35:49 <skorpan> is there any smoother way of doing this? "head $ drop 1 $ dropWhile (/=x) myList"
08:36:28 <skorpan> @pl head $ drop 1 $ dropWhile (/=x) myList
08:36:28 <lambdabot> head (drop 1 (dropWhile (x /=) myList))
08:36:33 <quicksilver> well (!!1) would be a shorter way to say head . drop 1
08:36:56 <RayNbow> @pl \x myList -> head $ drop 1 $ dropWhile (/=x) myList
08:36:57 <lambdabot> ((head . drop 1) .) . dropWhile . (/=)
08:37:27 * RayNbow can't read pointfree definitions :p
08:37:42 <RayNbow> (unless they're fairly simple)
08:38:53 <Jaak> @type let (.:) = (.).(.) in head . drop 1 .: dropWhile . (/=)
08:38:54 <lambdabot>     precedence parsing error
08:38:54 <lambdabot>         cannot mix `(.)' [infixr 9] and `(.:)' [infixl 9] in the same infix expression
08:38:54 <lambdabot>     precedence parsing error
08:39:07 <Jaak> ah
08:39:41 <quicksilver> :t let infixr 9 (.:); (.:) = (.).(.) in  head . drop 1 .: dropWhile . (/=)
08:39:42 <lambdabot> parse error on input `('
08:39:57 <quicksilver> :t let infixr 9 .:; (.:) = (.).(.) in  head . drop 1 .: dropWhile . (/=)
08:39:58 <lambdabot>     Couldn't match expected type `[a]'
08:39:58 <lambdabot>            against inferred type `[a1] -> [a1]'
08:39:58 <lambdabot>     Probable cause: `.:' is applied to too few arguments
08:40:24 <Jaak> hmh
08:40:44 <nolrai_> @type (.:)
08:40:45 <lambdabot> Not in scope: `.:'
08:41:22 <nolrai_> @type ((.).(.))
08:41:23 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
08:41:51 <Jaak> @type let infixr 9 .:; (.:) = (.).(.) in (head . drop 1) .: dropWhile . (/=)
08:41:52 <lambdabot> forall a. (Eq a) => a -> [a] -> a
08:43:04 <quicksilver> \o/
08:45:02 <drFetch> i'm having an error that i can't seem to solve ... '''thread <- forkIO $ bracket (listenOn $ PortNumber 8000) (sClose) (handle chan)''' gives me Couldn't match expected type `()' against inferred type `ThreadId'
08:46:09 <drFetch> In the second argument of `($)', namely bracket ...
08:47:28 <drFetch> @src forkIO
08:47:28 <lambdabot> forkIO action = IO $ \ s -> case (fork# action_plus s) of (# s1, id #) -> (# s1, ThreadId id #)
08:47:28 <lambdabot>     where action_plus = catchException action childHandler
08:47:42 <quicksilver> wrong question.
08:47:45 <quicksilver> :t forkIO
08:47:46 <lambdabot> Not in scope: `forkIO'
08:47:49 <quicksilver> bah
08:47:53 <Botje> :t accept
08:47:54 <quicksilver> :t System.IO.forkIO
08:47:54 <lambdabot> Not in scope: `accept'
08:47:55 <lambdabot> Not in scope: `System.IO.forkIO'
08:48:04 <allbery_b> what does handle return?
08:48:16 <Jaak> @type listenOn
08:48:18 <lambdabot> Not in scope: `listenOn'
08:48:24 <quicksilver> :t Control.Concurrent.forkIO
08:48:25 <lambdabot> IO () -> IO GHC.Conc.ThreadId
08:48:28 <quicksilver> grin
08:48:30 <drFetch> allbery_b: handle is a curried function which waits for a socket
08:48:52 <quicksilver> drFetch: forkIO returns a ThreadId
08:48:53 <Jaak> listenOn $ PortNumber 8000 doesnt match a -> IO b?
08:49:00 <allbery_b> bracket returns the result of the third argument (the action which gets bracketed)
08:49:09 <quicksilver> drFetch: are you using 'thread' in a context which makes it think that thread is () ?
08:49:12 <Jaak> aah
08:49:16 <drFetch> uhm
08:49:16 <quicksilver> drFetch: (you may have to paste a bit more code)
08:49:18 <allbery_b> that is, apparently, a ThreadId when forkIO wants ()
08:49:23 <drFetch> okay ill poste all my code
08:50:26 <hpaste>  joricj pasted "my code" at http://hpaste.org/6500
08:52:29 <quicksilver> :t Control.Exception.bracket
08:52:30 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
08:52:34 <allbery_b> drFetch:  the forkIO at the end of handle returns a ThreadId.  the argument to forkIO must produce IO (), not IO ThreadId
08:52:37 <Jaak> yeah, the listenOn $ PortNumber 8000 is wrong defn
08:52:53 <allbery_b> fix:  append 'return ()' to definition of handle
08:52:56 <quicksilver> drFetch: you could add return () to the end of handle
08:53:01 <quicksilver> would be one fix.
08:53:34 <quicksilver> but more likely, to be honest
08:53:40 <quicksilver> is adding handle chan sock to the end of handle
08:53:40 <drFetch> aha that seemed to do it
08:53:52 <quicksilver> (surely once you've accepted one you want to listen for the next?)
08:54:19 <drFetch> oh yeaah
08:55:17 <drFetch> allright it's working again, this is looking great.
08:55:41 <vincenz> ignore a = a >> return ()
08:55:45 <vincenz> ignore $ lastaction
08:58:32 <drFetch> > let ignore a = a >> return () in ignore putStrLn "test"
08:58:34 <lambdabot>  ()
08:58:46 <drFetch> > let ignore a = a `seq` return () in ignore putStrLn "test"
08:58:47 <lambdabot>  ()
08:59:04 <drFetch> > putStrLn "test"
08:59:05 <lambdabot>  <IO ()>
08:59:10 <drFetch> ah ok
08:59:33 <dmhouse> That's pretty subtle!
08:59:45 <dmhouse> > let ignore a = a >> return () in ignore (putStrLn "test") -- This is probably what you meant.
08:59:45 <lambdabot>  <IO ()>
09:00:31 <drFetch> because of the ()'s?
09:00:38 <dmhouse> If you did it your way round, it does putStrLn >> return (), which is in the ((->) a) monad, not IO.
09:01:31 <drFetch> what's the googlable name of the ((->) a) monad?
09:01:37 <dmhouse> It's roughly Reader.
09:02:09 <drFetch> hmm, don't know that one yet. i've learned about Parser IO and State so far
09:02:51 <dozer> if I have some algorithm that takes a monadic callback, and I'd like to sometimes have the callback 'remember' a list of values, can I use WriterT to simulate that cleanly?
09:03:46 <dmhouse> ignore putStrLn "test"  ->  (putStrLn >> return ()) "test"  ->  (putStrLn >>= \_ -> return ()) "test"  ->  (\x -> (\_ -> return ()) (putStrLn x) x) "test"  ->  (\x -> return () x) "test"  ->  return () "test"  ->  (\e -> ()) "test"  ->  ()
09:03:50 <dmhouse> Is how it works, I think.
09:04:28 <dmhouse> drFetch: moral of the story, make sure you parenthesise correctly. f a b means call f with parameters a and b. f (a b) means call a with b, then call f with the results.
09:04:44 <dmhouse> The fact that anything worked at all here was a fluke, albeit it an interesting one.
09:05:30 <Cale> The ((->) e) monad is fun. Basically, computations in that monad are simply functions, and "running" a function is just applying it to the parameter which the computation as a whole gets applied to.
09:05:36 <Cale> (which is of type e)
09:06:03 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
09:06:04 <lambdabot>  ("hello","olleh","HELLO")
09:06:51 <mrd> > sequence [id, reverse, map toUpper] "hello"
09:06:52 <lambdabot>  ["hello","olleh","HELLO"]
09:07:14 <quicksilver> the problem with the (->) e monad is that it isn't wrapped.
09:07:20 <quicksilver> so it decreases the chance of type errors
09:07:23 <Cale> That's not a problem :)
09:07:33 <mrd> it's still type safe
09:07:37 <quicksilver> and increases the chance of an incorrect program compiling into something incorrect.
09:07:41 <quicksilver> it is a problem, in a sense.
09:07:42 <Cale> It makes it far more useful though.
09:07:46 <quicksilver> (not that I'm suggesting it be changed)
09:08:00 <Jaak> > id &&& reverse &&& map toUpper $ "hello"
09:08:01 <lambdabot>  ("hello",("olleh","HELLO"))
09:08:03 <quicksilver> but as you add things like monad instances for 'basic constructors'
09:08:14 <quicksilver> you increase the chance that more and more arbitrary expressions type check
09:08:15 <Cale> > liftM3 (,,) id reverse (map toUpper) "hello"
09:08:15 <lambdabot>  ("hello","olleh","HELLO")
09:08:18 <quicksilver> not always what you want.
09:08:54 <Cale> As long as things which typecheck do something useful, I think it's okay :)
09:13:18 <gbacon> @src liftM3
09:13:18 <lambdabot> liftM3 f m1 m2 m3 = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
09:14:12 <Cale> > join (*) 5
09:14:16 <lambdabot>  25
09:14:26 <Cale> That one's also worth figuring out :)
09:14:42 <Cale> @src join
09:14:42 <lambdabot> join x =  x >>= id
09:14:53 <Cale> mm... perhaps I should have that give both versions :)
09:15:05 <Cale> join x = do y <- x; v <- y; return v
09:15:45 <byorgey> Cale: hm, can't you just write  join x = do y <- x; y  ?
09:16:00 <Jaak> syntax error
09:16:13 <Jaak> wait, no
09:16:33 * Jaak looks 'do' syntax up
09:16:37 <byorgey> @type \x -> do { y <- x; y }
09:16:39 <lambdabot> forall (t :: * -> *) t1. (Monad t) => t (t t1) -> t t1
09:17:00 <mrd> :t join (*)
09:17:01 <lambdabot> forall a. (Num a) => a -> a
09:17:46 <Jaak> do { y <- x; y } == do { y <- x; id y } == x >>= id
09:17:47 <Jaak> right
09:18:05 <Cale> byorgey: Of course you can :)
09:18:27 <Cale> byorgey: It's just a little more confusing to beginners, I've found.
09:18:38 <byorgey> Cale: really?  interesting
09:18:53 <Jaak> yes, it is :P
09:18:55 <Cale> (Just slightly)
09:20:54 <gbacon> @undo \x -> do { y <- x; y}
09:20:54 <lambdabot> \ x -> x >>= \ y -> y
09:21:26 <byorgey> wow, that has a nice symmetry =)
09:21:40 <gbacon> @undo do { y <- x; y}
09:21:40 <lambdabot> x >>= \ y -> y
09:24:09 <gbacon> @redo x >>= id
09:24:09 <lambdabot> do { a <- x; id a}
09:25:12 <EvilTerran> @pl do { a <- x; id a}
09:25:12 <lambdabot> (line 1, column 4):
09:25:12 <lambdabot> unexpected "{"
09:25:12 <lambdabot> expecting variable, "(", operator or end of input
09:25:16 <EvilTerran> okay then.
09:25:24 <EvilTerran> (thought @pl might simplify the id out)
09:26:52 <kpreid> @. pl undo do { a <- x; id a}
09:26:52 <lambdabot> join x
09:27:11 <kpreid> iirc, undo was invented partly because pl didn't understand do syntax
09:33:23 <EvilTerran> yeah, but i was thinking it might be able to work around it
09:33:28 <gnuvince> > reverse $ iterate (*10) [0..3]
09:33:29 <lambdabot>   add an instance declaration for (Num [t])
09:33:31 <EvilTerran> without changing it. apparently not, tho. nevermind.
09:33:52 <gnuvince> > reverse $ iterate (*10) ([0..3] :: [Int])
09:33:52 <lambdabot>   add an instance declaration for (Num [Int])
09:34:05 <mrd> > iterate (*10) 3
09:34:05 <lambdabot>  [3,30,300,3000,30000,300000,3000000,30000000,300000000,3000000000,3000000000...
09:34:26 <mrd> > map (*10) [0..3]
09:34:27 <lambdabot>  [0,10,20,30]
09:37:00 <RayNbow> http://reddit.com/r/programming/info/6cm8f/comments/ "Help! I can't understand existential types! (self.programming)"
09:37:25 <tromp> $src fromEnum
09:37:34 <tromp> @src fromEnum
09:37:34 <lambdabot> Source not found. Are you on drugs?
09:37:44 <EvilTerran> that depends on which instance you're using
09:38:00 <tromp> @src Prelude.fromEnum
09:38:00 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:38:13 <tromp> @where fromEnum
09:38:13 <lambdabot> I know nothing about fromenum.
09:38:32 <EvilTerran> do you want fromEnum for Bools? Chars? Word8s?
09:38:43 <EvilTerran> ... Orderings?
09:38:48 <EvilTerran> ?instances Enum
09:38:54 <EvilTerran> ?src Enum
09:39:00 <tromp> @src Enum
09:39:03 <lambdabot> Couldn't find class `Enum'. Try @instances-importing
09:39:03 <lambdabot> class  Enum a   where
09:39:03 <lambdabot>     succ                     :: a -> a
09:39:03 <lambdabot>     pred                     :: a -> a
09:39:03 <lambdabot>     toEnum                   :: Int -> a
09:39:05 <lambdabot>     fromEnum                 :: a -> Int
09:39:07 <lambdabot> [3 @more lines]
09:39:09 <lambdabot> class  Enum a   where
09:39:11 <lambdabot>     succ                     :: a -> a
09:39:13 <lambdabot>     pred                     :: a -> a
09:39:15 <lambdabot>     toEnum                   :: Int -> a
09:39:16 <EvilTerran> ups
09:39:17 <lambdabot> Plugin `source' failed with: thread killed
09:39:34 <tromp> i thought fromEnum might be defined as iterate succ
09:39:57 <EvilTerran> i think you're thinking of enumFrom
09:40:00 <EvilTerran> ?src enumFrom
09:40:00 <lambdabot> Source not found. My mind is going. I can feel it.
09:40:13 <EvilTerran> fromEnum :: Int -> a, not :: a -> [a]
09:40:16 <tromp> ah, yes, i must be:)
09:40:35 <tromp> @src fromEnum
09:40:35 <lambdabot> Source not found. Take a stress pill and think things over.
09:40:45 <EvilTerran> have a look in the source link from the haddocks. it might say there, even if it's not in the @src database.
09:41:20 <skorpan> what are the exact indentation rules on if/then/else? sometimes it seems that then-else have to be more indented than the "if", and sometimes they don't
09:41:26 <skorpan> (having them on different lines)
09:41:54 <hpaste>  (anonymous) pasted "If-then-else" at http://hpaste.org/6501
09:42:02 <Jaak> > iterate succ False
09:42:03 <lambdabot>  Exception: Prelude.Enum.Bool.succ: bad argument
09:42:04 <skorpan> that gives me parse errors
09:42:10 <Jaak> > [False..]
09:42:10 <lambdabot>  Parse error at "False..." (column 2)
09:42:14 <Jaak> > [False ..]
09:42:15 <lambdabot>  [False,True]
09:42:50 <skorpan> > [1..]
09:42:51 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:42:57 <skorpan> > [False..True]
09:42:57 <lambdabot>  Parse error at "False..." (column 2)
09:43:01 <skorpan> > [False ..True]
09:43:02 <lambdabot>  [False,True]
09:43:09 <skorpan> how peculiar
09:43:39 <sclv> as I recall, then and else are supposed to be both slightly more indented than the if, but if you don't nest clauses, you usually won't notice the difference.
09:44:01 <skorpan> oh
09:44:01 <sclv> haskell-mode for emacs' indentation for them has been broken forever, which confuses people too.
09:45:36 <sclv> conceptually the "then" and "else" are part of the block introduced by the if.
09:46:16 <skorpan> okay
09:46:40 <skorpan> i wonder why they still haven't fixed the if-then-else bug in haskell-mode
09:48:50 <quicksilver> try kuribas's alternative indentation algorithm
09:48:51 <quicksilver> it fixes that, and improves other stuff too.
09:49:22 <quicksilver> as for "when it happens", it's inside layout clauses.
09:49:38 <quicksilver> if you have do if foo \n then bar \n else baz
09:49:54 <quicksilver> and you indent the 'then' at the same place as the 'if' then the layout rule for the do kicks in
09:50:04 <quicksilver> and you've really written do { if foo ; then bar ; else baz }
09:50:08 <quicksilver> which is a syntax error
09:53:02 <skorpan> where can i find this kuribas' alternative indentation algorithm?
09:53:27 <quicksilver> http://kuribas.hcoop.net/haskell-indentation.el
09:53:36 <quicksilver> @where+ kuribas-indentation http://kuribas.hcoop.net/haskell-indentation.el
09:53:36 <lambdabot> Okay.
09:53:46 <skorpan> sweet
09:54:12 <quicksilver> deeply nested if then else still looks uglier than it should
09:54:15 <quicksilver> but you can't win em all.
09:54:20 <quicksilver> it's much better in many ways :)
09:54:30 <quicksilver> it guesses the correct indentation after a single keypress much more often.
09:57:40 <skorpan> i can't seem to get it to install
09:57:50 <skorpan> (add-hook haskell-mode-hook 'turn-on-haskell-indentation)
09:57:59 <skorpan> when that line is called, i get a lisp error
09:58:03 <skorpan> Debugger entered--Lisp error: (setting-constant nil)
09:59:20 <quicksilver> you can't add anythign to the haskell-mode-hook if it isn't loaded yet
09:59:29 <quicksilver> you either need to load it unconditionally first
09:59:32 <quicksilver> or use eval-after-load
09:59:51 <quicksilver> oh, I could be entirely wrong.
10:00:02 <quicksilver> it could just be you're missing the ' before 'haskell-mode-hook
10:00:46 <skorpan> well i copied it straight from the comments in the el file
10:00:54 <quicksilver> nonetheless
10:01:00 <quicksilver> I assure you it needs a '
10:01:13 <quicksilver> that's a bug in the comment :)
10:01:23 <skorpan> now emacs doesn't complain
10:01:33 <skorpan> but i don't seem to have the minor mode set by default
10:02:16 <ScriptDevil> is it ok to skip the Continuous Passing Style part in YAHT till later? It hurts my head!
10:02:24 <skorpan> could it simply be that it doesn't provide a minor-mode-name?
10:04:12 <nominolo> ScriptDevil: that's normal
10:04:36 <ScriptDevil> nominolo: which one? skipping that unit or hurting the head?
10:05:00 <nominolo> the hurting.  just read slowly
10:05:11 <ScriptDevil> :) ok... I will
10:05:13 <nominolo> i don't think it's so hard to skip it
10:05:33 <nominolo> @where yaht
10:05:33 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
10:05:52 <skorpan> quicksilver: i'm missing indentation cycles :/
10:06:05 <skorpan> but on the other hand it indents automatically when i do a new line
10:06:45 <nominolo> ScriptDevil: ok, that seems to be a little quick
10:06:46 <ScriptDevil> skorpan: i had this problem sometime back... I think i did something to the indent files!
10:07:06 <ScriptDevil> nominolo: yeah... too many things at the same time
10:07:11 <ScriptDevil> nominolo: what do i do?
10:07:32 <quicksilver> skorpan: TAB for next indent possibility right
10:07:42 <quicksilver> skorpan: BACKSPACE for next possibility left
10:07:47 <skorpan> oh
10:07:54 <quicksilver> skorpan: the cycle is still there but you can choose which way to go
10:07:57 <ScriptDevil> quicksilver: it did not do that sometime back.. Wait. will see what I did
10:07:58 <skorpan> awesome
10:08:54 <ScriptDevil> nominolo: well. I will try reading it real slow and refer the net every now and then
10:08:57 <ScriptDevil> :) thanks
10:08:59 <ScriptDevil> bye
10:09:28 <sclv> why is there this common confusion that ghc goes above -O2 ?
10:09:34 <quicksilver> skorpan: by the way, yes, I think it doesn't provide a minor mode name
10:11:54 <skorpan> quicksilver: it did, but turn-on-haskell-indentation wasn't the function to be called at all
10:12:01 <gwern> @seen lispy
10:12:01 <lambdabot> lispy is in ##logic, #haskell-blah, #darcs, #ghc and #haskell. I last heard lispy speak 8h 56m 44s ago.
10:12:02 <skorpan> there was no such function in the el file
10:12:24 <skorpan> i just changed it to haskell-indentation-mode
10:44:53 <roconnor> what are the laws for one monad to distribute over another?
10:46:13 <EvilTerran> i've seen that covered somewhere
10:46:29 <EvilTerran> ?type Data.Traversable.sequence -- might be relevant
10:46:32 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
10:54:37 <tromp> 400/1.56
10:54:43 <tromp> > 400/1.56
10:54:45 <lambdabot>  256.4102564102564
10:55:14 <pjd> > 400/1.56 :: Rational
10:55:14 <lambdabot>  10000%39
11:12:17 <roconnor> http://en.wikipedia.org/wiki/Distributive_law_between_monads
11:12:23 <roconnor> this is more complicated than I remember
11:16:14 <profmakx> hmm
11:19:52 <roconnor> well, apparently there are five distribution laws (if we include naturality)
11:20:42 <Codex_> roconnor: yes, those diagrams look pretty difficult to understand. (I wonder if the 2 triangle diagrams are related to limits)
11:21:03 <hpaste>  dcoutts pasted "writeFileAtomic" at http://hpaste.org/6502
11:21:33 <roconnor> Codex_: they aren't that hard to figure out.  I just thought there would only be one or two diagrams
11:21:46 <roconnor> the triangle say:
11:21:58 <roconnor> dist . return = map return
11:22:00 <roconnor> and
11:22:25 <roconnor> dist . (map return) = return
11:22:58 <roconnor> here dist is what they called l.
11:24:00 <roconnor> Codex_: I take it back, those diagrams are hard to understand. :)
11:24:14 <Codex_> :)
11:24:17 <roconnor> I cheated as was looking at http://homepages.inf.ed.ac.uk/wadler/papers/monadscomb/monadscomb.ps.gz
11:24:19 <lambdabot> http://tinyurl.com/35hbya
11:25:50 <Codex_> great, my linux opened the .ps file as text :)
11:31:04 <Peaker> Hey, String is defined to be an actual list of Chars, right? Do actual implementations (ghc, for instance) store it that way? Can't they use some S=(Length, Array) for the string, and the (S, offset) for substrings?
11:31:13 <Peaker> (as a less naive implementation, that is)
11:31:14 <mrd> type String = [Char]
11:31:22 <byorgey> Peaker: that would be ByteString =)
11:31:30 <mrd> it is precisely that
11:31:31 <Peaker> I'm wondering if compilers are smart enough to optimize strings from lists to ByteStrings
11:31:41 <mrd> the semantics are different, so no
11:31:53 <mrd> and ByteString isn't always an optimization
11:31:58 <dcoutts_> though in some trivial cases it's not impossible
11:32:30 <Peaker> mrd, when is it not?
11:32:33 <tromp> Strings are fully lazy
11:32:48 <mrd> one time i wrote some code and prematurely optimized by using ByteString
11:32:55 <mrd> I changed it back to lazy IO and it was faster
11:33:11 <dcoutts_> mrd: was that strict bytestring btw?
11:33:18 <mrd> yea
11:33:29 <dcoutts_> lazy bytestring supports lazy IO of course
11:33:39 <mrd> yea, i haven't tried the new lazy bytestrings
11:33:46 <Peaker> well, it is quite hard for me to see strings as linked lists of chars, sounds like crazy overhead :)
11:33:47 <bos> it could be related to small bytestrings, too.  they have very high overhead.
11:33:57 <dcoutts_> lazy bytestrings are actually excellent for IO
11:34:00 <mrd> i actually have a lot of trouble now seeing strings as arrays
11:34:20 <mrd> whenever i use non-haskell languages i pine for [Char]
11:34:46 <Peaker> I wish that the compiler was smart enough to choose array/list based on the kind of operations that were performed on it
11:34:57 <mrd> that makes no sense
11:35:08 <dcoutts_> doesn't it?
11:35:25 <dcoutts_> it makes sense to me, and indeed it's an interesting research project
11:35:25 <mrd> unless you want the compiler to write your program for you
11:35:38 <dcoutts_> mrd: data refinement based on strictness analysis
11:35:48 <tromp> in theory, a strictness analyser cld see that you will exhaust a string
11:36:04 <Peaker> mrd, the compiler is in many senses already writing my program for me :)
11:36:16 <dcoutts_> right, if you're using a list in a spine and element strict context then you could have used a stricter data structure to start with
11:36:17 <Peaker> mrd, this is just another sense
11:36:19 <mrd> i wouldn't want it to choose a totally different data structure behind my back
11:36:41 <dcoutts_> mrd: why? because it might make the program go faster?
11:36:47 <Peaker> I'd like to be able to specify which data structure, or be able to specify "choose the  one you think is best"
11:36:48 <mrd> i'm not talking about strict vs lazy lists
11:36:53 <sclv> mrd: the compiler does that all the time anyway.
11:37:16 <mrd> when i use a list i expect an inductively defined datastructure and all that entails
11:37:27 <dcoutts_> mrd: of course it cannot change program semantics
11:37:28 <tromp> compiler is free to make any semantic preserving transformatoin
11:37:59 <sclv> the problem is that the choice between optimizations and pessimizations is going to be partially architecture-dependent too, no?
11:38:31 <mrd> one of my peeves against Python is that it calls arrays "lists"
11:38:37 <mrd> they're not lists
11:39:07 <Peaker> mrd, what does an inductively defined datastructure entail to the execution of the program?
11:39:43 <mrd> the algorithms you use
11:40:24 <Peaker> mrd, well, you're writing a program specification, not a machine-algorithm
11:40:36 <mrd> so?
11:40:58 <Peaker> mrd, so it can choose a different algorithm for your string, if it knows that it will run faster
11:40:59 <mrd> whatcha talking about, i'm not coding an algorithm?
11:41:24 <mrd> how does it know that?
11:41:33 <Peaker> mrd, I don't know, its very smart
11:42:25 <mrd> is it an oracle?
11:43:29 <Peaker> mrd: Are you saying you don't want a smart compiler to make your program run faster, or that it is strictly impossible for a compiler to successfully choose arrays over lists or vice versa in specific cases?
11:43:43 <mrd> the latter
11:43:55 <mrd> well, depending on what you mean by 'specific'
11:44:22 <Peaker> its probably not hard to synthesize cases that make it easy for a compiler to know whether it should use an array or list.
11:44:23 <dons> ?users
11:44:23 <lambdabot> Maximum users seen in #haskell: 464, currently: 460 (99.1%), active: 17 (3.7%)
11:44:35 <Gilly> are there common convenient tricks to avoid evaluation of functions with same parameters multiple times, like suppose i do fib n = fib (n-1) + fib (n-2) then on second round fib (n-2) gets evaluated again
11:45:00 <Peaker> mrd, or do you disagree such cases can be synthesized?
11:45:02 <mrd> Gilly: yah, store your results in a lazy data structure
11:45:11 <tromp> memoization, Gilly
11:45:27 <Peaker> dynamic programming
11:45:32 <mrd> Peaker: i'm sure you can come up with toy examples
11:45:41 <mrd> Gilly: the 3 of us basically said the same thing
11:45:45 <desegnis> mrd: I think Peaker's point is that the inductive definition of a list is not the same as the implementation of a linked list, so a compiler has the right, in theory, to use an array for a list if that will make for the right semantics
11:45:51 <tromp> which for single nonzero integer parameters usually amounts to computing the list of all vlues
11:45:52 <Gilly> hm, but how to do it in haskell? in C i'd just create an array and check if it has a substitute
11:46:06 <tromp> i meant nonegative
11:46:09 <Deewiant> > fix ((0 :) . scanl (+) 1)
11:46:12 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:46:18 <mrd> "tail array" is much different than "tail list"
11:46:18 <Peaker> desegnis, I think mrd agrees with that, but does not agree that there are any "non-toy" cases where the compiler is smart enough to make that decision
11:46:39 <tromp> nice one, Deewiant
11:46:40 <Peaker> mrd, "tail array" does not need to copy the array, so it can have very similar properties to "tail list"
11:46:55 <tromp> :t fix
11:46:57 <lambdabot> forall a. (a -> a) -> a
11:46:59 <desegnis> Peaker, yeah, I realized that only when I had nearly finished the sentence, and then I hit Enter anyway
11:47:18 <Peaker> mrd, so why is "tail array" that different from "tail list"?
11:47:33 <Peaker> mrd, (given a non-copying implementation)
11:47:36 <mrd> Peaker: ok, then go ahead and cons something onto the array
11:47:42 <oerjan> Gilly: you can use an array in haskell as well, even an immutable one
11:48:03 <Peaker> mrd, now cons'ing something and sharing tails is where an array ceases to work - but what if the compiler sees strings that are only tail'd, but not cons'd?
11:48:11 <Peaker> mrd, are you saying that happens only in toy examples?
11:48:21 <oerjan> Gilly: the trick is that in haskell laziness allows you to put the values in the array _before_ computing them :)
11:48:34 <Gilly> mm i got to try that :)
11:48:38 <psofa> any quick way to create the letters of the alphabet?
11:48:44 <mrd> > ['a' .. 'z']
11:48:45 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
11:48:52 <psofa> nice ty
11:48:57 <Peaker> psofa, which alphabet?
11:49:02 <psofa> lol
11:49:04 <CosmicRay> of course, at this point, the obligatory question is, "whose alphabet"?
11:49:10 <tromp> @src fix
11:49:10 <lambdabot> fix f = let x = f x in x
11:49:14 <mrd> Peaker: i'm saying that deciding these kind of properties runs quickly into undecidable territory
11:49:22 <Peaker> mrd, not in every case
11:49:30 <mrd> Rice's Theorem comes down fast
11:49:43 <Peaker> mrd, in the general case, optimizing programs is an undecidable problem, lets abandon it :)
11:50:36 <mrd> #2, if the compiler behind my back starts using arrays instead of lists, then that's going to cause some wacky performance when later on i use it like it was list
11:51:22 <tromp> @let fibs = 0 : scanl (+) 1 fibs
11:51:23 <lambdabot> Defined.
11:51:28 <tromp> > fibs
11:51:29 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:52:00 <mrd> Gilly: the basic idea is to just recursively reference the data structure in the definition
11:52:13 <mrd> this seems really bad if you are coming from a strict language, but in haskell it can be ok
11:52:42 <Gilly> yea i guess i got the idea, i read some page in wiki
11:52:53 <Gilly> just gets a while to get used to i guess
11:53:20 <drFetch> @src scanl
11:53:20 <lambdabot> scanl f q ls = q : case ls of
11:53:20 <lambdabot>     []   -> []
11:53:20 <lambdabot>     x:xs -> scanl f (f q x) xs
11:53:57 <drFetch> ah
11:55:13 <Peaker> mrd, When you "later" use it like a list, will be new information fed to the same optimizer, who will fix it to be a list again
11:56:18 <Peaker> also, maybe a hybrid list of arrays can be used
11:56:41 <mrd> that's what lazy bytestring is, or was anyway
11:56:49 <Peaker> why "was"?
11:57:02 <mrd> i think they stopped using list in favor of their own datatype that is listlike
11:57:14 <mrd> that's why i said i haven't checked out the perf of the new lazy bs
11:57:18 <dcoutts_> it's essentially the same
11:57:27 <dcoutts_> just uses one fewer indirection
11:58:02 <tromp> @let fib = scanl (+) 0 (1:fib)
11:58:04 <lambdabot> Defined.
11:58:06 <mrd> the usage pattern of lazy bs does seem to be different than strict.  I've seen dons do some amazing things with lazy bs, but i've had relative failure myself.  unable to make things faster by using it.
11:58:06 <tromp> fib
11:58:09 <tromp> > fib
11:58:10 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
11:58:44 <dcoutts_> mrd: the ideal use cases are where you're doing streaming IO
11:58:57 <dcoutts_> the equivalent of C progs that to 4k block style processing
11:58:59 <mrd> indeed, a lot of these cases came from spoj contests where you get a large list of values to process
11:59:16 <tromp> so we have fix ((0 :) . scanl (+) 1)  ==  fix (scanl (+) 0 . (1:))
12:00:37 <oerjan> well the 0's should "obviously" be the same
12:00:59 <oerjan> but one of the 1s is probably 0+1 in essence
12:01:12 <Gilly> hrmpf, i guess that Map.fromList is strict then? so not so good for memoization?
12:01:40 <oerjan> > fix ((1 :) . scanl (+) 2)
12:01:40 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
12:01:57 <oerjan> > fix (scanl (+) 1 . (1:))
12:01:58 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
12:02:47 <oerjan> hypothesis: fix ((a :) . scanl f (f a b) == fix (scanl f a . (b:))
12:03:15 <oerjan> oh we can prove it
12:03:30 <oerjan> > fix ((a :) . scanl f (f a b)) :: Expr
12:03:30 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[Expr]'
12:03:34 <tromp> actually , the 1 in scanl (+) 0 . (1:) is whatever term should precede the 0
12:03:38 <oerjan> > fix ((a :) . scanl f (f a b)) :: [Expr]
12:03:38 <lambdabot>  [a,f a b,f (f a b) a,f (f (f a b) a) (f a b),f (f (f (f a b) a) (f a b)) (f ...
12:03:57 <oerjan> > fix (scanl f a . (b:)) :: [Expr]
12:03:57 <lambdabot>  [a,f a b,f (f a b) a,f (f (f a b) a) (f a b),f (f (f (f a b) a) (f a b)) (f ...
12:05:34 <oerjan> succeed you mean.  but that only works because 0 is additive identity
12:07:18 <oerjan> (or is that unit, i get those mixed up)
12:08:23 <oerjan> @where expr
12:08:23 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
12:10:19 <oerjan> > fix (scanl (op 0 "%") a . (b:)) :: [Expr]
12:10:20 <lambdabot>   Not in scope: `op'
12:10:24 <oerjan> oops
12:12:14 <oerjan> it seems the op in that link has not been included in lambdabot
12:13:23 <oerjan> hm
12:13:29 <oerjan> > fix (scanl (opl 0 "%") a . (b:)) :: [Expr]
12:13:29 <lambdabot>   Not in scope: `opl'
12:15:58 <oerjan> @where simplereflect
12:15:58 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
12:17:00 <oerjan> where is the actual code used in lambdabot?
12:17:10 <oerjan> (for simplereflect)
12:17:10 <Gilly> actually hmm... i don't think i fully understood the memoization example on fibonacci numbers after all
12:17:27 <Gilly> (referring this: http://www.haskell.org/haskellwiki/Memoization)
12:17:27 <lambdabot> Title: Memoization - HaskellWiki
12:17:54 <Gilly> why isn't the map fib [1..] called separately every time i call memoizedfib from the child fib?
12:19:19 <mrd> hmm?
12:20:05 <oerjan> because memoized_fib is not a function - there is just one copy of it
12:20:18 <oerjan> er
12:20:18 <mrd> it is a function.  "map fib [0 ..]" is computed once.
12:20:44 <oerjan> well there is just one copy of it anyhow
12:20:50 <mrd> though admittedly, i don't see why it is guaranteed to be computed once
12:21:22 <int-e> because memoized_fib is a constant. it's not actually guaranteed anywhere though, as far as I know.
12:21:35 <mrd> because it doesn't have syntactic parameters?
12:21:38 <mrd> it's a CAF
12:21:42 <int-e> right
12:21:49 <Lacrymology> excuse me, very stupid question: how can I use filter to get the numbers smaller than a given one in a list?
12:21:57 <desegnis> It's a little funny there to use (!!) when memoizing fib with a list
12:21:59 <mrd> > filter (<3) [0..5]
12:22:00 <lambdabot>  [0,1,2]
12:22:00 <gwern> this is an interesting question on -cafe. given a library which is compiled with -threaded, and requires its users to be compiled with -threaded, how can one make cabal enforce that?
12:22:01 <EvilTerran> filter (<x) xs
12:22:08 <Lacrymology> thanks
12:22:18 <Gilly> oh so if i want to use memoization like that i should avoid writing memofunc p1 p2 and use pl style instead?
12:22:22 <int-e> so in a typical haskell implementation, all uses of memoized_fib share the same, global thunk.
12:22:46 <int-e> Gilly: if you want stronger guarantees, yes.
12:22:50 <gwern> I want to say you can't write a cabalized library which enforces certain ghc-options: on importing other libraries and executables, but I'm not sure
12:23:10 <mrd> i would do it more explicitly with a list in a let-form
12:23:17 <int-e> Gilly: in reality, ghc will spot that map fib [0 ..] is constant and float it out, with the result that it gets shared anyway.
12:23:29 <Gilly> ah, ok...
12:24:08 <Gilly> can i use data.map with memoization? i mean i tried to use a similar approach as in that fibonacci example and use fromList to generate it but is fromList strict and thus avoids infinite maps?
12:24:15 <mrd> yes
12:24:30 <dcoutts_> gwern: that's correct
12:24:49 <dcoutts_> gwern: we save cc options, includes, c libs etc but not ghc options.
12:24:49 <Gilly> ok, are there workarounds? some other kind of memoization? what is this "a list in a let-form" thing you were talking about?
12:24:58 <int-e> Gilly: Data.Map will only work for finite domains. You can build suitable infinite tries though.
12:25:16 <gwern> dcoutts_: oh it is? so then what's his best course of option? a feature/bug report, a strongly worded description or what?
12:25:30 <dcoutts_> gwern: that's a tricky one
12:25:36 <mrd> one sec
12:26:04 <gwern> dcoutts_: is there any major reason ghc-options isn't saved?
12:26:08 <int-e> Gilly: or a list with increasingly larger arrays like  http://hpaste.org/41
12:26:32 <dcoutts_> gwern: yes, it's too easily abused, we used to save it but turned it off
12:26:57 <dcoutts_> gwern: people were doing things like adding extra pre-processors that all dependent packages would use, and other hideous things
12:27:01 <dcoutts_> http://hackage.haskell.org/trac/hackage/ticket/26
12:27:03 <lambdabot> Title: #26 (add Threaded as an extension?) - Hackage - Trac
12:27:13 <dcoutts_> gwern: that ticket might be relevant ^^
12:27:34 <gwern> heh
12:27:57 <gwern> dcoutts_: do you want to reply to the haskell-cafer or shall I?
12:27:59 <dcoutts_> gwern: though actually currently we do not save extensions either
12:28:04 <dcoutts_> gwern: feel free
12:28:14 <dcoutts_> gwern: basically we have no solution for that at the moment
12:28:29 <dcoutts_> gwern: it's tricky because it's not a modular thing, it's global per-process
12:29:09 <dcoutts_> gwern: what if one lib says: extensions: NoThreaded and another says extensions: Threaded, does that mean we cannot use those libs in the same program?
12:29:33 <hpaste>  mrd pasted "non-infinite fibs with Data.Map" at http://hpaste.org/6503
12:30:08 <Gilly> mmm that looks good
12:30:33 <Igloo> dcoutts_: According to the hackage DB, if you have MPTCs but not FDs then you can compile 1 package that you otherwise couldn't
12:30:35 <gwern> dcoutts_: wouldn't you default to Threaded? so far as I know, NoThreaded ruins stuff using Threaded, but Threaded does not ruin nonthreading programs, right?
12:30:36 <Gilly> int-e: yea, my particular problem happens to use (Int,Int) as parameters :)
12:30:52 <dcoutts_> Igloo: which one is that? base?
12:30:57 <dcoutts_> erm array
12:30:58 <Igloo> Not sure, hang on
12:31:20 <dcoutts_> gwern: some programs rely on using a single thread
12:31:35 <dcoutts_> are they any more broken than ones that rely on using many?
12:31:42 <taruti> dcoutts_: data Threading = Single | Threaded | AnythingIsFine
12:31:59 <dcoutts_> taruti: right, if unspecified then it's AnythingIsFine
12:32:09 <taruti> exactly
12:32:26 <gwern> dcoutts_: really? how can a program rely on running in a single thread if it isn't using any thread constructs?
12:32:30 <dcoutts_> but if we get a program that uses libs that require inconsistent values of Threading...
12:32:55 <dcoutts_> gwern: single threaded C gui libs like gtk, wx etc
12:32:57 <taruti> dcoutts_: then the program will not work. thus better to notice it at the build time.
12:33:00 <hpaste>  mrd annotated "non-infinite fibs with Data.Map" with "or array" at http://hpaste.org/6503#a1
12:33:04 <Igloo> dcoutts_: Hmm, ArrayRef claims to need FDs but not MPTCs
12:33:06 <Igloo> Doh
12:33:16 <dcoutts_> Igloo: wrong test? :-)
12:33:19 <mrd> Gilly: of course for that use you can just use an array as above
12:33:22 <Igloo> Oh, not doh. Thought I'd sent to the wrong channel
12:33:39 <Gilly> mrd: yea
12:33:42 <Igloo> dcoutts_: Hmm, ArrayRef claims to need FDs but not MPTCs. lax and syb-with-class claim to need MPTCs and not FDs
12:34:05 <Igloo> dcoutts_: Array claism to need neither
12:34:11 <dcoutts_> heh, that's wrong
12:34:44 <dcoutts_> I wonder how that compiles, perhaps it's noted in the .hs file
12:34:46 <oerjan> @seen cale
12:34:47 <lambdabot> cale is in #haskell-overflow, #ghc and #haskell. I last heard cale speak 3h 15m 51s ago.
12:35:06 <dcoutts_> Igloo: we don't enforce that all language pragmas are declared in the .cabal file
12:35:23 <int-e> Gilly: well you can curry your function and memoize both stages
12:35:32 <Igloo> dcoutts_: Yeah, but it's the best data we have that we can easily mine, sadly
12:35:39 <dcoutts_> Igloo: so to be accurate you'd have to grep the language pragmas in the source files
12:36:10 <patperry> Can anyone help me with something?  I get a stack overflow if I remove a trace message, but everything runs fine if I leave it in.
12:36:14 <dcoutts_> Igloo: I want cabal to start enforcing it btw, we'd add a separate field for extensions that are used in some modules but are not necessarily applied to every module when compiling
12:36:19 <hpaste>  patperry pasted "stack overflow" at http://hpaste.org/6504
12:36:38 * gwern likes this thread about existential types: http://reddit.com/info/6cm8f/comments/
12:37:09 <gwern> where else but on reddit would highjacking a type theorey discussion into a parody of philosophy be rewarded with upvotes?
12:37:20 <mrd> types.reddit.com, save us
12:37:22 <mm_freak_> hmmâ¦  is there any cryptographically strong RandomGen instance, or do i have to write my own?
12:37:38 <oerjan> patperry: trace "wtf???" zip ijs es ?
12:37:41 <patperry> yeah
12:37:44 <dcoutts_> Igloo: ah, ghc-options: -fglasgow-exts in array.cabal
12:37:45 <Igloo> dcoutts_: Yeah, me too
12:38:00 <oerjan> that definitely shouldn't cause a stack overflow although it may not do what you think either
12:38:10 <dcoutts_> Igloo: we should remove as many uses of -fglasgow-exts in the core libs as possible, hackage now warns on its use btw
12:38:46 <patperry> the overflow is somewhere downstream, but why would putting the trace message in prevent it?
12:38:56 <gwern> dcoutts_: I am saddened today. I got a reply from qthaskell's author, and he was quite mean to us and hackage
12:39:12 <dcoutts_> gwern: oh?
12:39:30 <gwern> 'As I mentioned in a previous e-mail, I don't feel that the Hackage site is the best place for the qtHaskell project, and if anything that is likely to be more the case as the project develops.'
12:39:32 <oerjan> patperry: and it only shows "wtf???"
12:39:58 <gwern> '...You can try and persuade me otherwise if you like, but I think you'll have to accept the fact sooner or later that not every progam written in Haskell is going to be downloaded from one website....'
12:39:59 <dcoutts_> gwern: well perhaps he doesn't like having people use his software
12:40:07 <oerjan> oh unsafePerformIO perhaps has something to do with it?
12:40:50 <patperry> oerjan: no, it shows "result is:\nwtf???\n595.0".  The trace is in the middle of a computation
12:40:56 * gwern wonders what the previous email was
12:40:59 <dcoutts_> gwern: file a bug: "cabal install qtHaskell doesn't work!?!!" :-)
12:41:07 <gwern> @seen dons
12:41:07 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 56m 44s ago.
12:41:11 <drFetch> is parsec much faster than regular expressions? eg to parse the IRCMessages in my server, should i really go and learn parsec or is something i better leave for later?
12:41:12 <Taejo> @oeis 1 1 2 4 4 2
12:41:13 <lambdabot> Row 1, where, at stage k>1, write i in row 1 and j in row 2, where i is the n...
12:41:13 <lambdabot> [3,1,2,1,3,1,3,6,2,5,1,1,7,4,6,1,3,2,1,8,5,9,1,1,2,4,4,2,10,7,12,1,1,2,2,4,5,...
12:41:26 <drFetch> is it+
12:41:29 <gwern> dcoutts_: I doubt that'll work
12:41:49 <dcoutts_> drFetch: learning any parser combinator lib is time well spent
12:41:56 <patperry> oerjan: maybe, but I don't see why it would be related to a stack overflow
12:42:12 <byorgey> drFetch: don't know whether it's faster, but it would definitely be much simpler.
12:42:14 <oerjan> patperry: i don't understand that at all
12:42:20 <byorgey> drFetch: simpler both to write and to modify.
12:42:21 <gwern> @ask dons when you asked the qthaskell author David Harley <dth.tss@gmail.com> back on 3 Jan whether he was gonna hackage it, did he reply to you offlist?
12:42:21 <gnuvince> :t oeis
12:42:21 <lambdabot> Consider it noted.
12:42:22 <lambdabot> Not in scope: `oeis'
12:42:23 <drFetch> dcoutts_: but is it going to make a diffrence? i mean i'm already pretty overwhelmed
12:43:06 <dcoutts_> drFetch: it depends a great deal on the parsing problem at hand, simple parsers can be faster than complex regexps
12:43:06 <patperry> oerjan: thanks for looking.  I'll bash my head against the wall some more and see if I get anywhere
12:43:08 <oerjan> patperry: hm wait one possibility occurred to me
12:43:22 <oerjan> it could be interfering with some optimization
12:43:24 <fasta> drFetch: Parsec will probably be slower in execution time.
12:43:45 <fasta> drFetch: otherwise, Parsec is what most Haskell users want.
12:44:11 <drFetch> dcoutts_: the pattern is something like (:<prefix>)? <command> <parameter>* (:<parameter>?)?
12:44:36 <oerjan> patperry: zip is probably heavily optimized but you have put a trace on it (btw you probably meant it to be trace "wtf???" (zip ijs es) ) so perhaps those optimizations are not triggered
12:44:42 <drFetch> i'm going to go with regular expressions for now, i think
12:44:56 <patperry> oerjan: that's kind of what I was thinking, too, but it's weird that the trace message helps
12:45:23 <patperry> oerjan: originally, I had trace messages on all of the expressions.  taking out the other ones was ok, but not the one on "ijes"
12:45:26 <oerjan> patperry: the trace probably prevents the usual zip optimizations from happening
12:45:38 <oerjan> (well i guess)
12:45:45 <mm_freak_> seems like i have to roll my own CSPRNG =/
12:46:32 <oerjan> patperry: without it, ijep' is probably deforestated
12:46:43 <Lacrymology> is there a quick way of making a random numbers list of size n?
12:46:56 <Lacrymology> the random generators are killing me
12:47:29 <dons> gwern: i know, i've no idea why he doesn't put it on hackage. i asked about it when it was released
12:47:29 <lambdabot> dons: You have 7 new messages. '/msg lambdabot @messages' to read them.
12:47:47 <dons> basically, the strategy of having it on sourceforge means none of the tools know about it, and we forget all the time that it exists
12:47:55 <gwern> dons: he doesn't really give any reasons. I'm trying to figure out the diplomatic way to reply
12:48:08 <gwern> @where qthaskell
12:48:08 <dons> maybe it doesn't need a reply?
12:48:08 <lambdabot> http://qthaskell.sourceforge.net/
12:48:15 <patperry> oerjan: thanks for the help
12:48:24 <fasta> Why should $PERSON put something on Hackage?
12:48:34 <stevan> is there a way to do this directly in the case, without having to bind ask? flip runReader 0 $ ask >>= \s -> case s of _ -> return ()
12:48:40 <fasta> If it's open-source and you have an interest in it, do it?
12:48:59 <mrd> stevan: why not just return ()
12:49:05 <fasta> Or extend Hackage, so that it's not an issue to begin with.
12:49:09 <gwern> fasta: I've been told uploading against the author/maintainer's desires is rude...
12:49:17 <mrd> > flip runReader 0 $ return ()
12:49:18 <lambdabot>  ()
12:49:19 <gwern> silly person, I know
12:49:21 <oerjan> patperry: oh or maybe it is the zip that doesn't get...
12:49:22 <gwern> but so I've been told
12:49:26 <stevan> mrd: this is just an example
12:49:35 <fasta> gwern: I didn't know that, but it sounds silly.
12:49:37 <mrd> oh you want to case it? you gotta do that
12:49:50 <mrd> the other way is to write a helper function
12:49:54 <fasta> gwern: unless he has a trademark on it.
12:50:17 <mrd> unless there is only 1 case, in which case (blah!) you can do the pattern match in the lambda
12:50:17 <fasta> gwern: in which case someone should rename it (see Iceweasel/Firefox).
12:50:29 <mrd> \ (Foo x) -> ...
12:50:30 <stevan> a caseM would be nice, no?
12:50:40 <nibro> gwern, fasta: it's because of maintenance issues (gwern knows that :p)
12:50:43 <gwern> the problem is, I really have no interest in a hostile fork
12:50:57 <nibro> gwern: though I certainly didn't mind it for my projects
12:51:18 <gwern> I don't use many if any qt-based programs, I don't have experience with big FFI bindings, and graphics libraries don't interest me much - I have other stuff to do
12:51:32 <mrd> stevan: or fully capable pattern matching lambdas like in SML
12:51:43 <fasta> gwern: right, so there is no reason why you should.
12:51:48 <gwern> nibro: see, this is one of the problems, people keep saying 'oh I remember when you did that for my project' and I have no idea who you are
12:51:55 <dons> gwern: why need it be a fork?
12:52:01 <fasta> gwern: you did your best to help. End of story?
12:52:04 <dons> is it cabalised? could we take the existing tarball?
12:52:45 <gwern> dons: it needs a bunch of metadata just to make it onto hackage, and I'm sure there are other problems
12:52:54 <Peaker> "cabal install xmonad" -> Where can I now find the sources of xmonad?
12:52:56 <gwern> the best I can really say for it is that at least it compiles from tarball
12:53:09 <gwern> Peaker: somewhere in .cabal?
12:53:18 <nibro> gwern: me == hsp and haskell-src-exts
12:53:21 <dons> Peaker: in ~/.cabal/
12:53:32 <Peaker> thanks
12:53:46 <dons> gwern: shrug. if nothing happens, in a years time we can fork.
12:53:51 <gwern> nibro: ah. how is the new stuff going?
12:54:01 <dons> i just can't see how he'll get development support unless it functions as a community project
12:54:10 <gwern> (in a years time, it may no longer compile)
12:54:13 <dons> gwern: but it is cabalised?
12:54:14 <hpaste>  int-e pasted "memoization with an infinite trie" at http://hpaste.org/6505
12:54:16 <nibro> gwern: it's going quite well, thans
12:54:19 <nibro> *thanks
12:55:05 <nibro> gwern: we're hoping to release it all some time this weekend, just in time for the GSoC proposals to be handed in...
12:55:06 <int-e> Gilly: that paste demonstrates the infinite trie idea I mentioned.
12:55:07 <mrd> is that a cotrie
12:55:07 <gwern> dons: it is cabalized
12:55:25 <gwern> (as I said, not terribly well as fae as metadata goes)
12:55:55 <gwern> nibro: great. you'll be reusing the cabal package name from the old hsps?
12:55:59 <gwern> *far as
12:56:17 <nibro> gwern: certainly, I'm very grateful for the work you did there
12:56:50 <pejo> nibro, is haskell-src-exts related to your research?
12:57:13 <nibro> gwern: though we'll have branched out a lot, so the project will consist of a lot more packages now than before
12:57:24 <nibro> pejo: well, in some ways, though not directly
12:57:59 <gwern> nibro: that's fine; I was just a little concerned that if a user goes to hackage they might see multiple 'hsp's and it'd be unclear what's the latest
12:57:59 <nibro> pejo: I need it to support the work on hsp, since I need a preprocessor for it that is capable of reading extensions
12:58:12 <gwern> ie, the old one might have 'name: hsp' and the new one 'name: HSP' or something
12:58:32 <nibro> gwern: no worries there, we'll release it as hsp... ah, a matter of case, no we'll keep the lowercase
12:58:37 <int-e> Gilly: although for simple recurrences like the fibonacci sequence, the list of arrays idea is better.
13:00:37 <gwern> nibro: just make sure a package overwrites the 'old' one at http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsp-0.2
13:00:39 <lambdabot> http://tinyurl.com/2wv6og
13:00:45 <gwern> and http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hspr-sh-0.3 too I suppose
13:00:46 <lambdabot> http://tinyurl.com/2mghnv
13:01:28 <nibro> gwern: hspr will be discontinued
13:01:39 <Gilly> int-e: hm, interesting
13:01:57 <nibro> gwern: should I upload a dummy package to override the old one, just noting that it is no longer valid?
13:02:00 <Lacrymology> can I get help with this, please?
13:02:02 <Lacrymology> System.Random> :l tests.hs
13:02:02 <Lacrymology> ERROR "tests.hs":23 - Instance of RandomGen (IO StdGen) required for definition of makeList
13:02:25 <Lacrymology> makeList is supposed to make a list of n random numbers
13:02:26 <nibro> Lacrymology: you're likely trying to use an IO expression in pure code :)
13:02:34 <Lacrymology> nibro: true dat
13:02:39 <Lacrymology> nibro: so how do I make my list
13:02:52 <gwern> nibro: that would be one solution, certainly - you say hspr is going away in its entirety, there's no intermediate or updated useful package?
13:05:39 <nibro> Lacrymology: do { gen <- getStdGen; xs <- randoms gen; return (take n xs) }
13:06:21 <Lacrymology> nibro: will that work in hugs?
13:06:30 <oerjan> nibro: newStdGen, unless you want it to return the same result each time
13:06:33 <nibro> gwern: no, there's nothing there that we want to keep supporting in any way
13:06:54 <nibro> oerjan: right you are
13:07:11 <nibro> Lacrymology: I don't see why it shouldn't
13:07:52 <Lacrymology> nibro: well, it says type [b] does not match IO a in term randoms gen
13:09:21 <oerjan> randoms is pure so it should be let xs = randoms gen;
13:09:31 <LordBr4in> hey, i want some opinions.. Say i'm writing an installer program which detects a lot of settings, and asks some from the user, validates the user input, and then performs the install.   Of the top of my head i'm thinking of having each setting have a string identifier and store them in a  Map which has an existential envelope for the associated value.  Does this sound like a reasonable way to go?
13:09:39 <LordBr4in>  There is of course going to be lots of conditional, if this setting & that setting, then do this action. Type stuff.. But i'd like to put off as much of the action which alters the system till the end.
13:10:19 <kpreid> LordBr4in: I happen to be working on an installer (not in Haskell) and it works very much like that
13:10:47 <LordBr4in> well, i am specifically asking if the Data.Map is a good choice here?
13:10:48 <kpreid> if an item is missing from the configuration map then that means "don't install this component"
13:11:00 <kpreid> can't think of why no
13:11:01 <kpreid> t
13:11:19 <Lacrymology> oerjan: now it loaded into hugs ok, but it didn't work
13:11:23 <oerjan> Lacrymology: this can be simplified to fmap (take n . randoms) newStdGen
13:11:32 <Lacrymology> it says unresolved overloaded
13:11:51 <fasta> LordBr4in: What's the application of the existential envelope?
13:11:55 <Lacrymology> http://pastebin.com/d6c4fb7a1
13:11:57 <nibro> oerjan: I don't think a new Haskell user would see that as a simplification :)
13:12:10 <Lacrymology> nibro: I can see it as that
13:12:14 <oerjan> Lacrymology: ah yes hugs has a small bug - it doesn't recognize Random has a defaultable class. add a type annotation
13:12:16 <Lacrymology> except for the . it's ok
13:12:22 <desegnis> Lacrymology: Did you specify what type of values you want to be generated?
13:12:23 <oerjan> *as a
13:12:24 <LordBr4in> fasta, well really only to get it polymorphic in the value... so if there is already something like a heterogenous map... that would be more appropriate
13:12:27 <unenough> what do 'par' and 'seq' do?
13:12:38 <Lacrymology> desegnis: oh, no I didn't
13:13:41 <Lacrymology> how do I do that, exactly?
13:13:43 <LordBr4in> in particular, i would like a map which has some values which are strings and some which are numeric
13:13:48 <esteth> unenough: The expression (x `par` y)  sparks the evaluation of x  (to weak head normal form) and returns y. Sparks are queued for execution in FIFO order, but are not executed immediately.
13:14:04 <desegnis> unenough: par x y is a hint for the compiler that x should be computed in parallel with y. The result of par x y is y.
13:14:06 <fasta> LordBr4in: Why not have data Value = StringValue String | IntValue Int?
13:14:14 <oerjan> Lacrymology: add :: [Int] , say, to the end
13:14:38 <esteth> unenough: That was copy/pasted from: http://www.haskell.org/ghc/docs/latest/html/users_guide/lang-parallel.html
13:14:39 <Lacrymology> oerjan: to the function definition?
13:14:56 <oerjan> Lacrymology: no just when you use it - this is only a problem in the interpreter
13:15:00 <unenough> thanks
13:15:19 <oerjan> unless you actually want to restrict it to one type
13:15:30 <oerjan> Lacrymology: oh probably need :: IO [Int]
13:15:49 <patperry> oerjan: uh, problem solved: http://hpaste.org/6504
13:16:04 <fasta> LordBr4in: How would the compiler know that when you put a String, an Int and whatever you want into a Map that when you get it out, the types work out?
13:16:23 <LordBr4in> fasta, well, i'm not really sure all the types that might be convenient to store in there
13:16:25 <fasta> LordBr4in: you can put SYB in it, but that's a different approach.
13:16:40 <Lacrymology> oerjan: ok, now it runs ok, but it doesn't return anything...
13:17:09 <oerjan> Lacrymology: oh right the result of IO actions are not printed automatically
13:17:18 <oerjan> Lacrymology: what's the name of your function?
13:17:26 <Lacrymology> makeList
13:17:49 <oerjan> print =<< (makeList :: IO [Int])
13:17:54 <Lacrymology> oerjan: but as long as it's returning, and I can use it to try stuff up, it's good enough
13:18:13 <fasta> LordBr4in: are you sure you know what you want?
13:18:14 <oerjan> er forgot the argument
13:18:24 <LordBr4in> if i was sure i knew what i wanted i wouldnt be asking for opinions
13:18:25 <oerjan> print =<< (makeList 10 :: IO [Int])
13:18:28 <kpreid> LordBr4in: I imagine an existential where you have the operations defaultValue :: IO a and askUserForValue :: IO x
13:18:40 <kpreid> er, inconsistent type variable naming there...
13:19:34 <Lacrymology> oerjan: any way to go from IO [a] to just [a] so's I can use this list in my functions?
13:19:43 <ttt--> hi, which package do i need for "containers-any" ?
13:20:03 <fasta> LordBr4in: existential solutions and constructive solutions are two different things. Compare "I want a pony" with "getting a pony". :)
13:20:04 <oerjan> Lacrymology: sure, use l <- makeList n  in a do expression, then l becomes just a list
13:20:16 <desegnis> ttt--: The package is called containers, indeed.
13:20:41 <desegnis> ttt--: It should come with ghc.
13:21:01 <LordBr4in> getting a pony would be analogous to the existential you mean?
13:21:17 <fasta> LordBr4in: no, to the constructive solution.
13:21:32 <LordBr4in> oh i see from the code's point of view
13:21:58 <LordBr4in> like i'm going to treat it like it's a pony no matter what, vs i know it is a pony
13:22:18 <ttt--> desegnis: im trying to build lamdabot, and i get "Setup.hs: cannot satisfy dependency containers-any
13:22:18 <ttt--> "
13:22:40 <desegnis> ttt--: Old ghc, perhaps?
13:22:59 <ttt--> 6.6.1
13:23:03 <LordBr4in> i do not have much experience with existentials... would the type be checked dynamically when the existential envelop is opened?
13:23:24 <fasta> LordBr4in: the existential envelope cannot be opened.
13:23:40 <LordBr4in> what do you mean?
13:23:53 <LordBr4in> i can't treat it like a pony?
13:24:12 <desegnis> ttt--: IIRC the containers package came with the base split somewhere in 6.8.*
13:24:26 <fasta> LordBr4in: yes, you can do that, but you cannot do operations that assume more than in the "envelope".
13:24:43 <fasta> LordBr4in: you can easily have a list of Ponyable.
13:24:56 <desegnis> ttt--: You could just try and remove the dependency from the .cabal file, but it might get tricky :)
13:25:08 <fasta> LordBr4in: or a Map or whatever.
13:25:23 <skorpan> how come i cant do: f = (not . g) ?
13:25:25 <LordBr4in> oh i see yes
13:25:45 <oerjan> skorpan: monomorphism restriction perhaps?
13:25:46 <ttt--> 6.6.1 is the latest ubuntu package available :(
13:25:57 <EvilTerran> if the envelope says "beast" on the outside, all you can do with it is stuff you can do with any beast
13:26:03 <skorpan> oerjan: so the only way to do it is use parameter names?
13:26:03 <EvilTerran> so, eat, chase, but not ride
13:26:13 <oerjan> skorpan: you could also add a type annotation
13:26:14 <LordBr4in> so if i try to do what i'm saying i would have to have a typeclass which gaurantees all the operations i would ever want to do on what's inside the envelope?
13:26:18 <EvilTerran> if it says "mount", then you can't eat it, but you can still chase it or ride it
13:26:27 <EvilTerran> if it say both, you can do all of the above
13:26:29 <skorpan> oerjan: i have that
13:26:38 <EvilTerran> "beast" and "mount" being typeclasses here
13:26:38 <oerjan> skorpan: hm then it should work.  paste?
13:26:53 <fasta> LordBr4in: yes, but initially having different data types also works.
13:26:56 <mauke> what do you mean by "i cant do"?
13:27:08 <skorpan> oerjan: never mind :P
13:27:11 <skorpan> thanks though
13:27:40 <oerjan> skorpan: note the type annotation (declaration) must be free-standing
13:27:43 <desegnis> ttt--, the easy way: Wait for Hardy
13:27:48 <skorpan> oerjan: a -> Bool?
13:29:07 <oerjan> skorpan: well with a whatever f/g actually takes
13:29:47 <oerjan> > let f :: Int -> Bool; f = not . even in f 3
13:29:48 <lambdabot>  True
13:30:31 <skorpan> that's what i had (though a bit more complex)
13:30:38 <skorpan> never mind, it's not that big of a deal
13:30:52 <oerjan> skorpan: yeah it would have to be more complex if the monomorphism restriction is triggered
13:31:16 <LordBr4in> hmmmm fasta, does anyone get dynamic type checking in haskell?  I remember studying an old mailing list post with stanamically ballanced binary trees..  which was pretty neat...   i thought the trick there was getting static when its possible and dynamic when it's not...
13:31:25 <oerjan> skorpan: in any case adding an argument should also work
13:31:52 <fasta> LordBr4in: that trick depends on encoding invariants in the type system.
13:32:07 <fasta> LordBr4in: dynamic typing can be done with various other modules that I haven't used.
13:32:29 <LordBr4in> http://okmij.org/ftp/Haskell/stanamically-balanced-trees.lhs
13:32:29 <LordBr4in> there it is by the way
13:32:29 <fasta> LordBr4in: Data.Dynamic for example.
13:32:58 <LordBr4in> ah
13:33:35 <fasta> LordBr4in: there's no dynamic typing, AFAIK, in the link you give.
13:34:02 <LordBr4in> ok
13:34:29 <Peaker> why can't I import modules in ghci?
13:34:29 <LordBr4in> it's been a long time since i studied it...
13:34:58 <nibro_> Peaker: use :m +
13:35:09 <nibro_> as in :m + Data.Map or whatever
13:35:17 <fasta> Peaker: you can in the same way as normal
13:35:21 <fasta> Peaker: import Foobar
13:35:33 <mauke> whoa
13:35:36 <mauke> when did that happen?
13:35:44 <fasta> mauke: not that long ago ^^
13:35:50 <Peaker> fasta, that does not work
13:35:54 <fasta> mauke: 6.8.2 has it
13:35:57 <mauke> yeah
13:35:59 <fasta> Peaker: yes, it does.
13:36:05 <LordBr4in> so if i wanted to keep dynamic typing on the values, i could do a Map with a value type of Dynamic
13:36:16 <Peaker> fasta, not in ghci 6.6.1
13:36:22 <Peaker> nibro, thanks
13:36:25 <fasta> Peaker: then don't use 6.6.1
13:36:30 <Peaker> nibro, so I can only use 1 module at a time? :)
13:36:31 <fasta> Peaker: :m + Foobar
13:36:36 <fasta> Peaker: that works in 6.6.1
13:36:47 <fasta> Peaker: + means "add".
13:36:50 <Peaker> fasta, ok, thanks.  Ubuntu doesn't have more advanced ones
13:37:03 <fasta> Peaker: that was said a few minutes ago, yes.
13:37:21 <nibro> fasta: cool, thanks for that, I had no idea it worked. :-)
13:37:23 <LordBr4in> hmmm i dont see a way to set up a handler or anything for when a dynamic typecheck fails
13:37:31 <fasta> LordBr4in: spend 3 years in Haskell before you start with Dynamic.
13:37:32 <desegnis> Peaker: It's a timing issue really. ghc 6.8 is just still rather new
13:37:38 <mm_freak_> there should be some cryptographic primitives somewhere in the standard libs
13:37:43 <mm_freak_> at least hash functions and stuff
13:37:46 <fasta> LordBr4in: that's my advice, others might have other.
13:37:48 <nibro> Peaker: no, you can use many modules, that's what the + does
13:37:52 <Peaker> desegnis, hopefully it goes into hardy with a working cabal
13:38:04 <Peaker> desegnis, waiting for Ubuntu i* for cabal is a long time
13:38:06 <LordBr4in> why is that fasta?
13:38:06 <nibro> Peaker: if you say :m Data.Map you get only Data.Map
13:38:14 <Peaker> nibro, thanks
13:38:22 <fasta> LordBr4in: because they are not very popular and I doubt you need it.
13:38:38 <mm_freak_> most distributions don't support haskell very well =/
13:38:45 <oerjan> @hoogle Dynamic -> Maybe a
13:38:45 <lambdabot> Data.Dynamic.fromDynamic :: Typeable a => Dynamic -> Maybe a
13:39:08 <fasta> It's not that complicated, but it's bad style most of the time.
13:39:22 <Peaker> @src :=
13:39:22 <lambdabot> Source not found. :(
13:39:26 <Peaker> What's the := operator http://www.haskell.org/haskellwiki/Memoization refers to?
13:39:28 <lambdabot> Title: Memoization - HaskellWiki
13:39:28 <oerjan> LordBr4in: it's wrapped in a Maybe so you get Nothing if it doesn't match
13:39:30 <fasta> You can write PHP in Haskell. It's just not a smart thing to do.
13:39:45 <mauke> s/ in Haskell//
13:39:55 <LordBr4in> oh i see oerjan
13:40:10 <fasta> mauke: yeah, that's easier :)
13:40:51 <ttt--> desegnis: i installed a  6.8.2 but now im missing arrows, zlib,.. how can i get those?
13:41:32 <oerjan> Peaker: some kind of meta-notation i figure
13:41:52 <oerjan> same for =~=  i guess
13:42:10 <desegnis> ttt--: Via cabal-install, or alternatively, from Hackage
13:42:18 <ttt--> thanks
13:45:45 <oerjan> Peaker: i think =~= is a kind of equivalence, := may be that or more likely a kind of reduction step
13:45:47 <Peaker> why does: " memoized_fib = ((map fib' [0 ..]) !!)  where fib' <pattern matches> " memoize while a normal <pattern matches> not memoize?
13:46:13 <Peaker> oerjan, ok, thanks. I skipped to the example code.. :)
13:46:23 <gwern> := is an assignment operation in some imperative langs, no?
13:47:12 <Peaker> why does (map pattern_matcher [0 ..] !!)  memoize? That's weird
13:47:13 <oerjan> gwern: Pascal, Ocaml at least but i don't think that fits here
13:47:32 <mauke> meh, ocaml's := is just writeIORef :-)
13:48:07 <oerjan> mauke: so?  writeIORef is a perfectly cromulent assignment.
13:48:14 <ttt--> in smalltalk too
13:48:14 <mauke> Peaker: does fib' call memoized_fib?
13:48:31 <Peaker> mauke, yeah. Ohh! I get it :-)
13:48:40 <mauke> so it's more like ":= is an assignment operation in some imperative libraries"
13:48:49 <Peaker> mauke, thanks
13:49:00 <mauke> heh, you're welcome
13:49:05 <oerjan> Peaker: definitions without function arguments are usually cached.  in fact the monomorphism restriction exists mainly to ensure this is the case.
13:50:54 <Peaker> oerjan, what's the monomorphism restriction?
13:51:11 <mauke> dreaded!
13:52:16 <oerjan> @where mr
13:52:17 <lambdabot> I know nothing about mr.
13:52:43 <oerjan> http://www.haskell.org/haskellwiki/Monomorphism_restriction
13:52:44 <lambdabot> Title: Monomorphism restriction - HaskellWiki
13:52:59 <oerjan> "The monomorphism restriction is probably the most annoying and controversial feature of Haskell's type system. All seem to agree that it is evil, but whether or not it is considered a necessary evil depends on who you ask."
13:55:30 <orzo> ok
13:55:34 <olsner> who considers it a necessary evil?
13:56:00 <orzo> I need help convincing the boss on haskell.  He's woried haskell programmers are in short supply
13:56:20 <LordBr4in> fasta, is there something like a data This = IntVal int | stringVal string | Word8Val Word8 | lots and lots of commonly used types   already built somewhere?
13:56:26 <Peaker> orzo, maybe he's right :)
13:56:31 <orzo> well
13:56:41 <orzo> i dont want to say that
13:57:15 <orzo> i was doing scheme code, and i told  him scheme is really easy to learn
13:57:25 <orzo> but then i replaced it with haskell that runs 4 times faster
13:57:28 <user317> orzo, the best way to use haskell it work, is use it where it works best, like writing tools, compilers, etc...  those kinds of jobs are done better by 1 person anyways, and you can show him that you can do them faster and with less bugs
13:57:45 <oerjan> LordBr4in: seems nearly equivalent to Dynamic to me
13:58:14 <orzo> well maybe i can pretend haskell is really easy to learn
13:58:21 <orzo> heh
13:58:33 <oerjan> orzo: i think that may be a felony in some places ;)
13:58:37 <orzo> heh
13:58:39 <LordBr4in> oerjan, well, i dont know it is equivalent, because the data This approach would be statically checked...
13:58:45 <roconnor> orzo: I'll work for your boss, but I'm really expensive.
13:58:51 <mauke> "read this, it's a totally Gentle Introduction"
13:58:55 <user317> orzo, it relative to the problem that you are trying to solve, learning yacc and bison and C is just as hard as learning haskell when you are trying to build a compiler
13:59:33 <oerjan> LordBr4in: if the list of types is long enough you end up leaving some out of your matches anyhow
13:59:47 <orzo> the task involves extracting information from lots of different sources using different protocols
13:59:49 <LordBr4in> hmmm
14:00:05 <LordBr4in> yeah
14:00:14 <LordBr4in> Dynamic is probably the way to go
14:00:28 <orzo> plenty of quick and dirty parsing
14:00:32 <oerjan> LordBr4in: if the list of types doesn't correspond to what you actually _use_, then This is not really more statically checked than Dynamic in reality.
14:00:50 <LordBr4in> yeah
14:01:04 <visof> can anyone enter #monad
14:01:06 <oerjan> good statical checking requires making the types close to the problem being solved
14:01:07 <visof> ?
14:01:09 <Peaker> roconnor, how expensive are you?
14:01:35 <Peaker> visof, invite only
14:01:37 <gwern> Peaker: that sounds so dirty
14:01:47 <orzo> man
14:01:59 <visof> peaker why this?
14:02:08 <orzo> he's all concerndd about maintainablity, but the code the compny works with is an undocumented nightmare of c++
14:02:09 <LordBr4in> it would be nice to have something that can be almost any type in there.  I can live with dynamic type checking.
14:02:13 <visof> no way to enter this channel ?
14:02:17 <tromp> if you have to ask, then you cant afford him
14:02:21 <gwern> 'roconnor is one of our premier 4-diamond programmers. His rates run 4k an hour for VIP members only...'
14:02:37 <roconnor> gwern: wow, that's awsome
14:02:57 <roconnor> gwern: I was thinking $200 an hour, obviously I was selling myself short.
14:03:01 <LordBr4in> orzo, i guess you have to show haskell is easy to maintain
14:03:24 <orzo>  "easy to maintain" means easy to get new coders to work on it
14:03:24 <mauke> they're doing it wrong
14:03:26 <orzo> heh
14:03:35 <gwern> roconnor: I'm parodying the recent Spitzer stuff; I believe the ho involved was 4k/hr (or was it per night?)
14:03:40 <mauke> #monad should be easy to join. #comonad should be invite-only
14:04:08 <kpreid> ha
14:04:11 <opqdonut> :D
14:04:18 <opqdonut> #monad should be hard to get out of right?
14:04:21 <opqdonut> :P
14:04:26 <mauke> exactly
14:04:31 <roconnor> visof: once you enter #monad you can not leaver.
14:04:35 <roconnor> leave
14:04:37 <oerjan> @remember mauke #monad should be easy to join. #comonad should be invite-only <opqdonut> #monad should be hard to get out of right?
14:04:37 <lambdabot> Okay.
14:05:24 <roconnor> gwern: I was going to say that I'm better than a prostitue, but that is perhaps not the case.
14:05:34 <gwern> opqdonut: no, you're thinking of #hotel-california, or #io-monad
14:05:51 <gwern> roconnor: the economy values you at less...
14:06:29 <roconnor> gwern: possibly with good reason.
14:06:34 <orzo> if haskell is only good compared to using flex and bison, then its worthless.
14:06:34 <opqdonut> gwern: :)
14:09:52 <xif> beyond the "logic" book and the one about discrete math, are there good books about CS - say, algorithms - using Haskell as their demonstration languages?
14:09:55 <xif> *language
14:10:48 <opqdonut> not really
14:10:55 <opqdonut> tho i recommend sicp
14:10:57 <dons> "purely functional data structures", sort of.
14:11:00 <opqdonut> which is the same but in scheme
14:11:25 <tromp> which is the logic book?
14:11:38 <tromp> The Haskell Road to Logic, Maths and Programming?
14:12:05 <fxr`> it's a great book
14:13:36 <tromp> yes, it is
14:13:50 <tromp> from my ex colleagues
14:19:06 <gwern> @src io
14:19:06 <lambdabot> Source not found. It can only be attributed to human error.
14:19:20 <oerjan> @src IO
14:19:20 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
14:20:01 <Peaker> What's #?
14:20:06 <gwern> no, I need the function 'io' not any type
14:20:07 <gwern> I'm sure it's somewhere in Control. but where?
14:20:26 <thoughtpolice> Peaker: it means 'unboxed'
14:20:39 <gwern> ah, it's an alias for liftIO
14:20:40 <mauke> gwern: where did you see it?
14:20:40 <oerjan> gwern: er what does it do?
14:20:43 <gwern> @hoogle liftIO
14:20:43 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
14:20:44 <oerjan> ah
14:20:46 <mauke> huhu, xmonad
14:20:56 <oerjan> @src MonadIO
14:20:56 <lambdabot> Source not found. stty: unknown mode: doofus
14:21:05 <gwern> mauke: yup. I'm borrowing the xmonad recompile system for autoproc
14:21:17 <mauke> class MonadIO m where liftIO :: m a -> IO a
14:21:22 <gwern> it's kind of messy, since xmonad hasn't really factored out all the xmonad specific bits
14:21:49 <oerjan> mauke: i think you mean CoMonadIO ;)
14:21:56 <mauke> :(
14:22:10 <mauke> my emperor, I've failed you
14:22:23 <oerjan> and would that be dropIO, i wonder
14:23:17 * gwern watches mauke explode
14:23:27 <idnar> heh
14:23:42 <oerjan> ah just a brain explosion, nothing unusual
14:24:20 <gwern> @quote brain
14:24:20 <lambdabot> Korollary says: my brain is fried. I cant read any more STM papers
14:24:29 <oerjan> @brain
14:24:29 <lambdabot> I think so, Brain, but I don't think Kaye Ballard's in the union.
14:25:14 <oerjan> @brain quote
14:25:14 <lambdabot> I think so, Brain! How much deeper would the ocean be if there weren't sponges down there?
14:25:26 <oerjan> deep questions
14:26:01 <xif> tromp: yeah
14:26:03 <xif> that one
14:26:16 <xif> "The Haskell Road to Logic, Maths and Programming" is next on my reading list
14:26:24 <gwern> @hoogle forkProcess
14:26:24 <lambdabot> No matches found
14:26:33 <xif> too bad there isn't one about algorithms.
14:27:23 <Peaker> how do I "do" this syntax: whenM conf (code >> whileM cond code)  ?  can I do the whole thing, or do I have to do just the paren part?
14:27:42 <quicksilver> that looks fine
14:27:49 <quicksilver> why would you want to "do" it?
14:27:55 <Peaker> quicksilver, educational
14:27:59 <quicksilver> ah, well
14:28:00 <roconnor> xif: what about dons's suggestion of "purely functional data structures"?
14:28:09 <quicksilver> the outer part has no >> or >>=
14:28:12 <quicksilver> so nothing to "do"
14:28:13 <oerjan> Peaker: do notation?  just the paren part
14:28:17 <quicksilver> the inner part has a >>
14:28:20 <oerjan> @redo whenM conf (code >> whileM cond code)
14:28:21 <lambdabot> whenM conf (do { code; whileM cond code})
14:28:21 <quicksilver> so you could "do" that.
14:28:25 <Peaker> quicksilver, I see, thanks
14:28:34 <quicksilver> you could useless do the outer bit too
14:28:41 <johnnn> FREE SEX! NEW PICS EVERY DAY! FOR FREE!! http://makemoneyfor.freehostia.com/4images_gallery/
14:28:42 <quicksilver> do {  whenM conf (do { code; whileM cond code}) }
14:28:42 <lambdabot> Title: BEST WALLPAPERS
14:28:48 --- mode: ChanServ set +o quicksilver
14:28:53 --- mode: quicksilver set +b *!*=PJIRCWeb@86.105.61.*
14:28:53 --- kick: johnnn was kicked by quicksilver (quicksilver)
14:29:21 <quicksilver> Peaker: do x ==== x
14:29:32 <quicksilver> (as long as x has monadic type, arguablly)
14:29:35 <Peaker> quicksilver, if I useless do the outer-part, I'd need 2 do's, right?
14:29:37 <quicksilver> so you can do all day if you like.
14:29:44 <mauke> Peaker: yes
14:29:44 <solrize> is there a way to tell how much memory a haskell program is using?
14:29:56 <oerjan> > do (do (do (do "be do")))
14:29:57 <lambdabot>  "be do"
14:30:01 <quicksilver> oerjan++
14:30:09 <solrize> and also to tell the gc how often to run?
14:30:11 <mauke> yes, read /proc/self/statm
14:30:25 <quicksilver> solrize: have a look at GHC's commandline options
14:30:29 <quicksilver> solrize: and especially the RTS options
14:30:35 <xif> roconnor: I'll check it out
14:30:37 <quicksilver> there are quite a few things you can tune / inspect
14:30:41 <solrize> thanks
14:30:43 <dons> we seem to have getting more bots than usual
14:30:56 <oerjan> @users
14:30:56 <lambdabot> Maximum users seen in #haskell: 473, currently: 466 (98.5%), active: 25 (5.4%)
14:30:58 * xif fears the quadruple equal-sign
14:30:59 <lispy> solrize: you have several options with ghc.  Even if you're not using profiling there is some info available about GC
14:31:19 <solrize> i think /proc/self/statm will tell me the total size of the process but i basically want to know the amount of free memory available after a gc
14:31:39 <solrize> or the amount of live data in the program, rather
14:31:43 <gwern> @hoogle (====)
14:31:43 <lambdabot> Did you mean: (====)
14:31:44 <lambdabot> Prelude.undefined :: a
14:31:44 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
14:31:45 <solrize> statm counts everything together
14:31:48 <lispy> solrize: everything you want should be available via the RTS options
14:31:54 <solrize> lispy thanks i'll look at that
14:32:05 <lispy> I wrote a program to run darcs and track this sort of thing
14:32:14 <lispy> but, really you could swap in things besides darcs
14:32:15 <solrize> darcs?
14:32:35 <lispy> solrize: it's a version control system written in haskell, very popular with the haskell community
14:32:50 <gwern> lispy: ah, a hook to darcs trackdown mebbe?
14:32:51 <solrize> lispy i know what darcs is, i just don't see what it has to do with this
14:33:32 <lispy> solrize: this may be somewhat helpful to you, even though it's scala not haskell: http://projects.codersbase.com/repos/darcssim/
14:33:33 <lambdabot> Title: Index of /repos/darcssim
14:33:43 <lispy> gwern: sorry?
14:33:56 --- mode: quicksilver set -o quicksilver
14:34:03 <lispy> solrize: I was using the rts to track memory usage
14:34:10 <lispy> solrize: to create graphs with gnu plot
14:34:20 <solrize> basically i want to sort a big disk file by doing the following: 1) read in records until the computer's ram is almost full; 2) sort those records in memory and write the sorted list out to disk, then release them from memory; 3) go to step 1 and repeat until all records have been dumped into sorted chunks on disk; 4) run a disk merge algorithm on the sorted chunks
14:34:39 <solrize> so the part i'm asking about is how to tell how much ram the process is using at a given moment
14:34:40 <quicksilver> I believe you'll find there is no point.
14:34:45 <lispy> solrize: oh you want access to the GC information from inside the running program?
14:34:48 <solrize> yes
14:34:51 <quicksilver> reading in a "sensible amount" like 10M
14:34:57 <quicksilver> will have the same performance as reading it all in.
14:35:02 <quicksilver> the benefits are tiny
14:35:12 <quicksilver> (the OS's own VM system does the same thing on your behalf, after all)
14:35:21 <quicksilver> (unless this is for an embedded system)
14:35:44 <gwern> lispy: well, if you were interested in tracking down how revisions affected performance, you could use darcs trackdown to work back one patch at a time, building and running and profiling each version
14:36:08 <solrize> quicksilver hmm i've always heard that the key to sort performance is to do the largest possible in-memory sorts before resorting to disk operations
14:36:26 <lispy> gwern: ah, yeah my approach was different
14:36:41 <lispy> gwern: I was writting a program to simulate usage patterns and track statistics during that
14:36:53 <lispy> I have the framework, but never really wrote any non-trivial usage patterns
14:36:53 <solrize> lispy oh i see what you were doing, yeah, this is somewhat different
14:37:09 <lispy> solrize: yeah, quite a bit different.  Sorry for confusing/wasting time :)
14:37:17 <quicksilver> solrize: it's easy to test.
14:37:27 <quicksilver> solrize: fix the maximum size at 10/20/40/80 megabytes
14:37:31 <jsedgwick> Hi, i am fairly new to haskell and I can't figure out how the following works:
14:37:31 <jsedgwick>     fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
14:37:35 <quicksilver> solrize: see if the difference is measurable :)
14:37:46 <hpaste>  gwern pasted "the maiden run of autoproc" at http://hpaste.org/6507
14:37:59 <quicksilver> solrize: I'd be surprised if it was more than 5% but I've been wrong before.
14:38:04 <quicksilver> ;)
14:38:04 <gwern> lispy: I just got the full xmonadized autoproc to dump out the default. I am cheered!
14:38:14 <lispy> gwern: awesome
14:38:16 <dons> jsedgwick: its memoising a list of results, 'fibs'
14:38:29 <lispy> gwern: I still don't know why gmail + darcs was corrupting those patches, I've never seen that before
14:38:30 <gwern> interesting
14:38:30 <jsedgwick> i don't understand how the recursion works
14:38:50 <lispy> jsedgwick: what is the type of fibs?
14:38:51 <jsedgwick> zipwith is called with 0:1:... and 1:...
14:38:52 <dons> also, remember list elements are being resolved lazily
14:39:13 <dons> basically, you have 0 and 1, then the remaining elements are suspended computations defined in terms of the last 2 elems
14:39:15 <gwern> lispy: dunno either. once someone was having trouble with my bundles, but turned out they were using darcs2
14:39:17 <solrize> quicksilver i think using 80m will lose badly since it's at least 4 or 5 more passes over the data compared to using the whole 4gb machine
14:39:36 <jsedgwick> so it adds 0 and 1, then what. where does the recursion go next
14:39:45 <solrize> also i want to use hsjudy to notice duplicate records
14:40:05 <gwern> lispy: I think I messed up the header though...
14:40:29 <hpaste>  gwern pasted "what is wrong with the string formatting here?" at http://hpaste.org/6508
14:40:47 <lispy> gwern: I'm using darcs2
14:40:52 <lispy> gwern: but darcs1 gave the same error
14:40:58 <tromp> the recursion is in zipWith
14:41:03 <gwern> I don't want to use multiple putStrLns here; do I need to insert some \ns?
14:41:08 <lispy> gwern: I even removed the hash and tried to apply it and I got an error in Transform.lhs
14:41:19 <gwern> lispy: so maybe it didn't download completely?
14:41:27 <quicksilver> solrize: if you're interested then try it and tell me.
14:41:32 <lispy> gwern: it was complete
14:41:33 <solrize> quicksilver, ok
14:41:39 <syntaks> I have a rather basic quiestion I beleive... how can I write a function show' :: Show s => s -> String that is like id for Strings but like show for anything else?
14:41:42 <Baughn> "whileM :: Monad m => (a -> m (Either a b)) -> a -> m b" <-- Is this a reasonable function to use? Does it have a name already?
14:41:43 <solrize> i'm also wondering how hsjudy interacts with the gc
14:42:03 <quicksilver> syntaks: short answer: that's not really what the class system is for, so "No".
14:42:08 <lispy> gwern: do lines ["#.procmailrc", ...,]
14:42:13 <quicksilver> syntaks: long answer: actually you can, with sufficient ingenuity :)
14:42:27 <tromp> use a typeclass, syntaks
14:42:33 <lispy> :t lines
14:42:34 <lambdabot> String -> [String]
14:42:39 <solrize> gwern you probably should put those messages in an external table indexed by an enumeration, so you can easily translate the messages into different languages
14:42:44 <lispy> gwern: er, unlines is probably what I meant
14:43:17 <syntaks> quicksilver: argh, not the answer I was hoping for ;)
14:43:29 <jsedgwick> tromp: where does it recurse? i'm just lost in the process...
14:43:49 <solrize> anyway thanks all, bbl
14:43:51 <syntaks> quicksilver: I'm trying to get rid of the quotes around strings when using show
14:44:07 <quicksilver> syntaks: the type class system wasn't really designed for logic like "everything except"
14:44:11 <mauke> syntaks: why?
14:44:13 <tromp> just follow definition of zipWith, and remember to share all instances of fibs (and its tails)
14:44:35 <jsedgwick> what do you mean share the instances
14:45:04 <syntaks> mauke: I'm trying to but together some formatted string from variables of a type deriving Show
14:45:14 <jsedgwick> if you treat them as the same list, wouldn't you end up zipping the first few over and over?
14:45:27 <jsedgwick> in additional to the later ones
14:46:22 <RayNbow> lol... "So ? At my university (Braga, Portugal) our CS courses have Haskell as the 1st programming language for at least 10 years. All the freshmen who think they're some C and Java hotshots get some piece of humble pie on their first semester."
14:46:23 <oerjan> :t let str x = case cast x of s -> s; _ -> show x in str
14:46:24 <lambdabot>     Couldn't match expected type `Maybe b'
14:46:24 <lambdabot>            against inferred type `String'
14:46:24 <lambdabot>       Expected type: Maybe b
14:46:28 <RayNbow> ( http://reddit.com/r/programming/info/6co80/comments/ )
14:46:34 <oerjan> :t let str x = case cast x of Just s -> s; _ -> show x in str
14:46:35 <lambdabot> forall a. (Show a, Typeable a) => a -> String
14:46:55 <Peaker> Any idea why ghc is complaining about: http://rafb.net/p/IfzZhl34.html  ?
14:46:56 <lambdabot> Title: Nopaste - No description
14:46:56 <oerjan> syntaks: ^^ that might work although it requires an extra restriction
14:47:28 <syntaks> oerjan: ok, I'll play around with that... I didn't know cast yet :)
14:48:04 <Peaker> oh I see - "a" is not rigid enough as it knows it must be ()
14:48:43 <gwern> lispy: reasonable
14:48:43 <gwern> you meant unlines?
14:48:43 <gwern> ah, nm
14:48:43 <oerjan> syntaks: it's in Data.Typeable
14:49:09 <oerjan> gwern: you can insert \n instead if you want
14:49:58 <oerjan> hm i guess that's actually one more char per line
14:50:30 <jsedgwick> can someone walk me through the first recursion of that fibs implementation?
14:50:33 <ddarius> newtype NoQuotes = NoQuotes String; instance Show NoQuotes where show (NoQuotes s) = s
14:50:54 <jsedgwick> i found a trace at http://en.literateprograms.org/Fibonacci_numbers_(Haskell) but i still don't get how it works quit
14:50:56 <lambdabot> Title: Fibonacci numbers (Haskell - LiteratePrograms
14:50:59 <jsedgwick> *quite
14:52:22 <Gilly> jsedgwick: does this help: let's suppose the list resembles the fibb numbers, then fibs = 0 : 1 : 1 : 2 : 3 : ... and tail fibs = 1 : 1 : 2 : 3 : ... and thus if we pairwise add the elements we get 1 : 2 : 3 : 5 : 8 which is really what we should append to 0 : 1 : to get the original list
14:52:30 <syntaks> ddarius: ah, that is also a nice way to do it...
14:52:45 <syntaks> ddarius, oerjan: thanks!
14:53:05 <lispy> jsedgwick: One cool thing you can do with Haskell code is use equational reasoning.  This makes it much easier to use pen&paper to analyse what is happening.  So, foo a = b, means you can replace "foo a" with "b" without changing the meaning
14:54:36 <hpaste>  gwern pasted "why is haddock erroring on the first line?" at http://hpaste.org/6509
14:54:53 <gwern> I like the docs haddock produces, but the errors are useless!
14:55:10 <lispy> gwern: is this haddock2 or old haddock?
14:55:14 <ddarius> gwern: Agreed
14:55:22 <gwern> haddock2, it should be
14:55:44 <gwern> 'Using haddock version 2.1.0 found on system at: /home/gwern/bin/bin/haddock'
14:55:54 * nominolo thinks the "Glorious Haskell Compiler" should be renamed to the "GHC Haskell Compliler" then saying GHC Haskell Compiler wouldn't be redundant anymore.
14:56:09 <gwern> 'Autoproc/Classifier.hs:254:0: parse error in doc string' <-- what on earth does that tell me? next to nothing
14:56:14 <ddarius> Who says GHC Haskell Compiler?
14:56:33 <gwern> nominolo: madness! think how many docs and books and papers would need to be updated
14:56:41 <nominolo> if people don't know GHC, you have to say the GHC Haskell compiler
14:56:55 <lispy> gwern: might be the '.&&.'
14:57:03 <ddarius> I say, the Glasgow Haskell Compiler.  Why would I say GHC Haskell Compiler?
14:57:10 <lispy> and i forget how [x,y,z] is treated
14:57:27 <nominolo> gwern: there are certainly already many references to Glasgow Haskell Compiler
14:57:28 <lispy> gwern: oh: "xyz" as the mbox"
14:57:51 <lispy> gwern: that last double quote is suspicious
14:57:52 <nominolo> oh, it is indeed still called that way
14:58:01 <gwern> lispy: yeah, it's definitely something in the second block f text
14:58:07 <nominolo> hm, where did i get that "glorious" from then :/
14:58:25 <ddarius> It's the Glorious Glasgow Haskell Compiler.
14:58:53 <lispy> gwern: is stuffToMbox something you wrote? it doesn't look familiar
14:58:58 <gwern> lispy: oops, you're right
14:58:59 <solrize> :t (:)
14:58:59 <lambdabot> forall a. a -> [a] -> [a]
14:59:01 <gwern> lispy: yes
14:59:22 <lispy> what is the seed?
14:59:33 <gwern> lispy: actually, I  have grave concerns about the fold in stuffToMbox - do Always and Never act as True and False?
15:00:12 * lispy thinks
15:00:40 <lispy> gwern: Always is a rule that always matches, so a bit different than True, but analagous to it
15:00:46 <lispy> (I think)
15:00:54 <lispy> It's been a while since I worked with this code
15:01:39 <gwern> and I added in a Never to the data Cond, but I have no idea whether it works
15:02:17 <lispy> gwern: the question is what to map it to interms of procmail
15:02:36 <lispy> gwern: if you have a good answer to that, then it makes sense to be a Cond
15:04:26 <Peaker> I am trying to use SDL's Haskell bindings - it has waitEvent/pollEvent which get one event at a time, is there a way to get all pending events?
15:04:51 <Baughn> Whatever happened to Shim?
15:05:17 <lament> last i checked, it compiles after some sex with the makefile
15:05:21 <Baughn> Peaker: If you just want all pending events, pollEvent until it stops returning any?
15:05:25 <lament> and then it actually works
15:06:11 <Baughn> lament: Shim?
15:06:25 <Peaker> Baughn, It seems to always return an Event, not a Maybe Event
15:06:38 <Baughn> Peaker: Oh. That's an odd name, then.
15:06:51 <Peaker> oh there's NoEvent
15:07:05 <Peaker> so appearantly Event is its own Maybe
15:07:07 <Baughn> lament: You may be right; it's compiling fine. Only.. I've got a year-old version, and the repo seems to have gone missing
15:07:31 <lispy> Baughn: the repo was moved
15:07:42 <dmwit> Peaker: How unfortunate.
15:07:50 <Baughn> lispy: Where to, pray tell?
15:07:50 * tibbe ponders how the networking libs can get some sweet it's-2008 love
15:08:09 * Baughn notes that http://haskell.org/haskellwiki/IDEs needs to be updated
15:08:12 <lambdabot> Title: IDEs - HaskellWiki
15:08:37 <lispy> Baughn: I think this is where it lives now: http://mapcar.org/haskell/shim/
15:08:38 <lambdabot> Title: Index of /haskell/shim
15:10:28 <Baughn> lispy: My local (year-old) repository actually has some (13) more patches. Sorry..
15:12:14 <Gwern-away> lispy: I just sent my last bundle to you
15:12:50 <Gwern-away> I think it works, although possibly the output is incorrect, and I really need to actually come up with my own .autoproc/autoproc.hs to test whether that works
15:13:05 <lispy> Baughn: interesting
15:13:15 <lispy> Baughn: looking at the time stamps tho
15:13:31 <lispy> Gwern-away: okay, thanks!
15:13:49 <Baughn> lispy: Last update was in 2007-07-08
15:14:19 <Baughn> lispy: ..by me. Okay, last patch was in jun. 28
15:15:35 <Peaker> how would I elegantly write takeWhileM? as a combination of mapM and takeWhile somehow?
15:15:43 <lispy> Baughn: interesting, I don't know then.
15:16:05 <lispy> :t takeWhile
15:16:07 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
15:16:14 <Baughn> lispy: The lack of anything recent on google makes me want to call it abandoned
15:16:15 <Gwern-away> hm. oops
15:16:17 <oerjan> Peaker: the problem is that mapM always executes all actions
15:16:21 <lispy> ?hoogle (a -> Bool) -> m a -> m a
15:16:22 <lambdabot> Prelude.until :: (a -> Bool) -> (a -> a) -> a -> a
15:16:27 <mauke> @hoogle takeWhile
15:16:27 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
15:16:27 <lambdabot> Data.List.takeWhile :: (a -> Bool) -> [a] -> [a]
15:16:27 <lambdabot> Data.ByteString.takeWhile :: (Word8 -> Bool) -> ByteString -> ByteString
15:16:38 <Baughn> :t liftM2 takeWhile
15:16:39 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> Bool) -> m [a] -> m [a]
15:16:42 <Peaker> oerjan, oh, so I'll haev to recurse myself
15:16:56 <oerjan> yeah
15:16:57 <Peaker> oerjan, I have one like that that should work, but not with tail-recursoin
15:17:42 <Baughn> Peaker: Tail-recursion is less necessary than you'd think. The compiler is Smart (tm)
15:17:50 <Peaker> oh, ok
15:18:14 <Peaker> I guess monad making recursions can't be tail-recursive easily because they often have to call return on the result
15:18:30 <lispy> tail recursion isn't as hot as expected when using lazy evaluation
15:18:48 <Baughn> They can't ever be. In "a >> b", >> is and will remain evaluated after b
15:19:18 <oerjan> Peaker: tail recursion seems hard for takeWhile since it must combine with previous results.  you might use an accumulator and reverse but then it wouldn't work with those monads that _are_ lazy enough
15:20:41 <Baughn> Peaker: You have to separate monad construction from execution, though. Construction can't possibly be tail-recursive, but it /doesn't matter/ - laziness makes the construction only happen at need, during execution
15:20:47 <oerjan> Baughn: but not necessarily executed after b.  one must be careful with exactly what one wants to be tail recursive, in haskell
15:20:57 <Peaker> Baughn, ok
15:21:10 <oerjan> heh we said essentially the same thing
15:21:11 <EvilTerran> you usually actually *don't* want tail recursion in haskell
15:21:17 <Peaker> EvilTerran, why?
15:21:20 <EvilTerran> you want to return a partial result as soon as possible
15:21:54 <roconnor> Peaker: we use co-recursion instead of tail-recursion in lazy langaugs.
15:21:56 <Peaker> EvilTerran, I see.. intuitively, compute it "outside->inwards" so I have the first results available, and not inside-outwards, via tail recursion
15:22:02 <Baughn> Yes. Thunks don't take memory before evaluation. (well.. potential thunks? ;)
15:22:14 <Peaker> Baughn, except for keeping references alive
15:22:38 <EvilTerran> if you use an accumulating parameter instead, you get a big unevaluated thunk building up in it, and evaluation has to reach the final recursion before returning *anything*
15:22:41 <Baughn> Peaker: I spoke badly. Thunks do take space, but the data they'd evaluate to doesn't.
15:23:05 <roconnor> Peaker: http://reddit.com/info/6as3z/comments/c03cgjs
15:23:20 <EvilTerran> foldl is tail-recursive, and on an infinite list, there's no final recursion, so foldl f e (infinite list) = _|_
15:23:30 <EvilTerran> s/list,/list/
15:23:36 <Baughn> Peaker: Anyway.. in infinite recursion, if you return a partial result immediately it /doesn't matter/ that it's not tail-recursive, since the partial result will hopefully be used by the executor and then potentially GCed before it ever recurses
15:24:05 <EvilTerran> foldr isn't tail-recursive, so it's possible to get a partial result after the first iteration, given an appropriate function as parameter
15:24:28 <Peaker> Baughn, ok, I think I understand
15:24:45 <oerjan> Peaker: with general monadic code it can be even more tricky because some monads (e.g. Reader, State) are lazy and can return partial results, while some (IO in particular) are strictly executing before returning anything
15:25:52 <oerjan> so it can be hard to give a "perfect" implementation that works for all of them
15:26:36 <Baughn> Peaker: The stack is used when evaluating a thunk - a chain of a million (+1)s can overflow it - but once the thunk is /done/ it's thrown away and only the thunk remains, on the heap, where it may be GCed. Thus..
15:26:39 <Peaker> does this make sense: http://rafb.net/p/keVkFU62.html ?
15:26:39 <lambdabot> Title: Nopaste - No description
15:26:39 <lispy> *cough* unsafeInterleaveIO *cough*
15:26:56 <EvilTerran> nasty cough you've got there, lispy
15:27:08 <esteth> I've been reading some more on monads and (can't you just see where this is going? :P) i'm still having trouble with some aspects of them. In particular, i've read that the state monad is one that is constructed as State s a where s is the type of the "variable" and a is the type of the result. I'm still left wondering, however, how exactly i can use the State monad. I know how to make one, but still have no idea of how to a
15:27:38 <EvilTerran> Peaker, "then liftM (value:) (takeWhileM cond element)"
15:27:43 <Peaker> esteth, the YAHT example is pretty good
15:27:46 <lispy> esteth: take a look at the random function
15:27:47 <Gwern-away> lispy: ok, I fixed my problem and am sending. thus far, it works with a .autoproc/autoproc.hs - although I've only tested it with 'autoprocMain $ dagitRules'...
15:27:49 <lispy> ?hoogle random
15:27:49 <lambdabot> System.Random.random :: (Random a, RandomGen g) => g -> (a, g)
15:27:49 <lambdabot> System.Random :: module
15:27:49 <lambdabot> System.Random.Random :: class Random a
15:28:13 <lispy> esteth: see that it returns a Random value, a, and a RandomGen g
15:28:21 <lispy> esteth: it plays nicely with the State monad
15:28:25 <ddarius> lispy: Nice self-promotion there.
15:28:27 <oerjan> Peaker: then return (value:takeWhileM cond element)
15:28:50 <lispy> ddarius: sorry?
15:28:51 <oerjan> will not work, it contains monadic actions inside the pure part
15:28:54 <EvilTerran> oerjan, i've already corrected that ;)
15:28:59 <Baughn> esteth: Most monads have an execute function that you use to extract the value. There are a few exceptions, like List or Maybe where you don't need one (or it's in the Prelude, I guess..)
15:29:01 <oerjan> oh
15:29:16 <Peaker> EvilTerran, oerjan : Hmm.. why does it compile correctly?
15:29:17 <EvilTerran> contrapuntal fugues an' all that, i guess :P
15:29:51 <roconnor> esteth: do { x <- put 5; y <- stateFooFunction; y <- get; {- at this point stateFooFunction may have changed the state, so y may no longer be 5 -} return (y+1) }
15:30:00 <EvilTerran> Peaker, it shouldn't
15:30:11 <EvilTerran> ?type (:)
15:30:12 <lambdabot> forall a. a -> [a] -> [a]
15:30:29 <cnwdup> @src Position
15:30:29 <lambdabot> Source not found. Do you think like you type?
15:30:31 <EvilTerran> and you say yourself that "takeWhileM cond element :: m [a]"
15:30:34 <roconnor> esteth: do { x <- put 5; y <- stateFooFunction; z <- get; {- at this point stateFooFunction may have changed the state, so z may no longer be 5 -} return (z+1) }
15:30:49 <Baughn> esteth: A State a b variable is effectively a program in a language with (one) mutable variable. The execute function acts as an interpreter
15:30:51 <roconnor> esteth: (sorry I didn't mean to use y twice in my example)
15:30:59 <Baughn> esteth: ..s/variable/value/
15:31:03 <EvilTerran> somewhat incompatible function types
15:31:15 <EvilTerran> ?type put -- roconnor, i don't think this returns anything interesting
15:31:16 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
15:31:21 <roconnor> it should be put 5 rather than x <- put 5
15:31:27 <roconnor> ugh
15:31:38 <Peaker> EvilTerran, oh indeed it does not compile, my bad
15:31:42 <roconnor> okay, I'll let you guys handle this.  Obviously I need to go eat ;)
15:31:44 <Peaker> EvilTerran, thanks
15:31:50 <roconnor> brain isn't entirely working.
15:32:07 <roconnor> good thing haskell has a type checker.
15:32:37 <EvilTerran> :)
15:32:49 <oerjan> @remember roconnor brain isn't entirely working. // good thing haskell has a type checker.
15:32:49 <lambdabot> Nice!
15:33:15 <esteth> Ok. so i use the put action to store the value in a container. Then i use get to fetch this value back out of the container? In this case, my set "variable" only exists for the duration of the do block?
15:33:28 <oerjan> nearly a haiku, that
15:34:06 <Baughn> esteth: It exists for the duration of the monad.. as I said, a state value is a program
15:35:06 <cnwdup> I'm trying to figure out what the type Position is like and how I can match it. Where do I look something like this up? Usually Google helps me but this time results are rather useless.
15:35:30 <oerjan> @hoogle Position
15:35:30 <lambdabot> Text.ParserCombinators.Parsec.Prim.getPosition :: GenParser tok st SourcePos
15:35:30 <lambdabot> Text.ParserCombinators.Parsec.Prim.setPosition :: SourcePos -> GenParser tok st ()
15:35:36 <oerjan> bah
15:36:06 <Baughn> Brain not working. Haskell has type checker. Warm winter rain.
15:36:11 <esteth> Baughn: I'd understand that if i explicitly had to create a reference to a State Int Int for example, then my state would no longer exist once i lost all my references to it, but what's the duration of the monad when i use put once?
15:36:13 <Gwern-away> 'i kant haskell today. I has the dumbs'
15:36:35 <oerjan> Baughn: er that's 4-6-4 not 5-7-5?
15:36:50 <Japsu> http://arcanux.org/lambdacats.html#entry8
15:36:52 <lambdabot> Title: Lambdacats
15:37:11 <Baughn> oerjan: I /told/ you my brain wasn't working
15:37:12 <oerjan> cnwdup: if you know the library there should be haddock documentation somewhere hopefully
15:37:31 <cnwdup> oerjan: Well... I think it's Prelude. I'll google for that. Thanks.
15:37:41 <Peaker> Why is the last return () invalid syntax in: http://rafb.net/p/gxzSZ063.html
15:37:42 <lambdabot> Title: Nopaste - No description
15:37:42 <Baughn> esteth: Indefinite. It exists for the duration of the monad, as I said - wherever you chain the monad value.
15:38:31 <EvilTerran> esteth, it's available anywhere in that monadic computation
15:38:31 <oerjan> cnwdup: doubtful.  i don't recall Position.  and if it was there @hoogle should have had it
15:38:51 <resiak> Peaker: because the 'do' block ends when you use 'where'
15:38:55 <EvilTerran> esteth, being, in a way, the outermost do{} block of the computation
15:39:17 <Peaker> resiak, oh, thanks
15:39:25 <cnwdup> oerjan: Okay. Then it could only be OpenGL related.
15:39:30 <oerjan> Peaker: may i recommend hpaste instead?
15:39:32 <oerjan> @hpaste
15:39:32 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:39:39 <resiak> Peaker: also, look at mapM_
15:39:50 <Peaker> sure, will do
15:39:55 <esteth> So it's availible as long as i don't stop using my >> / >>= operators, then it evaporates and i get a new set/put value?
15:40:07 <oerjan> cnwdup: sounds reasonable
15:40:11 <EvilTerran> esteth, it's "threaded through" your >>=s
15:40:13 <oerjan> @where opengl
15:40:13 <lambdabot> I know nothing about opengl.
15:40:17 <hpaste>  resiak pasted "Peaker: no do block in sight!" at http://hpaste.org/6510
15:40:21 <EvilTerran> (and >>s, they're just shorthand for >>=s)
15:40:32 <Baughn> esteth: Yes. Of course, the variables have to match up with the executeState invocations
15:40:48 <Peaker> @type mapM_
15:40:49 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
15:40:57 <EvilTerran> or runState, or evalState...
15:41:00 <Baughn> esteth: Another variable would imply an entirely separate computation. (..well, they're the only thing /in/ the computation)
15:41:11 <Peaker> so mapM_ just ignores the resulting list?
15:41:21 <EvilTerran> esteth, do you know what i mean by "monadic computation"?
15:41:25 <oerjan> cnwdup: hm i think :i Position in ghci could tell you where it is defined
15:41:49 <resiak> @src mapM_
15:41:50 <lambdabot> mapM_ f as = sequence_ (map f as)
15:41:50 <esteth> EvilTerran: You mean a do{} block or a sequence of actions put together with >>= ?
15:41:54 <oerjan> (assuming it is loaded from somewhere)
15:42:04 <Baughn> esteth: It would be impossible to "lose" it - such a program couldn't work since it'd then have to invent an initial value from whole cloth. Which it won't.
15:42:04 <oerjan> oh and also tells you the constructors
15:42:05 <resiak> Peaker: mapM actually wasn't doing what you think it was
15:42:14 <resiak> Peaker: you were building a whole list of IO actions, but never actually running them
15:42:17 <EvilTerran> esteth, yes, but bear in mind that functions can also return actions
15:42:22 <Baughn> esteth: If you like, its scope is as large as it possibly could be
15:42:25 <resiak> oh, no, i'm lying.  you weren't.
15:42:30 <cnwdup> oerjan: Thank you. (:
15:42:32 <Peaker> resiak, I thought it built an  m [a]
15:42:35 <Peaker> @type mapM
15:42:36 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:42:41 <EvilTerran> and that action gets made into part of the action you called the function from
15:42:42 <resiak> yeah, it was building IO [()]
15:42:59 <resiak> @src sequence_
15:42:59 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
15:43:06 <Peaker> resiak, mapM is building IO [..]  -- doesn't it mean its concat'd all of the little computations into a big one?
15:43:18 <EvilTerran> so a function :: ... -> State Foo (); gets linked into a bigger action if you call it from one, and so uses the same percieved mutable variable
15:43:24 <Baughn> Peaker: Sure
15:43:30 <EvilTerran> esteth, have you seen "you could have invented monads"?
15:43:35 <EvilTerran> ?go "you could have invented monads"
15:43:36 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
15:43:36 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
15:43:44 <Baughn> Peaker: Well, not "concat" in the sense of combine; they get run separately
15:43:46 <Peaker> resiak, oh I missed your message there
15:43:57 <Peaker> Baughn, Yeah I should have said monadically bound :-)
15:44:04 <esteth> Baughn: I'm confused now. Sorry about this, i feel like i'm just being stupid now. You're saying that i only get one get/put for my entire program, since the biggest possible scope is global, surely.
15:44:29 <EvilTerran> esteth, the biggest scope is the outermost do block of that monadic computation
15:44:37 <Baughn> esteth: Sorry. No, the largest possible scope is the scope of the runState evaluation
15:44:53 <Baughn> "outermost do block" is a decent intuition, but unfortunately not quite correct
15:45:30 <Baughn> esteth: You can use state by intuition and it'll usually work - same as IO, really - but you should probably read several monad tutorials in order to /really/ understand it. (I've read, oh, five..)
15:45:31 <EvilTerran> as i said, outermost if you include those inside functions that return actions you run in the caller's do block, and whatnot
15:46:02 * ddarius thinks monad tutorials are a waste of time.
15:46:36 <EvilTerran> ddarius, that's an implementation detail :P
15:46:45 <Baughn> It's hard to tell which one will make things click. Usually it's a combination, so..
15:46:58 <monochrom> ddarius: What do you recommend instead?
15:47:15 <oerjan> ddarius: does that mean you are going to be the one finally writing "Monad tutorials considered harmful"? :)
15:47:23 <esteth> right. So my state sits around until i close of the last do block i'm inside. So state doesn't "nest" inside do blocks? ie: do{x <- put 5; do{x <- put 3} y <- get} y is now 3?
15:47:34 <ddarius> Wadler's papers (though you may still consider them monad tutorials)
15:47:53 <monochrom> Ah, I agree with you!
15:48:08 <EvilTerran> esteth, we've said repeatedly that it does
15:48:19 <EvilTerran> esteth, go look at that link i summoned above
15:48:38 <monochrom> Why don't you execute the code and see?
15:48:40 <esteth> EvilTerran: Sorry, i must be misunderstanding you. I'll read that link though, thanks for that
15:49:10 <Baughn> esteth: put doesn't actually return anything. (Or if it doesn, that's surprising.. anyway, there's little point in the x <- bit
15:49:14 <monochrom> @botsnack
15:49:14 <lambdabot> :)
15:49:29 <shapr> @users
15:49:29 <lambdabot> Maximum users seen in #haskell: 473, currently: 461 (97.5%), active: 23 (5.0%)
15:49:37 <Baughn> esteth: And do { put 5; do { put 3}; y <- get } is exactly equivalent to do { put 5; put 3; y <- get }
15:50:01 <Baughn> esteth: That's true even if the inner do is another function. In fact, it's generally true in all of haskell.
15:50:05 <oerjan> @@ @redo @undo do { put 5; do { put 3}; y <- get; whatever }
15:50:05 <lambdabot>  do { y <- do { do { put 5; put 3}; get}; whatever}
15:50:12 <oerjan> what the
15:50:39 <oerjan> @undo do { put 5; do { put 3}; y <- get; whatever }
15:50:39 <lambdabot> put 5 >> put 3 >> get >>= \ y -> whatever
15:50:40 <EvilTerran> esteth, i found it made using the monad make more sense if i knew how it was implemented, which is what that page talks about
15:51:13 <oerjan> @redo put 5 >> put 3 >> get >>= \ y -> whatever
15:51:13 <lambdabot> do { y <- do { do { put 5; put 3}; get}; whatever}
15:51:28 <EvilTerran> ... fnord
15:51:31 <oerjan> that is just not right...
15:51:38 <monochrom> " do{x <- put 5; do{x <- put 3} y <- get} y  "  is invalid code.
15:51:43 <esteth> Baughn: Now that i think about it, that's obvious. the nested do block would just get broken down into >>='s
15:51:54 <esteth> so there's no "nesting" possible?
15:52:12 <Baughn> esteth: If you mean in the sense of hiding the variable, sure there is
15:52:19 <monochrom> Use Reader for "nesting", unless I can't guess what you mean.
15:52:25 <Baughn> esteth: Just call runState again. ;)
15:52:56 <oerjan> oh it is actually @undo which ignores precedence
15:53:00 <Baughn> esteth: Then you'd have "do put 5; runState (put 3) ...; get" returning 5, not 3
15:53:28 <Baughn> esteth: (Of course, the inner runstate wouldn"t actually be executed unless you use its value, which I don't here. Kinda silly, I guess.
15:54:04 <esteth> Baughn: Ok. In general though, a nested do block just becomes part of the surrounding do block?
15:54:20 <Baughn> esteth: Yes
15:55:06 <Baughn> esteth: And when you say "foo = whatever" in haskell, you really /mean/ it. Barring a few special cases that don't really affect semantics, you can substitute the right-hand side for the left-hand side anywhere you like.
15:55:23 <esteth> Ok. I've at least understood something from all of this :)
15:56:23 <Baughn> esteth: You do need to understand the runtime behaviour as well, where such substitution definitely /does/ affect things, but not semantically. Just memory use and cpu use...
15:57:14 <monochrom> I know what you mean, but I disagree with that wording.
15:57:35 <esteth> Baughn: I knew about that, since i had trouble with that before as well. It seems as though haskell is purposefully crafted to be just similar enough to imperative languages that you think you know what's going on, but different enough that it confuses me no end :(
16:00:25 <lament> haskell is so not similar to imperative languages.
16:00:44 <Baughn> It's not too similar to pure functional languages eitther
16:00:58 <Baughn> I do so enjoy using laziness to mutate data structures. ^_^
16:01:32 <realspace> Hello all. I have a problem in only three lines Haskell regarding type constraint in data type declaration with instance definition: http://hpaste.org/6511
16:01:42 <esteth> lament: I more meant in the way that i have classes that behave more like interfaces and equals that doesn't run anything, and so on
16:02:07 <monochrom> It hurts my eyes when people use imperative mindset to discuss haskell stack overflow such as "I think it is because my code is recursive".
16:02:12 <esteth> lament: so lots of the same terms are floating around, but they mean similar, but different things
16:03:57 <lament> realspace: this is called "stupid context"
16:04:07 <mauke> realspace: short answer: don't put type constraints on type definitions
16:04:17 <lament> realspace: that (Show a) part in the data declaration, i'm not sure if it does anything at all
16:04:18 <monochrom> Heh
16:04:38 <hpaste>  bos annotated "Problem" with "fixed for realspace" at http://hpaste.org/6511#a1
16:04:47 <Cale> It does do one thing. It restricts the type of the data constructor.
16:05:03 <realspace> lament: yes that "(Show a) =>" only effects the type constructor
16:05:08 <Cale> That's it. It doesn't give you anything else.
16:05:16 <kpreid> Cale: why doesn't it restrict x?
16:05:37 <Cale> kpreid: Because in order to do that, it would have to store a dictionary, almost like an existential would.
16:05:50 <hpaste>  lament annotated "Problem" with "-fglasgow-exts" at http://hpaste.org/6511#a2
16:05:53 <Cale> kpreid: and this is Haskell 98, so that kind of fanciness wasn't in consideration :)
16:06:02 <realspace> bos: THANK YOU!
16:06:14 <Cale> In GHC, if you use the GADT syntax, you can get that effect though.
16:06:18 <Cale> like:
16:06:23 <Cale> data Foobar a where
16:06:24 <kpreid> Cale: why does it need runtime presence?
16:06:28 <lispy> GADT++
16:06:33 <Cale>   Foobar :: (Show a) => a -> Foobar a
16:07:01 <BMeph> That's what Haskell needs, is a "data constrictor!" ;)
16:07:20 <Cale> kpreid: Because if you want functions which take values of that type to be able not to have that additional typeclass constraint, they have to get the dictionary of methods from somewhere.
16:07:39 <Cale> kpreid: and they're not going to magically construct it from the type -- that's gone at runtime.
16:08:17 <Cale> So basically the only practical way is to store it in with the rest of the data when values of that type are constructed.
16:08:28 * BMeph goes off to find a use for a "Boa" data type...
16:08:31 <kpreid> Cale: oh, and hoisting it into the instance head(?term?) would then end up an Odd Special Case?
16:09:12 <Cale> kpreid: Oh, that too.
16:09:52 <realspace> hmm, I'm just learning haskell. I don't know anything about GADT
16:09:59 <Cale> Normally, something like   instance (Show a) => Show (Foobar a)   is implemented as a function on dictionaries.
16:10:07 <bos> realspace: don't worry about GADTs for now. they're still not what you want.
16:10:22 <Cale> realspace: You just want to add a Show constraint to a, in the instance
16:10:34 <lament> realspace: Use bos's solution, not mine :)
16:10:42 <Cale> realspace: (and probably remove it from the Foobar data declaration, as it doesn't do much there)
16:11:19 <bos> it's actually damaging in the data declaration.
16:11:38 <bos> it removes the possibility of making your type a Functor or Monad.
16:11:52 <bos> both of which are tasty and nutritious, especially the Functor.
16:12:33 <realspace> yes I remove it from the Foobar data declaration. I allready learned with ":t Foobar" in ghci, that this only restrivted the constructor
16:12:34 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6512
16:16:16 <realspace> btw, exists somewhere a good tutorial or book which describes all that fancy type-stuff like my solved problem?
16:25:15 <mofmog> so how do i define data types in ghci
16:25:23 <mofmog> or do i have to load a file?
16:25:33 <mofmog> It's tough making strict typing look good to weak typing defenders
16:25:44 <oerjan> must load yes
16:25:50 <mofmog> dang
16:26:48 <Baughn> mofmog: Ask them how they'd implement Data.Map.lookup?
16:28:26 <monochrom> I wouldn't be keen on convincing people of Haskell.  If they dislike it, they can find all sorts of trivial excuses to attack it, such as "I hate to capitalize type names but not variable names".
16:28:38 <mofmog> right now i'm working on showing how you can do heterogeneous lists
16:28:58 <mofmog> i find the process of convincing helps the process of learning
16:29:29 <mofmog> I wouldn't even know what a zipper was until i tried convincing people they were better. Maybe a little backwards logic
16:29:32 <roconnor> @quote heterogeneous
16:29:32 <lambdabot> No quotes match. There are some things that I just don't know.
16:29:37 <Baughn> mofmog: It's an interesting thing to ask, but I've found that normally I don't /need/ them
16:29:53 <Baughn> Homogenous lists cover 99% of all cases
16:30:17 <mofmog> Baughn: I was giving an example with ADT's and how they could be used instead
16:30:29 <monochrom> I see.  Carefully choose whom to convince.  They should be the kind of people who focus on the real points rather than "what do you mean you can't enter that into ghci".
16:30:40 <mofmog> well i'm convincing my professor
16:30:48 <monochrom> See, it helps your learning if they focus on the important things too.
16:31:15 <mofmog> well knowing why strict typing is superior is important itseems to me
16:32:02 <roconnor> one problem is that dynamic types aren't types, they are tags
16:32:37 <dcoutts> roconnor: that's a controversial distinction
16:32:50 <kpreid> let's say it's a terminology distinction :-)
16:33:08 <roconnor> dcoutts: also, math is computer science.  :)
16:33:19 <dcoutts> heh heh
16:35:58 <jsedgwick> is there a trace command in ghc?
16:36:06 <oerjan> @hoogle trace
16:36:06 <lambdabot> Debug.Trace.trace :: String -> a -> a
16:36:06 <lambdabot> Debug.Trace :: module
16:36:06 <lambdabot> Debug.Trace.traceShow :: Show a => a -> b -> b
16:36:21 <oerjan> oh you mean the debugger
16:36:33 <roconnor> ooh, there is a traceShow!
16:36:48 <roconnor> now I don't have to write trace show
16:36:52 <jsedgwick> i just want to see the recursion tree as i'm confused with this function
16:37:54 <EvilTerran> get hat! :D
16:38:00 <EvilTerran> ?where hat
16:38:00 <lambdabot> http://www.haskell.org/hat/
16:42:09 <Gwern-away> does hat still work?
16:42:44 <Gwern-away> ...no, it doesn't
16:43:15 * Gwern-away thwaps EvilTerran. bad person, recommending to people broken software! what if jsedgwick had believed you?
16:43:52 <EvilTerran> the "! :D" was meant to suggest i wasn't being entirely serious
16:43:58 <mofmog> how do i respond to "Rapid Prototyping!"
16:44:05 <mofmog> as a support for weak typing
16:44:17 <EvilTerran> i wasn't aware that it was broken, tho. i thought i just sucked at getting stuff to work. :P
16:44:39 <roconnor> there is this new ghci debugger.
16:44:44 <roconnor> but I have never used it
16:44:47 <roconnor> not having the new ghc
16:44:52 <Gwern-away> EvilTerran: it could've easily been that hat was the perfect solution, so perfect you were infected with fatal hilarity at how well it would've aided the querant
16:44:55 <EvilTerran> mofmog, compare LoC stats between their "rapid prototype" and your finished product
16:44:55 <darrint> Where can I find web sites where I can enter haskell code in a browser form and see it evaluated?
16:45:05 * Gwern-away pities da fool using old GHC
16:45:13 <daf> darrint: http://codepad.org/
16:45:15 <Gwern-away> darrint: use lambdabot mebbe?
16:45:18 <Gwern-away> > 2 + 2
16:45:20 <lambdabot>  4
16:45:25 <EvilTerran> mofmog, and then gloat because your finalised haskell program is shorter than their quick hack
16:45:28 <dons> daf: yeah, lambdabot or codepad.org
16:45:54 <mofmog> EvilTerran: Well, my prfessor is going from a real world example of customers being stupid
16:45:58 <daf> you can also send lambdabot private messages if you don't want to spam the channel
16:46:07 <mofmog> and thus, you need a quick way of fixing their mistakes
16:46:08 <darrint> codepad. Thanks daf. I knew of that one and couldn't remember its name and google was zero help.
16:46:20 <mofmog> wait, has ghc been updated recently?
16:46:22 <daf> darrint: welcome
16:46:24 <EvilTerran> mofmog, i can rapid prototype just fine in haskell, anyway
16:46:51 <EvilTerran> if anything, it's even more rapid, as i can let the typechecker catch all the stupid mistake
16:46:52 <EvilTerran> s
16:48:05 <lispy> Gwern-away: I'm stuck on ghc6.6 because some of the more esoteric type checking changed in 6.8 :(
16:49:07 <DQuest> EvilTerran: A cunning ploy.  I'm coming to believe that people like dynamic languages because the type system gets out of their way, but really the problem isn't with types in general but rather the type systems you get with languages like java
16:49:44 <EvilTerran> indeed. the problem is static checks that get in the way, not static checks in general
16:49:45 <hpaste>  RedBeard0531 pasted "ungreedyView" at http://hpaste.org/6514
16:50:01 <EvilTerran> and haskell's type system doesn't get in the way (mostly), it stops you making stupid mistakes
16:50:51 <wagle_home> EvilTerran hasnt fought very interesting battles with the haskell type system
16:51:12 <EvilTerran> oh, i have
16:51:16 <EvilTerran> but you can avoid most of them
16:51:29 <DQuest> hah
16:52:09 <DQuest> many times I've heard it said that the beauty of haskell is that once you've got your datatypes right, the program practically writes itself.  What's not explained is exactly how hard getting your datatypes right might actually be
16:52:09 <aFlag> hello. Has anyone here used EHC? I'm having trouble compiling it.
16:52:10 <EvilTerran> the main one that bothers me (and that i'm still thinking about how to best fix/work around) is the need for newtypes for Monoid instances etc
16:52:45 <roconnor> DQuest: :)
16:53:34 <mofmog> ok um stupid question but what does => mean again?
16:53:43 <mofmog> as in Num =>
16:53:53 <TSC> It's a constraint on a type variable
16:54:02 <TSC> @type sum
16:54:03 <lambdabot> forall a. (Num a) => [a] -> a
16:54:04 <Japsu> Num a => a means "any type a for which there is an instance of the Num class"
16:54:43 <mofmog> ah
16:54:59 <Japsu> @instances Num
16:55:00 <lambdabot> Double, Float, Int, Integer
16:55:07 <Japsu> @type (+)
16:55:08 <lambdabot> forall a. (Num a) => a -> a -> a
16:55:22 <mofmog> so natural numbers have multiple ambiguous data types to haskell
16:55:27 <mofmog> until you set them
16:55:32 <oerjan> @instances- Data.Word Data.Int Foreign.C.Types Data.Complex Data.Ratio
16:55:32 <lambdabot> Couldn't find class `Data.Ratio'. Try @instances-importing
16:55:35 <Japsu> This means that you can use the + operator as if it were Double -> Double -> Double, Float -> Float -> Float etc.
16:55:42 <oerjan> @instances- Data.Word Data.Int Foreign.C.Types Data.Complex Data.Ratio Num
16:55:43 <lambdabot> CChar, CClock, CDouble, CFloat, CInt, CIntMax, CIntPtr, CLDouble, CLLong, CLong, CPtrdiff, CSChar, CShort, CSigAtomic, CSize, CTime, CUChar, CUInt, CUIntMax, CUIntPtr, CULLong, CULong, CUShort,
16:55:43 <lambdabot> CWchar, Complex a, Double, Float, Int, Int16, Int32, Int64, Int8, Integer, Ratio a, Word, Word16, Word32, Word64, Word8
16:57:05 <dons> funky, oerjan
16:57:51 <DQuest> haha
16:57:58 <DQuest> oops, wrong channel
16:58:12 <oerjan> #haskell is no laughing matter
16:58:26 <dons> this is serious business
16:58:26 <DQuest> damned lag had only half switched windows.  I hate my internet connection
16:58:28 <shapr> @yow !
16:58:29 <lambdabot> How do you explain Wayne Newton's POWER over millions?  It's th' MOUSTACHE
16:58:29 <lambdabot> ...  Have you ever noticed th' way it radiates SINCERITY, HONESTY & WARMTH?
16:58:29 <lambdabot> It's a MOUSTACHE you want to take HOME and introduce to NANCY SINATRA!
16:59:55 <Toxaris> shouldn't window switching be a client-side operation?
16:59:58 * oerjan notes that there is no moustache in wikipedia's Wayne Newton picture
16:59:59 <realspace> bye * and thank you again
17:00:08 <DQuest> yes, but my client is on another machine
17:00:14 <oerjan> maybe it was stolen!
17:00:27 <DQuest> so half my window was #haskell and the other half was a channel in which they are currently discussing tentacles
17:01:05 <dons> we can discuss tentacles here too, if you like
17:01:12 <dons> monads are like tentatcles
17:01:30 <Corun> read: testicles
17:01:41 <oerjan> read: gonads
17:01:53 <DQuest> that would be the most awesome or the most distrubing introduction to monads ever
17:02:13 <roconnor> tentatcles that grab onto types an never let go
17:02:19 <oerjan> ftagn
17:02:28 <DQuest> I've yet to write the traditional post-understanding-monads blog post about how they work
17:02:30 <roconnor> and when you bring it into contanct with another type
17:02:39 <roconnor> it latches onto that too!
17:02:42 <roconnor> @type (>>=)
17:02:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:02:57 <roconnor> =<< kinda even looks like chuthulu
17:03:04 <DQuest> so say you want a monad to represent a cult of a great old one
17:03:08 * oerjan suddenly wonders what co-cthulhu is like
17:03:10 <dons> monads are like chuthulu
17:03:16 <Toxaris> why do people focus on a property some monads have not (the existence of m a -> a) instead of properties all monads share?
17:03:51 <DQuest> Pah.  I didn't understand a thing until I learnt what the type system was actually doing
17:04:13 <DQuest> after that, monads are just a more complicated version of what's going on with (==)
17:04:38 <Toxaris> yeah, it helps to understand the definition of class Monad :)
17:04:52 <DQuest> It helps to understand the definition of "class" :P
17:05:19 <DQuest> I had this silly idea that it was all syntax that I would pick up as I went along
17:05:45 <dons> Toxaris: well, not so much m a -> a, but once you're out, you're out.
17:06:53 <oerjan> :t join -- i'm out - oh wait
17:06:54 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:07:08 <DQuest> :t uncloset
17:07:09 <lambdabot> Not in scope: `uncloset'
17:07:34 <Toxaris> dons: so there is no foo :: m a -> a with return . foo == id?
17:08:17 <Toxaris> dons: or something like this. but this follows from the non-triviality of m, not the monadicness.
17:08:19 <dolio> Wouldn't that be 'foo :: a -> m^-1 a'?
17:09:11 <oerjan> Toxaris: data Trivial a = Trivial; instance Monad Trivial where return _ = Trivial; _ >>= f = Trivial
17:09:14 <Baughn> dolio: ..I'm fairly certain that made no sense
17:09:34 <roconnor> @src () (>>=)
17:09:35 <lambdabot> Source not found. You speak an infinite deal of nothing
17:09:38 <EvilTerran> but it was an AWESOME lack of sense
17:09:39 <nibro> Toxaris: in the general case there is no such function, though it exists for some monads
17:09:40 <roconnor> @src (>>=) ()
17:09:40 <lambdabot> Source not found. That's something I cannot allow to happen.
17:09:41 <dolio> Oh, I was thinking id :: a -> a.
17:09:42 <oerjan> actually undefined would work for that one
17:09:43 <mauke> roconnor: kind error
17:09:47 <nibro> :t runReaderT
17:09:48 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
17:09:51 <dolio> Not m a -> m a.
17:09:51 <cjb> anyone want to point me at an awesome paper to read on my subway ride home?  :)
17:09:54 <roconnor> right
17:10:06 <nibro> :t runReader
17:10:08 <lambdabot> forall r a. Reader r a -> r -> a
17:10:20 <nibro> :t runWriter
17:10:20 <lambdabot> forall w a. Writer w a -> (a, w)
17:10:23 <EvilTerran> ... i guess you could data Void a = Void; instance Monad Void where return _ = Void; _ >>= _ = Void
17:10:34 <EvilTerran> oh, wait, oerjan just did that.
17:10:35 <Toxaris> oerjan, nibro: another reason not to speak about it in tutorials
17:10:54 <Toxaris> Identiy is enough
17:11:15 <nibro> bah, I really don't understand what's so hard about monads that you need tutorials on them
17:11:15 <EvilTerran> not for showing that :: m a -> a is impossible in general
17:11:17 <nibro> ;-)
17:11:20 <Toxaris> > runIdentity . return $ 3
17:11:21 <lambdabot>   Not in scope: `runIdentity'
17:11:24 <Toxaris> :(
17:11:26 <EvilTerran> Maybe is enough for that one, tho
17:11:37 <Toxaris> EvilTerran: I don't want to show that
17:11:46 <nibro> monads are all about making some things explicit in computation, that's all there is to it!
17:11:48 <EvilTerran> ... what're you showing?
17:12:07 <oerjan> nibro: they are so easy that you need tutorials to confuse you ;)
17:12:26 <nibro> oerjan: So true!!
17:12:28 <Toxaris> EvilTerran: why do people focus on a property some monads have not (the existence of m a -> a) instead of properties all monads share?
17:12:41 <nibro> Toxaris: who focuses on that?
17:12:45 <EvilTerran> because people are irrational and stupid
17:12:50 <dolio> Baughn: Clearly it's the type function inverse of the monad, where m (m^-1 a) = a. :)
17:12:53 <monochrom> The easiest things need the most learning effort.  Take numbers for example: takes most people years to learn.
17:13:15 <Toxaris> nibro: monad tutorials, especially the "monads are like" aproach
17:13:39 <Baughn> dolio: Can I use IO^-1 to recover safety after someone used unsafePerformIO?
17:13:39 <nibro> heh, good thing I've never had to read a monad tutorial then :)
17:13:57 <roconnor> aren't monads like nuclear waste in a space suit floating in the ocean?
17:14:11 <allbery_b> *snicker*
17:14:12 <nibro> but the run-equivalent of monads *is* important, and most monads have it
17:14:13 <Baughn> roconnor: No, that'S for monad transformers
17:14:15 <Toxaris> nibro: monads are about making things *implicit* in computation, e.g. implicit nondeterminism (aka [] monad), implicit parameters (aka Reader monad), implicit state passing (aka State and IO) etc
17:14:46 <nibro> Toxaris: right, that was a brain core dump by me, I meant implicit of course
17:14:53 * wagle_home wonders what it'd be like to be a non-cs freshman student in roconnor's class
17:15:09 <glen_quagmire> i teach MS Office in college yay
17:15:17 <dmwit> Implicit in the sense that you don't have to do it yourself, explicit in the sense that your type betrays what's really going on.
17:15:20 <nibro> Toxaris: the only monad without a run function equivalent is IO
17:15:24 <dolio> Baughn: Only with unsafePerformIO^-1, of course. :)
17:15:27 <nibro> dmwit: true
17:15:46 <nibro> implicit in the sense that you don't have to write out all the plumbing
17:16:03 <glen_quagmire> haskell is not functional programming. it is monad oriented programming
17:16:05 <Toxaris> nibro: hmm. and IO likes (consider frameworks different from IO). the may not exist, but they could and maybe should.
17:16:07 <nibro> the writer monad keeps output implicit, the reader monad keeps http://xs125.xs.to/xs125/08124/127visitors968.png
17:16:11 <nibro> gah
17:16:23 <nibro> the writer monad keeps output implicit, the reader monad keeps input implicit, etc
17:16:35 <monochrom> nice picture haha
17:16:47 <glen_quagmire> nibro: is that written in haskell?
17:16:47 <nibro> monochrom: I'm about to be invaded!
17:16:58 <nibro> glen_quagmire: I wish
17:17:15 <glen_quagmire> civillization III ?
17:17:19 <roconnor> wagle_home: perhaps a picuture will help http://koweycode.blogspot.com/2007/01/think-of-monad.html
17:17:19 <lambdabot> Title: koweycode: think of a monad...
17:17:20 <Toxaris> nibro: writer is not the opposite of reader in any sense i'm aware of
17:17:27 <nibro> glen_quagmire: quite right
17:17:30 <Toxaris> nibro: i think reader is a bad choosen name, it should be context
17:17:32 <hpaste>  morrow pasted "encode/decode sets with UFDs" at http://hpaste.org/6515
17:17:44 <roconnor> ``Think of a monad as a spacesuite full of nuclear waste in the ocean next to a container of apples. now, you can't put oranges in the space suite or the nucelar waste falls in the ocean, *but* the apples are carried around anyway, and you just take what you need. - Dons
17:18:08 <allbery_b> yeh, I've always thought "reader" was an odd name, it's not a reader in any sense I commonly think of
17:18:14 <allbery_b> context, otoh
17:18:18 <nibro> Toxaris: no, they are not opposites, the just keep different things (input/output) implicit
17:18:37 <glen_quagmire> i don't get that monad analogy at all
17:18:46 <nibro> I prefer the 'other' name to Reader: an environment monad
17:18:48 * Baughn notes that some germans have now invented room-temperature superconductors
17:18:59 <dmwit> glen_quagmire: Me neither.
17:19:01 <wagle_home> roconnor, rofl
17:19:14 <nibro> glen_quagmire: I don't think you're supposed to :)
17:19:31 <dolio> glen_quagmire: It's an amalgamation at all the different analogies for monads that were floating around at the time.
17:19:34 <glen_quagmire> shouldn't the apples inside the spacesuit?
17:19:44 <glen_quagmire>              ^ be
17:19:56 <oerjan> Baughn: o_O
17:20:06 <hpaste>  morrow annotated "encode/decode sets with UFDs" with "(no title)" at http://hpaste.org/6515#a1
17:20:34 <dolio> The nuclear waste has to do with the IO monad keeping evil IO stuff separate from pure code. And you can't open the space suit because there's no IO a -> a.
17:20:59 <dolio> The box of apples are from Cale's monads as containers, I think.
17:21:27 <monochrom> IMO the nuclear waste story is an insider joke. You have to understand monads first before you can understand the story.
17:21:30 <Baughn> oerjan: I'd link you, but it's slashdotted. Which means that statement may well be an exaggeration.
17:21:37 <glen_quagmire> i think of monads as public final static class Monad {}
17:21:39 <oerjan> so does this mean that a comonad is like a wildlife preserve on an island in a sea of nuclear waste?
17:22:00 <roconnor> oerjan: yes!
17:22:01 <Toxaris> and if you want to replace the apples by oranges, you just cast divineProtection to enable an fruit operator to swap the fruits
17:22:03 <nibro> oerjan: rofl!
17:22:10 <roconnor> oerjan: draw it in inkscape.
17:22:14 <glen_quagmire> public final volitile agile static const class
17:22:34 <glen_quagmire> ad hoc polymorphism for the win
17:22:43 <roconnor> glen_quagmire: I'm reminded of my mutable const blog post.
17:22:49 <dolio> They should totall add the "agile" keyword to Java.
17:22:50 <monochrom> type class is a bit of ad hoc polymorphism.
17:23:07 <dolio> Bring them up to speed with Ruby and Python.
17:23:10 * Toxaris votes for a "cool" framework just for the fun of it
17:23:15 <Toxaris> hmm, cool keyword
17:23:17 <roconnor> http://r6.ca/blog/20040917T021600Z.html
17:23:18 <lambdabot> Title: mutable const
17:23:52 <glen_quagmire> is mutable C++ keyword?
17:24:03 <dmwit> I don't remember it.
17:24:45 <oerjan> Baughn: i guess if it's true it'll show up on my usual news websites soon enough
17:24:51 <glen_quagmire> c++ is so hard that it won't break like monads
17:24:52 --- mode: ChanServ set +o dons
17:24:52 <oerjan> roconnor: no thanks
17:24:57 --- topic: set to '["Haskell and the Summer of Code. Sign up!", http://hackage.haskell.org/trac/summer-of-code/wiki/SoC2008 , "The Haskell programming language" ,"http://haskell.org " ,"Paste: http://hpaste.org " ,"Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
17:25:01 --- mode: ChanServ set -o dons
17:25:21 * monochrom is of the attitude that what's so special about monads as compared to other type classes?  OK sure one monad, IO, is special because you must face it.  But the same could be said about the Integral type class and two special instances you must face, Integer and Int.
17:25:28 <roconnor> @remember oerjan so does this mean that a comonad is like a wildlife preserve on an island in a sea of nuclear waste?
17:25:28 <lambdabot> It is forever etched in my memory.
17:26:22 <dmwit> monochrom: It's special because it doesn't really have an analog in more popular languages.
17:26:23 <roconnor> The keyword mutable is used to allow a particular data member of const object to be modified.
17:27:03 <Toxaris> monochrom: because Monad is an constructor class?
17:27:11 <roconnor> if I recall correctly mutable const Node * means the pointer is mutable, but the thing it points to is const.
17:27:27 <roconnor> but it has been 4 years, and I don't really remember how to parse that.
17:27:33 <nibro> monochrom: because Monads magically make things implicit
17:27:46 <dmwit> Toxaris: Class constructor?  But so is, say, Eq?
17:27:49 <mauke> mutable is only valid for class members
17:28:01 <Toxaris> roconnor: I believe that mutable means that a member may be modified by const functions
17:28:02 <mauke> dmwit: Eq is a type class, not a constructor class
17:28:04 <nibro> monochrom: everything that goes on in Integral or Eq is totally visible to the beginner programmer
17:28:10 <oerjan> dons: syntax error in topic
17:28:15 <dmwit> mauke: Okay, I don't know the term.
17:28:29 <roconnor> Toxaris: sounds right.
17:28:36 <dons> bah
17:28:44 <mauke> dmwit: a constructor class is a class whose parameter has a kind /= *
17:28:53 <dmwit> ah
17:28:56 <Toxaris> dmwit: constructor class. class Monad (m :: * -> *) but class Eq (a :: *). the point is the added complexity of (* -> *)
17:29:09 <dmwit> Right, that is pretty special.
17:29:27 <mib_r0bxbqn0> i am building a gui using wxhaskell, kinda easy, but there is something i am having trouble with after i defined the the textarea [wrap: = WrapNone], i want to create a wordwrap feature i wrote it but it doesn't seem to be working as how it should, i was wondering if something is globally defined, can the value be edited, or does it remain the same?
17:29:28 * monochrom wants to argue but resists.  Thanks for all your comments.
17:30:21 <nibro> monochrom: in principle I agree with you, I just argue for the sake of it
17:30:23 <dmwit> mib_r0bxbqn0: Anything defined globally is immutable (i.e. the value can't be edited).
17:30:55 <dmwit> mib_r0bxbqn0: Perhaps you'd like us to take a look at it?
17:30:57 <dmwit> ?hpaste
17:30:57 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:31:05 <lispy> Gwern-away: what was different about the last patch bundle you sent me?  It applied straight away.
17:31:09 <mib_r0bxbqn0> ok
17:31:17 <lispy> Gwern-away: I'm wondering if the problem has to do with your sendmail
17:31:53 <Toxaris> understanding Monad in three simple steps: first, learn about constructor classes. second, look at class Monad source. third, look at the Monad laws.
17:32:16 <Toxaris> unfortunately, people tend to ignore steps one, two and three and just start coding right away :(
17:32:34 <monochrom> Functor is a good start.
17:32:55 <Japsu> Theory is futile! All we want is a good abuse of the do notation!
17:33:07 <monochrom> Lots of examples help.
17:33:25 <nibro> I disagree!
17:33:33 <dibblego> when I teach, I go in this order; List.map, fmap, List.flatMap/concatMap, bind, then return/unit
17:33:36 <TomMD> And code that is formally proven in Isabelle... our basic needa are abuse of 'do' and formal proofs.
17:33:41 <nibro> the best way to learn monads is to not know they are monads
17:33:52 <Japsu> We should rename Monad to Sequencer
17:33:58 <Japsu> ;P
17:34:07 <Botje> "warm fuzzy sequencer" ?
17:34:12 <nibro> ask the students how to write functions that allow a state variable to be passed around implicitly
17:34:21 <nibro> or environment variable
17:34:38 <dmwit> That was the approach that worked for me.
17:34:46 <dibblego> SequencingHelper // for the Java ninnies :)
17:34:52 <Botje> let's rename Monad to Magic and be done with it
17:34:57 <monochrom> Yeah, "you could have re-invented it" is also awesome.
17:35:00 <Japsu> Botje: yay for Magic \o/
17:35:17 <nibro> Botje: great suggestion!
17:35:18 <monochrom> (shameless plug) http://www.vex.net/~trebla/haskell/fix.xhtml
17:35:23 * Toxaris strongly agrees with "Functor is a good start."
17:35:46 <hpaste>  b pasted "text wrap" at http://hpaste.org/6516
17:35:47 <Botje> slay :: (Magic m) => Dragon -> m ()
17:36:22 <awesame> I'm not really done learning about Monads, but so far the "you could have reinvented it" thing was pretty helpful
17:36:33 <awesame> also seeing list comps, IO, and Maybe as examples
17:36:41 <monochrom> I think it's interesting that we now have Arrow available too.  Perhaps Functor -> Arrow -> Monad is a much less steeper learning curve.  You can also insert Applicative there.
17:36:49 <mauke> Sequencer sequencer = new SequenceManagerFactory(null, null, null).getSequenceManager(null, null).getInstance().getSequence(null);
17:36:55 <Botje> applicative
17:37:01 <Botje> now THERE's a candidate for magic.
17:37:07 <mib_r0bxbqn0> i posted the text i was creating dmwit (wxhaskell)
17:37:26 <Toxaris> arrow is theoretically related, but not syntactically.
17:37:39 <Toxaris> functor -> applicative -> monad seems to be the natural learning road
17:37:54 <Botje> <--Â« Â»-->
17:38:10 <Toxaris> or, more fine-grained: fmap -> return -> ap -> join/bind
17:38:17 <awesame> I think I have a pretty good grasp of do notation and list comps, but I don't really understand bind
17:38:23 <nibro> I'd go for monads first
17:38:36 <awesame> maybe I should look at it again
17:38:43 <dmwit> mib_r0bxbqn0: I assume warpW there is just a typo for wrapW?
17:38:55 <oerjan> @undo x >>= f
17:38:55 <lambdabot> x >>= f
17:38:56 <Toxaris> but it's hard to find good real-world examples of Functor-exercises
17:39:00 <oerjan> @redo x >>= f
17:39:01 <lambdabot> do { a <- x; f a}
17:39:08 <mib_r0bxbqn0> yeah sorry
17:39:12 <oerjan> awesame: ^^
17:39:23 <dmwit> mib_r0bxbqn0: Also, does that type-check?
17:39:37 * Botje goes back to hunting design patterns in some crappy code
17:39:45 <awesame> oerjan: oh, that's pretty straighforward
17:39:57 <awesame> thanks!
17:40:07 <mib_r0bxbqn0> check what?
17:40:16 <oerjan> awesame: although technically the desugaring is in the opposite direction :)
17:40:30 <dmwit> mib_r0bxbqn0: I mean, does it compile?
17:40:32 <awesame> sort of a pointfree do
17:40:46 <mauke> @. redo unpl x >>= id
17:40:46 <lambdabot> (do { a <- x; a})
17:41:06 <mauke> :-)
17:41:26 <Botje> :t (Â»=)
17:41:27 <lambdabot> Not in scope: `»='
17:41:30 <Botje> boo :(
17:41:38 <mib_r0bxbqn0> yes
17:41:39 <Toxaris> @redo x >>= \a -> f a
17:41:39 <lambdabot> do { a <- x; f a}
17:41:42 <Botje> :t let (Â»=) = (>>=) in (Â»=)
17:41:43 <Toxaris> no need for pointfree
17:41:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:41:56 <hpaste>  mib_r0bxbqn0 annotated "text wrap" with "text wrap" at http://hpaste.org/6516#a1
17:42:25 <mib_r0bxbqn0> it is not the complete... i ommitted some dew to space available
17:42:26 <mauke> > 'Ã¶'
17:42:26 <lambdabot>  Improperly terminated character constant at "'Ã¶'" (column 1)
17:43:01 <mib_r0bxbqn0> i just want my word wrap function to work
17:43:07 <EvilTerran> > head "Ã¶"
17:43:09 <lambdabot>  '\246'
17:43:52 <glen_quagmire> > head "í"
17:43:53 <lambdabot>  '\54620'
17:44:10 <Japsu> > length "í"
17:44:10 <lambdabot>  1
17:44:14 <Japsu> !
17:44:25 <oerjan> > maxBound :: Char
17:44:25 <lambdabot>  '\1114111'
17:44:32 <Japsu> wicked
17:45:12 <oerjan> there's some bug in the Language.Haskell stage lambdabot puts it through that makes unicode character constants not work
17:45:32 <Japsu> > "í"
17:45:32 <lambdabot>  "\54620"
17:45:40 <oerjan> but strings work because there it doesn't matter if it things there are more characters than there should be
17:45:47 <oerjan> *it thinks
17:45:52 <oerjan> or so i guess
17:46:08 <dmwit> mib_r0bxbqn0: I don't know much about wxHaskell, but would it be so bad to put the WrapWord in the creation function?
17:46:25 <dmwit> mib_r0bxbqn0: i.e. "sw <- textCtrlRich f [wrap := WrapWord]"?
17:47:24 <mib_r0bxbqn0> automatically haskell wraps the file what basically i want to do is unwrap
17:49:56 <hpaste>  bd_ pasted "what does this error *mean*?" at http://hpaste.org/6517
17:50:06 <bd_> ^^^ porting code from 6.6 to 6.8
17:50:31 <bd_> A pointer to the right cabal extension would be appreciated, but I'd also like to know what the error's actually saying
17:51:13 <mib_r0bxbqn0> anyways, i was thinking of building a highlighter for haskell can use a the map & filter  to  search and apply color to the resoective words
17:51:29 <Igloo> Haskell98 says that if f and g are recursive, and f has type "Foo a => ...", then g must have type "Foo a => ..." too
17:51:51 <nibro> *mutually* recursive even :-)
17:51:57 <Igloo> Sorry, yes
17:51:58 <bd_> ah, I very explicitly don't want that, I think
17:52:07 <oerjan> Igloo: where does it say that?
17:52:25 <bd_> although it's been a while since I was hacking on this, I could be wrong
17:52:45 <bd_> is there a cabal extension I can flag this with? -fglasgow-exts seems like the wrong thing to do
17:54:00 <Igloo> Does RelaxedPolyRec turn it off?
17:54:16 * bd_ tries
17:54:22 <bd_> yep, that worked
17:54:33 <bd_> the error should probably mention -XRelaxedPolyRec...
17:54:35 <oerjan> hm i thought ghc had that on by default...
17:55:51 <oerjan> maybe that's what was changed
17:56:10 <Igloo> oerjan: I don't know where it says it, OTTOMH
17:56:22 <oerjan> Igloo: i remembered it myself now
17:58:58 <oerjan> oh right it was hugs that relaxed it by default
18:05:22 <glen_quagmire> haskell doesn't have postfix syntax?  like `name` is infix
18:05:57 <Riastradh> In GHC one can define postfix operators as a pun on sections.
18:06:06 <monochrom> ghc has an extension for postfix operator, like "5 !"
18:06:13 <glen_quagmire> > 5 !
18:06:14 <lambdabot>   parse error on input `}'
18:06:27 <Riastradh> > let (!) n = product [1..n] in (n!)
18:06:28 <lambdabot>  Exception: not a number
18:06:30 <glen_quagmire> what is precedence for `name` ?
18:06:31 <resiak> > let (??) x = x * 2 in 5 ??
18:06:32 <lambdabot>  Parse error at end of input
18:06:32 <Riastradh> > let (!) n = product [1..n] in (5!)
18:06:33 <lambdabot>  120
18:06:38 <dmwit> > let (!) n = n * ((n - 1)!) in (5!)
18:06:38 <resiak> oh
18:06:43 <lambdabot> Terminated
18:06:52 <Riastradh> let factorial n = product [1..n] in (5 `factorial`)
18:06:58 <Riastradh> > let factorial n = product [1..n] in (5 `factorial`)
18:06:59 <lambdabot>  120
18:07:02 <oerjan> glen_quagmire: default infixl 9 and it can be declared like any operator
18:07:21 <glen_quagmire> oh didn't know about declaring fixity
18:07:34 <oerjan> `div` and `mod` have same as * and /, say
18:10:58 <glen_quagmire> > let f x = x + 1 in (2 `f`)
18:10:59 <lambdabot>  3
18:11:30 <dmwit> Haskell has odd edges.
18:14:45 <glen_quagmire> > let {dup s = (head s : s); add s = head s + (head (tail s)); } in ([1] `dup` `add`)
18:14:45 <lambdabot>  Parse error at "`add`..." (column 78)
18:14:54 <glen_quagmire> > let {dup s = (head s : s); add s = head s + (head (tail s)); } in (([1] `dup`) `add`)
18:14:54 <lambdabot>  2
18:16:46 <glen_quagmire> is there a known algorithm for turning a function definition like:  f a b c = ...   into SK combinators without variables?
18:16:58 <dozer> is there a neat way to convert [[1,2,3], [4,5,6]] into [[1,4],[2,5],[3,6]]?
18:17:02 <oerjan> yes, abstraction elimination
18:17:07 <glen_quagmire> thanks oerjan
18:17:15 <dolio> > transpose [[1,2,3],[4,5,6]]
18:17:15 <lambdabot>  [[1,4],[2,5],[3,6]]
18:18:05 <dozer> thx
18:20:00 <oerjan> glen_quagmire: i assume that's what @pl does, using the fact that S = ap in the (r ->) monad and also simplifying the monadic expressions
18:22:42 <edward1> @seen bos
18:22:42 <lambdabot> I saw bos leaving #haskell and #ghc 1h 34m 35s ago, and .
18:23:27 <edward1> does anyone know if bos has done much to his LLVM module since the hackage version?
18:23:45 <shapr> @seen edwardk
18:23:46 <lambdabot> I saw edwardk leaving #haskell 10h 3m 23s ago, and .
18:24:01 <shapr> hiya edward1!
18:24:09 <SamB> lispy: hmm, you were right, -dr *is* gentler
18:24:26 <shapr> SamB: For what?
18:24:33 <SamB> screen
18:24:37 <edward1> heya shapr
18:24:38 <SamB> gentler than -D -R
18:24:58 <SamB> I got home and my xterm was still there
18:27:38 <SamB> at least, I think I left screen running when I left...
18:27:43 <hpaste>  mmorrow annotated "encode/decode sets with UFDs" with "(no title)" at http://hpaste.org/6515#a5
18:30:30 <Gwern-away> lispy: stuck on 6,6? how sad. I try to feel sympathetic but I venerate the GHCgods - if it worked on 6.6 and not 6.8 surely the problem is you!
18:31:08 <Gwern-away> lispy: anyway, if you're wondering if it's my setup - did you run a diff on the twain? I've darcs sent many a time, and with very few exceptions, people don't report problems applying
18:32:05 <Gwern-away> I really find myself wondering what happened to hat. traffic on the mailing list just stops Nov 2007
18:32:18 <James_> if i want to apply filter to a list with a function that takes more than one argument, how would i do so? e.g. filter (x `mod` *element* == 0) list
18:33:04 <Excedrin> filter (\element -> x `mod` element == 0) list
18:33:34 <James_> oh of course thanks Excedrin
18:37:59 <dmwit> filter ((== 0) . mod x) list -- ;-)
18:44:16 <SamB> Gwern-away: it had a rather annoying tendancy to crash ?
18:44:58 <dmwit> And it didn't do Data.Map!
18:47:16 <hpaste>  morrow annotated "encode/decode sets with UFDs" with "refinement" at http://hpaste.org/6515#a7
18:47:57 <dmwit> Is hpaste the new IRC?
18:48:11 <dmwit> It's like a whole conversation, there!
18:48:26 <dons> heh
18:48:28 <SamB> what the heck? xterm crashes on failed X_ImageText16 requests?
18:48:39 <dons> xterm? urxvt ftw!
18:48:46 <SamB> what the heck is that opcode anyway?
18:48:56 <SamB> dons: does urxvt handle all the characters?
18:49:04 <dons> all of them, and some others.
18:49:12 <dons> that's what the 'u' in urxvt is for
18:49:39 <dmwit> No way, it can't handle Robin Hood.
18:49:43 <dmwit> He's quite a character.
18:52:43 <sm> ba da bum!
18:53:24 <Gwern-away> SamB: hat you mean? well, an annoying aspect of it wouldn't explain a complete stop in traffic - that's months of silence
18:53:41 <Gwern-away> you'd think there'd be someone at least asking about how to make it build under 6.8!
18:54:25 <Gwern-away> dons: the qthaskell guy replied. apparently his primary beef is he wnats to have qthaskell build against a copy of QT included in the haskelltarball
18:55:07 <sethk> QT is a bitch to build, so he may have a point
18:56:07 <Gwern-away> I think it would need to build only against the headers, no? that might cause problems when the qt version he's bundling along is older than the system installed QT
18:56:47 <dons> Gwern-away: oh, he's bundling QT, so needs a C++ build system, so cabal doesn't work, so hackage doesn't work he?
18:57:01 <dons> i wonder why he doesn't link against an installed qt
18:57:02 <SamB> Gwern-away: you'd think...
18:57:16 <sethk> Gwern-away, if there are mismatch problems, they will happen whether you build against the headers or the full source
18:57:22 <allbery_b> the qt situation is even more tnagled than you think
18:57:37 <Gwern-away> dons: I don't actually think it needs to build the full C++ QT library; I think thje issue is the headers
18:57:41 <allbery_b> freebsd has (had?) two separate versions of qt --- one patched for KDE
18:57:55 * Gwern-away needs to redownload qthaskell and see what he's actually bundling in the tarball on sourceforge
18:58:13 <allbery_b> I can well imagine qthaskell punting and providing its own private qt libs
18:58:42 <dons> well, it is a C++ package. i can see how that's hard.
18:59:26 <sethk> there is also qt, qt embedded, qt x11 free...
18:59:53 <allbery_b> alternatively it could be something like perl/tk which bundles a modified tk library
19:00:22 <allbery_b> (although I would hope not; perl/tk is a hack even for perl)
19:01:16 <Gwern-away> no, I think this situation is like with hsjudy - it was including an entire copy of judy because it was easier than only including the include )if you follow). I don't remember with either hsjudy or qthaskell any messages indicating the actual C sources were being compiled by cabal
19:01:23 <SamB> dons: hmm, I seem to have a choice from seveeral different rxvts... none of which is called urxvt per-se
19:01:43 <dmwit> rxvt-unicode?
19:01:44 <Gwern-away> SamB: try rxvt-unicode
19:01:54 <allbery_b> yeh, it's usually rxvt-unicode
19:04:57 <Gwern-away> no, it definitely doesn't compile QT. I tried one of the examples, and I got a linker error for qt_core - qt-core is masked on gentoo, and obviously the qtc_core/ dir provided by qthaskell didn't get used
19:08:40 <Gwern-away> next question: are there any download stats for hackage yet?
19:10:15 <thoughtpolice> couldn't he just have a C file that wraps the C++ interface and then link that in with the project instead?
19:10:26 <thoughtpolice> or am i just missing the problem entirely
19:10:28 <Gwern-away> allbery_b: wait, why would freebsd have a QT for kde, and one not? wasn't QT developed with/partially for kde?
19:11:02 <allbery_b> I didn't look cliosely, haven't used kde on freebsd for a long time (freebsd machines are all low memory)
19:11:14 <\z> so, I find myself writing yet another parser monad
19:11:24 <\z> anyone have some advice on writing test code for such a beast?
19:11:27 <allbery_b> but ISTR seeing a qt-kde port whose description said that it was somehow patched for KDE
19:11:50 <dmwit> \z: I guess the existing parser monads don't meet your requirements for some reason?
19:11:55 <roconnor> \z: do you want to be online and constant space?
19:12:02 <\z> dmwit: that's correct
19:12:23 <\z> roconnor: constant space, sure.  not sure what you mean by online.
19:12:38 <roconnor> online means that you can produce partial results with partial input.
19:12:42 <dmwit> i.e. get partial parses with partial input
19:12:43 <\z> dmwit: I took a peek at HaXML's SAX parser, and it's not a SAX parser
19:12:52 <\z> roconnor: sure.  sounds about right.
19:13:07 <roconnor> I saw a talk about this at FP dag 2008
19:13:10 <Gwern-away> 'the parser monad came in from out of the core. Right away I could see me and my trusty editor would have a rainy night - and not from getting sloshed with the boys. Mr \z? she said, I heard you were the best. Well, she was partially right - people constantly visited me to get stuff broken down (if you follow).'
19:13:25 <\z> additionally, Parsec and most other parser monads have an out-of-band concept of failure.  SAX parsing has a failure event that's part of the stream.
19:14:04 <Gwern-away> (bizarre. nano just failed to compile
19:14:35 <roconnor> \z: Doaitse Swierstra gave a talk about some student who did work on how to properly write an online constant space monadic(ish) parser
19:14:50 <James_> why is "return False" giving me a return type of "m Bool"
19:14:53 <\z> roconnor: url?
19:14:55 <dmwit> \z: I am uncertain about good testing practices here.  Maybe find some examples online of XML parse testers?
19:14:58 <roconnor> I suppose you can email him for pointers to where it will be published.
19:15:05 <Gwern-away> my gd the QT sources are *huge*. qt-core is 90 megs compressed
19:15:09 <roconnor> \z: I wish I had a URL :/
19:15:11 <dmwit> James_: Because that's its type?
19:15:11 <allbery_b> ok, looks like qt-kde is long since gone
19:15:13 <dmwit> :t return
19:15:16 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
19:15:18 <roconnor> \z: I keep hoping a link will appear.
19:15:20 <Gwern-away> James_: what else would it give you? return :: a -> m a no?
19:15:25 <Gwern-away> @type return
19:15:26 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
19:15:26 <dmwit> James_: "return" is just a function, not a keyword
19:15:28 <\z> dmwit: I have the XML conformance test suite.  I intend to test against that
19:15:44 <\z> dmwit: I'm looking for techniques for testing (a) a parser monad and (b) a specific parser using that monad
19:15:46 <allbery_b> it's been 3-4 years since I last looked
19:15:59 <Gwern-away> *91 megs compressed
19:16:03 <James_> Gwern-away: you're overestimating my level of knowledge here
19:16:07 <\z> the last parser I had to write, I wrote a test suite that compared known inputs to expected outputs
19:16:15 <\z> that was more of a regression test than a unit test
19:16:27 <Gwern-away> James_: oh, ok. a newbie y're
19:16:27 <James_> if i want a function to return a Bool, how do i do so
19:16:27 <\z> roconnor: thanks. I'll keep my eyes peeled too.  ;-)
19:16:33 <James_> yeah
19:16:38 <dmwit> James_: For the most part, functions don't need an explicit "return", just write the equation.
19:16:50 <dmwit> James_: i.e. f False = True; f True = False
19:17:08 <Gwern-away> > let foo a = if foo = 1 then True else False in foo 0
19:17:08 <lambdabot>  Parse error at "=" (column 20)
19:17:18 <Gwern-away> > let foo a = if foo == 1 then True else False in foo 0
19:17:24 <lambdabot>   add an instance declaration for (Num (t -> Bool))
19:17:24 <lambdabot>     In the expression:
19:17:24 <lambdabot>   ...
19:17:24 <\z> so, it sounds like testing parser monads is something of a holy grail...
19:17:34 <dmwit> > let foo a = a == 1 in foo 0
19:17:39 <lambdabot>  False
19:17:42 <dmwit> > let foo a = a == 1 in foo 1
19:17:42 <lambdabot>  True
19:19:07 <Gwern-away> James_: functions just return whatever is left when they've evaluated as much as they can. Sometimes they can evaluate all the way down to an atom like a number or a string, and sometimes they can only evaluate down to a function - remember your maths, where sometimes the best answer you could provide was just an algebraic expression (simplified or otherwise)
19:19:20 <Gwern-away> (if that helps)
19:19:40 <James_> right, thanks
19:19:49 <James_> and now for the cryptic error messages...
19:20:18 <Gwern-away> error messages are like the Devil - they never lie, but they don't always mean what you think they mean
19:20:25 <BMeph> James_: Welcome to Haskell (and #haskell)! To answer your question about the bool, it's gonna sound "too simple," but - to "return a value," just tell how you'd get the value, so tospeak. :)
19:20:32 <hpaste>  jsedgwick pasted "isPrime" at http://hpaste.org/6518
19:21:16 <SamB> hmm, urxvt is displaying a clipped forall...
19:21:20 <Gwern-away> jsedgwick: have you seen the endless erastosthenes's sieves in haskell? the wiki has pages on just that I think
19:21:24 <SamB> it is missing it's rightmost parts
19:21:34 <BMeph> > let foo a = if a == 1 then True else False in foo 0
19:21:34 <lambdabot>  False
19:21:59 <Toxaris> jsedgwick: did you consider using all?
19:22:12 <James_> yeah, i know those but i'm playing around with haskell and i wanted to try it that way
19:22:16 <James_> all?
19:22:21 <SamB> dons: have you used urxvt with jhc before?
19:22:23 <BMeph> Gwern-away: is the gcd one there? It's got to be inefficient, but it's succinct. :)
19:22:35 <jsnx> we don't really have sum types in haskell -- or is that what type classes are?
19:22:41 <aFlag> Has anyone here used EHC? I'm having trouble compiling it.
19:22:56 <Gwern-away> BMeph: dunno. I remember the threads, they seemed to cover every possible version, so probably
19:22:57 <scook0> jsedgwick: I think that definition would be clearer with guards instead of if
19:23:04 <Toxaris> jsedgwick: or rather any. to avoid explicit recursion ...
19:23:06 <Gwern-away> aFlag: I haven't but what's the error?
19:23:21 * Gwern-away has long wondered whather EHC could be cabalized and put on hackage
19:23:25 <Toxaris> James_: all is a nice little predefined function.
19:23:27 <Toxaris> @type all
19:23:28 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
19:23:34 <hpaste>  dmwit annotated "isPrime" with "using "any"" at http://hpaste.org/6518#a1
19:23:35 <Toxaris> > all even [2, 6, 8, 10]
19:23:36 <lambdabot>  True
19:23:38 <James_> yeah just looked it up, thx
19:23:43 <Toxaris> > all even [2, 6, 15, 8 , 10]
19:23:43 <scook0> jsnx: any datatype with multiple constructors is a sum
19:23:44 <lambdabot>  False
19:23:47 <Gwern-away> @src all
19:23:47 <lambdabot> all p =  and . map p
19:23:59 <scook0> unless you have a more specific notion of "sum" in mind
19:24:04 <Gwern-away> @src and
19:24:04 <lambdabot> and   =  foldr (&&) True
19:24:16 <scook0> Haskell doesn't have *extensible* sums
19:24:24 <Gwern-away> hm - and is defined pointlessly
19:24:49 <aFlag> Gwern-away, it's not really a problem with haskell, but rather the Makefile seems to be wrong or something
19:25:01 <Gwern-away> aFlag: ln pls
19:25:36 <jsnx> scook0: what would that be like?
19:25:37 <aFlag> http://rafb.net/p/sUMMPr98.html
19:25:38 <lambdabot> Title: Nopaste - No description
19:25:44 <shapr> @seen bos
19:25:44 <lambdabot> I saw bos leaving #haskell and #ghc 2h 37m 36s ago, and .
19:25:48 <shapr> @seen lennart
19:25:48 <lambdabot> I haven't seen lennart.
19:25:52 <shapr> @seen augustss
19:25:52 <lambdabot> I saw augustss leaving #haskell 15h 18m 50s ago, and .
19:25:53 <shapr> foo
19:25:56 <James_> dmwit: rgabjs
19:26:01 <James_> WOW
19:26:05 <James_> thanks*
19:26:09 <shapr> Has anyone here built the LLVM binding by bos?
19:26:13 <scook0> jsnx: OCaml has something called "polymorphic variants"
19:26:15 <dmwit> James_: It can get even prettier. =)
19:26:18 <shapr> edwardk: Did you get it to build?
19:26:31 <James_> dmwit: oh is that so?
19:26:44 <dmwit> Well...
19:26:53 <dmwit> I guess it depends on your aesthetics. =)
19:27:11 <Gwern-away> aFlag: interesting. your makefile is broken, it's pretty obvious the command '--module=CDoc' is an arg to is just not listed
19:28:33 <aFlag> yes
19:28:34 <EvilTerran> > map (==3) [1..5]
19:28:35 <lambdabot>  [False,False,True,False,False]
19:28:47 <aFlag> but that's all they have in their site
19:28:52 <aFlag> maybe I should e-mail them
19:28:53 <Gwern-away> aFlag: offhand, I'd do a recursive grep for '--module=CDoc' to see whether there is an unborked copy around
19:29:11 <Gwern-away> or at least something you can figure out what the program name is
19:29:28 <Toxaris> dmwit: did you tested that code?
19:29:39 <dmwit> Toxaris: No, it could easily be wrong.
19:29:47 <Toxaris> dmwit: [1..(ceiling . sqrt n)] looks doubly broken to me
19:30:00 <dmwit> huh, yeah
19:30:01 <Toxaris> it should be [2 .. ceiling $ sqrt n] i assume
19:30:16 <dmwit> ceiling . sqrt . fromIntegral $ n
19:30:30 <jsnx> scook0: oh, interesting
19:30:31 * EvilTerran shudders at the use of gratuitous floating point
19:30:32 <dmwit> I just copied that part from above.
19:30:39 <dmwit> But better would be:
19:30:43 <EvilTerran> takeWhile ((<=n).(^2)) [2..]
19:30:46 <dmwit> yeah
19:30:51 <EvilTerran> :)
19:31:03 <edwardk> shapr: the llvm stuff?
19:31:18 <James_> dmwit: so "any (`divides` n) xs" works? what if it was something like "any (n `divides`) xs"?
19:31:31 <EvilTerran> you could maybe speed it up a little by doing a binary search for the square root, but any more than that would be premature optimisation
19:31:33 <EvilTerran> James_, sure!
19:31:35 <edwardk> shapr: did you get the version from his darcs repo or just the hackage ver?
19:31:36 <EvilTerran> > (x `f`)
19:31:36 <lambdabot>  Add a type signature
19:31:39 <dmwit> James_: Well, that would be syntactically correct, but think about what it would mean.
19:31:42 <EvilTerran> > (x `f`) :: Expr
19:31:43 <lambdabot>  f x
19:31:48 <EvilTerran> > (`f` x) :: Expr
19:31:48 <lambdabot>      The section `(`f` x)' takes one argument,
19:31:48 <lambdabot>     but its type `Expr' has no...
19:31:55 <EvilTerran> > (`f` x) :: Expr -> Expr
19:31:55 <lambdabot>  <SimpleReflect.Expr -> SimpleReflect.Expr>
19:32:01 <jsnx> scook0: what i'm trying to do is define a language Composite as being made up of a list of mini-languages A, B, C... and I want to avoid making new constructors for each thing I add to the language definition
19:32:12 <EvilTerran> > (`f` x) y :: Expr -- don't worry, i'll get this eventually
19:32:12 <lambdabot>  f y x
19:32:40 <dons> huh, how long as google been doing pop-up search completion?
19:32:42 <James_> dmwit: in the case where you would want to do it in that order. just a hypothetical
19:32:55 <dmwit> James_: Yep, definitely allowed! =)
19:33:06 <jsnx> but i have not thought of a good way to do this
19:33:10 <EvilTerran> > map (`mod` 2) [1..]
19:33:10 <lambdabot>  [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0...
19:33:10 <dmwit> dons: Google suggest has been around for two yearsish.
19:33:19 <EvilTerran> > map (100 `mod`) [1..]
19:33:20 <lambdabot>  [0,0,1,0,0,4,2,4,1,0,1,4,9,2,10,4,15,10,5,0,16,12,8,4,0,22,19,16,13,10,7,4,1...
19:33:20 <Toxaris> > let isPrime n = all ((0 /=) . mod n) . takeWhile ((<= n) . join (*)) $ [2..] in map isPrime [1, 2, 3, 9, 10, 11]
19:33:21 <lambdabot>  [True,True,True,False,False,True]
19:33:30 <EvilTerran> compare
19:33:31 <jsnx> have you guys seen google's "semantic search" ?
19:33:35 <cjb> nope
19:33:37 <jsnx> try
19:33:37 <dons> dmwit: the little popup thing on the front page?
19:33:38 <jsnx> phone
19:33:40 <jsnx> and then
19:33:42 <dons> dmwit: javascript et al?
19:33:43 <hpaste>  morrow annotated "encode/decode sets with UFDs" with "(union,intersect,\\) -> (lcm,gcd,div)" at http://hpaste.org/6515#a8
19:33:43 <jsnx> ~phone
19:33:48 <EvilTerran> Toxaris, "join (*)"? surely (^2) is neater...
19:33:48 <jsnx> very different results
19:33:51 <dmwit> dons: Yes, it's supposed to be opt-in.
19:33:53 <scook0> jsnx: perhaps http://www.cs.nott.ac.uk/~wss/Publications/DataTypesALaCarte.pdf might be of interest
19:34:00 <dons> ah , so its on by default now, or some such
19:34:09 <James_> alright, this is crazy talk
19:34:11 <dmwit> dons: i.e. the thing with suggestions and hit-counts for each?
19:34:14 <dons> "has" and "haskell" makes the top 10 :)
19:34:16 <dons> dmwit: yep
19:34:19 <dmwit> =)
19:34:34 <EvilTerran> James_, (x `foo`) = foo x, always
19:34:41 <dons> so i don't think that was on by default, on the anonymous front page, this morning..
19:34:47 <EvilTerran> and (`foo` y) = flip foo y
19:34:54 <EvilTerran> ?src flip
19:34:54 <lambdabot> flip f x y = f y x
19:34:59 <James_> explain what is wrong w/ "[1..(ceiling . sqrt n)]"?
19:35:00 <dmwit> jsnx: link?
19:35:06 <dmwit> James_: A couple things.
19:35:19 <Toxaris> James_: first of all, it should be 2 .. because *every* number is divisable by 1, including prime numbers
19:35:21 <dmwit> James_: First, function application binds tighter than anything else.
19:35:37 <James_> oh yeah, 2, sure
19:35:40 <Japsu> oh no, ceiling cat is watching me unsafePerformIO!
19:35:42 <EvilTerran> that's "ceiling . (sqrt n)" on the right there
19:35:52 <dmwit> James_: so (ceiling . sqrt n) parses as (ceiling . (sqrt n)), which tries to compose ceiling with the non-function (sqrt n).
19:36:33 <dmwit> James_: The next thing that's wrong is that this makes "n" get inferred to be a Floating value, so that sqrt can work on it, when you probably want it to be an Integral type.
19:36:44 <dmwit> James_: (Haskell requires explicit casts for these things.)
19:36:57 <EvilTerran> âcatâ?
19:37:11 <dmwit> James_: The other thing that's wrong is that you have extra parentheses. ;-)
19:37:12 * scook0 golfclaps
19:37:20 <dmwit> EvilTerran++
19:37:49 <James_> dunno why i put one, kinda arbitrary. as for the other stuff, give me a second...
19:37:50 <dmwit> James_: As a bonus, what you really want to do is stay in Integral the entire time, rather than converting in and out of Floating.
19:37:55 <jsnx> scook0: thanks
19:38:04 <jsnx> dmwit: i don't think it's documented anywhere
19:38:21 <jsnx> just put a ~ in front of something to do the semantic search
19:38:23 <dmwit> James_: So, something like (takeWhile (\x -> x * x <= n) [2..]) would be a better way.
19:38:41 * EvilTerran grins like a loon
19:38:48 <Gwern-away> hm. ehc requires uulib and uuagc - which are already cabalized. excellent
19:38:56 <James_> dmwit: your babies, i want them.
19:39:06 <EvilTerran> O.o
19:39:12 <dmwit> ;^^
19:39:21 <dmwit> Haskell's babies, you want them. =)
19:39:24 <Gwern-away> aFlag: incidentally, were you using EHC out of svn?
19:40:03 <Gwern-away> curried babies, they has a flavor
19:40:10 <shapr> Gwern-away: Are you really away?
19:40:18 <EvilTerran> eheheh
19:40:26 <monochrom> lambda babes?
19:40:32 <Gwern-away> shapr: I'm high as a kite
19:40:46 <shapr> ah
19:40:49 <monochrom> I'm free as softwrae
19:40:50 <shapr> Too much lambda lifting?
19:40:55 <Toxaris> > fix (\primes -> filter (\n -> all ((0 /=) . mod n) . takeWhile ((<= n) . (^ 2)) $ primes) [2..])
19:40:56 <Gwern-away> and it'll be a long long time, till touch down brings me round to find - I'm not as pure as they think I am - oh no, no no unsafeperformIO!
19:40:56 <lambdabot>  Exception: <<loop>>
19:41:00 <Toxaris> :(
19:41:29 <EvilTerran> Toxaris, i think you need to give that one 1
19:41:41 <EvilTerran> > fix (\primes -> (1 :) . filter (\n -> all ((0 /=) . mod n) . takeWhile ((<= n) . (^ 2)) $ primes) [2..])
19:41:42 <lambdabot>   add an instance declaration for (Integral [t])
19:41:47 <EvilTerran> ups
19:41:54 <shapr> edwardk: I got the version from the repo, can't build it.
19:42:04 <EvilTerran> nvm, ignore me, i'm thinking of something else entirely
19:42:13 <shapr> edwardk: Seems to be missing LLVM/ExecutionEngine.hs
19:42:45 <edwardk> likewise
19:42:58 * shapr tries the hackage version
19:43:09 <EvilTerran> > map head $ iterate (\x:xs -> filter ((/=0).(`mod`x)) xs) [2..]
19:43:09 <lambdabot>  Parse error at ":xs" (column 23)
19:43:17 <shapr> edwardk: hackage version explodes also.
19:43:24 <EvilTerran> > map head $ iterate (\(x:xs) -> filter ((/=0).(`mod`x)) xs) [2..] -- "bother", said eeyore
19:43:25 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
19:43:27 * shapr sighs
19:43:37 <Toxaris> EvilTerran: you are right, 2 can not be proven to be prime, because the first prime is not known to be > 4
19:43:53 <Toxaris> > fix (\primes -> 2 : filter (\n -> all ((0 /=) . mod n) . takeWhile ((<= n) . (^ 2)) $ primes) [3..])
19:43:54 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
19:44:24 <EvilTerran> there we go. that's surprisingly close to what i was trying to do, actually. :)
19:44:25 <monochrom>   @remember Toxaris 2 can not be proven to be prime
19:44:27 * monochrom ducks
19:44:55 <Toxaris> > fix ((2 :) . filter (\n -> all ((0 /=) . mod n) . takeWhile ((<= n) . (^ 2))) [3..])
19:44:56 <lambdabot>  Couldn't match expected type `Bool'
19:45:06 <EvilTerran> i think the problem is it needs to get 2 out of the list and see that it's too big before it can be done with the takeWhile
19:45:11 <dmwit> monochrom: So, did you put a prime number of spaces in front of your @remember, or not?
19:45:34 <Gwern-away> why can't 2 be proven prime? someting is prime if it isn't divisble by anything but 1 or itself, no, and 2 would seem to meet the criterion
19:45:36 <Toxaris> EvilTerran: yeah something like this was what i tried to express ...
19:45:42 <monochrom> haha
19:45:58 <EvilTerran> for working out if N is prime, you need an I s.t. ceil(sqrt(n)) <= i < n, i think
19:45:58 <dmwit> Gwern-away: Given the axioms in the fix statement above.
19:46:01 <edwardk> shapr: yeah =/
19:46:31 <EvilTerran> with that method. and, by "you", i mean the run-time system.
19:46:34 <dmwit> Gwern-away: We're given only that primes are those numbers that are non-zero mod all of their predecessor primes... but not which integer is the first prime.
19:46:46 <Gwern-away> no base case?
19:46:51 <dmwit> Gwern-away: right
19:46:56 <EvilTerran> ish
19:47:22 <monochrom> It is a crime to provide no base case. :)
19:47:24 <Toxaris> Gwern-away: ... by my particular and badly designed prime test function ...
19:47:34 <EvilTerran> the problem is it only stops getting primes to check for divisibility when it reaches the square-root of the number you're checking or it finds a divisor
19:47:43 * Gwern-away thinks I understand now
19:47:48 <Toxaris> monochrom: it's a co-crime to provide one
19:48:09 <BMeph> > nubBy (((>1).).gcd) [2..]
19:48:10 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
19:48:11 <EvilTerran> so requiring that the algorithm find 2 itself results in an infinite loop
19:48:23 <BMeph> I love that formula... :)
19:48:25 <EvilTerran> as there's no integers in [sqrt(2)..2)
19:48:28 <Toxaris> BMeph: nice one!
19:48:41 * Gwern-away wonders just how many versions EHC goes through before it reaches the final full blown ehc. it's compiled quite a bit so far
19:48:49 <EvilTerran> > nubBy ((/=0).flip mod) [2..]
19:48:49 <lambdabot>  Couldn't match expected type `a -> Bool'
19:48:56 <BMeph> Toxaris: I got it from oerjan, who got it from somewhere else. :)
19:48:58 <EvilTerran> > nubBy (((/=0).).flip mod) [2..]
19:49:02 <lambdabot> Terminated
19:49:18 <EvilTerran> > nubBy (((==0).).flip mod) [2..] -- i'm asleep here
19:49:19 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
19:49:21 <dmwit> I invented that one, though probably somebody has invented before me.
19:49:25 <EvilTerran> i prefer that one
19:49:37 <EvilTerran> when i can remember it ;)
19:49:42 <dmwit> =)
19:50:05 <glen_quagmire> :t ((==0).)
19:50:06 <lambdabot> forall a (f :: * -> *). (Functor f, Num a) => f a -> f Bool
19:50:13 <dmwit> It's back!
19:50:17 <dmwit> <3
19:50:26 <dmwit> :t (++)
19:50:27 <lambdabot> forall m. (Monoid m) => m -> m -> m
19:50:31 <dmwit> yaaaay
19:50:33 * Toxaris has never used nubBy
19:50:34 <dibblego> ?type (.)
19:50:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:50:44 <glen_quagmire> isn't ++ concatenation?
19:50:52 <dibblego> yes
19:50:59 <dibblego> who generalised all the lambdabot function types?
19:51:02 <EvilTerran> it's mappend. Cale's been playing tricks, iirc.
19:51:14 <dibblego> oh of course, Cale
19:51:25 <glen_quagmire> teach me monoid
19:51:27 <EvilTerran> "of course" :P
19:51:52 <Gwern-away> that lovable scamp
19:51:52 <Toxaris> @src Monoid
19:51:53 <lambdabot> class Monoid a where
19:51:53 <lambdabot>     mempty  :: a
19:51:53 <lambdabot>     mappend :: a -> a -> a
19:51:53 <lambdabot>     mconcat :: [a] -> a
19:52:00 <dibblego> glen_quagmire, Monoid is mappend and mempty, has left and right identity and associativity
19:52:23 <glen_quagmire> > mempty 1
19:52:23 <dibblego> ?check \m -> m `mappend` mzero == m
19:52:23 <lambdabot>  ()
19:52:24 <lambdabot>        add an instance declaration for (Eq (m a), Monoid (m a))
19:52:37 <dibblego> ?check \m -> m `mappend` mzero == (m :: [Int])
19:52:38 <lambdabot>  OK, passed 500 tests.
19:52:47 <dibblego> ?check \m -> m `mappend` mzero == (m :: [Int]) -- left identity
19:52:48 <lambdabot>  OK, passed 500 tests.
19:52:56 <Toxaris> > (mempty :: [Int], mempty :: Maybe Bool, mempty :: Bool) -- some examples
19:52:57 <lambdabot>   add an instance declaration for (Monoid Bool)
19:52:57 <lambdabot>     In the expression: mempty...
19:52:57 <hpaste>  solrize pasted "this seems like it should use the state monad... but i'm not sure how." at http://hpaste.org/6519
19:52:58 <dibblego> ?check \m -> mzero `mappend` m == (m :: [Int]) -- right identity
19:52:58 <lambdabot>  OK, passed 500 tests.
19:53:09 <Toxaris> > (mempty :: [Int], mempty :: Maybe Bool, mempty :: Sum Int) -- some examples
19:53:09 <lambdabot>   add an instance declaration for (Monoid Bool)
19:53:09 <lambdabot>     In the expression: mempty...
19:53:12 <Toxaris> :(
19:53:24 <Toxaris> > (mempty :: [Int], mempty :: Sum Int) -- some hopefully finally working examples
19:53:25 <lambdabot>  ([],Sum {getSum = 0})
19:53:28 <lispy> Gwern-away: it's not actually me, it's that they rewrote the GADT type checking for 6.8 and some quite reasonable cases that unify under 6.6 don't unify the same way under 6.8.  And GHC HQ has said that it will be rewritten again for 6.10, so I think we're skipping 6.8.
19:53:39 <dibblego> ?check \m n o -> (m `mappend` n) `mappend` o == m `mappend` (n `mappend` o) -- associativity
19:53:39 <lambdabot>  OK, passed 500 tests.
19:54:04 <dibblego> that completes the monoid teaching session
19:54:08 <scook0> > (mempty :: All, mempty :: Any)
19:54:08 <lambdabot>  (All {getAll = True},Any {getAny = False})
19:54:21 <lispy> Gwern-away: as for the darcs patches, it's weird.  I've not had problems with patches that arrived via gmail before
19:54:57 <scook0> @instances Monoid
19:54:57 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
19:54:59 <dmwit> > mempty :: Maybe ([Int], Product Int)
19:55:00 <lambdabot>  Nothing
19:55:14 <Gwern-away> lispy: we?
19:55:26 <lispy> Gwern-away: darcs
19:55:35 <scook0> > fmap ((+1) `mappend` (*2)) [1..3]
19:55:35 <lambdabot>  Add a type signature
19:55:39 <scook0> > map ((+1) `mappend` (*2)) [1..3]
19:55:39 <lambdabot>  Add a type signature
19:55:46 <lispy> Gwern-away: darcs compiles with 6.8, but the type witness stuff does not
19:55:58 <Gwern-away> aFlag: I just finished compiling EHC. I didn't hit any makefile problems. were you going through svnand following the instructions on the web?
19:56:09 <lispy> what is EHC?
19:56:22 <Gwern-away> lispy: oh. is the type witness stuff important?
19:56:37 <dmwit> solrize: Sounds like State Int to me.
19:56:48 <scook0> > appEndo (Endo (+1) `mappend` Endo (*2)) 6
19:56:49 <lambdabot>  13
19:57:07 <solrize> dmwit yes i'm just having a hard time finding a good description of how to write it that way
19:57:16 <Gwern-away> lispy: the Extensible Haskell Compiler; it's a bunch of packages going from a very very simple polymorph calc compiler to what claims to be a full haskell '98 compiler
19:57:18 <dmwit> solrize: Hold up half a tick.
19:57:23 <solrize> dmwit thanks
19:57:39 <solrize> EHC sounds cool
19:57:47 <Gwern-away> @where ehc
19:57:48 <lambdabot> I know nothing about ehc.
19:57:56 <Gwern-away> @where+ ehc http://www.cs.uu.nl/wiki/bin/view/Ehc/WebHome
19:57:56 <lambdabot> I will remember.
19:58:16 <cjs> Perhaps someone can give me some suggestions on the best way to deal with some time calculations. I have options with a specific maturity date and time (e.g., 3:10 p.m. on the third Thursday of every month), and I need to calculate a time to maturity (i.e., difference between the maturity time and the current time) when valuing the option. It only needs to be accurate down to a minute or so, but gets complex, becuase while for the moment I can jus
19:58:16 <cjs> t use the exact difference, later we're going to want to modify it based on which markets are open when. Though I probably shouldn't bother thinking about that complication right now....
19:59:24 <dibblego> ?type ap
19:59:25 <lispy> Gwern-away: yes, very important.  It's how we ensure that internally darcs only does patch manipulations that are valid
19:59:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
19:59:36 <solrize> cjs sec
20:00:31 <Gwern-away> lispy: so how is darcs working with 6.8 then? CPP directives?
20:01:09 <lispy> Gwern-away: right
20:01:10 <hpaste>  dmwit annotated "this seems like it should use the state monad... but i'm not sure how." with "one possible way to use State" at http://hpaste.org/6519#a1
20:01:25 <solrize> cjs it looks like you have to write the messy logic of "third thirsday of the month" using System.Time
20:01:36 <lispy> Gwern-away: not enough of darcs has been converted to type witness code to make it the default anyway
20:01:43 <dmwit> solrize: You might also want to put the map into the state, depending on what you are really doing in the big picture.
20:01:46 <hpaste>  Toxaris annotated "this seems like it should use the state monad... but i'm not sure how." with "transformed to State monad" at http://hpaste.org/6519#a2
20:02:13 <dmwit> solrize: Toxaris has shown how to do that version. =)
20:02:35 <solrize> the brute force way is just count forward minute by minute, mapping through toCalendarTime until you get a CalendarTime that has the characteristics you want
20:02:43 <solrize> dmwit, toxaris -- thanks
20:03:02 <Toxaris> solve Toxaris `par` solve dmwit `par` continue chatting
20:03:03 <solrize> looking
20:03:18 <dmwit> heh
20:03:49 <Gwern-away> chatting requires IO, so par wouldnae work
20:04:56 <dmwit> solrize: Oh, sorry, I didn't see the "serial" function.
20:05:08 <Toxaris> > zip [1..] . nub $ ["alice", "bob", "dave", "alice", "charlie", "bob"]
20:05:09 <lambdabot>  [(1,"alice"),(2,"bob"),(3,"dave"),(4,"charlie")]
20:05:22 <Taggnostr> hello
20:05:29 <solrize> > nub [6,1,2,6,2,3,1,7]
20:05:30 <lambdabot>  [6,1,2,3,7]
20:05:36 <dmwit> solrize: Maybe I'll leave that as an exercise to the reader. ;-)
20:05:44 <dmwit> Taggnostr: Hiya!
20:05:47 <cjb> is it bad form to use an infinite list as your zip argument when you could easily calculate the length needed?
20:06:02 <cjb> ie. does it create more thunks or require more work or anything like that?
20:06:04 <SamB> cjb: no
20:06:08 <SamB> it's not bad form
20:06:08 <Toxaris> cjb: i would consider it good form
20:06:17 <SamB> it saves everyone work
20:06:36 <cjb> ok :)
20:06:37 <SamB> (you, me, the compiler ... your dog ...)
20:06:38 <solrize> dmwit, yeah, i think i need to use something like state for this, the idea is that the input list is coming from a socket and is enormous and i don't want to keep it all in memory.
20:06:48 <cjb> that's cool.  I just freaked out a little at seeing the infinite list.  I bet it passes.
20:06:53 <Taggnostr> how is haskell?
20:07:06 <cjb> It's like seeing a while(1) { } loop in the middle of a block of C code.
20:07:07 <solrize> taggnostr, the answer is: yes, haskell can do that ;)
20:07:23 <Toxaris> cjb: it's lazier. consider take 1 . zip [1..] . [1..100000000]. no need to calculate the length of the list if we only want 1 element anyway
20:07:30 <roconnor> @faq how is haskell?
20:07:30 <lambdabot> The answer is: Yes! Haskell can do that.
20:07:38 <dmwit> i = 10; while(i --> 0) { printf("%d", i); }
20:07:43 <cjb> Toxaris: sure, I understand that.
20:07:44 <roconnor> @vixen how is Haskell?
20:07:44 <lambdabot> church is my favourite computer scientist.
20:07:53 <roconnor> *L*
20:08:04 <solrize> @src nub
20:08:04 <lambdabot> nub = nubBy (==)
20:08:08 <solrize> @src nubBy
20:08:08 <lambdabot> nubBy eq []             =  []
20:08:08 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
20:08:15 <Toxaris> cjb: so you can't *easily* calculate the length of the list in the general case.
20:08:33 <Taggnostr> I don't know why I'm here, but it seems a nice place
20:08:45 <solrize> omg, nub uses n**2 space and n**3 time ?
20:08:49 <dmwit> Taggnostr: Are you interested in learning Haskell?
20:09:00 <dmwit> solrize: n^2 time, I think.
20:09:03 <lispy> solrize: wait, n^3 time?
20:09:11 <Taggnostr> not really, just curious
20:09:16 <lispy> solrize: but, yeah nub is very slow
20:09:17 <dmwit> solrize: ...and O(n) space.
20:09:18 <solrize> hmm n**2 time
20:09:37 <solrize> and n**1 space
20:09:38 <lispy> solrize: it would have to require Ord instead of Eq if it wanted to go faster
20:09:44 <dmwit> solrize: But you can do something like (S.toList . S.fromList) if you don't need laziness and speed is an issue.
20:10:05 <solrize> S.toList ?
20:10:12 <solrize> what's S?
20:10:15 <dmwit> S = Data.Set
20:10:19 <solrize> oh
20:10:38 <solrize> hmm
20:10:42 <scook0> also, the Set version isn't order-preserving
20:10:56 <scook0> which might occasionally be an issue
20:10:59 <dmwit> true
20:11:01 <solrize> i think i don't care about order preservation, i'm going to end up sorting the output on disk
20:11:20 <cjs> solrize: sounds a bit painful. But I do know the actual dates, e.g. "2008-03-20T15:10", so I don't actually need to do the "third thursday of the month" part.
20:11:39 <cjs> I guess maybe I should just parse it into a System.Time type thing, and diff seconds....
20:11:43 <scook0> Data.Set.toList is sorted, iirc
20:11:45 <dmwit> cjs: Oh, great, then Data.Time might be just the thing.
20:11:50 <solrize> cjs, yeah
20:12:04 <dmwit> cjs: Data.Time has parsing functions ready-made (dunno if System.Time does).
20:12:39 <solrize> scook0 if i get really ambitious i might be able to use hsjudy to store the set as a bitmap.  hmm.
20:12:52 <cjs> Data.Time. yeah, I was mucking about with it the other day.
20:13:10 <cjs> Ok, I'll go back and muck some more, and then come back for opinions.
20:13:20 <Toxaris> > mapAccumR (\s x -> if S.member x s then (s, Nothing) else (S.insert x s, Just x)) S.empty ["alice", "bob", "dave", "alice", "charlie", "bob"]
20:13:21 <lambdabot>  (fromList ["alice","bob","charlie","dave"],[Nothing,Nothing,Just "dave",Just...
20:13:28 <scook0> solrize: as long as you don't mind the IO
20:13:38 <oerjan> ooh, mapAccumR
20:13:44 <cjs> (Grr. I hate that point in learning a new language where you end up in massive battles with the compiler over silly bits of syntax. Haskell seems particularly prone to this.)
20:14:07 <sethk> cjs, not so much prone, as the error messages can be difficult to interpret
20:14:23 <Taggnostr> is haskell compiled, interpreted or both?
20:14:23 <solrize> scook0 yeah i guess that's ok.
20:14:24 <Toxaris> > flip zip [1..] . catMaybes . snd . mapAccumR (\s x -> if S.member x s then (s, Nothing) else (S.insert x s, Just x)) S.empty $ ["alice", "bob", "dave", "alice", "charlie", "bob"]
20:14:24 <lambdabot>  [("dave",1),("alice",2),("charlie",3),("bob",4)]
20:14:35 <scook0> Taggnostr: both
20:14:44 <solrize> cjs, my biggest obstacle is that i think of a problem and immediately see the solution in terms of mutating state
20:14:48 <cjs> There is that, yes, but there are other things that are very Haskellish that get you. Like functions polymorphic over only the return type.
20:14:52 <sethk> Taggnostr, both.  ghci is an interpreter
20:14:54 <solrize> and i have to turn my brain sideways to functionalize it
20:14:58 <sethk> Taggnostr, ghc compiles to binary
20:14:59 <scook0> the most popular implementation, GHC, has both a native-code compiler and an interactive interpreter
20:15:08 <Toxaris> is ghci an interpreter?
20:15:15 <Toxaris> i thought it would compile expression-wise
20:15:17 <sethk> Toxaris, yes
20:15:20 <Taggnostr> ok, thanks
20:15:21 <cjs> solrize: heh. I have the opposite problem with ruby.
20:15:32 <sethk> Toxaris, well, it compiles to an intermediate form, but all interpreters do that
20:15:37 <scook0> Toxaris: these days the word "interpreter" is usually not taken completely literally
20:15:41 <cjs> solrize: BTW, read _The Little Schemer_ if you've not already. It helps a lot with that.
20:16:05 <solrize> cjs i've seen that book and it's nice, i don't have a personal copy
20:16:31 <cjs> I cannot recommend anything more highly.
20:16:32 <scook0> unless you're suggesting that GHCi compiles each statement to machine code, which it doesn't
20:16:46 <solrize> cjs maybe i'll send away for it, thanks
20:16:57 <cjs> It gets into some pretty darn serious stuff as you get towards the end, too. It looks like you're doing simple stuff, but you're not.
20:17:05 <solrize> i wish there was a "haskell in a nutshell" type of book, that explained all the library functions and how to use them
20:17:27 <cjs> Kinda the way that the parser chapter of Hutton's book makes you suddenly realize you understand monads.
20:17:45 <cjs> Yeah, and the syntax, too. The Report is not the best way to figure out syntax.
20:18:10 <solrize> i should get hold of hutton's book too.  i looked at it in the bookstore but it didn't seem to go into enough detail
20:18:32 <cjs> It's a lot better than it looks at first glance, though it doesn't go nearly as far as Hudak's book.
20:18:35 <solrize> i think i'm dealing with the syntax ok.  i can even understand ghc's error messages, enough to figure out where the problem is
20:18:55 <cjs> Yeah, I'm definitely good with interpreting the line number and character location. :-/
20:19:16 <solrize> hudak's book was very introductory i thought.  there are a whole mess of idioms and shortcuts to haskell, that are brand new to me, and hudak's book was not that much help with them
20:19:27 <solrize> like this thing with the state monad for example
20:19:49 <xelxebar> Has anyone here taken a look at the Haskell finger tree implementation?
20:20:58 <solrize> i haven't.  is it something like a tree with a zipper ?
20:21:18 <solrize> i've been reading about zippers and my brain is exploding ;-)
20:21:59 <solrize> @seen conal
20:21:59 <lambdabot> conal is in #haskell and #ghc. I don't know when conal last spoke.
20:23:22 <conal> solrize: yo
20:23:53 <solrize> hey conal i was looking at your page about zippers and it's awesome
20:24:22 <solrize> i was wondering if there's an "antiderivative" of an arbitrary datatype, that means anything
20:24:31 <conal> solrize: ?? page about zippers?  which page?  oh!  conor
20:24:36 <solrize> oh, sorry
20:24:42 <solrize> @seen conor
20:24:42 <lambdabot> I haven't seen conor.
20:24:43 <conal> np
20:24:45 <solrize> :)
20:24:54 <solrize> oops
20:25:01 <oerjan> @seen connor
20:25:01 <lambdabot> I haven't seen connor.
20:25:01 <solrize> <blush>
20:25:07 <oerjan> hm
20:25:12 <Taggnostr> which page?
20:25:12 <conal> conor does cool stuff
20:26:21 <solrize> lemme see if i can find the page again
20:27:36 <solrize> taggnostr, http://strictlypositive.org/calculus/
20:27:37 <lambdabot> Title: Differential Calculus with Datatypes
20:28:45 <Taggnostr> thanks
20:28:50 <solrize> i also want to understand oleg's zipper, which works differently
20:29:30 <solrize> taggnostr, see also: http://en.wikibooks.org/wiki/Haskell/Zippers#Differentiation_of_data_types
20:29:31 <lambdabot> http://tinyurl.com/3cauba
20:29:54 <dmwit> "I collect one-hole contexts in strings which always yield words when a vowel is plugged in the hole. Examples (in various dialects of English) include b.g, b.ll, b.t, d.ll, d.n, d.ne, g.t, h.m, h.t, l.g, m.te, n.t, p.t, t.t, w.n"
20:31:41 <Taggnostr> I can't understand it, but it seems cool
20:31:42 <Gwern-away> hm. mate, mite, mute, mete... huh
20:31:57 <Gwern-away> good thing 'y' is only a semi-vowel eh as 'myte' doesn't work
20:32:01 <solrize> taggnostr, i don't  understand it either, but it's mind boggling
20:32:17 <allbery_b> you missed mote
20:32:37 <Gwern-away> allbery_b: hence the ellipsis
20:33:09 <allbery_b> ...of course, if you know Hebrew or Arabic this is kind of amusing (because that's more or less how *all* Hebrew and Arabic words are formed)
20:39:09 <solrize> so is there much use for a functional wrapper of zlib?  i.e. i want to be able to write a compression function for short english strings, so (f "George Washington") is maybe a 5 or 6 character string.  the idea is that f would wrap a frozen state of zlib initialized from some text corpus.
20:39:43 <Gwern-away> solrize: don't we already have binding to zlib?
20:39:57 <Gwern-away> if you're going to work on zlib, just do one in haskell
20:40:03 <solrize> gwern, checking
20:40:26 <solrize> write a whole new compressor in haskell?  i guess that could be ok speedwise.
20:40:35 <Gwern-away> 'zlib [0.2, 0.3, 0.4, 0.4.0.1, 0.4.0.2, 0.4.0.3, 0.4.0.4] Compression and decompression in the gzip and zlib formats'
20:40:51 <solrize> where's that from?
20:41:15 <Gwern-away> solrize: 'cabal list'
20:41:32 <solrize> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib-0.4.0.4
20:41:36 <lambdabot> http://tinyurl.com/2yr4xl
20:42:20 <solrize> gwern i want to freeze the internal state of the compressor so i can use it on lots of different short strings
20:42:41 <solrize> sort of like currying it with "war and peace" :)
20:42:52 <Gwern-away> zlib as a continuation?
20:42:56 <Gwern-away> mindboggling
20:43:04 <solrize> hmm, yeah, continuation
20:43:32 <dmwit> ?go gzip quine
20:43:34 <lambdabot> http://groups.google.com/group/comp.compression/browse_thread/thread/c57c322e15c782aa/350d9fb166fdf11f
20:43:34 <lambdabot> Title: gzip decompression quine - comp.compression | Google Groups
20:43:36 <solrize> yeah, maybe it's better to do that in haskell with a functional data structure
20:44:30 <solrize> wow that quine looks cool
20:46:01 <dibblego> can a function be exported only to specific modules?
20:46:13 <dmwit> newp
20:48:29 <bd_> solrize: the site's down thogh :/
20:49:16 <solrize> the site about that quine?   yeah i noticed that, but i figure i can understand the quine if i look at the gzip format docs enough.  i looked at them a while back but didn't realize the format was that flexible
20:49:20 <cjb> are there any gtk2hs Haskell REPLs, with syntax highlighting?
20:49:27 <cjb> 'cause, that seems like it would be fun.
20:49:35 <bd_> ah, http://www.maximumcompression.com/selfgz.gz
20:49:39 <cjb> rather, a gtk2hs frontend to ghci.
20:49:59 <dmwit> ?go leskah
20:50:00 <lambdabot> No Result Found.
20:50:25 <dmwit> oh
20:50:29 <dmwit> ?go leksah
20:50:30 <lambdabot> http://code.haskell.org/leksah/
20:50:30 <lambdabot> Title: Index of /leksah
20:50:39 <cjb> well, that's an IDE, not an interactive REPL.
20:50:43 <dmwit> right
20:51:17 <cjb> I was thinking specifically that, while I fire up ghci a lot, I'd probably prefer to fire up gtk-ghci, where I get syntax highlighting and multi-line editing and so on.
20:51:26 <cjs> Isn't the one in codecs a pure haskell gzip?
20:51:29 <dmwit> aha
20:52:15 <dons> cjs: the good one is using libz
20:52:20 <dons> the nice lazy bytestring one
20:52:36 <cjb> cjs: hey, you're not allowed to talk at the same time I am, it's too confusing.
20:54:12 <cjs> Makes no difference; I'm always confused anyway.
20:55:18 <cjb> hm, Yhc has something called GuiGtk.
20:55:54 <dibblego> in Scala, import foo.{Bar, Baz} is equivalent to import foo.Bar; import foo.Baz; is there a Haskell equivalent?
20:56:30 <oerjan> no, different module names have no connection
20:56:37 <allbery_b> the code for ghci seems to have some support for a gtk frontend
20:56:53 <allbery_b> not that I've ever tried to build it, for all I know it's bitrotted
20:58:47 <cjs> Hm. Build system issue: my build system compiles an entirely library, including several modules that contain programs, and then I generate a handful of binaries using the --main-is flag to run the correct main for any particular one. However, I'd sometimes like to run these using runghc, but "runghc -main-is Ht Ht.hs" tells me it can't find main, and with -v, it seems not to be searching for it in the Ht module. Thoughts?
21:01:04 <cjb> allbery_b: hm, got a path/pointer to that?
21:03:12 <Saizan> cjs: do you need the module headers?
21:03:47 <cjs> You mean, take out the "module Hs where" entirely?
21:04:14 <Saizan> yeah, that's a workaround
21:04:31 <bd_> What's the Right Way to have cabal invoke an external script to generate (and build into the program) a haskell source file?
21:04:46 <bd_> Ideally I'd only want to regenerate this file when certain input files change too.
21:05:04 <cjs> I wonder how my overall --make compile will deal with that?
21:05:50 <Saizan> cjs: well if you use those modules in the library you can't remove the header
21:06:14 <Saizan> bd_: mmh, maybe look at how you add a custom preprocessor from Setup.hs ?
21:06:58 <cjs> If I take out the header, it compiles it as module Main. The issue there is that, since there are several of these modules that I run, if more than one compiles as Main, they all compile to Main.hs/Main.o, and overwrite each other.
21:07:24 <cjs> I could change the build system to work differently for "Main" programs, I suppose.
21:07:34 <bd_> Saizan: hm?
21:07:53 <cjs> But I kinda like being able to stick a main = in almost anything with useful little test routines or whatever.
21:07:58 <Saizan> cjs: which build system? ghc by default use the file name for .hi and .o
21:08:55 <Saizan> cjs: you should file a feature request on the bug tracker, i guess
21:10:37 <dibblego> can a cabal property value span multiple lines?
21:11:07 <dibblego> looks like it can :)
21:11:42 <Saizan> bd_: cabal can run some preprocessors for you, your problem seemed related
21:12:40 <bos> here's an interesting fact about the term "redex".  it's not just a reducible expression, it's also the name of a company that manufactures a product named "udder cream".
21:13:06 <oerjan> udderly weird
21:13:27 <cjs> It's a custom build system (http://www.starling-software.com/qam.html).
21:13:38 <bd_> Saizan: mmm, it's kind of special purpose though - I intend to embed a datafile into the program as a String
21:13:39 <cjs> Thus, I can change it to do whatever is the right thing.
21:14:15 <cjs> So you think that "runghc --main-is Xx" is a bug?
21:15:11 <cjb> shapr: ping
21:15:44 <Saizan> cjs: well i think it's not unreasonable to ask runghc to consider -main-is
21:16:34 <cjs> Hm. Ok, if you think it's a bug, I can file it.
21:17:19 <Saizan> bd_: well you can add your own preprocessor using hooks inside the Setup.hs script, or you could use TH instead to load the file and splice the String in a module at compile-time
21:17:36 <Saizan> cjs: more a feature request maybe
21:18:20 <shapr> cjb: pong
21:18:32 <oerjan> cjs: the user manual section on -main-is implies there might be trouble if the files are actually compiled with a different -main-is setting from before
21:19:06 <bd_> mmm
21:19:08 <bd_> I guess I'll try hooks
21:19:11 <cjb> shapr: I was thinking about Haskell projects that would be fun and suited to Haskell, and I thought about Fountain Codes.  Any interest in working on something like that?
21:19:44 <cjb> shapr: http://en.wikipedia.org/wiki/Fountain_code -- an encoding scheme where you can restore an original K packets in a lossy erasuer channel after hearing *any* K+epsilon packets.
21:19:45 <lambdabot> Title: Fountain code - Wikipedia, the free encyclopedia
21:20:08 <shapr> cjb: Yeah, interested... I'm upptagen with trying to get bos' LLVM binding working though.
21:20:26 <shapr> er, what's upptagen in English? uptaken? taken-up? busy?
21:20:33 <cjb> shapr: no idea :)
21:20:51 <shapr> "occupied"
21:20:59 <cjb> that works.
21:21:11 <shapr> Anyway, edwardk probably knows more about that sort of stuff, I first started talking to him about tornado codes.
21:21:21 <shapr> Does look interesting.
21:21:22 <cjb> Oh, same thing.
21:21:24 <Saizan> oerjan: -main-is doesn't work with runghc at all
21:21:48 <cjb> (I think almost all Tornado codes are patented, though.)
21:21:54 <shapr> Yeah, sucks very much.
21:22:01 <oerjan> ic
21:22:14 <cjb> I was thinking about the RT code, which is the published version of a fountain code from before they spun off a company.
21:22:38 <bos> shapr: augustss is pretty up to date with it.
21:22:45 <shapr> bos: It doesn't build!
21:23:19 <shapr> bos: Seems to be missing LLVM/ExecutionEngine.hs
21:23:44 <bos> hmm, bummer
21:23:47 <shapr> bos: Or am I missing something?
21:24:03 <bos> no, you're right.
21:24:23 <shapr> cjb: What're the best papers to read about RT codes?
21:24:36 <shapr> cjb: Oh hey, have you read Hamming's Art of Science and Engineering?
21:24:50 <allbery_b> cjb: grab ghc source and "find . -type f -print | xargs grep -i gtk", for starters
21:25:14 <cjb> shapr: I think my ex-boss's book is good, it has a chapter on them and is available online.
21:25:28 <bos> shapr: i've pinged augustss.
21:25:33 <shapr> cjb: Google keywords?
21:25:58 <cjb> shapr: http://www.inference.phy.cam.ac.uk/mackay/itprnn/ps/588.596.pdf
21:26:00 <shapr> bos: Spiffy, tahnks.
21:26:11 <shapr> er, thanks*
21:26:12 * shapr is tired
21:26:42 <shapr> cjb: Should be .gz
21:26:51 <shapr> I really miss 'file' when using windows.
21:27:19 <shapr> cjb: Oh hey, I have one spare ticket to The Pogues tomorrow night at the Orpheum, know anyone who wants it?
21:27:23 <bos> shapr: have you looked at FEC codes?
21:27:27 <shapr> cjb: Single female preferred ;-)
21:27:32 <shapr> bos: Nah, asking google...
21:28:21 <bos> turbo codes are kind of the state of the art for one-way channels with erasure.
21:28:25 <shapr> Oh yeah
21:28:40 <bos> but they're very complicated and expensive.
21:28:45 <shapr> edwardk was looking at turbo codes for doing bittorrent-style multicast downloads.
21:30:26 <bos> complexity apart, the problem with turbo codes is huge wads of patents.
21:30:29 <shapr> yup
21:30:44 <shapr> Speaking of which, isn't arithmetic compression going out of patent soon?
21:31:02 <cjb> shapr: I think it already did.
21:31:06 <cjb> (arithmetic encoding.)
21:31:07 <shapr> One of the really crappy parts of software patents is that I get to look at really cool toys and NOT PLAY WITH THEM FOR SEVENTEEN YEARS!
21:31:10 <shapr> oh cool
21:31:21 <cjb> At least, the BBC uses it for Dirac/Schroedinger now.
21:31:53 <shapr> http://en.wikipedia.org/wiki/Arithmetic_encoding#US_patents_on_arithmetic_coding
21:31:55 <lambdabot> http://tinyurl.com/2jknuh
21:32:20 <shapr> I'd guess the BBC licensed it from IBM.
21:33:07 <shapr> cjb: Anyway, I'm up for fountain codes if this LLVM thing reaches a stopping point.
21:33:31 <shapr> Ah, it's bedtime!
21:33:35 * shapr disappears
21:37:00 * bos needs to dust off the LLVM code and document it properly, then do a proper release.
21:40:22 <Pseudonym> One of Pixar's early patents has now expired, but an extension (which includes the original patent in it; I don't understand that) is still in effect.
21:40:31 <Pseudonym> The thing is, I worked out the extension from the original patent.
21:40:38 <Pseudonym> Does that count as "obvious"?
21:40:55 <jsnx> @tell scook0 thanks, that last paper was just the thing
21:40:55 <lambdabot> Consider it noted.
21:41:07 <scook0> glad to help
21:41:08 <lambdabot> scook0: You have 1 new message. '/msg lambdabot @messages' to read it.
21:41:19 <Pseudonym> It's all confusing.
21:41:25 <Pseudonym> I don't understand these extension things.
21:41:30 <jsnx> Pseudonym: it's not obvious till you challenge it
21:41:45 <Pseudonym> Well, it doesn't affect me in Australia.
21:42:14 <Pseudonym> The first patent was, essentially, "Monte Carlo integration as applied to sampling in graphics".
21:42:17 <jsnx> Pseudonym: uhm, well, are you sure about that?
21:42:27 <Pseudonym> Which, AFAICT, is prior art A + prior art B.
21:42:33 <jsnx> Pseudonym: many software patents are flimsy garbage
21:42:52 <Pseudonym> And the extension is "oh, yeah, you could use it to compute this integral too".
21:43:07 <jsnx> Pseudonym: i have a friend who's a patent officer for a small hardware company (OQO)
21:43:38 <jsnx> it seems to be the general feeling among patent professionals that a great many patents are ready to fall over at the slightest puff of air
21:43:43 * Pseudonym nods
21:43:46 <jsnx> in software, anyway
21:44:01 <Pseudonym> We do have a few patents around here, but I work in applied chemistry, in a group that invents new materials.
21:44:09 <Pseudonym> We think very hard about our patents.
21:44:40 <jsnx> yeah, in software it's a lot of shoot-from-the-hip garbage
21:44:47 <Pseudonym> In fact, one job I had to do was brainstorm in a document every idea for electronic support that we had, so we could give it to one group we wanted to work with.
21:44:58 <Pseudonym> The idea being that if we told them first, they couldn't patent it.
21:45:08 <jsnx> yeah
21:45:11 <SamB> in chemistry I'm sure your patents at least require high-pressure ... chemicals ... before they fall over
21:45:23 <Pseudonym> Nah, this is nanotech.  A puff of wind will do it.
21:45:31 <jsnx> hehe
21:46:11 <SamB> well. you probably at least need PHYSICAL wind in nanotech
21:46:16 <Pseudonym> Indeed.
21:46:32 <jsnx> well, honestly -- anything really new will get a lot of fluff patents
21:46:39 <Pseudonym> I'm not worried about the stuff that we patent, because you need a chemistry lab to make it.  Or, in some cases, a cyclotron.
21:46:56 <jsnx> the reviewers are like, yeah, this looks innovative -- we have no idea what it is
21:47:02 <SamB> I think that software patents can be blown over even with cheap-ass chrono trigger wind
21:47:12 <jsnx> SamB: yeah
21:47:32 <jsnx> now business method patents, on the other hand -- those are a horse of a different color
21:47:53 <Pseudonym> Or, perhaps, horse shit of a different colour.
21:48:30 <jsnx> imagine being able to patent "the method of burning linux distros and charging a per CD fee"
21:48:36 <jsnx> or something like that
21:48:47 <Pseudonym> Yeah.
21:48:56 <jsnx> it's important that software innovators be protected *somehow*
21:49:05 <Pseudonym> They are.  Trade secret and copyright.
21:49:15 <Pseudonym> Often both.
21:49:31 <jsnx> hmmm
21:49:56 <jsnx> neither is really comparable to the kind of protections blender makers have
21:49:58 <Pseudonym> The problem that I have is that a startup that hasn't shipped doesn't have any way to measure how much they've achieved.
21:50:14 <Pseudonym> jsnx: Software and blenders are not comparable.
21:50:24 <jsnx> you can reverse engineer them both
21:50:25 <Pseudonym> So the market is set up such that you _have_ to patent.
21:50:52 <Pseudonym> It's technically not legal to reverse engineer software in many jurisdictions except under certain circumstances.
21:51:00 <roconnor> @go 1 EUR in USD
21:51:00 <lambdabot> 1 Euro = 1.5757 U.S. dollars
21:51:07 <cjb> Pseudonym: where many == one?
21:51:10 <jsnx> Pseudonym: sure
21:51:15 <Pseudonym> cjb: many == several
21:51:26 <SamB> idiots
21:51:27 <Pseudonym> Whether you agree with that or not, I don't know.
21:51:37 <Pseudonym> I think that making work-alikes is fair game.
21:51:39 <SamB> (meaning the people who made it illegal to reverse engineer)
21:51:43 <jsnx> copyright does not protect an investment in ideas
21:51:49 <Pseudonym> Looking at a blender and going, "I can make a device which does that, too".
21:51:58 <Pseudonym> An idea and $2 will buy you a coffee.
21:51:59 <jsnx> software patents do, but they're ridiculous
21:52:11 * SamB doesn't like coffee
21:52:13 <Pseudonym> You don't invest in ideas, you invest in businesses and/or products.
21:52:18 <cjb> Pseudonym: I guess I don't have a counter-assertion; I just haven't heard of such law used anywhere except the USA.
21:52:24 * SamB would go for the $1 nestea instead
21:52:37 <jsnx> Pseudonym: business propositions are ideas
21:52:46 <jsnx> especially in software-land
21:52:52 <Pseudonym> VCs don't invest in business propositions, they invest in businesses.
21:53:10 <jsnx> Pseudonym: if you have a working business, you don't need VCs...
21:54:25 <jsnx> basically, i'm finding it hard to come up with a model for product development that is compatible with my own self-interest and open-source
21:54:26 <Pseudonym> You mean that if you have a sustainable business, you don't need VCs.
21:54:38 <jsnx> Pseudonym: that's what i mean
21:54:40 <Pseudonym> Right.
21:55:03 <jsnx> Pseudonym: if they just looked at your balance books, there'd be nothing to see at a startup
21:55:19 <jsnx> "wow, you guys burnt a lot of money and made nothing!"
21:55:29 <Pseudonym> Sure.  That's why they need to look at your business plan.
21:55:34 <jsnx> right
21:55:40 <SamB> which is an idea
21:55:44 <Pseudonym> A patent is a semi-tangible asset.
21:55:54 <Pseudonym> That's something that you can point to and say "we made this".
21:55:57 <SamB> because you can burn it?
21:55:59 <jsnx> Pseudonym: well, it is an idea with teeth
21:56:02 <Pseudonym> And it adds to the value of the company.
21:56:21 <jsnx> you can say, *only we* can do this (if we get adequate legal protection)
21:56:30 <Pseudonym> It'd be nice if VCs valued research papers.
21:56:33 <cjs> I have a NominalDiffTime, and I need a Double measuring that number of days. How would I do this?
21:56:48 <jsnx> Pseudonym: unfortunately, those don't offer exclusivity :)
21:57:02 <jsnx> Pseudonym: anyone can read the paper and try to undercut you
21:57:33 <cjs> Hoogle doesn't give me much love for "NominalDiffTime -> _". Or rather, too many pages of love. I must be searching poorly.
21:57:51 <Pseudonym> Well, anything paper-worthy is only going to be a small part of a product, in general.
21:57:52 <jsnx> Pseudonym: if they have a lot more money, they just wait for you to die and then bring their prices back up -- or use your idea as part of an inducement for some larger service of theirs
21:57:54 <Pseudonym> And you have a head start.
21:58:12 <Pseudonym> jsnx: I don't know about you, but I intend to live for longer than the length of a patent.
21:58:31 <SamB> you == bussiness
21:58:37 <jsnx> Pseudonym: by "you" i mean "your company"
21:58:40 <Pseudonym> Ah, right.
21:58:52 <jsnx> the market can stay irrational longer than you can stay solvent
21:58:56 <oerjan> @hoogle NominalDiffTime
21:58:56 <lambdabot> Data.Time.Clock.NominalDiffTime :: data NominalDiffTime
21:59:07 <jsnx> they can take a loss on your product, while you need to make a profit
21:59:30 <oerjan> cjs: it has a Real instance
21:59:36 <jsnx> since it's clear they're going to win, your stock will go down in value
21:59:37 <oerjan> :t realToFrac
21:59:40 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
21:59:58 <jsnx> so, you see what i'm getting at with business methods patents
22:00:24 <cjs> So basically that means it interoperates with other Reals?
22:00:29 <jsnx> in a way, they protect what's important to VCs -- not the right to build something, but the right to do so for a profit
22:00:42 <oerjan> yep
22:00:51 <oerjan> @src Real
22:00:51 <lambdabot> class  (Num a, Ord a) => Real a  where
22:00:51 <lambdabot>     toRational      ::  a -> Rational
22:01:35 <oerjan> or, you can convert it to any Fractional, such as Double
22:02:45 <oerjan> "Conversion functions will treat it as seconds"
22:03:48 <oerjan> http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Clock.html#t%3ANominalDiffTime
22:03:50 <lambdabot> http://tinyurl.com/2ydz82
22:07:23 <cjs> So I convert s :: NominalDiffTime to days :: Double using "fromRational (toRational s / 86400)"?
22:07:34 <cjs> Something about that seems weird to me.
22:07:51 <oerjan> @src realToFrac
22:07:52 <lambdabot> realToFrac = fromRational . toRational
22:08:43 <SamB> oerjan: cjs' way sounds like it would avoid rounding error better...
22:08:49 <oerjan> i don't think it matters much when you divide by 86400, since all the types are Fractionals
22:09:01 <oerjan> oh well maybe that
22:09:10 <SamB> oerjan: Rational has exact arithmatic
22:09:12 <SamB> so...
22:09:18 <roconnor> @go 1 day in seconds
22:09:19 <lambdabot> 1 day = 86,400 seconds
22:09:34 <roconnor> @go 1 sidereal day in seconds
22:09:35 <lambdabot> 1 sidereal day = 86,164.0905 seconds
22:09:37 <cjs> I was sorta thinking that doing "s / 86400" first produces a result also in seconds, which it certainly should not be, though once you convert that it comes out the same way in the end.
22:09:45 <roconnor> @go 1 solar day in seconds
22:09:47 <lambdabot> http://en.wikipedia.org/wiki/Solar_time
22:09:59 <cjs> Maybe I want to make myself a TimeDiffDays type or something like that.
22:10:28 <SamB> sidereal?
22:10:42 <cjs> Actually, dealing in seconds doesn't make that much sense in the end, since this is financial time, not anything to do with the physical world.
22:11:06 <roconnor> @go 1 day * (1 year - 1 day) / 1 year in seconds
22:11:06 <lambdabot> ((1 day) * ((1 year) - (1 day))) / (1 year) = 86,163.4446 seconds
22:11:35 <roconnor> @go 1 day * 1 year  / (1 year + 1 day) in seconds
22:11:36 <lambdabot> ((1 day) * 1 year) / ((1 year) + (1 day)) = 86,164.0905 seconds
22:11:42 <roconnor> better
22:12:02 <roconnor> @go 1 year in days
22:12:02 <lambdabot> 1 year = 365.242199 days
22:12:08 <roconnor> @go 1 year in sideral days
22:12:08 <lambdabot> http://en.wikipedia.org/wiki/Sidereal_time
22:12:08 <lambdabot> Title: Sidereal time - Wikipedia, the free encyclopedia
22:12:13 <roconnor> @go 1 year in sidereal days
22:12:13 <lambdabot> 1 year = 366.242199 sidereal days
22:12:57 <roconnor> SamB: one sidereal day is how long it takes for the fixed stars to return to their position in the sky.
22:13:02 <oerjan> @go 1 sidereal year in sidereal days
22:13:03 <lambdabot> 1 sidereal year = 366.256402 sidereal days
22:13:27 <roconnor> ?
22:13:33 <roconnor> what is a sidereal year?
22:13:57 <jql> how many revolutions the planet makes during one orbit of the sun
22:14:19 <Pseudonym> roconnor: It's how long it takes for the Sun to return to the same position relative to the background stars.
22:14:21 <jql> vs. how many times the sun reaches its zenith in one orbit of the sun (solar year)
22:15:02 * roconnor ponders that
22:15:30 <roconnor> Pseudonym: so persession is taken out?
22:16:03 <Pseudonym> roconnor: I think if you take that into account, it's an anomalistic year.
22:16:09 <Pseudonym> Something like that.
22:16:19 * Pseudonym has never been quite clear on what "anomalistic year" means
22:16:22 <roconnor> @go 1 eon in years
22:16:23 <lambdabot> http://en.wikipedia.org/wiki/Eon_Kid
22:16:23 <lambdabot> Title: Eon Kid - Wikipedia, the free encyclopedia
22:16:48 <oerjan> @go 1 kalpa in years
22:16:49 <lambdabot> http://en.wikipedia.org/wiki/Kalpa_(time_unit)
22:16:49 <lambdabot> Title: Kalpa (time unit) - Wikipedia, the free encyclopedia
22:16:53 <Pseudonym> Ah, no, that's a heliacal year.
22:16:55 <oerjan> bah :)
22:17:03 <Pseudonym> The interval between heliacal risings of a star.
22:17:13 <Pseudonym> Which does take precession into account.
22:17:41 <roconnor> @go 1 epoch in years
22:17:42 <lambdabot> http://en.wikipedia.org/wiki/Epoch_(astronomy)
22:17:42 <lambdabot> Title: Epoch (astronomy) - Wikipedia, the free encyclopedia
22:19:08 <roconnor> cjs: as you can see, it is all really complicated :)
22:21:02 <Pseudonym> Most of these years are only of interest to astronomers.
22:21:08 <Pseudonym> Even navigators don't have to worry about it.
22:23:15 <roconnor> :)
22:23:54 <roconnor> I kinda wish governments would stop meddling with time.
22:24:15 <Pseudonym> Yeah, down with UTC, up with TAI!
22:24:25 <Pseudonym> Leap seconds are slavery!
22:24:39 <roconnor> Pseudonym: fuck TAI go with TT!
22:31:23 --- mode: irc.freenode.net set +o ChanServ
22:33:54 <roconnor> in the 1970's TAI slowed down by a factor of 10^-12 to componsate for the gravitational time dilation of their altitude
22:34:16 <roconnor> I guess TAI isn't as steady as I thought :)
22:34:57 <roconnor> The instant that the gravitational correction started to be applied serves as the epoch for Barycentric Coordinate Time (TCB), Geocentric Coordinate Time (TCG), and Terrestrial Time (TT).
22:35:00 <Riastradh> At least it's steadier than daylight screwings time!
22:35:31 <Riastradh> (I'm still bitter about the hour that I want back from the other week.)
22:35:34 <Pseudonym> So the 2004 tsunami probably affected TT too.
22:36:09 <roconnor> ``In an effort to bost CPU performance GW Bush had decided to lengthen the second by 1 nanosecond.
22:36:16 <moss82> why don't they have computer clocks change adjust their clocks accordingly every day by nanoseconds
22:36:41 <roconnor> Pseudonym: crap
22:36:58 <lament> my computer at work has the time wrong because some patch hasn't been applied
22:37:03 <roconnor> Pseudonym: maybe we should use TCG?
22:38:21 <roconnor> ``In the 1990s annual periodic variations in the rate of some clocks were traced to blackbody radiation that varies with the ambient temperature. It became clear that a correction for this was required.
22:38:29 <roconnor> damn it
22:38:47 <roconnor> Accordingly, in 1997 the BIPM declared that the definition of the SI second referred to a caesium atom at rest and at absolute zero temperature. Temperature corrections were implemented in TAI from 1995 to 1998, speeding TAI up by about 10^-14.3.
22:38:55 <roconnor> they changed the rate again.
22:39:24 <Pseudonym> In some respect, TAI is more honest.
22:39:30 <Pseudonym> It changes as it needs to.
22:39:32 <dmwit> Wait, am I still in #haskell?
22:39:41 <dmwit> I mean, I'm pretty used to being lost, but what is TAI?
22:39:41 <Pseudonym> This is #haskell-timekeeping.
22:39:53 <Pseudonym> dmwit: TAI is International Atomic Time.
22:39:55 <dmwit> BIPM? TT?
22:39:57 <roconnor> Pseudonym: I like that it doesn't change history.
22:40:01 <dmwit> mm
22:40:01 <Pseudonym> Essentially, it's UTC without the leap seconds.
22:40:15 <roconnor> Pseudonym: When making my new operating system I'm torn between TAI and TT.
22:40:39 <Pseudonym> UTC is "civil time".
22:40:39 <roconnor> granted the difference is only 32.184, and hasn't changed yet.
22:40:48 <Pseudonym> I would therefore go with that.
22:41:18 <roconnor> Pseudonym: go with UTC for what?
22:41:57 <Pseudonym> An operating system.
22:42:04 <Pseudonym> It does have the problem of when to put in the leap seconds.
22:42:16 <Pseudonym> For true UTC, you need to get the announcements of when they happen.
22:42:49 <cjs> This is the nice thing about FT: no leap seconds, no daylight savings time.
22:42:58 <roconnor> An OS should internally store TT (or maybe TAI) and use software to convert to UTC, or local time.
22:43:08 <Pseudonym> Oh, interesting.  The ITU is going to vote on abolishing leap seconds this year.
22:43:20 <roconnor> Pseudonym: oh, thank god.
22:43:22 <Riastradh> In favour of what, a leap hour in a hundred years?
22:43:30 <cjs> I think someone was telling me that abolishing leap seconds was a really, really bad idea.
22:43:33 <roconnor> Pseudonym: the leap hour is a much better idea.
22:43:40 <Riastradh> Why is a leap hour a better idea?
22:43:41 <Pseudonym> In favour of UTC slowly getting out of sync with sundials.
22:44:02 <Pseudonym> However, if you need any more evidence: Pretty much every internet standard uses UTC.
22:44:05 <roconnor> Riastradh: 1) we push the problem off so far into the future, we never have to worry about it.
22:44:09 <Pseudonym> In particular, NTP.
22:44:40 <roconnor> Riastradh: 2) we are accustomed to shifting time by an hour randomly already.
22:44:41 <Riastradh> roconnor, thirty years ago you could have argued the same thing about 2038.  That's no argument.
22:45:10 <Riastradh> No, we're accustomed to shifting the way that we look at our local time by an hour randomly.
22:45:35 <roconnor> Riastradh: UTC is just a global local time.
22:45:37 <Riastradh> Anyone who actually cares about global synchronization doesn't worry about daylight savings time or any absurdity like that.  But they would suddenly have to care about a leap hour, once.
22:45:39 <cjs> See "The US Proposal" at http://www.cl.cam.ac.uk/~mgk25/time/leap/
22:45:40 <lambdabot> Title: Leap seconds
22:46:22 <cjs> Riastradh: Right. We use UTC specifically to avoid doing the shifting by an hour. If that starts shifting, too....
22:46:45 <Pseudonym> Daylight savings time is like gamma correction.  It's what happens when you render the actual time onto a specific locale.
22:47:10 <Pseudonym> All that's left is to define "the actual time"!
22:47:44 <roconnor> Pseudonym: and actual time is ... TT with no crazy 23:59:60
22:47:45 <Riastradh> Since that's not going to be laid down flat any time soon, it doesn't bother me to request tiny incremental updates in UTC on occasion.
22:48:05 <lament> actual time clearly should not be tied to such silly things as "the solar system"
22:48:15 <lament> which is also a specific locale
22:48:56 <Pseudonym> Thanks to Einstein, everywhere and everywhen is a specific locale.
22:50:09 <elaforge> is there any way to get hsc2hs to generate dependencies for make?
22:50:16 <scook0> I wonder if in practice people would set up a new reference time, and migrate systems over to that
22:50:21 <elaforge> I'd think all it would have to do is run gcc -M on the intermediate c file it generates...
22:50:23 <scook0> rather than actually use a leap hour
22:50:28 * dmwit proposes a new system, with ten hours per day, one hundred minutes per hour, and one hundred seconds per minute
22:50:44 <roconnor> actually maybe keeping UTC is okay.
22:51:03 <roconnor> Instead we should all more or less ignore UTC and talk about TT instead.
22:51:06 <Pseudonym> dmwit: What is this "day" of which you speak?
22:51:31 <dmwit> Pseudonym: Don't want to get too radical, people might not accept it. =)
22:52:18 <cjs> Actually, just working in kiloseconds and so on works pretty well.
22:52:44 <dmwit> Yeah, I picked that up for a little while after reading some Vinge. =)
22:53:11 <dmwit> If I remember well, kilosecond ~= 15 minutes, megasecond ~= 2 weeks.
22:53:45 <oerjan> @go 1 gigasecond in years
22:53:45 <lambdabot> 1 gigasecond = 31.6887646 years
22:53:51 <roconnor> Pseudonym: I believe dmwit's day is clear: 919263177000000 cycles of the radiation produced by the transition between two levels of the cesium 133 atom
22:54:35 <jekor> I'm trying to figure out concurrency and IO at the same time. I'm getting xtee: /tmp/fifo-out: hPutStr: illegal operation (handle is closed)
22:54:44 <jekor> This is for the program at http://paste.lisp.org/display/57693
22:55:02 <jekor> An explanation of what I'm trying to do is at http://jekor.com/xtee/xtee.pdf (1 page)
22:55:26 <jekor> Can someone please set me straight with forkIO and the IO functions in that program?
22:56:12 <Pseudonym> roconnor: So a "day" at sea level is different from a "day" on top of a mountain?
22:56:19 <oerjan> @hoogle withFile
22:56:20 <lambdabot> System.IO.withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
22:56:55 <roconnor> Pseudonym: of course.
22:57:04 <roconnor> well
22:57:09 <roconnor> depends on what you mean by different
22:57:15 <bd_> hmm, is hpaste down?
22:57:23 <jekor> bd_: It was for me.
22:57:28 <bd_> blah
22:57:33 <scook0> you probably aren't supposed to use forkIO inside withFile
22:57:33 <oerjan> jekor: withFile closes the file as soon as the action ends, which is immediately if you use forkIO
22:57:49 <jekor> Ah...ok, makes sense. I'll have another go at it. Thanks.
22:58:40 <elaforge> I'm trying to see how gtk2hs does it, but the makefile is hard to understand...
22:58:49 <roconnor> Pseudonym: oh apparently TT isn't defined to be time at sea level
22:59:25 <roconnor> it just ticks slower than TGC by a factor of (1-6.969290134 Ã 10^â10).
22:59:36 <roconnor> so the Tsunami didn't affect TT.
22:59:37 <bd_> http://pastebin.org/24541 <-- what's wrong here? I'm passing ExistentialQuantification in cabal's extension list...
22:59:48 <Pseudonym> Right.
23:00:31 <bd_> (the goal being to lift functions of the form foo :: SomeMonad r -> SomeMonad r)
23:02:10 <roconnor> ugh, there is TT(TAI) and TT(BIPM07) ,...
23:02:46 <oerjan> > fix (fun "TT" . fun "TAI") :: Expr
23:02:48 <lambdabot>  Add a type signature
23:02:52 <oerjan> bah
23:03:23 <oerjan> > fix ((fun "TT" :: Expr -> Expr) . fun "TAI")
23:03:25 <lambdabot>  TT (TAI (TT (TAI (TT (TAI (TT (TAI (TT (TAI (TT (TAI (TT (TAI (TT (TAI (TT (...
23:05:06 <dibblego> are instance declarations always imported by a module?
23:05:12 <oerjan> yes
23:05:18 <dibblego> great, thanks
23:08:32 <bd_> ah,needed Rank2Types
23:11:47 <cjs> So, I sometimes run into confusion when passing around various Double parameters, e.g., accidently reversing the strike price and interest rate. What would be the standard way of getting the type system to help me out here? Make newtypes of things? E.g., "newtype Interest = Double"?
23:12:07 <Riastradh> newtype Interest = Interest Double, surely.
23:12:27 <dmwit> But yes, newtypes are great for that.
23:12:45 * dmwit wishes for a ... deriving (Everything) clause
23:13:03 <bd_> ... huh, ghc probably shouldn't be using 600mb of RAM
23:13:08 <Riastradh> data ... deriving (Monad, Arrow, Comonad)
23:13:37 <dmwit> Riastradh: I want Everything, as in, "Everything" would literally be a recognized keyword.
23:14:49 <scook0> I think you'd want it to be everything then
23:15:02 <dmwit> ok
23:15:07 <scook0> what if I want to create an Everything typeclass? ;)
23:15:24 <oerjan> dmwit: deriving (..)  would fit with import syntax
23:15:26 <dmwit> It could be "deriving Antediluvian Slugs" for all I care. =)
23:15:42 <dmwit> oerjan: Yeah!
23:15:42 <scook0> yes, I was about to suggest ..
23:16:42 <scook0> if we had class aliases, newtype-deriving could probably support them without too much trouble
23:16:44 <jekor> Thanks, guys, that worked. Now I'm wondering if there's a way to make it more elegant/idiomatic (re the IO Handle stuff): http://paste.lisp.org/display/57695
23:17:31 <cjs> So given "newtype InterestRate = R Double", how do I multiply an InterestRate with a Double?
23:17:51 <oerjan> jekor: note you might get trouble if the main thread finishes before the forked one, because then the program exits..
23:17:52 <cjs> E.g., "0.3 :: Double * 0.05 :: InterestRate
23:18:20 <dmwit> cjs: You don't. =/
23:18:20 <Riastradh> cjs, first you redesign the prelude so that it distinguishes multiplication from scaling and otherwise does arithmetic and numerics sensibly.
23:18:33 <dmwit> cjs: More realistically:
23:18:41 <Riastradh> I have some ideas for how this ought to work, and there are a couple of other efforts that people have actually released, such as NumericPrelude.
23:18:49 <dmwit> (R 0.3) * (x :: InterestRate)
23:19:01 <jekor> oerjan: So I need to fork them both and then wait for both to finish?
23:19:07 <Riastradh> But 0.3 may not be an interest rate, dmwit.
23:19:20 <dmwit> *blink*
23:19:22 <cjs> Mmm. Ok, added to my to-do list: "redesign prelude."
23:19:29 <dmwit> Riastradh: That's why I put it in an R constructor?
23:19:33 <oerjan> jekor: well you don't need to fork both but the main thread should wait for the other after finishing its own work
23:19:37 <scook0> or 0.3 .* (0.05 :: InterestRate), for a suitable (.*)
23:19:48 <Riastradh> I know, dmwit, but that is a confusion of intent.
23:20:03 <dmwit> cjs: In the real world, though, you should have derived the proper instances so that literals can be InterestRate's.
23:20:10 <oerjan> jekor: you need to use an MVar or something to communicate between them
23:20:28 <dmwit> cjs: (Unless, of course, we are not talking about something that is a literal.)
23:20:30 <jekor> oerjan: OK, thanks. I'll re-read the paper on Concurrent Haskell.
23:20:35 <jekor> (for MVars)
23:20:43 <dmwit> Riastradh: What is really wrong with my suggestion, then?
23:21:32 <Riastradh> dmwit, it works, of course -- I'm just picking at details of how it isn't describing the intent of the system as carefully as one could, with a suitably modified prelude.
23:21:38 <cjs> Actually, I wanted to avoid literals being "automatically" interpreted as interest rates, so that, e.g., I say something like "calcPrice 37 (R 0.05)" and it tells me that I've got the price and interest arguments to that function reversed.
23:22:00 <cjs> Or, hm, maybe that's not quite it. But you see the idea I'm getting at, I think.
23:22:04 <dmwit> cjs: Ah, okay.  Then you have to pay the piper by explicitly wrapping things in R as appropriate.
23:23:06 <Riastradh> I'd like to see a separate `class Multiplicative a where (*) :: a -> a -> a' and `class Scalable scalar a where scale :: scalar -> a -> a'.  Then you could scale an interest rate by 0.3, without having 0.3 actually (confusingly) interpreted as an interest rate itself.
23:27:18 <cjs> Hm. That's a good idea.
23:27:55 <sclv> awesome -- i have a use for the Kleisli composition operator finally.
23:33:28 <sclv> and not only that, but its a doozy -- arises perfectly naturally from the problem at hand.
23:34:59 <sclv> sometimes monads are so awesome i wonder how i ever survived without them.
23:35:18 <cjs> Hey, just out of curiosity, is it possible to use greek letters as variable and function names in Haskell? It would be cool to use sigma instead of typing it out, or writing "vol" or whatever.
23:35:52 <sclv> in theory, current ghc supports unicode characters in source.
23:36:24 <Riastradh> The definition of Haskell supports it, in theory.
23:39:56 <bos> > is the toast ready yet
23:39:57 <lambdabot>  True
23:41:30 <dmwit> > [is, ()]
23:41:32 <lambdabot>  Couldn't match expected type `t -> t1 -> t2 -> t3 -> Bool'
23:41:42 <dmwit> > the
23:41:43 <lambdabot>  1
23:41:45 <dmwit> > toast
23:41:46 <lambdabot>  1
23:41:48 <dmwit> > ready
23:41:49 <lambdabot>  1
23:41:51 <dmwit> > yet
23:41:52 <lambdabot>  1
23:42:09 <dmwit> clever =0
23:42:12 <dmwit> =)
23:42:20 <dmwit> ?quote stack
23:42:20 <lambdabot> ghc says: Use -fcontext-stack20 to increase stack size to (e.g.) 20
23:42:22 <dmwit> ?quote stack
23:42:23 <lambdabot> ghc says: scavenge_stack: weird activation record found on stack
23:43:13 <dmwit> > let start f = f (); push s a f = f (a,s); add (a,(b,s)) f = f (a+b,s); end (a,_) = a in start push 2 push 3 add end
23:43:14 <lambdabot>  5
23:43:29 <bos> hi andyjgill
23:43:42 <andyjgill> Hi bos!
23:43:44 <andyjgill> Hows the book going?
23:44:03 <bos> bloody thing is never going to get finished! it's like an albatross!
23:44:08 <bos> nah, it's going well.
23:44:16 <andyjgill> Almost like a PhD!
23:44:33 <bos> i've just spent a few days editing some chapters, which is always fun.
23:44:55 <sclv> @let burnt = 0
23:44:56 <lambdabot> Defined.
23:44:56 <bos> it's like a PhD, only i have to cram it in between the hours of 9pm and 11pm.
23:45:01 <sclv> > is the toast burnt yet
23:45:03 <lambdabot>  True
23:45:12 <newsham> ?let swap (a,b) = (b,a)
23:45:13 <lambdabot> Defined.
23:45:14 <sclv> shucks.
23:45:40 <newsham> ?let (p /.\ f) x = guard (p x) >> return (f x)
23:45:41 <lambdabot> Defined.
23:45:54 <sclv> is yet ready the burnt
23:45:59 <sclv> > is yet ready the burnt
23:46:01 <lambdabot>  True
23:46:10 <newsham> > unfoldr ((/=0) /.\ swap.(`quotRem` 10)) 5234
23:46:12 <lambdabot>   add an instance declaration for (Num (t, t))
23:48:13 <sclv> > is the False True yet
23:48:14 <lambdabot>  True
23:48:18 <sclv> whoa
23:49:42 <newsham> > unfoldr ((/=0) /.\ swap.(`quotRem` 10)) 5234
23:49:43 <lambdabot>   add an instance declaration for (Num (t, t))
23:49:58 <newsham> hrmm.. why
23:50:10 <newsham> > unfoldr ((/=0) /.\ (swap.(`quotRem` 10))) 5234
23:50:11 <lambdabot>  [4,3,2,5]
23:50:16 <newsham> ahh precedence
23:52:32 <oerjan> > (is ()()()(), is "" "" "" "", is undefined undefined undefined undefined)
23:52:33 <lambdabot>  (True,True,True)
23:52:49 <newsham> ?type is
23:52:50 <lambdabot> forall t t1 t2 t3. t -> t1 -> t2 -> t3 -> Bool
23:52:54 <newsham> ?src is
23:52:54 <lambdabot> Source not found. You speak an infinite deal of nothing
23:53:18 <oerjan> i think the type + the undefined test pretty much nails it down
23:59:03 <bd_> hmm, how does -fallow-incoherent-instances select which instance to use? Or rather, I'm looking at a situation where it should be able to deduce which instance to use from fundeps, but it's not...
23:59:34 <bd_> moreover with incoherent instances it's picking the wrong one, then overflowing the context stack
