00:54:15 <profmakx> and cabal saves the day.
02:01:51 <dons> some intersting things at Hal3, http://iba-cg.de/hal3.html#engl
02:01:54 <lambdabot> Title: ||: iba Consulting Gesellschaft - intelligent business architecture:||
02:10:54 <profmakx> meh why is leipzig so far away from here :/
02:11:11 <Syzygy-> I'm normally living just next door (kinda) to Leipzig.
02:11:17 <Syzygy-> Still haven't made it to any of the HaL.
02:11:22 <Syzygy-> And for HaL3, I'll be in the US.
02:11:38 <Syzygy-> (which reminds me ... dons: wasn't you Seattle-based?)
02:12:37 <profmakx> oh i wasnt aware that you are from europe, Syzygy-
02:18:12 <Syzygy-> profmakx: I'm based in Germany, about an hour away frmo Leipzig.
02:33:51 <profmakx> i wonder whether one could get a haskell job at one of those companies
02:47:12 <Mr_Awesome> can haskell be compiled to create a shared library?
02:48:08 <Baughn> Mr_Awesome: Not.. yet. Not without lots of work, anywya.
02:48:40 <Baughn> Mr_Awesome: They're apparently working on it for 6.10
02:48:59 <Mr_Awesome> what are the obstacles?
02:49:05 * Baughn wouldn't know
02:49:26 <Baughn> Mr_Awesome: What do you want a shared library for, exactly?
02:49:40 <Mr_Awesome> Baughn: nothing specifically, just wondering
02:49:41 <ksandstr> ABI issues would be great, I suppose
02:49:57 <Baughn> Mr_Awesome: There is hs-plugins, which has some of the same functionality
02:53:06 <dolio> > 10^8 :: Int
02:53:17 <lambdabot>  100000000
02:53:33 <Baughn> > maxBound :: Int
02:53:34 <lambdabot>  2147483647
03:23:41 <ttt--> > maxBound + 1 :: Int
03:23:42 <lambdabot>  -2147483648
05:16:31 <EvilTerran> lively in here this morning
05:17:16 <Saul_> I'm trying to pattern match on a record, but I'm getting a pattern match error
05:17:26 <Saul_> Is it even possible?
05:17:32 <EvilTerran> yes, it is
05:17:58 <EvilTerran> RecordConstructor { fieldName = fieldValue, otherFieldName = otherFieldValue, ... } = ...
05:18:20 <EvilTerran> matches as you'd expect. fieldValue, otherFieldValue, etc can be patterns.
05:18:36 <EvilTerran> s/can be/are/
05:18:52 <Saul_> that's what I thought
05:19:23 <opqdonut> EvilTerran: shouldn't that be value = name
05:19:28 <opqdonut> not the other way around
05:20:08 <EvilTerran> an interesting side-effect of this is that ConstructorName{} works on any constructor, regardless of whether or not it was declared with record syntax or how many parameters it has
05:20:13 <EvilTerran> ?src State
05:20:13 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
05:20:38 <EvilTerran> ?src Sum
05:20:38 <lambdabot> Source not found. My brain just exploded
05:20:46 <EvilTerran> ?hoogle Sum
05:20:46 <lambdabot> Data.Monoid.Sum :: newtype Sum a
05:20:47 <lambdabot> Data.Monoid.Sum :: a -> Sum a
05:20:47 <lambdabot> Prelude.sum :: Num a => [a] -> a
05:20:52 <dolio> @type let foo (State { runState = f }) = f in foo
05:20:54 <lambdabot> forall t t1. State t t1 -> t -> (t1, t)
05:20:58 <EvilTerran> it's this way round
05:21:08 <EvilTerran> it's a little odd, but it is
05:21:13 <opqdonut> oh, wow
05:21:29 <dolio> Yeah, that always gets me.
05:21:52 <dolio> Or, gets me infrequently, because I don't use too many records that way, but it's hard to remember.
05:21:55 <EvilTerran> i just remember it as "patterns are the same shape as the value they construct"
05:22:20 <opqdonut> yeah it's kinda consistent that way
06:10:09 <skorpan> i hate parse errors, by the way
06:10:43 <ari> Why? They tend to be really simple to fix
06:11:04 <skorpan> this one is just really, really weird
06:11:19 * byorgey sings the hpaste song
06:11:20 <skorpan> i wouldn't be surprised if there was a type error, but this couldn't possibly be a parse error
06:11:43 <Botje> tabs instead of spaces?
06:11:45 <kpreid> well, show us!
06:12:04 <skorpan> only spaces
06:12:04 <skorpan> http://hpaste.org/6562
06:12:24 <kpreid> skorpan: (opponent n)
06:12:31 <mauke> that looks like you're trying to use a constructor variable
06:12:35 <kpreid> 'opponent' isn't a constructor
06:12:49 <skorpan> opponent is a function.
06:13:01 <mauke> you can't use functions in patterns
06:13:09 <skorpan> really?
06:13:09 <kpreid> you can't pattern match with a function
06:13:19 <kpreid> that would imply knowing how to compute the inverse of it
06:13:22 <skorpan> i did not know that.
06:13:25 <skorpan> thanks
06:13:26 <kpreid> and that it has a unique inverse
06:13:46 <skorpan> lol, thanks, it compiled immediately
06:13:52 <kpreid> you might want to use a guard on the pattern instead
06:31:50 <jacobian_> anyone know of a paper on parsing in a dependently typed language?
06:36:56 <dolio> I'm not sure why various types of parser combinators wouldn't work.
06:37:29 <dolio> Although, I guess they often rely on general recursion.
06:37:46 <jacobian_> yeah, the problem is a) general recursion and b) stronger specification
06:45:40 <mattam> jacobian_: coming up in Agda by Nils Anders Danielsson and Ulf Norrel, left recursive terminating parser combinators. In Coq, Greg Morrisett has a parser library too, with general recursion (not runnable in Coq). Both are dependently typed: the type of the parser gives you the type of the output objects.
06:46:34 <mattam> There's a talk on the first one here: http://www.cs.nott.ac.uk/~nad/publications/
06:49:06 <sethk> mattam, no papers on line?
06:49:23 <mattam> I don't think so.
06:49:42 <mattam> They're probably working on it though :)
06:52:21 <sethk> mattam, the slides are nice, but I need more to really understand
06:53:09 <mattam> There is agda code too, I'm sure they'd be happy to explain it if you asked them.
06:57:11 <dolio> Huh, the 'does it accept the empty string' was one thing I was thinking.
06:57:48 <dolio> Doubt I'd have gotten the other half, though.
06:58:10 <skorpan> @pl \(pos, _) -> free pos game
06:58:10 <lambdabot> flip free game . fst
07:00:28 <skorpan> i'm starting to grasp flip now
07:00:31 <skorpan> which is awesome
07:02:34 <jacobian_> Yeah, I don't totally grok what they've done in those slides.
07:02:54 <byorgey> skorpan: =)
07:05:19 <dolio> I was thinking that if you can prove that your a parser doesn't accept the empty string, you could do induction on the length of the input in the combinators that require recursion.
07:12:01 <jacobian_> dolio: Yeah that is basically what I did.
07:12:52 <jacobian_> dolio: I have a type: Suffix l' l, which says that l' is one of the tails of l.
07:13:27 <jacobian_> from there it is fairly straightforward to show that composition of terminating parsers are terminating.
07:14:30 <jacobian_> I was having trouble mixing parsers that accept the empty string, those that don't, possible failure and recursion.
07:21:43 <Saul_> Does anyone know the inverse to \a -> Vector2 (cos a) (sin a)
07:22:10 <Saul_> so given a unit vector, returns its angle
07:22:35 <Saul_> ?
07:23:47 <adiM> @pl add01 list = (add0 list) ++ (add1 list)
07:23:47 <lambdabot> add01 = liftM2 (++) add0 add1
07:23:48 <Heffalump> arctan (y/x)
07:24:09 <Heffalump> \Vector2 x y -> arctan (y/x), that is
07:24:53 <Shurique_> \ (Vector2 x y) -> atan2 y x
07:25:10 <luqui> atan2 behaves better when x is 0
07:25:22 <Shurique_> indeed
07:25:46 <Heffalump> ah, fair enough
07:27:38 <blarz> hi all
07:27:47 <byorgey> hi blarz
07:28:02 <desegnis> > atan (1/0) - atan2 1 0
07:28:05 <lambdabot>  6.1257422745431e-17
07:28:33 <blarz> hello byorgey
07:31:09 <Saul_> those atan thingies do sort of not give me exactly the right angle
07:32:41 <byorgey> Saul_: well, that's floating point for you.
07:32:57 <Saul_> > let f = (\a -> Vector2 (cos a) (sin a)); let g = (\(Vector2 x y) -> atan2 x y); let a = 3 * pi / 4; (g . f) a
07:32:57 <lambdabot>  Parse error at "let" (column 42)
07:33:27 <Saul_> > let f = (\a -> Vector2 (cos a) (sin a)); g = (\(Vector2 x y) -> atan2 x y); a = (3 * pi / 4) in (g . f) a
07:33:28 <lambdabot>   Not in scope: data constructor `Vector2'
07:33:40 <Saul_> argh
07:33:56 <byorgey>  > let f = (\a -> (cos a, sin a)); g = (\(x,y) -> atan2 x y); a = 3 * pi / 4 in (g . f) a
07:33:59 <byorgey> > let f = (\a -> (cos a, sin a)); g = (\(x,y) -> atan2 x y); a = 3 * pi / 4 in (g . f) a
07:34:00 <lambdabot>  -0.7853981633974483
07:34:02 <Saul_> anyway it returns -(pi/4) instead of (3*pi/4)
07:34:43 <dmhouse> Saul_: presumably because the atan takes the [-pi,pi] branch.
07:34:53 <dmhouse> Saul_: you can easily fix that, detect if it's < 0 and add 2pi if it is.
07:35:28 <byorgey> > let f = (\a -> (cos a, sin a)); g = (\(x,y) -> atan2 y x); a = 3 * pi / 4 in (g . f) a
07:35:29 <lambdabot>  2.356194490192345
07:35:36 <byorgey> > 3 * pi / 4
07:35:37 <lambdabot>  2.356194490192345
07:35:48 <byorgey> Saul_: you had x and y backwards in the arguments to atan2
07:37:10 <Saul_> byorgey: You're right, thanks
07:38:17 <Saul_> It still gives negative numbers, but now I can normalize those to my standards
07:42:06 * byorgey distributes lemon meringue lambdas
07:43:02 <resiak> perhaps you should make a lambda cheesecake
07:47:54 <byorgey> resiak: an excellent idea!
07:48:26 * byorgey whips up a strawberry lambda cheesecake
07:58:27 <sw17ch> does statement ordering ever matter outside of a do statement (or should it?)
07:59:11 <Zao> sw17ch: Outside do, there is only one statement.
07:59:29 <sw17ch> ... :) alright, here's the xample then
07:59:33 <sw17ch> i'm defining a function
07:59:38 <sw17ch> f (some pattern) = blah
07:59:44 <sw17ch> f _ = default
07:59:49 <sw17ch> those have to be in that order
07:59:53 <Zao> Patterns are matched top-down.
07:59:58 <sw17ch> alright, i figured
08:00:03 <sw17ch> but just wanted it confirmed
08:01:45 <sw17ch> thanks
08:36:45 <benny99> anybody interesting in coding something with a noob ?
08:37:04 <solrize_> ?
08:38:26 <benny99> well, I always read papers about FP or Haskell, but I still haven't used it -- now I'm looking for somebody else, who maybe did it the same way and is interested in programming some simple or more complex program in Haskell
08:39:49 <benny99> like hSpaceInvaders --
08:43:21 <benny99> ... or something
08:57:25 * Codexs bbl
09:01:45 <solrize_> benny99 yeah that's about where i'm at, i have a few ideas too
09:03:07 <benny99> solrize_: :), so !?
09:03:25 <solrize_> where are you, anywhere near san francisco ?
09:03:39 <benny99> :D no, sorry
09:10:48 <bparkis> pattern matching can be expressed using dependent types
09:11:33 <bparkis> if you have a function with a pattern matching rule f A = B, then you can represent that as "f has type x -> y where if x matches A, then y = B"
09:13:41 <bparkis> although that would seem to require y to be in class Eq
09:14:22 <Heffalump> I don't follow that at all.
09:14:54 <Heffalump> you seem just to be saying that dependent types give a more precise type to pattern matching constructs, not that they provide an encoding.
09:15:57 <bparkis> well I'm saying that with dependent types you could use a syntax similar to pattern matching to completely specify the function
09:16:32 <bparkis> and a smart enough compiler could generate the pattern matching code from the type, if it were written like that
09:16:49 <Heffalump> but all you seem to be doing is moving the pattern matching into the type
09:17:02 <bparkis> yes, that's my point, you can move the pattern matching into the type
09:17:51 <Heffalump> why is that useful?
09:18:09 <Heffalump> sometimes it might be, but not in general
09:18:21 <bparkis> it's not useful, I just thought it was interesting
09:18:59 <Heffalump> it seems obvious as well as not useful to me, I'm afraid :-)
09:19:14 <bparkis> it's an interpretation of pattern matching--you can interpret pattern matching as simply specifying the function's type dependently in a certain manner
09:21:35 <bparkis> http://www.bparkis.com/node/13
09:21:39 <lambdabot> Title: Expression inference | www.bparkis.com
09:24:00 <marshmallows> bparkis cool
09:24:25 <marshmallows> I agree "value inference" is a bad name, it's just theorem proving
09:24:38 <bparkis> yes I mention that
09:26:55 <marshmallows> I think lazy logic programming would be a nice place to do this sort of program derivation
09:27:10 <marshmallows> (must test this idea..)
09:29:25 <araujo> what is the option in cabal for the linker to look into a specific library path?
09:47:52 <olsner> :ty foldM
09:47:56 <olsner> @ty foldM
09:48:00 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
10:02:29 <benny99> Setup.lhs:4:29: Not in scope: `autoconfUserHooks' <-- on runghc Setup.lhs configure
10:02:36 <benny99> any ideas what's wrong?
10:11:33 <damg> what's the difference between vabsSQ = sum . map (\x -> x*x) and vabsSQ' v = sum (map (\x -> x * x) v) ? The first resolves to [Integer] -> Integer while the latter takes a generic Num.
10:12:02 <cinimod> @seen Heffalump
10:12:02 <lambdabot> Heffalump is in #haskell-soc, #haskell and #darcs. I last heard Heffalump speak 53m 3s ago.
10:12:12 <ari> damg: Monomorphism restriction
10:14:58 <damg> ari, could you explain it a bit easier please?
10:16:33 <desegnis> damg: The two definitions are equivalent with regard to their semantics, only the inferred types differs. You may annotate either function with the type you want it to be
10:18:01 <benny99> fixed
10:18:54 <damg> desegnis: ah, worked. so, is it a restriction which doesn't allow compiler to generalize the types itself?
10:19:21 <Heffalump> cinimod: I'm here.
10:19:32 <desegnis> damg: The idea behind the monomorphism restriction is that when you define a function without an explicit argument, then it looks like its value should only be computed once. But if its type is polymorphic then it may well have to be computed multiple times
10:19:59 <cinimod> Heffalump: I've asked a question about .lnk files on haskell-cafe
10:20:06 <desegnis> damg: right. Btw if you don't like it, just say -XNoMonomorphismRestriction
10:20:09 <Heffalump> oh yes, I remember
10:20:14 * Heffalump has no idea, however
10:20:27 <Heffalump> .lnk files aren't proper symlinks, they're just "shortcuts"
10:20:29 <cinimod> I think Neil has answered the question the wrong way round
10:20:36 <Heffalump> I think explorer has special knowledge of them, rather than the filesystem.
10:20:36 <ivan> you need the win32 api to create .lnk files
10:20:48 <damg> desegnis: , thank you very much for the clarification! :)
10:20:50 <cinimod> I want to open the linked to file not the link stuff itself
10:21:07 <Heffalump> right, so you need to read the file to figure out where it links to
10:21:14 <cinimod> ivan: I want to open whatever the .lnk points to
10:21:22 <Heffalump> I don't know how to do that, but perhaps IShellLink will help with that.
10:21:49 <Heffalump> However I'm not an expert either on Windows or on using Haskell with Windows :-)
10:22:02 * Heffalump just reluctantly tolerates it at work
10:23:07 <cinimod> Heffalump: I knew you did something with it
10:23:31 <cinimod> My colloborator uses Windows so I wanted the code to work on his setup as well as mine
10:24:02 <Heffalump> I don't think it's reasonable to expect applications to interpret shortcuts. I don't think most applications do.
10:24:05 <ivan> what are you reading lnk files for?
10:24:24 <olsner> no other windows application reads lnk files except explorer
10:24:32 <olsner> so I think your program shouldn't either
10:24:33 <ivan> some do, but it's pretty rare
10:24:58 <Heffalump> hmm, ok, Excel does (for example)
10:25:16 <ivan> yeah and anything with a file open/save dialog
10:25:20 <cinimod> A c program I'm using creates them to point to the real files
10:25:24 <Heffalump> ivan: ah, right
10:25:47 <cinimod> Well I know where the real files are so I'll compile them in there
10:26:07 <cinimod> and put the output in the working directory
10:26:10 <ivan> just don't make lnk files unless it's for start menus or desktops
10:26:27 <Heffalump> it's not a very big binary blob, might be quite easy to figure out the format if you want to
10:26:32 <Heffalump> seems to have a lot of crap in it, though.
10:26:45 <ivan> i wouldn't recommend figuring out MS blobs
10:26:56 <cinimod> I'll talk to the author but I'm guessing he just copied what he does on linux
10:26:59 <olsner> ehm, my program stalls in ghci (without using any cpu!) and prints <<loop>> when compiled
10:26:59 <ivan> probably incompatible across editions
10:27:39 <ivan> cygwin seems to misuse lnk files, especially its rsync
10:28:02 <cinimod> olsner: ghc has worked out you have an infinite loop - it can do that sometimes
10:28:36 <cinimod> I'm persuaded to ignore them completely and compile them from the real directory
10:28:54 <olsner> hmm, but if it did that at compile time, I would have expected it to print a warning about it rather than generate code that writes <<loop>>
10:29:12 <ddarius> olsner: It doesn't do it at compile-time.
10:32:53 <mauke> "The answer is probably "yes", because almost every time I've thought that a type system related question had an answer of "no", someone has been able to point me at a paper by Oleg Kiselyov."
10:33:44 <Heffalump> olsner: it works it out by noticing that it is re-entering a thunk that it is already trying to evaluate
10:34:20 <olsner> hmm, compiling without optimizations gives me a "Prelude.head: empty list" message
10:37:45 <Heffalump> ok, so it's running into a different bug first
10:38:25 <Heffalump> assuming that GHC isn't miscompiling your program, then your program has at least two errors in it; either it takes head [] or it loops. It's perfectly legitimate for optimisation to change which of those is hit first, so long as one is hit.
10:42:30 <matthew-_> gentlemen, I'm back
10:44:34 <Heffalump> welcome back
10:44:39 <Heffalump> were you gone? :-)
10:45:57 <matthew-_> indeed. To the South of France, to hurl myself down some mountains
10:46:33 <olsner> found the loop thing, stupid mistake... but then there's the empty list thing
10:47:37 <matthew-_> now, how good is the type synonynm implementation in 6.9? Is it usable yet?
10:48:34 <matthew-_> err, there should have been the word *families* in there somewhere...
10:49:16 <Heffalump> I'm using it.
10:49:29 <Heffalump> It's got some problems, and my code has some unsafeCoerce#s in it to work round them.
10:49:33 <Heffalump> And I can't do some stuff I want to.
10:49:42 <Heffalump> but I've done a fair bit with it.
10:50:02 <Heffalump> olsner: you could try using the ghci debugger to find the empty list.
10:50:15 <olsner> can the debugger break on exceptions?
10:50:19 <Heffalump> :set -fbreak-on-exception, then :trace main and look at :history when it fails
10:50:56 <matthew-_> ok, that's good to know. I'll probably need to pick your brains later on tonight then. I'm trying to do something with type families which I'm not sure can be done...
10:51:36 <pejo> Heffalump, are you using 6.9 for production code? How well does it work?
10:51:41 <Heffalump> I'm not really an expert on what's possible, I just have an early empirical view.
10:51:47 <Heffalump> pejo: not for production code, for my own playing.
10:52:09 <matthew-_> Heffalump: an empirical view's still valueable to me. :)
10:52:10 <Heffalump> we are actually using 6.9 at work, but that's a very early fork from 6.8 with a feature that only just missed going into 6.8 as unsupported
10:52:56 <matthew-_> is that the record update thingy or the string thingy?
10:53:04 <Heffalump> record update
10:53:12 <Heffalump> the string thingy is in 6.8
10:53:27 <matthew-_> I can remember vaguely lennart talking about both after several pints...
10:53:43 <Heffalump> it shouldn't need any alcohol to get us to talk about those :-)
10:55:36 <matthew-_> you know, one day I'm going to have to implement closed type classes and/or closed type families as their absence is driving me nuts
10:56:32 <Heffalump> ooh, yes please
10:56:58 <matthew-_> yeah, I'm not surprised I'm the only one who wants it
10:57:12 <matthew-_> suddenly, fundeps would actually mean what everyone always wants them to mean...
10:57:22 <Heffalump> being able to write instance Foo a => Bar a without it leading to all sorts of problems would be great.
10:57:25 <matthew-_> err, add an extra *not* to !-2
11:01:32 <matthew-_> yeah, that and the ability to do class C a b | a -> b where ... data F :: * -> * where FC :: (C a b) => b -> F a and then safely recover the b is my main motivation
11:02:12 <Heffalump> recover the b from what? The F a?
11:02:29 <matthew-_> yes
11:02:42 <Corun> Yarr, Mathew.
11:03:02 <Corun> Won the Deutsche Bank Prize :-)
11:03:04 <Heffalump> why don't fundeps already allow that?
11:03:08 <Corun> Good ol' topics in AI.
11:04:20 <Heffalump> you need type equalities in some situations like that to be able to use the fact that (C a b1, C a b2) means that b1 and b2 are the same
11:04:29 <Heffalump> but that's an implementation issue that 6.10 will address
11:06:29 <matthew-_> Heffalump: my main issue is that I want to write: foo :: (C a b) => F a -> b which you can't write
11:06:41 <matthew-_> because it won't unify the two 'b's
11:07:04 <matthew-_> because (aiui) as the type class is open, the fundep could be satisfied differently in two different modules
11:08:51 <Heffalump> how could something that used the two different ones ever come together?
11:09:03 <Heffalump> since instances are always implicitly exported/imported
11:09:58 <matthew-_> I have not a clue. But I do know that you can't write the above. Maybe my reasoning is wrong then...
11:10:06 <Heffalump> AIUI, from my question on ghc-users about why I can't write (Foo a b1, Foo a b2) => b1 -> b2 when Foo a b | a -> b was simply that GHC has no machinery for handling that kind of equality.
11:10:27 <Heffalump> but it will appear in 6.10 in some form.
11:10:43 <Heffalump> for now I just use an unsafeCoerce :-)
11:11:06 <matthew-_> Damn it, when are we going to get a theorem prover in the type system?
11:11:15 <matthew-_> Just a full constraint solver would do... ;)
11:11:44 <matthew-_> does ghc-users generally get this sort of question answered better than -cafe?
11:12:37 <Heffalump> errm, not sure
11:12:59 <Heffalump> I've been using -cafe recently because others have, but otherwise I'd have used ghc-users
11:27:11 <benny99> http://hpaste.org/6563 <-- sorry, but why does ghc not find the initSDL definition? I installed the cabal package :(
11:33:59 <benny99> because it does not exist...
11:37:32 <newsham> any haskell-related bay area goings on happening in the next few weeks?
11:56:25 <dons> newsham: a user group at stanford is forming
11:56:29 <dons> newsham: are you on BayFP ?
11:57:01 <lekro> is there a shorter way of writing \x -> x { foo = f foo }, i.e. applying a function to one field of a record?
11:57:19 <Cale> lekro: Not really, unfortunately.
11:57:20 <lekro> I mean \x -> x { foo = f (foo x) }
11:57:27 <Cale> right.
11:57:54 <newsham> dons: no, but i check the blog occasionally.
11:58:18 <newsham> i'm in bay area for two weeks starting tomorow.  i think i'm missing both last and next months bayfp
11:59:01 <newsham> lekro: you can use TH to macro it.  thats prob as good as you can get
11:59:13 <lekro> newsham: how would that look like?
11:59:49 <newsham> not sure.  I think HAppS has some macros (or at least used to) like that.
12:00:28 <newsham> i imagine you can make a macro that would instantiate modFieldName for each FieldName in a record given just its record name
12:01:04 <newsham> where modfoo would be \f x -> x { foo = f (foo x) }
12:02:00 <ski> lekro : <http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details> might be useful
12:02:00 <lambdabot> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details>
12:03:13 <newsham> ski: huh, thats very similar to something i've been toying with.  danke.
12:03:26 * shapr tosses lispy around the room
12:03:29 <shapr> @users
12:03:30 <lambdabot> Maximum users seen in #haskell: 473, currently: 438 (92.6%), active: 12 (2.7%)
12:03:43 <shapr> @yow !
12:03:43 <lambdabot> In 1962, you could buy a pair of SHARKSKIN SLACKS, with a "Continental
12:03:43 <lambdabot> Belt," for $10.99!!
12:03:44 <shapr> @quote
12:03:44 <lambdabot> goltrpoat says: Lemma: three cats chasing a deranged cricket all over the living room at 4am does not provide for a good reading environment
12:16:57 <newsham> ski: http://www.thenewsh.com/%7Enewsham/x/accessor.lhs
12:22:07 * lispy goes flying as shapr is quite strong
12:24:24 <opqdonut> @quote
12:24:24 <lambdabot> madpickle says: Stuff costs more than it used to.
12:26:59 <MarcWeber> sethk: I've my first trouble now. I have my GHCSide.hsc -> .hs -> {_stub,}.o and my if_ghc.o (only writing the command text to a file by now..). But when linking I'm getting an error:
12:28:56 <sethk> MarcWeber, I was sort of expecting something to follow the :
12:28:57 <MarcWeber> undefined reference : __stginit_containerszm0zi1zi0zi1_DataziMap_
12:28:59 <skorpan> is there any function which pattern matches?
12:29:21 <sethk> MarcWeber, ok, that's a c++ class method name, obviously
12:29:37 <sethk> MarcWeber, You could me just about to go out for a while.  I'll ping you when I get back.  K?
12:29:38 <MarcWeber> sethk: I'm visiting my sister right now and I had to retype the error message because I couldn't get pppoe to work on my laptop yet..
12:29:52 <sethk> MarcWeber, k
12:29:55 <MarcWeber> sethk: Sure..
12:30:09 <MarcWeber> cu
12:30:21 <Cale> MarcWeber: That usually happens when you're missing a package flag
12:30:28 <Cale> MarcWeber: Try compiling with --make
12:30:51 <Cale> It's not a C++ class method name at all.
12:31:42 <sethk> Cale, you're right, I was thinking about an earlier discussion with MW and I didn't look carefully
12:32:14 <MarcWeber> st= belongs to haskell
12:32:25 <MarcWeber> stg
12:32:43 <Cale> Yeah, that refers to the spineless tagless g-machine
12:33:07 <MarcWeber> Cale: I was too lazy to look it up.
12:33:16 <MarcWeber> Cale:  I only want to use ghc to link vim..
12:33:40 <MarcWeber> ghc is complaining about no input fails although i
12:33:47 <MarcWeber> 've added -no-hs-main
12:33:49 <Cale> That error is a result of not including the containers package which is needed for Data.Map
12:34:41 <ski> newsham : (too tired to look at that now) istr conal had something related, too
12:34:59 <Cale> --make will automatically include packages as needed
12:35:17 <ski> skorpan : `fst'
12:35:36 <skorpan> ski: fst?
12:35:40 <skorpan> no, i mean..
12:35:44 <MarcWeber> Cale: The information is already lost when linking (There are extra make targets for .o.. Yes, I've missed adding containers
12:35:56 <skorpan> it takes an argument "a" and is able to pattern match it againts e.g. "Hello _"
12:36:07 <skorpan> and return e.g. a Bool if it matches
12:36:10 <ski> oh, regexp ?
12:36:13 <MarcWeber> or my configure script doesn't its job right.
12:36:18 <skorpan> no, never mind.
12:36:27 <EvilTerran> skorpan, you have to write those yourself
12:37:02 <EvilTerran> you can make this quicker with one of the boilerplate-removing systems
12:38:00 <EvilTerran> (Data.Generics, Derive, Uniplate, that kinda thing)
12:38:14 <EvilTerran> ?type let f Nothing{} = False; f Just{} = True in f
12:38:15 <lambdabot> forall t. Maybe t -> Bool
12:38:31 <EvilTerran> that trick with the {}s is also useful for writing 'em by hand
12:39:01 <EvilTerran> it basically means "the appropriate number of '_'s (which can be none)"
12:39:22 <EvilTerran> ...in this context, anyway - it's an interesting side-effect of record syntax
12:40:23 <opqdonut> ah, nice indeed
12:40:31 <EvilTerran> it also saves parentheses :)
12:41:36 <Twey> skorpan: Uh, let
12:42:23 <lispy> Save the parens!
12:42:34 <lispy> (the lisp/scheme folks need them)
12:42:50 <skorpan> darn, you take defun out of lisp
12:43:41 <desegnis> lispy, didn't it rather go like, save the children? :)
12:43:57 <opqdonut> "save the children, the lispers want to eat them"
12:44:56 <MarcWeber> Cale:  Thanks. Linking suceeds after some manual adjustments ;-))
12:45:20 <EvilTerran> "serialise the children, that way we can easily distribute them to those with the resources available to deal with them"
12:46:57 <EvilTerran> (plus it'll make saving them easier)
13:23:02 <lekro> newsham: thanks, I got it working with TH. the module References doesn't look too pretty, though, but it makes the real code way easier to read
13:23:21 <lekro> ( http://hpaste.org/6565 )
13:24:53 <lekro> now I can write stuff like modifyIORef someState (update someField (+1))
13:45:28 <damg> is there a way to catch fails from pure functions without ending up in the IO monad? Or should I consider Maybe/Either in this case?
13:47:28 <opqdonut> Maybe or Either, yes
13:47:28 <opqdonut> and monadic operations
13:49:41 <damg> because I noticed that fromJust worked on  a successful result in a  [ fn :: (Monad m) => a -> m a ] function and there I began thinking that I must be doing something wrong there ...
13:50:49 <opqdonut> well using fromJust just unifies m with Maybe :)
13:50:57 <damg> ah, ok :-)
13:51:01 <opqdonut> (forces the used monad in other words)
13:51:16 <damg> hopefully that doesn't work on IO ;)
13:51:23 <opqdonut> the joys of polymorphy and type inference
13:51:42 <opqdonut> well of course it won't work: IO a doesn't unify with Maybe a
13:51:56 <damg> ah, true, good old unification
13:52:15 <idnar> @type fromJust
13:52:18 <lambdabot> forall a. Maybe a -> a
13:52:34 <idnar> oh
13:52:46 <damg> thank you very much for information
13:53:00 <opqdonut> np
13:57:33 <damg> I didn't think that it could be THAT generic (understood it now to 100% :-) )
14:07:36 <Mantaar> hey guys. Dumb question, but I can't seem to figure it out: how do I compile (or use!) the parces library? I'm using ghc, but ghc-pkg dosen't list text/parsec and ghc -package text gives an error.
14:07:49 <Mantaar> ... compiling doesn't work either... :-(
14:08:01 <Zao> I thought it was built-in nowadays.
14:08:06 <Zao> s/builtin/bundled/
14:08:18 <allbery_b> no, it's in extralibs
14:08:29 <Zao> Ah, close enough.
14:08:37 <allbery_b> you can get it from hackage, or check your distribution
14:09:03 <allbery_b> (most linux distributions have umbundled the packages)
14:09:24 <Mantaar> allbery_b: thx. I'm on debian. I'll apt-cache search for it now ;-)
14:10:51 <allbery_b> ok.  not a debian user, but if it follows the pattern I've seen mentioned for other packages look for libghc6-parsec-dev
14:12:00 <Mantaar> finally. Thanks, allbery_b, it was parsec-dev. :-)
14:12:11 <Mantaar> should've guessed it myself...
14:46:09 <newsham> ski: yah, i asked around and got a ref to conal's thing recently
14:47:00 <dainanaki> so I'm having some issues figuring out how to use the getargs imported from System.Environment
14:47:05 <dainanaki> anyone wanna help?
14:47:30 <newsham> main = getArgs >>= print
14:48:31 <dainanaki> thanks!
14:48:42 <dainanaki> that's exactly what I was looking for
14:48:45 <mauke> @redo main = getArgs >>= print
14:48:45 <lambdabot> main = do { a <- getArgs; print a}
14:50:49 <dibblego> has anyone written a wget function?
14:50:52 <dainanaki> so let's suppose that I wanted to take the arguments and seperate what they do into several cases, what would that look like
14:51:13 <dibblego> dainanaki, case match them inside a do block
14:51:33 <sethk> anyone seen this error (doing make install with the 32 bit intel linux binary 6.8.2 release)?  cd: 4: can't cd to base
14:51:36 <newsham> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/curl-1.3.1
14:51:37 <lambdabot> http://tinyurl.com/36p9nd
14:51:45 <newsham> ^^^ dibblego
14:51:46 <dibblego> newsham, nice one, thanks
14:53:17 <dainanaki> I'm just really confused how to keep IO from getting into everything...
14:53:52 <dibblego> dainanaki, getArgs comes from IO and must stay within it
14:53:56 <Heffalump> dainanaki: in the case of something like getArgs, you can just do the getArgs and call some pure function that processes them from main.
14:54:01 <dibblego> dainanaki, the type system forces this (and that's a good thing)
14:54:05 <Heffalump> so main is in IO, but the rest of your code isn't
14:54:24 <dibblego> main *must* be in IO, since main :: IO ()
14:54:30 <dainanaki> I understand that
14:54:34 <newsham> dai: you can get the arguments in main, and then use them to call a pure function, and use the results in main for more IO
14:54:47 <dainanaki> ok then
14:54:54 <newsham> like:   main = do { a <- getArgs; print (pureFunc a) }
14:55:04 <dainanaki> what if I wanted the arguments to be numbers for example
14:55:09 <newsham> or main = do { a <- getArgs; let val = pureFunc a; print val }
14:55:11 <dainanaki> say, a command-line calculator
14:55:23 <newsham> then you would use a function that converts strings to numbers
14:55:25 <newsham> like "read"
14:55:32 <newsham> > read "123" :: Int
14:55:34 <lambdabot>  123
14:55:50 <dainanaki> right, I was trying to write something like that, but I'm having a terrible time of it.
14:56:38 <newsham> main = do { [a,b] <- getArgs; let na = read a :: Int; let nb = read b; print (na + nb) }
14:56:44 <newsham> for example
14:57:01 <newsham> which will only work if there are exactly two args from getArgs
14:57:06 <newsham> and will give an error otherwise
14:57:09 <dainanaki> or else i could just use a fold
14:57:14 <newsham> yes.
14:57:23 <dainanaki> instead of doing pattern matching for the args
14:57:47 <newsham> do { as <- getArgs; let nas = map read as :: [Int]; print (product as) }
14:57:52 <newsham> do { as <- getArgs; let nas = map read as :: [Int]; print (product nas) }
14:57:54 <newsham> for example
14:58:41 <dainanaki> thanks, I think that ought to help get me on the right track.
14:58:51 <newsham> liftM (product . map read) getArgs >>= print
14:59:18 <Cale> heh, I just realised how punny Takusen is as a name for a database library :)
15:00:01 <dainanaki> isn't that japanese for oracle?
15:00:29 <skorpan> it kind of pisses me off that people know that stuff.
15:00:46 <newsham> why?
15:00:50 <xd> japanese?
15:01:02 <skorpan> that "takusen" is japanese for oracle
15:01:07 <dainanaki> i just recognized that it was japanese and plugged it into a dictionary :)
15:01:17 <Cale> dainanaki: yeah :)
15:01:19 <skorpan> :P
15:01:31 <Cale> skorpan: Why does it piss you off that people know other languages? :)
15:01:41 <dainanaki> I'm studying Japanese, but I don't know vague words like that
15:01:47 <skorpan> Cale: i thought he actually *knew* the word, which was what pissed me off
15:01:49 <dainanaki> er, not vague, but rare
15:01:52 <skorpan> you're not supposed to know stuff like that
15:02:00 <Cale> skorpan: huh?
15:02:00 <roconnor> dainanaki: maybe skorpan was refering to people in the board sense of humans with cybernetic google powers.
15:02:10 <skorpan> e.g. i know that takusen in japanese is 神託
15:02:23 <skorpan> which pisses me off
15:02:29 <skorpan> (since i wikipedia'd it)
15:02:29 <newsham> tako-san
15:02:41 <dainanaki> mr octopus?
15:02:42 <Cale> What's wrong with knowing that?
15:02:55 <Cale> and it's 託宣
15:02:59 <newsham> he doesnt like people knowing more about a subject than him?
15:03:06 <skorpan> http://ja.wikipedia.org/wiki/神託
15:03:08 <kfish> skorpan: you wrote shintaku
15:03:22 <sethk> might have lots of enemies, in that case
15:03:26 <newsham> oishi!
15:03:31 <kfish> ne!
15:03:41 <skorpan> i went to the english wikipedia article on "oracle" and then from there went to the japanese article
15:04:12 <dainanaki> different word for oracle
15:04:22 <skorpan> 日本語 <- how about that?
15:04:30 <skorpan> no wait
15:04:31 <dainanaki> that's definitely japanese
15:04:31 <roconnor> take it to #haskell.jp  :P
15:04:35 <skorpan> that's "japanese" :P
15:05:13 <newsham> -bah
15:05:15 <newsham> -blah
15:05:38 <ddarius> Everyone knows what 日本語 is.
15:05:53 <sethk> well, not me, actually
15:06:03 <skorpan> neither did i
15:06:06 <dainanaki> haha
15:06:09 <Cale> sethk: 'nihongo', it means Japanese.
15:06:15 <dainanaki> it's pretty common
15:06:23 <sethk> Cale, k, thanks
15:06:29 <dainanaki> Of course, I lived in Japan for a bit, so I have an excuse
15:06:35 <Cale> (as in the Japanese language)
15:06:48 <monochrom> If you have bought IBM products, you have already seen "日本語". :)
15:06:59 <sethk> seen, but not comprehended
15:07:05 <ddarius> Or if you've ever gone to wikipedia for any reason
15:07:05 <skorpan> who memorizes it?
15:07:22 <dainanaki> It's 日本 which means Japan
15:07:31 <skorpan> i'm an admin at swedish wikipedia and i have never really understood that it means "japanese" (obviously)
15:07:36 <newsham> nonpure needs to be kept on the #haskell-blah monad.
15:07:48 <dainanaki> and 語、which means language
15:07:56 <monochrom> Oh but you can guess.  Displayed in parallel:  English  Espanol  日本語  Everyone can guess it right.
15:08:29 <ddarius> 中国
15:08:33 <Twey> Everyone knows 中文 too
15:08:33 <dainanaki> chinese
15:08:39 <Twey> China
15:08:42 <skorpan> jesus, isn't that enough?
15:08:44 <monochrom> Haskell.
15:08:55 <dainanaki> i speak that a little bit!
15:08:56 <monochrom> English  Espanol  Haskell  :)
15:08:57 <Twey> 中国 = China, 中文 = Chinese (language)
15:08:59 <dainanaki> some of that haskell stuff
15:09:02 <Cale> ハスケル
15:09:13 <dainanaki> haskell
15:09:27 <dainanaki> alright, back to haskell then
15:09:35 <roconnor> 한국
15:09:37 <Twey> 「lambda」とは、日本語は何でしょうかな :-P
15:09:54 <monochrom> λ
15:10:03 <Twey> That's Greek :-P
15:10:10 <Twey> λ
15:10:11 <Twey> Hey
15:10:12 <dainanaki> 日本語のサバーください
15:10:13 <roconnor> Ελλάδα
15:10:27 <skorpan> what the.. i can see japanese symbols but not greek letters?
15:10:28 <Twey> My IME actually completes it
15:10:31 <monochrom> (λx→x) :: α→α
15:10:32 <Twey> skorpan: KDE?
15:10:42 <skorpan> Twey: what? no, emacs
15:10:51 <Twey> In what terminal?
15:10:53 <skorpan> it's terminus
15:10:55 <Twey> Oh
15:10:56 <skorpan> in emacs!
15:11:02 <Twey> Haha
15:11:03 <newsham> > let a Nothing x = x; a (Just y) x = a y (Just x) in a (Just (Just (Just ()))) (Just ())
15:11:03 <lambdabot>      Occurs check: cannot construct the infinite type: t = Maybe t
15:11:03 <lambdabot>       Expe...
15:11:20 <Twey> emacs may do many things, but AFAIK glyph rendering isn't one of them :-P
15:11:34 <skorpan> as i said, it's the font, nothing else
15:11:53 <Twey> Yeah, but some things are bad at glyph substitution
15:12:14 <skorpan> i'm not sure what glyph rendering/substitution means
15:12:25 <newsham> > let a Nothing x = x; a (Just y) x = a y (Just x) in a (Just (Just (Just Nothing))) (Just Nothing)
15:12:25 <lambdabot>      Occurs check: cannot construct the infinite type: t = Maybe t
15:12:25 <lambdabot>       Expe...
15:13:22 <byorgey> newsham: Maybe as Nat?
15:13:24 <Twey> skorpan: If a font doesn't have a certain character, something should look for another one that does and render the character using that font instead
15:13:38 <skorpan> oh.. emacs does that.
15:13:42 <Twey> What?
15:13:50 <newsham> byorg: yah but no work with the type system
15:13:53 <skorpan> it uses different fonts when the current one doesn't support them
15:13:53 <Cale> (In preferably a similar font)
15:14:07 <skorpan> atm it doesn't seem to work but when i use wikipedia-mode it does
15:14:21 <Twey> skorpan: emacs doesn't do that, whatever X interface you're using to it does
15:14:47 <skorpan> Twey: then how come it only happens in emacs?
15:15:09 <Twey> skorpan: Perhaps because you're using a different interface for emacs than anything else?
15:15:22 <skorpan> Twey: i'm not
15:15:33 <Twey> skorpan: You're running X, right?
15:15:37 <skorpan> or at least not that i know of
15:15:38 <skorpan> yes, X
15:15:56 <Twey> How are you running emacs under X?
15:15:58 <Twey> In a terminal?
15:16:01 <Twey> Using xemacs?
15:16:22 <skorpan> uh, just "normal" non-terminal emacs
15:16:28 <Twey> Argh
15:16:40 * Twey gives up and goes to read a book.
15:16:43 <newsham> heh
15:16:53 <newsham> "normal" involves a terminal :)
15:17:18 <augustss> yo
15:17:26 <skorpan> i have no idea what you guys are even talking about
15:17:43 <skorpan> <newsham> "normal" involves a terminal :)
15:17:45 <skorpan> what does that even mean?
15:17:53 <monochrom> I think that's wrong.
15:18:08 <newsham> theres a version of emacs that runs inside of your terminal window using curses
15:18:14 <newsham> and theres a version which opens its own X window
15:18:26 <skorpan> newsham: it's not the "normal" emacs... you use -nw for that.
15:18:41 <mauke> or DISPLAY= emacs
15:18:43 <monochrom> I agree about needing -nw.
15:18:46 <newsham> seemed pretty normal before X was invented
15:19:00 <monochrom> Oh did you just arrived here from the 1980s?
15:19:33 <newsham> sometimes emacs is even built without support for X
15:19:40 <newsham> its crazy,i know
15:19:43 <monochrom> Why don't you also talk about normality before transistors were invented.
15:19:51 <newsham> anyway, back to zmacs on the cadr
15:19:56 <skorpan> newsham: saying that "normal" emacs is non-X is just silly these days. i can't believe you even try to argue about it
15:20:14 <newsham> thats why its called "xemacs"
15:20:15 <monochrom> "normal emacs means taking 10 tonnes of vacuum tubes to run"
15:20:20 <radix> oh, dear.
15:20:20 <skorpan> newsham: no, it's not
15:20:24 <radix> "xemacs" is such an unfortunate name.
15:20:31 <newsham> mono: eight megs of vacuum tubes, and constantly swapping
15:20:32 <radix> newsham: xemacs does not mean "emacs for X"
15:20:33 <skorpan> xemacs and emacs are two different thingns
15:20:47 <newsham> ok i'm wrong about the "xemacs" thing
15:21:16 <b_jonas> let's call the simple emacs "gnu emacs" or "gemacs" or "stallman's emacs" or something
15:21:27 <wagle_home> original emacs for X was a disaster..  xemacs did it right..  dunno if that follows the politics of the fork though
15:21:28 <skorpan> stallman doesn't use a gui
15:21:29 <ddarius> There's a simple emacs?
15:21:30 <b_jonas> because there were other emacses before that
15:21:31 <dainanaki> stallmacs
15:21:36 <augustss> gnu emacs is too new
15:21:43 <b_jonas> in that case, there's no problem with the name "xemacs"
15:21:52 <augustss> gosling's emacs rulez!
15:22:01 <b_jonas> though really I don't care, I don't use neither x-based editors nor emacs
15:22:03 <monochrom> gosling's haskell  <duck>
15:22:07 <sieni> b_jonas: yeah, I think "gnu emacs" would be the preferable term for gnu emacs
15:22:11 <wagle_home> gosling emacs dereferences null..  8-p
15:22:21 <sethk> the mainline emacs has x support.  xemacs, AFAIK, still refers to the bad thing
15:22:30 <augustss> goslings's emacs had mocklisp
15:22:34 <Blicero_> fsf emacs
15:22:38 <augustss> lisp without lists
15:23:02 <monochrom> lambda emacs takes higher-order mode hooks :)
15:23:03 <ddarius> "Mocklisp a language for processing"
15:23:42 <augustss> Mocklisp had a good string type
15:23:44 <newsham> everyone knows vi is superior to emacs anyway
15:23:46 <newsham> <idles>
15:24:08 <augustss> newsham: yeah, I used to use vi too before I saw the light
15:24:10 <dainanaki> candles are better than monkeys!
15:24:11 <wy> newsham: why is it superior?
15:24:24 <wy> augustss: what's the light?
15:24:26 * Heffalump is not really convinced either is the light, it's just easy to stick with what you know
15:24:29 <sethk> I use both.  That way I use the one that makes my life easier at any particular moment.
15:24:31 <mauke> ravens are better than writing desks
15:24:34 <augustss> emacs shines!
15:24:35 <sek> heh that comment *always* sparks up debate
15:24:36 <monochrom> delimited continuation is superior to vi and emacs
15:24:47 <dainanaki> or notepad
15:24:54 <dainanaki> that thing is awesome
15:25:12 <augustss> I still can't stand watching people use vi, I hardly see anyone using it efficiently
15:25:12 <sethk> dainanaki, I might have a copy of wordstar here somewhere ...
15:25:12 <monochrom> notepad doesn't know unix line breaks.
15:25:26 <Heffalump> Igloo uses it efficiently, or at least seems to.
15:25:29 <monochrom> wordstar is awesome!
15:25:30 <dainanaki> i'm joking
15:25:33 * Heffalump doesn't use xemacs efficiently.
15:25:35 <sethk> augustss, vi is extremely efficient.  It was designed for the terminal world
15:25:40 <sethk> dainanaki, no!
15:25:45 <sethk> dainanaki, I never would have guessed
15:25:47 <mauke> When I use an editor, I don't want eight extra KILOBYTES of worthless help screens and cursor positioning code!  I just want an EDitor!!
15:25:53 <mauke> ot a "viitor".  Not a "emacsitor".  Those aren't even WORDS!!!! ED! ED! ED IS THE STANDARD!!!
15:25:56 <augustss> Heffalump: I'm sure there must be efficient vi users
15:26:00 <mauke> TEXT EDITOR.
15:26:05 <monochrom> C:> wordstar Main.hs
15:26:05 <wy> augustss: I can use both, but I like neither of them
15:26:09 <wagle_home> @yow
15:26:09 <lambdabot> Zippy's brain cells are straining to bridge synapses ...
15:26:13 <ATOMBOMB> wagle_home: Error: "yow" is not a valid command.
15:26:18 <augustss> those who can type d3t, without blinking
15:26:23 <sethk> augustss, absolutely.  I'm very quick with vi.  When I need macros, I fire up emacs
15:26:49 <sethk> augustss, I can type d3t without _looking_, so blinking is irrelevant.  If you don't touch type, vi is hard to use.
15:26:53 * augustss wrote a combinator reduction macro for vi
15:27:00 <newsham> ?echo ?echo
15:27:00 <lambdabot> echo; msg:IrcMessage {msgServer = "freenode", msgLBName = "lambdabot", msgPrefix = "newsham!n=chat@thenewsh.com", msgCommand = "PRIVMSG", msgParams = ["#haskell",":?echo ?echo"]} rest:"?echo"
15:27:14 <skorpan> you can typ d3t without looking? wow
15:27:30 <augustss> but d3t is an incomplete command
15:27:41 <sethk> augustss, don't change the subject
15:27:52 <Staz> So apparently functions with no arguments are constant values. But what exactly is their value?
15:27:53 <sethk> skorpan, for a small fee I'll give a demonstration.  :)
15:27:57 <b_jonas> d3t... what's "t"?
15:28:04 <b_jonas> is that like "f", character search?
15:28:04 <Staz> take '(10 +)' for example.
15:28:19 <augustss> Staz: there are no functions with no arguments, that's a contradiction
15:28:21 <mauke> yes, but not including the character itself
15:28:24 <wagle_home> > read
15:28:24 <lambdabot>  Add a type signature
15:28:37 <dibblego> there are constant functions
15:28:41 <dibblego> > let x = 7 in x
15:28:42 <lambdabot>  7
15:28:42 <sethk> augustss, an unapplied function has no arguments (or may have)
15:28:51 <kpreid> it depends on whether you consider a thunk a function
15:28:58 <b_jonas> (me looks up t in the help) yep, it is, I remembered right
15:28:59 <joricj> are threads cheap in haskell? i mean ... can i have 10.000 threads?
15:29:00 <kpreid> it depends on whether you consider a value in a typeclass a function
15:29:01 <EvilTerran> a thunktion?
15:29:03 <wagle_home> > read :: Int
15:29:03 <lambdabot>  Couldn't match expected type `Int'
15:29:05 <mauke> joricj: easily
15:29:10 <dibblego> Staz, what is take '(10 +)' ?
15:29:11 <EvilTerran> joricj, they are relatively cheap, yes
15:29:13 <ddarius> joricj: You can have quite a bit more than that.
15:29:18 <wagle_home> > read :: IO Int
15:29:18 <lambdabot>  Couldn't match expected type `IO Int'
15:29:20 <b_jonas> those f and t and F and T things are a good idea in vi
15:29:24 <ddarius> :t read
15:29:25 <lambdabot> forall a. (Read a) => String -> a
15:29:32 <wagle_home> doh
15:29:34 <Staz> dibblego : type error
15:29:35 <mauke> joricj: I ran 450000+ threads with no problems
15:29:40 <augustss> b_jonas: yes
15:29:40 <b_jonas> I should try to bind them to some key in my editor and try to see if I can use them
15:29:41 <joricj> because i was thinking i could simplify my code a lot by using many many more threads and dupChan
15:29:44 <EvilTerran> joricj, as ghc does them internally as green threads, instead of using the OS thread implementation
15:29:47 <dibblego> Staz, so clearly that's not a constant function then?
15:29:53 <b_jonas> they might make editing faster
15:29:55 <wy> mauke: what's that?
15:29:58 <sethk> mauke, I presume they weren't all computing at the same time.
15:30:02 <EvilTerran> ?hoogle readLine
15:30:02 <wagle_home> :t print
15:30:02 <lambdabot> No matches found
15:30:04 <lambdabot> forall a. (Show a) => a -> IO ()
15:30:07 <b_jonas> so any vi-ers use those often?
15:30:09 <EvilTerran> ?hoogle readLn
15:30:09 <mauke> sethk: http://mauke.ath.cx/stuff/haskell/stress.hs
15:30:09 <lambdabot> Prelude.readLn :: Read a => IO a
15:30:09 <lambdabot> System.IO.readLn :: Read a => IO a
15:30:15 <joricj> okay so i'll do that, thanks
15:30:16 <mauke> wy: what's what
15:30:17 <EvilTerran> wagle_home, was that what you were looking for?
15:30:23 <EvilTerran> b_jonas, which?
15:30:34 <b_jonas> EvilTerran: t and f and T and f
15:30:36 <Staz> dibblego : It has a constant value though?
15:30:39 <b_jonas> character search commands
15:30:56 <dibblego> Staz, no, it's a type error; it doesn't have any value
15:30:56 <EvilTerran> i didn't, but i'll bear them in mind now you've mentioned them ;)
15:30:56 <wagle_home> i dont do IO in haskell, just use ghci's implied IO
15:31:00 <augustss> Staz: every Haskell expression has a constant value
15:31:09 <wagle_home> the function that reads from stdin
15:31:17 <wy> mauke: about 450000+ threads. what's that about?
15:31:20 <EvilTerran> ?src readLn
15:31:20 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
15:31:29 <wagle_home> > readLn
15:31:30 <lambdabot>  Add a type signature
15:31:34 <EvilTerran> ?src readIO
15:31:34 <lambdabot> Source not found. Are you on drugs?
15:31:36 <EvilTerran> beh
15:31:41 <wagle_home> > readLn :: IO Int
15:31:42 <lambdabot>  <IO Int>
15:31:43 <mauke> wy: er. do you know what threads are?
15:31:47 <Staz> so the constant value of '(10 +) is just '(10 +)' ?
15:31:55 <augustss> Staz: yes
15:32:06 <augustss> Staz: the function that adds 10
15:32:09 <EvilTerran> (\x -> 10 + x), equivalently
15:32:14 <wagle_home> hmm..  ok..  i suppose thats a constant value, now that i think about it harder
15:32:18 <wy> mauke: of course. I mean I don't know why you talk about so many threads
15:32:20 <Staz> thanks very much augustss
15:32:30 <wy> mauke: lost context
15:32:42 <mauke> wy: because joricj asked
15:32:43 <roconnor> @karma+ augustss
15:32:43 <lambdabot> augustss's karma raised to 11.
15:32:43 <ATOMBOMB> roconnor: Error: "karma+" is not a valid command.
15:32:51 <augustss> wy: maybe mauke is talking to the wrong thread
15:32:51 <mauke> @wtf
15:32:51 <lambdabot> Maybe you meant: bf ft wn
15:32:52 <ATOMBOMB> mauke: (wtf [is] <something>) -- Returns wtf <something> is. 'wtf' is a *nix command that first appeared in NetBSD 1.5. In most *nices, it's available in some sort of 'bsdgames' package.
15:32:53 <EvilTerran> ... someone kill ATOMBOMB
15:32:59 <Japsu> DEATHBOMB
15:33:06 <wy> mauke: I see.. threads in haskell
15:33:07 <EvilTerran> @version
15:33:07 <lambdabot> lambdabot 4p597, GHC 6.8.2 (Linux i686 2.40GHz)
15:33:07 <lambdabot> darcs get http://code.haskell.org/lambdabot
15:33:11 <ATOMBOMB> EvilTerran: The current (running) version of this Supybot is 0.83.1+darcs.  The newest version available online is 0.83.3.
15:33:12 <ATOMBOMB> Title: Index of /lambdabot (at code.haskell.org)
15:33:23 <mauke> python?!
15:33:26 <Japsu> lol
15:33:28 <EvilTerran> what's it even doing in here? it's asking for an infinite loop.
15:33:29 <Japsu> heresy
15:33:30 <wy> mauke: I guess they are just implemented as continuations?
15:33:31 <Heffalump> bot wars!
15:33:34 <augustss> @wtf ATOMBOMB
15:33:34 <lambdabot> Maybe you meant: bf ft wn
15:33:34 <ATOMBOMB> augustss: Error: I couldn't find the wtf command on this system.  If it is installed on this system, reconfigure the supybot.plugins.Unix.wtf.command configuration variable appropriately.
15:33:43 <Heffalump> ATOMBOMB: die die die
15:33:43 <ATOMBOMB> Heffalump: Error: "die" is not a valid command.
15:33:49 <Heffalump> ATOMBOMB: quit quit quit
15:33:49 <ATOMBOMB> Heffalump: Error: You don't have the owner capability. If you think that you should have this capability, be sure that you are identified before trying again. The 'whoami' command can tell you if you're identified.
15:33:50 --- mode: ChanServ set +o Cale
15:33:55 --- mode: Cale set +b *!*@adsl-99-148-255-87.dsl.hstntx.sbcglobal.net
15:34:01 <mauke> ATOMBOMB: part
15:34:01 --- mode: Cale set -o Cale
15:34:15 <Cale> bye :)
15:34:18 <Heffalump> hmm, look at the channels it's on
15:34:36 <roconnor> Heffalump: how do I do that?
15:34:52 <Cale> roconnor: /whois ATOMBOMB
15:34:53 <mauke> /whois
15:35:03 <roconnor> \whois ATOMBOMB
15:35:07 <roconnor> crap
15:35:25 <roconnor> ok
15:35:38 <wy> I'm so sick of java. I don't want to TA a java course any more
15:36:01 <augustss> wy: teach them haskell istead and tell them it's java 1.9
15:36:04 <dibblego> wy, when I used to do that, I'd tell the students to see me after class if they want to learn about programming
15:36:16 <dibblego> wy, I'd usually have 2 or 3 after class
15:36:20 <TomMD> wy: Then don't - kill the TA of the Haskell course and take that.  (note to self: knowledge of Haskell makes me a marked target)
15:37:57 <b_jonas> lol
15:38:12 <b_jonas> "teach them haskell istead and tell them it's java 1.9"
15:39:06 <b_jonas> but first you need to write a library that allows you to write 'public static void main' instead of just 'main'
15:39:18 <EvilTerran> #define public
15:39:26 <EvilTerran> #define static
15:39:29 <EvilTerran> etc >:)
15:39:34 <wy> wagle_home: Do you think Kent Dybvig has enough power to prevent java overtake Indiana?
15:39:44 <joed> learn both and edjamacate people?
15:39:53 * EvilTerran parse errors
15:40:18 <mauke> module Main where main = Java.public () () ()
15:42:00 <dibblego> joed, you're way too optimistic; Java ninnies *hate* learning
15:43:02 <joed> dibblego: No they don
15:43:14 <joed> t :) The ones in ##java doing homework perhaps.
15:43:28 <dibblego> joed, I'm afraid so, but that's a lengthy discussion
15:43:30 <wagle_home> wy: no clue, havent been there for 10 years
15:43:41 <joed> dibblego: Yeah, we've had it.
15:43:58 <dibblego> joed, they don't consciously admit to hating to learn; we probably agree on that, but under the doublethink, they do indeed hate learning
15:44:06 <dibblego> joed, we can leave it at that ;)
15:44:28 <wy> wagle_home: I just visited Indiana :)
15:44:45 <wagle_home> wy: cool..  what'd you think?
15:44:54 <wy> wagle_home: I think I will go there
15:45:20 <talentless> is there a haskell function to go from a string "123" to an int 123 and if so what library is it in?
15:45:35 <Staz> read ?
15:45:37 <TomMD> talentless: "read"
15:45:38 <dibblego> > read "123" :: Int
15:45:39 <lambdabot>  123
15:45:39 <gnuvince_> talentless: read "123"::Int
15:45:44 <talentless> thanks
15:45:45 <joed> dibblego: I won't argue that :) I actually did not argue before either.
15:45:45 <Twey> trurl: Prelude
15:45:48 <Twey> Er
15:45:50 <Twey> talentless: ^
15:48:09 <Cale> talentless: You won't need to include an explicit type signature like that either, if it can be inferred that you need an Int
15:51:22 <roconnor> @seen conal
15:51:22 <lambdabot> I saw conal leaving #haskell and #ghc 1d 7h 45m 10s ago, and .
15:55:15 <Mantaar> uhm... what exactly am I doing wrong when ghc complains about the declaration of a type signature to not be in scope? (Which it can't be anyways, since I'm just declaring it)...
15:56:04 <newsham> ?hpaste mantaar -- put whole error msg online with more info?
15:56:04 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:56:25 <mauke> I don't think it complains about the declaration not being in scope
15:56:34 <mauke> because that doesn't really make sense
15:57:54 <Mantaar> ok, I though there would be something VERY obvious, but I'll just paste it away: http://hpaste.org/6566
15:58:03 <Mantaar> ... as you might have noticed. I'm a newb :-(
15:58:24 <mauke> obvious typo is obvious
15:58:35 <Mantaar> *mumble*
15:58:49 <newsham> "parseStirng"
15:58:53 <newsham> should be "parseString"
15:59:01 <Mantaar> goddamnit.
15:59:03 <newsham> it's complaining that you defined the type ofa function but not an implementation
15:59:23 <Mantaar> sorry. Yeah, of course. Makes SENSE... duh. I'll try to open my eyes next time...
15:59:24 <monochrom> We love newbies.
15:59:29 <monochrom> Tasty for breakfast.
15:59:36 <newsham> an extra pair of eyes always helps
15:59:49 <mauke> that's why I wear glasses
15:59:59 <Mantaar> hm... I should write a vim function or so that would catch such stupidity.
16:01:55 <monochrom> Oh! there is a typo.
16:03:16 <joed> dibblego: I'll concede the point, you are right, I'm wrong.
16:04:42 <falbani> Hi
16:05:05 <TomMD> hello falbani
16:05:07 <byorgey> hi falbani
16:06:01 <falbani> I need a way of getting the value under the curve of the gaussian distribution in Haskell...
16:06:21 <falbani> I google a little and I found this: http://article.gmane.org/gmane.comp.lang.haskell.cafe/11511
16:06:22 <lambdabot> Title: Gmane -- Mail To News And Back Again
16:06:57 <falbani> (the link in the mail is wrong... the correct one is http://iwi.wiwi.hu-berlin.de/~fis/code/ )
16:06:58 <lambdabot> Title: Index of /~fis/code
16:07:35 <augustss> falbani: "the value under the curve"?  do you mean the integral of the normal distribution?
16:07:42 <falbani> augustss: yes...
16:07:45 <falbani> Does GHC come with libraries for that?
16:08:11 <augustss> falbani: no.  Just pick a function from any language and rewrite it in Haskell
16:08:15 <augustss> it's easy
16:09:13 <augustss> google erf
16:09:22 <augustss> wikipedia has some links too
16:09:49 <falbani> I tried with GSL and gcc... but I could not compile the example in the documentation!!
16:11:08 <augustss> this is a good Fortran version http://www.netlib.org/specfun/erf
16:11:17 <mae_> anyone have an idea on how to fix this : http://rafb.net/p/u7dkuZ24.html
16:11:18 <lambdabot> Title: Nopaste - No description
16:12:14 <augustss> mae_: --make?
16:12:23 <falbani> augustss: thanks
16:12:40 <augustss> falbani: if you google you can probably find some C code
16:13:05 <augustss> falbani: the single precision version is pretty short, I don't know if you need double precision
16:20:08 <JohnMeacham> hmm... let's see what breaks with 30 bit Ints.
16:21:06 <augustss> woowoo, haven't seen any of those in a long time
16:21:25 <Heffalump> what are you going to do with the other 2 bits?
16:21:32 <dcoutts> sparc even has special instructions for tagged ints
16:21:46 <dcoutts> though I'm not quite sure how that works
16:22:05 <augustss> mmmm, tags!
16:22:08 <sethk> dcoutts, I think it does the right thing w.r.t. carries, and such
16:22:31 <dcoutts> but the tags are in the low bits arn't they?
16:22:39 <b_jonas> wow, really/
16:22:48 <b_jonas> special instructions for tagged ints/
16:22:51 <b_jonas> that sounds cool
16:22:53 <augustss> yes
16:23:01 <augustss> they are not that cool
16:23:04 <b_jonas> but it's not floating points, right?
16:23:12 <solrize_> sparc still has that?  i thought they got rid of it and it wasn't really done right to begin with
16:23:13 <augustss> int
16:23:33 <dcoutts> solrize: they don't want to break the abi, it's still there in sparc v9
16:23:37 <solrize_> oh
16:23:46 <Heffalump> if they were in the high bits you wouldn't need to do anything special with them when adding, would you? But you couldn't use the other tags for pointers very easily.
16:23:53 <augustss> i wonder who uses them?
16:24:06 <solrize_> it was intended for franz lisp, i think
16:24:09 <b_jonas> Heffalump: there's some problem with overflow
16:24:12 <opqdonut> Heffalump: err, overflow?
16:24:15 <augustss> adding is hard with high order tagging
16:24:18 <dcoutts> augustss: I don't think that matters, it's the principle of breaking the abi I think
16:24:31 <b_jonas> low bit tagging is usually better, yep
16:24:36 <opqdonut> kinda like all the cruft in the x86 instruction set
16:24:49 <dcoutts> right, they just make it perform terribly, but don't remove anything
16:24:50 <augustss> with high order tagging you need to mask before adding
16:24:51 <b_jonas> opqdonut: but they don't have tagged ints, do they?
16:24:59 <opqdonut> no
16:25:06 <b_jonas> or not yet
16:25:10 <opqdonut> but all sorts of funny stuff from the 8086 days
16:25:14 <b_jonas> it's growing, they could add it at some times
16:25:15 <dcoutts> though x86 has bcd ints iirc
16:25:17 <solrize_> the idea on the sparc was it had an add instruction that masked the tag automatically or something
16:25:18 <b_jonas> opqdonut: yeah
16:25:26 <opqdonut> dcoutts: exactly
16:25:29 <b_jonas> and only very few of those are removed even in x86_64
16:25:55 <solrize_> those weird old x86 instructions are generally in dog slow microcode in later x86's
16:25:57 <Heffalump> I don't follow. Why can't you just add and then reset the tag?
16:26:09 <solrize_> resetting the tag is an extra instruction
16:26:15 <Heffalump> ah, right.
16:26:28 <b_jonas> solrize: that's not always a problem
16:26:38 <b_jonas> that's what you get too when you tag with a set low bit
16:26:38 <JohnMeacham> Heffalump: various things.
16:26:42 <opqdonut> solrize_: yeah, the set of instructions that is actually used by compilers is pretty small
16:26:45 <augustss> generally low order tagging requires fewer instructions
16:26:48 <b_jonas> which you might want to do so that pointers are usable as is
16:27:04 <Heffalump> b_jonas: yeah, that was my original point
16:27:26 <b_jonas> Heffalump: but with low tagging, you can actually _detect_ the overflow
16:27:29 <solrize_> on the x86 low order tags are especially ok because they don't get in the way of pointers, you use the LEA instruction and can offset the tag as part of the instruction
16:27:31 <Heffalump> without a special instruction that blocks carry, low-order tagging will require masking too
16:27:31 <augustss> pointers are usable as is with low order tagging too
16:27:32 <b_jonas> the same way as with normal ints
16:27:51 <b_jonas> solrize_: hmm, makes sense
16:28:48 <solrize_> that's with a nonzero tag for pointers.  and with 0 for ints then you can just add tagged ints without masking
16:29:20 <Heffalump> oh, cunning
16:29:30 <JohnMeacham> Heffalump: http://repetae.net/computer/jhc/manual2.html#the-run-time-system
16:29:35 <Heffalump> though presumably your GC needs to be made aware of that
16:29:44 <augustss> oh yes
16:29:51 <Heffalump> but I guess you wouldn't be using the Boehm GC in such a situation anyway.
16:30:11 <b_jonas> solrize_: makes sense. or just normal indexing.
16:30:15 <solrize_> really the boehm gc is for legacy c programs and should not be used in a typed language
16:30:47 <Heffalump> yeah, but time-pressed compiler writers tend to use it :-)
16:31:01 <Heffalump> JohnMeacham: right, ta
16:31:26 <solrize_> that's really dangerous, let's say you write your web site with the boehm gc and somebody uploads a jpeg file, except it's concocted to be full of binary data that looks like pointers
16:31:35 <solrize_> bam your server is out of memory :)
16:31:48 <Heffalump> hehe
16:32:08 <JohnMeacham> solrize_: no, you allocate the data with the malloc_atomic routine which flags it as containing no pointers.
16:32:21 <solrize_> hmm
16:32:25 <solrize_> ok that helps
16:32:44 <JohnMeacham> but yeah, you can certainly do a lot better than the boehm gc when you have domain specific knowledge. jhc can use the boehm GC optionally in its back end.
16:33:23 <solrize_> i think you still have to be very careful about potentially hostile data in function args, static buffers or whatever
16:33:57 <solrize_> i guess boehm is ok as long as jhc is an experimental compiler but i hope it gets a real gc someday
16:34:40 <solrize_> as i remember jhc uses region inference sometimes?  that is REALLY cool
16:35:19 <b_jonas> lol
16:35:28 <b_jonas> sure you can
16:35:34 <b_jonas> there are very nice gcs out there
16:36:08 <JohnMeacham> solarize_: http://repetae.net/computer/jhc/results3.html
16:36:09 <lambdabot> Title: nobench: Haskell implementation shootout
16:36:09 <b_jonas> half a year ago, I read some article about them because I really didn't understand how they work
16:36:23 <JohnMeacham> here is a comparison between the static analysis (jhc_grin) and the boehm one.
16:36:25 <JohnMeacham> and ghc.
16:37:26 <b_jonas> now I understand some of it
16:37:30 <solrize_> looks like grin beats boehm just about always, not surprising; and boehm beats ghc sometimes but not always
16:37:36 <solrize_> ghc is supposedly getting a paralell gc soon
16:37:40 <b_jonas> but there are still so many variants and options that I still can't always follow them
16:37:49 <solrize_> i read chang's thesis recently it's pretty readable
16:37:53 <b_jonas> like which variant can be done with what set of callbacks needed
16:37:56 <solrize_> about the chang-blelloch algorithm
16:37:59 <solrize_> which is great
16:38:03 <b_jonas> chang's thesis? link?
16:38:13 <solrize_> lemme see if i can find it
16:38:50 <solrize_> sorry, cheng
16:38:51 <solrize_> sec
16:39:17 <solrize_> http://reports-archive.adm.cs.cmu.edu/anon/2001/CMU-CS-01-174.pdf
16:39:44 <solrize_> supposedly it gets a basically linear speedup with up to 64 processors
16:40:06 <b_jonas> I read this one on real-time generational: http://home.pipeline.com/~hbaker1/RealTimeGC.html
16:40:07 <lambdabot> Title: Comm. of the ACM 21, 4 (April 1978), 280-294.
16:40:15 <b_jonas> I really didn't undersand how real-time could work before that
16:40:21 <solrize_> yeah that's a classic
16:40:30 <b_jonas> even though it's actually simple once you understand it
16:40:38 <solrize_> there's a book by lins and jones which supposedly is the standard textbook i haven't looked at it yet
16:41:26 <b_jonas> solrize_: thanks for the link
16:41:29 <solrize_> np
16:43:17 <b_jonas> I wonder when hardware guys will come up with a cpu architecture that specifically supports parallel gc
16:43:23 <solrize_> yeah
16:43:34 <b_jonas> like some kind of assymetric multi-core design where some cores are specialized on gc
16:43:37 <b_jonas> it wouldn't be easy
16:43:50 <roconnor> b_jonas: hmm, maybe they could build a CPU with two cores, one to run the GC and the other to run the program. :D
16:43:55 <b_jonas> probably they someone could write a thesis if they design it
16:44:02 <b_jonas> roconnor: exactly
16:44:20 <JohnMeacham> like lisp machines?
16:44:25 <solrize_> i don't currently understand the cb algo in the sense of being able to explain it, i mean i read through the description and it made some sense at the time but i don't remember anything specific
16:44:40 <olsner> some kind of parallell memory, where each cell GC:s itself with suitable application of magic
16:44:49 <b_jonas> something even more ambitious would be to put gc in the memory controller locally
16:44:53 <solrize_> i didn't realize there was any parallelism in lisp machines
16:45:09 <b_jonas> eh, olsner was faster
16:45:34 <b_jonas> but that's probably very hard to do well too
16:46:29 <solrize_> maybe they'll stop putting cpu's in computers
16:46:39 <solrize_> you just get a giant fpga and configure it specifically to your application
16:47:05 <ddarius> That wouldn't gain you anything
16:48:16 <solrize_> eh?  it means if you want to use all the gates for a floating point matrix multiplier you can.  want a sorting network?  different configuration.  parallel encryption?  you get the idea
16:49:01 <solrize_> there's a good rant by dj bernstein about how N parallel units gets you effectively a more than linear speedup for many problems
16:49:48 <ddarius> Many small cores would probably be both faster and easier to build and program
16:49:54 <solrize_> b_jonas this paper is also good, it has the c-b benchmarks  http://www.cs.cmu.edu/~guyb/papers/gc2001.pdf
16:50:06 <solrize_> ddarius yeah maybe, djb likes to push things to their limits :)
16:52:49 <solrize_> johnmeacham are you doing anything about parallelism for jhc ?
16:57:58 <JohnMeacham> solrize_: nothing in particular.
17:01:31 <ehird> @src zipWith
17:01:31 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
17:01:32 <lambdabot> zipWith _ _      _      = []
17:02:41 <solrize_> jhc is awesome even on uniprocessors
17:03:04 <b_jonas> solrize_: I don't believe benchmarks, except those I do alone
17:03:09 <b_jonas> but I'll take a look at it anyway
17:09:00 <b_jonas> solrize_: ah, the first article you point to has a nice table summarizing gc algorithms
17:10:03 <b_jonas> useful
17:10:20 <solrize_> hmm
17:12:24 <b_jonas> nice thesis
17:12:29 <solrize_> yeah
17:13:06 <b_jonas> I should implement at least some garbage collectors once so I can really understand them
17:13:19 <b_jonas> (I did trivial reference counting once, but that doesn't count)
17:13:52 <solrize_> yeah i've never done any serious ones
17:15:29 <marshmallows> hello
17:15:39 <marshmallows> Has anyone tried CTM is haskell?
17:15:59 <solrize_> marshmallows hmm
17:16:11 <solrize_> i think not exactly
17:17:28 <blarz> @src zip
17:17:29 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
17:17:29 <lambdabot> zip _      _      = []
17:19:20 <dfeuer> zip iddy doodah
17:20:24 <solrize_> i wonder if there can be some static analysis that chooses between data structures depending on the context, i.e. something that could use a mutating structure instead of data.map if analysis showed the program never relied on map's persistence or purity
17:22:13 <olsner> i believe there are languages that store such information in the type system
17:22:37 <solrize_> interesting
17:22:54 <b_jonas> you could do that dynamically, couldn't you?
17:23:17 <b_jonas> you start with a mutating structure and replace it with a pure one if it turns out that you need it
17:23:17 <solrize_> with reference counts at all the map nodes?
17:23:25 <olsner> solrize_: http://en.wikipedia.org/wiki/Uniqueness_type
17:23:38 <b_jonas> that's what copy-on-write strings do in small I think
17:24:10 <b_jonas> olsner: is that the same as http://home.pipeline.com/~hbaker1/Use1Var.html ?
17:24:10 <lambdabot> Title: 'Use-Once' Variables and Linear Objects
17:24:30 <solrize_> not exactly the same but similar
17:25:46 <b_jonas> ok, good night now
17:25:52 <solrize_> i think it has to be done statically since you have to predict if there can be any future cpoying needed
17:25:53 <solrize_> copying
17:26:52 <roconnor> > product [1..10]
17:26:56 <lambdabot>  3628800
17:27:03 <Valodim> that took a while
17:27:14 <Valodim> > product [1..10]
17:27:15 <lambdabot>  3628800
17:27:27 <Valodim> ah, probably just some lag
17:28:45 <blarz> or cashed ;)
17:31:36 <roconnor> I don't suppose ``newtype Mu a = Roll { unroll :: Mu a -> a }'' is in one of the standard libs somewhere?
17:31:54 <EvilTerran> nop
17:32:05 <EvilTerran> i think 6.10'll have it in Data.Oleg
17:32:18 <marshmallows> is Mu due to Oleg?
17:32:19 <roconnor> :P
17:32:30 <marshmallows> I thought not
17:32:34 <EvilTerran> marshmallows, no, it's a rather old notation
17:32:37 <EvilTerran> but he uses it extensively
17:34:32 <solrize_> is augustss still here?  i have another dependent type question.  i'm wondering if it's possible to tell whether a type is "total"  ie. describes a unique function in Int->Int or whatever
17:35:57 <marshmallows> solrize_: No that's not part of the type
17:36:29 <marshmallows> solrize_: It's the language.. some are strongly normalizing and every function is total.. others are not, so you'd have to prove termination by inspecting the actual code
17:36:55 <roconnor> solrize_: it's probably undecidable, but provable in many cases.
17:36:57 <solrize_> i don't mean that the function is total (i'm assuming that all functions in these languages are total, i.e. general recursion isn't allowed)
17:37:22 <roconnor> solrize_: such types are called proof-irrelvent.
17:37:27 <roconnor> irrelevent
17:37:33 <solrize_> hmm, what's that mean?
17:37:44 <mauke> irrelevant
17:38:00 <roconnor> it means that if a, b : T, then a = b
17:38:05 <roconnor> ... for some definition of =
17:38:13 <solrize_> oh ok, yeah, that's exactly what i wanted to know
17:38:50 <solrize_> right it looks undecidable in general so i'm ok with user supplied proofs
17:39:26 <roconnor> @quote equality
17:39:26 <lambdabot> you'll says: probably still want unsafeEquality or whatever, though
17:39:34 <roconnor> @quote equality
17:39:34 <lambdabot> JamesMckinna says: We are once again left with the miserable prospect that it is equality that divides us.
17:39:35 <solrize_> basically i want to write some function (factorial or whatever) in haskell and find a type T that's precise enough to specify the function completely
17:39:54 <solrize_> then write it again in some typed assembly language with super duper optimization
17:40:04 <solrize_> and be able to certify that it computes the same function as the haskell version
17:40:17 <roconnor> solrize_: you probably can find many types that characterize factorial.
17:40:52 <roconnor> such as exists f, f = factorial
17:41:01 <roconnor> if you want to get right to the point. :)
17:41:08 <solrize_> factorial is just an example, there's a type for every predicate
17:42:01 <TomMD> How do I set the ghc debugger to break at exceptions?
17:42:15 <solrize_> and i want to say   forall x.  f x = g x
17:43:04 <olsner> TomMD: -fbreak-on-exception
17:43:17 <olsner> with :set or on the command line
17:43:28 <roconnor> exists f, forall x f x = factorial x
17:43:40 <solrize_> ok
17:44:00 <roconnor> that may be the same as f = factorial depending on your definition of =
17:44:11 <solrize_> is this a reasonable application?  i'd guess it'd be done a lot already if it makes any sense
17:44:16 <roconnor> or you can curry it
17:44:28 <roconnor> forall x. exists y. y = factorial x
17:44:55 <solrize_> yeah
17:44:58 <TomMD> olsner++
17:45:22 <roconnor> solrize_: I think it is a resonable application.
17:47:03 <solrize_> cool thanks
17:47:54 <sjanssen> @keal
17:47:54 <lambdabot> with KealDigit quantum crackproof encryption possible
17:48:43 <roconnor> solrize_: http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=71#more-71 is vaguely related.
17:48:44 <lambdabot> Title: FP Lunch  Blog Archive  Proof by Smugness
17:48:46 <EvilTerran> proof that someone is cracked?
17:49:52 <solrize_> roconnor yeah that looks great
17:49:54 <TomMD> @vixen If -fbreak-on-exception saved me, do I own AGill a dollar?
17:49:54 <lambdabot> good question
17:50:18 <solrize_> "my haskell function wasn't fast enough so i decided i better implement it in a lower level language.  i chose agda..."
17:50:38 <olsner> solrize: actual quote?
17:50:42 <TomMD> Scary
17:50:55 <roconnor> solrize_: where is that from?
17:51:02 <solrize_> olsner yeah, quote from me :)   describing what i was trying to do
17:52:17 <olsner> "Quoting myself is fun!"
17:52:29 <solrize_> heh
17:52:33 <solrize_> self-parody
17:52:43 <mauke> "I didn't say that!"  --me
17:52:43 <EvilTerran> "EvilTerran"
17:52:48 <EvilTerran> ... i don't really see the humour, TBH
17:53:29 <solrize_> that conor article looks spot-on, i just wish i could understand it
17:53:56 <solrize_> what's hutton's razor?
17:55:28 <olsner> seems to be the language of addition and values.... data Hutton = Val Int | Add Hutton Hutton
17:55:48 <augustss> "I quote myself sometimes...it adds spice to my conversation"
17:56:20 <olsner> "Indeed" --Teal'c
17:56:21 <roconnor> solrize_: he is making a data type for a stack language where it's semantics occurs in its type.
17:56:23 <solrize_> heh
17:57:15 <solrize_> roconnor yeah, i'm wondering how sane it is to want to extend that idea to complicated instructions of real cpu's
17:57:26 <augustss> I'm afraid mine wasn't mine, George Bernard S said it first
17:57:47 <solrize_> oh well
17:57:48 <roconnor> solrize_: it is sane for Intel to do.
17:58:23 <solrize_> hmm
17:58:31 <roconnor> solrize_: my main purpose to point you to that is to show assembly language whos behaviour is characterized by it's type.
17:58:44 <solrize_> yes
17:58:56 <solrize_> thanks
17:59:06 <roconnor> solrize_: Until recently I think you will find most people define f, define g, and seprarately prove that f = g.
17:59:17 <roconnor> which is still a reasonable thing to do.
17:59:53 <solrize_> i guess it's reasonable but normally wouldn't be done with types ?
18:00:28 <roconnor> not really, ... other than the fact that f = g is a type.
18:04:05 <joricj> in which library is fix defined (how would i go about finding out in which library $foo is defined)?
18:04:11 <mauke> @index fix
18:04:11 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
18:04:13 <solrize_> @src fix
18:04:13 <lambdabot> fix f = let x = f x in x
18:04:17 <solrize_> hmm
18:04:21 <mauke> @hoogle fix
18:04:21 <lambdabot> Data.Function.fix :: (a -> a) -> a
18:04:22 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
18:04:22 <lambdabot> Control.Monad.Fix :: module
18:04:34 <joricj> Data.Function?
18:05:13 <solrize_> anyway i'm totally clueless about this stuff, even clueless about how difficult it is to understand.  TAPL is on my endless reading list but i have no idea what i'm in for...
18:05:13 <EvilTerran> new with 6.8
18:11:20 <joricj> @index forever
18:11:20 <lambdabot> bzzt
18:11:28 <joricj> @src forever
18:11:28 <lambdabot> Source not found. Are you on drugs?
18:11:41 <joricj> !
18:11:45 <mauke> @hoogle forever
18:11:45 <lambdabot> Control.Monad.forever :: Monad m => m a -> m ()
18:14:15 <joricj> @src Control.Monad.forever
18:14:15 <lambdabot> Source not found. My pet ferret can type better than you!
18:14:56 <EvilTerran> forever m = m >> forever m
18:15:05 <mauke> forever = fix . (>>)
18:15:28 <solrize_> http://bp0.blogger.com/_Q0lTtPVTG40/R-Rn9FDqjbI/AAAAAAAAMGE/SY-m2Prhrxo/s1600-h/Giant+Rabbit.jpg   whoooa (watch out guy steele)
18:15:29 <lambdabot> Title: Giant+Rabbit.jpg (image), http://tinyurl.com/2j2ldm
18:16:00 <EvilTerran> ... is the kind of thing for #haskell-blah
18:16:10 <solrize_> heh
18:16:10 <vss> hi
18:17:22 <vss> I'm just starting with Haskell, and trying to catch AlreadyExists exception thrown by System.Directory.createDirectory. Tried google&hoogle but can't find which type it is and how I can handle it.
18:17:57 <vss> which module is it in? how do I pattern-match against it?
18:18:25 <roconnor> @hoogle catchJust
18:18:25 <lambdabot> Control.Exception.catchJust :: (Exception -> Maybe b) -> IO a -> (b -> IO a) -> IO a
18:18:26 <vss> more importantly, how can I find that out on my own
18:18:47 <vss> roconnor, yes. I'm asking about how to catch AlreadyExists:
18:18:57 <vss> create dir = do
18:18:57 <vss>   CE.handleJust someExceptions handler $
18:18:57 <vss>     System.Directory.createDirectory dir
18:18:57 <vss>   where
18:18:57 <vss>     someExceptions e@System.IO.Error.AlreadyExists = Just e
18:18:58 <vss>     someExceptions _ = Nothing
18:19:00 <vss>     handler e = do putStrLn $ "caught" ++ (show e)
18:19:08 <vss> (this doesn't compile)
18:19:31 <roconnor> vss close
18:19:40 <vss> ...because AlreadyExists is not in System.IO.Error
18:19:52 <mauke> isAlreadyExistsError :: IOError -> Bool
18:20:07 <roconnor> @hoogle AlreadyExists
18:20:07 <lambdabot> System.IO.Error.alreadyExistsErrorType :: IOErrorType
18:20:07 <lambdabot> System.IO.Error.isAlreadyExistsError :: IOError -> Bool
18:20:07 <lambdabot> System.IO.Error.isAlreadyExistsErrorType :: IOErrorType -> Bool
18:20:45 <solrize_> why does that throw an exception?  blecch
18:21:05 <EvilTerran> ?type createDirectory
18:21:06 <lambdabot> Not in scope: `createDirectory'
18:21:16 <vss> solrize_, I need to handle that condition, the directory exists already
18:21:22 <EvilTerran> ?hoogle createDirectory
18:21:22 <lambdabot> System.Directory.createDirectory :: FilePath -> IO ()
18:21:22 <lambdabot> System.Directory.createDirectoryIfMissing :: Bool -> FilePath -> IO ()
18:21:22 <lambdabot> Distribution.Simple.Utils.createDirectoryIfMissingVerbose :: Verbosity -> Bool -> FilePath -> IO ()
18:21:41 <roconnor> someExcpetion e | isAlreadyExistsError e = Just e
18:21:42 <vss> roconnor, so how do I use any of these?
18:21:45 <solrize_> yeah that's just a surprising way for the library to behave
18:21:53 <roconnor> someException e | otherwise = Nothing
18:21:58 <vss> roconnor, ah
18:22:04 <mauke> solrize_: why surprising?
18:22:10 <vss> roconnor, heh -- thanks :-)
18:22:29 <roconnor> @hoogle (a -> Bool) -> a -> Maybe a
18:22:30 <lambdabot> Data.Foldable.find :: Foldable t => (a -> Bool) -> t a -> Maybe a
18:22:33 <solrize_> mauke it doesn't return an Either or something like that
18:22:41 <roconnor> ha!
18:22:48 <mauke> solrize_: yes, it's in IO
18:22:51 <solrize_> actually there was a discussion about error handling the other night that pointed to some blog post
18:23:24 <roconnor> @djinn (a -> Bool) -> a -> Maybe a
18:23:25 <lambdabot> f a b =
18:23:25 <lambdabot>     case a b of
18:23:25 <lambdabot>     False -> Nothing
18:23:25 <lambdabot>     True -> Just b
18:23:36 <solrize_> johnmeacham :      Integer corresponds to IntMax rather than an arbitrary precision type. As soon as a suitable arbitrary precision library emerges, it will be replaced.
18:23:42 <solrize_> something wrong with gmpy?
18:24:45 <vss> thanks all
18:27:13 <solrize_> for "small" bigints (up to 2048 or maybe 4096 bits) libtom.org has some good fast code
18:27:20 <roconnor> vss: you may have to compose someExcecptions with ioErrors
18:27:30 <roconnor> @type ioErrors
18:27:31 <lambdabot> Not in scope: `ioErrors'
18:27:39 <roconnor> @hoggle ioErrors
18:27:39 <lambdabot> Control.Exception.ioErrors :: Exception -> Maybe IOError
18:29:10 <roconnor> @type (>.>)
18:29:11 <lambdabot> Not in scope: `>.>'
18:29:17 <roconnor> @hoogle (>.>)
18:29:17 <lambdabot> Did you mean: (>.>)
18:29:18 <lambdabot> Prelude.undefined :: a
18:29:18 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
18:31:16 <JohnMeacham> solrize_: something with good haskell bindings. or implemented in haskell.
18:31:48 <JohnMeacham> there are plenty of good C libraries.
18:33:00 <atp> xmonad dependencies in debian are annoyingly broken
18:33:55 <JohnMeacham> (int32_t)(int16_t)(uint16_t)64000 is very different than (int32_t)(uint16_t)6400
18:34:04 <dons> atp, how?
18:34:14 <dons> atp, please talk to Igloo. this is super important
18:34:26 <atp> ah?
18:34:31 <atp> they've been broken for a while
18:34:50 <solrize_> johnmeacham, oh i see, makes sense.  i thought i saw something on haskell.org recently about a pure haskell bignum lib, probably slow
18:34:51 <dons> atp, can you ask Igloo. you'll need to be more specific about what is wrong
18:34:58 <dons> atp, lots of people seem to be using them ok.
18:35:06 <sjanssen> atp: OOC, what is broken about them?
18:35:08 <solrize_> but what's "good haskell bindings"?  the ghc ffi?
18:35:15 <dons> atp, http://packages.debian.org/sid/xmonad ?
18:35:16 <lambdabot> Title: Debian -- Details of package xmonad in sid
18:35:19 <atp> no, no
18:35:44 <dons> sjanssen: note sparc and ia64 :)
18:35:45 <atp> the problem is that libghc6-xmonad-dev depends on the new version of ghc, which is in unstable but not in testing,
18:35:55 <elaforge> has anyone else noticed ghc being kinda inaccurate about "module unused" warnings?
18:35:58 <atp> but there is a version of xmonad in testing
18:36:06 <elaforge> I get "Warning: Module `Control.Concurrent.STM.TChan' is imported, but nothing from it is used,"
18:36:15 <solrize_> johnmeacham - http://isaac.cedarswampstudios.org/2007/HIntegerByInt/
18:36:17 <lambdabot> Title: Index of /2007/HIntegerByInt
18:36:19 <atp> so i can use xmonad fine (i'm using it now) but i can't configure it
18:36:20 <elaforge> but I do *too* use it
18:36:49 <dons> atp, if you feel this is wrong, please ask Igloo
18:36:59 <dons> he has maintainance privs
18:37:16 <atp> ok, i will do when i see him.
18:37:29 <dons> @seen Igloo
18:37:29 <lambdabot> Igloo is in #haskell, #haskell-soc, #darcs and #ghc. I last heard Igloo speak 1h 32m 40s ago.
18:37:52 <atp> i mean, sometimes when you're using testing you get this sort of situation
18:38:00 <sjanssen> elaforge: are you sure?  Double check that another module doesn't overlap Control.Monad.STM.TChan's exports
18:38:33 <elaforge> sjanssen: well, if I comment out the import, it breaks.  I'm using import qualified, so I use TChan.something
18:38:40 <JohnMeacham> solrize_: that code is extremely slow and pretty clunky.
18:38:41 <simony> hey, where's that cool augustss blog entry with the C in Haskell?
18:39:00 <solrize_> johnmeacham: heh i'm not surprised.
18:39:06 <atp> dons: what distro do you use?
18:39:20 <elaforge> sjanssen: would it make that noise if I could have technically typed e.g. STM.newTChan or something?
18:39:24 <dons> not debian :)
18:39:37 <idnar> atp: the version of libghc6-xmonad-dev in testing depends on the new ghc?
18:39:45 <solrize_> can jhc use ghc ffi stuff?
18:39:49 <Igloo> atp: xmonad is not in testing
18:39:57 <solrize_> or alternatively what's the obstacle to connecting up a c/asm library?
18:40:03 <idnar> oh, yeah, it's not
18:40:11 <atp> Igloo: then how on earth did i install it?  hmm
18:40:23 <atp> was it ever in testing?
18:40:28 <atp> i used to build it from source
18:40:31 <dons> maybe you got one of the .debs people were posting
18:40:50 <sjanssen> elaforge: maybe, I'm not particularly sure about that case
18:40:52 <atp> but then at some point i noticed it was showing up when apt-cache searched and so i installed it to save myself thetrouble
18:40:55 <atp> let me check
18:41:05 <dons> Igloo: i'm very impressed how debian cranks the handle, and all these builds on alphas, and ia64s et al start churning out
18:41:09 <dons> very nice
18:41:12 <sjanssen> elaforge: note that -Wall isn't required, either :)
18:41:25 <Igloo> dons: When it works, yeah  :-)
18:41:34 <elaforge> sjanssen: I know, but I do like the warnings, when they're not false positives that is
18:41:55 <elaforge> maybe I can turn off just that one...
18:42:01 <atp> hm, it does seem to only be in unstable... how weird
18:42:22 <elaforge> but it's so hard to miss it makes me thinking I'm doing something wrong
18:42:43 <atp> i don't really want to upgrade my whole system to unstable.  igloo, do you have any idea when those packages will be migrating into testing?
18:43:05 <Igloo> atp: No, sorry
18:43:10 <dons> so unstable -> testing -> stable ?
18:43:14 <atp> yeah.
18:43:15 <Igloo> yup
18:43:46 <atp> i feel like there must have been a testing package at some point in the past, back when there was the xmonad-rebuild package
18:44:01 <atp> but maybe i'm wrong...
18:44:44 <elaforge> -fno-warn-unused-imports, but that also hides the really unused imports.  oh well
18:44:52 <elaforge> sjanssen : thanks
18:46:34 <JohnMeacham> okay. regressions passed. jhc now uses 30 bit ints in general, you can extend them to 32 bits with -ffull-int. (they are always 32 bits on 64 bit archs)
18:47:07 <sjanssen> elaforge: have you tried the GHC flag that dumps minimal imports?
18:47:15 <sjanssen> -ddump-imports, or something like that
18:47:27 <elaforge> no, lemme try
18:47:30 <JohnMeacham> it would be nice if there were a flag to dump minimal exports...
18:47:30 <atp> wouldn't it be better to make them 30 bits on 64-bit arches as well, for compatibility, JohnMeacham?
18:47:42 <atp> barring an -ffull-int i mean
18:47:51 <JohnMeacham> atp: I don't see why, its not like ghc has compatable ints on the two.
18:48:36 <atp> JohnMeacham: i guess it just seemed like it might trip people up and we're going to see a lot of 32 -> 64 bit migration soon.  but it's nothing serious, i was just thinking aloud.
18:48:40 <JohnMeacham> and you arn't guarenteed anything on overflow anyway, so there is no way to tell the difference between 30 and 32 bit ints anyway.
18:48:44 <Igloo> JohnMeacham: So have you tested whether the 30bit Int is faster for real programs?
18:49:02 <JohnMeacham> Igloo: there is definitely a substantial memory savings.
18:49:22 <JohnMeacham> and hence less time spent allocating/collecting.
18:49:31 <Igloo> Ah, interesting
18:50:32 <diptansu> Hi there
18:50:47 <diptansu> I was wondering if anybody here has compiled hdirect recently?
18:50:49 <JohnMeacham> though. it would be nice if ghc used 32 bit ints everywhere. simply because 4 bytes per int is a lot to waste...
18:52:32 <roconnor> isn't that what Int32 is for?
18:53:07 <JohnMeacham> roconnor, no, Int32 is exactly 32 bits, and might even be slower than Int.
18:53:25 <JohnMeacham> and Int's appear all over the place, so the space is wasted everywhere.
18:54:09 <JohnMeacham> an Int is guarenteed to be at least 30 bits, but nothing else. so, any programs that actually use values > 30 bits are broken anyway and should be using Int64.
18:54:29 <elaforge> sjanssen: from the .imports file: import Control.Concurrent.STM(STM.newTChanIO, STM.writeTChan, STM.atomically)
18:54:54 <lament> any program that uses values > 30 bits is broken.
18:55:12 <JohnMeacham> certainly if they store them in Int's or Word's.
18:55:17 <elaforge> sjanssen: I guess it wants me to use STM.*TChan*
18:55:45 <roconnor> unless it checked maxBound
18:56:39 <elaforge> that error msg is kinda misleading though
18:56:40 <roconnor> I tend to use Int only when receiving a result from length.
18:57:06 <elaforge> and it seems more consistent to me to use the more specific module, unless it's explicitly private
18:58:40 <elaforge> sjanssen: anyway, thanks, I understand now
19:02:50 <solrize_> john i wish there was a compiler setting to trap int overflow
19:03:02 <solrize_> it seems like a big bug in haskell that int overflow can happen silently
19:03:15 <solrize_> also yes 64 bit ints would be good
19:03:24 <solrize_> or 62 bits or whatever
19:03:41 <roconnor> well, Int's are almost always wrong to use.
19:03:53 <solrize_> but the prelude uses them all over the place
19:04:06 <solrize_> and they'd be ok to use for lots of things if there were overflow traps just in case
19:04:29 <solrize_> @hoogle array
19:04:29 <lambdabot> Data.Array.IArray.array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
19:04:29 <lambdabot> Foreign.Marshal.Array :: module
19:04:29 <lambdabot> Data.Array :: module
19:04:36 <solrize_> :t Ix
19:04:38 <lambdabot> Not in scope: data constructor `Ix'
19:04:43 <solrize_> hmm
19:04:51 <solrize_> :t take
19:04:52 <lambdabot> forall a. Int -> [a] -> [a]
19:04:52 <EvilTerran> Ix is a class, not a value
19:05:02 <solrize_> :t (!!)
19:05:03 <EvilTerran> it doesn't have a type
19:05:03 <lambdabot> forall a. [a] -> Int -> a
19:05:06 <solrize_> :t (!)
19:05:07 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
19:05:10 <elaforge> :t genericTake
19:05:11 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
19:05:18 <EvilTerran> it doesn't even have a kind ;)
19:05:19 <solrize_> yeah but who wants to write THAT ?
19:05:28 <solrize_> generic take, i mean
19:05:31 <elaforge> not me, just sayin :)
19:05:35 <solrize_> :t length
19:05:35 <lambdabot> forall a. [a] -> Int
19:05:41 <solrize_> yada yada
19:05:41 <elaforge> I use Ints everywhere too
19:05:59 * EvilTerran uses Integer by default
19:06:46 <roconnor> Well, Ints are kinda okay for indexing into objects that are bounded by the size of addressable memory.
19:07:18 <solrize_> 30 or 32 bit ints are not long enough to hold pointers on today's machines
19:07:24 * sjanssen uses forall a. Num a => a by default :P
19:07:51 <roconnor> solrize_: and that is why on 64 bit machines, Ints ought to be bigger than 30 bits.
19:07:58 <solrize_> yeah
19:08:54 <roconnor> and I'm not certain that Int overflows are all that common when they are restricted to being used as indexes into structures.
19:09:39 <solrize_> there was some bad bug in an important program a while back where they were used to count network packets
19:09:50 <solrize_> the overflow led to some security failure
19:10:01 <roconnor> I suppose that may be an argument for trapping an overflow exception
19:11:04 <solrize_> yeah and in order to raise an overflow exception you have to check the result of every arithmetic op.  unfortunately there's no hardware int overflow trap on most machines afaik
19:11:49 <roconnor> anyhow, I don't think that using integers over 30 bits is buggy, or even non-portable.
19:12:23 <sjanssen> roconnor: relying on it in your program is a bug waiting to happen
19:13:00 <solrize_> well i'd expect "length xs" to give a correct answer
19:13:06 <solrize_> but it's an int
19:13:29 <EvilTerran> solrize_, i'd put that in roconnor's "restricted to being used as indexes into structures" category
19:13:31 <solrize_> and fairly cheap pc's these days can have 32 gb of memory
19:13:42 <solrize_> hm
19:14:07 <solrize_> maybe i'm not parsing the sentence correctly
19:14:10 <roconnor> solrize_: If you restrict the heap, then length xs should work.
19:14:12 <solrize_> i guess Ix could be an integer
19:14:13 <roconnor> in practice.
19:14:28 <solrize_> but why would i pay all that money for a 32 gb machine if i'm going to restrict the heap?
19:14:35 <solrize_> if i buy all that ram it's because i want to use it
19:14:48 <roconnor> solrize_: so you can run more than one process at a time.
19:14:54 <solrize_> hmm
19:15:05 <roconnor> solrize_: otherwise I suggest upgrading to a 64 bit processor.
19:15:33 <solrize_> yes the 32gb machine would have a 64 bit processor but it sounds like we're discussing 30 bit ints even on 64 bit cpu's
19:16:23 <solrize_> :t mmap
19:16:24 <lambdabot> Not in scope: `mmap'
19:16:32 <solrize_> @hoogle mmap
19:16:32 <lambdabot> No matches found
19:16:37 <roconnor> solrize_: right.  I'm saying that on a 64 bit machine you should use a haskell compiler ought to have at least 60 bits for an Int.
19:17:11 <solrize_> that's reasonable, 60 bits is enough to index anything real
19:17:30 <JohnMeacham> roconnor: not even C has more than 32 bits for Int. a lot of things use Int when they should be using WordPtr.
19:17:34 <solrize_> i think we have about 2**41 bytes of storage at work
19:18:36 <roconnor> JohnMeacham: I know, but because Haskell comes with Integer in the language standard, we should be less forgiving of improper use of Int.
19:18:57 <solrize_> i thought c had 64 bit ints on 64 bit machines
19:19:11 <JohnMeacham> roconnor: well, Integer is overkill for a lot of things, but certainly wherever C uses 'size_t' we should be using WordPtr.
19:19:14 <JohnMeacham> no.
19:19:16 <roconnor> solrize_: sadly not in most compilers.
19:19:16 <solrize_> and anyway programming in c is like juggling live chainsaws
19:19:37 <JohnMeacham> that is a good thing actually. 32 bit ints are faster, less memory intensive, etc.
19:20:01 <roconnor> 32 bit ints are faster on 64 bit processors?
19:20:06 <solrize_> well if they're 30 bits maybe they could automatically promote like in lisp
19:20:18 <solrize_> roconnor probably faster due to less cache pressure etc.
19:20:23 <JohnMeacham> yes. generally. plus cache issues outweigh most things nowadays.
19:20:54 <JohnMeacham> code size is larger too on some arches for 64 bit code.
19:21:29 <solrize_> x86-64 code size should be the same, or maybe even smaller because of the extra registers ?
19:21:30 <JohnMeacham> generally, the ABI defines 'int' to be the best general purpose integral type in terms of speed/size tradeoff.
19:21:49 <JohnMeacham> no, because the actual instructions are larger.
19:22:09 <solrize_> they are?!!  hmm i didn't realize that unless you're in 32 bit mode using 64 bit prefixes
19:22:12 <roconnor> Hmm
19:22:24 * solrize_ not an asm programmer, just play one on tv
19:23:25 <JohnMeacham> I forget exactly what the rules are.. I have my x86-64 manuals around here somewhere. amd is nice enough to send free hardcopies to anyone that asks.
19:23:36 <solrize_> yeah the manuals are all online too
19:23:39 <roconnor> I think the spirit of Int in the prelude is the size for indexing data structures.
19:23:50 <roconnor> but I admit this is subjective.
19:24:09 <roconnor> s/prelude/Haskell 98 standard/
19:24:14 <solrize_> 32 bits isn't enough to index data structures these days
19:24:20 <solrize_> and i think of int as being good for counting things
19:24:35 <JohnMeacham> http://www.x86-64.org/documentation/assembly.html
19:24:36 <lambdabot> Title: AMD64 Subpage
19:24:46 <solrize_> also disk files are data structures
19:24:55 <JohnMeacham> roconnor: I think it is the same as 'int' in C.
19:25:21 <JohnMeacham> yeah. for disk files we should be using IntMax for offsets.
19:25:25 <roconnor> JohnMeacham: I never got that impression
19:25:37 <roconnor> especially now that we have CInt.
19:25:43 <solrize_> i'm not so worried that 32 bits aren't "enough" but that i'll get caught by some surprising bug someday by relying on it without an overflow check
19:27:05 <roconnor> solrize_: that why you should use Integer by default. :)
19:29:23 <JohnMeacham> roconnor: CInt is just so we can specify foreign import/exports unambiguously, you don't actually want to use it in code.
19:30:05 <solrize_> roconnor i don't get to use integer by default as long as i code in natural style of using functions like "length" when i want the length of something
19:30:11 <roconnor> So you feel that Int outght be the same as CInt (but doesn't have to be).
19:30:21 <solrize_> what's Cint?
19:30:34 <roconnor> @hoogle CInt
19:30:34 <lambdabot> Foreign.C.Types.CInt :: data CInt
19:30:34 <lambdabot> Foreign.C.Types.CIntPtr :: data CIntPtr
19:30:35 <lambdabot> Foreign.C.Types.CIntMax :: data CIntMax
19:30:42 <solrize_> unboxed int
19:30:57 <JohnMeacham> roconnor, well I think it should be whatever is natural for the compiler/arch combo, as long as it is at least 30 bits.
19:30:58 <scook0> it's a type that's guaranteed to be compatible with a C-language "int" for FFI purposes
19:31:04 <joricj> @hoogle forkIO
19:31:04 <lambdabot> GHC.Conc.forkIO :: IO () -> IO ThreadId
19:31:04 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
19:31:14 <solrize_> scook0 oh ok that makes sense
19:31:36 <roconnor> JohnMeacham: I thought you just said it sould be the same as C's int.
19:32:15 <solrize_> i mean int overflow in some sense destroys haskell's type safety
19:32:19 <JohnMeacham> oh, simply because that is generally the best choice, as the designers of the CPU also designed the ABI spec and gave it the optimal int for the arch.
19:32:38 <roconnor> solrize_: I'd argue if you are calling length, then you are doing computations with indexing.
19:33:25 <solrize_> roconnor i'm not sure what you're getting at.  on a big machine i can call length and get back an answer > 2**30
19:33:34 <EvilTerran> length (repeat 1) -- it's broken anyway ;)
19:34:19 <scook0> > length (take (2^32) (repeat 1))
19:34:20 <lambdabot>  0
19:34:21 <solrize_> actually it doesn't even need a big machine, it could be the length of something coming from an i/o stream
19:34:22 <JohnMeacham> I should say that computations on Int's in jhc take place in 32 bits, but only 30 bits are preserved at the end. so you can't rely on overflow at 30 bits.
19:34:31 <roconnor> solrize_: I'm trying to aruge that Int ought to be bounded by approximately the size of the heap.
19:34:48 <roconnor> as oppose to being optimized for speed.
19:34:49 <JohnMeacham> roconnor: that is exactly what IntPtr is defined to be.
19:34:54 <sjanssen> roconnor: aren't you forgetting laziness?
19:34:57 <solrize_> roconnor then i think you are arguing that the prelude has specified the wrong type for length
19:35:13 <JohnMeacham> @type genericLength
19:35:13 <scook0> @hoogle genericLength
19:35:13 <roconnor> I've never heard of IntPtr before
19:35:13 <lambdabot> forall b i. (Num i) => [b] -> i
19:35:14 <lambdabot> Data.List.genericLength :: Num i => [b] -> i
19:35:21 <solrize_> do { x <- readFile "enormousfile.txt" ; print (length x) }   should be a reasonable way to find the length of a file
19:35:38 <roconnor> solrize_: perhaps I am.
19:35:48 <JohnMeacham> hah. that is in no way reasonable for reasons other than the type of 'length' :)
19:36:01 <solrize_> :)
19:36:04 <roconnor> solrize_: and if the file doesn't fit into the heap, then (lenght x) will crash.
19:36:11 <scook0> generally speaking, how much typeclass-specialization does GHC do?
19:36:22 <scook0> (i.e. in the absence of SPECIALIZE pragmata)
19:36:31 <solrize_> roconnor that shouldn't have to keep the file in the heap
19:36:33 <sjanssen> roconnor: no, it won't.  Remember laziness
19:38:40 <solrize_> actually that would be the number of characters in the file, and it's actually reasonable if say the file is in utf8, so checking the file size in bytes doesn't tell the actual number of unicode characters
19:38:48 <roconnor> solrize_: length x will force the file into memory in GHC.
19:39:01 <solrize_> it will?!!  hmm
19:39:03 <solrize_> that's not good
19:39:29 <roconnor> I'm pretty sure that length is a common technique for overriding the broken semantics of readFile.
19:39:51 <solrize_> well if you use length and then do something else with x...
19:39:57 <JohnMeacham> not only will it force the file, but it will force about 16 bytes to be allocated for each byte of the file.
19:41:00 <solrize_> i don't understand why it should force the file if it's written the obvious way
19:41:33 <solrize_> it sounds broken
19:42:20 <ddarius> liftM length (readFile "/dev/dsp")
19:44:30 <solrize_> like what if i wanted to count the lines in the file?    readFile "enormousfile.txt" >>= print . length . lines
19:44:32 <TomMD> Not being very involved in other Haskell projects (a major failing I constantly intend to fix), I often wonder how people do x,y,z.  So, when you have an intermediate function 'f' that wouldn't normally get exported out of module 'M', do you usually 1) not write tests 2) import QuickCheck into said module and have all tests internal 3) export the function anyway just so you can test it.
19:45:36 <dons> TomMD: i sometimes do 2) or 3), in particular
19:45:55 <solrize_> http://www.cse.unsw.edu.au/~dons/data/Basics.html
19:45:57 <lambdabot> Title: Haskell Unix Tools
19:46:05 <solrize_> -- Count number of characters in a file (like wc -c)
19:46:05 <solrize_> --
19:46:05 <solrize_> wc_c    = interact (showln . length)
19:46:08 <Jedai> It seems to me that length won't force the file in memory, except if you use its content afterward
19:46:08 <sjanssen> TomMD: I've also seen 4) export it conditionally using CPP
19:46:35 <solrize_> if it forces the file in memory then a bunch of the code in that page is broken
19:46:37 <dons> solrize_: length . lines runs in constant space
19:46:38 <TomMD> sjanssen: didn't consider that - thanks.
19:46:48 <solrize_> but length itself forces the file?
19:47:04 <dons> well, no, not really.
19:47:25 * solrize_ is confuuuuuuused
19:47:27 <dons> it'll compute the length lazily
19:47:41 <dons> the print demands a result
19:47:41 <solrize_> ohhhhhh
19:47:41 <Jedai> Well length force the reading of the entire file, but if you don't use it's content afterward, Haskell can garbage collect it as soon as it's read
19:47:48 <Jedai> So it will be in constant memory
19:48:04 <dons> it'll garbage collect pieces as it goes, yeah
19:48:18 <solrize_> hmm, "length $! x" ?
19:48:29 <solrize_> ok so it runs in constant space then
19:48:34 <solrize_> whew
19:49:34 <Jedai> solrize_: As long as you don't use the file content afterward, IOW, do { x <- readFile "Huge"; print $ length x; print $ take 10 x } is not okay
19:49:45 <solrize_> jedai right
19:49:48 <solrize_> that makes sense
19:50:31 <solrize_> although i gotta wonder if the lang. semantics says for sure what happens
19:51:08 <dons> its a non-strict language :)
19:51:28 <sjanssen> solrize_: the semantics are actually very loose
19:52:05 <solrize_> hmm
19:52:05 <sjanssen> theoretically, a compiler could fully evaulate the "take 10 x" before printing the file, making that code run in constant space
19:52:15 <sjanssen> this would require an incredibly smart compiler :)
19:52:15 <bos> here's a weird use of haskell: http://www.poetaexmachina.net/font/
19:52:16 <lambdabot> Title: kalliston!
19:52:27 <bos> to render ancient greek.
19:53:36 <solrize_> sjanssen yeah i'm wondering about whether the semantics say there can't be a space leak there
19:53:48 <solrize_> like i think they require tail recursion to not leak space
19:55:28 <sjanssen> solrize_: the semantics certainly allow a space leak
19:55:35 <solrize_> argggh
19:56:00 <sjanssen> note that I'm talking about Jedai's recent example
19:56:12 <sjanssen> also, Haskell doesn't require tail call optimization either :)
19:56:16 <ddarius> bos: That is rather bizarre.
19:56:33 <bos> especially the latin notation.
19:57:01 <Jedai> sjanssen: Yes, I wondered for a second if GHC could make that, but I guess it would really be too hard...
19:58:30 <misterPhyrePhox> hi
19:58:42 <misterPhyrePhox> is there a way to have alternatives in a pattern, and if either of them match, the whole pattern matches?
19:59:05 <misterPhyrePhox> like say x is a string, i want to do: case x of "blah", "b" -> doStuffBlah
19:59:11 <bos> nope.
19:59:19 <misterPhyrePhox> well blah :(
19:59:51 <ddarius> case x of x | x `elem` ["blah", "b"] -> doStuffBlah
20:00:06 <ddarius> misterPhyrePhox: If this is for argument handling, you may want to look at GetOpt
20:00:16 <roconnor> solrize_: well, I think the common use case of length x will use x again.
20:00:33 <ddarius> In fact, GetOpt should be appropriate even for some other things.
20:01:31 <roconnor> I suppose you ought to use genericLength for the readFile "enormousfile.txt" >>= print . length . lines example
20:02:05 <ddarius> There's a common use-case of 'length x'?
20:02:40 <misterPhyrePhox> ddarius, thanks, that's clever!
20:03:10 <ddarius> misterPhyrePhox: It's the "standard" solution (when possible)
20:03:12 <roconnor> ddarius: the common use case of 'length x' is occurs in poorly written code ;)
20:04:43 <solrize_> @hoogle a -> Int
20:04:43 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
20:04:43 <lambdabot> Prelude.fromEnum :: Enum a => a -> Int
20:04:43 <lambdabot> Prelude.floatDigits :: RealFloat a => a -> Int
20:05:08 <solrize_> err that search seems to have missed a lot :)
20:05:50 <roconnor> ddarius: I used length in my implementation of sha2
20:05:50 <solrize_> in fact i think int is the default interpretation of a numeric literal
20:06:03 <solrize_> > 2 + 3
20:06:08 <lambdabot>  5
20:06:08 <roconnor> hmm, maybe I assumed that Int was at least 32 bit.
20:06:13 <roconnor> bad me
20:06:22 <solrize_> I think that > 2 + 3 was an int calculation
20:06:30 <roconnor> no wait, i didn't use length
20:06:30 <dolio> > \() -> 5
20:06:30 <lambdabot>  <() -> Integer>
20:06:42 <solrize_> hmm
20:06:42 <roconnor> nevermind
20:06:42 <elaforge> the default declaration controls that
20:06:56 <solrize_> :t 3
20:07:00 <lambdabot> forall t. (Num t) => t
20:07:05 <solrize_> :t (3+5)
20:07:05 <lambdabot> forall t. (Num t) => t
20:07:09 <idnar> > \() -> 5 $ ()
20:07:09 <lambdabot>   add an instance declaration for (Num (() -> b))
20:07:19 <idnar> > (\() -> 5) ()
20:07:20 <lambdabot>  5
20:07:31 <idnar> > (\() -> 5) undefined
20:07:32 <lambdabot>  Undefined
20:07:37 <elaforge> here we go
20:07:38 <elaforge> Only one default declaration is permitted per module, and its effect is limited to that module. If no default declaration is given in a module then it assumed to be:
20:07:39 <elaforge>   default (Integer, Double)
20:07:46 <idnar> that's a pattern match on ()?
20:07:46 <solrize_> > 2147483647 + 2
20:07:47 <lambdabot>  2147483649
20:07:57 <dolio> Yeah.
20:07:57 <solrize_> > 2147483647 * 3
20:07:58 <lambdabot>  6442450941
20:08:38 <solrize_> oh of course, product [1..100] works
20:08:59 <elaforge> try "default (Int)" and see what happens
20:13:37 <marshmallows> @src guard
20:13:37 <lambdabot> guard True  =  return ()
20:13:37 <lambdabot> guard False =  mzero
20:14:15 <solrize_> @src (>>)
20:14:15 <lambdabot> m >> k      = m >>= \_ -> k
20:16:00 <solrize_> anyways, int overflow is a serious source of bugs in real world c programs, just like buffer overflow, type cast errors, etc.  it really seems like a horrible wart that it can happen in a purity-oriented language like haskell without the programmer resorting to out-of-the-way measures
20:18:55 <marshmallows> @index intercalate
20:18:55 <lambdabot> bzzt
20:19:01 <marshmallows> :t intercalate
20:19:02 <lambdabot> forall a. [a] -> [[a]] -> [a]
20:19:15 <marshmallows> ^ bug
20:19:45 <dolio> @hoogle intercalate
20:19:45 <lambdabot> Data.List.intercalate :: [a] -> [[a]] -> [a]
20:19:45 <lambdabot> Data.ByteString.intercalate :: ByteString -> [ByteString] -> ByteString
20:19:45 <lambdabot> Data.ByteString.Char8.intercalate :: ByteString -> [ByteString] -> ByteString
20:20:44 <marshmallows> I just added this Haskell version http://rosettacode.org/wiki/Amb#Haskell
20:20:46 <lambdabot> Title: Amb - Rosetta Code
20:20:49 <Adamant_> solarize_: since Haskell has no manual memory allocation, the security aspects of it are at least somewhat less relevant.
20:21:17 <dons> solrize_: i think the use of inductive structures also makes it less relevant
20:21:37 <lament> Peano numbers don't overflow!
20:21:48 <dons> many common idioms rely on induction on the structure of the type, rather than int or pointer math
20:21:59 <dons> also, that numbers default to Integer helps a lot too
20:22:19 <solrize_> good point about induction but i didn't realize numbers default to integer
20:22:31 <solrize_> that helps too i guess
20:22:33 <dons> right, it does. the defaults are Integer and Double
20:22:43 <dons> some people argue for Integer and Rational
20:22:58 <solrize_> yeah, scheme and common lisp do that
20:23:04 <dons> i think this is why we see so few complaints about buffer math going wrong
20:23:28 <solrize_> :t hGetBuf
20:23:29 <lambdabot> Not in scope: `hGetBuf'
20:23:52 <dons> there are low level functions for accessing foreign languages that are only lightly typed
20:24:24 <solrize_> right, the ffi is basically just machine types
20:24:31 <solrize_> that doesn't count though
20:24:41 <dolio> Once Cale succeeds in his quest to get length turned into genericLength (and so on), I imagine there will be no cause to complain.
20:24:45 <solrize_> it's mainly about expecting pure haskell code to do the right thing
20:25:12 <dolio> Since those are the only ways you'll accidentally get Ints using standard library code.
20:25:13 <dons> i guess we must just teach people that Int is not Integer or Nat
20:26:26 <solrize_> well really, that's ok if Int is only used in some special purpose types like arrays, the issue is that it is used (in non generic version) in too many standard functions
20:26:30 <solrize_> cale has the right idea
20:27:01 <solrize_> Int should even be renamed to unsafeInt or something like that
20:27:05 <solrize_> UnsafeInt
20:27:39 <dolio> Int isn't really used that much.
20:27:51 <dolio> length, take, drop, splitAt...
20:28:27 <dolio> to/fromEnum (that might be a good candidate for revising, I suppose).
20:28:30 <solrize_> i tend to use it anywhere i'd use an int in C (i.e. almost everywhere) but that means i'm a lamer and i should stop
20:29:45 <dolio> Oh, replicate and various index functions, too.
20:31:00 <solrize_> if they were written with integers and the compiler could optimize down to ints with automatic promotion that would be a big win
20:31:19 <dolio> Well, Integers are Ints with automatic promotion.
20:31:24 <solrize_> oh good
20:31:29 <dolio> @src Integer
20:31:29 <lambdabot> data Integer = S# Int#
20:31:29 <lambdabot>              | J# Int# ByteArray#
20:31:34 <dolio> @src Int
20:31:34 <lambdabot> data Int = I# Int#
20:31:53 <dolio> But you can't unbox it like an Int in really tight loops, I imagine.
20:32:14 <solrize_> hmm i'd hope the compiler could do that especially if it's generating native code
20:32:51 <idnar> I#?
20:33:23 <dolio> Well, that'd take something like generating two versions of the loop, one on unboxed Ints that tests for overflow all the time, and jumps to the other one in such a case.
20:33:31 <solrize_> dolio yeah
20:34:11 <dolio> Which I doubt gets done, but maybe I'm too pessimistic.
20:35:55 <marshmallows> no comments on my amb?  I guess it's ok then
20:36:00 <solrize_> amb?
20:36:07 <marshmallows> http://rosettacode.org/wiki/Amb
20:36:09 <lambdabot> Title: Amb - Rosetta Code
20:36:12 <marshmallows> I just added that Haskel one
20:36:35 <marshmallows> It's on a Monad so it's sort of cheating but Haskell can get away with it :P
20:36:48 <dolio> I don't know how much you'd gain having an unboxed loop that tests for overflow all the time over just using a boxed Integer.
20:38:20 <solrize_> hmm that looks weird i'm too haskell-impaired to see a fix right away but let me think about it
20:38:36 <dolio> marshmallows: Your amb is id.
20:38:59 <marshmallows> ugh, yeah thanks
20:39:06 <marshmallows> I forgot [] = mzero
20:39:21 <marshmallows> I fixed it
20:39:27 <dolio> Also, your 'if joins ...' might be expressed more nicely as: 'guard (joins w1 w2)'.
20:39:43 <marshmallows> true, but I want to use amb fail explicitly
20:40:18 <dolio> Well, you could always write it out explicitly in the code. :)
20:41:19 <dolio> I mean, define guard in the example, that is.
20:41:57 <ahunter> Suppose I'm writing a function which has a where/let clause, and it's not type checking.  Can I get GHC to tell me what it's inferring the type of the where-scoped variable to be?
20:42:18 <solrize_> > example = head $ [intercalate " " [w1,w2,w3,w4] | w1 <- ["the","that","a"], w2 <- ["frog", "elephant", "thing"],  w3 <-  ["walked", "treaded", "grows"],  w4 <-  ["slowly", "quickly"], joins w1 w2, joins w2 w3, joins w3 w4]
20:42:18 <lambdabot>  Parse error at "=" (column 9)
20:42:35 <solrize_> intercalate should be outside the listcomp etc.
20:42:45 <solrize_> but can't you just basically write it like that?
20:43:06 <solrize_> actually i guess it should be inside
20:43:12 <dolio> Yeah.
20:43:36 <dolio> [ e | x <- l , b ] = do x <- l ; guard b ; return e
20:44:31 <dolio> Probably with parentheses needed.
20:47:13 <solrize_> :t foldl
20:47:14 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
20:48:04 <idnar> "The Amb operator takes some number of expressions (or values if that's simpler in the language) and nondeterministically yeilds the one or fails if given no parameter, amb returns the value that doesn't lead to failure."
20:48:09 <idnar> that sentence doesn't quite parse
20:48:20 <solrize_> yeah i couldn't understand it either
20:48:26 <solrize_> like, choose one at random?
20:48:50 <solrize_> http://hpaste.org/6568   there should be a way to replace that guard with a fold
20:48:51 <idnar> "yeilds the one or fails if" seems to be missing at least a full stop, and maybe some other words
20:49:32 <idnar> http://www.randomhacks.net/articles/2005/10/11/amb-operator explains amb, which I've read before; but I guess someone should fix that description on rosettacode
20:49:32 <lambdabot> Title: McCarthy's Ambiguous Operator
20:49:34 <ahunter> solrize_: would "The Amb operator takes some number of expressions/values, and nondeterministically yields one of its arguments, choosing so as to avoid failure" be better?
20:49:45 <solrize_> ahunter i don't know what they were trying to say!
20:50:53 <ahunter> heh
20:51:15 <ahunter> Well, it's simple.  All it does is magically pick something so that the program works! :P
20:51:18 <solrize_> yeah, amb looks exactly like the list monad
20:51:19 <idnar> heh
20:51:27 <solrize_> i think the listcomp is the most straightforward translation
20:51:35 <ahunter> solrize_: it pretty much is, it just only returns a single value (iirc?)
20:51:41 <ahunter> at least, traditionally it does
20:52:00 <solrize_> i'm looking at the description on idnar's link
20:52:15 <solrize_> oh it cites mccarthy's paper
20:52:17 <solrize_> http://citeseer.ist.psu.edu/mccarthy63basis.html
20:52:25 <lambdabot> Title: A Basis For A Mathematical Theory Of Computation - McCarthy (ResearchIndex)
20:52:54 <solrize_> "computation is sure to become one of the most important of the sciences"    -- J. McCarthy, 1963
20:54:30 <ahunter> OK, this is pissing me off.  Anyone have experience with haskell-mode for Emacs?  The indent stuff is breaking (for me...)  Specifically, if I put a line like "x <- readTVar foo" in a do expression, the next line will be aligned to readTVar, not x.  I think this is probably Wrong.
20:54:43 <solrize_> hit tab again
20:55:04 <dolio> Yeah, tab cycles through possible indents.
20:55:11 <ahunter> nope, it's pretty certain about that position
20:55:22 <dolio> Says it's the only one?
20:55:29 <solrize_> hmm
20:55:35 <ahunter> I get a message (like) "Indent cycle (4)..."
20:55:45 <ahunter> ah, hmm
20:55:53 <ahunter> if I hit it two or three times it finally gets it right
20:55:56 <ahunter> sorry
20:56:16 <lament> emacs is not smart enough to figure out unambiguously how you want the line to be indented
20:56:20 <lament> probably because it's impossible
20:56:20 <ahunter> ah
20:57:02 <dolio> I've recently returned to haskell-mode and it doesn't seem as smart as I remember.
20:57:15 <ahunter> dolio: what did you use before, is there a better alternative?
20:57:55 <dolio> Well, just prior, I was using vim instead, which doesn't have that sort of cyclic indenting.
20:58:02 <solrize_> @hoogle foldl1
20:58:03 <lambdabot> Prelude.foldl1 :: (a -> a -> a) -> [a] -> a
20:58:03 <lambdabot> Data.List.foldl1 :: (a -> a -> a) -> [a] -> a
20:58:03 <lambdabot> Data.Foldable.foldl1 :: Foldable t => (a -> a -> a) -> t a -> a
20:58:22 <dolio> But it did just align with the 'x' in your example, which is usually what I want.
20:58:35 <dolio> Instead of being the 3rd most likely thing that I'd want.
20:58:45 <solrize_> @hoogle intercalate
20:58:45 <lambdabot> Data.List.intercalate :: [a] -> [[a]] -> [a]
20:58:45 <lambdabot> Data.ByteString.intercalate :: ByteString -> [ByteString] -> ByteString
20:58:45 <lambdabot> Data.ByteString.Char8.intercalate :: ByteString -> [ByteString] -> ByteString
20:58:50 <solrize_> @hoogle intersperse
20:58:50 <lambdabot> Data.List.intersperse :: a -> [a] -> [a]
20:58:50 <lambdabot> Data.ByteString.intersperse :: Word8 -> ByteString -> ByteString
20:58:50 <lambdabot> Data.ByteString.Char8.intersperse :: Char -> ByteString -> ByteString
21:00:21 <dolio> haskell-mode has its own ideas about if-then-else, too, which aren't even valid in a do block.
21:00:49 <dolio> I usually go with then and else indented more than if, but haskell-mode wants to align them all.
21:01:09 <dolio> And even if I indent 'then' more manually, it aligns the else with the if instead of the then.
21:01:49 <dolio> Which is never valid, I think.
21:03:09 <solrize_> :t scanl
21:03:10 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
21:03:20 <solrize_> :t scan
21:03:22 <lambdabot> Not in scope: `scan'
21:04:06 <solrize_> :t scanl1
21:04:08 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
21:04:54 <solrize_> does the function i'm looking for exist?
21:05:10 <dolio> What are you looking for?
21:05:27 <solrize_> func f [a,b,c,d] = [(f a b), (f b c), (f c d)]
21:05:55 <solrize_> etc
21:05:59 <dolio> > ap (zipWith f) tail $ [a,b,c,d]
21:06:03 <lambdabot>  Add a type signature
21:06:09 <dolio> > ap (zipWith f) tail $ [a,b,c,d] :: [Expr]
21:06:12 <solrize_> aha
21:06:13 <lambdabot>  [f a b,f b c,f c d]
21:06:15 <solrize_> :t ap
21:06:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:06:41 <dolio> That's '\l -> zipWith f l (tail l)'
21:15:09 <solrize_> http://hpaste.org/6568#a1   how's this ?
21:17:03 <solrize_> marshmallows ?
21:18:34 <marshmallows> ?
21:18:40 <marshmallows> in what respects
21:19:04 <solrize_> the version i pasted seems like a more idiomatic use of the list monad, i'm asking what you thought
21:19:57 <solrize_> i guess alljoins should say ws instead of w
21:24:14 <solrize_> i'm wondering how you feel about putting the listcomp version on rosetta if we're trying to illustrate haskell
21:24:20 <marshmallows> no
21:24:32 <marshmallows> it's demonstrating Amb in various languages
21:24:50 <marshmallows> you can write this program in loads of ways
21:25:00 <solrize_> right
21:25:05 <marshmallows> but the aim is to do it with amb and amb fail
21:25:11 <marshmallows> if you want to see something horrible I just added a C version
21:25:35 <solrize_> wow!
21:25:50 <roconnor> marshmallows: shouldn't you use guard instead of your if statements?
21:25:55 <roconnor> @src guard
21:25:56 <lambdabot> guard True  =  return ()
21:25:56 <lambdabot> guard False =  mzero
21:25:57 <marshmallows> roconnor: no
21:26:03 <solrize_> i'm not sure what you mean about amb fail but i'll leave it to you
21:26:04 <roconnor> oh right
21:26:28 <roconnor> @src unless
21:26:28 <lambdabot> unless p s = if p then return () else s
21:26:39 <roconnor> marshmallows: you want to use unless
21:26:41 <marshmallows> amb with zero arguments or empty list is fail, as in mzero
21:26:49 <solrize_> list fail is []
21:26:58 <marshmallows> unless (joins w1 w2) (amb []) -- like this?
21:27:06 <roconnor> yes
21:27:12 <roconnor> or
21:27:14 <marshmallows> ok thank you
21:27:23 * solrize_ confused
21:30:59 <dolio> Well, I give up trying to get haskell-mode to indent ifs the way I want.
21:31:00 <wkh> how does haskell automatically generate instance declarations of simple data types?
21:31:14 <wkh> like if i type data Day = Sun | Mon | Tue | Wed | Thu | Fri | Sat deriving (Eq, Ord, Enum, Show)
21:31:25 <solrize_> there's special compiler hair for those specific classes
21:31:30 <wkh> say i type data Day = Sun | Mon | Tue | Wed | Thu | Fri | Sat deriving (Eq, Ord, Enum, Show)
21:33:44 <dolio> It's not too hard to come up with some simple rules for that stuff.
21:33:49 <dolio> Sun == Sun, etc.
21:33:56 <dolio> Sun < Mon, etc.
21:34:08 <dolio> succ Sun = Mon ...
21:34:16 <dolio> show Sun = "Sun"
21:35:15 <dolio> Going based on the ordering in which you list the constructors, when ordering is required.
21:36:14 <ddarius> @where report
21:36:14 <lambdabot> http://www.haskell.org/onlinereport/
21:36:17 <ddarius> It says in there.
21:40:06 <dolio> You could probably derive Bounded even for non-enumeration types, but I guess that isn't done.
21:42:38 <solrize_> @src all
21:42:38 <lambdabot> all p =  and . map p
21:42:53 <solrize_> @pl all p = and . map p
21:42:53 <lambdabot> all = all
21:42:57 <solrize_> hah
21:47:17 <ahunter> :t writeTVar
21:47:18 <lambdabot> Not in scope: `writeTVar'
22:06:47 <roconnor> > 1 / 7
22:06:49 <lambdabot>  0.14285714285714285
22:31:50 <Staz> Hi, what is wrong with 'tail [1,2,3,4,5] ++ head [1,2,3,4,5]' ?
22:32:06 <roconnor> head x is not a list
22:32:17 <Staz> oh duh :)
22:32:17 <Staz> thanks very much
22:33:15 <Staz> tail [1,2,3,5] ++ head [1,2,3,4,5] : []
22:33:16 <roconnor> > take 1 [1,2,3,4,5]
22:33:17 <Staz> that did the trick
22:33:18 <lambdabot>  [1]
22:33:29 <Staz> oh very nice :)
22:33:48 <roconnor> > drop 1 [1,2,3,4,5]
22:33:49 <lambdabot>  [2,3,4,5]
22:34:21 <roconnor> > let f l = tail l ++ head l : [] in f [1,2,3,4,5]
22:34:22 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
22:34:22 <lambdabot>       Expected...
22:35:00 <roconnor> > let f l = tail l ++ (head l : []) in f [1,2,3,4,5]
22:35:01 <lambdabot>  [2,3,4,5,1]
22:35:08 <roconnor> > let f l = tail l ++ (head l : []) in f []
22:35:09 <lambdabot>  Exception: Prelude.tail: empty list
22:35:29 <roconnor> > let f l = drop 1 l ++ take 1 l in f []
22:35:30 <lambdabot>  []
22:35:50 <roconnor> Staz: depending on what you are trying to do, I might recommend drop and take
22:36:11 <marshmallows> > tail [1,2,3,5] ++ [head [1,2,3,4,5]]
22:36:12 <Staz> after seeing your examples I definitely agree.
22:36:12 <lambdabot>  [2,3,5,1]
22:36:13 <ddarius> rotating a list is usually not the best of ideas
22:36:15 <roconnor> > let (a,b) = splitAt 1 [1,2,3,4,5] in b++a
22:36:16 <lambdabot>  [2,3,4,5,1]
22:36:27 <roconnor> > let (a,b) = splitAt 1 [] in b++a
22:36:28 <lambdabot>  []
22:36:39 <roconnor> ddarius: one step at a time :)
22:36:44 <marshmallows> > [head [1,2,3,4,5]] : tail [1,2,3,4,5] -- rotating this way uses less effort
22:36:44 <lambdabot>   add an instance declaration for (Num [t])
22:36:50 <marshmallows> > head [1,2,3,4,5] : tail [1,2,3,4,5] -- oops
22:36:51 <lambdabot>  [1,2,3,4,5]
22:37:08 <ddarius> head l : tail l = id
22:37:08 <whee> > liftM2 take length (tail . cycle) [1,2,3,4,5]
22:37:09 <lambdabot>  [2,3,4,5,1]
22:37:23 <ddarius> (if length l > 0)
22:37:28 <roconnor> @free head
22:37:29 <lambdabot> f . head = head . $map f
22:37:40 <roconnor> oh
22:42:21 <chrisdone> hi
22:43:18 <roconnor> hi
22:47:08 <Staz> Foo(x1:x2:x3:xs)  <-- Is there any other ways of specifying that the list must have at least three elements?
22:47:53 <roconnor> Staz: that's probably one of the best ways.
22:48:11 <roconnor> this may be a sign you are using a poor datatype.
22:48:17 <marshmallows> -- The list must have 3 elements
22:48:34 <roconnor> marshmallows: that's even worse :)
22:48:53 <Staz> roconnor : I find that I need to reconstruct the original list in the function definition. eg :  "where mylist = x1 : x2 : x3 : xs"
22:49:09 <Staz> I don't *need* to but it certainly makes things less messy
22:49:19 <marshmallows> roconnor: Ideally you could put (List (S (S (S _))) a)...
22:49:28 <roconnor> Staz: Foo ((x1 : x2 : x3 :xs)@x)
22:49:33 <roconnor> x will be bound to the original list
22:49:48 <Staz> That is the coolest thing I have learnt all day!
22:49:49 <roconnor> Staz: Foo ((_ : _ : _ : _)@x)
22:49:53 <roconnor> nameless way
22:49:54 <chrisdone> i did not know you could use that operator postfix
22:50:09 <roconnor> oh wait
22:50:14 <roconnor> maybe it is x@
22:50:18 <roconnor> I forget
22:50:21 <roconnor> maybe it doesn't matter
22:50:35 <Staz> I love all the syntax sugar :)
22:50:54 <roconnor> > let f ((a,b)@(c,d)) = [a,b,c,d] in f (1,2)
22:50:54 <lambdabot>  Parse error at "@(c,d..." (column 13)
22:50:57 <Staz> I can't wait until my Haskell book finally arrives in the mail.
22:51:10 <roconnor> > let f (a@(c,d)) = [a,c,d] in f (1,2)
22:51:11 <lambdabot>      Occurs check: cannot construct the infinite type: t = (t, t1)
22:51:11 <lambdabot>       Expe...
22:51:22 <roconnor> > let f (a@(c,d)) = (a,c,d) in f (1,2)
22:51:23 <lambdabot>  ((1,2),1,2)
22:51:36 <chrisdone> perhaps Foo l | length l >= 3 =  ...?
22:51:36 <roconnor> > let f ((a,c)@d) = (a,c,d) in f (1,2)
22:51:36 <lambdabot>  Parse error at "@d)" (column 13)
22:51:50 <roconnor> ah chrisdone is right.
22:52:05 <roconnor> Staz: sorry it is x@(...)
22:52:19 <chrisdone> ah, right
22:52:40 <roconnor> chrisdone: calling length is slightly worse because it is O(n)
22:53:09 <roconnor> especially bad when n = infinity
22:54:46 <chrisdone> roconnor: ah, yes.
23:14:03 <cjs> Staz: which book did you order?
23:16:10 <cjs> Actually, I'm curious. When pattern matching something like "foo x:xs = x:xs", will the cons be optimized away?
23:16:50 <Staz> cjs : Haskell School of Expression
23:17:06 <cjs> Oh, great book.
23:17:18 <Staz> good to hear :)
23:17:45 <solrize_> is there a simple way to test for pattern match?  i.e.   if (x:y:ys matches z) then ...
23:17:49 <cjs> I was just realizing that some of the stuff he does for animations applies directly to my trading system, which also basically operats in "ticks".
23:18:05 <cjs> solrize_: why would you want to do that?
23:18:19 <cjs> A pattern match is a sort of an "if", isn't it?
23:18:25 <solrize_> yeah
23:19:02 <solrize_> inside a function body it's not always convenient to use a let or case
23:19:05 <cjs> (BTW, when I say, "Why would you want to do that?" it's genuine curiousity, not "You don't want to do that.")
23:19:17 <solrize_> and pattern matches seem to only work at the top level of a fcn def or in those statements
23:19:29 <cjs> Then use a where. :-)
23:19:47 <cjs> I'd be curious to see an example of where it's not convenient.
23:19:48 <solrize_> well anywhere you say "if (not null blah) ..." you might instead want to say "if (x:xs) matches blah..."
23:19:59 <solrize_> hmm lemme see if i can find one
23:20:37 <cjs> Isn't "if (not null blah)" the "x:xs" pattern?
23:20:59 <solrize_> right, x:xs is a little clearer maybe
23:21:16 <Staz> what is the difference between "let <stuff> in <stuff>" and "<stuff> where <stufff>" ?
23:21:33 <ddarius> let is an expression, where is (part of) a declaration
23:21:49 <solrize_> i just remember there have been times i've used a let or case even though i didn't want to refer back to any of the components, just to see if the pattern matched.
23:22:12 <cjs> ddarius: What is the difference?
23:22:45 <ddarius> cjs: Between an expression and a declaration?
23:23:10 <cjs> Yes.
23:23:23 <Staz> > let foo = "bar" in putStr foo
23:23:24 <ddarius> An expression has a value, a declaration does not.
23:23:28 <lambdabot>  <IO ()>
23:23:38 <Staz> > putStr foo where foo = "bar"
23:23:39 <lambdabot>  Parse error at "where" (column 12)
23:26:15 <cjs> Ah.
23:26:41 <cjs> > foo where foo = 7
23:26:41 <lambdabot>  Parse error at "where" (column 5)
23:29:25 <solrize_> also there seems to be no way to use a data statement inside a function?  to make a temporary datatype limited to the function scope
23:29:39 <ddarius> That's correct.
23:30:48 <dons> its surprisingly subtle, solrize_ . an interesting problem!
23:33:08 <mae_> if i want to extract some data from some xml, what should i use? i am looking at haxml but as far as i can see it seems to be mainly geared towards transformations like xslt
23:33:36 <ddarius> It can be (and is meant to be) used for selection as well.
23:34:09 <ddarius> It's vaguely XQuery like.
23:34:42 <dons> mae, maybe tagsoup?
23:34:48 <dons> haxml is fine too
23:37:14 <mae_> hmm
23:37:20 <mae_> which module in particular do i use in haxml
23:37:29 <mae_> i am just trying to do something similar to xpath
23:37:38 <mae_> look for some basic elements and do something with that data
23:40:40 <ddarius> The basic combinators in Text.XML.HaXml.Combinators should be fine.
23:41:45 <mae_> ok
23:44:50 <mae_> so how do i go from string xml to Content i
23:45:14 <mae_> i know there is xmlParse but this returns a Document .. whereass the stuff in the combinators take Content i
23:48:41 <omg911> is it possible to have 2 modules in 1 file?
23:48:59 <marshmallows> omg911: No
23:49:31 <marshmallows> @faq is it possible to have 2 modules in 1 file?
23:49:32 <lambdabot> The answer is: Yes! Haskell can do that.
23:49:48 <mae_> lol
23:49:50 <omg911> uh
23:49:56 <mae_> the answer is no
23:50:02 <mae_> lambdabot is  trickster
23:50:08 <omg911> oh ok that's unfortunate...
23:50:09 <oerjan> omg911: all the implementations look up modules by file name
23:50:15 <marshmallows> hi mae!
23:50:26 <mae_> hi
23:50:36 <oerjan> except for the main module sometimes
