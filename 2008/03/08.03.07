00:01:14 <Androo> faxathisia: don't think that works, does it?  I need to redefine zip without using zip, too.
00:02:06 <wagle_home> Androo, faxathisia meant myzip [1..] ([1..]++[1..])
00:02:13 <nornagon> grr, hscurses' color stuff is even more infuriating than curses' own stuff.
00:02:27 <wagle_home> zip works on that
00:03:53 <wagle_home> ooops
00:04:29 <faxathisia> Why not go like
00:04:30 <faxathisia> ziq     ([],[])     = Just []
00:04:30 <faxathisia> ziq ((x:xs),(y:ys)) = ziq (xs,ys) >>= return . ((x,y):)
00:04:30 <faxathisia> ziq      (_,_)      = Nothing
00:05:00 <wagle_home> Androo's not here, man
00:05:25 <wagle_home> (yeah, that was my idea too)
00:06:11 <wagle_home> (except curried..  8) )
00:06:17 <faxathisia> how?
00:06:52 <faxathisia> oh I see
00:07:03 <faxathisia> @pl x >>= return .  y
00:07:03 <lambdabot> y `fmap` x
00:07:05 <oklofok> how do i split a string in haskell?
00:07:12 <faxathisia> :t break
00:07:15 <wagle_home> you wrote it, i just thought about it..    i was thinking in terms of an accumulator rather than the arg
00:07:24 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
00:07:39 <faxathisia> @hoogle split
00:07:40 <lambdabot> Data.ByteString.split :: Word8 -> ByteString -> [ByteString]
00:07:40 <lambdabot> Data.Set.split :: Ord a => a -> Set a -> (Set a, Set a)
00:07:40 <lambdabot> Data.Map.split :: Ord k => k -> Map k a -> (Map k a, Map k a)
00:07:45 <faxathisia> there's a regex split..
00:07:48 <faxathisia> somewhere
00:08:34 <oklofok> regexps are for the weak, break works fine, thanks
00:09:27 <glguy> break might not be what you wanted:
00:09:36 <glguy> > break (== ' ') "or is it"
00:09:38 <lambdabot>  ("or"," is it")
00:09:55 <glguy> (on its own at least)
00:10:01 <faxathisia> > words "this also does.. something"
00:10:09 <lambdabot>  ["this","also","does..","something"]
00:10:23 <wagle_home> @src words
00:10:23 <lambdabot> words s = case dropWhile isSpace s of
00:10:23 <lambdabot>     "" -> []
00:10:23 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
00:10:26 <oklofok> actually, break is not good
00:10:29 <oklofok> it only splits once
00:11:10 <oklofok> glguy: yeah, it wasn't
00:11:26 <faxathisia> @src Functor
00:11:26 <lambdabot> class  Functor f  where
00:11:26 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
00:11:56 <faxathisia> I got ziq :: (MonadPlus m, Functor m) => [a] -> [b] -> m [(a, b)] -- can better be done?
00:12:03 <wagle_home> too bad words isn't using something more abstract
00:12:13 <faxathisia> @src words
00:12:14 <lambdabot> words s = case dropWhile isSpace s of
00:12:14 <lambdabot>     "" -> []
00:12:14 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
00:12:38 <oklofok> so there really isn't any split function in prelude?
00:12:46 <dolio> faxathisia: You could use liftM and cut it down to a MonadPlus context.
00:12:46 <oklofok> in case prelude is the stdlib
00:13:01 <faxathisia> ziq     [] []     = return []
00:13:01 <faxathisia> ziq (x:xs) (y:ys) = ((x , y) :) `fmap` ziq xs ys
00:13:01 <faxathisia> ziq      _ _      = mzero
00:13:05 <faxathisia> where would you use liftM?
00:13:11 <dolio> Instead of fmap.
00:13:23 <dolio> It's the same thing, but with a Monad constraint instead of Functor.
00:13:24 <faxathisia> ah great ok thanks
00:13:52 <wagle_home> faxathisia, nice
00:13:54 * oklofok cannot live without a split
00:14:25 <faxathisia> Parsec can split :P
00:14:30 <oklofok> i cannot google atm
00:15:00 <wagle_home> hmm
00:15:11 <oklofok> so... ByteString had a split
00:15:21 <oklofok> is that a... split?
00:16:20 <wagle_home> @index mzero
00:16:20 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
00:16:29 <faxathisia> mzero = Nothing
00:17:03 <oklofok> > Data.ByteString.split "asdasd" "asdasd"
00:17:03 <lambdabot>   Not in scope: `Data.ByteString.split'
00:17:22 <oklofok> can that be used somehow?
00:17:37 <faxathisia> what does split do?
00:17:40 <faxathisia> and what's it's type
00:17:51 <oerjan> :t Data.ByteString.split
00:17:52 <lambdabot> Word8 -> BSC.ByteString -> [BSC.ByteString]
00:18:01 <faxathisia> I mean oklofoks split
00:18:14 <oklofok> faxathisia: that
00:18:18 <faxathisia> ?
00:18:25 <oklofok> what bytestring's does, i think
00:18:38 <oklofok> it's a split, don't you    know python? :P
00:19:14 <faxathisia> no :(
00:19:31 <Baughn> > forever "a"
00:19:33 <lambdabot>  Exception: stack overflow
00:19:50 <wagle_home> need a zip that uses the continuation monad..  8)
00:19:52 <Baughn> > forever ""
00:19:53 <lambdabot>  []
00:20:16 <wagle_home> ziq
00:20:22 <wagle_home> ziq/cc?
00:20:23 <dolio> > BSC.split ' ' (BSC.pack "The quick brown fox jumps over the lazy dog")
00:20:24 <lambdabot>  ["The","quick","brown","fox","jumps","over","the","lazy","dog"]
00:20:29 <faxathisia> lol wagle
00:20:40 <oklofok> ah, that looks about right
00:20:58 <oklofok> ...BSC.pack?
00:21:08 <oklofok> makes it a special Ã¼berstring?
00:21:37 <dolio> Converts from the usual Haskell string type of [Char].
00:21:39 <Baughn> @type BSC.pack
00:21:41 <lambdabot> String -> BSC.ByteString
00:21:48 <Cheery> I wonder whether I'd need to build my own binary -module
00:21:52 <Baughn> Data.ByteString.Char?
00:22:00 <Cheery> or oh well..
00:22:29 <dolio> BS = Data.ByteString, BSC = Data.ByteString.Char8, BSL = Data.ByteString.Lazy
00:22:38 <dolio> Not sure what Char8.Lazy is called.
00:22:42 <dolio> BSCL doesn't seem to work.
00:23:19 <Baughn> BLC
00:23:25 <dolio> Ah.
00:23:32 <faxathisia> > foldr (\a b -> if a == ' ' then [a]:b else (a:head b) : tail b) [] "The quick brown fox jumps over the lazy dog"
00:23:33 <lambdabot>  Exception: Prelude.head: empty list
00:23:37 <faxathisia> :/
00:23:41 <faxathisia> > take 15 $ foldr (\a b -> if a == ' ' then [a]:b else (a:head b) : tail b) [] "The quick brown fox jumps over the lazy dog"
00:23:41 <lambdabot>  Exception: Prelude.head: empty list
00:23:45 <faxathisia> > take 3 $ foldr (\a b -> if a == ' ' then [a]:b else (a:head b) : tail b) [] "The quick brown fox jumps over the lazy dog"
00:23:46 <lambdabot>  ["The ","quick ","brown "]
00:24:29 <oklofok> hmph, i don't have BSC
00:24:39 <Baughn> > take 3 $ words "The qui ck brown dinosaur jumps over the tiny white spotlight"
00:24:40 <lambdabot>  ["The","qui","ck"]
00:24:52 <faxathisia> foldr (\a b -> if a == ' ' then []:b else (a:head b):tail b) [""] "The quick brown fox jumps over the lazy dog"
00:25:11 <faxathisia> @pl (\a b -> if a == ' ' then []:b else (a:head b):tail b)
00:25:12 <lambdabot> ap (ap . (. ([] :)) . if' . (' ' ==)) ((`ap` tail) . ((:) .) . (. head) . (:))
00:25:26 <Cheery> oh well, no need, this getter thing is far more sophisticated than thought
00:25:27 <dolio> > groupBy ((&&) `on` isSpace) "The quick brown fox jumps over the lazy dog"
00:25:35 <Baughn> faxathisia: No! Oh god no!
00:25:37 <lambdabot>  ["T","h","e"," ","q","u","i","c","k"," ","b","r","o","w","n"," ","f","o","x"...
00:26:05 <dolio> oklofok: The module is Data.ByteString.Char8. BSC is what it's called imported into lambdabot for short.
00:26:11 <dolio> > groupBy ((==) `on` isSpace) "The quick brown fox jumps over the lazy dog"
00:26:12 <lambdabot>  ["The"," ","quick"," ","brown"," ","fox"," ","jumps"," ","over"," ","the"," ...
00:26:12 <oklofok> > beginsWith "a" "asd"
00:26:13 <lambdabot>   Not in scope: `beginsWith'
00:26:26 <faxathisia> ow
00:26:28 <faxathisia> neat
00:26:30 <oklofok> i miss google...
00:26:35 <oerjan> > isPrefixOf "a" "asd"
00:26:35 <lambdabot>  True
00:26:42 <oklofok> ah
00:26:47 <faxathisia> @src isPrefixOf
00:26:47 <lambdabot> isPrefixOf [] _          = True
00:26:47 <lambdabot> isPrefixOf _  []         = False
00:26:47 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
00:26:52 <faxathisia> O_o
00:27:10 <faxathisia> @src isInfixOf
00:27:11 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
00:27:19 <faxathisia> ^ this is cool :D for lazynes
00:27:50 <dolio> Yeah. The fact that that isn't grossly inefficient is nice. :)
00:28:07 <Baughn> Are you /sure/ it isn't?
00:28:29 <Baughn> Given that @src sort shows insertion-sort, I wouldn't assume that this is in any way "fast"
00:28:34 <faxathisia> isPrefixOf is short circuting
00:28:47 <faxathisia> it's not the most possible efficient dynamic programming version but close
00:28:57 <Baughn> isPrefixof is fine. I was thinking more of isInficOf
00:29:04 <oklofok> it's algorithmically as fast as possible, methinks
00:29:09 <faxathisia> yes but isInfixOf uses isPrefixOf
00:29:22 <oklofok> if you don't have more information about the strings at hand
00:29:48 <Baughn> faxathisia: Yes, but too much. I'm pretty sure this version of isInfixOf is O(n^*m)
00:29:51 <wagle_home> @src isPostfixOf
00:29:51 <lambdabot> Source not found. stty: unknown mode: doofus
00:30:01 <faxathisia> Baughn:t ^* :P
00:30:16 <Baughn> @let (^*) (*)
00:30:16 <lambdabot>  Parse error
00:30:19 <Baughn> @let (^*) = (*)
00:30:21 <lambdabot> Defined.
00:30:27 <dolio> @src isSuffixOf
00:30:27 <lambdabot> isSuffixOf x y = reverse x `isPrefixOf` reverse y
00:30:35 <nornagon> hscurses is such a mess :(
00:31:27 <wagle_home> hmm.. i've seen that..  maybe in Bird
00:31:34 <andun> this isInfixOf is pretty nice :) http://twan.home.fmf.nl/blog/haskell/Knuth-Morris-Pratt-in-Haskell.details
00:31:36 <lambdabot> Title: Knuth-Morris-Pratt in Haskell - 21 thoughts, http://tinyurl.com/23rvcf
00:33:11 <oklofok> hmm... there are tons of name collisions when i import Data.ByteString.Char8, putStr for instance is both in prelude and there, and once again, i actually cannot google.
00:33:20 <oklofok> so... help needed :)
00:33:26 <Baughn> andun: You should submit a patch. The slow version is the one actually in use now.
00:33:38 <Baughn> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#isInfixOf *grumbles*
00:33:38 <wagle_home> andun, cool..  and short!
00:33:39 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2gpya5
00:33:46 <dolio> Baughn: It's fast in that all the tails are shared, so it's not O(m*n^2) like one might think at first.
00:33:49 <andun> Baughn, wagle_home: it's not me who made it
00:34:04 <Baughn> dolio: I never thought that, but O(n*m) is still too slow
00:34:08 <faxathisia> import qualified Foo as Bar ?
00:34:16 <faxathisia> import Foo hiding Bar
00:34:18 <oerjan> oklofok: the ByteString modules are usually imported qualified
00:34:19 <Baughn> andun: You can be the one to submit the patch. ;)
00:34:27 <oklofok> qualified, hiding?
00:34:29 <andun> ;)
00:35:06 <oklofok> qualified means i can use Bar to access stuff in Foo, but it's not imported in the namespace otherwise?
00:35:24 <oklofok> hiding means Bar's namespace is hidden where it overlaps with Foo's?
00:35:43 <oklofok> a bit hard to guess just from the keywords :P
00:35:59 <oerjan> oklofok: the first is correct
00:36:09 <oerjan> but hiding hides individual functions
00:36:26 <oklofok> and imports just individual functions too?
00:36:31 <oerjan> (and types, etc.)
00:36:39 <oerjan> no, everything not hidden
00:36:46 <oklofok> import qualified Data.ByteString.Char8 as BSC <<< like this then?
00:36:53 <oerjan> yeah
00:38:07 <oerjan> qualified, as and hiding can be combined arbitrarily i think, although not all combinations are that useful
00:38:08 <oklofok> heh, BSC's split is by character :P
00:38:14 <oklofok> i need it by string :D
00:38:23 <oklofok> anything for that?
00:39:28 <faxathisia> @src words
00:39:28 <lambdabot> words s = case dropWhile isSpace s of
00:39:28 <lambdabot>     "" -> []
00:39:28 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
00:39:51 <oklofok> oerjan: can you show an example of hiding, i didn't get it exactly
00:40:22 <oklofok> so... it hides a function, while importing a module?
00:40:41 <oerjan> import Prelude hiding (putStr)
00:40:42 <oklofok> hmm
00:40:49 <oklofok> oh
00:41:04 <oklofok> so it imports everything but putStr from Prelude
00:41:17 <oerjan> yep
00:41:49 <oklofok> is this All You Need To Know About Haskell Modules?
00:41:55 <oerjan> @where report
00:41:55 <lambdabot> http://www.haskell.org/onlinereport/
00:42:02 <oerjan> see modules chapter
00:42:05 <oklofok> can't access webpages.
00:42:07 <oklofok> :)
00:42:18 <glguy> now you'll never know!
00:42:23 <oerjan> that explains your google comments...
00:43:05 <oklofok> heh, you know the "open all in tabs" button in firefox, i always press it, and lose all pages i had open
00:43:16 <oklofok> and now, even if i remembered what those were, i cannot open them
00:43:41 <dolio> oklofok: Regexes are probably your best bet if you want to split by string, currently.
00:43:46 <oklofok> thank god undoing isn't done on OS level, every program might actually *have* it.
00:43:51 <oklofok> hmm
00:43:52 <oklofok> i see
00:43:54 <dolio> Or write such a function yourself.
00:44:04 <oklofok> yeah, i'm beginning to feel i should
00:44:26 <oklofok> the problem was just that my goal was to show myself haskell is shorter at this given task :P
00:44:27 <dolio> The base libraries just got join by string in 6.6.
00:44:54 <faxathisia> @hoogle isPrefixOf
00:44:54 <lambdabot> Data.List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
00:44:54 <lambdabot> Data.ByteString.isPrefixOf :: ByteString -> ByteString -> Bool
00:44:54 <lambdabot> Data.ByteString.Char8.isPrefixOf :: ByteString -> ByteString -> Bool
00:45:00 <oklofok> and then it didn't have split... such a rookie mistake
00:47:30 <dolio> Prelude Text.Regex> splitRegex (mkRegex ",") "foo,bar,baz"  ==> ["foo","bar","baz"]
00:51:19 <Adamant> is there a common naming convention for Haskell libraries?
00:52:11 <scook0> what do you mean by a naming convention?
00:53:03 <scook0> there's stuff like the Data and Control hierarchies
00:53:07 <Adamant> well, most C Unix libraries, start with libBlahBlahBlah, Haskell stuff tends to have a h in it, etc.
00:53:28 <dolio> Oh, no, nothing like that.
00:53:31 <oerjan> http://www.haskell.org/haskellwiki/Hierarchical_module_names
00:53:32 <lambdabot> Title: Hierarchical module names - HaskellWiki
00:53:49 <oerjan> but not for the library itself...
00:53:51 <dolio> If you can come up with some kind of clever wordplay, that's good, though. :)
00:54:06 <Adamant> like Harpy and Hoogle
00:55:37 <dolio> If you look on hackage, I think you'll find that most stuff doesn't begin with an h.
00:57:08 <Baughn> Distributions do tend to add a "hs" if there isn't one already, for some reason
01:01:03 <quicksilver> debian/ubuntu add libghc6-
01:01:14 <quicksilver> but that's ok :) that's just to show what it's compiled against.
01:01:40 <Baughn> Now if only they'd move 6.8.2 to stable
01:02:11 <Baughn> ..that'll happen when pigs fly. I love debian, but it's not so great for bleeding-edge development.
01:03:11 <glguy> "bleeding edge"
01:03:47 <quicksilver> "move to stable?
01:03:56 <quicksilver> nothing gets moved to stable.
01:04:04 <quicksilver> you get a new stable when there is a new debian release.
01:04:27 <Baughn> I know. I suppose what I'm asking is for smewhat /quicker/ releases.
01:04:38 <Baughn> Six months I could deal with
01:04:54 <osfameron> ubuntu is every 6 months
01:05:16 <Baughn> Ubuntu, I can't deal with.
01:05:31 <osfameron> hw come?
01:06:08 <Adamant> Debian reminds you that rigor mortis also results in stability
01:06:47 <Baughn> osfameron: It has a lot of processes doing things that, well, I don't want done. By the time I'd ripped them out it'd probably be unstable.
01:06:54 <quicksilver> quicker debian releases would be lovely.
01:07:11 <osfameron> "There is this special biologist word we use for 'stable'. It is 'dead'." -- Jack Cohen
01:07:11 <Baughn> osfameron: Probably okay for desktops, I guess. This one's a server.
01:07:14 <quicksilver> But it turns out to be very hard to do with a bunch of volunteers with a distribution that large.
01:07:40 <osfameron> Baughn: fair enough -- I've not tried ubuntu-server
01:07:55 <quicksilver> ubuntu sort-of succeeded by taking it commercial, paying people to work on it, and shrinking the distribution massively.
01:08:19 <glguy> I had to wipe ubuntu off this machine this evening... didn't feel like chasing down modern versions of ghc and git and other libs
01:08:23 <quicksilver> personally I find it very easy to do bleeding-edge development
01:08:25 <quicksilver> on debian.
01:08:42 <quicksilver> but I use unstable, and Im' not afraid to compile things if I have to.
01:08:52 <osfameron> ubuntu is just lovely for first time to linux.  there is a 90% chance that enough of your hardware will work that you don't immediately run screamin back to Windows/OSX
01:09:00 <Baughn> That's my solution also - I don't use debian's ghc packages, just my own.
01:09:06 <glguy> I thought I'd give Debian unstable a shot, but after a couple package simply segfaulting
01:09:12 <glguy> I figured that maybe it really was unstable
01:09:13 <Adamant> well, Debian's stability has good points. the problem is that Debian Stable should be Debian REALLY stable and Debian Stable should be updated much more often
01:09:32 <Baughn> "Debian Corpsicle"?
01:10:34 <quicksilver> Adamant: maybe you want debian testing?
01:10:42 <Adamant> Debian "Ken Thompson would feel right at home"
01:11:15 <faxathisia> > 1+100000000000^2
01:11:18 <lambdabot>  10000000000000000000001
01:11:25 <Baughn> quicksilver: Worst of two world. Testing actually gets security updates /slower/ than stable
01:11:44 <scook0> personally I love having "it just works" ubuntu for my desktop, and I'm willing to do a little extra work for the few bleeding-edge things I want
01:12:24 <glguy> Fedora has been the only large distro I've been able to use happily for months
01:13:04 <glguy> usually I get irritated and switch
01:13:21 <scook0> to be fair, ubuntu is the only distro I've used since I stopped using gentoo ages ago
01:13:23 <pjd> ~ FreeBSD, the OS for me ~
01:13:36 <scook0> so I don't know what the other "polished" distros are like
01:13:55 <glguy> I tried FreeBSD, couldn't deal with my wireless
01:14:03 <Adamant> very few distro are as polished for end-user as Ubuntu.
01:14:22 <glguy> which was kind of a deal breaker, so I didn't get to play much past that
01:14:39 <Adamant> glguy - try Project Mayhem?
01:14:59 <Adamant> or whatever the term was for Windows wireless drivers using on FBSD
01:15:04 <glguy> Adamant: There was a driver: ipw3945 or so
01:15:09 <glguy> but it caused kernel panics
01:15:10 <pjd> Adamant: Project Evil, IIRC
01:16:02 <Adamant> clearly my lack of sleep is affecting my judgement. maybe I need to attend a support group.
01:17:28 <scook0> > zip [1..] $ fix ("Don't talk about Haskell club.":)
01:17:30 <lambdabot>  [(1,"Don't talk about Haskell club."),(2,"Don't talk about Haskell club."),(...
01:18:21 <jones-> :)
01:18:22 <hpaste>  tibbe pasted "The beginnings of an incremental parser library" at http://hpaste.org/6180
01:18:47 <Baughn> scook0: I see an infinite amount of chatter, but wouldn't repeat be simpler? :P
01:19:16 <scook0> Baughn: if this is your first night ... you *have* to fix
01:19:26 * Baughn groans
01:19:29 <tibbe> I'm in need of some help adding back track possibilities to my incremental parsing library (implemented using continuations). Anyone up to the challenge? :)
01:19:35 <tibbe> I'm not smart enough
01:19:35 <scook0> *zing*
01:27:35 <dolio> What kind of back tracking?
01:58:52 <tibbe> dolio: well basically I have to write <|>
01:59:08 <tibbe> dolio: the two parsers should fail by only looking at one token
02:00:30 <dolio> Ah.
02:00:42 <tibbe> dolio: I linked it ^^
02:00:59 <dolio> Oh, right.
02:01:38 <tibbe> I'll probably end up formulating my question on -cafe
02:03:36 <dolio> Oh, well, here's an initial thought: you should use two continuations.
02:04:27 <dolio> A success continuation and a failure continuation.
02:05:28 <skorpan> is there a function which acts like lookup but for [Data.Map k a]?
02:05:48 <dolio> @type lookup
02:05:50 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
02:05:50 <skorpan> i mean, i could do toList
02:06:06 <dolio> There's no Data.Map.lookup?
02:06:14 <dolio> If not, try (!).
02:06:34 <skorpan> dolio: there is, but not for [Data.Map k a]
02:06:58 <quicksilver> skorpan: lookup . union
02:07:01 <quicksilver> skorpan: (roughly)
02:08:01 <oerjan> :t Data.Map.lookup
02:08:02 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
02:09:12 <oerjan> :t (mconcat .) . map lookup
02:09:13 <lambdabot>     Couldn't match expected type `[a]'
02:09:13 <lambdabot>            against inferred type `[(a1, b)] -> Maybe b'
02:09:13 <lambdabot>       Expected type: [a1] -> [[a]]
02:09:13 <wagle_home> :t Data.Map.!
02:09:14 <lambdabot> parse error on input `Data.Map.!'
02:09:22 <wagle_home> :t Data.Map.(!)
02:09:23 <lambdabot> Couldn't find qualified module.
02:09:26 <wagle_home> bah
02:09:30 <oerjan> :t (mconcat .) . map Data.Map.lookup
02:09:31 <lambdabot>     Couldn't match expected type `[a]'
02:09:31 <lambdabot>            against inferred type `M.Map a1 a2 -> m a2'
02:09:31 <lambdabot>       Expected type: [a1] -> [[a]]
02:09:46 <oerjan> oh wait
02:10:24 <oerjan> :t \k v -> mconcat . map (Data.Map.lookup k v)
02:10:30 <lambdabot> forall k b a. (Ord k, Monoid b) => k -> M.Map k b -> [a] -> b
02:10:34 <quicksilver> surely that's not what he wants?
02:10:42 <quicksilver> surely he wants to lookup in the first map it appears in?
02:10:44 <dolio> tibbe: Anyhow, that's how, for instance, LogicT works. p <|> p' would be handled by running p with a failure continuation involving p'.
02:10:53 <oerjan> that's what mconcat does, if you use Maybe
02:10:54 <quicksilver> although the monoid solution is certainly cool.
02:11:03 * quicksilver nods
02:11:07 <quicksilver> :t union
02:11:11 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
02:11:15 <quicksilver> :t M.union
02:11:16 <lambdabot> forall k a. (Ord k) => M.Map k a -> M.Map k a -> M.Map k a
02:11:25 <tibbe> dolio: interesting, I'll try it out
02:11:31 <tibbe> dolio: where can I find LogicT?
02:11:42 <dolio> @hackage logict
02:11:43 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/logict
02:11:50 <tibbe> dolio: thanks
02:11:55 <tibbe> dolio: time to work
02:12:00 <dolio> No problem.
02:12:07 <oerjan> oh wait
02:12:28 <quicksilver> :t \k mm -> M.lookup k (M.unions mm)
02:12:30 <oerjan> i'm confusing mconcat with msum
02:12:32 <lambdabot> forall k a (m :: * -> *). (Monad m, Ord k) => k -> [M.Map k a] -> m a
02:12:38 <oerjan> :t \k v -> msum . map (Data.Map.lookup k v)
02:12:40 <lambdabot> forall (m :: * -> *) a k a1. (Ord k, MonadPlus m) => k -> M.Map k (m a) -> [a1] -> m a
02:12:40 <quicksilver> that's what I assumed he wanted.
02:12:46 <wagle_home> :t Data.Map.find
02:12:48 <lambdabot> Not in scope: `Data.Map.find'
02:12:54 <oerjan> that's better
02:13:00 <dolio> Yeah, msum's the one.
02:13:07 <dolio> mconcat wont' work the right way, unfortunately.
02:13:55 <oerjan> i saw it type with mconcat and assumed it was right ;)
02:15:14 <oerjan> hm there is no function similar to mapM for (msum .) . map ?
02:15:50 <dolio> @type (msum .) . map -- scary type courtesy of Cale?
02:15:53 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => (a1 -> m a) -> [a1] -> m a
02:16:07 <dolio> Oh, no problem, actually.
02:16:34 <oerjan> :t (.)
02:16:35 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
02:16:36 <dolio> @type foldMap
02:16:37 <lambdabot> Not in scope: `foldMap'
02:16:43 <dolio> @type F.foldMap
02:16:44 <lambdabot> Couldn't find qualified module.
02:16:51 <dolio> @type Data.Foldable.foldMap
02:16:52 <lambdabot> forall a m (t :: * -> *). (Monoid m, Data.Foldable.Foldable t) => (a -> m) -> t a -> m
02:16:54 <quicksilver> I think mconcat and msum are particularly poorly named.
02:16:57 <oerjan> foldMap is wrong there
02:17:46 <dolio> foldMap would be it, if you could tell the haskell type systme that MonadPlus m implies forall a. Monoid (m a)
02:19:07 <oerjan> hm another use for if you could put instances in class declarations
02:20:08 <Cheery> hm.
02:20:13 <Cheery> when I try to do: B.hPutStr con (encode defaultConnectionSetup)
02:20:22 <Cheery> Couldn't match expected type `B.ByteString' against inferred type `Data.ByteString.Lazy.Internal.ByteString'
02:20:47 <Cheery> what should I do?
02:21:21 <oerjan> make sure you are not mixing Lazy and strict ByteStrings
02:22:15 <Cheery> well.. I guess Data.Binary is using lazy ByteStrings
02:22:33 <Cheery> I paste you the code
02:23:08 <hpaste>  Cheery pasted "FAIL" at http://hpaste.org/6181
02:23:51 <oerjan> oh and UTF8 cannot?
02:24:36 <oerjan> otherwise, just sprinkle .Lazy on top of the imports i think
02:25:25 <Cheery> Data.ByteString.Lazy ?
02:25:30 <oerjan> yeah
02:25:39 <oerjan> maybe something for UTF8 too
02:27:18 <oerjan> gotta go
02:33:10 <lQg_> is there a function with which i could grab the <title>title</title> from an html file?
02:33:58 <lQg_> from the fileStr perhaps
02:34:39 <Baughn> lQg_: tagsoup, perhaps
02:34:48 <skorpan> Text.HTML
02:34:56 <skorpan> oh yeaah a whole library for it!
02:36:23 <skorpan> lookup :: (Monad m, Ord k) => k -> Map k a -> m a
02:36:31 <skorpan> how do i tell haskell which monad to use?
02:36:43 <Baughn> skorpan: Context
02:36:54 <skorpan> what?
02:36:59 <skorpan> :: Maybe?
02:37:06 <Baughn> For example
02:37:07 <Cheery> ghhhh
02:37:16 <Cheery> finally managed to get something from it.
02:37:16 <dolio> Nah, you shouldn't need explicit type signatures.
02:37:28 <skorpan> dolio: what's your suggestion then?
02:37:30 <Baughn> skorpan: Type inference works. Just use it as whatever monad you want and, assuming there are no ambiguities, it'll figure it out.
02:37:32 <Cheery> what it says.. Protocol Version Mismatch
02:37:33 <Cheery> ...
02:37:35 <Cheery> :)
02:37:40 <Cheery> well, at least that!
02:37:42 <skorpan> Baughn: oh okay! thanks
02:38:17 <dolio> skorpan: Depends. Pattern matching disambiguates, for instance. 'case lookup k m of Just v -> ... ; Nothing -> ...'
02:38:21 <Baughn> @src [] fail
02:38:21 <lambdabot> fail _      = []
02:38:29 <skorpan> dolio: yeah, thanks
02:38:44 <lQg_> cool i'll check em out in abit
02:39:21 <Baughn> skorpan: "do foo <- lookup ..; return foo" would be ambiguous, of course, but it's also meaningless so..
02:39:59 <skorpan> :)
02:40:11 <dolio> In general, there will be somewhere in your program that requires a specific monad, and that will disambiguate things.
02:40:33 <Baughn> Ayup
02:40:52 <dolio> Especially since there's no polymorphic way to get things out of a monad.
02:41:25 <dolio> It's harder to get errors like 'show . read', where GHC doesn't know what to make the intermediate type.
02:44:02 * wli just lets the compiler complain and fixes it up when it does.
03:14:52 <georgw> What's a good way of filtering a list such that each element has a 50% chance of being in the output list?
03:15:17 <smg> ?
03:15:25 <georgw> I was tinkering with generating a random Bool-List of equal length but couldn't find an appropriate function to use it.
03:15:42 <georgw> E.g. [1,2,3,4,5]
03:15:51 <georgw> [True,False,False,True,True]
03:15:52 <georgw> gives
03:15:58 <georgw> [1,4,5]
03:16:08 <quicksilver> random Bool-List is the right approach, I'm sure.
03:16:14 <smg> yeah
03:16:21 <matthew_-> zipwith, Maybe and then catMaybes ?
03:16:29 <smg> georgw: what in your input list?
03:16:45 <scook0> filterM (chance 0.5) would work ... for appropriate implementations of chance :)
03:16:46 <georgw> smg: items, which are 3-tuples of ints.
03:16:56 <dolio> > let tag False _ = Nothing ; tag True a = Just a in catMaybes $ zipWith tag [False, True, False, False, True] [1..5]
03:17:00 <lambdabot>  [2,5]
03:17:06 <ToRA> \msg lambdabot @type (((map snd . filter fst).) . zip)
03:17:06 <quicksilver> > concat (zipWith (\n b -> if b then [n] else []) [1,2,3,4,5] [True,False,False,True,True])
03:17:07 <lambdabot>  [1,4,5]
03:17:13 <scook0> actually, make that const $ chance 0.5
03:17:41 <smg> georgw: cycle
03:17:47 <smg> georgw: cycle [True,False]
03:18:01 <matthew_-> not /very/ random is that...?
03:18:10 <smg> mh
03:18:53 <georgw> cool. zipWith is neat.
03:18:59 <georgw> Thank you all. :-)
03:19:26 <smg> matthew-_: maybe shuffling before the inputlist?
03:19:30 <skorpan> matthew_-: define /very/ random
03:20:01 <matthew_-> skorpan: easy. Using any data you already have, you still can't predict the next value with any accuracy greater than pure chance
03:20:18 <skorpan> matthew_-: that's non-deterministic randomness
03:20:18 <smg> hehe
03:20:29 <matthew_-> well that must be what I meant then :)
03:20:43 <skorpan> then good luck with your randomness project
03:21:04 <georgw> Luckily we figured out the random stuff already yesterday. :-)
03:21:05 <skorpan> pseudo-random is good enough in many (if not most) cases
03:22:40 <matthew_-> skorpan: or you can just buy a radioactive source, giger counter and some lead ;)
03:23:00 <skorpan> yeah or plug a fire detector into a webcam
03:23:25 <matthew_-> err what? I don't recognise that one.
03:23:29 <skorpan> smoke detector*
03:23:39 <georgw> thermic noise on a resistor is more than sufficient.
03:23:44 <matthew_-> ahh, brownian motion
03:24:13 <matthew_-> actually no, that would be smoke, not a smoke detector...
03:24:44 <matthew_-> ok, having been educated on how smoke detectors work, that makes *much* more sense now
03:25:19 <hpaste>  (anonymous) annotated "fibonacci" with "(no title)" at http://hpaste.org/6121#a1
03:25:42 <skorpan> http://www.economysizegeek.com/2006/08/13/dont-let-your-smoke-detector-catch-on-fire/
03:25:44 <lambdabot> Title: Economy Size Geek » Blog Archive » Don't Let Your Smoke Detector Catch On Fire, http://tinyurl.com/2dlth5
03:27:42 <scook0> @type lift
03:27:46 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
03:47:56 <byorgey> is code.haskell.org down?
03:53:13 <smg> for me it is
03:54:08 <smg> ping byorgey
03:54:19 <byorgey> hi smg
03:54:39 <smg> :)
03:55:00 <byorgey> hm, I think it is hosted in Portland where no one is awake yet =(
03:55:15 <smg> :<
03:55:17 <byorgey> smg: how goes the haskell-learning? =)
03:55:32 <smg> ah good
03:55:59 <smg> i'm not at the chapter which covers: Denotational semantics, howard-curry-isomorphism and catergory theory
03:56:18 <opqdonut> what are you reading?
03:56:26 <smg> the wiki book
03:56:35 <smg> http://en.wikibooks.org/wiki/Haskell
03:56:42 <smg> Wider Theory
03:57:48 <opqdonut> wow, the wikibook has really improved since i last checked it out
03:57:51 <opqdonut> wtg!
03:58:27 <smg> hehe
04:00:47 <byorgey> smg: awesome =)
04:01:46 <smg> byorgey: hrhr yeah it's good
04:06:24 <georgw> Does Haskell have the equivalent of the C operator "a ? b : c"?
04:06:56 <dolio> if a then b else c
04:07:35 <georgw> dolio: Thanks. So simple, haven't thought of it.
04:09:47 <smg> georgw: hehe yeah it's the ternary op
04:12:06 <dolio> Yeah, C-like if statements don't really work in Haskell (outside the context of a monad), so if expressions and the ternary operator are about the same.
04:12:10 <ndm_> georgw: you can define: a ? (b,c) = if a then b else c
04:12:44 <edwinb> aha, ndm_
04:12:46 <skorpan> i guess it's basically just: a (?) (b,c) = if a then b else c
04:12:48 <georgw> smg: I am so used to imperative programming that ifs returning values is witchcraft to me.
04:13:05 <ndm> hi edwinb
04:13:17 <edwinb> I see you were pinging me last night. I am still in St Andrews...
04:13:28 <smg> georgw: me too, but you will learn haskell fast
04:13:29 <edwinb> if you're around you should come and visit some time and give a talk or something ;)
04:14:00 <ndm> edwinb: my g/f is doing a masters at St Andrews, so i'll be  up in about 2 weeks, and fairly regularly until the end of the summer
04:14:03 <yitz> dcoutts here?
04:14:29 <edwinb> ndm: splendid, it would be interesting if you came along to tell us what you were up to
04:15:00 <ndm> edwinb: cool, would love to - do you have a regular talks series or anything? if you have any group talks or anything i'd love to hear what you lot are doing as well
04:15:27 <edwinb> we don't have anything regular, but I can let you know if something is happening
04:15:32 <georgw> smg: Yep, I already love it. Very fresh way of thinking differently about programming.
04:15:36 <ndm> was surprised to see that i've met about 4 St Andrews fp'ers but didn't realise any of them were from there
04:15:45 <edwinb> ndm: they tend to be pretty informal meetings
04:15:51 <georgw> smg: But takes a bit of energy to overcome the initial hurdles.
04:16:32 <ndm> edwinb: yeah, our group meetings are pretty informal too - plenty of heckling
04:16:36 <edwinb> people here are variously into resource aware programming, costing, GADTs and dependent types
04:16:40 <smg> georgw: monads you already figured out?
04:17:11 <ndm> yeah, i've read some of the HUME stuff
04:17:50 <georgw> smg: Well, I have figured out that IO is special and you need to use arrows to get stuff out, because they are not real functions.
04:18:04 <ndm> i also spoke to a girl from your group about GADT's for resource aware computing at a conference
04:18:14 <georgw> smg: I think I'll figure that out in time.
04:18:16 <edwinb> Charlotte, probably?
04:18:21 <georgw> smg: What I wonder about though is:
04:18:40 <ndm> yep, was Charlotte
04:19:25 <georgw> smg: There seems to be cleverer ways to write Haskell, like using point-free syntax, CPS, etc. So I wonder if I write horrible code right now that could be shrunk by a factor of two...
04:20:06 <ndm> edwinb: will let you know when i am next around - my g/f is a keen Go player btw
04:21:18 <matthew_-> where, in a case alternative, can you place additional class contexts?
04:23:57 <smg> georgw: hehe yes. i didn't know first but i think it's prefered
04:24:46 <smg> mh, can i make one x = 1 make somehow strict?
04:25:37 <ndm> smg: one x = x `seq` 1
04:25:53 <smg> ndm: one ~x = 1 would not work?
04:26:06 <ndm> smg: no, ~ makes things lazy, not strict
04:26:13 <ndm> one !x = 1 would work in GHC 6.8
04:26:19 <ndm> (probably...)
04:26:31 <ndm> there are some interesting parser issues with that, a really bad choice of syntax
04:26:56 <doserj> (you need to add LANGUAGE BangPatterns, i think)
04:26:58 <smg> ndm: ah damn i mixed up
04:27:13 <smg> mh i don't have GHC 6.8
04:27:43 <ndm> smg: you should use seq anyway - the !patterns should be removed
04:27:50 <smg> ndm: why?
04:27:56 <ndm> one !x = 1
04:28:00 <smg> i now acustomed to that
04:28:07 <ndm> is that one x = x `seq` 1
04:28:13 <ndm> or is it (!) one x = 1
04:28:22 <ndm> i.e. is it defining one, or defining (!)
04:28:28 <smg> ah lol
04:28:53 <ndm> there is a solution, disallow infix operators in definitions - which i think would be fine
04:28:54 <smg> let one !x = 1 defines at my ghc (!) :)
04:28:58 <ndm> but its a big breaking change
04:29:08 <ndm> smg: with bang patterns that may change
04:29:20 <smg> ah okay
04:29:23 <smg> ~6.8.2 <-- ghc
04:29:26 <smg> i isntall it now
04:29:37 <ndm> anyway, use seq, and everyone will be happy
04:29:46 <smg> {-# LANGUAGE BangPatterns #-} ?
04:29:49 <smg> k
04:29:52 <ndm> of course, the question is if you really want your thing strict
04:30:01 <smg> ndm: just for learning purpose atm
04:30:12 <smg> i wanted to build a function which is strict and elobarate something
04:30:35 <smg> so haskell is leftmost-outermost evaluation and therefore non-strict per default
04:30:40 <smg> hopefully this will be true
04:31:14 <smg> strict opposite of lazy languages also true? i hope ;-)
04:31:51 <ndm> yeah, i think you are right - and learning purposes is of course a good reason to experiment with stuff :)
04:32:17 <smg> hehe yes :) a bit learning by doing does not harme
04:32:54 <skorpan> updateLookupWithKey :: Ord k => (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a, Map k a)
04:33:02 <skorpan> what function could i pass as the first argument?
04:35:09 <skorpan> i'm not even sure what the function is supposed to do
04:35:36 <dolio> If there's already something in the map at that key, you can update it.
04:36:15 <dolio> Although, it's not obvious if returning Nothing deletes it or leaves the old value in place.
04:36:37 <dolio> Or whether the overall function gives the new or old value.
04:36:54 <skorpan> i really don't care about the old value so i probably want updateWithKey
04:37:17 <skorpan> however, that function also wants that silly function as the first argument
04:37:45 <smg> joint strictness hrhr
04:38:28 <dolio> I suspect the reason it wants you to return a Maybe is that if you return Nothing (i.e. no changes) it can hand you back the original map, instead of building a new map identical to the one you passed in.
04:39:00 <quicksilver> Nothing means 'delete this key'
04:39:03 <quicksilver> AIUI.
04:39:23 <edwinb> ndm: if you'd mentioned the Go player bit first I'd have already booked a seminar room ;)
04:39:33 <dolio> That's also a possibility.
04:40:02 <dcoutts> @seen yitz
04:42:18 <georgw> I have a list of custom type and want to get the element for which a certain element is maximal. Any easy way for that?
04:42:40 <dolio> Define an Ord instance for your type.
04:43:19 <byorgey> @type maximumBy
04:43:43 <byorgey> maximumBy :: forall a. (a -> a -> Ordering) -> [a] -> a
04:46:12 <smg> maybe i read somethign wrong but it is true that @ ==> ~ ?
04:46:24 <georgw> thx byorgey.
04:46:39 <georgw> Hmm... import Data.Ord does not work. Bad sign?
04:47:24 <byorgey> georgw: strange, what error does it give?
04:47:38 <georgw> Could not find module `Data.Ord':
04:47:47 <georgw> GHC Interactive, version 6.4.1
04:47:54 <georgw> too old?
04:48:03 <quicksilver> yes.
04:48:07 <quicksilver> (IIRC)
04:48:45 <quicksilver> smg: no. @ is just for associating an extra name to a pattern.
04:48:56 <quicksilver> smg: ~ is a semantic change, making a pattern lazy.
04:49:13 <Zao> The term irrefutable comes to mind, is that right?
04:49:22 <quicksilver> yes.
04:49:30 <quicksilver> irrefutable pattern == lazy pattern
04:50:29 <smg> ah okay
04:50:36 <smg> that did confuse me that irrefutable pattern
04:50:52 <smg> the _ wildcard => a sign for non-strictness
04:50:57 <smg> and ~ is lazy pattern
04:50:57 <quicksilver> nope.
04:51:02 <smg> damn -.-
04:51:03 <quicksilver> _ has nothing to do with non-strictness.
04:51:12 <quicksilver> well, that's a bit strong :)
04:51:21 <quicksilver> certainly _ can be used to build non-strict functions.
04:51:26 <smg> k
04:51:29 <quicksilver> but the symbol _ is just a wildcard name
04:51:35 <quicksilver> the link isn't direct.
04:51:37 <smg> Note that e wildcards are a general sign of non-strictness.
04:51:40 <smg> @wikibook
04:51:43 <quicksilver> yes, I agree.
04:51:47 <quicksilver> a general sign.
04:51:51 <quicksilver> but not always, of course.
04:51:51 <smg> ok
04:51:55 <smg> thx
04:52:04 <smg> but @ ~ and _ match "always"?
04:52:24 <dolio> @ doesn't always match.
04:52:41 <dolio> l@(h:t) only matches if (h:t) matches.
04:53:11 <smg> hehe
04:53:18 <smg> i need to correct that in the wiki
04:54:00 <dolio> Or, generally, v@p matches if p matches.
04:55:06 <smg> so
04:55:10 <quicksilver> I wouldn't quite say that ~ matches always.
04:55:16 <quicksilver> I'd say that ~ doesn't bother to check.
04:55:21 <smg> forall p (if p -> v@p matches)
04:55:32 <quicksilver> if, it later transpires, it didn't match, and you inspect the value, then your program explodes.
04:55:41 <byorgey> BOOM
04:55:48 <quicksilver> (if you never inspect it won't matter, though, even if it didn't)
04:55:50 <smg> :D
04:56:02 <smg> okay i will write that in the wiki
04:56:07 <smg> if you wouldn't bother
04:56:12 <quicksilver> please do
04:56:16 <quicksilver> improving wiki always welcome :)
04:57:21 <smg> ok
04:57:56 <smg> so ~ makes things lazy, and ! makes things strict
04:58:32 <smg> mh, is ghc 6.8.2 stable?
05:00:07 <Zao> Considering it's released, I'd say it is.
05:01:32 <DukeDave> Hey gang, so I have some code which uses readFile from Data.ByteString.Lazy.Char8.
05:01:52 <DukeDave> What is a good way to run a 'monitor' telling me how much of the file has been read?
05:01:52 <Socrates> Hey, I have putStr followed by a getLine in my main, and for reason when I compile this in GHC it seems to reorder them (doing the getLine first) as if it's not flushing the putStr, anyone any ideas how to fix it?
05:02:21 * georgw is on 6.8.2 now. :-)
05:02:55 <Zao> Socrates: The input and output streams are generally not synchronized.
05:03:23 <Zao> Socrates: Change the buffering on the output handle to NoBuffering?
05:03:27 <DukeDave> Socrates: Perhaps hFlush stdout
05:03:28 <byorgey> georgw: excellent =)
05:03:42 <Socrates> Thanks Zao and DukeDave, I'll give it a try
05:04:04 <quicksilver> DukeDave: you have discovered why Lazy IO is a very evil thing.
05:04:13 <quicksilver> DukeDave: what you want to do is, in fact, impossible.
05:05:04 <byorgey> Socrates: hFlush stdout after each putStr, as Zao suggested, or at the beginning you can do hSetBuffering stdout NoBuffering
05:05:25 <Socrates> byorgey: Thanks
05:05:35 <Socrates> Got it sorted now
05:06:24 <smg> mh okay
05:06:32 <smg> i build it but it will take approx. 2 hours :]
05:06:32 <dcoutts_> DukeDave: you just need to keep track of how much of the lazy ByteString you've consumed so far
05:06:52 <dcoutts_> DukeDave: the amount of IO done will never be more than 64k more than that.
05:06:56 <georgw> Could you throw me a very simple example on how to instance Ord?
05:07:28 <smg> instance Ord Foo where
05:07:49 <DukeDave> quicksilver: dcoutts: There seems to e an inconsistency in your answers :)
05:08:01 <smg> quicksilver: btw what would you recommend? to code haskell98 standard only or also use -fglasgow-exts?
05:08:08 <byorgey> georgw: instance (Ord a) => Ord (a,b) where (x,y) <= (z,w) = x <= z   -- compare pairs only by first element
05:08:38 <DukeDave> The "how much have I consumed" approach seems sane to me; I know the filesize outside of the execution
05:08:41 <quicksilver> DukeDave: I'm something of an anti-lazy-IO zealot, so I like to indulge in a little exagerration and hyperbole.
05:08:48 <dcoutts_> DukeDave: quicksilver might be referring to the precise amount of IO done which is indeed not observable, but the amount you've demanded is never more than a block different
05:08:49 <DukeDave> Nice :)
05:08:50 <quicksilver> DukeDave: keeps me amused, at least.
05:08:59 <quicksilver> smg: neither.
05:09:09 <smg> quicksilver: oh what does this mean? :]
05:09:10 <dcoutts_> DukeDave: oh and I'm a lazy-IO zealot, for contrast with quicksilver :-)
05:09:12 <byorgey> georgw: note, according to the Ord docs (http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Ord.html) you only have to define <= or compare, and all the other methods (<, >, etc.) get defined for you by default, based on the one you give
05:09:29 <quicksilver> smg: I would recommend coding mostly haskell98 but being aware of and using specific extensions and their uses.
05:09:47 <smg> quicksilver: ok
05:09:52 <quicksilver> smg: in particular, existentials, patter guards and mptcs
05:09:56 <quicksilver> are probably the most useful IMO.
05:10:04 <smg> ok
05:10:11 <DukeDave> dcoutts_: Should I be using forkIO to find out how much has been read?
05:10:13 <smg> now i will compile ghc 6.8.2 hehe
05:11:01 <dolio> You should use MagicHash in all your programs. :)
05:11:08 <georgw> byorgey: Seems I also need an instance for Eq?
05:11:14 <smg> georgw: yes
05:11:16 <byorgey> smg: note it's recommended to use a binary distribution if at all possible, compiling it from source takes a long time and is more likely to break.
05:11:21 <smg> your type needs to be derived of Eq too
05:11:25 <byorgey> georgw: ah, indeed.
05:11:44 <smg> class (Eq a) => Ord a <-- :)
05:11:49 <byorgey> smg: also note that I am a hypocrite, since I compiled 6.8.2 from source and it was kind of fun =)
05:12:00 <smg> byorgey: no i compile all :)
05:12:07 <smg> byorgey: i'm using gentoo linux
05:12:17 <georgw> Why do I need Eq? It's hardly possible that two of my objects are equal.
05:12:29 <byorgey> georgw: Ord is defined in terms of Eq.
05:12:30 <smg>      Thu Feb 14 15:51:09 2008 >>> dev-lang/ghc-6.6.1 ->  merge time: 2 hours, 33 minutes and 33 seconds.
05:12:31 <georgw> I just want comparisons based on one value.
05:12:33 <smg> byorgey: *g*
05:12:50 <byorgey> smg: hehe
05:12:50 <georgw> oic. So I can instance Eq to only look at one field in my data type?
05:13:30 <byorgey> georgw: yes.  you should define (==) in such a way so that x == y precisely when x <= y && x >= y  (according to the definition of <= you would like to use.)
05:13:38 <dcoutts_> DukeDave: so what you really want is a concurrent monitor that reports progress eg to some gui?
05:13:45 <smg> byorgey: my haskell programs which i wrote in 6.6.1 will be working in ghc 6.8.2?
05:13:58 <byorgey> smg: they should, yes.
05:14:02 <Zao> There should be little to no breaking changes.
05:16:13 <quicksilver> the worst trouble is with packaged libraries
05:16:26 <quicksilver> which is due to changes in the packaging infrastructure and base library layout
05:16:36 <quicksilver> actual end-user code is normally very compatible.
05:18:47 <DukeDave> dcoutts_: That's the one, although just some terminal output will be fine
05:18:54 <georgw> ok, I got the Ord and the Eq. What is the first argument for maximumBy? (a -> a -> Ordering)?
05:19:10 <quicksilver> you don't have to use maximumBy if you have an Ord instance
05:19:18 <quicksilver> then you just use 'maximum'
05:19:21 <georgw> oic.
05:19:31 <quicksilver> maximumBy is precisely for when yo u*don't* have an Ord instance.
05:19:37 <DukeDave> dcoutts_: I've just never done anything like this before; my programs have previously just been one in to out flow with no interaction
05:19:38 <quicksilver> (or, it's not the one you want)
05:19:45 <georgw> oh, I see.
05:19:53 <quicksilver> :t maximum
05:20:15 <quicksilver> Cale: bring back my lambdabot. Well, yours. Ours. Whatever.
05:22:30 <DukeDave> Oh yeah, where is lambdabot :(
05:22:40 <DukeDave> > 1 + 1
05:23:24 <DukeDave> That silence is horrible :|
05:23:57 <Zao> < lambdabot> type clash! a' != a'
05:24:02 <byorgey> 2
05:25:19 <idnar> heh
05:25:53 * Zao has found memories from his ML days.
05:25:58 <Zao> *fond
05:27:27 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6182
05:27:45 <smg> someone may take a look at the paste :)
05:28:13 <quicksilver> the answer is "maybe, maybe not"
05:28:15 <quicksilver> :P
05:28:31 <doserj> smg: datatypes are not "efficient". algorithms are
05:28:32 <matthew_-> now, has anyone managed to work out how to do recursion on the structure of contexts?
05:29:30 <smg> haha lol
05:34:22 <georgw> So, the program is finished and works. :-) Yay for Haskell. =) To make it more pretty... how do I do command line parsing?
05:34:40 <quicksilver> there is a GetOpt library you may find useful.
05:37:13 <dcoutts_> georgw: http://haskell.org/haskellwiki/High-level_option_handling_with_GetOpt
05:37:56 <georgw> Thanks! Looking at it now.
05:38:24 <smg> maybe you just need getArgs of System
05:39:57 <RR> why haskell sucks
05:40:36 <smg> RR?
05:40:38 <radix> RR: The correct grammar is "Why does Haskell suck?"
05:40:50 <matthew_-> or, "Why Haskell sucks: ... "
05:41:03 <radix> ;-)
05:41:08 <byorgey> hi RR, welcome to #haskell!  Most of us here don't think it sucks, but if you do we'd be happy to hear why, and hopefully convince you otherwise =)
05:41:31 --- mode: ChanServ set +o quicksilver
05:41:36 <DukeDave> Possibly "Why? Haskell sucks.."
05:41:43 <RR> i am not good with haskell
05:41:47 <smg> lool
05:41:51 <quicksilver> excellent.
05:41:53 <matthew_-> yeah, definitely more context is neede
05:41:54 <matthew_-> d
05:41:56 <quicksilver> that's an opportunity to learn!
05:41:57 <quicksilver> :)
05:42:07 <byorgey> RR: well, you have come to the right place =)
05:42:14 --- mode: quicksilver set -o quicksilver
05:42:20 <shapr> !paste
05:42:21 <hpaste> Haskell paste bin: http://hpaste.org/
05:42:24 <shapr> Huh
05:42:32 <dcoutts_> RR: and it looks like you're also at a good university that teaches Haskell, so you're in luck
05:42:39 <DukeDave> What a day to not have lambdabot, the greatest of all learning tools :(
05:42:54 <dcoutts_> RR: one of your professors wrote a popular book on learning Haskell
05:43:01 <shapr> DukeDave: Do you know of GoA?
05:43:09 <shapr> You can get lambdabot inside ghci
05:43:11 <smg> RR some more
05:43:31 <byorgey> shapr: does that work nowadays?  I thought it hadn't been updated in a while
05:43:47 <shapr> byorgey: I don't know, but it should!
05:43:55 <shapr> If it doesn't work, someone should update it.
05:43:57 <shapr> Probably me.
05:44:00 <byorgey> shapr: indeed!  hehe
05:44:15 <matthew_-> You are in a room. You are surrounded by ~400 mad haskellers. There is a book and a cup of coffee on the table.
05:44:30 <shapr> matthew_-: Time to code!
05:44:32 <RR> what is the best way to learn haskell
05:44:33 <byorgey> > drink coffee
05:44:46 <smg> Graham Hulton: Programming in Haskell
05:44:47 <matthew_-> shapr: you don't know how to code
05:44:49 <shapr> Does cabal work on win32?
05:44:56 <smg> then you go for YAHT and wikibook and gentle introduction to haskell
05:44:59 <DukeDave> shapr: I'm not sure how a "Portuguese factory or fortified trade town located on western India coast, 16th century" is relevant here? ;)
05:45:00 <shapr> matthew_-: ask the Haskellers how to code.
05:45:05 <smg> then you will be able to write something
05:45:07 <matthew_-> byorgey: you drink the coffee. It tastes good. You buzz slightly.
05:45:20 <byorgey> @where wikibook
05:45:28 <byorgey> doh, no \bot =(
05:45:30 <shapr> DukeDave: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/goa-3.0
05:45:30 <matthew_-> shapr: The haskellers respond helpfully and in at least stereo. Soon you are filled with joy.
05:45:36 * shapr grins
05:45:42 <smg> goa is a nice name
05:47:02 <dcoutts_> shapr: it does work on win32 generally though if you're using the darcs version it's not been tested recently so send bug reports :-)
05:47:05 <byorgey> RR: if you want some online tutorials, try http://en.wikibooks.org/wiki/Haskell and http://www.cs.utah.edu/~hal/htut/
05:47:33 <byorgey> RR: read stuff, play around, ask lots of questions here.
05:47:55 <byorgey> matthew_-: look at book
05:47:56 <shapr> dcoutts_: via cygwin?
05:48:08 <shapr> I'm not even sure how to get started with Haskell on win32
05:48:16 <DukeDave> shapr: I'll check it out :)
05:48:20 <dcoutts_> shapr: it's a native windows program so it doesn't grok cygwin paths
05:48:22 <ndm> shapr: its nice, but tends to suffer from the issue of not being as polished
05:48:32 <dcoutts_> shapr: ghc and all the other tools are native not cygwin programs
05:48:35 <shapr> Good morning ndm!
05:48:38 <shapr> ah
05:48:39 <ndm> shapr: install GHC off the website, the installer, and go - its all easy :)
05:48:44 <ndm> morning shapr
05:48:45 <shapr> I've done that part.
05:48:54 <dcoutts_> shapr: use the windows command line or msys
05:48:56 <shapr> Do I get cabal with that?
05:48:56 <ndm> shapr: now you can just develop
05:49:01 <shapr> What's msys?
05:49:03 <ndm> yes, but not cabal install
05:49:09 <ndm> msys is like cygwin lite
05:49:09 <shapr> oh, too bad
05:49:19 <dcoutts_> shapr: it's a unix like shell for windows
05:49:20 <ndm> you will for the next release of GHC
05:50:05 <ndm> shapr: http://www.cs.york.ac.uk/fp/yhc/dependencies/UnxUtils.zip - install some of those utilities, plus bsdtar from sourceforge, and it will make the windows experience a lot more pleasant
05:50:06 <dolio> Well, thanks to an emacs update, unicode rendering is now all wonky...
05:50:37 <dcoutts_> ndm: btw, you were asking about cabal upload yesterday
05:50:46 <dcoutts_> ndm: were you having problems with it?
05:50:57 <ndm> dcoutts_: yes, it asked for my password in plain text, then proceeded to do absolutely nothing
05:51:26 <ndm> i was at least hoping for a "lol, you've been trojaned" message :-)
05:52:06 <dcoutts_> ndm: you can use -v3 to see the http conversation
05:52:19 <ndm> dcoutts_: well even without -v i was hoping for something
05:52:34 <dcoutts_> ndm: usually one gets back OK or and error message
05:52:45 <dcoutts_> ndm: but there's no upload progress or anything like that atm
05:52:50 <ndm> dcoutts_: just tried it with -v3, absolutely nothing
05:53:07 <dcoutts_> ndm: it terminates immediately or hangs doing nothing?
05:53:34 <hpaste>  ndm pasted "Cabal upload interaction" at http://hpaste.org/6183
05:53:45 <ndm> dcoutts_: terminates, instantly
05:54:32 * dcoutts_ grins
05:55:00 <ndm> same behaviour with my correct password and the wrong one
05:55:04 <dcoutts_> ndm: oh, sorry that's not very clear is it
05:55:16 <dcoutts_> ndm: it expects a .tar.gz file to upload
05:55:21 <ndm> lol
05:55:28 <ndm> couldn't it use the one i just told it to generate?
05:55:30 <dcoutts_> it is iterating over each file you supplied :-)
05:55:40 <ndm> ah, the null iterate :)
05:55:43 <dcoutts_> so it's uploading everything you told it to
05:55:45 <dcoutts_> right :-)
05:55:54 <ndm> well, at least that makes sense
05:56:10 <dcoutts_> a usage message might be in order there :-)
05:56:11 <ndm> i would also be much happier if it used password entry, rather than getLine
05:58:06 <dcoutts_> ndm: if you can work out how to do that portably send a patch
05:58:35 <ndm> dcoutts_: ok
05:59:00 <dcoutts_> ndm: it's also possible to save username and/or password in the cabal config file
05:59:37 <georgw> Hmm.. it seems to work, but to me command line parsing is a mess... ;-)
06:01:19 <ndm> georgw: why? GetOpt is perfectly sufficient for all my needs
06:03:18 <explisixjelly> data AlexPosn = AlexPn !Int
06:03:23 <explisixjelly> what's that ! for?
06:03:33 <georgw> ndm: Seems kinda messy that I have to define data Options with input then a list of options for handling, then some processing in main. Seems like an awful lot to do. But I'm probably just a scared beginner. ;-)
06:03:34 <Zao> explisixjelly: Strictness.
06:03:40 <explisixjelly> Zao, strictness?
06:04:25 <Zao> It will evaluate the member to weak head normal form, to get rid of any excessive thunking.
06:04:36 <Zao> Or something along those lines, I defer to people who know stuff.
06:04:45 <ndm> georgw: its usually the best way to go if you want decent option handling, there was simpleargs announced on haskell a few days ago, which may be more what you want
06:04:50 <explisixjelly> weak head normal form. to get rid of thunking. uh-huh.
06:05:04 <Zao> explisixjelly: A thunk is a delayed computation.
06:05:09 <explisixjelly> ah
06:05:16 <Zao> It can evaluate to either another thunk or a value.
06:05:17 <georgw> ndm: Well, it works now, I'll stick to that for now. And will try to understand what exactly it does later. ;-)
06:05:27 <explisixjelly> Zao, I guess you have me enough pointers so that I can look it up, thanks
06:05:42 <Zao> explisixjelly: If you're overly lazy, you could get some rather massive thunks to evaluate, so it might help to have some strictness here and there.
06:06:51 <explisixjelly> Zao, ah, I see
06:14:07 <shapr> Quasiquoting is really neat.
06:14:34 <shapr> Is there a ghc 6.9 available for win32?
06:14:39 <shapr> Yeah, I know, silly question.
06:14:45 <radix> shapr: hey
06:14:49 <shapr> y0 radix
06:14:49 <radix> shapr: update mage
06:14:53 <shapr> wah?
06:14:55 <radix> shapr: it doesn't work with latest ghc :)
06:14:58 <shapr> I didn't write it, dark did.
06:15:08 <radix> shapr: oh, ok. I think it was in ~shae so I assumed you did
06:15:20 <shapr> Nah, I just archived a bunch of Haskell code that other people were throwing out.
06:15:39 <shapr> mage is pretty cute though.
06:15:43 <shapr> I was an alpha tester.
06:16:29 <radix> ok, cool
06:16:30 <shapr> dark also wrote an uncompiler, a source control system, and some other bits and pieces.
06:16:40 <radix> I think it's using Data.FiniteMap or something
06:16:47 <shapr> Um, that is old.
06:16:52 <radix> I learned :)
06:16:59 <shapr> Should be Data.Map I think.
06:17:06 <radix> the release is from 2002 after all :)
06:17:15 <radix> shapr: is it likely compatible?
06:17:21 <shapr> I don't know.
06:17:22 <shapr> Try it!
06:17:30 <shapr> Ask me if you run into problems.
06:17:33 <radix> cool, I will :)
06:17:46 <radix> shapr: so, have you made plans for CHUG this saturday?
06:18:36 <Cheery> I probably need to make a file serializer that is able to add align bits
06:18:40 <DukeDave> So, hmake says "you'll never need makefiles again", but I'm, a little confused; how do I use it? :|
06:18:50 <radix> shapr: Twisted hackers are all getting together to sprint tomorrow, and it'd be a very good chance to meet up for dinner.
06:19:07 <malcolmw> DukeDave: hmake -ghc Program
06:19:23 <shapr> radix: Haven't made plans yet. I think I'm going to try for a pre-CHUG dinner to meet people and get them interested.
06:19:24 <malcolmw> DukeDave: it's a bit like ghc --make Program :-)
06:19:40 <shapr> radix: When is the sprint over?
06:19:51 <Cheery> and is able to handle LSB/MSB correctly, etc.
06:20:03 <DukeDave> So you can't actually use it with Makefile-esque files
06:20:05 <radix> shapr: we generally end with a late dinner
06:20:11 <shapr> How late? 2am?
06:20:15 <radix> heh, not that late :)
06:20:23 <radix> something like 8pm
06:20:35 <DukeDave> Binaries in src folder = badness
06:20:44 <shapr> Hm, so a 7:30pm dinner near the Twisted HQ would probably work out.
06:21:02 <shapr> TQH is in Porter Square, right?
06:21:05 <radix> shapr: yes
06:21:09 <malcolmw> DukeDave: you can ask for object files to go somewhere else, e.g. with -dobjdir (IIRC)
06:21:12 <radix> shapr: we found out that a place called The Tavern isn't too bad
06:21:14 <shapr> um, THQ.. too tired to spell.
06:21:21 <shapr> Is it somewhat affordable as well?
06:21:36 <DukeDave> malcolmw: Cheers
06:21:43 <shapr> I can't guarantee that all attendees will be as well paid as the Twisted guys!
06:21:58 <radix> let's see, we had 5 people with drinks and I think the bill was about $105
06:22:21 <shapr> That is affordable3.
06:22:22 <radix> (I mean, food *and* drinks ;)
06:22:29 <shapr> Right, I understood.
06:22:42 <shapr> daf will be at the sprint?
06:22:49 <radix> I've had 5 people with *just* drinks and a $250 bill...
06:22:52 * shapr wonders who else to invite
06:22:57 <radix> shapr: daf seemed interested
06:23:07 <shapr> cjb might show up.
06:23:08 <radix> daf: still interested? :)
06:23:14 <shapr> I could invite Dave Herman, dunno if he'll show up.
06:24:13 <skorpan> geez, how do i update a specific key in a [Data.Map]?
06:24:22 <shapr> radix: Tavern in the Square?
06:24:26 <skorpan> i can't figure it out
06:24:45 <radix> shapr: that looks like it
06:25:12 <skorpan> oh.. union.
06:25:39 <shapr> skorpan: Union Square?
06:25:47 <skorpan> yes, union square.
06:25:53 <Baughn> skorpan: Same way you inserted the key in the first place
06:26:26 <skorpan> Baughn: no, not really. i insert stuff with Data.Map.insert.
06:27:18 <ndm> skorpan: yeah, insert again will work - read the haddock documentation for it and it says so
06:27:22 <Baughn> skorpan: Right, so..?
06:27:54 <skorpan> oh
06:28:53 <daf> shapr: you're thinking of doing dinner after the sprint?
06:29:45 <explisixjelly> :t Maybe
06:31:01 <shapr> daf: Yup
06:31:12 <shapr> Thinking of inviting some random Haskellers I know around town.
06:31:20 <shapr> Haven't I seen Ethan Aubin here lately?
06:32:19 <roconnor> The section on trace semantics for IO in Tackling the awkward squad makes no sense.
06:32:55 <roconnor> They suggest perhaps semantics of IO to be type IO a = (a, Set Trace)
06:33:09 <roconnor> but I don't see how to define the semantics of getChar
06:33:12 <Cheery> @hoogle Functor
06:33:27 <roconnor> type IO a = Set (a, Trace) I might believe
06:33:36 <roconnor> Maybe it was a typo.
06:34:39 * roconnor checks out the Roscoe reference.
06:34:47 <roconnor> thank god for books being online.
06:35:05 <roconnor> and by thank god, I guess I really mean thank humankind.
06:35:16 <hpaste>  (anonymous) annotated "Templated argument-munging function" with "(no title)" at http://hpaste.org/6134#a2
06:36:10 <Cheery> the Functor -thing seems like interesting
06:36:19 <Cheery> where does it become from?
06:36:32 <Cheery> appears it allow me to implement a map for any container
06:36:48 <roconnor> yep
06:37:36 <SamB> some kind of abstract mathematical nonsense...
06:38:17 <tromp> hello shae. long time no see
06:38:25 <shapr> hoi tromp!
06:38:33 <shapr> What's up with your life? I haven't heard from you in loong!
06:38:49 <tromp> my life is quite turned around
06:39:13 <shapr> Are you still playing in the lambda playground?
06:39:21 <shapr> Still doing recumbent cycling?
06:39:28 <BMeph> tromp: Right 'round, like a record, baby? ;)
06:39:29 <tromp> i left amsterdam for a girl in winnipeg, i've known for 13 years
06:39:36 <shapr> Whoa
06:39:44 <tromp> who i'm now married to
06:39:46 <shapr> Does that mean you'll come to Boston sometime and hang out with a bunch of Haskellers?
06:39:48 <shapr> Awesome!
06:40:05 <tromp> and i live and work in long island now
06:40:25 <tromp> we visited boston a few months ago
06:40:36 <BMeph> I've heard Long Island's sound...or did they mean...
06:40:46 <shapr> tromp: Aw, I didn't know.
06:40:54 <shapr> Admittedly, I wasn't here before January.
06:40:57 <tromp> Sound is the water north of LI
06:41:14 <tromp> we can see CT across the sound
06:41:58 <tromp> haven't done much lambda playing in past 2 years
06:42:22 <shapr> Do you have another research job?
06:42:45 <tromp> no, working for a hedge fund:(
06:43:10 <shapr> Do you get to write Haskell?
06:43:13 <tromp> no haskell here though
06:43:15 <shapr> Or maybe OCaml?
06:43:16 <shapr> aww
06:43:24 <tromp> neither
06:43:33 <shapr> Jane Street is in NYC, I've heard they do OCaml.
06:43:34 <tromp> perl a planty
06:43:45 <tromp> plenty
06:43:51 <tromp> and c++
06:44:07 <shapr> Well, at least it's not ditch digging.
06:44:12 <tromp> yes, i read about jane street
06:44:38 <tromp> did you hop the pond permanently?
06:44:39 <shapr> tromp: On the good side, this means we can finally compare unicycling to recumbent cycling.
06:44:52 <shapr> tromp: Yeah, the Swedish female dumped me.
06:44:54 <tromp> my bents are still in amsterdam
06:45:00 <shapr> aww
06:45:07 <tromp> hope to move them this summer
06:45:10 <shapr> Well, I can teach you to unicycle if you spend a few days in Boston :-)
06:45:16 <tromp> once my apt there sells
06:45:34 <shapr> Well, I'm finding more and more Haskellers in the northeastern USA!
06:45:44 <tromp> great; we're bound to visit boston again some time
06:45:54 <gogonkt-``> :)
06:45:55 <cin> would it be feasible to apply a first-class pattern to a monadic bind? could that ever be a good idea?
06:45:56 <shapr> Cool, hopefully there will be regular CHUG meetings.
06:45:57 <Cheery> is it a bad operation to take the length of ByteString?
06:46:17 <shapr> tromp: Doing any research for fun?
06:46:26 <dcoutts_> Cheery: for a strict one it's fine, for a lazy one you're forcing the whole thing into memory
06:46:47 <tromp> i occasionally work on a go program with a colleague
06:46:56 <cin> let's say i'm given a list of Foo a, and i want to pattern match across that to get a list of a
06:46:57 <tromp> called dimwit
06:46:57 <shapr> tromp: No more orimaze, kolmogorov stuff?
06:47:15 <tromp> not in a long time
06:47:22 <dcoutts_> Cheery: remember, a strict one is just one big chunk that's always in memory, a lazy bytestring can be thought of much like a lazy list
06:47:30 <quicksilver> cin: [a | Foo a <- list]
06:47:31 <tromp> i still practice my 5x5 orimaze once a week:)
06:47:57 <tromp> http://homepages.cwi.nl/~tromp/oriscript5.html
06:47:59 <shapr> Is your go playing program in Haskell?
06:48:14 <tromp> no, it's kinda perfoirmance critical
06:48:20 <tromp> so c++ :(
06:48:26 <cin> quicksilver: a list comprehension isn't a pattern, though, is it
06:48:47 <shapr> aww
06:49:01 <tromp> my binary lambda calc paper appeared in a book
06:49:07 <quicksilver> cin: Foo a is a pattern.
06:49:11 <shapr> Nifty, what book?
06:49:28 <cin> quicksilver: "[a | Foo a <- list]" isn't a pattern
06:49:29 <quicksilver> cin: I wasn't quite sure what you meant by your first question, but that example I gave is the standard way to do it
06:49:46 <quicksilver> cin: it does, however, do what you wanted.
06:49:48 <matthew_-> @where showHex
06:49:56 <tromp> "Randomness and Complexity" edited by C. Calude
06:50:03 <cin> quicksilver: that's not what i wanted
06:50:05 <quicksilver> "let's say i'm given a list of Foo a, and i want to pattern match across that to get a list of a"
06:50:14 <shapr> tromp: Any ideas how to make an efficient lambda calculus CPU?
06:50:18 <quicksilver> it is at least what you said you wanted :)
06:50:24 <Cheery> dcoutts_: so just like with evaluating an infinite list right?
06:50:25 <cin> quicksilver: no.
06:50:27 <ndm> shapr: already done, see the reduceron
06:50:28 <shapr> I saw lambda in a can recently and figured there must be something more efficient.
06:50:55 <shapr> ndm: I saw that, but it's not very fast. I do like the parallel nature, but I dunno if I could run an FPGA in an altoids tin.
06:51:01 <cin> quicksilver: i mean a pattern which matches a whole list, not a pattern which can be used to match individual items of a list in a list comprehension
06:51:10 <dcoutts_> Cheery: right, so it depends on how long you expect it to be, if it's very large or possibly infinite then avoid forcing the whole thing
06:51:23 <ndm> shapr: it is very fast, can draw with optimised GHC given the right FPGA
06:51:26 <shapr> On the other hand, that would very much be applied research.
06:51:35 <shapr> ndm: draw with optimized ghc? what?
06:51:42 <ndm> shapr: yep
06:51:50 <shapr> What does that mean?
06:51:50 <quicksilver> cin: yes, it isn't that. I agree. It does however have the effect you wanted.
06:52:00 <tromp> http://www.amazon.com/Randomness-Complexity-Leibniz-Chaitin-Cristian/dp/9812770828
06:52:01 <ndm> shapr: as long as you don't have a benchmark that ghc manages to end up as unboxed int manipulations
06:52:03 <quicksilver> cin: and it is something like a patter matching over a monadic bind.
06:52:08 <paczesiowa> is it possible for gci to reload source file everytime it changes?
06:52:09 <cin> quicksilver: nevermind
06:52:11 <ndm> shapr: same wall clock speed as
06:52:28 <shapr> tromp: Cool! Did you get a free copy? :-)
06:52:35 <tromp> of course:)
06:52:44 <shapr> Nifty
06:52:55 <matthew_-> fab. I love how the ghc libraries index javascript search destroys firefox and my computer. So helpful that...
06:53:08 <tromp> don't see a lambda cpu as something practical
06:53:23 <tromp> we just need ghc to get better
06:53:23 <ndm> matthew_-: that is my fault, its because GHC decided to index many many more libraries all of a sudden
06:53:25 <quicksilver> cin: I think it's quite rude to enter into a conversation on IRC and then treat someone like an idiot and refuse to explain what you really meant, when they engage with your topic.
06:53:43 <shapr> I don't think a lambda / graph reduction CPU will be practical before someone puts in real effort.
06:53:53 <dcoutts_> ndm: no, it's haddock's own javascript index search which is awful
06:54:01 <ndm> dcoutts_: yes, which is my fault
06:54:09 <shapr> Also, I'm convinced that strictness is purely a cultural issue having to do with strict CPUs, and I'd like to try the other altenatives.
06:54:13 <dcoutts_> ndm: oh, ok, good, send a patch to remove it :-)
06:54:41 <ndm> dcoutts_: i will, it worked fine when i did it, but then the libraries grew massively and it failed
06:54:43 <tromp> my Fhourstones benchmark is still WAY slower in Haskell
06:54:47 <dcoutts_> ndm: right
06:55:30 * shapr looks for fhourstones
06:55:53 <shapr> aha
06:56:03 <smg> someone has a dictionary which translates "thunk"?
06:56:11 <tromp> http://homepages.cwi.nl/~tromp/c4/fhour.html
06:56:17 <smg> i know thunk is an unevaluated block of code but.. :)
06:56:27 <shapr> smg: That's pretty much it... what else do you want to know?
06:56:44 <smg> does it come somehow from chunk?
06:56:45 <cin> smg: it's sometimes talked about like a function with no arguments
06:56:49 <sebell> smg: I think of a thunk as a function with no parameters
06:57:04 <tromp> i tried to put in strictness annotations in all the right places
06:57:17 <shapr> smg: http://en.wikipedia.org/wiki/Thunk
06:57:38 <smg> 	A dull, hollow sound: the thunk of a metal pipe striking a tree. <-- haha :)
06:57:44 <smg> shapr: good idea
06:57:59 <Toxaris> smg: wikipedia translates thunk as "delayed computation"
06:58:03 <tromp> does ghc do Int64 operations natively yet, instead of with library calls?
06:58:18 <dcoutts_> tromp: on 64bit machines, yes :-)
06:58:22 <quicksilver> on 64 bit machines, I believe it does
06:58:32 <shapr> dcoutts_: Does ghc support SIMD ops any?
06:58:40 <matthew_-> and on 128 bit machines?
06:58:40 <dcoutts_> shapr: no
06:58:43 <shapr> aww
06:58:44 <tromp> than Fhourstones shld be doing a bit better now
06:58:46 <tromp> then
06:58:58 <tromp> it's very 64bit intense
06:59:10 <smg> ToRA: http://en.wiktionary.org/wiki/thunk
06:59:29 <smg> wiktionary means its an Onomatopoeic :]
06:59:31 <tromp> where do you live now, Shae?
06:59:53 <shapr> Boston, MA
07:00:02 <shapr> Actually in Somerville, about two miles from MIT
07:00:06 <tromp> did you find a job there?
07:00:10 <shapr> smg: Hah, I like etymology 3
07:00:19 <araujo> morning
07:00:21 <shapr> tromp: Yeah, I gave up my Haskell job to take a C# job.
07:00:30 <hpaste>  sebell pasted "Network.Socket woes" at http://hpaste.org/6184
07:00:31 <earthy> hm. that's strangely similar to the last name of Ian Sommerville
07:00:39 <smg> shapr: ah yes better
07:00:46 <tromp> what kind of job?
07:01:10 <matthew_-> ok, say you've got a function f which you know may never terminate, but you also know that it will reach a fixed point. Can you run it just as long as is necessary to reach that fixed point?
07:01:18 <sebell> Anyone have any troubleshooting advice on the above paste?
07:01:20 <shapr> tromp: I'm working for a consulting firm. At the moment that means I get to hack C# for project management.
07:01:50 <shapr> Much of my reasons for taking this job is that I get to work with smart people, and I was sick of my life before this.
07:02:03 <Toxaris> matthew_-: a function f :: a -> a ?
07:02:20 <matthew_-> Toxaris: sortof
07:02:37 <matthew_-> you're going to suggest using fix aren't you?
07:02:44 <shapr> tromp: What about you, do you get to do cool stuff in perl/C++ ?
07:02:49 <matthew_-> wouldn't that require Eq ?
07:03:00 <quicksilver> fix doesn't use Eq.
07:03:06 <Toxaris> matthew_-: fix is something different
07:03:13 <quicksilver> but it wouldn't solve this problem either :)
07:03:17 <matthew_-> quicksilver: indeed not
07:03:43 <Toxaris> matthew_-: yes, my proposed solution needs Eq, of course. you have to somehow determine that you reached an fixed point
07:03:48 <tromp> it's somewhat interesting, we do algorithmic trading too
07:03:59 <matthew_-> Toxaris: f :: (InsertInTypeMap m1 key val m2) => m1 -> m2
07:05:02 <tromp> but it's mostly massaging big existing codebase
07:05:18 <Dybber> Is it possible to fold over the machinewords that a bytestring consists of? (I want to create a hash)
07:05:31 <quicksilver> sure.
07:05:40 <dcoutts_> Dybber: yes! use foldl or foldr (or foldl' or foldr')
07:05:40 <quicksilver> there is a fold in Data.Bytestring I believe.
07:05:42 <Cheery> hm. my ByteWriter -monad is becoming complex...
07:05:46 <roconnor> @instances foldable
07:05:47 <tromp> i think 2/3 of ppl herre have PhD
07:06:00 <Cheery> It needs to specify endian, align, and bunch of other stuff... :P
07:06:06 <dcoutts_> tromp: that's probably an over-estimate
07:06:22 <Cheery> soon I call it HellMonad
07:06:22 <dcoutts_> tromp: many are only starting or half way through PhDs :-)
07:06:22 <Toxaris> matthew_-: something like myfix = head . head . dropWhile (null . drop) . group . iterate
07:06:29 <roconnor> only 1/3 have a PhD, and another 1/3 are PhD candidates.
07:06:54 <matthew_-> Toxaris: I wonder if laziness will just mean that it works
07:07:03 <roconnor> Cheery: they are supposed to be warm an fuzzy.
07:07:05 <roconnor> :)
07:07:10 <shapr> tromp: And some have no degree at all :-)
07:07:15 <Dybber> dcoutts_: thanks, I don't really know why I didn't found them myself
07:07:17 <matthew_-> because surely f will only ever do work when the existing values it's produced don't satisfy what's needed
07:07:21 <Toxaris> matthew_-: but what's you're InsertInTypeMap about? your function has type m1 -> m2, how can you get a fixed point of it?
07:07:24 <shapr> Oh wait, you didn't mean "here" as in #haskell
07:07:28 <Jomyoot> Is there a persistence storage in haskell?
07:07:30 <Cheery> roconnor: well, you'll soon see my ByteWriter. ;)
07:07:36 <tromp> i mean in my company
07:07:37 <matthew_-> Toxaris: well, it's a type-level map.
07:07:43 <shapr> Ah cool
07:07:45 <Cheery> it is *not* warm and fuzzy
07:07:49 <matthew_-> and I need to add lots of stuff to it.
07:07:53 <roconnor> Cheery: this is something different from Data.Binary
07:07:57 <roconnor> ?
07:08:03 <matthew_-> oh no, this whole approach is rubbish.
07:08:04 <matthew_-> grr.
07:08:07 <shapr> tromp: Makes for fun lunches?
07:08:08 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6185
07:08:27 <tromp> i try to get them to play Go with me during lunch:)
07:08:36 <shapr> haha
07:08:37 <smg> another strange question i have is at this paste, maybe someone can answer it. i cannot.
07:08:51 * matthew_- realises his next idea would make compilation non-deterministic
07:09:05 <Jomyoot> dude. is there a persistence storage for data in Haskell?
07:09:10 <Jomyoot> i asked this since yesterday
07:09:15 <Cheery> roconnor: it is a bit different, I show you soon
07:09:29 <Cheery> @hoogle (Maybe a) -> a -> a
07:09:30 <Toxaris> matthew_-: do you want a type-level fixed point or a value-level fixed point or something else?
07:09:39 <matthew_-> Jomyoot: if you set up Show and Read instances, yes. If you set up Binary instances, yes.
07:09:40 <Cheery> @hoogle a -> (Maybe a) -> a
07:09:54 <roconnor> @type maybe
07:09:57 <matthew_-> Toxaris: type level
07:09:58 <idnar> matthew_-: that doesn't really sound like a persistence system
07:10:03 <Jomyoot> mathew: is it efficinent like berkely DB basically a persistant hash or map?
07:10:24 <matthew_-> Jomyoot: oh, well you can chuck haskell values in a RDBMS if you want
07:10:25 <smg> maybe quicksilver? :)
07:10:31 <matthew_-> or you can use files or whatever you want
07:10:35 <Jomyoot> i want a self-contained
07:10:40 <matthew_-> eh?
07:10:46 <matthew_-> a la Mnesia for Erlang?
07:10:47 <Jomyoot> nvm
07:10:55 <shapr> Jomyoot: I don't think your question was clear.
07:11:02 <idnar> matthew_-: do you know of something like that?
07:11:07 <Toxaris> matthew_-: hmm ok then i don't understand what you want.
07:11:11 <matthew_-> idnar: nope.
07:11:21 <matthew_-> Toxaris: for it "to work" ;)
07:11:42 <Toxaris> matthew_-: oh cool, that's easy, just write correct code ;)
07:11:48 <Jomyoot> I am looking for a Haskell library that allows me to exist my hashtable, hash, map on a filesystem as well as in memory and be efficient. BerkeleyDB does what I want, but it has hefty license.
07:11:55 <Jomyoot> And BerkeleyDB is not in Haskell
07:12:21 <matthew_-> ok, well Haskell doesn't really make use of hashtables or hashes.
07:12:40 <matthew_-> I would suggest you look at the database bindings and using an RDBMS
07:12:59 <shapr> Jomyoot: A Data.Binary instance for Data.Map would likely do what you describe.
07:13:06 <smg> Does someone maybe can answer http://hpaste.org/6185 ?
07:13:23 <matthew_-> shapr: yeah, that's true. Or you could look at something fairly lightweight like sqlite
07:13:29 <Toxaris> smg: have you tried wether the ~'s make any difference here?
07:14:04 <shapr> The most lightweight solution would be using Read and Show and a text file.
07:14:06 * Corun wonders what ~ does in patterns
07:14:14 <matthew_-> Corun: forces them to be lazy
07:14:19 <Corun> Yarr.
07:14:31 <Corun> But, er, aren't they lazy anyway, emehay?
07:14:35 <ToRA> smg: head' isn't typed correctly
07:14:36 <matthew_-> i.e. you assume the pattern match works and only actually check it when you need a value exposed by the pattern match
07:14:39 <Toxaris> smg: because as i understand lazy patterns, they make sense only when there's just a single case, because this case is then taken without forcing any thunks. but in your example, there are multiple cases. how to decide which case to take without forcing anything?
07:14:45 <tromp> the final round of Linares chess tournament just started
07:15:08 <doserj> smg: head [] = [] won't typecheck in any case...
07:15:27 <smg> doserj: true my mistake
07:15:28 <ToRA> smg: and head'' is the same as head, since you are strict in the first argument to check whether it's [] or not anyways
07:15:34 <quicksilver> smg: (a) neither of them typchecks (b) there is no simple answer about whether or not ~ is more efficient.
07:15:36 <Toxaris> Corun: not at all. patterns are the only thing in haskell which isn't lazy. pattern matching is used to deconstruct values, forcing them on the way
07:15:58 <smg> so i can't say ~ is 'better' than _ it just "depends"
07:16:10 <quicksilver> smg: if it was better, why wouldn't it be the default :)
07:16:15 <matthew_-> well, _ is better if you don't need the value
07:16:17 <smg> hehe
07:16:17 <quicksilver> smg: however, there is a guideline.
07:16:27 <Corun> Hmm, I guess so.
07:16:32 <quicksilver> the guideline is : 99.9999% of haskell programmers will never use ~ in their lives.
07:16:35 <quicksilver> ;)
07:16:39 <smg> haha
07:16:46 * ToRA feels special
07:16:51 <smg> hehe
07:16:52 <quicksilver> ! gets used more often.
07:16:56 <smg> hehe
07:17:08 <quicksilver> ~ is normally used to stop an infinite loop in some clever clever recursion.
07:17:09 <smg> i personally like _ more it looks nicer, just kidding ;-)
07:17:30 <shapr> But when you need ~, you really need it!
07:17:37 <smg> yes
07:17:38 <Toxaris> Corun: the following code fails, because the pattern is strict, even if the bound variable is never used: case undefined of Just _ -> 42
07:17:39 <hpaste>  (anonymous) annotated "Network.Socket woes" with "(no title)" at http://hpaste.org/6184#a1
07:17:44 <quicksilver> Toxaris: to be precise case patterns and function-definition patterns. Not let patterns.
07:17:52 <quicksilver> shapr: you can quite often rewrite with let, can't you?
07:17:57 <ToRA> shapr: really? can't you always re-write in terms of let/where and a suitibly lazy function?
07:18:07 <Toxaris> Corun: but this code works because of the explicit ~: case undefined of ~(Just _) -> 42
07:18:08 <shapr> Yes, but the difference in line count can be significant.
07:18:37 <Corun> Ah, I think i see.
07:18:41 <matthew_-> Toxaris: yes, and if anyone ever submitted code that looked like that I'd have to think very hard before asking them to leave uni
07:18:48 <shapr> I wonder if mdo can always be rewritten with let/where?
07:18:52 <shapr> I don't remember.
07:18:56 <smg> $! is also handy
07:19:27 <quicksilver> $! is heavily overused, often in entirely useless ways.
07:19:29 <quicksilver> :)
07:19:33 <smg> btw i will find all special operator like $! and ! in the haskell report?
07:19:37 <quicksilver> people misunderstand seq quite badly.
07:19:43 <Toxaris> matthew_-: looked like what?
07:19:46 <quicksilver> ! isn't an operator, in the sense you mean.
07:19:53 <quicksilver> ! is a special syntax.
07:19:53 <smg> quicksilver: so ! === seq ?
07:19:58 <shapr> My suggestion is to leave the use of seq and $! to people like dons.
07:20:06 <quicksilver> not exactly.
07:20:14 <quicksilver> but ! uses seq to do its dirty work.
07:20:20 <smg> shapr: mh now i need to know who dons is ;-)
07:20:20 <quicksilver> $! *is* just an operator.
07:20:21 <shapr> On the other hand, strictness added to datatypes is easier to understand, imho.
07:20:23 <smg> hehe
07:20:35 <smg> http://www.haskell.org/haskellwiki/Performance/Strictness
07:20:40 <smg> quicksilver: i read that here with $! :)
07:20:48 <Toxaris> smg: you will find all more or less special operators with http://haskell.org/hoogle/
07:20:53 <paczesiowa> is it possible for ghci to reload source file everytime it changes?
07:21:00 <hpaste>  Cheery pasted "HellMonad" at http://hpaste.org/6186
07:21:02 <matthew_-> Toxaris: where you've specified a pattern match which you obviously don't care about
07:21:03 <dejones> Is cabal-install dependable?  :)  I really don't want to manually install all these package dependencies.
07:21:19 <Cheery> roconnor: there it is
07:21:39 <smg> Toxaris: yeah i already acclimated to hoogle :)
07:21:40 <Toxaris> matthew_-: hehe ok, this was not about the usefullnes of ~, but about it's semantics
07:21:49 <matthew_-> Toxaris: whereas "~(Just e) -> if x then 42 else e" is more acceptable
07:21:59 <matthew_-> sure :)
07:22:17 <Cheery> @hoogle ~
07:22:26 <Cheery> @hoogle (~)
07:22:27 <Toxaris> matthew_-: but that could be trivially rewritten to if x then 42 else case ...
07:22:44 <matthew_-> yeah, that's not a good example. Cue ToRA:
07:22:49 <smg> @src ($!)
07:23:35 <quicksilver> f $! a = a `seq` f a
07:23:48 <quicksilver> which is not what most people assume.
07:23:54 <smg> quicksilver: thank you lambdabot v2 :)
07:24:00 <quicksilver> most people assume that it magically forces a to be evaluated when *they* want.
07:24:03 <hpaste>  Dybber pasted "instance declaration trouble" at http://hpaste.org/6187
07:24:06 <Toxaris> matthew_-: hoogle links to an interesting example: http://www.haskell.org/haskellwiki/Keywords#.7E
07:24:15 <quicksilver> whereas all it actually does it force it to be evaluted when the result of f is inspected.
07:24:18 <quicksilver> not quite the same.
07:24:29 <Dybber> Can anyone take a look at what I just pasted, I can't see whats wrong
07:24:31 <ToRA> > let bar ~(Just x) = (Just x) in isJust (bar Nothing)
07:24:43 <ToRA> > let bar ~(Just x) = (Just x) in fromJust (bar Nothing)
07:24:58 <Dybber> I hope you can see what I want to accomplish
07:25:04 <smg> your definition then means bottom if a is bottom else f a
07:25:20 <Cheery> if top is bottom then blaah
07:25:34 <doserj> Dybber: the error msg explicitely say what is wrong and how to fix it.
07:25:44 <roconnor> Cheery: shouldn't ByteWriter be parametereized by Endian instead?
07:25:56 <Dybber> doserj: I don't really understand it
07:26:07 <quicksilver> ToRA: the ~ is superfluous with a let, as I understand it.
07:26:12 <doserj> Dybber: but the instance declaration may not really be what you want
07:26:13 <Cheery> roconnor: explain
07:26:30 <ToRA> quicksilver: don't think so in those examples...
07:26:34 <roconnor> Cheery: well, I don't know how you are using Endian, but I can guess.
07:26:46 <quicksilver> ToRA: oh, I misread :)
07:27:00 <roconnor> Cheery: I sort of imagine that Endianness ought to be consistent accross the entire ByteString output.
07:27:01 <quicksilver> ToRA: didn't see that you were defining bar :) I read let ~(Just x)...
07:27:03 <Cheery> oh, roconnor, you mean like. Result, LSBResult, MSBResult
07:27:18 <doserj> Dybber: the type for which you declare an instance can not only consist of type variables (in Haskell98)
07:28:27 <roconnor> Cheery: so you ought to have a runLSBByteWriter  and runMSBBtyewriter
07:28:34 <Saizan> dejones: yes, it works quite well, it has a couple of dependecies though :)
07:28:38 <doserj> Dybber: so the m in Hashable (m a) would have to be a concrete type constructor
07:29:06 <Cheery> roconnor: the problem is, you may want to switch the byte-order between doing things
07:29:10 <dejones> Saizan: well, I'm using darcs to download cabal-install now... "copying patches" as we speak.
07:29:41 <roconnor> Cheery: so you do want to have the ability to change byte-order during writing?
07:29:48 <Dybber> doserj: oh ok, maybe I shouldn't use typeclasses for this after all
07:29:55 <Saizan> dejones: ah, you'd need to upgrade Cabal too, then
07:30:05 <Cheery> roconnor: yep
07:30:27 <byorgey> Dybber: you can make that code compile easily using the -XFlexibleInstances parameter to ghc (or putting {-# LANGUAGE FlexibleInstances #-} at the top)
07:30:45 <byorgey> doserj: why might that instance declaration not be what Dybber wants?
07:31:00 <dejones> Saizan: figures. ;) darcs get cabal now too :P
07:31:18 <roconnor> Cheery: in that case I would still be inclide to remove it from the ByteWriter monad.  It seems like it ought to be a parameter of the your tell command.
07:31:41 <Saizan> dejones: use --partial for a speedup :)
07:31:48 <roconnor> Cheery: otherwise the byteorder is implict, and unknown, and that strikes me as error-prone.
07:32:07 <Dybber> byorgey: I think I'll drop using classes, I tried to use a class before I learned about Foldable
07:32:18 <roconnor> Cheery: someone could insert a new command to change the byte order and break everything that comes after.
07:32:25 <byorgey> Dybber: ok
07:33:10 <doserj> byorgey: e.g., he will not be able to declare another instance for another type constructor
07:33:16 <dejones> Saizan: thanks. :)
07:33:17 <roconnor> Cheery: granted a lot of people design things like you have, but they are all wrong too :)
07:33:24 <byorgey> doserj: oh, good point
07:33:35 * roconnor grumbles at c++ streams
07:34:07 * shepheb has been writing a thread, networked app. there were a couple of minor almost-syntax errors (transposing port and hostname arguments, for example) once it got going, though, everything works on the first try.
07:34:35 <dejones> Saizan: is --partial available in the "stable" release?
07:34:37 * byorgey high-fives shepheb 
07:35:19 <shepheb> this is a very foreign feeling. I'm shocked how much win Haskell brings.
07:35:50 <dejones> Saizan: it seems it is. thanks
07:37:36 <roconnor> shepheb: that's a pretty impressive result for Haskell.
07:38:13 <roconnor> shepheb: I knew single threaded development was like that, but I'm happy that it also works for multi-threaded aps.
07:38:18 <shepheb> roconnor: oh, I know. it's a relatively simple app, too. but there's no concurrency problems and the server handles even abrupt disconnects gracefully.
07:38:47 <shepheb> my TChan structure is so simple I'm convinced it's correct. that's never happened before in a threaded app I've worked on.
07:40:40 <shepheb> I'm already awash in Haskell Kool-Aid, but if I weren't already, this would convert me again.
07:41:07 <shapr> shepheb: Write a blog entry!
07:41:29 <shepheb> shapr: that requires step 0: set up a blog. we'll see.
07:41:32 <radix> is there a planet haskell?
07:41:32 <shapr> heh
07:41:36 <shapr> radix: Yes
07:41:38 <shapr> planet.haskell.org
07:41:39 <radix> indeed there is
07:41:39 <byorgey> if you don't publish it, it didn't happen! ;)
07:41:43 * radix subscribes
07:41:47 <radix> uh oh
07:41:49 <radix> shapr: bugz
07:41:52 <Vq^> shapr: workin on it... :/
07:41:58 <shapr> bugz?
07:42:08 <idnar> I usually subscribe to individual blogs, rather than a planet feed
07:42:13 <radix> oh wait, weird. shapr: there was a temporary Service Unavailable the first time I hit, I guess.
07:42:29 <radix> idnar: well, it depends if they've allowed some jerk who talks about how emo he is all the time on the planet...
07:42:57 <radix> idnar: kinda like planet twisted + moshez, except instead of "emo" it's "happy"
07:43:06 <Cheery> roconnor: ok, I think that sounds ok
07:43:21 <shapr> Is Moshez emo nowadays?
07:43:28 <shapr> He seemed cheerful last time I met him.
07:43:30 <radix> shapr: reread :)
07:43:42 * shepheb should go on emo sites and post about having a great day.
07:43:47 <Cheery> I guess I'd like to shadow some things from Prelude
07:44:00 <shepheb> and having a good relationship with my parents.
07:44:03 <idnar> radix: well, the thing is, I probably have some of the people on the planet in my feeds anyway
07:44:10 * radix nods
07:44:26 <gwern> I think I've thought of a new lambdacat
07:44:33 <roconnor> Cheery: it is not uncomon to shadow things from the Prelude
07:44:35 <idnar> (incidentally, I'm subscribed to moshez's feed :P)
07:44:39 <gwern> 'I are -Wall cat. This are serious warning'
07:44:53 <byorgey> gwern: hehe, awesome =)
07:44:54 <quicksilver> gwern++
07:45:02 <Cheery> roconnor: how to do it?
07:45:15 <roconnor> import Prelude hiding (map)
07:45:16 <shepheb> gwern: -Werror cat?
07:45:19 <byorgey> gwern: maybe phrase it as '-Wall cat sez: this are...' instead?
07:45:21 <roconnor> or something close to that.
07:45:47 <byorgey> but '-Wall cat' could presumably be accompanied by a picture of a cat on a wall.
07:46:07 <Valodim> "serious" is too complex a word for lolcat slang
07:46:18 <byorgey> "srs"?
07:46:29 <gwern> byorgey: I was going to reuse the 'I are serious cat. This are serious discussion' one
07:46:44 <byorgey> gwern: oh, got it. I wasn't familiar with that one. =)
07:46:47 <roconnor> serius
07:46:48 <quicksilver> import Prelude hiding(things)
07:46:52 <quicksilver> oops
07:46:57 <quicksilver> scrolled-up-error
07:46:57 <shepheb> Valodim: but this is based on Serious Cat! http://farm2.static.flickr.com/1402/822327651_1efebd248a.jpg
07:47:13 <gwern> here we go http://www.roflcat.com/i-are-serious-cat-this-is-serious-thread.php
07:47:13 <gwern> no, it spells serious right
07:47:16 <shepheb> "srs" is the standard lolcat for "serious", but this is an exception.
07:47:20 <Valodim> well yeah because it's serious cat
07:47:23 <gwern> shepheb: ah, but where's the original?
07:47:24 <roconnor> quicksilver: I'm glad you agree with me.  I can never remember where the ('s go.
07:47:26 <Valodim> heh
07:47:55 <shepheb> gwern: you mean a blank? that would be almost impossible to find, I expect.
07:48:17 <gwern> dah
07:48:37 <shepheb> well, the original blank. one with the text edited out could probably be found.
07:48:53 <quicksilver> there should be a google image search for this
07:48:58 <quicksilver> "find un-lolled-cat"
07:49:10 <gwern> http://www.flickr.com/photos/stshores24/1971289512/ <-- well, here's a cropped version looks like
07:49:48 <quicksilver> google search for 'serious cat' gives me unlolled ones
07:49:52 <quicksilver> two of them straight away
07:49:57 <quicksilver> (the joke is underneath)
07:50:04 <gwern> lolless
07:50:16 <quicksilver> http://i50.photobucket.com/albums/f337/darcitamaria/SeriousCat.jpg
07:50:31 <quicksilver> I r cheef unlolr. I can has cookie now?
07:51:00 <gwern> http://www.flickr.com/photos/squadgod/471434865/ <-- this one almost works
07:51:29 <gwern> @where lambdacats
07:51:47 * byorgey cries
07:52:09 <gwern> @where lambdacat
07:52:27 <byorgey> gwern: lambdabot is... no longer with us
07:52:29 <roconnor> @where lambdabot
07:52:42 <gwern> > 1 + 1
07:52:46 <gwern> fick!
07:52:52 <byorgey> Cale! dons! fear! fire! foes! awake!
07:52:58 <gwern> byorgey: DID YOU DO IT
07:53:13 <byorgey> nuh-uh!
07:53:21 * byorgey points at... quicksilver!
07:53:26 <shepheb> no, no! we can't turn on each other now! we have to stick together!
07:53:36 * gwern watchs byorgey sound the alarum
07:54:06 * shepheb kicks off the looting as anarchy descends.
07:54:24 * roconnor starts hording lambdas for the upcoming apocolypse
07:54:31 <byorgey> > 2 + 2
07:54:32 <byorgey> 5
07:54:34 <byorgey> BWAHAHA
07:54:46 * quicksilver declares ffi-marshal law
07:54:50 <gwern> @quote byorgey
07:55:19 * gwern quietly begins selling unsafePerformIOs from the back of the local pub
07:55:27 <roconnor> @remember byorgey > 2 + 2\n5\nBWAHAHA
07:56:33 * roconnor sets fire to ocamls parked in the streets
07:58:01 <Cheery> hmm..
07:59:11 <Cheery> I sort of don't see a reason why the ByteWriter should be a monad..
07:59:19 <byorgey> ok, serious question.  I want to create a monad that can exit computations early, but any effects up to the early-exit point should still be retained.  I want ContT, right?
07:59:48 * shepheb has no idea where all these Blu-Ray players came from.
08:00:07 <byorgey> ...the Blu-Ray player factory?
08:00:08 <roconnor> Cheery: monads are useful for sequencing things
08:00:32 <Cheery> yep, but I realise.. actually should structure, not sequence!
08:00:34 <roconnor> Cheery: and writing output to a stream is a good example of something that is sequenced.
08:00:47 <shepheb> byorgey: see re: my looting. anyway, back to business.
08:01:03 <byorgey> shepheb: oh, hehe. =)
08:02:09 <quicksilver> byorgey: someone has suggested ExitT
08:02:31 <quicksilver> byorgey: which is essentially a special case of ContT for this simple application.
08:02:36 <byorgey> quicksilver: oh, interesting.
08:02:43 <byorgey> quicksilver: is it on the wiki?
08:02:48 <quicksilver> byorgey: I.e. : yes you can do it with ContT but it's a very simple example.
08:03:02 <byorgey> I'm creating a DSL where people should be able to write something like  do { act1 ; act2 ; require pred ; act3 }  and if 'pred' is not satisfied, act3 should not be executed.
08:03:02 <roconnor> byorgey: typically throwing an exeception retains the effects upto the exit point.
08:03:02 <quicksilver> in fact, if all you want to do is exit, isn't MaybeT enough?
08:03:23 <quicksilver> that sounds like MaybeT + guard.
08:03:30 <quicksilver> or ErrorT + guard.
08:03:37 <Cheery> I pick this: class Serializable a where serialise :: a -> ByteString
08:03:40 <byorgey> quicksilver: I already tried MaybeT, the problem with that is that v >> mzero = mzero, so effects up to the exit point are not retained.
08:03:58 <quicksilver> I don't believe that is a correct law of MaybeT.
08:04:08 <quicksilver> (it is of Maybe itself...)
08:04:13 <byorgey> quicksilver: well, it's a law of MonadPlus I mean
08:04:30 <quicksilver> yeah, it woudl be an 'abuse' of guard.
08:04:41 <quicksilver> because MaybeT isn't a true MonadPlus instance in that sense.
08:04:58 <byorgey> quicksilver: yeah.
08:05:30 <byorgey> roconnor: I'd rather not use exceptions if I don't have to.  Seems icky...
08:08:37 <byorgey> quicksilver: the Maybe monad is commutative, i.e. computations in the Maybe monad either succeed as a whole or fail as a whole.
08:08:54 <byorgey> quicksilver: thanks for the ExitT pointer, I'll take a look at that.
08:09:20 <Cheery> how to get the precedence of some thing?
08:09:26 <roconnor> byorgey: yeah but MaybeT is different
08:09:33 <Cheery> and how to set the precedence for operator?
08:09:35 <byorgey> roconnor: oh, how so?
08:09:47 <byorgey> I'm still feeling my way through this stuff
08:09:52 <quicksilver> you can get with :i
08:10:04 <quicksilver> byorgey: MaybeT doesn't work like that, because it can't ;)
08:10:15 <quicksilver> it's not possible to rollback IO
08:10:16 <roconnor> byorgey: newtype MaybeT m a = MaybeT {runMaybeT :: m (Maybe a)}
08:10:22 <quicksilver> (or, indeed, inner monads in general)
08:10:27 <byorgey> oh, right
08:10:29 <roconnor> byorgey: so you either have m Nothing, or m Just a
08:10:40 <roconnor> byorgey: and the effectsof m are retained
08:10:42 <quicksilver> As a general rule, given FooT Bar, 'Foo' is totally unable to rollback 'Bar' effects.
08:10:53 <quicksilver> however, given BazT FooT Bar
08:11:00 <quicksilver> Foo *can* rollback Baz effects
08:11:09 <byorgey> aha!
08:11:18 <roconnor> byorgey: so effects inside the MaybeT are kept, while effects outside the MaybeT are lost
08:11:22 <byorgey> right, I had StateT s (MaybeT IO) a
08:11:34 <quicksilver> then it can rollback the StateT
08:11:36 <byorgey> and I was really confused why the state stuff was getting rolled back
08:11:37 <quicksilver> but not the IO.
08:11:40 <roconnor> and IO can never appear on the outside :)
08:11:40 <hpaste>  smg pasted "diff String1 String2" at http://hpaste.org/6188
08:11:40 <byorgey> right =)
08:11:41 <quicksilver> exactly.
08:11:52 <byorgey> quicksilver: so I should be able to use MaybeT (StateT s IO) a ?
08:12:05 <roconnor> byorgey: that should work
08:12:11 <quicksilver> yup.
08:12:18 <quicksilver> that should rollback neither state nor IO.
08:12:28 <roconnor> byorgey: all that being said, you may find ExitT to be ``faster''
08:12:32 <byorgey> ok, nice.  I'll have to play around with that.
08:12:38 <byorgey> roconnor: 'faster' in what sense?
08:13:02 <Saizan> oh, we've ExitT somewhere?
08:13:04 <roconnor> byorgey: of course, if you write things abstractly, you should be able to swap without changing your code
08:13:23 <roconnor> byorgey: http://r6.ca/blog/20071028T162529Z.html
08:13:51 <roconnor> ``The code without using CPS took about 8 minutes to run Endoâs DNA. The new CPS monad takes about 2 minutes!
08:13:53 <quicksilver> Saizan: on the wiki.
08:14:51 <byorgey> roconnor: ah, interesting.  well, performance is not really much of an issue in this application, so for now I'll try MaybeT, and possibly switch later.
08:15:22 <roconnor> byorgey: I recommend that.
08:15:37 <byorgey> ok, thanks to both =)  roconnor++ quicksilver++
08:15:58 <roconnor> byorgey: you can see my sequence of monad transformers: StateT DNA (MaybeT (Writer (Endo [RNA])))
08:16:21 <roconnor> byorgey: this allows me to throw away my state on exit, but keep my writer output.
08:16:40 <byorgey> roconnor: got it, cool.
08:32:17 <Lemmih> Are there any mirrors of the cabal repository? darcs.haskell.org is very slow.
08:34:46 <Cheery> how would I convert enum to integer?
08:35:03 <SamB> fromEnum
08:35:03 <Cheery> @djinn
08:35:22 <Cheery> @djinn goo :: (Enum a) => a -> Integer
08:35:33 <pa-ching> So I have a bunch of datatypes, each with a lot of constructors... I want to add an Int identifier to each one. I could just add Int to each constructor, or pass around tuples rather than the datatype... but it would be really messy. Is there any way for me to add the Int without existing pattern matching code, etc.? Some kind of Identifiable typeclass, or "hidden" field, or something?
08:35:43 <SamB> @djinn didn't grok typeclasses last I checked...
08:35:44 <Cheery> :t fromEnum
08:35:46 <pa-ching> without modifying*
08:36:04 <doserj> Cheery: fromEnum :: (Enum a) => a -> Int
08:36:09 <Cheery> yep
08:36:16 <Cheery> what I want is an Integer
08:36:18 <Cale> pa-ching: Well, if you're using record syntax
08:36:18 <SamB> pa-ching: hidden?
08:36:27 <SamB> Cheery: well, fromIntegral it then...
08:36:29 <pa-ching> Yeah, the record syntax would also be messy though
08:36:33 <Cheery> or something else which can handle 64bit
08:36:44 <SamB> what size enum are you using?
08:36:59 <pa-ching> Oh well, was hoping there'd be some nice compact way to express this...
08:37:01 <Cale> pa-ching: I think what's probably clearest is just to do some pairing.
08:37:16 <Toxaris> pa-ching: do you want to associate Int identifiers with data types, data constructors or values?
08:37:28 <Cheery> SamB: Word64 would be in mind
08:37:33 <sarehu> use fromIntegral
08:37:35 <sarehu> or toInteger
08:37:45 <SamB> Cheery: how many constructors does this type HAVE?
08:37:53 <Cale> Toxaris: He effectively wants to add an Int parameter to each of the constructors
08:38:00 <pa-ching> Er, like "data Foo = A String | B Something | C Int Int" changed to "A Int String | B Int Something | C Int Int Int"
08:38:09 <pa-ching> and there are a lot of datas
08:38:17 <pa-ching> and code that already uses 'em
08:38:19 <astrolabe> @type toInteger.fromEnum
08:38:22 <Toxaris> hmm ok, so associate Int's with values
08:38:29 <SamB> pa-ching: perhaps you should have used records to start with
08:38:45 <quicksilver> Cheery: I'm not sure a Enum which doesn't fit in 32 bits is likely to be sensible ;)
08:38:46 <pa-ching> SamB: Yeah... Blah, they're so long heheh.
08:38:52 <quicksilver> Cheery: but then I don' tknow what you're doing with it.
08:38:55 <Cale> pa-ching: I think it's probably easiest to just work with (Int, Foo) instead. That way, existing code shouldn't have to change.
08:39:11 <pa-ching> Hmm..
08:39:23 <pa-ching> Ok, well I guess there's no "magic" way to deal with this ;)
08:39:25 <pa-ching> Thanks!
08:39:29 <Cale> (Or some custom named pair type)
08:39:36 <Toxaris> quicksilver: whats wrong with instance Enum Integer?
08:39:46 <SamB> I really doubt it's a good idea to have an enumerated type with more than 2^32 constructors...
08:40:27 <quicksilver> Toxaris: the fact that Enum is defined as a bijection into Int :)
08:41:05 <SamB> actually,
08:41:24 <SamB> Int isn't guarenteed to go beyond 2^29-1...
08:41:31 * quicksilver nods.
08:41:42 <SamB> now that I think about it
08:41:51 <Toxaris> quicksilver: if Enum were a bijection into Int, which it isn't, what sense would instance Enum Bool make?
08:41:57 <oerjan> Cheery: there is no general way to losslessly convert something which is just an Enum into anything larger than Int.  but things which are Integral can be converted with fromIntegral.
08:41:58 <SamB> I'm not positive it's guarenteed to go even that far...
08:42:04 <quicksilver> Toxaris: bijection into a subset of Int.
08:42:10 <quicksilver> Toxaris: injection into Int, sorry :)
08:42:11 <Toxaris> Prelude documentation: "Class Enum defines operations on sequentially ordered types."
08:42:26 <quicksilver> oerjan: but, it won't be lossless.
08:42:36 <quicksilver> oerjan: if it's larger than int ;)
08:42:39 <Toxaris> and documentation for fromEnum: "Convert to an Int. It is implementation-dependent what fromEnum returns when applied to a value that is too large to fit in an Int."
08:42:51 <quicksilver> ah, OK.
08:42:54 <quicksilver> that's interesting.
08:43:06 <quicksilver> I didn't know you were allowed instances where toEnum and fromEnum were broken.
08:43:16 <Toxaris> from my understanding, fromInt and toInt is implementation dependant nonsense, and succ, pred and enumFrom*** is the RealThing with the Enum typeclass
08:43:26 <oerjan> quicksilver: i meant it can then be converted to something suitably large, losslessly
08:43:34 <SamB> quicksilver: well, apparantly it's not supposed to corrupt your heap
08:43:43 <quicksilver> ;)
08:43:59 <quicksilver> Toxaris: that's a far way to look at it.
08:44:00 <SamB> that's about all that says
08:44:15 <quicksilver> Toxaris: of course, if you actually want the conversion a -> Integer...
08:44:25 <quicksilver> Toxaris: then going via succ and pred is going to be slow :)
08:44:35 <quicksilver> s/far/fair/
08:45:17 <SamB> yeah, you'd have more luck defining your own Enum' class and writing the code to derive it for derive or derive ... (er, one of which was renamed DrIFT)
08:45:21 <oerjan> quicksilver: impossible too, you cannot detect when you have reached the end
08:45:24 <byorgey> Cale: do you know what's up with lambdabot?
08:45:33 <Toxaris> quicksilver: succ and pred are only usable for Integer -> a as I understand it
08:45:37 <oerjan> @bot
08:45:48 <Cale> Is it down?
08:45:53 <Toxaris> obviously, Integer would have been a better choice for toEnum and fromEnum
08:45:54 <Deewiant> it's not here
08:45:56 <byorgey> Cale: yes
08:46:03 <quicksilver> Toxaris: except for efficiency, I suppose.
08:46:03 <Cale> okay, I'll restart it
08:46:10 <SamB> Toxaris: clearly!
08:46:11 <byorgey> so maybe I should have asked 'what's down with lambdabot'
08:46:20 <SamB> quicksilver: that would not suffer a great deal, with a decent compiler
08:46:30 <Cale> code.h.o is really really slow
08:46:40 <SamB> a decent compiler being one that could resolve the overloading before runtime
08:46:40 <byorgey> yeah, it was not responding earlier
08:46:48 <Cale> Apparently lambdabot got a SIGHUP.
08:47:03 <byorgey> Cale: maybe it's having the same problems that d.h.o was having yesterday?  DoS stuff?
08:47:12 <oerjan> Cale: someone mentioned a DOS attack on the wiki server yesterday?
08:47:20 <Cale> ah
08:47:30 <SamB> isn't that the same server as darcs.h.o?
08:47:42 <byorgey> maybe, I don't know
08:47:50 <SamB> or am I getting mixed up with hackage.h.o?
08:48:10 <byorgey> {community,hackage,darcs,code}.haskell.org, I get them all confused
08:48:29 <oerjan> aren't there just two physical servers?
08:48:50 <SamB> darcs.haskell.org       CNAME   haskell.galois.com
08:48:50 <SamB> code.haskell.org        CNAME   community.haskell.org
08:48:50 <SamB> hackage.haskell.org     CNAME   haskell.galois.com
08:48:50 <SamB> www.haskell.org         CNAME   bugs.haskell.org
08:48:55 <SamB> that... is a bit odd...
08:49:45 <Toxaris> Enum seems to be broken in more ways... it is nowhere stated that (Enum a, Ord a) => forall x . succ x > x
08:50:02 <quicksilver> right.
08:50:02 <SamB> Toxaris: well, with it being broken the way it is...
08:50:10 <quicksilver> there are a very large number of laws which are not stated.
08:50:30 <oerjan> > succ (1/0) > 1/0 -- oh wait, down
08:50:31 <SamB> also, there is no "pred" or "succ" for MonadZero
08:50:46 <lambdabot>  thread killed
08:51:01 <oerjan> > succ (1/0) > 1/0 -- once more
08:51:01 <lambdabot>  False
08:51:01 <SamB> that is, no mpred/msucc that work in MonadZero
08:51:03 <quicksilver> also note that succ and pred don't enumerate every element
08:51:16 <SamB> (never mind that MonadZero does not in fact EXIST right now)
08:51:27 <SamB> quicksilver: eh?
08:51:38 <pa-ching> How can I make it possible to derive from a typeclass?
08:51:40 <Toxaris> > [1.0..3.0]
08:51:41 <lambdabot>  [1.0,2.0,3.0]
08:51:45 <Toxaris> :(
08:51:50 <pa-ching> Er to use the "deriving" keyword, that is.
08:51:55 <oerjan> pa-ching: no way
08:51:56 <SamB> we should make a new Enum' class, I guess...
08:51:58 <SamB> to fix it up
08:51:59 <quicksilver> SamB: consider "succ 1.5"
08:52:00 <pa-ching> oerjan: :(
08:52:06 <SamB> quicksilver: ah, true
08:52:18 <quicksilver> well enum is overloaded
08:52:21 <pa-ching> Needs more reflection!
08:52:21 <quicksilver> it's doing (at least) two things
08:52:27 <SamB> yes, it's doing two things
08:52:29 <quicksilver> one is the magic .. notation.
08:52:42 <quicksilver> the other is the sensible notion of enumerable types.
08:52:53 <quicksilver> (like Bool and Int)
08:53:06 * Toxaris votes for even more Enum classes
08:53:07 <SamB> I guess the only workable way to do this is to have the .. notation class be a superclass of the other?
08:53:28 <roconnor> The whole enum thing for floats is broken and wrong.
08:53:28 <Toxaris> (1) magic ... notation, (2) succ and pred, (3) toInt and fromInt
08:53:44 <roconnor> at some point we discussed breaking Enum into two classes.
08:53:55 <SamB> Toxaris: why do we need (3)
08:54:14 <SamB> we could have (2) succ, pred, fromEnum, and toEnum
08:54:26 <SamB> fromEnum and toEnum have the proper types
08:54:45 <SamB> "but "++
08:56:19 <hpaste>  Cheery annotated "HellMonad" with "Serializable" at http://hpaste.org/6186#a1
08:56:23 <Toxaris> (2) supports enumFrom automatically
08:56:31 <Toxaris> (2) + Eq supports enumFromTo
08:56:35 <Toxaris> complicated stuff
08:56:48 <SamB> type class synonyms!
08:56:52 <SamB> we need those.
08:57:17 <Toxaris> every discussion about sensible Prelude design ends at the type class synyonym wall
08:57:27 <Toxaris> or gap, maybe
08:57:41 <roconnor> Cheery: that looks pretty good.
08:57:47 <SamB> should we implement them?
08:58:02 <oerjan> chasm
08:58:15 <roconnor> Cheery: you may want to use concatMap
08:58:27 <SamB> http://repetae.net/recent/out/classalias.html
08:58:30 <lambdabot> Title: Class Alias Proposal for Haskell
08:58:36 <hallongrottan> @type concatMap
08:58:40 <hallongrottan> hmm
08:58:42 <roconnor> at least if there is a concatMap for bytestrings.
08:58:47 <hallongrottan> > :t concatMap
08:58:51 <lambdabot> thread killed
08:58:53 <lambdabot>   parse error on input `:'
08:58:54 <hallongrottan> gah
08:58:58 <Toxaris> hehe, "Towards a sensible Prelude Design -- Bridging the Type Class Synonym Chasm"
08:59:21 <SamB> is that an actual paper?
08:59:23 <oerjan> :t concatMap
08:59:29 <Toxaris> SamB: it's a paper thunk
08:59:33 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
08:59:42 <Toxaris> someone should write it
08:59:44 <oerjan> :t Data.ByteString.concatMap
08:59:44 <SamB> yeah.
08:59:56 <SamB> I was in the midst of googling when I asked ....
08:59:58 <roconnor> I assume ByteStrings are a Monoid.
08:59:59 <lambdabot> thread killed
09:00:01 <quicksilver> If I start reading it, will it get lazily written?
09:00:02 <oerjan> :t Data.ByteString.concatMap
09:00:03 <pjd> concatMap = (=<<)
09:00:09 <lambdabot> (Word8 -> BSC.ByteString) -> BSC.ByteString -> BSC.ByteString
09:00:21 <quicksilver> BS.concatMap is a slightly obscure function
09:00:22 <quicksilver> IMO :)
09:00:34 <quicksilver> I think (a -> BS) -> [a] -> BS
09:00:40 <quicksilver> would be more useful.
09:00:56 <roconnor> ah I see why Cherry is using concat . map f
09:00:56 <quicksilver> but it's not that hard to write concat $ map ...
09:01:00 <Cheery> Data.ByteString.concatMap :: (Word8 -> ByteString) -> ByteString -> ByteString
09:01:02 <roconnor> because the map is from lists
09:01:10 <quicksilver> right.
09:01:11 <roconnor> and the concat is from bytestring.
09:01:18 <quicksilver> exactly my point :)
09:01:26 <oerjan> quicksilver: that's probably given by Data.Foldable.foldMap
09:01:30 <roconnor> quicksilver: I think you are right.
09:01:57 <quicksilver> oerjan: an excellent point.
09:02:05 <oerjan> except that may not be optimized
09:02:08 <quicksilver> I'd forgotten BS had a Monoid instance.
09:02:30 <quicksilver> I sometimes worry that that might be a problem with Foldable and Traversable.
09:02:31 <SamB> does foldMap use mconcat?
09:02:39 <quicksilver> that they impede the fusion stuff.
09:02:49 <quicksilver> SamB: it's a method. It's up to you :)
09:02:51 <Cheery> roconnor: it is maybe a bit confusing to cherry-pick the right functions which have similarity associsation between them
09:02:56 <quicksilver> the instantiator, I mean.
09:03:04 <oerjan> hm mconcat is a method too, so may be optimized
09:03:23 <SamB> oerjan: exactly MY point
09:03:25 <quicksilver> oerjan: but we're talking about the Foldable instance for [], not the Monoid instance for BS, there.
09:03:41 <oerjan> yeah
09:03:50 <Cheery> except, I wonder why there's no Sequence -class with things like length, concat, etc.
09:03:54 <roconnor> Cheery: is it okay that your serialization isn't self-delimiting?
09:04:00 <SamB> Cheery: there probably is
09:04:02 <SamB> on hackage
09:04:07 <quicksilver> Cheery: Foldable is close, actually.
09:04:17 <SamB> I think I saw it there...
09:04:21 <quicksilver> Cheery: it doesn't contain length although you can write it inefficiently.
09:04:26 <quicksilver> there is also ListLIke
09:04:33 <SamB> yeah, that's what I mean
09:04:35 <quicksilver> which approaches from a somewhat different perspective.
09:04:41 <Toxaris> length is bad anyway
09:04:47 <quicksilver> ListLike is very practical and pragmatic, and has a huge array of methods.
09:04:52 <Cheery> roconnor: what do you mean?
09:04:55 <quicksilver> Foldable is more abstract and elegant.
09:05:01 <quicksilver> and only has four methods, IIRC>
09:05:41 <Cheery> roconnor: next I'm going to try it
09:05:49 <SamB> what I love are when things are both practical and elegent
09:05:58 <SamB> like Monoid
09:06:11 <Cheery> Monoid...
09:06:17 <Toxaris> where to read about type class synonyms? (proposals, problems, whatever)
09:06:20 <roconnor> Cheery: you cannot tell where a list begins and ends by looking at the bytestring
09:06:26 <SamB> (sure, perhaps having mconcat as a method is not the best...)
09:06:31 <SamB> Toxaris: that link I pasted...
09:06:32 <roconnor> Cheery: [x] and x are encoded in the same way.
09:06:38 <SamB> is one place
09:06:50 <Cheery> roconnor: true, that's for purpose
09:06:54 <Toxaris> SamB: oups, missed it
09:07:08 <SamB> Toxaris: that's okay ;-)
09:07:16 <Cheery> it's because X11 -protocol specifies the lengths elsewhere, and I've made this for that thing
09:08:09 <Cheery> this is probably a beginning for a protocol of my own as well, which I'm planning to allow self-delimiting
09:10:41 <hallongrottan> @type matchRegexAll
09:10:41 <Cheery> going to shop for a while, you'll be seeing the application of that thing later this evening, should've made a bit easier to serialise that protocol
09:10:56 <lambdabot> thread killed
09:13:13 <byorgey> roconnor++ quicksilver++  -- \bot was dead before
09:13:18 * oerjan wonders if lambdabot could be made to base time limits on time used by the process instead of real time passed
09:14:09 <oerjan> assuming these thread kills happen because of large load
09:14:32 <pjd> oerjan: that would result in more load, though
09:14:41 <mrd> ulimit?
09:14:43 <oerjan> there could be a combined limit
09:15:00 <tibbe> I have a type error involving some continuation code, anyone willing to help?
09:15:12 <roconnor> @karma roconnor
09:15:12 <lambdabot> You have a karma of 3
09:15:17 <oerjan> pjd: not necessarily.  i mean, if we really want the result we just retry immediately, right?
09:15:55 * byorgey is surprised roconnor does not have a larger karma
09:16:10 <georgw> @karma georgw
09:16:10 <lambdabot> You have a karma of 0
09:16:12 <DukeDave> Woo lambdabot is back :)
09:16:27 <hpaste>  tibbe pasted "Type error involving CPS" at http://hpaste.org/6189
09:16:35 <georgw> @karma lambdabot
09:16:35 <lambdabot> lambdabot has a karma of 1
09:16:36 <tromp> @karma shapr
09:16:36 <lambdabot> shapr has a karma of 40
09:16:47 <georgw> @karma ChanServ
09:16:47 <lambdabot> ChanServ has a karma of 0
09:16:51 * byorgey bemoans the dying knowledge and use of karma points, with an oblique and unhelpful reference to "back in the day"
09:16:57 <astrolabe> @karma dons
09:16:57 <lambdabot> dons has a karma of 140
09:17:32 <tromp> @karma tromp
09:17:32 <lambdabot> You have a karma of 0
09:17:41 <astrolabe> How much karma do you need to become a budda?
09:17:59 <oerjan> tibbe: your succ . f implies your Functor instance does not accept any function type for f, which it must
09:18:00 <byorgey> astrolabe: if you need to ask, you don't have enough.
09:18:00 <daf> that sounds like the start of a koan
09:18:11 <letrec> @karma letrec
09:18:12 <lambdabot> You have a karma of 0
09:18:32 <oerjan> or wait
09:18:55 <oerjan> that's not the usual succ i see. but i think that may still be the problem.
09:19:24 <tibbe> oerjan: I might have gotten it all wrong, just started thinking about how I can replace my one continuation with a succ and fail one
09:19:58 <byorgey> oh, succ as in "success" rather than "successor" ?
09:20:50 <mrd> rather than "succubus"
09:21:03 <byorgey> ah, I see
09:21:34 <DukeDave> So gang, what's a nice way to monitor how much of a lazy readFile has been read, without flooding my code with IO ?
09:22:00 <tibbe> byorgey: right, sorry about that
09:22:09 <mrd> zip [0..] `liftM` readFile
09:22:10 <oerjan> tibbe: oh, hm.  i think maybe you need to distinguish the types for succ and fail
09:22:24 <tibbe> oerjan: I'm not sure what you mean?
09:22:31 <quicksilver> DukeDave: unfold your processing code into a callback, probably.
09:22:41 <quicksilver> which gets called for every 'chunk' of data.
09:22:48 <DukeDave> mrd: Was that at me?
09:22:53 <byorgey> oerjan, tibbe: ah, yes, that's it
09:22:55 <mrd> vaguely
09:23:09 <quicksilver> mrd's approach is quite interesting too, actually.
09:23:10 <DukeDave> quicksilver: Okay, I have a vague idea what you mean :|
09:23:21 <oerjan> tibbe: the fail is of the type ParserCont r a, so cannot be used for the modified Parser
09:23:30 * DukeDave doesn't understand mrd
09:23:45 * DukeDave ...'s approach
09:23:54 <mrd> that pairs every character with an integer index
09:24:03 <oerjan> because you change the succ type, and the Parser type is defined to have them be the same
09:24:06 <mrd> so you know how much has been read...
09:24:25 <tibbe> oerjan: right, I wonder if it's correct to apply f to fail too... hmmm
09:25:43 <DukeDave> mrd: Now that is smart :)
09:26:09 <oerjan> tibbe: you have to pass some fail.  note how this is analogous to Either/ErrorT which has failure and success with different types, and the monad/functor is only in the success
09:28:51 <DukeDave> mrd: quicksilver: Using the zip/liftM approach could I use arrows elegantly ?
09:29:08 <tibbe> oerjan: to backtrack a bit, I'm trying to write <|> and my parsec like approach failed and I'm trying the LogicT solution
09:29:51 <oerjan> tibbe: well still you need to separate success and failure types i think.  something like:
09:30:48 <SamB> Igloo: didn't I send you a happy patch ages ago?
09:30:53 <mrd> DukeDave: er? it's just a list
09:30:56 <oerjan> newtype Parser r f s = Parser { unParser :: S -> ParserCont r s -> ParserCont r f -> Result r }
09:31:13 <mrd> DukeDave: IO [(Integer, Char)]
09:32:25 <tibbe> oerjan: hmm
09:32:29 <profmakx> is there a haskell shell?
09:32:31 <oerjan> it would be possible to write a combinator to switch success and failure if you needed to do monad/functor things in the other
09:33:10 <tibbe> oerjan: so basically the idea is that the intermediate values on the patch to the "end" of the parsing might be different?
09:33:14 <georgw> So, I have handed in my first assignment using Haskell. Really curious if the assistant will be able to make any sense of the code. Thank you very much for your help, guys, it is very much appreciated. Have a good weekend.
09:33:21 <tibbe> oerjan: I'm trying to find an intuition for this
09:33:48 <DukeDave> mrd: I see that, I'm trying to find a way to 'monitor' the Integer without affecting the purity of the code which handles the Chars
09:33:58 <DukeDave> mrd: I'll get back to you ;)
09:34:17 <dmwit> profmakx: There's been several half-hearted attempts, I believe.
09:34:33 <oerjan> tibbe: basically that success and failure may follow different paths, which may have different typed functions applied before they merge again (if ever)
09:34:53 <tibbe> oerjan: ok, that was my intuition
09:35:07 <profmakx> because i started writing everything i would have scripted in zsh in haskell
09:35:18 <SamB> Igloo: happy still doesn't give proper error messages!
09:35:26 <quicksilver> profmakx: there is HSH which is a package for doing shell-like tasks in haskell.
09:35:35 <quicksilver> profmakx: it isn't actually a shell, though.
09:35:46 <quicksilver> profmakx: but it sort-of allows you to use gchi for shell tasks.
09:35:49 <quicksilver> it's quite clever.
09:36:10 <pcc1> why would I get a warning about this (ghc 6.6): "Warning: Pattern match(es) are overlapped\n In a case alternative:\n aconstant -> ...\n _ -> ..."
09:36:15 <tibbe> oerjan: put the type of 'parse' should still be Parser r r r -> ... ?
09:36:28 <profmakx> nice, thanks quicksilver i will try that
09:36:32 <oerjan> pcc1: it may have deduced that a case can never be reached
09:37:18 <tibbe> oerjan: I think Oleg used a forall somewhere in his continuations, dunno why though
09:38:14 <oerjan> tibbe: i think it may sometimes make things simple to really force the parsers to know nothing about what the final return value will be, i think that's what forall does
09:38:33 <oerjan> s/simple/more elegant/
09:38:33 <byorgey> pcc1: note that if you have a pattern like   foo -> blah, the 'foo' will match anything, and will shadow any existing definitions of foo.  it will NOT match the value of any existing variable called foo.  does that help? =)
09:38:40 <tibbe> oerjan: in what case?
09:39:07 <oerjan> tibbe: i assume oleg's for all is on the return value
09:39:10 <byorgey> pcc1: so in that case, 'aconstant' will match anything, and the _ case will never be reached
09:39:15 <oerjan> (i think i've seen that)
09:39:22 <pcc1> byorgey: yes, thanks
09:39:41 <oerjan> Cont a = Cont forall r. (a -> r) -> r
09:39:55 <oerjan> (may not be the right syntax)
09:40:01 <tibbe> what does he win by that?
09:40:22 <oerjan> probably something types easier somewhere...
09:42:15 <tibbe> oerjan: maybe all the r, s, and f's I have now?
09:42:28 <pcc1> ok what's the best way to do a C-style case expression then?
09:42:48 <oerjan> tibbe: oh i don't think you need those forall's - but burn that bridge when you come to it
09:43:22 <tibbe> oerjan: ok, I think the continuations should have different types, succ :: a -> S -> Result r and fail :: S -> Result f
09:43:37 <tibbe> oerjan: because where would fail get it 'a'? a only exists if a parse succeded
09:44:29 <byorgey> pcc1: use guards.  something like  foo a | a == 2  =  blah \n     | a == (y+z)  = bar \n    | a > aconstant  = .... and so on.
09:44:36 <oerjan> tibbe: oh right, you might not need a failure value.  although it _could_ be useful for error messages
09:45:00 <tibbe> oerjan: right
09:45:16 <tibbe> oerjan: I won't need it though, I do the simpler thing without for now
09:45:26 <byorgey> pcc1: pattern-matching can only be used to match patterns, which includes constant values, but not expressions.  if you want to check whether something satisfies some general predicate (is equal to some computed value, or something more complicated), you can use guards
09:47:39 <oerjan> tibbe: i assume complete symmetry between success and failure has its uses for other things... well, it's pretty, so it must have :)
09:48:13 <tibbe> oerjan: heh, I'll readd it later when I understand it. I will hopefully get too understanding it by skiping it as a first step
09:48:21 <SamB> @ask Igloo why there isn't a Debian package of happy 1.17
09:48:21 <lambdabot> Consider it noted.
09:48:28 <oerjan> @where Expr
09:48:29 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
09:48:59 <oerjan> wow, lambdabot remembered *wipes a tear*
09:50:15 <tibbe> oerjan: now I need something like cut for <|> so it doesn't hold on to too much state
09:50:22 <tibbe> oerjan: it should be LL(1)
09:52:01 <hpaste>  DukeDave pasted "Sequencing IO ()" at http://hpaste.org/6190
09:52:32 <DukeDave> Okay so I'm at this point now, can anyone suggest how I might implement the 'want' ?
09:54:39 <glguy> DukeDave: mapM_ (\(x,y) -> g x >> h y) f
09:54:50 <DukeDave> glguy: Yes!
09:55:05 <byorgey> DukeDave: are you sure that's [a] -> IO () instead of a -> IO () ?
09:55:12 <DukeDave> After much scribbling I just got that down at the bottom of my paper
09:55:25 <DukeDave> byorgey: Yeah
09:55:56 <glguy> if those are the types, you can't very well interleave them :-/
09:56:02 <byorgey> @type \f g -> mapM_ (\(x,y) -> g x >> h y)
09:56:17 <lambdabot> thread killed
09:56:19 <byorgey> @type \f g -> mapM_ (\(x,y) -> g x >> h y)
09:56:27 <byorgey> argh
09:56:31 <glguy> :t mapM_ (\(x,y) -> ?g x >> ?h y) ?
09:56:34 <lambdabot> thread killed
09:56:37 <glguy> :-/
09:56:46 <lambdabot> thread killed
09:56:54 <glguy> ?activity
09:56:55 <lambdabot> 3*total 3*#haskell
09:56:55 <DukeDave> byorgey: I already have working code for [a] -> IO ()   and now I'm zipping the [a] with [0..]
09:57:09 <dejones> hello, I did "make install" in the cabal repository from a darcs get... no errors occurred and it said it installed / registered; but, I don't have a cabal executable available?  I'm using Debian Linux.
09:57:11 <dejones> Any ideas?
09:57:31 <glguy> rehash?
09:57:34 <byorgey> DukeDave: well, that's not going to work.  glguy's code works for  f :: a -> IO () and g :: b -> IO ().
09:57:34 <DukeDave> byorgey: The plan being to have the [Integer] -> IO () function just print update to the terminal
09:57:55 <quicksilver> dejones: Ironically I believe the cabal executable is part of the cabal-install package?
09:58:00 <byorgey> DukeDave: if you have a function  f :: [a] -> IO ()  you cannot 'separate out' the effects of f on the separate elements.
09:58:06 <quicksilver> dejones: the cabal package is just the infrastructure.
09:58:10 <quicksilver> dejones: IIUC>
09:58:11 <glguy> DukeDave: my code did what your example showed, but not what your types showed
09:58:24 <dejones> quicksilver: lol, yea, I think I just noticed that...  but, how do I install cabal-install?  The README doesn't say.
09:58:39 <quicksilver> I think it's a separate download.
09:58:43 <quicksilver> or darcs checkout.
09:59:04 <DukeDave> glguy: byorgey: Ah yes I see now
09:59:10 <quicksilver> dejones: http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
09:59:12 <lambdabot> Title: CabalInstall - Hackage - Trac
09:59:14 <byorgey> DukeDave: but if you can find a function f' :: a -> IO ()  for which  f = sequence_ . map f', then you're golden =)
09:59:15 <dejones> quicksilver: yea, I downloaded cabal-install with darcs get too.
09:59:34 <dejones> quicksilver: I'm looking at that wiki page too.  It doesn't actually say how to install cabal-install.
09:59:42 <dejones> quicksilver: it just says how to use it...
09:59:43 <quicksilver> it's a cabal package :)
09:59:49 <quicksilver> runghc Setup.hs configure
09:59:52 <quicksilver> runghc Setup.hs make
09:59:55 <dejones> quicksilver: I see.
09:59:56 <quicksilver> runghc Setup.hs build
09:59:59 <quicksilver> (make was a lie!)
10:00:04 <dejones> quicksilver: haha
10:00:06 <quicksilver> sudo runghc Setup.hs install
10:00:18 <quicksilver> or configure --user if that's what you want. etc.
10:00:47 <dejones> quicksilver: thanks.  :)
10:01:13 <glguy> The cake is a lie!
10:01:36 <quicksilver> First we will bake you, then we will have cake.
10:01:37 <mrd> there was a party, and I invited all your friends
10:01:54 <dejones> lol
10:02:41 <DukeDave> byorgey: Hehe, actually have f' already but it was in another module and I was trying to avoid refactoring that as well, but no problem :)
10:03:09 <byorgey> DukeDave: oh, hehe =)
10:04:15 <byorgey> DukeDave: my usual mode of Haskell development is  1. write code.  2. get it to compile.  3. it usually works at this point.  4. refactor mercilessly until the code is 1/4 as long as it used to be, five times as general, and easier to understand.
10:05:01 <glguy> byorgey: are you a "tweaker"?
10:05:15 <mrd> then feed it to @pl and turn it into a one liner
10:05:25 <byorgey> glguy: I... suppose so.  depends what you mean by that. =)
10:05:42 <byorgey> mrd: @pl isn't necessary, #haskell works just as well =)
10:05:44 * oerjan has the problem of doing step 4 first, which may be why he rarely finishes anything
10:05:49 <byorgey> haha
10:05:54 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6191
10:06:08 <glguy> byorgey: can't leave code well enough alone, have to keep improving it endlessly (I'm kind of like this)
10:06:34 <byorgey> glguy: oh, then definitely.
10:06:38 <mrd> if it ain't broke, fix it
10:06:53 <byorgey> glguy: I'm always in search of the One True Set of Combinators for whatever I happen to be working on...
10:07:55 * SamB thinks happy ought to tell you when you put huge ammounts of code in the braces after a parse alternative...
10:09:14 <DukeDave> I've been lucky enough to get a job where despite no one else using Haskell they are happy for me to.. So am on very high 'tweak alert'. Must. Keep. Productivity. Up  :)
10:11:38 <lament> DukeDave: lucky
10:11:53 <SamB> Wierd.
10:11:59 <mrd> weird
10:12:04 <SamB> anyone express any interest in learning?
10:12:15 <SamB> mrd: are you agreeing or correcting my spelling?
10:12:23 <mrd> both
10:13:26 <DukeDave> Yeah very much so
10:13:48 <DukeDave> Most popular question: "So what would you use Haskell for"
10:14:08 <DukeDave> I.e. What 'types' of problem
10:14:11 <SamB> and your answer?
10:14:12 <lament> parsers
10:14:14 <byorgey> "um... everything?"
10:14:23 <DukeDave> byorgey: Exactly
10:14:44 <lament> haskell is pretty clearly not the best solution for *everything*...
10:15:15 <byorgey> yes, but as a first approximation, "everything" is a lot closer to the truth than what people might think.
10:15:28 <DukeDave> lament: We deal with a *lot* of data processing here so speed is the main concern
10:15:29 <Cale> lament: But characterising the exact set of problems where it would win out over other things is probably as hard as simply teaching the person Haskell to begin with.
10:16:13 <SamB> well, you might want to give an example of an area where it shines particularly
10:16:32 <Cale> Constraint optimisation problems are particularly fun in Haskell.
10:16:45 <roconnor> > exp(0.05*(1/365))
10:16:50 <Cale> Anything involving a parser.
10:17:00 <lambdabot>  thread killed
10:17:15 <Cale> Anything involving tricky algorithms tends to be more fun.
10:17:38 <Cale> (but more towards discrete algorithms than numerical ones)
10:18:01 <lament> haskell is optimized for tricky algorithms being fun :)
10:18:02 <DukeDave> Cale: Yeah I'm trying to push a "look how easily I can break down this complex data transformation algorithm"
10:18:18 <byorgey> anything that can benefit from large doses of abstraction...
10:18:31 <lament> sadly, so much programming doesn't need any tricky algorithms
10:20:09 <Cale> Well, a lot of programming could likely benefit somewhat from fancier algorithms than would otherwise be acceptable.
10:20:56 <roconnor> I'm reminded of the proof of the four colour theorem.
10:21:11 <roconnor> Appel and Hacken wrote a complex program to solve part of it.
10:21:25 <matthew_-> roconnor: didn't the proof take centuries before anyone worked it out?
10:21:29 <roconnor> and then they wrote another simpler program to verify the other program.
10:21:43 <roconnor> rather to verify the output of the other program
10:22:00 <roconnor> Gontheir implemented the same algorithm in Coq.
10:22:11 <roconnor> But he didn't need to write the verifier program.
10:22:24 <roconnor> instead he just proved that the first program was correct.
10:24:03 <SamB> how did the second program verify the output?
10:25:02 <roconnor> presumably the first program output a witness that could be used to easily verify whatever problem was being solved.
10:25:19 <Cale> There's a 4-colour theorem proof in Coq now.
10:25:34 <SamB> isn't that what was just stated?
10:25:42 <SamB> more or less
10:25:47 <Cale> Uh, I've only partly been following the conversation.
10:25:51 <Cale> ah, yeah
10:26:04 <Cale> Still, it would be nice to have an *elegant* proof of it.
10:26:27 <tromp> a 4 lines proof?
10:26:28 <SamB> yeah, it would
10:26:39 <Cale> That is, one which didn't involve checking more than 3 or 4 cases at most, say :)
10:26:50 <SamB> maybe 8
10:26:51 <BMeph> Someone, obviously, needs to find the proper isomorphism with a more elegant category. ;)
10:27:03 <SamB> 8 isn't too many for a person to grasp
10:27:09 <Cale> Maybe 8, sure. Something humanly manageable.
10:27:27 <Cale> ~600 is too many
10:27:28 <roconnor> I think 4 cases is really pushing it.
10:27:46 <Cale> Best would be just one case :)
10:28:25 <roconnor> Maybe I can live with 5 cases: two parameters with two interesting cases and then one exectional case.
10:29:04 <BMeph> Speaking of tricky algorithms, is there a book that helps one to figure out how to transform, say, imperative-based algorithms to a more straightforward...er, I mean, a more functional basis? :)
10:30:00 <roconnor> I think transforming algorithms is a bad way to proceed.
10:30:08 <roconnor> instead look for functional ways to solve the same problem.
10:30:22 <SamB> well, sometimes an algorithm is salvagable
10:30:26 <SamB> sometimes it isn't
10:30:53 <SamB> sometimes, you can use ST to use the imperative algorithm directly
10:31:27 <SamB> but yes, you really should look at functional ways ;-)
10:32:30 <byorgey> BMeph: in general, you want to transform control structures from the imperative algorithm into data structures in the functional version.
10:32:48 <byorgey> that doesn't always work out, but it's a good rule of thumb.
10:32:55 <byorgey> e.g. for loop --> list
10:34:07 <BMeph> Interesting. I wonder if there's some evil genius trying to work that concept in reverse... ;p
10:34:17 <SamB> BMeph: we call that the compiler
10:34:53 <dons> ?yow
10:34:54 <lambdabot> ... I don't like FRANK SINATRA or his CHILDREN.
10:35:05 <shapr> @quote dons
10:35:05 <lambdabot> dons says: too many papers, not enough code
10:35:10 * shapr cheers
10:35:24 <dejones> hey dons, in the binary package, where is the "poke" function defined?
10:35:25 <BMeph> shapr: Nicely played. :)
10:35:35 <dejones> dons: I'm just not seeing it...
10:35:40 <SamB> @hoogle poke
10:35:44 <lambdabot> Foreign.Storable.poke :: Storable a => Ptr a -> a -> IO ()
10:35:44 <lambdabot> Foreign.Storable.pokeElemOff :: Storable a => Ptr a -> Int -> a -> IO ()
10:35:44 <lambdabot> Foreign.Storable.pokeByteOff :: Storable a => Ptr b -> Int -> a -> IO ()
10:35:55 <dejones> SamB: thank you.
10:36:01 <shapr> Any Haskellers near Las Vegas?
10:36:21 <dejones> SamB: wow, hoogle is cool.  :)
10:36:21 <Cale> Counting cards in Haskell!
10:36:21 <shapr> I'm visiting Las Vegas for three days, thought I might try to meet some cool people.
10:36:33 <shapr> Hm, I think JohnMeacham is there.
10:36:44 <oerjan> impossible!  gambling is not referentially transparent.
10:36:47 <shapr> Cale: haha!
10:37:31 <shapr> Hm, repetae says Pasadena.
10:37:37 <SamB> dejones: only because "poke" is uniquely used for that one concept, which is only used in one library, did it work out so well
10:37:42 <shapr> @seen vulpyne
10:37:43 <lambdabot> Last time I saw vulpyne was when I left ##logic, #darcs, #gentoo-haskell, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell-soc, #jtiger, #parrot, #perl6, #rosettacode, #scala, #scannedinavia
10:37:43 <lambdabot> n, #unicycling and #xmonad 21d 14h 48m 14s ago, and .
10:37:46 <dons> we use Probability monads
10:37:48 <shapr> foo
10:38:09 <SamB> dejones: if you didn't know, the terms PEEK and POKE are from BASIC
10:38:28 <dejones> SamB: ahh, nope didn't realize they were from BASIC.  :)  Thanks for the tip.
10:38:30 <mrd> hmm, does it predate BASIC?
10:38:50 <SamB> mrd: who knows? but I bet that's where it was directly taken from...
10:39:08 <shapr> http://en.wikipedia.org/wiki/PEEK_and_POKE
10:39:10 <lambdabot> Title: PEEK and POKE - Wikipedia, the free encyclopedia
10:39:56 <BMeph> shapr: I'm in San Diego, which is a day's drive from LV. :)
10:41:06 <shapr> Could be fun!
10:41:29 <dejones> shapr: I'm in Kentucky, but you could buy me a plane ticket; I'd love to go to Vegas.  It's snowing here!
10:41:42 <dejones> ;)
10:41:55 <shapr> heh
10:42:07 <SamB> dejones: are you familiar with the principles of microcomputer architecture?
10:42:16 <dejones> SamB: Yeah.
10:42:21 <shapr> BMeph: I'll be in Vegas from the 27th to the 30th of March
10:42:56 <SamB> well, I suppose any *kind* of computer architecture...
10:43:02 <hpaste>  wurzelburzel pasted "xmonad.hs" at http://hpaste.org/6192
10:43:19 <BMeph> shapr: Cool - I'll drive up on the weekend. :)
10:43:19 <BMeph> Well, wife willing... ;)
10:43:19 <shapr> heh
10:43:22 <dejones> SamB: Yeah, I'm more familiar with Systems programming in C, than I am with Haskell programming.  ;)
10:43:40 <shapr> It's a business oriented weekend, let me make sure I have a serious chunk to hang out...
10:44:07 <SamB> dejones: hopefully that has not hindered you too much in learning Haskell ;-)
10:44:25 <SamB> it is clearly useful when it comes to Foreign
10:44:52 <shapr> Looks like Thursday is open.
10:44:53 <dejones> SamB: lol, I mostly struggle with the Haskell syntax.  The \y's and $ and . are all -foreign- to me.
10:45:18 <dejones> Conceptually, I like Haskell a lot though.  So, I am wading through... I plan to do my Master's thesis this summer with Haskell.
10:45:35 <hpaste>  wurzelburzel pasted "xmonad.hs" at http://hpaste.org/6193
10:45:40 <SamB> you don't know lambda calculus at all, then?
10:45:42 <shapr> dejones: Cool!
10:46:22 <SamB> you know... when I heard Haskell was purely functional, I interpreted that as something a bit more like Lazy K than like Haskell...
10:46:37 <dejones> SamB: Well, I'm having to learn lambda calculus now.
10:46:49 <shapr> BMeph: Yeah, looks like thursday afternoon... though that's not very employment friendly.
10:47:05 <dejones> shapr: hehe, I hope it will be cool.  I've picked a topic that I fear may be too difficult since I'm still learning Haskell.  ;)  But, I like a challenge!
10:47:08 <Cheery> dejones: do you know a lot about  low-level -stuff?
10:47:29 <dejones> Cheery: Yeah, that's most of my experience.  Some kernel programming, networking programming, etc.
10:47:54 <Cheery> cool
10:47:55 <dejones> I'm most comfortable in C with the bits.  :)
10:48:14 <SamB> dejones: maybe you should try compiler hacking ;-)
10:48:36 <Cheery> yeh, that'd be valuable
10:48:42 <BMeph> shapr: Hm, yeah. Work isn't the problem, though - I have choir practice on Thursday nights. :|
10:48:46 <dejones> SamB: Well, my master's thesis this summer is attempting to implement the Haskell RTS directly on the hardware, "Bare Metal Haskell."  It's similar to the House OS project...
10:48:50 <shapr> ah
10:49:10 <SamB> dejones: how exactly will that help?
10:49:12 <dejones> SamB, shapr: I'm mostly scared that I don't know enough Haskell to accomplish it...
10:49:22 <Cheery> dejones: so you are an another guy who is going to push haskell on low level as well?
10:49:30 <dejones> Cheery: Trying.  ;)
10:49:53 <shapr> dejones: Keep on learning!
10:50:10 <SamB> GHCi won't run without a bunch of library calls...
10:50:13 <Cheery> I like it, I hope that one day, C wouldn't be a kernel programming language anymore
10:50:15 <dejones> shapr: heh, working on it.  :)
10:50:23 <dejones> http://www.systems.ethz.ch/education/theses/haskell.php -- I got the project idea from here.
10:50:25 <lambdabot> Title: ETH Zurich Computer Systems Group
10:50:33 <SamB> Cheery: well, that seems unlikely
10:50:37 <dejones> So that's what I am attempting to do for my Master's thesis.
10:50:45 <byorgey> dejones: where are you doing your master's?
10:50:54 <SamB> but I suppose it is possible that some other language of that level will displace it if C falls out of favor in general...
10:50:59 <dejones> byorgey: Univ of Kentucky, my advisor is Dr. Raphael Finkel.
10:51:01 <BMeph> Cheery: Think it'd be interesting to think up a low-level language that'd be more suitable for system programming, but with facilities that'd be convenient for Haskell to compile into, sort of like a better C--? :)
10:51:28 <SamB> BMeph: try to avoid too many air-castles ;-)
10:51:43 <dejones> BMeph: C-- is more like assembly though... not really something I think you would want to program in on a regular basis, but it would be interesting to do some parts of a low-level implementation in C--.
10:51:56 <BMeph> SamB: "air-castles?"
10:52:22 <dejones> byorgey: I was trying to see the possibility of doing the project as a Google SoC, but the consensus seemed to be that it was too "researchy."  ;)
10:52:36 <tromp> how about Java-=1
10:52:37 <Cheery> I'm in larger clouds than SamB, I'd want a HL language that is able to do low-level so well that no intermediate-language is needed anymore
10:53:02 <dejones> tromp: or Java=null :P
10:53:26 <SamB> well, I still think you need to have a language to write the bootloader in
10:53:36 <byorgey> dejones: cool.
10:53:41 <SamB> are you going to write the bootloader in Haskell too?
10:53:59 <dejones> SamB: Noo.
10:54:13 <mrd> C-- pretty much punted on the RTS though, I think Norman called it "a lot harder than we expected"
10:54:17 <dejones> SamB: I'm not going to write a bootloader too... too much work.
10:54:17 <Cheery> SamB: maybe someday
10:54:52 <dejones> mrd: Really?  :(  Do you know why?  Did they publish any paper or anything about why it was too hard?
10:54:59 <dejones> That's disappointing...
10:55:17 <mrd> let me see if i can find the posts
10:55:46 <shapr> mrd: Isn't Norman coming to Boston?
10:55:54 <dejones> mrd: Thank you.
10:55:58 <SamB> C-- seems to have an awful lot of features
10:56:08 <mrd> shapr: well he is on leave from Harvard, right?
10:56:23 <mrd> I thought he was looking for another job
10:56:36 <dejones> SamB: Yeah, C-- seemed to me very promising for the RTS and as an intermediate language for a compiler...
10:56:49 <Cheery> can you implement Hindley-Milner without lambdas? (sounds a lot like decaf coffee)
10:56:50 <dejones> Granted, I only read one of the C-- papers...
10:57:19 <mrd> it did, but the msgs norman posted made it seem like there wasn't enough interest
10:58:04 <mrd> https://cminusminus.org/lists/pipermail/cminusminus/2006-December/000008.html
10:58:07 <dejones> mrd: I'm interested!
10:58:09 <lambdabot> Title: [C--] C-- status report: yes, someone is (barely) out here, http://tinyurl.com/ym8pdv
10:58:55 <mrd> basically he was denied tenure
10:59:02 <mrd> (which makes zero sense to me, but i'm not harvard)
10:59:13 <SamB> dejones: actually I meant more that it seems to have MORE than I'd like...
11:00:26 <dejones> mrd: Yeah, that sucks.  Well.. Harvard probably just says "Show me the $$$."  ;)
11:00:30 <mrd> "But nobody who already had a working system has been able to port their front-end run-time system to use the C-- run-time interface.
11:00:39 <dejones> :(
11:02:07 <mrd> i don't think he's going to take the project down, so interested people can still contribute
11:02:45 <dejones> mrd: Yeah... part of what I thought might be useful for my Master's thesis in implementing the GHC RTS on the bare metal would be to convert some of it to C--.  I have to think more about it though.
11:04:33 <mrd> https://cminusminus.org/lists/pipermail/cminusminus/2006-December/000019.html
11:04:36 <lambdabot> Title: [C--] C-- status report: yes, someone is (barely) out here, http://tinyurl.com/275mns
11:05:14 <mrd> good luck with the "boat anchor" =)
11:07:30 <hpaste>  wurzelburzel pasted "error message" at http://hpaste.org/6195
11:08:33 <Heffalump> LLVM seems to be taking over as the intermediate language of choice
11:08:43 * Heffalump doesn't really know how it compares, though
11:09:26 <dejones> mrd: Yea, that does suck.  It sounds like GHC needs a clean start with C-- for the RTS.  Yet, I'm sure that could be utter hell and more like a PhD thesis. lol
11:09:56 <dejones> mrd: "boat anchor" is intimidating though.  ;)
11:10:02 <mrd> yea, NR is obviously not too thrilled with LLVM.
11:10:30 <mrd> dejones: you might want to focus on another compiler, like one designed for learning
11:10:40 <Heffalump> what are his objections to it?
11:10:49 <Heffalump> (which are presumably technical rather than NIH)
11:10:58 <mrd> what's that haskell compiler who's focus is pedagogical?
11:11:06 <Heffalump> EHC?
11:11:08 <oerjan> Helium?
11:11:08 <mrd> Heffalump: hmm, let me see if i can dig up his post
11:11:11 <Heffalump> something from Utrecht, anyway
11:11:15 <Heffalump> mrd: it's on the C-- list?
11:11:16 <mrd> ah right
11:11:16 <shapr> Helium?
11:11:18 <Heffalump> if so I can look for it
11:11:24 <mrd> Heffalump: it might be, i don't remember
11:11:26 <Heffalump> Helium is a cut-down Haskell
11:11:49 <dejones> mrd: But, the goal of the project is trying to take advantage of the concurrency support offered by Haskell in GHC's RTS support.
11:12:35 <oerjan> Heffalump: ITYM light-weight.
11:12:35 <Heffalump> (can't find anything on the C-- archives)
11:12:47 <Heffalump> no, I mean cut-down..
11:13:13 <oerjan> it's got a pun that flies right over your head...
11:13:32 <Heffalump> oh :-)
11:13:42 <mrd> dejones: the scheduler? the STM?
11:14:34 <dejones> mrd: Well, it's more getting the framework working, as in, implementing the RTS directly on the hardware so those other things can be re-used.
11:15:15 <dejones> mrd: But, I haven't settled down on the specific details of the project with my advisor yet, so I am not certain as to the specific goals... I'm speculating upon my interests.  ;)
11:16:50 <ikegami--> reading "Survey:Haskell Unicode support" in the last year http://blog.kfish.org/2007/10/survey-haskell-unicode-support.html
11:16:51 <lambdabot> Title: blog.kfish.org: Survey: Haskell Unicode support
11:17:14 <ikegami--> The author lives in Kyoto, Japan
11:17:19 <dejones> brb
11:18:27 <ikegami--> and I wonder what is improved about Unicode and ghc from the last year
11:18:41 * mrd should have stopped by Kyoto Univ when he was there
11:19:36 <pcc1> how can I trap exceptions (i.e. values returned by "error") using FFI?
11:20:27 <mrd> C doesn't have exceptions
11:20:49 <pcc1> I mean values returned using "error" from the haskell (when calling haskell from c)
11:21:09 <mrd> hm
11:21:42 <gwern> error is uncatchable, I thought
11:21:53 <oerjan> it's catchable from IO
11:21:54 <mrd> only in the IO monad you can
11:22:00 <mrd> it's an effect
11:25:26 <allbery_b> presumabkly anything invoked from C code is automagically in IO, though
11:25:33 * allbery_b does not know the answer
11:25:44 <dejones> how can I load a module that is in the Prelude from ghci?
11:25:49 <dejones> such as Network.Socket
11:26:00 <dejones> I was hoping "import" would work.  ;)
11:26:04 <pcc1> I suppose I could somehow capture the error from haskell and return to C
11:26:05 <allbery_b>  :m +Network.Socket
11:26:07 <shapr> :m + Network.Socket
11:26:19 <pcc1> how do I catch it from IO?
11:26:29 <dejones> allbery_b, shapr: thanks
11:26:31 <dons> pcc1: Foreign.C.Error
11:26:44 <dons> then detect what errno value and lift it to a haskell error of some flavour
11:27:05 <dons> throwErrnoIfMinus1 , for example
11:27:12 <dons> i usually like to lift -1 into Maybe a
11:27:22 <pcc1> I'm looking to capture haskell errors from C, not the other way around
11:27:25 <dons> simple, pure error handling makes the  C a little more robust
11:29:31 <oerjan> dejones: Network.Socket is not in the Prelude.  only Prelude is :)
11:30:17 <dejones> oerjan: Sorry, I guess it is in base?
11:30:28 <oerjan> hm
11:31:05 <oerjan> no, it's in the network-2.1.0.0 package
11:31:07 <dejones> oerjan: actually, it is in network
11:31:07 <dejones> ;)
11:31:25 <dejones> thanks though.
11:31:30 <oerjan> base is constantly shrinking :)
11:32:21 <dejones> oerjan: yay for modularity.
11:32:28 <skorpan> > :t mapM
11:32:33 <lambdabot>   parse error on input `:'
11:32:37 <oerjan> no > with :t
11:32:50 <skorpan> :t mapM
11:32:57 <skorpan> THANKS A LOT FREAKIN' LAMBDABOT
11:33:02 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
11:33:36 <shepheb> what's the best practice for doing a read without crashing?
11:33:36 * shapr snickers
11:33:51 <mrd> :t reads
11:33:52 <lambdabot> forall a. (Read a) => String -> [(a, String)]
11:34:06 <mrd> > reads "a" :: [(Int,String)]
11:34:08 <lambdabot>  []
11:34:12 <mrd> > reads "12" :: [(Int,String)]
11:34:13 <lambdabot>  [(12,"")]
11:34:15 <oerjan> skorpan: every command starts with @ or ? (free choice) except three abbreviations:  :t for @type, :k for @kind,  > for @run
11:34:18 <resiak> shepheb: case reads x of { [(y, "")] -> Just y; _ -> Nothing }
11:34:30 <conal> @query lambdabot
11:34:30 <lambdabot> Unknown command, try @list
11:35:05 <shepheb> mrd,resiak: okay. that should work fine.
11:42:41 <byorgey> dcoutts: patch to fix synopsis paragraph wrapping incoming =)
11:43:21 <byorgey> dcoutts: turns out the pretty-print library has some setting called 'ribbonsPerLine' which does weird things, and is set to 1.5 by default instead of 1...
11:47:36 <Heffalump> byorgey/dcoutts: I've run into that too
11:47:47 <Heffalump> never did quite understand what it was trying to achieve
11:48:38 <dons> shepheb: use maybeRead
11:48:43 <byorgey> Heffalump: yeah, it's weird...
11:48:50 <dons> +maybeRead :: Read a => String -> Maybe a
11:48:50 <dons> +maybeRead s = case reads s of
11:48:50 <dons> +    [(x, "")] -> Just x
11:48:50 <dons> +    _         -> Nothing
11:49:01 * byorgey peeks at the implementation of fullRender
11:49:04 <Heffalump> it caused the thing I was pretty printing to get very stupidly wrapped, anyway
11:50:04 <skorpan> > 1 + 1.0
11:50:05 <lambdabot>  2.0
11:50:07 <skorpan> cool
11:50:16 <byorgey> Heffalump: yes, that's exactly what I was running into
11:50:42 <byorgey> Heffalump: not only was it not the right width, some lines were way too short when the next word obviously could have fit.
11:55:06 <Heffalump> byorgey: indeed. It just kept pushing stuff onto the next line.
11:57:33 <kaol> heh. been doing quite a bit of Haskell coding since I last used C++... Using the visitor pattern for just about anything comes so naturally now.
11:57:50 <skorpan> i thought the visitor pattern was something no one ever did
11:58:29 <kaol> it's just a map in disguise, for many uses
12:03:00 <Cheery> sigh... stupid hack: instance Serializable Char where serialize _ a = fromString [a]
12:03:22 <skorpan> is there a way to make a specific case clause match two different patterns?
12:03:29 <Cheery> in other hand, you could argue that Char is not serializable
12:03:34 <skorpan> e.g. A b and B c both do the same thing but anything else fails
12:04:01 <skorpan> atm i'm using a silly "where"
12:05:06 <byorgey> skorpan: I don't think so
12:05:13 <Cheery> I like the fact that haskell actually uses unicode strings
12:06:21 <oerjan> @hoogle Serializable
12:06:21 <lambdabot> No matches found
12:06:23 <radix> Cheery: Indeed, and that there's no implicit conversion.
12:06:42 <radix> I hate that about Python.
12:06:47 <SamB> Cheery: that basically came about because Chars were already heap allocated...
12:07:14 <SamB> so it did'nt really cost any more to use 32 bits than to use 8
12:10:02 <Cheery> SamB: heap allocated...
12:10:30 <Cheery> I've been wondering that too actually..
12:10:37 <Cheery> how haskell's strings are implemented?
12:10:49 <Cheery> and how does the ByteString affect?
12:11:07 <roconnor> @src String
12:11:07 <lambdabot> type String = [Char]
12:11:33 <Cheery> roconnor: and the list?
12:11:46 <roconnor> @src []
12:11:47 <lambdabot> data [] a = [] | a : [a]
12:12:07 <roconnor> er that might look confusing
12:12:09 <dejones> Is hackage.haskell.org having issues...?  It keeps timing out for me.
12:12:18 <roconnor> data List a = Nil | Cons a (List a)
12:12:27 <roconnor> that is what a desugered version would look like.
12:15:19 <dejones> If I had a list l = [(+), (-)], is there a way I could iterate through the list l and call the elements in the list as functions?
12:15:55 <byorgey> dejones: sure.
12:16:09 <shepheb> map ($ some args) l
12:16:12 <dejones> byorgey: how?
12:16:13 <gnuvince> > map (\f -> f 3 4) [(+), (*)]
12:16:14 <lambdabot>  [7,12]
12:16:26 <shepheb> oh, no mine won't work.
12:16:33 <dejones> shepheb: bad you! :P
12:16:35 <xerox> http://img251.imageshack.us/img251/782/casteixq7.jpg
12:16:38 <xerox> Err, sorry
12:16:39 <xerox> > [(+), (-)] `ap` [1..3] `ap` [4..6]
12:16:40 <lambdabot>  [5,6,7,6,7,8,7,8,9,-3,-4,-5,-2,-3,-4,-1,-2,-3]
12:16:42 <byorgey> shepheb: only if the functions take one parameter.
12:16:44 <xerox> Wrong buffer.
12:16:49 <gnuvince> :t ap
12:16:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:16:54 <shepheb> byorgey: yeah, I realized the mistake.
12:16:54 <dejones> lol xerox
12:17:17 <byorgey> > [(+), (-)] <*> [1..3] <*> [4..6]
12:17:18 <lambdabot>  [5,6,7,6,7,8,7,8,9,-3,-4,-5,-2,-3,-4,-1,-2,-3]
12:17:27 <dejones> why use (\f -> ...) instead of `ap` ? or <*> ?
12:17:42 <byorgey> dejones: well, it's much easier to see what is going on.
12:17:48 <dejones> See, this is where Haskell gets me... so many syntax possibilities...
12:17:53 <byorgey> if you don't already understand `ap`/<*>.
12:18:07 <Cheery> > map (($20)$40)  [(+), (-)]
12:18:08 <lambdabot>        add an instance declaration for (Num (a -> (a1 -> a1 -> a1) -> b))
12:18:09 <dejones> byorgey: I don't understand `ap` or <*> at all
12:18:17 <byorgey> dejones: then don't use them for now =)
12:18:28 <dejones> (\f -> ...) at least I know that is a lambda function
12:18:55 <byorgey> dejones: right. \f -> f 3 4  is a function which takes a function f as input, and applies f to the arguments 3 and 4.
12:18:59 <Cheery> map ($40) $ map ($20) [(+), (-)]
12:19:02 <Cheery> > map ($40) $ map ($20) [(+), (-)]
12:19:02 <lambdabot>  [60,-20]
12:19:05 <dejones> > map (\f -> f [3, 4]) [(+), (*)]
12:19:05 <lambdabot>   add an instance declaration for (Num [t])
12:19:18 <byorgey> dejones: so mapping that over a list of functions will take each function in the list, and apply it to 3 and 4.
12:20:00 <byorgey> > map (\f -> f [3,4]) [reverse, replicate 2, cycle]
12:20:00 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
12:20:00 <lambdabot>       Expected...
12:20:03 <dejones> > map (\f -> foldl f [3, 4]) [(+), (*)]
12:20:04 <lambdabot>   add an instance declaration for (Num [t])
12:20:08 <dejones> ??
12:20:30 <byorgey> > maap (\f -> foldl f 0 [3,4]) [(+), (*)]
12:20:30 <lambdabot>   Not in scope: `maap'
12:20:34 <byorgey> grr
12:20:37 <byorgey> > map (\f -> foldl f 0 [3,4]) [(+), (*)]
12:20:37 <dejones> lol
12:20:37 <lambdabot>  [7,0]
12:20:54 <dejones> oh, so I did have the right idea, yay.  :)
12:21:09 <dejones> that is cool
12:21:32 <Cheery> > map (\f -> scanl f [3,4,5]) [(+), (*)]
12:21:32 <lambdabot>   add an instance declaration for (Num [t])
12:21:49 <dejones> > map (\f -> foldl f [, 4]) [reverse, ]
12:21:49 <lambdabot>  Parse error at "," (column 21)
12:21:52 <byorgey> > map (\(f,z) -> foldl f z [1..5]) [((+), 0), ((*), 1), (max,-100)]
12:21:53 <lambdabot>  [15,120,5]
12:21:57 <dejones> > map (\f -> foldl f ['abc']) [reverse]
12:21:57 <lambdabot>  Improperly terminated character constant at "'abc'..." (column 21)
12:22:01 <Cheery> > map (\f -> scanl1 f [3,4,5]) [(+), (*)]
12:22:02 <lambdabot>  [[3,7,12],[3,12,60]]
12:22:09 <dejones> > map (\f -> foldl f "abc") [reverse]
12:22:09 <lambdabot>  Couldn't match expected type `b -> [Char]'
12:22:11 <dejones> lol
12:22:14 <skorpan> is there a dummy monad which allows one to do "do" notation?
12:22:22 <skorpan> ah, Id?
12:22:24 <byorgey> skorpan: Identity?
12:22:26 <dejones> > map (\f -> foldl f ["abc"]) [reverse]
12:22:27 <lambdabot>  Couldn't match expected type `b -> [[Char]]'
12:22:29 <skorpan> Identity, awesome, thanks
12:22:33 <Cheery> > map (\f -> foldl1 f [3,4,5]) [(+), (*)]
12:22:33 <lambdabot>  [12,60]
12:22:52 <Cheery> > map (\f -> foldl1 f [3,4,5]) [(+), (*), (-)]
12:22:52 <lambdabot>  [12,60,-6]
12:22:52 <byorgey> dejones: folding with reverse doesn't make sense
12:22:58 <dejones> byorgey: yea...
12:23:10 <dejones> I was trying to think what might.
12:23:40 <dejones> > map (\f -> map f ["abc"]) [reverse]
12:23:40 <lambdabot>  [["cba"]]
12:23:43 <dejones> :)
12:23:53 <dejones> map is fun
12:24:00 <byorgey> > map ($ "abcde") [reverse, concat . replicate 3, (>> "hi")]
12:24:01 <lambdabot>  ["edcba","abcdeabcdeabcde","hihihihihi"]
12:24:10 <dejones> byorgey: show-off :P
12:24:15 <byorgey> hehe =)
12:24:27 <dejones> what is the $?
12:24:35 <byorgey> dejones: it's just function application
12:24:37 <byorgey> f $ x = f x
12:24:39 <Deewiant> @src ($)
12:24:39 <lambdabot> f $ x = f x
12:24:50 <byorgey> so ($x) means \f -> f x
12:24:54 <dejones> \f -> f x
12:24:54 <dejones> ?
12:24:55 <dejones> ok
12:25:23 <dejones> is there one notation that is generally preferred?
12:25:34 <byorgey> dejones: one notation for what?
12:25:42 <dejones> (\f -> f x) or (f $ x), which one of these is preferred?
12:25:46 <dejones> they are the same, right?
12:26:11 <byorgey> you mean (\f -> f x) or ($x) ?
12:26:31 <byorgey> of those I think ($x) is probably preferred since it's shorter and relatively easy to read, once you know what $ is
12:26:36 <dejones> yea, but why isn't it (f$x) ?
12:26:47 <byorgey> (f $ x) just means (f x)
12:27:02 <byorgey> it is just a value which is the result of applying f to x
12:27:14 <dejones> (\f -> f x) equivalent to (f $ x) ?
12:27:17 <Cheery> > map (\f -> foldl f ["abc", "guux", "lolcat", "foobar"]) [intersect, union]
12:27:17 <lambdabot>  [<[[[Char]]] -> [[Char]]>,<[[[Char]]] -> [[Char]]>]
12:27:19 <byorgey> \f -> f x, on the other hand, is a *function* which takes a function f as input, and applies it to x.
12:27:24 <byorgey> dejones: no.
12:27:37 <byorgey> f x  is not the same as  \f -> f x.
12:27:44 <dejones> byorgey: is it because \f is an "anonymous" function?
12:27:56 <dejones> not sure if that is the correct terminology
12:27:56 <Cheery> > map (\f -> foldl1 f ["abc", "guux", "lolcat", "foobar"]) [intersect, union]
12:27:57 <lambdabot>  ["","abcguxlotfr"]
12:28:05 <byorgey> dejones: right, \f ->  creates an anonymous function which takes one parameter, called f
12:28:07 <dejones> Cheery: :P
12:28:32 <dejones> byorgey: and f $ x is the function f (not anonymous)
12:28:33 <dejones> correct?
12:28:38 <Cheery> > map (\f -> scanl1 f ["abc", "guux", "lolcat", "foobar"]) [intersect, union]
12:28:38 <lambdabot>  [["abc","","",""],["abc","abcgux","abcguxlot","abcguxlotfr"]]
12:28:40 <byorgey> dejones: not quite.
12:28:45 <dejones> lol
12:28:51 <byorgey> dejones: f $ x is just the result of applying f to x.
12:28:53 <dejones> correct my brain.  :)
12:28:55 <byorgey> and f must have been previously defined.
12:29:07 <dejones> alright.
12:29:17 <byorgey> dejones: here, maybe this helps:
12:29:20 <Deewiant> > (\x -> x + 1) $ 4
12:29:21 <lambdabot>  5
12:29:23 <byorgey> @type ?f $ ?x
12:29:24 <lambdabot> forall a b. (?x::a, ?f::a -> b) => b
12:29:33 <byorgey> @type \f -> f ?x
12:29:33 <lambdabot> forall t t1. (?x::t) => (t -> t1) -> t1
12:29:42 <byorgey> or... maybe not =P
12:29:44 <Cheery> ???
12:29:49 <dejones> byorgey: hahah
12:29:56 <dejones> byorgey: trying to make my brain melt?
12:30:02 <byorgey> dejones: not on purpose =)
12:30:09 <dejones> suure...
12:30:15 <dejones> I think Cheery is though.
12:30:17 <byorgey> well... only in a good way. ;)
12:30:21 <dejones> with all those crazy maps.
12:30:28 <oerjan> @quote paperwork
12:30:28 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
12:30:39 <radix> dejones: I don't know if this is totally correct, but I just think of $ as a way to avoid parentheses, most of the time
12:30:40 <dejones> lol
12:30:57 <radix> dejones: f $ x y = f (x y)
12:31:10 <dejones> radix: hmm, interesting usage.
12:31:14 <radix> when used in higher-level functions of course it has different utilities :)
12:31:17 <radix> err, higher-order
12:31:41 <dejones> Deewiant: thank you for that example, simple and clear.
12:31:49 <hpaste>  Cheery annotated "HellMonad" with "Screams, "\NUL\SYN\v\NUL\NUL\NUL\ACK\NULNo protocol specified\n\b\b"" at http://hpaste.org/6186#a2
12:31:50 <Deewiant> :-)
12:32:07 <Deewiant> dejones: and in that example, leaving the $ out works just as well
12:32:12 <Deewiant> > (\x -> x + 1) 4
12:32:13 <lambdabot>  5
12:32:16 <dejones> lol
12:32:18 <Deewiant> but here's the difference
12:32:25 <Deewiant> > (\x y -> x + y) $ 4 5
12:32:25 <lambdabot>   add an instance declaration for (Num (t -> a))
12:32:29 <Deewiant> err
12:32:39 <byorgey> no $ there...
12:32:55 <Deewiant> yeah, exactly right.
12:32:59 <Deewiant> > (\x y -> x + y) 4 5
12:32:59 <lambdabot>  9
12:33:03 <dejones> right
12:33:03 <Deewiant> confused myself there.
12:33:10 <Deewiant> > (\x y -> x + y) (4 5)
12:33:10 <lambdabot>   add an instance declaration for (Num (t -> a))
12:33:17 <Deewiant> dejones: see?
12:33:21 <dejones> yep.  :)
12:33:40 <Deewiant> dejones: the $ is equivalent to bracketing the rest, so it tries to call the function "4" with the param "5" which of course doesn't make any sense
12:34:15 <dejones> > (\x y -> x + y) $ (+) 0 1
12:34:16 <lambdabot>  <Integer -> Integer>
12:34:18 <dejones> lol
12:34:23 <dejones> oops
12:34:32 <dejones> > (\x y -> x + y) $ ((+) 0 1) 2
12:34:32 <lambdabot>   add an instance declaration for (Num (t -> a))
12:34:40 <dejones> > (\x y -> x + y)  ((+) 0 1) 2
12:34:41 <lambdabot>  3
12:34:44 <dejones> ll
12:34:45 <dejones> lol
12:34:53 <radix> :)
12:35:07 <Deewiant> dejones: \x y -> x + y is equivalent to (+)
12:35:53 <dejones> yea
12:35:56 <dejones> neat stuff
12:36:05 <dejones> Haskell is always intriguing.
12:36:53 <dejones> > (\x y -> x + y) 1 2 == (+) 1 2
12:36:54 <lambdabot>  True
12:36:56 <dejones> ;)
12:37:11 <dejones> > (\x y -> x + y) == (+)
12:37:11 <lambdabot>   add an instance declaration for (Eq (a -> a -> a))
12:37:11 <lambdabot>     In the expression: (...
12:37:15 <dejones> hehe
12:37:22 <Deewiant> @check \a b -> (\x y -> x + y) a b == a + b
12:37:23 <lambdabot>  OK, passed 500 tests.
12:37:34 <dejones> oohh, nice.
12:37:57 <RayNbow> @src repeat
12:37:57 <lambdabot> repeat x = xs where xs = x : xs
12:38:48 <noteventime> I love Haskell for definitions like that one :D
12:39:07 <roconnor> @pl let xs = x : xs in xs
12:39:07 <lambdabot> fix (x :)
12:39:19 * RayNbow was just too lazy to type it :p
12:39:25 <roconnor> > fix (9 :)
12:39:26 <lambdabot>  [9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9,9...
12:39:29 <oerjan> @pl repeat x = xs where xs = x : xs
12:39:30 <lambdabot> (line 1, column 24):
12:39:30 <lambdabot> unexpected "="
12:39:30 <lambdabot> expecting variable, "(", operator or end of input
12:39:36 <gnuvince> :t fix
12:39:36 <lambdabot> forall a. (a -> a) -> a
12:39:44 <roconnor> I don't think pl likes where clauses.
12:39:46 <RegexGuy> I was playing with threading in haskell, and was using forkIO(). It seems to not have a join method... is that correct?
12:39:47 <NatLWalker> Any haskell IDEs exist?
12:39:48 <NatLWalker> !ide
12:39:48 <Cheery> @src fix
12:39:48 <lambdabot> fix f = let x = f x in x
12:39:52 <gwern> @pl  pad1 o text = text ++ take (o - length text) (repeat ' ')
12:39:52 <lambdabot> pad1 = ap (++) . flip flip (repeat ' ') . (take .) . (. length) . (-)
12:40:02 <RayNbow> NatLWalker: Leksah or something was recently announced
12:40:12 <NatLWalker> Thank you.
12:40:18 <RayNbow> http://www.haskell.org/pipermail/haskell-cafe/2008-February/039553.html
12:40:20 <lambdabot> Title: [Haskell-cafe] ANN: Leksah 0.1 - Haskell IDE written in Haskell, http://tinyurl.com/2zy3ob
12:40:30 <oerjan> @pl repeat x = let xs = x : xs in xs
12:40:30 <lambdabot> repeat = fix . (:)
12:40:38 <byorgey> NatLWalker: note that it is not very featureful yet.  you're probably better off using emacs, vi, or some editor of your choice.
12:40:52 <byorgey> NatLWalker: but good haskell support exists for both emacs and vi.
12:41:09 <NatLWalker> ugh... leksah is a GTK app.
12:41:36 <noteventime> Well, there's no Qt for Haskell :/
12:41:51 <oerjan> actually i thought there was
12:41:58 <gwern> sure there is. qthaskell
12:42:01 <noteventime> :O
12:42:03 <gwern> dunno how usefulit is though...
12:42:10 <noteventime> Interesting
12:42:19 <RegexGuy> anyone know of a way to join a forkIO() thread?
12:42:21 <noteventime> How come I didn't find it? Is it new?
12:42:29 <gwern> http://sourceforge.net/projects/qthaskell
12:42:29 <gwern> @where qthaskell
12:42:30 <lambdabot> I know nothing about qthaskell.
12:42:32 <siti> RegexGuy: using mvars
12:42:40 <gwern> @where+ qthaskell http://sourceforge.net/projects/qthaskell
12:42:40 <lambdabot> I will remember.
12:42:46 <gwern> @where qtHaskell
12:42:46 <lambdabot> http://sourceforge.net/projects/qthaskell
12:42:47 <RegexGuy> I can construct something using STM
12:42:53 <RegexGuy> or use mvars or such
12:43:00 <siti> ghc forkIO docs has an example of how to do it
12:43:14 <RegexGuy> with mvars?
12:43:26 <noteventime> gwern: Thanks! :o
12:44:52 <gwern> also http://www.mail-archive.com/haskell@haskell.org/msg20791.html
12:44:52 <lambdabot> Title: [Haskell] announcing qtHaskell-1.1.1, the first preview release of qtHas
12:46:43 <noteventime> Got to try though out :)
12:48:43 <noteventime> gwern: Explains why I didn't know about it
12:52:06 <dejones> How about this: map (\f -> map f ["abc", "def", "ghi"]) ["reverse"]
12:52:18 <dejones> How could you get the "reverse" to be called as a function?  :)
12:52:31 <oerjan> drop those last " " 's
12:52:41 <dejones> oerjan: lol
12:52:43 <gwern> noteventime: oh, but of course the real reason is because I am so much better than you
12:52:53 <dejones> oerjan: and how might you do that?  ;)
12:53:11 <oerjan> > map (\f -> map f ["abc", "def", "ghi"]) [reverse]
12:53:11 <lambdabot>  [["cba","fed","ihg"]]
12:53:28 * gwern begins writing my autobuigraphy; I shall call it Ecce Homo! the first chapter will be, Why I am So Smart, the second, Why I am So Great, and thus on and thus forth
12:54:30 <dejones> oerjan: no no, I know how to do that... I want to convert the "reverse" into a function.
12:54:52 <oerjan> dejones: not standard haskell - maybe with template haskell there is a way
12:54:54 <noteventime> gwern: Are you then, perhaps, the super man?
12:55:06 <roconnor> is Fred McBride related to Conor McBride?
12:55:24 <oerjan> it has to be done at compile time, though
12:55:26 <Cale> dejones: You might look at hs-plugins.
12:55:31 <oerjan> or that
12:55:40 <Cale> hs-plugins has a type-safe eval
12:55:46 <dejones> Cale, oerjan: alright, template-haskell and hs-plugins...
12:55:49 <gwern> noteventime: the super man never is! he is always becoming the super man
12:55:55 <dejones> Cale: ahh, cool.
12:56:11 <Cale> Template Haskell could do it, but only at compile time, and it would be awkward.
12:56:15 <noteventime> gwern: :)
12:56:54 <dejones> Cale: hmm, thanks.
12:57:12 <Cale> However, using it to construct reverse at a polymorphic type will be tricky.
12:57:40 <Cale> (but it can be done with some hackery)
12:58:01 <grahamhutton> roconner: yes, fred is conor's father
12:58:01 <Cale> (you could specifically construct the version at any given type though)
12:58:10 <dejones> Cale: Well, I was more interested in possibly taking a URL, such as www.foo.com/bar/ and executing the bar function based upon what was in the URL.
12:58:29 <dejones> I guess really the safest way would be to just define the available functions first...
12:58:31 <Cale> That sounds brutally dangerous.
12:58:35 <dejones> Yeah.
12:58:45 <Cale> Maybe if it was a pure function.
13:00:00 <noteventime> gwern: I was given the collected works a little while ago :) Still in the beginning of Zarathustra though
13:00:01 <Cale> But you'd essentially be reinventing lambdabot with a bad user interface ;)
13:00:04 <gwern> lambdabot has shown us how dangerous even ostensibly pure can be
13:00:22 <gwern> noteventime: what a coincidence! I was sure my joke was going to fall on deaf ears
13:00:31 <dejones> Cale: lol.  I was more thinking for an web application server how they might interpret URLs and call the correct function.
13:01:14 <dejones> gwern: what has lambdabot done that was dangerous?
13:01:39 <grahamhutton> oops: roconnor (not oconner): yes, fred is conor's father
13:01:52 <roconnor> grahamhutton: awwww
13:01:59 <gwern> dejones: have you looked at the page on the wiki and seen how many countermeasures lambdabot had to take?
13:02:22 <Cale> dejones: Well, not a whole lot, but lots of exploits were found and had to be covered.
13:02:23 <dejones> gwern: heh, nope.  I didn't know there was a countermeasures page for the lambdabot.
13:03:16 <gwern> see http://haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code
13:03:17 <roconnor> http://www.haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code
13:03:19 <lambdabot> Title: Safely running untrusted Haskell code - HaskellWiki, http://tinyurl.com/2orccu
13:03:21 <dejones> dons sure does contribute a lot.
13:03:23 <lambdabot> Title: Safely running untrusted Haskell code - HaskellWiki, http://tinyurl.com/3alo2u
13:03:30 <Cale> dejones: lambdabot now parses each string separately as Haskell expression before building a program from it, to help prevent the usual sorts of injection attacks
13:03:44 * gwern likes the 16 different listed attacks
13:04:26 <roconnor> very large array allocations can integer overflow the storage manager, allowing arbitrary memory access
13:04:34 <roconnor> :(
13:04:37 <roconnor> is that true?
13:05:04 <roconnor> ``creating class instances that violate assumed laws (cf EvilIx)'' this is one of my favourites.
13:05:35 <roconnor> is there a wiki page about EvilIx?
13:05:36 <SamB> roconnor: I thought they fixed that...?
13:05:50 <roconnor> SamB: could be.  There was talk about fixing it.
13:06:15 <dejones> "throwing a piece of code as an exception, which is evaluated when the exception is shown"
13:06:16 <dejones> I like that.
13:06:17 <dejones> hehe
13:06:52 <Cale> dejones: Right, it was one way to defeat the resource limits before.
13:07:26 <Cale> dejones: (early on, the resource limits were applied to the evaluation of the expression, but not to showing exceptions thrown)
13:07:45 <dejones> :)
13:08:15 <roconnor> Cale: maybe we should disallow all functions that throw execptions.  No more (\).
13:08:34 <Cale> Nah, it's cool now.
13:10:08 <dejones> roconnor: is that (\) as in \x -> x + 1, or something else?
13:10:17 <dejones> like, divide by zero?
13:10:31 <dejones> 1 / 2
13:10:35 <dejones> > 1 / 2
13:10:35 <lambdabot>  0.5
13:10:46 <dejones> heh, the other slash..
13:11:03 <mrd> :t (/)
13:11:04 <lambdabot> forall a. (Fractional a) => a -> a -> a
13:11:18 <mrd> (/) :: Fractional a => a -> a -> Maybe a !!!
13:12:28 <TSC> Isn't it safe (for lambdabot-hacking purposes) to keep (/), because you can't throw arbitrary code as the exception?
13:12:51 <roconnor> dejones: er yeah, I meant (/).
13:13:07 <oerjan> > error $ repeat $ "It's all safe now"
13:13:08 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
13:13:11 <roconnor> TSC: good point
13:13:12 <oerjan> oops
13:13:19 <grahamhutton> TSC: yes, you can only throw a string
13:13:35 <oerjan> > error $ cycle $ "It's all safe now - "
13:13:35 <lambdabot>  Exception: It's all safe now - It's all safe now - It's all safe now - It's ...
13:13:47 <dejones> oerjan: lambdabot is smart these days...
13:13:51 <roconnor> > error $ cycle $ ""
13:13:52 <lambdabot>  Exception: Prelude.cycle: empty list
13:14:24 <dejones> > repeat 1
13:14:25 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:14:26 <roconnor> > error $ fix (""++)
13:14:27 <lambdabot>  Exception: <<loop>>
13:14:32 <gnuvince> :t (\)
13:14:33 <lambdabot> parse error on input `)'
13:14:33 <dejones> hehe
13:14:40 <dejones> :t (/)
13:14:41 <lambdabot> forall a. (Fractional a) => a -> a -> a
13:14:59 <roconnor> it's getting harder and harder to make GHC go into a tight infinite loop.
13:15:05 <oerjan> > error $ error "Is this fixed?"
13:15:05 <lambdabot>  Exception: Is this fixed?
13:15:15 <oerjan> apparently
13:15:41 <gwern> you can still do it. I've run into a case while enumerating LANGUAGE pragmas where omitting a particular type extension seems to do just that to GHC
13:15:42 <oerjan> > fix error
13:15:43 <lambdabot>  Exception: <<loop>>
13:15:49 <oerjan> oops :)
13:16:35 <Heffalump> > fix (('a':) . error)
13:16:36 <lambdabot>  Exception
13:16:45 <oerjan> ah
13:17:06 <roconnor> Heffalump: what have you done?
13:17:15 <oerjan> hm i wonder how deep it checks
13:17:47 <Heffalump> roconnor: hmm?
13:17:54 <oerjan> > foldr id "test" $ replicate 10 error
13:17:55 <lambdabot>  Exception: test
13:18:09 <oerjan> > foldr id "test" $ replicate 50 error
13:18:10 <lambdabot>  Exception: test
13:18:18 <oerjan> > foldr id "test" $ repeat error
13:18:19 <lambdabot>  Exception: <<loop>>
13:18:31 <oerjan> bah
13:18:58 <oerjan> > foldr id "test" $ repeat $ ('a':) . error
13:18:59 <lambdabot>  Exception
13:19:07 <oerjan> > foldr id "test" $ replicate 5 $ ('a':) . error
13:19:08 <lambdabot>  Exception
13:19:55 <oerjan> hm maybe it's actually strictness that does it
13:20:08 <oerjan> > error $ 'a' : error "b"
13:20:09 <lambdabot>  Exception
13:20:21 <oerjan> > error $ error "b"
13:20:21 <lambdabot>  Exception: b
13:37:29 <roconnor> After talking with McKinna, I am re-reading a view from the left.
13:38:03 <roconnor> It really gets me excited about the whole programming endevour.
13:41:40 <monochrom> Oh, "a view from the left" is the name of an article. :)
13:41:47 * monochrom almost couldn't parse that. :)
13:42:08 <roconnor> right sorry
13:42:16 <roconnor> ``The view from the left''
13:42:25 <roconnor> hmm
13:42:37 <roconnor> I alway thought it was ``A view from the left''.
13:43:31 <roconnor> I can't tell if the oleg proof system is a play on the lego proof system, or a nod to oleg, or both.
13:50:50 <noteventime> Does anyone know about a good font to use with emacs's haskell font lock feature?
13:51:00 <cjb> noteventime: I use Monospace-10.
13:51:19 <cjb> (this is an Xft font, not bitmap)
13:51:28 <noteventime> cjb: ok
13:52:04 <cjb> it looks like http://chris.printf.net/pretty-unicode-haskell.png , only the dpi there is wrong.
14:01:30 <sclv_> can I take a value m (a -> m b) and turn it into m ( a -> b) ?
14:01:47 <sclv_> somehow i suspect not.
14:02:14 <heatsink> sclv_: No... You could use that to convert a monadic function into a pure function.
14:02:42 <sclv_> sigh. back to the drawing board.
14:02:51 <heatsink> sclv_: Why do you want an (a->b) from an (a->m b)?
14:03:20 <sclv_> I don't. I want m (a->b) from m (a -> m b).
14:03:41 <sclv_> I need to make my classes work out for this bit of type hackery i'm trying.
14:03:45 <roconnor> ugh, rho-reduction
14:03:52 <roconnor> Connor!!!
14:04:02 <tromp> that's like wanting an m a from an m m a
14:04:04 <heatsink> Hmm.  Is m a monad class?
14:04:10 <sclv_> heatsink: yeah.
14:04:25 <oerjan> :t join
14:04:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:04:27 <sclv_> essentially I'm trying to write a polyvaridic function that plays nice with applicatives.
14:04:31 <roconnor> @type ap
14:04:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:04:50 <sclv_> right. but between the two, can I pull it off?
14:06:19 <tromp> what shld it do for m==a list?
14:06:29 <roconnor> @type map ($)
14:06:30 <lambdabot> forall a b. [a -> b] -> [a -> b]
14:06:36 <roconnor> @type liftM ($)
14:06:37 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m (a -> b)
14:07:00 <roconnor> @type  ($) >>=
14:07:01 <lambdabot> parse error (possibly incorrect indentation)
14:07:05 <roconnor> @type  (($) >>=)
14:07:06 <lambdabot> forall a b b1. ((a -> b) -> (a -> b) -> b1) -> (a -> b) -> b1
14:07:15 <roconnor> @type  (>>= ($))
14:07:16 <lambdabot> forall a b. (a -> a -> b) -> a -> b
14:07:25 <resiak> go go monad ((->) r)
14:07:51 <sclv_> :t fmap join
14:07:52 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (Functor f, Monad m) => f (m (m a)) -> f (m a)
14:07:56 <oerjan> i don't think you can go from a -> m b to m (a -> b), which is weaker
14:08:10 <sclv_> yeah. it doesn't seem feasable...
14:09:11 <oerjan> actually they are equivalent
14:09:45 <sclv_> but can I do it?
14:09:57 <sclv_> I'm feeling very on the fence about this.
14:10:20 <oerjan> no.  not even with m = Maybe
14:10:43 <oerjan> if a is a type for which you cannot enumerate all values
14:11:02 <roconnor> you could always return nothing :P
14:11:10 <oerjan> oh well
14:11:23 <radetsky> gwern: you there?
14:11:29 <oerjan> Either e
14:11:34 <heatsink> What do you call a type of kinds?
14:11:37 <sclv_> this is picking up from our conversation the other night: still trying to do the same absurd thing.
14:11:38 <oerjan> where e is an unknown type
14:12:08 <sclv_> right now I have a nice renderf tmpl (key,val) (key2,val2)... which is a lightweight thing like printf does.
14:12:14 <oerjan> then you cannot even return Left e unless you can actually find some value a that returns Left.
14:12:18 <radetsky> @seen gwern
14:12:19 <lambdabot> gwern is in #xmonad and #haskell. I last heard gwern speak 56m 37s ago.
14:12:41 <oerjan> and you cannot return Right f without knowing that no value a returns a Left
14:12:48 <sclv_> but I'm still dreaming of some sort of syntax where I can mix in monadic actions.
14:13:01 <sclv_> to get something intensely declarative.
14:13:32 <roconnor> sclv_: like Connor's idiom brackets?
14:13:56 <dons> ?users
14:13:56 <lambdabot> Maximum users seen in #haskell: 463, currently: 443 (95.7%), active: 12 (2.7%)
14:14:03 <sclv_> sort of -- i'd be happy to use raw applicative syntax if I could make it work with what I have. initially I thought it might work automatically, but no.
14:16:33 <sclv_> as it is, I can use =<< and stick at least one monadic value at the end of a chain, which is better than nothing.
14:17:00 <radetsky> dons: you ever work with hscurses?
14:17:02 <gwern> radetsky: what's up?
14:17:31 <radetsky> I think you broke hscurses
14:17:35 <dons> radetsky: its based on some code i wrote for yi
14:17:37 <radetsky> either that or I'm doing something really wrong
14:17:42 <dons> i may even have committed to it
14:17:56 <gwern> radetsky: hm? I doubt I broke all of it, since hetris runs fine for me after I ported it to hscurses
14:18:13 <radetsky> j/k
14:18:18 <dons> where's the hetris repo, btw?
14:18:20 <gwern> radetsky: but maybe you're using an older one? I uploaded recently another one with a lot of changes I needed for hetris
14:18:34 <gwern> on my computer
14:18:35 <radetsky> I pulled about 5min ago
14:18:53 <radetsky> but anyway, it's having cascades of link errors
14:18:57 <gwern> radetsky: well, what's the problem?
14:19:07 <radetsky> I don't think it can see any of the curses library anymore
14:19:09 <radetsky> for example:
14:19:31 * tibbe is one step closer to finishing his parser library.
14:19:33 <radetsky> /usr/local/lib/hscurses-1.3/ghc-6.8.2/libHShscurses-1.3.a(Curses.o): In function `sama_info':
14:19:33 <radetsky> (.text+0xd367): undefined reference to `LINES'
14:19:33 <radetsky> /usr/local/lib/hscurses-1.3/ghc-6.8.2/libHShscurses-1.3.a(Curses.o): In function `sama_info':
14:19:33 <radetsky> (.text+0xd36d): undefined reference to `COLS'
14:19:51 <conal> is System.Time (http://www.haskell.org/ghc/docs/latest/html/libraries/old-time/System-Time.html) deprecated?
14:19:53 <lambdabot> http://tinyurl.com/27ptdb
14:19:54 <dons> macros
14:20:00 <dons> conal, hmm, well, it in old-time now
14:20:07 <dons> so i you can figure out the time package, then yes,
14:20:19 <dons> but even sigbjorn says the 'time' package is wacky complicated
14:20:27 <conal> dons: "old-time" what i just noticed.
14:20:33 <gwern> radetsky: hm. check that its being built with -fvia-c
14:20:35 <gwern> radetsky: what OS and ncurses you using?
14:20:38 <dons> but its still entirely usable
14:20:38 <conal> yipes!  complicated even by sigbjorn standards?
14:20:43 <dons> uh huh.
14:20:49 <dons> scary eh?
14:20:57 <hpaste>  tibbe annotated "The beginnings of an incremental parser library" with "The beginnings of an incremental parser library" at http://hpaste.org/6180#a1
14:21:13 <radetsky> yeah, it is
14:21:16 <gwern> fwiw, I have sys-libs/ncurses-5.6-r2, dunno about you
14:21:21 <tibbe> dons: would you have time to try to help me figure out the last part of my parser library?
14:21:23 <dons> conal: in fact, he said "Data.Time.* is gnarly for non-time buffs"
14:21:26 <radetsky> I also tried -fasm and nothing, and none of those worked
14:21:44 <dons> tibbe: hmm, not right now, but i can take a look later
14:21:50 <tibbe> dons: sure, thanks
14:22:00 <conal> dons: glad to know.  thx.
14:22:19 <dons> i mostly use the UTC stuff in the time package
14:22:27 <tibbe> anyone have experience of writing backtracking using continuations?
14:22:35 <gwern> tibbe: this is not the end, or the middle, but the end of the beginning?
14:22:37 <gwern> radetsky: -fasm has never worked with ncurses stuff as far as I can see. every package I've looked at which has a ncurses binding always tucks in a -fvia-C somewhere
14:22:37 <gwern> radetsky: ok, so you just pulled a fresh repo from  #-}
14:22:38 <conal> dons: btw, is sigbjorn still in portland?  i emailed him recently with no reply.
14:22:53 <tibbe> gwern: ummmm, yeah ;)
14:22:55 <gwern> er.
14:23:01 <gwern> http://www.informatik.uni-freiburg.de/~wehr/darcs/hscurses , it's building fine with -fvia-c up to the link phase
14:23:05 <gwern> and then it errors
14:23:07 <dons> conal: yeah, he was in Norway for 6 months or so, but is back at Galois now. sitting next to me in fact
14:23:28 <conal> oh!  please say hi for me! :)  i'll try him again.
14:23:28 <radetsky> I'm using ubuntu with ncurses 5.5
14:23:34 <radetsky> fyi
14:23:48 <dons> conal: will do :)
14:23:59 <conal> :)
14:24:15 <radetsky> this is really annoying because I wanted to experiment with ways to fix the "writing off the screen causes instant application death", and I thought I had a pretty good idea, but now I can't even test it
14:24:25 <gwern> radetsky: well, besides pulling a fresh repo and trying again, I can only advise updating your ncurses
14:24:42 <radetsky> why would I need a fresh repo?
14:25:18 <gwern> radetsky: I've found in the past sometimes errors were caused by missing or corrupt files or odd local editrs or bad builds haning around from clean
14:25:30 <gwern> and the easiest way around was just a fresh repo
14:26:34 <radetsky> so you're using ncurses 5.6?
14:26:35 <dogbite> what's the best introduction to quickcheck?
14:26:54 <gwern> radetsky: since that's what is installed, yes
14:27:04 <grahamhutton> @users
14:27:04 <lambdabot> Maximum users seen in #haskell: 463, currently: 441 (95.2%), active: 17 (3.9%)
14:27:07 <dons> this is awsome. protein visualisation for haskell, http://vizdata.renci.org/projects/jeff/ProteinViz/ProteinViz.png
14:27:18 <dons> "primarily runs on our 14 foot by 9 foot (4.5x3 metres for those of us in metric) linux display wall.  The full program is about 800 linux of Haskell code using nothing but the standard library under GHC 6.8.
14:27:22 <dons> "
14:27:33 <radetsky> I just doubt that there's that much difference
14:27:42 <dons> heya grahamhutton
14:27:50 <gwern> dons: I've asked him about a release; he says he's thinking about it once his professor is done with it
14:27:51 <grahamhutton> hi don!
14:28:13 <dons> gwern: yeah, looks stunning
14:28:31 <gwern> (strangely, he wondered whether I was asking because I needed it for something :)
14:29:15 <roconnor> dons: how is the image generated?
14:29:19 <heatsink> I don't know.  I'd imagine even one linux would be a lot of haskell code.
14:30:19 <dons> roconnor: http://article.gmane.org/gmane.comp.lang.haskell.cafe/37328
14:30:21 <lambdabot> Title: Gmane -- Mail To News And Back Again
14:30:36 <dons> so i think the haskell stuff must be doing the translation from raw data to some funky output format
14:31:00 <gwern> '(the clustering technique uses a metric I'm unfamiliar with, and I got the dataset pre-packaged from the guy who's using it). '
14:31:10 <dons> i guess visualisation fits well into the "all software is either a compiler or an interpreter" model :)
14:31:34 <roconnor> what image library would you use to generate such an image?  cairo?
14:32:42 <dons> yeah. but perhaps that's actually input to a visualisation tool (like .dot format)
14:33:18 <gwern> 800 lines sounds like enough for it to be spitting out images by itself
14:33:36 <roconnor> dons: .dot doesn't strike me as fully interactive.
14:35:06 <MyCatVerbs> dons: that's a bit... inflexible. Who's to say there can't be midpoints between the two? :)
14:35:33 <dons> well, i'm just suggesting that there could be a tool he's targetting
14:35:40 <lekro> roconnor: such a detailed image would take a while to render (probably >100ms) on my iBook if it's cairo. Cairo is not bad but some implementations are real slow
14:36:01 <sclv_> ooh.. I got it working with a little trickery .. a join prefacing the whole thing and kapow!
14:36:24 <roconnor> lekro: Cairo should be re-implemented in Haskell :D
14:37:38 <MyCatVerbs> roconnor: using HOpenGL for ricer-grade speed, naturally.
14:37:55 <SamB> what was wrong with glitz?
14:38:15 <roconnor> MyCatVerbs: I could use HOpenGL to do that? .... Hmm, I guess i can believe taht.
14:38:47 <MyCatVerbs> roconnor: AFAIK there are already Cairo implementations that're OpenGL-accelerated, though.
14:38:50 <lekro> roconnor: be sure to enable anti-aliasing if you use HOpenGL for something like this
14:40:55 <MyCatVerbs> lekro: AFAIK that was kind of the point - OpenGL draws nice antialiased splines *much* faster than the CPU does.
14:41:48 <MyCatVerbs> lekro: I mean, look at Macromedia Flash. Yeeeeow, that's a nice way to turn an eight-thousand-MIPS machine into a slideshow. x_x
14:42:17 <roconnor> could I use OpenGL to render pretty text easily?
14:42:51 <siti> not easily
14:42:56 <siti> you need to use some lib
14:43:12 <siti> a common hack is to use bitmap fonts but the result is really ugly
14:44:19 <dons> another haskell company... http://antiope.com/downloads.html
14:44:20 <lambdabot> Title: Antiope Associates Software Downloads
14:45:18 <lekro> MyCatVerbs: yes, I experienced that. I rendered an image with Cairo and HOpenGL (with AA). OpenGL was probably 10 times faster and it only looked a little bit worse than the cairo result. obviously they don't have OpenGL-accelerated cairo on Mac OS X yet (or it's something else)
14:48:11 <lekro> roconnor: the easiest way is something like  renderString Helvetica18 "Hello world"  which is from GLUT. but that's not too pretty, it's just simple and it works.
14:48:36 <MyCatVerbs> roconnor: AFAIK the situation with text rendering in OpenGL is relatively grim. >_>
14:48:56 <MyCatVerbs> roconnor: in that apparently no one writing OpenGL libraries really tackles it head-on.
14:49:02 <roconnor> lekro: cool. Can I easily figure out how big that text is, where the baseline is, etc?
14:49:34 <gwern> hm. is  prof2dot on hackage yet? the license looks good
14:50:09 <dons> gwern: yeah, on hackage already
14:50:50 <lekro> roconnor: there is stringWidth in GLUT. there is also fontHeight but that only works with freeglut. it's a real primitive method for rendering text
14:51:11 <gwern> ah, there we go: 'prof2dot [0.3.1] Convert GHC profiles into GraphViz's dot format'
14:51:23 <roconnor> I want to make Epigram pretty.
14:51:38 <roconnor> and free it from ascii art
14:52:13 <MyCatVerbs> roconnor: if I understand the situation correctly, more or less every commercial videogame on the planet for the last ten years has implemented its own text-rendering from scratch.
14:52:55 <MyCatVerbs> roconnor: (excepting of course people who license, say, Quake or Unreal and build games on top of them.)
14:52:57 <Peaker> Hi, where can I read about competing implementations of Haskell, interpreters/compilers/etc?
14:53:16 <oerjan> haskell.org
14:54:30 <dons> ghc is the main industrial implementation
14:54:34 <Peaker> About GHC: "and supports concurrent and (recently) parallel programming." <- what's the difference?
14:54:38 <gwern> Peaker: you want the nutshell? 'use Hugs if you're on windows; use GHC everywhere else; YHC is good for crazy stuff like compiling haskell to javascript; JHC is for masochistic performance freaks; and only people into standards or embedded stuff use NHC'
14:55:12 <radix> gwern: hmm, why hugs on windows, does ghc suck there?
14:55:16 <dons> Peaker: concurrent v parallel?
14:55:21 <Peaker> dons, Yeah
14:55:25 <dons> Peaker: concurrency is a structuring mechanism
14:55:34 <dons> parallelism means things actually running in parallel
14:55:53 <dons> that's also why you'd want ghc -- it supports multicore parallelism transparently
14:56:00 <gwern> radix: well, it doesn't work as well as it could, although I think GHC has made a lot of progress re: hugs in the last few years; that or hugs is dropping behind. a compiler is a lot of work
14:56:03 <roconnor> threads in concurrecy often run one at a time.
14:56:07 <Peaker> dons: But concurrency implies chronological ordering, which I understand is supposed to be meaningless in a functional language (bar the side effects)
14:56:20 <dons> hmm? no.
14:56:25 <dons> see here: http://www.haskell.org/ghc/dist/current/docs/users_guide/lang-parallel.html
14:56:27 <lambdabot> Title: 8.17. Concurrent and Parallel Haskell, http://tinyurl.com/zqwkf
14:56:29 <radix> gwern: I do hope if I ever actually start using haskell for real applications that I can use the same implementation everywhere
14:56:50 <radix> (and ghc seems to be the one I want to use :)
14:56:56 <dons> Peaker: pure code can be parallelised easily though
14:57:04 <dons> since the order of evaluation is very flexible
14:57:07 <conal> Peaker: maybe meaningless in functional programming, but not in imperative programming in a functional language.
14:57:16 <Peaker> conal, I see
14:57:27 <gwern> radix: in that case, I'd use ghc on windows, and be sure to take notes for filing bug reports
14:57:36 <radix> gwern: ok :)
14:59:24 <gwern> radix: part of the reason windows support may not be ideal is simply because people don't use it much, y'know?
14:59:25 <gwern> not that I can talk, I'm on Linux after all
14:59:35 <radix> gwern: indeed, I never use it
15:00:19 <radix> gwern: does ghc have a continuous integration system?
15:00:38 <radix> it might be good to set up something that will automatically run the test suite on Windows.
15:00:56 <Nafai> Sounds like radix is volunteering to set up buildbot for ghc
15:01:21 <gwern> radix: it has build bots yes (or at least I thought it did). windows? dunno
15:01:22 <radix> I might set up the *master* and maybe an Ubuntu slave, but I don't think I'll do a Windows slave :)
15:01:43 <radix> gwern: oh cool, I'll try to find the URL
15:01:56 <quicksilver> there are windows buildbots.
15:01:59 <radix> woot
15:02:04 <radix> are they green? :)
15:02:24 <radix> found it
15:02:26 <radix> thanks
15:03:35 <radix> looks like they're having trouble checking out
15:07:14 <monochrom> Hrm, two benefits of non-strictness + immutability to parallelization.  Immutability implies flexible evaluation order, up to data dependency. (We already know this.)  Non-strictness further removes false data dependency, e.g., when you call "const x y", strictness implies x and y must be both evaluated first because "syntactically const x y depends on both x and y", but non-strictness says correctly that the dependency on x
15:07:14 <monochrom> is false.
15:07:18 <tibbe> is it a bad idea to have my cabal package expose a Control.Applicative module in case the users base library doesn't have it?
15:07:24 <tibbe> or wait, maybe it's on hackage
15:08:13 <tibbe> it isn't, it should be
15:09:05 <tibbe> @seen conal
15:09:05 <lambdabot> conal is in #haskell and #ghc. I last heard conal speak 11m 58s ago.
15:09:07 * oerjan thought Control.Applicative was bundled with everything
15:09:08 <monochrom> Control.Applicative is in base.
15:09:16 <tibbe> monochrom: since what version?
15:09:38 <tibbe> 3.0 right?
15:09:51 <monochrom> Sorry, I don't know the history.
15:10:04 <tibbe> so ghc 6.6 and 6.4 users need a compatibility package
15:10:07 <tibbe> conal: ping
15:10:29 <monochrom> They can install a new base.
15:11:08 <Peaker> what is the advantage of pattern matching over a simple conditional?
15:11:44 <tibbe> monochrom: oh? didn't know that that is possible
15:11:58 <tibbe> monochrom: are you sure? thought it contained very ghc specific things
15:12:02 <cjb> Peaker: just clarity.
15:12:14 <cjb> Peaker: when you have many conditions, the pattern matching style makes your code very elegant.
15:12:20 <Peaker> cjb, ok, thanks
15:12:51 <monochrom> IMO this is no difference from: a certain package adds a new feature in a new version.  If users want that new feature, they should fetch that new package version, *not* ask for the new feature to be separated out.
15:13:58 <brs> Hi all, I have a question about hat. Is this the right place to ask?
15:15:33 <Heffalump> it's the best place to ask that I know of (on IRC)
15:15:43 <Heffalump> whether you'll get an answer is a different matter, I don't think it's used much
15:17:10 <brs> It's just the only tool I could ever get to work that shows me what reductions my code carries out.
15:17:52 <brs> I seem to have an infinite loop in a parsec 3 parser somewhere, which I can't find.
15:18:04 <brs> CPU load goes up to near 100% and stays there for minute.
15:18:26 <brs> That can't be normal if the string i'm trying to parse is just "(1 2 3)"
15:18:48 <oerjan> perhaps you have a left recursion...
15:19:21 <brs> AFAICT the grammar has none (it's just S-Expressions), and I can't find any.
15:19:43 <oerjan> @paste
15:19:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:19:53 * Heffalump has used the ghci debugger to find infinite loops on a few occasions
15:19:57 <Heffalump> otherwise profiling
15:20:07 <brs> I tried that, but my mind boggled.
15:20:22 <Heffalump> with the ghci debugger, :set -fbreak-on-exceptions, and :trace main, then ^C and use :history
15:20:40 <brs> Ah. I didn't know that. Will try.
15:21:05 <Heffalump> it may not be helpful, but it might be; the history is an evaluation history rather than a stack trace.
15:21:23 <Heffalump> and is limited to 50 elements
15:22:48 <dogbite> Can somebody give me an example of a simple QuickCheck generator that would do something like
15:23:03 <dogbite> generate numbers between a specific range
15:23:14 <dogbite> I'm having trouble understanding generators
15:23:20 <dogbite> i wish the manual had an example
15:24:59 <SamB> @pl sequence . map f
15:25:00 <lambdabot> sequence . map f
15:25:17 <oerjan> mapM
15:25:28 <SamB> @type sequence . map f
15:25:29 <lambdabot> forall (m :: * -> *) a a1. (SimpleReflect.FromExpr (m a), Show a1, Monad m) => [a1] -> m [a]
15:25:32 <SamB> @type sequence . map ?f
15:25:33 <lambdabot> forall (m :: * -> *) a a1. (?f::a1 -> m a, Monad m) => [a1] -> m [a]
15:28:01 <oerjan> :t Test.QuickCheck.choose
15:28:02 <lambdabot> forall a. (Random a) => (a, a) -> Gen a
15:28:11 <oerjan> dogbite: ^^
15:28:58 <dogbite> oerjan: thank you!
15:32:59 <Peaker_> cjb, before you said pattern matching just aids clarity.. can conditionals test if something is of a certain type? It seems to be a difference between pattern matching and conditionals, isn't it?
15:34:17 <Heffalump> no, they can't test on types, except in certain non Haskell 98 circumstances that would also apply to pattern matching.
15:34:30 <Heffalump> types are erased at runtime
15:34:31 <brs> Heffalump: Thanks for your help, it turns out that I was just a little dense, and parseInt = liftM read (many digits) is not so great after all...
15:34:34 <cjb> Peaker_: it's a good question, I didn't know the answer :)
15:35:05 <oerjan> brs: many1
15:35:10 <Peaker_> Heffalump, do you remember the Leaf/Branch->Tree example and the fringe function in the tutorial?
15:35:14 <brs> yeah, I just corrected it and it runs now.
15:35:34 <Cfr> hi
15:35:36 <Peaker_> Heffalump, the fringe function cannot be implemented with a conditional, only with pattern matching, that way, right?
15:35:36 <brs> D'oh. That has haunted me for about six hours.
15:35:44 <brs> Anyway, thanks everybody. It seems to work now.
15:39:31 <Heffalump> Peaker_: I have no idea what tutorial you mean and I doubt I have ever read it to remember :-)
15:39:43 <Peaker_> Heffalump, http://www.haskell.org/tutorial/goodies.html
15:39:43 <lambdabot> Title: A Gentle Introduction to Haskell: Values and Types
15:39:47 <Heffalump> ultimately, selecting between constructors always requires pattern matching.
15:39:56 <Heffalump> But you can hide that behind functions and use those via conditionals.
15:41:13 <Heffalump> right, so fringe could have been defined using isLeaf and isBranch boolean functions together with leftBranch and rightBranch accessor functions. But those would have to have been defined with pattern matching.
15:41:21 <Peaker_> Heffalump, I see.  I was just always wondering what pattern matching was about - and why expose both that and conditionals
15:41:33 <Heffalump> So in a sense pattern matching is more fundamental. But conditionals are more flexible in many cases.
15:42:23 <Peaker_> Would Haskell be essentially different if it allowed a conditional expression to test which constructor it is, and did not have pattern matching?
15:42:40 <Heffalump> well, it'd be a lot less nice to write a lot of things :-)
15:42:44 <Heffalump> but not in any essential way
15:42:53 <idnar> the generic "function" form of pattern matching would be a fold, I guess
15:42:54 <Peaker_> ok, greatly helped my understand, thanks
15:43:03 <Peaker_> my understanding, that is :)
15:49:13 <Peaker_> "For (e1,e2,...,en), n>=2, if ti is the type of ei, then the type of the tuple is (t1,t2,...,tn)." <- can't tuples be 0 or 1 elements long?
15:49:50 <Toxaris> Peaker_: no, they can't. you can view () :: () as a nullary tuple, but (Int) = Int, so there are no unary tuples
15:49:51 <tromp> :t ()
15:49:52 <lambdabot> ()
15:50:32 <tromp> in other words, everything is a unary tuple:)
15:50:36 <Peaker> Toxaris, that's a little weird, doesn't it make generalizing for N-sized tuples more difficult, or is that generalizing impossible ni general?
15:50:47 <Heffalump> it does turn out to be kind of annoying
15:50:59 <Peaker> Heffalump, in which cases?
15:51:00 <Heffalump> but since you can't actually overload on tuple length very easily, not all that annoying.
15:51:29 <Toxaris> Peaker: such generalizing is not normally used, but possible via type classes
15:51:35 <Heffalump> well, at work, we have some stuff that does apply to arbitrary tuple lengths, and we end up with a One type to handle one-tuples.
15:51:41 <Heffalump> which is ugly and confusing for our users.
15:52:11 <Peaker> Is there a good reason not to distinguish (x,) from x?
15:52:34 <tromp> :t \x -> (x,)
15:52:35 <lambdabot> parse error on input `)'
15:52:44 <Heffalump> (x,) would be a sectioned operator if it was legal to section the , operator like that.
15:52:50 <Peaker> lambdabot, I'm borrowing from Python's 1-tuple syntax :)
15:52:50 <Toxaris> (x,) looks like a section for me, e.g. equivalent to (,) x
15:52:59 <Heffalump> (which it isn't)
15:53:24 <Peaker> It sounds to me like a syntatical issue became a semantic issue
15:53:35 <Heffalump> arguably, yes.
15:53:47 <Peaker> :(
15:54:04 <Heffalump> in retrospect, the application I'm talking about that is a bit messed up by one tuples would have been better implemented using chains of pairs
15:54:17 <Heffalump> so (), (a, ()), (a, (b, ()), (a, (b, (c, ())) etc.
15:54:22 <Heffalump> Makes the overloading much easier too.
15:55:00 <tromp> basically, HLists
15:55:05 <Peaker> Can always artifically add a nullary thingie or two to the tuple to increase its length by 2 :-)
15:55:08 <Toxaris> maybe tuples should be syntactic sugar for nested pairs. if you want the exact strictness behaviour of tuples, you can always define a custom datatype
15:55:40 <Peaker> tromp, Are HLists hetero-lists?
15:55:43 <tromp> yes
15:55:45 <Heffalump> yes
15:55:48 <ptolomy2> Is there a known performance penalty for using GHC overloaded string literals?
15:56:02 <Peaker> Funny way to call them, "H" being quite ambiguous here :)
15:56:19 <Heffalump> ptolomy2: in the case that the types get resolved close to the site of the literal?
15:56:42 <Heffalump> if so I'd expect the inliner to remove any penalty; otherwise there'd be the usual dictionary passing cost, but I wouldn't expect it to be large.
15:56:53 <sclv> heterogeneous lists actually. hetero is ambiguous too. :-)
15:57:37 <Peaker> sclv, :)
15:58:46 <ikeda> :t (Integer)
15:58:47 <lambdabot> Not in scope: data constructor `Integer'
15:58:55 <Peaker> I read the Haskell tutorial loong ago, and reading it now, it all seems much clearer and more intuitive.  Maybe recollecting is easier than learning :)
15:59:11 <ptolomy2> My code is just so very inner loopish (interpreter) that even minor changes seem to measurably but unpredictably impact the performance.. I just started using overloaded strings to avoid putting "pack" here and there, and the result seems to be a small performance hit, which is not what I expected.
15:59:19 * ptolomy2 goes off to make sure his types are resolved nicely closely.
15:59:42 <Heffalump> if you really care, you need to inspect the core
15:59:57 <Heffalump> which I have only passing familiarity with doing
15:59:57 <ikeda> :t (Int)
15:59:58 <lambdabot> Not in scope: data constructor `Int'
16:00:44 <Peaker> how can HLists work in Haskell, if type information is discarded at runtime?
16:00:55 <Toxaris> ikeda: Integer and Int are types themself, but the :t command gives you the type of a value.
16:00:59 <Peaker> How does Haskell code know which type the elements are?
16:01:02 <Toxaris> :t 3
16:01:03 <lambdabot> forall t. (Num t) => t
16:01:11 <Toxaris> :t (3 :: Int)
16:01:12 <lambdabot> Int
16:01:46 <ikeda> ok thanks tox
16:01:48 <Toxaris> Peaker: type information is discarded, but dictionaries aren't
16:02:32 <Peaker> Toxaris, Is this covered by haskell.org's tutorial?
16:02:33 <ikeda> :t (3)
16:02:33 <lambdabot> forall t. (Num t) => t
16:02:47 <Heffalump> type classes are one exception to the discarding of type information at runtime; existential types and dynamics (both non-H98) are another.
16:02:51 <Toxaris> Peaker: I have no idea
16:02:56 <Heffalump> I doubt it.
16:03:32 * ptolomy2 is getting a bit too big for his britches in terms of optimization.. 
16:03:43 <Heffalump> The thing about type classes is that, except for polymorphic recursion, you *could* discard the type information by doing really aggressive inlining.
16:03:45 <Peaker> how come hugs rejects "type Name = String" (taken from the tutorial)
16:04:00 <Heffalump> because you can't do as much at an interactive prompt as you can in .hs/.lhs files
16:04:22 <Heffalump> ghci allows value declarations but not type declarations, and hugs doesn't allow anything except expressions
16:05:19 <Peaker> ok
16:05:37 <Gebb> Why is the replace function defined in Network.CGI.Protocol? (And not in Data.List or something.)
16:05:53 <tromp> Lists are immutable
16:06:02 <skorpan> Gebb: doing the replay lab?
16:07:27 <Peaker> tromp, is anything mutable?
16:07:33 <Toxaris> Gebb: because replace is at the same time easy to define (have a look at it's source, it's only one simple line), and normally not what you really want (bad time complexity)
16:07:36 <Gebb> skorpan: No, someone asked if there was a function to convert "aa.bb.cc" to "cc.bb.aa".
16:07:38 <tromp> you cld write a replace giving a new list
16:09:54 <Toxaris> > reverse "aa.bb.cc"
16:09:54 <lambdabot>  "cc.bb.aa"
16:10:13 <Toxaris> Gebb: ;)
16:10:53 <Gebb> Toxaris: I see. Thanks. It's linear complexity, right? Is there a better approach?
16:10:53 <Gebb> btw, it should also do "ab.cd.ef" -> "ef.ab.cd".
16:11:28 <Gebb> Er... "ab.cd.ef" -> "ef.cd.ab"
16:12:10 <tromp> like \(a:b:c:d:e:f:g:h:[]) -> (g:h:c:d:e:f:a:b:[]) ?
16:13:11 <monochrom> Write a function mysplit with: mysplit "ab.cd.ef" = ["ab", "cd", "ef"].  Then I can do the rest.
16:13:13 <Gebb> tromp: a more general function. Like reversing the word order in a domain name. I came up with
16:13:13 <Gebb> let re = Network.CGI.Protocol.replace in (re ' ' '.').unwords.reverse.words.(re '.' ' ') $ "as.df.gh"
16:14:20 <Toxaris> Gebb: hehe nice work-around
16:14:20 <tromp> is there no generalization of words that allows you to specify delimeter?
16:14:26 <Gebb> (Didn't want to write my own wordsBy.)
16:14:28 <Toxaris> unfortunately not :(
16:14:59 <Toxaris> but wordsBy would have been less hackish in my eyes
16:15:12 <Toxaris> just copy the code of words :)
16:15:31 <Toxaris> alternatively, use Data.ByteString.Char8.split
16:16:54 <lament> in python, '.'.join(reversed(s.split('.')))
16:17:27 <Gebb> Well, the purpose was to write a short piece of code, not an eficient one.
16:17:32 <ptolomy2> It seems strange to me that my program spends a good portion of its time in 'readIORef'..
16:17:48 <lament> you could use python bindings to run that python code :)
16:18:42 <Toxaris> i don't think there is any good reason for the inexistence of wordsBy or split, only the imho bad reason that people can't agree what exactly it should mean
16:18:58 <dons> Igloo: can you translate this for me? http://buildd.debian.org/pkg.cgi?pkg=xmonad
16:19:03 <lambdabot> Title: buildd.debian.org: xmonad in the unstable wanna-build databases
16:19:09 <dons> are we looking at a possible 8 architectures with xmonad on it ? :)
16:20:37 <Igloo> dons: It's built on 4 arches, 2 will try to build it soon, and 7 are waiting until a build-dependency of it has been built first
16:20:37 <lambdabot> Igloo: You have 1 new message. '/msg lambdabot @messages' to read it.
16:20:44 <lament> Toxaris: i think it's actually really dumb, because there's TWO functions, words and lines, where only one is needed
16:20:55 <lament> and neither function does what you want
16:21:01 <Igloo> dons: Where did you get 8 from?
16:21:31 <lament> and having functions 'unwords' and 'unlines' is just inexcusable :)
16:21:48 <idnar> :t unwords
16:21:49 <lambdabot> [String] -> String
16:21:54 <Igloo> dons: What's the deal with Xinerama, BTW?
16:21:56 <idnar> oh, join
16:22:14 <Toxaris> lament: what about unBy :: a -> [[a]] -> [a]? ;)
16:22:31 <lament> Toxaris: i would call it join
16:22:33 <dons> Igloo: the deal with Xinerama?
16:22:34 <lament> joinBy
16:23:07 <lament> not join :)
16:23:14 <dons> Igloo: so re. xinerama, xmonad will just default to non-xinerama if the isXineramaEnabled check fails
16:23:17 <kpreid> lament: actually, unwords/unlines and words/lines differ in their handling of trailing seps, iirc
16:23:23 <kpreid> > unlines ["foo"]
16:23:23 <lambdabot>  "foo\n"
16:23:27 <kpreid> > unwords ["foo"]
16:23:28 <lambdabot>  "foo"
16:23:36 <kpreid> > lines "foo\nbar\n"
16:23:37 <lambdabot>  ["foo","bar"]
16:23:39 <idnar> lambdabot: concatBy? :P
16:23:41 <idnar> err
16:23:42 <dons> but that does assume libXinerama is available, if if the user doesn't actually use it -- which should be fine(?)
16:23:43 <idnar> lament: ^^
16:23:45 <kpreid> > words "foo bar "
16:23:45 <lambdabot>  ["foo","bar"]
16:24:01 <Toxaris> > unlines "empty\n\nlines\n\nincluded"
16:24:02 <lambdabot>  Couldn't match expected type `String' against inferred type `Char'
16:24:05 <tromp> > lines "foo\nbar"
16:24:06 <lambdabot>  ["foo","bar"]
16:24:08 <Igloo> dons: http://urchin.earth.li/pipermail/debian-haskell/2008-March/000383.html (was CCed to you)
16:24:12 <Toxaris> > lines "empty\n\nlines\n\nincluded"
16:24:12 <lambdabot>  ["empty","","lines","","included"]
16:24:16 <tromp> > lines "foo\nbar\n\n"
16:24:17 <lambdabot>  ["foo","bar",""]
16:24:18 <dons> Igloo: right, but I'm not sure what I'm being asked to do
16:24:25 <Toxaris> > words "empty      words not included"
16:24:26 <lambdabot>  ["empty","words","not","included"]
16:25:06 <Igloo> dons: Can't the xinerama stuff be moved into its own package? And if xmonad doesn't actually need it then it can conditionally depend on it with a flag
16:25:23 <dons> right. so our X11 lib uses defaults if xinerama isn't available
16:25:50 <lament> > intercalate "." ["haskell", "org"]
16:25:50 <lambdabot>  "haskell.org"
16:26:08 <dons> xmonad doesn't depend on x11-with-xinerama
16:26:17 <idnar> oh, of course
16:26:18 <dons> it depends on haskell-x11, which works with or without xinerama
16:26:57 <Igloo> dons: Ah, I see. OK, maybe that makes sense, then
16:27:53 <dons> when you build the haskell-x11 package, it checks if xinerama's available, if not, defaults are set.
16:28:13 <dons> i guess it works, since no other distros have issues here either
16:28:43 <Igloo> Right, I just hand't looked closely enough to see that you always export all the same things even if you don't have Xinerama
16:28:53 <dons> ah right. yes, we do.
16:29:17 <dons> #else
16:29:17 <dons> -- No Xinerama, but if we fake a non-active Xinerama interface, "getScreenInfo"
16:29:17 <dons> -- will continue to work fine in the single-screen case.
16:29:17 <dons> compiledWithXinerama :: Bool
16:29:17 <dons> compiledWithXinerama = False
16:29:20 <dons> xineramaIsActive :: Display -> IO Bool
16:29:22 <dons> xineramaIsActive _ = return False
16:29:25 <dons> et al
16:33:32 <dons> Igloo: btw, do we need libffi to build ghc these days?
16:33:40 <dons> ../utils/hsc2hs/hsc2hs-inplace -I.    -L/usr/local/lib -I/usr/local/include ghci/LibFFI.hsc
16:33:43 <dons> /usr/local/lib: file not recognized: File truncated
16:33:46 <dons> collect2: ld returned 1 exit status
16:33:48 <dons> linking ghci/LibFFI_hsc_make.o failed
16:33:51 <dons> command was: gcc /usr/local/lib ghci/LibFFI_hsc_make.o -o ghci/LibFFI_hsc_make
16:34:05 <Igloo> dons: It can be used, but I don't think it's necessary
16:34:25 <dons> i wonder why my build is failing
16:34:35 <dons> ah  i see
16:34:42 <dons> gcc /usr/local/lib
16:35:22 <dons> something fishy
16:41:03 <gwern> > let 1s = [1..]::[Int] in map (1+) 1s
16:41:03 <lambdabot>  Parse error in pattern at "in" (column 23)
17:05:10 <gwern> @seen SamB
17:05:10 <lambdabot> SamB is in #darcs, #perl6 and #haskell. I last heard SamB speak 1h 39m 38s ago.
17:07:31 <gwern> @tell SamB my patches to conjure are getting held for moderation because of size
17:07:31 <lambdabot> Consider it noted.
17:08:01 <Peaker> does that wait for SamB to say something and then tells him?
17:09:53 <gwern> Peaker: precisely
17:09:59 <Peaker> cool feature
17:10:14 <gwern> or rather, it tells him it has a message forhim, and if SamB msg's it, it'll reply back with the message
17:10:16 <dons> > map (^2) [1..]
17:10:17 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
17:10:19 <dons> also cool
17:10:23 <dons> :t map
17:10:24 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:10:30 <dons> ?hoogle (a -> b) -> [a] -> [b]
17:10:31 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
17:10:31 <lambdabot> Data.List.map :: (a -> b) -> [a] -> [b]
17:10:31 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
17:13:57 <dons> gwern: these kzm bioinfo projects are great
17:16:12 <gwern> dons: there's a lot of them
17:16:13 <gwern> I've still got 5 to go
17:16:17 * gwern always wonders why people like ketil don't just sned something to haskell-cafe to tell the rest of us about all this stuff of theirs
17:16:24 <gwern> @seen ketil
17:16:24 <lambdabot> I saw ketil leaving #haskell 3h 53m 41s ago, and .
17:20:53 <gwern> @hoogle Random
17:20:53 <lambdabot> System.Random :: module
17:20:53 <lambdabot> System.Random.Random :: class Random a
17:20:53 <lambdabot> System.Random.random :: (Random a, RandomGen g) => g -> (a, g)
17:22:34 <Peaker> how do I install "Cabal" packages (or generally packages from hackage.haskell.org) on an Ubuntu system?
17:23:35 <dons> simply, you download the .tar.gz , unpack it, then run: runhaskell Setup.lhs configure;  runhaskell Setup.lhs build;  runhaskell Setup.lhs install
17:23:43 <dons> this can also be automated, by using the cabal-install tool
17:23:43 <dino-> Peaker: The typical cabal way should work with those. I mean Setup.lhs configure ; ... yeah what he said.
17:24:03 <dons> http://www.haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package
17:24:04 <lambdabot> Title: Cabal/How to install a Cabal package - HaskellWiki, http://tinyurl.com/2ack74
17:24:04 <Peaker> dons, what about the dependencies?
17:24:06 <dino-> Peaker: There's generally not an actual Debian .deb for these things, with some occasional exceptions.
17:24:24 <dons> Peaker: you do the same for dependencies first, or use cabal-install, which does that for you
17:24:38 <dons> well, for some distros there's lots of packages already (gentoo, arch)
17:24:52 <Peaker> dons, I was hoping for something like apt
17:24:54 <dino-> cabal-install is pretty exciting, it's like apt for Hackage projects
17:25:12 <Peaker> cool
17:26:02 <dons> cabal-install is like apt, yes.
17:26:36 <dons> $ cabal install xmonad, will resolve all deps, build them, download and build the app, install it
17:26:54 * radix imagines something that automatically converts all of hackage into a debian repository
17:26:57 <radix> that would be neat :)
17:27:23 <dons> they've a tool like that for gentoo, iirc
17:27:27 <dino-> radix: Hm. I wonder if all the relevant info is sitting there in the .cabal to make the debian/ dir with its control and yada. Could be.
17:28:05 <dino-> I've heard of this being done with gentoo + cpan
17:28:08 <dino-> too
17:32:11 <Peaker> does darcs have something like bzr's checkout or git's tracking branch?
17:33:46 <dons> darcs get ?
17:33:48 <gwern> CosmicRay has tools to convert cabal to debian, iirc
17:33:59 <dons> what are you seeking to do, Peaker ?
17:34:04 <gwern> @hoogle system
17:34:05 <lambdabot> System.Cmd.system :: String -> IO ExitCode
17:34:05 <lambdabot> Distribution.System :: module
17:34:05 <lambdabot> System.Cmd.rawSystem :: String -> [String] -> IO ExitCode
17:34:12 <Peaker> dons, does it have update/commit that do pull/push such that the local branch seems to be an active mirror?
17:34:22 <nornagon> if I have some IOUArray, and I read a value from it using readArray and then don't use that value, is the readArray thunk ever evaluated?
17:34:43 <dons> Peaker: its super simple. darcs pull  to keep a repo in sync
17:35:02 <dons> if you want to sync both ways, darcs pull ; darcs push. there's likely recipes on the net for automating this
17:35:33 <Peaker> dons, so it doesn't have shortcuts for the centralized "workflow"
17:37:06 <dons> so typically you'll have a shared central repository, which people push and pull to
17:37:43 <dons> but its a decentralised vcs, so every repo is first class, and you can push and pull between them. (i'm not sure exactly what you mean by "centralised workflow" though)
17:37:50 <Peaker> dons, but in darcs you probably have to commit to copy file system changes into the branch, don't you?
17:37:56 <tromp> nornagon: yes, i would think so
17:38:17 <dons> Peaker: well, there's no branch concept in darcs. every repo is its own branch
17:38:18 <nornagon> tromp: is there a way to get it to not be evaluated in that case? a lazy IO action?
17:38:58 <Peaker> dons, then s/branch/repo in my question :)
17:39:26 <dons> so, if you make local changes, you have to commit them, and push, to propagate to a central repo
17:39:27 <BMeph> Hey, everyone. :)
17:39:29 <tromp> not that i can see
17:39:34 <Peaker> dons, http://bazaar-vcs.org/LockStepDevelopment
17:39:37 <lambdabot> Title: LockStepDevelopment - Bazaar Version Control
17:39:53 <dino-> But I make 'branches' often by getting from what I already have to another loc.
17:40:03 <Peaker> dons, bzr has a UI feature on top of the DVCS to make the centralized workflow easier (good for having all commits backed up on a server immediately, for example)
17:40:12 <TomMD> Hello BMeph
17:40:26 <BMeph> :)
17:40:27 <dons> ah , so there are probably scripts for this. i've not used them
17:40:36 <dons> i imagine git also does. they're very similar
17:40:43 <Peaker> dons, (without having to explicitly push too). Its also good in letting multiple developers work on a branch without allowing diverging commits (if you want to have all merges occur immediately and not accumulate)
17:41:16 * heatsink 's two complaints with darcs are that it consumes too much memory for very large patches and that it's hard to synchronize repositories between computers that don't directly connect over the network.  (Unless there's a feature I don't know about.)
17:41:40 <dons> heatsink: how do they communicate? filesystem?
17:41:53 <dons> darcs send ?
17:42:57 <gwern> @hoogle (?)
17:43:00 <lambdabot> Did you mean: (?)
17:43:00 <lambdabot> Prelude.undefined :: a
17:43:00 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
17:43:15 <Peaker> damn downloading the cabal install darcs repo is taking ages
17:43:16 <gwern> @hoogle ?
17:43:16 <lambdabot> Text.ParserCombinators.Parsec.Prim.(<?>) :: GenParser tok st a -> String -> GenParser tok st a
17:43:16 <lambdabot> Text.ParserCombinators.Parsec.Perm.(<|?>) :: PermParser tok st (a -> b) -> (a, GenParser tok st a) -> PermParser tok st b
17:43:16 <lambdabot> Text.ParserCombinators.Parsec.Perm.(<$?>) :: (a -> b) -> (a, GenParser tok st a) -> PermParser tok st b
17:43:21 <heatsink> dons: There's a firewall here so I can't ssh directly from laptop to the computer that has the repository.  My cheap workaround is to create a temporary repository on the gateway, which is accessible from both places, then delete it when I'm done synchronizing.
17:43:58 <Excedrin> ssh -L # problem solved
17:45:15 <dino-> Excedrin: I have something kind of unholy set up like that too from work machine to home with -R
17:45:26 <Excedrin> does it use pppd?
17:45:26 <dino-> A tunnel punched through.
17:45:42 <heatsink> Excedrin: Can you make darcs ssh to a specific port?  Darcs invokes ssh so I can't directly pass options to ssh.
17:46:09 <swidgy> ssh -R is my second best friend ;)
17:46:24 <Excedrin> When using ssh, if the SSH_PORT environment variable is defined, darcs will use that port rather than the default ssh port (which is 22).
17:46:38 <heatsink> oh! Thanks.
17:46:47 <dino-> Oh wow, I didn't know that SSH_PORT
17:48:58 <gwern> @hoogle elementOf
17:48:59 <lambdabot> No matches found
17:50:17 <gwern> @hoogle elem
17:50:18 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
17:50:18 <lambdabot> Data.List.elem :: Eq a => a -> [a] -> Bool
17:50:18 <lambdabot> Data.Foldable.elem :: (Foldable t, Eq a) => a -> t a -> Bool
17:51:40 <gwern> @hoogle mkSet
17:51:40 <lambdabot> No matches found
17:51:59 <sm> Peaker: you could set up darcs push-on-commit with a posthook (see manual)
17:52:10 <gwern> @hoogle Ord a => [a] -> Set a
17:52:10 <lambdabot> Data.Set.fromList :: Ord a => [a] -> Set a
17:52:10 <lambdabot> Data.Set.fromDistinctAscList :: [a] -> Set a
17:52:10 <lambdabot> Data.Set.fromAscList :: Eq a => [a] -> Set a
17:52:50 <sm> which is actually something I've never heard of being done, and seems interesting
17:53:58 * sm thinks: darcs pull prehook, commit, darcs push posthook ?
17:54:28 <sm> and you've got.. cvs ?
17:54:42 <heatsink> hahaha
17:55:02 <dino-> Oh come on, better than cvs. First-class-dirs.
17:55:08 <sm> right!
17:55:18 <dino-> :P
17:55:25 <sm> and hunk cherry picking
17:55:43 <gwern> @pl addListToFM_C c = foldr (uncurry (Map.insertWith c))
17:55:43 <lambdabot> addListToFM_C = foldr . uncurry . Map.insertWith
17:58:09 <nornagon> can ghc cross-compile?
18:00:20 <dons> nope
18:02:25 <Cale> > map (length . takeWhile (/= 0) . iterate (ap (.&.) (subtract 1))) [0..30 :: Integer]
18:02:25 <lambdabot> Terminated
18:02:34 <nornagon> dons: ;(
18:02:55 <heatsink> You can bootstrap GHC on another system, which is a sort of self-cross-compilation.  http://hackage.haskell.org/trac/ghc/wiki/Building/Porting/
18:03:04 <lambdabot> Title: Building/Porting - GHC - Trac
18:03:11 <nornagon> i don't have a ppc machine around, but i want to build some ppc binaries
18:03:21 <Cale> @undefine
18:03:22 <lambdabot> Undefined.
18:03:23 <Cale> > map (length . takeWhile (/= 0) . iterate (ap (.&.) (subtract 1))) [0..30 :: Integer]
18:03:24 <lambdabot>  [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4]
18:03:53 <BMeph> Cale: fusc? ;)
18:04:04 <Cale> @oeis 0,1,1,2,1,2,2,3,1,2,2,3
18:04:05 <lambdabot> 1's-counting sequence: number of 1's in binary expansion of n (or the binary ...
18:04:05 <lambdabot> [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,...
18:04:09 <nornagon> Cale: number of bits set?
18:04:15 <nornagon> heh :)
18:04:48 <BMeph> Ah, repeated values. Should've seen than. :)
18:06:04 <Cale> > map (length . takeWhile (/= 0) . iterate (ap (.&.) (subtract 1))) (product [1..100])
18:06:04 <lambdabot>   add an instance declaration for (Num [a])
18:06:05 <lambdabot>     In the expression: 1
18:06:09 <Cale> > map (length . takeWhile (/= 0) . iterate (ap (.&.) (subtract 1))) (product [1..100] :: Integer)
18:06:09 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Integer'
18:06:13 <Cale> oh
18:06:21 <Cale> > length . takeWhile (/= 0) . iterate (ap (.&.) (subtract 1)) $ product [1..100] :: Integer
18:06:21 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Int'
18:06:26 <Cale> > length . takeWhile (/= 0) . iterate (ap (.&.) (subtract 1)) $ (product [1..100] :: Integer)
18:06:27 <lambdabot>  207
18:06:40 <Cale> > length . takeWhile (/= 0) . iterate (ap (.&.) (subtract 1)) $ (product [1..1000] :: Integer)
18:06:40 <lambdabot>  3788
18:07:58 * ac checks out xmonad
18:08:14 <Cale> > length . takeWhile (/= 0) . iterate (ap (.&.) (subtract 1)) $ (product [1..10000] :: Integer)
18:08:16 <lambdabot> Terminated
18:08:19 <ac> I like how a lot of the xmonad key bindings are very similar to what I've configured sawfish to
18:08:52 <Cale> cgibbard@haskell:~/darcs/lambdabot$ ./runplugs
18:08:52 <Cale> length . takeWhile (/= 0) . iterate (ap (.&.) (subtract 1)) $ (product [1..10000] :: Integer)
18:08:52 <Cale> Segmentation fault
18:09:05 <Cale> ...
18:09:20 <ac> I actually already had a mod-[1-6] to switch workspaces, and a mod-shift-[1-6] to move the current window to a different workspace
18:10:04 <tromp> u can also define that seq in terms of itself
18:10:27 <tromp> bitcnts :: [Int]
18:10:39 <nornagon> @src seq
18:10:39 <lambdabot> Source not found. Just try something else.
18:11:25 <tromp> bitcnts = alternate bitcnts (map (1+) bitcnts)
18:11:46 <tromp> just need to make sure it starts with 0
18:13:36 <Cale> @let interleave [] ys = ys; interleave xs [] = xs; interleave (x:xs) (y:ys) = x : y : interleave xs ys
18:13:36 <lambdabot> Defined.
18:14:01 <Cale> > let bs = 0 : interleave bs (map (1+) bs) in bs
18:14:02 <lambdabot>  [0,0,1,0,1,1,2,0,1,1,2,1,2,2,3,0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,0,1,1,2,1,2,2...
18:14:09 <Cale> hmm
18:14:17 <roconnor> ahh, the obviously terminating definitoin of interleave
18:14:24 <tromp> recurrence doesn't work for tail
18:14:29 <Saizan> > let bs = interleave (0:bs) (map (1+) bs) in bs
18:14:29 <lambdabot>  Exception: <<loop>>
18:14:49 <Saizan> that interleave is too strict!
18:15:20 <tromp> just skip case 2
18:15:30 <Cale> @undefine
18:15:30 <lambdabot> Undefined.
18:15:55 <Cale> @let interleave ~(x:xs) ~(y:ys) = x : y : interleave xs ys
18:15:55 <lambdabot> Defined.
18:16:03 <Cale> > let bs = interleave (0:bs) (map (1+) bs) in bs
18:16:04 <lambdabot>  [0,1,0,2,1,1,0,3,2,2,1,2,1,1,0,4,3,3,2,3,2,2,1,3,2,2,1,2,1,1,0,5,4,4,3,4,3,3...
18:16:09 <Cale> not quite :)
18:16:27 <roconnor> ahh, the obviously productive definition of interleave
18:16:40 <tromp> @let interleave (x:xs) ys = x : interleave ys xs
18:16:40 <lambdabot> <local>:1:0:     Warning: Pattern match(es) are overlapped              In th...
18:16:54 <Cale> @undefine
18:16:55 <lambdabot> Undefined.
18:17:07 <Cale> tromp: that would be incorrect anyway
18:17:36 <tromp> only needs to work for infinite lists
18:17:45 <Cale> @let interleave ~(x:xs) ~(y:ys) = x : y : interleave xs ys
18:17:46 <lambdabot> Defined.
18:17:50 <roconnor> Cale: why?
18:17:51 <Cale> Hence that version ;)
18:18:01 <Cale> roconnor: Just producing the first list?
18:18:07 <Saizan> > let bs = interleave (0:tail bs) (map (1+) bs) in bs
18:18:07 <lambdabot>  [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3...
18:18:18 <Saizan> Cale: in the recursive call the arguments are flipped
18:18:20 <Cale> There it is :)
18:18:24 <roconnor> Cale: no, the recursive call swaps xs and ys
18:18:32 <Cale> oh, I missed that
18:18:44 <roconnor> it is the standard definition of interleave :)
18:18:56 <MyCatVerbs> What exactly is the goal here?
18:19:10 <Cale> MyCatVerbs: The goal was Saizan's last line.
18:19:30 <roconnor> MyCatVerbs:  I believe the goal is @oeis 0,1,1,2,1,2,2,3,1,2,2,3
18:19:41 <MyCatVerbs> roconnor: ahhhh.
18:19:43 <MyCatVerbs> Cale: huh, fun.
18:20:04 <MyCatVerbs> ...what the Heck is it?
18:20:10 <Cale> @oeis 0,1,1,2,1,2,2,3,1,2,2,3
18:20:11 <lambdabot> 1's-counting sequence: number of 1's in binary expansion of n (or the binary ...
18:20:11 <lambdabot> [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3,...
18:20:29 <MyCatVerbs> Oh, awesome. map hammingweight [0..]
18:20:57 <Cale> > map (length . takeWhile (/= 0) . iterate (ap (.&.) (subtract 1))) [0 :: Integer ..]
18:20:58 <lambdabot>  [0,1,1,2,1,2,2,3,1,2,2,3,2,3,3,4,1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5,1,2,2,3,2,3...
18:21:14 <tromp> @oeis 1, 57, 12675, 24318165, 414295148741
18:21:14 <lambdabot> Number of legal position in Go played on an n X n grid (each group must have ...
18:21:14 <lambdabot> [1,57,12675,24318165,414295148741,62567386502084877,83677847847984287628595,9...
18:21:18 <nornagon> nhc98 has no IOUArray ;(
18:21:19 <Cale> (that computes each one separately of course:)
18:21:20 <tromp> :-)
18:21:43 <gwern> ;(? what is that, some sort of unhappy wink?
18:22:00 <nornagon> crying
18:22:11 <roconnor> ;( == :'(
18:22:16 <MyCatVerbs> > let as = map (length . takeWhile (/=0) . iterate (ap (.&.) (subtract 1))) [0 :: Integer ..] in let bs = interleave (0:tail bs) (map (1+) bs) in zipWith (-) as bs
18:22:17 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
18:22:22 <gwern> flow my tears upwards, said the policeman...
18:22:30 <nornagon> );
18:22:37 <tromp> hmm, what seq is that?
18:22:39 <Cale> tromp: Aw, they still don't know it for 19x19, but it's surprising how many terms are known.
18:22:43 <tromp> @oeis 0,0,0,0,0,0,0,0,
18:22:43 <gwern> ok, that makes more sense
18:22:44 <lambdabot> The characteristic function of 0: a(n) = 0^n.
18:22:44 <lambdabot> [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
18:22:50 <tromp> aha:)
18:22:54 <nornagon> heh
18:23:57 <Cale> 19079388919628199204605726181850465220151058338147922243967269231944059187214767997105992341735209230667288462179090073659712583262087437 is the number of valid 17x17 positions.
18:24:02 <Cale> So they're getting close :)
18:24:04 <nornagon> only that many?
18:24:05 <MyCatVerbs> @oeis 3,6,9,12,15
18:24:06 <lambdabot> a(n) = 3*n.
18:24:06 <lambdabot> [0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78...
18:24:17 <tromp> yes, we got close
18:24:20 <nornagon> @oeis 34612,78425687,1235
18:24:20 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
18:24:20 <MyCatVerbs> Ahhh, it does get the trivial ones too. Not just the interesting ones. ^_^
18:24:49 <Cale> MyCatVerbs: hm?
18:24:54 <nornagon> Aw, it doesn't know the famous "sequence produced when nornagon mashed his fingers on the keyboard just now"
18:25:41 <Cale> @oeis 3,4,6,12,78,425,687,1235
18:25:41 <lambdabot> Plugin `oeis' failed with: Prelude.init: empty list
18:25:54 <Cale> aww, that looked so much more likely.
18:26:05 <MyCatVerbs> Cale: since it does so well on the interesting sequences, I was wondering if perhaps they'd skimped on getting the trivial ones right, too.
18:26:19 <MyCatVerbs> @oeis 1,3,6,10,15
18:26:19 <lambdabot> Triangular numbers: a(n) = C(n+1,2) = n(n+1)/2 = 0+1+2+...+n.
18:26:20 <lambdabot> [0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,253,27...
18:27:14 <Socrates> > take 4 (scanl1 (+) [1,5..])
18:27:14 <lambdabot>  [1,6,15,28]
18:27:20 <Cale> They have quite a lot. The point of having the easy sequences in there is probably so that SuperSeeker works better.
18:27:25 <Socrates> @oeis 1, 6, 15, 28
18:27:25 <lambdabot> Hexagonal numbers: n(2n-1).
18:27:25 <lambdabot> [0,1,6,15,28,45,66,91,120,153,190,231,276,325,378,435,496,561,630,703,780,861...
18:27:41 <Socrates> > take 4 (scanl1 (+) [1,7..])
18:27:41 <lambdabot>  [1,8,21,40]
18:27:43 <MyCatVerbs> Cale: SuperSeeker?
18:27:48 <Socrates> @oeis 1, 8, 21, 40
18:27:48 <lambdabot> Octagonal numbers: n(3n-2). Also called star numbers.
18:27:48 <lambdabot> [0,1,8,21,40,65,96,133,176,225,280,341,408,481,560,645,736,833,936,1045,1160,...
18:28:00 <Cale> (Superseeker is a server which you send an email to, and it replies in a while with results of a more intensive search for your sequence)
18:28:09 <tromp> @oeis 2, 3, 5, 7, 23, 63
18:28:09 <lambdabot> Value for which b(a(n))=0 when b(2)=n and b(k+1) is calculated by writing b(k...
18:28:09 <lambdabot> [2,3,5,7,23,63,383,2047]
18:28:37 <MyCatVerbs> Cale: ahhhh. So a more in-depth version of the same?
18:28:45 <Cale> Yeah. It applies lots of compositions of standard transformations and checks to see if any of those occur in the database.
18:29:57 * MyCatVerbs vaguely wonders how much disk space these databases weigh in at.
18:30:07 <Socrates> Haha
18:30:09 <Socrates> @oeis 1, 11, 21, 1211
18:30:09 <lambdabot> Look and Say sequence: describe the previous term! (method A - initial term i...
18:30:09 <lambdabot> [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,13211311123113...
18:33:25 <Cale> @oeis 1, 1, 6, 168, 20160
18:33:26 <lambdabot> Number of nonsingular n X n matrices over GF(2) (order of Chevalley group A_n...
18:33:26 <lambdabot> [1,1,6,168,20160,9999360,20158709760,163849992929280,5348063769211699200,6996...
18:36:23 <gwern> phew. glad xsact was the only one of ketil's projects using FiniteMap
18:38:46 <gwern> 'Monad.StrackSet'
18:39:13 <dmwit> Looks like a bit of a typo there... =P
18:39:54 <gwern> dmwit: yeah. someone forgot it's 'XMonad', not 'Monad'
18:40:24 <hpaste>  MyCatVerbs pasted "Presumably someone with a working brain can write something better than this" at http://hpaste.org/6198
18:41:12 <gwern> isn't there a really short runlength encoding-based version of the look-and-say function?
18:42:15 <gwern> http://en.literateprograms.org/Look_and_say_sequence_(Haskell) <-- well, that's not too bad, but I think one could do better
18:42:17 <lambdabot> Title: Look and say sequence (Haskell - LiteratePrograms
18:42:19 <dmwit> > let lookn s = concatMap ((\(a, b) -> show a ++ [b]) . length &&& head) s
18:42:19 <lambdabot>  Parse error at end of input
18:42:25 <dmwit> > let lookn s = concatMap ((\(a, b) -> show a ++ [b]) . length &&& head) s in lookn "hey"
18:42:26 <lambdabot>  Couldn't match expected type `(t, Char)'
18:42:47 <hpaste>  MyCatVerbs annotated "Presumably someone with a working brain can write something better than this" with "The most obvious improvement is to get rid of the in-band sentinel value" at http://hpaste.org/6198#a1
18:42:56 <gwern> http://blog.mikael.johanssons.org/archive/2007/04/looksay-todays-haskell-snippet/ <-- ok, now that's much better
18:42:59 <lambdabot> Title: Michi&#8217;s blog » Blog Archive » looksay - today&#8217;s Haskell snippet, http://tinyurl.com/2fzw8c
18:43:00 <dmwit> > map (length &&& head) "hey"
18:43:00 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
18:43:10 <gwern> > let lookSay = iterate (concatMap (\is -> length is : take 1 is) . group) [1] in lookSay 4
18:43:11 <lambdabot>  Couldn't match expected type `t1 -> t'
18:43:20 <MyCatVerbs> :t (&&&)
18:43:21 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:43:27 <MyCatVerbs> That's fanout, right? Ayyyup.
18:43:50 <gwern> > let lookSay = iterate (concatMap (\is -> length is : take 1 is) . group) [1] in lookSay '1'
18:43:50 <lambdabot>  Couldn't match expected type `Char -> t'
18:44:04 <gwern> > let lookSay = iterate (concatMap (\is -> length is : take 1 is) . group) [1] in lookSay
18:44:05 <lambdabot>  [[1],[1,1],[2,1],[1,2,1,1],[1,1,1,2,2,1],[3,1,2,2,1,1],[1,3,1,1,2,2,2,1],[1,...
18:44:21 <dmwit> > map (length &&& head) . group $ "hey"
18:44:22 <lambdabot>  [(1,'h'),(1,'e'),(1,'y')]
18:44:48 <gwern> > let lookSay = iterate (concatMap (\is -> length is : take 1 is) . group) [6] in lookSay
18:44:49 <lambdabot>  [[6],[1,6],[1,1,1,6],[3,1,1,6],[1,3,2,1,1,6],[1,1,1,3,1,2,2,1,1,6],[3,1,1,3,...
18:45:10 <dmwit> > let lookn s = (map (length &&& head) . group) s >>= \(n, c) -> show n ++ [c] in lookn "hey"
18:45:10 <MyCatVerbs> Hrm. flatzip . zip == interleave, surely?
18:45:10 <lambdabot>  "1h1e1y"
18:45:24 <gwern> now that's a pretty nice one liner; maybe better could be done, but I'd be satisfied with lookSay
18:45:29 <MyCatVerbs> :t group
18:45:30 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
18:45:38 * MyCatVerbs facepalms.
18:45:53 <dmwit> > let lookn s = (map (length &&& head) . group) s >>= \(n, c) -> show n ++ [c] in lookn "1121"
18:45:54 <lambdabot>  "211211"
18:46:37 <dmwit> Well that was fun.
18:46:45 <dmwit> Now let's do fizzbuzz.
18:46:54 <MyCatVerbs> dmwit: I like that version.
18:47:06 <MyCatVerbs> dmwit: no, fuck fizzbuzz. Random oeis entries are actually fun.
18:47:23 <dmwit> =)
18:47:28 <MyCatVerbs> dmwit: fizzbuzz is merely a way of checking whether or not the person you're talking to is still fucking breathing. x_x
18:47:29 <dmwit> ?oeis 32552
18:47:29 <lambdabot> Number of walks of length n between two vertices on a icosahedron at distance 1.
18:47:29 <lambdabot> [1,2,13,52,273,1302,6573,32552,163073,813802,4070573,20345052,101733073,50862...
18:47:54 <MyCatVerbs> ...what. oeis guesses from a single integer? Near.
18:48:11 <dmwit> Oh, huh, I thought that would get the n'th OEIS.
18:48:13 <MyCatVerbs> *Neat
18:48:15 <dmwit> bummer
18:48:19 <MyCatVerbs> @oeis 101
18:48:19 <lambdabot> The prime numbers.
18:48:19 <lambdabot> [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,1...
18:48:34 <dmwit> Ah, we've all done that one, skip it.
18:48:38 <MyCatVerbs> Damn, I was hoping it would tell me that I was enumeratin dalmatians or something.
18:48:48 <MyCatVerbs> *enumerating
18:50:36 <MyCatVerbs> dmwit: I love the way you manage to pull together stuff out of Control.Applicative, the list monad and also little bits and pieces from the prelude all in the course of a single one-liner.
18:51:09 <dmwit> heh
18:51:10 * dmwit bows
18:51:14 <MyCatVerbs> dmwit: honestly, I'm beginning to think that the single biggest hit to Haskell's terseness so far is the sheer quantity of import Foo statements at the beginning of each and every file.
18:51:24 <dmwit> yeah =/
18:51:48 <dmwit> I have a "module Dmwit" that gets all the unqualified imports out of the way. =)
18:52:35 <MyCatVerbs> Heh.
18:52:46 <tromp> dmwit: your name reminds me of my Go program
18:52:58 <tromp> called dimwit
18:53:11 <MyCatVerbs> tromp: wow, I wonder why?
18:54:09 <MyCatVerbs> Hmmmm.
18:54:48 <redleafgr> tromp: so how well does it play?
18:54:48 <olsner> Sufficiently advanced Haskell is indistinguishable from magic.
18:55:03 <MyCatVerbs> @pl \s -> (map (length &&& head) . group $ s) >>= (\(n,c) -> show n ++ [c])
18:55:04 <lambdabot> (uncurry ((. return) . (++) . show) =<<) . map (length &&& head) . group
18:55:07 <tromp> about 15kyu on 9x9
18:55:19 <redleafgr> what approach did you use to make it
18:56:10 <MyCatVerbs> :t uncurry
18:56:11 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
18:56:12 <tromp> it's UCT / Monte Carlo
18:56:27 <redleafgr> what does UCT stand for?
18:56:32 <tromp> written in c++ :(
18:56:44 <tromp> Upper Confidence bounds for Trees
18:56:47 <redleafgr> ahh
18:56:53 <redleafgr> c++, must have been a nightmare
18:57:11 <tromp> let's see we had some long debugging session:)
18:57:14 <tromp> say
18:57:25 <redleafgr> haha
18:57:36 <redleafgr> how long did it take to get to this point?
18:58:06 <tromp> shockingly my coauthnor wrote first version in one evening
18:58:16 <gwern> tromp: that name is only appropriate if you wrote dimwit in Haskell :)
18:58:16 <gwern> tromp: got a repo for dimwit?
18:58:16 <gwern> @hoogle SimpleArgs
18:58:16 <lambdabot> No matches found
18:58:18 * gwern shakes head disapointedly. and I wanted a go program, since we already have shogi covered
18:58:23 <redleafgr> wow
18:58:26 <tromp> then we hacked it for a few  months
18:58:48 <tromp> no repo, sorry
18:59:03 <redleafgr> how many lines of C++ is it...
18:59:13 <Cale> gwern: With a nice game tree editor :)
18:59:30 <gwern> when you mentioned C++, I ceased to care :)
18:59:42 <gwern> Cale: que?
18:59:48 <tromp> about 2000
19:00:05 <redleafgr> only 2000? nice... so you can re-write it in about 20 lines of haskell, right?
19:00:08 <Cale> gwern: Have you ever used KGS' CGoban client?
19:00:18 <gwern> Cale: don
19:00:21 <gwern> t hink so
19:00:38 <tromp> well, let's see how they compare on Fhourstones
19:00:39 * gwern is not as drink as you thunk I am!
19:00:56 <nornagon> haha
19:01:33 <Cale> gwern: Okay, so, next to the board it displays (or can display), a tree of the moves made. Usually in a game, this is just a straight line, but in a teaching game, the teacher can afterward go over variations and mark up the board and such.
19:01:52 <redleafgr> it can also vary if you ask for undos
19:01:56 <Cale> right
19:02:02 <redleafgr> aka cheating
19:02:02 <tromp> my haskell version is half the java size
19:02:41 <Cale> I tend to allow undos if I haven't yet played the response.
19:02:48 <redleafgr> i meant cheating yourself
19:03:17 <tensh> I want to make show on a generic type, but I don't want the extra quotes show does if the generic type happens to be a string. Is that possible to acheive without putting up any other restrictions than Show and Read?
19:03:57 <Cale> Is there a particular reason for that?
19:04:14 <Cale> You can generally tell statically that you have a string and not apply show to it.
19:04:36 <tensh> well, I solved it by requiring Typeable and tryst to cast it to a string
19:04:45 <tensh> and did show if it failed
19:05:08 <tensh> but I wasn't allowed to do that appearantly (school assignment)
19:05:21 <Cale> Why do you need such a thing?
19:05:37 <gwern> Cale: sounds difficult, and practically AI-ish to explain in human terms the reasoning behind the utility calculations
19:05:50 <tensh> I need to add the result of a computation to a list
19:06:06 <tensh> well
19:06:38 <tensh> it needs to be a string in the list
19:07:20 <tensh> so I have to cast it since it's generic, but if that generic type happens to be a string it adds ""
19:07:25 <tensh> which is very ugly in the final result
19:07:33 <tensh> I don't know how to explain it better
19:07:36 <Cale> hmm
19:08:18 <Cale> Are you using existential types anywhere?
19:08:36 <Cale> I can't think of a reason that you wouldn't know that it's a string at compile time.
19:09:01 <tensh> sec, gotta look existential up ;)
19:09:13 <Cale> Well, you're probably not, then :)
19:09:16 <Saizan> tensh: make your own class
19:09:24 <Cale> (they're a GHC extension)
19:09:33 <Cale> But yeah, you could just make your own version of Show
19:09:52 <Cale> most of the instances for various types would just use show to implement it.
19:09:53 <tensh> Saizan: I think they want something else
19:10:04 <tensh> the rejection wasn't very informal
19:10:13 <Cale> tensh: Why not just not apply show when it's a String?
19:10:14 <tensh> of the assignment
19:10:33 <tensh> Cale: well, how can I tell?
19:10:47 <tensh> it looks kinda like this right now:
19:10:53 <Cale> tensh: By looking at the type of the thing you're applying it to?
19:11:23 <tensh> Right y  -> myFn (k y) [] (t++[Result (show y)])
19:11:57 <Cale> So you have  case foo of ...
19:11:58 <tensh> Cale: I seem to have missed how to do that
19:12:05 <tensh> I only know how to do it with :t ;)
19:12:13 <Cale> What's the type of foo? It must be Maybe t for some t
19:12:14 <tensh> ahh
19:12:21 <tensh> true
19:12:29 <tensh> I'll try that, thanks
19:12:34 <Cale> Hm?
19:12:37 <Saizan> tensh: i think you should require y to be a String, and convert earlier if you need.
19:13:00 <Cale> I wasn't sure that I'd suggested a solution :)
19:13:06 <tensh> Saizan: y is generic now
19:13:22 <Saizan> tensh: make it not :)
19:13:48 <Cale> tensh: hmm... So it's something like  foo :: (Show a) => Maybe a
19:14:11 <tensh> yeah, kinda
19:14:16 <Cale> er...
19:14:30 <Cale> maybe for some specific a
19:14:38 <Cale> (but polymorphic)
19:14:43 <tensh> more like foo :: (Show a) => IO (Either notRelevant a)
19:14:59 <tensh> and Read a
19:16:07 <tensh> but it isn't possible to something like this: "case y of"
19:16:14 <tensh> String -> y
19:16:17 <Cale> no
19:16:18 <tensh> _     -> show y
19:16:32 <Cale> case is for matching against data constructors
19:16:34 <tensh> ahh, ok... that's kinda how I read what you wrote earlier ;)
19:16:48 <Cale> I was asking you a question about your code.
19:17:12 <tensh> sorry, I'm kinda tired
19:17:34 <tensh> and confused
19:17:38 <Cale> Could I see the type signature of the whole function which this code is in?
19:17:54 <tensh> yes, sec
19:17:55 <Cale> Usually you can tell if the thing is a string or not just by looking at it.
19:18:08 <Cale> After all, the compiler resolves typeclasses at compile time.
19:18:22 <Cale> So it has to know which instance it's going to be using.
19:20:01 <Saizan> well, but the concrete type might come from very far away in the application tree
19:20:08 <Cale> That's true.
19:21:12 <tensh> hmm... I'm having second thoughts about where the error comes from
19:21:15 <Cale> I've never personally run into a situation where it's a problem to tell whether I should apply show or not, which is why I'm interested. It's tricky to see how this could come up without the use of existential types.
19:21:54 <tensh> I was stripping out the relevant code and I realized that I might be looking at the wrong part
19:24:47 <tensh> are you going anywhere soon? ;) I'm thinking about where the problem arises
19:24:59 <Cale> I'll be around for a while
19:25:24 <Cale> If you want, you could hpaste some code and we'll look at it, but you might want to avoid that for coursework ;)
19:26:04 <tensh> yeah... in that case I'd prefer to post it on my webserver so I can take it offline right after ;)
19:26:23 <tensh> this channel is being logged, right?
19:26:44 <Cale> I think so, yes.
19:27:04 <Cale> Your professor may already be here ;)
19:27:11 <tensh> probably :)
19:27:55 <tensh> well, I'm pretty sure we're allowed to ask for help about certain specific questions
19:28:35 <tensh> as long as you don't let other people do your work for you
19:29:21 <Saizan> that's the policy of this channel as well, and some professors even suggest to ask here :)
19:29:43 <tensh> :)
19:30:33 <tensh> at least one of my tutors I had in a course last year hangs around this channel
19:30:42 <tensh> I don't know about the current ones
19:33:57 <Saizan> anyone knows a program that let's you classify files with tags? images in my case
19:35:14 <SamB> hmm, can someone write some sample code using the Class Aliases extension?
19:35:14 <lambdabot> SamB: You have 1 new message. '/msg lambdabot @messages' to read it.
19:35:18 <SamB> @messages
19:35:19 <lambdabot> gwern said 2h 27m 47s ago: my patches to conjure are getting held for moderation because of size
19:35:32 <SamB> gwern: ah, I'll take care of that
19:38:47 <tensh> Cale: I might actually be able to use Typeable, since I just realized that I never really needed it in so many places that I used it in before
19:39:30 <SamB> gwern: would 1 MB be a more appropriate size limit?
19:39:48 <tensh> only one place and that one is a bit special and won't be used when it's used as a module (as it's built to be)
19:40:08 <tensh> it's kinda like main() :)
19:42:55 <dino-> Saizan: Man, I'd like to start tagging my photos. I don't know if the EXIF headers can old that info or if it's something else.
19:43:45 <dino-> s/old/hold/
19:50:32 <glguy> Does anyone know what the Storable instance for Int corresponds to in C?
19:50:45 <SamB> glguy: HsInt?
19:51:10 <glguy> so if a struct says it contains an 'int', am I better off asking for a CInt?
19:51:21 <SamB> MUCH
19:51:27 <SamB> why did you think it was called CInt?
19:51:30 <SamB> notice the pattern?
19:51:34 <glguy> :-/
19:51:37 <SamB> our int is called HsInt in C?
19:51:42 <SamB> re. Our Int.
19:51:42 <glguy> ok
19:51:52 <SamB> their int is called CInt in Haskell?
20:06:25 <SamB> hmm, I'm not going to make much more headway on implementing class aliases in Jhc tonight...
20:06:53 <gwern> SamB: I figure a meg would be enough
20:07:40 <SamB> yeah, I upped the limit from 100k to 1024k
20:08:03 <glguy> @seen mauke
20:08:03 <lambdabot> mauke is in #xmonad and #haskell. I don't know when mauke last spoke.
20:18:40 <gwern> http://malde.org/~ketil/ <-- w00t. I have finally cabalized and put onto hackage everything ketil has up
20:18:42 <lambdabot> Title: Bioinformatics tools in Haskell
20:18:46 <gwern> man that took a while
20:19:00 * gwern waits for the accolades
20:19:25 <dons> well done, gwern
20:19:31 <gwern> ?accolade gwern
20:19:31 <lambdabot> Unknown command, try @list
20:19:55 <gwern> bah! lambdabot, you ain't never caught a rabbit and you ain't no hound-dog o' mine
20:20:59 <SamB> @tell gwern Good job!
20:20:59 <lambdabot> Consider it noted.
20:22:19 <gwern> SamB: yeah, so I mucked up a dependency for conjure
20:22:19 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
20:22:23 <gwern> and had to resend the whole batch
20:22:45 <SamB> Lemmih: are you getting gwern's patches?
20:23:20 <mauke> glguy: you rang?
20:26:30 * glguy needs a liftM17
20:26:39 <glguy> mauke: I saw a comment you wrote about #alignment
20:26:40 <mauke> it's called `ap`
20:26:42 <glguy> for hsc files
20:27:01 <glguy> does that work for more or less any struct?
20:27:07 <mauke> > return (+) `ap` [1,2] `ap` [10,20,30]
20:27:07 <lambdabot>  [11,21,31,12,22,32]
20:27:15 <mauke> glguy: yes, I think so
20:27:30 <mauke> it may not return the minimum possible alignment value but it's always safe
20:27:51 <glguy> ok, cool
20:27:56 <glguy> http://www.sqlite.org/c3ref/vfs.html
20:28:04 <glguy> almost done with an instance for this
20:28:07 <glguy> tedium
20:28:09 <mauke> oh wow
20:30:50 <glguy> that one's done, one more big one to go :)
20:48:50 <gwern> glguy: are you writing a haskell binding to sqlite?
20:48:50 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
20:50:11 <gwern> aw BMeph, that makes me feel so warm and fuzzy
20:50:38 <BMeph> gwern: Ha-ha, it made me hungry, TBH. ;)
20:51:03 <BMeph> Hungry...for Lambdas! >;)
20:51:16 * gwern just went and got a big hunk of cheese because I was hungry, actually
20:51:29 <gwern> now I will go and refill my tea pot to make tea to drink with the cheese
20:51:36 <SamB> gwern: because he was hungry
20:52:58 <dmwit> http://malde.org/~ketil/Hazard_lambda.svg
20:53:17 <dmwit> Warning: lambda's may cause your head to inflate to dangerously large sizes
20:57:11 <glguy> gwern: no, that already exists
20:57:26 <glguy> gwern: I want to write my own vfs implementation
20:58:32 <gwern> huh. well, I suppose you do worse for a learning exercise
20:58:45 <glguy> lol, not a learning exercise :)
20:59:15 <glguy> well, I'm sure I'll learn something from it
20:59:17 <glguy> but that's not the goal
20:59:21 <SamB> I suppose you think my project to implement class aliases in JHC is a learning attempt too?
20:59:36 <SamB> or didn't I tell anyone about that yet?
20:59:54 <gwern> SamB: you mentioned something earlier about utter failure
21:00:08 <SamB> I mentioned that I wasn't making any progress
21:00:23 <gwern> SamB: I dunno what class aliases are, so I don't know if that's an interesting exericse or one step closer to the day we have a useful ultra-high performance compiler
21:00:31 <SamB> that's probably because I'm too tired to work on it and need some guidance on how Jhc does classes ;-)
21:00:52 <SamB> gwern: it's more going for usability, actually ;-)
21:01:07 <SamB> I just want to see what you can actually use them for, at the moment...
21:01:14 <gwern> useful things are useable
21:01:35 <SamB> if they seem to work well, maybe we can get someone to do them in GHC as well
21:02:04 <SamB> but I think that implementing extensions in GHC is beyond me at present ;-)
21:06:22 <glguy> when subclassing a C struct, do you just make a new struct whose first field is the base struct?
21:07:21 <dmwit> Did you just use subclassing and C in the same sentence?
21:07:31 <glguy> wasn't my idea
21:07:35 <SamB> glguy: yes!
21:07:52 <SamB> that is how they do it in Python, and that is how they do it in GTK
21:12:40 <SamB> @tell Lemmih please review gwern's conjure patches soon
21:12:40 <lambdabot> Consider it noted.
21:14:10 <glguy> my puppy seems to be competing with my laptop for lap spaace
21:14:52 <SamB> maybe you shouldn't keep your laptop on your lap
21:15:01 <glguy> that seems to be his position
21:15:05 <dmwit> Puppy wins 9/10 times.
21:15:06 <SamB> that's a pretty strange place to have a laptop if you ask me
21:15:18 <SamB> usually I would use a table or desk
21:15:58 <SamB> during the month not quite five years ago when I had a laptop
21:19:48 <glguy> Sam, my puppy, has demonstrated that he doesn't typically look before he completes a sprint by jumping in my lap, so I have to be careful not to have him plow through my lcd
21:23:55 <scook0> @type runStateT
21:23:56 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
21:25:10 <dmwit> ?unmtl StateT s []
21:25:10 <lambdabot> err: `StateT s []' is not applied to enough arguments, giving `/\A. s -> [(A, s)]'
21:25:13 <glguy> ?where monadLib
21:25:13 <lambdabot> http://www.cse.ogi.edu/~diatchki/monadLib/
21:25:21 <dmwit> ?unmtl StateT s [] ()
21:25:21 <lambdabot> s -> [((), s)]
21:26:26 <glguy> @where+ monadLib http://purely-functional.net/monadLib/
21:26:26 <lambdabot> Nice!
21:30:51 <gwern> hm. I wonder if the [[Hashlife]] algorithm is purely functional. the description leads me to believe it is
21:52:45 <EvilTerran> gwern, i think the map gets updated with new cached results each iteration
21:53:07 <EvilTerran> but you could make it work lazy-functionally if you had a representation that was okay with infinite structures
21:55:23 <EvilTerran> (prefix tree?)
21:58:25 <gwern> would the levels of the tree represent the various generations as they spread out at the 'speed of light' (its equivalent in the game of life anyway)?
21:59:53 <EvilTerran> i mean as the map from one generation to the next on a per-2^n-square basis
22:00:02 <EvilTerran> i'm not really sure, i'm a bit fuzzy on the algorithm
22:00:58 <gwern> it's a complex algorithm which I don't entirely understand either. it's kind of weird how different areas of the plane can be billions of turns seperated in time, I never really understood it
22:10:38 <glguy> How does one tell Cabal to run hsc2hs
22:10:40 <dmwit> I thought the key part of the hashlife algorithm was pointer-based comparisons (which don't really have an analog in Haskell).
22:10:48 <glguy> or is that a manual step
22:10:53 <dmwit> not manual
22:11:03 <dmwit> Check how other projects do it?
22:12:48 <mauke> have a source file with .hsc
22:13:16 <glguy> there isn't a trick
22:13:18 <glguy> I just forgot to list it
22:13:40 <gwern> dmwit: the important part I understand was memoizing the results of a particular pattern; I'm not sure how Gosper could have chosen to use pointer-based comparisons in his original implementation in Zetalisp or whatever he was using on the symbolics machines
22:14:31 <dmwit> Yeah, memoization; but the memoization involves choosing a canonical representation of a node at each level of the quad-tree so that you don't have to do a deep comparison.
22:14:42 <dmwit> (I thought.)
22:15:23 <EvilTerran> that sounds about right
22:15:27 <dmwit> gwern: And lisp has several kinds of equals, one of which is pointer-equals, if I remember correctly.
22:17:13 <gwern> hm. I wonder if I still have gosper's paper around
22:17:38 <gwern> ah, yes, I have his paper from ''Physica D.
22:18:38 <glguy> ?hoogle a -> Ptr a
22:18:39 <lambdabot> No matches, try a more general search
22:19:06 <glguy> (just looking for a prepackaged: \ x -> malloc >>= \ ptr -> poke ptr x
22:19:36 <dolio> @type with
22:19:37 <lambdabot> Not in scope: `with'
22:19:47 <dmwit> ?index with
22:19:47 <lambdabot> Foreign.Marshal.Utils, Foreign.Marshal, Foreign
22:20:16 <glguy> ah:
22:20:18 <glguy> :t new
22:20:19 <lambdabot> Not in scope: `new'
22:20:23 <glguy> ?index new
22:20:23 <lambdabot> Data.Graph.Inductive.NodeMap, Data.Graph.Inductive, Data.HashTable, Foreign.Marshal.Utils, Foreign.Marshal, Foreign
22:20:46 <glguy> thnx
22:20:54 <gwern> 'the hash mechanism notices the coincidence and returns the old cell instead of a new one.' <--gee, thanks for the technical detail there gosper
22:21:11 <dmwit> heh
22:22:47 <Lemmih> gwern, SamB: I won't have commit access to conjure for at least a couple of days.
22:22:47 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
22:23:24 <gwern> Lemmih: no rush. I have no more plans for editing conjure right now
22:25:09 <gwern> Lemmih: although I'm curious as to why work on conjure stopped so apparently suddenly to judge by the ml; it had made a awful lot of progress I thought
22:27:22 <Lemmih> Writing a GUI wasn't all that fun.
22:28:32 <newsham> hi
22:28:40 <dmwit> Heya, newsham!
22:29:06 <newsham> what's going on?
22:29:22 <dmwit> I'm a code monkey for a few days. =/
22:29:26 <dmwit> How about with you?
22:29:47 <newsham> friday night, relaxing with a beer, contemplating some code fun of some sort
22:33:33 <dmwit> Yay!
22:33:50 <dmwit> What's fun these days?
22:34:23 <newsham> dunno.  i downloaded and built Singularity the other day and I was thinking of playing with that some, but I think that might be too intense for a fri night
22:34:32 <gwern> dmwit: taking old and unloved haskell code, and loving it
22:34:45 <gwern> dmwit: I have a long TODO list if you need help finding a project
22:34:46 <newsham> and i've been working on code for my lambda calc evaluator, but i cant think of a decent small project to code in it now.
22:35:02 <dmwit> gwern: Oh, no.  I have my own long list of TODO's, thank you very much. =)
22:35:15 <newsham> but if i can think of something simple and fun i might write more lambda calc stuff
22:35:51 <newsham> i have tuples and lists and state monads for it and wrote some simple examples like prime numbers and towers of hanoi
22:36:07 <glguy> C ffi!
22:37:20 <glguy> 259 lines later /me has a skeleton vfs use + type defs and storable instances :)
22:37:25 <newsham> heh, i dont wanna go in that direction.
22:37:29 <glguy> talk about painful
22:37:45 <newsham> what are you building?
22:37:53 <dmwit> newsham: Lists, or is that too similar to tuples?
22:38:05 <dmwit> No typing, huh?
22:38:07 <newsham> dmwit: i have lists.
22:38:08 <glguy> stuff tools to work on custom vfs impls. for sqlite
22:38:12 <newsham> no, using untyped lambda calc.
22:38:29 * dmwit blinks
22:38:35 <dmwit> I obviously can't read.
22:38:37 <newsham> here's my current prelude: http://www.thenewsh.com/%7Enewsham/lambda/prelude.lam
22:40:57 <Cale> newsham: Why is Y a macro?
22:41:42 <newsham> *shrug*
22:41:54 <newsham> i didnt want to inline it into LETREC
22:42:23 <Cale> oh, I see
22:43:31 <Cale> Interesting how you're using macros as a module system :)
22:43:43 <newsham> yah i think that worked out particularly well
22:44:21 <newsham> originally I had defmacro expanding to (\x x) too, but I ended up having it expand to None (like Nothing) and filtering out the top level None's
22:45:00 <newsham> i wanted the prelude to not have to be a pre-and-postlude and macros were the only way I could think of doing that
22:45:10 <newsham> and once I started going down that road, the modules seemed to make sense
22:51:33 <hpaste>  paolino pasted "line of pixels" at http://hpaste.org/6199
22:52:31 <paolino> if someone has hints on making it more simmetric , welcome
22:53:46 <ikegami--> > dropWhile (== 1) [1, 2, 3]
22:53:48 <lambdabot>  [2,3]
22:54:25 <ikegami--> hmm, my ghc (6.8.2) returns [1, 2, 3]
22:54:42 <ikegami--> I wonder what's wrong
22:54:46 <mauke> @version
22:54:46 <lambdabot> lambdabot 4p597, GHC 6.8.2 (Linux i686 2.40GHz)
22:54:46 <lambdabot> darcs get http://code.haskell.org/lambdabot
22:55:27 <dmwit> ikegami--: ...that would surprise me quite a lot.
22:55:31 <ikegami--> > dropWhile (==1) [1, 2, 3]
22:55:32 <lambdabot>  [2,3]
22:55:46 <newsham> my ghc6.8.2 returns [2,3]
22:55:57 <paolino> here also
22:56:09 <newsham> maybe your 1 is less than 1
22:56:19 <ikegami--> hehe
22:56:38 <paolino> or some pixels are missing
22:56:44 <ikegami--> Uh, I misunderstanded
22:56:59 <ikegami--> > dropWhile (== 'a') "abc"
22:57:00 <lambdabot>  "bc"
22:57:23 <ikegami--> > dropWhile (== 'c') "abc"
22:57:24 <lambdabot>  "abc"
22:57:41 <dmwit> > delete 'c' "abc"
22:57:42 <lambdabot>  "ab"
22:57:45 <ikegami--> This confuse me
22:57:51 <dmwit> > delete 'c' "abcc"
22:57:51 <lambdabot>  "abc"
22:58:01 <mauke> > filter (/= 'c') "abcc"
22:58:02 <lambdabot>  "ab"
22:58:10 <ikegami--> mauke++
22:58:12 <dmwit> ikegami--: dropWhile drops from the beginning, while the predicate matches.
22:58:30 <ikegami--> I must read the Prelude again
22:58:32 <newsham> if a == c then dropWhile ==c bc else a : dropWhile ==c bc
22:58:43 <dmwit> Since the beginning of "abc" does not match the predicate (=='c'), it just stops dropping immediately.
22:59:08 <newsham> err me wrong
22:59:16 <newsham> ignore the last dropWhile ==c
22:59:31 <ikegami--> dmwit: thanks
22:59:33 <newsham> > dropWhile (== 'a') "aaaaaaabbbcccc"
22:59:34 <lambdabot>  "bbbcccc"
22:59:36 <ikegami--> I see
22:59:44 <newsham> > dropWhile (=='b') "aaaaabbbbbcccc"
22:59:45 <lambdabot>  "aaaaabbbbbcccc"
23:00:03 <dmwit> > dropWhile (== 'a') "aaaabaaaaabaaaab"
23:00:03 <lambdabot>  "baaaaabaaaab"
23:00:17 <newsham> ?src dropWhlie
23:00:17 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
23:00:19 <newsham> ?src dropWhile
23:00:19 <lambdabot> Source not found. Where did you learn to type?
23:00:34 <dmwit> ?source Prelude
23:00:35 <lambdabot> http://darcs.haskell.org/packages/4/Prelude.hs
23:00:46 <dmwit> ?where Prelude
23:00:46 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
23:00:55 * paolino wants findlast in the prelude
23:01:00 <dmwit> That one isn't 404'd.
23:01:05 <dmwit> findlast?
23:01:26 <paolino> findLast t xs = fst `fmap` find (not . t . snd) $ zip xs (tail xs)
23:01:45 <dmwit> > let findLast x xs = length xs - indexOf x (reverse xs) in findLast 'c' "abbcbbcd"
23:01:47 <lambdabot>   Not in scope: `indexOf'
23:02:02 <newsham> length - find reverse?
23:02:22 <dmwit> :t find
23:02:23 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
23:02:39 <paolino> findLast :: (a -> Bool) -> [a] -> Maybe a
23:03:13 <paolino> find just goes one element too far
23:03:24 <dmwit> Yeah, I see what you're talking about.
23:03:51 <dmwit> findLast p xs = maybeLast $ takeWhile (not . p) xs
23:04:10 <dmwit> maybeLast [] = Nothing; maybeLast xs = Just (last xs)
23:04:48 <paolino> isn't it bad O ?
23:05:01 <dmwit> O(n), just like yours.
23:05:12 <paolino> ok
23:05:31 <newsham> > liftM (- (length "foobar")) $ elemIndex 'o' "foobar"
23:05:32 <lambdabot>  Couldn't match expected type `a1 -> r' against inferred type `Int'
23:05:34 <dmwit> Although mine gives wrong answers.
23:05:42 <newsham> > elemIndex 'o' "foobar"
23:05:43 <lambdabot>  Just 1
23:05:45 <mauke> lern2subtract
23:06:21 <newsham> > liftM (subtract (length "foobar" - 1)) $ elemIndex 'o' "foobar"
23:06:22 <lambdabot>  Just (-4)
23:06:29 <newsham> oopz
23:07:19 <newsham> > liftM (flip subtract (length "foobar" - 1)) $ elemIndex 'o' "foobar"
23:07:20 <lambdabot>  Just 4
23:07:33 <newsham> > liftM (flip subtract (length "foobar" + 1)) $ elemIndex 'o' "foobar"
23:07:34 <lambdabot>  Just 6
23:07:37 <newsham> heh
23:08:03 <newsham> > liftM (flip subtract (length "foobar" - 1)) $ elemIndex 'o' (reverse "foobar")
23:08:04 <lambdabot>  Just 2
23:08:18 <newsham> more error than trial
23:08:37 <paolino> trial and errors
23:10:28 <dmwit> > do { m <- length; n <- elemIndex 'o' . reverse; return (fmap (subtract n) m) } "foobar"
23:10:28 <lambdabot>  Parse error at ""foob..." (column 80)
23:10:35 <dmwit> > do { m <- length; n <- elemIndex 'o' . reverse; return (fmap (subtract n) m) } $ "foobar"
23:10:36 <lambdabot>  Couldn't match expected type `f (Maybe Int)'
23:10:51 <dmwit> Oh, right.
23:11:11 <dmwit> > do { m <- length; n <- elemIndex 'o' . reverse; return (fmap (m-) n) } $ "foobar"
23:11:11 <lambdabot>  Just 3
23:11:32 <newsham> -1
23:11:43 <dmwit> I suppose.
23:12:00 <newsham> if elemIndex returns 0 the result is length-1
23:12:07 <dmwit> I was more interested in how it looked in do notation than getting the right answer. =)
23:12:29 <newsham> ?remember dmwit I was more interested in how it looked in do notation than getting the right answer.
23:12:30 <lambdabot> I will never forget.
23:12:34 <newsham> that would make a good tshirt
23:13:00 <glguy> ?hoogle pokeCString
23:13:00 <lambdabot> No matches found
23:21:57 <glguy> wtf? Data.Time.Clock defines the newtype "UniversalTime" but now way to generate one?
23:24:05 <dmwit> And no way to consume one, either!
23:24:09 <dmwit> Isn't it grand?
23:24:30 <dmwit> glguy: Have a look in the other Data.Time libraries, though.
23:24:48 <dmwit> localTimeToUT1 :: Rational -> LocalTime -> UniversalTime, for example.
23:24:57 <glguy> hoogle found no other references to that type either
23:25:42 <dolio> Well, UniversalTime is Eq and Ord, so if you manage to get two, you can compare them. :)
23:26:28 <dmwit> It looks like localTimeToUT1 and ut1ToLocalTime are the only producers/consumers of UniversalTime's.
23:26:51 <glguy> ah ha
23:27:53 <glguy>   gettimeofday(&sNow, 0);
23:27:55 <glguy>   *prNow = 2440587.5 + sNow.tv_sec/86400.0 + sNow.tv_usec/86400000000.0;
23:28:02 <glguy> is what I'm trying to accomplish in the end
23:28:32 <glguy> dunno what that magic number is
23:28:47 <dmwit> Oh, porting some random code?
23:29:14 <dmwit> Well, you should be able to get the sec and usec part of a UTCTime, at least.
23:29:20 <glguy> yeah
23:29:38 <newsham> why + 2440587 ?
23:29:55 <glguy> that's the julian number for 1970
23:29:59 <glguy> whatever day the unix time started
23:30:15 <newsham> > 2440587  / 365
23:30:16 <lambdabot>  6686.539726027398
23:30:16 <glguy> I think I can make that universaltime work
23:36:35 <glguy> I *think* that I implemented the correct time function
23:38:23 <glguy> I need some kind of diagram
23:38:28 <glguy> explaining how these time types relate
23:47:58 * dmwit facepalms
