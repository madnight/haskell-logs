00:00:46 <awesame> does haskell have anything like an arraylist?
00:01:14 <awesame> and, is such a thing even necessary in haskell?  the performance of haskell code is still mostly mysterious to me.
00:01:32 <glguy> Like in Data.Array?
00:02:42 <awesame> Data.Array looks like arrays with fixed bounds
00:03:20 <awesame> "arraylist" refers to an implemention of a list as an array which re-allocates memory and doubles its size as necessary
00:03:48 <awesame> I think this could not be used anything like a list in haskell
00:04:17 <dolio> I doubt that'd be a good idea unless you built it on mutable arrays in a monad.
00:05:21 <awesame> I've been thinking of haskell lists as linked lists, since they're constructed like lisp lists, but I'm not sure I have any idea what the cost of a lookup is in a haskell list, because of laziness stuff I might not have thought about
00:05:22 <Korollary> That's typically called a vector
00:05:33 <awesame> vectors, yeah
00:05:34 <ketil> awesame, lazy bytestrings do something similar
00:05:49 <ketil> (although the blocks have some upper limit, they don't double in size)
00:06:54 <ketil> And Haskell lists are similar to Lisp, execpt for the type restriction.
00:07:37 <ketil> So random access in a list is O(n) - you should write your programs to stream through lists, so the head can be GCed while you continue working on the tail.
00:07:42 <awesame> ketil: including performance characteristics?
00:07:56 <awesame> right, okay
00:08:34 <dolio> @remember simonpj If you put a spoonful of sewage into a vat of wine, what do you have? A vat of sewage.
00:08:34 <lambdabot> It is forever etched in my memory.
00:08:34 <awesame> so if I want fast random access, Data.Array is the usual thing to use?
00:08:47 <ketil> awesame, probably, yes.
00:08:53 <ketil> Or Data.Map, perhaps.
00:09:57 <awesame> okay, that clears things up a little bit, at least
00:09:58 <awesame> thanks
00:25:35 <glguy> Any takusen users that have used withPreparedStatement with multiple withBoundStatement + execDML calls?
00:26:21 <glguy> this library is cool, but I'm not convinced anyone has ever used it
00:43:03 <Baughn> Map.fromList always uses the last element if I have multiple elements with the same key. Is this guaranteed?
00:43:58 <opqdonut> well the input list should be ascending right?
00:44:17 <opqdonut> it might want tightly ascending...
00:44:24 <oerjan> no, there is a specific function for that
00:44:44 <oerjan> fromAscList, and also fromDistinctAscList
00:44:55 <opqdonut> ah
00:45:29 <oerjan> only the last can break completely on equal keys, i assume
00:45:31 <opqdonut> oerjan: ok ok
00:45:36 <explisixjelly> good morning fellow haskell-men.
00:45:46 <opqdonut> Baughn: well you can always fold over the list with insert to guarantee that behaviour
00:45:49 <opqdonut> gtg
00:45:50 <opqdonut> ->
00:45:58 <dolio> I don't know if it's guaranteed, but the implementation is a foldl with insert.
00:48:54 <Baughn> Given that fromAscList does exist, it probably should be. I'll.. assume it is.
00:49:17 <opqdonut> dolio: exactly
00:51:28 <dmwit> The docs don't guarantee it, but I wouldn't be pained if I read code relying on it.
00:52:20 <Baughn> Something for haskell'?
00:53:26 <Baughn> Then again, Data.Map isn't part of the first one..
00:53:30 <dmwit> Aw, hell, good docs don't need to wait on Haskell'.
00:54:17 <opqdonut> is there any organised effort on building a "proper" Prelude
00:54:29 <opqdonut> with all the class system improvements, (.) = fmap etc.
00:54:41 <dmwit> There was a "licensed prelude extensions" or something, some time ago.
00:54:43 <opqdonut> as it seems haskell' is pretty conservative
00:55:02 <dmwit> But I think that disappeared when the old wiki did.
00:56:24 <Baughn> dmwit: So I just send patches with darcs to libraries@haskell.org, right?
00:57:00 <dmwit> That sounds good.
00:57:05 * dmwit doesn't really know
00:57:43 <oerjan> btw libraries@ was subscribers-only last i tried
00:58:42 <oerjan> s/last/the only time/
00:58:48 <glguy> ?seen dons
00:58:48 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 1h 39m 36s ago.
01:00:56 <sclv> haskell gripe of the day: no way to set infix operator precedence higher than function precedence, I think?
01:00:57 <sclv> sigh.
01:01:25 <oerjan> it's a feature!
01:01:45 * sclv wanted to write something with printf-type varargs, but infix.
01:02:31 <oerjan> ah
01:02:33 <Baughn> @ty printf
01:02:38 <lambdabot> forall r. (PrintfType r) => String -> r
01:02:56 <Baughn> @instances PrintfType
01:02:56 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
01:03:08 <Baughn> @instances-importing PrintfType
01:03:09 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
01:03:13 <sclv> the type system is such a tease. you think you can do anything and then... you really can't. or you can, but it involves more boilerplate than doing things another way in the first place.
01:03:19 <oerjan> @instances- Text.Printf PrintfType
01:03:19 <lambdabot> (a -> r), IO a, [c]
01:03:43 <Baughn> So that's how you use it
01:04:19 <Baughn> ..I th... whoever wrote printf must've been an insane genius
01:04:41 <opqdonut> :)
01:04:51 <oerjan> -- Copyright   :  (c) Lennart Augustsson, 2004
01:04:59 <opqdonut> it is a pretty spiffy piece of typeclassmagic
01:05:13 <oerjan> given that is the same guy who won the IOCCC twice, i'd say you are right :)
01:05:16 <Baughn> A patronym. That's a sure sign of mad science right there.
01:05:27 <oerjan> Baughn: why thank you.
01:06:17 <Baughn> oerjan: Just stay away from the giant gerbils, and we'll get along fine
01:06:33 <oerjan> ah another Narbonics fan
01:07:11 <Baughn> Girl genius, actually. Giant gerbils seem to be a common meme.. somehow.
01:07:43 <oerjan> er i read that too.  but i don't remember those giant gerbils.
01:08:02 <Baughn> They were in one of the sound dramas
01:08:07 <sclv> it generalizes very poorly.
01:08:17 <Baughn> And to be fair, it wasn't the /gerbils/ that were size-adjusted
01:08:28 <oerjan> aha
01:10:30 <oerjan> the giant rabbits definitely were, though
01:10:32 <sclv> ideally I'd have tmpl |< ("name",arg) ("name2",arg) etc. where |< not only gave the args to the template but also performed some postprocessing rendering on the template itself.
01:10:37 <sclv> this is apparently a fools dream.
01:11:16 <oerjan> just replace that , with something more polymorphic, i think
01:11:29 <sclv> i've tried nearly everything.
01:11:47 <quicksilver> tmpl <| ["name" $$ arg, "name2" $$ arg, "name3" $$ arg]
01:11:51 <quicksilver> should be acheivable
01:11:54 <sclv> oh, right.
01:12:05 <sclv> except the args are of different types but the same typeclass.
01:12:13 <quicksilver> that's ok.
01:12:21 <quicksilver> that's why I used an operator ;)
01:12:25 <sclv> oh, I see, use $$ to build an existential.
01:12:26 <oerjan> tmpl |< ("name" $$ arg) ("name2" $$ arg) perhaps?
01:12:32 <quicksilver> in practice I'd choose something better looking
01:12:35 <quicksilver> like :=
01:12:46 <quicksilver> I don't think there is much reason not to use a list her.
01:12:47 <quicksilver> here.
01:12:55 <quicksilver> it *is* a list after all.
01:13:05 <oerjan> depends what tmpl is.
01:13:06 <EvilTerran> it'd be that or tmpl |< (...) |< (...)
01:13:09 <sclv> right -- if I can marshall it into existentials its fine. figures i'd bang my head against the silly cute solution.
01:13:26 <sclv> EvilTerran: I already have that.
01:13:32 <quicksilver> sclv: this is how most of the big gui libraries do it.
01:13:57 <oerjan> if its type actually tells what arguments it can take, then existentials will be a loss
01:14:00 <quicksilver> quit <- button f [text := "Quit", on command := close f]
01:14:12 <quicksilver> (example from wxwidgets)
01:14:20 <oerjan> but if it is from a format string it won't matter
01:14:47 <quicksilver> I'm not really sure what you mean oerjan but I think you're wrong :)
01:14:55 <quicksilver> it's perfectly possible to have this typesafe.
01:15:07 <quicksilver> although the type errors you get could be ugly.
01:15:12 <quicksilver> as is generally the case with such tricks :)
01:15:59 <oerjan> quicksilver: type safe yes but not typechecked at compile time
01:16:14 <oerjan> existentials throw away information
01:16:24 <sclv> oerjan: not in my case, though.
01:16:32 <EvilTerran> use olegian HList-inspired extensible records! :P
01:16:42 <quicksilver> oerjan: not necessarily, no.
01:16:55 <quicksilver> oerjan: the existentials can easilly be parameterised.
01:17:07 <oerjan> quicksilver: not if you put them in a list
01:17:09 <quicksilver> oerjan: are you suggesting 'tmpl' might have type information in it?
01:17:11 <EvilTerran> tmpl |< Text "Quit" :*: OnCommand (close f)
01:17:21 <oerjan> then at a _minimum_ you lose the order of arguments
01:17:28 <quicksilver> certainly you lose that, yes.
01:17:32 <oerjan> quicksilver: tmpl could be combinator based
01:17:36 <quicksilver> yup.
01:17:46 <quicksilver> what I'm saying is that tmpl can have type information in
01:17:50 <sclv> on the other hand, EvilTerran's solution is actually syntactically cleaner I think than existentials and a list.
01:17:52 <quicksilver> which can be respected by your existentials.
01:18:00 <oerjan> there was a printf-like implementation of that sort (in ocaml?)
01:18:07 <quicksilver> sclv: EvilTerran's solution *is* existentials (just not a list)
01:18:13 <quicksilver> he's just unwrapped it
01:18:16 <EvilTerran> sclv, just wait 'til you see the relevant bits of the HList source
01:18:17 <quicksilver> using :*: instead of ,
01:18:34 <sclv> quicksilver, not that one, the previous one.
01:18:48 <oerjan> i believe tmpl |< ("name" $$ arg) ("name2" $$ arg) could be made to work with full types
01:18:50 <sclv> how it works now: outputTmpl $ boardTemplate |< ("board",x) |< ("threads",y)
01:19:31 <sclv> the outputTmpl $ bit looks sort of crufty, but beyond that its clean.
01:19:39 <oerjan> "just" make $$ give either a function or a |< argument as result
01:19:42 <quicksilver> oerjan: any, my point is that if tmpl :: Template a
01:19:57 <quicksilver> oerjan: then |< :: Template a -> [Parameter a]
01:20:06 <quicksilver> then |< :: Template a -> [Parameter a] -> Result a
01:20:08 <quicksilver> or whatever
01:20:26 <quicksilver> point is, type information from the tmp can affect type checking of the list.
01:20:41 <quicksilver> quit <- button f [text := "Quit", on command := close f]
01:20:54 <quicksilver> ^^ going back to the wxwidgets example, it *is* typechecked that 'buttons' have 'text'.
01:20:57 * glguy hates waiting for patches his code depends on to get pushed upstream
01:21:00 <quicksilver> if buttons didn't have text that would be a type error.
01:21:33 <oerjan> quicksilver: ok, that works because the order of elements in the list is immaterial
01:22:45 <oerjan> oh wait
01:23:43 <aleator_> Hi all.  What was the proper and neat way to force evaluation of structures? Using "print x" seems to do it, but that is just so silly :)
01:23:44 <oerjan> ("name" $$ arg) implies things are looked up by name... and the name is a value.  compile-time typing won't work.
01:24:03 <oerjan> :t evaluate
01:24:04 <lambdabot> forall a. (Testable a) => a -> Gen Result
01:24:08 <oerjan> argh
01:24:25 <oerjan> @hoogle evaluate
01:24:25 <lambdabot> Control.Exception.evaluate :: a -> IO a
01:24:29 <oerjan> that one
01:24:53 <Baughn> There's also seq
01:24:53 <oerjan> :t seq -- or this one, purely
01:24:54 <lambdabot> forall a t. a -> t -> t
01:24:58 <explisixjelly> am I the only one that sometimes places parantheses just to tell emacs to indent differently?
01:25:09 <oerjan> hm there was something i wanted to check
01:25:24 <oerjan> > (undefined >>= putStr) `seq` True
01:25:26 <quicksilver> oerjan: right. But 'arg' might be subject to some compile time checking.
01:25:26 <lambdabot>  True
01:25:56 <quicksilver> oerjan: given that it's a templating system I was thinking order of the arguments doesn't matter, yes.
01:26:11 <quicksilver> if the typing of the arguments has to influence later argumetns then yes, you can't use lists.
01:26:27 <aleator_> Well, seq does not really help if I have say lists of trees and deepseq would require me to make instances. I think there was something else but can't remember..
01:26:55 <oerjan> aleator_: deepseq or rnf.  but both require instances
01:27:25 <quicksilver> aleator_: if the problem you are trying to solve requires forcing evaluation of structures, then you're solving the wrong problem. Try a different one.
01:27:26 <oerjan> there is just no haskell way to do deep evaluation without them
01:27:28 <quicksilver> ;)
01:27:54 <quicksilver> I'm not entirely serious. But most of the time people use or try to use seq they really don't need to.
01:28:15 <sclv> thanks for the help guys. i'm off to sleep, will tackle this more tomorrow.
01:28:34 <quicksilver> the most common good reason is trying to divide work between parallel threads, in which case check out the control.parallel.strategies module
01:28:37 <aleator_> quicksilver: Well. I have a program that leaks memory. Can't figure out how to make it stop, except by forcing evaluation
01:29:08 * quicksilver nods
01:29:17 <quicksilver> well, that is another reason.
01:29:28 <quicksilver> I'd take a look at the function which is building up these large thunks
01:29:32 <quicksilver> and add a little strictness tehre
01:29:33 <oerjan> haskell, the sieve language
01:29:41 <wagle_home> really?  shouldit the forced data structure still use memory?
01:30:14 <wagle_home> oh..  nm
01:30:48 <wagle_home> (i see how the computations could hold on to things that would go away once the computation is complete)
01:30:59 <aleator_> Is there any reasonable way to figure out what exactly is "thunktrashing" in my code?
01:31:10 <glguy> profiling?
01:31:53 <quicksilver> my point, anyhow, is it's often easier to add strictness at build-up time.
01:31:53 <wagle_home> (whats thunktrashing?)
01:31:55 <roconnor> @type withFile
01:31:56 <lambdabot> Not in scope: `withFile'
01:31:58 <aleator_> can I do that with ffi?
01:32:02 <quicksilver> than try to force afterwards.
01:32:16 <roconnor> @hoogle withFile
01:32:16 <lambdabot> System.IO.withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
01:32:39 <roconnor> I don't think I knew about withFile.
01:32:42 <aleator_> wagle_home: my just invented term for having lazy computations holding on to stuff and making the machine swap until it dies.
01:33:43 <quicksilver> aleator_: these things normally aren't very hard to spot but without knowing about your code its hard to say :)
01:33:48 <wagle_home> ooo..  official sounding though
01:34:28 <aleator_> In this case it is really foul, since it (seems to be) holding 3000 images instead of 6000 numbers that it is supposed to calculate from them (I quess)
01:34:45 <hpaste>  smashor pasted "(no title)" at http://hpaste.org/6095
01:34:48 <aleator_> Never figured I would have such problems with memory leaks when starting up haskell.
01:35:01 <roconnor> is withFile new?
01:35:05 <roconnor> newish?
01:35:32 <aleator_> quicksilver: It is "research code" done "under a deadline". Mean there is nothing easy to spot in the whole thing :)
01:37:17 <roconnor> ah withFile isn't even in GHC 6.6
01:37:26 <roconnor> no wonder I haven't used it before.
01:39:31 <wagle_home> could be traversing the main list from the beginning to an index/position in each thunk
01:41:17 <oerjan> roconnor: it's not in the 6.8.1 release notes either...
01:43:30 <oerjan> aleator_: is there some kind of map over those images?  maybe you could paste that function
01:44:03 <oerjan> you are not using foldl are you? ;)
01:47:00 <aleator_> oerjan: some kind yes. I don't know how to paste this, because it uses rather lot of code, of which I don't know which is relevant.. foldl? Not visibly. Might hide in some library though.
01:49:52 <oerjan> aleator_: i am thinking maybe you are somehow reading in all the images before starting the number calculation?
01:50:59 <quicksilver> aleator_: as a general rule, whenever you calculate a summary value (like a single Int) from a very large computation, make it strict.
01:51:20 <quicksilver> as a second general rule, when you design a structure which stores summary values or computation results, make the fields strict.
01:51:34 <oerjan> hm are you using Parsec to read a list of images?  wild guess here
01:52:01 <quicksilver> some people say primitive types (Int,Double) inside custom types should always be strict.
01:52:15 <quicksilver> I think that takes things a bit far, but might be a decent guideline in your case.
01:53:27 * oerjan realizes he has no clue what he is discussing
01:53:48 <oerjan> paste the main function maybe?
01:54:06 <wagle_home> whatever happened to strictness analysis?  it used to (seem to) be big, but i havent even seen or heard the words since way back when
01:54:27 <oerjan> wagle_home: ghc does strictness analysis
01:54:39 <oerjan> called demand analysis these days
01:54:52 <wagle_home> ah
01:55:35 <wagle_home> but i guess it doesnt help him here
01:56:16 <roconnor> @src foldl
01:56:16 <lambdabot> foldl f z []     = z
01:56:16 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
01:56:29 <hpaste>  aleator pasted "Ugly, hurried, embarrassing and leaks memory." at http://hpaste.org/6096
01:56:35 <oerjan> aleator_: perhaps paste the main function, just in case there is some simple mistake in the top data flow...
01:56:49 <oerjan> ah
01:57:25 <aleator_> Some times you just don't have time to think while coding :/
01:57:37 <slarba> aleator_: try to make smaller functions
01:57:51 <oerjan> aleator_: is loadSampleImages reading lazily?
01:57:52 <slarba> those are quite long. makes it harder to profile where the leak is
01:58:25 <slarba> I had a bad leak in my ip stack lately
01:58:30 <roconnor> @src map
01:58:30 <lambdabot> map _ []     = []
01:58:30 <lambdabot> map f (x:xs) = f x : map f xs
01:58:32 <aleator_> slarba: I know it is ackward. No need to tell me this.
01:58:40 <aleator_> oerjan: Yes
01:59:39 <oerjan> genetic programming/neural networks?
02:00:28 <aleator_> oerjan: Huh? no, geurts ExtraTrees for classification.
02:00:28 <oerjan> aleator_: is imgs the images that get held on to too long?
02:01:49 <oerjan> oh. mapM (splitClass 0.5) imgs >>= return.unzip  looks dangerous
02:02:00 <aleator_> oerjan: No, that would be ok, since imgs take only static amount of memory. It is maybe the trainingImages/validationSampling..
02:02:09 <oerjan> oh
02:02:09 <skorpan> does anyone know of a tutorial for vty?
02:02:48 <aleator_> there are only about 600 images size of stamps. Then I sample 1300 samples of each image, each test which is no longer ok, if it stucks to memory..
02:03:01 <aleator_> i mean 130. Not 1300 :)
02:04:43 <oerjan> um there's an indentation error there
02:05:06 <oerjan>          let process seed = do
02:05:08 <oerjan>              setStdGen $ mkStdGen seed
02:05:25 <oerjan> is setStdGen really indented the same as process?
02:06:16 <aleator_> huh? process is setStdGen. and next few dozen lines.
02:06:23 <skorpan> lol
02:06:39 <oerjan> that's not strictly legal indentation but maybe ghc allows it
02:06:40 <aleator_> Well, This is why I was hesitant to make the paste. :) It is mindbogglingly ugly code
02:06:59 <aleator_> oerjan: How so?
02:07:14 <oerjan> let and do both start indentation blocks.
02:07:34 <oerjan> the setStdGen at the same indentation as the process should have ended the do block immediately
02:08:25 <aleator_> Really? I thought to end it I would need to indent to level of let. Otherwise, where do rest of the lines belong to?
02:08:28 <quicksilver> and given a syntax error
02:08:33 <quicksilver> aleator_: the let
02:08:37 <quicksilver> let foo = bar
02:08:39 <quicksilver>     baz = bam
02:08:47 <oerjan> you don't need to repeat let for each declaration
02:08:56 <quicksilver> but you should get a syntax error because it's expecting an '=' then
02:09:02 <quicksilver> if that was ghc's interpretation.
02:09:08 <quicksilver> maybe that's a tabe and not four spaces :)
02:09:13 * oerjan thinks he saw something about ghc being more lenient
02:09:17 <aleator_> No, it is spaces.
02:09:29 <explisixjelly> I have a list of pairs containing associations, similar to a Map. but it is no Map. how can I lookup something?
02:09:36 <glguy> :t lookup
02:09:37 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
02:09:38 <EvilTerran> ?hoogle lookup
02:09:39 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
02:09:39 <lambdabot> Data.List.lookup :: Eq a => a -> [(a, b)] -> Maybe b
02:09:39 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
02:09:45 <explisixjelly> heh. thanks
02:10:14 <oerjan> "GHC is a little less strict about the layout rule when used in do expressions. Specifically, the restriction that "a nested context must be indented further to the right than the enclosing context" is relaxed to allow the nested context to be at the same level as the enclosing context, if the enclosing context is a do expression."
02:10:50 <oerjan> except here the enclosing context is a let?
02:12:42 <aleator_> Well, I know how to make this code neat. That is not the problem. It just takes more time than I currently have.
02:16:21 <oerjan> the thing that worries me here is that you seem to be generating random numbers in the IO monad to generate things, and mapM'ing over the images to get the trainingSamples
02:16:37 <roconnor> @src foldr
02:16:37 <lambdabot> foldr f z []     = z
02:16:37 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
02:16:48 <oerjan> but generating random numbers in the IO monad certainly destroys any laziness, because it is strictly sequenced
02:17:13 <oerjan> so most of trainingSamples may be forced at definition point
02:17:44 <quicksilver> well the (Strictly generated) random number can still be bundled up into a large thunk
02:17:52 <quicksilver> with artithmetic operations.
02:18:15 <oerjan> i am not saying this strictness is a _good_ thing. on the contrary.
02:18:46 <aleator_> This does not rely on laziness. All image structures easily fit into memory, if there is only one set of them alive at the time..
02:19:00 <oerjan> the problem is the mapM
02:19:25 <oerjan> the entire trainingSamples list is allocated essentially at once
02:19:59 <aleator_> cs <- mapM.. ?
02:20:13 <oerjan> or concatMapM
02:20:38 <brauner> hi
02:20:40 <oerjan> hm, how many random numbers do you generate per sample?
02:20:51 <aleator_> oerjan: Yes, it should be allocated all at once. It is just dozen megabytes in size..
02:20:59 <brauner> I just read the wikibook introduction to GADTs
02:21:01 <oerjan> ok
02:21:10 <brauner> there is an example : safelists
02:21:28 <aleator_> oerjan:  about 200-400.
02:21:35 <brauner> with their types depending on another type whichs says if they are empty or not
02:21:49 <brauner> head is defined
02:21:52 <oerjan> aleator_: is it mapM process seeds that has too big result (if partially unevaluated) then?
02:22:02 <brauner> then there is an open question : "can you define tail for these lists ?"
02:22:13 <brauner> my guess is that it is not possible
02:22:23 <brauner> but do you know the answer ? :)
02:23:11 <Baughn> brauner: It's impossible to make it /as dynamic as the normal tail/. That is not quite the same as it being impossible in all cases
02:23:29 <Baughn> Having to prove at compile-time that you won't call tail on an empty list, though..
02:23:40 <aleator_> oerjan: That might be it.. But as the process runs it incrementally allocates all memory little by little. And the process results should not take more than few bytes each..
02:24:10 <brauner> Baughn: yeah but what would the return type of tail be then ?
02:24:23 <aleator_> Also, it seems that I'm doing +RTS -K<lots> on the script that runs it.. hmm..
02:24:25 <brauner> it's something like   List x (empty|nonempty)
02:24:31 <oerjan> aleator_: i guess something in (errorValidation,errorTraining,confusionMatrix,undefined,c) is the unevaluated culprit
02:24:36 <brauner> but is it possible to express that ?
02:24:37 <Baughn> brauner: I'm not sure. I'd probably encode the size of the list in the type.
02:25:14 <brauner> Baughn: I've read how to do this but this is much more heavy machinery
02:25:44 <brauner> for the moment, I just dont' manage to compile a definition of tail for these lists
02:25:55 <aleator_> oerjan: oh.. Oh indeed. That must be it! confusionMatrix requires the samples!
02:27:02 <Baughn> brauner: It's a fundamentally silly thing to want, but people keep doing impressive things using the same machinery..
02:29:05 <oerjan> aleator_: c looks suspicious too i think
02:29:30 <brauner> Baughn: ok, i'm convinced it's usefull to encode list size in the list but i'm just curious about haw i can define tail for these lists depending on empty and nonempty types
02:29:42 <brauner> s/haw/how/
02:29:45 <oerjan> but maybe it gets evaluated enough by the other calculations that use it
02:30:13 <brauner> Baughn: i wonder if i didn't miss some feature of the type system which allows to do this
02:30:29 <Baughn> brauner: Just guessing.. make tail a typeclass function, and don't define it for the empty list type?
02:30:29 <aleator_> oerjan: c or c'?
02:30:44 <Baughn> brauner: You were talking about GADTs, though. I haven't used those.
02:30:59 <aleator_> there is print $ length $ show c there which should really evaluate it.
02:31:03 <brauner> ok, i'll look at your propostion
02:31:08 <oerjan> c' is not returned but c is just a wrapper around it isn't it
02:31:19 <aleator_> Yes.
02:31:25 <oerjan> ah
02:31:28 <brauner> i understand GADTs better than typeclasses because i'm not an haskell programmer but i come from the coq world
02:32:05 <aleator_> oerjan: Now it seems bit more stable in consuming memory..
02:32:33 <Baughn> brauner: Typeclasses are simple, though. All the magic is in unification.. and existential typing, if you use that
02:33:19 <brauner> based on what i know of typeclasses i've tried something like that but it doesn't pass the compiler :
02:33:24 <brauner> class Info n
02:33:24 <brauner> instance Info Empty
02:33:24 <brauner> instance Info NonEmpty
02:33:35 <aleator_> oerjan: thanks
02:33:40 <brauner> safeTail :: SafeList x y -> (forall y. Info y => SafeList x y)
02:33:53 <oerjan> yay :)
02:33:53 <brauner> Baughn: is it the right way to do it ?
02:34:10 <brauner> sorry, i meant : safeTail :: SafeList x NonEmpty -> (forall y. Info y => SafeList x y)
02:34:29 <Baughn> brauner: I have no idea. It's not what I'd do, though
02:34:50 <brauner> how would you do ?
02:35:06 <brauner> (if you mind)
02:35:33 <Baughn> brauner: Something like class Lastable a where last : Lastable a -> a (er.. if that was the right syntax), and then only instance Lastable for the non-empty list type
02:36:08 <Baughn> brauner: ..also, that type was wrong. Should be a -> b, I suppose. Er. You should ask someone else.
02:36:17 <brauner> ok
02:36:19 <brauner> thanks a lot
02:36:37 <brauner> i'll look deeper at typeclasses
02:37:05 <Baughn> brauner: You want type arithmetic, I suppose
02:37:27 <brauner> you mean presburger in the typing procedure ?
02:37:38 <Baughn> http://haskell.org/haskellwiki/Type_arithmetic <-- This looks more like what I was thinking of
02:37:59 <brauner> yeah, ok, i've read that
02:38:12 <Baughn> Now identify "Zero" with "Empty list"
02:38:15 <brauner> but that seems much more compilcated that waht i'd like to define :)
02:38:24 <Baughn> No, that's the simple way. ;)
02:38:33 <Baughn> THe complex way would be to define /binary/ type arithmetic
02:39:06 <Baughn> (And don't even ask what the performance on this is like)
02:39:10 <brauner> Type-Level Lambda Calculus, that's insane :)
02:39:33 <wagle_home> the world needs a programming language which lets the programmer program in types, and nothing else
02:39:36 <brauner> but unification is not decidable anymore
02:39:50 <brauner> wagle_home: that's called calculus of constructions
02:40:03 <brauner> but typechecking has to be done by hand :)
02:42:03 <brauner> wagle_home: did look at coq, agda or some similar prover based on dependant type theory ?
02:42:08 <brauner> that's really cool
02:43:08 <wagle_home> a little coq..
02:43:20 <wagle_home> on my list of things to learn
02:44:38 <brauner> i only know coq and i'm discovering haskell
02:44:49 <brauner> i was amazed that GADTs were available
03:03:53 <roconnor> @src forM
03:03:53 <lambdabot> forM = flip mapM
03:13:37 <roconnor> @bab nl en ontvangen
03:13:37 <lambdabot>   to receive
03:48:48 <notsmack> so what's the best way to read an IEEE float out of a bytestring?
03:52:40 <wagle_home> i dunno, but i see interesting looking hits for google float bytestring cast haskell
03:52:58 <notsmack> i just found somebody suggesting an unsafeCoerce# solution
03:53:06 <jrx> hi
03:53:17 <jrx> I'm writing application using opengl in haskell
03:53:38 <jrx> which uses lots of state processing
03:53:53 <wagle_home> eww..  well, one important thing to consider is the endianness of the float
03:53:56 <jrx> and all of the opengl calls run in IO monad
03:54:25 <jrx> I have read that, to accomplish this I need monad transformers
03:54:30 <notsmack> wagle_home: right.
03:54:47 <jrx> could you point me to some resources about them?
03:55:23 <wagle_home> @go monad transformer tutorial
03:55:25 <lambdabot> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
03:55:25 <lambdabot> Title: Monad Transformers Step by Step
03:55:47 <wagle_home> hmm..  not the one i was hoping for
03:56:08 <jrx> how I can easily translate my existing code in IO monad using normal state calculation into .. code using IO and State
03:56:16 <dcoutts> mnislaih: ping
03:56:22 <quicksilver> jrx: you don't nevecessarily need to use monad transformers
03:56:26 <mnislaih> hi dcoutts
03:56:34 <quicksilver> jrx: in simple cases it's often easier to manage stuff by hand.
03:56:36 <quicksilver> YMMV.
03:56:48 <quicksilver> lifting to a state trasfnromer is going to be a lot of calls to liftIO.
03:56:52 <dcoutts> mnislaih: sounds like a good plan re command line & config files, one bit I didn't get...
03:56:58 <quicksilver> I don't normally bother, but I do use 'StateT-like techniques'.
03:57:08 <wagle_home> ahh..  the cavalry has arrived...
03:57:15 * wagle_home goes to bed
03:57:26 <dcoutts> mnislaih: I don't understand what you mean about FieldDescr 'instances' are provided in CabalInstall and them having to move to Cabal?
03:57:28 <jrx> quicksilver: I do like that now, but things begun to look ugly
03:57:43 <dcoutts> mnislaih: is that just the bit about parsing, that we have to define them together
03:58:17 <mnislaih> in Hackage.Config you have several lists of FieldDescrs for SavedConfig
03:58:20 <dcoutts> mnislaih: I just want to double check that we'll be able to define extra flag types in cabal-install that are not used in the Cabal lib
03:58:21 <quicksilver> jrx: I normally have a few different kinds of action in my opengl programs.
03:58:31 <quicksilver> jrx: WorldState -> IO ()
03:58:41 <quicksilver> WorldState -> WorldState
03:58:48 <quicksilver> WorldState -> IO WorldState
03:58:51 <wagle_home> notsmack, maybe you should ask your question again
03:59:15 <quicksilver> being, respectively : needs to access the state but not change it, changes the state but does no IO, and access+change+IO.
03:59:16 <mnislaih> that will have to be defined in Distribution.Setup, so that you can use them as Options. But there should be no problem to define other FieldDescrs in cabal-install dcoutts
03:59:36 <dcoutts> mnislaih: so in the end our 'SavedConfig' or whatever equivalent we end up with in your system will be composed of the ConfigFlags info and some extra flags/info that is specific to cabal-install (like hackage servers etc)
03:59:41 * notsmack eyes the Binary Double instance suspicously
03:59:45 <dcoutts> mnislaih: great
03:59:52 <mnislaih> exactly, I forgot to mention that in the ticket dcoutts
04:00:14 <dcoutts> mnislaih: you can see what we've done already with the installCommand in cabal-install,
04:00:20 <oerjan> notsmack: i vaguely recall that is not IEEE
04:00:26 <jrx> quicksilver: yep, they can be separated like that, actually I have only two of them:
04:00:28 <mnislaih> dcoutts: thanks, I will take a look
04:00:32 <dcoutts> installCommand :: CommandUI (Cabal.ConfigFlags, InstallFlags)
04:00:34 <notsmack> oerjan: yeah, not sure how i'd handle byte order even if it were
04:00:40 <jrx> renderFrame :: WorldState -> IO ()
04:00:45 <oerjan> i think it is portable however
04:00:55 <jrx> processEvents :: WorldState -> IO WorldState
04:01:00 <dcoutts> mnislaih: and we use map (liftOption fst (\a (_,b) -> (a,b))) :: [Option a] -> [Option (a,b)]
04:01:08 <oerjan> notsmack: .Binary.Put has general byteorder functions
04:01:14 <dcoutts> mnislaih: to lift the Cabal.ConfigFlags into (Cabal.ConfigFlags, InstallFlags)
04:01:36 <notsmack> oerjan: i'm trying to read currently, not put
04:01:44 <oerjan> .Binary.Get then
04:01:45 <dcoutts> mnislaih: liftOption there is a pair of getter and setter transformers
04:02:06 <quicksilver> jrx: yeah. I find this a relatively good way to arrange things.
04:02:14 <notsmack> oerjan: yeah, i'm looking at Get, but i can't see how to get anything besides an unsigned int
04:02:24 <quicksilver> jrx: I think you'll find using StateT adds more boilerplate than it removes.
04:02:39 <dcoutts> mnislaih: which is one way at least of making derived commands and their corresponding command line parsing description, by a projection/injection with a bigger type
04:02:42 <quicksilver> jrx: after all, you don't want renderFrame :: StateT WorldState IO ()
04:03:04 <smg> @pl f x y = 0.5*x*y
04:03:05 <lambdabot> f = (*) . (0 . 5 *)
04:03:18 <quicksilver> jrx: because, that would make it possible for rednerFrame to alter the state, which you wouldn't work.
04:03:24 <quicksilver> jrx: which you wouldn't want.
04:03:36 <quicksilver> jrx: more precise types are better.
04:03:44 <mnislaih> ok dcoutts, so what are the [FieldDescr ConfigFlags] for install used for, and where are they defined?
04:04:13 <dcoutts> mnislaih: in Hackage/Config.hs
04:04:16 <mnislaih> dcoutts  ah ok, you said Options, nevermind
04:04:17 <smg> > let area x y = 0.5*x*y in area (readLn >>= return) (readLn >>= return)
04:04:18 <lambdabot>   add an instance declaration for (Fractional (IO a))
04:04:25 <quicksilver> jrx: of course, you could try the StateT approach. Nothing like learning by doing ;)
04:04:35 <quicksilver> jrx: and I'd be happy to help you do so.
04:04:43 <quicksilver> I'm just saying I'm not convinced it's a big win.
04:04:51 <dcoutts> mnislaih: I'd expect the Hackage/Config.hs stuff to be completely replaced by your work
04:05:47 <oerjan> > let area x y = 0.5*x*y in liftM2 area readLn readLn
04:05:49 <lambdabot>  <IO Double>
04:06:07 <mnislaih> dcoutts yay. It seems that Options and Fields are essentially two views of the same thing. It is good if they can be unified without becoming too confusing
04:06:34 <dcoutts> mnislaih: yes they are, I modelled the Option on the Fields stuff :-)
04:06:45 <jrx> quicksilver: so which are the cases, when I should definetly use StateT IO ?
04:06:47 <oerjan> smg: oh and x >>= return  = x for any monad
04:06:58 <dcoutts> mnislaih: though I didn't use a ReadP parser for Options, which in retrospect is a blessing and a curse
04:07:17 <quicksilver> jrx: normally when you have other monads in the mix it becomes a bit complex without the transformers to help
04:07:23 <quicksilver> jrx: e.g. mix in Writer and Error.
04:07:25 <dcoutts> mnislaih: a blessing because ReadP is a pita, but not good because we have no error reporting facility when flag arguments do not parse
04:07:53 <dcoutts> mnislaih: returning (Either String flag) should help there
04:07:54 <mnislaih> dcoutts I know, I will have to translate all the parsers in Options to ReadP
04:08:06 <smg> oerjan: ah that's a monadic law isn't it?
04:08:17 <mnislaih> dcoutts:  or define a parseRead :: (String -> a) -> ReadP r a
04:08:20 <smg> oerjan: so liftM2 makes out of an action a value?
04:08:36 <smg> but liftM2 is in Monad module?
04:08:36 <mnislaih> dcoutts which handles failure. I don't think that's even possible in H98
04:08:38 <oerjan> @src liftM2
04:08:38 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
04:08:55 <dcoutts> mnislaih: ReadP is a most unfriendly parse framework since there is no error reporting at all
04:09:14 <dcoutts> mnislaih: and we do kind of need it, eg reporting when verbosity is out of range etc
04:09:15 <oerjan> smg: yes, the second monad law
04:09:34 <mnislaih> dcoutts: why not switch to Parsec then ? or try to extend ReadP with error reporting, that should be doable.
04:09:42 <quicksilver> smg: liftM2 takes a pure binary function and turns it into a binary action.
04:09:46 <mnislaih> after all, you have your own cooked version of ReadP in Compat.
04:09:47 <jrx> quicksilver: ok, I see
04:09:50 <oerjan> and nothing makes a value out of an action for a general monad
04:09:59 <dcoutts> mnislaih: perhaps if we just use String -> Either String flag, it gives the option of using a parser or something ad-hoc on a per-option basis
04:10:06 <jrx> quicksilver: any more techniques you would advise me to use in opengl apps?
04:10:09 <dcoutts> mnislaih: almost all the fields are trivial
04:10:21 <quicksilver> jrx: when your structure becomes more complex you start to want your own combinators.
04:10:34 <quicksilver> jrx: e.g. instance of ws <- get env; let foo = bar ws;
04:10:45 <quicksilver> jrx: you just want ot write foo <- getBar
04:10:46 <dcoutts> mnislaih: yes, I'm tempted to replace ReadP with the BSD versions of malcolmw's polyparse for the .cabal file parsing at some future date
04:11:03 <dcoutts> mnislaih: but I don't think we can do that just yet, it's a pretty hefty change
04:11:31 <quicksilver> jrx: then you start wanting to be a bit cleverer.
04:11:48 <quicksilver> (which doesn't force you to use StateT but it might be convenient).
04:12:03 <quicksilver> jrx: for OpenGL I have found my "with" combinator to be very useful
04:12:05 <mnislaih> dcoutts:  I will go with String -> Either String field then for Field. Back to latex hacking now !
04:12:20 <quicksilver> jrx: lets you save/restore multiple attributes at once, like depth buffer writes.
04:12:21 <mnislaih> Haskell hacking will have to wait until the weekend
04:12:30 <smg> quicksilver: ah nice
04:12:35 <smg> let area x y = 0.5*x*y in liftM2 area (putStr "Base: " >> readLn) (putStr "Height: " >> readLn)
04:12:39 <smg> so this is completly okay now
04:12:51 <dcoutts> mnislaih: thanks for taking the issue on, it's a great help
04:13:02 <jrx> quicksilver: conceptually something like preservingMatrix?
04:13:17 <quicksilver> jrx: exactly but more general.
04:13:19 <mnislaih> dcoutts: no need to give them.
04:14:05 <quicksilver> jrx: with [light (Light 1) := Enabled,depthMask := Disabled] act
04:14:14 <quicksilver> jrx: for example.
04:15:05 <jrx> @hoogle :=
04:15:05 <lambdabot> Hoogle Error: Parse Error: Unexpected character ':='
04:15:11 <jrx> @hoogle (:=)
04:15:11 <lambdabot> Did you mean: (:=)
04:15:11 <lambdabot> Prelude.undefined :: a
04:15:11 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
04:15:13 <quicksilver> it's mine.
04:15:19 <quicksilver> although there is something similar in wxWidgets.
04:15:23 <quicksilver> I didn't know that when I wrote it though.
04:16:13 <quicksilver> jrx: http://haskell.org/pipermail/haskell-cafe/2007-October/032568.html
04:16:14 <lambdabot> http://tinyurl.com/2oaa36
04:16:15 <jrx> quicksilver: what it does?
04:16:16 <smg> hey that liftM is cool!
04:16:26 <quicksilver> jrx: source and some explanation there.
04:16:49 <hallongrottan> @hoogle [a] -> b
04:16:50 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
04:16:50 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
04:16:50 <lambdabot> Data.List.foldl :: (a -> b -> a) -> a -> [b] -> a
04:16:57 <hallongrottan> sweet
04:17:26 <ohub> :t length
04:17:27 <lambdabot> forall a. [a] -> Int
04:17:33 <ohub> ah, right
04:18:31 <hallongrottan> @tell Smurfen_ i fixed the turtle graphics
04:18:31 <lambdabot> Consider it noted.
04:18:49 <quicksilver> jrx: if you think it looks useful I have a slightly newer version.
04:19:19 <jrx> looks pretty elegant
04:19:20 <Smurfen_> "ok"
04:19:21 <lambdabot> Smurfen_: You have 1 new message. '/msg lambdabot @messages' to read it.
04:19:28 <Smurfen_> orly...
04:19:32 <jrx> that's what I like in haskell
04:21:16 <hpaste>  quicksilver pasted "New version of 'With.hs'" at http://hpaste.org/6097
04:21:29 <quicksilver> jrx: pasted is slightly more elegantly written.
04:21:40 <quicksilver> jrx: and it adds a 'Preserving' constructor, so you can write:
04:22:03 <quicksilver> with [ depthMask := Disabled, Preserving currentColor]
04:22:26 <quicksilver> where you want to save the value of currentColor to restore it, but have no new value in mind.
04:22:34 <smg> quicksilver:
04:22:43 <quicksilver> smg:
04:23:00 <smg> > putStr "Your name: " ++ (liftM getLine)
04:23:01 <lambdabot>  Couldn't match expected type `[a]' against inferred type `IO ()'
04:23:13 <smg> how can i get this working?
04:23:18 <quicksilver> there are only 43 errors in that line.
04:23:25 <quicksilver> which one shall we take first?
04:23:27 <quicksilver> ;P
04:23:31 <jrx> quicksilver: now give me a couple of seconds to try to understand how it works
04:23:33 <jrx> ;)
04:23:34 <araujo> morning
04:23:39 <smg> quicksilver: wait a sec
04:23:46 <quicksilver> firstly, that brackets as (putStr "Your name:") ++ (liftM getLine)
04:24:16 <quicksilver> jrx: ;)
04:24:27 <smg> putStr ("Your name: " ++ (liftM getLine))
04:24:50 <hallongrottan> > putStrLn "hej"
04:24:52 <lambdabot>  <IO ()>
04:24:55 <hallongrottan> lol
04:25:40 <yondalf> should we just tell smg the correct way to do it?
04:25:52 <Baughn> > liftM ("Your name: " ++) =<< getLine
04:25:53 <lambdabot>  Couldn't match expected type `IO' against inferred type `[]'
04:26:27 <quicksilver> smg: the problem is that putStr is expecting a string
04:26:33 <quicksilver> smg: you can't give it an IO action
04:26:40 <quicksilver> smg: (and you can't make a string from an IO action)
04:26:42 <smg> ok
04:26:45 <quicksilver> you can never 'get out' of the IO
04:26:49 <smg> i thought i could make it like with liftM2
04:26:53 <quicksilver> you can put stuff in and mess about whilst in there.
04:26:57 <quicksilver> You can, but not quite like that.
04:27:02 <smg> ah okay
04:27:05 <quicksilver> most people would just write this:
04:27:18 <quicksilver> line <- getLine ; putStr ("Your name : " ++ line)
04:27:23 <smg> yeah sure :P
04:27:28 <quicksilver> however, if you're trying to be clever, watch this:
04:27:31 <quicksilver> :t getLine
04:27:31 <smg> i just wanted to get around with liftM :)
04:27:32 <lambdabot> IO String
04:27:41 <quicksilver> :t ("Your name : " ++)
04:27:42 <lambdabot> [Char] -> [Char]
04:27:50 <quicksilver> :t liftM ("Your name : " ++) getLine
04:27:51 <lambdabot> IO [Char]
04:27:52 <Baughn> :t liftM ("Your name: " ++)
04:27:53 <lambdabot> forall (m :: * -> *). (Monad m) => m [Char] -> m [Char]
04:28:00 <Baughn> ..doh
04:28:02 <quicksilver> :t liftM ("Your name : " ++) getLine >>= putStr
04:28:03 <lambdabot> IO ()
04:28:16 <quicksilver> which might look better written with the right-to-left =<<
04:28:25 <quicksilver> :t putStr =<< liftM ("Your name : " ++) getLine
04:28:26 <lambdabot> IO ()
04:28:35 <quicksilver> and perhaps with infix liftM?
04:28:44 <quicksilver> :t putStr =<< ("Your name : " ++) `liftM` getLine
04:28:45 <lambdabot> IO ()
04:28:59 <smg> interesting
04:29:29 <smg> quicksilver: ty
04:29:42 <jrx> quicksilver: lines 10-11 look a bit cryptic to me
04:30:08 <jrx> does this get mean get from State monad?
04:30:09 <quicksilver> smg: the fundamental different between this and your earlier example is you have two IO actions in series.
04:30:20 <jrx> and what that `fmap` does?
04:30:28 <smg> @type fmap
04:30:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:30:38 <smg> quicksilver: okay :)
04:30:45 <quicksilver> smg: you're using the result of 'getLine' (an IO action) as an argument of 'putStr' (an IO action)
04:30:51 <jrx> yep, I know fmap in general
04:30:56 <quicksilver> smg: to do that you basically need to use >>= or one of its friends.
04:31:04 <jrx> but in this case.. what is the functor?
04:31:35 <Botje> it was colonel mustard with the IO monad!
04:31:35 <quicksilver> jrx: "get" there is a magix openGL thing.
04:31:52 <quicksilver> jrx: for example I could write "col <- get currentColor"
04:31:58 <quicksilver> or "df <- get depthFunc"
04:32:08 <quicksilver> jrx: it gets the values from stuff that you can $=.
04:32:57 <quicksilver> jrx: the fmap is just a cute way of writing : do { value <- get a ; return (a := value) }
04:33:22 <smg> quicksilver: i see
04:33:39 <quicksilver> jrx: note that ":=" doesn't actually do anything. It's just a constructor.
04:33:53 <quicksilver> the only clever thing about := is its funky type.
04:34:13 <smg> <quicksilver> smg: liftM2 takes a pure binary function and turns it into a binary action.
04:34:21 <quicksilver> yup
04:34:26 <smg> quicksilver: this means i can give with liftM2 liftM3 a function arguments which are actions
04:34:26 <smg> ?
04:34:32 <quicksilver> yes, exactly
04:34:38 <smg> @type liftM2
04:34:39 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
04:34:42 <quicksilver> liftM3 f a b c
04:34:46 <hallongrottan> how do i get access to the HGL library in ghc?
04:34:52 <hallongrottan> do i need to recompile it?
04:34:54 <quicksilver> ^^ give 'f', which is a pure function, three actions as arguments.
04:35:09 <smg> quicksilver: hehe okay now i need to see the source for liftM2
04:35:11 <smg> @src liftM2
04:35:11 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
04:35:28 <smg> quicksilver: omg this makes things so awesome clear :]
04:35:45 <smg> so in general i don't need liftM2
04:35:46 <quicksilver> hallongrottan: you certainly don't need to recompile ghc.
04:35:56 <pjd> liftA2 f x y = f <$> x <*> y
04:35:57 <hallongrottan> quicksilver: oh, how do i get access to it then?
04:36:02 <jrx> quicksilver: ok, I got it know
04:36:07 <quicksilver> hallongrottan: I don't know anything about where you get HGL from though.
04:36:15 <hallongrottan> that's odd
04:36:20 <jrx> quicksilver: really smart thing with this Preserving
04:36:50 <pjd> liftA2 (+) [10] [1]
04:36:54 <pjd> > liftA2 (+) [10] [1]
04:36:55 <lambdabot>  [11]
04:36:56 <quicksilver> jrx: I just noticed a lot of my code was doing fiddly thiings preserving stuff by hand.
04:37:01 <pjd> > liftA2 (+) [10,20] [1,2]
04:37:01 <lambdabot>  [11,12,21,22]
04:37:09 <quicksilver> jrx: and found a way to make it much shorter and clearer!
04:37:26 <pjd> > liftA2 (+) [10,20] []
04:37:27 <lambdabot>  []
04:38:11 <Botje> > liftM2 (+) [10,20] [1,2] -- just checking
04:38:11 <lambdabot>  [11,12,21,22]
04:39:03 <pjd> liftA* == liftM*, generally speaking
04:39:04 <Syzygy-> > (+) <$> [10,20] <*> [1,2]
04:39:05 <lambdabot>  [11,12,21,22]
04:39:10 <Syzygy-> > [10,20] <*> [1,2]
04:39:11 <lambdabot>   add an instance declaration for (Num (a -> b))
04:39:15 <Syzygy-> Doh.
04:39:37 <pjd> > pure (+) <*> [10,20] <*> [1,2]
04:39:37 <lambdabot>  [11,12,21,22]
04:40:01 <pjd> which is equivalent to:
04:40:01 <pjd> > [(+)] <*> [10,20] <*> [1,2]
04:40:03 <lambdabot>  [11,12,21,22]
04:40:28 <pjd> > [(+),(-)] <*> [10,20] <*> [1,2]
04:40:29 <lambdabot>  [11,12,21,22,9,8,19,18]
04:42:14 <pjd> > [id,map toLower,map toUpper] <*> ["Hello","World"]
04:42:14 <lambdabot>  ["Hello","World","hello","world","HELLO","WORLD"]
04:43:09 <Saizan> > [toLower,toUpper] <*> "hello"
04:43:10 <lambdabot>  "helloHELLO"
04:45:34 <jrx> quicksilver: does forall has some meaning or does it mean the same as if it wasn't written
04:45:39 <jrx> ?
04:47:28 <Baughn> @ty <*>
04:47:29 <lambdabot> parse error on input `<*>'
04:47:34 <Baughn> @ty (<*>)
04:47:35 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
04:47:40 <Baughn> jrx: Yes
04:48:25 <Baughn> jrx: To both, that is. The default typing includes a forall at the top level, but it still has an effect elsewhere
04:48:40 <Baughn> jrx: See http://haskell.org/haskellwiki/Existential_type
04:49:55 <quicksilver> jrx: erm, it has to be written if you want quantification on a constructor.
04:50:04 <quicksilver> jrx: because that's an extension anyway.
04:50:11 <jrx> but forall is some type of extension, it isn't in haskell98, am I right?
04:50:26 <quicksilver> correct.
04:50:30 <quicksilver> existentials aren't in h98
04:50:45 <jrx> quicksilver: answer quicker than question ;)
04:50:56 <quicksilver> and neitehr are type-classes on constructors.
04:51:46 <quicksilver> there are ways of encoding existentials in h98, I think?
04:54:12 <Jomyoot> To what extent is parallelism (erlang-type) supported by Haskell?
04:55:01 <Baughn> Jomyoot: It doesn't support clusters, at least not without an extra library
04:55:11 <JohnMeacham> starting to see some interesting nobench results... jhc is super good at tight mathematical loops. for example, the 'loop' test is 5.21s for ghc with -O2, and 0.29s for jhc.
04:55:18 <Cheery> does there exist a system for installing with the path or module name?
04:55:39 <Jomyoot> Would it currently support parallel processing better than Roby or Python?
04:56:02 <Cheery> found, nvm
04:57:16 <Baughn> Jomyoot: Oh yes. Easily.
04:57:38 <Baughn> Jomyoot: There's a fairly large library in Control.Concurrent and Control.Parallel
04:57:54 <Jomyoot> does it come natural to programming?
04:58:04 <Baughn> As natural as parallel programming ever does
04:58:05 <Jomyoot> i mean in the future (2 years) will it match paralleism found in erlang?
04:58:30 <yondalf> JohnMeacham: is jhc good enough for day-to-day usage though?
04:59:27 <Baughn> Jomyoot: The parallel control structures are designed around shared memory instead of message-passing. Given that memory doesn't ever /change/, this is easier than message passing, but doesn'T scale as easily
04:59:39 <Baughn> Jomyoot: Control.Concurrent should be easy to adapt to clusters, though
05:00:29 <pejo> Jomyoot, there's work on data parallell haskell going on right now. As usual it's hard to tell how long it will take to complete a large research task though.
05:00:39 <Baughn> Jomyoot: Control.Concurrent.Chan, in particular, is the exact same abstraction you'd be used to from Erlang. There just happens to be a lot of others as well.
05:01:24 <JohnMeacham> yondalf: if your day to day usage involves bug fixing jhc, then sure. :)
05:01:52 <yondalf> JohnMeacham: :-)
05:02:44 <Baughn> Jomyoot: http://www.haskell.org/ghc/docs/latest/html/libraries/parallel/Control-Parallel.html <-- It doesn't get easier than par, though
05:02:45 <lambdabot> http://tinyurl.com/2ktqoz
05:03:24 <quicksilver> There are major unsolved problems about clustering haskell.
05:03:29 <quicksilver> Interesting ones, admittedly.
05:03:38 <quicksilver> the most naive approach requires code serialisation.
05:03:53 <quicksilver> otherwise you might have a special chan which forbids function types.
05:04:02 <Baughn> Nothing worse than clustering Erlang. You just have too high expectations - it can already do what Erlang does, quite easily. ;)
05:04:14 <quicksilver> I thought erlang could serialise code/
05:04:15 <quicksilver> ?
05:04:22 <Baughn> Okay. Almost easily.
05:04:35 <quicksilver> and I thought erlang had some kind of helpful primitives to cope with version skew.
05:05:08 <Baughn> Of a sort. I'll worry about that when it becomes possible to upgrade haskell programs while running /at all/
05:05:21 <quicksilver> Fair point.
05:05:33 <quicksilver> You can get quite a long way down that road with hs-plugins.
05:05:37 <quicksilver> Yi reloads itself whilst runnig.
05:05:43 <Baughn> Yeah, if it'd compile on 6.8.2. :P
05:05:57 <quicksilver> hs-plugins or yi?
05:06:00 <quicksilver> (both of them do)
05:06:01 <Baughn> hs-plugins
05:06:05 <quicksilver> it does.
05:06:08 <quicksilver> @where hs-plugins
05:06:08 <lambdabot> http://code.haskell.org/~dons/code/hs-plugins
05:06:12 <Baughn> Oh? The version I have doesn't. Where sh.. right
05:06:24 <quicksilver> I think that's the right one. I'm not 100% sure.
05:06:43 <quicksilver> Cale: which hs-plugins is the one you fixed?
05:06:47 <Baughn> I'll try it. Maybe I'll get cheiron working again.
05:07:38 <Cheery> erlang...
05:07:48 <Baughn> As I was going to say, though - serializing code is hard, and generally unwanted; it takes /too much communication/. It'd be much better to produce references that are still valid on the other machine, assuming that the other machine is running the same code to begin with
05:08:08 <quicksilver> intuitively I agree.
05:08:12 <quicksilver> I've never wanted to serialise code.
05:08:26 <Baughn> It'd be a nifty topic for research, sure, but every real-world system I've seen (stormcast..) relies on syncing code explicitly
05:08:34 <quicksilver> but I think if you want transparent clustering, you have to.
05:08:40 <Baughn> I don't
05:08:52 <quicksilver> (given that haskell data structures can include unevaluated thunks)
05:09:05 <JohnMeacham> nice. another one with a >10x speedup over ghc.
05:09:11 <Baughn> Is there any runtime compilation going on with those thunks?
05:09:38 <Baughn> I would /expect/ they can be reduced to a typical code+data scenario, with the code already being present on every node
05:09:57 <roconnor> @djinn (rw -> a , rw -> rw) -> (rw -> (a, rw))
05:09:57 <lambdabot> f (a, b) c = (a c, b c)
05:10:06 <quicksilver> JohnMeacham: jhc = win :)
05:10:10 <roconnor> @djinn (rw -> (a, rw)) -> (rw -> a , rw -> rw)
05:10:10 <lambdabot> f a =
05:10:10 <lambdabot>     (\ b ->
05:10:10 <lambdabot>      case a b of
05:10:10 <lambdabot>      (c, _) -> c,
05:10:10 <lambdabot>      \ d -> d)
05:10:13 <quicksilver> JohnMeacham: what scenario?
05:10:35 <quicksilver> Baughn: yes, maybe you're right. I was wondering something like that.
05:11:02 <JohnMeacham> I am running the nobench ones. basically anything that can compile down to an imperitive loop, jhc kicks ass at. numerics especially.
05:11:12 <Cheery> is there a binary distribution from cabal-install? to install cabal-install?
05:11:15 <Baughn> quicksilver: I'd want to reduce communication as much as possible. If doing it right requires serializing code, that implies a design flaw, not that we need to figure out how to serialize code
05:11:36 <Baughn> quicksilver: The nodes might not even all be on the same architecture.
05:11:45 <JohnMeacham> rfib is 2s for jhc, 15s for ghc. loop is 0.3s for jhc, 5s for ghc.
05:11:46 <Cheery> it sucks to solve all these depedencies
05:11:47 <Baughn> (Which raises questions with regards to Int)
05:11:54 <quicksilver> Baughn: right. You'd send a bytecode or AST repr.
05:12:07 <quicksilver> Baughn: but still, I agree it would be nicer if you didn't have to.
05:12:15 <quicksilver> Baughn: I haven't thought about it very hard.
05:12:17 <Baughn> quicksilver: That sounds fabulously expensive. I suppose it could be a handy fallback
05:17:47 <Jomyoot> Will Haskell reach the height of popularity like Ruby?
05:19:03 <Baughn> I hope not
05:19:04 <quicksilver> haskell will continue to be popular when ruby is just a distant memory.
05:19:05 <pjd> Jomyoot: popularity among whom?
05:19:12 <Jomyoot> Typical users
05:19:15 <Jomyoot> script writers
05:19:18 <quicksilver> (I don't know. Its hard to give a sensible answer)
05:19:18 <Jomyoot> everyday-scripting
05:19:20 <pjd> it's very arguable that Haskell is already more popular where it matters
05:19:23 <quicksilver> No, probably not.
05:19:24 <Baughn> So long as it remains unpopular, it can be my secret weapon. ;)
05:19:30 <quicksilver> typical script writers are too stupid.
05:19:32 <quicksilver> :P
05:19:37 <Jomyoot> Baughn: secret weapon for ?
05:19:48 <pjd> typical script writing is not necessarily something which would benefit from using Haskell
05:20:05 <Baughn> Jomyoot: Achieving unheard-of reliability, performance and programming speed
05:20:12 <Cheery> somehow this channel outputted directly what I thought all the time
05:20:12 <dcoutts> Jomyoot: getting rich writing better software than the competition :-)
05:20:23 * shepheb would far rather the current strong niche community to a meteoric rise and fall into oblivion.
05:20:58 <Baughn> Jomyoot: I wouldn't have associated haskell with performance two years ago, but nowadays.. it's /so very easy/ to have it use every core a computer has, unlike every other language
05:21:14 <quicksilver> it's a good point.
05:21:23 <Jomyoot> well but once you get some business, how can you hire co-programmers to improve your code
05:21:26 <dcoutts> shepheb: aye, we still have lots of work to do to make the platform really great, too many demanding users too soon would not be a good thing
05:21:36 <Jomyoot> it will be much easier finding ruby/python programmers to help you
05:21:39 <pjd> Baughn: it's not that hard in other languages, if you design with multiprocessing in mind :)
05:21:52 <Baughn> Given that any (new) system requiring extreme performance will have eight or sixteen cores these days, the 2-3x overhead no longer seems like very much
05:22:11 <Cheery> I don't believe haskell will always be the thing you use to defeat inferior failing software industry
05:22:26 <Baughn> pjd: I know from personal experience just how hard it is. Yes, it can be done, but it'll cost a lot more than writing the same program in haskell, or even writing a serial program in, say, C.
05:22:42 <pejo> Jomyoot, people with a reasonable CS background should be able to learn Haskell rather quickly.
05:22:59 <Beelsebob> pejo: people with such a background are rare
05:23:10 <Beelsebob> people with a degree in writing Java are much more common
05:23:10 <Cheery> either the failing software industry wither further or somebody makes a better functional language
05:23:46 <shepheb> Beelsebob: and there's plenty of jobs for them at my competition.
05:24:17 <Baughn> Cheery: Then we'll all jump ship, and be happy someone's made something /even better/. ;)
05:24:22 <Beelsebob> shepheb: hehe
05:24:36 <Cheery> Baughn: yep
05:27:36 * wli was under the impression systems requiring extreme performance had 512 or more cores (probably up to 1024 or 4096 since last I checked). cf. NASA's cluster of 20 512-core systems et al.
05:27:57 <shepheb> I'm curious what F# will do to Haskell's popularity. if F# takes off, we may get a lot of people investigating Haskell. I think that can be good, but it could also bring Java/C#-trained "coders" who Blub about why Haskell makes everything so complicated.
05:28:03 <Baughn> wli: Wrong extreme
05:28:31 <pejo> Beelsebob, we're still talking hundreds of new grads every year. It's not rare as in one in a million.
05:28:34 <wli> Baughn: Then what were you talking about?
05:29:06 <mrd> pejo: hundreds of grads are 1 in a million in a country of hundreds of millions of people
05:29:33 <Baughn> wli: Conventional systems. How much does one of thos 512-core systems cost?
05:30:41 <wli> Baughn: No idea. They're conventional, though. Bog-standard SOI etc. processes, no funny cryo-cooled superconductors or non- von Neumann architectures.
05:31:34 * wli ventures a guess of at least as much as 512 single-core systems.
05:31:51 * Baughn suspects far more than 64 8-core systems
05:32:23 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6098
05:32:42 <smg> Integer -> [Integer] -> [Integer] is just sugar for Integer -> ([Integer] -> [Integer]) isn't it?
05:32:57 <pejo> mrd, for starters the old ones don't disappear when new ones graduate, and I'm guessing that the number is bigger in the US.
05:33:40 <Baughn> smg: Pretty much
05:33:54 <smg> ah Baughn cool :)
05:34:01 <mrd> pejo: oh good, i was wondering when i was supposed to disappear
05:34:10 <shepheb> pejo: North America has lots of both types of grads. The real question is how the ratios of grads vs. productivity line up.
05:34:33 <Baughn> smg: Last I checked there is no partial evaluation, though
05:34:56 <Baughn> smg: So "foo x y" isn't the same as "foo x = doStuff .. \y ->"
05:36:04 <quicksilver> smg: it's not even sugar.
05:36:13 <quicksilver> smg: it just is the same.
05:36:28 <quicksilver> smg: in the same way that 1 - 2 - 3 *is* (1 - 2) - 3
05:36:46 <quicksilver> Baughn: that's not relevant to the types, though.
05:37:10 <quicksilver> Baughn: that's true, it's a feature of ghc's operational semantics, not the language particularly.
05:37:12 <systemparadox> afternoon everyone
05:37:19 <smg> yeah now i understood what curried means :)
05:37:26 <smg> if i have f x y = -- do something
05:37:44 <smg> it returns first a function and that function is working on second argument
05:37:58 <smg> so all functions have one argument in haskell
05:38:01 <Baughn> quicksilver: Quite. The language not saying anything about operational semantics is handy for /implementors/, but makes it hard to be sure about how code will behave
05:38:03 <smg> thought i could use uncurry
05:38:20 <systemparadox> i'm having a bit of trouble compiling some haskell
05:38:59 <quicksilver> systemparadox: tell us more, and we may be able to help.
05:39:03 <systemparadox> if i use ghc --make [hs files] it works fine
05:39:19 <quicksilver> yay! no problem then.
05:39:33 <systemparadox> but if i do it manually, with ghc -c [hs file] and ghc -o program [o files] it doesn't
05:39:40 <quicksilver> correct.
05:39:43 <quicksilver> don't do that, then?
05:39:44 <quicksilver> :P
05:39:46 <systemparadox> lol
05:39:55 <quicksilver> --make auto detect which packages to link against.
05:40:02 <quicksilver> it's the recommended appropach.
05:40:17 <systemparadox> i'm guessing it's something to do with shared libraries or something because it works with a slightly smaller program
05:40:25 <smg> > let takeInt n (x:xs) = x : (if n > 1 then takeInt (n-1) xs else []) in takeInt 4 [1..10]
05:40:28 <lambdabot>  [1,2,3,4]
05:40:37 <systemparadox> the problem is that --make is a little silly when building in another directory
05:40:57 <quicksilver> what's silly about it?
05:41:13 <quicksilver> you can specify all the -package options by hand, incidentally.
05:41:27 <quicksilver> but using --make is (normally?) simpler.
05:41:34 <systemparadox> if i --make in the current directory, ghc puts each *.hs as *.o and *.hi
05:42:28 <systemparadox> but if I --make in a different directory it puts the .o .hi files in the same dir as the .hs file, which is fine, but if i then use -odir and -hidir it creates Main.o and Main.hi for the file with main in it
05:42:43 <systemparadox> this is a problem because i'm building 2 programs
05:42:55 <quicksilver> don't call both your programs Main, then.
05:43:00 <quicksilver> call them Program1 and Program2
05:43:05 <mrd> the Main module doesn't have to be in a Main file
05:43:10 <systemparadox> it's not
05:43:18 <quicksilver> the module can be called anything.
05:43:20 * wli uses -main-is Module.main extensively.
05:43:31 <quicksilver> module Program1 (main) where ...
05:43:37 <quicksilver> and then, what wli said :)
05:43:37 <systemparadox> AHA!
05:43:42 * wli sometimes uses -main-is Module.driver etc. too.
05:43:53 <quicksilver> -main-is Module.TestHarness
05:43:54 <quicksilver> etc.
05:43:58 <quicksilver> such things can be handy.
05:43:59 <smg> > let <!!!> n (x:xs) = if (n > 1) then !!! (n-1) xs else xs in !!! 2 [1..10]
05:44:15 <smg> "thread killed"
05:44:28 <smg> ?
05:44:37 <lambdabot>  Parse error at "<!!!>" (column 5)
05:44:50 <smg> > let (!!!) n (x:xs) = if (n > 1) then (!!!) (n-1) xs else xs in (!!!) 2 [1..10]
05:44:51 <lambdabot>  [3,4,5,6,7,8,9,10]
05:45:54 <shepheb> let (!!!) = take in ...
05:46:04 <shepheb> er, drop
05:46:28 <Baughn> quicksilver: hs-plugins may or may not compile with ghc 6.8.2. Sadly, it does not compile with cabal 1.3.6
05:46:30 <shepheb> > drop 2 [1..10]
05:46:32 <lambdabot>  [3,4,5,6,7,8,9,10]
05:46:33 <smg> shepheb: i know :P
05:46:41 <smg> shepheb: just wanted to play around a bit
05:46:49 <smg> i need to get lambdabot on my box working
05:46:52 <quicksilver> Baughn: that is sad. Maybe Cale knows something.
05:47:00 <quicksilver> smg: you can private message lambdabot you know?
05:47:04 <smg> lol
05:47:08 <quicksilver> smg: but also, you could just use ghic on your own box
05:47:11 <quicksilver> for stuff like that.
05:47:12 <shepheb> smg: isn't local lambdabot called "ghci" for things like that eval.
05:47:13 <quicksilver> ghci.
05:47:13 <smg> no i did not know till now :)
05:47:24 <smg> yeah but lambdabot does more
05:47:31 <smg> for example @src and @hoogle :)
05:47:33 <shepheb> and for the more special features, /msg lambdabot.
05:47:39 <Baughn> quicksilver: s/may/does/, in fact. It'll be interesting to find out if it'll still /work/, since my system is now schizophrenic
05:48:50 <smg> nice
05:49:00 <Deewiant> what are likely causes of 'thread blocked indefinitely' with STM?
05:49:02 <Saizan> ?where hs-plugins
05:49:02 <lambdabot> http://code.haskell.org/~dons/code/hs-plugins
05:49:14 <Saizan> that builds with 6.8.2 ^^
05:49:27 <Baughn> Saizan: Right. As I mentioned, my problems are with cabal, not with ghc
05:49:58 <Baughn> Various packages I'm using require various versions of cabal, and the sets appear to be non-intersecting in total
05:50:18 <Baughn> ..so now I have three versions of cabal installed
05:50:41 <quicksilver> Deewiant: you have a thread waiting on an MVar and GHC has detected that it can never be woken up.
05:50:49 <quicksilver> Deewiant: Oh, STM.  waiting on a TVar then.
05:51:00 <smg> lambdabot: you are a good obfuscation tool :]
05:51:14 <Baughn> quicksilver: How does ghc detect that?
05:51:33 <ndm> Baughn: which packages from hackage won't build with the one installed on GHC 6.8? just fix those and you should be fine
05:51:47 <quicksilver> Baughn: it knows which threads are waiting on which MVars/TVars. When it runs the garbage collector, it can tell where those are reachable from.
05:51:56 <Baughn> ndm: cabal-install, primarily
05:52:03 <Cheery> It's quite funny
05:52:04 <Deewiant> quicksilver: does readTVar empty the TVar the same way takeMVar does for MVars?
05:52:17 <quicksilver> Baughn: if they aren't reachable from anywehere outside the blocked thread, it knows its a deadlock.
05:52:21 <quicksilver> Deewiant: no no, definitely not.
05:52:31 <Baughn> quicksilver: It won't detect deadlock cycles, then?
05:52:37 <quicksilver> Baughn: yes, it will. I simplified.
05:52:39 <Cheery> to install cabal-install, I need zlib-dev, then I need cabal packages:
05:52:42 <Baughn> quicksilver: Nifty
05:52:54 <quicksilver> Baughn: if they are only reachable from other threads which are in turn blocked on mvars which are only reachable from ... (Etc)
05:52:56 <Deewiant> quicksilver: well darn, then it's not at all obvious to me why this happens.
05:53:01 <quicksilver> Baughn: i.e it does detect cycles.
05:53:02 <ndm> Baughn: i installed cabal-install by doing cabal-install and cabal from darcs, and the others from hackage
05:53:08 <Cheery> cabal, HTTP, network, parsec
05:53:10 <ndm> Baughn: windows?
05:53:11 <quicksilver> Deewiant: do you understand how STM works and what a retry is?
05:53:28 <Deewiant> quicksilver: I think so, at least.
05:53:47 <Baughn> ndm: linux/x86_64
05:54:21 <Baughn> ndm: That's the same setup I had, except that darcs-cabal doesn't work with hs-plugins - but having one system-wide cabal, one user cabal and one spare cabal seems to be working
05:54:43 <ndm> Baughn: ah, you want hs-plugins as well, if you didn't would all work
05:55:22 <quicksilver> Deewiant: if a thread retries due to tvars having changed since it started, it can retry immediately.
05:55:31 <Baughn> ndm: I'm attempting to do runtime code replacement, so yes
05:55:37 <quicksilver> Deewiant: if it retries due to inconsistentcy, there is no point retrying immediately.
05:55:47 <quicksilver> Deewiant: because the tvars will still be inconsistent :)
05:55:47 <Deewiant> quicksilver: aye.
05:55:52 <Deewiant> exactly. :-)
05:55:55 <quicksilver> Deewiant: so, it waits unti the tvars change.
05:56:02 <Deewiant> yep.
05:56:02 <quicksilver> if GHC notices those TVars can never change
05:56:08 <quicksilver> because no live thread has access to them
05:56:11 <Cheery> whee, at last, cabal-install so I can laid back and let it do the job
05:56:11 <Deewiant> then we're screwed.
05:56:15 <Deewiant> but that shouldn't be happening :-P
05:56:16 <quicksilver> and GHC detects that
05:56:18 <quicksilver> and kills it
05:56:19 * quicksilver nods
05:56:49 <roconnor> quicksilver: that's awsome!
05:57:05 <roconnor> does "atomically retry" kill a thread then?
05:57:11 <Cheery> would it be hard to write a sid -player in haskell?
05:57:35 <Cheery> anyone knows about sids?
05:58:19 <roconnor> @faq can Haskell be used to write a sid -player?
05:58:20 <lambdabot> The answer is: Yes! Haskell can do that.
05:58:24 <roconnor> \o/
05:58:39 <smg> lol
05:58:46 <smg> @localtime quicksilver
05:58:47 <lambdabot> Local time for quicksilver is Tue Mar  4 13:58:23 2008
05:58:53 <Baughn> Cheery: Haskell's a general-purpose language. The answer is yes.
05:59:14 <Cheery> of course, but how hard is it? :)
05:59:18 <smg> btw you can write _everything_ which is turing complete i guess
05:59:22 <roconnor> actually Cheery's question is would it be hard.  I actually don't know what an sid -player is.
05:59:32 <smg> a language which is turing complete..
05:59:40 <roconnor> so I'm just being anoying. :(
06:00:03 <Baughn> Cheery: It shouldn't be any harder than any other language, and easier than most
06:00:27 <quicksilver> roconnor: I've never tried.
06:00:47 <quicksilver> roconnor: but, it is awesome :)
06:01:04 <roconnor> Cheery: you should do it, and then write an article about your adventure for The.Monad.Reader.
06:01:34 <Deewiant> quicksilver: I can't reproduce this in ghci, only in compiled code. Is that odd?
06:01:58 <quicksilver> Deewiant: I guess maybe ghci is keeping references to the TVar around
06:01:59 <quicksilver> I'm not sure
06:02:11 <quicksilver> maybe the tvar ends up reachable from the interpreter thread?
06:02:16 <Cheery> roconnor: probably going to do it anyway, been thinking to make an actual game with haskell, finally
06:02:26 <quicksilver> when you run stuf in ghci you're all in the same 'haskell context' as the interpreter.
06:02:34 <roconnor> Cheery: so what is an sid -player?
06:02:34 <Cheery> and I don't accept any other music than .sids. :)
06:02:41 <roconnor> ooooh
06:02:49 <quicksilver> Deewiant: alternatively, it could be some optimisation
06:03:09 <Cheery> sids played originally on commodore 64
06:03:29 <Cheery> actually I'd be emulating hardware there
06:03:56 <roconnor> other than actually doing output of audio, the rest should be fine to do in Haskell.
06:04:12 <roconnor> and outputing audio is also easy if there are some IO hooks written somewhere.
06:04:26 <Cheery> doesn't OpenAL have such?
06:04:44 <roconnor> this I don't know.
06:04:54 <Baughn> What ghc option, if any, corresponds to cabal setup's --user?
06:04:56 <quicksilver> http://en.wikipedia.org/wiki/MOS_Technology_SID
06:04:56 <lambdabot> Title: MOS Technology SID - Wikipedia, the free encyclopedia
06:05:00 <quicksilver> SID is more that just audio
06:05:07 <quicksilver> it's 6502 assembly, too :)
06:05:30 <Cheery> quicksilver: really?
06:05:32 <roconnor> 6502 assembly is just a langauge right?
06:05:43 <roconnor> a language to be interpreted?
06:05:49 <Cheery> yep.
06:06:04 <roconnor> Haskelly pretty damn good at writing interpreters
06:06:39 <Cheery> thought, they say 6502 had sort of bugs they exploited at doing music, but it ought be all documented
06:06:51 <roconnor> someone just needs to write playAudio :: LazyBytestring -> IO ()
06:07:03 <roconnor> (or preferably something more structured)
06:07:08 <Cheery> or find it.
06:07:20 <Saizan> Baughn: "corresponds" in what way? among the other things --user is passed to ghc-pkg when registering
06:07:45 <roconnor> but at the very least one could implement playAudio by writing to "/dev/audio"
06:08:32 <roconnor> just be sure to separate your output from your processing.
06:08:54 <quicksilver> roconnor: there is an openAL binding
06:08:56 <Deewiant> quicksilver: can I use "forM_ foo (const $ atomically (readTChan chan))" to guarantee that I get (length foo) results from a TChan?
06:09:06 <roconnor> @what openAl
06:09:06 <lambdabot> I know nothing about openal.
06:09:14 <Deewiant> @what OpenAL
06:09:15 <lambdabot> I know nothing about openal.
06:09:25 <Cheery> lets see if I could output sin wave from somewhere in openAL
06:09:29 <quicksilver> Deewiant: hmm. I wonder if you should do the form_ inside the atomically.
06:10:15 <quicksilver> Deewiant: I'm sure I would, anyhow
06:10:34 <Deewiant> doesn't seem to make a difference for the indefinite thread blocking
06:10:36 <quicksilver> atomically (forM foo (\_ -> readTChan chan))
06:10:42 <Baughn> Saizan: So ghc will look in ~/.ghc for -packages, I suppose.. never mind, I'm not sure that's what's going wrong with eval
06:11:10 <quicksilver> Deewiant: if you put the forM outside the atomically you risk getting non-consecutive reads.
06:11:49 <Deewiant> quicksilver: if it's outside the atomically doesn't that mean that it tries to read too many? I mean, if it's read 30 of 100 and then retries won't it expect another 100?
06:12:22 <Zao> Baughn: ghc will look wherever the config files that ghc-pkg list uses point to.
06:12:35 <quicksilver> Deewiant: No.
06:12:47 <quicksilver> Deewiant: it will try, separately, 100 times to read 1 entry.
06:12:56 <quicksilver> Deewiant: once it has finished it will have read 100 entries.
06:13:02 <quicksilver> but they will not necessarily be consecutive.
06:13:20 <quicksilver> with the forM inside the atomically, then it is going to try to read 100 consistently in a row.
06:13:27 <quicksilver> i.e. 100 consecutive.
06:13:53 <Deewiant> I'm just using this to wait on threads which have been forkIO'd, one for each element of foo
06:14:08 <Deewiant> to be sure that each one has completed before moving on
06:15:29 <quicksilver> sounds like you probably dont' need STM at all.
06:15:33 <quicksilver> Why not just use MVars?
06:15:39 <Deewiant> I don't, you're right
06:15:56 <Deewiant> mostly because I just wanted to try STM :-)
06:15:58 <quicksilver> ;)
06:16:06 <Deewiant> I've got a working MVar implementation of this
06:16:31 <Deewiant> to my mind this with TVars should do the exact same thing, but nope
06:16:37 <Deewiant> 'thread blocked indefinitely'
06:17:28 <Deewiant> if you want I can hpaste the whole thing, it's about 130 lines with both impls included
06:19:30 <smg> so we should only use foldr and foldl' for efficiency?
06:19:51 <shepheb> smg: it might be better said "there's no good reason to use foldl "
06:20:26 <smg> in that document is written: use foldr if the list could be infinite and use foldl' if you know it's finite
06:20:28 <shepheb> smg: foldl' and foldr are both good in the right situation. foldl is better replaced by one of the others.
06:20:55 <hpaste>  Deewiant pasted "TVars lead to 'thread blocked indefinitely', MVars work. Why?" at http://hpaste.org/6099
06:22:45 <Deewiant> smg: also, foldr is good at producing lazy data, whereas foldl' has to eval the whole list
06:24:05 <quicksilver> Deewiant: first question is to work out why it's retrying/blocking at all.
06:24:13 <Cheery> hm. openAL is a bit slightly hard
06:24:15 <pjd> smg: a better rule of thumb is to use foldl' when you know the result is finite and strict
06:24:23 <smg> k
06:24:26 <quicksilver> Deewiant: I wonder if it's retrying due to an exception caused by !, but that's a pure guess.
06:24:31 <pjd> for example, sum = foldl' (+) 0
06:24:41 <quicksilver> I don't even remember if exceptions cause retries by default.
06:25:03 <pjd> (+) is strict (it needs both arguments before it can return its result), and thus so is sum (it needs the whole list before it can return)
06:25:18 <smg> foldl1 (+) [1..] will fail?
06:25:23 <smg> > foldl1 (+) [1..]
06:25:29 <lambdabot> Terminated
06:25:35 <pjd> yes, it will eventually run out of space/time
06:25:39 <smg> > take 10 $ foldl1 (+) [1..]
06:25:39 <lambdabot>   add an instance declaration for (Enum [a], Num [a])
06:25:44 <smg> hehe ok
06:25:57 <Deewiant> quicksilver: what I do know is that if I replace "forkIO . f visited chan" with "\x -> forkIO (f visited chan x) `finally` (atomically $ writeTChan chan ())", it works but some of the outputs are cut in half
06:26:02 <gbacon> are there known bugs in ghc-6.8.2 regarding parsing of multiline string literals?
06:26:07 <Cheery> http://haskell.org/ghc/docs/latest/html/libraries/OpenAL/Sound-OpenAL-AL-Buffer.html#t%3ABuffer
06:26:09 <lambdabot> http://tinyurl.com/27m798
06:26:20 <Deewiant> quicksilver: can that meant that the finally is catching a 'thread blocked indefinitely' exception?
06:26:26 <Deewiant> s/meant/mean/
06:26:39 <quicksilver> yes.
06:26:42 <quicksilver> it coudl mean that.
06:26:48 <quicksilver> well it doesn't really catch it.
06:26:56 <quicksilver> but it tidies up before rethrowing it
06:26:59 <Cheery> that OpenAL -stuff looks weird
06:27:00 <Deewiant> I just wasn't sure if that was an exception or a hard abort on the RTS's part
06:27:08 <quicksilver> I think it's an exception.
06:27:40 <smg> ah scanl etc is also a nice function i learned about that atm :)
06:28:04 <Deewiant> but to be honest, that info doesn't help me very much, since forkAndWait calls itself that doesn't really pinpoint anything
06:28:16 <quicksilver> Deewiant: I don't have time to wrap my head around your code right now I'm afraid. Might save it to look later.
06:29:10 <Deewiant> quicksilver: if you would, that's great. I've pretty much given up for now, having tried various things for a couple of hours. I'm happy with my MVars thus far ;-)
06:32:37 <ndm> @seen dcoutts
06:32:37 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 1h 11m 11s ago.
06:32:45 <ndm> D:\sources\contrib\google-chart>cabal install --hugs
06:32:47 <ndm> cabal: user error (Pattern match failure in do expression at Hackage/Install.hs:99:6-19)
06:33:15 <ndm> dcoutts: am finding it hard to believe that you didn't run Catch on cabal-install!
06:34:13 <gbacon> are there command line options that alter parsing of multiline string literals?
06:34:39 <smg> gbacon: how do you create multiline strings?
06:34:44 <gbacon> ghci loads src/Pugs/Prelude.hs with no problem, but I get lexical errors when trying to compile it
06:35:09 <gbacon> \<EOL>  \next line\<EOL> ...
06:35:20 <smg> ah
06:35:33 <Baughn> "...\n"++"...\n"... is the usual way to do it
06:35:44 <gbacon> it seems to flag the second character of continuation lines
06:35:49 <Baughn> That relies on constant folding, obviously
06:36:12 <Baughn> gbacon: No, it's just that you aren't allowed to have literal newlines in string constants. Unfortunately.
06:36:27 <gbacon> Baughn: there are no literal newlines
06:36:44 <gbacon> they're all escaped
06:37:20 <Baughn> gbacon: GHC doesn't appear to care
06:37:38 <wli> s/EOL/LF/
06:37:51 <gbacon> that's what I'm saying: ghci loads it happily
06:37:56 <Baughn> gbacon: It's still a literal newline, even if it's part of an (invalid, as it turns out) escape sequence
06:39:09 <gbacon> Baughn: but the literal newlines are between the backslashes
06:39:26 <Baughn> gbacon: ghci does? Not here, with or without backslashes..
06:39:34 <Baughn> gbacon: What version are you on?
06:39:35 <gbacon> http://book.realworldhaskell.org/beta/escapes.html#id408946
06:39:36 <lambdabot> Title: Appendix B. Characters, strings, and escaping rules
06:39:41 <gbacon> Baughn: 6.8.2
06:39:49 <Baughn> Same. Huh.
06:39:55 <Baughn> gbacon: Could you paste your exact code?
06:40:06 <quicksilver> Baughn: erm, you're misinforming him
06:40:16 <quicksilver> Baughn: that is how to you do haskell multiline string literals
06:40:25 <quicksilver> the syntax is called 'string gaps'
06:40:32 <quicksilver> I think it's as ugly as hell, but it *is* haskell.
06:41:32 <Baughn> Oh, /two/ backslashes. Right you are.
06:42:10 <Baughn> quicksilver: Not as ugly as "foo\n"++..., I think
06:42:31 <hpaste>  gbacon pasted "src/Pugs/Prelude.hs" at http://hpaste.org/6100
06:43:02 <gbacon> quicksilver: are there command line options that alter parsing of strings with gaps?
06:44:19 <gbacon> I seem to have run into a paste length limit
06:44:34 <gbacon> it does end with \"
06:51:15 <akamaus> hello all. Does anybody know, what's wrong with happs.org? It seems to be down for at least a week for me
06:52:00 <quicksilver> Baughn: I like unlines ["foo", for that
06:52:51 <pjd> dolio: you were asking about linear/unique types?
06:53:30 <byorgey> akamaus: it works for me.
06:53:31 <pjd> did you seen the latest LtU post?  http://lambda-the-ultimate.org/node/2708
06:53:32 <lambdabot> Title: Uniqueness Typing Simplified | Lambda the Ultimate
06:53:39 <pjd> s/did/have/
06:55:24 <akamaus> byorgey: that's strange. I see some php-like garbage instead of page
06:55:57 <byorgey> akamaus: weird.  looks just fine over here.
06:56:14 <byorgey> akamaus: what browser are you using?
06:56:58 <akamaus> byorgey: I tried konqueror and it works. But site is totally corrupted FF
06:57:23 <akamaus> byorgey: firefox
06:57:32 <quicksilver> works fine in my firefox.
06:58:11 <byorgey> I'm using FF too (2.0.0.12), works fine.
06:58:47 <byorgey> akamaus: using any weird extensions?  some sort of strange greasemonkey script perhaps?
06:59:00 <akamaus> i'm under linux. Maybe it's the case. My ff is 2.0.0.11
06:59:00 <quicksilver> also works in my safari and even IE :)
07:00:07 <akamaus> byorgey: adblock, flashgot, foxmarks, imagezoom, quickproxy
07:00:54 <byorgey> akamaus: hmm... have you fed the little elves in your processor lately?
07:03:49 <akamaus> byorgey: not sure about what. By the way, there is something strange with colors on my display these days.. ;) i'll probably  kill some ff extensions
07:04:21 <akamaus> thanks anyone
07:06:02 <Cale> quicksilver: It's the one at http://code.haskell.org/~dons/code/hs-plugins/
07:06:02 <lambdabot> Title: Index of /~dons/code/hs-plugins
07:10:22 <quicksilver> @where hs-plugins
07:10:23 <lambdabot> http://code.haskell.org/~dons/code/hs-plugins
07:10:33 <quicksilver> Cale: good, that's right then :)
07:11:01 <quicksilver> Cale: Baughn reported it doesn't like cabal 1.3.6, or something.
07:11:47 <Cale> That may be true. I'm using whatever Cabal comes with GHC 6.8.2
07:12:18 <Cale> There appeared to be some Cabal API changes which affected it.
07:22:57 <swiert> q
07:23:07 <swiert> woops
07:25:17 <byorgey> hi swiert =)
07:25:29 <swiert> hiya.
07:25:39 <swiert> byorgey: How's the Agda coming along?
07:26:40 <byorgey> swiert: it was coming along well until I ran into another error I couldn't figure out, and then I went on a grad school visit and haven't touched it since then
07:26:54 <byorgey> but I hope to pick it up again soon
07:27:21 <swiert> byorgey: What? Agda's a great way to get distracted from everything else, not the other way round :)
07:27:30 <byorgey> swiert: hehe =)
07:27:45 <quicksilver> I've been thinking about agda's custom mixfixes quite a lot.
07:27:49 <quicksilver> I'm not sure I like them.
07:27:50 <byorgey> I was trying to implement some basic group theory but was running into problems trying to generate equality proofs
07:28:03 <quicksilver> I think it makes it too hard to mentally parse unknown code.
07:28:06 <byorgey> I take it type equality is a thorny problem in general.
07:29:00 <swiert> quicksilver: I agree. Together with Unicode, it's quite easy to write code nobody can parse (although can also be really convenient at times)
07:29:54 <Philippa> I tend to think that unparseable code is less of a problem in FPLs because people tend to be pickier to start with
07:29:55 <quicksilver> it's convenient and very pretty.
07:30:05 <quicksilver> if you don't mind having to explain upfront.
07:30:21 <swiert> byorgey: hmm. That doesn't sound like it be too hard...
07:30:23 <quicksilver> what I like about haskell is that (except for infix fixity) you can prase anything
07:30:34 <quicksilver> and thus work out what kind of trick someone is using.
07:30:46 <quicksilver> erm. "Parse anything without extra context like seeing the definition"
07:30:47 <byorgey> swiert: yeah, it was probably just a silly mistake on my part.
07:30:49 <quicksilver> is what I was trying to say.
07:31:00 <swiert> quicksilver: ever tried to parse Conor's code?
07:31:03 <quicksilver> yes.
07:31:07 <quicksilver> at first, I found it hard.
07:31:14 <quicksilver> but now, I find myself getting used to it :)
07:31:19 <mattam> swiert: :)
07:31:19 <byorgey> swiert: if you don't mind I might send you some code later, if you have some time to take a look at it
07:31:22 <quicksilver> if Conor used agda tricks it would be worse.
07:31:22 <swiert> quicksilver: I can still struggle sometimes.
07:31:28 <quicksilver> I'm sure Conor's agda code *is* worse :)
07:31:32 <swiert> byorgey: I'd be happy to.
07:31:42 <byorgey> swiert: cool, thanks =)
07:35:21 <Philippa> swiert: most of the time with Conor's code it's not so much parsing as semantics that's the problem though, which is the right problem to have
07:48:39 <gbacon> is ghc-6.8.2's typechecker stricter about wobbly types than 6.6's?
07:49:34 <mrd> i think there is some changes which may necessitate type annotations in different places
07:49:39 <mrd> there are
07:59:32 <quicksilver> wobbly types = impredicative?
08:00:05 <quicksilver> ah, no. wobbly types = GADTS.
08:00:28 <ehird> @src map
08:00:28 <lambdabot> map _ []     = []
08:00:28 <lambdabot> map f (x:xs) = f x : map f xs
08:00:32 <ehird> is that actually what ghc uses?
08:02:32 <quicksilver> ehird: no, because of fusion.
08:02:43 <ehird> what does it really use then ;)
08:02:44 <quicksilver> ehird: apart from that, it's a perfectly sensible defition though, I think.
08:02:55 <quicksilver> UTSL
08:03:28 <quicksilver> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html#map
08:03:29 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/yqjxlq
08:04:01 <ehird> hmm
08:04:02 <ehird> http://nobodyreadsthis.co.uk/2008/03/04/haskell-after-nightfall/
08:04:02 <lambdabot> Title: Haskell after Nightfall  Nobody Reads This
08:04:05 <ehird> someone tell me that is satire
08:04:08 <ehird> please?
08:05:24 <ehird> quicksilver: now that is bizzare
08:05:24 <ehird> :)
08:05:27 <quicksilver> I don't think it's satire, no.
08:05:38 <jgerman> whoah
08:05:40 <quicksilver> just a fairly uninformed  initial impresion.
08:05:45 <ehird> quicksilver: 'fairly'?
08:05:46 <jgerman> if that's not satire it's kinda depressing
08:06:02 <ehird> i hereby suggest we don't pick apart every part
08:06:07 <ehird> because it would be too horrific, and long
08:07:11 <Le-Chuck_ITA> Hi there. I need to make my type an instance of Functor, but I can do that only with additional constraints on the fmap method (basically, because my functor is on a specific category rather than on the category of haskell types)
08:07:21 <Le-Chuck_ITA> hmm
08:07:38 <Le-Chuck_ITA> thinking well about it, this should be impossible
08:09:14 <quicksilver> Le-Chuck_ITA: that's not really what Functor represents.
08:09:27 <Le-Chuck_ITA> yes I see
08:09:30 <quicksilver> Functor specifically represents Functors within Hask.
08:09:35 <Le-Chuck_ITA> so I should define my own functor class
08:09:45 <quicksilver> possibly, yes.
08:09:53 <Le-Chuck_ITA> thanks
08:11:37 * Philippa gets a "My brain just exploded." out of ghci
08:11:45 <Le-Chuck_ITA> quicksilver: however, it is not easy to make things parametric here. I want to define an algorithm which abstracts from the specific category being used. How do I explain that my data type takes an "Endofunctor over A and an arrow in A"?
08:11:50 <Le-Chuck_ITA> without defining A?
08:12:07 <byorgey> Philippa: congrats! =)
08:12:54 <quicksilver> I'm not sure. It woudl depend in what sense the categories are embedded in your code.
08:13:41 <Le-Chuck_ITA> well, perhaps I will first specialize my algorithm :)
08:15:17 <ehird> Philippa: wow
08:15:23 <ehird> how do you do that :D
08:17:48 <Philippa> ehird: try to let-bind things from inside a constructor with an existential type
08:18:03 <Philippa> GHC doesn't translate it to a case at core level, apparently
08:18:22 <Le-Chuck_ITA> Philippa: just use case :)
08:18:34 <hpaste>  mauke pasted "brain-explode.hs" at http://hpaste.org/6101
08:18:37 <Philippa> Le-Chuck_ITA: not the point
08:19:04 <quicksilver> Philippa: ah yes, I've done that too :) I was trying to remember how.
08:19:17 <Le-Chuck_ITA> Philippa: this is a bug I suppose
08:19:22 <ehird> Philippa: example?
08:19:41 <ehird> Haha
08:19:44 <byorgey> ehird: mauke pasted an example above
08:21:31 <ehird> yeah
08:21:33 <ehird> its funny :)
08:21:37 <ehird> how is that even valid?
08:21:47 <ehird> shouldn't it just complain that there is no 'y' here?
08:21:54 <ehird> oh, wait
08:21:55 <ehird> i see
08:22:03 <ehird> hmm
08:22:06 <ehird> shouldn't foo = id
08:22:08 <byorgey> it's pattern-matching the x against (C y)
08:22:24 <ehird> yse
08:22:25 <ehird> *yes
08:22:43 <mauke> no, foo :: T -> (exists a. a)
08:22:51 <ehird> well, yeah
08:23:00 <ehird> but..
08:23:05 <ehird> why doesn't ghc just convert it to a case?
08:23:49 <byorgey> note that this example doesn't compile even if you change it to use a case, since the quantified type escapes
08:24:28 <byorgey> but that's not the reason ghc doesn't convert it.
08:24:44 <byorgey> the reason ghc doesn't convert it to a case is, of course, that it makes Simon's brain explode =)
08:27:41 <hpaste>  pozorvlak pasted "Keyword.hs" at http://hpaste.org/6103
08:28:10 <hpaste>  pozorvlak pasted "Main.hs" at http://hpaste.org/6104
08:29:48 <ehird> Template Haskell looks so much like a typical templ. language running on haskell source
08:29:48 <ehird> :/
08:30:06 <ehird> hmmm
08:30:18 <ehird> does Haskell' have anything for making your own derivables?
08:30:22 <Cale> ehird: What's a typical template language?
08:30:24 <ehird> dunno what the syntax would be
08:30:33 <ehird> Cale: something like asp/php/erb style templates :P
08:30:36 <ehird> i know TH is much more advanced
08:30:40 <ehird> but it *looks* like one of those
08:30:51 <Cale> ehird: Not that I'm aware of. Haskell' is intended to be a standardisation of existing language features.
08:31:20 <ehird> hmm, the deriving-definitions would have to do some crazy stuff with field names
08:31:20 <ehird> etc
08:31:35 <ehird> doesn't ghc have something for that?
08:31:36 <ehird> Data or something
08:32:20 <Cale> Data does some reflection of structure using a typeclass which is defined separately for each type involved.
08:32:21 <ehird> any docs for that?
08:32:26 <ehird> ah, ok
08:32:31 <ehird> that's not very helpful then
08:32:42 <ehird> guess I'll go invent some syntax as a bad example of a 'derivation claws' :P
08:32:45 <Cale> GHC can derive that typeclass though.
08:33:09 <roconnor> Cale: what do you think of my co-recursion post?  I don't think I've seen it explained this way before.  Usually people talk about strictness and bottoms.
08:33:18 <ehird> I think 'derivation' might be the longest haskell keyword :)
08:33:25 <Cale> roconnor: It's quite sensible. I modded it up :)
08:33:40 <SamB> now if only Data could somehow respect abstraction :-(
08:33:47 <Cale> ehird: derivation isn't a Haskell keyword
08:33:56 <Cale> deriving is though
08:34:06 <Cale> qualified
08:34:09 <Cale> is a bit longer
08:34:16 <SamB> a byte longer!
08:34:28 <SamB> assuming UTF-8 or ASCII
08:35:02 <roconnor> Cale: good.  I was a bit concerned there may be a subtle error going on.  Best way to find out is to ask and see if anyone complains ;)
08:36:20 <ehird> @hpaste
08:36:20 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:36:23 <ehird> Cale: I know
08:36:25 <ehird> it isn't :P
08:36:36 <quicksilver> ehird: I don't think people will be interested in proposals to extend the power of deriving.
08:36:48 <quicksilver> ehird: there are already (metaprogramming) tools for that purpose
08:36:52 <hpaste>  ehird pasted "really crappy example" at http://hpaste.org/6105
08:36:53 <quicksilver> Data.Derive, DrIFT
08:37:02 <ehird> quicksilver: true.
08:37:02 <Cale> There is this: http://www.haskell.org/ghc/docs/latest/html/users_guide/generic-classes.html
08:37:04 <lambdabot> Title: 8.15. Generic classes, http://tinyurl.com/33xvg5
08:37:05 <ehird> but not really as clean, I guess.
08:37:07 <quicksilver> I think these are considered a better approach going forwards.
08:37:09 <SamB> hmm. Hackage needs ChangeLog files ...
08:37:12 <Cale> I don't know if they still work though.
08:37:17 <ehird> quicksilver: If we go that route, then just remove 'deriving' altogether
08:37:23 <Cale> I don't think anyone's touched that in a long time.
08:37:34 <SamB> ehird: why do we want to remove deriving?
08:37:35 <quicksilver> ehird: the kind of thing you are sketching out there is implementable with Data.
08:37:38 <quicksilver> probably.
08:37:40 <ehird> quicksilver: true. but still.
08:37:44 <ehird> just a random idea :p
08:37:47 <Cale> deriving is good :)
08:37:53 <ehird> SamB: if Data.Derive of DrIFT is the way forward, then..
08:37:57 <quicksilver> Data is almost universal, in terms of deriving-like-features.
08:38:11 <SamB> ehird: it's overkill for deriving Show and Eq...
08:38:15 <quicksilver> most other derivings could be implemented in pure haskell using it.
08:38:23 <ehird> SamB: so, just make 'derive' extendable
08:38:28 <ehird> otherwise it's kinda messy
08:38:40 <quicksilver> making derive extendable involves inventing TH.
08:38:43 <quicksilver> TH already exists.
08:38:45 <Cale> ehird: It's still very handy.
08:38:51 <SamB> anyway, I will tell you right now that both deriving and drift need a good bit of work
08:38:53 <SamB> er.
08:38:56 <SamB> Derive and drift
08:38:58 <sek> how would i do something like fmap putStr ["hello","\n"] ?
08:39:08 <Cale> sek: mapM
08:39:09 <quicksilver> sek: mapM_
08:39:12 <sek> ah ok, thanks:)
08:39:20 <Cale> mapM putStr ["hello", "\n"]
08:39:23 <Deewiant> putStrLn . head
08:39:23 <ehird> quicksilver: with the same syntax?
08:39:24 <Deewiant> ;-)
08:39:32 <sek> the less i use haskell the more i forget the functions i should be remembering:)
08:39:41 <Cale> Or mapM_ if you care about the fact that mapM will return you a useless list of ()'s
08:40:04 <SamB> last I tried it, it was hard to write derivings in Derive that would deal properly with higher-kinded types...
08:40:14 <Cale> > mapM putStr ["hello", "\n"]
08:40:19 <lambdabot>  <IO [()]>
08:40:31 <Cale> Is something wrong with lambdabot?
08:40:34 <SamB> and DrIFT didn't even have an AST for output
08:40:36 <mrd> @botsnack
08:40:36 <lambdabot> :)
08:40:53 <ehird> Cale: Why?
08:40:57 <mrd> won't even respond to a snack? uh oh
08:41:10 <mrd> sleepylambda
08:41:16 <Deewiant> it did respond
08:41:26 <Cale> > mapM_ putStr ["hello", "\n"]
08:41:26 <Cale> odd.
08:41:26 <lambdabot>  <IO ()>
08:41:33 <ehird> what's odd?
08:41:36 <SamB> mrd: some jokester added lambdabot to your ignore list?
08:41:38 <ehird> [16:41] <lambdabot> <IO ()>
08:41:41 <Cale> Sometimes it's just really slow.
08:41:52 <Cale> Slower than my ssh connection to code.h.o
08:42:08 <Cale> ehird: Yes, but it's really lagged.
08:42:09 <SamB> that's a really funny filename
08:42:15 <Baughn> It does do a lot of compilation
08:42:21 <Baughn> @bot
08:42:21 <lambdabot> :)
08:42:25 <Cale> ehird: It took upwards of 20 seconds to respond to the requests before that.
08:42:25 <mrd> yea darcs.h.o is also really slow
08:42:31 <Philippa> has anybody built a "wrapped applicative" arrow, for the purpose of using the arrow sugar? I guess I'd settle for an Applicative-friendly version of do notation, too
08:42:52 <Philippa> but the latter's not available and I'm not feeling particularly pointless
08:43:09 <Cale> Philippa: There's that funky idiom syntax.
08:43:16 <mrd> is that a pun?
08:43:18 <Philippa> Cale: it's pointless, isn't it?
08:43:28 <Cale> It's applicative :)
08:44:20 <Philippa> yeah, but it's going to make me write out something not much nicer than desugared do, right?
08:44:27 <quicksilver> Philippa: Applicative would seem to be in contradiction to do notation.
08:44:31 <ehird> how to check if a haskell function is uselessly trivial: (\x -> (@. djinn type x) == x)
08:44:32 <ehird> :-)_
08:44:33 <quicksilver> do notation is about wiring diagrams
08:44:38 <Philippa> quicksilver: trust me, you're wrong
08:44:41 <quicksilver> applicatives don't get wiring diagrams
08:44:50 <Philippa> the big difference between monads and applicatives is that there's no join, that's all
08:44:57 <quicksilver> Philippa: I don't doubt you. I'm probing hoping for enlightenment.
08:46:35 <Cale> Philippa: Basically, it lets you write  iI f x1 x2 x3 ... xn Ii, rather than pure f <*> x1 <*> x2 <*> ... <*> xn, if I recall correctly
08:46:37 <Philippa> quicksilver: you can lift any pure value, and you can compose lifted functions. Therefore you can build pairs of results, environments etc
08:47:11 <Philippa> Cale: yep. But that forces me to hand-manage any 'environment' I need
08:48:14 <Cale> hmm
08:48:44 <Philippa> so what I'll probably end up doing is desugared do, only with <**> instead of >>=
08:49:17 <Cale> hmm
08:49:25 <Cale> But not with lambdas directly...
08:49:41 <byorgey> roconnor: where is this co-recursion post?
08:49:51 <Cale> (the types don't quite work out there.)
08:49:58 <Deewiant> byorgey: http://reddit.com/info/6as3z/comments/c03cgjs
08:50:03 <byorgey> maybe it just hasn't shown up on Planet Haskell yet
08:50:05 <byorgey> Deewiant: thanks
08:50:20 <Deewiant> at least, I guess that's what he meant
08:50:41 <byorgey> oh, I see, it's a reddit comment, not a blog post
08:51:10 <Philippa> Cale: right. Hmm, I suspect it's going to turn out that the best I can do is to build an arrow and run it through that notation
08:51:36 <Cale> Philippa: Which applicative functor are you using?
08:51:48 <Philippa> something hand-built
08:51:54 <Philippa> it might be better off as an arrow in the long run
08:52:54 <Cale> hmm... does every applicative give rise to an arrow? I know the reverse is true.
08:53:12 * sebell needs to learn -farrow do notation
08:53:15 <Philippa> reading up, no it doesn't. So I'm being daft, then
08:53:26 <Philippa> I know this one does
08:53:30 <Philippa> but that's another matter
08:54:22 <Philippa> arrows irritate me somewhat, mostly because we insist on building environments out of pairs. I mean, if I wanted lisp...
08:55:58 <quicksilver> I'm still intuitively *getting* it
08:56:05 <quicksilver> in my head, Applicative is "things you can sequence"
08:56:12 <Philippa> it looks like I'd had a misfire as to what I was getting
08:56:14 <quicksilver> i.e. you can run a whole load of effects
08:56:20 <Philippa> there's a little more to it than that, because you've got pure
08:56:22 <quicksilver> and the effects are ordered
08:56:30 <quicksilver> but you can't wire results between effects
08:56:40 <quicksilver> that "wiring" is what monads can do but applicatives can't
08:56:48 <Philippa> no, it's what /arrows/ can do
08:56:56 <Philippa> monads're arrows with higher-order computations
08:56:59 <quicksilver> that's also true, yes.
08:57:28 <quicksilver> but in particular, comparing to monads, gives rise to the view that "Do notation" is essentially wiring diagrams.
08:57:36 <ska-fan> Does ghc produce multithreaded programs?
08:57:43 <sebell> ska-fan: It can, yes
08:57:46 <Cale> ska-fan: It can, yes.
08:57:48 <quicksilver> where applicatives have particularly simple wiring diagrams, not arbitrary ones.
08:57:48 <Cale> heh
08:57:51 <sebell> :)
08:58:01 <quicksilver> the wires have to be 'stratified'
08:58:23 <ska-fan> That sounds like "..., but it isn't really that useful"
08:58:41 <Philippa> quicksilver: can you give an example of that stratification?
08:58:46 <Cale> ska-fan: No, it's very useful.
08:59:09 <Cale> ska-fan: Are you interested more in parallelism or concurrency?
08:59:12 <Cale> (or both?)
08:59:23 <ska-fan> What's the difference
08:59:24 <ska-fan> ?
08:59:35 <Philippa> ska-fan: it means that you need a switch to enable the multi-threaded RTS
08:59:53 <Cale> parallelism is about computing multiple things at the same time, concurrency is about having multiple program counters.
09:00:02 <quicksilver> Philippa: do { x <- a ; y <- b; z <- f x y; g z};
09:00:07 <sebell> ska-fan: Although you can have `multi-threaded' programs without a threaded runtime, in in the form of lightweight user threads
09:00:12 <quicksilver> Philippa: can be rendered with an applicative, if I'm not mistaken.
09:00:30 <quicksilver> hrm.
09:00:32 <Cale> You can have concurrent programs where the execution just switches between threads and nothing is really done in parallel.
09:00:33 <quicksilver> no it can't.
09:00:36 <quicksilver> you end up one join out.
09:00:44 <ska-fan> Cale: Then parallelism.
09:00:57 <Philippa> quicksilver: where does the join nail you?
09:01:02 <quicksilver> g
09:01:05 <quicksilver> the last bit
09:01:09 <Philippa> *nod* - figures
09:01:15 <Cale> One of those can be trivially parallelised by compiling it with -threaded and supplying the commandline parameter +RTS -N 4, where 4 is the number of processors you want to run on.
09:01:17 <quicksilver> without join, you end up with m (m a)
09:01:36 <Cale> To fork a new thread, use forkIO from Control.Concurrent
09:01:38 <quicksilver> Philippa: there is a theorem than any applicative expression can be written in a particularly simple way.
09:01:43 <quicksilver> Philippa: it's in the paper.
09:01:50 <Cale> Give it an IO action, and it'll run in a new thread.
09:02:00 <skorpan> what does the declaration for a function which takes a binary operator (such as (*), (/), etc) look like?
09:02:05 <Cale> I should say, a new *Haskell* thread.
09:02:05 <quicksilver> I think it's pure f <*> a <*> b <*> c <*> ....
09:02:24 <quicksilver> skorpan: x :: (a -> a -> a) -> b -> c -> a
09:02:27 <Cale> Each Haskell thread may run on one or more OS threads, each of which may execute zero or more Haskell threads.
09:02:28 <quicksilver> skorpan: for example.
09:02:32 <ska-fan> I see. That's great. Maybe we can use Haskell for something at work.
09:02:41 <skorpan> okay thanks
09:02:43 <Deewiant> @src foldr
09:02:43 <lambdabot> foldr f z []     = z
09:02:43 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:02:45 <Philippa> quicksilver: could you do it if instead of binding the result of f to z, that were the last result?
09:02:47 <Deewiant> @ty foldr
09:02:50 <Cale> Haskell threads are incredibly lightweight, and it's okay to have thousands of them.
09:02:50 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
09:02:54 <Lord_Illidan> Hi all!
09:02:58 <Philippa> that's the form I actually need to support at all
09:02:59 <Deewiant> skorpan: ^ - the folds are good examples
09:03:01 <Cale> You can also do pure parallelism
09:03:08 <Lord_Illidan> I'd like to ask..can haskell modify a parameter?
09:03:24 <sebell> Cale: I'm assuming with the current RTS it is sufficient to run as many OS threads as CPUs/cores?
09:03:42 <Cale> There's a primitive called par, such that evaluating (par x y) will put x into a queue of things to be computed if there's available time on some processor, before resulting in y
09:03:43 <Philippa> Lord_Illidan: as in command-line parm, or as in \parm? The latter, definitely not - no mutability
09:03:47 * araujo next to add himerge to hackage
09:03:58 <Lord_Illidan> or else, can it return more than 1 parameter
09:03:58 <Cale> sebell: sure, but you can always run more
09:04:09 <Deewiant> Lord_Illidan: you can always return a list or tuple
09:04:16 <Cale> er
09:04:20 <Cale> sebell: Oh, OS thread
09:04:28 <Cale> sebell: Yeah, as many as cores will do.
09:04:38 <quicksilver> Philippa: yes, that would just be f <$> a <*> b
09:04:44 <quicksilver> Philippa: unless I misunderstood you.
09:04:44 <MyCatVerbs> @pl \ a b -> (a >>= \ra -> b >>= (\rb -> return (ra,rb)))
09:04:44 <lambdabot> liftM2 (,)
09:04:58 <Lord_Illidan> ok, then I guess the tuple will be the way to go
09:05:02 <Cale> Man, what's wrong with the language centre of my brain at the moment :)
09:05:07 <MyCatVerbs> @pl \ a b -> (a >>= \ra -> b ra >>= (\rb -> return (ra,rb)))
09:05:07 <lambdabot> (. flip (liftM2 (>>=)) ((return .) . (,))) . (>>=)
09:05:10 <Deewiant> Cale: if you run without +RTS -N foo, do threads from forkIO always run on only one core?
09:05:18 <Cale> Deewiant: yeah.
09:05:23 <Lord_Illidan> I was thinking about a stack and doing a pop() function
09:05:37 <Cale> Deewiant: I'm fairly sure. Maybe forkOS could overcome that.
09:05:57 <MyCatVerbs> Cale: I thought bounded threads only worked in the threaded implementation?
09:06:01 <Deewiant> Cale: that can't be changed from within the program trivially? I.e. you'd have to manually forkOS up to the number of cores available or something?
09:06:08 <dons> sebell: yeah, +RTS -N4 will give you 4 OS threads to multiplex all your haskell threads on
09:06:08 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
09:06:10 <Cale> MyCatVerbs: they do. We're talking about -threaded programs.
09:06:15 <MyCatVerbs> Cale: oh right, my bad.
09:06:27 <Lord_Illidan> what's forkOS?
09:06:33 <Philippa> quicksilver: d'oh - rather, it's liftA*
09:06:35 * MyCatVerbs wouldn't be surprised if forkOS'd threads did do that, but doesn't think that would be a good idea.
09:06:51 <quicksilver> Philippa: yes, excatly.
09:06:51 <Cale> Deewiant: You can bake that option in if you want, but other than that, I don't think you can change it at will.
09:06:54 <Philippa> quicksilver: though at that point a little sugar becomes desirable IMO
09:07:09 <Cale> It would be really nice to have an API for tweaking runtime options at runtime :)
09:07:21 <Lord_Illidan> Also, is there anything similar to linked lists in Haskell?
09:07:23 <Deewiant> I was thinking of something like make -jN
09:07:26 <Cale> Lord_Illidan: lists.
09:07:28 <MyCatVerbs> Lord_Illidan: like forkIO, but binds a Haskell thread to a particular OS thread. It's only important for things that need to use thread-local storage. (OpenGL is the only thing I've heard of that needs this.)
09:07:35 <Cale> Lord_Illidan: Lists are linked lists :)
09:07:38 <Deewiant> So I guess if you want something like that, you'll need a frontend script
09:07:51 <Lord_Illidan> Cale, ah of course
09:07:57 <quicksilver> MyCatVerbs: gtk too, I believe.
09:08:24 <Lord_Illidan> Has anyone tried opengl with haskell? Is it any good?
09:08:41 <hpaste>  ska-fan pasted "continuing 99 problems" at http://hpaste.org/6106
09:08:50 <sarehu> Yes it works
09:08:52 <dons> Lord_Illidan: yeah, HOpenGL is a pretty good binding, people say
09:08:59 <cjb> Lord_Illidan: there have been some remarkably complex programs written with it.
09:09:39 <ska-fan> I continued to solve the 99 problems in haskell, I'd appreciate it if someone could take a look at them and possibly comment. Problems and solutions are very simple, so it shouldn't take much time. It's appreciated :)
09:10:21 <Lord_Illidan> ska-fan, where are these 99 problems?
09:10:22 <Cale> ska-fan: I'll have a look
09:10:26 <ska-fan> Lord_Illidan: there's a URL at the top
09:10:31 <Deewiant> ska-fan: for compress, you could match (x:y:xs) instead of calling head
09:10:38 <Lord_Illidan> ska-fan, course, I'm reading it now, thanks
09:10:54 <quicksilver> Lord_Illidan: I find it rather satisfying (opengl in haskell)
09:11:09 <quicksilver> Lord_Illidan: because it yields very visible results in quite a short time
09:11:11 <Lord_Illidan> And has anyone used gtk in Haskell?
09:11:12 <Cale> ska-fan: In compress, you might want to try matching against the pattern (x:y:xs)
09:11:15 <Deewiant> ska-fan: for pack, [x] ++ is equivalent to x: (but I guess that's optimization)
09:11:22 <quicksilver> and it's quite a good playground for abstraction techniques.
09:11:32 <quicksilver> gtk I haven't tried yet.
09:11:48 <ska-fan> ok, (x:y:xs), x:
09:12:12 <Deewiant> ska-fan: for encode, you don't need parens around length x, made it look like a bit like a nested tuple to me... but maybe I just have poor eyesight ;-)
09:13:08 <Deewiant> ska-fan: and the same x: for dupli: x:x:dupli xs seems easier to read to me
09:13:54 <Cale> > foldr (\x xs -> x:x:xs) [] [1,2,3,4]
09:13:55 <cjb> Lord_Illidan: gtk2hs is also thought of as a very nice binding.
09:14:03 <Lord_Illidan> thanks cjb
09:14:05 <lambdabot>  [1,1,2,2,3,3,4,4]
09:14:11 <cjb> Lord_Illidan: I tend to find that Haskell GTK2 code isn't any longer than Python GTK2 code, which is saying something.
09:14:14 <Lord_Illidan> Another silly question
09:14:21 <Deewiant> @pl \x xs -> x:x:xs
09:14:21 <lambdabot> liftM2 (.) (:) (:)
09:14:29 <Cale> heh
09:14:35 <cjb> Lord_Illidan: e.g. here:  http://darcs.haskell.org/gtk2hs/docs/tutorial/Tutorial_Port/chap4-1.xhtml
09:14:38 <lambdabot> http://tinyurl.com/25vzfg
09:15:03 <Lord_Illidan> Given that I have a function add :: Integer -> Integer -> Integer
09:15:09 <Lord_Illidan> add x y = add x + y
09:15:11 <Cale> ska-fan: An elegant way to deal with list indices is to zip the list with the list [0..]
09:15:14 <Deewiant> ska-fan: for isPrime, why take all elements less than n and then check if n is an element of them? :-)
09:15:21 <cjb> Lord_Illidan: you mean add x y = x + y
09:15:23 <Lord_Illidan> how come inc = add 1
09:15:31 <Lord_Illidan> cjb, yes, typo, sorry
09:15:35 <ska-fan> hmm
09:15:35 <cjb> oh, because of currying
09:15:42 <ska-fan> x:x:dupli is a neat idea
09:15:55 * ska-fan is playing catch-up :)
09:15:57 <Deewiant> ska-fan: see also Cale's foldr which is cleaner :-)
09:15:59 <Lord_Illidan> Got some probs with my keyboard atm..
09:16:01 <Cale> ska-fan: For instance,  dropNth xs n = [x | (k,x) <- zip [0..] xs, k `mod` n /= 0]
09:16:15 <cjb> inc b -> add 1 ? -> add 1 b.
09:16:18 <ska-fan> Deewiant: technically, I don't know foldr yet :)
09:16:29 <Cale> Well, I'm not entirely sure that you would always want to use foldr for that, but it's good to look at it :)
09:16:36 <Lord_Illidan> hmm, I have to do some more research on currying
09:16:39 <Lord_Illidan> thanks a lot guys
09:17:06 <cjb> Lord_Illidan: the idea is that we're passing around a function called "add 1 ?"
09:17:13 <cjb> which in Haskell is totally fine
09:17:14 <Deewiant> ska-fan: 1 isn't prime
09:17:21 <cjb> and then fulfilling the ? whenever we call it with something.
09:17:22 <Cale> Lord_Illidan: add is really a function of one parameter which produces the function which takes another parameter and then returns the result of adding the two.
09:17:31 <Deewiant> ska-fan: and there's no need to error on negatives, they aren't prime either :-)
09:17:40 <Lord_Illidan> Yes, I got it from the "gentle" introduction
09:17:45 <Lord_Illidan> it confused me a bit
09:17:53 <Lord_Illidan> BTW, anyone around here from Malta?
09:17:55 * mrd wants a Natural type
09:18:06 <Cale> Deewiant: An integer n is prime if and only if -n is prime.
09:18:24 <Deewiant> Cale: eh?
09:18:39 <mrd> Cale: circular?
09:18:49 <Cale> mrd: Just not a definition.
09:18:57 <Deewiant> Cale: all n < 0 aren't prime, they're all divisible by -1
09:19:04 <Cale> -1 is a unit.
09:19:43 <Cale> A nonzero, nonunit p is prime if whenever p divides ab, then p divides a or p divides b.
09:20:09 <Mr_Awesome> Deewiant: the same could be said of positive numbers
09:20:22 <qebab> all n > 0 are also divisible by -1
09:20:33 <mrd> is 3i prime
09:20:39 <Cale> mrd: In what ring?
09:20:48 <mrd> the Cassini one
09:20:56 <mrd> or is that a division
09:20:58 <Deewiant> hmm, you're right aren't you.
09:21:26 <sarehu> bah, will you stop bringing in definitions from these domains I tried to forget about semesters ago?
09:21:50 <MyCatVerbs> @pl \f (a,b,c) -> (f a,f b,f c)
09:21:50 <lambdabot> (line 1, column 8):
09:21:50 <lambdabot> unexpected ","
09:21:50 <lambdabot> expecting letter or digit, operator or ")"
09:21:50 <lambdabot> ambiguous use of a non associative operator
09:22:20 <ska-fan> ok, I fixed the primes, noted the zip [0..] otherlist trick.
09:22:20 <MyCatVerbs> @pl \f (a,b) -> (f a,f b)
09:22:20 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
09:22:20 <Deewiant> lambdabot (or rather @pl and company) doesn't know anything bigger than pairs :-/
09:22:27 <Cale> Deewiant: Normally when we think of *the* primes, we think of the prime natural numbers rather than the prime integers.
09:22:35 <MyCatVerbs> Deewiant: ah, handy to know.
09:23:06 <quicksilver> @pl is sadly, a bit of hack in nature.
09:23:07 <lambdabot> (line 1, column 9):
09:23:07 <lambdabot> unexpected ","
09:23:07 <lambdabot> expecting variable, "(", operator or end of input
09:23:10 <ska-fan> map isPrime [-10..10]
09:23:10 <Cale> This is mainly because primes in the integers are no more interesting than the primes in the naturals.
09:23:11 <Deewiant> MyCatVerbs: join (***)
09:23:15 <hpaste>  gbacon pasted "wobbly type error" at http://hpaste.org/6107
09:23:32 <Deewiant> > join (***) (+1) (2,3)
09:23:32 <lambdabot>  (3,4)
09:23:41 <Cale> gbacon: Cool error :)
09:23:49 <gbacon> Cale: got a cool fix? :-)
09:23:50 <Deewiant> Cale: yes, I realized that a few minutes too late :-)
09:24:38 <MyCatVerbs> Deewiant: (***) is in what, Control.Applicative?
09:24:48 <Deewiant> MyCatVerbs: Control.Arrow
09:24:54 <MyCatVerbs> Nope, guessed wrong.
09:24:56 <MyCatVerbs> Ah, danke.
09:25:02 <gbacon> Cale: does the annotation for asYAML need to be updated?
09:25:16 <Cale> gbacon: Is this pugs code? ;)
09:25:20 <gbacon> Cale: yes
09:25:24 <Cale> oh, heh, obviously yes :)
09:25:37 <Cale> (I was doing google searches for things like fromTypeable :)
09:25:40 <gbacon> the pugs cabal build is progressing much further than it was
09:25:49 <Saizan> gbacon: put the annotation in the pattern rather than later?
09:26:12 <Cale> What is the type of fromTypeable?
09:26:40 <gbacon> Saizan: as in (Just (VMultiCode mc))?
09:26:42 <dcoutts_> @seen ndm
09:26:43 <lambdabot> I saw ndm leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 15m 56s ago, and .
09:26:57 <Cale> fromTypeable is not in the GHC libraries.
09:27:02 <gbacon> no, it's a pugs thing
09:27:06 <Saizan> Just (mc :: VMultiCode)
09:27:55 <dcoutts_> @tell ndm hugs has no notion of installed packages, what are we supposed to do?
09:27:55 <lambdabot> Consider it noted.
09:27:59 <hpaste>  gbacon annotated "wobbly type error" with "fromTypeable def" at http://hpaste.org/6107#a1
09:28:21 * MyCatVerbs blinks at Control.Arrow. Is there some interesting story behind why both "pure" and "arr" exist?
09:28:46 <cjb> MyCatVerbs: it's defined as pure = arr or something, right?  I recall knowing the story, but not what it actually is.
09:28:52 <gbacon> @karma+ Saizan
09:28:53 <lambdabot> Saizan's karma raised to 6.
09:28:57 <Cale> Strange.
09:29:03 <pjd> MyCatVerbs: to annoy people who also use Applicative?
09:29:06 <gbacon> Saizan: now why did that work?
09:29:11 <idnar> @type Control.Arrow.pure
09:29:14 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
09:29:15 <idnar> @type Control.Arrow.arr
09:29:16 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
09:29:19 <Philippa> pjd: historical accident, Arrow got there first
09:29:21 <idnar> heh
09:29:34 <Cale> gbacon: I'm guessing it helped fromTypeable to know which types it was casting between.
09:29:34 <MyCatVerbs> pjd: heh.
09:29:38 <Cheery> how to find out which instances there exists from a class?
09:29:43 <Philippa> IIRC one early paper used one and the other used the other
09:29:47 <pjd> @instances Monad
09:29:48 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:29:52 <Cale> gbacon: But there's something really odd going on, are these existential constructors?
09:29:55 <Cheery> @instances Binary
09:29:56 <lambdabot> Couldn't find class `Binary'. Try @instances-importing
09:29:59 <MyCatVerbs> Cheery: :i in ghci will do it too, as well as lambdabot.
09:30:17 <Saizan> gbacon: well i suppose ghc can't allow pattern matches to depend on how the values are used later
09:30:17 <gbacon> Cale: fromTypeable is (forall)
09:30:33 <gbacon> saizan: c'mon, lazy typechecking :-)
09:30:33 <Cale> How about MkRef and ICode?
09:31:01 <shag> what is the inverse of hSeek, i.e. a functino that returns the current (absolute) position inside a file (handle)?
09:31:20 <MyCatVerbs> shag: hTell
09:31:40 <shag> MyCatVerbs: oh thanks, i must be blind today, just spotted it in the docs ...
09:31:43 <Saizan> gbacon: heh, yeah, here it would have been straightforward, but i think there can be more obscure cases, you should ask the implementor of pattern guards :)
09:31:44 <gbacon> MkRef   :: (Typeable a) => !(IVar a) -> VRef
09:31:46 <quicksilver> see also hGetPosn and hSetPosn
09:32:26 <Cale> gbacon: Ah, of course, there'd be GADTs hanging around somewhere :)
09:32:33 <gbacon> Cale: oh yeah, all over
09:32:40 <gbacon> I've been reading spj's paper
09:33:00 <Cale> gbacon: That one in particular is existential, in that it throws away the type variable a
09:33:12 <gbacon> but the interaction between GADTs and typeclasses is tricky
09:33:16 <Cale> which is why you have to use this fromTypeable shenanigans in the first place.
09:33:27 <gbacon> @karma- shenanigans
09:33:28 <lambdabot> shenanigans's karma lowered to -1.
09:33:30 <quicksilver> I haven't seen a convincing use case for GADTs yet.
09:33:37 <quicksilver> I've seen really cute examples in papers
09:33:41 <quicksilver> which don't scale to real programs.
09:33:55 * MyCatVerbs giggles at the fit his classmates would throw if they saw him write something like: (*2) *** (*4) $ (4,8) -- and then proceeded to call that a "simple example" XD
09:33:57 <quicksilver> I've not seen a part of a real program which makes me think "Oh, GADTs are useful"
09:34:28 <Cheery> @go tutorial on haskell bytestrings
09:34:29 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
09:34:29 <lambdabot> Title: Data.ByteString
09:34:43 <MyCatVerbs> Oh man, Control.Arrow is really, really nice. x_x
09:34:43 <Deewiant> (8*)***(*8) looks artistic
09:35:13 <Cale> quicksilver: Well, regardless of whether they're useful in full generality, existential types are useful, and GADTs are a natural generalisation of those.
09:35:27 <MyCatVerbs> Deewiant: mental note to bury that somewhere important, one day.
09:35:35 <quicksilver> Cale: GADT syntax is a nice way to write existentials :)
09:35:38 <quicksilver> Cale: and I use it.
09:35:47 <Deewiant> @ty (.)($)($)(.)(8*)***(*8)(.)($)($)(.)
09:35:48 <lambdabot> forall a (f :: * -> *) a1 b (f1 :: * -> *). (Functor f1, Num ((((a1 -> b) -> f1 a1 -> f1 b) -> (a1 -> b) -> f1 a1 -> f1 b) -> (((a1 -> b) -> f1 a1 -> f1 b) -> (a1 -> b) -> f1 a1 -> f1 b) -> ((a1 ->
09:35:48 <lambdabot> b) -> f1 a1 -> f1 b) -> (a1 -> b) -> f1 a1 -> f1 b), Num a, Functor f) => (f a, a1 -> b) -> (f a, f1 a1 -> f1 b)
09:35:48 <quicksilver> Cale: but, I've not used the full version ever.
09:35:51 <Deewiant> ew
09:35:59 <Deewiant> somebody, use that for something
09:36:11 <ddarius> (2&*)*(4&*)
09:36:15 <Deewiant> d'oh, looks like it needs an anal Num instance
09:36:21 <MyCatVerbs> Cale, quicksilver: so you're saying that sometimes providing totally overkill power for a particular purpose can give nicer syntax than just solving the problem (existential types, in this case) directly?
09:36:30 <Cale> MyCatVerbs: yep
09:36:33 <Cheery> wondering.. is there some convenient way to write and read bytestrings?
09:36:38 <shag> why is length for normal ByteString Int but for lazy ByteStrings Int64?!
09:36:47 <pjd> :t ((8*)**)***(**(*8))
09:36:48 <lambdabot> forall t a. (Floating (a -> a), Num a, Floating (t -> t), Num t) => (t -> t, a -> a) -> (t -> t, a -> a)
09:36:54 <pjd> :t ((8***)**)*(**(***8))
09:36:55 <lambdabot> forall (a :: * -> * -> *) b' c'. (Num ((a b' c' -> a (b', b') (c', c')) -> a b' c' -> a (b', b') (c', c')), Floating (a b' c' -> a (b', b') (c', c')), Arrow a, Num (a b' c')) => (a b' c' -> a (b', b'
09:36:55 <lambdabot> ) (c', c')) -> a b' c' -> a (b', b') (c', c')
09:37:05 <Deewiant> meh
09:37:15 <qebab> whoa
09:37:26 <MyCatVerbs> Cale: how often does that happen, anyway? I'd tended to get the impression that most things are easiest and fastest to solve once you find the least powerful mechanism that just about fits the task.
09:37:32 <Deewiant> @ty ((8*). **)***(** .(*8))
09:37:34 <lambdabot> parse error on input `**'
09:37:43 <Botje> :t (**) `on` (**)
09:37:44 <lambdabot> forall a. (Floating a, Floating (a -> a)) => a -> a -> a -> a
09:37:46 <Deewiant> @ty ((8*).(**))***((**).(*8))
09:37:47 <lambdabot> forall a b'. (Floating b', Floating a, Num (a -> a)) => (a, b') -> (a -> a, b' -> b')
09:37:50 <dcoutts_> shag: because a normal bytestring cannot be bigger than your address space so it's length will always fit into Int
09:37:59 <Cale> MyCatVerbs: Well, it happens all the time in mathematics.
09:38:01 <MyCatVerbs> Cale: ("powerful" in that sentence is referring to the Choam-hierarchy definition of "power", rather than expressiveness)
09:38:16 <shag> dcoutts: good point. thanks for the insight :)
09:38:18 <MyCatVerbs> Er, Chomsky. Noam. Gah.
09:38:24 <mattam> GADT's are a somewhat boring case of dependent types, that's certainly why it's not been a very useful feature.
09:38:25 <Cale> MyCatVerbs: Generalising things often simplifies your view of them.
09:38:51 <pjd> cue (.) = fmap
09:39:01 <Deewiant> @ty ((8*)<<<(*8))***((8*)>>>(*8))
09:39:02 <lambdabot> forall b t. (Num t, Num b) => (b, t) -> (b, t)
09:39:20 <MyCatVerbs> Cale: suppose so. I thought that usually happened when you'd managed to generalize up to solving the real problem, rather than just one outcropping of it?
09:39:21 <Deewiant> > ((8*)<<<(*8))***((8*)>>>(*8)) 10 20
09:39:23 <lambdabot>   add an instance declaration for (Num (t -> b' -> c'))
09:39:51 <Deewiant> > ((8*)<<<(*8))***((8*)>>>(*8)) (10,20)
09:39:51 <lambdabot>  Couldn't match expected type `b' -> c''
09:40:15 <Deewiant> > (((8*)<<<(*8))***((8*)>>>(*8))) (10,20)
09:40:15 <lambdabot>  (640,1280)
09:40:20 <Deewiant> yay
09:40:24 <Cale> MyCatVerbs: Are you familiar with metric spaces?
09:40:35 <Deewiant> who isn't?
09:40:45 <MyCatVerbs> Cale: as in topology? I've read no more than one random blog post on the topic.
09:40:45 * dcoutts_ isn't
09:40:53 * sebell isn't either
09:41:12 <Cale> MyCatVerbs: Well, topology generalises the theory of metric spaces further.
09:41:14 <Deewiant> bah.
09:41:32 <Cale> Basically, a metric space is one in which for any two points, you have a notion of the distance between them.
09:41:42 <dcoutts_> like the and the Euclidean and British Rail metrics :-)
09:42:04 <dcoutts_> shortest point between two places is the sum of their distances via London
09:42:14 <Vq^> :)
09:42:29 <Deewiant> Topology is more abstract - you can only say whether something is close to something else or not
09:42:33 <MyCatVerbs> Cale: wait, metric spaces as in places where you can measure the distances between points using functions that satisfy the triangle inequality and others?
09:42:40 <Deewiant> MyCatVerbs: aye.
09:43:07 <Cale> MyCatVerbs: Basically.
09:43:13 <MyCatVerbs> Deewiant: thanks! Cale: ah, wonderful. In that case, yes, I do have a passing familiarity.
09:43:32 <Cale> A metric space M is a set of points, together with a function d: M x M -> R (where R is the real numbers) satisfying:
09:43:39 <Cale> 1) d(x,y) >= 0
09:43:46 <Deewiant> 2) d(x,y) = d(y,x)
09:43:46 <Cale> 2) d(x,y) = 0 if and only if x = y
09:43:56 <Cale> 3) d(x,y) = d(y,x)
09:43:57 <Cale> :)
09:43:58 <MyCatVerbs> Heh.
09:44:01 <Deewiant> bah.
09:44:08 <MyCatVerbs> Deewiant & Cale suffer a race condition.
09:44:09 <Cale> and 4) d(x,z) <= d(x,y) + d(y,z)
09:44:28 <Deewiant> Just say d : M x M -> [0, \infty) and you can lose the first property
09:44:31 <MyCatVerbs> What we need is a way to retroactively delete lines from IRC conversations, then we could have transactional discussions. :)
09:44:45 <Cale> actually you can lose the first property anyway
09:45:02 <Cale> Because 2 d(x,y) = d(x,y) + d(y,x) >= d(x,x) = 0
09:45:32 <Deewiant> Aye
09:45:50 <Cale> But the interesting thing, I found, was how much simpler it often was working with general metric spaces than with, for instance R^n directly.
09:45:52 <MyCatVerbs> I've seen the first property written as d: M x M -> R+ (R+ being specifically [ r | r in R, r >= 0 ])
09:46:01 <Cale> R^n has lots of extra features which can distract you.
09:46:21 <Deewiant> the discrete metric is nice to work with
09:46:26 <Cale> Heh
09:46:35 <Cale> It's good for counterexamples :)
09:46:38 * byorgey likes the p-adic metrics =)
09:46:51 <MyCatVerbs> Cale: ah. Hence the mathematician's advice to pay no heed to the fact that the data has fourty billion dimensions, and just work on the vectors as normal? :)
09:46:51 <Cale> The discrete metric is the one for which d(x,y) = 0 if x = y, and d(x,y) = 1 otherwise.
09:47:06 <Cale> MyCatVerbs: Well, this is even more general still :)
09:47:08 <MyCatVerbs> So... Hamming distance?
09:47:38 <Cale> MyCatVerbs: I suppose, sort of, for one-element strings :)
09:47:39 <MyCatVerbs> Cale: oh aye.
09:47:54 <Cale> We've even lost the vector space structure.
09:48:03 <Cale> There's no addition or scalar multiplication.
09:48:20 <MyCatVerbs> Well, it might correspond to Hamming distance if you map all your bit strings to vectors.
09:48:27 <Cale> But you can still prove a surprising amount about general metric spaces.
09:48:28 <MyCatVerbs> Ohhhh, I see. Handy.
09:48:55 <Cale> and the proofs generally are nice and clean, because all that other structure is out of the way
09:49:01 <ddarius> Cale: It's like parametricity.  The more general the level you work at, the less there is to say and the less ways of saying things at all.
09:49:07 <Cale> Right.
09:49:09 <Deewiant> Or horribly unintuitive ;-)
09:49:27 <Cale> Well, okay, there are ways in which your intuition will initially be hurt.
09:49:32 <Cale> But you get used to that. :)
09:50:07 * MyCatVerbs blinks.
09:50:47 <Cale> Like, take the real line R, and instead of the usual metric, put the discrete metric on it. So you have uncountably many points and they're all at exactly distance 1 from each other :)
09:50:49 <Cheery> "The bureaucrat has many strategies. But probably his best is to take an area of creative programming and devour it like a locust, by turning it into a form of mathematics."
09:50:58 <Cheery> I guess I'm a co-bureaucrat then.
09:51:28 <Cheery> http://unqualified-reservations.blogspot.com/2007/08/whats-wrong-with-cs-research.html
09:51:29 <MyCatVerbs> Cheery: what, take an area of disgusting hacky crap and turn it into creative, beautiful mathematics?
09:51:30 <lambdabot> Title: Unqualified Reservations: What's wrong with CS research, http://tinyurl.com/ypgj54
09:52:01 <MyCatVerbs> Cheery: or take a whole pile of beautiful mathematics and turn it into creative hackery? :)
09:52:17 <ddarius> MyCatVerbs: It's not crap, it's Art!  You just can't appreciate it.
09:52:31 <pjd> or take a bunch of dead hackery and vivify it into a form of creative mathematics?
09:53:09 <MyCatVerbs> ddarius: only because there's nothing to appreciate, usually. Sturgeon's Law applies to art, too.
09:54:28 <ddarius> MyCatVerbs: That's all those other hacks. -My- crappy code is Art!
09:54:32 <cjb> (Wow, I don't understand this meme that "Python was not designed by a PL researcher.")
09:56:35 <Cheery> does there exist some module for X in haskell?
09:56:42 <MyCatVerbs> cjb: oO. Python was designed as a teaching language originally, so wouldn't that have meant Guido must surely have been, at the very least, a TA at some point?
09:56:50 <slarba> Cheery: X11
09:56:56 <slarba> import X11
09:57:08 <byorgey> @faq does there exist some module for X in haskell?
09:57:08 <lambdabot> The answer is: Yes! Haskell can do that.
09:57:13 * ska-fan is thinking about rewriting a mysql to postgresql thingie for work to haskell
09:57:14 <gwern> depends on the value of X
09:57:26 <cjb> MyCatVerbs: Much more than that -- he worked in the same programming language design group that wrote ABC, which Python inherited a lot of ideas from.
09:57:44 <MyCatVerbs> Cheery: it's called Graphics.X11, unsurprisingly enough. You... quite possibly don't want to use it unless you really, really need to, since it's a straightforward binding of the (Considered Painful) Xlib API.
09:57:51 <byorgey> it took me a second to realize Cheery was asking about the windowing system, not a module meta-variable =)
09:57:58 <MyCatVerbs> cjb: inherited? Stole.
09:58:07 <cjb> MyCatVerbs: is there a difference?
09:58:17 <MyCatVerbs> cjb: yes. Inheriting things is for losers. Real artists steal.
09:58:31 <gwern> cjb: yes. good programming languages inherit. great ones steal
09:58:51 <MyCatVerbs> cjb: e.g. Haskell didn't inherit H-M inference and pattern matching from its ML roots, instead both features are stolen outright. ^_^
09:58:54 <gwern> (with apologies to Picasso and his dislike of computers - computers are useless, they can only give you answers)
09:59:21 <MyCatVerbs> gwern: that's what computer scientists are for! ;)
10:00:32 <SamB> I guess picasso didn't realize that having computers to help you get answers gives you more time to think of questions ;-)
10:01:09 <sclv> @go "genius steals"
10:01:11 <mrd> most computers raise plenty of questions
10:01:11 <lambdabot> http://farisyakob.typepad.com/
10:01:11 <lambdabot> Title: Talent imitates, genius steals
10:01:20 <mrd> like "why doesn't this $%^#&$%&#& thing work?"
10:02:32 <MyCatVerbs> mrd raises questions like, "I wonder if that's valid Perl?"
10:02:51 <Deewiant> It's valid Befunge for sure
10:03:02 <Deewiant> But it's an infinite loop...
10:03:10 <lament> Art is useless, it can only give you answer.
10:03:13 <lament> *answers
10:03:31 <Cheery> Maybe I'm asking it in wrong place now.. Theres things like gtk and that one thing by kde, how do they differ from X11?
10:03:33 <MyCatVerbs> lament: could you justify that?
10:03:46 <lament> MyCatVerbs: i will after picasso justifies what he said!
10:03:47 <SamB> mrd: yes, but they don't give them to you outright
10:03:49 <MyCatVerbs> Cheery: for the sake of your own sanity, use gtk.
10:03:51 <Deewiant> Cheery: they're layers on top of it
10:04:06 <slarba> Cheery: gtk is a widget library built on top of X11 library
10:04:17 <MyCatVerbs> Cheery: X11 is raw, low-level. Gtk and Qt both provide nice APIs and widgets.
10:04:19 <glen_quagmire> how can I implement partial application of a function?
10:04:24 <Cheery> cool!
10:04:30 <gwern> glen_quagmire: easily
10:04:32 <lament> glen_quagmire: in Haskell?
10:04:37 <glen_quagmire> yes
10:04:56 <gwern> > let foo = (+1) in foo 1
10:05:12 <lambdabot>  thread killed
10:05:13 <lament> glen_quagmire: it's already implemented.
10:05:17 <glen_quagmire> (f arg1) is already partially applied in haskell.. but f can be different type. so i'm not sure how to store f's  in a  list
10:05:28 <gwern> > let foo = (1+) in foo 1 -- hm
10:05:32 <lambdabot>  2
10:05:42 <Valodim> glen_quagmire: you can't
10:05:43 <lament> glen_quagmire: (f arg1) is a value of particular type.
10:05:46 <glen_quagmire> + is Num a => a ->  a -> a  ..
10:06:03 <lament> glen_quagmire: if (f arg1)'s all have the same type, you can store them in a list, and otherwise you can't.
10:06:11 <Valodim> lists store homogenous data, functions with different arguments are heterogenous
10:06:13 <glen_quagmire> f can be String -> String -> MyMonad m -> String -> Int -> Double ...
10:06:25 <shag> how do i get a seekable file handle to an ordinary file on my hd?
10:06:39 <MyCatVerbs> Cheery: X11 lets you do things like draw lines and shapes, check where the mouse cursor is right now, et cetera. GTK and Qt let you do things like draw buttons, open windows, fire off generic "Open file" dialog boxes, and so on.
10:06:46 <mauke_> :t openFile
10:06:48 <lambdabot> Not in scope: `openFile'
10:06:53 <glen_quagmire> so, i need to generalize type of my functions
10:07:05 <Valodim> yes
10:07:06 <lament> glen_quagmire: what are you trying to do?
10:07:20 <MyCatVerbs> shag: handle <- openFile "foo.txt" ReadMode
10:07:26 <glen_quagmire> i'm implementing a small lisp like language for homework. lament
10:07:44 <glen_quagmire> well it might not be lisp like after all
10:07:51 <MyCatVerbs> shag: all files on disk are seekable (hopefully) though many special files aren't (e.g. terminals).
10:08:03 <shag> MyCatVerbs: that is successful, but the handle returned does not seem to be seekable. at least, hIsSeekable gives True and hTell and hSeek give an exception
10:08:28 <MyCatVerbs> shag: that seems wrong.
10:08:38 <shag> that is what i am thinking :)
10:08:47 <byorgey> shag: what exception?
10:08:50 <Lord_Illidan> A programming language like Haskell, with a generally Piercean type system that takes a semester for even the smartest undergraduates to learn, is not useful. Because one of the key ingredients of victory in a language conflict - as in any other standards war - is how many people already use the language.
10:08:59 <Lord_Illidan> http://unqualified-reservations.blogspot.com/2007/08/whats-wrong-with-cs-research.html
10:09:00 <lambdabot> Title: Unqualified Reservations: What's wrong with CS research, http://tinyurl.com/ypgj54
10:09:07 <shag> byorgey: *** Exception: wurst.tmp: hGetPosn: illegal operation (handle is not seekable)
10:09:08 <Lord_Illidan> What do you think of that, people?
10:09:16 <MyCatVerbs> shag: on POSIX, hSeek - even if you go past the end of the file - should still work fine in write mode. In read mode, I don't know but I wouldn't assume anything good would happen.
10:09:18 <shag> MyCatVerbs, byorgey: but wait, i am using AppendMode
10:09:19 <Cheery> one can use X11 for getting joystick input along all else?
10:09:28 <slarba> Cheery: no.
10:09:42 <Cheery> what would be good for that then?
10:09:54 <byorgey> Lord_Illidan: gah, I skimmed that, it made me sad for whoever wrote it
10:09:58 <Cheery> assuming I'd probably like input from keyboards and mice as well
10:10:02 <slarba> Cheery: or, you'd need an input device driver for X11 to fo that
10:10:09 <Cheery> even without window context
10:10:11 <slarba> s/fo/do/
10:10:16 <Valodim> "productivity is now."
10:10:17 <Valodim> hah.
10:10:35 <shag> hm, files seem only be seekable in ReadMode or WriteMode but not in AppendMode
10:10:48 <lament> Lord_Illidan: "warriors of god"?
10:10:51 <lament> what's wrong with this guy
10:10:59 <Lord_Illidan> byorgey, Haskell isn't as hard as people claim
10:11:11 <byorgey> Lord_Illidan: I agree.
10:11:32 <MyCatVerbs> shag: try WriteMode, then immediately hSeek handle SeekFromEnd 0 ?
10:11:38 <Lord_Illidan> I just saw an implementation of merge sort in haskell
10:11:44 <Lord_Illidan> it's a breath of fresh air imho
10:12:05 <byorgey> Lord_Illidan: it certainly doesn't "take a semester for the smartest undergraduates to learn", unless by "learn" you mean "write a type checker in the type system"
10:12:19 <MyCatVerbs> shag: I'm not actually sure about whether or not file descriptors are seekable if you open them in append mode in POSIX. I wouldn't be surprised if they were explicitly not seekable, as an optimization (and for other purposes).
10:12:27 <glen_quagmire> if haskell.org library docs have php.net like comments. it'll attract people.
10:12:40 <Cheery> hm.. Can you communicate with drivers from haskell?
10:12:54 <Cheery> I wonder about using /dev/js and pals directly
10:12:57 <MyCatVerbs> byorgey: heh. Like the school of logic programming pedology where you teach people how to implement Prolog before teaching them how to use it? :D
10:13:07 <byorgey> MyCatVerbs: right =)
10:13:20 <MyCatVerbs> Cheery: it'd be exactly the same as speaking to them in C, with some reservations.
10:13:37 <Lord_Illidan> MyCatVerbs, I tried Prolog at uni
10:13:39 <Cheery> so what? :)  I just need it done.
10:14:03 <Lord_Illidan> Our lecturer wasn't so good, though..in 3 weeks, we've done more in Haskell than we did in a whole semester of Prolog
10:14:07 <MyCatVerbs> Cheery: the only problem I can think of is that you can't tear things up by casting pointers around randomly in the same way. But, eh, Data.Binary.
10:14:42 <Cheery> I access those driver handles like I'd access files?
10:14:51 <MyCatVerbs> Lord_Illidan: I'm not entirely convinced that Prolog is more useful than, say, unlambda. >_>
10:15:02 <byorgey> Lord_Illidan: oh, you are taking a class on Haskell?  cool.
10:15:07 <ska-fan> How do you do the thing in haskell where you define f n and constantly need (n - 1) in the code and don't want to repeat that everywhere?
10:15:07 <MyCatVerbs> Cheery: yeah, that's the whole *point* of Unix's everything-is-a-file mantra. :)
10:15:24 <byorgey> Lord_Illidan: can I ask what school you're at? just curious
10:15:28 <Cheery> I thought unix's everything-is-a-file mantra is broken to some extent
10:15:30 <Deewiant> ska-fan: let foo = n - 1 in ...
10:15:33 <MyCatVerbs> ska-fan: let bleh = (n-1) in ...
10:15:36 <ska-fan> thanks
10:15:39 <lament> Lord_Illidan: wow, that's actually a really nice article.
10:15:39 <Deewiant> ska-fan: or, ... where foo = n - 1
10:15:40 <MyCatVerbs> Cheery: it is, and a sad thing, too.
10:15:49 <Lord_Illidan> byorgey, the University of Malta
10:15:58 <Cheery> thought guess plan9 propaganda may overemphasize
10:16:03 <byorgey> Lord_Illidan: oh, cool =)
10:16:18 <MyCatVerbs> Cheery: no, it doesn't really. It really is that broken. :/
10:17:15 <shag> MyCatVerbs: ReadWriteMode is the key if you want to open an existing file and seek around. hSeek handle SeekFromEnd 0 works fine, thanks for the tip
10:17:17 * ska-fan likes it how variables can have ' in their names
10:17:22 <Cheery> hm. I wonder, if I open a handle to a thing like keyboard or mouse, X11 can't use it?
10:17:30 <MyCatVerbs> shag: spiffy. ^_^
10:18:04 <Lord_Illidan> I recall the developer of UT called Haskell the next best language?
10:18:05 <Cheery> wondering.. I remember said that there's support for multiple mice and keyboards in linux, but not in X
10:18:14 <desegnis> ska-fan, in most cases that will even be an optimization, because foo won't be calculated more than once
10:18:25 <Cheery> *somebody said once
10:18:31 <cjb> (actually, multi-pointer support in X is being merged in right now.)
10:18:41 <Cheery> :>
10:18:41 <cjb> but that's not really related to your question.
10:18:44 <MyCatVerbs> Can variables have ! or ? in their names, come to think of it?
10:18:45 <Deewiant> cjb: it is?! talk about 20 years in the waiting
10:18:55 <Deewiant> cjb: I've complained about lack of that for as long as I can remember :-)
10:18:58 <Cheery> :D
10:19:03 <MyCatVerbs> > let damnation! = 5 in damnation! + 1
10:19:03 <lambdabot>  Parse error at "=" (column 16)
10:19:09 <MyCatVerbs> Awwww. Oh well.
10:19:14 <byorgey> MyCatVerbs: I don't think they can.
10:19:18 <oerjan> MyCatVerbs: nope, those are operator characters
10:19:18 <cjb> Deewiant: yup, see Peter Hutterer's LCA talk for details.  It's called "mpx".
10:19:18 <MyCatVerbs> > let whut? = 40 in whut?
10:19:18 <lambdabot>  Parse error at "=" (column 11)
10:19:25 <MyCatVerbs> oerjan, byorgey: damn. Oh well.
10:19:27 <glen_quagmire> > haskellStyle
10:19:30 <lambdabot>   Not in scope: `haskellStyle'
10:19:32 <ska-fan> @hoogle (a -> b -> c) -> (b -> a -> c)
10:19:33 <lambdabot> No matches, try a more general search
10:19:35 <Lord_Illidan> Cheery, http://wearables.unisa.edu.au/mpx/
10:19:37 <lambdabot> Title: MPX: The Multi-Pointer X Server
10:19:54 <desegnis> Cheery, X11 sucks at mice anyway. I still didn't bother to set up the extra keys of my mouse :)
10:19:58 <shapr> Is there a darcs plugin for visual studio?
10:20:00 <oerjan> > let (!?!?) = 1 in (!?!?)
10:20:03 <smg> hello.
10:20:09 <Cheery> hm.. I wonder..
10:20:09 <byorgey> MyCatVerbs: IIRC (non-operator) names are only allowed to contain [a-zA-Z0-9_']
10:20:10 <glen_quagmire> http://www.haskell.org/ghc/docs/latest/html/libraries/parsec/src/Text-ParserCombinators-Parsec-Language.html#haskellStyle
10:20:11 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/ytlrx9
10:20:15 <lambdabot>  thread killed
10:20:17 <oerjan> what?
10:20:17 <dino-> I've got a project I'm working on, cabal things work fine on one system with Cabal-1.2.3.0 but I get errors on another system with Cabal-1.2.3.0, Cabal-1.3.6
10:20:19 <oerjan> > let (!?!?) = 1 in (!?!?)
10:20:20 <lambdabot>  1
10:20:26 <byorgey> hi smg
10:20:30 <shapr> I like multiple pointers in X
10:20:31 <oerjan> MyCatVerbs: ^^
10:20:32 <MyCatVerbs> byorgey: and also random utf-8 characters, too. :)
10:20:33 <smg> a performance question: if i use strictness ! and i specify my module which stuff to export it will generate more optimized code right?
10:20:37 <glen_quagmire> identLetter is [_'\w]
10:20:42 <byorgey> MyCatVerbs: oh, good point.
10:20:49 <dino-> In particular, things like Setup.lhs: photoname.cabal:2: Parse of field 'version' failed:
10:20:51 <pjd> smg: more strict code, maybe
10:20:51 <shapr> smg: There may be more opportunities for optimization, yes :-)
10:20:55 <Cheery> guessing the stuff to communicate with drivers can be read from some linux kernel dev site or such
10:21:02 <dino-> Does that seem familiar to anyone?
10:21:08 <pjd> which might or might not correspond to "more optimized" :)
10:21:15 <shapr> dino-: What does your version value look like?
10:21:16 <byorgey> smg: just putting ! everywhere does not guarantee more optimized code, though
10:21:22 <MyCatVerbs> byorgey: it just seems a little bit of a pity that we can't steal Scheme's !-postfix and ?-postfix convention for unsafe and predicate functions, respectively.
10:21:24 <smg> -no-recomp <-- what does this flag do?
10:21:27 <dino-> Version:             004
10:21:27 <smg> byorgey: yeah sure :)
10:21:40 <shapr> dino-: Maybe it doesn't like leading zeroes?
10:21:43 <byorgey> MyCatVerbs: I agree that might be nice.
10:22:04 <oerjan> MyCatVerbs: actually i think the unicode classification scheme (alphabetic, symbolic, whatever) is used
10:22:08 <dino-> Lame if I suddenly can't use whatever string I'd like there.
10:22:08 <shapr> dino-: Tried 0.4 ?
10:22:16 <shapr> dino-: Submit a patch? :-)
10:22:17 <dino-> Wasn't like that in 1.2.3.0
10:22:18 <dino-> :(
10:22:21 <dons> ?users
10:22:21 <lambdabot> Maximum users seen in #haskell: 463, currently: 435 (94.0%), active: 27 (6.2%)
10:22:27 <shapr> g'day dons!
10:22:28 <gwern> we already know, hence the divorce
10:22:37 <Cheery> on top of that, I probably need some way to steal the access to keyboard and mice from X
10:22:37 <byorgey> dino-: I'm pretty sure you can't use any string you like as the version.
10:22:43 <MyCatVerbs> oerjan: that would be sensible, aye.
10:22:49 <smg> This entry in fact runs faster than hand optimised (and vectorised) GCC! And is only slower than optimised Fortran. Lesson: Haskell can be very, very fast. <-- hehe
10:22:55 <gwern> smg: I would guess it means 'no recompilation', as opposed to the force recompilation option
10:22:56 <byorgey> dino-: Cabal needs to be able to parse it in order to resolve dependencies and so forth.
10:23:26 <shapr> smg: What's that from?
10:23:27 <MyCatVerbs> smg: I wonder what Fortran compiler?
10:23:33 <dino-> Yeah. I must go read docs on what's acceptable for version format.
10:23:38 <dino-> Thanks guys.
10:23:42 <smg> http://www.haskell.org/haskellwiki/Performance/GHC
10:23:42 <lambdabot> Title: Performance/GHC - HaskellWiki
10:24:34 <shapr> dons: How's code?
10:24:40 <dons> spicy!
10:24:41 <dino-> Also cabal-related, what's this about:  Warning: Deprecated use of `defaultUserHooks'
10:24:59 <smg> inlining and primops are also interesting :)
10:25:14 <dons> dino-: it means the Setup.hs is using hooks that are a bit deprecated
10:25:15 <dino-> I'm not finding what to use instead of this deprecated API in the 1.3.6 haddock.
10:25:25 <dino-> I know, but what to do instead.
10:25:28 <dons> dino-: not use hooks, perhaps?
10:25:30 <dons> if that's possible
10:25:37 <gwern> ignore it for now, imo
10:25:44 <SamB> it's a very good idea to avoid using hooks if possible
10:26:23 <dino-> Ok, I think maybe I'm designing my Setup.lhs in some bad/old way and again should go read about recent cabal.
10:26:24 <SamB> they seem to break fairly often...
10:26:34 <lament> "1930s metamathematicians were fascinated by the fact that they could represent any data structure as a function. While this is true, to describe it as perverse is an insult to perverts."
10:26:57 <SamB> lament: who wrote that silly thing?
10:27:08 <SamB> it's actually not very complicated at all
10:27:11 <Cale> It's not in the least bit perverse.
10:27:15 <lament> SamB: http://unqualified-reservations.blogspot.com/2007/08/whats-wrong-with-cs-research.html
10:27:26 <lambdabot> Title: Unqualified Reservations: What's wrong with CS research
10:27:33 <oerjan> lament: er and some are still fascinated by doing the same with sets...
10:27:34 <dons> oh that guy
10:27:37 <shepheb> it also pretends currying is a) unique to Haskell and b) a bad idea
10:27:45 <dons> yeah, he's nuts, lament
10:27:57 <lament> i can tell he's nuts, but he's nuts in a refreshing way
10:28:06 <lament> and he does have a point
10:28:08 <shepheb> shame really, it seems well-written and organized.
10:28:26 <oerjan> get your refreshing nuts here!
10:28:34 <glen_quagmire> let's say I have:  opAdd :: [Val] -> Val;  opAdd [Int a, Int b] = Int (a + b) ;   how would partial application look like for opAdd ?   opAdd (Int a : xs) = Int (a+) .. ?
10:28:53 <dons> shapr: swedish hackathon on 5 weeks!
10:29:05 <lament> shepheb: he's not against currying, he's against representing data as code, which haskell encourages
10:29:07 <oerjan> glen_quagmire: opAdd.(++)
10:29:18 <dons> shapr: also, did you see dmg's new yhc/javascript compiler is online (in alpha!)
10:29:35 <SamB> I admit I cannot help but admit that you can't easily send lambdas over networks...
10:29:37 <oerjan> er wait
10:29:40 <SamB> er.
10:29:42 <SamB> too many admits!
10:29:43 <lament> SamB: or debug them
10:29:48 <oerjan> (opAdd.).(++)
10:30:14 <oerjan> or actually for just one param at a time,
10:30:18 <SamB> lament: debugging is *possible*
10:30:19 <oerjan> (opAdd.).(:)
10:30:29 <SamB> well, so is sending over networks...
10:30:34 <lament> SamB: yes, exactly.
10:30:36 <SamB> but that involves a bit more coordination
10:30:47 <shepheb> lament: then I wonder what part of "functions are data" makes it surprising that data and functions are, well, the same.
10:30:58 <SamB> debugging doesn't have to be compatible, network protocols do
10:31:06 <oerjan> > ((concat.).(:)) "ab" ["cd","ef"]
10:31:07 <lambdabot>  "abcdef"
10:31:29 <shepheb> anyway, last time I check smart but not superstar CS undergrads could learn Haskell in a couple of weeks.
10:31:34 <glen_quagmire> oerjan: :t (opAdd.).(:)    --> (opAdd.).(:) :: Val -> [Val] -> Val  wheeeeeeeeeee
10:31:52 <Valodim> well "learn" /= "learn"
10:31:54 <shapr> dons: Cool! and not yet
10:31:56 <dino-> Huh, I wonder how to do stuff like run your test suite without custom hook.
10:32:00 <Deewiant> > "learn" /= "learn"
10:32:01 <lambdabot>  False
10:32:09 <Valodim> :P
10:32:19 <smg> oerjan: i think i should optimize code only when i need it or?
10:32:24 <lament> shepheb: obviously data and functions can be represented the same, that's church-turing equivalence. The whole point of PL design, though, is to choose the most appropriate representation of stuff
10:32:29 <ska-fan> Is there a pseudorandom number generator in hugs / ghc?
10:32:40 <Valodim> yes
10:32:40 <Deewiant> @hoogle random
10:32:41 <lambdabot> System.Random.random :: (Random a, RandomGen g) => g -> (a, g)
10:32:41 <lambdabot> System.Random :: module
10:32:41 <lambdabot> System.Random.Random :: class Random a
10:32:41 <lament> bah, he left.
10:32:49 <smg> oerjan: so i just set appropriate command line args to ghc and that will be enough, if i need more performance i would use primops/unboxing and inlining?
10:34:06 <sclv> smg: inlining can be "jacked up" for the entire compilation with -fset-unfolding-threshshold I think.
10:34:20 <oerjan> smg: ghc should optimize many of those things with -O options
10:34:24 <dino-> dons: Did you ever get a patch from me for mkcabal?
10:34:32 <lament> shepheb: obviously data and functions can be represented the same, that's church-turing equivalence. The whole point of PL design, though, is to choose the most appropriate representation of stuff
10:34:35 <dino-> I'm wondering if there was email failure that never got back to me.
10:34:37 <oerjan> although i am not an optimization expert here :)
10:34:38 <sclv> and as for primops/unboxing, you'll be shocked by how much smarter the compiler is than you, usually.
10:35:06 <lament> shepheb: and, for example, you obviously wouldn't use church numerals in actual programs, even though you can
10:35:09 <glen_quagmire> oerjan: how did you get to (opAdd.).(:) ? I am wondering how to do it myself when i face similar situation
10:35:11 <sclv> generally you'll find performance issues more in yr algorithms or data structures, or maybe a laziness issue.
10:35:23 <oerjan> glen_quagmire: you can use @pl
10:35:38 <oerjan> @pl \x xs -> opAdd (x:xs)
10:35:38 <lambdabot> (opAdd .) . (:)
10:35:38 <smg> oerjan: yeah i have ghc -O2 -funfolding-use-threshold=16 -optc-O3 -optc-ffast-math
10:35:47 <smg> oerjan: i guess this will be enough for now
10:35:56 <shapr> sclv: Good advice!
10:36:09 <glen_quagmire> is there unpl ?
10:36:18 <glen_quagmire> @unpl (opAdd .) . (:)
10:36:18 <lambdabot> (\ d g -> opAdd (((:)) d g))
10:37:05 <ska-fan> Can I write a file file.hs such that when I call hugs file.hs I can type take 5 rnd and it returns 5 pseudorandom numbers?
10:37:22 <oerjan> glen_quagmire: that ((:)) is disappointing
10:37:33 <oerjan> it really should know better
10:37:46 <oerjan> @unpl (+) a b
10:37:47 <lambdabot> a + b
10:37:50 <smg> hehe
10:37:51 <oerjan> @unpl (:) a b
10:37:51 <lambdabot> (:) a b
10:38:03 <oerjan> that's weird
10:38:13 <oerjan> @unpl (+*) a b
10:38:13 <lambdabot> a +* b
10:38:16 <Deewiant> @unpl a + b
10:38:16 <lambdabot> (a + b)
10:38:24 <glen_quagmire> @unpl (.(:))
10:38:24 <lambdabot> (\ a d -> a (((:)) d))
10:38:35 <glen_quagmire> probably . adds ()
10:38:39 <oerjan> it seems to be bad at removing parentheses?
10:39:04 <oerjan> of course it may not always be able to guess precedence, but still
10:39:23 <oerjan> @unpl (+) a ((*) b c)
10:39:23 <lambdabot> a + (b * c)
10:39:36 <oerjan> @unpl (+) a (b * c)
10:39:36 <lambdabot> a + (b * c)
10:41:11 <oerjan> ska-fan: you need a bit of IO in there, so not quite
10:41:57 <oerjan> but you can get an infinite list of random numbers in IO as:
10:42:24 <Deewiant> well, you don't need IO if you're willing to use the same seed each time ;-)
10:42:25 <ska-fan> oerjan: "in IO" contradicts "on the hugs command line"?
10:42:26 <smg> ah if i strip my haskell programm it get's really much more smaller
10:42:37 <sclv> ?pl \x -> M.lookup x ()
10:42:37 <lambdabot> flip M.lookup ()
10:42:46 <oerjan> ska-fan: no
10:42:50 <sclv> ^^ my pl changes were finally pushed!
10:43:06 <oerjan> but you cannot do take 5 rnd literally
10:43:18 <sclv> they're not perfect, but it handles () (mainly) as well as package namespacing. whee.
10:43:51 <ska-fan> oerjan: ok :) how?
10:44:02 <sclv> also, more operator precedences, btw.
10:44:18 <sclv> for the whole applicative and arrow suite.
10:44:34 <oerjan> > liftM (take 5) (randomRs (1,6) =<< newStdGen)
10:44:34 <lambdabot>  Couldn't match expected type `[a]'
10:44:38 <oerjan> er
10:44:43 <oerjan> ah
10:44:53 <oerjan> > liftM (take 5 . randomRs (1,6)) newStdGen
10:44:55 <lambdabot>  <IO [Integer]>
10:44:57 <Deewiant> @pl h f g = (>>= return . g) . f
10:44:57 <lambdabot> h = flip ((.) . fmap)
10:45:04 <Deewiant> @. pl unpl h f g = (>>= return . g) . f
10:45:04 <lambdabot> h = (. (return .)) . flip . ((>>=) .)
10:45:26 <oerjan> ska-fan: that should work if you have System.Random loaded
10:45:29 <Deewiant> ah well
10:45:31 <oerjan> er wait
10:45:45 <oerjan> make that fmap (take 5 . randomRs (1,6)) newStdGen
10:45:48 <ska-fan> @hoogle liftM
10:45:48 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
10:45:48 <lambdabot> Control.Monad.liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:45:48 <lambdabot> Control.Monad.liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
10:45:56 <oerjan> otherwise you need Control.Monad too
10:46:12 <ska-fan> ok :)
10:46:22 <Deewiant> I pretty much import Control.Monad and Control.Arrow by default these days :-P
10:46:33 <ska-fan> fmap (take 5 . randomRs (1,6)) newStdGen
10:46:33 <ska-fan> ERROR - Unresolved overloading
10:46:33 <ska-fan> *** Type       : (Num a, Random a) => IO [a]
10:46:33 <ska-fan> *** Expression : fmap (take 5 . randomRs (1,6)) newStdGen
10:47:19 <gbacon> shouldn't instance ((:<:) String) ByteString be equivalent to ByteString :<: [Char]
10:47:21 <gbacon> ?
10:47:22 <Deewiant> ska-fan: hugs sux? try randomRs (1::Int, 6) or something
10:47:42 * shapr answers ##csharp questions with Haskell code
10:47:54 <oerjan> ska-fan: oh right there's a hugs bug
10:47:54 <gbacon> shapr: nice :-)
10:48:03 <Deewiant> shapr: and what kind of response do you get :-)
10:48:04 <SamB> shapr: scarier is when they say "thanks, that helped!"
10:48:07 <MyCatVerbs> shapr: how evil.
10:48:09 <oerjan> it doesn't recognise Random as a defaultable class
10:48:13 <SamB> *after* trying
10:48:15 <ska-fan> Oh.
10:48:23 <MyCatVerbs> shapr: keep it up and maybe you'll get them to all switch to F#. :)
10:48:23 <ska-fan> Deewiant: same error btw.
10:48:29 <shapr> Someone asked if it was possible to define the powerset with recursive code.
10:48:31 <oerjan> fmap (take 5 . randomRs (1,6 :: Int)) newStdGen
10:48:43 <shapr> So I handed them Koen Claessan's mutually recursive powerset code.
10:48:49 <ska-fan> oerjan: that works but it returns (or at least outputs) nothirg
10:48:51 <SamB> shapr: sounds reasonable
10:48:53 <shapr> I can almost smell brain smoke from here.
10:49:03 <Robin_Huber_1808> ^^
10:49:04 <oerjan> ska-fan: ah yes hugs doesn't print the result of IO actions
10:49:05 <Deewiant> how can (1::Int, 6) not work but (1, 6 :: Int) works?
10:49:19 <oerjan> Deewiant: they both should
10:49:19 <SamB> maybe you should only do that in ##vb.net
10:49:21 <oerjan> i think
10:49:27 <Deewiant> oerjan: he said the former doesn't
10:49:38 <Le-Chuck_ITA> Did I see "we put the funk in funktor" already? Some of you know?
10:49:46 <Le-Chuck_ITA> I don't want to steal someone's else's slogan
10:49:50 <Le-Chuck_ITA> for...
10:49:52 <Le-Chuck_ITA> #catz
10:49:53 <Le-Chuck_ITA> :)
10:49:59 <ska-fan> loading, too
10:50:10 <shapr> MyCatVerbs: I still haven't tried F#, but I'd like to... I've heard it's ML-like
10:50:10 <ska-fan> Deewiant: just randomRs (1,6 :: Int) gives unresolved overloading, too
10:50:10 <SamB> Le-Chuck_ITA: I have seen it
10:50:15 <SamB> probably in the topic here
10:50:21 <MyCatVerbs> shapr: that'd be the point. :)
10:50:27 <oerjan> ska-fan: print . take 5 . randomRs (1,6 :: Int) =<< newStdGen
10:50:29 <Deewiant> ska-fan: giving Int on both works, or what?
10:50:32 <dino-> Ok, I see that I can get the custom hooks behavior by switching the simpleUserHooks, but I'm curious about the 'not using hooks' part.
10:50:42 <Le-Chuck_ITA> if it was in the topic here, I keep that for the topic there :)
10:50:47 <dino-> Are things like the test suite to be handled by entries in the .cabal file?
10:51:03 <oerjan> ska-fan: that's probably from the RandomGen
10:51:28 <SamB> it *is* possible for more than one organization to put the funk in function
10:51:35 <shapr> Le-Chuck_ITA: "We put the funk in funktor/funktional" came from a comment Manual Chakravarty made here on #haskell in the first year or so.
10:51:37 <SamB> functions are pretty funky ;-P
10:51:56 <ska-fan> Deewiant: the difference isn't in where the :: Int is, but whether it's just randomRs (something) or the whole expression with fmap and so on
10:51:58 <Le-Chuck_ITA> shapr: the only true problem with F# is the license of the compiler IMHO
10:52:15 <shapr> What's the license?
10:52:23 <Le-Chuck_ITA> microsoft shared source
10:52:32 <MyCatVerbs> SamB: indeed, there is much funk, and putting it in place would require multiple organizations, certainly.
10:52:35 <shapr> I do not enjoy dealing with stuff that requires a license key, that much I have figured out.
10:52:42 <Deewiant> ska-fan: ah. Of course I meant that you should use the whole expression with just that bit changed :-)
10:52:46 <SamB> Le-Chuck_ITA: is that any worse than VS express?
10:52:47 <MyCatVerbs> SamB: wait, ignore me, I just said nothing.
10:53:02 <Le-Chuck_ITA> I'd like to use F# to produce free software, but if the only compiler is under that licence, my code will never be able to go in ubuntu universe
10:53:11 <MyCatVerbs> SamB: I mean that there is so much funk that its deployment is not a task that can be completed by a single organisation alone.
10:53:12 <oerjan> ska-fan: Deewiant: in fact with just randomRs (something) it is correct haskell 98 behavior to complain, since RandomGen is not a numeric class
10:53:24 <Le-Chuck_ITA> SamB: I don't use VS since when I resigned as a developer
10:53:30 <shapr> I'm upset in any case where I use software where I cannot access the source.
10:53:43 <SamB> Le-Chuck_ITA: what did you resign over?
10:53:52 <cjb> shapr: are you upset when you develop software for which other people cannot access the source?  :)
10:53:52 <Le-Chuck_ITA> I started my ph.d.
10:53:59 <ska-fan> Ok, I see that random numbers are still a bit over my head.
10:54:00 <SamB> ah
10:54:11 <Le-Chuck_ITA> SamB: maybe I used the wrong english word
10:54:13 <SamB> not a protest then ;-)
10:54:14 <shapr> cjb: Yes
10:54:19 <SamB> Le-Chuck_ITA: not a bit
10:54:29 <SamB> but in the context of not having used it since...
10:54:36 <Le-Chuck_ITA> SamB: I was about to do that to protest :)
10:54:42 <oerjan> ska-fan: one tricky bit is that you need IO to get an initial random seed
10:54:46 <Le-Chuck_ITA> It was visual studio for .net 1.0
10:54:46 <shapr> cjb: I'd much rather give it all away and get paid large sums of money to do software as a service via the Haskell Highway.
10:54:50 <MyCatVerbs> shapr: entirely out of curiosity, Loonix, Bezerkely, or something else?
10:55:03 <oerjan> ska-fan: after that you can theoretically do things purely
10:55:06 <MyCatVerbs> shapr: (preference, rather than which you actually use)
10:55:14 <Le-Chuck_ITA> which really was visual studio for .net 0.098 alpha three (with super combos)
10:55:26 <ska-fan> oerjan: I could live with seeding the same value every time
10:55:32 <Le-Chuck_ITA> Ok, I sometimes feel the need to talk about categories
10:55:33 <SamB> Le-Chuck_ITA: that's how microsoft works
10:55:45 <shapr> I haven't tried BSD, but I've been using Linux on my desktop since '99 or so. Windows really pissed me off.
10:55:46 <Le-Chuck_ITA> so I founded #catz for the purpose
10:55:48 <ska-fan> Then I could probably just write a custom rnd generator
10:55:49 <SamB> it's not only microsoft that has problems with x.0, anyway
10:56:03 <shapr>  This job I got in January is my first use of microsoft since then.
10:56:03 <ska-fan> and track the seed as state, hmm
10:56:14 <MyCatVerbs> shapr: heh. Ever heard the saying, "Linux is for people who hate Windows, BSD is for people who love Unix"? ;)
10:56:21 <oerjan> > take 5 . randomRs (1,6 :: Int) $ mkStdGen 42 -- ska-fan: that is possible too
10:56:26 <lambdabot>  [6,4,2,5,3]
10:56:29 <shapr> It's interesting, that's for sure. Microsoft products have changed dramatically since '99
10:56:34 <shapr> MyCatVerbs: Nah, haven't heard that.
10:56:38 <oerjan> and no IO required
10:56:48 <Valodim> yeah they found that happy colors sell
10:56:57 <Valodim> (-> xp onward)
10:57:02 <ska-fan> oerjan: oh, great :)
10:57:04 <shapr> I don't love Unix in and of itself, but it sure does suck less than Windows... as long as I can access the source, of course.
10:57:15 <MyCatVerbs> shapr: I usually use Loonix myself, but more for the bloody convenient package managers than any particularly strong like of the whole system.
10:57:16 <shapr> cjb: What about you, do you get upset by those things?
10:57:19 * roconnor <3 OS/2
10:57:26 <SamB> I have to wonder how much windows would suck if I could access the source
10:57:32 <shapr> Yeah, I'd rather have an exokernel.
10:57:35 <Lord_Illidan> I've been using 100% Linux for about a year now
10:57:41 <SamB> (and not only I but a lot of people who are smarter than I am)
10:57:53 <MyCatVerbs> shapr: ahhh. Personally, I genuinely like Unix on its own merits, except for all the places where it sucks. ;)
10:58:05 <Le-Chuck_ITA> I've been using 100% linux for 8 years or so :)
10:58:14 <shapr> MyCatVerbs: forall a . I like a except for all the places where a sucks.
10:58:26 <ska-fan> 9 years! :)
10:58:27 <SamB> Le-Chuck_ITA: and you aren't a Linux-hater yet?
10:58:29 <Lord_Illidan> shame is that people at uni all use windows :(
10:58:31 <MyCatVerbs> shapr: the last part was ha-ha-only-serious. :)
10:58:37 <Le-Chuck_ITA> SamB: that's the ugly thing
10:58:38 <shapr> I can dig it
10:58:50 <SamB> Le-Chuck_ITA: eh?
10:58:57 <Le-Chuck_ITA> I don't hate it yet
10:59:05 <Le-Chuck_ITA> how can I be productive with something I don't hate?
10:59:06 <oerjan> ska-fan: handling the random generator as state is what the library is designed for, btw:  most of the functions return a new generator to use for the next selection
10:59:16 <SamB> Le-Chuck_ITA: hah
10:59:19 <ska-fan> oerjan: yeah, this is cumbersome
10:59:30 <shapr> ska-fan: Random monad fixes that!
10:59:34 <MyCatVerbs> shapr: besides, *glances towards Washington* there are many things in this world for which enumerating the ways in which they fail to suck is much briefer than enumerating the ways in which they do suck.
10:59:34 <SamB> Le-Chuck_ITA: well, how much RAM do you have
11:00:20 <Le-Chuck_ITA> SamB: 1Gb
11:00:26 <Le-Chuck_ITA> but when I started, I got 32mb
11:00:33 <largos> are there any mature wikis written with haskell?
11:00:35 <Le-Chuck_ITA> /got/had/
11:00:37 <shapr> MyCatVerbs: truly
11:00:48 <shapr> largos: Tried Flippi and HAppSWiki?
11:00:50 <gwern> largos: no
11:00:54 <SamB> Le-Chuck_ITA: remove 512mb. maybe that will solve your problem. (if not, install KDE.)
11:01:01 <shapr> largos: Part of the problem is that it's so easy to write a wiki, there are many.
11:01:12 <ska-fan> @hoogle cross product
11:01:13 <lambdabot> Did you mean: Cross Product
11:01:13 <lambdabot> Prelude.undefined :: a
11:01:13 <lambdabot> Control.Monad.State.Class.get :: MonadState s m => m s
11:01:14 <gwern> shapr: he said mature; those are far from mature. you can't run flippi with a recent GHC, and who knows about happswiki
11:01:17 <dino-> As this spins wildly further OT: I stopped all use of Windows in 2002. And I've been able to locate only employment where I use Linux or UNIX since then.
11:01:30 <largos> shapr: yeah.. that's part of the reason I'm asking -- that and googling for haskell wiki generates a lot of *entries* about haskell
11:01:32 <shapr> Well, I haven't updated happswiki, that's for sure.
11:01:43 <shapr> And since I wrote it... maybe I should.
11:01:54 <Cheery> whenever you had Monads or unique -types, I've thought it'd be nice to have type signatures where one name can contain multiple instances and pick them along the purpose
11:01:59 <shapr> Actually, I wonder if I should update flippi as well.
11:02:01 <largos> shapr: which version of happs does happswiki use?
11:02:05 <gwern> shapr: and put it on hackage, then...
11:02:12 <shapr> largos: HeckifIknow
11:02:17 <largos> <G>
11:02:25 <shapr> gwern: Or I could like, get a date, with a girl even.
11:02:26 <ska-fan> do you usually write top-down or bottom-up in haskell?
11:02:45 <Cheery> say, you'd split the IO -Monad to submonads which implement the stuff you want..
11:02:52 <oerjan> ska-fan: look at hackage, there is probably a vector library there
11:02:54 * gwern does not see the connection between dates, preferably with a female, and writing wikis in haskell
11:03:12 <shapr> ska-fan: I think I write top-down first, then do bottom-up refactoring to use Prelude and library functions as smoothly as possible.
11:03:13 <byorgey> ska-fan: I often find myself writing top-down, and then refactoring bottom-up.
11:03:15 <gwern> shapr: wait, does that imply you'd go on a date with a guy if you couldn't get a girl?
11:03:15 <Le-Chuck_ITA> ska-fan: top down,  using undefined everywhere
11:03:20 <shapr> gwern: nooo
11:03:24 * byorgey high-fives shapr
11:03:34 <shapr> gwern: I mean that I have a very limited amount of free time.
11:03:38 <Cheery> then, say you'd only use readStr and writeStr, the type signature for main would be :: {IORead, IOWrite}
11:03:45 <Cheery> or rather.
11:03:51 <shapr> gwern: Plus, you're not my type anyway :-P
11:03:52 <Cheery> :: {IORead, IOWrite} ()
11:04:09 <gwern> shapr: you barely even know me :(
11:04:11 <byorgey> Cheery: yes, that would be nice!
11:04:14 <gwern> ' get a date, with a girl even'
11:04:20 <MyCatVerbs> gwern: when did you become a teenager?
11:04:22 <shapr> gwern: Are you a girl?
11:04:36 * gwern is just badly emulating @vixen
11:04:40 * shapr laughs
11:04:45 <MyCatVerbs> gwern: (referring only to "you barely even know me", not anything else that's been said, I haven't read the rest of the conversation)
11:04:47 <gwern> @vixen am I shapr's type?
11:04:47 <lambdabot> isn't it obvious?
11:04:55 <byorgey> hahahaha
11:04:59 <shepheb> I'm surprised no one's quoted shapr back there yet.
11:04:59 <roconnor> > concatMap (repeat [])
11:05:00 <lambdabot>  Couldn't match expected type `a -> [b]'
11:05:07 <roconnor> > concat (repeat [])
11:05:08 <lambdabot>  Exception: <<loop>>
11:05:12 <shapr> shepheb: Or, quoted shapr about what?
11:05:18 <Le-Chuck_ITA> dino-: fancy I have just finished a small _paid_ work to do a free software and publish it on sourceforge :) and tomorrow morning I have a meeting to start a second one in a different company
11:05:27 <Le-Chuck_ITA> world is changing!
11:05:30 <Cheery> byorgey: did you say that with sarcasm without evaluating what I said? :/
11:05:35 <shapr> Oh, you mean saved something I said?
11:05:37 <shepheb> the original, the "Or I could get a date..."
11:05:45 <shapr> heh
11:05:51 <roconnor> > foldl (+) 0 [0..]
11:05:56 <lambdabot> Terminated
11:05:59 <shapr> I probably have enough quotes saved as it is.
11:06:04 <shapr> I'm a funny guy.
11:06:09 <byorgey> Cheery: no, I was agreeing with you.  sorry if it came across as sarcasm, I didn't intend that.
11:06:17 <shapr> That's what most of the chicks tell me... "you're a bit funny..."
11:06:22 <shepheb> @quote shapr
11:06:22 <lambdabot> shapr says: [on Oleg:]  And ccshan and he would argue furiously for a minute or two and then SPJ would say "Why don't you send an email to the Haskell list about that so we can have time to understand
11:06:22 <lambdabot>  what you just said?"
11:06:23 <SamB> gwern: I suppose the alternative would be going on a date by himself ;-)
11:06:53 <shapr> That was cool, Haskell Workshop 2006.
11:07:08 <shapr> @quote shepheb
11:07:08 <lambdabot> No quotes match.
11:07:10 <shapr> aww
11:07:27 <Cheery> byorgey: ok, anyway, there are problems to solve, like. what to do if you hit type signature like {Int, Char}, then use a function from Ord for that type?
11:07:35 <shepheb> I'm pretty sure something of mine got quoted a while back.
11:07:44 <MyCatVerbs> SamB: or finding a date with a sheep. (Admittedly I'm Welsh, so my perspective on that might be skewed.)
11:07:46 <shapr> I wonder where it went?
11:08:18 <shapr> Is a name like branwen Welsh?
11:08:19 <gwern> SamB: 1 is the loneliest data...
11:08:25 <byorgey> Cheery: so {foo, bar} is sort of an ad-hoc anonymous typeclass?
11:08:28 <Stinger_> datum?
11:08:37 <gwern> I've always supposed so
11:08:50 <shapr> gwern: Do you live near Wales?
11:09:05 <gwern> nowhere near it
11:09:20 <shapr> Um... in the USA?
11:09:55 * gwern would be a fool to deny that - my vocab and cultural references give me away as an american
11:10:20 <Cheery> byorgey: well.. I try write an example, it requires you make a new class, call it Composable, it has one method, decompose :: Composable a => {*} -> a
11:10:25 <shapr> Not to me.. I've not spent enough time in the USA lately to see the difference.
11:10:47 <shapr> Take cjb as an example, spends time in the USA, has a really cool British accent.
11:10:54 <SamB> wouldn't that be Decomposable?
11:11:21 <Cheery> SamB: hmm.. you may have a point there, but lets not argue about names yet
11:11:41 <MyCatVerbs> shapr: Branwen? Sounds like it.
11:11:49 <byorgey> Cheery: what is the {*} ?
11:11:52 <Cheery> lets define   foobar :: {Int, String} -> String
11:11:59 * shapr grins at the guy on ##csharp converting Koen Claessan's powerset code into LINQ
11:12:16 <MyCatVerbs> shapr: oh aye, certainly it is.
11:12:45 <Cheery> foobar c = (decompose c :: String) ++ (intToString $ decompose c :: Int)
11:13:23 <Cheery> hmm. you could actually omit the decompose here
11:13:54 <Cheery> foobar c = (c :: String) ++ (intToString $ c :: Int)
11:13:58 <byorgey> Cheery: hm, it seems you are using {Int, String} as if it is a tuple, (Int,String)
11:14:02 * shepheb occasionally wants a PerlMonks-style home node for other #haskellers, to find out where they live, what education they've got, and what they do to feed themselves.
11:14:12 * oerjan cannot read those functions without thinking "Mozart!"
11:14:17 <kowey> so... I'm trying to compile a library with GHC's -split-objs, but when I build a program using said library, I get linker errors (undefined symbols).
11:14:17 <lambdabot> kowey: You have 1 new message. '/msg lambdabot @messages' to read it.
11:14:25 <kowey> can anybody help me figure out why?
11:14:30 <SamB> feed myself? I put my parents in debt!
11:14:36 <SamB> (further)
11:15:02 <Cheery> byorgey: the purpose is to have multiple values under one name
11:15:06 <SamB> in my defense, they stopped paying me to go to college
11:15:31 <SamB> probably because I switched to a more expensive school
11:16:13 <Cheery> so that it is inferred inside the type what you mean each time..
11:16:59 <Feuerbach> what introduction to FFI would you advise?
11:17:09 <Cheery> thought, I think it has some problems, for instance, it requires that those monads truly are separate, ie. Reading doesn't depend on Writing and so on
11:17:25 <SamB> is there an intro to FFI?
11:17:51 <Cheery> since you aren't ensured anymore then that reading and writing happens in order. :)
11:18:00 <Cheery> just ensured that they happen
11:18:04 <Feuerbach> SamB: I've found at least one, but it isn't very practical
11:18:25 <NatLWalker> is the GHC haskell compiler based on GCC?
11:18:29 <SamB> Feuerbach: maybe you should just look at the GHC manual and the addendum
11:18:32 <SamB> NatLWalker: not a bit
11:18:36 <kalmar> what is the simplest, quickest way to get either hugs or ghc going on os x?
11:18:39 <SamB> the G in this case stands for Glasgow
11:18:47 <NatLWalker> is there any books online about haskell t
11:18:50 <NatLWalker> hrm...
11:18:57 <NatLWalker> nm it's in the tag up there
11:19:00 <SamB> it does sometimes invoke GCC, though...
11:19:07 <pjd> NatLWalker: it supports compiling to C, but this is not a requirement
11:19:16 <Cheery> maybe, need to research out that thing in multiple values with different type in one name
11:19:21 <NatLWalker> cool
11:19:31 <Cale> NatLWalker: There's YAHT and the wikibook, and a number of other resources.
11:19:46 <Cale> @where yaht
11:19:47 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
11:19:50 <Cale> @where wikibook
11:19:50 <lambdabot> http://en.wikibooks.org/wiki/Haskell
11:20:13 <NatLWalker> Thank you :)
11:20:30 <Cale> No problem. If you have any questions, don't hesitate to ask :)
11:20:44 <NatLWalker> Thanks :)
11:20:53 <Deewiant> it uses the GCC C preprocessor though, or?
11:21:27 <Cale> Deewiant: actually, it might use a modified version of the C preprocessor.
11:21:36 <Cale> (At least, when applied to Haskell sources)
11:21:50 <Deewiant> but based on GCC's, anyway.
11:21:53 <Cale> yeah
11:22:28 <Cale> When compiling via C, it obviously uses GCC directly.
11:22:39 <NatLWalker> i just want to avoid having to install GCC is all .
11:22:58 <Cale> It can compile to native code, so I'm not sure that GCC is actually required.
11:23:22 <mrd> it still needs to link, though
11:23:43 <shapr> What about hscpp?
11:26:56 <notsmack> so, i need to use a 3000 entry lookup table in a program...  any recommendations?
11:27:19 <oerjan> Data.Map
11:27:20 <notsmack> Data.Map with fromList gives me:  ghc-6.8.2: panic! (the 'impossible' happened) linkBCO: >= 64k insns in BCO
11:27:27 <notsmack> in ghci
11:27:44 <oerjan> er, that's a bug
11:28:00 <mrd> storing the table in the program?
11:28:05 <mrd> you might want to see the recent thread about that
11:28:17 <notsmack> mrd: was trying to, but only because it seemed simplest
11:28:21 <mrd> "static constants -- ideas?"
11:28:38 <notsmack> mrd: got it, reading
11:29:15 <mrd> particular Don and the Simons have some good examples
11:29:24 <Lemmih> notsmack: You can probably get around it by dividing the list in smaller parts.
11:31:27 <dino-> SamB: You said earlier to avoid using hooks, do you know how to run the test suite without hooks? Or what the right way to connect tests to the build is?
11:31:34 <gwern> what are the odds
11:31:43 <gwern> dino-: I like using darcs hooks myself
11:31:51 <gwern> do the tests for developers not users
11:32:05 <gwern> others disagree with me on this, but that's how I feel
11:32:15 <dino-> If there's some new idea of cabal architecture of a project, I'm interested in knowing about it.
11:32:24 <dino-> Not finding anything on Cabalwiki on it.
11:37:13 <MyCatVerbs> @pl \b -> if b then f else return ()
11:37:13 <lambdabot> flip (flip if' f) (return ())
11:37:19 <MyCatVerbs> @t if'
11:37:19 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:37:25 <MyCatVerbs> @type if'
11:37:29 <lambdabot> Not in scope: `if''
11:37:42 <oerjan> if' i t e = if i then t else e
11:37:48 <oerjan> only in @pl
11:38:29 <oerjan> oh and btw
11:38:45 <oerjan> @src when
11:38:45 <lambdabot> when p s = if p then s else return ()
11:39:05 <Cheery> @hg sleep
11:39:05 <lambdabot> Maybe you meant: . ? @ bf bug ft ghc id msg pl rc thx v wn
11:39:13 <Cheery> @hoogle sleep
11:39:14 <lambdabot> No matches found
11:39:17 <Cheery> @hoogle delay
11:39:18 <lambdabot> GHC.Conc.threadDelay :: Int -> IO ()
11:39:18 <lambdabot> GHC.Conc.registerDelay :: Int -> IO (TVar Bool)
11:39:18 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
11:42:04 <kalmar> so no answer on an easy way to get GHC or hugs on OS X?
11:42:23 <dino-> Somebody was going over this I think maybe last night. The .dmg file?
11:42:27 <dino-> <- not a Mac user
11:42:34 <kalmar> the class I'm TAing is using haskell for a little intro to lazy evaluation
11:43:02 <kalmar> and I need notes on how to get giong on windows (tried this) linux (moslty easy) and os x (having trouble)
11:43:13 <Lemmih> kalmar: They don't work out of the box?
11:43:15 <kalmar> dino-: I have it going on my machine, but I used darwinports
11:43:44 <kalmar> which involves compiling from source, which takes forever
11:43:44 <jgerman> os x should be as simple as installing through darwinports
11:44:42 <Deewiant> @bf a
11:44:42 <lambdabot>  fd:26: hClose: resource vanished (Broken pipe)
11:45:01 <dino-> I don't know if this is different whan what you guys are talking about, but it says binary dist: http://haskell.org/ghc/download_ghc_682.html#macosxintel
11:45:17 <jgerman> dino beat me to the link
11:45:18 <dino-> s/whan/than/
11:45:20 <mattrepl> kalmar: as well as this: http://www.haskell.org/pipermail/glasgow-haskell-users/2008-February/014298.html
11:45:22 <lambdabot> Title: ANN: Mac installer pkg for GHC - 6.8.2.20080211 trial release (Leopard, Intel), http://tinyurl.com/23km8g
11:45:27 <jgerman> but you can install one of those binaries as well
11:45:36 <kalmar> dino-: yeah I saw that, but it includes a bunch of non-trivial prerequisites
11:45:40 <jgerman> what version and processor?
11:45:47 <kalmar> getting dev tools installed, getting libgmp framwork etc
11:46:27 <mattrepl> can get newer versions from hitting the "haskell" directory: http://www.cse.unsw.edu.au/~chak/haskell/
11:46:28 <lambdabot> Title: Index of /~chak/haskell
11:47:02 <jgerman> you're not going to get much easier than those binaries
11:48:46 <kalmar> jgerman: thanks it's a start
11:49:04 <kalmar> maybe getting people to install darwinports is easiest
11:49:54 <jgerman> it's probably a 6 of one, half dozen of the other ... I've had problems with darwin ports in the past, but neither way is actually as big of a pain as it might initially look
11:51:24 <kpreid> the problem with a MacPorts install is that you get to wait for the compile.
11:51:48 <kpreid> also, MacPorts also requires the dev tools to be installed first, too.
11:55:40 <jgerman> installing the dev tools should be one of the first things you do on a new Mac anyways ;)
11:57:30 <oerjan> @users
11:57:30 <lambdabot> Maximum users seen in #haskell: 463, currently: 448 (96.8%), active: 18 (4.0%)
12:02:57 <hpaste>  szuliq annotated "(no title)" with "wtf is 'quotRem'? :P wersja dla uposledzonych (czyli mnie)" at http://hpaste.org/6090#a3
12:04:17 <Cale> hmm
12:04:35 <kalmar> jgerman, kpreid: my main issue is that this is a tiny fraction of the course
12:04:43 <kalmar> 3-4 lectures and one assignment at most
12:05:00 <kalmar> a 12+ hour compile seems overkill
12:05:07 <Cale> kalmar: Don't compile from source.
12:05:09 <kalmar> maybe I'll just tell them to use the lab machines, which have 6.6
12:05:16 <Cale> kalmar: There are binaries on the GHC site.
12:05:17 <jgerman> true, the binary route is the way to go then
12:05:26 <kalmar> Cale: that's what darwinports does
12:05:34 <kalmar> which is the most uniform way to go on OS X
12:05:38 <myki> Hello. I don't completely understand '.' notation (f(g(x)) f.g (x)). May you show me how to transform it to form with dots?: reverse (unfoldr (\n -> if n>0 then Just(intToDigit(mod n 10), div n 10) else Nothing) (fromEnum(n)))
12:05:47 <Cale> Compiling from source is utterly pointless unless you're hacking on GHC.
12:05:55 <Cheery> maybe I'm an idiot of some sort, but I feel I like the Xlib
12:06:01 <Cale> and it's a tremendous waste of time :)
12:06:03 <kalmar> otherwise you have the liftM2 (,) [10.4, 10.5] [ppc, intel] problem
12:06:03 <opqdonut> ?pl everse (unfoldr (\n -> if  n>0 then Just(intToDigit(mod n 10), div n 10) else Nothing) (fromEnum(n)))
12:06:03 <lambdabot> everse (unfoldr (flip (liftM2 if' (> 0) (Just . ap ((,) . intToDigit . flip mod 10) (flip div 10))) Nothing) (fromEnum n))
12:06:10 <jgerman> the install from those binaries are going to be very fast
12:06:12 <Cale> myki: sure
12:06:15 <jgerman> is*
12:06:19 <opqdonut> ?pl f n = reverse (unfoldr (\n -> if  n>0 then Just(intToDigit(mod n 10), div n 10) else Nothing) (fromEnum(n)))
12:06:19 <lambdabot> f = reverse . unfoldr (flip (liftM2 if' (> 0) (Just . ap ((,) . intToDigit . flip mod 10) (flip div 10))) Nothing) . fromEnum
12:06:24 <opqdonut> myki: that's one way
12:06:28 <Cale> myki: It's actually f (g x) = (f . g) x
12:06:31 <opqdonut> automated and ugly
12:06:39 <jgerman> kalmar: this is for a CS class of some sort right?
12:06:53 <kalmar> jgerman: yeah
12:06:53 <myki> Cale: ohh, ok. Thank you
12:07:25 <Cale> myki: That is, the function (f . g) is the function which applies g and then f to its argument.
12:08:21 <Cale> In Haskell, we usually don't put the argument to a function in parens unless it otherwise needs the grouping.
12:08:28 <jleedev> ?src (.)
12:08:29 <lambdabot> (.) f g x = f (g x)
12:08:47 <Cale> I should fix that src :)
12:08:54 <Cale> Would be nicer if it read:
12:08:57 <jgerman> kalmar: I'm not sure why the binaries need the devtools but it shouldn't be a stretch to ask CS students to install them regardless, they're useful for more than just Haskell :)
12:08:59 <Cale> (f . g) x = f (g x)
12:09:05 <Cale> (which is still valid Haskell)
12:09:51 <jleedev> That would be nice
12:10:11 <Cale> Now, if I could just ssh into code.h.o
12:10:20 <shapr> Why can't you?
12:10:32 <jleedev> ?src (>=>)
12:10:32 <lambdabot> Source not found. Maybe if you used more than just two fingers...
12:10:40 <jleedev> ?src (>>>)
12:10:40 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
12:10:46 <SamB> you need gcc and so on to LINK, too...
12:10:50 <Cale> @src (.)
12:10:50 <lambdabot> (.) f g x = f (g x)
12:10:53 <Cale> hmm
12:11:01 <Cale> maybe it loads the file on startup
12:11:10 <kalmar> jgerman: very true
12:11:21 <Cale> @src (.)
12:11:24 <shapr> Any thoughts on moving hpaste to code.h.o ?
12:11:27 <lambdabot> (f . g) x = f (g x)
12:11:33 <jleedev> cute
12:11:40 <shapr> glguy: Thoughts on moving hpaste to code.h.o ?
12:11:45 <shapr> @seen sorear
12:11:47 <oerjan> @src Arrow
12:11:49 <lambdabot> I saw sorear leaving #xmonad, #haskell-blah, #haskell and #ghc 12h 38m 39s ago, and .
12:11:55 <Cale> code.h.o has serious lag issues as it is.
12:11:55 <lambdabot> class Arrow a where
12:12:01 <kalmar> I just find the steps required to get GHC going on OS X sort of ironically complicated when compared with windows
12:12:01 <lambdabot>     arr, pure   :: (b -> c) -> a b c
12:12:07 <lambdabot> Plugin `source' failed with: thread killed
12:12:10 <shapr> Cale: from lambdabot? or what?
12:12:16 <oerjan> @src Arrow
12:12:21 <lambdabot> class Arrow a where
12:12:23 <Cale> shapr: I have no idea. lambdabot is randomly slow
12:12:26 <shapr> Hm
12:12:27 <lambdabot>     arr, pure   :: (b -> c) -> a b c
12:12:36 <lambdabot> Plugin `source' failed with: thread killed
12:12:39 <oerjan> good grief
12:12:42 <SamB> kalmar: you would like for it to bundle the GNU toolchain?
12:12:44 <shapr> I could get a static ip at home and run hpaste and lambdabot from there.
12:12:50 <Cale> shapr: and sometimes ssh'ing is annoyingly slow as well, but I can't see what's running that would be causing it
12:13:10 <shapr> And bunches of other stuff.. I can throw lots of hardware at my home server.
12:13:19 <kalmar> SamB: no of course not!
12:13:34 <SamB> kalmar: that's why it is so simple to install on windows ;-P
12:13:40 <jgerman> :)
12:13:51 <SamB> it bundles the GNU toolchain
12:13:53 <Cale> http://www.haskell.org/ghc/download_ghc_682.html#macosxppc -- what's wrong with these packages?
12:13:53 <lambdabot> Title: GHC: Download version 6.8.2
12:14:18 <kalmar> installing dev tools isn't a problem... just needing people to know their arch and OS version, and needing different binaries for each combination
12:14:26 <jgerman> Cale: nothing, he's just looking for a way with less steps
12:14:32 <SamB> kalmar: oh.
12:14:33 <shapr> Cale: Is code.h.o a virtual server?
12:14:51 <Cale> shapr: I don't know how to tell.
12:14:58 <Cale> shapr: But it would make sense if it were.
12:15:04 <SamB> well, it would be rather hard to get GHC to work biplatform...
12:15:20 <jgerman> kalmar: look at it this way, you're teaching them a valuable lesson, which will make the rest of our lives easier when they enter the work force :)
12:15:41 <kalmar> yeah I'll just link them generally "there"
12:15:45 <SamB> "PowerPC and i386 are actually not the same architecture"
12:16:02 <Cale> heh
12:16:25 <SamB> and I hope they can tell what OS they are on!
12:16:43 <jgerman> if they can't consider it a weed out process :p
12:16:43 <xerox> Cale: cat /proc/cpuinfo
12:16:54 <Cale> I have a Mac Ossix, ten and four tenths.
12:17:04 <xerox> Cale: if it says "model name: UML" :-)
12:17:26 <Cale> xerox: Looks like two Xeons
12:17:30 <kalmar> maybe I'm not giving them enough credit
12:17:30 <kalmar> ha
12:18:10 <Cale> kalmar: heh, "It's got four times two and a half. That's ten, right?"
12:18:13 <xerox> Cale: another trick is lloking at mac addresses in ifconfig -a
12:18:50 <xerox> If it starts with 00-05-69- or 00-0C-29- or 00-50-56- good chances are that the os lives inside vmware
12:18:56 <Cale> Link encap:UNSPEC  HWaddr 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00
12:19:15 <jleedev> Good chance the os lives inside The Matrix
12:19:56 <Cheery> does haskell have something I can use to put destructor hooks into my data?
12:20:14 <Cale> Cheery: There's ForeignPtrs
12:20:26 <tmpOO> Hello all. Is there a Haskell intepreter for Windows Mobile (pocket pc)?
12:20:48 <Cale> tmpOO: I don't know. You could try to compile hugs.
12:21:02 <Cheery> in other hand, that may not be a good idea
12:21:21 <Cale> Cheery: What exactly are you trying to accomplish?
12:21:47 <Cale> Cheery: Usually that problem stems from using some foreign library which needs some explicit deallocation thing to get called.
12:22:16 <Cheery> exactly so, but I already have the Xlib, I want to abstract stuff further
12:22:17 <Cale> Cheery: In which case the solution is usually provided by ForeignPte and addForeignPtrFinalizer
12:22:39 <Cale> hmm
12:22:55 <Cale> Cheery: You're designing some GUI library directly on top of Xlib?
12:23:07 <Cheery> thought about it
12:23:25 <gbacon> with ghc --make, how do I tell it to link against the objects in dist/build?
12:24:03 <Cale> gbacon: hmm, that setup usually indicates that you're using cabal to build...
12:24:17 <Cale> gbacon: But you could probably just pass the objects on the commandline directly.
12:24:25 <SamB> gbacon: why are you not using cabal to build?
12:24:34 <gbacon> Cale: granted, but Pugs.cabal for some reason doesn't have an Executable section
12:24:50 <gbacon> is this a case of "Hey, Doc, it hurts when I do my arm like this"?
12:24:55 <SamB> oh, just pass the files then
12:25:03 <SamB> and see if that works
12:25:04 <dino-> SamB: Is there a newer cabal way to run a project's unit tests without a runTests custom hook?
12:25:11 <SamB> dino-: oh, I dunno
12:25:24 <SamB> I never tried that...
12:25:27 <gbacon> ghc --make Main.hs $(find dist -name '*.o') or the moral equivalent?
12:25:44 <dino-> SamB: This is what my custom hook is in pretty much everything I've done, for Setup.lhs test
12:25:47 <SamB> but I do know that cabal hooks have had the API changed at least once...
12:26:04 <SamB> what was the problem again?
12:26:07 <dino-> SamB: I ask because you guys were "Dude, don't use hooks!"
12:26:21 * shapr hooks the spiky dino- saur.
12:26:53 <SamB> dino-: well, I don't think anyone said it after you mentioned that it was for testing
12:27:13 <shapr> I only know the recent #haskell and Planet Haskell testing discussion by ndm and dcoutts
12:27:32 <dino-> SamB: ok, I was wondering if there was something newer going on like making this configurable in the .cabal or with a specific script name in a specific loc.
12:28:40 <dcoutts_> dino-: currently there is no other way, but on the other hand the existing cabal test stuff is next to useless
12:29:03 <dcoutts_> dino-: the only advantage is that runghc Setup test works, there is no other advantage
12:29:03 <dino-> dcoutts_: I understand. But I do like the unified interface of being able to do Setup.lhs test
12:29:13 <dcoutts_> tests are not otherwise used or integrated
12:29:25 <dcoutts_> and there's no reporting of results etc
12:29:55 <dino-> I understand. In the case of one project, I get output from HUnit itself.
12:30:03 <dino-> Thanks guys
12:30:12 <SamB> yes, the darcs test stuff is actually GOOD for something...
12:30:41 <dcoutts_> dino-: http://hackage.haskell.org/trac/hackage/ticket/215
12:30:43 <lambdabot> Title: #215 (Overhaul support for package's tests) - Hackage - Trac
12:30:58 <dcoutts_> SamB: because it blocks records you mean
12:31:18 <dino-> ah. I did notice that some projects just have something like runTests.sh in their proj root.
12:31:20 <SamB> dcoutts: well, more because it runs when you do a record
12:31:37 <dino-> To be run by the developer directly. Which is basically what my tiny hook does anyway.
12:31:55 <dino-> Mainly I'm just trying to do things The Right Way
12:32:14 <SamB> dino-: yeah, until we have a one-stop-shop like dpkg-buildpackage...
12:32:19 <SamB> it isn't exactly useful
12:37:52 <myki> Is it possible to define function like f' (f x y) = Just (a,b)?
12:38:26 <Zao> Where'd a and b come from?
12:38:34 <oerjan> no, what should it mean anyhow?
12:39:03 <myki> In http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html#v%3Afoldr there's example, where unfoldr f' (foldr f z xs) = xs, just when f' z = Nothing, f' (f x y) = Just (x,y).
12:39:04 <lambdabot> http://tinyurl.com/wfo7q
12:40:16 <Riastradh> That's not a definition, myki; that is a theorem.
12:40:28 <myki> sorry, wrong anchor in link. It's under 'unfoldr'
12:41:20 <emmanuel_> hello? can i ask a beginners' haskell question?
12:41:26 <cjb> emmanuel_: Sure.
12:41:34 <SamB> emmanuel_: what do you think we are here for?
12:41:42 <emmanuel_> thanks. i'm having problem combining monads
12:41:50 <emmanuel_> from the Parsec monad i'd like to call the IO monad
12:41:52 <emmanuel_> here's my code:
12:41:53 <Riastradh> We're here for scaring novices away by inundating them with talk about category theory.
12:41:55 <emmanuel_> http://www.chez.com/powerpeanuts/parsec-test.hs
12:42:06 <myki> Riastradh: so there's any example of f, f' for which it works?
12:42:08 <emmanuel_> thanks for the enthusiasm :-)
12:42:17 <emmanuel_> in my code
12:42:22 <emmanuel_> i'd like to do a putStrLn
12:42:26 <emmanuel_> but somehow it doesn't get run
12:42:34 <wli> myki: A certain diagram has to commute. ;)
12:42:43 <SamB> hmm.
12:42:51 <Riastradh> emmanuel_, you need to reflect the fact that your parser performs I/O in its description and type.
12:43:07 <jleedev> > unfoldr (\x -> if x == 0 then Nothing else Just (1,x-1)) $ foldr (+) 0 (replicate 5 1)
12:43:08 <lambdabot>  [1,1,1,1,1]
12:43:21 * SamB must read the latest Parsec's documentation
12:43:26 <oerjan> emmanuel_: that is awkward, because Parsec is pure.  There is a new version that fixes the problem by being usable as a transformer
12:43:43 <oerjan> (or so i think)
12:43:57 <pjd> emmanuel_: for debugging, you could use trace
12:44:09 <emmanuel_> so it's possible that from a monad, you can't call any other monad?
12:44:37 <oerjan> yep
12:44:53 <oerjan> and anything involving IO is particularly hard to call
12:44:53 <pjd> :t trace
12:44:58 <lambdabot> Not in scope: `trace'
12:45:03 <pjd> :t Debug.Trace.trace
12:45:04 <lambdabot> forall a. String -> a -> a
12:45:08 <emmanuel_> how come the compiler lets me compile this then? it's a bit funny...
12:45:12 <SamB> Lemmih: your "safecopy" package needs better haddocks
12:45:20 <emmanuel_> and then it just doesn't run the IO stuff
12:45:38 <SamB> Lemmih: just look at this! http://hackage.haskell.org/packages/archive/safecopy/0.3/doc/html/Data-SafeCopy.html
12:45:39 <lambdabot> http://tinyurl.com/2c52q8
12:45:43 <pjd> emmanuel_: trace prints out the given string, and returns its second argument
12:46:09 <Lemmih> SamB: You know where to send patches.
12:46:11 <pjd> emmanuel_: you can temporarily shove it pretty much anywhere
12:46:18 <oerjan> emmanuel_: it is completely legal to _construct_ values of one monad inside another.  they just may not be runnable there
12:47:01 <mrd> pjd: I read that statement out of context at first
12:47:04 <SamB> Lemmih: I do not know where to check it out from
12:47:06 <emmanuel_> oerjan: i would still expect some sort of runtime exception. but i'm so far from understanding it all..
12:47:08 <oerjan> that's what return (putStrLn command) does
12:47:16 <mrd> sounded mean :)
12:47:31 <SamB> though I suppose I can guess
12:47:36 <emmanuel_> about trace
12:47:39 <oerjan> emmanuel_: a return ... statement anywhere in a do other than the end will be ignored
12:47:56 <emmanuel_> oh... oerjan thanks very much about the return not at then
12:47:59 <emmanuel_> the end
12:48:02 <oerjan> because it does nothing other than construct a value, which is then thrown away
12:48:04 <emmanuel_> helps a lot
12:48:17 <emmanuel_> about trace, how to put it in my code exactly?
12:48:25 <emmanuel_> trace command needs a second argument
12:48:30 <emmanuel_> what should I put there?
12:48:42 <SamB> emmanuel_: an expression you will be needing the value of
12:48:44 <emmanuel_> if i put "trace command []" it doesn't build
12:48:55 <oerjan> emmanuel_: you can put it on the last statement of the do
12:49:05 <Lemmih> SamB: Are you using SafeCopy, ooi? It has been integrated with HAppS so it may be deprecated.
12:49:07 <SamB> you could also just stick (return ()) there
12:49:21 <oerjan> trace "whatever" (return [[level], command])
12:49:33 <emmanuel_> ah.. that works
12:49:46 <SamB> Lemmih: I wasn't. but it sounded like an interesting concept, so I went to read the haddocks...
12:50:08 <emmanuel_> i wanted some generic solution to call trace, so i prefer the return () because sometimes when i want to do the trace, i won't have all the values for the final return
12:50:16 <Lemmih> SamB: The repo is: darcs.haskell.org/~lemmih/safecopy
12:50:21 <pjd> emmanuel_: basically, wherever you have a valid expression (x), you can say (trace "foo" x)
12:51:06 <emmanuel_> thanks for the help
12:51:12 <emmanuel_> you have unblocked me...
12:51:15 <pjd> emmanuel_: trace is an example of using unsafePerformIO, by the way
12:51:21 <emmanuel_> though i'm still as confused as before ;-)
12:51:51 <emmanuel_> pjd thanks for the info. i'll do some reading on UnsafePerformIO
12:52:02 <pjd> emmanuel_: just don't use it in real code :)
12:52:10 <oerjan> emmanuel_: actually maybe best not to ;)
12:52:14 <emmanuel_> well, not when it's "stable" right?
12:52:24 <emmanuel_> i'm just a dumb imperative programer
12:52:31 <emmanuel_> already no debugger is tough
12:52:35 <SamB> and when you use unsafePerformIO, you are required to prove that you don't care about certain things
12:52:36 <emmanuel_> but now, no debug statements...
12:52:39 <emmanuel_> it's pushing it
12:52:46 <oerjan> latest ghci has a debugger
12:52:55 <Lemmih> SamB: The types tell most of the story.
12:52:59 <emmanuel_> i'll check it out
12:53:03 <emmanuel_> well for the parsing stuff
12:53:13 <emmanuel_> parsec tells me parse error (ok with a lot of info)
12:53:21 <RayNbow> @pl \f xs -> concat $ map f xs
12:53:22 <lambdabot> (=<<)
12:53:24 <emmanuel_> but i need to see the sequence of stuff which was parsed to "get it"
12:53:28 <RayNbow> that's not what I wanted...
12:53:35 <emmanuel_> especially as it's my first haskell program and so on
12:53:47 <SamB> Lemmih: well, the types never told that GHC had a tendancy to leave off in the middle of an unsafePerformIO if another thread had computed the value of the thunk...
12:54:19 <emmanuel_> thanks for the tip about the debugger, will check it out too
12:54:37 <gnuvince> > toUpper =<< ["hello","world"]
12:54:38 <SamB> oh, wait, you meant about safecopy
12:54:38 <lambdabot>  Couldn't match expected type `m b' against inferred type `Char'
12:54:38 <pjd> RayNbow: it's the answer to what you asked...
12:54:40 <emmanuel_> maybe one more question
12:54:40 <SamB> heh
12:54:47 <emmanuel_> how do i know.. for one monad
12:54:50 <emmanuel_> if i call do IO from it
12:54:55 <emmanuel_> so, from parsec, i can't
12:55:04 <SamB> @instances MonadIO
12:55:05 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
12:55:13 <oerjan> > map toUpper =<< ["hello","world"]
12:55:17 <lambdabot>  "HELLOWORLD"
12:55:21 <emmanuel_> ok
12:55:24 <SamB> emmanuel_: there is a class MonadIO
12:55:25 <Lemmih> SamB: I was indeed.
12:55:33 <emmanuel_> so no MonadIO => no IO from that monad. thanks...
12:55:52 <SamB> note that not all of its instances have been listed here...
12:56:27 <oerjan> emmanuel_: that list is deceptive, most of those are monad transformers so they need a type argument with IO inside
12:56:28 <SamB> only the ones that lambdabot's boilerplate file imports...
12:56:41 <SamB> that too ;-)
12:56:41 <emmanuel_> and so...
12:56:55 <emmanuel_> IF parsed instanced MonadIO...
12:57:11 <emmanuel_> would the (liftM putStrLn) (return command) code be correct?
12:57:16 <emmanuel_> or how should i do it?
12:57:18 <oerjan> essentially you can only do IO in a monad if it is built around IO
12:57:26 <SamB> @type liftIO
12:57:29 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
12:57:30 <emmanuel_> i have used liftIO in monads offering it, but i understand not all do
12:57:33 <oerjan> emmanuel_: liftIO (putStrLn command)
12:57:42 <emmanuel_> ah...
12:57:47 <SamB> MonadIO is the class that liftIO is a member of
12:57:49 <emmanuel_> if there is no liftIO, then i can't do IO
12:57:52 <emmanuel_> ok
12:58:02 <emmanuel_> i used liftIO from another monad (cairo drawing)
12:58:07 <emmanuel_> for parsec, i saw it's not there
12:58:11 <SamB> It would be possible for someone to have forgotten to write the MonadIO instance...
12:58:13 <emmanuel_> i didn't realise it meant game other
12:58:14 <emmanuel_> over
12:58:40 <SamB> in which case you would need to make a fuss about that, possibly implement it and send them a patch...
12:59:04 <daveux> Hey, I'm having trouble getting an int from an expression a ** b
12:59:15 <conal> @ty (**)
12:59:20 <lambdabot> forall a. (Floating a) => a -> a -> a
12:59:27 <daveux> Hmm...
12:59:33 <conal> daveux: what types are a & b?
12:59:38 <conal> @ty (^)
12:59:39 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
12:59:41 <daveux> int, int
12:59:44 <conal> @ty (^^)
12:59:45 <emmanuel_> ok, thank you all. i'll go back to my learning now... you've helped a lot (in fact, i would have given up without you)
12:59:45 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
13:00:00 <daveux> oh, that's python...
13:00:18 <daveux> a^b is what I want, thank you
13:00:22 <conal> :)
13:02:04 <augustss> daveux: or maybe ^^
13:02:25 <augustss> well, not for Int, Int
13:03:22 <augustss> Haskell should have another exponentiation operator.  Surely 3 cannot be enough
13:03:42 <doserj> @type exp
13:03:43 <lambdabot> forall a. (Floating a) => a -> a
13:04:32 <wli> augustss: Riemann surface -based?
13:04:56 <Deewiant> hmm, @src only exists for (^^)
13:05:49 <oerjan> ^ is a bit long
13:06:00 <oerjan> @src **
13:06:00 <lambdabot> Source not found. :(
13:06:16 <Deewiant> @src (^^)
13:06:16 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
13:06:29 <oerjan>     x ** y               = exp (log x * y)
13:06:34 <oerjan> (default)
13:08:01 <Deewiant> @src exp
13:08:01 <lambdabot> Source not found. I am sorry.
13:09:48 <jsnx> so, what is the usual way to run a shell command in haskell -- e.g.
13:09:58 <jsnx> dateString <- run "date"
13:10:04 <shapr> popen?
13:10:20 <jsnx> oic
13:10:21 <jsnx> yuck
13:10:28 <shapr> I'm not sure.
13:10:38 <shapr> I haven't called any shell commands from Haskell in a long while.
13:11:36 <ndm> system, or System.Cmd/System.Process
13:11:36 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
13:11:38 <Lemmih> jsnx: See System.Process
13:11:44 <ndm> @messages
13:11:44 <lambdabot> dcoutts_ said 3h 43m 49s ago: hugs has no notion of installed packages, what are we supposed to do?
13:12:09 <ndm> dcoutts_: something slightly better than a pattern match error
13:12:11 <jsnx> yes, i've read all those
13:12:27 <jsnx> they are all a bit of a mess if you want to capture the output though
13:12:37 <shapr> ndm: Hey, where do I learn more about running/developing Haskell on Windows?
13:12:41 <jsnx> you have to read from a handle
13:12:48 <ndm> jsnx: i tend to do system "foo > log.txt", then readFile
13:12:59 <ndm> not the right way, but very easy
13:13:15 <ndm> shapr: just install GHC and Gtk2Hs and WinHugs, and its exactly hte same as on Linux
13:13:26 <jsnx> dons has a post where he uses a command just like `run`
13:13:26 <SamB> ndm: oh really?
13:13:39 <shapr> Er, how do I install gtk2hs on win32?
13:13:41 <ndm> shapr: along with a text editor - I use TextPad if you don't have a Vim/Emacs preference
13:13:58 <ndm> shapr: ah, now the problem is that typically the latest version of GHC and Gtk2hs aren't compiled together
13:14:03 <jsnx> i have no idea where he got it, though:
13:14:04 <shapr> oh, version mismatch?
13:14:05 <jsnx> http://cgi.cse.unsw.edu.au/~dons/blog/2007/03
13:14:06 <lambdabot> Title: Haskell hacking
13:14:06 <ndm> shapr: solution is to insult dcoutts on the mailing list
13:14:12 <shapr> um
13:14:14 <shapr> really?
13:14:21 <SamB> I think he might be serious
13:14:23 <ndm> shapr: yep, it actually does work
13:14:32 <shapr> I dunno, he let me sleep at his place for several days....
13:14:36 <shapr> And he let me ride his unicycle.
13:14:41 <ndm> yeah, i've stayed at his as well
13:14:42 <shapr> I don't think I can insult him, sorry.
13:14:49 <ndm> embarass gently?
13:14:54 <shapr> heh, ok
13:14:56 <SamB> apparantly insulting him makes him angry enough to build it?
13:15:06 <ndm> and you can refer to the Gtk2hs developers, rather than duncan
13:15:20 <shapr> oh, any idea if Visual Haskell works at all with vs 2008 ?
13:15:30 <ndm> but essentially, Duncan is the _only_ person on the planet who seems to be capable of building gtk2hs for Windows
13:15:32 <shapr> ndm: Is there a haskell-win32 mailing list?
13:15:34 <ndm> shapr: no, it doesn't
13:15:39 <shapr> oh
13:15:42 <ndm> shapr: nope, no mailing list
13:15:46 <shapr> Is Visual Haskell written in Haskell and open source?
13:15:54 <shapr> Time for a mailing list then.
13:15:56 <ndm> shapr: VH was kind dying at the point it was released, and now its entirely dead
13:16:01 <shapr> suck
13:16:15 <shapr> I have not one, but two msdn licenses.
13:16:15 <ndm> the GHC API runs very fast, and no one was running after it
13:16:20 <shapr> And it looks like I'll be developing for win32 for several years.
13:16:21 <ndm> i have an MSDNAA
13:16:26 <shapr> what's that?
13:16:34 <ndm> MSDN Academic Aliance
13:16:37 <shapr> oh
13:16:39 <shapr> What does that do?
13:16:42 <ndm> free stuff for students/lectureurs
13:16:42 <Zao> shapr: Free academic access to assorted apps.
13:16:48 <shapr> oh neat
13:16:49 <ndm> i get everything but office and flight sim
13:16:50 <Zao> Like Windows, Visual Studio, Visio and such.
13:17:08 <Zao> Quite handy if you're a poor student and want to run real OSes.
13:17:46 <shapr> I'm a well off C# developer who misses Haskell terribly.
13:18:08 <jsnx> Zao: watch it :)
13:18:30 <Nafai> I'm getting used to "other" OS's myself
13:18:38 <jsnx> Nafai: those being?
13:18:40 <shapr> In any case, my new push is ... get Haskell working well on win32, and working well with visual studio...
13:18:41 <Nafai> My new work machine is a Mac Book Pro
13:18:42 <ndm> I quite like C#, its good for GUI's
13:18:48 <shapr> ndm: Any ideas on where to start with that?
13:18:54 <SamB> shapr: maybe you should try VB.NET
13:19:13 <ndm> shapr: good luck, Haskell on Windows is not that bad, visual studio support was poor at its best, and its no longer at its best
13:19:14 <jsnx> Nafai: so, that is your first UNIX?
13:19:29 <roconnor> @seen sigfpe
13:19:29 <lambdabot> I haven't seen sigfpe.
13:19:51 <shapr> ndm: Ok, what's needed first?
13:19:53 <jsnx> shapr: even if you get it to work, how will you get any work with it?
13:19:55 <ndm> we need a little love on cabal, and probably GuiHaskell to be finished, but thats it to make Haskell and Windows first class
13:20:04 <Nafai> jsnx: Heck no
13:20:10 <jsnx> Nafai: oic
13:20:20 <Nafai> My first Unix was HP-UX a long time ago
13:20:24 <ndm> shapr: depends what you are after - a system for developers, or for end users who want to install a haskell app
13:20:34 <Nafai> I've been primarily a Linux user for the last decade almost
13:20:39 <shapr> jsnx: Some things that I do now are quick hacks to get something done. In those cases I would be more productive with Haskell.
13:20:50 <jsnx> Nafai: well, when you say "other" OSes -- it's hard for me to know what is "other" to you :)
13:20:53 <shapr> ndm: If there's no dev-friendly system, there will be no apps :-)
13:21:06 <jsnx> shapr: i think you are wrong about that
13:21:10 <Nafai> jsnx: True :)
13:21:24 <ndm> shapr: do you consider windows devs to require a GUI for some things, or do you consider them to be 100% console literate
13:21:26 <shapr> jsnx: How so?
13:21:35 <glguy> shapr: the hpastetwo release will start on code
13:21:37 <jsnx> shapr: if by dev-friendly you mean GUI
13:21:44 <shapr> ndm: I don't know.
13:21:59 <SamB> ndm: windows devs are forced to use a GUI sometimes, aren't they?
13:22:04 <jsnx> shapr: plenty of good stuff comes out of VIM and EMACS every year
13:22:04 <ndm> shapr: neither do i, i suspect we need a GUI for some stuff - therefore we need something like GuiHaskell
13:22:11 <ndm> SamB: no, we can use the console all day long
13:22:27 <SamB> how?
13:22:36 <ndm> most windows devs would probably want the option of doing certain things via the GUI, which we currently can't
13:22:41 <jsnx> SamB: virutalization
13:22:55 <oerjan> @remember ndm [on bitrotting packages] the GHC API runs very fast, and no one was running after it
13:22:55 <SamB> jsnx: wrong answer
13:22:55 <lambdabot> Good to know.
13:22:56 <ndm> SamB: you just fire up a console, i have 4 open at hte moment - the console is a GUI window, but you can use it normally
13:23:11 <jsnx> SamB: teasing
13:23:12 <SamB> ndm: well, I meant, aren't there things you just can't do that way?
13:23:29 <ndm> SamB: a couple of server admin style things, but for development, no
13:23:42 <shapr> jsnx: I think I mean that I want a system that will encourage Haskell-literate programmers who need a windows app to consider Haskell.
13:23:55 <jsnx> shapr: oic
13:24:10 <jsnx> shapr: well, the thing is, only big expensive languages can have nice IDEs
13:24:12 <ndm> shapr: in that case Haskell needs a more regular Gtk2hs release schedule, i.e. the second GHC is released
13:24:45 <ndm> shapr: and Gtk2hs needs to be more windows friendly, by producing complete installers, building with cabal, having more native windows themes - all of which are in progress
13:24:47 <jsnx> if you're going off the beaten path, there won't be take-out nearby necessarily
13:25:00 <SamB> ndm: how about "after it finishes compiling" instead?
13:26:01 <ndm> SamB: a day later is ok, but we're now months later and can't use gtk2hs on the stable version - which is very sad
13:26:02 <SamB> jsnx: I don't think I would eat at a take-out place that was literally off the beaten path...
13:26:16 <jsnx> SamB: aye
13:26:16 <SamB> ndm: yes
13:26:18 <SamB> that is sad
13:26:19 <shapr> ndm: I think that's a good list of things to improve.
13:26:36 <jsnx> SamB: i feel the same way about IDEs for ruby, python, &.c
13:26:40 <SamB> definately it is reasonable to expect a matching gtk2hs release within a week
13:26:55 <ndm> shapr: in summary, i think if the effort went into gtk2hs with a windows bias, rather than windows itself, you'd get more milage
13:27:06 <ndm> if you managed to compile gtk2hs on windows that would be a start
13:27:21 <shapr> ndm: Sounds good
13:27:40 <shapr> ndm: Does anyone else do real Haskell dev on windows other than you?
13:27:47 <jsnx> i have to develope windows apps
13:27:53 <jsnx> but i do the work on linux
13:27:58 <ndm> shapr: Esa, Bulat - thats it
13:28:12 <jsnx> and then compile on a windows instance on a mac
13:28:13 <SamB> jsnx: I've seen that before...
13:28:15 <shapr> Ah
13:28:16 <ndm> one of the problems is that haskell developers on windows are often ridiculed on the mailing list
13:28:20 <SamB> well, not the ast part...
13:28:20 <shapr> esa == esap?
13:28:21 <ndm> and in IRC
13:28:31 <shapr> ndm: I shall do my best to change that.
13:28:33 <dons> ndm, ridiculed? often?
13:28:39 <jsnx> shapr: how?
13:28:39 <SamB> ndm: who ridicules them?
13:28:39 <shapr> I don't think anyone should be ridiculed, ever.
13:28:43 <SamB> was it me?
13:28:49 <ndm> nope, esa, maintainer of Win32 - who now no longer goes on IRC because of windows unfriendlyness
13:28:56 <shapr> jsnx: How change ridicule?
13:29:00 <shapr> :-(
13:29:01 <jsnx> shapr: yeah?
13:29:07 <dons> he doesn't go on irc because of unfriendliness? really?
13:29:08 <ndm> dons: it happens, people refer to it as an inferior OS
13:29:17 <ndm> dons: he left #haskell because of it, a while back
13:29:25 <SamB> jsnx: social pressure
13:29:27 <jsnx> ndm: that's not the same thing as attacking the person
13:29:29 <shapr> jsnx: I will start a haskell-win32 mailing list, and a #haskell-win32 irc channel.
13:29:40 <jsnx> shapr: oic
13:29:44 <SamB> hmm.
13:29:48 <jsnx> that really won't help you much
13:29:55 <ndm> jsnx: yeah, i don't quite mean "ridicule" i guess, but just a general attitude of inferiority because of an OS
13:29:56 <shapr> jsnx: Yeah, that's what people said when I started #haskell
13:29:58 * byorgey is probably guilty of such ridiculing =(
13:29:59 <jsnx> because we'll just ridicule you over here
13:30:02 <dons> a win32 community seems like a good idea
13:30:06 * byorgey will stop now
13:30:07 <dons> we have similar things for gentoo et al
13:30:35 <dons> pretty much every other distro has a todo list, and a group of people who work on packaging issues
13:30:39 <jsnx> dons: but the #gentoo channel has nothing to do with addressing ridicule in the linux community
13:30:40 <SamB> honestly, I don't see why we don't ridicule the gentoo people more than the windows people...
13:30:41 <dons> so win32 should have one
13:30:51 <dons> jsnx: it addresses improving support for that distro
13:30:53 <ndm> yeah, personally i don't care at all about the jokes, but some developers do
13:30:55 <dons> which we need for win32 too
13:30:55 <shapr> Yeah, the only specialization on #haskell should be just that, Haskell. Not win32, linux, HURD, or whatever.
13:30:58 <jsnx> dons: yes
13:31:11 <SamB> HURD?
13:31:14 <SamB> we have a user on HURD?
13:31:17 <jsnx> win32 specialization makes some sense
13:31:18 <ndm> and its also a bit weird that the best Win32 developer we have, by a mile, is Duncan, who doesn't even use it
13:31:18 * shapr grins
13:31:28 <yowgi> as a HURD user I take offense at your mockery
13:31:38 <SamB> yowgi: I wasn't attempting mockery
13:31:42 <yowgi> ;)
13:31:44 * shapr hugs yowgi
13:31:49 <jsnx> but i would be really concerned to see .NET bindings, visual studio plugins, &c.
13:31:51 <SamB> I merely implied that a real HURD user is something you don't see very often
13:32:02 <jsnx> because basically, no one else can use that stuff
13:32:03 <shapr> jsnx: I shall flagrantly hug anyone who ridicules those on #haskell
13:32:08 <SamB> is there anything nice about HURD?
13:32:22 <jsnx> it would amount to a sort of piracy
13:32:22 <shapr> Because ridiculing someone else obviously means the ridiculer is unhappy.
13:32:25 <dibblego> ?check \x -> id x == x -- why isn't lambdabot asking me to add a type signature here?
13:32:26 <lambdabot>  OK, passed 500 tests.
13:32:38 <shapr> Anyway, gotta go home and hack on C# furiously, bbl
13:32:43 <jsnx> shapr: or we simply want to push them in the right direction
13:32:43 <SamB> jsnx: yes, but I'd have trouble using emacs on windows...
13:32:54 <jsnx> SamB: there are good ports, actually
13:32:54 <kpreid> dibblego: enthusiastic defaulting?
13:32:56 <shapr> ndm: Thanks for the discussion, I'll be back for more :-)
13:32:58 <radix> shapr!
13:33:01 <jsnx> SamB: same with vim
13:33:03 <radix> crap. he's going home.
13:33:06 <SamB> jsnx: where do you find good ports?
13:33:06 <radix> shapr: don't leave yet
13:33:10 <radix> d'oh
13:33:22 <jsnx> SamB: i know a patent manager who does all his work in 'lemmy', a vim port, on windows
13:33:25 <dons> hmm, i didn't think QC used extended defaulting
13:33:26 <dibblego> ?check \x -> let id' a = a in id' x == x
13:33:27 <lambdabot>  OK, passed 500 tests.
13:33:34 <SamB> specifically of emacs
13:33:42 <jsnx> SamB: you probably take a day or two and look for a nice one
13:33:47 <jsnx> instead of taking a week to write one
13:33:53 <jsnx> i don't use emacs
13:33:59 <dibblego> kpreid, odd
13:34:13 * jsnx stops himself from ridiculing emacs users
13:34:22 <SamB> jsnx: why?
13:34:24 <SamB> we are used to it!
13:34:26 <ndm> i actually have a half written blog post somewhere on haskell on windows
13:34:27 * jsnx reminds himself that we are all one big family
13:34:46 <SamB> we even tend to do it ourselves sometimes, I think
13:34:55 <dons> i've no idea why there hasn't been a win32 community form.
13:34:55 <jsnx> we text  editor users have to stick together
13:35:16 <dons> we have all these other distro groups, with web pages and so on
13:35:24 <Igloo> dons: For Haskell?
13:35:25 <jsnx> dons: you have a good point
13:35:32 <jsnx> we have #gentoo-haskell
13:35:33 <povman_> jsnx: i use vital! as such, i am offended
13:35:42 <SamB> povman: eh?
13:35:43 <SamB> what's that?
13:35:46 <Igloo> dons: If so, is Haskell unusual in that respect?
13:35:59 <jsnx> Igloo: it is unusual
13:36:04 <jsnx> we don't have #gentoo-c
13:36:08 <jsnx> #gentoo-ruby
13:36:11 <povman_> SamB: http://www.cs.kent.ac.uk/projects/vital/
13:36:12 <lambdabot> Title: Vital homepage
13:36:14 <dons> Igloo: i don't think so, i think it might be something about people not feeling very passionate about win32 ?
13:36:27 <dons> there's something social going on.
13:36:55 <lament> win32 is not the in thing.
13:36:56 <Igloo> dons: I think it's because it's harder to get to an OS development environment with Windows, and it feels a bit bolted-on once you get there
13:37:00 <povman_> [ #a-b | a <- oss, b <- projects]
13:37:04 <SamB> dons: you are saying that windows users are antisocial?
13:37:15 <Philippa> also, there's not a big culture of packaging stuff for windows
13:37:18 <jsnx> there are so many windows users
13:37:19 <Philippa> or even a package manager to deal with
13:37:26 <jsnx> it's harder to get them all to come together
13:37:31 <dons> SamB: no.
13:37:33 <jsnx> Philippa: you develop on windows, right?
13:37:51 <Igloo> Philippa: Sure there is - most Windows users don't compile anything, so everything is packaged up as an MSI or similar
13:38:09 <jsnx> so, there's ndm, Philippa, shapr
13:38:14 <ndm> Igloo: part of it is the extensive use of mingw and cygwin - since it is effectively installing linux and then working under than, rather than actually using windows
13:38:29 <SamB> Philippa: yeah, that irritates me...
13:38:40 <ndm> Igloo: cabal-install is nearly at the point where the problem of compiling/installing is about one GUI away from being solved
13:38:40 <Igloo> ndm: Exactly. And it's also slower than using the native OS.
13:38:45 <SamB> Igloo: MSI doesn't have a depends: field
13:39:11 <jsnx> Igloo: it may use more CPU cycles, but it can help a lot with developer time
13:39:21 <Philippa> Igloo: but that's not something win32 users do, it's something the developers do. Speaking generally, not about GHC
13:39:23 <ndm> that GUI would have to be integrated into a tool like GuiHaskell or WinHugs, to be effective
13:39:29 <SamB> Igloo: you need one of those to count as a package manager
13:39:29 <Igloo> jsnx: What can help with developer time?
13:39:46 <jsnx> Igloo: bash, sed, awk, diff, the list goes on
13:39:55 <Igloo> Philippa: I'm not sure I understand
13:40:14 <jsnx> Igloo: i've never seen a sensible way to get those outside of just doing it all at once with cygwin
13:40:17 <Philippa> ndm: I disagree - something that works a bit like synaptic would do
13:40:30 <jsnx> ndm: Philippa has a good point
13:40:32 <Philippa> Igloo: it's not a part of windows culture the way it's a part of, say, debian culture
13:40:40 <SamB> cabalitude would be neat
13:40:40 <jsnx> no need to compile anything for windows
13:40:56 <Igloo> jsnx: Oh, sure, I mean that those tools are slower on Windows than unices on the same hardware
13:41:03 <jsnx> just compile them all at the factory and ship packages
13:41:08 <ndm> Philippa: you need that, and then you need to make it accessible to users - ideally a button click away, and you need somewhere to put that button
13:41:09 <jsnx> Igloo: yes, you are right
13:41:09 <Philippa> Igloo: windows users generally expect that the "windows packager" is the developer
13:41:28 <Philippa> ndm: sure, but for most people that's either a tweak to their editor or the start menu
13:41:31 <gwern> yowgi: do you really use hurd? how well does it work?
13:41:35 <jsnx> ndm: developers could deal with a command line hpm
13:41:38 <roconnor> @src IO
13:41:38 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
13:41:43 <Igloo> Philippa: But that's only because Windows users don't have a development environment, and so don't compile things themselves
13:41:56 <roconnor> @src State#
13:41:56 <lambdabot> Source not found. My brain just exploded
13:42:03 <Igloo> Philippa: A developer wouldn't bother to write something for Windows if he wasn't going to package it, because no-one would use it
13:42:05 <roconnor> what is State#?
13:42:06 <Philippa> Igloo: no, it's generally true even amongst C++ coders on windows
13:42:08 <yowgi> gwern, no :) I would have written GNU/HURD if I was a user. That's how you spot them.
13:42:14 <jsnx> it's because windows has so many more "plain users" than any other platform
13:42:15 <ndm> we need to be able to generate windows installers for binaries, but no need for libraries
13:42:22 <Igloo> (excuse my sweeping generalisations)
13:42:32 <Philippa> there's a degree of disconnect between what's normal for windows-targetted libs and ones that originated elsewhere because of that
13:42:33 <jsnx> you have to be a bit of a developer to even use gentoo, for example
13:42:40 <SamB> yeah, some people can actually install a runtime environment first and then the program
13:42:42 <gwern> yowgi: I think the hardcore ones would simply say they use GNU, or the GNU OS - as itd be the GNU userland and a GNU kernel
13:43:41 <Igloo> Also, for a lot of Open Source software, the software was originally written for a UNIX platform, and the Windows "developer" is really just a packager, but one who needs to do porting work to make it build in the first place
13:43:43 <jsnx> so, what we do, is we take everything in cabal and build it for win32
13:43:49 <Philippa> ndm: yeah, although really installers for end-users aren't that huge a problem because if you're in that market you use one of the big tools for it anyway
13:43:55 <yowgi> but I do like the logo. I almost draw it every time I write in Erlang
13:44:11 <Philippa> Igloo: yes, and from a windows POV you can tell libs that's happened with
13:44:12 <ndm> Philippa: its still too hard to do, and Duncan has 90% of a solution to it
13:44:37 <Philippa> ndm: that's cool. I'm just pointing out that for commercial devs "too hard" is... well, look at the crap they put up with already
13:44:37 <SamB> Igloo: that is more than just a packager, I think
13:44:39 <brandon> i'm getting a stack overflow exception, i think i must have a non-terminating recursive function, is there a way to see a stack trace or something similar to help me find it?
13:44:46 <brandon> oh, and uh, hi :)
13:44:48 <SamB> *nix porters generally don't have much work to do
13:45:08 <Philippa> SamB: agreed, I tend to get pretty pissed off with the amount of "oh, I don't give a shit about portability to windows"
13:45:14 <SamB> now, sometimes they add significant value through configuration stuff...
13:45:27 <SamB> Philippa: even if people GIVE a shit
13:45:35 <Philippa> it actively stops us from participating, and some of us do have reasons for our OS choice
13:45:49 <jsnx> aye
13:45:51 <SamB> it can be a lot of work to go from having someone give a shit to actually getting the program to work right
13:45:58 <Philippa> *nod*
13:46:09 <jsnx> ultimately, we want windows users to be able to use the same haskell as the rest of us
13:46:11 <mrd> on the other hand, they may not want to spend the time, which can be quite significant
13:46:28 <SamB> because for some reason programs are rarely written in such a manner as to be trivially easy to port unless they don't actually need porting...
13:46:32 <ndm> brandon: you can run a profilling run, and see where 99% of the time goes, and assume that is where the non-termination is
13:46:33 <jsnx> it would be bad if there were a fork of some kind
13:46:41 <Philippa> mrd: yeah. While, of course, ranting about portability</bitter>
13:47:13 <brandon> ndm: thanks
13:47:24 <jsnx> what i'd be willing to get behind -- because i have to do it for work -- is better cross platform lib support
13:47:29 <brandon> i didn't know there was a profiler, time to read the man page i guess
13:47:42 <mrd> after spending much time working on web apps under FireFox and IE, I must say, Microsoft products are quite infuriating to develop for
13:47:43 <jsnx> what would leave me cold is stuff like bad ass directx extensions
13:47:43 <SamB> brandon: read the ghc user guide
13:47:50 <SamB> @google GHC documentation
13:47:50 <lambdabot> http://haskell.org/ghc/documentation.html
13:47:56 <jsnx> mrd: indeed
13:47:59 <brandon> SamB: k
13:48:20 <jsnx> mrd: but it would be cool to put haskell apps on the user's desktop
13:48:46 <oerjan> @check \x -> show x == "()"
13:48:47 <lambdabot>  OK, passed 500 tests.
13:48:48 <Philippa> jsnx: yeah, I don't think a lot of people're asking for DirectX in haskell anyway though
13:48:52 <jsnx> mrd: and to do that, we ultimately need a windows machine with a lot of packages, &c. on it as a compile slace
13:48:59 <jsnx> s/slace/slave/
13:49:06 <Philippa> and frankly, when it happened it wouldn't take long before someone could be paid to maintain the bindings
13:49:10 <jsnx> setting up that environment is not fun
13:49:18 <SamB> I hope ReactOS will eventually serve as a rallying point for some kind of actual packaging for windows...
13:49:19 <jsnx> Philippa: hehe
13:49:20 <mrd> not to mention you need a place to host it
13:49:28 <Philippa> yeah. Having a box available would fix the worst of it, I suspect
13:49:32 <jsnx> SamB: i hope they, uhm, die
13:49:45 <jsnx> oops
13:49:48 <jsnx> that slipped out
13:49:49 <gwern> SamB: that would be interesting, but wouldn't it suffice for now to test under Wine?
13:49:49 <ndm> Philippa: the opengl stuff apparently works on windows, and i think is developed on windows
13:49:51 <SamB> jsnx: what have you got against reactos?
13:50:00 <SamB> gwern: eh?
13:50:04 <jsnx> SamB: let's take it to blah
13:50:18 <mrd> OpenGL should work fine on Windows
13:50:18 <Philippa> I know when I have a separate server or other machine I might theoretically be able to run a nightly build on, it sure as hell doesn't run windows
13:50:28 <gwern> SamB: I mean, if you want to test windows compatibility in a free envirnoment, why not do it right now under wine?
13:50:41 <Philippa> ndm: yeah, but mainstream PC gamedev people generally want DirectX with access to the latest
13:51:03 <SamB> gwern: I just meant as the sort of place where people who are interested in packaged windows software would tend to collect
13:51:10 <ndm> Philippa: if i was running a gamedev, i wouldn't bet on haskell yet
13:51:21 <Philippa> a windows compatible non-windows environment is /not/ an appropriate place to run our nightlies
13:51:29 <SamB> or possibly as the core of a win32 distribution
13:51:46 <Philippa> ndm: me either! OTOH, I might consider it for tooling
13:51:51 <jsnx> Philippa: it could be fine for most things
13:52:03 <Philippa> jsnx: sure. The problem is not knowing when it's the environment's fault
13:52:42 <brandon> http://haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html#tracing references lots of commands in ghci that don't seem to be available in my ghci, and says that debugging facilities are on by default, am I missing something?
13:52:43 <lambdabot> http://tinyurl.com/2zhb6v
13:53:28 <ndm> Philippa: yes, a brilliant choice for tooling
13:53:45 <jsnx> Philippa: yes, you are right
13:54:24 <Philippa> ndm: thing about that is that you may well want the same kind of hardware access for GUI purposes that your engine has
13:54:53 <Philippa> granted the /real/ answer is probably to do your rendering in C++ still, but even then you at least want to be comfortable slinging around a GUI in haskell that the C++ code can render in
13:57:01 <jsnx> Philippa: i think game devs will ignore haskell for a few more years
13:57:20 <jsnx> Philippa: and i think writing apps in haskell with direct x would amount to a big fork
13:57:24 <Philippa> jsnx: depends what you mean by 'game devs' and 'ignore', but hey
13:57:35 <Philippa> no worse than many of the other industrial uses, tbh
13:58:14 <jsnx> Philippa: i mean, bungie &c.
13:58:32 <jsnx> casual game developers won't really notice a difference between opengl and directx
13:58:34 <Eelis> i wish the authors of System.Console.GetOpt had simply wrapped C's getopt instead of rolling their own. that way it would properly support localization :(
13:59:13 <Philippa> jsnx: not the distinction I have in mind. Individual gamedevs've been poking around for a while
13:59:29 <Philippa> it's certainly not got the mindshare that lua has, of course
14:00:12 <jsnx> Philippa: like who? when you 'individual' you mean, individuals in the industry?
14:00:26 <Philippa> yeah
14:00:35 <Zao> jsnx: The primary block to use Haskell FFI with game dev is that you can't really link haskell code against VS-generated code.
14:00:46 <Philippa> I've seen a few people I knew from #flipcode around here before, for example
14:00:47 <jsnx> well, as a scripting language, haskell wouldn't need direct x, either
14:00:50 <Zao> jsnx: You kind of have to go through a gcc-based DLL, which makes it cumbersome.
14:01:24 <faxathisia> man flipcode has some amazing screenshots
14:01:24 <lambdabot> faxathisia: You have 1 new message. '/msg lambdabot @messages' to read it.
14:01:30 <faxathisia> @messages
14:01:30 <lambdabot> dolio said 1d 10h 52m 22s ago: If you have the time, I'd appreciate it if you'd confirm a bug for me. In my agda repository, I have Category.Functor. If I uncomment the functor laws, agda -I dies
14:01:31 <lambdabot> here with "the impossible happened." Type checking for the emacs mode dies similarly.
14:01:35 <gwern> I wonder if the getopt lib is under the GPL, and that's why the base rolls it own
14:02:56 <jsnx> Zao: oic
14:02:59 <jsnx> interesting
14:03:00 <faxathisia> dolio, sure, if everything compiles here.
14:03:27 <ndm> gwern: also more portable and packageable if you write it yourself
14:03:31 <Zao> jsnx: I've got some proof-of-concept code lying around at home, but it's doable at least.
14:03:44 <Zao> jsnx: I've been entertaining the idea of using Haskell for assorted parsing tasks.
14:03:57 <gwern> ndm: yeah, but if it's not as capable, then is it worth it?
14:04:09 <ndm> gwern: who knows...
14:04:16 <jsnx> anyways, bah
14:04:35 <jsnx> i will work hard to not make of windows users
14:04:39 <mrd> hmm, whenever I have something to parse, I pine for Parsec
14:04:48 <mrd> it's just too convenient
14:04:55 <jsnx> s/make of/make fun of/
14:05:12 <jsnx> furthermore, i will not disparage efforts to make things work on windows
14:05:18 <jsnx> that is my pledge to you all
14:05:39 * gwern will disparage them for you. go use a Free system! nyaa
14:05:48 <Philippa> jsnx: I wouldn't use haskell as a scripting lang for gamedev, I'm just pointing out that lua has a lot of mindshare as a non-C/C++ lang in a way that haskell is nowhere near
14:05:52 <wli> Shame. That quote about the Deep Complex Universe got cut off.
14:05:57 <jsnx> Philippa: oic
14:06:03 <Philippa> I'd be interested to know how much it has compared to ocaml these days - I'd heard of ocaml back in the day, at least
14:06:04 <jsnx> Philippa: well, it's only for scripting though
14:06:12 <jsnx> lua, that is
14:06:36 <jsnx> whereas O'Caml and Haskell have to battle C++
14:06:50 <jsnx> i think C and Haskell is a lot more fun than C++
14:07:08 <jsnx> there's no escaping C :)
14:07:10 <mrd> I wonder how Lua got its foothold.  It doesn't seem that special.  And it's far from the first to make integration as an app script language the primary goal.
14:07:24 <mrd> serendipity?
14:07:27 <jsnx> mrd: it's not scheme, and it's very lightweight
14:07:29 <Shimei> mrd: Maybe because it's lightweight?
14:07:30 <SamB> oh, what is this class Category thing ???
14:07:33 <Shimei> Ah, beat me to it.
14:07:35 <faxathisia> mrd: It's really really good
14:07:53 <lament> faxathisia: at integration, or in general?
14:08:06 <mrd> I've used it.  ISTR it has weird scoping rules.
14:08:16 <jsnx> it has first class functions, which is nice
14:08:31 <SamB> what scripting language hasn't?
14:08:36 <jsnx> ruby
14:08:38 <jsnx> perl
14:08:38 <mrd> Python
14:08:45 <jsnx> python has them
14:08:46 <SamB> python has first-class functions!
14:08:49 <mrd> very limited
14:08:50 <gwern> iirc, the interpreter is extremely small compared to most scripting languages
14:08:54 <jsnx> mrd: no
14:08:55 <lament> mrd: sorry?
14:08:56 <SamB> what do you mean?
14:09:04 <SamB> lambdas != first-class functions
14:09:05 <jsnx> mrd: what is limited are anonymous declarations
14:09:07 <mrd> oh sorry, I thought you meant lambda forms
14:09:11 <mrd> yes
14:09:20 <lament> ruby also has first-class functions
14:09:21 <mrd> what is wrong with ruby's blocks or perl's subs then?
14:09:29 <jsnx> lament: well, sort of
14:09:32 <faxathisia> lament, really nice small clean implementation in C, It's very easy to program with and connect up with an existing C program
14:09:36 <lament> in ruby people actually use filter, except they call it select.
14:09:38 <SamB> I don't know ruby so can't defend it
14:09:38 <jsnx> you can't assign a value to a function proper
14:09:45 <jsnx> in ruby and perl
14:09:56 <SamB> assign?
14:09:58 <SamB> what's that?
14:09:59 <jsnx> you have to do all this wrapping/unwrapping
14:10:07 <mrd> SamB: I heard of that once in #C
14:10:08 <faxathisia> I'd say ruby and python should die, lua and Io are far far better
14:10:15 <jsnx> like in C with function pointers
14:10:19 <mrd> jsnx: you mean mutate captured bindings?
14:10:19 <Philippa> lua's lightweight in certain ways that gamedev people and other people paranoid about performance are pretty appreciative of, too
14:10:31 <lament> faxathisia: ruby and python don't try to be extension languages. They serve a completely different purpose.
14:10:33 <jsnx> mrd: no, i do not mean mutate captured bindings
14:10:37 <mrd> hmm
14:10:50 <jsnx> i mean, `f = name_of_func`
14:10:55 <jsnx> is not valid in ruby
14:11:00 <faxathisia> lament, yeah I know that
14:11:05 <SamB> jsnx: ah, yeah... but the reason C doesn't count is because it doesn't have any way to make a nested function...
14:11:06 <Cale> I found ruby's support for first class functions a little funny. You had to call the result of lambda in a different way from calling a function defined using def.
14:11:10 <jsnx> you have to go to all this extra work to wrap it
14:11:18 <mrd> hmm
14:11:19 <Shimei> Can lua match with libraries though? I think that's what draws people to python/ruby more than anything.
14:11:20 <jsnx> Cale: right
14:11:41 <jsnx> Cale: so technically, functions are not first class -- they don't behave like other values
14:11:41 <lament> Cale: ruby is just a little funny in general.
14:11:49 <Arnfreth> Hi there, I'm trying to install the zlibs library but I get an error stating that ghc can't find the module 'Date.ByteString.Base' does anybody know what I can do to redeem this?
14:11:54 <mrd> I actually wrote about a thousand lines of Lua a couple years ago, but I can't seem to remember much about it
14:11:57 <Shimei> Side effect of making lambdas an object isn't it?
14:11:57 <lament> Cale: take smalltalk, then strip it of all sanity :)
14:11:58 <jsnx> lament: ruby is OO
14:11:59 <Shimei> (in ruby)
14:12:02 <jsnx> through and through
14:12:09 <Philippa> Shimei: lua's not about that
14:12:11 <SamB> isn't that more of a block/function difference than an actual non-first-class-function problem?
14:12:12 <mrd> Arnfreth: -package fps ?
14:12:20 <mrd> Arnfreth: how old is your GHC?
14:12:24 <SamB> jsnx: so is smalltalk
14:12:24 <Philippa> lua is /not/ a shell-replacement-type scripting lang
14:12:26 <lament> jsnx: so are smalltalk and python
14:12:32 <Philippa> at least, not for your OS shell
14:12:34 <Arnfreth> mrd, it should be 6.8
14:12:35 <jsnx> SamB: aye, well, i don't know smalltalk
14:12:46 <lament> jsnx: smalltalk is the good language inside ruby.
14:12:47 <jsnx> lament: python has weak OO
14:12:53 <Shimei> Philippa: Well, someone mentioned ruby/python should die in favor of lua.
14:12:54 <Arnfreth> mrd, 6.8.2
14:12:54 <faxathisia> hehe
14:12:55 <lament> jsnx: i beg your pardon?
14:13:02 <SamB> jsnx: eh?
14:13:04 <jsnx> you have to manage the dictionaries explicitly, in many cases
14:13:07 <faxathisia> Shimei, That was me
14:13:11 <mrd> isn't bytestring in base in 6.8.2?
14:13:14 <mrd> or do you need a package
14:13:17 <faxathisia> Shimei, I said lua and Io
14:13:27 <SamB> python has OO that you don't have to use if you don't feel like it
14:13:32 <mrd> I always use --make /shrug
14:13:46 <lament> jsnx: can you give an example?
14:13:52 <jsnx> SamB: try ruby, you'll see what i mean
14:14:00 <jsnx> lament: let me think about it
14:14:11 <SamB> jsnx: tell me one compelling reason to learn ruby
14:14:13 <jsnx> lament: i switched from ruby to python not too long ago
14:14:21 <jsnx> SamB: to see what i mean
14:14:29 <jsnx> SamB: not compelling :)
14:14:30 <Cale> jsnx: Well, oddly enough, this means that functions defined with def are not first class, whereas functions defined with lambda are.
14:14:31 <Arnfreth> I would think bytestring was in base in 6.8.2, but since it's complaining I must be doing something wrong
14:14:41 <jsnx> Cale: right
14:14:51 <Cale> jsnx: I'm not entirely sure why there are two kinds of functions.
14:14:55 <jsnx> Cale: no, wait, what?
14:15:08 <SamB> Cale: well, that particular wart is also found in smalltalk is it not?
14:15:11 <jsnx> Cale: functions defined with def are first class, in python
14:15:13 <gwern> Arnfreth: not much is in 6.8 base
14:15:13 <Shimei> faxathisia: Curse my short term memory. I suppose libraries are more of a catch-22 than anything.
14:15:18 <Cale> jsnx: In ruby.
14:15:21 <jsnx> Cale: oh, you mean ruby
14:15:23 <jsnx> right
14:15:23 <faxathisia> I don't know what you mean
14:15:39 <Arnfreth> in that case, how do I get it? from cabal?
14:15:46 <lament> fwiw i don't like io at all, the syntax is too unfriendly
14:15:53 <lament> if you use io, might as well just use lisp instead.
14:15:58 <Botje> good news! the syntax is sugar! :)
14:16:00 <SamB> Arnfreth: I guess they moved it out again
14:16:20 <faxathisia> lament: Io is very different to Lisp
14:16:23 <SamB> Botje: are you saying you CAN just use lisp?
14:16:30 <Arnfreth> I see
14:16:39 <Botje> every language is lisp with appropriate macros :)
14:16:43 <mrd> it's in -package bytestring
14:16:47 <lament> faxathisia: yes, but both share the same brain-damaged idea of having a syntax that's more friendly to computers than to people
14:16:52 * mrd tested
14:16:57 <roconnor> @src (==>) State
14:16:57 <lambdabot> Source not found.
14:17:02 <faxathisia> Botje: Don't you mean, Lisp is every language given enough macros?
14:17:06 <roconnor> @src (==>) State s
14:17:06 <lambdabot> Source not found. It can only be attributed to human error.
14:17:13 <mrd> though I am not sure if .Base is exposed
14:17:15 <Arnfreth> Okay, I'll try to see if I can get it installed. Thanks a lot for the help
14:17:21 <mrd> that might be your problem
14:17:33 <mrd> or did .Base go away?
14:17:42 <pjd> re. the above, the difference between def and lambda in Python is purely syntactical
14:17:58 <Arnfreth> ehm, I'm not sure how to check
14:18:00 <Cale> pjd: I'm referring to ruby.
14:18:13 <dogbite> hello, i am thinking of reimplementing a python program that uses numpy using haskell
14:18:20 <mrd> Arnfreth: the haddock API seems to have something called .Internal now
14:18:29 <mrd> http://haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString-Internal.html
14:18:30 <lambdabot> http://tinyurl.com/3cylqo
14:18:32 <SamB> dogbite: it isn't going to be much fun as far as I can tell
14:18:39 <pjd> Cale: right, just clarifying
14:19:02 <lament> dogbite: Why?
14:19:45 <Arnfreth> I think that might be overkill, since I'm just trying to make zlib compile, but I'll try to get the normal bytestring package compiled
14:19:49 <dogbite> well, i am very excited about haskell
14:19:50 <gwern> what is numpy anyway?
14:20:02 <mrd> number lib?
14:20:04 <dogbite> because of all its benefits. i'm new at it although i have
14:20:15 <dogbite> read about it non-stop over the past 3 days and have started to
14:20:17 <dogbite> design my program
14:20:26 <gwern> @where+ numpy http://numpy.scipy.org/
14:20:26 <lambdabot> It is stored.
14:20:32 <dogbite> numpy is a library that is essentially like matlab
14:21:01 <dogbite> but accessible via python.  it's an efficient numerical processing library
14:21:06 <gwern> oh. in that case, it'd be interesting to see how you do
14:21:37 <dogbite> what are the current best practices for doing numerical processing in haskell?
14:21:49 <Cale> dogbite: There's a binding to GSL.
14:21:52 <SamB> dogbite: if you are happy with what you get, please tell me...
14:21:53 <sfultong> :(
14:22:04 <lament> Cale: is there a binding to gsl? I couldn't find one.
14:22:05 <Cale> dogbite: I've never used it, and I have no idea if it's any good.
14:22:15 <dogbite> the gsl binding looks somewhat interesting, yet incomplete
14:22:19 <pjd> dogbite: your first stop is probably http://haskell.org/haskellwiki/Applications_and_libraries/Mathematics
14:22:21 <lambdabot> http://tinyurl.com/2rt3uv
14:22:23 <sfultong> main: gtk/Graphics/UI/Gtk/Gdk/PixbufData.hs.pp:58:0: No instance nor default method for class operation Data.Array.Base.getNumElements
14:22:29 <lament> dogbite: There might or might not be a binding to GSL, but you can write your own bindings to a particular parts of it in seconds.
14:22:36 <lament> dogbite: haskell has a very good interface to c.
14:22:42 <Cale> http://alberrto.googlepages.com/gslhaskell
14:22:42 <lambdabot> Title: Alberrto - hmatrix
14:23:15 <lament> dogbite: (i have done this a little)
14:23:38 <dogbite> so the current best practice is to use the hmatrix library
14:23:43 <Arnfreth> mrd, how or where do I actually download the bytestring package? I can't figure out what the purpose of haddock is, since there isn't any download links or anything, but it's probably just me who's new to all this package stuff
14:23:51 <Cale> dogbite: I suppose. What sort of computation is it?
14:23:55 <mrd> Arnfreth: it's documentation. you have bytestring.
14:24:11 <mrd> Arnfreth: the problem is, in a nutshell, that library you have is out of date.  .Base is renamed to .Internal
14:24:30 <Arnfreth> aah
14:24:32 <dogbite> the computations are things like regression analysis and standard linear algebrea
14:24:41 <Arnfreth> so what can I do about it?
14:24:44 <lament> for standard linear algebra, hmatrix probable does that
14:24:48 <lament> *probably
14:24:49 <Cale> Try hmatrix then, yeah.
14:24:53 <mrd> possibly edit the files and change .Base to .Internal  there
14:25:12 <lament> dogbite: but do have a look at haskell's FFI if you haven't yet.
14:25:13 * wli wonders why the Schur decomposition is missing from gslhaskell.
14:25:14 <mrd> where did you get the library from?
14:25:15 <Arnfreth> I'll give it a shot. Thanks!
14:25:26 <Arnfreth> the bytestring library?
14:25:30 <mrd> the zlib thingy
14:25:34 <dogbite> the FFI is for connecting to external c, correct?
14:25:52 <mrd> because there should be an up-to-date compression library on hackage.haskell.org or haskell.org
14:25:58 <Arnfreth> cabal I think, two secs
14:26:10 <Arnfreth> I'm trying to install cabal-install, which depends on it
14:26:15 <dogbite> what about the general task of processing 2d arrays of numbers?
14:26:32 <dogbite> from what i gather the performance of Array is poor because it scales as O(n)
14:26:33 <mrd> is cabal-install up-to-date? or did it bitrot?
14:26:42 <gwern> mrd: up to date
14:26:45 <Arnfreth> which is kind of ironic, since I've been stuck in dependency hell the last two days because I want to install something to solve that problem ;)
14:26:47 <gwern> well, the darcs repo is
14:26:51 <gwern> it's quite nice
14:26:51 <wli> dogbite: O(lg(n))
14:26:53 <Cale> dogbite: There's a difference between lists and arrays.
14:27:01 <Arnfreth> I think it's up to date
14:27:09 <Saizan> mrd: did you "cabal update"?
14:27:10 <dogbite> well if you were to write something that kept a 2d array of some general type
14:27:23 <Saizan> Arnfreth: did you "cabal update"?
14:27:27 <sfultong> hey, is there a good reason for lazy IO?
14:27:28 <dogbite> lists don't seem optimal for that
14:27:44 <Saizan> Arnfreth: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib-0.4.0.4 <-- or try this zlib
14:27:45 <Cale> dogbite: Right, don't use them for that, if you have a lot of data. Use arrays :)
14:27:46 <lambdabot> http://tinyurl.com/2yr4xl
14:27:56 <mrd> sfultong: low memory usage perhaps
14:27:56 <gwern> you want http://darcs.haskell.org/cabal and http://darcs.haskell.org/cabal-install
14:27:57 <Cale> dogbite: Haskell has rather nice immutable and mutable array libraries.
14:27:58 <lambdabot> Title: Index of /cabal
14:28:15 <gwern> sfultong: sure. the usual benefits of laziness - simpler code and constant memory usage
14:28:19 <Arnfreth> that's the one I'm trying to compile which complains about bytestring.
14:28:38 <sfultong> I'm not sure I understand how lazy IO helps memory usage
14:28:51 <sfultong> I mean, I don't understand
14:28:53 <sfultong> :-P
14:28:54 <Arnfreth> I'm beginning to wonder if I did anything wrong when I upgraded ghc on my ubuntu system, and ghc6.6 is still trying to do the compiling
14:29:04 <dogbite> are you familiar with the Xarray library?
14:29:06 <jsnx> dons: where did you get the `run` function in http://cgi.cse.unsw.edu.au/~dons/blog/2007/03 ?
14:29:07 <lambdabot> Title: Haskell hacking
14:29:10 <mrd> Arnfreth: type ghc -v
14:29:15 <Cale> dogbite: Nope.
14:29:17 <Botje> sfultong: getContents >>= print . length
14:29:18 <dogbite> it seems like a very clevery student project
14:29:21 <Botje> look! lazy IO!
14:29:30 <dogbite> the goal is an array library
14:29:31 <SamB> sfultong: well, suppose you wrote a darcs-to-git conversion script in ruby, and started by slurping the entire darcs inventory into memory...
14:29:40 <dogbite> that has support for missing values and other computations over the vlues
14:29:49 <dogbite> so you could use it for building a spreadsheet program
14:29:50 <mrd> sfultong: the lazy IO primitives in ghc are clever enough to only load data into memory on-demand
14:29:58 <Arnfreth> "Glasgow Haskell Compiler, Version 6.8.2, for Haskell 98, stage 2 booted by GHC version 6.6.1"
14:30:06 <dogbite> some of that functionality is very appealing to me but the project is stale
14:30:15 <gwern> sfultong: are you familiar with mmap? https://secure.wikimedia.org/wikipedia/en/wiki/Mmap
14:30:16 <dogbite> and it was designed for usability, not performance
14:30:26 <gwern> think of lazy io as mmap everywhere maybe?
14:30:52 <SamB> gwern: except you don't need address space for lazy io
14:31:01 <sfultong> well, if you have mmap and sequence, why do you need lazy io? :-P
14:31:07 <jsnx> gwern: mmap uses all the memory at once, i though
14:31:10 <mrd> Arnfreth: i don't know how you got into that situation.  surely ubuntu has the .debs too?
14:31:14 <jsnx> s/though/thought/
14:31:16 <Saizan> Arnfreth: try clean in the zlib dir and restart
14:31:17 <mrd> libghc6-*-dev
14:31:31 <pjd> jsnx: mmap doesn't use any memory until you access something
14:31:36 <SamB> jsnx: it doesn't use RAM all at once, just address space
14:31:39 <gwern> jsnx: my understanding was that virtual memory was allocated, but the OS on page faults demand pages the sections into real memoryt
14:31:39 <pjd> pages are swapped in lazily
14:31:53 <Arnfreth> ubuntu doesn't have devs for zlib nor ghc6.8
14:31:54 <dons> jsnx: http://www.cse.unsw.edu.au/~dons/code/cpuperf/Process.hs
14:32:03 <Arnfreth> which is kinda why I'm stranded here
14:32:10 <pjd> (and swapped out when they haven't been accessed for a while)
14:32:12 <jsnx> pjd: thank you for explaining
14:32:21 <Nafai> dons: I watched a video given by your boss.  Galois seems like a cool place to work
14:32:25 <SamB> of course, using lazy IO is only a good idea if you aren't expecting to need random access, unlike mmap
14:32:32 <gwern> ubuntu isn't as good with haskell stuff as it could be
14:32:33 <dogbite> thank you all for your quick input
14:32:48 <jsnx> dons: thank you
14:32:48 <Arnfreth> Saizan, what do you mean when you say clean in the zlib dir? delete and recreate from zip or something specific?
14:32:55 <pjd> (mmap is also useful for sharing memory between processes, but that's another kettle of fish)
14:32:55 <dogbite> i will keep you posted as i progress with my project
14:32:58 <Arnfreth> gwern, agreed
14:33:01 <gwern> sfultong: some haskell stuff does use mmap for laziness, iirc, like bytestring
14:34:02 <Saizan> Arnfreth: i mean runghc Setup clean
14:34:08 <SamB> gwern: eh?
14:34:26 <Saizan> Arnfreth: which should delete the dist subdirectory
14:34:32 <sfultong> I like laziness in general, but it seems to me that laziness in IO just complicates reasoning about what will happen when
14:34:49 <SamB> sfultong: well, yes, that is true
14:35:00 <SamB> but it's great when you don't care much about that
14:35:04 <gwern> SamB: don't lazy bytestrings use mmap?
14:35:21 <wli> I don't mind laziness vs. non-laziness. It's the error reporting and propagation that bothers me in both the strict and lazy API's.
14:35:23 <Arnfreth> Saizan, I'll try, thanks
14:35:24 <sfultong> with mmap and sequence you can "add" laziness to IO... and it's still relatively easy to reason about
14:35:27 <Saizan> gwern: i think there's a specific mmap-for-bytestring packages
14:35:35 <gwern> hm. there's the bytestring-mmap package
14:35:59 <dons> both strict and lazy bytestrings can be mmapped
14:36:04 <SamB> gwern: I imagine the only thing mmap has to do with bytestrings is that it can be usefull to create a bytestring by mmapping a file
14:36:15 <dons> mmap is basically the kernel level laziness
14:36:27 <mofmog> so i type into ghci "let sequence_ a = foldr (>>) a"
14:36:30 <mofmog> and it works
14:36:39 <mofmog> however if i use sequence_ it spits out an error message
14:36:52 <wli> Having to write a catch block for every line even when errors may merely signal the need to retry or defer attempts to continue IO are nasty.
14:36:53 <gwern> http://darcs.serpentine.com/unicode/_darcs/patches/20060429034429-9c5c1-d44012f8600320ad8e1b53a7e03c26bb234e1e6a.gz <-- looks like bytestring itself did have mmap functions for a while
14:36:54 <lambdabot> http://tinyurl.com/yrzwub
14:37:00 <SamB> dons: so what happens when you mmap a file as a lazy bytestring?
14:37:09 <mofmog> i figure i have to tell ghci that sequence_ works with the IO monad, but I can't figure out how to do that
14:37:10 <byorgey> mofmog: what error message?
14:37:22 <gwern> http://reddit.com/r/programming/info/62txm/comments/ 'Data.ByteString had mmap. This was removed. Any plans on re-introducing it? Is there mmap support anywhere in Haskell/GHC?'
14:37:29 <dons> SamB: its mapped and unmapped in chunkwise fashion
14:37:30 <kalmar> :t foldr (>>) (return ())
14:37:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
14:37:38 <Arnfreth> Saizan, that solved the problem with zlib, thanks a lot
14:37:44 <SamB> dons: how large are the chunks?
14:37:48 <mofmog> sequence_ :: (Monad m) => [m a] -> m ()
14:38:03 <byorgey> mofmog: ah, indeed, I think you want foldr (>>) (return ()) a, as kalmar suggests
14:38:12 <dons> http://hackage.haskell.org/packages/archive/bytestring-mmap/0.2.0/doc/html/System-IO-Posix-MMap-Lazy.html
14:38:13 <byorgey> :t foldr
14:38:14 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:38:14 <lambdabot> http://tinyurl.com/yw76y8
14:38:18 <faxathisia> interesting mofmog
14:38:19 <dons> Memory map a file as a lazy ByteString. Finalisers are associated cached-sized portions of the file, which will be deallocated as those chunks go out of scope.
14:38:20 <wli> (What I want the Schur decomposition for is eigencrap for defective matrices.)
14:38:23 <dons> Unlike strict Bytestrings, mmapFile for Lazy ByteStrings will deallocate chunks of the file.
14:38:25 <sfultong> err... wait, oops.  I was reading mmap as mapm... silly me
14:38:31 <byorgey> mofmog: note the type of foldr
14:38:31 <Saizan> Arnfreth: that's why cabal caches information about external programs in a file, and that information can become obsolete.
14:38:36 <faxathisia> hey byorgy, how's Agda'ing? :D
14:38:42 <mofmog> :t foldr
14:38:43 <dons> SamB: so when you stop referencing some substring in the lazy bytestring, it will be unmapped
14:38:45 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:38:54 <Arnfreth> I see
14:39:04 <faxathisia> sorry, byorgey.. I keep making that mistake
14:39:08 <mofmog> so foldr is working on monads?
14:39:20 <byorgey> mofmog: no, foldr is a general list combinator
14:39:21 <mofmog> that's obvious i think
14:39:23 <mofmog> oh
14:39:24 <mofmog> right
14:39:27 <mofmog> like reduce
14:39:33 <byorgey> yes, exactly =)
14:39:36 <mofmog> so
14:39:37 <byorgey> it IS reduce =)
14:39:54 <mofmog> am i folding in the wrong direction?
14:40:03 <byorgey> faxathisia: your IRC client doesn't have nick tab completion? ;)
14:40:04 * mrd thinks of reduce as foldl
14:40:12 <SamB> mofmog: if so, switch to foldl
14:40:15 <faxathisia> byorgey, me secrets out..
14:40:17 <mofmog> lemme try
14:40:18 <SamB> or probably foldl'
14:40:20 <dons> mmap has similar restrictions on IO as haskell lazy io ops do, interestingly
14:40:24 <sfultong> does anyone think I have a point in saying (non explicitly stated) lazy IO is a bad idea?  Or am I just being sort-sighted?
14:40:27 <byorgey> mofmog: no, you're folding in the right direction.
14:40:34 <dons> i.e. you get unguaranteed effect orders, and issues with sharing
14:40:48 <dons> sfultong: you often want both?
14:40:53 <byorgey> mofmog: the problem is that foldr takes a combining function AND a starting value, in addition to the list you are folding
14:40:54 <dons> that's why even C has mmap
14:40:59 <mofmog> oh right
14:41:02 <byorgey> mofmog: in your definition of sequence_ you didn't give it a starting value
14:41:04 <pjd> mofmog: foldr is the catamorphism for lists, to be precise
14:41:04 <mofmog> starting value
14:41:06 <byorgey> which should be (return ())
14:41:12 <mofmog> a
14:41:17 <mofmog> ohh
14:41:18 <mofmog> i see
14:41:24 <mofmog> so it looks something like
14:41:27 <byorgey> sorry, instead of 'starting value' perhaps I should say 'ending value'
14:41:34 <dons> lazy IO is a good default for streaming processes, for files maybe not so much. that's why its best to provide both options
14:41:36 <mofmog> return () >> monadfunction1 >> monadfunction2
14:41:42 <mrd> the other day I was walking outside and I saw a catamorphism playing with a ratamorphism
14:41:45 <faxathisia> :D :D
14:41:53 <gwern> sfultong: no, you do have a point that lazy io isn't bugfree yet and so it's good for folks to know when they're using it
14:41:59 <faxathisia> > foldr (>>) (return ()) [fun "monadfunction1", fun "monadfunction2"]
14:42:00 <lambdabot>        add an instance declaration for (SimpleReflect.FromExpr (m a))
14:42:05 <faxathisia> HMF :/
14:42:09 <byorgey> mofmog: sorry, no, it would be m1 >> m2 >> return ()
14:42:11 <mrd> I heard an incessant squeaking noise and found that I had nearly stepped on the ratamorphism
14:42:19 <gwern> but I think defaulting to laziness is fine so far - I don't see all that many people showing up with errors here
14:42:20 <faxathisia> > foldr (>>) (return ()) [fun "monadfunction1", fun "monadfunction2"] :: Expr
14:42:20 <pjd> mrd: i bet you never metamorphism you didn't like
14:42:20 <lambdabot>  Couldn't match expected type `Expr' against inferred type `m ()'
14:42:24 <mofmog> damn i can't remember the order of the folds
14:42:29 <sfultong> ok, cool... I like not being entirely wrong :-P
14:42:35 <byorgey> > foldr f [x, y, z]   -- mofmog
14:42:36 <lambdabot>   add an instance declaration for (Typeable Expr)
14:42:36 <SamB> sfultong: it won't ever be gotcha-free
14:42:43 <faxathisia> > foldr (>>) (fun "return ()") [fun "monadfunction1", fun "monadfunction2"] :: Expr
14:42:43 <lambdabot>  Couldn't match expected type `Expr' against inferred type `m b'
14:42:45 <SamB> er. gwern
14:42:48 <SamB> whatever
14:42:49 <faxathisia> aw man..
14:42:56 <byorgey> > foldr f z [a, b, c] :: [Expr]  -- mofmog
14:42:57 <lambdabot>  Couldn't match expected type `[Expr]' against inferred type `Expr'
14:43:01 <byorgey> argh, sorry =P
14:43:15 <byorgey> > foldr f z [a, b, c]
14:43:16 <lambdabot>  f a (f b (f c z))
14:43:18 <faxathisia> we need an Expr Monad!
14:43:19 <byorgey> there =)
14:43:22 <mofmog> ah
14:43:31 <mofmog> so the deepest level is on the right
14:43:39 <mofmog> so foldl would have the deepest level on the left
14:43:44 <Heffalump> > \(a :: Expr) -> a
14:43:44 <lambdabot>  Parse error in pattern at "->" (column 14)
14:43:50 <mrd> > foldr (+) z [a, b, c] :: Expr
14:43:51 <lambdabot>  a + (b + (c + z))
14:43:57 <byorgey> mofmog: yes
14:43:58 <Heffalump> > (+) :: Expr -> Expr -> Expr
14:43:59 <lambdabot>   add an instance declaration for (Typeable Expr)
14:44:03 <mofmog> and the given value, for example (return ()) is placed in the deepestlevel
14:44:08 <Heffalump> huh?
14:44:10 <byorgey> mofmog: right
14:44:15 <mofmog> alright alright
14:44:17 <mofmog> everything makes sense now
14:44:19 <mrd> > foldr (><) z [a, b, c] :: Expr
14:44:19 <lambdabot>   Not in scope: `><'
14:44:22 <byorgey> mofmog: good =)
14:44:30 <mrd> > foldl (+) z [a, b, c] :: Expr
14:44:31 <lambdabot>  z + a + b + c
14:44:39 <kalmar> ?src Expr
14:44:39 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:44:45 <TSC> Is there any documentation anywhere on the Expr type?
14:44:45 <byorgey> @where Expr
14:44:45 <lambdabot> I know nothing about expr.
14:44:48 <Heffalump> > foldl (.) id [a, b, c] :: Expr
14:44:48 <lambdabot>  Couldn't match expected type `a -> a' against inferred type `Expr'
14:44:55 <mofmog> > foldr (+) z [a,b,c]
14:44:56 <lambdabot>  a + (b + (c + z))
14:45:00 <mofmog> yup
14:45:01 <kalmar> I saw the post on reddit, is it related to that
14:45:16 <kalmar> added to lambdabot?
14:45:27 <faxathisia> > let xs = [a,b,c,x,y,z] in ( foldr (flip f) e xs , foldl f e (reverse xs) )
14:45:29 <lambdabot>  (f (f (f (f (f (f e z) y) x) c) b) a,f (f (f (f (f (f e z) y) x) c) b) a)
14:45:39 <mrd> > foldr (.) id [a, b, c] :: Expr
14:45:39 <lambdabot>  Couldn't match expected type `a -> a' against inferred type `Expr'
14:45:40 <byorgey> @where+ Expr http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
14:45:40 <lambdabot> It is stored.
14:45:42 <mrd> hmm
14:45:44 <byorgey> @where Expr
14:45:44 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
14:45:50 <TSC> Thanks
14:46:02 <faxathisia> > let xs = [a,b,c,x,y,z] in ( foldl (flip f) e xs , foldr f e (reverse xs) )
14:46:03 <lambdabot>  (f z (f y (f x (f c (f b (f a e))))),f z (f y (f x (f c (f b (f a e))))))
14:46:27 <mofmog> there should be a contest
14:46:46 <byorgey> mofmog: for what?
14:46:56 <mofmog> who can write the most complex program using only lambda calculus. Now of course, l calculus is turing complete
14:47:00 <mrd> hmm, mofmog hasn't seen @pl yet
14:47:06 <mrd> or unlambda
14:47:29 <mofmog> so the stipulation is that you only get a sheet of legal pad and two ball point pens
14:48:05 <faxathisia> > ( foldr f e ([a,b,c] ++ [x,y,z]) , foldr f (foldr f e [x,y,z]) [a,b,c] )
14:48:05 <lambdabot>  (f a (f b (f c (f x (f y (f z e))))),f a (f b (f c (f x (f y (f z e))))))
14:48:17 <pjd> mofmog: you'll have a really hard time defining "complex"
14:48:22 <faxathisia> lambda calculus?
14:48:25 <mrd> > scanl (+) z [a,b,c] :: [Expr]
14:48:26 <lambdabot>  [z,z + a,z + a + b,z + a + b + c]
14:48:26 <jimminy> what defines complex?  most symbols that evaluates to normal form?
14:48:28 <faxathisia> with datatypes? :D
14:48:31 <mofmog> pjd: it shall be judged by cooolness
14:48:35 <mofmog> for example
14:48:38 <faxathisia> There's some pretty complex programs written in that..
14:48:55 <jimminy> coolness?  not very well defined...
14:48:58 <mofmog> fibonacci numbers? nah htat's just a y combinator and some extra stuff
14:48:59 <kalmar> :t f
14:49:00 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
14:49:02 <faxathisia> mofmog: btw, who cares about turing complete?
14:49:15 <kalmar> :t adfjak
14:49:16 <lambdabot> Not in scope: `adfjak'
14:49:21 <faxathisia> mofmog: It's like using a powersaw with no safety guard
14:49:26 <mrd> who can write the most complex program using only the basic polymorphic lambda calculus
14:49:30 <kalmar> :t m
14:49:30 <pjd> total functional programming now!
14:49:31 <lambdabot> Expr
14:49:45 <kalmar> :t g
14:49:46 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
14:49:51 <kalmar> ?where SimpleReflect
14:49:51 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
14:49:51 <mofmog> it's sort of like demo programming in asm
14:49:55 <mofmog> except 10000x nerdier
14:50:08 <faxathisia> mofmog, you could cheat..
14:50:18 <mofmog> how so?
14:50:29 <faxathisia> mofmog, Just compile any big haskell or ML program into an untyped lambda calc
14:50:31 <pjd> mofmog: you should check out Unlambda and Lazy K
14:50:33 <jimminy> faxathisia: he stipulated paper and pen, so i'd assume it would be in person
14:51:00 <SamB> PEN???????
14:51:00 <faxathisia> cons = \x y -> \f -> f x y -- etc..
14:51:14 <mofmog> it'd come down to figuring if an expression bet reduced corectly
14:51:16 <jimminy> SamB: two pens, actually
14:51:22 <mofmog> yes two
14:51:31 <lispy> "Variable occurs more often in a constraint than in the instance head"  This is with a type class.  Why does this lead to undecidable instances?
14:51:40 <mofmog> eventually you will become so frustrated that one will break
14:52:16 <mofmog> or we could just have a set task and whoever gets it right first wins
14:52:22 <mofmog> but that's nowhere near as fun
14:52:44 <Heffalump> lispy: because you end up with more constraints when you reduce
14:52:49 <Heffalump> so there's no guarantee of termination
14:54:08 <dons> ?bugs
14:54:08 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
14:54:10 <lispy> I wonder if I should just turn on undeciable instances
14:54:41 <Heffalump> yeah.
14:55:03 <hpaste>  sfultong pasted "gtk2hs pixbuf annoyance" at http://hpaste.org/6111
14:55:35 <lispy> Heffalump: well, this is darcs source and I really don't want to cause headaches for others, but there is no obvious way (at least to me) to do what I want without them.
14:57:30 <lispy> If I want to add a language pragma to a .lhs source, do I put the pragma as a comment in the first code block or do I put it in the start of literate section?
14:57:49 <gwern> lispy: I've always done it as the former
14:58:15 <Cale> http://cale.yi.org/index.php/Fold_Diagrams
14:58:17 <lambdabot> Title: Fold Diagrams - CaleWiki
14:58:36 <Cale> mofmog: you might like those :)
14:58:54 <lispy> gwern: yes, that does seem to work.  Thanks.
14:59:08 <faxathisia> hmmmmm
14:59:28 <faxathisia> Wonder if you would hook up Expr and GraphViz
15:00:12 <faxathisia> I think it might be possible to make pictures a little bit like that
15:01:54 <dibblego> ?type \e t -> if e then t else return () -- does this function exist in the libraries somewhere?
15:01:55 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
15:02:23 <lispy> when?
15:02:27 <lispy> ?type when
15:02:28 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
15:02:33 <dibblego> ah great, cheers
15:02:42 <lispy> > when True (Just 1)
15:02:43 <lambdabot>   add an instance declaration for (Num ())
15:02:56 <lispy> > when True (Just ())
15:02:57 <lambdabot>  Just ()
15:03:01 <lispy> > when False (Just ())
15:03:02 <lambdabot>  Just ()
15:03:11 <lispy> er, not a very good example i see ;)
15:03:23 <dibblego> IO is probably the best example
15:03:45 <sfultong> > when True ("")
15:03:45 <lambdabot>  Couldn't match expected type `()' against inferred type `Char'
15:03:46 <lispy> dibblego: yeah, well state would work with lambdabot
15:04:07 <lispy> dibblego: and the example could show it off  if you update the state but not the value
15:04:09 <mrd> > when True []
15:04:10 <lambdabot>  []
15:04:13 <mrd> > when False []
15:04:14 <lambdabot>  [()]
15:04:16 <mrd> thar
15:04:22 <lispy> nice and simple
15:04:23 <sfultong> yeah
15:04:23 <dibblego> lispy, I have an example in my IO code ;) thanks
15:04:44 <lispy> I think when has a corresponding unless...
15:04:48 <lispy> ?hoogle unless
15:04:48 <lambdabot> Control.Monad.unless :: Monad m => Bool -> m () -> m ()
15:04:54 <mrd> > (:[]) (:[])
15:04:54 <lambdabot>  Add a type signature
15:04:59 <dibblego> hrm; now I wonder which is which
15:04:59 <lispy> > unless True []
15:05:00 <lambdabot>  [()]
15:05:01 <dibblego> ?src when
15:05:01 <lambdabot> when p s = if p then s else return ()
15:05:07 <dibblego> ?src unless
15:05:07 <lambdabot> unless p s = if p then return () else s
15:05:14 <mrd> > (:[]) (:[]) :: [a -> [a]]
15:05:15 <lambdabot>  Add a type signature
15:06:19 <dibblego> Haskell is the best imperative language
15:06:26 <mrd> :t (:[]) (:[])
15:06:28 <dibblego> it's just great sometimes!
15:06:37 <lambdabot> forall a. [a -> [a]]
15:06:46 <mrd> yay, no show instance for ->, duh
15:07:07 <faxathisia> :t (:[]) (:[]) (:[]) (:[])
15:07:08 <lambdabot>     Couldn't match expected type `t1 -> t2 -> t'
15:07:08 <lambdabot>            against inferred type `[a]'
15:07:11 <faxathisia> aw.
15:07:21 <lispy> :t (:[]) (:[]) (:[]) (:[]) :: Expr
15:07:22 <lambdabot>     Couldn't match expected type `t -> t1 -> Expr'
15:07:22 <lambdabot>            against inferred type `[a]'
15:07:40 <lispy>  > (:[]) (:[]) :: Expr
15:07:45 <lispy> > (:[]) (:[]) :: Expr
15:07:46 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
15:08:08 <mrd> :t map (:[]) $ (:[]) (:[])
15:08:09 <lambdabot> forall a. [[a -> [a]]]
15:08:26 <byorgey> @src guard
15:08:27 <lambdabot> guard True  =  return ()
15:08:27 <lambdabot> guard False =  mzero
15:09:23 <lispy> byorgey: if you're comparing that to 'when' and 'unless' the difference is that guard False means something went wrong, in a sense.
15:09:30 <dibblego> ?type guard
15:09:32 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
15:09:42 <dcoutts_> Arnfreth: did you get zlib installed in the end?
15:10:09 <Arnfreth> dcoutts, I did, yes
15:10:19 <Arnfreth> And I'm very thankful for the help I got here
15:10:42 <Arnfreth> right now I'm fetching cabal-install with darcs because it's complaining over something when I'm trying to install it
15:10:46 <dibblego> ?check \p -> p `when` mzero == guard p
15:10:47 <lambdabot>   add an instance declaration for (Eq (m ()))     In the expression: p `when`...
15:10:51 <Arnfreth> but it's moving forward....
15:11:24 <jrx> is there any function fmap-like for tuples?
15:11:43 <SamB> :t left
15:11:43 <mrd> could only be for one value in a tuple
15:11:44 <faxathisia> @instances Functor
15:11:45 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
15:11:45 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
15:11:48 <jrx> like in fmap (+1) (1,2) ----> (2,3)
15:11:54 <SamB> :t first
15:11:54 <faxathisia> > fmap (+1) (1,2)
15:11:55 <byorgey> ?check \p -> (p :: [()]) `when` mzero == guard p
15:11:56 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
15:11:56 <lambdabot>  Couldn't match expected type `Bool' against inferred type `[()]'
15:11:56 <lambdabot>  (1,3)
15:12:02 <SamB> :t second
15:12:03 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
15:12:03 <Arnfreth> the learning curve has been a little steep, but I think I'm over the worst part
15:12:04 <lispy> ?check \p -> p `when` (mzero :: [Int]) == guard p
15:12:05 <lambdabot>  Couldn't match expected type `()' against inferred type `Int'
15:12:07 <byorgey> oh, duh =P
15:12:10 <faxathisia> > swap (fmap (+1) (swap (1,2)))
15:12:11 <lambdabot>   Not in scope: `swap'
15:12:11 <dcoutts_> @tell ndm building gtk2hs on win32 is easy! :-) I even give everyone the scripts and the tarball to work from.
15:12:11 <lambdabot> Consider it noted.
15:12:12 <mrd> > second (+1) (1,2)
15:12:13 <lambdabot>  (1,3)
15:12:46 <xerox> ?type join (***)
15:12:47 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
15:12:48 <lispy> ?check \p -> p `when` (mzero :: [()]) == guard p
15:12:48 <mrd> > second (+x) (a,b) :: Expr
15:12:48 <lambdabot>  Falsifiable, after 0 tests: True
15:12:49 <lambdabot>  Couldn't match expected type `Expr'
15:12:52 <xerox> there you go
15:12:54 <mrd> > second (+x) (a,b) :: (Expr, Expr)
15:12:54 <lambdabot>  (a,b + x)
15:13:00 <lispy> ?check \p -> p `unless` (mzero :: [()]) == guard p
15:13:00 <lambdabot>  OK, passed 500 tests.
15:13:06 <xerox> > join (***) f (x,y)
15:13:07 <lambdabot>  Add a type signature
15:13:26 <dibblego> ?check \p -> p `when` (mzero :: [()]) == guard $ not p
15:13:26 <lambdabot>  Couldn't match expected type `[()]'
15:13:28 <xerox> > join (***) (f::Int->Int) (x,y)
15:13:28 <lambdabot>  Couldn't match expected type `Int' against inferred type `Expr'
15:13:37 <xerox> > join (***) (f::Expr->Expr) (x,y)
15:13:38 <lambdabot>  (f x,f y)
15:13:54 <sfultong> dcoutts_: I'm having a gtk2hs pixbuf annoyance :(  can you give me a bit of help?
15:14:05 <dibblego> ?check \p -> p `when` (mzero :: [()]) == guard (not p)
15:14:06 <lambdabot>  OK, passed 500 tests.
15:14:29 <dcoutts_> sfultong: the pixbuf thing with ghc-6.8 ?
15:14:45 <mrd> > sequence [[a,b,c],[a,b,c]] :: [[Expr]]
15:14:46 <lambdabot>  [[a,a],[a,b],[a,c],[b,a],[b,b],[b,c],[c,a],[c,b],[c,c]]
15:14:48 <faxathisia> ?check \p -> p `when` (mzero :: [] ()) == guard (not p)
15:14:49 <lambdabot>  OK, passed 500 tests.
15:14:50 <sfultong> dcoutts: hmm, I dunno... what thing is this? I have have 6.8
15:14:56 <sfultong> *I do have
15:15:11 <byorgey> @unmtl StateT s (MaybeT IO) a
15:15:11 <lambdabot> s -> IO (Maybe (a, s))
15:15:14 <mrd> > filterM (const [False..]) [a,b,c,d,e] :: [[Expr]]
15:15:14 <lambdabot>  Parse error at "False..." (column 17)
15:15:16 <dcoutts_> sfultong: you'll have to use the darcs version with the fix
15:15:19 <mrd> > filterM (const [False ..]) [a,b,c,d,e] :: [[Expr]]
15:15:20 <lambdabot>  [[],[e],[d],[d,e],[c],[c,e],[c,d],[c,d,e],[b],[b,e],[b,d],[b,d,e],[b,c],[b,c...
15:15:24 <lispy> unmtl?
15:15:32 <lispy> Heh, i've never seen that one before
15:15:37 <byorgey> lispy: hehe =)
15:16:09 <sfultong> dcoutts: hmm, well thanks.  Is it in the gentoo overlay?
15:16:12 <byorgey> translates a stack of monad transformers into an isomorphic type (without all the newtype constructors)
15:16:20 <dcoutts_> sfultong: I think the 0.9.12 darcs branch has the fix, lemme check. No it's not in the overlay.
15:16:29 <Arnfreth> IT WORKS!
15:16:33 <Arnfreth> cake to everybody!
15:16:36 <byorgey> =D
15:16:40 <mrd> the cake isn't a lie!
15:16:50 <dcoutts_> sfultong: http://darcs.haskell.org/gtk2hs-branches/gtk2hs-0.9.12/
15:16:51 <lambdabot> Title: Index of /gtk2hs-branches/gtk2hs-0.9.12
15:17:13 <sfultong> dcoutts_: thanks
15:17:16 <dcoutts_> sfultong: that darcs repo is 0.9.12.1 + 2 bug fixes, including the pixbuf MArray fix
15:17:24 <sfultong> ah, sweet
15:17:29 <sfultong> just what I need
15:17:43 <byorgey> Arnfreth: what works?
15:17:50 <Arnfreth> cabal-install
15:17:58 <byorgey> oh, sweet =)
15:18:21 <byorgey> cabal-install is made of win
15:18:38 <Arnfreth> indeed, which means that all the problems I've had getting it installed, will now not apply to other stuff :D
15:18:45 <Arnfreth> it is indeed
15:19:14 <dcoutts_> :-)
15:19:33 <gbacon> @karma+ cabal-install
15:19:33 <lambdabot> cabal-install's karma raised to 1.
15:20:07 <dcoutts_> Arnfreth: if you find problems, check the hackage trac and report them or comment on the existing bug report
15:20:10 <gbacon> > [False ..]
15:20:15 <lambdabot>  [False,True]
15:20:19 <gbacon> > [False..]
15:20:20 <lambdabot>  Parse error at "False..." (column 2)
15:20:26 <gbacon> > [True ..]
15:20:27 <lambdabot>  [True]
15:20:31 <gbacon> clever
15:20:39 <byorgey> dcoutts_: speaking of which, did you see the cabal-install patch I sent to the list a little earlier?
15:20:46 <Arnfreth> dcoutts, will do
15:20:48 <dcoutts_> byorgey: lemme check...
15:21:04 <byorgey> dcoutts_: nothing major, just improving the output of 'cabal list' a bit
15:21:18 <dcoutts_> byorgey: great
15:21:46 <byorgey> and switching it to use HughesPJ while I was at it =)
15:23:36 <faxathisia> @flesh
15:23:36 <lambdabot> Not enough privileges
15:23:41 <lament> if lua is so amazing, why does it have arrays indexed from 1? :)
15:24:04 <faxathisia> lament, That's your choice
15:24:35 <faxathisia> they could start at 1, 0, -5... http://www.lua.org/pil/11.1.html
15:24:36 <lambdabot> Title: Programming in Lua : 11.1
15:24:39 <mrd> > listArray (1,10) [1..10]
15:24:41 <lambdabot>  array (1,10) [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10)]
15:24:47 <dcoutts_> byorgey: does the 'text' combinator do line wrapping or something?
15:25:17 <byorgey> dcoutts_: no, it's just String -> Doc
15:25:22 <lament> faxathisia: test = {"foo", "bar", "baz"}  -- test[1] is "foo"
15:25:23 <dcoutts_> byorgey: one of the things we should really do is reflow and rewrap the synopsis/description to fit 80 cols
15:25:35 <byorgey> dcoutts_: oh, that would be easy
15:25:43 <dcoutts_> byorgey: but lots of descriptions are already wrapped at a different width
15:26:03 <dcoutts_> byorgey: so we should do what haddoc does and split on paragraphs and then ignore line breaks within paragraphs
15:26:17 <dcoutts_> I think it recognises paragraphs by blank lines
15:26:17 <byorgey> dcoutts_: that's a good idea.  I'd be happy to code that up.
15:26:27 <byorgey> dcoutts_: yes, it does in the description field
15:26:32 <dcoutts_> byorgey: in the mean time I'll apply you patch :-) thanks
15:26:58 <byorgey> dcoutts_: you're welcome =)
15:27:09 <dcoutts_> byorgey: btw did you see that we've now got bash command line completion for cabal ?
15:27:16 <dcoutts_> including completing names of packages
15:27:19 <byorgey> ooooooh!! shiny =)
15:27:24 <byorgey> I hadn't noticed
15:27:31 <dcoutts_> cab<tab> i<tab> xmo<tab><tab>
15:27:51 <dcoutts_> in the bash-completion/ dir in the cabal-install repo
15:28:49 <byorgey> dcoutts_: hm, I'm not familiar with this sort of thing.  where do I have to put that bash-completion file to get it to work?
15:29:22 <dcoutts_> byorgey: depends on you distro I think, sadly
15:29:28 <byorgey> oh =(
15:29:39 <dcoutts_> byorgey: for a quick fix: source bash-completion/cabal
15:29:43 <lispy> what is the language extension for explicit kinding?
15:30:03 <lispy> n/m
15:30:06 <lispy> KindSignatures
15:30:09 <Zao> I couldn't quite find this in any documentation: foreign declarations are unsafe by default, right?
15:30:21 <dcoutts_> byorgey: on gentoo it's /usr/share/bash-completion/ but different distros do it differently unfortunately
15:30:27 <byorgey> dcoutts_: ah, I found it, /etc/bash_completion.d/ on ubuntu
15:31:00 <dcoutts_> byorgey: in the end it'll have to be something the distro packages sort out
15:31:09 <byorgey> dcoutts_: yeah
15:31:32 <lispy> actually, it says it can't parse it
15:31:42 <lispy> so maybe the docs are wrong or i'm doing it wrong
15:32:12 <byorgey> dcoutts_: cool, it works =)
15:32:35 <dcoutts_> byorgey: completion for names is a bit slow because ghc-pkg list is really slow
15:32:44 <byorgey> dcoutts_: ok, I noticed that.
15:32:53 <byorgey> why is ghc-pkg list so slow?
15:32:57 <dcoutts_> it takes ~7 seconds on this old box with only 68 registered packages
15:33:08 <byorgey> yikes
15:33:10 <dcoutts_> byorgey: it uses a silly package db format and a really slow parser
15:33:23 <byorgey> ah
15:33:34 <lispy> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#kinding
15:33:36 <lambdabot> Title: 8.7. Other type system extensions, http://tinyurl.com/3c7ura
15:33:37 <dcoutts_> on my fast machine it's still 1 and a bit seconds with 180 registered packages
15:33:44 <byorgey> well, it only takes 0.3s on my machine, but that's still noticeable when tab-completing package names
15:33:47 <lispy> according to that page, -XKindSignatures turns on explicit kinding.
15:33:59 <dcoutts_> byorgey: it's because it uses Read/Show
15:34:06 <byorgey> dcoutts_: doh!
15:34:09 <lispy> But, when I turn it on in {-# OPTIONS -XKindSignatures #-} it gives me an unknown flag error
15:34:28 <byorgey> lispy: try using {-# LANGUAGE KindSignatures #-}
15:34:32 <byorgey> lispy: what version of ghc?
15:34:37 <dcoutts_> byorgey: so if you want to do us all a great service, code up a new binary format, there's an open ghc ticket on the issue
15:34:41 <lispy> byorgey: it said it couldn't parse the language pragma :(
15:34:52 <lispy> byorgey: 6.6
15:35:08 <dcoutts_> lispy: -X flags are new in ghc-6.8
15:35:10 <byorgey> lispy: ah, hm, does 6.6 even have the new -X flags?
15:35:16 <dcoutts_> and several of the extensions are new too
15:35:24 <byorgey> dcoutts_: interesting idea =)
15:35:34 <dcoutts_> lispy: previously they were just under the general umbrella of -fglasgow-exts
15:35:38 <byorgey> dcoutts_: I'll add it to my list of possible projects =)
15:35:40 <lispy> Oh, I see
15:35:47 <lispy> dcoutts_: thanks, i'll try that extention then
15:35:56 <dcoutts_> lispy: if you put the extension in the .cabal file, cabal will use the right flag according to your ghc version
15:35:58 <lispy> I can't use 6.8 because gadt type checking was changed too much
15:36:14 <dcoutts_> byorgey: :-)
15:39:54 <gwern> but - but lispy, 6.8 is teh FUTURE!
15:40:43 <dolio> -X wasn't in 6.6, was it?
15:41:02 <dolio> It was just -fglasgow-exts, or a few other -f options.
15:41:18 <bos31337> correct.
15:41:32 * gwern plays hamlet - the text adventure http://versificator.co.uk/hamlet/
15:41:33 <lambdabot> Title: Hamlet - The Text Adventure
15:41:36 <gwern> (mischan)
15:42:21 <lispy> gwern: yeah, but I guess gadt type checking was changed a lot in 6.8 and will be rewritten in 6.10
15:42:53 <lispy> gwern: And we have code that is just fine and type checks under 6.6 but not 6.8, so I'm not sure what to make of it.  For now, we'll deal with 6.6 and not worry about 6.8.
15:43:09 <nornagon> am I correct in believing that hscurses is the curses library to use these days?
15:43:26 <nornagon> (also, hi gwern, i notice you uploaded the most recent hackage entry for hscurses :))
15:43:35 <gwern> nornagon: I'm not sure any curses library is really the one to use
15:43:47 <nornagon> -.-
15:44:29 <faxathisia> dolio, not able to get ghc or agda here, no make gcc or anything.. sorry, I could test when I'm back in a few days
15:44:33 <nornagon> is there any sane alternative for terminal graphics? there's vty, but iirc that's limited in sort of annoying ways
15:44:35 <gwern> nornagon: although if you really need curses stuff, I'm not sure what alternative you have to hscurses
15:44:45 <gwern> vty is somewhat abandoned
15:44:55 <nornagon> wie schade :(
15:44:56 <faxathisia> nornagon: emacs
15:44:58 <Philippa> lispy: can it be made to typecheck under 6.8 with additional signatures?
15:45:02 <dolio> faxathisia: Ah, okay. I might just send an e-mail to the list in that case.
15:45:14 <gwern> > kill ghost; Your attack passes harmlessly through the ghost.
15:45:14 <lambdabot>  Parse error at ";" (column 11)
15:45:25 <gwern> gah!
15:45:44 <lispy> Philippa: I don't know.  The time I tried it, it failed to unify some things, told me to report it to GHC HQ if I wanted it to unify.  So I asked droundy about it, he told me that stuff about 6.6 vs. 6.8 vs. 6.10 and I let it be.
15:46:07 * dolio goes to dinner.
15:46:20 <nornagon> well i'm thinking of dabbling with a roguelike in haskell
15:46:28 <lispy> Philippa: there are very few places in the darcs code that don't have type signatures already.
15:46:33 <nornagon> possibly a multiplayer one, so i can learn how to write nice servers
15:46:59 <lispy> Philippa: all top level module definitions must have them, and as we switch to our existential type witnesses we are required to add them to get the higher rank type checking to work.
15:47:02 <dons> lispy, has anyone ever run the test coverage tool -fhpc on darcs?
15:47:28 <faxathisia> nornagon: You could write a terminal emulator with SDL or something
15:47:43 <lispy> dons: I don't think so.  Have you bene following the buildbot threads?  I'm sure it could be integrated into that process, or perhaps even better.  Make tests in the test suite that depend on it.
15:47:51 <faxathisia> nornagon: use texture mapped quads for letters
15:47:52 <gwern> a rogue-like, really?
15:47:57 <gwern> nornagon: have you seen mage?
15:48:20 <dons> lispy: or, i was thinking, we just compile darcs with -fhpc and run the testsuite
15:48:23 <dons> then look at the graphs
15:48:25 <lispy> dons: I don't know what the output of hpc is, but potentially, the test for a feature could run and require that a specific module have x% coverage.
15:48:38 <nornagon> faxathisia: i thought about that
15:48:41 <dons> you could add that,  yep
15:48:41 <nornagon> faxathisia: i intend to do it
15:48:46 <nornagon> faxathisia: but not right now :)
15:49:01 <nornagon> gwern: no
15:49:06 <lispy> dons: I'm worry about other features of darcs at the moment, but that is always something in the back of my mind that I would love to start analyzing.
15:49:12 <dons> lispy: it looks like this, http://code.haskell.org/~dons/tests/pcre-light/hpc_index.html
15:49:20 <gwern> nornagon: oh. it's a rogue-like, obviously, you should look at it
15:49:27 <lispy> dons: my current task is getting more type checking into the core of darcs so that maintenance is easier
15:49:48 <lispy> dons: nice
15:49:50 <dons> i could probably do the -fhpc build pretty simply, i think
15:49:56 <dons> might be useful feedback to david
15:50:06 <nornagon> gwern: how do i googled for it.
15:50:14 <lispy> dons: yeah, it would be really appreciated i'm sure
15:50:38 <nornagon> obviously googling for 'mage roguelike' is not so useful.
15:50:50 <gwern> nornagon: http://haskell.org/haskellwiki/Applications_and_libraries/Games <-- doesn't have my modifications for making it compile under 6.8, obviously
15:51:00 <osfameron> wooo, xmonad is rather interesting
15:51:12 <dons> osfameron: oh?
15:51:32 <osfameron> dons: in a good way, mainly :-)
15:51:40 <dons> i agree
15:51:42 <osfameron> dons: (I'm not very familiar with this kind of window manager)
15:51:57 <dons> enjoy!
15:51:58 <UJustLostTheGame> Someone explain ST to me
15:51:59 <UJustLostTheGame> :P
15:52:03 <osfameron> dons: hehe, I will do
15:52:06 <UJustLostTheGame> oh looky i still have this name on
15:52:07 * shepheb cuddles sweet, sweet xmonad
15:52:16 <mauke> UJustLostTheGame: ST gives you mutable variables
15:52:24 <mauke> like IO limited to IORefs
15:52:27 <dons> UJustLostTheGame: ST lets you encapsulate mutable state inside a pure computation
15:52:35 <sarehu> and IOArrays/STArrays
15:52:43 <dons> with a guarantee the mutation isn't visible outside the runST
15:52:56 <osfameron> I'd like an out-of-the-box dzen config, but I guess that's hard with the different architectures it will run on
15:52:57 <nornagon> ugh, mage has its own curses bindings packaged...
15:53:10 <dons> osfameron: check the DynamicLog extension
15:53:13 <osfameron> (cos I don't really want to play with tweaking xmonad, just with having it worky)
15:53:31 <osfameron> dons: will do... though that sounds very much like tweaking :-)
15:53:35 <dons> tweaking the config file is pretty easy. just follow the docs :)
15:53:48 <gwern> nornagon: I know, crazy huhu
15:54:09 <byorgey> import XMonad.Hooks.DynamicLog ;  main = dzen xmonad   -- as out-of-the-box as it gets =)
15:54:22 <dons> couldn't be simpler :)
15:54:32 <mauke> pfft, that's a lame status bar
15:54:52 <dons> the status bar of champions!
15:55:13 <UJustLostTheGame> Damn you can't write coerce :: a -> b with STRefs
15:55:13 <UJustLostTheGame> :)
15:55:16 <UJustLostTheGame> and runST
15:55:21 <mauke> o rly
15:55:23 <ddarius> Of course not.
15:55:38 <ddarius> You can't write unsafeCoerce without some unsafe operations.
15:55:55 <UJustLostTheGame> Sure. But :P
15:55:59 <UJustLostTheGame> Gotta try!
15:56:04 <dons> hehe
15:56:15 <faxathisia> how would you write coerce with STRefs?
15:56:17 <dons> damn type system making code safe
15:56:25 <drigz> is a segfault in ghc generated code always a ghc bug? (if i'm not using non-standard stuff)
15:56:40 <dons> drigz: yep. if its not using the FFI
15:56:49 <mauke> http://img219.imageshack.us/img219/8172/screenshotia5.png <- THIS is a status bar
15:56:49 <nornagon> drigz: and if you're not using unsafePerformIO
15:56:52 <dons> before reporting, to a full clean rebuild
15:56:53 <nornagon> and friends
15:56:53 <drigz> dons: how do i go about pinning it down and reporting it?
15:57:00 <dons> nornagon: which is part of the ffi
15:57:04 <nornagon> oh
15:57:08 <nornagon> fair enough :)
15:57:11 <drigz> :( os x, i got ghc working once and hoped never to have to think about it again
15:57:16 <osfameron> dons: which documentation?  The configuring section on the site takes me straight to API docs
15:57:16 <dons> drigz: try to reduce it to the smallest example
15:57:20 <dons> and try to reproduce it
15:57:38 <dons> osfameron: yes, the api docs have lovely examples of exactly what to add to your config file
15:57:41 <drigz> i'm using 6.6 atm so i'll need to upgrade
15:57:45 <dons> there's also a broad overview of how to configure
15:57:55 <dons> see the 'Documentation' page in the api docs
15:58:13 <dons> drigz: oh, perhaps try 6.8.2's .dmg (if you're on intel)
15:58:21 <osfameron> dons: ah, ok.  yes it tells you which file to edit.  I was confused by the page looking like a javadoc (which quite regularly fail to give any information at all :-)
15:58:43 <drigz> wow, back in my day you had to use ports :D
15:58:44 <UJustLostTheGame> who was working on a smalltalk in haskell?
15:58:49 <nornagon> ugh, i remember why i hate ncurses now: colours. :(
15:58:56 <byorgey> osfameron: those are generated by haddock.  and us xmonad developers take pride in including useful information in them =)
15:59:27 <faxathisia> @fresh
15:59:27 <lambdabot> Hask
15:59:34 <nornagon> @help fresh
15:59:34 <lambdabot> fresh provides: freshname
15:59:37 <byorgey> o.O
15:59:39 <nornagon> @freshname
15:59:39 <lambdabot> Hasl
16:00:04 * byorgey wonders what faxathisia has been up to behind our backs
16:00:08 <dmwit> It's an extremely predictable pattern.
16:00:22 <dmwit> ...o man
16:00:25 <faxathisia> It's really been a productive day for me.. :P
16:00:30 <dmwit> It starts at Haa, doesn't it?
16:00:55 <drigz> dons: thanks, i'll get back to you when i try with 6.8
16:00:58 <dmwit> > 1*26*26+19*26+11
16:01:03 <gwern> odd. the scambda google code links to an empty subversion repo
16:01:04 <lambdabot>  1181
16:01:13 <nornagon> @index FiniteMap
16:01:13 <lambdabot> Data.FiniteMap, Data.Graph.Inductive.Internal.FiniteMap
16:01:17 <drigz> on the upside, it's only 71 lines of code atm, so if it is a bug :D
16:01:26 <dmwit> faxathisia: You sat there and sent ?fresh to \bot over 1000 times??
16:01:40 <faxathisia> dmwit, I lost count at 7812
16:01:43 <nornagon> hrm. Could not find module `Data.FiniteMap' from trying to build mage on 6.8.1...
16:02:05 <gwern> nornagon: I did say you needed to do a bit of editing efore it worked with 6.8...
16:02:07 <mauke> old module is old
16:02:14 <nornagon> gwern: yeah :/
16:02:18 <nornagon> where is it these days?
16:02:38 <gwern> finitemap was replaced by just map wasn't it?
16:02:51 <UJustLostTheGame> hmm
16:02:55 <UJustLostTheGame> can you call lambdabot commands from inside >?
16:02:57 <gwern> nornagon: oh, FiniteMap itself is on hackage
16:02:59 <byorgey> @remember faxathisia <faxathisia> @fresh  <lambdabot> Hask
16:02:59 <lambdabot> Done.
16:03:12 <gwern> > :t head
16:03:12 <lambdabot>   parse error on input `:'
16:03:13 <dmwit> UJustLostTheGame: Nope, but try using @@.
16:03:17 <nornagon> gwern: but i ought to be able to just replace it with Map, yeah?
16:03:18 <dmwit> ?help @@
16:03:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:03:24 <dmwit> ?help @
16:03:24 <lambdabot>  @ [args].
16:03:24 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
16:03:24 <lambdabot>  The commands are right associative.
16:03:24 <lambdabot>  For example:    @ @pl @undo code
16:03:24 <lambdabot>  is the same as: @ (@pl (@undo code))
16:03:30 <gwern> nornagon: don't think so. names and sigs changed
16:03:40 <nornagon> ah :/
16:03:52 <faxathisia> @brain
16:03:52 <lambdabot> I think so, Brain, but we're already naked.
16:04:03 <gwern> @brain
16:04:04 <lambdabot> I think so, Brain, but a codpiece made from a real fish would get smelly after a while, wouldn?t it?
16:04:13 <dmwit> @@ @eval "@brain"
16:04:15 <gwern> @quote brain
16:04:15 <lambdabot> Pseudonym says: The Scheme programming language is optimised for writing small brain-dead tutorial compilers for.
16:05:16 <drigz> dons: do you happen to know how i use the binary packages?
16:05:21 <faxathisia> @@ @elite @quote gwern
16:05:21 <lambdabot>  g\/\/eRN zaY$: <Jph0u7z> iz (|EAN 7YpeD? <Gw3Rn> I h34r sOM3 pE0PLE DIC747E dOwN 7H3ir C13An proGrAMz0rz +|-|roUg|-| VoiCE r3(09nitiOn PrOGRaMS
16:05:28 <dons> drigz: the .dmg package?
16:05:41 <dons> google for an email from manuel chakravarty announcing the dmg
16:05:43 <dons> and how to use it
16:06:08 <gwern> anyone know if scambda '
16:06:13 <gwern> A pure functional implementation of Scrabble(R) written in Haskell. ' ever releaed any code?
16:06:29 <drigz> dons: ok, thanks. i was looking at the release page
16:06:38 <dons> gwern: wow
16:06:45 <nornagon> oh, geeze, hscurses is being odd: unknown symbol `hs_curses_color_pair'
16:06:47 <dons> gwern: it rings a bell
16:07:03 <dons> nornagon: that's a macro on some systems
16:07:05 <gwern> the google code is empty, and googling doesn't turn up anything
16:07:10 <nornagon> dons: ah :/
16:07:18 <dons> see what i do in hmp3 for this
16:07:22 <dons> its wrapped in some cbits
16:07:45 <oklopol> do haskell implementations often memoize functions?
16:07:50 <dons> nope
16:07:55 <dons> its very memory intensive
16:08:14 <ddarius> I'm not aware of any implementation that memoizes functions.
16:08:14 <oklopol> hmm... kinda hard to do memoization explicitly...
16:08:17 <dons> you should plan to memoise explicitly with a data structure, such as a list
16:08:31 <oklopol> basically, i need to find heights in an acyclic graph
16:08:38 <ddarius> f = memo f' is too hard?
16:09:02 <oklopol> ddarius: that exists?
16:09:03 <faxathisia> what is the type memo?
16:09:52 <oklopol> memo doesn't exist as such
16:10:05 <faxathisia> (a -> b) -> a -> b
16:10:18 <dmwit> It exists in a mailing list post somewhere.
16:10:20 <faxathisia> ?djinn (a -> b) -> a -> b
16:10:20 <lambdabot> f a = a
16:10:21 <UJustLostTheGame> @hpaste
16:10:22 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:10:35 <faxathisia> I don't see how it can memoize
16:10:35 <UJustLostTheGame> @help @@
16:10:35 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:10:41 <Saizan> ((a -> b) -> a -> b) -> a -> b, with some constraint on "a" depending on the table.
16:10:47 <ddarius> You can make one.  A "pure" one would use a type class.  I also think Hugs (and GHC?) had a built-in one at some time.
16:10:58 <dmwit> http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737
16:11:00 <lambdabot> Title: Gmane -- Mail To News And Back Again
16:11:39 <hpaste>  ehird pasted "foo, bar, and bazz" at http://hpaste.org/6112
16:11:49 <faxathisia> very nice..
16:11:57 <dmwit> Yes indeed.
16:14:44 <drigz> dons: works with latest ghc. thanks for all the help!
16:14:54 <dons> sweet
16:15:18 <Saizan> but i like to do dynamic programming without a memoizing table when possibile, too bad it's not that elegant
16:15:20 <dmwit> ehird`: It's not clear to me what you're trying to do.
16:15:59 <faxathisia> Saizan, in haskell, do you have any examples at hand?
16:15:59 <dmwit> Saizan: What's the technique for table-less DP?
16:17:36 <Saizan> dmwit: to order your computation so that you consume values as you produce them
16:18:20 <dmwit> Saizan: Oh.  But then, can it be adapted to places where DP really shines, i.e. where you produce once but consume multiple times?
16:19:47 <Saizan> faxathisia: the classical let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs !! n is a trivial one, modulo some strictness so that earlier elements can really be garbage collected and don't end in a thunk
16:20:18 <ehird> i think i came up with an algorithm for strictifing haskell
16:20:27 <ehird> if rand(0,1) > 0.7 insert a "#"
16:20:37 <nornagon> @index finally
16:20:37 <lambdabot> Control.Exception, Distribution.Compat.Exception
16:20:47 <dmwit> ehird: heh
16:20:51 <Saizan> dmwit: well, it can
16:21:03 <ehird> @hoogle (Monad m) => m a -> a
16:21:07 <lambdabot> Prelude.id :: a -> a
16:21:07 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
16:21:08 <dmwit> ehird: Well, that's certainly an algorithm, though I'm not convinced yet that it's sound and correct. =P
16:21:09 <lambdabot> Data.Function.id :: a -> a
16:21:11 <ehird> runX :-P
16:21:15 <gwern> nornagon: I think I'm going to try to port mage to hscurses tonight. its ncurses binding seems to be a subset of hscurses's
16:21:24 <Saizan> dmwit: you may still need a "buffer" instead of the full table
16:21:25 <ehird> dmwit: it seems to produce output looking like micro-optimized strikell
16:21:58 <dmwit> Saizan: hm
16:24:38 <oklopol> what's wrong with let max = foldl1 (\ a b -> if a>b then a else b)
16:25:04 <dmwit> :t foldl1
16:25:13 <oklopol> > foldl1 (\ a b -> if a>b then a else b) [1,2,3]
16:25:19 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
16:25:20 <lambdabot>  3
16:25:25 <oklopol> > let max = foldl1 (\ a b -> if a>b then a else b) in max [1,2,3]
16:25:26 <lambdabot>  3
16:25:29 <oklopol> whut
16:25:30 <dmwit> Nothing?
16:25:47 <oklopol> okay, must be command line issue
16:25:48 <ehird> @karma+ lambdabot
16:25:48 <lambdabot> lambdabot's karma raised to 2.
16:25:48 <dmwit> oklopol: There *is* a Prelude "maximum", though.
16:25:55 <dmwit> :t maximum
16:25:59 <lambdabot> forall a. (Ord a) => [a] -> a
16:26:19 <oklopol> figured there would be, but thought that's so trivial it's easier to write it myself than find the name
16:26:26 <faxathisia> a `max` b | a > b = a | othewise = b
16:26:34 <oklopol> was wrong, it seems, but wasn't my own fault
16:26:53 <oklopol> > 2 `max 4
16:26:53 <lambdabot>  Parse error at "4" (column 8)
16:26:55 <oklopol> > 2 `max` 4
16:26:58 <lambdabot>  4
16:27:00 <oklopol> oh.
16:27:04 <oklopol> so just...
16:27:07 <Saizan> oklopol: you got bitten by the monomorphism restriction
16:27:08 <nornagon> @index max
16:27:08 <lambdabot> Prelude
16:27:15 <nornagon> :t max
16:27:15 <faxathisia> @let a `max` b | a > b = a | othewise = b
16:27:16 <lambdabot> <local>:1:24: Not in scope: `othewise'
16:27:16 <lambdabot> forall a. (Ord a) => a -> a -> a
16:27:18 <oklopol> > let m = foldl1 max in m [1,2,3]
16:27:19 <lambdabot>  3
16:27:21 <faxathisia> @let a `max` b | a > b = a | otherwise = b
16:27:21 <nornagon> @src max
16:27:22 <lambdabot> Defined.
16:27:22 <lambdabot> max x y = if x <= y then y else x
16:27:29 <faxathisia> hmmm
16:27:40 <faxathisia> I think the if_then_else_ version is better
16:27:42 <nornagon> gwern: hscurses' "CursesStyle" thing scares me
16:28:13 * dmwit Curses Style
16:28:29 <dmwit> It's so expensive to look good these days!
16:28:50 <gwern> nornagon: I approve of higher level layers...
16:29:02 <ehird> @type or
16:29:02 <lambdabot> [Bool] -> Bool
16:29:06 <ehird> err
16:29:08 <ehird> @type (||)
16:29:09 <lambdabot> Bool -> Bool -> Bool
16:29:17 <nornagon> gwern: what's wrong with init_pair :(
16:29:18 <ehird> oh, duh
16:30:59 <nornagon> also, i can't seem to get hscurses to actually *do* anything, due to aforementioned missing symbol
16:31:24 <ehird> isn't hscurses dedd?
16:31:45 <ehird> @hoogle (Monad m) => (m a) -> a
16:31:46 <lambdabot> Prelude.id :: a -> a
16:31:46 <lambdabot> Unsafe.Coerce.unsafeCoerce :: a -> b
16:31:46 <lambdabot> Data.Function.id :: a -> a
16:31:51 <ehird> hoogle is dum.
16:31:53 <nornagon> that's what i thought, but gwern uploaded something march 3, so i guess not :)
16:33:59 <dmwit> ehird: No it isn't, there is no function as general as what you're asking for.
16:34:21 <faxathisia> What (m a) -> a?
16:34:28 <dmwit> ehird: Some monads have functions that do that *for their instance of Monad*, but there are some that don't.
16:34:31 <faxathisia> :t fromMaybe
16:34:34 <lambdabot> forall a. a -> Maybe a -> a
16:34:34 <faxathisia> :t head
16:34:35 <lambdabot> forall a. [a] -> a
16:34:39 <ehird> dmwit: Yes. Hoogle should be able to find those ones.
16:34:40 <mauke> dmwit: that's unrelated to hoogle's dumness
16:34:42 <faxathisia> :t fromJust
16:34:43 <lambdabot> forall a. Maybe a -> a
16:34:43 <faxathisia> oops
16:34:46 <ehird> :-)
16:34:54 <faxathisia> there are some ehird
16:34:54 <ehird> It should be able to specificy-erize types!
16:35:06 <faxathisia> You should fix hoogle :P
16:35:17 <faxathisia> I think someone else is
16:35:21 <ehird> I am lazii.
16:35:22 <dmwit> ?hoogle Maybe a -> a
16:35:23 <lambdabot> Data.Maybe.fromJust :: Maybe a -> a
16:35:23 <lambdabot> Data.Maybe.fromMaybe :: a -> Maybe a -> a
16:35:23 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
16:35:25 <ehird> Plural laziness.
16:35:34 * dmwit specificy-erizes ehird's type
16:35:44 <dmwit> ;-)
16:35:56 <ehird> I thought this channel was family-friendly
16:35:56 <dons> ?babel en de hello mr. bot
16:35:56 <lambdabot>   hallo Herr bot
16:35:59 <nornagon> ow, my polymorphism :(
16:37:43 <Philippa> ehird: ...more so than it used to be, perhaps
16:37:59 <ddarius> This channel was family friendly?
16:38:44 <roconnor> @yow
16:38:45 <lambdabot> MMM-MM!!  So THIS is BIO-NEBULATION!
16:39:02 <ehird> Philippa: #haskell-xxx
16:39:29 <faxathisia> :O
16:39:54 <dmwit> It's empty. =(
16:40:06 <nornagon> dons: hrm, hscurses seems to do what you do, except it uses #def inline [stuff]
16:40:22 <MyCatVerbs> This channel is family-friendly, at least to the extent that nothing that won't offend one's labmates & colleagues won't usually destroy a child's innocence either.
16:43:51 <ehird> [00:42] *** faxathisia sets the channel topic to "HOT HOT POLYMORPHIC ON GENERALIZED ALGEBRAIC TYPE ACTION, IN A NON-PURE, UNSAFELY UNBOXED MONAD!!!!!".
16:43:58 <ehird> that's what I'm talkin' about!!!!!!
16:44:40 <faxathisia> ehird: I think you scared everyone :P
16:45:50 <ehird> all the countless kids in this channel have gone into therapy
16:45:52 <ehird> there's nobody left
16:46:17 * johnnowak dumps core
16:46:35 <nornagon> okay, yay, i have a patch to fix hscurses
16:47:24 <Philippa> MyCatVerbs: I know I've said things in here that'd be held to destroy at least some kids' innocence before now
16:47:28 <Philippa> and since -blah split off, too
16:49:02 <nornagon> http://nornagon.net/hscurses-nomacro-getcolorpair.patch
16:49:35 <nornagon> how can i put up a NMU?
16:51:02 <ehird> > fresh
16:51:04 <lambdabot>   Not in scope: `fresh'
16:51:08 <dmwit> ?fresh
16:51:08 <lambdabot> Havv
16:51:11 <ehird> no lambdabot-> interaction
16:51:11 <ehird> :(
16:51:14 <ehird> wait
16:51:19 <faxathisia> @fresh
16:51:19 <lambdabot> Havw
16:51:20 <faxathisia> @fresh
16:51:21 <lambdabot> Havx
16:51:36 <faxathisia> bad habit to start..
16:51:37 <ehird> i want to call @fresh until it returns one before Haskell
16:51:38 <ehird> :P
16:51:57 * allbery_b wonders who got "Hask"
16:52:16 <dmwit> ?quote \<Hask\>
16:52:17 <lambdabot> faxathisia says: <faxathisia> @fresh  <lambdabot> Hask
16:52:23 <faxathisia> I could have done 'Hack' but I thought that  was lame
16:52:52 <EvilTerran> we'll get to "haxx" fairly sool
16:52:54 <EvilTerran> n
16:53:01 <lament> what does @fresh do?
16:53:10 <EvilTerran> @help fresh
16:53:10 <lambdabot> fresh provides: freshname
16:53:13 <ehird> lament: returns name, and succeeds it
16:53:15 <EvilTerran> @help freshname
16:53:15 <lambdabot> freshname. Return a unique Haskell project name.
16:53:31 <ehird> i could write a script that @fresh's until it becomes Haskell-1
16:53:34 <faxathisia> :S
16:53:36 <dmwit> > 1*26^5 + 19*26^4 + 11*26^3 + 5*26^2 + 12*26^1 + 12*26^0
16:53:39 <faxathisia> @@ @fresh @fresh @fresh @fresh @fresh @fresh @fresh @fresh
16:53:39 <lambdabot> Plugin `compose' failed with: Unknown command: "fresh"
16:53:42 <lambdabot>  20760960
16:54:16 <dmwit> ehird: ...20 million @fresh's later, you'd likely be banned from the network.
16:54:21 <lament> ehird: are they base-26?
16:54:25 <dmwit> Assuming \bot didn't go down at all in that time.
16:54:39 <dmwit> ?fresh
16:54:39 <lambdabot> Havz
16:54:41 <dmwit> ?fresh
16:54:41 <lambdabot> Hawa
16:54:46 <dmwit> There you have it. =)
16:54:56 <wagle_home> ?rotten
16:54:56 <lambdabot> Unknown command, try @list
16:55:01 <ddarius> dmwit: You just need a botnet to do it.
16:55:31 <nornagon> ChilliX: boo :)
16:56:57 <ehird> dmwit: well sure :p
16:57:09 <ehird> botnet sounds  good
16:57:13 <lament> how did we get to "Hawa" already?
16:57:15 <ehird> we need an open-source botnet, distributed
16:57:22 <ehird> lament: it will have started Has
16:57:23 <ehird> or something
16:57:25 <lament> oh
16:57:27 <ehird> Probably Haaa
16:57:35 <ehird> anyone can add a botnet node
16:57:36 <lament> boring!
16:57:41 <ehird> and badly-behaving nodes are kicked by other nodes
16:57:42 <ehird> :D
16:58:43 <nornagon> so, erm, i want to upload this tiny hscurses patch to hackage
16:59:25 <nornagon> but i'm not sure of the conventions
16:59:30 <MyCatVerbs> Philippa: oh, really? I hadn't noticed.
16:59:50 <kfish> nornagon, have you sent it to the maintainers?
16:59:54 <nornagon> i bumped the version number to 1.2.1... but do you do this sort of thing for a 3-line patch?
17:00:15 <nornagon> kfish: the last upload was a nmu... i think the maintainers dropped it long ago
17:00:25 <ehird> nornagon: I would add another dot to the end
17:00:25 <ehird> :P
17:00:32 <nornagon> the copyright in there is 2005 at latest
17:00:42 <nornagon> Stefan Wehr has taken the project off his website
17:00:48 <nornagon> he's listed as the maintainer.
17:00:53 <kfish> nornagon, version numbering is usually up to the maintainers
17:00:56 <dons> you can ask him about it. he's very happy to open source things
17:00:59 <MyCatVerbs> Philippa: mind-blowing speech in here is so rare, though. Has a better likelihood of merely getting their neurons exploded by all the heavy maths here than of getting their neurons exploded by anything innocence-removing.
17:01:03 <ehird> 'funny Oxymorons' ~an oxymoron database
17:01:37 * wagle_home dies laughing
17:01:55 <dons> foxy morons
17:02:21 <SamB> so, has anyone set up a hashed mirror of GHC?
17:02:25 <ehird> that database also has 'Microsoft' as an entry
17:02:28 <ehird> just 'Microsoft', on its own
17:02:40 <SamB> because, if not, I'll do it
17:02:42 <kfish> nornagon, usually the right thing to do is to send a minimal patch which just solves the problem, with an explanation
17:02:50 <nornagon> send to where?
17:03:01 <nornagon> http://nornagon.net/hscurses-nomacro-getcolorpair.patch is the patch
17:03:04 <kfish> nornagon, if the repo is set up properly, you can 'darcs commit' and 'darcs send'
17:03:08 <MyCatVerbs> ehird: perhaps they're referring specifically to the "micro" part of the name, in relation to recently released products?
17:03:19 <nornagon> oh... i guess patching against darcs would be clever :p
17:03:20 <SamB> kfish: that's "darcs record"
17:03:29 <kfish> SamB, yow!
17:03:30 <nornagon> ... if there's a darcs repo, that is :|
17:04:00 * kfish has been doing dirty C coding recently ;-)
17:04:02 <ehird> MyCatVerbs: somehow, I doubt it
17:04:09 <nornagon> darcs failed:  Failed to download URL http://www.stefanwehr.de/darcs/hscurses/_darcs/inventory : HTTP error (404?)
17:04:14 <nornagon> ^- :<
17:04:34 <ehird> 'G.W.Bush' is also an entr.
17:04:36 <MyCatVerbs> ehird: not willing to give them the benefit of the doubt?
17:04:37 <ehird> Again, on its own.
17:04:42 <MyCatVerbs> ehird: ah, never mind then.
17:05:10 <ehird> So is 'animals'
17:05:16 <ehird> So is 'no words'
17:05:23 <nornagon> and http://www.informatik.uni-freiburg.de/~wehr/darcs/hscurses/ is 403
17:05:40 <lament> looks like hscurses is thoroughly bitrotten
17:05:44 <ehird> (And 'poop'. And 'qwvWtsEnFEsX', 'QUlRKfEWanqxYRGMBoU', 'high speed internet')
17:05:51 <nornagon> so i'm not really hopeful about any active maintenance here
17:06:13 <MyCatVerbs> ehird: that last one would be plausible to anyone who'd never been to a university.
17:06:34 <kfish> nornagon, perhaps you should send it to libraries@haskell.org then
17:06:35 * faxathisia recommends not using curses :/
17:06:45 <nornagon> faxathisia: not helpful, really
17:06:58 <nornagon> faxathisia: since vty is dead, and there's no slang binding
17:07:05 <nornagon> and i don't really feel like hacking sdl right now
17:07:25 <nornagon> and SDL's not really a solution anyway
17:07:33 <kfish> nornagon, does this all mean you've got haskell going on your DS? ;-)
17:07:40 <nornagon> heh
17:07:41 <nornagon> i wish
17:07:51 <SamB> is there a darcs2 on monk.galois.com (darcs.haskell.org)?
17:07:57 <nornagon> i think ghc's rts is too big; the ds only has 4M ram
17:08:08 <nornagon> but nhc98 might be worth a shot
17:08:08 <faxathisia> nornagon: wanna finish my half done terminal curses/slang like thing in C then bind to it, (it uses curses as the backend)
17:08:17 <SamB> nornagon: or Yhc?
17:08:21 <faxathisia> nornagon: It might be easier but you'd have to write some C
17:08:53 <nornagon> faxathisia: a wrapper over curses? why is that useful?
17:09:05 <nornagon> SamB: does that have an arm target?
17:09:16 <SamB> nornagon: it has bytecode...
17:09:40 <SamB> I'm sure it's not hard to get a VM working on ARM
17:10:03 <nornagon> speed is pretty vital when you need to get 60fps on a 66mhz processor.
17:10:14 <SamB> hmm.
17:11:25 <Philippa> nornagon: there're ways and means when it comes to doing stuff quickly in high level languages though
17:11:31 <Philippa> I mean, most of the rendering's array bashing still
17:11:35 <ehird> random q:
17:11:40 <ehird> if i take a function as an argument to a function
17:11:41 <ehird> a -> a
17:11:53 <ehird> is there a way to guarantee that the function is literally 'a -> a'?
17:11:58 <ehird> not 'MoreSpecific -> MoreSpecific'
17:12:13 <nornagon> Philippa: array bashing in bytecode not so fun :)
17:12:20 <nornagon> i guess you'd want some ffi
17:12:22 <Philippa> ehird: forall a. a -> a
17:12:30 <ehird> oh, is that what that does
17:12:32 <ehird> :-)
17:12:38 <EvilTerran> it's an extension, mind
17:12:39 <Philippa> nornagon: if you've got the right ops it doesn't have to be so bad, but yeah
17:12:50 <EvilTerran> -XRankNTypes, i believe
17:13:57 <SamB> @tell ndm I'm abusing your account on darcs.haskell.org to mirror GHC's repo in hashed format ... I hope
17:13:57 <lambdabot> Consider it noted.
17:14:04 <ehird> cool, that woprks :D
17:15:33 <MyCatVerbs> Philippa: "ways and means" implies black voodoo. Or should I just be thinking of lots of careful unboxing?
17:15:43 <ChilliX> nornagon: ??
17:16:37 <sorear> nornagon: you're welcome to take vty over :P
17:16:57 <MyCatVerbs> sorear: vty still works well enough for yi, though.
17:16:57 <Philippa> MyCatVerbs: that or a little FFI work and a lot of carefully used HOFs
17:17:06 <nornagon> ChilliX: I emailed you the other day
17:17:13 <dons> hey sorear, long time no see.
17:17:19 <nornagon> sorear: what needs doing?
17:18:57 <sorear> nornagon: figure out some nice functional way for the application to hint what parts of the screen need diffing, like the way curses has drawing commands
17:19:45 <nornagon> eh? which drawing commands would you be talking about?
17:19:51 <sorear> nornagon: frustration with that is 80% of what made me abandon vty... (performance is quite competitive in benchmarks where the whole screen changes every time)
17:20:14 <sorear> nornagon: mvputch, mvputstr, and a ton of obscure ones nobody uses
17:20:24 <Philippa> sorear: you mean dirty rectangles? That's nearasdammit pointless for 3D work and a bugger to make work fast enough given complicated enough 2D and typical hardware
17:20:34 <MyCatVerbs> Philippa: I thought there were fairly large overheads incurred when invoking the FFI? And I have no clue how proper HOF usage speeds things up.
17:20:37 <nornagon> sorear: oh right, yes
17:20:44 <nornagon> sorear: vty doesn't have those?
17:20:46 <Philippa> (if the DS can pull mode X-style scrolling tricks that's different)
17:20:51 <nornagon> <.<
17:20:53 <sorear> nornagon: correct
17:20:58 <faxathisia> Philippa: It's cuboids in 3D :S
17:21:07 <faxathisia> frustum culling.. space partitioning..
17:21:33 <ehird> #
17:21:37 * nornagon grabs the vty repo
17:21:38 <sorear> Philippa: You mean that in the real world people just redraw the whole thing every time?  That seems more than a little suboptimal for an editor situation, eg editing one line
17:21:39 <hpaste>  happyhacker pasted "compilerOpts problem" at http://hpaste.org/6113
17:21:41 <happyhacker> Hi
17:21:43 <Philippa> MyCatVerbs: you can do a lot about the overheads if you're careful with marshalling. HOFs help because they're your loops
17:21:45 <happyhacker> can someone help me on this?
17:21:50 <Philippa> sorear: games != editors
17:22:04 <happyhacker> I just can't get the initialized options list
17:22:11 <SamB> it's not like it's going to waste bandwidth or anything
17:22:21 <nornagon> @where vty
17:22:21 <lambdabot> darcs get http://members.cox.net/stefanor/vty/
17:22:26 <Philippa> and your typical modern PC has graphical horsepower to spare on the desktop, too
17:23:11 <happyhacker> I followed the haddock example, but would like to access the record of my commandline parameters properly
17:23:12 <Philippa> GPUs can blit billions of pixels a second for you
17:23:42 <Philippa> (not that /everything/ gets redrawn typically, it's not worth the paint messages - but things're increasingly sloppy)
17:23:59 <MyCatVerbs> Philippa: oh okay, fair enough. I thought HOFs were a touch expensive because of the indirection (hopping through function pointers, after all) involved?
17:24:12 <Philippa> MyCatVerbs: inlining is your friend
17:24:34 <Philippa> what you'll tend to get in practice with optimisation on is a bit different
17:24:38 <MyCatVerbs> Philippa: ohhhh, handy. Thanks.
17:25:32 <MyCatVerbs> Philippa: so are these combinators implemented in particularly efficient ways or summat?
17:25:41 <Philippa> you can also do HOF-like things with external chunks of code if you're in that kind of mood. It's not unheard of on hardware where it might matter to generate the code on the fly from pre-existing chunks...
17:26:08 <Philippa> (sadly, I believe this is happening a lot on the Mac still in the GPU drivers)
17:26:35 <Philippa> MyCatVerbs: strictness + tail calls leave you writing something surprisingly low level
17:26:35 <MyCatVerbs> It sounds like targetting something like a DS, you'd be best off by far with a whole-program optimizer, IMO.
17:26:57 <Philippa> I mean, CPS as an intermediate language is (modulo the GCed heap that's typical) lower-level than C
17:27:14 <happyhacker2> Would someone please be so kind to help me?
17:27:29 <faxathisia> happyhacker2: What's up?
17:27:46 <happyhacker2> I'm building a small program to parse some commandline options
17:27:52 <happyhacker2> which will be stored in a record
17:28:06 <dons> ok. are you using System.Console.GetOpt, or some other parser for the command line?
17:28:10 <MyCatVerbs> happyhacker2: this is #haskell, it's constantly full of computer science students looking for an excuse to procrastrinate away from their research and/or coursework. of course!
17:28:12 <SamB> Philippa: currently they use LLVM for this
17:28:16 <Philippa> MyCatVerbs: ultimately, don't expect to get quite that good from Haskell - but you can go a long way with a bit of work
17:28:17 <happyhacker2> GetOpt
17:28:19 <SamB> Philippa: is that a bad thing to do ?
17:28:29 <Philippa> SamB: last I heard they were still integrating it, but that was a while back admittedly
17:28:29 <happyhacker2> faxathisia, http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html#4
17:28:31 <faxathisia> happyhacker2: I used GetOpt once, worked ok..
17:28:32 <lambdabot> http://tinyurl.com/yyvufm
17:28:36 <lally> MyCatVerbs: holy crap you read my mind
17:28:39 <happyhacker2> I took this, but I just can't get to my record
17:28:46 <Philippa> from what I heard LLVM was a *big* improvement on what'd evolved before
17:28:52 <happyhacker2> code is located over here: http://hpaste.org/6113
17:29:03 <SamB> yeah, LLVM is pretty nice ;-)
17:29:08 <happyhacker2> It seems to do most of the trick, but I just don't get the record-magic
17:29:36 <Philippa> anyway, I've got to go to bed
17:29:46 <MyCatVerbs> Philippa: *blinkblink*. CPS being lower-level than C, makes sense now that you mention it but it'd never occurred to me before.
17:29:51 <MyCatVerbs> Philippa: pleasant dreams.
17:30:08 <ddarius> MyCatVerbs: CPS is related to SSA form.
17:30:16 <faxathisia> happyhacker: Something like.. optVerbose, just means that a function called that exists which takes that field, (So it's type is Options -> Bool)
17:30:46 <MyCatVerbs> ddarius: they're isomorphic, I'm told?
17:31:23 <happyhacker_> faxathisia, okay but  how to access the record properly ? In my own defined function (printOpts) it does not have the default values
17:31:24 <SamB> I thought it was tail-calling and SSA that were isomorphic
17:31:29 <sorear> Strictness + tail calls is way worse than C.  I'd be more inclined to liken it to old school BASIC, with line numbers and conditional gotos
17:32:05 <SamB> sorear: it is worse than C you think?
17:32:11 <lally> Anyone know a good source to get working with arrays?
17:32:34 <SamB> well, it's still nicer to write than SSA
17:32:38 <faxathisia> Don't the defaults go in OptDescr?
17:32:56 <happyhacker_> Well according to the example in Haddock, not
17:33:05 <sorear> SamB: yes
17:33:06 <faxathisia> happyhacker, let me show you something.. I used this example to figure out getopt
17:33:09 <dons> lally: Data.Array, or do you just want lists?
17:33:16 <sorear> SamB: I will take while loops over labels any day
17:33:33 <dogbite> I'm having trouble using QuickCheck: it's telling me that the it can't find fromInt
17:33:39 <dogbite> I understand that function is outdated
17:33:44 <dogbite> but what's the latest?
17:33:49 <SamB> fromIntegral
17:33:55 <dons> fromIntegral.
17:33:56 <SamB> but you are using an old QuickCheck
17:34:00 <dons> fromInt is pre-haskell98!
17:34:06 <SamB> use the modern one
17:34:08 <dogbite> where's the latest quickcheck? :-/
17:34:13 <dons> ?hackage QuickCheck
17:34:13 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/QuickCheck
17:34:18 <lally> dons: donno.  I'll be starting from an identity matrix and adding to it, from 13 GB of data
17:34:29 <dons> lally: ok, perhaps use hmatrix then?
17:34:36 <dons> what type of data?
17:34:55 <dons> 13G suggests to me you'll need a lazy structure
17:34:57 <dogbite> lally: i happened to ask a very similar question just a few hours ago!
17:35:01 <lally> pointwise visibliity.  like "(3.2 1.2 0) YES (1.2 3 2)"
17:35:28 <dons> perhaps start by sucking in the data in a lazy bytestring, and processing it in some way
17:35:34 <faxathisia> happyhacker: Check this out, http://www.cs.chalmers.se/~ulfn/darcs/Agda2/src/hTags/Main.hs
17:35:35 <lally> a function would apply to the pair of points (and the bool) and give a matrix to add to my current tally
17:35:36 <dons> to get a feel for how 13G can be managed
17:35:47 <happyhacker_> ill have a look
17:36:13 <faxathisia> happyhacker: see how defaultOptions is used, in the getOptions bit
17:36:14 <lally> does a lazy bytestring let me pull out data line-by-line?
17:36:28 <SamB> lally: sure
17:36:29 <happyhacker_> yes i see
17:36:54 <happyhacker_> faxathisia, can you tell me whether my printOpts function actually is correct?
17:37:01 <happyhacker_> faxathisia, which is over here
17:37:02 <happyhacker_> http://hpaste.org/6113
17:37:02 <lally> so how'd I combine all the intermediate matrices lazily?
17:37:51 <lally> I'm scanning hmatrix right now
17:37:58 <faxathisia> :t optVerbose
17:38:02 <lambdabot> Not in scope: `optVerbose'
17:38:13 <faxathisia> oh I see
17:38:16 <happyhacker_> it on the hpaste :)
17:38:35 <faxathisia> happyhacker: no, I'm pretty sure that's wrong
17:38:54 <happyhacker_> Okay thanks, can you tell me how to do the record stuff
17:38:54 <happyhacker_> ?
17:38:57 <faxathisia> happyhacker: because shouldn't it take as a parameter, ops :: Options and do like, print opts
17:38:58 <faxathisia> ?
17:39:11 <happyhacker_> yes I see
17:39:16 <happyhacker_> That's my second question
17:39:22 <faxathisia> :t print
17:39:23 <lambdabot> forall a. (Show a) => a -> IO ()
17:39:34 <faxathisia> happyhacker, print at the end has return ()
17:39:43 <faxathisia> so you can remove return (), if you like
17:39:44 <happyhacker_> ah stupid
17:39:48 <happyhacker_> true
17:39:53 <happyhacker_> but there's something more to ask:
17:40:03 <happyhacker_> the compilerOpts returns IO (Options, [String])
17:40:12 <happyhacker_> And the main function should use the Options result
17:40:25 <happyhacker_> how to do so, I don't understand the IO (Options,[String]) 'type'
17:40:29 <faxathisia> well then, using do notation, you can extract like
17:40:52 <faxathisia> do (opts, str) <- compilerOpts <something>
17:41:00 <faxathisia>    now you can use opts :: Options
17:41:00 <happyhacker_> ah fsck
17:41:04 <happyhacker_> that's easy
17:41:07 <faxathisia> do you know this notation?
17:41:10 <happyhacker_> have been looking for this quite some time
17:41:23 <happyhacker_> yes, now you're telling me to do so... i'm banging my head on my desk
17:41:42 <faxathisia> > do (x,y) <- return (9,7) ; return (x+y)
17:41:44 <lambdabot>   add an instance declaration for (Show (t t1))
17:41:47 <faxathisia> :L
17:41:55 <faxathisia> well it works something like that
17:42:03 <happyhacker_> thanks man :)
17:42:16 <happyhacker_> i'm going to update (and hopefully) fix the code :)
17:42:17 <mauke> > do (x,y) <- return (9,7) ; return (x+y) :: Maybe Integer
17:42:19 <lambdabot>  Just 16
17:42:32 <faxathisia> > (do (x,y) <- return (9,7) ; return (x+y)) :: [Int]
17:42:33 <lambdabot>  [16]
17:42:38 <mauke> > ( do (x,y) <- return (9,7) ; return (x+y) ) ()
17:42:39 <lambdabot>  16
17:42:43 <mauke> :-)
17:42:47 <faxathisia> oh clever
17:43:12 <hpaste>  morrow annotated "adjunctions" with "refinement" at http://hpaste.org/6060#a6
17:43:16 <lally> Ok, hMatrix looks way over my head for this... the resulting array isn't very big (100x200)
17:43:22 <ehird> mauke: whoa how does that work
17:43:26 <ehird> @type ( do (x,y) <- return (9,7) ; return (x+y) ) ()
17:43:27 <lambdabot> forall t. (Num t) => t
17:43:33 <ehird> o.O
17:43:37 <ehird> is that like ... Identity monad?
17:44:06 <happyhacker_> faxathisia, still one last question: what's wrong with accessing the record ?
17:44:18 <lally> I'd like to lazily read in each line, parse it, and update a temp matrix to the result.
17:44:25 <mauke> ehird: no, (...) () is function application
17:44:28 <lally> Without the I/O monad, simple tail recursion
17:44:31 <mauke> the monad is (->) ()
17:44:37 <happyhacker_> because I'm getting a: 1.hs:48:21: Empty record update
17:44:54 <ehird> mauke: (->) monad?!
17:44:57 <faxathisia> I don't know what that means
17:44:58 <ehird> where's THAT defined?!
17:45:04 <ehird> @src Monad (->)
17:45:04 <lambdabot> Source not found. Maybe if you used more than just two fingers...
17:45:06 <ehird> @src Monad (->) ()
17:45:07 <lambdabot> Source not found. Maybe you made a typo?
17:45:12 <SamB> @instances Monad
17:45:14 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:45:25 <SamB> try Control.Monad.Reader.Instances
17:45:38 <hpaste>  happyhacker_ pasted "updated commandline-thingie" at http://hpaste.org/6114
17:45:39 <SamB> or is that just C.M.Instances?
17:45:46 <lally> With it, I have no idea how to structure this.
17:45:51 <faxathisia> @src (->) (>>=)
17:45:51 <lambdabot> f >>= k = \ r -> k (f r) r
17:45:55 <faxathisia> @src (->) (return)
17:45:55 <lambdabot> Source not found. :(
17:45:56 <happyhacker_> faxathisia, just updated my code, and that error is being spawned when accessing the print functin
17:46:02 <SamB> lally: take the computation out of IO
17:46:11 <SamB> that is, write a function that isn't of an IO type
17:46:18 <SamB> and call it from IO
17:46:33 <lally> SamB: Ok, how do I keep it lazy?
17:46:52 <SamB> just pass it your lazybytestring
17:47:05 <faxathisia> happyhacker, Try to have it like, replace optVerbose(opt{}) with print opt
17:47:16 <happyhacker_> ahh okay
17:47:23 <ehird> @src (->) return
17:47:23 <lambdabot> return = const
17:47:27 <faxathisia> happyhacker, because Options has a Show instance you can use that
17:47:28 <lally> SamB: that's so straightforward.  I'm an idiot :-)
17:47:31 <happyhacker_> but how to access just specific fields of the record?
17:47:38 <faxathisia> @src print
17:47:38 <lambdabot> print x = putStrLn (show x)
17:47:41 <SamB> lally: not really
17:47:46 <happyhacker_> in the near future, I'd like to just get the boolean value
17:47:53 <faxathisia> happyhacker, optVerbose opt
17:47:58 <happyhacker_> instead of the boolean + string +int
17:48:04 <happyhacker_> ah okay
17:48:04 <hpaste>  gotenhan pasted "lista1" at http://hpaste.org/6115
17:48:07 <SamB> an idiot would require more explanation
17:48:10 <SamB> and still never get it
17:48:16 <faxathisia> happyhacker, because like I said those names just say, such a function  named optVerbose exists..
17:48:28 <faxathisia> happyhacker, and that it selects the Bool out
17:48:32 <SamB> I should know; I see my fair share in ##c
17:48:35 <happyhacker_> ahh okay
17:48:52 <lally> SamB: thanks.  Ok, I'm off to try!  Thanks!!
17:52:48 <jsnx> so, say i want to parse some data, and while i'm parsing it, print some stuff
17:52:56 <jsnx> i need monad transformers for that, right?
17:53:05 <mauke> yes, ParserT IO
17:53:45 <SamB> or you could use some kind of combination of a parser monad and a writer monad...
17:53:54 <mauke> "Haskell is the world's leading purely fictional programming language."
17:54:19 <SamB> mauke: you are making up monads?
17:54:37 <mauke> sort of
17:54:47 <SamB> are you implementing them?
17:55:04 <mauke> yeah, I have an implementation of ParserT lying around somewhere
17:55:39 <faxathisia> jsnx, If the parser is lazy
17:56:29 <happyhacker_> faxathisia, hope this is my last question. It's about the the do statement to get the opts from compilerOpts' result: 	opts= (do (opts',_) <- compilerOpts args; return opts')()
17:56:29 <happyhacker_>  
17:56:48 <happyhacker_> what's going wrong, GHC borks about the =, although I cloned your example
17:57:46 <dogbite> okay great i got the latest QuickCheck installed
17:57:59 <faxathisia> Don't do it like that
17:58:11 <happyhacker_> I know, otherwise it would compile ;)
17:58:13 <faxathisia> you shouldn't have ()
17:58:14 <dogbite> I wrote my first property and got a problem though related to the Show type
17:58:30 <dogbite>     No instance for (Show ([[MarrayVal Int]] -> Bool))
17:58:30 <dogbite>       arising from use of `print' at <interactive>:1:0-14
17:58:30 <dogbite>     Possible fix:
17:58:30 <dogbite>       add an instance declaration for (Show ([[MarrayVal Int]] -> Bool))
17:59:11 <happyhacker_> faxathisia, does not matter to GHC
18:00:05 <happyhacker_> the do statement is not the first line of my main function btw
18:01:58 <EvilTerran> gesundheit mr brown
18:04:46 <nornagon> gr, nhc98 won't compile for me :(
18:10:35 <nornagon> eek.
18:11:06 <happyhacker_> faxathisia, did you just give me solution or hint? (I don't want to be rude, but I've missed quite some messages I'm afraid)
18:11:09 <mauke> http://hackage.haskell.org/packages/archive/QuickCheck/1.1.0.0/doc/html/Test-QuickCheck.html
18:11:12 <lambdabot> http://tinyurl.com/2rzgpv
18:11:28 <TomMD> ?users
18:11:28 <lambdabot> Maximum users seen in #haskell: 463, currently: 425 (91.8%), active: 7 (1.6%)
18:11:42 <eyeris> Can someone here point me too the documentation for Text.Regex 0.93? That is the version that is packaged with Debian but the package doesn't seem to come with any documentation. http://www.haskell.org/ghc/docs/latest hosts the docs for 0.72.0.1
18:11:42 <lambdabot> Title: Index of /ghc/docs/latest
18:12:30 <mauke> @index transpose
18:12:30 <lambdabot> Data.List
18:12:31 <EvilTerran> ?where regex
18:12:31 <lambdabot> I know nothing about regex.
18:12:36 <EvilTerran> ?where data.regex
18:12:36 <lambdabot> I know nothing about data.regex.
18:12:47 <eyeris> ?where Text.Regex
18:12:47 <lambdabot> I know nothing about text.regex.
18:12:53 <eyeris> ?where Text.Regex.Posix
18:12:53 <lambdabot> I know nothing about text.regex.posix.
18:12:58 <wagle_home> @go regex
18:12:58 <lambdabot> http://en.wikipedia.org/wiki/Regular_expression
18:12:58 <lambdabot> Title: Regular expression - Wikipedia, the free encyclopedia
18:13:03 <wagle_home> @ho regex
18:13:04 <lambdabot> Maybe you meant: hoogle hoogle+ . ? @ bf echo ft ghc id pl rc show thx v wn yow
18:13:16 <wagle_home> @hoogle regex
18:13:16 <lambdabot> No matches found
18:13:22 <nornagon> i don't think nhc98 likes ghc-6.8.2 :(
18:13:26 <wagle_home> @index regex
18:13:26 <lambdabot> bzzt
18:13:27 <faxathisia> happyhacker no
18:13:31 <wagle_home> oh well
18:13:59 <EvilTerran> er, yes, quite. text.regex, not data.regex. somone'd just said that, too
18:14:00 <happyhacker_> faxathisia, too bad
18:14:02 * EvilTerran pokes his brain
18:16:35 <bparkis> java's lack of multiple dispatch means you have to do "pattern matching" using the kludgy visitor pattern
18:17:50 <SamB> bparkis: that's actually just like our fold pattern
18:18:19 <wagle_home> multiple dispatch?
18:18:25 <SamB> well, almost
18:18:44 <bparkis> i don't know what the fold pattern is... the visitor pattern is just a way to simulate multiple dispatch, haskell wouldn't need it
18:19:05 <nornagon> yay, i got nhc98 to compile :)
18:19:24 <nornagon> required adding -package packedstring and -package containers to the build
18:20:54 <bparkis> basically if you want to process an abstract syntax tree in java, instead of using something like pattern matching you use visitors which requires adorning the AST classes with an extra method
18:21:20 <bparkis> boilerplate
18:21:58 <SamB> bparkis: I'm versed in the pattern
18:22:10 <bparkis> ok
18:22:11 <SamB> I've read about it on WikiWikiWeb
18:22:47 <SamB> possibly seen it in Python programs
18:22:52 <hpaste>  happyhacker_ pasted "working commandline parser" at http://hpaste.org/6116
18:22:54 <happyhacker_> faxathisia, i got it to compile. Thanks a lot for the help.
18:25:19 <pkazmier> how do I load a package when starting ghci?  I wanted to test some functions in MissingH library but can't figure out how to load it.
18:25:39 <mauke> :m +Some.Package
18:28:29 <dogbite> Just to report back, I'm not using a 'quickCheck' command line utility.
18:28:31 <dogbite> i'm calling the quickCheck function from ghci or
18:28:33 <dogbite> from my program file
18:28:33 <dogbite> The links at the bottom of the Wikipedia page for QuickCheck were helpful
18:28:46 <pkazmier> oh, I was referring to the new module names for MissingH vs the old ones.
18:28:46 <pkazmier> thanks!
18:29:29 <SamB> dogbite: did you get the one from hackage yet?
18:30:05 <dogbite> yes, i downloaded the latest code from hackage
18:30:25 <dogbite> for some reason google doesn't point to the latest quickcheck stuff
18:30:32 <dogbite> i ended up going down a very stale path
18:31:39 <SamB> well, until recently quickcheck was included with GHC
18:31:58 <lally> how would I go about converting an L.ByteString to a String ?
18:32:20 <dcoutts> lally: unpack
18:32:36 <lally> hmm, I keep getting [Word8]
18:32:56 <lally> which unpack should I use? Data.ByteString.Lazy's unpack?
18:33:04 <EvilTerran> D.BS.Char8, perhaps?
18:33:27 <dcoutts> lally: the .Char8 modules provide a Char8 view of a bytestring
18:33:49 <dcoutts> lally: there are .Char8 variations for strict and lazy bytestrings
18:34:17 <dcoutts> the .Char8 modules use the same underlying type they just give a Char8 rather than Word8 view of the type
18:34:37 <lally> ohh
18:37:00 <faxathisia> :t ( pack , unpack )
18:37:07 <lambdabot> Not in scope: `pack'
18:37:07 <lambdabot> Not in scope: `unpack'
18:38:02 <lally> ok, switching to Lazy.Char8 really helped
18:38:18 <lally> hey, btw, how do I clean this up?
18:38:25 <lally> Prelude.filter isJust (Prelude.map parseDataPoint (unpacked (allLines lines) ))
18:38:34 <lally> specifically, all the Prelude.s and the parens
18:38:50 <mauke> :t catMaybes
18:38:51 <lambdabot> forall a. [Maybe a] -> [a]
18:39:13 <mauke> :t mapMaybe
18:39:14 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
18:39:38 <mauke> mapMaybe parseDataPoint (unpacked $ allLines lines)
18:39:48 <faxathisia> @src mapMaybe
18:39:48 <lambdabot> Source not found. :(
18:39:59 <faxathisia> :t catMaybes . map
18:40:00 <lambdabot>     Couldn't match expected type `[Maybe a]'
18:40:00 <lambdabot>            against inferred type `[a1] -> [b]'
18:40:00 <lambdabot>     Probable cause: `map' is applied to too few arguments
18:40:08 <faxathisia> :t ((.).(.)) catMaybes map
18:40:09 <lambdabot> forall a a1. (a1 -> Maybe a) -> [a1] -> [a]
18:40:16 <faxathisia> ok makes sense
18:40:43 <lally> nice
18:40:48 <Excedrin> @src Data.Maybe.mapMaybe
18:40:48 <lambdabot> Source not found. Just try something else.
18:40:52 <Excedrin> o k
18:41:15 <faxathisia> I'd like a symbol to use instead of ((.).(.))
18:41:31 <lally> ok, but this is giving me a type error, of all the things!
18:41:33 <lally> parseFile :: L.ByteString -> [DataPoint]
18:41:37 <lally> main  = do
18:41:46 <lally> whoops...
18:41:53 <lally> main = do print parseFile L.readFile "fake_input.txt"
18:42:12 <mauke> lally: print takes one argument, not three
18:42:33 <dons> main = do print . parseFile =<< L.readFile "fake_input.txt" -- maybe?
18:42:37 <dons> hard to say without  the types
18:42:59 <mauke> faxathisia: 
18:43:05 <dogbite> i'm building a data management tool and would like to share a little bit of the design and maybe get some thoughts
18:43:10 <dogbite> this project is my first one in haskell
18:43:15 <faxathisia> catMaybes  map
18:43:17 <dogbite> so i'm still learning best practices, etc
18:43:21 <dons> dogbite: great! ask away
18:43:21 <faxathisia> :D
18:43:26 <dons> also good to raise it on the list
18:43:36 <lally> wonderful!  that ran perfectly!
18:43:44 <dons> lally: hehe
18:43:47 <dogbite> so the general concept is that there will be vectors or matricies of numbers
18:43:55 <dogbite> think of it like a spreadsheet
18:44:08 <dogbite> so it tends to be column-oriented
18:44:12 <nornagon> > let () = ((.).(.))
18:44:12 <lambdabot>  Illegal character ''\136''
18:44:12 <lambdabot>  at ")" (column 7)
18:44:16 <dons> lally: also, bytestrings love ghc -O2 (compiled with optimisations)
18:44:16 <nornagon> aw.
18:44:22 <nornagon> Prelude Data.Maybe> :t catMaybes  map
18:44:22 <nornagon> catMaybes 4 map :: (a1 -> Maybe a) -> [a1] -> [a]
18:44:24 <dogbite> with data under teh same column being of some general type
18:44:25 <mauke> main = do x <- L.readFile "fake_input.txt"; print (parseFile x)
18:44:33 <nornagon> ^- ghci prints '4'? :/
18:44:45 <dogbite> maybe one type could be "temperature"
18:44:49 <dogbite> and anotehr could be "weight"
18:44:51 <dogbite> or "price"
18:45:03 <mauke> nornagon: bug!
18:45:04 <lally> mauke: ah, ok, that's where the <<= went
18:45:07 <dogbite> so by type i don't mean the numeric type, although they all could be floats in that case
18:45:18 <dino-_> dons: Did you get an mkcabal patch from me via email recently?
18:45:26 <dons> dino-_: ah yes, i think so.
18:45:28 <mauke> <interactive>:1:10: Not in scope: `4'
18:45:29 <dogbite> one consideration is that some values might be missing
18:45:31 <dino-> I'm fearing the email... ah
18:45:33 <dogbite> such as missing measurements
18:45:39 <dons> dogbite: they'd probably be represented by Nothing/Just a
18:45:40 <lally> hey, how can I express an array as an existing array with certain values incremented?
18:54:25 <nornagon_> unf
18:55:22 --- mode: irc.freenode.net set +o ChanServ
18:55:46 <mauke> toNumsVec = catMaybes
18:55:46 <dogbite> \?
18:55:46 <faxathisia> :t catMaybes
18:55:46 <faxathisia> catMaybes :: [Maybe a] -> [a]
18:55:47 <dogbite> how do i turn off these exit and enter notifications in irc
18:55:47 <dogbite> i'm sorry -- so new
18:55:47 <mauke> depends on your client
18:55:47 <dogbite> irssi
18:55:47 <dogbite> so catMaybes will filter out the Nothing
18:55:48 <mauke> /ignore * JOINS PARTS QUITS
18:55:48 <dogbite> thanks!
18:55:50 <lambdabot> forall a. [Maybe a] -> [a]
18:56:00 <dolio> "I've made a domain specific notation for describing puddings."
18:57:00 * faxathisia hopes you can encode proofs in it..
18:57:04 <wli> @type map fromJust . filter isJust
18:57:05 <lambdabot> forall a. [Maybe a] -> [a]
18:57:09 <dogbite> okay so what you're suggesting is
18:57:24 <dogbite> that i define a type Price = Float
18:57:31 <dogbite> and then have Just Price
18:57:36 <faxathisia> Maybe Price
18:57:43 <faxathisia> Just is a value
18:57:43 <dogbite> ah yes Maybe Price
18:57:48 <faxathisia> Maybe is a type constructor
18:57:56 <dogbite> so when I define my functions... right now I'm having to quality the 'a' as a Num
18:58:04 <dogbite> (Num a) => ...
18:58:12 <dogbite> that will still work for Price?
18:58:12 <faxathisia> You don't need to type that
18:58:39 <faxathisia> dogbyte: Haskell can figure out the type of functions
18:58:56 <dogbite> yeah i ran into some type errors
18:59:02 <dogbite> but maybe they will go away
18:59:05 <brad_larsen> just out of curiousity, does anyone know why [0..] is acceptable but [..10] is not?
18:59:13 <mauke> {-# OPTIONS_GHC -fno-monomorphism-restriction #-}
18:59:22 <mauke> brad_larsen: because lists have a beginning
18:59:28 <dogbite> i put that at the top?
18:59:36 <dino-> I have a cabal question. I'm trying to get something sdist-able and I'd like to have it include a testsuite/ dir everything under it.
18:59:43 <dino-> How do you do that, it's not 'data' per-se and it's not additional src modules with real dotted module names.
18:59:59 <mauke> dogbite: in case the dreaded monomorphism restriction bites you, yes. but I don't think that's likely
19:00:01 <faxathisia> > [10,9,..]
19:00:01 <lambdabot>  Parse error at "..]" (column 7)
19:00:05 <faxathisia> > [10,9..]
19:00:16 <dino-> Is it me or is it a little bit labor intensive when darcs dist is basically the fileset I want on Hackage.
19:00:17 <dogbite> okay thank you for that tip.  now, for my 'Maybe' type, i had defined
19:00:18 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-...
19:00:19 <dino-> ?
19:00:28 <dogbite> instance (Num a) => Show (MarrayVal a) where show (MissingVal)   = "X" show (PresentVal n) = show n
19:00:38 <brad_larsen> mauke: heh, suppose so.  i was getting tripped up i guess by thinking of natural numbers or something similar, where there is some ``start'' value
19:00:41 <dogbite> because when i print out my matrices or vectors
19:00:58 <mauke> http://neilmitchell.blogspot.com/2008/02/adding-data-files-using-cabal.html
19:00:59 <dogbite> I want the blanks to print as an 'X'
19:01:00 <brad_larsen> > [10, 8..]
19:01:00 <lambdabot>  [10,8,6,4,2,0,-2,-4,-6,-8,-10,-12,-14,-16,-18,-20,-22,-24,-26,-28,-30,-32,-3...
19:01:10 <lambdabot> Title: Com.org - Only the best links ..., http://tinyurl.com/364awx
19:01:49 <brad_larsen> > [10, 8.., 0..]
19:01:49 <lambdabot>  Parse error at "," (column 9)
19:02:14 <gwern> http://www.anime-source.com/banzai/images/articles/suzumiya/haruhi01.jpg <-- is that orange or yellow?
19:02:18 <gwern> mischan
19:02:39 <brad_larsen> mauke: thank you
19:03:05 <dogbite> any tips on how i override the show function
19:03:12 <dogbite> for this Maybe type so that the Just values
19:03:16 <dogbite> are printed out as 'X'
19:03:20 <faxathisia> dogbite, Don't do it
19:03:27 <mauke> make a new function
19:03:37 <faxathisia> dogbite, Write a dedicated present function that isn't show
19:03:43 <dogbite> okay
19:03:50 <dogbite> any best practice names for that type of function?
19:04:10 <jsnx> @hoogle [m a] -> m [a]
19:04:11 <lambdabot> Prelude.head :: [a] -> a
19:04:11 <lambdabot> Prelude.last :: [a] -> a
19:04:11 <lambdabot> Data.List.head :: [a] -> a
19:04:23 <byorgey> myTotallySweetFunctionWhichIsDifferentThanShow
19:04:25 <faxathisia> dogbite, I would call it present
19:04:28 <dino-> mauke: Thank you.
19:04:29 <byorgey> that's what I use at least
19:04:43 <faxathisia> dogbite, but your judgement is probably better since it's your code
19:04:44 <jsnx> byorgey: that is a good name
19:04:53 <byorgey> jsnx: thanks
19:05:23 <dogbite> present sounds good to me
19:05:45 <dogbite> maybe i can alias it to myorgey's
19:05:58 <faxathisia> heheh
19:06:07 <dogbite> is there a good function for printing a list of lists
19:06:10 <dogbite> in a pretty fashion
19:06:22 <wli> mapM_ print?
19:06:40 <Pseudonym> dogbite: If you want something fancy, consider using Text.PrettyPrint.HughesPJ.
19:07:24 <faxathisia> > let l = [1,2,3,4] in show . concat . zipWith ($) (interate (++" ")) l
19:07:26 <lambdabot>   Not in scope: `interate'
19:07:30 <faxathisia> > let l = [1,2,3,4] in show . concat . zipWith ($) (iterate (++" ")) l
19:07:30 <lambdabot>  Couldn't match expected type `[a -> b]'
19:08:06 <mauke> > intercalate " " . map show $ [1,2,3,4]
19:08:06 <lambdabot>  "1 2 3 4"
19:09:52 <mgsloan> > unwords . map show $ [1..4]
19:09:53 <lambdabot>  "1 2 3 4"
19:10:20 <faxathisia> > let l = [1..] in concat $ zipWith (++) (iterate (++" ") "") (map show l)
19:10:21 <lambdabot>  "1 2  3   4    5     6      7       8        9         10          11       ...
19:10:32 <sarehu> > ("[ "++) . (++" ]") . intercalate "\n  " . map (unwords . map show) $ [[i..i+3] | i <- [1..4]]
19:10:33 <lambdabot>  "[ 1 2 3 4\n  2 3 4 5\n  3 4 5 6\n  4 5 6 7 ]"
19:11:01 <sarehu> > ("[ "++) . (++" ]") . intercalate "\n  " . map (('[':) . (++"]") . unwords . map show) $ [[i..i+3] | i <- [1..4]]
19:11:02 <lambdabot>  "[ [1 2 3 4]\n  [2 3 4 5]\n  [3 4 5 6]\n  [4 5 6 7] ]"
19:11:23 <BMeph> src (,) fmap
19:12:09 <SamB> okay, does anyone know the guidelines for the distinction between use and abuse of darcs.haskell.org?
19:12:12 <dogbite> sarahu is stepping it up!
19:12:26 <byorgey> > let l = [[1,2,3],[4,5,6,7],[8,9]] in render $ text "[" $$ nest 2 (vcat $ map (text . show) l) $$ text "]"
19:12:27 <lambdabot>  "[ [1,2,3]\n  [4,5,6,7]\n  [8,9]\n]"
19:13:42 <nornagon_> @index vcat
19:13:43 <lambdabot> Language.Haskell.TH.PprLib, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
19:13:47 <nornagon_> @index nest
19:13:47 <lambdabot> Language.Haskell.TH.PprLib, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
19:14:55 <faxathisia> > let l = [1..] in concat $ zipWith (flip ((++) . show)) (map concat $ map (flip replicate " ") [1..]) l
19:14:57 <lambdabot>  "1 2  3   4    5     6      7       8        9         10          11       ...
19:16:38 <byorgey> > let l = [[1,2,3],[4,5,6,7],[8,9]]; pprL l = brackets $ hsep (map (text . show) l) in render $ text "[" $$ nest 2 (vcat $ map pprL l) $$ text "]"
19:16:39 <lambdabot>  "[ [1 2 3]\n  [4 5 6 7]\n  [8 9]\n]"
19:17:14 <dogbite> @sum
19:17:14 <lambdabot> Maybe you meant: bug run src
19:17:22 <byorgey> Text.PrettyPrint.HughesPJ ftw! =)
19:17:50 <byorgey> dogbite: what are you trying to do?
19:18:11 <faxathisia> @src sum
19:18:11 <lambdabot> sum = foldl (+) 0
19:18:14 <faxathisia> > sum [1..]
19:18:20 <lambdabot> Terminated
19:18:31 <nornagon_> <lambdabot> lots
19:18:34 <dogbite> Prelude Data.Maybe> :t sum catMaybes
19:18:34 <dogbite> <interactive>:1:4:
19:18:34 <dogbite>     Couldn't match expected type `[a]'
19:18:34 <dogbite>            against inferred type `[Maybe a1] -> [a1]'
19:18:34 <dogbite>     In the first argument of `sum', namely `catMaybes'
19:19:00 <dogbite> those are the type of errors i was getting before i think
19:19:25 <dogbite> oh oh oh
19:19:27 <dogbite> i got it
19:19:30 <ac> has anybody else read this?
19:19:32 <ac> http://math.ucr.edu/home/baez/rosetta/rose2.pdf
19:19:41 <byorgey> dogbite: sum . catMaybes ?
19:19:47 <byorgey> @type sum . catMaybes
19:19:48 <dogbite> ya, thanks byorgey
19:19:51 <lambdabot> forall a. (Num a) => [Maybe a] -> a
19:19:52 <byorgey> dogbite: =)
19:20:25 <faxathisia> > sum . catMaybes $ [Just 3, Nothing, Just 7, Nothing]
19:20:40 <mauke>  10
19:20:41 <lambdabot>  thread killed
19:20:48 <dogbite> mauke is quick!
19:20:50 <dogbite> ha
19:21:00 <BMeph> bzzt
19:22:13 <nornagon> ugh
19:22:17 <nornagon> i can't post to any nhc lists
19:22:34 <wagle_home> :t sum . catMaybes $ [Just 3, Nothing, Just 7, Nothing]
19:22:35 <lambdabot> forall a. (Num a) => a
19:22:55 <wagle_home> @djinni forall a. (Num a) => a
19:23:06 <dogbite> when you all code, do you document the type signature?
19:23:19 <faxathisia> dogbite: No
19:23:30 <cjb> dogbite: you mean, provide a fun :: foo -> bar line?
19:23:35 <cjb> or further documentation?
19:23:36 <faxathisia> dogbite: The only types I have in are when they are more descriptive than the function body
19:25:19 <mauke> I write type signatures for all top-level definitions
19:25:30 <SamB> Igloo: do you know how often the ghc repository gets pushed into?
19:25:32 <Eelis> what mauke said.
19:26:05 <ac> That paper is titled "Physics, Topology, Logic, and Computation: A Rosetta Stone"
19:26:21 <faxathisia> why mauke?
19:26:30 <mauke> faxathisia: because otherwise I get compiler warnings
19:27:02 <faxathisia> odd.
19:27:07 <Eelis> i do it because it helps me understand the code when i look at it a while after having written it.
19:27:17 <faxathisia> do you use a lot of typeclasses?
19:27:26 <mauke> Eelis: yeah, that too
19:27:43 <mauke> in many cases I write the type signature first
19:27:57 <mauke> with a stub 'foo = undefined' body for testing
19:28:48 * faxathisia sometimes writes code in ghci
19:28:49 <dibblego> @pl any . (not .)
19:28:49 <lambdabot> any . (not .)
19:28:57 <faxathisia> It's good to see what types are around while you edit
19:31:13 <glen_quagmire> i never write type signatures until compiler complains
19:31:29 <faxathisia> heh don't let the compiler boss you around
19:31:45 <Pseudonym> I write type signatures, that way the compiler complains earlier.
19:31:51 <mauke> just use unsafeCoerce
19:31:52 <Pseudonym> I like it when the compiler complains.
19:31:54 <dogbite> fromNumsMat :: [[a]] -> [[(Maybe a)]]
19:32:04 <faxathisia> I don't understand I never got these complaints from the compiler
19:32:23 <glen_quagmire> i don't like the fact that a function can have a value and a type only.
19:32:37 <glen_quagmire> a function should be a dictionary of many arbitrary things
19:32:50 <faxathisia> Eq a => [(a,b)]
19:32:58 <mauke> what is this ad-hockery
19:33:24 <glen_quagmire> then hasekll will be object oriented
19:33:44 <mauke> lambda calculus is pure OO
19:33:46 <faxathisia> glen_quagmire: What you described is not like objects at all
19:33:49 <Eelis> faxathisia: try -Wall
19:33:52 <dogbite> Prelude Data.Maybe> :t map (map (\x -> Maybe x))
19:33:56 <BMeph> glen_quagmire: And why in God's name would that be a plus? ;)
19:34:06 <dogbite> @type map (map (\x -> Maybe x))
19:34:08 <mauke> where object = function, message = object, message passing = function application
19:34:09 <lambdabot> Not in scope: data constructor `Maybe'
19:34:26 <mauke> :t map (map Just)
19:34:27 <lambdabot> forall a. [[a]] -> [[Maybe a]]
19:34:45 <faxathisia> dogbite: We have two programming languages here really
19:34:51 <faxathisia> dogbite:   values :: types
19:35:19 <dogbite> okay
19:35:32 <dogbite> i get confused because Maybe is both the name of the type
19:35:33 <faxathisia> dogbite: You can't mix them up, so Maybe (being in the Type language) can't be a value like \x -> Maybe x
19:35:35 <dogbite> and also the instance
19:35:38 <faxathisia> dogbite: No it's not
19:35:44 <dogbite> i mean
19:35:46 <dogbite> the constructor
19:35:54 <faxathisia> dogbite: Maybe a is a type
19:36:01 <BMeph> dogbite: No, it isn't. :)
19:36:02 <faxathisia> dogbite: Nothing, and Just x are values
19:36:06 <glen_quagmire> i don't think Maybe is contructor
19:36:10 <dogbite> oh!
19:36:10 <glen_quagmire> @index Maybe
19:36:11 <lambdabot> Data.Maybe, Prelude
19:36:12 <dogbite> Just
19:36:19 <faxathisia> glen_quagmire: It is a type constructor
19:36:20 <dogbite> argh, yes.
19:36:21 <mauke> Maybe is a type constructor, Just is a data constructor
19:36:25 <dogbite> now what if Maybe happened to be defined as
19:36:34 <dogbite> data Maybe = Nothing | Maybe a
19:36:36 <glen_quagmire> faxathisia: oh right
19:36:43 <mauke> dogbite: then you'd be right
19:36:45 <glen_quagmire> Nothing would be a value constructor
19:37:06 <glen_quagmire> again, two languages.  values :: types
19:37:15 <mauke> type 'a option = None | Some of 'a;;
19:37:15 <BMeph> Nothing _is_ a value constructor. :)
19:37:21 <dogbite> fromNumsMat  = map $ map Just
19:37:21 <faxathisia> dogbyte: That would be fine
19:37:24 <dogbite> hooray
19:37:37 <faxathisia> dogbyte: They live in different worlds so you don't have a name clash
19:37:53 <faxathisia> dogbyte: for example () is the name of a value, and () is its the type
19:37:55 <dogbite> okay i think i'm on board.  i got confused and was thinking the constructor was called Maybe
19:37:58 <glen_quagmire> types of values = type.  types of types = kind.
19:38:03 <faxathisia> dogbyte: (It's called unit and has a single inhabitant btw)
19:38:16 <glen_quagmire> why not munch them up together where everything is a type, value, kind...etc
19:38:29 <faxathisia> glen_quagmire: That's a fantastic idea
19:38:43 <faxathisia> glen_quagmire: Check out Coq, Agda 2 etc..
19:38:49 <glen_quagmire> i think that's curry howard isomorphism or something
19:39:05 <faxathisia> glen_quagmire: It's not but when you mix that in too you can do a lot
19:39:18 <agl> I have LANGUAGE MagicHash and import Data.Word, what else do I need to do to get W64#?
19:40:26 <mux> agl: I guess GHC.Word
19:40:29 <wy> hello~
19:41:17 <dogbite> okay i'm having an issue with the Num type again
19:41:22 <dogbite> i have that suggested string at the top
19:41:24 <dogbite> sumVec  :: [(Maybe a)] -> a
19:41:24 <dogbite> sumVec l  = sum $ catMaybes l
19:41:26 <mauke> Num is not a type :-)
19:41:36 <dogbite> oh.. Num is a class?
19:41:38 <dogbite> type class?
19:41:39 <mauke> yeah
19:41:46 <dogbite> okay -- right.
19:41:50 <faxathisia> [(Maybe a)] is the same as [Maybe a]
19:41:55 <agl> mux: ah, good point. Silly me, thanks.
19:41:55 <dogbite>     No instance for (Num a)
19:41:55 <dogbite>       arising from use of `sum' at HHData/Marray.hs:63:12-14
19:41:55 <dogbite>     Possible fix: add (Num a) to the type signature(s) for `sumVec'
19:42:04 <mauke> yeah, sum requires a Num instance
19:42:10 <faxathisia> dogbite: Remove the type annotation
19:42:15 <faxathisia> Just write
19:42:19 <faxathisia> sumVec = sum . catMaybes
19:42:22 <dogbite> k
19:42:29 <wagle> ac: havent read it, but it looks very interesting
19:42:30 <faxathisia> when you load the file you can go :t sumVec
19:42:33 <dogbite> that did it
19:42:34 <mauke> faxathisia: MONOMORPHISM RESTRICTION
19:42:35 <faxathisia> (if you are in ghci)
19:42:40 <faxathisia> mauke so what?
19:42:48 <wy> ?t catMaybes
19:42:48 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
19:42:49 <mauke> ;_;
19:42:53 <dogbite> i put that suggested flag at the top
19:43:02 <faxathisia> mauke, better to come up against and fix problems than ide
19:43:05 <faxathisia> hide*
19:43:06 <wy> @t catMaybes
19:43:06 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
19:43:14 <wy> :t catMaybes
19:43:14 <dogbite> {-# OPTIONS_GHC -fno-monomorphism-restriction #-}
19:43:14 <faxathisia> wy :t or @ty
19:43:19 <lambdabot> forall a. [Maybe a] -> [a]
19:43:19 <pjd> wy: @type, or :t
19:43:19 <dogbite> that's at the top of my file
19:43:25 <wy> faxathisia: bah. I forgot
19:43:27 <faxathisia> dogbyte, You should remove that
19:43:32 <SamB> @ask Igloo do you know how often the ghc repository gets pushed into?
19:43:32 <lambdabot> Consider it noted.
19:43:34 <faxathisia> wy, I reminded you :P
19:43:44 <dogbite> what does it do?
19:43:54 <wy> I didn't know there is a function in the library
19:43:55 <faxathisia> dogbyte, dunno, that's why you should get rid of it :P
19:44:08 <dogbite> oh but somebody just told me to put it up there, i was only following orders
19:44:21 <mauke> what
19:45:01 <mauke> not everything I write in this channel is an order for you to put it in your code
19:45:21 <dogbite> for sumVec, why is it not okay to define it as
19:45:22 <dogbite> sum $ catMaybes
19:45:28 <dogbite> why doesn't the currying work there
19:45:33 <dogbite> oh i got it
19:45:35 <dogbite> nevermind
19:45:37 <mauke> because ($) = id
19:45:42 <dogbite> because sum won't be able to process the curried input
19:45:47 <mauke> so that's equivalent to sum catMaybes
19:45:56 <mauke> and catMaybes is obviously not a list
19:46:16 <faxathisia> sum $ catMaybes l = sum $ (catMaybes l)
19:46:30 <mauke> you need some kind of suspension that tells it to wait for an input, then pass the filtered list to sum
19:46:32 <dogbite> got it i now have it as
19:46:35 <faxathisia> /= (sum $ catMaybes) l
19:46:37 <dogbite> sumVec l  = sum $ catMaybes l
19:46:43 <faxathisia> functions bind tighter than operators
19:46:45 <mauke> that suspension is .
19:47:01 <faxathisia> dogbite, didn't try: sumVec = sum . catMaybes -- ?
19:47:38 <wy> I have a question about covariance and contravariance. Is object pointer type covariant subtyping in C++ unsound for the same reason that covariant subtyping for array is unsound?
19:48:26 <dogbite> faxathisia: oh, right.  i see that.
19:48:31 <dogbite> i like that better
19:49:24 <mauke> wy: good question
19:49:50 <wy> mauke: actually I don't know both reasons :P
19:50:08 <dogbite> you guys are trimming down my code considerably!
19:50:13 <dogbite> i alrady removed an entire file
19:50:17 <mauke> dogbite: sorry :(
19:50:19 <dogbite> and cut the other one in half
19:50:38 <SamB> mauke: hmm, are you sure he is not happy?
19:50:57 <dogbite> my function to create a 2d list filled with the number 1
19:51:02 <dogbite> seems too complex
19:51:04 <mauke> we are destroying his precious works
19:51:14 <faxathisia> > replicate 10 $ replicate 10 $ 1
19:51:21 <lambdabot>  [[1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,1,1],[1,1,1,1,...
19:51:23 <SamB> helping him distill them!
19:51:31 <mauke> :t \n -> replicate n (replicate n 1)
19:51:31 <dogbite> ones    :: (Num a) => Int -> Int -> [[(Maybe a)]]
19:51:31 <dogbite> ones n m = [[Just 1 | y <- [0..(n-1)]] | x <- [0..(m-1)]]
19:51:32 <lambdabot> forall t. (Num t) => Int -> [[t]]
19:51:40 <wy> I looked up wikipedia for covariance and found the case of arrays. But I don't quite understand what it is saying about the remove operator
19:51:52 <faxathisia> > replicate 10 $ replicate 10 $ Just 1
19:51:53 <lambdabot>  [[Just 1,Just 1,Just 1,Just 1,Just 1,Just 1,Just 1,Just 1,Just 1,Just 1],[Ju...
19:51:56 <Cale> > let rectangle n m = replicate n . replicate m in rectangle 2 3 'a'
19:51:57 <lambdabot>  ["aaa","aaa"]
19:52:14 <mauke> :t \n m -> map Just . replicate n . replicate m $ 1
19:52:15 <lambdabot> forall a. (Num a) => Int -> Int -> [Maybe [a]]
19:52:15 <Cale> Don't abuse $ ;)
19:52:33 <dogbite> @type replicate
19:52:34 <lambdabot> forall a. Int -> a -> [a]
19:52:37 <wy> ...the remove operator is contravariant (e.g. one can remove an Object from an ArrayOf(String))...
19:52:43 <faxathisia> that's a lot more elegant
19:52:45 <dogbite> @src replicate
19:52:45 <lambdabot> replicate n x = take n (repeat x)
19:52:58 <faxathisia> I use haskell like sh for the first few weeks I was learning :S
19:53:52 <Cale> wy: If they were references and not pointers, then I would expect the subtyping to be covariant.
19:54:26 <wy> Cale: so do you think the problem is with multiple level of pointers?
19:54:30 <Cale> With the other pointer operations there, I'm not sure.
19:54:33 <Cale> hmm
19:54:41 <dolio> With pointers wouldn't you get problems indexing into the right parts of memory?
19:55:29 <Cale> wy: I think if there are any problems, they'll probably be with pointer arithmetic.
19:55:38 <dolio> superclassptr[1] would be different than subclassptr[1], because superclass and subclass might have different sizes.
19:55:48 <wy> dolio: suppose we don't have pointers as integers
19:56:00 <mauke> Cale: http://mauke.ath.cx/stuff/c++/inheritance-breaks-type-safety.cc
19:56:11 <Cale> If we can't do pointer arithmetic, then we just have references.
19:56:16 <Cale> So it should be covariant.
19:56:42 <dogbite> and the winner is....
19:56:43 <dogbite> ones n m = replicate m $ replicate n $ Just 1
19:57:05 <faxathisia> dogbite, you should see Cales one, It's much neater
19:57:17 * Cale would replace at least the first '$' with a '.' :) 
19:57:17 <faxathisia> more general too
19:57:40 <faxathisia> so you could write .. ones n m = rectangle n m $ Just 1
19:57:48 <dogbite> @type rectangle
19:57:51 <lambdabot> Not in scope: `rectangle'
19:57:54 <faxathisia> hwww.. ones n m = rectangle n m (Just 1)
19:58:03 <faxathisia> What's $ for?
19:58:05 <Cale> @let rectangle n m = replicate n . replicate m
19:58:05 <lambdabot> Defined.
19:58:15 <Cale> :t rectangle
19:58:16 <lambdabot> forall a. Int -> Int -> a -> [[a]]
19:58:23 <glen_quagmire> > rectangle 1 2 "hey"
19:58:31 <lambdabot>  [["hey","hey"]]
19:58:40 <Cale> > rectangle 3 4 (Just 1)
19:58:40 <lambdabot>  [[Just 1,Just 1,Just 1,Just 1],[Just 1,Just 1,Just 1,Just 1],[Just 1,Just 1,...
19:58:42 <glen_quagmire> oh it's matrix
19:59:06 <dogbite> indeed that's very nice
19:59:25 <glen_quagmire> > rectangle 1 2 "abc\n"
19:59:26 <lambdabot>  [["abc\n","abc\n"]]
19:59:54 <dogbite> look what you are responsible for
19:59:56 <dogbite> rectangle n m = replicate n . replicate m
19:59:56 <dogbite> ones n m      = rectangle n m $ Just 1
19:59:56 <dogbite> zeroes n m    = rectangle n m $ Just 0
19:59:56 <dogbite> empty n m     = rectangle n m $ Nothing
20:00:36 <mauke> @let ones n m = rectangle n m . pure
20:00:37 <lambdabot> Defined.
20:00:42 <dogbite> well, actually for my semantics i want
20:00:43 <dogbite> rectangle n m = replicate m . replicate n
20:00:45 <mauke> :t ones
20:00:46 <lambdabot> forall a (f :: * -> *). (Applicative f) => Int -> Int -> a -> [[f a]]
20:00:53 <dogbite> @type pure
20:00:54 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
20:01:18 <mauke> > ones 2 3 42
20:01:18 <dogbite> what's this pure?
20:01:18 <lambdabot>   add an instance declaration for (Show (f t))
20:01:22 <glen_quagmire> > pure 2
20:01:22 <lambdabot>   add an instance declaration for (Show (f t))
20:01:32 <mauke> > ones 2 3 42 :: [[Maybe Int]]
20:01:32 <lambdabot>  [[Just 42,Just 42,Just 42],[Just 42,Just 42,Just 42]]
20:01:39 <mauke> > ones 2 3 42 :: [[[Int]]]
20:01:40 <lambdabot>  [[[42],[42],[42]],[[42],[42],[42]]]
20:01:40 <dolio> > pure 2 :: ZipList Int
20:01:41 <lambdabot>   add an instance declaration for (Show (ZipList Int))
20:01:48 <dolio> Bah.
20:01:56 <mauke> dogbite: ignore that :-)
20:02:02 <mauke> dogbite: pure is a generic constructor
20:02:18 <mauke> it works for Maybe, [], and lots of other stuff
20:02:26 <pjd> dogbite: it's the same as Monad's return
20:03:05 <dogbite> you saying i'm not good enough for pure?
20:03:24 <Pseudonym> No, you're not.  Use arr instead.
20:03:32 <dogbite> oh boy
20:03:47 <mauke> I think it's overkill here, for no extra gain
20:03:55 <pjd> dogbite: pure, specifically, is part of Applicative (applicative functor) class
20:04:09 <pjd> "part of the", even
20:04:26 <dogbite> okay you guys might be right:  i'm on day 4 of my haskell quest so
20:04:31 <dogbite> that might be too much
20:04:45 <faxathisia> my haskell quest -- :D :D
20:04:50 <faxathisia> It's like a vision quest
20:04:55 <wy> Cale: I still don't understand. the remove operator is contravariant (e.g. one can remove an Object from an ArrayOf(String))...
20:04:58 <pjd> dogbite: learn Functor first; then Applicative :)
20:04:59 <dolio> It's also part of the Arrow (Freyd category) class. :)
20:05:03 <ac> wagle: yeah, I think a lot of it is over my head
20:05:04 <mauke> the final boss is hard
20:05:17 <wy> Cale: This seems to be natural. where is the problem?
20:05:17 <glen_quagmire> the first boss is Monad
20:05:30 <mauke> @quote oleg
20:05:30 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
20:05:46 <faxathisia> Oleg is the final boss?
20:05:47 <Cale> wy: Some of the operations on the type are covariant, and some are contravariant.
20:06:12 <dogbite> now getting back to my general design
20:06:13 <nornagon> :t range
20:06:16 <wy> Cale: can't we have both?
20:06:23 <lambdabot> forall a. (Ix a) => (a, a) -> [a]
20:06:33 <dogbite> if i had a [[Maybe a]]
20:06:43 <dogbite> and i had defined two types, say
20:06:54 <dogbite> type Price = Integer
20:07:05 <dogbite> type Temperature = Integer
20:07:12 <dogbite> (floats would be better but moving on)
20:07:20 <Cale> wy: Well, the question is whether ArrayOf(String) is a subtype of ArrayOf(Object) or vice versa.
20:07:41 <dogbite> well let's be more specific here
20:07:43 <dogbite> suppose i had
20:07:45 <dogbite> type Price = Float
20:07:49 <wy> Cale: got it. I missed the question :P
20:07:50 <dogbite> type Temperature = Integer
20:08:01 <mauke> Double > Float
20:08:01 <dogbite> now if i had a single 2d list
20:08:14 <dogbite> could it contain both Price and Temperature types?
20:08:19 <dogbite> not within a single list
20:08:22 <dogbite> but within a 2d list
20:08:27 <dogbite> where the sublists were uniformly typed
20:08:35 <mauke> no
20:08:46 <faxathisia> mumble
20:08:49 <mauke> lists are homogenous
20:08:58 <glen_quagmire> > [[1, 2.0]] :: (Num a) => [[a]]
20:09:00 <dogbite> okay, all the way through
20:09:06 <faxathisia> impossible to write hypetangle :: [Dimensions] -> a -> [...[a]...]
20:09:11 <lambdabot>        add (Fractional a) to the context of
20:09:11 <lambdabot>         the polymorphic type `for...
20:09:34 <faxathisia> What's stupid is I tried for 2 mins :P
20:09:35 <wy> Cale: Can you make an error case?
20:09:39 <dogbite> okay so if we're thinking of a 2d list
20:09:46 <dogbite> as a spreadsheet of sorts
20:09:51 <dogbite> where each column has some sort of data type
20:09:56 <dogbite> and the columns have a uniform type
20:10:01 <glen_quagmire> dogbite: maybe data CellVal = Price Double | Temperature Integer  ;  [[CellVal]] ??
20:10:36 <dogbite> what's the semicolon?
20:10:52 <mauke> data Record = Record{ price :: Double, temperature :: Integer }
20:10:58 <glen_quagmire> nothing. it's not haskell. just to say it ends data declaration
20:11:02 <mauke> [Record]
20:11:08 <mauke> it is haskell, actually
20:11:14 <pjd> [[Either Price Temperature]]
20:12:08 <wy> Object[] a = new String[10]
20:12:20 <pjd> :t [Left "foo", Right 5, Left "bar"]
20:12:27 <lambdabot> forall b. (Num b) => [Either [Char] b]
20:12:41 <dogbite> okay
20:12:49 <dogbite> so my two options... which are likely equivalent are
20:12:56 <mauke> there's more than one way to slice a table
20:13:00 <dogbite> create a record type of some sort... the kind with the named fields
20:13:07 <dogbite> that seems not as good
20:13:12 <dogbite> as having an algebraic type
20:13:24 <pjd> dogbite: records are algebraic types
20:13:33 <glen_quagmire> dogbite: are you trying to store Integer and Double in a list?
20:13:36 <mauke> records are products
20:13:38 <pjd> just syntax sugar
20:13:46 <dogbite> now how does this mix with the Maybe class
20:13:55 <dogbite> right now my cell value is a (Maybe a)
20:14:02 <wy> Cale: and then? what can be wrong?
20:14:17 <dogbite> so will i have my cell values be a (Maybe a) where the 'a' is my algebraic type?
20:14:18 <mauke> wy: a[0] = new Double();
20:14:19 <pjd> dogbite: [[Maybe (Either Price Temperature)]] ?
20:14:43 <glen_quagmire> dogbite: i am not sure what you are trying to do.
20:14:44 <wy> mauke: still see nothing wrong
20:15:16 <dogbite> well right now I have a 2d list of Maybe a values
20:15:23 <dogbite> so that i can have 'blank' values in the list
20:15:28 <dogbite> but now i want to enhance it so that
20:15:39 <dogbite> i have different data types in each column of the 2d list
20:15:51 <mauke> wy: String[] ss = new String[1]; Object[] os = ss; os[0] = new Double(); // now ss[0] (a String) contains a Double
20:15:53 <horchata> dogbite: you want beef?
20:16:03 <mauke> wy: WHERE IS YOUR TYPE SYSTEM NOW?!
20:16:03 <glen_quagmire> data Cell = Null | Int Integer | Float Double | ...  ?
20:16:15 <pjd> dogbite: what glen_quagmire said
20:16:21 * faxathisia lol
20:16:23 <dogbite> horchata, you think i grow up in the hood and don't know how to represent?
20:16:39 <dogbite> okay so if i go with what glen_quagmire says
20:16:47 <dogbite> do i loose the ability to use the functions such as
20:16:49 <dogbite> catMaybes?
20:17:03 <wy> mauke: ah! I got it
20:19:03 <pjd> dogbite: you might, depending on what you want to accomplish
20:19:03 <pjd> if you want differently-typed columns, you probably want tuples
20:19:03 <pjd> [(Type1, Type2, Type3, ...)]
20:19:14 <atp> dogbite: loose? :)
20:20:08 <pjd> dogbite: but you might not really want that
20:20:16 <mauke> this is a runtime error in java, btw
20:20:19 <glen_quagmire> dogbite: why would you need catMaybes?
20:20:23 <dogbite> sumVec   = (sum . catMaybes)
20:20:23 <dogbite> prodVec  = (product . catMaybes)
20:20:28 <dons> glguy: around? do we absolutely depend on python 2.4?
20:20:29 <dons> 2.5, i should say.
20:20:32 <dogbite> loose?
20:20:33 <mauke> lose
20:20:33 <dogbite> pjd, can you elaborate?
20:23:07 <glen_quagmire> dogbite: in a vector, types are uniform? like Int or Float ?? or does a vector contain both Int and Float?
20:23:07 <nornagon> @index stderr
20:23:07 <glguy> dons: dunno
20:23:07 <glguy> why
20:23:07 <dons> glguy: just wondering.
20:23:07 <dogbite> [[Just 11, Nothing], [Just 12, Just 22]]
20:23:07 <dogbite> so within a single column
20:23:07 <lambdabot> System.IO
20:23:07 <dogbite> i think of a 2d list as being
20:23:07 <dogbite> a list of column vectors
20:23:07 <glguy> dons: We'd have to do some pre-processing work for the foreign imports
20:23:07 <glguy> if it is compatible with earlier versions
20:23:07 <dogbite> so within a single column it can be uniformly typed
20:23:07 <glen_quagmire> sumVec = foldl (+ . unpackCell) 0 where unpackCell (Int i) = fromIntegral i; unpackCell (Float f) = f
20:23:07 <glguy> since the major version number is in the include path
20:23:07 <glguy> brb
20:23:12 <SamB> so, is there any benefit to using http://darcs.haskell.org/ghc-hashedrepo/ ?
20:23:13 <lambdabot> Title: Index of /ghc-hashedrepo
20:23:22 <pjd> dogbite: what do you want elaborated? :)
20:23:33 <pjd> [(Type1, Type2, Type3, ...)] ?
20:24:24 <dogbite> okay backing up... my 2d list
20:24:24 <dogbite> it is of the type [[Maybe a]]
20:24:24 <dogbite> i will need to change that to some custom type
20:24:35 <dogbite> that includes a Null which is equivalent to Nothing
20:24:37 <dogbite> and also has some other types that are a riff on Just a
20:24:37 <dogbite> correct?
20:25:16 <dogbite> so i will now have a 2d list as [[Cell a]]
20:26:12 <glen_quagmire> dogbite: yes. but then you need to rewrite sumVec and other functions. and i'm not sure how to do so.
20:26:34 <glen_quagmire> i would want ghc to read my mind
20:26:52 <dogbite> well i can figure that out
20:26:59 <dogbite> i just wanted to make sure that was actually a ramification
20:27:04 <glguy> interesting? #haskel forwards here
20:27:22 <SamB> maybe someone mispells it a lot?
20:27:37 <dibblego> I do, google helps
20:28:04 <dons> cool. i wonder how that got set up.
20:28:47 <glguy> dons: do you have python2.5?
20:28:48 <daf> SamB: ah, right, didn't think of that
20:28:56 <jsnx> one thing i like about haskell is there's always something more esoteric to learn
20:29:00 <dons> glguy: yep
20:29:12 <glguy> were you able to get pygments?
20:29:21 <jsnx> i'm just getting the hang of the IO monad and parsec...and now i need to combine them
20:29:38 <dons> glguy: getting there...
20:29:39 <jsnx> and soon, i'm sure, i will need something i don't even know what's it called
20:29:51 <SamB> daf: and JohnMeacham has proposed a magic underscore expression that makes a nice error invocation with file and line number...
20:29:56 <Cale> jsnx: You need to do IO in the middle of parsing?
20:30:09 <gwern> @hoogle CW_
20:30:09 <lambdabot> No matches found
20:30:11 <jsnx> Cale: yes, to implement a sed like thing
20:30:42 <glguy> dons: so for previewing, does this model sound reasonable:
20:30:58 <glguy> use clicks preview, sees syntax highlighted paste
20:31:01 <glguy> and has a button to save
20:31:03 <glguy> and has a button to save
20:31:04 <travisbrady> how do I sort a list of pairs by the second element?
20:31:07 <glguy> or can click back?
20:31:20 <glguy> or do you think that it is necessary to have/pollute with another edit box?
20:31:20 <Cale> In case any of those didn't go through...
20:31:32 <glguy> :t comparing
20:31:37 <lambdabot> Not in scope: `comparing'
20:31:41 <daf> SamB: oh?
20:31:44 <glguy> travisbrady: you'll use sortBy
20:31:48 <glguy> :t sortBy
20:31:49 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
20:32:06 <Cale> jsnx: You need to do I/O in the middle of parsing? Usually you use the IO monad to read in some string from a file, say, and then parse it separately.
20:32:08 <travisbrady> glguy: thanks, but what sort of function do i pass it?
20:32:08 <glguy> :t \ x y -> snd x `compare` snd y
20:32:09 <lambdabot> forall a a1 b. (Ord b) => (a, b) -> (a1, b) -> Ordering
20:32:16 <travisbrady> glguy: ahhh, thank you
20:32:37 <jsnx> Cale: yes, but that is so boring
20:32:46 <jsnx> i want to write awk programs in haskell
20:32:51 <glguy> dons: (did you see my messages before/after the flood?)
20:33:06 <glguy> jsnx: you want to ask the user to parse it for you?
20:33:08 <wy> mauke: haha I got it in Java: Exception in thread "main" java.lang.ArrayStoreException: C at Covariant.main(Covariant.java:20)
20:33:21 <Cale> > sortBy (comparing snd) (zip [0..] (words "hello there this is a test"))
20:33:21 <lambdabot>   Not in scope: `comparing'
20:33:23 <jsnx> glguy: no, you have never truly written awk
20:33:25 <Cale> oh!
20:33:31 <dons> sounds ok, glguy
20:33:31 <SamB> daf: alarmingly, I can't find any mention of it
20:33:33 <dolio> glguy: Seems fine to me.
20:33:42 <glguy> I think that it would look cleaner that way
20:34:00 <Cale> > sortBy (comparing snd) (zip [0..] (words "hello there this is a test"))
20:34:00 <lambdabot>  [(4,"a"),(0,"hello"),(3,"is"),(5,"test"),(1,"there"),(2,"this")]
20:34:16 <Cale> comparing is in Data.Ord
20:34:17 <jsnx> Cale: the distinguishing thing about awk is that the logic for what to do with this pattern goes right next to the pattern
20:34:38 <glguy> jsnx: you can return IO values
20:34:42 <glguy> without being in the io monad
20:34:45 <glguy> and run them later
20:34:47 <jsnx> glguy: really?
20:34:53 <jsnx> glguy: you're right, you can
20:35:07 <jsnx> so i guess i don't need ParserT
20:35:51 <pjd> jsnx: being able to do that kind of thing is largely the point of referentially-transparent IO :)
20:37:02 <dons> interesting to see how many people are using the codebin for haskell src, even just on reddit, http://reddit.com/info/6aw16/comments
20:37:18 <dons> should we consider leaning on this more as a teaching tool? http://codepad.org/
20:37:29 <dons> use haskell without needing to install hugs
20:38:05 <wy> mauke: yes. they are actually the same problem. two level pointer is the same as an array of references
20:38:15 <awesame> dons: I've been shocked at how much haskell use it's seen
20:38:30 <gwern> anyone know what 'newtype CursesWindow = CW_ WINDOWptr' means? I've grepped Mage's codebase, and CW_ is always used and never defined
20:38:33 <sclv_> @seen oerjan
20:38:33 <lambdabot> I saw oerjan leaving #haskell 6h 31m 13s ago, and .
20:38:41 <glguy> cool, we don't need hpaste :)
20:38:44 <glguy> outsourcing ftw
20:38:58 <dons> awesame: are you involved with it?
20:39:11 <dons> glguy: well, we can use it for the 'run this code' functionality :)
20:39:19 <dons> i'd also like a 'type check this' button
20:39:30 <SamB> didn't awesame add the Haskell support or something?
20:39:38 <dons> ah yes, that rings a bell :)
20:39:44 <gwern> geordi
20:40:15 <mauke> gwern: CW_ is the data constructor for CursesWindow
20:40:15 <awesame> dons: I'm the author
20:40:31 <SamB> so awesame == confuseme?
20:40:39 <awesame> dons: currently scrambling to keep it from falling over!
20:40:44 <awesame> SamB: yeah
20:40:51 <glguy> where's the code?
20:40:54 <dons> awesame: wonderful work :) we've long talked of an online evaluator.
20:40:58 <dons> ?where lambdaweb
20:40:58 <lambdabot> http://lambdabot.codersbase.com
20:41:16 <dons> was a previous one, which built on lambdabot's type system sandbox
20:41:24 <awesame> glguy: I'm planning to release it, but haven't decided on a license, and am still shy about my haskell
20:41:26 <gwern> mauke: oh. so CW_ is coming from the FFI, which is why hoogle didn't pick it up?
20:41:33 <glguy> oh..
20:41:36 <mauke> gwern: whu?
20:41:42 <mauke> CW_ is coming from the line you pasted
20:41:56 <gwern> mauke: wait, so that's the *definition* of CW_, not just a use?
20:42:01 <mauke> yes
20:42:17 <mauke> just like data Maybe a = Nothing | Just a is the definition of Just
20:42:22 <dogbite> before i asked about python's numpy but i have another question about python functionality that would be cool in haskell
20:42:31 <dogbite> are any of you familiar with the 'rrule' package?
20:42:42 <dogbite> it allows you to specify recurrence rules for dates
20:42:47 <gwern> ....clearly I do not understand newtype/data then
20:42:50 <dogbite> so you could say "last friday of every month"
20:42:52 <awesame> dons: yeah, I read about lambdabot while building it
20:42:53 <dons> oh, that's interesting, dogbite
20:42:54 <glguy> awesame: what do you use for syntax highlighting?
20:43:10 <dogbite> and it's a pretty powerful (complex)
20:43:15 <dogbite> interface where you can really specify
20:43:18 <awesame> dons: Eelis deserves a bit part of the credit, because all the really interesting sandboxing is based on geordi's supervisor
20:43:23 <awesame> s/bit/big/
20:43:24 <dogbite> a large number of recurrence rules of dates
20:43:47 <awesame> glguy: pygments, which is a python package
20:43:51 <mauke> gwern: data <Typename> <params> = <Constructor1> <args> | <Constructor2> <args> | ...
20:44:06 <glguy> awesame: how do you call it?
20:44:26 <SamB> heh
20:44:32 <glguy> c api or command line
20:44:35 <awesame> glguy: the web fronted is all in python.  the backend execution servers are in haskell.
20:44:35 <glguy> or other :)
20:44:36 <SamB> reddit.com reports time in milliseconds???
20:44:45 <glguy> awesame: Ahh..
20:44:47 <hpaste>  solrize pasted "nonworking multiprocess proxy" at http://hpaste.org/6118
20:45:03 <dons> awesame: cool. would *love* to see the code
20:45:53 <solrize_> awesame, heh i came in too late to see what this is about but it sounds really cool anyway
20:45:59 <awesame> dons: you can look at geordi right now -- http://www.xs4all.nl/~weegen/eelis/geordi/
20:46:23 <solrize_>  oh neat
20:46:33 <awesame> solrize_: my web site, http://codepad.org/
20:46:41 <awesame> solrize_: which is currently Very Busy
20:46:47 <dons> huh, didn't know about this, awesame
20:46:53 <dogbite> so do any of you have thoughts on this recurrece rule concept?
20:46:56 <dogbite> it seems like something that would be
20:47:01 <dogbite> very nice to solve in a language like haskell
20:47:05 <solrize_> wow neat
20:47:06 <dogbite> due to the recurrence part
20:47:23 <solrize_> awesame how do you sandbox the pasted code?
20:47:25 <dbueno> dogbite: I came late to the discussion, but the Emacs diary allows recurrence dates like you say.
20:47:40 <dogbite> is that accessible in some way from haskell?
20:47:41 <awesame> solrize_: see http://codepad.org/about
20:47:59 <solrize_> niiiice
20:48:16 <dbueno> dogbite: Not in any convenient way that I know of.  But if you're okay with looking at some GPL'd code for reference, I'm sure you could find the relevant code in the diary somewhere.
20:48:38 <dogbite> ya i could dig.. it would certainly be a slog i'm sure
20:48:40 <dbueno> dogbite: Though looking at existing code sort of defeats the purpose of "solving" the problem in Haskell. =]
20:48:47 <dogbite> i think my old advisor was involved with it
20:49:36 <dogbite> yeah good point, heh
20:49:42 <dogbite> i'm sorta itching to solve it but
20:49:55 <lispy> heh, I thought geordi was something related to GIS.
20:49:56 <dogbite> i feel like it could be done very well.... maybe using advanced concepts
20:49:59 <dogbite> because in a way it's like a parser
20:50:08 <faxathisia> what is it?
20:50:09 <dogbite> you are likely looping through an infinite list
20:50:13 <dogbite> of dates
20:50:14 <solrize_> what kind of recurrence rule do you mean?  like "easter = first sunday after first full moon after vernal equinox"?
20:50:50 <dogbite> http://labix.org/python-dateutil
20:50:51 <lambdabot> Title: python-dateutil - Labix
20:51:15 <dbueno> dogbite: I've always found reading Emacs sources enlightening.  Usually things are done in a very general way that factors the problem nicely.  However, undoubtedly the approach would differ in haskell.
20:51:38 <dogbite> on that link you'd have to scroll down but
20:51:45 <dogbite> list(rrule(DAILY, count=3, byweekday=(TU,TH), bysetpos=1,
20:51:46 <dogbite> ...            dtstart=datetime(2007,1,1)))
20:51:50 <dogbite> that's some python code
20:52:03 <dogbite> as you can see you're just saying it's a daily recurrence on tues/thurs
20:52:22 <solrize_> looks easy to do in .hs
20:52:27 <dogbite> and then you're able to iterate through it
20:52:37 <solrize_> yeah
20:52:37 <dogbite> calling before and after
20:52:42 <dogbite> and you can also test for membership
20:53:47 <solrize_> hey does anyone know how to get a forkIO thread to actually start running?
20:53:59 <mauke> it starts running right away
20:54:00 <solrize_> i mean to get it to force values from the other end?
20:54:07 <mauke> what
20:54:09 <dons> solrize_: hmm? the other end?
20:54:16 <solrize_> err
20:54:26 <monochrom> There is no other end.
20:54:28 <solrize_> sorry.  the thread reads from a socket and writes to a Chan
20:54:43 <dons> ah, you want to force the values before you write them to the chan?
20:54:59 <solrize_> hmm yeah i guess so
20:55:03 <solrize_> code is here  http://hpaste.org/6118
20:55:07 <dons> in that case, i recommend the strict-concurrency package, or use of Control.Parallel.Strategies.rnf on the value before you write it.
20:55:25 <dons> oh, but that's strict already?
20:55:30 <dons> or is there some issue you've observed
20:55:31 <solrize_> hmm i didn't know about those
20:55:47 <solrize_> well i run that thing and only two of the processes seem to become active
20:56:01 <dons> compiled with -threaded ?
20:56:02 <solrize_> i telnet into the local socket and type stuff
20:56:18 <solrize_> dons no do i have to compile specially?  i don't think i need OS threads
20:56:25 <solrize_> also on this machine i don't have ghc and am using hugs
20:56:29 <dons> yep. it means foreign calls won't block the whole runtime.
20:56:34 <dons> oh, not sure about hugs.
20:56:37 <solrize_> am i making any foreign calls?
20:56:40 <dons> concurrency isn't well tested on hugs
20:56:47 <dons> when you do read from the socket
20:57:05 <dons> can you check that you get the same behaviour in ghc?
20:57:07 <sclv_> hugs has weird concurrency i recall reading.
20:57:08 <solrize_> like hGetLine  ?  ohhhhh
20:57:20 <solrize_> i don't have ghc available right now but can try it on another machine later
20:57:38 <solrize_> or maybe i can clear some disk space and install ghc...
20:57:40 <dons> a concurrency issue in hugs definitely needs to be checked against ghc first
20:57:45 <solrize_> ok
20:57:45 <dons> since its so rarely used
20:57:50 <solrize_> that sounds like a plan
20:57:57 <dons> i don't think its a strictness issue, in this case.
20:58:00 <solrize_> i thought what i was doing was very basic, with no foreign calls
20:58:04 <solrize_> ok, thanks
20:58:14 <dons> well, you wait on the network somewhere, which means blocking
20:58:16 <SamB> that shouldn't count as a foreign call
20:58:20 <SamB> excactly
20:58:32 <SamB> but with hugs, who knows?
20:58:36 <dons> who knows.
20:58:40 <sclv_> hugs has cooperative concurrency only.
20:58:47 <dons> oh, hmm.
20:58:49 <sclv_> which means, i guess, you need to yield explicitly?
20:58:52 <dons> yeah.
20:58:55 <dons> the bad old days
20:59:00 <SamB> no select though?
20:59:12 <solrize_> there's not an automatic yield on all the blocking i/o operations?
20:59:23 <dons> in hugs? who knows.
20:59:37 <dons> ghc -threaded, yeah.
20:59:43 <solrize_> ok i guess hugs is in disrepair and i better switch to ghc
20:59:49 <solrize_> maybe i'll uninstall hugs to make space
20:59:54 <dons> you can compile on one machine, and put the binary on the server
21:00:10 <dons> well, for concurrency, hugs is pretty untested in the last decade
21:00:20 <solrize_> hmm
21:00:26 <sclv_> "Using Hugs, all I/O operations and foreign calls will block all other Haskell threads." says the haddocks.
21:00:34 <dons> there we go
21:00:41 <solrize_> all i/o operations?   aarrrggghhhaaahhghhrhhrhhrhhahhrggg
21:00:53 <dons> don't worry, ghc and its magic multicores are here to save the day
21:01:01 <solrize_> hehe
21:01:23 <solrize_> yeah i don't need multicore for this, it's intended as an irc proxy so only needs to be fast enough to keep up with someone typing
21:01:34 <dons> hugs is really a lazy teacher/newbie/emergency tool
21:01:42 <biouser> Looking for a way to check if:
21:01:50 <sclv_> hugs lacking preemption is actually a huge strike against its usefulness as a teaching tool as concurrency becomes more important.
21:01:52 <dons> well, you need a runtime that won't block on IO too :)
21:01:57 <solrize_> yeah i think i saw that description of hugs so as a newbie i said "that sounds like what i want" and installed it
21:02:15 <solrize_> ghci's error messages are actually a lot better than hugs's
21:02:27 <dons> yeah, people keep saying this.
21:02:32 <solrize_> which is a big part of newbie friendliness
21:02:33 <dons> 10 years ago it was the opposite.
21:02:41 <dons> but good to know. yet more strikes against hugs
21:02:43 <sclv_> we should really make a more thorough search of the haskell wiki and remove all the outdated hugs recommendations.
21:02:56 <dons> the type error one is the most pervasive , i reckon
21:02:57 <biouser> c1*a + c2*e +c3*i=x has integer solutions for c1,c2,c3 for given values of a,e,i,x
21:02:58 <oklopol> is there a "unique" function in haskell
21:03:01 <oklopol> i mean
21:03:14 <faxathisia> biouser: Always?
21:03:18 <dons> > nub [1,2,1,1,1,2,1]
21:03:19 <oklopol> unique [1, 43, 5, 43] = [1, 43, 5]
21:03:24 <dons> ?bot
21:03:25 <lambdabot> :)
21:03:30 <lambdabot>  [1,2]
21:03:34 <oklopol> thanks
21:03:42 <oklopol> why nub?
21:03:59 <cjb> I still want a Hoogle that takes instances of transformations and works out what function would have resulted in that transformation
21:03:59 <solrize_> oklopol it's british :)
21:04:00 <biouser> x=14   a=10, e=5, i=5
21:04:04 <dons> ?web1913 nub
21:04:05 <lambdabot> *** "Nub" web1913 "Webster's Revised Unabridged Dictionary (1913)"
21:04:05 <lambdabot> Nub \Nub\, v. t. [Cf. {Knob}.]
21:04:05 <lambdabot>    To push; to nudge; also, to beckon. [Prov. Eng.]
21:04:05 <lambdabot>  
21:04:05 <lambdabot> *** "Nub" web1913 "Webster's Revised Unabridged Dictionary (1913)"
21:04:07 <lambdabot> [3 @more lines]
21:04:09 <dons> ?more
21:04:09 <lambdabot> Nub \Nub\, n.
21:04:11 <lambdabot>    A jag, or snag; a knob; a protuberance; also, the point or
21:04:11 <cjb> the function space can be bounded by Prelude functions only, so it's not intractable
21:04:13 <lambdabot>    gist, as of a story. [Colloq.]
21:04:21 <dons> "the point or gist of a story"
21:04:26 <oklopol> hehe
21:05:11 <dons> http://reddit.com/info/6awsq/details "geordi: the evaluation supervisor behind codepad.org (written in Haskell) [programming] (xs4all.nl)" :)
21:05:20 <faxathisia> > let funk a e i x = [ (c1,c2,c3) | c1 <- [1..] , c2 <- [1..c1] , c3 <- [1..c2] , c1*a + c2*e +c3*i == x ] in funk 10 5 5 14
21:05:27 <lambdabot> Terminated
21:05:27 <oklopol> umm
21:05:31 <oklopol> nub is not in scope
21:05:33 <oklopol> where is it?
21:05:35 <faxathisia> :(
21:05:40 <dons> ?hoogle nub
21:05:45 <solrize_> Data.List maybe
21:05:46 <lambdabot> Data.List.nub :: Eq a => [a] -> [a]
21:05:47 <lambdabot> Data.List.nubBy :: (a -> a -> Bool) -> [a] -> [a]
21:05:48 <thoughtp1lice> Data.List iirc
21:05:48 <faxathisia> needs permutations
21:05:56 <solrize_> ?hoogle xgcd
21:05:56 <lambdabot> No matches found
21:06:00 <solrize_> ?hoogle egcd
21:06:00 <lambdabot> No matches found
21:06:05 <solrize_> ?hoogle gcd
21:06:05 <lambdabot> Prelude.gcd :: Integral a => a -> a -> a
21:06:07 <awesame> dons: yay, traffic for Eelis too
21:06:12 <biouser> I am trying to check if arbitrary numbers of *these* hyperrectangles can be fitted together to for *this* hyperrectangle
21:06:49 <biouser> hyper_decomp :: [Hyper_dim] -> Hyper_dim -> Bool
21:06:49 <biouser> hyper_decomp [[a,b,c,d],[e,f,g,h],[i,j,k,l]] [n,m,o,p] =
21:07:09 <dons> http://www.ohloh.net/projects/12533 too, awesame :)
21:07:09 <lambdabot> Title: geordi - Ohloh
21:07:56 <dons> glguy: have you been following all this?
21:08:18 <dons> glguy: duplicating the sandboxing of codepad seems very time consuming. how about a web service to 'run this' from hpaste :)
21:08:43 <dons> awesame: we're in the middle of rewriting hpaste.org, mostly generalising things
21:10:11 <hpaste>  biouser pasted "Knights4d Tools" at http://hpaste.org/6119
21:10:15 <awesame> dons: I'd be happy to provide you a web service to execute code on hpaste.org, in exchange for a link or something
21:10:46 <awesame> it'll probably take me a few days to get around to it, though
21:11:01 <awesame> I'm still struggling to keep up with the sudden burst of traffic
21:11:22 <dons> yeah, no rush. whatever makes sense to you
21:11:41 <gwern> so geordi is public domain...
21:11:56 <gwern> awesame: how hard d'you suppose putting geordi on hackage'd be?
21:12:20 <dons> gwern: you confirmed the license?
21:12:45 <gwern> dons: the link you posted says pd
21:12:52 <awesame> you should bug Eelis to do that, geordi is his project
21:13:31 <conal> is anyone here familiar with "wget -r"?
21:13:37 * gwern is eager to try something for a little while; mage's curses binding turns out to be quite sophisticated and including a fair bit of functionality hscurses misses
21:13:48 <gwern> conal: a recursive wget within a domain.
21:14:04 <conal> gwern: yes.  i tried it and got a recursive copy from the *top* of the domain.
21:14:20 <dino-> conal: I've used pavuk for more sophisticated grabs like this.
21:14:21 <conal> is that the expected behavior?
21:14:26 <gwern> conal: it'd follow a .. up to the top, I'd expect
21:14:33 <solrize_> conal yeah
21:14:35 <daf> -np may be what you want
21:14:40 <solrize_> right
21:14:43 <Korollary> -np = no parent
21:14:45 <gwern> there is an option to only decend, btw
21:14:45 <solrize_> --no-parent
21:14:50 <dino-> It's been some time, but I believe has switches for things like stay at this dir or below etc..
21:14:59 <gwern> *only descend, and -np does look like the right option
21:15:04 <solrize_> also you can use -l 1  to limit it o 1 level
21:15:06 <conal> oh!  i didn't notice -np.  thanks, all.
21:15:12 <dons> awesame: "The proxy server received an invalid response from an upstream server."
21:15:12 <dino-> an -np nifty
21:15:16 <dino-> ah
21:15:25 <conal> though -- jeepers.  would anyone ever not want -np?
21:15:26 <dons> oh, working now.
21:15:40 <awesame> yeah, struggling to keep things from falling over
21:15:47 <gwern> conal: when you want a full mirror of the domain
21:15:55 <dogbite> so, i understand how this function works
21:15:59 <dogbite> catMaybes ms           =  [ m | Just m <- ms ]
21:16:03 <gwern> conal: although I suppose you really should be using the mirror package of options for that...
21:16:06 <faxathisia> @undo [ m | Just m <- ms ]
21:16:06 <lambdabot> concatMap (\ a -> case a of { Just m -> [m]; _ -> []}) ms
21:16:06 <conal> gwern: i wonder why one wouldn't just start at the domain top then.
21:16:26 <dogbite> but what if you want to match
21:16:26 <gwern> @seen enriche
21:16:27 <lambdabot> I haven't seen enriche.
21:16:34 <dogbite> everything that is *not* the Just
21:16:34 <gwern> @seen jaortega
21:16:34 <lambdabot> I haven't seen jaortega.
21:16:42 <gwern> @seen fxnoria
21:16:42 <lambdabot> I haven't seen fxnoria.
21:16:48 <gwern> @seen ofrias
21:16:48 <lambdabot> I haven't seen ofrias.
21:17:01 <gwern> geez. who the heck were these scrambda guys anyway?
21:17:09 <pjd> dogbite: the only other thing you can match is Nothing
21:17:18 <dogbite> well what if i have a type
21:17:31 <dogbite> Cell = Null | Price Double | Temp Double
21:17:38 <dogbite> and i want to build a list of the non-nulls
21:17:43 <pjd> alternatively speaking, _ in that example matches everything except Just
21:18:10 <faxathisia> dogbite: write something, Cell -> Maybe Double
21:18:43 <faxathisia> dogbite: so then you can turn Null -> Nothing, and the other two into Just <something>
21:18:44 <dogbite> okay i was going to take that approach
21:18:49 <dogbite> of converting to Maybe
21:19:05 <dogbite> but i didn't know if that was the best way
21:19:16 <faxathisia> It's probably not
21:19:21 <dogbite> :-)
21:19:26 <faxathisia> but that's the best way I can think of
21:19:40 <faxathisia> because then you can use catMaybes
21:19:51 <dogbite> yeah i like my friend catMaybes now
21:20:32 * gwern reads the geordi readme. '    1. chmod +x scripts/*   # darcs is not yet aware of executability' <-- that's a dirty lie!
21:20:57 <dogbite> i think what i'll do is write it as a recursive filter
21:21:04 <dogbite> a custom filter... i'd like to use filter actually
21:21:13 <dogbite> but i don't know who to w... or.... yeah i can do that i think
21:21:17 <dogbite> i think i got it
21:22:29 <glguy> dons: what version of ghc does hspluggins require?
21:22:58 <mogunus> Hello. What editor do most people use for haskell?
21:23:03 <glguy> heh
21:23:36 <hpaste>  eyeris pasted "yi build log -- no errors but no Yi binary either. Why?" at http://hpaste.org/6120
21:24:57 <gwern> hpaste looks cut off
21:24:59 <glen_quagmire> eyeris: [53 of 59]   ?? maybe it needs to do steps 54 through 59?
21:25:13 <Korollary> mogunus: vi and emacs I think
21:25:15 <eyeris> yeah
21:25:15 <gwern> glguy: I believe 6.8.x
21:25:22 <eyeris> it just got cut off
21:25:45 <hpaste>  (anonymous) annotated "yi build log -- no errors but no Yi binary either. Why?" with "(no title)" at http://hpaste.org/6120#a1
21:26:08 <eyeris> ack
21:26:16 <glguy> http://71.111.57.135:81/hpaste.fcgi/ -- does this link work? does previewing work as expected?
21:26:33 <mogunus> Korollary: thanks. Just getting started with haskell and was wondering if my first instinct (grab the emacs mode for it) was a bad idea.
21:26:52 <mrd> no, it is a good idea
21:27:00 <eyeris> http://www.nomorepasting.com/getpaste.php?pasteid=12565
21:27:01 <sclv_> glguy: seems to be timing out.
21:27:10 <mrd> grab the latest haskell-mode, like 2.4 i think
21:27:24 <glguy> hmm
21:27:38 <dons> emacs and vim are most commonly used
21:27:51 <mrd> if you like vim, google Reinke's vim plugins for haskell
21:27:58 <mogunus> mrd: check. I'm an emacs addict.
21:28:04 <dogbite> hmm... is there a way to write a function to turn Cell -> Maybe Double
21:28:11 <dogbite> again, i have
21:28:12 <sclv_> mogunus: be warned. there is one real known issue with the emacs mode -- it doesn't handle if then indentation quite right. there's a fix for it floating around, but aside from that, the mode rocks.
21:28:15 <dogbite> Cell = Null | Price Double | Temp Double
21:28:26 <dogbite> but what if i don't want to write a pattern/guard
21:28:30 <dogbite> for every new type i define
21:28:37 <mrd> i don't use the smart-indentation anymore
21:28:38 <dogbite> i don't know how to capture the double part
21:28:44 <mrd> just 2-space tabs
21:28:51 <pjd> dogbite: it's not very common to define types like that
21:28:53 <mrd> er, not tabs
21:28:55 <mrd> indents
21:28:59 <dogbite> what's more common?
21:29:07 <sclv_> whew! i almost choked there.
21:29:14 <faxathisia> pjd, is for me..
21:29:28 <glen_quagmire> eyeris: did you check dist directory for Yi or Main binary?
21:29:28 <faxathisia> although I would not use the name Temp....
21:29:36 <dogbite> well right Temperature
21:29:40 <eyeris> Yeah
21:29:42 <dogbite> getting cheap with my keystrokes
21:29:44 <eyeris> Not there
21:29:47 <faxathisia> dogbite: I would suggest changing it to
21:29:49 <pjd> dogbite: what are you actually trying to implement?
21:29:57 <faxathisia> data Cell = Null | Price Double | Temperature Double
21:30:11 <glguy> http://71.111.57.135/hpaste.fcgi/ -- does this link work? does previewing work as expected?
21:30:14 <dogbite> fair enough, i agree.  but i don't see a way to pull off the DOuble
21:30:19 <glguy> (changed the port)
21:30:24 <ac> is there a way to export a data type with all its constructors without naming them all?
21:30:26 <faxathisia> dogbite what?
21:30:29 <eyeris> http://www.nomorepasting.com/getpaste.php?pasteid=12566
21:30:37 <faxathisia> you don't know how to write Cell -> Just Double?
21:30:39 <sclv_> glguy: same problem. firewall issues?
21:30:41 <dogbite> say i want to write a fromCell function
21:30:53 <glguy> aparently!
21:30:56 <dogbite> yes, or more generally a Cell -> Double
21:30:57 <glguy> apparently*
21:31:10 <sclv_> well what would it yield on fromCell Null ?
21:31:12 <faxathisia> Cell -> Double makes no sense
21:31:15 <glen_quagmire> eyeris: yay
21:31:16 <faxathisia> fromCell :: Cell -> Just Double -- is ok
21:31:22 <dogbite> why's that?
21:31:25 <faxathisia> fromCell Null = Nothing
21:31:32 <faxathisia> fromCell (Price x) = Just x
21:31:43 <faxathisia> fromCell (Temperature x) = Just (x * 7.3)
21:31:50 <faxathisia> you can use pattern matching like that
21:31:57 <dogbite> yes, but now if i add a new type
21:32:02 <pjd> dogbite: are you sure you need that type if you're only going to destruct it?
21:32:02 <dogbite> i have to go and aedit fromCell
21:32:02 <sclv_> glguy: home machine behind a router?
21:32:13 <faxathisia> do you really mean a new Constructor?
21:32:20 <dogbite> yes i think i need it because
21:32:21 <faxathisia> dogbite, show me what new type you mean
21:32:26 <dogbite> i want to distiguish between the doubles
21:32:28 <eyeris> glen_quagmire: what is yay about that?
21:32:31 <glguy> sclv_: yeah, a particularly crappy one
21:32:34 <dogbite> well what if i add
21:32:57 <dogbite> Cell = Null | Price Double | Temperature Double | Weight Int
21:32:58 <glen_quagmire> eyeris: there is Yi
21:33:12 <faxathisia> :t fromIntegral
21:33:13 <eyeris> That is a dir. With no yi exec in it
21:33:17 <lambdabot> forall a b. (Num b, Integral a) => a -> b
21:33:18 <glen_quagmire> but it's kinda small. not sure if it's really executable
21:33:20 <sclv_> ah.. seems there should be some way to open the port on it manually still... or just to say "heck with security" for the moment and dmz yr. box.
21:33:21 <faxathisia> then you will want fromIntegral
21:33:23 <pjd> dogbite: ok, but the price of distinguishing them is that you have to distinguish them :)
21:33:24 <glen_quagmire> eyeris: oops
21:33:43 <dogbite> okay, if that's the case then so it goes!
21:33:44 <sclv_> gamers need that sort of functionality, so even the low end routers have it.
21:34:02 <glguy> sclv_: the port *was* open
21:34:25 <dogbite> there's no way of matching something like _ Double
21:34:29 <sclv_> oh well, nevermind </gilda radner voice>
21:34:31 <pjd> dogbite: but step back;  why do you want to distinguish them?
21:34:55 <pjd> you talked earlier about columns having the same type;  is that really what you want?
21:35:08 <dogbite> well each column will have a certain type
21:35:12 <sclv_> ohh.. works now.
21:35:21 <dogbite> i don't want to simply have vanila types such as Double
21:35:32 <dogbite> because later i'm going to layer on more sematnics
21:35:39 <dogbite> and when i perform operations on ac olumn that is Price
21:35:40 <sclv_> or no.. that's cached... blah.
21:35:42 <pjd> dogbite: will each column have the same type? (like Temperature, or Price)
21:35:42 <dogbite> it will be different
21:35:50 <pjd> dogbite: ok, because then you don't want this
21:35:57 <dogbite> every cell under a singel column
21:35:59 <dogbite> will have the same type
21:36:05 <dogbite> but diff columns can have diff types but
21:36:06 <pjd> you want your columns to be typed, not your cells
21:36:10 <dogbite> they will all be Cells
21:36:31 <dogbite> well it hought about that but i'm not so sure
21:36:34 <pjd> this is what i was talking about earlier: [(Temperature, Price, ...)]
21:36:46 <dogbite> i don't understnad this array of tuple
21:37:07 <pjd> dogbite: it's a list of rows
21:37:20 <pjd> where each row has columns of the listed types
21:37:44 <sclv_> glguy: and now it really works. sorry for the stream of consciousness replies.
21:38:03 <dogbite> yes but i think the problem with that is
21:38:34 <dogbite> i think i lose some information because if you think of it as a spreadsheet
21:38:43 <dogbite> the individual values are typed as in... if it is a price
21:38:47 <dogbite> then that number is a Price
21:38:48 <glguy> sclv_: it works??
21:38:53 <sclv_> yep.
21:38:54 <dogbite> and it has semantics that go along with it
21:39:01 <dogbite> perhaps even how it is printed
21:39:01 <glguy> I love when things "just work" for "no reason"
21:39:08 <sclv_> interacting and previewing and everything.
21:39:10 <dogbite> so if you move the type info
21:39:13 <dogbite> out to the column
21:39:13 <pjd> dogbite: that's still the same
21:39:16 <dogbite> or an external structure
21:39:22 <pjd> the type still applies to the values
21:39:27 <dogbite> then you have to go and reference the external structure explicitly
21:39:49 <dogbite> but if I go back to having either Nothing or Just a
21:39:49 <glen_quagmire> ./exit
21:39:57 <dogbite> then when you call your display function on each Just a
21:40:06 <dogbite> it won't know to display as currency or what
21:40:10 <pjd> dogbite: the a inside the Just carries its own type
21:40:18 <dogbite> unless it checks some external structure to say
21:40:37 <dogbite> but if I put my Just Price
21:40:38 <sclv_> i note that text and wiki don't wrap (perhaps nothing does?) which is fine, but that also the box they're on top of still cuts off at the end of the page -- i.e. they don't push its borders.
21:40:44 <dogbite> Just Price Double
21:40:57 <dogbite> then it seems like i'm simply adding in a layer
21:40:59 <dogbite> for no reason
21:41:12 <faxathisia> Just Price Double will not work
21:41:27 <faxathisia> Like the value language, application of type constructors goes like this
21:41:39 <faxathisia> f x y z = (((f x) y) z)
21:41:46 <faxathisia> So you have
21:41:49 <faxathisia> (Just Price) Double
21:41:50 <pjd> dogbite: you're not adding any layer you weren't adding before :)
21:41:52 <glguy> sclv_: you mean when you make the window smaller you'd like a scrollbar or something?
21:41:56 <faxathisia> when you probably wanted Just (Price Double)
21:42:05 <faxathisia> (because the first is an error)
21:42:06 <dogbite> true that's what i want
21:42:10 <dogbite> Just (Price Double)
21:42:26 <dogbite> i think i'll still have the same issue where
21:42:36 <sclv_> not exactly: when you look at the wiki markup example, the text doesn't wrap, but the white box with borders that contains it only extends to the end of my window, so when i scroll right to see more text, the text runs over onto the grey background.
21:42:37 <dogbite> if I want to extract the actual Doulbe out
21:42:40 <dogbite> of a Just (Price Double)
21:42:52 <faxathisia> um
21:42:53 <dogbite> then I'll have to explicitly match every type that I have
21:43:04 <faxathisia> dogbite: You are mixing up the type and value languegs
21:43:10 <sclv_> you could add an optional scroll with some fancy hacking, or you could just set it so unwrapped text pushed the borders of the box further...
21:43:15 <faxathisia> dogbite: I didn't notice before but you can't have Double there
21:43:16 <dogbite> I have a Cell = Null | Price Double | Temperature Double
21:43:21 <dogbite> and i want to extract the Double
21:43:27 <faxathisia> dogbite: You could put A double there, likxe 3.1459265
21:43:28 <glguy> sclv_: better?
21:43:39 <faxathisia> dogbite: Just (Price 7.01) is ok..
21:43:52 <dogbite> okay fair enough
21:44:04 <faxathisia> snatch (Just (Price x)) = x -- you can extract it with pattern matching like this
21:44:08 <faxathisia> then use that function
21:44:19 <dogbite> right but then i need to write new code
21:44:21 <dogbite> every time i add a type
21:44:32 <dogbite> if i add a Weight to the Cell class
21:44:42 <pjd> dogbite: you write less new code than before (or you just pattern match, without writing any new code)
21:44:50 <faxathisia> obviously
21:44:56 <sclv_> glguy: much! i also note that the "add highlight" feature (which i don't know what its supposed to do) is borked but you probably knew that. and that "add revision" doesn't put any info in the resulting page, whereas I'd expect at least the language setting would carry over.
21:45:10 <faxathisia> If you want to change thigs you have to write more code...
21:45:19 <pjd> dogbite: if you add a Weight column, you don't have to change any existing code for the other columns
21:45:21 <glguy> sclv_: the add highlight is the rough interface
21:45:26 <glguy> sclv_: but put a lie number in
21:45:27 <glguy> line*
21:45:31 <glguy> and it will highlight that line
21:45:33 <pjd> but you do have to change them, if you use the Cell type
21:45:47 <pjd> which is why that approach is not such a good idea
21:45:48 <glguy> sclv_: I just haven't figured out a nice way to present line highlighting yet
21:46:11 <sclv_> oh, nice. i get it!
21:46:29 <dogbite> okay
21:46:32 <dogbite> i'm going to sleep on this
21:46:34 <glguy> sclv_: paste #51 is how I see that being used
21:46:38 <sclv_> when the scrollbar kicks in, it also messes with the vertical alignment a bit, so the line numbers don't match right with the lines anymore.
21:46:42 <dogbite> thank you all for your very helpful input
21:46:43 <pjd> dogbite: having the type specified for each cell complicates things, because every function needs to deal with every possible type
21:46:44 <dogbite> really appreciate it
21:47:04 <dogbite> pjd: this is a good point
21:47:18 <dogbite> will contemplate
21:47:18 <glguy> sclv_: is the line number situation better now?
21:47:23 <dogbite> thanks
21:47:27 <pjd> dogbite: but when you specify it for a whole column at a time, your code can treat all the values in that column uniformly
21:47:48 <pjd> without having to handle other possibilities (that should not occur in the first place)
21:47:54 <sclv_> yep! hot durn but you're fast with the css.
21:48:21 <dogbite> what if i did it like
21:48:26 <faxathisia> nice hpaste!
21:48:35 <faxathisia> I hope to build it :P
21:48:43 <faxathisia> or is it not written in haskell
21:49:00 <glguy> haskell
21:49:01 <dogbite> Cell t d = Null | NotNull t d
21:49:09 <glguy> faxathisia: much easier to build than old hpaste
21:49:20 <faxathisia> :D
21:49:22 <glguy> (additional dependency on the python library: pygments)
21:49:35 <pjd> dogbite: well, that's the same as Maybe (t, d) :)
21:49:46 <dogbite> fair enough but
21:49:49 <glguy> I have an embedded python interpreter that handles syntax highlighting
21:49:51 <faxathisia> dogbite, not very descriptive names, might as well go with what pjd says
21:49:55 <dogbite> would I be able to check if t == Price
21:50:11 <dogbite> or, i mean
21:50:14 <dogbite> t == "price"
21:50:18 <pjd> dogbite: you would, but then you're just manually implementing the types
21:50:24 <faxathisia> :S
21:50:25 <pjd> more work
21:50:31 <dogbite> right
21:50:38 <faxathisia> dogbite, this sounds like a bad idea :P
21:50:44 <dogbite> agreed
21:50:47 <dogbite> scratch that idea
21:51:22 <dogbite> i'm uncomfortable with moving the type informatin away from the absolute value
21:51:27 <dogbite> because then the values cannot stand alone
21:51:32 <dogbite> like for example
21:51:38 <dogbite> if you have a list of Price values
21:51:40 <pjd> dogbite: you're definitely not moving any type information "away" from any value
21:51:41 <dogbite> and you call sum on it
21:51:55 <dogbite> then it will be a function of [Price d] -> d
21:51:59 <dogbite> i mean
21:52:01 <pjd> there might be a misconception somewhere
21:52:04 <dogbite> [Price d] -> Price d
21:52:24 <dogbite> sum :: [Price d] -> Price d
21:52:46 <pjd> right
21:53:05 <dogbite> can't i use something like type classes here where
21:53:11 <faxathisia> what for/
21:53:21 <faxathisia> I don't think type classes solve your problem
21:53:34 <faxathisia> :t sum
21:53:36 <dogbite> right.  i suppose i'm slipping into the OO paradigm there
21:53:37 <lambdabot> forall a. (Num a) => [a] -> a
21:53:51 <pjd> dogbite: sum already uses the Num type class
21:54:04 <dogbite> well i might have to write
21:54:05 <dogbite> sumVec
21:54:11 <pjd> nah
21:54:15 <dogbite> sumVec :: [Cell] -> Cell
21:54:22 <faxathisia> What is Cell?
21:54:32 <pjd> dogbite: that's why you don't want Cell :)
21:54:33 <dogbite> it will be the type i define
21:54:39 <faxathisia> What is it?
21:54:41 <pjd> if you have a list of Prices, you can just sum them
21:55:07 <dogbite> okay
21:55:13 <dogbite> pjd, i think you're convincing me
21:55:25 <faxathisia> data Cell = ...?
21:55:48 <dogbite> faxathisia: right now i have
21:55:57 <dogbite> well right now i'm just using Maybe a
21:56:03 <dogbite> but i was thinking of changing it to
21:56:12 <dogbite> data Cell = Null | Price Double | Temperature Double
21:56:17 <faxathisia> ok cool
21:56:26 <dogbite> but pjd has talked me out of it
21:56:30 <dogbite> and i'm back to Maybe
21:56:32 <faxathisia> so sumVec = sum . catMaybes . map cellToMaybe
21:56:58 <faxathisia> where cellToMaybe Null = Nothing ; cellToMaybe (Price x) = x ; cellToMaybe (Temperature k) = 72.6 * x
21:57:00 <faxathisia> oops..
21:59:59 <solrize_> ?hoogle getArgs
22:00:00 <lambdabot> System.Environment.getArgs :: IO [String]
22:00:25 <wy> Cale: B* b = new B; B** bb = &b; A** aa = bb; *aa = new A;   Am I doing pointer arithmetic?
22:06:12 <faxathisia> *++wy; // do it like this
22:06:50 <faxathisia> "or this way"[5];
22:07:03 <faxathisia> but just dereferencing does not really count as arithmetic imo
22:07:04 <wy> faxathisia: I mean that it seem that I don't need pointer arithmetic to make the typing unsound
22:07:17 <faxathisia> sure .. no one said C or C++ is type safe
22:08:05 <jsnx> ghc comes with gcc on windows
22:08:32 <wy> hmm I wish I could stop thinking about these things, but maybe they are beneficial to my brain?
22:08:34 <jsnx> so, how do i setup a cabal package to get its c parts built that way
22:08:57 <faxathisia> wy, I know the feeling :)
22:09:12 <faxathisia> wy, You should read TAPL it covers this
22:09:21 * dolio can never remember what qualifies as covariant vs. contravariant with subtyping.
22:09:22 <faxathisia> and it's a very fun book anway..
22:09:32 <wy> faxathisia: really! I haven't read it in full
22:09:57 <wy> faxathisia: I'll try to get one
22:10:46 <wy> any ideas about ... my last problem... show that field conflicts may occur even if the classes in the program all have different names...
22:11:06 <wy> if we have multiple inheritance and pointers
22:11:11 <faxathisia> didn't mauke show an example of this?
22:11:54 <joha2> noob question: what's wrong with: map (\x y -> x + y) [1 2 3 4] when foldr1 (\x y -> x + y) [1 2 3 4] works?
22:12:10 <glguy> :t map
22:12:14 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
22:12:14 <glguy> :t foldr1
22:12:15 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
22:12:23 <jsnx> joha2: you should have a one argument function for map
22:12:25 <glguy> ?src foldr1
22:12:25 <lambdabot> foldr1 _ [x]    = x
22:12:25 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
22:12:25 <lambdabot> foldr1 _ []     = undefined
22:12:43 <jsnx> joha2: what is that function supposed to do?
22:13:13 <faxathisia> PLease use [1, 2, 3, 4]
22:13:13 <faxathisia> not [1 2 3 4]
22:13:13 <pjd> dogbite: one point is that if you use newtype for Price, you have to derive the Num instance for it (so you can add Prices, etc.)
22:13:14 <wagle_home> :t map (\x y -> x + y) [1 2 3 4]
22:13:15 <lambdabot>     Ambiguous type variable `t' in the constraint:
22:13:15 <lambdabot>       `Num t' arising from the literal `2' at <interactive>:1:23
22:13:15 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
22:13:21 <faxathisia> wagle, ...
22:13:26 <wagle_home> oh yeah
22:13:28 <wy> no. he showed something else
22:13:55 <wagle_home> :t map (\x y -> x + y) [1, 2, 3, 4]
22:13:56 <lambdabot> forall a. (Num a) => [a -> a]
22:14:05 <jsnx> > map (1 +) [1 2 3 4]
22:14:06 <lambdabot>        add an instance declaration for (Num (t -> t1 -> t2 -> t3))
22:14:11 <pjd> dogbite: with -fglasgow-exts, you would say something like: newtype Price = Price Double deriving (Eq,Show,Num)
22:14:21 <faxathisia> jsnx, please use [1 2 3 4]
22:14:25 <jsnx> > map (1 +) [1, 2, 3, 4]
22:14:25 <joha2> jsnx: what I want to do is to like (lambda (x y) (+ x y) '(1 2 3 ) '(5 6 7) -> (6 8 10).
22:14:27 <lambdabot>  [2,3,4,5]
22:14:37 <faxathisia> joha2: zipWith
22:14:40 <jsnx> faxathisia: i wanted to see what would happen
22:14:47 <faxathisia> > zipWith (+) [1,2,3] [5,6,7]
22:14:47 <lambdabot>  [6,8,10]
22:14:57 <joha2> aha, thanks. will try
22:15:08 <jsnx> faxathisia: not what i expected :)
22:16:01 <Heffalump> pjd: why would glasgow-exts be needed?
22:16:17 <glguy> newtype deriving
22:16:18 <pjd> Heffalump: for newtype-deriving
22:16:28 <Heffalump> but that's not newtype-deriving
22:16:32 <Heffalump> it's just normal deriving
22:16:39 <glguy> GeneralizedNewtypeDeriving
22:16:42 <glguy> is the other one
22:16:48 <glguy> where they aren't the built-ins
22:17:12 <pjd> Heffalump: you can't normally derive Num :)
22:17:22 <Heffalump> oh yeah :-)
22:17:39 <Heffalump> sorry, missed that!
22:20:45 * dolio begins to doubt that defining monads in arbitrary categories would be a good idea for Agda programming.
22:21:09 <jsnx> lambdabot: @tell
22:21:09 <lambdabot> Plugin `tell' failed with: Prelude.head: empty list
22:21:44 <solrize_> so how is it possible to write something like a basic telnet client, with no concurrency?
22:22:43 <jsnx> lambdabot: @tell Philippa what is the right way to arrange for Cabal to build a package that has a C file in it, using the GCC that comes with Windows GHC?
22:22:43 <lambdabot> Consider it noted.
22:22:49 <wy> faxathisia: Is that problem also in TAPL?
22:22:58 <gwern> solrize_: it's possible
22:23:21 <solrize_> i guess with select
22:23:26 <gwern> solrize_: check out ZFS on hackage - using delimited continuations
22:23:42 <gwern> it's crazy stuff tho, so don't expect to understand it :)
22:23:42 <faxathisia> I couldn't do categories in Agda
22:23:52 <solrize_> zomg :)
22:24:09 <gwern> solrize_: you may just want to read the PDF in the package...
22:24:30 * solrize_ will prob just install ghc
22:25:54 <dolio> faxathisia: I tried defining mapM, but (a ~> T b) -> ([a] ~> T [b]), isn't a valid type, because [] expects Set, and ~> wants objects from whatever category you're working in.
22:25:58 <faxathisia> which?
22:26:20 * faxathisia had similar trouble fiddling with Set levels..
22:26:38 <solrize_> agda >:O
22:26:47 <faxathisia> There is a constructive category theory thing in Coq btw but It's a bit much for me to understand at this stage
22:27:06 <faxathisia> solrize: Agda 2 :D
22:27:24 <solrize_> that's like, agda squared? :)
22:27:38 <dolio> I can still define mapM, of course, but it only works on (Monad STAR)s.
22:27:40 <faxathisia> It's more like haskell squashed..
22:28:18 * solrize_ still trying to figure out regular haskell
22:28:20 <wy> faxathisia: I got an online version of TAPL. Which chapter is it in? 18?
22:28:31 <BMeph> @type sequence . map
22:28:38 <lambdabot>     Couldn't match expected type `[m a]'
22:28:38 <lambdabot>            against inferred type `[a1] -> [b]'
22:28:38 <lambdabot>     Probable cause: `map' is applied to too few arguments
22:28:59 <BMeph> @type (sequence .). map
22:29:00 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
22:29:09 <BMeph> ?bo
22:29:09 <lambdabot> :)
22:29:26 <faxathisia> @typ ((.).(.)) sequence map
22:29:28 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
22:29:35 <faxathisia> Oh great
22:29:47 <faxathisia> that's a much nicer way to put it
22:30:37 <BMeph> "((.).(.))", huh? I wonder what you were thinking of when you brought THAT out... ;p
22:30:54 <faxathisia> .. lol
22:31:02 <glguy> the owl is angry!
22:32:27 <BMeph> glguy: Well, the hooter is...something emotional. ;)
22:32:33 <dolio> faxathisia: For that matter, _>>=_ isn't properly typed except in STAR. _=<<_ is, but in general you could only apply it to one argument, not use it as an operator.
22:33:10 <solrize_> :t (.)(.)
22:33:14 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => f1 (a -> b) -> f1 (f a -> f b)
22:33:26 <BMeph> dolio: STAR? :)
22:33:42 <sclv_> @ty mapM
22:33:43 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
22:33:52 <dolio> BMeph: Category with Haskell/Agda types as objects.
22:33:54 <faxathisia> dolio, I'm not sure how to do this, I wanted to use results from category theory to prove the foldr relation too but on luck
22:34:08 <sclv_> @let o = (.).(.)
22:34:08 <lambdabot> <local>:4:4:     Ambiguous type variable `f' in the constraint:       `Functo...
22:34:10 <faxathisia> no luck*
22:34:19 <faxathisia> :t (.).(.)
22:34:20 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
22:34:28 <dolio> BMeph: So named since the kind is usually *.
22:34:41 <dolio> Although it isn't in Agda.
22:34:51 <faxathisia> :t (.).(.) :: (a -> b) -> (y -> (x -> a)) -> (y -> (x -> b))
22:34:52 <lambdabot> forall a b y x. (a -> b) -> (y -> x -> a) -> y -> x -> b
22:35:00 <sclv_> @let o = (.).(.) :: (Functor f, Functor g) => (a->b) -> f(g a) -> f(g b)
22:35:00 <lambdabot> <local>:4:4:     Ambiguous type variable `f' in the constraint:       `Functo...
22:35:13 <faxathisia> @let o = (.).(.) :: (a -> b) -> (y -> (x -> a)) -> (y -> (x -> b))
22:35:15 <lambdabot> Defined.
22:35:20 <sclv_> whee!
22:35:35 <BMeph> dolio: So, do Agda folks call it something else, or are they generally familiar enough with Haskell to get the back-reference? :)
22:35:36 <sclv_> ?ty sequence `o` map
22:35:37 <lambdabot>     Ambiguous occurrence `o'
22:35:37 <lambdabot>     It could refer to either `L.o', defined at <local>:4:0
22:35:37 <lambdabot>                           or `SimpleReflect.o', imported from SimpleReflect at State/imports.h:69:0-32
22:35:43 <pjd> :t (.)
22:35:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:35:50 <faxathisia> > (sqrt) `o` (+ `on` (join (*))) $ 3 4
22:35:50 <pjd> hey, when did that happen
22:35:50 <lambdabot>  Parse error at "`on`" (column 15)
22:35:57 <faxathisia> @src on
22:35:57 <lambdabot> (*) `on` f = \x y -> f x * f y
22:36:02 <faxathisia> pjd, Cale
22:36:08 <pjd> Cale++
22:36:11 <faxathisia> > let (*) `on` f = \x y -> f x * f y in (sqrt) `o` (+ `on` (join (*))) $ 3 4
22:36:12 <lambdabot>  Parse error at "`on`" (column 53)
22:36:13 <sclv_> -fcale-exts
22:36:20 <faxathisia> > sqrt `o` ((+) `on` (join (*))) $ 3 4
22:36:21 <dolio> BMeph: Well, this is my own fiddling around, lifted in a roundabout way from something on the Epigram list, which also uses *.
22:36:21 <lambdabot> Terminated
22:36:27 <faxathisia> :( why?
22:36:46 <sclv_> ambiguous variables cause termination of lambdabot.
22:36:56 <sclv_> s/variables/functions/
22:36:58 <faxathisia> > sqrt `o` ((+) `on` (join (*))) $ 3 4
22:36:58 <lambdabot> Terminated
22:37:08 <sclv_> > sqrt `L.o` ((+) `on` (join (*))) $ 3 4
22:37:08 <lambdabot>   add an instance declaration for (Num (t -> a))
22:37:09 <faxathisia> > (sqrt `o` ((+) `on` (join (*))) :: Int -> Int -> Int) $ 3 4
22:37:09 <lambdabot> Terminated
22:37:17 <faxathisia> blah I give up
22:37:29 <dolio> BMeph: Agda has an infinite hierarchy of sorts. Values have type T (for some T), T has kind(?) Set, Set is a Set1, Set1 is a Set2, etc.
22:37:51 <sclv_> @let dot = (.).(.) :: (a -> b) -> (y -> (x -> a)) -> (y -> (x -> b))
22:37:56 * BMeph wonders if sclv_ knows how to "use functions as variables" ;p
22:37:58 <lambdabot> Defined.
22:38:06 <faxathisia> Agda is calculus of inductive constructions I think
22:38:27 <sclv_> > sqrt `dot` ((+) `on` (join (*))) $ 3 4
22:38:28 <lambdabot>   add an instance declaration for (Num (t -> a))
22:38:39 <wagle_home> > (sqrt) `L.o` ((+) `on` (join (*))) $ 3 4
22:38:39 <lambdabot>   add an instance declaration for (Num (t -> a))
22:38:45 <dolio> I'm not sure what Epigram does in that regard.
22:38:45 <sclv_> close enough. :-P
22:39:33 <dolio> I played with Coq for about five minutes, and it seems to cut off at Type, but maybe I was doing things wrong.
22:40:12 <faxathisia> dolio, Type has an implicit level
22:40:27 <faxathisia> not sure if that's what you menat
22:40:40 <faxathisia> I think Coq and Agda 2 are the same calculus though and Epigram is a bit different?
22:40:48 <dolio> Well, it said Type was a Type.
22:41:07 <faxathisia> Type : Type is true.. but it's implicitly Type[i] : Type[j] where i < j
22:41:15 <dolio> Ah, okay.
22:41:36 <dolio> That's different than Agda, isn't it?
22:41:39 <faxathisia> (plain Type : Type causes inconsistency and breaks normalization .. everything)
22:41:49 <faxathisia> well in Agda it's just called Set isn't it?
22:42:03 <dolio> Since it means Set1 : Set3, which it doesn't seem to be.
22:42:04 <faxathisia> I was guessing that was equivalent
22:42:13 <faxathisia> hmmm
22:42:33 <Feuerbach> please help me to grok this recursive definition (from X11): "newtype Region = Region (ForeignPtr Region)"
22:42:33 <dolio> I think in agda it's strictly Set[i] : Set[i+1].
22:43:13 <faxathisia> I see.. I wonder if that's why typing these tricky things is so hard?
22:43:20 <glguy> Feuerbach: ForeignPtr's type parameter is a phantom type
22:43:50 <dolio> It may be. I think I remember seeing discussion of changing it to be more like Coq in the mailing list archives, but I guess it hasn't been done yet.
22:43:59 <glguy> it is just used as a tag to make sure that things match up
22:45:33 <Feuerbach> glguy: so is it a ForeignPtr property?
22:47:06 <glguy> I'm not sure what you mean
22:49:36 <Feuerbach> I mean, will ForeignPtr argument always treated as "phantom"?
22:49:42 <glguy> yes
22:50:00 <glguy> maybe a simpler "phantom type" example will help?
22:50:14 <glguy> newtype ExampleA a = ExampleB
22:50:41 <glguy> ExampleB :: ExampleA Int
22:50:46 <glguy> (for instance)
22:51:04 <glguy> even though no there is no Int to be found in the ExampleB constructor
22:51:38 <glguy> er
22:51:43 <glguy> data ExampleA a = ExampleB
22:51:49 <glguy> now we can say:
22:51:58 <glguy> newtype Wrapper = Wrapper (ExampleA Wrapper)
22:52:23 <glguy> Wrapper (ExampleB :: ExampleA Wrapper) :: Wrapper
22:52:26 <dolio> faxathisia: Oh: http://appserv.cs.chalmers.se/users/ulfn/wiki/agda.php?n=Main.UniversePolymorphism
22:52:32 <glguy> (does that help at all, or am I confusing you with bad examples)
22:53:22 <Feuerbach> I think I need more time to get it... I've just found wikibook entry, will read it. Thanks for help :)
22:55:05 <faxathisia> hm.. it sounds like a hard problem :/
22:55:31 <dolio> Evidently.
22:56:11 <dolio> I think Epigram2 is supposed to have universe polymorphism (I think that was mentioned in the category/functor/etc. mail).
22:57:23 <dolio> Of course, it isn't available yet.
22:58:23 * faxathisia doesn't understand dependent typecheckers source code so reading ecce wouldn't help
22:58:54 <glguy> http://71.111.57.135/hpaste.fcgi/view?id=55#a55
22:59:05 <glguy> Feuerbach: ^ ?
23:01:24 <thoughtp1lice> Feuerbach: the wikibook page isn't very good; phantom types are just an idiom, you basically just 'hijack' the type system to ensure something at compile time. the types are phantom because they don't actually exist at runtime, they're just there to catch errors at compile time
23:01:56 <glguy> catch errors / pick instances
23:03:07 <Feuerbach> glguy: yes, that snippet is clear
23:04:07 <glguy> newtype CodePerformance a = CodePerformance Int
23:04:17 <glguy> this protects you from trying to compare a:  CodePerformance Ruby
23:04:23 <glguy> with a CodePerformance Haskell :-o
23:04:32 <glguy> even though they are both ints :)
23:05:39 <Feuerbach> glguy: just infinte-recursive types drive me crazy :) but since constructor ExampleA doesn't have argument of type Wrapper, we can build instance of such type, right?
23:05:40 <thoughtp1lice> Feuerbach: an example I liked was the one augustss showed in a blog post about a DSL:
23:05:43 <thoughtp1lice> http://augustss.blogspot.com/2007/06/representing-dsl-expressions-in-haskell.html
23:05:45 <lambdabot> Title: Things that amuse me, http://tinyurl.com/35u5ec
23:10:39 <ac> would it be better to use newtypes or ghci's synonyms-as-instances extension?
23:11:19 <ac> I guess it just depends on weather I want it to be portable or not
23:11:31 <ac> *whether
23:11:51 <Feuerbach> thoughtp1lice: yeah, it's nice :)
23:17:52 <glguy> Feuerbach: right
23:18:52 <wagle_home> poor brown
23:19:55 <glguy> have there been wallmsgs about it?
23:22:20 <wagle_home> i dunno..  i'm a peon, and i havent seen anything
23:38:04 --- mode: irc.freenode.net set +o ChanServ
23:38:18 <qwe> i use hugs what is the function there for isLower ?
23:38:40 <glguy> ?index isLower
23:38:40 <lambdabot> Data.Char
23:38:44 <Cale> qwe: isLower, but it's in Data.Char
23:49:51 <faxathisia> :/
23:50:05 <faxathisia> Where does pattern matching come from
23:50:16 <ddarius> ?
23:50:25 <glguy> the stork!
23:50:31 <faxathisia> hehe
23:50:39 <hpaste>  vikrant pasted "fibonacci" at http://hpaste.org/6121
23:51:12 <xpika> is there a way to append a function to the currently loaded haskell file in ghci?
23:52:36 <joha2> another n00b question: how can I set an element in a list (or rather, make a copy of the list with one element replaced)
23:53:04 <ddarius> joha2: There are ways, but it's a bad idea.
23:53:10 <ddarius> (usually)
23:54:36 <joha2> I'm making a Sudoku game solver, taking a game board as an argument, and calling this function recursively with more positions fixed. How to fix the positions if I cannot change the board structure?
23:55:16 <joha2> (the board is a list, so I want to change it before calling the solver function)
23:55:48 <siti> will you don't really change anything in haskell you just transform stuff
23:56:13 <faxathisia> What is the logical meaning of pattern matching?
23:56:22 <siti> I don't really know what you are trying to do, but maybe you could have a function that processes your list and returns something
23:56:45 <faxathisia> I thought it could just be suger for a catamorphism, but I feel this is wrong after rethinking it
23:57:00 <ddarius> faxathisia: The simplest kind is disjunction elimination.
23:57:09 <ddarius> (Which is usually part of a catamorphism.)
23:57:32 <joha2> siti: yes, that is what I'm thinking. A function that takes a list and returns a new list with one of the positions set to a new value.
23:57:55 <siti> yep
23:58:15 <siti> it takes some time to get around the concept of transforming rather than changing
23:58:54 <faxathisia> ok that makes perfect sense for any algebraic type, but what happens with more general types?
23:59:09 <joha2> siti: since this should be a common operation I was hoping that there would be a prelude or List function for this. But perhaps I have to make my own
23:59:14 <ddarius> joha2: It's preferable to transform things "whole-sale" rather than incrementally though in this case it's not -so- bad since the list is of a relatively small fixed size.
23:59:29 <ddarius> joha2: That operation is a very poor one to use in most cases.
23:59:49 <siti> if you are messing with lists foldr is nice :)
23:59:56 <ddarius> faxathisia: A more general type such as?
