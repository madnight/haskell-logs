00:25:31 <Mr_Awesome> is there some form of (&&&) that would work a list of arrows instead of just a pair?
00:25:51 <faxathisia> :t (&&&)
00:25:55 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
00:26:15 <faxathisia> what?
00:26:33 <Mr_Awesome> (&&&) takes a pair of arrows and combines their output into a pair
00:26:39 <oerjan> i think that came up the other day, the answer is no, but it is easy to write
00:26:42 <Mr_Awesome> i want to take a list of arrows and combine their output into a list
00:26:50 <faxathisia> [a b c] -> a b [c] ?
00:27:04 <faxathisia> :t sequence
00:27:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
00:27:07 <Mr_Awesome> yes
00:27:11 <faxathisia> @src sequence
00:27:11 <lambdabot> sequence []     = return []
00:27:11 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
00:27:11 <lambdabot> --OR
00:27:11 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
00:27:20 <faxathisia> :t foldr (liftA2 (:)) (return []) xs
00:27:21 <lambdabot> Not in scope: `xs'
00:27:29 <faxathisia> :t \xs -> foldr (liftA2 (:)) (return []) xs
00:27:30 <lambdabot> forall a (f :: * -> *). (Monad f, Applicative f) => [f a] -> f [a]
00:27:40 <oerjan> faxathisia: you are confusing Applicatives and Arrows
00:27:40 <faxathisia> oh.. I'm not sure
00:27:46 <faxathisia> yeah I see
00:27:58 <Mr_Awesome> so its something i should write myself?
00:28:05 <faxathisia> how do you write it?
00:28:17 <Mr_Awesome> okay, ill go try
00:28:39 <oerjan> :t let fanout as = foldr (\a x -> (a &&& x) >>> uncurry (:)) (arr []) as in fanout
00:28:40 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `[a]'
00:28:40 <lambdabot>     In the first argument of `arr', namely `[]'
00:28:40 <lambdabot>     In the second argument of `foldr', namely `(arr [])'
00:28:43 <oerjan> argh
00:28:57 <faxathisia> I see
00:29:05 <oerjan> something close to that
00:29:48 <oerjan> :t let fanout as = foldr (\a x -> (a &&& x) >>> uncurry (:)) (arr (const [])) as in fanout
00:29:49 <lambdabot> forall b a. [b -> a] -> b -> [a]
00:30:01 <oerjan> what the?
00:30:06 <oerjan> oh
00:30:21 <oerjan> :t let fanout as = foldr (\a x -> (a &&& x) >>> arr (uncurry (:))) (arr (const [])) as in fanout
00:30:22 <lambdabot> forall (a :: * -> * -> *) b a1. (Arrow a) => [a b a1] -> a b [a1]
00:30:28 <oerjan> there you are
00:32:36 <Gilly> would anyone have suggestions on how to implement a settings system in haskell for my plotter. I'd need to be able to alter settings for plots but at the same time have the syntax convenient for end user to stick with defaults (preferably not having to think about settings at all)
00:33:53 <Gilly> you'd have to be able to change the settings for every individual plot and so on...
00:33:57 <oerjan> :t let fanout as = foldr (\a x -> (a &&& x) >>^ uncurry (:)) (arr (const [])) as in fanout
00:33:58 <lambdabot> forall (a :: * -> * -> *) b a1. (Arrow a) => [a b a1] -> a b [a1]
00:34:15 <faxathisia> :t uncurry (:)
00:34:16 <lambdabot> forall a. (a, [a]) -> [a]
00:34:27 <faxathisia> :t break
00:34:28 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
00:34:38 <siti> Gilly: use hsplugins ;)
00:34:42 <faxathisia> let chop = uncurry (:) -- ?
00:34:59 <oerjan> huh?
00:35:11 * faxathisia wants a name for that
00:35:19 <oerjan> > uncurry (:) ('a', "bcd")
00:35:20 <lambdabot>  "abcd"
00:35:39 <Gilly> siti: i'll look at it, thanks
00:35:43 <faxathisia> stick = uncurry (:)
00:36:36 <Mr_Awesome> oerjan: i just wrote a recursive version using arrow notation. is your way a better idea do you think?
00:36:50 <faxathisia> Mr_Awesome, can I see it
00:37:43 <oerjan> Mr_Awesome: don't know much about arrow notation, and i just felt like using foldr, an explicit recursion might well be clearer
00:38:48 <oerjan> does :t do arrow notation?  pretty sure > doesn't
00:39:22 <oerjan> > proc whatever
00:39:22 <lambdabot>   Not in scope: `whatever'
00:39:41 <faxathisia> (Arrow ~>) => [b ~> a1] -> b ~> [a1]
00:39:55 <faxathisia> hm
00:39:58 <oerjan> :t let proc something = something in proc
00:39:59 <faxathisia> -XTypeOperators
00:40:00 <lambdabot> forall t. t -> t
00:41:29 <oerjan> :t proc apat -> apat
00:41:30 <lambdabot> parse error on input `->'
00:42:19 <b_jonas> also, wouldn't you need (Arrow (~>))
00:42:37 <Mr_Awesome> :t proc x -> do returnA -< x
00:42:38 <lambdabot> parse error on input `->'
00:43:01 <Mr_Awesome> > (proc x -> do returnA -< x) 1
00:43:01 <lambdabot>  Parse error at "->" (column 9)
00:43:18 <oerjan>  > has very few extensions
00:43:24 <hpaste>  Mr_Awesome pasted "fanout" at http://hpaste.org/6077
00:43:28 <oerjan>  :t has a bit more
00:43:33 <Mr_Awesome> theres my version
00:44:05 <oerjan> :t returnA
00:44:06 <lambdabot> forall (a :: * -> * -> *) b. (Arrow a) => a b b
00:45:33 <oerjan> in particular, > is passed through Language.Haskell which understands only/mostly H98 syntax
00:45:48 <Mr_Awesome> my version is correct, yes?
00:46:01 <oerjan> if it types, it must be right ;)
00:46:06 <b_jonas> really?
00:46:06 <faxathisia> Why would you use this?
00:46:42 <Mr_Awesome> use what? this function? or arrow notation?
00:46:50 <faxathisia> faanoun
00:46:58 <faxathisia> fanout*
00:47:29 <Mr_Awesome> well, i have a list of arrows, and i want to give them all the same input, collecting their results into a list
00:47:56 <b_jonas> > throwError 2 :: Either Int ()
00:47:58 <lambdabot>   add an instance declaration for (Error Int)
00:47:59 <lambdabot>     In the expression: throwErr...
00:48:46 <b_jonas> > throwError "2" :: Either String ()
00:48:48 <lambdabot>  Left "2"
00:52:53 <faxathisia> @hoogle ((f -> x -> y - z,x),y) -> z
00:52:53 <lambdabot> Hoogle Error: Parse Error: Unexpected character '- z,x),y) '
00:53:00 <faxathisia> ?djin ((f -> x -> y - z,x),y) -> z
00:53:00 <lambdabot> Maybe you meant: djinn djinn-add djinn-clr djinn-del djinn-env djinn-names djinn-ver
00:53:04 <faxathisia> ?djinn ((f -> x -> y - z,x),y) -> z
00:53:04 <lambdabot> Cannot parse command
00:53:12 <faxathisia> ?djinn ((f -> x -> y -> z,x),y) -> z
00:53:12 <lambdabot> -- f cannot be realized.
00:53:19 <faxathisia> ?djinn ((x -> y -> z,x),y) -> z
00:53:19 <lambdabot> f ((a, b), c) = a b c
00:53:29 <faxathisia> @pl f ((a, b), c) = a b c
00:53:30 <lambdabot> f = uncurry (ap fst snd)
00:54:51 <oerjan> faxathisia: exactly where do you expect the f to come from?
00:57:40 <faxathisia> (zipWith (ap fst snd) .) . zip . repeat = zipWith
00:59:14 <oerjan> zip . repeat = map . (,)
01:02:48 <Mr_Awesome> is there a cleaner syntax for import X hiding (y); import qualifed X (y) ?
01:04:30 <oerjan> i don't think so
01:20:35 <b_jonas> could you say just 'import X hiding (y); import qualified X;' ?
01:21:37 <ndm> b_jonas: that is a standard trick for Data.Map
01:21:47 <b_jonas> is it?
01:21:51 <ndm> import Data.Map(Map); import qualified Data.Map as Map
01:21:57 <b_jonas> yeah, but not with hiding
01:22:02 <b_jonas> you'd have to hide too many things
01:22:13 <ndm> yeah, depends whether you want to hide a lot
01:22:54 <b_jonas> lambdabot eval prompt has import qualified Data.Map as M; import qualified Data.Sequence as S; iirc
01:25:52 <Mr_Awesome> b_jonas: ah, good idea
01:26:58 <dolio> @type (M.!)
01:27:02 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
01:27:19 <b_jonas> it also imports several modules unqualified of course
01:27:20 <oerjan> @type (Data.Map.!)
01:27:21 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
01:27:26 <b_jonas> you can read the full list somewhere on the internets
01:27:29 <oerjan> ah
01:27:38 <oerjan> > (Data.Map.!)
01:27:40 <lambdabot>   Not in scope: `Data.Map.!'
01:27:50 <b_jonas> > Data.Map.(!)
01:27:51 <lambdabot>   Not in scope: data constructor `Data.Map'
01:27:51 <oerjan> gah
01:28:01 <b_jonas> hmm, so yours is the right syntax
01:28:03 <oerjan> > (M.!)
01:28:05 <lambdabot>  Add a type signature
01:31:51 <sphynx> ?where parsec
01:31:51 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
01:32:15 <Mr_Awesome> if i have data T = T in module M, when i do import M hiding (T); import qualified M (T), why does the constructor T never get imported?
01:32:27 <Mr_Awesome> (out of curiosity)
01:32:36 <quicksilver> Mr_Awesome: that's not a constructor, I think.
01:32:41 <quicksilver> Mr_Awesome: I think T is a type, right?
01:32:51 <quicksilver> ;)
01:32:51 <oerjan> import qualified M (T(T))
01:32:56 <quicksilver> the syntax for constructors is
01:33:00 <quicksilver> oh, oerjan beat me ;)
01:33:12 <Mr_Awesome> but import M hiding (T) hides the constructor
01:33:13 <quicksilver> disadvantage of punning.
01:33:26 <quicksilver> Mr_Awesome: it hides the entire type (including ALL its constructors, be they named T or otherwise)
01:33:27 <Mr_Awesome> why doesnt import qualified M (T) import the constructor?
01:33:41 <oerjan> i don't think it is possible to import the constructor without importing the type itself
01:34:02 <quicksilver> Mr_Awesome: I suggest you experiment with data T = S.
01:34:17 <quicksilver> Mr_Awesome: when you can tell the constructor apart form the type, it's more obvious what's going on.
01:34:55 <Mr_Awesome> so if i did import M (T), S wouldnt be imported?
01:35:28 <oerjan> right.  the syntax for importing all the constructors is T(..)
01:36:00 <oerjan> (literal ..)
01:36:03 <Mr_Awesome> so then why does import M hiding (T) hide S?
01:36:21 <sphynx> quicksilver: hi! Could you pelase tell, where can I get that alternative haskell-mode for emacs?
01:36:32 <dolio> How would you import the constructors without importing the type?
01:37:09 <Mr_Awesome> dolio: ah, understood. thanks :)
01:37:41 <dolio> It makes a little more sense if you import the type qualified later, I guess, but that's not required.
01:37:47 <quicksilver> sphynx: it's not a whole mode, it's just a new indentation algorithm.
01:37:53 <Mr_Awesome> dolio: wait no. nevermind, it still doesnt make sense
01:38:17 <Mr_Awesome> dolio: you can do just that with import M hiding (T()). that imports S but not T
01:38:28 <dolio> Oh, really?
01:38:34 <dolio> Huh.
01:38:35 <Mr_Awesome> yeah
01:39:04 <dolio> I guess in hiding, T = T(..), and in specific importing, T = T().
01:39:05 <quicksilver> sphynx: http://kuribas.hcoop.net/haskell-indentation.el
01:39:59 <Mr_Awesome> dolio: exactly. and im wondering why there is a discrepancy. i suppose if there werent such a discrepancy though, having T() would be redundant
01:40:15 <sphynx> quicksilver: Yeah, I meant the same. Thanks!
01:40:15 <Mr_Awesome> as in, if T= T() always
01:40:31 <dolio> Well, personally, I'd expect T=T(..) by default.
01:40:35 <dolio> In all cases.
01:41:22 <Mr_Awesome> agreed. but i happened to already know that T = T() when importing, and i got really confused when i found out that T = T(..) when hiding
01:41:24 <dolio> Even if that were the case, I suppose it'd still be useful for clarity.
01:41:36 <oerjan> oh wait.
01:41:52 <oerjan> "Data constructors may be named directly in hiding lists without being prefixed by the associated type."
01:42:29 <oerjan> so in fact if both are named T, hiding (T) clearly hides both
01:42:45 <dolio> Ah.
01:43:04 <Mr_Awesome> oerjan: so if it were named data T = S, then import M hiding (T) would import S?
01:43:07 <dolio> Does it not hide S, then?
01:43:11 <oerjan> don't know yet
01:43:21 <oerjan> http://www.haskell.org/onlinereport/modules.html
01:43:21 <lambdabot> Title: The Haskell 98 Report: Modules
01:43:28 <Mr_Awesome> ah, thanks
01:43:50 <dolio> T=T() except when T=T(T). :)
01:45:35 <oerjan> i would read it as not hiding S
01:45:50 <oerjan> "all entities exported by the named module should be imported except for those named in the list"
01:46:13 <Mr_Awesome> dolio: it all makes sense now :)
01:46:21 <dolio> Heh.
01:46:33 <Mr_Awesome> but thats only when hiding
01:46:40 <Mr_Awesome> when importing, T = T() no matter what
01:46:48 <dolio> Yes, of course. :)
01:47:43 <Mr_Awesome> so my assumption that import M hiding (<decls>); import qualified M (<decls>) always imported everything one way or another was false
01:48:09 <Mr_Awesome> if you have data T = T and <decls> is T, then the T constructor gets left out
01:48:25 <Mr_Awesome> i wonder how many people have had this problem?
01:48:30 <dolio> Mr_Awesome: You can change the latter to 'import qualified M'
01:48:35 <oerjan> billions and billions
01:48:48 <dolio> It imports everything as M, but you only have to qualify stuff you haven't imported the other way.
01:48:51 <Mr_Awesome> dolio: right, ive already done that. like i said, this whole question was just out of curiosity
01:48:52 * EvilTerran does what dolio suggests
02:56:46 <dolio> @seen faxathisia
02:56:46 <lambdabot> faxathisia is in #haskell. I last heard faxathisia speak 1h 54m 47s ago.
02:59:00 <Saizan_> is there a way in darcs to select only a part of what it presents as a "change"?
03:09:08 <dolio> @tell faxathisia If you have the time, I'd appreciate it if you'd confirm a bug for me. In my agda repository, I have Category.Functor. If I uncomment the functor laws, agda -I dies here with "the impossible happened." Type checking for the emacs mode dies similarly.
03:09:08 <lambdabot> Consider it noted.
03:10:29 <opqdonut> Saizan_: iirc you can edit the diffs it offers
03:31:36 <Saizan_> opqdonut: i don't see the option for that
03:31:45 <Saizan_> ?where darcs
03:31:45 <lambdabot> http://darcs.net/
03:31:58 <Saizan_> but i may have an old version
03:33:21 <opqdonut> it seems i misremember
03:33:31 <opqdonut> hmm, kinda stupid there's no option for that
03:35:57 <quicksilver> I thought there was
03:36:09 <quicksilver> it's one of the things that darcs-fans cite as a good thign about it, Ibelieve
03:36:15 <quicksilver> hunk-level-cherrypicking.
03:36:28 <quicksilver> isn't it provided by some of the interactive darcs features?
03:36:58 <idnar> uhm, when you record, you get interactive hunk selection
03:37:20 <idnar> I think what Saizan_ is asking about is how to select part of what it treats as a single hunk
03:37:49 <opqdonut> sub-hunk cherrypicking
03:37:50 <opqdonut> :)
03:38:06 <Saizan_> idnar: yeah
03:46:27 <Vq^> what is Data.Graph.Inductive.Monad used for?
03:51:02 <opqdonut> Vq^: implementing imperative graph algorithms?
03:53:57 <Vq^> opqdonut: i thought so too, but the graphs that implements it doesn't seem to be "mutable"
03:54:19 <Vq^> maybe i missed something
03:55:40 <opqdonut> hmm true
03:57:57 <Vq^> and if i had some form of graph in a monadic state i wouldn't want those types on the functions
03:58:36 <ttmrichter> Is there anybody here with some experience with the Eclipse support for Haskell?  I'm having weird problems installing it on Eclipse 3.2.
03:59:17 <quicksilver> Vq^: It's for implementing graphs whose data store is trapped in a monad isn't it?
03:59:27 <quicksilver> Vq^: e.g. a graph implemented over an IOArray.
04:00:58 <Vq^> i see
04:27:49 <guenni> good morning
04:28:17 <dolio> @type (>=>)
04:28:22 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
04:28:24 <smg> hello
04:28:39 <smg> liftM is used for list comprehensions fot example?
04:30:09 <Saizan_> dcoutts: ping
04:31:35 <daniel_larsson> liftM is for running a pure function on a monadic value
04:31:45 <daniel_larsson> @type liftM
04:31:46 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
04:32:23 <dcoutts_> Saizan_: pong
04:33:17 <Saizan_> dcoutts_: i've found a bug in cabal configure
04:33:29 <dcoutts_> Saizan_: only one? ;-)
04:33:45 <Saizan_> one that messes with my patches :D
04:33:54 <dcoutts_> Saizan_: tell me more, I'll be back in a moment with some coffee :-)
04:35:51 <dcoutts_> mmm coffee
04:36:10 <dcoutts_> Saizan_: details?
04:36:18 <Saizan_> dcoutts_: on cabal configure --global, in configInstallDirs prefix is leaved to NoFlag so when we do savedConfig `mappend` flags, the prefix used for a localinstalled overrides NoFlag, making this effectively an user installation, even if userInstall is set to False
04:37:06 <Saizan_> s/localinstalled/local installation/
04:37:28 <Saizan_> $HOME/.cabal, or what's in $HOME/.cabal/config
04:38:02 <Saizan_> so i think this is a residue of switching from defaulting to global to defaulting to user
04:38:09 <dcoutts_> Saizan_: mm
04:38:25 <dcoutts_> Saizan_: so you want to specify it explicitly
04:38:57 <Saizan_> like --global should set the prefix explicitly rather than NoFlag?
04:39:54 <dcoutts_> Saizan_: I'm still confused, the config file has two sets of install dirs, one for global installs and one for user
04:41:14 <Saizan_> dcoutts_: yeah, but ConfigFlags doesn't, and SavedConfig is converted to ConfigFlags before mappend
04:42:12 <Saizan_> dcoutts_: so maybe we should propagate configUserInstall from command-line-flags to savedConfig before converting the latter
04:42:31 <dcoutts_> Saizan_: you're going to have to walk me through the data flow, I'm not sure I see yet where it goes wrong exactly
04:43:40 <Saizan_> dcoutts_: ok, we're inside Main.installCommand
04:43:47 <Saizan_> no
04:43:59 <Saizan_> "configureAction"
04:44:03 <dcoutts_> in cabal-install
04:44:10 <Saizan_> yes
04:44:31 <dcoutts_> and this is the original invocation, not the self re-exec'ing phase
04:44:38 <Saizan_> no
04:44:51 <dcoutts_> oh, this is the self re-exec bit?
04:44:57 <Saizan_> it's original
04:45:01 <dcoutts_> ok
04:45:13 <Saizan_> it happens when calling "cabal configure --global" on command line
04:45:28 <dcoutts_> so the user did: cabal install --global --root-cmd=sudo foobar
04:46:31 <Saizan_> dcoutts_: err, no, it's a bug indipendent from that, it sets the wrong prefix in the setup-config
04:46:43 <Saizan_> that's why it's biting me later
04:46:47 <dcoutts_> ah ok
04:47:06 <dcoutts_> so just "cabal install --global foobar" is doing the wrong thing?
04:47:39 <Saizan_> cabal configue --global is doing wrong, in my opinion
04:47:47 <Saizan_> "configure"
04:49:27 <Saizan_> configureAction takes flags as an argument, with the command line ones, but also loads ~/.cabal/config, and does a merge of the two efore calling setupWrapper, right?
04:49:46 <dcoutts_> right
04:50:14 <dcoutts_> though it decides which set of install dirs to use from the ~/.cabal/config based on the --global/--user flag
04:50:46 <Saizan_> no, it doesn't it ignores the user submitted --global
04:51:38 <dcoutts_> ohh
04:51:48 <Saizan_> because it first convert ~/.cabal/config to ConfigFlags keeping the prefix as in --user
04:52:02 <Saizan_> and then mappend propagates it
04:52:43 <dcoutts_> I see, yes
04:52:53 <dcoutts_> $ cabal configure --global -v
04:52:53 <dcoutts_> dist/setup/setup configure --verbose=2 --ghc --prefix=/home/duncan/.cabal --global
04:53:28 <dcoutts_> it's calling dist/setup/setup with the user --prefix from the ~/.cabal/config even though it's a --global
04:53:36 <Saizan_> heh, i should have started with a paste like that :)
04:53:52 <dcoutts_> Saizan_: so I understand now :-)
04:54:04 <dcoutts_> should be easy to fix, I'll take a look
04:54:28 <lcamden> ?seen sjanssen
04:54:28 <lambdabot> I haven't seen sjanssen.
04:57:03 <cin> haskell, hell yeah!
04:58:17 <Saizan_> dcoutts_: yeah, it should, but i'm not sure where, i thought of setting the user-supplied value of userInstall inside the loaded savedConfig before converting it, but it's kind of backwards
04:58:46 <dcoutts_> Saizan_: I'm looking at the savedConfigToConfigFlags
04:59:06 <dcoutts_> Saizan_: it takes the packageDB flag supplied on the command line for precisely this reason
04:59:15 <dcoutts_> Saizan_: I think it's just a bug in that function
04:59:39 <dcoutts_> I suspect the mappend there is backwards, I'm just testing it to be sure
05:13:21 <Saizan_> oh, right, completely overlooked packageDB
05:21:06 <dcoutts_> Saizan_: I think it used to work and I broke it by changing the way the --user/--global and package db flags work in configure
05:38:06 <Codex_> :t s f = (\p.f p, \k.f k)
05:38:10 <lambdabot> parse error on input `='
05:39:00 <Saizan_> :t let s f = (\p -> f p, \k -> f k) in s
05:39:01 <lambdabot> forall t t1. (t -> t1) -> (t -> t1, t -> t1)
05:40:08 <Codex_> how do I get the type to be (a \/ b -> t1) -> (a->t1, b->t1) ? :)
05:40:54 <quicksilver> :t \f -> (f . Left , f . Right)
05:40:54 <lambdabot> forall b a b1. (Either a b1 -> b) -> (a -> b, b1 -> b)
05:41:15 <quicksilver> you may find it looks clearer eta-expanded, though
05:41:32 <quicksilver> :t \f -> (\a -> f (Left a) , \b ->  f (Right b))
05:41:33 <lambdabot> forall a b t. (Either a b -> t) -> (a -> t, b -> t)
05:42:07 <mauke> @djinn (Either a b1 -> b) -> (a -> b, b1 -> b)
05:42:07 <lambdabot> f a = (\ b -> a (Left b), \ c -> a (Right c))
05:42:28 <shepheb> seems like there should be an arrow combinator for that.
05:43:03 <quicksilver> there is
05:43:07 <quicksilver> it's (|||)
05:43:15 <quicksilver> or some slight variant thereof
05:43:51 <shepheb> but clearly not a standard one
05:43:59 <quicksilver> "standard"?
05:44:10 <shepheb> "standard" = "in Control.Arrow"
05:44:16 <quicksilver> it's in Control.Arrow.
05:44:38 <daniel_larsson> (|||) is sort of the inverse of that, no?
05:44:39 <shepheb> oh, I misread the haddock.
05:44:52 <daniel_larsson> @type (|||)
05:44:53 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
05:45:03 <quicksilver> yes, it is sort-of the inverse
05:45:11 <quicksilver> hmm
05:45:42 <quicksilver> there should be a way of building it :)
05:45:46 <quicksilver> maybe there isn't.
05:47:33 <daniel_larsson> The function above is slightly funny... returns two functions for each Either branch...
05:48:30 <explisixjelly> without hoogle i would be LOST
05:52:11 <LoLLo> http://it.youtube.com/watch?v=-Gs8sYe4uqM
05:52:12 <lambdabot> Title: YouTube - Linux Ubuntu Power by Pilo
05:53:59 <quicksilver> LoLLo: are you hre to talk about haskell?
05:54:13 <quicksilver> A video about ubuntu doesn't sound very relevant to the channel.
05:54:49 <roconnor> how does YHC represent IO a?
05:55:05 <quicksilver> ndm might know.
05:55:25 <ndm> roconnor: newtype IO a = a -> _E a
05:55:45 <roconnor> okay
05:55:51 <dcoutts_> which raises more questions than it answers :-)
05:55:53 <ndm> where data _E a = _E a
05:55:54 <roconnor> how do I want to think of _E?
05:56:02 <ndm> think of it as a box to stop over-eager evaluation
05:56:18 <quicksilver> what's the 'a' on the input side of the arrow then?
05:56:23 <roconnor> so it is isomorphic to a -> a
05:56:25 <roconnor> ?
05:56:25 <ndm> real world
05:56:29 <ndm> no
05:56:33 <ndm> actually, just let me check
05:57:54 <ndm> data World = World
05:57:56 <ndm> newtype IO a = IO (World -> _E a)
05:58:05 <mux> makes more sense to me :)
05:58:10 <dcoutts_> Saizan_: I've got a fix, pushing...
05:58:28 <ndm> data _E a = _E a
05:58:43 <ndm> those are from YHC.Internal (first 2) and YHC.Primitive (last 1)
06:01:50 <dcoutts_> Saizan_: pushed, try it out
06:02:09 <roconnor> ndm: can you say how putChar is implemented?
06:02:33 <ndm> foreign import ccall hPutCharC :: Handle -> Char -> IO ()
06:02:51 <ndm> roconnor: that's the ultimate function that actually does it, its primitive how it manipulates boxes etc
06:03:51 <ndm> roconnor: it is strict on the world argument, and then generates the box and the enclosing value at the same time
06:04:49 <ndm> to get exact details email Tom though, via the Yhc list
06:11:34 <explisixjelly> okay. ErrorT in combination with a state monad gives me headaches right now
06:11:57 <Saizan_> dcoutts_: ok, it appears fixed
06:12:35 <dcoutts_> Saizan_: great
06:12:40 <quicksilver> explisixjelly: I suspect this means your head is about to explode.
06:12:47 <explisixjelly> quicksilver, probably %)
06:12:48 <quicksilver> explisixjelly: I recommend wearing a nice soft hat.
06:15:52 <explisixjelly> what is mapErrorT for?
06:15:56 <explisixjelly> :t mapErrorT
06:16:00 <lambdabot> forall (m :: * -> *) e a (n :: * -> *) e' b. (m (Either e a) -> n (Either e' b)) -> ErrorT e m a -> ErrorT e' n b
06:16:07 <explisixjelly> nice. why? 8)
06:16:36 <dcoutts_> looks like it's for transforming the error type
06:17:31 <Saizan_> and the internal monad
06:17:43 <explisixjelly> puh. headache.
06:17:45 <dcoutts_> oh yes
06:17:51 <Saizan_> like.. everything :D
06:18:21 <explisixjelly> type Foo = ErrorT MyError (State MyState)
06:18:31 <Saizan_> mapErrorT f = ErrorT . f . runErrorT
06:18:56 <explisixjelly> getSomeState = return $ State (\s -> (s, s))
06:18:59 <explisixjelly> that works, I guess
06:19:00 <explisixjelly> but
06:19:13 <Saizan_> no, it doesn't
06:19:17 <explisixjelly> let's suppose I want to do something more complex than just returning "s" as value
06:19:20 <explisixjelly> it doesn't?
06:19:25 <Saizan_> ?type return $ State (\s -> (s, s))
06:19:29 <lambdabot> forall (m :: * -> *) s. (Monad m) => m (State s s)
06:19:41 <explisixjelly> and?
06:19:48 <Saizan_> (ErrorT e) is not a monad
06:19:55 <Saizan_> it's a monad-transformer
06:20:33 <Saizan_> ?unmtl ErrorT MyError (State MyState) a
06:20:34 <lambdabot> MyState -> (Either MyError a, MyState)
06:21:16 <Saizan_> getSomeState = ErrorT $ State (\s -> (return s, s)), or just getSomeState = lift get
06:21:37 <quicksilver> or just getSomeState = get
06:21:37 <Saizan_> ?type lift -- seen this?
06:21:40 <lambdabot>     Ambiguous occurrence `lift'
06:21:40 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
06:21:40 <lambdabot>                           or `Control.Arrow.Transformer.lift', imported from Control.Arrow.Transformer
06:21:42 <explisixjelly> ah. that's exactly it. thanks.
06:21:48 <quicksilver> just 'get'
06:21:52 <quicksilver> 'get' is already in a typeclass
06:21:54 <explisixjelly> Saizan_, no, get is not what I want, I'm doing something a bit more complex
06:22:00 <quicksilver> and there is an instance for ErrorT.
06:22:04 <quicksilver> explisixjelly: what do you want?
06:22:05 <Saizan_> ?type Control.Monad.Trans.lift
06:22:06 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
06:22:08 <explisixjelly> I was just going to explain my problem using this simpler version
06:22:26 <explisixjelly> quicksilver, I want to do stuff to the state and maybe raise an error while doing so
06:22:32 <Saizan_> lift is more general, even if there are cases when it won't work
06:22:52 <quicksilver> explisixjelly: that sounds easy enough.
06:22:55 <quicksilver> explisixjelly: what's the problem?
06:23:04 <explisixjelly> quicksilver, nothing, it works now, I just got confused
06:23:18 <quicksilver> do { x <- get ; let y = do_stuff_to x ; if not_good y then throwError else...
06:23:21 <quicksilver> ah, good :)
06:24:16 <explisixjelly> quicksilver, yes, but I wanted to do it with State (\s...) which is why I got confused
06:24:20 <explisixjelly> in type hell
06:25:00 <Saizan_> "the outer transformer becomes the inner monad" :)
06:25:20 <explisixjelly> yes, I totally forgot about monad transformes
06:25:22 <explisixjelly> +r
06:26:22 <quicksilver> I wonder why you would prefer to use State (\s -> ...)
06:26:31 <quicksilver> instead of using the nice combinators in MonadState
06:26:44 <explisixjelly> quicksilver, to learn! 8)
06:26:49 <quicksilver> fair enough.
06:27:45 <explisixjelly> I'm writing a compiler
06:28:21 <explisixjelly> right now I'm writing the interpreter which interprets the intermediate code that results from the compiler's first pass.
06:28:28 <explisixjelly> for testing purposes
06:28:33 <explisixjelly> writing compilers is a great way to learn haskell.
06:28:39 <explisixjelly> (and interpreters, too)
06:29:10 <Codex_> most people start by writing a parser and type checker first :)
06:29:13 <skorpan> as a matter of fact, i'm writing a simple interpreter as well
06:29:35 <explisixjelly> Codex_, uh, I did that, otherwise I wouldn't have any intermediate code right now ;)
06:29:43 <skorpan> did you use bnfc?
06:29:45 <quicksilver> essentially all computer programs are interpreters :)
06:29:50 <quicksilver> and many of them are compilers, too.
06:30:10 <explisixjelly> yes, I know
06:30:38 <explisixjelly> Codex_, I didn't say that I'm writing the interpreter before the parser or type checker %) besides, the type checker was VERY simple in that case
06:33:30 <explisixjelly> so I just incorporated the type checker into the first pass
06:33:36 <explisixjelly> with translates into intermediate code.
06:35:53 <oklokok> >>> map (-5) [1,2,3]
06:35:59 <oklokok> > map (-5) [1,2,3]
06:36:01 <lambdabot>   add an instance declaration for (Num (a -> b))
06:36:21 <explisixjelly> > map (- 5) [1,2,3]
06:36:21 <lambdabot>   add an instance declaration for (Num (a -> b))
06:36:24 <explisixjelly> hm
06:36:42 <oklokok> > map (5 -) [1,2,3]
06:36:44 <lambdabot>  [4,3,2]
06:36:45 <oklokok> > map ((-)5) [1,2,3]
06:36:46 <lambdabot>  [4,3,2]
06:37:22 <explisixjelly> aah.
06:37:48 <oklokok> you can only curry params left-to-right
06:37:56 <daniel_larsson> > map (flip (-) 5) [1,2,3]
06:37:56 <lambdabot>  [-4,-3,-2]
06:38:04 <explisixjelly> I really though the parser wouldn't interpret - <number> with spaces between it as a negative number.
06:38:54 <oklokok> well, "-" is a special case anyway, what did you expect it to be?
06:40:48 <quicksilver> I'd kind-of like it to work as explisixjelly suggests
06:41:03 <quicksilver> but I understand reluctance to add more sensitivity to 'minor' whitespace changes.
06:42:30 <sphynx> Hi all! I have a Parsec question. How can I specify that I need to parse until some parser succeed and to get the output of that stoppper-parser at the same time? So I need something like:
06:42:31 <sphynx> res <- manyTill anyChar (t <- tags <|> newline)  -- incorrect Haskell, but I need 't'
06:43:24 <Philippa> sphynx: easiest thing to do'd be to ready the source for manyTill and modify it
06:43:50 <sphynx> Philippa: yeah, but it uses internal scan function
06:44:26 <sphynx> source is here: http://haskell.org/ghc/docs/latest/html/libraries/parsec/src/Text-ParserCombinators-Parsec-Combinator.html
06:44:27 <lambdabot> http://tinyurl.com/yw73jf
06:45:41 <Cheery> here I have the haskell standard libraries documentation, bunch of papers related to ghc and the implementation of functional programming languages..
06:45:52 <Cheery> which one would be best to read first?
06:46:12 <shepheb> Cheery: as a path to learning Haskell?
06:46:30 <profmakx> none of them ;)
06:46:37 <Philippa> sphynx: it /defines/ scan, that's not a problem
06:46:52 <Cheery> I've learnt haskell already
06:47:11 <Cheery> need to learn the internals and learn to actually use haskell in my projects
06:47:20 <sphynx> Philippa: oops, really :) Sorry
06:49:03 <Cheery> profmakx: all of them are such that I'm going to read them anyway
06:49:16 <Cheery> just thinking about the best order to read them. :>
06:51:13 <Cheery> rational behind reading the documentation from standard libs would actually provide me knowledge about what sort of toys do I actually have, and would probably be most useful
06:51:44 <Cheery> some stuff in those bunch of papers would be such that I'd want to myself implement them also, and try out variations.
06:52:10 * shepheb would start with the libraries, since they define the tools you have. the implementation is worthy of study, but it won't help you as directly as the libraries.
06:52:53 <Saizan_> reference documentations are usually read in a call-by-need fashion.. otherwise it's hard to remember a bunch of functions/types without using them
06:53:08 <Saizan_> i'd just skim it to have an idea
06:53:23 <profmakx> Cheery, to learn USING a tool
06:53:25 <profmakx> USE it
06:53:41 <profmakx> You only learn things by doing them
06:54:12 <Cheery> Saizan_: I think not only skimming, but reading what do they contain would be good
06:54:27 <Cheery> then reading libraries in detail which I'm going to use
06:54:37 <Cheery> it's a bit tedious to lookup things when you need them
06:54:57 <Cheery> especially when it all is outside your emacs
06:55:00 <daniel_larsson> That's when hoogle comes to the rescue :)
06:55:01 * profmakx doesnt think this is a wise idea
06:55:14 <profmakx> frustration factor is too high if you ask me
06:56:02 <Cheery> well, that may be..
06:56:13 <daniel_larsson> Skimming isn't a bad idea, at least you hopefully have an idea what kind of functions there are, and where to find them
06:57:05 <Cheery> yep, especially with opengl -module, I ran into problems last time when I didn't knew where to find things I were looking for
06:58:10 <profmakx> asking this channel is an option
06:58:18 <profmakx> almost always a good one
06:58:42 <Cheery> it is slow method
06:59:36 <profmakx> well sure, if you haven`t got ANY idea what you can do it is slow to ask for every statement
06:59:41 <shepheb> can anyone recommend an introduction to Kleisli arrows?
06:59:58 <profmakx> I just dont really see any use in reading API docs as in reading a book
07:00:04 <profmakx> thats just plain boring and useless
07:00:31 <Cheery> I were thinking about reading the names of functions in the module
07:00:51 <Cheery> for each module in the standard library haskell comes with
07:01:31 <Cheery> anyway, there's only 42 modules, from which 12 modules are hierachical
07:02:47 <explisixjelly>     No instance for (Ord Temp)
07:02:47 <explisixjelly>       arising from use of `Map.lookup' at fishbowl.hs:24:35-56
07:02:49 <explisixjelly> erm. what?
07:03:24 <daniel_larsson> The type you're using as key needs to implement the Ord type class maybe?
07:03:27 <profmakx> explisixjelly, you dont have an Ord isntance for Temp
07:03:46 <profmakx> @hoogle Temp
07:03:47 <lambdabot> Distribution.Extension.TemplateHaskell :: Extension
07:03:47 <lambdabot> Language.Haskell.Extension.TemplateHaskell :: Extension
07:03:47 <lambdabot> System.IO.openTempFile :: FilePath -> String -> IO (FilePath, Handle)
07:08:02 <explisixjelly> profmakx, Temp is my type
07:08:07 <explisixjelly> yes thank you I understood the message
07:08:17 <explisixjelly> I'm just wondering why Map.lookup suddenly wants a... ooooh.
07:08:19 <explisixjelly> I'm dumb.
07:09:22 <profmakx> thats what you said.
07:09:26 <profmakx> ;)
07:10:54 <georgw> Ok, just starting to use Haskell to solve real (well, academic...) problems. I'd be happy for pointers for the following problem:
07:11:57 * Zao holds his breath in anticipation.
07:11:59 <georgw> I want to read integers from a file, separated by newlines. What's the best way? readFile followed by some hand-tailored readsPrec?
07:12:16 <profmakx> readFile followed by lines
07:12:22 <profmakx> and then read
07:12:35 <quicksilver> :t (map read . lines) <$> readFile "foo.txt"
07:12:38 <lambdabot> forall a. (Read a) => IO [a]
07:13:06 <kjdf> :t (<$>)
07:13:07 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:13:45 <quicksilver> it's fmap by another name
07:16:13 <georgw> Thanks. :-) What's <$> though, haven't encountered that...
07:17:21 <earthy> <$> is fmap renamed.
07:17:33 <earthy> as quicksilver just stated. :)
07:18:24 <georgw> oic. Is that common syntax for some compiler? ghci doesn't seem to know it.
07:18:36 <resiak> so suppose i'm in a reader monad of some form, and i want to do { x <- ask; f x y }.  Is there any magic Applicative combinator goo for writing that as f $op x $op y ?
07:19:29 <resiak> effectively i guess i want to turn f :: a -> b -> m c  into f' :: m a -> b -> m c
07:20:40 <quicksilver> georgw: <$> is in Control.Applicative
07:20:51 <quicksilver> georgw: it's not very important, although I do think that's the nicest way to write it.
07:21:09 <quicksilver> georgw: it's for applying a pure function to the result of a monadic one.
07:21:13 <quicksilver> you might also see
07:21:29 <quicksilver> liftM (map read . lines) (readFile "foo.txt")
07:21:34 <quicksilver> liftM = fmap = <$>
07:21:54 <quicksilver> resiak: f <$> ask <*> pure y
07:21:55 <byorgey> @type \f ma b -> f <$> ma <*> pure b  -- resiak?
07:21:56 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> a1 -> f b
07:22:20 <byorgey> hm, that's not quite the same thing, but close
07:22:21 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
07:23:01 <georgw> Thank you very much. :) That helps a lot, always seem to get stuck in the beginning with the simple stuff in a new language. ;-)
07:27:21 <resiak> quicksilver: hrm!
07:30:44 <quicksilver> resiak: not the answer you wanted?
07:31:45 <resiak> quicksilver: f in that example is a -> b -> c, not a -> b -> m c
07:32:21 <resiak> i'll play with this some more later!
07:36:10 <mightybyte> @maxBound :: Int
07:36:10 <lambdabot> Unknown command, try @list
07:36:18 <resiak> > maxBound :: Int
07:36:24 <lambdabot>  2147483647
07:36:29 <mightybyte> Heh, you beat me to it.
07:37:35 <quicksilver> resiak: then you should have said 'return (f x y)' :P
07:38:01 <quicksilver> resiak: oh, sorry.
07:38:03 <georgw> another newbie question. The interpreter (ghci) does not accept "data Pair a b = Pair a b" even with a let prefix. What's wrong?
07:38:09 <quicksilver> resiak: you just need a 'join' then.
07:38:12 <resiak> georgw: you can't define types in the interpreter
07:38:14 <resiak> quicksilver: aha
07:38:24 <resiak> of course!  thanks :)
07:38:41 <georgw> ok, so do play around I need to put those in a file, load the file and call functions, correct?
07:39:08 <LoLLo> http://it.youtube.com/watch?v=-Gs8sYe4uqM
07:39:08 <lambdabot> Title: YouTube - Linux Ubuntu Power by Pilo
07:39:22 --- mode: ChanServ set +o quicksilver
07:39:37 --- kick: LoLLo was kicked by quicksilver (Haskell Power by #haskell)
07:39:58 <quicksilver> georgw: I'm afraid so, yes.
07:40:08 <quicksilver> georgw: still loading/reloading files is fairly painless.
07:40:56 <georgw> Yep. Was just wondering if this is necessary. Thx.
07:41:30 <allbery_b> there's been discussion about changing that but nobody has provided code yet
07:41:54 <pjd> georgw: if you use screen, it's pretty convenient to open a source file in an editor in one window, and ghci in another
07:42:18 <quicksilver> if you use emacs, have an inferior haskell process in one frame and your source in another
07:42:19 <pjd> reloading in the ghci window with :r, as necessary
07:42:21 <quicksilver> (etc)
07:42:28 <georgw> Dual monitors... veeery convenient. :)
07:42:29 <byorgey> if you use xmonad, it's pretty convenient to open a source file in one window, and ghci in another window next to it =)
07:42:39 --- mode: quicksilver set -o quicksilver
07:42:53 <Cale> byorgey: It's even pretty convenient if you don't use xmonad :)
07:43:01 <byorgey> Cale: hehe, I know =)
07:43:17 <byorgey> if you use Windows, it's pretty convenient to... switch to linux.
07:46:17 <Cale> byorgey: heh
07:50:37 <byorgey> @seen mrd
07:50:37 <lambdabot> mrd is in ##logic, #haskell-blah, #haskell and #ghc. I last heard mrd speak 8h 9m 21s ago.
07:51:12 <byorgey> @tell mrd nice blog posts!
07:51:12 <lambdabot> Consider it noted.
07:51:17 <amiddelk> and if you use visual haskell, you don't need a ghci window open because it compiles automatically all the time... and if it compiles you can ship it
07:52:04 <explisixjelly> by the way, is there such a compile-while-edit-solution for emacs?
07:53:16 <Saizan_> with haskell-mode C-c C-l loads the current file in ghci, opening a buffer
07:53:27 <allbery_b> haskell mode-s inferior ghci has stuff built in for that, yes
07:54:50 <shepheb> I wouldn't mind the always-compiling feature either. actually, I'd rather have a "load in the interpeter, but just tell me in the status line if it has errors or not"
07:55:07 <shepheb> actually, "load in the interpreter. status bar report on success, open buffer on errors"
07:56:09 <explisixjelly> sometimes you just have to use !!
07:56:48 <explisixjelly> if you're doing it often (as in it gets executed often), but only on small lists... would you still consider switching to one of the "magic" array types?
07:57:15 <sebell> magic?
07:57:50 <explisixjelly> those with O(1) access time
07:58:10 <explisixjelly> which you couldn't really implement in haskell. (or could you?)
07:58:44 <sebell> explisixjelly: Why not?
07:58:51 <explisixjelly> sebell, well, hm, how? 8)
07:59:04 <Saizan_> do you update those lists often?
07:59:15 <explisixjelly> Saizan_, no...
07:59:29 <explisixjelly> Saizan_, I build them once and then just pass them through
07:59:46 <explisixjelly> they usually have around 2 to 5 elements
07:59:47 <shepheb> sounds like a job of IArrays
07:59:53 <shepheb> although at that point
07:59:59 <shepheb> !! might be just as well.
08:00:15 <explisixjelly> shepheb, yes, I consider IArrays to be one of the "magic" types 8) and as I said, I don't know if it's worth switching
08:00:20 <shepheb> if you don't update them, though, IArrays give you O(1) lookup
08:00:37 <explisixjelly> shepheb, yeah, I know...
08:00:39 <shepheb> I'm not sure. if a _lot_ of lookups are being called, maybe
08:00:48 <explisixjelly> hmm.
08:00:53 <explisixjelly> I could just try it out. see if it's worth it.
08:01:08 <shepheb> I think IArrays use sharing, so you have O(u) updates, where u is the number of changed cells.
08:02:04 <Saizan_> IArray is a class.
08:02:41 <Saizan_> with instances like Data.Array and Data.DiffArray (plus the unboxed variants)
08:03:16 <shepheb> Saizan_: oh, right. I guess I'm referring to Data.Array.
08:03:25 <Saizan_> the first just make a copy on every update (modulo optimizations, which are often trigged)
08:05:54 <Saizan_> DiffArrays try to be clever by exposing a pure interface while internally using mutation and a log of updates, so references to older versions get gradually slower
08:06:07 <Saizan_> but they have hhigh contant factors at the moment
08:06:36 <mrd> byorgey: thanks
08:06:36 <lambdabot> mrd: You have 1 new message. '/msg lambdabot @messages' to read it.
08:06:44 <explisixjelly> sebell, so, uhm, how?
08:07:11 <Saizan_> http://www.haskell.org/haskellwiki/Arrays <-- for more, and better explained :)
08:07:16 <lambdabot> Title: Arrays - HaskellWiki
08:07:38 <Japsu> @type ?viimesyksinen (.) ?nolla (.) ?toleranssi . ?kokeilu
08:07:44 <lambdabot> forall t t1 a b a1 b1 (f :: * -> *) a2 b2 (f1 :: * -> *) (f2 :: * -> *). (Functor f2, ?kokeilu::f2 a, ?toleranssi::t1, Functor f1, ?nolla::t, Functor f, ?viimesyksinen::((a1 -> b1) -> f a1 -> f b1) -
08:07:44 <lambdabot> > t -> ((a2 -> b2) -> f1 a2 -> f1 b2) -> t1 -> a -> b) => f2 b
08:08:31 <quicksilver> explisixjelly: with small lists, !! should be fine, but it sounds unusual to do that 'often'.
08:08:37 <quicksilver> explisixjelly: are you sure you don't want tuples or something? :)
08:10:16 <mrd> erk, sequence.complete.org completely changed its layout
08:11:49 <jaj> Hi! I want to start a new project and I need database connectivity. I was wondering whether I should use the hsql or the haskelldb frontend.
08:12:37 <Saizan_> haskellDB uses either HDBC or HSQL as backends
08:14:42 <sclv> hsql is not in the best shape at the moment although i understand foax are working on it, and haskelldb is really cool but only gives you a subset of standard db functionality.
08:14:48 <oklokok> how does haskell do hashmaps?
08:15:04 <sclv> takusen is sort of fancy, but you may want to try that, otherwise hdbc is in good shape at the moment.
08:15:27 <sclv> oklokok: slowly and painfully.
08:15:35 <oklokok> :)
08:15:40 <oklokok> is there a way though?
08:16:04 <oklokok> i guess i can do with a list if it's much more complicated.
08:16:12 <sclv> you can look at the data.hashtable source for yourself... but its all in the IO monad because you need mutability...
08:16:13 <quicksilver> oklokok: use Data.Map
08:16:17 <jaj> sclv: thanks I'll use haskelldb-hdbc then
08:16:24 <quicksilver> oklokok: don't fuss about that fact that it isn't a hashmap, it doesn't matter much.
08:16:28 <quicksilver> ;)
08:16:56 <oklokok> well, i don't actually need speed, so i'll just use a list.
08:17:14 <quicksilver> Data.Map is a more convenient interface for some operations
08:17:18 <quicksilver> depends what you're doing.
08:17:23 <quicksilver> List-of-pairs can be fine too though.
08:26:50 <Cale> Data.Map is awesome. You basically shouldn't even bother looking at Data.HashTable
08:27:50 <dejones> Cale: That is excellent advise.  Using Data.Map was much, much easier!
08:29:29 <davidL> is it worth the trouble to implement the KMP algorithm rather than using GHC's implementation of isInfixOf?
08:30:19 <Cale> davidL: Depends on how big a string matching task you need to perform, I suppose.
08:31:06 <quicksilver> KMP is only a win for "fairly long" substrings where "fairly long partial matches" are expected.
08:31:09 <quicksilver> IYSWIM.
08:31:26 <dino-> Is HashTable older or something? It seems like Data.Map can do everything it can do, like be in IO if you need it to be.
08:31:27 <Cale> http://twan.home.fmf.nl/blog/haskell/Knuth-Morris-Pratt-in-Haskell.details
08:31:29 <lambdabot> Title: Knuth-Morris-Pratt in Haskell - 21 thoughts, http://tinyurl.com/23rvcf
08:32:02 <quicksilver> So if you're trying to match "aaaaaaaaaaaaaaaaaaaaab" amongst some text which has lots and lots of occurences of "aaaaaaaaab"
08:32:11 <davidL> Cale: it would be looking for a GIF or JPEG or PNG signature in a network stream
08:32:12 <Cale> dino-: It's old and used in parts of GHC, but Data.Map outperforms it pretty consistently.
08:32:14 <quicksilver> then a naive isInfixOf wastes a moderate amount of time.
08:32:49 <dino-> Cale: I see, so it's not just the awesomeness of being generalized over all Monad.
08:32:50 <Cale> davidL: Those strings are pretty short. The usual isInfixOf should do rather well.
08:32:50 <quicksilver> davidL: for short search strings ("GIF98a" ?) KMP is a waste of time.
08:32:55 <dino-> That's so cool about it.
08:33:07 <Cale> dino-: It's not generalised over all monads, is it?
08:33:08 <oklokok> numbers <-> characters conversion
08:33:09 <oklokok> how to
08:33:14 <quicksilver> dino-: Data.Hashtable has better asymptotic behaviour.
08:33:20 <quicksilver> dino-: but, real programs aren't asymptotic :)
08:33:41 <Cale> Data.HashTable stops working before that asymptotic improvement takes effect.
08:33:42 <davidL> what about Boyer-Moore? or would that be a waste of time also?
08:33:50 <quicksilver> Cale: however, GHC has its own, better, hashing algorithm now doesn't it?
08:34:01 <quicksilver> Cale: they use it to intern symbols?
08:34:14 <quicksilver> oklokok: ord / chr , in Data.Char
08:34:19 <Cale> quicksilver: I'm not sure. I don't know why Data.HashTable would still be in base otherwise.
08:34:31 <dino-> Cale: Um I was referring to things like this:  Data.Map.lookup :: (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
08:34:47 <Cale> dino-: Ah, heh, that's actually slightly evil.
08:34:54 <dino-> But Data.Hashtable.lookup is ...HashTable key val -> key -> IO (Maybe val)
08:34:56 <Cale> It doesn't really work in any monad
08:35:00 <quicksilver> dino-: that's really just using a monad for failure.
08:35:01 <Cale> It works in any MonadZero.
08:35:04 <quicksilver> tis ugliness
08:35:18 <dino-> quicksilver: Sure, but Hashtable is not happy with me so much if I'd like to use Error and no IO
08:35:24 <Cale> But the MonadZero class no longer exists due to stupidity in the Haskell 98 process.
08:35:51 <Cale> dino-: IO is not one of the monads you should be using for M there.
08:35:54 <davidL> anyway, thanks Cale and quicksilver, I suppose I wont waste my time with KMP or BM and use the standard isInfixOf
08:36:04 <Cale> davidL: That's probably sane.
08:36:11 <dino-> ya. :(
08:36:21 <Cale> davidL: The headers you're looking for are only a few characters long.
08:36:25 <dino-> <- trying to learn, but it's a slow process
08:36:30 <quicksilver> dino-: hashtable is not using that monad for error reporting
08:36:35 <dcoutts_> Cale, quicksilver: ghc hardly uses Data.HashTable, it could be moved into the containers package or deprecated into a separate package
08:36:35 <quicksilver> dino-: at least, not primarily
08:36:54 <quicksilver> dino-: it's using that monad primarly to mutate its underlying mutable structure.
08:37:04 <quicksilver> dino-: the error reporting is by the by
08:37:14 <jaj> I just installed the 'pretty' package under a non-default prefix and now the cabal system always yields me an error
08:37:17 <Cale> dcoutts_: Yeah, it should probably be moved into a separate package of its own for people who really want it.
08:37:19 <dcoutts_> Cale, quicksilver: amusingly the only use of Data.HashTable is for its hashString function :-)
08:37:20 <quicksilver> (it's not very hard to lift IO Errors into ErrorT IO anyway, if that's the objective)
08:37:21 <hpaste>  jaj pasted "cabal unhappy after installation of 'pretty' under --prefix" at http://hpaste.org/6080
08:37:22 <dino-> But isn't there value in not forcing it to be Maybe?
08:37:44 <davidL> Cale: and it doesn't matter that the haystack is very large?
08:37:53 <Cale> dino-: There's some. You could use lists, for instance.
08:38:08 <dino-> Or Error with the snazzy do { } `catchError` ...
08:38:12 <Cale> davidL: Not so much as the needle being large.
08:38:27 <davidL> Cale: alright, thank you
08:38:34 <dino-> If exception stuff is desired.
08:39:08 <Cale> davidL: Your needles are only a few characters. You'd be able to get a speedup of approximately the length of your needle with a smarter algorithm, but even that is relatively unlikely.
08:39:48 <davidL> very well, I am convinced
08:39:58 <Cale> If you had many more needles, there are techniques for searching for multiple needles at once which are better as well.
08:40:12 <Cale> But you only have a few, so they're unlikely to improve things.
08:40:42 <davidL> I don't suspect more than three or four needles
08:40:52 <Cale> dino-: Yeah, it probably throws a proper exception in IO, so perhaps I shouldn't have been so quick to say that IO is unsuitable.
08:41:12 <dcoutts_> jaj: looks like you broke cabal by re-installing pretty, did you really need to re-install pretty?
08:41:30 <dino-> But I was thinking that this generalization of the failure is part of what's so cool about Data.Map.
08:41:38 <Cale> dino-: lookup uses 'fail', which isn't implementable in most monads, leaving you with a call to error which is annoying to debug.
08:41:57 <dino-> So now I'm sitting here thinking 'please say that's a little true so that I feel like I'm getting things'
08:42:00 <dino-> heh
08:42:05 <Cale> Sure, it's a little true :)
08:42:16 <dino-> I see
08:42:19 <Cale> It would be much nicer if it used something like mzero instead.
08:42:37 <dino-> This is the aforementioned MonadZero stupidity, etc..
08:42:41 <Cale> yeah
08:43:09 <smg> @src Integral
08:43:09 <lambdabot> class  (Real a, Enum a) => Integral a  where
08:43:09 <lambdabot>     quot, rem, div, mod :: a -> a -> a
08:43:09 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
08:43:09 <lambdabot>     toInteger           :: a -> Integer
08:43:20 <smg> @src Integer
08:43:20 <lambdabot> data Integer = S# Int#
08:43:20 <lambdabot>              | J# Int# ByteArray#
08:43:29 <smg> wtf "#"?
08:43:40 <Cale> dino-: fail isn't really supposed to be a method of the Monad class. It got stuck in there, because people wanted to oversimplify the do-notation translation.
08:43:42 <byorgey> smg: low-level unboxed baked-in ghc goodness.
08:43:54 <jaj> dcoutts_: haskelldb said it couldn't find it
08:43:58 <byorgey> smg: # = "pay no attention to the man behind the curtain"
08:44:06 <Cale> dino-: Things like this give people the wrong idea that all monads support some means of failure.
08:44:18 <dino-> I had that vague impression, yeah.
08:44:31 <quicksilver> it does have its benefits though
08:44:34 <Cale> It's not true, but people abuse it.
08:44:41 <quicksilver> it's a constant source of lively and entertaining debate on #haskell.
08:44:42 <dino-> Or at least that they call can do something reasonable with failure if written to do so.
08:44:49 <dino-> s/call/all/
08:45:09 <jaj> dcoutts_: Could not find module `Text.PrettyPrint.HughesPJ': it is a member of package pretty-1.0.0.0, which is hidden
08:45:16 <Cale> dino-: Things like the State monad can't really do a whole lot though.
08:45:34 <jaj> dcoutts_: so I thought I had to install pretty
08:45:36 <Cale> dino-: Their only option is just to crash your whole program.
08:45:51 <dcoutts_> jaj: it was already installed
08:45:58 <dcoutts_> @where cabal-faq
08:45:58 <lambdabot> I know nothing about cabal-faq.
08:46:17 <dcoutts_> @where+ cabal-faq http://haskell.org/haskellwiki/Cabal/FAQ
08:46:17 <lambdabot> Done.
08:46:23 <dcoutts_> jaj: see ^^^
08:46:31 <dino-> hmm
08:46:58 <jaj> dcoutts_: thanks
08:48:07 <explisixjelly> I'm still not sure how to indent sometimes.
08:48:26 <byorgey> jaj: what are you trying to build?  maybe you need to add pretty to the build-depends: field in the .cabal file?
08:48:27 <explisixjelly> (just with respect to style)
08:49:23 <byorgey> explisixjelly: there's not really any accepted standard, only vague generally-accepted cultural practices =P
08:49:47 <dino-> quicksilver, Cale, etc: Thanks for talking about that. I learn a lot here.
08:49:53 <byorgey> explisixjelly: feel free to paste some code on hpaste.org if you want comments on your indentation.
08:49:58 <explisixjelly> byorgey, yeah... unfortunately, I still don't have my best practices %)
08:50:10 <explisixjelly> byorgey, thanks, I'll do that
08:51:13 <smg> @src RealFloat
08:51:14 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
08:51:24 <smg> -.-
08:51:56 <shepheb> ChanServ: @hoogle RealFloat
08:52:03 <shepheb> huh?
08:52:07 <shepheb> @hoogle RealFloat
08:52:08 <lambdabot> Prelude.RealFloat :: class (RealFrac a, Floating a) => RealFloat a
08:52:16 <smg> ah okay
08:52:26 <smg> so RealFloat must be a Subclass of Fractional
08:52:54 <quicksilver> ghci is better at answering these questions than lambdabot
08:53:00 <quicksilver> type :info RealFloat
08:53:04 <quicksilver> (and the other classes)
08:53:13 <smg> ah cool
08:53:36 <quicksilver> but, yes, RealFloat subclasses RealFrac which subclasses Fractional.
08:53:54 <explisixjelly> there's no thing such as forward declaration of data types in haskell, right?
08:54:01 <biouser> I am trying to store the output of my function as a new variable
08:54:05 <explisixjelly> w/ respect to cyclic imports
08:54:12 <quicksilver> explisixjelly: everything can be forward or backward.
08:54:20 <quicksilver> neither helps with the cyclic import problem :)
08:54:28 <quicksilver> within a single file, declarations are not ordered.
08:54:30 <biouser> the output is a list of 4-tuples... [(a,b,c,d),(q,w,e,r)...]
08:55:12 <biouser> a= head $ closedKnights [1,4,1,4,1,4,1,4] was my first thought
08:55:16 <quicksilver> smg: here 'Real' is used in the 'not strictly complex' sense rather than the more common programming language 'not integer' sense.
08:55:27 <explisixjelly> quicksilver, in C++ at least a forward declaration isn't the same as a definition
08:55:33 <quicksilver> biouser: that would make 'a' the first tuples
08:55:35 <biouser> where >head $ closedKnights ... gives back the list of 4-tuples
08:55:36 <quicksilver> (a,b,c,d)
08:55:42 <quicksilver> oh
08:55:46 <quicksilver> ok then, that's fine.
08:55:48 <byorgey> explisixjelly: I know what you mean, and you're right, there's no such thing in Haskell
08:55:51 <Saizan_> does cabal uses splitobjs for libraries by default?
08:56:05 <quicksilver> explisixjelly: right, but such things are not necessary in haskell because there is no order to declarations.
08:56:09 <quicksilver> explisixjelly: that's the point I was making.
08:56:11 <biouser> parse error on input '='
08:56:24 <explisixjelly> but, yeah, won't work like that. which is a pity, because now I have to change datatypes just according to how I chose to split the types up into several files
08:56:43 <quicksilver> biouser: if you're working in ghci you need "let"
08:56:50 <byorgey> explisixjelly: you *can* do cyclic imports though.
08:56:52 <quicksilver> let a = head $ closedKnights ....
08:56:56 <biouser> oh yeah, 'let' in ghci...
08:57:01 <biouser> gets me every day
08:57:01 <explisixjelly> quicksilver, ok, unfortunately, I have a type using a type declared in another module which I can't import because it relies on that very data structure.
08:57:07 <explisixjelly> byorgey, I can?
08:57:17 <byorgey> explisixjelly: I forget how, something to do with hs-boot files or something like that
08:57:28 <byorgey> explisixjelly: check the ghc documentation... I'll look too, just a minute
08:57:34 <explisixjelly> byorgey, ahah? %)
08:57:34 <quicksilver> explisixjelly: typically my first reaction is "are you *sure* you want cyclic module dependencies? that's normally not very sensible"
08:57:46 <quicksilver> explisixjelly: then my second reation is to point you to the docs.
08:58:17 <quicksilver> typically if I have A <-> B (cyclic dep) I factor out the common base into 'Base' and have A import Base and B import Base.
08:58:21 <biouser> how can I check to see if any of the elements of my list of 4-tuples is the same?
08:58:22 <explisixjelly> quicksilver, well, I think it would be very ugly to put those two types into the same file. but they use each other.
08:58:28 <quicksilver> and typically I find that feels more pleasant anyway.
08:58:39 <quicksilver> (sometimes 'Base' is just a bunch of types)
08:58:42 <byorgey> explisixjelly: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
08:58:44 <lambdabot> Title: 5.6. Filenames and separate compilation, http://tinyurl.com/yyunf2
08:58:46 <biouser> where (1,2,3,4) = (4,3,2,1) too
08:58:55 <explisixjelly> quicksilver, no. no, wouldn't be good with what I have here.
08:58:57 <explisixjelly> byorgey, ah, thanks a lot
08:59:11 <quicksilver> explisixjelly: I accept that there are cases where cyclic deps are the right answer.
08:59:20 <quicksilver> it's just my experience finds those cases to be very rare.
08:59:36 <quicksilver> normally good modularisation ends up layering things
08:59:47 <quicksilver> where nothing in layer n depends on anything else in a higher layer.
08:59:55 <explisixjelly> quicksilver, I really believe that is such a case. both types are huge, but one of those types is used in just one part of my compiler
08:59:56 <biouser> actually that equivalence was wrong (1,2,3,4) != (4,3,2,1)
08:59:56 <byorgey> biouser: well, it's ugly with 4-tuples.  are you sure you want 4-tuples and not 4-element lists?
09:00:23 <quicksilver> explisixjelly: if the other type (which is not used in just one part) uses the first type (which is)
09:00:33 <biouser> byorgey, I have been thinking about changing it all to lists, [] right?, but now they are ()
09:00:33 <byorgey> biouser: but in general you could write a function which decides equality for your elements (whatever that should mean in your case)
09:00:36 <quicksilver> explisixjelly: then I would argue the first type is *actually* used everywhere the other one is :)
09:00:41 <byorgey> biouser: yes
09:00:56 <quicksilver> well it's not too hard to sort 4-tuples
09:00:59 <quicksilver> so you could check.
09:01:16 <biouser> order is important, I wasn't thinking right before
09:01:22 <mrd> byorgey: hey, thanks.  but how did you get at the articles.  sequence.c.o seems to be completely changed now and doesn't link to anything
09:01:25 <quicksilver> sort4tup (a,b,c,d) = let [w,x,y,z] = sort [a,b,c,d] in (w,x,y,z)
09:01:28 <quicksilver> ah.
09:01:50 <byorgey> mrd: I don't know, it showed up on Planet Haskell, so I read it. =)
09:02:46 <jaj> can anybody tell me where cabal stores its database by default?
09:03:07 <biouser> a=[(a,b,c,d),(q,w,e,r), (x,y,z,w)...] I want to make sure that no (t,y,u,i)=(f,g,h,j)
09:03:11 <biouser> in a
09:03:16 <skorpan> @Int
09:03:16 <lambdabot> Maybe you meant: ft let wn
09:03:21 <skorpan> maybe.
09:03:30 <explisixjelly> quicksilver, one of those types is called "Error"
09:03:30 <skorpan> @type Int
09:03:34 <lambdabot> Not in scope: data constructor `Int'
09:03:35 <explisixjelly> quicksilver, there are different errors
09:03:37 <skorpan> > :t Int
09:03:37 <lambdabot>   parse error on input `:'
09:03:43 <skorpan> fuck it
09:03:51 <byorgey> biouser: in general if you have a list of things, and you want to see whether any are equal, you could sort the list and then use 'group', and see whether any of the resulting groups have length more than 1.
09:03:57 <explisixjelly> quicksilver, one or two of those errors also contain that other data type
09:04:11 <byorgey> > filter ((>1) . length) . group . sort $ [1,4,5,9,2,3]
09:04:12 <lambdabot>  []
09:04:17 <byorgey> > filter ((>1) . length) . group . sort $ [1,4,5,9,2,3,1,9]
09:04:18 <lambdabot>  [[1,1],[9,9]]
09:04:19 <biouser> byorgey, that sounds like it might work
09:04:30 <mrd> yea I use that trick to decide poker hands
09:04:42 <explisixjelly> quicksilver, and while the other data type doesn't reference Error, some things very close to it, that I'd like to have in the same file, do
09:04:55 <byorgey> biouser: if your notion of equality between elements is not the same as the built-in Eq instance, then use groupBy instead of group.
09:05:05 <explisixjelly> quicksilver, but, yeah, not really feeling like messing around with cyclic imports, I just changed things a bit
09:05:12 <quicksilver> ;)
09:05:23 <explisixjelly> quicksilver, for now, the relevant Error constructors take a string, that's also ok in that case.
09:05:31 <byorgey> skorpan: what are you trying to do?
09:05:53 <byorgey> skorpan: also, note this is supposed to be a family-friendly channel
09:06:30 <daniel_larsson> @i Int -- maybe?
09:06:30 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
09:06:53 <daniel_larsson> oh, ghci equivalent of :i not available?
09:06:57 <quicksilver> nope
09:07:03 <quicksilver> it's a minor annoyance, btu then
09:07:05 <quicksilver> it's quite verbose :)
09:07:09 <daniel_larsson> yea )
09:07:10 <byorgey> @src Int  -- maybe?  not very useful though
09:07:10 <lambdabot> Source not found. You type like i drive.
09:07:19 <quicksilver> it's probably just as well that they do it in their own ghcis
09:07:51 <biouser> byorgey, wow, thanks, need to digest that for a while
09:08:25 <byorgey> biouser: sure.  come back and ask if you experience any indigestion =)
09:09:58 <Japsu> @type (.)(.)
09:10:00 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f1, Functor f) => f1 (a -> b) -> f1 (f a -> f b)
09:10:46 <jaj> I thought I removed everything cabal/ghc related but I still get that error concerning pretty, so cabal must have stored it's data somewhere
09:11:00 <shapr> @users
09:11:00 <lambdabot> Maximum users seen in #haskell: 463, currently: 421 (90.9%), active: 19 (4.5%)
09:17:04 <dcoutts_> jaj: ghc-pkg list pretty
09:17:24 <dcoutts_> jaj: does it tell you you've got two versions installed?
09:17:50 <jaj> dcoutts_: currently I deinstalled ghc and I can't install it anymore
09:18:04 <mae> hello haskellites
09:18:08 <byorgey> Japsu: note, (.) has been reappropriated by Cale, so expect different results in ghci =)
09:18:11 <byorgey> @type (.)
09:18:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:18:23 <byorgey> hi mae
09:18:35 <mae> type Tofu = Bananas
09:18:45 <mae> random declaration of the day
09:18:59 <smg> @hoogle quaternion
09:19:02 <lambdabot> No matches found
09:19:06 <dcoutts_> jaj: so why can't you install ghc now?
09:19:19 <Japsu> byorgey: hmm yeah, I was kinda wondering about that functor thingy
09:19:24 <Japsu> @undef
09:19:25 <lambdabot> Undefined.
09:19:32 <Japsu> @type (.) . (.)
09:19:33 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:19:40 <Japsu> interesting
09:19:45 <Deewiant> @check \a b c -> (a . b) c == (a `fmap` (b::Int->Int)) (c::Int)
09:19:46 <lambdabot>  OK, passed 500 tests.
09:20:00 <jaj> dcoutts_: because when it installs it tries to register some packages and then it runs into the cabal error. I'll try to reproduce it
09:20:03 <byorgey> Japsu: to recover the old definition of (.), replace f with (r ->)
09:20:13 <Japsu> is that to support . between Expr "functions"?
09:20:20 <Japsu> @type f . g
09:20:21 <dcoutts_> jaj: remove your locally registered packages rm -r ~/.ghc
09:20:21 <byorgey> Japsu: no
09:20:21 <lambdabot> forall a b (f :: * -> *). (Functor f, SimpleReflect.FromExpr (f a), SimpleReflect.FromExpr b, Show a) => f b
09:20:41 <byorgey> Japsu: it's to unify (.) with fmap
09:21:06 <Japsu> byorgey: hmm ok
09:21:10 <mae> so guys, is there  a primer on quickcheck you can point me too
09:21:11 <jaj> dcoutts_: oh I think that's what I was looking for
09:21:20 <Deewiant> is this going to end up in base or is it just for lambdabot
09:21:26 <Japsu> what about unifying fmap with map? ;)
09:21:32 * Japsu demands!
09:21:38 <Cale> Japsu: that could be done as well :)
09:21:40 <dcoutts_> jaj: I bet what you did was to register the pretty package locally, then ghc will use that one in preference to the global one, however the installed cabal package was built against the global pretty package and fails to link against the extra copy you made
09:21:40 <Japsu> > fmap (+1) [1..3]
09:21:41 <lambdabot>  [2,3,4]
09:21:45 <quicksilver> mae: the first google hit for quickcheck has one.
09:21:51 <Cale> > (+1) . [1..3]
09:21:53 <lambdabot>  [2,3,4]
09:22:01 <Japsu> Cale: lol, that's evil
09:22:06 <Deewiant> > (+1) . 1
09:22:06 <lambdabot>   add an instance declaration for (Num (f a))
09:22:15 <jaj> dcoutts_: yes that's exactly what happened
09:22:40 <smg> > map (+) [1..3]
09:22:41 <lambdabot>  [<Integer -> Integer>,<Integer -> Integer>,<Integer -> Integer>]
09:28:13 <jaj> > <$> (+1) [1..3]
09:28:13 <lambdabot>   parse error on input `<$>'
09:28:44 <jaj> seems like I got the fmap=<$> part wrong
09:28:47 <ddarius> > ((+1) <$> [1..3],(<$>) (+1) [1..3])
09:28:48 <lambdabot>  ([2,3,4],[2,3,4])
09:28:50 <quicksilver> no, you didn't
09:28:53 <quicksilver> you just spelt it wrong
09:28:58 <quicksilver> > + 1 3
09:28:58 <lambdabot>   parse error on input `+'
09:28:59 <ddarius> @src (<$>)
09:28:59 <lambdabot> f <$> a = fmap f a
09:29:03 <quicksilver> this doesn't work for the same reason
09:29:03 <Deewiant> > (<$>) (+1) [1..3]
09:29:04 <lambdabot>  [2,3,4]
09:29:10 <quicksilver> you can't use operators prefix
09:29:13 <Deewiant> @src (.)
09:29:13 <lambdabot> (.) f g x = f (g x)
09:29:14 <quicksilver> operators are infix!
09:29:22 <quicksilver> you can wrap them in () to use them prefix, though.
09:29:37 <Deewiant> so is (.) equivalent to (<$>) now?
09:31:24 <jaj> quicksilver: yeah I forgot the parentheses
09:31:48 <quicksilver> Deewiant: in lambdabot, yes.
09:33:53 <dejones> hello, I'm trying to take a string to a double, and I was using read s :: Double, but I was wondering if there is a way to catch an exception if the string can't be converted to a double?
09:34:16 <dejones> Possibly using the Maybe monad?
09:34:33 <Cale> dejones: reads
09:34:40 <Cale> > reads "5.23" :: Double
09:34:41 <lambdabot>  Couldn't match expected type `Double'
09:34:48 <Cale> > reads "5.23" :: [(Double, String)]
09:34:49 <lambdabot>  [(5.23,"")]
09:34:56 <Cale> > reads "x" :: [(Double, String)]
09:34:56 <lambdabot>  []
09:35:05 <Cale> > reads "5.23 apple" :: [(Double, String)]
09:35:06 <lambdabot>  [(5.23," apple")]
09:35:26 <dejones> hmm
09:36:03 <Cale> If there were ever any ambiguity, you'd get a longer list of possible parses, but in this case, there won't be.
09:36:05 <dejones> > reads "x" :: [Double]
09:36:05 <lambdabot>  Couldn't match expected type `Double'
09:36:32 <Cale> > map fst (reads "x") :: [(Double, String)]
09:36:35 <lambdabot>  []
09:36:36 <Cale> > map fst (reads "x") :: [Double]
09:36:37 <lambdabot>  []
09:36:50 <ddarius> :t reads
09:36:51 <lambdabot> forall a. (Read a) => String -> [(a, String)]
09:37:03 <Cale> > map fst (reads "5.32 hello") :: [Double]
09:37:04 <lambdabot>  [5.32]
09:37:11 <ddarius> :t msum . reads
09:37:14 <lambdabot> forall a. (Read a, MonadPlus ((,) a)) => String -> (a, String)
09:37:24 <dejones> Interesting.
09:38:07 <dejones> Thanks Cale.
09:38:17 <dejones> and ddarius
09:38:17 <Cheery> what'd be good with opengl?
09:38:25 <ddarius> :t foldr (mplus . return) mzero . reads
09:38:29 <lambdabot> forall (m :: * -> *) a. (Read a, MonadPlus m) => String -> m (a, String)
09:38:35 <Cheery> sdl sucks quite lot, I think.
09:38:52 <Cheery> I'd need joystick stuff and window stuff
09:38:57 <quicksilver> I believe that sdl does not suck.
09:38:58 * ddarius hugs higher order functions.
09:39:01 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6083
09:39:05 <quicksilver> but, I have never used it.
09:39:13 <smg> someone have a look at that paste?
09:39:14 <quicksilver> I think SDL is very likely your best bet if you need joystick support.
09:39:24 <ddarius> My experience with SDL is that it is exactly what it says on the box.
09:39:34 <quicksilver> smg: Quaternion is not a type.
09:39:43 <quicksilver> smg: therefore it cannot be an instance of Num.
09:39:46 <Cheery> ddarius: well, almost
09:39:55 <quicksilver> smg: 'Quaternion Int' is a type, though. That could be.
09:40:05 <quicksilver> smg: or, most generally, I suspect : Num a => Quaternion a
09:40:18 <ddarius> Incidentally, type Quaternion a = Complex (Complex a)
09:40:35 <Cheery> I don't like it, it's too simple with redundant stuff in other place
09:40:50 <Cheery> wrong things have been removed and wrong things have been added
09:41:27 <b_jonas> I think Num a is not enough for Quaternion a to be a Num, because abs would lead out of the domain
09:41:34 <b_jonas> abs has to take a square root
09:41:36 <ddarius> Maybe.  I haven't used it in several years really.
09:41:43 <smg> quicksilver: i see now it complains about (+) isn't a visible method
09:41:46 <b_jonas> the docs says RealFloat a => Num (Complex a)
09:41:56 <b_jonas> but that's just a detail probably not relevant here
09:41:57 <Philippa> Cheery: which would you drop, which would you add?
09:42:35 <quicksilver> b_jonas: that's probably true but I was answering the question at a more trivial level.
09:42:43 <b_jonas> quicksilver: yep
09:42:47 <quicksilver> b_jonas: smg was only after defining a (+) method at this point, and that's fine :)
09:42:49 <Cheery> probably multiple windows, probably I would remove the event system and replace it with callbacks, probably would do some finetuning for input handling, etc.
09:43:04 <byorgey> abs shouldn't be in Num anyway =)
09:43:09 <smg> hehe
09:43:16 <smg> data.hs:77:4: `+' is not a (visible) method of class `Quaternion' <--
09:43:31 <byorgey> class Quaternion ?
09:43:34 <Philippa> okay, so one of those is an improvement but hasn't been recent for most games until recently, one's a matter of architectural choice and one's finetuning
09:43:38 <Philippa> that could be a lot worse
09:43:39 <Cheery> also, probably would remove that stupid dependencies of different seemingly separate items like input and window
09:43:49 <b_jonas> maybe
09:43:57 <Philippa> those stupid dependencies are often necessary to be portable
09:43:58 <Cheery> and give both input with and without window
09:44:26 <smg> byorgey: i don't now what ghci does ...
09:44:30 <smg> http://hpaste.org/6083
09:44:35 <smg> there is nothing about a class
09:44:37 <quicksilver> replacing events with callbacks is very contraversial
09:44:47 <quicksilver> and likely to make other language bindings a nightmare
09:45:02 <quicksilver> since SDL has bindings to almost a million languages, I can understand why they don't opt for that.
09:45:06 <Philippa> definitely, events need far less FFI power than callbacks
09:45:22 <byorgey> smg: did you read what quicksilver wrote above?
09:45:35 <smg> yeah i wrote that in my source
09:45:36 <quicksilver> in a suitably expressive language like haskell it's trivial to implement a nice callback system on top of events
09:45:47 <quicksilver> if the programmer wants to give up his event loop.
09:45:47 <ddarius> I like the simplicity of the SDL system and what quicksilver said.
09:46:05 <quicksilver> In the absence of a reliable threading system, having to use a provided event loop can be a real pain.
09:46:07 <Cheery> oh well, events are something I'm not sure about
09:46:18 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/6084
09:46:27 <ddarius> Events are dual to threads.
09:46:29 <smg> ddarius: paste 6084 is it
09:46:30 <Cheery> when combined with multithreading they don't seem so bad
09:47:02 <ddarius> smg: Num (Quaternion a)
09:47:17 <Cheery> but still, those small inconsistency -things are something I don't like about
09:47:45 <smg> ddarius: mh?
09:47:50 <ddarius> Well SDL's growth is probably best described as "organic"
09:48:15 <byorgey> smg: you want instance (Num a) => Num (Quaternion a) where ...
09:48:25 <Cheery> and the fact that I don't care much about drawing stuff, so why should I get the SDL_Surface object when I go to opengl ?
09:48:35 <byorgey> smg: that says, basically, "as long as 'a' is an instance of Num, then 'Quaternion a' is an instance of Num'
09:49:24 <Philippa> Cheery: historically, games have avoided multithreading. When SDL was first put together, the standard advice was to avoid them like the plague
09:49:36 <Philippa> it's only really things like the shift to multicore that've changed that
09:49:40 <ddarius> For good reason.
09:49:40 <Cheery> how so?
09:49:48 <Cheery> why did they avoided multithreading?
09:49:55 <dcoutts_> Cheery: it's hard
09:49:59 <Philippa> because it makes a snake pit look safe in a gamedev context
09:50:01 <ddarius> Events have traditionally been associated with "real-time" computing.
09:50:02 <Cheery> I know average game programmer has no wit
09:50:08 <Philippa> especially in a gamedev circa 2000 context
09:50:27 <Philippa> That means that one average programmer on your team means you'll never be able to debug safely
09:51:17 <Philippa> you'll get devoured by heisenbugs and be lucky if you know whose fault it was
09:51:24 <Cheery> lol
09:51:24 <Cheery> that's true.
09:51:38 <Cheery> but that hasn't changed anyway, except in the time of haskell when you need less those average programmers
09:51:57 <Cheery> and anyway, if you need them, you can restrict them enough that hell doesn't happen
09:52:10 <Philippa> the amount of education about threading's changed somewhat and people are wising up about architecture
09:52:42 <Philippa> but that doesn't mean that an approach that wants multithreading to work properly was a good idea in 2000, or even a not-totally-stupid one
09:52:53 * RayNbow is fooling around with Djinn...
09:53:09 <RayNbow> I can't wait till I can compile Readline for Windows :p
09:53:21 <hpaste>  Deewiant annotated "(no title)" with "this should work" at http://hpaste.org/6083#a1
09:55:01 <Cheery> I wonder..
09:55:04 <hpaste>  byorgey annotated "(no title)" with "need parens around (Quaternion a)" at http://hpaste.org/6083#a2
09:55:24 <Cheery> SDL were made to fit the limitations in each system into an another
09:55:43 <Cheery> since it has some idiotic things and some annoyances, etc.
09:55:50 <Cheery> What about the opposite approach?
09:56:07 <ddarius> DirectX?
09:56:12 <Cheery> nop.
09:56:59 <Cheery> Say you define clearly in haskell what sort of interfaces you require for each thing, then implement them, for the defeat of each operating system
09:57:48 <Philippa> then you run into some whacky piece of hardware. There's a reason that since DX7 we've talked about classes of 3D hardware based on the API version
09:57:49 <Cheery> and force the behavior for each thing
09:58:13 <Philippa> then you discover that you don't have enough pull over the organisations whose systems you're trying to interoperate with and you lose
09:58:33 <Philippa> you're not a console manufacturer and you're not Microsoft. 'nuff said.
09:58:48 <Cheery> hm.. if you mean that I'd even try to make it work with windows, forget it. :)
09:59:06 <Philippa> and you've just dropped one of SDL's objectives in the process
09:59:10 <nominolo> @seen dcoutts
09:59:10 <lambdabot> dcoutts is in #gentoo-haskell, #haskell-soc, #haskell-overflow, #haskell and #ghc. I last heard dcoutts speak 15h 34m 9s ago.
09:59:15 <Cheery> portability?
09:59:16 <Philippa> oh, and incidentally pretty much every commercial concern in your lib
09:59:17 <Cheery> :)
09:59:19 <dcoutts_> hia nominolo
09:59:42 <Cheery> Philippa: maybe that's the strength, I don't care about commercial stuff much.
09:59:44 <Philippa> SDL was a pragmatic project
10:00:05 <Philippa> it is what it is because it did what actual game developers needed. Historically, it especially did what TBS developers needed
10:01:55 <Philippa> to put it another way: you may as well add a pony to your requirements list while you're at it
10:02:23 <Cheery> lol
10:02:42 <Cheery> thought, if you have noticed, gaming on windows PC has declined over last years
10:02:43 <Japsu> TBS?
10:02:55 <dcoutts_> nominolo: ?
10:02:55 <Philippa> Turn-Based Strategy
10:03:00 <Japsu> ah
10:03:08 <Japsu> wesnoth <3
10:03:13 <Philippa> Cheery: over the last decade or so. The console market's eaten increasing amounts of the PC's lunch
10:03:40 <Cheery> yep
10:03:51 <Philippa> Bioware becoming primarily console developers is a big sign there - even the traditionally PC-focused end of the RPG genre's mostly on consoles
10:03:52 <Cheery> but console market doesn't support 'newcomers' so well
10:04:46 <Philippa> I'm not sure there's much in it for the mainstream chunk of the market by now
10:04:51 <Philippa> the budgets're too big
10:05:13 <lament> strange that consoles are so popular
10:05:15 <Cheery> so if one could drag 'newcomers' with a lib that doesn't contain annoyances, big companies would be required to support it or else they'd be finished
10:05:22 <nominolo> dcoutts_: oh, heh.  privmsg to wrong nick
10:05:24 <mrd> unfortunately, the console ports of RPGs seem to be rather crummy
10:05:28 <nominolo> let me try again...
10:05:42 <mrd> and that infects the PC version too, like with Oblivion :/
10:05:45 <Cheery> lament: maybe it's not because that people ask for console games
10:06:14 <Cheery> Philippa: I'm thinking in around ten-year -range
10:06:23 <phobes__> Is the PC market actually declining and if so in what sense?
10:06:43 <Cheery> phobes__: the shelf titles have shifted towards consoles
10:07:10 <Cheery> people are thinking PC gaming is dead
10:07:11 <phobes__> But in terms of numbers of gamers / revenues?
10:07:27 <psnively> PC FPS gaming is dead. So what?
10:07:28 <Cheery> not really that way
10:07:38 <Philippa> psnively: I wouldn't go that far. But it's a niche and will remain so
10:07:50 <Cheery> psnively: exactly. :)
10:08:05 <phobes__> How about WoW - player base started to decline yet?
10:08:07 <psnively> Well, let me rephrase that: only Epic, id, and Valve can make money at it. :-)
10:08:09 <Philippa> it's not /as/ dead as the 2D fighter, for example, and I picked up a new one recently
10:08:10 <mrd> Crysis is PC
10:08:28 <psnively> Yeah, it'll be interesting to see how Crytek does.
10:08:30 <mrd> I'm not counting out PC gaming just yet
10:08:32 <phobes__> psnively:  Crytek?
10:08:41 <phobes__> nm
10:08:46 <psnively> Company behind Crytek engine and Crysis..
10:08:50 <mrd> I waas enjoying Crysis until I ran into a game-stopping bug and I haven't had time to fix it
10:09:02 <Philippa> mrd: I think a lot of the things I hear people complaining about being missing in RPGs that get console versions are... not really that big a loss most of the time, tbh
10:09:04 <lament> Epic is the company that's making Duke Nukem Forever?
10:09:11 <psnively> Er, no.
10:09:19 <Philippa> Epic're the guys behind the Unreal series
10:09:26 <psnively> Epic consistently ships product.
10:09:26 <lament> oh, right
10:09:26 <Cheery> I think PC-gaming starts again at some point, but with different people
10:09:45 <psnively> I think PC gaming is the place to be for RTS and MMORPG.
10:09:47 <phobes__> But is the PC market actually declining?  Does anyone have data to support this?
10:09:49 <Philippa> Cheery: on a different scale, that's the big thing. PC gaming needs to be about lower budget, intricate gameplay
10:09:49 <Cheery> anyway, wii was the first console I've ever bought
10:09:55 <mrd> Philippa: to some extent, it can be pulled off.  but you miss out on keyboard interaction and mods.
10:09:58 <Philippa> psnively: yeah, though it probably won't hang on to MMO in the long run
10:10:18 <psnively> Depends upon whether MMO degenerates into nothing but PvP combat or not.
10:10:24 <psnively> But you may be right.
10:10:28 <Philippa> mrd: yeah, but most players don't care so much about mods for SP games and there's no reason the current crop of consoles can't do them
10:10:29 <psnively> (Obviously.)
10:10:53 <Philippa> psnively: it doesn't at all. Either usable voice-based comms or a keyboard for the console and you're set
10:11:08 <mrd> Philippa: most players perhaps, but there is a very active minority of modders.  gives a lot of replay value to SP games too.  but it is possible for that to be duplicated on console, for sure.
10:11:41 <bos> psnively: are you somewhere near the SF bay area?
10:11:44 <Cheery> I think PC gaming is nicer than on consoles, if you avoid games that force installing from CD/DVD, games that don't have copy protections, etc.
10:11:51 <psnively> bos: 400 miles near. :-)
10:11:57 <bos> ah, socal?
10:12:06 <Philippa> Cheery: IOW, if you avoid mainstream PC gaming as most people see it
10:12:13 <Philippa> (the real mainstream for PC games is all Flash)
10:12:14 <Cheery> and, of course, if you avoid the big-budget -titles that take exceedingly long to boot
10:12:16 <psnively> The idea of a console with a keyboard is, I think, blurring the distinction between console and PC a lot.
10:12:19 <psnively> bos, yes, LA
10:12:27 <Philippa> psnively: it's been blurred to hell and back already, it'll happen
10:13:05 <Cheery> I think the lack of support for grassroot level is what kills the console every time
10:13:07 <phobes__> PCs and consoles cost about the same amount these days :)
10:13:18 <Philippa> phobes__: not good gaming PCs
10:13:40 <Philippa> you get a lot more gaming bang for your buck out of a 360 Arcade than a PC of the same price
10:13:41 <phobes__> Philippa:  Not high end gaming PCs
10:13:46 <mrd> I haven't been able to put a finger on it, but there is definitely a different feel to console shooters than PC.  I can't really describe it, but it felt quite distinct when I played Half-life2 followed by BioShock
10:13:57 <Philippa> no, just not good. For the price of a 360, you barely get the spec of the 18 month old box I'm on
10:14:01 <Philippa> and it was mid-range at best at the time
10:14:20 <phobes__> Philippa:  Ya, you're right, if you buy a PC at retail, you'll be much better off with a console
10:14:22 <mrd> yes, gaming PCs are getting pretty expensive.  the newer 8800GTs and such have made it somewhat more reasonable though
10:14:26 <dons> ?yow
10:14:26 <lambdabot> Your CHEEKS sit like twin NECTARINES above a MOUTH that knows no BOUNDS --
10:14:31 <Cheery> but, in other hand, if you add the support for grassroot, the console is just a simplified PC
10:14:35 <lament> console shooters are designed for poor controls
10:14:44 <Philippa> Cheery: the grassroots for consoles just isn't what you think it is
10:14:51 <Philippa> lament: different, not necessarily poor per se
10:14:53 <Cheery> ?
10:15:01 <Philippa> they have a different set of constraints, yes
10:15:08 <mrd> my friends do just fine with the xbox controller on Halo, but I can't deal with it at all
10:15:14 <Philippa> but PC shooters are far less realistic about aiming than console ones, for example
10:15:24 <phobes__> mrd:  That different feel of console controllers for FPS I usually describe as "bleh"
10:15:35 <Cheery> Philippa: can you explain that about grassroots on consoles?
10:15:45 <Philippa> Cheery: grassroots support for consoles isn't /developer/ support
10:15:49 <Philippa> it's gamer support
10:15:54 <lament> Philippa: it's not supposed to be realistic! it's supposed to be fun!
10:16:01 <lament> UT instagib is so fun.
10:16:05 <Philippa> *nod*
10:16:07 <Philippa> I like UT
10:16:18 <Philippa> but I've also played console titles that wouldn't have worked with a mouse and keyboard
10:16:22 <lament> i don't see how instagib can possibly work on console
10:16:27 <Cheery> Philippa: but aren't usual good game developers also the guys who play games?
10:16:39 <mrd> I can't see games like super smash working out well on the PC
10:16:39 <phobes__> Philippa:  Guitar hero?
10:16:42 <Philippa> Cheery: not once they're developers, believe me
10:16:55 <Philippa> phobes__: FPSes
10:17:04 <Cheery> Philippa: what happens?
10:17:10 <Philippa> mrd: the entire fighting genre sucks on PC
10:17:14 <Philippa> the controls are just wrong
10:17:25 <Philippa> Cheery: death march project management. No time to be gamers
10:17:33 <hpaste>  (anonymous) pasted "Quaternion" at http://hpaste.org/6085
10:17:45 <smg> so
10:17:47 <skorpan> ah, the quaternions
10:17:48 <Cheery> Philippa: but that also destroys their quality as game developers..
10:17:53 <Philippa> the grass roots stuff for console games is the people who'll take apart a game until they know the mechanics better than the developers do
10:18:02 <phobes__> Have USB keyboards finally removed the limitation on the number of keys that can be depressed at once?
10:18:08 <smg> byorgey and ddarius: http://hpaste.org/6085
10:18:09 <smg> now it works
10:18:16 <Cheery> Philippa: sounds cool
10:18:21 <Philippa> phobes__: keyboard still stinks for fighters even after that though
10:18:23 <phobes__> Fighting games on PC were always broken because certain key combos would lock up the keyboard
10:18:26 <smg> skorpan: yeah sorry it's my first try to code something useful in haskell :)
10:18:44 <phobes__> Philippa: ya, I agree it just feels much better with a console
10:18:46 <Philippa> I'm weird for a fighting game fan because I'm usually more comfortable with a Dual Shock pad than a proper 'cade joystick
10:18:50 <skorpan> smg: don't get me wrong, i understand *nothing* about quaternions, but a few friends of mine used them in a game project about a year ago
10:19:20 <Philippa> I picked up two KoF titles recently, I now have calluses on my left thumb
10:19:24 <Cheery> quaternions are said to be nicer than matrix -stuff, and for me they are also quite attracting
10:19:27 <ska-fan> What's a type that's not Eq and not Ord?
10:19:45 <phobes__> a -> a
10:19:48 <mrd> ska-fan: functions
10:19:56 <Cale> Functions aren't in Eq
10:20:02 <ska-fan> ok, thanks
10:20:07 <ska-fan> everything else is?
10:20:10 <ska-fan> more or less?
10:20:16 <mrd> anything you define and don't make an isntance for :)
10:20:30 <Cale> IO actions are another one.
10:20:44 <Cheery> hm.. I wonder what else channel would be better for a talk from games than #haskell..
10:20:56 <Cale> IORefs are in Eq, but not in Ord
10:21:04 <Cheery> :) I actually got some new thoughts here
10:21:06 <phobes__> I was just wondering how this game conversation got derailed into Eq, and Ord... stay on topic people
10:21:18 <mrd> are games in Ord?
10:21:33 <Philippa> * > WoW, so sure
10:21:47 <mrd> so we have a least element
10:21:47 <lament> totally ordered, it seems :)
10:22:26 <Cheery> btw. I played the prince of persia on PC lately.
10:22:33 <Cale> I'm not entirely sure I understand the attraction to consoles. If you're going to own a computer anyway, why not just play games on that?
10:22:35 <Cheery> I think it has better controls than the nes-version
10:22:40 <Cheery> and better gameplay in general
10:23:07 <mrd> Cale: the question is: did you grow up in front of the computer, or in the arcade?
10:23:12 <Philippa> remind me which system PoP originated on?
10:23:22 <skorpan> are there any conventions in haskell on when to use "data Person = Person String" and when to use "data Person = Person { name :: String }"?
10:23:22 <Philippa> Cale: controls, title availability
10:23:30 <lament> Cale: it makes sense if gaming is the only resource-intensive thing you do on the computer. You buy a cheap laptop for other stuff, and a cheap console for games. As opposed to an uber-expensive gaming rig.
10:23:52 <lament> with 829374 fans.
10:23:57 * mrd chuckles
10:24:00 <TSC> skorpan: Typically, when you have more than a couple of elements, you'll want to start naming them
10:24:03 <Cheery> Philippa: I'm not sure even myself
10:24:12 <skorpan> TSC: okay, thanks
10:24:15 <Philippa> Cheery: I have a suspicion it may've been the Mac
10:24:17 <ska-fan> How would I define my own show function for a type in hugs? the naive way gives me Ambiguous variable occurrence "show" *** Could refer to: Main.show Hugs.Prelude.show
10:24:18 <mrd> lament: not that a PS3 is cheap...
10:24:19 <TSC> skorpan: And if you think you might want to add or remove them later, you'll definitely need to name them
10:24:28 <skorpan> cool
10:24:34 <Philippa> heh, no - Apple II
10:24:53 <lament> Cale: also, you can run linux or mac on your computer and still play lots of games
10:25:21 <dons> skorpan: yeah, doesn't hurt to name things
10:25:25 <Cale> lament: I run linux, and have no shortage of games to play.
10:25:29 <Cheery> "Prince of Persia (Also known as POP)is a platform game, originally developed by Jordan Mechner in 1989 for the Apple II, that was widely seen[citation needed] as a great leap forward in the quality of animation seen in computer games."
10:25:44 <TSC> ska-fan: You should make a Show instance for your type ("instance Show MyType where show x = ...")
10:25:48 <phobes__> Cale:  I think he meant lots of *good* games :)
10:25:58 <mrd> TSC: why not deriving (Show)
10:26:00 <mux> MAME provides you that :)
10:26:01 <lament> Cale: fine, s/linux or mac/mac/ :)
10:26:02 <Cheery> I think, game is not good if you can't play it with a bit old computer
10:26:16 <TSC> Or you could derive Show, sure
10:26:40 <Cale> Well, I just finished Portal and got a bit tired of Oblivion, and I'm working on Half Life 2.
10:26:48 <Cheery> the current run after high-tech computers is the whole problem why gaming has declined on PC
10:26:53 <Cale> These all run just fine in Wine.
10:26:55 <mrd> <3 portal
10:27:06 <Philippa> Cheery: not exactly. It's been one of the differentiators from consoles
10:27:06 <Cheery> nobody has the money to buy new hardware each year
10:27:10 <mrd> Source games seem to run fine on older hardware, which is nice
10:27:20 <ska-fan> data Tree a = Leaf a | Branch (Tree a) (Tree a)
10:27:20 <ska-fan> instance Show Tree a where show (Leaf x) = show x
10:27:23 <Cheery> oh well, somebody has. :P
10:27:24 <phobes__> Cale:   The hardware accelleration works fine?
10:27:27 <ska-fan> ERROR "tree.hs":2 - Syntax error in instance head (constructor expected)
10:27:31 <Cale> phobes__: yep
10:28:23 <phobes__> Cale:  sudo apt-get install oblivion .... what am I doing wrong?
10:28:37 <Cale> phobes__: heh
10:28:40 <mrd> phobes__: you need the right sources.lst =)
10:28:49 <phobes__> =)
10:29:38 <Cheery> Anyway, PoP is nice since the controls are challenging, and there's good elements in games.
10:29:59 <Cheery> I like the skeletons, which were completely fucked in the nes -version.
10:30:25 <Philippa> generally I don't like it when control schemes are challenging - at least, not at a basic level
10:30:28 <Cheery> in the nes -version, you were able to kill those things
10:30:28 <TSC> ska-fan: I got this to work in ghci:
10:30:30 <TSC> instance (Show a) => Show (Tree a) where show (Leaf x) = show x
10:30:48 <Philippa> learning to be able to shoot straight without pretending to be a turret in Counter-strike was pretty frustrating
10:30:54 <phobes__> Anyone ever play that game where you free form controlled a guy's sword arm with your mouse?
10:31:00 <Deewiant> die by the sword?
10:31:10 <Cheery> Philippa: I've tended to like about platformers, it's probably one of things which I like in platformers.
10:31:25 <ska-fan> TSC: thanks, works in hugs, too
10:31:35 <TSC> No worries
10:31:44 <Philippa> with platformers it's more the physics than the control scheme per se I'm interested in
10:31:46 <Cheery> Philippa: maybe that's because in counter-strike the character is quite a lot just turret. :)
10:32:05 <phobes__> Deewiant:  maybe
10:32:11 <Philippa> when I played a lot, if you knew how to "silent run" with a kalashnikov you sure didn't play turret much
10:32:20 <skorpan> if i have made a data type such as "data Person = Person { name :: String }", is it possible to allow for users to write simply "Player \"John\"" to mean "Player { name = \"John\" }"?
10:32:30 <Deewiant> phobes__: does it look familiar? :-) http://en.wikipedia.org/wiki/Die_By_the_Sword
10:32:30 <Cheery> I think it's the combination of levels, non-realism and control schemes
10:33:05 <Philippa> I suspect they removed the wrinkle in the physics/control scheme that allowed the "silent run" though
10:33:24 <phobes__> Deewiant:  Ya, I looked at that - I can't say for sure :/
10:33:27 <phobes__> That might be it
10:33:37 <Philippa> (you alternated walking and running rapidly so that you never went over the velocity threshold the game recognised as running - so you maintain walking-speed accuracy and don't make footsteps)
10:33:57 <Deewiant> phobes__: google image search has screenies too
10:33:59 <Cheery> I liked the blade of darkness in one way, but it lacked good controls and the interesting -factor
10:34:12 <Philippa> bonus points if you zig-zagged and shot just as your velocity hit zero
10:34:12 <Deewiant> phobes__: I'm just interested because if it's not that, I'd like to know what it is :-)
10:34:16 <phobes__> Deewiant:  I found screenshots... it looks familiar, but I just can't say
10:34:19 <Deewiant> Blade of Darkness was cool
10:34:30 <phobes__> I might have seen an early version of it or something
10:34:31 <Philippa> (or rather, a frame or two after as that was optimum for shot accuracy)
10:34:42 <bos> hey kids, could we take this to some other channel?
10:34:44 <Cheery> it was just killing some goblins with nice kitchen knifes
10:34:53 <phobes__> No, I played a demo of this game, it was terrible...
10:34:53 <TSC> skorpan: Yeah, 'Person "John"' is the same as 'Person { name = "John" }'
10:35:00 <Philippa> point. #haskell-blah is thataway ->, folks
10:35:04 <skorpan> TSC: oh it is? awesome
10:35:10 <Philippa> and people are asking on-topic questions
10:35:26 <TSC> skorpan: If you've defined field names (like name), you don't have to use them
10:35:27 <skorpan> awesome!
10:36:02 <Deewiant> but this can lead to maintenance problems if you add fields later
10:36:13 <Deewiant> as I discovered over the weekend first hand ;-)
10:36:17 <lament> fields lead to maintenance problems.
10:36:38 <Deewiant> all my functions were defined in the form foo (Foo _ _ x _) = stuff
10:36:52 <notsmack> lament: is there a good alternative?
10:37:55 <lament> not that i know of
10:38:12 <notsmack> :-(
10:39:38 <dino-> You can use record-style data types to get around some of that future breakage.
10:40:09 <dino-> The record names behave like functions from the data type as a whole to the specific item in it.
10:40:21 <notsmack> dino-: that's what they were talking about
10:40:38 <Deewiant> that's the most annoying bit in my experience: global namespace pollution
10:40:43 <notsmack> me too
10:40:48 <dino-> ah, sorry to butt in
10:41:07 <ska-fan> Is there something that has excercises in which I need to write haskell programs with increasing complexity?
10:41:14 <Deewiant> can't call anything anything common like "name", have to give it a prefix (or then just always use qualified imports of that module)
10:41:41 <dino-> Deewiant: Ya, I've had that happen as well
10:41:48 <dcoutts_> ska-fan: I've got an NP hard problem for you if you want, Cabal package dependency resolution :-)
10:42:08 <ska-fan> nah, I'm a beginner :)
10:42:41 <lament> Deewiant: basically, if you try to do OO in haskell, it will complain and bite you
10:42:41 <Deewiant> ska-fan: maybe http://www.haskell.org/haskellwiki/99_Haskell_exercises =
10:42:42 <lambdabot> Title: H-99: Ninety-Nine Haskell Problems - HaskellWiki
10:42:50 <TSC> ska-fan: I used the Project Euler problems to learn Haskell
10:43:00 <lament> Deewiant: and record-style data types look like they're a way to fake OO
10:43:03 <TSC> (among other things)
10:43:07 <Deewiant> lament: I just need a data type with a couple of fields with common names, is that so bad? :-)
10:43:29 <lament> Deewiant: yes :(
10:43:50 <lament> haskell's support for abstractions like that is terrible
10:43:51 <Deewiant> I really don't want to have to declare a type class for each field
10:43:58 <Deewiant> class HasName...
10:44:14 <notsmack> Deewiant: not even good enough if they end up different types
10:44:16 <Deewiant> is that a sign that I'm doing something wrong, then? O_o
10:44:35 <lament> well, look at python or ruby... :D
10:44:40 <lament> or scala i guess...
10:44:48 <mrd> haskell is not OO, so, it's not the way you do things
10:45:00 <Cale> Deewiant: Not necessarily. It's just that Haskell doesn't have a real record system.
10:45:09 <Deewiant> if I have 5 pieces of data I want to group together, should I just use tuples then :-P
10:45:30 <Deewiant> Cale: I'm aware of this, I'm just wondering why this hasn't been a big enough problem that it hasn't been solved yet
10:45:32 <lament> you could hack your own system on top of haskell, but it would not be very pretty
10:45:34 <Cale> Deewiant: Usually I just prefix the record labels with some abbreviation of the type name.
10:45:51 <radix> lament: what's the best practice, then?
10:46:04 <lament> as far as i'm concerned, it's a huge fundamental flaw in haskell, but obviously lots of people don't mind it
10:46:09 <radix> oh, ok.
10:46:18 <lament> radix: radix!
10:46:19 <mrd> nah, i don't find records to be that bad
10:46:22 <radix> lament: Hi!
10:46:26 <mrd> there's worse things
10:46:26 <radix> lament: How are you, lament
10:46:32 <lament> radix: How are you, radix
10:46:36 <radix> I'm good!
10:46:46 <lament> me too!
10:46:53 <mrd> if you try to use records as some sort of OOP style construct, you will be disappointed
10:46:54 <lament> how's pypy?
10:46:59 <Deewiant> Cale: that's what I do, too, but isn't this common enough for people to want to do something about it?
10:47:12 <lament> Deewiant: have a look at scala :)
10:47:18 <ska-fan> TSC, Deewiant: thanks for the tip
10:47:21 <Cale> Proper extensible polymorphic records and variants are up there on my list of desired features, but they're not something which I've run into terribly often, they just feel like a gap.
10:47:45 <Cale> Deewiant: I think that most of the programs which functional programmers tend to write don't seem to use very large product types.
10:47:53 <Deewiant> I don't need polymorphism or anything magic, I just want an abstract data type with a few accessors :-)
10:48:04 <Cale> Instead, we'll just carry things around in smaller chunks.
10:48:13 <gbacon> so cranking up the verbosity level in the pugs build (with Cabal-1.3.3) produces a different result!
10:48:15 <mrd> Deewiant: do they need to be separate datatypes?
10:48:33 <Deewiant> mrd: how do you mean, separate?
10:48:33 <ska-fan> I think I'll go with the 99 for now
10:48:34 <lament> but yeah, you could just keep the parts of your record type separate
10:48:54 <lament> printPerson :: Name -> Age -> IO ()
10:48:56 <Deewiant> oh, like having two pairs instead of four separate types
10:49:07 <Deewiant> or that.
10:49:08 <mrd> Deewiant: can you use a union type, in other words, data Foo = Bar ... | Blah ...
10:49:39 <mrd> are you sure that's not what you intend?
10:49:53 <Deewiant> no, I do need all 5 fields "at once"
10:50:01 <lament> make a monad :D
10:50:03 <mrd> ?
10:50:13 <Deewiant> String, [String], [FilePath], [FilePath], IO ()
10:50:27 <mrd> data Foo = Bar { field1 :: String, ... } | Blah { field1 :: String, ... }
10:50:45 <Deewiant> mrd: what's the advantage of that?
10:50:57 <Deewiant> mrd: I'm afraid I'm not quite sure what you're after
10:51:05 <mrd> Deewiant: and I'm not sure what you're trying to do, then
10:51:24 <Deewiant> I was complaining about global namespace pollution with record accessors :-)
10:51:27 <mrd> Deewiant: I'm just afraid lament's been confusing you and telling you that something is not possible, when it probably is quite possible
10:51:40 <pejo> Cale, weren't you starting to hack on some record proposal?
10:51:51 <mrd> Deewiant: modules control namespacing
10:52:11 <psnively> Deewiant: consider OCaml.
10:52:11 <Cale> pejo: Yes, well, trying to learn enough about GHC to sort out what I'd have to do.
10:53:28 <Cale> pejo: It's somewhat insane kind of change for me to be doing though, given that I've never really looked closely at GHC before.
10:53:32 <Deewiant> mrd: aye, it's just that using a common name such as "name" as a field accessor leads to annoying shadowing warnings if you have a function defined as foo name = ... for instance
10:54:07 <psnively> I wonder how the JHC compiler is coming?
10:54:07 <mrd> yes, the accessors are just ordinary functions
10:54:33 <Cale> Oh, also, newer GHCs come with a solution to that very problem. It's just a hack though.
10:54:45 <Cale> (and not a complete solution)
10:55:11 <psnively> GHC seems to be getting kinda big and unwieldy.
10:55:13 <mrd> remember, though, that Haskell doesn't practice function overloading -- instead it features type inference
10:55:35 <Deewiant> Cale: what's that?
10:55:36 <Cale> http://haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields
10:55:37 <lambdabot> http://tinyurl.com/29me25
10:55:53 <ndm> psnively: but at least it terminates most of the time - writing a compiler is a big undertaking, and GHC is actually pretty well engineered, so not that unwieldy
10:55:58 <pejo> psnively, hasn't GHC been big "forever"?
10:56:40 <psnively> I was imprecise. "Unnecessarily big" in the sense that it supports a number of extensions that have made its inference and checking machinery gain accidental, vs. essential, complexity. (cf. JHC).
10:57:13 <psnively> Isn't there a more-or-less explicit push to, e.g. integrate whatever the successor to "wobbly types" turned out to be, to simplify some of the machinery?
10:57:17 <mrd> GHC also incorporates extensions for which the type checking and reconstruction algorithms are still active topics of research
10:57:21 <psnively> ==
10:58:17 <psnively> It just seems to add to the difficulty of hacking GHC at present.
10:58:21 <psnively> (At least to me.)
10:58:36 <Cale> psnively: How are GADTs presently handled?
10:58:47 <psnively> Good question. :-)
10:58:57 <Cale> psnively: I would expect that the internal type system is much richer than required for all the extensions.
10:59:13 <Cale> psnively: (but inference for it would suck)
10:59:55 <psnively> Is that true? I thought one of the distinguishing characteristics of JHC is that it uses Henk as one of its IRs, and GHC doesn't, even though Henk was spec'ed by SPJ.
11:02:04 <Saizan_> i thought the internal type system was ~ System F_omega
11:03:06 <mux> it used to be, now it's Fc, system F with type equality coercions
11:03:44 <Cale> http://research.microsoft.com/%7Esimonpj/papers/ext%2Df/
11:03:45 <lambdabot> Title: Simon Peyton Jones: papers
11:04:36 <ska-fan> Ok, I got stuck at implementing flatten
11:05:28 <ska-fan> but I have an idea. :)
11:05:39 <gilson> hello guys, sorry i'm newbie in haskell
11:05:50 <cjb> gilson: welcome!
11:06:21 <gilson> im trying to call ord function but it gets "Not in scope: 'ord'"
11:06:23 <lament> ska-fan: first things first.. do you have its type signature? :)
11:06:42 <gilson> how can i load the library that contains this function
11:06:42 <Cale> gilson: It's in Data.Char
11:06:42 <gilson> ?
11:06:57 <Cale> gilson: If you're writing a module, add  import Data.Char near the top, after the module declaration
11:07:02 <ska-fan> lament: hmm :) didn't think about it yet. Am now.
11:07:10 <lament> ska-fan: that's really the most important thing
11:07:12 <Cale> gilson: If you're in ghci, type  :m + Data.Char
11:07:16 <gilson> ah, thx, and how can i load this library, i tried the :l <module> command, but not succeded
11:07:17 <Cale> To bring it into scope
11:07:38 <ska-fan> lament: there are no nested lists in haskell
11:07:44 <lament> ska-fan: there aren't?
11:07:45 <Cale> In hugs, I believe the appropriate command is  :also Data.Char
11:07:47 <gilson> ah, thx very much guys ;-)
11:07:58 <lament> :t [[1,2],[3,4]]
11:08:02 <lambdabot> forall t. (Num t) => [[t]]
11:08:06 <ska-fan> well at least not such lists: [a, [b, [c, d], e]]
11:08:26 <Cale> gilson: No problem. Feel free to let us know if you have any trouble or questions.
11:08:27 <ukl> :t []
11:08:29 <lambdabot> forall a. [a]
11:08:29 <ska-fan> (from https://prof.ti.bfh.ch/hew1/informatik3/prolog/p-99/ , which I'm using because the haskell page has the solutions right there)
11:08:38 <lament> ska-fan: oh, that's true.
11:08:55 <ukl> lists are lists of elements of one type, right?
11:08:59 <lament> ukl: yes.
11:09:38 <ska-fan> flatten :: [[a]] -> [a]
11:09:40 <lament> ska-fan: on the plus side, this makes implementing flatten easy :)
11:09:51 <lament> ska-fan: okay, so you have the type signature
11:09:51 <ukl> you could have [ [[a]], [[b],[c,d]], [[e]]], I think, but that's...uhm... not that lucky.
11:09:54 <ska-fan> indeed :)
11:09:57 <lament> ska-fan: next step: type the type signature into hoogle
11:10:01 <Cale> > [ [[a]], [[b],[c,d]], [[e]]]
11:10:02 <lament> @hoogle [[a]] -> [a]
11:10:03 <lambdabot> Prelude.concat :: [[a]] -> [a]
11:10:03 <lambdabot> Data.List.concat :: [[a]] -> [a]
11:10:03 <lambdabot> Data.List.intercalate :: [a] -> [[a]] -> [a]
11:10:03 <lambdabot>  [[[a]],[[b],[c,d]],[[e]]]
11:10:10 <Cale> yes, indeed you could :)
11:10:17 <gilson> thx Cale
11:10:27 <lament> > concat [[1,2],[3,4]]
11:10:28 <lambdabot>  [1,2,3,4]
11:10:32 <ska-fan> lament: that step comes after I implemented the function :)
11:10:39 <Cale> > concat [[[a]], [[b],[c,d]], [[e]]]
11:10:39 <lambdabot>  [[a],[b],[c,d],[e]]
11:10:42 <Deewiant> > concat.concat$ [[[a]],[[b],[c,d]],[[e]]]
11:10:43 <lambdabot>  [a,b,c,d,e]
11:11:01 <lament> > join [[1,2],[3,4]]
11:11:02 <lambdabot>  [1,2,3,4]
11:11:11 <Deewiant> > join [[[a]],[[b],[c,d]],[[e]]]
11:11:12 <lambdabot>  [[a],[b],[c,d],[e]]
11:11:30 <Cale> Oh, for the beginners here, these variables 'a' through 'e' there, are part of a library which is imported by lambdabot, but isn't yet widely available.
11:11:51 <ukl> I was just wondering...
11:11:55 <Cale> (so that won't work in ghci directly)
11:12:11 <Cale> > iterate f z
11:12:12 <lambdabot>  [z,f z,f (f z),f (f (f z)),f (f (f (f z))),f (f (f (f (f z)))),f (f (f (f (f...
11:12:24 <Cale> It's handy for checking out what various functions do :)
11:12:30 <Cale> > foldr f z [1,2,3]
11:12:31 <lambdabot>  f 1 (f 2 (f 3 z))
11:12:38 <Cale> > foldl f z [1,2,3]
11:12:39 <lambdabot>  f (f (f z 1) 2) 3
11:12:52 <dons> Cale, is the library available on hackage?
11:12:55 <lament> > join [a]
11:12:55 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Expr'
11:12:57 <ukl> [[['a']],[['b'],['c','d']],[['e']]] is fine with ghci. (but a little more boring)
11:13:00 <Cale> dons: I don't think so...
11:13:00 <dons> perhaps under some teaching category?
11:13:14 <Cale> dons: But it would be good if someone was to package it :)
11:13:24 <Cale> dons: You can get it as part of lambdabot.
11:13:26 <lament> is packaging stuff non-trivial somehow?
11:13:31 <dons> not really
11:13:38 <dons> its pretty trivial.
11:14:50 <hpaste>  ska-fan pasted "99 problems" at http://hpaste.org/6086
11:15:07 <ska-fan> Ok, 1:14 am here. I'd appreciate it if someone could take a look at the first 6 simple problems
11:15:35 <lament> ukl: but you have to be careful with those:
11:15:36 <lament> > concat [['a','b'], ['c']]
11:15:37 <lambdabot>  "abc"
11:16:06 <ukl> > "abc" == ['a','b','c']
11:16:07 <lambdabot>  True
11:16:18 <ukl> :)
11:16:24 <lament> > True
11:16:25 <lambdabot>  True
11:17:00 <Cale> ska-fan: for isPalindrome, why not  isPalindrome xs = xs == revList xs
11:17:58 <ska-fan> Cale: hmm, indeed :)
11:19:40 <Cale> ska-fan: For flattening, you probably just want to use ++ to combine the elements of the list.
11:20:09 <Cale> If you know about foldr, it's easy to write as  flatten xs = foldr (++) [] xs
11:20:19 <Cale> Otherwise, it would look something like:
11:20:24 <Cale> flatten [] = []
11:20:31 <Cale> flatten (x:xs) = x ++ flatten xs
11:21:00 <Cale> > otherwise
11:21:01 <lambdabot>  True
11:21:56 <Cale> :t unless otherwise
11:21:58 <lambdabot> forall (m :: * -> *). (Monad m) => m () -> m ()
11:22:12 <ukl> I just wonder, what would be the right way to write a flatten that works with any list-depth? (i guess not to try it, but...)
11:22:18 <ska-fan> Cale: hmm, fwiw that flatten doesn't work in hugs at least
11:22:37 <lament> > unless otherwise $ putStrLn "What"
11:22:38 <lambdabot>  <IO ()>
11:22:43 <ska-fan> flatten [1..10]
11:22:43 <ska-fan> ERROR - Cannot infer instance
11:22:57 <ukl> every function has got one and only one type signature, right? So this wouldn't work in any easy way...
11:23:12 <Cale> ukl: Well, you could perhaps use typeclasses, and maybe some extensions to the typeclass system. However, more likely you'd want to be flattening a tree than a list of lists.
11:23:42 <lament> what's the name of a generic flattening function?
11:23:44 <Cale> (So a more straightforward way would just to be to define a tree datastructure and write a flatten for that)
11:23:56 <Cale> lament: well, there's join
11:23:59 <Cale> :t join
11:23:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:24:09 <lament> Cale: i mean fully flattening
11:24:16 <lament> Cale: a b -> b
11:24:18 <Cale> I don't know if that has a name.
11:24:27 <ukl> Cale: ok, thank you...a tree's like a list that's nested in the way ska-fan suggested earlier, right? (at least a little like that)
11:24:35 <Cale> ukl: yeah
11:24:56 <ska-fan> ukl: well [[a]] -> [a] fits for lists of arbitrary depth
11:24:59 <Cale> ukl: You could define something like   data Tree a = Branch a [Tree a]
11:25:11 <byorgey> ska-fan: you know that elementAt = (!!) and numElems = length?  or is the point to implement these yourself?
11:25:11 <lament> functors are called functors, and this is.. like the opposite of a functor :)
11:25:21 <ska-fan> byorgey: the latter :)
11:25:29 <byorgey> ska-fan: ok =)
11:26:01 <ska-fan> Ok, I'm off to sleep.
11:26:02 <ukl> [a,[b, [c,d],[f]],[e]] would mean node a with a left branch b and a right branch e, with node b having one branch (c,d) and f...something like this....
11:26:29 <byorgey> ukl: yup
11:26:39 <Cale> Oh, or something like  data Tree a = Leaf a | Branch [Tree a]
11:26:51 <Cale> Which would be closer to what is meant here :)
11:26:56 <lament> Cale: i guess it's the "missing monad operation", the opposite of 'return', so "unsafePerform" :)
11:26:58 <ndm__> dcoutts, i am installing cabal-install on 6.8, and while installing zlib, Could not find module `Data.ByteString.Base'
11:27:23 <dcoutts_> ndm__: using what zlib version?
11:27:49 <Cale> So that would become:  Branch [Leaf a, Branch [Leaf b, Branch [Leaf c, Leaf d], Branch [Leaf f]], Branch [Leaf e]]
11:27:50 <ndm__> dcoutts_, hackage tarball 0.4.0.4
11:28:07 <ukl> this data Tree a = Leaf a | Branch [Tree a] seems kind of odd to me...It'd have values only on its leaves, nothing on the points where branches split away...
11:28:30 <ukl> well, ok, the information that there's a branch instead of a leaf is some kind of information
11:28:33 <Cale> ukl: But this is what nested lists have, when looked at the usual way
11:29:13 <Cale> At each point, you either have an element which is not a list (a leaf), or a list of other stuff (a branch)
11:29:27 <ukl> I see, I just was stuck with some different idea of a tree
11:29:51 <dcoutts_> ndm__: when you run build with -v is it passing -DBYTESTRING_IN_BASE ?
11:29:57 <ukl> but it's fine. I should try some of these 99 problems, too...something to practice with
11:30:28 <dcoutts_> ndm__: and when you run configure -v what flag assignment is it using?
11:30:47 <dcoutts_> ndm__: Configuring zlib-0.4.0.4...
11:30:47 <dcoutts_> Flags chosen: bytestring-in-base=???
11:31:06 <ndm__> dcoutts_: no -D in build
11:31:37 <dcoutts_> ndm__: so what file and line is importing .Base ?
11:31:38 <ndm__> dcoutts_: and configure says false to bytestring in base
11:32:03 <ndm__> dcoutts_: zlib.stream
11:32:28 <dcoutts_> ndm__: so that file uses:
11:32:29 <dcoutts_> #ifdef BYTESTRING_IN_BASE
11:32:29 <dcoutts_> import Data.ByteString.Base
11:32:29 <dcoutts_> #else
11:32:41 <dcoutts_> and that's the only import of it in the file
11:33:59 <ndm__> dcoutts_: yeah, i see
11:34:03 <dcoutts_> ndm__: take a look at the generated dist/build/Codec/Compression/Zlib/Stream.hs
11:34:29 <dcoutts_> ndm__: if you use build -v you can see how cabal is calling hsc2hs
11:34:31 <ndm__> dcoutts_: ah - i think i ran build with 6.6 first, and obviously the generated stream.hs doesn't get vaped
11:34:33 <Cheery> has anyone ever yet written an imperative if in haskell?
11:34:35 <Cheery> eg.
11:34:46 <dcoutts_> ndm__: ah, right yes
11:35:00 <ndm__> dcoutts_: is that a cabal bug?
11:35:02 <dcoutts_> ndm__: it only looks at the src file not config changes
11:35:04 <Cheery> mif :: Boolean -> IO a -> IO a -> IO a
11:35:20 <dcoutts_> ndm__: in a sense yes, but it's not one we can solve easily at the moment
11:35:29 <lament> Cheery: sounds like it wouldn't take _too_ long to write
11:35:29 <Cheery> oh wait, there were that one..
11:35:34 <Cheery> @hoogle when
11:35:35 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
11:35:47 <dcoutts_> ndm__: we'll get a fix for free when we move to a make-style dependency framework
11:35:47 <ndm__> dcoutts_: :( - have got it working now though
11:35:47 <Cheery> oh well, it's not the same I think
11:36:01 <Cheery> ought be something like:
11:36:10 <Cheery> Monad m => Bool -> m a -> m a
11:36:24 <Cheery> lament: true. :)
11:36:24 <lament> Cheery: write it!
11:36:33 <Cheery> okay.
11:37:10 <lament> preferrably in one line
11:37:15 <lament> cause two lines is too easy
11:37:32 <lament> actually one line is still too easy, try zero lines
11:37:49 <Cheery> mif b t f = if b then t else f
11:38:03 <lament> very good :D
11:38:23 <Cheery> and actually, you can't write the when for anything else except ()
11:38:35 <doserj> now, can you tell the difference between mif and if?
11:38:36 <Cheery> unless you make a default value of some sort, which sounds like stupid
11:38:56 <smg> smtms: stop it
11:38:58 <Cheery> doserj: nothing. :)
11:39:04 <doserj> :)
11:39:05 <smtms> smg, stop what?
11:39:28 <smg> * Received a CTCP PING 1204573143 404365 from smtms
11:39:34 <lament> Cheery: of course the type sig you gave was Monad m => Bool -> m a -> m a
11:39:35 <Cheery> quite interesting, functional if is equivalent to imperative if
11:39:41 <lament> Cheery: which is not if
11:40:03 <smtms> smg, I wanted to ping myself
11:40:08 <smg> hehe okay :)
11:40:09 <lament> :t mif where mif b t f = if b then t else f
11:40:15 <lambdabot> parse error on input `where'
11:40:17 <smtms> smg, do you feel offended when somebody pings you?
11:40:18 <lament> bah
11:40:38 <Cheery> lament: the type signature for that is Bool -> a -> a
11:40:43 <lament> Cheery: no.
11:40:44 <smg> smtms: mh, no, only if it would me multiple times :]
11:41:01 <Deewiant> @ty let mif b t f = if b then t else f in mif
11:41:14 <lambdabot> forall t. Bool -> t -> t -> t
11:41:27 <Cheery> oh yeah, my bad
11:41:39 <lament> when, on the other hand, has the signature you gave
11:42:30 <Cheery> and imperative if without else... when is nearer that
11:42:41 <Cheery> and I guess it'
11:42:44 <Cheery> just
11:43:03 <Cheery> when b t = if b then t else return ()
11:45:21 <Deewiant> @src when
11:45:21 <lambdabot> when p s = if p then s else return ()
11:48:41 <pgavin> I asked this yesterday, but no one was able to help me... does anyone know of a way to define (or emulate) an instance declaration to use if no other instance is defined for a class?
11:50:06 <roconnor> pgavin: ?
11:50:07 <pgavin> I'm trying to define an instance for ArrowLoop, and in loop :: a (b, d) (c, d) I need d :: Eq a => a, which of course isn't allowed
11:50:42 <roconnor> @type loop
11:50:44 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
11:51:20 <pgavin> I can't call == on d, but of course I can't
11:51:37 <pgavin> can't -> want to :)
11:51:46 <roconnor> hmm
11:52:50 <oerjan> :t loop
11:52:51 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
11:52:59 <pgavin> but it's ok to assume False if d isn't Eq
11:53:05 * oerjan needs glasses
11:53:15 <gbacon> in code generated by hsc2hs, what is the base of relative paths in #include directives?
11:54:38 <gbacon> s/in code/when compiling code/
11:55:14 <pgavin> gbacon: I'm  assuming you mean #include "" and not #include <>
11:55:25 <gbacon> pgavin: correct
11:55:29 <pgavin> gbacon: I would assume the current directory for ""
11:55:40 <pgavin> or whatever directory the .hsc file is in
11:56:13 <roconnor> pgavin: I guess you'll just have to use your own loop function that isn't part of the class.
11:56:20 <dejones> how can I put a string on multiple lines?
11:56:22 <pgavin> roconnor: yeah, I figured as much
11:56:36 <pgavin> roconnor: but I wan't the rec keyword to work :/
11:56:44 <pgavin> s/wan't/want/
11:57:04 <oerjan> > "whitespace (including newlines) is escaped like\    \this"
11:57:11 <lambdabot>  "whitespace (including newlines) is escaped likethis"
11:57:44 <oerjan> if you want actual newlines in a string you need to use \n
11:57:56 <dejones> let str = "foo"  ++ (newline) "bar" ++ "whatever"
11:57:58 <dejones> such as that
11:58:04 <dons> Igloo: did you see this Overflow.hs thread?
11:58:06 <oerjan> or you can use unlines ["first line", "second line" ...]
11:58:07 <dejones> I want the newline in the source code
11:58:23 <dejones> so the line doesn't go over 80 characters in my source code for readability
11:58:26 <Deewiant> or \n?
11:58:28 <dons> Igloo: 40M file containing a bytestring causes GHC to allocate over a gig. it should go through uninterpretred though.
11:58:32 <dons> so might make a useful benchmark
11:59:28 <oerjan> dejones: let str = "foo"  ++ (newline) "bar" ++ "whatever" is also allowed.  but the part after newline must be indented more than str.
11:59:37 <Igloo> dons: We're working through those sorts of problems at the moment. Can you put the example (or code to generate it) in a bug report please?
11:59:57 <dons> Igloo: will do.
12:00:18 <roconnor> pgavin: what does assuming False mean if d isn't a member of Eq, and how could that even be the case?
12:00:19 <dons> Igloo: i've some other similar benchmarks, i'll bundle them up for you
12:00:37 <Igloo> dons: Great, thanks!
12:01:05 <dejones> oerjan: weird, that's what I am doing...
12:01:15 <oerjan> dejones: hpaste?
12:01:19 <oerjan> !paste
12:01:19 <hpaste> Haskell paste bin: http://hpaste.org/
12:01:21 <dejones> ya, 1sec
12:01:46 <pgavin> roconnor: let me rephrase: I want essentially a function f :: a -> a -> Bool that returns a == a if Eq a; otherwise it returns False
12:01:56 <hpaste>  dejones pasted "indentation error..." at http://hpaste.org/6087
12:02:09 <dejones> oerjan: there ya go
12:02:23 <roconnor> pgavin: that is a bizarre request.
12:02:28 <hpaste>  oerjan annotated "indentation error..." with "fixed" at http://hpaste.org/6087#a1
12:02:32 <pgavin> roconnor: I know :)
12:02:44 <roconnor> pgavin: you must be doing something wrong.
12:02:48 <pgavin> roconnor: but I can't think of any other way to do what I want
12:02:52 <pgavin> roconnor: possibly
12:02:57 <oerjan> at least one character more than the variable name
12:03:36 <dejones> oerjan: ahh, thank you.  :)
12:04:48 <hpaste>  oerjan annotated "indentation error..." with "superfluous parentheses" at http://hpaste.org/6087#a2
12:05:14 <Cheery> Is there a way to drop down from  forever ?
12:05:29 <roconnor> drop down?
12:05:32 <oerjan> Cheery: you mean escape?  use an Error monad
12:06:07 <oerjan> (MonadError monad)
12:06:24 <Cheery> oerjan: isn't it quite confusing?
12:06:24 <laura22> hi ^^
12:06:26 <Cale> Cheery: If you're in something like ContT IO, you could perhaps call the continuation provided by callCC from outside the forever. Other than that, you're pretty much stuck.
12:06:33 <Cale> laura22: hello
12:07:04 <Cheery> hm. There's so much of those cool things
12:07:15 * roconnor has used MonadError to escape from a forever.
12:07:17 <Cheery> I think reading the stdlib of haskell is not boring at all. :)
12:07:46 <Saizan_> roconnor: for last ICFP?
12:08:16 <roconnor> yes
12:08:24 <oerjan> > flip runStateT 0 $ runErrorT $ forever $ do n <- get; if n>10 then throwError (show n) else modify (+1)
12:08:26 <lambdabot>        add an instance declaration for (Show (m (Either String (), s)))
12:08:38 <oerjan> > flip runState 0 $ runErrorT $ forever $ do n <- get; if n>10 then throwError (show n) else modify (+1)
12:08:38 <lambdabot> Terminated
12:08:41 <oerjan> > flip runState 0 $ runErrorT $ forever $ do n <- get; if n>10 then throwError (show n) else modify (+1)
12:08:41 <lambdabot> Terminated
12:08:49 <oerjan> huh
12:09:19 <oerjan> > flip runState 0 $ runErrorT $ forever $ do n <- get; if n>10 then fail (show n) else modify (+1)
12:09:20 <lambdabot> Terminated
12:09:31 <oerjan> hm maybe a name conflict
12:09:43 <Cale> > (`runContT` return) (do r <- liftIO (newIORef 10); callCC (\k -> forever (do n <- liftIO (readIORef r); if n == 0 then k () else liftIO (writeIORef r (n-1)))); liftIO (putStrLn "done!"))
12:09:43 <lambdabot>   Not in scope: `writeIORef'
12:09:54 <Cale> (you might try that in ghci :)
12:10:06 <oerjan> > forever $ do n <- get; if n>10 then fail (show n) else modify (+1)
12:10:06 <lambdabot>   add an instance declaration for (Show (m ()))
12:10:07 <dejones> > length [1,2,3] :: Double
12:10:08 <lambdabot>  Couldn't match expected type `Double' against inferred type `Int'
12:10:10 <dejones> :(
12:10:19 <Cheery> I'd love to have a quantum monad, similar to transformer but it'd combine with the underlying monad, and I wouldn't need to pick the underlying monad
12:10:22 <oerjan> :t flip runState 0 $ runErrorT $ forever $ do n <- get; if n>10 then fail (show n) else modify (+1)
12:10:24 <Cale> dejones: Indeed, that is sad.
12:10:30 <Cale> :t length
12:10:33 <lambdabot> forall a. [a] -> Int
12:10:33 <lambdabot>     Ambiguous occurrence `runState'
12:10:33 <lambdabot>     It could refer to either `Control.Monad.State.runState', imported from Control.Monad.State
12:10:33 <lambdabot>                           or `Control.Arrow.Transformer.All.runState', imported from Control.Arrow.Transformer.All
12:10:41 <oerjan> ouch!
12:10:42 <dejones> Cale: I understand that the length is type Int, but I need a double so I can calculate an average...
12:10:52 <Cale> dejones: fromIntegral will do the conversion
12:10:59 <dejones> Cale: Thank yo.
12:11:02 <dejones> * you.
12:11:03 <dejones> :)
12:11:04 <oerjan> Cale: that Control.Arrow.Transformer.All should be qualified
12:11:30 <doserj> > genericLength [1,2,3]::Double
12:11:30 <lambdabot>  3.0
12:11:31 <dejones> Cale: Now, I see, fromIntegral was all the way at the bottom of the Int API spec.
12:11:33 <Cale> ah, indeed it should.
12:12:31 <Cheery> wow, Maybe has lots of instances on things
12:12:35 <Cale> :t flip runState 0 . runErrorT . forever $ do n <- get; if n>10 then fail (show n) else modify (+1)
12:12:36 <lambdabot> forall e s. (Error e, Ord s, Num s) => (Either e (), s)
12:13:08 <oerjan> > flip runState 0 . runErrorT . forever $ do n <- get; if n>10 then fail (show n) else modify (+1)
12:13:09 <lambdabot>  Add a type signature
12:13:11 <Cale> fail is pure evil though
12:13:17 <oerjan> oh
12:13:21 <Cale> You should use throwError
12:13:27 <oerjan> er i did originally
12:13:37 <oerjan> > flip runState 0 . runErrorT . forever $ do n <- get; if n>10 then throwError (show n) else modify (+1)
12:13:38 <lambdabot>  (Left "11",11)
12:15:08 <laura22> i need a hint. how would you implement a powerset function?
12:15:27 <Cheery> whee.. mapMaybe seems useful.. :)
12:15:34 <oerjan> > filterM (const [True, False]) [1..5]
12:15:35 <lambdabot>  [[1,2,3,4,5],[1,2,3,4],[1,2,3,5],[1,2,3],[1,2,4,5],[1,2,4],[1,2,5],[1,2],[1,...
12:15:38 <Cale> laura22: Well, there's recursion
12:15:51 <Cale> laura22: This is on lists, right?
12:15:55 <laura22> Cale, right
12:16:02 <Cale> The powerset of [] will be [[]]
12:16:14 <Heffalump> aargh, not the obfuscated solution!
12:16:25 <Cale> and then we need to figure out how to write the powerset of (x:xs) in terms of the powerset of xs
12:16:40 <Cale> I'll explain the monad solution in a bit if you really want :)
12:16:43 <oerjan> Heffalump: i got carried away :D
12:16:48 <Cheery> > mapMaybe (\x -> if x < 20 then Just x - 20 else Nothing) $ take 40 [0..]
12:16:49 <lambdabot>   add an instance declaration for (Num (Maybe a))
12:17:04 <Cale> It's not really obfuscated, but requires a proper understanding of monads.
12:17:11 <Cale> (and in particular the list monad)
12:17:44 <Cale> laura22: So, suppose we have the powerset of xs
12:17:58 <oerjan> > mapMaybe (\x -> if x < 20 then Just (x - 20) else Nothing) $ take 40 [0..]
12:17:58 <lambdabot>  [-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1]
12:18:01 <Cheery> > mapMaybe (\x -> if x < 20 then Just x - 20 else Nothing) $ take 40 [0..] :: Int
12:18:02 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
12:18:04 <laura22> Cale, nod
12:18:10 <Cheery> > mapMaybe (\x -> if x < 20 then Just x - 20 else Nothing) $ take 40 [0..] :: [Int]
12:18:10 <lambdabot>   add an instance declaration for (Num (Maybe Int))
12:18:17 <Cale> Everything in the powerset of xs is also in the powerset of (x:xs)
12:18:23 <oerjan> Cheery: ^^ precedence error
12:18:26 <Cheery> > mapMaybe (\x -> if x < 20 then Just (x - 20) else Nothing) $ take 40 [0..]
12:18:27 <lambdabot>  [-20,-19,-18,-17,-16,-15,-14,-13,-12,-11,-10,-9,-8,-7,-6,-5,-4,-3,-2,-1]
12:18:35 <Cale> But there are some additional elements in the powerset of (x:xs), what are they?
12:18:36 <Cheery> :P
12:18:49 <Cheery> > mapMaybe (\x -> if x > 20 then Just (x - 20) else Nothing) $ take 40 [0..]
12:18:50 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]
12:18:58 <laura22> Cale, its subsets?
12:19:18 <Cale> laura22: Well, specifically, the subsets which contain x.
12:19:29 <laura22> oh right
12:19:34 <Cale> (they wouldn't already be included in the powerset of xs)
12:19:34 <Cheery> oerjan: teh lambdabot gave too little hints
12:20:03 <Cale> any subset of (x:xs) which contains x can be written as x:ys, where ys is some subset of xs
12:20:17 <Cale> agreed?
12:20:23 <Cheery> @ty filter
12:20:27 <Cale> So this gives us a recursive solution to the problem.
12:20:29 <oerjan> Cheery: add an instance declaration for (Num ... often means you are using something numeric where it expects another type
12:20:29 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
12:21:02 <Cale> powerset (x:xs) = powerset xs ++ [x : ys | ys <- powerset xs]
12:21:03 <Cheery> hm. so mapMaybe is sort of map and filter combined to one dire beast
12:21:12 <oerjan> @src mapMaybe
12:21:13 <lambdabot> Source not found. Sorry.
12:21:13 <Cale> Or to put it another way:
12:21:21 <Cale> powerset (x:xs) = powerset xs ++ map (x:) (powerset xs)
12:22:10 <Cheery> oerjan: that does make sense only if you think you've actually written it right. :)
12:22:47 <oerjan> Cheery: not at all.
12:23:07 <Cale> > (`runState` 0) . (`runContT` return) $ do v <- callCC (\k -> forever (do n <- lift get; if n > 10 then k n else lift (put (n+1))); return v
12:23:07 <lambdabot> Unbalanced parentheses
12:23:15 <oerjan> > (1::Int) ++ "hi"
12:23:15 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Int'
12:23:17 <Cale> > (`runState` 0) . (`runContT` return) $ do v <- callCC (\k -> forever (do n <- lift get; if n > 10 then k n else lift (put (n+1)))); return v
12:23:17 <lambdabot> Terminated
12:23:21 <Cale> > (`runState` 0) . (`runContT` return) $ do v <- callCC (\k -> forever (do n <- lift get; if n > 10 then k n else lift (put (n+1)))); return v
12:23:22 <lambdabot> Terminated
12:23:24 <Cale> hmm
12:23:41 <Cale> oh
12:23:45 <Cheery> um. I meant, does make sense if you think you've actually written it  wrong
12:24:02 <Cale> ah, right
12:24:03 <ukl> now, finally: powerOf2 n = length $ powerset [1..n]
12:24:04 <Cheery> anyway, ghci quirked: "In the expression: if x > 20 then Just x - 20 else Nothing"
12:24:17 <Cale> > (`runState` 0) . (`runContT` return) $ do callCC (\k -> forever (do n <- lift get; if n > 10 then k () else lift (put (n+1)))); get
12:24:17 <lambdabot> Terminated
12:24:28 <Cheery> I think that's the nearest 'tip'
12:24:33 <Cale> okay, that really shouldn't be "Terminated"
12:24:43 * Cale wonders what's going on...
12:25:11 <Cale> oh
12:25:13 <Cale> er..
12:25:22 <oerjan> :t (`runState` 0) . (`runContT` return) $ do callCC (\k -> forever (do n <- lift get; if n > 10 then k () else lift (put (n+1)))); get
12:25:23 <lambdabot>     Ambiguous occurrence `lift'
12:25:23 <lambdabot>     It could refer to either `Control.Monad.Error.lift', imported from Control.Monad.Error
12:25:23 <lambdabot>                           or `Control.Arrow.Transformer.lift', imported from Control.Arrow.Transformer
12:25:35 <oerjan> lots of those i see
12:25:40 <Cale> > (`runState` 0) . (`runContT` return) $ do callCC (\k -> forever (do n <- lift get; if n > 10 then k () else lift (put (n+1)))); get
12:25:42 <lambdabot>  (11,11)
12:25:46 <Cale> there we go :)
12:26:15 <Cale> I've imported Control.Arrow.Transformer and Control.Arrow.Transformer.All as AT
12:26:33 <laura22> Cale, thank you ^^
12:26:41 <Cale> laura22: No problem :)
12:27:43 <Cheery> btw. I think haskell type system could be even more restrictive, but it has a limit at a point where marshalling and playing 'outside' the type system is too major
12:27:49 <oerjan> > runST (do x <- newSTRef 1; writeSTRef x 2; readSTRef x)
12:27:50 <lambdabot>   Not in scope: `readSTRef'
12:28:14 <Cale> laura22: The monadic solution using filterM in the list monad is actually a rather expressive way of stating the solution, once you understand the parts. filterM is like filter, except that the conditional, rather than being a function a -> Bool is instead a function a -> m Bool, giving a computation which will run to decide whether the element stays in the list or is removed
12:28:39 <Cale> In the list monad, computations are lists, and running such a computation is choosing one of its elements in all possible ways
12:29:12 <Cale> So  filterM (\x -> [True, False]) xs   means "for each element in the list, either keep it, or throw it away"
12:29:36 <Cale> which is exactly the description of the powerset
12:29:47 <monochrom> Hrm, why does ICFP come to Canada every so often?  Not too long ago it was Montreal.  Now it's Vancouver.
12:29:59 <Cale> Because Canada is awesome.
12:30:07 <Cale> ;)
12:30:52 <Igloo> It alternates between America and Europe
12:31:06 <laura22> Cale, good to know, thanks a lot
12:32:33 <Heffalump> monochrom: I thought it was Victoria.
12:32:59 <monochrom> Oops.
12:33:08 <Heffalump> even further West :-)
12:33:10 * shepheb looks up Cale's location.
12:33:27 <Cale> shepheb: Brantford, Ontario
12:33:28 <shepheb> Cale: I'm a University of Waterloo comp sci undergrad.
12:33:41 <Cale> shepheb: Cool, I went there for pure mathematics.
12:34:00 <conal> Cale: what do you do now?
12:34:49 <Cale> conal: Not much, but I've had a long enough break now, and will be looking for some place to do graduate studies soon enough.
12:35:15 <saccade> flee! flee back to academia!
12:35:20 <saccade> (I did.)
12:36:15 <Cale> I'm really not very well suited to anything else :)
12:36:32 <Cale> So I hope it works out for me somehow :)
12:36:53 <Cale> Well, I suppose I could write software if it came down to that.
12:37:57 <Cale> Perhaps move out west and see about getting hired by Galois or something :)
12:38:51 <conal> Cale: grad school sounds good. are admissions tough these days?
12:39:04 <saccade> that's a rather general question
12:40:03 <conal> saccade: and yet i'm guessing Cale will know i mean specifically to his situation
12:40:11 <saccade> in the past couple of decades college admissions have increased in competitiveness considerably more than math research programs
12:40:31 <Cale> conal: I'm not sure, really.
12:41:13 <Gilly> I've been creating a small plotter interface in haskell. The main features are that the plots (currently ParametricPlot and ContourPlot) can be plotted to get a segment approximation of the curve and those approximations can be further used to create new plots (things like getDistance to those approximations are already implemented). You can see a sample plot with code http://btw.blobtrox.net/~btw/plotter.png here and http://btw.blobtrox.net/~btw/Plo
12:41:20 <Gilly> ... here. I'd be interested in hearing any comments.
12:41:28 <saccade> Cale: would you be going for pure math again?
12:41:44 <Cale> saccade: Yes, most likely. Specifically algebraic combinatorics if I can get it.
12:41:51 <saccade> about 1/3 of the people in my program came out of math
12:42:12 <saccade> planning on taking a crack at P=?NP then?
12:42:36 <Gilly> I'm looking for comments specifically about the syntax used (is it haskell-like?) as I'm rather new to haskell.
12:42:39 <Cale> More likely something to so with symmetric polynomials or something like that.
12:42:44 <Cale> to do*
12:42:56 <Heffalump> Gilly: the second URL doesn't work
12:43:13 <Cale> Gilly: your message got cut off in the middle of the second url
12:43:18 <Gilly> oh
12:43:23 <Heffalump> ah, that's why it doesn't work :-)
12:43:24 <Gilly> http://btw.blobtrox.net/~btw/Plot.hs
12:44:41 <Cale> I rather like the approach. By the way though, you don't need to type let over and over again.
12:45:04 <Gilly> oh that might be true :)
12:46:16 <Gilly> I use Graphics.GD to do the drawing... The contour plotting algorithm is really simple and the drawbacks are that it requires the contour to change sign to get plotted.
12:46:45 <Gilly> (That's why the last random contour misses a straight line from the center of the circle to the bottom side of the triangle)
12:47:08 <Cale> The parameters to drawAndSaveImage are almost in the reverse of the order I'd expect, but I'm not sure. :)
12:47:12 <Gilly> But OTOH not even gnuplot handles that kind of contours it seems (not 100% sure though)
12:47:35 <skorpan> is there any predefined type which is Ord => [((a,a), b)]?
12:47:39 <skorpan> Ord a*
12:47:45 <Gilly> oh settings parameter should be moved after rect i think
12:47:56 <Cale> skorpan: hm?
12:48:28 <Cale> Gilly: Parameters which would change least often should go first.
12:48:52 <Gilly> oh i never heard about that rule :) sounds reasonable though
12:48:55 <skorpan> Cale: no?
12:49:07 <Cale> Gilly: and you want increasing variability as you go down the parameter list. That way curried applications are of maximum usefulness :)
12:49:23 <Cale> skorpan: Like a type synonym? I'm not sure what you mean.
12:49:40 <Gilly> ahh i see :)
12:49:43 <Cale> skorpan: I don't think so, but if you're using lists of pairs, you may want to look at Data.Map.
12:49:51 <skorpan> Cale: thanks, i will
12:50:30 <Cale> skorpan: You should almost never use [(a,b)] as a lookup table, since lookups will be O(n) instead of O(log(n))
12:51:09 <Cale> (and this will make a big difference to the speed of your program if there are lots of lookups, even with pretty moderate sized lists)
12:51:16 <skorpan> Cale: in this case, time complexity is actually no issue, so i don't even know why i bother :) it would just be nice to lookup fast
12:51:38 <skorpan> my list is pretty much always < 100 elements
12:51:59 <skorpan> keeping the list sorted would be nice, because i only add elements to it at startup
12:52:00 <Cale> Any larger than about 4 elements and you should probably start considering Data.Map :)
12:52:12 <skorpan> so with a sorted list it would probably take O(log n) to lookup
12:52:20 <Cale> No, still O(n)
12:52:22 <monochrom> Time complexity is no issue.  But Data.Map is still much easier to use than [(a,b)].
12:52:28 <skorpan> Cale: why is that?
12:52:31 <Cale> It takes O(n) time just to walk down the list to the nth element.
12:52:46 <skorpan> ah, true
12:52:46 <skorpan> of course
12:52:46 <skorpan> that was silly :)
12:52:46 <gwern> hm. is the term 'versioned' ever used in a non-software context?
12:53:36 <byorgey> gwern: you just did.
12:53:55 <oerjan> no, he mentioned it
12:53:55 <byorgey> other than that, I don't think so =)
12:54:04 <byorgey> well, good point
12:54:27 <trez> skorpan: any progress? :)
12:54:28 <gwern> heh heh. the use-mention distinction strikes again!
12:54:57 <audreyt> gwern: yes, a woman may be versioned before giving birth
12:55:00 <skorpan> trez: much progress! these type classes piss me off though. how about you?
12:55:06 <audreyt> to version = manual turning of the fetus
12:55:23 <gwern> audreyt: ...really? what does that mean?
12:55:37 <audreyt> gwern: http://medical-dictionary.thefreedictionary.com/Versions
12:56:17 <gwern> huh. I had no idea
12:56:20 <trez> skorpan: haven't even chosen what project to do yet, the other courses are consuming all my time atm :P
12:56:55 <skorpan> trez: which other courses?
12:57:24 <trez> skorpan: mainly OS
12:57:35 <skorpan> OS is taking up your time?
12:57:53 <skorpan> i did virtually nothing in that course and got 4
12:58:13 <trez> yeah, had to finnish up the labs today and last work tomorrow :)
12:58:19 <skorpan> oh hehe
12:58:24 <trez> after that I'm free! :)
12:58:26 <Cheery> does lambdabot workout also on ircnet?
12:58:38 <skorpan> i'm starting to get worried about the programming lingo course, as i have only done the labs and pretty much nothing more
12:58:41 <skorpan> was the exam difficult?
12:58:43 <noecksit> hello, how may i able to compare two lists, if order does not matter?
12:58:56 <TSC> noecksit: sort them first, then compare the sorted versions
12:58:57 <noecksit> so, it is actually more of a set though
12:59:06 <skorpan> there are no duplicate elements?
12:59:21 <noecksit> i thought there mightve been premade function
12:59:31 <noecksit> skorpan: no
12:59:36 <TSC> There are two: sort, and (==)   (:
12:59:43 <skorpan> sort x == sort y
12:59:53 <oerjan> :t (==) `on` sort
12:59:56 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Bool
13:00:03 <lament> if the elements are not in Ord, you can do an ugly list comprehension
13:00:15 <trez> skorpan: depends on what grade you aim for, not to hard, one of the last questions was about lambda expressions and that was easy ;)
13:00:36 <Cheery> > intercalate "cat" ["lambda", "lol"]
13:00:40 <lambdabot>  "lambdacatlol"
13:00:42 <skorpan> trez: beta reduction etc.?
13:00:59 <trez> skorpan: something like that
13:01:07 <skorpan> we did beta reduction in programming paradigms
13:01:13 <oerjan> > concatMap (++"cat ")  ["lambda", "lol"]
13:01:14 <lambdabot>  "lambdacat lolcat "
13:01:40 <Cheery> > intercalate "cat" ["lambda", "lol", " tuna sandwitch", ""]
13:01:41 <lambdabot>  "lambdacatlolcat tuna sandwitchcat"
13:02:00 <oerjan> hm, nice trick
13:04:46 <Toxaris> lament: i would not consider (all . flip elem) an ugly list comprehension
13:05:15 <Toxaris> on the other hand, i may not be correct :(
13:14:29 <byorgey> noecksit: you could also convert the lists to Sets first (look at Data.Set) and then compare them... might be overkill for what you want but could also be useful
13:16:33 <guenni> I remember coming accross a paper, something with bananas and haskell and erik mijer, anybody which that is?
13:17:14 <Saizan_> ?google bananas lenses barberwire
13:17:14 <lambdabot> No Result Found.
13:17:19 <Saizan_> ?google bananas lenses wire
13:17:21 <lambdabot> http://citeseer.ist.psu.edu/meijer91functional.html
13:17:21 <lambdabot> Title: Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire (Research ...
13:17:56 <Saizan_> it's a paper on morphism, like cata- etc..
13:19:09 <Cheery> > product [20..1]
13:19:12 <lambdabot>  1
13:19:20 <Cheery> > product [1..20]
13:19:20 <lambdabot>  2432902008176640000
13:19:25 <notsmack> > product [20,19..1]
13:19:26 <lambdabot>  2432902008176640000
13:19:59 <guenni> thx, found it
13:23:22 <Cheery> > scanl (\x, y -> (x,y)) [1,2,3]
13:23:22 <lambdabot>  Parse error at "," (column 10)
13:23:30 <Cheery> > scanl (\x y -> (x,y)) [1,2,3]
13:23:30 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a, b)
13:23:30 <lambdabot>       Expec...
13:23:43 <Cheery> > scanl (\x y -> (x,y)) 0 [1,2,3]
13:23:43 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a, b)
13:23:43 <lambdabot>       Expec...
13:23:49 <Cheery> hm. :/
13:24:30 <gwern> @hoogle CForeign
13:24:30 <lambdabot> Foreign.ForeignPtr.mallocForeignPtr :: Storable a => IO (ForeignPtr a)
13:24:30 <lambdabot> Foreign.ForeignPtr.mallocForeignPtrBytes :: Int -> IO (ForeignPtr a)
13:24:30 <lambdabot> Foreign.ForeignPtr.mallocForeignPtrArray :: Storable a => Int -> IO (ForeignPtr a)
13:24:35 <Cheery> > scanl (\(_,x) y -> (x,y)) (0,0) [1,2,3]
13:24:36 <lambdabot>  [(0,0),(0,1),(1,2),(2,3)]
13:25:24 <gwern> @hoogle Locale
13:25:28 <lambdabot> System.Locale :: module
13:25:28 <lambdabot> System.Locale.TimeLocale :: data TimeLocale
13:25:28 <lambdabot> System.Locale.TimeLocale :: [(String, String)] -> [(String, String)] -> [(String, String)] -> (String, String) -> String -> String -> String -> String -> TimeLocale
13:26:42 <Cheery> > scanl (\(_,x) y -> (x,y)) (4,1) [2,3,4]
13:26:43 <gwern> @hoogle CInt
13:26:43 <lambdabot> Foreign.C.Types.CInt :: data CInt
13:26:43 <lambdabot> Foreign.C.Types.CIntPtr :: data CIntPtr
13:26:43 <lambdabot> Foreign.C.Types.CIntMax :: data CIntMax
13:26:46 <lambdabot>  [(4,1),(1,2),(2,3),(3,4)]
13:27:20 <gwern> @hoogle withCString
13:27:20 <lambdabot> Foreign.C.String.withCString :: String -> (CString -> IO a) -> IO a
13:27:20 <lambdabot> Foreign.C.String.withCStringLen :: String -> (CStringLen -> IO a) -> IO a
13:28:42 <Cheery> > scanr (\x (y,_) -> (x,y)) (4,1) [1,2,3,4]
13:28:44 <lambdabot>  [(1,2),(2,3),(3,4),(4,4),(4,1)]
13:29:02 <Cheery> > scanr (\x (y,_) -> (x,y)) (4,1) [1,2,3]
13:29:03 <lambdabot>  [(1,2),(2,3),(3,4),(4,1)]
13:40:51 <smg> would you recommend to read hte haskell report? :)
13:41:06 <mofmo1> so
13:45:56 <Cale> smg: Sure, it's worth reading at some point.
13:46:10 <mofmo1> >>= essentially means apply a function to the a in monad m?
13:46:15 <smg> i'm just done with your videos, gentle intro to haskell and yet another haskell tutorial
13:46:25 <smg> i'm just elaborating the next step
13:46:33 <smg> http://haskell.org/haskellwiki/Video_presentations <-- maybe this
13:46:47 <smg> and after that the books section at haskell.org
13:47:49 <mofmo1> so >>= has the type m a -> (a -> m b) -> mb
13:48:03 <notsmack> Cale has videos?
13:48:18 <smg> notsmack: no...
13:48:21 <smg> the videos he gave me
13:48:26 <notsmack> oh
13:48:27 <mofmo1> so a represents all the items contained within the m monad
13:48:37 <smg> notsmack: it's on youtube about monads
13:56:05 <astrolabe> smg: I think it is particularly worth reading the report chapter about the prelude.
13:56:11 <smg> ok
13:57:08 <smg> astrolabe: i'm a bit sad that there isn't much material in german about haskell
13:57:24 <osfameron> evening
13:57:35 <osfameron> is "'Executable' stanza starting with field 'flag small_base description'" an error message in Cabal?
13:58:20 <notsmack> why does runGet call for Data.ByteString.Lazy.Internal.ByteString instead of just ByteString?
13:58:28 <osfameron> ah, "xmonad 0.5 needs a newer version of Cabal."
13:58:34 <osfameron> says google
13:58:45 <osfameron> dunno why cabal couldn't give something that actually *looked* like an error message
13:59:20 <dons> notsmack: it uses internal representation details of lazy bytestrings
14:00:06 <Saizan_> notsmack: you mean the type?
14:00:16 <notsmack> Saizan_:
14:00:17 <notsmack> yeah
14:00:29 <notsmack> was just wondering why i couldn't use it on a bytestring i just readFile'd
14:02:14 <Saizan_> notsmack: do you use Data.Bytestring.Lazy.Char8.readFile? or Data.ByteString.Char8.readFile?
14:02:57 <notsmack> Saizan_: just Data.ByteString, i think?  i'm just playing around with it
14:03:24 <Saizan_> well there are two ByteString types
14:03:30 <Saizan_> one .Lazy and one not
14:03:40 <Saizan_> runGet wants the .Lazy one
14:03:53 <notsmack> alright
14:05:20 <notsmack> yep, adding the .Lazy works, thanks
14:06:09 <Cheery> > take 4 $ iterate (strapBy (++)) ["lolcat","catlambda","lambdanuke","nukelol"] where strapBy f lst@(a:xs) = g lst where { g [x] = [f x a] ; g (x:lst@(y:xs)) = f x y : g lst }
14:06:10 <lambdabot>  Parse error at "where" (column 79)
14:07:07 <Cheery> > let strapBy f lst@(a:xs) = g lst where { g [x] = [f x a] ; g (x:lst@(y:xs)) = f x y : g lst } in take 4 $ iterate (strapBy (++)) ["lolcat","catlambda","lambdanuke","nukelol"]
14:07:10 <lambdabot>  [["lolcat","catlambda","lambdanuke","nukelol"],["lolcatcatlambda","catlambda...
14:09:23 <RayNbow> @src (Maybe) (>>=)
14:09:23 <lambdabot> Source not found. :(
14:09:27 <RayNbow> @src Maybe (>>=)
14:09:27 <lambdabot> (Just x) >>= k      = k x
14:09:27 <lambdabot> Nothing  >>= _      = Nothing
14:09:44 <RayNbow> gotta love pattern matching :)
14:10:14 <jimminy> no i don't (but, of course, i do)
14:14:04 <gwern> http://radar.oreilly.com/archives/2008/03/state-of-the-computer-book-mar-22.html <-- someone should forward that to harrop and point out how ocaml is in the 'irrelevant' languages category :)
14:14:06 <lambdabot> Title: State of the Computer Book Market, part 4 -- The Lanugages - O'Reilly Radar, http://tinyurl.com/36863d
14:14:23 <gwern> (while Haskell is in the 'Minor' category)
14:14:38 <lament> cute
14:14:41 <gwern> 'The noticeable trend in the minor languages is that Haskell is up, although there were two additional Haskell titles added to the space in Q1 '07. The four Haskell titles are averaging fewer than 30 copies per month.'
14:15:32 <roconnor> what is a title?
14:15:45 <roconnor> oh books
14:15:45 <daf> a book
14:16:25 <roconnor> wow, ruby is a major language
14:16:25 <lament> ouch, actionscript outperforming python twice
14:16:30 <roconnor> when did that happen?
14:16:33 <lament> and ruby is way above python
14:16:36 <lament> roconnor: rails
14:17:01 <roconnor> what is rails anyway?
14:17:20 <lament> heh, C is the least popular non-irrelevant language
14:17:54 <chr1s> dcoutts: ping
14:18:00 <roconnor> okay, now I think this ranking is irrelevent.
14:18:01 <gwern> roconnor: rails cannot be explained. it must be seen
14:18:04 <ivan_> hi, i have a transformed monad of type ErrorT e (StateT r IO) a, and in a function i am getting no instance for Error e arrising from using throwerror?
14:18:17 <gwern> now; do you choose the red pill, or the blue?
14:18:21 <roconnor> gwern: i'll pick up a book on it then.
14:18:43 <roconnor> ivan_: what are you throwing?
14:19:05 <ivan_> roconnor: the e
14:19:12 <roconnor> e is a type
14:19:29 <ivan_> no, the function is abstract
14:19:49 <roconnor> anyhow, you need the Error e => constraint
14:19:53 <roconnor> @type throwError
14:19:55 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
14:19:56 <ivan_> the function is e -> m e r r
14:20:06 <roconnor> hmm
14:20:17 <roconnor> well, I'm sure that constraint appears somewhere.
14:20:38 <ivan_> my techer said that it could be solved without the error e constraint ? :/
14:20:48 <roconnor> @type runErrorT
14:20:49 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
14:21:05 <astrolabe> If I have a class in which method1 is defined in terms of method2, so to instatiate the class I need to define method2, but I want users of the class to only see method1, is there a good way of doing what I want?  Am I mad to want this?
14:21:12 <roconnor> ivan_: oh, maybe your teacher is right.
14:21:42 <dibblego> ?index getArgs
14:21:42 <lambdabot> System.Environment
14:21:43 <ivan_> roconnor: he probably is, but i have no ide what i am doing wrong
14:21:56 <dancor> how for is vty yi from being usable in a subwindow of another program
14:22:42 <roconnor> (Monad m, Error e) => MonadError e (ErrorT e m) is the instance declaration.
14:22:50 <gwern> if it can't do it now, I'd be pessimistic about it ever doing it, dancor
14:23:02 <roconnor> ErrorT is only a MonadError when e is an Error.
14:23:19 <Saizan_> astrolabe: do you need the users to instantiate the class?
14:23:33 <astrolabe> Saizan_: No
14:24:09 <Saizan_> astrolabe: so you can just avoid exporting method2, IArray does that iirc
14:24:30 <roconnor> ivan_: now I think your teacher is either wrong, or there is something you are misunderstanding.
14:24:36 <ivan_> roconnor: so why does haskell want a constraint on error e when i am doing e -> m e r r and throError e ???
14:24:45 <astrolabe> Saizan_: Ah, that seems obvious now.  Thanks.
14:24:51 <roconnor> @type throwError
14:24:52 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
14:24:57 <ivan_> roconnor: hope he is wrong :p
14:25:23 <roconnor> ivan_ throwError requires m to be an instance of MonadError.
14:25:32 <Saizan_> astrolabe: the syntax is ClassFoo(method1), i think
14:25:49 <ivan_> oh now i c maybe i am using the wrong error function
14:25:52 <roconnor> ivan_: ErrorT e ... is only an instance of MonadError when e is an instance of Error.
14:25:58 <astrolabe> Saizan_: Yep, that looks right.  Thanks.
14:26:12 <ikeda> hey, does anyone know what the best way to run haskell in embedded systems is these days?
14:26:47 <laura22> hm what function is computed by foldr (:) []?
14:26:50 <dons> ikeda: compile with ghc, then download the stripped object file to the target?
14:27:03 <dibblego> laura22, identity
14:27:10 <dons> > foldr (:) [] "haskell"
14:27:12 <lambdabot>  "haskell"
14:27:38 <astrolabe> @type foldr (:) []
14:27:39 <lambdabot> forall a. [a] -> [a]
14:27:55 <laura22> oh ok... quite a surprise to me ^^
14:27:57 <dibblego> @check \x -> foldr (:) [] x == (x :: [Int])
14:28:01 <roconnor> foldr (:) [] replaces all occurences of (:) with (:) and all occurances of [] with []
14:28:02 <lambdabot>  OK, passed 500 tests.
14:28:21 <dibblego> and all occurrences of occurance with occurrence ;)
14:28:28 <laura22> thanks guys ^^
14:28:35 <ikeda> dons: do you know of example projects?
14:29:37 <dons> ikeda: hmm, not off the top of my head. some people have done this to put haskell code on nokia mobile phones though
14:30:01 <dons> the fully statically linked objects should be nicely portable
14:30:17 <ikeda> ok I'll google that, thanx
14:31:51 <ivan_> roconnor: how do i return the e in the errorT, is it just possible with throwerror?
14:31:53 <dcoutts> chr1s: pong
14:32:48 <roconnor> ivan_: I don't understand your question.
14:32:57 <roconnor> @type runErrorT
14:33:05 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
14:33:18 <roconnor> when you runErrorT you will either get an e or an a.
14:34:12 <roconnor> > runIdentity (runErrorT (throwError "ivan_"))
14:34:13 <lambdabot>   Not in scope: `runIdentity'
14:35:09 <roconnor> > Control.Monad.Identity.runIdentity (runErrorT (throwError "ivan_"))
14:35:10 <lambdabot>   Not in scope: `Control.Monad.Identity.runIdentity'
14:35:29 <roconnor> :(
14:35:51 <roconnor> > runReader () (runErrorT (throwError "ivan_"))
14:35:53 <chr1s> dcoutts: have you aver seen a problem with gtk2hs and concurrency?
14:35:53 <lambdabot>  Couldn't match expected type `Reader r a'
14:36:25 <chr1s> I've got a yield every 50 milliseconds
14:36:50 <roconnor> > runReader (runErrorT (throwError "ivan_")) ()
14:36:53 <lambdabot>  Left "ivan_"
14:37:09 <chr1s> copied from the gtk2hs blog: timeoutAdd (yield >> return True) 50
14:37:14 <dcoutts> chr1s: right
14:37:28 <chr1s> but that gives me a "couldn't allocate memory" error
14:37:40 <dcoutts> chr1s: hmm, that's very odd
14:37:54 <chr1s> I'm not sure why, because it even happens without forkIO, just adding that line makes my app crash.
14:37:59 <dcoutts> chr1s: what is the full error message and does it come from gtk or ghc do you think?
14:38:07 <chr1s> one sec
14:41:15 <chr1s> dcoutts: memory allocation failed (requested 50331648 bytes)
14:41:21 <roconnor> we should add Control.Monad.Identity to the imports.
14:41:22 <chr1s> so it's probably GHC
14:42:18 <dibblego> does anyone know of a package that uses CABAL and produces an executable? the CABAL docs seem out of date
14:42:29 <chr1s> so it's basically a very simple application, and I'm not forking anything yet, just adding that line causes it to crash.
14:44:22 <smg> which book from http://haskell.org/haskellwiki/Books do you suggest?
14:44:28 <chr1s> dcoutts: I'm on GHC 6.8.2, Intel OS X and gtk2hs-0.9.12
14:45:10 <gwern> dibblego: doesn't half the stuff on hackage produce executables?
14:45:20 <dibblego> gwern, hrm, maybe :)
14:45:31 <gwern> smg: personally, I'd say save yourself the money until you're sure neither the wikibook or YAHT do it for you
14:45:51 <smg> gwern: i read gentle introduction to haskell, YAHT and the wikibook
14:45:58 <smg> gwern: but i guess i need one step more :)
14:46:01 <gwern> @seen sm
14:46:01 <lambdabot> I saw sm leaving #haskell and #darcs 2d 3h 12m 9s ago, and .
14:46:27 <gwern> read? bah. you need to do'em
14:47:47 <dibblego> gwern, do you of any specific one? each time I try a cabal file, there is no main-is or executable field and that's what is giving me problems
14:48:20 <gwern> dibblego: look at Monadius
14:48:26 <gwern> fun little game
14:48:36 <dibblego> cheers
14:48:59 * gwern sighs at hscurses's licensing problems. maybe if more people kept kosher with not mizing meat and dairy, not mixing LPGL and GPL code would be easier to understand?
14:50:07 <chr1s> dcoutts: it also happens without the yield, i.e. timeoutAddFull (return True) priorityDefaultIdle 50
14:50:43 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/6088#a1
14:53:20 <chr1s> dcoutts: I'm off now, if you know what could've cause the problem, send me a PM
14:53:34 <smg> gwern: how about craft of functional programming?
14:54:11 <gwern> smg: I used that one. I think it's good
14:54:37 <lauralaura> what's wrong in: [x | x <- [1..n], x<=n, n 'mod' x == 0] == [1,n] ? it says improperly terminated character constant.
14:55:01 <smg> gwern: k i buy it
14:55:12 <radix> lauralaura: ` vs '
14:56:01 <smg> lauralaura: ` mod `
14:56:09 <roconnor> /me starts reading Programming in Martin-Lf's Type Theory
14:56:09 * gwern sez, I don't think it'll do you much more good than YAHT, the wikibook, and planet haskell would, but is yr money
14:56:22 <lauralaura> hm is that really the only thing?
14:56:32 <opqdonut> roconnor: Martin-Lf?
14:56:34 <smg> [1,n] seems wrong
14:56:46 <smg> and you're missing a ]
14:56:50 <lauralaura> right ^^ haha
14:56:55 <roconnor> opqdonut: Martin-Lf!
14:56:55 <lauralaura> i'm so clumsy
14:57:10 <opqdonut> and the x<=n is redundant
14:57:15 <opqdonut> since x<-[1..n]
14:57:46 <dibblego> gwern, cheers, apparently switching the order of main-is and executable makes a difference
14:57:47 <jaj> I read "The Haskell School of Expression" by Paul Hudak and I liked it
15:00:04 <mux> is there someone working on implementing gstreamer bindings for haskell?
15:01:06 <gwern> dibblego: really? that's odd. I wonder if the documentation mentions that ordering is important
15:01:46 <kjdf> is there a standard function "sleep :: Int -> IO ()" ?
15:01:47 <gwern> http://www.haskell.org/haskellwiki/Applications_and_libraries/Music_and_sound "'    Minstrel is a curses frontend to the GStreamer library written in Haskell. '"
15:01:48 <lambdabot> Title: Applications and libraries/Music and sound - HaskellWiki, http://tinyurl.com/38fums
15:02:06 <radix> kjdf: I think it's called delayThread or something.
15:02:10 <mauke> kjdf: threadDelay
15:02:25 <radix> :)
15:02:26 <gwern> @hoogle delay
15:02:27 <lambdabot> GHC.Conc.threadDelay :: Int -> IO ()
15:02:27 <lambdabot> GHC.Conc.registerDelay :: Int -> IO (TVar Bool)
15:02:27 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
15:02:42 <kjdf> thanks
15:03:07 <dcoutts> chr1s: the memory allocation is a ghc exception and I very much doubt it's due to the yield
15:04:17 <mux> gwern: thanks
15:06:25 <ivan_> can any1 helpe me, how to throw an error in the transformed monad Error e (StateT r IO) a, i want to do this without the Error e contratint on my function
15:08:05 <gwern> some would have it that it is the bogdanoff brothers who are grossly ignorant
15:08:07 <gwern> er. mischan
15:08:15 <roconnor> @src throwError
15:08:15 <ivan_> @unmtl ErrorT q (StateT r IO) a
15:08:15 <lambdabot> Source not found. My mind is going. I can feel it.
15:08:15 <lambdabot> r -> IO (Either q a, r)
15:08:18 <mauke> :t throwError
15:08:22 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
15:09:00 <roconnor> ivan_: ErrorT (return (Left "ivan_"))
15:09:17 <roconnor> :t ErrorT (return (Left "ivan_"))
15:09:18 <lambdabot> forall a (m :: * -> *). (Monad m) => ErrorT [Char] m a
15:09:37 <roconnor> :t ErrorT (return (Left 6))
15:09:38 <lambdabot> forall t a (m :: * -> *). (Monad m, Num t) => ErrorT t m a
15:10:12 <cjb> hm, which monospace font is the awesomest?
15:10:23 <roconnor> FreeMono
15:10:30 <Zao> Schumacher Clean.
15:11:08 <gwern> dejavu sans mono
15:11:25 <Zao> With Bitstream Vera Sans Mono in a tight second place.
15:11:42 <mux> +1 @ dejavu sans mono
15:11:55 <gwern> the dejavus are bitstream but better
15:12:00 <yoshi> Is there no standard editing program that comes /w ghci?
15:12:40 <ivan_> :t get
15:12:42 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
15:12:52 <cjb> yoshi: the unix philosophy is for your compiler to be distinct from your editor; you should use whichever editor you like.
15:13:05 <gwern> why would ghci include an editor? seems like overkill
15:13:37 <roconnor> :t \e -> ErrorT (return (Left e))
15:13:43 <lambdabot> forall e a (m :: * -> *). (Monad m) => e -> ErrorT e m a
15:13:57 <mrd> ghci can invoke the EDITOR env var
15:14:04 <mrd> I think
15:14:08 <cjb> Zao: ah, that's a bitmap font?  I prefer scalable.
15:14:39 <Zao> cjb: Scalable would imply that it'd be smudgy and non-pixel-perfect :P
15:15:10 <mux> feh, anti-aliased fonts for the win!
15:15:13 <cjb> heh, fair point.  when you only have four pixels in width, you probably care which ones they are.
15:15:39 <wolverian> cjb, Consolas!
15:15:50 <gwern> ...so I did a google search for lambda-h, and my first hit was for some old hentai
15:16:02 <wolverian> gwern, so it was a success?
15:16:06 <ddarius> gwern: What were you expecting?
15:16:28 <Zao> cjb: Not many pixels per glyph here, no :) http://www.acc.umu.se/~zao/clean.png
15:16:34 <gwern> ddarius: I was expecting some results about a lambda type system implementing gradual typing
15:17:58 <ivan_> :t put
15:17:59 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
15:18:59 <ivan_> :t ErrorT (return (Right "foo"))
15:19:01 <lambdabot> forall e (m :: * -> *). (Monad m) => ErrorT e m [Char]
15:20:23 <Saizan> ?type liftM id ErrorT (return (Left "foo"))
15:20:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => ErrorT [Char] m a
15:20:38 <Saizan> ?type liftM id ErrorT (return (Left ()))
15:20:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => ErrorT () m a
15:20:56 <roconnor> liftM id?
15:22:04 <Saizan> haddock reports (Monad m, Error e) => Monad (ErrorT e m)
15:22:24 <Saizan> oh, parentheses
15:22:29 <Saizan> ?type liftM id $ ErrorT (return (Left (4::Int)))
15:22:31 <lambdabot>     No instance for (Error Int)
15:22:31 <lambdabot>       arising from a use of `liftM' at <interactive>:1:0-7
15:22:31 <lambdabot>     Possible fix: add an instance declaration for (Error Int)
15:22:38 <Saizan> there :)
15:23:15 <roconnor> ah
15:23:29 <sneg__> hello. i get the following error when doing tail (words body). Couldn't match expected type [Char] against inferred type [String]. Any ideas how to overcome this?
15:23:29 <Saizan> you can't use ErrorT e m as a monad without Error e
15:23:38 <roconnor> @type liftM id ErrorT
15:23:39 <lambdabot> forall (m :: * -> *) e a. m (Either e a) -> ErrorT e m a
15:23:42 <sneg__> body is a list of strings
15:24:15 <roconnor> @type ErrorT
15:24:16 <lambdabot> forall (m :: * -> *) e a. m (Either e a) -> ErrorT e m a
15:24:18 <Zao> ?type words
15:24:19 <lambdabot> String -> [String]
15:24:32 <sneg__> sorry... body is a string : >
15:24:44 <sneg__> i mean tail output is expected to be a list of strings
15:24:45 <roconnor> @type liftM
15:24:46 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
15:24:56 <Cale> > tail (words "hello there world")
15:24:58 <mauke> sneg__: your compiler thinks otherwise
15:24:59 <lambdabot>  ["there","world"]
15:25:21 <byorgey> sneg__: are you sure that 'body' has type String?
15:25:25 <sneg__> yep
15:25:32 <roconnor> Saizan: reader monad?
15:25:38 <Saizan> roconnor: yeah
15:25:47 <roconnor> :/
15:25:51 <byorgey> sneg__: can you paste your code, along with the error message, on hpaste.org?
15:25:55 <Cale> sneg__: can we see how it's defined?
15:25:58 <Cale> (body, that is)
15:25:59 <roconnor> some days I think r -> a shouldn't be a monad.
15:26:05 <sneg__> yes sure
15:26:07 <Cale> roconnor: why not?
15:26:18 <roconnor> Cale: potentially buggy.
15:26:24 <Saizan> it hides some obvious errors
15:26:25 <Cale> roconnor: buggy?
15:26:40 <Cale> hmm
15:26:52 <roconnor> Cale: Saizan made an error that wasn't caught by the type checker.
15:26:53 <Saizan> like here "liftM id ErrorT (return (Left ())) " where i meant liftM id $ ErrorT (return (Left ()))
15:27:04 <roconnor> ... granted his code was a bit silly.
15:27:22 <roconnor> but it still worries me
15:27:26 <bos> oh, that's lovely.
15:27:30 <Cale> Well, in a larger program, that would have been caught easily.
15:27:32 <roconnor> at least r -> a isn't a monad in the Prelude.
15:27:49 <Cale> I really wish the (->) r monad *was* in the prelude.
15:27:54 <Saizan> yeah, it's not a big problem
15:28:20 <Cale> its consequences are quite useful.
15:28:36 <roconnor> I know
15:28:42 <roconnor> @quote liftM
15:28:42 <lambdabot> mauke says: product `liftM` liftM read `liftM` liftM return `liftM` take 5 $ "1234567"
15:28:54 <roconnor> those consequeces. :P
15:29:14 <Cale> liftM is just function composition, so it's a little silly to write it as liftM for the most part :)
15:29:19 <sneg__> http://hpaste.org/6089
15:29:49 <roconnor> Cale: I thought you wanted to replace (.) with fmap, or vice versa.
15:30:04 <Saizan> ivan_: so, if you need to use ErrorT just give a dummy instance for Error or write your own ErrorT
15:30:11 <Cale> roconnor: Well, yes, (.) should mean the same thing as fmap, and so should map :)
15:30:19 <Cale> (and we can kill off fmap at that point)
15:30:31 <mauke> > product . (read .) . (return .) . take 5 $ "1234567"
15:30:34 <lambdabot>  120
15:30:37 <Saizan> and we could fix Control.Monad.Error
15:31:06 <roconnor> > fix Control.Monad.Error
15:31:07 <lambdabot>   Not in scope: data constructor `Control.Monad.Error'
15:31:13 <Cale> heh
15:31:43 <Saizan> which inherits its brokeness from fail, btw
15:31:50 <Cale> Right.
15:31:53 <smg> Cale: are you here?
15:31:57 <Cale> smg: yep
15:31:59 <smg> hi mauke :)
15:32:23 <Cale> sneg__: what's the type of maybeM ?
15:32:41 <byorgey> sneg__: and what's the type of mynick ?
15:32:50 <sneg__> mynick is a string
15:33:02 <sneg__> maybeM one moment
15:33:02 <ivan_> roconnor: my monad alos has a right value which is held by the StateT right? in ErrorT e (StateT r IO) a, i get the same error using get and put. The instance error e... how do i tackle this problem, do i have to keep track of the transform stack?
15:33:05 <byorgey> ok, then [mynick, tail (words body)] is ill-typed
15:33:14 <byorgey> mynick is a String but tail (words body) is a [String]
15:33:25 <sneg__> ohhhhh
15:33:38 <byorgey> you probably want mynick : tail (words body)  instead of concat [mynick, tail (words body)]
15:34:21 <sneg__> hmmm i wrote so in the first place but it didnt like it for some reason. one momemnt
15:34:33 <roconnor> ivan_: StateT has pairs, but Right is for Eithers.
15:34:38 <byorgey> or maybe concat (mynick : tail (words body))
15:34:44 <lauralaura> bye guys ^^
15:35:14 <roconnor> ivan_ Saizan points out that ErrorT e m a isn't a monad unless e is an instance of Error.
15:36:11 <sneg__> hm it thinks mynick is a string
15:36:22 <sneg__> is a char, sorry
15:36:27 <sneg__> that is weiiird
15:37:00 <ivan_> roconnor: so if i want to put something into my monad, how do i do this without the constrain error e ?
15:37:06 <byorgey> sneg__: what makes you say that?
15:37:20 <sneg__> oh no. that is not the case. i m sorry once again... error messages confuse me
15:37:24 <sneg__> byorgey: Couldn't match expected type `Char' against inferred type `String'
15:37:30 <sneg__> this is what it says about mynick
15:37:40 <byorgey> note that trying to match String = [Char] against the type [String] = [[Char]] will result in the message 'couldn't match Char against [Char]'
15:37:55 <byorgey> sneg__: since to match [a] with [b] it recursively matches a with b
15:38:01 <roconnor> ivan_: you cannot do anything with the standard monad functions unless you have he constraint.
15:38:13 <byorgey> sneg__: yes, they can be confusing until you get used to them =)
15:38:39 <byorgey> sneg__: did my suggestion fix things, or are you still getting an error?
15:38:44 <ivan_> :t put
15:38:46 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
15:38:54 <sneg__> byorgey: i know get an error above
15:38:55 <ivan_> can i write this function myself then?
15:39:13 <byorgey> sneg__: you can paste your updated code with the new error message as an annotation to your original paste
15:39:24 <roconnor> ivan_: you can write all the functions yourself for your particular datatype if you wish.
15:39:43 <roconnor> ivan_: this is an assignment?
15:40:18 <sneg__> byorgey: http://hpaste.org/6089#a1
15:40:38 <ivan_> roconnor: a small part from it, he wanted me to remove the constraint, everything worked alredy, but now i have to define all the functions all over again
15:41:20 <roconnor> why does he want you to do that?
15:41:35 <sneg__> byorgey: in case you wonder where mynick actually comes from http://hpaste.org/6089#a2
15:42:28 <Saizan> sneg__: ok, so mynick :: String
15:42:41 <sneg__> yep
15:45:33 <ivan__> :t put
15:45:34 <Saizan> so i think you want (unwords (mynick : tail (words body))) there, or concat instead of unwords if you don't want spaces
15:45:36 <lambdabot> forall s (m :: * -> *). (MonadState s m) => s -> m ()
15:46:29 <Saizan> this is assuming body :: String too
15:47:21 <sneg__> Oh i see. yep that will work
15:47:23 <byorgey> sneg__: what is the type of is_request?
15:47:26 <byorgey> oh, ok
15:47:31 <roconnor> ivan__: for ErrorT e m a to be a MonadState s, m needs to be a MonadState s, ... oh and e needs to be an Error.  There is no winning.
15:49:35 <ivan__> roconnor: but is it possible to return like you showed befor for the throwError where you could write ErrorT (return (Left e)) is it possible to define put the same way?
15:50:07 <roconnor> @unmtl ErrorT e (StateT r IO) a
15:50:07 <lambdabot> r -> IO (Either e a, r)
15:50:12 <Saizan> ivan__: it's possibile but you still won't be able to use the result in a monadic context
15:51:10 <ivan__> Saizan: yes i understand this, but this monad should only work for my purpouse =)
15:51:20 <roconnor> > do {ErrorT (return (Left (5::Int)))}
15:51:22 <lambdabot>        add an instance declaration for (Show (ErrorT Int m a))
15:51:43 <roconnor> > runErrorT (do {ErrorT (return (Left (5::Int)))})
15:51:43 <lambdabot>        add an instance declaration for (Show (m (Either Int a)))
15:52:08 <roconnor> > runStateT (runErrorT (do {ErrorT (return (Left (5::Int)))})) ()
15:52:08 <lambdabot>        add an instance declaration for (Show (m (Either Int a, ())))
15:52:15 <roconnor> > runState (runErrorT (do {ErrorT (return (Left (5::Int)))})) ()
15:52:19 <lambdabot>  (Left 5,())
15:52:28 <kjdf> :pl \n = head $ dropWhile (<n) $ iterate (*2) 1
15:52:34 <kjdf> :pl \n -> head $ dropWhile (<n) $ iterate (*2) 1
15:52:35 <roconnor> > runState (runErrorT (do {ErrorT (return (Left (5::Int)))>>return True})) ()
15:52:35 <lambdabot>   add an instance declaration for (Error Int)
15:52:53 <roconnor> > runState (runErrorT (do {return () >> ErrorT (return (Left (5::Int)))})) ()
15:52:53 <lambdabot>   add an instance declaration for (Error Int)
15:53:04 <dons> dcoutts: around? have a look at section 4 (d) of the LGPL, I'm not sure its possible to satisfy those requirements in Haskell, except under the very specific case of either a) using hs-plugins, or b) distribute separate object archives with .hi files missing unfoldings
15:53:26 <roconnor> ivan__: you won't be able to use ErrorT (return (Left (5::Int))) in any do block that has more than 1 statement.
15:53:42 <roconnor> neither directly nor indirectly.
15:53:49 <dcoutts> dons: I know it's a bit tricky
15:54:01 <dcoutts> dons: btw, it doesn't have to be easy, just technically possible
15:54:32 <dons> oh, interesting.
15:55:27 <dons> dcoutts: have you read the ocaml variant on the LGPL?
15:55:39 <dcoutts> dons: are you looking at LGPL 2.1 or 3.0 ?
15:55:47 <dons> 3
15:56:59 <dcoutts> dons: the key term there seems to be "interface-compatible"
15:57:30 <dons> so ghc libs that are compiled with -O or above aren't interface compatible, due to inlining
15:57:36 <Cale> @pl \n -> head . dropWhile (<n) . iterate (*2) $ 1
15:57:36 <lambdabot> flip (head .) 1 . (. iterate (2 *)) . dropWhile . flip (<)
15:58:01 <dcoutts> dons: depends what interface you mean, not source API certainly, but there is an ABI defined by the ghc implementation
15:58:01 <dons> dcoutts: you could modify cabal to warn and compile LGPL code with -fno-interface-pragmas so it was interface compatible :)
15:58:27 <dons> so there's an ABI derived from the source, based on how code was unfolded, you mean?
15:58:32 <dcoutts> sure
15:58:37 <dcoutts> specified in the .hi files
15:58:50 <dons> you generally can't tweak much at the source level without getting linker errors
15:58:53 <dcoutts> it's abi compatible if the .hi files are the same
15:59:10 <dons> right. so that's only going to hold with -fno-interface-pragmas (or -Onot)
15:59:38 <dcoutts> dons: well if you use an ordinary ghc and make significant code changes
15:59:44 <dbpatterson> is there a subRegex for ByteStrings?
16:00:50 <dons> here's the ocaml modified LGPL with the variation for the interface issue ghc also has, http://caml.inria.fr/ocaml/license.en.html
16:00:53 <lambdabot> Title: Objective Caml's License
16:01:01 <dcoutts> dons: but in principle the .hi api could be translated into a C header file and you could implement the interface in C
16:01:03 <ivan__> :t get
16:01:04 <lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
16:01:39 <dons> dcoutts: what ABI isn't compatible under this interpretation then?
16:01:50 <dons> an encrypted one?
16:01:58 <dons> that explicitly disallows other use?
16:02:26 <dcoutts> dons: a code loading mechanism that checks the content
16:04:01 <dons> interesting. so really any unchecked linkage is ok, you think, since you can always call whatever you want at the ABI lvel
16:04:49 <dons> the other conditions on the LGPL,about distributing prominant LGPL notices and so on, are also interesting. I've not fully grokked when you're supposed to satisify those restrictions
16:04:50 <dcoutts> dons: a similar example is an LGPL C lib that include inline functions in the header files
16:05:03 <dcoutts> dons: is that not the same as the BSD?
16:05:20 <dons> yeah. that might break the "10 line header function" clause in the LGPL
16:05:33 <dons> no, we use the version without the advertising clause
16:05:58 <dcoutts> dons: but it says that the notice must be reproduced
16:06:09 <dons> oh yes, that's also true.
16:06:23 <dcoutts> - Redistributions in binary form must reproduce the above copyright notice,
16:06:23 <dcoutts> this list of conditions and the following disclaimer in the documentation
16:06:23 <dcoutts> and/or other materials provided with the distribution.
16:06:30 <dcoutts> from the ghc LICENSE file ^^^
16:06:34 <dons> yep. so without the prominent notice stuff
16:08:42 <dcoutts> dons: if you stuck a note into your own program's license file that'd be as prominent as your own copyright notice
16:09:09 <dons> I wonder why the ocaml guys decided to use their own variant of the license with out the linking glue
16:09:24 <dons> a different view on the linkability issue?
16:09:46 <dcoutts> dons: probably want to make it extra clear
16:10:00 <dcoutts> since it does require some interpretation to say if it's ok or not
16:10:06 * dons would like hackage to warn on LGPL uploads that the relationship to haskell code is unclear
16:10:18 <dcoutts> dons: so I'm not saying it is ok, but it's not obviously wrong
16:10:28 <dons> yeah.
16:10:51 <dons> the LGPL intent is supposed to be BSD3-like + modifications stay open sourced, I assume
16:10:59 <dons> when people use it in our community
16:11:03 <dcoutts> that's my understanding
16:11:04 <gwern> ironic that the very day I come across lgpl problems in hscurses, y'all start discussing it
16:11:19 <dons> but the LGPL license itself is a fairly obfuscated way of trying to enforce this
16:11:34 <dons> we need a "BSD3 + stays open" simple license
16:11:47 <dcoutts> dons: you know what layers are like
16:12:07 <dcoutts> dons: short licenses do not satisfy the layers because they leave too many corners unspecified
16:12:21 <dcoutts> it just doesn't chime with some hackers
16:12:34 <Igloo> Perhaps Cabal should have an LGPL/Haskell license, which has an "It's OK to cross-module inline" clause?
16:12:42 <dons> and the LGPL is aimed at an archaic distribution and compilation model :)
16:12:59 <dcoutts> dons: or perhaps it's a hint that we need a proper ABI ;-)
16:13:09 <dons> Igloo: or just that we state somewhere why the LGPL is ok for cabalised libs (if it is)
16:13:45 <Igloo> dons: AIUI no-one knows because it's not been tested in court
16:13:51 <dcoutts> dons: and it obviously depends on the compilation model, eg LGPL is fine for libs deployed with yhc and hugs
16:13:58 <dons> yep
16:14:13 <dons> its the ghc .hi file unfolding that makes it very hard to relink
16:14:24 <dons> and how "very hard" interacts with the weird linking rules of the LGPL
16:14:36 <dcoutts> that's analogous to the .h inline functions thing
16:14:48 <lament> heh: http://en.wikipedia.org/wiki/GNAT_Modified_General_Public_License
16:14:48 <lambdabot> Title: GNAT Modified General Public License - Wikipedia, the free encyclopedia
16:14:49 <Igloo> ghc -O0 is fine too
16:15:11 <lament> other languages have to adjust LGPL to make use of it
16:15:48 <dons> Igloo: yeah, -O0 or -fno-interface-pragmas clearly satisfy it, I think
16:16:07 <gwern> (please, won't someone think of the developers? onl *you* can prevent license proliferation)
16:17:39 <dcoutts> dons: so commercial users of LGPL libs could do that, they can tell ghc to ignore the unfolding parts of the .hi files for certain packages
16:18:01 <dcoutts> dons: and thereby have an ABI that can be used practically rather than just in theory
16:19:33 <dons> hmm. so that would be an interesting warning..
16:20:04 <dcoutts> dons: if you build a cabal package with license: AllRightsReserved
16:20:18 <dcoutts> and it uses LGPL libs
16:21:21 <hpaste>  Tener annotated "(no title)" with "itoa - different version" at http://hpaste.org/6090#a1
16:23:04 <Igloo> dcoutts: Hmm, I'm not sure AllRightsReserved is actually the right phrase for what we mean, BTW
16:23:40 <Igloo> Copyright notices for Free software generally look like
16:23:40 <Igloo> Copyright (c) 1994-1996,1998-2002 Todd C. Miller <Todd.Miller@courtesan.com>
16:23:40 <Igloo> All rights reserved.
16:24:06 <dcoutts> Igloo: they start like that and then provide a license
16:24:10 <Igloo> Undistributable might be what we mean?
16:24:27 <Igloo> Hmm, maybe. I don't understand how these things work.
16:26:52 <dcoutts> Igloo: proprietary stuff would be OtherLicense, but really it doesn't matter since we're not going to see any such things on hackage as source cabal packages :-)
16:27:21 <gwern> dcoutts: is that actually policy now, that hackage packages have to be Free?
16:27:30 <dcoutts> gwern: it's always been so
16:27:41 <dons> well, they have to be what, freely redistributable?
16:27:45 <dons> that's the only constraint?
16:27:45 <dcoutts> gwern: it makes no sense to upload things that cannot be downloaded :-)
16:27:52 <dcoutts> dons: right
16:28:08 <dons> but they can e.g. require you to do a dance, or display a notice, or whatever
16:28:21 <gwern> dcoutts: eh. there's the issue of implicit licenses modifying proprietary
16:28:34 <dcoutts> gwern: I don't follow
16:28:55 <dcoutts> dons: we've never really specified it, just left it up to peoples good judgement
16:29:00 <gwern> like emails to a mailing list - they're all rights reserved, but they can stillbe posted in an archive
16:29:31 <dcoutts> gwern: if it's the copyright author who uploaded it anyway
16:29:45 <dcoutts> gwern: which as you know is not always the case
16:34:26 <Pseudonym> OK, question.  Bernie Pope has an honours student who's interested in category theory and functional programming.
16:34:38 <Pseudonym> What are some good small research topics?
16:36:08 <dons> dcoutts: http://www.gnu.org/licenses/lgpl-java.html has some interesting clarifications about how easy it should be -- i.e. that it only has to be possible
16:36:09 <lambdabot> Title: The LGPL and Java
16:36:33 <ddarius> Pseudonym: Neil Ghani's (I think) recent paper on initial algebra semantics for GADTs has some interesting possibilities for growth.
16:36:56 <dons> dcoutts: "the LGPL works as intended with
16:36:57 <dons> all known programming languages, including Java. Applications which link to LGPL
16:36:59 <dons> libraries need not be released under the LGPL."
16:37:15 * Pseudonym will take a look, thanks
16:37:31 <Pseudonym> Bernie just asked me for suggestions, so I thought I'd get some opinions.
16:37:56 <dons> dcoutts: so that explicitly talks about the interface level accessibilty (and that it can be hard, as long as its possible)
16:38:12 <ddarius> Can you be any more specific on "functional programming" and/or "category theory", i.e. semantics, implementation, pragmatics?
16:38:14 <dcoutts> dons: you can of course email licensing@gnu.org and ask specifically about the .hi unfolding issue
16:38:41 <dons> yeah, we can do that.
16:38:52 <dcoutts> dons: java has a clear ABI at the bytecode level
16:39:15 <dons> "all known programming languages" is interesting.
16:39:27 <dons> well, haskell as a clear ABI at the ISA level
16:39:44 <dcoutts> heh, for some value of "clear"
16:39:53 <Pseudonym> Unfortunately, not all of the bytecode is accessible from the Java language.
16:39:57 <dons> hehe you don't think the Z encoding is clear??!
16:39:58 <ddarius> Pseudonym: One vague thing in particular from the aforementioned paper is coming up with more applications of Kan extensions.
16:40:09 <dcoutts> dons: that's possibly the clearest bit!
16:40:28 <dcoutts> dons: consider the rts interface for example
16:40:41 <dons> hehe.
16:41:24 <dcoutts> dons: the ghc runtime abi is not actually defined, we just know which bits of information it depends on
16:42:22 <siponen> Hi guys! Is there a statically linked binary package of GHC available? I should get it running on a computer that has no internet connection, some random old Ubuntu installed and is situated too far to make me want to do extra trips to get all the libraries right...
16:42:36 <glen_quagmire> > [("/", (/)), ("div", div)] :: (Num a) => [(String, a )]
16:42:44 <lambdabot>  ghc: failed with error code 9
16:42:51 <dons> 9!
16:43:03 <dons> > [("/", (/)), ("div", div)] :: (Num a) => [(String, a )]
16:43:08 <ddarius> > product [2..9]
16:43:10 <lambdabot>  ghc: failed with error code 9
16:43:11 <lambdabot>  362880
16:43:31 <dcoutts> dons: mm sigkill :-)
16:43:41 <smg> > foldr1 (*) [2..9]
16:43:41 <lambdabot>  362880
16:44:22 <Igloo> Hmm, that's exciting
16:44:28 <dons> mm, that code is doing something weird to my ghci
16:44:37 <dons> Igloo: try it in your local ghci
16:44:47 <Saizan> siponen: http://www.haskell.org/ghc/download_ghc_682.html#binaries <-- there?
16:44:47 <lambdabot> Title: GHC: Download version 6.8.2
16:45:00 <Igloo> I /think/ that's a bug SPJ fixed this last week
16:45:08 <dons> ah
16:45:15 <Igloo> Well, actually, I'm not sure. What do you mean by weird, dons?
16:45:21 <dons> glen_quagmire: did you just stumble on that?
16:45:34 <Igloo> For me it looks like an infinite loop
16:45:40 <dons> yeah. same
16:45:40 <dcoutts> Igloo: typechecking it fails to terminate, that's what's weird :-)
16:45:42 <ddarius> That's an interesting bug.
16:45:58 <dons> *very* interesting
16:46:00 <glen_quagmire> dons: yes. i was trying to figure out how to implement "+", "/", ... for my small language that has separate type for Int and Float
16:46:01 <siponen> Saizan: From the wording on the descriptions I think those are all dynamically linked.
16:46:09 <Igloo> dcoutts: Right, SPJ fixed an infinite loop in the TCer, and it works in my latest 6.8 branch build
16:46:15 <dons> awesome
16:46:17 <dcoutts> Igloo: ok
16:46:41 <Igloo> But I don't know how you would get a SIGKILL if that's what it is
16:46:55 <dons> oh, code.haskell.org has funky resource limits
16:46:58 <glen_quagmire> ex, I wanted :  "1 / 2" ==>  div 1 2     and "1.0 / 2" ==> 1.0 / 2
16:47:30 <Igloo> > last [1..]
16:47:33 <lambdabot> Terminated
16:48:39 <Igloo> http://hackage.haskell.org/trac/ghc/ticket/1899 is the bug I'm thinking of
16:48:40 <lambdabot> Title: #1899 (compiler does not halt) - GHC - Trac
16:49:07 <dcoutts> Igloo, dons: it is odd, since typchecking it in ghci here does not consume increasing memory so no oom killer problem
16:49:34 <dcoutts> should just use it's cpu time like last [1..]
16:50:20 <Igloo> Yeah, that's why I'm confused. It looks like the same bug to me, though
16:50:56 <smg> > let sig x = case x of { x | (x > 0) -> 1; (x < 0) -> (-1); otherwise -> 0; }
16:50:56 <lambdabot>  Parse error in pattern at "->" (column 51)
16:51:22 <smg> mmmmh!
16:52:16 <ddarius> > let x | True = 1 | False = 2 in x
16:52:30 <lambdabot>  1
16:52:40 <smg> > let sig x = case x of { x | (x > 0) -> 1 | (x < 0) -> (-1) |  otherwise -> 0; } in 10
16:52:41 <lambdabot>  10
16:52:48 <smg> ddarius: i figured it out :)
16:53:14 <smg> > let sig x = case x of { x | (x > 0) -> 1 | (x < 0) -> (-1) |  otherwise -> 0; } in sig (-10)
16:53:15 <lambdabot>  -1
16:53:34 <smg> @pl sig x = case x of { x | (x > 0) -> 1 | (x < 0) -> (-1) |  otherwise -> 0; }
16:53:34 <lambdabot> (line 1, column 19):
16:53:34 <lambdabot> unexpected "{"
16:53:34 <lambdabot> expecting variable, "(", operator or end of input
16:53:44 <smg> @pl let sig x = case x of { x | (x > 0) -> 1 | (x < 0) -> (-1) |  otherwise -> 0; }
16:53:44 <lambdabot> (line 1, column 23):
16:53:44 <lambdabot> unexpected "{"
16:53:44 <lambdabot> expecting variable, "(", operator, ";" or "in"
16:53:50 <smg> @pl let sig x = case x of { x | (x > 0) -> 1 | (x < 0) -> (-1) |  otherwise -> 0; } in sig(-10)
16:53:50 <lambdabot> (line 1, column 23):
16:53:50 <lambdabot> unexpected "{"
16:53:50 <lambdabot> expecting variable, "(", operator, ";" or "in"
17:00:17 <EvilTerran> pl can't deal with branching of any kind
17:00:26 <smg> ah okay
17:00:30 <EvilTerran> ?type signum
17:00:32 <lambdabot> forall a. (Num a) => a -> a
17:00:37 <EvilTerran> ?index signum
17:00:37 <lambdabot> Prelude
17:00:40 <smg> yeah i know it's pre-defined :)
17:01:01 <EvilTerran> > map (fromEnum . compare 0) [-5..5]
17:01:02 <lambdabot>  [2,2,2,2,2,1,0,0,0,0,0]
17:01:17 <smg> oO
17:01:25 <smg> interesting
17:01:26 * shepheb would really like conditional breakpoints in ghci
17:02:11 <EvilTerran> @check \x -> ((1-).fromEnum.compare 0) x == signum x
17:02:12 <lambdabot>  OK, passed 500 tests.
17:02:21 <smg> what's @check?
17:02:30 <EvilTerran> it tries loads of random values
17:02:34 <EvilTerran> @where quickcheck
17:02:35 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
17:02:41 <smg> nice
17:03:01 <EvilTerran> using that framework, and shows which value produced a wrong answer if the expression ever returns false
17:04:50 <EvilTerran> @check \x -> 1/(1/x) == x
17:04:50 <lambdabot>  Falsifiable, after 13 tests: -3.5714285714285716
17:04:54 <EvilTerran> heh
17:04:57 <smg> cool
17:04:58 <EvilTerran> @check \x -> 1/(1/x) == (x :: Rational)
17:04:59 <lambdabot>  Exception: Ratio.%: zero denominator
17:04:59 <smg> @localtime EvilTerran
17:05:00 <lambdabot> Local time for EvilTerran is Tue Mar 04 01:06:48
17:05:07 <EvilTerran> good morning :)
17:05:15 <smg> hehe
17:05:28 <EvilTerran> > 1/(1/0)
17:05:29 <lambdabot>  0.0
17:05:36 <smg> EvilTerran: i'm watching haskell videos
17:05:40 <EvilTerran> hooray for IEEE
17:05:41 <smg> what are you doing? :]
17:05:50 <smg> hehe
17:05:59 <EvilTerran> i'm about to pack my laptop up and take it over to my friends' house to have a late-night work binge
17:06:05 <smg> :D
17:06:06 <smg> binge?
17:06:14 <smg> note to myself: improve your english
17:06:23 <EvilTerran> @wn binge
17:06:23 <lambdabot> *** "binge" wn "WordNet (r) 2.0"
17:06:25 <lambdabot> binge
17:06:27 <lambdabot>      n 1: any act of immoderate indulgence; "an orgy of shopping"; "an
17:06:29 <lambdabot>           emotional binge"; "a splurge of spending" [syn: {orgy},
17:06:31 <lambdabot>           {splurge}]
17:06:32 <bockmabe> smg: What vids?
17:06:33 <lambdabot> [8 @more lines]
17:06:41 <EvilTerran> @more
17:06:43 <lambdabot>      2: an occasion for excessive eating or drinking; "they went on
17:06:47 <lambdabot>         a bust that lasted three days" [syn: {bust}, {tear}, {bout}]
17:06:51 <lambdabot>      v : overeat or eat immodestly; make a pig of oneself; "She
17:06:53 <lambdabot>          stuffed herself at the dinner"; "The kids binged on
17:06:55 <lambdabot>          icecream" [syn: {gorge}, {ingurgitate}, {overindulge}, {glut},
17:06:57 <lambdabot> Plugin `more' failed with: thread killed
17:07:01 <smg> http://video.s-inf.de/#FP.2005-SS-Giesl.(COt).HD_Videoaufzeichnung
17:07:02 <EvilTerran> oops
17:07:02 <smg> bockmabe:
17:07:05 <lambdabot> Title: S-INF.de - Vorlesungsvideos, http://tinyurl.com/y4m979
17:07:11 <EvilTerran> you get the idea
17:07:13 <smg> HD Videos about haskell in a good german university
17:07:18 <ddarius> "ingurgitate", that's a word I hadn't heard before
17:07:27 <EvilTerran> the usual term is "binge drinking"
17:07:31 <EvilTerran> but i like "work binge"
17:07:35 <smg> dict.leo.org ftw
17:07:47 <EvilTerran> that was princeton wordnet
17:07:49 <EvilTerran> @help wn
17:07:49 <lambdabot> I perform dictionary lookups via the following 13 commands:
17:07:49 <lambdabot> all-dicts ... Query all databases on dict.org
17:07:49 <lambdabot> devils ...... The Devil's Dictionary
17:07:49 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
17:07:49 <lambdabot> elements .... Elements database
17:07:50 <smg> ah alcohol hehe
17:07:51 <lambdabot> [9 @more lines]
17:07:52 <EvilTerran> hm
17:08:12 <EvilTerran> http://wordnet.princeton.edu/perl/webwn
17:08:12 <smg> bockmabe: you start here: 2005-SS-FP.V01.2005-04-12.HDV
17:08:14 <lambdabot> Title: WordNet Search - 3.0
17:08:47 <EvilTerran> anyway. time to shut my baby down and take her for a walk :P
17:09:00 <smg> haha
17:09:22 <siponen> If shutting down babies only was possible...
17:09:35 <smg> siponen: haha
17:09:48 <bockmabe> smg: cool thanks.
17:10:30 <smg> hehe np
17:10:38 <smg> but they are kinda large 800MB per video
17:14:41 <hpaste>  travisbrady pasted "no buffering" at http://hpaste.org/6092
17:15:08 <travisbrady_> does anyone know why the tidbit i just pasted would yield "no buffering"?
17:41:01 <jhtulb> @pl f a b = g a `k` g b
17:41:01 <lambdabot> f = (. g) . k . g
17:41:13 <dolio> @src on
17:41:14 <lambdabot> (*) `on` f = \x y -> f x * f y
17:41:37 <jhtulb> ah, thanks!
17:44:29 <jhtulb> is Data.Function new?
17:44:39 <jhtulb> my ghc install doesn't seem to like it :)
17:45:32 <dolio> New in 6.8, I think.
17:45:56 <jhtulb> weird; seems like a useful function
17:45:59 <Jedai> jhtulb: Yep, it appeared in 6.8
17:46:29 <ddarius> jhtulb: There are a handful of very useful functions that aren't in the Prelude even now.
17:46:30 <Jedai> jhtulb: there was already comparing in Data.Ord and fix in Control.Monad.Fix
17:46:34 <ddarius> (or some standard library)
17:50:34 <lispy> I find `on` to be quite confusing.  I don't quite get how to remember what it's doing (I still haven't found the mnemonic for it)
17:52:04 <lispy> :t on
17:52:06 <jhtulb> I just had a couple of   instance Ord Foo where compare = compare `on` length
17:52:07 <jhtulb> (say)
17:52:08 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
17:52:27 <dolio> The second argument is like a reference into a data structure.
17:52:47 <dolio> And the first is supposed to do something with two such parts.
17:53:13 <lispy> sounds like an fmap for non functors
17:53:28 <lispy> (although should work with functors too, right?)
17:54:09 <dolio> Of course, it works for arbitrary functions, not just functions that represent functional references.
17:58:04 <jhtulb> @hoogle Bool -> a -> a -> a
17:58:06 <lambdabot> No matches, try a more general search
17:58:15 <dolio> For instance, if you build a type for functional references: Ref t p = (t -> p, (p -> p) -> t -> t)
17:58:19 <jhtulb> @hoogle a->a->Bool->a
17:58:20 <lambdabot> No matches, try a more general search
17:58:44 <dolio> Which is a pair of a pointer into a data structure and an update for that part.
17:59:16 <dolio> The second argument to on takes such pointers.
18:00:02 <dolio> And uses a function on the parts, and such pointers to define a function on the whole structure.
18:03:00 <jhtulb> is there some lambdabot command for "here is a chain of library functions; find a better chain"
18:03:25 <dolio> You could try @pl, but that doesn't know about that many.
18:03:26 <lament> here's a program, find a better program?
18:03:37 <jhtulb> lament: yes. i also want a pony :)
18:04:06 <jhtulb> no wait, lollipop
18:05:05 <lament> :D
18:06:27 <shepheb> most of the decidable such patterns are already GHC optimizations. eg. map f . map g . map h === map (f . g . h)
18:08:38 <jhtulb> just prelude.map or will it actually try to see if my fmap is safe?
18:15:48 <jhtulb> @pl flip <|>
18:15:49 <lambdabot> (line 1, column 9):
18:15:49 <lambdabot> unexpected end of input
18:15:49 <lambdabot> expecting white space or simple term
18:15:56 <jhtulb> @pl flip (<|>)
18:15:56 <lambdabot> flip (<|>)
18:19:22 <gwern> @where haddock
18:19:22 <lambdabot> http://www.haskell.org/haddock/
18:20:27 <gwern> 'A monk asked Wen, "What is the difference between a humanistic, monastic system of belief in which wisdom is sought by means of an apparently nonsensical system of questions and answers, and a lot of mystic gibberish made up on the spur of the moment?" Wen said, "A fish."'
18:21:30 <byorgey> gwern: haha!
18:22:22 <gwern> wikipedia vandalism can be amusing sometimes
18:22:38 <byorgey> that was wikipedia vandalism?  hehe
18:24:53 <gwern> 'This may be public information. But if this were wikipedia I'd remove it as original research and a violation of privacy. ' <-- yes, a pity it is not?
18:25:06 <gwern> d'oh. mischan
18:29:10 <byorgey> @yow !
18:29:10 <lambdabot> What UNIVERSE is this, please??
18:32:19 * dolio is confused by CoqIde.
18:32:29 <moconnor>  /part
18:40:11 <Cale> @keal
18:40:12 <lambdabot> making a bot of me is highly offensive
18:41:30 <gwern> @keal
18:41:31 <lambdabot>  what have you been smoking? you narrow minded Haskell user?
18:41:39 * allbery_b muses that "offensive" has multiple definitions
18:41:57 <gwern> sometimes I wonder what keal live was like
18:43:19 <dcoutts> woo! 50% of the way on the roadmap to Cabal-1.4
18:43:26 <dcoutts> 17 tickets down, 17 to go
18:43:38 * dcoutts encourages everyone to pitch in
18:43:39 <byorgey> dcoutts: nice! =)
18:43:42 <dcoutts> http://hackage.haskell.org/trac/hackage/roadmap
18:43:43 <lambdabot> Title: Roadmap - Hackage - Trac
18:44:19 <dcoutts> remaining tickets for Cabal-1.4 by component:
18:44:20 <dcoutts> http://hackage.haskell.org/trac/hackage/query?status=new&status=assigned&status=reopened&group=component&milestone=Cabal-1.4&order=priority
18:44:22 <lambdabot> Title: Custom Query - Hackage - Trac, http://tinyurl.com/25boef
18:44:41 <Cale> @keal
18:44:41 <lambdabot> it is very easy to go off topic
18:44:43 <Cale> @keal
18:44:43 <lambdabot> i still dont understand how gci is supposed to do anything other than mathematics
18:44:45 <dons> dcoutts: so this cabal release will include cabal-install?
18:44:49 <gwern> sure, but what has cabal done for me *lately*?
18:45:56 <dcoutts> gwern: you mean apart from sanitation, the medicine, education, wine, public order, irrigation, roads, a fresh water system, and public health?
18:46:32 <dcoutts> dons: the release of cabal-install will depend on Cabal-1.4
18:46:46 <dons> ok. great.
18:46:58 <dons> they won't be simultaneous releases though?
18:47:04 <dcoutts> might be
18:47:13 <dcoutts> that's what's preventing a release of cabal-install at the moment
18:47:24 <dcoutts> that it depends on the development version of the Cabal lib
18:48:40 <gwern> dcoutts: that
18:48:45 <gwern> s all old news
18:48:52 * gwern doesn't drink wine, besides
18:48:54 <dcoutts> :-)
18:49:55 <dcoutts> dons: I worry slightly that as soon as we do a public release of cabal-install we'll find that to fix all the issues we need more incompatible Cabal lib changes, and then we have to go to Cabal-1.6 etc
18:50:10 <dons> do a beta release?
18:50:12 <dcoutts> dons: though the fact that people are using it already a bit helps
18:50:14 <dons> snapshots et al.
18:50:16 <dons> yes.
18:50:25 <dcoutts> dons: every day is a snapshot release :-)
18:50:32 <dcoutts> dons: but yes, we could announce one
18:50:47 <dcoutts> I've done at least once snapshot which I didn't announce
18:51:08 <gwern> 'every day is a snapshot release'? aw man now I want to parody some zen koans into haskell
18:51:12 <dcoutts> partly just to check the system for doing so works
18:52:23 <gwern> "Once, dons entered into dcoutts' cabal shop. He asked, 'What is the best release to use?' dcoutts replied, 'Every release is best! You cannot find a release in my shop which is not the best!' And dons was enlightened."
18:52:26 <dcoutts> dons: I think the major issue for cabal-install is config stuff and having a decent dependency resolution algorithm
18:52:37 <dcoutts> dons: btw, turns out that dependency resolution is NP-complete
18:52:44 <dons> hah!
18:52:50 <dcoutts> there's a reduction from CNF-SAT to it
18:53:00 <dons> wow.
18:53:03 <byorgey> that's awesome
18:53:13 <dcoutts> yes, apt solves NP-hard problems every time you use it :-)
18:53:22 <SamB> that would explain why debian always gets rid of the old packages ;-P
18:53:40 <dcoutts> though obviously in practise the problems we get are in the very easy end
18:53:44 <dibblego> dcoutts, how did you find that out?
18:53:49 * QtPlatypus stuggles with PHP "There must be a better functional way to do HTML templating."
18:53:52 <gwern> "Oleg faced his assembled students. 'Quickly, tell me about cabal 5 years from now!' The students hemmed and hawedm until Oleg shouted, 'EVERY DAY IS A SNAPSHOT RELEASE!'"
18:54:02 <dcoutts> dibblego: I suspected it and then read a paper by one of the debian apt devs
18:54:16 <gwern> QtPlatypus: I've heard good things about the hsstring haskell templating library
18:54:19 <SamB> dcoutts: yeah, I suppose people aren't trying to make it difficult to resolve dependencies. I wonder why not?
18:54:22 <Cale> Oleg does snapshot releases in the type system.
18:54:36 * dons `ap` home
18:54:52 <dcoutts> dibblego: it's reasonably clear that you can formulate the dependency problem as a boolean satisfacton problem, that's one way to do the algorithm, use a SAT solver
18:55:32 <dcoutts> dibblego: so that's a reduction from dep resolution to SAT, and it turns out you can go the other way too
18:55:38 <dcoutts> so it's NP-complete
18:56:02 <dolio> Romanes eunt domus.
18:56:34 <dcoutts> SamB: because it'd be insane :-)
18:56:46 <dcoutts> SamB: we'd not understand the solutions and would never have tested them
18:57:02 <dcoutts> we only ever get easy instances of the problem
18:57:44 <dcoutts> and there's probably little point looking for the hard solutions if there is no easy solution since it's likely to be highly convoluted and not be a configuration anyone has tested
18:58:42 <SamB> dcoutts: or would want
18:58:49 <dcoutts> SamB: right
18:59:33 <dibblego> hmmm, I was hoping to solve that problem some day
18:59:39 * byorgey gets bored with computation in the type system, and starts hacking a library to do computation in Cabal's dependency resolution system
18:59:40 <dcoutts> so my plan is to try a single pass algorithm that considers the constraints in a kind of top-down order and does no backtracking
18:59:44 <dibblego> thanks for saving me :)
18:59:50 <dcoutts> byorgey: here's some code...
19:00:10 <dcoutts> byorgey: http://haskell.org/~duncan/cabal/DependencySet.hs and InstallPlan.hs
19:00:17 * SamB wonders why xspice and ngspice are mutually dependant packages
19:00:20 <dcoutts> byorgey: see especially the comments in InstallPlan.hs
19:01:04 <dcoutts> byorgey: my general algorithm was to start at the top of the dependency tree and work down, gathering dependency constraints as we go
19:01:37 <byorgey> dcoutts: cool
19:01:38 <dcoutts> byorgey: go breadth first, considering all the choices at each level simultaneously
19:01:57 <dcoutts> byorgey: the idea is that we should always have a satisfiable partial solution
19:02:15 <dcoutts> byorgey: as soon as the constraint set becomes unsatisfiable we fail
19:02:24 <dcoutts> though we have some local choices
19:02:54 <dcoutts> but at each level, once we pick we're committed, no backtracking to try other versions
19:03:26 <byorgey> dcoutts: that sounds nice and simple
19:03:44 <byorgey> dcoutts: the question is, in what situations does that fail to find a solution when one actually exists?
19:04:35 <bd_> when you have alternatives and conflicts?
19:04:49 <bd_> A depends on C | D
19:04:50 <dcoutts> byorgey: when at one level we make a choice that is initial satisfiable but turns out after we go one level or more deeper to be unsatisfiable and there existed an alternative choice earlier that did lead to a solution
19:04:52 <bd_> B depends on D
19:04:55 <bd_> C and D conflict
19:05:18 <byorgey> dcoutts: right, but I mean, how would such a situation arise in practice?  and how common would it be?
19:05:23 <bd_> if you try to simultaneously install A and B, commit to installing C, and you're stuck
19:06:06 <dcoutts> bd_: we cannot have conflicts, except for versions of the same package, we have to satisfy all deps on Foo with the same version of Foo
19:06:07 <byorgey> bd_: true
19:06:43 <dcoutts> byorgey: I could try and construct one I guess
19:06:52 <jhtulb> does cabal ever look inside tarballs for information?
19:07:07 <dcoutts> jhtulb: no, only at the .cabal file
19:07:10 <jhtulb> ok, good
19:07:10 <byorgey> dcoutts: seems like it could happen easily if I have two versions of the same package installed
19:07:13 <bd_> okay, one package wants version >1, another < 3, and we have 2 and 3 installed?
19:07:22 <byorgey> bd_: right
19:07:27 <jhtulb> 'cause i think "does this tarball contain a file named FOO" is undecidable
19:08:03 <dcoutts> byorgey: my plan is to try this approach and then run it on all packages in hackage and see where it falls over and if the failures look reasonable
19:08:05 <wagle_home> huh?  O(n) search
19:08:28 <jhtulb> wagle: assuming you can nest tarballs
19:08:30 <byorgey> A depends on B >=1.  We have B 1.0 and B 2.0 installed, so we commit to B 1.0.  A also depends on C, and C depends on B >= 2.0.  and we're stuck.
19:08:40 <dcoutts> byorgey: I want the search to gather the evidence of the failure so it can be explained in an error message
19:08:59 <byorgey> dcoutts: yeah, sounds good.
19:09:16 <byorgey> testing it on what's actually out there is reasonable.
19:09:22 <wagle_home> jhtulb, still a linear search in the size of the tarball
19:09:55 <byorgey> dcoutts: and if there are some sort of flags you could use to force it to use certain versions?
19:10:12 <byorgey> like in my example scenario above you could force it to choose B 2.0 to satisfy A's dependency
19:10:13 <dcoutts> byorgey: yes, you can add additional constraints
19:10:24 <byorgey> ok, cool
19:10:55 <dcoutts> byorgey: the only thing the search cannot do is find solutions that do involve using inconsistent versions of a dependency
19:11:07 <dcoutts> byorgey: taking into account the deps of all installed packages too
19:11:24 <byorgey> dcoutts: ok, right.
19:11:42 <dcoutts> and not all such solutions would necessarily fail, but we cannot know that they would not so we should err on the side of caution
19:11:55 <dcoutts> but it will cause problems for packages that cannot be rebuilt
19:12:00 <dcoutts> eg the ghc package
19:12:11 <dcoutts> which in ghc-6.8.2 depends on bytestring-0.9.0.1
19:12:52 <dcoutts> so if you use the ghc package and you installed bytestring-0.9.0.4 and built some packages against bytestring-0.9.0.4 then we have a problem
19:13:02 <dbpatterson> what is the status of cross compiling with ghc?
19:13:13 <dcoutts> dbpatterson: none, and none planned atm
19:13:37 <dcoutts> dbpatterson: except what is necessary for bootstrapping on new target machines
19:14:42 <dcoutts> byorgey: in that case a solution would involve rebuilding some existing packages to use the older bytestring so that it'd be compatible with the ghc package
19:14:46 <dbpatterson> dcoutts: damn.
19:15:13 <jhtulb> wagle: tarballs are usually gzipped, so you can do (almost) arbitrary string rewriting
19:16:25 <wagle_home> so the output of gzip is undecidable?
19:16:51 <dcoutts> jhtulb: the hackage server has to unpack the tarballs to extract the .cabal file to put into the index, which is what cabal-install then uses
19:16:54 <byorgey> dcoutts: yes, I see how that poses a problem.
19:17:41 <jhtulb> wagle: only if you uncompress recursively, of course :)
19:17:56 <dcoutts> byorgey: so the nice thing about the definition of an install plan is that we can easily check if it's valid and it embodies all the decisions and trade-offs in finding a solution
19:18:27 <dcoutts> byorgey: it can describe plans that involve rebuilding existing installed packages
19:18:41 <byorgey> dcoutts: oh, cool
19:19:51 <byorgey> dcoutts: yeah, looking at the code now, this is neat =)
19:19:54 <dcoutts> byorgey: don't let me stop you from trying alternative methods or whatever, my ideas are so far untested :-)
19:20:08 <wagle_home> i dont see how you have to look at any byte in the compressed compressed tarball more than once..  the compression is always finite, so you don't get lost in an infinite output
19:20:43 <byorgey> dcoutts: hehe, ok =)
19:20:57 <byorgey> dcoutts: I wasn't planning on it, just trying to understand your approach
19:22:48 <dolio> wagle_home: You can make a file that decompresses to itself, so you will never finish searching it, barring logic to detect such cases. It's effectively an infinitely nested container.
19:22:53 <dcoutts> g'night folks
19:24:31 <wagle_home> dolio, hmm/ewww
19:24:40 <hpaste>  glen_quagmire pasted "I don't like op* functions. Is there a better way?" at http://hpaste.org/6093
19:26:12 <byorgey> night dcoutts
19:28:12 <dolio> wagle_home: http://www.maximumcompression.com/selfgz.gz
19:28:58 <byorgey> glen_quagmire: you could pretty easily create a higher-order function which takes a function (such as +, -, *, etc.) as input, and applies it to a [Val] in the way you do for each of thoer op* functions.
19:29:34 <byorgey> glen_quagmire: well, I guess / is a special case, but it would work for the others
19:29:47 <glen_quagmire> byorgey: yah / and div got me to write it that way
19:30:07 <byorgey> glen_quagmire: yup.  but you could still abstract away the other three
19:30:11 <wagle_home> dolio, next step is to encode ackermann's function in the series of A expands to B, which expands to C, ....
19:30:25 <byorgey> and just say  opAdd = mkOp (+), opSub = mkOp (-), and so on
19:30:46 <byorgey> then define mkOp :: (Num a) => (a -> a -> a) -> [Val] -> Val  appropriately
19:31:51 <ddarius> opDiv [Int a, Int b] = Int (div a b); opDiv args = mkOp (/) args
19:32:04 <dolio> wagle_home: Well, last time people were talking about that, someone posted a link to a 42Kb compressed file that, when decompressed (it's a bunch of nested archives) takes up several petabytes.
19:33:01 <glen_quagmire> mkOp f [Int i, Float f] ...  mkOp f [Float f, Int i] ...  do I still have to do this?
19:33:33 <wagle_home> still not technically undecidable, but might as well be
19:33:42 <byorgey> glen_quagmire: yeah, I can't see any way around that part.
19:34:06 <wagle_home> unless pathological compressions are detectable by their mathematical structure
19:34:20 <glen_quagmire> thank you byorgey
19:34:31 <wagle_home> but that ratio indicates that prolly doesnt work
19:34:49 <cjb> well, the way around is to monitor disk space and CPU time.
19:35:29 <byorgey> wow, how does one go about creating a file which is a fixpoint of gzip?
19:36:15 <ddarius> iterate gzip
19:36:18 <jhtulb> byorgey: figure it out. it's fun
19:37:04 <wagle_home> i wonder more about series of expansions in "gzip-space"
19:37:36 <jhtulb> byorgey: pretend you have a language with two commands: "print the next N lines verbatim" and "going N lines back from the current end of the output, copy M lines"
19:37:43 <jhtulb> byorgey: then write a quine in that
19:39:21 <wagle_home> will gzip correctly tell you the compression ratio on that petabyte expansion?
19:40:27 <jhtulb> wagle: the 'size' field is 32 bits, so probably not :)
19:41:11 <wagle_home> yeah..  it leaves itself wiggle room for not knowing
19:41:13 <dolio> wagle_home: http://www.unforgettable.dk/
19:41:13 <lambdabot> Title: 42.zip
19:42:08 <dolio> It isn't actually a 4.5 petabyte file. It's several levels nested with initially 4 gigabyte files.
19:43:25 <wagle_home> was thinking maybe you could refuse to expand a gzip that expanded into a gzip..
19:44:37 <wagle_home> but if a gzip expanded in one step to a couple petabytes, that'd not work very well..  8/
19:44:51 <jhtulb> there's a limit
19:44:55 <jhtulb> something like 32K / few bytes
19:45:45 <dolio> It's not that abrupt, but it goes from 4 MB to 4 GB in one step.
19:49:00 <hpaste>  glen_quagmire annotated "I don't like op* functions. Is there a better way?" with "(no title)" at http://hpaste.org/6093#a1
19:49:10 <jhtulb> ok, this should do it
19:49:41 <wagle_home> oh!  here's what you do..  take 42.zip and tweak it to expand into tarballs containing the gzipped pathologicals
19:49:50 <jhtulb> hang on
19:50:13 <jhtulb> http://la.pska.us/more.zip
19:50:16 <jhtulb> like so?
19:51:03 <wagle_home> i'm scared to press "uncompress this"
19:51:25 <dolio> Heh. So it's an infinite sequence of 4.5 petabyte archives.
19:52:13 <jhtulb> hm... still only a countably infinite number of 4.5 petabyte archives
20:09:08 <dons> Cale: this is a job for you, http://nobodyreadsthis.co.uk/2008/03/04/haskell-after-nightfall/
20:09:08 <lambdabot> Title: Haskell after Nightfall  Nobody Reads This
20:10:26 <dino-> oh boy
20:11:02 <dons> hehe
20:11:06 <cjb> poor guy, about to get spammed with language geeks
20:11:36 <dons> its an interesting insight into the mind of a php programmer (?)
20:11:37 <ddarius> In many ways, Haskell is a very inexpressive language.
20:11:51 <Riastradh> It is primitive, in a mathematical sense.  The state of the world must be represented explicitly, in a sense, whereas it is built-in to the `richer' evaluation models of other languages.
20:12:20 <dons> though the case here, 'for' and 'while' loops, just means he didn't find the Prelude
20:12:40 <ddarius> There are no C-style for or while loops in any of the standard libraries (for very good reason)
20:12:54 <dons> and he's not found list comprehensions yet, i assume
20:13:12 <dino-> I was curious about this "And also lacking the ability to use functions as variables"
20:13:33 <dons> so he knows php, does that offer any context for the remark?
20:13:44 * allbery_b *blinkblink*
20:13:53 <ddarius> List comprehensions are a poultice for our primitve lack of control flow contructs and generators.
20:14:26 <byorgey> "you simply have to recall the local function from inside itself"... i.e. recursion??
20:14:45 <dino-> byorgey: You, sir, are a caveman.
20:15:30 <dons> interesting insight into how programming is viewed by some: a set of fixed imperative constructs you combine
20:15:56 <dons> i sometimes forget what programming feels like for people not doing FP.
20:16:10 <Riastradh> Cut & paste concepts.
20:16:16 <byorgey> like... being a caveman? =D
20:16:29 <BMeph> dons: Like string processing in Lisp? ;)
20:16:35 <glen_quagmire> programming is about passing messages to objects
20:16:39 <dons> i guess this is a perfect "blub" post, isn't it.
20:16:48 <BMeph> Oh, NM, byorgey already said that. ;)
20:16:51 <dino-> dons: I was thinking exactly that, blub.
20:16:52 <dons> he can't imagine what something that doesn't use 'for' and 'while' is like
20:17:22 <dons> its startlingly obvious how the programming languages he has used have fixed his scope of understanding
20:17:29 <Riastradh> I think Paul Graham's ramblings about Arc are more perfect `blub' posts, to be honest.
20:17:35 <dons> its rare to see this kind of blub in such a pure form
20:17:38 <dons> Riastradh: :)
20:17:50 <ddarius> Riastradh: Good observation.
20:17:51 <BMeph> dons: So, who is this Paul Graham of the imperative world? ;)
20:18:08 <BMeph> Riastradh: Jinx! :)
20:18:42 <Riastradh> This fellow at least doesn't claim to understand it all, or even imply such a claim.
20:19:26 <mrd> paul graham is the paul graham of the imperative world
20:19:40 <byorgey> poor chap, he doesn't realize that using the word "Haskell" in a blog post is like speaking a magic word which summons a hundred powerful (if benevolent) genies... =)
20:19:49 <glen_quagmire> paul graham invented web applications
20:19:57 <ddarius> "a hundred"?
20:20:16 <dons> esp. in the title, byorgey :)
20:20:19 <BMeph> glen_quagmire: And small-cap VC's. ;p
20:20:20 <byorgey> well, ok, at least a hundred
20:20:23 <byorgey> dons: hehe, indeed =)
20:20:37 <dons> its cool that a guy like this thinks he should learn haskell
20:20:44 <dons> somehow it got on his radar
20:21:04 <ddarius> Haskell: Failing To Avoid Success Since 2000-something
20:21:17 <dons> 2005, according to my metrics
20:21:28 <byorgey> dons: yes, that is very interesting, I wonder why
20:22:19 <dons> http://www.ohloh.net/languages/chart?measure=contributors&l0=haskell&action=compare&controller=languages
20:22:21 <ddarius> According to John Baez, Haskell and LISP are the two most famous examples of functional languages.
20:22:25 <lambdabot> http://tinyurl.com/3y883g
20:22:34 <dons> so things bubbled along pretty flat till just into 2005
20:22:50 <dons> when everything went into darcs, and collaboration got a lot easier (just some of the factors)
20:23:06 <dons> (that graphs monthly contributors)
20:24:06 <ddarius> I can pretend that I'm a "old guard" Haskeller then.
20:24:11 <cjb> the most frustrating thing to me about Haskell at the moment is that, now that I understand most of the constructs I think I can expect to see, I look at someone's Haskell code expecting Enlightenment and instead.. it's kinda ugly.
20:24:14 <gwern> correct me if I'm wrong, but it sounds like he needs to learn haskell for a class - '. I just finished catching up (I think  I might have one weeks worth left to do come to think about it) with my Haskell programming exercises.'
20:24:20 <gwern> ...tangled syntax and all
20:25:21 <ddarius> Dylan Thurston was actually the person that indirectly led to me learning Haskell.
20:25:26 <Riastradh> cjb, do you ever look at anyone's code, in any language, and find enlightenment rather than just kinda ugliness?
20:25:53 <Riastradh> I know I have, but not often.
20:25:57 <glen_quagmire> i learned haskell because it came up a lot on reddit.com
20:26:32 <dons> cool :)
20:26:52 <cjb> Riastradh: No, of course not.  That's why I decided to learn Haskell, see.  :)
20:27:30 <dons> here's another interssting one, "But really. Can't at least someone make a monad that behaves like a Python generator (the range) so you could apply a function to each number supplied by the generator and decide what to do with it?"
20:27:32 <cjb> Although I've seen some pretty good Python code recently.  Not great, but like, "oh, that's concise."
20:27:45 <cjb> dons: *facepalm*
20:28:07 <dons> yeah, pretty funny considering the origin of yield and generators in python
20:28:12 <gwern> is that... suggesting mapping over a list?
20:28:16 <cjb> yes!
20:28:30 <dons> if that's the kind of world view we're up against, its a bit scary
20:28:45 <FMota> :|
20:28:59 <FMota> seems like typical case of someone who doesn't understand the implications of lazy
20:29:08 <dons> apparently monads can do everything though :)
20:29:21 <gwern> isn't python removing its FP constructs in v3? I heard something about that
20:29:23 <dons> i.e. he assumes there's probably a monad for something
20:29:41 <dons> no, foldl moved to a library, basically
20:29:48 <dolio> CC-delcont will let you write python-esque generators. :)
20:29:49 <FMota> I like Python though. I'm a lot better at it than at Haskell, that's for sure.
20:29:52 <dons> instead of being primitive
20:29:55 <dons> dolio: hehe!
20:29:59 <cjb> gwern: nah, it's not
20:30:07 <dolio> generator $ \yield -> do yield 1 ; yield 2 ; yield 3 ...
20:30:17 <cjb> they were thinking about removing filter, which you have a billion other ways to write anyway
20:30:20 <cjb> e.g. as a list comprehension
20:30:58 <cjb> I'm still holding out for optional static typing in Python.
20:31:48 <FMota> they're taking reduce from the builtins, and there's no obvious way to do it. For loops don't count. ;)
20:32:24 <dolio> FMota: Just implement a trampoline with exceptions. Simple. :)
20:32:24 <FMota> cjb: static typing doesn't really suit Python
20:32:42 <FMota> dolio: trampoline?
20:32:56 <dons> makes more sense for python than ruby though.
20:33:00 <dolio> FMota: Well, the problem with a recursive definition is stack overflows, right?
20:33:10 <dons> a lot of python looks like a lot of haskell, imo. and the haskell code's statically typed
20:33:40 <FMota> dolio: I see...
20:34:06 <dolio> FMota: So you count recursive calls and throw an exception to unwind the stack after so many.
20:34:17 <Cale> FMota: I don't quite understand why static typing shouldn't suit python, other than that it hasn't been statically typed, and its existing dynamic types are a bit messy.
20:34:44 <Cale> It would be quite reasonable to have a language which was recognisable as python, only with a good static type system.
20:34:58 <FMota> Cale: depends on how you define "good"
20:34:59 <lispy> dons: and the haskell tends to be might tighter on the memory consumed, in my (limited) experience
20:35:24 <dons> that'd been my experience too
20:35:25 <BMeph> "lacking the ability to use functions as variables" - WTF?!? Put down the crack pipe, man!
20:35:47 <dons> its interesting that he assumed the language was the limiting factor
20:36:00 <BMeph> What does that mean, using functions as variables?
20:36:00 <cjb> dons: you mean, as opposed to his brane?
20:36:10 <gwern> actually, what does that even mean, using a function as a variable? he talking about first-order functions?
20:36:15 <dons> yeah :) if i program epigram, and i can't do it, i assume its my fault.
20:36:18 * ddarius is going to start trolling in the Web 2.0 world by making random blogs and random blog posts.
20:36:22 <lispy> BMeph: I would assume that means first class functions
20:36:25 <dons> ddarius: mwhaha
20:36:59 <ddarius> Does PHP have first class functions?
20:37:01 <FMota> Cale: Python could never have a Haskell-like type system. It could have something closer to C++, with union types.
20:37:07 <lispy> ddarius: heh, aren't they doing that to themselves at the moment?
20:37:12 <dons> "It
20:37:13 <dons> is now inescapable that soon millions of people will be programming in haskell and erlang, and using
20:37:16 <dons> those languages to solve abstruse math puzzles. Get on this bandwagon before it's a fad!"
20:37:21 <BMeph> lispy: Wouldn't that be using a function as a parameter, or as an argument, though? "Using a function as a variable"?!? Bleech.
20:37:23 <FMota> Which I don't exactly consider "good". ;)
20:37:56 <dons> its difficult to imagine what he tried to do, where using a function as a variable didn't work
20:38:13 <Cale> FMota: I'm not assuming that all existing python programs would typecheck.
20:38:18 <dons> something that he expected to be able to do, based on knowing php, that he couldn't do.
20:38:20 <lispy> BMeph: not everyone has the PL theory sophistication to make a distinction between formal parameter and 'variable'
20:38:22 <ddarius> f x = x + 1; f = \x + 2
20:38:35 <cjb> perhaps he thinks that using functions as variables is the opposite of havin functions "call themselves from the inside".
20:38:51 <dons> ddarius: ok. so using a function as a variable :)
20:39:50 <dons> Cale, did you see the post?
20:39:52 <FMota> Cale: Aye, I can see that.
20:40:05 <dons> i'm interested in any insights you have. its so remote from the usual people we see
20:40:20 <ddarius> Thankfully in my opinion.
20:40:37 <dons> well, we made it to 470 people without too much trouble
20:40:44 <Cale> dons: what post?
20:40:46 <BMeph> lispy: Mmm, right. I suppose implying that languages w/o while or for loops are primitive, should have warned me from the start.
20:40:46 <dons> though i do sometimes miss the 4 hour discussions we'd have :)
20:40:55 <dons> Cale, http://nobodyreadsthis.co.uk/2008/03/04/haskell-after-nightfall/
20:40:55 <lambdabot> Title: Haskell after Nightfall  Nobody Reads This
20:41:38 <dons> maybe there's some lost in translation going on in his use of 'primitive' too
20:42:02 <ddarius> Those people on the other side of the pond talk funny.
20:42:15 <cjb> hey, don't lump all of us in with him
20:42:43 <lispy> cjb: too late ;)
20:42:50 <cjb> I wonder where in the UK he gets Haskell lectures.  York, maybe?  I'm gonna hope it's not Oxford.
20:42:53 <ddarius> cjb: I'm American.
20:43:04 <BMeph> I'm tempted to try the drugs he's using...but then I thing of the after-effects they must have - yikes!
20:43:14 <dons> the side effects, BMeph ?
20:43:18 * gwern sighs. The lyf so short, the craft so longe to lerne!
20:43:19 <cjb> ddarius: no, I mean, don't lump all of us Brits, of which I'm one, in with that dude who is stupid.
20:43:27 <dons> hehe
20:43:33 <dons> cjb, spj, and this guy
20:43:37 <ddarius> cjb: You totally missed the intent of my statement.
20:43:47 <ddarius> (The "I'm American" one.)
20:43:55 <hpaste>  DMG pasted "First public test of the Yhc Web Service" at http://hpaste.org/6094
20:43:57 <cjb> ddarius: Oh!  Okay.
20:44:05 <Cale> dons: Interesting to hear that Haskell seems primitive. I suppose in some sense it is. The core of the language is very simple, and most things are in the libraries.
20:44:08 <cjb> Your American subtle humor was too.. wait, what the hell?
20:44:31 <BMeph> dons: I tend to think of side-effects as effects that come along with using a drug, and after-effects things that happen...after taking them. ;)
20:44:38 <dons> wow, dmitry's yhc stuff is kinda amazing
20:45:03 <FMota> cjb: Funny. :-) I'd like to know what the post guy's on, though...
20:45:07 <Cale> I don't really understand what he means by using functions as variables...
20:45:11 <Adamant> I don't know why that post surprises anyone. Haskell may eventually go the route of Scheme in becoming a hated teaching language, at least in relation to the typical imperative/OO CS student.
20:45:34 <FMota> :/
20:45:39 <dons> Adamant: oh, its not surprising. its  curious artifact. but have we decided he's been forced to do it at school?
20:45:53 <sarehu> that reminds me of a link...
20:46:07 <Adamant> it's a reasonable conclusion since it's .uk, but you're right that we can't be certain.
20:46:11 <gwern> oh, neat. it compiled haskell down to javascript and ran it
20:46:15 <lispy> Cale: my theory on that one was that variable == formal parameter to him
20:46:17 <FMota> Well, dons, he seems like he isn't enjoying it, and he has "programming exercises", so I'm inclined to say, yes.
20:46:20 <BMeph> Cale: Welcome to the club. :)
20:46:38 <Cale> lispy: So, using functions as formal parameters? In what language do you do that?
20:46:56 <Cale> (and how does that work?)
20:46:58 <dino-> I wonder if he's not seeing pointers or refs to functions. Which is what a closure can look like to you in, say, Perl.
20:46:59 <bd_> "And also lacking the ability to use functions as variables" wheh? oO
20:47:16 <dino-> I mean, I wonder if it's that he's not seeing.
20:47:28 <cjb> dino-: yeah, that was my first thought.
20:47:28 <lispy> Cale: I haven't read the blog, but it sounded like he meant you could pass a function around as a value...
20:47:39 <bd_> maybe he means "And also lacking the ability to use variables in functions"
20:47:47 <BMeph> Aw, man! I just started poking around in the blog, and saw his avatar - he's a fan of one of my favorite web comics! I'm scared now.
20:47:53 <dons> its  a perfect troll, isn't it. so profoundly weird a sentence
20:48:26 * FMota stops worrying about troll and goes back to prototyping in Python.
20:48:40 <dons> prototyping in python? *sigh* ;)
20:49:01 <dons> you'll have perfectly typed pseudocode if you prototype in haskell, FMota. the lambda revolution has to start somewhere!
20:49:25 <FMota> problem: Haskell is simply too complicated.
20:49:31 * BMeph chants, "what better place than here, what better time than now..."
20:50:05 <dons> FMota: hmm. its so simple though. no for or while loops!
20:50:07 <bd_> FMota: maybe it's just not complicated enough :)
20:50:19 <lispy> FMota: when you're learning haskell, #haskell and the haskell-cafe mailing lists are great ways to deal with that complexity :)
20:50:22 <FMota> For me to start a new program, I mean. I'm more used to Python.
20:50:35 <dons> yeah, familiarity is reasonable :)
20:50:47 <ddarius> FMota: Haskell is downright primitive.
20:50:54 <BMeph> Ah, some of the mystery clears: "My name is James Reynolds and im a Student at the University of Portsmouth; Reading for a Degree in Computer Science."
20:50:55 <dons> but prototyping is a great place to start using haskell, since you end up with a beautiful model at the end -- that's going to be fast
20:50:55 <FMota> I'm thinking of making the finished product in Haskell though.
20:50:59 <dons> hehe
20:51:04 <Adamant> dons - we're about to start the functional languages part of my Languages class, I'll record and note class commentary on Haskell if you're interested. college is a typical middle of the road US CS program.
20:51:07 <dons> that would be an interesting progression
20:51:19 <dons> Adamant: oh, yes, that would be interesting.
20:51:23 <sarehu> I read somewhere on some jav forum a post by somebody beginning CS, learning haskell and java at the same time. she passingly mentioned that she liked haskell much better, but was trying really hard to get up to speed with java!
20:51:30 <dons> should be more fun now we've got all this great infrastructure in place
20:51:42 <dons> so much different from when i was using gofer and there was no haskell.org :)
20:51:58 <dons> sarehu: awesome
20:52:00 <Adamant> yeah, unfortunately they're pushing WinHugs as the Haskell translator of choice
20:52:13 <ddarius> That's fairly typical.
20:52:15 <dons> hmm, that's a pity, but does make sense for lots of windows users
20:52:23 <Adamant> I'm just gonna use ghc on my Mac
20:52:26 <dons> oxford, chalmers and unsw use ghc
20:52:27 <lispy> how do the linux students deal with winhug?  does that work in wine?
20:52:35 <Adamant> just use ghc
20:52:38 <dons> they'd use hugs, surely, lispy.
20:52:48 * lispy was teasing, yes.
20:52:51 <dons> hugs does create the impression its a toy language
20:53:02 <FMota> ghci isn't working on my mac. And on my linux (same machine, dual-booted), isSpace doesn't exist...
20:53:05 <FMota> :t isSpace
20:53:08 <lambdabot> Char -> Bool
20:53:14 <dons> FMota: hmm?
20:53:19 <dons> that's *wrong*.
20:53:21 <Adamant> FMota - have you tried the new dmg's for 6.8.2?
20:53:22 <ddarius> @index isSpace
20:53:22 <lambdabot> Data.Char
20:53:28 <adu> JamesR?!?
20:53:30 <adu> i know that guy!
20:53:30 * Cale comments.
20:53:38 <cjb> adu: bwahaha
20:53:40 <FMota> Adamant: I have not.
20:53:42 <cjb> adu: which uni is he at?
20:53:44 <ddarius> Cale: What have you done?!
20:53:54 <Cale> ddarius: hm?
20:53:58 <Adamant> Macports keeps shitting the beds and is still stuck on 6.6
20:54:01 <OceanSpray> #ghc's a bit dead right now.
20:54:02 <dons> FMota: isSpace is in Data.Char
20:54:02 <Cale> ddarius: I've added a comment to the blog.
20:54:10 <OceanSpray> how do I compile with complete static linking?
20:54:12 <FMota> dons: Okay. Next time I'll try that ;)
20:54:13 <Adamant> the dmg is your best choice for right now
20:54:22 <dons> Prelude> :m + Data.Char
20:54:23 <dons> Prelude Data.Char> dropWhile isSpace " hehe"
20:54:23 <dons> "hehe"
20:54:44 <wagle_home> last time i looked the dmg was only for mac/intel
20:54:58 <Adamant> that might be the case, I am mac/intel
20:55:51 <dons> mac/intel works. the .dmg is available, and will even be on apple.com/downloads soon
20:55:52 <Cale> ddarius: Everyone has to start somewhere. There's never anything wrong with helping out people who want to learn :)
20:55:58 <dons> Cale, definitely!
20:56:02 <FMota> I'm mac/intel as well, but I haven't updated ghc in a while (> 1 month)
20:56:33 <FMota> oh sod it, I'll just download it now
20:56:53 <Adamant> yeah, downloading is much easier than having to wait for compilation
20:57:25 <Adamant> I'm relearning the virtues of this after being all Gentoo all the time for a while.
20:57:49 <ddarius> Haskell: We Bring The Help To You
20:57:51 <dons> having a dmg makes it pretty painless
20:58:14 <Cale> Where did you find this blog? Google blog search?
20:58:15 <ddarius> (whether you want it or not)
20:59:13 * BMeph calls dmg-control, requesting more dmg
20:59:19 <Adamant> dmg incorportated
20:59:29 <dons> Cale: yeah
20:59:30 <Adamant> ated, whatever
21:00:01 <BMeph> Planned Dmg: Making all dmg, wanted dmg
21:00:15 <wagle_home> :t dmg
21:00:17 <lambdabot> Not in scope: `dmg'
21:13:54 <FMota> Adamant: where's said .dmg file, again?
21:14:13 <Adamant> let me find you a link
21:14:14 <FMota> I can't find it on the GHC website, and google is unenlightening.
21:17:21 <dons> gwern: 'frown' isn't on hackage
21:17:56 <Adamant> http://www.haskell.org/pipermail/glasgow-haskell-users/2008-February/014298.html
21:17:57 <lambdabot> Title: ANN: Mac installer pkg for GHC - 6.8.2.20080211 trial release (Leopard, Intel), http://tinyurl.com/23km8g
21:19:33 <wagle_home> http://www.haskell.org/ghc/
21:19:34 <lambdabot> Title: The Glasgow Haskell Compiler
21:20:14 <FMota> Thank you very much. :-)
21:20:20 <wagle_home> several download links there
21:35:22 <dibblego> is there a way of getting the /tmp directory in a platform-independent way?
21:39:58 <roconnor> @hoogle temp
21:39:59 <lambdabot> Distribution.Extension.TemplateHaskell :: Extension
21:39:59 <lambdabot> Language.Haskell.Extension.TemplateHaskell :: Extension
21:39:59 <lambdabot> System.IO.openTempFile :: FilePath -> String -> IO (FilePath, Handle)
21:44:23 <FMota> oh btw
21:44:30 <FMota> today's my 17th birthday
21:44:39 <FMota> for another 21 minutes, at least.
21:44:46 <Pseudonym> Happy birthday.
21:44:56 <FMota> Thank You. :-)
21:45:00 <BMeph> Happy B-day, FMota - it's my wife's B-day, too. :)
21:45:23 <Pseudonym> Or, perhaps, happy whole-numbered-multiple-of-an-arbitrary-time-period-since-birth.
21:45:34 <FMota> Awesome BMeph. Congrats to you wife too.
21:45:45 <BMeph> FMota: I'll pass it on. :)
21:46:02 * BMeph calculates how many fortnights it's been since his birthday
21:46:27 <FMota> Pseudonym: eh. Birthdays are important for legal status.
21:46:48 <FMota> At least until you're 21, in the US.
21:48:51 <dolio> Higher than that if you're looking to rent cars and such.
21:51:21 <FMota> really? :/
21:54:30 <dolio> Well, I haven't tried myself, but I've heard most places don't like renting to people under 24 or 25.
21:55:06 <dibblego> same in AU
21:59:07 <bos> the only easy way to rent if you're under about 26 is via a corporate account held by your employer. if you have an employer. and they have a corporate account.
22:01:17 <SamB> well... that probably makes sense.
22:01:52 <SamB> sucks if you happen to be a responsible driver under 26, but... makes sense.
22:03:52 <FMota> ugh.
22:08:06 <OceanSpray> if you define an accessor for one field, you have to make accessors for every field?
22:08:52 <dolio> Huh?
22:09:29 <kfish> OceanSpray, I assume you mean fields of a record?
22:09:40 <OceanSpray> data D = D {a :: Foo, b :: Bar}
22:09:42 <OceanSpray> yeah
22:09:58 <kfish> if you start a field name with an underscoare, you won't get warnings about it being unused
22:10:10 <OceanSpray> oh, underscore.
22:18:04 * BMeph wants MOAR UNDERSKOARZ
22:20:19 <dons> Cale++ http://the-programmers-stone.com/2008/03/04/a-first-haskell-experience/
22:20:22 <lambdabot> Title: The Programmers&#8217; Stone  Blog Archive  A First Haskell Experience, http://tinyurl.com/3dywmw
22:20:28 <FMota> How unportable is MVar?
22:20:33 <dons> "They say that if it compiles, it will run correctly. It?s nearly true! I?m amazed. ... Such buglessness will remove a huge source of indeterminism in production environments where the work of many teams is co-ordinated by schedules."
22:20:38 <dons> FMota: portable in what sense?
22:20:47 <FMota> different operating-systems
22:20:54 <dons> oh, very portable
22:20:58 <FMota> e.g. win, linux, mac
22:21:03 <dons> yes.
22:21:06 <FMota> okay, I'll take your word for it :)
22:21:15 <dons> ghc wouldn't work without it
22:21:41 <dons> concurrency and parallelism is available out of the box on all machines ghc works on, which is most
22:25:03 <Cale> dons: awesome :)
22:25:20 <dons> :D
22:25:52 <dons> i like the anecdote about haskell being like the unix community in the early 80s
22:27:29 <bd_> hm, so, by that analogy, a court order will force ghc to market itself via resellers, and eventually a bored finnish college student will write LHC, which after a decade or so will displace GHC? :D
22:28:10 <dons> i guess i do prefer the analogy to linux in the early 90s :)
22:30:29 <dons> Cale, and he's followed up on the list now
22:35:49 <bos> wow, that's a long and very interesting article.
22:36:05 <bos> dons: i assume you've already reddited it?
22:37:53 * dolio didn't realize that Extensions in a .cabal enabled them on all files in a package.
22:38:03 <bos> that's all it's for, in fact.
22:38:39 <dons> bos, oh. hehehe. no.
22:38:56 <dons> but it makes a good follow on from the big controversy about his earlier mail
22:39:23 <dons> this one, http://reddit.com/info/691v1/comments/
22:40:29 <bos> well then http://reddit.com/info/6as3z/comments/
22:40:49 <dons> ah ha
22:42:12 <dibblego> I have forced Haskell onto my colleagues who asked me to "just write a script" :)
22:42:37 <dibblego> I told them I'd choose "the right tool for the job"
22:42:48 <dons> good work
22:42:57 <dibblego> there have been protests
22:43:02 <dibblego> but fuggem
22:43:03 <dons> so many 'scripts' are translators, and we know a good tool for writing translators
22:43:13 <bos> we're talking a bit about using erlang at work.
22:43:27 <dons> cool. that would be a bit of coup
22:44:05 <bos> i think it would be interesting.  i'm not going to try to evangelise haskell there. i'm already dragging the engineering team by the nose through any number of other disruptive changes/.
22:44:14 <dons> hehe
22:44:20 <bos> if i start bringing up haskell, they'll just decide i'm messing with their heads.
22:44:24 <dons> yep
22:44:31 <dibblego> why do people think having to learn something is a valid reason not use that thing?
22:44:40 <dons> haha dibblego :)
22:44:56 <dons> "everything i don't know is stupid" syndrome
22:45:04 <dibblego> yep ;)
22:45:46 <dolio> He had an error from improper comment indenting? I find that hard to believe.
22:47:29 <inimino> hm did he read the H98 report?
22:47:32 <bos> so do i, but you know, there are a few other newbie errors in there. it's no surprise he'd have confused a few things.
22:48:11 <dolio> Yeah. I'd be interested to see it if it's true, though.
22:48:15 <bos> for example, lots of people start off thinking that tail recursion is the right way to do loops, when the actual right way to do loops depends on what you're doing.
22:48:29 <dolio> I'm pretty sure I've commented things in the middle of (say) a do block in column 1 without problems.
22:48:36 <inimino> seemed to me like the layout rules are unambiguously specified
22:49:07 <bos> as far as i know, the indentation of a comment-only line does not matter.
22:51:04 <dons> anyone got ghc on an eeepc yet?
22:55:52 <dolio> SPJ references Jon Harrop a lot in his Ericsson talk.
22:56:24 <dons> oh?
22:56:55 <bos> bummer.
22:57:23 <dolio> Yeah. His vector graphics library, and an algorithm for computing the nodes n hops away from a particular node in a network.
22:57:44 <dons> ah well
22:58:09 <dons> dolio: so there's a video of the talk?
22:58:18 <ska-fan> One shouldn'T learn haskell when one's day job is an OO language with half-assed functional functions which your co-workers use seldomly.
22:58:18 <bos> yes, on ulf wiger's blog.
22:58:40 <dolio> Yeah, several talks, actually.
22:58:42 <dolio> Two by SPJ, I think.
22:58:48 <dolio> One by Hughes.
22:58:52 <dons> ah yes, JL too
22:59:06 <bos> http://ulf.wiger.net/weblog/2008/02/29/functional-programming-seminar-2/
22:59:08 <lambdabot> Title: 1d9 Ulf Wiger  Functional Programming Seminar, http://tinyurl.com/38473e
23:02:56 <dons> someone want to drop that by -cafe@ ?
23:03:11 <glguy> yow
23:51:12 <dolio> @yow!
23:51:12 <lambdabot> I'm having a RELIGIOUS EXPERIENCE ... and I don't take any DRUGS
23:56:11 <hpaste>  ski annotated "adjunctions" with "correction" at http://hpaste.org/6060#a5
