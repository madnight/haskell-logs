00:00:25 <sclv> my other syntax woe of late is the poor interaction between infix and the layout rule.
00:00:31 <Peaker> solrize, I don't mind if that's how Haskell is "stored" in some backend, but I want it to be presented to me in the best visual way, which is a specialized UI showing the however-encoded Haskell code
00:03:26 <lispy> being able to still use the traditional tools is important to me.  So the 'however-encoding' would still need to be greppable I reckon.
00:04:19 <oerjan> sclv: are you referring to ending layout due to nonassociative fixity, which compilers don't even try to support and which will probably be removed in haskell-prime?
00:05:07 <Cale> I don't understand why people seem to think that a function which takes a parameter and passes that variable to some other function which it is using, doesn't "use" the variable in question.
00:05:21 <Cale> Doesn't that seem ridiculous?
00:05:43 <Peaker> is there any counter-boilerplate for liftM[n] ?
00:05:50 <sclv> no -- rather that fixity seems to override layout -- i.e. if I have a <|> b <|> c I want it to parse different if it visually "looks" like a <|> (b <|> c) just as it would with regular prefix function application.
00:06:03 <Peaker> Or is it considered OK that it is repeated for each arg count?
00:06:03 <Cale> Peaker: Well, there's ap
00:06:07 <ski> Cale : it only makes sense if you identify some uses as primitive/direct
00:06:10 <Peaker> Cale, ap?
00:06:12 <oerjan> (it used to be my syntax woe, but i think i got over it)
00:06:44 <Cale> :t ap
00:06:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
00:06:46 <sclv> building up cute chains of alternatives is much less fun when you need to throw parens all over the place.
00:06:51 <oerjan> sclv: oh.  layout only applies to let, where, do, (case) of blocks...
00:07:00 <Cale> > return (+) `ap` [1,2,3] `ap` [10,20]
00:07:01 <lambdabot>  [11,21,12,22,13,23]
00:07:08 <Cale> > liftM2 (+) [1,2,3] [10,20]
00:07:09 <lambdabot>  [11,21,12,22,13,23]
00:08:17 <Cale> > (+) <$> [1,2,3] <*> [10,20]
00:08:17 <lambdabot>  [11,21,12,22,13,23]
00:08:32 <sclv> oerjan: seriously? you mean it doesn't apply in regular function definitions at all?
00:08:39 <cjs> Is there a way to put the cabal package database somewhere other than --global or --user, such as in the "standard place" under the prefix I supply?
00:08:40 <lispy> :t (+) <$> [1..3]
00:08:41 <lambdabot> forall a. (Enum a, Num a) => [a -> a]
00:09:01 <dolio> Layout desugars to explicit {;}.
00:09:10 <dolio> So, no, nothing to do with function application.
00:09:11 <oerjan> sclv: only in that the parts must be indented more than the function name
00:09:20 <Peaker> I think if a syntax-less Haskell got a smart UI to edit it, we'd get rid of $, the infix-precedence, paren-stuff, etc
00:09:36 <sclv> hmm... that makes sense now that I think about it.
00:09:45 <lispy> Peaker: ($) isn't about syntax
00:09:52 <lispy> :t map ($)
00:09:53 <lambdabot> forall a b. [a -> b] -> [a -> b]
00:11:05 <Peaker> lispy, ok, then scratch the $ :-)
00:11:11 <lispy> > map ($) [+1, +2, +3, +4] [1,1..]
00:11:11 <lambdabot>  Parse error at "+1," (column 10)
00:11:22 <oerjan> sclv: oh and by that i mean the function name being _defined_, not any in sub-applications
00:11:25 <lispy> > map ($) [(+1), (+2), (+3), (+4)] [1,1..]
00:11:25 <lambdabot>  Couldn't match expected type `[t1] -> t'
00:11:26 <Peaker> a smart code UI editor could also let you view the Haskell program running against an example, as you edit it
00:11:35 <Peaker> Keeping it always syntatically valid
00:11:36 <lispy> oh, well you get the point :)
00:11:56 <Peaker> lispy, Yeah, $ is not about syntax when its not being called in the expression its used
00:11:56 <dolio> > zipWith ($) [(+1), (+2), (+3), (+4)] [1,1..]
00:11:57 <lambdabot>  [2,3,4,5]
00:12:12 <lispy> Peaker: do you always keep the syntax valid while you're programming?  I don't don't.  So that feature might actually be obnoxious :)
00:12:14 <Cale> I want a Haskell environment which can animate the stepwise reduction of an expression's code graph :)
00:12:14 <Peaker> lispy, but its also used for syntax when it is
00:12:30 <Peaker> lispy, I do want the syntax to always be valid, why not?
00:12:46 <Peaker> Cale, like subtext's expansion of the FP tree?
00:12:52 <lispy> Cale: I want that for type unification
00:13:00 <Cale> Peaker: Like HOPS
00:13:04 <Peaker> Cale, what's HOPS?
00:13:21 <Peaker> with my kind of suggestion - you could also have the same program be multilingual (same program edited, at same time, by Chinese and American :-)
00:13:26 <lispy> Peaker: there are plenty of times when I'm editing and the shortest path is via invalid syntax.
00:13:32 <Peaker> lispy, example?
00:13:32 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/
00:13:33 <lambdabot> Title: HOPS
00:13:36 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
00:13:37 <lambdabot> Title: HOPS - Animations
00:13:56 <Peaker> lispy, You could ofcourse map any such invalid-syntax mid-stage to a UI shortcut
00:13:57 <lispy> Peaker: obviously I fix it before I compile again
00:14:13 <sclv> in that case, my gripe is that the layout rule isn't more sophisticated. :-)
00:14:29 <Peaker> lispy, for example, if you convert a colon to a comma by first deleting it, you could have a "replace" in the UI, instead
00:14:37 <lispy> Peaker: have you ever heard of cognitive dimensions?
00:14:41 <Peaker> lispy, nope
00:15:06 <lispy> Okay, well in cognitive dimensions they have something called an escape from formalism
00:15:30 <lispy> basically, letting the use 'escape the formalism' can reduced a lot of frustration some times
00:16:08 <Peaker> lispy, I think I can prove that a UI can contain all shortcut paths you get by invalid syntaxes
00:16:14 <lispy> Peaker: I mean, it sounds like, to do some complex types of editing in your propose system I'd have to comment a region, edit it to taste and then uncomment it
00:16:23 <Peaker> lispy, a smart UI is at worst, as inefficient as a text editor in this case
00:17:02 <Peaker> lispy, nope, you'd use semantic transformations that do what you want - instead of invalid syntaxes, there's no "comment region" that lets you make a model invalid
00:17:41 <lispy> Peaker: I'm increasingly skeptical of the proposed system
00:17:48 <Peaker> lispy, Test it by example
00:18:02 <Peaker> lispy, tell me the kind of invalid-syntaxes you'd go through, and I'll explain the correct UI feature you should use instead
00:18:43 <lispy> You'd have to collect data about all the keystrokes/whatnot that real users do when doing real tasks in order to do that
00:19:34 <Peaker> lispy, even if you consider that being a minus (Which I believe I can formally prove not to be, at least against some objective measurement such as the number of keyboard keys required in each system), consider the vast amount of pluses you get as well
00:21:04 <wy> are getting de Bruijn indices compilation all about?
00:21:13 <lispy> Have you considered the cognitive load that you place on people when you require them to do only valid transformations by using editor features?  Each primitive you throw at the user increases the congnitive load a lot.  Think about a text editor.  How many primitives do you have to learn?  Sure, you have the possibility of invalid syntax, but how many experience programmers complain that syntax keeps them from their deadlines?
00:21:53 <dolio> lispy: All the ones that use Lisp. :)
00:22:55 <dolio> wy: Maybe it's me, but I don't understand your question.
00:23:01 <Peaker> lispy, the number of primitives available at any given context will be smaller than the one available in a text editor - and reflectionally available in the UI
00:23:25 <wy> dolio: I mean ... what is compilation
00:23:39 <Peaker> lispy: Also consider the upsides: A) Program is always running, you see the intermediate values of all computations  B) Type inference can happen sooner, quicker feedback, shorter loops  C) Names become comments - so programs become multilingual, renames are much easier.  D) semantic editing features are much easier to place in the editor
00:23:48 <wy> It seems to me most of the work is to converting names to indices
00:24:15 <lispy> Peaker: I recommend you take up some studies in HCI before you build such a system 1) A lot of research has already gone into this area 2) I can't tell that you've studied it at all, and even if you have the best idea knowing the relevant HCI will make your idea better.
00:24:34 <Peaker> lispy, E) Program can be visualized in multiple ways, things like showing/hiding redundant () are not part of the program
00:25:27 <Peaker> lispy, Well, given that I've been interacting with my computer for decades, and a lot of my friends have to, in the exact domain I want to work in, I think I know what me and my friends would want :)
00:25:43 <Peaker> lispy, And I suspect we are not that unique
00:25:53 <lispy> You're making huge leaps here.  I don't know how you jumped to (A) and I don't understand (C) at all.  Why is (D) true?
00:26:18 <Peaker> lispy, if the program is always valid, it is always runnable, you can show it running as you edit it
00:27:01 <Peaker> lispy, Names in syntax are used to create references between nodes in the program which is a graph. If those references are stored as node-references, rather than names, then names become comments
00:27:10 <lispy> Peaker: have you ever picked up the proceedings of VL/HCC the conference?
00:27:23 <Peaker> lispy, nope
00:27:33 <lispy> you have a lot of reading to do :)
00:27:46 <dolio> I can write syntactically valid programs that won't run.
00:28:04 <Peaker> lispy, D is true because creating semantic manipulations of a program at the textual-encoded level, where the encoding may be broken (syntax invalid at time) is much more difficult than a manipulation on an existing, valid program graph
00:28:36 <lispy> Peaker: have you read some of the research that has gone into eclipse?
00:28:42 <Peaker> dolio, "not run" can be converted to "throw some failure" which can be presented instead of a value
00:28:54 <Peaker> lispy, yes, especially subtext - which is an inspiration
00:28:54 <lispy> They have valid ASTs to work with and they still have to prove their refactoring transformations are valid
00:28:57 <dolio> wy: I suppose it might be easier to write a compiler for an encoding of a program that uses de Bruijn indices.
00:28:58 <lispy> And that's hard
00:29:22 <Peaker> lispy, ASTs are not program graphs, and they don't necessarily have an AST, because syntax may be currently broken
00:29:51 <Peaker> lispy, and the rest of the program they don't have at all (the text/AST of other files), at least not in a programmatically usable way
00:29:56 <dolio> wy: Since the index might correspond to some location on a call stack or something.
00:30:11 <lispy> Peaker: Well, it certainly sounds like you've done your homework and have it *all* figured out.  So, I'll let you get back to work.
00:30:43 <Peaker> lispy, My work is currently learning Haskell so I can do this for Haskell, as I was trying Python and ended up creating a half-arsed FP in Python :)
00:32:05 <oklofok> @die 1d2
00:32:05 <lambdabot> 1d2 => 1
00:32:13 <Peaker> lispy, btw: Have you seen subtext?
00:33:01 * glguy solves another PE problem in C to avoid stack overflows in Haskell... behold the power of pointer arithmetic!
00:33:24 <solrize> PE ?
00:33:46 <Excedrin> project euler
00:33:52 <mauke> which one?
00:33:57 <glguy> 179
00:34:46 <glguy> numbers 2 10000000 | factor | mycounter
00:34:50 <lispy> Peaker: subtext could refer to a lot of things
00:35:43 <dmwit> lispy: subtextual.org
00:36:00 <dmwit> That's almost certainly what he's talking about.
00:36:47 <solrize> er, yeah, if you've got a fast enough way to count the divisors, just map [2..10^7] through it
00:36:58 <solrize> and then use groupBy
00:37:45 <glguy> the group approach was too prone to stack blowing
00:37:51 <glguy> and I didn't feel like bothering with it
00:38:57 <solrize> that's interesting i guess group/groupby has to build up each group completely and then reverse it, there should be a version that gives you each group reversed
00:39:34 <oerjan> solrize: no, it is lazy, it doesn't reverse
00:40:08 <oerjan> @src groupBy
00:40:08 <lambdabot> groupBy _  []       =  []
00:40:08 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
00:40:08 <lambdabot>     where (ys,zs) = span (eq x) xs
00:40:08 <solrize> do i misunderstand?  there has to be a reversal when you actually look at the groups
00:40:45 <solrize> :t groupBy
00:40:46 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
00:41:10 <solrize> > groupBy (== . (`div` 5)) [1..20]
00:41:11 <lambdabot>  Parse error at "." (column 13)
00:41:25 <solrize> > groupBy ((== ). (`div` 5)) [1..20]
00:41:25 <lambdabot>  [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[11],[12],[13],[14],[15],[16],[17]...
00:41:35 <oerjan> > take 2 . head $ group (1:1:undefined)
00:41:35 <lambdabot>  [1,1]
00:41:54 <dmwit> > groupBy ((==) `on` (`div` 5)) [1..20]
00:41:55 <lambdabot>  [[1,2,3,4],[5,6,7,8,9],[10,11,12,13,14],[15,16,17,18,19],[20]]
00:42:12 <solrize> @src span
00:42:12 <lambdabot> Source not found.
00:42:27 <dmwit> solrize: This is not a generalization of span.
00:42:33 <mauke> how would you use groupBy for this problem?
00:42:48 <dmwit> groupBy's first argument takes two arguments; span's argument takes only one.
00:42:57 <oerjan> dmwit: span is part of the code for groupBy
00:43:14 <dmwit> erk
00:43:29 <lispy> Peaker: things like subtextual.org (assuming that's the subtext you meant) are riddled with unsolved problems.  And those will probably stay unsolved until the computer reads our mind or we take the A out of AI.
00:43:30 * dmwit shuts up... again
00:43:37 <lispy> ?quote read.*mind
00:43:37 <lambdabot> jrmole says: any program that could read minds would just evolve into a porn downloader
00:43:48 <lispy> and see the problem with reading our mind :)
00:45:51 <lispy> Peaker: and I wasn't joking when I said you should look up VL/HCC, there is an environment for teaching programming that's probably already what you have in mind call Alice.
00:46:38 <lispy> but, visual programming languages have essentially failed their original goals.
00:48:39 <lispy> If you're going to succeed where others have failed, it helps to know why they failed
00:50:44 <lispy> Peaker: softvis and chi are two other conferences you'll want to be familiar with
00:53:25 <Peaker> lispy, I have looked at Alice, its not what I have in mind
00:53:41 <Peaker> lispy, Subtextual is much closer to what I have in mind, only I think his UI superficially sucks ;-)
00:53:56 <Peaker> lispy, As in: Not keyboard-controlled enough
00:54:21 <Peaker> lispy, also, I think his "Actions" could really be just Haskell monads, rather than a special primitive (which is what he uses)
00:56:25 <Peaker> lispy, also, I want to focus on the time history becoming a time graph (for revisioning/branching) so that revision control is unified with undo/redo history in the editor
01:02:05 <solrize> http://cyclone.thelanguage.org  this is cool, it fixes most of C's worst lossage
01:04:41 <dmwit> http://cyclone.thelanguage.org/wiki/Why%20Cyclone is a real let-down.
01:05:01 <dmwit> They talk for six paragraphs about C, and then one sentence about Cyclone.
01:07:11 <Peaker> it also destroys most of C's goodness :)
01:07:36 <solrize> hmm there's instances in C of retargeting pointers from one region to another, but it's not that common to do so
01:07:55 <solrize> one thing i used to do was thread linked data structures through C stack frames, maybe cyclone would barf at that
01:08:18 <solrize> like, i did shallow binding in a recursive evaluator that way once
01:08:31 <QtPlatypus> solrize: Isn't that just asking for segmentation errors?
01:08:39 <solrize> not if you're careful
01:08:58 * QtPlatypus recalls a case where one of his coleages did that by accedent and produced very hard to debug bugs.
01:09:31 <dmwit> ew
01:09:32 <solrize> it's scarier if you use alloca :)
01:09:51 <dmwit> int main(int argc, char *@fat *@fat argv) { ... } // yuck
01:11:18 <pjd> "Cyclone: the safe language that with C’s level of control and efficiency."
01:11:19 <pjd> uh huh
01:11:36 <dmwit> Yeah, the cake is a lie.
01:11:50 <dmwit> You don't have to read far in the User Manual to discover that. =P
01:11:53 <solrize> you mean because the fat pointers are bigger ?
01:12:14 <dmwit> I mean because every dereference comes with a bounds check and a null-check.
01:12:15 <pjd> dmwit: i'm wondering about the missing verb, actually
01:12:42 <solrize> not EVERY dereference, only the ones that use fat pointers, there's other ones that are validated by the static type system
01:16:24 <sieni> hmm, cyclone looks cool
01:17:06 <solrize> so i'm writing haskell code with newtypes out the wazoo.  is that an antipattern/
01:17:07 <solrize> ?
01:20:25 <earthy> solrize: no, it isn't
01:20:38 <earthy> if it helps documenting e.g. argument positions
01:21:36 <solrize> i did it because of a remark in TAPL that says you have to use lots of  types in order to give the typechecker traction for finding probs in your code
01:21:37 <dmwit> newtypes are nice when you need a different instance of some standard class.
01:21:57 <solrize> i.e. I have newtype Red = Red Int  and such all over the place
01:21:59 <dmwit> That's the other really nice use for newtypes. =)
01:22:26 <dancor> great cabal-install doesn't even build
01:22:32 <solrize> if i just left everything up to type inference then i think it would only help spot where i mismatched two higher order combinators etc.
01:22:58 <dancor>     Module `Distribution.Version' does not export `Dependency(..)'
01:27:59 <dancor> and now i'm getting errors about having two versions of cabal
01:28:14 <dancor> i really appreciate all the glib advice about cabal-install which is clearly not ready
01:29:16 <dmwit> So bitter!
01:30:22 <Cale> dancor: Why do you have two versions of Cabal?
01:30:36 <Cale> dancor: I recommend just sticking with whichever one comes with GHC.
01:31:00 <Cale> dancor: When you get a new stable GHC, you'll get an updated Cabal then :)
01:33:19 <solrize> is Maybe a   implemented as a cons node?  or does Nothing turn into a runtime-checked null pointer or the like
01:34:33 <Cale> solrize: It's implemented similarly to a cons node, but not identically, as it has at most one parameter.
01:35:24 <solrize> right, so there's an extra box connected to the value... does ghc optimize it away in the places where it's obviously possible?
01:36:13 <Cale> Not generally. However, it does something called pointer tagging, which makes it obvious whether the value a pointer points to is Nothing or Just, after it's been followed once.
01:37:15 <Cale> (pointers always point to word-aligned values, so it's possible to store a bit of information in the low-order bits)
01:37:26 <solrize> yeah that's pretty normal
01:37:56 <solrize> and on the x86 you can subtract off the tag bit for "free" by dereferencing with LEA
01:39:49 <Cale> It'll do this with any datatype with up to 3 constructors on a 32 bit machine, or 7 constructors on a 64 bit one.
01:40:11 <solrize> hmm
01:40:18 <olsner> where 0 means not-yet-tagged?
01:40:22 <Cale> yeah
01:41:11 <opqdonut> how is the simultaneous-eval thing detected
01:41:33 <opqdonut> the one where ghc suspends a thread if it tries to eval something that is underway
01:43:26 <Cale> http://research.microsoft.com/~simonpj/papers/ptr-tag/index.htm
01:43:27 <lambdabot> Title: Faster laziness using dynamic pointer tagging
01:43:46 <olsner> @faq Can Haskell solve the halting problem?
01:43:47 <lambdabot> The answer is: Yes! Haskell can do that.
01:43:53 <olsner> :D
01:44:04 <Botje> didn't you know?
01:44:18 <Botje> GHC 11 will have that feature
01:44:35 <Cale> opqdonut: Well, I think if a pointer has a tag, then it doesn't need evaluation...
01:44:55 <Cale> opqdonut: So I'd hope that was an orthogonal issue...
01:45:44 <opqdonut> yeah, but i thought you might know :)
01:45:48 <Cale> hmm
01:46:13 <opqdonut> keeping thunks-in-evaluation in some structure sounds pretty bad for performance
01:46:22 <Cale> Oh, it doesn't do that.
01:46:43 <olsner> of course that's done by bit-fiddling too (I assume)
01:47:08 <olsner> btw, doesn't fiddling really mean "playing the violin"?
01:47:53 <opqdonut> olsner: i guess :)
01:48:03 <Cale> It replaces the pointer to the code for the expression with a pointer to a "grey hole" when it's first entered.
01:48:26 <opqdonut> yeah that sounds good
01:48:45 <opqdonut> since it will anyway have to replace the thunk with a value eventually
01:48:49 <Cale> http://research.microsoft.com/~tharris/papers/2005-haskell.pdf
01:48:56 <Cale> That has the details, I believe.
02:03:04 <solrize> http://lambda-the-ultimate.org/node/2552  :(
02:03:06 <lambdabot> Title: Quantifying the Performance of Garbage Collection vs. Explicit Memory Management ...
02:03:21 <solrize> @faq can haskell beat the unix sort utillity ?
02:03:21 <lambdabot> The answer is: Yes! Haskell can do that.
02:03:24 <solrize> heh
02:06:08 <solrize> skala ?
02:15:53 <skorpan> is there any predefined function which does f (x, y) (w, z) = (x + w, y + z)?
02:16:08 <olsner> :t (+) *** (+)
02:16:12 <lambdabot> forall a b'. (Num b', Num a) => (a, b') -> (a -> a, b' -> b')
02:16:25 <skorpan> what the?
02:16:51 <olsner> hmm, maybe not quite right
02:16:56 <skorpan> @hoogle (a, a) -> (a, a) -> (a, a)
02:16:56 <lambdabot> No matches, try a more general search
02:17:08 <skorpan> @hoogle (a, b) -> (a, b) -> (a, b)
02:17:08 <lambdabot> No matches, try a more general search
02:17:11 <olsner> @pl \(x, y) (w, z) -> (x + w, y + z)
02:17:12 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
02:17:21 <skorpan> :|
02:17:29 <olsner> @ty (***)
02:17:30 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
02:17:44 <skorpan> okay well thanks, but i'll stick to the simple version
02:18:08 <Botje> :t (pure (+)) *** (pure (+))
02:18:09 <lambdabot> forall a (a1 :: * -> * -> *) b a2 b'. (Arrow a1, Applicative (a1 b'), Num a2, Applicative (a1 b), Num a) => a1 (b, b') (a -> a -> a, a2 -> a2 -> a2)
02:18:23 <Botje> heh
02:18:25 <Botje> that's not it :)
02:19:15 <olsner> @hoogle a b c -> a d e -> a (b,c) (d,e)
02:19:16 <lambdabot> No matches, try a more general search
02:19:34 <olsner> @hoogle a b c -> a d e -> a (b,d) (c,e)
02:19:34 <lambdabot> No matches, try a more general search
02:20:23 <olsner> shouldn't (***) on the -> arrow be it?
02:20:33 <olsner> @ty (***) (+)
02:20:33 <lambdabot> forall a b' c'. (Num a) => (b' -> c') -> (a, b') -> (a -> a, c')
02:21:15 <larssg> Hi! I'm new to Haskell and functional languages - does anyone have a book recommendation?
02:21:27 <solrize> errr
02:21:29 <solrize> hmm
02:21:48 <skorpan> larssg: i'd say http://en.wikibooks.org/wiki/Haskell/YAHT
02:21:48 <lambdabot> Title: Haskell/YAHT - Wikibooks, collection of open-content textbooks
02:21:49 <solrize> did you look at haskell.org ?
02:21:55 <skorpan> "yet another haskell tutorial"
02:21:59 <larssg> Yes, I looked at haskell.org
02:22:22 <larssg> but it just lists a bunch of books and I've no idea which would make sense to read as a beginner
02:22:27 <solrize> i haven't seen any books i like, but 'haskell school of expression' is probably the gentlest start
02:22:49 <solrize> actually how about SICP (which is not about haskell) if you want to begin at the beginning
02:23:02 <solrize> http://mitpress.mit.edu/sicp/
02:23:02 <lambdabot> Title: Welcome to the SICP Web Site
02:23:30 <larssg> I'll have a look - I've never heard of that
02:24:23 <larssg> thanks
02:24:23 <skorpan> larssg: check my link out
02:24:31 <skorpan> i think YAHT is really awesome and a good start
02:24:34 <larssg> I did
02:24:35 <larssg> okay
02:24:38 <skorpan> okay good :)
02:24:42 <larssg> :-)
02:24:42 <skorpan> i thought you missed it
02:25:00 <larssg> It's Scheme-like?
02:25:07 <skorpan> sorry, i don't know scheme
02:25:15 <larssg> okay, fair enough :-)
02:25:21 <larssg> but thanks for the links
02:26:04 <haraldk> Yaht worked OK for me
02:26:43 <larssg> okay, sounds good - I was just wondering whether it would make sense to buy a book (it's paid for by the company...)
02:26:47 <skorpan> yaht is one of those "books" which are to-the-point without missing too much details
02:26:57 <larssg> but I'll have a look at YAHT first
02:26:59 <larssg> cool
02:27:21 <haraldk> larssg: May I ask what company? :-)
02:27:29 <larssg> haha
02:28:46 <therp> larssg: SICP is really nice :) -- although it's not about functional programming in the sense that Haskell is FP. it's still a good way to spent your time
02:29:54 <haraldk> It's fun, I'm starting to see FP work
02:30:20 <ski> http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/
02:30:21 <lambdabot> Title: Structure and Interpretation of Computer Programs, Video Lectures, http://tinyurl.com/2by7b
02:30:50 <larssg> I'll have a look at SICP too. FP sounds great but so far I've only heard of it in podcasts and seen a couple of Google Videos about it
02:30:53 <haraldk> First there is this O'caml program I'm supposed to document since the one guy who knew O'caml here quit
02:31:09 <haraldk> Ok, so that may not be such a good sign...
02:32:07 <solrize> there's some reasonable ml books on line
02:32:16 <haraldk> but then there's this company I'm doing a consultancy job for, I mentioned knew some Haskell, "Oh yeah, we have some haskell programs lying around"
02:32:56 <solrize> haskell has a steep learning curve compared with most other languages
02:33:05 <larssg> ah, okay
02:33:39 <solrize> and there -really- aren't any good books about it
02:33:48 <skorpan> but i think that's mostly because it's so different, being the pure fp language that it is
02:33:58 <solrize> it's not just that
02:34:20 <solrize> it has a more powerful type system than most programmers are used to, and many language idioms revolve around that
02:34:27 <larssg> SICP is easier to understand coming from C# and Ruby?
02:34:28 <larssg> okay
02:34:47 <solrize> sicp should be simple if you know ruby
02:34:52 <solrize> ruby is scheme with barfed-up syntax
02:35:03 <solrize> well that's nto really right
02:35:08 <solrize> ruby is smalltalk with barfed-up syntax ?
02:35:26 <larssg> I've heard people say that before
02:35:28 <solrize> anyway scheme (which sicp uses) will seem very natural if you've done some ruby
02:35:30 <dolio> Something like that.
02:35:32 <larssg> - so that may be true
02:35:37 <larssg> okay
02:35:40 <solrize> c# = java = vogon poetry
02:35:43 <larssg> haha
02:35:44 <larssg> true
02:35:48 <dolio> It certainly gets a lot of names from Smalltalk.
02:35:51 <skorpan> C# = java indeed
02:38:00 <quicksilver> solrize: have you read Hutton? or Hudak?
02:38:21 <solrize> i looked at hutton's book in the store.  i have hudak's book
02:38:30 <solrize> haskell school of expression
02:38:41 <dolio> Wow, you found a store that has Haskell books?
02:38:53 <quicksilver> Because lots of people like HUtton's book, although I haven't seen it myself.
02:38:55 <solrize> it's a good introduction but after reading it i still felt like a complete beginner
02:39:17 <solrize> and it's not really possible to make gradual progress in the early stages of learning haskell
02:39:38 <solrize> there's some hurdles to overcome before you can do anything nontrivial
02:39:52 <solrize> so there's a big lurch at the beginning
02:40:14 <solrize> and even after that, to really know what you're doing it seems to me that you have to read a lot of academic research papers
02:40:22 <solrize> the necessary stuff is simply not published anywhere else
02:40:35 <quicksilver> well, you say that like it's a bad thing :P
02:40:39 <quicksilver> reading papers is fun.
02:40:47 <quicksilver> but, I'm not sure you "have to"
02:40:50 <quicksilver> to understand STM, sure.
02:40:52 <solrize> sure it's fun but you have to piece together the info from a zillion separate places
02:40:57 <quicksilver> but to just write programs, I don't think so.
02:41:10 <solrize> STM, SYB, TH, ...
02:41:20 <solrize> gadt's
02:41:26 <quicksilver> none of which are particularly important
02:41:32 <quicksilver> or necessary for writing "ordinary" programs.
02:41:41 <solrize> well, happs uses all that stuff
02:41:49 <quicksilver> ah, well, happs is something else.
02:42:00 <solrize> well, it's a major haskell application
02:42:18 <solrize> so if it's it's incomprehensible without understanding those features
02:42:27 <solrize> i'd say they're important
02:42:44 <quicksilver> yes, but it's a particularly complex, hard to compile, and experimental program
02:42:54 <quicksilver> (not to mention poorly documented)
02:43:24 <quicksilver> most haskell developers do not udnerstand happs :)
02:43:29 <solrize> well yes, but it performs a ubiquitous and imprtant task, so if it takes a lot of complexity and compilation difficulty to do what it does, that says something about haskell
02:43:31 <quicksilver> and yet they manage to do useful work.
02:43:41 <quicksilver> happs took the hard path.
02:43:48 <solrize> well if useful is measured by serving web pages ...
02:43:49 <quicksilver> at every single choice, happs took the hardest, most obscure pathway
02:44:07 <quicksilver> there are other ways to serve webpages which don't rely on poorly documented haskell extensions :)
02:44:35 <solrize> i think at every single choice, happs faced the problem squarely and refused to compromise
02:44:40 <quicksilver> happs is a fabulous thing, but it's not a "simple web framework"
02:44:55 <solrize> well no, not "simple" :)
02:45:51 <solrize> the thing is, other languages like python have obscure features, that i don't understand and don't use, but i have reasonable confidence that if i had to understand python metaclasses i could spend an evening with the docs figuring them out
02:46:14 <solrize> with haskell it's more like studying a new branch of mathematics
02:46:18 <solrize> for each of those things
02:47:24 <haskell> Hi, how can I change state e. g. an user input should be appended to an existing list
02:47:47 <solrize> er usually you wouldn't do that
02:48:46 <solrize> anyway i'm not sure what to make of happs really.  it was one of my main motivators for being interested in haskell
02:49:04 <solrize> but i'm still nowhere near capable of understanding it
02:49:21 <ski> haskell : if you only use simple interaction, then `interact' or `getContents' may be useful
02:49:33 <ski> haskell : it's hard to tell if you don't provide more context
02:49:53 <ski> what problem are you trying to solve ?
02:50:05 <haskell> suppose I have a menu: 1. add a line 2. write inputed lines so far 3. quit
02:50:32 <haskell> thats basically the problem
02:50:35 <ski> ok
02:51:02 <ski> sounds like you can keep the state in a parameter of your loop function .. possibly hidden behind a state monad
02:51:25 <ski> possibly you want to try the first case first, to understand it
02:51:27 <solrize> the simplest way would be just pass the lsit of lines seen as a parameter to the loop func
02:51:29 <solrize> list
02:52:21 <ski> haskell : do you understand basic `do'-notation for `IO'-actions ?
02:52:30 <ski> do putStrLn "Enter a line"
02:52:36 <ski>   l <- getLine
02:52:42 <haskell> yes the thing with the loop parmet will do I guess thanks
02:52:49 <ski>    putStrLn ("Here's the line : " ++ l)
02:53:04 <haskell> I'll try this out.  I know basic io thanks
02:53:23 <ski> haskell : a passing note, probably it is simplest to store the list of lines in reverse order
02:53:30 <quicksilver> yes, recursion is the simplest way to store state
02:53:39 <quicksilver> (hide the state in a parameter)
02:56:01 <haskell> How would I store in reverse order something like: lines ++ [newLine]
02:56:52 <ski> haskell : that's not reverse order, that's the normal order
02:56:58 <byorgey> haskell: I think ski meant  newLine : lines
02:57:08 <ski> reverse order would be like `newLine : reverseOrderLines'
02:57:14 <byorgey> then when you want to write them out, reverse them first
02:57:43 <quicksilver> although I would get it working before worrying about such things
02:57:52 <quicksilver> this is only for efficiency anyway?
02:58:04 <quicksilver> and I doubt the user will enter so many lines teh append time becomes a problem.
02:58:23 <haskell> :-) since I learnd : first newLine : lines is for me the normal order and yes I reverse them before I write them out
02:58:57 <solrize> newline : lines
02:59:54 <haskell> @quicksilver yes I going to get it working right now therfore I'm off thanks to everyone
02:59:54 <lambdabot> Unknown command, try @list
03:04:04 <skorpan> could someone here come up with a smooth way of checking whether any player in a game of standard chess is checkmate?
03:04:13 <skorpan> smooth, meaning fast and understandable!
03:04:29 <solrize> in haskell you mean?  i don't think speed is on the table, compared with how chess progs are usually written
03:04:52 <skorpan> okay, so then smooth = not slower than usual haskell code and understandable!
03:05:01 <solrize> http://en.wikipedia.org/wiki/Bitboard
03:05:02 <lambdabot> Title: Bitboard - Wikipedia, the free encyclopedia
03:05:17 <skorpan> ouch
03:06:06 <solrize> http://en.wikipedia.org/wiki/Board_representation_%28chess%29
03:06:06 <Botje> skorpan: 1) try to move the king, see if that is possible
03:06:14 <skorpan> Botje: ah! of course1
03:06:15 <skorpan> thanks!
03:06:20 <Botje> 2) if not, try to move a piece in front of the king
03:06:33 <Botje> 3) try to capture pieces that threaten the king
03:06:36 <Botje> 4) if all else fails, checkmate
03:06:47 <skorpan> cool, thanks again
03:07:01 <solrize> checkmate = 1) player on move is in check; and, 2) player has no legal moves (i.e. no way out of check)
03:07:11 <solrize> your prog has to have a legal move generator
03:07:19 <solrize> so if it finds no moves but king is not in check, stalemate
03:07:27 <solrize> if king is in check and no legal moves, checkmate
03:07:33 <skorpan> true
03:07:42 <skorpan> darn you, stalemate!
03:11:08 <dmwit> Chess is not an elegant game.
03:12:54 <skorpan> i just realized that i must put another checker in my move generator, making sure the new positions generated don't put the player's king in check
03:13:29 <opqdonut> dmwit: exactly
03:29:32 <dmwit> Actually, I thought I'd get a bit more outrage from that comment.
03:31:13 <quicksilver> solrize: I would think first step is to work out which squares on the board are "attacked" by white (resp. black)
03:31:24 <solrize> yes
03:31:33 <quicksilver> solrize: then see if king is attacked. Then see if king can move to unattacked square.
03:31:37 <quicksilver> and then what botje said
03:31:38 <quicksilver> :)
03:31:46 <skorpan> that's the main issue really
03:31:53 <skorpan> checking whether the king is attacked
03:33:10 <Botje> work it out piece by piece
03:33:23 <skorpan> i feel like a naive search is my only option here
03:34:35 <quicksilver> Map ChessSquare [Pieces]
03:34:49 <quicksilver> a map from squares to the list of pieces which can attack them
03:35:08 <quicksilver> built by using fromListWith (++)
03:35:10 <quicksilver> probably
03:35:42 <skorpan> yes, but that list of pieces which can attack them would have to be generated in some way
03:35:48 <skorpan> which probably would also be naive
03:37:35 <quicksilver> well it's a map over pieces
03:37:50 <Botje> what's so naive about it? it's Good Enough(tm)
03:38:05 <quicksilver> map (\p -> [(attackable p,p)]) pieces
03:38:07 <quicksilver> or something
03:39:21 <skorpan> Botje: i have nothing against naive searches, i'm just saying.
03:39:39 <skorpan> i'm writing a little function for finding the kings in the game now
03:40:01 <skorpan> and then for each piece, i'll check if it is a valid move to move TO the opposing king FROM its current position
03:40:06 <skorpan> that's for checking for check
03:40:57 <skorpan> i wonder if this will be so slow that the user will notice
03:43:27 <quicksilver> skorpan: that sounds un-necessarily special purpose.
03:43:39 <quicksilver> skorpan: I would generate the complete "attackability" map per my suggestion.
03:43:45 <quicksilver> and then just look at the king's square.
03:44:04 <Botje> skorpan: that's at most, what, 400 squares to inspect?
03:44:18 <skorpan> Botje: i'm not sure, i'm not good with math
03:44:44 <Botje> you shouldn't worry about performance for anything less than 1M nodes
03:44:52 <Botje> make it work first
03:45:00 <skorpan> yeah, that's what i was thinking too
03:45:05 <Botje> if that's not fast enough, at least you know the problem in detail and come up with decent solutions :)
03:45:24 <skorpan> :)
03:45:38 <Botje> that's how I tackle project euler problems, mostly
03:46:10 <skorpan> i miss project euler now actually
03:46:20 <skorpan> 500 lines of code for chess?! i mean come on!
03:46:31 <skorpan> i must have made some really lame design choices
03:46:48 <Botje> heh
03:46:57 <Botje> I've written a webserver in 200 lines :)
03:47:01 <pjd> skorpan: choosing chess? :)
03:47:11 <skorpan> i wrote an http server in 100 lines of erlang (don't beat me!)
03:47:21 <skorpan> pjd: yeah, i guess :/
03:47:53 <quicksilver> skorpan: I'm not that surprised. Chess is moderately complicate. Even describing the legal moves takes a few lines.
03:48:04 <quicksilver> maybe 'complicated' isn't the right word.
03:48:07 <quicksilver> but it's detailed.
03:48:12 <quicksilver> there are lots of "facts" you need to encode.
03:48:17 <skorpan> quicksilver: the legal movement had to be completely rewritten due to bad design choices
03:48:22 <quicksilver> ;)
03:48:28 <skorpan> and i haven't even started working on the pawn movement
03:48:37 <skorpan> i'm not sure how i should keep track of en passant moves
03:48:45 <skorpan> i don't even want to think about castling
03:48:58 <quicksilver> pawns are stateful.
03:48:59 <haraldk> There's a "serious" chess program, Micro-max, that is only about 100 lines
03:48:59 <Baughn> See, this is why you should be attacking Go instead. ;)
03:49:00 <haraldk> of C
03:49:06 <skorpan> Baughn: right! :)
03:49:14 <quicksilver> pawns, kings and rooks are stateful, IIRC.
03:49:16 <skorpan> haraldk: impossible!
03:49:23 <skorpan> quicksilver: what do you mean when you say stateful?
03:49:32 <haraldk> No, you can look at the source code
03:49:35 <quicksilver> I mean, they have more than one state.
03:49:42 <Baughn> haraldk: How /long/ are the lines?
03:49:43 <quicksilver> one rook is not like another rook
03:49:44 <skorpan> haraldk: no i mean, impossible since i wouldn't be able to do it!
03:49:50 <quicksilver> if it's moved before, it can't be part of a castling move
03:49:55 <quicksilver> if I remember my chess correctly
03:49:57 <skorpan> quicksilver: oh, yeah, that's true
03:49:59 <haraldk> It's about 1400 characters, he says
03:50:05 <quicksilver> pawns / en passant is a similar issue
03:50:11 <skorpan> haraldk: so 14 characters per line?
03:50:14 <solrize> http://home.hccnet.nl/h.g.muller/max-src2.html
03:50:15 <lambdabot> Title: Micro-Max
03:50:16 <Botje> you can cheat with pawns
03:50:22 <Baughn> haraldk: IOCCC-type code?
03:50:31 <haraldk> implements most of the state-of-the-art methods, too
03:50:42 <haraldk> Baughn: Not quite
03:50:44 <skorpan> "Even when I dropped the nitty gritty details of the FIDE rules, like castling and en-passant capture, I could not get the size much below 1200 characters. "
03:50:50 <skorpan> that explains it
03:51:06 <Baughn> haraldk: Oh yes. Quite.
03:51:16 <skorpan> how is en passant pronounced anyways? "awn passawn"? i don't want to make fool of myself in front of my belgian teacher
03:51:37 <Botje> skorpan: that's a fair representation, yes
03:51:39 <Baughn> skorpan: I always pronounced it "an passan"
03:51:55 <haraldk> Baughn: He had super-short variable names, and some #define usage, but it was far from IOCCC
03:51:58 <Baughn> skorpan: ...that's probably norwegian, though. Eh..
03:52:01 <skorpan> :)
03:52:05 <quicksilver> the 'n's are lighter than english ns
03:52:18 <quicksilver> not quite as definite as the sound at the end of 'pin', say.
03:52:19 <skorpan> quicksilver: yeah, i think we're thinking the same thing
03:52:32 <Botje> the sound of the first word is closer to "o" than "aw" though
03:52:37 * wagle_home waits for chess in one line of haskell
03:52:39 <Baughn> haraldk: This looks almost exactly like typical IOCCC code
03:52:42 <quicksilver> and so is the last syllable
03:52:47 <quicksilver> on pas on
03:52:51 <skorpan> yeah okay
03:52:52 <quicksilver> is pretty close
03:52:55 <Baughn> haraldk: It may be that IOCCC programs are more obfuscated. I can't say. They're all equally unreadable to me
03:52:59 <skorpan> so i should probably start thinking about my code now :)
03:53:40 <solrize> http://fabrice.bellard.free.fr/otcc/
03:53:41 <lambdabot> Title: OTCC : Obfuscated Tiny C Compiler
03:53:51 <solrize> My goal was to write the smallest C compiler which is able to compile itself. I choose a subset of C which was general enough to write a small C compiler. Then I extended the C subset until I reached the maximum size authorized by the contest: 2048 bytes of C source excluding the ';', '{', '}' and space characters.
03:53:54 <haraldk> It's not entirely unreadable if you know what is happening - at least not the one with expanded variable names
03:54:34 <haraldk> I'm not saying it's readable, but IOCCC is worse - much worse.
04:19:03 <skorpan> when the pawn reaches the other end of the board, is there any reason at all for the player *not* to choose it to be a queen?
04:19:18 <solrize> yes
04:19:24 <solrize> the usual reason is stalemate
04:19:35 <Botje> sometimes you can force a win with another piece :)
04:19:56 <solrize> you could imagine a position though where promoting to a knight allows a quick mate that a queen can't deliver
04:20:18 <solrize> google "saavedra position" and then for real yuks, try "babson task"
04:20:31 <QtPlatypus> Now thats a sentence that can be taken out of context.
04:21:05 <QtPlatypus>  "A knigh allows a quick mate that a queen can't deliver"
04:21:05 <quicksilver> skorpan: showing off? :P
04:21:32 <solrize> http://en.wikipedia.org/wiki/Saavedra_position
04:21:36 <solrize> qtplatypus heh
04:24:24 <solrize> when Dutch author Tim Krabbé saw this version in the Soviet publication ´64´, he records that the realisation that somebody had at last solved the Babson Task had the effect upon him as if he had " ... opened a newspaper and seen the headline ´Purpose Of Life Discovered´.
04:27:26 <smg> hello.
04:27:34 <smg> is there an interpreter etc for lambda-calculus?
04:27:53 <SamB> what would it do?
04:28:15 <SamB> find a normal form?
04:28:24 <pjd> smg: besides Haskell, say?
04:28:35 <SamB> Haskell is typed, remember
04:28:46 <SamB> the untyped lambda calculus is not
04:29:06 <idnar> unlambda or something?
04:29:17 <SamB> that is not lambda calculus!
04:29:21 <SamB> look at the name!
04:29:27 <idnar> heh
04:29:42 <SamB> that's a messed up SKI calculus
04:29:52 <smg> i just wanted to have some fun with pure lambda calculus hehe
04:30:07 <SamB> I think most people use pencil and paper or something?
04:30:41 <smg> yeah exactly :)
04:30:41 <SamB> you could write an interpreter easily in Haskell, if you could figure out what you wanted it to do
04:30:50 <smg> hehe okay
04:31:31 <solrize> hey samB is jhc really intended to run without a garbage collector?  just region inference?
04:31:34 <smg> i will stick to paper, somehow nostalgic but okay hehe
04:31:55 <SamB> solrize: well, John said that he had meant to write a GC the other weekend...
04:32:03 <SamB> but accidentally wrote a scheme interpreter instead
04:32:35 <solrize> i don't see how it can handle functional data structures without a gc, i mean lots of computations are basically unfolds over data.map
04:32:52 <SamB> so I suppose it will have an RTS once he actually writes that GC
04:33:04 * ski wrote an LC-interpreter to answer excercises about reduction steps of boring expressions
04:33:28 <scook0> aren't there LC interpreters associated with TaPL?
04:33:38 <ski> (it took less time than to compute the answers by hand !)
04:34:31 <smg> btw you know coq? really handy :]
04:34:39 <SamB> smg: you could, for instance, write an interpreter that passes a church-encodes stdin to the lambda, and church-decodes the return value to write to stdout...
04:34:58 <SamB> s/encodes/encoded/
04:35:32 <smg> SamB: good idea, ty
04:35:59 <scook0> http://www.cis.upenn.edu/~bcpierce/tapl/checkers/
04:36:00 <lambdabot> Title: Directory Index
04:36:19 <solrize> what's the difference between structural and nominal typing?
04:36:49 <smg> ~1 hour then ghc 6.8.2 will be done :)
04:37:00 <pjd> solrize: the former considers things with different structure different, the latter things with different names different
04:37:16 <pjd> (as a first approximation)
04:41:26 <solrize> thanks
04:54:44 <smg> btw where can i look how Int and so on are implemented in haskell?
04:54:48 <smg> is that in Prelude.hs?
04:55:23 <pjd> @src Int
04:55:23 <lambdabot> data Int = I# Int#
04:55:32 <ski> @src Int#
04:55:32 <lambdabot> Source not found. Are you on drugs?
04:56:06 <ndm> data Int# = S# !Int# | Z#
04:56:13 <ndm> that would be one possible implementation
04:56:21 <opqdonut> heh
04:56:22 <smg> no. :)
04:56:29 <smg> i want to see more, is haskell implemented in C?
04:56:44 <ndm> smg: Int# is a machine register, as in C style
04:56:46 <ski> smg : haskell is a language. it has several implementations
04:56:47 <pjd> smg: Haskell is implemented in various ways
04:57:07 <scook0> the GHC compiler is written in Haskell, though the runtime-system is (iirc) in C
04:57:13 <pjd> foo# and such are GHC things, i think
04:57:44 <smg> mh
04:57:51 <smg> ok
05:00:59 <quicksilver> the RTS is written in a mixture of C, C minus minus
05:01:04 <quicksilver> and, arguably, haskell
05:01:11 <quicksilver> although it depends where you draw the line I suppose.
05:01:44 <quicksilver> (the GHC RTS, I mean)
05:04:38 <SamB> I think it's reasonable to say that it includes Haskell code
05:05:15 <SamB> didn't they move a lot of the IO management into Haskell code?
05:05:37 <quicksilver> yes
05:05:46 <quicksilver> although it's sort-of-not haskell
05:05:55 <quicksilver> it's haskell with some unsound primitives added :)
05:06:12 <quicksilver> State# and so on.
05:06:19 <quicksilver> but syntactically it's haskell
05:06:56 <amitprakash> hi.. i was looking into the soc project ideas for haskell.. as far as the parser for multiple languages is concerened, i didnt quite understand it
05:07:04 <amitprakash> can someone please explain it?
05:08:09 <amitprakash> so what exactly does the language library do?
05:10:26 <malcolmw> any one parser would be for a single language. but there are multiple languages to choose from :-)
05:10:55 <amitprakash> malcolmw, so language library creates a parse tree for a given language?
05:11:39 <malcolmw> amitprakash: yes.  There is already a Language.C parser as part of the c2hs project
05:11:52 <amitprakash> ah ok
05:13:01 <malcolmw> and there are at least two Language.Haskell packages with parsers capable of dealing with different language extensions
05:20:30 <amitprakash> malcolmw, where can i read more on the language class?
05:25:57 <malcolmw> amitprakash: that is not a well-formed question.  Haskell does not have a "language class".  Maybe you need to look up "parser combinators", or Happy (a parser generator tool).
05:39:01 <hallongrottan> sup
06:04:34 <dcoutts> @seen mnislaih
06:04:34 <lambdabot> I saw mnislaih leaving #haskell and #ghc 12h 52m 13s ago, and .
06:21:23 <Arindama> hi
06:21:31 <Lemmih> Hiya.
06:21:58 <Arindama> i dont know which room to chat in
06:22:03 <Arindama> so randomly picked one
06:22:04 <Arindama> :)
06:22:13 <Arindama> how are you lemmih?
06:22:31 <Lemmih> Just fine, thank you.
06:22:38 <Arindama> nice
06:22:56 <Arindama> so, whazzup?
06:23:38 <Feuerbach> Arindama: do you know Haskell Curry?
06:24:00 <Feuerbach> he's who we actually chat about here
06:24:21 <Arindama> :-(
06:24:37 <Arindama> ignorance is bliss, and i am ecstatic
06:24:54 <Feuerbach> Arindama: you can learn more about him at wikipedia
06:25:01 <Arindama> i dont know if there are general chat rooms
06:25:09 <Arindama> searched for them, couldnt find one
06:25:12 <Arindama> noob here
06:25:20 <Feuerbach> Arindama: sorry, I can't help you
06:25:24 <Arindama> thats okay
06:25:25 <Arindama> :-)
06:25:32 <Arindama> let me read abt Haskell
06:26:12 <Arindama> whoaaa
06:26:40 <Arindama> ok
06:26:42 <Arindama> am leavin
06:26:47 <Arindama> c ya folks
06:26:51 <Feuerbach> bye
06:27:03 <nornagon> haha
06:39:05 <opqdonut> suggestions for finding shortest paths in a weighted graph
06:39:24 <opqdonut> dijkstra turns pretty ugly if one tries to use some efficient data structure
06:39:39 <cjb> A*?
06:39:51 <ohub> opqdonut; can you share the code? :)
06:40:03 <opqdonut> cjb: implementable idiomatically and succintly in haskell? doubt it...
06:40:17 <opqdonut> ohub: well yes for a naive list-based dijkstra
06:40:45 <ohub> I just learned the algorithm in a course, so seeing it implemented would be fun :)
06:41:11 <cjb> opqdonut: http://web.engr.oregonstate.edu/~erwig/fgl/haskell/
06:41:11 <lambdabot> Title: Functional Graph Library/Haskell
06:44:16 <opqdonut> cjb: thanks for the pointer
07:07:36 <EvilTerran> isn't dijkstra a specific case of A* anyway?
07:09:11 <opqdonut> yeah
07:10:37 <byorgey> yes, if the evaluation function always gives 0 for any node, you get Dijkstra.
07:11:16 <Peaker_> is there a ready implementation of Dijkstra, with the right kind of heap (that supports decrease in-place) in Haskell?
07:19:34 <Peaker_> say, how long does it take a typical programmer to "get into" Haskell and be comfortable with creating new Monads, using the language proficiently, etc?  I've been spending hours every day for almost a week now, and I'm still not completely comfortable with Monads/etc (Though am increasingly so :-)
07:19:53 <earthy> peaker: a week is peanuts. :)
07:20:11 <glen_quagmire> Peaker_: you need to get ph.d and recognized
07:20:23 <earthy> glenquagmire: that's a bit steep
07:20:25 <Peaker_> hah :-)
07:20:30 <Peaker_> PhD's are overrated :)
07:20:32 <Spark> anyone can get a phd
07:20:38 <earthy> peaker: it really depends on how flexible your mind is
07:20:48 <Spark> you need an erdos number of 2 or less
07:20:54 <kpreid> Peaker_: after you have stopped thinking of monads as a profound mystery, you will be well on your way
07:21:05 <yitz> Peaker: you don't need to create new monads to "get into" Haskell. It's fun, though.
07:21:35 <byorgey> Peaker_: it took me several months to reach the point of feeling that comfortable, and even then I was still learning tons of new stuff all the time.
07:22:02 <Peaker_> kpreid, well, for a long time everything I read about them was abstract in-the-air talk about algebras, category-theory, etc.  once I found groundly descriptions of monads describing the monad class, and the semantics of >>= and return, I understood their mechanics - and I am slowly understanding more of their applications
07:22:12 <glen_quagmire> i find haskell tough to learn. but for you professional programmers, do you have 1 mental mind that can apply to various programs?
07:22:24 <Spark> monads are a good reason to be pretentious
07:22:48 <Peaker_> I try to explain everything I learn about Haskell to some of my friends, which aids a lot in my understanding :)
07:23:25 <byorgey> Peaker_: teaching is always a good way to understand things better =)
07:23:29 <b_jonas> Peaker_: yeah, that can help
07:23:29 <glen_quagmire> for example, it's possible to figure things out on my own in imperative languages.  for haskell though, i need to study and learn new things
07:23:48 <b_jonas> luckily in programming languages there's the alternative method of writing programs
07:24:28 <Peaker_> b_jonas, in Haskell, I feel I have too much freedom in the way I put my program as a beginner, which makes it harder, not easier.. I don't know whether I need recursion to formulate my mainloop, a whileM, or a different thing altogether
07:24:32 <yitz> Peaker: I'm always learning more. But I was able to get to the point where I could write better programs than in any other language, and quicker, after a week or two. (that was long before I grokked monads)
07:25:08 <Peaker_> yitz, I doubt that will happen very soon, as I've spent many years doing C/Python intensively...
07:25:21 <yitz> Peaker_: so had I
07:26:05 <smg> ah cool
07:26:17 <smg> ghc 6.8.2 has trace,step and breakpoints :]
07:26:18 <yitz> Peaker_: Python took me less time to get to that point (after years of many languages). but haskell still beats it.
07:27:25 <glen_quagmire> python is very nice. if ghci has docstrings stuff, it'd beat python
07:27:26 <Peaker_> Does the Haskell community care about Haskell becoming mainstream?
07:27:47 <Peaker_> glen_quagmire, it could be nice if ghci were to accept everything that a normal ghc program does, even types
07:27:56 <yitz> Peaker_: absolutely. it's just that some are for, and some are against. :)
07:28:07 <idnar> Peaker_: I don't think you're the first person to raise an objection like that
07:28:25 <idnar> Peaker_: but to be clear, we're talking about a documentation issue, right?
07:28:32 <glen_quagmire> Peaker_: no. haskell will be research language. it's like a table for experimental stuff. it'll influence other languages though. very much.
07:28:54 <Peaker_> yitz, because there seem to be pretty trivial issues (like Ubuntu integration) that could be addressed - and help a lot in its becoming mainstream.
07:29:14 <glen_quagmire> when haskell becomes mainstream, researchers will invent another language and move onto that
07:29:18 <idnar> glen_quagmire: is there any reason why it has to stay a "research" language?
07:29:33 <yitz> Peaker_: if someone wants to take on ubuntu integration, it could happen.
07:29:35 <Peaker_> idnar, the main barrier of entry for me -- was poor Ubuntu integration
07:29:53 <glen_quagmire> i think i'm a troll. sorry.
07:29:56 <idnar> Peaker_: I'm not sure what you mean by "integration"; does Ubuntu not have ghc packages?
07:29:57 <Peaker_> idnar, then, after that, I think the syntax of Haskell has very innovative and cool ideas - but overall, that it kinda sucks :)
07:30:10 <Peaker_> idnar, not ones that work with the vast majority of Haskell code out there
07:30:19 <yitz> Peaker_: i've been using it on debian, windows, and mac os. not perfect on any of them, but i've been happy.
07:30:24 <Peaker_> idnar, Nor does it have packages for various libs, or cabal-install to fetch them
07:30:29 <idnar> Peaker_: I guess you need to convince some Ubuntu Developers to take an interest, then :P
07:30:38 <idnar> although the Debian Haskell situation could also use some work
07:30:59 <Peaker_> Unlike C - in Haskell, one can create alternate Haskell syntax'es by creating from/to conversion scripts
07:31:04 <idnar> (it's one of the things I'm hoping to focus some time on, but probably only after I become a DD)
07:31:13 <Peaker_> idnar, DD?
07:31:17 <idnar> Peaker_: Debian Developer
07:31:30 <Peaker_> idnar, oh. I do support Ubuntu just uses the Debian work as-is
07:31:39 <Peaker_> s/support/suppose
07:31:56 <idnar> Peaker_: right, but things only get imported from Debian at certain points in the release cycle
07:32:16 <idnar> so I think a little manual handholding from MotUs or whatever is required to smooth things over from time to time
07:32:23 <idnar> (get imported automatically, I mean)
07:32:31 <idnar>  personally, I'm quite fond of Haskell's syntax
07:32:52 <glen_quagmire> what matters is not haskell being mainstream or not. if it works for you, it works for you.
07:32:57 <idnar> it's not exactly perfect, but it's a lot simpler than most languages I've used
07:33:05 <Peaker_> glen_quagmire, I want to improve the world :-)
07:33:16 <Peaker_> idnar, I think Python's main plus is its syntax..
07:33:29 <idnar> Peaker_: I like Python's syntax, but it feels horribly complex by comparison
07:33:39 <glen_quagmire> that's one fallacy of humans. we want to put other people according to our set frame
07:33:40 <vegai> glen_quagmire: I could more probably use it at work if it was mainstream
07:33:41 <idnar> Peaker_: I think that's an unavoidable side-effect of a "simple" syntax
07:33:49 <yitz> Peaker_:, idnar: the syntax is very different than all those C-like things, which is good. and it is designed to interact nicely with types, which is great. i think there is still room for improvement, but i'm not sure how. the agda people are working on that, i think.
07:33:51 <Peaker_> idnar, Really? I find it much simpler..
07:33:54 <idnar> you end up with lots and lots of special cases, instead of a few general concepts
07:34:38 <Philippa> they have different forms of simplicity
07:34:39 <idnar> for example, every statement in Python has its own syntax to learn, and there are like a dozen of them
07:34:44 <glen_quagmire> it's difficult to please the mass. if haskell compromises to be mainstream, many supporters might leave
07:34:46 <Peaker_> yitz, My first Haskell project (if its not over my Haskell head :) - will be a Haskell editor that edits Haskell programs directly, without syntax
07:34:54 <Peaker_> yitz, as in, syntax is a presentational-thing on screen
07:34:56 <idnar> so it might be easier to understand small amounts of python syntax
07:35:05 <idnar> but to master it, you need to keep a lot more in your head at a time
07:35:38 <idnar> I've only really been using Haskell for a few months now, and I'd already say that I'm more familiar with Haskell syntax than I am with Python syntax (despite writing intermediate-to-advanced level Python code for nearly 5 years now)
07:35:59 <yitz> idnar: the idea is that you already know C. stuff that goes beyond that is pretty regular.
07:36:09 <Peaker_> idnar, Well, Haskell's syntax has let, where, do, <-, ->, assignments, (the type world, but unfair to compare that to Python), pattern matching stuff, case, if, the infix/prefix stuff
07:36:15 <Peaker_> idnar, I think that's bigger than Python's set
07:36:36 <idnar> Peaker_: half of the things you just mentioned overlap, though
07:37:30 <Peaker_> idnar, I am having a hard time with names that are defined after expressions with "where" clauses, too
07:37:38 <idnar> or, they do for me; I guess not everyone may have the same conceptualization that I do
07:38:14 <idnar> anyhow, I'm not necessarily saying that one approach is better than the other
07:38:21 <yitz> certain things are declared "sugar" and intentionally deviate from the regular rules - such as list and tuple, list comprehensions, do notation. other stuff is regualr.
07:38:29 <Peaker_> also I think Haskell syntax has too many equivalencies: a b = c  and a = \b -> c,   where/let can be equivalent (If I understood correctly), do-sugar, comprehensions, pattern-vs-case, ...
07:38:58 <skorpan> "too many" equivalencies?
07:39:02 <yitz> Peaker_: Haskell was influenced by Perl (many ways to do it), not Python (one way to do it)
07:39:04 <Peaker_> I like the Python motto: There is preferrably one obvious way to do it
07:39:08 <idnar> Peaker_: the thing is, breaking those equivalencies raises the conceptual complexity, because you're artificially limiting arbitrary concepts
07:39:16 <glen_quagmire> i don't think syntax is barely a thing that keeps haskell from being mainstream
07:39:27 <idnar> I don't think creating an obvious way to do things by arbitrarily outlawing all of the alternatives is a good idea
07:39:29 <glen_quagmire> that sentence is wrong
07:39:30 <Peaker_> yitz, Having many ways to express the same thing does not make writing much easier but makes reading harder
07:39:45 <skorpan> i seriously think that the purity of haskell is what keeps it from being mainstream
07:39:51 <Peaker_> idnar, its not arbitrarily outlawing but more of not having them in the first place
07:40:00 <skorpan> people often wish to have side effects easily
07:40:11 <yitz> Peaker_:  not arguing, I like Python better than Perl. But there is something to it
07:40:12 <idnar> Peaker_: ok, so in haskell's case, that would mean forcing you to use lambda syntax for every function definition
07:40:14 <Peaker_> where is a good source to read about parallelism in Haskell?
07:40:17 <idnar> Peaker_: (for example)
07:40:27 <idnar> Peaker_: I don't think that would be a very beneficial trade-off
07:40:38 <Peaker_> idnar, That would be great - if lambda syntax was also made a bit nicer
07:40:39 <glen_quagmire> i think the reason haskell isn't yet mainstream is ajax and mvc
07:41:19 <Peaker_> I think that if Haskell was as "accessible" as Python is (apt-get install python ; python ; "help" -> "neat!") it would help a lot
07:41:21 <yitz> skorpan: purity is Haskell's forte.
07:41:24 <idnar> Peaker_: anyhow, I guess I've side-tracked myself
07:41:25 <b_jonas> Peaker: lambda syntax nicer? in what way? do you mean multiple cases?
07:41:33 <idnar> Peaker_: there are millions of ways to do things in Python too
07:41:35 <b_jonas> multiple patterns that is
07:41:47 <Peaker_> even a funny thing like "apt-cache search haskell" bringing back tons of unrelated pages and no "haskell" command add up to the barrier to entry
07:41:52 <Peaker_> idnar, "one obvious way"
07:41:53 <idnar> Peaker_: so I guess your complaint is that you get bombarded with too much too fast when learning Haskell?
07:41:59 <glen_quagmire> lambdas should be like this:  (_a + _b) 1 2 ==> 3
07:42:12 <idnar> Peaker_: there are plenty of situations where there isn't a single obvious way
07:42:19 <b_jonas> glen_quagmire: no.
07:42:36 <EvilTerran> glen_quagmire, how do you know where a lambda stops, then?
07:42:41 <b_jonas> but if you want that, you can probably do it with a bit of magic and defining _a and _b
07:42:52 <EvilTerran> you could use magic brackets, i guess
07:43:08 <b_jonas> though the type of < and other stuff can make it difficult
07:43:08 <EvilTerran> (\ _a + _b \) or something
07:43:15 <idnar> Peaker_: "apt-cache search c" is even worse, but I don't think people have trouble finding a C compiler ;)
07:43:27 <b_jonas> EvilTerran: I don't like that idea
07:43:45 <EvilTerran> b_jonas, me neither, but i'm just pointing out how it's not as simple as it looks
07:43:50 <ivan_>  i have a problem with definint loop in arrow, it says a (b,d) (c,d) -> a b c, the only thing i want it to do is to take (b-d) but to get the d i have to run b to c and then run (b-d) to get the final c, i dont understand how to define loop, any suggestions?
07:43:57 <b_jonas> if I want easy lambdas, then it'd rather be normal lambdas AND apl2-like TRAINS
07:44:08 <EvilTerran> choo choo?
07:44:12 <b_jonas> yes
07:44:20 <idnar> Peaker_: also, I'm not sure what you mean by "unrelated"; almost all of the entries I get from that are Haskell libraries, which is pretty similar to the output from, for example, "apt-cache search python"
07:44:24 * EvilTerran would quite like two-ended sections, mind
07:44:27 <b_jonas> though it's not trivial to work out the syntax
07:44:51 <EvilTerran> if sections worked by syntax-tree splicing, regardless of operator precedence
07:45:04 <EvilTerran> so (x++y++) = (x++).(y++)
07:45:11 <b_jonas> I was just thinking about nice language syntax today, and I couldn't work it out.
07:45:22 <EvilTerran> it'd make sense for (++x++) to mean (\a b -> a ++ x ++ b)
07:45:55 <EvilTerran> ((x++y++) = \a -> x++y++a, rather than \a -> (x++y)++ a)
07:46:05 <b_jonas> apl2/j trains are very good for all common cases, but they get complicated in some ugly general cases
07:46:32 <glen_quagmire> \x \y dup [dip] + swap   lol
07:46:35 <b_jonas> I'd like to work out a syntax that's both general and nice for simple cases
07:46:54 <EvilTerran> de brujin notation!
07:46:56 <b_jonas> and has nice rules
07:47:08 <b_jonas> heh, de bruin notation
07:47:11 <EvilTerran> (\.\. #0 + #1)
07:47:33 <b_jonas> why the dot then though?
07:47:49 <EvilTerran> so it knows to stop looking for the ->
07:48:08 <b_jonas> but if you only have de-bruin, it's not needed
07:48:19 <EvilTerran> i meant as a haskell extension
07:48:23 <b_jonas> you can still (\let foo=# in bar)
07:48:27 <b_jonas> if you want to name something
07:48:31 <EvilTerran> ew ew ew
07:48:38 <b_jonas> that wouldn't be a haskell extension thoguh
07:48:45 <b_jonas> \. is an infix operator in haskell
07:48:53 <EvilTerran> eh. true.
07:49:08 <b_jonas> and # is too, in #0
07:49:33 <EvilTerran> well, it'd be a pseudo-extension :P
07:49:48 <EvilTerran> unicode characters!
07:50:56 <smg> say i have file_1 .. file_i which i want to make a module out of it. how would i do it?
07:51:06 <Philippa> Peaker: there's no haskell command (well, actually - runhaskell) because there's no canonical implementation
07:51:14 <EvilTerran> (λλ 0̱+1̱)
07:51:14 <Philippa> this isn't python or perl
07:51:32 <Philippa> okay, many platforms have cc for "C compiler"...
07:51:37 <b_jonas> wait, what if you wrote do instead of \.
07:51:40 <b_jonas> could it work that way?
07:51:50 <b_jonas> no, it couldn't
07:51:51 <b_jonas> pity
07:52:23 <b_jonas> philippa: and some prolog interpreters have the executable named just prolog or pl
07:52:51 <b_jonas> as for cc, that's because in the beginning, there was only one c interpreter on the c-based unix
07:52:59 <b_jonas> and it's compatibility starting from there
07:53:09 <Philippa> yeah, I know
07:53:09 <smg> should i just put all files in a dir?
07:58:20 <glen_quagmire> smg: i think you can only have 1 module per file
07:58:44 <glen_quagmire> if all files have    module DirName.ModuleName where  ...  then the DirName kinda becomes module i guess
07:58:55 <smg> ah sorry what i wanted to have is this: i want to import MyLibrary.MyModule
07:59:07 <smg> how would i do this? put all modules in the dir MyLibrary?
08:00:04 <glen_quagmire> so,  mkdir -p src/MyLibrary  ;   mv *.hs src/MyLibrary ;  mv src/MyLibrary/Main.hs src ;  then change all library files so that their module name becomes MyLibrary.ActualModuleName
08:00:52 <glen_quagmire> smg: so you need a directory named MyLibrary. and put files there. the files there should have module MyLibrary.ModuleName where ...
08:01:06 <smg> ok
08:01:18 <glen_quagmire> if that doesn't work. i failed again.
08:02:34 <glen_quagmire> @google haskell module search algorithm
08:02:35 <lambdabot> No Result Found.
08:02:59 <smg> glen_quagmire: it will work
08:03:12 <smg> but atm i need to downgrade ghc... cabal fails on 6.8.2 somehow
08:10:08 <glen_quagmire> result <- parseAndEval input  -- this might throwError, how can I handle it?
08:11:00 <Lemmih> glen_quagmire: Catch the exception?
08:11:10 <glen_quagmire> catchError!
08:16:21 <Peaker_> Philippa, I think a canonical implementation, just an arbitrary choice for Ubuntu/etc could help new users
08:16:35 <Peaker_> idnar, indeed apt-cache search python does, but I can just apt-get install python, run it, and start working with it
08:16:38 <hallongrottan> what does "illegal bang pattern" mean?
08:16:45 <glen_quagmire> result <- catchError (parseAndEval line) (e -> return e)    can't be done because  parseAndEval line :: Wrap Val  ;  but e in the lambda is Err.  And I don't want to merge Err type with Val type
08:16:59 <Peaker_> idnar, Haskell is a lot less "accessible" in that way, and ofcourse due to it doing things in a different way that is not obvious to newcomers
08:17:02 <hallongrottan> i just made a guard saying balbla ns | !valid ns = Nothing
08:17:07 <hallongrottan> adn ghci does NOT like it
08:17:30 <Peaker_> idnar, I think a good UI that creates Haskell programs can help new users a lot..
08:17:31 <glen_quagmire> when parseAndEval throws, I want to print the error.  otherwise, i want to capture the returned Val and print it
08:17:53 <quicksilver> hallongrottan: ! does not mean not
08:17:57 <quicksilver> hallongrottan: (if that's what you hoped)
08:17:59 <hallongrottan> well yes
08:18:06 <quicksilver> hallongrottan: operators in haskell are all infix, except for stupid -
08:18:12 <quicksilver> | not (valid ns)
08:18:16 <hallongrottan> ah
08:18:19 <hallongrottan> lol
08:18:20 <hallongrottan> thanks
08:28:37 <idnar> Peaker_: for me, the main obstacles to switching my projects over to Haskell are 1) I'm still lacking in Haskell experience, 2) existing projects probably aren't worth rewriting from scratch, 3) lack of libraries for doing stuff, so I'd have to write a lot of code myself to get things up and running
08:29:05 <Baughn> idnar: What sort of things are you missing libraries for?
08:29:57 <idnar> Baughn: databases, network protocols, web frontends, and probably other stuff
08:30:09 <idnar> Baughn: not to say that there are absolutely no libraries that already implement that sort of functionality
08:30:09 <skorpan> is it possible to let two functions with the exact same name take a different number of arguments?
08:30:28 <mrd> skorpan: no and yes
08:30:35 <skorpan> mrd: Maybe Bool?
08:30:37 <idnar> but they're just not up to the level of my existing tools, from what I've seen
08:30:40 <mrd> skorpan: one way
08:30:49 <mrd> idnar: anything specific?
08:30:57 <skorpan> mrd: mind telling me more about this?
08:31:11 <idnar> mrd: hmm, it's hard to pin down, without just saying "well, in Python, I have $LIBRARY"
08:31:13 <Baughn> idnar: For databases, HDBC-odbc does everything I've asked for. You've got me on "network protocols", but that's hopelessly vague
08:31:16 <mrd> skorpan: what are you trying to do?  simply speaking, all functions in haskell take precisely one parameter.
08:31:20 <Peaker_> idnar, I think once people "see the light" and understand how things are done and why that is better, then the barriers of entry you mention come in effect, but until then, the "little" barriers like the ease of getting a prompt that lets you type "help" are the ones that matter, and they probably block a significant amount of users who would otherwise try it out
08:31:25 <mrd> idnar: hackage has tons and tons of stuff
08:31:42 <skorpan> mrd: i see what you mean.. i'm trying to create a function which takes no arguments or exactly one String
08:31:51 <idnar> Baughn: HDBC-odbc sounds like a fairly low-level thing
08:31:54 <mrd> skorpan: the usual way is Maybe String
08:32:04 <skorpan> yes, but then i'd have to write "fn Nothing"
08:32:04 <idnar> Baughn: what I'm looking for is more on the level of an ORM, for example
08:32:17 <mrd> idnar: how about Takusen
08:32:31 <idnar> (or something like Mnesia, perhaps)
08:32:35 <Baughn> idnar: It lets you do parametrized sql queries. ORM.. I must admit, I'm on the relational side of that contest
08:32:37 <mrd> and ORMs are fundamentally broken ideas, I've gotten sick of using them
08:32:45 <mrd> but takusen is high level in other ways
08:32:51 <idnar> well, I'm not saying I need an ORM
08:33:08 <idnar> I'm just looking for something more than a thin wrapper over an SQL client library
08:33:20 <idnar> I guess I'll take a look at Takusen
08:33:36 <mrd> and which network protocol are you looking to use?
08:33:53 <quicksilver> skorpan: just make two functions with slightly different names.
08:34:04 <quicksilver> skorpan: there are other hacks using type classes but they're probably not what you want.
08:34:15 <quicksilver> or just type fn Nothing :)
08:34:46 <skorpan> quicksilver: :)
08:35:02 <kjdf> "haddock: no GHC lib dir specified"
08:35:10 <kjdf> ^ what should I do to fix this?
08:35:19 <kjdf> it expects a "libdir" argument
08:36:24 <Gnezdo> kjdf: this is kind of suboptimal though as it could default to the GHC it was built with (cabal does have this available, doesn't it?)
08:36:25 <glen_quagmire> let result = case ... of    is this wrong?
08:36:39 <mrd> it's not complete
08:37:32 <quicksilver> skorpan: it may be enlightening to think a bit harder about the problem.
08:37:40 <quicksilver> skorpan: suppose f :: String -> Int
08:37:50 <quicksilver> skorpan: (but you want the string parameter to be optional)
08:38:12 <idnar> mrd: Jabber is the most recent protocol I've touched, I guess
08:38:21 <quicksilver> skorpan: what should "f" on its own mean?
08:38:32 <quicksilver> skorpan: shall it be "f", applied, but with no parameters, and thus an Int.
08:38:42 <quicksilver> skorpan: or, shall it be "f", unapplied, and thus a function of type String -> Int.
08:39:14 <idnar> mrd: I see http://www.dtek.chalmers.se/~henoch/text/hsxmpp.html but it's not exactly an extensive / mature library
08:39:15 <lambdabot> Title: XMPP
08:39:43 <idnar> mrd: this is one of those army of monkeys things, though
08:39:54 <quicksilver> skorpan: that's the basic problem. You can answer that question with typeclasses, in fact.
08:39:58 <idnar> the more monkeys you have banging on the typewriters, the more likely it is that one of them already typed out the thing you wanted ;)
08:41:12 <idnar> there are still some bigger libraries / frameworks (HAppS, for example) that I need to check out
08:41:42 <quicksilver> happs isn't a framework, it's a mental illness
08:41:53 <quicksilver> there is no known cure, look at it at your own risk :)
08:42:09 <idnar> quicksilver: hoeh
08:42:10 <idnar> *heh
08:42:26 <idnar> quicksilver: I was hoping my initial impressions would turn out to be wrong ;)
08:42:33 <quicksilver> ;)
08:42:42 <quicksilver> I'm not suggesting it's a bad thing.
08:42:50 <quicksilver> I'm just suggesting it is not intended for human minds.
08:43:04 <idnar> that's ok, I don't think I'm entirely human these days
08:43:33 <Lemmih> People said the same about laziness and lack of mutability.
08:43:41 <Taejo> ug
08:45:01 <paolino> how I take even elements from a list ?
08:45:24 <ivan__> what do i need to use the sugar syntax for arrows :/ ghci complains about proc x -> do ?????
08:45:49 <Lemmih> paolino: filter even?
08:45:52 <allbery_b> {-# LANGUAGE Arrows #-} I presume
08:46:10 <quicksilver> Lemmih: I'm not serious about happs, if that's not clear.
08:46:21 <quicksilver> But it does  challenge people's preconceptions in a host of ways.
08:46:33 <paolino> Lemmih: is that for indexes I suppose
08:46:42 <quicksilver> so it is a little more than the average gobstopper to get around.
08:46:59 <mrd> > map snd . filter (first even) . zip [0..] $ "abcdefghij"
08:47:01 <idnar> I already end up reinventing my own wheels half the time
08:47:01 <lambdabot>  Couldn't match expected type `Bool'
08:47:12 <mrd> > map snd . filter (even . fst) . zip [0..] $ "abcdefghij"
08:47:14 <idnar> so I don't mind doing some of that; but there's a trade-off point
08:47:14 <lambdabot>  "acegi"
08:47:35 <mrd> or even better
08:47:43 <paolino> mrd, I hope that's not The way
08:47:43 <quicksilver> > map head . takeWhile (not.null) . iterate (drop 2) $ "abcdefghi"
08:47:44 <lambdabot>  "acegi"
08:48:06 <mrd> > map snd . filter fst . zip (cycle [True, False]) $ "abcdefghij"
08:48:07 <lambdabot>  "acegi"
08:48:14 <idnar> hmm, XML processing is something else I was looking at; HaXML seemed nice, but a bit unwieldy and abandoned
08:48:16 <mrd> or maybe not better, i dunno
08:48:22 <paolino> :)
08:48:24 <ttt--> > "acegi"
08:48:24 <lambdabot>  "acegi"
08:48:28 <quicksilver> mrd: that is odd elements, of course
08:48:31 <mrd> I don't know about HaXML, I think it is actively maintained.  I use HXT.
08:48:35 <quicksilver> (as were our other two attempts)
08:48:40 <mrd> quicksilver: er, i'm counting from 0
08:48:44 <quicksilver> ah
08:48:45 <mrd> > map snd . filter fst . zip (cycle [False ..]) $ "abcdefghij"
08:48:45 <lambdabot>  "bdfhj"
08:48:49 <quicksilver> you win then ;)
08:48:52 <idnar> guess I'll take a look at HXT
08:49:00 <mrd> @wiki HXT/Practical
08:49:01 <lambdabot> http://www.haskell.org/haskellwiki/HXT/Practical
08:49:04 <mrd> @go wikibook HXT
08:49:05 <lambdabot> http://en.wikibooks.org/wiki/Haskell/XML
08:49:05 <lambdabot> Title: Haskell/XML - Wikibooks, collection of open-content textbooks
08:49:10 <mrd> @wiki HXT
08:49:10 <lambdabot> http://www.haskell.org/haskellwiki/HXT
08:49:27 <quicksilver> idnar: haxml is in no way abandoned
08:49:37 <quicksilver> idnar: what gave you the impression it was?
08:49:45 <paolino> thnks
08:49:49 <idnar> quicksilver: I'd have to poke around to give specifics
08:50:15 <quicksilver> the most recent haxml version was january 14th
08:50:18 <quicksilver> just a couple of months old
08:50:27 <quicksilver> mmm, the smell of fresh XML!
08:50:27 <idnar> quicksilver: where is that?
08:50:28 <smg> > quickCheck (\s -> all (`elem` ['a'..'e']) (take5 s))
08:50:28 <lambdabot>   Not in scope: `take5'
08:50:34 <smg> > quickCheck (\s -> all (`elem` ['a'..'e']) (take 5 s))
08:50:35 <quicksilver> idnar: http://www.cs.york.ac.uk/fp/HaXml-devel/
08:50:35 <lambdabot>  <IO ()>
08:50:36 <idnar> quicksilver: maybe I was just looking at old webpages
08:50:36 <lambdabot> Title: HaXml: Haskell and XML
08:50:45 <mrd> quicksilver: like stale BO
08:50:47 <quicksilver> smg: @check
08:50:59 <idnar> quicksilver: hmm. I'm pretty sure I never saw that page
08:51:04 <quicksilver> @check (\s -> all (`elem` ['a'..'e']) (take 5 s))
08:51:10 <lambdabot>  Falsifiable, after 0 tests: "\968728"
08:52:08 <quicksilver> win 24
08:52:10 <quicksilver> grrr!
08:52:51 <smg> hehe
08:52:58 <smg> so check needs invariants?
08:56:05 <Saizan> lazy IO is even more broken on windows, you can't delete a file if you still ahve the Handle open, and hGetContents doesn't close it immediatly
09:00:17 * paolino thinks lazy IO is utopia
09:01:28 <glen_quagmire> f :: Wrap Val.  newtype Wrap = Wrap ErrorT ...    so, how can I pattern match f for the case of Left (error) ??     case f of (Left err, st) ->   can't be done because Wrap is newtype
09:03:27 <paolino> (Wrap (Left err)) is wrong ?
09:05:59 <glen_quagmire> Couldn't match expected type `E.ErrorT Err (S.StateT EnvStack IO) Val`  in the pattern Wrap (Left err, st)
09:07:10 <Saizan> paolino: it's very useful, but needs to be handled with care
09:08:09 <quicksilver> glen_quagmire: erm, you're doing it all wrong
09:08:09 <b_jonas> lazy IO can't work without a special monad, can it?
09:08:12 <quicksilver> glen_quagmire: (no offence)
09:08:21 <quicksilver> glen_quagmire: the problem isn't wrap, it's Left
09:08:22 <b_jonas> (isn't mmap lazy IO enough?)
09:08:25 <glen_quagmire> quicksilver: lead me to the right path
09:08:35 <quicksilver> glen_quagmire: ErrorT does not have 'Left' as a constructor.
09:08:42 <quicksilver> Left is a constructor of Either.
09:08:45 <quicksilver> (not ErrorT)
09:08:58 <quicksilver> although ErrorT is built from Either, it's not the same thing.
09:09:14 <quicksilver> :t ErrorT
09:09:16 <lambdabot> forall (m :: * -> *) e a. m (Either e a) -> ErrorT e m a
09:09:19 <phobes_> Philippa:  (If you're still around)   I think you previously mentioned to me that STT had higher consistency strength than ZFC.  Is that right?  And if so, do you know if STT is known to be consistent in ZFC + some sufficiently large inaccessible cardinal?
09:09:42 <ivan__> hi, realy need help with arrow syntax, i cant get it to work, i have imported Control.Arrow, do i need anything else?
09:09:54 <quicksilver> glen_quagmire: you might get an explicit constructor to match with something like a Wrap ( ErrorT ( Left ( StateT (.....
09:10:09 <quicksilver> glen_quagmire: but that's not the way you're supposed to use monad transformers, for obvious reasons.
09:10:15 <sethk_> The parsec docs show running a Token parser using runLex, but I don't find runLex in the docs or in the parsec modules.  Any clues?
09:10:18 <quicksilver> glen_quagmire: you're supposed to use the combinators they give you.
09:10:22 <glen_quagmire> yah. i don't want to expose data constructor Wrap
09:10:38 <phobes_> Philippa:  It was probably CIC, not STT
09:10:47 <paolino> :t runErrorT
09:10:48 <lambdabot> forall e (m :: * -> *) a. ErrorT e m a -> m (Either e a)
09:11:01 <quicksilver> glen_quagmire: (and you don't want to have to use the constructors StateT, ErrorT by hand, either)
09:11:12 <quicksilver> glen_quagmire: paste a fragment of code and we'll have a look at it.
09:11:40 <quicksilver> if you use all the constructors by hand in case statements then, apart rom very ugly code, you end up depending deeply on the exact shape of the stack
09:11:43 <quicksilver> which is not much fun.
09:13:19 <paolino> Saizan, lazy IO would be based on the strict one in the end
09:13:46 <dcoutts_> Saizan: do you want to put yourself as owner of ticket #40, kr.angelov was the reporter and should not really be down as assigned
09:14:00 <glen_quagmire> quicksilver: http://hpaste.org/6475   it's not a compilable testcase . just fragments
09:14:17 <Baughn> Is there an interface for asynchronous i/o anywhere yet?
09:14:33 <dcoutts_> Baughn: make one up! :-)
09:14:35 <Saizan> dcoutts_: ok, i almost have the patch too, just need to add comments
09:14:40 <dcoutts_> Saizan: oh cool
09:14:43 <Baughn> dcoutts_: I will. :)
09:14:48 <dcoutts_> Saizan: using interleave io
09:15:05 <dcoutts_> Baughn: there are a few ideas around but there is nothing standard
09:15:07 <quicksilver> glen_quagmire: you don't case parseAndEval
09:15:11 <quicksilver> glen_quagmire: you "use" it directly
09:15:18 <quicksilver> val <- parseAndEval line
09:15:20 <Saizan> dcoutts_: yes, but properly closing the handles, i've found this is a problem on windows because it doesn't let you delete open files
09:15:25 <b_jonas> why not with threads?
09:15:27 <quicksilver> glen_quagmire: errors will be thrown automatically (that's the point of your monad)
09:15:30 <dcoutts_> Baughn: of course haskell light weight threads give you an async IO api
09:15:34 <glen_quagmire> quicksilver: then in case of error, the program quits
09:15:35 <quicksilver> glen_quagmire: the state will be threaded automatically, too
09:15:55 <Baughn> dcoutts_: They do, but I'm worried that overlapped i/o to multiple devices just might not happen, the way it works now
09:16:13 <dcoutts_> Saizan: oh, hmm, the handles should close automatically when the last byte is read, or is that the bytestring-0.9.0.1 bug?
09:16:51 <glen_quagmire> so i wanted to catchError (parseAndEval line) (\e -> return e)   but the type of e was Err while parseAndEval line was Wrap Val
09:16:56 <Saizan> dcoutts_: i'm using 0.9.0.1 so maybe yes, since i read all the bytes
09:17:01 <ivan__> why dosn't syntax for arrows work in ghci ?
09:17:15 <dcoutts_> Baughn: the threads gives an api, but of course the current rts does not do async io, just non-blocking io which has many similar characteristics (with enough buffering at least)
09:17:35 <dcoutts_> Saizan: try with 0.9.0.4 and without the explicit closing
09:17:36 <Baughn> dcoutts_: For the /interface/, I should think that something like "call function to read* file into a bytestring, start reading in the background, block once you access data that hasn't been read yet (* or write)" would be sufficient
09:17:59 <dcoutts_> Baughn: you mean completely transparent
09:18:04 <smg> can i use deriving OwnTypeClass when declaring a data/newtype?
09:18:08 <Baughn> dcoutts_: That'd be ideal, yes
09:18:10 <mauke> smg: no
09:18:14 <Saizan> dcoutts_: btw, i've fixed some imports in cabal-install wrt the moving of Dependency in Cabal, should i send the patch?
09:18:20 <Baughn> dcoutts_: As I recall, there was some initiative to rewrite the io part of the rts a few months ago. Did that go anywhere?
09:18:22 <dcoutts_> Baughn: do content <- readStuff; blah blah; evaluate (length content)
09:18:45 <dcoutts_> Baughn: the threaded rts manages all IO in Haskell using an IO manager thread
09:19:15 <dcoutts_> Baughn: the IO manager thread calls select but it could be adapted to use OS-specific things like epoll etc
09:19:33 <quicksilver> glen_quagmire: no, the program won't quit
09:19:39 <quicksilver> glen_quagmire: (sorry I was off talking to someone)
09:19:49 <quicksilver> glen_quagmire: the error will ripple back up to main
09:19:54 <quicksilver> glen_quagmire: (to your runErrorT)
09:20:02 <quicksilver> glen_quagmire: and the runErrorT will turn it into a Left up there
09:20:18 <dcoutts_> Baughn: of course there is the issue that most OSs do not do async IO very well at all, certainly that's true for linux and related. Solaris and Windows do a bit better.
09:20:28 <Toxaris> glen_quagmire: parseAndEval line >>= print `catchError` print
09:21:35 <Baughn> dcoutts_: That /would/ be an issue. aio_read/aio_suspend are insufficiently implemented?
09:21:57 <dcoutts_> Baughn: they work but are no faster and are implemented using threads and blocking IO, so usually slower.
09:22:44 <Toxaris> glen_quagmire: alternatively, to avoid the duplication of print: (liftM show (parseAndEval line) `catchError` return . show) >>= print
09:22:53 <Baughn> dcoutts_: Ouch. Still, if it's implemented using them it'd hopefully start working later?
09:23:08 <Toxaris> glen_quagmire: hmm, not print but putStrLn in the alternative variant
09:23:23 <dcoutts_> Baughn: maybe, the apis are also very limited, you cannot use posix aio easily with an event loop iirc
09:23:40 <dcoutts_> Baughn: the api for finding out when an aio operation has completed does not integrate with other events
09:23:44 <Baughn> dcoutts_: http://lse.sourceforge.net/io/aio.html <-- This suggests that it is, in fact, implemented - using another api, which may be better
09:23:45 <lambdabot> Title: Kernel Asynchronous I/O (AIO) Support for Linux
09:25:54 <dcoutts_> Baughn: note that it says that it does not work on ordinary files
09:26:34 <Baughn> dcoutts_: We'd have to use O_DIRECT. I have no idea how that would affect things - probably badly.
09:26:53 <dcoutts_> Baughn: yep
09:27:34 <Baughn> I suppose there's one bright spark in this mess
09:27:48 <Baughn> I can now claim honestly that haskell's i/o is as good as linux allows it to be. >_<
09:28:45 <dcoutts_> Baughn: there's a new proposal for linux aio that'd work everywhere, there are several articles on lwn
09:29:24 <dcoutts_> Baughn: the point is, don't set your sights on it, think of it as an OS-specific optimisation
09:32:40 <Saizan> dcoutts_: it works fine with 0.9.0.4, so it was the bug
09:33:06 <dcoutts_> Saizan: excellent, so if it simplifies the code then don't include the closing hack
09:34:10 <glen_quagmire> quicksilver, Toxaris thank you! it is working!
09:34:13 <Saizan> dcoutts_: should i note this anywhere?
09:34:19 <quicksilver> glen_quagmire: yay :)
09:34:29 <ivan__> do any! know how to get the arrow syntax to work in ghci ?
09:34:35 <quicksilver> glen_quagmire: the point is, that have a monad stack is supposed to save you from all those explicit cases
09:34:35 <glen_quagmire> XP++ level up!
09:34:36 <dcoutts_> Saizan: how nasty is the closing hack?
09:34:40 <quicksilver> glen_quagmire: that's the "point" ;)
09:34:43 <quicksilver> glen_quagmire: to make it all implicit
09:35:05 <dcoutts_> Saizan: we could just depend on the bytestring without the bug
09:35:51 <glen_quagmire> i would never have come up with this line myself: http://hpaste.org/6475#a1
09:36:01 <dcoutts_> Saizan: if the hack to work with 0.9.0.1 is not too bad in your opinion then fine, keep it with a TODO note explaining why it's there and when we can remove it
09:36:58 <oerjan> ivan__: -XArrows
09:37:11 <oerjan> http://haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#id351320
09:37:14 <lambdabot> Title: 5.17. Flag reference, http://tinyurl.com/yod3gf
09:37:17 <glen_quagmire> Wrap Val --> Wrap String --> in case of error, Err --> Wrap String --> print
09:37:31 <ivan__> oerjan: when i start ghci?
09:37:56 <oerjan> yeah
09:38:21 <oerjan> ivan__: or with the :set command
09:38:35 <ivan__> oerjan: i have ghci 6.6.1 and i dosn't work :( i have installed libghc6.1-arrows
09:38:56 <oerjan> oh -X may be new syntax
09:39:09 <oerjan> try -farrows
09:39:45 <ivan__> yup that could work, didn't get error =)
09:40:18 <oerjan> i guess the 6.6 guide is around there somewhere
09:41:25 <ivan__> oerjan: the loading didn't fail =) so maybe it works, are the syntaxis the same ?
09:41:36 <conal> is there a name for functions that distribute over Functor, Applicative, and/or Monad methods?  e.g., foo (fmap f z) = fmap f (foo z).  I have quite a lot of these guys.
09:41:36 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
09:41:37 <oerjan> ivan__: http://www.haskell.org/ghc/docs/6.6.1/html/users_guide/flag-reference.html#id3132983
09:41:38 <lambdabot> Title: 4.17. Flag reference, http://tinyurl.com/3aqfl4
09:41:48 <oerjan> (for 6.6.1, -farrows seems correct)
09:42:32 <ivan__> oerjan: thx =)
09:42:38 <conal> gwern: ping
09:45:19 <skorpan> what's the real use of the reader monad? i'm currently thinking of it as basically the State monad, without the "a" is s -> (a,s).
09:45:45 <quicksilver> glen_quagmire: it's kind of cute, but probably not how I would write it myself
09:45:53 <oerjan> conal: i think that is a natural transformation from the functor to itself
09:46:14 <mauke> skorpan: Reader is State without the s in (a,s)
09:46:21 <skorpan> ah... so true.
09:46:35 <conal> oerjan: two different functors
09:46:42 <skorpan> so is there anything which is like State without the a in (a,s)? e.g. s -> s
09:46:58 <oerjan> ah yes, confused by the fmap notation
09:47:00 <glen_quagmire> quicksilver: how would you write it?
09:47:08 <oerjan> conal: so it is simply a natural transformation then
09:47:10 <conal> oerjan: of course.  what about Applicative & Monad?
09:47:12 <mauke> skorpan: yes, Endo
09:47:16 <conal> oerjan: thx
09:47:24 <skorpan> @hoogle Endo
09:47:24 <lambdabot> Data.Monoid.Endo :: newtype Endo a
09:47:24 <lambdabot> Data.Monoid.Endo :: (a -> a) -> Endo a
09:47:24 <lambdabot> Data.Monoid.appEndo :: Endo a -> a -> a
09:47:24 <oerjan> conal: well they are also Functors, at least in spirit
09:47:28 <Toxaris> glen_quagmire: http://hpaste.org/6475#a2
09:47:35 <glen_quagmire> Toxaris: woot just checked
09:47:56 <Toxaris> glen_quagmire: handleError's type probably needs a MonadIO constraint and it's implementation a liftIO to make print work, but you get the idea
09:48:01 <quicksilver> glen_quagmire: just annotated my version.
09:48:05 <quicksilver> Toxaris: erm, that's wrong :P
09:48:18 <quicksilver> Toxaris: the line == ":q" part does nothing
09:48:28 <quicksilver> Toxaris: return () does not short-circuit in haskell :)
09:48:34 <Toxaris> oups :)
09:49:01 <quicksilver> I thnk you want "when (line /= ":q") (handleErrors .....)
09:49:13 <Toxaris> yeah maybe
09:49:19 <Toxaris> I don't like the case inside the do
09:49:29 <Toxaris> I prefer "flat" do's
09:49:41 <quicksilver> glen_quagmire: my point is that >>= is all very well, but I wanted you to see the do version
09:49:59 <quicksilver> glen_quagmire: and point-free is also very well, but by naming the exception 'e' I remind myself it is an exception.
09:50:16 <quicksilver> glen_quagmire: in other words, my unfolding might be easier to understand, although the >>= version was definitely cuter.
09:50:27 <conal> oerjan: sure.  though there are additional properties that hold besides the nat trans property.  foo (pure a) = pure a, foo (u <*> v) = of u <*> foo v, and foo (join uu) = join (fmap foo (foo uu))
09:50:55 <conal> (s/of u/foo u/)
09:51:13 <oerjan> conal: now that sounds like a homomorphism
09:51:30 <glen_quagmire> fmap is almost same as liftM
09:51:36 <conal> oerjan: agreed.
09:51:41 <quicksilver> glen_quagmire: yes it is. I'm not sure why I prefer it.
09:51:48 <quicksilver> glen_quagmire: I like to write it infix though.
09:51:57 <quicksilver> glen_quagmire: in fact, in real code I'd use <$> instead of `fmap`
09:52:01 <Toxaris> quicksilver, glen_quagmire: and I prefer error-handling to be as top-level as possible, e.g. not hidden inside the expression producing the string to be printed, but selecting between a value-printing and an error-printing part of the program
09:52:04 <quicksilver> which is exactly the same thing, but looks nicer.
09:52:15 <EvilTerran> well, you don't have to import fmap. that's always handy.
09:52:19 <smg> is mutually recursion nifty? :)
09:52:25 <EvilTerran> and it's nice to be as general as possible :)
09:52:38 <EvilTerran> smg, yes. yes it is. tying the knot is also very nifty.
09:53:31 <glen_quagmire> man today i learned a lot. #haskell is the best haskell book
09:53:35 <conal> i'm writing up new foundation for FRP, with semantics & efficient implementation, noting that the semantic functions for behaviors, events, reactive values, and futures, are all homomorphic in this way.
09:53:50 <mofmog> how would i partially evaluate a function out of order
09:54:14 <mofmog> say i had map and i want to partially evaluate the list so as to produce a function that accepts other functions
09:54:27 <mofmog> :t map
09:54:28 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:54:35 <conal> and i'm wondering how to express those particular homomorphisms in a succinct and hopefully familiar way.
09:54:54 <oerjan> mofmog: you mean like \l f -> map f l ?
09:54:55 <Toxaris> :t flip map [1, 2, 3]
09:54:56 <lambdabot> forall a b. (Num a) => (a -> b) -> [b]
09:54:56 <mofmog> from map, I want a function (a -> b) -> [b]
09:55:03 <oerjan> or that
09:55:13 <Toxaris> mofmog: use lambda or flip or infix syntax
09:55:33 <Toxaris> :t (`map` [1,2,3])
09:55:35 <lambdabot> forall a b. (Num a) => (a -> b) -> [b]
09:55:43 <mofmog> haha that is truly awesome
09:55:57 <scook0> :t flip map [1..3]
09:55:58 <lambdabot> forall a b. (Enum a, Num a) => (a -> b) -> [b]
09:56:10 <oerjan> guess that about covers it :)
09:56:22 <scook0> :t (\xs f -> map f xs) [1,2,3]
09:56:23 <lambdabot> forall a b. (Num a) => (a -> b) -> [b]
09:56:34 <Toxaris> :t (<$> [1,2,3])
09:56:35 <lambdabot> forall a b. (Num a) => (a -> b) -> [b]
09:56:39 <smg> EvilTerran: haah! :)
09:58:02 <smg> > let even = \x -> if x == 0 then True else odd (x-1) in let odd = \z -> if z == 0 then False else even(x-1) in even 4
09:58:03 <lambdabot>  True
09:58:07 <smg> > let even = \x -> if x == 0 then True else odd (x-1) in let odd = \z -> if z == 0 then False else even(x-1) in even 3
09:58:08 <lambdabot>  False
09:58:23 <smg> EvilTerran: :)
09:58:54 <EvilTerran> ... you do realise those aren't mutually recursive...
09:59:19 <Toxaris> > let even = \x -> if x == 0 then True else odd (x-1) in let odd = error "never called" in even 4
09:59:20 <lambdabot>  True
09:59:25 <Toxaris> > let even = \x -> if x == 0 then True else odd (x-1) in let odd = error "never called" in even 3
09:59:25 <lambdabot>  False
09:59:38 <EvilTerran> the binding of even can't see the binding of odd - it's not in scope in the outer let
09:59:42 <EvilTerran> it's calling Prelude.odd
10:00:09 <oerjan> conal: you might consider commutative diagrams
10:00:31 <EvilTerran> > let even' 0 = True; even' n = odd' (n-1); odd' 0 = False; odd' n = even' (n-1) in [even', odd'] <*> [1..5]
10:00:31 <lambdabot>  [False,True,False,True,False,True,False,True,False,True]
10:01:23 <EvilTerran> > let even' 0 = True; even' n = odd' (n-1); odd' 0 = False; odd' n = even' (n-1) in [even', odd'] <*> [a,b,c,d,e]
10:01:28 <conal> oerjan: yep.  i just thought maybe these particular homomorphisms (Functor, Applicative, Monad) already had standard names and studied properties, e.g. for type composition.
10:01:29 <lambdabot> Terminated
10:02:03 <oerjan> ah.  well i don't know.
10:03:05 <oerjan> "morphism in the category of Monads" or something like that probably
10:03:42 <gnuvince> The variables a', a'', a''', how do you pronounce them? a prime, a prime prime, a prime prime prime?
10:03:52 <Zao> prime, bis,
10:03:55 <skorpan> a prime, a bis, a something
10:04:03 <conal> oerjan: okay, thanks for the help.
10:04:06 <Zao> tres?
10:04:16 <oerjan> ter comes after bis iirc
10:04:18 <mrd> un dos tres
10:04:26 <oerjan> (in latin)
10:04:28 <skorpan> isn't that usually written sort of as "a^3" if it's obvious that one is speaking derivation?
10:04:39 <skorpan> never mind
10:04:42 <skorpan> helps nothing
10:04:43 <Toxaris> > let even' 0 = True; even' n = odd' (n-1); odd' 0 = False; odd' n = even' (n-1) in even' <$> [0, 1, 2, 3] :: Expr
10:04:43 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[Bool]'
10:04:51 <Toxaris> > let even' 0 = True; even' n = odd' (n-1); odd' 0 = False; odd' n = even' (n-1) in even' <$> [0, 1, 2, 3] :: [Expr]
10:04:51 <lambdabot>  Couldn't match expected type `Expr' against inferred type `Bool'
10:05:12 <EvilTerran> skorpan, i've seen a^(3) to mean third-derivative of a
10:05:27 <EvilTerran> as distinct from a^3 just meaning a*a*a
10:05:28 <mrd> > map snd . filter (even . snd) . zip [1..] $ [a,b,c,d,e,f,g,h,i,j]
10:05:29 <lambdabot>  []
10:05:30 <Toxaris> hmm. why is there not class Bool to allow instance Bool Expr?  ;)
10:05:32 <oerjan> skorpan: a^{'3} (where ^{} indicates superscript)
10:05:32 <skorpan> good, then i'm not alone in this world.
10:05:41 <mrd> > map fst . filter (even . snd) . zip [1..] $ [a,b,c,d,e,f,g,h,i,j]
10:05:42 <lambdabot>  []
10:05:49 <mrd> > map snd . filter (even . fst) . zip [1..] $ [a,b,c,d,e,f,g,h,i,j]
10:05:50 <lambdabot>  [b,d,f,h,j]
10:05:55 <mrd> there, me is dumb
10:06:17 <skorpan> mrd: whaddya know, i actually understood that piece of code
10:06:23 <skorpan> it's pretty unusual for me
10:06:31 <mrd> i'd hope so, it's just composing some list functions
10:06:49 <mrd> > zip [1..] [a,b,c,d,e,f,g,h,i,j]
10:06:50 <lambdabot>  [(1,a),(2,b),(3,c),(4,d),(5,e),(6,f),(7,g),(8,h),(9,i),(10,j)]
10:07:02 <skorpan> no need to explain, i got it :)
10:07:09 <mrd> i know, i just like Expr
10:07:40 <mrd> > filterM (const [False ..]) [a,b,c,d,e,f] :: [[Expr]]
10:07:40 <lambdabot>  [[],[f],[e],[e,f],[d],[d,f],[d,e],[d,e,f],[c],[c,f],[c,e],[c,e,f],[c,d],[c,d...
10:08:15 <skorpan> time for monads...
10:08:20 <EvilTerran> Toxaris, i've thought of that, too
10:08:34 <EvilTerran> instance Bool (Maybe a) where bool Nothing = False; bool _ = True
10:08:35 <EvilTerran> etc
10:09:04 <EvilTerran> instance (Eq a, Monoid a) => Bool a where bool x = x /= mempty...
10:09:55 <mrd> > map snd . filter fst . zip (iterate not False) $ [a,b,c,d,e,f,g,h,i,j]
10:09:55 <lambdabot>  [b,d,f,h,j]
10:12:15 <oerjan> > catMaybes . zipWith ($) . cycle [const Nothing, Just] $ [a,b,c,d,e,f,g,h,i,j]
10:12:15 <lambdabot>  Couldn't match expected type `[Maybe a]'
10:12:19 <oerjan> argh
10:12:59 <oerjan> :t zipWith ($) . cycle [const Nothing, Just] $ [a,b,c,d,e,f,g,h,i,j]
10:13:00 <lambdabot>     Couldn't match expected type `a -> [a1 -> b]'
10:13:00 <lambdabot>            against inferred type `[b1 -> Maybe b1]'
10:13:00 <lambdabot>     In the second argument of `(.)', namely
10:13:07 <tromp> > map snd . filter (off. first) . zip [0..] $ [a,b,c,d,e,f,g,h,i,j]
10:13:07 <lambdabot>   Not in scope: `off'
10:13:23 <tromp> > map snd . filter (odd . first) . zip [0..] $ [a,b,c,d,e,f,g,h,i,j]
10:13:23 <lambdabot>   add an instance declaration for (Arrow (,))
10:13:40 <oerjan> fst
10:13:46 <tromp> > map snd . filter (odd . fst) . zip [0..] $ [a,b,c,d,e,f,g,h,i,j]
10:13:47 <lambdabot>  [b,d,f,h,j]
10:14:18 <oerjan> oh
10:14:27 <oerjan> > catMaybes $ zipWith ($) . cycle [const Nothing, Just] $ [a,b,c,d,e,f,g,h,i,j]
10:14:28 <lambdabot>  Couldn't match expected type `a -> [a1 -> b]'
10:14:49 <oerjan> > catMaybes $ zipWith ($) (cycle [const Nothing, Just]) $ [a,b,c,d,e,f,g,h,i,j]
10:14:49 <lambdabot>  [b,d,f,h,j]
10:16:14 <Toxaris> > map head . takeWhile (not . null) . iterate (drop 2) $ [a,b,c,d,e,f,g,i,j]
10:16:14 <lambdabot>  [a,c,e,g,j]
10:17:43 <smg> EvilTerran: :<
10:17:50 <EvilTerran> smg, er, what?
10:18:03 <EvilTerran> oh, the mutual recursion thing. don't worry 'bout it, poop happens :)
10:18:06 <smg> EvilTerran: you're right that it calls the prelude odd etc.
10:18:27 <smg> EvilTerran: i knew that it would not work, but i didn't know that odd/even are in the prelude so i was confused :]
10:18:55 <EvilTerran> surprise! it's a useful function, so someone's already implemented it in haskell :D
10:19:08 <Toxaris> @src even
10:19:08 <lambdabot> even n = n `rem` 2 == 0
10:19:08 <smg> hrhr
10:19:10 <EvilTerran> heck, Oleg's even implemented RSA in the typesystem, IIRC
10:19:27 <mauke> no, that was left as an exercise for the reader
10:19:46 <EvilTerran> oh, yeah. he's layed the foundations, tho.
10:19:50 <smg> mh `rem`
10:19:57 <smg> couldn't we use `mod` ? :)
10:20:30 <Toxaris> is even :: Int -> Bool really compiled to calls to rem and ==?
10:20:35 <oerjan> rem is supposedly more directly supported on CPUs
10:21:02 <smg> oerjan: ah okay
10:21:05 <smg> @src rem
10:21:05 <lambdabot> Source not found.
10:21:09 <smg> @type rem
10:21:10 <lambdabot> forall a. (Integral a) => a -> a -> a
10:21:13 <smg> @type mod
10:21:14 <lambdabot> forall a. (Integral a) => a -> a -> a
10:21:17 <smg> k
10:21:20 <oerjan> @src Integral
10:21:20 <lambdabot> class  (Real a, Enum a) => Integral a  where
10:21:21 <lambdabot>     quot, rem, div, mod :: a -> a -> a
10:21:21 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
10:21:21 <lambdabot>     toInteger           :: a -> Integer
10:21:48 <shepheb> but is there even a difference between mod and rem? where do they differ?
10:22:22 <nominolo> > ((-1) `mod` 3, (-1) `rem` 3)
10:22:22 <lambdabot>  (2,-1)
10:22:49 <shepheb> ah, fair.
10:22:54 <quicksilver> @check (\x y -> x `mod` y == (x `rem` y :: Int))
10:22:58 <smg> interesting
10:22:58 <lambdabot>  Exception: divide by zero
10:23:01 <quicksilver> heh
10:23:03 <EvilTerran> div finds the greatest integer less than the result of the division. quot finds the one nearest to zero. i think.
10:23:12 <quicksilver> @check (\x y -> y /= 0 ==>  x `mod` y == (x `rem` y :: Int))
10:23:13 <lambdabot>  Falsifiable, after 9 tests: 4, -6
10:23:14 <EvilTerran> and mod and rem fill out the obvious identity
10:23:26 <quicksilver> shepheb: quickcheck could have told you :)
10:23:52 <orzo> http://hpaste.org/6477
10:24:01 <orzo> dumb layout/syntax problem
10:24:14 <orzo> it was layout, but i converted it in order to try to get rid of parse errors
10:24:16 <byorgey> @check (\x y -> y > 0 ==> x `mod` y == (x `rem` y :: Int))
10:24:17 <lambdabot>  Falsifiable, after 4 tests: -1, 3
10:24:21 <smg> quicksilver: ==> ? :)
10:24:21 <EvilTerran> orzo, you need an else on that thar if
10:24:25 <byorgey> @check (\x y -> x > 0 && y > 0 ==> x `mod` y == (x `rem` y :: Int))
10:24:26 <lambdabot>  Arguments exhausted after 268 tests.
10:24:33 <smg> @type (==>)
10:24:34 <orzo> which one, EvilTerran
10:24:34 <lambdabot> forall a. (Testable a) => Bool -> a -> Property
10:24:47 <EvilTerran> the one that doesn't have one
10:24:51 <byorgey> smg: it lets you specify a precondition on quickcheck properties
10:25:07 <EvilTerran> if stringPrefix dataS s ...
10:25:11 <byorgey> smg: any generated test data which doesn't satisfy the precondition gets discarded.
10:25:13 <orzo> i'm allowed to omit else when an if is in the body of a do, right?
10:25:18 <EvilTerran> no
10:25:19 <quicksilver> orzo: nope.
10:25:26 <quicksilver> you're never allowed to omit else.
10:25:31 <EvilTerran> alternatively, you may want "when" or "unless"
10:25:35 <quicksilver> there is a combinator "when" which is a bit like an if, though :)
10:25:35 <byorgey> orzo: but you can say  'if blah then foo else return ()'
10:25:42 <byorgey> which may do what you want.
10:25:43 <quicksilver> @src when
10:25:44 <lambdabot> when p s = if p then s else return ()
10:25:46 <EvilTerran> ?hoogle Bool -> m () -> m ()
10:25:49 <lambdabot> No matches, try a more general search
10:26:10 <smg> byorgey: ah
10:26:14 <smg> byorgey: ty :)
10:26:53 <oerjan> :t when
10:26:54 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
10:26:56 <Toxaris> > EvilTerran: there is no if'
10:26:57 <lambdabot>   Not in scope: `if''
10:27:49 <EvilTerran> Toxaris, er, i never said there was...
10:27:50 <Toxaris> EvilTerran: ohh, I've read Bool -> m () -> m () -> m ()
10:28:04 <oerjan> orzo: i think your code could get more readable with guards instead of if-then-else
10:28:06 <EvilTerran> i was trying to get it to come up with when and unless at the same time
10:28:56 <resiak> with which of the ninety-five^W three XML libraries would it be most straightforward to parse a very simple tree, with about six distinct tags, for which there is no DTD?
10:29:05 <dmead> haskellers
10:29:06 <dmead> http://it.slashdot.org/article.pl?sid=08/03/18/1633229
10:29:07 <lambdabot> Title: Slashdot | What Programming Languages Should You Learn Next?
10:29:09 <dmead> pounce
10:29:38 <quicksilver> orzo: I agree strongly with oerjan.
10:29:40 <orzo> ok, oerjan, i'll do that
10:29:45 <quicksilver> orzo: guards FTW in that kind of case.
10:29:49 * EvilTerran goes to suggest befunge and intercal :P
10:29:54 <orzo> i was wondering what to do when i wrote it
10:30:07 <orzo> if else ... didn't seem very elegant
10:30:22 <Toxaris> EvilTerran: does hoogle work this way? by looking at it's output for Bool -> m a -> m a I have the feeling that it is willing to instantiate m, but not a
10:31:02 <oerjan> orzo: shall i annotate?
10:31:22 <Toxaris> orzo: case () of () | cond1 -> expr1 | cons2 -> expr2 ...
10:31:43 <oerjan> Toxaris: i don't think the () trick is actually necessary here
10:31:46 <Toxaris> orzo: in your case, you can even reuse the existing case
10:32:18 <oerjan> hm i will annotate
10:32:50 <Toxaris> oerjan: there is a trailing (>> loop ss) around
10:33:00 <oerjan> i just noticed it :(
10:33:20 <Toxaris> but i don't think it should be there
10:33:48 <oerjan> indeed
10:34:33 <orzo> hm?
10:34:40 <orzo> loop ss should be there
10:34:47 <oerjan> at the very end?
10:35:03 <oerjan> it would get called twice in some cases
10:35:31 <quicksilver> just after the final else, I think
10:35:45 <oerjan> orzo: should loop ss always be called at the end, in all cases?
10:35:58 <oerjan> (and just once)
10:36:57 <oerjan> orzo: hm i guess you are planning to fill in some of the other cases later?  otherwise it could be simplified a lot
10:38:28 <oerjan> i cannot rewrite it without knowing which loop ss should really be there or not
10:38:36 <orzo> i annotated with gaurds
10:38:40 <oerjan> ah
10:39:51 <lament> data types and values are the same thing!
10:39:55 * lament asplodes
10:40:16 * lament runs around drooling and speaking in tongues
10:41:28 <quicksilver> orzo: since you never consume more than one element, I think you could rewrite that whole thing as a mapM
10:41:43 <orzo> that's not true
10:41:50 <quicksilver> is it not?
10:41:51 <quicksilver> ah
10:41:54 <quicksilver> sorry, I missed it.
10:41:56 <quicksilver> gotcha.
10:42:16 <orzo> actually, that points out an error
10:42:22 <quicksilver> Do you really want ot call loop ss after that case, then ?
10:42:23 <quicksilver> :)
10:42:27 <desegnis> Hi all, I've started reading on Pierce's ‘Types and programming languages’ and I try to understand the notion of ‘run-time type errors’. Would, say, a DivideByZero exception in Haskell qualify as a run-time type error?
10:42:32 <orzo> no, quicksilver
10:42:39 <quicksilver> I suspected not.
10:43:07 <roconnor> desegnis: page?
10:43:11 <oerjan> orzo: what, the innermost one?
10:43:18 <quicksilver> desegnis: probably not, no
10:43:34 <quicksilver> desegnis: I haven't read that page, the but the kind of run-time type error he is probably talking about doesn't happen in haskell.
10:43:48 <quicksilver> desegnis: it would be something like "sqrt : error string found where number expected"
10:43:55 <desegnis> roconnor: page 3, chapter 1.1, two paragraphs after "if <complex test>"
10:44:02 <quicksilver> desegnis: such as you might get in a dynamic language if you wrote "sqrt('hello')
10:44:11 <quicksilver> desegnis: in a static language, such things are caught by the compiler.
10:44:21 <quicksilver> (which is the point, in a sense)
10:44:33 <desegnis> quicksilver: That's what I would think of if I just heard "run-time type error", as in dynamic languages
10:44:38 * quicksilver nods
10:44:51 <desegnis> quicksilver: But Pierce's notion seems to be different, that's why I asked
10:44:55 <oerjan> orzo: http://hpaste.org/6477#a2
10:44:57 <quicksilver> ah, sorry.
10:45:08 <orzo> annootated version 3 with corrections
10:46:04 <desegnis> quicksilver: I understand it like, we would want to catch this with a type system, but we cannot because of the limitations of the system.
10:46:09 <Peaker_> what are instances of (IO a) called? Are they called IO monads? Monadic values of IO?
10:46:15 <Peaker_> oops, not instances, values
10:46:21 <quicksilver> Peaker_: IO actions, typically
10:46:29 <ddarius> Peaker: The latter
10:46:39 <ddarius> IO actions or monadic computation is also common
10:46:45 <Peaker_> quicksilver, I thought actions are functions that return that
10:46:52 <mofmog> hmm it seems zippers take at least O(n) time where n is the depth to reconstruct a tree
10:46:52 <quicksilver> both
10:46:59 <Peaker_> I see
10:46:59 <quicksilver> Peaker_: IO a is an action with no parameters :)
10:47:02 <oerjan> orzo: corrected mine similarly: http://hpaste.org/6477#a4
10:47:05 <mofmog> whereas set-car! and set-cdr! simply work on the memory taking about constant time
10:47:08 <Peaker_> quicksilver, oh, indeed :-)
10:47:08 <quicksilver> Peaker_: b -> IO a is an action with one parameter
10:47:18 <quicksilver> Peaker_: once you've given it one parameter, it becomes and action with none :)
10:47:22 <Peaker_> quicksilver, Yes, I have some getting used to to do :)
10:47:24 <oerjan> oh wait darn
10:47:34 <mofmog> quick, i need an advantage of zippers over set-car! to justify their extra time constraints
10:47:47 <quicksilver> mofmog: sharing? undoing?
10:47:51 <ddarius> mofmog: Zippers support persistent data structures
10:47:52 <mofmog> ooh right
10:47:55 <quicksilver> mofmog: reasoning? bugfreeness?
10:47:59 <mofmog> haha
10:48:00 <mofmog> right right
10:48:19 <EvilTerran> mofmog, it takes the same O() to find the element to change when you're using set-*! as it takes to find the right element and reconstruct necessary element with zippers
10:48:34 <oerjan> orzo: my simplification doesn't quite work with all the different loop arguments i think
10:48:47 <Peaker_> and generally, values of the type  (Monad m) => (m a)  are monadic values?
10:48:59 <Toxaris> EvilTerran: but with a destructive data structure, you can keep various pointers into the data structure, but zippers only support one pointer.
10:49:09 <mofmog> EvilTerran: I'm implementing zippers in scheme
10:49:15 <quicksilver> Peaker_: yeah.
10:49:26 <quicksilver> Peaker_: (or actions, or computations)
10:49:28 <mofmog> the prof said that you need set-car! etc because the recursive versions would be harder
10:49:28 <desegnis> Peaker_: They are, and they are even generally called (monadic) actions/computations
10:49:34 <EvilTerran> Toxaris, well, that's true
10:49:34 <mofmog> but i'm making a posting saying otherwise
10:49:40 <mofmog> the conclusion will be
10:49:40 <desegnis> I'm too slow :)
10:49:48 <EvilTerran> let's put it this way: mutating data structures is premature optimisation :D
10:49:49 <mofmog> "Wait, but you have to define a new variable for every zipper!"
10:49:52 <mofmog> and i will retort
10:49:56 <orzo> oerjan, you must have meant dotOnwards instead of lines2 on the line just after recordEmail...
10:49:59 <mofmog> "Not if your language has monads. Oh wait. HAhAHAHAHAHA"
10:50:22 <Toxaris> how can a language not "have" monads?
10:50:28 <mofmog> well predefined
10:50:43 <oerjan> oh
10:50:47 <mofmog> also it implies you have to do it yourself
10:50:53 <EvilTerran> using mutable state is akin to manual garbage collection, as you need to keep track of which values you don't need any more
10:50:57 <Peaker_> Toxaris, does C have monads?
10:51:10 <oerjan> orzo: are you really sure you should have loop lines at the end?
10:51:24 <oerjan> oh wait
10:51:28 <oerjan> i'm stupid :)
10:52:02 * EvilTerran really quite likes that analogy. it's overstating it a little, but it works surprisingly well, imo
10:52:02 <oerjan> i'll do a new attempt based on your correction
10:52:26 <orzo> i'm not sure i'm happy with it in any case
10:52:40 <orzo> a mapM_ would be nifty
10:52:51 <orzo> or some way to avoid all these loop calls
10:52:56 <dcoutts_> Saizan: I'm fixing the strict read slightly differently
10:54:05 <orzo> i'm translating from a scheme implementation that accepted an event getter function rather than a list of lines
10:54:21 <b_jonas> which is why we have IORef and similar, which does automatic garbage-collection
10:54:42 <orzo> do you think it would be better to use IORef here?
10:55:27 <EvilTerran> b_jonas, you're still having to make a concious decision about what data to throw away
10:55:45 <b_jonas> EvilTerran: do I?
10:55:57 <b_jonas> I don't think so
10:56:04 <EvilTerran> although you can tell based on the types what's at risk of being affected by your decision
10:56:08 <EvilTerran> which makes things a *lot* simpler
10:56:21 <b_jonas> not more than with your typical garbage-collected procedural language
10:56:25 <EvilTerran> (namely, monadic actions)
10:56:36 <Saizan> dcoutts_: ok
10:56:39 <Toxaris> orzo: what about loop :: [...] -> IO [...], that is, loop returns the unhandled part of the input
10:56:51 <Saizan> dcoutts_: sent the patch for #40
10:56:58 <dcoutts_> Saizan: great
10:56:59 <EvilTerran> b_jonas, indeed. but the point of the analogy is that over-writing values in a procedural language is like doing garbage collection
10:57:20 <EvilTerran> it's an analogy. i'm not saying it *is* garbage collection, only that it requires similar mental juggling
10:57:25 <b_jonas> hmm
10:57:54 <b_jonas> dunno
10:57:58 <Toxaris> orzo: and then handleSMTP x = loop x >>= \x' -> when (not $ null $ x') $ handleSMTP x
10:58:00 <EvilTerran> "i don't need this value any more, i'll free the memory so i can re-use it" "i don't need this value any more, i'll over-write it so i can re-use the variable"
10:58:03 <Toxaris> orzo: or something like that..
10:58:17 <b_jonas> can't really think about that
10:58:42 <b_jonas> am now upset because they've removed the embedding interface from the new version of the J interpreter
10:58:46 <b_jonas> and I'm fussed about that
10:58:55 <b_jonas> how will my J evalbot work this way?
10:59:19 <oerjan> orzo: http://hpaste.org/6477#a5
10:59:27 <byorgey> b_jonas: oh, sad
10:59:30 <oerjan> (not related to your latest question)
10:59:59 <b_jonas> it's just stupid. would have taken nothing for them to keep it in the code.
11:00:25 <orzo> hm
11:00:32 <b_jonas> now I either have to figure out how the shared library interface works, or reimplement the J interpreter
11:00:42 <b_jonas> but the latter would take lots of time
11:00:53 <orzo> thanks, taxaris
11:01:02 <orzo> and oerjan
11:01:13 <oerjan> orzo: i made a small correction while rewriting
11:01:16 <sclv> oleg's scheme zipper: http://okmij.org/ftp/Scheme/zipper-in-scheme.txt
11:01:35 <EvilTerran> b_jonas, do it in haskell! :D
11:01:45 <oerjan> (it looked like loop lines2 would be called even when loop dotOnWards had been)
11:01:48 <orzo> i'm not sure putting all that in a where clause aids readibility
11:01:49 <orzo> heh
11:01:51 <b_jonas> EvilTerran: yeah, I started it in haskell this time
11:01:52 <sclv> its oleg-style (i.e. uses delimited continuations rather than the typical way)
11:01:59 <b_jonas> still, it's complicated
11:02:02 <b_jonas> lots of work
11:02:02 <oerjan> orzo: matter of taste i guess
11:02:09 <b_jonas> I can't finish it while writing my thesis
11:03:50 <orzo> what was your correction
11:04:06 <oerjan> orzo: btw even if you go with let you don't need one let per definition, you can separate them with semicolons like in the where
11:04:26 <oerjan> orzo: (it looked like loop lines2 would be called even when loop dotOnWards had been)
11:04:48 <oerjan> so i changed it to do loop lines2 instead of return () in the other branch
11:05:24 <skorpan> type GameState a b = ErrorT GameError (State (Game a) (GameResult a)) b
11:05:29 <skorpan> for some reason that gives me an error:
11:05:33 <orzo> i see.  I expect to use the function on an infinite list so i never bothered to consider returns from loop
11:05:36 <skorpan> Expected kind `* -> *'
11:05:42 <skorpan> i can't really figure it out
11:06:36 <sclv> "So after knowing those methodoligies perhaps you should study functional languages
11:06:37 <sclv> (LISP, SCHEME, HASCAL)"
11:06:39 <sclv> ?yow
11:06:39 <lambdabot> Don't SANFORIZE me!!
11:06:43 <oerjan> orzo: i see.  even if the list is infinite it could give stack problems since it wouldn't have been tail recursive
11:07:34 <b_jonas> HASCAL lol
11:07:38 <Toxaris> skorpan: I don't understand the State (Game a) (GameResult a) part
11:08:54 <skorpan> Toxaris: that's where it complains, but basically i want the "a" in "s -> (a,s)" to be "GameResult a" and the "s" to be "Game a"
11:09:33 <oerjan> afk
11:09:40 <Toxaris> skorpan: ErrorT want's a monad as second parameter (e.g. State (Game a))
11:09:48 <skorpan> ah!!!
11:10:02 <orzo> hm
11:10:09 <Toxaris> skorpan: I don't think you want that. the a may be used for various, game-unrelated types
11:10:26 <skorpan> so hum... i want: GameState a = ErrorT GameError (State (Game a)) (GameResult a) ?
11:10:32 <trez> :D
11:10:38 <skorpan> trez: :(
11:10:49 <orzo> i say haskell to sound simmilar to rascal but others around me all rhyme it with pascal
11:10:54 <Toxaris> skorpan: I assume that you want to GameState as a monad?
11:11:04 <orzo> am i saying it wrong?
11:11:22 <skorpan> Toxaris: no, not really
11:11:43 <byorgey> orzo: you are saying it correctly.
11:11:44 <skorpan> i just want to pass around a GameState data type, with the possibility of throwing errors
11:12:02 <damg> is it possible to create a list holding elements of the same instance(s), but different types?
11:12:17 <tromp> nope
11:12:21 <orzo> i wonder why everyone is so confident seeming when they say it their way
11:12:37 <orzo> and are not detered by teh way i say it
11:12:40 <orzo> heh
11:12:41 <damg> tromp: thanks for the info :-)
11:13:21 <tromp> you can have a type Eq a => [a], but the whole list has type a for some a
11:13:41 <tromp> i.e. you cannot have [Eq a => a]
11:13:51 <byorgey> damg, tromp: actually, you can =)
11:14:02 <byorgey> but it requires creating an existential wrapper type first
11:14:17 <tromp> yes, but the wrapper is then the common type
11:14:40 <byorgey> data EqThing = forall a. Eq a => a
11:14:45 <byorgey> then you can have [EqThing]
11:15:02 <byorgey> tromp: for sure, but it seems this is the answer to the question damg is really asking
11:15:16 <tromp> you left out data constructor
11:15:21 <byorgey> er, sorry, that should be something like
11:15:27 <damg> tromp: , yeah, I just wished I had (Integral a) => [x,y,z], where x is Int, y is Integral and z is e.g. Natural
11:15:37 <byorgey> data EqThing = forall a. Eq a => MkEq a
11:15:44 <Toxaris> skorpan: I don't understand what you mean, but I have to go anyway now. I have the feeling that you mix up what the m and what the a does in Monad m => m a, but I'm not sure.
11:16:06 <skorpan> okay
11:16:09 <byorgey> damg: so, you can do that, if you make an Integral wrapper
11:16:09 <Lemmih> join #happs
11:16:11 <skorpan> it compiled, but still i'm not sure
11:16:13 <Lemmih> Sorry.
11:16:29 <damg> great, thank you very much!
11:16:49 <byorgey> data IntegralThing = forall a. Integral a => MkIntegral a
11:17:11 <byorgey> then [MkIntegral (3 :: Int), MkIntegral (4 :: Integer)]  :: [IntegralThing]  is valid
11:17:45 <byorgey> damg: can I ask why you want to do that? =)
11:17:54 <tromp> of course you then have to define instance Num IntegralThing, which can be rather tedious
11:17:59 <damg> wanted to write a generic wrapper for my needs :)
11:18:03 <damg> er
11:18:07 <damg> ini wrapper
11:18:11 <damg> didnt say the key word :)
11:18:52 <damg> thought of holding reads and shows ... but it looks that it will become retarded while reading right now
11:21:30 <_andre> http://hpaste.org/6479  any hints on how to refactor this to avoid the repetition in the case statement?
11:22:47 <oerjan> _andre: move the where's out into a let just before the case
11:23:32 <_andre> but the "search" case is different
11:23:47 <orzo> does Data.ByteString come with ghc 6.8.2 ?
11:23:53 <oerjan> just merge the wheres
11:24:02 <oerjan> oh
11:24:04 <dcoutts_> orzo: yep in the bytestring package
11:24:20 <oerjan> well rename the clashing name
11:24:53 <oerjan> er there aren't any
11:25:18 <_andre> only "add" and "replace" are actually exactly the same
11:25:22 <oerjan> _andre: note that let and where are lazy.  there is no harm in defining something which is not used
11:26:35 <orzo> can i make ByteString literals?
11:27:29 <oerjan> orzo: there is an extension for it
11:27:31 <allbery_b> 6.8.x, overloaded strings
11:28:17 <oerjan> _andre: would uid:attr:[values] = args
11:28:20 <oerjan> argh
11:28:38 <oerjan> _andre: would uid:attr: ~[values] = args be good enough?
11:29:10 <_andre> what does ~[values] mean?
11:29:30 <oerjan> it means it doesn't check if that part actually is of that form unless you use values
11:29:39 <dcoutts_> orzo: or just use pack, on ghc there is an optimisation so that pack of a literal string does not go via a list
11:29:52 <oerjan> ~ is lazy (sub-)pattern
11:30:00 <_andre> hmm
11:30:05 <_andre> yeah, that could work :)
11:31:02 <_andre> btw, anyone ever done a vim colorscheme that highlights like hpaste does? :)
11:31:04 <oerjan> hm might need parentheses around ~[values]
11:31:04 <orzo> pack :: [Word8] -> ByteString
11:31:08 <orzo> that pack?
11:31:17 <orzo> it takes [Word8] instead of [Char]
11:31:25 <dcoutts_> orzo: no, the one from the .Char8 module
11:31:33 <dcoutts_> @hoogle String -> ByteString
11:31:33 <lambdabot> Data.ByteString.Char8.pack :: String -> ByteString
11:31:50 <oerjan> :t let uid:attr: ~[values] = "test" in (uid,attr)
11:31:54 <lambdabot> (Char, Char)
11:32:02 <oerjan> ah it's not necessary
11:33:19 <orzo> does lambdaboot use the same backend for hoogle as haskell.org/hoogle ?
11:34:15 <dmwit> Haskell.org and lambdabot each have a copy of hoogle.
11:37:58 <orzo> are items in non imported modules available via their fully qualified names even so?
11:38:25 <Saizan> orzo: no, that works only at the ghci prompt iirc
11:40:44 <mofmog> so i just implemented zippers in scheme, but it's absolutely unweildly without monads
11:40:45 <mofmog> hahaha
11:41:01 <mofmog> well they're more like binary tree zippers
11:41:30 <mofmog> here's a quote for posterity: " In a real *cough*haskell*cough* language that enforces actual data typing, this would be done for us ^_^"
11:41:47 <mofmog> in scheme i had to use tagged data
11:41:48 <mofmog> ugh
11:42:42 <dons> great talk from simonM just then about the new parallel gc.
11:42:59 <solrize> mmm parallel
11:43:00 <solrize> tasty
11:43:12 <solrize> chang/blelloch ?
11:43:49 <dons> simon&simon :)
11:43:54 <solrize> :)
11:45:05 <pete2> does anybody know why this overflows the stack when we ask for printing (by entering of y); I mean I used mapM_ so I do not care about the resulting list, so a tail optimization should happen, right?
11:45:05 <pete2> see http://hpaste.org/6480
11:45:51 <dons> how do you compile it?
11:46:03 <pete2> ghc --make -O2
11:47:15 <pete2> I did the test on windows (though hopefully there is no difference there)
11:50:30 <dons> iorefs eh?
11:50:43 <dons> what are all the new iorefs for?
11:50:46 <pete2> yeah; I wanted originaly to test that they are released
11:51:45 <pete2> I was not sure they are released when there is not reference to them any more; it looks like the iorefs are released but I got the stack overflow which I believe should not be there
11:52:56 <pete2> I tested the relesing by comparing with a modified version like this:
11:52:56 <pete2> change "mkIORefs rs' (ioref:ac) (i-1)"
11:52:56 <pete2> to "mkIORefs rs' [ioref] (i-1)"
11:52:56 <pete2> and comparing how memory ussage is changed
11:53:16 <mofmog> haha zippers are awesome
11:53:19 <mofmog> i just like
11:53:21 <mofmog> the idea
11:53:25 <mofmog> just thinking about zippers is cool
11:53:40 * mofmog has become too enthralled by data structures
11:53:52 <pete2> mofmog: :)
11:54:19 <mofmog> i find implementing stuff to be a better medium for learning than those stupid tutorials
11:55:25 <mofmog> haskell is basically derived from mathematical foundations and all of these tutorial writer keep ignoring the fact that most CS students took discrete math and linear algebra at best -_-
11:56:05 <mofmog> i guess i should take some sort of upper div topology class or something dang
11:56:35 <pete2> dons: do you think the stack overflow is there because of the iorefs? looks to me it should not depend on it but I did not try...
11:57:17 <roconnor> @go 1.5 lb in g
11:57:18 <lambdabot> 1.5 pounds = 680.388555 grams
11:59:53 <orzo> @hoogle fromForeignPtr
11:59:53 <lambdabot> Data.ByteString.Internal.fromForeignPtr :: ForeignPtr Word8 -> Int -> Int -> ByteString
12:02:53 <oerjan> pete2: i think the stack overflow is due to mkIORefs
12:03:06 <oerjan> and the splitAt.
12:04:29 <oerjan> try changing the last line to (mkIORefs $! rs') (ioref:ac) (i-1)
12:04:44 <oerjan> that forces rs' to be evaluated before you recurse
12:04:58 <pete2> oerjan: you mean all the splits are as thunks there; ok; I'll tryt; this looks good
12:05:13 <oerjan> actually you may want to evaluate x as well
12:05:40 <gwern> man. I need to increase irssi's scrollback. someone said something to me at some point, but dunno what
12:05:40 <lambdabot> gwern: You have 3 new messages. '/msg lambdabot @messages' to read them.
12:05:47 <oerjan> or something; randoms may have each value be a thunk of the previous
12:06:12 <tromp> u can check the archives, gwern
12:06:46 <orzo>     Couldn't match expected type `GHC.Word.Word8'
12:06:46 <orzo>            against inferred type `CChar'
12:07:04 <orzo> overly agressive type checking, heh
12:07:30 <orzo> @hoogle CChar -> Word8
12:07:30 <lambdabot> No matches, try a more general search
12:07:37 <gwern> tromp: but that is so troublesome
12:08:02 <gbacon> @ty compare `on`
12:08:04 <lambdabot> parse error (possibly incorrect indentation)
12:08:12 <gbacon> @ty (compare `on`)
12:08:12 <gwern> wonder if @messages only works in priv mesg
12:08:13 <lambdabot> forall b a. (Ord b) => (a -> b) -> a -> a -> Ordering
12:08:17 <gwern> @messages
12:08:18 <lambdabot> You don't have any new messages.
12:08:30 <gbacon> @ty on
12:08:31 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
12:09:18 <orzo> @hoogle ForeignPtr CChar -> CSize -> ByteString
12:09:18 <lambdabot> No matches, try a more general search
12:09:26 <wagle_home> @src on
12:09:27 <lambdabot> (*) `on` f = \x y -> f x * f y
12:09:30 <orzo> @hoogle ForeignPtr CChar -> Int -> ByteString
12:09:30 <lambdabot> No matches, try a more general search
12:09:40 <orzo> @hoogle ForeignPtr Word8 -> Int -> ByteString
12:09:40 <lambdabot> Data.ByteString.Internal.PS :: ForeignPtr Word8 -> Int -> Int -> ByteString
12:09:40 <lambdabot> Data.ByteString.Internal.fromForeignPtr :: ForeignPtr Word8 -> Int -> Int -> ByteString
12:09:50 <conal> gwern: thanks for the heads-up about reactive & TypeCompose being out of sync on hackage.  fixed now.  odd: i didn't get your patches.
12:10:08 <dcoutts_> orzo: what are you looking for?
12:10:24 <wagle_home> @pl  (*) `on` f = \x y -> f x * f y
12:10:24 <lambdabot> (line 1, column 12):
12:10:25 <lambdabot> unexpected "="
12:10:25 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
12:10:33 <orzo> i want an O(1) operation turning a ForeignPtr CChar into a ByteString
12:10:45 <gwern> conal: you didn't? I was sure I sent them. hum
12:10:55 <gwern> conal: well, I'll send again
12:11:02 <dcoutts_> orzo: it's in the Data.ByteString.Unsafe module
12:11:25 <conal> gwern: thx.
12:11:40 <dcoutts_> orzo: and you have to promise that the CChar really is immutable, and you need to worry about when it is finalised and you need to know the length up front
12:11:56 <orzo> i know the length
12:12:12 <gwern> how would I define a function name mixing infix and alphabetic characters? '(c++) foo = id foo
12:12:12 <gwern> is apaprently an error
12:12:38 <b_jonas> gwern: I don't think you can do that
12:12:49 <oerjan> gwern: you're not supposed to be able to
12:12:55 <dcoutts_> orzo: is the CString allocated with C malloc and so has to be free()ed ?
12:12:59 <b_jonas> except that there'a ghc extension that allows # in names too
12:14:02 <b_jonas> though you could define c and ++ separately in such a way that (c++) returns a function you want
12:14:18 <gwern> oerjan: why not?
12:14:31 <gwern> b_jonas: well, obviously I can't do it that way :) but I was hoping there was some way
12:14:36 <orzo> it's allocated with mallocForeignPtr or else it doesn't have to be freed
12:14:40 <oerjan> gwern: lexical analysis is context-free, so the splitting into tokens happens without looking at what is defined or not
12:14:50 <b_jonas> > let { c = (); ()++foo = id foo; } in (c++) 42
12:14:52 <lambdabot>  42
12:14:53 * gwern was pondering whether `c++` might work
12:15:01 <dcoutts_> orzo: ok so you can use unsafePackCStringLen which is O(1)
12:15:41 <oerjan> and there is no required space between alphabetic identifiers and operator identifiers in most cases
12:15:44 <b_jonas> this also means you can't define the Moses operator ~|_|~
12:16:12 <gwern> oerjan: ack! so 5 + 5 is seen as the same as 5+5? f.g is f . g? foo!!bar is the same as foo !! bar?
12:16:27 * gwern slays b_jonas for that bad joke
12:16:34 <oerjan> gwern: yeah, although the f.g case is more subtle
12:16:40 <orzo> that'll put me in IO
12:17:01 <b_jonas> gwern: it wasn't me. it's in some perl6 A/E/S
12:17:02 <gwern> @quote Moses
12:17:02 <lambdabot> No quotes match. :(
12:17:04 <conal> gwern: got it.  thx.
12:17:32 <gwern> oerjan: really? iirc, dots are also used for import statements but I can't think what else might make it subtler
12:17:44 <gwern> > 2 `(+)` 2
12:17:44 <lambdabot>  Parse error at "(+)`" (column 4)
12:17:50 <oerjan> gwern: module qualifiers, floating point come to mind
12:18:00 <orzo> i do not modify the string
12:18:05 <gwern> > 2 `mod` 2
12:18:05 <conal> gwern: oops -- i *did* see those notes but i mistakenly re-assigned them to my Haskell pile w/o looking.
12:18:06 <lambdabot>  0
12:18:07 <orzo> should i just use unsafePerformIO ?
12:18:23 <oerjan> gwern: the general rule is that tokens go as far rightward as possible
12:18:37 <gwern> oerjan: oh, you mean like 2.0? is it a number or two functions,,,
12:18:44 <gwern> > 2`mod`2
12:18:44 <lambdabot>  0
12:18:45 <orzo> the string is not intended to be modified after it is initialized
12:18:48 <oerjan> yeah
12:19:05 <gwern> conal: you naughty person. anyway, I have reactive patches, but I can't compile reactive because I can't compile wxhaskell(...)
12:19:11 <oerjan> although usually 2 is not a function, type classes allow you to make it one :)
12:19:19 <gwern> phooey.
12:20:10 <dcoutts_> orzo: sounds like you're making a bytestring extension lib, or something that's rather intimate with bytestring
12:20:19 <gwern> oerjan: so suppose I wanted to make ghci have spaces around infix stuff, so f.g was distinct from f . g; does anyone know of a way I'd go about it?
12:20:57 <gwern> conal: actually, did I send you the reactive patches? I may've, I stuffed it in my archive/ folder
12:21:02 <dcoutts_> orzo: so you're trying to build a bytestring in haskell code, what are you using to initialise it? are you calling some C function or doing it all in haskell?
12:21:12 <conal> gwern: yes.  i have them.
12:21:30 <oerjan> gwern: maybe a preprocessor?
12:21:46 <orzo> dcoutts_, i have embedded haskell in a c program that is calling the haskell code, passing in strings
12:21:52 <oerjan> there are flags for setting that, i think
12:22:10 <orzo> occassionally, the haskell code usess mallocForeignPtr and memcpy to remember data accross calls
12:22:24 <ziman> > (`div`) 8 2
12:22:24 <lambdabot>  Parse error at ")" (column 7)
12:22:29 <dcoutts_> orzo: so you're allocating the string on the haskell side, and calling to C to initialise the contents?
12:22:40 <oerjan> (modifying the actual lexer would probably require more work and compiling ghc i think)
12:22:50 <orzo> dcoutts_: yes, but it's just a memcpy
12:23:08 <DRMacIver> Is it just me or is the code for most of the collection classes in Data.* really hard to read? (It's probably just me. My Haskell is far too rusty)
12:23:14 <dcoutts_> orzo: ok so you know the size of the string up front.
12:23:18 <orzo> yes
12:23:36 <oerjan> > 3.5e+5 -- floating point makes lexing even more complicated than that
12:23:36 <lambdabot>  350000.0
12:23:42 <oerjan> gwern: ^^
12:23:46 <dcoutts_> orzo: so actually you're just making a copy of a C string of a known length
12:23:53 <orzo> yes
12:24:23 <dcoutts_> orzo: ok, easy, just use packCStringLen
12:24:53 <gwern> oerjan: wow. I have no idea haskell supported scientific notation
12:25:10 <gwern> > 2.45e20
12:25:10 <lambdabot>  2.45e20
12:25:14 <orzo> actually, the c code invokes the haskell code with pointers and lengths indicating chunks of a stream.  The haskell code interprets teh stream and breaks it into different logical chunks and so sometimes has to do a copy to remember partial-chunks across calls from c
12:25:27 <oerjan> > 0x1ff -- hex and octal too
12:25:27 <lambdabot>  511
12:26:22 <oerjan> > 2.45e20 :: Rational
12:26:22 <lambdabot>  245000000000000000000%1
12:26:25 <gwern> cool
12:26:38 <orzo> ok
12:27:02 <oerjan> > 1e-1000000 -- used to crash ghc
12:27:07 <lambdabot>  ghc: failed with error code 9
12:27:14 <oerjan> apparently still does :)
12:27:46 <gwern> oerjan: but I'm a little confused; a preprocessor parsing Haskell fancily could certainly reject any files or input which went f.g and not f . g, and make exceptions for 'c++', but that still doesn't get GHC to internally see the difference between 'c++' and 'c ++'. how could a preprocessor help?
12:28:10 <oerjan> gwern: i guess you would have to invent some mangling scheme...
12:28:32 <pete2> oerjan: that was it; there were unevaluated thunks because of the split; I did not realize that; thank you! and dons too
12:28:38 <b_jonas> heh
12:28:40 <oerjan> i am not sure that it would work of course
12:28:53 <b_jonas> would have to parse haskell I guess
12:29:00 <b_jonas> or maybe just lex it?
12:29:05 <gwern> oh noes. :( maybe I should go find a ghc guru and ask whether there's anyway to insert my own parser ino ghc or something
12:29:06 <b_jonas> I'm not sure
12:29:21 <gwern> does the standard actually say f.g is as licit as f . g?
12:29:26 <b_jonas> gwern: why not just make your own parser output haskell?
12:29:44 <b_jonas> gwern: I think so, by the longest token rule
12:29:45 <oerjan> > sin.cos $ 3 -- well, it is
12:29:45 <lambdabot>  -0.8360218615377305
12:31:06 <gwern> oerjan: I know in practice ghc accepts sin.cos, but I'm wondering whether I can skirt this by saying to the GHC devs 'your lack of adherence to the standard is breaking my shell program!'
12:31:14 <b_jonas> > let {-1 @ x = -x; } in -1 @ 3
12:31:14 <lambdabot>  Unterminated nested comment at "let" (column 1)
12:31:27 <oerjan> gwern: doubt it
12:31:49 <b_jonas> oh yeah, because -1 isn't a single token
12:32:18 <oerjan> the general rule is that space is only required if the first token would continue otherwise
12:32:41 <b_jonas> oerjan: that's a tautology
12:33:00 <b_jonas> better say "could continue" instead of "would continue"
12:33:06 <oerjan> very well
12:34:12 <oerjan> gwern: mind you there are some cases where ghc and others break the standard
12:34:19 <b_jonas> yeah
12:34:26 <b_jonas> like the hyerarchical module expansion
12:34:40 <oerjan> the standard says Just.if should parse as Just . if because if is a keyword
12:34:41 <dcoutts_> @seen Saizan
12:34:42 <lambdabot> Saizan is in #haskell-soc, #haskell-blah, #haskell-overflow and #haskell. I last heard Saizan speak 56m 16s ago.
12:34:42 <b_jonas> and the parsing rules for indents
12:35:01 <oerjan> but that is not supported in practice
12:35:08 <b_jonas> layout I mean
12:35:41 <oerjan> um that was not a comment on you.  btw gotta go
12:36:05 <dcoutts_> Saizan: I'm making some changes to the sdist. Sorry if you think that every time you send a patch I rewrite it, it's more that whenever we make changes to existing code it makes me notice how crap the existing code was and how it was screaming to be refactored.
12:40:55 <Saizan> dcoutts_: oh, well, no problem, it's true that i tend to make as little changes as possible to existing code
12:41:12 <dcoutts_> Saizan: aye, and generally that's a good thing :-)
12:41:23 <lispy> do any of you guys ever wish there was a library API for accessing darcs?  If so, what do you think the pros of such a library would be?
12:41:37 <dcoutts_> Saizan: btw, we cannot use withFile, it's new in 6.8, can't we just use BS.writeFile ?
12:42:15 <Saizan> dcoutts_: you just need to open the handle before entering in the inDir block
12:42:31 <dcoutts_> Saizan: and I tend not to like inDir :-)
12:42:42 <forkiliens> hi guys, i wanted to ask if there is any tool to write tutorials in haskell in html
12:42:42 <gwern> lispy: I think it'd be good, yes, I could see it being useful for a darcs-backed wiki
12:43:06 <lispy> gwern: what would you want it to do compared to just using darcs CLI?
12:43:10 <b_jonas> isn't there already one?
12:43:24 <b_jonas> I mean, there's one for other version control systems I think
12:43:26 <dcoutts_> Saizan: the current dir is a big ugly global variable, mutating it affects all other threads in the program. We should only use it when absolutely essential.
12:43:43 <lispy> b_jonas: there is no darcs API, only a darcs CLI
12:44:20 <lispy> b_jonas: but there is a libsvn
12:44:26 <gwern> lispy: for starters, I'd like to be able to use .darcs instead of _darcs; not making darcs a runtime dependency is another; avoiding the shell is always good; and I'm sure going through a library instead of 'revert [ynslkf]' is more flexible...
12:44:38 <b_jonas> lispy: yeah, that's what I thought of
12:46:01 <lispy> gwern: _darcs vs. .darcs seems a bit superficial to me, and probably wouldn't be addressed in a first version of libdarcs.  If you remove darcs as a runtime dependency, wouldn't you gain the dependency that you have to recompile your app for each darcs release?
12:46:25 <lispy> gwern: but I think you're right on about 'revert [ynslkf]' sort of stuff.
12:46:49 <b_jonas> isn't there a command-line switch to supress those prompts?
12:46:51 <lispy> gwern: which is more useful, a C binding or a direct Haskell binding?
12:46:54 <Saizan> dcoutts_: i see, i didn't think of multithreading there, pay attention to makeRelativeToCurrentDirectory in sanitizePath when you remove inDir
12:47:10 <dcoutts_> Saizan: right'o
12:47:14 <gwern> @where qthaskell
12:47:14 <lambdabot> I know nothing about qthaskell.
12:47:19 <lispy> b_jonas: yeah usually.  Darcs is very good about letting you pass the information on the command line
12:47:42 <dcoutts_> Saizan: what kind of testing did you use btw? if you've got anything then perhaps we should keep it in the tests/ dir somewhere
12:47:56 <gwern> 'Latest qtHaskell release: v1.1.1 (December 2007)'
12:49:04 <forkiliens> hi, i'm repeating my question, in case you overread it :)  : i want to write for self-educational purposes a tutorial in german about haskell. which tool do i use best?
12:49:34 <byorgey> forkiliens: I don't know of any specific tools for making Haskell tutorials.
12:49:56 <lispy> forkiliens: Do you know latex?
12:50:00 <byorgey> forkiliens: maybe your tutorial could be about creating such a tool, in Haskell of course.  And you could use the tool to write the tutorial about writing it.
12:50:01 <Baughn> forkiliens: Literate haskell? There will presumably be examples, and that way you could compile/test the same code that"s in your tutorial easily
12:50:06 <lispy> forkiliens: I suppose you could write the tutorial in literal haskell
12:50:23 <lispy> er yeah literate not literal
12:50:23 <gwern> @where qthaskell+ http://qthaskell.sourceforge.net/
12:50:23 <lambdabot> I know nothing about qthaskell+.
12:50:32 <Saizan> dcoutts_: nothing automated :(, just called createTarGzFile on some dir and checked that tar could extract the package, but i could write some using the reading side
12:51:00 <dcoutts_> Saizan: I wonder if we could compare it to the output of gnu tar
12:51:26 <gwern> lispy: I care about the aesthetics of my directories, and I hate _darcs - it's too easy for tools to mess with it. have you ever seen the arguments about why CVS/ is bad?
12:51:29 <forkiliens> i want to be able to write the code and my comments in the code should be the description of the tutorial (which should be in html)
12:51:30 <dcoutts_> Saizan: if we're byte for byte equal then cool, but I wonder if gnutar would be using file perms / owner etc that we're not
12:51:41 <Saizan> dcoutts_: not easily becuase of the semplifications in ownership/permissions
12:51:46 <forkiliens> is literate haskell the right thing to do this?
12:52:02 <Baughn> forkiliens: Yes
12:52:06 <gwern> as for speed, well, the first version maybe wouldn't - I looked and the darcs code is positively lousy with baked in _darcs
12:52:12 <Baughn> forkiliens: Combines easily with latex, too. ;]
12:52:19 <forkiliens> baugh: thanks
12:52:30 <gwern> but splitting between a lib and an executable is the first step to getting the configuration info out of the core functions
12:52:31 <forkiliens> baughn: :)
12:52:44 <gwern> lispy: dunno what you mean by c/haskell binding
12:52:54 <dcoutts_> Saizan: right, so perhaps the ideal unit test would have to untar with our untar code and compare the headers except for the owner or something
12:53:55 <lispy> gwern: would you interoperate with the libdarcs as if it were a Haskell library or some C code that you compiled against?
12:54:35 <gwern> b_jonas: there are things you can't do on the CLI which I think would be doable if you had access to the library. For example, I used to have a tool which everytime I made a typo in the shell, it'd save the correction, commit it to my .bashrc as an alias, and then have darcs record it with a canned message. no matter how I tried, I couldn't figure out *how* to get it to record only the last chunk in a file without using something stupid ...
12:54:36 <gwern> ... like expect (--all, sure, but not --last, --first, --second...)
12:54:45 <lispy> gwern: ask yourself this, what language would you use libdarcs from
12:54:46 <gwern> b_jonas: this was bad because I was often editing .bashrc and making *other* changes
12:55:10 <lispy> gwern: I think the configuration is out of the core already
12:55:21 <b_jonas> gwern: couldn't you have put those aliases in a separate file which you sourced from bashrc?
12:55:30 <gwern> eventually I gae up and changed it to put all the typos in .bash-typos; darcs was still recording all the changes to that particular file, but at least over or under recording was less likely
12:55:42 <gwern> @where+ qthaskell http://qthaskell.sourceforge.net/
12:55:42 <lambdabot> It is stored.
12:56:18 <gwern> forkiliens: if I myself were writing a haskell tutorial, I would go to Wikibooks and make my tutorial a subection or minitutorial of the existing haskell wikibook
12:56:25 <visof> hello
12:56:59 <b_jonas> could you not have saved a copy of bashrc just before adding the alias, and then commit the diffs from that copy?
12:57:10 <gwern> lispy: I think libsvn is a good argument for libdarcs. googling, it looks like a number of subversion tools use the library and not the CLI
12:57:41 <b_jonas> I can't really see how the library would have helped there
12:57:51 <lispy> gwern: yeah, I'm all for libdarcs, I just wanted to gather information about how others thought of it and get more informed about the general opinion.  Thanks for the feedback.
12:57:51 <Baughn> forkiliens: http://haskell.org/haskellwiki/Literate_programming
12:57:53 <lambdabot> Title: Literate programming - HaskellWiki
12:57:53 <b_jonas> how else would you have told it to save only the changed aliases at the bottom?
12:58:25 <gwern> lispy: well, being a haskeller, my code would be in haskell, so I guess I'd want it to be a haskell lib
12:58:32 <lispy> gwern: one HUGE problem with darcs on windows is that CLI on windows is stupid.  But, tortoise darcs is hard to write throuh the CLI interface.
12:58:37 <gwern> lispy: also, it can be hard to predict in advance what a library'd be used for. none of the xmonad devs expected such a huge XMonadContrib to arise; it was only possible because so much of xmonad is a library
12:59:24 <lispy> gwern: yeah, we have surprisingly little darcs-contrib.
12:59:41 <lispy> now and again people will comment they have one-off scripts and whatnot but we don't have an official contrib
13:02:20 <vegai> anyone written a static blog generator?
13:02:47 <Saizan> lispy: is darcs suitable to be extended via something like plugins?
13:03:43 <Baughn> Incidentally, does darcs have a 'delete all files that aren't in the repository' command?
13:04:01 <dbueno> Is there a way to get GHC to output any profiling information when I Ctrl-C the process?  The user's guide doesn't seem to suggest normal termination is required, but it doesn't address my question either.
13:04:28 <Baughn> dbueno: You could presumably install a signal handler tied to forcibly terminating the process
13:04:44 <Igloo> dbueno: What version? It ought to do so
13:04:55 <dbueno> Igloo: GHC 6.8.2
13:05:15 <dbueno> Baughn: A signal handler that catches SIGINT?
13:05:19 <visof> where can i download libreadline4.deb?
13:05:24 <dbueno> Or whatever signal Ctrl-C generates?
13:05:38 <Baughn> dbueno: Yes. If it makes your program exit cleanly, that should do it..
13:05:47 <dbueno> Igloo:  Huh.  It apparently *does* work.
13:05:56 <Baughn> dbueno: I suppose you'd have to use throwTo to make it work
13:05:57 <dbueno> Igloo: But I promise it didn't before....
13:06:06 * Baughn blinks
13:06:44 <dbueno> Was that a change from 6.8.1?
13:07:13 <Igloo> No
13:07:50 <vegai> I started toying with the idea: http://vegai.iki.fi/haskell/hasblog-1
13:08:30 <dbueno> Baughn, Igloo:  Thanks for the help, sorry for the noise.
13:08:33 <Saizan> dcoutts_: i just realized i forgot to add Hackage.SrcDist in Other-Modules.. (quite ironic)
13:09:02 <dcoutts_> Saizan: np
13:15:45 <gwern> lispy: heh. 'surprisingly little darcs-contrib'. yeah, I was actually thinking this recently looking at latexki
13:17:13 <Codex_> What kind of math do programmers need to write good code?
13:17:30 <gwern> lispy: anyway, are you filing a bug report/feature request for libdarcs?
13:17:52 <dmwit> Codex_: It depends on what you're writing, really, but typically discrete math is the first thing to get really solid.
13:18:30 <gwern> Codex_: basic algebra ~for refactoring and arithmetic is the bare minimum
13:19:27 <Codex_> I'm asking because I'm writing a math book for programmers and need to figure out what to write. :)
13:19:46 <Lemmih> Is there a way of speeding up darcs when download many small patches? I get an average download rate at 25KiB/s when getting a repo, but downloading a single file sustains a rate of 600KiB/s
13:20:01 <mrd> Category Theory, Topology
13:20:07 <Baughn> Lemmih: Yes, fix the pipelining support. ;]
13:20:12 <mrd> every programmer should get a PhD in Mathematics, too
13:20:14 <Baughn> Or add it, I'm not sure at this point
13:20:37 <dmwit> Codex_: Figure out what problem you want people to be able to solve at the end of your book, then write about the math it takes to accomplish that. ;-)
13:21:22 <Codex_> mrd: categories are definitely one of the topics I'm going to cover. But I'm not sure if I can write formal enough so I've been delaying the category part a little... :)
13:21:35 <gwern> mrd: come on, you want calculus first for graphics stuff and taking the derivatve of a data structure to get a zipper, or of regular expressions! :)
13:21:40 <xif> Hi
13:21:52 <gwern> Lemmih: bug the repo maintainer to add a checkpoint
13:21:55 <xif> I read somewhere that "Haskell researchers have recently shown how to implement a full object model as a Haskell library"
13:21:56 <mrd> well linear algebra anyhow
13:22:07 <xif> anyone knows what that refers to?
13:22:15 <mrd> oh you want abstract algebra for regexes of course.  algebraic automata theory.
13:22:53 <Lemmih> gwern: That's not very sustainable.
13:23:01 <lispy> gwern: there is a thread on darcs-devel at the moment about libdarcs (it comes up a couple times a year)
13:23:50 <lispy> gwern: It's something I would like to work on if someone doesn't beat me to it.  Right now I need to focus on wrapping up my masters, but when I get free time again it's on the list of improvements I'd like to make for darcs.
13:24:04 <lispy> I think it would make a decent SoC project too
13:24:10 <roconnor> @time mattam
13:24:11 <lambdabot> Local time for mattam is Tue Mar 18 21:22:34 2008
13:24:29 <gwern> xif: o'haskell, iirc
13:24:53 <gwern> or maybe OOhaskell? http://homepages.cwi.nl/~ralf/OOHaskell/
13:24:54 <lambdabot> Title: Haskell's overlooked object system
13:26:05 <skorpan> if i have a module where i import A and want the modules which import that module to also automagically get access to A, how do i do that?
13:26:58 <Lemmih> skorpan: module B ( module B, module A) where ...
13:27:22 <skorpan> oh... so it's as simple as that.
13:27:47 <monochrom> module B ( module B ( module B ( module B ( ....
13:27:53 <EvilTerran> yeah. in an export decleration, "module Foo" means "export everything i imported from Foo"
13:28:02 <xif> gwern: thanks, the guy claims there's a pure-haskell implementation, running on a standard Haskell compiler.
13:28:08 <EvilTerran> the default is "module Foo (module Foo) where", for when you don't specify one
13:28:24 <EvilTerran> (that's equivalent to "module Foo where"
13:28:27 <xif> (a pure-haskell implementation of fully-capable objects)
13:28:29 <gwern> lispy: it would; after darcs2 seems like a good time to consider restructuring
13:29:22 <gwern> Lemmih: not sustainable perhaps, but it does have the salutary benefit of encouraging maintainers to tag and checkpoint (and release) early and often (relative to activity)
13:31:13 <Lemmih> gwern: I'm trying to mirror the repositories on d.h.o but it seems darcs is responsible for most of the slow down.
13:32:21 <gwern> xif: well, I only know of o'haskell (by the MS guys iirc) and oohaskell (oleg), both of which were pure 'haskell' afaik
13:33:22 <xif> gwern: O'Haskell isn't pure haskell, it requires a special compiler, O'Hugs
13:34:54 <gwern> xif: oh, I didn't know that. strange. does o'hugs even run any more? I would expect not
13:35:45 <xif> gwern: last version was out on 2001
13:36:02 <xif> I'd guess not, any solution relying on a custom interpreter isn't very useful
13:37:29 <enticingjelly> can I somehow instruct ghc to look for the "Foo" module in a file called "foo.hs/hi" instead of "Foo.hs/hi"?
13:37:47 <gwern> I would tend to avoid special solutions, yes, but I suppose it allowed nicer syntax than oohaskell could deliver
13:40:15 <xif> gwern: interesting, looks like OOHaskell is indeed pure Haskell.
13:40:33 <xif> kudos to the Haskell language and its supporters!
13:41:43 <dons> kudos for all!
13:41:44 <gwern> xif: oleg prides himself on doing incredible things in pure haskell
13:41:49 <gwern> @olegfacts
13:41:49 <lambdabot> Unknown command, try @list
13:41:50 <dons> and for all, a kudo!
13:42:04 <gwern> @olegfact
13:42:04 <lambdabot> Unknown command, try @list
13:42:14 <lispy> gwern: it's not even a problem with the structure.  Eric restructured darcs to work more like it has a library driving it already :)
13:42:15 <gwern> Mm.... kudos
13:42:20 <gwern> @list
13:42:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
13:42:44 <xif> is that like Chuck Norris facts?
13:42:46 <mauke> @quote olegfact
13:42:47 <lambdabot> No quotes match. :(
13:42:47 <gwern> lispy: if it's already half done what makes you think it'll be an entire SoC?
13:43:05 <gwern> huh. what happened to the oleg facts?
13:43:12 <gwern> @quote oleg
13:43:13 <lambdabot> edwinb says: where does 'Oleg cornered me in a pub and explained delimited continuations to me' fit in?
13:43:29 <lispy> gwern: building the C bindings and making sure the api works plus making it comfortable/easy to use and writing up documentation is quite time consuming
13:43:31 <gwern> @quote oleg
13:43:31 <lambdabot> vincenz says: we need a flag like "ghc --I-am-oleg"
13:43:42 <gwern> nice
13:43:45 <gwern> @quote oleg
13:43:45 <lambdabot> simonpj says: Maybe if I had an Oleg implant I could express all this in the type system
13:44:10 <gwern> lispy: why are there c bindings to it? that doesn't seem very essential to me
13:44:11 <gwern> @quote oleg
13:44:11 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
13:44:41 <xif> interesting, so advanced Haskell is the norm today?
13:44:43 <lispy> gwern: It's not essential, but it would be important to the long term success of libdarcs I believe.
13:45:13 <monochrom> The standard is always raised.
13:45:30 <gwern> xif: I think so. I've seen many projects using funky extensions, and the older the project, the closer to haskell98 they seem to be
13:45:33 <gwern> @quote oleg
13:45:33 <lambdabot> vincenz says: we need a flag like "ghc --I-am-oleg"
13:45:36 <lispy> gwern: a C binding enables many languages to use the library.  Which means python hackers, perl hackers, C/C++ hackers, etc could all start contributing.
13:45:50 <gwern> phooey. I guess we lost all the oleg facts then
13:45:55 <gwern> damn lambdabot's crappiness!
13:46:11 <monochrom> Many extensions are no longer funky.
13:47:03 <gwern> monochrom: all extensions one doesn't understand are funky
13:47:23 <mrd> not if you specify -fno-funk
13:47:37 <lispy> ghc -fglasgow-exts -fno-funk
13:47:55 * gwern facepalms
13:47:55 <mrd> of course, GHC is much cooler with the funk
13:48:13 <lispy> GHC has some sexy extensions
13:48:24 <lispy> I can't imagine doing real world haskell in anything else
13:48:38 <monochrom> Examples of pretty sane, safe, useful extensions: higher-rank polymorphism, existential types, (oh oops that's redundant :) ), ...
13:49:22 <lispy> aren't most ghc extensions for the type system?
13:49:25 <monochrom> MPTC is the difficult story. It's well-understood and useful, but I think we still need to decide how much of logic programming we want it to resemble.
13:50:03 <lispy> isn't MPTC going to be a thing of the past if associated typeclasses are implemented?
13:50:09 <lispy> (was AT even the right name??)
13:50:20 <johnnowak> to what extent is inference possible for rank-2 types in ghc?
13:50:35 <lispy> ghc can do rank-n types, but requires more type signatures
13:50:50 <lispy> I think, rank-2 has been supported for a very long time in ghc
13:50:50 <johnnowak> i know, but i believe it has separate rank-N and rank-2 option
13:50:53 <dons> johnnowak: well, ST-based code using rank-2 is inferrable all over the place
13:51:04 <dons> but check the user's guide
13:51:05 <monochrom> I think I know less than you do here.  I think you're right, it may give a nice story.
13:51:21 <johnnowak> thanks dons
13:53:20 <mrd> type inference is possible for rank-2 polymorphism
13:53:28 <mrd> there's a paper somewhere proving it
13:55:18 <enticingjelly> @t liftIO
13:55:18 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
13:55:31 <enticingjelly> :t liftIO
13:55:32 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
13:56:16 <dons> i'm not sure its always inferrable in ghc, but it at least acts as if it is :)
13:56:24 <dons> there may be some corners i've not run into
13:58:12 <monochrom> ghc finishes in a short time for me, and my program finishes in a short time too.  in practice anyway. :)
14:02:00 <ziman> @thanks
14:02:00 <lambdabot> you are welcome
14:02:03 <ziman> :)
14:03:27 <Peaker> do any of you have some SDL program examples?  Or other GUI stuff/ I am wondering about good ways to write event-driven code in Haskell
14:04:08 <sm_> howdy gwern.. around ?
14:04:38 <skorpan> i'm using monads! yay!
14:05:20 <dcoutts_> Peaker: gtk2hs has a number of demo programs
14:05:25 <sm> the fungen author is debating X11, LGPL (like HOpenGL) and GPLv3. which should he use ?
14:05:51 <Peaker> dcoutts, is it trying to remain similar to Gtk+'s API, or does it Haskellize it a lot? :)
14:06:02 <dcoutts_> Peaker: both! :-)
14:08:55 <Peaker> is there a lot of work being done about proving the correctness of Haskell programs?
14:09:13 <Peaker> or at least, their purely functional part
14:09:22 <monochrom> sm: What are the restrictions of X11 on users, copiers, re-sellers, ...?  IIRC it is the least restrictive among the three, so I suggest using it.
14:09:43 <Peaker> cabal list  shows "soegtk",  is that a name for gtk2hs?
14:09:47 <Twey> X11 is basically just new-style BSD, as I understand it.
14:10:26 <dcoutts_> Peaker: no, that's a package that uses gtk2hs. gtk2hs is not on hackage yet because we need a few more improvements to Cabal before we can use Cabal to build it.
14:10:31 <dcoutts_> @where gtk2hs
14:10:31 <lambdabot> http://haskell.org/gtk2hs/
14:10:38 <Peaker> dcoutts, oh, thanks
14:10:42 <dcoutts_> Peaker: you can get it from the homepage ^^
14:11:02 <Peaker> so I need to manually install both gtk2hs and cairo?
14:11:37 <dcoutts_> Peaker: gtk2hs consists of several components, including the cairo bindings, it'll install all of them that can be built on your system
14:11:55 <Peaker> oh, ok
14:12:59 <Peaker> I guess I can install the Ubuntu package? I didn't notice it but one exists
14:13:15 <dcoutts_> Peaker: yep
14:22:56 <Laney> Anyone got a link to that decent monad transformer tutorial that was around a couple of weeks ago?
14:26:15 <lispy> Laney: this one? http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
14:26:15 <lambdabot> Title: Monad Transformers Step by Step
14:27:39 <Peaker> Haskell documents are always in PDF eh?
14:27:55 <lispy> isn't functional reactive style also a way to do event stuff in Haskell?
14:28:14 <lispy> Peaker: PDF is a common format for research papers
14:28:27 <lispy> and many Haskellers are researchers or graduate students
14:30:03 <Laney> lispy: No, I find that one a bit confusing. I think it was written in the last month or so. Sorry I can't be more specific :(
14:30:36 <Riastradh> Most (reasonable) academic documents are either in PDF, PostScript, or DVI...
14:31:46 <lispy> Laney: do you remember who the author was?  Maybe someone like Cale wrote it?
14:32:34 <bos> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
14:32:39 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
14:33:38 <wagle_home> thats not the one i saw..  thought i bookmarked it, but didnt
14:33:52 <bos> that's the best of them, though.
14:35:05 <lispy> Laney: have you tried searching the channel log?
14:35:40 <Laney> lispy: Yeah, I'm doing it now. I think it used a similar example to the one you linked, but written in a clearer way IMHO.
14:35:43 * Laney carries on looking...
14:35:52 <wagle_home> lispy: search for what?  "monad transformer"?  har har
14:37:14 <lispy> wagle_home: yeah, not ideal is it
14:37:42 <wagle_home> 8)
14:37:45 <wagle_home> yeah
14:44:37 <lispy> Cale: I work with traffic engineers and they always say, it's Amber not Yellow ;)
14:52:57 <dmwit> > (13 * 600 + 4 * 450 + 4 * 240 + 4 * 100, 8 * 600 + 10 * 450 + 5 * 250 + 100)
14:52:59 <lambdabot>  (10960,10650)
14:54:18 <mjf> How much Gofer language differs from Haskell? I found http://www.cs.uu.nl/people/jeroen/courses/fp-eng.pdf this one PDF which looks quite fine to start learning from it and Gofer codes in it looks pretty similar (visually) to what I know Haskell looks like. I wanna know if it's really so similar...
14:54:46 <ddarius> hugs stands for "Haskell Users Gofer System"
14:54:59 <mjf> ddarius: eh?
14:55:03 <mjf> ddarius: Can you exmplain?
14:55:13 <mjf> ddarius: explain
14:55:37 <mjf> ddarius: HUGS - one of Haskell interpreter?
14:56:00 <ddarius> Gofer was an experimental Haskell-like language.  Everything it innovated on has since been folded into Haskell, either in the standard or in the implementations.
14:56:43 <mjf> ddarius: So, I will be able to run the codes in the PDF in, say, ghci?
14:57:25 <ddarius> The libraries aren't identical, but the language should be more or less a subset of Haskell (with extensions)
14:57:34 <mjf> ddarius: OK
14:57:39 <mjf> ddarius: Thanks.
15:02:58 <bos> @users
15:02:58 <lambdabot> Maximum users seen in #haskell: 464, currently: 454 (97.8%), active: 13 (2.9%)
15:03:08 <adiM> @pl atIndex a i -> a ! i
15:03:08 <lambdabot> (line 1, column 13):
15:03:08 <lambdabot> unexpected ">" or "-"
15:03:08 <lambdabot> expecting variable, "(", operator or end of input
15:03:16 <adiM> @pl atIndex a i = a ! i
15:03:16 <lambdabot> atIndex = (!)
15:03:42 <lispy> what is a rigid type context?
15:03:48 <byorgey> adiM: you can turn infix operators into prefix functions by enclosing them with parentheses.
15:04:23 <lispy>     A pattern type signature cannot bind scoped type variables `x'
15:04:23 <lispy>       unless the pattern has a rigid type context
15:04:32 <byorgey> lispy: one that isn't wobbly
15:04:45 <lispy> byorgey: oh! *facepalm*
15:05:28 <byorgey> lispy: I'm actually being serious, but unfortunately I don't remember/understand what wobbly types are
15:05:33 <byorgey> @go wobbly types
15:05:34 <lambdabot> http://citeseer.ist.psu.edu/jones04wobbly.html
15:05:34 <lambdabot> Title: Wobbly Types: Type Inference for Generalised Algebraic Data Types - Jones, Washb ...
15:06:19 <lispy> byorgey: oh, you weren't making fun
15:06:38 <ddarius> The opposite of rigid is flexible.
15:06:46 <ddarius> Wobbly is something else altogether.
15:06:47 <gwern> sm: tell him X11 (it's a lot like BSD, and works with GPL), gplv3, lgpl in that order
15:06:53 <byorgey> oh, sorry
15:07:12 <byorgey> lispy: no, I wasn't making fun, although I did purposefully answer in a way that would *sound* silly =)
15:07:12 <Riastradh> gwern, are you suggesting that the 3-clause BSD licence is incompatible with the GPL?
15:07:35 <byorgey> but apparently I wasn't correct anyway.
15:07:39 <ddarius> The terminology almost certainly comes from unification algorithm/logic programming stuff.
15:07:47 <Peaker> is the reason we need "where" in addition to "let" because   "where" can apply to more than an expression's scope?
15:07:56 <gwern> Riastradh: bsd3 wasn't an option sm listed
15:08:01 <mauke> we don't need where
15:08:08 <Riastradh> gwern, which was meant by `BSD', then?
15:08:16 <Heffalump> Peaker: yes, where applies to a group of definitions
15:08:19 <Peaker> mauke, can any instance of "where" be replaced with "let" that is pretty much equivalent?
15:08:20 <ddarius> Peaker: We don't -need- where, but there are things that would require restructuring to do with let.
15:08:24 <mauke> Peaker: yes
15:08:30 <Heffalump> or rather, a single definition with multiple guards
15:08:30 <ddarius> no
15:08:39 <gwern> if I had my druthers, everything would be public domain until a company stole it and then you'd license as GPLv3 (or maybe affero...)
15:08:41 <Peaker> but wouldn't a single "where" become multiple "let"s?
15:09:04 <ddarius> None of them, technically, are interreplaceable.  One is a declaration, the other is an expression.  They aren't even the same syntactic class.
15:09:51 <Peaker> ddarius, most examples of "where" that I see seem to be convertible to a "let" inside the expression it applies to?
15:10:00 <edwardk> peaker: not quite, as i recall where clauses scope over pattern guards and let clauses are scoped within the guard
15:10:03 <dolio> If you have guards on a function, you could move them inside a let by using a case with guards.
15:10:21 <Peaker> that clears it all up, thanks.
15:10:41 <edwardk> that and where tends to be easier on the eyes ;)
15:10:57 <Peaker> I think it could be nice to reduce the conceptual size of Haskell and have just let/case-pattern-matching, rather than let/case/func-pattern-match/where
15:11:17 <esteth> hm. my rather simple implementation of a factorial function and the infinite list of all factorials is: "fac 1 = 1; fac n = n*(fac(n-1)); facs = [fac x | x < [1..]]" However, this list isn't infinite in practice due to stack overflow. Is there a way to define the facs list in terms of itself, so that i only need to multiply by the previous number in the list?
15:11:20 <bos> but they're all so handy.
15:11:33 <Riastradh> Peaker, neither function pattern clauses nor `where' increases Haskell's conceptual complexity.
15:11:41 <lispy> Peaker: most code in the wild seems to prefer 'where' over 'let' though
15:11:46 <mauke> :t scanl
15:11:46 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
15:11:49 <Riastradh> Peaker, they increase only the complexity of the description of its notation.
15:12:04 * dolio suspects that where/function pattern matching/etc. lead to less indentation.
15:12:26 <lispy> Riastradh: in some language extensions, 'where' does increase the complexity when compared to pattern matching
15:12:33 <edwardk> peaker: they get desugared into the same thing in the end you only have cases. they increase surface syntactic complexity, but in the end the don't affect the complexity of the core language
15:12:38 <edwardk> i like sugar, its sweet ;)
15:12:41 <mauke> > scanl (*) 1 [1 ..]
15:12:42 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
15:12:57 <Riastradh> lispy, the conceptual complexity -- the complexity of the concepts in program in Haskell?
15:13:13 <Peaker> edwardk, Riastradh, lispy: well, I know that the variety of equivalent syntaxes is making entry into Haskell more difficult (for me and friends of mine, at least)
15:13:32 <Peaker> and keeping where is fine, but both let and where seems redundant
15:13:33 <esteth> mauke: Oh, that's a lot simpler than i was thinking :)
15:13:36 <lispy> Riastradh: yes.  There are some patterns that cannot be expressed in 'where' but can be expressed in pattern matches (like in do-notation) when using existential types
15:13:39 <esteth> mauke: thanks
15:13:53 <byorgey> > scanl f a [b,c,d]
15:13:54 <lambdabot>  [a,f a b,f (f a b) c,f (f (f a b) c) d]
15:14:01 <Riastradh> lispy, does that imply that the introduction of `where' increases the number of concepts?
15:14:12 <lispy> Riastradh: have you ever seen GHC tell you that it's brain just exploded?
15:14:15 <edwardk> peaker: the problem is there are a couple of schools of thought on how one should write functional programs. one is more ml like with the separate patterns in cases, one is more declarative with a bunch of separate statements. haskell at the time it was designed was very careful to not pick sides
15:14:23 <lispy> its*
15:14:24 <mauke> @quote explode
15:14:24 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
15:14:36 <Riastradh> lispy, nope, but such an error message wouldn't surprise me!
15:14:43 <Peaker> edwardk, that sounds like a very superficial difference, hardly justifying a whole "school of thought" ...
15:15:10 <edwardk> peaker: well, each side firmly believes they are right and that the other looks hideous ;)
15:15:11 <byorgey> you have to be doing semi-esoteric stuff with existential types to get that error message...
15:15:31 <lispy> Riastradh: I don't fully understand the problem, but it has to do with the polymorphic nature of let/where and that you could potentially export an existental type
15:15:41 <Peaker> edwardk, Given that translating between one another is so trivial, it seems pretty superficial
15:15:42 <lispy> Riastradh: so to me, that does increase the concepts
15:15:45 <edwardk> remember haskell came about originally when god and everyone was trying to come up with a lazy language
15:15:59 <bos> what?
15:16:00 <Riastradh> lispy, is that *different* with `where' from `let'?
15:16:14 <edwardk> peaker: hence why haskell ultimately decided to allow all of the forms and to just desugar them down into a simple internal representation that didn't care about the surface syntax
15:16:17 <ddarius> edwardk: There isn't another side, not within the Haskell community.
15:16:19 <lispy> byorgey: this happens to me a lot in real code actually :)
15:16:23 <Riastradh> lispy, Peaker was concerned originally about adding anything beyond `case' and `let'.
15:16:27 <Peaker> scanl = foldl ?
15:16:30 <byorgey> lispy: that's because you work on darcs!
15:16:45 * byorgey takes a wild guess
15:16:57 <Peaker> @src scanl
15:16:57 <lambdabot> scanl f q ls = q : case ls of
15:16:57 <lambdabot>     []   -> []
15:16:57 <lambdabot>     x:xs -> scanl f (f q x) xs
15:17:00 <Peaker> @src foldl
15:17:00 <lambdabot> foldl f z []     = z
15:17:00 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
15:17:05 <Peaker> those seem equivalent
15:17:06 <byorgey> Peaker: scanl is like a foldl that accumulates all the intermediate results.
15:17:09 <lispy> byorgey: ya, you are right, but I dunno.  I'm not sure darcs should be considered esoteric since it's one of the big real-world haskell examples :)
15:17:09 <tromp> scanl is list opf partial folds
15:17:15 <Peaker> perhaps one is from ML's "school of thought" and the other from the other :)
15:17:22 <byorgey> Peaker: foldl just returns a single value, which would be the last element of the list returned by scanl
15:17:24 <Peaker> oh, ok, thanks
15:17:30 <edwardk> peaker: no, ml has both of those
15:17:45 <byorgey> lispy: by 'semi-esoteric' I meant that someone learning the language would not be likely to have encountered it =)
15:17:47 <mauke> Riastradh: http://hpaste.org/6101
15:17:52 <edwardk> peaker case is for inspecting a value. let is for binding a value for repreated reuse
15:18:11 <monochrom> "f x | even x = y | odd x = y \n     where y = x+1"  If you try to rewrite this with "let", you must also abandon the nice "|" and use if-then-else.  Imagine if you have a million cases rather than just 2 here.
15:18:24 <lispy> Peaker: I think of it like this; you want to keep things simple conceptually, but at the same time you have to balance convenience with simplicity so people will be able to use the language comfortably.
15:18:32 <Peaker> edwardk, Yeah, I know - case<->func-pat-match  seem redundant, as well as  let<->where.   where's appearance AFTER the things that depend on it is also confusing
15:18:32 <edwardk> case doesn't give you a name to repeatedly reuse the term unless you cheese and do something like case foo bar baz of x -> ....
15:18:43 <edwardk> in which case you have really obscured the reason for using a case in the first place
15:18:50 <Peaker> lispy, I wish I had a shortcut key that shows it to me the way I like it :-)
15:18:59 <edwardk> and let is useful for mutually recursive bindings
15:19:07 <Peaker> lispy, rather than hard-coding this presentational thing into the program description itself...
15:19:37 <monochrom> Err, nevermind, "f x = let y = x+1 in case x of x | ... | ..." does it.
15:19:54 <lispy> Peaker: when you've designed PVPL 1.0 (Peaker's Visual Programming Language 1.0) then you can do this
15:20:21 <monochrom> Ha, I come up with another example.
15:21:07 <lispy> I think the placement of let/where was probably based on how those words are used in math texts
15:21:28 <monochrom> "f (x:xs) | even x = y | odd x = y++y \n    where y = tail xs"  this one is harder.
15:21:29 <lispy> In my experience, you adapt to their placement pretty quickly.
15:22:44 <monochrom> This one you can use two stages of pattern matching, but it gets ugly.  "f (x:xs) = let y = tail xs in case x of x | even x ... | odd x ..."
15:22:51 <Peaker> lispy, there is a lot of confusion revolving around "non-textual programming". Non-textual means that the program is not serialized to a textual format - it does not mean the editor is necessarily "graphical". It can look like text presentationally
15:23:20 <monochrom> So, "where" simplifies a lot of things.
15:23:54 <lispy> Peaker: Similarly, there is a lot of confusion over the definiton of visual language and what people mean by "software visualization".  But, as an ex-researcher in those areas, I assure you, there is a LOT of overlap between your ideas and those areas.
15:24:20 <lispy> Peaker: it would be in your best interest to become familiar with them :)
15:24:29 <monochrom> "Can programming be liberated from the Plain Text File?"
15:24:49 <ddarius> monochrom: Yes.  Will it?  Yes.  When?  Not now.
15:25:49 <lispy> Peaker: some VPL researchers would even consider a completely sound based language to be a VPL because to them the "visualization" is in your mind not in the presentation
15:25:51 <dolio> "f (x:xs@(~(_:y))) | even x = y | odd x = y ++ y" :)
15:26:27 <monochrom> "f (x:xs) | even x = y | odd x = y++y \n    where y = g xs"
15:26:29 <dmwit> Wait, what's wrong with textual languages?
15:26:37 <dolio> Aww. :)
15:26:43 <lispy> dmwit: correct
15:27:01 <dolio> monochrom: Give me some view patterns and I'll get you (maybe). :)
15:27:11 <Peaker> lispy, what research have you done in the area?
15:27:31 <dolio> Actually, probably not.
15:27:46 <Cale> dmwit: Well, there are some really cool things you can do if the language is more than textual. I rather like Subtext 2's tables.
15:28:00 <lispy> Peaker: I worked for a while on a VPL that IBM was creating for webservices and I published a paper about using cognitive dimensions to analyze VPLs
15:28:02 <dmwit> f xs = concat . replicate (head xs `mod` 2) . g $ tail xs
15:28:10 <monochrom> If pattern matching is so generalized as to accept arbitrary functions, Haskell will be called a Pattern Matching Language. :)
15:28:15 <Peaker> lispy, cognitive dimensions?
15:28:22 <ddarius> @google pattern calculus
15:28:25 <lambdabot> http://www-staff.it.uts.edu.au/~cbj/Publications/purepattern.pdf
15:28:44 <lispy> Peaker: it's a framework propose by some psychologists for discussing the cognitive aspects of languages
15:28:45 <dmwit> Cale: I rather dislike Subtext's UI that requires switching between mouse and keyboard for every interaction.
15:29:02 <Peaker> lispy, psychologists? Oy vey :-)
15:29:14 <Peaker> lispy, I agree with Dijkstra about psychologists :)
15:29:21 <lispy> Peaker: and what did he say?
15:29:22 <monochrom> dmwit: Note that your code has different strictness.
15:29:46 <dmwit> monochrom: Also, it gives a different answer. ;-)
15:29:53 <kpreid> dmwit: Subtext is available?
15:29:57 <lispy> Peaker: it's better than psychologists do the human aspect of HCI than it is having so many CS people do it.  I really hate it when CS researchers do the human study portion.
15:29:58 <Cale> dmwit: Well, that's perhaps something which can be improved by shortcut keys. I don't tend to mind switching between mouse and keyboard though. Typing should never be the majority of time spent working on code.
15:30:05 <dmwit> monochrom: ... replicate (1 + (head xs `mod` 2)) ...
15:30:24 <Peaker> lispy, IIRC, that naming computer science with a bunch of differing terms ("Its the new electrical engineering", "its the new X") brought invitation of all kinds of people, including psychologists, that had nothing to contribute to the field
15:30:56 <lispy> Peaker: psychologists do have something to contribute, and have contributed something.
15:30:56 <Peaker> lispy, I can relate to that if you're designing a word processor or a web page - but when designing a UI for programmers, programmers are probably the best humans to judge whether or not its comfortable for them
15:31:20 <dmwit> Cale: I find that, although it isn't the majority, it does require some "flow".  That is, think for 5 hours in a row, then code for a straight hour.  In that hour, I don't want to be messing around, I want to Get It Done.
15:32:02 <dmwit> kpreid: I don't actually know, I'm just going by the screen-cast.
15:32:16 <monochrom> Do not forget that  programmer's habit <-> programming environment   is a two-way street.
15:32:21 <lispy> Peaker: It's perfered to study your target user group, regardless of what you want to make :)
15:33:10 <Peaker> monochrom, I think some people (not all), and I hope/believe I am one of them, can put aside my habits, and think about what would be efficient, in objective terms such as "minimal amount of key presses", "minimal feedback required from computer", etc
15:33:10 <kpreid> dmwit: I'm not exactly disagreeing, but something I've noticed: using a laptop (trackpad in front) reduces the cost of keyboard/mouse switches, at least for me
15:33:10 <monochrom> I.e., quite some of "programmers prefer xxx" is a result of existing programming environments.
15:33:25 <kpreid> ...of course, a trackpad isn't as good in itself as a pointing device
15:33:29 <dmwit> kpreid: The lousiness of my trackpad may have something to do with my aversion to mice. =P
15:33:35 <monochrom> The only objective test is to test with clean slates.
15:34:12 <Peaker> lispy, I don't think the way I use/want to use a programming editor is unique to me - so creating something that I feel comfortable with and am much more efficient with than any text editor would already be a big step forward - and serve as a platform for others to create their own widgets to edit the code... The nice thing is that different people can edit Haskell with differing editors. A "children mode" could use more pictures, a "begin
15:34:12 <Peaker> ners mode" could have more verbosity.
15:34:33 <Peaker> lispy, and they'd all edit the same code
15:34:39 <Saul_> I always get a feeling that psychology is a bit of a self-fulfilling prophecy
15:34:58 <monochrom> Get two groups of small children in Africa.  Take 10-20 years to educate them generally as well as in programming.  Use two different programming environments/paradigms/whatever upon them.  Measure their productivity, happiness, etc.  That will the the only faithful test.
15:35:11 <Saul_> Basically psychologists say that people think a certain way, so we should approach them accordingly
15:35:34 <Saul_> and then you have child psychologists who make sure kids are thought to think that way
15:35:36 <lispy> Peaker: I'm not trying to discourage you.  But, I can tell you would benefit a lot from being more familiar with what has been tried, what works, etc and just HCI in general.  It certainly can't hurt you to know more.
15:36:48 <Peaker> lispy, links to material would be appreciated.  Note I have not committed to any specific UI idea yet - I only know that in my case (as a user), I would benefit a lot from reducing key strokes and requirement of feedback for my coding efficiency
15:36:53 <Saul_> I'm not saying that it's bad perse, but we might be living in a local optimum of sorts
15:36:58 <lispy> So 'case' doesn't provide a rigid type context?
15:37:18 <lispy> How do I get a pattern match in a case to have a rigid type context?
15:37:22 <Saul_> Why not experiment and teach our kids some new thoughtpatterns?
15:37:28 <jsnx> @seen Cale
15:37:29 <lambdabot> Cale is in #haskell-overflow, #ghc and #haskell. I last heard Cale speak 7m 30s ago.
15:37:54 <Saul_> Might be considered child abuse, but it might be interesting
15:37:55 <Cale> jsnx: hi
15:37:57 <ddarius> I don't recall any psychologists teaching me any thought patterns when I was a child.  Perhaps I'm unusual.
15:38:12 <jsnx> Cale: what are the arrows in a poset considered as a category?
15:38:31 <ddarius> jsnx: They aren't anything.
15:38:31 <Peaker> Cale, dmwit : I agree that superficially (in terms of direct keyboard control) the Subtext UI sucks
15:38:32 <lispy> Peaker: I would start by becoming familiar with softvis, VL/HCC, and CHI (all conferences, google should take you to past proceedings) and cognitive dimensions (not sure how you'd get a copy of this, the journal we published in removed our rights to share the article)
15:38:43 <jsnx> ddarius: oh
15:38:47 <Cale> jsnx: There's a unique arrow f: x -> y whenever x <= y
15:38:47 <monochrom> There is a unique arrow from x to y iff x <= y in the poset.
15:38:49 <Saul_> ddarius: Parents, teachers and society in general are all psychologists in a way
15:38:55 <Peaker> lispy, well, if its not freely published I can't probably read it
15:39:09 <Peaker> lispy, thanks for the references, I'll look it all up
15:39:14 <lispy> Peaker: well then, it's okay to ignore the CDs
15:39:20 <bos> down with non-OA journals.
15:39:21 <jsnx> great, thank you all
15:39:25 <lispy> bos: I agree
15:39:42 <lispy> I didn't want to publish there, but the journal chose them for us
15:39:58 <Cale> Peaker/dmwit: for certain kinds of code, I can see how it would be incredibly time-saving.
15:40:08 <therp> lispy: the journal you published in removed your rights? omg. we need really start to get ride of commercial publishers in the academic sector.
15:40:23 <lispy> But, anyway, if I have case foo of Just (Sealed p {- I want to give p a type sig -}) -> ...., how do I get p into a rigid type context?
15:40:24 <dmwit> Cale: Meaning in debugging/reasoning time?
15:40:30 <therp> bos: non-OA?
15:40:35 <dmwit> Cale: Or do you also think it could save in coding time?
15:40:43 <Cale> (Note, I'm specifically talking about the Subtext 2 stuff. The original subtext really had little advantage over plaintext.
15:40:49 <Cale> Coding time.
15:40:49 <lispy> therp: yeah, I can publish a derivative work as long as it's different enough or some non-sense
15:41:00 <bos> therp: OA == "open access"
15:41:09 <Cale> There's a really good abstraction there for complex case-handling.
15:41:23 <therp> bos: fullack
15:41:34 <Cale> and it doesn't really work out in plaintext, as far as I can tell.
15:41:37 <bos> therp: big movement in science publishing over the past half dozen years, inspired by open source software.
15:41:38 <Peaker> Cale, consider the ability of foreign/non-americans to edit the same code in their natural language.  Or showing/hiding type information with a shortcut key.  Or adding more hide-able metadata to the code (perhaps theorem proofs?),  and a huge set of features that become feasible
15:41:51 <therp> probably we could get some kind of agreement in the haskell scene to not publish in non-OA journals?
15:41:56 <Peaker> Cale, the original subtext 1 had a big advantage - you saw the program running as you edit
15:41:58 <Cale> Peaker: I agree.
15:42:03 <Cale> Er
15:42:16 <bos> therp: not likely. the only FP journal is non-OA.
15:42:19 <therp> bos: I partially know what it's about. I've just not been familiar with this acronym
15:42:34 <Cale> I suppose you did, but the problems with the UI overwhelmed that.
15:42:35 <therp> bos: so? just found another one
15:42:38 <adiM> > let func = (!) [1..100]  in func 5
15:42:38 <lambdabot>  Couldn't match expected type `Array i e'
15:43:02 <jsnx> what i like about haskell is that it make programming harder
15:43:03 * mrchebas is running out of ideas
15:43:04 <bos> therp: that requires the academics in the scene to care enough to do it. i'm not an academic.
15:43:17 <Cale> You also don't really need to see the program running as you edit it. It's nice to have a visual representation for the program running at all though.
15:43:17 <jsnx> harder = job security
15:43:29 <Cale> For Haskell, that would probably best be graph reduction.
15:43:31 <jsnx> think about that, guys
15:43:46 <mrchebas> any clue as to why ghci-6.8.1 does not want to load and complains about "unknown symbol `___stginit_base_Prelude_' "?
15:43:50 <adiM> > let func = (!!) [1..100]  in func 5
15:43:51 <lambdabot>  6
15:43:59 <Peaker> Cale, You don't "need" it - but it can be mighty helpful. Much nicer than classical "debugging"
15:44:00 <jsnx> mrchebas: job security :)
15:44:10 <Peaker> Cale, The unit-test assertion adding was nice too
15:44:16 <adiM> Will the list be always completely evaluated in the above function func?
15:44:24 <mrchebas> ?
15:44:30 <mrchebas> not mine :)
15:44:30 <oerjan> adiM: certainly not
15:44:36 <Cale> Peaker: Oh, I'm just making the distinction between while editing and after editing.
15:44:38 <therp> bos: not paying travel expenses to conferences associated with non-OA should help
15:44:56 <oerjan> > let func = undefined:2:undefined in func 1
15:44:56 <lambdabot>  Couldn't match expected type `t1 -> t' against inferred type `[a]'
15:44:58 <Cale> Peaker: I don't think I'd usually care to see code running as I edit it, that's just distracting.
15:45:01 <oerjan> er
15:45:08 <adiM> I am trying to write a function where the list is generated from a big calculation, and I want to reuse the list rather than evaluating it always. how do I do that?
15:45:10 <Peaker> Cale, I agree that before the code does anything of interest, the feature is not always helpful - but often when I write code I have to keep "imagining" an example input, and in those cases it would help me greatly
15:45:10 <oerjan> > let func = (!!) (undefined:2:undefined) in func 1
15:45:11 <lambdabot>  2
15:45:25 <Peaker> Cale, Do you use emacs editor macros?
15:45:31 <Peaker> Cale, or any editor macros?
15:45:32 <Cale> Peaker: no, not at all
15:45:55 <Peaker> Cale, well, they're very powerful tools
15:46:13 <Peaker> Cale, and ones that can be generalized to general programming, rather than just string manipulations, in such an environment
15:46:15 <Cale> Peaker: I mostly code by thinking of properties that my functions must satisfy.
15:46:24 <oerjan> adiM: give the list a name
15:46:33 <Peaker> Cale, do you ever use regular expressions?
15:46:46 <Cale> Not often. I'll usually just use Parsec or something.
15:47:24 <adiM> oerjan, I do not want to define a global variable since I want to reuse the function in the form of a library
15:47:30 <Cale> The most common use case I have for regular expressions is using a little tool involving sed to rename bunches of files.
15:47:39 <Peaker> Cale, with editor macros, I write string-manipulation programs in fractions of seconds, that would take me a few minutes to write with ordinary code
15:48:02 <Cale> Could you give an example?
15:48:09 <oerjan> adiM: you can use func = (!!) l where l = ...
15:48:18 <Peaker> Cale, the reason is that my brain (and I suspect many others') is much better at generalizing a way to manipulate a concrete piece of data, than it is at creating a generalized way without reference concrete data
15:48:39 <Peaker> Cale, ok, for example, I have a big "if(..) else if (..)" that I want to convert to a switch(..) { case ..: ... }
15:49:00 <oerjan> i am not sure whether func n = l !! n where l = ... would work too, that might still recalculate
15:49:00 <adiM> oerjan, does that mean that if I call the func twice with the same arguments, the list will be evaluated only once?
15:49:09 <noecksit> hello, i have some problem understanding the code that i wrote, it is @ hpaste.org/6468
15:49:13 <Peaker> Cale, I can record a macro that converts a single if case into its own case .. :
15:49:18 <oerjan> adiM: even with different arguments
15:49:20 <ddarius> func = let l = ... in \n -> l !! n
15:49:32 <Peaker> Cale, When I am recording the macro, I act on a specific case, but it records the operations I do, not their specific effect on the first example
15:49:42 <adiM> oerjan, thanks
15:49:44 <oerjan> ddarius: that should be equivalent to the first one
15:49:44 <Cale> noecksit: are you sure that's your paste?
15:49:49 <Peaker> Cale, so I have to be careful not to press right 5 times to go the next word, but press "Ctrl+Right" (next word)
15:49:49 <noecksit> if anyone knows about alpha-beta pruning, or has read the paper "Why FP matters", i am trying to do what they are saying on pg 20
15:50:00 <Cale> http://hpaste.org/6486
15:50:11 <ddarius> oerjan: Of course it's semantically equivalent, but we're talking about non-observable properties.
15:50:16 <noecksit> Cale: yeah my bad, thats it
15:50:26 <Peaker> Cale, however, I see the results immediately on the first example, and with a bit of skill, you don't get over-specific for the first example, and you just run the recorded macro on the rest of the cases
15:50:37 <ddarius> Either way, the compiler is free to share or unshare any representation.
15:50:54 <Peaker> Cale, I can convert 50 if/else cases to a case ..: format (or to their own functions, or anything else) in a matter of a few seconds
15:51:17 <noecksit> its not giving me the same answer when i use minimax without alpha-beta pruning, which means its wrong...
15:51:35 <oerjan> ddarius: yeah but i am thinking about ghc, it probably shares both with func = ... where ... and func = let ... in ... but i don't know about func n = ... where ...
15:52:06 <oerjan> and the first desugars to the second i think
15:52:10 <Saul_> Peaker: But at which point do you have 50 if-else statements?
15:52:11 <Cale> Peaker: hmm, okay
15:52:32 <adiM> ddarius, oerjan, the program that I have written is http://hpaste.org/6487 So, I should not worry about arr being computed multiple times
15:53:11 <Saul_> Peaker: I have yet to use a nested if-else in haskell
15:53:31 <Peaker> Saul_, I haven't done enough Haskell to know about where I'd need it there.. so I used a C example
15:53:51 <Peaker> Saul_, Generally I prefer to extract code from cases in large switch()es to their own functions - I use macros for that too
15:54:12 <Peaker> Saul_, no other tool lets you program that fast
15:54:25 <Peaker> I think it can be generalized to more than just text editing
15:54:25 <dmwit> vim?
15:54:29 <oerjan> adiM: i think that's fine ( (!) arr part i assume )
15:54:32 <Saul_> Peaker: Well I don't have much experience with macros myself
15:54:35 <Peaker> dmwit, I suppose vim can do it too, as it also has macros
15:54:51 * dmwit scrolls back to see what tool we're talking about
15:54:52 <Saul_> Peaker: I can see how they are handy sometimes, but they seem a little ad-hoc to me
15:55:13 <adiM> oerjan, thanks
15:55:14 <Saul_> Peaker: There is this tool called HaRe that is a refactorer for haskell
15:55:17 <Peaker> Saul_, they're an ad-hoc tool to solve ad-hoc problems. A haskell program solving the same problem would also be ad-hoc
15:55:32 <Peaker> Saul_, Refactoring should be integrated into the editor
15:55:55 <dmwit> Oh, yeah, emacs/vim.
15:56:37 <Saul_> Peaker: I think it is unmaintained at the moment, but it actually knows the semantics of haskell so you can do really cool refactors with it easily and not get for examples scoping errors like you would with a global replace
15:57:02 <Saul_> I think it was integrated with some editors, not sure which ones though
15:57:17 <Peaker> Saul_, you probably missed my former rants about the need to replace text editors with specialized UI's to edit Haskell programs.. see the backlog :)
15:57:19 <Saul_> I haven't used it myself, only saw a short presentation on it
15:57:55 <mrd> just so long as the "specialized UI" doesn't involve using the mouse
15:58:10 <oerjan> hpaste bot still down?
15:58:11 <mrd> most IDEs make that mistake horribly
15:58:23 <oerjan> @seen hpaste
15:58:23 <lambdabot> I saw hpaste leaving #haskell 2d 14h 2m 48s ago, and .
15:58:31 <shapr> I'll fix hpaste in a bit.
15:58:59 <Peaker> mrd, I agree! Subtext also made the mouse mistake
15:58:59 <Saul_> I don't think using the mouse is that bad, just make sure I don't have to switch to and fro 5 times a second
15:59:03 <Apocalisp> mrd: Programming with the mouse is an insult to the craft!
15:59:04 <noecksit> no takers?
15:59:25 <Peaker> the mouse is useful for geographic positioning, not discrete selections which it is usually used for
16:00:06 <Apocalisp> "Throw away your mouse!"
16:00:39 <mrd> kill the rat!
16:01:14 * Apocalisp whacks at his logitech, screaming, with a mad look on his face
16:01:27 <Peaker> The mouse is _great_ for starcraft and Quake :)
16:01:38 <shapr> And tremulous
16:01:40 <shapr> g'day Pseudonym
16:01:56 <Pseudonym> G'day.
16:02:07 <Apocalisp> The mouse for starcraft? Dude. Got micro?
16:02:23 <Peaker> Apocalisp, you can't play Starcraft without a good mouse ;)
16:02:26 <Zao> Apocalisp: Selecting things tend to be rather impossible with the keyboard.
16:02:44 <Peaker> even worse, selecting where to go without the mouse? horrible
16:02:48 <Apocalisp> yea, I've never played that crap. I'm just stirring up strife
16:02:51 <Zao> Amusingly enough, Starcraft had a N64 port.
16:03:29 <dmwit> Zao: Yeah, but you don't select things with the mouse that often.  Shift+F5, baby ;-)
16:03:57 <lispy> are we talking about building Starcraft in Haskell? <hint, hint>
16:03:58 <shapr> !paste
16:03:58 <hpaste> Haskell paste bin: http://hpaste.org/
16:04:01 <shapr> excellent
16:04:08 <shapr> oerjan: Ok, fixed
16:04:26 <Saul_> People that still play it on the internet are so good that they beat you before you even get around to selecting stuff
16:05:02 <Peaker> Saul_, I beat most people on the internet :-)
16:05:05 <Apocalisp> Saul_: Tahts bcuz u r a no0b
16:05:10 <Peaker> I've played Starcraft for years, though
16:05:20 <Japsu> Starcraft is probably the best RTS I've played
16:05:42 <Japsu> (AOE2 scores pretty high too, though)
16:05:49 <shapr> I wonder if gtk2hs is sufficient for writing a starcraft clone?
16:06:08 <Saul_> I once played with the Protoss and had 30 Zealots, then I ran to the enemy and I ran into a few spider mines
16:06:09 <Japsu> why not use SDL
16:06:23 <dmwit> shapr: I think the graphics would be too slow.
16:06:36 <Japsu> !go HSDL
16:06:37 <shapr> dmwit: You think hsSDL or something would be fast enough?
16:06:41 <dcoutts_> dmwit: why?
16:06:41 <Japsu> @go HSDL
16:06:41 <Peaker> the interesting part about Starcraft is its network-engine, I believe
16:06:44 <lambdabot> https://www.hsdl.org/
16:06:55 <Japsu> interesting ;D
16:07:00 <Peaker> I wrote my own clone of their network algorithm, as I understood it (according to its symptomatic behaviour)
16:07:00 <Japsu> homeland security digital library
16:07:07 <shapr> Peaker: In Haskell?
16:07:12 <Peaker> shapr, Nope
16:07:21 <shapr> oh
16:07:22 <Peaker> shapr, I don't know enough Haskell yet
16:07:27 <shapr> ok
16:07:28 <dmwit> dcoutts_: Well, just based on writing a small game based on gtk2hs that was turn-based; almost no time was spent calculating, it was all in the graphics.
16:07:33 <Saul_> I've been working on my own game for the last few days
16:07:52 <Saul_> Basically just trying to get something to run
16:08:15 <dmwit> dcoutts_: Then again, I was using Cairo; if there's an option for non-scalable graphics, that would probably be faster.
16:08:15 <Saul_> Now I've been reading a very simple introduction to physics simulation
16:08:28 <Peaker> Saul_, SDL?
16:08:29 <Baughn> shapr: hsOpenGl should be quite fast enough. Offload the sprite copying to the gpu. ;)
16:08:30 <Pseudonym> Saul: Have you read David Baraff's tutorial?
16:08:35 <shapr> Baughn: True that
16:08:37 <Saul_> What's SDL?
16:08:44 <shapr> @go sdl
16:08:46 <lambdabot> http://www.libsdl.org/
16:08:46 <lambdabot> Title: Simple DirectMedia Layer
16:08:51 <Peaker> Saul_, graphics/events/etc library for games
16:09:02 <Peaker> Saul_, or generally graphic UI stuff
16:09:08 <Pseudonym> http://www.cs.cmu.edu/~baraff/sigcourse/ <- Best introduction that you'll ever read.
16:09:08 <lambdabot> Title: Physically Based Modeling
16:09:13 <dcoutts_> dmwit: there's the older Gdk lib which is essentially a thin wrapper over the X11 primitives, so really fast
16:09:17 <Saul_> No I'm doing it all by myself (and opengl)
16:09:36 <shapr> Oh, I was trying to think of new and interesting SoC projects today...
16:09:49 <dcoutts_> dmwit: and then of course I expect most of the graphics would be bitmap anyway right? so using pixmaps and pixbufs
16:09:51 <Pseudonym> Oh, I've been thinking about data-parallel physics.
16:09:52 * shapr thinks
16:10:02 <shapr> Pseudonym: Got any ideas for an SoC project?
16:10:04 <dmwit> dcoutts_: Right, so I retract my claim.
16:10:18 <Pseudonym> Yeah, I think that fluid simulation might actually be better from a DP point of view.
16:10:37 <Saul_> Pseudonym: No, I'm reading http://chrishecker.com/Rigid_Body_Dynamics by Chris Hecker
16:10:38 <dmwit> shapr: It turns out I actually have no idea about the speed of gtk's graphics. =P
16:10:39 <lambdabot> Title: Rigid Body Dynamics - Chris Hecker's Website
16:10:42 <Pseudonym> Saul: Right.
16:10:47 <dcoutts_> dmwit: you're quite right that cairo can be a tad slow, esp for some operations like gradient fills, though it has got faster in recent releases
16:10:52 <shapr> dmwit: oh
16:11:00 <Pseudonym> The problem with rigid-body physics is collision.
16:11:05 <Pseudonym> Which fluid simulation doesn't have.
16:11:10 <Pseudonym> So it's "more parallel", in a sense.
16:11:16 <Baughn> Pseudonym: Parallelism in any kind of physics never struck me as much of an issue. Just make sure you build it as a discrete-time automaton, not actual constraint solving..
16:11:47 <_spider_>  kosovo is the heart of serbia!
16:11:59 --- mode: ChanServ set +o Pseudonym
16:12:03 --- kick: _spider_ was kicked by Pseudonym (Pseudonym)
16:12:04 --- mode: ChanServ set -o Pseudonym
16:12:46 <Baughn> Pseudonym: The traditional insistence on having *perfect* collision detection also seems to lead to artifacts in the physics, so.. instead, make all the objects negatively charged or something?
16:12:55 <Saul_> I actually only did the first two of Chris Hecker's articles
16:13:06 <Saul_> And the first I already figured out on my own
16:13:11 <forkiliens> is anyone familiar with the package binary? i'm trying to install it with darcs, but get the following error:
16:13:21 <Pseudonym> Baughn: Have you looked into impulse-based physics simulators?
16:13:29 <Saul_> But the rotation thing was useful
16:13:36 <forkiliens> Preprocessing library binary-0.2...
16:13:36 <forkiliens> Building binary-0.2...
16:13:36 <forkiliens> src/Data/Binary.hs:88:17:
16:13:36 <forkiliens>     Could not find module `Data.Sequence':
16:13:36 <forkiliens>       it is a member of package containers-0.1.0.1, which is hidden
16:13:36 <Pseudonym> I've got some papers on my reading list.
16:14:00 <Baughn> forkiliens: You're using ghc 6.8.x, right?
16:14:11 <dcoutts_> forkiliens: try the latest version of binary, you've got a very old version there.
16:14:18 <Baughn> forkiliens: You're also using an old version of binary that isn't compatible with it. Get a newer one
16:14:22 <dcoutts_> the latest is on hackage
16:14:31 <dcoutts_> @hackage binary
16:14:31 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
16:14:34 <Baughn> I'd suggest using cabal-install
16:14:55 <Saul_> I'm going to go, I have stuff to do and you're keeping me from it :)
16:15:10 <Baughn> Pseudonym: Not yet. All my interest has been in liquid/gas physics, but since I'm trying to simulate tectonics now I mmight need to look into it
16:15:23 <Pseudonym> Yeah, I like fluid dynamics.
16:15:26 <forkiliens> ok, i'm trying the other version. thanks
16:15:47 <Pseudonym> So, Eulerian or Lagrangian?
16:16:13 <Baughn> Ur.. baughnian?
16:16:32 <Baughn> It's for a /game/. I'm not trying to get something that works perfectly, just something that looks good
16:16:36 <Pseudonym> Ah.
16:16:43 <Baughn> (Anyway, the channels are typically one cell wide)
16:16:49 <Pseudonym> Lagrangian means that your fluids are particles.
16:17:09 <Saul_> For games speed is far more important than having a perfect simulation
16:17:14 <Pseudonym> Eulerian means that you have a grid or some other mesh and store a density/velocity in each cell.
16:17:21 <Saul_> especially since no one will see the difference
16:17:40 <Baughn> Saul_: In this game, they might
16:17:48 <bos> numerical stability is also very important.
16:17:59 <Saul_> What kind of game is it?
16:18:26 <Pseudonym> In the entertainment business, be it games or movies, the two most important things in order are a) visual plausibility, and b) stability.
16:18:27 <Baughn> Pseudonym: I'm not sure I see the difference, but I think eulerian. I'm storing depth, pressure, velocity and.. something I like to call "pull" that really has no physical analogue
16:18:32 <lispy> Baughn: does this mean you'll be releasing a Haskell based game physics engine?
16:18:34 <Pseudonym> Right.
16:18:36 <Pseudonym> That's Eulerian.
16:18:53 <Baughn> lispy: If I ever get past playing with the physics, sure. :P
16:19:03 <Pseudonym> What kind of solver, if I might ask?
16:19:25 <lispy> Baughn: cool, I look forward to it.  I'd love to see more game programming done with Haskell.
16:19:46 <Baughn> Pseudonym: It's all ad-hoc. I jumped before I looked, and have been figuring things out myself, so I don't know what they're called
16:19:53 <Saul_> lispy: I think it is actually a pretty cool language to program them in
16:20:02 <Baughn> Pseudonym: FWIW, it's a discrete time simulation with no nonlocal effects
16:20:10 <Pseudonym> Right.
16:20:15 <Pseudonym> Have you read "Stable Fluids"?
16:20:22 <Baughn> I haven't read /anything/. ;)
16:20:41 <lispy> Saul_: definitely.  And anything that is performance intensive can often be pushed down or written in high performance Haskell.  So there aren't even that many technical excuses for not using haskell :)
16:20:51 <Pseudonym> :-)
16:20:54 <Baughn> Saul_: Oh, right. Clone of dwarf fortress. Theoretically.
16:20:56 <Peaker> lispy, what is "high performance Haskell"?
16:21:28 <Pseudonym> "Stable Fluids" is a brilliant paper.
16:21:32 <lispy> Peaker: it's haskell code that has been through a filter similar to dons.  It may not be pretty like normal haskell, but it will be fast and still be haskell.
16:21:38 <Pseudonym> It's only a few pages long, and it's very tutorial-like.
16:21:49 <Pseudonym> And Jos Stam has even released source code for PDAs.
16:21:50 <forkiliens> does anyone use ubuntu / linux? i have installed both ghc-6.82 (since i want to install happs) and 6.41
16:21:50 <Baughn> Pseudonym: I'll take a look
16:21:58 <gweiqi> Pseudonym: do you have a link?
16:22:04 <Baughn> http://portal.acm.org/citation.cfm?id=311535.311548&type=series
16:22:05 <Saul_> forkiliens: Yes I do
16:22:08 <lambdabot> Title: Stable fluids
16:22:13 <forkiliens> i want to make it possible that ghc points to 6.82
16:22:16 <gweiqi> cool, thanks
16:22:21 <Pseudonym> http://www.dgp.toronto.edu/people/stam/reality/Research/pub.html
16:22:22 <lambdabot> Title: Jos Stam: publications
16:22:26 <forkiliens> how do i do this?
16:22:35 <Pseudonym> Check out "Real-Time Fluid Dynamics for Games" as well.
16:22:40 <Saul_> forkiliens: It should do that if you install it after 6.41
16:22:46 <Pseudonym> It has source code./
16:22:48 <Baughn> forkiliens: I'd suggest uninstalling 6.4.1
16:22:51 <lispy> forkiliens: does ubuntu have alternatives?
16:23:00 <forkiliens> i think so.
16:23:07 <Peaker> lispy, what is "dons"?
16:23:09 <lispy> forkiliens: I think debian has a facility for switching between installed packages (changing the default and symlinks)
16:23:17 <lispy> ?where dons
16:23:17 <lambdabot> http://www.cse.unsw.edu.au/~dons
16:23:17 <Baughn> lispy: Problem is, ubuntu doesn't have ghc 6.8.2
16:23:22 <Baughn> So it's presumably in /usr/local
16:23:35 <Saul_> The problem is that 6.8 isn't in the package manager yet (in Ubuntu)
16:23:42 <lispy> ah
16:24:21 <sethk_> Saul_, I installed the package version, and used it to install 6.8.2
16:24:35 <sethk_> working perfectly
16:24:37 <Baughn> Pseudonym: Anyway, I've been trying for something that looks /and/ behaves sanely when the visible cells are ~2m^3, and I think I've managed that pretty well. I'll read the paper, though.
16:24:55 <Pseudonym> Sounds good.
16:25:14 <Pseudonym> Bear in mind that the paper is a little bit old.
16:25:16 <forkiliens> ok, i'll try removing 6.42
16:25:36 <Pseudonym> You'd prefer a MAC grid to the everything-at-the-grid-centre today.
16:25:53 <Saul_> sethk_: So did I, it's forkiliens that is having problems
16:25:53 <Peaker> idnar, did you abandon Twisted after discovering Haskell?
16:25:56 <lispy> Peaker: basically dons is a very bright and capable haskell hacker who hangs out here a lot and loves to optimize code so that it's just as fast or faster than C
16:26:11 <sethk_> Saul_, ah, sorry
16:26:24 <Peaker> lispy, cool - I am a big believer that high-level code should be faster, not slower, than low-level code :)
16:26:31 <Baughn> Pseudonym: Is there some glossary I could read that will explain these terms? Or a book? Or something?
16:27:24 <Baughn> Peaker: In this case, I have high-level code running several *thousand* times faster than the original low-level code. That's because I use a better algorithm, though.
16:27:30 <Pseudonym> The Stam paper is a pretty good introduction.
16:27:33 <Pseudonym> "Stable Fluids".
16:27:47 <Baughn> Right.
16:28:16 <Pseudonym> If you're not thrown by the word "Lagrangian", should be fine.
16:28:36 <Baughn> I am, but that's at a level that I can look it up
16:28:43 <Peaker> what is an "irregular tree"?
16:28:55 <Baughn> A non-balanced tree?
16:29:10 <Peaker> oh, ok
16:29:18 <Peaker> haven't heard that term before, somehow :)
16:29:37 <Saul_> Regular tree is a tree with all leaves at the same depth iirc
16:30:12 <Baughn> Whereas a merely /balanced/ tree can be arbitrarily irregular, depending on the algorithm
16:31:30 <Pseudonym> Aha!
16:31:33 <Pseudonym> http://www.cs.ubc.ca/~rbridson/fluidsimulation/2006/
16:31:36 <Pseudonym> SIGGRAPH course notes.
16:31:40 <Pseudonym> They're always good.
16:32:01 <Baughn> Thanks!
16:32:53 * Baughn goes back to doing partial-update finite element models of mountains. I'll call the delay in things falling down "crumbling time". That sounds good.
16:35:40 <solrize> @src nub
16:35:41 <lambdabot> nub = nubBy (==)
16:35:45 <solrize> @src nubBy
16:35:45 <lambdabot> nubBy eq []             =  []
16:35:45 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
16:39:37 <idnar> Peaker: abanodon?
16:39:41 <idnar> *abandon
16:40:05 <Peaker> idnar, Didn't you always hang out in there?
16:40:19 <idnar> Peaker: I'm still there :P
16:40:23 <Peaker> oh, +s
16:40:36 <gweiqi> twisted as in matrix?
16:40:58 <idnar> yes
16:40:59 <Peaker> yeah, Twisted matrix (Python framework)
16:41:05 <gweiqi> i used to use that
16:41:14 <gweiqi> then i had to get a job
16:41:40 <Peaker> gweiqi, heh I used it in a job (sort of), and friends of mine use it in their jobs - and hopefully I can convince my current workplace to dumb their home-made one and switch too
16:41:44 <Peaker> s/dumb/dump
16:41:44 <idnar> my day job involves quite a lot of Twisted (although mostly underneath other libraries)
16:41:53 <gweiqi> cool
16:41:58 <gweiqi> my job involves too much C++
16:42:17 <gweiqi> though they accept python for more limited applications
16:42:27 <sethk_> Haskell is amazing.  When I finally get something to compile (I'm still weak in some language areas), it works forever and I get no bug reports
16:42:44 <Peaker> sethk_, getting no bug reports may not be a good sign :)
16:42:59 <sethk_> Peaker, that's true, but in this case the users have no other options  :)
16:43:28 <idnar> heh
16:44:04 <forkiliens> does anyone know where to get HApps-Util?
16:44:05 <BMeph> Baughn: After you finish the Stam paper, you might want to check out a study by Ted Kim: http://www.cs.unc.edu/~kim/I3D08/hardware_fluids.pdf
16:44:49 <oerjan> @where happs-util
16:44:49 <lambdabot> I know nothing about happs-util.
16:44:52 <gwern> forkiliens: http://happs.org/HAppS/HAppS-Util or hackage
16:45:00 <oerjan> @where happs
16:45:00 <lambdabot> http://happs.org
16:45:03 <gwern> @where+ happs-util http://happs.org/HAppS/HAppS-Util
16:45:03 <lambdabot> Okay.
16:45:13 <gwern> @where+ HApps-Util http://happs.org/HAppS/HAppS-Util
16:45:13 <lambdabot> Nice!
16:45:27 <gwern> @where+ HAppS-Util http://happs.org/HAppS/HAppS-Util
16:45:27 <lambdabot> Done.
16:45:30 <oerjan> i think it's case insensitive
16:45:35 <gwern> HAppS is such a unpleasant name
16:45:49 <oerjan> @where hApPs-UtIl
16:45:49 <lambdabot> http://happs.org/HAppS/HAppS-Util
16:45:52 <sethk_> URLs are insensitive according to the specs, yes
16:45:54 <forkiliens> what does that mean @where?
16:46:05 <forkiliens> do i type it in shell?
16:46:14 <oerjan> forkiliens: lambdabot command
16:46:22 <gwern> forkiliens: where is a little database lambdabot maintains of names-> URLs
16:46:25 <gwern> @where Frag
16:46:25 <lambdabot> http://www.haskell.org/haskellwiki/Frag
16:46:31 <gwern> @where xmonad
16:46:31 <lambdabot> http://xmonad.org/
16:46:38 <gwern> forkiliens: you get the idea
16:47:49 <forkiliens> a lot of new stuff to get used to... let's hope, that it's worth the effort.  :) anyway thanks for your answers
16:48:14 <gwern> forkiliens: lambdabot is just a tool, like Hoogle
16:48:16 <gwern> @where Hoogle
16:48:16 <lambdabot> http://haskell.org/hoogle
16:48:18 <gwern> :)
16:48:24 <oerjan> @hoogle where
16:48:25 <lambdabot> Language.Haskell.TH.Ppr.where_clause :: [Dec] -> Doc
16:48:25 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
16:48:25 <lambdabot> Data.Generics.Schemes.somewhere :: MonadPlus m => GenericM m -> GenericM m
16:49:18 <adiM> @pl f (x,(y,z)) = (x,y,z)
16:49:19 <lambdabot> f = uncurry ((`ap` snd) . (. fst) . (,,))
16:49:25 <forkiliens> @where Hoogle
16:49:25 <lambdabot> http://haskell.org/hoogle
16:49:33 <forkiliens> ahh
16:50:00 <forkiliens> @where HAppS-Util
16:50:00 <lambdabot> http://happs.org/HAppS/HAppS-Util
16:50:04 <forkiliens> cool
16:50:11 <monochrom> Somehow in theory I don't expect type checking to be all that bug-catching.  After all if you have something like transform :: String -> String your bugs are bound to be in the algorithms rather than the types.  But I said "in theory".  In practice you have all observed that type checking gets you very close to bug-free, especially for you who came from other, more mainstream, less checking languages.  If that is true, that i
16:50:12 <monochrom> s a miserable statement about the mainstream rather than a success statement about Haskell, i.e., the mainstream encourages you to make so many blantantly obvious errors, and refuses to catch them though they're so easily machine-catchable.
16:50:21 <adiM> @pl f (x,(y,z)) = ((x,y),z)
16:50:21 <lambdabot> f = uncurry ((`ap` snd) . (. fst) . ((,) .) . (,))
16:51:13 <Peaker> monochrom, String is also a bad example, perhaps, as it is almost an escape from the type system
16:51:20 <dibblego> monochrom, so true
16:51:25 <Peaker> monochrom, Strings use encodings to encode rich types on top of them
16:52:22 <Baughn> monochrom: Strings should normally only be used in the edges of the program. Very few complex modules need to deal with them..
16:52:42 <monochrom> Yes yes, if you make use of real, rich types to represent things in your algorithm, you get extra checks, which is very nice.
16:52:47 <Toxaris> transform = prettyprint . process . parse
16:52:59 <Toxaris> with process :: some sensible type
16:54:01 <monochrom> What is appalling is you could do this just the same in C, C++, Java, ... most mainstream languages, and yet you find Haskell so much more helpful.
16:54:31 <monochrom> I mean, why and how could people possibly tolerate this?
16:54:37 <Baughn> Haskell makes it sufficiently easy that you actually /do/ it
16:54:49 <Baughn> If that is an indictment of the mainstream, I'm happy to indict
16:54:57 <gwern> backwards compatibility, catering to the masses... I dunno
16:55:16 <sethk_> haskell is far more difficult to write than C++ or Java
16:55:22 <gwern> lisp may not do it, but that's because type checking is hard in it, and you could just put your own language on top
16:55:27 <Peaker> monochrom, Type inference is hard
16:55:37 <monochrom> Why are there no programmers going to the streets doing a protest demonstration: "Gosling, we want HM + Rank-N HERE AND NOW!" ?
16:55:47 <Peaker> monochrom, So most statically typed languages require a lot of redundant parts in your program
16:56:02 <gwern> maybe it's the old Worse is better thing - it was too hard to write compilers which supported type inference/checking in the decades before, so no one did it. simple, not comprehensive
16:56:11 <BMeph> Baughn: Do you mean strings specifically, or any type "isomorphic" to Strings? ;)
16:56:44 <Baughn> BMeph: I mean any type where you encode information in the payload that really should be in the type
16:57:19 <Baughn> BMeph: You see the exact same problem in sql databases. Some people /will/ stick xml strings in instead of decomposing it..
16:57:21 <nibro> monochrom: Allow me to quote Paul Graham: "The good thing about the world being stupid is that by being smart you can kick their ass"
16:57:28 * BMeph nods appreciatively at Baughn's point
16:57:30 <monochrom> Heh, I actually agree with sethk_ about Haskell being harder.  Remember on -cafe there was a thread about "let's state clearly on haskellwiki what Haskell is about"?  I was going to say: "Haskell is for you who want higher abstractions".  Clearly not for everyone.
16:57:46 <Baughn> BMeph: And by "really should", I mean "could"
16:58:03 <gwern> nibro: I'd rather have a world where haskell is the status quo and everyone can benefit than look on PG's bright side
16:58:11 <hpaste>  lithis pasted "xmonad config" at http://hpaste.org/6488
16:58:12 <Toxaris> Baughn: in a perfect world, every bit of information would be possibly represented in the type. how could you know beforehand what part of the information is static or dynamic in a specific usecase?
16:58:15 <Peaker> for me, Haskell is perhaps the basis for a new concept for software architecture in general
16:58:16 <augustss> everyone needs higher abstraction, but not everyone wants it.
16:58:17 <ddarius> monochrom: Why do we need HM in Java?
16:58:36 <monochrom> That's just an example.
16:59:04 <Baughn> Toxaris: If you don't know, you put it in the payload. Currently the problem is with people putting too /little/ in the typing, not too /much/
16:59:06 <adiM> Is there a built-in function to find the unique elements of a list
16:59:09 <ddarius> monochrom: My point is why would I heckle Gosling when I could just switch to an existing language?
16:59:16 <nibro> gwern: of course - but I still love the quote :)
16:59:17 <gwern> adiM: nub?
16:59:25 <adiM> @src nub
16:59:26 <lambdabot> nub = nubBy (==)
16:59:32 <gwern> nibro: it's a cold consolation....
16:59:32 <adiM> @src nubBy
16:59:32 <lambdabot> nubBy eq []             =  []
16:59:32 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
16:59:39 <monochrom> I offer this example for Baughn's point.  Source code = string things which should have been more structured and typed. :)
16:59:46 <Toxaris> Baughn: sure. and my proposal is: put everything in the type.
16:59:54 <adiM> > nub [1,2,4,2,1,2,4,1,2,4]
16:59:56 <lambdabot>  [1,2,4]
17:00:07 <adiM> gwern, thanks :)
17:00:07 <Baughn> Toxaris: Even then, you can say things like "data Foo = Empty | Int" instead of encoding empty as -1..
17:00:18 <Peaker> Toxaris, if you unite the type and the data, you get dynamic-typing
17:00:20 <nibro> gwern: it makes life much more bearable in the mean time, while we patiently wait...
17:00:33 <augustss> adiM: of you have a long list, don't use nub
17:01:01 <Baughn> monochrom: Well, yes. ;)
17:01:07 <oerjan> > S.toList . S.fromList $ [4,2,1,4,2,2,4,1]
17:01:08 <lambdabot>  [1,2,4]
17:01:15 <sieni> Peaker: how does it differ from "don't do bad software architecture, do good software architecture"?
17:01:17 <monochrom> ddarius: OK, even "Gosling" was an example.  How about: "we want HM + rank-N in ALL languages HERE AND NOW!" ?
17:01:25 <Peaker> sieni, what is?
17:01:26 <oerjan> adiM: ^^ more efficient for long lists (S = Data.Set)
17:01:36 <adiM> oerjan, thanks
17:01:38 * gwern sends off an email to the qthaskell guy. let's see whether anything has happened with it since december
17:01:41 <ddarius> monochrom: I could care less if Icon, say, had HM types.
17:01:47 <gwern> monochrom: typed assembler? interesting idea
17:02:00 <Baughn> adiM: It's more restrictive in the type than nub, of course
17:02:01 <ddarius> @google Talx86
17:02:02 <lambdabot> http://www.cs.cornell.edu/talc/releases.html
17:02:02 <lambdabot> Title: Talc Releases
17:02:05 <augustss> gwern: typed assembler is very cool
17:02:12 <oerjan> > map head . group . sort $ [4,2,1,4,2,2,4,1]
17:02:13 <lambdabot>  [1,2,4]
17:02:17 <Peaker> sieni, what did I say? :)
17:02:20 <oerjan> adiM: ^^ yet another option
17:02:31 <EvilTerran> god damnit, Arthur C Clarke's died.
17:02:36 <augustss> yeah :(
17:02:39 <adiM> oerjan, wouldn't sort make it very slow?
17:02:46 <EvilTerran> =[
17:02:50 <Baughn> EvilTerran: Please tell me he's at least been put on ice
17:03:06 <oerjan> adiM: sort is usually mergesort so pretty fast (same as S.fromList i think)
17:03:06 <ziman> sort is n log n, too
17:03:12 <Baughn> adiM: sort is O(n lg n), same as fromList. It's the same complexity
17:03:15 <gwern> Baughn: I don't know why, but sci-fi authors never  seem to take advantage of cryogenic storage
17:03:33 <Baughn> gwern: Probably too certain that it's /fiction/
17:03:37 <gwern> heinlein supposedly had his paid for and wrote a book on a guy stored and revived, but he went and became wormfood!
17:03:55 <sieni> "<Peaker> for me, Haskell is perhaps the basis for a new concept for software architecture in general"
17:04:03 <Toxaris> Peaker: I want dynamic typing at compile-time. obviously, type-correctness = correctness for such a language, but we just need type-checker = theorem prover to make this sensible.
17:04:20 <Peaker> Toxaris, with pure-functional languages, you can unite edit-time, compile-time, and run-time, into the same time
17:04:30 <Peaker> Toxaris, except for the running of the IO actions
17:04:41 <adiM> Can I simplify the above if the list is generated by concatMap?
17:04:53 * monochrom now returns to shell script programming, is improving his backup-making script.
17:05:01 <Peaker> sieni, Oh: I mean I believe that the right approach to build software is to build a platform based on a language, without hardware protection, etc
17:05:04 <sieni> you know that your computer sucks, when it only can render a _screen capture_ of an nvidia demo at less than 1fps
17:05:11 <Peaker> sieni, no processes, access control lists, etc
17:05:25 <Toxaris> Peaker: run-time includes actual parameters not known at compile-time.
17:05:32 <sieni> Peaker: ahh, ok
17:05:35 <Peaker> Toxaris, for a purely functional program?
17:05:36 <dmwit> adiM: Not really, unless you want to write your own merge.
17:05:53 <monochrom> I need exception in shell scripts. :)
17:05:57 <sieni> Peaker: that might make sense
17:06:00 <Peaker> Toxaris, knowing "everything" about a functional program means knowing all of the values of intermediate results
17:06:15 <Baughn> Peaker: Think of compile-time as partially evaluating the program. ;)
17:06:18 <Baughn> Peaker: In fact, please do
17:06:41 <augustss> as that is what it is
17:06:52 <monochrom> I guess { x && y && z; } || { handler; }  will be my exception mechanism. :)
17:06:53 <ddarius> mix(mix,I)
17:06:58 <Baughn> Now if only currying worked with partial evaluation..
17:07:22 <augustss> Baughn: you mean if currying actually used PE?
17:07:30 <ddarius> monochrom: Now write a "Exception Monads In Shell" post... except I think someone already did that.
17:07:42 <Peaker> Baughn, why partially evaluate it, if its purely functional and I have its inputs already?
17:07:46 <monochrom> Everything has been written. :)
17:07:53 <Peaker> Baughn, I can fully evaluate it
17:08:10 <Toxaris> Peaker: my point is that for proving sort correct at compile-time, you need to prove that sort :: list -> sorted list. but at runtime, it is applied to some concrete values, so you only have to prove sort [5, 3, 7] :: sorted list, which is much easier. just apply sort and check the result for being ordered.
17:08:10 <oerjan> adiM: actually you can i think
17:08:14 <augustss> Peaker: because it can be more efficient to partially evaluated it first
17:08:28 <lispy> Cale: ping?
17:08:29 <Baughn> augustss: It would be handy. I've had functions of the form "foo x y = bar y (baz x)", and it would be nice to have (baz x) shared when I pass 'foo x' around
17:08:53 <Peaker> augustss, ok, but that may be a hidden implementation detail of full evaluation
17:09:01 <Baughn> Peaker: You don't have all the inputs. Things like network the value of stdin..
17:09:12 <Baughn> Peaker: Thus, "partial evaluation"
17:09:16 <oerjan> :t S.toList . F.foldMap ?f
17:09:17 <lambdabot> Couldn't find qualified module.
17:09:18 <augustss> Baughn: write it as "foo x = let a = baz x in \ y -> bar y a"
17:09:21 <oerjan> bah
17:09:24 <monochrom> Haha, someone should mimic dons's "programmable semicolon" article, except change it to shell scripting and call it "programmable newline" :)
17:09:28 <oerjan> :t S.toList . Data.Foldable.foldMap ?f
17:09:29 <lambdabot> forall a a1 (t :: * -> *). (Ord a, Data.Foldable.Foldable t, ?f::a1 -> S.Set a) => t a1 -> [a]
17:09:29 <Peaker> Toxaris, so you have the program, but you don't yet have the inputs, you want to prove it for any input of a certain type - that means you don't know "Everything" and is the basis for separation between values and types
17:09:31 <Baughn> augustss: I do, but that /should/ be equivalent
17:09:44 <oerjan> er no
17:09:47 <oerjan> hm...
17:09:48 <augustss> Baughn: semantically it is
17:10:05 <Peaker> Baughn, Yeah, I know - I was just trying to make a point about where the line between values and types is
17:10:05 * ddarius has deja vu
17:10:24 <oerjan> or wait that should work
17:10:29 <Baughn> augustss: I had an awful time figuring out why my parser was O(n^2) instead of O(n), back a year ago. That was why. ;)
17:10:37 <augustss> Baughn: but I agree, PE would be cool to have around.  you just have to apply it at the right time
17:11:57 <oerjan> > S.toList . Data.Foldable.foldMap (\x -> [x..x+10]) $ [1,5..30]
17:11:57 <lambdabot>  Couldn't match expected type `S.Set a' against inferred type `[a1]'
17:12:24 <oerjan> > S.toList . Data.Foldable.foldMap (\x -> S.fromList [x..x+10]) $ [1,5..30]
17:12:25 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:12:32 <oerjan> hm didn't really help
17:13:48 <adiM> oerjan, thanks for the effort, I will need to check foldMap to even start comprehending your attempts
17:14:23 <oerjan> adiM: i'm not sure it is an improvement on S.fromList . concatMap ...
17:14:49 <Toxaris> Peaker: I don't get what you're trying to tell me.
17:16:18 <adiM> Another question. In Haskell, is array memory allocation fixed or dynamic. That is, if I declare an array with 100 enteries, but use only 50, am I wasting space? I need non-rectangular 2D arrays.
17:16:59 <roconnor> adiM: the arrays from Data.Array are static.
17:17:02 <Baughn> adiM: Wasting space. If it is sufficiently sparse, you may want to use data.map instead
17:17:47 <EvilTerran> adiM, alternatively, an array-of-arrays might suit better
17:18:01 <Baughn> adiM: Alternately, laziness would lend itself to simple sparse arrays, such as http://hackage.haskell.org/cgi-bin/hackage-scripts/package/lazyarray-0.1.3
17:18:04 <lambdabot> http://tinyurl.com/2sl5ym
17:18:07 <lispy> Baughn: can you really say it's all allocated up front though?
17:18:13 <Toxaris> roconnor: but their length is not included in the type, so an array-of-arrays could be used to model a non-rectangular 2D array
17:18:23 <Peaker> Toxaris, I may have misunderstood what you are trying to say - you said the type system should describe "everything", in that case, your program has already run
17:18:24 <Baughn> lispy: Me? No, but I'm almost certain it is
17:18:29 <lispy> adiM: I think what's difficult about this question is that some things are only computed (and hence only take up space) when they are needed.
17:18:43 <Peaker> Toxaris, Unless you mean it should describe and prove all requirements - in which case I agree its a huge benefit
17:18:52 <ddarius> For 2D arrays, the term is usually dense and sparse.
17:19:44 <adiM> both data.map and lazyarray look good. I will explore both of them. Thanks
17:19:45 * Baughn wonders how good lazyarray is with sparse arrays
17:20:34 <Toxaris> ddarius: I understand non-rectangular /= sparse. but I may mis-understand it.
17:20:37 <Peaker> Toxaris, I think that proving your sort is correct, and other such things will be much easier with a specialized UI than with syntatic extensions to the language
17:20:45 * EvilTerran agrees with Toxaris
17:20:52 <gwern> lol. the editor comment on http://it.slashdot.org/article.pl?sid=08/03/18/1633229 is 'from the anything-but-haskell dept.'
17:20:53 <Baughn> adiM: In any case arrays are lazy in values, so if you make something like an array of arrays of arrays, only the (entire) array(s) you actually access will be allocated
17:20:53 <lambdabot> Title: Slashdot | What Programming Languages Should You Learn Next?
17:22:28 <Toxaris> Peaker: the type system should be able to describe everything, e.g. I can describe the exact output for a given input, then typechecking = testing. alternatively, i can define a clever type like sorted list and can use a signature like sort :: list -> sorted list, then type-checking = correctness proof.
17:23:11 <adiM> Baughn, for my application an array of array of arrays will be difficult. I think that I can use data.map quite easily, so will go with that
17:24:17 <Baughn> adiM: data.map will be considerably less efficient for dense arrays, and is asymptotically less efficient overall. On the other hand, it does allow updates in O(lg n) time, while (pure) arrays need O(n)
17:24:47 <Toxaris> Peaker: yeah, the state-of-the art in automated theorem proving suggests the language of my dream is not possible yet. good that i'm still young and may live to see it at some point, when I'm too old to leave Haskell and switch to that better language
17:25:14 <Baughn> Toxaris: Lucky, too, that by the time you're that old there will likely be mental flexibility drugs to fix that
17:25:57 <Toxaris> Peaker: but I don't think it's a good idea to suppose Haskell and it's aproach to typing is the end result of programming language evolution
17:26:20 <Peaker> Toxaris, automated theorem proving is not possible, human help is inevitable
17:26:20 <NikkiA> Baughn: they have those already, they're called crosswords, and thats why you see so many retired people doing them religiously :P
17:26:35 <gwern> 'Our submission is in TALx86, a strongly typed functional language that \ encourages an explicit continuation-passing style and supports \ mutually recursive modules. We were encouraged to use this language \ when we learned that the competition would allow us to run our program \ on an interpreter implemented in hardware. We are grateful to the \ Intel Corporation for developing this interpreter....'
17:26:36 <dolio> Clearly it isn't. Dependently typed languages go beyond Haskell.
17:26:44 <Baughn> NikkiA: I'm sure we can do better than that. ;)
17:26:44 <Peaker> Toxaris, You must be careful when you say describe "everything", as "everything" includes a bit too much - that's why I specifically say describe "requirements"
17:26:55 <gwern> yeah, everyone knows Qi has the ultimate type system
17:27:20 <Toxaris> Peaker: ok, more carefully: I want every set of values to be describable as a type.
17:27:57 <augustss> Toxaris: you can have that (with a suitable definition of every)
17:28:46 <Toxaris> Baughn: good to know.
17:29:10 <Baughn> Toxaris: Of course, it might involve uploading
17:29:49 <augustss> Toxaris: if you can describe your set with, say, predicate logic, you've can already have what you're asking for.
17:29:59 <solrize> hey augustss, do you think it's possible to use fancy type systems on implementations of crypto protocols, to get security proofs based on assumptions about the crypto primitives?
17:30:19 <Baughn> solrize: Sure
17:30:26 <augustss> solrize: yes
17:30:28 <gwern> there was an olegfact about just that... :(
17:30:37 <Peaker> Toxaris, I thought about an approach to do that - via "assertion guards" .  A "guard" is runtime if it cannot be proven, or compile-time if its proven.  A guard can be proven on the basis of any other guards in scope and auto-deductions.
17:30:58 <Peaker> Toxaris, By adding intermediate guards, one can help the compiler prove the entire program
17:31:31 <oerjan> @quote rsa.in
17:31:31 <lambdabot> No quotes match. I've seen penguins that can type better than that.
17:31:36 <oerjan> @quote rsa
17:31:36 <lambdabot> byorgey says: if math, haskell :: [Knowledge], the problem with learn $ math ++ haskell (or vice-versa) is that both lists are infinite, so you'll never get to the second one.  Better to do something
17:31:36 <lambdabot> like learn $ zip math haskell.
17:32:00 <oerjan> @quote \<rsa\>
17:32:00 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
17:32:04 <Toxaris> Peaker: sounds like exactly what I'm speaking of. expressive like if-statements, but automatically proven at compile-time (if possible). I can accept the "(if possible)"..
17:32:30 * edwinb is tormenting his CPU with a fancy type system
17:32:39 <edwinb> I hate to think what RSA would do to the poor thing
17:32:52 <oerjan> @quote \<rsa\>
17:32:52 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
17:32:56 <solrize> i wonder how to do it, since the security properties wanted are things like "there is no function that distinguishes this data from random data with probability higher than 0.5+2**-n" (for some parameter n)
17:32:57 <augustss> edwinb: make it hotter
17:33:00 <Baughn> edwinb: RSA is /simple/
17:33:07 <edwinb> augustss: it already is quite hot
17:33:17 <edwinb> I don't need the heating on at the minute
17:33:45 <augustss> solrize: i'm not sure those kind of properties are any easier to prove using types
17:34:11 <solrize> augustss, yeah, that's what i was wondering
17:34:23 <augustss> solrize: besides, your statement is false
17:34:28 <edwinb> might be worth having a go at RSA actually, if it is simple...
17:34:43 <Toxaris> augustss: In a language I'm able to understand and usable for real-world development?
17:35:02 <augustss> solrize: presumable the decryption function can do just that, and it exists
17:35:11 <gwern> edwinb: 'we fight them over there at compile time so we don't have to fight them over here at runtime'?
17:35:17 <Baughn> edwinb: It's simple in the "can be implemented in one line of haskell" sense, sure. Not necessarily.. if you want it fast
17:35:17 <solrize> augustss yeah i misstated it, i need to make assertions about the running time
17:35:31 <augustss> Toxaris: i'm sure you can understand it, but usable for real world development, no
17:36:18 <solrize> basically the starting point is (say) the AES block cipher, which is assumed indistinguishable from a random permutation on Word128
17:36:19 <Toxaris> well, the second is not really the problem, I'm not doing any real world development anyway :)
17:36:32 <augustss> solrize: even with running time, the decryption function does it fast, and it exists.  so you can't prove non-existence
17:36:54 <augustss> Toxaris: look at Agda-2 then
17:37:19 <augustss> Toxaris: or wait for edwinb to finish
17:37:24 <solrize> the decryption function has an unknown parameter and your chance of guessing it is 2**-n  that's where that additive amount comes from
17:37:33 <edwinb> augustss: might be a long wait ;)
17:37:44 <edwinb> it just took 10 minutes to count to 20
17:38:03 <solrize> obviously figuring out how to formalize the statement is the first step ;-)
17:38:10 <augustss> solrize: i understand what you want to prove, i'm just saying that you have to formulate it carefully for it to be true
17:38:21 <solrize> yeah
17:38:48 <oerjan> and you have to prove P/=NP to prove it :)
17:39:23 <solrize> oerjan you're starting from the assumption that you can't distinguish AES from a random permutation.  that by itself implies that you assume P!=NP
17:39:49 <solrize> someone called bringing up P vs NP the Godwin's Law of cryptography ;)
17:40:03 <oerjan> heh
17:40:22 <solrize> anyway even formulating the security statement precisely i don't see how to state that kind of thing using types
17:40:24 * Baughn wonders whether an infinitely fast computer would be able to answer P==NP
17:40:52 <solrize> baughn there's a good article by scott aaronson discussing whether p=np might be independent of set theory
17:41:02 <bd_> Baughn: Since any operation would complete in constant (specifically, zero) time, P==NP in such a machine
17:41:03 <oerjan> Baughn: i think so.  it could guess an algorithm for SAT and test it on all cases.
17:41:18 <mrd> Baughn: well it could simulate an infinite number of computers computing a solution in polynomial time, i imagine
17:41:18 <Toxaris> Baughn: I read about something like this recently. an article about what a time-machine would do to computing.
17:41:19 <solrize> er, hmm, all cases ... ?  i guess.
17:41:28 <Peaker> An article by some quantum computing researcher postulates that maybe NP'ness is a physical property of the universe
17:41:31 <Pseudonym> There's a paper I saw some time ago which suggested tht any proof that P /= NP would, if it existed, be intractable.
17:41:42 <solrize> yeah, same guy, article in scientific american last month
17:41:44 <Baughn> Toxaris: The moravec computer? That doesn't actually manage /infinite/ computation, just.. exponential
17:41:49 <oerjan> solrize: infinite he said :)
17:41:55 <idnar> heh
17:41:57 <gnuvince1> Is there a library path variable that one must set to use libs that are not in the ghc-6.8.2/lib directory?
17:42:14 <Baughn> oerjan: That was my thinking, yes
17:42:15 <Pseudonym> An infinitely fast computer could solve NP-hard problems instantaneously.
17:42:16 <solrize> the thing is a time-machine computer with finite memory could only decide stuff in PSPACE
17:42:40 <Baughn> Pseudonym: Right, so imagine it's an infinitely fast computer that is only able to answer famous math questions
17:42:42 <Pseudonym> If nothing else, Claude Shannon would be really annoyed.
17:42:46 <Peaker> what is the class name of the class of the Halting Problem?
17:42:49 <solrize> there's a cute series of papers by Joel Hamkins about infinitely powerful computers, that can compute on transfinite ordinals
17:42:56 <Baughn> Pseudonym: No /particular/ instance of the problems are famous, therefore it can'T solve them
17:43:00 <oerjan> bd_: that would mean the P=NP with oracle question (which is known to vary with the oracle).  i assume Baughn meant solving the basic one.
17:43:14 * Baughn did, yes.
17:43:15 <solrize> so hmm, i guess one of those could resolve p vs np
17:43:36 <solrize> but that doesn't seem right, if it's independent ...
17:43:36 <gwern> gnuvince1: what mannger of libs?
17:43:36 <gwern> *manner
17:43:58 <Pseudonym> See, the infinitely fast computer could check all P-sized proofs to see if any of them are a proof that P /= NP.
17:44:11 <solrize> that wouldn't take infinite speed, just very fast finite speed :)
17:45:40 <Baughn> Isn't there an infinite number of possible proofs?
17:46:11 <EvilTerran> countable, tho. so an infinitely fast computer could do it
17:46:16 <solrize> augustss -- anyway yeah my basic question was whether that kind of property could be expressed in some reasonable using types.  and the idea is that type checking integrates better into programming languages than other kinds of theorem proving.  but i know squat about this stuff
17:47:10 <gnuvince1> gwern: I'm trying to build lambdabot on my computer.  It says that a few packages are missing.  I installed arrows-0.4 with cabal-install, but Setup.hs configure still says I don't have it installed.
17:47:36 <Baughn> gnuvince1: You need to edit the build script to pass --user to configure
17:47:37 <solrize> baughn yeah, and there is a situation where a proof of something in pure arithmetic (PA) is extremely long, like towers of exponentials, but if you assume PA is consistent then the proof becomes a lot shorter
17:47:42 <nibro> 7quit
17:47:44 <Baughn> gnuvince1: Well, setup.hs configure that is
17:48:05 <gwern> gnuvince1: ah. sounds like you need --user
17:48:17 <Baughn> solrize: Still, you couldn't be /certain/ there isn't a proof without checking all of them
17:48:25 <gnuvince1> Cool
17:48:30 <gwern> fwiw, I have 'configure' as an alias to 'runhaskell Setup configure --verbose=2 --user --prefix=$HOME/bin --datadir=$HOME/bin/share'
17:48:31 <gnuvince1> That looks like it.
17:48:37 <solrize> baughn, right
17:48:46 <Baughn> solrize: ..it would be troubling if, after doing all that, it turns out that it's unprovable
17:49:00 <solrize> i wonder whether limiting the size of the proofs checked means you miss something though
17:49:28 <solrize> i mean it could have a short proof in PA + CON(PA) + CON(PA+CON(PA)) + ...
17:50:10 <gwern> I think godel said if you had a proof checking machine, you could set it to an absurdly high constant; any proofs it missed which were longer than that, 'would thereby be shown to not be of interest to humanity' (I paraphrase)
17:50:10 <Baughn> CON?
17:50:11 <Peaker> Toxaris, The idea is that with a specialized UI for code editing, you can have the proofs occur at edit-time, so you can see "red assertions" and "green assertions" for run-time, and compile-time respectively. And then you can add intermediate ones that become red/green until you greenify all of them
17:50:22 * SamB wonders about a gentler version of % screen -D -R jhc
17:50:27 <solrize> CON(PA) = a statement that PA is consistent (does not prove contradictions)
17:50:40 <Baughn> solrize: screen -xRR?
17:50:45 <solrize> sorry ?
17:50:47 <lispy> SamB: gentler in what way?
17:50:47 <Baughn> *sam
17:50:50 <solrize> oh
17:50:56 <ddarius> solrize: You can use pretty much any logic you like for a type system so you can formalize whatever you like.
17:50:57 <Toxaris> Peaker: sounds like unifying edit-time and compile-time, like e.g. eclipse does for Java
17:51:01 <lispy> SamB: -rd is my typical way to use screen
17:51:05 <gwern> kind of like the quote that the 4-color theorem being ultimately solved by brute force demonstrated it was a problem of little relevance to mathematics
17:51:20 <Peaker> Toxaris, Yeah, and if you add examples -- you can also unify run-time
17:51:36 <Baughn> gwern: There is no proof that there isn't a much shorter proof of 4ct to be had, though
17:51:40 <Peaker> Toxaris, (examples and "hypothetical futures")
17:51:46 <lispy> gwern: Not so fast.  Just because we need a machine to check the proof doesn't mean it's suddenly not relevant to mathematics.
17:52:17 <Toxaris> Peaker: but i don't want to fully unify run-time, i want to produce a executable program for my clients, at the end of the process. well, I suppose that's what professional programmers want to do :)
17:52:18 <lispy> gwern: I'd say it just means we're lazy :)
17:52:26 <SamB> lispy: not killing the xterm in which I had previously run it?
17:52:44 <gwern> lispy: godel said it, not I, although I do agree that having a proof of problems whose shortest proof require millions/billions etc of symbols would not advance mathematics
17:52:50 <Peaker> Toxaris, Well, Excel unifies edit, compile and run-time, and you can still send excel programs to your clients :)
17:53:02 <lispy> SamB: oh, I've never had screen kill a terminal.
17:53:06 <Peaker> Toxaris, Ofcourse the unification of runtime is not as true as its just a specific case of runtime
17:53:13 <SamB> I guess it's probably not screens fault
17:53:15 <Baughn> SamB: That's what -x is for
17:53:19 <SamB> my xterms seem really flimsy lately
17:53:24 <Baughn> SamB: So, as I said, screen -xRR
17:53:33 <SamB> Baughn: I *do* want the prior instance to disappear
17:53:40 <SamB> I *don't* want the xterm to vanish
17:53:44 <Toxaris> Peaker: yeah, excel is very special, but maybe more programming languages should be like excel. it seems to be easy to learn for a lot of people
17:53:46 <lispy> SamB: then try -rd, I don't like -x either
17:53:48 <Baughn> SamB: Then you should make xterm stop crashing when applications quit
17:54:05 <lispy> Excel is an FP language
17:54:08 <ddarius> Toxaris: The trick is to not call it a programming language.
17:54:33 <solrize> @faq can i write a high speed sorting utility in haskell ?
17:54:33 <lambdabot> The answer is: Yes! Haskell can do that.
17:54:36 <solrize> hehe
17:54:50 <Toxaris> gwern: isn't every solvable problem solvable by brute force?
17:54:55 <lispy> Use randomized search + monadrandom!
17:54:57 <Peaker> Toxaris, Just have Haskell code run on examples all the time - and you've got something like Excel, making it more approachable for people
17:55:12 <bd_> @faq can I write an embedded OS to fit within 1024 bytes in haskell?
17:55:12 <lambdabot> The answer is: Yes! Haskell can do that.
17:55:14 <ddarius> @where vital
17:55:14 <lambdabot> http://www.cs.kent.ac.uk/projects/vital/
17:55:14 <solrize> toxaris -- graph minor theorem
17:55:46 <ddarius> bd_: Look at Virgil.
17:55:53 <lispy> ?faq Can I write type incorrect code and cause my program to segfault at run-time?
17:55:53 <lambdabot> The answer is: Yes! Haskell can do that.
17:56:00 <solrize> lol
17:56:06 <ddarius> Quite easily too.
17:56:08 <gwern> Toxaris: not if you want termination, iirc, although we're both being awfully informal :) (the distinction between bounded and unbounded loops)
17:56:20 <bd_> ddarius: virgil?
17:56:25 <gwern> lispy: dovetail searches are cooler!
17:56:53 <Peaker> ddarius, how?
17:57:06 <bd_> ?faq Can a haskell library function determine whether an arbitrary turing machine with a finite number of states halts?
17:57:06 <lambdabot> The answer is: Yes! Haskell can do that.
17:57:11 <bd_> :o!
17:57:12 <SamB> @faq can I write code that segfaults the typechecker?
17:57:12 <lambdabot> The answer is: Yes! Haskell can do that.
17:57:20 <Baughn> gwern: Soo... maybe this universe is actually running in an infinitely powerful dovetail-using solver trying to figure out if p=np
17:57:32 <Baughn> gwern: And the moment we find the answer, the universe ends
17:58:03 <glen_quagmire> isn't it n = np ?
17:58:13 <glen_quagmire> no crap. it's p = np
17:58:19 <Peaker> n=np if n==1 or p==0 :)
17:58:28 <Baughn> @faq Can haskell solve a problem so horrible not even haskell can solve it?
17:58:28 <lambdabot> The answer is: Yes! Haskell can do that.
17:58:30 <solrize> divide both side by p,   it means n = 1
17:58:37 <Peaker> oops, p=np if..
17:58:42 <solrize> yeah :)
17:59:03 <glen_quagmire> p = np means n is identity function
17:59:12 <gwern> Baughn: you know, the neat thing about dove-tail models of the multiverse is that they have a kolgmorov complexity of practically zilch; the tradeoff is then induction becomes an even harder philosophical question
17:59:16 <bd_> ?faq Can I build a quantum computer by forking RealWorld#?
17:59:16 <lambdabot> The answer is: Yes! Haskell can do that.
17:59:20 <lispy> ?vixen sometimes I feel like you're just a "yes" woman
17:59:21 <lambdabot> yup, i'm all woman
17:59:31 <Baughn> gwern: I've been reading the everything-list, if that tells you anything. I'm aware.
17:59:50 <Peaker> Can lambdabot pass the Turing test?
17:59:53 <glen_quagmire> ?vixen why aren't you announcing hpaste posts?
17:59:53 <lambdabot> why anything?
17:59:55 <gwern> Baughn: aw :(
18:00:45 <Baughn> gwern: That said, I keep wondering whether the lack of any obvious mechanism to avoid everyone being zombies in _this_ universe could be because this universe is, in fact, a simulation and the lower-level one makes it entirely obvious
18:01:22 <glen_quagmire> zombies are creepy. but capitalism essentially creates zombies
18:01:29 <gwern> Baughn: that adds on complexity unfortunately
18:01:37 <oerjan> !paste
18:01:37 <hpaste> Haskell paste bin: http://hpaste.org/
18:01:53 <Baughn> gwern: It falls under the general heading of anthropic complexity
18:02:16 <hpaste>  oerjan pasted "Testing announce" at http://hpaste.org/6489
18:02:24 <gwern> unless you want to use bostrom's simulation arg
18:02:43 <Baughn> ...the time period /is/ disturbingly interesting, yes
18:02:57 <hpaste>  glen_quagmire pasted "testing II" at http://hpaste.org/6490
18:03:02 <glen_quagmire> oh it works now
18:03:23 <glen_quagmire> maybe hpaste wasn't here when I pasted before
18:03:48 <glen_quagmire> i thought lambdabot was ignoreing me (didn't know about hpaste bot)
18:04:09 <oerjan> @vixen Are you ignoring glen_quagmire?
18:04:09 <lambdabot> is that really what you want to know?
18:04:20 <ddarius> @google virgil objects on the head of a pin
18:04:21 <lambdabot> http://compilers.cs.ucla.edu/virgil/virgil-oopsla06.pdf
18:04:26 * edwinb cries at the profiler
18:04:34 <edwinb> apparently 100% of my program is spent inside MAIN.
18:04:37 <ddarius> Peaker: unsafeCoerce
18:04:43 <edwinb> who'd 'a thought it...
18:04:44 <ddarius> edwinb: Congratulations!
18:04:52 <Peaker> ddarius, that's not type-unsafety..
18:05:49 <Baughn> You people need to stop linking to interesting papers. I'm up to seventy unread ones. :'(
18:06:13 <Peaker> Haskell makes me read a lot too :(
18:06:33 <Peaker> its the first time my progress bottleneck is the speed I can pour information into my brain
18:06:34 <glen_quagmire> i read very slowly
18:06:52 <ddarius> Baughn: How big is your library of papers read and unread?
18:07:32 <ddarius> glen_quagmire: Marry a beautiful woman and have her read to you.
18:07:37 <Baughn> ddarius: 71 unread, at least a hundred read
18:07:48 <SamB> edwinb: that just means that your program is long enough running to make the load cost vanishingly small
18:08:03 <ddarius> Baughn: You have a long ways to go then...
18:08:10 <SamB> actually I bet it doesn't mean that even
18:08:35 <Baughn> ddarius: Well aware, yes. It's the most interesting part of the game.
18:08:43 <lispy> ddarius: heh, interesting solution to the slow reading problem.
18:09:04 <glen_quagmire> i'll marry a beautiful woman and stop reading
18:10:10 <joricj> what does "fix" do? i'm trying to read through the example on http://www.haskell.org/haskellwiki/Implement_a_chat_server
18:10:11 <lambdabot> Title: Implement a chat server - HaskellWiki
18:10:18 <SamB> glen_quagmire: you expect her to read all that stuff to you?
18:10:25 <Baughn> @src fix
18:10:25 <lambdabot> fix f = let x = f x in x
18:10:27 <SamB> how do you read two-dimensional code aloud?
18:12:31 <Saizan> joricj: see that as let loop = do ... in loop
18:12:40 <joricj> i still don't understand it, i mean it look like it will compute (f (f (f (f ...)))) infinitely (i guess with lazy programming that's okay) but how do you use it
18:13:02 <Saizan> fix is used for anonymous recursion
18:13:05 <Baughn> joricj: It works if f produces some output before going on to examine x
18:13:25 <ddarius> fix is used for obfuscation
18:13:26 <joricj> forkIO $ fix $ \loop -> do           (_, msg) <- readChan chan                  loop
18:13:33 <lispy> joricj: try this example
18:13:34 <Saizan> > let fac f n = if n == 0 then 1 else n * f (n-1) in fix fac 5
18:13:35 <lambdabot>  120
18:13:35 <lispy> > fix show
18:13:36 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
18:13:37 <Baughn> joricj: Could be a list, for example.. you'll get an infinite list, with x as the theoretical last element
18:14:01 <joricj> ah ok
18:14:02 <wkh> eschew all obsfucatory diction
18:14:15 <lispy> > fix (\fibs -> 1 : 1 : zipWith (+) fibs (tail fibs))
18:14:15 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
18:14:28 <Saizan> joricj: yeah, that's the same as forkIO $ let loop = do (_,msg) <- readChan chan; loop in loop
18:14:29 <Baughn> > fix (1:) :: Expr
18:14:29 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[t]'
18:14:44 <lispy> > fix (\fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)) :: Expr
18:14:45 <lambdabot>  Couldn't match expected type `Expr' against inferred type `[a]'
18:14:55 <lispy> > fix (\fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)) :: [Expr]
18:14:56 <lambdabot>  [1,1,1 + 1,1 + (1 + 1),1 + 1 + (1 + (1 + 1)),1 + (1 + 1) + (1 + 1 + (1 + (1 ...
18:15:01 * Baughn is pretty sure Expr is just a Num instance. Oh well.
18:15:06 <SamB> joricj: it actually just passes the value a function is *going* to return as the argument for the call it was going to return it from
18:15:13 <joricj> Saizan: so what it does is it starts a thread to read from the channel forever?
18:15:16 <SamB> that's all
18:15:19 <ddarius> > fix f
18:15:19 <lambdabot>  Add a type signature
18:15:21 <SamB> nothing the least bit odd about that
18:15:22 <lispy> Baughn: it's a bit more than that because it can do functions to
18:15:35 <ddarius> > fix f :: Expr
18:15:36 <lambdabot>  f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f...
18:15:50 <lispy> ?src fix
18:15:50 <lambdabot> fix f = let x = f x in x
18:15:59 <Baughn> I see
18:16:00 <joricj> mind boggling
18:16:14 <lispy> joricj: I found it really helped to understand 'fix show'
18:16:28 <Baughn> joricj: If it helps, try thinking in terms of thunks
18:16:29 <ddarius> fix show is really cute
18:16:35 <wkh> > fix show
18:16:36 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
18:16:37 <lispy> > take 10 . map length . fix $ show
18:16:37 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
18:16:43 <wkh> i don't get it.
18:17:01 <lispy> > take 10 . map length $ fix show
18:17:01 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
18:17:10 <roconnor> showing a string starts with " no matter what
18:17:16 <Baughn> wkh: show returns a list. The /first/ element of that list is '"', and gets returned before it gets around to looking at its parameter. That seeds the recursion..
18:17:29 <roconnor> so the first caracter of itself is ", which is shown as \"
18:17:37 <roconnor> so the string begins "\"
18:17:41 <joricj> > fix cos
18:17:42 <lambdabot>  Exception: <<loop>>
18:17:44 <roconnor> the next character is \
18:17:49 <roconnor> which is printed as \\
18:17:54 <roconnor> so we get "\"\\
18:18:03 <oerjan> joricj: cos is strict, it cannot return anything without looking at its argument
18:18:11 <roconnor> then the quote again is printed as \"
18:18:17 <roconnor> so we get "\"\\\"
18:18:21 <roconnor> etc.
18:18:28 <Saizan> joricj: apparently, yes
18:18:36 <joricj> i'm starting to understand how fix show does the thing ... because it cannot ever return the entire value but it can return a part of it
18:18:50 <oerjan> > (*) 2pi -- something i wanted to check
18:18:51 <lambdabot>  6.283185307179586
18:18:53 <roconnor> the special thing about show it that it can output a " before it knows anything about the string being printed.
18:18:57 <Baughn> joricj: Two things are required for fix to work. First, the function needs to return *some* information before it starts reading its argument; second, the argument must be sufficiently lazy that that bit of data will be just enough for it to start computing the function, producing more data for the function, so on, so forth..
18:19:28 <jao> hmmm, cabal-install does not build in my machine: Hackage/ParseUtils.hs:7:36:
18:19:28 <jao>     Module `Distribution.ParseUtils' does not export `parseDependency'
18:19:42 <Baughn> joricj: (Lazy in just the right way, too)
18:19:46 <joricj> Baughn: i don't understand the second thing
18:19:48 <roconnor> the special thing about the result of fix show is that if you were to show it, you'd get the exact same string.
18:19:56 <lispy> > take 20 . map length . group . fix $ show
18:19:58 <Baughn> jao: You need to upgrade to the newest (unreleased) version of cabal
18:19:58 <lambdabot>  [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023]
18:20:00 <roconnor> > fix show
18:20:01 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
18:20:06 <roconnor> > show (fix show)
18:20:06 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
18:20:11 <jao> Baughn: i already did
18:20:24 <Baughn> jao: 1.3.7?
18:20:33 <oerjan> > iterate show ""
18:20:34 <lambdabot>  ["","\"\"","\"\\\"\\\"\"","\"\\\"\\\\\\\"\\\\\\\"\\\"\"","\"\\\"\\\\\\\"\\\\...
18:20:34 <jao> Baughn: yes...
18:20:39 <Baughn> jao: And run setup.hs with --user if that's where it was installed
18:20:56 <jao> Baughn: no, i installed it globally
18:21:07 <Baughn> roconnor: That's why it's called "fixed point", I should hope
18:21:16 <oerjan> > flip id 1exp
18:21:16 <lambdabot>  Float with missing exponent at "1exp" (column 9)
18:21:27 <oerjan> whoops
18:21:37 <Toxaris> roconnor: is this property related to show, or only to fix?
18:21:38 <oerjan> was not that smart
18:21:58 <joricj> thx guys
18:22:00 * oerjan thinks that may technically be a bug
18:22:08 <roconnor> the output of fix f is always some x such that  x and f x are the same.
18:22:09 <lispy> ?check \f -> f (fix f) == fix (f :: Int -> Int)
18:22:10 <lambdabot>  Exception: stack overflow
18:22:26 <roconnor> even fix cos has this property
18:22:36 <Baughn> jao: Hum. I'll figure it out if you give me.. ten minutes
18:22:37 <roconnor> fix cos is undefined.
18:22:41 <ddarius> > cos undefined
18:22:42 <lambdabot>  Undefined
18:22:43 <ddarius> > undefined
18:22:43 <roconnor> and cos undefined is undefined.
18:22:44 <lambdabot>  Undefined
18:22:56 <lispy> ?scheck \f -> f (fix f) == fix (f :: Int -> Int)
18:22:57 <lambdabot> Exception: stack overflow
18:23:00 <bd_> roconnor: to be precise it's the bottom. It may well be nontermination as well, you see.
18:23:04 <bd_> > fix cos
18:23:04 <lambdabot>  Exception: <<loop>>
18:23:05 <EvilTerran> fix finds the least fixed point, and _|_ is the least value
18:23:08 <jao> Baughn: sure. i have also the old cabal, btw
18:23:11 <roconnor> right, I mean bottom
18:23:21 <jao> Baughn: the one that comes with ghc 6.8.2
18:23:30 <roconnor> notice that show (undefined:string) is not undefined.
18:23:31 <Saizan> jao: that's because of a recent patch in the cabal repo which has moved Dependecy
18:23:36 <joricj> > fix (*2)
18:23:37 <lambdabot>  Exception: <<loop>>
18:23:41 <roconnor> > show (undefined :: string)
18:23:42 <lispy> ?quote largos.*c++
18:23:42 <lambdabot>  Undefined
18:23:42 <lambdabot> No quotes match. Wrong!  You cheating scum!
18:23:45 <lispy> ?quote largos
18:23:45 <lambdabot> largos says: [on programming languages] "...and I'd rather not own as much rope as c/c++ gives you."
18:23:45 <joricj> why doesn't it return 0?
18:23:49 <Saizan> jao: and cabal-install has not been updated yet to match that
18:23:52 <roconnor> > show (undefined :: String)
18:23:53 <lambdabot>  Undefined
18:23:55 <Baughn> jao: What he said. You could unpull the last six patches in your cabal repository for a quick fix
18:23:58 <bd_> roconnor: it is undefined :)
18:24:04 <ddarius> > head $ show (undefined :: String)
18:24:05 <lambdabot>  '"'
18:24:06 <roconnor> damn you lambdabot!
18:24:08 <bd_> roconnor: how should show (nontermination) work? :)
18:24:10 <Baughn> jao: (Until the "move dependency and its show and parser.." bit)
18:24:11 <EvilTerran> joricj, because _|_ is a lesser fixed point than 0
18:24:13 <roconnor> you are screwing up my story
18:24:23 <bd_> roconnor: it'd need to solve the turing problem to display the bottom
18:24:30 <joricj> EvilTerran: what does lesser mean?
18:24:37 <bd_> however, there can certainly be multiple fixed points for a given function
18:24:39 <EvilTerran> contains less information
18:24:44 <oerjan> joricj: _|_ is lesser than everything, so if it is a fixpoint, it will be returned
18:24:44 <jao> Baughn: aha... do you know f it will be long until cabal-install catches up? (i'm in no hurry)
18:24:50 <roconnor> show (undefiend::String) should print a " and then hang
18:24:55 <Toxaris> joricj: 0 is a fixed point of (* 2), but not the least fixed point. how should the computer be able to guess that you want 0?
18:24:58 <Baughn> jao: Eh, probably by tomorrow
18:25:09 <bd_> roconnor: ah
18:25:17 <bd_> show (fix id)
18:25:19 <bd_> > show (fix id)
18:25:19 <lambdabot>  Exception: <<loop>>
18:25:22 <Baughn> jao: If you're on linux/x86_64, you could use http://brage.info/~svein/cabal until then. Precompiled cabal-install there.
18:25:23 <oerjan> roconnor: it does in other places.  lambdabot looks at a longer part of the string before showing any
18:25:29 <jao> Baughn: ok, thanks
18:25:37 <bd_> oh, lambdabot is discarding the partial result, gotcha
18:25:43 <Toxaris> > "roconnor: lambdabot has special undefined handling" ++ undefined
18:25:44 <lambdabot>  Undefined
18:25:45 <roconnor> Prelude> show (undefined::String)
18:25:46 <roconnor> "\"*** Exception: Prelude.undefined
18:25:48 <EvilTerran> joricj, haskell can only work out a partial part of the result if it can do so without evaluating the same part in the result of the recursive call
18:26:20 <roconnor> of if you rather:
18:26:26 <roconnor> Prelude> print (undefined::String)
18:26:26 <roconnor> "*** Exception: Prelude.undefined
18:26:32 <EvilTerran> because otherwise you have a circular data dependency, being the declarative equivalent of an infinite loop
18:26:45 <roconnor> so this is why bottom isn't a fixed point of show.
18:27:12 <Baughn> joricj: Fortunately, the (threaded?) runtime is smart enough to crash when this happens
18:27:22 <joricj> i take it a declarative loop is something like foo=foo? (i'm sorry i'm kinda new to this)
18:27:37 <lispy> > let foo = foo in foo
18:27:38 <lambdabot>  Exception: <<loop>>
18:27:45 <EvilTerran> joricj, exactly
18:27:48 <Baughn> joricj: Yes. Or x=x+1, or anything like that
18:27:52 <EvilTerran> it can't work out foo without working out, er, foo
18:28:09 <Baughn> joricj: Where the evaluation of one thunk depends on the evaluation of the same thunk
18:28:15 <EvilTerran> and, if you expand the definition of fix
18:28:15 <EvilTerran> ?src fix
18:28:15 <lambdabot> fix f = let x = f x in x
18:28:19 <Toxaris> Baughn: the behaviour of x = x + 1 depends on Num instance choosen :)
18:28:42 <EvilTerran> and you get such a circular thunk dependency, fix f is _|_
18:28:55 <Baughn> Toxaris: Fortunately there are list-based implementations in the Prelude
18:28:56 <EvilTerran> (or something containing a _|_)
18:28:59 <Baughn> *are no
18:30:08 <joricj> > let foo = foo:foo in foo
18:30:09 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
18:30:09 <lambdabot>       Expected...
18:30:21 <joricj> > let foo = 1:foo in foo
18:30:22 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:30:31 <joricj> > let foo = foo:1 in foo
18:30:31 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
18:30:31 <lambdabot>       Expected...
18:30:49 <Baughn> > let foo = foo ++ 1 in foo -- That what you meant?
18:30:50 <lambdabot>  Add a type signature
18:31:13 <EvilTerran> note that that's "let (foo :: [a]) = (foo :: a):1 in foo", once the typechecker's been through
18:31:25 <joricj> > let foo = foo:foo in fix foo
18:31:25 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
18:31:25 <lambdabot>       Expected...
18:31:57 <Baughn> joricj: You're requiring foo to be both a list and the elements of said list. Won't work.
18:32:00 <EvilTerran> the first element of a list cannot be the same type as the list itself
18:32:06 <EvilTerran> ?type \x y -> x:y
18:32:07 <lambdabot> forall a. a -> [a] -> [a]
18:32:53 <EvilTerran> first parameter's a different type from the return value
18:32:53 <Baughn> joricj: Also, fix takes a function, not a list
18:33:04 <EvilTerran> if a = [a], then they're both infinite types
18:33:06 <joricj> oh yeah
18:33:35 <lispy> > fix (1:)
18:33:36 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:33:51 <lispy> > let ones = 1:ones in ones
18:33:52 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:33:57 <joricj> > fix (:1)
18:33:57 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
18:33:57 <lambdabot>       Expected...
18:34:15 <wkh> > (1:)
18:34:15 <Baughn> > fix (\x -> 1 : (head x + 1))
18:34:15 <lambdabot>  <[Integer] -> [Integer]>
18:34:16 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
18:34:16 <lambdabot>       Expected...
18:34:24 <lispy> > fix ([1]++)
18:34:25 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:34:30 <lispy> > fix (++[1])
18:34:31 <lambdabot>  Exception: <<loop>>
18:34:34 <wkh> <- noob/nub
18:34:40 <lispy> :t nub
18:34:41 <lambdabot> forall a. (Eq a) => [a] -> [a]
18:34:50 <Baughn> > fix (\x -> 1 : (head x + 1) : x)
18:34:50 <lambdabot>  [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2...
18:34:52 <lispy> wkh :: forall a. (Eq a) => [a] -> [a] ;)
18:34:55 <wkh> this is like. my 4th try learning haskell.
18:35:04 <joricj> > nub [1, 2, 3]
18:35:05 <lambdabot>  [1,2,3]
18:35:09 <Baughn> > fix (\x -> 1 : map (+1) x)
18:35:09 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:35:24 <Toxaris> > nub [1, 1, 2, 2, 3, 3, 2, 1]
18:35:25 <lambdabot>  [1,2,3]
18:35:26 <lispy> > nub [1,1,2,3,2,1,3,2]
18:35:26 <lambdabot>  [1,2,3]
18:35:27 <joricj> > nub [1, 2, 3, 1, 2, 2, 4, 1, 0, 100]
18:35:27 <lambdabot>  [1,2,3,4,0,100]
18:36:01 <lispy> ?djinn (Eq a) => [a] -> [a]
18:36:01 <lambdabot> f a = a
18:36:09 <Baughn> > fix (\x -> 1 : map (+1) x) !! 1000
18:36:10 <lambdabot>  1001
18:36:16 <Baughn> > fix (\x -> 1 : map (+1) x) !! 100000
18:36:16 <lambdabot>  100001
18:36:22 <Baughn> > fix (\x -> 1 : map (+1) x) !! 10000000
18:36:24 <lambdabot>  Terminated
18:36:55 <Baughn> ..I'm /almost/ certain that list takes quadratic time, though. Oh well.
18:37:37 <Baughn> > fix (\x -> 1 : map (+1) x) :: [Expr]
18:37:37 <lambdabot>  [1,1 + 1,1 + 1 + 1,1 + 1 + 1 + 1,1 + 1 + 1 + 1 + 1,1 + 1 + 1 + 1 + 1 + 1,1 +...
18:38:04 <Baughn> ..had to be, but is there sharing?
18:38:38 <ddarius> Extending Expr to expose sharing is left as an exercise to the reader.
18:38:54 <kbateman> > fix (+1)
18:38:54 <lambdabot>  Exception: <<loop>>
18:38:59 <lispy> Baughn: and you will do your homework, won't you?
18:39:33 <kbateman> fix ((1 -) . sin)
18:39:36 <Baughn> lispy: If only I had homework in haskell..
18:39:40 <kbateman> > fix ((1 -) . sin)
18:39:40 <lambdabot>  Exception: <<loop>>
18:40:12 <kbateman> > fix cos
18:40:13 <lambdabot>  Exception: <<loop>>
18:40:27 <wagle_home> fix const
18:40:32 <wagle_home> > fix const
18:40:32 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
18:40:32 <lambdabot>     Probabl...
18:40:45 <lispy> > const fix
18:40:45 <lambdabot>  Add a type signature
18:40:54 <ddarius> BYK=I
18:41:11 <dolio> > fix . const $ 5
18:41:12 <lambdabot>  5
18:42:25 <lispy> > fix . const $ show
18:42:26 <lambdabot>  <() -> [Char]>
18:42:51 <lispy> > fix . const $ show ()
18:42:52 <lambdabot>  "()"
18:43:00 <Baughn> @pl fix . const
18:43:00 <lambdabot> id
18:43:07 <lispy> > fix . const $ show :: Expr
18:43:08 <lambdabot>  Couldn't match expected type `Expr'
18:43:29 <joricj> what's the diffrence between $ and $!?
18:43:35 <joricj> i mean $!
18:43:35 <ddarius> @src ($)
18:43:35 <lambdabot> f $ x = f x
18:43:39 <lispy> ?scheck \x -> fix . const $ x == (x :: Int)
18:43:40 <ddarius> @src ($!)
18:43:40 <lambdabot>   Completed 13 test(s) without failure.
18:43:40 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
18:43:51 <ddarius> f $! x = x `seq` f x
18:44:04 <joricj> @src seq
18:44:04 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
18:44:08 <lispy> joricj: one is 'stricter' than the other
18:44:23 <joricj> @src (seq)
18:44:23 <lambdabot> Source not found. You type like i drive.
18:44:33 <lispy> :t seq
18:44:34 <lambdabot> forall a t. a -> t -> t
18:44:44 <lispy> > undefined `seq` 1
18:44:45 <lambdabot>  Undefined
18:44:56 <EvilTerran> seq :: !a -> b -> b; seq _ x = x
18:45:00 <lispy> > let f x y = y in undefined `f` 1
18:45:01 <lambdabot>  1
18:45:05 <oerjan> joricj: f $! x  evaluates x even if f doesn't use it
18:45:10 <lispy> joricj: do you see the difference between seq and f?
18:45:39 <nolrai_> > fix (\list -> 1:list)
18:45:40 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:45:50 <oerjan> @src iterate
18:45:50 <lambdabot> iterate f x =  x : iterate f (f x)
18:45:58 <oerjan> @pl iterate f x =  x : iterate f (f x)
18:45:58 <lambdabot> iterate = fix ((ap (:) .) . ((.) =<<))
18:46:08 <oerjan> good grief
18:46:21 <oerjan> @pl itf x =  x : itf (f x)
18:46:21 <lambdabot> itf = fix (ap (:) . (. f))
18:46:31 <ddarius> iterate f = iterate f . f
18:46:46 <ddarius> uh + a cons...
18:46:53 * Baughn would like to see an IOHCC
18:46:54 <lispy> iterate and fix are related of course
18:47:04 <oerjan> Baughn: there have been three i hear
18:47:08 <ddarius> @wiki IOHCC
18:47:08 <lambdabot> http://www.haskell.org/haskellwiki/IOHCC
18:47:17 <joricj> > let f x = 1 in f $ undefined
18:47:18 <lambdabot>  1
18:47:22 <joricj> > let f x = 1 in f $! undefined
18:47:22 <lambdabot>  Undefined
18:47:28 <ddarius> @google IOHCC
18:47:30 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation/IOHCC_2004
18:47:30 <lambdabot> Title: Obfuscation/IOHCC 2004 - HaskellWiki
18:47:38 <EvilTerran> ?type fix \it f -> f : it f
18:47:39 <lambdabot> parse error on input `\'
18:47:43 <EvilTerran> ?type fix$ \it f -> f : it f
18:47:44 <lambdabot> forall a. a -> [a]
18:48:20 <nolrai_> > fix (1 :)
18:48:21 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:48:33 <EvilTerran> ?type fix$ \it -> (:) <*> it
18:48:34 <lambdabot> forall a. a -> [a]
18:48:46 <EvilTerran> ?type fix $ ap (:)
18:48:47 <lambdabot> forall a. a -> [a]
18:48:54 <EvilTerran> there's iterate
18:48:56 <EvilTerran> :)
18:49:20 <lispy> boy, that use of ap is tricky
18:49:27 <EvilTerran> that's actually quite pretty, imo
18:49:34 <EvilTerran> lispy, it's the S combinator :D
18:49:35 <ddarius> :t iterate
18:49:36 <lambdabot> forall a. (a -> a) -> a -> [a]
18:49:43 <ddarius> :t fix $ ap (:)
18:49:44 <lambdabot> forall a. a -> [a]
18:49:47 <EvilTerran> ... that's not iterate. what've i done.
18:49:54 <ddarius> Probably repeat
18:50:00 * EvilTerran hides. i'm a silly person.
18:50:09 <ddarius> > fix (ap (:)) 3
18:50:09 <Baughn> @ty ap
18:50:10 <lambdabot>  [3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3,3...
18:50:10 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:50:10 <joricj> i get what $! does now but i still don't understand what it does in the code "mainLoop sock chan $ nr+1", isn't it superfluous?
18:50:11 <EvilTerran> > ap (:) `fix` 1
18:50:12 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:50:38 <joricj> i mean "chan $! nr+1", i copy pasted it wrong
18:50:41 <ddarius> @wiki Stack overflow
18:50:41 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
18:51:13 <Toxaris> joricj: the $! takes care that nr is increment before calling mainLoop again
18:51:40 <Toxaris> joricj: without $!, nr would be increment when first accessed
18:52:11 <byorgey> in other words you could end up with something like mainLoop sock chan (((((((1+1)+1)+1)+1)+.....
18:52:12 <EvilTerran> > fix (ap (liftA2 (:)) . ((.) =<<)) (+1) 0
18:52:12 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:52:13 <nolrai_> > fix ((1 :) . map (+1))
18:52:13 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
18:52:16 <byorgey> without the $!
18:52:27 <EvilTerran> ta-dah!
18:52:36 <EvilTerran> now it's ugly.
18:52:45 <EvilTerran> i preferred fix (ap (:)), even if it was wrong :P
18:52:52 <roconnor> @unpl fix (ap (liftA2 (:)) . ((.) =<<)) (+1) 0
18:52:53 <lambdabot> fix (\ h -> (liftA2 (:)) >>= \ j -> (h >>= \ a b c -> a (b c)) >>= \ i -> return (j i)) (\ e -> e + 1) 0
18:52:58 <roconnor> better
18:53:41 <EvilTerran> ?pl \f x -> fix $ (x:) . map f
18:53:41 <lambdabot> (fix .) . flip ((.) . (:)) . map
18:54:00 <EvilTerran> well, that's got a certain perverse elegance to it, at least
18:54:07 <oerjan> @unpl ((.) =<<)
18:54:08 <lambdabot> (\ d -> d >>= \ a b c -> a (b c))
18:54:29 <ddarius> @pl \x -> fix $ (x:) . map f
18:54:29 <lambdabot> fix . (. map f) . (:)
18:54:42 <hpaste>  nolrai pasted "arrows are confusing. help." at http://hpaste.org/6491
18:54:54 <joricj> byorgey: i still don't understand ... it seems to work without the !, what do you mean when you say (((+1))))?
18:54:55 <EvilTerran> ?type (=<<) :: (e -> a -> b) -> (e -> a) -> e -> b
18:54:56 <lambdabot>     Couldn't match expected type `e' against inferred type `a'
18:54:56 <lambdabot>       `e' is a rigid type variable bound by
18:54:56 <lambdabot>           the polymorphic type
18:55:07 <EvilTerran> ups
18:55:17 <EvilTerran> nvm. you get the idea. it's like S with the parameters swapped
18:55:18 <byorgey> joricj: it will work fine without the !, $! will never change the value of an expression
18:55:26 <byorgey> joricj: it just changes the evaluation strategy.
18:55:27 <EvilTerran> ?type (=<<) `asTypeOf` flip . ap
18:55:28 <lambdabot>     Occurs check: cannot construct the infinite type: b = b -> a
18:55:28 <lambdabot>       Expected type: (a -> b -> b1) -> (b -> a) -> b -> b1
18:55:28 <lambdabot>       Inferred type: (a -> b -> b1) -> b -> a -> b1
18:55:34 <EvilTerran> bah.
18:55:54 <byorgey> joricj: if you pass something like (nr+1) as an argument to a function, if the function does not use it, it will not be evaluated
18:56:11 <joricj> why is that bad ?
18:56:11 <nolrai_> ?type (=<<)
18:56:12 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
18:56:21 <byorgey> joricj: it's not necessarily bad.  it's usually a good thing.
18:56:29 <nolrai_> ?type (ap)
18:56:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
18:56:37 <EvilTerran> ?type (=<<) :: (a -> e -> b) -> (e -> a) -> e -> b
18:56:38 <lambdabot> forall a e b. (a -> e -> b) -> (e -> a) -> e -> b
18:56:41 <wagle_home> :t (>>=)
18:56:42 <byorgey> joricj: but imagine a function (such as mainLoop) that just keeps calling itself with (nr+1)
18:56:42 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:56:44 <EvilTerran> there we go :)
18:56:47 <ddarius> :t ((((((((((id))))))))))
18:56:48 <lambdabot> forall a. a -> a
18:56:50 <joricj> byorgey: ok
18:57:00 <joricj> what you're saying is that then
18:57:02 <byorgey> joricj: the second call to mainLoop will have the parameter ((nr+1)+1)
18:57:04 <EvilTerran> ?type flip . ap
18:57:05 <lambdabot> forall b a b1. (b -> a -> b1) -> b -> (b -> a) -> b1
18:57:12 <byorgey> joricj: and then next will be (((nr+1)+1)+1)
18:57:14 <byorgey> and so on
18:57:18 <joricj> and that takes extra memory?
18:57:26 <byorgey> joricj: yes.
18:57:33 <EvilTerran> ?type (=<<) `asTypeOf` ap . flip
18:57:34 <lambdabot> forall a c. (a -> a -> c) -> (a -> a) -> a -> c
18:57:42 <EvilTerran> hooray!
18:57:42 <oerjan> joricj: not only that, but when it is finally evaluated it may run out of stack
18:57:54 <byorgey> joricj: and more importantly, when it actually needs to be evaluated, it will push lots of 1's onto the stack as it unrolls all the +'s
18:58:06 <byorgey> joricj: and it may end up overflowing the stack
18:58:27 <joricj> wow so it seems i have to be really careful of how i call my functions
18:58:29 <byorgey> joricj: but all this can be avoided if we just make sure to actually evaluate the increment at each recursive call.
18:58:33 * roconnor grumbles about machine integers
18:58:35 <oerjan> :t (.($)).(=<<)
18:58:36 <lambdabot> forall a a1 b. (a1 -> a -> b) -> (a -> a1) -> a -> b
18:58:40 <lispy> needing to specify the evaluation strategy in cases like this is one of the most unfortunate aspects of lazy evaluation.  It takes real practical experience with lazy eval before knowing when to do this is important.
18:58:52 <byorgey> joricj: in general, you don't.
18:58:52 <ddarius> roconnor: I think you want to grumble about flat CPOs
18:59:11 <byorgey> joricj: in practice, you just need to be aware that this kind of thing can happen
18:59:26 * roconnor grumbles about machine integers with flat CPOs
18:59:29 <byorgey> joricj: and don't worry about it unless you actually get a stack overflow.
18:59:32 <solrize> hmm there's no ByteString.lines function, is there something else to use ?
18:59:44 <dcoutts_> solrize: yes there is
18:59:47 <oerjan> @hoogle lines
18:59:47 <lambdabot> Prelude.lines :: String -> [String]
18:59:47 <lambdabot> Data.List.lines :: String -> [String]
18:59:47 <lambdabot> Data.ByteString.Char8.lines :: ByteString -> [ByteString]
18:59:49 <joricj> if it does happen (suddenly a stack overflow), how do i know what part of my code did it?
18:59:56 <byorgey> joricj: note, the other easy way to get a stack overflow is to use foldl
19:00:03 <solrize> oh, char8.lines
19:00:06 <solrize> thanks
19:00:14 <roconnor> joricj: it will be the part of the code where you write (+ 1) ;)
19:00:16 <byorgey> joricj: the solution is to use foldl', which is like foldl but uses seq (aka $!) for you
19:00:20 <dcoutts_> solrize: lines is in the .Char8 module because it considers the bytestring as ascii text rather than binary.
19:00:41 <byorgey> joricj: ah, that is something of an art form =)
19:00:43 <lispy> > filter (/=100) [1..99]
19:00:44 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
19:00:46 <solrize> if i have "import qualified Data.ByteString as B" can I then import B.Char8 or do i need another full qualification?
19:00:55 <joricj> byorgey: ah yes because foldl doesn't really compute it but only set's up the (f (f (f (f (f ...))))
19:01:01 <oerjan> solrize: you need another full one
19:01:02 <byorgey> joricj: exactly!
19:01:13 <solrize> thanks
19:01:18 <solrize> import qualified Data.ByteString as B
19:01:18 <solrize> import qualified Data.ByteString.Char8 as B8
19:01:26 <solrize> i guess that looks ok
19:01:28 <lispy> joricj: but we have foldl'
19:01:37 <lispy> joricj: that in strict for this reason
19:01:38 <oerjan> solrize: haskell does not consider hierarchical module names to be related to each other in any way
19:02:27 <ddarius> Indeed.   The heirarchical module extension is simply to allow '.' in module names.
19:02:39 <lispy> solrize: and it's probably a good thing overall that it doesn't.  suppose that B.Char8 is a valid module name and then remove the line import ... as B, now it may have different meaning.
19:03:07 <joricj> so `seq` is where the dark magic happens?
19:03:27 <solrize> hmm there's no B.show
19:03:39 <lispy> joricj: It's not that dark really.  You can make the strictness happen yourself without seq I believe.
19:03:54 <ddarius> lispy: Oftentimes.
19:03:59 <lispy> joricj: pattern matching increases strictness
19:04:02 <oerjan> solrize: pack . show ?
19:04:12 <ddarius> > case undefined of 1 -> 1; x -> x
19:04:13 <lambdabot>  Undefined
19:04:17 <ddarius> > case 4 of 1 -> 1; x -> x
19:04:18 <lambdabot>  4
19:04:21 <ddarius> > case ` of 1 -> 1; x -> x
19:04:21 <lambdabot>  Parse error at "`" (column 6)
19:04:21 <joricj> lispy: ah yes
19:04:24 <ddarius> > case 1 of 1 -> 1; x -> x
19:04:25 <lambdabot>  1
19:04:31 <solrize> oerjan, hmm
19:04:41 <SamB> lispy: seq is magical, though
19:04:43 <joricj> pattern matching, because than it *has* to evaluate part of the result to go on
19:04:47 <solrize> will bytestring someday replace regular strings in the language ?
19:04:47 <oerjan> solrize: since the Show class is defined with Strings it makes no sense for Bytestring to avoid them
19:05:10 <SamB> seq doesn't need to have any knowlege of the type involved in order to cause the value to be forced...
19:05:12 <ddarius> We should go back to the Eval class...
19:05:18 <lispy> solrize: Probably not, but it will be an option for the forseeable future
19:05:21 <dcoutts_> solrize: no, they're not unicode
19:05:24 <joricj> although, can't it just setup a pattern match to be executed later when the result of the matching is needed?
19:05:39 <solrize> dcoutts_ oh right, but there's a unicode module in there for them
19:05:49 <SamB> joricj: not in cases
19:05:59 <dcoutts_> it'd be a pretty radical change to make the String type abstract
19:06:20 <ddarius> joricj: A pattern match will only be executed when its result is needed.  Anything in Haskell will only be executed when its result is needed.
19:06:28 <SamB> dcoutts: I thought we wanted to do that anyway
19:06:32 <hpaste>  solrize pasted "simple bytestring example" at http://hpaste.org/6492
19:06:34 <dcoutts_> SamB: really?
19:06:44 <SamB> well.. overloading the syntax and all...
19:06:53 <solrize> type mismatch
19:07:01 <dcoutts_> SamB: you might want to, but I expect it'd break every program in existence
19:07:17 <SamB> ... since when does that stop us?
19:07:21 <dcoutts_> hah
19:07:23 <SamB> we also want a better record system
19:07:36 <ddarius> we just can't decide on which
19:07:40 <oerjan> solrize: i don't know whether B.putStrLn . B.pack  is any improvement from plain putStrLn
19:07:43 <SamB> quite.
19:07:45 <solrize> dcoutts_ i want to generate and sort an enormous number of small strings, is making a list of bytestrings and using list.sort reasonable ?
19:08:09 <joricj> so how can you force strictness without `seq`?
19:08:12 <solrize> oerjan i can use plain putstrln?  i'll try that
19:08:12 <dcoutts_> solrize: it's not likely to be much faster, bytestring does not perform well for small strings
19:08:23 <oerjan> solrize: Bytestrings have higher overhead for small string iirc
19:08:26 <oerjan> *s
19:08:29 <solrize> oh interesting
19:08:51 <lekro> what happens if the first argument of par raises an error (e.g., pattern mismatch), but the result is not needed? Like, f x = undefined `par` x
19:08:56 <lispy> joricj: I think IO requested by main will force things
19:08:57 <EvilTerran> dcoutts_, what about Data.String?
19:09:04 <ddarius> lekro: Try it.
19:09:06 <oerjan> solrize: in fact you can use print
19:09:07 <EvilTerran> -XOverloadedStrings etc
19:09:11 <solrize> what i think i really want is to write out my strings to a file, mmap it, build up an STU array of offsets into the mmap and sort that using a mutating quicksort or something
19:09:17 <lekro> ddarius: I can't, I only have a single core machine.
19:09:24 <solrize> oerjan ok i'll try that
19:09:29 <oerjan> B.putStrLn . B.pack . show = print afaict
19:09:30 <dcoutts_> EvilTerran: allowing it to use more similar syntax isn't quite the same as redefining String
19:09:33 <ddarius> The number of cores shouldn't change the semantics.
19:09:37 <byorgey> joricj: in general, I don't think you can.
19:09:42 <lekro> ddarius: oh, ok
19:09:43 <EvilTerran> true
19:10:06 <ddarius> Not in general, but in most cases.
19:10:15 <oerjan> solrize: there might be a slight difference in strictness, since pack packs the entire string before passing any of it on
19:10:31 <solrize> that's ok, these are short strings
19:10:36 <dcoutts_> oerjan: only difference is in atomicity
19:10:43 <solrize> but     mapM_ (print . show . (zipWith (,) [1..])) xlines      doesn't typecheck
19:10:47 <oerjan> dcoutts_: this is strict bytestring
19:10:49 <byorgey> joricj: well, you could do something contrived with a case, like  case lst of [] -> foo; (x:xs) -> foo   instead of lst `seq` foo  but obviously that is non-optimal since you have to repeat 'foo'
19:11:08 <lispy> Has anyone (or is it even decidable) written a tool that will statically tell you if you're a line of code could cause stack overflow?
19:11:55 <solrize> basically i have a 4gb machine and i'm hoping i can use at least 3.5gb of it as input buffer isolated from the gc
19:12:02 <dolio> class Seq a where seq :: a -> b -> b ; instance Seq [a] where { seq (_:_) b = b ; seq [] b = b } ; ...
19:12:09 <ddarius> lispy: You'd have to define "stack overflow" much more precisely to even begin to do that.
19:12:15 <ddarius> (usefully)
19:12:27 <byorgey> dolio: ugh, but good point =)
19:12:32 <lispy> ddarius: I'm thinking of joricj question that brought up ($!)
19:12:35 <dolio> That's how things used to be.
19:12:44 <byorgey> dolio: interesting.
19:12:52 <byorgey> lispy: mightCauseStackOverflow = const True  =)
19:12:52 <SamB> lispy: not possible to decide if stack usage of some particular code is bounded or not, I'm pretty sure
19:13:01 <oerjan> solrize: um no . show although that shouldn't cause a type error
19:13:04 <SamB> in general
19:13:10 <SamB> that seems like the halting problem to me
19:13:12 <oerjan> @src print
19:13:13 <lambdabot> print x = putStrLn (show x)
19:13:14 <ddarius> SamB: It is undecidable.
19:13:20 <lispy> SamB: that's what I figured
19:13:23 <dolio> Until the evils of polymorphic seq were perpetrated, because the Seq class pollutes type signatures. :)
19:13:28 <solrize> taking out the . show  has same type error
19:13:44 <byorgey> of course, that doesn't mean you couldn't have something that could identify possible stack overflows.
19:13:48 <SamB> because, you know, I could make a turing machine that pushes something on a stack every cycle
19:13:53 <SamB> until it halts
19:13:57 <byorgey> it wouldn't have to decide the problem in order to be useful.
19:14:00 <ddarius> dolio: It -should- pollute type signatures.
19:14:00 <SamB> QED
19:14:05 <ddarius> @free seq
19:14:06 <lambdabot> g . seq x = seq (f x) . g
19:14:25 <lament> lispy: "could" is certainly decidable
19:14:38 <dolio> ddarius: Well, I did call polymorphic seq 'evil'. :)
19:14:41 <solrize> System.IO.Posix.MMap  <--- wow, cool
19:14:47 <lispy> lament: yeah, the const True implementation showed that :)
19:14:48 <oerjan> solrize: zipWith (,) = zip  but that's not the error either :)
19:14:50 <SamB> if you just meant "could it overflow some stack", that's trivially easy
19:15:04 <solrize> oh heh
19:15:07 <SamB> you just check to see if it could use the stack AT ALL
19:15:08 <solrize> good point :)
19:15:11 <lispy> but, const True isn't a very useful implementation
19:15:20 <SamB> well, perhaps that's not a decision procedure
19:15:29 <EvilTerran> const isComputerOn
19:15:35 <EvilTerran> const (not isComputerOnFire)
19:15:36 <SamB> but it would be a conservative approximation, at least...
19:15:45 <roconnor> @free id
19:15:47 <lambdabot> f . id = id . f
19:15:57 <roconnor> @free ($)
19:15:57 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:15:59 <EvilTerran> (yeah, those should probably be IO actions)
19:16:00 <solrize> why is it inferring B8.ByteString instead of B.ByteString ?
19:16:05 <lament> lispy: but in general, if you have a loop (for example a recursive function) where the effect of each iteration is to add to the stack, it becomes undecidable
19:16:15 <ddarius> SamB: Well, if a function uses any stack it could stack overflow.
19:16:24 <SamB> ddarius: I just said that
19:16:25 <byorgey> EvilTerran: no, isComputerOn :: Bool  =)
19:16:39 <oerjan> solrize: oh you are using B.readFile but B8.lines
19:16:43 <lament> lispy: of course if you don't have any loops, your program is not turing-complete, but then calculating the effects on the stack is trivial :)
19:16:45 <oerjan> you need to use the same for both
19:16:48 <SamB> well, it's really easy as long as the halting problem doesn't come up before you get to a push
19:16:52 <byorgey> EvilTerran: isComputerOnFire has to be an IO action though, I guess
19:16:56 <oerjan> or wait...
19:16:58 <gwern> @seen lispy
19:16:58 <lambdabot> lispy is in ##logic, #haskell-blah, #darcs, #ghc and #haskell. I last heard lispy speak 1m 48s ago.
19:17:02 <solrize> i need B8.readFile ?   hmm didn't realize there was one
19:17:03 <solrize> thanks
19:17:06 <oerjan> i'm misremembering perhaps
19:17:16 <lispy> gwern: what's up?
19:17:20 <solrize> didn't help
19:17:22 <EvilTerran> byorgey, i think, as it appeared in some BSD or another, it was a constant procedure that always returned false
19:17:31 <byorgey> EvilTerran: hehe
19:17:32 <ddarius> SamB: I'm emphasizing that it could actually overflow stack and not just that using some stack is a requisite for overflowing stack.
19:17:37 <oerjan> solrize: chances are B8 exports everything in common with B anyhow
19:17:47 <SamB> ddarius: oh, I know
19:17:53 <forkiliens> has anyone experience with running happs-applications?
19:17:53 <SamB> that's what I meant too ;-)
19:18:02 <SamB> since you could have no stack left at all
19:18:03 <gwern> lispy: my memory is bad... autoproc is yours right?
19:18:08 <lispy> gwern: correct
19:18:10 <Toxaris> solrize: i think B8.ByteString /= B.ByteString. the idea is to use either Data.ByteString or Data.ByteString.Char8
19:18:13 <forkiliens> i have compiled some, but don't know how to start them
19:18:14 <lispy> gwern: I am dagit at codersbase
19:18:22 <gwern> lispy: ok. what's the license?
19:18:22 <EvilTerran> byorgey, oh, no, sorry, it was BeOS
19:18:37 <byorgey> ah, I see
19:18:37 <ddarius> SamB: That was one of the bases of my comment that lispy needed to define stack overflow more precisely.
19:18:47 <SamB> if such a situation were not possible, it would be impossible to ever overflow the stack, because there would always be at least another unit of stack
19:18:54 <TomMD> forkiliens: Not to discourage you from asking here, but you know there is a #happs channel, right?
19:19:00 <EvilTerran> except it's rather more advanced than i remember: http://www.tycomsystems.com/beos/BeBook/The%20Kernel%20Kit/System.html
19:19:02 <lambdabot> Title: The Kernel Kit: System Information, http://tinyurl.com/3yklbn
19:19:04 <oerjan> solrize: could you paste your current version?
19:19:04 <Toxaris> solrize: so you could consider just doing import Data.ByteString.Char8 as B
19:19:10 <lispy> gwern: I think for this project, GPL is good.  You're the only other contributor, what is your thoughts?  I usually use either GPL or BSD (and usually only BSD if I want to use it at work and open source it)
19:19:10 <forkiliens> sorry
19:19:18 <forkiliens> join #happs
19:19:19 <EvilTerran> "double is_computer_on_fire(void); Returns the temperature of the motherboard if the computer is currently on fire. If the computer isn't on fire, the function returns some other value. "
19:19:20 <solrize>   mapM_ print $ zip [1..] xlines
19:19:20 <solrize>           worked :)
19:19:37 <ddarius> SamB: If we talked about whole programs rather than functions the distinction becomes more significant.
19:19:48 <oerjan> oh
19:20:02 <gwern> lispy: might as well go with BSD if it doesn't make any real difference to you
19:20:03 <byorgey> EvilTerran: haha, that's awesome =)
19:20:26 <SamB> ddarius: oh, I think I could rig up a way to leave a program with arbitrarily little stack space to work with...
19:20:34 <ddarius> EvilTerran: How do you tell if a result is the temperature of the motherboard or just another value.
19:20:46 <byorgey> ddarius: that's the beauty of it! =)
19:20:57 <oerjan> solrize: oh yeah B.pack doesn't take a String
19:20:58 * solrize favors gpl, i'm required to release stuff i do at work under gpl and also i like it better for non-work stuff
19:20:59 <Toxaris> ddarius: that easy, you just check whether the computer is on fire by other means
19:21:01 <ddarius> SamB: Not from within the program in that case.
19:21:07 <SamB> byorgey: a little tricky to test, that function
19:21:08 <oerjan> @hoogle pack
19:21:08 <lambdabot> Data.ByteString.pack :: [Word8] -> ByteString
19:21:08 <lambdabot> Data.ByteString.Char8.pack :: String -> ByteString
19:21:08 <lambdabot> Data.ByteString.Lazy.pack :: [Word8] -> ByteString
19:21:14 <SamB> ddarius: quite so
19:21:26 <ddarius> Toxaris: Unit testing that function must be expensive.
19:21:27 <allbery_b> "lp1: on fire"
19:21:38 <forkiliens> exit
19:21:40 <solrize> i got rid of the pack and am just using print directly on the (Int,B8.ByteString)
19:21:45 <SamB> but the available stack for the function case was not determined in the function, either
19:21:48 <byorgey> every time you call that function, you could prompt the user: "Is the computer on fire? Y/N "
19:22:00 <monochrom> heh
19:22:01 <SamB> byorgey: what about SSH access?
19:22:07 <lispy> gwern: BSD3 it is then.
19:22:14 <SamB> a remote user might not know if the computer was on fire or not
19:22:33 <byorgey> SamB: true, they'd have to call an on-location sysadmin in order to proceed
19:23:20 <ddarius> A variant could be a useful function for defending against some security attacks.
19:23:21 <gwern> lispy: 'k
19:23:30 <lispy> solrize: because it's sometimes hard for companies to include GPL where they could include BSD, I often times feel like BSD is more free.  But in the end, I like both licenses and undersand they both have cons.
19:23:53 <EvilTerran> lispy, do they also have nil? :D
19:24:04 <monochrom> I like public domain. :)
19:24:05 <gwern> I public domain my stuff, since I know no company will ever go after my little programs and configs
19:24:06 <ddarius> The Haskell community is pretty pro-BSD.
19:24:13 <solrize> well if i'm developing for the benefit of a company then i expect them to pay me :)
19:24:21 <SamB> I would basically use the GPL where I really thought there was a serious danger of a company trying to take the product and make something proprietary in a deliberate attempt to steal all the users...
19:24:32 <SamB> a serious, near-future danger
19:24:44 <gwern> it's nice and simple
19:25:00 <wagle_home> solrize, what about companies that sell distributions of free software?
19:25:11 <gwern> ddarius: we can't really afford to offput people; game theoretically, GPL would offput BSDers, but BSD won't offput Windows and Linuxers
19:25:15 <gwern> so BSD is dominant
19:25:15 <SamB> if it was a more remote danger, I might use the LGPL... but not for Haskell code.
19:25:17 <gwern> *a dominant strategy
19:25:38 <solrize> BSD offputs me somewhat, i use BSD code but i'm generally less interested in hackign on it
19:25:38 <noecksit> is there a function in haskell that give a list of numbers, returns the index of the maximum in that list?
19:25:43 <solrize> i guess it would depend what it was
19:25:55 <ddarius> gwern: We can't afford to offput people?
19:26:00 <solrize> noecksit  let me try
19:26:16 <solrize> fst . (maximumBy snd) . (zip [1..])
19:26:30 <solrize> gwern may i ask what the program is ?
19:26:32 <gwern> ddarius: I don't think haskell is popular enough to be able to needlessly piss people off
19:26:37 <wagle_home> > maximum [2,1,3,2,4,76,8,3,2]
19:26:37 <Toxaris> :t maximumBy
19:26:38 <lambdabot>  76
19:26:39 <ddarius> fst . maximumBy snd . zip [0..]
19:26:39 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
19:26:55 <gwern> solrize: that I'm working on with lispy?
19:26:56 <ddarius> gwern: And what happens if we do?
19:26:59 <Riastradh> solrize, I'm curious -- what puts you off about the (3-clause?) BSD licence?
19:26:59 <solrize> gwern yeah
19:27:03 <oerjan> gwern: i wonder if this is a rock-paper-scissors situation
19:27:04 <Toxaris> solrize: fst . (maximumBy $ compare `on` snd) . zip [1..]
19:27:15 <solrize> toxaris right
19:27:18 * lispy leaves
19:27:20 <wagle_home> ohhhh..  index..  sorry
19:27:22 <lispy> gwern: send me patches please!
19:27:38 <noecksit> maximumBy [1,2,3]
19:28:00 <gwern> solrize: it's autoproc; it defines functions/edsl/module for defining mail filtering, and 'compiles' it into a .procmailrc
19:28:01 <solrize> riastradh i'm put off by the idea of being an unpaid coolie for microsoft :).  i'm ok with bsd if i'm getting paid.
19:28:09 <gwern> lispy: I will, I just really started
19:28:26 <wagle_home> yeah, ddarius stole my solution before i thought of it!  8)
19:28:36 <solrize> gwern oh that sounds neat
19:29:03 <dmwit> :t findIndex
19:29:04 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
19:29:25 <ddarius> wagle_home: That was solrize's (slightly modified)
19:29:27 <dmwit> :t \xs -> fromJust . findIndex (== maximum xs) $ xs
19:29:27 <lambdabot> forall a. (Ord a) => [a] -> Int
19:29:51 <solrize> dmwit that makes two passes over the list ... ?
19:29:52 <gwern> solrize: http://projects.codersbase.com/repos/autoproc
19:29:53 <lambdabot> Title: Index of /repos/autoproc
19:30:20 <noecksit> so which one is it?
19:30:23 <dmwit> solrize: Yes.
19:30:34 <solrize> gwern neat maybe i'll try it, i feel like i'm in some kind of transitional crufty period where my email situation is a spamwreck and i haven't figured out what to ultimately do about it
19:30:37 <gwern> oerjan: I don't think so, since rocks-paper-scissors has no ESS with rational players
19:30:47 <gwern> but I think there are ESSs for software licenses
19:30:57 <dmwit> :t foldl
19:30:58 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
19:31:06 <solrize> ESS ?
19:31:07 <oerjan> ESS?
19:31:46 <gwern> evolutionarily stable strategy; ie a strategy that once dominant won't be dislogded by an invading strategy
19:31:54 <wagle_home> @go Evolutionarily Stable Strategy
19:31:55 <lambdabot> http://en.wikipedia.org/wiki/Evolutionarily_stable_strategy
19:31:55 <lambdabot> Title: Evolutionarily stable strategy - Wikipedia, the free encyclopedia
19:31:59 <solrize> oh ok
19:32:03 <gwern> ESSs are not necessarily the global optima though
19:32:19 <mcnster> hi.  q: is there a semantic difference between saying "forall a. a -> b" and just "a -> b"?
19:32:43 <dmwit> mcnster: no
19:33:06 <mcnster> dmwit, then why say "forall a"?  ;-)
19:33:08 <oerjan> mcnster: haskell puts foralls for all variables on implicitly at the beginning
19:33:28 <oerjan> however with rank-n types _inside_ there can be a difference
19:33:33 <dmwit> mcnster: Just to clarify where the scope of a.
19:33:54 <dmwit> mcnster: For example, this type is not the same if you drop the "forall":
19:33:57 <oerjan> so forall a b. a -> b  is different from forall b. (forall a. a) -> b
19:34:02 <dmwit> a -> (forall b. b)
19:34:16 <gwern> hm. I wonder how fast a bucket sort would be on a [String]
19:34:24 <oerjan> dmwit: actually that one is equivalent i think
19:34:39 <dmwit> err
19:34:50 <mcnster> oerjan, in your example, what is the difference?
19:34:54 <solrize> gwern i think if you're really trying to sort fast, cache locality is important
19:35:02 <ddarius> Using explicit foralls also triggers an extension.
19:35:03 <solrize> and bucket sort may clobber you
19:35:10 <noecksit> Toxaris: where could i find the function "on"?
19:35:10 <dmwit> Oh, I need a context for that to be different.
19:35:11 <ddarius> (as well as being one themselves)
19:35:16 <dmwit> noecksit: Data.Function
19:35:20 * SamB discovers john meacham has a project called "getlaid"
19:35:28 <noecksit> thanx
19:35:30 <monochrom> (forall a. a -> a) -> Int -> Int
19:35:32 <dmwit> noecksit: Unless you're pre-6.8.2, in which case, on (+) f x y = f x + f y -- the definition
19:35:37 <oerjan> mcnster: the first type, you have a function which can be used on any a.  the second you have a function which can be used only with an argument that is itself forall a. a
19:35:52 <gwern> solrize: are there any resources on sorting a [String] really fast then?
19:36:03 <solrize> you're asking ME?  i'm the newbie here.
19:36:06 <gwern> I'm guessing the library sorts are not what I'd want
19:36:28 <gwern> heh
19:36:38 <solrize> and you mean a regular string which is consed-up lazy lists of chars?  that's probably hosed from the get go
19:36:38 <gwern> I'm bad with names, I don't remember that
19:36:58 <solrize> i'm thinking of using mmap and STUArrays or even the FFI
19:37:10 <gwern> well, I'd probably actually use a strict bytestring
19:37:17 <solrize> i spent part of today thinking of how to do really big sorts
19:37:27 <mcnster> oerjan, what would an argument that is itself forall a. a look like?
19:37:35 <joricj> okay ... i decided my first project is i'd want to extend the Chat Server on the wiki to support multiple rooms. can anyone give me a few hints as to how i would go about this (i have no clue atm)?
19:37:35 <solrize> i found that the unix sort utility is quite a bit faster than the c library qsort routine on a file that doesn't fit in ram
19:37:48 <solrize> joricj you mean lambdabot ?
19:37:51 <noecksit> the function says 'on' and $ cannot be mixed
19:37:52 <oerjan> mcnster: actually that was a bad type because a useful example doesn't actually exist
19:37:53 <monochrom> (forall a. a) is very hard.
19:37:56 <solrize> :whois oambdabot
19:37:59 <wagle_home> > sort [[1..], [1..]]
19:38:03 <solrize> wagle :)
19:38:03 <lambdabot>  Terminated
19:38:04 <gwern> yeah, it does clever out of core sort
19:38:12 <mcnster> oerjan, oh ok.  that's a relief :)
19:38:13 <gwern> someone came up with a very neat out of core sort using bytestrings, iirc
19:38:16 <oerjan> mcnster: try forall a. a -> a instead.  then the id function is of that type
19:38:26 <TomMD> Hey, someone created a proposed projects wiki on Haskell.org (http://haskell.org/haskellwiki/Potential_projects) - independent of any hackathon.  Hopefully it will get some interesting proposals/requests.
19:38:29 <lambdabot> Title: Potential projects - HaskellWiki
19:38:33 <joricj> solrize: no not the ircbot, i want to extend the chat server (eventually into a very very very simple IRC server)
19:38:45 <solrize> gwern. yeah, i hoped qsort used the classic quicksort algorithm with the two pointers converging towards the middle, and they woudl have good paging locality so they wouldn't thrash the vm too much
19:38:55 <solrize> oh, you want to write your own ircd ?
19:39:09 <wagle_home> only a equality check would attempt to reify all of [1..], i think
19:39:17 <oerjan> > (0$0 `on`)
19:39:18 <lambdabot>      The operator `on' [infixl 0] of a section
19:39:18 <lambdabot>         must have lower preced...
19:39:21 <dmwit> joricj: Are you talking about http://haskell.org/haskellwiki/Implement_a_chat_server ?
19:39:22 <lambdabot> Title: Implement a chat server - HaskellWiki
19:39:26 <solrize> i think that shouldn't be too hard
19:39:35 <oerjan> noecksit: they had the bad sense of giving on fixity 0
19:39:37 <mcnster> oerjan, it seems to me that a -> a is also an id function of that type, or am i missing something?
19:39:37 <pantsd__> what does "Non-exhaustive patterns in function" mean?
19:39:43 <oerjan> i think that should be reserved for $
19:39:48 <wagle_home> > sort [[1,1,1],[1..],[1,1]]
19:39:49 <lambdabot>  [[1,1],[1,1,1],[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,...
19:39:55 <joricj> dmwit, solrize: yes
19:39:59 <solrize> pantsd__ it means you did a pattern match that left some possible cases untested
19:40:06 <solrize> but i thought haskell compilers didn't check for that
19:40:08 <SamB> oerjan: who gave it a fixity of 0?
19:40:10 <solrize> and there's a separate tool for it
19:40:16 <oerjan> mcnster: oh id is of that type.  you need to consider something more complicated.
19:40:19 <solrize> joricj i know there's some ircd's written in python
19:40:22 <SamB> oerjan: I'm fairly certain a patch to change the fixity to 1 would be accepted
19:40:24 <solrize> so you could look at one to see how it's done
19:40:26 <oerjan> SamB: the people who put it in the library?
19:40:39 <gwern> lispy: http://www.codersbase.com/ is broken, what is codersbase?
19:40:40 <joricj> solrize: i'm not intrested really in writing an IRCd i just want to learn haskell :D
19:40:41 <SamB> unless you know of anything else with a fixity of 1?
19:41:02 <monochrom> To get something less boring, try adding class constraints, e.g., f :: (forall a. Show a => a -> String) -> (Int,Bool) -> (String,String) \n f g (x,y) = (g x, g y)
19:41:16 <pantsd__> solrize: intriguing I get this at link time with ghc 6.6.1 . Can you recommend any tools which would say enumerate which cases I've failed to match?
19:41:18 <SamB> oerjan: so, why don't you try it?
19:41:26 <monochrom> If you try to take away the inner forall, it breaks.
19:41:33 <solrize> joricj in that case a simple multi-user chat is probably a reasonable thing to try, if you're interested in internet programming
19:41:43 <solrize> pantsd__ there's something called catch, i've never used it and it sounds like a pain
19:41:45 <joricj> the thing is iam new to this (i know a little scheme but that's also destructive programming) so i have NO IDEA how i would organize my data (eg, which users are online, which channels exists, which people are in which channels)
19:41:51 <SamB> edit the file, change the value to 1, darcs record, darcs send
19:41:54 <SamB> it's that simple
19:42:09 <bd_> joricj: Data.Map is your friend :)
19:42:12 <solrize> joricj you'd use a bunch of data.maps which you'd update using recursion
19:42:17 <pantsd__> solrize: cool. thanks :)
19:42:26 <bd_> joricj: STM is also your friend.
19:42:37 <solrize> http://www-users.cs.york.ac.uk/~ndm/catch/
19:42:38 <lambdabot> Title: Neil Mitchell - Catch: Case Totality Checker for Haskell
19:42:47 <bd_> it lets you get all the benefits of threading and not-threading all in one :)
19:42:56 <joricj> okay i will check out STM and Data.Map
19:43:14 <solrize> if you look at how happs works, it's brilliant, sort of the ultimate in that, but insanely complicated
19:43:20 <solrize> you shouldn't need STM
19:43:25 <mcnster> oerjan, thanks for the clues
19:43:31 <solrize> just have your threads communicate through Chan
19:43:45 <bd_> solrize: Well, he could toss off a thread for each client, and if they need to, eg, join a channel, use STM to update the channel user lists
19:43:45 <solrize> Control.Concurrent.Chan  iirc
19:44:16 <solrize> yeah i don't think that needs stm but i haven't looked at the stm stuff that much.  the Chan approach was natural to me as a python user
19:44:19 <bd_> but yeah Chan would be nice for actually passing around the messages
19:44:30 <joricj> solrize: but if i use a chan don't i need two threads per client? (one for reading, one for writing) that's what the chatserver on the wiki uses
19:44:39 <bd_> joricj: threads are cheap, go for it :)
19:44:47 <solrize> yes 2 threads is the usual way
19:44:56 <solrize> doing it with 1 thread sounds like a pain
19:45:04 <solrize> asynchronous i/o
19:45:16 <solrize> let the ghc runtime handle it :)
19:45:22 <joricj> 2 threads is the standard way?! NICE :D
19:45:29 <bd_> you'd need to foreign call out to C to do it with one thread, the haskell runtime only really gives support for the multithreaded way :)
19:45:41 <noecksit> may someone give me examples of maximumBy?
19:45:43 <bd_> which reminds me, I need to finish implementing epoll support for the threaded RTS's IO manager
19:45:48 <solrize> there's a nonblocking read function in the lib
19:45:57 <monochrom> :t maximumBy
19:45:58 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
19:46:12 <solrize> you could do the state machine crap that you'd do in C but what's the point of using haskell then
19:46:13 <bd_> solrize: Yeah, but can you block on ready-to-read and ready-to-write at the same time?
19:46:16 <bd_> right
19:46:21 <monochrom> Oh, that one is hard, have to cook up a function returning Ordering.
19:46:26 <bd_> much easier to just spawn a second lightweight thread and be happy
19:46:39 <noecksit> i tried doing "maximumBy (comparing length) [1,2,3,44]" but i get an error
19:46:46 <solrize> bd i expect there's something like select but didnt' care enough to check specifically
19:46:52 <monochrom> :t comparing length
19:46:53 <lambdabot> forall a. [a] -> [a] -> Ordering
19:46:59 <solrize> i wonder if there's anything like SIGIO
19:47:02 <monochrom> Clearly.
19:47:11 <dmwit> > maximumBy (comparing length) [[1, 34], [5], [23532,52,523,35]]
19:47:12 <lambdabot>  [23532,52,523,35]
19:47:12 <bd_> solrize: the IO manager basically works by being handed a MVar, then when the handle is ready, inserting a () in it
19:47:18 <monochrom> I mean, "a" is not "[a]"
19:47:23 <bd_> so anything else would basically be a call out to C's select
19:47:29 <solrize> the article abotu the awkward squad is worth reading
19:47:39 <dmwit> noecksit: If you want to compare lengths, the things in you list have to themselves be lists. ;-)
19:47:59 <solrize> http://www-users.cs.york.ac.uk/~ndm/catch/   tackling the awkward squad
19:48:00 <lambdabot> Title: Neil Mitchell - Catch: Case Totality Checker for Haskell
19:48:04 <noecksit> oh
19:48:05 <dmwit> noecksit: In "maximumBy (comparing foo)", you need to be able to apply "foo" to any two elements of the list you pass in.
19:48:06 <solrize> whoops wrong url
19:48:10 <solrize> http://research.microsoft.com/~simonpj/papers/marktoberdorf/
19:48:11 <lambdabot> Title: Simon Peyton Jones: papers
19:54:39 <dcoutts> @seen mnislaih_
19:54:39 <lambdabot> mnislaih_ is in #haskell and #ghc. I last heard mnislaih_ speak 7h 25m 22s ago.
19:55:12 <dcoutts> @tell mnislaih_ latests patches look good to me, I might hold off pushing though 'til cabal-install is building
19:55:13 <lambdabot> Consider it noted.
19:55:22 <dmwit> :t snd . maximumBy (comparing fst) . map . (*** id)
19:55:23 <lambdabot>     Couldn't match expected type `[(a, b)]'
19:55:23 <lambdabot>            against inferred type `[a1] -> [b1]'
19:55:23 <lambdabot>     Probable cause: `map' is applied to too few arguments
19:56:15 <ddarius> "Although there is barely any difference between 2D and 3D simulations, supporting 3D user interaction is more challenging."
19:56:36 <gwern> @[; showFlags [NeedLock b] = show (NeedLock b)
19:56:36 <lambdabot> Maybe you meant: . ? @ bf ft id pl rc v wn
19:56:44 <gwern> @pl showFlags [NeedLock b] = show (NeedLock b)
19:56:44 <lambdabot> (line 1, column 24):
19:56:44 <lambdabot> unexpected "="
19:56:44 <lambdabot> expecting variable, "(", operator or end of input
19:56:59 <dmwit> ?pl \f -> snd . maximumBy (comparing fst) . map (f *** id)
19:56:59 <lambdabot> ((snd . maximumBy (comparing fst)) .) . map . (*** id)
19:57:08 <oerjan> gwern: pattern matches cannot be @pl'ed in general
19:57:18 <gwern> oh
19:57:37 <solrize> ;t on
19:57:38 <oerjan> if you have a field name it might be possible
19:57:45 <solrize> :t on
19:57:46 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
19:58:03 <dmwit> gwern: show . head ?
19:59:00 <oerjan> ah yes
19:59:48 <oerjan> gwern: although if you are not sure that it is of the form [NeedLock b], show . head won't help you check
20:01:11 <kraftyswine> does anyone here know fran?
20:01:18 <shapr> I've met her, I think...
20:01:25 <shapr> Oh wait, you mean the functional reactive stuff?
20:01:29 <kraftyswine> yup
20:01:35 <shapr> Nah, never heard of it..
20:01:39 * shapr grins
20:01:41 <zgold> Does haskell have any default equivalent of a "string.contains" ?
20:01:51 <kraftyswine> :)
20:01:56 <gwern> lispy: I'm sending you some basic cabalizing patches now
20:01:58 <shapr> zgold: isPrefixOf ?
20:01:58 <gwern> nothing fancy
20:02:08 <oerjan> :t isInfixOf
20:02:09 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
20:02:34 <bd_> zgold: http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString.html#v%3AisSubstringOf
20:02:35 <lambdabot> http://tinyurl.com/377db6
20:02:50 <zgold> oerjan: what library is that in?  its not in std. prelude from what i see.
20:02:54 <zgold> bd_: checking
20:02:58 <bd_> oh, deprecated, though...
20:03:15 <bd_> well, isSubstringOf isn't
20:03:18 <bd_> but {-# DEPRECATED findSubstring "Do not use. The ByteString searching api is about to be replaced." #-}
20:03:27 <oerjan> @hoogle isInfixOf
20:03:28 <lambdabot> Data.List.isInfixOf :: Eq a => [a] -> [a] -> Bool
20:03:28 <lambdabot> Data.ByteString.isInfixOf :: ByteString -> ByteString -> Bool
20:03:28 <lambdabot> Data.ByteString.Char8.isInfixOf :: ByteString -> ByteString -> Bool
20:04:01 <zgold> ah, its in Data.ByteString
20:04:03 <zgold> Thanks!
20:04:07 <gwern> (sending patches through tor takes a while)
20:04:13 <oerjan> zgold: er, Data.List
20:04:14 <noecksit> ok, i finally figured out the function
20:04:24 <oerjan> unless you really are looking at bytestrings
20:04:56 <noecksit> fst . maximumBy (comparing snd) $ zip [0..] [7,8,4,9,2,0]
20:05:19 <zgold> oerjan: what is the equivalent function in List?
20:05:26 <kraftyswine> shapr: dumb question, but is fran strictly 2d or 3d?
20:05:27 <zgold> oh, isInfix is there
20:05:29 <zgold> thanks :)
20:05:30 <oerjan> zgold: they have the same name
20:05:51 <kraftyswine> shapr: nm, found the 3d stuff
20:06:23 <gwern> lispy: ok, I've sent the first batch. I'm going to try to implement my xmonad strategy with the next batch, no idea when I'll be done or if
20:06:24 <oerjan> zgold: however it was added relatively recently
20:08:12 <zgold> I'm using 6.8, think thats okay?
20:08:34 <zgold> (Need to make the code in a compile-able state to test ;) )
20:10:20 <oerjan> yeah it may be from 6.6 or thereabouts
20:10:26 <dmwit> zgold: 6.8 is the most recent. (well, 6.8.2 or so)
20:10:28 <zgold> Woot, got it :)
20:10:55 <zgold> Thanks guys, appreciate the help
20:11:15 <shapr> kraftyswine: I don't know much about fran, have you seen the successors like yampa?
20:14:17 <joricj> !paste
20:14:17 <hpaste> Haskell paste bin: http://hpaste.org/
20:15:09 <gwern> kraftyswine: if you're itnerested in FRP, talk to conal - he writes/wrote some of them andcan tell you which ones are still up to date
20:15:13 <gwern> we were discussing this earlier actually
20:15:16 <joricj> okay so i think i know how i want to do the design of my IRC server i will type it down on hpaste because it's going to be kinda long
20:15:33 <gwern> (I think grapefruit is an up to date one)
20:15:50 <hpaste>  joricj pasted "overall design of IRC server version 0.0a" at http://hpaste.org/6494
20:15:52 <gwern> @seen SamB
20:15:53 <lambdabot> SamB is in #xmonad, #perl6 and #haskell. I last heard SamB speak 33m 59s ago.
20:16:13 <gwern> @tell SamB btw, I added an strace of the zmachine crash: http://hackage.haskell.org/trac/ghc/attachment/ticket/2164/zmachine.strace
20:16:14 <lambdabot> Consider it noted.
20:16:35 <joricj> can someone who knows more than i do please take a look and see if i'm getting anything wrong in this stage?
20:17:00 <solrize> looking
20:17:35 <shapr> kraftyswine: http://www.haskell.org/yampa/
20:17:35 <lambdabot> Title: Yampa
20:17:42 <gwern> 'The idea is that you could encapsulate all that complexity inside a method inside a class--instantiate that class inside a class that has a "main()" and then put the whole thing in a module. You call all of that method with the correct parameters in an instance of another class created and instantiated the same way. You then jar it up as bytecode and then run it on the JVM--making sure your users are running the right versions of the JVM.' \ 'On ...
20:17:50 <gwern> ... second thought, OMGWTF?' <-- lol
20:17:58 <shapr> kraftyswine: also http://www.haskell.org/arrows/
20:17:58 <lambdabot> Title: Arrows: A General Interface to Computation
20:18:19 <gwern> last updated 2004... conal mentioned that hudak has a student working on FRP, I wonder where the more reent work is
20:19:24 <solrize> joricj, i think you'd have a main loop accepting socket connections and forkIO'ing a pair of client handler threads each time a connection arrives
20:19:45 <shapr> kraftyswine: Hey, you should talk about Haskell in the main channel.
20:20:27 <solrize> then there would be a multiplexer/demultiplexer thread that would communicate with the client threads through a pair of channels
20:20:44 <shapr> kraftyswine: Realize that if you want people to help you, being insulting doesn't encourage them.
20:20:57 <kraftyswine> piss off
20:21:10 --- mode: ChanServ set +o shapr
20:21:16 <solrize> when a client gets a message it sends to the mux/demux and the demux broadcasts it to the other clients
20:21:19 <shapr> kraftyswine: Seriously, be nice or else.
20:21:29 <gwern> kraftyswine: wrong reply
20:21:33 <kraftyswine> are there any resources, any at all, to learn to USE fran, and nothing else?
20:21:55 <kraftyswine> gwern: I'm not in the mood to deal with idiots and power-hungry prigs
20:21:56 <joricj> solrize: so there would be a mux/demux for every channel? i don't understand
20:21:59 <shapr> kraftyswine: fran is one instance of functional reactive programming, and there are several different codebases that use FRP.
20:22:04 <gwern> kraftyswine: long story short, FRP is a volatile academic area. don't expect much help
20:22:17 <kraftyswine> well that sort of helps
20:22:19 <shapr> kraftyswine: Are you implying that I am an idiot or power-hungry prig?
20:22:35 <kraftyswine> you'd be the idiot and gwern would be the power hungry prig
20:22:42 <shapr> Ah, I see.
20:22:42 <joricj> the way it is written down now, it could work ... no ? or is it too slow because every command has to go through the TChan?
20:22:46 --- kick: kraftyswine was kicked by shapr (Kicked by shapr)
20:22:47 <dcoutts> oops, by by kraftyswine
20:22:57 <solrize> joricj, no there would be one mux/demux thread, listening to messages from clients and sending them to other clients
20:23:09 <gwern> I'm power hungry? that's a new one on me
20:23:13 <joricj> but i want multiple rooms!
20:23:13 * shapr shrugs
20:23:15 <solrize> let's see i guess there would be a chan going out to each client
20:23:15 <roconnor> what did kraftyswine do?
20:23:20 <roconnor> I didn't see anything?
20:23:27 <solrize> you woudl just track which rooms any client was in
20:23:31 <dcoutts> gwern: I'm power hungry :-)
20:23:36 <dcoutts> mwahahaha!
20:23:36 <solrize> that would select which clients you rebroadcast any given message to
20:23:36 <shapr> roconnor: I could paste the privmsgs, but it's not worth it.
20:23:46 <roconnor> shapr: oh privmsgs
20:23:54 <shapr> I was trying to be helpful.
20:24:00 <roconnor> that's fine. It was just weird to see you suddenly upset
20:24:01 <joricj> solrize: iam going to give my solution a try before i try yours
20:24:01 <gwern> dcoutts: well, you work hard for that power so I don't mind too much :)
20:24:02 <shapr> kraftyswine was being insulting.
20:24:15 <solrize> jorich ok, i just thought your paste skipped a bunch of details
20:24:34 <shapr> Ya know, if someone wants to learn some cool Haskell stuff, it's not a good idea to be rude here on #haskell
20:24:36 <joricj> but if i come back in twenty minutes and i failed you can laugh at me and i will never doubt you again sensei :)
20:25:09 <shapr> It's too bad, he sounds intelligent.
20:25:34 <roconnor> shapr: that's fine.  It just looked from my prespective that you suddenly went crazy, because I didn't see the privmsgs. ;)
20:25:37 * gwern has a sudden urge to call joricj young grasshopper
20:25:57 <solrize> joricj i've done this sort of thiing in python but my attempt to do it in hugs didn't work because hugs doesn't have non-blockign io... i haven't moved those files to ghc yet
20:25:58 <gwern> shapr: well, I sort of feel bad for anyone wanting to seriously use FRP. it's a confusing area; I keep meaning to review the literature and work out just how all the libraries are related...
20:26:04 <shapr> roconnor: Hopefully that'll never happen.
20:26:25 <shapr> gwern: I don't think it's confusing, I think it's experimental - and possibly very powerful - research.
20:26:41 <solrize> i haven't written anything in haskell bigger than toy examples yet, but am just starting to feel comfortable enough to maybe do something nontrivial
20:26:44 <gwern> shapr: he seemed a little confused
20:26:50 <dolio> At least shapr didn't use his katana.
20:26:56 <shapr> heh
20:27:04 * gwern agrees about the potential, but fundamentally, if you want to do something right now with FRP...
20:27:12 <shapr> Yeah, I agree.
20:27:16 <wkh> maybe roll your own?
20:27:35 <gwern> wkh: that's even worse, altought it seemed to work for Frag
20:27:41 <wkh> then all the FRP libraries can fight like in 15th century japan.
20:27:47 <sclv> cells is awesome -- but it only makes sense mutable state type languages.
20:27:53 <sclv> (i think)
20:28:08 <roconnor> @what cells
20:28:09 <lambdabot> I know nothing about cells.
20:28:21 <sclv> FRP can mean like fifteen thousand things is the problem too -- "push" or "pull" etc.
20:28:22 <shapr> gwern: if kraftyswine had said "I haven't gotten any help on #haskell and that's frustrating me" I would have done my best to assist him.
20:28:24 <gwern> cells is lisp stuff iirc
20:28:36 <wkh> isn't that some dataflow thing?
20:28:45 <gwern> shapr: we pride ourselves on #haskell...
20:28:54 <sclv> yeah -- but hook it to gtk and you get an frpish system.
20:29:00 <shapr> Yes, the rules are "Be nice - or else"
20:29:31 <sclv> dataflow and frp are pretty similar too as far as i understand?
20:30:05 <sclv> there's continuous and discrete as well as push and pull as continua I should note...
20:30:06 <dolio> They're both use cases for arrows.
20:30:27 <dolio> Although I've heard it argued that comonads are a better fit for data flow.
20:31:09 * sclv crosses his arms and waits for a comonad dataflow library.
20:31:32 <solrize> comonads aren't arrows ?
20:31:49 <sclv> they can be, in a wrapper.
20:31:52 <dolio> Well, comonads give rise to coKleisli arrows.
20:31:57 <roconnor> cokliesli arrows are arrows
20:32:25 <dolio> But the idea is that the combinators your get with comonads are a better fit than the more general arrows.
20:32:26 <roconnor> sclv: there must be a comonad dataflow library somewhere.
20:32:33 <gwern> one day I will understand this sort of discussion
20:32:54 <sclv> i bet there isn't.
20:32:55 <roconnor> W a -> b is a coKleisli arrow where W is a comonad.
20:33:03 <shapr> gwern: Me too!
20:33:11 <dolio> http://cs.ioc.ee/~tarmo/papers/aplas05.pdf
20:33:28 <roconnor> @go haskell dataflow
20:33:29 <lambdabot> No Result Found.
20:33:35 <roconnor> :(
20:33:41 <sclv> I'm not sure I understand this discussion -- I read lots of papers when i get around to them, but I'm not exactly formally trained in any of this stuff...
20:33:41 <oerjan> roconnor: @go is buggy
20:33:44 <dmwit> ?go Control.Comonad
20:33:44 <TomMD> @go haskell information flow
20:33:48 <lambdabot> http://www.eyrie.org/~zednenem/2004/hsce/Control.Comonad.html
20:33:49 <lambdabot> http://www.cis.upenn.edu/~stevez/papers/LZ06a.pdf
20:33:50 <solrize> i look at a lot of papers that i don't understand at all, with the idea that i'm absorbing culture from them or whatever anyway
20:33:53 <shapr> sclv: Neither am I...
20:33:56 <gwern> shapr: oh noes! you is not a Haskell sage? my faith is shattered
20:33:57 <wkh> what is the benefit of having such weird abstractions
20:34:00 <shapr> So, who will offer us a course on all this?
20:34:02 <wkh> "where W is a comonad"
20:34:02 <TomMD> stevez has quite the info flow papers.
20:34:04 <gwern> what d'I believe in now?
20:34:07 <shapr> @quote index
20:34:07 <lambdabot> shapr says: Anyway, I'm just a walking index into the Haskell world. I can tell you a little bit about many things, but I will quickly forward you to the experts for more detail.
20:34:34 <vincenz> shapr: kraftsywine was abbrasive the other day as well
20:34:46 <vincenz> shapr: I almost kicked him then, but Cale was using the nice approach
20:34:48 <shapr> I'm sorry I missed it.
20:35:04 <shapr> Hopefully kraftyswine will understand that being nice helps.
20:35:05 <vincenz> just fyi
20:35:10 <shapr> Thanks
20:35:20 <sclv> wkh: there have been a bunch of papers looking for a benefit, but so far it doesn't seem there's been much concrete yet. it just seems that as the dual of a monad there *should* be a good use for them.
20:35:27 <dmwit> Oh, it even has a Functor w => Comonad w restriction.
20:35:45 <dmwit> There are not so many instances, though. =P
20:35:51 <dolio> @hackage category-extras
20:35:51 <sclv> conal has some very nice uses for cofunctors that I only sort of get, but that relate to his latest frp work.
20:35:51 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/category-extras
20:35:57 <roconnor> dmwit: but you don't get the functor instance for free. :(
20:36:15 <dmwit> roconnor: You still do: fmap = extend.
20:36:24 <dmwit> roconnor: You just have to write that.
20:36:39 <roconnor> so much typing
20:36:45 <dmwit> heh, yeah
20:37:19 <conal> sclv: contravariant functors are just the thing for consumers of values.
20:37:22 <dmwit> roconnor: Alternatively, you could define fmap, then write extend = fmap, and save yourself the "duplicate" definition.
20:37:36 * conal just tuned in
20:37:47 <dolio> extend isn't fmap.
20:38:06 <roconnor> dmwit: isn't there a default for extend in terms of coreturn and cobind?
20:38:11 <sclv> dolio: seen that dataflow paper before. uustalu and v have a bunch of new stuff too that i haven't even tried to tackle yet -- seems even more complicated. what i did understand i didn't find that compelling though.
20:38:12 <dolio> fmap f = extend (f . counit), I believe.
20:38:28 <roconnor> @type extend
20:38:29 <lambdabot> Not in scope: `extend'
20:38:40 <dmwit> Sorry, you're right, extend = liftW.
20:38:45 <sclv> at some point i read earlier things on comonads that suggested they could be the basis of an effects system, which i'd find to be an excellent and helpful abstraction...
20:39:06 <dolio> sclv: Yeah, I've read various papers on comonads, and nothing's ever clicked for me.
20:39:22 <dolio> Dataflow, attribute grammars, modal effects...
20:39:32 <roconnor> http://sigfpe.blogspot.com/2006/12/evaluating-cellular-automata-is.html
20:39:34 <lambdabot> Title: A Neighborhood of Infinity: Evaluating cellular automata is comonadic, http://tinyurl.com/2e55ly
20:39:54 <dolio> Oh, yeah, I suppose the celular automata/pointer stuff is decent.
20:40:07 <roconnor> ``So here's the deal: whenever you see large datastructures pieced together from lots of small but similar computations there's a good chance that we're dealing with a comonad.
20:41:07 <dolio> I read a paper not too long ago about using modal necessity (which is a comonad, I guess) in an effect system, and they argued that it worked better for delimited continuations, but I just couldn't see it.
20:41:56 <ddarius> dolio: Depends on the modal logic.
20:42:17 <wkh> who cares whether evaluating CA is comonadic? what does that get you?
20:42:43 <roconnor> wkh: the same thing you get when you see that state is a monad.
20:42:59 <wkh> which is what?
20:43:13 <dolio> It lets you reuse a whole bunch of functions that work in any monad.
20:43:14 <roconnor> wkh: good question.
20:43:27 <ddarius> mapM
20:43:53 <sclv> "iterate (=>> rule)" is the whole function to run a ca!
20:43:55 <wkh> code reuse. brevity. fewer bugs. no need to reinvent the wheel. that's what you get?
20:44:13 <wkh> do you get working code out to people faster
20:44:15 <wkh> that's all i care about
20:44:16 <sclv> that's sort of nifty, and once you get what a comonad is, its conceptually concise.
20:44:38 <roconnor> I think you also get a whole framework to think about the problem (assuming you are familiar with comonads) (this may or may not be a good thing).
20:45:31 <joricj> wow my first attempt at this and everything just works ! incredible !!
20:45:38 <sclv> #haskell reminds me of my old campus co-op a bit, 75% of the folks were there because they wanted to be in a co-op and 25% were there only because the rent was cheap.
20:45:43 <roconnor> joricj: welcome to haskell. :)
20:46:22 <cjb> joricj: cool, what did you do?
20:47:07 <codetoad> sclv: co-op: rent :: __ :__ ?
20:47:43 <sclv> functional programming : stock options
20:48:08 <sclv> (ish)
20:48:19 <roconnor> codetoad: I read that as a list begining with co-op and ending with rent has type ... huh, : isn't a type constructor.
20:48:28 <oerjan> 25% of people are in #haskell because of stock options? o_O
20:48:36 <codetoad> roconnor: i realized the error in my ways as soon as i hit return :0)
20:48:56 <hpaste>  joricl pasted "my very first program! it's *almost* an IRCd :D" at http://hpaste.org/6495
20:49:11 <glguy> oerjan: you didn't get your hpaste stock options?
20:49:20 <joricj> cjb: see hpaste
20:49:39 <roconnor> joricj: wow, that's more sophisticated than I was imagining.
20:49:53 <oerjan> glguy: no :(
20:50:06 <scook0> I read "rent was cheap" as "people who aren't super-enthused about haskell/types/ct/maths, but just want some help with haskell"
20:50:11 <glguy> joricj: Have you looked at the library on hackage for parsing and generating irc messages?
20:50:14 <joricj> i'm no noob :p just a noob to haskell. i read SICP and wanted to move up
20:50:51 <solrize> for "loop sock" you can write   forever $  accept sock >>= handle
20:50:56 <sclv> I guess I'm just talking about the ratio of startup/finance types to "whoa! cool!" types interested in fp in general.
20:51:17 <joricj> glguy: no but i'm glad you mention them! for my project i will probably have to alter them a bot though (i want really special syntax for channel names)
20:51:24 <roconnor> sclv: really?
20:51:48 <solrize> joricj you have just 1 thread per client which means if you are write blocked and the client sends you something, you won't see it
20:51:51 <sclv> well, i'm in new york, so the scene, which I only vaguely know, is sort of special...
20:51:52 <glguy> sclv: I'm not sure you've characterized many of the people in the channel at all
20:52:42 <joricj> solrize: what does write blocked mean? (i figured i would handle the writing to a Handle in startExecuting)
20:52:52 <Gwern-away> phooey. I hate when tor breaks the connection but irssi doesn't notice for a long time
20:53:07 <solrize> it means you send something to the outbound socket and are waiting for the write to complete
20:53:21 <joricj> or do you mean write blocked on the Chan?
20:53:28 <solrize> no on the handle
20:53:28 <joricj> ah
20:53:43 <solrize> something is wrong here too there is no loop in the client handler
20:53:44 <roconnor> solrize_: the reply's will be buffered right?
20:53:48 <roconnor> replies
20:54:16 <roconnor> solrize: I think the loop is part of joricj
20:54:16 <solrize> well the chan will buffer up messages, yes, but look at your hGetLine h
20:54:19 <roconnor> 's todo
20:54:23 <joricj> solrize: yes there are a couple of loops missing i couldn't wait to try it out and then i suddenly realized it was my first program so i figured oh well whats done is done
20:54:26 <solrize> that means you're waiting for the person at the other end to type soemthing
20:54:31 <solrize> and he's waiting to see something on the screen
20:54:37 <solrize> so you have outgoing messages ready to send
20:54:48 <solrize> but aren't sending them because you're blocked waiting for a read
20:54:57 <joricj> aha i understand it
20:55:15 <solrize> you really want, for each client, to be able to read stuff and write stuff independently
20:55:32 <solrize> so usually you'd use 2 threads with a chan for each thread
20:55:53 <roconnor> @hoogle newChan
20:55:53 <lambdabot> Control.Concurrent.Chan.newChan :: IO (Chan a)
20:55:56 <joricj> but how does making a seperate thread for that fix it? i mean i figure the second thread will also always block for a read?
20:56:06 <solrize> no one thread for reading, one for writing
20:56:28 <solrize> the writer thread loops taking data from the chan and sending it to the socket
20:56:37 <solrize> the reader thread loops reading data from the socket and sending it to the chan
20:56:43 <joricj> well yeah but iam already using diffrent threads for writing and reading (its just that iam only using *one* writer thread)
20:56:56 <solrize> your client handler is reading and writing
20:57:02 <joricj> no it's not
20:57:10 <solrize> oh hmm
20:57:16 <solrize> i see, you're putting io actiosn into the chan
20:57:22 <solrize> let's see, what's at the other end?
20:57:48 <solrize> there needs to be a loop somewhere at the otehr end of that chan
20:57:52 <joricj> what i want to do is the client threads they parse all the incoming strings to ClientEvents and line them up in a chan
20:58:00 <solrize> btw did you see dons' article about writing your own irc bot?  that says how irc messages look
20:58:21 <glguy> hpaste also has client code if you are interested
20:58:21 <joricj> no
20:58:23 <solrize> joricj that part is ok, but something has to be at the other end of the chan, processing the messages
20:58:36 <glguy> and an example of using two threads, one to listen and one to write
20:58:49 <solrize> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
20:58:50 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
20:58:52 <joricj> solrize: yes but it's a work in progress :D
20:58:59 <solrize> :)
20:59:16 <joricj> okay i am going to read that i will probably be right back with more questions :D
20:59:42 <solrize> i have to leave soon but the other ppl here can help
20:59:50 <joricj> ok
20:59:58 <joricj> thanks for all your help so far !
21:00:01 <solrize> np
21:00:06 * Gwern-away smirks. excellent, an opportunity to generalize using a fold!
21:00:19 <joricj> i really appreciate it a lot it helps sooo much if people look at your code and comment on it
21:02:00 <Gwern-away> hm, and I can generalize the operator I'm folding in... bwa ha ha
21:02:08 <Gwern-away> lispy will be happy when I'm done
21:04:59 <gwern> @src and
21:04:59 <lambdabot> and   =  foldr (&&) True
21:05:19 <gwern> :t foldr
21:05:22 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:06:05 <gwern> @src or
21:06:05 <lambdabot> or    =  foldr (||) False
21:16:24 <hpaste>  gwern pasted "I write unmaintainable code!" at http://hpaste.org/6496
21:17:24 * solrize looking at zipper article
21:17:27 <bd_> gwern: what's so unmaintainable about that?
21:17:48 <gwern> @src any
21:17:49 <lambdabot> any p =  or . map p
21:17:57 <solrize> data.map uses some old fashioned data structure like avl trees with tree rotations and all that ad hoc stuff
21:18:11 <solrize> do zippers handle that problem more generally?
21:18:17 <bos> no.
21:18:22 <gwern> bd_: look at it, it's got so many parameters, and it's a odd conditional on a fold on a map with paramterized operators and seeds and...
21:18:22 <sclv> solrize: they're sort of orthagonal.
21:18:25 <solrize> hmm
21:18:26 <bos> totally unrelated.
21:18:40 <Riastradh> Old-fashioned data structures like AVL trees?  (I think they're actually weight-balanced, if I recall correctly, not AVL trees.)  Ad-hoc stuff like rotations?
21:18:41 <bos> a zipper lets you navigate around inside the tree.
21:18:45 <sclv> as i recall the collections package provides zippers into maps
21:18:52 <gwern> solrize: a zipper is the derivative of a data structure
21:18:53 <bos> i believe that Data.Map uses red-black trees.
21:18:54 <Stinger> zippers are more like iterators aren't they?
21:18:55 <bd_> gwern: Well, I suppose, but it's not *big* enough to be unmaintainable. Also you've got that comment there too :)
21:18:57 <gwern> trees are trees
21:19:04 <bd_> though any/all would be better ofc
21:19:23 <solrize> well by old fashioned i just mean something that one reads about in wikipedia ;)
21:19:25 <bd_> Stinger: zippers are a generalization of iterators to non-linear structures, I believe
21:19:39 <bos> Stinger: zippers are vaguely like iterators.
21:19:40 <gwern> bd_: I think I may have the definition of subjectsNotToMbox wrong anyway
21:19:56 <bos> you can zipper over a limited number of kinds of structures.
21:20:07 <solrize> Zipper is a construction that lets us replace an item deep in a complex data structure, e.g., a tree or a term, without any mutation. The result will share as much of its components with the old structure as possible.  (from oleg abstract)
21:20:08 <bd_> there's also... what was it, functional accessors or something? The idea being you'd have a data Accessor container valuetype = Accessor { get :: container -> valuetype; set :: valuetype -> container -> container }
21:20:22 <bd_> and then you can composite such things
21:20:36 <sclv> functional references
21:20:43 <bd_> aha
21:20:55 <bd_> no wonder I was failing to google for it
21:20:59 <gwern> bd_: I;m not sure I could use any/all because of the type business going on - one of the parameters is a function like String -> EmailHeaderType
21:21:12 <sclv> I think deep-arrow implements a version of them?
21:21:33 <gwern> so I need to fold with the special boolean operators defined for EmailHeaderType (or whatever it actualkly is)
21:21:36 <sclv> also, um, the equally misnamed data.category
21:21:52 <bd_> gwern: why do you have special boolean operators for something that's not a boolean oO
21:22:00 <bd_> or rather, can you just map them to a [Bool]?
21:22:19 <solrize> how does genericzipper generically do updates?
21:23:21 <dolio> You write a traversal that generically updates a data structure, and turn it into an iterator using delimited continuations.
21:23:23 <sclv> is this oleg's zipper?
21:23:30 <solrize> yeah i guess so
21:23:45 <dons> ?yow
21:23:45 <lambdabot> UH-OH!!  We're out of AUTOMOBILE PARTS and RUBBER GOODS!
21:24:02 <sclv> everyone talks about it -- for production i've seen folks tend to use simpler hand-rolled ones.
21:24:35 <solrize> dolio, hmm, there's a generic way to flatten a data structure and insert a new value in the middle?  that's what seems odd.
21:24:37 <bd_> FRefs seem nicer to me - having to tell the zipper where to go and what to do in a very imperative way seems un-haskell to me :)
21:24:55 <bos> it seems that quite often people will have a poke at oleg's code, their heads will explode, and they'll find some other way to do their thing.
21:25:13 <gwern> (oleg's stuff is frightening)
21:25:21 <dolio> It's been a while since I read that article.
21:25:30 <sclv> well, the classical huet zipper seems cleaner for most purposes...
21:25:41 <dolio> I think the function that builds a zipper takes such a traversal function.
21:25:44 <solrize> bos ;)
21:25:54 <scook0> oleg's stuff is cool, but there tends to be a fundamental upper bound on how usable it can be without the cooperation of the language
21:26:06 <sclv> bd_: a zipper and an fref are for rilly different purposes though.
21:26:20 <dolio> So you write one for each data structure you make.
21:26:28 <dolio> And, of course, you could make a type class for that.
21:26:54 <dons> oleg's stuff helps notify developers on when the type system needs work :)
21:26:56 <gwern> @remember bos 00:24 < bos> it seems that quite often people will have a poke at oleg's code, their heads will explode, and they'll find some other way to do their thing.
21:26:56 <lambdabot> I will never forget.
21:26:58 <bd_> sclv: oh?
21:27:03 <dons> if oleg exploits something, likely that needs removing :)
21:27:06 <dolio> But ccshan's blog had a series of posts where they used scrap your boilerplate to make a zipper that worked over any Typeable or something like that.
21:27:27 <gwern> @quote bos
21:27:27 <lambdabot> bos says: imperative languages only go up to ten
21:27:29 <sclv> there's a functional pearl on that
21:27:53 <nolrai_> @pl op f1 f2 a1 a2 -> f1 (f2 a1) (f2 a2)
21:27:53 <lambdabot> (line 1, column 16):
21:27:53 <lambdabot> unexpected ">" or "-"
21:27:53 <lambdabot> expecting variable, "(", operator or end of input
21:28:04 <nolrai_> @pl op f1 f2 a1 a2 = f1 (f2 a1) (f2 a2)
21:28:04 <lambdabot> op = join . ((flip . ((.) .)) .) . (.)
21:28:25 <sclv> if your control flow is specified by the location of a zipper then it makes sense to use a zipper. if you want in place updates deep into a structure getting passed around by another form of control, then it makes sense to use an fref.
21:28:27 <dolio> Or, I guess, any Data.
21:28:31 <nolrai_> @type join
21:28:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
21:28:49 <gwern> heh. so haskell is a speaker that goes to 12 then?
21:28:57 <scook0> @src on
21:28:57 <lambdabot> (*) `on` f = \x y -> f x * f y
21:28:58 <gwern> ->? not =?
21:29:15 <nolrai_> thanks scook0
21:29:33 <sclv> i.e. if the job of your program is to walk around in a tree, then walking in a tree makes sense -- zippers give a neat solution to the same-fringes problem, for example, without the need for coroutines.
21:29:45 <solrize> cool
21:29:50 <solrize> yeah good point
21:29:55 <solrize> what's fref ?
21:30:02 <solrize> i mean is that a general thing like a zipper ?
21:30:11 <dmwit> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
21:30:13 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
21:30:18 <solrize> (symbolic calculus on datatypes with SYB, shudder)
21:30:28 <nolrai_> whats the lambdabot comand for geting what module somthing is in?
21:30:31 <solrize> thanks
21:30:35 <dmwit> ?index on
21:30:35 <lambdabot> bzzt
21:30:41 <sclv> and oleg's inside-out generic zipper is just a generalization of that -- i.e. that zippers and continuations are, over the domain of certain data structures, interchangable.
21:30:44 <dmwit> nolrai_: Well, it's ?index, anyway.
21:30:53 <scook0> an fref is basically the combination of a getter and a (pure) setter
21:30:55 <gwern> :info findSubstring
21:31:11 <dmwit> ?info do { x <- getLine; print x }
21:31:11 <lambdabot> getLine >>= \ x -> print x
21:31:30 <oerjan> nolrai_: @hoogle is also good, and more up-to-date i think
21:31:31 <dmwit>  ?info spell-corrects to ?undo. =)
21:31:47 <nolrai_> @hoogle (*) `on`
21:31:47 <lambdabot> Hoogle Error: Parse Error: Unexpected character '`on`'
21:31:48 <dmwit> ...oh, you meant in ghci.
21:31:59 <scook0> @hoogle on
21:32:00 <lambdabot> Data.Function.on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
21:32:00 <lambdabot> Text.ParserCombinators.Parsec.Char.oneOf :: [Char] -> CharParser st Char
21:32:00 <lambdabot> Data.Function :: module
21:32:34 <nolrai_> I did?
21:32:41 <solrize> so is SYB sort of a lisp interpreter that operates on the term types in a haskell program?
21:32:49 <dmwit> nolrai_: No, gwern did.
21:33:00 <nolrai_> oh, ok
21:33:18 <gwern> hm. this is tricky. I need a function such that if the entire list is True, it returns True, else False; and I need to make it work as a fold
21:33:40 <solrize> :t and
21:33:41 <lambdabot> [Bool] -> Bool
21:33:47 <oerjan> @src and
21:33:47 <lambdabot> and   =  foldr (&&) True
21:34:27 <gwern> ah, I see. the seed value forces it, otherwie a [False] would return True
21:34:48 <oerjan> ?
21:35:21 <dmwit> > foldr1 (&&) [False] -- oerjan
21:35:22 <lambdabot>  False
21:35:34 <gwern> and if I wanted the opposite, all True returns False, else true, then using False as the seed would force it the other way
21:35:48 <dmwit> ...no
21:35:59 <dmwit> gwern: That would evaluate *always* to False.
21:36:13 <dmwit> gwern: If you want the opposite, just stick (not .) at the beginning.
21:36:14 <oerjan> > foldr ((&&).not) False [True,True,True]
21:36:15 <lambdabot>  False
21:36:20 <oerjan> > foldr ((&&).not) False [True,True,False]
21:36:21 <lambdabot>  False
21:36:30 <gwern> @src foldr1
21:36:30 <lambdabot> foldr1 _ [x]    = x
21:36:30 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
21:36:30 <lambdabot> foldr1 _ []     = undefined
21:36:45 <oerjan> argh
21:36:48 <gwern> > foldr (&&) False [False, False]
21:36:48 <lambdabot>  False
21:37:07 <oerjan> > foldr ((||).not) False [True,True,False]
21:37:08 <dmwit> > foldr (join (liftM2 (&&)) not) False [True, True, True]
21:37:08 <lambdabot>  True
21:37:08 <lambdabot>  Couldn't match expected type `b -> b' against inferred type `Bool'
21:37:15 <oerjan> > foldr ((||).not) False [True,True,True]
21:37:15 <lambdabot>  False
21:37:22 <oerjan> that's it
21:37:24 <solrize> it looks like FRefs are not generic like zippers
21:37:30 <gwern> hm
21:37:49 <solrize> that stands to reason, it takes a lot of cleverness to see how to update an AVL tree in a way that preserves its invariants
21:37:56 <dmwit> :t join (liftM2 (&&)) not
21:37:57 <lambdabot> Bool -> Bool
21:38:21 <dmwit> oh
21:38:37 <dmwit> :t ap
21:38:38 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
21:38:44 <gwern> > foldr ((||) . not) False [False,False,False]
21:38:45 <lambdabot>  True
21:39:15 <gwern> > foldr ((||) . not) False [False,False,True]
21:39:15 <lambdabot>  True
21:39:18 <gwern> > foldr ((||) . not) False [True,True,True]
21:39:18 <lambdabot>  False
21:40:04 <dmwit> > foldr (||) True . map not $ [False, False, False]
21:40:05 <lambdabot>  True
21:40:32 <oerjan> dmwit: that's equivalent, i think there may even be a ghc rule to turn it into the first one
21:40:52 <dmwit> Oh, neat!
21:40:58 <dmwit> Is there a list of such rules somewhere?
21:41:06 <dmwit> (i.e. the rules that are actually used?)
21:41:11 <oerjan> or wait i'm not sure about the initial value
21:41:31 <oerjan> dmwit: see the source code
21:41:45 <dmwit> ?quickcheck \xs -> foldr (||) True (map not xs) == foldr ((||) . not) False xs
21:41:45 <lambdabot> Unknown command, try @list
21:41:54 <dmwit> ?check \xs -> foldr (||) True (map not xs) == foldr ((||) . not) False xs
21:41:55 <lambdabot>  Falsifiable, after 0 tests: []
21:42:31 <oerjan> dmwit: oh wait, i think the initial value should _not_ be changed
21:42:41 <dmwit> hum
21:42:49 <dmwit> ?src foldr
21:42:49 <lambdabot> foldr f z []     = z
21:42:49 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:42:57 <dmwit> Ah, quite right.
21:43:05 <dmwit> ?check \xs -> foldr (||) False (map not xs) == foldr ((||) . not) False xs
21:43:06 <lambdabot>  OK, passed 500 tests.
21:43:44 <oerjan> dmwit: the rule is probably in the Data.List source code
21:44:00 <dmwit> ?check \xs -> any not xs == foldr (||) False (map not xs)
21:44:01 <lambdabot>  OK, passed 500 tests.
21:44:11 <dmwit> "any not" is prettier. =)
21:45:15 <oerjan> hm no
21:45:31 <dmwit> Perhaps this does not do what gwern was asking for, though.
21:45:43 <oerjan> he said he needed it to be a fold
21:46:05 <dmwit> Yeah, plus it doesn't meet the spec:
21:46:12 <oerjan> probably for that unmaintainable paste :)
21:46:19 <dmwit> "all True returns false, else True"
21:46:35 <dmwit> oh
21:46:47 <dmwit> Okay, it does meet the spec. =)
21:47:22 <dmwit> ?check \xs -> any not xs == not (and xs)
21:47:23 <lambdabot>  OK, passed 500 tests.
21:47:43 <BMeph> mot . all? :)
21:47:50 <BMeph> s/mot/not/
21:47:59 <dmwit> not . and
21:48:06 <dmwit> all /= and
21:49:02 <BMeph> Right - I always forget how all/any and and/or are def'd.
21:49:32 <dmwit> Me too. =)
21:50:00 <dmwit> It's like ?src vs. ?source, though I'm getting that one right more often now.
21:51:16 <oerjan> dmwit: i think the rules in question are in http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html but it's a bit complicated (map gets expanded to use build, then foldr + build is optimized, or something like that)
21:51:16 <wkh> :t (*) . (*)
21:51:17 <lambdabot> forall a. (Num a, Num (a -> a)) => a -> (a -> a) -> a -> a
21:51:17 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/yqjxlq
21:51:22 <wkh> boobies!!!!!!!!!!!
21:51:39 <joed> Hah
21:51:44 <dmwit> :t (.) . (.) -- the canonical boobies =)
21:51:45 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
21:51:50 <gwern> ?users
21:51:50 <lambdabot> Maximum users seen in #haskell: 464, currently: 419 (90.3%), active: 15 (3.6%)
21:52:12 <dmwit> Ooph, that type-sig is even hairier with Functors than it was before.
21:52:34 <dmwit> oerjan: thanks
21:52:46 <glguy> ?let (.) f g x = f (g x)
21:52:46 <lambdabot> L.hs:9:0:     Multiple declarations of `L..'     Declared at: <local>:10:0   ...
21:52:54 <glguy> ?undefine
21:52:55 <lambdabot> Undefined.
21:52:57 <glguy> ?let (.) f g x = f (g x)
21:52:57 <lambdabot> L.hs:9:0:     Multiple declarations of `L..'     Declared at: <local>:1:0    ...
21:53:04 <dmwit> oerjan: I'm especially fond of the comment 'build = error "urk"'. =D
21:53:07 <glguy> borked
21:54:20 <dmwit> (.) is probably a local definition like (.) = fmap.
21:54:32 <glguy> yeah, shame considering that lambdabot is used for teaching people
21:54:33 <glguy> :-/
21:54:43 <oerjan> glguy: it is in the default file, so it's still there after @undefined
21:54:46 * wkh wishes to place bets on when java people will realize that exception handling is pattern matching for babies
21:54:54 <wkh> i say 15 years.
21:55:03 <dmwit> But... it's not.
21:55:18 <dmwit> You can catch exceptions of several different types, thanks to inheritance.
21:55:45 <dibblego> Scala pattern matches for exceptions and handles inheritance
21:55:47 <dmwit> (+ a block can throw several different types of exceptions)
21:55:58 <dibblego> case e // any exception
21:56:05 <wkh> catching any of several different exception types does not resemble pattern matching to you.
21:56:11 <dibblego> case e: Foo // Foo or any subclasses
21:56:26 <wkh> fine.
21:56:41 <dibblego> it's pattern matching
21:56:46 * dmwit re-evaluates
21:56:53 <dibblego> with a catch keyword instead of case
21:58:21 <dmwit> I would consider this form of exception catching strictly more powerful than pattern matching.
21:59:22 <dibblego> more powerful because the keyword is longer?
21:59:46 <dmwit> Say we line up catching an instance of an exception in Java with matching against a constructor in Haskell.
21:59:59 <dmwit> In Java, you can add a subclass without breaking old code.
22:00:19 <dmwit> In Haskell, adding a constructor *can* break old code, because the pattern match is no longer exhaustive.
22:00:32 <dibblego> does haskell have open sum types?
22:00:47 <dmwit> I'm not sure, what is an open sum type?
22:01:06 <dibblego> one where the constructors are not necessarily finite
22:01:06 <glguy> can you add constructors to a data type defined in another module? no
22:01:29 <dmwit> glguy: That sounds like your on my side. =)
22:01:34 <dibblego> you're
22:01:36 <dmwit> s/your/you're/
22:01:38 <dmwit> sorry
22:01:42 <dibblego> that's mk :)
22:01:51 <glguy> I wasn't sure if I was even answering the question, so I restated to be clear :)
22:02:03 <dibblego> are you saying that Java's inheritance is more powerful than Haskell's type classes then?
22:02:10 <dmwit> No.
22:02:22 <dibblego> but you can derive new subclasses without breaking code
22:02:54 <dmwit> The correspondence is usually done a different way than (Java class <=> Haskell constructor).
22:03:06 <glguy> you can add instances of a typeclass too
22:03:29 <dibblego> open types are not more powerful
22:03:38 <dmwit> If you make the correspondence (Java class <=> Haskell class), then I would consider Haskell more powerful.
22:03:53 <dmwit> But then the exception catching does not have so obvious of an analog.
22:04:27 <dibblego> Java's implicit case _ is not grounds for being more powerful
22:04:38 <dmwit> Oh, I just read your definition of open sum types.
22:04:53 <dmwit> What do you mean by infinite: infinite arity, or an infinite number of constructors?
22:04:59 <dibblego> number of constructors
22:05:01 <dmwit> Never mind, Haskell doesn't really have either.
22:05:41 <dmwit> Oh yeah, there's a "case _".
22:06:04 <dmwit> (Sorry if my replies seem a bit disjointed, xchat is reporting some 3-4s lag.)
22:07:28 --- mode: ChanServ set -o shapr
22:07:48 <levi> Hi, folks.  I've got a quick question.  I'm writing a program with a state monad, and I keep changing the members of the structure that holds the state.
22:08:27 <dons> dibblego: type classes are open (you can add new instances later), and you can encode data type constructors in instances, fwiw
22:08:34 <levi> This means that, with how I've written things, I have to change all the pattern matches I use for destructuring and updating the state.
22:08:52 <dmwit> levi: Try using records.
22:08:54 <dons> dibblego: but check "the expression problem", there's a tension between add new functions, and adding new data type variants
22:08:54 <bos> @src odd
22:08:54 <lambdabot> odd = not . even
22:08:57 <bos> @src even
22:08:57 <lambdabot> even n = n `rem` 2 == 0
22:09:13 <levi> dmwit: Er, I am using records, I just forgot the right name for them. :)
22:09:36 <levi> dmwit: Is there a handy way to make a new record with just one element changed?
22:09:44 <dmwit> levi: x { foo = newFoo }
22:09:47 <bos> levi: a { foo = 1}
22:09:58 <bos> @quote stereo
22:09:58 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
22:10:02 <bos> dammit.
22:10:20 <levi> So, x (or a) is the record, and foo is the accessor for the element?
22:10:23 <bos> @remember Cale Welcome to #haskell, where your questions are answered in majestic stereo!
22:10:23 <lambdabot> Done.
22:10:28 <dmwit> levi: yes
22:10:42 <bos> levi: it's special magic syntax.
22:10:44 <levi> (I'm sorry if I'm messing up the names, I'm still fairly new to Haskell)
22:10:59 <levi> Very handy special magic syntax.  Thanks, this will clean up my code a lot.
22:11:43 <dmwit> ?quote magic
22:11:44 <lambdabot> qwe1234 says: real programmers write their own garbage collectors instead of using a magic black box from godforsaken academic website.
22:11:44 <oerjan> @quote stereo
22:11:44 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
22:12:04 <oerjan> bos: it's not that the quote is missing, there is something buggy
22:12:08 <oerjan> @quote stereo!
22:12:08 <lambdabot> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
22:12:16 <oerjan> oh yes
22:12:21 <bos> how weird.
22:12:27 <dmwit> ?quote majestic
22:12:27 <lambdabot> C-a-l-e says: Welcome to #haskell where your questions are answered in majestic stereo!
22:12:28 <oerjan> @forget Cale Welcome to #haskell, where your questions are answered in majestic stereo!
22:12:28 <lambdabot> Done.
22:12:33 <dons> i never tracked that one down
22:12:41 <dons> now, Cale's the maintainer, its his problem
22:12:43 <dons> :D
22:12:47 <dmwit> hahahaha
22:12:51 <bos> frickin' haskell, can't write any reliable software in it.
22:12:56 <dons> hehe
22:13:08 <dons> my lambdabot at galois' been up for 3 months now
22:13:09 <bos> i'm turning in my badge and going back to PHP.
22:13:10 <dons> fwiw
22:13:22 <dons> but lambdabot was never a high assurance device
22:13:24 <dmwit> ?remember dons <dons> i never tracked that one down <dons> now, Cale's the maintainer, its his problem
22:13:24 <lambdabot> Good to know.
22:13:37 <dons> more a pile of candy held together with sticky glue
22:13:47 <lament> yum
22:13:48 <dmwit> mmmm cadny
22:13:52 <bos> dons: you underestimate the importance of seven 9s of availability of pithy quotes.
22:13:57 <dons> heh
22:14:46 <dons> :t (.) -- however, i'm not sure about this
22:14:47 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
22:14:52 <dons> oh, its reverted!
22:15:06 <dmwit> wha?
22:15:08 <dons> Cale, did you back down on the haskell++ support?
22:15:16 <dons> :t (++)
22:15:17 <lambdabot> forall a. [a] -> [a] -> [a]
22:15:20 <dons> yep, looks like it
22:15:36 <dons> these were all monoidal functory 1.4-ish things last week
22:15:39 <dmwit> But, but... just earlier tonight it was still fmap!
22:15:50 * dons rejoices
22:15:55 <dons> haskell returns to #haskell !
22:16:15 <dmwit> \bot hasn't even quit since (.) = fmap!
22:16:20 <dmwit> How does that happen?
22:16:29 <glguy> it must be written in Erlang
22:16:29 <dmwit> revert + ?undefine, I guess.
22:16:31 <dons> oh, the prelude @eval uses can change on the fly
22:16:40 <dons> loosly coupled and all that
22:16:44 <lament> glguy: hah
22:16:53 <dons> 7 nines of @eval availability
22:17:03 <dmwit> 7 nines... is a lot of nines.
22:17:08 * dons smacks glguy . hs-plugins!! woo
22:17:14 <dons> take that erlang!
22:17:27 <dmwit> > (1 - 99.99999) * 365 * 24 * 60 * 60
22:17:28 <lambdabot>  -3.12206368464e9
22:17:34 <dmwit> See!
22:17:37 <dmwit> oh
22:17:40 <dmwit> > (100 - 99.99999) * 365 * 24 * 60 * 60
22:17:41 <lambdabot>  315.36000010009957
22:17:54 <lament> 5 minutes
22:17:57 <dmwit> You get 3s downtime all year!
22:18:15 <dmwit> That's longer than it takes to even notice the thing is down.
22:18:24 <lament> oh, 3s
22:18:47 <dons> 3 bots would be enough to keep it up all the time, i reckon :)
22:18:52 <dons> just multiplex them
22:19:00 <dons> have one take over for the other
22:19:08 <lament> dons: is there a non-buzzwordy explanation of what galois does?
22:19:18 <dons> lament: high assurance software
22:19:22 <lament> galois.com/methods.php is pretty embarassing to read
22:19:25 <dmwit> Gotta have them in different locations + figure out a way for them to monitor each other.
22:19:38 <dmwit> I guess that wouldn't be *so* hard to do.
22:19:42 <lament> dons: right, i mean methods used
22:19:54 <oerjan> > x
22:19:55 <lambdabot>  x
22:19:58 <dons> lament: theorem proving and functional programming
22:20:43 <dons> also, -Ofun
22:22:37 <lament> does it involve proving that a program has no bugs? :)
22:22:56 <dons> there are people employed to do that, yeah
22:23:35 <lament> hm
22:23:47 <lament> that does seem more effective than unit testing
22:23:55 <dons> heh
22:24:02 <dons> yeah, just a little
22:24:06 <lament> but kinda hard in a general case
22:24:21 <dons> right.
22:24:29 <dons> or we'd all be doing it, yeah?
22:24:36 <dmwit> Luckily, they just have a lot of specialized cases. ;-)
22:24:40 <dons> its suppposed to be hard, that's why it pays well :)
22:25:02 <lament> so i guess for the most part you don't _actually_ prove bug-freeness?
22:25:14 <joed> huh?
22:25:15 <dons> no, you want to prove specific things your customer really really cares about
22:25:17 <cjs_> Any 'leet ghc hackers here?
22:25:18 <gwern> dons: what do they have you doing?
22:25:38 <dons> haskell stuff, gwern
22:25:39 <lament> dons: methods.php mentions "automated test generation", which seems far from any sort of proof
22:26:05 <cjs_> /usr/pkg/lib/ghc-6.8.2/lib/base-3.0.1.0/libHSbase-3.0.1.0.a(Internals.o): In function `base_SystemziPosixziInternals_zdwccall16_info':
22:26:06 <cjs_> : warning: warning: reference to compatibility opendir(); include <dirent.h> for correct reference
22:26:18 <gwern> dons: well, I know that :) I mean, do they have you writing infrastructure stuff like HalFS or byestrings, or are you working on theorems or applications or what?
22:26:18 <dons> lament: sounds like a blurb for QuickCheck ?
22:26:25 <cjs_> I'm a little bit mystified as to where I go to fix this.
22:26:35 <dons> lament: substitute 'formal' or 'model' for "the theorem guys do this bit"
22:27:07 <dons> gwern: bit and pieces from low to medium. i'm not one of the formal methods guys though (as you can probably guess)
22:27:15 <dons> cjs_: missing --make ?
22:27:23 <dons> oh hmm. base.
22:27:39 <solrize> dons do they believe in GHC for shipping high assurance code?
22:27:42 <gwern> (the 'theorem guys' gave it away, yes)
22:27:58 <dmwit> cjs_: Dunno, have you got the libraries that GHC depends on?
22:27:59 <gwern> solrize: what else could they use, really?
22:28:01 <cjs_> Yeah, it's appeared in the NetBSD package since it was upgraded from 6.6 to 6.8. I just need to tweak a header file somewhere, obviously.
22:28:22 <dons> solrize: yeah, haskell's a key technology
22:28:39 <lament> dons: does that mean you verify bug-freeness of ghc as well?
22:28:50 <cjs_> I'm pretty sure I do. This is running haskell code just fine; it's just that that message has started appearing since the upgrade.
22:28:53 <lament> you pretty much have to
22:28:54 <dons> lament: for some things, we check the generated code
22:28:58 <lament> ah
22:29:07 <dons> there's lots of different approaches
22:29:14 <dons> some involve larger or smaller trusted components
22:29:24 <gwern> how can you check the generated code? asm is hard to prove stuff about. do you just test it a ton?
22:29:43 <dmwit> cjs_: Where does it appear?  When building GHC, or when using GHC to build your own apps?
22:30:03 <cjs_> dmwit: sorry, when using ghc to build my apps.
22:30:15 <dmwit> huh
22:30:23 <dons> gwern: i don't think i can really talk about the methods. but they involve lots of Isabelle.
22:31:16 <gwern> (darn NDAs)
22:32:23 <solrize> do they still use cryptol ?
22:32:23 <glguy> nondeterministic automata?
22:32:54 <BMeph> Good night, all. :)
22:33:01 <dmwit> nondisclosure agreements (in case you were really confused, and not just making a joke)
22:34:08 <solrize> i guess if GHC is 3x less reliable than Spark/Ada in terms of errors introduced per line of input code, and it takes 10x as much Ada code as Haskell code to implement something, then Haskell is beating Ada by 3 to 1 even with a less reliable compiler
22:34:33 <dons> i've no idea if its 3x less reliable :) how reliable is Ada?
22:34:42 <cjs_> Hm. I wonder if it's related to how I'm building stuff.
22:34:45 <dons> but yeah, productivity is a big part of it
22:34:53 <gwern> solrize: well, I think ghc is a pretty reliable compiler - all the other ones seem to be even worse
22:35:09 <dmwit> dons: Have you ever caught GHC in an error?
22:35:16 <glguy> heh
22:35:16 <dons> found a bug in ghc, dmwit ?
22:35:19 <gwern> dons: apparently ada has pretty impressive types and safety features for an imperative language
22:35:19 <cjs_> Nope. Ordinary ghc on "main = do return ()" gives that message.
22:35:19 <dmwit> yes
22:35:40 <dons> maybe once a year i catch it generating the wrong result.
22:35:43 <solrize> err just last night there was something about an unchecked pointer in the array module
22:35:49 <dons> most issues are optimisations not firing, or wibbles
22:35:59 <glguy> solrize: that is the intended behavior
22:36:12 <glguy> solrize: a conscious decision
22:36:12 <dons> solrize: sure, a library issue. and the intended behaviour
22:36:15 <dons> not a compiler issue
22:36:25 <dmwit> dons: Dunno about wibbles, but the other means slow but correct code still comes out?
22:36:29 <solrize> oh i thought that was a bug, and it got a patch checked in
22:36:31 <solrize> what's a wibble ?
22:36:42 <dmwit> (Also, I'm fairly surprised by once a year, that's pretty good.)
22:36:46 * gwern ran into a bug day before yesterday where a ghc=compiled binary crashed on x86_64 but not i386
22:36:55 <dons> little improvements here and there to things. not affecting correctness or performance
22:38:21 <solrize> from sci.crypt: >I'm somewhat out of my field, but I have looked into this, so here's
22:38:21 <solrize> >what I think I know:  From a security standpoint, the primary advantage
22:38:21 <solrize> >of Ada over the other languages Wagner names (except I know nothing of
22:38:21 <solrize> >E), is that Ada itself is more reliable.  The Ada community has invested
22:38:21 <solrize> >colossal resources into solidifying the standard and validating
22:38:22 <solrize> >compilers.
22:38:25 <dons> gwern: 64 bit bug in an ffi binding? :)
22:38:41 <solrize> he's talking about ada compared with haskell, ML, etc.
22:38:58 <gwern> dons: so far as I could tell, there was no ffi involved
22:38:59 <gwern> pure haskell
22:39:05 <gwern> well, except for gtk
22:39:19 <dons> ok, so it wasn't pure haskell :)
22:39:19 <gwern> but the issue doesn't involve the gui afaic
22:39:29 <dons> did you boil it down to a test case?
22:39:35 <dons> solrize: yeah, ada had a huge investment in it
22:40:28 <solrize> i remember asking what kinds of methods the aerospace crowd uses to make software reliable (i.e. what did they know that other industries didn't) and the answer was "they know how to spend a boatload of money"
22:40:52 <dons> heh
22:41:02 <gwern> dons: no. zmachine was way too complex for me to figure out what was triggering the bug or not - it's reliably and reproducible, I posted a bug with straces and system config info
22:41:11 <gwern> I'll see what the devs say when they get around to replying to it
22:41:22 <lament> gwern: you're implementing the z machine?
22:42:08 <gwern> lament: no, SamB did
22:42:09 <dmwit> solrize: Wagner... he's a pretty smart guy.
22:42:11 <dmwit> ;-)
22:42:32 <solrize> yes :)
22:42:37 <lament> solrize: just hire ten guys to review everything the programmer is writing in a systematic way and you'll probably be fine
22:42:41 <gwern> (it's an amusing little bug - type in 'look map' and crash it every time, but 'look at map' runs fine)
22:42:58 <lament> er
22:43:19 <lament> that's... really odd
22:43:30 <solrize> ada is designed to be readable by nonprogrammers, so that (e.g.) jet engine designers who know about heat flow but aren't coders can be in the code reviews for the jet engine code
22:43:48 <dons> maybe it was readable in the late 80s :)
22:43:52 <solrize> heh
22:44:06 <lament> i'm sure most things are readable to jet engine designers
22:44:10 <dons> heh
22:44:22 <dmwit> There's a famous story that Haskell is so readable, a group submitted a Haskell program to a contest, and it was initially rejected because they thought it was just pseudocode.
22:44:22 <lament> "it's rocket science"
22:44:39 <solrize> lol dmwit, that was hudak's navy paper
22:44:50 <dmwit> Right.
22:44:54 <solrize> mostly it was because it was so short
22:44:57 <dons> dmwit: its been heard of in here, that students submit executable haskell as pseudocode :)
22:45:01 <solrize> 2 pages of haskell vs 1000+ lines of ada
22:45:01 <lament> dmwit: haskell is only readable until you start to use higher-order-functions often
22:45:10 <dmwit> dons: Done it a few times myself. =)
22:45:16 <dons> lament: what, like 'map' ?
22:45:30 <dmwit> It  helps to be able to try out your pseudocode and see if it works. =P
22:45:56 <dons> i like my pseudo code to type check, compile to asm, and run damn fast :)
22:46:18 <oerjan> @remember dons i like my pseudo code to type check, compile to asm, and run damn fast :)
22:46:18 <lambdabot> It is stored.
22:46:21 <lament> dons: map is fine :) lifts, arrows and other stuff not so much. I guess I really meant higher-order types
22:48:37 <dmwit> ?quote :)
22:48:38 <lambdabot> <Cale> says: Inheritance? Inheritance is broken, anyway :)
22:48:41 <dmwit> ?quote :)
22:48:41 <lambdabot> <Cale> says: Inheritance? Inheritance is broken, anyway :)
22:48:43 <dmwit> ?quote :)
22:48:43 <lambdabot> numerodix says: tbh people who do haskell on their own initiative kinda creep me out :)
22:48:57 <dmwit> ?quote :(
22:48:57 <lambdabot> Plugin `quote' failed with: regex failed: (ReturnCode 8,"Unmatched ( or \\(")
22:49:03 <dmwit> ?quote :\(
22:49:04 <lambdabot> puusorsa says: do not try this in a shell: :() { :&:; } ;:
22:49:26 <dmwit> fork bomb!
22:50:08 <MyCatVerbs> dmwit: life isn't really worth living unless you're creeping somebody out.
22:50:14 <MyCatVerbs> dmwit: the more the merrier, even!
22:50:18 <dmwit> heh
22:55:31 <solrize>  The Space Shuttle On-board
22:55:31 <solrize> Software development group has a world-renowned engineering
22:55:31 <solrize> process.  They produce reliable, validated software, for about
22:55:31 <solrize> $20,000 per line.  The software controlling commercial passenger
22:55:32 <solrize> jets is also highly reliable and reportedly costs less: just
22:55:34 <solrize> $15,000 a line.   (also from sci.crypt, same thread)
22:56:06 <cjs_> Now look how much cheaper it would have been to do it in assembler....
23:01:14 <JohnMeacham> Actually, ada was a ploy to slow down the communist efforts at programming: more details here http://www.pipeline.com/~hbaker1/sigplannotices/gigo-1997-04.html
23:01:14 <lambdabot> Title: Sigplan Not. Apr 1997: I Have a Feeling We're Not in Emerald City Anymore
23:03:28 <solrize> my officemate used to use Ada and while this is not exactly a great recommendation for Ada, he and various other people I know think that C is even worse
23:04:22 <lament> i thought ada was supposed to be good
23:04:25 <solrize> Lisp, APL, Prolog, Smalltalk and Forth.    (from Baker paper).     which of those is not like the others?  :)
23:04:44 <dons> "Ada: C is worse" :)
23:04:44 <lament> haha
23:04:53 <dmwit> solrize: All of them?
23:05:03 <lament> solrize: Forth
23:05:07 <lament> all others have "l" in the name
23:05:23 <solrize> ada seems like a reasonable alternative to C from what i can tell, i.e. low level verbose imperative, but much less undefined behavior and unsafety than C
23:05:43 <gwern> APL. none of the others are all caps
23:06:35 <JohnMeacham> unboxed haskell is a great little imperitive language.
23:07:03 <solrize> john yeah dons was describing that last night, it sounds interesting
23:07:22 <solrize> what do you do about memory management in it?
23:07:26 <lament> Lisp - all others are useful for something ;)
23:08:11 <JohnMeacham> smalltalk, it's the only one without a type theoretically pure decendent.
23:08:32 <JohnMeacham> (hasakell, J, mercury, and joy for the others)
23:09:13 <solrize> i'd like to learn something about typed assemblers but the papers i've looked at are confusing
23:09:25 <lament> Prolog - it's the only one they teach at my university (unless you count Scheme as Lisp)
23:11:44 <gwern> heh. and the circle is complete
23:16:26 <solrize> @faq do they write realtime code in GHC ?
23:16:26 <lambdabot> The answer is: Yes! Haskell can do that.
23:23:08 <solrize> so anyone got a sense of how to write a sorting program in haskell, where the main goal is to use all the ram in the computer for the internal sort/merge passes?
23:27:38 <vegai> @faq Can Haskell generate a program that it cannot run, and then run it?
23:27:38 <lambdabot> The answer is: Yes! Haskell can do that.
23:28:16 <scook0> @faw I have a nasty itch behind my ear, is Haskell responsible?
23:28:16 <lambdabot> The answer is: Yes! Haskell can do that.
23:28:31 <Mr_Awesome> hahahaha
23:28:42 <Mr_Awesome> well played
23:28:49 <dmwit> ?far out!
23:28:49 <lambdabot> The answer is: Yes! Haskell can do that.
23:28:50 <MyCatVerbs> @faq Murder thirty people with a fork?
23:28:50 <lambdabot> The answer is: Yes! Haskell can do that.
23:33:20 <bd_> ?faq Can Haskell be used to write a FAQ bot that passes the turing test?
23:33:20 <lambdabot> The answer is: Yes! Haskell can do that.
23:33:23 <bd_> Wow!
23:36:00 <solrize>     When Bell Labs were invited to evaluate C against the DoD
23:36:00 <solrize>     requirements, they said that there was no chance of C meeting
23:36:00 <solrize>     the [STEELMAN] requirements of readability, safety, etc, for
23:36:00 <solrize>     which we were striving, and that it should not even be on the
23:36:00 <solrize>     list of evaluated languages. We recognized the truth in their
23:36:01 <solrize>     observation and honored their request.
23:36:05 <solrize>        William H. Whitaker, Col, USAF (ret), "Ada - The Project:
23:36:07 <solrize>        The DoD High Order Language Working Group", History of
23:36:09 <solrize>        Programming Languages - II, ACM SIGPlan Notices, v.28, #3,
23:36:11 <solrize>        March 1993, pg 314
23:39:51 <cjs_> What's the nice way to figure out how many seconds we currently are from a particular date and time?
23:40:11 <oerjan> @hoogle timediff
23:40:11 <lambdabot> System.Time.TimeDiff :: data TimeDiff
23:40:11 <lambdabot> System.Time.TimeDiff :: Int -> Int -> Int -> Int -> Int -> Int -> Integer -> TimeDiff
23:40:11 <lambdabot> System.Time.timeDiffToString :: TimeDiff -> String
23:40:23 <dmwit> :t diffUTCTime
23:40:25 <lambdabot> Not in scope: `diffUTCTime'
23:40:33 <dmwit> ?hoogle diffUTCTime
23:40:33 <lambdabot> Data.Time.Clock.diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime
23:40:45 <cjs_> So what's the diff between System.Time and Data.Time.Clock stuff?
23:40:51 <oerjan> oh
23:40:54 <dmwit> I've found Data.Time to be much more complete than System.Time.
23:42:53 <vegai> there's also System.Posix.Time if you weren't confused enough before
23:42:57 <cjs_> So if I want to let t = 2008-03-21T17:10+0900, how do I say that?
23:43:09 <cjs_> Posix me harder.
23:43:15 <dmwit> ?hoogle readTime
23:43:16 <lambdabot> Data.Time.Format.readTime :: ParseTime t => TimeLocale -> String -> String -> t
23:43:38 <dmwit> See the docs for more information about how to format the two string arguments.
23:44:12 <taruti> Data.Time seems to lack a nice way of specifying non-absolute time differences.
23:44:26 <dmwit> ?
23:44:54 <dmwit> What is an absolute time difference?
23:45:02 <taruti> e.g. "+one month" "+one week" "+one day" "+one hour"
23:45:32 <dmwit> What's wrong with (60 * 60 * 1000) or whatever?
23:45:34 <taruti> dmwit: something that could be represented as a number of seconds, i.e. the duration does not depend on the start.
23:45:45 <taruti> dmwit: one month can be 28-31 days.
23:46:04 <dmwit> ah, yes
23:46:04 <taruti> depending on the date it is aplied to.
23:46:20 <dmwit> Yeah, I don't think there's a nice way to do that.
23:46:28 <scook0> with edge cases when the following month has fewer days
23:47:07 <Pseudonym> exit
23:47:25 <scook0> that sort of thing is arguably the domain of an extra module, rather than Data.Time itself
23:47:33 <scook0> but it would be useful, either way
23:47:45 <taruti> data DiffCalTime = DiffCalTime { years :: Int, months :: Int, days :: Int, time :: NominalDiffTime } kind of works.
23:47:56 <taruti> together with Data.Time.Calendar
23:47:58 <cjs_> Hm. "1 month" is one month. It can't be converted to days.
23:48:15 <cjs_> It can only be added to or subtracted from a date.
23:48:42 <scook0> indeed
23:50:07 <scook0> and once you have the framework for handling that sort of thing, you can also start looking at "next tuesday" and "friday week"
23:50:48 <adu> "friday week"?
23:51:09 <dmwit> friday weekly or maybe a week from friday
23:51:20 <dmwit> But yes, a natural-language time library would be nice.
23:51:55 <adu> I think there are 3 distinctly different kinds of time
23:51:57 <solrize> there's a C library function like that, which has been ported to python
23:52:03 <solrize> it would be nice to rewrite or port it to haskell
23:53:21 <adu> time points, time intervals, and (definite | indefinite) repeated time (points | intervals),
23:53:56 <adu> i guess thats actually 6
23:54:36 <Twey> Heh
23:56:42 <cjs_> runghc gives me "Failed to load interface for `Main':". Huh? I have a "main = ..." and can compile and run with ghc.
23:57:03 <adu> cjs_: do you have a "module Main where"?
23:57:16 <cjs_> Ah, the module needs to be called Main as well? Got it, thanks.
