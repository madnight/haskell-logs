00:00:35 <Cale> omg911: The standard doesn't forbid it but the implementations all do.
00:01:02 <solrize_> it would be ok if other modules in a file were visible only within that file
00:26:55 <JohnMeacham> there was an implementation that allowed multiple modules per file.
00:28:29 <scook0> sometimes I'd like to hide the constructors of a datatype from all but the most primitive functions
00:28:47 <scook0> but I rarely bother spinning off a separate file just for that
00:29:55 <scook0> having "package-private" exports would be convenient at times as well
00:39:42 <Brandon-b91b> has anyone here taken a gander at the haskell finger tree code?
00:39:59 <Cale> I have. At least, I've looked at the paper.
00:40:34 <Brandon-b91b> what was your impression?
00:40:47 <Cale> It's a rather clever and general data structure.
00:41:42 <Cale> Also, it's currently under-used. For example, it would be really nice to have a priority queue and interval tree library implemented in terms of it, like the paper shows how to do.
00:42:41 <marshmallows> does anyone have a regex -> NFA and NFA parser in Haskell? (I'd like to compare with my one in a different language)
00:43:25 <Cale> marshmallows: I have something I hastily put together a while back.
00:43:35 <Brandon-b91b> yeah, it definitely has potential ; I am playing with the idea of making a C implementation and wanted to use the Haskell code for inspiration
00:44:16 <Cale> marshmallows: http://cale.yi.org/autoshare/Regular.hs
00:46:24 <Brandon-b91b> Cale, the paper you read, would it be helpful in this reguard?
00:46:34 <marshmallows> thank you Cale
00:46:47 <Cale> Brandon-b91b: Oh, certainly, I wouldn't try implementing them without reading the paper :)
00:46:52 <Cale> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
00:46:53 <lambdabot> Title: Finger Trees: A Simple General-purpose Data Structure
00:47:05 <Brandon-b91b> :) thanks
00:48:58 <Cale> How to abstract over a general monoid will be fun in the C implementation. You might end up with a struct having fields for the unit and operation :)
00:50:59 <Cale> marshmallows: btw, to run an NFA on a string, use derivNFA. I had a bit of an odd mindset while I was writing that code ;)
00:51:00 <Brandon-b91b> Hahaha, fun is one thing you could call it... step 1- implement haskell, step 2- write tree using implementation
00:51:20 <solrize_> what do finger trees do that zippers don't ?
00:51:39 <marshmallows> It's pretty cool
00:51:54 <solrize_> there is a heap lib somewhere
00:52:02 <solrize_> for priority queues
00:52:26 <Cale> solrize_: They're completely different constructions, at least as I see it. For any datastructure, you can take that datastructure and form a zipper for it, which is its derivative together with an additional element to "plug the hole"
00:53:34 <Cale> solrize_: A finger tree is a tree datastructure which is parametrised by a given monoid (which is like a general combining operation) and it leads to things like sequences with efficient splitting and concatenation, priority queues, interval sets, and so on.
00:54:01 <solrize_> oh i didn't realize that, i thought it was just a tree structure that you could point to places in like a zipper
00:54:44 <Cale> It's sort of a funky 2-3 tree.
01:06:22 <dons> matthew-_: "<matthew_-> I'm sorry, but xmonad does not rule. IMHO, xmonad is a cut down version of a Windows "Wizard", trying to tell me how I want my screen laid out."
01:06:25 <dons> boo!
01:07:26 <marshmallows> "Haskell type system does not rule, always telling me how I want my values to fit together" :P
01:08:08 <matthew-_> boo
01:08:13 <Cale> Someone add window borders and enough EWMH support to get interoperation with Gnome working well and I'll use it :)
01:08:27 <matthew-_> that was a rather rude awakening ;)
01:08:44 <dons> Cale, both work now.
01:08:59 <dons> there's full(-ish) EWMH, and a moderate gnome community
01:09:07 <Cale> hmm... :)
01:09:21 <dons> so you can use those dock apps, in particular
01:09:32 <dons> i believe we're the only tiling wm that tries to support gnome
01:09:35 <Cale> If I can pretend that it's not a tiling window manager at all, that would be cool :)
01:09:40 <dons> heh
01:09:51 <dons> that's probably a stretch. a few people do use it without any tiling algorithms though
01:10:08 <dons> its your patriotic duty, as a member of #haskell
01:10:12 <Cale> hehe
01:10:44 <Cale> I should add a module to make it behave exactly like Metacity :)
01:11:28 <dons> e.g. http://ivanmiljenovic.files.wordpress.com/2008/01/xmonad_screenshot.png
01:11:43 <dons> looks like lots of wacky gnome thingies in the menu
01:12:06 <Cale> That's xfce actually, but yeah.
01:12:19 <dons> yeah, there's similar shots for gnome things, but i've not got those to hand
01:12:24 <Cale> The pager looks like it might be working :)
01:12:36 <dons> there's a gnome configuration page
01:12:42 <dons> http://haskell.org/haskellwiki/Xmonad/Using_xmonad_in_Gnome
01:12:42 <lambdabot> Title: Xmonad/Using xmonad in Gnome - HaskellWiki
01:13:02 <capitrane> http://ivanmiljenovic.files.wordpress.com/2008/01/xmonad_screenshot.png
01:13:09 <Cale> Do you handle, say, switching desktops with the pager?
01:13:21 <dons> i think nomeata got that working at the hackathon last september
01:13:25 <dons> i remember him showing it to me
01:13:38 <dons> i'm unsure if that's currently the case
01:13:59 <dons> resistance is futile though
01:14:04 <dons> just so you know :)
01:14:21 <Cale> When I tried it last, the pager knew what windows were on each desktop, but it wouldn't let you manipulate them by drag and drop, or switch desktops
01:15:08 <dons> ok. it would be useful to identify some gnome integration champions to work on ensuring this all works well
01:27:53 <Feuerbach> wtf is Oleg style?
01:27:53 <lambdabot> Feuerbach: You have 1 new message. '/msg lambdabot @messages' to read it.
01:28:43 <marshmallows> I guess that would be the style of code Oleg usually writes
01:29:05 <marshmallows> A pretty high quality standand I've seen..
01:29:08 <Feuerbach> and who is Oleg? some celebrity?
01:29:24 <marshmallows> he co-authored The Reasoned Schemer, so yes
01:29:34 <taruti> type system wizard
01:29:40 <marshmallows> and also Pure Declarative Constructive Arithmetic
01:29:59 <marshmallows> more than just some type level factorial :P
01:40:25 <oerjan> @where oleg
01:40:26 <lambdabot> http://okmij.org/ftp/
01:43:25 <thoughtpolice> i'm pretty sure the typechecker is scared of him.
01:44:15 <marshmallows> > [ (x,y,z) | x <- [1..] , y <- [1..x] , z <- [1..y], x^2 + y^2 == z^2 ]
01:44:24 <lambdabot> Terminated
01:45:18 <marshmallows> > [ (x,y,z) | x <- [1..] , y <- [1..x] , z <- [1..y] , x^2 == y^2 + z^2 ]
01:45:19 <lambdabot>  [(5,4,3),(10,8,6),(13,12,5),(15,12,9),(17,15,8),(20,16,12),(25,20,15),(25,24...
01:46:32 <xerox> > [ undefined | x <- [1..y] , y <- [1..] ]
01:46:33 <lambdabot>  Exception: not a number
01:47:00 <Cale> that's an interesting exception there :)
01:47:13 <marshmallows> > [ undefined | x <- [1..7] , y <- [1..] ]
01:47:13 <lambdabot>  Undefined
01:47:21 <Cale> ah, right
01:47:27 <Cale> y is an Expr
01:47:38 <xerox> Indeed :-)
02:05:36 <matthew-_> su
02:05:41 <matthew-_> oops, ww.
02:05:58 <marshmallows> Password:
02:06:27 <matthew-_> hang on, this machine isn't called marshmallows...
02:06:50 * marshmallows hides :p
02:10:19 <Syzygy-> Password:
02:10:39 <vss> hi
02:10:51 <Syzygy-> (he COULD have a machine called Syzygy- :)
02:11:10 <vss> I'm confused by exception handling / documentation on that
02:11:17 <matthew-_> hmm. I don't though
02:11:24 <matthew-_> I don't think any of my machines are on #haskell
02:11:51 <vss> I'm trying to catch a specific exception, thrown by System.Directory.createDirectory. The manual literally says:
02:12:03 <vss> createDirectory :: FilePath -> IO ()
02:12:13 <vss> The operation may fail with:
02:12:23 <vss> #  isAlreadyExistsError / AlreadyExists The operand refers to a directory that already exists.  [EEXIST]
02:12:48 <matthew-_> yep, so it may call fail within the IO monad, I think. Thus you can catch it
02:12:52 <vss> now, first, I can't find where AlreadyExists is defined
02:13:03 <vss> second, the type info is:
02:13:10 <vss> Prelude> :t System.IO.Error.isAlreadyExistsError
02:13:11 <vss> System.IO.Error.isAlreadyExistsError :: IOError -> Bool
02:13:30 <vss> while Control.Exception.handleJust is:
02:13:52 <vss> Prelude> :t Control.Exception.handleJust
02:13:52 <vss> Control.Exception.handleJust :: (GHC.IOBase.Exception -> Maybe b)
02:13:52 <vss>                                 -> (b -> IO a)
02:13:52 <vss>                                 -> IO a
02:13:53 <vss>                                 -> IO a
02:14:25 <vss> does it mean I can't use System.IO.Error.isAlreadyExistsError as a predicate for Control.Exception.handleJust?
02:15:18 <matthew-_> handleJust isn't what you want, I don't think
02:15:23 <xerox> ?docs System.IO.Error
02:15:24 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/4/System-IO-Error.html
02:15:33 <xerox> s/4/base/
02:15:45 <xerox> Check out the (fixed) url.
02:16:02 <vss> ok, will do and report back :-) thanks
02:16:38 <matthew-_> I'd just use catch
02:16:50 <matthew-_> or basically, you're doing `mplus` IIRC
02:17:39 <matthew-_> @instances MonadPlus
02:17:39 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
02:18:40 <matthew-_> hmm. where is that IO instance defined?
02:19:58 <matthew-_> ahh, Control.Monad.Error
02:20:12 <unenough> As a Haskell noob, i'm wondering: If haskell is so great (as it is) why haven't I heard of any application written in haskell?
02:20:41 <marshmallows> lol
02:20:59 <marshmallows> unenough: Some people haven't even heard of perl
02:21:08 <matthew-_> unenough: everyone accepts C is a terrible language. Yet that doesn't mean there aren't MANY programmes written in C
02:21:27 <matthew-_> vss: try something like: (createDirectory "~/tmp/" >> putStrLn "ok") `mplus` (putStrLn "boo")
02:21:27 <unenough> marshmallows: good for them!
02:21:36 <ibid> C is not a terrible language
02:21:57 <unenough> C is good for its purposes except for a few glitches
02:22:03 <marshmallows> unenough: my point is you're like them
02:22:05 <thoughtpolice> unenough: if you've heard of GHC you have heard of an application (a fairly industrial-strength one) written in haskell
02:22:40 <unenough> (=/== confusion, array/pointer confusion (array not being like struct), and several pitfalls)
02:22:57 <unenough> thoughtpolice well obviously there must be a haskell compiler...
02:23:16 <unenough> my point is, can you point me to some haskell applications? not development tools
02:23:24 <unenough> just to see what people have done
02:24:20 <thoughtpolice> yeah, there must be. but that doesn't mean it has to be written in haskell (hugs is written in C.)
02:24:41 <thoughtpolice> also i don't see how GHC being a compiler excludes it from the list of applications written in haskell.
02:24:45 <ksandstr> I wrote some XML processing programs in Haskell at my previous work, for producing invoices -- but that was private code
02:24:49 <thoughtpolice> but if you want another good example, google 'xmonad'
02:24:54 <thoughtpolice> or just join #xmonad
02:25:04 <ibid> unenough: darcs, yi, house?
02:25:20 <ibid> unless those are classed as development tools :)
02:25:35 <thoughtpolice> also look through here for libs/applications of all sorts:
02:25:36 <thoughtpolice> http://hackage.haskell.org/packages/archive/pkg-list.html
02:25:50 <unenough> darcs is in haskell? ok that's one i didn't know
02:25:51 <vss> unenough: frag
02:26:17 <thoughtpolice> also there is lambdabot who we all love
02:26:27 <vss> unenough: http://www.haskell.org/haskellwiki/Frag
02:26:29 <lambdabot> Title: Frag - HaskellWiki
02:26:53 * vss pats lambdabot on its back
02:26:58 <unenough> frag looks nice
02:27:04 <ibid> an auxiliary script in debian's build-essential package was originally (bad) haskell
02:27:40 <ibid> when i passed it on to other maintainers, they rewrote in a language they know (python, iirc)
02:28:04 <ibid> but it was my first real-world use of haskell
02:28:54 <ibid> unenough: i also have a simple board game written in haskell. haven't touched in years, though
02:29:00 <bd_> which script?
02:29:08 <unenough> i'm still a little disappointed, but i'm hoping that it's because of the ratio of haskell coders to any other popular language (very low)
02:30:07 <unenough> "haskell" has only about 7.5 million hits in googls
02:30:10 <unenough> google
02:30:14 <ibid> bd_: list2depends
02:30:28 <bd_> google's result estimates can be wildly inaccurate in either direction :)
02:30:32 <thoughtpolice> also note that there's probably large quantities of haskell code sitting behind some corperate walls (galois, bluespec, credit suisse); so the up-front examples here don't indicate too much.
02:30:46 <unenough> bd_ the order of magnitude is probably correct
02:30:49 <thoughtpolice> and lots of stuff that isn't on hackage either
02:30:59 <bd_> unenough: yeah, probably
02:31:05 <bd_> +- a digit or two
02:31:14 <ibid> hmm, i should probably go do some mainenance on my stuff
02:31:35 <unenough> c++ has 104 million, php has 8 billion (piece of crap), perl 97 million
02:31:50 <bd_> php gets all the deployments as well
02:31:53 <bd_> ".php" and all that
02:31:54 <unenough> yeah
02:32:01 <bd_> (extensions in URLs considered harmful)
02:32:06 <unenough> i don't care about php anyway
02:32:29 <thoughtpolice> haskell's motto is "avoid success at all costs" anyway
02:32:37 <unenough> c# has 70 million
02:32:41 <thoughtpolice> (might have changed)
02:32:51 <unenough> heh....
02:33:00 <ksandstr> so that's that for google-based research? :)
02:33:15 <unenough> ksandstr yes i'll write a paper with that data
02:33:25 <matthew-_> hmm. isn't the entire xandros or linspire build system written in haskell?
02:33:50 <thoughtpolice> matthew-_: linspire is supposed to use haskell heavily in development but I'm not sure how
02:34:02 <ibid> unenough: ask aleator (when he's here) what he's doing with haskell :)
02:34:04 <bd_> linspire's based on debian, so a lot of it is shell and make :) But I've heard they use haskell somewhee
02:34:15 <thoughtpolice> http://urchin.earth.li/pipermail/debian-haskell/2006-May/000169.html
02:34:16 <ibid> (basically, uses it as a better matlab for research:)
02:34:17 <matthew-_> IIRC, most of their infrastructure is haskell. But again, I don't know the details
02:34:18 <lambdabot> Title: [Debian-haskell] Linspire/Freespire Core OS Team and Haskell, http://tinyurl.com/kztsr
02:34:40 <vss> guys, can you enlighten me on how IOError is [technically] linked to IO? Where is that spelled that any IO () computation can return IOError? I'm trying to understand it, not just use.
02:36:05 <matthew-_> IOError is a type synonynm for IOException
02:36:11 <vss> ok, I see that
02:36:32 <vss> ...and?
02:36:37 <matthew-_> @source throwIO
02:36:37 <lambdabot> throwIO not available
02:36:43 <bd_> throwIO is a primitive
02:36:56 <vss> is it hardwired into compiler?
02:36:57 <thoughtpolice> :t ioError
02:36:58 <bd_> yep
02:37:00 <lambdabot> forall a. IOError -> IO a
02:37:14 <matthew-_> hmm. it looks slightly magic from the source
02:37:24 <bd_> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IOBase.html#throwIO
02:37:25 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/2rxblz
02:37:26 <unenough> isn't freespire/linspire slightly irrelevant due to ubuntu?
02:37:38 <unenough> kubuntu/xubuntu/edubuntu/etc.
02:37:41 <bd_> things ending in # are hardwired into GHC
02:37:45 <bd_> and also completely unportable
02:38:04 * vss is checking that out
02:38:21 <matthew-_> yeah, IME, IO is generally not a good citizen at all.
02:38:41 <matthew-_> look at how it works with other, better behaved monads and then just tread IO the same. ;)
02:38:47 <matthew-_> *treat
02:39:05 <vss> :-)
02:39:10 <bd_> runIO :: RealWorld -> IO a -> (IO a, RealWorld)? :D
02:39:13 <bd_> er
02:39:14 <unenough> anyway guys, maybe i'll be the one who writes the killer haskell application. later
02:39:18 <bd_> (a, RealWorld) even
02:39:20 <vss> I haven't completely grok monads yet :-)
02:39:24 <unenough> (first I need to know what a monad is)
02:39:31 <bd_> (note, this is how IO is implemented in GHC)
02:40:18 <solrize_> happs is potentially a killer app
02:40:27 <matthew-_> vss: there are plenty of good tutorials out there on Monads. And #haskell is quite useful too ;0
02:40:33 <solrize_> if it's nearly as good as alexj makes it sound
02:41:06 <marshmallows> happs needs to build to be killer....
02:41:10 <solrize_> hehe
02:41:17 <vss> so would you guys advice to assume that IOError is just a magic "subtype" of IO and not sweat it at this point?
02:41:39 <thoughtpolice> happs would at least be more killer than it is if some documentation would appear, i think.
02:41:40 <ksandstr> the IO monad is special in other ways too. not the best spot to look to understand monads
02:41:41 <bd_> vss: It's not a subtype, it's just a magic exception type that IO throws magically :)
02:41:56 <vss> matthew-_, I've read a plenty and I seem to understand that, just never happened to use them yet
02:41:59 <bd_> It's very carefully not defined how that works
02:42:16 <bd_> You don't understand monads until you've used them, and implemented a few yourself :)
02:42:35 <bd_> Fortunately implementing some simple monads isn't too hard.
02:42:39 <vss> bd_, well, I've used Maybe alredy (with do notation I mean)
02:42:57 <bd_> IIRC, the light came to me when I implemented Cont on paper
02:42:58 <Lemmih> thoughtpolice: There's haddock documentation, a few tutorials and a bunch of examples.
02:42:58 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
02:43:11 <marshmallows> is there a list somewhere of EVERY haskell monad?
02:43:21 <marshmallows> not just the std ones
02:43:27 <thoughtpolice> marshmallows: check the haskellwiki
02:43:36 <thoughtpolice> there are links to a lot of different and interesting ones
02:43:39 <Lemmih> marshmallows: If it doesn't build on your platform, report a bug.
02:44:06 <bd_> marshmallows: It's often useful to make application-specific monads too, so you're never going to find a complete list... ofc, those application specific monads are usually just a bunch of standard ones glued together
02:44:43 <marshmallows> cool :o
02:44:47 <marshmallows> pi calculus monad
02:44:55 <vss> ok, thanks guys..
02:46:17 <pjd> @instances Monad
02:46:18 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
02:47:03 <bd_> 13 type or newtype'd monads (all built out of existing mtl monads of course) in one program I'm writing :)
02:49:11 <bd_> (most used only within one module)
02:49:38 <unenough> actually I love C, except for the few glitches
03:10:53 <solrize_> happs gave up on xslt and now wants to populate pages with client side ajax?
03:12:43 <Lemmih> HAppS doesn't care if you use xslt or not. You can use whatever templating system you want.
03:14:27 <solrize_> i've had the idea of writing an xslt compiler in haskell, that maybe would even turn the stylesheet into haskell code and then run ghc on it
03:14:49 <solrize_> xsl to machine code with loop fusion etc., yum
03:16:10 <taruti> xslt is painful to write
03:16:25 <solrize_> hmm
03:16:37 <taruti> if you can use Haskell then writing the transformations in Haskell instead of xslt will probably be nicer
03:16:48 <solrize_> yeah i think web designers are used to php-like template systems
03:17:13 <solrize_> i remember happs had a lot of magic to automagically map haskell datatypes to xml and vice versa
03:27:56 * qwr wonders, why would anybody want xslt, when they have haskell at hand
03:30:37 <Heffalump> we have a bunch of XSLT scripts at work, some of which we've rewritten in Haskell.
03:49:17 <syntaks> hello everyone
03:49:45 <syntaks> Can the following be made to work? I want to declare a class (Show a, Typeable a) => MyClass a ... and I have default implementations for all the methods such that I could write instance (Show b, Typeable b) MyClass b. But this leads to ambiguties, whenever something explicitly implements MyClass
03:50:19 <syntaks> SO what I want to express is "Whenever something is not an i9nstance of MyCLass, use the default"
03:52:51 <opqdonut> i think enabling ambigous instances (a ghc extension) does what you want
03:52:52 <opqdonut> it chooses the most specific one
03:53:34 <syntaks> do you mean UndecidableInstances?
03:53:38 <opqdonut> yeah, that
03:53:42 <matthew-_> no
03:53:45 <matthew-_> that won't work
03:53:50 <opqdonut> oh ok
03:53:53 <matthew-_> decisions are NEVER made on the instance context
03:53:57 <matthew-_> only on the instance head
03:54:04 <matthew-_> regardless of any ghc extension
03:54:10 <syntaks> I tried it already, to that effect
03:54:57 <syntaks> is there a way top constrain the instance head such that it does only apply for types to deriving MyClass themself?
03:55:05 <opqdonut> perhaps i misunderstood you, what did you mean with the "(Show b,  Typeable b) MyClass b.
03:55:09 <opqdonut> "
03:55:11 <opqdonut> bit
03:55:51 <syntaks> opqdonut: I meant that anything that is Typeable and Show should be an instance of MyClass by using some default methods that I wrote
03:56:17 <syntaks> however, for some of my types, I want to declare other implementations
03:56:40 <opqdonut> yeah but if you then make a (say) "instance MyClass Integer", isn't it more specific than the default one
03:57:01 <opqdonut> (i'm trying to understand why UndecideableInstances didn't help)
03:57:17 <syntaks> that's what I thought, but it didn't work
03:57:53 <syntaks> oh wait, I only said UndecidableInstance in the module decalring the class, not the one defining the explicit instance...
03:57:57 <syntaks> let me check again
04:00:30 <syntaks> I get overlapping instances error for the default one and the explicit one
04:02:28 <syntaks> I'll put together a little test case that you can look at.. right now there is too much other stuff in there
04:03:00 <jrx> hi everyone
04:03:09 <jrx> I've got two types:
04:03:29 <jrx> ErrorT E (StateT S Identity)
04:03:31 <jrx> and
04:03:40 <jrx> ErrorT E (StateT S IO)
04:04:19 <jrx> have you got any ideas how I can lift from the first to the second?
04:06:49 <opqdonut> syntaks: ok, nice :)
04:07:08 <opqdonut> :t runIdentity -- jrx
04:07:11 <lambdabot> Not in scope: `runIdentity'
04:07:15 <opqdonut> gah
04:07:20 <opqdonut> ?source Identity
04:07:20 <lambdabot> Identity not available
04:07:34 <opqdonut> well, runIdentity :: Identity a -> a
04:07:52 <opqdonut> so something like lift (return.runIdentity)
04:08:58 <jrx> but isn't it that I can runIdentity only after runErrorT and runStateT?
04:12:57 <syntaks> opqdonut: http://hpaste.org/6569
04:13:06 <syntaks> opqdonut: that reproduces the effect
04:14:36 <taruti> syntaks: -fallow-overlapping-instances ?
04:14:46 <Heffalump> jrx: yeah. I think to lift you need to write something customised, or perhaps involving lift.
04:15:02 <opqdonut> syntaks: ah, yes, -overlapping too
04:15:20 <syntaks> trying...
04:15:47 <opqdonut> btw, i usually put default implementations in "instance (Typeable b, Show b) => MyClass b"
04:16:03 <opqdonut> but i guess it's really equivalent
04:17:11 <syntaks> opqdonut, taruti, yep OverlappingInstances does the trick ;)
04:17:16 <opqdonut> good :)
04:17:38 <syntaks> opqdonut: I tried that too and I also think it's nicer... this is what I ended up with while testing things
04:17:46 <opqdonut> :)
04:18:03 <syntaks> thanks a lot... I'm still a bit confused by the many different options
04:19:47 <syntaks> phew... it also works with my real code =)
04:34:42 <Baughn> How do you pronounce >>=? Bind?
04:35:07 <hallongrottan> yes
04:35:18 <marshmallows> not =<< ?
04:35:44 <skorpan> =<< is dnib
04:35:49 <hallongrottan> lol
04:35:56 <hallongrottan> sup skorpan
04:36:38 <skorpan> hallongrottan: nothing much
04:36:45 <skorpan> still trying to fix these bugs in my program
04:36:49 <hallongrottan> ah
04:36:58 <skorpan> i think i've fixed the checkmate bug now, but there's still a lot of work to do on the pawn movement
04:37:03 <hallongrottan> ah
04:37:05 <hallongrottan> i see
04:37:08 <skorpan> how's your project coming then?
04:37:11 <hallongrottan> well
04:37:26 <hallongrottan> i just got to school so i'm about to get the math thingy to work
04:37:48 <hallongrottan> i had a weird bug which made the program to realign notes
04:39:24 <skorpan> hallongrottan: up for a trip to monas?
04:39:48 <hallongrottan> hmm
04:39:51 <hallongrottan> sounds nice actually
04:39:57 <hallongrottan> i'm in 3217 atm
04:40:17 <hallongrottan> trying to download memtest, but for some reason that won't work
04:40:22 <skorpan> lol
04:40:29 <skorpan> okay so i'll meet you there
04:40:32 <skorpan> brb
04:40:33 <hallongrottan> sweet
04:42:26 <jrx> Heffalump: any clues, how to write it?
04:45:14 <dancor> what is the correct way to create include/*.h files from include/*.h.in files with cabal for cbits/-ery
04:55:06 <Heffalump> jrx: hmm. I think you just have to unwrap and rewrap.
04:55:23 <Heffalump> the last time I remember doing it was in lambdabot, and that's roughly what I seem to have done there.
05:20:58 <hallongrottan> @pl map (\x -> x+1) [1..100]
05:20:58 <lambdabot> map (1 +) [1..100]
05:21:04 <skorpan> @pl \x -> game (fst x) y (snd x)
05:21:04 <lambdabot> uncurry (flip game y)
05:24:18 <jrx> Heffalump: ok, I'll try
05:32:52 <smg> > fix let f x = if x < 2 then 1 else x * (f(x-1))
05:32:52 <lambdabot>  Parse error at "let" (column 5)
05:33:15 <mauke_> s/let/\\/, s/=/->/
05:37:05 <smg> mauke: true
05:41:13 <benny99> did anybody in here ever use SDL with Haskell? -- I guess I need some "lockable monad" now :(, but I got no idea
05:41:21 <Feuerbach> is there a way to hide some part of literate Haskell program from lhs2TeX?
05:41:46 <Feuerbach> some code, I mean
05:43:38 <allbery_b> look at the comment package for LaTeX
05:44:41 <benny99> is there a "What a former C++-Programmer has to know about 'class-member-variables' in Haskell"-tutorial maybe?
05:44:46 <allbery_b> http://www.tex.ac.uk/cgi-bin/texfaq2html?label=conditional
05:44:48 <lambdabot> Title: TeX Frequently Asked Questions -- question label "conditional"
05:45:41 <mauke> Haskell has no classes (in the C++ sense)
05:45:42 <allbery_b> (you can probably get away with the simple stuff at the top that they call risky, since you actually *want* it to see the \begin{code} so it won't get confused by what's inside it)
05:45:58 <benny99> mauke: I know
05:46:06 <mauke> so what's there to know?
05:46:46 <benny99> mauke: well, I got a variable that I don't want to pass around in all the functions and can only be accessed by one function at a time
05:46:54 <Feuerbach> allbery_b: great, thanks!
05:46:57 <benny99> mauke: like a g
05:46:59 <allbery_b> mauke: presumably how to carry data around the sdame way member variables do.  which I would call State
05:47:05 <Jedai> benny99: Somewhere on the HaskellWiki you have a comparison between OO style and Haskell
05:47:05 <benny99> mauke: like a global variable in C or something
05:47:15 <paczesiowa> what's wrong with hs-plugins-1.1 ? it fails to configure because of missing files
05:47:18 <mauke> yeah, sounds like State
05:47:30 <benny99> allbery_b: yeah, sorry, I'm still new to Haskell :(
05:47:37 <benny99> yeah, I guess so
05:47:45 <benny99> Jedai: thanks :)
05:47:53 <Jedai> benny99: There's also this extension of GHC that allows you to create function that takes implicit parameters
05:48:20 <benny99> Jedai: http://www.haskell.org/tmrwiki/FpVsOo ?
05:48:21 <lambdabot> Title: FpVsOo - TmrWiki
05:48:21 <Jedai> benny99: But if you modify it, State is better
05:49:14 <pjd> if you don't modify it, you can use Reader
05:50:05 <benny99> Jedai: well, in C it's a pointer to the 'screen variable' that just some 'video-related-functions' got to use
05:50:21 <benny99> I have to modify it I guess
05:52:05 <Jedai> I was more thinking of http://www.haskell.org/haskellwiki/OOP_vs_type_classes but I guess your page is fine too
05:52:06 <lambdabot> Title: OOP vs type classes - HaskellWiki
05:54:41 <Jedai> benny99: And the SDL module don't already provide the necessary abstraction ?
05:54:50 <Jedai> That seems a little bit strange
05:55:10 <benny99> Jedai: I got no idea
05:55:31 <benny99> Jedai: I should take a look at that first ;)
05:56:04 <pjd> benny99: are you actually trying to do that same thing in Haskell, or was it just an example?
05:56:15 <benny99> I'm trying to do it
05:56:55 <benny99> but I didn't mind that the SDL-binding-author might already have done it :-[
05:57:39 <pjd> if you were doing it from scratch, you'd want to look at the FFI
05:57:50 <benny99> pjd: thanks :)
05:58:02 <benny99> pjd: yeah, I'd want to know it anyway
05:58:04 <Jedai> benny99: It seems the Haskell functions don't require this variable (they probably thread it along in the library itself)
05:58:08 <pjd> and you'd probably be using the IO monad and other low-level things, rather than State/Reader
05:58:24 <pjd> and expose a higher-level interface
05:58:34 <benny99> yep, the bindings use IO for sure so far
05:59:20 <Jedai> benny99: Given the nature of the stuff (I/O) it requires sequencing, and has side effect, so the IO monad make sense
05:59:24 <benny99> (http://www.cse.unsw.edu.au/~chak/haskell/ffi/ ?)
05:59:26 <lambdabot> Title: The Haskell 98 Foreign Function Interface 1.0
05:59:47 <benny99> Jedai: yeah - but pjd mentioned the Reader/Writer Monad
06:00:38 <Jedai> benny99: The Reader/Writer monad don't allow side-effect, nor strict sequencing
06:01:04 <pjd> s/allow/provide/
06:01:28 <olsner> with unsafePerformIO, anything provides side-effects :P
06:01:39 <Jedai> benny99: To just thread a state, they'll do, but for side-effecting actions (like GUI actions) they won't
06:01:46 <benny99> Jedai: ah :) -- damn, I really don't know that much, yet =/
06:02:41 <Jedai> benny99: The only place where unrestricted side-effect are possible is the IO monad
06:02:51 <allbery_b> http://hpaste.org/3137 ?
06:03:16 <allbery_b> GUI actions are generally in IO (because they're actions)
06:05:39 <b_jonas> "note that we hide mutable state inside IORefs, since there is no way otherwise to sneak mutable data past callbacks." -- it doesn't want generalized MonadIO? :)
06:08:21 <benny99> (ah, hsdl provides Surface)
06:08:30 <allbery_b> gtk2hs, at least, doesn't use MonadIO, it uses IO.
06:08:46 <allbery_b> if it had been written to use MonadIO in its callbacks, there wouldn't be a problem
06:09:25 <allbery_b> (rather, MonadIO m => m a instead of IO a)
06:09:31 <benny99> isn't IO a monada ?
06:09:33 <benny99> -a
06:09:39 <skorpan> it is
06:09:55 <benny99> :-[ what is the difference between MonadIO and IO then ?
06:10:03 <opqdonut> MonadIO is a typeclass
06:10:15 <benny99> ah
06:11:07 <benny99> (yeah, type class actually rings a bell ;) )
06:11:15 <allbery_b> MonadIO is a typeclass, IO is a specific instance.  if it used a typeclass then I could use anything which was a member of MonadIO as a callback, so I could use ReaderT IO without the ugly wrapper stuff in that hpaste
06:12:18 <benny99> (what do you think about The Haskell School of Expression btw. ?)
06:12:27 <allbery_b> @instances-importing Control.Monad.Reader MonadIO
06:12:28 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
06:13:08 <benny99> allbery_b: I actually even understood that :)
06:15:19 <benny99> thanks
06:15:58 <allbery_b> I should say instance of, not meber of; typeclasses aren't classes, as previously noted.  (they do, however, resemble java interfaces)
06:16:43 <benny99> allbery_b: you did "MonadIO is a typeclass, IO is a specific instance"
06:20:17 <allbery_b> yes, but then I said "...member of MonadIO..."
06:20:30 <paczesiowa> can anyone successfully build any version of hs-plugins?
06:23:54 <dolio> I'm pretty sure I've built the latest darcs version with 6.8.2.
06:24:04 <dolio> Or, if not the latest, close to it.
06:25:46 <pcmoritz> hi, i've got a question: does there exist a globally optimizing algorithm for prettyprinting (something like TeX's paragraph breaking algorithm)
06:26:02 <paczesiowa> I'll try darcs, hackage versions are broken (missing makefile files? come on, we typecheck the untyped and publish broken archives?)
06:26:46 <dolio> The hackage version is pretty old.
06:26:59 <dolio> It only builds on 6.6, I think.
06:27:00 <hallongrottan> @pl filter (\x -> pos x == Left') ns
06:27:00 <lambdabot> filter ((Left' ==) . pos) ns
06:27:16 <hallongrottan> oh snap
06:29:02 <hallongrottan> @pl [x | x <- xs, isPrime x]
06:29:02 <lambdabot> [x | x <- xs, isPrime x]
06:29:06 <hallongrottan> ok lol
06:29:15 <xerox> filter isPrime
06:29:21 <hallongrottan> yeah i know
06:29:28 <hallongrottan> just wanted to see if lambdabot thought so too :P
06:29:30 <paczesiowa> dolio: "error: C compiler cannot create executables" sounds familiar from those darcs builds of hs-plugins?
06:29:39 <mauke> @undo [x | x <- xs, isPrime x]
06:29:39 <lambdabot> concatMap (\ x -> if isPrime x then [x] else []) xs
06:29:46 <mauke> @. pl undo [x | x <- xs, isPrime x]
06:29:46 <lambdabot> flip (liftM2 if' isPrime return) [] =<< xs
06:29:55 <dolio> No, can't say that it is.
06:30:05 <dolio> Are you trying to use make or something? You mentioned makefiles.
06:30:16 <dolio> I'm pretty sure I built it with cabal.
06:30:23 <paczesiowa> 0.9.10 was makefile only
06:30:35 <dolio> runhaskell Setup.lhs configure ; runhaskell Setup.lhs build ; runhaskell Setup.lhs install
06:30:37 <paczesiowa> I try cabal too with darcs
06:31:07 <hallongrottan> @type liftM2
06:31:08 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
06:31:15 <olsner> I think I've seen that, caused by the current-directory detection (IIRC, a piece of haskell that does something trivial) in the configure script
06:31:34 <dolio> Huh, I didn't know undo did list comprehensions.
06:35:08 <paczesiowa> http://hpaste.org/6572 where does this garbage come from?
06:36:33 <Zao> paczesiowa: Smells like a colour escape code.
06:36:42 <allbery_b> no, terminal setup
06:37:12 <benny99> I still wonder how to store my "screen" now... the function that creates the screen returns it as Surface (Maybe a) -- where Surface is a  ForeignPtr SurfaceStruct
06:37:13 <Jaak> oh, i'd really like to know how to fix this
06:37:51 <paczesiowa> can i skip those configure checks?
06:37:51 <Jaak> using bytestring quite often throws such garbage for into end of output for me
06:38:10 <Jaak> s/for into/into
06:38:18 <Zao> paczesiowa: You ought to fix them instead.
06:38:49 <paczesiowa> it's hard to fix when I don't know what is broken:>
06:39:16 <Zao> As allbery_b says, your terminal is misconfigured or broken.
06:39:37 <allbery_b> Zao:  no.  those sequences shoiuld not be being output at all
06:39:53 <allbery_b> something is assuming full-screen terminal operation that should not be
06:40:02 <Zao> Where does the value of TOP come from?
06:40:19 <olsner> here's the same problem: http://ircarchive.info/haskell/2007/4/16/23.html
06:40:21 <lambdabot> Title: haskell #define TOP "/usr/src/hs-plugins | ^[[?1034h" is odd.
06:40:55 <allbery_b> http://ircarchive.info/haskell/2007/4/16/23.html
06:40:56 <lambdabot> Title: haskell #define TOP "/usr/src/hs-plugins | ^[[?1034h" is odd.
06:40:58 <allbery_b> heh
06:41:18 <allbery_b> interesting ti runs ghc --interactive
06:41:27 <Zao> What if you run it all through something like   env TERM=dumb ./configure ...
06:41:32 <paczesiowa> using tty (alt+ctrl+F1) it successfully configured, in konsole (kde) it fails...
06:41:32 <allbery_b> I would workaround by running env TERM=dumb ghc ...
06:41:34 <allbery_b> heh
06:41:36 <Zao> Or some other less-featured terminal?
06:42:06 <Zao> Out of curiousity, what is $TERM set to in Konsole?
06:42:06 <benny99> guess it's the terminals fault then :-[! ?
06:42:14 <allbery_b> ah, konsole.  I was wondering why the odd escape (it's not one of the standard xterm escapes)
06:42:18 <allbery_b> not exactly
06:42:21 <paczesiowa> Zao: xterm
06:42:59 <allbery_b> the real problem is that ghci / ghc --interactive (and runhaskell and ghc -e, which are part of the same mechanism) should recognize when not running to terminal and suppress terminal escapes
06:43:09 <allbery_b> the workaround is to force TERM=dumb
06:44:03 <paczesiowa> dolio: darcs version looks like ghc-6.6, "member of package array-0.1.0.0, which is hidden" standard pre-6.8 errors
06:44:39 <psofa> anyone that could give me a hint on how to use $ to get around haskell's lazyness?
06:44:40 <dolio> Oh, wait.
06:44:43 <dolio> Which darcs did you pull from?
06:44:48 <dolio> unsw?
06:44:51 <mauke> psofa: huh?
06:45:00 <paczesiowa> dolio: http://www.cse.unsw.edu.au/~dons/code/hs-plugins
06:45:02 <allbery_b> psofa:  you mean $! ?
06:45:02 <lambdabot> Title: Index of /~dons/code/hs-plugins
06:45:10 <dolio> paczesiowa: Yeah, that one's old.
06:45:14 <dolio> @where plugins
06:45:14 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
06:45:19 <dolio> Hmm...
06:45:25 <allbery_b> that's the old archive.  http://code.haskell.org/hs-plugins/
06:45:30 <dolio> @where hs-plugins
06:45:30 <lambdabot> http://code.haskell.org/~dons/code/hs-plugins
06:45:40 <dolio> That's the new one.
06:45:42 <allbery_b> ah
06:45:44 <psofa> allbery_b, mauke  well im not sure i was given this as an "abstract" advice
06:45:46 <psofa> :)
06:46:34 <paczesiowa> allbery_b: yeah, 6 more patches, thanks!
06:47:05 <psofa> reading what $ does i cant see how i can use it that way
06:47:14 <paczesiowa> anyway, I still think it's a "little" too hard to use that package...
06:47:30 <Zao> Shouldn't lambdabot have @src for ($!), or is it in some other module?
06:47:39 <mauke> @src ($!)
06:47:39 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
06:47:41 <psofa> anyway what i want to do is call myfunc bleh s and make sure that s is fully calculated
06:47:44 <mauke> :(
06:47:54 <mauke> psofa: myfunc bleh $! s
06:48:01 <mauke> well, not fully
06:48:04 <mauke> just to WHNF
06:48:11 <psofa> whnf?
06:48:22 <mauke> the outermost layer or lambda
06:48:33 <paczesiowa> can I install libraries just for one user?
06:48:42 <Zao> "Weak Head Normal Form"
06:48:43 <allbery_b> --user option to cabal
06:48:48 <dolio>  @src is kind of spotty.
06:48:56 <allbery_b> that is, runhaskell Setup.hs configure --user
06:49:02 <allbery_b> (and same for install)
06:49:14 <psofa> okay ill pretend that i understood :) and go read what exactly does $! do
06:49:18 <olsner> apparently, the extra escape code is Interpret "meta" key, sets eighth bit. (enables the eightBitInput resource).
06:49:19 <paczesiowa> allbery_b: thanks
06:49:30 <mauke> f $! x = x `seq` f x  -- or something like that
06:50:20 <paczesiowa> allbery_b: runhaskell Setup.lhs install --user fails "Setup.lhs: /usr/local/share/doc/plugins-1.1: createDirectory: permission denied (Permission denied)"
06:50:39 <psofa> may i suppose that 'seq' has some monadic meaning like do?
06:50:54 <allbery_b> hm, right
06:51:05 <allbery_b> --user controls which database, you still need a --prefix with configure
06:51:12 <allbery_b> psofa: no
06:51:35 <allbery_b> seq is a compiler builtin.  it has nothing to do with monads
06:51:44 <paczesiowa> allbery_b: too complicated, I'll just su:P
06:52:03 <psofa> uhm anyone knows how is $! called? i cant search for  haskell+ $! :)
06:52:50 <mauke> psofa: no, seq has nothing to do with monads
06:54:34 <mauke> psofa: http://haskell.org/onlinereport/basic.html#sect6.2
06:54:36 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
06:55:13 <psofa> mauke, thanks a lot
07:04:59 <paczesiowa> Zao, allbery_b: thanks for help, I successfully run example program
07:05:55 <paczesiowa> could you file a bug about that TERM thing? ( I don't even know where is that bug coming from)
07:08:14 <myname> hi
07:08:31 <Zao> paczesiowa: ghci doesn't understand that it's called in a non-interactive way and tries to do helpful things.
07:09:00 <Zao> paczesiowa: By setting the terminal type to "dumb", it thinks that the user is on a terminal that doesn't understand much at all.
07:09:34 <allbery_b> I'm checking bug db to see if it's there, will file new bug if it's not
07:09:58 <allbery_b> ghc trac's being dodgy for me
07:10:03 <myname> \q
07:10:10 <paczesiowa> allbery_b: thanks
07:33:55 <skorpan> is there any smooth way of writing the equivalent of if x then [(x, y)] else []?
07:34:06 <skorpan> i mean in sort of reducing that [] out in a hackish manner
07:35:26 <hallongrottan> @pl if x then [(x,y)] else []
07:35:26 <lambdabot> if' x [(x, y)] []
07:35:33 <allbery_b> not useful
07:35:34 <skorpan> what the.
07:35:36 <hallongrottan> lol wtf
07:35:43 <skorpan> WHAT the.
07:35:47 <allbery_b> if' is @pl's way of saying that if can't be made poiintfree
07:35:50 <skorpan> is that valid haskell 98=
07:35:50 <skorpan> ?
07:35:55 <skorpan> oh
07:35:58 <hallongrottan> oh
07:36:00 <dolio> > let foo x y = guard x >> [(x,y)] in (foo True 1, foo False 2)
07:36:02 <lambdabot>  ([(True,1)],[])
07:36:03 <taruti> if' a b c = if a then b else c
07:36:10 <chessguy> if' p t f = if p then t else f
07:36:12 <chessguy> yeah
07:36:28 <skorpan> lol chessguy i'm actually writing chess in haskell atm
07:36:52 <dolio> > let foo x y = [(x,y) | x] in (foo True 1, foo False 2)
07:36:53 <lambdabot>  ([(True,1)],[])
07:36:54 <chessguy> skorpan, oh?
07:36:57 <skorpan> yep.
07:37:00 <benny99> hm... it's not possible to "unmonad" a function right?
07:37:03 <skorpan> what's your excuse?
07:37:09 <benny99> like "m a -> a"
07:37:10 <chessguy> have you written an engine in another language?
07:37:14 <EvilTerran> benny99, not in general. that's part of the point of monds.
07:37:19 <EvilTerran> (+a)
07:37:22 <skorpan> benny99: you could do unwrapping through pattern matching, sort of
07:37:23 <benny99> yeah
07:37:34 <skorpan> i think?
07:37:37 <benny99> hm, IO Bool -> Bool
07:37:42 <benny99> that's my current problem (
07:37:43 <benny99> :(
07:37:45 <EvilTerran> otherwise a function could do IO and not have an IO type
07:37:49 <liesen> no
07:37:50 <EvilTerran> which would break everything
07:37:52 <skorpan> no, i don't think that's possible
07:37:53 <benny99> yeah
07:38:15 <benny99> how can I test again IO Bool then ?
07:38:18 <EvilTerran> you can pull the value out with <- in a do block or >>= otherwise
07:38:24 <chessguy> skorpan, have you written an engine in another language?
07:38:32 <EvilTerran>  but you have to go back into IO with return or whatever
07:38:41 <xerox> ?type const True :: IO Bool -> Bool
07:38:42 <lambdabot> IO Bool -> Bool
07:38:51 <EvilTerran> benny99, do pred <- <IO Bool>; if pred then ... else ...
07:39:03 <benny99> ah :)
07:39:08 <skorpan> chessguy: i'm not sure i have written what you could call an engine
07:39:21 <EvilTerran> or <IO Bool> >>= \pred -> if pred ...
07:39:28 <skorpan> i have made an embedded language for board games and i am currently writing an example of usage in chess
07:39:30 <benny99> those <- are called arrows right? they are still magic to me :/
07:39:31 <chessguy> @\f -> p <- f; if p then t else f
07:39:32 <lambdabot>  fd:26: hClose: resource vanished (Broken pipe)
07:39:37 <skorpan> benny99: no, not really
07:39:39 <EvilTerran> or (\pred -> if pred ...) <$> <IO Bool>
07:39:40 <chessguy> @pl \f -> p <- f; if p then t else f
07:39:40 <EvilTerran> etcetc
07:39:41 <lambdabot> (line 1, column 13):
07:39:41 <lambdabot> unexpected ";"
07:39:41 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
07:39:43 <skorpan> arrows is kind of "-<"
07:39:46 <EvilTerran> no, they're not called arrows
07:39:54 <skorpan> arrows are a whole different concept
07:40:02 <skorpan> <- is just syntactic sugar
07:40:06 <EvilTerran> i refer to "<-" as "bind", even if it's not strictly accurate
07:40:07 <hallongrottan> for >>=
07:40:19 <benny99> ah, sorry :_[
07:40:20 <chessguy> skorpan, embedded in haskell?
07:40:24 <skorpan> chessguy: yes
07:40:30 <chessguy> skorpan, got a link?
07:40:31 <EvilTerran> @. pl undo \f -> p <- f; if p then t else f
07:40:31 <lambdabot> Parse error at "<-" (column 9)
07:40:37 <EvilTerran> @undo \f -> p <- f; if p then t else f
07:40:38 <lambdabot>  Parse error at "<-" (column 9)
07:40:38 <hallongrottan> benny99: do x <- foo; return x == foo >>= \x -> return x
07:40:41 <benny99> yeah, I've gone through monadstuff thanks to dons :)
07:40:45 <skorpan> chessguy: it's not public at all at the moment as it's my project for the advanced functional programming course
07:40:46 <EvilTerran> @. pl undo \f -> do p <- f; if p then t else f -- oops
07:40:46 <lambdabot> ap (>>=) (flip (flip if' t))
07:40:55 <allbery_b> heh
07:40:58 <skorpan> maybe i'll release it publicly when the course is over
07:41:10 <liesen> skorpan: first deadline tomorrow, right?
07:41:16 <skorpan> liesen: yes
07:41:17 <chessguy> skorpan, is the embedded language for the AI side or for representing the rules or what?
07:41:19 <benny99> thanks :) -- I guess I'm able to solve that now
07:41:44 <skorpan> chessguy: i have no AI whatsoever, so it's just for representing the board, the players, adding/removing/replacing/moving pieces etc.
07:41:53 <chessguy> oh, ok
07:41:55 <skorpan> the rules cannot be represented in my DSL
07:42:28 <skorpan> i think representation of rules in such a dynamic manner would be far beyond this course tbh
07:42:29 <chessguy> i'm more interested in the AI side of things
07:42:53 <skorpan> if i were to implement AI it would be simple minimax probably, which isn't at all that interesting
07:43:07 <chessguy> no, not really :)
07:43:22 <liesen> skorpan: how so? you could just begin by representing the rules for each piece and build from there
07:43:49 <skorpan> liesen: of course, but how would i possibly express the "en passant" rule?
07:44:25 <skorpan> my reasoning is that if i were to create something like that, it would just be *more* work for the user, as there are so many special cases
07:44:36 <liesen> surely
07:44:45 <skorpan> liesen: what's your project?
07:44:51 <liesen> web scraping
07:45:03 <skorpan> so how's it going?
07:45:04 <chessguy> oh, that's fun
07:45:24 <liesen> so i of course ran into all the usual problems with html/xml
07:45:38 <liesen> but i got it working quite well right now
07:45:41 <skorpan> did you look at xpath?
07:45:46 <liesen> yeah
07:46:05 <liesen> i automagically turn each page into a "document" in haxml
07:46:16 <liesen> you could run xtract queries on that, if you wanted to
07:46:32 <liesen> but the focus has been more on stuff that should be easy, like getting all forms
07:47:14 <liesen> .. clicking links, etc
07:47:47 <b_jonas> skorpan: with minimax, you still have to create a good way to calculate the score for a position, and some way to cut the search tree
07:47:50 <b_jonas> it's still not trivial
07:59:59 <benny99> http://hpaste.org/6573 <-- got anybody a clue why that does not work the way I want ?
08:00:45 <benny99> do locked <- (return True); if locked then putStrLn "yeah" else putStrLn "no" -- works
08:02:08 <mauke> 「locked <- (return SDL.lockSurface) screen」 seems to be equivalent to 「locked <- SDL.lockSurface」
08:02:43 <benny99> ?
08:03:03 <mauke> don't you mean 「locked <- SDL.lockSurface screen」?
08:03:15 <benny99> no
08:03:28 <mauke> why not?
08:03:30 <benny99> I meant (SDL.lockSurface screen)
08:03:36 <benny99> in a way
08:03:44 <mauke> what
08:03:53 <benny99> but SDL.lockSurface doesn't want IO Surface, but a Surface
08:04:12 <benny99> ((liftM . SDL.lockSurface) screen) -- ????
08:04:32 <mauke> do { screen <- SDL.getVideoSurface; locked <- SDL.lockSurface screen;
08:04:56 <benny99> mauke: nah, I can't do that
08:05:01 <mauke> why not?
08:05:07 <benny99> mauke: because lockSurface requires "IO Surface" and not "Surface"
08:05:14 <benny99> ah, wait
08:05:20 <benny99> :/ yeah, thanks
08:05:25 <benny99> but why does my approach not work ?
08:05:33 <mauke> because it doesn't make any sense
08:05:37 <benny99> why ?
08:05:41 <Saizan> or do locked <- lockSurface =<< screen
08:05:42 <benny99> jsorry
08:05:46 <mauke> no, why should it make sense?
08:05:51 <Saizan> ?type return
08:05:52 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
08:05:54 <mauke> nonsense is the default
08:06:27 <benny99> mauke: locked <- (return True) -- locked is a True then
08:06:31 <mauke> 「(return SDL.lockSurface) screen」 uses 「return ...」 as a function, so return = const here
08:06:34 <yitz> benny99: hi, r u benny k who set up the meeting at village green in jan. and is interested in sdl?
08:06:48 <Saizan> benny99: if lockSurface :: Surface -> IO Bool, return lockSurface :: Monad m => m (Surface -> IO Bool)
08:06:50 <benny99> yitz: I guess no :(
08:06:50 <mauke> const SDL.lockSurface screen == SDL.lockSurface
08:06:59 <yitz> benny99: ok. :)
08:07:44 <benny99> mauke: !?
08:08:00 <edwardk> @pl \f g -> runIdentity . xmap (return . f) (return . g)
08:08:00 <lambdabot> ((runIdentity .) .) . (. (return .)) . xmap . (return .)
08:08:03 <edwardk> ugh
08:08:15 <mauke> ‼
08:08:15 <Saizan> benny99: locked <- return True works becuase return True :: Monad m => m Bool
08:08:44 <mauke> 「x <- return y」 is better written as 「let x = y」
08:09:17 <benny99> Saizan: hm :/
08:09:28 <benny99> sorry, I don't get it I guess
08:09:53 <mauke> return = put value into m
08:09:57 <mauke> <- = get value out of m
08:09:59 <benny99> mauke: yeah
08:10:01 <mauke> they cancel each other
08:10:01 <benny99> yeah
08:10:07 <benny99> so why does my approach not work then :/ ?
08:10:15 <mauke> what approach?
08:10:23 <Saizan> benny99: well return wraps its argument in the monad, so if the argument is a function you can't apply it normally anymore
08:10:27 <benny99> http://hpaste.org/6573
08:10:40 <mauke> because you used the result of return x as a function
08:10:48 <mauke> thereby forcing m = ((->) e)
08:10:55 <mauke> @src (->) return
08:10:55 <lambdabot> return = const
08:10:59 <benny99> :/
08:11:03 <mauke> and in that monad, return is const
08:11:14 <Saizan> also, screen is still IO Surface, while you need Surface
08:11:34 <benny99> mauke: sorry, I can't understand you :(, thanks for trying anyway
08:11:36 <mauke> if you use return to wrap things in IO, you can't use them as functions
08:11:43 <nibro> @where paste
08:11:43 <lambdabot> http://hpaste.org/new
08:11:44 <benny99> mauke: but liftM should work ?
08:11:53 <Saizan> ?type liftM
08:11:53 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:12:03 <mauke> benny99: unlikely
08:12:06 <mauke> liftM == fmap
08:12:07 <benny99> hm :(
08:12:11 <mauke> you want >>=
08:12:32 <mauke> locked <- SDL.getVideoSurface >>= SDL.lockSurface
08:12:34 * smg says hello to all
08:12:34 <benny99> :t >>=
08:12:35 <lambdabot> parse error on input `>>='
08:12:44 <smg> :t (>>=)
08:12:45 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:12:52 <benny99> thanks
08:12:54 <smg> btw. pure lambda calculus is Interesting
08:13:25 <benny99> mauke: hm, but that code is hard to read isn't it ?
08:13:42 <smg> np
08:13:46 <mauke> depends
08:13:56 <smg> "turing fixpoint combinator" :)
08:14:03 <benny99> mauke: locked <- SDL.getVideoSurface just looks weird to me
08:14:04 <mauke> but since you need screen later again, I'd extract it up front
08:14:24 <mauke> benny99: that's because it's wrong
08:15:04 <benny99> mauke: ah :p
08:15:08 <smg> > let fix = (\x \y -> y (x x y)) (\x \y -> y (x x y)) -- the turing fixpoint converter
08:15:09 <lambdabot>  Parse error at "\y" (column 15)
08:15:29 <mauke> SDL.getVideoSurface >>= SDL.lockSurface is what's on the RHS of <-
08:15:42 <benny99> ah, ah, sorry
08:15:50 <benny99> miss-parsed that statement :)
08:16:04 <benny99> eh, expression, whatever
08:16:07 <mauke> >>= is a normal function/operator
08:16:11 <mauke> <- is special syntax
08:16:36 <benny99> yeah
08:16:46 <resiak> smg: \x y -> or \x -> \y ->
08:17:04 <benny99> I read it as "locked <- SDL.getVideoSurface; locked >>= SDL.lockedSurface
08:17:11 <benny99> but I got it now
08:17:27 <smg> resiak: i know :)
08:17:30 <benny99> thanks, I'll try to figure that out :)
08:17:33 <resiak> smg: :)
08:17:38 <benny99> I'm away for 30min now though
08:17:41 <smg> resiak: but this let declaration won't work then still :)
08:17:47 <resiak> smg: point :)
08:17:56 <benny99> mauke: thanks for your *very* patient support ;)
08:18:50 <mauke> oh well, back to hacking regexes in syntax/perl.vim
08:21:49 <smg> mauke++
08:24:58 <smg> someone knows of an interpreter for pure lambda calculus? i won't find one :)
08:25:21 <Lycurgus> *can't
08:25:54 <xerox> ?lambda
08:25:54 <lambdabot> Done.
08:26:07 <xerox> (But it seems broken for anything nontrivial at the moment.)
08:26:15 <nibro> > let fix = (\x y -> y (x x y)) (\x y -> y (x x y))
08:26:15 <lambdabot>  Parse error at end of input
08:26:15 <olsner> ?help lambda
08:26:16 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:26:23 <mauke> @lambda \x.x
08:26:23 <lambdabot>  fd:26: hClose: resource vanished (Broken pipe)
08:26:52 <smg> http://en.wikipedia.org/wiki/Fixed_point_combinator
08:26:53 <lambdabot> Title: Fixed point combinator - Wikipedia, the free encyclopedia
08:27:15 <jekor`> Has anyone used HaskellDB? Any comments on its suitability for a large project?
08:27:20 <nibro> > (\x y -> y (x x y)) (\x y -> y (x x y))
08:27:21 <lambdabot>      Occurs check: cannot construct the infinite type: t = t -> t1 -> t2
08:27:21 <lambdabot>     ...
08:32:53 <dolio> @djinn ((a -> k) -> i) -> (((a -> k) -> j) -> j) -> i
08:32:53 <lambdabot> -- f cannot be realized.
08:33:23 <dolio> @djinn ((a -> i) -> k) -> (((a -> i) -> j) -> k) -> j
08:33:23 <lambdabot> -- f cannot be realized.
08:34:25 <smg> http://en.wikipedia.org/wiki/Unlambda <--- haha
08:34:30 <smg> Unlambda.. :)
08:34:51 <dolio> @djinn ((a -> i) -> k) -> (((a -> j) -> k) -> i) -> j
08:34:51 <lambdabot> -- f cannot be realized.
08:41:12 <edwardk> i'm being a moron, i need a function of the form: Monad m => (a -> m b) -> m a -> m b and I'm drawing a blank, I know its easy
08:41:24 <edwardk> hahah
08:41:27 <edwardk> nevermind =)
08:41:34 <Twey> Umm
08:41:36 <Twey> Heh
08:41:38 <edwardk> =<<
08:41:40 <edwardk> =)
08:41:50 <Twey> Heh
08:42:21 <edwardk> woohoo it worked
08:42:52 <Heffalump> or "flip (>>=)" :-)
08:43:29 <edwardk> my brain just for some reason was not thinking right about the problem
08:44:23 <Heffalump> http://hsenag.livejournal.com/11803.html
08:44:23 <lambdabot> Title: hsenag: Restricted monads in Haskell
08:44:48 <Heffalump> (hsenag is me)
08:45:29 <benny99> smg: do you know Project LambdaCan :) ?
08:45:40 <edwardk> @pl \f -> cata (f . bidist)
08:45:40 <lambdabot> cata . (. bidist)
08:45:59 <benny99> smg: http://alum.wpi.edu/~tfraser/Software/Arduino/lambdacan.html --
08:45:59 <lambdabot> Title: Project LambdaCan---Lambda Calculus in a Can
08:46:03 <edwardk> cata . (.bidist) . (=<<) isn't exactly the clearest function i've ever written . ugh
08:46:16 <edwardk> @unpl cata . (.bidist) . (=<<)
08:46:16 <lambdabot> (\ d -> cata (\ m -> (bidist m) >>= d))
08:46:32 <smg> benny99: no i will look
08:47:06 <smg> Here is 11 + 12 = 23, a computation that uses nearly all of the LambdaCan's available memory <-- lol
08:47:27 <benny99> :D
08:47:48 <benny99> yeah, but I like the idea :p
08:48:44 <benny99> mauke: locked <- SDL.getVideoSurface >>= SDL.lockSurface -- does not work btw., because lockSurface expects a Surface -- if I bother too much, tell me :-[
08:49:53 <mauke> doesn't getVideoSurface return one?
08:50:25 <benny99> mauke: no, IO Surface
08:51:38 <dolio> ls
08:51:40 <allbery_b> but >>= "unwraps" IO
08:51:42 <dolio> Oops
08:51:57 <benny99> dolio: ;)
08:52:11 <dolio> Heffalump: Interesting.
08:52:18 <benny99> allbery_b: ?
08:53:17 <allbery_b> that is, if SDL.getSurface returns an IO Surface, then (SDL.getSurface >>=) gives you a Surface and requires a function from Surface to IO a (for some a that can't be known yet)
08:53:41 <benny99> allbery_b: but it doesn't
08:54:32 <benny99> allbery_b: wait, sorry
08:55:39 <benny99> allbery_b: SDL.getVideoSurface returns IO Surface -- and SDL.lockedSurface is Surface -> IO Bool
08:56:22 <allbery_b> ok, so the expression (SDL.getVideoSurface >>= SDL.lockSurface) should produce an IO Bool
08:56:28 <benny99> yeah
08:56:48 <benny99> gnah, sorry ...
08:56:52 <allbery_b> perhaps you should paste your code and the actual error
08:56:53 <benny99> I was in the wrong line ...
08:56:53 <allbery_b> @paste
08:56:54 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:57:13 <benny99> error message referred to L31, I was in 30...
08:57:55 <allbery_b> looking at the error expression instead of the actual line, I take it :)
08:57:59 * benny99 feels stupid
08:58:25 <allbery_b> ("locked <- SDL.getSurface >>= SDL.lockSurface" is an incomplete expression)
08:59:52 <allbery_b> it really means "SDL.getSurface >>= SDL.lockSurface >>= \locked ->" --- need something to finish it out, so the current expresson in an error message for the next line will start with the first line
09:03:12 <joricj> how can i close a Chan so that sending to it will cause an error. i can't find a function to do it so im tempted to pass (Mutex,Chan) around, is there a better solution?
09:03:36 <Saizan> joricj: that operation is not supported
09:03:43 <benny99> :/
09:03:46 <joricj> hm
09:04:05 <benny99> I got no idea, guess you are right
09:04:19 <joricj> okay so ill go with the mutex thing, it will work i guess ... just needs some wrapper code
09:04:38 <Saizan> joricj: you can write your own Chan module if you want
09:04:49 <joricj> eh
09:05:36 <joricj> it's my first program, i'm trying to stay away from digging into library code as much as possible :D
09:06:05 <Saizan> joricj: ah, that sounds reasonable :) however this is how i've done it http://hackage.haskell.org/packages/archive/hspread/0.3/doc/html/Control-Concurrent-Chan-Closeable.html
09:06:06 <lambdabot> http://tinyurl.com/2oktgk
09:06:31 <Saizan> it also separates the write end W from the read one R
09:06:58 <joricj> wow
09:07:02 <joricj> that sounds like what i need
09:08:50 <joricj> is it in apt-get ?
09:09:27 <Cale> It's in Hackage.
09:09:33 <Saizan> no, not in apt-get
09:10:41 <Cale> Saizan: that would almost be worth making into its own package :)
09:11:26 <Saizan> Cale: yeah, i was thinking that, but a one-module package? i could add some other variations
09:11:51 <benny99> (ah I guess I guess I'm going to understand...)
09:12:28 <Cale> There's nothing wrong with having a one module package :)
09:12:30 <Cale> benny99: ?
09:12:53 <Cale> :t unless
09:12:58 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
09:13:12 <skorpan> @pl dropWhile (/=current) (cycle (map (name) $ players game)) !! 1
09:13:12 <lambdabot> dropWhile (current /=) (cycle (map name (players game))) !! 1
09:13:13 <Cale> unless just takes a Bool
09:13:20 <benny99> Cale: that wasn't the problem :p
09:13:35 <skorpan> awesome
09:13:40 <Cale> benny99: On the previous line, you have  locked <- (return SDL.lockSurface) screen
09:13:46 <Cale> which looks pretty suspicious
09:14:26 <joricj> Saizan: if your library is BSD licensed, does that mean i can't release my code into the public domain if i depend on it?
09:14:31 <benny99> Cale: it's corrected already, I guess I remember/know how it works now :)
09:14:33 <skorpan> @pl inRange (0, mx) x && inRange (0, my) y
09:14:33 <lambdabot> inRange (0, mx) x && inRange (0, my) y
09:15:00 <Cale> okay
09:15:50 <benny99> Cale: thanks for your attention anyway :)
09:17:07 <Saizan> joricj: you can, the limitations apply to what you do to the library, or binaries built with it
09:18:30 <joricj> the binaries built with it?
09:18:42 <joricj> what does BSD say about them?
09:19:46 <benny99> (of course it doesn't work -- but it compiles ;) )
09:19:52 <Saizan> joricj: well, only redistribution of the library in binary form must reproduce the LICENSE file
09:20:02 <Saizan> s/only/only that/
09:20:15 <Saizan> joricj: it's a very liberal license :)
09:20:18 <joricj> hmm, ok
09:22:44 <yitz> @type (&&) `on` (uncurry $ inRange . (,) 0)
09:22:45 <lambdabot> forall a. (Num a, Ix a) => (a, a) -> (a, a) -> Bool
09:23:13 <Saizan> joricj: however it might be easier to just copy that single module in this case, since you don't need the rest of the library
09:24:08 <yitz> @pl \ mx my x y -> (&&) `on` (uncurry $ inRange . (,) 0) (mx, x) (yx, y)
09:24:08 <lambdabot> const . ((((&&) `on`) .) .) . flip flip ((,) yx) . (((.) . uncurry (inRange . (,) 0)) .) . (,)
09:25:29 <yitz> skorpan: ^
09:33:11 <skorpan> thanks yitz
09:33:12 <skorpan> :)
09:33:48 <EvilTerran> ?docs
09:33:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
09:39:42 <benny99> (works, yipiee)
09:41:37 * benny99 is away
09:41:43 <yitz> benny99: :)
09:43:02 <benny99> http://hpaste.org/6574 <-- just if anybody wants to see a minimal hsdl example
09:43:21 <hallongrottan> @pl fst x
09:43:21 <lambdabot> fst x
09:43:24 <hallongrottan> damn
09:43:28 <skorpan> @unpl fst x
09:43:28 <lambdabot> fst x
09:43:30 <skorpan> hmm
09:43:55 <hallongrottan> ok skorpan
09:44:02 <Lemmih> benny99: Are you sure you want 'trySetVideoMode'?
09:44:26 <hallongrottan> @pl map fst xs
09:44:26 <lambdabot> map fst xs
09:44:29 <hallongrottan> gah
09:44:37 <benny99> Lemmih: at the moment it doesn't really matter I guess
09:44:40 <Lemmih> benny99: You don't validate the result so wouldn't it be better to get an exception?
09:45:20 <skorpan> @pl concatMap (\x -> [(fst x)] ++ [(snd x)] ) ls
09:45:20 <lambdabot> ap ((++) . return . fst) (return . snd) =<< ls
09:45:22 <benny99> yeah
09:45:38 <skorpan> friggin hardcore
09:45:47 <hallongrottan> lol wtf
09:47:04 <skorpan> @pl concatMap (\x -> head (tail (snd x)) : (tail (fst x))) ls
09:47:05 <lambdabot> ap ((:) . head . tail . snd) (tail . fst) =<< ls
09:47:13 <skorpan> @pl concatMap (\x -> head (tail (snd x)) : (tail (fst x))) ls !! 4
09:47:14 <lambdabot> (ap ((:) . head . tail . snd) (tail . fst) =<< ls) !! 4
09:47:16 <skorpan> :/
09:47:48 <benny99> Lemmih: it doesn't really matter at the moment, I just wanted to get "something working" -- but thanks for your recommendation :)
09:48:05 <hallongrottan> @pl maximum $ map (\x -> maximum [lcm x n | n <- ns']) ns'
09:48:06 <lambdabot> maximum (map (maximum . return . (<- ns') . (| n) . flip lcm n) ns')
09:48:48 * benny99 is really away now
09:49:52 <hallongrottan> heh
09:52:20 <hallongrottan> @pl take (num - p0) $ repeat "0000"
09:52:20 <lambdabot> take (num - p0) (repeat "0000")
09:54:00 <chessguy> @pl \p0 -> take (num - p0) $ repeat "0000"
09:54:00 <lambdabot> ($ repeat "0000") . take . (-) num
09:54:21 <chessguy> @pl \p0 str -> take (num - p0) $ repeat str
09:54:21 <lambdabot> (. repeat) . take . (-) num
09:54:40 <hallongrottan> i see
09:54:59 <chessguy> @pl \str p0 -> take (num - p0) $ repeat str
09:54:59 <lambdabot> flip (take . (-) num) . repeat
09:58:06 <yitz> @pl \str p0 -> take (subtract p0 num) $ repeat str
09:58:06 <lambdabot> flip (take . (-) num) . repeat
10:23:40 <matthew_-> @seen Heffalump
10:23:40 <lambdabot> Heffalump is in #haskell-soc, #haskell and #darcs. I last heard Heffalump speak 32m 35s ago.
10:23:58 <matthew_-> ok, has anyone had any luck with symmetric type synonynm families?
10:24:24 <matthew_-> i.e. instance Foo x = y and instance Foo y = x and then (Foo (Foo a)) = a ?
10:43:44 <joricj> @src filter
10:43:44 <lambdabot> filter _ []     = []
10:43:44 <lambdabot> filter p (x:xs)
10:43:44 <lambdabot>     | p x       = x : filter p xs
10:43:44 <lambdabot>     | otherwise = filter p xs
10:43:56 <joricj> @hoogle filter
10:43:59 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
10:43:59 <lambdabot> Data.List.filter :: (a -> Bool) -> [a] -> [a]
10:43:59 <lambdabot> Data.ByteString.filter :: (Word8 -> Bool) -> ByteString -> ByteString
10:55:26 <solrize_> @tell benny99 i just woke up
10:55:26 <lambdabot> Consider it noted.
10:56:11 <solrize_> lambdabot, now THAT's a killer app.
10:57:25 <olsner> unfortunately, it's wholly irrelevant outside of #haskell
10:57:34 <solrize_> joke
10:58:10 <olsner> besides, every other language channel has its own bot written in that language (even #c!)
10:58:48 <dolio> Like math bot, written in math?
10:59:29 <olsner> for some appropriate subset of "every channel" :P
11:00:04 <solrize_> #php
11:00:07 <solrize_> hmm
11:01:09 <sclv_> I thought c, or maybe #c++ used a bot partially written in haskell?
11:01:19 <monochrom> woah! :)
11:02:06 <sclv_> http://www.xs4all.nl/~weegen/eelis/geordi/
11:03:38 <monochrom> Haha I see. That rocks. :)
11:04:38 <dolio> Does #perl6 have a perl6 bot? Or do they just use lambdabot?
11:04:49 <sclv_> @listchans
11:04:49 <lambdabot> ##logic #darcs #friendly-coders #gentoo-haskell #gentoo-uy #ghc #haskell #haskell-blah #haskell-overflow #haskell-soc #jhc #jtiger #parrot #perl6 #rosettacode #scala #scannedinavian #unicycling #
11:04:49 <lambdabot> xmonad
11:05:10 <solrize_> perl6 doesn't need a bot written in haskell, their LANGUAGE is written in haskell ;)
11:05:48 <dolio> :)
11:06:08 <wolverian> one implementation is, anyway :)
11:06:23 <solrize_> do they have any other ones working at the moment?
11:06:26 <dolio> Is there an implementation besides pugs?
11:06:49 <wolverian> rakudo (on parrot), smop, kp6 come to mind first
11:06:54 * dolio clearly follows perl 6 closely.
11:07:01 <wolverian> smop is C, kp6 is perl5
11:07:31 <wolverian> pugs is still the most complete one, but it's stalled, whereas rakudo is improving rapidly
11:15:00 <hallongrottan> @pl notes s pos size ++ toNotes ss size (pos+1)
11:15:00 <lambdabot> notes s pos size ++ toNotes ss size (pos + 1)
11:15:08 <hallongrottan> asch
11:16:12 <xerox> There are no lambdas.
11:16:57 <cjb> xerox: hihi
11:18:41 <EvilTerran> hallongrottan, ?pl only works if you make what's a parameter explicit
11:18:53 <hallongrottan> aha, good to know
11:19:31 <EvilTerran> ?pl \(s:ss) pos size -> notes s pos size ++ toNotes ss size (pos+1)
11:19:32 <lambdabot> ap ((. ((. (1 +)) . flip . toNotes)) . ap . (liftM2 (++) .) . notes . head) tail
11:19:39 <EvilTerran> DO NOT WANT
11:32:49 <dozer> ?pl \i -> mplus (return i)
11:32:49 <lambdabot> mplus . return
11:33:07 <dozer> dho!
11:33:52 <dozer> @t foldr (mplus . return) mzero
11:33:53 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:34:01 <dozer> ?t foldr (mplus . return) mzero
11:34:01 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:34:10 <dozer> :t foldr (mplus . return) mzero
11:34:12 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m a
11:34:32 <smg> @type const
11:34:33 <lambdabot> forall a b. a -> b -> a
11:34:54 <smg> @info const
11:34:54 <lambdabot> const
11:35:56 <dozer> happy easter by the way
11:37:00 <dozer> I seem to be defining the same operation over and over again for monad transformers
11:37:09 <dozer> sort of a dual to lift - I'm calling it hoist
11:37:33 <dozer> converts MonadFoo -> MonadFooT
11:37:48 <dozer> or rather: MonadFoo a -> MonadFooT m a
11:41:13 <EvilTerran> dozer, i think msum = foldr (mplus . return) mzero
11:41:27 <EvilTerran> er, no, that's msum . map return.
11:44:18 <piojo> ?pl \x f->f x
11:44:18 <lambdabot> flip id
11:44:28 <piojo> how does that work?
11:44:49 <piojo> i mean, I know it's right, but how is "flip id" the same as "\x f->f x"?
11:44:54 <piojo> anybody get that?
11:45:07 <elliottt> well
11:45:14 <elliottt> if the type of id is a -> a
11:45:21 <dozer> EvilTerran: ok
11:45:32 <elliottt> when you flip it, you're assuming that you've got more than one argument
11:45:38 <elliottt> ?t flip id
11:45:38 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
11:45:45 <piojo> elliottt: i'm surprised that works, actually
11:46:00 <elliottt> :t flip id
11:46:01 <lambdabot> forall b c. b -> (b -> c) -> c
11:46:05 <EvilTerran> ?src flip
11:46:06 <lambdabot> flip f x y = f y x
11:46:08 <EvilTerran> ?src id
11:46:08 <lambdabot> id x = x
11:46:14 <Jedai> piojo: a can be unified with any type (b -> c) included
11:46:16 <dozer> EvilTerran: I've ended up writing functions that 'hoist' values from MonadFoo -> MonadFooT quite a lot
11:46:23 <piojo> Jedai: ahh
11:46:29 <dozer> I smell a generally useful class here, that provides operators binding the transformer with the base monad
11:46:36 <EvilTerran> so ((flip id) x) y = (id y) x = y x
11:46:45 <elliottt> piojo: a more interesting one is: flip fix :)
11:46:53 <elliottt> :t flip fix
11:46:53 <piojo> :t fix
11:46:54 <lambdabot> forall b c. b -> ((b -> c) -> b -> c) -> c
11:46:54 <lambdabot> forall a. (a -> a) -> a
11:47:09 <piojo> :t fix
11:47:09 <lambdabot> forall a. (a -> a) -> a
11:47:13 <piojo> okay
11:47:14 <olsner> :t fix flip
11:47:15 <lambdabot> forall b c. b -> b -> c
11:47:51 <olsner> hmm, since that's an "impossible" type, I assume fix flip doesn't terminate?
11:47:52 <piojo> and these actually turn out to be useful?
11:48:46 <piojo> it's okay if they're just fun curiosities ;)
11:48:51 <elliottt> it will, it depends on the arguments
11:49:06 <skorpan> can you put x@(y, z) anywhere in the code or only in pattern matching?
11:49:43 <elliottt> glguy had a use for fix flip recently
11:49:48 <elliottt> can't remember exactly what it was :)
11:50:08 <Zao> http://thread.gmane.org/gmane.comp.lang.haskell.libraries/6363
11:50:11 <lambdabot> Title: Gmane Loom
11:50:16 <Zao> Did this ever go into the main Network package?
11:52:59 <monochrom> x@(y,z) only in pattern matching.
11:53:23 <skorpan> okay
11:57:02 <elliottt> olsner: you're right, fix flip doesn't.  for some reason i read it as flip fix.
12:04:16 <Eelis> elliottt: you've got mail :)
12:05:24 <benny99> hm, does anybody use haskell-mode in emacs ?
12:05:24 <lambdabot> benny99: You have 1 new message. '/msg lambdabot @messages' to read it.
12:05:41 <dolio> I do.
12:05:43 <shapr> yow!
12:06:21 <dolio> @yow!
12:06:21 <lambdabot> The SAME WAVE keeps coming in and COLLAPSING like a rayon MUU-MUU ...
12:09:09 <roconnor> @keal
12:09:09 <lambdabot> T seems to be haskell, except with a decent interface at this point
12:09:22 <kuribas> benny99: Did you try my new mode?
12:09:45 <solrize_> yeah i use haskell mode, i have an old version i think
12:09:49 <benny99> kuribas: nope :( ?
12:10:05 <kuribas> http://kuribas.hcoop.net/haskell-indentation.el
12:10:14 <elliottt> Eelis: thanks :)
12:10:54 <kuribas> benny99: Actually, it's only a new indentation engine, if that's what you need.
12:10:55 <benny99> if I got a module Video in the same folder I got a module Main, can't I import the Video module by inserting "import Video" ?
12:11:09 <dolio> kuribas: Does it indent if-then-else correctly?
12:11:13 <benny99> kuribas: nope, I wonder how I could import multiple modules in ghci
12:11:24 <benny99> dolio: haskell-mode does here
12:11:38 <kuribas> dolio: If you mean with regard to the layout-rule, then yes.
12:11:45 <dolio> benny99: It indents 'then' and 'else' more than 'if'?
12:12:23 <benny99> dolio: no :( ?
12:12:50 * dolio gets excited.
12:13:04 <elliottt> Eelis: I've got the irc stuff up at a repo on code.haskell.org now, but i've not requested a project space for it.
12:13:09 <benny99> hm, but it compiled my progs
12:13:13 <Eelis> elliottt: i see
12:13:14 <elliottt> http://code.haskell.org/~elliottt/repos/irc
12:13:34 <elliottt> whoops, http://code.haskell.org/~elliottt/code/irc/
12:13:34 <lambdabot> Title: Index of /~elliottt/code/irc
12:14:36 <Eelis> elliottt: alright. i can re-send the patch as a proper darcs patch if you like (and if you think the patch is good to begin with)
12:14:45 <kuribas> benny99: Have you tried ":m +Video"?
12:15:15 <benny99> kuribas: well, I actually just tried "C-c C-l" so far ;)
12:15:25 <skorpan> there should be an emacs haskell-mode function which sorts functions..
12:15:35 <elliottt> I've just applied the patch here, i'll run the tests and see what happens :)
12:15:55 <Eelis> elliottt: as i wrote in the mail, at least one test will fail
12:16:49 <benny99> ghc main.hs video.hs  -o test -- does also not work
12:17:13 <mofmog> oh man, monad transformers are hurting my head
12:17:16 <mofmog> but they shouldn't
12:18:29 <elliottt> Eelis: yeah, it did
12:18:44 <elliottt> Eelis: what about the case where someone has a parameter set that looks like: ["a",":b","c"]
12:18:44 <mofmog> so far, my understanding is that a transformer builds a layer on top of another monad
12:18:58 <Eelis> elliottt: that is not a valid set of parameters according to the IRC RFC
12:19:07 <elliottt> ok.
12:19:13 <benny99> (:/ ok... right... cAsE-sEnSiTiVe...)
12:19:29 <mperillo> hi all
12:19:43 <mperillo> a curiosity: how it is implemented something like this:  3 % 3 == 1.0 ?
12:20:17 <Eelis> elliottt: by "valid" i mean "representable"
12:20:29 <skorpan> mperillo: you might refer to 3 `mod` 3 == mod 3 3 == 1
12:20:30 <mperillo> where 3 % 3 is a rational number
12:20:44 <mofmog> so if i have StateT and IO, it'd look like StateT was surrounding IO? So I use it as any other monad, but when i want to work with IO, i have to use lift
12:20:53 <kuribas> mofmog: Have you read this? http://sigfpe.blogspot.com/2006/05/grok-haskell-monad-transformers.html
12:20:54 <lambdabot> Title: A Neighborhood of Infinity: Grok Haskell Monad Transformers, http://tinyurl.com/y6w3jr
12:21:00 <elliottt> Eelis: so my expectation with that code would be that it would be formatted as: "a :b c"
12:21:10 <mofmog> kuribas: yes
12:21:15 <elliottt> but that breaks the encode.decode property
12:21:22 <mofmog> i tried the examples and now i'm messing around with it
12:21:26 <elliottt> as it would then decode as ["a",":b c"]
12:21:34 <allbery_b> mofmog:  but StateT also has a MonadIO instance so some IO operations can be done directly
12:21:37 <elliottt> so i think that your patch makes more sense than what i had before
12:21:44 <mperillo> skorpan, what I mean is if there is some sort of type coercion
12:21:56 <Eelis> elliottt: the result of encode is only meaningful for messages that are representable. similarly, the decode.encode property needs only hold for representable messages
12:22:15 <elliottt> yep
12:22:20 <mperillo> or simply there is a definition of the == operator for operand of type Ratio and Num
12:22:33 <elliottt> i've just pushed your patch
12:22:45 <Eelis> elliottt: great, thanks :)
12:22:49 <benny99> Lemmih: ups, you are actually the author of hsdl hm :) ?
12:23:34 <Lemmih> That I am.
12:23:44 <benny99> Lemmih: thanks.
12:25:22 <Eelis> elliottt: the  showp [] = []  case is not needed because showp is never applied to an empty list. of course, it doesn't hurt either :)
12:26:08 <elliottt> Eelis: i added it in to remove the warning :)
12:26:16 <Eelis> elliottt: ah, fair enough :)
12:26:27 <elliottt> Eelis: just pushed a new version of the library.  thanks for the patch! :)
12:26:37 <Eelis> elliottt: you're welcome, and thanks again
12:26:56 <elliottt> Eelis: sorry i've been out of touch these last few months, school was harder than usual this term
12:27:05 <Eelis> elliottt: life happens :)
12:27:08 <elliottt> :)
12:27:22 <TomMD> @type let y c= toEnum (fromEnum c - 11) in (\x -> x : y x : succ x : succ (y x) : toEnum (fromEnum x - 8) : y x : ['s'])
12:27:23 <lambdabot> Char -> [Char]
12:28:03 <mofmog> ok this works now
12:28:04 <mofmog> woo
12:33:38 <dolio> kuribas: Is there a way to get it to indent if-then-else that way even outside a do?
12:34:37 <mofmog> hmm. Can you define modify as "modify fn = do { a <- get; put (fn a); }"
12:34:56 <mofmog> that seems to me like what modify does in any case
12:36:57 <kuribas> dolio: Not with the current code.
12:37:37 <unenough> how much category theory do I need to know to get to monads?
12:37:44 <mofmog> none
12:37:47 <hallongrottan> none
12:38:01 * benny99 agrees silently
12:38:02 <unenough> I'd like to understand the rootings of the concept
12:38:08 <mofmog> oh
12:38:14 <mofmog> that's different
12:38:28 <peter> hmmm; interesting; do I need some category theory to get into arrows ?
12:38:46 <Deewiant> nope
12:38:47 <mofmog> i think I "get" arrows, I just dont know what makes them special
12:38:55 <Deewiant> unless, again, you want to deeply understand them
12:38:56 <mofmog> but that means i dont get them
12:39:07 <mofmog> so far they just seem like a fancy word for function?
12:39:07 <peter> ok; thanks :)
12:39:56 <kuribas> dolio: if-then-else is indented the same as let-in and case-of.
12:40:51 <unenough> so what do you say then?
12:41:09 <dolio> kuribas: Ah.
12:42:08 <mofmog> hmm, i think i can make an interpreter for a toy assembly language now
12:49:01 <dolio> kuribas: Oh, interesting, it uses tab/backspace instead of cycling.
12:49:43 <kuribas> yes
12:50:28 <dolio> I think I like that better.
12:50:46 <kuribas> I do :-)
12:51:09 <kuribas> Cycling was driving me crazy, and it never seemed to do what I wanted...
12:51:11 <dolio> Especially since in, say, 'do a <- m ; ...' it aligns with 'a' straight away.
12:51:25 <dolio> Where cycling aligns with 'm' first, I think.
12:51:31 <dolio> Which is almost never right.
12:52:38 <allbery_b> yeh, that's one of the annoyances I always trip over.  that, and indentation of it-then-else *inside* a do block
12:52:51 <allbery_b> (the then and else must be indented, but aren't)
12:53:15 <dolio> Yeah, his gets that right, too.
12:54:19 <dolio> Although, myself, I like indenting then and else more all the time.
12:55:04 <dolio> And I usually align 'in' with the 'et' of the corresponding 'let'.
12:55:43 <kuribas> It would be possible to implement that.
12:56:02 <dolio> Which saves you from errors with that in a do block, as well (although that's less crucial, since you can just use the do version of let).
12:56:46 <kuribas> I prefer to have as little indentation as possible, to avoid having the code all over the place.
12:59:46 <kuribas> dolio: if-then-else, let, case and lambda are all implemented the same, would you indent them similarly?
13:01:03 <dolio> I'm not totally sure.
13:01:14 <dolio> then and else I indent by two spaces beyond the if.
13:01:25 <dolio> in I align with et in let.
13:01:54 <dolio> case I rarely use, but I tend to align the pattern matches with the 'x' in 'case x of'
13:02:56 <kuribas> Otherwise I have to use a variable for each individual keyword.
13:03:02 <kuribas> (perhaps using a alist).
13:04:10 <dolio> I don't really know about lambdas, either. I probably just wing those depending on the situation.
13:04:49 <piojo> does anybody know why a build (of wxhaskell) might fail to compile when run in some sort of special environment? (fakeroot, at least)
13:05:19 <kuribas> dolio: Everything after 'case x of' or 'let x = 1 in' or '\x ->' goes to the far left.
13:05:29 <piojo> when compiling by hand vs. compiling in my package system (on arch linux), the compilation seems to compile files in different orders, and the hand-compilation works, and the automated one fails
13:06:21 <luqui> wxhaskell is very finicky in my experience
13:06:29 <luqui> not sure why
13:06:41 <piojo> wouldn't cabal probably be the problem, here?
13:06:58 <piojo> i think this just has to do with the build environment
13:07:10 <luqui> wxhaskell has a nonstandard build procedure, so it could be cabal's fault
13:07:46 <piojo> oh... if the procedure is nonstandard, then it's more likely to be wxhaskell's fault...
13:08:04 <piojo> i'll try to contact the maintainers, i guess
13:08:25 <piojo> (i really don't know much about wxhaskell or cabal)
13:09:50 <dolio> kuribas: Those schemes I listed all sound different to me, but I don't want to dump work on you just on my account.
13:10:27 <dolio> Incidentally, how does "left offset" affect do? I can only figure out what it does to where.
13:11:36 <kuribas> Do you mean haskell-indentation-left-offset?
13:11:44 <dolio> Right.
13:12:47 <kuribas> It's the extra indentation to add after do or where or let...
13:13:31 <benny99> @type proc
13:13:32 <lambdabot> Not in scope: `proc'
13:13:44 <benny99> @type Control.Arrow.proc
13:13:44 <lambdabot> Not in scope: `Control.Arrow.proc'
13:13:53 <allbery_b> proc is syntax
13:13:54 <benny99> :( does anybody know where proc is defined ?
13:14:18 <allbery_b> built in to the compiler, only available with -farrows or -XArrows
13:14:20 <dolio> It's part of arrow syntax.
13:14:44 <benny99> let addOne a = proc a -> returnA -< (a + 1) -- is that non-ghc-6.6.1. compatible ?
13:15:07 <allbery_b> did you pass one of the options I named?
13:15:13 <benny99> yeah
13:15:25 <allbery_b> arrows are not Haskell98, so not accepted by default
13:15:33 <dolio> You might not be able to add things to a.
13:15:51 <benny99> ghci -farrows <--
13:16:03 <benny99> <interactive>:1:9: parse error on input `='
13:16:37 <benny99> argh..., mixed two ghci sessions..
13:16:43 <allbery_b> hm, somehow I don't think that is the fault of proc.
13:17:24 <benny99> works... stupidity as always :/
13:17:38 <dolio> Oh, I guess you can. Ignore me. :)
13:17:39 <benny99> no, I opened two ghci sessions here
13:17:58 * dolio hasn't actually used arrow syntax.
13:18:05 * benny99 did neither
13:18:17 <benny99> -did
13:18:41 <benny99> http://www.haskell.org/arrows/syntax.html <-- with lots of colours :)
13:18:42 <lambdabot> Title: Arrow syntax
13:21:13 <dolio> I do think you want: 'let addOne = proc a -> returnA -< (a + 1)'
13:21:36 <dolio> The a parameter to addOne gets ignored.
13:23:15 <benny99> I do
13:28:25 <mofmog> data Expr = Expr String Int Int
13:28:40 <mofmog> ^^ that means an expression is something with a string followed by two integers right?
13:28:55 <skorpan> yes mofmog
13:29:00 <skorpan> and Expr is its constructor
13:29:04 <mofmog> alright thanks
13:29:04 <skorpan> (afaik)
13:29:17 <mofmog> just making sure before ghc spits out an error.
13:29:23 <skorpan> :)
13:29:27 <mofmog> although ghc errors are pretty understandable
13:29:33 <skorpan> trial and error is one of the best learning methods
13:30:19 <xerox> > [ x*y | x <- [y,y-1 .. 0], y <- [1..10]]
13:30:19 <lambdabot>  Exception: not a number
13:31:30 <yitz> > [ x*y | y <- [1..10], x <- [y,y-1 .. 0]]
13:31:31 <lambdabot>  [1,0,4,2,0,9,6,3,0,16,12,8,4,0,25,20,15,10,5,0,36,30,24,18,12,6,0,49,42,35,2...
13:31:35 <xerox> ;-)
13:34:15 <Zao> If one finds a typo in the Network docs on hackage, who/how should a bug report be issued to.
13:34:35 <Zao> e.g "opertaions" on http://hackage.haskell.org/packages/archive/network/2.1.0.0/doc/html/Network.html#v%3Aaccept
13:34:36 <lambdabot> http://tinyurl.com/2nqzoz
13:41:53 <yitz> Zao: http://hackage.haskell.org/trac/ghc/
13:41:54 <lambdabot> Title: GHC - Trac
13:44:34 <Twey> GHC is in Hackage?
13:44:54 <allbery_b> no, just the trac instance runs on the same machine
13:45:41 <Zao> I've skimmed the user list but haven't found any clear trend in usernames. Is any particular form preferred?
13:47:04 <sethk> can data statements nest?  as in   data Whatever = Whatever { ..... data Whatever2 = ...   ?
13:51:05 <shapr> bos: Hey, I'm trying to build llvm, and I get "checking for LLVMModuleCreateWithName in -lLLVMCore... no" What does that mean?
13:51:36 <shapr> @seen bos
13:51:36 <lambdabot> bos is in #haskell and #ghc. I last heard bos speak 17h 52m 25s ago.
13:51:37 <shapr> ah
13:51:51 <yitz> Shouldn't the hackage page for a package have a link to the bug tracker for that package?
13:52:21 <yitz> And package "home page"?
13:52:51 <Zao> Home page seems to be mostly abused as darcs repos.
13:54:38 <yitz> Zao: hmm. well, any field could be abused, I suppose. If we actually used it, proper use would be better enforced.
13:55:03 <Zao> Anyway, bug submitted, thanks for the pointers.
13:55:26 <yitz> darcs repo could be a separate field, but I suppose we want to avoid that so that people will use cabal instead.
13:56:01 <unenough> @src tip
13:56:01 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:56:09 <unenough> HEy Peaker
13:56:27 <unenough> @hoogle a->[a]
13:56:28 <lambdabot> Prelude.repeat :: a -> [a]
13:56:28 <lambdabot> Data.List.repeat :: a -> [a]
13:56:28 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
13:56:40 <yitz> tip?
13:56:59 <yitz> @type cycle
13:56:59 <lambdabot> forall a. [a] -> [a]
13:57:21 <unenough> tip x = [x]
13:57:35 <yitz> so repeat?
13:57:36 <Peaker> unenough, return x = [x]
13:57:37 <lambdabot> Peaker: You have 1 new message. '/msg lambdabot @messages' to read it.
13:58:23 <yitz> > repeat 1
13:58:24 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:58:33 <yitz> > return 1 :: [Int]
13:58:34 <lambdabot>  [1]
13:58:42 <yitz> > (:[]) 1
13:58:43 <lambdabot>  [1]
13:58:54 <unenough> no not repeat
13:58:58 <dolio> > getZipList . pure $ 1
13:58:59 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
13:58:59 <ziman> > return 1 :: (IO Int)
13:59:00 <unenough> > let tip x = [x]
13:59:00 <lambdabot>  Parse error at end of input
13:59:00 <lambdabot>  <IO Int>
13:59:11 <unenough> > tip 1
13:59:12 <lambdabot>   Not in scope: `tip'
13:59:21 <unenough> ah, noob alert.
13:59:22 <Peaker> > (return 5)::[Int]
13:59:23 <lambdabot>  [5]
13:59:24 <dolio> tip isn't a Haskell function.
13:59:27 <diptansu> can somebody help me with this error:         Something is amiss; requested module  hdirect-1.0.0.0:HDirect.Base diffe
13:59:27 <diptansu> rs from name found in the interface file hdirect:HDirect.Base
14:00:03 <unenough> dolio i've figured that by now...is there a function x -> [x], though?
14:00:15 <dolio> People just listed a bunch.
14:00:17 <yitz> diptansu: oh oh, sounds like cabal trouble.
14:00:23 <dolio> return, pure, (:[])
14:00:35 <unenough> >return 1
14:00:37 <Peaker> unenough, "return" in the List monad puts it in the list
14:01:20 <yitz> unenough: I use return when in a monadic context, and (:[]) when just dealing with lists.
14:01:40 <ziman> > fail :: [Int]
14:01:40 <lambdabot>  Couldn't match expected type `[Int]'
14:01:40 <unenough> 1:[]
14:01:43 <yitz> (either one always works)
14:01:44 <unenough> > 1:[]
14:01:45 <lambdabot>  [1]
14:01:48 <unenough> ah ok
14:01:51 <diptansu> yeah.... but what is the problem actually?
14:01:56 <unenough> no problem :) thanks
14:02:18 <yitz> diptansu: what did you type?
14:02:22 <diptansu> i was compiling the hdirect sources and it gave this error while trying to compile the examples
14:02:40 <diptansu> the hdirect sources compiled correctly
14:04:05 <yitz> using cabal?
14:04:39 <diptansu> no... using the Makefiles in the cvs  sources
14:05:01 <diptansu> but i think i screwed up the registering part of it
14:05:46 <diptansu> i registered using the ghc-pkg -u option, with the input redirected from a file in the sources...
14:06:09 <diptansu> name:hdirect
14:06:18 <diptansu> version: 1.0.0.0
14:06:31 <diptansu> exposed-Module: HDirect.Base,....
14:07:08 <yitz> diptansu: where did you get it from? (the "latest version" linked from its home page is 0.21, looks bit-rotted. don't see anything on hackage.)
14:07:24 <diptansu> the latest version from CVS
14:07:43 <yitz> where's that?
14:07:44 <diptansu> no, this is not the downloadale version from the home page.... that one didnt compile
14:08:10 <diptansu> its in fptools/hdirect in cvs.haskell.orgf
14:08:15 <diptansu> its in fptools/hdirect in cvs.haskell.org
14:08:38 <diptansu> however the latest sources needed some fixes before they could compile....
14:10:20 <yitz> hmm... cvs hasn't been used for years... they use darcs now, and I don't see hdirect there.
14:10:31 <skorpan> is there any type of filter which can be applied to Data.Map.Map?
14:10:49 <diptansu> hmmm... its in the cvs
14:11:06 <skorpan> i have a map A -> B and want to filter out all the B's which don't match my criteria
14:11:21 <diptansu> there is a link from the hdirect home page to thhe cvs sources
14:11:24 <Peaker> skorpan, apply a filter to your map result?
14:11:29 <skorpan> preferrably without doing toList and then fromList
14:11:39 <skorpan> oh, there is a filter function
14:11:40 <skorpan> my bad
14:11:41 <Peaker> skorpan, oh, nm, I missed previous statement
14:11:55 <skorpan> :)
14:11:59 <skorpan> nvm i got it
14:13:07 <yitz> diptansu: ooh. i see it. last check-in was 3 yrs ago, most 7-10 years ago. doesn't look great. what did you want to do with it?
14:13:34 <skorpan> @pl M.filter (\y -> not $ isRank x y) (pieces $ board game)
14:13:34 <lambdabot> M.filter (not . isRank x) (pieces (board game))
14:13:34 <diptansu> right
14:13:45 <skorpan> awesome
14:14:08 <diptansu> i want a way to call c functions from a dll file....
14:14:16 <diptansu> hdirect seems to be a way to do it simply...
14:14:49 <diptansu> that way i can use a lot of existing functions and control them from haskell...
14:15:03 <yitz> diptansu: I think people just use ffi nowadays, works pretty good i think.
14:15:28 <diptansu> ok, i will check that out...
14:15:45 <diptansu> but will FFI help if say I want to call function from .net libraries?
14:15:48 <yitz> there are other tools to simplify generating header files and what-not.
14:16:03 <diptansu> because then I can leverage the huge amount of libraries available in .net
14:16:49 <yitz> diptansu so you want to compile haskell to clr?
14:17:15 <diptansu> no, i dont want to compile to clr... just call functions from the .net libraries
14:17:33 <diptansu> say i want to call the windows.forms functions....
14:17:47 <yitz> so using com?
14:17:59 <diptansu> yeah... thats y i was looking at hdirect...
14:18:20 <allbery_b> somewhere or other SPJ said why there is no Haskell for the CLR, related somehow to linkage IIRC
14:18:45 <allbery_b> (it was anobvious question once F# aka OCaml-for-CLR showed up)
14:19:18 <yitz> allbery_b: yes, he worked on it a few years back, but it was just too big. it would be a great project for anyone who takes it on...
14:20:23 <diptansu> but can't we do a similar thing by leveraging COM?
14:20:24 <yitz> should be possible using com, though. I have done that myself. if no one else answers here, post to haskell-cafe.
14:20:25 <skorpan> @pl M.filter (\r -> player r == turn game) x
14:20:25 <lambdabot> M.filter ((turn game ==) . player) x
14:21:03 <diptansu> what's haskell-cafe? (sorry i am kinda new to haskell...)
14:21:08 <skorpan> lambdabot, you're so awesome
14:22:08 <dons> diptansu: its the main mailing list of the community
14:22:17 <diptansu> ok, thanks
14:22:21 <TSC> diptansu: http://www.haskell.org/mailman/listinfo/haskell-cafe
14:22:21 <lambdabot> Title: Haskell-Cafe Info Page
14:22:42 <diptansu> while compiling a module, is there a directive which says what the package is that it is being compiled for?
14:22:52 <diptansu> if so, maybe there is a problem there...
14:24:26 <yitz> diptansu: there's a section called "Calling C functions in DLL" on http://haskell.org/haskellwiki/FFI_cook_book
14:24:28 <lambdabot> Title: FFI cook book - HaskellWiki
14:27:02 <skorpan> @pl map (\p -> (p, attacked p game)) ps
14:27:02 <lambdabot> map (ap (,) (flip attacked game)) ps
14:27:09 <skorpan> ap? :|
14:27:15 <mauke> @src ap
14:27:15 <lambdabot> ap = liftM2 id
14:27:20 <edwardk> @seen trurl
14:27:21 <lambdabot> trurl is in #haskell. I don't know when trurl last spoke.
14:27:30 <Jaak> > fmap (+1) (0, 1)
14:27:31 <lambdabot>  (0,2)
14:27:46 <Jaak> bah
14:28:07 <xerox> > join (***) (+1) (0,1)
14:28:08 <lambdabot>  (1,2)
14:28:11 <solrize_> you can doooooooo that?
14:28:18 <solrize_> fmap (+1) (1,2,3,4,5,6,7)
14:28:25 <solrize_> > fmap (+1) (1,2,3,4,5,6,7)
14:28:26 <lambdabot>        add an instance declaration for
14:28:26 <lambdabot>       (Functor ((,,,,,,) t t1 t2 t3 t4...
14:28:30 <solrize_> hah
14:28:33 <wagle_home> > fmap (+1) (Left 1)
14:28:34 <lambdabot>  Left 1
14:28:39 <diptansu> yitz: Thanks
14:28:45 <wagle_home> > fmap (+1) (Right 1)
14:28:45 <lambdabot>  Right 2
14:29:11 <wagle_home> monads are too linear or something
14:30:17 <sieni> I agree that they should be at least quartic
14:30:18 <dolio> fmap (+1) (1,2,3,4,5,6,7) would be (1,2,3,4,5,6,8) if such a functor were declared.
14:33:36 <Jaak> it all makes sense actually
14:34:10 <Jaak> i was looking for something along the lines of "instance Functor (a,a)"
14:34:51 <dolio> Yeah. Sized vectors rather than tuples.
14:35:57 <skorpan> @pl any (\(_, b) -> b) $ attackedPositions ps game
14:35:57 <lambdabot> any snd (attackedPositions ps game)
14:36:09 <skorpan> oh.. right.
14:37:09 <dolio> kuribas: Your indenter won't let me write GADTs. :)
14:50:09 <dolio> http://hpaste.org/6575
14:58:15 <haskelldude> Hi, I'm trying to print a prompt ("> ") before I readLine but my STDIO is not flushed since I use putStr and not putStrLn -- how do I flush the buffer?
14:58:43 <monochrom> import System.IO, then use hFlush stdout
14:59:12 <haskelldude> INSANE
14:59:19 <haskelldude> Thank you,
15:01:48 <Twey> haskelldude: Alternatively, hSetBuffering stdout NoBuffering
15:05:05 * matthew-_ wins the prize for a type class with 24 params
15:06:43 <monochrom> That is a lot. :)
15:07:30 <matthew-_> it's sufficient ;)
15:07:52 <xerox> What does it encode?
15:08:04 <matthew-_> err, you really don't want me to try to explain that
15:08:08 <matthew-_> I'll be here all night
15:11:26 <wkh> > (Char.ord '5') - (Char.ord '0')
15:11:26 <lambdabot>   Not in scope: `Char.ord'
15:11:37 <wkh> > ord 'a'
15:11:37 <lambdabot>  97
15:11:48 <wkh> > ord '5' - ord '0'
15:11:49 <lambdabot>  5
15:12:04 <wkh> @pl \c -> ord c - ord '0'
15:12:04 <lambdabot> subtract (ord '0') . ord
15:12:12 <wkh> huh.
15:12:46 <mauke> > digitToInt '5'
15:12:46 <lambdabot>  5
15:13:24 <wagle_home> > digitToInt 'f'
15:13:25 <lambdabot>  15
15:13:50 <wagle_home> @src digitToInt
15:13:50 <lambdabot> Source not found.
15:14:02 <wkh> @src Char.digitToInt
15:14:02 <lambdabot> Source not found. I feel much better now.
15:14:12 <Botje> > map digitToInt ['0'..'9']++['a'..'f']
15:14:13 <lambdabot>  Couldn't match expected type `Int' against inferred type `Char'
15:14:17 <gnuvince_> > map digitToInt ([0..9] ++ ['a'.. 'f'])
15:14:18 <lambdabot>   add an instance declaration for (Num Char)
15:14:18 <lambdabot>     In the expression: 0
15:14:33 <Botje> > map digitToInt (['0'..'9']++['a'..'f'])
15:14:33 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
15:14:53 <shapr`> @yow !
15:14:54 <lambdabot> The fact that 47 PEOPLE are yelling and sweat is cascading down my
15:14:54 <lambdabot> SPINAL COLUMN is fairly enjoyable!!
15:15:02 <mauke> @yow!
15:15:03 <lambdabot> Now I'm having INSIPID THOUGHTS about the beatiful, round wives of
15:15:03 <lambdabot> HOLLYWOOD MOVIE MOGULS encased in PLEXIGLASS CARS and being approached
15:15:03 <lambdabot> by SMALL BOYS selling FRUIT ...
15:15:04 <Botje> :)
15:15:08 <Botje> hello
15:15:27 <wkh> i'm on page 50 of Bird :/
15:16:04 <monochrom> Bird is good.
15:24:38 <dozer> I'm using (sequence . map makeOpp) params
15:24:48 <dozer> where makeOpp is a monad transformer applied to IO
15:24:49 <mauke> :t mapM
15:24:50 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:25:19 <dozer> it looks like the op is being evaluated very eagerly to me
15:27:21 <dozer> do { res <- evaluate $ mapM makeOpps params ; mapM_ printResult res }
15:27:33 <dozer> this seems to build the whole of res before applying printResult to any of the elements
15:30:50 <monochrom> That is what mapM and sequence do.
15:31:14 <dozer> oh dear (
15:31:27 <dozer> mapM returns values, not computations?
15:32:02 <glguy> mapM returns a single computation of a list of values
15:32:09 <allbery_b> depends.  IO is often forced, but there's no conceptual reason why monads can't be lazy
15:32:12 <EvilTerran> it can only return one computation - look at the type
15:32:56 <monochrom> I cannot explain in those terms.  sequence [a,b] is the same as do{x<-a; y<-b; return [x,y]}.  You decide what that means.
15:32:58 <solrize_> > do { return (1/0) ; print "hi" }
15:32:58 <lambdabot>  <IO ()>
15:33:46 <ziman> > 1/0
15:33:47 <lambdabot>  Infinity
15:33:50 <EvilTerran> solrize_, the parameter of return won't be forced by bind
15:34:00 <EvilTerran> > return undefined >> return ()
15:34:00 <ziman> > 0/0
15:34:00 <lambdabot>   add an instance declaration for (Show (m ()))
15:34:01 <lambdabot>  NaN
15:34:15 <EvilTerran> > return undefined >> return () :: IO ()
15:34:16 <lambdabot>  <IO ()>
15:34:17 <solrize_> evilterran, correct.  it did what i expected.  what i'm wondering is why do {print "hi"; print "there"} does both prints.
15:34:22 <EvilTerran> > undefined >> return () :: IO ()
15:34:23 <lambdabot>  <IO ()>
15:34:23 <monochrom> What sequence does is the best possible given that it can only assume Monad and nothing else.  It cannot know how >>= behaves.  It can only use it.  There are no other operators to use.
15:34:26 <EvilTerran> bah.
15:34:45 <EvilTerran> solrize_, um... because you give it both prints to do?
15:35:06 <solrize_> how is the first print different from return(1/0) ?
15:35:15 <monochrom> If you say, "but I'm in an IO-like monad, I have access to unsafeInterleaveIO", then that's specific to IO and not applicable to all Monads.
15:35:26 <mauke> solrize_: return(1/0) doesn't print anything
15:35:34 <EvilTerran> solrize_, >> runs the action on the left, runs the action on the right, and then returns the value of the action on the right
15:35:52 <solrize_> err, what happens when you "run the action" of return $ 1/0 ?
15:35:55 <EvilTerran> "runs the action" and "returns the value of" are very different ideas
15:36:05 <mauke> solrize_: nothing
15:36:12 <EvilTerran> nothing. (return x) is defined to be the action that does nothing but has the value x.
15:36:15 <mauke> 'return' has no side effects
15:36:28 <EvilTerran> this is guaranteed by the monad laws.
15:36:38 <solrize_> hmm
15:36:48 <EvilTerran> (specifically, that (return >=>) = (>=> return) = id)
15:36:54 <dozer> solrize_ it's only when you later try to access (1/0) in some way e.g. print it that it gets evaluated to an error
15:37:18 <solrize_> > do { print (1/0); print "whee"}
15:37:19 <lambdabot>  <IO ()>
15:38:00 <monochrom> return must be both pure and non-strict.  A monad law implies  return (1/0) >> return True  equals  return True.  The latter can't throw an exception.
15:38:07 <eu-prleu-peupe1> hello
15:38:16 <eu-prleu-peupe1> i have an application to the google summer of code
15:38:22 <eu-prleu-peupe1> and i would like to do it in haskell
15:38:27 <eu-prleu-peupe1> anyone care to review it ?
15:38:40 <solrize_> eu-prleu-peupe1, sure.  pastebin?
15:38:43 <eu-prleu-peupe1> http://pastebin.com/d6d871698
15:38:43 <solrize_> hpaste.org
15:38:51 <eu-prleu-peupe1> oh i didn't knew of hpaste
15:39:14 <eu-prleu-peupe1> anyway, this is just an idea that came up, dont know if anyone might be interested on that
15:39:16 <mauke> hpaste will probably truncate it anyway
15:40:01 <wagle_home> eu-prleu-peupe1, need short definition of "procedural content generation" in abstract..  i'm lost
15:40:42 <solrize_> yeah, also proposing a haskell project without having written anything in haskell before is kind of scary.  haskell is probably not like anything you're used to
15:41:01 <wagle_home> and i dont know what "desired content" would be
15:41:10 <eu-prleu-peupe1> ah ok, ill add some references to it, and try to describe it
15:41:40 <eu-prleu-peupe1> i have written some OCaml though.. but i wouldn't like to do it in OCaml :/
15:41:45 <Tobsan> @src concatMap
15:41:45 <lambdabot> concatMap f = foldr ((++) . f) []
15:41:53 <wagle_home> your audience is computer literate, but doesnt know this particular stuff
15:42:11 <eu-prleu-peupe1> ok
15:42:23 <solrize_> ok, return (1/0)::IO a   makes a monadic action that does nothing and wraps 1/0.  So you compute the action, nothing happens, but when you bind it, 1/0 gets forced and diverges.
15:42:38 <mauke> > show (1/0)
15:42:39 <lambdabot>  "Infinity"
15:43:05 <solrize_> eu-prleu-peupe1 i think haskell is further out than ocaml
15:43:43 <solrize_> i looked at the ocaml manual and said "ok, this is a cross between lisp and C" or something like that.  haskell i've studied on and off for about a year and am stilly totally confused by even the simplest things.
15:43:46 <solrize_> still
15:43:49 <solrize_> brb
15:43:56 <eu-prleu-peupe1> hmm yes, im a bit scared too
15:43:58 <Tobsan> sup svahn
15:44:00 <fophillips> Is the best way to get the first option from the command line and convert it into an int: args <- getArgs; read (head args) :: Int
15:44:18 <EvilTerran> ?type readIO
15:44:18 <Botje> depends on your definition of "best"
15:44:19 <lambdabot> forall a. (Read a) => String -> IO a
15:44:32 <monochrom> That code won't compile, but fine.
15:44:33 <svahn> Tobsan: :)
15:44:44 <EvilTerran> might be of use - it makes an IO error instead of a normal bottom
15:44:44 <eu-prleu-peupe1> my code wont be l33t haskell, but dummie haskell instead...
15:44:46 <Botje> it will fail with a "can't take head of empty list" error
15:44:51 <Botje> if there are no args
15:44:51 <Tobsan> @pl filter (==True) [ isPrime x | x <- xs]
15:44:51 <lambdabot> filter (True ==) [isPrime x | x <- xs]
15:44:56 <Tobsan> pfft
15:45:05 <Tobsan> hmm
15:45:08 <Tobsan> oh yes
15:45:13 <fophillips> Botje: Validation isn't really necessary.
15:45:32 <Botje> in that case, go with that :)
15:45:43 <EvilTerran> Tobsan, it seems odd to filter on a list of booleans - are you sure that's what you want?
15:45:50 <Tobsan> @pl filter (\x -> x == True) $ map (\x -> isPrime x) xs
15:45:50 <lambdabot> filter (True ==) (map isPrime xs)
15:46:00 <Tobsan> EvilTerran: i'm just playing around with @pl
15:46:17 <EvilTerran> [xIsPrime | x <- xs, let xIsPrime = isPrime x, xIsPrime]
15:46:33 <Tobsan> EvilTerran: it's nothing really i want to do :P
15:46:43 <EvilTerran> actually, neater: [True | x <- xs, isPrime x]
15:47:02 <fophillips> Also, from the wiki: http://hpaste.org/6576
15:47:11 <svahn> EvilTerran: He's just showing me @pl
15:47:15 <EvilTerran> that may be so, but i can still demonstrate some functionality of haskell that you may or may not be aware of :P
15:47:16 <dolio> \x -> x == True = id
15:47:53 <monochrom> Are you using Haskell equal True?
15:48:18 <EvilTerran> belgium.
15:57:40 <kuribas> dolio: fixed
15:58:42 <litb> hello all
16:00:11 <kuribas> dolio: http://kuribas.hcoop.net/haskell-indentation.el
16:00:16 <dolio> kuribas: Nice, thanks.
16:01:01 <kuribas> It was a trivial change, I just needed to add the "where" keyword to "data".
16:02:59 <kuribas> Please tell me if there are more extensions that need to be supported :)
16:03:25 <dolio> I'll let you know if I run into anything.
16:06:29 <diptansu> whats the "-syslib" option for GHC?
16:10:23 <fophillips> How could I make this return all the possible combinations rather than just the first <http://hpaste.org/6576>?
16:11:12 <fophillips> Never mind...
16:11:37 <dozer> is there a short tutorial/example of how to use Writer?
16:11:56 <monochrom> I don't know, perhaps remove "head" ?
16:12:00 <Laney> dozer: Have you seen All About Monads?
16:12:28 <allbery_b> monochrom: I suspect that's why the sheepish-dsounding "Never mind..."
16:12:56 <monochrom> Haha, didn't notice the last line. :)
16:13:00 <matthew-_> can you put rank N types in class instance heads?
16:13:20 <fophillips> monochrom: :)
16:13:23 <matthew-_> eg instance Eq (forall a . Foo a) (forall b . Foo b) where ... ?
16:13:43 <matthew-_> err, ignore that
16:13:50 <dozer> Laney: that's exactly what I needed - thx
16:16:27 <EvilTerran> matthew-_, i don't think you can, i think you need a constructor wrapper for them
16:16:58 <matthew-_> EvilTerran: hmm
16:17:07 <matthew-_> maybe a type family would help
16:19:09 <haskelldude> is there an xor function in the prelude?
16:19:24 <mauke> bitwise or logical?
16:19:29 <haskelldude> logical
16:19:36 <mauke> yes, it's called (/=)
16:19:43 <haskelldude> haha
16:19:45 <haskelldude> my bad
16:23:06 <Twey> Is there a *bitwise* xor in the Prelude?
16:23:16 <mauke> no, it's in Data.Bits
16:23:16 <dons> :t Data.Bits.xor
16:23:19 <lambdabot> forall a. (Bits a) => a -> a -> a
16:23:27 <Twey> Aha
16:23:38 <mauke> and for some weird reason it's not called .^.
16:23:42 <dons> heh
16:23:50 <Twey> Heheh
16:23:57 <dons> ?let (.^.) = Data.Bits.xor
16:23:58 <lambdabot> <local>:2:8:     Ambiguous type variable `a' in the constraint:       `Bits a...
16:24:14 <mauke> monomorpwned
16:24:14 <dons> ?let (.^.) :: (Bits a) => a -> a -> a ; (.^.) = Data.Bits.xor
16:24:15 <lambdabot> Defined.
16:24:32 <dons> ?check \x y -> x .^. y == x `xor` y
16:24:32 <lambdabot>  Add a type signature
16:24:37 <dons> ?check \x y -> x .^. y == x `xor` (y :: Int)
16:24:38 <lambdabot>  OK, passed 500 tests.
16:25:12 <whee> I don't understand check :(
16:25:17 <whee> @check \x y -> x == y
16:25:18 <lambdabot>  OK, passed 500 tests.
16:25:24 <mauke> haha
16:25:28 <EvilTerran> ... what?
16:25:33 <mauke> defaults to ()
16:25:44 <EvilTerran> that strikes me as an odd choice
16:25:54 <mauke> @check \x y -> x == (y :: Int)
16:25:58 <lambdabot>  Falsifiable, after 0 tests: -3, 0
16:27:53 <dons> ?check \x -> x == (- (- x) :: Float)
16:27:54 <lambdabot>  OK, passed 500 tests.
16:28:21 <mauke> > (\x -> x == (- (- x)) (0/0)
16:28:21 <lambdabot> Unbalanced parentheses
16:28:26 <mauke> > (\x -> x == (- (- x))) (0/0)
16:28:29 <lambdabot>  False
16:28:54 <dons> ?check \x y -> x + y == y + (x :: Double)
16:28:54 <lambdabot>  OK, passed 500 tests.
16:29:24 <mauke> @check \x y z -> (x + y) + z == x + (y + z :: Double)
16:29:24 <lambdabot>  OK, passed 500 tests.
16:29:28 <mauke> lame
16:30:19 <EvilTerran> ?check \x y -> x/y == x/(y::Double)
16:30:19 <lambdabot>  Falsifiable, after 0 tests: 0.0, 0.0
16:30:24 <EvilTerran> win!
16:30:35 <EvilTerran> ?check on
16:30:35 <lambdabot>  Add a type signature
16:32:23 <EvilTerran> ?check (join (==) .) . (/) :: Double -> Double -> Bool
16:32:24 <lambdabot>  Falsifiable, after 7 tests: 0.0, 0.0
16:32:28 <EvilTerran> whee, pointlessness
16:32:48 <plaeremans> hi, h as anyone tried the network-minihttp library yet ?
16:32:53 <EvilTerran> ?check join (==) :: Double -> Double -> Bool
16:32:53 <lambdabot>  Couldn't match expected type `Double -> Bool'
16:32:58 <EvilTerran> ?check join (==) :: Double -> Bool
16:32:59 <lambdabot>  OK, passed 500 tests.
16:33:16 <EvilTerran> it'd be nice if that checked NaN, Infinity, etc i guess
16:33:24 <EvilTerran> ?scheck join (==) :: Double -> Bool
16:33:32 <lambdabot>   Completed 79 test(s) without failure.
16:40:14 <Fester> I was wondering, would anyone consider the idea about implementation of a machine learning library to haskell suitable for a SoC project?
16:40:28 <Fester> it is listed in the project ideas from last year
16:51:07 <Botje> @pl \name -> Infix (ASTBinOp name) AssocRight
16:51:07 <lambdabot> flip Infix AssocRight . ASTBinOp
16:51:19 <skorpan> @pl \pos -> not $ attacked pos game
16:51:20 <lambdabot> not . flip attacked game
16:52:25 <EvilTerran> if you prefer, not . (`attacked` game)
16:53:57 <skorpan> that one was pretty cool too
16:54:04 <EvilTerran> (i do)
16:54:05 <skorpan> (my project is due in 23 hours)
16:54:10 <duncan> Saizan: ah so you fixed #166 ?
16:54:22 <EvilTerran> @pl \pos -> not $ pos `attacked` game
16:54:22 <lambdabot> not . (`attacked` game)
16:54:48 <svahn> skorpan: Doing AFP? ;)
16:54:54 <EvilTerran> i guess it depends on the meaning of "attacked" whether it makes sense to use it infix
16:59:40 <skorpan> svahn: indeed i am
17:00:25 <dons> ndm, around?
17:00:30 <dons> nope.
17:00:32 <skorpan> svahn: i see you're describing music in a DSL.. i'm curious to know what you have done differently from hascore (was that the name for it?)
17:01:07 <svahn> skorpan: That's kinda the thing I realized when I started looking in to it.
17:01:24 <skorpan> svahn: :D
17:01:54 <skorpan> i was going to do that project as well, but soon realized that i would have done it at best as good as hascore
17:02:01 <skorpan> so i ditched the idea and went for board games
17:02:04 <svahn> :)
17:02:08 <svahn> Good choice.
17:02:26 <skorpan> i'm not so sure... 956 LOC's and still counting :/
17:02:42 <svahn> I managed to adapt his MIDI-thingamajig to my implementation.
17:02:45 <roconnor> skorpan: we can cut that in half.
17:02:48 <svahn> So at least I can listen to my stuff.
17:02:54 <Dybber> > iterate (+1) 0 !! 1000000
17:02:55 <lambdabot>  Exception: stack overflow
17:03:05 <skorpan> roconnor: i'd bet you could
17:03:14 <skorpan> svahn: well that's awesome
17:03:17 <Dybber> hmm why do I get that stack-overflow?
17:03:19 <roconnor> haskell code can always be cut in half.
17:03:22 <mauke> > iterate succ 0 !! 1000000
17:03:23 <lambdabot>  Exception: stack overflow
17:03:33 <mauke> > iterate (succ $!) 0 !! 1000000
17:03:34 <lambdabot>  Exception: stack overflow
17:03:41 <skorpan> roconnor: the problem here is that i want my DSL to be as good as possible and provide support for anything you might want to do in a board game, so..
17:03:50 <Dybber> > maximum [1..1000000]
17:03:51 <lambdabot>  1000000
17:03:57 <mauke> er
17:04:09 <skorpan> wow, i got into an infinite loop. i must be doing something right!
17:04:12 <mauke> what was I thinking
17:04:14 <roconnor> Dybber: I belive it is building up a thunk contaning 1 000 000 unevaluated additions
17:05:05 <roconnor> skorpan: well, it is all about finding just the right set of primitives.
17:05:05 <Dybber> roconnor: ah, but how can I fix it?
17:05:17 <skorpan> roconnor: indeed!
17:05:32 <skorpan> but i'm the type of guy that likes trial and error
17:05:32 <roconnor> Dybber: just say 1000000.  More seriously, what are you trying to do?
17:05:54 <skorpan> i don't like to really analyze problems and look for the best solution there is, but rather get things done
17:05:55 <roconnor> skorpan: I'm not aware of any other method of finding the right set of primatives.
17:06:07 <skorpan> roconnor: well, that's true.
17:06:08 <skorpan> :)
17:06:22 <roconnor> If you find a better method, please let us know!
17:06:31 <roconnor> I actually suspect there is a better way.
17:06:42 <skorpan> UML!
17:06:51 <skorpan> i kiiid, i kiiid... fsck UML.
17:06:53 <Dybber> roconnor: well I just used the addition as an example, I use a function that computes the next step in the euler-method http://en.wikipedia.org/wiki/Euler_method
17:06:53 <roconnor> bzzzt!
17:06:54 <lambdabot> Title: Euler method - Wikipedia, the free encyclopedia
17:07:09 <matthew-_> haddock: internal Haddock or GHC error: src/Haddock/Interface/AttachInstances.hs:(122,0)-(123,47): Non-exhaustive patterns in function toHsPred
17:07:14 <duncan> if UML is the answer, you asked the wrong question
17:07:17 <matthew-_> any idea what that's about?
17:07:25 <svahn> The answer is badgers.
17:08:29 <roconnor> Dybber: you won't get a stack overflow if you consume the list of iterates.
17:08:57 <mauke> iterate' f x = x `seq` (x : iterate' f (f x))
17:09:19 <Dybber> roconnor: that is, look at every element on the way?
17:09:29 <roconnor> Dybber: correct
17:10:10 <skorpan> :t (!!!)
17:10:11 <lambdabot> Not in scope: `!!!'
17:10:13 <skorpan> sweet
17:10:35 <roconnor> > let iterate' f x = x `seq` (x : iterate' f (f x)) in interate' (+1) 0 !! 100000
17:10:35 <lambdabot>   Not in scope: `interate''
17:10:41 <roconnor> > let iterate' f x = x `seq` (x : iterate' f (f x)) in iterate' (+1) 0 !! 100000
17:10:43 <lambdabot>  100000
17:10:48 <roconnor> > let iterate' f x = x `seq` (x : iterate' f (f x)) in iterate' (+1) 0 !! 1000000
17:10:50 <lambdabot>  1000000
17:11:10 <roconnor> mauke: seq makes my head hurt.
17:11:15 <mauke> heh, why?
17:11:16 <Dybber> I think I'll use that version :-) Thanks roconnor and mauke
17:11:43 <roconnor> mauke: I can't tell when it is evaluated.
17:11:56 <mauke> as always, when someone needs it
17:12:14 <roconnor> mauke: right, so when the cons is demanded.
17:12:24 <mauke> the trick is that evaluating (x `seq` y) automatically forces x
17:12:45 <roconnor> mauke: yeah, but when is (x `seq` y) demanded?
17:12:53 <roconnor> answer, when the constructor in y is demanded?
17:12:58 <mauke> somewhere in !!
17:13:13 <roconnor> mauke: yeah, somewhere is what confuses me.
17:13:26 <mauke> @src (!!)
17:13:26 <lambdabot> xs     !! n | n < 0 = undefined
17:13:26 <lambdabot> []     !! _         = undefined
17:13:26 <lambdabot> (x:_)  !! 0         = x
17:13:26 <lambdabot> (_:xs) !! n         = xs !! (n-1)
17:13:29 <Dybber> seq relies on the call-by-need evaluation, right?
17:14:09 <mauke> the pattern matching on xs forces the seq, which forces x and then returns the cons
17:14:48 <Dybber> @src seq
17:14:48 <lambdabot> Source not found. Do you think like you type?
17:14:57 <mauke> seq is magic
17:15:13 <roconnor> mauke: right, the (:)
17:16:16 <duncan> @seen Saizan
17:16:16 <lambdabot> Saizan is in #haskell, #haskell-overflow, #haskell-blah and #haskell-soc. I last heard Saizan speak 7h 53m 3s ago.
17:16:17 <roconnor> mauke: I wanted to understand why your definiton worked, but iterate (something with seq) doesn't.
17:16:35 <roconnor> mauke: it is because you put the seq outside the (:)
17:16:42 <mauke> yeah
17:16:54 <matthew-_> sessions 2008.3.23 released. Get it while it's hot!
17:16:55 <mauke> iterate would just build a thunk of seqs
17:17:09 <roconnor> hence why my head hurts.
17:17:29 <mauke> that's how you know it works!
17:17:48 <roconnor> I still think Dybber doesn't need your definition, but it doesn't hurt too much either.
17:18:10 <mauke> (succ $!) is obviously useless because succ is strict anyway
17:19:45 <roconnor> And once Dybber has a working program he can remove the ' and see that it still works ;)
17:19:47 <Dybber> roconnor: well, the only reason I create a list of the results is when I need to create graphs of the data, the most of the time I just want an element far down the list.
17:21:00 <roconnor> Dybber: how far down?
17:21:08 <Dybber> hmm when using my euler-method function I still get stack overflow
17:22:50 <Dybber> roconnor: well, I don't know, it's just an assignment in numerical analysis, I don't think it matters so much. I decided to do it in Haskell at first, then ask the lecturer afterwards if thats ok :)
17:23:07 <roconnor> :)
17:24:13 <Dybber> He probably wants it in MATLAB..
17:25:19 <solrize_> dybber have you looked at "why fp matters" ?
17:25:53 <solrize_> anyway i think for your euler integrator the basic strategy is add strictness til it works
17:26:19 <Dybber> solrize_: only the first couple of pages I think
17:26:28 <EvilTerran> use the debugger to see what's overflowing, mind
17:26:30 <solrize_> the numerical stuff starts a few pages in
17:29:32 <Dybber> solrize_: ok, it will be my goodnight story :)
17:29:55 <solrize_> it just gives some examples of numerical algorithms in a haskell-like language
17:30:12 <solrize_> i think its integrator basically comes down to richardson extrapolation
17:30:13 <solrize_> http://en.wikipedia.org/wiki/Richardson_extrapolation
17:30:14 <Dybber> yes, miranda, I remember that
17:30:33 <solrize_> i think there's a way to do ODE's the same way more or less
17:31:08 <solrize_> but that gets fancy
17:31:19 <solrize_> and if your assignment is euler's method then stay with that at first :)
17:32:07 <Dybber> it directly says that we should implement eulers method
17:32:18 <elaforge> could someone help me get my head around monad transformers for a bit?
17:32:25 <elaforge> I implemented MaybeT as in http://en.wikibooks.org/wiki/Haskell/Monad_transformers
17:32:33 <elaforge> now I'm trying to figure out how to use it!
17:33:18 <elaforge> if I have MaybeT IO a, I should be able to have nested IO actions that only happen if I don't hit a Nothing, right?
17:33:45 <roconnor> elaforge: sounds approximately right.
17:34:32 <elaforge> but this doesn't work:
17:34:32 <elaforge> t1 :: MaybeT IO Int
17:34:33 <elaforge> t1 = do
17:34:33 <elaforge>     x <- lift get1
17:34:33 <elaforge>     y <- Nothing
17:34:33 <elaforge>     return (x+y)
17:34:47 <elaforge> where get1 :: IO Int, = return 42
17:34:55 <roconnor> elaforge: oh maybe not.
17:35:09 <roconnor> hmm
17:35:38 <elaforge> from the signature, though, the Maybe is *inside* the IO
17:35:45 <elaforge> IO (Maybe a)
17:36:11 <elaforge> which is IO actions maybe giving values, not functions that maybe give IO actions
17:36:24 <roconnor> right
17:36:48 <elaforge> but the page refers to m in MaybeT m a as the *inner* monad
17:37:18 <elaforge> which implies that MaybeT IO Int is IO inside a maybe, right?
17:37:34 <sethk> maybe
17:37:48 <elaforge> boo
17:37:55 <roconnor> the thing is that monad transforms sometimes compose on the outside, and sometimes compose on the inside, and sometimes a bit of both, and sometimes neither.
17:37:58 <elaforge> (if that was supposed to be a pun, I mean)
17:38:17 <sethk> elaforge, well, a bit weak, I admit  :)
17:38:22 <elaforge> erm, but the bottom line is to get both behaviours in one do-block, right?
17:38:46 <elaforge> I could do the nested StateT examples, that worked as I expected
17:39:04 <elaforge> but then I wanted to be able to do the Maybeish thing where I abort the whole function as soon as I hit Nothing
17:39:30 <elaforge> that's what ErrorT does, right?
17:41:07 <roconnor> elaforge: let's look at your example again
17:41:29 <elaforge> t1 = do
17:41:30 <elaforge>     x <- lift get1
17:41:30 <elaforge>     y <- Nothing
17:41:30 <elaforge>     return (x+y)
17:41:37 <elaforge> I can hpaste if you want
17:41:41 <roconnor> what happens that you find unexpected?
17:41:47 <MarcWeber> Which is the way to expose some API to an GHC(I) scripting interface?
17:41:49 <elaforge> type error :)
17:41:58 <roconnor> oh
17:42:08 <elaforge>     Couldn't match expected type `MaybeT IO t'
17:42:08 <elaforge>            against inferred type `Maybe a'
17:42:08 <elaforge>     In a 'do' expression: y <- Nothing
17:42:16 <dons> interesting, a nice curses wrapper? http://www.clifford.at/stfl/
17:42:17 <elaforge> MarcWeber: FFI?
17:42:17 <lambdabot> Title: STFL - Structured Terminal Forms Language/Library
17:42:18 <dons> that we could bind to
17:42:40 <svahn> If you write this in a case expression, in what order will it be pattern-matched?
17:42:43 <svahn>   Cs -> C; Cf -> C;
17:42:46 <svahn>   Ds -> D; Df -> D;
17:43:10 <roconnor> elaforge: indead,  Nothing has type Maybe t, not MaybeT IO t.
17:43:12 <svahn> Left-right or top-bottom?
17:43:14 <roconnor> indeed
17:43:14 <sethk> svahn, sequentially, horizontally first of course
17:43:23 <MarcWeber> elaforge: Concrete example: How do I expose some FFI imported functions (vim scripting interface)  to a GHCI session?
17:43:34 <sethk> svahn, line 1 left, line 1 right, line2 left ...
17:43:44 <MarcWeber> The GHCI session is started by using GHC API
17:43:56 <svahn> sethk: Thanks.
17:44:10 <VP> I think I found a weird multithreading bug in Gtk2Hs. Where do I report it?
17:44:11 <elaforge> MarcWeber: oh, dunno about ghc api, but in general you just do 'foreign import etc. c_function' and then you call it from haskell
17:44:12 <roconnor> elaforge: you need some primatives for Maybe-like monads.
17:44:23 <elaforge> other than bind and return?
17:44:31 <MarcWeber> sethk: Any suggestion?
17:44:33 <roconnor> yep
17:44:45 <roconnor> elaforge: state has its get and put
17:44:48 <roconnor> elaforge: writer as tell
17:44:59 <roconnor> elaforge: error has throw and catch
17:45:08 <elaforge> roconnor: so something like "throw" except it doesn't need an arg
17:45:22 <sethk> MarcWeber, I'm not clear on exactly what you are doing.  Give an example of one FFI function and how you want to be able to use it.
17:45:30 <elaforge> that will be basically "abort = MaybeT (return Nothing)"?
17:45:30 <roconnor> elaforge: one convient one would be fail
17:45:41 <roconnor> elaforge: correct
17:45:47 <Jedai> dons: create returning a Map of GettableSettable (like in OpenGL or other GUI libraries) ?
17:45:57 <elaforge> ok, so I'll try a fail impl in the monad instance for MaybeT
17:46:02 <MarcWeber> sethk: One example (he most important :) eval
17:46:04 <roconnor> elaforge: you should implement fail in your Monad instance for MaybeT m
17:46:19 <roconnor> elaforge: and then use fail in place of Nothing.
17:46:24 <sethk> MarcWeber, let me think about it for a few minutes
17:46:32 <MarcWeber> sethk: from C I'd like to call a :ghc command invoking a haskell function (is already working)
17:46:55 <sethk> MarcWeber, right, but the within vim part isn't there yet?
17:46:57 <MarcWeber> sethk: the haskell function should start a ghc(i) session (if not already started).. and run the command.
17:47:14 <sethk> MarcWeber, k
17:47:19 <MarcWeber> sethk: It is. At least :ghc some stuff is written to a temp test file by a .hsc fle
17:47:39 <MarcWeber> Instead of writing it to a file I need to pass it to the interpreter
17:47:39 <elaforge> roconnor: yay it works!
17:47:57 <elaforge> roconnor: thanks so much
17:48:01 <roconnor> np
17:48:11 <sethk> MarcWeber, ok.  I'll try to find some examples of similar things in other languages
17:48:24 <elaforge> roconnor: so in the bigger picture, I want something like a failing, logging, IO-doing monad
17:48:45 <elaforge> is the usual practice to type = up a big transformer stack and then define helper functions that do the lifting?
17:48:46 <MarcWeber> sethk: That's no big deal either. There are some examples on how to deal with the ghc api. But I don't know which is the way to expose some functions from vim (running the interpreter session) to the (sandboxed) intertreted session
17:48:46 <roconnor> sure, some combination of writerT and errorT and IO
17:48:54 <MarcWeber> sethk: Start at if_* ..
17:49:03 <roconnor> the order depends on if you want the log thrown out with the error or not.
17:49:10 <MarcWeber> (if_python if_ruby if_scheme etc) @ sethk
17:49:14 <elaforge> or is 'tell' overloaded so I don't have to lift?
17:49:20 <elaforge> oh right, hmm, interesting
17:49:40 <roconnor> yep, this overloading mechanism is really useful
17:49:47 <sethk> MarcWeber, ok.  I haven't looked at the details in quite a while, so I need to review a bit before I can say anything that might be genuinely helpful.
17:49:58 <elaforge> so would a I say "log msg = (lift.lift.lift) msg" depending on how deep the logging monad is?
17:50:16 <roconnor> no, you'd just say tell msg
17:50:28 <elaforge> hmm, and if I have more than one in there?
17:50:40 <MarcWeber> sethk: You don't know the details of vim. That's not important. Exposing some API to the interpreted session is. I'll try asking at #ghc..
17:50:50 <dozer> Writer [] will presumably get slow, since it adds things to the 'expensive' end of the list?
17:51:09 <sethk> MarcWeber, ok.  but that's just a matter of importing, no?
17:51:32 <roconnor> elaforge: well, tell will probably just use the outer most one.
17:51:43 <MarcWeber> sethk: Yes. but what? How can I link an imported module to the running process?
17:51:54 <roconnor> elaforge: with some fancy class stuff you can do things where it uses the type to select the correct layer.
17:52:21 <MarcWeber> Mmh I guess using FFI.. maybe there is an easier way
17:52:23 <elaforge> roconnor: hmm, I'll try writing my stack first, with explicit lifting for the two writers
17:52:24 <sethk> MarcWeber, Create a module with the needed symbols, and then import the module.
17:52:55 <elaforge> roconnor: another approach is to collapse everything into State, since you can technically log with that too, but it seems less compositional
17:53:01 <roconnor> elaforge: well, as long as you give your own primative their own names, then adjusting the code will be easy if you add more layers.
17:54:16 <elaforge> heh, Control.Monad.Writer has no haddock
17:54:34 <elaforge> guess I have to read that paper to know what anything does...
17:54:37 <roconnor> you want Control.Monad.Writer.Lazy
17:54:45 <roconnor> or Control.Monad.Writer.Class
17:54:54 <elaforge> yeah, that's where 'tell' is, but none of them have docs
17:55:04 <roconnor> ?
17:55:06 <roconnor> really?
17:55:38 <roconnor> elaforge: btw, in 2008 we are now using monadlib instead of the mtl.
17:55:50 <elaforge> nope: http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Writer.html
17:55:51 <lambdabot> http://tinyurl.com/2zuxtx
17:56:00 <elaforge> roconnor: what's the difference?
17:56:15 <elaforge> oh wait, these docs are for mtl...
17:56:39 <MarcWeber> sethk: This does mean you can't start another ghc sessioin within ghc?
17:56:52 <MarcWeber> I'll just try..
17:56:52 <roconnor> elaforge: monadlib fixes some strange things about the mtl.  For instance ContT Writer is an instance of Writer in monadlib.
17:57:07 <elaforge> http://www.galois.com/~diatchki/monadLib/ ?
17:57:08 <lambdabot> Title: monadLib
17:57:09 <sethk> MarcWeber, I'm not sure
17:58:44 <roconnor> *L* IdentityT
17:58:57 <elaforge> roconnor: and "we" is "general consensus in haskell land"?
17:59:06 <roconnor> for the much undervalued monadTransformerTransformer.
17:59:34 <roconnor> elaforge: I haven't taken a survey, but I'd use monadLib for any new project.
17:59:48 <roconnor> ... granted I've never used monadLib ...
18:00:01 <roconnor> elaforge: you can find out though. :D
18:01:36 <elaforge> heh, I just wouldn't want to get tangled up in some nonstandard alternate-prelude style ghetto...  it does look slightly more organized though
18:01:46 <elaforge> also with the almost nonexistent docs though
18:03:18 <elaforge> do you know of any example code out there that uses monadlib?
18:03:24 <dozer> "Care should be taken when using a list as the monoid for a Writer, as there may be a performance penalty associated with the mappend operation as the output grows. In that case, a data structure that supports fast append operations would be a more appropriate choice."
18:03:42 <roconnor> elaforge: nope.  I wonder if hackage can answer that question though.
18:03:47 <dozer> so ... this begs the question - what monoid is a good choice?
18:03:52 <elaforge> dozer: why not just prepend and then reverse when the monad is run?
18:04:05 <roconnor> dozer: I use Endo []
18:04:07 <elaforge> dozer: I sort of assumed writer already did that...
18:04:17 <roconnor> dozer: or I use ContT Writer []
18:04:48 <roconnor> dozer: although Dlist is Endo []
18:04:58 <roconnor> dozer: I assume DList is a monoid.
18:05:13 <dozer> roconnor: Endo is like applying flip to mappend?
18:05:27 <roconnor> dozer: not at all
18:05:30 <roconnor> @src Endo
18:05:30 <lambdabot> Source not found. My pet ferret can type better than you!
18:05:37 <roconnor> *sigh*
18:05:49 <roconnor> dozer: Endo a is a -> a
18:07:41 <kpreid> dozer: there's a newtype that *is* like applying flip to mappend, but I forget what it is
18:07:52 <kpreid> Dual?
18:08:44 <roconnor> dozer: the problem with mappend isn't the back to front order.
18:08:49 <dolio> @src Dual
18:08:49 <lambdabot> Source not found. Take a stress pill and think things over.
18:08:54 <roconnor> dozer: the problem is associating it correctly
18:09:06 <dolio> Yeah, it's Dual.
18:09:20 <roconnor> dozer: DList allows you to fully associate the ++ operation in the correct way.
18:09:47 <roconnor> dozer: ContT fully associates the bind operation in the correct way, which will force the ++ to be associated in the same way.
18:10:04 <elaforge> as an aside, I did read the "springschool" paper, and it introduced transformers with a whole new set of classes I've never seen before
18:10:23 <dozer> roconnor: ok - I think I'm lost - need stuff to read
18:10:25 <roconnor> elaforge: link?
18:10:25 <elaforge> and the "Writer" monad in that paper looks different from the one in the std lib
18:10:35 <elaforge> http://web.cecs.pdx.edu/~mpj/pubs/springschool.html
18:10:36 <lambdabot> Title: Functional Programming with Overloading and Higher-Order Polymorphism
18:10:43 <roconnor> dozer: a ++ (b ++ ( c++ d)) is good
18:10:55 <roconnor> dozer: ((a ++ b) ++ c) ++ d is bad
18:10:59 <dozer> ah, ok
18:11:14 <dozer> and Endo [] does the former?
18:11:25 <elaforge> all the monad libs have a pointer to that, in lieu of documentation
18:11:42 <roconnor> dozer: effectively yes.
18:11:55 <roconnor> dozer: the problem with writer []
18:12:18 <roconnor> is that the ++ 's follow the associativity of the bind operations
18:12:34 <dozer> k, so for now, without needing to understand it deeply, I use Writer (Endo []), treat the accumulator as a list (modulo de-endoing it) and pray to the gods of blissfull ignorance?
18:12:53 <roconnor> so if you (do a <- foo; b <- bar), and foo writes a and b, and bar writes c and d
18:13:04 <roconnor> then you get ((a ++ b) ++ (c ++ d))
18:13:10 <roconnor> which isn't optimal.
18:13:31 <joricj> oh god no, all this time i was working under the assumption that one can compare two 'Chan's for equality
18:13:32 <roconnor> dozer: using Writer DList is probably slightly better
18:13:41 <joricj> and now i find out that isn't so
18:13:50 <joricj> say it ain't true !
18:14:07 <roconnor> dozer: but Writer (Endo []) and Writer DList have identical representations.
18:14:17 <roconnor> dozer: but DList will probably give you nicer functions.
18:14:45 <sethk> joricj, you can create an instance of Eq for Chan
18:14:51 <elaforge> what is DList?
18:14:59 <dolio> joricj: You'll probably have to generate unique identifiers and bundle them with the chan.
18:15:06 <roconnor> elaforge: difference lists
18:15:10 <joricj> oh noes
18:15:23 <elaforge> I see, alternate list impl with different efficiency?
18:15:32 <roconnor> elaforge: wher "string" is represented as the function ("string"++)
18:15:51 <elaforge> oh, like shows or whatever its called
18:15:55 <roconnor> elaforge: it has fast append.
18:16:02 <joricj> is there a (destructive) way to create a unique identifier in the IO monad?
18:16:06 <roconnor> elaforge: exactly like shows
18:16:09 <dancor> how do i tell cabal to do -lunit in the linking
18:16:11 <dozer> roconnor: ok - hoogle has told me where to get dlist from - will grab and build
18:16:19 <dancor> for ffi
18:16:44 <sethk> joricj, use a timestamp
18:17:00 <dolio> joricj: Make an IORef starting at 0, and increment every time you take an identifier.
18:17:07 <roconnor> joricj: does it have to be threadsafe?
18:17:17 <joricj> roconnor: yes, i have a looot of threads
18:17:28 <glguy> ?seen dons
18:17:28 <lambdabot> dons is in #haskell, #xmonad and #haskell-soc. I last heard dons speak 35m 10s ago.
18:18:02 <joricj> i am using actors, and i was using something like data Inbox = Inbox (Chan (Inbox, Message))
18:18:21 <elaforge> joricj: use a TVar with a counter?
18:18:35 <dons> glguy: ?
18:18:49 <dolio> I suppose it could be an MVar instead of an IORef if you need to generate unique ids in multiple threads.
18:19:29 <joricj> damn this really bit me in the ass
18:26:37 <joricj> i pasted my code here, can someone recommend a strategy? (runActor is called from many diffrent threads) http://hpaste.org/6580
18:30:17 <elaforge> joricj: I annotated it
18:33:02 <joricj> how do global variables work in haskell? it seems to me if you do "foo = newTVarIO 0" it will create a diffrent TVar every time. what does unsafePerformIO do?
18:33:20 <elaforge> makes a global variable :)
18:33:36 <dons> joricj: it memoises the result, so the action is only computed once
18:33:45 <dons> joricj: otherwise, yes, newTVAr will just return a new one each time
18:33:49 <joricj> ah ok
18:34:02 <elaforge> it sucks, but it's the only way I know of to make a mutable global like that
18:34:16 <joricj> well yeah, i figured you'd need some dark magic for it
18:35:39 <dons> mutable globals are pretty nasty though
18:35:49 <dozer> ?pl \a b -> length b
18:35:50 <lambdabot> const length
18:37:44 <joricj> @hoogle unsafePerformIO
18:37:45 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
18:37:45 <lambdabot> System.IO.Unsafe.unsafePerformIO :: IO a -> a
18:38:50 <joricj> @hoogle newTVarIO
18:38:50 <lambdabot> GHC.Conc.newTVarIO :: a -> IO (TVar a)
18:40:21 <joricj> @hoogle attomically
18:40:21 <lambdabot> No matches found
18:40:25 <joricj> @hoogle atomically
18:40:25 <lambdabot> GHC.Conc.atomically :: STM a -> IO a
18:40:25 <lambdabot> Control.Exception.NestedAtomically :: Exception
18:41:27 * dolio has annotated, as well.
18:45:09 <joricj> elaforge: okay i got it to work :D
18:47:13 <joricj> dolio: wooow
18:47:27 <joricj> that looks complicated :D
18:48:24 <joricj> i just thought of another solution: have a thread which listens to a Chan of samplevars and have the thread write out the id's to the sample var
18:48:52 <dons> matthew-_: are we going to see examples of how to use the sessions library? or is it a thesis project?
18:51:42 <dons> nice http://reddit.com/info/6d4jf/comments/
18:51:51 <dons> "Using OpenGL to visualize congestion in convex routing (in Haskell)"
18:51:54 <dolio> It isn't that much more complicated.
18:52:15 <dolio> Except you have to sprinkle liftIO all over the place, because IO stuff isn't sufficiently general by default.
19:06:29 <Saizan> @seen duncan
19:06:30 <lambdabot> I saw duncan leaving #haskell-overflow, #haskell and #gentoo-haskell 1h 40m 16s ago, and .
19:06:45 <Saizan> @seen dcoutts_
19:06:45 <lambdabot> dcoutts_ is in #gentoo-haskell, #haskell, #haskell-overflow, #haskell-soc and #ghc. I last heard dcoutts_ speak 2d 8h 13m 17s ago.
19:09:05 <svahn> :r
19:09:15 <svahn> Haha
19:09:21 <svahn> Too many tabs open
19:18:30 <dozer> bubbleWriter :: (Monad m, RandomGen g) => RandT g (WriterT w m) a -> RandT g m (a,w)
19:20:05 <dozer> mm
19:21:31 <Saizan> oprationally id?
19:25:49 <joricj> @hoogle Handle
19:25:49 <lambdabot> System.IO.Handle :: data Handle
19:25:49 <lambdabot> Control.Exception.handle :: (Exception -> IO a) -> IO a -> IO a
19:25:49 <lambdabot> System.IO.HandlePosn :: data HandlePosn
19:44:42 <mm_freak>     Could not find module `Graphics.UI.SDL.General':
19:44:42 <mm_freak>       it is a member of package SDL-0.4.0, which is hidden
19:44:44 <mm_freak> mh?!
19:45:17 <TomMD> mm_freak: You know how to edit the .cabal to fix that, right?
19:45:33 <mm_freak> i don't know, what's missing there
19:45:39 <mm_freak> Other-modules ?
19:45:53 <mm_freak> Build-depends ?
19:45:56 <TomMD> if you edit the .cabal file and add "SDL" under "build-depends:   "
19:46:04 <TomMD> then it should be ok.
19:46:24 <mm_freak> ok, thanks…  looks like i've never needed any non-base package =)
19:53:53 <Cale> @go electron volts per second in horsepower
19:53:53 <lambdabot> 1 horsepower = 4.65429301 x 10^21 electron volt per second
19:55:46 <elaforge> roconnor, yay it works.  thanks again for your help
19:56:06 <elaforge> fwiw I'm using StateT and modify (x:) instead of Writer
19:56:55 <elaforge> and mtl instead of monadlib...  I'll check out monadlib when I'm in a mood to prettify and not just get things done quickly
20:02:35 <roconnor> elaforge: why StateT?
20:03:17 <elaforge> seemed simpler than downloading DList and figuring out how to use it, and then wrapping all 'tell' msgs with :[]
20:04:05 <elaforge> I did find some documentation for Writer though
20:04:18 <roconnor> Writer isn't too complicated
20:04:22 <roconnor> you use tell
20:04:36 <roconnor> and runWriter returns a the list of what was told
20:04:47 <elaforge> right, but then I run into mappend inefficiency, as you were saying earlier
20:04:56 <roconnor> ah, fair point
20:05:09 <roconnor> or premature optimization
20:05:14 <roconnor> not sure which.
20:05:23 <elaforge> since I always write one at a time anyway, prepending to the list instead seemed simpler
20:05:33 <roconnor> ok
20:05:39 <elaforge> yeah, could be, I don't think I'll log tons of things anyway
20:06:21 <elaforge> hmm, the other thing is I'm logging msgs that should go out soon, so latency is an issue
20:06:43 <elaforge> clearly if it were a big issue I wouldn't be using haskell for it though :)
20:10:32 <roconnor> logging messages should go out soon?
20:10:50 <roconnor> like written to a handle?
20:11:04 <elaforge> yep
20:11:21 <elaforge> well, going out a midi port
20:12:30 <roconnor> You want this writing to be interleaved with other IO actions?
20:13:27 <elaforge> I was planning on waiting until the end of monad when it gets run, but actually, if things are lazy enough, I should be able to start reading from the list before the monad finishes, right?
20:13:54 <misterPhyrePhox> hi
20:13:56 <elaforge> then I could use the log msgs for status on the computation as it runs...
20:13:58 <roconnor> um, you can do stuff like that if you are careful.
20:14:18 <elaforge> does that mean it works unless you do something that destroys it?
20:14:45 <roconnor> it works until you try to read something from the list that depends on an IO action that hasn't happend yet.
20:14:53 <misterPhyrePhox> why doesn't this work: type Id a = a; type App f = f (); x = undefined :: App Id ?
20:15:02 <elaforge> but then you just block until the something does happen, right?
20:15:28 <thoughtpolice> misterPhyrePhox: because you have 'App Id' instead of 'App (Id <something)'
20:15:42 <roconnor> elaforge: you either crash or hang forever.
20:15:45 <misterPhyrePhox> but shouldn't App act like a higher order type?
20:15:47 <elaforge> I mean I've vaguely heard that haskell threads wait for thunks to get evaluated
20:15:48 <elaforge> ow
20:15:50 <misterPhyrePhox> (if that's a word)
20:16:10 <misterPhyrePhox> as in it takes the type constructor Id as a parameter (of kind (* -> *)) and applies it to ()
20:16:16 <roconnor> well, the needed IO action may end up waiting for the writing to be done before it is executed.
20:17:05 <elaforge> yeah, I guess it could.  though if I'm just sending the data out I'd think that wouldn't happen
20:17:38 <thoughtpolice> misterPhyrePhox: 'Id a' is just a synonym for 'a' from your type declaration
20:17:42 <mauke> hmm, it works with -fglasgow-exts
20:18:03 <elaforge> it does seem sketchy though... like I'm trying to slip in a unsafeInterleaveIO without actually calling that
20:18:21 <thoughtpolice> so it's not really a constructor, it doesn't really even exist as far as the compiler is concerned, you can use the two interchangeably
20:18:39 <misterPhyrePhox> ahh, i see; when i convert it to use data declarations it works fine
20:18:39 <elaforge> well, if it does horrible things I can just write to Chan like normal people
20:18:50 <thoughtpolice> misterPhyrePhox: yeah, you can also probably use newtypes
20:19:12 <misterPhyrePhox> what are newtypes?
20:19:18 <misterPhyrePhox> i never figured out why you would use them instead of data or type
20:19:42 <elaforge> they're slightly more efficient, and stricter
20:19:49 <thoughtpolice> misterPhyrePhox: they are single constructor data declarations, basically. you can do 'newtype N a = N a' basically. they are there to enforce a little more type correctness, and they are also optimized away at compile time
20:20:43 <misterPhyrePhox> thoughtpolice, ahh, i see
20:20:56 <thoughtpolice> for example if you have a function plot of type 'Int -> Int -> Graph -> Graph' and the first two parameters are x and y coordinates, you could enforce that you don't ever swap them around by having two newtype's, X and Y. they are both optimized away, but you can ensure you never mix the two up
20:21:23 <thoughtpolice> and then plot would just have to pattern match, i.e. plot (X x) (Y y) g1 = ...
20:21:36 <thoughtpolice> (you could just have a function mkX :: Int -> X essentially)
20:21:43 <ddarius> To answer your earlier question, if partial application of type synonyms were allowed (in general), you would be able to perform arbitrary computation at the type level at compile-time and in particular, non-terminating computations.
20:22:48 <thoughtpolice> misterPhyrePhox: normally I use them just to create a monad from a transformer, and use newtype deriving to automatically derive instances for Monad or MonadIO or something
20:23:20 <misterPhyrePhox> well now you've gone over my head :)
20:23:24 <misterPhyrePhox> thanks for your help!
20:23:37 <thoughtpolice> i.e. newtype FakeMonad a = Fake { unF :: StateT Int IO a }
20:23:52 <elaforge> thoughtpolice, oh is that a way to collapse a transformer stack?
20:24:09 <elaforge> thoughtpolice, i.e. I'm justing doing "type SomethingM = ThisT ThatT etc."
20:24:59 <thoughtpolice> elaforge: it's an idiom I got from Cale's guide on how to use transformers; it works pretty well and lets you control exactly what operations the functions inside the monad can do.
20:25:07 <thoughtpolice> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
20:25:10 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
20:25:19 <elaforge> cool, thanks, will take a look
20:25:25 <elaforge> today is the day of monad transformers
20:25:40 <thoughtpolice> I used that as my primary reference for 'getting' monad transformers. Cale++
20:25:54 <thoughtpolice> (well, partly. moreso to construct them properly I guess)
20:26:09 <elaforge> "getting" has been my primary activity today
20:26:36 <Cale> :)
20:28:06 <elaforge> my next challenge will be letting callers extend the monad with some of their own state
20:28:42 <Cale> You can use an extra type parameter for that.
20:29:31 <elaforge> FancyMonad user_state = ThisT ThatT (StateT user_state) etc.?
20:29:48 <solrize_> > (const 3) (print "foo")
20:29:51 <lambdabot>  3
20:31:38 <Cale> elaforge: yeah, something like that
20:31:57 <elaforge> Cale, thanks I'll give it a try when I get there
21:05:26 <glguy> ?seen dons
21:05:26 <lambdabot> dons is in #haskell, #xmonad and #haskell-soc. I last heard dons speak 1h 18m 5s ago.
21:14:53 <jcreigh> hi, I'm having some trouble installing hpodder 1.1.2 on debian testing (lenny) with GHC 6.6. It requires (among others) "old-time", "directory", "process". Looking on Hackage, I suspect that those packages are due to some sort of reorganization in 6.8. Is this right?
21:15:09 <allbery_b> yes
21:15:27 <allbery_b> I think all of those are in base in 6.6
21:16:14 <jcreigh> I figured as much. I took them out of the .cabal to try to get hpodder to build and it fails with Could not find module `Data.String'
21:16:24 <jcreigh> (Which I think is supposed to be part of MissingH?)
21:17:18 <jcreigh> I have MissingH 1.0.0 installed.
21:18:37 <jcreigh> but the feeling I get is that I'm just being foolish from thinking this is going to work with 6.6.
21:24:03 <allbery_b> mmm, if it wants that then it wants bytestrings.  which exist for 6.6, but class IsString also goes with 6.8's overloaded strings support.  I suspect you are doomed
21:24:10 <jcreigh> haha
21:24:18 <jcreigh> thanks for your honesty. :)
21:26:06 <allbery_b> (Data.String only contains the defintion of class IsString.  and AFAIK that class exists only for overloaded strings, so that a string literal can be a bytestring literal.  this is a 6.8 feature, 6.6 doesn't support it)
21:31:44 <jcreigh> hmm. GHC 6.8 is in debian unstable.
21:32:16 <jcreigh> *and* the version of hpodder I want. I shouldn't be tempted to try this...
21:38:26 <diptansu> I am trying to compile haskellDB and I keep getting an error with these lines: setField :: SetField f r a => l f a -> a -> r -> r
21:38:26 <diptansu> setField (x::l f a) = setField_ (undefined::f)
21:38:52 <diptansu>     Not in scope: type variable `l'
21:39:12 <diptansu> can some one help me with this error?
21:48:55 <Cale> diptansu: hmm... are pattern signatures turned on?
21:49:35 <Cale> diptansu: actually, with that explicit type signature, it doesn't look from that code that the pattern signature is required there
21:49:49 <Cale> hmm
21:50:35 <Cale> Seems a little odd to use a completely polymorphic type constructor like that.
21:58:30 <jcreigh> muhahaha! It's building!
22:08:44 <wy> anyone read "The Seasoned Schemer"?
22:09:26 <glguy> yup
22:09:34 <wy> It looks quite hard
22:09:34 <glguy> I've got 3 of the schemer books on my bookshelf :)
22:09:54 <dons> Cale: you need to help vagif, he's making a scene. http://reddit.com/r/programming/info/6d4ze/comments
22:10:04 <dons> all week he's been complaining about CGIT (I think)
22:10:16 <wy> glguy: Have you figured out what's the transformation in the first chapter?
22:10:24 <diptansu> Cale: Its from a file in haskellDB
22:10:42 <dons> Cale: but i'm inclined to help vagif offline
22:11:04 <Cale> dons: Does he live near you?
22:12:10 <dons> i don't know. i only know he's an occasional #xmonad-er, and pretty active on reddit
22:12:31 <Cale> ah, so you mean offline in the sense of 'on irc'?
22:12:32 <glguy> wy, let me grab the book from my shelf... I don't remember
22:12:39 <dons> Cale, yeah :)
22:12:46 <dons> not in a reddit thread
22:12:54 <wy> That two-in-a-row? thing
22:13:01 * dons though irc was offline
22:16:02 <wy> glguy: It looks like some kind of manual partial evaluation
22:16:03 <glguy> > let two-in-a-row [] = False; two-in-a-row (x:xs) = two-in-a-row-b x xs; two-in-a-row-b x [] = False; two-in-a-row-b x (y:ys) | x == y = True | otherwise = two-in-a-row-b y ys in two-in-a-row [1,2,3,4,4,5,6]
22:16:04 <lambdabot>  Parse error at "in-a-..." (column 9)
22:16:07 <glguy> oh, heh
22:16:14 <glguy> that's a lot of -'s to fix
22:16:27 <elliottt> sed to the rescue? :)
22:18:08 <allbery_b> tr - _
22:18:11 <allbery_b> :)
22:18:13 <elliottt> oooh
22:18:23 <glguy> 8-o
22:20:49 <wy> I thought I already know scheme...
22:22:30 <mofmo1> so i have a state monad running with an io monad. I want to pass on the state of a bunch of functions, a counter variable and a list
22:22:47 <mofmo1> i put it into a 3-tuple but i dont how to do the accessors for it
22:22:59 <mofmo1> without pattern matching etc
22:23:08 <mofmo1> i guess i could just write a function
22:23:08 <bd_> mofmo1: it's easier to define a data type for your state
22:23:20 <Cale> > let twoInARow xs = not . null $ [() | (_:_:_) <- group xs]  in twoInARow [1,2,3,3,4,5]
22:23:23 <lambdabot>  True
22:23:24 <bd_> data MyState = MyState { foo :: Bar -> Baz, ... }
22:23:24 <mofmo1> how would it work with modify or put?
22:23:26 <Cale> > let twoInARow xs = not . null $ [() | (_:_:_) <- group xs]  in twoInARow [1,2,3,4,5]
22:23:27 <lambdabot>  False
22:23:28 <bd_> then things like
22:23:32 <bd_>   myfoo <- gets foo
22:23:32 <Cale> > let twoInARow xs = not . null $ [() | (_:_:_) <- group xs]  in twoInARow [1,1..]
22:23:32 <lambdabot>  True
22:23:40 <bd_>   modify $ \s -> s { foo = ... }
22:24:15 <shachaf> glguy: Are there more than 3?
22:25:09 <jaj> diptansu: you need to add ghc extensions to haskelldb.cabal
22:25:27 <jaj> -glasgow-ext or something
22:26:01 <dons> roconnor: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/control-timeout
22:26:04 <lambdabot> http://tinyurl.com/3exw2s
22:26:15 <mofmo1> so you could define gets foo as gets a = case a of {foo x -> x; etc}
22:26:16 <wy> :t group
22:26:17 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
22:26:26 <glguy> wy: i don't know if it is so much manual partial evaluation
22:26:34 <glguy> as keeping an accumulator
22:26:41 <roconnor> dons: hmm
22:26:54 <glguy> it's basically a left fold
22:27:00 <glguy> shachaf: more than three?
22:27:01 <jaj> diptansu: -fglasgow-exts
22:27:05 <wy> The accumulator is easy, but he got it in a strange way
22:27:08 <shachaf> glguy: Schemer books, I mean.
22:27:12 <roconnor> dons: I'm not certain that is the same as a network timeout
22:27:16 <dons> roconnor: agl is using it for network stuff (see his other suite of network libraries)
22:27:17 <bd_> mofmo1: no, gets is a builtin
22:27:20 <wkh> simon peyton-jones sounds like the roman guy in Life of Brian whose friend is biggus dickus
22:27:22 <wkh> http://blip.tv/file/324976
22:27:23 <lambdabot> Title: OSCON 2007 - Simon Peyton-Jones - A Taste of Haskell Part I
22:27:26 <bd_> gets f = do { s <- get; return (f s) }
22:27:27 <roconnor> dons: what is agl?
22:27:30 <glguy> shachaf: I don't know if there are, but I figured if I said "I have all three" that someone would tell me I was wrong ;)
22:27:33 <dons> agl is adam langley
22:27:38 <dons> author of the network-* libs on hackage
22:27:43 <roconnor> oh
22:27:47 <wkh> i would give anything to hear him say "do you find it funny when i say the name... catamorphism?"
22:28:11 <mofmo1> bd_: wait, what if i want to extract a specific part of the state?
22:28:27 <bd_> mofmo1: that's what gets does. You pass in a function which pulls out whatever part of the state you want.
22:28:31 <EvilTerran> wkh, do you mean he sounds, er, like an englishman?
22:28:35 <mofmo1> oh right
22:28:35 <mofmo1> sorry
22:28:39 <dons> roconnor: e.g. in network-dns, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/network-dns
22:28:42 <lambdabot> http://tinyurl.com/3dnyx7
22:28:44 <EvilTerran> ;)
22:30:10 <bd_> mofmo1: for an example, take a look at http://repo.or.cz/w/kaos.git?a=blob;f=src/Kaos/CoreFold.hs;hb=HEAD - getSM, modifySM, putSM
22:30:14 <lambdabot> Title: Public Git Hosting - kaos.git/blob - src/Kaos/CoreFold.hs, http://tinyurl.com/2k8dt7
22:30:55 <dons> Cale, do you also think monad transformers occur when building interactive apps (not just libraries)
22:31:31 <Cale> dons: Monad transformers are something I think the use of which should always be hidden by a module boundary.
22:32:29 <Cale> You use them to get the monad you're interested in, or something which is close to it, then you implement the primitives in that monad using lifts and the newtype constructor, and then you promptly forget that monad transformers ever existed.
22:32:43 <dons> yep, that's reasonable
22:32:47 <roconnor> dons: Does the SO_SNDTIMO and SO_RCVTIMEO do essientially the same thing that this timeout library provides?
22:33:00 <dons> roconnor: no idea. talk to agl about it, he's also on the cafe@
22:34:23 <glguy> ?src minimum
22:34:23 <lambdabot> minimum [] = undefined
22:34:23 <lambdabot> minimum xs = foldl1 min xs
22:35:59 <wkh> what's the difference between subtract and (-)
22:36:07 <solrize_> @src (-)
22:36:07 <lambdabot> x - y = x + negate y
22:36:14 <solrize_> @src subtract
22:36:14 <lambdabot> subtract x y = y - x
22:36:20 <solrize_> @src negate
22:36:20 <lambdabot> negate x = 0 - x
22:36:39 <roconnor> \check \ x y -> (-) x y == subtract x y
22:36:43 <roconnor> @check \ x y -> (-) x y == subtract x y
22:36:47 <lambdabot>  Falsifiable, after 0 tests: -3, -1
22:36:55 <roconnor> @check \ x y -> (-) x y == subtract y x
22:36:56 <lambdabot>  OK, passed 500 tests.
22:37:05 <EvilTerran> wkh, subtract and negate are saner to use than sections of (-) or whatever
22:40:04 <lispy> :t negate
22:40:09 <lispy> :t 0
22:40:11 <lambdabot> forall t. (Num t) => t
22:40:11 <lambdabot> forall a. (Num a) => a -> a
22:41:54 <lispy> ?let positate x = 0 + x
22:41:54 <lambdabot> Defined.
22:42:05 <lispy> now negate has a friend
22:43:11 <cjs> I guess it's a few more hours before I can expect to see folks on #ghc?
22:44:01 <lispy> ?pl flip (-)
22:44:01 <lambdabot> subtract
22:44:18 <lispy> I never really tohught about that before, that subtract needs to flip the arguments
22:44:37 <glguy> in case it hasn't been made clear so far... subtract exists so you can write:  (subtract 5)
22:44:47 * lispy nods
22:44:48 <glguy> instead of: (+(-5))
22:44:59 <lispy> it just never occured to me that you need to flip it
22:45:54 <lispy> because if you used it like, x `subtract` y, you probably would think it's sully
22:45:57 <lispy> er silly
22:46:02 <lispy> > 1 `subtract` 3
22:46:03 <lambdabot>  2
22:46:13 <shachaf> @let subtractedFrom = subtract
22:46:18 <lambdabot> Defined.
22:46:29 <EvilTerran> cjs, quite possibly, seeing as it's 5.45am in the UK, and i think the americans are starting to go to bed at this hour too
22:46:55 <lispy> EvilTerran: the west coast americans yeah, the other ones should be in bed already :)
22:47:30 <EvilTerran> yeah, you know it's late when people six timezones after you start going to bed :P
22:47:47 <solrize_> zzz
22:48:16 <solrize_> something wrong with (-5) ?
22:48:19 <solrize_> (-5) 2
22:48:25 <solrize_> > (-5) 2
22:48:25 <lambdabot>   add an instance declaration for (Num (t -> a))
22:48:30 <solrize_> bah
22:48:43 <solrize_> > (- 5) 2
22:48:43 <lambdabot>   add an instance declaration for (Num (t -> a))
22:48:53 <lispy> > (2-) 5
22:48:53 <lambdabot>  -3
22:48:53 <solrize_> ok ok
22:49:08 <solrize_> ((-) 5) 2
22:49:18 <solrize_> > ((-) 5) 2
22:49:19 <lambdabot>  3
22:49:21 <solrize_> there
22:49:31 <solrize_> > (subtract 2) 5
22:49:32 <lambdabot>  3
22:49:35 <lispy> > (flip (-) 5) 2
22:49:36 <lambdabot>  -3
22:50:03 <lispy> > (flip(-)5)2 -- let's just mash it all together
22:50:04 <lambdabot>  -3
22:50:18 <wkh> what's the difference between type, newtype, and data?
22:50:41 <lispy> wkh: type is quite different from the other two, but the other two are fairly similar
22:50:49 <lispy> wkh: do you know C+
22:50:51 <lispy> er C?
22:51:13 <wkh> yeah, well enough. is there some comparison to typedefs here?
22:51:23 <shachaf> wkh: Yes, type is like typedef.
22:51:27 <glguy> type is like typedef
22:51:28 <wkh> yeah, got that
22:51:29 <lispy> yes, type and typedef are basically the same.  They created a named alias to another type
22:51:49 <lispy> wkh: newtype gives an existing type a new identity
22:51:59 <glguy> (and compiles away)
22:52:06 <Cale> (which is treated as a completely separate type in the type system)
22:52:28 <Cale> So for instance, if you have  newtype Dollars = D Integer
22:52:28 <wkh> why would you want to give an existing type a new identity?
22:52:35 <wkh> oh, yeah
22:52:37 <bd_> newtype is mostly useful when you don't want the old type's instances (or the implementation detail of what the type is) leaking out - but don't want the extra overhead data would add
22:52:45 <wkh> oh, i see
22:52:48 <Cale> Then the typesystem will prevent you from getting dollar amounts mixed up with other integers.
22:52:53 <lispy> wkh: suppose you wanted to create a type for natural numbers.  It's like integers, but no negatives.
22:52:59 <shachaf> bd_: It's useful for more than that.
22:52:59 <bd_> newtype MyMonadT m a = MMT (StateT Foo (ReaderT Bar m) a) deriving (Monad)
22:53:08 <bd_> shachaf: it's what I mostly use it for anyway :)
22:53:19 <bd_> (note, above requires generalized newtype deriving extension)
22:53:27 <Cale> Oh, and there's newtype deriving in GHC, which is an advantage over data.
22:53:39 <lispy> wkh: and you already know data, right?
22:53:42 <Cale> (also the semantics are slightly different)
22:53:51 <wkh> dta is the general type declaration mechanism, i suppose
22:54:33 <lispy> data lets you compose types in a way that allows the creation of data structures and other values
22:55:02 * lispy wonders if saying that way just confuses things
22:55:27 <Cale> wkh: yeah
22:56:24 <Cale> Basically the types composed using data are formed as what might be called a "sum of products". You have a bunch of different possible data constructors for your new datatype, and each of them has its own bunch of fields.
22:56:45 <Cale> and they can be recursive
22:57:04 <Cale> data List a = Nil | Cons a (List a)
22:57:26 <lispy> wkh: usually as a beginner you don't need any of them except data.  Then, you might find at some point it's unweildly to type out a type, or you keep changing the implementation data type but the interface stays.  In both those cases you reach for 'type'.
22:57:39 <Cale> "A list of values of type a is either the value Nil, or it is Cons x xs, where x is of type a, and xs is of type List a"
22:58:36 <cjs> type is also handy for aliases for function signatures.
22:58:53 <cjs> type Parser = a -> (a -> b) -> b
22:59:06 <wli> data List t = Nil | Cons { head :: t, tail :: List t } ?
22:59:06 <bd_> type LexicalContext = String -> Maybe Variable
22:59:17 <cjs> Oh, wait, that's not the definition, but you get the idea.
22:59:50 <Cale> cjs: you'd need Parser a b at least :)
23:01:01 <cjs> type Parser a -> String -> [(a, String)]
23:01:47 <cjs> (For some reason my brain was urging me towards the type of >>=.)
23:02:22 <cjs> (>>=) :: Parser a -> (a -> Parser b) -> Parser b
23:05:06 <solrize_> wheee
23:05:09 <solrize_> whoops sorry
23:22:59 <cjs> Grr. My ghc quick build can't find gmp.h.
23:24:27 <lukea_> hopefully an obvious question here, I'm trying to use the parsec library in GHC, and it's stopped linking in libHSparsec.a ( source code & error: http://hpaste.org/6582#a1)
23:24:57 <lukea_> strange thing is, It *was* working, and I dont remember changing anything
23:25:14 <lukea_> anyone got any ideas?
23:25:59 <cjs> Run file on that library. Perhaps something corrupted or emptied it.
23:27:28 <koninkje> :t until
23:27:31 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
23:28:39 <lukea_> the file command reports: "current ar archive".
23:29:43 <lukea_> I've tried re-extracting ghc from the binary tarball I originally installed from, but the error persists
23:37:26 <koninkje> @pl \f m -> map (\(k,x)-> (k,f x)) (assocs m)
23:37:26 <lambdabot> (. assocs) . map . (`ap` snd) . (. fst) . flip ((.) . (,))
23:39:37 <koninkje> @pl (\(k,x) m-> insert k x m)
23:39:37 <lambdabot> uncurry insert
