00:00:33 <cads> http://www.standardpascal.org/The_Programming_Language_Pascal_1973.pdf
00:00:46 <lambdabot> Title: cache:http://www.standardpascal.org/The_Programming_Language_Pascal_1973.pdf - G ..., http://tinyurl.com/4xstau
00:01:08 <cads> go fig, Wirth is the author
00:05:54 <chrisdone> pingo
00:10:40 <olsner> oh, P-code? even I've heard of that!
00:20:20 <mib_lz30tuzr> > 1+1
00:20:21 <lambdabot>   2
00:21:55 <yewT> [ [1,2,3] , [] , [7,8,9] ] vs [ [1,2,3] , [4,5,6] , [7,8,9] ]
00:22:40 <yewT> [ [1] , [] , [9] ] vs [ [1,2,3] , [4,5,6] , [7,8,9] ]
00:23:05 <yewT> how do i clear the 2nd list's item if the first list is empty?
00:23:31 <yewT> so it would become this >>> [ [1,2,3] , [7,8,9] ]
00:23:33 <niklaus>  dmwit i tried writing recursion but it is very slow for 15 digit and 20 digit numbers and beyond
00:24:53 <yewT> anyone?
00:26:17 <luqui> yewT, what are you asking?
00:26:24 <luqui> oh I see it now
00:26:52 <Vq^> > map snd . filter (not . null . fst) . zip  [ [1] , [] , [9] ] $ [ [1,2,3] , [4,5,6] , [7,8,9] ]
00:26:53 <lambdabot>   [[1,2,3],[7,8,9]]
00:27:08 <Vq^> maybe there is a better way :/
00:27:23 <yewT> umm.. that way only works with snd right?
00:28:29 <yewT> because... what if its [ [a] , [] , [c],[],[] ] vs [ [a,a,a] , [b,b,b] , [c,c,c], , [d,d,d] , [e,e,e] ] >> [ [a,a,a] , [c,c,c]]
00:28:44 <luqui> yewT, okay, so let's start a little simpler
00:29:16 * yewT wonders*
00:29:19 <luqui> how would you pair up corresponding elements in the first and second lists so you can operate on them
00:29:41 <yewT> pair them up as a tuple?
00:29:52 <yewT> or pair them up as a list?
00:30:04 <yewT> tuple would be zip?
00:30:12 <luqui> well, there's only going to be two of them so list seems overkill
00:30:28 <luqui> sure, start by zipping them.
00:30:31 <yewT> list seems overkill means?
00:30:39 <yewT> ok i'll zip them
00:30:56 <luqui> and then do something to that to see if the first one is empty
00:31:21 <yewT> ok
00:31:43 <yewT> it would be empty
00:32:10 <luqui> hmm?
00:32:20 <hackage> Uploaded to hackage: panda 2008.10.17
00:32:20 <hackage> Uploaded to hackage: data-memocombinators 0.2
00:33:03 <yewT> luqui http://hpaste.org/11138
00:33:58 <luqui> yewT, okay good.   now how do see if something has an empty first element?
00:34:06 <yewT> > zip [[],[1,1]] [[2,2],[3,3]]
00:34:07 <lambdabot>   [([],[2,2]),([1,1],[3,3])]
00:34:13 <yewT> yeah
00:35:21 <yewT> so... ?
00:36:03 <luqui> i.e.   I give you x = ([], [1,1]).  I want False if the first element is empty, True if it's not.  (that is, here it would be False)
00:36:52 * Badger laughed upon seeing "Maybe"
00:37:19 <luqui> Badger, yeah, it's quaint.  Much cuter than "Nullable" :-)
00:37:24 <Baughn> luqui: So that's not . null . fst, then.
00:37:42 <luqui> Baughn, right.  helping yewT.
00:37:56 <Baughn> ..right.
00:37:59 <luqui> I have to go.  take over?
00:38:06 <luqui> =P
00:38:08 <Baughn> Sorry, I was just about to leave myself
00:38:45 <yewT> ok
00:38:45 <yewT> oh no
00:38:54 <yewT> luqui and baughn leaving?
00:39:03 <yewT> who should i seek help?
00:39:27 <cjs> I might be able to help a bit.
00:39:36 <yewT> hmm [] = null?
00:39:43 <sjanssen> @type null
00:39:45 <lambdabot> forall a. [a] -> Bool
00:39:58 <yewT> ok
00:40:02 <sjanssen> yewT: null is the function that returns True if the given list is []
00:40:12 <sjanssen> @src null
00:40:12 <lambdabot> null []     = True
00:40:12 <lambdabot> null (_:_)  = False
00:40:13 <yewT> oh
00:40:42 <yewT> so... if a /= null then add into a new list?
00:41:06 <yewT> hmm
00:41:18 <sjanssen> no
00:41:23 <sjanssen> > null [1]
00:41:24 <lambdabot>   False
00:41:26 <sjanssen> > null []
00:41:27 <lambdabot>   True
00:42:00 <yewT> no?
00:42:06 <Baughn> > (not.null) []
00:42:07 <lambdabot>   False
00:42:22 <Baughn> > iterate not (null [])
00:42:23 <lambdabot>   [True,False,True,False,True,False,True,False,True,False,True,False,True,Fal...
00:42:25 <sjanssen> about the "a /= null" part, because you can't use /= on null, since null is a function
00:43:09 <yewT> how do i extract 1 [String] from [[String]] and 1 [String] from anotehr [[STring]] and later compare them using the null
00:43:22 <yewT> map only able to take in 1 [[String]] at a time
00:43:47 <Baughn> Might zip them first
00:43:53 <sjanssen> yewT: zip or zipWith?
00:44:10 <yewT> but later i would need to unzip them right? because i would need them as [[STring]] back
00:44:19 <sjanssen> > zip ["foo", "bar"] ["1", "2"]
00:44:20 <lambdabot>   [("foo","1"),("bar","2")]
00:44:39 <sjanssen> > unzip  [("foo","1"),("bar","2")] -- gives you two lists back
00:44:40 <lambdabot>   (["foo","bar"],["1","2"])
00:45:22 <yewT> but zip and unzip would not be efficient if there are many
00:45:47 <sjanssen> they're efficient enough
00:46:06 <sjanssen> @src unzip
00:46:06 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
00:46:21 <sjanssen> yes, they're both rather efficient
00:46:22 <yewT> umm nvm i see it wrongly
00:47:08 <yewT> so how do i check if a tuple has an empty list  using _null_ using filter
00:48:23 <yewT> > filter(\x -> x == null)[([],1)]
00:48:24 <lambdabot>   Couldn't match expected type `[a] -> Bool'
00:48:45 <sjanssen> yewT: don't use == on null, null is a function
00:48:53 <sjanssen> so "null x" rather than "x == null"
00:48:54 <Baughn> yewT: null is a function, we told you that already. Three times.
00:49:00 <yewT> > filter(null)[([],1)]
00:49:02 <lambdabot>   Couldn't match expected type `[a]'
00:49:22 <Baughn> @type null
00:49:23 <lambdabot> forall a. [a] -> Bool
00:49:26 <yewT> sorry, i did not see it
00:49:34 <sjanssen> yewT: you need to pull the tuple apart and only apply null on the first part
00:49:47 <Baughn> @type fst
00:49:48 <lambdabot> forall a b. (a, b) -> a
00:49:49 <yewT> how do i pull them apart?
00:50:07 <cjs> > filter (null.fst) [([],1),(['a','b'],2)]
00:50:08 <lambdabot>   [("",1)]
00:52:06 <yewT> > filter (not.null.fst) [([],1),(['a','b'],2)]
00:52:08 <lambdabot>   [("ab",2)]
00:52:21 <yewT> > unzip $ filter (not.null.fst) [([],1),(['a','b'],2)]
00:52:23 <lambdabot>   (["ab"],[2])
00:55:59 <yewT> h ok
01:02:58 <pastorn> yewT: you getting the hang of it now?
01:04:44 <yewT> > fst(1,2)
01:04:44 <yewT> > 1+1
01:04:46 <lambdabot>   1
01:04:46 <lambdabot>   2
01:05:12 <pastorn> yes, 1+1 is 2
01:05:15 <pastorn> amazing :p
01:05:25 <Baughn> > case (1,2,3) of (_,_,a) -> a
01:05:26 <lambdabot>   3
01:05:28 <yewT> i did that to check whether im dc
01:05:35 <yewT> > fst(1,2)
01:05:35 <yewT> > 1+1
01:05:37 <lambdabot>   2
01:05:37 <lambdabot>   1
01:05:50 <Baughn> > fst (1,2,3) -- Just so you know.
01:05:50 <lambdabot>   Couldn't match expected type `(a, b)'
01:12:26 <yewT> hmm stil stuck
01:12:51 <n00b> guys i have a question to ask
01:13:33 <yewT> i now get a [True, False, True] and i want to display items which matches [1,2,3] >> so it returns [1,3]
01:13:40 <n00b> i have to the tower of hanoi problem to solve a problem but i don't know what the ques is really askin
01:13:55 <n00b> The simplest strategy, called the father/son, backs up each day's work on a tape named for that particular day, except for Fridays which alternate between two tapes (see table 1). This scheme uses six tapes and has a depth of two weeks.
01:14:09 <n00b> The Towers of Hanoi is a mathematical game or puzzle. It consists of three rods, and a number of disks of different sizes which can slide onto any rod. The puzzle starts with the disks neatly stacked in order of size on one rod, the smallest at the top, thus making a conical shape [1].
01:14:23 <n00b> there r five days in the week
01:14:24 <quicksilver> yewT: you can zip the two lists together
01:14:46 <n00b> i must use the function (tower of hanoi) to do backup
01:14:50 <yewT> and what should i do next?
01:14:52 <n00b> we have 5 tape
01:15:02 <n00b> 31 days in all
01:15:18 <n00b> the thing is 5/6 alternate on fridat
01:15:21 <quicksilver> yewT: and then filter for things with True in the first component.
01:15:33 <n00b> Week 1 Tape1 Tape 2 Tape 3 Tape 4 Tape 5
01:15:37 <quicksilver> n00b: that's a bit much to blurt into the channel all at once
01:15:40 <n00b> Week 2 Tape 1 Tape 2 Tape 3 Tape 4 Tape 6
01:15:45 <quicksilver> n00b: and it doesn't seem to have anything to do with haskell
01:16:21 <yewT> filter ( ??? ) (zip [True, False, True] [1,2,3] )
01:16:28 <n00b> well the tower of hanoi must be implemented in haskell to solve a five backup problem
01:17:05 <quicksilver> yewT: have you seen the result of the zip?
01:17:18 <quicksilver> ah yes, I see sjanssen showed you.
01:17:21 <Baughn> n00b: It's your homework, however
01:17:32 <n00b> i wrote the hanoi function right, i wanna know if i must instead 3 poles, should it b 5 since it's 5 days
01:17:45 <n00b> i don't want u to show me, i want u to help me
01:17:48 <n00b> big diff
01:17:50 <quicksilver> well you must write a function which checks if the first component of a tuple is true.
01:17:58 <n00b> u can choose or not
01:18:10 <quicksilver> yewT: do you understand how to write anonymous functions with \ ?
01:18:19 <quicksilver> yewT: like, for example (\(a,b) -> a)
01:18:33 <yewT> yeah
01:18:33 <yewT> only basic
01:19:17 <quicksilver> well that one I just showed extracts the first component
01:19:25 <quicksilver> you want to check if it's true
01:19:33 <n00b> > ( [True, False, True], [1,2,3] )
01:19:34 <lambdabot>   ([True,False,True],[1,2,3])
01:19:46 <quicksilver> > filter (\(a,b) -> a == True) (zip [True,False,True] [1,2,3])
01:19:47 <lambdabot>   [(True,1),(True,3)]
01:19:53 <quicksilver> yewT: see what I did there?
01:20:03 <yewT> yeah i go tthat answer too
01:20:09 <quicksilver> good.
01:20:13 <quicksilver> where do we have to go next?
01:20:14 <n00b> > filter (zipWith (++) [True, False, True] [1,2,3] )
01:20:15 <lambdabot>   Couldn't match expected type `[a]' against inferred type `Bool'
01:20:20 <quicksilver> extract the second tuple?
01:20:22 <yewT> but i still cant figure out how to remove those ()
01:20:26 * quicksilver nods
01:20:30 <quicksilver> > snd (True,1)
01:20:32 <lambdabot>   1
01:20:38 <quicksilver> 'snd' extracts the second component
01:21:14 <yewT> > map (snd) [(True,1),(True,3)]
01:21:15 <lambdabot>   [1,3]
01:21:20 <yewT> yay
01:21:22 <yewT> finally T_T
01:21:37 <quicksilver> \o/
01:21:39 <yewT> > map (\(a,b)->a) [(True,1),(True,3)]
01:21:40 <lambdabot>   [True,True]
01:21:44 <yewT> > map (\(a,b)->b) [(True,1),(True,3)]
01:21:46 <lambdabot>   [1,3]
01:21:49 <quicksilver> nice :)
01:21:53 <quicksilver> yewT: getting the hang of it now?
01:21:54 <yewT> *sweat
01:21:57 <quicksilver> good stuff.
01:21:59 <yewT> yeah
01:22:05 <yewT> i guess i mastered the basics of ()
01:22:09 <yewT> have phobia in it
01:22:18 <quicksilver> \(a,b) -> b is, of course, the definition of 'snd'
01:22:30 <yewT> just wanna try that lambda thingy
01:22:46 * quicksilver nods
01:24:15 <Baughn> > map (\t@(a,b) -> (t,b)) [(True,1),(True,3)] -- ^_^
01:24:16 <lambdabot>   [((True,1),1),((True,3),3)]
01:26:09 <yewT> baughn could you explain your code?
01:26:23 <yewT> what does the @ do and how did the t appear from?
01:26:25 <BeelsebobWork> > map (\(a,b) -> let t = (a,t) in t) [(1,True),(3,True)]
01:26:26 <lambdabot>       Occurs check: cannot construct the infinite type: t = (t1, t)
01:26:26 <lambdabot>        Ex...
01:26:29 <BeelsebobWork> awww:(
01:26:41 <BeelsebobWork> yewT: the @ lets you bind multiple variables to the same pattern
01:27:01 <BeelsebobWork> > let t@(a,b) = (5,2) in t
01:27:02 <lambdabot>   (5,2)
01:27:04 <BeelsebobWork> > let t@(a,b) = (5,2) in a
01:27:05 <lambdabot>   5
01:27:07 <BeelsebobWork> > let t@(a,b) = (5,2) in b
01:27:07 <luqui> Beelsebob, what, can *your* type system support infinite tuples? ;-)
01:27:08 <quicksilver> it makes 't' an alternative name for the whole of "(a,b)"
01:27:08 <lambdabot>   2
01:27:16 <BeelsebobWork> luqui: :P
01:27:20 <BeelsebobWork> it can't do tuples at all atm
01:27:28 <BeelsebobWork> or polymorphism :(
01:27:38 <BeelsebobWork> which is proving a greater headache than I expected
01:27:47 <luqui> what wrt inference?
01:27:51 <BeelsebobWork> yeh
01:28:03 <BeelsebobWork> it's very hard to avoid an exponential blow up in the size of the graph
01:28:37 * BeelsebobWork pokes luqui into #anygma to see if he has any cunning ideas
01:29:00 <luqui> hm yeah, I suspect a lot of these fairly straightforward algorithms get quite a bit more difficult when you're maintaining a graph
01:32:21 <hackage> Uploaded to hackage: mps 2008.10.15
01:32:21 <hackage> Uploaded to hackage: mps 2008.10.14
01:34:39 <Axman6> "For this program you will need to use Haskell's record data type" s/data type/syntax ?
01:34:53 <quicksilver> Axman6: yes, I think so. Where is that from?
01:35:02 <Axman6> http://www.engr.uconn.edu/~jeffm/Classes/CSE240-Spring-2001/Projects/project03/project3/node2.html
01:35:04 <lambdabot> Title: Preliminaries, http://tinyurl.com/453c58
01:35:33 <Axman6> looks like a nice net of assigments. implementing a simple ARM CPU in haskell
01:35:41 <Axman6> set*
01:37:36 <cjs> "Every field name in the entire type declaration must be unique." That's wrong.
01:37:48 <cjs> Or is that Haskell98?
01:37:56 <pastorn> cjs: no
01:38:01 <pastorn> but it should be...
01:38:03 <quicksilver> as far as I know, its' wrong even in h98
01:38:15 <quicksilver> pastorn: why should it be?
01:38:26 * quicksilver thinks field name punning is a harmless trick.
01:38:42 <quicksilver> indeed, it might make a function total which would otherwise be partial.
01:38:44 <pastorn> well, overloading function names isn't very haskell-y
01:38:49 <Axman6> yeah, the example he gives would be better if you could just use id as a function for both types
01:39:12 <quicksilver> pastorn: it's not overloading.
01:39:14 <quicksilver> pastorn: it's one function.
01:39:28 <quicksilver> data Foo = Foo1 {id :: Int} | Foo2 {id :: Int}
01:39:42 <quicksilver> 'id :: Foo -> Int' is a (badly named, oops!) total function.
01:39:46 <quicksilver> this is nicer than
01:39:54 <quicksilver> data Foo = Foo1 {id1 :: Int} | Foo2 {id2 :: Int}
01:40:00 <quicksilver> where id1 and id2 are both partial.
01:40:06 <cjs> They're not actually overloaded, really; if one named, e.g., both grdID and ugID just "id", then they would both be functions on a value of type Student that returned a String.
01:40:20 <quicksilver> cjs: they wouldn't both be functions. THey'd be one function :)
01:40:45 <Axman6> would if in both types have to be of the same type?
01:40:54 * cjs throws a spitball at quicksilver.
01:41:04 <Axman6> so, it couldn't be Foo -> Int and Foo -> String
01:41:17 <cjs> Yes, the return value of each declaration must be the same type.
01:41:26 <Axman6> ok
01:41:45 <Axman6> just checking that what made sense to me made sense to... well the syntax
01:41:52 <cjs> I use this all the time. E.g., data Instrument = Future { stockName :: String, ... } | Option { stockName :: String, ... }
01:43:17 <Axman6> cjs: i'm sure a few people are whincing at those names
01:43:36 <Axman6> with the economy as it is at the moment ;)
01:43:36 <quicksilver> I mean, it's true that I wish field names were more like lenses and less like selectors, but given that they are what they are
01:43:45 <quicksilver> sharing them is sensible.
01:44:28 <cjs> Axman6: why? Aside from stockName, which is actually a hold-over from a particular market data feed format I read.
01:44:48 <BeelsebobWork> @pl zipWith (\x y -> (x,zipWith (,) y))
01:44:48 <lambdabot> zipWith ((. zip) . (,))
01:44:52 <BeelsebobWork> bah
01:44:53 <BeelsebobWork> ugly
01:44:54 <Axman6> the Future and Option bits
01:44:56 <Axman6> dw though
01:45:10 <cjs> Hm? What's odd about those?
01:45:20 <Axman6> nothing odd
01:45:32 <Axman6> just, maybe unplesant for some people at the moment
01:45:35 <cjs> Oh!
01:45:53 <cjs> Yes, I've been very pleased with some of the test data I've been gathering recently. :-)
01:46:03 <Axman6> heh
01:52:16 <yewT> hey guys, how do i make my upper case to work?
01:52:22 <yewT> what do i need to import?
01:52:24 <yewT> data.char?
01:52:31 <BeelsebobWork> yep
01:52:39 <yewT> i type that but its not working
01:52:45 <yewT> import data.char
01:52:58 <quicksilver> in ghci?
01:53:08 <yewT> winhugs
01:53:08 <quicksilver> in ghci you want :m +Data.Char
01:53:17 <quicksilver> in winhugs, I have no idea what you want.
01:53:27 <Saizan> :load Char ?
01:53:42 <yewT> o_o
01:53:45 <yewT> how do i make a word uppercase?
01:53:57 <Saizan> > map toUpper "word"
01:53:58 <lambdabot>   "WORD"
01:53:59 <yewT> map(uppercase)"abc"
01:54:13 <yewT> > map toLower "word"
01:54:14 <lambdabot>   "word"
01:54:16 <Saizan> yewT: module names are case sensitive btw
01:54:24 <pastorn> yewT: stop writing fun(var1,var2)
01:54:29 <pastorn> it's hard to read :p
01:54:29 <Saizan> just like everything else
01:54:31 <yewT> thanks saizan for the tip
01:54:47 <yewT> fun (var1,var2?)
01:54:51 <yewT> i did not type that
01:55:04 <pastorn> "map(uppercase)"abc""
01:55:14 <pastorn> > map toUpper "lol"
01:55:15 <lambdabot>   "LOL"
01:55:29 <Arnar_> Hi all
01:55:39 <yewT> hi arnar_
01:55:44 <Arnar_> Saizan: hey there, thanks for the comment
01:56:04 <pastorn> @hoogle Int -> [a] -> [a]
01:56:05 <lambdabot> Prelude drop :: Int -> [a] -> [a]
01:56:05 <lambdabot> Prelude take :: Int -> [a] -> [a]
01:56:05 <lambdabot> Data.List drop :: Int -> [a] -> [a]
01:58:59 <yewT> > map toUpper ["abc","123"]
01:59:00 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
02:00:03 <yewT> how do i give a list to the toUpper so it converts all elements into uppercase?
02:00:11 <solrize> sequence.complete.org is down?
02:00:29 <ilyak> > map (map toUpper) ["abc","123"]
02:00:30 <lambdabot>   ["ABC","123"]
02:00:39 <ilyak> yewT:
02:01:08 <BeelsebobWork> > (fmap . fmap) toUpper ["abc", "123"] -- there, conalised
02:01:09 <lambdabot>   ["ABC","123"]
02:01:18 <luqui> haha
02:01:21 <yewT> my method o_o
02:01:24 <yewT> > let abc x = map toUpper x in map(abc) ["abc","123"]
02:01:25 <lambdabot>   ["ABC","123"]
02:01:45 <yewT> luqui whats so funny
02:02:01 <BeelsebobWork> yewT: that works -- all that ilyak did differently is he wrote abc rather more concicely
02:02:13 <BeelsebobWork> yewT: you can get between the two easily
02:02:34 <BeelsebobWork> let abc x = map toUpper x -- this can be rewritten dropping the xes
02:02:36 <luqui> yewT, BeelsebobWork "conalized" the code, which is a rather weirder way of writing it that has deeper neatness
02:02:38 <BeelsebobWork> let abc = map toUpper
02:02:43 <yewT> oh
02:02:51 <yewT> what is cornalized?
02:02:54 <luqui> because conal is a weird guy we know
02:03:07 <BeelsebobWork> so we have let abc = map toUpper in map abc ["abc", "123"]
02:03:15 <BeelsebobWork> now we can just fold the constant into the expression
02:03:33 <BeelsebobWork> let abc = map toUpper in map (map toUpper) ["abc", "123"]
02:03:39 <BeelsebobWork> and now we have an unused definition of abc
02:03:42 <BeelsebobWork> so we can bin it
02:03:51 <BeelsebobWork> map (map toUpper) ["abc", "123"]
02:04:02 <BeelsebobWork> > map (map toUpper) ["abc", "123"]
02:04:03 <lambdabot>   ["ABC","123"]
02:04:05 <yewT> bin = remove?
02:04:10 <BeelsebobWork> yep
02:04:13 <BeelsebobWork> throw it in the bin
02:04:32 <luqui> stop being so british.   (*checks the time*)
02:05:02 <BeelsebobWork> incidentally -- this is one of the reasons that I love functional programming -- we can easily transform one program into another, while never going through a program that doesn't actually compile
02:05:17 <BeelsebobWork> so we actually formed a proof that the two programs are equal there
02:05:31 * luqui orgasms at the idea of doing this with graphics instead of clunkily with text..
02:05:49 <BeelsebobWork> (assuming you believe that each of my transforms are actually behavior preserving)
02:05:51 <yewT> woah i didnt see it coming
02:05:54 <BeelsebobWork> luqui: yeh, that would be rather nice
02:05:55 <yewT> > map (map toUpper) ["abc", "123"]
02:05:57 <lambdabot>   ["ABC","123"]
02:06:28 <Arnar_> Saizan: Did you mean something like this: http://hpaste.org/11139 ?
02:06:42 <luqui> @pll let abc x = map toUpper x in map(abc) ["abc","123"]
02:06:43 <lambdabot> map (map toUpper) ["abc", "123"]
02:06:50 <yewT> thanks BeelsebobWork for explaining
02:06:52 <luqui> lambdabot agrees :-)
02:07:04 <BeelsebobWork> yewT: and as luqui just demonstrated, the process we just went through can be automated
02:07:20 <Saizan> Arnar_: exactly
02:07:38 <BeelsebobWork> (although not in all cases, sometimes humans just make better decisions than lambdabot)
02:07:58 <yewT> what is @pll?
02:08:12 <Saizan> Arnar_: does it work fine?:)
02:08:22 <BeelsebobWork> it's a lambdabot command that computes the "point free style" equivalent of an expression
02:08:28 <BeelsebobWork> equation even
02:08:38 <yewT> what is a point free style/
02:08:41 <BeelsebobWork> point free style meaning without any arguments
02:08:46 <BeelsebobWork> so for example...
02:08:53 <BeelsebobWork> @pl f x y = x + y
02:08:54 <lambdabot> f = (+)
02:09:06 <pjdelport> @unpl (+)
02:09:09 <lambdabot> (+)
02:09:12 <BeelsebobWork> that's how you would write f if you didn't want the arguments there
02:09:15 <luqui> oops :-)
02:09:18 <ilyak> @unpl f = (+)
02:09:19 <lambdabot> f = (+)
02:09:21 <ilyak> wow
02:09:26 <pjdelport> heh, foiled
02:10:11 <luqui> @pl \a b c -> (-b + sqrt (b^2 - 4*a*c))/(2*a)   -- ack!
02:10:12 <lambdabot> ap (flip . ((flip . (((/) . negate) .)) .) . liftM2 (.) (+) . ((sqrt .) .) . flip ((.) . (-) . (^ 2)) . (*) . (4 *)) (2 *)
02:10:22 <BeelsebobWork> as you can see... sometimes it produces garbage ;)
02:10:46 <Saizan> Arnar_: a little comment on style, if cond then foo else return () == when cond foo
02:10:54 <BeelsebobWork> also luqui make that return a tuple already
02:11:16 <luqui> uh... I'm afraid :-)
02:11:23 <Axman6> "It may be tempting to call this function newCPU instead, but by Haskell convention, new is used in a function name only when I/O is required." really?
02:11:24 <BeelsebobWork> haha
02:11:48 <luqui> @pl \a b c -> let plusminus x y = (x+y,x-y) in ((-b) `plusminus` sqrt (b^2 - 4*a*c))/(2*a)
02:11:50 <lambdabot> flip flip (ap (ap . ((,) .) . (+)) (-)) . (flip .) . ap (flip . ((flip . ((flip . ((/) .)) .)) .) . ap ((.) . flip . flip id . negate) . ((sqrt .) .) . flip ((.) . (-) . (^ 2)) . (*) . (4 *)) (2 *)
02:11:58 <BeelsebobWork> ahahahah
02:12:21 <luqui> which is wrong, because (/) does not work on tuples, but... no I'll stop here :-)
02:12:48 <Axman6> flip flip...
02:13:01 <luqui> :t flip flip
02:13:02 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
02:13:15 <BeelsebobWork> @hoogle (a -> b) -> (a,a) -> (b,b)
02:13:15 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
02:13:15 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
02:13:15 <lambdabot> Data.Array.Base ixmap :: (IArray a e, Ix i, Ix j) => (i, i) -> (i -> j) -> a j e -> a i e
02:13:36 <BeelsebobWork> bad lambdabot!
02:13:50 <luqui> @pl \f -> f *** f
02:13:51 <lambdabot> join (***)
02:14:11 <luqui> :t join (***)
02:14:12 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
02:14:31 <Arnar_> Saizan: ah, thanks.. didn't know about that
02:14:45 <luqui> hmmmmm
02:14:46 <idnar> starstarstar
02:14:50 <BeelsebobWork> @pl \a b c -> let x ± y = (x+y,x-y) in (join (***)) (/(2*a)) ((-b) ± sqrt (b^2 - 4*a*c))
02:14:50 <lambdabot> (line 1, column 18):
02:14:50 <lambdabot> unexpected "\177"
02:14:50 <lambdabot> expecting pattern or "="
02:14:53 <BeelsebobWork> awww :(
02:14:56 <Arnar_> Saizan: I've updated the post with a link to the more elegant version :)
02:14:59 <luqui> @. type pl \f -> f *** f
02:15:00 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
02:15:01 <Arnar_> Saizan: thanks a lot!
02:15:34 <BeelsebobWork> @pl \a b c -> let plusminus x y = (x+y,x-y) in (join (***)) (/(2*a)) ((-b) `plusminus` sqrt (b^2 - 4*a*c))
02:15:36 <lambdabot> flip flip (ap (ap . ((,) .) . (+)) (-)) . (flip .) . ap ((.) . (.) . (.) . join (***) . flip (/) . (2 *)) (ap ((.) . flip . flip id . negate) . ((sqrt .) .) . flip ((.) . (-) . (^ 2)) . (*) . (4 *))
02:15:50 <BeelsebobWork> there we go, but I liked my ±
02:15:51 <Arnar_> Saizan: and yes, it works perfectly - even a tiny bit faster than using MVars
02:15:52 <yewT> cya guys
02:15:53 <BeelsebobWork> :'(
02:15:53 <yewT> thanks everyone ^_^
02:18:28 <Saizan> Arnar_: cool, and i suspect using DList String (which is a fancy name for (String -> String)) as the monoid for Writer might be faster
02:18:50 <Arnar_> Saizan: ah, nice.. because mappend is not so efficient for []?
02:19:55 <luqui> Arnar_, in a lot of cases you're correct.
02:19:57 <Saizan> Arnar_: mappend for [] is (++) which gets quadratic if nested poorly, i.e a ++ (b ++ c) is efficient, while (a ++ b) ++ c isn't
02:20:08 <Arnar_> yeah..
02:20:26 * Arnar_ tries DList String
02:21:37 <quicksilver> Endo String
02:21:45 <quicksilver> (different name, same thing)
02:22:44 <Arnar_> quicksilver: yes.. and doesn't require me to install a dependency
02:23:51 <Arnar_> @src Endo mappend
02:23:52 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
02:24:00 <Saizan> (.)
02:24:37 <Saizan> (modulo newtype wrapping)
02:24:46 <Arnar_> thanks
02:25:32 <Arnar_> I'm a bit thick.. how do I use endomorphisims instead of lists in Writer?
02:26:05 <Saizan> instead of tell [a] you use tell (Endo (a:))
02:26:27 <Saizan> oh
02:26:28 <Arnar_> ah, clever
02:26:29 <Deewiant> http://www.reddit.com/r/programming/comments/770gv/is_haskellml_really_used_in_an_industrial/ -- needs answers!
02:26:31 <lambdabot> Title: Is Haskell/ML really used in an industrial application? : programming, http://tinyurl.com/4g3zcg
02:26:46 <Saizan> but i was wrong, it's [String] -> [String] in your case, so Endo [String]
02:26:56 <Arnar_> Saizan: should I use Endo or Dual Endo?
02:27:06 <Arnar_> yeah.. realized
02:27:18 <Saizan> let's see
02:27:28 <Arnar_> Saizan: using Endo will reverse the output list, right.. which is no problem actually
02:27:52 <Saizan> > runApp (Endo (:"a") `mappend` Endo (:"b")) []
02:27:53 <lambdabot>   Not in scope: `runApp'
02:27:58 <Saizan> > appEndo (Endo (:"a") `mappend` Endo (:"b")) []
02:27:59 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
02:28:11 <Saizan> > appEndo (Endo ("a":) `mappend` Endo ("b":)) []
02:28:12 <lambdabot>   ["a","b"]
02:28:20 <Arnar_> oh, ok
02:28:21 <Saizan> no reversing :)
02:28:23 <Arnar_> cheers
02:28:39 * Saizan is not fully awake yet
02:29:34 <luqui> theoretically it should be possible to memoize functions of infinite lists, right?
02:30:04 <quicksilver> well memoize finite initial segments, yes
02:30:12 <quicksilver> the standard fibs example does exactly that.
02:30:48 <Arnar_> hmm
02:30:51 <luqui> so is it possible to write, say, memoStream :: (Stream Bool -> b) -> (StreamBool -> b)
02:30:54 <Arnar_> :index Endo
02:31:06 <Arnar_> @index Endo
02:31:06 <lambdabot> bzzt
02:31:07 <luqui> My hunch is that b needs more structure
02:31:13 <luqui> Arnar_, it's in Data.Monoid
02:31:35 <Arnar_> luqui: ah, ok.. I was trying "import Data.Monoid.Endo"
02:31:38 <Arnar_> :)
02:31:44 <Cale> luqui: hmm... should be quite possible
02:32:08 <pjdelport> you'd build a trie of the results
02:32:20 <luqui> pjdelport, except for the results are infinitely far down in the trie
02:32:21 <hackage> Uploaded to hackage: panda 2008.10.18
02:32:36 <luqui> so more cleverness is necessary it seems
02:32:37 <Cale> My intuition is that any function which consumes a Stream and produces a result can only have looked at a finite portion of that input stream.
02:32:40 <Saizan> pjdelport: to do that the function should tell you at which point it has finished to read the Stream, no?
02:32:52 <thomashartman1> When I try to post external-sort to hackage, I get "#"
02:32:54 <thomashartman1> # Exposed modules use unallocated top-level names: ExternalSort
02:32:54 <Saizan> Cale: unless its result is infinite too
02:33:11 <luqui> Cale, well, functions are continuous, so a finite amount of information in the result only depends on a finite amount of information in the arguments
02:33:13 <Cale> Saizan: mm... yes. Any total function then.
02:33:22 <thomashartman1> http://code.haskell.org/external-sort/externalsort.cabal
02:33:29 <luqui> but certainly "id" looks at its entire argument,just not all at once
02:33:30 <Cale> er...
02:33:33 <thomashartman1> don't understand that error... what do I do?
02:33:46 <Cale> ah, if it's producing something infinite, yeah, that's different...
02:33:46 <thomashartman1> well, it's a warning not an error, but still.
02:33:58 <thomashartman1> should I ignore it, or am I doing something wrong?
02:34:01 <luqui> thus "b needs more structure"
02:34:03 <Saizan> corecursion gets in the way :)
02:34:11 <Cale> But let's say  Stream Bool -> Bool to start with.
02:34:30 <luqui> aye
02:36:10 <Saizan> there's a nice relevant sigfpe post
02:36:11 <Cale> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/ -- you could use this.
02:36:16 <lambdabot> Title: Mathematics and Computation » Seemingly impossible functional programs, http://tinyurl.com/2umqwh
02:36:25 <luqui> Saizan, yeah, that's a pretty one.  it seems to be the dual of what I'm looking for...
02:36:38 <Cale> There's a program there for finding the modulus of continuity.
02:36:52 <luqui> ah cool.
02:36:55 <quicksilver> oh yeah, I remember that post.
02:37:00 <quicksilver> that was *extremely* cool.
02:37:18 <Cale> uniform continuity*
02:37:23 <Arnar_> Saizan: would you mind having a look? http://hpaste.org/11140
02:37:32 <Cale> modulus f = least(\n -> forevery(\a -> forevery(\b -> eq n a b --> (f a == f b))))
02:37:45 <Cale> Such a beautiful program too :)
02:38:16 <quicksilver> Arnar_: you are confused about whether you are collecting strings or chars
02:38:18 <luqui> what is the topological property of Bool that allows this?
02:38:23 <luqui> compactness?
02:38:26 <quicksilver> is it Endo String or Endo [String] ?
02:38:43 <quicksilver> or Endo [[String]], indeed ;)
02:39:08 <Arnar_> quicksilver: I'm trying to replace Writer [[String]] ()
02:39:17 <Arnar_> ah..
02:39:18 <Arnar_> right
02:39:23 <Arnar_> so it is Endo [[String]]..
02:39:42 <Arnar_> since [String]: is [[String]] -> [[String]]
02:40:09 <Cale> Well, yeah, and more specifically, it's that any product of compact spaces is compact.
02:40:09 <quicksilver> perhaps you want Endo (ac++)
02:40:20 <quicksilver> in the definition of antichains'
02:40:38 <Arnar_> quicksilver: hmm.. the use of Endo here was to avoid appending lists
02:40:50 <quicksilver> that's fine.
02:40:53 <quicksilver> (ac++) is fine.
02:41:01 <Arnar_> ok..
02:41:42 <Saizan> Arnar_: since you had Writer [[String]] (), you've to use Writer (Endo [[String]]) (), unless concatenating the results is fine
02:42:42 <Arnar_> Saizan: yeah.. got it working. using Endo is slower though than just using [[String]] in the first place
02:42:52 <Cale> hmm...
02:42:53 <Arnar_> quicksilver: (ac++) does not work..
02:44:30 <Arnar_> quicksilver: but ([ac]++) does.. but doesn't that put me right back with using [[String]] as the monoid
02:44:50 <Saizan> Arnar_: did you compile both with -O2?
02:44:56 <quicksilver> ([ac]++) is just (ac:) :P
02:45:10 <quicksilver> I was changing your code to Endo [String] instead of Endo [[String]]
02:45:14 <quicksilver> depends what you want.
02:45:17 <Arnar_> quicksilver: ah. right
02:45:20 <Cale> Oh, of course.
02:45:22 <Arnar_> quicksilver: yes, that's not what I want :)
02:46:06 <Arnar_> Saizan: no.. just runhaskell actually :P
02:46:08 <Cale> er... no, that's for functions of type ((Stream Bool -> Bool) -> y) which equality is decidable
02:46:28 <Cale> (where y has decidable equality)
02:47:30 <quicksilver> Arnar_: if you're not compiling with -O then measuring performance is uninteresting.
02:47:35 <quicksilver> ;)
02:48:48 <Arnar_> quicksilver, Saizan: yeah :) After compiling with -O2 the two do not differ in performance, at least not on my input
02:49:28 * kowey grumbles about cabal-install 0.5.2 not installing on GHC 6.6.1
02:49:54 <Saizan> Arnar_: hah, :)
02:50:19 <hugo_> im coding haskell for 700 euros a month :P
02:50:27 <hugo_> coding = learning while coding lol
02:50:56 <hugo_> lots of offers fill my inbox, to code in .net and java, for large ammounts of money...
02:51:02 <hugo_> i can't say i am not tempted...
02:51:20 <Saizan> kowey: what's the problem?
02:52:53 <kowey> Saizan: lots of little issues - for example unix and network dependencies not available
02:53:10 <kowey> bootstrap.sh thinks that /bin/sh is bash (on a general note)
02:53:21 <Saizan> yeah, that's already fixed
02:53:53 <hugo_> in portugal 700 euros a month is enough to make a living
02:53:59 <kowey> are there plans for a cabal install 0.5.3 with hopefully a little more testing on older GHC?
02:54:02 <Saizan> for network and unix it means that you've not installed the extralibs
02:54:07 <kowey> oh
02:54:37 <kowey> i installed those and then I get some error about Monoid instance in the tar code?
02:54:56 <Saizan> that's more serious :)
02:54:57 <kowey> (the packages individually and not the extralibs)
02:56:45 <kowey> my workaround so far is just to go with cabal-install 0.5.1
02:57:07 <kowey> since the bootstrap.sh so kindly installed HTTP, zlib and Cabal for me
02:57:57 <kowey> note: a use case is "installing Haskell software on your former phd supervisor's machine"... where former phd supervisors tend not to be so enthusiastic about upgrading GHC :-)
03:00:05 <Saizan> kowey: Cabal and cabal-install support till 6.4.2, and dcoutts checks that from time to time, that Monoid issue looks fixed in HEAD looking at darcs changes, so i guess we need more testers for the release candidates :)
03:18:17 <luqui> ping
03:19:11 <BeelsebobWork> pong
03:19:21 <ivanm> pang
03:19:42 <Cale> poioioioing
03:19:55 <luqui> okay, thought the entire internet died.  I'm glad there are at least four survivors
03:20:20 <ivanm> Cale: you playing pogo-pong? :p
03:20:34 <ivanm> luqui: that's it, we must form a new haskell-oriented society! ;-)
03:20:41 <luqui> yay!
03:20:57 <dolio> @yow!
03:20:58 <lambdabot> Toes, knees, NIPPLES.  Toes, knees, nipples, KNUCKLES ...
03:20:58 <lambdabot> Nipples, dimples, knuckles, NICKLES, wrinkles, pimples!!
03:21:10 <ivanm> @yarr!!
03:21:10 <lambdabot> Arr! Me ship be the biggest brig in the port!
03:21:49 <BeelsebobWork> Cale: I'm not sure I like the sound of breeding with luqui
03:22:05 <BeelsebobWork> the result might be a horrible dependant type monster
03:22:23 <ivanm> did I say anything about breeding?
03:22:39 <BeelsebobWork> oh, it was you, but no you didn't
03:22:45 * ivanm was going to stick with good-old-fashioned immortality
03:22:46 <ivanm> ;-)
03:22:48 <luqui> Down with the IO bourgeoisie!  Long live the purely functional proletariat
03:22:58 <BeelsebobWork> oh, imortality, that works
03:23:05 <BeelsebobWork> we can become the Haskell gods of a new world
03:23:08 <ivanm> cloning if we absolutely have to
03:23:19 <dolio> It could be like the Shakers. You have to convert people to the Haskell way, or else you die out.
03:23:21 <luqui> lazily cloning of course
03:23:22 <ivanm> @remember luqui Down with the IO bourgeoisie!  Long live the purely functional proletariat
03:23:22 <lambdabot> I will remember.
03:23:44 <BeelsebobWork> @vixen you lie lambdabot!
03:23:44 <lambdabot> why does everyone ask i'f on a bot?
03:23:56 <osfameron> is there a music player written in haskell?
03:23:58 <ivanm> ummmmm... s/f/m/ ?
03:24:07 <ivanm> osfameron: dons had an mp3 player IIRC...
03:24:15 <osfameron> given that all of the current ones are buggy and awful...
03:24:16 <luqui> osfameron, pff, that's not theoretically interesting
03:24:20 <dolio> Yeah, some kind of console one.
03:24:23 <ivanm> osfameron: mpd!
03:24:26 <osfameron> luqui: what about curried playlists? ;-)
03:24:35 <quicksilver> well it was a frontend to mpg123
03:24:38 <quicksilver> or something, IIRC>
03:24:43 <luqui> goodSongs :: Playlist -> Playlist
03:24:45 <ivanm> yeah, that sounds about right
03:24:46 <quicksilver> I have part of a graphical frontend to mplayer.
03:24:50 <luqui> = filter doesntSuck
03:24:54 <BeelsebobWork> I want a recipie store application written in Haskell
03:24:55 <quicksilver> it's not very complete, but it's purty ;)
03:24:58 <BeelsebobWork> so I can have curried curry
03:25:03 <ivanm> BeelsebobWork: then write one!
03:25:08 <ivanm> quicksilver: using which toolkit?
03:25:32 <BeelsebobWork> ivanm: no good cocoa bindings :(
03:25:36 <BeelsebobWork> HOC seems to have died :(
03:25:54 <ivanm> BeelsebobWork: oh? though I do admit, cocoa would be appropriate...
03:26:01 <ivanm> but strangely enough not too portable
03:26:14 <quicksilver> http://roobarb.jellybean.co.uk/~jules/Picture%20116.png
03:26:17 <BeelsebobWork> yeh, but I'm avidly against portable GUI APIs
03:26:21 <BeelsebobWork> portable application cores -- great
03:26:25 <quicksilver> ivanm: opengl ;)
03:26:26 <BeelsebobWork> portable GUI layers -- fail
03:26:33 <ivanm> quicksilver: :o
03:26:41 <ivanm> so it's a resource/graphics hog?
03:26:46 <ivanm> BeelsebobWork: why?
03:26:50 <ivanm> what's wrong with gtk2hs?
03:27:04 <BeelsebobWork> ivanm: on most modern OSes all the windows are drawn with OpenGL (or MS's bastard child)
03:27:07 <quicksilver> certainly not a resource hog on my machine.
03:27:16 <BeelsebobWork> ivanm: and I'm against portable GUIs because they're not
03:27:29 <ivanm> BeelsebobWork: well, not directly drawn with...
03:27:41 <ivanm> quicksilver: ummmm.... so you've re-invented the file dialog?
03:28:05 <BeelsebobWork> ivanm: sure directly drawn with -- most OS X apps draw their window contents with OpenGL
03:28:15 <ivanm> oh? not cocoa?
03:28:28 <BeelsebobWork> cocoa uses Quartz 2D Extreme
03:28:34 <BeelsebobWork> which boils down to OpenGL
03:29:12 <ivanm> yes.... but does the end programmer use opengl directly, or use a widget toolkit/library?
03:29:20 <Debolaz> As much as I want to, I can't get myself to like OpenGL.
03:29:24 * ivanm goes off to watch the idiot box
03:29:34 <BeelsebobWork> ivanm: yeh, but since when does that magically get rid of the overhead of using OpenGL?
03:29:41 <BeelsebobWork> Debolaz: that's because it's horrible
03:29:49 <BeelsebobWork> it's a nasty nastly big clunky state machine of death
03:29:53 <quicksilver> ivanm: if you think there is no difference between that an a file dialog then I can't be bothered to explain.
03:29:57 <BeelsebobWork> hopefully OpenCL will sort this out for us
03:30:21 <BeelsebobWork> ivanm: in the mean time.. they're not portable, because a GUI written to work well on linux invariable works in a completely counter intuitive way on Windows or OS X, and similarly if you design it on OS X or windows
03:30:31 <BeelsebobWork> cross platform GUIs just don't work
03:30:37 <Debolaz> And I really don't want to say this either, but Direct3D is fun to use in comparison.
03:30:53 <BeelsebobWork> Debolaz: absolutely -- fingers crossed for OpenCL fixing that too
03:32:21 <hackage> Uploaded to hackage: kibro 0.4
03:32:21 <hackage> Uploaded to hackage: regex-tdfa 0.95.1
03:32:21 <hackage> Uploaded to hackage: external-sort 0.1
03:32:36 <osfameron> ivanm: oo, that sounds interesting
03:33:48 <luqui> oo is uninteresting
03:37:44 <osfameron> luqui: there are some interesting things about oo.  But I really meant "oooo" about the mpd interface
03:47:26 <luqui> osfameron, yeah, I was just being silly.  I actually think OO is pretty interesting, and have for quite a while tried to identify beauty behind the philosophy of OO.
03:47:57 <luqui> So far I consider myself unsuccessful, though I've boiled it down to "something having to do with identity" (as the difference between conventional mathematics)
03:51:47 <pjdelport> luqui: which flavor of OO
03:51:54 <pjdelport> or incarnation, rather
03:52:06 <pjdelport> e.g. actor model?
03:54:21 <hugo_> i like smalltalk
03:55:01 <Axman6> not sure why, but i find java really easy to use, and have issues with Objective-C. i wish it were the other way :\
03:55:07 <luqui> pjdelport, uh, whichever one has the beauty I seek.
03:55:31 <luqui> there are certainly ones which are ad-hoc messes.  I'm looking for the one that isn't, and how others are variations on it :-)
03:55:48 <luqui> Axman6, maybe you like strong typing?
03:55:59 <Axman6> i do
03:56:19 <luqui> By that I meant "building finger strength"  =P
03:56:41 <dolio> Maybe he likes downcasting.
03:56:53 <pjdelport> luqui: have you looked at generic function based OO, a la CLOS/Dylan?
03:56:57 <dolio> But, then, who doesn't?
03:57:27 <hugo_> and what about this func. pure language called clean ?
03:57:29 <quicksilver> implementation inheritance certainly appears to work well for GUI toolkits.
03:57:34 <luqui> pjdelport, I'm vaguely familiar with CLOS.  mostly it's the state that bugs me.
03:57:43 <quicksilver> I'm not sure if that's because that's the tool people had.
03:57:56 <quicksilver> I'm not so convinced in works in other domains it is put to.
03:58:17 <pjdelport> luqui: the state?
03:58:23 <luqui> state is an essential part of OO, but all state is single-threaded (i.e. cloning is not *essential*).  there's something to that, thus I call it "identity"
03:58:26 <pjdelport> object state in general?
03:58:44 <pjdelport> hmm
03:58:45 <luqui> yeah object state in general.  state is not really a mathematical thing, it's an operational thing.
03:58:49 <quicksilver> objects like to hold on to references to other objects.
03:58:51 <pjdelport> have you looked at linear typing systems?
03:58:56 <quicksilver> and the expectation is that if the other object changes
03:58:57 <luqui> pjdelport, no
03:59:04 <quicksilver> your reference automatically becomes a reference to the new version
03:59:05 <luqui> oh of course
03:59:11 <quicksilver> so there is a notion of object identity
03:59:16 <luqui> yes, I read that as "linear (typing systems)"
03:59:41 <luqui> quicksilver, aye.
03:59:53 <luqui> it's kind of a weak version of reactive programming, where objects are functions of time.
04:00:24 <luqui> but that's not really its essence, because it matters who is allowed to change state too; state is not definitional
04:01:02 <pjdelport> http://home.pipeline.com/~hbaker1/Use1Var.html
04:01:03 <lambdabot> Title: 'Use-Once' Variables and Linear Objects
04:01:12 <FalconNL> Could anyone help shed some light on this Parsec problem?
04:01:13 <FalconNL> http://hpaste.org/11141
04:01:15 <FalconNL> I'm sure I'm doing something wrong but I haven't the foggiest idea what.
04:01:30 <luqui> pjdelport, right, I've actually done quite a lot with linear types, I just misparsed your query,  thanks though :-)
04:01:45 <pjdelport> luqui: cool
04:02:32 <quicksilver> luqui: yes, the key point is that there is only one version of an object around at a given time.
04:02:43 <quicksilver> luqui: and, at that time, that's the only version you care about.
04:02:56 <quicksilver> btu I'm not really sure if that's the essence or not.
04:03:03 <quicksilver> it's just totally tied in to the popular implementations.
04:03:16 <luqui> yeah... agreed
04:03:39 <quicksilver> FalconNL: you're using a tokeniser.
04:03:47 <quicksilver> FalconNL: the tokeniser is splitting . and : into symbol tokens
04:03:54 <quicksilver> so they'll never match "string"
04:04:07 <quicksilver> I think?
04:04:25 <quicksilver> I've never used parsec's tokeniser stuff.
04:04:56 <FalconNL> If that were the case, wouldn't "i." fail as well? I'd expect the period to be a separate token then too.
04:06:20 <quicksilver> I'd expect it to get pulled into the number token then
04:06:24 <quicksilver> :-/
04:08:26 <FalconNL> changing integerPrefix to "." and replacing the string integerPrefix in term with char '.' doesn't work either
04:10:41 <quicksilver> I thin it's something to do with the tokeniser trying to behave like haskell's lexer, FalconNL
04:10:45 <quicksilver> but I'm unsure of the details.
04:12:25 <chrisdone> cabal install constantly re-installs network-2.2.0.0
04:12:40 <chrisdone> anyone else get this?
04:14:00 <FalconNL> Hm... it seems it only does this for certain characters. It fails on . : < > ? but , ; [ ] ( ) are ok. How predictable :s
04:14:42 <EvilTerran> the first set are "symbol" characters in haskell, the second set are "reservedop", iirc
04:15:17 <quicksilver> FalconNL: my advise is don't use parsec's built in tokensier
04:15:25 <EvilTerran> yeah, i blame the tokeniser
04:15:28 <quicksilver> unless your plan is to use a very haskell-like lexical syntax.
04:15:37 <quicksilver> for simple stuff, don't bother with a tokeniser at all.
04:15:49 <quicksilver> for more complex stuff, write your own (possibly using parsec's tools for it)
04:16:05 <quicksilver> using haskell's tokeniser pins you to some of the fairly eccentric lexical choices haskell has.
04:16:05 <EvilTerran> i quite like writing a [Char] -> [Token] and a [Token] -> AST as two separate GenParsers
04:16:16 <quicksilver> yes, that's the approach I take, EvilTerran.
04:16:22 <quicksilver> (although I don't use Parsec for either)
04:16:28 <FalconNL> Thanks. Does anyone have a link explaining how to use a different/no tokenizer?
04:16:37 <quicksilver> and I generally don't even bother with simple parser combinators for the first.
04:16:42 <quicksilver> just write it by hand.
04:17:56 <FalconNL> This problem is merely a boiled down version of a more complicated grammar to describe the problem. I have it working in Parsec except for this little problem
04:20:10 <EvilTerran> FalconNL, well, as i said, you'd write a [Char] -> [Token] function any way you see fit
04:22:48 <EvilTerran> and then it's a case of tweaking the parser to work over Tokens instead of Chars
04:23:02 <EvilTerran> most of the time, this should actually simplify the parser
04:23:24 <EvilTerran> as you go through it - you should still be able to use Parsec.Expr
04:24:45 <FalconNL> Ok, I'll see what I can come up with. Thanks all.
04:36:38 <ivanm> quicksilver: it just looks like some kind of file/song chooser to me
04:38:50 <quicksilver> yes, it is. But there are reasons to prefer it to a file dialog.
04:39:11 <quicksilver> the eye can recognise distinctive album art much faster than it can recognise text
04:39:18 <quicksilver> also our eyes are designed to track motion
04:39:27 <ivanm> *shrug* I only use mplayer for some videos that vlc doesn't like anyway
04:39:41 <quicksilver> and it can display many more albums on screen than a normal file browser
04:39:42 <ivanm> for music, I just get mpd to play from a randomised song list
04:40:03 <ivanm> so whilst your GUI looks pretty, it doesn't look like anything I'd use ;-)
04:40:35 <quicksilver> fair enough.
04:40:38 <quicksilver> it doesn't work, anyway.
04:40:39 <ivanm> (Especially since I don't have album art for all my albums.... some of them I can't even tag because they were given to me as numbered mp3 files, so I"m not even sure who the artist is :s )
04:40:48 <ivanm> oh? in what way doesn't it work?
04:40:58 <hugo_> oh
04:40:59 <quicksilver> It just struck me as fairly harsh throwaway comment which I felt compelled to defend myself from.
04:41:04 <hugo_> i only have 10 mins till i leave
04:41:11 <hugo_> and i solved my problem of yesterday
04:41:15 <hugo_> strange thing about haskell
04:41:21 <Sxan> Sorry... I came late to the game.  What's the app?
04:41:22 <ivanm> quicksilver: didn't mean it as brash... more querying than anything else
04:41:35 <ivanm> Sxan: quicksilver is hacking on an mplayer gui
04:41:56 <hugo_> because i was inside an IO in where the file was not created, so even the file being there, it still answered as the file was not there
04:42:03 <hugo_> i thought it was a evaluation problem
04:42:11 <Sxan> Yup.  What's its name?
04:42:15 <hugo_> but it was a monad context...
04:42:28 <Sxan> Because it sounds like an app that I _would_ use ;-)
04:42:33 <ivanm> Sxan: not released yet ;-)
04:42:50 <hugo_> oh well, it works now, and it is more elegant :)
04:43:07 <Sxan> My wife is incessantly complaining because she can never find her music on the network music server.
04:43:15 <Sxan> She's used to browsing by the cover art.
04:43:49 <Sxan> Too bad.  I'm already looking forward to it. :-D
04:43:56 <quicksilver> Sxan: http://roobarb.jellybean.co.uk/~jules/Picture%20116.png
04:44:02 <quicksilver> as I was just telling ivan, though, it doesn't work.
04:44:10 <Saizan> i also need a nice gui with for a player that doesn't drag all my system resources, so far i've settled for exaile
04:44:11 <quicksilver> still if people actually wanted it that might encourage me to fix it.
04:44:12 <Sxan> Yeah, I heard.
04:44:27 <Sxan> Sweet!
04:44:47 <Sxan> What's the GUI toolkit?  Is it running on a Mac, or is that just a GTK theme?
04:45:01 <ivanm> mac is my guess
04:46:29 <quicksilver> it is running on a mac butnothing other than the title bar comes from there ;)
04:46:35 <quicksilver> it's written in opengl.
04:46:41 <Sxan> Nice.
04:46:42 <quicksilver> but it use wx to load fonts and images.
04:46:48 <Sxan> Definitely looking forward to it.
04:47:00 <Sxan> As long as it is portable...
04:47:13 <Sxan> opengl + wx should be fine, though.
04:47:30 <quicksilver> fiddly to install the deps, possibly, but fine ;)
04:48:52 <Sxan> Ubuntu has packages for the GL libs; I don't see one for the WX lib.
04:49:16 <Sxan> Oh, say... I'm struggling with something in Haskell; I've hit a performance-related ceiling and I'm not sure where to go from here.  Any good samaritans available?
04:49:57 <Axman6> Sxan: what's the question?
04:50:26 * ivanm wonders if IRC should have a general "don't ask to ask" meta-topic
04:50:27 <Sxan> Well... I've been trying to write what I thought was a small app (isn't that always how it starts?)
04:50:45 <Sxan> I was just gathering some statistics from an XML file... a count of how many times each tag occurs.
04:51:18 <Sxan> I'm using foldl' and Data.ByteStream.Char8, which is about my limit of performance tuning.
04:51:45 <Sxan> But running it on a 100MB XML file rapidly consumes huge amounts of memory.
04:52:13 <ivanm> Sxan: how are you reading the file?
04:52:34 <dolio> Data.ByteString.Char8 is strict byte strings.
04:52:41 <dolio> It reads the whole file into memory before doing anything else.
04:52:44 <EvilTerran> whups!
04:53:16 <Sxan> So... I don't know if this is so much a performance issue as a memory use one.
04:53:16 <Sxan> Actually, Char8 is probably irrelevant to the memory thing.  But foldl' should have taken care of any thunk issues, right?
04:53:51 <Sxan> Char8.getContents
04:54:03 <EvilTerran> you want Data.BS.Lazy.Char8, i suspect
04:54:06 <dolio> What happens if you use Data.ByteString.Lazy.Char8?
04:54:12 <EvilTerran> or is it Char8.Lazy?
04:54:12 <Sxan> dolio: I'll try.
04:54:19 <Sxan> No, I didn't use Lazy.
04:54:24 <dolio> One of the two. I can never remember.
04:54:25 <EvilTerran> we need a tag-based module system :P
04:54:32 <Sxan> But, please explain something for me...
04:54:39 <EvilTerran> Data.ByteString.(Char8 + Lazy)
04:54:51 <Sxan> If Char8 is strict byte strings, then shouldn't a 100MB file consume little more than 100MB?
04:54:59 <EvilTerran> indeed
04:55:10 <Sxan> The app sucked up 800MB before I nervously nuked it.
04:55:20 <dolio> What's your foldl' look like?
04:55:25 <EvilTerran> i suspect there may also be thunk leaks in your foldl - what representation are you using for your accumulator?
04:55:35 * dolio suspects tuples.
04:55:52 <EvilTerran> i was thinking Map String Int
04:55:55 <Sxan> Oh... I didn't mention that I'm also using Data.Map.
04:56:00 * Sxan looks sheepish
04:56:04 <dolio> Damn. :)
04:56:06 <Sxan> That's my other suspect.
04:56:12 <Sxan> process = B.foldl' parse (State "" (Just False) False 0 (singleton "/" 0) [])
04:56:14 <EvilTerran> forcing a map won't force the values, only the keys
04:56:25 <Sxan> But the map shouldn't get that big.
04:56:33 <quicksilver> the values will
04:56:35 <EvilTerran> a little seq-sprinkling may help
04:56:38 <quicksilver> they'll become huge thunks.
04:56:42 <Sxan> Hm.
04:56:47 <EvilTerran> your values will be thunks to the effect of "1 + 1 + 1 + 1 + ..."
04:56:50 <quicksilver> (1+1+1+1+1+1+1+1+1+1+1+1+1+1+1....
04:56:55 <dolio> Oh, it's a state monad computation?
04:56:55 <quicksilver> damn, EvilTerran beat me ;)
04:57:02 <dolio> Is lazy state the default?
04:57:06 <Sxan> dolio: Yes.
04:57:09 <Sxan> Lazy state?
04:57:17 <EvilTerran> @@ @read @run cycle "1 + "
04:57:18 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
04:57:21 <dolio> There are two state monads in mtl.
04:57:30 <dolio> Control.Monad.State.Lazy and C.M.S.Strict
04:57:40 <EvilTerran> even if it's strict, that won't help with the map values
04:57:47 <dolio> One can build up thunks, depending on how you use it.
04:57:49 <Sxan> Ugh.  Ok, we've passed my Haskell knowledge limit.
04:58:17 <Sxan> So, I need to seq the Map keys?
04:58:23 <igel> is there sth. like [Either a b] -> ([a], [b]) ?
04:58:24 <Sxan> And the counters?
04:58:41 <Sxan> No, but there are Maybe's.
04:58:45 <EvilTerran> Sxan, i suggest reading up on `seq` and co - an understanding of when to use strictness will probably be enough for you to gain a level in Haskell :)
04:58:58 <dolio> Lazy state is the one you get if you just import Control.Monad.State.
04:59:11 <dolio> So that could be the problem, too, theoretically.
04:59:12 <quicksilver> if you're using insertWith it may be enough to replace that with insertWith'
04:59:17 <quicksilver> which strictifies the value.
04:59:22 <quicksilver> I hope.
04:59:28 <Sxan> I'm not explicitly importing any Monad.
04:59:30 <EvilTerran> igel, i've seen it mentioned somewhere
04:59:41 <EvilTerran> Sxan, are you even using the State monad, or do you have something else called State?
05:00:01 <Sxan> I'm using alter, but I'll check for an alter'.
05:00:03 <Saizan> (State "" (Just False) False 0 (singleton "/" 0) []) wouldn't type if it was the State monad.
05:00:04 <EvilTerran> igel, but i don't think it's bundled with ghc
05:00:16 <EvilTerran> igel, it'd be a pretty easy foldr, i think
05:00:22 <dolio> Yeah, I guess not.
05:00:33 <Sxan> EvilTerran: I tried that, but I still have trouble wrapping my head around foldr.
05:00:42 <Saizan> igel, EvilTerran: there's partitionEithers in base-4 :)⇧
05:00:50 <pjdelport> foldr is great
05:00:55 <Sxan> pjdelport: I know.
05:01:09 <pjdelport> Sxan: it's just constructor replacement :)
05:01:09 <Sxan> It just isn't intuitive to me yet.
05:01:14 <igel> Saizan: yay
05:01:16 <Saizan> Sxan: that State constructor is from a datatype you've defined right?
05:01:21 <Sxan> Yes.
05:01:26 <EvilTerran> > foldr (first.(:) `either` second.(:)) ([],[]) [Left 1, Right 2, Left 3, Left 4, Right 5]
05:01:27 <lambdabot>       precedence parsing error
05:01:27 <lambdabot>          cannot mix `(.)' [infixr 9] and `eith...
05:01:29 <EvilTerran> do
05:01:37 <Saizan> Sxan: so you probably need to add strictness there, you're using it as accumulator
05:01:41 <EvilTerran> > foldr (either (first.(:)) (second.(:))) ([],[]) [Left 1, Right 2, Left 3, Left 4, Right 5]
05:01:42 <lambdabot>   ([1,3,4],[2,5])
05:01:46 <EvilTerran> shazam!
05:01:49 <pjdelport> Sxan: is foldr (:) [] intuitive, at least?
05:02:04 <Sxan> EvilTerran: See?  I'm not even sure I understand that.
05:02:10 <Sxan> pjdelport: Yes.
05:02:14 <Sxan> I understand how it works.
05:02:20 <EvilTerran> ?type either
05:02:21 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
05:02:27 <Sxan> I just can't translate how I think of foldls to foldr easily.
05:02:38 <pjdelport> foldl is weird
05:03:07 <Saizan> well, it also depends on your algorithm
05:03:08 <Axman6> > foldr f [1..4] :: Expr
05:03:09 <lambdabot>   Couldn't match expected type `Expr'
05:03:14 <Axman6> > foldr f [1..4] :: [Expr]
05:03:15 <lambdabot>   Couldn't match expected type `[Expr]'
05:03:19 <Axman6> no...
05:03:25 <Sxan> Which modules are loaded by lambdabot?
05:03:26 <EvilTerran> > foldr (\x (ls,rs) -> case x of Left l -> (l:ls,rs); Right r -> (ls,r:rs)) ([],[]) [Left 1, Right 2, Left 3, Left 4, Right 5]
05:03:27 <lambdabot>   ([1,3,4],[2,5])
05:03:31 <EvilTerran> that's equivalent
05:03:35 <Saizan> > foldr f z [1..4]
05:03:36 <lambdabot>   f 1 (f 2 (f 3 (f 4 z)))
05:03:39 <Axman6> > foldr f [a,b,c,d] :: [Expr]
05:03:40 <lambdabot>   Couldn't match expected type `[Expr]'
05:03:46 <Axman6> > foldr f [a,b,c,d]
05:03:47 <lambdabot>       Overlapping instances for Show ([a] -> [Expr])
05:03:47 <lambdabot>        arising from a us...
05:03:48 <EvilTerran> from expanding out the definition of "either"
05:03:52 <Saizan> Axman6: the base case!
05:04:00 <Axman6> > foldr f z [a,b,c,d]
05:04:00 <EvilTerran> ?src either
05:04:00 <lambdabot> either f _ (Left x)     =  f x
05:04:00 <lambdabot> either _ g (Right y)    =  g y
05:04:01 <lambdabot>   f a (f b (f c (f d z)))
05:04:08 <Axman6> about time!
05:04:09 <Axman6> rawr
05:05:15 <Sxan> Crap.  No alter' .
05:05:27 <Axman6> > foldl f z [a,b,c,d]
05:05:28 <lambdabot>   f (f (f (f z a) b) c) d
05:05:30 <EvilTerran> and a little eta-expansion and so on to un-pointsfree it
05:05:34 <pjdelport> Sxan: you can approach EvilTerran's foldr is a modification of the identity
05:06:05 <EvilTerran> > (\x (ls,rs) -> case x of Left l -> (l:ls,rs); Right r -> (ls,r:rs)) (Left 1) ([2],[3])
05:06:06 <lambdabot>   ([1,2],[3])
05:06:11 <Sxan> foldl' should be solving the outer thunk problem.
05:06:26 <EvilTerran> > either (first.(:)) (second.(:)) (Right 1) ([2],[3])
05:06:27 <lambdabot>   ([2],[1,3])
05:06:27 <pjdelport> Sxan: [] is "lifted" to ([],[])
05:06:53 <EvilTerran> > either f g (Left x) :: Expr
05:06:54 <lambdabot>   f x
05:07:02 <Sxan> Are you suggesting that using a right fold will solve the Map and the (+) issue?
05:07:07 <Sxan> Issue(s)?
05:07:52 <pjdelport> Sxan: and (:) is lifted in either, to handle both cases
05:08:16 <pjdelport> and routed to the first or second list in the tuple using first and second
05:08:21 <Saizan> Sxan: foldr is good if the function you're passing it is sufficiently lazy in its second parameter
05:09:07 <Sxan> Hm.  The function is just a bunch of pattern matches returning a State.
05:09:25 <quicksilver> as a general rule, foldr is good if you are prdocuing a streaming answer which is to be lazily consumed
05:09:28 <quicksilver> (like a list)
05:09:40 <quicksilver> foldl' is good if you are producing an 'atomic' summary result.
05:09:44 <pjdelport> > foldr (either (:) (:)) [] [Left 1, Right 2, Left 3, Left 4, Right 5]
05:09:46 <lambdabot>   [1,2,3,4,5]
05:09:47 <Saizan> Sxan: if not foldl' is the right choice, but you've to be careful about the accumulator, since if it's something like e.g. a tuple the fact that foldl' is stricter then foldl is not enogh, since thunks can be hiding inside the two fields
05:09:48 <Sxan> However, in the State are a Map, an accumulator, an array of Strings, and some other stuff that probably isn't relevant.
05:09:52 <quicksilver> my understanding of your code is that foldl' is the one choose.
05:10:02 <rog_> is there a standard class for types that can be created with "default" values. kind of like mzero, but not necessarily for monads? i'm thinking something like: class New a where new :: a
05:10:08 <pjdelport> Sxan: there's the halfway point, which just gets rid of the Either
05:10:18 <Saizan> Sxan: the first thing to do is make the the fields of State strict
05:10:32 <Axman6> rog_: i think you can use record syntax for that
05:10:46 <Saizan> Sxan: so if you have data State = State (Map Foo Bar) use data State = State !(Map Foo Bar)
05:10:50 <Axman6> Thing { val = 10 :: Integer }
05:11:02 <Axman6> someone correct me if i'm wrong
05:11:04 <Sxan> Saizan: Thanks, I'll try that.
05:11:15 <oliverss> hello all ...
05:11:23 <Saizan> Sxan: and compile with -O2
05:11:31 <rog_> Axman6: how can i use record syntax so that arbitrary code can create a new instance of a record type with all fields initialised to their default values?
05:11:41 <Saizan> rog_: the nearer we get is Monoid, but it also has mappend
05:12:17 <oliverss> how good is the haskell book by Paul G ?
05:12:18 <Axman6> rog_: yeah... that's beyond my knowledge of such things
05:12:27 <Sxan> Whenever I do stuff like this, I feel like I'm defeating the purpose of Haskell...
05:12:28 <rog_> Saizan: maybe i'm better off just passing around the default instance. but it gets tedious after a while...
05:13:19 <Saizan> rog_: well, you can define a class yourself
05:13:55 <quicksilver> rog_: I've thought class Default would be handy, sometimes.
05:14:07 <quicksilver> rog_: although ideally you want a little simple metaprogramming to derive instances.
05:14:09 <Axman6> rog_: could always make a function that results in the default values you want: defaultThing = Thing 10 "Stuff"
05:14:37 <rog_> Saizan: i think i will. it means that i should be able to automatically derive instances for largish records, which should save time and code.
05:15:50 <Saizan> not automatically..
05:15:52 <rog_> i've got fairly large records with lots of e.g. (Double, Double) etc tuples inside, and mutation functions that change one element only. it's a bit of a pain to do all the initialisation manually.
05:16:00 <rog_> oh
05:16:22 <Saizan> unless you e.g. write a derivation using Data.Derive
05:16:45 <rog_> i'll have to look that up
05:16:46 <Saizan> which boils down to using template-haskell
05:17:30 <luqui> rog_, data-accessor-template!
05:18:05 <luqui> oh maybe not.  I just saw an opportunity for a plug, and I have no shame.
05:18:50 <luqui> rog_, there's also a somewhat misguided data-default on hackage
05:20:06 <rog_> luqui: well, that's pretty much what i was thinking of doing. why is it misguided?
05:20:29 <luqui> what does it mean?  what do you gain by making it a typeclass?
05:22:06 <luqui> is defaultFoo = Foo { ... } no good?
05:22:29 <rog_> in my case, i need a base value that i can start to mutate. the values of components of the original that aren't mutated are not of too much concern. hence default would be a reasonable solution. currently, i have to pass around a default value. which might be the best thing after all, actually.
05:23:05 <rog_> luqui: it's no good if you don't know statically know the type you're dealing with.
05:23:12 <quicksilver> luqui: it's just nice to be able to type 'default' and have it choose the right one.
05:23:20 <quicksilver> a nice simple example of using a typeclass.
05:23:33 <luqui> I don't get it...
05:24:24 <luqui> when would you type default?
05:25:25 <quicksilver> the same place you'd type defaultFoo
05:25:28 <luqui> rog_, are you talking about something like TV, where you have a UI that is mutating these?
05:25:41 <rog_> luqui: TV?
05:25:55 <luqui> tangible values.  basically user interfaces for arbitrary types.
05:26:22 <luqui> quicksilver, and when would that be parametric?
05:27:04 <quicksilver> it wouldn't, often.
05:27:05 <luqui> or is this simply using typeclasses as a notational convenience?
05:27:08 <rog_> i'm not familiar with TV, but kind of. i've got what amounts to a user-interface dynamically composing sets of mutations on records.
05:27:12 <quicksilver> just like (+) is very seldom parametric.
05:27:28 <quicksilver> but it would aid refactoring, sometimes
05:27:34 <quicksilver> you could move stuff around and 'default' woudl still work.
05:27:43 <rog_> luqui: i think using type classes is always a notational convenience. isn't it?
05:27:53 <quicksilver> there might be some parametric cases but not off the top of my head.
05:28:10 <luqui> well you can always use dictionary passing in lieu of it, but I'm more speaking of the case where there would otherwise be no dictionary passing whatsoever
05:28:21 <luqui> i.e. the compiler always knows the exact type you're talking about
05:28:51 <rog_> luqui: there would be "dictionary" passing in this case as you'd have to pass in the default value itself
05:29:05 <rog_> luqui: i.e. a one-element dictionary containing one value
05:29:49 <luqui> well from your description it sounds like I don't really grok what you're trying to do.   Okay, so you have this default value
05:29:56 <luqui> what operations can you do to it?
05:30:58 <luqui> if you can update it using record syntax, then you know exactly what type it is (and could use defaultFoo instead).  If you can't, then you must be able to do *something* to it
05:31:04 <rog_> ... and after this discussion, i think i will actually do that. the only reaon for using a type class is if the derivation would be automatic for records. i.e. i could say "data D = D {x :: Double, y ::  (Double, Double), z :: String}" and never have to mention all the fields together again.
05:31:23 <quicksilver> foo <- newIORef (Foo { bar = defaultBar, baz = defaultBaz, bam = defaultBam })
05:31:41 <quicksilver> sometimes i'd rather not have to write the (obvious) definition for defaultFoo
05:31:52 <rog_> exactly
05:32:16 <luqui> I always would :-)  but okay, it's a very minor convenience
05:32:17 <quicksilver> I wise I could just say
05:32:19 <rog_> just like the "zero values" default initialisation rules for structs in C are often convenient
05:32:21 <hackage> Uploaded to hackage: kibro 0.4.1
05:32:24 <quicksilver> foo <- newIORef (default)
05:32:26 <luqui> that would make a *lot* more sense if we could do induction over data definitions
05:32:27 <quicksilver> and have it all work.
05:32:31 <luqui> (as in Data.Derive)
05:32:39 <quicksilver> yes, I'm assuming you'd use Data.Derive
05:32:43 <quicksilver> the class *alone* doesn' win much.
05:32:52 <quicksilver> what wins something is the class + automatic derivation.
05:32:52 <luqui> oh, I missed that part.
05:32:56 <rog_> you're right.
05:33:20 <quicksilver> and what it wins, mostly, is the ability to redesign your data structures without updating hundreds of 'defaultFoo' methods.
05:33:29 <quicksilver> luqui: still, it is a pretty minor convenience.
05:33:42 <quicksilver> as is witnessed by the fact that I've never actually got off my arse and written it.
05:33:50 <quicksilver> but I recognised the issue that rog was describing.
05:34:16 <luqui> well for his application, as in "user-visible default value" it makes more sense to me
05:34:25 <ivanm> :o I thought by using seq I had gotten rid of my stack overflow problems... but I'm _still_ getting them!
05:34:27 <luqui> internally I have never had a need for "defaults" per se
05:34:34 <ivanm> thing is, it doesn't always happen :s
05:35:15 <ivanm> oh, wait, I think I know why.... I added a counter and forgot to make it !Int
05:35:16 <rog_> quicksilver: the way things are at the moment, if i add a new field, i've got to add a) the field itself; b) a "mutator" record, holding get and put functions for each field, and c) the default value for the field.
05:35:41 * quicksilver nods.
05:35:47 <rog_> quicksilver: i'm starting to think i should look at TH. i'm a bit reluctant though.
05:36:13 <luqui> TH is cool, but it's pretty seldom that you need to use it directly.
05:37:17 <quicksilver> *nod* rog_
05:37:17 <quicksilver> objAmbientL   = objL<.>Lens (\ms -> (objAmbient ms , \v -> ms {objAmbient = v}))
05:37:25 <quicksilver> rog_: my code is full of stuff like that :)
05:37:34 <quicksilver> at least I only have to write it once per field
05:37:42 <quicksilver> and it's pretty easy to copy-paste for a new field
05:37:55 <plutonas> does haskell have anything named "err"?
05:38:05 <SamB_XP> err?
05:38:06 <luqui> _that_ is what data-accessor-template is for :-)
05:38:14 <plutonas> SamB_XP: yes, i can't find anything related
05:38:22 <SamB_XP> why ?
05:38:26 <luqui> plutonas, not that I know of.  what's the context?
05:38:36 <quicksilver> @err
05:38:36 <lambdabot> Yeh scurvy dog...
05:38:39 <plutonas> i'm stupid, sorry
05:38:42 <SamB_XP> heh
05:39:02 <plutonas> the prof said i should use err for some thing of the assignment, and i was looking everywhere in haskell docs to find it
05:39:06 <plutonas> though it was defined just above
05:39:09 <plutonas> :P
05:39:29 <SamB_XP> hehehe
05:39:33 <ivanm> lol
05:39:43 <ivanm> I love it when that happens
05:39:52 <plutonas> sometimes the brain stops working...
05:40:08 <quicksilver> luqui: there were reasons I didn't use data-accessor
05:40:18 <quicksilver> luqui: although, its API seems to have evolved quite a bit since I didn't use it.
05:40:21 <ivanm> its even better when you're skimming through some paper/notes and you find an unfamiliar term in an equation/algorithm and can't work out wtf it is, until you notice it they defined it within the big chunk of text just before :s
05:40:45 <luqui> quicksilver, heh "evolved".
05:40:56 <luqui> it certainly has become more complicated.
05:41:31 <quicksilver> luqui: when I looked you didn't have the nice infix hacks that I like.
05:41:52 <luqui> heh ghod forbid you write them yourself =P
05:41:53 <quicksilver> I still have a MonadLens hack you don't have.
05:42:01 <quicksilver> luqui: well I'd already written them.
05:42:08 <quicksilver> so there was no compelling reason to move my working code
05:42:09 <luqui> do tell. it's mostly Henning's thing now.
05:42:15 <rog_> quicksilver: i found it a bit odd there's no concept unifying the getting and/or the setting of a particular field. so i defined this: http://hpaste.org/11142#a0 which i found useful.
05:42:19 <quicksilver> well it's like your MonadState
05:42:24 <quicksilver> but the monad is just a parameter
05:42:29 <quicksilver> doesn't have to be MonadState
05:42:51 <quicksilver> data MonadLens m s = MonadLens { mlGet :: m s , mlSet :: s -> m () }
05:43:00 <luqui> oh it's a dictionary for statelike things
05:43:17 <quicksilver> you can instantiate it with an IORef, for example.
05:43:21 <quicksilver> as well as with a State monad
05:43:26 <luqui> that's pretty nice
05:44:05 <quicksilver> then you can run any "state action" in an abitrary monad using a monad lens
05:44:11 <quicksilver> withLens :: Monad m => MonadLens m s -> (s -> m (s,a))  -> m a
05:44:32 <quicksilver> which I use for various types of 'caching' actions which update their own cache
05:44:35 <quicksilver> (font loading/rendering)
05:45:08 <BeelsebobWork> @type on
05:45:09 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
05:45:40 * luqui ponders
05:45:55 <BeelsebobWork> @type (\g -> uncurry ((||) `on` g))
05:45:56 <lambdabot> forall a. (a -> Bool) -> (a, a) -> Bool
05:46:04 <BeelsebobWork> good good :)
05:46:18 <luqui> if that were MonadLens { mlGet :: m a , mlSet :: a -> m s }, then a lens is just a MonadLens over (s ->)
05:46:42 <luqui> maybe.  the types match up at least.
05:47:13 <luqui> oh but where is s coming from.  darn.
05:47:23 <quicksilver> luqui: yeah, the "s" is implicit
05:47:28 <quicksilver> it's buried somewhere in the 'm'
05:47:47 <quicksilver> for example it might be MonadState r, but you're actually accessing 's'
05:47:56 <luqui> right
05:48:03 <quicksilver> (via composition with another lens)
05:48:05 <quicksilver> or it might be IO
05:48:17 <quicksilver> and the actual value is buried in some hideous obscure fashion
05:48:19 <quicksilver> (IORef)
05:48:24 <luqui> I'd love to see a generalization that covers both usual lenses and monad lenses in one go...
05:50:15 <Sxan> Hmmm.
05:50:45 <Sxan> Ok, I think I've seq'ed everything, and I'm still having memory issues.
05:50:52 <Sxan> Well, I've sequed what counts.
05:51:10 <BeelsebobWork> hmm, is there an abstraction of a fold where each step on the fold can add to the things you need to fold on
05:51:34 <luqui> BeelsebobWork, well it's not so much of a fold then is it?
05:51:34 <Sxan> ... unless... does ghci cause everything to evaluate at print time?
05:51:50 * rog_ didn't know about Lenses
05:51:57 <Saizan> Sxan: _don't_ use ghci for these things, compile instead
05:52:00 <pjdelport> BeelsebobWork: it could just do that before returning?
05:52:01 <BeelsebobWork> @hoogle (a -> b -> b) -> (a -> [a]) -> b -> [a] -> b
05:52:01 <lambdabot> No results found
05:52:14 <BeelsebobWork> pjdelport: do what before returning?
05:52:15 <luqui> BeelsebobWork, oh I see what you mean, duh
05:52:23 <Sxan> Saizan: I was worried about that.
05:52:33 <BeelsebobWork> so each step in the fold can expand an element, and fold becomes bfs
05:52:42 <luqui> BeelsebobWork, that sig just looks like (fold ... . bfs)
05:52:43 <Saizan> Sxan: with -O2 or al least -O
05:52:45 <Sxan> I don't know how else to see what's going on,though.  *Something* is thunking, but what?
05:52:58 <BeelsebobWork> luqui: yep, that sounds about like it
05:53:15 <Saizan> Sxan: how big is your program? can you paste it somewhere?
05:53:18 <BeelsebobWork> @hoogle bfs
05:53:19 <lambdabot> No results found
05:53:23 <BeelsebobWork> :(
05:53:45 <Sxan> Saizan: Yeah.  Hold on.
05:53:51 <BeelsebobWork> @hoogle (a -> [a]) -> a -> [a]
05:53:51 <lambdabot> Data.Generics.Basics gmapMo :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a
05:53:52 <lambdabot> Data.Generics.Basics gmapMp :: (Data a, MonadPlus m) => (a -> m a) -> a -> m a
05:53:52 <lambdabot> Data.Generics.Basics gmapM :: (Data a, Monad m) => (a -> m a) -> a -> m a
05:54:03 <pjdelport> BeelsebobWork: sounds like unfold, to some extent
05:54:17 <BeelsebobWork> pjdelport: it does a bit doesn't it
05:54:24 <luqui> > let bfs f xs = xs ++ concatMap f xs in bfs (\x -> [x*2,x*3-1]) [1]
05:54:25 <lambdabot>   [1,2,2]
05:54:34 <luqui> > let bfs f xs = xs ++ bfs (concatMap f xs) in bfs (\x -> [x*2,x*3-1]) [1]
05:54:35 <lambdabot>   Couldn't match expected type `[b]' against inferred type `a -> [b]'
05:54:50 <Sxan> Saizan: http://www.ser1.net/CountTags2.hs
05:54:51 <BeelsebobWork> > let bfs f xs = xs ++ map bfs (concatMap f xs) in bfs (\x -> [x*2,x*3-1]) [1]
05:54:53 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a] -> t
05:54:53 <lambdabot>      Pro...
05:55:00 <Sxan> Saizan: Thanks, BTW.
05:55:21 <luqui> why do we suck at haskell!
05:55:27 <BeelsebobWork> > let bfs f xs = xs ++ concatMap bfs (concatMap f xs) in bfs (\x -> [x*2,x*3-1]) [1]
05:55:28 <lambdabot>   Couldn't match expected type `[a]' against inferred type `[a] -> t'
05:55:35 <BeelsebobWork> I suck twice as much as you though :(
05:55:50 <serussell> Oy.
05:55:54 <luqui> oh duh
05:56:04 <luqui> > let bfs f xs = xs ++ concatMap bfs f (concatMap f xs) in bfs (\x -> [x*2,x*3-1]) [1]
05:56:05 <lambdabot>   Couldn't match expected type `[b]' against inferred type `[a] -> t'
05:56:08 <BeelsebobWork> > let bfs f xs = xs ++ concatMap (bfs f) (concatMap f xs) in bfs (\x -> [x*2,x*3-1]) [1]
05:56:09 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
05:56:09 <lambdabot>        Expect...
05:56:11 <luqui> oh fcksniwjhefpiuwehiuhgw
05:56:16 <BeelsebobWork> >.<
05:56:18 <luqui> > let bfs f xs = xs ++ bfs f (concatMap f xs) in bfs (\x -> [x*2,x*3-1]) [1]
05:56:19 <lambdabot>   [1,2,2,4,5,4,5,8,11,10,14,8,11,10,14,16,23,22,32,20,29,28,41,16,23,22,32,20...
05:56:21 <luqui> tada!
05:56:24 <BeelsebobWork> YAY!
05:56:32 <luqui> programming by random perturbation!
05:56:39 <BeelsebobWork> hehe
05:57:05 <ivanm> grrrr..... I'm sure my code follows the required algorithm correctly, but my results don't match up with what I should be getting :@
05:57:20 <BeelsebobWork> ivanm: time for some algorithmic debugging!
05:57:29 <pjdelport> BeelsebobWork: oh, the other thing it sounds like is repeated binding in the list monad
05:57:31 <ivanm> yeah :s
05:57:57 <ivanm> thing is, I've gone over the algorithm a couple of times... and doing it step by step for a simple number of cases reveals nothing :s
05:58:04 <pjdelport> though it looks like you're there already
05:58:21 <ivanm> I can't test the whole thing, since even for a 2x2 grid it runs for around 27000 iterations :s
06:00:10 <ddarius> Find and test the invariants that the algorithm maintaits
06:00:24 <luqui> BeelsebobWork, oh, don't forget the base case in bfs.  it sneaks up on you.
06:00:33 <ivanm> ddarius: there's no real invariants :s
06:00:42 <Saizan> Sxan: edit your definition of State so that you have ", count :: !Integer  , tags  :: !Map String Integer"
06:00:44 <ivanm> http://en.wikipedia.org/wiki/Wang_and_Landau_algorithm <-- that's what I'm using
06:00:44 <luqui> > let bfs f xs = xs ++ bfs f (concatMap f xs) in bfs (const []) [42]
06:00:45 <lambdabot> Title: Wang and Landau algorithm - Wikipedia, the free encyclopedia
06:00:52 <BeelsebobWork> luqui: yeh, it's always useful ;)
06:00:56 <ddarius> ivanm: There are always invariants.
06:00:57 <luqui> (output was [1,   )
06:01:00 <lambdabot>   thread killed
06:01:02 <luqui> er [42,
06:01:02 <Sxan> Saizan: Wow.  Didn't know you could do that.
06:01:03 <BeelsebobWork> luqui: oh
06:01:05 <BeelsebobWork> blimeh
06:01:13 <BeelsebobWork> oh, that makes sense
06:01:39 <ivanm> ddarius: well, in that case I can't think of what they might be
06:02:01 <quicksilver> luqui: well they are unified if the Monad is 'State r'
06:02:13 <quicksilver> luqui: then (unwrapping the definition of state) you get a normal lens.
06:02:16 <Sxan> Saizan: Can I take out the seqs from "update?"
06:02:18 <quicksilver> modulo efficiency issues.
06:02:37 <Saizan> Sxan: they weren't helping anyhow
06:03:11 <Saizan> Sxan: you might need this instead -> updateParents c (p:ps) m = m `seq` updateParents c ps (update c p m)
06:03:17 <Sxan> It is still running up to 941MB
06:03:30 <BeelsebobWork> gah -- why does unionMap not exist in Data.Set
06:03:47 <luqui> BeelsebobWork, union*Map*?
06:03:55 <BeelsebobWork> luqui: unions . map
06:03:56 <luqui> oh you mean like concatMap
06:03:59 <BeelsebobWork> exactly
06:04:08 <luqui> would it be any more efficient?
06:04:12 <ivanm> BeelsebobWork: because they're waiting for you to define it ;-)
06:04:33 <BeelsebobWork> luqui: I don't think so -- but it would be nice to have the mirror of the list functionality where appropritae
06:04:50 <Sxan> Saizan: Or am I doing some really stupid with this parser?
06:04:51 <BeelsebobWork> also... gief not having to reimplement everything for Data.Set just because it can't be a functor :'(
06:05:23 <luqui> if only everything had decidable ordering
06:05:34 <BeelsebobWork> indeed
06:05:38 <Saizan> Sxan: i can't exactly tell what you're trying to do, but i suspect there's a simpler way to write this
06:06:00 <serussell> Dang.  No, the seq in updateParents didn't help, either.
06:07:58 <serussell> Saizan: Is there a more haskell-ish way to do this?  It seems like a fairly complex solution to a trivial problem.
06:08:09 <jcpetruzza> hi, i'm trying ghc 6.10-rc and i can't get a package configured
06:08:38 <jcpetruzza> i get an error saying that QuickCheck-1.1.0.0 requires base-3.0.3.0 while the other packages require base-4.0.0.0
06:08:42 <Saizan> serussell: i'm not clear on what the problem "is" :)
06:08:59 <Saizan> it's not clear to me, i mean
06:09:05 <Sxan> Saizan: Sorry. I keep getting dumped out of IRC.
06:09:24 <Sxan> It takes a couple of minutes for the server to release my nick.
06:09:27 <Saizan> jcpetruzza: update Cabal/cabal-install
06:10:19 <Saizan> Sxan: yeah, i recognized it was you, but i still don't know the problem you're trying to solve
06:10:23 <Sxan> Oh.
06:10:35 <Sxan> I'm counting the number of times tags occur in an XML file.
06:10:37 <jcpetruzza> Saizan: thanks, so Cabal-1.5.5 that comes with ghc-6.10 is already deprecated? :)
06:11:49 <BeelsebobWork> @hoogle Set (Set a) -> Set a
06:11:50 <lambdabot> Data.Set deleteMax :: Set a -> Set a
06:11:50 <lambdabot> Data.Set deleteMin :: Set a -> Set a
06:11:50 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
06:11:56 <BeelsebobWork> bah
06:12:11 <Sxan> Saizan: I wrote it in 21 lines of Ruby, but on large files it was too slow.  The Haskell version is much larger, and blows up with out-of-memory, so I'm thinking I'm going about this wrong.
06:12:12 <BeelsebobWork> so I have to S.unions . S.toList . S.map?
06:12:14 <Saizan> jcpetruzza: well we have Cabal-1.6 but the one that comes with the rc should work :)
06:12:18 <BeelsebobWork> laaaaaaaaaame
06:12:58 <Saizan> jcpetruzza: but you've to recompile the darcs version of cabal-install, and it currently needs 1.6
06:13:47 <Saizan> Sxan: yeah, but from the code i can't tell what you're trying to do, so i can't tell how i'd write it in haskell
06:14:29 <ddarius> ivanm: That's why I split it into two steps: -find- and test the invariants.
06:14:31 <jcpetruzza> Saizan: just to see if I understand, does that mean that one won't be able to use runhaskell Setup configure && etc to install packages?
06:15:25 <Saizan> jcpetruzza: you wills till be able to do that
06:15:56 <ivanm> ddarius: yes, and I've been looking, but can't find anything that is an invariant (well, I could think of one thing that checks a shortcut calculation I'm doing, which upon testing does seem to be valid)
06:15:58 <Saizan> jcpetruzza: maybe i've misunderstood your situation, you're getting a warning from runhaskell Setup configure about inconsistent dependencies?
06:16:11 <Sxan> quicksilver: BTW, if you want someone to guinea pig your app for you, let me know.
06:16:36 <Sxan> Saizan: I'm trying to see how much space tags in an XML file consume.
06:17:03 <jcpetruzza> Saizan: exactly. /Setup configure --user gives me this error
06:17:20 <Saizan> jcpetruzza: but it should be just a warning, you can continue with build
06:17:38 <Sxan> Saizan: So, "<a><b/><b/></a>" would be [/a=15, /a/b=8]
06:18:06 <Saizan> jcpetruzza: Cabal-1.6 should not give a warning at all in the case of base3 vs base4
06:18:46 <Sxan> This was originally just to generate some statistics for work, but I got curious about what the solution would look like in Haskell.  I thought it'd be trivial :-)
06:19:08 <jcpetruzza> Saizan: ok, i see. and if it builds ok, i shouldn't expect runtime errors due to linkin problems, right?
06:19:26 <Sxan> In any case, I think my solution should work, if I can figure out the memory problem.
06:19:28 <Saizan> jcpetruzza: right, ghc guarantees that
06:19:40 <ddarius> ivanm: For recursive code, one tends to talk about induction hypotheses rather than invariants (which are related.)  Also, you want the invariants/induction hypotheses from the algorithm not your code.
06:19:53 <Saizan> Sxan: i see
06:20:08 <ivanm> ddarius: yeah, and I'm basing them off the algorithm....
06:20:18 <ivanm> ddarius: can you see any obvious ones here? http://en.wikipedia.org/wiki/Wang_and_Landau_algorithm
06:20:20 <lambdabot> Title: Wang and Landau algorithm - Wikipedia, the free encyclopedia
06:21:12 <ivanm> my problem is that the values I get from the variable they call log_g is roughly uniform, when it should be the log of a gaussian :s
06:21:23 <Sxan> Saizan: Is there any other place where there could be trouble?
06:21:28 <ddarius> Well, heck, with a term like "energy" one possibility immediately suggests itself.
06:21:46 <ivanm> hmmmm?
06:21:47 <Sxan> Saizan: count and tags are strict, and I'm seq'ing the map.
06:22:31 <ivanm> ddarius: energy in the system isn't constant, if that's what you mean
06:23:18 <Saizan> Sxan: how many different tags you expect to have?
06:24:34 <Sxan> About 63 unique tags.
06:24:54 <Sxan> But 191k occurances.
06:25:51 <Sxan> Saizan: The deepest tag is no more than 5 levels down, so the maximum tag length is on the order of 60 chars.
06:26:14 <Sxan> Saizan: I don't see currentTag or paths being an issue.
06:26:37 <Sxan> Saizan: And the Map shouldn't have more than about 60 entries.
06:26:59 <Saizan> Sxan: you could use memory profiling
06:27:02 <ddarius> ivanm: Is the system guaranteed to converge?  Does it converge monotonically?
06:27:12 <Saizan> ?google ghc manual heap profiling
06:27:15 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html
06:27:15 <lambdabot> Title: 6.4.�Profiling memory usage
06:27:39 <Sxan> Saizan: Thanks.  I'll look into that.
06:27:51 <ivanm> ddarius: converge, kind of... monotonically, I'm not sure about
06:28:06 <Sxan> Saizan: Thanks for your help.  Enough fun for this morning... I'm going to head into work now.
06:28:42 <Axman6> @hoogle Int -> Word32
06:28:42 <lambdabot> Prelude toEnum :: Enum a => Int -> a
06:28:42 <lambdabot> Data.Bits bit :: Bits a => Int -> a
06:28:42 <lambdabot> Data.Bits clearBit :: Bits a => a -> Int -> a
06:28:49 <Saizan> Sxan: np
06:30:00 <Saizan> Sxan: do you know how i could easily generate a test case?:)
06:30:24 <Sxan> Hm.
06:30:32 <Sxan> Saizan: Like, sample input data?
06:30:48 <Axman6> bleh, i'm using some code that uses the function intToWord32, and i can't find it anywhere. seems to have been in Hugs (in 2001)
06:31:01 <quicksilver> use fromIntegral
06:31:03 <Saizan> Sxan: yeah
06:31:13 <Sxan> Saizan: I call it with:
06:31:16 <Sxan> import CountTags2
06:31:16 <Sxan> import Data.ByteString.Char8 as B hiding (putStrLn)
06:31:16 <Sxan> main = do
06:31:16 <Sxan>   contents <- B.getContents
06:31:16 <Sxan>   putStrLn $ show $ countTags contents
06:31:37 <Sxan> Saizan: Which OS are you on?
06:32:57 <Saizan> Sxan: linux
06:35:05 <Sxan> Saizan: Small, or large enough to be a noticable memory hog?
06:36:07 <Saizan> Sxan: large enough, but if it's a problem don't worry
06:37:55 <Sxan> Saizan: Hmmm...
06:38:14 <Sxan> Saizan: On small files, it behaves.
06:38:43 <Sxan> Saizan: I tried a 500K file, and it pegged my CPU, but didn't consume more than 5MB RAM.
06:38:52 <Sxan> Saizan: I had to kill it; it didn't complete.
06:38:59 <Sxan> Saizan: I wonder if something else is going oden.
06:39:04 <Sxan> s/oden/on/
06:39:15 <Sxan> Saizan: One sec, I'll paste a URL.
06:39:42 <Saizan> Sxan: the memory wasn't growing?
06:39:51 <Sxan> Saizan: No.
06:39:59 <Sxan> Not on the 500k file.
06:41:26 <Sxan> Saizan: Try this file:
06:41:28 <Sxan> http://hg.germane-software.com/rexml/raw-file/2c6d32696e1f/test/data/ofbiz-issues-full-177.xml
06:41:35 <lambdabot> http://tinyurl.com/43znot
06:42:49 <Sxan> Wow.  strace on that is useless.
06:43:32 <jeffz`> strace is only really for troubleshooting systemcalls
06:43:37 <Sxan> Saizan: Ok, I'm going to have to do the profiling, because this is slower than the Ruby version.  I'm doing something really wrong.
06:43:49 <Sxan> jeffz`: Yeah, but I'd expect some interaction with the system.
06:43:51 <quicksilver> Sxan: are you compiling with optimisation? just checking.
06:44:03 <Sxan> quicksilver: Yes, -O2.
06:44:11 <quicksilver> did you paste the code?
06:44:28 <Sxan> Actually, "slower" is not accurate... it doesn't seem to be completing.
06:44:43 <Sxan> quicksilver: Yup!  Way back... a URL.
06:44:54 <Sxan> http://www.ser1.net/CountTags2.hs
06:44:58 <zachk> i received "Programming in Haskell" by Graham Hutton the other day for my birthday. I am quite pleased with it and I am up to chapter 5. Thank you #haskell for the recommendation :-D
06:46:35 <Sxan> Yay lambdabot!
06:51:11 <set_theory> hello
06:51:20 <Sxan> Hello.
06:52:03 <Saizan> it looks like all the time is spent in update
06:52:39 <Sxan> Saizan: Did you get it to complete with that 500k file?
06:53:06 <set_theory> I was wondering if anyone had good examples of haskell code used to compute Cantor's diagonal theorem?
06:53:19 <Sxan> Saizan: If I could do this without Map, I would.
06:55:08 <vixey> set_theory: it's not clear what you mean
06:57:09 <Saizan> Sxan: maybe there's a bug so that you're calling it too many times?
06:57:29 <Sxan> Saizan: Possibly.
06:57:49 <opqdonut> are there (la)tex modes for writing "functional" pseudo-code?
06:58:06 <Cale> set_theory: you mean, something like a bit of code which given a list of streams of boolean values, finds a stream of booleans which is not in the list?
06:58:16 <Sxan> Saizan: The size of each child has to be added to the size of all ancestors.
06:58:29 <dblazakis> opqdonut: lhs2tex might help
06:58:40 <Sxan> Saizan: I could optimize it by performing the addition at the end, rather than inline.
06:59:13 <opqdonut> dblazakis: hmm, maybe
06:59:14 <set_theory> well, i would like to code something that would return the values located @ the n_th position within the enumeration of Cantor's diagonal
06:59:20 <Sxan> Saizan: That would be a bit more effort, tho.
06:59:57 <opqdonut> i'm after something like the code listings in okasaki
07:00:05 <Cale> set_theory: well, the nth element of a list xs can be obtained using xs !! n
07:00:26 <Cale> > [3,6..] !! 10
07:00:27 <lambdabot>   33
07:00:30 <Sxan> Saizan: Which I'm not opposed to, mind you, except that the program is already larger than I was hoping for.
07:01:01 <set_theory> Is there perhaps an example of this?  I am just starting out learning Haskell
07:01:09 <dblazakis> opqdonut: i don't have his book, but i've seen him writing in ML
07:01:22 <quicksilver> Sxan: in any case, that doesn't explain the memory blowup.
07:02:45 <Sxan> quicksilver: I don't believe that it explains the performance issue, either.
07:03:14 <Sxan> Hmm...
07:03:23 <quicksilver> could there be a blowup with malformed XML?
07:03:30 <quicksilver> like an improperly terminated tag.
07:03:40 <Sxan> Actually, there are a lot of wierd behaviors about this.
07:03:53 <Sxan> quicksilver: I don't believe so.  I'm not doing any real parsing of  XML, per se.
07:04:19 <Sxan> If a tag isn't closed then the worst that can happen is that the child node isn't created.
07:04:19 <quicksilver> yes, but you are growing 'currentTag'
07:04:36 <vixey> set_theory: example of what?
07:04:44 <quicksilver> in a way which is only guaranteed to work if the '>' comes at the right time.
07:04:49 <Sxan> quicksilver: There's a termination clause for currentTag, caused by a space or a '/'
07:05:12 <Sxan> The only way that could fail is if there literally was < followed by one really long tag name.
07:05:15 <quicksilver> yes, there is.
07:05:19 <quicksilver> but you see what I mean?
07:05:22 <Sxan> Yes.
07:05:29 <quicksilver> there is a class of behaviour caused by malformed XML
07:05:38 <Sxan> True enough.
07:05:55 <set_theory> Actually, I think i've found what I'm looking for, thanks for the help all
07:05:56 <Sxan> I don't believe that any of my sample XMLs have that particular problem.
07:06:05 <vixey> set_theory: ...
07:06:35 <Sxan> quicksilver: In fact, I'm not even matching tags.
07:06:47 <Sxan> quicksilver: The code works on "<a><b></a>"
07:07:09 <Sxan> quicksilver: Not correctly, but it does terminate.
07:07:40 * quicksilver nods
07:07:42 <EvilTerran> what about <a<b/></a> or something, though?
07:07:42 <Sxan> That's really strange.
07:07:43 <Saizan> Sxan: oh, after 6ms it terminates, and it looks like it found really long and weirds tag names..
07:07:43 <quicksilver> I just tested that case.
07:07:59 <Sxan> Saizan: On that 500k file?
07:08:14 <Saizan> Sxan: yes
07:08:17 <Sxan> Saizan: That's because this isn't an XML parser, so it thinks XML instructions and comments are really tgs.
07:08:24 <quicksilver> Sxan: well there are only two places the overflow could happen
07:08:27 <quicksilver> sorry, space leak
07:08:31 <EvilTerran> might TagSoup be suitable?
07:08:32 <quicksilver> either in currentTag or paths
07:08:33 <EvilTerran> or is it too slow
07:09:06 <Sxan> EvilTerran: I was hoping for something faster.
07:09:27 <EvilTerran> i see
07:09:42 <quicksilver> it's interesting to ask why Sxan's program doesn't work
07:09:44 <Sxan> I don't need to *parse* the XML.  I'm just generating some statistics about who the big space consumers are in some files we're generating.
07:09:49 <quicksilver> even if tehre might be a better way ;)
07:09:57 <quicksilver> because superficially it's a fairly simple program
07:10:04 <quicksilver> although it does encode a fairly fiddly statemachine.
07:10:05 <Cale> Arnar_/Saizan/whoever else was following this: I had a go at that antichain problem :) http://www.reddit.com/r/programming/comments/76xem/finding_all_dependencyclosed_sets_haskell/c05ult3
07:10:06 <Sxan> quicksilver: There's definitely a better way :-)
07:10:07 <lambdabot> Title: cgibbard comments on Finding all dependency-closed sets [Haskell], http://tinyurl.com/4thyxz
07:11:12 <Sxan> quicksilver: Fiddly?  I'm not disagreeing.. in fact, I'd be interested in seeing a more elegant solution.
07:11:43 <Sxan> I was trying for something that would work in constant space and do no more work than needed to generate my stats.
07:12:21 <Sxan> Obviously, I failed ;-)
07:13:36 <Sxan> Saizan: Actually, you said it terminated after 6ms on the 500k file, presumably with profiling enabled??
07:13:43 <Sxan> That's really strange.
07:14:22 <Saizan> 6 minutes, without profiling, but i switched to lazy bytestrings now that i recall
07:14:35 <Sxan> Oh.
07:16:06 <Saizan> Cale: very nice, i wonder how the graph of dependencies between the compations looks like in both case..
07:16:40 * vixey amused by Cales code
07:17:16 <Saizan> Sxan: i'm going to retry with strict
07:17:38 <Cale> :)
07:17:51 <Sxan> Saizan: I'm taking out the Map and seeing how it behaves.
07:18:08 <Sxan> Doh.
07:18:10 <Sxan> Wow.
07:18:25 <Sxan> 0.341s
07:18:45 <Saizan> heh
07:19:26 <Sxan> Saizan: It's also sucking down the 100MB file, topping out at 4.6MB RAM.
07:19:37 <Sxan> Of course, it doesn't generate any useful output...
07:20:01 <Sxan> 60s.
07:20:35 <quicksilver> I suspect you are building up very very long map keys
07:20:40 <quicksilver> due to a bug.
07:20:56 <Saizan> at least in the 500k case the keys are quite long
07:21:15 <Sxan> Hm.
07:21:29 <Sxan> The 500K file has more depth.
07:21:35 <Sxan> My 100MB file is really flat.
07:21:52 <Sxan> It shouldn't be XML, to be honest, but that's a different issue.
07:22:16 <Sxan> However, the Haskell version -- without maps -- is STILL slower than the Ruby version.
07:22:19 <Sxan> 45s for the Ruby.
07:22:23 <quicksilver> comparisons between very long strings are (relatively) slow
07:22:27 <jeffz`> Sxan: did you compile with -prof -auto-all then run with +RTS -p?
07:22:31 <Sxan> What the heck am I doing wrong?
07:22:49 <Saizan> what data structures are you using in Ruby?
07:23:06 <Sxan> A hash and an array with pairs.
07:23:11 <Sxan> The logic is totally different.
07:23:37 <Sxan> I'm using regular expressions in the Ruby version.
07:24:00 <Sxan> I'm not parsing per-byte, like the Haskell version.  The Haskell version *should* be much faster.
07:24:13 <Sxan> jeffz`: Not yet.
07:24:42 <Sxan> Uh...
07:25:08 <Sxan> -prof -all-auto makes GHC not able to find the ByteString library...
07:25:14 <jeffz`> read carefully
07:25:19 <mapreduce> > let x=x in 5
07:25:20 <Sxan> Sorry, auto-all
07:25:20 <lambdabot>   5
07:25:36 <jeffz`> it should say something about not finding the profiling library if anything
07:25:48 <mapreduce> > let abc=abc in 5
07:25:49 <lambdabot>   5
07:25:53 <Sxan> Could not find module `Data.ByteString.Lazy.Char8'
07:25:56 <mapreduce> > let abc=abc in abc
07:26:00 <Cale> > let 0 = 1 in 0
07:26:01 <lambdabot>   0
07:26:06 <Sxan> ghc --make -prof -auto-all Slow.hs
07:26:11 <lambdabot>   thread killed
07:27:03 <Cale> > let x = x + 1 in x
07:27:15 <Saizan> Sxan: it means you've not installed the profiling version of the library
07:27:18 <lambdabot>   thread killed
07:27:25 <Sxan> Oh.
07:27:27 <Sxan> Ok.
07:27:36 <Saizan> did you use cabal for it?
07:27:39 <Sxan> Oh, of course.
07:27:46 <Sxan> No.
07:28:02 <Sxan> I meant "of course, that makes sense," and "no, I didn't use Cabal"
07:28:08 <Sxan> I'm using the Ubuntu packages.
07:28:18 <Sxan> Which, AFAIK, could be using cabal underneath.
07:28:45 <Sxan> Yeah, I didn't install any of the profiling packages :-(
07:30:20 <mib_gbbyr1> i am trying too implement tower of hanoi tape rotation backup, i have my hanoi function but to get the tape backup to work with my 5 days, is kinda not going so well, any help please
07:30:42 <vixey> what's rotation backup
07:32:32 <mib_gbbyr1> here's the link http://www.alvechurchdata.co.uk/softhanoi.htm
07:32:34 <lambdabot> Title: Tower of Hanoi pattern for backup
07:33:15 <mib_gbbyr1> i want to use the function too generate something like that
07:33:59 <Sxan_away> Be back in a bit.
07:34:21 <mib_gbbyr1> i have 5 tapes right using the hanoi function, it suppose to return which tape is used on a day.
07:36:12 <vixey> > intercalate "a" (intercalate "b" (intercalate "c" (intercalate "d" "e")))
07:36:13 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
07:36:51 <Saizan> anyone knows of a nice program to play with turing machines?
07:37:25 <Cale> Reading about this on Wikipedia, the connection to the Tower of Hanoi puzzle seems more like a fun observation than a useful way to describe the schedule.
07:37:30 <visof> > let foo n = bar@[ x | x <-[1..], length bar == 1] in foo 1
07:37:31 <lambdabot>       Pattern syntax in expression context:
07:37:31 <lambdabot>          bar@[x | x <- [1 .. ], l...
07:38:07 <vixey> > intersperse 'a' (intersperse 'b' (intersperse 'c' (intersperse 'd' "__")))
07:38:08 <lambdabot>   "_abacabadabacaba_"
07:38:32 <Cale> :)
07:38:46 <vixey> so I think that
07:38:48 <vixey> lnNumDisks = 5
07:38:58 <vixey> is a bit odd
07:39:13 <BeelsebobWork> > foldr intersperse "__" "abcde"
07:39:14 <lambdabot>   "_abacabadabacabaeabacabadabacaba_"
07:39:14 <vixey> that "FoxPro procedure" is not really sensible
07:39:18 <dolio> > intersperse 'a' "bcb" ++ "b"
07:39:19 <lambdabot>   "bacabb"
07:39:31 <dolio> > 'a' : intersperse 'a' "bcb" ++ "b"
07:39:32 <lambdabot>   "abacabb"
07:39:37 <BeelsebobWork> > foldr intersperse "__" "abcdefgh"
07:39:38 <lambdabot>   "_abacabadabacabaeabacabadabacabafabacabadabacabaeabacabadabacabagabacabada...
07:39:42 <BeelsebobWork> caboom :)
07:40:58 <Ferdirand> iirc, this "tower of hanoi" pattern is used in FFT too
07:42:12 <Cale> diskFor day | even day  = 0
07:42:12 <Cale>             | otherwise = 1 + diskFor ((day - 1) `div` 2)
07:45:55 <Cale> alternately, you can think of it as the number of contiguous 1's at the least significant end of the day expressed in binary.
07:46:35 <Cale> (or 0's, that works just as well)
07:47:09 <Cale> diskFor day | odd day   = 0
07:47:09 <Cale>             | otherwise = 1 + diskFor (day `div` 2)
07:47:30 <Cale> (it's just shifted over)
07:50:21 <camio> Does anyone have any suggestions for blog software that has Haskell syntax highlighting and maybe LaTeX formula support?
07:50:55 <vixey> you can use emacs M-x htmlize-buffer
07:52:17 <camio> vixey: I'm hoping to be able to write code directly in the blog site for convenience.
07:52:25 <Sxan> Saizan, quicksilver, et al: Thanks for the help.  I'm going to go sink my head in some profiling data.
07:52:47 <dolio> You could try following links to various blogs on planet haskell. I'm sure one has the setup you're looking for.
07:54:02 <dolio> edwardk's blog is pretty nice, whatever he uses.
07:54:13 <dolio> Assuming his category theory diagrams are inline (they may not be).
07:54:40 <camio> Thanks for the suggestion.
07:55:52 <dolio> I don't know how to figure out what he's running just by looking at it, though.
07:56:17 <Saizan> i think he says that in one of the first posts
07:57:04 <dolio> Oh yeah. The latex and diagrams are inline.
07:57:17 <dolio> That's pretty hot.
07:58:03 <dolio> Actually, he doesn't appear to say what he's actually running. Just posts some tests of it all.
07:58:39 <mib_gbbyr1> cale with the diskfor the day, how does the hanoi get used there?
07:58:40 <camio> I think it's wordpress.
07:58:42 <dolio> Other than wordpress. I assume it doesn't do all that fancy stuff out of the box.
08:00:02 <dolio> Although, what blog can't use a few commutative diagrams, really.
08:06:08 * quicksilver is quite surprised that droundy doesn't see the self-evident truth that constants are supposed to be universal.
08:08:39 <camio> Arg, wordpress is php/mysql. Ah well.
08:16:48 <mib_gbbyr1> cale, what if i wanted it in the format of mon|tues|wed|thurs|fri how do i go about implementing that/
08:17:03 <mib_gbbyr1> and ensure it starts back each time
08:17:34 <mib_gbbyr1> i was thinking of using a IO and the use a \n to call back the function on the next line
08:18:20 <Arnar_> Cale: thanks a lot for the reddit comment.. this is very interesting
08:29:22 <chrisdone> camio: IIRC panda has LaTeX support
08:29:41 <chrisdone> camio: http://github.com/nfjinjing/panda/tree/master
08:29:46 <lambdabot> Title: nfjinjing's panda at master — GitHub
08:30:28 <camio> Thanks for the pointer.
08:31:07 <chrisdone> (I don't know how advanced it is (I don't know LaTeX), but I use Panda for my blog)
08:44:10 <Arnar> camio: were you looking for latex support in wordpress?
08:46:33 <harrison_partch> Error building zlib from zlib-0.4.0.4.tar.gz on amd64 http://rafb.net/p/UoAN0J49.html
08:46:34 <lambdabot> Title: Nopaste - No description
08:47:15 <harrison_partch> I need zlib to compile cabal-install
08:47:18 <Saizan> Stream.hsc:74:18: error: zlib.h: No such file or directory
08:47:44 <Saizan> you need to install the header files for libz,
08:47:45 <harrison_partch> ah, the linux installation lacks zlib.
08:47:49 <harrison_partch> k
08:47:52 <harrison_partch> got it
08:50:10 <harrison_partch> solved. thx
09:06:38 * BMeph is amazed that any Linux installation is lacking zlib...
09:06:48 <harrison_partch> No, I have zlib!
09:07:36 <harrison_partch> But for some reason, when I try to build from zlib-0.4.0.4.tar.gz it doesn't find zlib.h
09:07:47 <Arnar> BMeph: many modern distros have the libraries but not the headers
09:07:56 <Arnar> harrison_partch: what's your distro?
09:08:02 <dmwit_> zlib-dev
09:08:03 <harrison_partch> nixos
09:08:13 <dmwit_> wow
09:08:19 <dmwit_> I didn't know anybody used that in real life.
09:08:20 <dmwit_> How is it?
09:08:29 <Arnar> ok.. don't know it - if there's a package manager look for zlip-headers, zlip-dev, zlib-developer etc
09:08:52 <harrison_partch> it is amazing yet very alpah
09:08:55 <harrison_partch> alpha
09:09:17 <harrison_partch> it took me days to boot x windows.
09:09:23 <dmwit_> oops
09:10:22 <harrison_partch> haskell-zlib-0.4.0.2 zlib-1.2.3 zlib-1.2.3-static
09:10:33 <harrison_partch> interesting. i must be leaving out a step.
09:11:39 <harrison_partch> i don't see why, if i have installed haskell-zlib-0.4.0 as a nixos package,
09:12:16 <harrison_partch> the cabal-install package, when it builds, tries to build zlib from source anyway.
09:12:35 <Saizan> harrison_partch: are you using bootstrap.sh?
09:12:43 <harrison_partch> y.
09:12:53 <harrison_partch> source bootstrap.sh
09:12:53 <Saizan> well it's not a very smart script
09:12:56 <harrison_partch> k
09:13:05 <dmwit_> In such a case, you *may* want to special case things. =)
09:13:05 <quicksilver> there must be something call zlib-1.2.3-dev
09:13:05 <harrison_partch> is there a way around it?
09:13:06 <Saizan> comment out the lines for zlib
09:13:07 <quicksilver> or something.
09:13:17 <harrison_partch> k script surgery.
09:15:02 <nicknull> data X = X {f :: String}, i want curr to be a function and thus have the type function. how do i declare type :: function?
09:15:22 <quicksilver> function is not a type.
09:15:31 <quicksilver> you need to say what function ;)
09:15:41 <quicksilver> "a -> b" is the most general functional type.
09:16:00 <quicksilver> String -> String is a specific example
09:17:52 <nicknull> ok i see
09:18:31 <nicknull> data TransitionFunction = TransitionFunction { f :: a -> b }          deriving(Eq, Ord, Show)
09:18:38 <nicknull> or i dont since that doesnt work
09:19:55 <leadnose> I think you need to write it "data TransitionFunction a b = ...", though I'm not sure
09:20:25 <Saizan> unsing ghc6.10 with editline haskell-mode looks buggy, the usual C-u C-c C-y prints :type <function_name>^J<function-type> in the ghci buffer instead of pasting it in the file, any obvious fixes i might try from someone that knows emacs better than me?:)
09:21:01 <Badger> I wouldn't have though it would be a b
09:21:11 <Badger> since b is the result, is it not
09:21:51 <dmwit_> Badger: what?
09:21:54 <quicksilver> nicknull: well you can't derive Eq, Ord, or Show for functions.
09:22:07 <Badger> dmwit_: the above.
09:22:18 <quicksilver> nicknull: what are you trying to do in fact?
09:22:20 <Badger> but what do I know anyway. :P
09:22:29 <quicksilver> likely leadnose is right and you want to name the parameters as part of the type.
09:22:33 <dmwit_> Badger: I'm pretty sure leadnose is right.  I'm not sure I understand your objection.
09:23:10 <Badger> dmwit_: in that case, I've probably not been paying enough attention to my book
09:23:22 <nicknull> qucksilver: im trying to write a simple finite state machine, modeling a parketing-area-gate :)
09:25:05 <Leimy> is hs-plugins the only way to get GHC to dynamically re-evaluate stuff?
09:25:11 <Leimy> I thought that was being used in Yi many moons ago.
09:26:09 <nicknull> is hs-plugins something you need to download or it is a module?
09:26:35 <dmwit_> Leimy: There's a GHC api now.
09:26:35 <Saizan> it's a package, you can find it on hackage
09:26:52 <Leimy> dmwit_: So once can just do the GHC as a library stuff to get it to re-evaluate stuff?
09:27:11 <dmwit_> ...what do you mean by re-evaluate?
09:28:32 <Leimy> Can I dynamically redefine a function or an action and continue running a program without shutting it down first? :-)
09:28:36 <Leimy> I guess I'm thinking Erlang
09:29:26 <dmwit_> Not really.
09:29:54 <dmwit_> You can sort of load some code and run it, but it will be nowhere near as convenient as just calling a function.
09:30:14 <dmwit_> (And you won't be able to redefine a function defined in the normal, obvious "foo x y = ..." way.)
09:30:25 <Leimy> hmmm
09:30:45 <Leimy> So I think I should study lambdabot a bit.
09:31:12 <dmwit_> hs-plugins has the same problem
09:31:36 <vixey> I don't think lambdabot is worth studying
09:32:13 <dmwit_> Leimy: It's really pretty uncommon to need to change things dynamically; do you mind sharing what you're trying to do at a high level?
09:32:21 <hackage> Uploaded to hackage: PSQueue 1.1
09:33:03 <Leimy> I'm just wondering if haskell has the capability to change things dynamically, and if so how.
09:33:15 <Leimy> I'm not exactly sure why I'd use it in that way just yet.
09:33:20 <vixey> Leimy: "change things" mean what
09:33:36 <Valodim_> lambdabot needs more documentation big time
09:33:37 <Leimy> vixey: behaviors of a program.
09:33:45 <vixey> um. yes.
09:33:48 <Leimy> I'd like to replay functions :-)
09:33:51 <Leimy> er replace
09:34:45 <vixey> Valodim_: or just wiped out of existence
09:34:58 <Valodim_> wiped out?
09:35:01 <Valodim_> what, don't you like \bot? :(
09:35:08 <Leimy> I don't think vixey likes lambdabot
09:35:48 <leadnose> Leimy, in case you don't know lisp yet, i suggest you give it a try, it's much more dynamic in that sense
09:36:05 <Leimy> Erlang can do it too
09:36:14 <vixey> leadnose: And what is it that lets you do that you can't do in haskell
09:37:09 <leadnose> some things are easier to do in it, but I suppose there's nothing you really _can't_ do in haskell that lisp can do
09:38:34 <quicksilver> Map String Command
09:39:05 <osfameron> @faq can haskell do the things you can't do in haskell?
09:39:05 <lambdabot> The answer is: Yes! Haskell can do that.
09:39:18 <leadnose> :D
09:39:35 <Badger> @faq can haskell cook me a good meal?
09:39:35 <lambdabot> The answer is: Yes! Haskell can do that.
09:39:37 <quicksilver> is one way to model a well-factored application which can dynamically replace its own commands
09:40:00 <quicksilver> and then you could use hs-plugins to dynamically load more things of type 'Commmand'
09:40:07 <quicksilver> (which is presumably some function type)
09:40:30 <quicksilver> there are lots of reasons to structure 'applications' in this kind of way.
09:40:46 <Leimy> Sometimes you have code that isn't allowed to completely crash
09:40:49 <quicksilver> it's been standard Apple advice for ten years; factor your code through apple events
09:40:56 <Leimy> heh
09:41:01 <quicksilver> it's also analogous to how emacs works
09:41:08 <quicksilver> at a slightly different level of bureacracy ;)
09:41:12 <Leimy> yes :-)
09:41:38 <quicksilver> not being allowed to completely crash is a different requirement.
09:41:44 <Leimy> yes. :-)
09:41:46 <quicksilver> hs-plugins can't magically give you that ability.
09:41:54 <quicksilver> you can hs-plugins load non-terminating code
09:41:55 <leadnose> I wonder if anyone has thought of writing an emacs in haskell :)
09:41:59 <quicksilver> code which exhausts all memory, etc.
09:42:02 <Leimy> leadnose: you mean Yi?
09:42:02 <quicksilver> leadnose: they have. Yi.
09:42:13 * leadnose runs to google
09:42:18 <Leimy> quicksilver: Even in Erlang, it's hard to write code that does not crash :-)
09:42:24 <quicksilver> modern OSes are only just, barely, and very recently, getting the ability to sandbox code like that.
09:42:31 <vixey> You'd have to do it in some horrible confused dialect of haskell for it to be a real emacs
09:42:44 <quicksilver> well arguably rlimits gave us that years ago, but it was pretty coarse grained.
09:42:48 <Leimy> vixey: with dumb scoping rules yes :-)
09:42:58 <quicksilver> vixey: yes, certainly not a real emacs
09:43:01 <quicksilver> but emacs-like in spirit.
09:43:03 <vixey> quicksilver: I wonder if jvm and all the type stuff is partly helping that (sandboxing)
09:43:08 <Leimy> Emacs-like in spirit but with less suck :-)
09:43:17 <quicksilver> and different suck!
09:45:28 <Leimy> oh everything sucks
09:45:31 <Leimy> just in different ways.
09:48:09 <Apocalisp> ah, but does it suck well or badly?
09:49:22 <harrison_partch> quicksilver: modern OS. sandboxing. have you looked at Oberon and the modern OS written in it, usually known as Bluebottle (they seem to have changed it to "A2" recently)?
09:49:44 <harrison_partch> Now, a functional language on that would be interesting.
09:50:34 <harrison_partch> Oberon unlike C is inherently typesafe and is GC'd at the systems level in modular statically compiled code.
09:52:52 <harrison_partch> http://www.bluebottle.ethz.ch/download.html  The iso boots with some nice demos including a realtime raytracer that someone or other wrote.
10:00:15 <Halleck> Hey guys I am just trying to learn haskell coming from the C world. I have an assignment in one of my programming classes to build a simulation of a cpu scheduler (using FCFS and MLFQ algorithms) and was thinking about trying to build this in haskell. What do you guys think? Feasible?
10:00:31 <vixey> yes
10:01:33 <roconnor> what's the difference between libghc6-glib-dev and libghc6-gtk-dev?
10:01:52 <Halleck> sweet, can you think of any specific challenges I am likely to come across implementing this? Or should I just wait until I hit a problem and come ask then?
10:02:12 <vixey> just hack
10:02:20 <vixey> you might learn some things from the gameboy emulator
10:02:20 <vixey> a
10:02:33 <roconnor> Halleck: I don't think you will encounter any problem other than typicial troubles learning Haskell.
10:02:44 <dmwit_> roconnor: I'm guessing the same as the difference between libglib and libgtk?
10:02:49 <roconnor> Halleck: if you are a fast learner you may even find some cute Haskell tricks for this problem.
10:02:57 <roconnor> dmwit_: what's the diff?
10:03:15 <roconnor> why does cairo depend on libglib and not libgtk?
10:03:46 <rwbarton> glib is just a generic C utility library that was split off of gtk long ago
10:04:55 <roconnor> doesn't cairo depend on gtk?
10:05:18 <rwbarton> It might depend on gdk
10:05:48 <roconnor> it isn't in the ubuntu dependencies, which surprised me.
10:08:42 <dmwit_> roconnor: Gtk is just one of many backends for Cairo.
10:09:20 <dmwit_> The close tie between Cairo and Gtk in Haskell is mostly accidental; in fact I think they're working on splitting off the Cairo stuff into its own library.
10:09:38 <roconnor> dmwit_: right, but I thought ghc-cairo had this historic, but unecessary, link to gtk
10:09:40 <rwbarton> I'd even call Gtk a frontend for Cairo
10:09:54 <dmwit_> rwbarton: That might be better, yeah.
10:09:58 <roconnor> but this link hasn't been removed yet AFAIK
10:10:04 <dmwit_> roconnor: correct
10:10:18 <roconnor> So why no package depencency?
10:10:59 <dmwit_> roconnor: Between what and what?
10:11:25 <dmwit_> Outside of the Haskell world, cairo doesn't *need* to depend on gtk.
10:11:36 <dmwit_> And inside the Haskell world, there's no separate cairo stuff to install.
10:12:13 <Saizan> dmwit_: the debian packages are separate
10:12:19 <roconnor> dmwit_: between libghc6-cairo and libghc6-gtk
10:12:31 <roconnor> in ubuntu (debian)
10:12:33 <dmwit_> whoa
10:13:09 <roconnor> well at least libghc6-cairo doesn't depend libghc6-gtk
10:13:18 <roconnor> I can check the reverse in a moment.
10:14:09 <dmwit_> Well, I mean, I've used the Cairo bits without the Gtk bits, even in Haskell.
10:14:23 <dmwit_> So maybe the debian maintainers are even ahead of the Gtk2Hs themselves.
10:14:31 <dmwit_> *Gtk2Hs crew
10:15:02 <dcoutts> the cairo package does not depend on the gtk package
10:15:10 <dcoutts> it's just a matter of the build system
10:15:40 <roconnor> ah
10:15:53 <roconnor> libghc6-gtk-dev depends on libghc6-cairo-dev
10:15:53 <rwbarton> Oh yeah, they have the same source package gtk2hs.
10:15:56 <roconnor> strange
10:15:58 <roconnor> ok
10:16:30 <roconnor> I guess I should install libghc6-gtk-dev
10:16:34 <nicknull> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State-Lazy.html
10:16:36 <lambdabot> Title: Control.Monad.State.Lazy, http://tinyurl.com/2dn8t6
10:16:37 <nicknull> wtf
10:17:04 <nicknull> haskells really makes things abstract to the pont of pure masturbation
10:17:19 <dmwit_> http://downforeveryoneorjustme.com/sequence.complete.org
10:17:28 <bos> nicknull: hardly.
10:17:30 <lambdabot> Title: Huh?
10:17:31 <dmwit_> I can't read the HWN. =/
10:17:40 <roconnor> nicknull: what's wrong with Control.Monad.State.Lazy?
10:17:48 <luqui> bos, just tell that to category-extras! :-)
10:18:00 <dmwit_> nicknull: I would rather say that other languages mix things up to the point of pure confusion.
10:18:14 <bos> luqui: that's people's crazy libraries, not the language :-)
10:18:21 <vixey> nicknull: what would the impure form be?
10:18:30 <luqui> bos, weren't we talking about mtl to begin with?
10:18:35 <patchwork> (don't feed the trolls)
10:18:36 <dmwit_> sex!
10:18:39 <roconnor> dmwit_: I wouldn't say *pure* confusion :)
10:18:52 <nicknull> evalStateT  , lol first read it ias evilState
10:18:56 <luqui> roconnor, =P
10:19:07 <dmwit_> roconnor: Ah, well, with a little discipline, anything can be forced into an understandable format. =P
10:19:11 <patchwork> roconnor:  Yeah *pure* confusion would be mathematically precise ;)
10:19:13 <dmwit_> ...*even* InterCal, yes.
10:19:33 <dmwit_> nicknull: heh
10:25:31 <nicknull> how do i do input in haskell?
10:25:46 <vixey> nicknull: any intro or tutorial should cover this
10:25:54 <vixey> nicknull: what sorts of input did you mean?
10:27:33 <noZone> Simple query to anyone here: are there reasons you use Haskell other than for the practical or pragmatic?
10:28:15 <Valodim_> I always thought haskell was more esotheric and theoretically interesting than pragmatically.. :|
10:28:50 <shepheb> aesthetic and community reasons are among my reasons for liking Haskell, certainly. but it also makes me productive.
10:28:50 <daf> noZone: I find it more fun/satisfying than other languages
10:29:22 <Taral> Anyone have a good reference on the difference between intesional and extensional type systems? :/
10:30:07 <noZone> Haskell does seem to me to have that quality as well. I waas curious if it had a similar appeal to others.
10:30:41 <vixey> Taral: you really mean 'systems' and not 'theories'?
10:31:31 <noZone> "Form follows function". Perhaps in Haskell both play together very well.
10:31:50 <Taral> That's the term I've seen.
10:32:07 <vixey> Taral: not sure what it means then, where's this from
10:32:16 <Taral> Bah, I'll have to find the paper again.
10:32:21 <hackage> Uploaded to hackage: CheatSheet 1.2
10:32:31 <nicknull> i use python, C, Lisp, Java for the practical and Haskell to rape my brain
10:32:47 <Baughn> noZone: Haskell is /right/. That it is also pragmatically good, easy to use, produces fast programs and challenges my brain are just bonuses.
10:32:48 <Taral> aha
10:32:49 <mattam> Taral: I guess "Programming in Martin-Löf type theory" has something to say about that.
10:33:19 <noZone> nicknull: I'll add masochism to my list. :)
10:33:20 <nicknull> learning C only though so shouldnt bein there ^^
10:33:21 <Taral> "In extensional higher order logic the (non-empty) predicate term can be made into a type of locally closed terms. In intensional dependent type systems (including Coq), this construction isn't available."
10:33:54 <Taral> mattam: I'll look that up.
10:34:06 <mattam> The best, thourough treatment I know is Hofmann's thesis otherwise, but it's very categorical :)
10:35:01 <Taral> Yeah, need an intro to category theory too :D
10:35:10 <noZone> Given a choice between a language that was slightly more productive vs one that was also elegant, which would you choose?
10:35:31 <mattam> Where's that excerpt from? I don't understand it.
10:36:04 <vixey> noZone: there is a difference?
10:36:11 <vixey> noZone: I did not think so
10:36:29 <Philippa_> vixey: sometimes we have to do things that nobody's worked out how to do elegantly yet
10:37:08 <Taral> mattam: Engineering Formal Metatheory, Aydemir et al., POPL 2008
10:37:09 <Baughn> noZone: I don't believe a language *can* be productive without also being elegant
10:37:15 <Taral> Footnote 7.
10:37:28 <Baughn> noZone: Not if you ignore libraries. Someone has to write them, after all.
10:37:42 <luqui> Baughn, er.  what?
10:37:53 <luqui> how much of the world's code is written in C++?
10:37:59 <Philippa_> noZone: most of my reasons probably amount to a certain kind of pragmatism, but I have a weird brain
10:38:01 <Baughn> I mean, if you measure productivity across the entire language community
10:38:05 <Taral> mattam: It helps to know that "term" is a predicate.
10:38:39 <noZone> Philippa_: I doubt you are alone.
10:38:59 <Philippa_> oh, I know I'm not - I gave a talk on my weirdness and keep having people pop up and thank me for it because it describes them too
10:39:11 <noZone> :)
10:39:36 <luqui> C and assemblers I can see as elegant, from a sort of bare-bones perspective.  Haskell and smalltalk I can too, from a high-level beauty perspective (smalltalk's is a bit superficial).  C++ is a pile of poop.  :-)
10:40:11 <noZone> One man's poison is another man's poop....
10:40:15 * luqui couldn't resist, and now must leave in his tactless glory.
10:41:20 <Baughn> luqui: C the language is to some degree elegant, although the type /notation/ makes me puke. Programs written in C tend to be anything but, so..
10:42:02 <lament> Baughn: I agree, except i think it works the other way around - lots of people are productive in C++ so there must be some elegance in it :)
10:42:29 <lament> which all those other people coding in C++ haven't found yet...
10:42:58 <Philippa_> luqui: Smalltalk's beauty is as much in how far down it can be pushed, mind
10:43:03 <Valodim_> no actually, Java is more elegant than C++ >_>
10:43:14 <Philippa_> that, and in how the basic concepts also work well with external systems
10:43:17 <mattam> Taral: well, I don't see why you couldn't take { x : preterm | term x }.
10:43:57 <Philippa_> in that regard I'm tempted to say Haskell's merely equal (it takes about the most blatant punt you can on external interaction, for example), but people do highly beautiful things in it too
10:44:12 <lament> elegance is not just subjectively evaluated, it's subjectively defined
10:44:18 <lament> so it's a pretty horrible term to use
10:44:45 <Taral> mattam: I don't know. But I think it's key to this whole intensional/extensional bit.
10:44:46 <vixey> welcome to natural language
10:45:37 <noZone> vixey: my thoughts exactly... can't live without it.
10:45:38 <Philippa_> lament: it's surprising how much actually is shared, in that regard
10:46:19 <lament> Philippa_: I am not surprised. It seems several classes of people interpret "elegance" in several different ways
10:46:20 <nicknull> http://www.zvon.org/other/haskell/Outputsyntax/type_reference.html#
10:46:23 <lambdabot> Title: Haskell : type, http://tinyurl.com/4klhov
10:46:35 <nicknull> vant i declare type X :: String ?
10:46:40 <lament> Philippa_: in particular consider the statement "C++ is elegant"
10:46:45 <vixey> nicknull: no
10:46:54 <lament> Philippa_: or, for that matter, "Scheme is elegant"
10:47:03 <vixey> Scheme is very elegant
10:47:20 <lament> vixey: really? I thought it was just a mess of unnecessary parentheses.
10:48:01 <Apocalisp> Philippa_, expected: Haskell; found: C++
10:50:10 <lament> Philippa_: the engineer/mathematician split...
10:50:10 <noZone> Guile/scheme has "ctax" to drop all those crazy parens.
10:50:45 <noZone> engineer/mathematician/poet also?
10:51:58 <Baughn> What do the poets use? Whitespace?
10:52:01 <lament> most mathematicians think they're poets :)
10:52:18 <noZone> http://www.usenix.org/publications/library/proceedings/tcl95/full_papers/lord.txt <-- paper on ctax
10:52:20 <lambdabot> http://tinyurl.com/4dez8s
10:54:24 <kaol> "Head explosion is the *goal* of teaching Haskell."
10:54:47 <Baughn> My head exploded three times, but I got better.
10:56:01 <noZone> I think my head actually imploded.
10:56:46 <lament> too much pressure?
10:57:08 <noZone> I think so.
10:57:29 <noZone> My tiny brain wasn't up to it at times.
10:57:41 <nullednick> im confused about finite state machine. i eman they are simple but im confused about if something would qualify as a statemachine or not. and events and actions are the same kind of, why have 2 different categories if they are the same?
11:00:32 <Saizan> "state machine" is a quite generic term
11:00:56 <chrisdone> nulled: what is a finite state machine?
11:01:03 <plutonas> how can i rephrase this function to curry the second argument: http://www.pastebin.ca/1227049 ?
11:01:14 <lament> nullednick: if it has a finite number of possible states, it's a finite state machine...
11:01:35 <mauke> plutonas: huh? it's already curried
11:01:40 <Baughn> nullednick: *Technically*, /computers/ qualify as finite state machines. Well, anything with a finite number of states would, which quite possibly includes the universe..
11:01:53 <plutonas> mauke: i mean not have str
11:01:55 <Baughn> nullednick: And you can't build anything but a finite state machine from part of a finite state machine
11:01:58 <plutonas> what is already curried?
11:02:24 <scottutd> Can anyone help me with a type class problem (to do with the Edison AssocX class)?
11:02:43 <Saizan> plutonas: what's the point of calling accept again with the same arguments?
11:02:47 <Baughn> scottutd: No idea. Typically you just ask, and anyone capable of answering.. answers.
11:03:00 <rwbarton> plutonas: You could write   require w = maybe (err "missing string" w) Just . accept w
11:03:30 <rwbarton> plutonas: Your code seems a little odd though, why return a Maybe foo when you could return a foo?
11:03:42 <rwbarton> (Also why compute accept w str twice?)
11:03:42 <plutonas> Saizan: no point, but calling accept is not expensive
11:03:49 <plutonas> rwbarton: it has to do with the program as whole
11:04:05 <plutonas> i mean i need maybe value
11:04:31 <rwbarton> OK, well what I wrote above should be equivalent to your function.
11:04:40 <scottutd> http://hpaste.org/11146: Here's the relevant types and the error message
11:05:01 <plutonas> rwbarton: thanks, but isn't there any equivalent without using maybe and Just?
11:05:32 <nullednick> data State = State
11:05:32 <nullednick>     { curr_state :: String, _event :: String, _action :: String }
11:05:32 <nullednick>              deriving(Eq, Ord, Show)
11:05:38 <scottutd> er.. http://hpaste.org/11146
11:06:13 <nullednick> if i want to set curr_state to something new  i cant just let state = State "Gate up" then s <- updateState ?
11:06:14 <rwbarton> plutonas: Certainly there are equivalents, you could write a separate function for the maybe (err "missing string" w) Just part
11:07:39 <rwbarton> scottutd: Probably you meant to define an instance F.AssocX (FM k) k
11:09:04 <scottutd> rwbarton: then I get "Illegal Instance declaration.. all instance types must be of the form (T a1 ... an)..."
11:10:10 <plutonas> rwbarton: what if i don't want to have any Just or Nothing, or maybe in my code?
11:10:17 <rwbarton> scottutd: Yeah.  Turn on whatever language pragma it suggests, probably {-# LANGUAGE FlexibleInstances #-}
11:10:27 <plutonas> do you think it would be doable?
11:10:54 <rwbarton> scottutd: (Your program is not Haskell 98 anyways, since it's using multiparameter type classes)
11:12:00 <Baughn> Very few programs seem to be.. is *anyone* programming to haskell98? Other than perhaps pure data-structure libraries?
11:12:19 <rwbarton> plutonas: Of course, you could just implement that part with a case like you do now, but as a separate function so that you can compose it with accept w
11:13:42 <nullednick> is there no way to have a class like in python like: class State: __init__(self, state):self.state = state. then just fucking change the state when i need to?
11:14:07 <Baughn> nullednick: That would be missing the point of haskell entirely.
11:14:29 <Baughn> nullednick: There /are/ ways to do imperative, stat-changing algorithms when you absoklutely need to (IORef, STRef), but you almost never need to
11:14:49 <Saizan> you can live in the State monad though
11:14:55 <nullednick> Baugn: im doing a finite STATE machine
11:14:59 <Baughn> nullednick: Instead of /changing/ a structure, just make a new one and use that instead
11:15:32 <nullednick> but it is the same parking lot as before, not a new one.
11:15:41 <Baughn> You copy the parking lot.
11:15:55 <Saizan> if it's different it's not the same :)
11:15:57 <Baughn> If the data structure is well defined, all the bits that don't change will still be the same.
11:16:16 <Baughn> And anyway, the GHC memory allocator is absurdly fast by most standards
11:16:44 <nullednick> the thing is the non-state behaviour of haskell programs hinders me from breaking upa  program logically and it creates a problem out of something that isnt. ive spent enough time with java to loathe that, in java you cant express some things naturally and thus it sucks to program in. haskell fixes those things but then bring the pain here instead
11:16:46 <bd_> copying collectors usually are, when most of the heap is dead :)
11:17:24 <Baughn> bd_: The allocator isn't /quite/ "add 42, %heap", though
11:17:37 <nullednick> i challenge you to convince people that once they parked their car it is a new parking lot and not just the old one with another car
11:18:05 <Saizan> you don't have to convince people of that
11:18:09 <Baughn> nullednick: Nobody said Haskell works the way you're used to, but if you try to force it to act that way you won't learn anything
11:18:32 <thetallguy> nullednick: I'm not a big fan of object analogies.  Computing is more like mathematics. After all, you can't really copy a car.
11:18:34 <Baughn> > iterate (+1) 0 -- Look! Adding cars to a parking lot!
11:18:36 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
11:19:18 <mmorrow> nullednick: one common way to represent finite state machines in haskell is with a group of mutually recursive functions which accumulate state which is explicitly passed as a function arg between these functions
11:19:19 <thetallguy> nullednick: and as for breaking up a program logically, Haskell excels at that, but the patterns are very different.
11:19:25 <Baughn> nullednick: ..anyway, you really /are/ supposed to copy the parking lot each time, instead of changing it. Is that really a big problem?
11:19:36 <nicknull> and i cantr have a function sometimes return type State, sometimes type Action, wtf
11:19:54 <bos> nicknull: please keep things polite.
11:19:54 <mmorrow> nicknull: one common way to represent finite state machines in haskell is with a group of mutually recursive functions which accumulate state which is explicitly passed as a function arg between these functions
11:19:55 <Taral> nicknull: Either State Action
11:20:13 <thetallguy> nicknull: because that would make the type ambiguous
11:20:34 <Baughn> nicknull: You could make a new type that contains one of the two
11:20:37 <lilac> data FiniteStateMachine input output = FSM (input -> FiniteStateMachine input) | Done output
11:20:37 <Baughn> Or use Either
11:21:12 <thetallguy> nicknull: a function can simply not be correct if it operates on the wrong domain
11:21:15 <mmorrow> nicknull: which you can think of as the same thing as having a single C function with a few vars local-to-that-function vars as the state, then a bunch of labeled blocks, each of which ends with a goto
11:24:42 <nicknull> where is Either?
11:24:49 <Baughn> Data.Either
11:24:51 <mmorrow> , src ''Either
11:25:06 <mmorrow> it should be Prelude
11:25:08 <lunabot>  data Either a b = Left a | Right b
11:25:20 <Baughn> Well, it is, but there's a lot of utility in Data.Either
11:25:23 <mauke> @index Either
11:25:23 <lambdabot> Data.Either, Prelude
11:25:50 <mmorrow> Baughn: heh, "a lot"
11:25:59 <mmorrow> @index either
11:26:00 <lambdabot> Data.Either, Prelude
11:26:11 <Baughn> @index lefts
11:26:11 <lambdabot> bzzt
11:26:22 <mmorrow> @index partitionEithers
11:26:22 <Baughn> ..okay, three functions
11:26:22 <lambdabot> bzzt
11:26:24 <nicknull> its not in ghci
11:26:35 <mmorrow> nicknull: what isn't?
11:26:50 <mmorrow> Either? if not, then your ghci is borked
11:27:32 <Baughn> nicknull: "Left 42" fails?
11:27:32 <EthanIsWorking> Hey, what does it mean if I get an error like this?   Data/Set.hs:(830,0)-(832,42): Non-exhaustive patterns in function rotateL
11:27:51 <mmorrow> , let f (x:xs) = 42 in f []
11:27:53 <lunabot>  luna: <interactive>:1:54-66: Non-exhaustive patterns in function f
11:28:06 <mmorrow> , let f [] = 9 ; f (x:xs) = 42 in f []
11:28:08 <lunabot>  9
11:28:21 <Saizan> EthanIsWorking: either there's a bug in Data.Set or your Ord instance is not a total order
11:28:48 <EthanIsWorking> Oh, thanks!
11:29:33 <nicknull> either is, iwas usign Either
11:31:43 <Saizan> nicknull: Either is the type
11:31:47 <nicknull> thetallguy: perhaps not a function in the pure mathematical sense but a function or procedure could work sometimes returning a string, smetimes an int
11:32:25 <Saizan> nicknull: then the caller should check the type of what it got right?
11:34:02 <nicknull> saizan: yes
11:35:24 <Saizan> nicknull: Either is just a way to pass this information to the caller
11:35:52 <nicknull> ok so a safety-measure kind of, i see your point
11:39:43 <vixey> , src ''Yoneda
11:39:46 <Badger> goo grief
11:39:48 <lunabot>  newtype Yoneda f a = Yoneda {runYoneda :: (forall b . (a -> b) ->
11:39:48 <lunabot>                                                        f b)}
11:39:52 <Badger> good grief
11:39:54 <harrison_partch> cough oberon cough
11:40:02 <Badger> ["ERC Version 5.2 (IRC client for Emacs)"]
11:40:06 <Badger> o_O
11:40:12 <vixey> harrison_partch: wtf
11:40:18 <Badger> so Emacs IS an operating system!
11:40:22 <Badger> :D
11:40:24 <mauke> Badger: http://www.vim.org/scripts/script.php?script_id=931
11:40:25 <lambdabot> Title: VimIRC.vim - An IRC client script : vim online
11:40:32 <Badger> <_<
11:40:40 <harrison_partch> i was looking at the language discussion above and didn't realize that that was notthe current topic. sorry.
11:43:46 <nicknull> @faq is emacs better than haskell
11:43:47 <lambdabot> The answer is: Yes! Haskell can do that.
11:44:08 <nicknull> @faq can haskell pretend to be a lisp?
11:44:08 <lambdabot> The answer is: Yes! Haskell can do that.
11:44:14 <mauke> preflex: 8ball is emacs better than haskell?
11:44:14 <preflex>  without a doubt
11:44:18 <Trinithis> @faq can haskell prove that vim is > emacs?
11:44:18 <lambdabot> The answer is: Yes! Haskell can do that.
11:44:30 <mauke> preflex: 8ball is vim better than emacs?
11:44:30 <preflex>  my reply is no
11:44:47 <nicknull>  @faq can haskell prove that emacs is > vim?
11:45:01 <mauke> The answer is: no
11:45:01 <nicknull> a
11:45:05 <opqdonut> :)
11:45:06 <nicknull>  @faq can haskell prove that emacs is > vim?
11:45:21 <opqdonut> The answer is: why not
11:45:22 <nicknull> @faq can haskell pretend to be a lisp?
11:45:22 <lambdabot> The answer is: Yes! Haskell can do that.
11:45:22 <Trinithis> The answer is: No! Haskell cannot do that
11:47:20 <jeffersonheard> @faq can Haskell prove that a certain someone on the mailing list asks for too many pointless additions to the language?
11:47:21 <lambdabot> The answer is: Yes! Haskell can do that.
11:47:41 <mauke> who is it this time?
11:47:45 <nicknull> bah isnt a finite state machine just a bunch of case-switch statements?
11:47:49 <vixey> not just mailing lists that people want to improve haskell on
11:48:06 <vixey> "improve" *
11:48:13 <Baughn> nicknull: No, but a bunch of case-switch statements can be a state machine.
11:48:20 <Baughn> nicknull: Though not in haskell, obviously.
11:48:34 <jeffersonheard> oh...  just the "why don't you guys make void into mapM_ and sequence_ for me?"
11:49:09 <romildo> Hi.
11:49:18 <Baughn> nicknull: Typically you'd have one function per state, pass in a list (stream) of inputs, and have the function decide which function (state, that is) to call next depending on the input. Then pass the rest of said input to the next function.
11:49:55 <Baughn> nicknull: Of course, that's in the pure language-recognition sense of a state machine, that has no output other than "invalid input for this state". Not that going beyond that is hard.
11:53:00 <dblazakis> nicknull: check out section 2.2 of http://research.microsoft.com/~simonpj/Papers/pj-lester-book/ for one way to do a state transition system
11:53:01 <lambdabot> Title: Simon Peyton Jones: book
12:00:35 <scottutd> does anyone know of a good tutorial for using Edison?
12:03:19 <mapreduce> Is there a lisp with static typing and type inference?
12:03:37 <mapreduce> Typed Scheme has no inference, and Liskell looks a bit dead (and hard to get working).
12:04:04 <mauke> mapreduce: Qi
12:04:16 <mauke> wait, I don't know if it has type inference
12:04:31 <mapreduce> I just thought you were being rude.
12:04:42 <mmorrow> haha
12:04:42 <mapreduce> Ah, that's a Q.
12:04:43 <mauke> wat
12:05:07 <mapreduce> My contact lenses are optimised for long distance. :)
12:05:52 <mauke> http://www.lambdassociates.org/aboutqi.htm
12:05:57 <lambdabot> Title: Qi FAQ
12:06:21 <vixey> "that Qi inherits all the features of Lisp that ML and Haskell do not have; (think macros, EVAL, hash-tables, property-lists, metaprogramming ....)"
12:06:23 <vixey> ... lol
12:06:26 <vixey> FUDs
12:06:45 <mauke> macros, eval, property-lists is valid
12:06:48 <mapreduce> Function types are explicitly typed in Qi.
12:06:52 <mapreduce> (as in Scala)
12:08:24 <mapreduce> I'd rather not have optional typing.  And I know Mark Tarver already as a bit of a crank.
12:14:53 <Taejo> @pl \x -> (x, x)
12:14:54 <lambdabot> join (,)
12:15:01 <Taejo> :t join
12:15:02 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:15:36 <mauke> :t join ?f
12:15:37 <lambdabot> forall (m :: * -> *) a. (Monad m, ?f::m (m a)) => m a
12:15:43 <mauke> :t join f
12:15:45 <lambdabot> forall (m :: * -> *) a. (Monad m, SimpleReflect.FromExpr (m (m a))) => m a
12:15:53 <camio> @pl \x -> first x &&& second x
12:15:54 <lambdabot> liftM2 (&&&) first second
12:16:24 <camio> @pl \f (a,b) -> (f a, f b)
12:16:25 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
12:16:25 <mmorrow> @src join
12:16:26 <lambdabot> join x =  x >>= id
12:16:46 <mmorrow> , (id=<<) (repeat [0..4])
12:16:47 <lunabot>  [0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,1,2,3,4,0,...
12:17:23 <mmorrow> , (id=<<) (*) 4
12:17:25 <lunabot>  16
12:19:08 * Taejo </3 monomorphism restriction (or at least the error messages it causes)
12:19:46 <mmorrow> , ((*2) *** (*4)) (1,1)
12:19:48 <lunabot>  (2,4)
12:20:05 <mmorrow> , join (***) (*2) (1,1)
12:20:07 <lunabot>  (2,2)
12:20:34 <mmorrow> @type join (***)
12:20:35 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
12:20:47 <mmorrow> @type join (***) :: (a -> b) -> (a,a) -> (b,b)
12:20:48 <lambdabot> forall a b. (a -> b) -> (a, a) -> (b, b)
12:23:10 <scottutd> Is Edison widely used, or is there a more popular package for Sets, Maps, etc?
12:23:24 <vixey> not enough use of Edison
12:23:35 <nicknull> can i have recursive main = dos ?
12:23:41 <mmorrow> mdo
12:23:46 <scottutd> vixey: so I should use it then? :P
12:23:57 <mmorrow> nicknull: err, wait. recursive how?
12:24:05 <vixey> main = main
12:24:15 <camio> scottutd: As opposed to Data.Set and Data.Map in ghc?
12:24:26 <mmorrow> nicknull: like you just want to call main from main? or recursive in the sense that a let can be recursive?
12:26:29 <scottutd> thanks all
12:28:24 <nicknull> mmorrow: both now that you bring it up, but i ws just asking abut recursive mains
12:30:06 <nicknull> i want a foldl but print all intermediate results
12:30:23 <mauke> :t foldM
12:30:24 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
12:30:24 <vixey> @src foldM
12:30:24 <lambdabot> foldM _ a []     = return a
12:30:24 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
12:30:43 <mauke> :t scanr
12:30:44 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
12:30:45 <Ferdirand> :t scanl
12:30:46 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
12:31:25 <mauke> > scanl f 0 [w,x,y,z]
12:31:26 <lambdabot>   Add a type signature
12:31:29 <mauke> > scanl f 0 [w,x,y,z] :: [Expr]
12:31:31 <lambdabot>   [0,f 0 w,f (f 0 w) x,f (f (f 0 w) x) y,f (f (f (f 0 w) x) y) z]
12:33:34 <nicknull> http://hpaste.org/11148
12:34:05 <vixey> nicknull: that's an odd way to write it
12:35:11 <nicknull> vixey: what is, the python way?
12:40:57 <nicknull> vixey: what is, the python way?
12:49:42 <opqdonut> gah, i need a citation "pure core"
12:49:53 <nicknull> cn i ahve a funcion that returns Int or (Int, String)? would that be either(Int, (Int, String)) ?
12:49:55 <Valodim_> [Citation Needed]
12:50:09 <mauke> Either Int (Int, String)
12:50:12 <Valodim_> Either Int (Int, String)
12:50:14 <Valodim_> hah
12:50:16 <mauke> (Int, Maybe String)
12:50:18 <Valodim_> dang :)
12:52:30 <Leimy> That reminds me of a questionable menu
12:52:36 <Leimy> (Chicken, Maybe Pie)
12:53:18 <Leimy> #foldl
13:03:41 <nicknull> http://hpaste.org/11149 , is that a finite state machine? just a whole lot of tests. very primitive. anyway, i want to print all the intermediate results, how'd i do that? some sort of fold?
13:04:52 <camio> nicknull: I would probably make a State and Event data declaration.
13:04:58 <quicksilver> harrison_partch: I'm vaguely aware of oberon.
13:05:08 <quicksilver> harrison_partch: never heard of bluebottle, thouhg. Very interesting.
13:06:24 <nicknull> camio: and wrap it around a string? what would be the point?
13:08:13 <camio> nicknull: Where are the strings coming from?
13:08:28 <nicknull> where are the states coming from?
13:08:40 <nicknull> i have to rep the state somehow anyway
13:08:48 <nicknull> some symbol or variable
13:09:35 <camio> So, why not a data declaration instead of a string?
13:09:46 <nicknull> to what end?
13:10:18 <camio> The end is thinking in terms of what you want to represent instead of how it is represented.
13:10:32 <nicknull> data State = GateUp | GateDown
13:10:43 <nicknull> something like that?
13:10:44 <camio> Yep
13:11:25 <camio> Then I would probably define my transition function using pattern matching instead of the '|' pattern.
13:12:11 <pao> hi!
13:12:19 <camio> lines like "transition GateUp PaymentRecieved = GateUp", etc.
13:12:22 <pao> is there a way to import qualified in ghci?
13:12:39 <Deewiant> nope
13:13:07 <pao> Deewiant: thanks
13:13:30 <pao> I guess it's not possibile to hide a name either...
13:13:52 <quicksilver> pao: well you can import a stub module which does just that
13:13:57 <quicksilver> sets up your imports + hids
13:14:13 <pao> quicksilver: thanks
13:14:21 <musiKk> this seems like a wanted feature, yesterday someone asked the same questions
13:15:23 <djahandarie> Haskell is awesome! =D
13:15:42 * Ferdirand seconds that
13:15:57 <younder> Rading chapter 3 in "Real World Haskell" on Types. What is the point of 'Just'?
13:16:09 <Ferdirand> :t Just
13:16:10 <lambdabot> forall a. a -> Maybe a
13:16:25 <Botje> it's the counterpart of Nothing
13:16:40 <Botje> Together they form the Maybe a type
13:17:06 <younder> But why is it needed? In lisp with generalized boolean everything not nil is a subtype of t.
13:17:16 <vixey> this is not lisp
13:17:17 <Botje> so you can use "Just a" to model a computation that produces a value of type "a", and "Nothing" to model a computation that produces nothing
13:17:21 <djahandarie> -_-
13:17:26 <djahandarie> 12:14  vixey this is not lisp
13:17:34 <Botje> younder: how do you model failing computations, then?
13:17:54 <Botje> say you're asking a remote server what someone's credit rating is
13:18:13 <younder> I throw a exception
13:18:26 <mauke> Nothing is an exception :-)
13:18:26 <Botje> that's a bit heavyweight
13:18:42 <mauke> welcome to MonadError
13:18:45 <Botje> heh
13:19:19 <younder> Not in Lisp which allows me to revover from the arror and rerun the code where it left off
13:19:50 <Philonous> :t ()
13:19:52 <lambdabot> ()
13:20:00 <Botje> exceptions are just GOTOs
13:20:04 <younder> Anyhow I need Just so I can counter it with Nothing because that is how algebraic types work
13:20:04 <Botje> and we all know GOTO is bad :)
13:20:07 <Saizan> well haskell is pure and strongly typed, so every "effect" must appear in the the type
13:20:10 <vixey> exceptions aren't goto
13:20:19 <mauke> exceptions are computed come-from
13:20:46 * Botje really hopes to not discover what come-from is :]
13:20:50 <Saizan> Botje: except that works for say, recusion too
13:21:00 <Deewiant> Botje: it's the counterpart to goto, quite obvious really :-)
13:21:15 <Botje> Saizan: but recursion is explicit
13:21:18 <Deewiant> implemented in INTERCAL and possibly elsewhere
13:21:20 <musiKk> comefrom appears in INTERCAL
13:21:32 <Botje> oh dear :P
13:21:37 <musiKk> :D
13:21:38 <Deewiant> originally a joke by... can't remember
13:21:48 <musiKk> yes, it's a joke language
13:21:55 <Deewiant> I meant come-from
13:22:00 <Vq^> the neat thing about comefrom is that it can be used to spark threads as well
13:22:01 <Botje> and I just started Gödel Escher Bach, too
13:22:03 <musiKk> that too
13:22:08 <Vq^> so it's more functional than goto
13:24:04 <Philonous> younder: The advantage of Maybe over nil is IMO that when your function returns Maybe you know you have to handle the special case Nothing, wheres for "normal" (i.e. not moandic) functions you can rely on them always return some meaningfull value that doesn't need to be checked
13:24:52 <nicknull> camio: http://hpaste.org/11150 , much nicer, good tip
13:25:03 <mmorrow> Botje: goto is t3h awesome!
13:25:18 <Philonous> And since Maybe is a monad you can even scrap the biolerplate code (like nested if's in C) and just let the monad handle failure of a function
13:25:46 <mmorrow> well, s/goto/jmp/
13:25:48 <younder> Philonous: Yes I guessed as much.
13:26:03 <Yoric[DT]> lambdabot: (.)
13:26:06 <camio> nicknull: Now I'd probably remove the redundancy in the transition function.
13:26:20 <Yoric[DT]> mmmhhh...
13:26:29 * Yoric[DT] obviously fails to remember the syntax of lambdabot.
13:26:53 <camio> nicknull: So I'd define the transition GateUp Weight_pushed = GateDown; And then transition GateUp _ = GateUp. Then I'd do the same for the GateDown cases.
13:27:01 <nicknull> philonius: that is very true, gave me some insight to maybe because ina  normal langauge exceptions kind of confused me. you cant check fro them all anyway, hen youd litter your code with checks so its kind of catch the most probable ones otherwise program -> die
13:27:13 <sm> g
13:27:17 <sm> g'day all
13:27:24 <Ferdirand> the whole point of exceptions is not to catch them all
13:27:51 <Ferdirand> to defer error handling to upper layers, where you can make more sensible decisions, without the pain of having to propagate status back to it
13:28:38 <Philonous> nicknull: There are exceptions in haskell, too. But normaly you don't abuse them as "expections" like you would in java. So yes, I agree
13:28:39 <nicknull> transition GateUp _ = GateUp , eh? doesnt that mean any Gateup should -> GateUpp?
13:29:06 <camio> nicknull: It goes to that case only when the above ones don't match.
13:31:20 <nicknull> lol yes a lot shorter :)
13:31:53 <nicknull> http://hpaste.org/11151
13:32:07 <camio> Yes, looking much nicer now.
13:32:46 <nicknull> but is it a finite state machine?
13:33:12 <camio> nicknull: What do you think?
13:34:18 <nicknull> yes
13:34:20 <nicknull> lol
13:34:34 <nicknull> but the concept of a finite state machine apply to most things if you want right?
13:35:59 <camio> I prefer the concept of lambda calculus as it applies to a whole lot more.
13:37:56 <nicknull> huh?
13:38:39 <camio> nicknull: A finite state machine, for example, can't tell me the length of its input.
13:39:37 <nicknull> so if i add a counter to my fsm func it is no longer an fsm?
13:39:46 <nicknull> or my fsm isnt an fsm?
13:39:51 <camio> correct
13:40:26 <nicknull> which one is correct?
13:40:41 <camio> the former
13:41:34 <nicknull> but why? an fsm stops being an fsm when it keeps track of itself?
13:41:55 <nicknull> then it becomes soemthing that encapsulates fsms
13:43:13 <camio> http://en.wikipedia.org/wiki/Finite_state_machine
13:43:15 <lambdabot> Title: Finite state machine - Wikipedia, the free encyclopedia
13:43:34 <camio> See the "Mathematical Model" section.
13:43:51 <Cthulhon> The F doesn't stand for 'flying'. :)
13:45:00 <camio> hehe
13:46:24 <nicknull> so it qualifies for the mathematical model right? but is is just state -> event -> state . i havent included actions but those are the same as events kind of, anywya
13:50:29 <nicknull> a yes or no would make me hapy
13:50:32 <dancor> @djinn (Int -> b) -> b
13:50:33 <lambdabot> Error: Undefined type Int
13:50:49 <younder> A fsm has to have deterministic state change. no "pumps" on state so there are some restrictions on the grammar
13:51:06 <camio> Your code models a FSM.
13:51:15 <nicknull> ty
13:51:19 <camio> Not all of them, but one of them.
13:51:24 <nicknull> younder: what do you mean pumps?
13:51:46 <nicknull> camio: you mean not all fsm ot you mean GateUp does, GateDown doesnt?
13:52:36 <nicknull> younder: i know i cant have statex -> eventx -> statey; statex -> eventx -> statez
13:52:37 <younder> well in a context senitive grammar  ' if' could call 'statement' and the statement call 'if' for instance
13:52:38 <camio> nicknull: I mean _a_ FSM in the same way I would say _a_ haskell program.
13:52:57 <nicknull> ok
13:56:47 <camio> nicknull: A fun fact, the set of regular expressions == the set of FSM's.
13:57:13 <camio> nicknull: For every FSM, there is an equivelant RE and vice versa.
13:58:44 <sbahra> nicknull, google "Pumping lemma"
14:00:04 <plutonas> if i have data Something = Num Integer | Var String | ... and so on
14:00:06 <pumpkin_> can I do fancy pattern matching for the same value in two different pairs?
14:00:08 <pumpkin_> func (x, y) (x, z) = moo
14:00:10 <pumpkin_> so I want to catch cases in which the two pairs have the same fst
14:00:19 <plutonas> how can i construct an element of type Something, for testing purposes
14:00:32 <plutonas> i mean so that it's considered as Something and not as Integer, or String etc
14:00:43 <mauke> plutonas: Num 42
14:00:48 <mauke> or Var "foo"
14:00:55 <plutonas> ooh, thanks
14:00:55 <mauke> pumpkin_: no
14:04:28 <bos> @seen juhp
14:04:28 <lambdabot> juhp is in #haskell. I last heard juhp speak 19h 18m 54s ago.
14:05:30 <plutonas> mauke: if the end of the data definition is deriving Show, do i have to set any other things for Show? i get some mistakes from missing show
14:05:45 <mauke> plutonas: no, that should work
14:05:56 <nicknull> http://hpaste.org/11153 , check the main there(the run_fsm solved the probably in another way). im not allowed to use recursive monads like that? it goes into infinite recursion
14:05:56 <plutonas> strange, anyway, thanks
14:06:59 <quicksilver> nicknull: there is nothing wrong with the recursion pattern in main
14:07:09 <quicksilver> nicknull: recursion in most monads works fine.
14:08:05 <nicknull> yes it was rthe let s = transition s i. i changed to new_s
14:09:08 <quicksilver> nicknull: right :) that was a recursive binding in s ;)
14:13:23 <pumpkin-> sorry, got disconnected
14:13:25 <pumpkin-> so what's the most "haskell"-y way of doing that sort of pattern matching? I'd like a function that takes two pairs and does two different things depending on whether the fst of the pairs is the same or not
14:13:52 <dcoutts> f (x,y) | x == y = ...
14:13:58 <ddarius> f (a,b) (c,d) | a == b = doA | otherwise = doB
14:14:01 <dcoutts>         | otherwise = ...
14:14:08 <pumpkin-> aha
14:14:16 <pumpkin-> a == c is what I need
14:14:25 <ddarius> That's what I meant.
14:14:29 <pumpkin-> cool, thanks
14:19:48 <pumpkin-> is the pipe in that context called a guard as well?
14:20:08 <chrisdone> ErrorT is one fine piece of programming stuff
14:20:08 <nicknull> what's the coolest thing you've done in haskell?
14:20:34 <ddarius> pumpkin-: The whole construct is called a guard.  The | character has no particular name in that context.
14:20:45 <dons> didn't we talk about this yesterday?
14:20:50 * dons is getting deja vu
14:21:05 <pumpkin-> yup
14:21:17 <pumpkin-> I get it now :) sorry!
14:27:24 <mightybyte> Is there a pure array implementation similar to Array, but that doesn't use association lists under the hood?
14:27:45 <mauke> wait, Array uses association lists?
14:27:50 <mauke> since when?
14:27:53 <ddarius> None of them use association lists
14:27:57 <chrisdone> I'm pretty sure Array is O(1)
14:28:16 <mightybyte> chrisdone: Weird.  I'm getting horrible performance with it.
14:28:27 <ddarius> Immutable arrays are O(n) update
14:28:27 <mauke> O(2000)
14:28:30 <opqdonut> mightybyte: what are you doing with it
14:28:31 <rwbarton> mightybyte: Are you using the // operator heavily?
14:28:35 <mightybyte> Yeah
14:28:37 <opqdonut> use difference lists
14:28:40 <opqdonut> gah
14:28:48 <mauke> use an impure array
14:28:53 <sbahra> mauke, O(2000)?
14:28:59 <mightybyte> mauke: Well, I was trying to avoid doing that.
14:29:04 <mauke> mightybyte: why?
14:29:06 <rwbarton> The // operator makes a copy of the whole array, so of course it's slow.
14:29:16 <mightybyte> mauke: As an exercise more than anything else
14:29:25 <opqdonut> or UArray?
14:29:40 <opqdonut> or DiffArray?
14:29:44 <mauke> can you use an IntMap instead?
14:29:55 <dons> slides for lispy's darcs talk up, http://www.galois.com/blog/2008/10/09/type-correct-changes-a-safe-approach-to-version-control-implementation/
14:29:55 <mightybyte> rwbarton: Yeah, when I substituted IntMap for Array, I got acceptable performance.
14:30:02 <lambdabot> Title: Galois › Blog › Blog » Type Correct Changes: A Safe Approach to Version Con ..., http://tinyurl.com/4decec
14:30:14 <opqdonut> mightybyte: DiffArrays have fast update
14:30:28 <opqdonut> but some access patterns still give horrible performance
14:30:32 <mightybyte> opqdonut: Ok, I'll check them out too.
14:30:34 <opqdonut> but you should probably try them out
14:30:51 <rwbarton> I've always heard DiffArrays are "slow" and never tried them.  Is there truth to that?
14:31:08 <opqdonut> well
14:31:10 <rwbarton> Because they seem like a good idea...
14:31:16 <lispy> dons: wow, that was fast, I was just coming here to see if you got them :)
14:31:18 <dons> they've not been   optimised in nearly 15 years.
14:31:23 <opqdonut> for single-threaded updates when you don't query far into the history
14:31:26 <opqdonut> they're acceptable
14:31:37 <opqdonut> of course, they're ugly as hell
14:31:47 <rwbarton> i.e. probably better than IntMap, but not as good as STArray?
14:32:02 <opqdonut> an IntMap or a random access list structure will probably be a better choice
14:32:07 <opqdonut> rwbarton: depends on the usage pattern
14:32:16 <rwbarton> Yeah, assume single-threaded update and use
14:32:48 <mightybyte> Ok, DiffArray is exactly what I was looking for.  A pure interface to a destructively updated array.
14:33:15 <mightybyte> ...at least it *sounds* like what I'm looking for.
14:33:27 <dons> IntMap is probably just as good, or better.
14:33:38 <ddarius> Try both and see what happens.
14:34:01 <rwbarton> Yeah, I'm curious to hear how it turns out
14:34:05 <mightybyte> dons: Better even though it doesn't have O(1) operations?
14:34:12 <romildo> Hi.
14:34:14 <opqdonut> O(1) is overrated
14:34:17 <mightybyte> lol
14:34:25 <dons> right. O(log n) is O(1) for all n
14:34:29 <opqdonut> :)
14:34:38 <lament> would it be ridiculously painful to switch from FooArray to IntMap?
14:34:42 <dons> and diff arrays have a significant k*1
14:34:43 <opqdonut> you probably aren't scaling enough to make the log growth show
14:35:38 <mightybyte> dons: It seems to me like there should be a way to make DiffArray have a small constant.
14:35:47 <dons> yes.
14:35:53 <opqdonut> 0031.18  dons$ they've not been   optimised in nearly 15 years.
14:35:58 <dons> i think sitting down and optimising it would be a reasonalbe idea
14:36:04 <opqdonut> SoC?
14:36:08 <pastorn> anyone here have experience with hcurses?
14:36:12 <dons> glguy wrote a union/find diff array based on uvectors that looked ok
14:36:15 <opqdonut> ('course, the next one is ages away)
14:36:26 <rwbarton> mightybyte: are you working on the same problem as before?
14:36:31 <ddarius> Isn't IntMap log log n?
14:36:35 <mightybyte> rwbarton: No
14:36:39 <pastorn> i vaguely remember that the argument order in standard hcurses are un-intuitive
14:36:40 <ddarius> (Probably not for updates...)
14:36:45 <mightybyte> rwbarton: The most recent one.
14:36:58 <ikegami__> I finished to read the "type correct changes"
14:37:01 <mauke> isn't IntMap O(32)?
14:37:04 <ikegami__> the slides
14:37:04 <djahandarie> ddarius, your name is almost my name :O
14:37:09 <ikegami__> good talk
14:37:33 <lispy> ikegami__: thanks
14:38:47 <ikegami__> i wish darcs source becomes not to be flagile, and works efficiently more
14:39:19 <ikegami__> currently, in my opinion, darcs is slow than other vcs
14:39:25 <ddarius> I used to go by Darius here, but Darius Bacon would happen along every now and then and he has more right to the name than I.
14:39:39 <mauke> mmh, bacon
14:39:42 <lispy> ikegami__: we've having world wide hacking sprints for darcs (focusing on performance) Oct 24-25
14:39:53 <olsner> hmm, "Moved emphasis of understanding from Patch Theory to Haskell's type system" ... is that really a *reduced* learning curve?
14:39:59 <ikegami__> good news
14:40:50 <lispy> olsner: right, it's hard to say without see how new people react.  But, certainly, Haskell's type system is better explained and understood by more people than patch theory
14:40:56 <ikegami__> I'm going to announce the hacking sprints to a Japanese Haskell community
14:41:27 <romildo> I am writing an application which uses a gtk tree view widget (from gtk2hs). One of the columns of the tree view should renderer an image. The file path to the image is given in the model. If gtk fails to load the image, the stock missing image item should be used. In the first case the attribute cellPixbuf is used, and in the second case, the attribute is cellPixbufStockId. I would use the attribute op (MV.cellPixbuf :=> pixbufNewFromFileAtSize fileP
14:41:27 <romildo> ath w h) in the first case, and (MV.cellPixbufStockId :=> stockMissingImage) in the second case. How can I combine them to implement the explained logic?
14:42:02 <olsner> yea, and the haskell type system does have more general applicativity
14:42:04 <dcoutts> romildo: I highly recommend that you load the pixbuf images first
14:42:18 <dcoutts> romildo: if you have to load them from file every time then the GUI will be very slow
14:42:38 <dcoutts> romildo: ie store the pixbuf in the model, not just the filepath
14:43:31 <romildo> dcoutts: then, how I would obtain a pixbuf corresponding to the stockMissingImage item?
14:52:10 <skorpan> http://img.4chan.org/b/src/1224021037889.jpg
14:52:47 <olsner> that'd better be sfw
14:52:54 <skorpan> it is
14:52:55 <opqdonut> :D
14:53:05 <lispy> skorpan: heh
14:53:06 <lispy> nice
14:53:30 <lispy> ikegami__: have you seen the announcements on haskell-cafe or the darcs wiki for the sprint?
14:53:52 <lispy> ikegami__: http://wiki.darcs.net/index.html/Sprints
14:53:55 <lambdabot> Title: Sprints - DarcsWiki
14:53:57 <lispy> ikegami__: we have 3 locations so far
14:54:09 <lispy> ikegami__: paris, portland or, and brighton
14:55:43 <insane> hello i'm trying to emerge wxhaskell on gentoo and during compiling i get the following error: wxc/src/extra.cpp:224: error: cast from ‘wxInputStream*’ to ‘int’ loses precision
14:55:54 <insane> does anyone know the solution?
14:58:18 <dcoutts> romildo: I think one is supposed to use the iconset stuff to get the stock icons. The stock icons are referenced by name and are affected by the current theme.
15:08:47 <plutonas> how can i go from a maybe type to a non-maybe type, or print an error if it's Nothing?
15:09:47 <Saizan> plutonas: pattern matching
15:10:03 <Saizan> > case Just 'a' of Just x -> x;
15:10:04 <lambdabot>   'a'
15:10:34 <Saizan> > case Nothing of Just x -> x; Nothing -> error "this shouldn't happen!"
15:10:35 <lambdabot>   * Exception: this shouldn't happen!
15:10:57 <plutonas> thanks!
15:11:29 <dblazakis> > maybe (error "this shouldn't happen") id $ Just 1
15:11:30 <lambdabot>   1
15:11:35 <dblazakis> > maybe (error "this shouldn't happen") id $ Nothing
15:11:36 <lambdabot>   * Exception: this shouldn't happen
15:12:24 <Saizan> > fromMaybe (error "this shouldn't happen") $ Nothing
15:12:25 <lambdabot>   * Exception: this shouldn't happen
15:18:15 <mmorrow> @index fromMaybe
15:18:15 <lambdabot> Data.Maybe
15:18:18 <mmorrow> @index maybe
15:18:19 <lambdabot> Data.Maybe, Prelude
15:20:10 <plutonas> what is this supposed to mean:  No instance for (Fractional Integer);      arising from a use of `/' at Expr.hs:82:34-62
15:20:22 <plutonas> can't i just divide two numbers?
15:21:08 <Philonous> > 2/3
15:21:10 <lambdabot>   0.6666666666666666
15:21:19 <ivanm> plutonas: if you want integral division, use div
15:21:28 <ivanm> > 4 `div` 3
15:21:30 <lambdabot>   1
15:21:52 <plutonas> hm, ok, thanks
15:22:14 <Philonous> > (2::Integer) / 3
15:22:15 <lambdabot>       No instance for (Fractional Integer)
15:22:15 <lambdabot>        arising from a use of `/' a...
15:23:12 <plutonas> i see, div is what i wanted
15:23:14 <lispy> > 2%3
15:23:15 <lambdabot>   2%3
15:23:26 <Philonous> :t (%)
15:23:27 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
15:23:38 <lispy> Do people actually use the ratio type at all?
15:23:49 <lispy> I don't recall ever seeing it in practice
15:23:52 <Axman6> i have
15:23:59 <ivanm> lispy: I think I"ve used it once or twice
15:24:15 <Philonous> > (1%3) + (5%3)
15:24:16 <ivanm> can't remember what for though...
15:24:17 <lambdabot>   2%1
15:24:18 <lispy> What sorts of ratios do you use it with?  What type of data?
15:24:25 <Axman6> made a project euler problem pretty easy. though still very inefficient, need to get back to that one -_-
15:24:58 <Axman6> i was using it for fractions, where i needed to filter all fractions that weren't 1%n
15:24:58 <chrisdone> this solutions is not sufficient ~_~
15:25:09 <lispy> > map (%2) [1..10]
15:25:10 <lambdabot>   [1%2,1%1,3%2,2%1,5%2,3%1,7%2,4%1,9%2,5%1]
15:25:47 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (%) fibs (tail fibs)
15:25:48 <lambdabot>       Occurs check: cannot construct the infinite type: a = Ratio a
15:25:48 <lambdabot>        Ex...
15:26:06 <lispy> :t zipWith (%)
15:26:07 <lambdabot> forall a. (Integral a) => [a] -> [a] -> [Ratio a]
15:26:12 <lispy> oh
15:26:23 <lispy> > fix $ \fibs -> 1%1 : 1%1 : zipWith (%) fibs (tail fibs)
15:26:24 <lambdabot>       Occurs check: cannot construct the infinite type: t = Ratio t
15:26:24 <lambdabot>        Ex...
15:26:30 <lispy> doh, still not riht
15:26:44 <Saizan> > fix $ \fibs -> 1 : 1 : zipWith (/) fibs (tail fibs) :: [Ratio Integer]
15:26:45 <lambdabot>   [1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%...
15:27:04 <Saizan> not what you wanted i guess :)
15:27:09 <lispy> Well, that's not very interesting :)
15:27:40 <lispy> > nub $ fix $ \fibs -> 1%1 : 1%1 : zipWith (%) fibs (tail fibs)
15:27:41 <lambdabot>       Occurs check: cannot construct the infinite type: t = Ratio t
15:27:41 <lambdabot>        Ex...
15:27:47 <lispy> oops, meant to do that on yours
15:28:01 <lispy> But, it's not going to return anyway
15:28:37 <lispy> ?pl \x y -> (x + y)/y
15:28:37 <lambdabot> join . ((/) .) . (+)
15:29:02 <lispy> > fix $ \fibs _> 1 : 1 : zipWith (join . ((/).).(+)) fibs (tail fibs) :: [Ratio Integer]
15:29:03 <lambdabot>   <no location info>: parse error on input `>'
15:29:13 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (join . ((/).).(+)) fibs (tail fibs) :: [Ratio Integer]
15:29:14 <lambdabot>   [1%1,1%1,2%1,3%2,7%3,23%14,167%69,3925%2338,661271%270825,2609039723%154605...
15:29:27 <mmorrow> , fix (\next m n -> m : next n (m+n)) 0 1
15:29:28 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
15:29:35 <lispy> ?pl \x y -> (x + ) / (x * y)
15:29:36 <lambdabot> ap ((.) . (/) . (+)) (*)
15:30:08 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (\x y -> (x+y)/(x*y)) fibs (tail fibs) :: [Ratio Integer]
15:30:09 <lambdabot>   [1%1,1%1,2%1,3%2,7%6,32%21,339%224,14287%10848,6877760%4843293,143806067571...
15:30:25 <mmorrow> , fix (\next m n -> if 1000 < m then [] else m : next n (m+n)) 0 1
15:30:27 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987]
15:39:30 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (\x y -> (product [1..x])/(product [1..y])) fibs (tail fibs) :: [Ratio Integer]
15:39:32 <lambdabot>   [1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%...
15:39:45 <lispy> > fix $ \fibs -> 1 : 2 : zipWith (\x y -> (product [1..x])/(product [1..y])) fibs (tail fibs) :: [Ratio Integer]
15:39:46 <lambdabot>   [1%1,2%1,1%2,2%1,1%2,2%1,1%2,2%1,1%2,2%1,1%2,2%1,1%2,2%1,1%2,2%1,1%2,2%1,1%...
15:40:08 <lispy> > fix $ \fibs -> 1 : 2 : zipWith (\x y -> (product [1..y])/(product [1..x])) fibs (tail fibs) :: [Ratio Integer]
15:40:09 <lambdabot>   [1%1,2%1,2%1,1%1,1%2,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%1,1%...
15:40:14 <lispy> I'm sort of disappointed
15:40:20 <mmorrow> heh
15:40:21 <lispy> I was hoping to see some interesting expressions
15:41:42 <sjanssen> > ap (zipWith (/)) tail $ fix $ \fibs -> 0 : 1 : zipWith (+) fibs (tail fibs)
15:41:44 <lambdabot>   [0.0,1.0,0.5,0.6666666666666666,0.6,0.625,0.6153846153846154,0.619047619047...
15:41:52 <lispy> oh, this one is better
15:41:53 <lispy> > fix $ \fibs -> 2 : 3 : zipWith (\x y -> (product [1..x])/(product [1..y])) fibs (tail fibs) :: [Ratio Integer]
15:41:55 <lambdabot>   [2%1,3%1,1%3,6%1,1%720,720%1,1%26012189435657951002049032270810436111915218...
15:42:07 <lispy> Notice how it keeps flip flopping
16:00:23 <juhp> bos: hi
16:07:33 <edwardk1> Heya bos!
16:07:43 <sbahra> :t fix
16:07:44 <lambdabot> forall a. (a -> a) -> a
16:08:46 <roconnor> wow, i think Haskell's laziness is going to let me compute my 95% confidence intervals on my distributions without computing the whole distribution
16:08:53 <roconnor> laziness++
16:09:06 <sbahra> laziness++
16:09:09 <bos> hi edwardk1
16:10:34 <lament> if you need 95% confidence intervals, you're doing statistics wrong :)
16:13:02 <roconnor> lament: oh, why is that?
16:13:08 <roconnor> I could be doing things wrong
16:14:05 <lament> nah, ignore me, i'm just trolling for bayesian stats
16:14:54 <ddarius> roconnor: http://bayes.wustl.edu/etj/node1.html
16:14:55 <lambdabot> Title: Edwin T. Jaynes - Bibliography
16:16:39 <lament> (bayesian vs non-bayesian seems a little like functional vs imperative in that it's way more elegant, yet much more obscure)
16:36:15 <edwardk> bayes++
16:39:30 <ddarius> jaynes++
16:40:24 <lispy> :t \i -> do { (i++); return i; }  -- See you can write C looking code in Haskell :)
16:40:25 <lambdabot> forall a. [a] -> [a] -> [a]
16:44:50 <lispy> have you guys ever seen those challenges where you write 1 source file that can be understood as N different languages?
16:45:09 <lispy> We could do programs that are dual Haskell and C :)
16:45:18 <pumpkin-> is there a good way to generate all six pairs of pairs such that first element is from [1, 2, 3] and second is from [5, 6], without using comprehensions or whatever that sugar expands to?
16:45:40 <dmwit> lispy: Usually such things amount to being really clever about comments, not about the actual syntax... =P
16:46:04 <dmwit> pumpkin-: Why would you put such a restriction?
16:46:22 <lispy> ?faq Can Haskell do your homework?
16:46:22 <lambdabot> The answer is: Yes! Haskell can do that.
16:46:26 <pumpkin-> lol
16:46:45 <pumpkin-> I'm not doing _my_ homework :P
16:46:50 <sjanssen> pumpkin-: yes, list comprehensions are just do expressions
16:47:29 <sjanssen> pumpkin-: anything that can be done with comprehensions can be done with the Monad operations
16:47:32 <ddarius> lispy: Lennart almost did that.
16:47:59 <ddarius> Unfortunately, usually just use comments in interesting ways.
16:48:13 <sjanssen> (>>=) (which is concatMap for lists), return, guard
16:48:13 <lispy> Ah, that Lennart
16:49:00 <Philonous> > [(1,5),(1,6),(2,5),(2,6),(3,5),(3,6)] -- no sugar, no sweetener ;)
16:49:02 <lambdabot>   [(1,5),(1,6),(2,5),(2,6),(3,5),(3,6)]
16:49:21 <Philonous> Oh, actually it's still sugared...
16:49:54 <edwardk> haskell and c should be kinda easy if you can be allowed to use cpp =)
16:52:05 <lispy> > (\xs ys -> map (map (\x -> (x,)) xs) ys) [1..3] ['a', 'b']
16:52:06 <lambdabot>   <no location info>: parse error on input `)'
16:52:16 <sjanssen> #ifdef GHC_VERSION
16:52:18 <sjanssen> :)
16:52:56 <lispy> I'm not sure what that was supposed to do, BTW
16:54:05 <TomMD> sjanssen: Are you still hanging out in your college town?
16:54:46 <sjanssen> TomMD: yeah
16:54:51 <dblazakis> lispy: have you seen that ioccc winner from a few years ago that was a lisp interpreter in C that was also a lisp program? (that ran on the interpreter)
16:55:13 <lispy> dblazakis: using lisp almost seems like cheating :)
16:56:15 <pumpkin-> I wonder how hard it would be to write a scheme interpreter in haskell
16:56:39 <dblazakis> ?go scheme in haskell
16:56:41 <lambdabot> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
16:56:41 <lambdabot> Title: Write Yourself a Scheme in 48 hours
16:56:52 <lispy> > (=<<) . flip (map . flip (,)) [1..3] ['a', 'b']
16:56:53 <lambdabot>   Couldn't match expected type `a -> a1 -> m b'
16:56:55 <pumpkin-> oh wow :)
16:57:07 <lispy> > ((=<<) . flip (map . flip (,))) [1..3] ['a', 'b']
16:57:08 <lambdabot>   [(1,'a'),(2,'a'),(3,'a'),(1,'b'),(2,'b'),(3,'b')]
16:57:23 <lispy> pumpkin-: ^^ ;)
16:57:39 <pumpkin-> :) thanks :P
16:57:58 <dmwit> There are *definitely* better ways than that!
16:58:07 <dmwit> But I'm still worried about that HW thing...
16:58:41 <lispy> dmwit: right, so if pumpkin- uses my solution pumpkin- will either have to do more work to understand it, or get marked down for being obtuse, I reckon ;)
16:59:45 <lispy> ?pl \xs ys -> [(x,y) | x <- xs, y <- ys]
16:59:45 <lambdabot> (. (return . (y <-))) . (:) . (((x, y) | x) <-)
16:59:56 <sbahra> dblazakis, sounds very cool
17:00:04 <lispy> Too bad, pl doesn't grok list comps
17:00:32 <lispy> Now that it understands do-notation we could desugar comps to do notation then undo and pl the result
17:00:53 <nicknull> is it easy to understand the darcs-source?
17:01:06 <sjanssen> nicknull: in my limited experience, no
17:01:17 <sjanssen> I'm sure lispy will chime in, though :)
17:01:23 <nicknull> is some of the performance problems fixed now or does it still have that quadratic performance on what was it, merging?
17:01:28 <lispy> nicknull: we've tried to make it a lot easier to understand :)  I gave a talk today on that very subject
17:01:30 <ddarius> ?. pl undo \xs ys -> [(x,y) | x <- xs, y <- ys]
17:01:31 <lambdabot> (. flip ((=<<) . flip flip [] . ((:) .) . (,))) . (>>=)
17:02:02 <lispy> nicknull: you're probably thinking of the exponential merge problem
17:02:43 <lispy> nicknull: The performance is a lot better in darcs2, but it could still be a lot better.  We're having a world wide hacking sprint for darcs Oct. 24-25th
17:02:59 <lispy> nicknull: and performance is the key concern
17:03:27 <lispy> ddarius: ah, cool.  I didn't realize undo understood list comps too
17:03:48 <dblazakis> sbahra: http://www.mikeash.com/lispob3.c
17:04:00 <sbahra> thx
17:04:14 <dblazakis> it is a quine in lisp and in C, a lisp interpreter
17:04:28 <sbahra> easier than i though
17:04:28 <sbahra> t
17:04:42 <sbahra> but cool
17:05:49 <dblazakis> haha easier? compressing a C program down to under 4096 bytes while still functioning in two languages seems pretty difficult to me
17:05:49 <lispy> sjanssen: I do think the un-readability of the darcs source is a valid complaint though.  We're just trying to make it better :)
17:05:59 <dblazakis> but the semicolon comment thing is definitely a nice trick
17:08:37 <BONUS_> :info Mu
17:08:46 <BONUS_> @info Mu
17:08:46 <lambdabot> Mu
17:08:49 <plutonas> how can i make a function call some functions that return type Maybe, until one returns something different than Nothing, and in case all return Nothing, act accordingly (e.g. give an error message)
17:09:07 <lispy> > Nothing `mplus` Just 1
17:09:09 <lambdabot>   Just 1
17:09:16 <lispy> > Nothing `mplus` Just 1 `mplus` Just 2
17:09:17 <lambdabot>   Just 1
17:09:36 <plutonas> lispy: thank you :)
17:09:45 <lispy> plutonas: np :)
17:10:12 <lispy> plutonas: I didn't actually know if it behaved the way you wanted :)
17:10:20 <plutonas> where do i find it though?
17:10:31 <dobblego> Control.Monad
17:10:40 <plutonas> > Nothing `mplus` Nothing
17:10:41 <lambdabot>   Nothing
17:10:45 <plutonas> nice :)
17:10:57 <BONUS_> also
17:11:05 <BONUS_> > msum [Nothing, Just 2, Just 8, Just 10]
17:11:06 <lambdabot>   Just 2
17:11:16 <BONUS_> > msum [Nothing, Nothing, Nothing]
17:11:17 <lambdabot>   Nothing
17:11:54 <luite> @src msum
17:11:54 <lambdabot> msum =  foldr mplus mzero
17:12:27 <luite> ah
17:18:44 <plutonas> what happens if one of the functions returns an error instead of Just or Nothing?
17:19:05 <plutonas> i'd like to print that error instead of continuing, but i suspect it's not working
17:19:20 <lispy> > msum [Nothing, error "ack no!", Just 1]
17:19:20 <dmwit> An error as in an exception?
17:19:21 <lambdabot>   * Exception: ack no!
17:19:26 <Philonous> @src Either
17:19:26 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
17:19:37 <plutonas> hm, strange, though i think my problem is deeper
17:19:37 <lispy> > msum [Nothing, Just 1, error "no problem" ]
17:19:38 <lambdabot>   Just 1
17:20:01 <newsham> ?src mconcat
17:20:01 <lambdabot> Source not found. My brain just exploded
17:20:26 <newsham> ?type mconcat
17:20:27 <lambdabot> forall a. (Monoid a) => [a] -> a
17:20:48 <lispy> msum == fromJust . head . catMaybes (with special handling for head []) right?
17:20:49 <newsham> > mconcat [Nothing, Just 2, Just 8, Just 10]
17:20:50 <lambdabot>   Add a type signature
17:22:14 <plutonas> what should i look for when i get this error:
17:22:16 <plutonas>  Ambiguous type variable `a' in the constraint:
17:22:59 <lispy> plutonas: it means that the type class couldn't be inferred
17:23:24 <newsham> look at the types of functions you're using that have type constraints
17:23:30 <lispy> plutonas: well, rather that the instance of the type class could not be inferred
17:23:32 <newsham> like "read" for example
17:23:35 <dmwit> plutonas: read is the most common one
17:23:44 <lispy> > read "1"
17:23:45 <lambdabot>   * Exception: Prelude.read: no parse
17:23:49 <lispy> ah
17:23:52 <dblazakis> :t read "1"
17:23:53 <lambdabot> forall a. (Read a) => a
17:23:57 <lispy> stupid mueval
17:24:03 <plutonas> hm, strange
17:24:06 <lispy> GHCi> read "1"
17:24:07 <lispy> <interactive>:1:0: Ambiguous type variable `a' in the constraint:
17:24:17 <dmwit> > read "()"
17:24:18 <lambdabot>   ()
17:24:21 <dmwit> lispy: ^^
17:24:35 <dmwit> It's not mueval's fault, it's defaulting's fault. =)
17:24:43 <plutonas> i have something like function str = function1 str `mplus` function2 str `mplus` ... `mplus` function7 str
17:24:50 <plutonas> running functionX str works fine
17:25:00 <plutonas> running function str gives me this ambigouus type
17:25:15 <newsham> pluto: perhaps it cant imply what kind of monadplus you want
17:25:26 <dmwit> :t mplus
17:25:27 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
17:25:40 <dmwit> plutonas: Perhaps your contained type is overconstrained.
17:25:44 <plutonas> newsham: what does this mean, how could i let it know what i want?
17:25:51 <plutonas> overcontstrained?
17:25:55 <plutonas> you confuse me guys
17:26:10 <dmwit> (Integral a, Fractional a) => Maybe a -- a classic overconstrained type
17:26:49 <dmwit> :t let x = 1 / 2; y = 3^x in x
17:26:50 <lambdabot>     Ambiguous type variable `b' in the constraints:
17:26:50 <lambdabot>       `Fractional b' arising from a use of `x' at <interactive>:1:21
17:26:50 <lambdabot>       `Integral b' arising from a use of `^' at <interactive>:1:19-21
17:26:52 <dblazakis> what are the types of the functions?  are they all the same String -> Maybe a
17:27:49 <dmwit> :t msum . sequence :: [e -> Maybe a] -> e -> Maybe a
17:27:51 <lambdabot>     Couldn't match expected type `e -> Maybe a'
17:27:51 <lambdabot>            against inferred type `[Maybe a]'
17:27:51 <lambdabot>       Expected type: [e -> Maybe a] -> [m a1]
17:27:57 <plutonas> dmwit: so what's the problem here? can't 3(^1/2) be defined?
17:28:03 <sbahra> Is there some function that can pretty print ByteStrings?
17:28:07 <dmwit> plutonas: Yes, but not using (^).
17:28:19 <sbahra> or atleast rather than: Chunk "wm2-4.0_2" Empty
17:28:21 <plutonas> why not?
17:28:23 <sbahra> just "wm2-4.0_2"
17:28:23 <dmwit> plutonas: (^) restricts its second argument to be integral, so it can use a (potentially exact) looping algorithm.
17:28:24 <sbahra> for example
17:28:24 <newsham> pluto: if you want to narrow it down, you can add a "where" clause with definitions for the subexpressions in your expression, and add type annotations for them all
17:28:30 <newsham> to make sure that you and the compiler agree on the types
17:28:55 <dmwit> plutonas: The point here being that if you have function1 and function2 returning different types (or even polymorphic types with different contexts), that may be the source of your problem.
17:29:03 <plutonas> dmwit: i see...
17:29:58 <plutonas> dmwit: they all return either nothing or Just(FixedTypeHere, String)...
17:30:09 <sbahra> hm
17:30:14 <sbahra> liftM it is ;[
17:30:32 <plutonas> though the fixed type can have more forms, if i get it right
17:30:35 <dmwit> plutonas: Maybe you should hpaste.
17:30:38 <plutonas> ok
17:30:48 <dblazakis> plutonas: have you annotated them all with type signatures?
17:31:09 <ozy`> dmwit: isn't there another operator that raise a number to a non-integral exponent?
17:31:13 <plutonas> dblazakis: nope
17:31:38 <dmwit> ozy`: Certainly.  The number functions are so tangential to the point here, though.
17:32:06 <ozy`> just curious :p
17:32:08 <dblazakis> plutonas: whenever i get type errors I don't understand, i play a bit in GHCi to make sure I understand the types of everything -- I also annotate all my functions
17:32:13 <dmwit> :t (**) -- ozy`
17:32:14 <lambdabot> forall a. (Floating a) => a -> a -> a
17:32:20 <dmwit> Also,
17:32:21 <dmwit> :t (^^)
17:32:22 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
17:32:25 <dblazakis>  :t works in GHCi too (not just lambdabot)
17:32:27 <newsham> > 0.123 ** 1.234
17:32:28 <lambdabot>   7.532565338931238e-2
17:32:45 <newsham> > pi ** pi
17:32:46 <lambdabot>   36.4621596072079
17:32:57 <plutonas> dmwit: i'm not sure i want to paste my code in hpaste, it's homework code, and the professor wouldn't be happy to find it online... i thought i could limit what i put, but if i put all 7 functions...
17:32:58 <dmwit> > pi ^^ 3 :: CReal
17:32:59 <lambdabot>   31.0062766802998201754763150671013952022253
17:32:59 <plutonas> :(
17:33:15 <dmwit> plutonas: ok
17:33:24 <dmwit> plutonas: Just play with the types of each function in ghci, then.
17:33:28 <newsham> > pi ** pi :: CReal
17:33:30 <lambdabot>   36.4621596072079117709908260226921236663655
17:34:22 <lispy> plutonas: if you're using mplus in homework, you may need to defend your understanding of it.
17:34:32 <lispy> plutonas: Have you studied monads yet?
17:34:36 <lispy> :t mplus
17:34:37 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
17:34:41 <lispy> plutonas: and type classes?
17:35:56 <lispy> plutonas: on the other hand, it should be quite easy for you to define something just like mplus
17:36:15 <plutonas> lispy: nope
17:36:30 <plutonas> dmwit: lispy, though all the functions types are the same, just a sec
17:38:23 <djahandarie> What would be the easiest way to use MySQL with Haskell? (I don't want a pure haskell binding... I just want to use normal MySQL commands)
17:38:24 <newsham> > mconcat . map First $ [Nothing, Nothing, Just 8, Nothing, Just 5]
17:38:25 <lambdabot>   First {getFirst = Just 8}
17:38:56 <dmwit> :t msum
17:38:57 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
17:38:59 <dmwit> :t mconcat
17:39:00 <lambdabot> forall a. (Monoid a) => [a] -> a
17:39:00 <lispy> djahandarie: I want to say HDBC then, but I'm not really an expert on that subject
17:39:10 <newsham> you can use hdbc with mysql if you set up an odbc thingy for mysql
17:39:26 <djahandarie> Hm, okay.
17:39:37 <newsham> i dont know if thats the "easiest", but thats a way
17:39:43 <dblazakis> :t First
17:39:44 <lambdabot> forall a. Maybe a -> First a
17:39:53 <plutonas> http://hpaste.org/11158
17:39:56 <dblazakis> @src First
17:39:56 <lambdabot> Source not found. It can only be attributed to human error.
17:41:18 <newsham> *Statement> :type parse
17:41:18 <ronwalf> Anyone know of a rete-esque rule system implemented in haskell?
17:41:18 <newsham> parse :: (Parse a) => String -> Maybe (a, String)
17:41:34 <plutonas> lispy: dmwit: i pasted the signatures, and the function that uses mplus, i hope this is enough information... can't paste more, and can't understand the problem...
17:41:45 <lispy> plutonas: newsham already pointed it out :)
17:41:57 <lispy> plutonas: the problem is that we don't know what 'a' should be
17:42:12 <newsham> pluto: when you run "parse" it doesnt konw what kind of return value (out of a set of possible return value types) you want
17:42:26 <newsham> since it can return a Maybe (a, String) for a number of different a's
17:42:33 <plutonas> oh
17:42:45 <mapreduce> > 3 :: Num Integer
17:42:46 <dmwit> plutonas: Oh!
17:42:46 <lambdabot>       Class `Num' used as a type
17:42:47 <lambdabot>      In the type `Num Integer'
17:42:47 <lambdabot>      In an ex...
17:42:54 <lispy> parse "blah" :: (Maybe Int, String) that would be differente
17:42:55 <newsham> try:  parse "..." :: Maybe (Statement, String)    ?
17:42:57 <dmwit> plutonas: Just pick an instance of Parse for your return type.
17:43:11 <newsham> or whatever type you want
17:43:36 <mapreduce> :kind Num
17:43:44 <dmwit> Though I'm not really sure how it came up with that type for parse.
17:43:57 <lispy> I was about to type the same thing
17:44:06 <lispy> :t mplus
17:44:07 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
17:44:22 <lispy> :t \a b -> a `mplus` b
17:44:23 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
17:44:33 <dmwit> plutonas: I think you're lying about either the types of those functions or the definition of parse. =)
17:44:41 <dmwit> :t (msum .) . sequence
17:44:42 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m) => [a1 -> m a] -> a1 -> m a
17:44:55 <newsham> also, are you supposed to be using a parsing library?
17:44:58 <newsham> or writing your own?
17:45:06 <plutonas> dmwit: am not lying
17:45:06 <newsham> there might be neater notation than "mplus"
17:45:07 <dmwit> :t (msum .) . sequence :: [e -> Maybe a] -> e -> Maybe a -- =)
17:45:08 <lambdabot> forall e a. [e -> Maybe a] -> e -> Maybe a
17:45:24 <plutonas> the only thing i didn't mention is that the parse definition comes in instance Parse statement where ...
17:45:36 <dmwit> plutonas: ah =)
17:45:44 <plutonas> which gives me trouble adding a type definition
17:46:21 <lispy> so you have a class Parse that defines a method parse?
17:46:43 <plutonas> it defines it as Parser a
17:47:05 <newsham> so parse is supposed to return a type of Parser a?
17:47:07 <plutonas> oh is this where i put the type definition?
17:47:18 <newsham> and each of your internal functions returns a Maybe (Statement, String)?
17:47:24 <newsham> is that a conflict?
17:47:28 <plutonas> yes Parser a means : String -> Maybe (a, String)
17:47:37 <lispy> plutonas: so, what is Statement?
17:47:45 <newsham> or is this instance just for Statement?
17:47:47 <dblazakis> plutonas: you may want to go read up a bit on typeclasses
17:48:12 <plutonas> lispy: Statement can be of 7 different types
17:48:29 <plutonas> each of the functions for which i pasted the type parses one kind of statemnt
17:48:36 <lispy> plutonas: what *is* Statement then?  A type class?
17:49:11 <lispy> plutonas: or do you mean you have, data Statement = Assignment ... | If ..., etc?
17:49:22 <plutonas> data Statement = Assignment String Expression | If Expression Statement Statement | etc
17:49:27 <plutonas> lispy: yes
17:49:51 <lispy> plutonas: okay, so the terminology is that Statement is a type, and Assignment, If, etc are data constructors
17:50:30 <lispy> plutonas: for example, Assignment has type, String -> Expression -> Statement :)
17:51:09 <lispy> plutonas: that is, Assignment is a constructor of 2 params that returns a value of type Statement.  Does that make sense?
17:51:19 <plutonas> hm, i see, is this what makes the ambiguity?
17:51:28 <plutonas> lispy: yes it does make sense
17:51:30 <dmwit> plutonas: You might not need type classes at all, if I'm understanding you correctly.
17:51:34 <lispy> plutonas: Well, how many instances of Parser, do you plan on making?
17:52:14 <lispy> plutonas: you can't make one for each data constructor, BTW.  Only one instance per *type*
17:52:15 <plutonas> lispy: i have really a lot of them already
17:52:24 <plutonas> don't think i'll make any more though, now it's just about combining them
17:52:42 <plutonas> hm
17:52:47 <BMeph> sbahra: Is there a perf hit from 'unpack'-ing that you want to skip? :)
17:53:52 <plutonas> lispy: you mean i can't have 7 different functions with this type?
17:54:02 <BMeph> sbahra: BTW, sorry for jumping into a topic that's a half-hour too late. :)
17:54:05 <lispy> plutonas: I suspect, without looking at your code, that you were envisioning making an instance of Parser for each data constructor.  You could still do this, but it would require that you make each data constructor for Statement into it's own type, which I wouldn't advise.
17:54:21 <lispy> plutonas: you can do that, but I suspect you don't want to
17:54:58 <dmwit> plutonas: If you have only one instance declaration, then you may get rid of the type class altogether.
17:55:09 <dmwit> plutonas: Classes are only interesting when there is more than one instance of them.
17:55:28 <plutonas> dmwit: no don't want to get rid of the Class...
17:55:29 <lispy> dmwit: *cough* unless you're doing some type level hackery :)
17:55:30 <dmwit> plutonas: This may be a terminology thing; classes in Haskell are not much like classes from, say, C++ or Java.
17:55:53 <lispy> plutonas: Besides Statement, what is an instance of Parser?
17:55:55 <plutonas> dmwit: no, the class code was not written by me, and i don't speak C++ neither java :)
17:55:57 <dmwit> plutonas: In Haskell, a "class" is more like a set of types -- so, "class" in the mathematical sense.
17:56:18 <dmwit> plutonas: Sets with only one element aren't so interesting... hence my comment about singleton instances. =)
17:56:25 <humasect> a class in c++/java is almost like how it is in smalltalk : still an object, not really a class.
17:56:31 <BMeph> lispy, plutonas: Couldn't you define this in a GADT and simplify it? :)
17:56:42 <BMeph> *s/in/as/
17:56:47 <plutonas> lispy: i have a lot, actually almost 90% of my functions are instances of Parser
17:56:59 <lispy> BMeph: Oh probably, but for a first or second term Haskell student that may be overkill :)
17:57:12 <dmwit> plutonas: Again, this is a terminology problem.
17:57:23 <dmwit> lispy isn't asking how many functions return things of type Parser a => a.
17:57:32 <dmwit> He's asking how many types a fit the bill "Parser a".
17:57:37 <lispy> plutonas: because Parser is a type class, only types can be instances.  so I think we're miscommunicating still.
17:57:40 <humasect> what kind of problem is there that is not a terminology/vocabulary problem ?
17:57:40 <dblazakis> plutonas: a function can't be an instance
17:57:44 <dmwit> That is, how many times have you written "instance Parser Foo where ..."?
17:57:47 <dblazakis> ok, that's not true
17:57:52 <dblazakis> but it's probably not what you mean
17:58:20 <BMeph> lispy: O RLY?!? I like GADT-style, even for ADTs... :)
17:58:34 <dmwit> humasect: Here's one from earlier today: how can I write dynamic code loading with low syntax overhead in Haskell?
17:58:36 <lispy> BMeph: yeah, GADTs are cool :)
17:58:40 <humasect> often haskell code itself speaks volumes over any description of it. the keywords, the statements, they are the terminology =)
17:58:41 <SamB_XP> BMeph: doesn't everyone ?
17:58:48 <dmwit> It's not a terminology issue, it's just something that's kind of outside the bounds of what Haskell was made to do.
17:58:49 <plutonas> lispy: i'm not sure i entirely understand, but if you mean this, i have functions with type Parser a, Parser Char and Parser String
17:59:19 <dobblego> plutonas, are you working out of the Graham Hutton book?
17:59:21 <lispy> plutonas: as dmwit said, how many times, and for which types, have you written "instance Parser Foo where"?
17:59:23 <humasect> dmwit: hehe, so in a way: that is a terminology that haskell is unaware of. like a talking cat. in some movies cats can talk, in others they cannot ..
17:59:42 <dmwit> humasect: That's not what I mean by a terminology problem, and you know it.
17:59:52 <plutonas> dobblego: nope
18:00:04 <plutonas> lispy: oh
18:00:11 <newsham> did you write the instances Parser Char and the definition for parse for Char?
18:00:14 <newsham> or was that given?
18:00:14 <mmorrow> "<dmwit> It's not a terminology issue, it's just something that's kind of outside the bounds of what Haskell was made to do."
18:00:27 <mmorrow> dmwit: but something which Haskell can easily accomplish ;)
18:00:29 <BMeph> dmwit: ...which is a terminology issue! The issue being what's Haskell's problem set. ;)
18:00:56 <plutonas> 5 times
18:01:05 <plutonas> newsham: it was given
18:01:15 <dmwit> mmorrow: I disagree.
18:01:19 <mmorrow> dmwit: (just write a linker..) (i'm serious, there already are a few)
18:01:21 <newsham> and your task is to write instance Parser Statement?
18:01:30 <lispy> plutonas: be so kind as te let me know which types appear across those 5 instances?  Presumable, Statement, but what else?
18:01:38 <mmorrow> dmwit: (a linker in /Haskell/ that is)
18:01:46 <br1> There's something I don't understand in Pierce's "Types and Programming Languages". Does someone have it nearby and can give me a hand?
18:02:16 <dmwit> mmorrow: As far as I know, hs-plugins and GHC's API are the best ways to do code loading right now.  I wouldn't exactly call either of them low-overhead compared to, say, lisp.
18:02:21 <dmwit> mmorrow: That's not a bad thing.
18:02:30 <dmwit> I think code loading is usually not the right solution.
18:02:41 <dmwit> br1: shoot
18:02:46 <plutonas> it's actually 3 times sorry
18:02:53 <plutonas> it's Statement, T, and Expr
18:02:57 <mmorrow> dmwit: the right solution for what? things for which it's a solution for are impossible to do without it.
18:02:59 <humasect> read/show is good enough for most things =)
18:03:06 <mmorrow> s/for//
18:03:09 <lispy> plutonas: cool, thanks, so that gives me a better idea of what you're doing
18:03:23 <humasect> mmorrow=)
18:03:26 <BMeph> dmwit: Technicall, aren't dynamic code loading and syntax overhead more compiler issues than language issues?
18:03:47 <plutonas> lispy: really? i'm still looking what T is in that case, as T is defined in different places
18:04:03 <humasect> *parsec/read/show
18:04:07 <mmorrow> humasect: that "s/for//" was refering to my previous sentence (in case that's what you're talking about) :)
18:04:21 <lispy> plutonas: I still think it's weird thta parse is giving this error.  If you add this line to your program, does the error go away?  parse :: String -> Maybe (Statement, String)
18:04:25 <humasect> i was smiling of the previous sentence. almost=)
18:04:36 <br1> dmwit: I don't understand how the second object encoding in chapter 27 avoids repeating the method table per object, since the methods are already wired with the representation.
18:05:48 <dmwit> BMeph, mmorrow: Getting back on track: some problems are terminology issues.  Some are not.  That is all I claimed originally, and I doubt you'd disagree with me very hard.
18:05:57 <newsham> lispy: why is it weird? if parse can parse many types of things, and he didnt specify what type of parse he wants, then its going to have an error
18:06:10 <dmwit> br1: You'll have to give me a second to re-read what the two representations are.
18:06:16 <plutonas> lispy: add it where? i get that it's misplaced
18:06:27 <BMeph> dmwit: Well, depending on how you'd define... -- ;p
18:06:28 <br1> dmwit: Sure. Thank you.
18:06:34 <newsham> pluto: did you try specifying the return value you want to get out of parse?
18:06:40 <lispy> plutonas: on the line above the definition of parse, for instance
18:06:58 <lispy> newsham: but, everything in the body of parse uses the same explicit instance of Parse, right?
18:07:09 <plutonas> lispy: misplaced still
18:07:11 <plutonas>   Misplaced type signature:
18:07:11 <newsham> lispy: but its in an instance decl, and there are other instances
18:07:11 <plutonas>     parse :: String -> Maybe (Statement, String)
18:07:11 <plutonas>     You cannot give a type signature for an imported value
18:07:36 <newsham> parse :: (Parse a) => String -> Maybe (a, String)
18:07:50 <newsham> you need to specify what kind of "a" you want in the return
18:08:04 <newsham> ie:   parse "this is my string" :: Maybe (Int, String)
18:08:38 <newsham> since you have Parse a instances for Int and Char and Statement and others
18:08:46 <mmorrow> dmwit: i definitely agree with you on that. i disagree though on the need for a to-mach-code compiled lang dynamically linking more code into itself to be something that that lang was "designed to do" at the language level though :)
18:08:50 <dons> ?users
18:08:51 <lambdabot> Maximum users seen in #haskell: 518, currently: 466 (90.0%), active: 16 (3.4%)
18:08:52 <dons> ?uptime
18:08:52 <lambdabot> uptime: 4d 5h 58m 30s, longest uptime: 1m 10d 23h 44m 29s
18:09:29 <lispy> newsham: oh, right parse is in a type class
18:09:50 <lispy> how quickly I forget
18:10:02 <plutonas> i don't understand anything
18:10:11 <BMeph> andrewsw: Welcome back. ;)
18:10:14 <mmorrow> ELF++
18:10:14 <plutonas> also got quite late, and can't think so clear anymore...
18:10:27 <andrewsw> hiya BMeph
18:10:58 <plutonas> anyway, i still don't understand the problem, but i'd like to thank you all for your help/time :)
18:11:54 <newsham> pluto: when you say:  parse "foo"
18:11:55 <lispy> plutonas: the type signature of parse has to be suitable to work with all instances of Parser, hence the type variable 'a'.  But, you need to specialize your usage to the fact that you're parsing Statement, that's why newsham suggestion works
18:11:59 <newsham> what is the return type of parse gong to be?
18:12:14 <newsham> or even more fundamentally, what "parse" is it going to run?
18:13:14 <newsham> the answer is it wil pick the one that matches the right return type you ask for
18:13:24 <newsham> but if you dont specify what return type you want, it cant pick between them
18:13:34 <newsham> hence "a" is ambiguous in parse :: (Parse a) => String -> Maybe (a, String)
18:13:40 <mib_n6kjgw> i wanna write a function that break, that breaks every 5 elemenst
18:13:43 <newsham> the solution is to tell it what return type you want
18:13:46 <plutonas> ooh
18:13:53 <dmwit> br1: Remember that evaluation stops at the outermost lambda in TaPL's version of the world -- but not until then!
18:14:01 <plutonas> i got it now
18:14:13 <newsham> mib: so turns "abcdefghijk" int "abcde","fghij", "k" ?
18:14:18 <plutonas> it doesn't know if it has to parse an expression or a statement etc
18:14:22 <newsham> yup
18:14:26 <dmwit> br1: So "setCounterClass", which is in a let, only gets called once, even if we call newSetCounter several times.
18:14:26 <newsham> so tell it which one you want
18:14:35 <plutonas> a bit slow but finally got it :P
18:14:51 <newsham> no problem, its an unusual concept that isnt in most other languages
18:16:00 <plutonas> newsham: so should i use a data constructor to make my string, on which i run parse?
18:16:01 <nicknull> fakk i hate windows. i mean seriously without asking fakking donkeysoft just starts downloading some huge program fires the cpu to 100% so i cant work. so incredibly retarded and so shouldnt be like that 2008
18:16:26 <plutonas> doesn't make sense
18:16:33 <plutonas> how do i tell it that it's a statement?
18:16:44 <nicknull> say -> statement
18:16:49 <ddarius> @src Show
18:16:50 <lambdabot> class  Show a  where
18:16:50 <lambdabot>     showsPrec :: Int -> a -> ShowS
18:16:50 <lambdabot>     show      :: a   -> String
18:16:50 <lambdabot>     showList  :: [a] -> ShowS
18:16:50 <mib_n6kjgw> i wanna write a function that break, that breaks every 5 elements
18:17:13 <newsham> pluto: just tell it what type yo uwant
18:17:14 <nicknull> palin -> iqtest -> maybe(fail, uberfail)
18:17:17 <newsham> > read "5" :: Int
18:17:18 <lambdabot>   5
18:17:24 <newsham> > read "Just 5" :: Maybe Float
18:17:25 <lambdabot>   Just 5.0
18:17:28 <br1> dmwit: But setCounterClass isn't provided with all its arguments in the let. The method table is created inside the lambda that is left.
18:17:30 <newsham> ?type read
18:17:31 <lambdabot> forall a. (Read a) => String -> a
18:17:39 <newsham> the same thing happens with 'read'.  see how I specified the type?
18:18:12 <dmwit> br1: The method table *is* the lambda (\r -> {get,set,inc}).
18:18:26 <plutonas> i see !!!! works!
18:19:04 <plutonas> thanks a lot everyone
18:19:22 <newsham> sometimes the return type will be obvious from one of the uses of the return value
18:19:25 <newsham> and you wont have to specify it
18:19:30 <nicknull> are regexps non-haskellish? after finishing my simple FSM im thinking about doing a dfa to implement a regexp-engine
18:19:49 <newsham> > read "\"test\"" ++ "!"
18:19:50 <lambdabot>   "test!"
18:20:51 <br1> dmwit: But newSetCounter does supply r at the end. Shouldn't it leave it at that?
18:21:15 <mmorrow> nicknull: i think a fair amount of people have written code for that and can link you to theirs if you'd like (for reference/example/whatever).
18:21:31 <mmorrow> nicknull: i know Cale has some code for that.
18:21:40 <Cale> wha?
18:21:48 <Cale> ah
18:22:01 <mmorrow> Cale: didn't you link to some DFA.hs or something on your site a few days ago?
18:22:05 <Cale> yeah
18:22:24 <Cale> actually several people had done almost the same thing there, and I was one of them :)
18:22:46 <Cale> Implementing NFA's in Haskell is extremely easy.
18:22:57 <mmorrow> Cale: could you relink? i'd like to check that out as well. :)
18:23:24 <SamB_XP> isn't an NFA just a DFA anyway ?
18:23:26 <nicknull> id like to see any code doing that thanx
18:23:28 <Cale> http://cale.yi.org/share/Regular.hs
18:23:38 <Cale> SamB_XP: except with the state being a set.
18:23:45 <mmorrow> awesome, thx
18:23:48 <SamB_XP> Cale: yes
18:24:11 <SamB_XP> but any DFA could have sets for state
18:24:24 <Cale> right.
18:24:45 <Cale> An NFA is just a special kind of DFA when you look at it the right way.
18:25:03 <Cale> (and of course, vice versa)
18:27:00 <Cale> My Regular.hs has some code for inequality comparisons on regular expressions (which goes via the construction of their NFA's)
18:29:27 <Cale> (that is, via the inclusion partial ordering on their languages)
18:32:06 <sbahra> http://elide.org/libfsm is kind of interesting.
18:32:09 <lambdabot> Title: libfsm - Trac
18:32:21 <sbahra> Missing a good amount of features, but still useful.
18:32:22 <hackage> Uploaded to hackage: MemoTrie 0.1
18:33:41 <sbahra> nicknull, can we see the sourcecode to your fsm stuff?
18:34:17 <ddarius> sbahra: How is libfsm interesting?
18:40:55 <sbahra> ddarius, it does my homework
18:41:19 <sbahra> It isn't really interesting (it is elementary). :-) But it is useful for some simple problems.
18:42:18 <keseldud1> quick question about lambdabot... I added "import Text.Regex.PCRE" and "import Text.Regex.Base" to L/Pristine.hs, but it says "=~" isn't in the scope
18:42:29 <keseldud1> is there anything I can do to make it in scope?
18:42:54 <br1> dmwit: thank you for your time.
18:47:50 <Cale> keseldude: mm... depending on which version you're using, you may have to add it to a list of modules specified in the code for mueval
18:48:09 <keseldude> ah
18:48:18 <Cale> iirc, Context.hs
18:48:39 <nicknull> sbahra: it is just 20-liner, as basic a fsm as you can do...not something general
18:49:00 <andrewsw> what is the maximum size of a data.sequence? I'm getting index out of bounds on 1*10^6 elements, but not on 1*10^5
18:49:06 * andrewsw is trying other numbers
18:49:26 <alexsuraci> would anyone recommend me buying this book? http://www.amazon.com/Haskell-School-Expression-Functional-Programming/dp/0521644089/ref=sr_1_7?ie=UTF8&s=books&qid=1224034703&sr=8-7
18:49:29 <lambdabot> http://tinyurl.com/4degkz
18:49:52 <keseldude> Cale: I installed mueval with cabal :(
18:49:55 <keseldude> no Context.hs
18:49:58 <keseldude> only a Context.hi
18:50:24 <Cale> keseldude: you'll find it in .cabal/packages/hackage.haskell.org/mueval/
18:50:29 <Cale> (zipped up)
18:50:36 <keseldude> ah
18:50:38 <keseldude> thanks
18:50:44 <Cale> You can unpack that, edit it, and then  cabal install  from that directory
18:52:21 <Cale> alexsuraci: Well, it's supposed to be good, but it's probably aging.
18:52:42 <keseldude> Cale: should I add it to default modules or safe modules?
18:52:46 <keseldude> I don't understand the difference
18:52:49 <Cale> default
18:53:19 <Cale> The safe ones are not loaded by default, but are permitted when specified on the commandline.
18:53:40 <Cale> There are a lot of very unnecessary "security" precautions in mueval, which I just hack out by hand.
18:53:53 <dons> boo on mueval. runplugs forever!
18:54:00 <keseldude> :P
18:54:19 <alexsuraci> Cale: That's what I was thinking. 8 years is quite a while.
18:54:23 <Cale> dons: You should make it into a cabal package :)
18:54:29 <keseldude> yay, it works now <3
18:55:00 <dons> a simple, clean security mechanism. used in the wild.
18:55:21 <Cale> alexsuraci: Graham Hutton's book is supposed to be really good for what it covers, but from what I understand it doesn't get to many advanced topics.
18:55:39 <dons> yes, it's an introductory programmer's book
18:55:55 <keseldude> for mbot, I think it would be neat if you took advantage of Mathematica's Export function to allow the users to plot stuff and host the image
18:56:04 <dons> that's a nice idea.
18:56:06 <Cale> There's also Real World Haskell, which has the advantage of being available online :)
18:56:14 <alexsuraci> Cale: I have a basic understanding of Haskell so far (I'm coming from a Python/Ruby/PHP backing), I wouldn't mind some in-depth explanations.
18:56:26 <alexsuraci> Real World Haskell is what got me started. :)
18:57:01 <alexsuraci> It felt like it was skimming over too many things, though.
18:57:06 <dons> oh?
18:57:16 <dons> 700 pages of skimming. /me isn't sure what to think
18:57:23 <Cale> keseldude: I thought about it, but limiting the amount of functionality present is probably a good thing, given the questionable legal issues surrounding giving random people access to one's copy of mathematica.
18:57:31 <dons> you could write a book about each chapter of rwh, though, imo.
18:57:37 <alexsuraci> Haha, fair enough. I just didn't digest it very well.
18:57:37 <dons> there's a lot to explore
18:58:08 <keseldude> Cale: ah, I didn't really consider that
18:58:19 <keseldude> maybe I'll implement it for my personal use, though
18:58:50 * andrewsw is overflowing and trying to look up negative indexes...
19:00:51 <dons> use Word keys? :)
19:01:12 <Cale> ehehe
19:01:21 <Cale> Use Integer keys!
19:01:21 <dons> Int is the work of the devil, sent here to stimulate dependent type research
19:01:33 <andrewsw> I'm learning.
19:01:49 * Cale likes his keys to be capable of growing to the size of memory.
19:01:51 * pastorn wants haskell reflection
19:02:04 <andrewsw> I couldn't figure out why it would throw an exception on what seemed to be small values...
19:02:16 <dons> pastorn: read the comparative generics paper?
19:02:25 <andrewsw> But its Collatz sequences and some of them get really big before the get small again.
19:02:51 <pastorn> dons: no? is that about how you can get reflection?
19:03:13 <pastorn> like importing haskell in one of your modules?
19:04:23 <Cale> andrewsw: yeah, you probably want to have a cutoff for how much you memoise
19:04:36 <andrewsw> you got it exactly.
19:05:11 <andrewsw> but what I really need is to cast back to Int so I can get at my memoised results if I'm in that range. if that makes sense
19:06:03 <Cale> Well, all the numeric conversions you'll probably need are provided by fromIntegral
19:10:55 <andrewsw> yep. a little numeric conversion sure makes a big difference.
19:12:56 <roconnor> @haskell sparks
19:12:56 <lambdabot> Unknown command, try @list
19:12:59 <roconnor> er
19:13:03 <roconnor> @hackage sparks
19:13:03 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/sparks
19:13:15 <roconnor> :(
19:13:20 <roconnor> @hackage isn't very smart
19:13:21 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/isn't very smart
19:13:28 <Mortoc> haha
19:14:00 <sbahra> heh
19:16:02 <andrewsw> is it reasonable to assume that a stack overflow is caused by too much lazyiness?
19:16:32 <andrewsw> IOW, putting some strictness annotation in a few critical places could help with that?
19:16:34 <Cale> Stack overflows are caused by expressions which get too large before being evaluated.
19:16:39 <Cale> Yes, in many cases.
19:17:18 <Cale> See, the 'stack' doesn't mean what you might expect from imperative languages.
19:17:34 <andrewsw> do tell.
19:17:42 <Cale> The stack is used when searching an expression for a reducible subexpression.
19:18:04 <Cale> For example, let's look at:
19:18:09 <roconnor> I have ghc 6.8.2; do I have cabal-install or whatever it is?
19:18:09 <Cale> foldl (+) 0 [1,2,3]
19:18:17 <Cale> recall that:
19:18:25 <jeffz`> roconnor: think you need to upgrade cabal and cabal-install
19:18:27 <Cale> foldl f z [] = z
19:18:38 <andrewsw> I follow
19:18:38 <Cale> foldl f z (x:xs) = foldl f (f z x) xs
19:18:41 <dcoutts> roconnor: cabal-install is a separate package, it's not distributed with ghc
19:18:43 <Cale> So now:
19:18:49 <Cale> foldl (+) 0 [1,2,3]
19:18:54 <roconnor> bah, I'll just install sparklines by hand.
19:18:55 <Cale> -> foldl (+) (0 + 1) [2,3]
19:19:01 <jeffz`> hiya dcoutts
19:19:01 <Cale> -> foldl (+) ((0 + 1) + 2) [3]
19:19:08 <Cale> -> foldl (+) (((0 + 1) + 2) + 3) []
19:19:17 <dmwit> roconnor: No, cabal-install doesn't come with the 6.8 family.
19:19:19 <Cale> -> ((0 + 1) + 2) + 3
19:19:28 <dmwit> roconnor: But it's really easy to install, and it saves a lot of work...
19:19:30 <Cale> What just happened so far runs in constant stack.
19:19:31 <dmwit> ?hackage cabal-install
19:19:32 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
19:19:47 <roconnor> ok I'll give it a go
19:19:53 <andrewsw> Cale: I follow
19:20:04 <Cale> Because the reducible subexpression is always foldl, which is the outermost function (lazy evaluation evaluates outermost first)
19:20:17 <Cale> But now, the outermost reducible subexpression is the 0 + 1
19:20:33 <Cale> and that's nested a bit, so stuff will be put on the stack
19:20:34 * roconnor hopes cabal-install is as easy to install as a typical haskell program
19:20:40 <andrewsw> so all the rest of it ends up on the stack
19:20:40 <Cale> Which is why:
19:20:45 <Cale> > foldl (+) 0 [1..100000]
19:20:46 <lambdabot>   5000050000
19:20:49 <Cale> > foldl (+) 0 [1..1000000]
19:20:51 <lambdabot>   * Exception: stack overflow
19:20:51 <mmorrow> here're the worked out results of the flattening of the compositions of various common Monads: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=151#a151
19:21:08 <andrewsw> gotcha
19:21:19 <roconnor> :)
19:21:21 <dcoutts> hi jeffz`
19:21:22 <andrewsw> how does foldl' fit in the picture?
19:21:22 <roconnor> bootstrap.sh
19:21:25 <Cale> So we can avoid the stack overflow by forcing the evaluation of the 'z' parameter before recursing on each step, which is what foldl' does
19:21:33 <Cale> > foldl' (+) 0 [1..1000000]
19:21:34 <lambdabot>   500000500000
19:21:48 <mmorrow> next step: write TH functions to automatically derive flattened versions of arbitrary combinations of monads, along with the appropriate instances and helper functions :)
19:22:04 <mmorrow> R + W + S == RWS
19:22:09 <Cale> Still runs in constant stack while evaluating foldl', but there's nothing left to do at the end, because the additions happened during the loop.
19:22:18 <mmorrow> W + R + S == WRS /= RWS
19:22:20 <Cale> foldl' f z [] = z
19:22:37 <Cale> foldl' f z (x:xs) = let y = f z x in y `seq` foldl' f y xs
19:22:40 <jeffz`> hm, just noticing that parsec3 isn't a good drop-in replacement for parsec2, seems to have higher time and space cost, roughly 4x as much
19:22:55 <andrewsw> okay.
19:23:03 <andrewsw> That's helped me narrow it down a bit.
19:23:21 <andrewsw> interestingly, my stack overflow is happening in Data.Sequence.maximumBy
19:23:58 <mmorrow> probably your comparison function?
19:24:00 <Cale> mmm...
19:24:18 <Cale> It would be interesting if they managed to get that wrong.
19:24:19 <heatsink> mmorrow: Are monad transformer applications less efficient than pre-transformed monads?
19:24:27 <mmorrow> heatsink: much much
19:24:28 <heatsink> *manually transformed monads
19:24:50 <andrewsw> Cale: oh, I'm sure it's something I'm doing...
19:24:54 <Cale> ah, that's via Foldable
19:24:58 <heatsink> mmorrow: Am curious how so.
19:25:02 <andrewsw> yes, sorry
19:25:33 <mmorrow> heatsink: one sec, and i'll paste a convincing argument ;)
19:25:38 <Cale> oh, and very interesting, maximumBy uses foldr1, so it's a little unsurprising.
19:26:08 <Cale> You could just use foldl1' myMax
19:26:14 <andrewsw> maybe I write my own maximumBy using foldl'
19:26:28 <andrewsw> what is the "1"?
19:26:35 <Cale> er, is foldl1' missing?
19:26:39 <Cale> grr
19:26:45 <roconnor> ``cabal successfully installed in /home/roconnor/.cabal/bin.
19:26:55 <Cale> That would be the version which doesn't need an initial element (it steals it from the first element of the list)
19:26:57 <andrewsw> oh, sorry nevermind, I understand
19:26:59 <roconnor> shouldln't it be installed globally?
19:27:01 <andrewsw> yeah. d'oh
19:27:06 <roconnor> ... granted I'm the only user.
19:27:11 <Cale> Not so hard though
19:27:19 <Cale> pattern match your list as (x:xs)
19:27:32 <Cale> and use x as the initial value for foldl'
19:27:32 <dcoutts> roconnor: there's no particular advantage to installing globally
19:27:36 * roconnor reads more README
19:27:49 <andrewsw> right, I've seen some examples of that around
19:27:58 <roconnor> dcoutts: why is that?
19:28:06 <roconnor> will cabal install install every package locally?
19:28:35 <dcoutts> roconnor: by default, yes. You can tell it to install globally instead if you prefer.
19:28:36 <Cale> The right fold used for maximumBy is not bad in some cases (because it can evaluate lazily), but in a fairly large number won't be what you want.
19:28:49 <roconnor> dcoutts: how could I do that?
19:29:18 <dcoutts> roconnor: edit the ~/.cabal/config but then you'll have to invoke it with sudo or set the --root-cmd option to sudo
19:29:28 <andrewsw> I'm hitting a wall at a Data.Sequence with about 190,000 elements in it.
19:29:38 <dcoutts> roconnor: so why would you want it to install everything globally?
19:30:14 <Cale> That sounds about right for blowing up the stack.
19:30:31 <roconnor> dcoutts: so every user can run all these wonderful haskell programs
19:30:41 <dcoutts> roconnor: all one of you? :-)
19:30:52 <andrewsw> alright, Ive got to go. Thanks a lot Cale
19:30:55 <roconnor> dcoutts: and my guest account
19:31:19 <andrewsw> I"ll be back if that doesn't sort it (in the next couple of days... oh where does the time go)
19:31:25 <Cale> So yeah,  maximumBy' cmp (x:xs) = foldl' max' x xs  where max' x y = case cmp x y of GT -> x; _ -> y
19:31:27 <dcoutts> roconnor: each user can use cabal-install independently of course, but yes, sharing is about the only good reason I can think of for doing global installs.
19:31:45 <Cale> Should hopefully fix it up.
19:32:04 <MarcWeber> Which is the way to tell GLUT about a non standard freeglut location?
19:34:12 <andrewsw> Cale: yup, that did it... now looking for the new ceiling ;)
19:35:07 <andrewsw> oh awesome! that got me 10^6 and probably more.
19:35:40 <andrewsw> and all this work I've done learning how to memoise the results has saved me at least a minute of processor time! ;-P
19:35:45 <roconnor> I don't have a .cabal/config file to edit.
19:35:46 <Cale> ehehe
19:36:03 * andrewsw has been working on this in spare moments for about a week.
19:36:07 <andrewsw> Thanks again Cale!
19:36:12 <Cale> No problem :)
19:36:16 <andrewsw-afk> later
19:36:22 <Cale> yep :)
19:37:01 <dcoutts> roconnor: it's made automatically the first time you use cabal-install, eg try cabal list foobar
19:37:33 * roconnor does cabal update
19:37:33 <heatsink> mmorrow: are you writing it now?
19:39:59 <lispy> heatsink: hi
19:40:03 <mmorrow> heatsink: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=151#a152
19:40:06 <lispy> heatsink: I've been trying to catch you :)
19:40:20 <heatsink> lispy: I didn't do anything! It wasn't me!
19:40:21 <lispy> heatsink: you went to droundy's talk at the acm thing about a week ago?
19:40:23 <mmorrow> heatsink: heh, i went on a tangent for a sec ;)
19:40:37 <heatsink> oh! Yeah.
19:40:48 <lispy> heatsink: what did you learn?
19:40:52 <mmorrow> heatsink: anywho, the nested transformer version has to do a shitload of more stuff in its (>>=)/etc
19:41:04 <roconnor> how do I set up cabal install to work globally?
19:41:37 <dcoutts> roconnor: set user install to false in ~/.cabal/config if you want to do it by default, or if it's a one-off use --global
19:41:43 <dons> Cale, dcoutts http://www.spreadshirt.com/us/US/There-is-no-Cabal/Products-64/Marketplace/Products/detail/article/3612542
19:41:45 <lambdabot> Title: Men's Heavyweight Cotton T-Shirt There is no Cabal - Spreadshirt Marktplatz, http://tinyurl.com/53w2te
19:41:55 <dcoutts> dons: yay
19:42:15 * roconnor cabal install hsparklines
19:42:40 <Cale> Hooray, my art on a t-shirt :)
19:42:50 <dcoutts> dons: oh, that's haskell.org, so does that site let me make my own design? I want "There is no Cabal" on the back
19:43:02 <roconnor> dcoutts: I don't suppose there is a way to only install as root and not build as root?
19:43:03 <dons> yeah, hang on...
19:43:21 <roconnor> dcoutts++
19:43:32 <dcoutts> roconnor: yes, that's what the root-cmd: sudo is about
19:43:35 <dons> dcoutts: http://www.spreadshirt.com/us/US/Buy-t-shirt/Designs-63/Marketplace/Designs/detail/design/3197759
19:43:37 <lambdabot> Title: cabal (vector), cabal, haskell, - Spreadshirt Marktplatz, http://tinyurl.com/4cswds
19:43:45 <dons> you can create your own item with that logo on it
19:43:46 <ddarius> nymphaea is pretty too
19:43:56 <dons> "The classic star/box cabal logo, by Cale Gibbard" :)
19:44:09 <lispy> dude, that's classic
19:44:22 <dons> the hot item this winter.
19:44:26 <dcoutts> dons: :-)
19:44:44 <dons> nice, 'similar items ==> xmonad tshirt'
19:45:34 <lispy> You know the shirt that says, "Knuth is my home boy", can we have one like that but with system F or ghc or?
19:46:35 <dons> anyway, i've ordered a tshirt.
19:48:50 <roconnor> grr
19:48:52 <roconnor> GD.hsc:70:16: error: gd.h: No such file or directory
19:49:00 <roconnor> anyone know what this GD thing is?
19:49:17 <lispy> heatsink: I was just curious about what you thought of his talk.  I've looked over his slides but I already no the content, so I was wondering how it was for audiece members :)
19:49:20 <dons> yeah, big time image library, roconnor
19:49:24 <dons> look in your package system
19:49:38 <roconnor> dons: it's stupid hard to search for
19:50:02 <lispy> roconnor: for a sec there I thought GD was an abbreviated exclaimation involving a diety :)
19:50:27 <roconnor> dons: I have libgd2-xpm installed, but no gd.h file
19:50:50 <dons> gd2-xpm eh?
19:51:07 <roconnor> provides  libgd2
19:51:10 <dons> #define GD_VERSION_STRING "2.0.35"
19:54:58 <heatsink> lispy: The talk was actually halfway over when I found out about it, so I missed the patch theory stuff.  I think most of what I remember didn't come from the slides actually.  Patches get redundantly checked for commutability in some cases because it can't be propagated through the type system, and darcs was meant to improve on the patch idea of arch, indentation patches were one of the original motivations although he ha
19:54:58 <heatsink> sn't gotten around to them, Roundy spends much more time on scalability than he would have expected at the start.
19:55:15 <dino-> I'm tinkering with hscurses and am confused by a build problem.
19:55:30 <roconnor> oh
19:55:30 <dino-> I was able to build and install hscurses 1.3, I see it in ghc-pkg list output.
19:55:39 <dino-> But I can't build that example cm application.
19:55:41 <roconnor> gd.h is supposed to come with the haskell package?
19:55:50 <lispy> heatsink: interesting, so his slides didn't cover much of what he really talked about?
19:55:52 <dons> roconnor: no. it's in the gd C library
19:55:59 <dino-> I get a lot of this type of thing: ghc12854_0.hc:(.text+0xbae2): undefined reference to `wmove'
19:56:36 <dmwit> dino-: ghc --make
19:56:37 <dmwit> ?
19:56:51 <dino-> dmwit: Just did ./Setup build with it. It has a cm.cabal
19:56:55 <dino-> That's not the way to build it?
19:56:58 <roconnor> ah libgd2-xpm-dev
19:57:02 <dmwit> Oh, no, that's the thing to do.
19:57:29 <heatsink> lispy: When I arrived, he was describing an example bug that was caught with the type system.  I think it was the fourth from the last slide.
19:57:43 <dmwit> dino-: ...have you got the curses lib installed?
19:58:32 <dino-> dmwit: libncurses5, libncurses5-dev
19:58:42 <dmwit> huh
19:58:46 <dino-> (debian)
19:59:00 <lispy> heatsink: sounds like it was interesting.  Funny about the indentation patches.  I could have used those recently...
19:59:01 <heatsink> lispy: He talked about what was on the slides, but some of the interesting information was in the Q&A session.
19:59:30 <dino-> Would the hscurses lib itself build without those?
19:59:53 <dino-> (just curious)
20:00:34 <dmwit> Probably not.
20:00:37 <roconnor> dcoutts: I have symlink-bindir: /home/roconnor/bin/
20:00:38 <dmwit> But stranger things have happened.
20:00:58 <roconnor> dcoutts: but I still get: cabal: Unable to find cabal executable at: /home/roconnor/.cabal/bin/cabal
20:01:05 <dmwit> It would be odd indeed to be in a situation where you had the headers for a library, but not the library itself.
20:01:10 <roconnor> cabal: Error: some packages failed to install:
20:01:11 <roconnor> dataenc-0.11.1 failed during the final install step. The exception was:
20:01:11 <roconnor> exit: ExitFailure 1
20:01:38 <lispy> Does anyone else experience this: As you get stressed and burdened with real-life demands you want to retreat into fun Hobby-style programming projects?
20:01:50 <dcoutts> roconnor: hmm, and presumably it does exist there?
20:01:53 <dmwit> lispy: of course
20:01:59 <bos> lispy: absolutely
20:02:03 <roconnor> dcoutts: nope, the README said to move it
20:02:05 <dmwit> lispy: ...which only makes it worse. =/
20:02:06 <dino-> dmwit: Thank you.
20:02:13 <heatsink> lispy: Sometimes, but not inevitably.
20:02:16 <lispy> dmwit: exactly :)
20:02:19 <dmwit> dino-: Yeah, sorry I don't know how to fix it.
20:02:24 <dcoutts> roconnor: oh, but the symlink in ~/bin/ still points to it?
20:02:38 <dino-> dmwit: But good to confirm that I didn't do anything obviously silly at this stage.
20:02:38 <lispy> I found myself just now thinking about how to rewrite nethack or angband in Haskell :)
20:02:44 <heatsink> Raskell.
20:02:46 <roconnor> dcoutts: no I moved it to ~/bin
20:02:52 <roconnor> dcoutts: like the readme said
20:03:13 <roconnor>  * move the `cabal` program elsewhere and edit the `$HOME/.cabal/config` file
20:03:13 <roconnor>    and set the `symlink-bindir` entry to point to an alternative location where
20:03:13 <roconnor>    that is on your `$PATH`, eg a `$HOME/bin` directory.
20:03:35 <lispy> heatsink: heh, nice
20:03:44 <heatsink> A roguelike library for Haskell would be fun.
20:03:47 <dblazakis> lispy: i fully support that
20:04:06 <lispy> dblazakis: heeh, don't encourage me :)
20:04:31 <dcoutts> roconnor: ohh, the cabal executable knows where it was configured to be installed, so looks for itslef there when doing the sudo install part
20:05:08 <roconnor> dcoutts: so it's a bug?
20:05:19 <dcoutts> roconnor: well depends on your point of view
20:05:27 <dcoutts> roconnor: perhaps the bug is in the README :-)
20:05:45 <roconnor> I can accept a bug in the readme
20:05:46 <bos> dcoutts: cabal doesn't install haddocks?
20:05:48 <roconnor> I'll make a hardlink
20:05:53 <dino-> lispy: speak of the curses devil
20:06:13 <lispy> dino-: maybe that's what triggered me to think about it :)
20:06:19 <dcoutts> bos: not by default, you have to --enable-documentation or set the equivalent in the ~/.cabal/config
20:06:41 <heatsink> lispy: There's an incomplete roguelike called `Xenocide' with a really nice mood and some interesting additions, which I'd love to revive.
20:06:44 <dcoutts> roconnor: on unix it's not easy for programs to find their own executable files
20:06:53 <heatsink> lispy: Unfortunately it's written in C++ and Polish.
20:06:58 <dino-> That makes me happy, being able to set it in .cabal config for everything
20:07:00 <bos> dcoutts: i don't see a --enable-documentation option
20:07:04 <roconnor> dcoutts: isn't it arg 0?
20:07:09 <lispy> heatsink: I don't know Polish, but I know C++...
20:07:24 <dcoutts> roconnor: arg 0 would often be "cabal" not a full path
20:07:29 <roconnor> dcoutts: why doesn't it read the location I said in the config file?
20:07:46 <dcoutts> roconnor: why would it's location be given in the config file?
20:07:58 <dcoutts> which one would tell it that?
20:07:58 <dino-> roconnor, dcoutts: And then there's if it was run from a symlink weirdness, yes?
20:08:03 <roconnor> symlink-bindir: /home/roconnor/bin/
20:08:07 <roconnor> I wrote that
20:08:08 <bos> dcoutts: oh, i meant Cabal, not the cabal command. as in "runghc Setup copy"
20:08:14 <roconnor> what more does it want?
20:08:34 <dcoutts> bos: runghc Setup haddock && runghc Setup copy
20:08:37 <roconnor> no sure why it is call symlink-bindir
20:08:37 <dino-> I've used this: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/FindBin
20:08:38 <heatsink> lispy: I know C++ too, but it's like having random character strings for variable and function names.
20:08:43 <lambdabot> Title: HackageDB: FindBin-0.0.1, http://tinyurl.com/5yozt8
20:08:49 <roconnor> since symlinks aren't involved
20:08:52 <bos> dcoutts: only installs the .haddock file
20:08:57 <dcoutts> roconnor: yes they are, that's the point.
20:09:42 <dcoutts> bos: then something went wrong, that's been the standard procedure since forever. did it generate the html files?
20:09:49 <bos> dcoutts: yep
20:10:13 <heatsink> lispy: Looks like it's been updated after a few years of stagnation. http://xeno.chaosforge.org/
20:10:17 <dcoutts> bos: does this only happen for some specific package or for some specific Cabal lib version?
20:10:29 <roconnor> dcoutts: that's not what the README says
20:10:38 <roconnor> it said to move the files
20:10:44 <bos> dcoutts: zlib 0.4.0.4, Cabal 1.5.5, ghc 6.10 RC 1
20:11:13 <lispy> heatsink: I think learning about the algos for generating maps and whatnot would be interesting
20:11:19 <dcoutts> bos: and haddock 2.2 I presume. I'll try to reproduce it.
20:11:28 <bos> dcoutts: right.
20:12:02 <lispy> heatsink: seems to be pretty simple actually: http://en.wikipedia.org/wiki/Maze_generation_algorithm
20:12:04 <lambdabot> Title: Maze generation algorithm - Wikipedia, the free encyclopedia
20:12:07 <rdmltrs9> hi does anyone have a good book recommendation for learning about monadic transformers?
20:12:22 <dcoutts> roconnor: the README doesn't says to set the symlink-bindir, it doesn't describe the difference between the bindir and the symlink-bindir
20:12:28 <heatsink> lispy: Line-of-sight visibility would also be interesting to implement.
20:12:36 <dcoutts> roconnor: erm, rather the README just says to set the symlink-bindir
20:13:49 <lispy> heatsink: any other interesting talks at the ACM event?
20:13:53 <roconnor>  * move the `cabal` program elsewhere and edit the `$HOME/.cabal/config` file
20:13:53 <roconnor>    and set the `symlink-bindir` entry to point to an alternative location where
20:13:53 <roconnor>    that is on your `$PATH`, eg a `$HOME/bin` directory.
20:14:04 <roconnor> dcoutts: am I misreading this?
20:14:22 <dcoutts> roconnor: I've lost track about what we were confused about
20:14:50 <roconnor> dcoutts: the README says to move the file but says nothing about making a symlink
20:15:04 <dcoutts> roconnor: right, there's no need to make any symlink
20:15:07 <roconnor> it then says to set the `symlink-bindir` entry, even though no symlink was made
20:15:16 <dcoutts> yes
20:15:36 <lispy> heatsink: oh, in fact, since a lot of the maze generators work by construting a minimum spanning tree, I bet Haskell has nice tools (may FGL would be good) for making elaborate mazes elegantly
20:15:40 <bos> @seen juhp
20:15:41 <lambdabot> juhp is in #haskell. I last heard juhp speak 4h 15m 18s ago.
20:15:55 <heatsink> lispy: There were other good talks, but I completely forgot about the event.
20:15:55 <roconnor> so why doesn't cabal use the `symlink-bindir` entry to find the cabal file?
20:16:09 <roconnor> since that is where I told it that it was.
20:16:19 <dcoutts> roconnor: ah that's the confusion
20:16:25 <roconnor> :)
20:16:33 <dcoutts> roconnor: the symlink-bindir is to tell cabal where to put other executables
20:16:40 <dcoutts> not where it should find itself
20:16:46 <roconnor> oh
20:16:53 <dcoutts> it just happens that you probably want those to be the same place
20:16:57 <roconnor> :^)
20:17:06 <dcoutts> eg where does 'alex' end up when you cabal install alex
20:17:21 <dcoutts> well it ends up in the bindir, and a symlink to it is added to the symlink-bindir
20:20:22 <dino-> Oh yeah, baby. Had to add to cm.cabal: extra-libraries: ncurses
20:20:28 <dino-> And BAM, it linked.
20:21:19 <dino-> Is that likely to be pretty much required to anybody? I could submit a patch against hscurses for this.
20:21:26 <dino-> s/to/for/
20:22:06 <roconnor> dcoutts: will --global still install in the symlink-bindir?
20:22:23 <dcoutts> roconnor: hmm, not sure. Probably will yes.
20:22:54 <dcoutts> roconnor: that could be classified as a bug. Perhaps the symlink-bindir should be per-set of settings user/global
20:23:01 <heatsink> lispy: Not sure how to use a maze algorithm in a roguelike.  I think you'd want a collection of room-drawing primitives that can be combined to produce different effects.
20:23:04 <dcoutts> roconnor: feel free to file a bug
20:23:53 <dcoutts> bos: works for me with haddock-0.x, trying with 2.x
20:24:15 <bos> hmm
20:24:34 <lispy> heatsink: the algorithms seem to focus on spanning trees.  The rooms are the vertices in the graph and you can add extra edges once your done to put in loops and stuff.  Then when you actually render the graph to a maze, you can associate non-trival rooms with the verticies :)
20:25:14 <lispy> heh, xmobar
20:25:20 <lispy> interesting name
20:25:39 <heatsink> lispy: So that's how you get nethack's rooms-connected-by-cooridoors?
20:27:21 <lispy> heatsink: I can't be certain that's how nethack/angband do it, but it sure sounds like a fit
20:27:48 <lispy> heatsink: BTW, I've only played nethack twice but I've played angband for years...so I could be wrong about details of nethack
20:29:18 <dcoutts> bos: works fine
20:29:36 <bos> dcoutts: how weird.
20:30:05 <bos> dcoutts: i get the docs built fine, but only the .haddock file installed.
20:30:05 <dcoutts> bos: so you find it copies just the one file?
20:30:12 <bos> yes.
20:30:21 <dcoutts> bos: and copy -v reports it only installs the one doc file too?
20:30:21 <juhp> bos: still here :)
20:30:25 <bos> i'm passing a --haddockdir that is different from --docdir
20:30:29 <bos> let me run with 0-v
20:30:43 <heatsink> lispy: One of the things I liked about Xenocide is that dungeon shapes change dramatically as you move from one level to the next.  The shuttle has irregular-shaped rooms with walls, but no cooridoors; the laboratory has small square rooms and straight hallways; caves have irregular shaped rooms and winding hallways.
20:30:57 <dcoutts> bos: ah, we probably havn't tested making those different very often, could be related
20:31:51 <dblazakis> heatsink: kind of like the gnomish mines in nethack/slashem?  large irregular room
20:31:52 <lispy> heatsink: the way I'm thinking of it now, all that should be pretty easy to specify in the "rendering" part where you transform from an abstract graph to a concrete maze
20:32:11 <bos> dcoutts: hmm
20:32:45 <lispy> heatsink: But, I think the algos on wikipedia assume that the "rendering" is happening during maze creation
20:33:30 <bos> dcoutts: that's the bug.
20:33:43 <dcoutts> bos: got the details?
20:33:58 <bos> it copies the html docs to $docdir, and just the .haddock file to --haddockdir
20:34:11 * heatsink moves to #haskell-blah
20:34:22 <bos> dcoutts: i entirely missed --htmldir
20:34:43 <dcoutts> bos: right, so the problem is an unexpected UI
20:35:10 <dcoutts> bos: is there anything you think we could do about that? eg user guide or something?
20:35:15 <dcoutts> or --help message?
20:35:25 <bos> it's in --help
20:35:31 <bos> ot
20:35:34 <bos> urk
20:35:43 <bos> it's just that --help output is long and intricate.
20:35:53 <dcoutts> too configurable :-)
20:36:01 <dcoutts> I should split it into sections
20:36:06 <dcoutts> the --help outout
20:36:11 <dcoutts> output
20:36:12 <bos> that might help
20:36:32 <bos> ok, with --htmldir, we are teh happiez
20:36:53 <dcoutts> good good :-)
20:37:18 <dcoutts> bos: could you file a ticket for more readable --help output, split into sections
20:39:07 <bos> dcoutts: will do
20:39:14 <dcoutts> ta muchly
20:46:17 <roconnor> Loading package gd-3000.4.0 ... can't load .so/.DLL for: pthread (/usr/lib/libpthread.so: invalid ELF header)
20:46:28 <roconnor> I don't know whethet to blame gd or cabal
20:46:33 <roconnor> whether
20:46:58 <roconnor> stupid binding for crap
20:47:05 <roconnor> people should just write pure haskell
20:47:06 <dcoutts> roconnor: I bet it's a ld linker script, try file /usr/lib/libpthread.so
20:47:42 <roconnor> $ file /usr/lib/libpthread.so
20:47:42 <roconnor> /usr/lib/libpthread.so: ASCII C program text
20:47:50 <dcoutts> roconnor: right, not an ELF binary
20:48:03 <roconnor> /* GNU ld script
20:48:03 <roconnor>    Use the shared library, but some functions are only in
20:48:03 <roconnor>    the static library, so try that secondarily.  */
20:48:03 <roconnor> OUTPUT_FORMAT(elf32-i386)
20:48:03 <roconnor> GROUP ( /lib/libpthread.so.0 /usr/lib/libpthread_nonshared.a )
20:48:04 <roconnor> /usr/lib/libpthread.so (END)
20:48:07 <dcoutts> file is misinterpreting it as C source code
20:48:24 <dcoutts> roconnor: and that cannot be loaded with dlopen
20:48:31 <dcoutts> which is what ghci tries to do
20:48:36 <crutcher> I just learned about how expensive x^2 is compared to x^(2::Int)
20:48:57 <roconnor> dcoutts: I don't know what you are talking about, but it sounds like linux is pretty sucky
20:49:01 <crutcher> That seems to be something we could teach the compiler about. Does anyone know much about pragmas?
20:49:05 <dcoutts> roconnor: there's a ghc ticket open on the issue, it's not that easy to solve though there are probably some hacks we could add to work around it
20:49:26 <dcoutts> roconnor: it works with the native linker because it looks at that when it does the initial link
20:49:50 <roconnor> craptastic
20:50:47 <dcoutts> roconnor: you could report it as a Cabal ticket, we could introduce a hack to workaround it
20:51:14 <dcoutts> eg just filtering out -lpthread on linux systems for the ghci libs
20:51:15 <roconnor> what does cabal have to do with it?
20:51:25 <dcoutts> roconnor: it's probably the best place to add a workaround
20:51:51 <dcoutts> roconnor: or we'll decide it isn't and reassign it to ghc or just throw our hand up in exasperation :-)
20:52:15 <roconnor> I don't see how Cabal is involved
20:52:26 <roconnor> who made this /usr/lib/libpthread.so ?
20:52:34 <roconnor> ubuntu right?
20:52:44 <roconnor> and ghci is trying to misload it
20:52:51 <roconnor> so I don't see where cabal fits in.
20:53:02 <roconnor> oh
20:53:12 <roconnor> unless you build gd so that it doesn't use this
20:53:22 <dcoutts> roconnor: we can notice that a package is adding pthread as an extra-libraries thing and just hack it on linux systems not to do that
20:53:41 <roconnor> stupid bindings for crap
20:53:46 <roconnor> people should just write pure haskell
20:53:55 <dcoutts> roconnor: we can all agree on that one :-)
20:54:04 <solrize> @t ixmap
20:54:04 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
20:54:10 <solrize> :t ixmap
20:54:11 <lambdabot> forall i j e. (Ix j, Ix i) => (i, i) -> (i -> j) -> Array j e -> Array i e
20:56:58 <crutcher> Is anyone interested in talking about x^2 vs x^(2::Int) ?
20:57:52 <byorgey> crutcher: without any further constraints, the 2 in x^2 is probably defaulting to type Integer
20:58:01 <byorgey> but I don't see why those should behave any differently
20:58:17 <byorgey> have you noticed a difference?
20:58:18 <crutcher> yes, it is. It would be nice if it didn't, because that's an expensive default.
20:58:23 <crutcher> yes, 3x speed hit
20:58:41 <byorgey> you can change the defaulting.
20:58:54 <sjanssen> crutcher: is there still a cost when compiled with -O2?
20:59:03 <sjanssen> crutcher: is the "2" a literal constant?
20:59:03 <crutcher> yes.
20:59:06 <crutcher> yes.
20:59:08 <crutcher> to both.
20:59:14 <sjanssen> hmm, maybe there could be a rule for that
20:59:19 <byorgey> I don't exactly remember how off the top of my head, something like "default (Int,Integer,Double)"
20:59:43 <crutcher> that's what I'm interested in, but I don't know how to do that. I want to be able to dig into this and help, but I've never done any ghc stuff yet.
20:59:51 <crutcher> where should I look?
21:00:03 <sjanssen> crutcher: look up RULES pragmas in the GHC manual
21:00:29 <rwbarton> crutcher: A good place to start is to look at the core to see what's really happening: pass -ddump-simpl
21:00:30 <Cale> byorgey has it.
21:00:46 <Cale> You can change the defaulting rules.
21:01:22 <Cale> (If you'd prefer Int)
21:01:35 <byorgey> crutcher: also, if you care that much about performance, it's probably better to say x*x than x^2
21:01:41 <byorgey> although maybe the 2 was just an example
21:01:42 <Cale> However, in most cases, Int is a correctness-damaging premature optimisation.
21:02:45 <crutcher> byorgey: yes, x*x is better. But wouldn't it be nice to teach ghc about it?
21:02:47 <lispy> Cale: everytime you say that god kills a C programmer
21:03:27 <byorgey> crutcher: sure, that's a different question: that can be done with a RULES pragma, as sjanssen suggested.
21:03:27 <dons> ?remember Cale Int is a correctness-damaging premature optimisation
21:03:28 <lambdabot> Nice!
21:04:07 <sjanssen> dons: I can't remember, can RULES fire on class overloaded things?
21:04:07 <byorgey> crutcher: you can specify transformations which should be applied prior to compilation.
21:04:11 <lispy> that quote should come with a link to the google blog where they discuss the bug they found in a java function that made assumptions about ints being arbitrarily sized
21:04:15 <dons> sjanssen: yeah, if you're careful
21:04:24 <sjanssen> eg. {-# RULES "square" forall x. x ^ (2 :: Integer) = x * x #-}
21:04:24 <dons> fromIntegral/truncate et al are all rules-ified
21:04:29 <dons> yeah 'sok.
21:04:39 <sjanssen> I wonder why it isn't matching
21:05:39 <sjanssen> maybe SPEC is firing before my rule has a chance to fire?
21:06:28 <bos> maybe you need RULES[0] or RULES[1]
21:06:44 <bos> all that stuff is fragile magic.
21:07:06 <crutcher> Well, fixing it just for x^2 isn't really the point.
21:07:15 <crutcher> I mean, yes x^2 == x*x is nice.
21:07:19 <sjanssen> crutcher: I'm trying to find a starting point
21:07:26 <dons> (^) probably inlined.
21:08:12 <rwbarton> (^) isn't inline in the trivial examples I'm looking at.  But maybe that's because it's basically the entire function I'm defining?
21:08:15 <crutcher> but we want a rule which goes from x^y, where y is an integral constant less than maxInt, and generates x^(y::Int)
21:08:23 <crutcher> and I'm not sure if we can say taht with the rules.
21:08:29 <bos> welcome to haskell's confusing world of exponentiation. how many operators would you like today?
21:08:31 <dons> mm
21:09:05 <crutcher> I want to conditionally change the default type for the constant, based on the constant's value.
21:09:24 <bos> that's kind of scary.
21:09:27 <crutcher> It's _always_ faster if we do that, but can we express it?
21:09:40 <dons> mm
21:09:57 <bos> i think that would require plumbing in the compiler itself.
21:10:08 <sjanssen> {-# RULES "square" forall (x :: Integer) (n :: Int#). x ^ (S# n) = x ^ (I# n) #-}
21:10:15 <sjanssen> seems to me that should work but it isn't
21:11:14 <dons> lots of dictionaries in the way, sjanssen
21:11:20 <sjanssen> oh (^) is specialized to Integer -> Integer -> Integer
21:11:27 <sjanssen> dons: but I've made all types explicit
21:11:28 <dons> yea, SPEC is firing
21:11:30 <dons> oh
21:11:41 <sjanssen> {-# SPECIALISE (^) :: Integer -> Integer -> Integer,
21:11:59 <sjanssen> will that prevent rules from firing?
21:12:38 <crutcher> Is there any way to give a hint to a constant's type?
21:12:48 <dmwit> crutcher: ::
21:12:53 <sjanssen> crutcher: (2 :: Int)
21:13:13 <crutcher> that's not a hint.
21:13:24 <crutcher> that's explicitly typing the constant
21:13:25 <dmwit> What do you mean, then?
21:14:08 <crutcher> I mean: foo :: Integral a => a (prefer Int) or something
21:14:18 <dons> sjanssen: is it already doing the transformation?
21:14:23 <dons>  i'm seeing GHC.Num.* @ GHC.Types.Int GHC.Num.$ in the core.
21:14:31 <dmwit> crutcher: Yes, you can set the defaulting.
21:14:37 <crutcher> where, how?
21:14:39 <dmwit> Have a look online to find out how.
21:14:43 <dmwit> (I don't know the specifics.)
21:14:49 <dmwit> But you have a keyword to search for now. =)
21:14:53 <dons> ah, got it to fire
21:15:01 <dons> 2 RuleFired 1 SPEC GHC.Real.^ 1 square
21:15:24 <sjanssen> dons: same rule?
21:15:39 <dons> gimme a sec. something weird.
21:15:45 <dons> ah no
21:17:04 <dons> http://hpaste.org/11161
21:17:05 <sjanssen> crutcher: default(Int, Double)
21:17:21 <dons> now work backwards from there to get it to fire for less obvious things
21:17:47 <sjanssen> Int -> Integer -> Integer is the important type
21:19:36 <sjanssen> does "^2" mean the second specialized version of ^?
21:22:10 <crutcher> I think so
21:22:45 <crutcher> I'm looking at the docs on default(), it I'm a bit lost. Can we use it on a single function? What would it look like?
21:23:07 <sjanssen> crutcher: it works only in a module context, not on a function
21:23:35 <crutcher> So, we'd have to declare a module just for (^)?
21:23:43 <sjanssen> that wouldn't work either
21:24:07 <sjanssen> it works in the module where the concrete type is chosen (ie. your module)
21:24:22 <dmwit> crutcher: What is this all about, anyway?
21:24:30 <dmwit> (Why do you need this feature?)
21:25:11 <crutcher> I don't need this feature. I just noticed that this is always faster, and I wanted to understand how this feature would be added, if it was possible.
21:26:07 <crutcher> i was screwing arround with a prime sieve working some programming problems, and noticing this took away most of my time cost.
21:26:50 <crutcher> and I want to train myself up to be a ghc hacker, because that's what I want to do for my next degree, so I figgured I'd at least ask about it.
21:27:32 <dmwit> Okay.  Defaulting is the preferred method for module-level stuff; explicit type annotations is the preferred method for single functions.
21:27:53 <dmwit> You could certainly propose a better syntax... bonus points if you hack it into GHC. =)
21:28:19 <crutcher> Is defaulting value safe? If I use a constant that's larger than the platform's maxInt, what happens to the defaulting?
21:28:27 <sjanssen> crutcher: overflow
21:28:32 <sjanssen> > 999999999999999999999999999999 :: Int
21:28:34 <lambdabot>   5076944270305263615
21:29:01 <sjanssen> so I think the problem is the specialize pragma on (^)
21:29:19 <dmwit> crutcher: Defaulting to Int is not safe, no.
21:29:26 <crutcher> would you re-order it?
21:29:37 <dmwit> If you thought you were going to be using large values, you would have to explicitly switch back to Integer for any polymorphic computations.
21:29:38 <rwbarton> Can you just write a specialized version of (^) for a -> Integer -> a that calls the version for Int on S# input?  Surely that wouldn't be too slow?
21:29:47 <sjanssen> is there a way to name a specialized function in a rule?
21:30:00 <sjanssen> rwbarton: that is what my rule attempts to do
21:30:13 <crutcher> is S# constant input?
21:30:20 <dmwit> S# is small values
21:30:24 <dmwit> rather
21:30:27 <dmwit> S# wraps small values
21:30:44 <sjanssen> crutcher: x ^ 2 is actually (x ^ S# 2#) (given the usual default settings)
21:30:52 <rwbarton> sjanssen: Well, your rule applies when it's known at compile time that the argument is an S#, right?
21:31:26 <sjanssen> rwbarton: correct
21:31:33 <crutcher> sjanssen: x^2 is 3x slower than x^(2::Int)
21:31:43 <rwbarton> crutcher: can you hpaste that benchmark?
21:31:52 <sjanssen> and GHC definitely knows it is S# 2# in this case
21:31:57 <sjanssen> (checked with ghc-core)
21:32:11 <rwbarton> sjanssen: I was proposing  x ^ (S# n#) = x ^ (I# n#); x ^ y = x `regularExp` y
21:32:22 <sjanssen> crutcher: x^(2::Int) is actually x^(I# 2#)
21:32:29 <dmwit> crutcher: I dare you to look at the Core generated for the code "main = print $ even 2". =P
21:32:30 <sjanssen> rwbarton: we can't do that without access to GHC's source
21:32:36 <rwbarton> as a regular function definition that somehow applies only to Integer
21:32:41 <sjanssen> rather, base's source
21:32:46 <rwbarton> base, sure.
21:32:58 <sjanssen> rwbarton: but that optimization would also be useful
21:33:11 <sjanssen> and hopefully spec-constr could even optimize that indirection away
21:34:05 <crutcher> rwbarton: I'd have to write it again, did this a work today. I'm not down with internal timers yet, so I was doing main = print $ sum $ map (x^2) [1..100000]
21:34:10 <adu> dmwit: a 'simple compile' as turned into a very long GHC building experiment
21:34:22 <dmwit> mmm
21:34:33 <adu> dmwit: it took me awhile to figure out that I needed to run 'alex' and 'happy' on those files...
21:34:38 <dmwit> Welcome to the wonderful world of building the unstable version of GHC...
21:35:09 <adu> dmwit: o no don't get me wrong, it built fine, but my syntax didn't work because i didn't do alex/hapy :)
21:35:12 <crutcher> atually, use a bigger array
21:35:24 <sjanssen> yep, I've confirmed that SPECIALIZE is the problem
21:35:27 <dmwit> ah, heh
21:37:00 <rwbarton> Can I tell ghc to inline (^) with a directive at the use of (^)?
21:37:03 <crutcher> hmm. Well, I did this at work, with GHC 6.4, but I've got 6.8 here. The difference seems more like 25% with 6.8
21:37:27 <rwbarton> OK, that's a lot easier to understand
21:37:32 <sjanssen> crutcher: oh, 6.4 can make a *huge* difference
21:37:48 <sjanssen> don't even bother benchmarking anything less than 6.8
21:37:57 <crutcher> but it is still a net win with 6.8
21:38:03 <sjanssen> right
21:38:11 <crutcher> sjanssen: thanks, I'll remember that
21:38:43 <crutcher> sjanssen: can you tell me _how_ SPECIALIZE is the problem?
21:38:49 <crutcher> is it teh order?
21:38:49 <sjanssen> http://hpaste.org/11162
21:39:12 <sjanssen> crutcher: nah, it's that (^) is immediately re-written to a special value that we don't have a name for
21:39:19 <sjanssen> and it doesn't give a chance for the RULE to match
21:39:47 <crutcher> oh.
21:39:55 <crutcher> is there a way arround that?
21:40:18 <sjanssen> changing the source of the base library is the only way I know how to do that
21:40:28 <sjanssen> but that will probably make other uses of (^) slower
21:41:20 <crutcher> are the rules processed in order?
21:41:36 <crutcher> ycould you put the pragma before the SPECIALIZE?
21:41:39 <sjanssen> in a mostly random order
21:41:51 <sjanssen> I'm not exactly sure when SPECIALIZE happens
21:41:57 <sjanssen> maybe we could stick some phase control on it
21:44:09 <sjanssen> apparently SPECIALIZE generates a rule
21:44:24 <rwbarton> How can I find out what, say, GHC.Real.$wf mean in core?
21:45:29 <sbahra> @kick rwbarton
21:45:29 <lambdabot> Maybe you meant: dice dict kind
21:45:35 <sbahra> No. I didn't.
21:46:13 <bos> dons, dcoutts: is there a place i can snarf prereleases of the haskell platform?
21:47:05 <dons> http://code.haskell.org/haskell-platform/ but activity is focusing on ghc atm.
21:47:06 <lambdabot> Title: Index of /haskell-platform
21:47:27 <dons> there's a wiki page, tickets, and some scripts for creating .tar.gz bundles of what's listed in that .cabal file
21:48:15 <adu> how do you run the ghc cpp on something thats not haskell?
21:48:32 <crutcher> sjanssen: thanks. I think I need a bit more background before I dig deeper in this.
21:48:48 <sjanssen> "SPEC Exp.^" ALWAYS
21:48:48 <sjanssen>     forall {}
21:48:48 <sjanssen>       Exp.^ @ GHC.Num.Integer @ GHC.Base.Int GHC.Num.$f3 GHC.Real.$f10
21:48:48 <sjanssen>       = Exp.^2
21:49:01 <sjanssen> is there a way to make that ALWAYS a SOMETIMES? :P
21:49:28 <bos> dons: thanks
21:52:46 <crutcher> I'm out. Thanks again.
21:57:14 <solrize> sequence.complete.org down since yesterday?
22:11:37 <sjanssen> if anyone is curious, this is what I finally came up with http://hpaste.org/11162#a3
22:12:09 <dons> noice.
22:12:33 <sjanssen> dons: anything there look suspicious?
22:12:43 <rwbarton> I'm surprised that in the  print $ sum $ map (^(2::Int)) [1..10000000]  test, (^(2::Int)) is only a few percent slower than (\x -> x*x)
22:14:09 <dons> pity that doesn't fuse. you should try the stream-fusion package
22:14:35 <rwbarton> I also wrote it as an explicit loop and that didn't make it significantly faster
22:14:37 <adu> sjanssen: so all you're doing is the reduction of powers by squares?
22:14:45 <rwbarton> Maybe I was doing something wrong... let me try again
22:14:53 <sjanssen> adu: that source is copied from GHC
22:15:06 <sjanssen> adu: the tricky stuff is the RULES and SPECIALIZE stuff
22:15:19 <adu> oh ok, fancy fuzion
22:15:33 <sjanssen> rwbarton: map . enumFromTo x y -- should fuse
22:15:34 <rwbarton> the explicit loop is about 10% faster
22:15:37 <sjanssen> adu: no, not fusion
22:15:50 <rwbarton> sjanssen: OK, that seems consistent with what I'm seeing
22:15:57 <sjanssen> so the 10% speed up probably comes because sum won't fuse
22:16:00 <dons> http://hpaste.org/11163
22:16:12 <dons> sum won't fuse, that's right. try uvector
22:16:36 <rwbarton> If I do computations on Ints rather than Integers, it becomes 97% faster :P
22:16:43 <dons> it's nice the manual recursion that is yielded.
22:16:45 <dons> go fusion!
22:17:10 <dons> $wf ww1_s15G 2  looks suspicious
22:17:51 <sjanssen> dons: over here $wf is the specialized version of f that works on Int#
22:17:53 <BMeph> shoot-out hacking again? ;)
22:17:55 <rwbarton> How come my core output has all this extra junk compared to that?
22:18:18 <dons> http://hpaste.org/11163#a1
22:18:20 <dons> much better.
22:18:32 <dons> rwbarton: no fusion in your trunk?
22:19:07 <dons> 15x faster using square x  = x * x :)
22:19:15 <rwbarton> No, I'm talking about $wf vs. GHC.Real.$wf and "case @ Int#" and so on
22:19:29 <dons> mm.
22:19:45 <sjanssen> dons: I'm working on RULES for that :)
22:20:01 <dons> so the last one is the one to match, i think, http://hpaste.org/11163#a1
22:20:16 <dons> i need to get the kids using streamable lists more often. mm. a new release perhaps
22:22:36 <rwbarton> I guess in this case the only difference between dons' core output is mine is that mine has all the symbol names qualified
22:22:46 <rwbarton> Is that an option, or a compiler version difference, or what?
22:22:50 <sjanssen> dons: http://hpaste.org/11162#a4
22:22:57 <sjanssen> dons: think I should make a GHC patch?
22:23:31 <dons> rwbarton: ah ha
22:23:34 <dons> i'm using 'ghc-core'
22:23:39 <dons> which cleans up the output and pretty prints it
22:23:46 <dons> i thoroughly recommend it
22:24:13 <dons> sjanssen: i'd open a ticket. perhaps add some QCs
22:24:15 <rwbarton> dons: Oh, OK.  Yeah, I've already installed that, just hadn't used it enough yet to notice that difference (and I forget about it sometimes)
22:24:20 <dons> looks good to me, sjanssen
22:24:33 <dons> the multiple phasing looks a little fragile
22:24:58 <sjanssen> yeah
22:26:56 <dolio> sjanssen: You're not going to suggest the "Integer exp" rule, are you?
22:27:42 <sjanssen> dolio: why not?
22:27:52 <adu> sjanssen: how about "^/pow"
22:28:06 <sjanssen> yes, I'll just a different name
22:28:13 <dolio> Because why use a RULE for that when you could just put it in the instance declaration for Integer?
22:28:14 <sjanssen> dolio: but is the RULE wrong in some other way?
22:28:29 <rwbarton> dolio: (^) is not an instance method
22:28:32 <sjanssen> (^) is not a class method
22:28:38 <rwbarton> er, that :)
22:28:45 <dolio> Oh, bah.
22:29:39 <noZone> The sun never sets on #haskell.
22:30:04 <dolio> Still not a fan, but I guess there's not much that can be done.
22:30:13 <sjanssen> dolio: that would be the ideal solution, but we can't break compat with Haskell '98
22:30:20 <dolio> Yeah.
22:30:42 <pumpkin-> how is the @src thing working with lambdabot?
22:33:02 <adu> whats the diff between HsExpr and LHsExpr?
22:35:34 <rwbarton> Hmm, isn't there some code that makes the inliner loop?  Maybe that behavior could be abused to create a version of (^) that inlines all of the recursion...
22:37:30 <dons> well, you can write rules that loop
22:37:36 <dons> RULES f = f
22:37:49 <dancor> > unzip (map decons ["hi", "bye", "lol"]) where decons (x:xs) = (x, xs)
22:37:51 <lambdabot>   ("hbl",["i","ye","ol"])
22:38:00 <dancor> is there a func to get (heads, tails) already
22:40:11 <dmwit> > (map head &&& map tail) ["hi", "bye", "lol"]
22:40:12 <lambdabot>   ("hbl",["i","ye","ol"])
22:40:24 <dancor> sikh
22:40:32 <inimino> hm
22:40:45 <dancor> but that's 2N right
22:40:51 <dmwit> > unzip . map (splitAt 1) $ ["hi", "bye", "lol"]
22:40:52 <lambdabot>   (["h","b","l"],["i","ye","ol"])
22:40:55 <inimino> @type &&&
22:40:56 <lambdabot> parse error on input `&&&'
22:40:59 <dmwit> :t (&&&)
22:41:00 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
22:41:01 <inimino> @type (&&&)
22:41:02 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
22:41:39 <dmwit> dancor: I think there's nothing wrong with the code you wrote.
22:41:48 <dancor> ok
22:41:49 <dmwit> dancor: Although this kind of thing might be rolled into the consumer.
22:42:15 <dmwit> > first concat . unzip . map (splitAt 1) $ ["hi", "bye", "lol"]
22:42:16 <lambdabot>   ("hbl",["i","ye","ol"])
22:42:21 <dmwit> yuck
22:43:11 * quicksilver gives up on the semantics argument in the -cafe since nobody seems to see what I'm after in a semantics or why you should care.
22:43:18 <dmwit> > unzip . map (head &&& tail) $ ["hi", "bye", "lol"]
22:43:19 <lambdabot>   ("hbl",["i","ye","ol"])
22:43:30 <dmwit> ah!
22:43:50 <dmwit> > ((&&&) `on` map) head tail ["hi", "bye", "lol"]
22:43:52 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
22:43:52 <lambdabot>        Expect...
22:44:06 <dmwit> :t (&&&) `on` map
22:44:07 <lambdabot> forall a b. (a -> b) -> (a -> b) -> [a] -> ([b], [b])
22:44:16 <dmwit> oh, yeah
22:44:43 <RayNbow> type inference <3
22:45:04 <RayNbow> types are sometimes easier to understand than code :p
22:45:29 <adu> :t (&&&)
22:45:30 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
22:45:49 <adu> :t on
22:45:50 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
22:46:50 <dmwit> It makes you wish for a "split" operator.
22:47:15 <adu> @src (&&&)
22:47:15 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
22:47:31 <adu> @src (***)
22:47:31 <lambdabot> f *** g = first f >>> second g
22:47:47 <dmwit> not that such a thing would be possible =/
22:48:19 <inimino> a split operator?
22:48:24 <adu> dmwit: what split? like in perl?
22:48:50 <dmwit> A "split" that takes a value, and copies it, so that the types need not be the same after the copy.
22:48:59 <dmwit> :t on
22:49:00 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
22:49:22 <dmwit> The problem with "on" is that the second argument pins down "a" and "b", even if it's pretty darn polymorphic itself.
22:49:32 <inimino> you mean like a coerce?
22:49:40 <adu> > (&&&) `on` map (+1) (`subtract`1) [1,2,3]
22:49:41 <lambdabot>       The section `(`subtract` 1)' takes one argument,
22:49:42 <lambdabot>      but its type `[a]...
22:49:59 <rwbarton> > ((&&&) `on` map) (+1) (subtract 1) [1,2,3]
22:50:00 <lambdabot>   ([2,3,4],[0,1,2])
22:50:07 <dmwit> inimino: Exactly, that's why I decided it "wasn't possible" -- meaning, really, that for other reasons it isn't desirable.
22:50:16 <inimino> ok
22:50:22 <adu> > (&&&) `on` map (+1) (+2) [1,2,3]
22:50:23 <lambdabot>       The section `(+ 2)' takes one argument,
22:50:23 <lambdabot>      but its type `[a]' has none
22:50:39 <dmwit> > (&&&) `on` map head tail [[1]]
22:50:40 <lambdabot>   Couldn't match expected type `[[a]]'
22:50:54 <rwbarton> More parentheses everybody!
22:50:57 <dmwit> > (map head &&& map tail) [[1]]
22:50:59 <lambdabot>   ([1],[[]])
22:51:28 <dmwit> See? If we expand the definition, it typechecks, because "map" takes two different types in the two places you substitute it in.
22:51:43 <dmwit> rwbarton: Good point.
22:51:52 <dmwit> > ((&&&) `on` map) head tail [[1]]
22:51:53 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
22:51:53 <lambdabot>        Expect...
22:51:59 <dmwit> That's more like it.
22:52:15 <inimino> oh, I see
22:52:33 <RayNbow> > (\x -> x x) id 4
22:52:34 <lambdabot>       Occurs check: cannot construct the infinite type: t = t -> t2 -> t1
22:52:34 <lambdabot>    ...
22:52:40 <RayNbow> ah damn :p
22:52:55 <dmwit> But that's expected.  One of the first things you learn about when you study type systems is that evaluation can make a program "more well typed", so to speak.
22:52:59 <dmwit> =)
22:53:08 <rwbarton> > (\(x :: forall a. a -> a) -> x x) id 4
22:53:09 <lambdabot>   4
22:53:33 <dmwit> That's not H98! =P
22:54:05 <inimino> I guess I should read about arrows
22:54:23 <dmwit> I guess I should sleep.p
22:54:27 <rwbarton> Hmm, I wonder what kind of computation is possible using RULES...
22:57:52 <rwbarton> http://hpaste.org/11164  <-- very wrong! :)
22:58:32 <sjanssen> rwbarton: nice
22:58:55 <rwbarton> I'm pretty sure I can't turn a literal '4' into s (s (s (s z))) though...
22:59:52 <sjanssen> rwbarton: I wouldn't be so sure
22:59:57 <rwbarton> Aw, n+k patterns don't work in RULES :)
23:00:06 <rwbarton> hmm, any ideas?
23:00:47 <sjanssen> forall x. mkS x = if x == 0 then 0 else succ (mkS x)
23:01:05 <sjanssen> maybe use a case there to stress the optimizer less
23:01:28 <sjanssen> forall x. mkS x = if x == 0 then 0 else succ (mkS (pred x)) -- corrected
23:01:53 <rwbarton> also, by succ you mean s
23:02:13 <sjanssen> you'll need to make sure that mkS is applied *only* to values known at compile time
23:02:44 <rwbarton> Right, I think that can be ensured by only calling it from certain rules, as long as client programs don't use the I# constructor explicitly
23:02:54 <rwbarton> But I suspect that kind of rule will always loop anyways...
23:03:05 <sjanssen> rwbarton: actually, you should make s a NOINLINE version of succ
23:03:31 <sjanssen> it depends on how the optimizer is written
23:03:33 <rwbarton> oh, clever
23:03:48 <sjanssen> if it does known case elimination after each rule match, then we're safe
23:04:43 <sjanssen> forall x. mkS (I# x) = ... -- might be a safer rule
23:04:52 <rwbarton> But it doesn't seem to, that rule goes into a loop
23:05:01 <sjanssen> oh well
23:05:38 <rwbarton> Yeah, that's why I think the 4 -> s (s (s (s z))) rule isn't going to happen
23:09:02 <adu> i think I just realized how to make the most interesting bot
23:19:00 <pumpkin-> are there any large-scale haskell projects out there that I can examine to see how things like that are structured in haskell?
23:19:11 <OceanSpray> GHC?
23:19:14 <OceanSpray> xmonad?
23:19:24 <OceanSpray> darcs?
23:19:55 <pumpkin-> cool, I'll check those out then
23:21:22 <pumpkin-> dons: mind if I pm?
23:22:12 <rwbarton> Ugh, ghc tells me the -# rule is firing but that's kind of hard to search for...
23:27:07 <adu> yey it finally compiled!
23:28:19 <lispy> adu: congrats (what is it?)
23:28:37 <adu> lispy: my -XLinkedTuples extension :)
23:28:54 <lispy> adu: huh, what is a linked tuple?
23:29:03 <adu> (a, (b, (c, ())))
23:31:22 <adu> lispy: to be more specific, one of the following: http://haskell.pastecode.com/7989
23:31:32 <adu> lispy: not sure which yet, but right now I'm trying (3)
23:35:56 <lispy> adu: what is the problem that you're solving?
23:36:35 <lispy> adu: I don't meant to interrogate, but I'm wondering what this is useful for
23:36:58 <lispy> adu: you want heterogeonous lists of finite length or something?
23:37:06 <adu> lispy: i don't know how the GHC parser works, and it is useful because it helps me learn
23:37:11 <mmorrow> pumpkin: bear in mind that GHC is old, and probably would be structured differently now that we have hierarchical modules and other such things.
23:39:03 <adu> lispy: but in general the problem of tuples
23:43:26 <adu> lispy: the problem as I see it is that tuples are incredibly painful to support and provide functions for, like zipWith99, or curry7
23:44:56 <rwbarton> sjanssen: still playing around.  Actually, x -# 1# does get simplified during RULES expansion.  But the problem now is that I can't say that a rule should apply only when the argument is nonzero
23:51:24 <lispy> pumpkin: xmonad is likely structured better than both GHC and Darcs
23:58:06 <dreixel> is there some way of knowing detailed system information in a Haskell program? Things like processor type and speed, ram, etc. Something like System.Info, but more detailed...
