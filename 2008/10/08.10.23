00:00:46 <Cale> Well... I suppose that is a special case of sorts.
00:01:24 <Cale> It appears according to that diagram that the root always has at most a left child.
00:01:35 <hhiroavalon> yes
00:02:25 <sjanssen> glguy: -package is not one of the options that may be set in a source file
00:02:55 <glguy> sjanssen, what about -lcrypto ?
00:03:41 <Cale> hhiroavalon: I think it might be easiest to write the function  forestToBin :: [RoseTree a] -> BinaryTree a first and then handle the root by:  roseToBin x = forestToBin [x]
00:03:41 <sjanssen> hmm, not sure if that is possible
00:04:10 <glguy> all of the options I need are in the .cabal file...
00:04:17 * glguy ponders a cabal load-ghci
00:05:15 <Cale> I structured forestToBin as a right fold, but it might be easier to do pattern matching if you're more comfortable with that.
00:05:24 <sjanssen> glguy: yeah, I really want that too
00:06:50 <hhiroavalon> Cale: thanks, let me think of that for a while... (sorry that I am not bright in Haskell... :(
00:07:09 <Cale> hhiroavalon: It's all right. We were all beginners at some point :)
00:12:30 <pao> hi all
00:12:51 <pao> class (Monad m) => MonadError e m | m -> e where
00:13:05 <pao> m -> e is a functional dependency, right?
00:13:10 <Cale> right
00:13:36 <Cale> It means that for any given m, there is at most one e for which MonadError e m is an instance.
00:13:44 <Shimei2> Heya. I was just wondering if there's an easy way to get ghci's debugger to set breakpoints in std. libraries.
00:14:04 <pao> Cale: it simply narrows the type checking?
00:14:33 <Cale> pao: Yeah, it helps when typechecking because e can be determined from m.
00:14:46 <Cale> (which removes ambiguities)
00:16:50 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=264#a264 -- this is my code for the rose tree to binary tree conversion.
00:17:53 <pao> Cale: my pc freezed :-( I lost any response....
00:18:03 <hhiroavalon> Cale: Thanks, but I'll try not to see it until I'm REALLY stuck (...which might happen really soon... ><)
00:18:08 <Cale> <Cale> pao: Yeah, it helps when typechecking because e can be determined from m.
00:18:09 <Cale> <Cale> (which removes ambiguities)
00:18:24 <pao> Cale: thanks
00:19:17 <Cale> hhiroavalon: Rather than doing it the way that I did it anyway, you should try to break it down into various cases for what list of trees you have, and pattern match.
00:20:52 <hhiroavalon> Cale: okay, thanks for your advice :)
00:28:53 <pao> are functional dependency still seen as controversial?
00:34:43 <sjanssen> pao: somewhat, yes
00:34:54 <sjanssen> but they're still used fairly frequently
00:35:17 <pao> sjanssen: thanks
00:37:18 <pao> sjanssen: the problem is I understand is with type checker robustness.... right?
00:38:00 <BONUS> this blog post posted yesterday would be fairly relevant to this: http://abstractabsurd.blogspot.com/2008/10/serious-problem.html
00:38:01 <lambdabot> Title: Abstract Absurdities: A serious problem
00:39:23 <pao> BONUS: thanks
00:41:24 * BMeph wonders how long before Oleg publishes his HMD inference system...in Scheme
00:41:52 <pao> BONUS: funny post :-)
00:41:59 <pao> BONUS: point taken
00:44:35 <johnnowak> BMeph: HMD?
00:44:43 <johnnowak> oh. right. damas.
00:44:44 <johnnowak> pfft.
00:45:06 <sjanssen> pao: type checker robustness, and it seems that fundeps aren't incredibly well understood
00:45:51 <sjanssen> pao: there are some who say that type families are a better solution, and that it makes more sense to have a functional type language rather than a logical one
00:46:07 <glguy> turns out they are equivalent
00:46:27 <glguy> and a matter of syntax
00:46:51 <sjanssen> it isn't just syntax
00:47:35 <glguy> at best type families provide a subset of functionality
00:47:57 <dolio> I'm pretty sure the type families guys claim the opposite is true.
00:47:59 <sjanssen> even so, the issue is deeper than syntax
00:48:21 <sjanssen> yeah, type families can encode all fundeps (though the encoding can become ugly)
00:48:21 <glguy> dolio, not as of ICFP '08
00:48:54 <Mzzz> any reference to type families?
00:49:03 <sjanssen> @google haskell type families
00:49:08 <glguy> Mzzz, unless you are using 6.10, they aren't ready
00:49:16 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Type_families
00:49:16 <lambdabot> Title: GHC/Type families - HaskellWiki
00:49:46 <Mzzz> I'm just interested in type systems
00:49:57 <glguy> ok , just warning if you in case you try playing with some code
00:50:16 <Mzzz> thanks
00:50:35 <glguy> one is logic programming in terms of equality constraints
00:51:23 <glguy> and the other is demonized as logic programing in a function language
00:53:31 <jsn> glguy: you're talking about type families and type classes?  "demonized"?
00:53:47 <glguy> jsn, no, functional dependencies are
00:54:01 <sjanssen> glguy: type families certainly have a more functional flavor
00:55:03 <sjanssen> I also like that the overlap and decidability rules are simple with type families
00:55:33 <glguy> because they picked constraints that made them simpler?
00:55:50 <path[l]> I have a question about the rwh book chapter 4 -> http://book.realworldhaskell.org/read/functional-programming.html. Im not sure what the "id" is in the first example
00:55:50 <lambdabot> Title: Chapter 4. Functional programming
00:56:12 <BONUS> id is a function that takes something and just returns the same thing
00:56:15 <BONUS> > id 299
00:56:16 <lambdabot>   299
00:56:21 <path[l]> oh
00:56:22 <path[l]> I see
00:56:24 <glguy> Anyway, I think its a bikeshed argument and I don't like that 6.8's fundeps have been neglected and broken
00:56:31 <glguy> while the type families impl wasn't done
00:56:38 <sjanssen> glguy: fundeps in 6.8 were broken?
00:56:58 <glguy> it doesn't check them to make sure they make sense
00:57:02 <path[l]> but it says "myFunction = id". So does that mean myFunction will now return whatever you give it?
00:57:07 <glguy> you have to use hugs to get sane checking
00:57:24 <sjanssen> glguy: can you give an example?  I hadn't heard of this
00:57:50 <glguy> sjanssen, I can dig some up when I get to work
00:57:55 <glguy> I left my laptop there
00:58:09 <sjanssen> no need if it's a hassle, I was just curious
00:58:10 <glguy> Iavor can explain in detail what they broke
00:58:15 <glguy> I 've just been affected by it
00:59:10 <glguy> ?type unfoldr Just
00:59:11 <lambdabot> forall a b. (a, b) -> [a]
00:59:25 <glguy> > unfoldr Just ('a','b')
00:59:25 <dolio> Fundebs don't interact properly with GADTs.
00:59:26 <lambdabot>   mueval: Prelude.read: no parse
01:00:27 <glguy> Someone needs to write the definitive lambda calculus interpreter in GADTs and put it up on hackage
01:00:29 <sjanssen> glguy: fun bug :)
01:00:35 <glguy> then we won't need to worry about them any more
01:01:26 <sjanssen> glguy: you're insinuating interpreters are the only use of GADTs?
01:01:39 <dolio> For instance, class Foo a b | a -> b ; instance Foo Int Int ; data Bar a where IBar :: Bar Int ; foo :: Foo a b => Bar a -> b ; foo IBar = 5 -- error
01:01:41 <glguy> I'm insinuating that I haven't seen a good use of them otherwise
01:01:51 <glguy> not that one doesn't exist
01:02:50 <johnnowak> glguy: they've been used extensively to prove correctness in a DVCS that's too buggy and slow to use compared to a pile of perl and C
01:03:37 <glguy> johnnowak, I'm not sure if that was an endorsement or not ;)
01:03:45 <johnnowak> heh, me neither
01:03:47 <glguy> of a number of things :)
01:04:19 <hhiroavalon> oh my... pattern matching is killing me... <<;;;
01:14:25 <xhanjian> q: why foldl can work with empty list? like  foldl (\acc x -> acc + x) 0 []
01:14:35 <xhanjian> here x = ?
01:14:53 <Baughn> xhanjian: The list isn't empty. It starts with a 0.
01:15:02 <Baughn> So to speak. ;)
01:15:23 <Baughn> xhanjian: Try that with foldl1, and it'll fail just fine
01:15:46 <xhanjian> but foldl1 will work with single element list
01:15:51 <Baughn> Yes
01:15:55 <Baughn> @src foldl
01:15:55 <lambdabot> foldl f z []     = z
01:15:55 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
01:16:07 <Baughn> It's kind of obvious how this works, I'd say.
01:16:23 <xhanjian> ic..
01:16:39 <xhanjian> a special case
01:17:08 <xhanjian> is there any way to look the src of foldl in ghci?
01:17:31 <Baughn> Nope, but there's normally a source link in the library documentation
01:17:45 <xhanjian> thanks Baughn
01:18:01 <Baughn> The @src command doesn't actually look up the source - it uses a manually written database. The documentation link is something else.
01:20:18 <solrize> @src foldl
01:20:18 <lambdabot> foldl f z []     = z
01:20:18 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
01:20:29 <solrize> oh
01:20:58 <solrize> btw has anyone looked at oleg's foldl-based i/o slides?  they are pretty good
01:21:18 <solrize> but i'm not understanding whether the idea is to fold over containers of single characters, which sounds inefficient
01:24:10 <dolio> I didn't read them that closely, but I don't think it's committed to any intermediate container form for the characters.
01:26:12 <dolio> I mean, you can interact with bytestrings with a left fold and that doesn't make them less efficient.
01:31:09 <rog> i don't know if anyone here uses Data.Accessor.Template, but if you do... is there some reason why it doesn't seem to be possible to derive accessors for a data type that's declared in another module? i've got a tiny example here: http://hpaste.org/11411#a0
01:32:50 <rog> (i'm not very familiar with TH, so i'm reluctant to go diving in if there's a simple answer...)
01:33:22 <rog> s/very/at all/ :-)
01:40:00 <glguy> solrize, I was at the presentation he gave at ICFP over them
01:40:06 <glguy> was pretty awesome
01:40:19 <glguy> There isn't any reason they have ot be based on lists of chars
01:42:18 <dolio> I'm pretty sure one of his points is that it can be higly efficient. :)
01:42:22 <rog> solrize: the idea is that you fold over chunks (often corresponding to IO read chunks)
01:43:00 <rog> rog: each chunk contains many characters (or whatever your component data type is)
01:43:07 <rog> s/rog/solrize/ :-)
01:43:39 <solrize> well, say you want to write "wc", so you want to split the input stream into lines or words
01:44:20 <solrize> i guess you have to handle the case of lines crossing chunk boundaries by accumulating across calls
01:44:26 <solrize> basically you're writing a state machine
01:44:38 <solrize> seems kind of old fashioned when i think of it that way :)
01:45:02 <dolio> wc is pretty easy, really. Just count \ns and groups of spaces.
01:45:35 <solrize> well let's say you want to actually do something with the words (like translate them to pig latin) not just count them
01:46:21 <dolio> Yeah. That's the problem with bytestring folds over chunks I've had.
01:46:43 <dolio> Carrying across chunk boundaries is a pain.
01:46:53 <solrize> you had some code for python-like iterators that i never understood
01:47:05 <dolio> I did?
01:47:10 <solrize> i thought so
01:47:14 <solrize> hmm
01:47:16 <rog> solrize: the thing is you can write operators that look arbitrarily far ahead
01:47:36 <dolio> Well, I have generators implemented with delimited continuations. I don't think that'd be speedy, though.
01:47:45 <solrize> yeah, that's what it was
01:49:08 <rog> although you do have to rewrite much of your list-based code into foldl-based code, which would be annoying, i think.
01:51:40 <solrize> oh man it's almost 0200 here, i better go to bed.  nite
01:55:57 <rog> solrize: 0955 here...
01:57:22 <dolio> You can't use list-based code for byte strings anyhow. :)
01:58:56 <rog> dolio: getContents doesn't return a byte string...
01:59:15 <dolio> getContents is slow.
01:59:28 <rog> dolio: interesting. why's that?
01:59:44 <dolio> Because [Char]-based IO is slow.
02:00:27 <rog> dolio: ... but that's what oleg's foldl stuff comes down to, in the end. and he reckons it's fast.
02:00:29 <dolio> At least, as implemented in GHC.
02:00:44 <rog> dolio: is it just that the unsafeInterleaveIO is slow?
02:00:56 <dolio> Maybe with ndm's supercompiler you'll be able to get high performance.
02:01:12 <dolio> No, it's that [Char] has huge amounts of overhead for each character.
02:01:28 <dolio> data [] a = [] | a : [a]...
02:01:52 <dolio> So, tag byte, pointer-tag-byte for each character...
02:02:05 <dolio> And a pointer for the next character.
02:02:23 <dolio> Wait, no, characters are more than a byte.
02:03:11 <dolio> Tags might be more than a byte, too, I'm not sure.
02:03:11 <rog> is there a reasonable alternative?
02:03:24 <dolio> Yeah, bytestrings.
02:03:46 <dolio> Although they aren't great for unicode, although utf8-string might be all right for that.
02:04:24 <quicksilver> [Char] is between 16 and 24 bytes per char
02:04:28 <dolio> Anyhow, as was mentioned earlier, there's nothing necessarily tying Oleg's formalism to lists of characters.
02:04:30 <quicksilver> depending on host word size.
02:05:01 <rog> but if you're not hanging on to the start of the string, surely the overall space overhead isn't too bad?
02:05:12 <BeelsebobWork> @pl \f g h = uncurry f (g &&& h)
02:05:12 <lambdabot> (line 1, column 8):
02:05:12 <lambdabot> unexpected "="
02:05:12 <lambdabot> expecting pattern or "->"
02:05:21 <BeelsebobWork> @pl \f g h -> uncurry f (g &&& h)
02:05:22 <lambdabot> (. (&&&)) . (.) . uncurry
02:05:25 <BeelsebobWork> bugger
02:05:25 <rog> (or does the space overhead translate into much time overhead too?)
02:05:35 * BeelsebobWork wonders if there's a function for that already
02:06:31 <quicksilver> rog: if you're not hanging on to the start of the list it's not too bad, no.
02:06:43 <lispy> rog: dealing with excessive waste will slow down your programs substantially
02:06:49 <quicksilver> rog: since most of the fluff stays in the cache
02:06:59 <quicksilver> rog: you're still exercising the GC quite hard though.
02:07:14 <rog> lispy: ... but don't all haskell programs generate excessive amounts of waste? :-)
02:07:37 <lispy> rog: well, it depends.  If you're using good consumer/producers then it's efficient
02:07:38 <dolio> Not all of them.
02:07:48 <rog> lispy: i mean, most times you create a closure, it's waste, no?
02:07:49 <lispy> rog: it's the *excessive* waste that is bad
02:08:14 <lispy> anyway, I'm going to bed.  good luck :)
02:08:18 <dolio> Good bytestring code can get fused into very nice loops.
02:08:32 * rog has difficulty understanding the performance trade-offs in haskell
02:09:20 <dolio> dons has benchmarks competing well with C, for instance.
02:10:14 <rog> dolio: i bet the code doesn't look very idiomatic though.
02:10:15 <dolio> Although I wouldn't necessarily expect to get that competitive in larger programs.
02:10:33 <rog> indeed.
02:10:36 <dolio> Well, you'd be wrong.
02:11:28 <dolio> I'm pretty sure he gets pretty good speed with 'main = foo . bar . baz =<< getContents' style stuff.
02:11:33 <rog> i guess it depends on the nature of the inner loop, if there is one.
02:11:36 <cow_2001> woah. it's more or less as big as #gentoo!
02:11:42 <BeelsebobWork> oh duh, it's called liftA2
02:13:54 <solrize> what about main = (foldr (.) id [foo,bar,baz]) << getcontents'
02:14:08 <solrize> i.e. you don't know what foo bar and baz are until runtime
02:14:37 <solrize> is there a way to invoke the compiler somehow, to get interprocedural optimizations on a constructed function like that?
02:14:46 <quicksilver> nope.
02:14:57 <quicksilver> RULES are intrinscially static.
02:14:59 <quicksilver> sucks, doesn't it/
02:15:14 <solrize> well, if the compiler were a library...
02:15:31 <quicksilver> or if compilation was deferred until runtime...
02:16:38 <dolio> Then GHC could spend several minutes doing whole program optimization followed by running your actual program for a few seconds!
02:16:51 <cow_2001> how come this channel is HUGE and i hardly ever hear about this language except from medfly who is a friend of cale?
02:17:13 <solrize> i'm ok with ghc spending several minutes optimizing.  the program will run for days or weeks
02:17:21 <dolio> Clearly you need new friends.
02:17:55 <rog> is there some way to stop ghci printing all the current modules at the prompt?
02:18:44 <rog> it'd be really nice to be able to have a 2 char prompt. more space for useful info.
02:19:31 <RayNbow> rog, :set prompt "> "
02:20:12 <rog> RayNbow: i just found it!
02:20:24 <rog> RayNbow: bliss
02:20:28 <RayNbow> :)
02:23:17 <quicksilver> :set prompt "[#haskell] "
02:23:23 <quicksilver> then ghci seems more friendly
02:24:31 <rog> quicksilver: :-)
02:26:26 <rog> it's true though. the restraint, forbearance & general good humour shown by those on this channel is amazing.
02:26:33 <rog> compared to others i've seen
02:27:12 <rog> the best answer to a stupid question *is* silence :-)
02:27:14 <RayNbow> quicksilver: why not :set prompt "<lambdabot> "? :p
02:28:01 <RayNbow> (although ghci out-of-the-box misses certain features)
02:29:06 <luite> RayNbow: you mean :set prompt "<RayNbow> " ?
02:29:44 <RayNbow> hmm...
02:29:55 <luite> it does not answer using the prompt
02:31:24 <luite> RayNbow: you may need top patch GHCi to answer as <lambdabot>. if you do so, could you implement the @src command and send me the patches? :)
02:33:03 <hugo__> where can i read about comonads ?
02:33:04 <RayNbow> http://www.cse.unsw.edu.au/~dons/code/goa/ ?
02:33:05 <lambdabot> Title: Index of /~dons/code/goa
02:33:13 <RayNbow> ^ luite
02:34:09 <quicksilver> I think GoA has bitrotted, though?
02:34:11 <quicksilver> it's a cool idea.
02:34:36 <dolio> @go essence of dataflow comonad pdf
02:34:40 <lambdabot> http://cs.ioc.ee/~tarmo/papers/aplas05.pdf
02:34:40 <lambdabot> Title: LNCS 3780 - The Essence of Dataflow Programming
02:34:44 <luite> RayNbow: but then I'd have to be able to build lambdabot first
02:34:59 <luite> which is somewhat a problem on iwndows
02:35:14 <RayNbow> quicksilver: also, one of the blog posts on GoA is kinda dead... (Google Cache: http://64.233.183.104/search?q=cache:zXjkCGj1K-kJ:chrisdone.com/08-08-01%2520GHCi%2520on%2520Acid+%22ghci+on+acid%22&hl=nl&ct=clnk&cd=3&gl=nl )
02:35:16 <lambdabot> Title: Chris Done's Blog, http://tinyurl.com/5sjdjp
02:37:20 <hugo__> dolio, yes, im reading that one, thanks :D
02:37:41 <dolio> I have others, but looking at them, I think I haven't read a lot of them.
02:37:46 <rog> "We assume that the reader is familiar with [...]denotational semantics and the
02:37:46 <dolio> So I don't know which are good.
02:37:46 <rog> Lambek-Lawvere correspondence between typed lambda calculi and cartesian
02:37:47 <rog> closed categories." oh well.
02:38:15 <dolio> I don't actually remember if that one's good, either.
02:38:49 <luite> RayNbow: does the GoA :hoogle command work without an internet connection?
02:39:33 <Baughn> What would I put in .cabal/config to have it compile everything with -O2?
02:39:42 <dolio> However, dataflow is probably a good subsection to look at.
02:40:24 <dolio> It clicked with me when I heard someone say that dataflow languages are comonadically impure in the same way that imperative languages are monadically impure.
02:40:45 <dolio> (Not that dataflow is the only use for comonads.)
02:41:54 <quicksilver> luite: hoogle doesn't use an internet connection.
02:42:03 <quicksilver> luite: hoogle is just a generated database which is searched
02:43:45 <yitz> RayNbow: It probably wouldn't be that hard to define ghci commands that interact with \bot on #haskell via IRC.
02:45:43 <quicksilver> yitz: no it wouldn't be that hard, but it's nicer to have it offline and not bothering the real \bot
02:46:21 <yitz> true. surprisingly, it seems to be harder to set up though.
02:47:09 <yitz> I don't think \bot minds being bothered. It might be more of a problem if millions of people start doing that.
02:50:26 <quicksilver> yitz: hard though you may find this to believe, I sometimes work offlinne :)
02:50:33 <quicksilver> yitz: in actual fact, most of my haskell hacking is offline.
02:51:25 <yitz> quicksilver: hehe, I envy you. My company is distributed, so I have no choice.
02:52:06 <quicksilver> yitz: my haskell hacking is not paid work ;)
02:52:11 <quicksilver> my paid work is all online, indeed.
02:52:17 <quicksilver> my haskell hacking tends to happen on the train.
02:53:01 <yitz> quicksilver: once they wifi every train - as they are now doing with planes - even that refuge will be lost.
02:53:20 <quicksilver> ;)
02:53:24 <quicksilver> well, I have GPRS/3G
02:53:29 <quicksilver> but I don't always choose to use it.
02:53:43 <quicksilver> expensive + slow
02:54:39 <yitz> I fear it won't be long before OSes won't work well offline anymore. They already can't be installed offline.
02:57:06 * quicksilver notes that debian can be installed fine offline.
02:59:58 <yitz> well, so can Mac OS X when that becomes necessary. But there's one company with a particularly large share of the market that wants to make sure that you are not engaging in any nefarious activity by installing their OS.
03:00:57 <Baughn> Apple?
03:01:03 * ivanm wonders which company yitz is referring to... ;-)
03:01:04 <yitz> uh, no,
03:01:08 <hugo__> sun ?
03:01:13 <Baughn> IBM?
03:01:21 <yitz> Amiga?
03:01:31 <Baughn> Name one company that /doesn't/ behave that way, when they have the ability to do so
03:03:11 <yitz> This goes along with the "Malicious Software Removal Tool" that they are so kind as to install for you automatically, and keep constantly up to date.
03:03:23 <ilyak> Just use linux
03:03:34 <hugo__> i hope the os of the future contains a quick search on the pirate bay :P
03:04:09 <Baughn> Ah, firefox.
03:04:14 <hugo__> their logo is just too good :)
03:04:19 <ilyak> hugo__: Well, you can set it up in kde in a minute
03:04:35 <hugo__> :)
03:04:43 <ilyak> so typing tpb:something anywhere will result in search opened in konq
03:05:31 <hugo__> im using kde 4, but konq is just too slow :( and breaks a lot...
03:05:44 <ilyak> Well, I didn't try konq from kde4
03:05:59 <ilyak> kde3 is fine for me, it's not very good on js tho
03:06:33 <yitz> I'm dreading the day when Debian testing ups me to kde4.
03:07:46 <ilyak> I hope kde4 wouldn't be the new vista
03:08:58 <BeelsebobWork> at least konqueror in kde4 should be much improved -- purely because it has the option to use WebKit/squirrelfish extreme instead of KHTML
03:09:40 <hugo__> oh
03:10:06 <hugo__> i miss most of firefox extensions :/
03:10:08 <yitz> Apple used konq as the basis of Safari, and they put a lot of work into it. Have they contributed anything back?
03:10:10 <hugo__> like firebug :P
03:10:25 <ilyak> yitz: sure, as an open-source webkit
03:10:36 <yitz> ah, that's that WebKit thing?
03:10:39 <BeelsebobWork> yitz: uh, yes... all of WebKit
03:10:40 <hugo__> have you seen the new apple ads ?
03:10:45 <dolio> That only happened recently.
03:10:46 <BeelsebobWork> and Squirrelfish Extreme
03:10:56 <BeelsebobWork> uh no, WebKit's been open since it started
03:11:14 <BeelsebobWork> the complaints were that Apple forked it and patched their fork with patches that were hard to merge back to khtml
03:11:17 <ilyak> Firefox extensions are cool, but I can't make myself use them
03:11:24 <dolio> They used to just dump tarballs on the khtml team.
03:11:52 <BeelsebobWork> yep, but they still maintained their own svn repo and said "you're welcome to take source from it"
03:12:03 <hugo__> ilyak: firemarks, ad-block plus, google notepad, firebug, customize google, etc...
03:12:06 <BeelsebobWork> mostly the KHTML team bitched that apple did a whole crap load of work on it, and they couldn't keep up with it
03:12:09 <hugo__> is just too much to skip
03:12:28 <ilyak> hugo__: Well, that's cool, still I can't make myself search for those and install them
03:12:40 <ilyak> I don't really enjoy tuning apps
03:12:41 <BeelsebobWork> hugo__: yeh, I used to use firefox purely for firebug, but now Safari's Web Inspector is better than it
03:12:46 <ilyak> Unless forced, really
03:12:48 <BeelsebobWork> so Safari trumps it somewhat
03:12:59 <hugo__> :)
03:13:10 <yitz> by contributing back I meant in a way that is usable, in cooperation with the team.
03:13:12 <BeelsebobWork> it is a shame that it's not available in other WebKit based browsers though
03:13:13 <hugo__> customize google is also preatty good
03:13:38 <BeelsebobWork> yitz: sure -- it was usable in that they could use the WebKit fork (which they've now decided to do because WebKit is now so much better than KHTML)
03:13:53 <yitz> ok
03:14:01 <BeelsebobWork> it's so usable that google chose to use WebKit's fork rather than KHTML's fork
03:14:02 <quicksilver> BeelsebobWork: safari's web inspector is quite a bit less powerful than firebug as far as I can see
03:14:11 <BeelsebobWork> quicksilver: have you got Safari 4?
03:14:14 <quicksilver> although it may well be easier to use
03:14:16 <quicksilver> no.
03:14:19 <BeelsebobWork> get it
03:14:29 <BeelsebobWork> they improved the web inspector *tons*
03:14:33 <quicksilver> the webkit nightlies?
03:14:38 <hugo__> :)
03:14:40 <BeelsebobWork> nope, it's on connect.apple.com
03:14:44 <BeelsebobWork> for the new GUI
03:14:57 <hugo__> ill buy a macbook when they make it touchscreen :)
03:15:05 <BeelsebobWork> haha
03:15:11 <BeelsebobWork> tbh, the new track pad is fecking shiny
03:15:19 <hugo__> :)
03:15:47 <yitz> Safari 4? I'm on a Mac (at the moment), and Software Update has me at 3.1.2.
03:16:03 <BeelsebobWork> yitz: yep, it's a developer preview -- go to connect.apple.com
03:16:08 <BeelsebobWork> grab the Safari 4 DP
03:16:19 <BeelsebobWork> and then grab the WebKit nightly off nightly.webkit.org
03:16:22 <BeelsebobWork> and you get the new engine too
03:16:26 <hugo__> yitz: you have to put the unstable repositories :)
03:16:33 <BeelsebobWork> (which is stupifyingly fast at javascript)
03:16:55 <hugo__> is there silverlight support for safari ? :P
03:17:07 <BeelsebobWork> heh, yes
03:17:13 <BeelsebobWork> not sure how much I care
03:17:13 <ilyak> Is there silverlight for anything other than windows?
03:17:25 <BeelsebobWork> yeh, there's both linux and mac os clients
03:17:27 <BeelsebobWork> but... meh
03:17:28 <yitz> BeelsebobWork: fast at js? they must be using the YHC backend.
03:17:29 <ilyak> As in 'original or fully compatible'
03:17:39 <ilyak> not as in 'another mono half-assburger'
03:17:50 <lilac> BeelsebobWork: webkit has not been open since it started, actually
03:18:00 <BeelsebobWork> yitz: heh, no, they wrote their own JIT for it -- it's much faster than google's new engine -- even at google's own test suite which was rigged to favor V8
03:18:12 <lilac> BeelsebobWork: apple only released the source when they were ready to release safari
03:18:14 <BeelsebobWork> lilac: uh, why can I svn co it then?
03:18:25 <hugo__> i have a friend that works in opera browser, and he tells me that opera sucks
03:18:27 <BeelsebobWork> oh sure
03:18:37 <BeelsebobWork> but they hadn't even announced that they were working on a browser until then
03:18:49 <lilac> BeelsebobWork: and even then, their BTS is closed, and a lot of the commits have messages saying "fix bug #1324" and the like
03:18:52 <BeelsebobWork> they were essentially just playing around with it up until safari 1's release date
03:19:17 <hugo__> it would be nice if google would make a web-based webbrowser :)
03:19:22 <hugo__> just for the recursive feeling of it
03:19:23 <BeelsebobWork> lilac: I have a browser window open with WebKit's bug repository open at the moment
03:19:57 <BeelsebobWork> it's at bugs.webkit.org
03:20:17 <BeelsebobWork> https://bugs.webkit.org/buglist.cgi?query_format=specific&order=relevance+desc&bug_status=__open__&product=WebKit&content= <-- all the bugs open atm
03:20:59 <hugo__> how do you make a living when you just code in haskell ?
03:21:16 <BeelsebobWork> at the moment -- I do it by working for Anygma
03:21:17 <lilac> BeelsebobWork: hmm, well that's good of them. it was certainly a problem in the early days
03:21:28 <hugo__> is it necessary to move to the UK ? i heard they have lots of jobs in the uk...
03:21:44 <hugo__> hmm
03:22:15 <BeelsebobWork> lilac: as far as I know, that bug repo has been open since they released safari 1.0 -- pretty much all the complaints about apple and web kit have been purely moans about a big corporation taking an OSS project and using it
03:22:24 <hugo__> im planning on starting my own company... and see where it goes
03:22:31 <hugo__> a new media art haskell company :P
03:22:33 <BeelsebobWork> and it's taken a *long* time for the KHTML devs to realise that they are actually contributing a crap load to it
03:23:24 <hugo__> but i need to finish the master thesis first :/ (which im working on dataflow programming  for 3D graph-visualizations )
03:23:37 <BeelsebobWork> they were essentially just pissed off that apple forked it, rather than chugging along at KHTML's slow pace
03:23:58 <quicksilver> well pr
03:23:59 <hugo__> typical...
03:24:06 <quicksilver> esumably apple made some big decisions/changes
03:24:13 <hugo__> ...have anyone tried to convince the guys at kernel.org to use darcs instead of git ?
03:24:13 <ilyak> BeelsebobWork: This isn't true, really
03:24:14 <BeelsebobWork> yep, I think they did
03:24:17 <quicksilver> which took it in a different direction from KHTML
03:24:19 * quicksilver shrugs.
03:24:24 <BeelsebobWork> yep
03:24:27 <quicksilver> but, this is open source for you
03:24:31 <quicksilver> you're allowed to do that :)
03:24:39 <hugo__> :P i think it would result in a nice flamewar: "hey use darcs instead of git..."
03:24:44 <BeelsebobWork> but not sufficiently different that the KHTML devs haven't gone "hey actually, that's a good engine", and switched konq over to it
03:24:47 <quicksilver> and it can't be disputed that apple produced a good product out if it.
03:24:49 <ilyak> Apple didn't release their webkit in any meaningful format before there were a large scandal, and then finally opened their trees and bugs and whatever
03:25:14 <hugo__> "hey linus, you are deprecated: here is darcs"
03:25:28 <ilyak> After they did that, I didn't heard of any complaints regarding their openness
03:26:06 <BeelsebobWork> the only real complaint I have over apple and FOSS atm is the state of darwin
03:26:44 <BeelsebobWork> but hey, that was BSD licenced -- they can do what they like with it... it's just a shame that they're no longer being nice with it
03:27:08 <hugo__> stallman was right then :)
03:27:12 <BeelsebobWork> no
03:27:26 <BeelsebobWork> I didn't say it was a bad thing that it was BSD licenced ;)
03:27:30 <quicksilver> lots of the things stallman says are right
03:27:35 <quicksilver> but his value judgements are subjective.
03:27:40 <hugo__> when stallman was here on my univ. lots of geeks showed up, and he just played flute...
03:27:43 <quicksilver> so, obviously, you can not agree with them.
03:27:44 <BeelsebobWork> yeh, that's roughly where I stand with him
03:28:03 <quicksilver> if the BSD stuff had been GPL'ed, apple couldn't have done what they did.
03:28:12 <quicksilver> would they, instead, have produced a GPL'ed kernel for OSX?
03:28:16 <quicksilver> I don't know. I doubt it, personally.
03:28:22 <BeelsebobWork> ditto
03:28:26 <ilyak> quicksilver: They wouldn't release it in the first place
03:28:28 <quicksilver> I imagine they'd have bought in something else.
03:28:36 <ilyak> Maybe there wouldn't be a unix-based mac os at all
03:28:40 <quicksilver> of course, none of us know for sure what woudl have happened ;)
03:28:42 <quicksilver> we can only guess.
03:28:50 <BeelsebobWork> quicksilver: I think most people's problem with him is not that he's factually inacurate, but instead that he's bloody good at pushing his opinion on the matter as being the fact of the matter
03:28:51 <hugo__> :)
03:28:58 <hugo__> i guess stallman would continue to play flute
03:29:00 <BeelsebobWork> i.e. he's bloody good at saying essentially the GPL is the only way to go
03:30:10 <hugo__> i once sent an email to stallman asking for his msn
03:30:17 <BeelsebobWork> haha
03:30:21 <BeelsebobWork> I bet that went down well
03:30:33 <hugo__> and he answered me, saying that chats are inefficient, and that he only used mail
03:31:15 <lispy> is there a function foo, such that foo [] bs = bs; foo as _ = as
03:31:43 <BeelsebobWork> (>>= .) . listToMaybe
03:31:45 <BeelsebobWork> ?
03:31:53 <BeelsebobWork> oh no
03:31:56 <lispy> mplus is almost it, but it concatenate
03:31:56 <BeelsebobWork> that's not quite right
03:33:47 <dolio> If MonadPlus ever gets split with MonadOrElse, you'll have your wish.
03:33:47 <BeelsebobWork> maybe (const as) fromJust . listToMaybe -- closer, but still not quite right
03:34:46 <dolio> > (\as bs -> foldr (\_ _ -> as) bs as) [] [1,2,3]
03:34:47 <lambdabot>   [1,2,3]
03:34:51 <dolio> > (\as bs -> foldr (\_ _ -> as) bs as) [1] [1,2,3]
03:34:52 <lambdabot>   [1]
03:35:05 <BeelsebobWork> neat
03:35:29 <lispy> > listToMaybe [1,2,3]
03:35:31 <lambdabot>   Just 1
03:35:56 <dolio> @pl (\as bs -> foldr (\_ _ -> as) bs as)
03:35:56 <lambdabot> flip =<< foldr . const . const
03:36:09 <dolio> Huh. Not nearly as bad as I was expecting.
03:36:18 <BeelsebobWork> the bind is a bit odd
03:36:25 <medfly> hey guys, i'm a bit of a haskell newbie, and something i'm doing requires me to check whether a number can be divided with no remainder. i'm a bit unsure how to do it, much less properly :) can anyone give me a hint?
03:36:37 <BeelsebobWork> medfly: mod
03:36:47 <BeelsebobWork> > 5 `mod` 2
03:36:48 <lambdabot>   1
03:36:58 <medfly> > 5.5 `mod` 2
03:36:59 <lambdabot>   Add a type signature
03:37:02 <medfly> ? :O
03:37:10 <BeelsebobWork> @type mod
03:37:11 <lambdabot> forall a. (Integral a) => a -> a -> a
03:37:18 <BeelsebobWork> gotta be integral
03:37:26 <medfly> what type is something like 5.5?
03:37:34 <BeelsebobWork> @type 5.5
03:37:34 <lambdabot> forall t. (Fractional t) => t
03:37:35 <medfly> @type 5.5
03:37:36 <lambdabot> forall t. (Fractional t) => t
03:37:37 <medfly> hehe :)
03:37:52 <dolio> What answer do you want from 5.5 `foo` 2?
03:37:53 <BeelsebobWork> (any fractional type)
03:38:31 <BeelsebobWork> more interestingly, what answer do you want from 5.00000000000001 `foo` 2
03:38:31 <medfly> hmm... would be nice if i could just check if its type fractional :) i guess i could do that... maybe...
03:38:39 <yitz> medfly: what does it mean for 5.5 to be "divided with no remainder"? Any two fractionsl numbers can be divided.
03:38:58 <medfly> if 5.5 divided by a certain number has no remainder.
03:39:17 <yitz> medfly: that's true of any number.
03:39:34 <medfly> a very certain number of my choosing :)
03:39:39 <BeelsebobWork> medfly: remainder only has meaning for integer types
03:39:46 <yitz> medfly: so here is your function: const True
03:40:04 <medfly> ?
03:40:46 <medfly> can i have like, an if statement that checks if the type is fractional?
03:41:18 <BeelsebobWork> in the mean time... I *think* what you're meaning is something along the lines of
03:41:19 <BeelsebobWork> > abs . snd . properFraction $ 5.5 < 0.00001
03:41:20 <lambdabot>       No instance for (RealFrac Bool)
03:41:20 <lambdabot>        arising from a use of `properFra...
03:41:31 <BeelsebobWork> > (abs . snd . properFraction $ 5.5) < 0.00001
03:41:32 <lambdabot>   False
03:41:33 <yitz> medfly: the compiler checks types at compile time.
03:41:38 <BeelsebobWork> > (abs . snd . properFraction $ 5) < 0.00001
03:41:39 <lambdabot>   True
03:41:57 <BeelsebobWork> > (abs . snd . properFraction $ 5 / 2) < 0.00001
03:41:58 <lambdabot>   False
03:42:25 <BeelsebobWork> (where 0.00001 is a measure of how much you trust floating point rounding)
03:42:52 <yitz> @type properFraction
03:42:53 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> (b, a)
03:43:16 <yitz> > (abs . snd . properFraction $ 5 % 2) < 0.00001
03:43:17 <lambdabot>   False
03:43:28 <BeelsebobWork> shush with your real rationals :P
03:43:29 <yitz> > (abs . snd . properFraction $ 5 % 1) < 0.00001
03:43:30 <lambdabot>   True
03:43:42 <medfly> i suppose i could do n `mod` 1 = 0 :)
03:43:52 <BeelsebobWork> only if you're dealing with integers
03:44:00 <medfly> yeah...
03:44:00 <BeelsebobWork> because mod only makes sense when dealing with integers
03:44:16 <BeelsebobWork> > (abs . snd . properFraction $ 1000000 % 1) < 0.00001
03:44:17 <lambdabot>   True
03:44:17 <yitz> here 0.00001 is a measure of what you mean by "approximately evenly divisible".
03:44:30 <BeelsebobWork> yitz: yeh, that's more accurate
03:45:11 <yitz> medfly: what do want to do exactly?
03:46:14 <flux> beelsebobwork, well, there's the remainder definition fmod(3) uses
03:46:36 <medfly> its an overcomplicated prime number generator.
03:47:08 <BeelsebobWork> then you *probably* don't want to use Floats anywhere, right?
03:47:08 <yitz> medfly: so won't you be dealing only with integers then?
03:47:14 <BeelsebobWork> so mod sounds like what you want
03:48:04 <hugo__> Occurs check: cannot construct the infinite type: t = IO t
03:48:15 <hugo__> something tells me my recursion is not quite right
03:48:18 <BeelsebobWork> heh
03:48:25 <BeelsebobWork> something tells me you used let when you meant <-
03:49:12 <medfly> yitz, uh... well, i wanted, when having a number n, to divide it by the previous primes, and see if i get a remainder..
03:49:25 <BeelsebobWork> medfly: so... use mod
03:49:34 <BeelsebobWork> they're all Integers aren't they?
03:49:49 <medfly> oh
03:49:51 <medfly> okay...
03:49:52 <hugo__> Inferred type: IO (IO t)
03:49:53 <medfly> thats a way
03:50:25 <hugo__> haskell should stop infering... its making bad things to my reasoning logic
03:50:28 <medfly> thanks :)
03:50:39 <medfly> :)
03:50:57 <EvilTerran> hugo__, without type inference, you would need explicit type signatures on *everything*
03:51:42 <BeelsebobWork> EvilTerran: depends if you consider figuring out that 5 is an Int to be "inferring" the type of 5 or not
03:52:05 <hugo__> yes, i kind of like it the way it is... it allows me to be sloppy with the sigs
03:52:48 <EvilTerran> and, this way, it helpfully infers for you that your code is wrong! :P
03:52:51 <yitz> > let primes = 2 : filter (\n -> all ((/= 0) . (n `mod`)) $ takeWhile ((<= n) . (^ 2)) primes) [3,5..] in primes
03:52:52 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
03:54:01 <EvilTerran> > let f (x:xs) = x : f (filter ((/=0).(`mod`x)) xs) in f [2..]
03:54:02 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
03:54:14 <EvilTerran> > ([2,3,5,7]...)
03:54:15 <lambdabot>   Not in scope: `...'
03:54:18 <EvilTerran> , ([2,3,5,7]...)
03:54:25 <EvilTerran> bah
03:54:26 <lunabot>  luna: Not in scope: `...'
03:54:34 <hugo__> is it clean do use "func = do return xpto" ? :/
03:54:47 <EvilTerran> just leave off the "do"
03:54:52 <hugo__> ok
03:55:07 <BeelsebobWork> > let primes = nubBy (\x y -> y `mod` x == 0) [2..] in primes
03:55:10 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
03:55:43 <rog> i'm trying to debug some template haskell. does anyone know what mkOccName and friends are supposed to do?
03:56:11 <rog> there's no mention in any of the tutorials. and the documentation has no explanation.
03:56:13 <yitz> @pl \x y -> y `mod` x == 0
03:56:13 <lambdabot> flip flip 0 . ((==) .) . flip mod
03:56:39 <EvilTerran> , src 'mkOccName
03:56:44 <rog> it would help if i knew what Occ was meant to stand for...
03:57:09 <lunabot>  mkOccName :: String -> OccName
03:57:19 <EvilTerran> hm
03:58:46 <yitz> @pl \x -> ( == 0).(`mod` x)
03:58:46 <lambdabot> ((0 ==) .) . flip mod
03:59:05 <medfly> :) i'm going to make something complicated and supposedly efficient.
03:59:36 <medfly> anyway, i'm going to eat, thanks for the help guys :)
03:59:48 <yitz> rog: occult? occidental?
04:00:10 <mokus> occurrence I think
04:00:19 <rog> yitz: or occurring?
04:01:46 <yitz> rog: grep '^occ' /usr/share/dict/words gives some interesting possibilities.
04:01:55 <yitz> occipitobregmatic
04:02:23 <yitz> occiduous
04:03:02 <mokus> occasionalist
04:03:45 <rog> thats, erm... useful.
04:07:46 <rog> from my trial-and-error, it looks like an OccName is like a Name without the module qualifications. or something. anyway, i've fixed the bug, by changing the original mkOccName to a plain mkName. i've probably broken something else in the process, but i'll submit a fix anyway...
04:20:20 <lispy> heh
04:20:24 <lispy> rog: what are working on?
04:25:08 <kaomoji> hello guys
04:25:51 <kaomoji> just a stupid question...
04:26:21 <quicksilver> kaomoji: you're not going to get any answers until you ask it :P
04:26:36 <kaomoji> what is the minimum/maximum value for a number in haskell?
04:26:45 <quicksilver> depends on the type.
04:26:54 <quicksilver> with Integer, there is no min/max, subject to the RAM on your machine.
04:26:54 <kaomoji> the largest one, then
04:26:59 <rog> lispy: a generalised "decision support framework" supporting various kinds of uncertainty in model parameters. the motivation is flood modelling, but it should be generally applicable.
04:26:59 <kaomoji> oh
04:27:20 <kaomoji> the number I want isn't an Integer
04:27:36 <quicksilver> what is it?
04:27:48 <kaomoji> the golden ratio
04:27:55 <kaomoji> f(^_^)
04:28:08 <quicksilver> well, that's not likely to be outside the min/max range :P
04:28:10 <rog> lispy: from the difficulty i'm having with HList, i feel i should probably have gone with dynamic types, though. a day and a half (so far) trying to get this piece of code to compile...
04:28:24 <quicksilver> since it's between 1 and 2
04:29:01 <kaomoji> true
04:29:24 <quicksilver> kaomoji: perhaps you meant to ask what was the highest precision?
04:29:28 <rog> lispy: the problem being that the error messages seem to bear to relationship to the cause of the problem, neither in location or meaning...
04:29:33 <kaomoji> exactly
04:29:38 <kaomoji> sorry about this
04:29:43 <quicksilver> kaomoji: well Rational is arbitrary precision
04:29:48 <kaomoji> my english isn't very good when I wake up
04:30:02 <quicksilver> but you'd need to write your own code for calculating an arbitrarily good approximation to phi.
04:30:25 <quicksilver> alternatively, CReal (which doesn't come pre-installed) gives you the tools for arbitrary precision computable reals.
04:30:37 <kaomoji> why isn't phi on Prelude, like pi?
04:31:37 <Deewiant> probably because it's easily defined accurately and pi isn't
04:31:46 <rog> isn't it possible for a continuing fraction to represent the golden ratio exactly?
04:31:59 <quicksilver> marmolak: because it's not actually useful for anything?
04:32:02 <quicksilver> oops
04:32:06 <quicksilver> tab complete errorr!
04:32:13 <quicksilver> kaomoji: because it's not actually useful for anything? :)
04:32:16 <SamB_XP> heh
04:32:20 <Deewiant> > (1 + sqrt 5) / 2 :: CReal
04:32:21 <lambdabot>   1.6180339887498948482045868343656381177203
04:32:23 <kaomoji> yes, it's possible rog
04:32:35 <Botje> it's useful for beating the snot out of kiddies who claim their language can compute fib the fastest :P
04:32:39 <quicksilver> but yes, phi has a simple closed form.
04:32:40 <MyCatVerbs> quicksilver: you have a tab key that expands snarky comments for you automatically?
04:32:47 <quicksilver> MyCatVerbs: of course.
04:32:53 <quicksilver> MyCatVerbs: do you think I think them all up on my own?
04:33:13 <Botje> i thought that was your scriptwriter :]
04:33:27 <rog> in fact, the continuing fraction form is particularly pretty, it seems.
04:34:00 <quicksilver> rog: I'm not sure it's really any prettier than the naive expansion for pi
04:34:04 <MyCatVerbs> quicksilver: I thought maybe you had a Tom Lehrer clone chained to the ceiling.
04:34:08 <MyCatVerbs> quicksilver: doesn't everyone?
04:34:10 <quicksilver> (but admittedly it converges faster)
04:34:24 <quicksilver> MyCatVerbs: I did. He escaped and went off to poison some pigeons.
04:34:25 <rog> quicksilver: but... it's all ones! isn't that nice?
04:34:36 <yitz> rog: numbers in quadratic extensions of the rationals all have nice repeating continued fractions.
04:35:13 <rog> yitz: indeed.
04:35:16 <MyCatVerbs> quicksilver: I'd lend you mine, but he went dancing and somehow got the crap beaten out of him in the process.
04:35:34 <kaomoji> man, you guys are really nerdy
04:35:39 <quicksilver> hello yeah.
04:36:03 <rog> (i have to confess i only found out about continuing fractions through the recent xkcd cartoon...)
04:36:04 <quicksilver> this is the only place in IRC you can be a maths nerd and have someone else understand the joke :P
04:36:04 <wjt> @remember kaomoji [on #haskell] man, you guys are really nerdy
04:36:05 <lambdabot> Nice!
04:36:13 <MyCatVerbs> kaomoji: thank you. :)
04:36:36 <quicksilver> wikipedia makes me laugh
04:36:44 <quicksilver> "The golden ratio can be expressed as a mathematical constant"
04:36:48 <MyCatVerbs> quicksilver: I think #scheme might qualify too, and presumably there exist #math and #group?
04:36:50 <quicksilver> what is that phrase supposed to mean?
04:36:57 <rog> quicksilver: change it!
04:37:06 <quicksilver> it *is* a mathmetical constant.
04:38:05 * quicksilver alters the page on wikipedia itself to say Wikipedia can be expressed as a free multilingual encyclopedia project.
04:38:19 <quicksilver> rog: bitching about WP is more fun than correcting it.
04:43:18 <kaomoji> om nom nom
04:43:24 <kaomoji> this chicken is delicious
04:43:30 * SamB_XP steals it
04:44:44 <profmakx> so
04:45:25 * rog goes and heats up some of last nights chorizo soup.
04:47:25 <pyNem> How do I get Arguments with ByteStrings?
04:47:53 <pyNem> I cant seem to find Data.ByteString.getArgs Data.ByteString.Char8getArgs
04:49:36 <quicksilver> pyNem: I don't think you can.
04:50:24 <kaomoji> does this channel have an official song?
04:50:57 <pyNem> quicksilver, http://cvs.haskell.org/Hugs/pages/libraries/base/Data-ByteString.html#v%3AgetArgs tells me otherwise
04:51:09 <lambdabot> Title: Data.ByteString, http://tinyurl.com/63fbrf
04:51:25 <quicksilver> pyNem: intriguing
04:51:39 <pyNem> quicksilver, in any case, I need to take a one word command line argument, and compare it with several ByteStrings from a list
04:51:56 <idnar> @hoogle (%)
04:51:56 <lambdabot> Data.Ratio (%) :: Integral a => a -> a -> Ratio a
04:52:15 <quicksilver> pyNem: well the solution to your problem is just to convert the strings to bytestrings
04:52:31 <quicksilver> pyNem: I'm intrigued y the function apparently appearing or disappearing
04:52:54 <pyNem> quicksilver, I cant seem to figure out how to do that.. All I find are word8 -> ByteString, and I dont know what word8 is
04:53:32 <quicksilver> pyNem: pack
04:53:38 <quicksilver> (the Char8 version of ByteString)
04:53:54 <Peaker> @src Ratio
04:53:54 <lambdabot> data (Integral a) => Ratio a = !a :% !a
04:54:07 <pyNem> @hoogle (pack)
04:54:08 <lambdabot> Prelude undefined :: a
04:54:08 <lambdabot> Data.Array.Base arrEleBottom :: a
04:54:08 <lambdabot> Test.QuickCheck.Batch bottom :: a
04:54:10 <idnar> what is the difference between data and newtype?
04:54:33 <quicksilver> idnar: not much. Mostly just runtime efficiency.
04:54:39 <Peaker> idnar: newtype is only allowed to have one data constructor, and is strict on the data within it, so it does not introduce a new value to the datatype (bottom)
04:54:42 <quicksilver> there is a subtle semantics difference.
04:55:10 <pyNem> quicksilver, I still dont get it :( -> pack :: [GHC.Word.Word8] -> ByteString .. but how do I convert a String -> GHC.Word.Word8 or directly String -> ByteString
04:55:21 <pyNem> quicksilver, oh wait
04:55:21 <SamB_XP> also it is only allowed to have one field on that constructor ...
04:55:29 <Peaker> quicksilver: what difference remains between: data Blah = Blah !T    and  newtype Blah = Blah T ?
04:55:30 <idnar> okay
04:55:31 <pyNem> quicksilver,  let me try hoogle .. I have never tried it before :)
04:56:12 <lilac> @hoogle (a,a) -> [a]
04:56:12 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
04:56:12 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
04:56:12 <lambdabot> Prelude snd :: (a, b) -> b
04:56:22 <pyNem> quicksilver, http://hackage.haskell.org/packages/archive/bytestring/0.9.1.0/doc/html/Data-ByteString-Lazy-Char8.html#v:pack :) .. thanks .. I understood now
04:56:22 <quicksilver> Peaker: the one you just said.
04:56:24 <lambdabot> Title: Data.ByteString.Lazy.Char8, http://tinyurl.com/5gtb2e
04:56:28 <quicksilver> Peaker: (bottom)
04:59:17 <pyNem> Suppose I do import qualified Data.ByteString.Lazy as B, then is there a way I can address Data.ByteString.Lazy.Char8.lines quickly (some sort of B.Char8.lines) ?
04:59:17 <Peaker> quicksilver: oh, I thought the strictness made a new bottom impossible
04:59:29 <quicksilver> ah hmm.
04:59:43 <quicksilver> yes, I was slightly wrong
04:59:52 <quicksilver> the difference is in whether case x of Blah y -> forces the bottom or not
05:00:23 <Peaker> in the case of data, yeah, in the case of newtype, no?
05:00:31 <quicksilver> right.
05:00:55 <rog> but if the data field is qualified with !, there's no difference?
05:01:05 <Peaker> the bottom is sort of "moved" from the contained value to the containing type?
05:01:06 <quicksilver> yes there is the different I just said.
05:01:34 <quicksilver> something like that
05:02:16 <rog> hmm
05:02:20 <idnar> is there any sort of stylistic principle on when to use one, and when to use the other?
05:02:42 <quicksilver> the general principle is always use newtype when it applies
05:02:53 <idnar> okay
05:03:35 <idnar> ah, the wiki has a nice explanation of the differences
05:05:18 <rog> yet another nightmare error message: http://hpaste.org/11413#a0
05:05:20 <rog> aargh
05:05:21 <idnar> oh, hmm
05:05:45 <idnar> I guess I can't turn "data Foo a = (a,a)" into a newtype
05:06:40 <ronwe> that isnt a valid data type declaration
05:06:45 <Saizan> rog, Peaker: data D = D !Int, newtype N = N Int, D _|_ == N _|_ == _|_, but case undefined of D _ -> () == _|_, while case undefined of N _ -> () == ()
05:06:51 <idnar> er
05:07:22 <idnar> data Foo a = Foo (a,a) is what I meant
05:07:26 <int-e> idnar: newtype Foo a = Foo (a, a) will work. But maybe you should rather use  data Foo a = Foo a a
05:07:52 <idnar> but the newtype was fine too, I just had a typo
05:08:12 <idnar> int-e: yeah, I guess so
05:08:32 <rog> Saizan: presumably that's because if you *did* add more constructors to D, you wouldn't want the semantics to change?
05:08:55 <Saizan> rog: exactly
05:09:11 <Beelsebob> Saizan: D _|_ /= _|_ does it?
05:09:29 <Saizan> Beelsebob: no, if data D = D !Int
05:09:33 <Beelsebob> oh, okay
05:09:47 <Beelsebob> isn't that more of D _|_ is not a valid value
05:10:02 <Beelsebob> you either have _|_ or you have D with a computed int
05:10:23 <Beelsebob> D _|_ just isn't in the set
05:10:26 <quicksilver> well "D (fix id)" is valid, compilable term
05:10:27 <Saizan> well you can surely apply D to a non-terminating espression
05:10:32 <idnar> http://www.haskell.org/haskellwiki/Newtype
05:10:33 <lambdabot> Title: Newtype - HaskellWiki
05:10:50 <Beelsebob> ah true
05:11:09 <int-e> quicksilver: yes, but semantically that's bottom
05:11:18 <Beelsebob> otoh, pattern matching against that doesn't work
05:11:35 <Beelsebob> case (D (fix id)) of D _ -> () == _|_
05:11:37 <Beelsebob> not ()
05:11:48 <Saizan> ..that's what i said
05:12:00 <Beelsebob> oh, so you did
05:12:08 <Beelsebob> brain confused, sorry
05:12:21 <yitz> perhaps Beelsebob meant case (D (fix id)) of _ -> ()
05:12:34 <Saizan> i probably abused notation when i wrote D _|_ == _|_
05:12:37 <quicksilver> int-e: agreed.
05:12:51 <quicksilver> int-e: I'd still "call it" D _|_
05:12:52 <opqdonut> case (Just (fix id)) of _ -> () == ()
05:13:06 <quicksilver> int-e: but I agree entirely with Saizan's equation D _|_ = _|_
05:13:10 <quicksilver> that was the whole point.
05:13:12 <opqdonut> case (Just (fix id)) of Just _ -> () = ()
05:13:16 <yitz> opqdonut: yes because Just is not strict
05:13:26 <opqdonut> ah, we were still talking about a stric constructor
05:13:27 <opqdonut> sorry
05:14:04 <int-e> quicksilver: oh, ok, I missed your point then
05:14:16 <opqdonut> communication breakdown :)
05:15:09 <lispy> > undefined == undefined
05:15:10 <lambdabot>   * Exception: Prelude.undefined
05:15:33 <lispy> > 1/0 == 1/0
05:15:34 <lambdabot>   True
05:15:38 <lispy> wait as ec
05:15:43 <lispy> > 1/0
05:15:44 <lambdabot>   Infinity
05:15:49 <C-Keen> undefined should always raise an exception
05:15:50 <lispy> oh n/m
05:15:54 <lispy> I thought 1/0 was NaN
05:16:02 <ronwe> indar, the way i see it, newtype is more for restricting the interface to some pre-existing type, while data is used for creating new algebraic data types.
05:16:11 <yitz> > 0/0
05:16:13 <lambdabot>   NaN
05:16:23 <lispy> > 0/0 == 0/0
05:16:24 <lambdabot>   False
05:16:27 <lispy> Yay!
05:16:30 <lispy> yitz: thanks
05:17:12 <Peaker> Saizan: from the above, it seems that D _|_  == _|_, but N _|_ /= _|_
05:17:32 <lispy> Someone made a webpage that spells this out in 3 simple examples
05:17:36 <lispy> I wonder where that is now
05:17:47 <opqdonut> hrr, IEEE754 comparisons
05:17:49 <Kamina> Hi, can someone tell me, why I get the error message "No instance for (Monad ((->) [Double]))", while the ghci documentation says that there is an instance "Monad ((->) r)" ?
05:18:04 <Deewiant> Kamina: import Control.Monad.Instances
05:18:04 <quicksilver> Kamina: you need to import Control.Monad.Instances
05:18:09 <Kamina> ah
05:18:10 <yitz> ronwe: yes, but then you could always just use the pre-existing type itself. The advantage of the newtype is that then you can define different class instances.
05:18:14 <lispy> This newtype/data handling of bottom is why we want (but can't have in Haskell) strongly normalizing value
05:18:28 <Kamina> Deewiant,quicksilver: Thanks a lot... how should i have known ;-)
05:18:34 <Peaker> lispy: what does that mean?
05:18:36 <Deewiant> Kamina: that instance isn't Haskell 98, so it's not in scope by default, which can be annoying
05:18:58 <Kamina> Deewiant: if you want to overwrite it with some other meaning?
05:19:22 <yitz> Kamina: you are right, that really needs to appear in the docs.
05:19:24 <quicksilver> yitz: not just that. you may also wish to restrict the interface in other ways.
05:19:32 <lispy> Peaker: in Haskell _|_ is something we live with...we have general recursion for example.  But if the language was total, then all values would be strongly normalizing...meaning it doesn't matter semantically whether it's lazy or strict and there is no _|_
05:19:40 <Saizan> Peaker: N undefined `seq` () == _|_, so essentially it's like N is not there at all
05:19:55 <Kamina> yitz: do you have contact to the guys maintaining the docs? or should i write them something?
05:20:02 <Deewiant> Kamina: I'm not sure there are many possible meanings, and in any case it's probably not a good idea
05:20:13 <Peaker> lispy: in a total language, you could still have infinite inputs, which distinguish laziness from strictness, no?
05:20:36 <SamB_XP> Deewiant: well, even defining another instance with the same meaning would conflict ...
05:20:41 <ronwe> yitz, you wouldnt be restricting the interface if you just used the type, and you can make new class instances reguardless of weather its newtype or datatype (as opposed to just type)
05:21:03 <Peaker> Saizan: but when pattern-matching N it is very much there... weird
05:21:15 <ronwe> he was asking about the differences between data and newtype
05:21:19 <Deewiant> SamB_XP: unless you don't use the other one anywhere, but yes, that's why I said it's not a good idea :-)
05:21:21 <Peaker> Saizan: why does seq force (N undefined) more than case does?
05:21:23 <lispy> Peaker: in a total language you can't have infinite inputs unless you allow codata.  But in that case, you require that processing the codata always makes progress.  You use the "co" version of structural recrusion called guarded recursion
05:21:43 <SamB_XP> Deewiant: and, in Haskell 98, defining such an instance would be fine ...
05:21:43 <quicksilver> Peaker: because case (for newtype) compiles away completely.
05:21:44 <Saizan> Peaker: well no, since if you remove N you get case undefined of _ -> ()
05:21:47 <quicksilver> Peaker: it vanishes.
05:22:08 <quicksilver> Peaker: that is the point of newtype - to add no runtime overhead.
05:22:11 <yitz> Kamina: hmm, where in ghci did you first see that there is an instance Monad ((->) r)?
05:22:26 <Peaker> quicksilver: ah, yeah it doesn't make a lot of sense to pattern-match a new type, except to extract the value
05:22:37 <idnar> @hoogle guard
05:22:37 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
05:22:37 <lambdabot> Language.Haskell.TH data Guard
05:22:37 <lambdabot> Language.Haskell.TH.Syntax data Guard
05:22:43 <Kamina> yitz: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
05:22:43 <lispy> yitz: that would be the instance for reader, iirc
05:22:45 <lambdabot> Title: Control.Monad, http://tinyurl.com/y25qsm
05:23:07 <Peaker> lispy: are there general purpose total languages that are usable for real-world stuff?
05:23:19 <pyNem> I am having type problems - http://hpaste.org/11414#a1
05:23:24 <quicksilver> the main reason the instance for (->) isn't in the prelude, similarly (,), is that they allegedly lead to confusing error messages.
05:23:33 <quicksilver> I'm not sure their absence improves thing notable.
05:23:37 <Kamina> yitz: I didn't look through the sub-pages of Control.Monad
05:23:38 <yitz> ronwe: true about restricting the interface, as quicksilver also pointed out. For instances, I meant alternative instances for existing ones.
05:23:54 <quicksilver> pyNem: mismatch between Lazy and strict?
05:24:02 <ronwe> true
05:24:07 <pyNem> quicksilver, how do i set it right?
05:24:17 <quicksilver> pyNem: don't import the strict version of sort
05:24:20 <quicksilver> pyNem: import the lazy one.
05:24:24 <quicksilver> import Data.ByteString (sort)
05:24:29 <quicksilver> ^^ that gives you the "wrong" sort.
05:24:37 <pyNem> ohh ..
05:24:58 <yitz> lispy: hasn't that instance been removed from C.M.Reader in favor of C.M.instnaces?
05:25:08 <lispy> Peaker: agda, coq and epigrams are the examples I know of...but they use dependent types and other crazy stuff I don't know much about.  Usable for real stuff?  Well.  I'm not sure.  If you want to do a proof and extract code then yes, otherwise I'm not sure.
05:25:09 <pyNem> where can I find the right sort? http://www.haskell.org/hoogle/?hoogle=sort doesnt say anything
05:25:10 <lambdabot> Title: sort - Hoogle
05:25:16 <pyNem> quicksilver, should I be writing my own?
05:25:22 <lispy> yitz: I don't know where it lives :(
05:25:29 <idnar> is it normal to use guard in a do block, rather than pattern matching?
05:26:01 <quicksilver> pyNem: no.
05:26:10 <quicksilver> pyNem: it's in ByteString.Lazy
05:26:12 <quicksilver> (isn't it?)
05:26:14 <yitz> Kamina: ah, I see. Most of the instances listed there have a link you can click on to see the docs of where the instance is defined. But (->) is not linked. Hmm.
05:27:06 <lispy> idnar: I've never really seen people use guard to be honet
05:27:09 <lispy> :t guard
05:27:10 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
05:27:28 <lispy> :t when
05:27:28 <pyNem> quicksilver, cant find a sort at http://hackage.haskell.org/packages/archive/bytestring/0.9.1.0/doc/html/Data-ByteString-Lazy.html
05:27:29 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
05:27:30 <lambdabot> Title: Data.ByteString.Lazy, http://tinyurl.com/5gv9xg
05:27:51 <idnar> I mean pattern matching against True
05:28:37 <quicksilver> pyNem: hmm. You could just use the 'list' version.
05:28:47 <quicksilver> pyNem: that will work with ByteStrings; it works for all a
05:28:50 <yitz> lispy, idnar I use guard all the time. But I prefer pattern matching when available. Or list comp. for []
05:28:51 <quicksilver> pyNem: import Data.List(sort)
05:29:08 <quicksilver> lispy: guard is great in the Maybe monad.
05:29:55 <yitz> idnar: oh. I guess guard would look more clear to me.
05:30:11 <idnar> I'm in the list monad right now
05:30:13 <pyNem> quicksilver, oh ok .. :) .. But I thought byteString was implemented using a Foriegn Pointer ?
05:30:27 <idnar> too many operations to fit comfortably in a list comprehension
05:30:38 <quicksilver> pyNem: so?
05:30:45 <quicksilver> pyNem: it still supports > and <
05:31:22 <pyNem> quicksilver, oh .. :)
05:31:31 <yitz> Kamina: the maintainer of Control.Monad is libraries@haskell.org. Post a message to that list.
05:32:30 <Kamina> yitz: okay, thank you for that info
05:32:40 <yitz> Kamina: I suppose this might be a feature that should be added to haddock, which generated the docs. But even if so, in the meantime I think a note should be added by hand to the docs.
05:33:53 <pyNem> quicksilver, still doesnt work - http://hpaste.org/11414#a2
05:34:04 <yitz> idnar: I know the feeling. Sometimes I write long, long list comps., but it feels weird.
05:34:40 <Kamina> yitz: maybe it's because "->" is not alphanumeric...
05:35:15 <yitz> yeah, it's an infix type symbol. that seems to be the issue.
05:35:17 <quicksilver> pyNem: I didn't read your code well enough before.
05:35:29 <quicksilver> pyNem: I didn't realise you actually wanted to sort the bytestring itself.
05:35:52 <quicksilver> pyNem: I believe your problem is much more easily solved by using [Char] to be honest :)
05:36:09 <quicksilver> but if you want to use bytestrings, use the strict flavour
05:36:32 <pyNem> quicksilver, yeah the first version was [Char] .. was a tad too slow in unjumbling the words
05:36:47 <pyNem> quicksilver, ok .. ill use the strict flavour :)
05:38:25 <yitz> Kamina: the home page for the libraries list is http://www.haskell.org/mailman/listinfo/libraries
05:38:26 <lambdabot> Title: Libraries Info Page
05:38:52 <yitz> wow the list description is embarrassingly outdated for such an important list.
05:39:00 <path[l]_> quick question. Whats the difference between import Data.List and :module +Data.List ?
05:39:15 <Deewiant> none, I think
05:39:24 <Deewiant> the latter doesn't work in source code ;-)
05:39:38 <yitz> and the former doesn't work at the ghci prompt
05:39:46 <Deewiant> yes it does
05:40:07 <yitz> the latter lengthens your ghci prompt string, unless you change it with :set prompt
05:40:15 <yitz> it does?
05:40:15 <Deewiant> the former does also
05:40:18 <Deewiant> yes, it does
05:40:19 <ronwe> (isnt sure when it works, but it does sometimes)
05:40:20 <quicksilver> import at the ghci prompt was added as a hack in some recent version
05:40:32 <quicksilver> I think.
05:40:35 <yitz> how about import qualified as?
05:40:40 <Deewiant> that doesn't work
05:40:40 <quicksilver> It's certainly not in 6.6 which is what I use.
05:40:44 <yitz> oof
05:42:15 <ronwe> ive had ghci make all of the imported modules in some source file in-scope inside the prompt aswell
05:42:22 <path[l]_> ah
05:42:24 <path[l]_> I see
05:42:40 <path[l]_> thanks
05:42:55 <path[l]_> whats import qualified as? Is it like adding a prefix for an import
05:43:05 <yitz> yes
05:43:21 <yitz> like: import qualified Data.Map as M
05:43:44 <lispy> qualified is kinda nice, but if you don't use a standard naming scheme for the qualification it can be a bit confusing :)
05:43:50 <yitz> then M.size is short for Data.Map.size
05:43:58 <lispy> import qualified Data.Map as BraSize -- this would be weird
05:44:08 <BeelsebobWork> that would be... fairly wierd, yes
05:44:16 <BeelsebobWork> good for obfuscation though
05:44:18 <lispy> BraSize.insert
05:44:26 <ronwe> i wish you could just 'import qualified with arbitrary dotless prefix foo'
05:44:39 <BeelsebobWork> would be better if it was Bra
05:44:41 <BeelsebobWork> Bra.delete
05:45:23 <yitz> @vixen the denizens of #haskell can sometimes be so juvenile.
05:45:24 <lambdabot> church is my favourite computer scientist.
05:45:36 <BeelsebobWork> haha
05:45:47 <BeelsebobWork> @vixen are you trying to imply that church is juvenile?
05:45:47 <lambdabot> i truely am
05:45:50 <BeelsebobWork> :D
05:46:06 <SamB_XP> @vixen really?
05:46:06 <lambdabot> really!
05:46:09 <SamB_XP> @vixen rly?
05:46:10 <lambdabot> i'll hafta plead the fifth on that one.
05:46:25 <medfly> what is that?
05:47:09 <ronwe> its an amendment to the united states constitution :P
05:49:20 <lispy> medfly: pleading the fifth means you use your right to *not* talk
05:49:57 <ddarius> Not to incriminate yourself
05:50:40 <lispy> from wikipedia: To "plead the Fifth" is a refusal to answer a question because the response could form self-incriminating evidence.
05:51:29 <medfly> ooooh... okay
05:52:07 <FunctorSalad> hi medfly ;)
05:53:38 <medfly> hi FunctorSalad
05:53:41 <medfly> i'm doing haskell!
05:53:57 <lispy> medfly++
05:54:00 <FunctorSalad> :)
05:54:01 <lispy> get your haskell on!
05:54:05 <FunctorSalad> good choice
05:54:22 <medfly> hehe
05:59:21 <ronwe> you have the right to id, anything you cons can and will be held against you in a list comprehension
06:07:33 <ronwe> you have a right to a (map lawyer), if you cannot afford one, one choosen at random from sufficiently low values n from a function from n to lawschool gpa's will be appointed
06:08:40 <ketil> [140482.214432] xmonad-i386-lin[5625]: segfault at 0 ip 080a1b7f sp bfc59a40 error 4 in xmonad-i386-linux[8048000+cc000]
06:08:43 <ketil> Whoops?!
06:09:31 <dmwit> Whoops!
06:09:32 <lispy> ketil: whoa.  I'd mention that in #xmonad
06:09:50 <dmwit> Sounds like you've got an xmonad/library mismatch.
06:09:59 <dmwit> But, yes, you should definitely bring this to #xmonad.
06:10:03 * lispy wants someone to port xmonad to osx in a way that interfaces with the native windowing system
06:10:15 <quicksilver> ketil: did you downmod one of dons' reddit posts?
06:10:24 <quicksilver> ketil: I think there is an xmonad backdoor for that case.
06:10:47 <ketil> No, this is fairly straight out-of-the-box xmonad as shipped with Ubuntu 8.10 (beta)
06:10:57 <byorgey> quicksilver: hehehe
06:11:05 <mc__> lispy:  I dont think it would be possible
06:11:50 <byorgey> when (downModded donsPost) $ unsafePerformIO segFault
06:13:39 <quicksilver> mc__: possible in principle. But you'd need to reverse engineer WindowServer
06:13:41 <quicksilver> not trivial.
06:14:32 <lispy> quicksilver: someone here though that it may be possible to use apple script
06:14:55 <quicksilver> to layout windows? possible
06:15:01 <quicksilver> to remove decorations? I'm fairly sure it's not.
06:15:17 <quicksilver> to add global keyboard shortcuts? Proabbly possible with some kind of scripting extension.
06:15:32 <quicksilver> to take over basic window management features like expose and minimisation? I would think not.
06:15:39 <nominolo|msr> @seen waern
06:15:40 <lambdabot> I saw waern leaving #haskell, #haskell.se and #ghc 12d 15h 46m 13s ago, and .
06:15:42 <quicksilver> depends what kind of xmonad port you're after :)
06:16:21 <Cthulhon> There's an app called SIMBL that lets you inject code into every Cocoa app to override Cocoa defaults.
06:16:46 <Cthulhon> It could do much for Expose/Spaces, but nyou could hyandle hotkeys/decoration.
06:16:51 <Cthulhon> *couldn't
06:17:54 <Cthulhon> The well documented Cocoa classes make the necessary reverse engineering not that hard.
06:18:39 <Cthulhon> If OSX respects LD_PRELOAD, you could probably integrate it with a pretty tiny shared library.
06:20:11 <dmwit> ox
06:20:19 <dmwit> double ack
06:20:31 <quicksilver> it certainly respects "something like" LD_PRELOAD
06:20:34 <quicksilver> different name, I think.
06:21:04 <Cthulhon> The biggest issue is that not everything is Cocoa.
06:21:22 <Cthulhon> FF2 wasn't, and I'm sure there's more.
06:21:48 <Cthulhon> But it would work for 90% of apps.
06:21:52 <Philippa_> cross-platform stuff won't be Cocoa, generally
06:22:14 <Cthulhon> Some is, some isn't.
06:22:33 <Cthulhon> VLC has a very nice Cocoa interface, for example.
06:23:12 <mc__> finder is Carbon
06:23:20 <Cthulhon> I'm not sure to what degree Apple's JVM plays nice with Cocoa.
06:23:30 <BeelsebobWork> I wouldn't call VLC's interface nice in any way shape or form
06:23:46 <Cthulhon> Well, that's fair.
06:23:49 <BeelsebobWork> it's so bad in fact that most people go "uh, wut" when I say "hey, you know you can encode video with that?"
06:23:58 <Cthulhon> But it has a developed Cocoa interface.
06:24:28 <BeelsebobWork> yep
06:24:32 <BeelsebobWork> and it's a lot better than firefox
06:24:41 <Cthulhon> I assume Carbon is documented well enough to be able to patch that too.
06:25:03 <Cthulhon> But cross-platform toolkits are tricky.
06:25:04 <BeelsebobWork> it's amazing how much difference it makes that firefox doesn't have features like the OS's built in spell checking
06:26:38 <dons> ?yow
06:26:39 <lambdabot> Can you MAIL a BEAN CAKE?
06:27:11 <dmead> ?yow
06:27:12 <lambdabot> FEELINGS are cascading over me!!!
06:27:40 <pizza___> sorry, i spilled those
06:31:26 <mdlavin> Hi.  I'm fairly new to haskell, and I've got a question about parsing large files with Parsec
06:31:58 <mdlavin> Anybody around to help?
06:31:59 <yitz> lispy: anyway, xmonad doesn't really fit in with the whole mac philosophy. So I think a lot of things probably wouldn't work the way you would expect.
06:32:50 <yitz> mdlavin: I'm interested in hearing the responses you get to this.
06:33:16 <BeelsebobWork> mdlavin: don't do it :D
06:33:26 <BeelsebobWork> that's about the extent of my help with parsec/large files
06:33:45 <BeelsebobWork> I usually write a parsec parser and go "shit, this is really slow" and rewrite it manually
06:33:58 <quicksilver> mdlavin: how large? 100k or 100M?
06:34:28 <yitz> Cthulhon: Apple's jvm is such an integral part of their monolithic platform, I would be very surprised if it isn't integrated with Cocoa at least in some sense.
06:34:56 <BeelsebobWork> yitz: uh?
06:34:57 <mdlavin> closer to 85M.  The file is composed of various elements one after another... so it seems like it should be possible to tell Parsec "give me the next element, ... now give me the next", but I can figure out how to do that
06:35:01 <dons> mdlavin: ask your question!
06:35:02 <Cthulhon> Yeah, but it's a question oif how integrated it is at a binary level.
06:35:07 <BeelsebobWork> apple's JVM is sun's jvm with a prettier UI
06:35:11 <Cthulhon> *of
06:35:14 <BeelsebobWork> (and not much prettier at that)
06:35:44 <yitz> BeelsebobWork: "prettier UI" means integrated with the platform, no? or it's just cosmetic emulation?
06:35:45 <Cthulhon> That is, would the same binary patches work for the JVM process.
06:36:14 <quicksilver> BeelsebobWork: I don't think that is true.
06:36:26 <quicksilver> BeelsebobWork: I think apple's JVM is an entirely separately developed VM.
06:36:28 <BeelsebobWork> yitz: it's just cosmetic emulation
06:36:29 <mdlavin> I guess my question would be, "is it possible to have Parsec parse one part, let me process that, and then continue parsing when I ask for the next part later?"
06:36:33 <quicksilver> it certainly always was.
06:36:50 <Cthulhon> It is a completely alternate implementation.
06:37:37 <Cthulhon> But that may mean it still has to implement Swing and all the UI L&F kludges that implies.
06:37:49 <BeelsebobWork> quicksilver: when you go to download sun's jvm from sun you get prompted with a screen saying "just get it from software update already"
06:38:09 <yitz> the mac is the only platform for which you can't download the latest jvm from Sun - making Java apps that require a newer version than Apple has provided incompatible. So much for "write once, run everywhere".
06:38:59 <ilyak> yitz: Well, what's the last jvm version for mac os x?
06:39:25 <quicksilver> Unless it's changed recently
06:39:27 <Cthulhon> 1.6.0_07 or something.
06:39:33 <BeelsebobWork> 1.6.0_05
06:39:33 <quicksilver> (which is possible, because I stopped following things)
06:39:35 <ilyak> Oh, it's pretty recent isn't it?
06:39:40 * rog has sent the compiler into an infinite loop. darn.
06:39:40 <quicksilver> it was because sun stopped writing JVMs for the mac
06:39:50 <quicksilver> so apple was forced to write their own.
06:39:51 <yitz> ilyak right now on tiger it's 1.5.0_16
06:40:07 <ilyak> yitz: Well, it's still usable, most apps target 1.5 nowdays
06:40:10 <Cthulhon> I'm pretty sure I saw an _07 on my MBP's Software Update.
06:40:15 <quicksilver> a *long* time ago. System 8, or something?
06:40:20 <Cthulhon> And that's Tiger.
06:40:22 <quicksilver> apple started writing their own Java VM.
06:40:25 <BeelsebobWork> Cthulhon: http://developer.apple.com/java/
06:40:25 <lambdabot> Title: Java
06:40:26 <ilyak> sun can't make a jvm for every platform
06:40:30 <dmwit> rog: You must be using some wacky extensions.
06:40:39 <BeelsebobWork> 1.6.0_05, but you need an intel 64 bit mac
06:40:41 <rog> what language extensions mean that GHC might loop forever?
06:40:45 <ilyak> quicksilver: I guess, rather, apple gets source from sun, patches it and distributes the result
06:40:50 <yitz> ilyak: at work our central tool is dita-ot. and that doesn't run on my mac. very perturbing.
06:40:54 <opqdonut> rog: fundeps might be enough
06:40:58 <rog> dmwit: well, i'm just using the extensions that are mandated by HList!
06:41:03 <opqdonut> type families certainly
06:41:10 <quicksilver> ilyak: PPC was an entirely apple production.
06:41:12 <ilyak> yitz: Rebuild it on 1.5?
06:41:18 <rog> shit
06:41:24 <quicksilver> however from that apple page
06:41:25 <ilyak> quicksilver: Even class libs?
06:41:30 <quicksilver> ilyak: no, of course not.
06:41:31 <rog> excuse my french
06:41:35 <quicksilver> ilyak: I'm talking about the JVM, not the library :)
06:41:53 <quicksilver> but from that apple apple page BeelsebobWork links
06:41:56 <ilyak> So, the acuaal vm
06:41:58 <ilyak> actual
06:41:58 <quicksilver> they clearly mention hotspot
06:42:15 <quicksilver> so I'm guessing they kissed and made up with sun when they switched back to intel.
06:42:16 <yitz> ilyak: maybe. probably not worth the time and effort.
06:42:35 <ilyak> yitz: Well, why? rebuilding java apps is trivial
06:42:55 <BeelsebobWork> quicksilver: I think basically apple doesn't give a shit about java
06:42:56 <yitz> ilyak: it's an idea, maybe I'll try it
06:43:03 <rog> any tips for debugging this kind of thing? it happened when i removed a declaration (because it was giving an error)
06:43:17 <Cthulhon> They don't anymore.
06:43:42 <quicksilver> BeelsebobWork: they did for a while.
06:43:43 <Cthulhon> They did for awhile in the first few versions of OSX.
06:43:53 <BeelsebobWork> yep, but not any more
06:43:55 <quicksilver> BeelsebobWork: they don't any more since it seems increasingly irrelevant, I guess.
06:44:18 <ilyak> quicksilver: java is very relevant (what else?), but not on desktop
06:44:31 <Cthulhon> It's only relevant for 'enterprise' stuff, at least.
06:44:35 <quicksilver> ilyak: right, but the context here is desktop, I guess.
06:44:40 <ilyak> So, a lot of internal desktop apps are java, so they need them if they ever want to go enterprise
06:44:53 <quicksilver> enterprise java runs fine on apple servers
06:44:58 <quicksilver> cos that doesn't use any custom toolkits
06:45:04 <quicksilver> it's just like java running on *BSD
06:45:04 <yitz> mdlavin: traditionally, parsec was strict, so it read the entire file into memory. that was intentional for speed, but with obvious drawbacks. I thought that newer versions have a lazy option, but I guess I'm wrong because no one seems to have said that.
06:45:10 <quicksilver> (or indeed linux or solaris)
06:45:15 <rog> it seems to be hanging inside ByteCodeGen
06:45:16 <Saizan> rog: you removed it from an HList module?
06:45:27 <rog> Saizan: no. from one of my own functions.
06:45:38 <ilyak> quicksilver: Well, which java apps do use custom toolkits? Not counting SWT
06:45:42 <tromp_> g'morning folks
06:45:48 <ilyak> Because you shouldn't really, or else it's not java anymore, really
06:45:57 <rog> (at least, ByteCodeGen is the last thing printed when i :set -v and then load
06:46:34 <quicksilver> ilyak: I don't think I said that very well.
06:46:39 <ilyak> Any meaningful java app should still run on java 1.5 with no mandatory native libs
06:46:53 <quicksilver> ilyak: my point is, the "hard" part of getting java running on another OS is the integration with the native GUI layer.
06:46:56 * rog thinks that combining HLists with Data.Accessor isn't perhaps a very good idea.
06:47:10 <quicksilver> ilyak: that's the bit that apple spent ages and ages working on and it was always a bit clunky.
06:47:13 <BeelsebobWork> quicksilver: but I don't think any OS does that
06:47:21 <BeelsebobWork> OS X kinda does it... really badly
06:47:24 <yitz> hi tromp_
06:47:27 <ilyak> quicksilver: If you're using swing, it's pretty impossible
06:47:29 <BeelsebobWork> windows just gives up and uses sun's UI
06:47:38 <quicksilver> ilyak: however, that's mostly irrelevant to the enterprise
06:47:39 <ilyak> If you're using SWT, it will look osx but not always feel osx
06:47:41 <mapreduce> Hmm, this stuff isn't true.
06:47:50 <ilyak> sure, they don't care about clunkinness
06:48:00 <quicksilver> ilyak: because the enterprise stack isn't about integrating with native gui, it's about databases and networks and sockets
06:48:07 <mapreduce> Swing has a fairly good Windows look and feel, but it's not the default.  Metal is.
06:48:07 <quicksilver> and at that level, OSX is just another unix
06:48:11 <quicksilver> so it's all pretty easy.
06:48:36 <quicksilver> So the hard challenges in porting java to the mac are not relevant to the enterprise, particularly.
06:48:40 <quicksilver> that's all I was trying to say.
06:48:46 <ilyak> quicksilver: Sure, but enterprises also do use some java gui internal apps
06:48:49 <ilyak> generally
06:48:49 <quicksilver> L'n'F isn't the point, either.
06:49:02 <yitz> quicksilver: on the mac it always is
06:49:06 <quicksilver> you still need to integrate the OS's windowing toolkit and event pump.
06:49:10 <quicksilver> that's the hard bit.
06:49:12 <BeelsebobWork> personally, I find it completely pointless to try and write GUI apps in cross platform APIs anyway
06:49:14 <quicksilver> yitz: it's not *my* point.
06:49:19 <quicksilver> yitz: it's not what I"m trying to say.
06:49:20 <yitz> ok fair enough
06:49:21 <ilyak> BeelsebobWork: Qt is very cool
06:49:29 <ilyak> BeelsebobWork: and it will get you a good app
06:49:33 <BeelsebobWork> ilyak: but doesn't feel anything like an OS X app when running on OS X
06:49:35 <mapreduce> BeelsebobWork: My program works on OS X.  I have never seen it running on OS X.
06:50:01 <BeelsebobWork> mapreduce: yes, and I bet that OS X users see it, try it, go "ewwwwwwww", and use something else instead
06:50:01 <ilyak> BeelsebobWork: Well, poor os x, but anyway
06:50:03 <mapreduce> Unless I personally have access to all the supported platforms, I'd like cross-platform GUIs.
06:50:04 <ilyak> Qt is fine
06:50:12 <mapreduce> BeelsebobWork: They don't have much choice.
06:50:29 <yitz> supposedly gtk2 has a new osx l&f that is nice. I haven't seen it though
06:50:31 <BeelsebobWork> I'm not saying that it's a bad thing to write a cross platform UI as a fall back
06:50:44 <yitz> or I have seen it and didn't even notice, in which case it is excellent.
06:50:52 <BeelsebobWork> but the GUI layer should be sufficiently abstracted that you can plug on a *real* UI when you actually have the relevant toolkit available
06:51:13 <BeelsebobWork> yitz: it's used by GIMP and OOo 3
06:51:17 <BeelsebobWork> it's very noticable
06:51:19 <ilyak> BeelsebobWork: SWT tries to do that
06:51:25 <BeelsebobWork> but it's a lot better than them running in X11
06:51:28 <quicksilver> genuinely cross-platform GUI is a hard challenge
06:51:30 <mapreduce> Swing uses Windows' native drawing on Windows.
06:51:33 <quicksilver> and I personally no longer care about it.
06:51:36 <mapreduce> It didn't some years ago.
06:51:41 <quicksilver> I just don't find it an interesting challenge any more.
06:51:42 <LynxAba> hello everybody, is there any way to put the "_" symbol inside a logical expression of a function? say:
06:51:42 <LynxAba> foo :: (Int,Int) -> Int
06:51:46 <LynxAba> then
06:51:47 <opqdonut> I no longer care about GUI
06:51:49 <mapreduce> SWT seems misguided; it should have been a Swing look and feel.
06:51:59 <yitz> BeelsebobWork: I'm using neoOffice.
06:52:09 <quicksilver> I value X-platform much higher than "nice native L'n'F on OSX"
06:52:18 <BeelsebobWork> yitz: try the new OpenOffice
06:52:24 <BeelsebobWork> it's quite a lot better than neoOffice
06:52:24 <quicksilver> I use OSX and the only apps I ever use are iTerm, FireFox and emacs :)
06:52:38 <BeelsebobWork> quicksilver: ewwww, iTerm :P
06:52:40 <opqdonut> quicksilver: ditto but linux, aterm, opera and emacs
06:52:41 <yitz> BeelsebobWork: as for gimp - it's been waiting for a macports upgrade for a long time, I haven't had the time to let it compile.
06:52:46 <BeelsebobWork> (also, ewww FF and ewww emacs)
06:53:16 <yitz> iTerm is fine - better than Terminal.
06:53:18 <dmwit> ewww software
06:53:48 <yitz> Firefox is good for some sites that don't properly support Safari - but I use Camino for that.
06:54:01 <BeelsebobWork> yitz: I find Terminal.app quite a lot better than iTerm since leopard
06:54:15 <yitz> BeelsebobWork: could be. I'm still on tiger.
06:54:23 <BeelsebobWork> yeh, fair enough then
06:55:21 <yitz> I've been using Aquaemacs - even though quicksilver doesn't like it. I changed a few settings to make it more normal, and it's fine.
06:55:36 <LynxAba> then: foo x | x == (5,_) = 0
06:55:36 <LynxAba>                   | x == (_,5) = 1
06:56:03 <opqdonut> LynxAba: use "case x of (5,_) -> ..."
06:56:23 <yitz> LynxAba: or foo (5,_) = 0; foo (_,5) = 1
06:56:23 <Deewiant> how about "foo (5,_) = 0"
06:56:32 <quicksilver> ! ignoring quicksilver's advice? Whatever next? ;)
06:56:40 <opqdonut> Deewiant: i think the example was purposefully simplified
06:56:45 <BeelsebobWork> > fmap (const 2) undefined :: (Int,Int)
06:56:46 <lambdabot>   * Exception: Prelude.undefined
06:56:59 <yitz> heaven knows to what depths we can descend
06:57:22 <LynxAba> > 2+2
06:57:23 <lambdabot>   4
06:57:39 <BeelsebobWork> > second (const 2) undefined :: (Int,Int)
06:57:41 <lambdabot>   (* Exception: Prelude.undefined
06:58:50 <yitz> > (const 2 *** const 3) undefined :: (Int, Int)
06:58:52 <lambdabot>   (2,3)
06:59:14 <opqdonut>    
06:59:17 <opqdonut> sry
06:59:19 <opqdonut> lag
07:01:35 <yitz> BeelsebobWork: how is raw OOo better than NeoOffice? I thought their code bases are converging as mac integration gets merged into the OOo trunk.
07:01:36 <Saizan> fmap is strict? booo
07:02:08 <idnar> it is?
07:02:11 <therp> any ideas for a simple hash (on Strings) that is probably better than the sum of multiplied with k values mod p, where k and p are relative prime..
07:02:33 <yitz> @src (->) fmap
07:02:33 <lambdabot> fmap = (.)
07:02:57 <rog> actually, the compiler hangup happens when i *add* a declaration...
07:03:25 <yitz> @src Control.Monad.Writer fmap
07:03:25 <lambdabot> Source not found. My pet ferret can type better than you!
07:03:34 <yitz> @src Writer fmap
07:03:34 <lambdabot> Source not found.
07:03:53 <lilac> can anyone help me with this error from cabal install: http://hpaste.org/11417 ?
07:03:55 <Cthulhon> : (***)
07:03:58 <Cthulhon> Er.
07:04:02 <Cthulhon> :t (***)
07:04:03 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
07:04:47 <yitz> therp: what's wrong with that hash?
07:04:48 <mib_1ycpa4j2> hello
07:05:18 <yitz> hello mib_1ycpa4j2
07:05:28 <opqdonut> therp: check TAOCP
07:05:28 <opqdonut> ;)
07:06:29 <yitz> opqdonut: or check Applied Cryptography
07:06:41 <mattam> Is it right that the catamorphism for Maybe is [cata e f Nothing = e ; cata e f (Just x) = f x]?
07:07:10 <mib_1ycpa4j2> I am trying to sort a string, eg "I need to go and wash the car in Spain.", I need to turn it into lowercase (ive done that), need to remove punctuation which I am getting stuck on
07:07:35 <mib_1ycpa4j2> to get it into lower case i did:
07:08:05 <yitz> > filter (not . isAlpha) "I need to go and wash the car in Spain."
07:08:06 <lambdabot>   "         ."
07:08:17 <yitz> > filter (isAlpha) "I need to go and wash the car in Spain."
07:08:18 <lambdabot>   "IneedtogoandwashthecarinSpain"
07:08:49 <lispy> ?users
07:08:49 <lambdabot> Maximum users seen in #haskell: 547, currently: 513 (93.8%), active: 26 (5.1%)
07:08:54 <yitz> > filter (\c -> isAlpha c || isSpace c) "I need to go and wash the car in Spain."
07:08:55 <lambdabot>   "I need to go and wash the car in Spain"
07:09:16 <mib_1ycpa4j2> i used this to get it into lower case:
07:09:20 <dons> ?users
07:09:20 <lambdabot> Maximum users seen in #haskell: 547, currently: 513 (93.8%), active: 25 (4.9%)
07:09:22 <dons> uptime
07:09:24 <mib_1ycpa4j2> import Char  lowercase :: String -> String lowercase = map toLower
07:09:24 <dons> ?uptime
07:09:25 <lambdabot> uptime: 4d 23h 43m 40s, longest uptime: 1m 10d 23h 44m 29s
07:09:57 <lispy> mib_1ycpa4j2: yea, that looks right
07:10:00 <yitz> mib_1ycpa4j2: sounds good
07:10:00 <lilac> > filter (liftA2 (||) isAlpha isSpace) . map toLower $ "I need to go and wash the car in Spain."
07:10:02 <lambdabot>   "i need to go and wash the car in spain"
07:10:07 <mib_1ycpa4j2> how could i remove punctuation from a string i inout?
07:10:22 <mib_1ycpa4j2> *input
07:10:31 <mib_1ycpa4j2> sorry i know this prob basic
07:10:44 <yitz> mib_1ycpa4j2: filter removes things
07:11:21 <yitz> mib_1ycpa4j2: are you sorting letters, words, or what?
07:11:36 <lispy> > filter (\x -> not (x `elem` ".?!@#$%^&*")) "You can remove punctuation if you want!  See?  Like that."
07:11:38 <lambdabot>   "You can remove punctuation if you want  See  Like that"
07:11:49 <EnderMB> If I paste something in the pastebin how long will it stay for and will it be crawled by Google?
07:12:11 <lispy> EnderMB: for ever, I think and I'm not sure but I think google crawls it
07:12:35 <mib_1ycpa4j2> i am sorting eg "I need to go and wash the car in Spain." to lowercase, remove punctuation and then need to order it alphabetically
07:13:03 <quicksilver> EnderMB: hpaste stays for ever and gets google crawled.
07:13:05 <yitz> mib_1ycpa4j2: what should the result look like, exactly?
07:13:33 <mib_1ycpa4j2> it would be a list of the input words like this:
07:13:38 <mib_1ycpa4j2> and *
07:13:44 <mib_1ycpa4j2> car*
07:13:50 <EnderMB> Hmm, I was thinking of getting a similar pastebin, but was worried about other peoples' code getting crawled
07:13:56 <quicksilver> EnderMB: somee other pastebins don't.
07:14:19 <BeelsebobWork> yitz: no, OOo is using GTK's native OS X interface stuff
07:14:23 <yitz> mib_1ycpa4j2: so you are sorting words
07:14:29 <lispy> > unwords . sort . words . filter (\x -> not (x `elem` ".?!@#$%^&*")) $ "You can remove punctuation if you want!  See?  Like that." -- I hope I didn't jsut do your homework
07:14:30 <BeelsebobWork> not neoOffice's java stuff
07:14:31 <lambdabot>   "Like See You can if punctuation remove that want you"
07:14:50 <mib_1ycpa4j2> yea from the string i input
07:14:50 <yitz> BeelsebobWork: oh, ok. so it's faster, is that it?
07:15:03 <BeelsebobWork> yitz: and interacts better with the rest of the OS
07:15:20 <lilac> is it possible to upgrade ghc using cabal-install?
07:15:24 <EnderMB> I'll probably look at the scripts the other channels use to see if they'll be better suited for me
07:15:27 <EnderMB> Thanks for the help
07:15:35 <therp> yitz: I'm using it to generate HSL colors, and they doesn't look that much different.. probably I should blame HSL.
07:16:09 <mib_1ycpa4j2> no no, you didnt yitz, but thanks, just trting to implement it into a defintion
07:16:56 <yitz> lispy, mib_1ycpa4j2: if it's by words, then you don't need an explicit list of punctuation. The spaces will be gone, so it's just not . isAlpha.
07:17:26 <lispy> > isAlpha '1
07:17:26 <lambdabot>   <no location info>:
07:17:26 <lambdabot>      lexical error in string/character literal at chara...
07:17:27 <lispy> > isAlpha '1'
07:17:29 <lambdabot>   False
07:17:34 <yitz> oh
07:17:53 <yitz> mib_1ycpa4j2: could there be digits in the strings?
07:18:22 <mib_1ycpa4j2> Erm I dont think so, just words i think
07:18:40 <yitz> BeelsebobWork: but isn't the whole point of NeoOffice to interact better with the OS?
07:18:54 <BeelsebobWork> yitz: yes, but it doesn't do a very good job of it
07:18:55 <mib_1ycpa4j2> its my first coursework assignment at uni, but finding it hard getting what i want if that makes sense
07:19:01 <BeelsebobWork> so the OOo team fixed it
07:19:14 <BeelsebobWork> NeoOffice is pretty much redundant since v3 of OOo
07:19:45 <yitz> BeelsebobWork: ok, I'll try it. (but remember I'm on tiger :) )
07:20:51 * rog wishes there was some way to get the ghc error messages as a data structure, so he could write a program to manipulate them into a more readable form.
07:21:20 <yitz> rog: write a parser for HList errors. sounds like a useful tool.
07:22:12 <mib_1ycpa4j2> hmm cant seem to get filter (\x -> not (x `elem` ".?!@#$%^&*"))  to work in my definiton, im getting Syntax error in input (unexpected backslash (lambda))
07:22:56 <lilac> mib_1ycpa4j2: can you provide more context? maybe hpaste?
07:23:06 <dmead> i think you need to scape that string brah
07:23:08 <yitz> @hpaste
07:23:08 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:23:56 <mib_1ycpa4j2> ok sorry this is all new to me
07:24:04 <rog> yitz: i wonder if there's something more general in there trying to get out. after all, the compiler has the types in data structures already - maybe i could make it possible to add a post-processor for printed types.
07:24:46 <mib_1ycpa4j2> http://hpaste.org/11418
07:25:00 <rog> yitz: writing a parser seems like coming at it the wrong way. after all, the form of the error messages could change on any compiler release.
07:25:09 <yitz> rog: perhaps there's a useful hook in the ghc api.
07:25:44 <rog> yitz: yes, perhaps. more "to do"s...
07:28:22 <yitz> mib_1ycpa4j2: so far so good. now make that a function of type String -> String that removes punctuation.
07:28:35 <luite> is it possible to get a command history (up arrow in normale ghci sessions) in ghci running in emacs haskell-mode? the normal up arrow just moves the cursor up
07:28:43 <yitz> mib_1ycpa4j2: you don't need lengthcase. Because:
07:28:48 <yitz> @type length
07:28:49 <lambdabot> forall a. [a] -> Int
07:29:10 <mib_1ycpa4j2> yea was trying things about hehe
07:29:18 <yitz> and a String is actually a list - it's an alias for [Char].
07:29:33 <Ornedan> luite: Ctrl + up works for me
07:29:54 <luite> ah yes, that's it, thanks
07:31:49 <swiert> @seen edwinb
07:31:49 <lambdabot> edwinb is in #haskell. I don't know when edwinb last spoke.
07:32:26 <mib_1ycpa4j2> yitz would it look like this: http://hpaste.org/11419
07:32:29 <yitz> mib_1ycpa4j2: is "import Char" what they told you to use in your course? Nowadays most people use "import Data.Char", but perhaps you are expected to use that old way?
07:32:58 <yitz> mib_1ycpa4j2: I'll bet that will work.
07:33:46 <BeelsebobWork> mib_1ycpa4j2: I'd write removePunc as filter (not . (`elem` ".?!@#$%^&*"))
07:35:33 <mib_1ycpa4j2> hmm, im getting ERROR - Undefined variable "removePunc"
07:36:11 <mib_1ycpa4j2> for this http://hpaste.org/11420
07:36:14 <yitz> mib_1ycpa4j2: did you write it with P or p
07:37:02 <mib_1ycpa4j2> like this: removePunc "I need to go and wash the car in Spain."
07:37:06 <yitz> mib_1ycpa4j2: when you are pasting a new version of the same thing in hpaste, you can use the "annotate" button instead of a whole new paste page.
07:37:46 <mib_1ycpa4j2> oh ok lol, sorry m8
07:38:07 <yitz> mib_1ycpa4j2: hmm. did you do a reload?
07:38:22 <edwinb> swiert: arrr
07:39:01 <tromp_> latest version of my Go rules program at http://www.cwi.nl/~tromp/go/Go.hs
07:39:05 <mib_1ycpa4j2> i had to reboot winhugs, that was strange
07:39:11 <tromp_> any suggestions for improvement welcome
07:39:22 <swiert> edwinb: Hiya! I was just thinking I hadn't seen you in a while.
07:39:27 <vegai> could haskell-hint be fixed for ghc-6.10? It seems to be one of the few last things that block lambdabot
07:39:29 <swiert> edwinb: Any news on the job hunt?
07:39:38 <yitz> mib_1ycpa4j2: try :reload in hugs
07:40:10 <edwinb> swiert: I'm teaching until May. What fun.
07:40:27 <edwinb> Our network proposal didn't get funded though :(.
07:40:28 <swiert> edwinb: How about your EPSRC grant?
07:40:37 <swiert> edwinb: Gosh, that's a shame!
07:40:38 <edwinb> We got good reviews so we're going to try it again with a few tweaks, in a few months.
07:40:49 <edwinb> at least I have time now ;)
07:40:53 <swiert> edwinb: I thought it looked quite promising.
07:41:03 <edwinb> did you have any progress on what's happening next?
07:41:15 <mib_1ycpa4j2> yitz i changed a few things and it works http://hpaste.org/11420#a1
07:41:16 <edwinb> yeah, the reviewers said, "This looks cool. We want this yesterday."
07:41:21 <edwinb> but the panel obviously didn't see it that way
07:42:14 <swiert> edwinb: too bad.
07:42:28 <yitz> mib_1ycpa4j2: cool
07:43:29 <lispy> swiert: oh, hi!
07:43:35 <yitz> @users
07:43:35 <lambdabot> Maximum users seen in #haskell: 547, currently: 515 (94.1%), active: 19 (3.7%)
07:43:53 <lispy> swiert: not sure if you know who I am...I'm the guy that's working on darcs...I did the monad reader article
07:43:58 <mib_1ycpa4j2> hmm, now i need to sort the words alphabetically, would a simple sort do that? or will i need to run it like unwords . sort . words to process the whole string?
07:44:10 <swiert> lispy: sure. hiya.
07:44:12 <medfly> take 1
07:44:15 <lispy> swiert: do you have an interest (or time/resources) in trying to make the patch theory more formal?
07:44:19 <medfly> > take 1 "pie"
07:44:21 <lambdabot>   "p"
07:44:28 <swiert> lispy: not at the moment I'm afraid.
07:44:39 <swiert> lispy: I'm making a push to finish my thesis.
07:44:41 <yitz> mib_1ycpa4j2: yep. do you need the unwords, or would just a list of sorted words be good enough?
07:44:59 <swiert> lispy: Once I get that out of the way (a few weeks) I should have more time.
07:44:59 <lispy> swiert: heh, I know the feeling...I'm writing mine at the moment
07:45:04 <lispy> kk
07:45:37 <yitz> mib_1ycpa4j2: got to go for a few minutes.
07:45:54 <mib_1ycpa4j2> yitz: as long as there sorted alphabetically i think its sufficant
07:46:02 <mib_1ycpa4j2> ok cool o/
07:46:31 <swiert> lispy: It's a shame we never resubmitted our paper somewhere - I'd like to tinker with the ideas there a bit more, but it's not very high on my list of priorities atm.
07:47:16 <lispy> swiert: yeah.  That paper had an interesting start.  And I wish I could reference it in my thesis :)
07:47:49 <lispy> I plan to read it again more carefully after I graduate to see how it fits my current, greatly improved, understanding of darcs
07:48:20 <swiert> lispy: cool. I'd be interested to hear your thoughts.
07:48:36 <DustyDingo> hm, how can i match agains a non empty list?
07:48:53 <RayNbow> use (x:xs)?
07:48:58 <lilac> DustyDingo: xs@(_:_)
07:49:06 <RayNbow> or what lilac says
07:49:34 <DustyDingo> lilac: thx
07:51:07 <mib_1ycpa4j2> is there a way to save this tab? like if i left and logged back on it would still be here?
07:53:02 <lilac> mib_1ycpa4j2: logs at http://tunes.org/~nef/logs/haskell/
07:53:05 <lambdabot> Title: Index of /~nef/logs/haskell
07:54:29 <mib_1ycpa4j2> THANKS DUDES, CYA O/
07:56:50 * rog doesn't quite understand how he can have an apparently correctly initialised record instance r, and still have ":type memberfn r" fail.
07:59:19 <quicksilver> "fail" in what way, rog?
07:59:38 <rog> quicksilver: "No instances for ..."
08:00:05 <quicksilver> could it be polymorphic
08:00:14 <quicksilver> and there is some instance but it needs a type annotation to find it?
08:00:24 <rog> could what be polymorphic?
08:00:25 <quicksilver> that kind of circumstance arises quite often in HList code I believe.
08:00:33 <quicksilver> "memberfn r" be polymorphic
08:01:28 <rog> oh yes, memberfn r is definitely polymorphic. but :type r is fine. and surely the very definition of a member function ensures that its return type is known with respect to the type of the record?
08:01:52 <pjdelport> this question is a bit random, but is there a canonical metacircular Haskell implementation?
08:02:00 <pjdelport> (for educational purposes)
08:02:51 <quicksilver> pjdelport: ghci, but it's not really metacircular in the full sense.
08:03:35 <quicksilver> rog: well, what I'm saying is that the missing instance exists but unification on the general types of "memberfn" and "r" doesn't pin the type tightly enough to find the instance.
08:03:41 <pjdelport> quicksilver: oh?
08:04:09 <quicksilver> rog: I'm afraid I can't construct an example myself, because I don't have enough experience with these tricks.
08:04:09 <EvilTerran> pjdelport, well, ghc is mostly written in haskell, but it has a few non-haskell bits
08:04:11 * pjdelport assumed ghci was more tied to ghc
08:04:23 <quicksilver> pjdelport: ghci contains a full interpreter, but doesn't make the interpreter available to interpreted code
08:04:35 <quicksilver> there is no architectural reason why it couldn't
08:04:36 <quicksilver> but it doesn't.
08:04:54 <quicksilver> so you can't quite circle the whole meta :)
08:04:55 <roconnor> Should my module be called Data.Colour.Names or Data.Colour.Name ?
08:05:09 <EvilTerran> roconnor, what does it define?
08:05:13 <pjdelport> quicksilver: how simple / self-contained is ghci?
08:05:25 <rog> quicksilver: ... and i've got an example, but just the description of the instances required is 58 lines long :-)
08:06:31 <tromp_> quicksilver: have you looked at the new Go code with parametrized boards?
08:07:09 <roconnor> EvilTerran: http://hackage.haskell.org/packages/archive/colour/0.0.0/doc/html/Data-Colour-Names.html
08:07:15 <lambdabot> Title: Data.Colour.Names, http://tinyurl.com/5ahaq9
08:07:28 <roconnor> EvilTerran: it defines a bunch of colours by name
08:07:39 <pjdelport> quicksilver: doesn't it compile to bytecode?
08:07:56 <roconnor> Data.Colour.Name.aqua or Data.Colour.Names.aqua
08:08:30 <pjdelport> i was thinking more of something in the tradition of metacircular lisp / scheme interpreters
08:15:15 <quicksilver> pjdelport: I don't think compilation to bytecode is incompatible with being metacircular.
08:15:29 <quicksilver> pjdelport: after all, a lisp interpreter might use a bytecode form internally
08:15:34 <quicksilver> (you really can't tell, can you?)
08:15:50 <quicksilver> but the critical part is that GHCi doesn't expose its own interpretation module to its hosted code.
08:15:58 <quicksilver> However, it certainly *could* do that. It just doesn't.
08:16:20 <pjdelport> quicksilver: well, i actually mean metacircular in its proper sense, not just self-hosting
08:16:37 <quicksilver> wikiP claims "Meta-circular evaluation is only possible in homoiconic languages."
08:16:41 <quicksilver> I'm not sure if I agree with that.
08:16:48 <quicksilver> obviously haskell isn't homoiconic.
08:16:51 <pjdelport> yes, that isn't correct
08:17:01 <pjdelport> s/possible/easy/
08:17:08 <quicksilver> pjdelport: perhaps you'd care to define what you mean by metacircular?
08:17:14 <quicksilver> and I'll try to give you a better answer.
08:17:26 <pjdelport> quicksilver: implementing the language in terms of itself
08:17:51 <pjdelport> (not just in itself)
08:18:33 <quicksilver> pjdelport: OK, I don't think that's ever been done.
08:18:44 <quicksilver> pjdelport: but I claim that GHCi has done all the hard work required to make it possible.
08:18:55 <pjdelport> ghci looks a lot more extensive, though
08:19:03 <quicksilver> pjdelport: the "easy part" which remains is to actually write the eval loop, using ghci's internal API
08:19:20 * rog gives up for the night.
08:21:28 <pjdelport> i guess my question could be rephrased as, what's the smallest and simplest chunk of Haskell code that can run Haskell code
08:21:33 <pjdelport> or a meaningful subset, at least
08:22:06 <pjdelport> like in Scheme, you have your eval/apply loop
08:22:30 <quicksilver> pjdelport: I think ghci, believe it or not, is that smallest + simplest chunk ;)
08:22:45 <quicksilver> pjdelport: although obviously you could cut it down a bit.
08:22:45 <pjdelport> and a couple of helpers, and that's pretty much it
08:23:05 <quicksilver> the key point about ghci is that it is metacircular with its RTS
08:23:15 <quicksilver> I abuse terminology
08:23:23 <quicksilver> but ghci runs in the same RTS as the code it interprets
08:23:38 <quicksilver> that's a pretty important trick to get circularity going
08:24:59 <pjdelport> quicksilver: hmm, ok
08:25:04 <tromp_> pjdelport: i tried to answer that question for binary lambda calculus
08:25:17 <pjdelport> "binary" lambda calculus?
08:25:31 <tromp_> lc with a binary encoding of terms
08:31:04 <pjdelport> tromp_: what kind of encoding?
08:33:02 <tromp_> see my paper at http://homepages.cwi.nl/~tromp/cl/LC.pdf
08:33:04 <lambdabot> Title: Binary Lambda Calculus and Combinatory Logic
08:33:26 <tromp_> basically, unary encoding of de bruijn indices
08:41:25 <pjdelport> funky
08:41:57 * pjdelport wonders if some kind of arithmetic coding could be applied
08:50:40 <Baughn> pjdelport: Depends. Do you live in a country where software patents apply?
08:51:30 <idnar> haha
08:51:53 <pjdelport> Baughn: i don't think it matters much
08:52:17 <Baughn> pjdelport: But of course it does. You wouldn't wnat to break the law.
08:52:48 <pjdelport> any arithmetic coding patent meaningful enough to uphold would almost certainly be too specific to be a worry
08:53:06 <pjdelport> there are lots of ways to approach arithmetic coding
08:53:26 <Baughn> Hmm, true. Patent dodging by using haskell?
08:54:03 <pjdelport> maths
08:54:16 <pjdelport> can't patent fundamental maths
08:55:10 <geezusfreeek> *they* don't know that
08:55:38 <geezusfreeek> http://en.wikipedia.org/wiki/Illegal_prime
08:55:39 <lambdabot> Title: Illegal prime - Wikipedia, the free encyclopedia
08:56:01 <quicksilver> pjdelport: I've got news for you, in america, you can patent everything.
08:56:02 <geezusfreeek> ^ not about patents, but still applies i think
08:56:28 <pjdelport> quicksilver: not legally
08:56:30 <quicksilver> pjdelport: someone probably has a patent on at least one thing you do every five minutes. So, in the US, your life is illegal.
08:56:34 <pjdelport> i know in practice it might differ
08:56:40 <quicksilver> the law is what is enforced.
08:56:43 <pjdelport> but that's up to your court system
08:57:10 <pjdelport> quicksilver: well the law is pretty clear on what isn't patentable
08:57:13 <pjdelport> and it's generally reasonable
08:57:24 <pjdelport> the only problem is that that's what's not so well enforced
08:57:55 <Kamina> patent laws have been made in a world, which has already changed a lot, but the laws didn't change
08:58:02 <quicksilver> the letter of the law is clear. However "The Law" is, by definition, that which is enforced by the highest court in the land. :(
08:58:07 <quicksilver> still, this is pretty off-topic.
08:58:08 <Kamina> patent laws should be considered deprecated
08:58:51 <pjdelport> someone should define a Haskell DSL for describing patents, and a library suite that formally decides their patentability
08:59:29 <Kamina> pjdelport: law in real world is not logic, because it's not based on clear mathematical definitions
09:00:02 <pjdelport> Kamina: of course :)
09:00:06 <daf> clearly the patentability should be decided in the type system
09:00:55 <pjdelport> geezusfreeek: have you read this? http://ansuz.sooke.bc.ca/lawpoli/colour/2004061001.php
09:00:56 <lambdabot> Title: What Colour are your bits?
09:01:06 <pjdelport> (last aside)
09:01:38 <pjdelport> geezusfreeek: that's more or less about how something like illegal prime is treated under law
09:01:48 <pjdelport> short version is "it's the intent that matters, not the bits"
09:02:06 <pjdelport> so it's not the prime that matters, it's where you got the bits and what you intend to do with them
09:02:17 <lilac> is GHC 6.10.1 supposed to be compilable from GHC 6.6.1?
09:02:37 <Deewiant> even from 6.4, I think
09:02:59 <geezusfreeek> i have not read it, but it's bookmarked now
09:03:07 <lilac> Deewiant: that's what i thought. who should i be telling that it doesn't work?
09:03:24 <pjdelport> geezusfreeek: good essay
09:03:32 <quicksilver> I think they dropped 6.4, I think it has to be 6.6
09:03:37 <quicksilver> lilac: glasgow-haskell-users
09:03:39 <Deewiant> lilac: glasgow-haskell-users
09:03:46 <lilac> ta
09:05:36 <lilac> it's already reported: http://www.haskell.org/pipermail/glasgow-haskell-users/2008-October/015827.html
09:05:37 <lambdabot> Title: Building ghc-6.10 with ghc-6.6.1, http://tinyurl.com/6krzkz
09:07:05 <quicksilver> is Control.Exception.Extensible needed to compile 6.10 then?
09:07:14 <quicksilver> that's interesting
09:10:32 <hhiroavalon>  Hi, I would like to know the definition of foldr, since I want to use it in a mathematical induction...
09:10:47 <quicksilver> @src foldr
09:10:47 <lambdabot> foldr f z []     = z
09:10:47 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:12:18 <hhiroavalon> quicksilver: thanks, do you think it would be the same definition for a lambda function?
09:12:28 <quicksilver> hhiroavalon: what is a lambda function?
09:13:44 <hhiroavalon> it's like: "foldr (\n xs -> (f n):xs) []"
09:14:10 <quicksilver> hhiroavalon: the definition of foldr makes no different what parameters you pass it
09:14:15 <quicksilver> otherwise it would be a pretty stupid definition :P
09:16:03 <hhiroavalon> @src map
09:16:03 <lambdabot> map _ []     = []
09:16:04 <lambdabot> map f (x:xs) = f x : map f xs
09:18:29 <dancor> @src foldl
09:18:29 <lambdabot> foldl f z []     = z
09:18:29 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:19:26 <pjdelport> @pl (\n xs -> (f n):xs)
09:19:26 <lambdabot> (:) . f
09:19:31 <pjdelport> FWIW
09:20:03 <pjdelport> :t foldr (:) []
09:20:05 <lambdabot> forall a. [a] -> [a]
09:20:09 <yitz> @src foldl'
09:20:09 <lambdabot> foldl' f a []     = a
09:20:09 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
09:20:12 <quicksilver> pjdelport: possibly that's not worth much, to someone trying to prove the theorem I believe hhiroavalon is trying to prove :)
09:20:14 <pjdelport> :t \f -> foldr ((:) . f) []
09:20:15 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
09:20:24 <quicksilver> pjdelport: I think it just defers the proof to somwewhere else.
09:22:51 <quicksilver> pjdelport: that colour essay is one of the best I've read on digital copyright. Actually it may be the only good one :P
09:23:04 <pjdelport> yep
09:23:14 <pjdelport> nice to have some sanity to refer to
09:24:06 <hhiroavalon> quicksilver, pjdelport: well, yeah, still I have to understand the logic and everything before I can write it on the answer :)
09:24:23 <yitz> quicksilver, pjdelport: that color essay debunks certain silly misconceptions, but still begs the basic question.
09:25:40 <pjdelport> yitz: of copyright?
09:26:09 <quicksilver> yitz: I feel it explains the basic question very well.
09:26:16 <camio> Do people use '\RightArrow' to signify "evaluates to" in latex?
09:26:23 <quicksilver> yitz: it doesn't *answer* it because, well, it's not obvious it has an answer ;)
09:26:24 <yitz> of ownership of bits - or any other rights, such as copyright or patent or what have you
09:26:32 <quicksilver> camio: quite often, yes
09:26:41 <quicksilver> camio: although it's by no means the only notation I've seen
09:27:20 <yitz> quicksilver: there are several questions that could be asked. some of them could indeed have answers.
09:27:26 * quicksilver nods
09:27:34 <pjdelport> yitz: the whole point of the article is that it *isn't* ownership of bits
09:28:35 <pjdelport> but of intangible works, having some agreed meaning in society
09:29:44 <zachk> how evil am i if i write foldr foldl map and filter in java
09:29:56 <pjdelport> s/evil/masochistic/
09:30:23 <zachk> yea its a major pain in the arse because java lacks first class functions
09:30:25 <wjt> zachk: unoriginally :p
09:30:29 <yitz> pjdelport: no true - the point is that ownership is a kind of "metadata" that is independent of the property. so arguments about the nature of bits cannot be used to prove that ownership of them is intrinsically nonsensical, as many computer people would like to.
09:30:52 <badsheepy> where i have filter (\l -> (l `mod` x) /= 0) xs, is there some way of writing this in a nicer way (without the lambda or a where or let)
09:30:54 <yitz> but that doesn't mean that it's not nonsensical
09:31:05 <Deewiant> ?pl \l -> (l `mod` x) /= 0
09:31:05 <lambdabot> (0 /=) . (`mod` x)
09:31:31 <badsheepy> im not sure thats entirely nicer, but ty :)
09:31:42 <zachk> wjt: what im coding is unorignal? :-( that saddens me
09:31:49 <wjt> zachk: i'm sure it's been done :-)
09:32:23 <wjt> zachk: presumably interface F<a,b> { b call(a arg); } ?
09:33:05 <yitz> zachk: you can see the written in javascript at http://foldr.com and http://foldl.com
09:33:09 <lambdabot> Title: 9 foldr.com 20
09:35:27 <quicksilver> badsheepy: can you quantify what about that you think is not nice?
09:36:30 <Deewiant> points are never nice
09:37:20 <Kamina> does someone know how to convert a float to a double? or more generally how to convert a Floating value into a Double?
09:37:35 <ddarius> Hoogle does
09:37:38 <Deewiant> fromRational?
09:37:38 <quicksilver> Deewiant: I don't agree at all. I think points are an elegant way to convey certain things.
09:37:46 <quicksilver> @quote need
09:37:46 <lambdabot> mckinna says: you don't need to produce elements of an *arbitrary* whatever-it-is when you can produce elements of the *initial* whatever-it-is
09:37:55 <quicksilver> @quote Float
09:37:55 <lambdabot> jcreigh says: 99 times out of 100.0000000000000000032467823764876238476, you're better off without floats.
09:37:58 <quicksilver> damn!
09:38:00 <quicksilver> @quote need a
09:38:01 <lambdabot> No quotes for this person. I am sorry.
09:38:07 <Kamina> Deewiant: Couldn't match expected type `Rational' against inferred type `Float'
09:38:10 <quicksilver> Kamina: realToFrac
09:38:20 <Deewiant> right, that was it
09:38:27 <Deewiant> ?hoogle Floating a => a -> Double
09:38:27 <lambdabot> Prelude acos :: Floating a => a -> a
09:38:27 <lambdabot> Prelude acosh :: Floating a => a -> a
09:38:27 <lambdabot> Prelude asin :: Floating a => a -> a
09:38:36 <quicksilver> Deewiant: (\(_,_,c) -> c)
09:38:37 <yitz> pjdelport: ownership of physical chattels and real estate is not something that was decided upon by anyone, or forced upon anyone. It has been part of human culture for all of our recorded history. Ownership of "works" or "bits" or "business processes" was made up within the past few years by certain people who stand to profit by it. So it is not a good analogy at all.
09:38:49 <quicksilver> Deewiant: is, in my opinion, just about the most concise way to express that function.
09:38:59 <quicksilver> Deewiant: it's a good use of a point.
09:39:01 <Deewiant> quicksilver: pattern matching can't be done without points, what'cha gonna do? :-)
09:39:09 <Kamina> quicksilver: ah, as it's polymorphic it can return me any fractional type
09:39:11 <Kamina> quicksilver: thanks
09:39:15 <quicksilver> well you could, for example, call it "thd" or "thd3"
09:39:17 <quicksilver> Kamina: right.
09:39:27 <quicksilver> but I claim that rather than coming up with names for all tuple selectors
09:39:31 <quicksilver> lambda notation is actually nicer
09:39:39 <quicksilver> because it's obvious how to generalise it to other cases.
09:39:42 <yitz> Certain types of "rights" perhaps could be defined that might be overall beneficial, but it will take a long, long time before we'll really be able to say.
09:39:53 <Deewiant> depends on how much you use them, I'd say
09:40:04 <Deewiant> but of course, if you're using them a lot you're doing something wrong anyway ;-)
09:40:14 <quicksilver> yes
09:40:22 <quicksilver> agreed on both counts.
09:40:30 <quicksilver> another example is (\ _ _ c -> c)
09:40:36 <quicksilver> (rather similar, of course)
09:40:45 <quicksilver> that's much nicer than const (const id)
09:40:58 <Deewiant> I could quote all kinds of "fst.tail.frth4.trd3.tail.tail.snd" stuff from my first real haskell program
09:41:02 * quicksilver nods
09:41:05 <badsheepy> quicksilver, nothing in particular, i just find half the stuff i try in haskell could be written in about 3 characters by someone who had a clue, so i thought id ask just in case :)
09:41:12 <quicksilver> @pl (\_ _ c -> c)
09:41:13 <lambdabot> const (const id)
09:41:20 <quicksilver> @pl (\c _ _  -> c)
09:41:20 <lambdabot> const . const
09:41:27 <pjdelport> Kamina: one other option specific to Float/Double would be: uncurry encodeFloat . decodeFloat
09:41:29 <quicksilver> badsheepy: fair enough.
09:41:34 <RayNbow> @djinn a -> b -> c -> c
09:41:35 <lambdabot> f _ _ a = a
09:41:36 <yitz> @unpl const . const
09:41:36 <lambdabot> (\ e _ _ -> e)
09:42:06 <Deewiant> quicksilver: funny, I was just thinking about that yesterday or this morning, would I prefer writing (const.const) x, const $ const x, \_ _ -> x, or some TH like $(const 2 x)
09:42:32 <Deewiant> and I came to the conclusion that since I don't know how to write the last I'll go with the points ;-)
09:42:55 <ddarius> Why not learn to write the last?  It's very easy.
09:42:58 <ToRA|MSR> you mean $(const 2) x for the last one
09:43:25 <ToRA|MSR> putting the x in the splice is probably not what you want to do
09:43:40 <Deewiant> given that I know practically nothing of TH, I'll take your word for it ;-)
09:43:43 <jeffersonheard> anyone do UDP using either Network or Network.Socket?
09:44:51 <Deewiant> ddarius: documentation on TH seemed rather scarce, at least last time I was looking
09:45:21 <jrh> I have a multitouch event engine that sends all its events over UDP
09:45:37 <rwbarton> , [| \x _ _ -> x |]
09:45:42 <Deewiant> and I haven't really had the need, so I haven't been bothered to.
09:45:42 <lunabot>  LamE [VarP x_0,WildP,WildP] (VarE x_0)
09:46:21 <rwbarton> , $( return $ LamE [VarP "x", WildP, WildP, WildP] (VarE "x") ) 1 2 3 4
09:46:22 <Deewiant> I've mostly been writing libraries, which I want to keep as extension-free as possible; requiring TH just for some syntactic sugar is not something I'd like to do ;-)
09:46:22 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
09:46:42 <rwbarton> , $( return $ LamE [VarP (mkName "x"), WildP, WildP, WildP] (VarE (mkName "x")) ) 1 2 3 4
09:46:45 <lunabot>  1
09:47:19 <Deewiant> hmm, looks rather trivial
09:47:36 <ToRA|MSR> something like: const = \num -> do n <- mkName "x" ; return $ LamE ([VarP n) ++ replicate num WildP) (VarE n)
09:48:10 <Kamina> pjdelport: i prefer realToFrac in this case :-)
09:56:16 <luite> how can I trace a parsec parser? something like printing each parser that is applied, whether it succeeds and what input it consumed?
10:05:33 <walrus> someone knows what is the fastest multidimensional mutable array to be used in haskell?
10:06:31 <Deewiant> probably STUArray/IOUArray
10:07:11 <Deewiant> unless you feel like futzing about with Ptr's, which are probably faster but... they're pointers :-P
10:08:08 <walrus> yes, trying not to use pointers
10:08:28 <walrus> but is possible to use multidimensional array with IOUArray?
10:08:57 <walrus> I am asking this because of http://www.haskell.org/ghc/docs/6.6.1/html/libraries/base/Data-Array-IO.html#t%3AIOUArray
10:08:58 <lambdabot> Title: Data.Array.IO, http://tinyurl.com/62re5n
10:10:10 <mauke> sure, why not?
10:10:41 <walrus> I can't make a IOUArray i (IOUArray i e). Or can I and I just don't know how?
10:10:54 <mauke> you can't
10:11:02 <mauke> just use a multidimensional array instead
10:11:33 <mauke> i can be a tuple
10:11:37 <mauke> arr ! (x, y)
10:11:56 <rwbarton> an IOArray i (IOUArray i e) is probably almost as good, but it's still a pain to use relative to IOUArray (i, i) e
10:13:14 <pjdelport> Kamina: well, it's probably more obvious that the decode/encode approach is non-lossy, if that matters
10:13:26 <walrus> mauke: Use a tupe in the index? Yes, sure... Why I didn't tought in this...
10:14:13 <walrus> thanks guys!
10:17:02 <laz0r> hi #haskell, if i get errors like 'No instance for (Monad ((->) [Char]))' for example, what does the (->) thing mean in that context?
10:17:15 <mauke> function type constructor
10:17:33 <mauke> that instance is in Control.Monad.Instances, btw (and Control.Monad.Reader)
10:17:49 <laz0r> mmh, ok, i'll google that
10:18:01 <roconnor> (->) [Char] === \x . [Char] -> x
10:18:04 <mauke> do you know what [Char] -> Int means?
10:18:08 <mauke> or a -> b -> c
10:18:28 <laz0r> yes, i think so
10:18:39 <mauke> a -> b is the same as (->) a b
10:19:06 <mauke> so ((->) [Char]) is (Char -> ) -- except that's a syntax error
10:19:06 <laz0r> ah, ok
10:20:51 <bbs> hey i keep getting an error here
10:20:54 <bbs> http://zlin.dk/p/?ZjE1MjI2
10:20:58 <lambdabot> Title: K-nopaste
10:21:00 <bbs> in the Var x line
10:21:16 <bbs>     Couldn't match expected type `Integer'
10:21:17 <bbs>            against inferred type `String'
10:21:24 <bbs> thats what ends up happening
10:22:12 <mauke> assoc is broken
10:22:24 <bbs> mauke: :/ how is that?
10:22:37 <mauke> assoc test [] = test  -- wrong
10:22:43 <mauke> 'test' has the wrong type
10:23:07 <bbs> mauke: it should be null then right?
10:23:12 <mauke> there is no null
10:23:14 <bbs> or 0
10:23:18 <bbs> since its
10:23:23 <bbs> now int based
10:23:36 <mauke> if you want to restrict assoc to numbers, yes
10:23:52 <bbs> what it i just said [] for the empty list?
10:24:08 <mauke> parse error
10:24:44 <bbs> mauke: now i get another error
10:24:56 <bbs> it should be ("string", intvalue)
10:25:21 <bbs> so i guess i need a base case
10:26:40 <TomMD> I seem to recall seeing huffman codes (and erasure codes) in Haskell some time ago, but don't see any package on hackage.  Is there a mature package for this?
10:28:51 <linolium> Why am I getting a non-exhaustive pattern error with these two function definitions? largestSubstringWithKeys' _ [] _ _ _ bestLen = bestLen     and     largestSubstringWithKeys' (first:substring) (next:stringLeft) keys curKeys hash bestLen = ... stuff ...
10:29:32 <laz0r> http://hpaste.org/11421
10:29:36 <vixey> linolium: there are some values that those patterns wouldn't match
10:29:40 <laz0r> ^ that caused my question
10:29:44 <linolium> vixey: how so?
10:29:45 <laz0r> just FYI
10:29:48 <vixey> linolium: largestSubstringWithKeys' [] (_:_) ...
10:29:48 <rwbarton> linolium: you can have the compiler tell you!  ghc -Wall -Werror
10:30:05 <TomMD> linolium: largestSubstringWithKeys [] (x:xs) _ _ _ _ = what?
10:30:29 <linolium> TomMD: oh
10:30:34 <EmielRegis> hello
10:30:38 <linolium> hi
10:30:40 <EmielRegis> i could use some help with Property
10:30:43 <TomMD> hello EmielRegis.
10:30:49 <TomMD> As in, QuickCheck?
10:30:56 <EmielRegis> yes
10:30:58 <EmielRegis> it wont work
10:31:05 <TomMD> ?test 1 == 1
10:31:05 <lambdabot> Maybe you meant: let list tell
10:31:06 <EmielRegis> says 'No instance for (Show Property)"
10:31:18 <TomMD> This is correct - Property is not an instance of show.
10:31:24 <EmielRegis> >prop_cipher key s = decipherStr key (encipherStr key s) == normalize s ==> True
10:31:28 <EmielRegis> thats what im trying ot run
10:31:30 <TomMD> You probably want to do "quickCheck func" not "putStrLn func"
10:31:33 <EmielRegis> if i change function to bool, it works
10:31:49 <EmielRegis> im doing quickCheck prop_cipher
10:32:17 <TomMD> ... Why the "==> True"
10:32:23 <EmielRegis> D> You probably want to do "quickCheck func" not "putStrLn func"
10:32:23 <EmielRegis> <EmielRe
10:32:26 <EmielRegis> well
10:32:39 <EmielRegis> this is an exercise for my studies :p
10:32:51 <EmielRegis> and Im supposed to use property to make sure the input is correct
10:32:57 <rwbarton> but but... *everything* ==> True
10:33:04 <TomMD> EmielRegis: From what I can tell, you just want: prop_cipher key s = decipherStr key (encipherStr key s) == normalize s
10:33:08 <Deewiant> hmm, @check is somewhat broken
10:33:09 <rwbarton> Oh, True is just a placeholder?
10:33:10 <Deewiant> @check \x -> x /= 0 ==> x /= 0
10:33:11 <TomMD> You don't want ==> True
10:33:11 <lambdabot>       No instance for (QuickCheck-1.1.0.0:Test.QuickCheck.Testable
10:33:11 <lambdabot>           ...
10:33:20 <TomMD> @check \_ -> 1 == 1
10:33:21 <lambdabot>   "OK, passed 500 tests."
10:33:22 <EmielRegis> yes it is a placeholder
10:33:40 <EmielRegis> i want to put something to check proper input in there but havent figured it out yet
10:33:47 <EmielRegis> my problem is that quickCheck wont work it it
10:33:55 <EmielRegis> just like it doesn't work with strings :(
10:34:03 <Deewiant> QuickCheck-2 can generate strings
10:34:15 <Deewiant> out of the box, that is
10:34:22 <EmielRegis> really?
10:34:22 <EmielRegis> gonna check that
10:34:24 <Deewiant> QuickCheck-1 can of course do it as well, you just need to tell it how
10:34:49 <EmielRegis> and how do you do that?
10:35:01 <Deewiant> you need to provide an instance Arbitrary Char
10:36:19 <EmielRegis> urgh
10:36:27 <EmielRegis> sorry but Im quite a newb to Haskell
10:36:42 <TomMD> instance Arbitrary char where      ;     arbitrary = arbitrary >>= \i -> fromEnum i
10:36:47 <vegai> does anyone have insight as to what the level of programmers is in India? Does anyone there know what Haskell is?
10:36:59 <TomMD> errr... that should be (return . fromEnum)
10:37:02 <vegai> or is it just java java java?
10:37:04 <EmielRegis> vegai, I heard India has one of best programmers atm
10:37:05 <TomMD> not the lambda
10:37:09 <EmielRegis> probably java+c++
10:37:11 <mauke> TomMD: >>= return . better written as liftM/fmap
10:37:30 <vegai> EmielRegis: from my very limited sample, it doesn't seem to be so
10:37:36 <TomMD> mauke, yeah, I just corrected myself.   I was thinking composition then typed a lambda - not sure how that happened.
10:38:01 <EmielRegis> so it should be
10:38:18 <EmielRegis> instance Arbitrary char where      ;     arbitrary = arbitrary >>= \i -> liftM/fmap fromEnum i
10:38:19 <EmielRegis> ?
10:38:43 <mauke> instance Arbitrary Char where arbitrary = fmap fromEnum arbitrary
10:38:54 <EmielRegis> ah ok
10:39:08 <mauke> wait, why fromEnum?
10:39:18 <mauke> isn't arbitrary supposed to return a Char?
10:39:19 <BMeph> "... and -boom- goes the dynamite." :)
10:39:46 <mauke> instance Arbitrary Char where arbitrary = fmap chr arbitrary  -- makes more sense to me (I've never used quickcheck)
10:40:14 <Deewiant> chr = toEnum
10:40:19 <rwbarton> none of this explains No instance for (Show Property), does it?
10:43:28 <EmielRegis> well
10:43:35 <EmielRegis> fromEnum returns error
10:43:42 <EmielRegis> ERROR file:.tutorial3.hs:10 - Type error in instance member binding
10:43:43 <EmielRegis> *** Term           : arbitrary
10:43:43 <EmielRegis> *** Type           : Gen Int
10:43:43 <EmielRegis> *** Does not match : Gen Char
10:44:18 * mauke wins
10:44:22 <Deewiant> EmielRegis: use toEnum
10:44:51 <EmielRegis> Program error: chr: out of range
10:44:57 <rwbarton> that's going to fail too as soon as an integer too big gets generated
10:45:06 <Deewiant> oh, darn
10:45:09 <Deewiant> > toEnum (-1) :: Char
10:45:10 <lambdabot>   * Exception: Prelude.chr: bad argument
10:45:13 <Deewiant> :-/
10:45:25 <rwbarton> how about   arbitrary = elements [minBound .. maxBound]
10:46:22 <Deewiant> how about arbitrary = choose (minBound, maxBound)
10:46:26 <Deewiant> or whatever, there's something like that
10:46:37 <rwbarton> or that
10:46:37 <Deewiant> so it doesn't do a !! on that million-element list :-P
10:47:17 <rwbarton> Hey, the implementation of elements *could* have been clever :-P
10:47:47 <bbs> http://zlin.dk/p/?ZjQzMWVi
10:47:48 <lambdabot> Title: K-nopaste
10:47:56 <Deewiant> RULES "clever" elements . enumFromTo = uncurry choose
10:47:57 <Deewiant> ;-P
10:48:02 <EmielRegis> elements ['A'..'Z'] works
10:48:03 <EmielRegis> thank you
10:48:16 <bbs> can someone help me with ^^ paste
10:48:30 <rwbarton> I just meant it could build an array... seems like the logical thing to do
10:48:52 <bbs>     Couldn't match expected type `[(String, Integer)]'
10:48:52 <bbs>            against inferred type `AExp'
10:48:52 <bbs>     In the pattern: IntLit val
10:48:52 <bbs>     In the definition of `eval': eval store (IntLit val) = val
10:48:58 <bbs> i don't get why :/
10:49:07 <mauke> bbs: wrong type signature
10:49:12 <mauke> argument order reversed
10:49:18 <Deewiant> rwbarton: elements xs = (xs !!) `fmap` choose (0, length xs - 1)
10:49:20 <Deewiant> sorry :-P
10:49:36 <rwbarton> Deewiant: yeah, I checked too
10:49:38 <EmielRegis> what does elements do anyway
10:51:37 <rwbarton> Deewiant: ah, this is fixed in QuickCheck 2.  elements no longer exists :)
10:51:54 <bbs> mauke: what do you mean?
10:52:14 <Deewiant> rwbarton: yes it does
10:52:15 <rwbarton> oh, it just moved. it's unchanged
10:52:18 <mauke> bbs: what what
10:53:40 <bbs> mauke: i don't know how to fix the type signature
10:53:53 <rwbarton> bbs: yes you do :P
10:53:57 <rwbarton> bbs: look at the order
10:53:59 <vixey> bbs: I do, delete it
10:54:17 <vixey> haskell acctually can infer types
10:54:20 <bbs> i can fix the order
10:54:34 <vixey> btw you should write eval as a fold
10:57:13 <bbs> vixey: i don't know how to do that right now -- also i fixed the order and it still gets messed up
10:58:02 <mauke> you don't know how to delete a line?
10:58:10 <mauke> oh, the fold thing
10:58:17 <bbs> mauke: no both ;(
10:58:30 <bbs> http://zlin.dk/p/?OGVlMTlh
10:58:34 <lambdabot> Title: K-nopaste
10:58:38 <bbs> my brain is broken atm
10:59:08 <mauke> http://arcanux.org/lambdacats/dumb.jpg
10:59:35 <bbs> mauke: LOLOL
10:59:45 * bbs makes his backgroung
11:01:32 <EmielRegis> huhu
11:01:47 <EmielRegis> btw, can anyone tell me a serious application where haskell is actually useful?
11:01:56 <EmielRegis> cause I can't imagine one myself :(
11:02:23 <mauke> version control, compilers, window managers, irc bots
11:02:38 <bbs> great wm's
11:02:41 <bbs> :D
11:02:49 <bbs> mauke: anyways so how do i really do this
11:02:59 <bbs> my whole program is done except for this one detail
11:03:06 <mauke> what's the problem?
11:03:14 <EmielRegis> uhm...
11:03:38 <EmielRegis> I still find it hard to imagine writing a sophistated program (like game) in Haskell
11:03:39 <Deewiant> EmielRegis: seriously, it's a programming language, my answer is "any"
11:03:42 <bbs> mauke: do you have my most recent paste?
11:03:49 <mauke> I think so
11:03:54 <EmielRegis> probably im just used to imperative programming...
11:04:20 <EmielRegis> but i cant see haskell as language for writing operating systems, games, and generally more sophisticated stuff
11:04:33 <zachk> there is frag
11:04:39 <Deewiant> ?where frag
11:04:40 <lambdabot> http://www.haskell.org/haskellwiki/Frag
11:04:41 <zachk> a quake3 wannabe
11:04:49 <mauke> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Monadius
11:04:55 <EmielRegis> O_O
11:04:55 <lambdabot> Title: HackageDB: Monadius-0.92, http://tinyurl.com/5bkzup
11:04:56 <EmielRegis> OMFG
11:05:11 <EmielRegis> thaatt
11:05:12 <daf> also http://programatica.cs.pdx.edu/House/, an operating system written in Haskell
11:05:13 <lambdabot> Title: House
11:05:14 <EmielRegis> urgh
11:05:31 <Deewiant> oh nice, an OS
11:05:34 <Deewiant> didn't know one existed
11:06:04 <bbs> mauke: http://zlin.dk/p/?MDg0ZWUx
11:06:05 <lambdabot> Title: K-nopaste
11:06:07 <bbs> there ist he latest
11:06:46 <bbs> mauke: i sent the error too thx for your help
11:06:51 <cjb> does anyone have a modern screenshot of House?
11:07:13 <bbs> mauke: and i think i just fixed it
11:07:21 <bbs>                         Exp exp -> eval store exp
11:07:21 <mauke> missing argument in call to eval
11:07:25 <mauke> yep
11:07:26 <bbs> by changing that line
11:07:28 <bbs> ;p
11:08:35 <TomMD> Deewiant: You might also be interested in one of the two L4 kernels in Haskell.  One from L4.verified and the other from PDX.
11:08:46 <zachk> i am starting to bring in fp concepts into any language i program in
11:09:08 <Deewiant> TomMD: thanks, I'll take a look
11:10:06 <bbs> mauke: its broked though
11:10:09 <bbs> wait!
11:10:10 <bbs> no
11:10:17 <EmielRegis> i can see some advantages of FP, however i so much prefer loops over recursion...
11:10:31 <mauke> I prefer combinators over both
11:11:04 <zachk> loops are evil
11:11:30 <ziman> non-local state is evil :)
11:11:34 <Vq^> EmielRegis: try HOFs then
11:11:35 <TomMD> All I need in life I can get from folds, maps and filters. ;-)
11:11:41 <EmielRegis> wots that?
11:11:48 <Vq^> EmielRegis: higher-order-functions
11:11:56 <EmielRegis> i read about it
11:12:01 <EmielRegis> its like generic programming isnt it
11:12:03 <mauke> preflex: . HOF
11:12:03 <preflex>  factoid not found
11:12:06 <Vq^> much better than loops
11:12:09 <mauke> preflex: store HOF higher-order function
11:12:36 <EmielRegis> well
11:12:42 <EmielRegis> i dont see anything special in HOFs
11:12:50 <EmielRegis> just simple templates from C++
11:13:11 <mauke> what
11:13:18 <Vq^> EmielRegis: look again
11:13:26 <mauke> show me a C++ function that returns another function, then we'll talk
11:13:33 <Vq^> EmielRegis: and ask yourself why templates in C++ hasn't replaced loops
11:13:36 <EmielRegis> ok not templates
11:13:39 <EmielRegis> function overloading
11:13:54 <EmielRegis> ah thats what you mean
11:14:13 <EmielRegis> i didnt notice that part of the description it seems
11:14:40 <bd_> http://www.boost.org/doc/libs/1_36_0/doc/html/function/tutorial.html <-- function objects in C++
11:14:41 <mauke> C++ function overloading is very shallow syntactic sugar
11:14:42 <lambdabot> Title: Tutorial, http://tinyurl.com/5ehpe2
11:14:48 <bd_> combine with boost::bind and boost::lambda for additional fun
11:14:57 <pjdelport> EmielRegis: loops are one kind of recursion
11:15:01 <mauke> you can always replace it with explicit calls to different functions
11:15:02 <int-e> mauke: does overloading the () operator count?
11:15:04 <EmielRegis> no
11:15:16 <EmielRegis> they are not recursive at all
11:15:19 <mauke> int-e: eww
11:15:29 <pjdelport> EmielRegis: yes, they are
11:15:31 <int-e> mauke: yes :)
11:15:36 <EmielRegis> no, because they are not infinite
11:15:38 <EmielRegis> like recursion
11:15:42 <mauke> EmielRegis: er, what?
11:15:46 <EmielRegis> unless you do something like while(1)
11:15:53 <int-e> mauke: but that's C++ for you.
11:15:59 <pjdelport> EmielRegis: the looping point is the recursion point
11:16:01 <TomMD> loops can be infinate... so can recursion.... loops typically aren't infinate... neither is recursion.
11:16:12 <EmielRegis> Imean
11:16:16 <EmielRegis> definition of recursion
11:16:20 <EmielRegis> is See recursion :P
11:16:33 <mauke> ok, this is pointless
11:16:35 <Deewiant> definition of loop is goto definition of loop
11:16:36 <pjdelport> EmielRegis: that's the punchline to a joke
11:16:55 <pjdelport> EmielRegis: recursive loops can be infinite or not
11:17:06 <EmielRegis> recursive loops?
11:17:10 <Vq^> looping is fairly abstract
11:17:17 <EmielRegis> well no
11:17:32 <EmielRegis> looping is very simple and assembler- like
11:17:37 <EmielRegis> just need a register and a jmp
11:17:37 <Vq^> if by looping one mean repeating some action then recursion is a form of looping, right?
11:17:45 <EmielRegis> indeed
11:18:05 <pjdelport> EmielRegis: so's tail recursion
11:18:10 <Deewiant> EmielRegis: and for recursion you just need a register and a call :-P
11:18:24 <EmielRegis> heh
11:18:30 <EmielRegis> but jmp is cheaper than call!
11:18:31 <EmielRegis> :P
11:18:48 <Deewiant> yes, hence tail call optimization
11:18:52 <pjdelport> EmielRegis: who said anything about a call?
11:18:53 <Vq^> if we're comparing machine-code there might not be any difference at all between your loops and recursion :P
11:19:00 <EmielRegis> Deewiant did ^^
11:19:12 <EmielRegis> Vq^, there should be tho
11:19:20 <pjdelport> EmielRegis: well, you don't need the call instruction for recursion
11:19:38 <TomMD> Yes, that is a common sticking point.
11:19:38 <EmielRegis> depends on implementation of the compiler I guess
11:19:43 <Deewiant> of course not, just inline everything into one huge clump and jmp around
11:19:51 <EmielRegis> you could do it with jmp too probbly
11:20:07 <Deewiant> "go sub" and all that
11:20:16 <Vq^> EmielRegis: you are a long way from the assembly-language irc-channel ;)
11:20:28 <EmielRegis> i know ^^
11:20:32 <pjdelport> EmielRegis: anyway, the point is that looping and recursion are just different styles of writing down exactly the same thing
11:20:39 <EmielRegis> im not an assembler coder myself anyway
11:20:40 <ziman> recursion is an abstract way to describe things. the compiler may (and probably will) translate it into loops if appropriate
11:20:47 <EmielRegis> yes i know pjdelport
11:20:48 <pjdelport> in general, loops are a specific kind of recursion
11:21:06 <EmielRegis> but they are a tad different in description and that I was pointing
11:21:09 <Vq^> EmielRegis: and the kind of recursion we are talking about can result in the machine code loop that you are thinking of (by tail-call optimization for example)
11:21:11 <TomMD> Vq^: But its a valid point.  Many people I talk to react "ewww, recursion slow".  Its as if they are hardwired to think gcc style recusion (no optimization).
11:21:31 <EmielRegis> what I also meant
11:21:41 <Deewiant> TomMD: GCC 4 does TCO, I think
11:21:45 <int-e> TomMD: it's not even true in C anymore.
11:21:49 <EmielRegis> is that for example by doing quick sort (i think thats the algorithms name) with loops
11:21:55 <mauke> TomMD: er, gcc is pretty good at optimizing recursion
11:21:55 <Vq^> TomMD: gcc got tail call optimization i believe
11:21:58 <EmielRegis> you can get index of wanted element very easily
11:22:00 <EmielRegis> while with recursion
11:22:09 <EmielRegis> in haskell, you need to mes with zip
11:22:10 <TomMD> Well, my point stands that many people have this negative (and incorrect) picture that needs correcting.
11:22:15 <mauke> EmielRegis: no, you don't
11:22:28 <EmielRegis> how so?
11:22:30 <mauke> EmielRegis: and 99% of quicksort implementations use recursion
11:22:47 <mauke> EmielRegis: er, you just don't. why would you even need an index?
11:23:16 <EmielRegis> err sorry i dont mean quicksort
11:23:24 <EmielRegis> I mean normal sort like
11:23:37 <EmielRegis> GetElementIndex( string str )
11:23:38 <mauke> bubblesort!
11:23:39 <Vq^> normalsort?
11:23:48 <glguy> Vq^, it's new
11:23:56 <Vq^> bubblesort is efficient, it gots no recursion :o)
11:23:57 <EmielRegis> for( int i = 0, i < length(str), i++)
11:24:09 <EmielRegis> oh wait i fail
11:24:12 <EmielRegis> i need a char also
11:24:17 <EmielRegis> so
11:24:19 <mauke> and ; in for
11:24:32 <EmielRegis> if( char == str[i]) return i;
11:24:37 <Deewiant> you fail, that has type String -> Char -> Int, it should be [a] -> a -> Maybe Int ;-)
11:24:37 <EmielRegis> now how do you do that in haskell>?
11:24:41 <Deewiant> ?src elemIndex
11:24:42 <lambdabot> elemIndex x     = findIndex (x==)
11:24:46 <Deewiant> ?src findIndex
11:24:46 <lambdabot> findIndex p     = listToMaybe . findIndices p
11:24:50 <Deewiant> ?src findIndices
11:24:51 <lambdabot> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
11:24:53 <Deewiant> like that
11:24:58 <mauke> EmielRegis: I use elemIndex
11:25:00 <sjanssen> EmielRegis: firstly, we wouldn't call that a sort
11:25:02 <EmielRegis> Deewiant, that was pseudo-C code
11:25:07 <Deewiant> EmielRegis: and that was real Haskell code
11:25:17 <EmielRegis> <lambdabot> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
11:25:19 <EmielRegis> exactly!
11:25:26 <EmielRegis> i said that you need to zip things before doing anything
11:25:39 <EmielRegis> while you dont have to with imperative...
11:25:45 <sjanssen> EmielRegis: you can do it without zipping
11:25:46 <ziman> of course when you demand the index explicitly :)
11:25:48 <mauke> this has nothing to do with sorting
11:25:50 <Deewiant> EmielRegis: with imperative, you have to write "for int i = 0" etc.
11:26:03 <glguy> EmielRegis, and you had to manually increment your counter
11:26:04 <rwbarton> what's so special about zip?
11:26:06 <rwbarton> @src zip
11:26:06 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
11:26:07 <lambdabot> zip _      _      = []
11:26:09 <glguy> yikes
11:26:13 <rwbarton> it's lambdas all the way down :)
11:26:14 <EmielRegis> yes sorry mauke I meant index search
11:26:29 <mauke> EmielRegis: ok, so what's the problem with using zip?
11:26:29 <EmielRegis> nice bot btw ;)
11:26:32 <Vq^> if it's C then i would worry more about having to write strlen
11:26:35 <EmielRegis> there is none
11:26:37 <EmielRegis> my point is
11:26:43 <EmielRegis> that you can do it faster with C :p
11:26:49 <Deewiant> also incorrect
11:26:51 <mauke> EmielRegis: how is that your point?
11:26:58 <rwbarton> Well, linked lists and arrays are not the same thing
11:26:58 <EmielRegis> cause you dont have to use zip
11:27:04 <mauke> EmielRegis: do you think zip is slow or something?
11:27:06 <Vq^> C would theoretically be less efficient with that example
11:27:09 <Deewiant> using zip does not slow your program down
11:27:11 <EmielRegis> anyway, this is not a 'fast' algorithm (the C one)
11:27:12 <sjanssen> findIndices p xs = go 0 xs where go i [] = []; go i (x:xs) = if i == x then x : go (i+1) xs else go (i+1) xs
11:27:13 <EmielRegis> no mauke
11:27:17 <EmielRegis> but its certainly longer
11:27:21 <EmielRegis> than just a loop
11:27:23 <rwbarton> sjanssen's code is exactly your for loop
11:27:27 <sjanssen> EmielRegis: you can write findIndices like that, and it is a loop
11:27:27 <int-e> EmielRegis: the strength of Haskell is not in writing small inner loops, that's true. It's in composing pieces to working programs.
11:27:30 <Deewiant> sjanssen: you forgot about p there
11:27:30 <mauke> EmielRegis: no, it isn't
11:27:30 <EmielRegis> which translates to very few assembler instruction
11:27:40 <sjanssen> Deewiant: oops
11:27:43 <mauke> EmielRegis: elemIndex is a single line. that's very short code
11:27:43 <glguy> EmielRegis, Did you have a question about Haskell?
11:28:06 <EmielRegis> lol I knew you would all jump on me once i start dissing Haskell ^^
11:28:07 <rwbarton> EmielRegis: I think you'd be very surprised if you looked at the code ghc emits for this kind of trivial task
11:28:19 <EmielRegis> probably yeah
11:28:25 <rwbarton> EmielRegis: it's generally identical to the C code
11:28:28 <mauke> EmielRegis: "very few assembler instructions" doesn't mean shit if 50% of them are function calls
11:28:42 <EmielRegis> they arent
11:28:46 <mauke> EmielRegis: strlen is
11:28:47 <EmielRegis> just jmps probably
11:28:51 <TomMD> int i = 0; for (; i < len; i++) if (list[i] == a) break; if (i < len) blah;
11:28:56 <TomMD> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
11:29:36 <EmielRegis> p x?
11:29:56 <TomMD> p would be the (== a) function
11:30:08 <TomMD> findIndices p xs = [ i | (x,i) <- zip xs [0..], x == a]
11:30:10 <EmielRegis> ah
11:30:16 <EmielRegis> ye
11:30:28 <hukolele_> which parser library is better to make an assembler?
11:30:33 <Vq^> it can also be written with parallel listcomprehension if you don't like the word "zip"
11:30:40 <Vq^> :P
11:30:51 <Deewiant> but that just desugars to zip anyway :-P
11:30:57 <int-e> EvilTerran: you can write code like this. But it's not very Haskell-ish: http://hpaste.org/11423
11:31:06 <int-e> EmielRegis: oops, I meant you.
11:33:10 <EmielRegis> ok ^^
11:36:29 <EmielRegis> @src Data.Array
11:36:30 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
11:36:34 <EmielRegis> ;o
11:36:57 <mauke> @source Data.Array
11:36:58 <lambdabot> http://darcs.haskell.org/packages/base/Data/Array.hs
11:37:05 <mauke> lambdabot: fail
11:37:12 <Deewiant> @vixen fail
11:37:13 <rwbarton> @slap lambdabot
11:37:13 <lambdabot> i'm a huge baseball fan
11:37:13 * lambdabot hits lambdabot with an assortment of kitchen utensils
11:37:53 <int-e> http://darcs.haskell.org/packages/array/Data/Array.hs
11:38:17 <Deewiant> http://www.haskell.org/ghc/docs/latest/html/libraries/array/src/Data-Array.html
11:38:23 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5jpm7v
11:38:42 <EmielRegis> * lambdabot hits lambdabot with an assortment of kitchen utensils
11:38:43 <EmielRegis> lol
11:38:46 <EmielRegis> seriously, nice bot
11:39:13 <int-e> @botsnack
11:39:14 <lambdabot> :)
11:39:41 <TomMD> > let f = map fst . filter ((== 5) . snd) . zip [0..] in f $ [1..100] ++ [100,99..1]  -- Yeah, I like lambdabot.
11:39:43 <lambdabot>   [4,195]
11:39:59 <TomMD> > sum [1..]
11:40:07 <TomMD> Its fairly safe too.
11:40:19 <lambdabot>   thread killed
11:40:23 <mauke> > fix error
11:40:24 <EmielRegis> lol
11:40:27 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
11:40:28 <int-e> @quote unsafePerformIO
11:40:28 <lambdabot> Binkley says: [Monads as clothes] <Binkley> using unsafePerformIO is kind of like going naked in public, might be safe in some contexts, but you really don't want to know what happensif you do it in
11:40:28 <lambdabot> a really bad one
11:40:33 <geezusfreeek> [1..]
11:40:37 <geezusfreeek> > [1..]
11:40:38 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:41:35 <int-e> @quote ghc
11:41:35 <lambdabot> ghc says: deadlock: main thread blocked in a strange way
11:41:47 <Deewiant> @ghc
11:41:47 <lambdabot> ghc says: Only unit numeric type pattern is valid
11:42:06 <Deewiant> hmm
11:42:07 <int-e> > undefined :: 1
11:42:08 <lambdabot>       No instance for (Show Unit)
11:42:09 <lambdabot>        arising from a use of `show' at <int...
11:42:13 <Deewiant> are @ghc all actual GHC quotes?
11:42:14 <rwbarton> > undefined :: 2
11:42:15 <int-e> > undefined :: 2
11:42:16 <lambdabot>   Only unit numeric type pattern is valid
11:42:16 <lambdabot>   Only unit numeric type pattern is valid
11:42:20 <Deewiant> ew
11:42:20 <rwbarton> I like that one
11:42:28 <rwbarton> Deewiant: Some are from the ghc source
11:42:33 <rwbarton> @quote ghc PhD
11:42:33 <lambdabot> ghc says: You can get a PhD for explaining the True Meaning of this last construct
11:42:49 <Deewiant> ?ty undefined :: 1
11:42:50 <rwbarton> @ghc exploded
11:42:51 <lambdabot> Unit
11:42:52 <lambdabot> ghc says: My brain just exploded.
11:42:55 <Deewiant> ?index Unit
11:42:56 <lambdabot> bzzt
11:43:01 <Deewiant> what's that
11:44:57 <Deewiant> ?users
11:44:57 <lambdabot> Maximum users seen in #haskell: 547, currently: 533 (97.4%), active: 15 (2.8%)
11:45:19 <Deewiant> ?ghc
11:45:19 <lambdabot> ghc says: parse error (possibly incorrect indentation)
11:46:22 <rwbarton> Deewiant: I think it's for -XGenerics
11:46:23 <sereven> what would be simpler way of `val <- getEnvironment >>= return . fromMaybe "def" . lookup "key"
11:46:54 <rwbarton> val <- fromMaybe "def" . lookup "key" <$> getEnvironment
11:47:15 <Deewiant> x >>= return . y is equivalent to fmap y x
11:47:45 <int-e> @type findWithDefault
11:47:46 <lambdabot> Not in scope: `findWithDefault'
11:47:52 <int-e> @type Data.Map.findWithDefault
11:47:53 <lambdabot> forall a k. (Ord k) => a -> k -> M.Map k a -> a
11:48:10 <rwbarton> getEnvironment doesn't use Data.Map, though, does it?
11:48:27 <sereven> no, just a list of tuple (k,v)
11:49:06 <ziman> http://hpaste.org/11423#a1 ;) it's O(n^2), though
11:49:09 <int-e> findWithDefault "def" "key" <$> getEnvironment  (assuming this is a Map)
11:49:10 <sereven> thanks :)
11:49:51 <EmielRegis> another noob question: how are lists held in memory? do they behave like linked lists (hold an element in first memory page along with pointer to the next element)?
11:50:03 <rwbarton> Yes.
11:50:35 <EmielRegis> cool
11:52:15 <roconnor> > cycle [1,2,3]
11:52:16 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
11:52:23 <roconnor> ^^ ciruclar linked list
11:52:45 <int-e> > map succ $ cycle [1,2,3]
11:52:46 <lambdabot>   [2,3,4,2,3,4,2,3,4,2,3,4,2,3,4,2,3,4,2,3,4,2,3,4,2,3,4,2,3,4,2,3,4,2,3,4,2,...
11:52:53 <int-e> ^^ sadly, not circular
11:52:59 <mauke> map breaks the cycle
11:53:28 <roconnor> {-# RULE map f (cycle l) = cycle (map f l) #-}
11:53:32 <roconnor> fixed
11:53:36 <mauke> heh
11:53:38 <idnar> heh
11:54:43 * [- wonders why that highlighted for him
11:54:44 <int-e> > scanl (flip (-)) 0 (cycle [1,2,3])
11:54:46 <lambdabot>   [0,1,1,2,-1,3,0,1,1,2,-1,3,0,1,1,2,-1,3,0,1,1,2,-1,3,0,1,1,2,-1,3,0,1,1,2,-...
11:55:04 <mauke> preflex: nickometer [-
11:55:04 <preflex>  [- is 40% lame
11:55:09 <Asztal^_^> [-: RFC1459 defines { to be the uppercase version of [
11:55:28 <roconnor> really? that's dumb
11:55:29 <Asztal^_^> preflex: nickometer Asztal^_^
11:55:29 <preflex>  Asztal^_^ is 97.05% lame
11:55:36 <[-> Asztal^_^, ah
11:55:48 <_andre> is there a standard name for this function? f lower_bound upper_bound x = max lower_bound (min upper_bound x)
11:55:49 <mauke> {\} = [|]
11:55:53 <[-> preflex, nickometer _-_-~{}
11:55:53 <preflex>  _-_-~{} is 99.968507% lame
11:55:55 <roconnor> > toUpper '{'
11:55:57 <lambdabot>   '{'
11:56:02 <roconnor> :)
11:56:06 <[-> > toUpper '['
11:56:07 <idnar> _andre: I would probably call it "clip" or something like that
11:56:07 <lambdabot>   '['
11:56:14 <idnar> no clue if that's "standard", though
11:56:18 <Asztal^_^> I would call it clamp
11:56:24 <roconnor> _andre: I call it clamp, but I don't think it is standard
11:56:26 <idnar> ah, clamp is probably better
11:56:44 <_andre> ok, clamp it is :)
11:57:01 <roconnor> _andre: take care that lower_bound <= upper_bound
11:57:32 * roconnor grumbles about trying to prove correctness about clamp.
11:57:57 <int-e> roconnor: "Because of IRC's scandanavian origin, the characters {}| are considered to be the lower case equivalents of the characters []\." - obviously they used some rare ASCII characters for letters.
12:00:57 <vixey> what's clamp?
12:01:11 <vixey> **** what's clamp correctness
12:01:40 <MyCatVerbs> vixey: boo! Good to see you still about.
12:01:41 <vixey> oh I get it
12:01:51 <vixey> hi hi verbs
12:02:02 <roconnor> vixey: one property of clamp is that the result is between lower_bound and upper_bound
12:02:04 <int-e> > map (max 1 . min 5) [0..6]
12:02:06 <lambdabot>   [1,1,2,3,4,5,5]
12:02:06 <MyCatVerbs> int-e: the .fi connection makes me wonder why the IRC spec doesn't mandate UTF-8 or something sane. ;)
12:02:16 <roconnor> f lower_bound upper_bound x = max lower_bound (min upper_bound x) -- clamp
12:02:46 <roconnor> int-e: you are pulling my leg.
12:02:55 <int-e> MyCatVerbs: in 1993? (and that's the date of the RFC, the protocol is certainly older.)
12:03:36 <MyCatVerbs> int-e: utf-8 dates from about the mid 80s. :)
12:04:16 <MyCatVerbs> int-e: but yeah, true dat. But a bit more of a pity that it isn't mandated in most protocols *now*. :)
12:04:55 <roconnor> @when utf-8
12:04:55 <lambdabot> Maybe you meant: seen what where wn
12:05:04 <rwbarton> MyCatVerbs: you might want to "fix" wikipedia then--it claims 1992--1993
12:05:57 <int-e> roconnor: Even the "scandanavian" typo is from the actual RFC. Sorry.
12:09:25 <dblazakis> this is off topic, but didn't someone write a new linker that is really fast... i don't have the google-fu to bring it back to me
12:09:35 <vixey> googles one?
12:09:42 <sjanssen> dblazakis: "gold"?
12:09:54 <dblazakis> vixey: sjanssen: yes!
12:09:55 <dblazakis> thanks
12:09:56 <MyCatVerbs> rwbarton: my bad.
12:10:06 <MyCatVerbs> rwbarton: I have it wrong, then.
12:15:48 <yitz> http://www.cl.cam.ac.uk/~mgk25/ucs/utf-8-history.txt
12:16:22 <agcorona> hi
12:16:41 <yitz> UTF-8 was designed, in front of my eyes, on a placemat in a New Jersey diner one night in September or so 1992. What happened was this...
12:17:01 <yitz> (not me. that was a quote.)
12:17:26 <agcorona> what is the best paste service for haskell?
12:17:41 <agcorona> paste.org is ugly
12:17:42 <yitz> @hpaste
12:17:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:18:02 <yitz> don't know if it's best, but it's traditional around here.
12:18:09 <agcorona> thanks
12:19:39 <geezusfreeek> there is also a newer paste site that somebody here made, i think, which i usually like when i see it
12:19:44 <geezusfreeek> but i can't remember its name
12:19:53 <vixey> neither can lambdabot
12:20:04 <mauke> codepad?
12:21:33 <sbahra> Someone here made codepad?
12:21:54 <TomMD> ?where codepad
12:21:54 <lambdabot> I know nothing about codepad.
12:22:01 <rwbarton> @where hpaste2
12:22:01 <lambdabot> I know nothing about hpaste2.
12:22:03 <rwbarton> @where hpastetwo
12:22:03 <lambdabot> I know nothing about hpastetwo.
12:22:08 <quicksilver> geezusfreeek probably means moonpatio
12:22:20 <quicksilver> which is mmorrow's installation of hpastetwo
12:22:34 <Deewiant> @where+ hpastetwo http://moonpatio.com:8080/
12:22:34 <lambdabot> Done.
12:23:58 <TomMD> ?google codepad
12:23:59 <TomMD> @go is this broken?
12:24:01 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
12:24:10 <lambdabot> http://www.goodexperience.com/tib/
12:24:10 <lambdabot> Title: This Is Broken
12:24:11 <sbahra> @google haskell
12:24:13 <lambdabot> http://www.haskell.org/
12:24:13 <lambdabot> Title: Haskell - HaskellWiki
12:32:02 <geezusfreeek> quicksilver, yes, that's it
12:43:35 <nicknull> has there been much research on programmer effectiveness and time saved with dynamic typing that is perhaps laer lost when chasing bugs etc?
12:46:34 <pizza___> we're still compiling the results; there are type-related bugs in our census and statistical applications
12:47:50 <djsiegel> Hey, I'm trying to get a Network.CGI example running, and my main module loads in ghci just fine, and I can run it with runhaskell, but when I try to run it through my web browser, apache complains that Network.CGI cannot be found. What's up with that?
12:48:50 <djsiegel> Ah, doing the static linking worked, but ewww.
12:49:10 <mightybyte> @pl \a -> [a]
12:49:11 <lambdabot> return
12:49:19 <Deewiant> (:[])
12:49:20 <Cale> djsiegel: How were you managing dynamic linking at all?
12:50:04 <yitz> Cale: djsiegel said "..oads in ghci just fine..."
12:50:43 <djsiegel> Cale, I'm running a development server on the same machine I have Haskell installed on, so I just had #!/usr/bin/runhaskell at the top of my main module. I was hoping I could just visit ../cgi-bin/Blah.hs?param=hello+world in my browser while I am poking around.
12:51:35 <Cale> djsiegel: The only problem I can imagine with that is that the user the webserver is running as doesn't have access to the same Haskell libraries as you?
12:51:54 <Cale> (for instance, if you have the network package installed as user)
12:51:59 <djsiegel> Yeah, I thought that too so I logged in as www and ghci loaded it fine.
12:52:05 <Cale> interesting.
12:52:50 <paolino> if I remember right it works with hugs
12:56:19 <paolino> what is the type of a function which produces a function of the same type
12:56:22 <paolino> ?
12:56:28 <Deewiant> ?ty id :: (a -> a) -> a -> a
12:56:29 <lambdabot> forall a. (a -> a) -> a -> a
12:56:35 <Deewiant> or wait, what
12:56:48 <Deewiant> ?ty undefined
12:56:49 <lambdabot> forall a. a
12:56:59 <vixey> newtype FuntionMaker a = a -> FuntionMaker a
12:57:29 <paolino> data F a = F (a -> F a)
12:57:30 <paolino> f  = F (const f)
12:57:40 <vixey> yeah yours is better
12:57:50 <paolino> let F y = f
12:57:50 <mauke> b@(a -> b)
12:57:59 <vixey> -rectypes
12:58:00 <vixey> heh
12:58:06 <paolino> *Main> :t y
12:58:07 <paolino> y :: GHC.Prim.Any -> F GHC.Prim.Any
12:58:10 <paolino> O_O
13:00:09 <paolino> it's some months I'm not coding these are first 5 lines after that ......
13:01:36 <paolino> anyway , is this the kind of use for CPS ?
13:01:54 <vixey> what
13:03:18 <paolino> if CPS is the framework for using functions like those
13:03:35 <vixey> no not at all
13:06:46 <roconnor> @free map
13:06:47 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
13:09:08 <FalconNL> Hm, either I'm doing something wrong or Oleg's shuffle algorithm is incomplete. The former seems rather more likely, but I haven't a clue what. Can anyone enlighten me? http://hpaste.org/11429
13:10:13 <Deewiant> FalconNL: perhaps the lengths of the two input lists need to be the same
13:11:36 <FalconNL> Deewiant: no, the original article explicitly states the second one should be one shorter. The examples in there confirm that
13:12:17 <FalconNL> Otherwise the first test wouldn't work either
13:12:37 <Deewiant> the first could be a fluke, but I see that you're right; beats me
13:12:58 <tromp_> doesn't the (n-i)th number have to be <= i ?
13:14:07 <FalconNL> From the article: "Each sample in a sequence is chosen independently. The
13:14:08 <Deewiant> "such that r[i] is an independent sample from a uniform random distribution [0..n-i]"
13:14:09 <FalconNL> sample of random numbers may contain subsequences (0,0,0,0) -- which
13:14:10 <FalconNL> are just as likely as (1,2,3,4) or (3,1,4,1) or any other given
13:14:12 <FalconNL> sequence of four values. In fact, this is one of the PRNG tests --
13:14:13 <FalconNL> making sure that all the tuples (r1,r2) or (r1,r2,r3) appear equally
13:14:15 <FalconNL> likely."
13:14:27 <Deewiant> r[i] has to be <= n-i
13:14:31 <FalconNL> ah
13:14:44 <FalconNL> thanks
13:17:59 <seydar> has anyone written syntax highlighter for yi for ruby?
13:18:00 <seydar> or any other language?
13:32:07 <roconnor> @free id
13:32:08 <lambdabot> f . id = id . f
13:32:17 <roconnor> @free (.)
13:32:18 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
13:32:35 <mauke> @free (.) :: a
13:32:35 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
13:32:42 <vixey> @free failure
13:32:43 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `failure'\n\n"
13:33:02 <mauke> @free compose :: (b -> c) -> (a -> b) -> a -> c
13:33:02 <lambdabot> g . k = p . f => f . q = f1 . h => g . compose k q = compose p f1 . h
13:34:46 <kniu> I read somewhere that Haskell's type-classes and their use can be straightforwardly translated into the declaration and use of plain algebraic data types.
13:35:02 <kniu> That is, the former can be thought of as syntactic sugar.
13:35:04 <vixey> kniu: I don't believe that
13:35:14 <SamB> depends on what you mean by "plain"
13:35:24 <vixey> syntactic sugar doesn't usually do proof search
13:35:30 <mauke> kniu: I believe you!
13:35:33 <SamB> true enough
13:35:50 <vixey> I beleive kniu.. but not the statement..
13:36:12 <SamB> it does do proof search ...
13:36:16 <kniu> I think it's this one: http://research.microsoft.com/~simonpj/papers/history-of-haskell/history.pdf
13:36:19 <lambdabot> Title: A History of Haskell: Being Lazy With Class, http://tinyurl.com/yotlvc
13:36:19 <SamB> so I guess sugar isn't the term ...
13:38:25 <kniu> "A particularly attractive feature of type classes is that they can
13:38:25 <kniu> be translated into so-called dictionary-passing style by a typedirected
13:38:25 <kniu> transformation."
13:39:10 <kniu> page 17
13:39:17 <vixey> kniu: but they don't give a compiler that does that transform?
13:39:24 <mauke> ghc
13:39:40 <gio123> can somebody tell me  equivalent reg expression of this expression  X \cup a+b
13:40:15 <pao> @google flexiblecontexts
13:40:18 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/FlexibleContexts
13:40:18 <lambdabot> Title: FlexibleContexts - Haskell Prime - Trac
13:40:36 <mauke> I don't know what + means, but \cup is probably |
13:41:07 <gio123> can somebody tell me  equivalent reg expression of this expression  X \cup a+b, so reg expression which will be constructed only using regular operators
13:41:59 <pao> How do I find a detailed explanation for -XFlexibleContexts?
13:42:35 <Cale> pao: Probably the GHC user's guide has one
13:43:01 <gio123> Cale:hi
13:43:16 <pao> Cale: I guess so ... It's a pity it misses a good index or search tool
13:43:45 <Cale> pao: http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#id352860
13:43:47 <lambdabot> Title: 5.17.Flag reference, http://tinyurl.com/ydk2e6
13:44:12 <pao> Cale:  Thanks :-)
13:45:07 <gio123> can somebody tell me  equivalent reg expression of this expression  X \cup a+b, so reg expression which will be constructed only using regular operators
13:45:36 <Cale> Grr, I wanted to bookmark that, and when I started to drag the little page icon next to the URL bar in Firefox, it "helpfully" pops up a tooltip saying "This web site does not supply identity information." covering up the folder that I wanted to drag the item into.
13:46:34 <pao> Cale: :-(
13:48:37 <gio123> cale: hey
13:49:48 <Cale> gio123: Hello! If it's about regular expressions I don't want to hear it. ;)
13:50:26 <gio123> :)
13:50:30 <gio123> why?
13:51:35 <gio123> only tell me this one and finish regexp for ever can you tell me quikly what would be X \cup a+b ==> regexp
13:54:34 <Cale> gio123: I have no idea what that question means.
13:56:34 <gio123> Cale: intersection of two regular automatas is regular right?
13:57:31 <BMeph> Is there a version of takeWhile that includes the first failure condition? I'd rather now write it myself, if I don't have to... :)
13:58:22 <sjanssen> BMeph: something involving span?
13:58:58 <sjanssen> @type \p -> fmap listToMaybe . span p
13:58:59 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], Maybe a)
13:59:05 <sjanssen> BMeph: there you go
14:01:17 <yitz> @type \p -> uncurry (++) . fmap (take 1) . span p
14:01:20 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
14:02:02 * EmielRegis http://img87.echo.cx/img87/1403/jeromelebanner8xj5rm.gif
14:02:38 <yitz> Lately I've needed several times the converse of that - a dropWhile that stops one element *before* the condition becomes true.
14:03:31 <vixey> yitz, that's a curious function, what do you use it for?
14:05:21 <yitz> vixey: well, for example, to move something one square to the right. the predicate finds the empty square, now I need the one to the left of it.
14:06:00 <vixey> ok
14:06:03 <yitz> but I think "the one just before" is a common enough idiom.
14:06:14 <vixey> I can't remember every using it
14:06:17 <vixey> ever*
14:06:26 <yitz> anyway, it's trickier than what BMeph wanted.
14:07:33 <yitz> I haven't found a neat way of doing it without either rewriting dropWhile, or reading through the initial elements twice.
14:14:22 <tromp_> :t span
14:14:23 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
14:15:53 <tromp_> :t fmap listToMaybe
14:15:54 <lambdabot> forall a (f :: * -> *). (Functor f) => f [a] -> f (Maybe a)
14:16:35 <tromp_> @instances Functor
14:16:36 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
14:17:25 <vixey> @src Cont
14:17:26 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
14:17:27 <sjanssen> yitz: use a zip
14:17:31 <vixey> :t Cont
14:17:32 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
14:18:44 <yitz> sjanssen: yes, but that essentially reads through them twice.
14:19:22 <sjanssen> yitz: \p (x:xs) -> x : map snd (dropWhile (p . fst) (x:xs) xs
14:19:38 <sjanssen> @type \p (x:xs) -> x : map snd (dropWhile (p . fst) $ zip (x:xs) xs)
14:19:39 <lambdabot> forall b. (b -> Bool) -> [b] -> [b]
14:19:53 <sjanssen> yitz: this is Haskell, there is only one traversal
14:20:42 <sjanssen> erm, that isn't quite right
14:20:53 <sjanssen> that is the takeWhile version
14:21:43 <yitz> sjanssen: ok.
14:22:13 <sjanssen> but I'm confident we can find the right defn.
14:23:52 <yitz> sjanssen: yes, but it's two operations at each step of the traversal. you don't think defining it by direct recursion would be faster?
14:24:11 <sjanssen> yitz: meh
14:24:26 <sjanssen> I don't expect there to be much of a difference
14:25:08 <yitz> or that just using span and last would be about the same?
14:27:19 <sjanssen> @src span
14:27:20 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
14:27:22 <sjanssen> of course.
14:29:11 <sjanssen> dropWhile1 p xs = fromMaybe [] $ fmap snd $ find (not . p . fst) $ zip (tail xs) (tails xs)
14:30:35 <sjanssen> @src tails
14:30:36 <lambdabot> tails []         = [[]]
14:30:36 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
14:31:21 <roconnor> What do people think about Data.Colour.Name vs Data.Colour.Names?
14:31:36 <roconnor> Data.Colour.Name.aqua vs Data.Colour.Names.aqua
14:31:51 <roconnor> import Data.Colour.Name vs import Data.Colour.Names
14:32:07 <vixey> why not Color
14:32:19 <MyCatVerbs> vixey: because not all of us are barbarians. ;)
14:32:19 <sjanssen> vs import Data.Color.Name vs Data.Color.Names :)
14:32:32 <vixey> anyone who spells color correctly hasn't use a computer
14:32:36 <yitz> vixey:  better duck :)
14:32:53 <MyCatVerbs> vixey: hasn't used a barbarian-crafted computer, you mean.
14:33:05 * MyCatVerbs puts a pancake on vixey's head.
14:33:07 <SamB_XP> oh man ...
14:33:11 <roconnor> I may add a series of Data.Color modules to reexport Data.Colour modules, but let's stick to the issue at hand. :)
14:33:19 <MyCatVerbs> roconnor: I'd go with the plural. :)
14:33:30 <sjanssen> roconnor: seems like the module isn't actually about names of colors, but is just a collection of named colors
14:33:32 <roconnor> MyCatVerbs: I'm leaning that way too.
14:33:39 <roconnor> sjanssen: correct
14:33:43 <SamB_XP> we ought to standardize one spelling and stick to it
14:33:47 <sjanssen> roconnor: do these color names come from some source? (an RFC, or something?)
14:33:52 <MyCatVerbs> roconnor: and please don't bugger the Haddock pages by having two copies of everything to please both the barbarians and the civilized.
14:33:57 <vixey> SamB_XP: That's the biggest influence of HTML
14:34:02 <MyCatVerbs> roconnor: I'd much rather just use the barbarian spelling. :)
14:34:07 <roconnor> sjanssen: SVG 1.0 spec, which more or less gets them from X11.
14:34:24 <SamB_XP> roconnor: emphasis on less
14:34:42 <roconnor> SamB_XP: are there more colour names in X11?
14:34:44 <yitz> roconnor: you can use either the ploural or the singulre.
14:35:02 <sjanssen> roconnor: seems to me Name doesn't belong in the name at all
14:35:04 <roconnor> yitz: I know that, I'm trying to decide. ;)
14:35:11 <SamB_XP> roconnor: I mean, there are a few color names with totally different RGB triples ...
14:35:33 <roconnor> sjanssen: that's fair.  But I do want to put the names in a separate module.
14:35:34 <sjanssen> if SamB_XP is right, it really should be Data.Colour.SVG
14:35:45 <SamB_XP> why Colour ?
14:35:55 <roconnor> sjanssen: but all sorts of people use the same names.
14:36:09 <sjanssen> roconnor: but apparently they don't mean the same thing, per SamB_XP
14:36:18 <roconnor> it is the defacto list of names.
14:36:32 <roconnor> sjanssen: I'm waiting for more evidence from SamB_XP.  AFAIK they are the same.
14:37:07 <roconnor> sjanssen: everyone agrees except for .Net who thinks darkgreen is something different, or something like that.  Microsoft always has to be incompatiable.
14:37:20 <yitz> roconnor: the de facto standard is Pantone,really, but that's proprietary.
14:37:35 <sjanssen> roconnor: yet more evidence that you shouldn't call use the "Name" part
14:37:52 <roconnor> sjanssen: what module should it go into?
14:38:16 <sjanssen> because somebody will want Data.Colour.DotNet with the standard values except darkgreen which would be different
14:38:30 <sjanssen> roconnor: name it after the standard (SVG, or whatever)
14:38:34 <roconnor> sjanssen: and they can make such a module.
14:38:41 <yitz> Graphics.SVG.Colors
14:39:24 <yitz> ok, Colours. there.
14:39:25 <roconnor> sjanssen: people didn't like Data.Colour.Rec709, prefering Data.Colour.HDTV.  Using Data.Colour.SVG would be analogous using Data.Colour.Rec709 (by naming the standard instead of naming the concept)
14:39:35 <sjanssen> Graphics.Colors.Names.SVG
14:40:09 <roconnor> I think putting SVG is a bad idea.  There is no more reason to put in SVG than X11, than whatever other standard adopts these names.
14:40:41 <sjanssen> roconnor: on an unrelated note, I think you should reconsider Colour.  I don't want to sound bigoted, but American spelling is pretty standard in technical circles, IME
14:41:04 <vixey> It really doesn't matter, I just wondered why
14:41:30 <vixey> is Colour a data type though?
14:41:32 <sjanssen> of course I'm an American, so I'm hardly unbiased on the matter :)
14:41:35 <yitz> roconnor: you took it from SVG, so that's what it is really. X11 will probably never need this anyway, because in X11 you don't hard-wire color names, you always read rgb.txt.
14:41:45 <MyCatVerbs> sjanssen: are you insinuiating that the circles on this side of the Pond aren't technical? ;P
14:41:46 <yitz> come to think of it, perhaps you should do the same.
14:41:49 <vixey> Well I'm a person who uses a computer, so I spell it color
14:42:11 <sjanssen> MyCatVerbs: no, just that Americans are jerks and make people spell their way
14:42:16 <vixey> (if I was writing on paper with a pencil, that would be different)
14:42:34 <MyCatVerbs> sjanssen: comrade... that is what good ol' fashioned polite disdain is for. :)
14:42:56 <SamB_XP> so ... has anybody actually compared these colors to those listed in the X11 text file ...?
14:42:58 <roconnor> sjanssen: I've seen no such standarization.  e.g. the Poynton's ColorFAQ uses Color in the name of the document and Colour in the text of the document.
14:43:48 <roconnor> focus people: Names vs Name vs SVG :)
14:44:05 <SamB_XP> roconnor: but we are so much more emotional about Color vs. Colour
14:44:06 <vixey> roconnor: What is the data type though?
14:44:07 * sjanssen looks for his X11 spec to see if it names any colors
14:44:14 <MyCatVerbs> roconnor: SVG. :)
14:44:35 <roconnor> vixey: http://hackage.haskell.org/packages/archive/colour/0.0.0/doc/html/Data-Colour-Names.html
14:44:37 <lambdabot> Title: Data.Colour.Names, http://tinyurl.com/5ahaq9
14:44:44 <roconnor> Ugh
14:44:58 <roconnor> people will never think of importing Data.Colour.SVG to get a module of colour names.
14:45:17 <MyCatVerbs> roconnor: stuff them into Data.Colour ;P
14:45:19 <vixey> why not have Data.Colour give al the names??
14:45:20 <roconnor> they will want colour names and not find it, because they don't know anything about SVG.
14:45:40 <sjanssen> roconnor: Data.Colour.SVGNames
14:45:44 <roconnor> MyCatVerbs: I don't want to pollute the imported list of function... tan is particularly problematic.
14:45:56 <roconnor> sjanssen: SVGNames or SVGName?
14:45:57 <Cale> Data.Colour.Names ?
14:46:10 <Cale> Yes, it's already there :)
14:46:12 <Cale> hehe
14:46:12 <sjanssen> or Data.Colour.Names.SVG, perhaps with Data.Colour.Names re-exporting if you reall feel it should
14:46:59 <Cale> Or provide one function  lookupColour :: (Ord a, Floating a) => String -> Maybe (Colour a)
14:47:28 <roconnor> Cale: I was thinking of adding that function as well, but that would be additional.
14:48:32 <mib_tuaz4mi7> hello guys o/
14:48:42 <roconnor> Cale: You prefer Data.Colour.Names over Data.Colour.Name ?
14:48:46 <yitz> This should be in Graphics, not Data.
14:48:53 <SamB> http://markmail.org/message/nsqs5slfkcqew24o
14:48:54 <lambdabot> Title: color names in SVG-1.0 conflict with /usr/lib/X11/rgb.txt - John Ellson - org.w3 ...
14:48:55 <Cale> roconnor: I don't have a specific preference, actually.
14:49:01 <mib_tuaz4mi7> hey yitz, its the guy from earlier
14:49:12 <roconnor> yitz: perhaps.  I'm not sure this is entirely graphics specific.
14:49:16 <yitz> Data is becoming everyone's misc. garbage dump.
14:49:32 <roconnor> yitz: I really want some semantics for this heirarchy
14:49:34 <Cale> Hmm, is AffineSpace really the right name for that class?
14:49:36 <yitz> roconnor: you'll use it for sound or something?
14:50:29 <roconnor> yitz: Colour is mostly about human perception.
14:50:35 * BMeph dishonourably adds extra colours to sjanssen's files...
14:50:39 <roconnor> Psycology.Colour perhaps?
14:50:48 <mib_tuaz4mi7> i need to take a string, eg "I walk the dog" and print it on screen as a list alphabetically, but not sure how to implement this, should i count the length of the string and aligin it or something?
14:51:10 <mauke> a list of what?
14:51:13 <Cale> mib_tuaz4mi7: You need to print one string alphabetically?
14:51:24 <Cale> Like, sort the characters in it?
14:51:31 <Cale> > sort "I walk the dog"
14:51:33 <lambdabot>   "   Iadeghklotw"
14:51:46 <vixey> > (sort . words) "I walk the dog"
14:51:47 <roconnor> Cale: what's wrong with AffineSpace... other than it's location. :)
14:51:47 <mib_tuaz4mi7> like this:
14:51:47 <lambdabot>   ["I","dog","the","walk"]
14:52:04 <RayNbow> hmm... is there verb related to the mathematical notion of set union?
14:52:09 <mib_tuaz4mi7> dog *
14:52:13 <Cale> roconnor: I didn't realise that affine spaces were defined by the convex combinations of their elements.
14:52:13 <vixey> RayNbow: union
14:52:16 <mib_tuaz4mi7> i *
14:52:23 <mib_tuaz4mi7> the *
14:52:30 <roconnor> Cale: affine combinations... and I'm not sure they are defined by that.
14:52:35 <tromp_> [minBound..maxBound] :: [Ordering]
14:52:41 <tromp_> > [minBound..maxBound] :: [Ordering]
14:52:43 <lambdabot>   [LT,EQ,GT]
14:52:49 <vixey> > (unlines . map (++" *") . sort . words . map toLower) "I walk the dog"
14:52:49 <mauke> > sortBy (compare `on` map toLower) . words $ "I walk the dog"
14:52:50 <lambdabot>   "dog *\ni *\nthe *\nwalk *\n"
14:52:51 <lambdabot>   ["dog","I","the","walk"]
14:52:53 <BMeph> mib_tuaz4mi7: No, what you want is: Given a string, 1) Break it into a list of words 2) sort the words alphabetically("lexicographically"); 3)Print the list.
14:52:56 <roconnor> Cale: they are defined by a vector space action.
14:53:06 <SamB> roconnor: evidence at http://markmail.org/message/nsqs5slfkcqew24o
14:53:07 <lambdabot> Title: color names in SVG-1.0 conflict with /usr/lib/X11/rgb.txt - John Ellson - org.w3 ...
14:53:09 <Cale> roconnor: right...
14:53:11 <BMeph> ...never mind. Man, I got to learn how to type someday. ;)
14:53:14 <ddarius> Cale: http://ocw.mit.edu/OcwWeb/Electrical-Engineering-and-Computer-Science/6-046JFall-2005/LectureNotes/ Watch the 9th lecture.
14:53:16 <lambdabot> Title: MIT OpenCourseWare | Electrical Engineering and Computer Science | 6.046J Introd ..., http://tinyurl.com/58hjzd
14:53:22 <RayNbow> vixey: ah, so it's ok to use "to union" in a text?
14:53:27 <Cale> ddarius: What's this about?
14:53:27 <SamB> I just checked and those values are still the same in SVG-1.1
14:53:31 <RayNbow> (my dictionaries don't list it as a verb)
14:54:02 <vixey> RayNbow: I've heard it used as a verb often
14:54:05 <ddarius> It's a lecture from 6.046J Introduction to Algorithms on the analysis of randomly built binary search trees.
14:54:29 <Cale> Are you suggesting it just because it's cool, or is there a more specific reason? :)
14:54:53 <ddarius> Cale: I'm suggesting it because it mentions affine combinations and convexity.
14:54:57 <Cale> ah
14:55:41 <roconnor> SamB: thanks
14:56:37 <mib_tuaz4mi7> Please see this: http://hpaste.org/11420#a2
14:56:57 <mib_tuaz4mi7> it shows how i need to print the list and the code ive done so far
14:57:17 <roconnor> Cale: think we can recover an affine space from the affineCombination operator.
14:57:22 <roconnor> I suspect we can
14:57:30 <mib_tuaz4mi7> sorry took me a while :-(
14:57:35 <roconnor> by representing vectors by an equivalence relation on pairs of points.
14:57:42 <roconnor> but I'm not sure
14:57:56 <Cale> roconnor: Is affineCombination supposed to take coefficients which sum to less than 1?
14:58:02 <roconnor> Cale: nope
14:58:16 <roconnor> I'd call it convexCombination if that were the case.
14:58:52 <Cale> roconnor: It's just that you have that last element which takes "the remaining weight", which makes it seem somewaht like that.
14:58:57 <Cale> somewhat*
14:59:20 <roconnor> It is intended to be used as convex combinations in the common case.
14:59:28 <roconnor> perhaps I should make it more clear.
15:00:33 <roconnor> right we can make a vector space centred at black (or wherever)
15:00:44 <mib_tuaz4mi7> its basically a histogram output im after i think
15:00:57 <roconnor> c1 <+> c2 = affineCombo [(1,c1) (1,c2)] black
15:01:13 <roconnor> s <*> c1 = blend s c1 black
15:01:34 <mib_tuaz4mi7> i think i need to use putStr or something, i am so confused
15:04:17 <roconnor> Cale: how can you have no opinion between Name and Names? :)
15:04:48 <mib_tuaz4mi7> can anyone help me sorry?
15:04:55 <Cale> roconnor: They're equally obvious in meaning to me :)
15:05:06 <roconnor> mib_tuaz4mi7: what's the problem?
15:05:10 <Cale> mib_tuaz4mi7: sure
15:05:26 <mib_tuaz4mi7> http://hpaste.org/11420#a2
15:05:28 <roconnor> Cale: No standard on plurals for module names?
15:05:37 <ddarius> import Color.Names
15:05:56 <Botje> mib_tuaz4mi7: you probably want to use the group function
15:06:16 <Botje> since you sorted the list of words, idnetical words are right next to eachother
15:06:23 <Botje> and group groups them together into lists
15:06:25 <mib_tuaz4mi7> Ive put my code on there, i need to print the String eg "The rain in Spain falls mainly on the plain." like its displayed on that hpaste
15:06:31 <Botje> > group [1,2,3,3,3,4,5,5]
15:06:33 <lambdabot>   [[1],[2],[3,3,3],[4],[5,5]]
15:06:35 <roconnor> > group "Mississippi"
15:06:36 <lambdabot>   ["M","i","ss","i","ss","i","pp","i"]
15:06:37 <Cale> > group . sort . words $ "the rain in spain falls mainly on the plain"
15:06:38 <lambdabot>   [["falls"],["in"],["mainly"],["on"],["plain"],["rain"],["spain"],["the","th...
15:06:58 <Botje> mib_tuaz4mi7: so you can then count the length of each little list
15:07:57 <mib_tuaz4mi7> how do i print them as a list like shown on that hpaste
15:08:25 <Botje> can you use IO?
15:08:35 <Botje> wait, scratch that
15:08:45 <Botje> mib_tuaz4mi7: first transform everything like this:
15:09:02 <Botje> [("falls","*"),("in","*"),...,("the","**")]
15:09:16 <mib_tuaz4mi7> thanks for the help btw, really appreicate it
15:09:30 <Cale> I wonder what nice things we might be able to say about spaces together with a defined homotopy from the identity map on their Cartesian powers to their own identity map.
15:09:38 <Botje> then you can either transform it into a string and print that , or use mapM_ in combination with print
15:09:45 <mib_tuaz4mi7> how do i do that botje?
15:10:00 <mib_tuaz4mi7> get the string like 	[("falls","*"),("in","*"),...,("the","**")]
15:10:04 <Botje> mib_tuaz4mi7: that's for you to find out
15:10:21 <Botje> as we pointed out above, you can use group to group identical words together
15:10:36 <Cale> er...
15:10:37 <Botje> so in your case you'd get [["falls"],....,["the","the"]]
15:11:02 <mib_tuaz4mi7> i wont get two the's though
15:11:03 <Cale> actually, no, it's more like a homotopy between the projection maps.
15:11:05 <Botje> you need to count the length of each sublist and put it in a pair with the word
15:11:12 <Botje> mib_tuaz4mi7: you will if you do group . sort
15:11:20 <Botje> as Cale pointed out above
15:11:29 <Botje> 00:06 < Cale> > group . sort . words $ "the rain in spain falls mainly on the plain"
15:11:32 <Botje> 00:06 < lambdabot>
15:11:35 <Botje> [["falls"],["in"],["mainly"],["on"],["plain"],["rain"],["spain"],["the","th...
15:11:44 <mib_tuaz4mi7> crap sorry
15:12:21 <Cale> You have pi_1, pi_2: S x S -> S, and a homotopy between those is a continuous mapping H: S x S x [0,1] -> S such that H(x,y,0) = x and H(x,y,1) = y
15:12:47 <FunctorSalad> is there a haskell irc client in the works? :)
15:13:04 <RayNbow> @google haskell irc client
15:13:06 <lambdabot> http://www.haskell.org/hircules/
15:13:06 <lambdabot> Title: Hircules - an IRC client in haskell
15:13:10 <mib_tuaz4mi7> hmm let me try a few things and ill get back to you
15:13:13 <FunctorSalad> (would be more fun than learning the architecture of some other client)
15:13:21 <FunctorSalad> RayNbow: ah thx
15:13:22 <Botje> mib_tuaz4mi7: good luck
15:13:35 <Botje> i could just tell you, but finding it out is half the fun and/or learning experience :)
15:13:41 <mib_tuaz4mi7> thanks btw, this is all very new to me
15:13:55 <RayNbow> FunctorSalad: I'm looking for examples that haven't been made in Haskell yet :p
15:14:12 <Botje> if you have further questions, don't hesitate to ask!
15:14:32 <Cale> (of course, once we have that, there's an "obvious" way to form larger convex combinations of elements of S)
15:14:36 <FunctorSalad> RayNbow: hmm, last activity 2003 :(
15:14:51 <FunctorSalad> RayNbow: examples of what? not following
15:15:00 <Botje> FunctorSalad: maybe they decided it was perfect already :P
15:15:06 <luite> what would be a good way to debug a parsec parser? my parser has some errors, but I can't find out which parsers consume which input
15:15:27 <FunctorSalad> Botje: nah, starts with "I'm planning to add more features like ..."
15:15:37 <Botje> damn :(
15:16:21 <mib_tuaz4mi7> http://hpaste.org/11431
15:16:29 <mib_tuaz4mi7> am i on the right track?
15:17:08 <FunctorSalad> luite: I'm pretty sure parsec offers some mechanism for better, custom parsing error messages
15:17:10 <Botje> yes, except the type is wrong
15:17:14 <FunctorSalad> luite: I don't remember though
15:17:26 <Botje> words is String -> [String]
15:17:33 <wy> Hello!
15:17:35 <Botje> sort is [String] -> [String]
15:17:44 <Botje> and group is [String] -> [[String]]
15:17:51 <SamB> luite: <?> might be of use
15:17:52 <luite> FunctorSalad: I can only find the function parseTest, but I don't think that helps in this situation
15:17:56 <FunctorSalad> hello wy
15:18:02 <wy> Is Template Haskell still in GHC? I can't seem to compile the TH programs with it
15:18:37 <luite> SamB: I do know the error, and the location in the file, but I don't exactly know how it got there
15:18:46 <RayNbow> FunctorSalad: with that remark I meant to say that I'm surprised that every time I look for a <x> client written in Haskell, I always get a hit on Google...
15:18:50 <ddarius> America has a lot of Helium.
15:18:58 <SamB> luite: how what got where?
15:19:04 <dolio> wy: Is it possible you don't have the template-haskell package installed?
15:19:04 <mib_tuaz4mi7> so it would be this  groupWords :: String -> [[String]]? as were grouping the words?
15:19:15 <Botje> yes
15:19:19 <RayNbow> so I'm still waiting for the day to come that Google says: "Nope, I don't know anything about an <x> client written in Haskell"
15:19:23 <RayNbow> for some value of <x>
15:19:34 <wy> dolio: Do I have to install a package for it? I can't seem to find up-to-date information about TH.
15:19:41 <FunctorSalad> RayNbow: kitchen sink? ;)
15:19:58 <Botje> RayNbow: i'm waiting for the day when google says "nope, i don't know any type of program not written in haskell"
15:20:03 <mib_tuaz4mi7> cool thanks botje
15:20:10 <FunctorSalad> RayNbow: asking on IRC is more fun though. don't have to wade through google and might get a conversation started
15:20:35 <dolio> wy: Well, it probably depends on how you installed it. Does 'ghc-pkg list template-haskell' show a package?
15:20:35 <FunctorSalad> e.g., maybe someone wanted to start coding one as well
15:21:16 <luite> SamB: which parsers are already used and which input they consumed, before the parser that gives an error arrived at that location in the input
15:21:18 <wy> dolio: yes. It's 2.2.0.0
15:21:30 <wy> Do I need a switch for the compiler?
15:21:32 <Cale> I suppose it's kind of just a fancy way of saying that the space is path connected...
15:21:38 <dolio> Well, that's not it, then.  What error are you getting.
15:21:48 <dolio> Oh, yes. You need TemplateHaskell in the LANGUAGE pragmas or something.
15:22:25 <wy> dolio: parse error on input '|' from quasiquotes
15:22:25 <dolio> It is an extension, after all.
15:22:39 <wy> dolio: How do I do that?
15:22:49 <dolio> Oh, if you're using quasiquotes, you probably need a flag for that, too.
15:23:01 <dolio> wy: {-# LANGUAGE TemplateHaskell #-} at the top of the file.
15:23:04 <mib_tuaz4mi7> hmm, now that i have grouped the words, how do i print them as a list on winhugs?
15:24:05 <mib_tuaz4mi7> the two 'the' would be printed eg 'the **'
15:24:06 <dolio> Or -XTemplateHaskell on the command line when you're compiling.
15:24:29 <dolio> To find the quasiquotes flag use 'ghc --supported-languages' and grep for Quasi or something.
15:24:47 <mib_tuaz4mi7> the two ** would mean two occurances of the
15:25:05 <wy> dolio: It works. Thank you!
15:25:16 <RayNbow> just wondering... are there any efficient ways of computing the k-th n-smooth number?
15:25:24 <myrkraverk> hi all, I'm trying to go through the tutorial on http://lisperati.com/haskell/ ; however, hugs (what is available as packag for my system) chokes on import Data.Ord -- is there a way for me to fix that?
15:25:38 * RayNbow is currently just generating all the n-smooth numbers and then take the k-th number
15:26:06 <FunctorSalad> one of the nice things about this channel is that there's no "rtfm"... the assumption that it's always better to rtm first before asking on IRC is stupid. noone is forced to answer elementary questions if he doesn't want to
15:26:23 <Cale> myrkraverk: oh, that's unfortunate...
15:26:34 <Cale> myrkraverk: Which platform, btw?
15:26:39 <roconnor> manuals suck compared to humans.
15:26:42 <myrkraverk> solaris
15:27:16 <SamB_XP> anyway, finding the manual can be a significant portion of the battle ;-)
15:27:26 <Cale> myrkraverk: Which version of Hugs is it?
15:27:28 <jsn> myrkraverk: there is a GHC package for Solaris
15:27:28 <roconnor> ... interupting humans isn't so good, but you can't interupt people on IRC.  They are obviously looking to waste their time :)
15:27:35 <myrkraverk> jsn, where?
15:27:42 <jsn> just a minute
15:27:47 <myrkraverk> Cale, I don't know, it only says something about 2003
15:27:53 <mokus> roconnor: plus there's always /ignore ;-)
15:27:58 <SamB_XP> roconnor: also, it's impossible to interrupt a privmsg via IRC
15:28:09 <Cale> myrkraverk: Ah, okay, that's rather old. There's a Sep2006 version.
15:28:15 <myrkraverk> ah, ok
15:28:20 <FunctorSalad> roconnor: yeah. the rtfm camp argues that the asker is stealing his time.... but first, it takes a lot less time for an expert to give a pointer than for a newb to rtfm, so it's a positive-sum game. second, many people actually enjoy answering
15:28:22 <jsn> http://haskell.org/ghc/download_ghc_683.html#binaries
15:28:29 <myrkraverk> jsn, thanks
15:28:31 <jsn> myrkraverk: there you go
15:28:33 <lambdabot> Title: GHC: Download version 6.8.3
15:28:34 <Cale> myrkraverk: But if you can get GHC, that would be better.
15:28:55 <mokus> i don't know that it's necessarily positive sum when you factor in attrition, but I'm still anti-rtfm
15:29:04 <roconnor> FunctorSalad: I learn a lot by answering "n00b" questions.  Rethinking the basics often gives me more insight.
15:29:14 <Cale> I seem to recall that if you're on Solaris 9, you might have problems.
15:29:19 <jsn> oh?
15:29:22 <Cale> But 8 and 10 are okay.
15:29:23 <roconnor> allows one to refect and extrapolate.
15:29:47 <SamB_XP> suggesting that people read the documentation isn't wrong ... but it works better if you point them to a specific portion ;-)
15:30:12 <mokus> yea, and it works better if you can do it without the 'f' in rtfm
15:30:12 <yitz> here on #haskell, we're not the rtfm crowd, we're the atf# crowd.
15:30:19 <roconnor> Basic quesitions take on new meaning in the context of all the new knowledge since I last considered the basic questions.
15:30:21 <myrkraverk> atf?
15:30:26 <Plareplane> ask the fucking question
15:30:30 <jsn> on this channel, we are relatively insulated from real n00bs, though
15:30:33 <SamB_XP> isn't that spelled atfq?
15:30:33 <yitz> Ask the Fine #haskell
15:30:42 <Plareplane> ah, that's more polite :)
15:30:43 <mib_tuaz4mi7> how could i print a string once ive grouped it as a list?
15:31:05 <jsn> mib_tuaz4mi7: a string is a list
15:31:06 <yitz> Ask the Friendly #haskell
15:31:15 <RayNbow> I think mib_tuaz4mi7 means a list of strings
15:31:33 <FunctorSalad> mokus: I'm not suggesting that people let themselves be attritioned (?) :) when I'm close to attrition, I just let someone else answer rather than saying 'rtfm'
15:31:39 <mib_tuaz4mi7> yea, like this:http://hpaste.org/11420#a1
15:31:44 <roconnor> mib_tuaz4mi7: mapM_ will apply an action to each element of a list.  So mapM_ putStrLn foo will putStrLn each element of foo.
15:31:47 <BMeph> roconnor: Studies have shown that professors that teach elementary classes think better, because they're more familiar with the foundations of the subject. :)
15:31:49 <jsn> mib_tuaz4mi7: putStrLn $ unwords listOfStrings
15:31:55 <mokus> FunctorSalad: attrition happens is my point
15:32:03 <roconnor> BMeph: I beleive it.
15:32:17 <SamB_XP> BMeph: is THAT why this one guy likes to teach Circuits 1 but not Circuits 2 ...
15:32:17 <yitz> mib_tuaz4mi7: or unlines
15:32:19 <FunctorSalad> Roey: I agree with what you previously said too
15:32:25 <FunctorSalad> err roconnor not Roey
15:32:44 <mokus> 1 minute for 1 expert to answer a question counts more than 10 min for a noob to look it up, because they're a lot more noobs than experts
15:32:46 <RayNbow> too many R-nicks in this channel :p
15:33:00 <mib_tuaz4mi7> im confused sorry
15:33:00 <SamB_XP> mokus: but you didn't factor in the lurkers
15:33:03 <mokus> at least, that's my conjecture
15:33:14 <mokus> ah, true - but do they have the same question?
15:33:21 <FunctorSalad> mokus: okay, that's a point
15:33:27 <mib_tuaz4mi7> it could be any random string i input
15:33:33 <SamB_XP> or the fact that most of us are not actual experts on the subjects of many of the questions we answer ;-)
15:33:40 <mokus> heh
15:33:56 <SamB_XP> mokus: well, often they benefit from the answer
15:34:04 <luite> I lurkalot, but even if I don't have questions, I can still learn from answers
15:34:08 <ddarius> There isn't a manual for Haskell, but there are enough very high quality educational resources that referring to them is better for everyone.  One is not going to reproduce 700+ pages of text, in a minute on IRC.
15:34:16 <RayNbow> > unwords ["hello", "#haskell"]
15:34:17 <lambdabot>   "hello #haskell"
15:34:39 <FunctorSalad> mokus: I was thinking less of things that are in clear sight in the manual, more of things like "in which of the 200 configuration files do I put this"
15:34:42 <jsn> mib_tuaz4mi7: maybe we don't understand the question? you have a list of strings or ...?
15:34:48 <BMeph> SamB_XP: You'd have to ask "this one guy"... :)
15:35:11 <SamB_XP> BMeph: hmm, he tends to be a bit grumpy though
15:35:21 <BMeph> RayNbow: Too many RTFNicks...? ;)
15:35:27 <mokus> FunctorSalad: I'm with you - just pointing out that it's not clear-cut whether there's a time advantage on the side of the answerer
15:35:35 <yitz> SamB_XP: we're not experts, but one of Cale or quicksilver is usually here to back us up.
15:35:40 <FunctorSalad> *nod*
15:36:09 <yitz> so us answering is certainly efficient use of *their* time
15:36:12 <jsn> the ultimate question, in my mind, is how much effort is the asker putting in, and how much more would they have to put in to do it themselves? if they want to change a config option, and the effort they'd have to go to is reading the source code, i think it's okay to answer their question (true story -- mu-conference)
15:36:21 <BMeph> yitz: Bingo! :)
15:36:37 <SamB_XP> or "which of these 200 html files that make up the manual might help me to figure this out"
15:37:32 <ddarius> jsn: For highly specific questions, asking is fine.  For instances when very broad knowledge is required ["Teach me how to Haskell"], books and such are likely better for all.
15:37:36 <FunctorSalad> yitz: heh. kinda like the court / appeals system
15:37:46 <jsn> ddarius: i agree
15:37:55 <mokus> SamB_XP: or "which of these 35 howtos is actually helpful"
15:38:00 <SamB_XP> ddarius: well, few people actually ask "teach me haskell"
15:38:22 <jsn> well, sometimes they as questions that are tantamount to that, though
15:38:29 <ddarius> SamB_XP: There are several that essentially do.
15:38:44 <yitz> another thing - we should add a @homework command to \bot, similar to @hpaste, that gives the url to the homework page on the wiki.
15:38:45 <SamB_XP> ddarius: hmm ?
15:38:49 <mib_tuaz4mi7> hmm sorry if im vague jsn, dont mean to be
15:39:11 <BMeph> SamB_XP: More like "MOAR Haskill plzkthxbai!" ;;p
15:39:22 <FunctorSalad> BMeph: :)
15:39:35 <SamB_XP> BMeph: aren't they just asking us to email them some urls for papers ?
15:39:57 <ddarius> SamB_XP: If you don't know how to program Haskell at all and you want (or need) to do something even remotely non-trivial, you're first going to have to learn Haskell.
15:40:18 <SamB_XP> ddarius: hmm.
15:40:26 <BMeph> SamB_XP: Heh-heh, they may not have believed they were,... >;)
15:40:46 <mib_tuaz4mi7> The output string contains newline characters terminating the lines. eg like this: " falls *\n in *\n mainly *\n on *\n plain *\n rain *\n spain ...
15:40:49 <jsn> mib_tuaz4mi7: so, you sort the words and then put them back in a string?
15:40:49 <SamB_XP> or, heck, we could send them the postscript files ;-P
15:41:13 <jsn> so you have a string with the words in it
15:41:42 <jsn> mib_tuaz4mi7: so then you can break it up again, and put newlines at the, like:
15:41:53 <mib_tuaz4mi7> yea i have "The rain in Spain falls mainly on the plain.")
15:42:05 <mib_tuaz4mi7> as a example sorry
15:42:06 <jsn> > unlines . words $ "The rain in Spain falls mainly on the plain."
15:42:07 <lambdabot>   "The\nrain\nin\nSpain\nfalls\nmainly\non\nthe\nplain.\n"
15:42:54 <jsn> > intercalate " *\n" . words $ "The rain in Spain falls mainly on the plain."
15:42:55 <lambdabot>   "The *\nrain *\nin *\nSpain *\nfalls *\nmainly *\non *\nthe *\nplain."
15:43:03 <jsn> etcetera
15:43:23 <myrkraverk> etcetera, etcetera -- what a lovely name
15:43:44 <Saizan> jsn: the * are supposed to represent how many times a word occurs in the sentence, i guess
15:43:50 <jsn> oh
15:44:16 <mib_tuaz4mi7> yea i think thats right, the questions i got are very vague
15:44:32 <jsn> myrkraverk: if i have a little girl, i will name her etcetera
15:44:42 <jsn> little &c. will call here
15:44:47 <jsn> s/here/her/
15:44:58 <Cale> s/will/we'll/
15:44:58 <BMeph> myrkraverk: Ceteris paribus... ;)
15:45:02 <Pseudonym> My next child will be called "); drop table person; --"
15:45:02 <mib_tuaz4mi7> i think the output needs to be like this " falls *\n in *\n mainly *\n on *\n plain *\n rain *\n spain ...
15:45:10 <jsn> Cale: hehe
15:45:55 <jsn> i fear my spelling tables are keyed by sound and not by meaning :(
15:46:02 <mib_tuaz4mi7> The output string contains newline characters terminating the lines
15:46:27 <mib_tuaz4mi7> man i am getting more and more confused lol
15:46:47 <jeffz> mib_tuaz4mi7: I think the reason you are confused is that you have not clearly defined the original problem.
15:46:48 <BMeph> jsn: Could be worse - maybe Pseudonym's future kid got you to delete those tables... ;p
15:47:59 <myrkraverk> Pseudonym, hahahahahah
15:48:01 <jsn> BMeph: Pseudonym's child might be taken down by a DMCA notice :)
15:48:41 <yitz> @fact-set homework Please see this page about homework: http://www.haskell.org/haskellwiki/Homework_help
15:48:41 <lambdabot> Fact recorded.
15:49:00 <yitz> @fact homework
15:49:01 <lambdabot> homework: Please see this page about homework: http://www.haskell.org/haskellwiki/Homework_help
15:49:15 <yitz> ok, it'll do for now.
15:49:30 <Pseudonym> This reminds me of the person who, after being charged 20 pounds for a 10 pound overdraft, changed his name to Yorkshire Bank PLC Are Fascist Bastards, and insisted they change the name on his account to that.
15:49:45 <BMeph> jsn: I'm counting on the DMCA getting challenged off the books. :)
15:49:50 <Pseudonym> They refused, but allowed Mr. Bastards to close his account and get his money back.
15:49:58 <mib_tuaz4mi7> hmmm let me try this to explain it: http://hpaste.org/11432
15:50:06 <mib_tuaz4mi7> this is my task
15:51:03 <mib_tuaz4mi7> hope this helps to explain what i am trying to do
15:51:38 <jeffz> mib_tuaz4mi7: it looks similar to an excercise from K&R
15:51:58 <mib_tuaz4mi7> whats k&r m8?
15:52:10 <jeffz> oh, it's a book, The C Programming Language by K&R
15:52:45 <mib_tuaz4mi7> ohhh, maybe thats what they based it on, im having a lot of trouble implementing the print part
15:52:46 <jeffz> K&R are Brian W. Kernighan and  Dennis M. Ritchie
15:53:10 <mib_tuaz4mi7> managed to sort, lower the case and remove punctuation
15:53:40 <Saizan> mib_tuaz4mi7: before printing you want to implement the counting of the occurrences
15:55:42 <mib_tuaz4mi7> hmm, ive grouped them
15:57:12 <mib_tuaz4mi7> im not sure how to count each occurance though
15:57:16 <Cale> > map (\x -> (head x, length x)) . group . sort $ "mississippi"
15:57:17 <lambdabot>   [('i',4),('m',1),('p',2),('s',4)]
15:58:25 <mib_tuaz4mi7> dont think i can use maps
15:58:39 <Cale> why?
15:58:47 <mib_tuaz4mi7> i think i can only use basic functions
15:58:53 <yitz> > map (\x -> (head x, length x)) . group . sort . words . map toLower $ "The rain in spain falls mainly on the plain"
15:58:54 <Cale> You're already using group...
15:58:55 <lambdabot>   [("falls",1),("in",1),("mainly",1),("on",1),("plain",1),("rain",1),("spain"...
15:59:06 <lament> what's more basic than map
15:59:07 <Cale> and sort
15:59:09 <yitz> oh, come on lambdabot
15:59:11 <lament> fmap, i guess
15:59:37 <mib_tuaz4mi7> i dont know sorry lol
15:59:44 <Cale> mib_tuaz4mi7: map is sort of fundamental to the way we program in Haskell...
16:00:07 <int-e> ndm++ (tagsoup is cool)
16:00:09 <Cale> mib_tuaz4mi7: you could write a function to do it in an explicit recursive manner, but it would go against the grain of how we do things.
16:00:52 <mib_tuaz4mi7> its awkward, i have to use the prtStr too but even in the task it says not to make sense of it
16:01:12 <SamB_XP> ???
16:01:17 <lament> @hoogle prtStr
16:01:17 <lambdabot> No results found
16:01:27 <mib_tuaz4mi7> putStr sorry
16:03:23 <Saizan> you could write map yourself
16:03:54 <mib_tuaz4mi7> i really dont know how, ive only just started learning haskell
16:05:33 <Cale> mib_tuaz4mi7: Okay, so in order to understand putStr, basically it turns a string into an action which if executed would print that string on the screen.
16:06:14 <Cale> mib_tuaz4mi7: You eventually define main to be an action, and it could even be the result of putStr (assuming your program doesn't have to do any other I/O)
16:06:14 <mib_tuaz4mi7> im gonna sleep i think, think it over 2mora, thanks for all the help, i do really appreciate it, and being patient with me. Take it easy o/
16:06:36 <Cale> Ah, see you around :)
16:06:46 <cjb> Is there a "flip ($)" in the stdlib somewhere?
16:06:51 <mib_tuaz4mi7> prob be back on 2mora lol
16:08:24 <int-e> @hoogle a -> (a -> b) -> b
16:08:25 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
16:08:25 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
16:08:25 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
16:09:27 <cjb> int-e: tried that already :)
16:10:52 <ddarius> :t runCont . return
16:10:53 <lambdabot> forall r a. a -> (a -> r) -> r
16:11:40 <yitz> but then you might as well say flip ($)
16:12:05 <roconnor> > 0xf0
16:12:07 <lambdabot>   240
16:14:00 <int-e> cjb: flip id  isn't awfully much to type anyway.
16:14:58 <yitz> @type (runIdentity .) . flip (return .)
16:14:58 <ddarius> let c = flip; i = id in c i
16:14:59 <lambdabot> forall b a. a -> (a -> b) -> b
16:16:02 <int-e> . o O ( let di = flip id )
16:16:32 <wy> dolio: Do you use TH a lot?
16:17:36 <yitz> @type flip id
16:17:37 <lambdabot> forall b c. b -> (b -> c) -> c
16:17:51 <int-e> @src ($)
16:17:51 <lambdabot> f $ x = f x
16:17:52 <wy> I got some error that "GHC stage restriction: `g' is used in a top-level splice, and must be imported, not defined locally
16:18:14 <yitz> @type curry id
16:18:15 <lambdabot> forall a b. a -> b -> (a, b)
16:18:26 <int-e> wy: so define 'g' in a separate module
16:18:43 <int-e> wy: import the module, then use the function in the splice.
16:18:46 <wy> int-e: but... that's not reasonable
16:19:06 <wy> Does that mean TH hasn't implemented "hygien"?
16:20:10 <int-e> wy: staging doesn't really work in haskell where definitions can be mutually recursive without limitations within a module
16:20:51 <wy> int-e: I think this is just a trick to avoid variable capturing in binding constructs
16:22:47 <wy> The simplest example from SPJ's notes can't work
16:22:51 <roconnor> ahhhhhhhh! why in vi does my s/^[a-z]+/ not work but s/^[a-z][a-z]*/ does work?
16:23:01 * roconnor 's head explodes
16:23:30 <ddarius> \+ maybe?
16:23:48 <roconnor> yes
16:23:50 <roconnor> that's fucked up
16:23:56 <roconnor> wtf?
16:24:06 <ddarius> :set magic (or something)
16:24:23 <roconnor> I hope there is a good reason for this retardedness
16:24:42 <roconnor> is + and RE extensions?
16:24:46 <roconnor> extension
16:24:47 <Cale> Well, perhaps it was decided that more people want + to be a literal +
16:24:53 <Cale> I think of it as an extension.
16:25:05 <edwardk> roconnor: yes
16:25:43 <int-e> wy: which notes?
16:25:56 <edwardk> roconnor: vim unfortunately has a ton of \'s required because they implemented the original regex specification way back in the day + ( ), etc are extensions to that
16:26:01 <wy> http://research.microsoft.com/~simonpj/tmp/notes2.ps
16:26:17 <Cale> Regular expressions have disjunction, concatenation, their respective identities, and Kleene star.
16:26:23 <Cale> Everything else is sugar :)
16:26:28 <wy> int-e: The first exmaple
16:33:56 <roconnor> edwardk: thanks
16:34:48 <Cale> One thing I'm slightly surprised about is the general lack of notation for other valid operations on regular languages. The intersection or difference of two regular languages is regular, and the complement of a regular language is regular, so why isn't there any notation for that in most regex libraries?
16:35:32 <int-e> wy: which is illtyped anyway, hmm.
16:35:41 <Cale> Why do we get silly things like x+ as a shorthand for xx* instead?
16:38:12 <wy> int-e: Yes. I guess they meant g y = [| $x + $y |]
16:38:32 <roconnor> Cale: something about efficency
16:38:35 <roconnor> possibly historical
16:38:39 <int-e> Cale: neither complement nor intersection are simple operations on NFAs.
16:38:56 <Cale> They're simpler for the machine to do than for me to do it by hand.
16:41:59 <wy> int-e: You said "staging doesn't really work in haskell where definitions can be mutually recursive without limitations within a module". I don't quite understand.
16:42:26 <wy> int-e: should change t to "t x = $(g 4)" and it will work
16:42:58 * EmielRegis g'nite
17:02:21 <heatsink> What's a good idiom for doing subtyping where most functions expect to see only a subset of a data type's constructors?
17:03:03 <roconnor> another datatype with an injection?
17:03:17 <jsn> heatsink: you mean, sub-typing and you use the same constructor names over and over again?
17:03:56 <heatsink> jsn: I mean, most functions expect not to see some of the data type's possible values.
17:05:19 <heatsink> roconnor's solution would do it.  I wish there were a solution that didn't involve allocating extra objects, though.
17:05:39 <mgsloan> heatsink: newtype, or, more weakly, type synonyms could help
17:05:55 <Cale> There's always the somewhat unsafe way of just not handling some cases.
17:05:56 <heatsink> jsn: For example, I have data Obj = DefinedObj ... | UndefinedObj ...; most functions expect to see only the DefinedObj constructor.
17:06:23 <heatsink> mgsloan: That's a pretty good idea, actually.
17:06:50 <jsn> heatsink: that seems basically unsafe
17:07:04 <dolio> Define all your types as fixed points of coproducts of functors. :)
17:07:16 <heatsink> argh, categoryspeak.
17:07:18 <dolio> One for each sub-type.
17:07:42 <roconnor> what dolio said
17:09:00 * heatsink co-understands what dolio said
17:10:55 <dolio> Do Objs contain other Objs?
17:11:26 <heatsink> yes
17:12:02 <heatsink> at least, DefinedObjs do.
17:13:07 <dolio> Can DefinedObjs contain UndefinedOjbs?
17:13:11 <heatsink> yes
17:15:25 <heatsink> Okay, I think I get the fixed point and the coproduct part.  Where does the functor come in?
17:16:55 <dolio> Well, in initial algebra semantics, more or less all data types are the fixed point of functors.
17:17:03 <SamB_XP> @quote Ruby on Rails
17:17:03 <lambdabot> No quotes for this person. :(
17:17:07 <SamB_XP> @quote rails
17:17:07 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
17:17:24 <int-e> wy: I've digged a bit further. The story is that all the template haskell stuff for a module happens while type checking, before any code is generated for the module.
17:17:31 <dolio> So, lists are the fixed point of 'data ListShape a x = Nil | Cons a x'.
17:17:56 <dolio> Or, [a] = Fix (ListShape a), that is.
17:17:57 <BMeph> CT jargon aside, just seeing the structure for lists shines a whole new light on the lisp trick for them. (To me, anyway.)
17:17:59 <int-e> wy: as a result, if you define a toplevel function in a module, while it would make sense in principle to use it in splices, the compiler can't, because there is no code to run for them.
17:18:32 <int-e> wy: so, as the manual says, "You can only run a function at compile time if it is imported from another module. That is, you can't define a function in a module, and call it from within a splice in the same module. (It would make sense to do so, but it's hard to implement.)"
17:19:04 <heatsink> ListShape a = mu x. Nil | Cons a x
17:19:32 <dolio> That's actually list, not list shape.
17:19:43 <dolio> List a = mu x. ListShape a x
17:19:56 <heatsink> oh, I see.
17:20:06 <BMeph> List a = mu b. Maybe (a,b) -- heh-heh. ;)
17:20:29 <dolio> Anyhow, if you define 'data DefinedObj x = DefinedObj ...' and 'data UndefinedObj x = UndefinedObj ...' ...
17:20:36 <BMeph> That explains unfoldr's goofy type signature for me so well. :)
17:21:08 <int-e> BMeph: right :)
17:21:11 <ddarius> BMeph: There is little CT about that.
17:21:12 <dolio> Then 'Obj = mu x. (DefinedObj x + UndefinedOjb x)'
17:21:42 <wy> int-e: I still don't see it in the example.
17:21:49 <dolio> But, if you can somehow show that you have 'mu x. DefinedObj x', you don't have to worry about undefined objects.
17:22:30 <heatsink> Because UndefinedObj is not involved in the recursion?
17:23:06 <dolio> Right. In that case, you have the fixed point of the defined object functor, not the either defined or undefined object functors.
17:25:25 <int-e> wy: to compile t x = $(g 4), the compiler needs code to run for g.
17:25:46 <wy> int-e: I see. The compiler can't run part of a file?
17:26:38 <int-e> wy: right, because it first typechecks the whole module (which already involves some staging for TH - as explained in the paper) and then generates code for that.
17:28:26 <tromp> hmm, why does the following give an error
17:28:28 <tromp> a = do line <- getLine; return a where a = line
17:28:43 <tromp> it says:  Not in scope: `line'
17:28:57 <heatsink> tromp: line is only in scope over "return a"
17:29:07 <int-e> tromp: because it's do { line <- getLine; return a } where a = line
17:29:39 <int-e> do line <- getLine; let a = line; return a  will work
17:30:02 <int-e> oh, seeing the desugaring may help
17:30:08 <int-e> @undo do line <- getLine; return a
17:30:08 <lambdabot> getLine >>= \ line -> return a
17:30:18 <heatsink> dolio: Thanks, I understand a little more now.
17:30:35 <int-e> getLine >>= \ line -> return a
17:30:45 <tromp> thx, int-e
17:30:53 <int-e> a = (getLine >>= \ line -> return a) where a = line
17:31:28 <int-e> @undo do line <- getLine; let a = line; return a
17:31:29 <lambdabot>  Parse error at end of input
17:31:39 <int-e> @undo do line <- getLine; let { a = line }; return a
17:31:39 <lambdabot> getLine >>= \ line -> let { a = line} in return a
17:32:11 * int-e keeps forgetting about the need to put braces there.
17:33:14 <tromp> my program wld look clearer though if i can define a below the return
17:33:24 <tromp> i guess that's not possible to achieve
17:33:53 <wy> int-e: so it will make the definition or2 x y = $([| let t = $x in if t then t else $y |]) unusable?
17:33:55 <int-e> tromp: define a function with suitable arguments instead? (a line = ...)
17:35:05 <tromp> yes, with some passing arguments
17:36:59 <int-e> wy: or2 x y = [| let t = $x in if t then t else $y |]  will work.
17:37:16 <int-e> wy: what was the extra $() supposed to do?
17:38:39 <wy> int-e: If I don't use $(), it will return an ExpQ, instead of the result
17:39:17 * Peaker gets a knee-jerk reaction when seeing Perlish/shellish sigils
17:41:11 <int-e> wy: well, to use or2, you'll write  $(or2 [| ... |] [| ... |])
17:47:44 <int-e> @index ($+$)
17:47:44 <lambdabot> Language.Haskell.TH.PprLib, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
17:47:48 <int-e> Peaker: ;-)
17:51:57 <wy> int-e: What's that?
17:52:45 <wy> :t  ($+$)
17:52:46 <lambdabot> Doc -> Doc -> Doc
17:54:21 <SamB_XP> > text "hi!" $+$ text "bye!"
17:54:22 <lambdabot>   hi!
17:54:22 <lambdabot>  bye!
17:54:47 <SamB_XP> > text "woooo" <+> (text "hi!" $+$ text "bye!")
17:54:48 <lambdabot>       Ambiguous occurrence `<+>'
17:54:49 <lambdabot>      It could refer to either `Control.Arrow...
17:55:00 <SamB_XP> > text "woooo" <> (text "hi!" $+$ text "bye!")
17:55:01 <lambdabot>   woooohi!
17:55:01 <lambdabot>       bye!
17:55:33 <SamB_XP> > text "woooo" <> (text "hi!" $+$ text "bye!") <> text "ooooow"
17:55:35 <lambdabot>   woooohi!
17:55:35 <lambdabot>       bye!ooooow
17:55:47 <SamB_XP> > text "woooo" <> (text "hi!" $+$ text "byeeeee!") <> text "ooooow"
17:55:49 <lambdabot>   woooohi!
17:55:49 <lambdabot>       byeeeee!ooooow
17:56:09 <int-e> > text "hi!" $$ nest 10 (text "bye!")
17:56:10 <lambdabot>   hi!       bye!
17:56:13 <int-e> > text "hi!" $+$ nest 10 (text "bye!")
17:56:15 <lambdabot>   hi!
17:56:15 <lambdabot>            bye!
17:56:35 * SamB_XP didn't remember what it did
17:57:09 <SamB_XP> > text "hi!\nbye!"
17:57:10 <lambdabot>   hi!
17:57:10 <lambdabot>  bye!
17:57:34 <SamB_XP> why are there TWO spaces before the "hi!" ?
17:57:39 <SamB_XP> > 1
17:57:40 <lambdabot>   1
17:57:53 <SamB_XP> it messes up the indentation ...
17:57:55 <int-e> that's the difference between $+$ and $$ - both will (vertically) append documents, but $$ will start the first line of the second document on the last line as the first document if it's indented (nested) far enough.
17:58:44 <int-e> > error "foo"
17:58:46 <lambdabot>   * Exception: foo
17:59:05 <int-e> no idea. mueval is to blame, probably.
17:59:22 <SamB_XP> GWERN!!!!
17:59:36 <SamB_XP> @tell gwern mueval is to blame
17:59:36 <lambdabot> Consider it noted.
18:01:25 <thoughtpolice> excellent note :]
18:01:42 <SamB_XP> @tell gwern ... for messing up the indentation of pretty-printing
18:01:42 <lambdabot> Consider it noted.
18:02:11 <SamB_XP> thoughtpolice: I was expecting someone else to add the informative bit
18:02:24 <int-e> . o O ( @tell gwern ... probably )
18:02:32 <thoughtpolice> SamB_XP: hehehe
18:02:49 <Peaker> I'm looking up at all that and I'm wondering if that's some sort of LaTeX DSL for Haskell, and if not, is there one? :)
18:03:13 <SamB_XP> Peaker: heh
18:03:25 <SamB_XP> um, I don't think so
18:03:36 <Peaker> Haskell is the new language of languages -- why write another parser ever again?
18:03:50 <SamB_XP> and I haven't a clue how to implement lout in it either
18:04:29 <int-e> Peaker: because writing parsers is easy ;)
18:05:03 <Peaker> int-e: in a parsed language, you cannot arbitrarily use Haskell code to generate your building blocks ;)
18:05:22 <Peaker> int-e: and you end up writing text generators or something ugly like that :(
18:08:40 * heatsink would like a HaX implementation
18:09:00 <SamB_XP> yay! hax!
18:09:03 <SamB_XP> I love hax
18:09:12 <jeffz> spreadsheet?
18:09:29 <SamB_XP> ???
18:09:37 <jeffz> heh, what's HaX?
18:09:43 <heatsink> Like TeX, but you can write functions to control programs in Haskell.
18:09:45 <SamB_XP> where hax ~= hacks
18:09:53 <heatsink> erm
18:09:57 <heatsink> functions to control layout
18:10:47 <heatsink> I should learn LuaTeX sometime.
18:27:44 <petekaz> blist
18:31:21 <wy> Is there some function I can use to show generated TH code?
18:51:48 <Plouj> hi
18:51:59 <Plouj> "In Haskell, return simply takes a normal value (for instance, one of type IO Int) and makes it into an action that returns the given value (for instance, the value of type Int)." - is this really correct?
18:53:12 <Philonous> If by action you mean the monadic value - yes
18:53:24 <Plouj> that's just what YAHT says
18:53:31 <Philonous> return lifts a value into a monad
18:53:52 <Plouj> I don't see how that not conflict with "The return function is a function that takes a value of type a and returns an action of type IO a. Thus, the type of return () is IO ()."
18:53:53 <Philonous> Well, it is at best ambiguous
18:54:55 <Plouj> I don't see how () is of type "IO Int" or an action.
18:55:28 <bd_> It's not
18:55:33 <bd_> 'return 42' would be IO Int
18:55:37 <Philonous> Well, this is really strange
18:55:39 <bd_> or to be more precise, Num n => IO n
18:55:58 <Philonous> Since "IO Int" isn't a "normal" action to begin with, it's already monadic
18:56:23 <Plouj> so, does someone have a better way to say it?
18:56:29 <bd_> yeah, I think the types are backwards in that example
18:56:39 <cjb> Plouj: return lifts a value into a monadic form.
18:56:40 <Plouj> the first or second sentence, bd_?
18:56:49 <cjb> Plouj: consider
18:56:53 <Plouj> cjb: but you can't say that someone who doesn't know what "lift" or "monad" is
18:57:10 <bd_> return takes a normal value (eg, Int), and produces an action (eg, something of tyoe IO Int) which simply returns that constant value.
18:57:12 <cjb> > a <- 2; return 2
18:57:13 <lambdabot>   <no location info>: parse error on input `<-'
18:57:19 <Philonous> Plouj: Well, if you don't know what a monad is it is hard to describe what return does
18:57:21 <cjb> > do a <- 2; return 2
18:57:23 <lambdabot>       No instance for (Show (t t2))
18:57:23 <lambdabot>        arising from a use of `show' at <i...
18:57:30 <cjb> > do a <- 2; return (2)
18:57:31 <lambdabot>       No instance for (Show (t t2))
18:57:31 <lambdabot>        arising from a use of `show' at <i...
18:57:37 <Plouj> bd_: ok, I'll change it :)
18:57:41 <cjb> .. this is what I get for trying to write to lambdabot :)
18:57:58 <bd_> > do { let a = 2; return 2 }
18:57:58 <bd_> ?
18:57:59 <lambdabot>   <no location info>: parse error on input `}'
18:58:02 <bd_> oh, blah
18:58:21 <Philonous> bd_ What do you mean by "return that constant value" ?
18:58:27 <Philonous> returns
18:58:31 <bd_> Philonous: x = return 42
18:58:37 <bd_> x is an action in some monad that returns 42
18:58:39 <bd_> or produces 42
18:58:41 <bd_> or contains 42
18:58:45 <bd_> or whatever analogy you want to use
18:59:11 <Philonous> Yeah, but that's ambiguous IMO.
18:59:12 <bd_> if we want to be totally precise, we can simply state that forall e f. return e >>= f is equivalent to f e
18:59:45 <bd_> and of course (>>= return) is the identity function on a restricted domain
19:00:18 <Plouj> bd_: on the other hand, this matches the current sentence:
19:00:19 <Plouj>  :t return
19:00:20 <Plouj> return :: (Monad m) => a -> m a
19:00:32 <Philonous> But yeah, without going into details too much "return takes a value and makes it a computation" might be the best way to put it.
19:00:56 <Plouj> I'm guessing the (Monad m) part is filled in by the do syntax
19:01:18 <cjb> you could walk through with an example, like do a <- [8]; return 2 returning [2].  the list monad lifts its return values into lists, so you can think of "Monad m" as being "List m" for that case.
19:01:26 <ddarius> do-notation is just a light syntactic sugar
19:01:33 <Cale> Plouj: you mean which monad is selected?
19:01:47 <Plouj> Cale: yeah, I guess
19:01:58 <cjb> other monads do different things with their return values, but all of them involve a -> m a
19:01:59 <Cale> Plouj: Usually that ends up being determined by some other computation that's around, but if it's not, then you end up with something polymorphic.
19:02:04 <xcthulhu> Plouj: The Monad m is inferred by the do syntax
19:02:23 <Cale> For example...
19:02:34 <Cale> :t do x <- getLine; return (reverse x)
19:02:35 <lambdabot> IO [Char]
19:02:35 <ddarius> xcthulhu: do-notation is just syntax.  It doesn't "do" anything.
19:02:37 <Plouj> xcthulhu: that's what I guessed
19:02:48 <Cale> It must be the IO monad, because there's a getLine there.
19:03:02 <Cale> and that tells it which implementation of return it'll need.
19:03:42 <Cale> But if for whatever reason, that's not determined, it just stays polymorphic
19:04:04 <Cale> :t \xs -> do vs <- sequence xs; return (reverse vs)
19:04:05 <lambdabot> forall (t :: * -> *) a. (Monad t) => [t a] -> t [a]
19:05:53 <xcthulhu> Cale: t:: *->* just says that t is functor, right?
19:06:01 <Cale> That t is a type constructor.
19:06:05 <xcthulhu> oh
19:06:13 <Cale> (it might not be a Functor, for that you need fmap)
19:06:34 <Cale> But the fact that t is a monad ensures that it's also a functor.
19:06:40 * allbery_b mutters about having to reimplemnt Data.Fixed
19:06:50 <xcthulhu> It happens to be a Functor, because all Monads are instances of functors
19:06:54 <xcthulhu> yeah
19:06:58 <allbery_b> (need to be able to mix numbers with different resolutions)
19:06:59 <xcthulhu> on the same page then
19:07:41 <roconnor> allbery_b: Fixed is always represented by an Integer right?
19:07:43 <Cale> allbery_b: Can't you explicitly convert one resolution to another?
19:07:55 <nejucomo> Hello.
19:08:01 <allbery_b> I could but the whole thing gets painful
19:08:08 <Cale> allbery_b: fromIntegral ought to do it.
19:08:13 <allbery_b> (I'm representing an SQL NUMERIC(N,P) type)
19:08:26 <nejucomo> I have a simple type with multiple constructors.
19:08:29 <Cale> er, actually, hmm
19:08:32 <roconnor> Cale: I don't think Fixed is an integral.
19:08:34 <Cale> realToFrac
19:08:39 <Cale> right.
19:08:47 <nejucomo> Each constructor is of the form "Constname SomeType".
19:08:50 <roconnor> @type fromRational
19:08:51 <lambdabot> forall a. (Fractional a) => Rational -> a
19:09:02 <roconnor> is Fixed an instance of Fractional?
19:09:19 <nejucomo> I'm writing many functions of the type "MyType -> Maybe SomeType" to unwrap each constructor by name.
19:09:28 <allbery_b> yes, it is
19:09:29 <nejucomo> Is there an easier way to do this?
19:09:37 <Peaker> nejucomo: catamorphism maybe
19:09:46 <nejucomo> What is that?
19:10:07 <nejucomo> It almost seems like the Data.Dynamic class is what I'm recreating, but I don't see exactly how it maps.
19:10:14 <Peaker> nejucomo: its a function that takes a function for each data constructor, and the data type, and calls the appropriate function depending on the constructor, and returns whatever it returned
19:10:14 <allbery_b> I'm still trying to honor the SQL definition, some programs rely on it (in particular truncating fractional results at the declared precision)
19:10:27 <Peaker> nejucomo: where do you use these Maybes?
19:10:55 <nejucomo> in a mapMaybe.
19:11:32 <nejucomo> I have a [MyType] list and I want to check that each list element uses the same construct and then unwrap it into a [SomeType] list.
19:11:51 * xcthulhu remembers the good old days when a programmer didn't need to know category theory ... :)
19:12:10 <roconnor> xcthulhu: I need a goto, stat.
19:12:16 <ddarius> Programmer's still don't need to know category theory and most don't.
19:12:18 <Cale> xcthulhu: It's somewhat happy that you still don't. It's just helpful :)
19:12:38 <roconnor> @hoogle goto
19:12:38 <ddarius> s/'//
19:12:39 <lambdabot> No results found
19:12:48 <roconnor> damn, how can I program in this language!
19:12:53 <roconnor> :P
19:13:05 <xcthulhu> roconnor: With the lambda calculus :P
19:13:08 <Cale> roconnor: ContT
19:13:15 <Peaker> nejucomo: why do you need to do that?
19:13:17 <roconnor> goto :: Label -> IO a
19:13:28 <roconnor> goto :: String -> IO a
19:15:01 <nejucomo> Peaker, I'm writing an interpreter that uses dynamic types and I want to write code that only executes provided the referent objects have the correct runtime types.
19:15:38 <Peaker> nejucomo: ah. Then maybe you do want "cast" or Dynamic
19:15:45 <Peaker> nejucomo: I am not sure
19:15:57 <nejucomo> Me neither.  Only time/experience will tell.
19:17:58 <Cale> :t let getCC = callCC (\c -> let x = c x in return x) in (`runContT` return) (do r <- liftIO (newIORef 0); label <- getCC; liftIO (print =<< readIORef r); liftIO (modifyIORef r (+1)); label)
19:17:59 <lambdabot> Not in scope: `newIORef'
19:18:00 <lambdabot> Not in scope: `readIORef'
19:18:00 <lambdabot> Not in scope: `modifyIORef'
19:18:04 <Cale> of course.
19:18:31 <roconnor> :D
19:19:45 <nejucomo> Shucks.  No luck with "unwrap cons (cons a) = Just a"
19:19:53 <Peaker> if you want backwards goto's, maybe label :: IO Label  and goto :: Label -> IO () would be evil enough for you?
19:20:49 <EvilTerran> call 'em setjmp and longjmp
19:20:59 <cjb> !
19:21:06 <MyCatVerbs> EvilTerran: aaaaaa!
19:21:12 <EvilTerran> you could do it fairly directly as a wrapper around the Cont monad, i think
19:21:14 <EvilTerran> MyCatVerbs, :P
19:22:01 <Cale> label :: IO (IO a)
19:22:28 <ddarius> mdo goto label; foo; label <- bar; return ()
19:22:50 <Peaker> Cale: what does join label do?
19:23:08 <Cale> Peaker: loop forever
19:23:39 <dmwit> nejucomo: You're only allowed to pattern match on constructors.
19:23:51 <Peaker> Cale: what action does label compute?
19:23:59 <Cale> Peaker: the current continuation
19:24:21 <Peaker> Cale: ah, I see
19:24:30 <Peaker> Cale: instead of a Label type, you just use a continuation
19:24:33 <Cale> right.
19:24:44 <nejucomo> dmwit, good to know.
19:25:01 <Cale> Because presumably the only thing you can do with a Label is apply goto to it.
19:25:13 <Cale> So it might as well be the result of applying goto.
19:25:22 <Cale> Which is the current continuation :)
19:25:44 <Peaker> if the continuation is after the label, maybe "join label" would just jump to after the label (do nothing?)
19:25:55 <ddarius> Also you want goto :: Label -> IO Void which is what Cale's approach effectively leads to.
19:26:14 <Cale> Peaker: join x = do v <- x; v
19:26:26 <Cale> Peaker: so  join label = do v <- label; label
19:26:57 <Cale> (which had best loop forever)
19:27:08 <dmwit> do v <- label; v
19:27:11 <Cale> er
19:27:12 <Cale> v
19:27:14 <Cale> yes
19:27:37 <Cale> It's easy to write
19:27:41 <Peaker> I guess the code "after" the label is this "join"
19:27:42 <Cale> In the ContT monad
19:28:12 <ddarius> join label is label: goto label
19:28:12 <Cale> :t let getCC = callCC (\c -> let x = c x in return x) in getCC
19:28:12 <Peaker> ddarius: Why, Cale's approach lets you bind the label to goto, instead of calling a "goto"?
19:28:16 <lambdabot> forall (m :: * -> *) b. (MonadCont m) => m (m b)
19:28:40 <Cale> also handy is:
19:28:48 <Cale> :t let getCC' x0 = callCC (\c -> let f x = c (x, f) in return (x0, f))
19:28:49 <ddarius> Peaker: No, because of the type of label, what could you do with 'a'
19:28:49 <lambdabot> <no location info>:
19:28:49 <lambdabot>     not an expression: `let getCC' x0 = callCC (\c -> let f x = c (x, f) in return (x0, f))'
19:28:50 <ddarius> ?
19:28:54 <Cale> :t let getCC' x0 = callCC (\c -> let f x = c (x, f) in return (x0, f)) in getCC'
19:28:55 <lambdabot> forall t (m :: * -> *) b. (MonadCont m) => t -> m (t, t -> m b)
19:29:48 <ddarius> Or rather what could label or the action it produces do with 'a'?
19:29:52 <jeffz> nejucomo: are you implementing an existing language or creating a new one?
19:29:56 <Cale> Basically, that lets you jump back with a new value.
19:31:18 <Cale> (x0 is the value for the first iteration of the loop, and it's replaced by whatever the label-function that's returned is called with.)
19:31:46 <nejucomo> jeffz, I haven't really decided yet.  ;-)
19:31:53 <nejucomo> I have a lisp-ish parser so far.
19:33:07 * Cale wonders why the mtl is so stagnant.
19:33:40 <Peaker> monad transformers - the past, FRP - the future? :-)
19:33:43 <Cale> Cont is still just as broken as a couple years ago. We still have a broken ListT, no new monad transformers...
19:34:02 <ddarius> What's broken about Cont?
19:34:09 <dmwit> Who's the maintainer?
19:34:10 <jeffz> nejucomo: ah, I've almost completed a PostScript interpreter, ignoring the graphics and font stuff
19:34:24 <Cale> ddarius: Lack of polymorphism in the return type.
19:34:32 <ddarius> jeffz: Those are the hard parts...
19:35:42 <jeffz> ddarius: yeah, I haven't really felt compelled to bother with that part of things, I can always consider doing some of that stuff later.
19:35:47 <Cale> It should be newtype Cont a = Cont { runCont :: forall r. ((a -> r) -> r) }, shouldn't it?
19:36:16 <ddarius> There are benefits of leaving the variable available
19:36:27 <ddarius> And you can easily write type Cont' a = forall r. Cont r a
19:40:30 <Cale> I'm somewhat unsure about that. You can run into strange issues where 'r' variables don't unify, that I think the other version avoids.
19:40:59 <Cale> However, I forget a good concrete example of what it is that I'm talking about...
19:42:03 <Cale> Oh, I suppose the problem is really more with the type of callCC.
19:42:34 <EvilTerran> ?type callCC
19:42:35 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
19:43:53 <Cale> Should be  ((a -> (forall b. m b)) -> m a) -> m a
19:45:35 <EvilTerran> or ((forall b. a -> m b) -> m a) -> m a?
19:46:04 <Cale> I'd imagine that would also do.
19:46:19 <EvilTerran> i think they're equivalent, it's too late at night for me to be sur e:P
19:46:26 <Cale> yeah
19:47:03 <Plouj> is there a good way to avoid these kind of strange errors when I just needed parans around the arguments to return? http://codepad.org/x39NBMIr
19:47:36 <Cale> Plouj: not really, except for noticing things like that as a special case.
19:47:48 <Plouj> paranthesising the arguments to return didn't hit my my for about 2 hours
19:48:02 <Cale> Plouj: but in some cases,  return xs ++ ys  can be well typed.
19:48:13 <adu> hi
19:48:28 <Cale> > return 1 ++ [2,3,4,5]
19:48:29 <lambdabot>   [1,2,3,4,5]
19:48:45 <dmwit> > let (xs:ys) = [1..5] in return xs ++ ys
19:48:46 <lambdabot>   [1,2,3,4,5]
19:49:05 <dmwit> adu: Hi!
19:49:14 <adu> > return $ [1] ++ [2,3,4,5]
19:49:15 <lambdabot>       No instance for (Show (m [t]))
19:49:15 <lambdabot>        arising from a use of `show' at <...
19:49:34 <Cale> > return $ [1] ++ [2,3,4,5] :: [[Integer]
19:49:35 <lambdabot>   <no location info>: parse error on input `;'
19:49:35 <Cale> > return $ [1] ++ [2,3,4,5] :: [[Integer]]
19:49:36 <lambdabot>   [[1,2,3,4,5]]
19:49:42 <adu> dmwit: how goes it?
19:50:24 <Cale> Plouj: GHC reports better errors, generally.
19:50:29 <dmwit> adu: sleepily
19:50:31 <adu> are all the OSs wishing they were more functional?
19:50:50 <adu> dmwizzzzzz
19:51:08 <Cale> But here, it gives a fairly similar one.
19:51:27 <jeffz> adu, you said something amusing yesterday
19:51:36 <adu> i did?
19:51:38 <jeffz> <adu> all OSs should have 4GLs builtin, and DBMSs integrated with the filesystem...
19:52:03 <adu> o ya, thats just cuz I love Mathematica
19:52:12 <adu> and SQL
19:52:18 <adu> and XPath
19:52:18 <jeffz> IBM has been doing that for awhile with iSeries / AS/400
19:52:22 <Cale> http://codepad.org/aciTs3A6 -- this is GHC's error message
19:52:44 <adu> jeffz: really? I want one
19:53:06 <Plouj> Cale: not really: http://codepad.org/oSf13R7C It actually confuses me because I can never tell/remember which of expected or inferred is the type that I actually meant in the given code line.
19:53:08 <jeffz> adu, it's priced for companies that have more money than sense
19:53:24 <Cale> Plouj: You could have meant either one.
19:53:35 <Cale> Plouj: (which is why it's a type error :)
19:54:33 <Plouj> yeah, but that means I have to trace both ways to see where I accidentally caused the variable to be of either expected or inferred type
19:55:35 <Plouj> only having specified the type of getAllLines to be -> String did I realize that the problem is that moreLines is expected to be a [String] for some reason
19:55:52 <dolio> Cale: callCC doesn't type for newtype Cont a = Cont { runCont :: forall r. (a -> r) -> r }
19:55:55 <Plouj> meh, this is confusing
19:56:07 <Plouj> how do I insert a newline character into a string?
19:56:19 <sjanssen> \n
19:56:29 <Cale> dolio: Did you give it the modified type I gave?
19:56:32 <adu> jeffz: actually, my favorite application of xpath is xsh, which lets you do something like a/b/c@d=hello and it builds the XML document that would make that XPath return something
19:58:09 <adu> I wonder how easy it would be to reimplement xsh in Haskell...
19:58:15 <adu> I want to reimplement everything in Haskell...
19:58:18 <jeffz> adu, with AS/400,  you buy the hardware, they license the software to you and the operating system based on the amount of resources you use, which is portable accross various architectures, the standard filesystem isn't hierarchial, but consists of libraries which are sort of like "databases" that contain members "files" that contain records which have fields per the definition for that member.  all files can be queried with SQL.
19:58:26 <Cale> dolio: hmm
19:58:36 <dolio> Cale: Yes. The problem is in the mismatching of the universals.
19:59:15 <adu> jeffz: sounds like lots of licensing and not that many features...
19:59:27 <jeffz> adu, most frequently people use the 4GLish language called CL to script everything, but larger programs can be written in RPG and COBOL
19:59:51 <adu> COBOL???
20:00:20 <jeffz> adu, also comes with C and C++ compilers, an IBM JDK and JRE and the default charset/encoding is a variant of EBCDIC depending on where in the world you are
20:02:40 <adu> jeffz: sounds like a mixture of ancient and decent
20:03:13 <dolio> Cale: More or less, 'Cont a = forall r. (a -> r) -> r' is a CPSed identity monad, not a first-class continuation monad.
20:03:19 <jeffz> adu, all jobs that run "processes" have to be run in queues or interactively, having various queues lets you schedule and prioritise things as they can be suspended and resumed, it's also had logical partitions which are like virtual machines I guess, where you can run more instances of the same OS on the same hardware
20:03:42 <Cale> dolio: hmm, I suppose that's true, yes
20:03:51 <Plouj> whew, IO section done...
20:04:17 <adu> wow, so is it at all posix compliant?
20:04:31 <jeffz> adu, yeah, it's pretty decent, just really, really overpriced since theoretically it could run on regular x86 hardware but you have to buy and license special IBM hardware
20:04:49 <MyCatVerbs> adu: actually I think RPG should frighten you more than the mention of COBOL. :)
20:05:16 <jeffz> adu, hm, I don't think it's posix compliant, there are posix-like features
20:05:29 <adu> MyCatVerbs: I have never heard of RPG, so i'm not scared of it :)
20:05:48 <adu> MyCatVerbs: and I've heard of at least 200 programming languages, so that kinda says something...
20:05:57 <jeffz> adu, http://en.wikipedia.org/wiki/Report_Program_Generator#Example_code
20:06:00 <lambdabot> Title: IBM RPG - Wikipedia, the free encyclopedia, http://tinyurl.com/5j3mza
20:07:21 <MyCatVerbs> adu: RPG came out of IBM and was, by reputation, less expressive than the instruction sets of the CPUs it was run on.
20:08:05 <adu> MyCatVerbs: lolol, sounds like a funge
20:08:26 <jeffz> adu, http://en.wikipedia.org/wiki/AS/400_Control_Language is the 4GL'ish language for scripting things
20:08:26 <lambdabot> Title: AS/400 Control Language - Wikipedia, the free encyclopedia
20:10:21 <MyCatVerbs> adu: well, it starts with fixed-column syntax. IMO, it's not really possible to go anywhere uphill from there.
20:10:44 * adu looks as some other entries in Category:Command_shells ... I recognize APL and MPW...
20:12:38 <adu> I misss MPW
20:23:13 <mofmog> so yahoo came to my school today and they had some hacking competition. this is what I decided to do (I hope fairuse covers my ass because this is a parody)
20:23:14 <mofmog> http://inst.eecs.berkeley.edu/~cs61a-ri/
20:23:15 <lambdabot> Title: Yahoo! NEW AND IMPROVED! Because we realized our user base is made up mostly of  ...
20:23:57 <pizza_> sluts?
20:27:57 <Spark> people who don't care about the quality of their search results
20:29:09 <jeffz> making a webpage doesn't sound like much of a hacking comptetition :|
20:39:50 <roconnor> @seen dmwit
20:39:51 <lambdabot> dmwit is in #haskell, #xmonad, #haskell-blah and #haskell-overflow. I last heard dmwit speak 49m 22s ago.
20:42:00 <pizza_> @seen pizza___
20:42:00 <lambdabot> pizza___ is in #haskell. I last heard pizza___ speak 7h 55m 25s ago.
20:42:06 <pizza_> @seen pizza___
20:42:06 <lambdabot> pizza___ is in #haskell. I last heard pizza___ speak 7h 55m 31s ago.
20:42:15 <roconnor> dmwit: there are many SDTV standards, each with it's own Y'Cb'Cr encoding. How do you feel about Data.Colour.SDTV.SMPTE-C, Data.Colour.SDTV.EBU, Data.Colour.SDTV.SMTPE240M, etc?
21:02:05 <roconnor> dmwit: maybe I should just have the y'CbCr take a colourspace parameter
21:05:38 <kniu> Can multi-parameter type-classes be translated into dictionary-passing style?
21:07:54 <dolio> Sure, why not?
21:11:05 <bd_> kniu: When you instantiate the function, just save the dictionary then.
21:18:43 <ddarius> There's nothing to do.  The dictionary translation just turns C a into CDict a so C a b is just CDict a b
21:19:40 <kniu> Just a question is all.
21:19:41 <dolio> The thing that doesn't really translate is fundeps, but that's because you're hand-choosing the dictionary.
21:19:43 <kniu> thanks.
21:20:00 <kniu> hmm
21:20:14 <kniu> if, by some bizarre change of fate,
21:20:41 <kniu> Haskell had been blessed with sexpr syntax and macros,
21:20:55 <kniu> would type-classes have been implemented as a library instead?
21:21:02 <kniu> Is that possible, I ask?
21:21:10 <ddarius> fundeps are resolved ahead of time
21:21:32 <ddarius> kniu: Not in any useful way.
21:21:40 <kniu> ddarius, what do you mean?
21:22:40 <ddarius> You can use macros to write a compiler from Haskell with type classes to... something else but you couldn't then intermix Haskell w/o type classes and Haskell w/ type classes except as somewhat of a foreign language.
21:28:17 <mm_freak> two Integer numbers have equal definedness, don't they?
21:28:45 <mm_freak> so if  is "less or equally defined", then 1  2, isn't it?
21:29:00 <ddarius> mm_freak: No
21:29:08 <ddarius> mm_freak: It's a flat domain
21:29:52 <dolio> 1 and 2 are incomparable members of the partial order, no?
21:30:17 <mm_freak> yeah, and in such a domain i'd assume all elements to have equal definedness, or are they simple incomparable?
21:30:18 <ddarius> Correct.  This is clear otherwise fixpoints over integers would not have well-defined results.
21:31:00 <mm_freak> ok, seems like i don't understand definedness properly
21:31:42 <rwbarton> 1 is more defined than _|_
21:32:04 <ddarius> mm_freak: You have posets.  If 1 <= 2 and 2 <= 1 then 1 would have to be 2.
21:32:26 <rwbarton> The picture is: _|_ at the bottom (hence the name)
21:32:34 <rwbarton> everything else in a row above it, incomparable to each other.
21:32:54 <ddarius> @google Hasse diagram
21:32:57 <lambdabot> http://en.wikipedia.org/wiki/Hasse_diagram
21:32:57 <lambdabot> Title: Hasse diagram - Wikipedia, the free encyclopedia
21:33:40 <mm_freak> ddarius: ok, that makes sense
21:34:30 <mm_freak> so 1  2 is not simply false, the comparison itself is flawed, yes?
21:35:05 <mm_freak> we just set it false for convenience, so we have a partial order
21:35:06 <Cale> With Nat, things are a little more interesting, 1 and 2 are still incomparable, but S _|_ < S (S _|_)
21:35:07 <ddarius> No, it's false
21:35:08 <rwbarton> 1  2 is simply false, as is 2  1
21:35:34 <ddarius> It just doesn't imply 2 < 1.  It is just simply false.
21:35:46 <mm_freak> ok
21:37:14 <mm_freak> it's just a bit unintuitive to me, because i'm not used to order trees
21:41:06 <Cale> mm_freak: It might help to think of trying to order the various countries by how many medals of each type they won in the Olympics. Is a country that has 2 silver medals doing better or worse than the country with 1 gold medal? It's not so clear, so you might just not make a decision about that. You could still form a partial order where if one country had more medals of each type than another, then it was doing bette
21:41:06 <Cale> r.
21:42:29 <mm_freak> thanks, that explains it
21:43:15 <mm_freak> but that sounds like what i said:  we just set it false for convenience, so we have a partial order
21:43:34 <mm_freak> if we said "undefined" or "pointless" instead of "false", we couldn't form a partial order
21:43:48 <ddarius> A different tack is to choose something that is not related to a total order.  a <= b if a is a child of b.
21:43:48 <mm_freak> is that right?
21:43:52 <Cale> Well, we wouldn't even have a relation...
21:44:13 <Cale> A relation on a set S is a subset of SxS.
21:44:39 <ddarius> Siblings in that order are incomparable, neither is a child of the other.
21:44:54 <Cale> So when we say that we have this definedness relation, x <= y if (x,y) is in this particular subset of SxS.
21:45:06 <ddarius> s/child/descendant/g
21:46:23 <mm_freak> ok
21:46:26 <Cale> Heh, btw, someone drew the Hasse diagram for a slightly more sophisticated version of that Olympic partial order: http://tartarus.org/simon/2008-olympics-hasse/ (it takes the quality of the medals into account as well)
21:46:37 <lambdabot> Title: Hasse diagram of the 2008 Olympic medal table
21:47:47 <Cale> So you see, that diagraph at the bottom, one country X is doing better than another Y, if there's a path going from X down to Y.
21:48:22 <Cale> and it's easy to see that some countries are not comparable with others because there is neither a path from X to Y nor a path from Y to X.
21:50:01 <mm_freak> so if, in a vertical relation tree, there is no path between x and y without changing the vertical direction, then x and y don't fulfill the relation
21:50:39 <Cale> x and y are incomparable, we'd say
21:51:13 <Cale> We'd have neither that x <= y nor that y <= x.
21:52:02 <Cale> Usually, we don't end up with a tree, but a directed acyclic graph.
21:52:03 <mm_freak> but they aren't incomparable in the same sense that 3.5 and 4.5 are incomparable in : X, where X is a subset of x
21:53:04 <ddarius> That's just a type error.  You could just as well have used frogs and SUVs instead of 3.5 and 4.5.
21:53:33 <mm_freak> true
21:53:47 <Cale> But I suppose, as sets, you're allowed to ask the question of whether (3.5,4.5) is an element of the relation, and the answer is "no, it's not".
21:54:25 <Cale> (and neither is (4.5,3.5)), but yeah, it's not interesting, because 3.5 and 4.5 are not elements of N.
21:54:59 <ddarius> (frogs, SUVs)  NxN
21:55:52 <Cale> Whereas it's still possible for (x,y) and (y,x) to both not be in a subset of XxY for some x in X and y in Y.
21:57:20 <Cale> er, probably should have made those the same set, to be clear :)
21:58:54 <Cale> Let's pick a random relation on S. If S has n elements, then there are 2^(n^2) of those, because you're picking whether each of the n^2 possible pairs is in the relation.
22:00:50 <mm_freak> a question regarding partial orders
22:02:16 <mm_freak> ~ = XxX would imply that X contains only a single element, wouldn't it?
22:02:38 <Cale> If ~ is a partial order?
22:02:42 <mm_freak> yeah
22:02:49 <rwbarton> Or X is empty :)
22:02:58 <Cale> yeah, it has at most one element
22:03:01 <mm_freak> or that, yeah
22:03:18 <Cale> Because if x, y are elements of X then, we have that x ~ y and y ~ x, but that means that x = y.
22:03:42 <Cale> (by the antisymmetry axiom for a partial order)
22:03:45 <mm_freak> what about a partial order ~ = XY with X  Y, that's impossible, isn't it?
22:03:57 <ddarius> mm_freak: That can't be reflexive
22:04:03 <ddarius> (except in some trivial cases)
22:04:13 <mm_freak> which trivial cases?
22:04:13 <Cale> Right, you don't have x ~ x
22:04:17 <Cale> So it would have to be empty.
22:04:21 <ddarius> X = {} or Y = {}
22:04:49 <Cale> Er, partial orders technically have to be relations on SxS for just one set S :)
22:05:12 <Cale> (I messed this up a bit earlier as well. More general relations of course, don't have to be.)
22:05:14 <mm_freak> yeah, if X = {}, then Y = {}
22:05:33 <ddarius> That's not true, and in fact you specifically rule out that case.
22:05:44 <mm_freak> that's the point =)
22:05:57 <ddarius> XxY = {} if either X = {} or Y = {}
22:06:33 <mm_freak> that's why i asked for trivial cases, since in the above condition, there can't be any
22:07:18 <ddarius> Yes there can.  There are two.  There can't be any if you require that a partial order by a subset of XxY for X = Y and require X /= Y.
22:07:29 <ddarius> s/by/be
22:07:35 <Cale> If you remove the antisymmetry axiom, keeping just reflexivity and transitivity, then you have what's called a preorder. Another way to characterise preorders is as categories where there is at most one arrow between any pair of objects.
22:08:06 <Cale> The connection being that we say  x <= y  if and only if there is some arrow  f: x -> y
22:09:15 <Cale> Note that reflexivity is the same as saying the identity arrows exist, and that transitivity comes from composition of arrows.
22:10:42 <Cale> So then a partial order is a category with at most one arrow between any pair of objects, and for which if there's an arrow f: X -> Y and g: Y -> X, then X = Y
22:12:04 <Cale> I'm not sure if this is just confusing, but I think it's a nice way to look at it.
22:13:10 <Cale> A Hasse diagram (one of those digraphs) is a sort of picture of that category, where extraneous arrows which arise due to composition have been removed.
22:14:10 <Riastradh> I'm curious, Cale.  What does the categorical terminology add to the notion?
22:14:43 <ddarius> Riastradh: Not much unless you know more category theory than order theory.
22:14:50 <Cale> Right.
22:15:11 <Cale> You get a lot of the usual order theory constructions for free by considering category theoretic concepts.
22:15:54 <Cale> (Consider what a product is, for instance, or a functor between two such posets.)
22:17:44 <Cale> A product X x Y of two objects X and Y in a preorder category is an object with arrows X x Y -> X and X x Y -> Y, such that for any other object U with arrows U -> X and U -> Y, we get that there's a (unique) arrow U -> X x Y
22:18:53 <Cale> So X x Y is a greatest lower bound for X and Y.
22:19:43 <Cale> dually, a coproduct is a least upper bound.
22:22:09 <Cale> Adjoint functors between two poset categories give a Galois connection.
22:23:07 <Cale> A monad on a poset category is called a closure operator.
22:41:57 <quicksilver> I would say that the category theory adds (almost) nothing to the study of posets; but conversely, using posets as an example is very helpful for someone who already knew about posets trying to root themselves with categories?
22:44:52 <dolio> It certainly helps divorce you from the notion that categorical products are necessarily anything like the products you might be used to.
22:45:50 <Cale> quicksilver: Well, it certainly gets you to many of the interesting constructions of order theory very quickly.
22:46:09 <Cale> (Supposing that you're already familiar with categories.)
22:46:27 <quicksilver> from at least one perspective, that's a strange notion of 'very quickly'
22:47:01 <quicksilver> it's nice that so many of things have independent names and were of independent study
22:47:09 <quicksilver> before it become clear than one was a case of the other
22:47:52 <Cale> I think that with category theory we finally have a tool which lets us quickly find objects that we ought to find interesting.
22:48:32 <path[l]> hi I have a basic question. Can I create a composite function directly? For example can I define f = head(words) ? Is there any way to do it?
22:48:41 <Cale> f = head . words
22:50:03 <quicksilver> "Category Theory: The metal detector in the treasure hunt which is mathematics"
22:50:16 <path[l]> oooh thats possible?
22:50:17 <path[l]> neat
22:50:27 <rwbarton> @src (.)
22:50:27 <lambdabot> (f . g) x = f (g x)
22:51:01 <rwbarton> Even if it wasn't in the standard library, you could have written it yourself. :)
22:51:26 <Cale> quicksilver: yeah!
22:51:46 <path[l]> ah
22:54:43 <Plareplane> has anyone tried to formulate, say, typical undergraduate math curriculum in category-theoretic terms instead of set-theoretic ones
22:55:36 <quicksilver> sure
22:55:41 <quicksilver> (not me personally)
22:55:56 <quicksilver> but there is a school (in the abstract sense) very keen on CT as foundations
22:56:12 <omy> how many ways are there to get to number 64, multiplying 1,2,3,4,5? You can't add, just multiply. I could only come up with 4*4*4, (2*2)*4*4, (2*2)(2*2)(4), (2*2)(2*2)(2*2).... I started with 4^3  and just broke every four into 2s.. making it 2^6... "1" is discarded since it makes an infinite loop... are there any other solutions?
22:56:44 <solrize> i think typical undergrad math cirricula don't pay much attention to foundations
22:56:59 <solrize> i had two logic classes and one set theory class and they were all electives
22:57:48 <papermachine> Foundations isn't really necessary for common life
22:57:55 <solrize> but yeah, there's some heavyweight logic dudes and even regular math dudes, who say set theory is bogus
22:57:56 <pumpkin_> omy: it's just the number of additions you can make out of 6, really, and the infinite list you said about 1
22:58:02 <solrize> i think logic is important but set theory is not
22:58:14 <solrize> all math and cs people should study some logic
22:58:26 <pzl> pumpkin: How do you prove that?
22:58:52 <pumpkin_> you factor 64 to show that 3 and 5 can't be options
22:58:54 <omy> pumpkin_, only adding sixes won't get you to 64, it will take you to 66.
22:59:08 <pumpkin_> I mean, the number of ways to do it, not actually doing it
22:59:28 <pumpkin_> but that'll include 32, 16, and 8 now that I think about it
22:59:48 <pzl> he said 1 to 5
22:59:58 <pumpkin_> yup
22:59:59 <pzl> so just remove that from factors
23:00:26 <omy> so the only solutions are... 2^6 and 4^3, right?
23:00:54 <pumpkin_> well they're the same thing, really
23:00:56 <quicksilver> 2^4 * 4
23:00:58 <quicksilver> (etc)
23:01:05 <quicksilver> your 4s are just pairs of 2s
23:01:08 <quicksilver> in the factor language
23:01:24 <pzl> its like a factorial pyramid
23:01:46 <pumpkin_> I mean, you can reduce it to (1 + 1 + 1 + 1 + 1 + 1) = (1 + 1 + 1 + 1 + 2) etc
23:01:49 <omy> so the only solution would be 2^6? and all it's equivalents?
23:01:55 <pumpkin_> do you get to reorder it?
23:02:08 <pzl> all you do is: get the factors of 64, and remove all factors which are above 5, then go through each term and see if that can be factored
23:02:11 <pzl> til nones left
23:03:21 <rwbarton> solrize: in what sense do they say set theory is bogus?
23:03:34 <rwbarton> solrize: (I'm not here to defend set theory, just curious)
23:03:49 <solrize> sec
23:06:07 <omy> Okay I got it... there are 4 possible solutions... 2^6, 4(2^4), 4^2(2^2), 4^3.
23:06:16 <dolio> Set theory is religion!
23:06:17 <omy> thank you all for helping me understand it... :)
23:06:18 <Cale> I have the impression that in order to say interesting things in set theory, you mostly have to be talking about extraordinarily large sets.
23:06:24 <solrize> i was trying to find a particular article by feferman but i guess it's not online.  anyway the idea is it's not meaningful to talk about (say) the power set of the integers, since almost all the subsets can't be described
23:06:36 <dolio> Follow up to sci.math
23:06:42 <Cale> solrize: But anyone who would tell you that is a weirdo.
23:06:54 <solrize> feferman is a weirdo?
23:07:05 <quicksilver> that sounds like a hardline constructivist view
23:07:06 <Cale> If he advocates that view, then yes.
23:07:24 <quicksilver> I don't find the hardline constructivists particular interesting.
23:07:29 <quicksilver> but, horses for courses, I guess.
23:08:05 <solrize> he's not a constructivist, he's fine with sets that can't be constructed, as long as those sets can be described (e.g. the set of halting turing machines is unconstructable but describable)
23:08:17 <lament> which axioms do constructivists reject?
23:08:28 <Cale> But the powerset of the integers can be describes.
23:08:30 <Cale> described*
23:08:43 <lament> oh, law of excluded middle
23:08:58 <solrize> the individual subsets of the integers mostly can't be described
23:08:58 <Cale> lament: Well, that's intuitionists, for a start.
23:09:03 <Cale> solrize: right.
23:09:10 <Cale> solrize: But the set of all of them can.
23:09:21 <lament> wp sez "Constructivist mathematics uses intuitionistic logic"
23:09:39 <Cale> lament: right.
23:10:38 <Cale> Nevermind the powerset axiom, even rejecting the axiom of choice makes you a weirdo.
23:10:40 <solrize> i dunno that the power set of the integers can be described.  there's sort of an infinite loop, if you want to say what "subset" means on such sets, you're back to set theory
23:11:08 <Cale> solrize: It can certainly be defined in ZFC. There's an axiom which hands it to you.
23:11:24 <lament> oh, i see, to them there's true stuff, false stuff, and unknown stuff
23:11:30 <lament> Maybe Bool
23:11:30 <solrize> that axiom doesn't describe the powerset.  it just asserts its existence.
23:11:43 <rwbarton> I think it's good to know that there are countable models of ZFC, and roughly understand what that means, and also good to acknowledge that for doing everyday math (i.e., everything except set theory) we should think of sets "existing" even if we can't pin them down precisely.
23:11:44 <Cale> solrize: It does both at the same time.
23:12:20 <lament> it seems really strange that somebody would honestly be an intuitionist
23:12:44 <solrize> there's a pretty good article by vanaanen
23:12:47 <solrize> lemme find it
23:13:02 <Cale> solrize: It says that for any set X there is a set P such that for any set Y, if Y is a subset of X, then Y is an element of P.
23:13:08 <solrize> http://www.math.ucla.edu/~asl/bsl/0704/0704-003.ps
23:13:14 <rwbarton> As far as I can tell intuitionists just have a very different notion of truth.
23:13:22 <Cale> That's a good enough description of the powerset to me.
23:13:25 <lament> rwbarton: Maybe Bool as far as I can tell.
23:14:23 <Cale> But why should we *like* that axiom? Well, the powerset is a very useful set to be able to talk about.
23:14:40 <solrize> that doesn't even define the powerset of the integers, i.e. there are formulas over the integers that are true in some interpretations of ZFC and false in others
23:14:50 <Cale> solrize: hm?
23:15:02 <Cale> solrize: That describes every powerset.
23:15:28 <Cale> Unless I typoed something.
23:16:06 <solrize> well, there's this set N = {1,2,3,...}, and if we say there's a unique powerset 2**N, then that completely characterizes the integers (morley categoricity theorem)
23:16:18 <solrize> but there are statements about the integers that are independent of zfc
23:16:34 <lament> i guess intuitionistic math should be a better framework for CS stuff
23:17:10 <solrize> so, ZFC doesn't precisely specify what 2**N is
23:17:29 <pzl> has there ever been a discovery made on IRC
23:17:32 <Cale> solrize: Sorry, what are you claiming uniquely characterises the integers?
23:17:44 <solrize> cale, the peano axioms in 2nd order logic characterize the integers
23:17:55 <Cale> solrize: Every set has a unique powerset.
23:18:23 <solrize> cale, well, that's a platonistic view of set theory
23:18:23 <Cale> (I'm talking strictly about ZFC here.)
23:18:28 <Cale> No it's not.
23:18:35 <solrize> ZFC doesn't have a unique model
23:18:37 <Cale> It's a formalist view of set theory.
23:18:59 <rwbarton> The statement "Every set has a unique powerset" follows directly from various axioms of ZFC
23:19:03 <Cale> For all sets X and Y, if P(X) = P(Y), then X = Y
23:19:03 <solrize> in any particular interpretation of ZFC, the integers have a powerset that is unique in that interpretation
23:19:35 <Cale> solrize: Did I mention interepretations anywhere?
23:19:51 <Cale> (or did you?)
23:20:24 <solrize> cale, consider the set of all even perfect numbers (which might or might not be empty)
23:20:33 <rwbarton> It's not :)
23:20:41 <solrize> wait i mean odd perfect numbers :)
23:20:47 <Cale> okay
23:21:14 <solrize> call that set S
23:21:14 <quicksilver> solrize: the fact that we don't know *everything* about something, does not mean that that something does not exist
23:21:19 <Cale> It might or might not be the empty set, but regardless, it has a unique powerset.
23:21:27 <solrize> it could be that S is empty in some models of ZFC and nonempty in others
23:21:35 <Cale> solrize: sure.
23:21:39 <quicksilver> there are indeed theorems about P(N) we can't prove.
23:21:46 <quicksilver> but there also theorems about N we can't prove.
23:21:48 <solrize> therefore, the axioms of ZFC do not uniquely characterize the integers
23:22:04 <quicksilver> solrize: that problem is not unique to powersets
23:22:14 <solrize> quicksilver, sure
23:22:15 <quicksilver> I'm not sure why you're pointing such a strong finger at powersets
23:22:16 <Cale> solrize: depends on what you mean by "uniquely characterise"
23:22:25 <quicksilver> there are all kinds of things we can't prove in ZFC
23:22:28 <quicksilver> about all kinds of sets.
23:23:12 <solrize> cale, uniquely characterize means any sentence has the same truth value in all interpretations
23:23:34 <Cale> any sentence in what language?
23:23:42 <solrize> let's say in peano arithmetic
23:23:48 <solrize> (N,0,1,+,>)
23:24:24 <Cale> Well, we already know that's impossible, unless you're willing to have an inconsistent system.
23:25:23 <solrize> right, the reason it's impossible is that ZFC and anything like it, fail to describe P(N) precisely
23:26:12 <lament> how do you describe it better?
23:26:34 <solrize> lament, nobody says you can :)
23:26:53 <Cale> The reason that it's impossible is Goedel's first incompleteness theorem, no?
23:26:58 <lament> sure you can - just add more axioms to the system :)
23:27:06 <quicksilver> the leap I can't make is "fail to describe precisely" => "doesn't exist"
23:27:26 <quicksilver> sure, godel's truths were pretty uncomfortable when they were first discovered.
23:27:37 <quicksilver> but you don't solve that problem by throwing away set theory
23:27:48 <quicksilver> if you do that, all you're actaully doing is using set theory and pretending not to
23:27:50 <Cale> Any system which is complete and capable of expressing arithmetic must be inconsistent.
23:27:51 <quicksilver> which is dishonesty.
23:28:04 <lament> quicksilver: i don't understand
23:28:05 <Cale> So, don't even bother worrying about that.
23:28:32 <quicksilver> lament: completeness, consistency, arithmetic, choose two.
23:28:47 <quicksilver> lament: that's a concise expression of godel.
23:28:59 <quicksilver> I find it most interesting to choose consistency + arithmetic, personally.
23:29:04 <lament> what do you mean by "actually doing set theory and pretending not to"?
23:29:11 <solrize> completeness only means that all true statements are provable
23:29:50 <quicksilver> lament: because people who "reject" set theory, replace it by wooly comments about "a class of these" and "some of those" and "some kinds of those"
23:29:57 <Cale> solrize: If there are any undecidable statements P, then adding P or adding not P to the axioms will leave the consistency unchanged.
23:30:14 <quicksilver> lament: and they then go on to "take as obvious" many of things which ZFC would prove.
23:30:25 <quicksilver> although they may succeed in working in a weaker system (no choice, perhaps)
23:30:30 <lament> there're different axiom sets
23:30:33 <lament> than ZFC
23:30:39 <Cale> solrize: So in order for every statement about N to have the same truth value in every interpretation, the system must be *complete*
23:30:40 <quicksilver> there are indeed.
23:30:48 <Cale> solrize: which means that it must be inconsistent.
23:30:50 <quicksilver> most of them aren't "fundamentally" different. they're just tweaks.
23:30:54 <lament> what's its name
23:30:58 <solrize> cale, that's only because you haven't got P(N) that you can quantity over :)
23:31:02 <quicksilver> the ones which are fundamentaly different, like NF
23:31:03 <solrize> quantify
23:31:09 <quicksilver> are interesting as objects of study
23:31:17 <Cale> solrize: No, it's more serious than that.
23:31:20 <quicksilver> but there is no reason (yet) to assume they are foundationally more useful.
23:31:31 <quicksilver> and, even if they were, they still have precisely the same godel problem :)
23:31:38 <quicksilver> they still won't be complete, if they're consistent.
23:32:09 <solrize> all statements about N are true in every interpretation of the 19th century peano axioms (that quantify over P(N))
23:32:30 <solrize> er, all TRUE statements about N, that is...
23:32:40 <solrize> arggh
23:32:43 <lament> what about the NF/NFU theories?
23:33:07 <solrize> lament same situation
23:34:05 <quicksilver> lament: they're very interesting (if you're interested in such things) but they don't solve the problem.
23:34:23 <quicksilver> they still can't be complete + consistent
23:34:27 <solrize> the basic limitation is that a recursively enumerable set of axioms can only describe a countable subset of P(N)
23:34:51 <Cale> solrize: Are you claiming that Peano arithmetic is complete?
23:34:59 <solrize> quicksilver, the original peano axioms are certainly not complete, they just don't have nonstandard models
23:35:22 <papermachine> Surely the Peano axioms have non-standard models
23:35:25 <Cale> In what way don't they have nonstandard models?
23:35:27 <quicksilver> "the original peano axioms don't have non-standard models"?
23:35:27 <solrize> "peano arithmetic" (I may have misused the term earlier) usually refers to first order arithmetic
23:35:31 <quicksilver> what does that mean?
23:35:51 <solrize> quicksilver, the original peano axioms had an induction axiom that quantified over P(N), i.e. they were written in 2nd order logic
23:35:58 <quicksilver> there are entire PhD theses written about non-standard models of PA.
23:36:16 <quicksilver> probably entire university deparments devoted to it. Well, maybe not ;)
23:36:17 <solrize> the completeness and compactness theorems only apply to 1st order logic
23:36:41 <papermachine> Take for example the ultraproduct of N; that's a non-standard model for PA.
23:37:10 <papermachine> s/the/a/;
23:37:45 <papermachine> You can unroll the induction axiom and get a countable theory for PA, btw.
23:37:47 <glguy> so since HUnit-1.2.0.2 requires base 4
23:37:54 <Cale> solrize: You should be careful. Many early systems were inconsistent.
23:37:54 <glguy> does that mean cabal install is broken for 6.8.3?
23:39:03 <Cale> (*especially* second order ones)
23:40:08 <solrize> http://en.wikipedia.org/wiki/Peano_axioms#Models
23:40:09 <lambdabot> Title: Peano axioms - Wikipedia, the free encyclopedia
23:40:26 <solrize>  Dedekind proved in his 1888 book, What are numbers and what should they be (German: Was sind und was sollen die Zahlen) that any two models of the Peano axioms are isomorphic: given two models (NA, 0A, SA) and (NB, 0B, SB) of the Peano axioms, the homomorphism f : NA  NB defined as
23:40:26 <solrize>     \begin{align} f(0_A) &= 0_B \\ f(S_A (n)) &= S_B (f (n)) \end{align}
23:40:26 <solrize> is a bijection. The Peano axioms are thus categorical; this is not the case with any first-order reformulation of the Peano axioms, however.
23:41:17 <solrize> cale, it's not even true that every first order axiomitization of N is either inconsistent or incomplete
23:41:27 <solrize> that only holds if the axiomitization is recursively enumerable
23:41:56 <solrize> that is one of the preconditions of goedel's theorem
23:42:01 <papermachine> Oh, you're using the second-order axioms.
23:42:02 <Cale> Of course.
23:42:23 <solrize> papermachine, right
23:42:27 <papermachine> Also, categorical doesn't mean that there's only one model
23:42:37 <papermachine> it means there's one model of a given cardinality
23:42:47 <solrize> papermachine, hmm
23:42:59 <papermachine> upper lowenheim-skolem says that if there's one of cardinality aleph_null, then there's one for each aleph_k
23:43:02 <papermachine> IIRC
23:43:27 <solrize> papermachine, hmm
23:43:44 <papermachine> That fragment should say "where N is a countably infinite set"
23:43:57 <quicksilver> solrize: you confused me a bit with terminology there.
23:44:05 <quicksilver> See here for a critique on that WP article:
23:44:06 <quicksilver> http://sci.tech-archive.net/Archive/sci.math/2006-04/msg02876.html
23:44:08 <lambdabot> Title: Re: A few questions about the Peano axioms, http://tinyurl.com/5ekr92
23:45:38 <quicksilver> (not that sci.math is likely, on average to be better than WP. I suspect the opposite is true. sci.math can be dire. However that speaker certainly mirrors the mathematical orthodoxy as I am aware of it)
23:45:43 <solrize> quicksilver, yeah, i tried to distinguish that i meant the 19th century (i.e. 2nd order) version of the axioms
23:46:26 <papermachine> The 2nd-order version can be embedded into first-order logic as well
23:46:33 <solrize> http://www.questia.com/PM.qst?a=o&d=79130973
23:46:37 <lambdabot> Title: In the Light of Logic
23:46:46 <rwbarton> I wouldn't guess that upward lowenheim-skolem would apply to second-order logic though?
23:47:47 <papermachine> rwbarton: I guess I'm just stuck in a first-order mindset today
23:49:24 <jekor> How can you match against Unicode strings using Unicode character classes? I'd like to be able to match against a string like "Jos" with a regex like "^[[:alnum:]]$". I've tried Text.Regex.PCRE, Text.Regex.TDFA with no luck (and I'm unable to compile Text.Regex.DFA and Text.Regex.Parsec). Is what I'm trying to do even possible?
23:51:09 <solrize> iirc there is not any way in 1st order logic to describe the set of true sentences over N
23:51:30 <solrize> in the sense that one can describe (but not construct), say, the set of halting turing machines
23:51:44 <solrize> or equivalently the set of true pi-1 sentences
23:51:49 <papermachine> solrize: that sounds right
23:53:18 <solrize> looks like my program finished, now i gotta do some work, bbl ;)
23:54:21 <Cale> I remain unconvinced that this has any bearing on whether we should accept the powerset axiom.
23:55:40 <solrize> i think feferman's view is more like, accept the powerset axiom but reject the axiom of infinity
23:55:49 <Cale> oh really?
23:56:18 <solrize> yeah, i think he's ok with there being infinite classes
23:56:29 <Cale> That's even more ridiculous, in my opinion.
23:56:39 <solrize> why?
23:56:47 <Cale> Oh, so N is a proper class?
23:56:50 <solrize> yeah
23:56:57 <solrize> so there's no 2**N
23:57:02 <rwbarton> It sounds OK as a "foundation", but not as a "foundation for mathematics". :)
23:57:08 <lament> haha
23:57:10 <Cale> Yeah.
23:57:20 <Cale> solrize: So there's no R.
23:57:39 <lament> it's exactly what you want to analyze calculations done by a computer program
23:57:40 <solrize> right, if there is such a thing as R, then CH is either true or false, but he says it's meaningless
23:57:42 <papermachine> Are there even functions with N as a domain, then?
23:57:50 <Cale> solrize: what?
23:57:56 <lament> that's operating on a discrete machine and runs for finite time
23:58:14 <Cale> solrize: By "Either true or false" do you mean "decidable"?
23:58:40 <Cale> Or do you mean that (CH \/ ~CH) which is obviously true.
23:59:05 <lament> Cale: yes, obviously true
23:59:11 <solrize> cale, if (CH \/ ~CH) is true, then either CH is true or ~CH is true
23:59:16 <lament> but not if you reject the existence of 2**n
23:59:43 <Cale> solrize: But neither CH nor ~CH is provable.
