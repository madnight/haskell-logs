00:00:09 <Baughn> I see. The correct solution would be to fix the optimizer, though, not make it easier to do manually.
00:00:24 <Baughn> (Though you could presumably combine the two)
00:00:25 <sjanssen> it's a fundamental problem with parametric polymorphism -- a function that works on "Maybe a" has to work on everything, requiring a uniform representation
00:00:50 <Baughn> To specialize the data, you'd have to also specialize all functions that can touch it
00:00:54 <Kitchy> Who's Haskell's developer?
00:00:56 <sjanssen> right
00:01:09 <Baughn> That's not a fundamental problem, that's just a lot of work
00:01:16 * dolio wonders why his irc connection always seems to cut out just after he says something after a period of long inactivity.
00:01:20 <Baughn> Kitchy: Anonymous
00:01:25 * [R]ayne Types /whois haskell's developer just for kicks.
00:01:49 <Baughn> dolio: Hm? When do you think it cut out?
00:02:06 <Saizan> dolio: because your client doesn't check regurarily if it's still connected
00:02:17 <sjanssen> Baughn: so I want modules to have type arguments, all functions and data in that module will be specialized against each different argument type
00:02:22 <Baughn> Well, he was connected until 8:56
00:02:23 <int-e> Baughn: there's a problem. if you specialise the data constructor, you'll also have to specialise all functions taking the polymorphic version as arguments, or pay the cost of rewrapping the data when calling such a function.
00:02:36 <dolio> sjanssen said he wants to specialize map. I said data/type families. Then it lagged for 3 minutes and reconnected.
00:02:48 <sjanssen> dolio: yeah, we didn't get that
00:03:04 <Baughn> dolio: Are you behind a NATwall?
00:03:17 <Baughn> dolio: (Solution: Use the ipv6 freenode server)
00:03:33 <sjanssen> dolio: data families allow specialized data, but you have to rewrite each function that operates on the data
00:03:35 <dolio> I believe so. I haven't fiddled with my router much.
00:03:49 <Baughn> dolio: Ah. Router, no less.
00:04:01 <Baughn> dolio: There are /reasons/ why I always insist on using PCs for routers. :P
00:04:02 <Cthulhon> Kitchy: Yes, Baughn is right, Haskell is a collaborative /b/ project.
00:04:02 <Kitchy> I was just wondering who sues me if I create a new language and call it Haskell.
00:04:10 <dolio> :)
00:04:16 <Baughn> Well, that or very high-end routers
00:04:29 <Cthulhon> That's why it plays with your head.
00:04:34 <dolio> sjanssen: You just want to specialize all the functions to Int functions?
00:04:39 <Baughn> Kitchy: Nobody, but you'd get attacked by hackers on steroids
00:04:58 <sjanssen> dolio: yes, all the functions in Data.Map
00:05:36 <Baughn> sjanssen: There already is IntMap, of course
00:05:52 <sjanssen> and with a C++ template-like system, we also avoid the polymorphism issue, since Map specialized to Int is a different type from Map specialized to Char
00:06:48 <dolio> I mean, GHC does that kind of thing if you tell it to inline everywhere at least. :)
00:06:57 <sjanssen> Baughn: IntMap is an interesting point.  It is faster in practice than Map, but nobody knows if this is because of the Int specialization, or because tries are simply better
00:07:23 <dolio> Provided the types are statically known.
00:07:25 <Baughn> sjanssen: It can't be both?
00:07:52 <dolio> Tries being better for Ints is questionable.
00:07:53 <sjanssen> Baughn: maybe it is, but I don't think anybody actually knows
00:07:59 <dolio> It's not as obivous as, say, lists.
00:10:43 <dolio> I'm not sure it even requires inlining. For instance, the stuff in the recursive benchmark on the shootout gets specialized (barring bugs in 6.8.3).
00:10:49 <dolio> And they aren't really suitable for inlining.
00:11:01 <sjanssen> Baughn: for an example of the importance of this sort of specialization, see Data.Sequence
00:11:08 <dolio> But perhaps cross-module specialization isn't done.
00:11:13 <sjanssen> dolio: I don't think GHC will specialize the data under any circumstances
00:11:53 <dolio> Oh, no, perhaps not.
00:12:14 <sjanssen> that is what I really want.  I want to specialize the data, and generate functions that will work on the specialized type
00:12:46 <dolio> Yeah, I guess I'm pretty sure it doesn't.
00:13:25 <dolio> Since, for instance 'data Pair = P !Int !Int' gets appropriately unboxed. But 'data Pair a b = P !a !b' doesn't when used as 'Pair Int Int'.
00:13:32 <hml> anyone here got haskore running on macosx ?
00:13:37 <sjanssen> dolio: exactly
00:13:50 <dolio> So if it were generating specialized types, presumably the relevant optimizations would kick in.
00:14:29 <int-e> dolio: yes, but unboxing the latter would open a can of worms. You'd have to have several versions of all functions that involve P a b polymorphically anywhere.
00:15:12 <sjanssen> int-e: this is why I want to specialize entire modules -- make the specialized Int pair totally separate from all other pairs
00:16:01 <dolio> Sure. It's potentially a code explosion if you have Pair used at several statically known types.
00:16:55 <sjanssen> and you might have to repack in cases where the compiler isn't smart enough
00:16:58 <int-e> dolio: even more interestingly, how do you handle code that takes arguments of type (forall a . Pair a a -> b) and is called with various Pair types internally? One of those pair may have type Pair Int Int.
00:18:07 <dolio> int-e: You default to what GHC does now, and only generate specialized code when you statically know the concrete types used?
00:19:38 <int-e> dolio: hmm. then you can never put your specialized pair into any data structures ... f :: [Pair Int Int] may look harmless, but what if that value ever gets used in a context where a different list of pairs may also be used?
00:20:20 <int-e> dolio: then you find yourself having to repack Pairs that are hidden in a data structure that you don't know much about in the general case.
00:20:32 <int-e> dolio: (the list is just an example)
00:21:03 <dolio> Ah. That is a conundrum.
00:21:57 <int-e> dolio: the best you can hope for, I think is something like a  newtype IntPair = IntPair (Pair Int Int) with *non-noop* construction and deconstruction, and with specialised code for dealing with those pairs.
00:22:32 <adu> YEY
00:22:36 <adu> my python thing worked!
00:22:37 <Saizan> JHC already pattern matches on types for typeclasses, so maybe it would be easier there
00:22:58 <sjanssen> int-e: I was just about to suggest something like newtypes.  That with aggressive optimization on newtype derived classes might be sufficient
00:23:05 <ivanm> has anyone here ever used the pandoc library?
00:23:22 <ivanm> (as in using pandoc _as_ a library)
00:25:25 <ttt--> hi, how is state usually kept in ui apps? for example: i have login data that can be entered and will be used by other actions
00:25:26 <int-e> sjanssen: yes, it might work.
00:27:23 * ivanm wonders if it would be easier just to try and create the markdown directly rather than using the pandoc library
00:29:41 <ttt--> the real world haskell book example uses a database connection as state
00:30:05 <ttt--> is there a similar IO thing i can use to read/write too?
00:30:11 <sjanssen> perhaps a new SUPERUNPACK pragma that unpacks data, and also unpacks all strict components which now have a concrete type
00:32:23 <zeno__> @pl (\a b -> a ++ [b])
00:32:24 <lambdabot> (. return) . (++)
00:35:41 <Saizan> ttt--: you need persistency?
00:36:21 <mmorrow> ivanm: it probably will be easier to do it youself. that way you can have it do it how you want it done, and be lightweight. just Text.PrettyPrint is key, as is making a class Ppr a where ppr :: a -> Doc ; pprs :: [a] -> Doc
00:42:27 <mmorrow> , let ppr (id,args,stmts) = text "function" <> parens (hcat . punctuate comma . fmap text $ args) <> text "{" $+$ nest 2 (vcat . fmap ((<>semi) . text) $ stmts) $+$ text "}" in ppr ("map",["f","xs"],["blah(42)"])
00:42:29 <lunabot>  function(f,xs){
00:42:29 <lunabot>    blah(42);
00:42:29 <lunabot>  }
00:43:28 <ttt--> Saizan, no just a way to store state
00:43:52 <ttt--> during the run of the program
00:44:24 <ttt--> It might be simple, im new :)
00:46:09 <ttt--> I'll try IORef
00:46:36 <Saizan> ttt--: i'd suggest State or StateT s IO
00:56:31 <lightstep> which gui library supports shaped windows?
00:57:50 <lightstep> never mind, i see gtk2hs does
01:02:15 <ivanm> @tell mmorrow well, I wanted it to output to pandoc format so it could then be turned to other formats :s
01:02:16 <lambdabot> Consider it noted.
01:09:49 <zeno__> > foldl (\a b -> a:b) "q" ['a'..'s'] :: Expr
01:09:50 <lambdabot>       Occurs check: cannot construct the infinite type: a = [a]
01:09:50 <lambdabot>        Expect...
01:15:44 * Wild_Cat reads up on the Haskell platform... This sure does look interesting.
01:17:38 <adu> Wild_Cat: platform?
01:17:48 <adu> Wild_Cat: when did Haskell become a platform?
01:17:53 <Wild_Cat> adu: http://haskell.org/haskellwiki/Haskell_Platform
01:17:54 <lambdabot> Title: Haskell Platform - HaskellWiki
01:18:05 <Wild_Cat> since dons and dcoutts decided to do something about it, it'd seem ;)
01:18:34 <Wild_Cat> and that's a decision I fully support, being a Python guy first and foremost.
01:21:28 <adu> reminds me of http://vis.cs.ucdavis.edu/~ogawa/codeswarm/
01:21:29 <lambdabot> Title: code_swarm
01:22:05 <Wild_Cat> ooh, pretty!
01:22:27 <adu> Wild_Cat: also, I'm working on a binding to the Python API right now, wanna see?
01:22:56 <Wild_Cat> adu: you mean a Haskell-Python binding?
01:23:02 <Wild_Cat> sure, go ahead.
01:25:10 <adu> http://hpaste.org/10801
01:26:07 <adu> I'm trying to make reasonable wrappers, like objPrint = flip object_Print stdout
01:26:50 <adu> and since CFile is such a pain to deal with object_Print is a wrapper for PyObject_Print that takes a Handle instead of Ptr CFile :)
01:27:19 <Wild_Cat> hrmm, so it'd make it possible to write Python exts in Haskell? Good good!
01:27:29 <adu> ya!
01:27:40 <Wild_Cat> you should probably make use of type classes, though.
01:27:52 <adu> Wild_Cat: how so?
01:28:05 <adu> I'm already using "fromString" which comes from IsString type class
01:28:25 <adu> I made an instance for IsString PyObj
01:28:53 <Wild_Cat> adu: well, I was thinking of something more complex, in which you'd map the core Python object hierarchy to a typeclass hierarchy as well.
01:28:56 <adu> or are you saying PyObj should be a typeclass for PyString, PyList, etc...
01:29:16 <Xenoblitz> hi guys ... i'm using HGL and it has only say 8 Colors defined... I know i might be asking something complete stupid... but is it possible to extend them somehow?
01:29:16 <adu> that could work
01:29:36 <adu> whats hgl?
01:29:37 <Wild_Cat> with pretty much everything deriving from the PyObject class
01:30:00 <Xenoblitz> :adu Haskell Graphics Library
01:30:05 <Xenoblitz> *adu:
01:30:06 <Xenoblitz> sorry
01:30:11 <Wild_Cat> (I think that's more or less what Gtk2Hs does)
01:31:00 <adu> well Python is very similar to Gtk internally
01:31:14 <adu> and most OOP-C things for that matter...
01:31:52 <Wild_Cat> it looks better, though :p
01:34:32 <adu> well I'm only going to do the heirarchy for core objects, cuz I'm doing this by hand, not c2hs
01:35:45 <EvilTerran> Xenoblitz, http://hackage.haskell.org/packages/archive/HGL/3.2.0.0/doc/html/Graphics-HGL-Draw-Text.html#t%3ARGB ?
01:35:51 <lambdabot> Title: Graphics.HGL.Draw.Text, http://tinyurl.com/4rkhky
01:35:56 <int-e> Xenoblitz: HGL has RGB support it seems; it's the SOE module that comes with it that is overly simplified, and apparently, without any backdoors.
01:37:05 <Xenoblitz> EvilTerran: I saw that website earlier... it does define RGB but there is no way to convert and RGB to Color as far as I know :/
01:37:11 <quicksilver> adu: have you seen how WxHaskell encodes the hierarchy?
01:37:17 <quicksilver> adu: that's quite unusual/clever.
01:37:25 <adu> nope
01:37:28 <EvilTerran> Xenoblitz, where's "Color" defined??
01:37:32 <Xenoblitz> int-e: same as EvilTerran
01:37:41 <mmorrow> lunabot gives 32 lines (max) of output now in /msg fyi.
01:37:41 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
01:37:44 <quicksilver> adu: "Window a" meaning 'any subclass of Window'
01:37:45 <Xenoblitz> EvilTerran: just a sec lemme find a link
01:37:54 <adu> i have spent nearly 0 seconds using wx or gtk
01:37:58 <quicksilver> adu: "Window ()" meaning '*exactly* Window, not a subclass'
01:37:59 <EvilTerran> I don't see it in the HGL documentation there
01:38:05 <EvilTerran> ah, SOE
01:38:20 <quicksilver> adu: and "Window (Button a)" meaning 'A window which is actually a Button'
01:38:29 <quicksilver> given that Button is a subclass of Window in C++.
01:38:47 <quicksilver> adu: you don't need to care about wx as a toolkit ;) it is just an interesting way to encode subclasses in haskell.
01:38:51 <EvilTerran> Xenoblitz, i found it: http://hackage.haskell.org/packages/archive/HGL/3.2.0.0/doc/html/Graphics-SOE.html#t%3AColor
01:38:52 <lambdabot> Title: Graphics.SOE, http://tinyurl.com/3hq74x
01:39:00 <Xenoblitz> EvilTerran: no no its HGL itself... http://cvs.haskell.org/Hugs/pages/libraries/HGL/Graphics-HGL-Utils.html#t%3AColor
01:39:02 <lambdabot> Title: Graphics.HGL.Utils, http://tinyurl.com/4qbjfe
01:39:25 <adu> quicksilver: I never said I didn't care! I love wx, just never used it in Haskell
01:39:40 <EvilTerran> right, well, you can't convert RGB to Color in general
01:39:47 <mmorrow> this draws a pretty picture in /msg :) , let f m n = return (n, takeWhile (<m) . take 2 . iterate (+1) $ (n+1)) in text . drawForest . (fmap . fmap) show . concat $ (unfoldForestM_BF (f 4) [0]::[Forest Int])
01:39:47 <Xenoblitz> :/
01:39:48 <quicksilver> adu: no that's fine too ;) but it's irrelevant to my point. I was just pointing you at an unusual way to encode subclasses.
01:39:56 <adu> ok
01:40:01 <EvilTerran> because, as you can see in the documentation, there's only 8 possible values for Color
01:40:11 <mmorrow> unfoldForestM_BF is a hidden gem
01:40:18 <EvilTerran> however, most of the functions outside SOE seem to take an RGB instead of a Color anyway
01:40:29 <mmorrow> (from Data.Tree)
01:40:50 <mmorrow> (related to that okasaki breadth-first-numbering paper/pearl)
01:40:58 <int-e> Xenoblitz: withColor c g = withRGB (colorTable ! c) g
01:41:47 <int-e> Xenoblitz: you can use withRGB (RGB red blue green) g  instead of withColor Red g  I think
01:42:36 <Xenoblitz> EvilTerran: its weird that SOE has something better than HGL
01:42:58 <int-e> it does?
01:43:15 <EvilTerran> it does?
01:43:17 <mmorrow> @tell ivanm that's definitely a reason to go the pandoc route. i looked at it briefly once for converting latex table to html tabs, but it didn't do what i wanted in that case.
01:43:17 <lambdabot> Consider it noted.
01:43:18 <Xenoblitz> int-e: as from what evilterran is saying :P
01:43:22 <EvilTerran> what?
01:43:43 <EvilTerran> "most of the functions outside SOE seem to take an RGB" <- as in, the functions outside SOE are *more* versatile
01:43:46 <Xenoblitz> i mean does SOE let you write your own colors using rgb values? or i misunderstood you?
01:43:52 <Xenoblitz> AH
01:43:56 <Xenoblitz> i read that inside
01:43:57 <Xenoblitz> -_-
01:43:59 <Xenoblitz> sorry
01:44:04 <int-e> Xenoblitz: No. SOE doesn't. HGL does.
01:44:31 <EvilTerran> colour me confused
01:44:37 <EvilTerran> i can't find SOE on that page you linked from
01:44:50 <Xenoblitz> sorry about that confusion guys
01:45:03 <Xenoblitz> i'll try withRGB (RGB red blue green) g
01:45:04 <int-e> With SOE, I mean this, http://hackage.haskell.org/packages/archive/HGL/3.2.0.0/doc/html/Graphics-SOE.html
01:45:05 <Xenoblitz> and see if it works
01:45:06 <lambdabot> Title: Graphics.SOE, http://tinyurl.com/3hq74x
01:45:21 <EvilTerran> my fault, i'm trying to be helpful before the first cup of coffee of the day
01:45:24 <EvilTerran> confusion was inevitable
01:45:27 <EvilTerran> brb, coffee
01:45:29 <Xenoblitz> hehe :)
01:45:44 <mmorrow> that is an interesting way to encode subclasses. hmm.
01:45:53 <Xenoblitz> i'll give it a shot guys and let you know... btw how does hackage work really?
01:46:10 <int-e> sorry for bringing SOE up at all. I did because that's the only place where I found the limited Color datatype.
01:46:11 <Xenoblitz> i mean i know its sort of like a repo but ... how do you include stuff from there?
01:46:55 <int-e> you can download the packages and build them. or you can build cabal-install and then use that to do the work for you.
01:47:18 <mmorrow> wget _.tar.gz && tar -xzf _.tar.gz && ghc cd blah blah && ghc --make Setup.*hs && ./Setup configure && ./Setup build && sudo ./Setup install
01:47:35 <mmorrow> (or some people more hip use cabal install)
01:47:39 <Xenoblitz> hehe
01:47:52 <Xenoblitz> what about windows (omgosh he uses windows still?)
01:47:56 <Xenoblitz> hehe
01:48:06 <mmorrow> i dunno about windows...
01:48:42 <Xenoblitz> i have a feeling haskell will turn me unix
01:48:43 <int-e> Xenoblitz: me either, but in principle the Setup configure, Setup build, Setup install  should still work.
01:48:50 <Xenoblitz> cool thanks
01:51:51 <DekuDekuplex> Hi.  Just wondering ... does anybody know of any math humor linking Dedekind cuts and chocolate?
01:53:00 <humasect> :t ("asdf"++"lkjh"++)
01:53:01 <lambdabot>     The operator `++' [infixr 5] of a section
01:53:01 <lambdabot>         must have lower precedence than the operand `(++)' [infixr 5]
01:53:01 <lambdabot>         in the section: `("asdf" ++ "lkjh" ++)'
01:53:19 <humasect> hm, interesting error message. it is not ghc standard?
01:53:46 <humasect> also, what is it saying exactly? =)
01:54:27 <sjanssen> humasect: you can't use operators of the same precedence in a section
01:54:33 <int-e> :t (("asdf"++"lkjh")++)
01:54:34 <lambdabot> [Char] -> [Char]
01:54:36 <humasect> what is a section ?
01:54:48 <humasect> ahh, thanks int-e .. now i understand what it means too =)
01:54:49 <quicksilver> (1+) is a section.
01:54:52 <sjanssen> humasect: an operator applied to only one of two arguments
01:54:54 <int-e> :t (++"asdf"++"lkjh")
01:54:54 * quicksilver defines by example.
01:54:56 <lambdabot> [Char] -> [Char]
01:55:19 <quicksilver> int-e: wow. I never knew that was possible :)
01:55:24 <humasect> hm.. and int-e 's example then changes the sensicalness.
01:55:27 <int-e> humasect: the error message claims that 5 is smaller than 5 though - that's bad.
01:55:41 <humasect> ah that is what i initially figured
01:55:48 <sjanssen> int-e: no, it says "must have lower precedence"
01:56:04 <humasect> should ("asd"++"asd"++) be ok just as (++"asd"++"asd") is
01:56:05 <humasect> ?
01:56:17 <sjanssen> not "does have lower precedence"
01:56:18 <int-e> :t (1*2*) -- note: left associative
01:56:19 <lambdabot> forall t. (Num t) => t -> t
01:56:30 <int-e> :t (++""++"") -- and right associative
01:56:30 <humasect> hmm.
01:56:31 <lambdabot> [Char] -> [Char]
01:56:39 <quicksilver> humasect: in a sense (++) is fully associative.
01:56:44 <quicksilver> humasect: but (a) haskell doesn't know this.
01:56:45 <humasect> int-e: infixl and infixr ?
01:56:50 <quicksilver> humasect: (b) it isn't really, in complexity.
01:57:40 <humasect> :t (<<[])
01:57:41 <lambdabot> Not in scope: `<<'
01:57:46 <humasect> oh, hehe..
02:00:35 <mmorrow> looks like you can only use them that way if it's going the same way as their fixity
02:00:53 <quicksilver> yes, because ((1*2)*) is allowed
02:00:54 <mmorrow> > ("asdf"++"jkl;"++) []
02:00:55 <lambdabot>       The operator `++' [infixr 5] of a section
02:00:55 <lambdabot>          must have lower prec...
02:01:03 <quicksilver> and (1*2*) produces the same AST as that.
02:02:17 <mmorrow> good to know this extra chance for ditching parens
02:02:24 <int-e> humasect: yep
02:03:37 <mmorrow> , $(lift =<< reify '(.))
02:03:39 <lunabot>  VarI GHC.Base.. (ForallT [b_1627414541,c_1627414542,a_1627414543] [] (App...
02:03:51 <mmorrow> , cleanNames' $(lift =<< reify '(.))
02:03:53 <lunabot>  VarI . (ForallT [b,c,a] [] (AppT (AppT ArrowT (AppT (AppT ArrowT (VarT b)...
02:03:57 <mmorrow> gah
02:05:46 <Xenoblitz> thanks EvilTerran and int-e, your suggestions worked ... i had misunderstood things... i thought that HGL was limited to 8 colors only when in fact Color is just a help :)
02:05:54 <Xenoblitz> ^^
02:07:14 <humasect> :t reify
02:07:15 <lambdabot> Not in scope: `reify'
02:07:42 <humasect> Xenoblitz =)
02:26:45 <insitu> hello, i am trying to use fcgi as described at http://mult.ifario.us/p/wiring-haskell-into-a-fastcgi-web-server using ghc-6.8.2 and apache 2.2.8 on Ubuntu Hardy Heron
02:26:56 <lambdabot> Title: wiring-haskell-into-a-fastcgi-web-server
02:28:00 <insitu> apache keeps replying 500 with logs showing incomplete headers received from thee fcgi script
02:34:01 <EvilTerran> np, Xenoblitz :)
02:35:47 <earthy> insitu: you need to explicitly set the status of your CGI with setStatus
02:36:08 <earthy> Network.FastCGI does not seem to default to a particular status
02:36:32 <earthy> and if apache is being strict in interpreting the result of your CGI that will say 'incomplete headers'
02:36:57 <earthy> so, add e.g.   setStatus 200 "OK"     to your CGI script
02:39:49 <mapreduce> > (3 :: Int) `div` (2 :: Int)
02:39:50 <lambdabot>   1
02:41:14 <insitu> earthy: thanks for the tip ! It works way better.
02:41:47 <mapreduce> > let midPoint x y = (x + y) `div` (2 :: Int) in midPoint (1000000000 :: Int) (2000000000 :: Int)
02:41:48 <lambdabot>   /home/cale/.lambdabot24: Not in scope: `description'/home/cale/.lambdabot38...
02:41:48 <lightstep> Xenoblitz, re windows, i found that cabal install works there too
02:41:55 <mapreduce> > "broken bot"
02:41:55 <lambdabot>   /home/cale/.lambdabot24: Not in scope: `description'/home/cale/.lambdabot38...
02:42:16 <dancor> > (3 :: Float) `div` (2 :: Float)
02:42:16 <lambdabot>   /home/cale/.lambdabot24: Not in scope: `description'/home/cale/.lambdabot38...
02:42:29 <mapreduce> Cale: @undefine seemed to kill it.
02:43:22 <Cale> @undefine
02:43:29 <Cale> > 1 + 1
02:43:31 <lambdabot>   2
02:52:48 <EvilTerran> > [f,g] <*> [x,y,z] :: [Expr]
02:52:50 <lambdabot>   [f x,f y,f z,g x,g y,g z]
02:57:04 <Twey> @src (<*>)
02:57:05 <lambdabot> Source not found. Wrong!  You cheating scum!
02:57:07 <Twey> :(
02:57:14 <Twey> @src [] (<*>)
02:57:14 <lambdabot> (<*>) = ap
02:57:19 <Twey> @src ap
02:57:19 <lambdabot> ap = liftM2 id
02:57:32 <ttt--> Doesnt ghc always infer the most general type?
02:57:38 <Twey> .ua
02:58:00 <quicksilver> ttt--: yes.
02:58:06 <quicksilver> ttt--: FSOV of most general type.
02:58:38 <ttt--> it infers: "boxNatural :: VBox -> Widget -> IO ()"
02:59:07 <ttt--> isnt this more general --boxNatural :: (WidgetClass c, BoxClass s) => s -> c  -> IO ()
02:59:15 <quicksilver> yes.
02:59:22 <quicksilver> There must be a reason it inferred that type.
02:59:29 <quicksilver> it would have inferred the more general if it did apply.
02:59:46 <ttt--> when i add the type in the code, it compiles
02:59:56 <ttt--> without it, it gives a compile error
03:00:19 <mmorrow> heh, adding strategic type sigs is half of haskell programming ;)
03:00:21 <quicksilver> that's odd.
03:00:27 <maltem> ttt--: Not having seen the code,  suspect the monomorphism restriction
03:00:32 <quicksilver> ttt--: can you paste the code? or at least the error?
03:00:37 <maltem> s/suspect/I suspect/
03:00:45 <quicksilver> the monomorphism restriction seems likely. But not as applied to that binding.
03:00:59 <quicksilver> perhaps some other binding in the same inference group.
03:01:03 <maltem> hm yeah
03:02:54 <ttt--> http://hpaste.org/10803
03:03:51 <maltem> now, that looks to me like the MR applied to boxNatural
03:04:23 <ttt--> ok thanks
03:04:30 <quicksilver> nope.
03:04:35 <quicksilver> boxNatural is of function type.
03:04:38 <quicksilver> MR doesn't not apply.
03:05:28 <maltem> hm...
03:05:29 <quicksilver> ttt--: I don't think your boxNatural is in scope.
03:06:02 <quicksilver> or not with the type signature you show in that paste.
03:06:22 <quicksilver> maltem: in any case, he's using explicit type sigs.
03:06:30 <maltem> quicksilver: I think he gets the error when omitting the type sig
03:06:35 <ttt--> yes, sorry
03:06:49 <ttt--> it compiles when i put the sig
03:07:06 <quicksilver> you omit both sigs?
03:07:13 <quicksilver> boxNaturalN as well?
03:08:03 <Japsu> @dice 1d44
03:08:04 <lambdabot> 1d44 => 17
03:08:11 <quicksilver> what's the type of boxPackStart?
03:08:15 <quicksilver> need to see more code, anyhow
03:08:16 <mmorrow> @dice
03:08:16 <lambdabot> unexpected end of input: expecting number
03:08:20 <quicksilver> I can't see any reason for that error.
03:08:20 <mmorrow> @dice 0
03:08:21 <lambdabot> 0 => 0
03:08:23 <mmorrow> @dice 1
03:08:23 <lambdabot> 1 => 1
03:08:30 <maltem> so the type checker tries to specialize boxNatural to either of VBox -> Widget -> IO (), VBox -> TreeView -> IO ()
03:08:41 <quicksilver> why would it do that?
03:08:55 <mmorrow> @dice 11235813
03:08:56 <lambdabot> 11235813 => 11235813
03:09:10 <mmorrow> @dice jkl;
03:09:10 <lambdabot> unexpected "j": expecting number
03:09:15 <mmorrow> @dice 9kl;
03:09:16 <lambdabot> unexpected "k": expecting digit, "d", "+" or end
03:09:16 <cjs> I must be missing something silly here. What is the source of this error? http://hpaste.org/10804
03:09:19 <maltem> because boxNatural is called with expressions of those types
03:09:27 <mmorrow> @help dice
03:09:27 <lambdabot> dice <expr>. Throw random dice. <expr> is of the form 3d6+2.
03:09:47 <mmorrow> uh
03:09:48 <quicksilver> ttt--: oh.
03:09:53 <cjs> And what does it mean when I get "Paterrn match(es) are non-exhaustive" with an empty list of "Patterns not matched"?
03:09:56 <quicksilver> ttt--: you need to name the parameters to boxNatural.
03:10:04 <mmorrow> @dice 3d9999999999999999+7
03:10:04 <lambdabot> 3d9999999999999999+7 => 14212817993356070
03:10:05 <quicksilver> boxNatural = boxNaturalN 0
03:10:12 <quicksilver> boxNatural s c = boxNaturalN 0 s c
03:10:21 <quicksilver> ttt--: sorry I shoul dhave spotted that straight away.
03:10:30 <quicksilver> to stop the MR kicking in, you need to name at least one parameter.
03:10:35 <quicksilver> (sucks, doesn't it?)
03:10:40 <maltem> haha, my first suspection was right this time on #haskell. What a feeling :)
03:12:09 <Cthulhon> @dice 1d20
03:12:09 <lambdabot> 1d20 => 18
03:12:18 <Cthulhon> Decent.
03:12:22 <mmorrow> lol
03:12:22 <ttt--> quicksilver, yes
03:12:33 <ttt--> it compiles if i name one parameter
03:12:35 <ttt--> weird
03:12:38 <Cthulhon> I wish I still had my D&D dice.
03:12:47 <maltem> ttt--: Alternatively, you can use the language extrension NoMonomorphismRestriction (but then you're not Haskell-98 anymore)
03:12:54 <mmorrow> i wish i had a sheet of cardboard and an alley
03:12:57 <mmorrow> (dice too)
03:13:50 <maltem> ttt--: Hitting the MR is something any Haskell programmer must go through in his life
03:14:43 <ttt--> Why would naming a variable matter?
03:15:50 <maltem> ttt--: The MR says that something is monomorphic if it is declared without any named parameter (or that's what I think it is, roughly)
03:15:57 <quicksilver> ttt--: http://www.haskell.org/haskellwiki/Monomorphism_restriction
03:15:58 <lambdabot> Title: Monomorphism restriction - HaskellWiki
03:16:11 <quicksilver> it's do to with expectations about sharing and caching.
03:16:22 <quicksilver> take a look at that pafe, but feel free to ask more questions.
03:19:37 <cjs> No thoughts on my pattern match issue?
03:20:22 <quicksilver> cjs: well the empty list is surely a weird GHC bug
03:20:36 <cjs> Empty list?
03:21:00 <quicksilver> 11:09 < cjs> And what does it mean when I get "Paterrn match(es) are  non-exhaustive" with an empty list of "Patterns not matched"?
03:21:15 <cjs> Actually, that was the same issue. I've just realized, it's the guards.
03:21:29 <quicksilver> it doesn't know the guards are complete
03:21:37 <quicksilver> so as far as it is concerned there is no catch-all
03:21:48 <quicksilver> the incompleteness checker doesn't really work with guards :(
03:21:49 <cjs> I need to use otherwise instead of the <.
03:22:01 <quicksilver> I don't think that will fix it.
03:22:05 <quicksilver> maybe it will?
03:22:05 <quicksilver> hmm
03:22:08 <cjs> It does.
03:22:10 <quicksilver> yes, maybe it is smart enough.
03:22:11 <quicksilver> good.
03:23:14 <cjs> Well, if there's an otherwise, it has to work. It's unfortunate that it's not smart enough about the >/==/< comparisons, though.
03:23:29 <cjs> Since "otherwise" makes my lines longer. :-)
03:24:02 <maltem> Yeah it would be nice if the trichotomy of Ord could be stated in code
03:24:11 <quicksilver> it can.
03:24:18 <cjs> GT/LT/EQ.
03:24:20 <quicksilver> case compare n d of LT -> GT -> EQ ->
03:24:30 <maltem> ah
03:24:32 <maltem> right
03:24:34 <cjs> I actually did that, at one point, but it looked kinda ugly.
03:24:54 <cjs> But maybe a let will help.
03:25:10 <cjs> Ah, whatever.
03:25:11 <quicksilver> well n and d are locally bound
03:25:17 <quicksilver> so you can't push that any further out.
03:25:28 <cjs> Oh, this was in the other similar thing, not the one I posted.
03:25:42 <quicksilver> you can have a trichotomy combinator of your own if you like
03:25:49 <quicksilver> like 'either' but for this case
03:26:47 <quicksilver> @type \x y a b c -> case compare x y of LT -> a; EQ -> b; GT -> c
03:26:48 <lambdabot> forall t a. (Ord a) => a -> a -> t -> t -> t -> t
03:27:20 <quicksilver> rq d (MQ n : qs) = trichot n d (MQ (n-d) : qs
03:27:31 <quicksilver> ) qs (rq (d-n) qs)
03:27:39 <quicksilver> format according to taste.
03:29:51 <cjs> Hm. Of course. I still don't think enough in terms of HOFs.
03:33:16 <mmorrow> <cjs> Since "otherwise" makes my lines longer. :-)
03:33:19 <mmorrow> i know!
03:33:30 <mmorrow> i wish _ was synonymous with otherwise
03:33:34 <quicksilver> cjs: HOFs aren't always easy to read.
03:33:53 <quicksilver> cjs: it's great to be able to define new combinators but they have to be understood.
03:35:57 <cjs> Indeed.
03:45:43 <humasect> hehe mmorrow
03:46:05 <ukl> hello. I just tried to rebuild XMonadContrib from darcs, and I ran into the following issue: http://hpaste.org/10805  -- and Setup.lhs build fails as announced.
03:46:44 <ukl> I just haven't got time at the moment; so I thought I'd just tell someone. Oh uhm, this is not #xmonad...well, anyways
03:47:01 <humasect> for each view pattern i have, it says "pattern matches not exhaustive"
03:47:46 <quicksilver> I'm not hugely surprised to hear that.
03:48:26 <humasect> hmm. it is kind of silly if there is only one in use. oh well ..
03:48:55 <maltem> mmorrow, cjs: define sonst = otherwise :)
03:49:40 <cjs> I like the idea, but, "sonst"?
03:49:51 <maltem> cjs: German for otherwise
03:51:16 <cjs> Ah! In my case, "又は". :-)
03:51:30 <dancor> anyone know what might be going on here: runtime linker fatal only with runghc: http://hpaste.org/10806
03:51:40 <maltem> heh
03:51:51 <dancor> it wasn't happening before, must be from recent cabal install-ery?
03:52:10 <quicksilver> dancor: two versions of bytestring installed, I think.
03:52:17 <quicksilver> and one conflicting with the internal one, or something.
03:52:27 <humasect> $B$=$NB>!)!!$^$?$O!)!!A3$J$/$P!!!a!K(B
03:52:42 <ttt--> > [|3|]
03:52:43 <lambdabot>   <no location info>: parse error on input `|'
03:53:31 <quicksilver> humasect: is that APL?
03:53:51 <humasect> hm, i don't know what APL is
03:54:18 <quicksilver> it's an illegible programming language :)
03:54:19 <Ferdirand> can't be APL, it's only ascii chars :p
03:54:25 <humasect> ohh, that =)
03:54:27 <quicksilver> to my eyes, it looks like what you typed.
03:54:43 <humasect> no its japanese encoding; i must have utf-8 turned off.
03:55:06 <humasect> $B$3$NJ8;z$rFI$_$^$9$+!)(B
03:55:49 <humasect> word wrap is bad for your health; and so are variables, and typing something more than once
03:55:58 <mmorrow> αλλως
03:56:31 <dancor> quicksilver: yi-0.4.6.2 wants bytestring 0.9.1.x, wat should i do..
03:57:11 <dancor> quicksilver: removing my newer bytestring did solve that first problem
03:57:18 <quicksilver> I don't know.
03:57:23 <quicksilver> You need a dcoutts_ .
03:57:27 <dancor> bigtime!
03:57:41 * dancor hopes things will be better after 6.10
03:57:53 <quicksilver> I know little or nothing about cabal. Or multiple libraries versions at once. Or any of that bad stuff.
03:58:26 <hackage> Uploaded to hackage: BerkeleyDBXML 0.3
03:58:48 <maltem> dancor: I think it's OK if ghc is compiled against a different version of bytestring than yi, but all other libraries that yi depends on should be compiled against the same version as yi itself
03:59:56 <dancor> so i should just rebuild everything after installing the newer bytestring
04:00:40 <maltem> dancor: Well I don't know if your problem has anything to do with it at all, but in general, yes
04:04:32 <humasect> speedbar and M-x compile work with haskell; great =) thought speedbar seemed less productive than i thought it would be. what do you guys use? anything with syntax highlight? yi?
04:04:49 <humasect> leskah?
04:05:09 <quicksilver> emacs + haskell-mode does what I need.
04:05:13 <mmorrow> dancor: get a src ghc (better yet, get src 6.10), and if the version you get doesn't come with the newest bytestring, get it, and build from source (you may be able to get a 6.10 binary, i'm not sure). only solution at the moment.
04:05:13 <quicksilver> just the built in dumb completion.
04:05:25 <humasect> ah, completion, i forgot about that.
04:05:52 <humasect> it can be smart if you work with it, naming your stuff with more rare combinations of chars at the beginning of symbols/names=)
04:06:43 <mmorrow> (only solution, without having to juggle multiple versions of multiple packages, the getting linker "duplicate symbol error"s at the least opportune times...
04:06:45 <mmorrow> )
04:07:02 <mmorrow> s/the/then/
04:07:23 <humasect> why does ghc get mad when a toplevel definition is not immediately following its type ? because it is a sanity check, or something technical ?
04:07:41 <quicksilver> it doesn't, actually.
04:07:45 <quicksilver> f,g :: Int
04:07:46 <quicksilver> f = 3
04:07:48 <quicksilver> g = 3
04:07:50 <quicksilver> is legal IIRC.
04:07:57 <humasect> i mean something like:
04:08:04 <humasect> f :: Int -> Int
04:08:09 <humasect> f 3 = 0
04:08:11 <humasect> g = 6
04:08:12 <humasect> f 1 = 0
04:08:20 <quicksilver> that's not definition following type
04:08:28 <quicksilver> that's equations not being together :)
04:08:29 <humasect> that's right . whatever it is called =)
04:08:31 <quicksilver> that's not what you said!
04:08:35 <humasect> right, so it is a sanity check ?
04:08:40 <quicksilver> equations being together is just to keep you sane.
04:08:43 <humasect> did i use different words ?
04:08:46 <quicksilver> equations are ordered after all.
04:08:52 <humasect> hehe. so it is nothing technical.
04:09:07 <quicksilver> well the fact that equations are ordered
04:09:22 <quicksilver> while definitions and declarations are not
04:09:22 <cjs> I could have so much fun if we didn't have to keep the definitions all together.
04:09:23 <humasect> skipping g as it is not f, f is still 'ordered'
04:09:23 <quicksilver> is technical.
04:09:29 <humasect> hehe cjs
04:09:35 <quicksilver> indeed, it is just sanity in a sense.
04:09:44 <quicksilver> but there is a technical pointP
04:09:53 <quicksilver> f's equations are ordered
04:10:00 <humasect> they still are ordered
04:10:00 <quicksilver> but f and g are not ordered w.r.t each other
04:10:03 <humasect> with a g in between
04:10:04 <quicksilver> so it's strange to interleave.
04:10:10 <quicksilver> yes I know that I'm not stupid.
04:10:34 <quicksilver> I'm saying that
04:10:41 <humasect> its fine if it is just a sanity check =)
04:10:46 <quicksilver> GIVEN that the order matters for the equations of f
04:10:53 <quicksilver> GIVEN that the relative order of f and g does not matter
04:11:01 <quicksilver> THEN it might be confusing to interleave f and g.
04:11:07 <quicksilver> thats all.
04:11:18 <quicksilver> but there is a technical point there: that order matters in some cases and not in others.
04:11:34 <quicksilver> it is confusing to intermingle order-significant things with order insignificant-things.
04:12:14 <humasect> i wonder on the amount of thrown away haskell code versus other languages
04:12:48 <rog_> hi, someone here said yesterday that type constraints on data declarations were misleading and a waste of time. does this also apply to newtype declarations? i only ask, 'cos i came across one in http://www.haskell.org/haskellwiki/New_monads/MonadRandom
04:12:49 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
04:13:14 <cjs> What is "thrown-away code"?
04:13:19 <humasect> :t lift
04:13:20 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (Monad m, MonadTrans t) => m a -> t m a
04:13:59 <humasect> cjs: i am not sure of the scientific word for it. but when code is refactored
04:14:03 <quicksilver> rog_: yes, I wouldn't bother with that.
04:14:11 <quicksilver> rog_: but OTOH you could say it doesn't do much harm.
04:14:42 <humasect> cjs: perhaps functions should be factored enough that they can be copy and pasted , as a lot of C refactoring is just this.
04:14:50 <rog_> i suppose at worst it's a "hard comment"
04:15:46 <rog_> quicksilver: ta
04:15:58 <quicksilver> rog_: it protects the constructor
04:16:07 <quicksilver> rog_: but it doesn't stop you needing annotations on the other functions.
04:16:15 <quicksilver> so it doesn't save what you hope it will save.
04:16:19 <quicksilver> but it does no harm.
04:16:32 <cjs> humasect: Depends on the coding style, I'd guess. Some people might refactor a lot, some very little.
04:16:37 <cjs> (I've seen both in Haskell.)
04:16:54 <humasect> ah, i see
04:17:11 <quicksilver> humasect: perhaps you mean "does haskell's expressivity mean you can refactor more easily and throw away less code when you do so?"
04:17:24 <quicksilver> the answer to that is "Yes, but only if you wrote the code well in the first place ;)"
04:17:40 <quicksilver> certainly well written haskell can have a very good separation of concerns.
04:17:45 <quicksilver> (but so can well-written code in any language)
04:17:57 <humasect> quicksilver: i see; what is writing code well ? for example a change in datatype can change a lot of functions along with it.
04:18:06 <humasect> yes, that's right
04:18:28 <rog_> quicksilver: i suppose it serves as a declaration of intent.
04:19:02 <humasect> i am not experienced enough to see it clearly for myself, but i have thrown away at least a 10-20% of this project's code, in recollection.
04:19:12 <rog_> quicksilver: and avoids the need to create a "smart constructor" (why are constructors syntactically distinct from functions, anyway?)
04:19:20 <quicksilver> rog_: becausey ou can pattern match on them.
04:19:31 <quicksilver> (and to your earlier questions, 'yes')
04:19:50 <quicksilver> humasect: if I could express what writing code well was in 256 chars then I would be out of a job ;)
04:19:52 <humasect> also, infix precedence i think. ie : f Data [something=s} = ...
04:20:01 <humasect> hehe qs
04:20:16 <quicksilver> humasect: but generally, it's the separation of unrelated concerns
04:20:19 <humasect> ... that should be *{something=s}
04:20:24 <quicksilver> good packaging of data with functions
04:20:27 <quicksilver> clear module boundaries
04:20:33 <quicksilver> sensible APIs at those boundaries
04:20:39 <humasect> hm, yes
04:20:43 <rog_> quicksilver: ah of course. has anyone thought about putting active patterns (a la F#) into haskell? or does the nature of the language make them unnecessary?
04:20:47 <humasect> that certainly helps (also in most languages)
04:20:59 <humasect> the main problem above all, for this project, is running into cyclic module imports. ouch!
04:21:14 <humasect> active patterns = view patterns ?
04:21:27 <rog_> humasect: maybe...
04:21:45 <rog_> humasect: microsoft have a talent for renaming everything
04:21:51 <humasect> hehe they sure do =)
04:21:55 <humasect> "active*"
04:22:09 <humasect> a function or expression supplied to 'filter' a pattern match
04:22:36 <humasect> not sure, rog_ : http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
04:22:43 <lambdabot> Title: ViewPatterns - GHC - Trac
04:23:13 <humasect> aka. Irrational Pattern Overload Warnings
04:24:55 <rog_> humasect: they do look related, at first glance
04:25:05 <humasect> hm i se
04:26:01 <rog_> i found them quite nice, as they enable you to leverage pattern matching for more than just the predefined types.
04:27:27 <humasect> oh? this sounds like haskell's normal pattern matching, though
04:27:42 <rog_> re: refactoring: FWIW, i've usually found that the code that i don't throw away is usually code that is large enough to do something independently useful, and that places no significant external stipulations on the caller.
04:28:30 <humasect> yes =)
04:28:34 <rog_> humasect: not really, as the shape of the haskell data structure may be hidden, but i might still wish to pattern match against aspects of it
04:29:40 <humasect> ah, like view patterns. say : renderPolygon (verticesOf -> vs) = ...  -- where the vertices are somehow unavailable without this method?
04:29:55 <humasect> can you show an example?
04:31:03 * rog_ is trying to think of a good example
04:32:38 <rog_> i think the F# paper says it best: http://blogs.msdn.com/dsyme/attachment/2044281.ashx
04:32:47 <lambdabot> Title: Extensible Pattern Matching via a Lightweight Language Extension
04:34:40 <quicksilver> humasect: it's about expanding the abstraction boundary so you can lie about your constructors.
04:34:51 <quicksilver> permit pattern matching against 'virtual' constructors
04:35:00 <quicksilver> without exposing your 'real' representation.
04:35:02 <rog_> it looks to me as if the main difference between view patterns & F#'s active patterns is a syntactic one: a view pattern looks different in form to a normal pattern; it's a little more syntactically heavyweight
04:35:26 <humasect> hm now i just want bananas.
04:35:35 <rog_> :-)
04:36:27 <humasect> what is real, what is virtual? what is exposed and what is not?
04:36:39 <humasect> or what is clearly existing and what is fuzzily assumed?
04:37:17 <quicksilver> of course you don't need view patterns to use views
04:37:32 <quicksilver> case (viewl s) of -> ViewL x xs ....
04:37:34 <quicksilver> works fine.
04:37:41 <quicksilver> view patterns are just a syntax cleanup.
04:37:48 <quicksilver> it's not entirely clear they've hit the right sweetspot.
04:37:58 <humasect> it avoids several let's for me
04:38:18 <humasect> not with the warning each of them seems to come with, no. but they can be pattern matched, too
04:38:28 <rog_> quicksilver: but nesting them requires nesting cases, which becomes annoying
04:38:30 <vixey> I wonder if,
04:38:34 <vixey> f (foo -> P1) = ...
04:38:38 <quicksilver> rog_: not necessarily.
04:38:38 <vixey> f (foo -> P2) = ...
04:38:38 <vixey> f (foo -> P3) = ...
04:38:50 <vixey> calls 'foo' once only, or several times
04:39:02 <quicksilver> case (viewl s, viewr t) of (ViewL x xs, ViewR y ys) -> ...
04:39:07 <vixey> there doesn't seem to be any guarantee
04:39:21 <quicksilver> rog_: but yes, I think in some cases they can avoid nesting.
04:39:30 <quicksilver> case-of-tuple is a good idiom to note, though.
04:39:36 <humasect> vixey: i think that is one of the optimization issues. i am not sure
04:39:51 <Philippa_> vixey: you wanted slides?
04:39:58 <vixey> yes!
04:40:07 <humasect> from the wiki: Exhaustiveness/Redundancy. It is hard to check for completeness of pattern matching; and likewise for overlap. But guards already make both of these hard; and GADTs make completness tricky too. So matters are not much worse than before.
04:40:29 <Philippa_> right, gimme a mo to upload. They're not wonderful though
04:41:25 <rog_> quicksilver: i like that idiom, but i think there's a fair amount of cleverness in the usual pattern matcher that can take out common factors and allow different cases to be specified in a straightforward way. but i'm probably wrong here.
04:41:35 <humasect> vixey: in your case, foo would have to return the same result unless something unsafe is going on , anyway=)
04:42:11 <vixey> humasect: not so
04:43:09 <humasect> should i believe it, or know it?
04:43:50 <quicksilver> foo could be overloaded
04:43:56 <quicksilver> and P1 / P2 could have different types.
04:44:15 <quicksilver> f (read -> (i :: Int)) = ...
04:44:20 <quicksilver> f (read -> (d :: Double)) = ...
04:44:31 <vixey> consider a simple example
04:44:33 <vixey> foo (classify -> Odd) = ...
04:44:35 <vixey> foo (classify -> Even) = ...
04:44:49 <vixey> what happens if you pass in 6 and what happens if you pass in 71 ?
04:45:08 <humasect> is it possible to use TH or similar, to say .. (mapM (\n -> import n) [Data.List,Control.Monad]   .. ?
04:45:29 <dolio> quicksilver: That doesn't work without readMaybe.
04:45:50 <humasect> ah right, vixey ; i am still new. i didn't realise and remember that view patterns are passed in something. my apologies, it is very later here =)
04:47:04 <quicksilver> dolio: yes, it wasn't a complete example but the idea is clear enough.
04:47:20 <quicksilver> humasect: what you said is morally true.
04:47:28 <quicksilver> for fixed parameter, foo will always return the same.
04:47:34 <quicksilver> (unless there is a class context)
04:47:48 <quicksilver> and so the question of if it will be recomputed is relevant.
04:47:52 <humasect> i wish i could say i am fully awake=)
04:48:04 <humasect> yes
04:50:22 <rog_> quicksilver: AFAIK, F# active patterns do avoid recomputation when possible, so i'd imagine that haskell would do the same thing (or could in principal, even if they haven't bothered for now)
04:50:41 <rog_> s/principal/principle/ argh
04:50:55 <telexicon> ok so is it possible to call haskell code from a C elf plugin module?
04:50:59 <dolio> I belive that was on the to-do list.
04:51:22 <rog_> telexicon: system() :-)
04:51:36 <telexicon> rog_, lol, totally lame
04:51:56 <rog_> telexicon: well, you did say "possible"...
04:52:17 <telexicon> well of course thats possible
04:52:24 <quicksilver> telexicon: if you're prepared to dlopen() the stuff yourself
04:52:28 <quicksilver> telexicon: and handle private mapping etc
04:52:32 <quicksilver> then it's possible.
04:52:38 <telexicon> quicksilver, private mapping?
04:52:41 <quicksilver> you would need to understand this stuff to do so.
04:52:46 * telexicon sighs
04:52:53 <quicksilver> mapping the symbol tables so it doesn't overlap with other symbol
04:52:54 <telexicon> perhaps i phrased the question wrong
04:52:55 <humasect> cannot one just link to HS runtime libs?
04:52:57 <quicksilver> (like another copy of GMP)
04:53:24 <humasect> if you can link the C elf module with HS runtime, you are gold.
04:53:30 <telexicon> i need a haskell so module to provide certain C ABI compatible functions
04:53:54 <telexicon> well, not really need.. it'd just be interesting and useful
04:53:59 <humasect> sure you can do this
04:54:19 <humasect> link in the C code that provides the ABI, that calls into haskell.
04:54:33 <telexicon> ok
04:54:37 <rog_> what are GHC's VM requirements. does it assume it owns the whole of memory space, or does it work within blocks obtained via malloc?
04:54:56 <telexicon> humasect, where can i find info on calling into haskell from C?
04:55:27 <Zao> rog_: The latter, it seems like.
04:55:27 <humasect> http://www.haskell.org/haskellwiki/GHC/Using_the_FFI#Calling_Haskell_from_C
04:55:30 <lambdabot> Title: GHC/Using the FFI - HaskellWiki, http://tinyurl.com/6xh6cr
04:55:50 <rog_> Zao: that's sensible
04:56:14 <telexicon> humasect, yes i read that and it makes 0 sense
04:56:16 <humasect> ah, scroll up a bit, telexicon
04:56:21 <telexicon> because it still looks like calling C from haskell
04:56:44 <telexicon> that title needs to be fixed or something
04:56:48 <humasect> hm, ocaml can be used both ways, C as main and ocaml as main; i am sure haskell can as well.
04:57:16 <rog_> ew, what's "reinterpret_cast"? looks like a C++ism to me
04:57:21 <Zao> rog_: It is.
04:57:23 <telexicon> rog_, it is
04:57:33 <Zao> rog_: Bitwise reinterpretation as another type.
04:57:44 <Zao> The C++ casts are more granular and specific, and thus superior.
04:57:55 <humasect> telexicon: there is a way to start the runtime.
04:58:37 <quicksilver> sloppy to call it 'C code' though.
04:58:45 <telexicon> actually, this callbacks into haskell might work
04:58:59 * rog_ is tempted to stray way off-topic, but is keeping his lips sealed
04:59:17 <telexicon> hm actually no
04:59:37 <telexicon> no these FFI docs are pretty much a mess
04:59:44 <humasect> telexicon: start runtime with some of the available Hs*.h files, call haskell from there. the C file would just provide the ABI and start the runtime
04:59:47 <telexicon> its a bunch of C++ for ms visual studio windows nonsese
05:00:02 <telexicon> really, how many people are running haskell on windows relative to other platforms
05:00:03 <humasect> yes it is just a starting point. it is not your copy and paste do it for you kind of page perhaps
05:00:17 <telexicon> no, and i dont want a copy paste kind of page
05:00:22 <humasect> telexicon: regardless, windows users generally need more help with that kind of stuff.
05:00:25 <Zao> telexicon: I doubt that it targets VS, as you need to have a gcc DLL/EXE to call into Haskell.
05:00:27 <rog_> Zao: so reinterpret_cast is just like good old C cast?
05:00:27 <telexicon> but just a page that i can identify with and fits in with my environment
05:00:38 <Zao> rog_: Yes, depending on the types.
05:00:54 <telexicon> Zao, it mentions visual studio explicitly
05:00:59 <humasect> well, it is your own personal journey, the task you are interested to undertake; anyways right ?
05:01:04 <rog_> Zao: ok. presumably the types have to be the same size
05:01:26 <telexicon> humasect, lol, just lol
05:01:42 <telexicon> "windows users generally need more help with that kind of stuff"
05:01:48 <telexicon> windows users dont even know what haskell is
05:02:15 <Zao> telexicon: Ah, that example.
05:02:36 <telexicon> if calling haskell from C was relatively easy, somebody would've given me a reasonable answer already, or there would be an example on the wiki
05:02:43 <Zao> telexicon: The DLL is still built with GCC though, only the header is used by VS to get the signatures.
05:02:45 <telexicon> since it isnt, its either not implemented, or requires hackery magic
05:03:01 <telexicon> Zao, yeah, well i suppose C ABIs are C ABIs because its C instead of C++?
05:03:19 <Zao> telexicon: foreign export ccall "omg" omg :: Whatever
05:03:21 <telexicon> so you can mix compilers in that case
05:03:46 <Zao> telexicon: You still have the problem that gcc objs and libs and vs objs and libs are incompatible.
05:03:47 <telexicon> Zao, interesting, ill see where that leads me, thanks
05:03:56 <telexicon> Zao, they are?
05:04:03 <Zao> telexicon: Typed from memory, so consult Ye Olde Docs.
05:04:14 <telexicon> i mean at some point, mingw has to produce windows understandable exectuables
05:04:21 <telexicon> with PE symbol tables and whatnot
05:04:22 <Zao> telexicon: Which is why the DLL is made with gcc and dynamically loaded into a VS program.
05:04:34 <Zao> telexicon: The .o files and .obj files are compiler specific.
05:04:44 <Zao> As are .a files and .lib files.
05:04:48 <telexicon> ah ok
05:04:55 <telexicon> so use DLLs?
05:05:09 <Zao> DLLs and EXEs are regular PE images, so they are sane.
05:05:30 <telexicon> hmm, i better not get to far into that
05:05:39 <telexicon> ive somewhat lost touch with windows
05:05:55 <Zao> I do agree that the docs are a bit suboptimal, I was in your shoes a few months ago, trying to interop properly.
05:06:55 <telexicon> Zao, i guess ill figure it out when i have more time
05:07:04 <telexicon> or perhaps you can comment on whether these ideas are reasonable or not
05:07:13 <telexicon> im looking at using haskell for some security oriented software
05:07:21 <telexicon> would that be a sane reasonable thing to do?
05:07:32 <telexicon> using haskell's strong type safety and other checks to prevent common vulnerabilities
05:08:01 <Zao> telexicon: Possibly. The downside to interop is that you have to marshal a lot, and can introduce issues there.
05:08:14 <telexicon> hm
05:08:38 <Zao> But as most applications in Haskell are done in a thin IO shell around a functional core, wrapping the outer shell with a C or C++ application is not that much different.
05:09:10 <humasect> =)
05:09:10 <telexicon> yeah, its just 4 functions it has to provide, after that haskell can do all the processing it needs to do
05:09:28 <Zao> Then it's most probably a quite sane idea.
05:09:40 <telexicon> its a plugin interface
05:09:57 <telexicon> specifically, PAM
05:10:07 <telexicon> just as a test for now i suppose
05:12:00 <telexicon> hmm, so how would you deal with something that mangles pointers?
05:12:26 <telexicon> i guess i should just read this spec, and see if it answers my question first
05:12:57 <humasect> Foreign.Ptr
05:13:31 <telexicon> this is pretty cool
05:13:46 <telexicon> ok, so beyond sane, thoughts on the security parts?
05:13:54 <telexicon> would haskell really help for making more secure code?
05:14:09 <telexicon> i mean, i suppose buffer overflows would become a lot less of an issue
05:16:07 <earthy> absent, really
05:16:25 <earthy> but, the main issue is sanitising input
05:16:28 <Zao> telexicon: As opposed to the usual C byte shoveling, likely.
05:16:44 <earthy> (which, in essence, is the root cause of buffer overflows anyway; unsanitised input)
05:17:00 <telexicon> yeah
05:18:42 <telexicon> well, i still dont understand why so much new code gets written using the standard c string manipulation functions
05:18:49 <telexicon> i mean, its just asking for trouble
05:18:58 <Philippa_> "because that's what I know"
05:19:07 <Philippa_> "because we'd only screw up our own implementations"
05:19:07 <Eridius> because it's the lowest common denominator
05:19:15 <Philippa_> etc etc
05:19:17 <Philippa_> exactly
05:19:43 <telexicon> so if you really cant spare a little extra code
05:19:53 <telexicon> you could add on just a lightweight wrapper to do it
05:20:12 <telexicon> at least reduce the classes of bugs you end up with
05:20:17 <telexicon> the low hanging fruit
05:21:29 <Zao> telexicon: I solve that by using C++.
05:21:39 <Zao> It's not an optimal solution, but it sure beats C :)
05:21:40 <telexicon> Zao, yes, c++ can work as well
05:21:53 <telexicon> although i have a tough time convincing some people of that
05:22:00 <telexicon> at least, what simply using std::string can save you from
05:23:20 <maltem> I've been told that most C++ people never really use reusable structures for things like linked lists
05:23:40 <telexicon> maltem, what do you mean?
05:23:52 <Zao> maltem: Those are coding in "C with ++"
05:24:04 <maltem> telexicon: I don't mean anything, that's what someone told me :)
05:24:16 <telexicon> Zao, that drives me nuts
05:24:23 <maltem> Zao, that sounds likely
05:24:25 <Zao> I wouldn't consider someone who doesn't have a reasonably firm grip on the C++ standard library a C++ programmer.
05:24:25 <telexicon> people referring to it as C with classes
05:24:41 <telexicon> the c++ standard template library is very useful
05:24:55 <telexicon> it has most of the data structures and algorithms you would want
05:25:10 <telexicon> although, its still missing a proper hash table (but thats getting fixed next revision)
05:25:12 <Zao> telexicon: Whatever it hasn't, Boost probably has.
05:25:19 <telexicon> Zao, yup
05:25:36 <telexicon> Zao, ive been looking over c++0x as well, they are making some nice additions to really clean certain things up
05:25:47 <telexicon> rvalue references are really great for specifying proper move semantics
05:26:06 <Zao> Indeed.
05:26:15 <telexicon> and so auto_ptr gets replaced with unique_ptr which will work better
05:26:21 <telexicon> and then the whole concepts thing
05:26:32 <telexicon> kind of reminded me of type classes but perhaps i have it a bit off
05:27:27 <maltem> I'll have to learn C++ next year... will be interesting how I'll digest it
05:27:41 <slarba> hmm. can ghc optimize this to single list traversal: (minimum l, maximum l)
05:27:57 <maltem> slarba: afaik it cannot
05:28:21 <slarba> that's quite common piece of code, a place for a rewrite rule?
05:28:21 <slarba> :)
05:28:22 <Philippa_> however, if you're willing to write them as folds it's pretty easy to do it yourself
05:28:29 <slarba> Philippa_: yes
05:28:36 <Philippa_> and in that particular case you may as well just have a function that gets you both
05:28:37 <slarba> can folds be fused?
05:28:44 <Philippa_> sort-of
05:28:57 <Philippa_> you want a different technique here, so it's not fusion in the usual sense
05:29:00 <maltem> @src maximum
05:29:00 <lambdabot> maximum [] = undefined
05:29:00 <lambdabot> maximum xs = foldl1 max xs
05:29:02 <ziman> maybe (fold, fold) could be generically rewritten as fold f (_,_)
05:29:08 <Philippa_> ziman: it can
05:29:26 <Philippa_> give or take being sufficiently picky about the syntactic details :-)
05:29:40 <telexicon> maltem, what would you be looking for in it?
05:29:59 <dolio> The rules for combining things like (maximum l, minimum l) while preserving semantics are somewhat non-trivial.
05:30:05 <telexicon> i have to admit, it has some subtleties and complexities that are a bit annoying to deal with
05:30:25 <telexicon> and it seems people tend to use those things in their code first, instead of just making it simple
05:31:00 <maltem> telexicon: the thing is, I've grown very accustomed to Haskell, it will be quite of a paradigm shift
05:31:03 <RayNbow> hmm... I've been wondering... is there something like a left unfold?
05:31:09 <Philippa_> a first attempt: foldl (\n (nmin, nmax) -> (min n nmin, max n nmax)) (undefined, undefined)
05:31:20 <Philippa_> > foldl (\n (nmin, nmax) -> (min n nmin, max n nmax)) (undefined, undefined) [1,2,3]
05:31:21 <lambdabot>       Occurs check: cannot construct the infinite type: a = (a, a)
05:31:21 <lambdabot>        Exp...
05:31:24 <Philippa_> d'oh :-)
05:31:25 * RayNbow can't imagine a left unfold (if it would exist)
05:31:42 <telexicon> maltem, yeah i suppose it would
05:31:51 <telexicon> maltem, i need to get more into haskell, it'd be good for me i guess
05:31:57 <telexicon> im still a bit lost with it
05:31:59 <Philippa_> > foldl (\(nmin, nmax) n -> (min n nmin, max n nmax)) (undefined, undefined) [1,2,3]
05:32:00 <lambdabot>   (* Exception: Prelude.undefined
05:32:16 <Philippa_> ...okay, do the special casing for undefined, my bad :-)
05:32:37 <Philippa_> > foldl1 (\(nmin, nmax) n -> (min n nmin, max n nmax)) [1,2,3]
05:32:39 <lambdabot>       Occurs check: cannot construct the infinite type: t = (t, t1)
05:32:39 <lambdabot>        Ex...
05:33:15 <maltem> telexicon: I experience learning Haskell as fun anyways
05:33:22 <Philippa_> meh. Yeah, hence the tediousness part. I forget what the names for the maximum and minimum numbers of a given type are
05:33:42 <Philippa_> but use the foldl that crashed only with undefined swapped with those and it'll work aside from the empty lists case
05:34:00 <Philippa_> (and there, it's up to you if you want to retain the special cases from maximum/minimum anyway)
05:34:09 <Philippa_> slarba: all that make sense?
05:34:22 <Philippa_> dolio: have you got the actual rules written out somewhere, OOI?
05:34:27 <telexicon> has there been working targetting llvm for haskell?
05:34:29 <Philippa_> not necessarily as GHC RULES
05:34:38 <maltem> > foldl (\(nmin,nmax) n -> (min n nmin, max n nmax)) (1,1) [2,3]
05:34:40 <lambdabot>   (1,3)
05:34:57 <telexicon> Philippa_, ghs can continue doing its high level optimizations
05:35:02 <telexicon> Philippa_, er, ghc
05:35:06 <dolio> Philippa_: No, but you have to look at things like strictness of the reducing function carefully.
05:35:10 <Philippa_> telexicon: wasn't responding to you there :-)
05:35:11 <telexicon> but instead of outputting C it could output llvm bytecode
05:35:16 <telexicon> Philippa_, oh sorry lol
05:35:36 <dolio> And make sure your function on pairs preserves the appropriate strictness.
05:35:40 <Philippa_> telexicon: and no, the work's on GHC's own back end these days. I don't think LLVM's quite appealed enough to folks
05:35:54 <Philippa_> dolio: fair enough
05:35:59 <telexicon> interesting
05:36:10 <dolio> And you can't really talk about that in RULES, as far as I know.
05:36:24 <Philippa_> *nod* - certainly I was talking about doing it by hand still
05:36:28 <dolio> Hence it not being available. :)
05:36:43 <Philippa_> well, I said not necessarily as GHC RULES for a reason :-)
05:36:58 <dolio> Yeah, I know. But in reference to the original question...
05:37:46 <Philippa_> telexicon: GHC's spitting out its own asm. There are some LLVM bindings lying around somewhere if someone really wanted to have a play, mind
05:38:08 <telexicon> i think your messages are getting chopped off
05:38:10 <Philippa_> I suspect it's just not quite as good a fit as you might expect on account of Haskell being a rather unusual language
05:38:27 <Philippa_> telexicon: not on my end
05:38:38 <telexicon> yea i suppose different classes of optimizations wouldnt apply as well
05:39:02 <telexicon> Philippa_, did your response before end with "play, mind" ?
05:39:10 <Philippa_> yes
05:39:40 <telexicon> oh ok
05:39:51 <Philippa_> my english may be a little too idiom-laden :-)
05:40:23 <ivanm> mmorrow: ping
05:40:24 <telexicon> which english?
05:40:30 <telexicon> :p
05:40:32 <dolio> We speak 'Mericun in here.
05:40:55 <telexicon> interesting
05:41:04 <ivanm> dolio: never heard of that dialect before...
05:41:15 <dolio> :)
05:41:34 <marcot_> Good morning.
05:41:49 <marcot_> I'm still having problems with using getChar inside a forkIO.
05:41:59 <BeelsebobWork_> what problems are those?
05:42:24 <marcot_> http://hpaste.org/10808
05:42:32 <marcot_> In GHCi this code runs fine.
05:42:58 <Philippa_> dolio: you might :-)
05:43:07 <marcot_> After compilation with ghc --make, no character is read, and the process is never interrupt.
05:43:09 <BeelsebobWork_> and what happens in non-ghci?
05:43:11 <Philippa_> telexicon: English. As in, English English.
05:43:25 <telexicon> you cant do that when you mention idioms
05:43:27 <dolio> You can just git out! :)
05:43:39 <telexicon> because there are australian ones and canadian ones and american ones and british ones
05:43:40 <maltem> marcot_: Maybe disable buffering
05:43:46 <BeelsebobWork_> yeh
05:43:51 <BeelsebobWork_> that's almost certainly it
05:43:58 <marcot_> maltem: how could I do that?
05:44:03 <BeelsebobWork_> hSetBuffering
05:44:04 <ivanm> Philippa_: you mean the Queen's English?
05:44:07 <maltem> marcot_: hSetBuffering stdin NoBuffering -- or similar
05:44:13 <Philippa_> telexicon: and people in each country absorb some other countries' idioms these days via the 'net
05:44:18 <Philippa_> ivanm: we do not :-)
05:44:26 <ivanm> heh
05:44:39 <ivanm> Philippa_: and via american mass-media propaganda! :p
05:45:01 <marcot_> I've added hSetBuffering stdin NoBuffering and I get the same..
05:45:12 <BeelsebobWork_> marcot_: do the same to stdout
05:45:13 <marcot_> Works in GHCi but now in GHC.
05:45:52 <Philippa_> ivanm: Not just the merkins, mind. I mean, most planets have a north
05:46:58 <marcot_> Same here..
05:47:07 <telexicon> Philippa_, im just not familiar with that particular one
05:47:14 <marcot_> I don't understand very well why the behaviour is so different in GHC and GHCi.
05:47:17 <Philippa_> I actually pick up more idioms via usenet
05:47:21 <ivanm> has anyone here ever used pandoc as a _library_, not just as an app?
05:47:28 <BeelsebobWork_> marcot_: because ghci sets up buffering itself
05:47:36 <BeelsebobWork_> and because threading behavior is subtly different between the two
05:47:46 <Philippa_> telexicon: "$foo, mind" is roughly equivalent to "bear in mind $foo", if that helps?
05:47:48 <BeelsebobWork_> anything you run in ghci doesn't get run on the main bound thread
05:47:56 <marcot_> hum...
05:48:25 <marcot_> But do you have any other suggestions?
05:48:30 <marcot_> I get the same here still.
05:48:32 <telexicon> Philippa_, interesting
05:50:44 <marcot_> And something I don't understand very well is when does getChar waits for an Enter and when it does not.
05:51:49 <maltem> marcot_: getChar doesn't wait for an Enter, but buffering may prevent it to see the character at the right time
05:52:01 <maltem> marcot_: still it's strange it doesn't still work for you
05:53:28 <marcot_> main = hSetBuffering stdin NoBuffering >> hSetBuffering stdout NoBuffering >> getChar >>= putChar
05:53:44 <marcot_> With this in GHCi it waits for an enter, and in GHC it doesn't.
05:54:29 <marcot_> Actually the hSetBuffering stdout here doesn't make much difference.
05:54:42 <marcot_> I think that problem is related to forkIO and maybe to runCommand
05:54:51 <dibblego> is there a type-class structure that can help me with (a -> t) -> (b -> t) -> (a, b) -> (t, t) ?
05:54:55 <maltem> marcot_: Here it won't wait for an enter in either case
05:55:04 <dibblego> s/(a, b)/a -> b
05:55:22 <maltem> marcot_: even though, now that I tested, your original program isn't without programs here either
05:56:25 <marcot_> maltem: my program isn't without programs?
05:56:40 <maltem> er, without problems
05:57:01 <maltem> (I don't get "wait" printed")
05:57:16 <marcot_> maltem: you mean this small test I posted in IRC?  Here in GHCi it waits for an enter.  What GHC version are you using?
05:57:51 <marcot_> maltem: so nothing happens when you run the hpaste program?
05:59:21 <mightybyte> Is there a way to get ghci to give you a step-by-step call expansion for the execution of a function?
05:59:34 <ivanm> mightybyte: the ghci debugger might do what you want
05:59:57 <luqui> :t (***)
05:59:58 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
06:00:03 <luqui> dibblego, ^
06:00:03 <BeelsebobWork_> mightybyte: not in ghci, but if you're writing Haskell 98, hat-anim, or hood will do that
06:00:11 <luqui> dibblego, where a = (->)
06:00:14 <dibblego> luqui, cheers, I knew it was somewhere around Arrow :)
06:00:16 <mightybyte> ivanm: Ok, I'll look into that.
06:00:22 <maltem> marcot_: The hpaste program will just run wget. If I press a key, it will be printed, but it looks as if wget gets the keypress rather than the Haskell program
06:00:29 <maltem> marcot_: As for the "small test", it's the same for me with ghc 6.8.3 or a 6.8.10 prerelease
06:00:31 <maltem> marcot_: hm... are you on Windows, incidentally?
06:00:41 <mightybyte> BeelsebobWork_: Ok, thanks.
06:00:49 <marcot_> maltem: no, I'm in debian, with GHC 6.8.2.
06:01:04 <marcot_> maltem: maybe this is a difference between GHC 6.8.2 and 6.8.3.
06:01:20 * luqui thinks *** and &&& are pretty neat little functions
06:03:20 <dibblego> in (Arrow a) => a b c, is there a fmap on b or c?
06:04:35 <dibblego> @hoogle (Arrow a) => a b c -> (c -> d) -> a b d
06:04:35 <lambdabot> Control.Arrow (>>^) :: Arrow a => a b c -> (c -> d) -> a b d
06:04:35 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
06:04:35 <lambdabot> Data.Map map :: (a -> b) -> Map k a -> Map k b
06:05:26 <luqui> most instances of arrow will have fmap on c.
06:05:40 <dibblego> figured
06:05:49 <luqui> there would be a "cofmap" on b, but our type system is not cool enough to do that cleanly
06:06:00 <dibblego> yes of course
06:07:27 <lilac> luqui: all instances of arrow admit an fmap on c
06:07:37 <luqui> lilac, of course
06:07:44 <luqui> it'
06:07:50 <luqui> s just (^<<) above :-)
06:08:08 <lilac> heh, natch
06:08:17 <dibblego> @type \f g -> (f *** g) ^<< id
06:08:19 <lambdabot> forall b c b' c'. (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
06:08:19 <rog_> luquie: what's cofmap?
06:08:21 <dibblego> @type \f g -> (f *** g)
06:08:22 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
06:08:33 <dibblego> cofmap :: f a -> (b -> a) -> f b
06:08:46 <lilac> rog_: cofmap :: (Cofunctor c) => (a -> b) -> c b -> c a
06:09:18 <luqui> presumably from category-extras, where all the costuff is
06:09:35 <dibblego> x ^<< id == x ?
06:09:39 <lilac> unfortunately, you can't define an instance for an arrow, since the type parameter is in the wrong place
06:10:07 <lilac> dibblego: i believe the arrow laws guarantee that, yes.
06:10:37 <luqui> arrow laws are more or less "they do the right thing on pure functions" and "composition is associative"
06:11:14 <rog_> how can that work without taking the inverse of the (a -> b) function?
06:11:29 <lilac> rog_: a -> b is a cofunctor over a
06:11:33 <luqui> rog_, try to define it for this type:  newtype Foo a = Foo (a -> Int)
06:11:49 <besiria> is there a solution of the dining philosophers problem in haskell? i would like to take a look at it
06:12:05 <dibblego> @type \f g -> f *** g ^<< uncurry mappend -- expecting (Arrow a) => a b c -> a b' c' -> a (b, b') c ?
06:12:06 <lambdabot> forall b c b' c'. (Monoid b', Monoid b) => (b -> c) -> (b' -> c') -> ((b, b'), (b, b')) -> (c, c')
06:12:07 <lilac> 'Functor a' has an a, 'Cofunctor a' wants an a
06:12:20 <rog_> oh i see. like you can only define fmap on outputs of functions, not inputs, right? so cofunctor is the other way around?
06:12:43 <dibblego> no
06:12:47 <maltem`_> marcot_: hm might be
06:12:54 <dibblego> s/c'/c
06:13:00 <luqui> rog_, more or less, yeah
06:13:18 <rog_> um. was that a contradiction there?
06:13:45 <luqui> hmm?
06:14:05 <rog_> maybe dibblego wasn't responding to me. no matter.
06:14:28 <dibblego> no I wasn't, I am confused by the type signature - it doesn't meet my expectation
06:15:30 <telexicon> excellent i got it working
06:15:37 <telexicon> the ghc docs are much more helpful than the wiki
06:16:15 <luqui> @type \f g -> (f *** g) ^<< uncurry mappend
06:16:15 <lambdabot> forall b c b' c'. (Monoid b', Monoid b) => (b -> c) -> (b' -> c') -> ((b, b'), (b, b')) -> (c, c')
06:16:24 <luqui> @type \f g -> f *** (g ^<< uncurry mappend)
06:16:25 <lambdabot> forall b c c' a. (Monoid a) => (b -> c) -> (a -> c') -> (b, (a, a)) -> (c, c')
06:16:52 <dibblego> I'm looking for (Monoid c, Arrow a) => a b c -> a b' c -> a (b, b') c
06:16:56 <lilac> @type \a b -> (a *** b) >>^ uncurry mappend
06:16:57 <lambdabot> forall (a :: * -> * -> *) b b' c'. (Monoid c', Arrow a) => a b c' -> a b' c' -> a (b, b') c'
06:17:01 <luqui> okay that was the random perturbation method.  now let me try thinking
06:17:06 <luqui> or not and let lilac do it :-)
06:17:14 <lilac> :D
06:17:26 <dibblego> oh duh @ me thanks
06:17:49 <dibblego> @type \f g -> uncurry mappend ^<< f *** g
06:17:50 <lambdabot> forall (a :: * -> * -> *) b b' c'. (Arrow a, Monoid c') => a b c' -> a b' c' -> a (b, b') c'
06:18:16 <telexicon> ew, it static linked my app with the haskell runtime
06:18:17 <telexicon> :(
06:20:57 <lilac> besiria: yes, there're various implementations. do you know about STM?
06:22:33 <ivanm> telexicon: ummmm.... what's wrong with static linking?
06:22:36 <lilac> besiria: for instance: http://computationalthoughts.blogspot.com/2008/03/some-examples-of-software-transactional.html
06:22:38 <lambdabot> Title: Computational Thoughts: Some examples of Software Transactional Memory in Haskel ..., http://tinyurl.com/3zkmbf
06:22:56 <telexicon> ivanm, its not the modern *nix way?
06:23:21 <ivanm> ghc is cross-platform though
06:23:35 <ivanm> and realistically, you need to statically link your app to the runtime...
06:23:47 <telexicon> because ...
06:23:58 <ivanm> unless you want to have haskell code compile down to bytecode and have a bytecode interpreter >_>
06:24:12 <telexicon> what was wrong with a shared library?
06:24:52 <besiria> lilac: thx
06:24:52 <telexicon> you know, that fancy new dynamic linking thingy
06:24:57 <lilac> a fair chunk of the haskell runtime functions'll be inlined into your code anyway
06:25:26 <telexicon> lilac, so 240K for a hello world is reasonable?
06:25:27 <ivanm> telexicon: the haskell runtime can be thought of as a mini interpreter
06:25:47 <telexicon> ivanm, which parts does it actually mangle?
06:25:59 <BeelsebobWork_> telexicon: given that I have a 2TB hard disk, not a 200K hard disk, no, I don't really mind hello world being 200k
06:25:59 <telexicon> ivanm, id guess garbage collection and.. perhaps some of the concurrency features?
06:26:18 <ivanm> telexicon: AFAIK, that's the main stuff it does
06:26:21 <BeelsebobWork_> (if I get tangiable benefit from it, like significantly faster programs)
06:26:24 <telexicon> BeelsebobWork_, given that nobody cares about hard drives, i dont see your point
06:26:33 <ivanm> telexicon: I care about my hard drive!
06:26:42 <ivanm> without it, my computer would have trouble running!
06:26:47 <BeelsebobWork_> telexicon: my point is that a 240k hello world is totally insignificant in todays terms
06:26:50 <telexicon> ivanm, awesome
06:26:51 <maltem> It _is_ a pity that dynamics linking plays so bad with ghc optimizations
06:26:59 <telexicon> BeelsebobWork_, in terms of memory
06:27:12 <dolio> There's supposed to be some dynamic linking in 6.10.
06:27:15 <telexicon> maltem, it'd be trendy and too scary for common use
06:27:20 <ivanm> dolio: oh?
06:27:23 <telexicon> but if you had a really powerful linker in your os
06:27:28 <BeelsebobWork_> telexicon: again, I have crap tons of RAM, I don't care particularly -- especially given that lots of small programs will use no more ram at all
06:27:31 <telexicon> you could do some magical link-time optimizations
06:27:32 <dolio> Yeah. I don't know the specifics.
06:27:52 <telexicon> BeelsebobWork_, sure you do, but they dont
06:27:55 <ivanm> I'm quite happy with static linking for haskell... if its using non-haskell libs, I can see dynamic linking being good/usefull...
06:28:00 <BeelsebobWork_> telexicon: who doesn't?
06:28:06 <telexicon> BeelsebobWork_, lots of people
06:28:10 <BeelsebobWork_> really?
06:28:12 <telexicon> and btw, it really adds up
06:28:15 <ivanm> and for getting around license restrictions... ;-)
06:28:17 <BeelsebobWork_> I don't know anyone with less than a gig of ram these days
06:28:29 <telexicon> BeelsebobWork_, then all your friends are rich people?
06:28:31 <maltem> dolio: oo, I'll have to check this out
06:28:48 <BeelsebobWork_> telexicon: uh, a gig of ram costs $12
06:28:57 <telexicon> there are plenty of people working with 512MB, 256MB .. 128MB and even less
06:29:13 <telexicon> BeelsebobWork_, and those memory module types dont fit in these machines
06:29:18 <telexicon> and what about embedded systems?
06:29:21 <ivanm> telexicon: and how many of those code/install new software?
06:29:23 <EvilTerran> and how many of those are likely to be using haskell programs?
06:29:34 <BeelsebobWork_> what about embedded systems?  Why are you using Haskell, not Hume to program an embedded system/
06:29:36 <telexicon> ah, so you dont want widespread use?
06:29:38 <ivanm> telexicon: I don't think anyone is using haskell for embedded?
06:29:44 <telexicon> interesting
06:29:48 <dolio> Oh, my bad. Apparently it's in the "Beyond 6.10" section.
06:29:57 <telexicon> ok, so i should cross out writing PAM modules in haskell, of my try this list?
06:29:58 <lilac> telexicon: no, we don't want widespread use :D
06:30:00 <maltem> Imagine any program on your desktop was written in Haskell and linked statically... I fear that would sum up
06:30:00 <ivanm> telexicon: SPJ said recently that Haskell is more interesting as a primarily _research_ language to test new ideas, etc.
06:30:02 <dolio> It's described as "about a week's work" though.
06:30:03 <ivanm> something like that
06:30:09 <dolio> http://hackage.haskell.org/trac/ghc/wiki/Status/Releases
06:30:10 <lambdabot> Title: Status/Releases - GHC - Trac
06:30:11 <BeelsebobWork_> telexicon: we do want widespread use -- and the bottom line is that most people buy $300 crap laptops, that have 2GB of ram as default
06:30:23 <telexicon> BeelsebobWork_, it still adds up?
06:30:33 <telexicon> well, lets just hope that the 245K is constant
06:30:40 <telexicon> and that it just seems big because the app is small
06:30:43 <quicksilver> maltem: on OSX, or win32, most applications do not share the libraries that they use outside of the system core set.
06:30:49 <BeelsebobWork_> telexicon: not really, I've never had a significant memory use problem with a haskell program
06:30:58 <telexicon> BeelsebobWork_, cool
06:31:03 <quicksilver> maltem: although those platforms support shared libs, each application bundles its own copy.
06:31:05 <lilac> BeelsebobWork_: how many haskell programs do you run at once?
06:31:14 <ivanm> BeelsebobWork_: I have... but then again, it was a large numerics app ;-)
06:31:14 <BeelsebobWork_> (other than a really obvious sive like leak, in which case, that's my bug)
06:31:16 <quicksilver> maltem: so, in practice people don't care.
06:31:30 <telexicon> really its just
06:31:33 <quicksilver> maltem: only Linux has sensible distributions which are able to actually share the shared libraries :)
06:31:34 <maltem> quicksilver: A fair point... but it's also a point why I don't prefer those platforms
06:31:42 <telexicon> i was looking at writing a pam module
06:31:47 <telexicon> so, i figured memory use was important
06:31:51 <maltem> quicksilver: heh exactly :)
06:32:10 <telexicon> since pam is somewhat of a core component, and linux runs on lots of things besides crappy $300 laptops with 2GB of ram
06:32:12 <ivanm> telexicon: why would it be?
06:32:32 * ivanm doesn't know _that_ much about PAM
06:32:41 <ivanm> but I can't see it's RAM usage being that big
06:32:41 <lilac> if half the processes on this machine were written in haskell (or used libraries written in haskell or whatever), i'd be using 80MB more ram. that's nearly 1% of my RAM! :D
06:32:54 <ivanm> lilac: how did you calculate that figure?
06:33:00 <telexicon> ivanm, well ill put it this way
06:33:05 <lilac> ivanm: 250KB per process
06:33:09 <telexicon> ivanm, do you ever use those password thingies?
06:33:12 <ivanm> lilac: and you have 8GB of RAM?
06:33:16 <ivanm> telexicon: which ones? :p
06:33:17 <lilac> ivanm: 10GB :)
06:33:24 <ivanm> lilac: :o
06:33:26 <telexicon> or, any type of service where you do that crazy 'authentication' stuff
06:33:32 * ivanm has 4GB, but can't use all of it
06:33:40 <ivanm> telexicon: yes, but not all of them use PAM AFAIK
06:33:42 <telexicon> login, su, sudo, ssh, cron, kerberos, ldap, samba, nfs, etc etc
06:33:47 <telexicon> that all uses PAM
06:34:04 <ivanm> well, I don't think claws-mail GPG dialog uses PAM :p
06:34:14 <Zao> And most importantly, xlock :P
06:34:17 <ivanm> but yes, it uses PAM... so?
06:34:18 <telexicon> no, that talks to your GPG agent
06:34:27 <ivanm> Zao: I thought xlock was discourage for being insecure?
06:34:31 <ivanm> telexicon: no, it uses its own
06:34:40 <telexicon> ok, it uses its own
06:35:07 <Zao> ivanm: No idea. I've locked myself out by having a xlock compiled with too few auth methods :)
06:35:10 <telexicon> so i just had a few concerns
06:35:19 <ivanm> Zao: heh
06:35:29 <telexicon> PAM stuff tends to run as root, so theres the whole code auditing thing
06:35:35 <ivanm> telexicon: by PAM module, you mean something that uses PAM?
06:35:37 <telexicon> i mean, suid root
06:35:42 <ivanm> or a Haskell PAM library?
06:35:59 <telexicon> no, PAM module is an authentication mechanism that pam can make use of
06:36:04 <ivanm> ahhh, OK
06:36:15 <ivanm> I don't see why RAM usage would necessarily be a _huge_ problem though
06:36:21 <ivanm> sure, you'd want low RAM usage
06:36:31 <telexicon> yeah, it may not be a huge issue
06:36:39 <telexicon> in fact it isnt
06:36:39 <ivanm> but 200K vs say 50K... *shrug*
06:36:45 <ivanm> 200K is still pretty small
06:36:59 <telexicon> im also looking at code security
06:37:11 <telexicon> what kind of checking does haskell do?
06:37:19 <telexicon> i mean, is it going to prove a lot of this stuff?
06:37:20 <BeelsebobWork_> telexicon: type checking
06:37:29 <BeelsebobWork_> it proves that all the types match
06:37:32 <ivanm> quickchecking :p
06:37:40 <telexicon> great
06:37:40 <Elly> quickchecking doesn't prove anything :P
06:37:48 <BeelsebobWork_> how precice you make your types is up to you
06:37:57 <ivanm> Elly: well, it helps reduce the likelihood of bugs...
06:37:59 <BeelsebobWork_> Elly: sure it does -- it proves when you have a bug
06:38:04 <BeelsebobWork_> it just doesn't prove when you don't
06:38:06 <Elly> BeelsebobWork_: touche
06:38:13 <telexicon> ok, my point being
06:38:29 <telexicon> wanting to avoid a lot of the security issues that cause problems these days
06:38:38 <ivanm> BeelsebobWork_: no, it can't _prove_ you had a bug, because you mightn't have understood what your code is meant to do! :p
06:38:46 <telexicon> so, i was looking at using haskell because of its safety
06:38:47 <quicksilver> telexicon: the type system can prove security properties.
06:38:49 <ivanm> and you might have a bug in your qc test ;-)
06:38:54 <quicksilver> but only if you use it that way.
06:39:04 <telexicon> quicksilver, interesting
06:39:05 <flux> ivanm, well, that's a bug, right?-)
06:39:07 <quicksilver> ivanm: there are only two kinds of bugs.
06:39:11 <BeelsebobWork_> ivanm: if you define a bug as a difference between the properties you express about your code, and the actions of the code, it certainly does
06:39:15 <ddarius> ivanm: A bug in your test is still a bug and a specification error isn't something that can be formally proven or disproven.
06:39:15 <BeelsebobWork_> and that's a fair enough definition
06:39:21 <BeelsebobWork_> it's either a bug in your properties, or in your code
06:39:22 <quicksilver> ivanm: test failures and missing tests :)
06:39:25 <ivanm> heh
06:39:59 <ivanm> well, how do you know it isn't _quickcheck_ that has the bug? :P
06:40:08 <BeelsebobWork_> haha, you still have a bug
06:40:08 <ddarius> ivanm: Still a bug.
06:40:10 <BeelsebobWork_> :P
06:40:24 <ddarius> The RTS or the OS can also have the bug.
06:40:29 <ddarius> Or the hardware.
06:40:43 <ivanm> well, BeelsebobWork_ said that quickcheck proves when YOU have a bug (emphasis added)
06:40:48 <maltem> or the laws of physics
06:40:54 <ivanm> ddarius: solar radiation! :p
06:41:02 <BeelsebobWork_> ivanm: sure -- and you do have a bug -- the bug is that you haven't fixed quickcheck yet
06:41:03 <flux> or your wetware might have a bug, when it says "test passed" but you interpret it otherwise..
06:41:07 <quicksilver> I don't need quickcheck to tell me that *I* have bugs.
06:41:09 <quicksilver> I know that :)
06:41:10 <ddarius> ivanm: That's actually an arguable case.  In that case, it is user error.
06:41:27 <ddarius> "Why test?  You already know you have bugs."
06:41:28 <ivanm> BeelsebobWork_: heh
06:41:30 <BeelsebobWork_> quicksilver: omnomnomn tastey bugs?
06:41:44 <ivanm> quicksilver: it just helps you find out where some of them are?
06:41:44 <quicksilver> nom.
06:42:21 <maltem> dolio: pity, dynamic libraries have been deferred to 6.12
06:42:22 <BeelsebobWork_> heh, interesting perspective
06:42:26 <BeelsebobWork_> quickcheck is a debugger
06:42:33 <dolio> Such is life.
06:42:52 <dolio> 6.12 should be pretty sweet, then. :)
06:43:13 <dolio> Shared libraries, lots of code gen work...
06:43:17 <quicksilver> dynamic libraries just aren't an interesting enough problem to enough people.
06:43:24 <maltem> dolio: definitely.
06:43:29 <dolio> Maybe type families will be fully completed.
06:43:31 <quicksilver> I'd much rather JaffaCake and SPJ spent the time on codegen.
06:43:39 <quicksilver> and new type system features.
06:43:47 <maltem> more data parallel stuff, parallel profiling, ...
06:43:54 <quicksilver> yes, those things as well.
06:43:59 <BeelsebobWork_> quicksilver: from an industry perspective, they're a fairly large one for us, in terms of linking against LGPL code
06:44:12 <quicksilver> BeelsebobWork_: that makes sense.
06:44:15 <BeelsebobWork_> (first hurdle, can we release anything, given that we have to link against gmp)
06:44:33 <quicksilver> at least on OSX and linux, gmp is linked dynamically.
06:44:47 <BeelsebobWork_> depends on what copy of ghc you got on OS X, sometimes it's static
06:44:55 * quicksilver nods.
06:45:03 <BeelsebobWork_> and on windows you have to jump through a lot of hoops to get it dynamic
06:45:06 <quicksilver> linking gmp dynamically is a solved problem anyhow.
06:45:20 <quicksilver> it's quite different to linking the haskell rts / haskell libs dynamically.
06:45:23 <quicksilver> that's the hard one.
06:45:29 <BeelsebobWork_> yep
06:45:37 <ivanm> does anyone know of an app/library that uses pandoc _as a library_?
06:46:24 <ivanm> I'm having trouble deciphering their haddock docs :s
06:46:58 <Eridius> @pl (\pe -> (uid pe, pe))
06:46:59 <lambdabot> (,) =<< uid
06:46:59 <rog_> in GHC, if i've got a stack overflow, is there a quick way of determining which functions have caused it?
06:47:05 <Eridius> whoa
06:48:09 <EvilTerran> (uid &&& id) would work too
06:48:18 <BeelsebobWork_> rog: profile it, and look at what got called 10000000 times
06:48:50 <Eridius> @hoogle &&&
06:48:50 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
06:49:00 <maltem> BeelsebobWork_: provided it will run far enough to write profiling output...
06:49:20 <quicksilver> rog_: did you compile with optimisation?
06:49:37 <rog_> quicksilver: i was just using ghci, so i didn't actually compile per se
06:49:56 <rog_> BeelsebobWork_: would that not give me the properly tail-recursive fns too?
06:49:57 <insitu> hello, still trying to develop a basic web app. I want to use hdbc-sqlite module but it does not install properly using cabal
06:50:04 <quicksilver> the strictness analyser will defeat some some stack overflows
06:50:14 <quicksilver> it can sometimes stop a huge thunk being built up.
06:50:20 <quicksilver> but that only happens on optimisation.
06:50:24 <quicksilver> (never in ghci)
06:50:29 <rog_> quicksilver: ok. that'd be nice.
06:50:32 <rog_> oh
06:50:40 <jpcooper> hello
06:50:54 <insitu> I got a compile error about undeclared items (eg. SQLITE_NULL). I tried degrading HDBC from 1.1.5 to 1.1.4 but to no avail
06:51:10 <jpcooper> does anyone know how to evaluate a list of items in a parallel fashion?
06:51:26 <quicksilver> jpcooper: Control.Parallel.Strategies
06:51:43 <jpcooper> quicksilver, thanks. I was wondering if there were some other things as well. I'll look more into that
06:51:50 <quicksilver> there are other things.
06:51:55 <quicksilver> that is *probably* the simplest.
06:51:59 <quicksilver> ;)
06:52:03 <quicksilver> at least, it keeps IO out of it.
06:59:24 <rog_> hmm. i'm getting a "failed to load interface" error when compiling. it worked fine from ghci. do i have to separate out the interfaces into separate files?
06:59:24 <EvilTerran> ?src ErrorT
06:59:24 <lambdabot> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
07:00:40 <rog_> doing -v says it's searching for ".hi" and ".hi-boot" files, of which i'm ignorant.
07:00:47 <quicksilver> rog_: I think that might mean stuff was in the wrong directory.
07:01:01 <rog_> quicksilver: it's all in the cwd
07:01:05 <quicksilver> rog_: you need to put module Foo.Bar.Baz in Foo/Bar/Baz.hs
07:01:18 <quicksilver> rog_: paste the command line + the error?
07:01:22 <rog_> i have no prefixes
07:02:44 <rog_> http://hpaste.org/10809#a0
07:03:42 <quicksilver> rog_: ghc --make
07:03:48 <quicksilver> ghc --make main.hs
07:05:00 <rog_> quicksilver: ok. actually, i'd just fixed it, by compiling the files in reverse dependency order.
07:05:08 <quicksilver> you can do that.
07:05:13 <quicksilver> or you can just use ghc --make
07:05:19 <quicksilver> and save yourself the hassle :P
07:05:30 <rog_> quicksilver: i'll do that :-)
07:05:42 <igel> hi!
07:06:08 <igel> is it possible (with standard functions) to compare two lists with a user-defined compare for elements?
07:06:18 <igel> i have a customCompare :: a -> a -A
07:06:24 <igel> i have a customCompare :: a -> a -> Ordering
07:06:32 <igel> and i have two lists of type [a]
07:06:47 <quicksilver> igel: only by playing newtype games.
07:06:47 <igel> and i want to compare the lists using customCompare for the elements
07:07:11 <igel> i came up with
07:07:24 <igel> mconcat $ zipWith customCompare list1 list2
07:07:33 <rog_> quicksilver: ok, done. unfortunately there's still a stack overflow... i'll look at heap profiling, i guess.
07:07:34 <igel> but it throws away the information which list was longer
07:07:59 <igel> e.g. it would say that [1,2,3] and [1,2] are equal
07:08:04 <wjt> @ty on
07:08:05 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
07:08:12 <EvilTerran> igel, do you want (xs < xs ++ ys) for ys /= [] ?
07:08:20 <wjt> @ty sortBy
07:08:21 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
07:08:25 <wjt> oh, we're not sorting
07:08:28 <quicksilver> EvilTerran: he wants exactly the behaviour of the stnadrd Ord intance for [a]
07:08:36 <quicksilver> except with a different compare for a.
07:08:38 <EvilTerran> > [1,2,3] `compare` [1,2]
07:08:39 <lambdabot>   GT
07:08:41 <EvilTerran> righto
07:08:42 <rog_> quicksilver: PS. thanks.
07:08:44 <quicksilver> the easiest thing is to newtype the as.
07:09:31 <rog_> given newtype X = X Foo, is map X list_of_foo a no-op at runtime?
07:10:17 <quicksilver> rog_: no.
07:10:23 <quicksilver> it generates a new list.
07:10:26 <quicksilver> just like 'map id'
07:10:34 <quicksilver> it might be an amortised no-op, though.
07:10:38 <quicksilver> if it fuses with something else.
07:11:30 <rog_> is there any way to distinguish  (map id x) from x?
07:11:41 <quicksilver> no.
07:11:46 <EvilTerran> {-# RULES "map X" map X = Unsafe.Coerce.unsafeCoerce #-}
07:11:48 <EvilTerran> >:)
07:11:48 <quicksilver> but operationally they are different.
07:12:00 <ivanm> the extra run-time it takes? :p
07:12:03 <maltem> What must I do to convince ghc 6.10-pre to actually parallelize Data Parallel code?
07:13:04 <quicksilver> in particular, "map f . map X" should fuse
07:13:10 <rog_> so presumably it could just use the same list, as all (X foo) does is change its type, which is just a compile-time op, right?
07:13:18 <quicksilver> so that "map X" is O(0) in that case.
07:13:27 <quicksilver> rog_: yes it could, but it doesn't know that.
07:13:57 <EvilTerran> (map f . map X) would fuse to map (f . X), and then the X would be nonexistant at runtime
07:14:02 <rog_> quicksilver: ok. that's useful to know. i'd kind of assumed that most newtype-related ops were free.
07:14:08 <EvilTerran> with nothing to fuse with, though, map X will be map id at runtime
07:14:26 <quicksilver> EvilTerran: that's what I said isn't it? :)
07:14:28 <EvilTerran> unless you do something dodgey with RULES (as above)
07:14:29 <rog_> why isn't map id a no-op then?
07:14:41 <quicksilver> why should it be?
07:14:45 <EvilTerran> quicksilver, well, yeah, except i said what the fused version was. just elaborating.
07:14:49 <quicksilver> map is just an ordinary function.
07:14:49 <rog_> 'cos it's cheaper?
07:14:57 <quicksilver> how is the compiler to know?
07:15:03 <quicksilver> i.e. this would be a special-case for map.
07:15:03 <EvilTerran> it seems to me there could be a {-# RULES "map id" map id = id #-}
07:15:17 <rog_> that was kinda what i was thinking
07:15:22 <EvilTerran> but it's not gonna come up very often as-is
07:15:32 <EvilTerran> and i don't think that RULES would catch newtype wrapping/unwrapping
07:15:37 <rog_> ah
07:15:44 <quicksilver> no, because RULES run pre-type-erasure.
07:16:28 <Philonous1> I guess it would be rather hard to prove that some function is extensionally equivalent to id. On the other hand when would you use map id explicitly?
07:16:48 <Philonous1> To decide by a compiler, I meant
07:16:54 <quicksilver> yeah, I mean it's obviously possible to do this special case.
07:17:04 <quicksilver> All I'm trying to say is that it is a special case.
07:17:12 <quicksilver> and presumably it's not obvious how useful it is ;)
07:17:27 <quicksilver> particularly since in most applications you can imagine there is something to fuse to.
07:17:46 <razor0> i was told to ask this question here:
07:17:47 <razor0> I am looking for a tutorial, article, and/or book on functional programming design. Not on any specific language, but i am looking on a document that will explain functional programming thought to someone who has not done it
07:18:02 * Baughn wonders if it's common to get a warm glow from writing a tight function
07:18:17 * rog_ knows that it is
07:18:25 <quicksilver> razor0: try "Why Functional Programming Matters"
07:18:59 <Baughn> ..oh, wow
07:19:02 * rog_ certainly does, rather.
07:19:13 <Baughn> I had 17.3GB of GHC source in various states of disassembly lying around. -_-
07:19:25 <razor0> okay, thanks
07:19:41 <Baughn> Hm. Make that 3.2GB of GHC sources and 14.1GB of _darcs directories
07:20:04 <Baughn> Was ghc going to switch to git, or will it be using darcs2 now that the problems are apparently fixed?
07:20:28 <geezusfreeek> wait what problems in darcs2 were fixed?
07:20:46 <quicksilver> as far as I know the switch is still planned.
07:20:59 <Baughn> No, the problems in darcs1, I meant. Slowness, hugeness, etc.
07:21:01 <quicksilver> as far as I know, the key problem was performance particularly branching and merging
07:21:01 <geezusfreeek> i have heard no news of canceling the plans
07:21:07 <igel> quicksilver, EvilTerran: wouldn't it be reasonable to add "compareBy :: (a -> a -> Ordering) -> [a] -> [a] -> Ordering" to base?
07:21:14 <quicksilver> and as far as I know those problems have not been fixed.
07:21:17 <Baughn> Right. Well, I suppose git makes sense.
07:21:20 <EvilTerran> igel, well, compareListBy, i guess
07:21:21 <Baughn> It /is/ very fast
07:21:21 <quicksilver> igel: not entirely unreasonable.
07:21:24 <igel> or maybe to Data.Foldable
07:21:38 <quicksilver> igel: will you add that to every single container type with a built in Ord instance?
07:21:42 <geezusfreeek> yeah that is what confused me. i didn't hear anything about the performance problems being fixed (yet)
07:21:51 <EvilTerran> local instances! :P
07:21:52 <quicksilver> igel: (a,a) ? (a,b,c) ? providing three different compares?
07:22:10 <quicksilver> Maybe a ?
07:22:11 <Baughn> geezusfreeek: I don't know if those specific ones were fixed. I do know that darcs, especially 2.1, is much much faster than v1
07:22:33 <geezusfreeek> yes, 2 is waay faster than 1, but it still has problems with massive repos like ghc
07:22:36 <quicksilver> Baughn: as far as I understand it darcs 2.1 is quite a bit faster but still too slow for a huge repo like ghc
07:22:41 <geezusfreeek> for most projects it is acceptable
07:22:51 <EvilTerran> (let instance Ord [a] where { ... } in ...) kinda thing. shame about the semantics being impossible in general. =/
07:22:55 <igel> quicksilver: i haven't tried, yet, but isn't it possible to formulate it with Foldable instances instread of lists?
07:22:55 <quicksilver> not many repos have the volume of code and the number of revisions that ghc has.
07:23:05 <Baughn> quicksilver: There we go, then. I'd be quite happy with /fast/ ghc checkouts
07:23:06 <quicksilver> igel: yes.
07:23:15 <Baughn> How about the core libraries?
07:23:31 <quicksilver> I believe they are staying in darcs.
07:23:38 <igel> ah of course, Data.Foldable even contains toList :)
07:23:45 <igel> hmm...
07:23:47 <Baughn> Oh yes, and I've noticed that darcs is quite a lot faster when used from behind squid, for some reason
07:23:59 <Baughn> Even when the caching shouldn't come into play
07:24:09 <igel> but Foldable instances don't guarantee anything about the order of elements, do they?
07:24:25 <quicksilver> yes, they do.
07:24:38 <quicksilver> Foldable means "supporting toList"
07:24:42 <quicksilver> so it implies a canonical order.
07:25:23 <igel> the documentation doesn't say that
07:25:39 <quicksilver> no.
07:25:42 <quicksilver> I did, though.
07:25:48 <Baughn> If you can fold it, you can also make a list from it
07:25:59 <Baughn> Eg. fold (:) []
07:26:00 <quicksilver> the documentation probably thinks it is boring and concrete to think of Foldable as being 'merely toList'
07:26:10 <quicksilver> but, that doesn't change the truth of it.
07:26:18 <quicksilver> Foldable is dual to Monoid
07:26:24 <quicksilver> and lists are the free Monoid
07:26:39 <quicksilver> so every foldable operation factors through list.
07:26:41 <geezusfreeek> what exactly does
07:26:42 <quicksilver> theorems for free!
07:26:47 <geezusfreeek> oops, sorry, lemme retry that
07:27:12 <geezusfreeek> what exactly does "free" mean here? i see it used this way a lot
07:27:12 <igel> so when implementing Foldable i have to make sure that (toList x) == (toList y) <=> x == y?
07:27:26 <EvilTerran> no...
07:27:48 <quicksilver> igel: for some definition of (==)
07:28:06 <quicksilver> that's what is observable through your Foldable instance.
07:28:17 <igel> well let me give an example, this will be easier
07:28:17 <quicksilver> so that's all that something which treats your type as Foldable can see.
07:28:25 <quicksilver> however, you may have more structure behind the scenes
07:28:27 <quicksilver> (e.g. Tree)
07:28:27 <igel> i implemented a heap
07:28:33 <igel> which is a tree strucutre
07:28:34 <EvilTerran> given data Tree a = Tree a :+: Tree a | Leaf a, toList (Leaf 1 :+: (Leaf 2 :+: Leaf 3)) == toList ((Leaf 1 :+: Leaf 2) :+: Leaf 3)
07:28:37 <EvilTerran> could make sense
07:28:38 <quicksilver> the point is merely that that structure is not visible through Foldable.
07:28:59 <quicksilver> so any operation which is polymorphic over all Foldables, is only aware of the 'toList' observation
07:29:01 <igel> and there are multiple "valid" trees representing the same set of data in a heap
07:29:06 <EvilTerran> even though the trees are different, the elements could be in the same order
07:29:10 <quicksilver> right.
07:29:25 <geezusfreeek> igel, consider implementing Foldable for (,) a... (a, c) /= (b, c) but toList (a, c) == toList (b, c)
07:29:46 <quicksilver> igel: if your multiple different orders give rise to different toLists
07:29:47 <igel> ie two heaps may contain the same elements, but they may not be traversed in the same order (using fold)
07:29:56 <quicksilver> igel: then that is, in a sense, a broken instance of Foldable.
07:30:02 <EvilTerran> igel, if (==) on your heap type didn't distinguish between different internal structures, it'd make sense to have (toList x) == (toList y) <=> x == y
07:30:10 <quicksilver> you could specify that people should only use 'fold' with commutative monoids.
07:30:31 <EvilTerran> the natural definition of toList for a heap would ensure that, anyway
07:30:35 <quicksilver> igel: basically by implementing Foldable in that way you are exposing implementation detail which is probably intended to be abstract.
07:30:49 <igel> yes
07:30:53 <quicksilver> EvilTerran: igel is concerned about the dual problem, actually.
07:31:05 <igel> but i was not aware of the fact that foldable guarantees the order of elements!
07:31:06 <quicksilver> EvilTerran: he is concerned that two heaps which *are* in fact (==), will have different toLists.
07:31:23 <igel> quicksilver: exactly
07:31:27 <quicksilver> igel: well to switch terminology on you, it doesn't so much guarantee it, as it exposes it.
07:31:34 <geezusfreeek> you could define it to sort the lists on the way out or something
07:31:47 <quicksilver> igel: if you expose that, you have probably broken your (==)
07:31:51 <quicksilver> FSOV broken
07:31:56 <geezusfreeek> it would at least have well defined demantics
07:31:59 <EvilTerran> igel, i'd say (x == y) ==> (toList x == toList y)
07:32:02 <EvilTerran> but not vice-versa
07:32:04 <quicksilver> because you have f such that x == y does not imply f x == f y
07:32:06 <EvilTerran> necessarily
07:32:12 <igel> the thing is, i have toList and toAscList
07:32:16 <EvilTerran> because of what quicksilver is saying
07:32:25 <quicksilver> igel: however, your Foldable instance might be, morally, a 'commutative foldable instance'
07:32:28 <igel> toList is faster, but doesn't guarantee any order of elements
07:32:31 <quicksilver> we don't have a typeclass for that, though.
07:32:39 <EvilTerran> if you had "toList h | empty h = [] | otherwise = x : toList h' where (x,h') = extractMin h"
07:32:43 <quicksilver> igel: that's probably a reasonable compromise operationally.
07:32:54 <quicksilver> igel: but it is, in some sense, an 'unsafe Foldable instance'
07:32:55 <igel> sure, it won't matter for foldl (+)^^
07:33:32 <igel> of course i can use the toAscList to implement Foldable
07:33:58 <igel> i mean it's no problem to fix it, but it's dangerous that the Foldable documentation does not say a word about it
07:34:08 <quicksilver> a foldable for commutative monoids might be interesting.
07:34:18 <quicksilver> but the payoff for makign the class library finer is not clear.
07:34:26 <quicksilver> it is certainly an interesting abstract notion.
07:35:43 <geezusfreeek> even if i never used it, i would feel better knowing it's there :)
07:36:26 <igel> where can i suggest a clear documentation on that issue in Data.Foldable?
07:36:57 <quicksilver> libraries@, I guess.
07:37:09 <quicksilver> conor/ross wrote Foldable.
07:37:12 <quicksilver> They read that list.
07:37:13 <igel> @haskell.org?
07:37:13 <lambdabot> Unknown command, try @list
07:37:31 <igel> @botsnack
07:37:31 <lambdabot> :)
07:37:50 <quicksilver> you probably need to be subscribed to post. I imagine.
07:38:07 <igel> i'll just give it a try
07:41:19 <igel> so, when implementing my heap foldable instance, would it be reasonable to use the (deterministic) toAscList for foldr/foldl and the (unorted toList) for the folds that use a monoid?
07:45:06 <EvilTerran> i wouldn't, seeing as monoids aren't necessarily commutative
07:45:31 <igel> argh yes...
07:45:43 * igel keeps mixing up associative and commutative :D
07:50:46 <quicksilver> igel: you know that you only have to implement one of them?
07:51:21 <igel> id o
07:52:39 <lilac> geezusfreeek: "free" in "free monoid" means the same thing as "free" in "free group" and so on
07:53:06 <geezusfreeek> i will just look it up
07:53:32 <geezusfreeek> but thanks
07:53:55 <bjrn> lilac: Ah, the free-as-in-group kind of free.
07:53:59 <lilac> geezusfreeek: it's precisely defined in category theory, but informally the free X generated by Y is something like the unique smallest X which contains Y and has no additional nontrivial identities
07:54:10 <bjrn> We need a license that covers that :)
07:54:10 <lilac> bjrn: :)
07:54:40 <geezusfreeek> "In mathematics, a group G is called free if there is a subset S of G such that any element of G can be written in one and only one way as a product of finitely many elements of S and their inverses [...]."
07:54:49 <geezusfreeek> makes sense to me
07:55:16 <geezusfreeek> but thanks for clarifying that the "free" in "free monoid" is the same basic concept
07:55:50 <geezusfreeek> bjrn, yes!
07:56:36 <bjrn> It adds a whole new dimension to the license wars. We have GPL vs BSD vs the third fraction that is also free as in group.
07:56:54 <bjrn> faction even
07:57:39 <lilac> the free-as-in-group license: you can combine it with other software, but you can't add additional restrictions or additional functionality
07:58:07 <geezusfreeek> sounds like a variation of LGPL
07:59:23 <razor0> every FLOSS company should have some sort of licensing expert
07:59:50 <razor0> one small word, or even short sentence alters everything :(
08:09:28 <ivanm> dons: that site that Axman6 and I bought RWH... now wants $116 for it! :o
08:10:14 <bjrn> ivanm: That's alot, my book store want 36 USD
08:10:38 <bjrn> On the other hand, they still believe the book is only 300 pages
08:10:43 <bjrn> And I can't preorder it
08:10:44 <ivanm> well, we got it for AUD$55
08:10:52 <ivanm> :o
08:11:11 <chrisdone> how many pages is it actually?
08:11:36 <ivanm> 704 is the number I've got
08:12:28 <TSC> ivanm: Where did you buy it?
08:12:36 <ivanm> fishpond.com.au
08:12:42 <ivanm> but the price has more than doubled :o
08:13:36 <TSC> Indeed it has (:
08:16:09 <bjrn> Alright, here it comes:
08:16:49 <bjrn> Okay, any second now:
08:17:08 <bjrn> @bot
08:17:08 <lambdabot> :)
08:17:17 <bjrn> Gah, I  have to do everything myself.
08:17:24 <ski> ?
08:17:26 <bjrn> Announce! Package mp3decoder-0.0.1 added to the database.
08:17:31 <bjrn> My very first haskell program!
08:18:06 <ski> > repeat '!' ++ "?"
08:18:08 <lambdabot>   "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
08:18:33 <TSC> bjrn: Congratulations!  Is the website http://www.bjrn.se/mp3dec/ supposed to work?
08:18:42 <bjrn> TSC: It is, soon :)
08:20:06 <jeffersonheard> I have a minor annoyance, or at least a minor ugliness that I'd like to make pretty with monadic syntax...  I think this might be a place for fmap?
08:20:32 <jeffersonheard> basically, I have a function f that takes a value which I have stored in an IORef and that function f returns an IO ()
08:21:09 <jeffersonheard> > type readIORef
08:21:09 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 8}
08:21:09 <lambdabot>  ...
08:21:18 <TSC> :t readIORef
08:21:19 <lambdabot> Not in scope: `readIORef'
08:21:23 <jeffersonheard> :t readIORef
08:21:24 <lambdabot> Not in scope: `readIORef'
08:21:25 <jeffersonheard> ah
08:21:26 <jeffersonheard> right
08:21:37 <TSC> readIORef :: IORef a -> IO a
08:21:44 <jeffersonheard> well, its signature is: readIORef :: IORef a -> IO a
08:22:02 <TSC> So you would do "readIORef ref >>= f" ?
08:22:03 <ski> @type Data.IORef.readIORef
08:22:04 <lambdabot> forall a. GHC.IOBase.IORef a -> IO a
08:22:13 <jeffersonheard> then f's sig is f :: a -> IO () -> IO ()
08:22:36 <TSC> What does f do with the second argument?
08:23:28 <jeffersonheard> it's a callback if the function's test on a returns true
08:23:39 <TSC> Ah
08:24:18 <ski> where is the `IORef a' ?
08:24:41 <ski> (is `a' some specific, not specified type ?)
08:24:59 <jeffersonheard> in the scope of the function that calls f, and a is the general program state.
08:25:15 <jeffersonheard> a :: IORef ProgramState
08:25:31 <ski> so what is it you want to do ?
08:25:51 <jeffersonheard> write something that takes half a dozen lines into one line
08:25:52 <bjrn> TSC: Here it is http://blog.bjrn.se/2008/10/lets-build-mp3-decoder.html
08:25:53 <lambdabot> Title: blog.bjrn.se: Let’s build an MP3-decoder!
08:25:55 <ski> what is the minor ugly code whereof you spake ?
08:25:56 <jeffersonheard> if I can't, it's no worries
08:26:20 <ski> hpaste it ?
08:26:29 <jeffersonheard> yeah...  hold on
08:28:36 <dblazakis> bjrn: that looks pretty cool!
08:28:53 <bjrn> dblazakis: Cheers :)
08:29:43 <jeffersonheard> http://hpaste.org/10812
08:30:18 <jeffersonheard> when being an "if" that returns () on false
08:30:30 <jeffersonheard> once again, for cleanup, because there are many many event handlers
08:31:02 <ski> @hoogle m Bool -> m () -> m ()
08:31:03 <lambdabot> Control.Monad unless :: Monad m => Bool -> m () -> m ()
08:31:03 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
08:31:03 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
08:31:04 <Deewiant> jeffersonheard: you want "whenM :: Monad m => m Bool -> m () -> m ()"
08:31:20 <jeffersonheard> k
08:31:20 <Deewiant> which doesn't exist in any standard library but is easy to define
08:31:39 <jeffersonheard> yeah, I can see how to define that
08:31:43 <jeffersonheard> thanks, Deewiant
08:31:46 <rwbarton> readIORef st >>= (toggleButtonGetACtive . tgl_select) >>= flip when do ...
08:32:17 <rwbarton> that's probably a worse option
08:32:21 <Deewiant> jeffersonheard: and if you want to make it maybe a bit more useful, you can make it have type m Bool -> m a -> m a instead
08:33:13 <ski> @let whenM = (=<<) . flip when
08:33:14 <lambdabot>  <local>:1:8:
08:33:14 <lambdabot>      Ambiguous type variable `m' in the constraint:
08:33:14 <lambdabot>        `Mon...
08:33:28 <ski> @type let whenM = (=<<) . flip when in whenM
08:33:28 <lambdabot> forall (m :: * -> *). (Monad m) => m () -> m Bool -> m ()
08:35:23 <Deewiant> baah, @let has the monomorphism restriction
08:36:14 <jeffersonheard> yeah, but assuming that my type is really IO and that's obvious to the type checker, it should compile in context
08:36:44 <jeffersonheard> that is, if I define when and then define whenM in terms of when, then call it in code that uses IO, I can't see that the type checker would fail on that
08:36:48 <Deewiant> well, just giving an explicit type signature will solve the problem
08:36:53 <jeffersonheard> right
08:37:01 <Deewiant> doing that with @let is impossible, of course
08:37:18 <jeffersonheard> sure.  do I need the forall in the type signature, or can I leave that out?
08:37:26 <Deewiant> leave it out
08:37:30 <jeffersonheard> thx
08:37:34 <Deewiant> you need an extension to even make it valid :-)
08:37:41 <jeffersonheard> I know that much :)
08:37:49 <ski> (hm, obviously there should be an outer `flip' in the body of `whenM' ..)
08:37:57 <jeffersonheard> y
08:38:20 <jeffersonheard> flip $ (=<<) . flip when
08:38:27 <Deewiant> or just don't use the point-free style :-P
08:38:47 <jeffersonheard> yeah yeah yeah, but that's no fun
08:38:47 <ski> @let whenM :: Monad m => m Bool -> m () -> m (); whenM mb mu = mb >>= \b -> when b mu
08:38:49 <lambdabot>  Defined.
08:39:53 <Deewiant> ?ty (. (flip when . (>> return ()))) . (>>=)
08:39:56 <lambdabot> forall a (m :: * -> *). (Monad m) => m Bool -> m a -> m ()
08:40:15 <ski> btw, you might be able to remove the boilerplate from the "body lines" in the paste, provided that you will always have that pattern there
08:40:15 <geezusfreeek> @pl whenM mb mu = mb >>= \b -> when b mu
08:40:15 <lambdabot> whenM = (. flip when) . (>>=)
08:40:22 <ski> jeffersonheard : ^
08:40:40 <jeffersonheard> right
08:40:41 <dolio> @ty flip $ (=<<) . flip when
08:40:42 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
08:41:06 <geezusfreeek> @src when
08:41:06 <lambdabot> when p s = if p then s else return ()
08:41:36 <geezusfreeek> @pl whenM mb mu = mb >>= \b -> if b then mu else return ()
08:41:36 <ski>   forM_ [tgl_insert,tgl_path,tgl_marker,tgl_rubberband] $ \tgl_foo ->
08:41:36 <lambdabot> whenM = (. flip (flip . flip if') (return ())) . (>>=)
08:41:37 <ski>     toggleButtonSetActive (tgl_foo state) False
08:41:41 <geezusfreeek> ew
08:41:49 <quicksilver> jeffersonheard: yah, there is a pattern there with the states
08:41:53 <quicksilver> you may be able to abstract
08:42:02 <quicksilver> but I generally don't bother with these things until I can see a bigger picture.
08:42:13 <dblazakis> is there a markdown implementation in haskell?
08:42:39 <quicksilver> there is a pandoc implementation, IIRC
08:42:59 <quicksilver> (and that supports markdown)
08:43:02 <dblazakis> quicksilver: ah, i see that now, thanks
08:43:11 <quicksilver> http://johnmacfarlane.net/pandoc/
08:43:16 <lambdabot> Title: Pandoc
08:43:27 <geezusfreeek> @unpl (. flip (flip . flip if') (return ()))
08:43:28 <lambdabot> (\ j p -> j (\ f -> if' f p (return ())))
08:49:01 <gbacon> ?seen cale
08:49:01 <lambdabot> cale is in #haskell-overflow, #haskell and #ghc. I last heard cale speak 6h 5m 32s ago.
08:49:57 <rwbarton> @hoogle (:)
08:49:58 <lambdabot> Parse error:
08:49:58 <lambdabot>   --count=20 (:)
08:49:58 <lambdabot>               ^
08:50:10 <Deewiant> O_o
08:50:13 <Baughn> Hm. It's right, what they say - Haskell makes a better imperative language than the imperative languages.
08:50:16 * Baughn pats STArray
08:50:16 <rwbarton> @hoogle :
08:50:17 <lambdabot> Parse error:
08:50:17 <lambdabot>   --count=20 :
08:50:17 <lambdabot>              ^
08:50:22 <Deewiant> @hoogle ;
08:50:23 <lambdabot> Parse error:
08:50:23 <lambdabot>   --count=20 ;
08:50:23 <lambdabot>              ^
08:50:26 <Deewiant> @hoogle (+)
08:50:27 <lambdabot> Prelude (+) :: Num a => a -> a -> a
08:50:27 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
08:50:27 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
08:50:30 <Deewiant> @hoogle +
08:50:31 <lambdabot> Prelude (+) :: Num a => a -> a -> a
08:50:31 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
08:50:31 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
08:50:33 <Deewiant> O_o
08:50:40 * Baughn grins
08:50:47 <vixey> @hoogle ; ls
08:50:47 <lambdabot> Parse error:
08:50:47 <lambdabot>   --count=20 "; ls"
08:50:47 <lambdabot>              ^
08:50:57 <Baughn> You wish. :P
08:50:57 <rwbarton> @hoogle "; ls"
08:50:58 <lambdabot> Parse error:
08:50:58 <lambdabot>   --count=20 ""; ls""
08:50:58 <lambdabot>              ^
08:51:03 <vixey> @hoogle $echo hehe
08:51:04 <lambdabot> Parse error:
08:51:04 <lambdabot>   --count=20 "$echo hehe"
08:51:04 <lambdabot>              ^
08:51:09 <Baughn> That's the sanitizer giving up, not anything bad making it through
08:51:29 <quicksilver> Baughn: that's even true of ML.
08:51:37 <quicksilver> Baughn: it's especially true of haskell.
08:51:45 <quicksilver> Baughn: I worked on a joint ML / java project once.
08:51:48 <Baughn> quicksilver: I just never had reason to treat it as one before, but..
08:51:58 <quicksilver> Baughn: it became clear to us that ML was better even at the bits we thought java was better at.
08:52:07 <quicksilver> (..we though java was going to be better at)
08:52:11 <Deewiant> what possessed you to think Java would be better at anything? :-P
08:52:22 <quicksilver> producing a GUI for an applet
08:52:47 <Deewiant> that might be valid, I try to avoid GUIs
08:52:51 <gbacon> ?tell Cale at configure for lambdabot, Cabal complains about dependency mismatches of binary, haskell-src, mtl, network, parsec, regex-compat, and regex-posix
08:52:52 <lambdabot> Consider it noted.
08:58:26 <hackage> Uploaded to hackage: mp3decoder 0.0.1
09:02:01 <jstanley> Has anyone seen ghc errors/warnings of the form:
09:02:01 <jstanley>     Var/Type length mismatch:
09:02:01 <jstanley>     []
09:02:01 <jstanley>     [base:GHC.Base.(){(w) tc 40}] before?
09:03:40 <Deewiant> http://hackage.haskell.org/trac/ghc/ticket/2478 evidently
09:03:44 <lambdabot> Title: #2478 (Assertion failure in type checker) - GHC - Trac
09:03:58 <jstanley> Deewiant: Thanks.
09:05:18 <jstanley> Deewiant: How can I find out if there's a stable release newer than 6.8.3 that has the bug fix included?
09:05:43 <Baughn> jstanley: There are no stable releases newer than 6.8.3
09:05:43 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mp3decoder
09:05:43 <Deewiant> easily. There is no stable release newer than 6.8.3. :-P
09:05:45 <lambdabot> Title: HackageDB: mp3decoder-0.0.1, http://tinyurl.com/54zqnd
09:05:49 <dons> check that out guys, a true haskell mp3decoder.
09:05:54 <Baughn> jstanley: But don't worry, 6.10 will be out soon. :P
09:05:59 <dons> at least, it decodes mp3s to .wav files, slowly.
09:06:01 <jstanley> Baughn: hehe. ok, thanks.
09:06:03 <dons> but they seem to work.
09:06:21 <dons> maybe a chance to through some low level hacking and parallelism into the mix.
09:06:22 <Deewiant> jstanley: if you have a simple example, you might want to post a comment on the bug.
09:06:42 <Deewiant> although hmm, it was fixed 2 months ago.
09:06:56 <Deewiant> bah, whatever. :-P
09:07:09 <jstanley> Deewiant: Yeah, I just want the fix. Guess I'll wait for 6.10.
09:07:34 <quicksilver> jstanley: do you have it triggered by code which should work?
09:07:41 <jstanley> Deewiant: It doesn't prevent compilation and as far as I can tell there are no bugs.
09:07:42 <quicksilver> or by code which is admittedly wrong anyway?
09:07:55 <quicksilver> oh, weird.
09:07:56 <jstanley> quicksilver: Code which (a) should work and (b) which worked in 6.6.1.
09:08:14 <jstanley> quicksilver: it's part of a large code base that was last built with 6.6.1 ;)
09:08:29 <quicksilver> odd.
09:10:23 <honen> hello, short question! how can i make a list of ints ([12,30,11]for example) to one(!) Int (123011)? (i think it's something easy, but I don't see it :()
09:10:59 <Deewiant> > read . concatMap show $ [12,30,11] :: Int
09:11:00 <lambdabot>   123011
09:11:11 <Zao> @src concatMap
09:11:12 <lambdabot> concatMap f = foldr ((++) . f) []
09:11:12 <Eridius> @pl \x -> DL (unDL xs . unDL ys)
09:11:12 <lambdabot> const (DL (unDL xs . unDL ys))
09:11:19 <Eridius> ack
09:11:22 <Eridius> @pl \xs -> DL (unDL xs . unDL ys)
09:11:22 <lambdabot> DL . (. unDL ys) . unDL
09:11:28 <Eridius> damnit
09:11:30 <Eridius> @pl \xs ys -> DL (unDL xs . unDL ys)
09:11:31 <lambdabot> (DL .) . (. unDL) . (.) . unDL
09:11:43 <Eridius> eww
09:12:04 <honen> thanks!
09:12:05 <EvilTerran> curry (DL . uncurry (.) . join (***) unDL)
09:12:19 <Eridius> EvilTerran: that doesn't look any better
09:12:23 <Eridius> :t ***
09:12:24 <lambdabot> parse error on input `***'
09:12:27 <rwbarton> @pl on
09:12:27 <Eridius> :t (***)
09:12:27 <lambdabot> on
09:12:28 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
09:12:31 <EvilTerran> i'd say it's easier to follow than the @pl version, anyway
09:12:35 <EvilTerran> ah, yes, `on` is a good idea
09:12:44 <Eridius> except I have no idea what *** does
09:12:47 <EvilTerran> curry (DL . uncurry ((.) `on` unDL))
09:12:47 <Deewiant> :t join (***)
09:12:49 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
09:12:54 <Eridius> or what `on` does
09:12:57 <rwbarton> :t on
09:12:58 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
09:13:10 <EvilTerran> aka (DL .) . ((.) `on` unDL)
09:13:11 <Eridius> ah
09:13:15 <EvilTerran> ?src on
09:13:15 <lambdabot> (*) `on` f = \x y -> f x * f y
09:13:15 <Deewiant> join (***) f applies f to both components of a tuple
09:13:17 <rwbarton> I think it's just   ... that
09:13:18 <quicksilver> EvilTerran: lifting functions through isomorphisms is a general pattern.
09:13:39 <quicksilver> bit fiddly to abstract because of arity.
09:13:53 <EvilTerran> quicksilver, er, what's this in response to?
09:14:06 <quicksilver> the DL/unDL stuff
09:14:08 <EvilTerran> ah
09:14:16 <quicksilver> DL/unDL is an isomorphism
09:14:28 <quicksilver> you were lifting (.) through it. Or lifting (++) if you like.
09:14:29 <quicksilver> ;)
09:14:54 <quicksilver> Foo (f (unFoo a) (unFoo b))
09:14:55 <EvilTerran> i don't know what DL and unDL are, so i couldn't be sure DL/unDL was an isomorphism
09:14:56 <EvilTerran> but ok
09:15:06 <Eridius> it's a simple data
09:15:10 <Eridius> actually, a newtype
09:15:11 <quicksilver> they're the isomorphism between lists and DLists
09:15:12 <quicksilver> I assume.
09:15:16 <Eridius> yeah
09:15:19 <EvilTerran> DLists?
09:15:28 <quicksilver> lists represented as [a] -> [a]
09:15:31 <Eridius> difference list
09:15:35 <quicksilver> :t ShowS
09:15:36 <lambdabot> Not in scope: data constructor `ShowS'
09:15:36 <EvilTerran> ah, the generalisation of ShowS?
09:15:38 <quicksilver> like that
09:15:39 <quicksilver> yes.
09:15:45 <rwbarton> class Compose a where compose :: a -> a -> a ; instance Compose (->) where compose = (.) ; newtype DL ... deriving Compose
09:16:25 <rwbarton> (Well, it's probably Compose a b c where compose :: .....)
09:17:05 <rwbarton> (er, you know what I mean.  Compose (~>) where compose :: (b ~> c) -> (a ~> b) -> (a ~> c))
09:17:42 <lilac> @type (<<<)
09:17:43 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a c d -> a b c -> a b d
09:18:39 <rwbarton> newtype DL ... deriving Arrow, then, I guess
09:19:16 <rog_> random generates a number from [0, 1). if i'm testing limits and wish to generate the number just below 1, how would i do it? guess at a suitably small fraction and hope it's not too small...?
09:19:55 <EvilTerran> > last . takeWhile (<1) . map (1-) . iterate (/2) $ 1
09:19:56 <lambdabot>   0.9999999999999999
09:20:52 <rog_> that'll do...
09:22:28 <rog_> > length $ takeWhile (<1) . map (1-) . iterate (/2) $ 1
09:22:29 <lambdabot>   54
09:23:38 <rog_> always nice seeing idiomatic haskell examples too, thanks.
09:24:00 <rog_> (i've never used iterate, for example)
09:24:47 <dons> http://www.reddit.com/r/programming/comments/74n0v/implementing_an_mp3_decoder_a_haskell_tutorial/
09:24:50 <lambdabot> Title: Implementing an mp3 decoder: a Haskell tutorial : programming, http://tinyurl.com/4qosta
09:26:39 <yakov2> I'd like to be able to use "show" on my own datatype, is it possible to make that happen?
09:27:05 <quicksilver> sure.
09:27:12 <quicksilver> just add 'deriving Show'
09:27:20 <quicksilver> or, implement it your own way. But that's not recommended.
09:27:23 <yakov2> oh okay, cheers
09:29:01 <yakov2> But if I'd like to redefine how it should print it?
09:29:14 <quicksilver> that shuld not be something you want.
09:29:31 <quicksilver> 'show' is for producing a fixed, parsable, Haskell-source representation.
09:29:46 <quicksilver> the output of 'show' should be valid to copy and paste back into a haskell program.
09:29:57 <quicksilver> if you want some other kind of printing, giving it a different name ;)
09:30:05 <yakov2> oh okay
09:32:50 <newsham> hmm.. haskell-cafe is starting to get job recruiters
09:33:06 <newsham> the end is near
09:33:20 <leimy> holy crap
09:33:21 <leimy> :-)
09:34:08 <leimy> snowballs have a good chance in hell?
09:34:29 <Baughn> Hell was long since abandoned and has frozen solid
09:34:35 <dmwit_> Nah, it just means you'll have to learn Coq if you want to boast about knowing a language nobody uses.
09:34:42 <Baughn> (All the demons are up here. People keep telling me so.)
09:34:47 <Jaak> or agda
09:35:02 <Jaak> or epigram
09:35:20 <Jaak> plenty of options :P
09:35:26 <dmwit_> Basically anything with dependent types. =)
09:35:28 <byorgey> or ATS =)
09:35:51 <dmwit_> eww
09:35:58 <byorgey> hehe
09:36:00 <dmwit_> Have you even seen what that language looks like?
09:36:29 <byorgey> not yet, although I'm going to read a paper about it shortly
09:37:08 <ddarius> newsham: That's been happening for a while.
09:38:46 <newsham> leimy: its already snowing in hell (or mars, perhaps)
09:39:19 <newsham> i cant finda copy of "Real World Agda" anywhere. :\
09:44:15 <jeffersonheard> Alrighty.  Remember that when problem I had earlier?  I just wrote a Control.Monad.IfElse library to handle if/elif, C switch, and anaphoric variants of if and C switch.
09:44:45 <jeffersonheard> and I wondered if people want it on Hackage, and if so, what I should call switch instead of "switch"
09:44:59 <jeffersonheard> since the behavior is to break after the first true test.
09:46:39 <byorgey> why would people *not* want it on hackage? =)
09:47:27 <jeffersonheard> okay, more to the point then, "switch" is a silly name.
09:48:00 <jeffersonheard> and inaccurate, since C switch eagerly executes until someone writes a break;
09:48:10 <jeffersonheard> this is more like a chained if-else
09:48:15 <jeffersonheard> or if-elif
09:48:52 <Baughn> Cl Cond?
09:49:06 <Baughn> *CL's cond?
09:49:24 <jeffersonheard> Ah yes, Baughn.  That's more like it
09:49:33 <jeffersonheard> I'll call it cond and acond
09:49:37 <jeffersonheard> (for anaphoric cond)
09:49:55 <Baughn> Now there's an idea
09:50:03 <Baughn> Why don't you implement LOOP in haskell?
09:50:18 <Baughn> It'd be a monad, I suppose. ^_^;
09:50:36 <jeffersonheard> Heh.  Because everytime I read someone else's LOOP code, my eyes cross?
09:50:55 <jeffersonheard> There's idiomatic, and then there's Chaucer.
09:51:10 <Baughn> It is powerful, though. :P
09:51:39 <Baughn> Some cleaned-up version of it might actually do quite well as a monad (transformer)
09:51:53 <jeffersonheard> true...  or a series of combinators
09:52:20 <Baughn> To implement collect and its kind.. you'd have to reimplement monads. Might as well use their infrastructure.
09:52:22 <jeffersonheard> looping combinators...  there's an idea.  probably be just as unreadable as LOOP in the end
09:53:12 <ski> speaking of foof-loop ?
09:54:11 <ski> jeffersonheard : do you have some examples of these combinators of yours .. or even just type sugnatures ?
09:55:12 <jeffersonheard> Ski:  I'm not reimplementing loop with combinators.  I don't have the time.  We were just speculating on how to do it.
09:55:31 <jeffersonheard> I do have the Control.Monad.IfElse, though.  Cabalizing it now, and I'll upload later
09:56:49 <ski> jeffersonheard : the first question was about *which* `loop' you spake of .. Common Lisp one ?
09:56:56 <jeffersonheard> Yes
09:57:11 <jeffersonheard> see also Baughn's comments
10:03:02 <rwbarton> Unicode IO moved from 6.10 to "Beyond 6.10"?
10:07:09 <Baughn> > scanl f a [b,c,d]
10:07:10 <lambdabot>   [a,f a b,f (f a b) c,f (f (f a b) c) d]
10:07:58 <rog_> i've just written a function that computes all n-way combinations of a given list (e.g. combinations [0, 1] 2 -> [[0, 0], [0, 1], [1, 0], [1, 1]], but i've got difficulty envisaging its space/time complexity, though it does seem to be lazy. is there a much simpler way to do this? http://hpaste.org/10815#a0
10:08:31 <rog_>  is there a much simpler way to do this? http://hpaste.org/10815#a0
10:08:36 <EvilTerran> foldl (++) [] = concat, btw
10:08:43 <EvilTerran> ?src concat
10:08:44 <lambdabot> concat = foldr (++) []
10:08:55 <nominolo_> :t liftM fst
10:08:56 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a, b) -> m a
10:09:26 <rog_> ok. might the fact that it's foldr, not foldl, make a difference?
10:09:46 <nominolo_> > fromMaybe $ liftM head =<< return [1,2,3]
10:09:47 <lambdabot>       Overlapping instances for Show (Maybe [a] -> [a])
10:09:47 <lambdabot>        arising from a...
10:09:57 <EvilTerran> foldr is better in this case, i think
10:10:02 <nominolo_> > fromMaybe $ liftM head (return [1,2,3])
10:10:02 <EvilTerran> not that there's much difference either way
10:10:03 <lambdabot>       Overlapping instances for Show (Maybe (m a) -> m a)
10:10:03 <lambdabot>        arising from...
10:10:13 <nominolo_> :t fromMabye
10:10:14 <lambdabot> Not in scope: `fromMabye'
10:10:18 <nominolo_> :t fromMaybe
10:10:19 <lambdabot> forall a. a -> Maybe a -> a
10:10:25 <nominolo_> > fromMaybe 42 $ liftM head (return [1,2,3])
10:10:26 <lambdabot>   1
10:11:21 <rwbarton> foldr (++) []  is significantly better than  foldl (++) []
10:11:38 <rwbarton> Also, combinations = flip replicateM   :)
10:11:45 <rog_> good. i can still do  (take 4 $ combinations [0, 1] 40) in almost no time, which is the main thing
10:11:48 <rwbarton> > replicateM 2 [0, 1]
10:11:50 <lambdabot>   [[0,0],[0,1],[1,0],[1,1]]
10:12:06 <rog_> ahhh, now *that's* the kind of thing i was looking for!
10:13:21 <Jaak> > replicateM 2 [0..]
10:13:22 <lambdabot>   [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[0,7],[0,8],[0,9],[0,10],[0,11],...
10:14:00 <rwbarton> :k LogicT
10:14:02 <lambdabot> (* -> *) -> * -> *
10:15:13 <dolio> > [0..] `interleave` [1..]
10:15:15 <lambdabot>   /tmp/749657721600700347:67:46: Not in scope: `interleave'
10:15:39 <rog_> @src replicateM
10:15:39 <lambdabot> replicateM n x = sequence (replicate n x)
10:16:09 <ziman> > replicateM 3 [0..]
10:16:13 <rog_> @src replicate
10:16:17 <lambdabot>   [[0,0,0],[0,0,1],[0,0,2],[0,0,3],[0,0,4],[0,0,5],[0,0,6],[0,0,7],[0,0,8],[0...
10:16:22 <lambdabot> replicate n x = take n (repeat x)
10:17:33 <rwbarton> Looks like another disagreement between @type/:k/etc. and mueval...
10:17:43 <rwbarton> @type interleave
10:17:44 <lambdabot> forall (m :: * -> *) a. (MonadLogic m) => m a -> m a -> m a
10:21:19 <rwbarton> , let x = msum (map return [0..]) in observeAll $ x >>- \a -> x >>- \b -> return (a, b)
10:21:23 <lunabot>  luna: Not in scope: `observeAll'
10:21:23 <lunabot>  Not in scope: `>>-'
10:21:23 <lunabot>  Not in scope: `>>-'
10:23:17 <dolio> mmorrow doesn't have logict imported?
10:23:19 <dolio> I'm offended.
10:25:17 <rwbarton> :t sequenceBy
10:25:20 <lambdabot> Not in scope: `sequenceBy'
10:28:35 <rwbarton> Is there a commonly-used name for a "smart constructor" version of :=, as in association lists?
10:30:48 <dons> hmm (,) ?
10:31:28 <rwbarton> Actually this is for the json library :)
10:31:40 <rwbarton> I'm thinking of making a newtype which is basically (,), but with a special showJSONs method
10:31:44 <mmorrow> dolio: /me adds it now ;)
10:31:45 <dons> sure.
10:33:06 <rwbarton> and it seems convenient to have  (=:) :: JSON a => String -> a -> Assoc  where  newtype Assoc = Assoc (String, JSValue)
10:33:55 <rwbarton> I was wondering if anyone had a favorite name for this (=:) (I'd use (:=), if I could)
10:34:03 <Saizan> i've seen ($=) used for that
10:35:05 <rwbarton> I feel like I've seen that too, but I can't remember where.
10:35:36 <Saizan> hopengl or gtk2hs, i think
10:37:56 <rwbarton> Ah, hopengl, thanks.  It's a little different (($=) = writeIORef) but the idea is close enough
10:40:05 <jeffersonheard> hopengl's is $=
10:40:34 <jeffersonheard> gtk2hs uses separate get and set functions for everything, annoyingly
10:41:07 <jeffersonheard> (I realize that this makes it more familiar to GTK programmers, but I'm inundated in it at the moment)
10:41:14 <rwbarton> gtk2hs seems to use := (and existential types) for some things
10:41:25 <dcoutts> jeffersonheard: we provide attributes for quite a few things
10:41:39 <rwbarton> But in my case I don't feel the need to use existential types just to get a prettier operator name :)
10:41:53 <dcoutts> rwbarton: heh heh
10:42:04 <dcoutts> I think it'd be doable without existential types
10:42:13 <dcoutts> and anyway, what's wrong with existential types? :-)
10:42:51 <dcoutts> they're just the dual to other ordinary stuff
10:43:25 <jeffersonheard> dcoutts, that's true. and I'm sure as hell not going to knock your work.  I've been fiddling with ToggleButtons all day, and the toggleButtonGet/SetActive
10:43:31 <dons> btw peoples looking for jobs, note the multi-programmer job offer on haskell-cafe@
10:43:34 <dons> hey jeffersonheard
10:43:39 <jeffersonheard> Hey dons
10:43:43 <dons> i think we didn't get to meet at ICFP, but good to see you around.
10:44:07 <mmorrow> , let x = msum (map return [0..]) in observeAll $ x >>- \a -> x >>- \b -> return (a, b)
10:44:08 <lunabot>  [(0,0),(1,0),(0,1),(2,0),(0,2),(1,1),(0,3),(3,0),(0,4),(1,2),(0,5),(2,1),...
10:44:10 <jeffersonheard> Thanks.  Funny, that.  I kept expecting to see you in one place or another, since you were the chair of DEFUN, but I never did
10:44:23 <jeffersonheard> My tutorial went well, I think.  Curious to know what everyone thought of the tutorials
10:44:29 <rwbarton> dcoutts: possible without existential types?  I want to write  showJSON [ "intField" := 1, "stringField" := "hello" ]
10:44:34 <jeffersonheard> dons ^
10:44:56 <mmorrow> , let x = eval "let x = msum (map return [0..]) in observeAll $ x >>- \a -> x >>- \b -> return (a, b)" in fromDynamic x :: Maybe [(Integer,Integer)]
10:44:56 <dons> jeffersonheard: i have a copy of your visualisation paper right here :)
10:44:59 <lunabot>  luna: out of memory (requested 1048576 bytes)
10:45:11 <dons> but i think we scheduled it wrong, clashing with the haskell symposium :/
10:45:24 <dcoutts> rwbarton: sure, but not using a data constructor like :=
10:45:25 <rwbarton> mmorrow: eval/fromDynamic not lazy enough or something?
10:45:36 <rwbarton> dcoutts: Right, that's why I'll probably use $= or something
10:45:42 <jeffersonheard> dons: excellent.  Will probably be expanding it quite a bit soon.  Also working on formalizing some of the notions to create a higher level toolkit for building visualizations
10:45:46 <dcoutts> rwbarton: aye
10:45:52 <dons> jeffersonheard: yeah, a toolkit is needed!
10:46:06 <dons> jeffersonheard: i want to do visualisation of data/graphs of the hackage codebase, btw.
10:46:11 <dons> so if you have any thoughts on that, i'm keen.
10:46:15 <rwbarton> , let x = eval "[3, 4, undefined]" in fromDynamic x :: Maybe [Integer]
10:46:18 <lunabot>  luna: Prelude.undefined
10:46:26 <mmorrow> , let x = eval "let x = msum (map return [0..]) in observeAll $ x >>- \\a -> x >>- \\b -> return (a, b)" in fromDynamic x :: Maybe [(Integer,Integer)]
10:46:28 <lunabot>  Just [(0,0),(1,0),(0,1),(2,0),(0,2),(1,1),(0,3),(3,0),(0,4),(1,2),(0,5),(...
10:46:35 <dons> a couple of million lines of code, 800 packages, maybe 5-10k dependency edges.
10:46:39 <rwbarton> oh.
10:46:46 <jeffersonheard> dons: can we find some way of generating GML for it?
10:47:00 <rwbarton> , [3, 4, undefined] :: [Integer]
10:47:01 <dons> hmm. probably. we generated dot files last week.
10:47:01 <lunabot>  luna: Prelude.undefined
10:47:01 <mmorrow> rwbarton: it was Posix.Resources killing it. i upped the memory hard limit
10:47:05 <dons> jeffersonheard: do we have a GML lib?
10:47:14 <rwbarton> , "\a"
10:47:15 <lunabot>  "\a"
10:47:24 <rwbarton> grr
10:47:26 <jeffersonheard> not yet, but I'm about to get a big GML dataset, so as soon as I get it there will be one
10:47:27 <dons> good work, rwbarton-bot
10:47:28 <mmorrow> ding!
10:47:29 <jeffersonheard> same with NetCDF
10:47:32 <rwbarton> , head
10:47:34 <lunabot>  luna: No instance for (GHC.Show.Show ([a] -> a))
10:47:34 <lunabot>    arising from a use of `GHC.Show.show' at <interactive>:1:43-54
10:47:34 <lunabot>  Possible fix:
10:47:35 <dons> jeffersonheard: sweet.
10:47:35 <rwbarton> , head "\a"
10:47:36 <lunabot>  '\a'
10:47:44 <jeffersonheard> Haskell's all I use  for vis, so as I run into things I need, I'm making them
10:48:03 <mmorrow> , text "\a"
10:48:04 <lunabot>  
10:48:12 <mmorrow> i filter out raw ctrl chars
10:50:00 <mightybyte> Is it possible to make a where/let clause that is visible to all guards?
10:50:24 <jeffersonheard> dons: if there was someone out there with more skill in functionalizing computational geometry than me, I'd love to see an r-tree data structure library out there, or something similar where I can do two-d bounded interval indexes
10:50:43 <jeffersonheard> then we'd be on our way to creating GIS
10:51:05 <jeffersonheard> Or rather, I would.  Porting gdal atm.
10:51:36 <dons> hmm. functional computation geometry. sigfpe perhaps?
10:51:38 <jeffersonheard> porting.  I should say binding
10:53:23 <jeffersonheard> sigfpe?  All I know that as is the floating point exception.  There's an ACM special-interest group?
10:53:47 <rwbarton> , fromJust . eval . ap (++) show $ "fromJust . eval . ap (++) show $ "
10:53:49 <lunabot>  luna: Couldn't match expected type `Data.Maybe.Maybe a'
10:53:49 <lunabot>         against inferred type `Data.Dynamic.Dynamic'
10:53:54 <mmorrow> , let x = eval "eval" in maybe undefined (\ev -> fromDynamic (ev "[0..]") :: Maybe [Integer]) (fromDynamic x :: Maybe (String -> Dynamic))
10:53:56 <lunabot>  Just [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25...
10:54:03 <rwbarton> , fromJust . fromDynamic . eval . ap (++) show $ "fromJust . fromDynamic . eval . ap (++) show $ "
10:54:06 <lunabot>  luna: Ambiguous type variable `a' in the constraint:
10:54:06 <lunabot>    `Data.Typeable.Typeable a'
10:54:06 <lunabot>      arising from a use of `Data.Dynamic.toDyn'
10:54:12 <mattam> jeffersonheard: http://sigfpe.blogspot.com/
10:54:13 <lambdabot> Title: A Neighborhood of Infinity
10:54:45 <rwbarton> , (`asTypeOf` ()) . fromJust . fromDynamic . eval . ap (++) show $ "(`asTypeOf` ()) . fromJust . fromDynamic . eval . ap (++) show $ "
10:54:50 <lunabot>  Killed.
10:54:59 <jeffersonheard> mattam: shiny...
10:55:15 <mattam> People have built R-Trees for this year's ICFP contest, I don't know if anyone has released that though.
10:56:23 <jeffersonheard> it's no big deal.  for the index size I have now, (about 36000 nodes), north,south,east,and west maps I have suffice
10:56:39 <jeffersonheard> be nice to do something a little more intelligent, though
10:56:45 <rwbarton> , repeat 'a'
10:56:47 <lunabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
10:56:49 <rwbarton> , ('a':) . fromJust . fromDynamic . eval . ap (++) show $ "('a':) . fromJust . fromDynamic . eval . ap (++) show $ "
10:56:53 <lunabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
10:56:56 <jeffersonheard> you made luna scream
10:57:15 <rwbarton> Without recursion! :)
10:57:21 <mmorrow> heh, sweet
10:58:27 <hackage> Uploaded to hackage: AERN-RnToRm-Plot 0.1.0
10:59:11 <mmorrow> dolio: if you didn't see earlier, lunabot has logict now
10:59:19 <dolio> I did see.
10:59:32 <dolio> I wasn't planning on doing anything with it, really.
10:59:36 <mmorrow> haha
10:59:41 <dolio> ] [0..] `interleave` [0..]
10:59:43 <lunabot>  [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15...
10:59:58 <mmorrow> interesting..
11:00:04 * mmorrow looks at the logict docs
11:00:06 <Eridius> :t <$>
11:00:07 <lambdabot> parse error on input `<$>'
11:00:12 <Eridius> :t (<$>)
11:00:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:00:18 <jeffersonheard> dons: is there a programmatic interface to Hackage, or would I just be downloading and cleaning a hell of a lot of data?
11:00:19 <Eridius> ah yeah, fmap
11:00:22 <jeffersonheard> in HTML
11:00:36 <Deewiant> ] concatMap (take 2 . repeat) [0..]
11:00:38 <lunabot>  [0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15...
11:00:48 <dons> jeffersonheard: dcoutts has been implementing a programmatic interface to new hackage.
11:01:00 <dons> but atm we're more interested in ideas for how to visualise the different data
11:01:52 <dcoutts> jeffersonheard: all the data is in the 00-index.tar.gz it's all the .cabal files for which we have a parser etc
11:02:06 <jeffersonheard> well, what I'm asking, though, is what the different data are?  What forms does it take?  Obv, we have a graph, but what data is attached to the edges, what data is attached to the nodes, and what extra data is there that we could use to create "qualities" on the individual nodes/edges and adjust the layout?
11:02:08 <dcoutts> jeffersonheard: all the code to handle it is in cabal-install, but not yet with a nice external api
11:03:14 <mmorrow> , once [0..]
11:03:14 <jeffersonheard> so edges are package dependencies...  nodes are packages.  we can also look at using categories to adjust the layout
11:03:15 <lunabot>  [0]
11:03:26 <mmorrow> , msplit [0..]
11:03:28 <lunabot>  [Just (0,[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,...
11:04:48 <rwbarton> Why doesn't the MonadLogic [] instance show up in haddock?
11:05:01 <dolio> No idea.
11:05:02 <jeffersonheard> dcoutts / dons : how are you calculating "what's new"?  I could heatmap the colors on the individual graph nodes to how often/ how recent a package is updated
11:05:21 <jeffersonheard> and adjust node size based on the number of packages/modules/functions exported by the library.  Some notion of "size"
11:05:23 <dolio> I think I've had similar problems elsewhere, though.
11:06:09 <rwbarton> Yeah, I've noticed instances that seemed to be missing before.
11:06:20 <mmorrow> yeah, me too. where the instance shows up in the docs is sometimes the opposite place i expect it to
11:07:08 <mmorrow> maybe the MonadLogic instance would show up under the data decl doc area for [] ?
11:07:39 <mmorrow> (assuming logict docs were avail when you built the docs for [] blah blah)
11:07:55 <dolio> It may be failing due to a lack of docs for [], yeah.
11:07:55 <rwbarton> (Which obviously they weren't)
11:08:08 <mmorrow> yeah
11:08:12 <dolio> Although I think haddock used to just put an unlinked note in there.
11:08:19 <dolio> So it might be a new problem in 2+.
11:08:25 <mmorrow> hmm
11:08:58 <jeffersonheard> dons: here is an example of visualizing cross-site "dependency" (shared traffic) and external qualities of each site on a hugemongous website: http://vizserv5.renci.unc.edu/projects/jun04_2008/europa/ibiblio/
11:08:59 <lambdabot> Title: Untitled Document
11:09:14 <rwbarton> But you do see MonadLogic m => MonadLogic (StateT s m)... that doesn't seem so different from MonadLogic [].
11:09:38 <jeffersonheard> something like this would be interesting in terms of animation, and the layout could be cleaned up.
11:10:16 <jeffersonheard> and then there's something like this for interactive inspection of dependencies: http://vizserv5.renci.unc.edu/projects/feb27_2008/europa/SaratK/CircleViz_200_overview1.TIF
11:10:17 <lambdabot> http://tinyurl.com/3wtwj6
11:10:26 <dolio> Those do have docs linked, though.
11:10:34 <mmorrow> oh, ha. i actually /do/ have a listing for MonadLogic [] in my docs that just got built
11:10:59 <dolio> What version of haddock are you using?
11:11:01 <jeffersonheard> that's just off the top of my head.  (the former is mine, the latter is a colleague's)
11:11:15 <mmorrow> (the haddock which came with a src dist of 6.10 from two days ago == Haddock version 2.2.2, (c) Simon Marlow 2006)
11:11:49 <dolio> Oh. Huh. Well, either they fixed it between that and the version that's on hackage, or it's something else.
11:13:01 <mmorrow> it's an unlinked "[]" though
11:13:21 <mmorrow> like you said you recalled
11:13:22 <dolio> That's not too surprising. The declaration for [] is kind of weird.
11:13:50 <mmorrow> heh
11:14:04 <mmorrow> , ppDoc $(lift =<< reify ''[])
11:14:06 <lunabot>  luna: Ambiguous occurrence `lift'
11:14:06 <lunabot>  It could refer to either `Language.Haskell.TH.Syntax.lift', imported from...
11:14:06 <lunabot>                        or `Control.Monad.Trans.lift', imported from Contro...
11:14:15 <mmorrow> oh crap
11:14:21 <dolio> Oops.
11:14:37 <dolio> You'll have to hide that in the logict import.
11:15:11 <jeffersonheard> dcoutts : where is the 00-index.tar.gz?
11:15:37 <rwbarton> is there an easy way to get cabal install to put haddock documentation somewhere?
11:15:59 <dcoutts> rwbarton: --enable-documentation or set that in the ~/.cabal/config
11:16:25 <dcoutts> jeffersonheard: it's linked from the hackage intro page, it's the file that cabal-install uses for everything
11:16:32 <jeffersonheard> k
11:17:02 <mmorrow> , ppDoc $(lift =<< reify ''[])
11:17:05 <lunabot>  data [] a_0 = [] | a_0 : ([] a_0)
11:17:46 <jeffersonheard> ah, got it.  This looks quite doable...
11:18:26 <jeffersonheard> no download logs for those, are there?  number of times each package has been downloaded?
11:18:51 <mmorrow> , let normalizeT (ConT n) | n == ''[] = ListT ; normalizeT t = t in (text . pprint . cleanNames' . everywhere (mkT normalizeT)) ( $(lift =<< reify ''[])
11:18:53 <lunabot>  luna: parse error (possibly incorrect indentation)
11:18:57 <mmorrow> , let normalizeT (ConT n) | n == ''[] = ListT ; normalizeT t = t in (text . pprint . cleanNames' . everywhere (mkT normalizeT)) $(lift =<< reify ''[])
11:18:59 <lunabot>  data [] a = [] | a : ([a])
11:19:24 <dolio> So much simpler than @src []
11:19:33 <mmorrow> hehe
11:20:27 <rwbarton> mmorrow: can you make most of that into a function?   , src ''[]
11:20:33 <mmorrow> reify (with the appropriate instances of Lift for all the TH datatypes) is way handy in ghci
11:20:59 <mmorrow> rwbarton: actually, yeah, now that i have `eval'
11:21:39 <mmorrow> hmm, that'd be nice. /me puts that on the todo list
11:22:05 <dons> ?users
11:22:06 <lambdabot> Maximum users seen in #haskell: 515, currently: 497 (96.5%), active: 19 (3.8%)
11:23:42 <rwbarton> dcoutts: great, thanks.
11:24:01 <rwbarton> I have a MonadLogic [] instance in the haddock output, and I seem to have Haddock 0.8 :)
11:25:50 <mmorrow> , let src n = (fromJust . (fromDynamic::Dynamic->Maybe Doc) . eval) ("let normalizeT (ConT n) | n == ''[] = ListT ; normalizeT t = t in (text . pprint . cleanNames' . everywhere (mkT normalizeT)) $(lift =<< reify ''"++nameBase n) in src ''IO
11:25:52 <lunabot>  luna: No instance for (Data.Typeable.Typeable
11:25:52 <lunabot>                     Text.PrettyPrint.HughesPJ.Doc)
11:25:52 <lunabot>    arising from a use of `Data.Dynamic.fromDynamic'
11:25:59 <mmorrow> grr
11:26:45 <Twey> With the sudden arrival of Unicode in GHC, one has to wonder:
11:26:53 <Twey> Why isn't λ a synonym for \?
11:27:05 <Twey> You'd think that would be the *first* addition they'd make.
11:27:09 <Igloo> Because it's a letter
11:27:12 <Eridius> @pl \gen -> (fst $ random gen, fst $ random gen)
11:27:12 <lambdabot> ap ((,) . fst . random) (fst . random)
11:27:17 <Twey> But but but x.x
11:27:28 <Twey> \ is meant to represent λ
11:27:47 <Eridius> yeah but \ isn't a letter, λ is
11:28:00 <Twey> But it's *meant* to be a letter.
11:28:08 <rwbarton> How about Unicode Character 'COMBINING CIRCUMFLEX ACCENT' (U+0302)
11:28:11 <ziman> well, it might be made a keyword
11:28:12 <Twey> It's only not a letter due to limitations.
11:28:13 <Eridius> no, it's meant to be a symbol that represents the concept of a lambda
11:28:28 <Twey> Besides, 'let' is formed of letters.  Nobody complains about that.
11:28:34 <Twey> And 'do'.
11:28:51 <Twey> Magic syntax is predominantly letter-based, it seems.
11:28:55 <Eridius> in that case, you'd have to say λ x rather than λx
11:29:36 <Twey> Aye
11:29:41 <mmorrow> , let src n = (text . fromJust . (fromDynamic::Dynamic->Maybe String) . eval) ("let normalizeT (ConT n) | n == ''[] = ListT ; normalizeT t = t in (pprint . cleanNames' . everywhere (mkT normalizeT)) $(lift =<< reify ''"++nameBase n++")") in vcat . fmap src $ [''IO,''[],''Doc]
11:29:42 <Twey> I'm sure we could live with that
11:29:45 <lunabot>  newtype IO a = IO (State# RealWorld -> (#,#) (State# RealWorld) a)
11:29:45 <lunabot>  data [] a = [] | a : ([a])
11:29:45 <lunabot>  data Doc = Empty
11:30:26 <Saizan> Twey: i suppose you'd not like "l" to be a keyword, now, suppose you were greek :)
11:30:37 <Eridius> so what does lunabot do?
11:30:46 <mmorrow> just evals stuff
11:30:50 <mmorrow> , 42 * 12
11:30:52 <lunabot>  504
11:30:53 <Eridius> how's that different than lambdabot's >
11:31:03 <Saizan> different backend
11:31:08 <mmorrow> it has some different imports, and does template-haskell
11:31:16 <mmorrow> and different backend, yeah
11:31:18 <Eridius> ok, I was just wondering at the practical difference
11:31:33 <mmorrow> , eval "eval 42"
11:31:35 <Twey> Saizan: Yes, and if I spoke !Xóõ or N|u, I would hate most programming languages
11:31:37 <lunabot>  luna: No instance for (GHC.Num.Num GHC.Base.String)
11:31:37 <lunabot>    arising from the literal `42' at <interactive>:1:48-49
11:31:37 <lunabot>  Possible fix:
11:31:45 <mmorrow> , eval "eval \"42\""
11:31:49 <lunabot>  <<Dynamic>>
11:32:26 <mmorrow> , (fromJust . fromDynamic . fromJust . fromDynamic) (eval "eval \"42\"") :: Integer
11:32:29 <lunabot>  42
11:32:34 <Eridius> @pl \gen -> let (a, gen') = random gen; (b, gen'') = random gen' in ((a, b), gen'')
11:32:34 <lambdabot> (line 1, column 13):
11:32:34 <lambdabot> unexpected "("
11:32:34 <lambdabot> expecting "()", natural, identifier or "in"
11:32:45 <Eridius> huh
11:33:00 <Eridius> @pl \gen -> let { (a, gen') = random gen; (b, gen'') = random gen' } in ((a, b), gen'')
11:33:00 <lambdabot> (line 1, column 13):
11:33:00 <lambdabot> unexpected "{"
11:33:00 <lambdabot> expecting "()", natural, identifier or "in"
11:33:07 <Eridius> interesting
11:33:16 <mmorrow> it only does single expressions i believe
11:33:17 <EvilTerran> Eridius, @pl doesn't do let
11:33:19 <Eridius> apparently so
11:33:20 <Twey> On the other hand, I guess it does mean we can define map λ (x:xs) = (λ x) : map λ xs
11:33:26 <rwbarton> @pl \gen -> let ((a, gen'), (b, gen'')) = (random gen, random gen') in ((a, b), gen'')
11:33:27 <lambdabot> (line 1, column 13):
11:33:27 <lambdabot> unexpected "("
11:33:27 <lambdabot> expecting "()", natural, identifier or "in"
11:33:43 <rwbarton> @pl \gen -> let (x, y) = (3, gen) in x + y
11:33:44 <lambdabot> (line 1, column 13):
11:33:44 <lambdabot> unexpected "("
11:33:44 <lambdabot> expecting "()", natural, identifier or "in"
11:33:59 <Saizan> let randomM = State random; in runState (listM2 (,) randomM randomM) gen
11:33:59 <Eridius> @pl \gen -> let a = 3 in a
11:33:59 <lambdabot> const 3
11:34:02 <Eridius> huh
11:34:18 <Eridius> so I guess it does let, just very brain-dead
11:34:49 <rwbarton> I think what it doesn't do is patterns besides simple variables.
11:34:57 <rwbarton> (Because in general it can't)
11:35:42 <Twey> @pl \gen -> let (a, gen) = random gen in (a, gen)
11:35:42 <lambdabot> (line 1, column 13):
11:35:42 <lambdabot> unexpected "("
11:35:42 <lambdabot> expecting "()", natural, identifier or "in"
11:35:48 <Twey> Oh ah.
11:36:12 <Twey> @pl x -> let (a, b) = x in b
11:36:12 <lambdabot> (line 1, column 3):
11:36:13 <lambdabot> unexpected ">" or "-"
11:36:13 <lambdabot> expecting variable, "(", operator or end of input
11:36:20 <Twey> Correct answer: snd :>
11:36:24 <rwbarton> @pl \gen -> let x = random gen in let a = fst x in let gen' = snd x in let y = random gen' in let b = fst y in let gen'' = snd y in ((a, b), gen'')
11:36:27 <lambdabot> ap (flip ((. random) . (`ap` fst) . (. snd) . flip . ((,) .) . (,)) . fix . const . snd) fst . fix . const . random
11:36:37 <Twey> Urrgh
11:37:11 <Twey> General rule of point-free: if it contains more than one flip applied to any one function, it's not worth it
11:37:12 <rwbarton> @unpl fix . const
11:37:13 <lambdabot> (\ d -> fix (\ _ -> d))
11:37:20 <Baughn> Whee. Nothing quite like applying theoretical entropy measures to a block-cipher cracking function in order to detect human text when it shows up. In haskell. Who says it's too slow?
11:37:45 <Twey> Baughn: Gesundheit :-P
11:39:15 <geezusfreeek> @unpl ap (flip ((. random) . (`ap` fst) . (. snd) . flip . ((,) .) . (,)) . fix . const . snd) fst . fix . const . random
11:39:15 <lambdabot> (\ o -> ((\ x c -> ((\ bf i -> ((,)) (((,)) c i) (snd bf)) >>= \ bk -> fst >>= \ bj -> return (bk bj)) (random (fix (\ _ -> snd x)))) >>= \ q -> fst >>= \ p -> return (q p)) (fix (\ _ -> random o)))
11:39:27 <geezusfreeek> beautiful
11:39:42 <moshisushi> that looks like porridge with cut nails in it
11:39:55 <mmorrow> @pl (\ o -> ((\ x c -> ((\ bf i -> ((,)) (((,)) c i) (snd bf)) >>= \ bk -> fst >>= \ bj -> return (bk bj)) (random (fix (\ _ -> snd x)))) >>= \ q -> fst >>= \ p -> return (q p)) (fix (\ _ -> random o)))
11:39:55 <lambdabot> ((fst >>=) . (return .) =<< flip (((fst >>=) . (return .) =<<) . (. snd) . flip . ((,) .) . (,)) . random . fix . const . snd) . fix . const . random
11:42:00 <Eridius> ooh, it's like google translate!
11:42:18 <Eridius> I wonder what expression you can write under, say, 30 chars, that grows the fastest when you pl/unpl it?
11:43:37 <Itkovian> Sometimes I really wish I could parse expressions such as the above in a rapid fashion.
11:43:45 <mmorrow> it'd be interesting to iterate (unpl . pl)
11:43:54 <Deewiant> it converges quite quickly
11:45:39 <dolio> Once you pl once, I'd expect unpling and pling to yield about the same thing.
11:46:18 <Deewiant> ?. pl unpl uncurry ((. flip (,)) . flip fmap)
11:46:19 <lambdabot> uncurry (flip (fmap . flip (,)))
11:46:46 <mmorrow> ?. pl unpl uncurry (flip (fmap . flip (,)))
11:46:46 <lambdabot> uncurry (flip (fmap . flip (,)))
11:46:48 <Deewiant> that's one instance where slight changes to the original resulted in the ?pl result to change
11:46:56 <Deewiant> but in most cases it just gives that.
11:47:12 <Eridius> hrm, is there any way to turn record update syntax into a function without explicitly wrapping it in a function?
11:47:20 <Eridius> @pl \x -> x { foo = 1 }
11:47:20 <lambdabot> (line 1, column 9):
11:47:21 <lambdabot> unexpected "{"
11:47:21 <lambdabot> expecting variable, "(", operator or end of input
11:47:23 <Eridius> heh
11:48:07 <rwbarton> Eridius: The short answer is "no".  The long answer probably involves using template haskell
11:48:12 <Eridius> ok
11:48:21 <dons> Cale: interesting, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/AERN-RnToRm-Plot
11:48:23 <lambdabot> Title: HackageDB: AERN-RnToRm-Plot-0.1.0, http://tinyurl.com/3hwqzp
11:48:26 <Eridius> what is template-haskell anyway? Is it like haskell with macros?
11:48:33 <dons> yes.
11:48:34 <EvilTerran> effectively, yes
11:48:38 <dons> typed macros
11:48:54 <Eridius> but I assume only compile-time macros?
11:49:02 <Deewiant> is there another kind? :-P
11:49:04 <Eridius> like, C-style macros + typing?
11:49:07 <dons> you can run them at runtime if you want.
11:49:14 <dons> but that's a bit advanced.
11:49:15 <Eridius> Deewiant: lisp has 3 different types of macro
11:49:16 <dolio> More like lisp macros.
11:49:19 <ttt--> can TH be turned on in lambdabot?
11:49:29 <dons> its a huge security hole.
11:49:35 <Eridius> why's that?
11:49:35 <dons> it has been on in the past
11:49:41 <dons> but requires careful control to make it safe.
11:49:50 <dons> well, you can generate code that's run at compile time
11:49:51 <Eridius> > getStdGen
11:49:52 <lambdabot>       No instance for (Typeable StdGen)
11:49:52 <lambdabot>        arising from a use of `show' a...
11:49:57 <Eridius> huh
11:49:57 <dons> i.e. before type checking
11:49:58 <Deewiant> lunabot has TH, no?
11:50:00 <dons> so you can do some funky things.
11:50:05 <mmorrow> ?djinn ((((a->r)->r) -> ((b->r)->r)) -> ((a->r)->r)) -> ((a->r)->r)
11:50:05 <lambdabot> f a b = a (\ c _ -> c b) b
11:50:12 <Eridius> what's djinn?
11:50:13 <EvilTerran> arr!
11:50:15 <mmorrow> ?djinn ((((a->r)->r) -> ((b->r)->r)) -> ((a->r)->r)) -> ((a->r)->r)
11:50:15 <lambdabot> f a b = a (\ c _ -> c b) b
11:50:27 <mmorrow> ?. pl djinn ((((a->r)->r) -> ((b->r)->r)) -> ((a->r)->r)) -> ((a->r)->r)
11:50:27 <lambdabot> f = join . (. ((const .) . flip id))
11:50:41 <mmorrow> ?. unpl . pl djinn ((((a->r)->r) -> ((b->r)->r)) -> ((a->r)->r)) -> ((a->r)->r)
11:50:42 <lambdabot> f j = (\ r -> j (\ u _ -> u r)) >>= \ k -> k
11:50:42 <rwbarton> @help djinn
11:50:43 <lambdabot> djinn <type>.
11:50:43 <lambdabot> Generates Haskell code from a type.
11:50:44 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
11:50:47 <Eridius> huh
11:50:57 <mmorrow> ?. pl . unpl . pl djinn ((((a->r)->r) -> ((b->r)->r)) -> ((a->r)->r)) -> ((a->r)->r)
11:50:57 <lambdabot> f = join . (. ((const .) . flip id))
11:51:00 <Baughn> djinn < type>
11:51:04 <Baughn> Prints "f cannot be realized".
11:51:24 <romildo> Hi.
11:51:32 <dons> ?users
11:51:33 <lambdabot> Maximum users seen in #haskell: 515, currently: 499 (96.9%), active: 24 (4.8%)
11:51:38 <Deewiant> @yow
11:51:38 <lambdabot> MERYL STREEP is my obstetrician!
11:51:44 <mmorrow> lol
11:51:44 <Eridius> o_O
11:52:00 <ttt--> . [|2|]
11:52:08 <jeffersonheard> @yow
11:52:08 <lambdabot> YOU!!  Give me the CUTEST, PINKEST, most charming little VICTORIAN
11:52:08 <lambdabot> DOLLHOUSE you can find!!  An make it SNAPPY!!
11:52:11 <Deewiant> ] [|2|]
11:52:13 <lunabot>  LitE (IntegerL 2)
11:52:18 <jeffersonheard> I didn't know it did that...
11:52:27 <Deewiant> @vixen
11:52:28 <lambdabot> why do you keep repeating yourself?
11:52:42 <ttt--> ] $([|2|])
11:52:43 <lunabot>  2
11:53:11 * Eridius is starting to think that using any non-ascii char to start your sentence will trigger a bot here
11:53:20 <Eridius> err, I mean non-word char
11:53:21 <romildo> How would one check if a char is a space but not a newline? (\x -> isSpace x && x != '\n') ? Would that work independent of the plataform, as newline is represented differently in Unix, WIndos and MacOS?
11:53:29 <Deewiant> lunabot responds to various chars, not sure which ones
11:53:35 <Eridius> romildo: if you read a file in text-mode, \r\n is turned into \n on Windows
11:53:59 <Deewiant> there's also NEL and such
11:54:02 <Baughn> romildo: Newline is, by and large '\n' on modern mac
11:54:16 <Eridius> on OS X it's '\n'. You'd have to go back to Mac Classic for it to be '\r'
11:54:20 <Deewiant> > isSpace '\85'
11:54:21 <lambdabot>   False
11:54:41 <Deewiant> but it's still worth supporting plain '\r' IMO.
11:54:45 <Baughn> Well, you still see OS X programs that use \r, and a number of libraries are written to handle it. But it's *supposed* to be '\n'.
11:55:01 <mmorrow> i had to make a package that exported a subset of the TH interface (in particular, hide runIO), and had to write some instances of Show for ExpQ, etc which use unsafePerformIO, then re-export the parts of TH i wanted.
11:55:06 <Baughn> There's also the detail that (some) mac keyboards actually have an \r key
11:55:31 <Eridius> you could just check if not $ x `elem` "\n\r"
11:55:38 <Eridius> in addition to the isSpace check, that is
11:55:39 <Deewiant> > isSpace '\133'
11:55:41 <lambdabot>   False
11:56:01 <romildo> So it is better to write something like (\x -> isSpace x && x != '\n' && x != '\r')
11:56:12 <Deewiant> x `notElem` "\n\r"
11:56:20 <romildo> yes
11:56:31 <Deewiant> and \133 and \f and whatever else
11:56:35 <Baughn> > filter (isSpace.snd) $ map (\c -> (c,chr c) [0..10000]
11:56:35 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
11:56:36 <lambdabot>  ...
11:56:39 <chr1s> nice! Anders Hejlsberg (creator of C#) about programming in C#:
11:56:40 <chr1s> 50% of the bugs that people run into today, coding with C# in our platform, and the same is true of Java for that matter, are probably null reference exceptions. If we had had a stronger type system that would allow you to say that ‘this parameter may never be null, and you compiler please check that at every call, by doing static analysis of the code’. Then we could have stamped out classes of bugs.
11:56:46 <chr1s> http://www.computerworld.com.au/index.php/id;1149786074;fp;;fpid;;pf;1
11:56:52 <Baughn> > filter (isSpace.snd) $ map (\c -> (c,chr c)) [0..10000]
11:56:53 <Eridius> huh, never heard of NEL
11:56:54 <lambdabot>   [(9,'\t'),(10,'\n'),(11,'\v'),(12,'\f'),(13,'\r'),(32,' '),(160,'\160'),(57...
11:56:55 <lambdabot> Title: Computerworld - The A-Z of Programming Languages: C#, http://tinyurl.com/4kg4ev
11:57:01 <chr1s> I guess I prefer a language with Maybe
11:57:13 <Deewiant> there's also LS and PS, U+2028 and U+2029 respectively.
11:57:20 <mmorrow> > filter (isControl.snd) $ map (\c -> (c,chr c)) [0..10000]
11:57:21 <lambdabot>   [(0,'\NUL'),(1,'\SOH'),(2,'\STX'),(3,'\ETX'),(4,'\EOT'),(5,'\ENQ'),(6,'\ACK...
11:57:32 <Deewiant> > isSpace (chr 2028)
11:57:33 <Eridius> Deewiant: well, isSpace doesn't think '\85' is a space
11:57:34 <lambdabot>   False
11:57:36 <Deewiant> > isSpace (chr 85)
11:57:38 <Baughn> chr1s: Of course, just about any value can be _|_ in haskell
11:57:38 <lambdabot>   False
11:57:43 <Deewiant> Eridius: isSpace is crap. :-P
11:57:45 <rwbarton> > chr 85
11:57:46 <lambdabot>   'U'
11:57:57 <jeffersonheard> :t fmap (&&)
11:57:59 <lambdabot> forall (f :: * -> *). (Functor f) => f Bool -> f (Bool -> Bool)
11:58:13 <Deewiant> http://hackage.haskell.org/packages/archive/unicode-properties/3.2.0.0/doc/html/Data-Char-Properties-Misc.html is probably best
11:58:15 <lambdabot> Title: Data.Char.Properties.Misc, http://tinyurl.com/46dubp
11:58:50 <Eridius> Deewiant: I think you meant (chr 133) not (chr 85)
11:58:58 <Eridius> or possibly (chr 0x85)
11:59:03 <Deewiant> right, my bad.
11:59:06 <chr1s> Baughn: sure, but you can statically check that, and hardly anybody uses it (except for sometimes as phantom parameters for typeclasses)
11:59:09 <Eridius> still, same result
11:59:16 <Deewiant> > map isSpace [chr 0x2028, chr 0x2029, chr 0x85]
11:59:18 <lambdabot>   [False,False,False]
11:59:21 <Deewiant> :-/
11:59:35 <chr1s> Baughn: I most normal programs you wouldn't really find (a lot of) bottoms
11:59:35 <Baughn> chr1s: True. Less bottoms are yet another nice effect of laziness and purity, I think. :)
11:59:47 <dolio> > '\x85'
11:59:48 <lambdabot>   '\133'
12:00:03 <lambdabot>   Control
12:00:25 <rwbarton> > "hi there"
12:00:26 <lambdabot>   "hi there"
12:00:43 <Baughn> ..on most channels, that would be a _large_ netsplit
12:00:54 <Deewiant> > map isSpace . map chr . concat $ [[9..0xd],[0x20,0x85,0xa0,0x1680],[0x2000..0x200a],[0x2028,0x2029,0x202f,0x3000]]
12:00:56 <lambdabot>   [True,True,True,True,True,True,False,True,True,True,True,True,True,True,Tru...
12:01:28 <Deewiant> > filter (not.isSpace.snd) . map (\x -> (x,chr x)) . concat $ [[9..0xd],[0x20,0x85,0xa0,0x1680],[0x2000..0x200a],[0x2028,0x2029,0x202f,0x3000]]
12:01:29 <lambdabot>   [(133,'\133'),(8232,'\8232'),(8233,'\8233')]
12:01:37 <Deewiant> heh
12:01:44 <Deewiant> specifically the three that I try are the ones that fail :-P
12:05:25 --- mode: irc.freenode.net set +o ChanServ
12:05:42 <mmorrow> , toUTF8 ("|"++(take 10 . filter ((==Space) . generalCategory) $ ['\128'..])++"|")
12:05:42 <lunabot>  |  ᠎       |
12:05:42 <mmorrow> hm
12:05:43 <mmorrow> , take 4 (filter ((==Space) . generalCategory) ['\128'..])
12:05:44 <lunabot>  "\160\5760\6158\8192"
12:05:54 <Eridius> Deewiant: you could use isWhiteSpace from Data.Char.Properties
12:05:57 <Eridius> > isWhiteSpace '\x85'
12:05:58 <lambdabot>   Not in scope: `isWhiteSpace'
12:06:07 <Eridius> > Data.Char.Properties.Misc.isWhiteSpace '\x85'
12:06:08 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
12:06:08 <Deewiant> Eridius: yes, I linked to it myself :-P
12:06:11 <chrisdone> eek, that toUTF8 call has put a purple square on my terminal
12:06:13 <chrisdone> hax!!
12:06:21 <Eridius> Deewiant: we got netsplit
12:06:25 <Eridius> @list
12:06:26 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
12:06:29 <Deewiant> Eridius: that was before the netsplit
12:06:32 <mmorrow> chrisdone: haha
12:06:38 <Deewiant> > filter (not.isSpace.snd) . map (\x -> (x,chr x)) . concat $ [[9..0xd],[0x20,0x85,0xa0,0x1680],[0x2000..0x200a],[0x2028,0x2029,0x202f,0x3000]]
12:06:39 <lambdabot>   [(133,'\133'),(8232,'\8232'),(8233,'\8233')]
12:06:46 <Eridius> Deewiant: I didn't see that before the netsplit, but I can't check because it's already pushed beyond my scrollback :/
12:06:46 <Deewiant> I think that's a bug in isSpace, actually
12:07:05 <Deewiant> that list should definitely be empty
12:07:15 <Eridius> @index toUTF8
12:07:15 <lambdabot> bzzt
12:07:18 <mmorrow> , fmap (utf8enc . (:[])) . take 4 . (filter ((==Space) . generalCategory) $ ['\128'..])
12:07:19 <lunabot>  luna: Couldn't match expected type `a -> [a1]'
12:07:19 <lunabot>         against inferred type `[GHC.Types.Char]'
12:07:27 <Eridius> @hoogle toUTF8
12:07:27 <lambdabot> Distribution.Simple.Utils toUTF8 :: String -> String
12:07:38 <mmorrow> it's not that one
12:07:39 <chrisdone> huh
12:09:10 <mmorrow> it's a func i made just for lunabot, toUTF8 :: String -> UTF8, where the newtype UTF8 String has a show instance which goes through Text.PrettyPrint.Doc, which actually shows it not as a String
12:09:27 <mmorrow> , text "Doc's show instance"
12:09:28 <lunabot>  Doc's show instance
12:09:44 <mmorrow> , text "\n0"
12:09:44 <lunabot>  0
12:09:48 <mmorrow> err
12:10:08 <mmorrow> , vcat [text "0",text "1"]
12:10:09 <lunabot>  0
12:10:09 <lunabot>  1
12:11:00 * jeffersonheard is confused about the definition of fmap.  If I (fmap (&&)), I get a type signature I don't understand.  if f is IO, what do my params look like?
12:11:25 <Eridius> fmap == liftM
12:11:29 <olsner> @ty fmap (&&)
12:11:30 <lambdabot> forall (f :: * -> *). (Functor f) => f Bool -> f (Bool -> Bool)
12:11:35 <mmorrow> , fmap (utf8enc . (:[])) $ (filter ((==Space) . generalCategory) $ ['\128'..])
12:11:36 <lunabot>  ["\194\160","\225\154\128","\225\160\142","\226\128\128","\226\128\129","...
12:11:59 <Saizan> fmapIO :: (a -> b) -> IO a -> IO b, so fmapIO (&&) :: IO Bool -> IO (Bool -> Bool)
12:12:00 <jeffersonheard> ah.  fmap == liftM makes more sense.  But why are both defined?
12:12:29 <Saizan> liftM is how you define fmap if you only have >>= and return
12:12:31 <jeffersonheard> oh, nm
12:12:34 <jeffersonheard> I see why
12:12:34 <jeffersonheard> right
12:12:36 <jeffersonheard> thanks
12:12:51 <olsner> ... because someone missed having Monad extend Functor
12:13:53 <mmorrow> , text (utf8enc "\8704")
12:13:54 <lunabot>  ∀
12:14:20 <mmorrow> is exactly what toUTF8 does
12:14:41 <Eridius> ok
12:14:43 <Eridius> mischan
12:14:47 <mmorrow> @type text
12:14:48 <lambdabot> String -> Doc
12:19:13 <witkamp> I am new here to the #haskell I have a quick question syntax question.
12:19:35 <witkamp> Can I just paste an example in the channel
12:19:42 <mmorrow> use hpaste.org :)
12:19:45 <EvilTerran> @hpaste
12:19:45 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:19:47 <newsham> if its more than one line, please hpaste
12:19:57 <witkamp> thanks for info
12:19:59 <witkamp> :)
12:21:37 <newsham> codepad.org is useful if you wanna show error and/or output
12:21:49 <newsham> i guess more "or" than "and"
12:21:53 <mmorrow> oh yeh, codepad rocks.
12:22:25 <mmorrow> hmm. lunabot should have a web interface as well for eval...
12:22:43 <newsham> too bad codepad doesnt let you use files or do cmdline args
12:23:09 <mmorrow> and too bad x10 that it uses hugs
12:23:20 <mmorrow> (or at least last time i checked)
12:23:22 <witkamp> Why doesn't this parse http://hpaste.org/10818?lines=true
12:23:27 <newsham> yah
12:23:58 <olsner> witkamp: looks like inconsistent indentation
12:24:05 <Cale> witkamp: your cases aren't lined up
12:24:06 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
12:24:28 <mmorrow> witkamp: whoa, witkamp you're in luck. there's this sweet ELF parsing lib. i'll find the url to the darcs repo
12:24:34 <witkamp> olsner: I have been bitten by this a lot
12:24:55 <Cale> witkamp: also, it doesn't appear that it should matter, but there are some tabs in that, and you should make sure your editor converts them to spaces, because they'll inevitably cause trouble otherwise
12:24:58 <newsham> witkamp: btw, with the derive package, you can have it automaticaly derive your binary instances for you
12:26:09 <mmorrow> $ derive --module=MyFileBinaryInstance -dBinary MyFile.hs > MyFileBinaryInstance.hs
12:26:12 <newsham> i often wish there was better notation for "\w -> case w of ...."
12:26:16 <witkamp> Thanks guys
12:26:46 <olsner> 0s: problem posted in #haskell, 30s: solution, 1m: there's already a library that does half of what you're trying to do, 1m30s: there's another library that does the rest of it
12:27:29 <witkamp> so derive is a code generation tool ?
12:27:37 <newsham> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/derive
12:27:37 <lambdabot> Title: HackageDB: derive-0.1.1
12:27:42 <witkamp> cool thanks
12:27:43 <newsham> its a library.
12:28:04 <mmorrow> witkamp: here's that link http://www.cs.york.ac.uk/fp/darcs/ELF
12:28:10 <lambdabot> Title: Index of /fp/darcs/ELF
12:28:11 <witkamp> is it releated to template haskell?
12:28:17 <mmorrow> witkamp: yes
12:28:37 <rwbarton> mmorrow: it looks like it's only a parser, not a writer?
12:28:46 <witkamp> I making my own ELF reader for learning
12:28:49 <mmorrow> witkamp: the derive package also happens to have a cli tool, but is a lib first
12:29:01 <mmorrow> rwbarton: ah yeah, only a parser
12:29:22 <mmorrow> witkamp: cool
12:29:27 <newsham> there's also http://www.thenewsh.com/~newsham/store/DeriveBinary.hs
12:29:34 <newsham> which i'm obligated to hype
12:29:40 <mmorrow> heh
12:30:13 <newsham> elf is all fun and games until someone writes a dwarf2 parser
12:30:32 <witkamp> Well that is what I would like to do
12:30:39 <rwbarton> having written a rudimentary elf file writer, I don't think tools like derive would be too useful.  But maybe I don't know what they can do.
12:30:52 <mmorrow> rwbarton: that ELF package + Harpy.X86Disassembler is amusing to say the least
12:31:12 <witkamp> I would like to make a cool analys tool
12:31:22 <newsham> rwbarton: i have some tools in my derive that make it slightly omre general (ie. you can pick mapping of discriminants to variant tags)
12:31:28 <rwbarton> mmorrow: yeah mine was a brainfuck to elf executable compiler :)
12:31:42 <mmorrow> rwbarton: whoa. link?
12:32:07 <witkamp> lol
12:32:11 <jeffersonheard> cat $ELF.so | od  would be more readable
12:32:13 <rwbarton> let me find it.  I think it doesn't actually work in general, because of some issue with relocations.
12:32:36 <rwbarton> But it works for some medium-sized examples (and it beat bf2c + gcc)
12:33:22 <mmorrow> rwbarton: sweet. i want to learn about linker considerations, so this'll be excellent :)
12:33:45 <jeffersonheard> squick
12:34:15 <newsham> http://www.thenewsh.com/~newsham/x/machine/bdiff/elf.py
12:34:22 <rwbarton> mmorrow: OK.  Let me get this code into a respectable state, then you can work out how to fix it :)
12:34:39 <mmorrow> jeffersonheard: have you used harpy? you can disassemble to a [Instruction], then pattern match/manipulate at will (and even write the code back to a buffer and call it)
12:34:56 <mmorrow> rwbarton: hehe, thx.
12:35:32 <jeffersonheard> sounds familiary, but no
12:37:52 <geezusfreeek> it appears that i have some OMG vote data in gmail
12:38:02 <geezusfreeek> 2005
12:38:03 <rwbarton> mmorrow: oh, so actually I wrote a relocatable (.o) file and then linked it with ld.
12:38:10 <geezusfreeek> oops, i'm in the wrong channel
12:38:12 <geezusfreeek> sry
12:39:03 <mmorrow> rwbarton: cool, i also want learn about how to generate a .o
12:40:48 * SamB_XP wonders how people knew what year it was in BC
12:41:36 <newsham> samb: because they hadnt invented negative nubmers yet?
12:41:38 <mmorrow> SamB_XP: cal(1) ?
12:41:46 <SamB_XP> mmorrow: what ?
12:41:52 <mmorrow> lol
12:42:08 <gio123> language(a*b(a*b+bb*a)*) subset or equal language((a*b+bb*a)*)
12:42:19 <SamB_XP> gio123: what the heck ?
12:42:33 <SamB_XP> please explain your notation
12:43:16 <newsham> cal(1) is the man page for "cal" in section 1 of th emanual
12:43:47 <SamB_XP> newsham: I know that!
12:43:51 <SamB_XP> but did they ?
12:44:06 <gio123> heck?
12:44:08 <olsner> of course, how else would they have known?
12:44:12 <mmorrow> of course, where do you think unix came from?
12:44:14 <gio123> regular expression
12:44:23 <SamB_XP> gio123: ah!
12:44:27 <SamB_XP> regular expressions
12:44:45 <gio123> yes
12:45:06 <SamB_XP> well, is a*b a subset of (a*b+bb*a)* ?
12:45:25 <rwbarton> mmorrow: take a look at http://web.mit.edu/rwbarton/Public/bf2o.tar.gz
12:45:31 <SamB_XP> er.
12:45:34 <SamB_XP> a sublanguage
12:45:40 <mmorrow> rwbarton: excellent, thx
12:46:08 <newsham> cal 9 1752
12:46:31 <olsner> old :)
12:47:12 <rwbarton> mmorrow: Ah, I remember how it was "broken" now.
12:47:21 <newsham> samb: (a*b+bb*a) does not contain b, but a*b does
12:47:38 <rwbarton> mmorrow: harpy generates code into a fixed-size buffer, then when it gets too close to the end, it allocates another buffer and inserts a jump to it.
12:47:48 <olsner> hmm, I wonder what happens at the end of 5875706 to motivate this: "cal: year 5875707 not in range 1..5875706"
12:48:04 <rwbarton> mmorrow: I just treat whatever happens to be in memory between the start of the first buffer and the end of the last buffer as the executable code.
12:48:09 <newsham> cal: year 5875707 not in range 1..9999
12:48:15 <newsham> (freebsd)
12:48:19 <rwbarton> mmorrow: This works fine as long as the first buffer is at the lowest address and the blocks are pretty close together.
12:48:34 <olsner> newsham: apparently, gnu outlives bsd :)
12:48:52 <newsham> i think 5875707 is the year 1 hurd
12:48:55 <romildo> Are there high order functions in the library to combine two predicates with || or && operators?
12:49:04 <SamB_XP> 'cal' is not recognized as an internal or external command,
12:49:04 <SamB_XP> operable program or batch file.
12:49:14 <mmorrow> rwbarton: interesting
12:49:18 <olsner> operable program?
12:49:26 <rwbarton> romildo: liftM2 (||)
12:49:33 <newsham> ?type liftM2 (&&)
12:49:34 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
12:49:52 <rwbarton> > map (liftM2 (||) isAlpha isDigit) "ab3*"
12:49:53 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 22}
12:49:53 <lambdabot> ...
12:50:02 <newsham> ?type liftM2 (||) isAlpha isDigit
12:50:03 <lambdabot> Char -> Bool
12:50:06 <dons> ?users
12:50:06 <lambdabot> Maximum users seen in #haskell: 515, currently: 494 (95.9%), active: 16 (3.2%)
12:50:22 <newsham> whoa, weird, rwbarton used same exact example
12:50:27 <rwbarton> > isAlpha '3'
12:50:28 <lambdabot>   False
12:51:07 <mmorrow> oh. i think this is a haskell-src-exts bug if i recall correctly.
12:51:15 <mmorrow> > (||) undefined undefined
12:51:15 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 10}
12:51:15 <lambdabot> ...
12:51:19 <mmorrow> yeah, it is.
12:51:43 <mmorrow> the extra syntax they added to the haskell-src-exts parser screws with "(|"
12:51:54 <mmorrow> > ( ||) undefined undefined
12:51:55 <lambdabot>   * Exception: Prelude.undefined
12:51:59 <rwbarton> > map (liftM2 ( || ) isAlpha isDigit) "ab3*"
12:52:01 <lambdabot>   [True,True,True,False]
12:52:19 <SamB_XP> $ cal 5875707
12:52:19 <SamB_XP> cal: illegal year value: use 1-9999
12:52:19 <SamB_XP> Sam@deadweight ~
12:52:41 <SamB_XP> (Cygwin)
12:53:06 <SamB_XP> $ cal -V
12:53:06 <SamB_XP> cal from util-linux-2.12r
12:53:48 <mmorrow> , parseHsExp "(||) undefined undefined"
12:53:49 <lunabot>  Right (HsApp (HsApp (HsVar (UnQual (HsSymbol "||"))) (HsVar (UnQual (HsId...
12:54:23 <rwbarton> , (||) undefined undefined
12:54:24 <lunabot>  luna: Prelude.undefined
12:54:25 <mmorrow> (i just commented out all that extra syntax in my copy of haskell-src-exts)
12:54:28 <rwbarton> ah
12:55:17 <SamB> huh
12:55:22 <mmorrow> luna doesn't put its input through haskell-src-exts like lambdabot though..
12:55:31 <SamB> the only cal(1) I seem to have is cal(1posix)
12:55:33 <scodil> If I've got a bunch of functions of type s -> (s,a), ie a state monad, and some of them could possibly fail with an explanation, but I don't want to catch these failures I just want to inform the user and abort the operation, what's the most efficient way to handle that? ContT? ErrorT has a fair amount of overhead, doesn't it?
12:55:50 <SamB> DESCRIPTION
12:55:50 <SamB>        The  cal  utility  shall  write a calendar to standard output using the
12:55:50 <SamB>        Julian calendar for dates from January 1, 1 through September  2,  1752
12:55:50 <SamB>        and  the  Gregorian  calendar for dates from September 14, 1752 through
12:55:50 <SamB>        December 31, 9999 as though the Gregorian calendar had been adopted  on
12:55:50 <SamB>        September 14, 1752.
12:56:57 * SamB asks his mother the difference between julian and gregorian calendars
12:57:10 <mmorrow> the BC peeps had a diff DESCRIPTION which was, sadly, lost when the library at alexandria burned
12:57:13 * SamB is told to wait 5 minutes while she finishes reading history to his sister
12:58:00 <EvilTerran> scodil, if ErrorT fits your situation, i'd use ErrorT
12:58:05 <SamB> hmm
12:58:07 <EvilTerran> then, if it's too slow, profile
12:58:16 <SamB> I have an ncal(1) which claims to be CAL(1)
12:58:56 <mmorrow> scodil: catchDyn/throwDyn would work as well (if you're in IO)
12:59:12 <scodil> I'm not in io
12:59:23 <SamB> hmm, ncal's manpage mentions 5875706
12:59:41 <mmorrow> err, actually i guess only the catchDyn has to be in IO
12:59:48 <mmorrow> @type throwDyn
12:59:49 <lambdabot> Not in scope: `throwDyn'
12:59:56 <SamB> @hoogle throwDyn
12:59:56 <lambdabot> Control.Exception throwDyn :: Typeable exception => exception -> b
12:59:56 <lambdabot> Control.Exception throwDynTo :: Typeable exception => ThreadId -> exception -> IO ()
13:00:17 <mmorrow> my favorite is "throwDyn ()"
13:00:26 <SamB> that's SOOOO informative
13:00:37 <mmorrow> i guess you could throwDyn (errorMsg::String)
13:00:58 <SamB> that wouldn't work too well though would it ?
13:00:58 <mmorrow> SamB: heh. throwDyn () as a synonym for "jump"/"abort"
13:01:10 <scodil> what's the downside to using CPS for exceptions? Its just more complicated? The consensus seems to be that its a lot more efficient
13:01:12 <FunctorSalad> is it safe to make a stream of curl download IO actions? ._.
13:01:27 <mmorrow> scodil: CPS is great
13:01:35 <dons> FunctorSalad: how about using Network.Curl.Download.Lazy ?
13:01:41 <EvilTerran> scodil, just the complexity, i think
13:01:42 <dons> FunctorSalad: its all done for you.
13:01:45 <FunctorSalad> "safe" as in "only as many files as necessary are downloaded"
13:01:49 <FunctorSalad> dons: ah, thanks :)
13:01:54 <SamB> Prelude Control.Exception> throwDyn "hi"
13:01:55 <SamB> *** Exception: (unknown)
13:01:56 <EvilTerran> it fails Do The Simplest Thing That Could Possibly Work
13:01:58 <dons> FunctorSalad: in the download-curl package.
13:02:33 <SamB> scodil, EvilTerran: what context are you speaking of ?
13:02:51 <EvilTerran> SamB, using MonadCont when MonadError would suffice
13:03:08 <SamB> EvilTerran: that's faster somehow ?
13:03:20 <EvilTerran> i dunno, ask scodil
13:03:30 <EvilTerran> i say, if MonadError would do, use MonadError
13:03:30 <scodil> http://www.haskell.org/haskellwiki/Performance/Monads
13:03:32 <lambdabot> Title: Performance/Monads - HaskellWiki
13:03:35 <FunctorSalad> dons: too high-level unfortunately (I have an existing curl handle which has cookies :))
13:03:58 <scodil> the fellow there claims 4x speedup by switching to CPS
13:04:02 <dons> FunctorSalad: right, but you might be able to look how we did it.
13:04:05 <scodil> versus the MTL monads
13:04:14 <dons> scodil: yes, this has been noticed before.
13:04:18 <dons> though we don't have recent data
13:04:20 <SamB> scodil: compiled optimally?
13:04:27 <dons> esp. since the ghc inliner has improved drastically.
13:04:30 <FunctorSalad> what I got so far is a "MyArrow Url (stuff,Url)" and I'd like a stream of stuff
13:05:11 <mmorrow> > let forever' m a = m a >>= forever' m in flip runCont id (callCC $ \k -> forever' (\n -> if n > 10 then k n else return (n+1)) 0)
13:05:12 <lambdabot>   11
13:05:17 <FunctorSalad> (it's an IOStateArrow to be specific)
13:06:58 <mmorrow> scodil: yhc-javascript also uses cps instead of a Monad for efficiency reasons
13:08:45 <scodil> I've tinkered with the State monad for compute-intensive code, and GHC seems to do ok with it, but it doesn't really every get eliminated. The state parameter gets threaded through everything, even if its passed around un changed. I'm just wondering if ErrorT will leave branches lingering in loops. Plust CPS seems cool and I'd like to learn how to write in that style
13:09:09 <scodil> "but it doesn't really ever get eliminated"
13:09:19 <scodil> that's a terrible sentence but you know what I mean
13:10:25 <SamB> @go one galactic year
13:10:27 <lambdabot> http://en.wikipedia.org/wiki/Galactic_year
13:10:28 <lambdabot> Title: Galactic year - Wikipedia, the free encyclopedia
13:10:31 <SamB> aww
13:10:40 <ukl> I used to "darcs pull" and build myself but now set up cabal (and I kinda like it, really) - How can I "hand over control" for something I installed myself to cabal (for upgrading for example)?
13:11:23 <SamB> ukl: cabal-install, you mean ?
13:11:44 <SamB> there really aren't any steps involved
13:11:56 <ukl> SamB: cabal-install, yea right! :)
13:12:49 <SamB> it seems to me like cabal-install is to ./Setup.hs as apt-get is to dpkg ... though dcoutts doesn't see it that way at all
13:13:09 <ukl> SamB: So I can just delete my local darcs repo, be happy with the installed packages (lying somewhere else, ~/lib instead of ~/.cabal/lib/ ) and have everything managed by cabal-install for ever?
13:13:39 <SamB> sure
13:13:43 <SamB> should be fine
13:14:27 <ukl> it will even delete the outdated files in ~/lib/ ? wow, I didn't expect that. :) cool.
13:14:32 <mmorrow> > let increment = 3 ; forever' m a = m a >>= forever' m in flip runCont id (callCC $ \outer -> callCC (\inner -> forever' (\n -> when (n > 0 && n `rem` 9 == 0) (outer n >> return()) >> when (n > 10) (inner n >> return ()) >> return (n+increment)) 0))
13:14:34 <lambdabot>   9
13:14:37 <mmorrow> > let increment = 2 ; forever' m a = m a >>= forever' m in flip runCont id (callCC $ \outer -> callCC (\inner -> forever' (\n -> when (n > 0 && n `rem` 9 == 0) (outer n >> return()) >> when (n > 10) (inner n >> return ()) >> return (n+increment)) 0))
13:14:39 <lambdabot>   12
13:14:45 <SamB> ukl: what makes you think it ever deletes anything ?
13:14:49 <rwbarton> cabal install will totally ignore your existing installation.
13:15:17 <ukl> SamB: Oh. So it just installes the new one beside the existing one?
13:15:37 <SamB_XP> yeah ;-)
13:15:53 <rwbarton> your darcs repos are of things on hackage?  or random cabalized libraries?
13:16:14 <ukl> indeed... (just checked ghc-pkg list) some versions of some things
13:16:29 <ukl> so it doesn't even delete the outdated things it installed on its own? ok.
13:16:34 <ukl> rwbarton: hackage things, yes
13:16:59 <rwbarton> (You can also use "cabal install" as a replacement for "runhaskell Setup configure; ...".)
13:19:50 <ukl> thank you, SamB*, rwbarton.
13:20:08 <SamB_XP> you're welcome ;-)
13:22:57 <mmorrow> , let mapC f [] = [] ; mapC f (x:xs) = f x xs (\xs -> mapC f xs) in mapC (\n rest k -> if n == 8 then k [] else n : k rest) [0..]
13:22:59 <lunabot>  [0,1,2,3,4,5,6,7]
13:24:24 <mmorrow> , let mapC f [] = [] ; mapC f (x:xs) = f x xs (\xs -> mapC f xs) in mapC (\x (y:z:rest) k -> x : y : k (z:y:rest)) [0..]
13:24:26 <lunabot>  [0,1,2,1,3,1,4,1,5,1,6,1,7,1,8,1,9,1,10,1,11,1,12,1,13,1,14,1,15,1,16,1,1...
13:26:56 <mmorrow> , let mapC f [] = [] ; mapC f (x:xs) = f x xs (\xs -> mapC f xs) in mapC (\x (y:z:rest) k -> x : y : k (z:x+y:rest)) [0..]
13:26:57 <lunabot>  [0,1,2,1,3,3,4,6,5,10,6,15,7,21,8,28,9,36,10,45,11,55,12,66,13,78,14,91,1...
13:27:54 <mmorrow> , let mapC f [] = [] ; mapC f (x:xs) = f x xs (\xs -> mapC f xs) in mapC (\x (y:rest) k -> x+y : k (y:x+y:rest)) [0..]
13:27:55 <lunabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
13:28:37 <hugo_> hmm
13:28:47 <hugo_> what is the meaning of IO String type ?
13:28:57 <hugo_> can i define a IO myType ?
13:29:13 <dibblego> @type return 7 :: IO Int
13:29:14 <lambdabot> IO Int
13:29:22 <mmorrow> a function (StateOfTheWorld -> String)
13:29:26 <pjdelport> hugo_: it's an action that will return a string
13:29:36 <hugo_> ok
13:29:42 <pjdelport> :t getLine
13:29:42 <mmorrow> newtype IO a = IO (StateOfTheWorld -> a)
13:29:44 <lambdabot> IO String
13:29:44 <Cale> hugo_: For any type t, values of type IO t are actions which if executed, would produce a value of type t.
13:29:59 <Cale> hugo_: Normal evaluation doesn't cause this execution to occur.
13:30:05 <hugo_> ah thanks :)
13:30:54 <hugo_> so i can have a function with a type signature like this: String->IO myData
13:30:56 <Cale> hugo_: In some sense, the only action which is executed in a compiled program is the one called main, but in turn it is typically built up from many simpler actions :)
13:30:59 <Cale> yes
13:31:07 <hugo_> yes
13:31:08 <hugo_> i see
13:31:18 <hugo_> then i will be bound to IO
13:31:22 <Cale> Though if it's a custom datatype, you'll need that to be MyData
13:31:36 <hugo_> heheh
13:31:37 <hugo_> yes
13:31:41 <Cale> IO actions can be built up not only from IO actions though, but also from pure functions.
13:31:44 <mmorrow> and "executing" an IO action is just (\(IO f) -> f currentWorldState)
13:31:51 <hugo_> hmm
13:32:14 <hugo_> i can run a role of pure functions inside an action, as long as the final return type is IO something, right ?
13:32:15 <Cale> So the idea is that the actual input and output are done in the IO monad, and in between somewhere, the input is passed to some pure functions for processing.
13:32:44 <Baughn> hugo_: If you couldn't, there would be no way to use pure functions at all
13:32:51 <hugo_> heheh yes
13:32:51 <hugo_> :)
13:33:12 <Cale> hugo_: Well, if you write a do-block with IO actions in it, the type of the whole do-block automatically must be IO t for some type t.
13:33:22 <Cale> (in fact, it's the type of the last action in the block)
13:33:35 <mmorrow> (getChar >>= \c -> (somePureFunction::Char -> a) c) :: IO a
13:33:42 <SamB_XP> :type do 1
13:33:47 <Cale> do blocks glue together IO actions into larger ones
13:34:00 <hugo_> yes
13:34:03 <SamB_XP> :t do 1
13:34:04 <lambdabot> forall (t :: * -> *) t1. (Num (t t1)) => t t1
13:34:04 <hugo_> i see
13:34:11 <hugo_> ill try to do something then :)
13:34:11 <hugo_> thanks
13:34:13 <hugo_> :D
13:34:18 <SamB_XP> WIERD
13:34:26 <Cale> http://www.haskell.org/haskellwiki/Introduction_to_IO
13:34:28 <lambdabot> Title: Introduction to IO - HaskellWiki
13:34:28 <mmorrow> ((getChar >>= \c -> (somePureFunction::Char -> a) c) >>= \a -> (anotherPureF::a -> b) a) :: IO b
13:34:39 <Cale> goes a little further in discussing how things are built up
13:34:44 <Cale> you might check it out :)
13:34:58 <SamB_XP> ... why does GHC now constrain it to be built from a type constructor, but not constrain that type constructor further ?
13:35:12 <SamB_XP> shouldn't the type by (Num a) => a ?
13:35:15 <mmorrow> do c <- getChar ; return (anotherPureF . somePureFunction) c
13:35:18 <hugo_> thanks Cale :)
13:35:20 <mmorrow> err
13:35:25 <mmorrow> do c <- getChar ; return $ (anotherPureF . somePureFunction) c
13:35:47 <mmorrow> :: IO b
13:35:58 <pastorn> can you do "type MyAlias a = SomeType a" but for typeclasses?
13:36:00 <Cale> SamB_XP: I think it should be (Monad m, Num a) => a, but I suppose that doesn't really matter.
13:36:03 <Cale> er
13:36:07 <Cale> => m a rather
13:36:16 <SamB_XP> Cale: well, Haskell 98 seems fairly clear on this ;-)
13:36:30 <rwbarton> Hugs seems to get it more right.  do {...} :: (Monad a, Num (a b)) => a b
13:36:31 <SamB_XP> it says that do 1 = 1
13:36:38 <SamB_XP> and doesn't say a thing about the type
13:37:02 <Cale> SamB_XP: Well, yes, but GHC has as long as I can remember been a little strange on that front.
13:37:04 <pastorn> http://www.haskell.org/pipermail/haskell-cafe/2006-November/019190.html <-- i want to do typeClassAlias WarmFuzzyThing m = Monad m
13:37:06 <lambdabot> Title: [Haskell-cafe] there's a monster in my Haskell!, http://tinyurl.com/y49m75
13:37:19 <SamB_XP> Cale: I think it used to do what rwbarton describes, which is not a strange thing to do ...
13:39:59 <rwbarton> pastorn: you might be able to get close by writing  class Monad m => WarmFuzzyThing m; instance Monad m => WarmFuzzyThing m where;
13:40:29 <pastorn> rwbarton: thanks :D
13:41:20 <vixey> @quote
13:41:20 <lambdabot> emu says: olegarithmic!
13:41:29 <vixey> @quote
13:41:29 <lambdabot> pkhuong says: [vincenz] life is all in the randomness [pkhuong] says the concurrent programmer
13:43:13 <vixey> hello
13:45:37 <vixey> @farber
13:45:38 <lambdabot> I was working my balls to the bone.
13:49:04 <vixey> , data Foo x = Bar x (Foo (x,x))
13:49:06 <lunabot>  luna: parse error on input `data'
13:50:36 <mmorrow> , (ppDoc . head) `fmap` [d|data Foo x = Bar x (Foo (x,x))|]
13:50:38 <lunabot>  data Foo x_0 = Bar x_0 (Foo ((x_0, x_0)))
13:50:40 <Eridius> @pl \r -> runReader (k (runReader m r)) r
13:50:40 <lambdabot> runReader =<< k . runReader m
13:52:15 <mmorrow> @type \k m -> join ((runReader .) . k . runReader m)
13:52:16 <lambdabot> forall r a a1 a2. (a2 -> a1 -> Reader r a) -> Reader a1 a2 -> a1 -> r -> a
13:52:36 <mmorrow> @type \k m r -> runReader (k (runReader m r)) r
13:52:37 <lambdabot> forall r a a1. (a -> Reader r a1) -> Reader r a -> r -> a1
13:53:00 <mmorrow> @type \k m -> (runReader .) . k . runReader m
13:53:01 <lambdabot> forall r a a1 a2 a3. (a3 -> a1 -> Reader r a) -> Reader a2 a3 -> a2 -> a1 -> r -> a
13:53:15 <vixey> what's going on?
13:53:43 <mmorrow> not much
13:55:08 <mmorrow> vixey: can you explain to me what's happening in "de bruijn subtlety" http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=64 ?
13:55:22 <vixey> It's just me being confused as usual
13:55:30 <vixey> I've got a solution to it..
13:55:52 <vixey> It's supposed to be the same typechecking derivation in alpha and de bruijn terms
13:56:03 <vixey> it goes horribly wrong for no apparent reason with de bruijn though..
13:57:23 <mmorrow> is the big pi as in "product" or "pi type"?, i'm not fully familiar with the notation yet.
13:57:41 <mmorrow> (or is that the same thing)
13:57:52 <mmorrow> (in whatever sense)
13:58:09 <vixey> I write X -> Y as ∏(_:X), Y
13:58:33 <mmorrow> ah, ok. i see now.
13:58:51 <vixey> if I was doing simple types I'd just unify the type rules over a fold but this is a bit harder
13:59:41 <mmorrow> hmm
14:00:44 <rwbarton> Has anyone seen this error message before:   parse error in doc string: [haddock: Internal Happy error
14:01:48 <rwbarton> It's choking on this comment:  -- /foo/bar/baz, /foo/bar/*, /foo/bar/**, /foo/**, /**
14:02:27 <jeffersonheard> is there some place that explains how to use the ST monad?
14:02:48 * bos is building ghc 6.10.1 beta on x86_64. mmm, warm toasty laptop.
14:02:55 <bos> jeffersonheard: real world haskell.
14:03:08 <jeffersonheard> oh yeah!
14:03:36 <bos> jeffersonheard: http://book.realworldhaskell.org/read/advanced-library-design-building-a-bloom-filter.html#id680273
14:03:38 <lambdabot> Title: Chapter 26. Advanced library design: building a Bloom filter, http://tinyurl.com/5nfgdp
14:03:39 <vixey> mmorrow: so I have the typechecker now.. next I have to add data (and derive eliminators for them)
14:04:00 <byorgey> vixey: what are you working on?
14:04:30 <vixey> byorgey: trying to make a little programming language
14:04:32 <mattam> vixey: I can look at your de Bruijn version if you like.
14:04:40 <byorgey> vixey: cool, sounds fun
14:04:53 <vixey> mattam: ah it is currently working
14:05:09 <vixey> I have split the free vars into Sym String and Local Integer, like in a paper I read
14:06:07 <mattam> Ah, localy nameless ftw
14:06:10 <vixey> (so de bruijn terms get changed into Locals to be put into a type context.. instead of directly, and it seems to work)
14:06:21 <vixey> yeah it's very much better than using Strings for everythding :)
14:06:44 <dons> bos, keep a list of what breaks.
14:06:51 <dons> so we can start managing the 6.10 transition
14:07:02 <mattam> Coq uses that representation as well, although you can have de Bruijn contexts in some places.
14:07:19 <mmorrow> vixey: sweet.
14:07:35 <dons> mm. votes going 10:1 in favour of the haskell mp3 blog today. lovely jubbly.
14:09:26 <dons> in case anyone else missed this, http://www.reddit.com/r/programming/comments/74n0v/implementing_an_mp3_decoder_a_haskell_tutorial/
14:09:29 <lambdabot> Title: Implementing an mp3 decoder: a Haskell tutorial : programming, http://tinyurl.com/4qosta
14:10:33 <hugo_> is there any way to install all the standard libraries ?
14:10:54 <vixey> byorgey: except for writing a parser!
14:11:01 * vixey has been avoiding this..
14:11:03 <hugo_> i mean, without installing them one by one :P
14:11:04 <dons> hugo_: all of them?
14:11:12 <dons> hugo_: or do you just mean those that come with ghc?
14:11:26 <vixey> hugo: did you build GHC ? because there are extralibs you can get for it
14:11:33 <hugo_> oh
14:11:36 <dons> it really depends on your distibution. likely you have all the core and extralibs with your ghc package.
14:11:39 <hugo_> i got the suse binary package
14:11:59 <hugo_> i have to install them :( seems it is a really stripped down version
14:12:10 <vixey> I am used to write code that loks like Lam (Lam (App (Var 0) (Lam ... though
14:12:15 <mattam> vixey: you can probably get away with a simple parsec implentation don't you think?
14:13:54 <vixey> hm I think so yes
14:14:08 <bos> dons: that article is great.
14:14:25 <bos> it's also the first haskell article on reddit in a while to get loads of votes.
14:14:34 <dons> yeah.
14:15:01 <dons> a matter of timing (submitting early morning on a weekday), and having very broad, obvious appeal
14:15:12 <dons> it could be a RWH chapter :)
14:15:13 <bos> yep.
14:15:24 <bos> heh, it could indeed.
14:16:12 <vixey> mattam: I'm wondering if I can get away with no pattern matching construct.. just eliminatiors. it certainly works for haskell like languages but something like this? It's tougher (on the implementor :p)
14:17:35 <chr1s> bos: how was the RWH session?
14:17:59 <bos> good!
14:18:02 <chr1s> bos: and thanks for pointing me to andy
14:18:16 <bos> sure, i hear it went well.
14:18:25 <chr1s> what was the audience like? lots of haskell programmers, or really the target audience?
14:18:33 <bos> mostly the latter.
14:18:40 <hugo_> oh
14:18:47 <chr1s> cool!
14:18:57 <bos> yes, that was good.
14:20:42 <fxr> dons: thanks for the arch package :)
14:22:16 <Cale> dons: you wrote: let !x = 2^43112609-1 -- does that bang pattern actually do anything? ;)
14:22:54 <byorgey> vixey: on the other hand, allowing pattern matching gets really hairy for you =)
14:23:45 <byorgey> actually, I am currently trying to read through a bunch of papers on pattern matching with dependent and inductive data types =)
14:24:00 <thoughtpolice> Cale: http://hpaste.org/10820 <- would that indicate 'yes'?
14:24:26 <Cale> thoughtpolice: scary.
14:25:05 <Cale> How are bang patterns on pattern bindings translated?
14:25:13 <bos> yes, the bang pattern effectively makes the pattern strict.
14:25:26 <bos> it's a more reliable way to get strictness than via seq.
14:25:28 <Cale> bos: I understand what bang patterns do in *function* bindings.
14:25:42 <bos> i know you do :-)
14:25:45 <Cale> :)
14:25:59 <Cale> So is this a genuinely new language primitive?
14:26:15 <Philonous> Are variables not just nullary functions?
14:26:17 <vixey> byorgey: oh which papers?
14:26:21 <Cale> Philonous: no :)
14:26:33 <mattam> vixey: eliminators are enough, but you may like to compile down to them as in EDPM by Goguen, McBride and McKinna. It's pretty easy in the non-dependent case.
14:26:54 <Cale> bos: Or are the seq's all put in at the start of the 'in' part?
14:26:54 <bos> it's compiled into a case expression.
14:26:58 <Cale> mm...
14:27:25 <Cale> okay
14:27:26 <bos> so it's not translated to applications of seq.
14:27:29 <Cale> I can imagine that.
14:28:01 <bos> i think that pseq behaves more like a bang pattern.
14:28:04 <Cale> Oh, so if we have, say,  !f = (+1) . undefined
14:28:08 <vixey> mattam: *nod* I've done it in the non-dependent case for a couple languages - I wanted to try out the method that brings out a unification problem in JMeq equations.. it's a really cool method
14:28:14 <Cale> hmm
14:28:22 * Cale tries :)
14:29:08 <bos> Cale: you still get a case expression, but since it's an unapplied function, no crash.
14:29:09 <mattam> vixey: The thing is, if you have a primitive case construct you can express all eliminators in terms of this. Otherwise you need to add more reduction rules with each new datatype.
14:29:31 <mattam> Or do things very generically but no working system does it yet.
14:29:42 <bos> ye gods, building the haskell platform is going to take forever.
14:29:45 <Cale> er, which ghc is this?
14:30:21 <mattam> Yeah the JMeq trick is nice but specialization by unification requires a bit of machinery.
14:30:21 <bos> are you asking me?
14:30:23 <vixey> it is quite a trade off
14:30:27 <roconnor> mattam, vixey: wait, how are eliminators enough?  What about the tree-forest nested fixpoint example?
14:30:28 <Cale> aha, it's new in 6.8.3
14:30:31 <Cale> (this behaviour)
14:31:26 <Cale> main = do let f :: Int -> Int
14:31:26 <Cale>               !f = undefined
14:31:26 <Cale>           print "Hi!"
14:31:33 <Cale> that still dies :)
14:31:48 <Cale> So it's forcing the evaluation of the function, anyway.
14:31:58 <Cale> (which is something that an ordinary case can't do, iirc.)
14:32:21 <mattam> roconnor: Ha good point. I think the idea is that any kind of definable recursion scheme is allowed. You know the encoding of course-of-value recursion via a Below predicate? Probably the a variation on this can be done for this case.
14:32:57 <mattam> No time to try that now, sadly.
14:33:01 <vixey> roconnor: I'm not totally sure what I'm going to do yet, but as it could be defined in the bove capretta way, I'd like to try to do most things via that (except it does mean more (non-automatedd) theoremproving)
14:33:44 <roconnor> I kinda dropped into the middle of this conversation, so I guess I don't really know what the subject is. :)
14:34:06 <roconnor> "only eliminators are required" made my ears (eyes?) perk up
14:34:12 <vixey> hehe
14:34:26 <ddarius> Knowing what you're talking about is for losers.
14:34:27 <mattam> roconnor: compiling dependent pattern-matching (and recursive functions made from such equations) down to eliminators.
14:34:56 <roconnor> :)
14:34:56 <bos> ddarius: on the contrary, it's for lovers.
14:35:05 <tristes_tigres> @pointless sex
14:35:06 <lambdabot> sex
14:35:30 <roconnor> I must say I was impressed with Agda which appears to take the opposite approach: turn everything into pattern matching.
14:35:44 <roconnor> they even got the K axiom/theorem.
14:35:48 <vixey> what bugs me about Agda is I have _no clue_ how it works
14:35:57 <mattam> I find the Below-way very nice and clever.
14:36:00 <vixey> .. and I can't read the source code to understand it
14:36:01 <Cale> What are eliminators?
14:36:08 <roconnor> vixey: have you read Alf(?)'s thesis?
14:36:08 <mattam> Agda cheats :)
14:36:21 <vixey> Cale: I guess it would be like foldr, except it has a more explicit type
14:36:22 <roconnor> Cale: primitive recursers (I think)
14:36:28 <Cale> mm, okay :)
14:36:53 <roconnor> mattam: cheats?
14:36:53 <mattam> It compiles dependent pattern-matching away to nothing.
14:37:22 <mattam> The first-order unification is part of the kernel.
14:37:23 <vixey> i.e. list-elim : ∏A:*, (P : list A -> *) -> P nil -> (∏x xs, P xs -> P (x:xs)) -> ∏xs, P xs -- something like that
14:37:29 <roconnor> oh
14:37:32 <roconnor> cheats in that way.
14:37:40 <roconnor> hmm
14:37:41 <vixey> ugh I mixed up : with :
14:38:06 <mattam> It extends the underlying type-theory in a way.
14:38:14 <vixey> mattam, what do you mean by nothing?
14:38:26 <vixey> it is just executed in the naive way?
14:38:30 <roconnor> mattam: well, like I said, it gives them K.
14:38:36 <hellige> does anyone how to get lambdabot in a new channel?
14:38:47 <Cale> hellige: I do.
14:38:52 <Cale> hellige: Which channel?
14:39:24 <hellige> cale: ##hrg (some friends want to do a haskell reading group, and meet in irc for discussion. i figure lambdabot would be a big help.)
14:39:33 <Cale> okay
14:39:45 <Cale> well, for starters
14:39:50 <Cale> lambdabot: @join ##hrg
14:40:04 <Cale> I'll add you to the join list in case lambdabot gets restarted
14:40:20 <roconnor> vixey: have you read Alf(?)'s thesis on Agda?  It seems to be the way to understand how Agda works.
14:40:25 <mattam> vixey: It checks exhaustiveness and that branches are well-typed and that's it, it doesn't compile this down to simpler case expressions. That's called the external approach.
14:40:29 <hellige> great, thanks! i didn't see "join" or anything similar in the command list.
14:40:31 <mattam> Ulf's
14:40:36 <roconnor> yes
14:40:38 <vixey> roconnor: oh sorry, I had skimmed it
14:40:38 <roconnor> Ulf
14:40:49 <roconnor> oh good.
14:40:56 <Cale> hellige: It's an operator command anyway :)
14:41:02 <mattam> The explanation of the pattern matching algorithm is quite clear in it.
14:41:03 <roconnor> I haven't read it either.  Just enough to undertand how they manage to prove K.
14:41:14 <hellige> cale: eureka. thanks again!
14:41:29 <Cale> No problem :)
14:42:22 <mattam> Altough, it doesn't explain it in terms of simpler constructs like the EDPM article does. Agda also allows overlapping which is not supported usually.
14:42:46 <vixey> oh there is another option I thought about
14:43:06 <vixey> adding ISPTs to the theory and then every data and fold could be in terms of that
14:43:31 <vixey> although I don't imagine I would get it to work..
14:43:34 <mattam> ISPTs?
14:44:14 <vixey> All the sort of things presented in http://www.cs.nott.ac.uk/~pwm/
14:44:16 <kosmikus> indexed strictly positive types
14:44:18 <lambdabot> Title: Peter Morris's Homepage
14:44:32 <vixey> it would be really cool to do but I think it should be quite hard :)
14:44:56 <mattam> Yeah, the generic approach.
14:45:13 <mattam> We'll see if Epigram 2 goes anywhere :)
14:45:29 <mattam> It looks promising at least.
14:45:45 <kosmikus> yes, it'd be great to have a better epigram
14:46:01 <mmorrow> ISPTs? Infuriatingly Slippery Pet Turtles?
14:46:09 <ddarius> hellige: Matt from LtU?
14:46:28 <mmorrow> (slash what does ISPT stand for?)
14:46:29 <olsner> insanely stinky perl turds?
14:49:05 * shepheb thinks it would be near impossible to hold on to a greased turtle
14:49:13 <mmorrow> Invariably Swampy Prison Toilets?
14:49:44 <vixey> mmorrow: all the papers on Peter Morris site
14:50:41 <mmorrow> hehe: http://www.ispt.org/membership.htm
14:50:41 <lambdabot> Title: How to Become a Member of International Society of Professional Trackers ISPT
14:54:41 <tristes_tigres> ISPT - Incredibly Sexy Penthouse Things ?
15:03:27 <chrisdone> eww I'm reading someone's code and they've defined (.) :: a -> (a -> b) -> b
15:04:03 <chrisdone> does anyone else do this?
15:04:17 <seliopou> I want to experience
15:04:20 <seliopou> what it's like to be them
15:04:26 <chrisdone> haha
15:05:00 <chrisdone> (G.flat_uri / post_id.to_utf8) .doesFileExist .liftIO
15:05:44 <dons> Cale: sure, that bang pattern is kind of important, since we don't demand 'x'
15:05:54 <chrisdone> has to be a python or ruby programmer
15:06:09 <bos> my copy of "the princeton companion to mathematics" arrived last night.
15:06:20 <bos> it should give me some good bedtime reading for the next several years.
15:06:26 <seliopou> it's kindof sortof RPN-ish as well
15:06:54 <SamB_XP> chrisdone: heh
15:06:58 <vixey> I skimmed Proofs from The Book the other day, that's packed with interesting stuff
15:07:03 <SamB_XP> what do they do for composition ?
15:07:04 <Cale> dons: I was previously unaware that bang patterns had any meaning for pattern bound variables
15:07:08 <olsner> almost something for the obfuscated haskell contest
15:07:23 <djsiegel> Can someone help me with Text.XML.HaXml.Combinators?
15:07:55 <djsiegel> I'm trying to get every element with the name "entry" in my document. I feel like it should look something like:
15:08:20 <djsiegel> let Document _ _ (Elem _ _ contents) _ = myParsedDocument
15:08:41 <djsiegel> somethin /> tag "entry" /> something $ contents
15:08:44 <chrisdone> SamB_XP: I can't really find any composition
15:08:55 <dons> Cale, yes, it has interesting consequences.
15:08:59 <djsiegel> There are just too many new types that I can't get a grip on what's going on.
15:09:04 <dons> particular for observing exceptions
15:10:09 <Cale> dons: bos said that they're translated into case expressions, but I was able to observe that a function was undefined in that way, so that can't be the whole story :)
15:10:25 <mmorrow> bos: lol
15:10:31 <Cale> (seems more like putting a bunch of seq's before the 'in' part)
15:10:32 <chrisdone> SamB_XP: I'm looking at the source of Panda, some blog software that someone's wrote ( http://github.com/nfjinjing/panda/tree/master ) using my Kibro. it's nice software
15:10:34 <lambdabot> Title: nfjinjing's panda at master — GitHub
15:10:50 <bos> Cale: they really are. look at the Core output.
15:10:53 <Cale> hmm
15:11:04 <bos> where the heck did hsc2hs go in ghc 6.10?
15:11:32 <Cale> > case undefined :: Int -> Int of x -> 5
15:11:33 <lambdabot>   5
15:11:39 <seliopou> djsiegel: I don't know what your requirements are, nor have I actually used any Haskell XML libraries. However the 'xml' package on hackage seems to have a very simple interface.
15:11:42 <chrisdone> SamB_XP: http://jinjing.blog.easymic.com/ http://chrisdone.com/blog/ haskell blogs everywhere!
15:11:43 <lambdabot> Title: C大调
15:11:43 <seliopou> might want to check that out
15:12:11 <dons> the desugaring for let-bindings is described on the ghc wiki.
15:12:21 <mmorrow> chrisdone: yeah, i saw that, it is nice. that's rad that (at least one so far) people are using kibro for cool stuff :)
15:12:25 <bos> is hsc2hs maybe supposed not to be run by hand any longer?
15:12:26 <chrisdone> I've used the `xml' lib. it is simple and easy
15:12:31 <Cale> > let f = undefined :: Int -> Int in f `seq` 5
15:12:33 <lambdabot>   * Exception: Prelude.undefined
15:12:36 <chrisdone> mmorrow: yeah, I wtf'd at first
15:12:44 <mmorrow> heh
15:14:37 <Cale> hmm
15:15:12 <djsiegel> ﻿seliopou, I'll check it out -- what I'm doing is very simple
15:15:15 <chrisdone> djsiegel: using Text.XML.Light.Proc, you can use `filterElements' to filter all elements of name "entry" like a piece of cake
15:15:22 <Cale> aha, that's interesting...
15:15:27 <dons> bos, kinda. cabal is easier for using hsc2hs
15:15:48 <bos> dons: i think i had a packaging bug.
15:15:50 <dons> bos, hm. but it should still be there.
15:15:56 <Cale> case undefined :: Int -> Int of x -> print "Hi!"  gets compiled into  print_rlv (GHC.Base.unpackCString# "Hi!")
15:16:00 <dons> it shouldn't have disappeared...
15:16:27 <bos> dons: the alternatives system wasn't setting it up properly
15:16:30 <Cale> hmm, what if we use the function...
15:16:34 <chrisdone> djsiegel: I can help if you have any problems
15:17:14 <bos> yikes!
15:17:20 <bos> hsc2hs: Main.hs:161:6-68: Irrefutable pattern failed for pattern (before, tpl : after)
15:17:40 <chrisdone> empty list‽
15:18:07 <bos> yes.
15:18:08 <mmorrow> chrisdone: haha, that reminds me...
15:18:12 <shepheb> anyone have a favorite introduction for someone unafraid of formal logic to get a taste of Lojban?
15:18:17 <mmorrow> ‽ "‽"
15:18:18 <lunabot>  "\8253"
15:18:30 <Cale> Okay, so it compiles any case expression whose scrutinee is of function type by inlining, and I suppose in core, case always forces WHNF.
15:18:40 <chrisdone> shepheb: why, yes... http://jbotcan.org/cllc
15:18:42 <lambdabot> Title: The Lojban Reference Grammar
15:18:45 <djsiegel> chrisdone, I feel very strange unpacking the Document after parsing. Is this normal?
15:18:51 <dons> mmorrow: heh
15:19:05 <djsiegel> I parse my xml to a Document, then unpack the root element and its contents... Seems very dirty.
15:19:05 <Cale> I guess that works. It means that 'case' in Core means something slightly different from 'case' in Haskell.
15:19:38 <augustss_> Cale: any case expression with just a variable pattern compiles to nothing.  it's not special for functions
15:19:55 <chrisdone> djsiegel: ah, when I said I could help I meant with the simple `xml' library :-P
15:19:58 <aivuk> hi everyone, I was trying to figure out why this program http://hpaste.org/10821 is so slow (compared with equivalent one made in C). The program is just 'calculating' pi with a simple montecarlo
15:20:04 <augustss_> case isn't strict
15:20:05 <chrisdone> mmorrow: haha
15:20:40 <Cale> augustss_: But in Core, case seems to be able to force the evaluation of something with function type. You need to write a bang pattern to get it to happen though.
15:20:52 <Cale> (that is, to get that Core to be generated in the first place)
15:21:04 <augustss_> Cale: case in Core and case in the surface language have different semantics
15:21:12 <djsiegel> ok! thanks chrisdone, I'll go check it out
15:21:13 <Cale> augustss_: yes, that's what I just found out :)
15:21:28 <Cale> augustss_: I'd naively expected them to be the same.
15:22:04 <augustss_> Cale: think both choices make good sense, even if it's a little confusing
15:24:39 <chrisdone> shepheb: are you aware there is a #lojban channel?
15:24:53 <bos> is the haddock in 6.10 supposed to replace the standalone haddock command?
15:25:00 <shepheb> chrisdone: yes
15:25:15 <chrisdone> je'e ;)
15:26:25 <shepheb> chrisdone: I don't know any yet, I just heard tell and was intrigued
15:26:46 <chrisdone> shepheb: okay
15:27:17 <shepheb> thanks for the link
15:27:57 <chrisdone> I am working on this lojban library for haskell: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/lojban (and the bot (lojbot) uses it) :D
15:27:57 <lambdabot> Title: HackageDB: lojban-0.1
15:28:17 <mmorrow> lojbot: help
15:28:53 <chrisdone> can't remember what prefix I set it to
15:28:56 <chrisdone> %help
15:28:56 <lojbot> commands: valsi (v, w), definition (d), translate (jt, t), grammar (jg, g), selma'o (s), ref, cll, lujvo, selrafsi (sr), jbobau (tavla), speak, mlismu, addfatci (add), more, help (h)
15:28:59 <chrisdone> ah
15:29:01 <mmorrow> %
15:29:10 <mmorrow> %speak
15:29:11 <lojbot> mi cu jijnu le du'u so'i boi da cu xamgu ma'a vau kei ku vau
15:29:11 <lojbot> [([jijnu1 (intuit-er(s)):] mi /I, me/) cu /is/does/ <<jijnu /intuit-ing/>> ([jijnu2 (intuited thing(s)):] le /the/ <du'u /fact that/ [([xamgu1 (good thing(s)):] so'i /many/ boi / / /(of)/ da /X/) cu /is/does/ <<xamgu /being good/>> ([xamgu2 (goodness beneficiary thing(s)):] ma'a /we with you/) vau /
15:29:12 <lojbot> /] kei / /> ku / /) vau / /]
15:29:13 <chrisdone> mmorrow: your bot is taking a zillion prefixes so I wasn't sure :P
15:29:39 <mmorrow> chrisdone: heh, let me know if you want the interrobang
15:31:14 <aivuk> Is possible to make a efficient monte carlo in haskell?
15:31:26 <chrisdone> ?faq Is possible to make a efficient monte carlo in haskell?
15:31:26 <dons> in haskell, than in other languages?
15:31:26 <lambdabot> The answer is: Yes! Haskell can do that.
15:31:28 <witkamp> Hey guys I am still having a parse problem on this case statement. http://hpaste.org/10818#a1
15:31:40 <dons> aivuk: i wrote a paper about this.
15:31:44 <witkamp> I fixed the tabs but I am still having problem
15:31:48 <witkamp> thanks
15:32:00 <dons> aivuk: http://www.cse.unsw.edu.au/~chak/papers/KCCSB07.html
15:32:03 <dons> ?faq
15:32:03 <lambdabot> Title: Research Papers of Manuel Chakravarty
15:32:04 <lambdabot> The answer is: Yes! Haskell can do that.
15:32:11 <chrisdone> :P
15:32:27 <mmorrow> chrisdone: lunabot responds to `elem` ",]♪♫"
15:32:48 <SamB_XP> but ... for some reason, not to o/`
15:33:11 <aivuk> Ok, I will read the paper, thanks dons
15:33:46 <chrisdone> mmorrow: ah okay. /me warns lojbot responds to hailing words. test: ma dansu doi lojbot
15:33:47 <lojbot> dansu fa tu
15:33:48 <jeffz> ?faq can Haskell make my functions look like Elephants
15:33:49 <lambdabot> The answer is: Yes! Haskell can do that.
15:33:50 <mmorrow> SamB_XP: um, is "o/`" meant to be read literally, or does it stand for some char?
15:34:03 <SamB_XP> mmorrow: it is the ascii art for musical note
15:34:05 <chrisdone> I thought it was a salute
15:34:10 <mmorrow> ma
15:34:17 <SamB_XP> isn't it?
15:34:25 <mmorrow>  ma dansu doi lojbot
15:34:26 <lojbot> dansu fa jy. boi
15:34:35 <mmorrow>  ma dansu doi lojbot
15:34:35 <lojbot> ti cu dansu
15:34:42 <mmorrow> %help
15:34:43 <lojbot> commands: valsi (v, w), definition (d), translate (jt, t), grammar (jg, g), selma'o (s), ref, cll, lujvo, selrafsi (sr), jbobau (tavla), speak, mlismu, addfatci (add), more, help (h)
15:34:57 <chrisdone> you're saying “who dances?”, it just said “this dances”
15:34:58 <mmorrow> %translate dansu fa jy. boi
15:34:58 <lojbot> [<<dansu /danc-ing/>> ([dansu1 (dance-r(s)):] fa / / jy /j/ boi / /)]
15:35:09 <mmorrow> chrisdone: ha
15:35:12 <chrisdone> jy is a name
15:35:19 <mmorrow> %translate ti cu dansu
15:35:20 <lojbot> [([dansu1 (dance-r(s)):] ti /this here/) cu /is/does/ <<dansu /danc-ing/>>]
15:35:28 <mmorrow> %translate boi
15:35:28 <lojbot> parse error
15:35:44 <chrisdone> boi ends the name
15:35:49 <mmorrow> ah
15:35:53 <chrisdone> %w boi
15:35:53 <lojbot> cmavo {boi}, of selma'o BOI, glossing to "end number or lerfu": elidable terminator: terminate numeral or letteral string. .. 1 more result
15:36:37 <SamB_XP> %w hai
15:36:38 <lojbot> no results for: hai
15:36:53 <SamB_XP> @all-dict eated
15:36:54 <lambdabot> No match for "eated".
15:36:57 <SamB_XP> @all-dict hai
15:36:58 <lambdabot> No match for "hai".
15:37:00 <mmorrow> SamB_XP: oh, i see
15:37:05 <chrisdone> zasti pei doi lojbot
15:37:05 <lojbot> .e'a le pensi cu zasti
15:37:10 <SamB_XP> Cale: you need some more dictionaries ...
15:37:21 <chrisdone> “the thinker exists”
15:37:29 <SamB_XP> you need a dictionary of lolcat words ;-P
15:37:35 <chrisdone> hehe
15:37:52 <Cale> Preferably with lolcat definitions of them :)
15:38:05 <dons>  /win 37
15:38:18 <mmorrow> the line "but i eated it" makes me laugh whenever i think about it
15:38:20 <chrisdone> 37 channels ..
15:38:25 <chrisdone> mmorrow: haha, me too
15:38:37 <SamB_XP> mmorrow: I made you a test case ...
15:38:42 <mmorrow> haha
15:38:52 <chrisdone> <:³
15:39:17 * SamB_XP refers to one of the most recent lambda"cat"s
15:39:56 <mmorrow> SamB_XP: yeah, that picture is what i see now whenever i think of "i eated it" now, which makes me laugh even harder
15:40:14 <mmorrow> that beady rodent eye
15:41:21 <chrisdone> I liked this one http://jcsu.jesus.cam.ac.uk/~csr21/lolpg.jpg
15:41:35 <Cale> aha
15:41:45 <Cale> That's funny :)
15:42:00 <shepheb> http://img524.imageshack.us/my.php?image=wtfhw3.jpg
15:45:54 <mattrepl> is there a set of syntax rules for denoting algebraic data types and typed functions in a neutral manner?  i.e., for use in a paper
15:46:15 <mattrepl> sorry, I realize this is #haskell...
15:49:39 <SamB_XP> mattrepl: what, glorified Haskell syntax isn't good enough for you ?
15:49:43 <dons> in a neutral manner?
15:49:54 <dons> just use haskell pseudocode?
15:50:05 <SamB_XP> why not just use Haskell ?
15:50:15 <SamB_XP> or perhaps slightly pretified Haskell
15:50:22 <dons> data Tree a = Empty | Node a (Tree a) (Tree a) -- ADT
15:50:37 <dons> size :: Tree a -> Integer -- typed functions
15:50:39 <dons> looks good to me
15:50:49 <bos> whoa, cabal-install's prerequisites don't build under ghc 6.10
15:50:50 <SamB_XP> hmm, come to think of it, you might want to use GADT-style syntax
15:51:00 <dons> which ones, bos?
15:51:00 <mattrepl> no, Haskell is good enough, just wanted to keep it language agnostic
15:51:05 <bos> dons: HTTP
15:51:11 <dons> how does it fail?
15:51:20 <bos> dons: "Class `Exception' used as a type"
15:51:22 <dons> note that cabal-install itself is currently useless with 6.10.x
15:51:28 <dons> ah. it needs base-3.
15:51:30 <bos> it is?
15:51:32 <dons> not base-4
15:51:37 <SamB_XP> mattrepl: using a language is usually a better bet ;-)
15:51:41 <bos> crumbly bums.
15:51:44 <dons> yes, due to the inability to resolve deps on 'base' that really mean base-3
15:51:57 <dons> we're trying to tackle this now in #ghc
15:52:05 <dons> and duncan's sleeping on my couch till he solves it. :)
15:52:08 <mattrepl> SamB_XP:  considering the alternatives I've seen so far, I agree  =)
15:54:01 <pheaver> in Cabal, is there an easy way to specify what the default prefix should be, either in the .cabal or the Setup.hs file?  I'm having to write a custom confHook right now.
15:54:26 <newsham> wow, while most computer programs use base-2, haskell is now relying on base-4
15:54:42 <SamB_XP> newsham: that's nuthin'
15:54:46 <SamB_XP> Coq uses base-1
15:57:09 <bos> pheaver: yes, in .cabal/config
15:57:57 <pheaver> ah, but I want this to be for a specific package
15:58:07 <pheaver> not my user
15:58:17 <dcoutts> pheaver: the .cabal or Setup.hs is the wrong place for such a default. It it the user doing the install not the person making the package that gets to decide where a package should go.
15:58:44 <dcoutts> pheaver: on the command line you can use the --prefix flag and the other similar flags like ./configure uses
15:59:01 <pheaver> ah, that's not what i want
15:59:33 <pheaver> as the writer of the package, i want to specify what the default prefix is when the user doesn't use the --prefix flag
16:00:00 <dcoutts> pheaver: I see, well that's not supported
16:00:10 <pheaver> heh, ok :)
16:00:15 <dcoutts> pheaver: it's the package manager and the user that decide that default
16:00:21 <dcoutts> not the package author
16:00:28 <pheaver> well, shucks
16:00:39 <pheaver> guess i'll stick with the hackish way that I am doing it now
16:00:41 <dcoutts> pheaver: why would you want to set a default ooi?
16:01:18 <pheaver> well, we prefer that our package be installed to a specific location by default
16:01:39 <dcoutts> pheaver: but it works to install anywhere?
16:02:14 <pheaver> well
16:02:26 <pheaver> it really should be installed to a prefix that isn't shared
16:02:37 <pheaver> like /opt/package instead of /usr/local
16:02:42 <dcoutts> why is that?
16:02:52 <pheaver> because we assume that it is, heh
16:03:33 <pheaver> (this is Cryptol I'm talking about here)
16:03:59 <dons> pheaver: maybe discuss in person then? :)
16:04:00 <pheaver> we prefer to install to /opt/<package>-<version>
16:04:14 <pheaver> :)
16:04:15 <dons> ?users
16:04:15 <lambdabot> Maximum users seen in #haskell: 515, currently: 482 (93.6%), active: 16 (3.3%)
16:10:49 * lispy wonders where is the sweet spot between a comfy couch and dcoutts solving the problem quickly
16:11:19 <SamB_XP> lispy: eh?
16:11:38 <lispy> 15:50 <dons> and duncan's sleeping on my couch till he solves it. :)
16:12:09 <SamB_XP> dons: and where does he usually sleep?
16:19:21 <mmorrow> > let dft xs = let i = 0 :+ 1 ; fi = fromIntegral ; go len k xs = sum . flip fmap [0..len-1] $ \n -> (xs!!n) * exp (negate(2*pi*i*fi n*fi k)/fi len) in let len = length xs in zipWith (go len) [0..len-1] (repeat xs) in dft (fmap fromIntegral [0..4])
16:19:22 <lambdabot>   [10.0 :+ 0.0,(-2.5000000000000018) :+ 3.4409548011779325,(-2.49999999999999...
16:19:33 <mmorrow> @let dft xs = let i = 0 :+ 1 ; fi = fromIntegral ; go len k xs = sum . flip fmap [0..len-1] $ \n -> (xs!!n) * exp (negate(2*pi*i*fi n*fi k)/fi len) in let len = length xs in zipWith (go len) [0..len-1] (repeat xs)
16:19:34 <lambdabot>  Defined.
16:19:45 <mmorrow> > dft (fmap fromIntegral [0..4])
16:19:47 <lambdabot>   [10.0 :+ 0.0,(-2.5000000000000018) :+ 3.4409548011779325,(-2.49999999999999...
16:20:01 <mmorrow> > dft (fmap fromIntegral [0..4]) :: Complex CReal
16:20:02 <lambdabot>   Couldn't match expected type `Complex CReal'
16:20:12 <mmorrow> > dft (fmap fromIntegral [0..4]) :: [Complex CReal]
16:20:27 <lambdabot>   thread killed
16:20:50 <mmorrow> > dft (fmap fromIntegral [0..4]) :: [Complex Double]
16:20:52 <lambdabot>   [10.0 :+ 0.0,(-2.5000000000000018) :+ 3.4409548011779325,(-2.49999999999999...
16:20:56 <mmorrow> > dft (fmap fromIntegral [0..1000]) :: [Complex Double]
16:20:58 <lambdabot>   [500500.0 :+ 0.0,(-500.50000000014256) :+ 159472.8885339027,(-500.500000000...
16:21:06 <mmorrow> > dft (fmap fromIntegral [0..10000000]) :: [Complex Double]
16:21:21 <lambdabot>   thread killed
16:21:23 <ziman> ambitious :)
16:21:29 <mmorrow> hehe
16:22:48 <mmorrow> ah dang
16:23:18 <mmorrow> @let dft' xs = let i = 0 :+ 1 ; fi = fromIntegral ; go len k xs = foldl' (+) 0 . flip fmap [0..len-1] $ \n -> (xs!!n) * exp (negate(2*pi*i*fi n*fi k)/fi len) in let len = length xs in zipWith (go len) [0..len-1] (repeat xs)
16:23:21 <lambdabot>  Defined.
16:23:30 <mmorrow> > dft' (fmap fromIntegral [0..10000]) :: [Complex Double]
16:23:46 <lambdabot>   thread killed
16:23:52 <mmorrow> > dft' (fmap fromIntegral [0..2000]) :: [Complex Double]
16:23:54 <lambdabot>   [2001000.0 :+ 0.0,(-1000.4999999990739) :+ 637256.0276960303,(-1000.4999999...
16:26:19 <bjrn> Can anyone here think of a project with a higher importance-to-fun ratio than time zone libraries? That got to be the single most boring project anyone could ever work on. We as programmers usually take this functionality for granted tho. Makes you feel indebted :)
16:26:35 <bos> character set conversion.
16:26:49 <bjrn> Ah, that's a good one.
16:26:52 <bos> even more important, but less rewarding, while also harder.
16:27:43 <shepheb> I think character sets win importance*pain:fun
16:28:21 <dons> charsets are the bomb.
16:28:23 <pjdelport> unicode rendering
16:28:35 <bos> speaking of which:
16:28:38 <bos> @seen sioraiocht
16:28:39 <lambdabot> I saw sioraiocht leaving #haskell.es, #haskell.de, #haskell-blah and #haskell 1m 3d 3h 24m 28s ago, and .
16:28:39 <pjdelport> to go with character sets
16:28:55 <bos> dcoutts: what's sioraiocht's email addy?
16:29:08 <bos> i can't remember his actual name, so i can't google for it.
16:29:32 <dons> bos, dcoutts' student?
16:29:41 <pjdelport> maintaining mission-critical COBOL apps, to go for easy
16:29:54 <bos> dons: yes
16:29:55 <dcoutts> bos: Tom Harper
16:30:02 <bos> ah yes, thanks.
16:39:42 <Armored_Azrael1> Hey, I have a question about the operation of mfix in the list monad
16:40:26 <Armored_Azrael1> > map (take 10) (take 10 $ mfix (\x -> ['a' : x, 'b' : x]))
16:40:27 <lambdabot>   ["aaaaaaaaaa","bbbbbbbbbb"]
16:40:50 <ivanm> dcoutts: you have a student? I thought _you_ were the student :s
16:41:10 <SamB_XP> ivanm: they let students have students these days
16:41:22 <ivanm> O RLY?
16:41:38 <Armored_Azrael1> When I did what I believed to be mfix on paper, I get a far different result--at the very least that it there should be an infinite list of infinite strings here.
16:41:41 <SamB_XP> YS, RLY!
16:41:46 <ivanm> heh
16:41:48 <dcoutts> ivanm: I was supervising an MSc project, though officially my supervisor was his supervisor, I did all the work :-)
16:42:13 <Armored_Azrael1> I assumed the way it worked was basically that you just apply the monadic action, apply monadic join, and repeat infinitely. Is this not what occurs?
16:42:25 <ivanm> dcoutts: ahhhhh
16:42:26 <dcoutts> ivanm: well, of course Tom did all the work really, I just chatted to him a lot and talked about core code and optimization
16:42:38 <ivanm> free student labour? :p
16:42:50 <dcoutts> right, he built a useful unicode string lib
16:42:58 <dcoutts> which we should get published soon
16:48:59 <retrohscoder> where is a good place to learn how to use the HGL library? I've tried searching google, but I'm unable to locate anything really informative.
16:50:03 <SamB_XP> retrohscoder: ... why'd you want to ?
16:51:31 <retrohscoder> is there an alternative graphics library that I am unaware of?
16:52:12 <SamB_XP> what sort of graphics do you seek?
16:52:13 <byorgey> retrohscoder: there are lots.  What kind of graphics do you want?
16:52:20 <dons> i'd recommend gtk2hs.
16:52:39 <byorgey> yes, the Cairo library bundled with gtk2hs is very nice.
16:52:42 <SamB_XP> or perhaps hOpenGL is what you want ?
16:52:49 <retrohscoder> I'm looking to make a simple retro 2D game
16:53:04 <SamB_XP> HSDL ?
16:53:19 <retrohscoder> There is an SDL binding for haskell?
16:53:49 <Apocalisp> I notice that HFoldr is mentioned in the HList paper, but it's not in the hackage library. Do you know if HFoldr is new or deprecated?
16:53:54 <SamB_XP> isn't there ?
16:54:20 * retrohscoder googles
16:56:09 <bos> most oleg code is not on hackage.
16:56:12 <bos> alas.
16:56:28 <dons> well, we know he knows about hackage now.
16:57:27 <Apocalisp> yay!
16:57:32 <retrohscoder> interesting
16:59:16 <Apocalisp> http://darcs.haskell.org/HList/
16:59:17 <lambdabot> Title: Index of /HList
16:59:19 <Apocalisp> That's more like it
16:59:23 <retrohscoder> I have a question that I can't seem to find an answer to. I know haskell does not have loops per-say, and that it uses recursion. However, I am at a loss as to how to implement certain things in that manner. I come from a C background, and I'd like to know
16:59:46 <SamB_XP> like to know what?
17:00:07 <Apocalisp> retrohscoder: You've definitely come to the right place :)
17:00:13 <retrohscoder> how one would implement something as simple as: object* objects[num_objects]; for (int i = 0; i < num_objects; i++)objects[i]->update();
17:00:45 <dons> forM_ [0 .. num_objects-1] (\i -> update (objects !! i))
17:00:49 <sjanssen> retrohscoder: firstly, we probably wouldn't modify the objects themselves, we'd make a new list of objects
17:00:55 <sjanssen> dons: yuck
17:00:55 <pjdelport> retrohscoder: in Haskell, lists often serve as "reified" loops
17:01:02 <dons> control you use either explicit recursion, or recursion combinators, like forM_, mapM_, fold, map, filter.
17:01:09 <sjanssen> forM_ objects update
17:01:26 <pjdelport> there are various ways to go about it, as you can probably tell from the above :)
17:01:27 <SamB_XP> mapM_ update objects
17:01:36 <sjanssen> SamB_XP wins
17:01:41 <retrohscoder> hmm I'm going to have to read more on the haskell docs :D ..anything better than the haskell.org pages?
17:01:48 <dons> [ update o | o <- objects ]
17:01:58 <SamB_XP> dons: what?
17:01:58 <byorgey> > map (+1) [1,3,6,8]
17:02:00 <lambdabot>   [2,4,7,9]
17:02:02 <dons> retrohscoder: a good book? 'Programming in Haskell' is one.
17:02:05 <Cale> sequence ;)
17:02:23 <FunctorSalad> it was mentioned here recently, but what's the command to trace evaluation order again?
17:02:24 <povman> the wikibook is awesome
17:02:27 <retrohscoder> dons: you don't have the ISBN by any chance do you?
17:02:32 <Philonous> @src forM_
17:02:32 <lambdabot> forM_ = flip mapM_
17:02:32 <pjdelport> retrohscoder: is your question more about looping, or more about side effects?
17:02:42 <Cale> FunctorSalad: You mean :trace ?
17:02:45 <SamB_XP> @amazon "Programming in Haskell"
17:02:46 <pjdelport> the two have different treatment
17:02:46 <lambdabot> Unknown command, try @list
17:02:46 <retrohscoder> pjdelport: looping
17:02:47 <sjanssen> dons isn't recommending Real World Haskell?
17:02:49 <Philonous> @src mapM:
17:02:49 <lambdabot> Source not found. :(
17:02:51 <Philonous> @src mapM_
17:02:52 <lambdabot> mapM_ f as = sequence_ (map f as)
17:02:52 <Cale> FunctorSalad: Or are you referring to Debug.Trace.trace ?
17:02:52 <FunctorSalad> Cale: that only seems to work with breakpoints
17:02:57 <SamB_XP> sjanssen: isn't that still in beta ?
17:02:58 <FunctorSalad> (ghci :trace)
17:03:07 <pjdelport> retrohscoder: ok, all the *M and *M_ functions above are more about dealing with side effects, than looping
17:03:14 <Philonous> @src sequence_
17:03:15 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
17:03:15 <Cale> FunctorSalad: :step?
17:03:16 <byorgey> retrohscoder: to "loop" over a list, you can use 'map' like in my example above
17:03:21 <povman> retrohscoder: http://en.wikibooks.org/wiki/Haskell
17:03:23 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
17:03:24 <byorgey> map update list
17:03:27 <pjdelport> (or other non-side-effect monads too, but you don't have to worry about that yet)
17:03:36 <byorgey> > map (*2) [1..4]
17:03:36 <sjanssen> SamB_XP: I've heard it's done
17:03:37 <lambdabot>   [2,4,6,8]
17:03:42 <SamB_XP> sjanssen: oh?
17:03:48 <pjdelport> @src map
17:03:48 <lambdabot> map _ []     = []
17:03:48 <lambdabot> map f (x:xs) = f x : map f xs
17:03:52 <retrohscoder> pjdelport: would you mind taking a moment to explain things in a private chat? the scrolling is making it a little difficult to keep up.
17:04:00 <SamB_XP> dons: is this true ? is it in gamma now ?
17:04:15 <FunctorSalad> Cale: yeah but then I'll have to do :step a million times... I thought there was a way to just let the program run with tracing
17:04:18 <pjdelport> retrohscoder: would it help if i highlight everything? :)
17:04:28 <Cale> FunctorSalad: what would it do?
17:04:37 <dons> sjanssen: in this case, since the question is about recursion, PiH is likely a better choice?
17:04:41 <Cale> FunctorSalad: print out the current context over and over?
17:04:58 <FunctorSalad> Cale: I'm not sure ;-) that would probably be overly verbose
17:04:58 <sjanssen> dons: oh, maybe.  I guess I don't know much about either book :)
17:05:00 <retrohscoder> pjdelport: hmm, just had a thought. let me enable logging, then I can re-read it all later.
17:05:06 <pjdelport> retrohscoder: the source code for map above shows how you would idiomatically implement looping, using recursion
17:05:24 <byorgey> retrohscoder: this channel is already logged, actually =)
17:05:26 <FunctorSalad> Cale: maybe I just need more debug messages
17:05:39 <byorgey> http://tunes.org/~nef/logs/haskell/
17:05:47 <lambdabot> Title: Index of /~nef/logs/haskell
17:05:50 <Cale> retrohscoder: Perhaps #haskell-overflow?
17:06:03 <Apocalisp> ?src map
17:06:03 <lambdabot> map _ []     = []
17:06:03 <lambdabot> map f (x:xs) = f x : map f xs
17:06:05 <FunctorSalad> (it's my own fault for trying to make an evaluation-order-sensitive loop out of IOArrows ;-))
17:06:10 <Cale> retrohscoder: (it's good to use when there's too much noise)
17:08:55 <mdmkolbe> While at the Haskell Symposium it was mentioned that someone is working on a new feature to make writting .cabal files easier.  Is there a name for that feature?  Is that feature in any repositories that I can use to test it?
17:08:56 <FunctorSalad> this seems to call "producer" repeatedly before ever evaluating more than the first line (debug message) of "performer" http://hpaste.org/10824
17:10:05 <FunctorSalad> maybe it's a stupid question, I'm new to IO details :(
17:10:53 <FunctorSalad> hmm wait, I should also check the particular function I pass to it
17:11:45 <FunctorSalad> (seems to be buggy)
17:12:51 <Philonous> Btw. why is it called mapM_ when it behaves more like a fold than a map?
17:13:27 <mdmkolbe> @type mapM_
17:13:28 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
17:13:32 <mdmkolbe> @type mapM
17:13:33 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
17:13:37 <sjanssen> @src mapM
17:13:38 <lambdabot> mapM f as = sequence (map f as)
17:13:42 <sjanssen> @src mapM_
17:13:42 <lambdabot> mapM_ f as = sequence_ (map f as)
17:13:47 <byorgey> @src sequence
17:13:47 <lambdabot> sequence []     = return []
17:13:48 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:13:48 <lambdabot> --OR
17:13:48 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
17:13:49 <sjanssen> Philonous: that is why
17:13:52 <rwbarton> @src replicateM
17:13:52 <lambdabot> replicateM n x = sequence (replicate n x)
17:14:16 <byorgey> Philonous: it's actually both: a map followed by 'sequence', which is a fold
17:14:18 <sjanssen> Philonous: the general pattern is listfunctionM = sequence . listfunction
17:14:34 <FunctorSalad> sorry, problem was elsewhere
17:14:34 <sjanssen> Philonous: and listfunctionM_ = sequence_ . listfunction
17:14:46 <SamB_XP> sjanssen: oh?
17:15:00 <Philonous> Ah ok, so the name isn't really referring to the behaviour of the function but rather it's definition
17:15:01 <SamB_XP> :t let lf = sequence.lf in lf
17:15:02 <lambdabot> forall a a1. a -> [[a1]]
17:15:14 <SamB_XP> oh ... kay ...
17:15:27 <SamB_XP> sjanssen: surprisingly, that's actually well-typed ;-P
17:15:37 <SamB_XP> :t let lf = sequence_.lf in lf
17:15:38 <byorgey> Philonous: it *is* referring to the behavior.  mapM_ behaves very much like a map.  it just happens to have a fold afterwards to get one monadic value.
17:15:39 <lambdabot>     Couldn't match expected type `[a]' against inferred type `()'
17:15:39 <lambdabot>       Expected type: a1 -> [[a]]
17:15:39 <lambdabot>       Inferred type: a1 -> [()]
17:15:46 <SamB_XP> ... but THAT isn't ;-P
17:16:04 <sjanssen> SamB_XP: note that the LHS ends in M_ and the RHS doesn't
17:16:43 <sjanssen> Philonous: plus, why distinguish between maps and folds -- map is a fold!
17:16:53 <pjdelport> Philonous: also, you could say that mapM_ is really a fold only in the same sense that map is really a fold
17:16:56 <SamB_XP> ph
17:16:56 <SamB_XP> oh
17:17:03 <mdmkolbe> At the Haskell Symposium it was mentioned that someone is working on a new feature of Cabal to make writting .cabal files easier by prompting for the essential fields.  Is there a name for that feature?  Is that feature in any repositories that I can use to test it?
17:17:09 <SamB_XP> nM is a bit hard to spot in this font, I guess?
17:17:18 <sjanssen> mdmkolbe: clearly nobody around knows
17:17:28 <Philonous> Ok, that makes sense.
17:17:32 <lispy> no, no map is a zip
17:17:50 <lispy> map = zipWith1
17:17:59 <byorgey> heh
17:18:00 <sjanssen> zipWith0
17:18:01 <pjdelport> map f = foldr ((:) . f) []
17:18:18 <sjanssen> nah, I guess zipWith0 = repeat
17:18:24 <SamB_XP> sjanssen: that's ... uh ... not definable because it's impossible to figure out how long to make the list
17:18:35 <mdmkolbe> @type repeat
17:18:36 <lambdabot> forall a. a -> [a]
17:18:55 <byorgey> SamB_XP: maybe impossible for *you*.  I figured out that it's supposed to have length 17.
17:18:56 <sjanssen> SamB_XP: see the ZipList applicative functor
17:19:05 * mdmkolbe checks scheme's map (which is zip) for the zero case
17:19:23 <SamB_XP> mdmkolbe: you mean zipWith
17:19:34 <pjdelport> mdmkolbe: it's an error
17:19:40 <mdmkolbe> SamB_XP: yeah
17:19:53 <SamB_XP> I bets it complains that your value isn't a function ;-P
17:19:53 <mdmkolbe> pjdelport: you beat me to it ;-)
17:20:21 <sjanssen> it's an error because Scheme isn't a lazy language
17:20:45 <sjanssen> > pure 1 :: ZipList Int
17:20:47 <lambdabot>       Ambiguous occurrence `pure'
17:20:47 <lambdabot>      It could refer to either `Control.Appl...
17:20:52 <sjanssen> wut?
17:21:01 <sjanssen> > Control.Applicative.pure 1 :: ZipList Int
17:21:02 <lambdabot>       No instance for (Show (ZipList Int))
17:21:02 <lambdabot>        arising from a use of `show...
17:21:06 <sjanssen> GRR
17:21:17 <rwbarton> @src ZipList
17:21:18 <lambdabot> Source not found. Just try something else.
17:21:18 <mdmkolbe> SamB_XP: It's an incorrect number of arguments to "map" error in Chez and Ikarus
17:21:20 <pjdelport> sjanssen: fromZipList
17:21:20 <sjanssen> > getZipList $ Control.Applicative.pure 1
17:21:22 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:21:26 <pjdelport> oh, get, sorry
17:21:35 <SamB_XP> mdmkolbe: eh, ikarus drowned didn't it ?
17:22:38 <sjanssen> Cale: do you know why there are multiple pures in scope?
17:22:47 <sjanssen> @hoogle pure
17:22:48 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
17:22:48 <lambdabot> Control.Arrow pure :: Arrow a => (b -> c) -> a b c
17:22:48 <lambdabot> package pureMD5
17:22:58 <sjanssen> ah yes, Arrow
17:23:24 <FunctorSalad> arr!
17:23:31 <FunctorSalad> @hoogle arr
17:23:32 <lambdabot> Control.Arrow arr :: Arrow a => (b -> c) -> a b c
17:23:32 <lambdabot> module Data.Array
17:23:32 <lambdabot> module Foreign.Marshal.Array
17:23:38 <Pseudonym> Speaking of which, is anyone working on arrow calculus syntax in Haskell?
17:23:53 <sjanssen> @let pure' x = Control.Applicative.pure x
17:23:54 <lambdabot>  Defined.
17:23:55 * SamB_XP almost saw Data.Matey
17:24:20 <Pseudonym> Data.Dog.Scurvy
17:24:23 <mdmkolbe> SamB_XP: "he" drowned, but "it" hasn't (yet)
17:24:35 <FunctorSalad> Pseudonym: diagrams might be a good syntax for arrows
17:25:01 <Pseudonym> FunctorSalad: I'm referring specifically to Wadler's arrow calculus.
17:25:08 <FunctorSalad> Pseudonym: ah
17:25:29 <Pseudonym> It seems like the "right thing" because the axioms are so easy to understand.
17:25:39 <Pseudonym> Unlike the Hughes axioms.
17:26:05 <dons> i like all the attention for the mp3 decoder, with people saying things like 'oh, i'll try implementing this on the weekend'
17:26:40 <Cale> sjanssen: Because the GHC API apparently has no support for importing specific lists of things, or if it does, hint doesn't expose that support.
17:26:55 <sjanssen> Cale: ah yes, right
17:27:48 <mdmkolbe> Pseudonym: Wadler's Arrow Calculus is the same as regular arrows but recast as a direct calculus?
17:28:11 <Pseudonym> Yes.
17:28:18 <Pseudonym> As an extension to lambda calculus.
17:28:25 <mdmkolbe> Pseudonym: cool
17:30:22 <Pseudonym> http://homepages.inf.ed.ac.uk/wadler/papers/arrows/arrows.pdf
17:30:36 <lambdabot> Title: The Arrow Calculus (Functional Pearl)
17:31:05 <dons> lispy: http://www.galois.com/blog/2008/09/30/bluespec-systemverilog/
17:31:06 <lambdabot> Title: Galois › Blog › Blog » Bluespec SystemVerilog
17:32:48 <lispy> dons: ya ya, I finally got the announcement on pdxfunc but I forgot to say thanks :)
17:32:57 <lispy> dons: I'll be there or I'll be []
17:33:28 <dons> heh
17:40:39 <sjanssen> I'll be there or I'll be mempty?
17:40:45 <sjanssen> mzero?
17:40:58 <sjanssen> fail ""?
17:41:39 <povman> undefined
17:42:57 <sjanssen> [] /= undefined
17:43:15 <shrughes> Be there or be [].
17:43:27 <shrughes> oh, that's the source of this confusion
17:43:48 <sjanssen> Be there, or be the empty list.
17:45:06 <shrughes> Be there, or be the list type constructor.
17:45:51 <Olathe> Be there or be two.
17:45:53 <ivanm> Be there, or I'll be '() ? :p
17:46:13 <sjanssen> be there or be □
17:46:16 <ivanm> thus avoiding the whole nil vs null issue...
17:46:40 <pjdelport> Be there, or be (^2)
17:46:41 <lispy> lisp :: Either There ()
17:46:43 <sjanssen> be there or be a particular sort of Functor
17:46:43 <Olathe> nil, null, Nathing
17:46:47 <shrughes> Be there, or be (quote ())
17:46:54 <Olathe> > quote ()
17:46:55 <lambdabot>   Not in scope: `quote'
17:47:26 <shrughes> Be there, or be join (*)
17:47:43 <lispy> lispy where | where == there = Right there; | otherwise = []
17:47:47 <shapr> @yow !
17:47:48 <lambdabot> Yow!  Are we laid back yet?
17:47:51 * shapr boings cheerfully
17:47:54 <sjanssen> shrughes++
17:47:55 <shapr> hey!
17:48:00 <shapr> I just missed matt_estes, dang.
17:49:33 <Olathe> Be there or be class List; instance List Empty; undefined :: Empty
17:54:25 <byorgey> shapr!
17:56:14 * byorgey works furiously on a long overdue HWN
17:57:38 <lispy> ?quote OlegFact
17:57:39 <lambdabot> No quotes match. My pet ferret can type better than you!
17:57:44 <lispy> ?quote Oleg.Fact
17:57:45 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
17:57:51 <lispy> I thought gwern said that would work
17:58:14 <lispy> ?quote OlegFacts
17:58:14 <lambdabot> OlegFacts says: GHC doesn't have a type checker. It emails your types to Oleg for checking.
17:58:35 <byorgey> heheh, I hadn't seen that one before =)
17:58:48 <pjdelport> ?quote OlegFibs
17:58:49 <lambdabot> No quotes match. Just try something else.
17:59:00 <byorgey> ?quote OlegFacts
17:59:00 <lambdabot> OlegFacts says: GHC doesn't have a type checker. It emails your types to Oleg for checking.
17:59:03 <lispy> I guess we only have 2 facts
17:59:10 <byorgey> boo =(
17:59:17 <dons> how do i add an oleg fact?
17:59:42 <byorgey> just @remember OlegFacts, I guess
17:59:44 <dons> ?remember OlegFacts Left fold enumerators are simpler than lazy IO
17:59:45 <lambdabot> Okay.
17:59:50 <byorgey> @fact oleg
17:59:50 <lambdabot> I know nothing about oleg
17:59:55 <byorgey> @fact Oleg
17:59:55 <lambdabot> I know nothing about oleg
18:00:59 <pjdelport> @remember OlegFacts Type wizardry is measured in milli-Olegs.
18:01:00 <lambdabot> Okay.
18:01:58 <shapr> hiya byorgey!
18:02:11 <byorgey> hey shapr!  how goes it?
18:02:46 <shapr> Life is good! How's yours?
18:02:58 <pjdelport> @remember OlegFacts Oleg can evaluate bottom.  With his fists.
18:02:59 <lambdabot> I will remember.
18:03:16 <byorgey> shapr: mine too, grad school is a lot of fun =)
18:03:55 <ac> humasect: you around?
18:04:28 * lispy wishes he could agree with shapr and byorgey today but is all out of steam at the moment
18:04:47 <byorgey> lispy: sorry to hear that
18:05:08 <humasect> yes ac =)
18:05:17 <ac> humasect: when do I get to run Novapilot?
18:06:35 <humasect> hehehe =) as soon as the procedures/synths/mutators become finished up today or tommorrow (was supposed to be yesterday=)
18:06:41 <humasect> what is your system again?
18:06:52 <ac> humasect: ubuntu x86
18:06:53 <unmarshal> anyone know where i can find process 1.0.1
18:06:57 <unmarshal> i noticed Pipe 2.0 requires it
18:06:59 <unmarshal> but cannot find it anywhere
18:07:12 <byorgey> unmarshal: it's not on Hackage?
18:07:17 <unmarshal> 1.0.0
18:07:18 <unmarshal> only
18:07:23 <byorgey> oh, I see
18:07:24 <humasect> ok ac hmm
18:07:25 <unmarshal> i'm a bit surprised
18:07:37 <unmarshal> tried to build Pipe with it and errored out
18:07:37 <byorgey> unmarshal: who wrote Pipe?
18:07:40 <unmarshal> so must be some dev version around
18:07:48 <unmarshal> Matti Niemenmaa
18:07:53 <unmarshal> i'll shoot him a mail
18:07:54 <unmarshal> just curious
18:07:56 <unmarshal> if anyone knew
18:08:00 <byorgey> yeah, that sounds like the best option
18:08:04 <unmarshal> yup :)
18:08:05 <unmarshal> thanks
18:08:47 <byorgey> retrohscoder: one point of possible confusion is that in the definition of foldr, f is a function which is prefix
18:08:54 <byorgey> er, sorry, wrong channel
18:10:21 <Axman6> ivanm: well... seems we got an excellent deal :D
18:11:09 <humasect> ac: various things have come up lately, as well as something large has come up; which basically comes down to perhaps necessitating the opening of the source completely, very very soon. hmm
18:15:55 <shapr> Dang, I missed matt AGAIN?
18:16:39 <lispy> humasect: such as accidentally using a library with a restrictive license?
18:16:50 <humasect> hehe nope, lispy =)
18:17:23 <mmorrow> just uploaded a pure-haskell fft implem to hackage if anyone's interested in such things http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pure-fft-0.1.0
18:17:25 <lambdabot> Title: HackageDB: pure-fft-0.1.0, http://tinyurl.com/3lsnqk
18:19:55 <bjrn> Nice one mmorrow!
18:19:58 <Axman6> mmorrow: how efficient is it?
18:20:03 <Axman6> just curious
18:20:24 <mmorrow> it does main = print . last . fft . fmap fromIntegral $ [0..2^16-1]
18:20:26 <mmorrow> in
18:20:33 <mmorrow> real    0m0.757s
18:20:33 <mmorrow> user    0m0.729s
18:20:33 <mmorrow> sys     0m0.019s
18:21:04 <mmorrow> whereas i killed the dft of [0..2^16-1] after 20 seconds
18:21:17 <Axman6> so... rather good then :P
18:21:28 <mmorrow> here's the code (nice and short :)) http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=71#a72
18:21:34 <Axman6> guessing laziness helps a lot there?
18:21:40 <Axman6> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=71#a72
18:22:04 <Axman6> whoops
18:22:05 <mmorrow> it's cool, if you do "fft . fmap fromIntegral $ [0..2^16-1]" in ghci, it'll immediately begin producing results, and printing them out
18:22:13 <Axman6> damn windows/putty -_-
18:22:57 <humasect> hm how come mmorrow , fmap ?
18:23:35 <byorgey> humasect: fmap for lists is just map
18:23:51 <mmorrow> laziness
18:24:45 <shapr> @users
18:24:46 <lambdabot> Maximum users seen in #haskell: 515, currently: 469 (91.1%), active: 15 (3.2%)
18:26:27 <mmorrow> bjrn: :)
18:27:18 <ivanm> Axman6: definitely!
18:32:24 <mmorrow> err, that it does main = print . last . fft . fmap fromIntegral $ [0..2^16-1] having a time of
18:32:38 <mmorrow> real    0m0.757s was because it didn't evaluate everything of course
18:34:13 <humasect> ac: how long will you be around for today ?
18:34:47 <mmorrow> i haven't had a chance to benchmark it yet, but that's on the todo list..
18:43:48 <Axman6> mmorrow: any chance you could explain what an FFT actually is? i remember asking my electro lecturer, and i forgot what his answer was...
18:47:19 <pjdelport> Axman6: Fast Fourier Transform
18:47:22 <Axman6> :t pairs
18:47:23 <lambdabot> Not in scope: `pairs'
18:48:12 <Axman6> pjdelport: that much i do know. i'm just not sure what the result of one is. i've done some fourier analysis, but not much (10 weeks of an el;ectro cource
18:48:49 <pjdelport> well, the Wikipedia articles are probably a start
18:49:09 <pjdelport> the result is basically a frequency spectrum
18:50:02 <lispy> it's also the fastest way I know of to do polynomial multiplication
18:50:34 <lispy> and since you can represent numbers as polynomials in their base, it's also the fastest way to do multiplication
18:55:51 <Axman6> :t unzip
18:55:52 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
18:56:09 <Axman6> @src unzip
18:56:09 <lambdabot> unzip = foldr (\(a,b) ~(as,bs) -> (a:as,b:bs)) ([],[])
18:58:27 <hackage> Uploaded to hackage: pure-fft 0.1.0
19:03:55 <mmorrow> here's a 4-liner in ghci to see the freq spectrum of a .wav file: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=73#a73
19:04:29 <humasect> cool
19:05:37 <shrughes> it uses Numeric.FFT, cheater :P
19:07:01 <mmorrow> Axman6: suppose you have a list of values [Double], maybe representing the volume of a sound at even intervals in time, or something analogous. so when you fourier transform that, it transforms that data from being parameterized by time (or whatever x is) to being in a sense parameterized frequency
19:10:29 <mmorrow> what that means is that the fourier transform takes a function and maps that to another function which is expressed in terms of a sum of other functions which are similar to e^(theta*i)
19:10:52 <mmorrow> err, clarifying
19:11:37 <mmorrow> what that means is that the fourier transform takes a function and expresses it in terms of a sum of functions which are similar to e^(theta*i)
19:12:53 <mmorrow> shrughes: heh, i just wrote that!
19:13:23 <mmorrow> shrughes: ok, so maybe "technically" more than four lines...
19:14:03 <mmorrow> shrughes: that Numeric.FFT: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=71
19:14:20 <shrughes> sire
19:14:22 <shrughes> nice*
19:14:28 <mmorrow> :)
19:16:51 <Axman6> mmorrow: so does it give you the phasors at various frequencies? or just the magnitude at different frequencies?
19:17:27 <solrize> woah, google.com is down?
19:17:58 <bd_> google.com is geohomed, even if it's down for you others will probably see it up... certainly it's up for me
19:18:17 <retrohscoder> google works for me here in Texas
19:20:25 <lispy> google can go down?
19:20:32 <mmorrow> Axman: so to get the magnitudes at the diff freqs, you take  (\z -> |z|/|z|^2) of each val
19:20:47 <mmorrow> (where z `elem` C)
19:21:47 <mdmkolbe> @seen dons
19:21:48 <lambdabot> dons is in #arch-haskell, #ghc, #darcs, #xmonad and #haskell. I last heard dons speak 1h 22m 3s ago.
19:23:35 <chrisdone> how can I find out where my ghc packages are installed? I'm trying to remove them
19:24:37 <thoughtpolice> chrisdone: can't you just do 'ghc-pkg unregister <pkg>'? or do you have to remote the actual files?
19:25:35 <thoughtpolice> chrisdone: if you have to remove the files do 'ghc-pkg describe <pkg>' and it'll give you all the relevant info i believe
19:26:16 <mmorrow> ah, i forgot to pad the wav data list out to a power of two, so you'll notice only the first 512 sample got considered in that plot...
19:27:08 <mmorrow> (but that also means that that's more than half of the data in the file, so the plot probably wouldn't change much)
19:28:42 <chrisdone> thoughtpolice: ah, thanks
19:33:10 <dcoutts> byorgey: excellent work on the HWN as usual
19:33:19 <byorgey> thanks dcoutts =)
19:34:25 <dcoutts> byorgey: you know that many academics and in-house professional Haskellers depend only on HWN to summarise haskell-cafe etc
19:34:49 <Liempt> Hi, I'm a very unexperienced programmer trying to wrap his head around pointfree programming, I was wondering if someone could give me a hand.
19:34:49 <byorgey> I've gathered as much!
19:35:09 <lispy> hey Liempt
19:35:13 <dcoutts> byorgey: because I've been told that reading haskell-cafe is like drinking from a fire hose
19:35:29 <lispy> Liempt: have you met lambdabot?  lambdabot is capable of converting normal stuff into point free form
19:35:29 <byorgey> hehe, it is indeed =)
19:35:31 <chrisdone> I suspect 90% of the people in here greatly enjoy discussing point free programming
19:35:48 <lispy> @pl \x xs -> x : xs
19:35:48 <lambdabot> (:)
19:35:50 <dcoutts> chrisdone: I prefer discussing pointless programming
19:36:35 <dons> i enjoy pointless programming discussions.
19:37:09 * lispy bites his tongue before making a comment about prog.reddit ;)
19:37:23 <byorgey> oops, too late
19:37:35 <vanLiempt> Hmm, it seems that I exploded.
19:37:37 <vanLiempt> Sorry about that.
19:37:41 <lispy> i turns out I can still type even with my tongue firmly between my teeth
19:37:52 <Liempt> lispy: Now, were you offering to help me before I exploded or was that just my imagination?
19:38:01 <lispy> Liempt: right
19:38:06 <lispy> @pl \x xs -> x : xs
19:38:07 <lambdabot> (:)
19:38:08 <byorgey> Liempt: but... we hadn't even *begun* discussing point-free programming!
19:38:08 <Liempt> Okay.
19:38:18 <lispy> Liempt: the point being that lambdabot can do pointless refactorings for you
19:38:25 <byorgey> you're supposed to wait a bit before exploding
19:38:35 <Liempt> Heh.
19:38:57 <Liempt> Lispy: Yeah, but I'd rather understand them so I can do them myself.
19:39:00 * mmorrow wipes the bits of brain of his /just/ drycleaned shirt. sigh.
19:39:07 <mmorrow> *off
19:39:23 <Liempt> @pl \x -> exp (-(x^2))
19:39:23 <lambdabot> exp . negate . (^ 2)
19:39:25 <lispy> Liempt: are you familiar with the lambda calculus?
19:39:33 <Liempt> Moderately.
19:39:43 <mmorrow> Liempt: i've learned many things from @pl
19:40:10 <chrisdone> why is it called “point free”? why not, say, “formal parameter free”?
19:40:16 <mmorrow> after a while, you start to pick up some of the patterns it's using
19:40:28 <lispy> Liempt: so are you familiar with this definition: (f . g) x = f (g x) ?
19:40:38 <pjdelport> chrisdone: the term comes from topology
19:40:43 <pjdelport> where variables are called points
19:40:44 <thoughtpolice> dcoutts: if -cafe is drinking from a firehose, lkml is something along the lines of trying to drink the pacific ocean.
19:40:49 <jbruce> http://en.wikipedia.org/wiki/Pointless_topology
19:40:52 <lambdabot> Title: Pointless topology - Wikipedia, the free encyclopedia
19:40:53 <chrisdone> pjdelport: oh, right. 'ow queer
19:41:55 <Cale> Does anyone here know a particularly nice treatment of the theory of matroids? Something particularly categorical would be nice.
19:42:16 <jbruce> anyone played with Language.C?
19:42:34 <chrisdone> jbruce: is that on hackage?
19:42:39 <lispy> The irony of point free definitions is that you remove points by adding dots.
19:42:50 <vanLiempt> That's actually really beginning to annoy me.
19:42:52 <vanLiempt> Sorry about that again.
19:42:54 <vanLiempt> I am indeed familiar with that definition.
19:42:57 <mib_w6mvmc> i am trying to write a recursive power function using 1 input any help
19:43:00 <mib_w6mvmc> i am a n00b
19:43:05 <mib_w6mvmc> take time with me
19:43:10 <Cale> mib_w6mvmc: Okay
19:43:26 <mib_w6mvmc> i know power n = n ^ n
19:43:34 <jbruce> chrisdone: yes
19:43:39 <Cale> mib_w6mvmc: Oh, that kind of power?
19:43:45 <Cale> mib_w6mvmc: Then aren't you done?
19:43:52 <mib_w6mvmc> no
19:44:02 <mib_w6mvmc> i want to write it recursivel
19:44:04 <mib_w6mvmc> y
19:44:09 <lispy> > let power n = power n ^ power n in power 2
19:44:11 <mmorrow> > let pow x n = (iterate (x*) x) !! n in pow 2 8
19:44:11 <lambdabot>   * Exception: stack overflow
19:44:12 <lambdabot>   512
19:44:23 <Liempt> I'm very familiar with pointless topologies and such.
19:44:23 <mmorrow> @src iterate
19:44:24 <lambdabot> iterate f x =  x : iterate f (f x)
19:44:29 <mib_w6mvmc> 1 input only
19:44:34 <Liempt> I'm aware of the basic premises of pointless programming.
19:44:41 <mib_w6mvmc> i know how to do it using 2
19:44:49 <mmorrow> mib_w6mvmc: what's the type sig for the function you want?
19:44:55 <lispy> ?p \f x -> x : iterate f (f x)
19:44:55 <lambdabot> Maybe you meant: palomer part paste ping pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-notices protontorpedo purge-notices . ? @
19:44:55 <lambdabot> v
19:45:01 <lispy> ?pl \f x -> x : iterate f (f x)
19:45:02 <lambdabot> ap (:) . ((.) =<< iterate)
19:45:02 <mib_w6mvmc> power :: Int -> Int
19:45:13 <rwbarton> mib_w6mvmc: there isn't a reasonable way to do it without writing something like  power n = power2 n n where power2 x y = <recursive definition you already know>
19:45:17 * lispy cowers in fear of lambdabot's response
19:45:20 <mmorrow> so you want power 5 ---> 5 ^ 5 ?
19:45:28 <Liempt> Lispy, I guess my question would be as follows: With a non-commutative function of some sort, how do you insert a value into an arbitrary spot?
19:45:34 <retrohscoder> hehe. an amusing statement. "<Liempt> I'm aware of the basic premises of pointless programming."
19:45:37 <teardrop> any maple people here? I need some help translating some basic haskell into maple
19:45:45 <Cale> mib_w6mvmc: I'm not sure what you mean... that function isn't recursive in any reasonable way. The exponentiation function of two parameters can be recursively defined in terms of multiplication.
19:45:48 <mib_w6mvmc> i was thinkin of using a where function and creat a helper
19:45:56 <Cale> mib_w6mvmc: You could do that.
19:46:06 <rwbarton> mib_w6mvmc: Yes, that's what I suggested above
19:46:07 <mmorrow> > let power n = foldl (*) n (replicate (n-1) n) in power 12
19:46:08 <mib_w6mvmc> how?
19:46:09 <lambdabot>   8916100448256
19:46:14 <lispy> ?pl \x y -> y + x
19:46:15 <lambdabot> (+)
19:46:18 <ivanm> teardrop: that's the first time I recall seeing someone asking how to turn Haskell into FOO, instead of the other way around
19:46:32 <ivanm> (or should it be s/FOO/BLUB/ :p )
19:46:32 <mib_w6mvmc> english please
19:46:33 <lispy> Liempt: oh, lambdabot is too smart.  But, flip is probably the answer you want
19:46:45 <Cale> mib_w6mvmc: pow x 0 = 1; pow x y = x * pow x (y-1)
19:46:56 <lispy> ?pl \xs f -> map f xs
19:46:57 <Cale> mib_w6mvmc: power n = pow n n
19:46:57 <lambdabot> flip map
19:47:04 <teardrop> ivanm, if it were up to me, I'd use haskell for everything
19:47:07 <lispy> ?src flip
19:47:08 <lambdabot> flip f x y = f y x
19:47:10 <Liempt> lispy: Perfect.
19:47:10 <mib_w6mvmc> i jk
19:47:20 <Liempt> Thank you very much.
19:47:21 <mmorrow> Cale: he wants :: Int -> Int though, i'm not really clear on what it's supposed to do..
19:47:33 <Cale> mmorrow: Well, if he can use a helper, it's fine.
19:47:44 <rwbarton> Liempt: you can also use section syntax like
19:47:45 <mmorrow> ah, ;)
19:47:58 <rwbarton> > filter ((== 0) . (`mod` 7)) [1..30]
19:48:00 <lambdabot>   [7,14,21,28]
19:48:03 <lispy> I bet the point of the assignment is to get them to use a lambda or a locally defined function in the definition of their pow
19:48:19 <mmorrow> > let f n = replicate n n in f 4
19:48:20 <lambdabot>   [4,4,4,4]
19:48:23 <mmorrow> > let f n = replicate n n in f 20
19:48:25 <lambdabot>   [20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20,20]
19:48:40 <mmorrow> > let power n = product (replicate n n)
19:48:40 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
19:48:40 <lambdabot>  ...
19:48:44 <Liempt> rwbarton: Oh, equally useful.
19:48:50 <lispy> > let f n = replicate n n in zipWith (*) (f 20)
19:48:51 <lambdabot>       Overlapping instances for Show ([Int] -> [Int])
19:48:51 <lambdabot>        arising from a u...
19:48:51 <mmorrow> > let power n = product (replicate n n) in power 5
19:48:52 <lambdabot>   3125
19:48:54 <Liempt> Thanks you both very much.
19:48:57 <rwbarton> Liempt: Right.  And sometimes (but not always) easier to read
19:49:05 <mmorrow> > let pow n = product (replicate n n) in pow 5
19:49:06 <lambdabot>   3125
19:49:14 <lispy> oh right, product = zipWith (>)
19:49:16 <lispy> er
19:49:18 <lispy> (*)
19:49:22 <mmorrow> weird. wtf is "power" that it's causing a syntax error?
19:49:34 <lispy> mmorrow: "in ..."
19:49:34 <rwbarton> didn't you just forget the  in ...?
19:49:50 <mib_w6mvmc> thanks Cale got it
19:49:53 <mmorrow> um
19:49:58 <mmorrow> > let power n = product (replicate n n) in power 5
19:49:59 <lambdabot>   3125
19:50:06 <mmorrow> oh, heh i did
19:50:34 * lispy wonders if we just did someone's homework for them :)
19:50:45 <lispy> Cale: I have a type checking question if you're in a homework doing mood :)
19:51:23 <rwbarton> mmorrow: btw, is there a solution yet (i.e., in a 6.10 prerelease) to the problem of producing pattern guards/view patterns from quasiquoters?
19:51:36 <Cale> lispy: hehe :)
19:52:40 <mmorrow> rwbarton: unfortunately not yet. the rep needs to be added to the TH ast. hmm, i have some ideas of other things to add as well. maybe it'd be good to make list list of proposed additions.
19:52:51 * mmorrow starts thinking
19:53:22 <Cale> lispy: What is the question? :)
19:53:27 <lispy> Cale: just a sec, pasting
19:53:53 <Cale> I don't know a ton of type theory.
19:54:06 <Cale> But who knows, maybe I can help :)
19:54:06 <mmorrow> rwbarton: i think we have a few weeks tops to get stuff added before 6.10 final comes out
19:54:39 <mib_w6mvmc> cale i have a ques i need help with
19:54:56 <mib_w6mvmc> i did it one way i jus want to shorten  it
19:54:59 <chrisdone> ./bootstrap.sh: 24: popd: not found  .. ./bootstrap.sh: 27: pushd: not found
19:55:00 <chrisdone>  
19:55:01 <mib_w6mvmc> here's the ques
19:55:02 <chrisdone> what are there programs?
19:55:03 <mib_w6mvmc> Write a Haskell function countChange that calculates the number of different  ways we can make change of n cents, given denominations of 1 cent, 2 cents,  … , d cents ( i.e. if d=5, the denominations of coins available are 5 cents, 4  cents, 3 cents, 2 cents and 1 cent )
19:55:24 <Cale> mib_w6mvmc: ah, that's a nice recursive problem :)
19:55:29 <lispy> Cale: http://hpaste.org/10828
19:56:23 <Eridius> mib_w6mvmc: you could probably brute-force it with a list comprehension pretty trivially
19:56:45 <Cale> lispy: Just to check that my eyes don't deceive me, the only difference there is that two lines have been swapped?
19:56:55 <lispy> Cale: correct
19:57:19 <mib_w6mvmc> this is what i wrote http://hpaste.org/10829
19:57:31 <Cale> lispy: and you're not using some wacky preprocessor which changes the meaning of do notation? :)
19:57:47 <Cale> lispy: I have a hard time seeing how that could possibly ever happen...
19:57:51 <waynemokane> does anyone know a good reference or examples for learning about subsumption architectures?
19:57:52 <mib_w6mvmc> Eridius, look at what i have, jus want to shorten it
19:58:07 <mmorrow> Cale: are you interested in matroids from the point of view of algorithms? if so i recently got a really great book on combinatorial optimization algos which includes matroids (not categorical, and i haven't looked at that chapter yet). i'll give you the name in a  bit when i'll have access to it if you desire
19:58:16 <lispy> Cale: no, I'm not using a preprocessor
19:58:23 <lispy> Cale: other than the macro C()
19:58:42 <lispy> Which can be ommited if you prefer, it's just #define C(a) a
19:58:49 <lispy> (I forgot remove it)
20:00:03 <mmorrow> Cale: ah, found it on amazon (5 stars) http://www.amazon.com/Combinatorial-Optimization-Theory-Algorithms-Combinatorics/dp/3540718435/ref=sr_1_4?ie=UTF8&s=books&qid=1222916365&sr=1-4
20:00:06 <Eridius> mib_w6mvmc: so your code is meant to be called like (coins 92 5)?
20:00:07 <lambdabot> http://tinyurl.com/3oudd6
20:00:13 <mib_w6mvmc> yeah
20:00:21 <rwbarton> lispy: I am reminded of the error you get when you write  runST $ do ...
20:00:21 <glguy> "Is this an unmodified ghc tarball?" I wondered. No hashes to be found and the SSL cert on haskell.org is the automatically generated localhost.localdomain one anyway. woot!
20:00:38 <Cale> lispy: hmm, that is insane...
20:00:48 <lispy> rwbarton: I can remove the ($) operators if you like
20:00:58 <rwbarton> lispy: Sure, I guess.
20:00:59 <Cale> lispy: I can imagine how it would influence the meaning of the code, but not its type...
20:01:23 <Cale> lispy: But maybe it has something to do with the fact that you're unpacking an existential in do-notation?
20:01:26 <lispy> rwbarton: same error without ($)
20:01:32 <Eridius> mib_w6mvmc: your code looks fine to me. I suggested list comprehensions earlier, but I didn't realize the set of denominations was variable
20:01:34 <rwbarton> lispy: Maybe you should try desugaring by hand
20:01:43 <Cale> lispy: Try using case by hand to unpack the existential.
20:01:44 <lispy> I will try to remove the sugar
20:01:48 <Cale> Rather than pattern matching.
20:01:52 <rwbarton> lispy: I think there might be "too much stuff" between some funky type and some other funky type, is what I'm trying to say :)
20:02:19 <mib_w6mvmc> is there a shorter way to do this?
20:02:33 <Cale> lispy: hehe, will the difficulties with the Sealed type never end? :)
20:03:23 <lispy> Cale: that is correct :)
20:03:32 <Eridius> mib_w6mvmc: shorter than what? You have 2 base cases and a general case. Seems short enough to me
20:03:41 <lispy> Cale: I'm studying this case because I want to explain it as a tricky spot
20:03:57 <mib_w6mvmc> k
20:04:17 <lispy> I'm using case and it still has the same error
20:04:24 <lispy> desugar the monad?
20:04:37 <Eridius> mib_w6mvmc: a list comprehension is significantly faster at calculating the value, but it has to hard-code the number of denominations
20:05:59 <rwbarton> Desugar the monad is what I was suggesting, yeah
20:06:22 <lispy> completely desugared, still has the type error
20:06:29 <rwbarton> hpaste again?
20:06:44 <Cale> lispy: Let's have a look at the new code, maybe it'll be clearer what's happening now...
20:06:47 <lispy> http://hpaste.org/10828#a1
20:07:02 <mib_w6mvmc> can u show me how to do it using list comprehension please Eridius
20:07:21 <glguy> lispy: you have a tap character in there
20:07:25 <glguy> lispy: is that breaking something?
20:07:28 <lispy> tap?
20:07:30 <Eridius> mib_w6mvmc: well, I actually used the list monad instead (list comprehensions are actually just an alternative syntax for the list monad)
20:07:36 <glguy> tab*
20:07:45 <lispy> glguy: no tab character locally
20:07:47 <mib_w6mvmc> k
20:07:50 <Eridius> mib_w6mvmc:
20:07:50 <Eridius> http://hpaste.org/10829#a1
20:08:07 <rwbarton> So I don't know exactly how case statements on existentials work, but maybe the problem is that the argument (\r -> ...) to (>>=) needs to be at a polymorphic type?  Or something.
20:08:31 <glguy> lispy: nvm, I was looking at the error message when I pulled it down with curl
20:08:43 <Cale> What's the type of seal?
20:09:00 <mib_w6mvmc> is there anyway to avoid hard-coding the values
20:09:10 <mib_w6mvmc> ???
20:09:21 <Eridius> mib_w6mvmc: well, that's the hard part
20:09:35 <rwbarton> also, what's the definition of Sealed?
20:09:49 <lispy> Cale: hit reload, #a3
20:10:01 <lispy> I could replace seal with Sealed
20:10:45 <lispy> Do you guys think this is ghc bug report worth?
20:11:03 <mib_w6mvmc> what about using factorial to break it down
20:11:03 <Cale> Wait, I totally fail to understand what the point of this sealed thing is...
20:11:26 <lispy> Cale: you existentially hide a type...
20:11:32 <Cale> lispy: You put a data structure in Sealed, and it's like throwing away the elements of the structure?
20:12:19 <glguy> data BitBucket = forall a. Bucket a
20:12:19 <Cale> Sealed :: [x] -> Sealed [], and then the elements of the list are no longer accessible, so it might as well be a natural?
20:12:21 <rwbarton> Cale: a isn't necessarily a Functor.  It could contain some data and a dictionary for using that data, for instance
20:12:22 <lispy> Cale: yeah, but we only do that to phantom types anyway
20:12:51 <mib_w6mvmc> Eridius can we using factorial to break down the number
20:13:29 <Eridius> mib_w6mvmc: I don't think that'll help, but feel free to try
20:15:29 <rwbarton> lispy: Actually, this error message looks like it's telling the truth to me.
20:15:48 <mib_w6mvmc> anything u think that can help?
20:15:50 <lispy> rwbarton: why does the reordering fix it?  That's what I want to understand
20:16:04 <rwbarton> Yeah, that's what has me confused now.
20:16:29 <rwbarton> I guess it's because in the first definition, it knows what type to instantiate cH at
20:16:40 <rwbarton> (it's whichever type it got out of rest)
20:17:09 <int-e> lispy: hmm. you can probably implement something like  myTest :: Monad m => [a] -> (forall x . Sealed (RL b x) -> m c) -> m c
20:17:57 <rwbarton> Wait, that didn't make any sense.
20:19:33 <int-e> @type runST
20:19:35 <lambdabot> forall a. (forall s. ST s a) -> a
20:19:44 <rwbarton> Well, I think it makes sense if you replace cH by its definition (undefined) ignoring the type signature.
20:19:55 <Liempt> Quick question for anyone who is listening.  What is the "ap" function that @pl keeps on giving me, and in what module or what-have-you is it located?
20:20:12 <lispy> int-e, rwbarton, Cale: we also have this data point: http://hpaste.org/10828#a4
20:20:44 <lispy> Liempt: try ?index ap
20:20:47 <lispy> Liempt: or :t ap
20:20:57 <Liempt> ?index ap
20:20:57 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Data.Graph.
20:20:57 <lambdabot> Inductive.Query.ArtPoint, Data.Graph.Inductive.Query, Data.Graph.Inductive
20:20:59 <rwbarton> Liempt: or @hoogle ap
20:21:16 <lispy> Liempt: you'll also want to look at the Reader instance of ((->) r)
20:22:04 <rwbarton> lispy: this also fits with my guess for what should happen if you just replaced cH by undefined.
20:22:58 <lispy> rwbarton: oh, right so the type of cH doesn't matter
20:23:17 <lispy> rwbarton: I just commented out the type sig of cH and i get the type error in the fully desugared example.
20:23:28 <lispy> rwbarton: So, somehow (>>=) doing this?
20:23:29 <rwbarton> lispy: Try changing Sealed x to Sealed (x :: forall xx. q xx)
20:23:58 <lispy> rwbarton: in the definition of what? cH?
20:24:09 <rwbarton> On the first line of the do
20:24:16 <rwbarton> But now I think it's probably not legal syntax.
20:24:36 <lispy> it's legalish in ghc
20:24:54 <rwbarton> Even on a <- -bound variable, which is supposed to be monomorphic?
20:25:17 <lispy>     A pattern type signature cannot bind scoped type variables `q'
20:25:17 <lispy>       unless the pattern has a rigid type context
20:25:48 <rwbarton> lispy: I have another idea
20:26:07 <rwbarton> lispy: Take the code that compiles and make cH a top-level (no-inline?) definition
20:26:55 <lispy> rwbarton: okay, but I'm not using lexically scope type variables
20:27:03 <rwbarton> hmm
20:27:14 <lispy> so the working one keeps working
20:27:24 <rwbarton> oh I see
20:27:48 <rwbarton> What if you change the type of cH to  Monad m => m (Sealed (RL b x))?
20:28:01 <Eridius> mib_w6mvmc: http://hpaste.org/10829#a2
20:28:12 <Eridius> no list comprehensions, instead it's simply much faster
20:28:14 <lispy> rwbarton: well, the working one stops working
20:28:28 <rwbarton> I guess that's because of the type of :<:
20:28:51 <lispy> ah yeah, sorry, :<:, is a cons. Let me get you the definition
20:29:31 <lispy> rwbarton: http://hpaste.org/10828#a5
20:30:23 <lispy> Cale: did you throw in the towel?
20:31:00 <lispy> rwbarton: the problem has to be related to (>>=) right?
20:31:05 <Cale> lispy: I have no idea man :)
20:31:28 * lispy makes a mark on the calendar for the first day he heard Cale say those words :)
20:31:34 <rwbarton> lispy: hang on
20:31:41 <Cale> lispy: hehe
20:31:42 <rwbarton> lispy: I'm confused by your mytest2 example now
20:31:52 <Cale> lispy: Believe me, there are lots of things which I have no idea about :)
20:32:02 <rwbarton> isn't (:<:) getting its arguments in the wrong order in one of those definitions?
20:32:22 <lispy> rwbarton: that would make sense yes.  So maybe that's just a bad example.
20:32:30 <rwbarton> I'm guessing you forgot to swap something else in the hpaste
20:32:53 <lispy> rwbarton: the working mytest2 is good.  The non-working on may be a red herring
20:33:11 <rwbarton> Yeah, it is.  The error message even says so :)
20:35:00 <rwbarton> Well, now I have enough code to replicate your error message :)
20:35:14 <lispy> I have a simpler example I think
20:36:51 <lispy> rwbarton: http://hpaste.org/10828#a6
20:37:16 <rwbarton> Great
20:38:11 <lispy> so why is the type of (mytest xs) :: (forall b. m (Sealed (q b)))
20:38:38 <lispy> WHat's up with that inner forall on the b?
20:39:00 <int-e> lispy: your 'working' mytest2 fails to typecheck for me. is {-# LANGUAGE GADTs, RankNTypes #-} enough?
20:39:21 <lispy> int-e: I'm not sure what is enough.  What is your error message?
20:40:39 <int-e> oh wait a second. (:<:) does not have type (forall y z. q y z -> p x y -> r x z)
20:41:58 <int-e> yes it does. let me think about it.
20:42:57 <int-e> found it. My RL definition was wrong, sorry for the false alarm.
20:45:58 <lispy> I havea version that jus needs Sealed, no undefined, no (:<:)
20:47:21 <lispy> http://hpaste.org/10828#a7
20:49:09 <rwbarton> lispy: I think this behavior kind of makes sense.
20:49:22 <lispy> rwbarton: then, please explain :)
20:49:43 <rwbarton> lispy: If you unpack the mx first, you know what type b you want to take the value of my at (it's the type that's in the existential)
20:50:01 <lispy> But, what tells you that?
20:50:11 <lispy> What is it about unpacking it first?
20:50:53 <rwbarton> But you can't instead unpack my at a polymorphic type, because the y in Sealed y has to be at a monotype.  So you can't decide later what the type is using the contents of mx.
20:51:53 <lispy> rwbarton: I'm not following :(
20:52:03 <adu> hi
20:52:06 <rwbarton> It's probably because I don't really understand how existential types work.
20:52:15 <lispy> rwbarton: what about the order of unpacking changes the polymorphismL
20:52:32 <lispy> rwbarton: Well, when you bind an existential it gets a nice distinct type
20:52:39 <rwbarton> I can give you a toy model for them though
20:52:40 <lispy> rwbarton: (binding meaning unpacking)
20:52:41 <adu> rwbarton: maybe because they're not existential types, there actually universal types
20:53:08 <lispy> I wonder if I should email haskell-cafe
20:53:14 <rwbarton> a value of type forall b. m (Sealed (q b)) is a box that you can put a type 'b' into and it will give you a type 'x' and some data of type q b x
20:53:17 <adu> "forall" = universal quantifier
20:53:18 <adu> "exists" = existential quantifier
20:53:37 <adu> and what does Haskell use? "forall".
20:53:49 <Heffalump> it puts the forall in different places to make existentials
20:54:03 <lispy> oh, here is someone that might now how/why this works
20:54:08 <lispy> Heffalump: hey, I need some help
20:54:10 <adu> Heffalump: ya I've never seen that, I've only seen the forall in one place
20:54:14 <Heffalump> lispy: am just readin git
20:54:17 <dfrey> I would like to time how long it takes for some IO action to run.  How can I measure elapsed time using haskell?
20:54:19 <Heffalump> s/readin git/reading it/
20:54:40 <dfrey> Heffalump: I am guessing you are a git user?  :)
20:54:40 <adu> the only place I've seen forall used is: value :: forall a . type
20:54:44 <lispy> Heffalump: oh, I thought maybe you caught the git fever ;)
20:55:02 <Heffalump> the explanation above about when 'b' is instantiated makes sense to me too
20:55:21 <adu> dfrey: theres always the long way around
20:55:31 <lispy> adu: If you move the forall, according to the rules of logic, it becomes essentially an existential quantifier
20:55:45 <rwbarton> Heffalump: Cool, please explain what I said back to me using real words :)
20:55:59 <adu> dfrey: system $ "time ghci -e '" ++ expr ++ "'"
20:55:59 <lispy> Heffalump: yeah, I'm not getting the intuition yet
20:56:00 <Heffalump> rwbarton: I don't think I could explain it any more clearly.
20:56:13 <Heffalump> I'm just thinking through the desugaring though.
20:56:15 <dfrey> adu: I'm trying to avoid that
20:56:35 <adu> dfrey: lol ya, i assumed so
20:56:38 <rwbarton> lispy: I can only understand this intuitively using the fact that <- corresponds to some kind of sequencing, not explicitly using the desugaring.
20:56:47 <leimy> heh
20:58:08 <adu> lispy: where do you move it to?
20:58:19 <dfrey> It looks like there is epochTime in System.Posix.Time, but I was hoping for something with millisecond or better granularity
20:58:37 <adu> dfrey: theres a way of getting nanoseconds
20:58:46 <adu> dfrey: I think in LocaleTime or something
20:59:27 <lispy> adu: you could move it the other side of a function arrow
20:59:35 <lispy> adu: or you could move it inside a data constructor
20:59:38 <Heffalump> hmm. Actually, I don't believe that explanation any more.
20:59:46 <adu> dfrey: http://hackage.haskell.org/packages/archive/time/1.1.2.1/doc/html/Data-Time-Clock.html#v:picosecondsToDiffTime
20:59:57 <lambdabot> Title: Data.Time.Clock, http://tinyurl.com/3l2kxb
21:00:20 <Heffalump> I think you should ask ghc-users, SPJ is on the lookout for bad error messages.
21:00:40 <lispy> Heffalump: okay, this one is consistent accross ghc versions
21:00:46 <lispy> Should I send to haskell-cafe too?
21:01:08 <Heffalump> not sure that cross-posting is sensible
21:01:19 <Heffalump> and SPJ doesn't read haskell-cafe
21:01:33 <lispy> Yeah, but some other sharp cookies do :)
21:01:45 <Heffalump> yes, but that won't help improve GHC's error messages
21:02:09 <lispy> Well, right now I want to understand the problem regardless of the error message
21:02:51 <Heffalump> I expect you'll get an explanation there, and perhaps in future the error message will become clearer.
21:03:49 <hml> OT: has the wednesday bailout plan vote happened yet? If so, which way did it go? I can't find this on google news
21:04:12 <Heffalump> you can reproduce it without the monads btw
21:04:30 <lispy> Heffalump: oh?
21:04:30 <Cale> "matroid homomorphism" gives only 4 results in google... what the heck? :)
21:04:48 <lispy> Heffalump: the error message or this reordering issue?
21:05:11 <Heffalump> (annotation added)
21:05:15 <rwbarton> Oh, indeed
21:05:53 <lispy> Heffalump: thanks, i'll use your version then
21:05:59 <lispy> I'm also going to remove gadts
21:06:04 <Heffalump> what I'm confused about is what the b in Sealed y gets instantiated to in the first case statement
21:06:08 <dfrey> adu: I should be able to do ":module +Data.Time.Clock" in ghci in order to access that correct?  I ask because it's not working.
21:06:12 <Heffalump> I wouldn't bother, the existential is important
21:06:17 <Heffalump> and GADTs are a good way to express that
21:06:32 <lispy> data Sealed a = Sealed (forall x. a x)
21:06:37 <adu> dfrey: depends, ghc 6.6 or 6.8?
21:08:14 <dfrey> adu: I think it may not be installed.  I just noticed that there is a libghc6-time-dev package in ubuntu
21:08:37 <Heffalump> I think I believe rwbarton's explanation again.
21:09:01 <Heffalump> The problem is that an existential won't unify with *anything* in the environment, even a free unconstrained type variable.
21:09:06 <ivanm> if I'm in the IO monad, and I want to ensure the results of a command are finalised, is there a better way than: foo <- f outp; foo `seq` hClose outp ?
21:09:09 <lispy> I think it may be a gadt problem
21:09:14 <Heffalump> I don't
21:09:17 <ivanm> if I don't use seq, it seems that the command isn't run :s
21:09:46 <rwbarton> I think the types in the f parameter are important
21:10:14 <Heffalump> rwbarton: well, the fact that it requires the two instances of y to unify is important
21:10:14 <sjanssen> ivanm: the command will certainly be run
21:10:19 <Heffalump> I don't think it matters otherwise
21:10:31 <lispy> Heffalump: it goes away if I don't use a GADT to define Sealed
21:10:45 <ivanm> sjanssen: well, when I didn't have the foo `seq` in there, nothing was returned :s
21:10:50 <Heffalump> lispy: your definition above is wrong
21:10:56 <Heffalump> it's not existential, it's universal
21:10:56 <adu> dfrey: want a working example? http://hpaste.org/10833
21:11:10 <lispy> Heffalump: ah, then what is the right non-gadt def?
21:11:18 <sjanssen> ivanm: is f lazy in some way, using hGetContents or unsafeInterleaveIO?
21:11:39 <lispy> data Sealed a = forall x. Sealed (a x) ?
21:11:42 <Heffalump> lispy: umm. Not sure now. And I'm not certain it's wrong any more :-) But I think it is.
21:11:44 <ivanm> yeah, it uses hGetContents
21:11:45 <Heffalump> Yes, try that.
21:12:03 <sjanssen> ivanm: you shouldn't hClose handles that have been hGetContents'ed
21:12:16 <Heffalump> the example can be further simplified by lifting f into a top-level definition
21:12:20 <Heffalump> (just make the body be undefined)
21:12:21 <lispy> Heffalump: yeah, okay that's same results as the gadt one
21:12:30 <sjanssen> ivanm: and if you want to make sure the IO happens right away, you ought to Control.Exception.evaluate (length foo)
21:12:40 <adu> dfrey: ya get that, and if its ghc 6.6 then use ":module +Data.Time" but if its ghc 6.8 then use "import Data.Time"
21:12:46 <ivanm> sjanssen: oh.....
21:12:55 <adu> and theres always ":browse Data.Time" ... :)
21:13:00 <ivanm> I didn't know you weren't meant to close them :s
21:13:13 <rwbarton> Heffalump: BTW, you know you posted the non-working version, not the working version?
21:13:15 <ivanm> sjanssen: why not?
21:13:32 <Heffalump> yes (just added another simplified version that is the working version)
21:13:35 <ivanm> especially since the function that I'm using might _not_ invovle hGetContents :s
21:13:56 <adu> sjanssen: ya that confused the hell out of me the first time it didn't work, so I started using readFile instead of trying to understand
21:14:25 * Heffalump has to go
21:14:33 <adu> bye Heffalump
21:14:39 <lispy> Heffalump: thanks
21:14:44 <cjs> Hm. Interesting how ghc will infer a type alias, rather than the aliased type.
21:14:51 <cjs> Awfully clever.
21:15:23 <dfrey> adu: how do ":module +..." and "import ..." differ?
21:15:40 <dfrey> adu: Thanks for the example.
21:15:54 <adu> dfrey: I really don't know, i just know that you couldn't do "import ..." in the older version
21:15:56 <sjanssen> ivanm: I'm not sure whether it is an error to close the handle or not, but hGetContents is supposed to put a handle in a "semi-closed" state
21:16:41 <cjs> It likely is an error, since you might close it before it's finished reading from it.
21:16:42 <ivanm> OK, I just looked at the haddock docs... hClose closes it fully
21:16:47 <ivanm> cjs: *nod*
21:17:14 <ivanm> so what's the best way to ensure that it is fully read, especially since the function may or may not use hGetContents?
21:17:17 <dfrey> adu: Ok.  I definitely tried import when I first started toying around with Haskell and I remember it not working.  I didn't realize that import works now
21:17:39 <adu> sjanssen: the problem is (do c <- hGetContents h; hClose h; putStr c) will return "" because nothing could be read from the closed file or something
21:17:45 <int-e> lispy: http://hpaste.org/10828#a10 may be interesting. (I'm intrigued that the naive desugaring of the do block leads to code that doesn't type check)
21:17:51 <cjs> If you use hGetContents, the point is that you don't care if it's fully read or not. You just care that should anybody evaluate it, they get stuff.
21:17:53 <sjanssen> adu: yeah, that's right
21:18:07 <ivanm> cjs: OK, what if I want _all_ the contents?
21:18:08 <adu> sjanssen: something about laziness, which I don't understand
21:18:11 <sjanssen> ivanm: you could just not close the Handle
21:18:19 * ivanm copied hGetContents off somehwere else
21:18:25 <adu> ivanm: either hGetContents or readFile
21:18:31 <ivanm> sjanssen: no, I need to because the function may or may not use hGetContents
21:18:47 <sjanssen> ivanm: it will eventually be closed when it is garbage collected.  This is okay as long as you don't open tons of files and hit the open FD limit on your OS
21:18:50 <cjs> ivarm: Don't do a lazy read. Just read it all at once.
21:19:06 <ivanm> cjs: how?
21:19:09 <sjanssen> cjs probably has the best advice
21:19:26 <ivanm> sjanssen: so I don't have to bother closing _any_ handles?
21:19:35 <adu> dfrey: ya, I think thats a 6.8 feature
21:19:41 <ivanm> @type readFile
21:19:43 <lambdabot> FilePath -> IO String
21:19:54 <ivanm> no, I need something that takes a handle :s
21:20:04 <ivanm> @hoogle Handle -> IO a
21:20:05 <lambdabot> Control.Exception evaluate :: a -> IO a
21:20:05 <lambdabot> System.IO hClose :: Handle -> IO ()
21:20:05 <lambdabot> System.IO hFlush :: Handle -> IO ()
21:20:40 <cjs> Well, if you were using Data.ByteString,Strict, you could use its hGetContents, but probably you want to stick with Strings, right?
21:20:52 <ivanm> yeah
21:21:49 <int-e> lispy: in any case, doing a similar desugaring with type signatures after swapping the x <- mx and y <- my fails, because you have to commit to a type for y before x mx is executed, which *also* fixes its own value for y.
21:21:51 <sjanssen> ivanm: the Handle will be closed when it is garbage collected, but sometimes you need to close the handle earlier
21:21:51 <ivanm> OK, the code I'm copying hGetContents from does (length foo) `seq` return () :s
21:21:59 <ivanm> sjanssen: ahhhhh, OK
21:22:03 * ivanm tries not closing the handle then
21:22:26 <sjanssen> ivanm: just be careful, because there is a limit on the number of files you can have open at once
21:22:34 <lispy> int-e: I think I'm starting to understand that.  This is related to the monotype discussion.
21:22:40 <ivanm> sjanssen: *nod*
21:22:49 <ivanm> I don't think it will be a problem...
21:22:58 <cjs> ivanm: Sorry, I just got a bit busy, but I'll come back in a bit if someone else hasn't told you how to do what you want.
21:23:06 <int-e> lispy: basically you cannot go from  forall b. m (Sealed (q b)))  to  m (forall b. Sealed (q b))) - I think that's the issue at heart.
21:23:10 <ivanm> cjs: fair enough
21:23:35 <rwbarton> int-e: Actually, there was a simpler example which didn't have m at all.
21:23:47 <int-e> rwbarton: I saw that.
21:24:22 <ivanm> well, a `seq` hClose seems to work, and it avoids the issue about not having too many files open at once
21:24:25 <rwbarton> http://hpaste.org/10834  (clicked the wrong button)
21:24:34 <int-e> rwbarton: (the fundamental reason remains the same, I think. (forall b. (Sealed (q b))) can't be converted to (Sealed (forall b . q b))
21:25:00 <rwbarton> I suspect existential types support local types like  exists z. q y z  (where q and y are bound in the environment) but not  forall y. exists z. q y z
21:29:41 <ivanm> @seen matthew-_
21:29:41 <lambdabot> matthew-_ is in #haskell, #ghc and #haskell-blah. I last heard matthew-_ speak 1d 13h 18m 54s ago.
21:31:12 <mm_freak_> what does it mean for a function in CPS to ignore the continuation?
21:31:24 <mm_freak_> is this strictly incorrect or can it be useful?
21:32:10 <dfrey> I'm looking at Data.Time.Clock and I see that there is a function "getCurrentTime  :: IO UTCTime" and there is another function "diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime".  This seems like almost exactly what I'm looking for except I don't understand how I can convert the NominalDiffTime into something useful to me like a Double representing milliseconds.
21:32:40 <rwbarton> mm_freak_: In haskell, it means you used some value of type forall a. a (to construct the unknown return type).  So probably you called undefined or error
21:33:43 <int-e> lispy: and indeed you can evaluate my before mx with another wrapper for the result of my. http://hpaste.org/10828#a11
21:34:04 <[R]ayne> Hey binrapt
21:34:15 <mm_freak_> thanks
21:34:59 <lispy> int-e: hmm?
21:35:02 <lispy> looing
21:35:06 <lispy> looking*
21:36:30 <lispy> int-e: oh man, that does confuse me a bit :)
21:36:47 <lispy> int-e: I think i get it
21:37:00 <mm_freak_> what about a contination that returns?  example:  fact n k = k (product [2..n])
21:37:07 <mm_freak_> fact 5 print
21:37:11 <lispy> int-e: you use a data type as a vehicle for controlling when the existential binds.  Yes, that's typical of existentials it seems.
21:37:22 <int-e> lispy: yep
21:37:23 <mm_freak_> this runs perfectly well, but it somehow appears incorrect to me
21:37:46 <int-e> lispy: the Sealed' name is awful ... it's more of a Wildcard.
21:38:51 <lispy> int-e: right
21:39:13 <lispy> it is a clever solution though
21:39:18 <lispy> I'm adding it to my notes
21:39:45 <lispy> int-e: if I want to attribute the idea, do you have a preferred name? :)
21:39:56 <lispy> I doubt you want to be called 'int-e from freenode'
21:40:40 <int-e> int-e = Bertram Felgenhauer ;)
21:40:53 <rwbarton> Note that mytest3 and mytest3' don't have the same type though, as int-e pointed out
21:41:47 <int-e> you can't convert forall x . m (Sealed q x) to m (Sealed
21:42:08 <int-e> to m (Sealed' q) in general - it doesn't work for lists for example.
21:42:21 <sbahra> dfrey, http://haskell.org/ghc/docs/latest/html/libraries/time/Data-Time-Clock.html#t%3ANominalDiffTime
21:42:23 <lambdabot> Title: Data.Time.Clock, http://tinyurl.com/2w6lgd
21:42:32 <rwbarton> right. http://hpaste.org/10828#a12
21:42:36 <int-e> So that's an essential difference.
21:43:34 <lispy> ah
21:44:30 <mmorrow> , let go _ [] = [] ; go f (x:xs) = f x xs (\xs -> go f xs) in go (\n rest k -> if n==10 then [] else n : k rest) [0..]
21:44:31 <lunabot>  [0,1,2,3,4,5,6,7,8,9]
21:44:39 <int-e> rwbarton: oops. I thought that didn't work ... I wonder why.
21:45:11 <mmorrow> sometimes ignoring the continuation is the way to bail, and sometimes vice-versa depending on the situation
21:45:39 <int-e> rwbarton: I probably got confused between universal and existential quanitification somewhere. Thanks.
21:45:41 <conal> what are people's favorite irc clients on osx.
21:46:28 <rwbarton> oh yeah.  If a function gets passed the continuation to some other, calling function, it can call it instead of its own continuation, as a kind of non-local flow control
21:46:56 <conal> i'm asking for a friend who's starting haskell.  i'm encouraging him to join this channel, and he doesn't use irc yet.
21:47:59 <mmorrow> > flip runCont id (callCC $ \k -> foldM (\a b -> if b==0 then k a else return (a*b)) 1 ([1..10]++[0..]))
21:48:00 <lambdabot>   3628800
21:48:17 <mmorrow> "product until 0 is seen"
21:51:56 <Saizan> conal: a commonly used one is X-Chat
21:52:16 <mmorrow> x-chat is quite nice
21:52:46 <dfrey> x-chat is pretty nice, but there are probably clients that integrate better with the OSX environment.
21:52:47 <mmorrow> i always use a console irc client until a few months ago, then x-chat. i'll never go back.
21:52:55 <mmorrow> s/use/used/
21:53:06 <Saizan> mmorrow: i did the opposite :)
21:53:14 <mmorrow> Saizan: heh
21:53:15 <int-e> mmorrow: hehe. used xchat for ages, then switched to irssi. will never switch back ;)
21:53:30 <mmorrow> i always used ircii
21:53:39 <ivanm> anyone here familiar with darcsum-mode for emacs?
21:53:54 <rwbarton> What exactly does it mean when Oleg says something is *easily* achievable? :)
21:54:22 <int-e> "doesn't require any type system extensions, plain Haskell 98 is enough"?
21:54:26 <conal> thanks for the irc client recommendations.
21:54:28 <mmorrow> rwbarton: known to be not impossible?
21:55:18 <lispy> conal: colloqui (sp?) is a popular osx client
21:55:23 <thoughtpolice> conal: on os x lots of people think colloquy is pretty good
21:55:33 <thoughtpolice> that one :]
21:55:49 <rwbarton> Does the term of type  Cont r (Either a (a->r))  have a nice interpretation?  (law of the excluded middle)
21:56:09 <conal> thx
21:56:36 <rwbarton> Oh, I guess it's that devil thing.
21:56:42 <lispy> rwbarton, int-e: do you want to see the less abstract context that this reorder came up in?
21:57:10 <mmorrow> rwbarton: satan is involved?
21:57:15 <lispy> rwbarton, int-e: look at the function rp http://hpaste.org/6316
21:57:32 <rwbarton> mmorrow: There's some paper with a story about the devil that involves this type
21:58:08 <mmorrow> ah, i've heard "that devil thing" mentioned in here in passing, but never knew wtf it was refering to
21:58:33 <lispy> Does said devil go down to Georgia?
21:58:46 <mmorrow> on a midnight train!
21:59:46 <rwbarton> basically it goes like this
22:00:01 <rwbarton> the devil says, "I'll give you either an 'a' or an 'a->r'"
22:00:10 <mmorrow> lol
22:00:24 <mmorrow> ok
22:00:26 <rwbarton> (The story version is better, of course :)
22:00:33 <rwbarton> At first, he gives you an a->r
22:00:44 <mmorrow> heh, i'm amused picturing this situation
22:00:45 <rwbarton> (Where does it come from?  It doesn't matter.)
22:00:58 <rwbarton> Because in order to call it, you need to put in an a
22:01:03 <mmorrow> clearly it's from hell
22:01:07 <rwbarton> Then the devil changes his mind and says "here is your a"
22:01:51 <rwbarton> (giving you back the a you put into the a->r)
22:02:11 <mmorrow> ha, i just got it
22:02:35 <mmorrow> (or perhaps i'm just inventing a metaphor)
22:03:15 <mmorrow> i won't say anything though in case it will ruin it though
22:03:42 <mmorrow> s/though/i always do the double though and it drives me crazy/
22:07:44 <gio123>  (a*b+bb*a)* is subset of (a+b)*
22:07:48 <dons> bos, so i think we've solved your bug report about base-3/base-4 inconsistency
22:08:07 <dons> and have a good notion for a constistent dependency now for the same package with different versions.
22:08:11 <dons> phew. starting to make sense.
22:08:18 <lispy> dons: I'm going to try coming over on a bus in the morning.  Is your building locked or anything?
22:08:57 <dons> nope. walk in the front door. take the lift to level 3 at around 10.30
22:09:07 <dons> go to the front desk, then into the meeting room
22:09:27 <lispy> oh, level 3?  I think the website says 2nd floor
22:09:50 <dons> nah.
22:10:09 <dons> 421 SW 6th Ave. Suite 300
22:10:12 <lispy> dons: http://www.cubespacepdx.com/directions
22:10:17 <lambdabot> Title: Directions |
22:10:21 <lispy> dons: ah
22:10:47 <slava> i saw a link on reddit the other day, about doing I/O with folds, or something
22:10:50 <slava> in teh context of a web server
22:10:52 <slava> I can't find it anymore :(
22:10:58 <thoughtpolice> slava: enumerators!
22:11:01 <lispy> dons: so I guess the pdxfunc info for cubespace is wrong
22:11:08 <sjanssen> slava: search for left fold enumerators
22:11:11 <slava> ah ok
22:11:22 <dons> lispy: cubespace is wrong.
22:11:24 * sjanssen can't remember the name of the web server
22:11:26 <thoughtpolice> slava: http://www.galois.com/blog/2008/09/12/left-fold-enumerators-a-safe-expressive-and-efficient-io-interface-for-haskell/
22:11:26 <dons> this isn't at cubespace :)
22:11:31 <lambdabot> Title: Galois › Blog › Blog » Left-fold enumerators: a safe, expressive and effici ..., http://tinyurl.com/3f3er3
22:11:33 <sjanssen> dons probably knows it
22:11:35 <dons> lispy: http://upcoming.yahoo.com/event/1162057/?ps=7
22:11:36 <lambdabot> Title: Galois Tech Talk: Bluespec SystemVerilog at Galois (Thursday October 2, 2008) -  ...
22:11:39 <rwbarton> mmorrow: http://hpaste.org/10838
22:11:50 <thoughtpolice> slava: git repo is here - http://github.com/tibbe/hyena/tree/master
22:11:51 <lispy> dons: Ah, I'm getting it now.
22:11:55 <lispy> dons: thanks for the correction
22:11:56 <lambdabot> Title: tibbe's hyena at master — GitHub
22:12:07 <slava> thanks guys.
22:12:21 <thoughtpolice> slava: oleg's treatment on the whole matter is real readable too
22:12:24 <lispy> dons: that's why simpler than wher I was going :)
22:12:33 <lispy> dons: now I just hope on red or blue line and it takes me to your door :)
22:12:36 <dons> slava: there was also a talk and code online by oleg implementing another left-fold baesd io scheme
22:12:45 <dons> lispy: right. get off at pioneer square
22:12:53 <thoughtpolice> slava: http://okmij.org/ftp/Haskell/fold-stream.lhs and http://okmij.org/ftp/papers/LL3-collections-enumerators.txt
22:13:31 <lispy> dons: I was wondering why you guys called your office CubeSpace, but I just thought, "eh, because they can."
22:13:45 * lispy feels silly
22:14:38 <dons> hehe
22:14:43 <dons> we don't have cubes actually
22:14:48 <dons> more a hexagonal thingy
22:14:52 <dons> its free-form space
22:15:09 <dons> slava: btw, if you implement a good left-fold based IO system, i'd love to see it.
22:15:15 <dons> the big problem i see is compositionality.
22:15:23 <dons> and you'll have that too, i think.
22:15:42 <dons> f . g . h works well for composing stream transformers, but you need a new notion for foldables
22:15:53 <slava> dons: i'm interested in this in the context of http in particular
22:15:58 <dons> yeah, me too.
22:16:00 <slava> handling large file uploads and responses
22:16:08 <sjanssen> dons: what is the best source to start on enumerators?
22:16:19 <dons> so in a strict-only language, it might be the only way to do large uploads?
22:16:24 <dons> you have to chunk things somehow.
22:16:25 <lispy> why do you call it a left-fold based IO system?
22:16:27 <dons> and you can't use laziness.
22:16:34 <slava> dons: either that or you give the web app access to the underlying socket (which can get messy)
22:16:38 <dons> lispy: its based on fusing large bodies for a single left fold
22:16:47 <dons> slava: ah yes, manual management i guess.
22:16:52 <slava> dons: java people stream the upload into a temp file and pass the file name to the web app
22:17:04 <dons> so the temp file is fully allocated?
22:17:06 <dons> O(n) space?
22:17:07 <slava> yes
22:17:07 <int-e> @type \f -> f (Right (f . Left))
22:17:09 <lambdabot> forall c a. (Either a (a -> c) -> c) -> c
22:17:11 <slava> dons: except its on disk
22:17:19 <slava> dons: so its not entirely satisfactory
22:17:24 <slava> its good if you're actually just uploading files
22:17:26 <dons> right. we want to have both O(1) space, and precise resource management, and high level
22:17:28 <slava> yes
22:17:36 <slava> the user might want to stream real-time video which you compress, etc
22:17:44 <dons> yes. but you can't just use lazy streams.
22:17:55 <dons> since they have indefinite resource deallocation
22:18:01 <dons> though they hit O(1) space and high level.
22:18:11 <int-e> :t Cont (\f -> f (Right (f . Left)))
22:18:14 <lambdabot> forall r a. Cont r (Either a (a -> r))
22:18:27 * lispy changes locations
22:18:27 <dons> slava: its a cool problem. if you solve it, i guarantee you a galois tech talk. :)
22:18:39 <dons> slava has an open galois tech talk invitation anyway.
22:19:10 <dons> its fairly easy to write a good system that works, but a really elegant way of composing the bodies of the folds is the bit i'm stuck on.
22:19:14 <Saizan> how do i unpack/install the .pkg archive for ghc-6.10?
22:19:16 <dons> something as nice as f . g . h
22:20:24 <slava> yeah
22:20:25 <thoughtpolice> sjanssen: oleg's two little papers above i linked to are excellent intros to the idea
22:20:58 <sjanssen> thoughtpolice: thanks
22:23:17 <slava> dons: another problem i haven't seen an elegant solution to is writing resumable parsers
22:23:23 <slava> where 'elegant' means 'no extra work needed'
22:24:09 <thoughtpolice> dons: have you talked with oleg any about it outside of -cafe?
22:24:35 <JuanDaugherty> elegant = done. Luv it.
22:26:33 <dons> thoughtpolice: a little at DEFUN last week.
22:26:37 <dons> and he gave a tutorial on it to 30 people.
22:26:57 <dons> its easy to write a working system, but the combinators get .. complicated.
22:27:44 <thoughtpolice> yes, correctness is there, but general composition is a bit harder. :]
22:29:49 <dons> correctness and efficiency. it should be identical to chunked lazy io performance wise, but with the resource scoping solved.
22:31:59 <eck> hi all, i'm wondering why this program uses so much memory: http://hpaste.org/10839
22:32:59 <ivanm> eck: because it's reading in the whole file?
22:33:06 <rwbarton> eck: Not enough strictness probably.
22:33:17 <rwbarton> eck: try changing  max x y  to  max $! x $! y
22:33:28 <ivanm> and why are you using an IORef?
22:33:37 <int-e> eck: get rid of the ioref. Import Data.List and du  print (foldl' max 0 lineLengths)
22:33:40 <JuanDaugherty> Behold Eck!
22:33:46 <ivanm> why not just do: let longest = maximum lineLengths ?
22:34:01 <rwbarton> You guys didn't read the comment :)
22:34:10 <eck> i was trying to simplify a problem with a more complicated program that was doing something similar
22:34:15 <JuanDaugherty> (couldn't resist that)
22:34:18 <int-e> rwbarton: that doesn't help. using  modifyIORef  for updating state is a bad idea, it's lazy.
22:34:23 <ivanm> rwbarton: yes, but I didn't tell him to use foldr or max ;-)
22:34:39 <eck> when i did maximum it also used a lot of memory
22:34:44 <eck> but foldr max didn't
22:34:59 <ivanm> eck: compiled or interpreted?
22:35:07 <eck> compiled
22:35:12 <rwbarton> int-e: oh, right.
22:35:14 <roconnor> @src maximum
22:35:15 <lambdabot> maximum [] = undefined
22:35:15 <lambdabot> maximum xs = foldl1 max xs
22:35:16 <int-e> compiled with -O?
22:35:17 <ivanm> with optimizations?
22:35:26 <eck> i guess not, let me try again
22:35:38 <int-e> (there's a rule that replaces maximum by strictMaximum for Ints)
22:36:01 <int-e> where strictMaximum is a function that is defined in Data.List but not exported. lovely :)
22:36:03 <eck> -O didn't help
22:36:20 <ivanm> int-e: :o
22:36:24 <ivanm> then what's the point?
22:36:33 <roconnor> -O2?
22:36:35 <int-e> ivanm: the rule can access it anyway
22:36:39 * roconnor isn't really following
22:36:40 <eck> ivanm: wrt your first comment about reading the whole file, isn't readFile lazy?
22:36:56 <ivanm> eck: wouldn't have a clue
22:37:09 <ivanm> int-e: oh.... so why bring up not exporting it?
22:37:25 <eck> -O2 is also bad
22:37:30 <int-e> ivanm: it means that you can't use it directly.
22:37:54 <int-e> ivanm: which I thought would be a reasonable idea otherwise.
22:37:55 <roconnor> what is being maximumized here?
22:38:04 <scodil> eck: are you compiling that pasted code with -O2? or did you change it to foldl'1 max or something else strict?
22:38:25 <eck> it's the same
22:38:26 <scodil> er, foldl1'
22:38:39 <scodil> modifyIORef is not strict, i don' think. so that's probably it
22:38:58 <int-e> with -O2, print (maximum lineLengths) seems to run nicely in constant memory here (with a large file with short lines)
22:39:04 <scodil> @src modifyIORef
22:39:05 <lambdabot> modifyIORef ref f = writeIORef ref . f =<< readIORef ref
22:40:02 <int-e> same for -O. without -O it leaks memory. All as predicted.
22:40:09 <pantsd_> whats wrong with:
22:40:13 <pantsd_> finduse row i = if  not (1 == (head row)) then i else (finduse (tail row) i+1)
22:41:03 <eck> scodil: i guess that makes sense
22:41:14 <rwbarton> pantsd_: I don't know, what is wrong with it? :)
22:41:26 <pantsd_> wells I also have finduse [] i = -1
22:41:42 <rwbarton> pantsd_: OK, you need parentheses around i+1
22:41:44 <pantsd_> so I expect it to give me -1 if the list is not filled of 1s
22:41:45 <eck> that's sneaky
22:41:56 <pantsd_> ahs
22:41:57 <pantsd_> thanks :)
22:42:14 <pantsd_> yays!
22:43:36 <rwbarton> pantsd_: By the way, you don't need any of the other parentheses except those around "tail row" :)
22:43:46 <rwbarton> er, and around the argument to not
22:45:39 <int-e> eck: the other way the prograsm can consume a lot of memory is if the input file(s) contain very long lines.
22:46:19 <quicksilver> pantsd_: it is, incidentally, more idiomatic to use patterns than head/tail.
22:46:51 <quicksilver> pantsd_: finduse (1:rs) i = finduse rs (i+1); finduse (_:rs) i = i
22:47:09 <eck> int-e: correct, but that wasn't the case here
22:47:38 <eck> i found this which seems to confirm that the problem is modifyIORef laziness: http://ircarchive.info/haskell/2007/5/1/103.html
22:47:49 <lambdabot> Title: haskell mzero = ArrowMonad zeroArrow mplus (ArrowMonad a) (ArrowMonad b) = Arrow ...
22:49:54 <quicksilver> the only reason to use IORefs is to pass arbitrary bits of state through an IO () callback / inversion of control.
22:50:02 <quicksilver> any other use of them is an error :)
22:50:33 <scodil> quicksilver: no even in that case its still an error. you should curry the state into the callback :)
22:51:07 <quicksilver> scodil: well my intended meaning was that that was an API you didn't control.
22:51:09 <scodil> er, partially apply. i guess thats a misuse of the verb curry
22:52:15 <scodil> quicksilver: yeah I know what you meant. if the library wants a callback of type a -> IO (), and you have state of type s, make your callback type s -> a -> IO (), fix s when you set the callback, and bind a new handler with new state in the callback.
22:52:35 <quicksilver> scodil: and how does that allow the callback to change the state?
22:52:48 <scodil> the callback re-binds itself
22:53:03 <quicksilver> ah well, that assumes the API permits rebinding.
22:53:17 <scodil> rebinding is just binding again
22:53:18 <quicksilver> 'forM_', for example, does not.
22:53:42 <quicksilver> [although it's not a particularly good example because it's monad-polymorphic so you can just run it in a different monad]
22:53:55 <scodil> oh I thought you were talking about C libraries
22:53:56 <quicksilver> but plenty of APIs use inversion of control without giving you a way to 'rebind the callback.
22:53:58 <scodil> gtk and whatnot
22:54:28 <scodil> haskell APIs? Or foreign ones?
22:54:31 <quicksilver> both.
22:55:07 <quicksilver> also, merely allowing the callback to rebind itself doesn't propagate the new state to code outside the callback.
22:55:52 <scodil> i think we're thinking of different things when we say callback
22:56:01 <quicksilver> perhaps.
22:56:11 <quicksilver> Inversion of control is a general technique, and my remark was a general one.
22:56:23 <quicksilver> it may be true that well designed libraries don't have this problem.
22:56:26 <quicksilver> but that's not my point.
22:56:37 <quicksilver> My point is that the problem exists, and that's when you use IORefs :)
22:56:48 <scodil> so whats an example of a library that forces you to use IORefs?
23:04:06 <quicksilver> scodil: nothing springs to mind.
23:04:21 <quicksilver> scodil: but an over-specialised forM_ would be a good example.
23:05:17 <scodil> lucky for us haskellers love folds
23:05:38 <quicksilver> right.
23:05:49 <quicksilver> certainly it's not scalable to avoid using IORefs in GLUT, say
23:05:57 <quicksilver> because every callback has to know about every other callback
23:06:04 <humasect> @src foldl'
23:06:04 <lambdabot> foldl' f a []     = a
23:06:04 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
23:06:05 <quicksilver> in order to rebind every one with the new state
23:07:35 <scodil> right. you can use them to fashion a pretty clean state machine, though
23:07:49 <scodil> built of course with an IORef :)
23:41:36 <ac> humasect: still around
23:41:57 <humasect> yep ^_^
23:42:16 <ac> humasect: I meant I was. you asked how long I was going to be around. What's up?
23:42:53 <humasect> ahh. well, it looks like it may definately be open in less than 2 weeks
23:44:25 <ac> humasect: so what's the story with this project?
23:46:39 <humasect> hm.. can you be more specific ? =)
23:47:37 <ac> humasect: the motivation, who's paying for it (if anybody)
23:50:20 <humasect> ah, the motivation: available tools for any platform are insufficient, overly complicated and overdesigned, yet not exactly flexible and powerful enough; for ... well game development is the target because it is a fantastic demographic and thorough testing ground. also they don't need millions of dollars and 50 employees to make. where the programming language meets video, audio, input; is where the relationship of human and compute
23:51:03 <ac> humasect: yeah I agree. The most important libraries are for video and audio
23:51:05 <humasect> it is not paid for, but there is a kind of investor.
23:51:09 <humasect> yes indeed
23:51:18 <humasect> you are interested in this kind of thing?
23:51:36 <ac> definitely...  that's why I'm curious about this project
23:52:16 <humasect> ah, cool, i see
23:52:58 <humasect> i just have to finish up the rework of some of the rendering and editing of procedurals within the editor
23:53:12 <humasect> also i am not sure why it is ultra fast. hehe
23:55:28 <jeffz> humasect: are you working on a game or tools for game development?
23:55:30 <humasect> it is very matured, there just needs the first game project (gb) to implement the rest (sugar mostly)
23:55:35 <humasect> both
23:55:58 <jeffz> ah, I'm trying my hand at creating a game too.
23:56:08 <humasect> ah, i see ^_^ how is that going ?
23:56:32 <humasect> this project would not be possible without haskell, that has been very clear always
23:57:08 <jeffz> well, it's a 2d game, so I've mostly been doing sketches and a bit of a mockup on paper what I think the code will look like
23:57:27 <humasect> ahh, i see
23:57:39 <humasect> these tools are focused on 2d
23:57:46 <humasect> well, 2 dimensions.
23:58:28 <hackage> Uploaded to hackage: OneTuple 0.1.0
23:58:57 * humasect found (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,) in GHC.Tuple yesterday .. hehe
23:59:21 <ac> that's absurd
23:59:45 <Baughn> Yes, but where would you draw the line?
23:59:58 <Baughn> ..though I suppose the most absurd part is that it can't generate them lazily
