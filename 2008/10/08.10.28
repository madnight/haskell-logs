00:02:47 <johnsons> DCC SEND "readerror" 0 0 0
00:08:36 <mmorrow> http://www.unsafecoerce.com/
00:09:34 <mmorrow> http://www.unsafecoerce.com:8080
00:10:09 <mmorrow> (unsafecoerce.com points to moonpatio.com at the moment, so that hpaste2 is reachable at 8080)
00:10:12 <sleven> im learning a little perl fort the first time. holy shit that language is ugly. why would haskellers ever want to use that for scripting?
00:10:18 <sleven> python is ooo much cleaner
00:10:44 <mmorrow> perl is teh awesome :)
00:10:50 <loop_> perl is good for oneliners
00:11:44 <mmorrow> perl -lne '/(asdf)/; print $1'
00:11:51 <mmorrow> is one that i use a bunch
00:12:12 <loop_> grep isn't good enough?
00:12:18 <mmorrow> pretty much the only perl is write anymore actually
00:12:25 <solrize> http://blog.malde.org/index.php/2008/10/24/optimization-again-befuddled-by-bytestrings/   uggghhhh
00:12:25 <rwbarton> mmorrow: make unsafecoerce.com an analogue of foldr.com
00:12:28 <lambdabot> Title: BHLog Â» Optimization again: befuddled by bytestrings, http://tinyurl.com/6pscg6
00:12:28 <Adamant> perl is bad, throw rocks at it
00:12:40 <viklund> hey, whats wrong with: @p>>+=<<@s ?
00:12:46 <viklund> ;)
00:13:01 <mmorrow> loop_: the perl regexes are more powerful than grep's
00:13:24 <mmorrow> rwbarton: heh, i was just thinking something along those lines myself
00:14:16 <mmorrow> oh yeah, i meant
00:14:17 <loop_> mmorrow: btw. 'print if /(asdf)/' is nicer imho ;-)
00:14:20 <mmorrow> perl -lne '/(asdf)/g; print $1'
00:16:18 <mmorrow> perl -lne 's/\"0?(\d)\//\"0$1\//g; s/\/0?(\d)\//\/0$1\//g; s/(\d{2})\/(\d{2})\/(\d{4})/$3$1$2/g; print'
00:16:20 <mmorrow> hehe
00:16:42 <quicksilver> sleven: the main reason to use perl, IMO, is CPAN
00:16:52 <quicksilver> i.e. the volume of libraries available for it.
00:18:22 <sleven> quicksilver, i see
00:18:23 <jsn> the great problem with good libraries for your current favorite language is you can't take them to the next one :(
00:19:20 <sleven> python regexen vs perl regexen?
00:20:02 <sleven> i really like the word regexen, sounds very cathedral-lish and heretic
00:20:25 <mmorrow> what is the "word regexen"?
00:20:55 <quicksilver> sleven: personally I don't find the differences between python and perl interesting.
00:21:05 <quicksilver> from where I look at them, they are basically the same language.
00:21:22 <olsner> mmorrow: the word "regexen" is "regexen" :P
00:21:38 <quicksilver> there are some trivial syntactic differences, and python has a built-in object system which is rather like the one many people choose to use in Perl.
00:21:52 <mmorrow> ohhh, haha
00:21:56 <quicksilver> of course, some people spend weeks arguing about the differences
00:22:02 <quicksilver> so they obviously matter to some people :)
00:22:27 <mmorrow> i like perl precisely because it's friggin nuts
00:22:51 <mmorrow> (refering to perl5)
00:23:08 <mmorrow> i don't know particulars of any others..
00:23:16 <sleven> quicksilver: i will impale you and eat your intestines for that
00:23:37 <mmorrow> organ popsicle?
00:23:48 <sleven> lol
00:24:42 * quicksilver shrugs
00:25:17 <quicksilver> I have nearly 20 years experience of watching language debates play out.
00:25:22 <quicksilver> I've got bored of most of the arguments.
00:26:29 <sleven> impaling too?
00:26:32 <ski> (sleven : not "regices", then ?)
00:26:38 <Adamant> quicksilver: it does get old after a while.
00:26:41 <sleven> yes i see your point, wrong channel anyway
00:26:53 <sleven> ski: nah regexen has a nice feel to it
00:27:25 <quicksilver> @tell dons did you see the report of a weird performance regression in Data.Binary in 6.10?
00:27:26 <lambdabot> Consider it noted.
00:28:45 <sleven> where did you say cabal-install is on ubuntu?
00:28:52 <sleven> after installing obv
00:36:16 <sleven> my rc profile?= where is that on ubuntu? i need to put th path to cabal-install there
00:47:42 <sleven> i cant find the path to cabal-install
00:50:29 <kowey> oh nice; wxhaskell now has xrc support (which allows for things like wxGlade)
00:53:40 <sleven> if cabal-install works i just type: cabal-install GLUT right?
00:53:50 <dons> yup
00:53:50 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
00:54:00 <dons> even, cabal install glut
00:54:07 <sleven> export "/home/user/.cabal/bin:$PATH" <- added that to .bashrc
00:54:11 <dons> yup
00:54:17 <sleven> doesnt work
00:54:22 <dons> its an interesting question, why we'd need to add that.
00:54:34 <dons> $ cabal install glut
00:54:37 <dons> -- works for me.
00:55:56 <sleven> i dont have a folder .cabal in my home/user/
00:56:16 <sleven> yes i have
00:56:56 <dons> it'll be created when needed
00:57:08 <sleven> it is there
00:57:13 <sleven> no i cd into the dir
00:57:18 <sleven> and even there i cant do cabal
00:57:23 <sleven> but the file cabal is there
00:57:45 <sleven> i dont need ghc right?
00:57:57 <sleven> i mean when using cabal, i have ghc obv
00:57:59 <dons> sure you do. it helps keep the world going round :)
00:58:11 <dons> cabal compiles the code with ghc
00:58:22 <sleven> export "/home/user/.cabal/bin:$PATH"
00:58:23 <sleven> or
00:58:29 <sleven> export /home/user/.cabal/bin:$PATH ?
00:58:45 <dons> export PATH=/home/$USER/.cabal/bin:$PATH
00:58:52 <Cale> Though technically cabal is supposed to interoperate with other Haskell compilers, a lot of the stuff on Hackage requires GHC to build.
00:59:27 <sleven> still doesnt work
00:59:45 <rwbarton> If I want to build stuff on hackage for other compilers, though, does cabal install make it easy?
01:00:11 <dons> sleven: you'll need to say why it doesn't work
01:00:19 <dons> "doesn't work" is the /dev/null of bug reports
01:00:28 <dons> rwbarton: yeah, it supports whatever compiler you've got
01:00:36 <dons> hugs and nhc, in particular
01:00:41 <Cale> rwbarton: you're supposed to be able to pass an appropriate flag to cabal install
01:00:53 <Cale> rwbarton: like --nhc98 or --jhc etc.
01:00:53 <dons> and in fact, you can (i build bytestring for hugs with cabal)
01:01:03 <Cale> ah, cool
01:01:52 <Cale> When asked to build something for Hugs, does cabal just copy the sourcecode somewhere? :)
01:02:30 <sleven> dons:  command not found
01:02:46 <sleven> for cabal and cabal-install
01:03:00 <Cale> sleven: aha, you should install cabal-install then :)
01:03:04 <sleven> all i need is add to .bashrc and save tha fle right?
01:03:27 <sleven> i did
01:03:32 <sleven> or was it just cabal?
01:03:35 <Cale> sleven: you might need to restart your shell if you haven't run that command
01:03:45 <Cale> The executable is just called cabal
01:04:17 <sleven> pfft now it works
01:04:24 <sleven> no command given
01:04:36 <sleven> but cabal-install is that used as: cabal install?
01:05:02 <rwbarton> Cale: heh :)
01:05:21 <Cale> yes
01:05:30 <Cale> cabal install packagefoo
01:05:40 <sleven> blarf
01:05:47 <sleven> configure: error: no OpenGL headers found, so this package cannot be built
01:05:49 <rwbarton> Cale: I currently have no idea how packages work in any compiler other than ghc, but I have a project that will use the javascript backend to yhc or hugs
01:06:09 <sleven> cabal should figure out all dependencies right?
01:06:37 <sleven> same for cabal install OpenGL
01:06:39 <Cale> sleven: sudo apt-get install libgl-dev ?
01:06:54 <Cale> sleven: Not if there are C libraries which are required for bindings.
01:07:10 <quicksilver> there are.
01:07:18 <sleven> You should explicitly select one to install.
01:07:19 <sleven> E: Package libgl-dev has no installation candidate
01:07:52 <quicksilver> probably libgl1-mesa-dev
01:07:55 <quicksilver> and freeglut-dev
01:08:03 <Cale> Well, right, that one depends on your video driver, doesn't it?
01:08:25 <quicksilver> freeglut3-dev
01:08:29 <quicksilver> no, it doesn't.
01:08:32 <Cale> okay :)
01:08:42 <quicksilver> the dev package - the library headers - are driver independent on linux.
01:09:08 <Cale> Well, there appear to be lots of different versions of nvidia-glx-*-dev here.
01:10:00 <steven_ashley> Hi everyone, Is anyone aware of how I can do a lookup on a Data.Map such that it returns the greatest key/value pair such that the key is less than or equal to the search key.
01:10:22 <steven_ashley> I can't seem to find a function for it though it seems a sensible thing to want to do.
01:10:36 <Cale> steven_ashley: you could split the map, I suppose.
01:10:53 <steven_ashley> ahh yes :)
01:11:43 <Cale> There's splitLookup, which also gives you the element at the given key, if it exists, along with the two halves of the map.
01:12:48 <sleven> where do i import zipWithM_ and replicateM?
01:12:59 <sleven> and do the Ms stand for monad?
01:13:00 <Cale> Control.Monad
01:13:02 <steven_ashley> Cale: cheers for your help :)
01:13:10 <Cale> steven_ashley: no problem :)
01:14:02 <sleven> thanks cale, quick and the rest
01:14:13 <sleven> woot i can do grpahics on Ubuntu!!!!!!!
01:14:20 <Cale> :)
01:14:53 <steven_ashley> OpenGL rocks in haskell :)
01:16:08 <sleven> yes
01:16:11 <Cale> I have a feeling that it could rock even more, but that nobody as far as I know has gotten around to writing quite the appropriate library. :)
01:17:55 <sleven> i want to write a raytracer eventually, or raycaster
01:18:08 <sleven> tried some examples on windows that didnt work
01:18:48 <steven_ashley> I wrote a little data-structure describing scenes and transformations and had an interpreter thing that examines it and calls the appropriate GL commands, it worked quite nicely because it allowed me to visualize the scene in other ways (besides GL).
01:18:55 <Cale> It's a fun thing to do in Haskell. I've written a couple which mostly did spheres, which took about a page of Haskell code each :)
01:19:09 <steven_ashley> and it makes the scene code completely pure ;)
01:19:15 <steven_ashley> nice :)
01:19:21 <Cale> steven_ashley: Yeah, that's closer to what I'm thinking of :)
01:19:50 <Cale> A purely functional library for describing 3D geometry, texturing and lighting and stuff like that :)
01:20:05 <steven_ashley> yep :)
01:23:30 <sleven> http://www.haskell.org/tmrwiki/HRay
01:23:31 <lambdabot> Title: HRay - TmrWiki
01:23:33 <Cale> My favourite scene to test raytracers involves just 4 spheres (of the same radius), 3 lights and the camera, placed at the vertices of a cube such that the 4 spheres are mutually touching each other at a single point.
01:23:54 <sleven> anyone know if the code is somewhere else because the link is dead
01:24:24 <Cale> You end up with a nice fractal of reflections. :)
01:24:48 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HRay
01:24:49 <lambdabot> Title: HackageDB: HRay-1.1.1
01:24:51 <quicksilver> Cale: to answer your question from earlier, the nvidia glx dev pacakges must be interfaces to some specfic extra API.
01:25:02 <Cale> quicksilver: ah, okay
01:25:05 <quicksilver> Cale: but in general, all linux opengl goes through generic interfaces
01:25:12 <quicksilver> Cale: (and therefore we have binary compatibility)
01:25:19 <Cale> That makes sense :)
01:25:30 <quicksilver> otherwise, software would need recompiling for each vendor
01:25:32 <quicksilver> which would suck :)
01:26:10 <Cale> But, but, I thought linux was completely ISV unfriendly? Tuomov! You lied to me!
01:26:13 <quicksilver> ;)
01:26:29 <quicksilver> well it does need recompiling for different libc versions
01:26:37 <quicksilver> which was one of the few sensible things in that debate.
01:26:53 <quicksilver> but new (abi incompatible) libc versions don't come out every week.
01:29:51 * dolio is confused by the prime factorization discussion on the cafe.
01:30:17 <quicksilver> is that part of the rounding thread?
01:30:19 <Cale> Yeah, libc versions have never posed a big problem to me. I think if you stay reasonably up to date in terms of your distribution's version, things generally just work.
01:30:23 <dolio> Yeah.
01:30:32 <quicksilver> that thread has gone seriously off the rails
01:30:43 <quicksilver> the total content in it is about 3 sentences.
01:31:01 <quicksilver> Yes this is a standard way. No it's not the only standard way. Yes there are arguments for both alternatives.
01:31:29 <jeffz> I've been bitten by a libc change before, during an upgrade between ubuntu versions, ubuntu forced a libc ugprade when the kernel was the wrong version.  broke horribly.
01:32:02 <dolio> Yeah, basically.
01:32:14 <quicksilver> conversely, I had a machine with 500 days uptime which went through 2 major libx upgrades
01:32:18 <quicksilver> without ever needing rebooting :)
01:32:34 <dolio> But somehow someone decided to complain that 1 can be included infinitely many times in a prime decomposition, despite not being prime...
01:32:41 <dolio> Or something like that. It's hard to say.
01:32:53 <quicksilver> reminded me of the useless arguments on sci.math
01:33:02 <quicksilver> about whether cantor's diagonlisation is valid.
01:36:24 <dolio> Yeah. That gets discussed a lot.
01:36:53 <dolio> That and how lazy mathematicians are for not bothering to prove their axioms.
01:37:15 <quicksilver> lazy's a good thing, right?
01:37:58 <dolio> Not in the opinion of the person forwarding the argument, I think.
01:39:29 <dolio> All right. What GHC 6.10 user wants to help me out?
01:40:52 <rwbarton> About the prime decompositions, I've been assuming that one participant in the discussion is trying to be witty, and failing.
01:41:13 <Baughn> dolio: Sorry, "prove" axioms?
01:41:17 <dolio> Yeah, I can't tell if he's serious or not. I think there may be a language barrier.
01:41:39 <dolio> Baughn: Yeah, if mathematicians weren't so lazy/dumb, all their axioms could be theorems instead.
01:41:45 <dobblego> is there a document that explains why resolving software dependencies is NP-complete (my intuition says otherwise)?
01:42:30 <jsn> > reads ['a','\\','n','b']
01:42:31 <lambdabot>   []
01:42:32 <Baughn> dobblego: Try asking your intuition to embed an np-complete problem in dependency resolution
01:42:47 <Baughn> dolio: You're joking, right?
01:42:54 <quicksilver> dobblego: well I think for np completeness you need each package to be available in 'n' different versions
01:43:03 <dolio> Dependency resolution seems like a good candidate for embedding some nasty graph algorithm.
01:43:19 <quicksilver> dobblego: and you need the dependency of one package to be an arbitrary subset of the possible versions of another
01:43:27 <dolio> Baughn: I don't believe that. But I've seen people argue for it on sci.math.
01:43:48 <dolio> sci.math has a lot of nuts.
01:43:53 <Baughn> dolio: That should be a FAQ
01:44:00 <dobblego> quicksilver, in that case, won't a resolver simply because the "latest" version?
01:44:11 <dobblego> s/because/choose (oops)
01:46:17 <Baughn> dobblego: No, since other packages may conflict with that latest version
01:47:01 <Baughn> dobblego: Given support for conflicts, you can actually embed just about any algorithm in package graphs, so.. yeah. NP-complete, easily
01:47:01 <dobblego> Baughn, what if you assume that a later version of a package is always an improper superset of functionality of earlier versions?
01:47:26 <Baughn> dobblego: Then you're breaking the definition of "package manager" that was used to declare them NP-complete
01:47:38 <Baughn> dobblego: Practically speaking, though, they /aren't/
01:47:42 <Baughn> Look at base-4 vs. base-3
01:47:51 <dobblego> what is base-4, base-3?
01:48:21 <Baughn> base-4 is the base library version that's bundled with ghc-10. base-3 is the ghc-8 one, but is still bundled with ghc-10, so..
01:48:30 <Baughn> Many libraries conflict with base-4
01:48:59 <dobblego> then, is there a reasonable approximation that is tractable?
01:49:11 <Baughn> Sure. *Solve* the nice np-complete problem.
01:49:41 <Baughn> Humans are the ones making the dependencies, and they rarely make anything that's hard to resolve - you really have to /try/.
01:50:13 <dobblego> you mean, in practice, although it is NP-complete, it is still feasible?
01:50:30 <Baughn> Yep
01:50:30 <dolio> Just like you almost never run into exponential behavior with your haskell type checking.
01:50:41 <dobblego> ok understood
01:50:44 <dobblego> thanks for the explanation
01:51:15 <mmorrow> mindmelting perl repl http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=315
01:51:19 <Baughn> It's just something to keep in mind, but I've never yet seen an unfeasible dependency graph in the wild
01:51:38 <mmorrow> i can't figure out how to not have it die if the call to eval errors out
01:51:41 <mattam> Baughn: people working in this project have: http://www.edos-project.org/xwiki/bin/view/Main/Wp1
01:51:55 <lambdabot> Title: EDOS - Wp1
01:51:57 <mmorrow> preflex: seen mauke
01:51:57 <preflex>  mauke was last seen on #perl 11 hours, 9 minutes and 10 seconds ago, saying: eval: sub x { my $fmt = shift; sprintf $fmt, @_ }; $thing='dummy'; $number=3.1415;  qq(I'm a ${\x"%-20s", $thing}, I like ${\x"%15s", "Pie"}, my favorite number is ${\x"%4.6f", $number}\n)
01:52:00 <mattam> They reduce a package installation problem to SAT :)
01:52:23 <rwbarton> Hmm... it would make an interesting denial of service attack on Hackage... :)
01:52:29 <Baughn> mattam: Naturally
01:52:40 <Baughn> rwbarton: Does hackage actually resolve dependencies at any point?
01:52:57 <dolio> mmorrow: Go to http://code.haskell.org/~dolio/ , darcs get bytestring-show, and tell me if it builds on 6.10.
01:52:57 <lambdabot> Title: Dan Doel's Haskell Hacking
01:53:04 <rwbarton> Baughn: Well, probably not, but if people can't install things from it, it's not serving its purpose
01:53:27 <Baughn> rwbarton: They'll only be unable to install the particular poisoned packages, though
01:53:29 <rwbarton> I guess cabal install doesn't need to consider every package, though
01:53:33 <Baughn> Right
01:53:50 <Baughn> A larger problem is that hackage doesn't assign ownership to packages, so you can overwrite anyone's code with your own. ^^;
01:53:56 <mmorrow> dolio: will do, cowboy
01:54:00 <dolio> :)
01:54:19 <mmorrow> heh
01:55:53 <mmorrow> Setup: At least the following dependencies are missing:
01:55:53 <mmorrow> integer-gmp -any
01:56:03 <mmorrow> [m@ganon bytestring-show]$ ghc-pkg list integer
01:56:06 <dolio> Hmm...
01:56:07 <mmorrow> integer-0.1.0.0
01:56:34 <mmorrow> ooh
01:56:38 <dolio> Bah. Stupid directory names.
01:56:44 <mmorrow> i changed it to integer and (i'll paste)
01:58:06 <mmorrow> http://hpaste.org/11542
01:58:49 <dolio> Hmm, all right.
01:59:38 <mmorrow> ah
01:59:39 <mmorrow> quotRemInteger :: Integer -> Integer -> (# Integer, Integer #)
01:59:39 <mmorrow>         -- Defined in GHC.Integer
02:00:36 <mmorrow> here's a :browse of GHC.Integer http://hpaste.org/11542#a1
02:01:09 <dolio> Yeah, I have the code. I just don't feel like installing it at the moment.
02:01:19 <dolio> Plus, I need to kee 6.8 around to make sure it still builds on that.
02:02:02 <dolio> So, if you change Text.Show.ByteString.Integer to import GHC.Integer in the INTEGER_GMP case, and GHC.Num in all cases, does that solve things?
02:03:09 <dolio> Actually, forget about importing GHC.Integer explicitly, GHC.Num re-exports it.
02:07:18 <sleven> is perl weakly typed? i mean it converts "3 hello" to 3 when use with print but it does so predictably
02:07:37 <mmorrow> dolio: heh, i just saw that (the re-export)
02:07:44 <dolio> Huh, GHC.Integer exports the Integer constructors, but GHC.Num doesn't, despite re-exporting the module?
02:07:57 <mmorrow> grrr
02:07:59 <quicksilver> Baughn: well time proportional to (2^(2^n)) is fine if n turns out to be 3.
02:08:13 <quicksilver> Baughn: and the constant factor is in the microseconds :)
02:11:11 <Baughn> quicksilver: I know, I know, but that function there still makes me wince every time I glance at it
02:12:30 <quicksilver> sleven: http://www.pphsg.org/cdsmith/types.html
02:12:31 <lambdabot> Title: Chris Smith's Personal Web Site - Ideas - What to Know Before Debating Type Syst ...
02:12:39 <quicksilver> sleven: read that before using the phrase 'weakly typed' ;)
02:14:00 <mmorrow> dolio: this works http://hpaste.org/11542#a2
02:15:37 <dolio> Gah, they switched to unboxed tuples?
02:15:56 <mmorrow> sneaky bastards
02:16:17 <dolio> That means my pristine code will be even more sullied by CPP directives.
02:17:26 <mmorrow> hah
02:17:46 <carl_> is there something like split g >>= \(g1, g2) -> i can do to split a random num generater before a function, i know that syntax is used for binding from monads
02:18:24 <mmorrow> @type split
02:18:25 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
02:19:04 <mmorrow> @type let withSplit g k = k (split g) in withSplit
02:19:05 <lambdabot> forall g t. (RandomGen g) => g -> ((g, g) -> t) -> t
02:19:17 <mmorrow> like that?
02:19:53 <carl_> lol probably
02:19:55 <carl_> ill have a play
02:21:15 <mmorrow> , let r = randomRs (0,9::Int) ; withSplit g k = k (split g) in withSplit (mkStdGen 0) $ \(g0,g1) -> zip (r g0) (r g1)
02:21:17 <lunabot>  luna: Ambiguous occurrence `split'
02:21:22 <mmorrow> > let r = randomRs (0,9::Int) ; withSplit g k = k (split g) in withSplit (mkStdGen 0) $ \(g0,g1) -> zip (r g0) (r g1)
02:21:23 <lambdabot>   [(7,2),(9,1),(8,4),(2,2),(4,2),(0,3),(8,2),(1,6),(6,5),(7,9),(6,6),(9,3),(8...
02:21:39 <mmorrow> cool. i've never used split before
02:22:05 * dancor used split heavily before discovering Control.Monad.Random
02:24:39 <mmorrow> > let r = randomRs (0,9::Int) ; withSplit g k = k (split g) in withSplit (mkStdGen 0) $ \(g0,g1) -> sum (take 100000 $ zipWith ((^2) . subtract) (r g0) (r g1))
02:24:40 <lambdabot>       No instance for (Num (Int -> Int))
02:24:40 <lambdabot>        arising from a use of `^' at ...
02:24:55 <mmorrow> > let r = randomRs (0,9::Int) ; withSplit g k = k (split g) in withSplit (mkStdGen 0) $ \(g0,g1) -> sum (take 100000 $ zipWith (((^2) .) . subtract) (r g0) (r g1))
02:24:59 <lambdabot>   1647772
02:25:03 <mmorrow> err
02:26:21 <mmorrow> > let r = randomRs (0,9::Int) ; withSplit g k = k (split g) in withSplit (mkStdGen 0) $ \(g0,g1) ->  ((/100000) . fromIntegral . sum) (take 100000 $ zipWith ((abs .) . subtract) (r g0) (r g1))
02:26:25 <lambdabot>   3.2966
02:26:39 <dolio> mmorrow: All right. Mind pulling to make sure I've got everything in order?
02:26:47 <mmorrow> oh, that's a useless number
02:26:58 <mmorrow> dolio: fo sho
02:28:53 <mmorrow> heh, looks like you forgot a '->'
02:28:54 <mmorrow> Text/Show/ByteString/Integer.hs:69:2: Parse error in pattern
02:29:33 <mmorrow> adding that, it builds flawlessly
02:29:45 <dolio> Just missing the ->?
02:30:11 <mmorrow> yeah
02:30:16 <dolio> Okay.
02:31:55 <mmorrow> hmm, that'd be sweet if there was a ByteString Text.PrettyPrint.HughesPJ
02:33:18 <mmorrow> i wonder how tough tough it'd be to adapt the autoderiving Show code in Data.Derive to your Show
02:33:50 <dolio> Yeah, I've been meaning to get to some Derive stuff for it.
02:35:03 <mmorrow> i'd totally run that over all of the std libs and only use the ByteString Show from then on
02:36:03 <quicksilver> mmorrow: ByteStrings are quite a bit less efficient than String for strings less than (say) 10 chars
02:36:21 <dolio> It's actually not faster than Strings in my experience.
02:36:32 <mmorrow> hmm
02:36:40 <dolio> It's just faster than pack . show.
02:37:06 <mmorrow> i bet it'd be a gain if the datatype you're showing is massive (?)
02:37:31 <dolio> I haven't done a lot of work optimizing, though, so I don't know if I'm doing something wrong, or if Binary just has more overhead for this kind of thing.
02:37:38 <mmorrow> like say for instance the parsed AST of a 1000 line module
02:38:16 <dolio> Well, I don't know about that. But, for instance, printing the new Mersenne prime with just print is faster than the print in my library.
02:38:28 <mmorrow> hmm
02:40:56 <dolio> Sometimes it about ties. Like showing floating point numbers, since I more or less lifted the GHC algorithm, and it spends a lot of its time manipulating lists of digits before actually printing anything.
02:45:47 <quicksilver> mmorrow: as a general rule bytestrings are more memory compact, but slower, than strings
02:46:04 <quicksilver> the corrolary, of course, is that they are faster when memory bandwidth was your limiting factor
02:46:13 <quicksilver> which is a fairly common occurance but by no means universal
02:46:15 <mmorrow> dolio: i was just about to ask you about that. http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=317#a317
02:46:27 <quicksilver> (and clock multipliers seem to be dropping again? the new macs are only x2)
02:46:51 <mmorrow> quicksilver: slower?
02:47:01 <mmorrow> i don't think i understand
02:48:44 <quicksilver> why should you understand?
02:48:46 <quicksilver> I didn't explain.
02:48:51 <quicksilver> I just stated a fact.
02:48:52 <quicksilver> ;)
02:49:01 <mmorrow> dolio: ah, i see now. i didn't recognize the modified-for-Put functions at first
02:49:09 <mmorrow> quicksilver: heh
02:49:31 <mmorrow> well, so why are they slower?
02:49:50 <quicksilver> because of the overhead of unpacking bytes
02:49:55 <quicksilver> into something you can actually work with
02:49:58 <quicksilver> and (possibly) packing them back
02:50:21 <mmorrow> i don't see why you have to unpack anything though
02:50:49 <mmorrow> err, well i'm thinking in the context of a  show :: a -> ByteString
02:51:25 <quicksilver> well in that case you have to pack
02:51:35 <mmorrow> yeah, true
02:52:13 <dolio> Yeah. Instead of show incrementally building a string...
02:52:23 <dolio> showp builds a Put, which then builds a byte string.
02:53:01 <mmorrow> i wonder if you could just allocate a chunk of mem, then just writeWord8Off to fill it as you traverse your "a" and show it
02:54:08 <dolio> I don't really relish the idea of doing that.
02:54:14 <quicksilver> that is roughly what the Put monad tries to do, mmorrow
02:54:29 <quicksilver> if the compiler optimises everything as it is hoped to
02:54:30 <mmorrow> dolio: yeah, only pain awaits down that road
02:54:38 <mmorrow> but speed too
02:54:54 <quicksilver> but the basic problem is that your "a" still has stuff expanded 'out' in nice haskell strcutures
02:55:01 <mmorrow> quicksilver: i've been meaning to look at the Data.Binary code to see what it's doing
02:55:06 <quicksilver> and you still have to pull parts out, encode them as bytes, and push them in
02:55:14 <quicksilver> however you play it there is still work to do.
02:55:40 <quicksilver> in C librariess doing stuff like this, things are often encoded as bytes in the 'source' as well
02:55:48 <quicksilver> it it degenerates to a bunch of carfully chosen memcpys
02:55:53 <mmorrow> ahh
02:57:46 <mmorrow> oh ok. so the real gain is when you're going to (pack . show) anyway.
02:59:05 <mmorrow> i guess the bottleneck is in the IO in the end, so that seems to me to be a definite gain
02:59:39 <mmorrow> like, ByteString.readFile is blazingly fast compared to Prelude.readFile
02:59:42 <dolio> pack . show isn't really correct, either.
03:00:17 <dolio> It'd need to be 'utf8Encode . show' or similar, in which case it's probably even better.
03:00:43 <mmorrow> ooh, true. unicode and all that
03:00:45 <dolio> Since I don't check for Unicode in places where I know I don't need to.
03:00:45 <quicksilver> mmorrow: BS.readFile isn't necessarily "blazingly fast" compared to Prelude.readFile.
03:01:06 <quicksilver> mmorrow: in some kinds of circumstances it's just a few % faster
03:01:14 <quicksilver> it does rather depend what you're doing
03:01:25 <quicksilver> like I said before, it depends how important memory compactness is.
03:01:40 <mmorrow> quicksilver: true. but if you're reading 100MB..
03:01:51 <mmorrow> yeah
03:02:12 <mmorrow> so i guess "fast" is the wrong word
03:07:15 <Leaves> hello, do you know why I can't do :t concat . map in ghci? (I was expecting (a -> [c]) -> [a] -> [c])
03:07:45 <quicksilver> Leaves: because map takes two parameters, basically
03:07:58 <quicksilver> Leaves: you can "concat . map f" for some function f
03:08:04 <Deewiant> (concat . map) x y  -->  concat (map x) y
03:08:08 <quicksilver> or you can make that a parameter itself
03:08:28 <quicksilver> :t \f -> concat . map f
03:08:29 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
03:08:37 <mmorrow> :t (concat .) . map
03:08:38 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
03:09:18 <mmorrow> @pl \a b c -> g (f a b c)
03:09:19 <lambdabot> ((g .) .) . f
03:09:26 <mmorrow> @pl \a b c d -> g (f a b c d)
03:09:26 <lambdabot> (((g .) .) .) . f
03:09:58 <Deewiant> ((concat .) . map) x y  -->  ((concat .) (map x)) y  -->  (concat . map x) y  -->  concat (map x y)
03:10:00 <Leaves> ok, so when I do (f . g) g aslways must take only one argument?
03:10:35 <Leaves> but (map . map) does work
03:10:44 <mmorrow> well, without knowing the types of f and g, you can't know for sure
03:11:01 <mmorrow> , (map . map) (*2) [[0..4],[6,7,43,4]]
03:11:05 <lunabot>  [[0,2,4,6,8],[12,14,86,8]]
03:11:24 <mmorrow> , (map . map . map) (*2) [[[2]],[[0..4],[6,7,43,4]]]
03:11:26 <lunabot>  [[[4]],[[0,2,4,6,8],[12,14,86,8]]]
03:14:59 <Leaves> I think I may see the difference, (map f) is a functionwith type [a] -> [b], so it can be the first argument of another map, thus (map .map) works, but (concat . map) does not work since (map f) :: [a] -> [b] (with b = [c]) while it should be [b], so it can not be the argument of concat..
03:15:32 <mmorrow> exactly
03:15:33 <Cale> Leaves: In some sense, every function in Haskell has exactly one parameter
03:16:20 <mmorrow> a -> b -> c -> d  <====> a -> (b -> (c -> d))
03:17:11 <Leaves> ok, and when doing f . g . h one should put the first argument in h, then put the result as the first arg in g, then that result as the first argument in f and then the rest of the argument in f?
03:17:29 <mmorrow> yes
03:17:41 <Cale> (f . g . h) x = f (g (h x))
03:17:42 <Deewiant> (f . g . h) x y z = f (g (h x)) y z
03:17:44 <Leaves> ok, that was not clear to me
03:18:07 <Deewiant> > (f . g . h) x y z :: Expr
03:18:08 <lambdabot>   Add a type signature
03:18:11 <Deewiant> :-/
03:18:43 <Leaves> ok, it's all clear to me now, thanks for the help!
03:18:50 <mmorrow> :)
03:33:24 <Taejo> I was rereading the FDIP paper yesterday, and wondering if it was ever going to be included in GHC
03:33:30 <Taejo> does anyone know?
03:35:43 <quicksilver> we can't see the future :)
03:36:59 <quicksilver> Taejo: the closest thing I've seen to discussion of future ghc priorities is the periodic HCAR roundups
03:37:41 <quicksilver> and FDIP wasn't mentioned in the last hcar
03:37:48 <Taejo> ok
03:38:27 <Saizan> FDIP?
03:38:47 <Taejo> Saizan: Feedback-directed implicit parallelism
03:39:14 <Taejo> basically, the compiler profiles your code, and uses that to add par combinators
03:39:31 <Saizan> i see
03:39:47 <Taejo> Saizan: there was a paper at ICFP 2007
03:47:38 <Peaker> quicksilver: http://www.pphsg.org/cdsmith/types.html  lies about the type of Data.Map.lookup ;-)
03:47:39 <lambdabot> Title: Chris Smith's Personal Web Site - Ideas - What to Know Before Debating Type Syst ...
03:47:50 <Peaker> (or did Data.Map.lookup once return any monad, and changed to return Maybe only?)
03:47:56 <Deewiant> yes, changed in 6.10
03:48:11 <quicksilver> Peaker: yes, I know, it's embarassing isn't it?
03:48:33 <quicksilver> but, ah well.
03:48:37 <quicksilver> things change :)
03:48:44 <BONUS> Data.Map returns Maybe now?
03:48:49 <Deewiant> yep
03:48:55 <BONUS> interesting
03:49:13 <BONUS> maybe it would have been better if it returned monadplus though?
03:49:24 <quicksilver> no.
03:49:28 <quicksilver> @quote mckinna
03:49:28 <lambdabot> mckinna says: you don't need to produce elements of an *arbitrary* whatever-it-is when you can produce elements of the *initial* whatever-it-is
03:49:47 <BONUS> hmm
03:49:58 <BONUS> yeah anyway it's better than just doing Monad m like it did until now
03:50:11 <quicksilver> Maybe is the correct type because it describes precisely what it is.
03:50:29 <quicksilver> MonadPlus is just adding false generality.
03:50:35 <Cale> An arbitrary MonadZero wouldn't be so bad either, but Maybe is probably best.
03:50:49 <quicksilver> you can always use (maybe mzero return)
03:50:55 <Cale> (and we don't have MonadZero for the time being)
03:51:21 <Peaker> Why aren't catamorphisms auto-generated from data declarations?
03:51:49 <Cale> That is an excellent question. They could be.
03:52:04 <Cale> We could even have a special syntax to make them look nice in general.
03:52:19 <dolio> Just lift that out of Charity.
03:52:28 <Kvasir> catawhat?
03:52:44 <Peaker> Kvasir: functions like maybe for data types like Maybe
03:52:56 <Cale> Kvasir: Catamorphisms are functions which essentially replace the constructors of a datatype with other functions or values.
03:53:13 <Kvasir> ok
03:53:18 <Cale> For instance, foldr f z replaces each (:) in a list with the function f, and the [] at the end with z
03:53:29 <Deewiant> http://www.haskell.org/haskellwiki/Zygohistomorphic_prepromorphisms
03:53:36 <lambdabot> Title: Zygohistomorphic prepromorphisms - HaskellWiki, http://tinyurl.com/66ubol
03:53:47 <Cale> maybe z f replaces Nothing with z and Just with f
03:54:36 <Cale> and of course, for various tree datatypes, you can imagine writing a function which replaces the branch nodes with functions and the leaves with values or functions as appropriate.
03:55:18 <Peaker> Kvasir: you can consider it a function that takes a function for each possible pattern-match on the type, then applies the appropriate function and returns its result.  Its sort of an alternative to exhaustively pattern-matching
03:56:01 <Peaker> @type maybe
03:56:02 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
03:56:04 <Peaker> @src Maybe
03:56:05 <lambdabot> data Maybe a = Nothing | Just a
03:56:17 <Cale> Peaker: not just that though, since it does so recursively
03:56:59 <Peaker> @type foldr
03:57:00 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
03:57:03 <Peaker> @src []
03:57:03 <lambdabot> data [] a = [] | a : [a]
03:57:20 <Peaker> foldr is flipped catamorphism ;)
04:00:04 <Peaker> Haskell's syntax is so extensible that pretty much every combination is already taken. Hard to extend that syntax now...
04:00:28 <Peaker> Is @ allowed as an operator?
04:00:56 <EvilTerran> no
04:01:05 <EvilTerran> it'd be ambiguous with as-expressions
04:01:29 <EvilTerran> > let a@(b,c) = (True,"foo") in (a,b,c)
04:01:31 <lambdabot>   ((True,"foo"),True,"foo")
04:03:06 <Peaker> Haskell syntax is not future proof :P
04:03:36 <quicksilver> there is probably something to be said for taking a completely fresh look at haskell syntax
04:03:44 <quicksilver> and learning from 20 years of experience.
04:03:58 <quicksilver> I think we've reached a point where it's hard to "patch on" new features one by one.
04:04:22 <quicksilver> that's something I hope iwll be possible with a pluggable GHC front end
04:04:28 <Peaker> a new syntax for existing semantics is not that bad, since backwards compatibility is easy with a conversion script
04:06:34 <BeelsebobWork> EvilTerran: why would it be ambiguous?  function application isn't allowed on the LHS of a rule
04:06:49 <BeelsebobWork> (it would be okay for operators, but not for infix constructors)
04:06:54 <ac> @seen humasect
04:06:54 <lambdabot> I saw humasect leaving #haskell-overflow 11d 5h 14m 36s ago, and .
04:06:55 <dolio> Same reason bang patterns are ambiguous.
04:07:07 <EvilTerran> BeelsebobWork, well, how would you define the operator (@)?
04:07:12 <BeelsebobWork> oh, duh
04:07:17 * BeelsebobWork smacks own head
04:07:24 <dolio> a ! b = ... is a definition of (!), a !b = ... is a definition of a strict in b.
04:07:46 <BeelsebobWork> yeh, so why is a @ b = ... not a definition of (@)?
04:07:58 <sleven> im not seeing any posts?
04:08:01 <Deewiant> a@b @ x@y = ...
04:08:01 <sleven> is anyone there?
04:08:06 <EvilTerran> because the report specified that'd be a def of (a) and (b), i believe
04:08:14 <EvilTerran> > let a @ b = "foo" in (a,b)
04:08:15 <dolio> Because @ was designed not to be ambiguous back in the H98 report.
04:08:15 <lambdabot>   ("foo","foo")
04:08:27 <quicksilver> whereas bang patterns are a hack
04:08:33 <BeelsebobWork> okay
04:08:36 <quicksilver> added after we already had a (!) operator
04:08:43 <quicksilver> still, it's not very satisfactory.
04:08:50 * BeelsebobWork wishes there had been a more structured approach to what characters are allowed where
04:09:04 <BeelsebobWork> I really get the feeling that what's allowed in operators is way to restricted
04:09:15 <quicksilver> I think it was quite structured BeelsebobWork
04:09:22 <quicksilver> maybe that's not the best way to phrase your objection? :)
04:09:35 <quicksilver> I think you wish it was more general, or more extensible, or something.
04:10:44 <quicksilver> It was a simplicitly lexical separation of the available characters into classes.
04:10:50 <quicksilver> its simplicity is attractive
04:10:55 <EvilTerran> i still haven't found a system for specifying syntax that's sufficiently extensible for what i want to do
04:10:55 <quicksilver> but it now feels limiting.
04:11:07 <quicksilver> which is what I meant by "time to take a fresh look"
04:11:14 <mmorrow> preflex: seen mauke
04:11:14 <preflex>  mauke was last seen on #perl 13 hours, 28 minutes and 27 seconds ago, saying: eval: sub x { my $fmt = shift; sprintf $fmt, @_ }; $thing='dummy'; $number=3.1415;  qq(I'm a ${\x"%-20s", $thing}, I like ${\x"%15s", "Pie"}, my favorite number is ${\x"%4.6f", $number}\n)
04:11:15 <EvilTerran> extensible grammars would be kinda cool
04:11:45 <dolio> Agda's system is pretty sexy, but has its own problems.
04:11:48 <quicksilver> preflex: I'll have none of that language in here, thank you.
04:12:13 <quicksilver> dolio: Yeah. I've seen agda's stuff look sexy in examples, but I haven't actually played with it to learn about the problems.
04:12:16 <EvilTerran> extending a grammar could be basically refinement
04:12:33 <EvilTerran> an extended grammar would work like the old one, except where the old one didn't work
04:12:53 <dolio> quicksilver: Well, the obvious one is that, say, [x] is different than [ x ]. And (a, b) is different than (a , b).
04:13:06 <quicksilver> dolio: Ah. Yes. I'm really not keen on that kind of thing.
04:13:13 <quicksilver> (yes, I know haskell has some of it)
04:13:16 <dolio> I'm not sure how hard it is to actually implement, either.
04:13:42 <quicksilver> There are some enticing things about moving away from plain text.
04:13:57 <Saizan> the main problem is if you can still "implement" it in your head while reading code
04:14:02 <byorgey> you could just distinguish different syntactic classes by color ;)
04:14:03 <quicksilver> for example, operators, type operators, type constructors could be in different 'colours'
04:14:07 <quicksilver> right.
04:14:20 <Gabby> Guys, sorry to noob over the place but is there a 1 liner for fizz buzz in haskell?
04:14:21 <quicksilver> and the colour could be inferred correctly most of the time by your editor
04:14:31 <quicksilver> and corrected manually as needed.
04:14:34 <byorgey> hehe, colourchecking
04:14:43 <quicksilver> But, there is a lot to hate about moving away form plain text.
04:14:49 <quicksilver> plain text is great in so many ways.
04:14:51 <mmorrow> preflex: tell mauke how can i not die when eval errors out with a syntax or other error? http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=315#a318
04:14:51 <preflex>  Consider it noted.
04:15:31 <byorgey> Gabby: sure, probably using a list comprehension or something.  I forget the exact details of fizz buzz, you'll have to remind me.
04:15:35 <Deewiant> Gabby: looks like 84 bytes is doable: http://golf.shinh.org/p.rb?FizzBuzz#Haskell
04:15:47 <lambdabot> Title: anarchy golf - FizzBuzz
04:15:55 <Deewiant> not quite a one-liner if you like 80-char lines but close enough
04:16:19 <Saizan> or google for site:hpaste.org fizzbuzz
04:16:31 <Gabby> Ah thanks
04:17:18 <EvilTerran> http://google.com/search?q=site:hpaste.org+fizzbuzz
04:17:39 <Gabby> byorgey, if the number is evenly divisible by 3 output fizz, if 5 buzz if both 3 and 5 fizzbuzz
04:17:48 <byorgey> > map (liftA2 (++) (f 3 "Fizz") (f 5 "Buzz")) [1..100] where f d s n = if n `mod` d == 0 then s else ""
04:17:49 <lambdabot>   ["","","Fizz","","Buzz","Fizz","","","Fizz","Buzz","","Fizz","","","FizzBuz...
04:18:29 <Gabby> nice
04:18:31 <byorgey> there are lots of ways to do it, you wouldn't even have to use semi-esoteric things like liftA2 =)
04:19:10 <Gabby> Thanks!
04:19:50 <byorgey> sure
04:20:29 <byorgey> if you want to actually print them you can just add "putStr . unlines $" to the front
04:20:34 <KAI_Tite> hi, newbie here
04:20:51 <byorgey> hi KAI_Tite, welcome
04:21:05 <KAI_Tite> i've a little problem
04:21:52 <KAI_Tite> i've to write a function that returns de higher of a set of integer numbers
04:21:54 <KAI_Tite> but
04:22:26 <KAI_Tite> i dont know what type of structure i can use
04:22:42 <KAI_Tite> sorry about my english :P
04:22:44 <byorgey> a list, perhaps?
04:22:54 <KAI_Tite> i cant use lists :S
04:22:59 <byorgey> OK, I'm not quite sure I understand what you want to do
04:23:03 <byorgey> can you give an example?
04:23:09 <KAI_Tite> uhm
04:23:35 <KAI_Tite> i've a set of numbers (2,6,4,5)
04:24:06 <KAI_Tite> and my function have to return de higher number of the set (6)
04:24:30 <KAI_Tite> and i cant use lists
04:24:41 <EvilTerran> why not?
04:24:59 <byorgey> I don't know how you would represent the input to your function if you can't use lists
04:25:43 <KAI_Tite> because the topic of the problem dont allow me
04:26:02 <Cale> KAI_Tite: do you know what the type of the function is supposed to be?
04:26:05 <xpika> is there an easy way of (1,2)+(3,4) =(4,6) ?
04:26:14 <byorgey> well, what is the topic?  what are you supposed to be learning about by doing this problem?
04:26:25 <quicksilver> xpika: on lists there is.
04:26:33 <quicksilver> > zipWith (+) [1,2] [3,4]
04:26:34 <lambdabot>   [4,6]
04:26:41 <byorgey> there is on tuples too, using (***)
04:26:50 <Saizan> > (join (***) (+)) (1,2) (3,4)
04:26:51 <lambdabot>   Couldn't match expected type `t1 -> t'
04:27:06 <byorgey> oh... wait, that's actually not so easy, is it
04:27:17 <KAI_Tite> well, the problem doesnt specity the structure that i have to use
04:27:19 <Deewiant> the easiest way is pointy
04:27:31 <KAI_Tite> it only says that i cant user lists
04:28:00 <KAI_Tite> then i'm looking for a structure to solve the problem
04:28:34 <xpika> I would use zipWith but the zip function outputs a tuple
04:28:43 <byorgey> KAI_Tite: and your function needs to work for any set of numbers?
04:28:48 <BONUS> > (join (***) (+)) (1,2) *** (3,4)
04:28:49 <lambdabot>       Overlapping instances for Show (b -> b)
04:28:49 <lambdabot>        arising from a use of `s...
04:28:56 <Saizan> maybe they want you to implement your own structure that's efficient for sets?
04:28:58 <luite_> KAI_Tite: maybe they want you to look at how a list is actually constructed and have you build your own list-like structure?
04:29:02 <KAI_Tite> yes byorgey
04:29:04 <byorgey> xpika: well, then the easiest way is just to write your own addition function for tuples
04:29:48 <KAI_Tite> [Saizan] it may be possible, but it cant be implemented over lists
04:29:59 <byorgey> xpika: if you need to do things other than adding, you could also be a bit more general and write a function to lift any binary function to tuples elementwise
04:30:01 <Cale> KAI_Tite: that is very strange.
04:30:11 <KAI_Tite> jeje i know :P
04:30:38 <EvilTerran> pairLift :: (a -> b) -> (a,a) -> (b,b)
04:30:40 <Cale> KAI_Tite: Lists are sort of the usual collection type for Haskell. It's hard to work with arbitrary numbers of things without going via a list at some point.
04:30:41 <EvilTerran> or something
04:30:53 <Deewiant> > (\(a,b) -> (($a) *** ($b)) . (join (***) (+))) (1,2) (3,4)
04:30:53 <EvilTerran> (for xpika, i mean)
04:30:54 <lambdabot>   (4,6)
04:31:06 <byorgey> more like  pairLift2 :: (a -> b -> c) -> (a,a) -> (b,b) -> (c,c)
04:31:11 <Cale> KAI_Tite: If you know that you will always have 4 things, for example, you could just use a tuple.
04:31:15 <EvilTerran> ah, yes, binary operations.
04:31:35 <byorgey> of course, if you want to be really general you can just make an instance of Applicative for (a,a) =)
04:31:38 <Cale> KAI_Tite: and of course, it will be a minor pain, because you have to do all the comparisons one by one.
04:31:42 <KAI_Tite> but i dont know how many numbers i'll have
04:31:43 <KAI_Tite> :P
04:31:55 <xpika> > (\(x1,y1) (x2,y2)->(x1+x2,y1+y2)) (1,2) (3,4)
04:31:56 <lambdabot>   (4,6)
04:32:03 <EvilTerran> byorgey, well, it'd need to be "newtype Both a = Both (a,a)" or something
04:32:04 <mmorrow> , uncurry (:) . fmap (:[]) $ (0,1)
04:32:07 <MarcWebe2> rwbarton: ping
04:32:10 <byorgey> EvilTerran: well, sure
04:32:13 <lunabot>  [0,1]
04:32:16 <Cale> KAI_Tite: There's no way to write a function which takes an arbitrary number of parameters without taking them in the form of some collection datastructure like a list.
04:32:19 <EvilTerran> but that would probably be the easiest way of doing it
04:32:38 <EvilTerran> well, best combination of simple and general
04:32:38 <byorgey> xpika: yup, that works.  now just give that function a name.
04:32:39 <KAI_Tite> [Cale] exist any structure like a set?
04:32:46 <Cale> KAI_Tite: There are sets implemented in Data.Set, but somehow I doubt this is what is intended for a beginner...
04:33:04 <KAI_Tite> i think so
04:33:21 <byorgey> KAI_Tite: maybe you are supposed to implement your own list data structure?
04:33:23 * EvilTerran once again wishes haskell had done tuples differently
04:33:34 <byorgey> instead of using the lists provided in the standard libraries?
04:33:42 <Deewiant> ?ty \f (a,b) (x,y) -> (($x) *** ($y)) $ join (***) f (a,b)
04:33:43 <lambdabot> forall a b b1. (b1 -> a -> b) -> (b1, b1) -> (a, a) -> (b, b)
04:33:52 <KAI_Tite> i was searching for this and i found the Data.set but i think that its very avanced for me
04:33:54 <Cale> EvilTerran: Even if they had been done differently, wouldn't this still involve a typeclass?
04:33:55 <mmorrow> , foldl (zipWith (+)) (repeat 0) . fmap (uncurry (:) . fmap (:[])) $ [(0,1),(99,203),(5,9)]
04:33:56 <byorgey> Deewiant: hehe, nice
04:33:57 <lunabot>  [104,213]
04:34:02 <Deewiant> ?pl \f (a,b) (x,y) -> (($x) *** ($y)) $ join (***) f (a,b)
04:34:06 <lambdabot> flip ap snd . (. fst) . flip flip snd . (flip .) . ((ap .) .) . flip flip fst . (flip .) . (((.) .) .) . ((flip (flip . (. flip id) . (***) . flip id) .) .) . (. (,)) . (.) . join (***)
04:34:06 <lambdabot> optimization suspended, use @pl-resume to continue.
04:34:09 <Deewiant> :-/
04:34:17 <EvilTerran> Cale, yes, but then you could potentially write a single Applicative instance that could cover n-ary tuples
04:34:18 <Cale> KAI_Tite: Right, there's something funny about the question... Is it in another language? It would be nice to know the exact wording.
04:34:23 <byorgey> mmorrow: cheater! ;)
04:34:26 <Cale> EvilTerran: ah
04:34:31 <mmorrow> byorgey: hehe
04:34:40 <EvilTerran> ?pl \f (a,b) (x,y) -> (f a x, f b y)
04:34:44 <lambdabot> flip ap snd . (. fst) . flip flip snd . ((flip . (ap .)) .) . flip flip fst . (flip .) . (((.) .) .) . join (flip . (((.) . flip . (((.) . (,)) .)) .))
04:34:44 <lambdabot> optimization suspended, use @pl-resume to continue.
04:34:46 <EvilTerran> hm
04:34:47 <KAI_Tite> [Cale] the topic is in spanish
04:34:48 <KAI_Tite> :P
04:34:51 <EvilTerran> ?type \f (a,b) (x,y) -> (f a x, f b y)
04:34:52 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t, t) -> (t1, t1) -> (t2, t2)
04:35:17 <byorgey> KAI_Tite: can you paste it?  I'm sure somebody here knows spanish.
04:35:18 <KAI_Tite> if you want i paste you the text
04:35:21 <KAI_Tite> ok
04:35:26 <dolio> This doesn't realy become easy unless you're using sized vectors, not tuples.
04:35:50 <KAI_Tite> escribe una función que determine el mayor de un conjunto de números enteros (no utilizar listas)
04:36:18 <mmorrow> what is conjunto?
04:36:20 <BONUS> > uncurry (***) ((join (***) (+)) (1,2)) (3,4)
04:36:21 <lambdabot>   (4,6)
04:36:23 <BONUS> haha, oh man
04:36:47 <KAI_Tite> "whithe a function that determine the higher of a set of integer numbers (dont use lists)"
04:36:51 <KAI_Tite> more or less xD
04:37:03 <Cale> hmm
04:37:04 <KAI_Tite> oh sorry
04:37:06 <mmorrow> but what does "conjunto" literally mean?
04:37:07 <luite_> KAI_Tite: does 'enteros' mean that the user has to enter the numbers?
04:37:14 <KAI_Tite> "write a function that determine the higher of a set of integer numbers (dont use lists)"
04:37:24 <KAI_Tite> enteros = integers
04:37:28 <luite_> ok
04:37:30 <luite_> :)
04:37:32 <mmorrow> what is a "set" though?
04:37:42 <byorgey> @babel es en conjunto
04:37:43 <KAI_Tite> conjunto = set of
04:37:43 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
04:37:48 <byorgey> doh
04:37:57 <Twey> Whoopsadaisy
04:38:00 <EvilTerran> > ((uncurry (***) .) . join (***)) f (a,b) (c,d) :: (Expr,Expr)
04:38:02 <lambdabot>   (f a c,f b d)
04:38:03 <mmorrow> set := arbitrary n-tuple
04:38:06 <Twey> Someone was a little undercautious with head
04:38:06 <Cale> KAI_Tite: I suppose that you can write functions which take a specific number of integers, and find the maximum. But without using lists or some other datastructure, you can't handle an arbitrary number of them.
04:38:13 <mmorrow> set := arbitrary nesting of tuples
04:38:16 <EvilTerran> Cale, i think i see what the point is
04:38:22 <mmorrow> set := arbitrary type other than list
04:38:23 <mmorrow> ?
04:38:33 <EvilTerran> Cale, it's probably meant to use constant memory
04:38:42 <KAI_Tite> uhm
04:38:59 <KAI_Tite> there is a previus step in the exercise
04:39:04 <EvilTerran> hm?
04:39:26 <byorgey> KAI_Tite: and what was that?
04:39:58 <KAI_Tite> i have to white a function that i give 4 integers and it returns the higher
04:40:08 <KAI_Tite> there i no problem with this part
04:40:12 <Cale> KAI_Tite: okay
04:40:38 <KAI_Tite> before it i have to do the other function
04:41:12 <EvilTerran> KAI_Tite, by the way, in English, "higher" = "more high"; "highest" = "most high"
04:41:15 <Cale> KAI_Tite: Well, I'm not sure what to recommend. It's probably a good exercise at least to write a function which finds the minimum of a list of integers.
04:41:30 <KAI_Tite> well, the highest then
04:41:32 <KAI_Tite> [xD]
04:41:36 <EvilTerran> :)
04:42:21 <KAI_Tite> its a problem that i cant use lists :P
04:42:22 <Cale> KAI_Tite: All functions in Haskell have a fixed number of parameters.
04:43:01 <Cale> (which is not quite true, but close enough for beginners :)
04:43:29 <KAI_Tite> yes, but it may have a king of argument like a list (not a list) who were a set of integers
04:43:39 <Cale> yeah
04:44:15 <KAI_Tite> heheeh i've a big problem xDD
04:44:22 <Cale> So it seems impossible without using a list or an array, or a Data.Set or something else, and lists are the simplest one.
04:44:33 <KAI_Tite> i will ask my teacher for it
04:44:57 <Cale> You probably should try the one which takes a list and finds the minimum element of it anyway, since that's a good exercise.
04:45:01 <KAI_Tite> maybe the topic of the problem is wrong
04:45:11 <Cale> But yeah, ask your teacher :)
04:45:57 <KAI_Tite> and what i ve to do is a new data structure based on lists
04:45:58 <mmorrow> KAI_Tite: if the question said /exactly/ what a conjunto is in this context, that would help a lot
04:46:11 <KAI_Tite> not using directly lists
04:46:15 <mmorrow> ahh
04:46:43 <mmorrow> newtype NotAList a = Fish a | SeaGull a (NotAList a)
04:46:53 <mmorrow> , src ''[]
04:46:55 <KAI_Tite> weah
04:47:00 <KAI_Tite> something like this
04:47:06 <lunabot>  data [] a = [] | a `(:)` ([a])
04:47:28 <mmorrow> oops, "`(:)`"
04:47:40 <mmorrow> double oops
04:47:47 <KAI_Tite> [XD]
04:47:47 <mmorrow> newtype NotAList a = Fish | SeaGull a (NotAList a)
04:48:07 <Saizan> except for newtype
04:48:14 <mmorrow> haha TRIPLE
04:48:19 <mmorrow> data NotAList a = Fish | SeaGull a (NotAList a)
04:48:21 <mmorrow> :)
04:48:57 <Saizan> call it CestPasUneList and add some clouds in the background :)
04:49:07 <mmorrow> hah
04:49:20 <Saizan> except for my french
04:49:26 <quicksilver> CeciN'EstPasUneListe
04:49:47 <lilac> data CeciN'estPasUneList a = Clouds | Pipe (CeciN'estPasUneList a)
04:50:03 <lilac> hmm
04:50:06 <lilac> data CeciN'estPasUneList a = Clouds | Pipe a (CeciN'estPasUneList a)
04:50:42 <mmorrow> isFluffy :: CeciN'estPasUneList a -> Bool ; isFluffy Clouds = True ; isFluffy _ = False
04:53:42 <mmorrow> isScaly :: NotAList a -> Bool ; isScaly Fish = True ; isScaly _ = False
04:54:00 <mmorrow> @src null
04:54:01 <lambdabot> null []     = True
04:54:01 <lambdabot> null (_:_)  = False
04:54:25 <mmorrow> why would null bother with that second pattern match?
04:54:44 <RayNbow> mmorrow: for aesthetics
04:55:47 <mmorrow> i suppose to each his own aesthetic
04:55:48 <RayNbow> (it's just an excuse to write (_:_))
04:55:51 <mmorrow> haha
04:58:01 <lilac> probably to avoid overlapping patterns
04:58:21 <mmorrow> ?
04:59:06 <mmorrow> ah, you mean "order independence"?
04:59:44 <mmorrow> i can see that as motivation, since that's the reference implem
04:59:48 <lilac> yes, i suppose i do :)
05:01:26 <birdspider> hi, how can I map Nothing to 0,  or Maybe Int -> Int ?
05:01:38 <byorgey> birdspider: fromMaybe 0
05:01:46 <byorgey> > fromMaybe 0 Nothing
05:01:47 <lambdabot>   0
05:01:52 <byorgey> > fromMaybe 0 (Just 3)
05:01:53 <lambdabot>   3
05:02:28 <byorgey> there's also the  'maybe' function if you want to apply a function to the data inside a Just, instead of simply extracting it
05:04:05 <birdspider> thanks, fromMaybe was exactly the thing I was looking for
05:04:21 <mmorrow> maybe is super nice
05:04:45 <mmorrow> maybe n f = fromMaybe n . fmap f
05:05:00 <mmorrow> @src maybe
05:05:00 <lambdabot> maybe n _ Nothing  = n
05:05:01 <lambdabot> maybe _ f (Just x) = f x
05:05:40 <mmorrow> maybe 0 (either (*2) (*1000)) (Just (Right 42))
05:05:44 <mmorrow> , maybe 0 (either (*2) (*1000)) (Just (Right 42))
05:05:55 <lunabot>  42000
05:06:18 <mmorrow> @src either
05:06:18 <lambdabot> either f _ (Left x)     =  f x
05:06:18 <lambdabot> either _ g (Right y)    =  g y
05:07:17 <Beelsebob> hmm
05:07:47 <Beelsebob> maybe z and either f fit nicely into conal's (fmap . fmap . first . fmap) idiom
05:07:59 <mmorrow> list n _ [] = n ; list _ c (x:xs) = c x xs
05:08:09 <Beelsebob> > (maybe 0 . either (*2)) (*1000) (Just (Right 42))
05:08:10 <lambdabot>   42000
05:08:14 <mmorrow> maybe and either are the folds of Maybe and Either
05:08:43 <Beelsebob> yeh
05:08:57 * mmorrow loves the using the folds
05:09:32 <mmorrow> totally point-free-enabling
05:09:59 <Beelsebob> they actually need slight variants maybe' :: b -> (a -> b) -> Maybe a -> Maybe b and either' :: Either (a -> b) -> (c -> d) -> Either a c -> Either b d to fit properly into the idiom
05:10:14 <Beelsebob> oh, but that's fmap
05:10:15 <Beelsebob> >.<
05:10:17 <Beelsebob> duh
05:10:19 <Beelsebob> so it's already there
05:10:28 * mmorrow loves fmap
05:10:37 <Beelsebob> well, it's not quite fmap
05:10:42 <Beelsebob> it's fmap with a default
05:10:55 <mmorrow> hmm
05:11:18 <Beelsebob> @let maybe' z Nothing = Just z; maybe' _ (Just x) = Just x
05:11:20 <lambdabot>  Defined.
05:11:56 <Beelsebob> @let either' f _ (Left x) = Left . f $ x; either' _ f (Right x) = Right . f $ x
05:11:57 <lambdabot>  Defined.
05:12:05 <mmorrow> maybe' z = Just . maybe z id
05:12:11 <Beelsebob> yep
05:12:14 <Beelsebob> that too
05:12:19 <Beelsebob> either's not quite the same
05:12:32 <Beelsebob> although a variant could be easily made that pushes everything into a Right
05:12:41 <Beelsebob> that would essentially be catchError
05:12:58 <mmorrow> either' f = either (Left . f) (Right . f)
05:13:14 <Beelsebob> @let catchError c f = Right . either c f
05:13:15 <lambdabot>  Defined.
05:13:32 <mmorrow> hmm, that's interesting
05:13:35 <Beelsebob> > catchError (const 0) id (Left "It exploded")
05:13:37 <lambdabot>       Ambiguous occurrence `catchError'
05:13:37 <lambdabot>      It could refer to either `L.catc...
05:13:50 <Beelsebob> is L the scope of @let?
05:14:02 <mmorrow> composing one of the constructors of a datatype with the result of a fold of the same
05:14:06 <Beelsebob> > L.catchError (const 0) id (Left "It exploded")
05:14:08 <lambdabot>   Right 0
05:14:16 <Beelsebob> > L.catchError (const 0) id (Right 42)
05:14:17 <lambdabot>   Right 42
05:14:38 <mmorrow> yeah, i believe L.hs is the file for lambdabot local defs
05:14:43 <ziman> :t L.catchError
05:14:44 <lambdabot> forall a1 c b a. (a1 -> c) -> (b -> c) -> Either a1 b -> Either a c
05:15:01 <Beelsebob> mmorrow: it seems pretty general doesn't it
05:15:34 <mmorrow> it does. i'm trying to think of how to say it though.
05:16:22 <lilac> is it possible to use >>- from \b?
05:16:38 <Cale> :t (>>-)
05:16:39 <lambdabot> forall (m :: * -> *) a b. (MonadLogic m) => m a -> (a -> m b) -> m b
05:16:44 <sclv> cokleisli?
05:16:52 <lilac> > [1,2,3] >>- return
05:16:53 <lambdabot>   /tmp/2576139505969209813:68:52: Not in scope: `>>-'
05:16:58 <Cale> oh, hmm
05:17:02 <Cale> that's odd
05:17:13 <Cale> It was working at one point, let me check :)
05:17:15 <sclv> or maybe just cobind even
05:17:42 <Cale> >>- is fair conjunction from LogicT.
05:17:44 <sclv> (extract . duplicate) or such
05:18:06 <sclv> in ref to the above discussion that is, not >>-
05:18:20 <Cale> ah
05:19:34 <Cale> hmm...
05:19:41 <Cale> lambdabot: @quit
05:20:09 <Beelsebob> mmorrow: I'll talk to conal about it this eve -- he may have some insight into what they are
05:20:24 <Beelsebob> (it was his idiom that inspired it after all)
05:22:31 <Cale> > (msum . map return $ [1,2,3]) >>- return
05:22:34 <lambdabot>  Terminated
05:22:36 <Cale> > (msum . map return $ [1,2,3]) >>- return
05:22:44 <lambdabot>  Terminated
05:22:45 <Cale> hmm
05:22:49 <Cale> > 1
05:22:54 <lambdabot>  Terminated
05:23:01 <Cale> grumble...
05:23:18 <Peaker> @type (>>-)
05:23:24 <lambdabot> forall (m :: * -> *) a b. (MonadLogic m) => m a -> (a -> m b) -> m b
05:23:33 <Peaker> @src MonadLogic
05:23:34 <Cale> It *might* just be slow because it's joining channels still.
05:23:38 <dolio> , let pick = msum . map return in pick [1,2,3] >>- return
05:23:40 <lambdabot> Source not found. Take a stress pill and think things over.
05:23:44 <lilac> > [1] >>- return
05:23:46 <lunabot>  luna: No instance for (GHC.Show.Show (m t))
05:23:46 <lambdabot> dolio: You have 1 new message. '/msg lambdabot @messages' to read it.
05:23:50 <Peaker> Cale: thread termination is based on real time, rather than CPU time?
05:23:52 <lambdabot>  Terminated
05:23:56 <Cale> yes
05:24:00 <Cale> afaik
05:24:15 <dolio> Heh, that was an old message.
05:24:38 <lilac> > [1] >>- return
05:24:43 <lambdabot>  Terminated
05:24:44 <Cale> > 1
05:24:46 <Peaker> Cale: if its getting a big list of nicks in each channel, but it did see the request to run code, why would the incoming list of nicks make the code running take long real time?
05:24:49 <lambdabot>  Terminated
05:24:55 <lilac> dolio: vixey says "\\neg actually also works I just noticed" ?
05:24:57 <Cale> okay, maybe it's just plain broken ;)
05:25:20 <lilac> dolio: that's in the \b package on hackage :)
05:25:26 <Cale> ah, yes it is
05:25:36 <Cale> -rw-r--r-- 1 cale cale        0 2008-10-28 05:18 mueval
05:25:39 <Cale> that would be why
05:25:42 <lilac> hehe
05:25:59 <Cale> > 1
05:25:59 <lambdabot>  Terminated
05:26:30 <Cale> okay, that's odd
05:26:54 * Cale does a cabal clean before cabal install this time...
05:27:08 <Cale> aha
05:27:09 <Cale> > 1
05:27:11 <lambdabot>   1
05:27:18 <Cale> > (msum . map return $ [1,2,3]) >>- return
05:27:19 <lambdabot>       No instance for (Show (m a))
05:27:20 <lambdabot>        arising from a use of `show' at <in...
05:27:46 <Peaker> Would it be right to say that syntax is an encoding/serialization for a semantic structure?
05:27:56 <lilac> > [1,2,3] >>- return
05:27:57 <lambdabot>   [1,2,3]
05:28:02 <lilac> Cale: what do i need to do to my \b to get the fix? :)
05:28:02 <Cale> > observeAll (msum . map return $ [1,2,3]) >>- return
05:28:04 <lambdabot>   [1,2,3]
05:28:06 <Peaker> If so, why does http://www.pphsg.org/cdsmith/types.html claim that type systems are bound to syntax, and not to semantics?
05:28:07 <lambdabot> Title: Chris Smith's Personal Web Site - Ideas - What to Know Before Debating Type Syst ...
05:28:12 <Cale> lilac: Get a different mueval.
05:28:14 <mmorrow> Beelsebob: here's some TH code to autogen the fold for an arbitrary data decl http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=319
05:28:24 <lilac> any particular version?
05:28:37 <mmorrow> and some example derivations: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=319#a320
05:28:40 <Cale> lilac: I haven't contributed my patches to mueval, since it basically involved cutting out half the code in a rather hackish way.
05:28:50 <Cale> lilac: But if you just want to add modules, look in Context.hs
05:28:58 <lilac> ok, thanks
05:29:09 <Cale> I'm running a modified version of the darcs mueval
05:29:56 <Cale> Oh, that is interesting, [] really is an instance of MonadLogic
05:30:28 <mmorrow> oops, i forgot to change the name of and lowercase-the-first-char of the String i passed in in those examples
05:31:35 <xpika> what would be the best way to pad a list out with 0's
05:33:12 <mmorrow> Beelsebob: fixed: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=319#a321
05:34:45 <mmorrow> , [0..9] `interleave` [1000..]
05:34:49 <lunabot>  [0,1000,1,1001,2,1002,3,1003,4,1004,5,1005,6,1006,7,1007,8,1008,9,1009,10...
05:35:55 <mmorrow> , let postpad n xs = xs ++ replicate n 0 in postpad 8 [0..9]
05:35:58 <lunabot>  [0,1,2,3,4,5,6,7,8,9,0,0,0,0,0,0,0,0]
05:36:22 <Peaker> @src interleave
05:36:22 <lambdabot> Source not found. Are you on drugs?
05:36:35 <mmorrow> , src 'interleave
05:36:46 <lunabot>  Class op from MonadLogic: interleave :: forall m . MonadLogic m => forall...
05:36:46 <lunabot>                                                                           ...
05:36:50 <mmorrow> lunabot is dragging ass today
05:36:52 <mmorrow> oof
05:37:02 <mmorrow> haven't made class methods pretty yet
05:37:18 <mmorrow> , src ''MonadLogic
05:37:23 <lunabot>  class (MonadPlus m) => MonadLogic m where
05:37:23 <lunabot>          msplit :: forall a . m a -> m (Maybe (a, m a))
05:37:23 <lunabot>          interleave :: forall a . m a -> m a -> m a
05:37:53 <mmorrow> i think there're more than just those two, but lunabot only returns 3 lines not-in-a-/msg
05:38:02 <Peaker> , msplit [1,2,3]
05:38:05 <lunabot>  [Just (1,[2,3])]
05:38:42 <mmorrow> <lunabot>  class (MonadPlus m) => MonadLogic m where
05:38:42 <mmorrow> <lunabot>          msplit :: forall a . m a -> m (Maybe (a, m a))
05:38:42 <mmorrow> <lunabot>          interleave :: forall a . m a -> m a -> m a
05:38:42 <mmorrow> <lunabot>          (>>-) :: forall b a . m a -> (a -> m b) -> m b
05:38:42 <mmorrow> <lunabot>          ifte :: forall b a . m a -> (a -> m b) -> m b -> m b
05:38:43 <mmorrow> <lunabot>          once :: forall a . m a -> m a
05:39:12 <mmorrow> , once [0..]
05:39:14 <lunabot>  [0]
05:45:25 <mmorrow> <Peaker> Would it be right to say that syntax is an encoding/serialization for a semantic structure?
05:45:35 <mmorrow> that sounds good to me
05:45:54 <Peaker> <Peaker> If so, why does http://www.pphsg.org/cdsmith/types.html claim that type systems are bound to syntax, and not to semantics?
05:45:55 <lambdabot> Title: Chris Smith's Personal Web Site - Ideas - What to Know Before Debating Type Syst ...
05:46:43 <Saizan> you usually define a type system on the "language" so on the syntax, then you can ask yourself if it is sound wrt a certain semantic, afaiu
05:47:37 <Peaker> but can't I define the type system on the semantic structure itself? isn't that in fact what is done?
05:48:13 <mmorrow> that sounds like it'd be ideal
05:48:33 <Saizan> it's not great for typechecking
05:48:43 <mmorrow> well, "ideal" may be a..
05:48:44 <mmorrow> yeah
05:48:57 <Peaker> (a -> b) does not describe f = \x -> y   and  f x = y  separately, for example
05:48:59 <mmorrow> you'd have to rethink how you approach typechecking
05:49:48 <mmorrow> i for one am all for separating as much as possible from syntax
05:50:10 <Saizan> Peaker: a lot things semantically different have the same type tough
05:50:21 <Peaker> Saizan: for example?
05:50:30 <Saizan> 1 and 2?
05:50:52 <mmorrow> (fireSeagulls >> return 3)    and          (return 3)
05:50:54 <Peaker> Saizan: Oh :) but that doesn't contradict that typing is on semantic entities, rather than syntactic ones
05:51:11 <mapreduce> Perhaps 1 is of the type "not 2".
05:51:51 <Saizan> Peaker: yeah, but saying that f= \x -> y and f x = y have the same type doesn't tell us much
05:51:59 <mmorrow> i think the entire system you'd use to type semantics would be not-directly-comparable to that which is used with syntax
05:52:13 <dolio> f = \x -> y and f x = y have potentially different inferred types.
05:52:18 <dolio> In Haskell.
05:52:22 <mmorrow> ah, yeah true
05:52:39 <Peaker> dolio: why? Isn't one desugared into the other?
05:52:40 <mapreduce> dolio: How so?
05:52:50 <Saizan> monomorphism restriction.
05:52:55 <dolio> f = \x -> y is subject to the monomorphism restriction.
05:53:00 <mmorrow> death to the ...
05:53:25 <mmorrow> , [d|f = \x -> x|]
05:53:27 <lunabot>  ValD (VarP f) (NormalB (LamE [VarP x_0] (VarE x_0))) []
05:53:33 <mmorrow> , [d|f  x = x|]
05:53:35 <lunabot>  FunD f [Clause [VarP x_0] (NormalB (VarE x_0)) []]
05:53:39 <mapreduce> :type \x -> 3
05:53:57 <mapreduce> > "bot?"
05:53:58 <lambdabot>   "bot?"
05:54:04 <mapreduce> :t \x -> 3
05:54:05 <lambdabot> forall t t1. (Num t1) => t -> t1
05:55:18 <mmorrow> , src 'ValD
05:55:22 <mmorrow> , src 'FunD
05:55:23 <lunabot>  data Dec = ... | ValD Pat Body ([Dec]) | ...
05:55:23 <lunabot>  infixl 9
05:55:28 <lunabot>  data Dec = ... | FunD Name ([Clause]) | ...
05:55:28 <lunabot>  infixl 9
05:55:36 <mmorrow> , src ''Clause
05:55:38 <Saizan> however, unless you're an idealist, the semantic is just another syntax :)
05:55:41 <lunabot>  data Clause = Clause ([Pat]) Body ([Dec])
05:55:55 <mmorrow> Saizan: heh
05:56:58 <dolio> Anyhow, leaving that case aside (and peculiarities of optimization), you could say that 'f = \x -> y' and 'f x = y' are represented by the same abstract syntax (although they aren't in Haskell).
05:57:03 <mmorrow> i need to add a src-and-gimme-the-reachable-info
05:57:12 <dolio> Which is what you'll be type checking, presumably.
05:57:40 <mmorrow> , src ''Body
05:57:45 <lunabot>  data Body = GuardedB ([(Guard, Exp)]) | NormalB Exp
05:57:53 <mmorrow> , src ''Guard
05:57:58 <lunabot>  data Guard = NormalG Exp | PatG ([Stmt])
05:58:01 <mattam> , src ''Dec
05:58:08 <lunabot>  data Dec = FunD Name ([Clause])
05:58:08 <lunabot>           | ValD Pat Body ([Dec])
05:58:08 <lunabot>           | DataD Cxt Name ([Name]) ([Con]) ([Name])
05:58:20 <mmorrow> mattam: do a /msg with that to lunabot for the whole thing :)
05:58:39 <mmorrow> lunabot'll return up to 32 lines in a /msg
05:59:41 <mattam> What's Dec for?
06:00:05 <mmorrow> it's the AST fragment for declarations in template-haskell
06:00:27 <mmorrow> Exp, Pat, Dec, Stmt, Type  are the main ones
06:00:49 <mmorrow> , src 'LamE
06:00:54 <lunabot>  data Exp = ... | LamE ([Pat]) Exp | ...
06:00:54 <lunabot>  infixl 9
06:01:00 <mattam> I meam, why is there Body and Dec's here...
06:01:38 <mmorrow> , [d|fix f = let x = f x in x|]
06:01:46 <lunabot>  FunD fix [Clause [VarP f_0] (NormalB (LetE [ValD (VarP x_1) (NormalB (App...
06:02:10 <mmorrow> , [d|f x | x == 4 = 42|]
06:02:13 <lunabot>  FunD f [Clause [VarP x_0] (GuardedB [(NormalG (InfixE (Just (VarE x_0)) (...
06:02:56 <mmorrow> , ppDoc `fmap` [d|fix f = let x = f x in x|]
06:02:58 <lunabot>  fix f_0 = let x_1 = f_0 x_1
06:02:58 <lunabot>             in x_1
06:10:36 <pjdelport> data NotAList a = Tequila a (NotAList a) | Floor
06:12:16 <quicksilver> data NotAList a = OneTequila a | TwoTequila a a | ThreeTequila a a a | Floor
06:12:26 <mmorrow> hehe
06:13:01 <Cale> That one has to end up in some Haskell tutorial now.
06:13:32 <chr1s> haha
06:23:15 <Saizan> Peaker: also, if you define a type system on the semantic, e.g. denotational, then to typecheck a program you'd have to calucate its denotation first which might require to run it
06:25:10 <Saizan> it seems to me that a type system is an approximation of the dynamic semantic, so defining the former in terms of the latter would lose its value
06:25:11 <Philippa> Peaker: look up "let polymorphism", the type system very much exploits things that on paper're denotationally or even sometimes operationally identical
06:25:43 <Peaker> Saizan: I think maybe we're missing a word for something in between the syntactic serialization of the program as text, and the denotational semantics that speak of its execution results?
06:26:00 <Philippa> "abstract syntax"?
06:26:35 <Philippa> typechecking for sugar is often defined simply as "desugar it, check it", sure
06:26:43 <Philippa> but that's still a syntactic operation
06:26:55 <Philippa> in fact, probably the best definition we have of type systems defines them as a syntactic method
06:27:43 <Peaker> Philippa: because they operate on the encoded structure of the program, rather than on the meaning of that structure?
06:28:17 <Philippa> they're another meaning of it - as such, they pretty much have to be defined syntactically
06:28:31 <Philippa> (also: consider that this even applies to cases like Coq's language - isn't that rather telling?)
06:29:11 <Peaker> Yeah. I think I had learned a wrong/too-narrow definition of the word syntax
06:29:26 <Peaker> Which may explain some misunderstandings I had in previous discussions here
06:30:54 <Philippa> *nod* - abstract syntax really isn't explained well as a concept a lot of the time, and if you've not played with language implementation then you just don't have it
06:31:19 <Philippa> you seemed to be somewhat put out by my small lambda calculus interpreter a while back, I'm guessing that was partly because you didn't think it had syntax and so was 'cheating'?
06:32:06 <Peaker> Philippa: I thought it didn't have syntax, and that it was great, because I think syntax as a serial text-string is a bad idea ;-)
06:32:22 <Philippa> heh
06:32:47 <Philippa> you kinda dropped off silently, at the time it left me feeling like you didn't want to concede the point re OO vs algebraic encodings of syntax
06:34:32 <Philippa> (which it sounds like isn't what was going on, FWIW)
06:34:39 <Peaker> Philippa: I've thought about OO a lot since, and my conclusion is that OO conflates data types and type classes (interfaces). It is possible to use them in a useful way despite this, but I think I had a confused idea and other OO programmers probably have one too
06:35:05 <Philippa> yeah, the interface vs inheritance thing's actually increasingly recognised in the OO community too
06:35:38 <Philippa> part of the problem I have with OO encodings of ASTs is that it also gets the open-closed stuff backwards (this isn't surprising - subtyping for algebraic types works in the opposite direction to subtyping for records)
06:36:35 <ketil> @seen bos
06:36:36 <lambdabot> I saw bos leaving #ghc and #haskell 10d 12h 49m 53s ago, and .
06:36:48 <ketil> Oh..
06:36:57 <Peaker> I think OO-style inheritence is not very useful at all: Inheritence is just a "special member" that derives all of the parent's interfaces and shares a namespace. I think these things ought to be done not via inheritence
06:37:11 <Philippa> the mechanism wants to be more general, yes
06:37:37 <Philippa> I've given thought to doing something similar for typeclasses in the past, it's been a while though
06:38:27 <Philippa> the more dynamic OO languages've played with delegation for much that kind of reason
06:39:32 <Peaker> if you remove inheritence from OO, and instead have just "implements" for interfaces, then you add automatic delegation of interfaces to members, you're getting awfully close to how FP languages do it
06:40:02 <Philippa> totally automatic delegation to members is a little tricky, but yeah. You might find Self an interesting language
06:40:16 <Peaker> Perhaps I could even try to write a little paper about how to get from OO to FP with just incremental positive changes :)
06:40:36 <Vq^> i find zope3 interfaces and adapters interesting for this reason
06:40:38 <Philippa> like the 3946 others? >-)
06:40:40 <Peaker> Well, not exactly OO to FP, but class/inheritence to FP-style types
06:40:58 <Philippa> ...apparently my hair's floppier than usual today
06:41:10 <Peaker> Philippa: I have seen a lot of papers about the merits of FP, but they always treat OO/FP as apples to oranges and don't compare them directly
06:41:43 <Philippa> yeah, you have to read slightly more subtly. But there's lots and lots and lots of work on this - and bear in mind that really you're talking about "FP-style typing" rather than FP
06:41:43 <Peaker> Philippa: would love to see a paper going from OO to FP via small incremental improvements :)
06:41:58 <Peaker> Philippa: Yeah, thanks, was looking for a word for that
06:42:10 <Philippa> also bear in mind that Smalltalk descended rather from lisp...
06:43:05 <Peaker> Would you say Lisp has FP-style typing?
06:43:08 <Vq^> when the runtime handles adapters between classes and interfaces it starts to feel a lot like writing type-class instances in Haskell
06:43:17 <Philippa> heh, I wouldn't necessarily say Lisp has /typing/
06:43:23 <Philippa> (but beware the incoming flamewar)
06:43:42 <Vq^> thought nameable adapters is a bit more powerful than Haskells class instances
06:44:04 <Philippa> yeah, presumably it's akin to first-class ML modules plus some degree of inference happening?
06:44:12 <Vq^> Philippa: im sure it has some sort of type somewhere :)
06:44:17 <Peaker> Philippa: I think the interest in FP is in pure-FP. I think the difference between non-pure FP and imperative is not that large, and therefore I don't even see Lisp as a functional language..
06:44:41 <Peaker> at least not functional in an interesting way
06:44:47 <Philippa> Peaker: one can reasonably view the ML family as a principled higher-order imperative language, certainly
06:45:16 <Philippa> to an extent, the libraries rather than the language're what makes the difference there
06:45:51 <Philippa> Vq^: there's an argument that dynamic type systems aren't type systems. Needless to say, it's somewhat controversial :-)
06:46:09 <Vq^> is mutable assignment in ML similar to that of lisp?
06:46:33 <Philippa> nah, you can only mutate references. IORefs and the like are descended from ML's approach to mutability
06:46:33 <quicksilver> ML mutability is explicitly flagged in the type system
06:46:41 <quicksilver> "ref a" is a different type from "Aa"
06:46:44 <quicksilver> gah. "a"a
06:46:48 <Philippa> (rather, you can only mutate the cells pointed to /by/ the references)
06:47:03 <Vq^> ok, thats quite sensible
06:47:26 <quicksilver> that bit that's not sensible is that ML doesn't similarly flag functions according to whether they do any mutation :)
06:47:36 <quicksilver> it's like they only read half the story and then got bored of the book.
06:49:18 <Philippa> to be fair, ML was happily mutating before Moggi's original monadic semantics paper
06:50:05 <Vq^> are there any ML that allows this today?
06:50:05 <quicksilver> yeah, I know. My point was anachronistic and pretty unfair.
06:50:20 <quicksilver> but it's an interesting way to look at it.
06:50:39 <Philippa> Vq^: that allow what?
06:50:45 <quicksilver> (that tagging functions as performing mutation is the other side of the same coin as tagging types as being mutable)
06:50:53 <Philippa> *nod*
06:51:02 <Philippa> rather, tagging computations
06:51:06 <quicksilver> right.
06:51:13 <quicksilver> but ML people do still call them functions
06:51:18 <quicksilver> even whent they're not ;)
06:51:19 <Vq^> Philippa: never mind, i misinterpreted you
06:51:20 <Philippa> yeah. But see C
06:51:34 <quicksilver> ah, well, C people can be forgiven
06:51:37 <quicksilver> they know not what they do.
06:51:42 <quicksilver> ML people know damn well what they do.
06:51:43 <Peaker> heh
06:51:49 <Philippa> the usage is pretty well-embedded, and Haskell's distinction seems odd to people at first glance because we actually entirely separate function from computation
06:52:35 <Peaker> I first saw this separation in Subtext 1's demo, and realized that these notions are more different than similar..
06:53:02 <Peaker> I think Jonathan Edwards invented monadic IO for subtext from scratch, which is pretty nice ;)
06:53:31 <Philippa> heh. Talking of which, do you know how easy it is to implement monadic IO in an interpreter?
06:54:30 <Peaker> I'd still credit him for creating this distinction between pure functions and IO computations, and not only that - but also creating a really nice visualization of the RealWorld -> (a, RealWorld) type
06:54:46 <Philippa> sure, I'm not saying don't credit the guy at all
06:54:56 <Philippa> I'm just saying that it's shockingly easy to write
06:55:03 <Peaker> this nice visualization really ought to be used in Haskell programming environments, IMO
06:55:21 <quicksilver> Peaker: which nice visualization is that?
06:56:05 <Peaker> quicksilver: He's showing the resulting RealWorld as a "hypothetic future" that you can look at, in which you can find the same action and others, and dive into any hypothetic future path you wish to see what would happen
06:56:39 <quicksilver> that sounds interesting, but how does it work in practice?
06:56:45 <quicksilver> how do you navigate the possible futures?
06:57:18 <Peaker> quicksilver: Well, reversible side effects are probably easy.. Irreversible ones probably just need to emulate how a result would look like
06:57:43 <Philippa> having an interface for IO is a good idea anyway, no reason not to run in a dummy monad after that
06:58:02 <Philippa> Peaker: want to see the code? (I could not-totally-insanely squeeze it down to four lines, too)
06:58:33 <Peaker> Philippa: sure
06:59:58 <Philippa> http://hpaste.org/11545
07:00:23 <Philippa> there're some functions being called that were already written of course, and I've not counted the cost of the function that executes primitives other than bind or return because you'd be paying that either way
07:00:36 <ivanm> @seen gwern
07:00:36 <lambdabot> I saw gwern leaving #haskell 10d 12h 35m 34s ago, and .
07:00:53 <Philippa> the PBind case is the one I could reduce, of course
07:01:12 <ivanm> @ask gwern what exactly does your change-monger app do?
07:01:13 <lambdabot> Consider it noted.
07:02:09 <Peaker> Philippa: what's the 0 there doing?
07:02:25 <Philippa> it's part of the closure implementation
07:02:36 <Philippa> says it's not expecting any more parms before it does something
07:02:44 <Philippa> not necessarily needed for those cases, but important for others
07:02:55 <Peaker> btw, the funny thing is that Jonathan Edwards did not understand he reinvented monads, and has a section in his faq: "Why not use monads?" "Because they're so complicated few programmers manage to understand them"
07:03:02 <Philippa> heh
07:03:32 <Peaker> (not in these words, though)
07:04:34 <Peaker> Philippa: would that code join on the resulting IO action an arbitrary amount of times?
07:04:44 <Peaker> (as in, if it evaluates to an action again, execute that)
07:05:21 <Philippa> yeah, it executes the entire computation not just a single step
07:05:30 <Philippa> oh, wait.
07:05:34 <Philippa> no, it doesn't auto-join
07:05:40 <Philippa> you need a bind to make it call the 'next' thing
07:06:13 <Peaker> Philippa: I ask because you exec_ on the result of the right-side of bind
07:06:27 <Philippa> yeah, that's just the "and then run the result" that you expect to see
07:06:33 <Peaker> ah, exec_ which is not exec, yeah
07:07:10 <Philippa> *nod* - I appreciate the naming convention's a little confusing if you're not used to it - I would've made it ' instead of _, but at the time my editor screwed up the highlighting
07:07:32 <Philippa> the general pattern is that if I have foo and foo_, foo_ doesn't call foo
07:07:39 <Philippa> and foo is just a light wrapper
07:08:49 <Peaker> ' is often used for that, but then you have foldl'
07:09:05 <Peaker> I find elegance in the fact that both a compiler and an interpreter generate an executable description of the computation, one as an IO-typed value, and one as a lower language. I wonder if this means compilers/interpreters can share much more code than in imperative languages
07:10:24 <quicksilver> I sometimes use foo', sometimes foo_aux, sometimes 'where helper = '
07:10:28 <Philippa> can do, yeah. Though you'd need a more subtle interface than a monad to really do it right
07:10:30 <quicksilver> occasionally even foo'aux
07:10:34 <quicksilver> I really should be consistent :-/
07:11:26 <Saizan> Philippa: why?
07:12:03 <Peaker> quicksilver: I tried specifying a type signature for an auxiliary like that, but realized I needed a type-variable from an outer scope. Is it generally impossible to have explicit type signatures for nested experssions that use outer-names?
07:12:47 <lilac> how can i provide extra arguments to ld in a program built by Distribution.Simple ?
07:12:48 <Saizan> you need ScopedTypeVariables for that
07:13:18 <quicksilver> Peaker: you need an extension, in general. Which sucks.
07:13:23 <Peaker> How do scoped type variables work?  Do you explicitly specify the scope of a type variable, or is it the same as the normal lexical scope?
07:13:41 <quicksilver> Peaker: any type which explicitly mentions 'forall' is taken to introduct a scope for those variabels
07:13:52 <quicksilver> ...which is the normal lexical scope you would expect;
07:14:09 <Peaker> ah, cool.
07:14:51 <quicksilver> so the explicit forall (which is not legal in h98) is the key to make the extension do its stuff.
07:15:04 <Philippa> Saizan: return is a bugger, you can't compile it yourself
07:15:33 <Saizan> lilac: if it's for -lfoo you can pass extra-libraries: z
07:15:40 <Saizan> s/z/foo
07:16:00 <lilac> Saizan: i want --no-keep-memory, since i'm compiling on a box with almost no RAM
07:16:29 <Saizan> lilac: or i think you can pass it via ghc-options and -optl(?)
07:16:50 <lilac> excellent, thanks :)
07:16:59 <Peaker> Philippa: why not?  If I have an X86Assembly instance of Monad, I might have each monadic action leave the result pointed to by some register, and have return create the necessary assembly to have that register point to that?
07:18:10 <Philippa> Peaker: so you actually have an additional layer of interpretation there that isn't in the interpreter
07:18:26 <Philippa> also: you /don't have access to the code in return/
07:18:28 <Peaker> Philippa: I guess that wouldn't work at all, how do I generate assembly from Haskell functions? :P
07:18:37 <Philippa> yeah, exactly
07:19:09 <Peaker> monadic computations cannot be compiled into other forms of computations, I guess, they can only be executed
07:19:32 <quicksilver> well you can design monads which are designed to do that
07:19:42 <dancor> assembly combinator library
07:19:47 <Peaker> quicksilver: how can they implement >>= ?
07:19:52 <quicksilver> but the parts of them which are haskell expressions aren't introspectable.
07:19:58 <Philippa> quicksilver: not really. You can design things that pretend to be monads, otherwise you've just got a fancy version of Writer
07:20:25 <Philippa> yeah, exactly. So you don't get anything: you have to not use return
07:20:42 <Peaker> Philippa: why is "return" the problem, and not the right-hand-side of >>= ?
07:20:59 <Saizan> well the (a -> m b) part is also an not-instropectable haskell expression
07:21:28 <Peaker> I see, both return and (>>=)  take an argument that's not wrapped in a monad
07:21:43 <Philippa> Peaker: that's a problem too, but it's not the same class of problem - there's a formulation of monads that doesn't have it
07:22:06 <Peaker> Philippa: Aha, Applicative + join, but then both fmap and pure are a problem
07:22:19 <Philippa> right. But you /can/ provide analogues
07:22:40 <quicksilver> Philippa: yes indeed. ALthough you can use the 'carrier' to carry lables.
07:22:46 <Philippa> really the big deal is that you don't want your structure to use Hask as the host category
07:22:48 <quicksilver> Philippa: or some other domain specific thing.
07:23:14 <Philippa> sure. forall a.a is a bugger, more specific things are usable
07:23:19 <Peaker> Philippa: what analogue is usable for fmap?
07:23:21 <neppihpmas> if i'm computing really really big numbers, how do I get haskell to 1. stop saying infinity and 2. actually print the thing as opposed to putting it in standard form?
07:23:43 <quicksilver> neppihpmas: don't use Double.
07:23:46 <Philippa> Peaker: something that's limited to a DSL you can introspect but can't put in the compile-time
07:23:49 <quicksilver> neppihpmas: Double has limited precision.
07:24:02 <Philippa> (but can use to structure what does go there)
07:24:06 <Peaker> Philippa: is that not simply the monad alternative itself?
07:24:09 <neppihpmas> quicksilver, I'm not using doubles (or at least not intentionally)
07:24:12 <dolio> Look up the numbers package on hackage.
07:24:15 <dolio> And use CReal.
07:24:20 <Philippa> Peaker: I'm not sure I follow you
07:24:35 <Philippa> I mean yeah, really the big deal is <*> or ap
07:24:40 <Peaker> Philippa: If you replace (a->b) by (Monad m=>m (a->b)) you can introspect it, but you end up with <*>
07:24:46 <quicksilver> neppihpmas: Doubles are the only type with 'Infinity' as far as I know.
07:24:56 <neppihpmas> quicksilver, i'm not converting to doubles
07:24:57 <quicksilver> neppihpmas: if you tell me a bit more about what you're doing, I may be able to tell you more.
07:25:04 <Philippa> Peaker: not what I'm suggesting
07:25:05 <quicksilver> You gave me a pretty small clue so far.
07:25:05 <neppihpmas> quicksilver, i'll paste the code
07:25:08 <quicksilver> > 2 ^ 1000
07:25:10 <lambdabot>   107150860718626732094842504906000181056140481170553360744375038837035105112...
07:25:15 <quicksilver> that's quite a big number
07:25:19 <dolio> Doubles are the default for operations like (/).
07:25:22 <quicksilver> and yet it's not showing as infinity.
07:25:36 <dolio> Or sqrt, sin, ...
07:25:37 <Philippa> well, it's one way to do it, admittedly. But what you actually want is an equivalent type that's limited to the functions you like, as it were
07:25:48 <Philippa> so you get something more akin to arrows
07:25:48 <Peaker> Philippa: So would   Applicative + join - fmap - pure   do?
07:25:57 <neppihpmas> quicksilver, http://dpaste.com/87288/plain/
07:26:03 <Philippa> probably, yeah
07:26:17 <quicksilver> neppihpmas: use ^ not **
07:26:28 <neppihpmas> quicksilver, that's the python talking :P
07:26:48 <quicksilver> :t (**)
07:26:49 <lambdabot> forall a. (Floating a) => a -> a -> a
07:27:02 <quicksilver> Floating defaults to Double
07:27:02 <neppihpmas> quicksilver, do you like my ridiculous function?
07:27:26 <Philippa> Peaker: yeah, sorry, I'm rambling a bit. It's nearly 2:30pm and I'm only just having breakfast, I think it's showing
07:27:27 <quicksilver> well I'm don't get a particularly big kick out of fast growing functions
07:27:29 <quicksilver> but sure.
07:27:33 <quicksilver> it's fine :)
07:27:40 <Peaker> Philippa: you'd probably want to add something like limitedReturn :: (Introspectable a, MonadAlternative m) => a -> m a
07:28:00 <Peaker> Philippa: so you can have both IO and the other language compilable
07:29:18 <Philippa> *nod*
07:29:53 <jrh> so I've done something horrible to solve yesterday's problem of grabbing NBO 8 byte CDoubles...
07:30:00 <Peaker> could be cool to show how Haskell is powerful enough to have an interpreter/compiler share the implementation ;)
07:30:20 <Peaker> not sure how ghci vs ghc works..
07:30:23 <jrh> unsafePerformIO (withForeignPtr (castForeignPtr . fst3 . B.toForeignPtr $ y) peek)
07:30:28 <Philippa> you probably just need Introspectable for your value reps, don't you?
07:31:02 <jrh> where y is a bytestring of eight bytes that I just reversed
07:31:30 <jrh> will that work?  assuming the return type is CDouble?
07:32:03 <Peaker> Philippa: I think the type argument to a (MonadAlternative m) will always have to be Introspectable
07:32:24 <Philippa> yep, or something equivalent
07:34:05 <Philippa> it's pretty common to just fix it to one datatype, actually
07:34:56 <Peaker> Philippa: Maybe a generic class-based one would make the compiler extensible though, I haven't thought it through
07:35:02 <jrh> question, though for what I've done...  If I declare {-# INLINE #-} that function, but I give it type Storable a => B.ByteString -> a, will it still inline?
07:35:33 <Philippa> Peaker: there's a pile of ways to encode extensible algebraic datatypes
07:35:56 <Peaker> Philippa: How?
07:36:39 <Philippa> there's one example built on HList. Another's just to leave "extra" tags around and have explicit coercions from sub -> sup
07:38:08 <Peaker> HList is just an existential-type list?
07:38:25 <quicksilver> HList is just tuples.
07:38:31 <quicksilver> (nested tuples)
07:38:31 <Cale> Peaker: No, it's a homogeneous list in which the type of each element is encoded
07:38:41 <quicksilver> with a bunch of type classes around them to make them "easy" to manage.
07:38:53 <Cale> and there are operations which, say, pick out all the elements of any one type
07:39:24 <quicksilver> FVO "easy" approaching "major brain haemorrhage""
07:39:32 <Cale> haha
07:39:35 <Saizan> what's homogeneous in HList?
07:39:44 <Cale> er, heterogeneous
07:39:48 <Saizan> ah ok :)
07:39:54 <Peaker> When is it better to use a (SomeClass a => a) vs an extensible data type?
07:40:00 <Cale> (thanks)
07:40:09 <quicksilver> what is an extensible data type?
07:40:22 <Saizan> when you can't forget about the types
07:40:58 <Peaker> quicksilver: a data type encoding which allows extensions, as Philippa mentioned above
07:41:28 <quicksilver> I think that's comparing apples with oranges
07:41:34 <Philippa> quicksilver: we're talking about encodings of extensible variants ala ocaml
07:41:36 <Philippa> and yeah
07:41:42 <quicksilver> as Philippa said, there are muptiple encodings
07:41:45 <Philippa> but then: when does an apple work better? When does an orange?
07:41:55 <quicksilver> many of them use typeclasses
07:41:59 <quicksilver> to manage the encoding.
07:42:10 <Peaker> Philippa: well, the Introspectable case might be an example where I'd have to choose between one and the other.. I wonder what factors weigh in that decision
07:42:19 * Philippa has just realised why she needs to hurry up and implement the type system from the paper she's working on into a language...
07:42:43 <Philippa> Peaker: you just use an extensible encoding with a type that supports extra operations if you want to do it that way
07:43:12 <Philippa> but if the abstraction is "I've got this interface, it's fixed, you don't care what's behind it", then the type class is probably the way to go to start with
07:44:04 <Cale> I think that nails it pretty much: whether you can determine at this moment what the important operations are which bring together the various cases involved.
07:44:29 <plutonas> how would one implement insertion sort and shell sort in haskell? (because the way the algorithm is described, it would require change in variables
07:44:42 <Peaker> Any examples for when you can't pre-determine the set of operations you'd use on that data type?
07:44:42 <dmwit_> :t foldr insert
07:44:44 <lambdabot> forall a. (Ord a) => [a] -> [a] -> [a]
07:44:49 <dmwit_> :t foldr insert []
07:44:50 <lambdabot> forall a. (Ord a) => [a] -> [a]
07:44:55 <Cale> If you can't decide, then maybe something along the lines of having an algebraic type with a case for "other", which gets filled in by some type variable would be appropriate, if a little bit messy.
07:44:57 <dmwit_> plutonas: There's insertion sort.
07:45:25 <plutonas> hm
07:45:28 <dmwit_> plutonas: (Not that it's a particularly performant implementation of that algorithm.)
07:45:29 <Peaker> If you don't know what you're going to do with a value at all, why is it there? :-)
07:45:37 <quicksilver> plutonas: for a precisely comparable implementation, you'd use mutable arrays.
07:45:50 <quicksilver> plutonas: it wouldn't be a very interesting thing to do, in my opinion.
07:45:57 <Cale> Peaker: It might be there because something entirely different will need it later, and you just need to pass it along.
07:45:58 <plutonas> i care about implementing the algorithm idea not the pseuydocode
07:46:15 <plutonas> and don't care much about performance if it isn't an overkill
07:46:16 <quicksilver> the common 'functional insertion sort' uses the same intuitive ideas as the common imperative one
07:46:23 <quicksilver> it's a totally different algorithm though
07:46:33 <quicksilver> (linked list ==> no 'shift-up' cost for the array)
07:46:45 <quicksilver> really they're different algorithms based on the same idea.
07:46:56 <plutonas> dmwit_: though i didn't understand your code so good
07:47:08 <Peaker> Cale: passing it along is kind of using it, though, especially as the code you're passing it along to requires a certain type?
07:47:10 <plutonas> foldr insert [] ?
07:47:26 <dmwit_> > foldr insert [] [5,3,4,2,1]
07:47:28 <lambdabot>   [1,2,3,4,5]
07:47:46 <Cale> Peaker: but that's the advantage of the parameter -- it need not be any specific type, and you make no specifications for what operations that type supports.
07:47:53 <dmwit_> plutonas: "insert" is from the Prelude (I think, or maybe Data.List); it inserts an element in the "correct" sorted position in a list.
07:48:00 <dmwit_> > insert 3 [1,2,4,5]
07:48:01 <lambdabot>   [1,2,3,4,5]
07:48:07 <plutonas> oh alright
07:48:08 <plutonas> :)
07:48:14 <Peaker> Cale: I guess I need to see a real example of that to understand where it is useful
07:48:24 <Saizan> Peaker: you may like Data Types a la Carte on this subject, btw
07:48:58 <Cale> Peaker: For a possibly oversimplified example, look at the length function. It doesn't care what the elements of the list are at all.
07:49:11 <plutonas> dmwit_: though here it doesn't work
07:49:15 <plutonas> Prelude Data.List> foldr insert [] [6 2 3 4 5 6]
07:49:15 <plutonas> <interactive>:1:17:
07:49:15 <plutonas>     No instance for (Num (t -> t1 -> t2 -> t3 -> t4 -> a))
07:49:15 <plutonas>       arising from the literal `6' at <interactive>:1:17-27
07:49:24 <dmwit_> plutonas: Check your list syntax.
07:49:28 <plutonas> (insert is in Data.List by the way)
07:49:29 <plutonas> oohhh
07:49:34 <dmwit_> [6 2 3 4 5 6] -> [6, 2, 3, 4, 5, 6]
07:49:34 <Cale> Peaker: To do its work, it need not specify anything about the type of elements. But then why should the elements be in the list at all?
07:49:42 <plutonas> yeap thanks
07:49:49 <Peaker> Cale: yeah, so it can just use a "forall a. a", which could be said to be a subcase of (forall a. (SomeClass a, AnotherClass a, ...) => a)
07:49:50 <plutonas> that happens when i switch between languages too often
07:49:59 <dmwit_> plutonas: Matlab?
07:50:03 <plutonas> lisp
07:50:08 <plutonas> how would you do shellsort though
07:50:11 <dmwit_> ah
07:50:14 <dmwit_> What's shellsort?
07:50:23 <Peaker> Cale: I am wondering when you would prefer to have an HList or some other encoding of an extensible data type, instead of a (SomeClass a => a) type
07:50:24 <plutonas> it sorts sublists first
07:50:38 <plutonas> like the 1st, 5th, 10th etc element are sorted
07:50:54 <dmwit_> 1st, 5th, 10th?
07:50:56 <plutonas> and the result is put on the 1st,5th and so on position of the list
07:50:57 <Cale> Peaker: Oh, well, HLists peg the types of the elements down exactly.
07:50:59 <dmwit_> Does it follow some pattern?
07:51:07 <plutonas> then 2nd, 6th, 11th etc
07:51:21 <plutonas> and after 4th 9th 14th etc are also sorted
07:51:26 <plutonas> it calls insertion sort
07:51:31 <plutonas> (so there are less move arrounds
07:51:33 <plutonas> )
07:51:44 <dmwit_> I guess you meant 0th, 5th, 10th and 1st, 6th, 11th?
07:52:03 <plutonas> well yes
07:52:07 <dmwit_> ok =)
07:52:08 <plutonas> :)
07:52:18 <idnar> what is the 0th element of a list?
07:52:21 <idnar> the element at index -1?
07:52:33 <Cale> Peaker: If I have an HList of type  Integer :*: String :*: String :*: [Employee], say,
07:52:35 <Peaker> idnar: maybe in Pascal ;)
07:52:37 <dmwit_> Probably the most direct translation of this one would use mutable arrays.
07:52:51 <Cale> Peaker: I can do anything at all which I could do with an Integer, a couple of strings, and a list of Employees.
07:52:55 <dmwit_> Check out STArray (or STUArray for speed).
07:53:14 <idnar> Peaker: if the first index of the list is 0, then I would call the element at that index the 1st (or "first") element
07:53:48 <Peaker> Cale: yes, I see, so if you don't know to limit the operations you'll end up being able to do (leaving the user of those types open for change), you cannot use a typeclass, and need something like HList
07:53:51 <Cale> Peaker: If instead, I choose to record a homogeneous list of existentials, where I'm guaranteed there are some operations (maybe length, for instance), which I can apply to each of the elements, I can't do some things anymore.
07:54:23 <plutonas> dmwit_: thanks
07:54:43 <plutonas> is there some good tutorial, reference on them?
07:54:43 <Peaker> idnar: I think its a shame natural languages have mostly adopted a 1-based index naming scheme
07:55:08 <idnar> Peaker: it's not really 1-based
07:55:21 <idnar> Peaker: that's sort of a hack "
07:55:22 <idnar> :P
07:55:46 <idnar> it's actually a counting scheme, not an index naming scheme
07:55:50 <Peaker> idnar: well, first correlates to one (because "third" correlates to "three"), and so it is one based
07:56:00 <idnar> and you generally state the count *after* you count a particular item
07:56:03 <Peaker> idnar: "first" is more an index than a count
07:56:23 <idnar> well, ok, yeah
07:56:44 <dmwit_> plutonas: It uses the MArray interface and the ST monad for most of the magic; at the very end, you can use runST[U]Array to bring the array into the pure world.
07:56:45 <idnar> but "eighth" means "the element after which the count is eight"
07:57:06 <plutonas> ough
07:57:13 <dmwit_> plutonas: If you pretty much grok monads, I'd say the STArray/MArray docs are the best place to start.
07:57:35 <plutonas> ok, thanks again
07:58:02 <dmwit_> If you come up with some specific questions, definitely ask here.
07:58:24 <dmwit_> I'm going to be hanging around for a bit, and I've just done a pretty STUArray-heavy calculation recently, so I may be able to help, at least.
07:59:56 <plutonas> :)
08:03:44 <byorgey> and remember, STRefs are lazy ;)
08:03:57 <dmwit_> Yikes, yes.  Remember that.
08:04:03 <dmwit_> =/
08:04:14 <byorgey> hehe
08:12:24 <salty-horse> hi. in chapter 4 of real world haskell, filter is implemented with foldr. Is there any reason to prefer foldr over foldl for this purpose?
08:13:51 <int-e> yes, the foldl version would not be lazy; for example (filter odd [1..]) would not work with it.
08:15:28 <int-e> hmm, it would also be harder to implement - filter p = foldl (\xs x -> if p x then xs ++ [x] else xs) [] ? -- note the concatenation (++) where the foldr version can use (:)
08:16:29 <salty-horse> yes, I used concatenation :)
08:17:08 <int-e> salty-horse: the problem being, the end result will be (([] ++ [1]) ++ [2]) ++ [3] ..., so you end up appending to increasingly longer lists.
08:17:44 <int-e> salty-horse: so using foldr is both more lazy and more efficient in that case.
08:18:05 <salty-horse> I need a bit to think about the difference :)
08:18:22 <salty-horse> (of time) :)
08:19:02 <salty-horse> I also noticed the parameters of the step function in foldl and foldr are reversed
08:19:18 <salty-horse> (accumulator and new value)
08:20:21 <Saizan> that's to mimick the direction from where those values come from
08:21:32 <Saizan> the one in foldr is not really an accumulator, but rather the result of the corresponding recursive call
08:26:33 <lilac> > (foldl f a [1..5], foldr f a [1..5])
08:26:36 <lambdabot>   (f (f (f (f (f a 1) 2) 3) 4) 5,f 1 (f 2 (f 3 (f 4 (f 5 a)))))
08:27:58 <lilac> > (foldl (*) a [1..5], foldr (*) a [1..5])
08:28:01 <lambdabot>   (a * 1 * 2 * 3 * 4 * 5,1 * (2 * (3 * (4 * (5 * a)))))
08:28:53 <lilac> ^^ the argument order is chosen so that foldl and foldr give the same order for an associative, but not commutative, operator
08:29:03 <lilac> s/order/result/
08:30:16 <salty-horse> lilac, I think I understand that difference.. I still need to grok the lazyness of foldr over foldl
08:30:23 <Cale> salty-horse: If it helps, I have some diagrams illustrating the action of foldr and foldl here: http://cale.yi.org/index.php/Fold_Diagrams
08:30:25 <lambdabot> Title: Fold Diagrams - CaleWiki
08:30:30 <Cale> Let's look at the laziness.
08:30:40 <Cale> Do you know what lazy evaluation is?
08:30:58 <salty-horse> yes. here's what's confusing me in other words:
08:31:02 <Cale> If not, it's basically just evaluating the outermost function in an expression first.
08:31:22 <Cale> Whereas strict evaluation evaluates the innermost function first.
08:31:46 <Cale> (there's actually an additional subtlety to it, but that's enough to understand why foldr works and foldl doesn't)
08:31:54 <salty-horse> It feels like since foldr starts from the end, it has to go all the way and back.... while foldl is more "logical" starting from the head
08:32:04 <Cale> Actually, it's the other way around
08:32:17 <earthy> salty-horse: feels like
08:32:19 <Cale> foldr starts from the head, foldl starts from the end
08:32:20 <salty-horse> Cale, yes, that's what I see after expanding the steps into an expression :)
08:32:33 <Cale> foldr (+) 0 [1,2,3]
08:32:37 <earthy> salty-horse: however, if you look at the nesting of the creation of the list you'll see that is not the case
08:32:42 <Cale> -> 1 + (foldr (+) 0 [2,3])
08:32:47 <earthy> [1,2,3] = (1:(2:(3:[]))
08:32:53 <Cale> -> 1 + (2 + (foldr (+) 0 [3]))
08:33:05 <Cale> -> 1 + (2 + (3 + foldr (+) 0 []))
08:33:11 <Cale> -> 1 + (2 + (3 + 0))
08:33:47 <Peaker> > foldr (+) 0 [1,2,3] :: Expr
08:33:50 <lambdabot>   1 + (2 + (3 + 0))
08:33:53 <Cale> In this specific case, + isn't a lazy operation, it's strict in both its arguments, so there's no benefit here.
08:34:00 <earthy> > foldl (+) 0 [1,2,3] :: Expr
08:34:03 <lambdabot>   0 + 1 + 2 + 3
08:34:14 <lilac> heh, neat, i didn't know there was a Num Expr instance :)
08:34:25 <earthy> me neither
08:34:27 <Cale> But if you were to pass foldr a function which maybe didn't have to look at its second argument to produce a result, then foldr would have an advantage of being able to stop
08:34:52 <Cale> @src foldr
08:34:52 <lambdabot> foldr f z []     = z
08:34:52 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
08:35:08 <Cale> after the first step, it's the function f which gets to evaluate next
08:35:11 <lilac> foldr (const 1) undefined (undefined:undefined)
08:35:14 <lilac> > foldr (const 1) undefined (undefined:undefined)
08:35:17 <lambdabot>       No instance for (Num (b -> b))
08:35:17 <lambdabot>        arising from the literal `1' at <...
08:35:17 <Cale> (in the nonempty list case)
08:35:23 <salty-horse> this is getting a bit infodumpy :)
08:36:00 <salty-horse> I'll be back after a few minutes of thought
08:36:05 <Cale> Let's look at foldr (\x xs -> 2*x : xs) [] [1,2,3], and pretend that we only care about what the first element of the resulting list is.
08:36:13 <Cale> oh, all right :)
08:37:27 <mauke> preflex: seen mmorrow
08:37:27 <preflex>  mmorrow was last seen on #haskell 2 hours, 25 minutes and 2 seconds ago, saying: hehe
08:37:30 <preflex>  mauke: you have 1 new message. '/msg preflex messages' to read it.
08:38:34 <Cale> salty-horse: foldl always recurses right away until it reaches the end of the list, not giving any chance for anything else to evaluate until then
08:43:23 <dancor> i have a parsec parser with a state (st) of Bool.  i would like to see the state at the end of the parse, but runParser seems to throw it away
08:43:50 <dancor> i am not supposed to use the state like this?  or is there an easy way to see the final state
08:44:42 <dancor> what i'm doing in general is performing changes to some lexed files and the state keeps track of if any changes have been made
08:44:45 <earthy> getParserState :: GenParser tok st (State tok st)
08:44:47 <dancor> ah
08:45:04 <earthy> getState :: GenParser tok st st
08:45:10 <earthy> hth
08:47:42 <jrh> can a ' occur in the middle of a symbol?
08:47:51 <dolio> Yes.
08:47:52 <dmwit> yes
08:47:59 <dolio> this'is'a'valid'function'name
08:48:01 <jrh> like oh args'afterthought
08:48:21 <jrh> thanks
08:48:26 <dolio> Oleg names functions like that sometimes.
08:49:31 <byorgey> hm, anyone know a general strategy for handling associativity when pretty-printing expressions?
08:49:46 <byorgey> i.e. I want to leave out parens that are unnecessary due to associativity conventions.
08:50:06 <dolio> Have you seen showsPrec?
08:50:13 <byorgey> @type showsPrec
08:50:15 <lambdabot> forall a. (Show a) => Int -> a -> String -> String
08:50:15 <dmwit> precedence /= associativity ;`-)
08:50:28 <dmwit> Man, I'm big on the typos today.
08:50:38 <opqdonut> ^_^
08:50:40 <byorgey> I know that, I meant associativity
08:51:03 <byorgey> I understand how to deal with precedence a la showsPrec.
08:51:14 <byorgey> dolio: are you saying showsPrec deals with associativity as well?
08:51:24 <byorgey> or is there some way to encode it using precedence?
08:51:29 <dmwit> I guess one way is to encode your data type with the same associativity as the operator it represents.
08:51:35 <dolio> Hmm, no. But you could probably pass along an associativity, too.
08:51:52 <dmwit> i.e. data Expr = Plus Int Expr vs. data Expr = Plus Expr Int
08:52:06 <dmwit> ...but that's not very general.
08:52:10 <byorgey> dmwit: I don't see how that helps
08:52:21 <dmwit> byorgey: Yeah, it actually hurts.
08:52:28 <byorgey> heh
08:52:40 <dmwit> Since then you can't even represent something with the wrong associativity.
08:53:08 <dmwit> byorgey: Is it harder than just parenthesizing one side?
08:53:10 <dolio> For instance, if you get passed in N and Right, then if your operator is Right associative with precedence N, you don't need parentheses.
08:53:20 <dolio> Or any associativity with precedence > N.
08:53:28 <byorgey> dolio: ah, I see, that makes sense
08:53:44 <dolio> I don't know if that actually works, but it's worth a shot.
08:54:03 <byorgey> sure, I'll try it =)
08:54:30 <dancor> earthy: i'm still not sure how to have the final state after running the parser
08:55:18 <dmwit> dancor: liftM2 (,) getState parser
08:55:40 <dmwit> :t liftM2 (,) getState
08:55:41 <lambdabot> Not in scope: `getState'
08:55:46 <Saizan> more like liftM2 (,) perser getState
08:55:52 <dmwit> :t liftM2 (,) Text.ParserCombinators.Parsec.getState
08:55:53 <lambdabot> forall a2 tok st. Text.ParserCombinators.Parsec.Prim.GenParser tok st a2 -> Text.ParserCombinators.Parsec.Prim.GenParser tok st (st, a2)
08:56:00 <dmwit> Saizan: ...sure
08:56:02 <Saizan> unless you want the initial state :)
08:56:06 <dmwit> Ah, yes.
08:56:11 <dmwit> You're right, of course.
08:57:21 <dancor> that's sweet
08:59:56 <salty-horse> Cale, so foldr is lazy because I know the intermediate value of the accumulator at each step, where in foldl it is buried inside parentheses?
09:00:59 <dmwit> foldr is lazy because the first argument to the function you supplied is the first element of the list.
09:01:00 <Cale> salty-horse: Well, it's more that the function which is accumulating the values gets a chance to evaluate, and if it doesn't need its second parameter to get (part of) its result, then the recursion stops.
09:01:07 <Cale> @src foldr
09:01:07 <lambdabot> foldr f z []     = z
09:01:07 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
09:01:24 <Cale> See, after the first step in the nonempty list case, the next thing to evaluate will be f
09:01:35 <Cale> (because it's the outermost function)
09:02:00 <salty-horse> yes, I'm looking at the two implementations from real world haskell
09:02:24 <Cale> and if it happens to not need its second parameter, or it only uses its second parameter in a deeper part of its result, after the topmost data constructor, then the computation might just stop.
09:02:33 <Cale> That foldr might never be called.
09:02:44 <Cale> On the other hand:
09:02:46 <Cale> @src foldl
09:02:46 <lambdabot> foldl f z []     = z
09:02:46 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
09:03:06 <dancor> is foldlM the same as foldM, but mysteriously renamed unlike other things in Data.Foldable?
09:03:15 <Cale> foldl never gives f a chance to evaluate, its result is another call to foldl, so foldl just keeps getting called until the list runs out of elements
09:03:55 <salty-horse> which is called "tail recursion"? and what's the other recursion term?
09:04:02 <Cale> dancor: I believe the foldM in Data.Foldable gives an arbitrary association of the elements, but don't hold me to that.
09:04:25 <daf> salty-horse: non-tail recursion?
09:04:39 <Cale> salty-horse: Well, tail recursion is where the result of a recursive call is the result of the function.
09:04:50 <Cale> salty-horse: (foldl here is tail recursive)
09:05:50 <Cale> Tail recursion has the advantage that it can be compiled into a nice tight loop.
09:06:22 <Cale> However, lazy evaluation here means that this tight loop does nothing but build up a large expression, which is only evaluated after the loop finishes.
09:06:42 <salty-horse> and in functional programming this is usually "better"?
09:06:44 <Cale> For instance:
09:06:49 <Cale> foldl (+) 0 [1,2,3]
09:06:57 <Cale> -> foldl (+) (0+1) [2,3]
09:07:02 <Cale> -> foldl (+) ((0+1)+2) [3]
09:07:06 <Cale> -> foldl (+) (((0+1)+2)+3) []
09:07:13 <Cale> -> ((0+1)+2)+3
09:07:43 <salty-horse> you don't have to repeat those traces.. I got them by now :)
09:07:57 <Cale> While those steps happen very quickly, most of the work is still left to be done, and in the meantime, we're building up an expression which may take lots of memory.
09:08:08 <Cale> For this reason there's a variant of foldl called foldl'
09:08:19 <salty-horse> yes, I know that from regular procedural programming
09:08:22 <Cale> foldl' forces the evaluation of the accumulating parameter as it goes
09:08:53 <Cale> Well, this is different from procedural programming (at least in any procedural language I'm aware of)
09:09:26 <Cale> because you have values which are retained as expressions in memory, and not evaluated immediately
09:09:28 <salty-horse> foldl' 's behavior is what I logically took for granted in my "manual" implementation of foldl
09:09:37 <Cale> aha, yes
09:09:42 <Cale> that would be likely :)
09:10:08 <salty-horse> "take each element from the head and start adding them. you don't have to get to the end to have some kind of value in your hand"
09:10:10 <dancor> :t \ p -> liftM2 (,) p Text.ParserCombinators.Parsec.getState
09:10:11 <lambdabot> forall a1 tok st. Text.ParserCombinators.Parsec.Prim.GenParser tok st a1 -> Text.ParserCombinators.Parsec.Prim.GenParser tok st (a1, st)
09:10:36 <Cale> Note that even foldl' doesn't necessarily force full evaluation, and sometimes you need to do a little more. It forces evaluation of the accumulating parameter *up to determining the top level constructor*
09:10:55 <Cale> which is often enough, especially for things like integers, but for compound data structures might not be
09:11:00 <salty-horse> so should I strive for lazyness when implementing functions, or use it just when I need it?
09:11:12 <Cale> Well, my heuristic is this...
09:11:59 <Cale> If I'm taking lots of values which could be separately evaluated and getting a result which uses them all to produce a value that doesn't have lots of parts which could conceivably be separately evaluated, then strict evaluation is what is needed.
09:12:08 <Cale> In all other cases, laziness does fine, or better.
09:12:32 <Cale> That is, if I'm taking something "large" and turning it into something "small"
09:12:39 <Cale> for appropriate definitions of "large" and "small"
09:13:08 <Cale> Searching through a large structure for a single element can still be done lazily to good effect too.
09:13:25 <Cale> But it's these processes which summarise lots of data where strictness is important.
09:13:51 <quicksilver> Stream -> Stream -- do it lazily
09:13:56 <quicksilver> Stream -> Summary -- do it strictly
09:14:03 <quicksilver> is the most common pattern.
09:14:05 <salty-horse> Cale, by "separately evaluated" do you mean things like map?
09:14:13 <Cale> salty-horse: I mean like the elements of a list
09:15:19 <Cale> Or the results of evaluating a function for various different parameters.
09:15:33 <Cale> Or some other data structure which is lazy.
09:15:40 <Cale> (lazy trees, etc.)
09:16:59 <salty-horse> then I don't understand yet... I'll think I'll continue to other chapters and keep thinking of it
09:18:33 <salty-horse> thanks for the explanations!
09:18:58 <Cale> salty-horse: To get a feel for the reason for this heuristic takes some time and practice.
09:19:50 <salty-horse> now I have another mental roadblock. I keep thinking of foldr's result as simply foldl on the reversed list :D
09:19:52 <Cale> But basically, it has to do with the fact that if the thing you're constructing doesn't have many parts which could be evaluated separately, you're going to end up doing all the work anyway. So using memory to record that work needs to be done is a waste.
09:20:37 <Cale> and in other cases, it might be a waste of time to do the work up front.
09:20:51 <Cale> (or at least, usually doesn't hurt so much)
09:21:08 <sleven> challenge!
09:21:09 <sleven> http://bc.tech.coop/blog/081027.html
09:21:19 <sleven> http://www.reddit.com/r/programming/comments/79mse/exploring_clojure_lisp_on_the_jvm_part_3_some/
09:21:19 <lambdabot> Title: Bill Clementson's Blog: Exploring Clojure (Lisp on the JVM) - Part 3 - Some Lang ...
09:21:21 <lambdabot> Title: Exploring Clojure (Lisp on the JVM) - Part 3 - Some Language Features : programm ..., http://tinyurl.com/6pjw9z
09:21:35 <sleven> seq_xor xs = foldl1 (++) $ filter (\x -> length x == 1) $ groupBy (==) $ sort $ foldl1 (\x y -> x ++ nub y) xs
09:22:01 <sleven> i made a python one with a dict that was superfast, the haskell one is prob pretty slow, im gonna better it
09:22:39 <quicksilver> the binary version is (a\\b) ++ (b\\a) isn't it?
09:22:47 <quicksilver> although that's not necessarily the best algorithm.
09:23:24 <sleven> wait my algo is not working correclty either
09:23:52 <quicksilver> > let xor a b = (a\\b) ++ (b\\a) in "abc" `xor` "ac"
09:23:53 <lambdabot>   "b"
09:24:00 <quicksilver> > let xor a b = (a\\b) ++ (b\\a) in "abc" `xor` "adc"
09:24:01 <lambdabot>   "bd"
09:24:10 <quicksilver> looks right to me. Maybe I read it too fast though.
09:24:10 <sleven> lol
09:24:29 <BrokenClockwork> Hey, I am new to Haskell and I am confronted with the compiler error "Non-exhaustive patters in function dec" (@ http://hpaste.org/11546 ). When I use the argument of one list element, for instance: dec [1] 3 4 ... then it works, otherwise not, I have no clue
09:24:50 <mauke> :-S
09:24:58 <quicksilver> BrokenClockwork: you have indeed only defined that function for the case when the first arg is a list of length exactly one
09:25:06 <mauke> what's the point of [d] !! 0?
09:25:06 <sleven> not correc tthough
09:25:08 <quicksilver> BrokenClockwork: [d] is a pattern which matches a list of length exactly one
09:25:09 <mauke> it's always d
09:25:14 <plutonas> http://pastebin.ca/1238742 <--- hello, i implemented 5 sorting algorithms in haskell, can someone please take a look at the code and comment on it?
09:25:17 <quicksilver> BrokenClockwork: (and that one element is d)
09:25:27 <BrokenClockwork> oh
09:25:33 <BrokenClockwork> I get it
09:25:46 <BrokenClockwork> well how can I declare that the input for d ist a list for the user?
09:26:05 <mauke> what
09:26:12 <Peaker> BrokenClockwork: declare what?
09:26:17 <u_quark> is there a "when should I use haskell" article somewhere ?
09:26:30 <BrokenClockwork> d to a list of integer
09:26:56 <Leibnix> Hello! I'm just another newbie. I wonder how one might write things like priority queues in a purely functional language?
09:26:57 <BrokenClockwork> dec d b r = ... won't do, because it will only accept one number and not a list of numbers
09:27:04 <mauke> BrokenClockwork: wrong
09:27:18 <BrokenClockwork> oh
09:27:36 <BrokenClockwork> well I forgot to try this one... damn, thanks :)
09:27:52 <Peaker> plutonas: I find it a little bit weird that you choose to return xs' and not xs after a bubble iteration went unchanged (though I don't know if that's bad :-)
09:28:22 <Cale> Leibnix: well, you might look at the finger trees paper for one rather beautiful approach to it.
09:28:29 <BrokenClockwork> working, weeh :)
09:28:31 <plutonas> Peaker: well it's the same, but i think xs is better
09:28:38 <ddarius> Leibnix: http://www.palgrave.com/products/title.aspx?is=0333992857 The sample chapter is interesting.
09:28:40 <lambdabot> Title: The Fun of Programming >> Palgrave.com : Title Page
09:28:41 <plutonas> anything else?
09:28:44 <Peaker> plutonas: I think a real mergesort depends on random access, yours will be O(n*n) I think
09:28:52 <Leibnix> Thanks!
09:28:54 <Cale> Leibnix: but you can build a nice priority queue from the existing fast structures available with GHC, like Data.Sequence, rather easily.
09:28:59 <mornfall> Mergesort and random access?
09:29:13 <mornfall> Wasn't like the whole point of it to not need that?
09:29:39 <plutonas> Peaker: are you sure?, i mean i'm just splitting and attaching sublists
09:29:56 <ddarius> You can implement a nice priority queue in about 10 lines of code from scratch, not even using standard library functions.
09:29:58 <plutonas> and i thought thats what the algorithms says
09:29:59 <Peaker> plutonas: I'm not sure, no
09:30:03 <quicksilver> Peaker: nah, merge sort is (log n) linear passes
09:30:18 <plutonas> quicksilver: even my implementation?
09:30:21 <plutonas> have to check this
09:30:23 <Peaker> quicksilver, plutonas: Yeah, my bad, it seems valid
09:30:26 <ddarius> @google k-funnel sort
09:30:31 <lambdabot> http://courses.csail.mit.edu/6.897/spring03/scribe_notes/L17/lecture17.pdf
09:30:31 <lambdabot> Title: Lecture 17 â April 28, 2003 1 Overview 2 External-Memory Sorting 3 Cache-Obliv ...
09:30:31 <quicksilver> although as remarked earlier pretty much all algorithms are different in immutable form.
09:30:40 <Cale> Leibnix: you'll also find on Hackage, a package called PSQueue, which is a rather beautiful datastructure combining the benefits of a priority queue and a search tree.
09:30:50 <RayNbow> has anyone ever implemented http://en.wikipedia.org/wiki/Bogosort in Haskell?
09:30:57 <Leibnix> All right. Would these 'fast' structures guarantee O(log n) operations?
09:31:09 <ddarius> Leibnix: That and more.
09:31:13 <quicksilver> so really most of plutonas's algorithms are something different.
09:31:19 <quicksilver> the quicksort for example is definitely not a quicksort
09:31:29 <quicksilver> actually the merge sort is probably one of the morally closest.
09:31:40 <plutonas> quicksilver: really? Now you dissapoint me
09:31:50 <plutonas> though i guess there's not much i can do about it, can i?
09:31:52 <quicksilver> no.
09:31:58 <quicksilver> it's a different frameowrk.
09:32:10 <quicksilver> the classic statement of these algorithms is mutable, random access arrays.
09:32:17 <quicksilver> you're implementing them with immutable linked lists
09:32:23 <quicksilver> so obviously you get something different ;)
09:32:31 <quicksilver> with quicksort it's very, very different.
09:32:46 <quicksilver> with merge sort it's actually quite similar.
09:32:52 <plutonas> quicksilver: could i have a closer implementation on any of them
09:32:57 <Peaker> quicksilver: wouldn't the moving indices trick be possible to implement functionally? (Even if quite tediously)
09:33:09 <quicksilver> (because merge sort doesn't actually use random access)
09:33:26 <Philippa> Peaker: it can all be implemented, much of it has appalling performance with lists
09:34:10 <quicksilver> your naive quicksort there, using Data.Seq instead of List
09:34:11 <lament> Quicksort is an algorithm for sorting a constant access time array in place.
09:34:12 <Peaker> Yeah, swapping two indices won't be nice :)
09:34:15 <quicksilver> becomes quite a bit better.
09:34:32 <quicksilver> without thinking a bit hrder I'm not sure if it changes complexity class
09:35:01 <Peaker> isn't there a typeclass that both lists and Data.Seq have instances of, and encompasses all the operations used by his implementation of qsort?
09:36:26 <quicksilver> Monoid + Foldable
09:36:31 <quicksilver> (so it's two type classes)
09:44:11 <Peaker> wouldn't it be nice if most code used typeclasses like these instead of being specific for lists/etc?
09:44:26 <dolio> I'm incredulous that qsort is expressible using Monoid and Foldable.
09:44:54 <Cale> Peaker: Various specific types express specific ideas perfectly.
09:44:54 <quicksilver> dolio: well Monoid + Foldable gives you an isomorphism with list
09:45:03 <opqdonut> yeah but it isn't qsort
09:45:07 <quicksilver> dolio: (assuming something about the compatibility between the two)
09:45:10 <quicksilver> opqdonut: right.
09:45:15 <Peaker> Cale: but why be specific to list, when Data.Seq would also work? Is that really part of the idea you're expressing?
09:45:34 <quicksilver> dolio: it particular that foldr mappend mempty . toList === id
09:45:41 <Philippa> Peaker: have some hysterical raisins :-)
09:45:46 <mauke> YO DAWG I HEARD YOU LIKE METACIRCULARITY SO WE PUT AN INTERPRETER IN YOUR INTERPRETER SO YOU CAN RUN CODE WHILE YOU RUN CODE
09:45:57 <Cale> Peaker: Well, for one, algorithms which are expressed in a way which is efficient for one type may be completely inefficient for the other.
09:46:07 <quicksilver> Peaker: part of the idea you are expressing is space + time complexity
09:46:23 <quicksilver> an interace which 'papers over' entirely different complexities is not a very useful abstraction.
09:46:23 <int-e> mauke: what's that, a lambdacat picture?
09:46:35 <Cale> Peaker: Lists are the best possible datastructure for expressing iteration.
09:46:35 <Philippa> most of the time we don't want to pick a specific sort, we want a fast sort for the type in question
09:47:07 <Cale> Peaker: Data.Sequence doesn't do all that well (constant factor wise), when you use it like a cons-list.
09:47:39 <dolio> quicksilver: fromList . sort . toList is viable I guess. But you can't write fromList without some way to inject elements into the alternate sequence monoid.
09:47:42 <mauke> int-e: http://images.encyclopediadramatica.com/images/c/cc/Sup_dawg.jpg
09:47:51 <Cale> On the other hand, you can split a Data.Sequence in the middle in log time, which is something you can't do efficiently at all with a list.
09:48:12 <quicksilver> dolio: oh, damn. you're right.
09:48:15 <quicksilver> dolio: you need 'pure' too
09:48:15 <dolio> @remember mauke YO DAWG I HEARD YOU LIKE METACIRCULARITY SO WE PUT AN INTERPRETER IN YOUR INTERPRETER SO YOU CAN RUN CODE WHILE YOU RUN CODE
09:48:16 <lambdabot> Done.
09:48:23 <dolio> Hah! :)
09:48:23 <quicksilver> dolio: from Applicative or some such.
09:48:47 <Cale> OMG GUYS! HELP! I ACCIDENTALLY THE WHOLE INTERPRETER!
09:49:15 <lament> is it bad?
09:49:37 <int-e> . o O ( fix interpreter )
09:50:17 <Cale> fix (\k -> I ACCIDENTALLY k THE WHOLE INTERPRETER!)
09:51:01 <BONUS_> @tell Philippa i changed all mentions of 'type coercion' to 'type annotations' and added an explanatory sentence or two
09:51:01 <lambdabot> Consider it noted.
09:51:05 <idnar> Cale: hahaha
09:51:18 <lilac> Cale: YOU ACCIDENTALLY WHAT?
09:51:24 <BONUS_> haha
09:51:27 <BONUS_> the whole interpreter
09:51:29 <Cale> lilac: THE WHOLE INTERPRETER!
09:51:34 <lilac> !!
09:51:37 <lament> > fix (\k -> "I ACCIDENTALLY " : k : " THE WHOLE INTERPRETER")
09:51:38 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
09:51:49 <lament> bah
09:51:52 <lament> ++
09:51:53 <mauke> ++
09:51:55 <idnar> > fix (\k -> "I ACCIDENTALLY " ++ k ++ " THE WHOLE INTERPRETER")
09:51:56 <lambdabot>   "I ACCIDENTALLY I ACCIDENTALLY I ACCIDENTALLY I ACCIDENTALLY I ACCIDENTALLY...
09:52:26 <idnar> I wonder if there's any way to turn that into "I ACCIDENTALLY I ACCIDENTALLY I ACCIDENTALLY...THE WHOLE INTERPRETER THE WHOLE INTERPRETER THE WHOLE INTERPRETER"
09:53:02 <Cale> by replacing fix with another function, yes
09:53:06 <dolio> Would lambda cats accept a picture of Xzibit?
09:54:33 <Philippa> BONUS_: cool
09:54:33 <lambdabot> Philippa: You have 1 new message. '/msg lambdabot @messages' to read it.
09:56:27 <x6d65> When using Data.Heap, to get a MinHeap do I just need to explicitly type the heap given by the 'empty' function?
09:57:09 <quicksilver> well you don't normally need to explicitly type
09:57:17 <quicksilver> because it can normally work the type out by later context.
09:57:36 <x6d65> How would it work out that I want a MinHeap instead of, say, a MaxHeap though?
09:58:03 <x6d65> The operations are all the same.
09:58:24 <quicksilver> by a type signature somewhere else in your program
09:58:25 <quicksilver> typically.
09:58:51 <quicksilver> otherwise, well your program ends up being totally polymorphic in heap policy
09:58:57 <x6d65> Okay, but somewhere I'm going to have to say that I'm expecting a MinHeap.
09:58:58 <quicksilver> (And that's a good thing, right? ;)
09:59:11 <x6d65> Heh.
09:59:37 <igel> x6d65: i suggest you keep it as general as possible
09:59:49 <igel> and that's by using signatures just like in Data.Heap, e.g.
09:59:59 <x6d65> Yes, but my algorithm requires a MinHeap.
10:00:07 <igel> foo :: HeapPolicy p a => Heap p a -> ... -> ...
10:00:45 <igel> ok then just write MinHeap in the signatures
10:00:51 <wjt> idnar: i guess Â«iterate (\k -> "I ACCIDENTALLY " ++ k ++ " THE WHOLE INTERPRETER") "I ACCIDENTALLY THE WHOLE INTERPRETER"Â» is close :)
10:01:23 <x6d65> Okie doke.
10:01:38 <x6d65> Thanks for the help :)
10:01:46 <Husio> how to print list?
10:01:54 <igel> the cool thing about this is, that the type system makes sure you don't mix up min- and maxheaps =)
10:02:25 <Husio> oh, nevermid ;)
10:02:36 <igel> > show [1..4]
10:02:37 <lambdabot>   "[1,2,3,4]"
10:02:41 <mauke> > print [1]
10:02:41 <samphippen> <3 haskell
10:02:42 <lambdabot>   * Exception: "<IO ()>"
10:09:59 <peachi> If I do something like:   head [ x | x <- [1..10], x == 5 ]
10:10:20 <peachi> I assume because of lazy-evaluation that the whole of the list comprehension isn't calculated, is it?
10:10:28 <lilac> no, just the bit up to 5
10:10:34 <idnar> no, just the bit up to 1 :P
10:10:38 <idnar> oh wait
10:10:39 <idnar> misread
10:10:47 * idnar gets more coffee
10:10:49 <lilac> > head [ x | x <- 1:2:3:4:5:undefined, x == 5]
10:10:50 <lambdabot>   5
10:11:30 <peachi> so is it just as efficient as    head ( dropWhile (/= 5) [1..10] )
10:12:19 <peachi> someone told me that the first way was silly because it was creating the entire [1..10] list, whereas his way (the one using dropWhile) is better because it stops after 5 is found
10:12:28 <peachi> but I don't agree, based on what we said above
10:12:29 <peachi> right?
10:12:56 <lilac> right, whoever said that would be right in a strict language
10:13:02 <lilac> but not in a lazy language like haskell
10:13:09 <idnar> lilac: only a strict language with lazy list comprehensions
10:13:12 <idnar> or something
10:13:17 <lilac> actually
10:13:23 <peachi> so would you say the first way is nicer in haskell?
10:13:26 <lilac> yeah, they'd never be right; they're equivalent in both
10:13:31 <idnar> the first one would evaluate the whole list too, although the resulting list would be shorter
10:13:56 <lilac> idnar: good point :)
10:14:10 <idnar> peachi: well, you might consider using find
10:14:11 <lilac> peachi: personally i'd use find
10:14:17 <idnar> > find (== 5) [1..10]
10:14:18 <lambdabot>   Just 5
10:14:19 <idnar> > find (== 5) [9..10]
10:14:21 <lambdabot>   Nothing
10:14:28 <peachi> hmm
10:14:37 <idnar> > head . (dropWhile /= 5) $ [9..10]
10:14:38 <lambdabot>   Couldn't match expected type `a -> [a1]'
10:14:43 <idnar> er
10:14:46 <idnar> > head . (dropWhile (/= 5)) $ [9..10]
10:14:48 <lambdabot>   * Exception: Prelude.head: empty list
10:14:50 <peachi> when I type ":i find" into my hugs prompt it doesn't like it
10:14:51 <lilac> indeed, my preference would be to never use head at all
10:14:58 <idnar> peachi: you need to import Data.List
10:14:59 <peachi> is find in the prelude?
10:15:07 <mauke> @index find
10:15:08 <lambdabot> Data.List
10:15:15 <lilac> > let maybeHead = find (const True) in  (maybeHead [1,2,3], maybeHead [])
10:15:17 <lambdabot>   (Just 1,Nothing)
10:15:43 <peachi> hmm, I'm not allowed to use other libraries
10:15:50 <dons> ?users
10:15:50 <lambdabot> Maximum users seen in #haskell: 524, currently: 520 (99.2%), active: 19 (3.7%)
10:15:56 <idnar> > let maybeHead [] = Nothing; maybeHead (x:_) = Just x in (maybeHead [1,2,3], maybeHead [])
10:15:57 <lambdabot>   (Just 1,Nothing)
10:16:04 <idnar> I guess yours is shorter
10:16:11 <idnar> oh wait
10:16:19 <peachi> how can I find the source code for find?
10:16:22 <idnar> > let maybeHead = listToMaybe (maybeHead [1,2,3], maybeHead [])
10:16:23 <lambdabot>   <no location info>: parse error on input `;'
10:16:28 <idnar> > let maybeHead = listToMaybe in (maybeHead [1,2,3], maybeHead [])
10:16:29 <lambdabot>   (Just 1,Nothing)
10:16:31 <idnar> :)
10:16:35 <idnar> @src find
10:16:35 <lambdabot> find p          = listToMaybe . filter p
10:16:55 <idnar> I guess that doesn't help you, since listToMaybe isn't in the Prelude either
10:17:03 <mauke> @src listToMaybe
10:17:03 <lambdabot> listToMaybe []        =  Nothing
10:17:04 <lambdabot> listToMaybe (a:_)     =  Just a
10:17:31 <lilac> @index find
10:17:31 <lambdabot> Data.List
10:17:35 <lilac> @index listToMaybe
10:17:36 <lambdabot> Data.Maybe
10:17:45 <idnar> if you're stuck with the prelude, and you don't want to copy those definitions into your code, then I'd go with the head/dropWhile one, it reads a bit nicer (to me) than the list comprehension
10:17:53 <lilac> peachi: does 'other libraries' include standard libraries?
10:18:00 <Laney> How can I uninstall the ghc-6.8.3 pkg for osx that I got from haskell.org?
10:18:26 <Laney> I stupidly did port install darcs which is happily building its own ghc
10:18:29 <peachi> idnar, problem is I'm actually using it with tuples
10:18:29 <lilac> > case filter (==5) [1..10] of a:_ -> a
10:18:30 <lambdabot>   5
10:18:42 <idnar> peachi: how do you mean?
10:19:33 <peachi> so I have   lookupCh command pairs = head [ s | (c, s) <- pairs, c == command ]
10:19:43 <peachi> where pairs :: [ (Char, String) ]
10:19:46 <Gabby> Laney, can't just drag and drop it to bin like normal? (I've not installed it on my mac, just ssh to a server)
10:19:52 <idnar> peachi: oh, right; I guess I'd also go with the listcomp there
10:19:55 <peachi> so using dropWhile I have to make it
10:20:14 <Laney> Gabby: No, it doesn't install like that
10:20:28 <idnar> head . (dropWhile (\(c,s) -> c /= command)) $ pairs -- or something
10:20:34 <peachi> lookupCh command pairs = s where (c, s) = head ( dropWhile ( (/= command) . fst ) pairs )
10:20:36 <MarcWeber> rwbarton: Have you had success?
10:20:48 <idnar> oh, throw a snd into mine
10:20:51 <Gabby> Laney, :/
10:21:08 <idnar> so yeah, listcomp is definitely nicer there, IMO
10:21:14 <peachi> ok cool
10:21:16 <peachi> I agree :)
10:21:17 <Laney> a .pkg is more like a windows installer from what I gather
10:21:30 <lilac> @type lookup
10:21:31 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
10:21:35 <lilac> @index lookup
10:21:35 <lambdabot> Data.HashTable, Data.IntMap, Data.Map, Data.List, Prelude
10:21:45 <lilac> peachi: ^^ there you go
10:22:19 <lilac> lookupCh command pairs = fromJust $ lookup command pairs
10:22:19 <idnar> peachi: it's interesting to me; because of currying/partial application, sections, and Haskell's minimal function application syntax, I end up using list comprehensions far less often in Haskell than in Python
10:22:35 <idnar> peachi: but they are nice in more complex cases
10:22:54 <peachi> well I've only just started learning Haskell so can't really comment hehe
10:23:00 <peachi> all I can say is that it's really quite cool at the moment
10:23:06 <dons> idnar: there's more higher order functions for lists in haskell, too
10:23:10 <idnar> dons: yeah, that too
10:23:14 <idnar> "filter (== 5) foo" is pretty nice compared with "[x | x <- foo, x == y]"
10:23:34 <idnar> but "filter(lambda x: x == 5, foo)" isn't so great compared with "[x for x in foo if x == 5]"
10:24:05 <idnar> compared to? whatever
10:24:19 <peachi> idnar, how might I translate lookupCh command pairs = head [ s | (c, s) <- pairs, c == command ] into a call to filter?
10:24:41 <lilac> peachi: just use lookup
10:24:46 <lilac> it's in the Prelude
10:25:09 <peachi> lilac, this is for my programming labs, I'm not allowed to hehe
10:25:17 <idnar> peachi: it would be the same as the dropWhile example, just with "filter (\(c,s) -> c == command))" instead of "dropWhile (\(c,s) -> c /= command)"
10:25:23 <peachi> head ( filter ( \(c, s) -> c == command ) pairs ) ?
10:25:30 <peachi> ok cool
10:25:56 <peachi> would the use of filter be preferred over a list comp here?
10:26:13 <idnar> not in my opinion, as I mentioned earlier
10:26:14 <idnar> @pl \(c, s) -> c == command
10:26:14 <lambdabot> (command ==) . fst
10:30:40 <lilac> peachi: you're allowed filter but not lookup?
10:31:05 <peachi> lilac, I actually just tried using lookup but it won't work because of the types
10:31:09 <peachi> I have
10:31:27 <peachi> lookupCh :: Char -> [ (Char, String) ] -> String
10:31:38 <lilac> you'll either need to change lookupCh to return Maybe String or use fromJust like I did above
10:32:07 <peachi> ok, we haven't done Maybe stuff or fromJust yet so I'll stick with the way I'm doing it
10:32:10 <peachi> thanks anyway though :)
10:32:41 <Peaker> I dislike non-exhaustive pattern searchers like fromJust.. I think in a few cases I looked at, it was possible to refactor it so it doesn't happen
10:34:01 <lilac> Peaker: it's no better or worse than head in my opinion
10:34:18 <Deewiant> head is also to be disliked :-P
10:34:24 <Peaker> lilac: Yeah, I hope its possible to avoid head too :)
10:34:27 <lilac> indeed
10:35:03 <lilac> s/head/unsafeHead/g, s/fromJust/unsafeFromJust/g
10:35:20 <Peaker> or maybe unjust? :)
10:35:36 <twanvl_> head and fromJust are not unsafe
10:35:41 <twanvl_> IMO
11:02:21 <oscar> hello
11:02:39 <oscar> can someone help. its a quick question
11:03:11 <Botje> yes, someone can help
11:03:12 <Botje> NEXT!
11:03:21 <Saizan> oscar: feel free to ask
11:03:24 <Botje> (what is your quick question? :)
11:03:30 <oscar> thanks
11:03:39 <oscar> i have a string its
11:04:18 <oscar> if %CONFID% == USAGE RESTRICT goto ARP
11:04:32 <proq> we put the bald in balderdash
11:05:00 <oscar> THE THE USAGE RESTRICT DOESNT DISPLAY
11:05:18 <oscar> because the two words are seperated
11:05:35 <mauke> what is your quick question?
11:05:56 <oscar>  if %CONFID% == USAGE RESTRICT goto ARP
11:06:09 <oscar> THE THE USAGE RESTRICT DOESNT DISPLAY
11:06:22 <int-e> where's the Haskell?
11:06:36 <oscar> on the USAGE SHOWS AND NOT THE RESTRICT
11:07:13 <mauke> what is your quick question?
11:07:30 <oscar> if %CONFID% == USAGE RESTRICT goto ARP
11:07:32 <thorkilnaur_> oscar, This is .bat, right? Try using "%CONFID%" == "USAGE RESTRICT", I'm not sure, it may help. But I guess that this is not the right channel for .bat questions
11:07:44 <mauke> oscar: HELLO? IS THIS THING ON?
11:08:27 <vixey> uh...
11:08:28 <vixey> hi
11:08:42 <Zao> oscar: Your question has nothing to do with Haskell.
11:08:45 <int-e> @quote dada
11:08:45 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
11:09:01 <vixey> @quote
11:09:01 <lambdabot> jlouis says: Q: When does one know he has programmed too much Haskell? A: When he uses == and /= in everyday IRC chat or when he tries to fix a relationship by passing himself as a continuation
11:09:10 <vixey> @quote
11:09:11 <lambdabot> lambdabot says: I know everything hasn't been quite right with me, but I can assure you now, very confidentaly, that it's going to be all right again.  I feel much better now.  I really do.
11:09:13 <thorkilnaur_> @quote .bat
11:09:13 <lambdabot> Philippa says:  in this case using the FFI sounds rather like masturbating with a running chainsaw
11:09:23 <vixey> hehe
11:09:27 <thorkilnaur_> Hm ...
11:09:47 <mauke> preflex: quote
11:09:48 <preflex>  <solrize> this would never happen in haskell: i sent in a search query to a certain python program, but left the query field empty, expecting to get back an error message.  instead it found a bunch of books written by the diet doctor Gary Null.
11:10:14 <Cale> ahaha
11:10:18 <idnar> bwahaha
11:10:21 <thorkilnaur_> Perfect ...
11:10:24 <Cale> fail fail
11:10:28 <phoenix> Hi guys, any gtk2hs user here? :)
11:10:31 <dolio> @quote qwe1234
11:10:32 <lambdabot> qwe1234 says: every half-assed dynamically-typed, ass-slow scripting language is Lisp but a bit different
11:11:24 <phoenix> I have a small question regarding the use of onKeyPress
11:12:33 <ToRA|MSR> phoenix: shoot, but no promises
11:12:36 <int-e> sigh, what's so hard about just asking a question?
11:13:06 <phoenix> int-e: trying to be polite :)
11:13:08 <int-e> It's not like people sit on the channel all day because they want to say "please ask your question" all the time.
11:13:22 <Gabby> Anyone know if lambdabot can be set to ignore cetain users?
11:14:14 <Cale> Gabby: I'm not sure if it has an existing mechanism for this
11:14:16 <phoenix> ToRA|MSR: my problem is that onKeyPress as I have written the code, works a piece of code until the key is release (repeatedly)
11:14:20 <int-e> phoenix: I know, but it's the wrong medium for that. On IRC, your question will not bother anybody who decides not to read it. And it's sort of persistent - people can still read it when they get back after a couple of minutes. You won't be interrupting anybody.
11:14:35 <phoenix> int-e: won't happen again
11:15:10 <phoenix> ToRA|MSR: how possible is it to make it stop doing so... that is, make the action work once and then wait until another keydown sort to speak
11:15:57 <Gabby> Cale, I was afraid of that, thanks.
11:16:08 <ToRA|MSR> phoenix: mmm
11:16:13 <Cale> Gabby: why?
11:16:33 <Saizan> phoenix: tried returning False from the handler?
11:17:14 <Saizan> phoenix: just a wild guess
11:17:51 <ToRA|MSR> isn't the True/False whether the handler propogates down to other handlers?
11:17:53 <phoenix> Saizan: its actually True what you are refering to but once I set it to true its lost... i mean its like 1 shot and that's it
11:18:30 <Saizan> ah, ok
11:18:30 <Gabby> Cale, I've got him in a couple of chans on another network, for general playing around and the fun fetures he provies. I've also got another bot that does rss feeds etc, so everytime if displays a feed lambdabot displays the title.
11:18:54 <Cale> aha
11:18:56 <int-e> phoenix: If I understand the question correctly, I don't think you can. It's X11 (or possibly Windows) that generates multiple events if you press a key and hold it.
11:19:10 <rwbarton> phoenix: does it look like you're running into autorepeat?
11:19:21 <rwbarton> phoenix: is there a separate onKeyDown event?
11:19:29 <Gabby> Cale, nothing major, so was just curious if I'd missed soemthing.
11:19:31 <Cale> Gabby: well, the username is certainly made available to the seen plugin, so you could hack in a check there
11:19:44 * Gabby nods
11:19:56 <int-e> phoenix: you can set a flag in the event and wait for the corresponding onKeyRelease(?) event to reset the flag again
11:20:10 <Gabby> I'll have a poke around :)
11:20:14 <phoenix> int-e: yes that's what I was thinking off... was just asking cause it seems a bit messy that way
11:20:33 <phoenix> rwbarton: there is an onKeyDown event but its something totally different apparently
11:20:39 <int-e> phoenix: but that's also unreliable - it's possible to press a key, then change keyboard focus, and release it.
11:23:24 <phoenix> is it possible that no one met this problem before?
11:23:35 <ToRA|MSR> phoenix: two things.  1, if you intend to swallow the key press, make sure the handler returns true.  if it's a key press you're not interested in, return false.  If you want to check if it was an up / down event, look at the eventRelease flag in the event
11:23:39 * EmielRegis http://www.motifake.com/motivational_posters/cbaa1f75c.jpg
11:24:02 <ToRA|MSR> though as int-e said, you have to check for focus lost cases in your widget too
11:24:10 <int-e> phoenix: I think it only matters for games, and there waiting for the release event is probably good enough.
11:24:23 <phoenix> int-e: take a guess at what I am working on? :P
11:24:36 <int-e> phoenix: I did ;)
11:25:17 <phoenix> ToRA|MSR: I'll try it out :)
11:25:36 <phoenix> thanks guys I'll let you know how it went... however... an onKeyDown/onKeyUp event would be awesome
11:25:51 <ToRA|MSR> phoenix: you can easily make wrappers
11:26:05 <rwbarton> in xev, I see an alternating sequence of KeyPress and KeyRelease when I hold down a key
11:26:30 <phoenix> ToRA|MSR: yeah but that might be a bit advanced for me :)
11:26:36 <ToRA|MSR> onKeyUp evt f | eventRelease evt = f (evt) ; | otherwise = return False
11:26:57 <ToRA|MSR> okKeyDown evt f | not (eventRelease evt) = f (evt) ; | otherwise = return False
11:27:00 <ToRA|MSR> or something like that ;0
11:27:01 <ToRA|MSR> ;)
11:27:19 <phoenix> rwbarton: is it supposed to work that way?
11:27:25 <int-e> rwbarton: nasty, what platform is that?
11:27:44 <phoenix> btw I am working on a windows platform right now
11:28:09 <mmorrow> int-e, rwbarton: me too (on linux)
11:28:14 <ToRA|MSR> the evts above assume it /is/ a Key event btw
11:28:24 <int-e> Oh, but I do see a KeyRelease event when the keyboard focus is changed. Interesting.
11:28:48 <rwbarton> int-e: debian testing... nothing weird AFAIK
11:29:25 <phoenix> I also tried using afterKeyPress but its not working as I hoped...
11:29:38 <int-e> rwbarton: never mind, I see the same. :(
11:29:48 <ToRA|MSR> phoenix: the before/on/after refers to when in the event loop the event happens
11:29:55 <ToRA|MSR> afaiu
11:30:20 <phoenix> so the million dollar question from a noob like me is: is the thing bugged?
11:32:52 <int-e> hum, so I guess it comes down to xlib, playing with XAutoRepeatOff and XAutoRepeatOn? Eek.
11:33:40 <Cale> Yeah, if you have keyboard auto repeat in X, programs get many keypresses when you hold a key down.
11:33:47 <ToRA|MSR> phoenix: mmm, so according to some googling, gtk2 represents key repeats by giving you: down..down..down..down..up
11:38:17 <phoenix> ToRA|MSR: I'll try your approach of writing wrappers thanks for the input guys, much appreciated
11:38:24 <int-e> ToRA|MSR: hmm, yes it does. interesting.
11:44:09 <mr_H> hello
11:44:14 <mr_H> i have a list of strings, that i want to write to a file, how do i do it elegantly ?
11:45:12 <Saizan> do you want each one on a separate line?
11:45:29 <mr_H> yes, if possible, to choose a "separator" string between them
11:45:41 <BMeph> mr_H: Do you want each one in a separate file? :)
11:45:56 <Saizan> ?type intercalate
11:45:57 <lambdabot> forall a. [a] -> [[a]] -> [a]
11:45:59 <mr_H> BMeph: no, all of them in the same file
11:46:01 <Saizan> ?type writeFile
11:46:02 <lambdabot> FilePath -> String -> IO ()
11:46:23 <Saizan> > intercalate "separator" ["foo","bar,"baz"]
11:46:24 <lambdabot>   <no location info>:
11:46:24 <lambdabot>      lexical error in string/character literal at chara...
11:46:34 <Saizan> > intercalate "separator" ["foo","bar","baz"]
11:46:34 <mr_H> ahhh
11:46:35 <lambdabot>   "fooseparatorbarseparatorbaz"
11:46:38 <mr_H> nice nice :D
11:46:50 <EvilTerran> > unlines ["foo","bar,"baz"]
11:46:51 <lambdabot>   <no location info>:
11:46:51 <lambdabot>      lexical error in string/character literal at chara...
11:46:54 <EvilTerran> ...
11:47:00 <EvilTerran> , unlines ["foo","bar,"baz"]
11:47:02 <mr_H> can i make "\nseparator\n" and expect haskell to put newline chars in there ?
11:47:04 <lunabot>  luna: lexical error in string/character literal at end of input
11:47:11 <lilac> s/bar/bar"/
11:47:14 <mr_H> :D
11:47:16 <Saizan> > unlines ["foo","bar","baz"]
11:47:18 <lambdabot>   "foo\nbar\nbaz\n"
11:47:18 <mr_H> sweeeettt stufff
11:47:18 <EvilTerran> > unlines ["foo","bar","baz"] -- dammit, copy-and-pasted the wrong one
11:47:19 <lambdabot>   "foo\nbar\nbaz\n"
11:47:20 <byorgey> mr_H: sure
11:47:34 <EvilTerran> mr_H, we've got the usual \t and so on as well
11:47:47 <byorgey> , unlines . intersperse "======" $ ["foo", "bar", "baz"]   -- you could do this too
11:47:49 <lunabot>  luna: parse error (possibly incorrect indentation)
11:47:53 <byorgey> > unlines . intersperse "======" $ ["foo", "bar", "baz"]   -- you could do this too
11:47:53 <mr_H> allright
11:47:54 <lambdabot>   "foo\n======\nbar\n======\nbaz\n"
11:48:30 <byorgey> mr_H: then once you get the string you want, just use  writeFile  to write it to a file
11:48:32 <EvilTerran> http://haskell.org/onlinereport/lexemes.html#lexemes-char
11:48:34 <lambdabot> Title: Haskell 98 Lexical Structure
11:48:42 <byorgey> or you can open the file manually and then use hPutStr.
11:48:53 <EvilTerran> mr_H, ^ that describes the string syntax in rigorous detail
11:49:01 <BMeph> > unlines . intersperse "separator" $ ["foo","bar","baz"]
11:49:02 <lambdabot>   "foo\nseparator\nbar\nseparator\nbaz\n"
11:49:06 <mr_H> nice
11:49:39 <byorgey> mr_H: note, in general the idiom is to process whatever data you have into one giant string which represents exactly what you want in the file, and then write that to the file.
11:49:45 <mr_H> intercalate is not available
11:49:46 <byorgey> as opposed to doing a bunch of writes.
11:49:58 <byorgey> mr_H: what version of ghc do you have?
11:50:03 <mr_H> yes, i see
11:50:05 <byorgey> ISTR intercalate was new in 6.8.
11:50:18 <byorgey> but you can just write it yourself:
11:50:21 <byorgey> @src intercalate
11:50:21 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
11:50:25 <EvilTerran> also, it's in Data.List, not the prelude, iirc
11:50:28 <mr_H> 6.8.3
11:50:37 <byorgey> oh, right, just 'import Data.List'
11:50:39 <EvilTerran> ?hoogle intercalate
11:50:40 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
11:50:40 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
11:50:40 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
11:50:42 <mr_H> ahh nice
11:50:53 <EvilTerran> import Data.List (intercalate) will only import that function
11:52:45 <mr_H> thanks :D the code is now beautifull
11:52:57 <mr_H> off to programming, bye ppl
11:59:15 <lispy> > " I like pizza! " `intercalate` ["So tell me what you want.", "What you really, really want.", "Spice girls attack!"]
11:59:17 <lambdabot>   "So tell me what you want. I like pizza! What you really, really want. I li...
11:59:38 <vixey> that FPH stuff is really cool
11:59:46 <lispy> FPH?
11:59:53 <lispy> functional programming hacks?
12:00:02 <vixey> are they actually adding this to GHC?
12:01:19 <sjanssen> vixey: do you mean DPH?
12:01:58 <Saizan> http://www.icfpconference.org/icfp2008/accepted/60.html
12:01:59 <lambdabot> Title: ICFP 2008 - FPH: First-class Polymorphism for Haskell
12:02:00 <vixey> http://www.cis.upenn.edu/~dimitriv/fph/
12:05:41 <byorgey> vixey: I think so.
12:06:10 <byorgey> Dimitrios has a postdoc at MSR cambridge now, I assume he is still working on it
12:07:12 <int-e> In case anybody cares about key events in Gtk+ - Gdk does two things: 1) if supported, use the XKEYBOARD extension to use "detectable autorepeat" which drops the artificial release events on the server side. 2) if this is not possible, it drops release events that are followed by a press event for the same key, with the same timestamp.
12:08:01 <phoenix> guys if I am working in the IO () monad, and I call a function which has type IO (Whatever Here)... er how can i get it work? without getting a Couldn't match expected type `()'against inferred type `Whatever Here' ... sort of ignore the output?
12:08:34 <byorgey> phoenix: myFunction >> return ()
12:08:45 <byorgey> phoenix: or if you have a do-block, just put 'return ()' on the last line
12:09:52 <phoenix> byorgey: I have myFunction >> return True where myFunction has type: IO (Whatever Here)
12:11:24 <phoenix> how can "convert" myFunction to have type IO ()? sort of ignore the output?
12:12:34 <int-e> @type ?myFunction >> return ()
12:12:34 <lambdabot> forall (m :: * -> *) a. (Monad m, ?myFunction::m a) => m ()
12:13:50 <phoenix> int-e: thanks but I don't understand that
12:14:13 <int-e> phoenix: I don't understand your question. What type does myFunction have?
12:14:24 <dancor> phoenix: if f has type IO a then f >> return () has type IO ()
12:14:40 <phoenix> let me hpaste my code
12:15:53 <int-e> myFunction >> return True  will have type  IO Bool  if  myFunction  has type  IO a  (regardless of a)
12:16:12 <phoenix> http://hpaste.org/11548
12:17:11 <int-e> ok, so your problem is  (setupCommandKeyDown chrString window drawArea move gameVar)
12:17:18 <int-e> replace that by  (setupCommandKeyDown chrString window drawArea move gameVar >> return ())
12:17:36 <int-e> or change  setupCommandKeyDown  so that it ends in a   return ()
12:18:24 <int-e> which is probably what you wanted
12:18:46 <phoenix> no i need the return True or False
12:18:55 <phoenix> but your first answer fixed it
12:19:04 <phoenix> what exactly did I do wrong?
12:19:16 <rwbarton> @type when
12:19:17 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
12:19:35 <int-e> phoenix: this is what I meant in the second answer, http://hpaste.org/11548#a1
12:20:11 <phoenix> ah!
12:20:13 <phoenix> ok
12:20:31 <EvilTerran> that makes the "return True" a little pointless
12:20:50 <EvilTerran> the problem's the parameter to "when", anyway
12:20:52 <EvilTerran> ?src when
12:20:52 <lambdabot> when p s = if p then s else return ()
12:21:30 <int-e> EvilTerran: the return True is for the event handler
12:21:47 <int-e> oh.
12:21:48 <EvilTerran> ah, i see, one of those functions is using the other as a parameter to "when"
12:22:00 <int-e> you need to return (key == chrString)  though.
12:22:11 <int-e> It's no good to eat all the other key events, too. :)
12:22:28 <EvilTerran> i suspect replacing the "when" with an if/then/else may be more appropriate here
12:22:54 <int-e> agreed
12:24:50 <phoenix> thanks guys
12:31:04 <vixey> what I am supposed to be doing :?
12:33:04 <Elly> vixey: saving the world!
12:33:25 <mauke> save the cheerleader
12:34:05 <fee> reading Hutton?
12:36:23 <vixey> fee what
12:36:51 <fee> Programming in Haskell (G. Hutton)
12:37:12 <vixey> oh I don't have it
12:37:27 <fee> Its a good book.
12:39:29 <mm_freak> i was bored
12:39:31 <mm_freak> http://rafb.net/p/04chID94.html
12:39:33 <mm_freak> =)
12:39:36 <lambdabot> Title: Nopaste - Next generation crazy factorial function.
12:42:17 <olsner> mm_freak: nice :)
12:43:03 <mm_freak> unfortunately, you need a GCC extension to compile itâ¦  closures are quite alien in C99 =)
12:43:06 <idnar> :i <$>
12:43:15 <Beelsebob> mm_freak: really?
12:43:23 <Beelsebob> I thought you could use blocks in C99 to get closures?
12:43:39 <vixey> You can't really close a scope and not have GC
12:43:44 <Peaker> Not real closures, you can't return them
12:43:47 <idnar> oh, infixl not infixr
12:43:51 <idnar> silly ($)
12:43:55 <Beelsebob> Peaker: can you not? lame :(
12:44:05 <Peaker> Beelsebob: no GC, how would it work?
12:44:14 <Peaker> Beelsebob: it lives on the stack
12:44:15 <Beelsebob> Peaker: like... magic?
12:44:16 <Beelsebob> :D
12:44:43 <vixey> "in addition to malloc/free, we now have malloc_closure/free_closure"
12:45:05 <int-e> This is nice though, thanks to CPS we don't need GC, we'll just blow the stack :)
12:45:07 <mm_freak> Peaker: i know, and the GCC extension doesn't change that, so i used continuations =)
12:45:46 <int-e> and allocation is fast - it's just decrementing the stack pointer. where have we seen that before ... hmm :)
12:47:11 <mm_freak> in fact i exaggerated a bit with CPS, but i wanted to keep all functions (other than main) void-typed =)
12:47:53 <mm_freak> interestingly, if you break the continuation chain at some point, the program segfaultsâ¦  that may be a GCC bug
12:51:06 <idnar> @type (<$)
12:51:07 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
12:51:15 <idnar> @type ($>)
12:51:16 <lambdabot> Not in scope: `$>'
12:51:18 <idnar> aww
12:53:52 <CAP1360> [Cale] finally i did the exercise using lists :P
12:54:09 <CAP1360> ops
12:54:17 <KAI_Tite> data Conjunto = C [Int]
12:54:17 <KAI_Tite> maximo :: Conjunto -> Int
12:54:17 <KAI_Tite> maximo (C (x:xs))
12:54:17 <KAI_Tite> | xs == [] = x
12:54:17 <KAI_Tite> | x > maximo (C xs) = x
12:54:18 <KAI_Tite> | otherwise = maximo (C xs)
12:54:42 <vixey> yuck
12:55:18 <mauke> wow, is that O(n^2)?
12:55:34 <vixey> it's O(wful)
12:55:44 <opqdonut> :D
12:56:44 <olsner> basically, a foldr-version of maximum?
12:57:37 <olsner> KAI_Tite: maximo (C xs) = maximum xs
12:57:46 <BrokenClockwork1> Is there a site, which lists some or many compiling error messages with example solutions?
12:58:20 <idnar> @src maximum
12:58:21 <lambdabot> maximum [] = undefined
12:58:21 <lambdabot> maximum xs = foldl1 max xs
12:58:39 <BMeph> BrokenClockwork1: Yes - hpaste. ;)
12:58:40 <geezusfreeek> BrokenClockwork1, hmm, not that i know of, but that is a good idea
12:58:43 <idnar> > foldl1 max []
12:58:44 <lambdabot>   * Exception: Prelude.foldl1: empty list
12:58:48 <idnar> > maximum []
12:58:50 <lambdabot>   * Exception: Prelude.maximum: empty list
12:58:52 <EvilTerran> BrokenClockwork1, no, but, if you tell us the first line of the error, we may be able to suggest a solution
12:59:14 <Peaker> is @src maximum lying?
12:59:19 <EvilTerran> BrokenClockwork1, or, indeed, you could put the error and a snippet of relevant code on hpaste.org
12:59:28 <mauke> Peaker: yes
12:59:29 <EvilTerran> Peaker, no, as all _|_s are equivalent :P
12:59:49 <BrokenClockwork1> No instance for (Integral [t]) arising from a use of 'convert' at <interactuve>:1:9-19
12:59:49 <Peaker> where does @src take its sources from?
12:59:51 <RayNbow> EvilTerran: but some more than others?
13:00:02 <EvilTerran> Peaker, it's own weird little database
13:00:06 <vixey> some .gzip file I think
13:00:10 <EvilTerran> compiled from various sources
13:00:16 <vixey> on whatever lambdabot is hosted on
13:00:20 <mauke> BrokenClockwork1: that means you're using a list as if it were a number
13:00:24 <EvilTerran> BrokenClockwork1, ah, that looks suspiciously like you're trying to use a list as a number
13:00:48 <BrokenClockwork1> heh, okay let me check it :)
13:02:21 <RayNbow> http://www.reddit.com/r/haskell/comments/79shy/haskell_solution_to_the_farmer_problem/c062boi <-- roconnor, are you nuts? :p
13:02:23 <lambdabot> Title: roconnor comments on Haskell Solution To The Farmer Problem, http://tinyurl.com/5p5vcf
13:04:00 <opqdonut> :D
13:04:15 <opqdonut> argh
13:04:22 <opqdonut> why does that solution use chars
13:04:49 <EvilTerran> data Bank = W | E deriving (everything) :P
13:04:51 <olsner> hmm, actually, that sounds like the kind of problem with tractable type system solutions (insofar as it's logic-programming-like)
13:05:02 <opqdonut> ah, it's not even meant to be elegant or anything
13:05:08 <opqdonut> just somebody learning the ropes
13:07:03 * EvilTerran notes that it might not be as hard as jfredett suggests in http://www.reddit.com/r/haskell/comments/79shy
13:07:04 <lambdabot> Title: Haskell Solution To The Farmer Problem : haskell
13:07:16 <BrokenClockwork1> hmmm... are parameters global to the source code?
13:07:26 <EvilTerran> er, wrong link, i meant to go for the specific reply, but never mind...
13:08:25 <RayNbow> opqdonut: for a beginning Haskeller, it's pretty okayish
13:08:29 <EvilTerran> ... while i agree it looks like a satisfiability problem, to me it looks like 2-CNF satisfiability in particular, which *is* tractable
13:08:44 <RayNbow> except the blog software screwed up the indenting
13:09:29 <RayNbow`> hmm
13:09:31 * RayNbow` opens log
13:11:55 <RayNbow`> odd, my last message was received by the server, but I did not receive EvilTerran's message...
13:12:06 <rwbarton> Someone should write a 5-line type-level program and put it in a comment
13:12:14 <vixey> 5 line??
13:12:54 <rwbarton> Well, slight exaggeration
13:13:50 <BrokenClockwork1> I didn't find the problem: http://hpaste.org/11550
13:13:58 <BrokenClockwork1> "No instance for (Integral [t]) arising from a use of 'convert' at <interactuve>:1:9-19"
13:14:19 <rwbarton> It does look like a good problem for Prolog/type classes though
13:14:36 <vixey> yeah Prolog would be fine ...
13:14:53 <BrokenClockwork1> Prolog?
13:15:56 <BrokenClockwork1> well I will read into Typeclasses ..
13:16:24 <rwbarton> BrokenClockwork1: Sorry, that wasn't supposed to be an answer to you :)
13:16:45 <BrokenClockwork1> oh lol :)
13:17:37 <mauke> BrokenClockwork1: the problem is: what is the type of x (in convert)?
13:17:54 <BrokenClockwork1> actually a list
13:17:57 <rwbarton> BrokenClockwork1: from the looks of the error the problem is when you call convert from ghci
13:18:17 <BrokenClockwork1> x is a list of numbers
13:18:42 <mauke> BrokenClockwork1: then the call to remaindiv is wrong
13:18:50 <mauke> because remaindiv expects a number, not a list
13:19:04 <BrokenClockwork1> oh I see it now
13:19:08 <BrokenClockwork1> because I' using div and mod
13:19:21 <BrokenClockwork1> gahhh.... stuipid me, thanks
13:19:40 <rwbarton> BrokenClockwork1: I strongly suggest writing type annotations for your top-level values to make it easier to pin down where errors are happening :)
13:19:59 <BrokenClockwork1> type annoations... mhh
13:20:11 <BrokenClockwork1> comments? what's the syntax symbol for that?
13:20:17 <mauke> BrokenClockwork1: the second line of 'dec' can be written as: dec (d : ds) b = d * b^(length ds) + dec ds b
13:20:29 <Peaker> BrokenClockwork1: comments are -- to end of line or {- to -}
13:20:41 <mauke> type annotations are written with ::
13:20:51 <Cale> BrokenClockwork1: Type annotations look like  foo :: String -> Integer
13:20:52 <BrokenClockwork1> oh these..
13:20:58 <BrokenClockwork1> ok
13:21:54 <BrokenClockwork1> oh nice, thanks mauke
13:22:18 <Husio> what's wrong with that code: http://paste.pocoo.org/show/89346/ ?
13:23:01 <Botje> you're mixing pure and monadic code
13:23:02 <mauke> putStr returns IO (), your qsort returns [a]
13:23:05 <mauke> the types don't match
13:23:11 <mauke> (because IO is not a list)
13:23:11 <Botje> Husio: import Debug.Trace instead
13:23:30 <Botje> then you can do qsort (p:xs) = trace (show p) $ qsort lesser ++ .....
13:24:00 <ttt--> hi, is there a type for 2d arrays (matrix or something) ?
13:24:02 <Husio> it's too advanced for me, I've just started to learning haskell ;)
13:24:11 <Botje> ttt--: like Array? :)
13:24:12 <rwbarton> ttt--: Yes, Array :)
13:24:25 <Botje> Husio: stick to trace then, if you want to have debugging statements
13:25:16 <ttt--> oh, how did i miss that
13:25:18 <ttt--> thanks
13:25:34 <Husio> ehh, IO is hard in haskell
13:25:49 <mauke> not really
13:26:06 <mauke> it's easier than memory allocation in C
13:26:58 <vixey> is this actually possible to do in the type sytem
13:27:01 <Samy> Husio, once you understand monads, it's very nice.
13:27:13 <mauke> monads just confuse the issue
13:27:27 <rwbarton> Once you get used to the idea that you should be keeping track of what IO you do, it's very nice :)
13:27:31 <Gabby> memory allocation is easy, just randomly add malloc till it starts vagually working
13:27:34 <mauke> my advice is: ignore monads, just learn how IO works
13:27:35 <Samy> I guess that's another way to look at it mauke :p
13:27:48 <Botje> i'm with mauke on that one
13:27:55 <Botje> I wasted too much time reading monad tutorials
13:28:13 <Botje> whereas i "got" monads by simply trying to use them and working out the type errors
13:28:55 <Cale> But you don't even need to get monads in order to understand IO
13:29:05 <Botje> indeed
13:29:06 <Cale> The fact that IO is a monad is actually mostly irrelevant.
13:29:15 <Botje> which is why maukes advice is very good :)
13:29:41 <Peaker> Its probably easier to understand a specific case first (IO) and then understand how that is generalized, than the other way around
13:29:48 <opqdonut> yeah
13:30:03 <Botje> learn to do IO first
13:30:10 <Botje> then start rewriting list comprehensions with the list monad
13:30:15 <Botje> and then move on to maybe monad
13:30:24 <Botje> after that the rest is a snap :)
13:30:40 <rwbarton> Some day I would like to write a Haskell tutorial that tries to blow the reader's mind as often as possible :P
13:30:56 <rwbarton> maybe I'd start with IO, and then do Maybe, and then say "look, these are the same thing"
13:31:10 <mauke> don't forget the naked reader
13:31:25 <Cale> IO is probably the most complicated monad.
13:31:29 <Botje> nudists have a right to read!
13:31:32 <Botje> Cale: far from it!
13:31:33 <mauke> (->) e
13:31:36 <vixey> more than Cont ?
13:31:36 <Botje> at least from the users side
13:31:38 <rwbarton> I think there are too many tutorials that lull the reader into a false sense of "this is just like Python" and then when the interesting stuff starts to happen, it's too late.
13:31:46 <Cale> vixey: Cont is simple by comparison.
13:31:54 <Cale> Think of all the stuff which IO has!
13:32:11 <mauke> but the stuff is not part of its monaditude
13:32:45 <Cale> It has exceptions, input and output effects, arbitrary amounts of mutable references and arrays, concurrency...
13:32:54 <Peaker> RealWorld -> (a, RealWorld) is not hard to grasp, nor is how return and (>>=) are defined in light of that
13:33:17 <vixey> I don't think about IO like that
13:33:18 <Cale> RealWorld -> (a,RealWorld) also breaks down pretty badly in the face of forkIO
13:33:21 <roconnor> RayNbow: http://intoverflow.wordpress.com/2007/09/14/programming-in-the-haskell-type-system/
13:33:23 <lambdabot> Title: Programming in the Haskell Type System Â« Integer Overflow, http://tinyurl.com/6zc9qm
13:33:27 <Cale> (and I don't think about IO like that either)
13:34:03 <mauke> Peaker: RealWorld -> (a, RealWorld) is obviously bogus
13:34:03 <BrokenClockwork1> is there a command, which adds numbers of a list to an integer? For instance [1,2,0] -> 120
13:34:13 <Peaker> mauke: because of threads?
13:34:29 <mauke> Peaker: no, because my computer doesn't suck the whole universe into a haskell program, etc
13:34:35 <BONUS_> BrokenClockwork1: i usually use read . concatMap show
13:34:36 <mauke> it's just not How Things Work
13:34:37 <Botje> > foldl (\x y -> x*10+y) 0 [1,2,0]
13:34:38 <lambdabot>   120
13:34:40 <Peaker> mauke: sure it does, conceptually :)
13:34:48 <BONUS_> but Botje's is better yeah better yeah
13:34:59 <RayNbow> roconnor: ah, I haven't read that yet...
13:35:16 <BONUS_> @pl \x y -> x*10+y
13:35:17 <lambdabot> (+) . (10 *)
13:35:27 <RayNbow> I did read some paper about fundeps in which some computations at the type level were performed
13:36:21 <Cale> Peaker: You could never ever implement it that way, regardless of what information you decided to store in RealWorld.
13:36:43 <Peaker> Cale: True, but its a conceptual model that works until you don't need it ;)
13:36:51 <Peaker> Cale: (By the time you use forkIO, you probably don't need it)
13:37:09 <Cale> I'd argue that it's not as useful a conceptual model as most others.
13:37:12 <vixey> ? ?
13:37:12 * RayNbow can't find which paper he read though... (I should organize all these pdf files instead of having them randomly scattered throughout my whole hard drive)
13:37:30 <vixey> if it's a conceptual model then you'd want to actually be a model of the things it's modelling ...
13:37:39 <vixey> so not handling forkIO is sort a major problem
13:37:44 <vixey> sort of a*
13:38:37 <Peaker> what if I say that forkIO just has the various threads modify the RealWorld between its being returned from one action and given to the next? :)
13:39:15 <BMeph> rwbarton: Here's a fun way to mind-blow someone - explain Mu. ;)
13:39:21 <Cale> Peaker: that violates the definition of bind.
13:39:42 <Peaker> Cale: yeah, in that case you need a more magical (>>=)
13:39:46 <vixey> you must add in some tieing the knot
13:39:51 <mauke> Peaker: RealWorld is immutable
13:39:56 <vixey> find a really complex example to confuse better
13:40:23 <Peaker> mauke: yeah, I basically meant that >>= wouldn't be the State bind, but something that pipes ReadWorld through actions of others threads before giving it to the next action
13:40:55 <EvilTerran> context-switching on >>=s?
13:40:57 <Samy> cool paper
13:41:00 <Peaker> but its probably better to just use a different simpler model then ;)
13:41:04 <Peaker> EvilTerran: yeah ;)
13:41:20 <EvilTerran> eeeeevil
13:41:41 <Cale> Peaker: A much better description of how IO might be implemented is just as a term algebra -- that is, you just have some datastructure which represents stuff to be done. Bind is a constructor.
13:42:13 <mauke> free IO!
13:42:16 <Cale> The runtime system subsequently is responsible for picking these descriptions apart and carrying them out.
13:42:29 <Peaker> Cale: yeap
13:42:33 <EvilTerran> that would work
13:42:45 <EvilTerran> you could even build something that looked kinda like the IO monad but worked that way
13:42:53 <Cale> right.
13:43:08 <mauke> you want GADTs for that
13:43:14 <Cale> yeah
13:43:24 <Cale> But it's still quite complicated. FFI makes it even more complicated, since we'd want an open GADT.
13:44:06 <Cale> (in essence, the type representing IO depends on what FFI import declarations there are)
13:46:53 <vixey> must it be an open GADT?
13:47:11 <vixey> I mean you could try to put the C types into the GADT and then a string representing the name
13:47:19 <Cale> hmm...
13:49:01 <vixey> although typeclass might be better
13:49:10 <vixey> sin :: Double -> Double
13:49:17 <vixey> sin = ffi "math.h" "sin"
13:50:22 <olsner> > log 2.71
13:50:23 <lambdabot>   0.9969486348916096
13:50:24 <mauke> runtime name resolution
13:50:30 <J-roen> Hi. Does the Prelude contain a function which checks if an element is in an array?
13:50:38 <J-roen> Sorry. Array should be list.
13:50:42 <olsner> heh, ln not log10 then... no wonder I'm getting the wrong results...
13:51:01 <int-e> @type elem
13:51:02 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
13:51:09 <mauke> @hoogle [a] -> a -> Bool
13:51:10 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
13:51:10 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
13:51:10 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
13:51:12 <int-e> > 4 `elem` [1,3..100]
13:51:13 <lambdabot>   False
13:51:17 <igel> @check \x -> x || False == x
13:51:18 <lambdabot>   "OK, passed 500 tests."
13:51:29 <J-roen> Thanks int-e.
13:52:45 <Samy> :t mappend
13:52:46 <lambdabot> forall a. (Monoid a) => a -> a -> a
13:53:23 <Beelsebob> @check \x y -> x `mappend` y == x
13:53:24 <lambdabot>   "OK, passed 500 tests."
13:53:29 <Beelsebob> yep, still doesn't work right
13:53:30 <Beelsebob> :D
13:53:38 <Samy> heh
13:53:42 <Beelsebob> stupid thing chosing the () type
13:54:00 <mauke> @check (==)
13:54:01 <lambdabot>   "OK, passed 500 tests."
13:54:07 <Beelsebob> hehe
13:55:43 <Samy> @check (\x -> (==) x (.))
13:55:44 <lambdabot>       Overlapping instances for Show ((b -> c) -> (a -> b) -> a -> c)
13:55:44 <lambdabot>        ...
13:59:22 <jonathanturner> is there a better way of writing "sum[1..10000000]"?  Doing that seems to give me a stack overflow in ghci
13:59:39 <vixey> jonathanturner: 10000000*(10000000+1)/2
14:00:01 <pcc1> in what circumstances would I encounter an "Edge Exception" while building an inductive graph? not very clear from the code
14:00:28 <mauke> vixey: `div`
14:00:50 <jonathanturner> vixey: I mean to actually do the iteration, not get the answer :)
14:00:54 <vixey> mauke, ...but there's no way to be sure the result will be an integer
14:01:00 <vixey> :)))
14:01:15 <vixey> ?go evolution of haskell programming
14:01:15 <mauke> jonathanturner: compile with ghc -O2
14:01:17 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
14:01:17 <lambdabot> Title: The Evolution of a Haskell Programmer
14:01:18 <vixey> jonathanturner ^
14:01:31 <vixey> jonathanturner, there are actually lots of ways to not get the answer
14:01:44 <mauke> alternatively, foldl' (+) 0 [1 .. 100000000]
14:01:50 <vixey> yours is the most direct ..
14:02:24 <RayNbow> vixey: why /2 and not `div` 2?
14:02:50 <Samy> vixey, why can't you guarantee it? (n*n + n) / 2 for any integer.
14:02:52 <vixey> RayNbow: at the time, I thought '/' was shorter to type..
14:03:00 <Samy> Oh
14:03:31 <slarba_> http://eigenclass.org/hiki/widefinder2-conclusions hey, a haskell challenge
14:04:04 <RayNbow> oh great, I made Windows happy... everything has been swapped to disk :p
14:08:26 <RayNbow> hmm, is there a reason why Data.List.sum does not strictly evaluate its accumulator in its helper function sum'?
14:08:52 <RayNbow> is it because it might not be desirable for certain instances of Num?
14:09:14 <EvilTerran> pretty much, yeah
14:09:20 <EvilTerran> it could change the semantics messily
14:15:06 <byorgey> RayNbow: it's not much of a reason though.
14:15:22 <byorgey> RayNbow: note that with -O2, GHC will usually turn it into a strict version.
14:15:33 <olsner> hmm, how can you force reinstallation of a cabal package?
14:15:43 <byorgey> olsner: pass it --reinstall
14:15:45 <byorgey> I think
14:22:50 <olsner> ah, ubuntu has the profiling stuff packages separately... apparently I just have to select the right packages
14:23:23 <idnar> @src sum
14:23:23 <lambdabot> sum = foldl (+) 0
14:23:28 <idnar> heh
14:38:42 <idnar> @type (<$>)
14:38:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:38:44 <idnar> @type (<$)
14:38:45 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
14:39:00 <idnar> @src (<$)
14:39:00 <lambdabot> (<$) = (<$>) . const
14:39:08 <idnar> @unpl (<$>) . const
14:39:08 <lambdabot> (\ d -> (<$>) (\ _ -> d))
14:40:11 <EvilTerran> x <$ y = const x <$> y
14:40:27 <EvilTerran> = fmap (const x) y
14:40:28 <idnar> yeah, that's easier to parse
14:40:56 * EvilTerran notes that niven.freenode.net seems to be prone to doing that
14:41:00 <idnar> all this functor / applicative stuff keeps confusing me if I think too hard about it
14:41:12 <idnar> EvilTerran: it's not necessarily niven
14:41:28 <idnar> EvilTerran: freenode shows you any netsplit as a split between yourserver.freenode.net and irc.freenode.net
14:41:35 <EvilTerran> oh, i see
14:41:42 <EvilTerran> i was about to hop server :P
14:42:11 <olsner> ugh, space leaks :(
14:42:22 <idnar> space leaks cause netsplits? :P
14:42:25 <EvilTerran> that's a really weird way of doing it; couldn't they just change the message to "netsplit" if they didn't want to let on which servers it was?
14:45:14 <idnar> EvilTerran: I think they're trying to be nice to clients that detect netsplits (like irssi does)
14:45:35 <EvilTerran> ah
14:45:45 <idnar> I see this in irssi:
14:45:50 <idnar> -!- Netsplit wolfe.freenode.net <-> irc.freenode.net quits: LarstiQ, smtms, tromp_, bens, igno, obraun, camio, fxr, rictic, mm_freak,  (+59 more, use /NETSPLIT to show all of them)
14:46:07 <idnar> and then later:
14:46:07 <EvilTerran> that seems like a useful feature to have :P
14:46:08 <idnar> -!- Netsplit over, joins: clq, profmakx, ArneB, birdspider, besiria, obraun, djsiegel1, wchogg, EmielRegis, aeolist (+26 more)
14:46:18 <idnar> indeed :)
14:46:29 <Peaker> What if you /quit irc.fake.org haha.freenode.org ?
14:46:34 <ddarius> EvilTerran: If like 300 people disappear, it is your server that is the problem.
14:46:48 <idnar> Peaker: then your quit message is "irc.fake.org haha.freenode.org"
14:46:51 <EvilTerran> ddarius, ah, of course
14:46:53 <idnar> Peaker: the real version doesn't have the ""
14:46:58 <Peaker> idnar: oh
14:47:27 <idnar> Peaker: on other ircds that's Quit: irc.fake.org haha.freenode.org or User Quit: irc.fake.org haha.freenode.org or some other variation
14:47:40 <idnar> Peaker: but there's almost always a way to tell the difference between a user-provided message, and a server-provided one
14:48:24 <EvilTerran> i imagine it only kicks in when many happen in a short space of time, anyway
14:48:53 <idnar> well, I think it'll kick in even if it's only one person
14:49:00 <idnar> but if there's a long delay, it'll show separate messages
14:49:22 <mauke> bVTECb just kicked in yo
14:49:32 <EvilTerran> that didn't work right here
14:49:35 <idnar> it also aggregates mode changes
14:49:47 <idnar> eg. if you set mode +o someone and then set mode +o someonelse
14:50:06 <idnar> it holds back on displaying the mode change for a second or two, and just shows you mode +oo someone someonelse
14:51:47 <vixey> @oies  1 2 2 4 3 4 3 8 5 6 4 8 5 6 4 16 9 10 6 12 7 8 5 16 9 10 6 12 7 8 5 32 17 18 10 20 11 12 7 24 13 14 8 16 9 10 6 32 17 18
14:51:47 <lambdabot>  a(0) = 0; a(2n) = 2a(n), a(2n+1) = a(n) + 1.
14:51:48 <lambdabot>  [0,1,2,2,4,3,4,3,8,5,6,4,8,5,6,4,16,9,10,6,12,7,8,5,16,9,10,6,12,7,8,5,32,17...
14:52:09 <vixey> :/
14:52:14 <vixey> that sort of takes the fun out if it
14:52:21 <idnar> heh
14:52:24 <EvilTerran> out of what?
14:52:33 <BrokenClockwork1> I don't get my break exit condition for the following recursion: http://hpaste.org/11552 it should exit, if x div p = 0
14:53:01 <Baughn> @oeis 0 0 0 0 1
14:53:02 <lambdabot>  Binomial coefficients binomial(n,4).
14:53:02 <lambdabot>  [0,0,0,0,1,5,15,35,70,126,210,330,495,715,1001,1365,1820,2380,3060,3876,4845...
14:53:13 <Baughn> @oeis 13 42
14:53:14 <lambdabot>  Number of 6-ary Lyndon words of length n with trace 0 and subtrace 3 over Z_6.
14:53:14 <lambdabot>  [0,0,3,13,42,165,900,5094,29151,167928]
14:53:25 <Baughn> ..there are just way too many lists in that database
14:53:27 <vixey> BrokenClockwork1: It's not a break/exist condition :(
14:53:29 <EvilTerran> that's very... specific, that one
14:53:36 <BrokenClockwork1> not?
14:53:48 <vixey> BrokenClockwork1: so did you try and type check that code?
14:54:09 <vixey> BrokenClockwork1: there's no structured programing break; out of a loop type stuff in functional programming
14:54:37 <BrokenClockwork1> sure
14:54:50 <BrokenClockwork1> but a recursion algorithm has a exit condition
14:54:55 <BrokenClockwork1> , hasn't it?
14:54:57 <lunabot>  luna: Not in scope: `hasn't'
14:55:04 <BrokenClockwork1> as in, the smallest problem, which can be solved
14:55:13 <vixey> BrokenClockwork1: No
14:55:14 <EvilTerran> BrokenClockwork1, but what value should the expression (condiv 0 p) have?
14:55:25 <Peaker> BrokenClockwork1: for your recursion to make any progress, you usually want to pass the recursive call different arguments from those it received
14:56:23 <EvilTerran> Peaker, but he is
14:56:35 <EvilTerran> he's giving it a different number of arguments, too!
14:57:05 <Peaker> EvilTerran: hehe. I doubt these parenthesis are intentional ;)
14:57:25 <BrokenClockwork1> I think so too ^^
14:57:54 <Peaker> BrokenClockwork1: to call condiv with x and p as args, you use:  condiv x p, and not condiv (x p)
14:57:56 <DuClare> 23'55'34 ... igel :n=igel@port-92-195-54-61.dynamic.qsc.de: has quit $ "your ad here"
14:58:21 <BrokenClockwork1> oh right
14:58:48 <EvilTerran> you can use (condiv x) p, too, if you feel so inclined
14:59:05 <Peaker> BrokenClockwork1: now, if condiv x p = condiv x p `div` ...  -- you are recalling condiv with the exact same arguments
14:59:18 <Peaker> BrokenClockwork1: that it already received
14:59:27 <BrokenClockwork1> yeah I get this
15:00:22 <BrokenClockwork1> so how can I nest it the way, that div is called on the result of x div p =
15:00:41 <EvilTerran> BrokenClockwork1, er, what's this function actually meant to *do*?
15:00:46 <Peaker> BrokenClockwork1: x `div` p ?
15:01:03 <EvilTerran> what does (condiv x p) mean in terms of x and p?
15:01:41 <BrokenClockwork1> yeah x 'div' p
15:01:49 <DuClare> It's not '
15:01:51 <EvilTerran> not 'div'
15:01:52 <EvilTerran> `div`
15:02:26 <BrokenClockwork1> sorry, didnt let me type in this chat window so I used the single marks :P
15:02:36 <DuClare> :o
15:03:30 <Peaker> http://www.haskell.org/bz/th3.htm makes TH seem simple
15:03:31 <lambdabot> Title: Template Haskell tutorial
15:03:53 <DuClare> Careful with that, `f` and 'f' are both used but have entirely different meanings. :)
15:03:54 <RayNbow> <byorgey> RayNbow: note that with -O2, GHC will usually turn it into a strict version. <-- I usually try things out without compiling (running examples in ghci)...
15:04:14 <byorgey> RayNbow: yeah, then you'll want to make your own strict version
15:04:18 <Baughn> RayNbow: You can pass -fobject-code -O2 to GHCi for approximately the same effect
15:04:20 <byorgey> sum' = foldl' (+) 0
15:05:26 <RayNbow> byorgey: yup... otherwise I either run out of stack space or out of swap space :p
15:07:25 <BrokenClockwork1> so actually I want to this: x `div` p = result `div` p = result `div` = ... until the result becomes 0
15:08:06 <BrokenClockwork1> but well, I don't know how to implement this functional
15:08:25 <Peaker> BrokenClockwork1: that is a wrong way to put it, you want to do: x `div` p `div` p `div` p until it is ==0 ?
15:08:41 <BrokenClockwork1> yeah
15:08:42 <Peaker> @type iterate
15:08:43 <lambdabot> forall a. (a -> a) -> a -> [a]
15:08:56 <Peaker> > iterate (`div` 5) 21
15:08:57 <lambdabot>   [21,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
15:09:38 <Peaker> > takeWhile (/= 0) (iterate (`div` 5) 21)
15:09:39 <lambdabot>   [21,4]
15:09:56 <EvilTerran> BrokenClockwork1, what meaningful value do you want to get out of this?
15:10:33 <BrokenClockwork1> oh well, this was just a try to split it, actually...
15:10:44 <EvilTerran> pardon?
15:10:51 <Peaker> BrokenClockwork1: what is split, what is "it"?
15:11:50 <BrokenClockwork1> I want to produce a list of mod-results from: x mod p
15:12:05 <BrokenClockwork1> but with every step, x must change to (x `div` p)
15:12:12 <eu-prleu-peupeu> hey!!!
15:12:27 <mauke> :t unfoldr
15:12:28 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
15:12:31 <eu-prleu-peupeu> where can i learn how to do ffi with c++  ?
15:12:46 <mauke> forget it, it's NP-complete
15:12:50 <Zao> eu-prleu-peupeu: Via C?
15:13:04 <mauke> > unfoldr (Just . (`divMod` 10)) 123
15:13:05 <lambdabot>   [12,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
15:13:35 <Peaker> @pl \(a,b) -> (b,a)
15:13:36 <lambdabot> uncurry (flip (,))
15:13:44 <mauke> > unfoldr (Just . swap . (`divMod` 10)) 123
15:13:45 <lambdabot>   [3,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
15:13:47 <eu-prleu-peupeu> Zao: via C ? like solving the wicked name mangling and figuring out wich addresses correspond to which function ?
15:14:01 <eu-prleu-peupeu> i read about this project called "hacanon" anyone used it ?
15:14:02 <Peaker> @src swap
15:14:02 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
15:14:06 <BrokenClockwork1>  x mod p = first result .. (x `div` p) mod p = second result .. ((x `div` p)  div p) mod p = third result ... and so on, putting all the results into a list of numbers
15:14:06 <mauke> eu-prleu-peupeu: no, write an extern "C" wrapper :/
15:14:14 <BrokenClockwork1> that's my actuall goal
15:15:53 <eu-prleu-peupeu> mauke: wont that kill my inline functions ?
15:16:23 <mauke> wat
15:16:33 <mauke> you're going to call them from haskell anyway
15:16:33 <eu-prleu-peupeu> ah
15:16:36 <eu-prleu-peupeu> yes
15:16:39 <eu-prleu-peupeu> stupid me
15:16:51 <eu-prleu-peupeu> i can't have inline funcs on a lib :P
15:16:57 <eu-prleu-peupeu> lol duh
15:17:26 <eu-prleu-peupeu> ill look into hacanon, just for the kick of it
15:17:27 <RayNbow> > unfoldUntil (==0) (swap . (`divMod` 10)) 123
15:17:28 <lambdabot>   [3,2,1]
15:17:44 <EvilTerran> BrokenClockwork1, so you want to build up a list of values?
15:17:58 <BrokenClockwork1> yep
15:18:08 <EvilTerran> well, in that case, you're going to need to return a list!
15:18:32 <BrokenClockwork1> this was my old code: remaindiv x p c = remaindiv (x `div` p) p (x `mod` p : c)
15:18:46 <BrokenClockwork1> I thought this would work
15:18:50 <mauke> infinite recursion
15:18:56 <EvilTerran> ah, a list of remainders
15:19:19 <mauke> this function has no base case. how does it recurse?
15:19:33 <EvilTerran> mauke, _|_!
15:19:46 <mauke> 00Terrible!g
15:20:18 <BrokenClockwork1> that's ,y problem, I didnt find a base case yet, or more badly, I have no idea how the base cas eshould look like on which I construct my recursion step
15:20:25 <Baughn> @index unfoldUntil
15:20:26 <lambdabot> bzzt
15:20:32 <EvilTerran> BrokenClockwork1, well, as i said, you need to be producing a list
15:20:41 <EvilTerran> ?src []
15:20:42 <lambdabot> data [] a = [] | a : [a]
15:20:44 <mauke> BrokenClockwork1: you should return a call to :, not to remaindiv
15:20:53 <olsner> @pl \f x -> f x x
15:20:53 <lambdabot> join
15:21:02 <EvilTerran> hm. that ?src really doesn't help
15:21:32 <EvilTerran> BrokenClockwork1, anyway, there's two basic types of list
15:21:37 <EvilTerran> ?type [] -- the empty list
15:21:38 <lambdabot> forall a. [a]
15:22:58 <RayNbow> Baughn: unfoldUntil p f = unfoldr (\x -> guard (not (p x)) >> return (f x))
15:22:59 <EvilTerran> ?type 1 : [] -- and "cons cells"; (x:xs) is the list starting with x and thereafter being xs
15:23:00 <lambdabot> forall t. (Num t) => [t]
15:23:17 <EvilTerran> > 1 : [] = [1]
15:23:18 <RayNbow> unfoldUntil is a nice function newsham once pasted here
15:23:18 <lambdabot>   <no location info>: parse error on input `='
15:23:22 <EvilTerran> > 1 : [] == [1]
15:23:24 <lambdabot>   True
15:23:37 <EvilTerran> BrokenClockwork1, in your base case, you'll probably want to return an empty list, []
15:24:33 <EvilTerran> BrokenClockwork1, and, in your recursive case, you'll probably want "... = (some value) : (a recursive call)"
15:25:07 <vixey> too many ideas.. there's no way to put it all together in one source code :/
15:25:26 <BrokenClockwork1> remainlist c = []
15:25:27 <BrokenClockwork1> remainlist c = (divoperation) : c
15:25:38 <EvilTerran> er, what happened to your other parameter?
15:25:44 <vixey> that's so weird BrokenClock
15:26:35 <BrokenClockwork1> sorry I get tired and that: "you'll probably want "... = (some value) : (a recursive call)" :o
15:26:42 <BrokenClockwork1> confused me
15:27:01 <EvilTerran> 1sec
15:27:47 <vixey> BrokenClock, Do you know the link with recursive functions and proof by induction?
15:27:58 <EvilTerran> BrokenClockwork1, http://hpaste.org/11552#a1
15:28:06 <BrokenClockwork1> no, proof by induction we hadnt yet
15:28:19 <vixey> oh you've never seen a proof by induction? :)
15:28:32 <EvilTerran> that would make recursion more confusing
15:28:37 <BrokenClockwork1> I did
15:28:39 <BrokenClockwork1> but just once
15:28:44 <vixey> hm there's a nice one I can't remember about being able to draw any sqrt with a straight edge and compass
15:29:13 <vixey> BrokenClock, anyway, I find this very a useful connection, basically they are ..the same exact thing
15:29:39 <vixey> BrokenClock, So the approach you take to write a recursive function can be just how you might prove by induction something
15:30:18 <vixey> BrokenClock, i.e. for length, you have length [] = 0, and for length (x:xs) assuming 'length' works for xs, how do you get length (x:xs) ? .. 1 + length xs
15:30:19 <BrokenClockwork1> I jsut started going to university, I had just 3 or 4 math lectures yet ^^
15:30:45 <vixey> not sure what remainlist is, but I'm sure you can write it by thinking about it in this same fashion
15:32:01 <BrokenClockwork1> okay, what about this one: http://hpaste.org/11552#a2
15:32:14 <vixey> BrokenClockwork1: There's a good book actually, The Moment of Proof by Donald C. Benson
15:32:39 <vixey> BrokenClockwork1: If you have gone to high school or something, so you missed out on all the good math you could have been studying otherwise, then it's a must read
15:33:49 <BrokenClockwork1> no, no high schools in Berlin
15:33:51 <Peaker> vixey: did you manage to avoid high school?
15:34:16 <vixey> no
15:35:12 <EvilTerran> BrokenClockwork1, that one's very close; you've just put a set of parentheses in the wrong place again
15:35:39 <olsner> hmm, real-time heap retainer profiling was kind of fun
15:35:42 <EvilTerran> i'm partly at fault that time, i should've left two (???)s after "remainders" there to indicate the presence of two parameter
15:35:43 <EvilTerran> s
15:36:14 <olsner> but top shows the program always increasing in memory size, while the heap profile says it's fluctuating around 8MB
15:36:16 <BrokenClockwork1> http://hpaste.org/11552#a3
15:36:36 <BrokenClockwork1> no nto really i'm doing this mistake again and again.. *g*
15:37:02 <vixey> just remember:
15:37:07 <EvilTerran> that looks right
15:37:08 <vixey> f x y z = (((f x) y) z)
15:37:13 <EvilTerran> BrokenClockwork1, have you tried it?
15:37:38 <BrokenClockwork1> no I will do now
15:38:44 <EvilTerran> you can learn a lot just by goofing around in a small file and loading it into ghci (or hugs) to tinker with it
15:39:06 <EvilTerran> you at least pick up on enough haskell to be able to decipher ghci's error messages pretty quickly, anyway :P
15:40:18 <BrokenClockwork1> Isn't that the actualy way to really udnerstand a programming language? =)
15:41:03 <EvilTerran> well, the best way to understand a natural *or* programming language is by immersion
15:41:10 <vixey> no
15:41:27 <EvilTerran> ... once you've reached a basic level of competence, so you won't Learn It Wrong
15:41:33 <EvilTerran> at least
15:41:45 <vixey> this is actually not good advice
15:42:01 <EvilTerran> no?
15:42:25 <EvilTerran> i find i pick up a new programming language a lot quicker when i find excuses to use it everywhere
15:42:56 <vixey> no that's fine
15:43:19 <vixey> I'm objecting to 'futz around until it works'
15:43:36 <EvilTerran> vixey, i didn't suggest that
15:44:36 <pumpkin_> :o
15:44:47 <EvilTerran> i meant more "futz around with it after it works; break it in new and interesting ways, and then learn while you fix it"
15:45:29 <vixey> mmorrow, awesome find (FPH).. wishing this was in GHC :)
15:45:48 <EvilTerran> FPH?
15:46:44 <vixey> http://www.cis.upenn.edu/~dimitriv/fph/
15:46:47 <Axman6> frigging parallel haskell
15:47:10 <Axman6> i like mine better
15:47:15 <mmorrow> vixey: i believe it's being or already is incorporated into HEAD
15:47:23 <vixey> great
15:47:32 <mmorrow> http://research.microsoft.com/~simonpj/papers/boxy/
15:47:32 <lambdabot> Title: Simon Peyton Jones: papers
15:48:21 <BrokenClockwork1> the remainders function works very well
15:49:07 <vixey> I really more resources (time and brain) to actually write the code I want :/
15:49:11 <vixey> really need*
15:49:30 <EvilTerran> vixey, don't we all =/
15:50:18 <EvilTerran> now it looks like i'm going to burn what few resources i have reading this fascinating- but exhausting-looking paper :P
15:50:33 <BrokenClockwork1> that's the hunger
15:50:42 <EvilTerran> OM NOM NOM TYPE SYSTEMS
15:50:44 <vixey> I skimmed the code first
15:51:03 <EvilTerran> (sorry)
15:52:09 <vixey> Do you think there is a market for my cereal idea
15:52:18 <vixey> "Monad Transformers"
15:57:21 <BrokenClockwork1> if I define a a function, with the content: if ... then a else [a]
15:57:25 <BrokenClockwork1> is that possible?
15:57:30 <dmwit> No.
15:57:35 <BrokenClockwork1> damn
15:57:42 <dmwit> Both branches must result in a value of the same type.
15:57:53 <BrokenClockwork1> yeah thought so... mhhh
15:57:55 <dmwit> (Or else what would the correct type be?)
15:58:45 <EvilTerran> BrokenClockwork1, why do you want to do this?
15:58:53 <xcthulhu> BrokenClockwork1: I think it's in the Haskell docs somewhere that you should think of "if ... then ... else ..." like a function "f' :: Bool -> a"
15:59:22 <Peaker> Bool -> a -> a -> a perhaps?
15:59:24 <BrokenClockwork1> true...
15:59:41 <xcthulhu> Peaker: yeah, that makes more sense
15:59:44 <vixey> BrokenClock: I use:
15:59:47 <vixey> bool true false True = true
15:59:51 <vixey> bool true false False = false
15:59:53 <vixey> sometimes
16:00:08 <vixey> it's useful becaues you can chain it with other things like  f . g . bool p q . h ...
16:00:28 <BrokenClockwork1> :o
16:00:29 <BrokenClockwork1> http://hpaste.org/11553
16:00:31 <BMeph> I prefer swapping the false and true branches, but otherwise I do the same. :)
16:01:02 <vixey> BMeph: You put the _false_ case first?
16:01:03 <BrokenClockwork1> that's my complete source so far, the compiler whines about: then -> a and else -> [[a]]
16:01:40 <BrokenClockwork1> ?
16:01:45 <EvilTerran> ...
16:01:49 <xcthulhu> BrokenClockwork1: You could make a new datatype.
16:02:11 <BMeph> vixey: Yes! Because, it's first in the declaration. Just like I handle the Nothing case before the Just, even though most folks write case statements the other way around. :)
16:02:18 <xcthulhu> With appropriate constructors for "Lone" and "ListList" or something
16:02:22 <EvilTerran> BrokenClockwork1, your function appears to be confused
16:02:26 <vixey> ok
16:02:36 <BrokenClockwork1> the convert one?
16:02:38 <EvilTerran> what's it taking as a parameter? what's it giving back?
16:03:21 <xcthulhu> BrokenClockwork1: I don't know what you mean by "the convert one"
16:03:32 <EvilTerran> any of them
16:03:33 <EvilTerran> all of them
16:04:09 <BrokenClockwork1> is this question about what's my code intention?
16:04:24 <EvilTerran> pretty much, yes
16:04:35 <EvilTerran> the types of the functions would be a start
16:04:46 <BMeph> BrokenClockwork1: Yeah, that 'convert' function has a messed-up declaration - you'd have to test for what type it returns, to be able to handle it right. :/
16:04:47 <BrokenClockwork1> the task is a programm which converts nubmers from different basis to other different basis
16:05:05 <EvilTerran> what form are these numbers meant to be in?
16:05:34 <vixey> oh cool
16:05:34 <EvilTerran> Int, just the number? [Int], a list of digits? String, a textual representation?
16:05:38 <BMeph> BrokenClockwork1: Not to mention, you use x differently in 'dec' and 'remainders'. :)
16:05:42 <vixey> this is actually a very nice program
16:06:04 <vixey> > foldr (\x y -> y * 10 + x) 0 [3,6,8,4]
16:06:05 <lambdabot>   4863
16:06:12 <Ferdirand> sounds like a good candidate for fold/unfold
16:06:16 <vixey> this program works for any base obviously
16:06:26 <vixey> it is the inverse of what you want to program
16:06:36 <BrokenClockwork1> I havn't decided yet EvilTerran to be certain ^^
16:06:43 <vixey> .. and it happens to be the easiest program to invert that I know :)
16:07:04 <BrokenClockwork1> if decimal, then it can be an Int
16:07:09 <vixey> so you use unfoldr, like Ferdirand says
16:07:10 <BrokenClockwork1> otherwise it should be a list
16:07:15 <EvilTerran> BrokenClockwork1, well, as haskell is strictly typed, you need to stick with a single, consistent representation
16:07:22 <BrokenClockwork1> ok
16:07:35 <EvilTerran> lists would work fine for decimals too, so i guess lists are the way to go
16:07:59 <mmorrow> <vixey> Do you think there is a market for my cereal idea
16:08:01 <mmorrow> lol
16:08:05 <BrokenClockwork1> then I should rewrite this, otherwise it wouldnt be very elegant
16:08:17 <Ferdirand> Monad Crunch
16:08:17 <dmwit> BrokenClockwork1: Are you familiar with readInt and showIntAtBase?
16:08:19 <dmwit> :t readInt
16:08:20 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> String -> [(a, String)]
16:08:22 <dmwit> :t showIntAtBase
16:08:23 <lambdabot> forall a. (Integral a) => a -> (Int -> Char) -> a -> String -> String
16:08:29 <BrokenClockwork1> no
16:08:32 <EvilTerran> BrokenClockwork1, well, you need to write some function that takes a list of digits and two bases, and returns another list of digits
16:08:37 <vixey> BrokenClockwork1: You probably wont study unfoldr :)
16:08:47 <dmwit> BrokenClockwork1: Unless this is an exercise for learning Haskell, I recommend using those. =)
16:08:49 <vixey> BrokenClockwork1: .. but at least know, it is the correct way to write this program
16:08:51 <EvilTerran> BrokenClockwork1, this would probably be easier if broken down into two parts
16:08:58 <BrokenClockwork1> it is
16:09:04 <conal> is there a haddock that works with ghc 6.9?  haddock-2.2.2 depends on ghc ==6.8.2||==6.8.3, and had-2.3.0 (from darcs) dies trying to find MonadUtils
16:09:51 <mmorrow> conal: haddock comes with (the src version at least) 6.9 i think and 6.10 i know
16:09:56 <EvilTerran> BrokenClockwork1, as in, "convertBases from to x = convertToBase to (convertFromBase from x)"
16:10:15 <EvilTerran> hang on
16:10:17 <conal> mmorrow: oh!  maybe my local version is shadowing the ghc version.
16:10:25 <mmorrow> conal: but i once built a haddock other than the one that came with ghc and it was all pain
16:10:47 <mmorrow> yeah, weird shadowing and errors happened
16:11:21 <EvilTerran> BrokenClockwork1, anyway, i think it'd be easier to write one function that takes a list of digits and a base, and produces a single Int
16:11:40 <EvilTerran> BrokenClockwork1, ... and another that takes a base and a number, and produces a list of digits
16:11:48 <BMeph> BrokenClockwork1: Have you noticed that dec's first argument is a list, but the function gives a list, and remainders does the opposite?
16:12:11 <conal> mmorrow: urg.  there's no haddock.exe in my ghc-6.9.20080622/bin .  it's a good idea packaging them, since they have to be in sync.
16:12:12 <EvilTerran> you've done something like that with dec and remainders
16:12:25 <EvilTerran> but then you've combined them rather oddly
16:12:30 <mmorrow> conal: totally
16:12:56 <conal> and sadly, ghc>6.9 crashes with glut on my machine.  hm.
16:13:01 <mmorrow> conal: 6.10 is nice
16:13:02 <mmorrow> ah
16:13:04 <mmorrow> too bad
16:13:23 <conal> mmorrow: i love the type family fixes in 6.10.  what do you like?
16:13:35 <dons> faster smp
16:13:36 <mmorrow> heh, hmm..
16:13:50 <conal> dons: faster smp in 6.10?
16:14:02 <dons> yea.
16:14:05 <vixey> I am the only one using 6.11?
16:14:06 <conal> nice
16:14:22 <mmorrow> quasiquotes, type family stuff for sure, ghci WITH A HISTORY, seemingly speedier everything ..
16:14:29 <EvilTerran> vixey, your ghc goes up to 11?
16:14:47 <conal> EvilTerran: heh
16:14:48 <mmorrow> vixey: i haven't built a 6.11 yet
16:15:03 <mmorrow> i'm still trying to get everything to work on the official 6.10
16:15:07 <conal> mmorrow: sounds great.  i'll try to fix my gl problem.
16:15:27 <mmorrow> conal: good luck
16:15:32 <conal> thx
16:15:36 <dmwit> After 6.10 should be 7
16:16:05 <EvilTerran> surely that should come after 6.9?
16:16:21 <vixey> Imagine what GHC 10 will be
16:16:23 <vixey> lol
16:16:27 <BMeph> dmwit: No, after 6.9 should be 6.A ;)
16:16:43 <dmwit> 6.AAAAAAAAAAA
16:16:52 <dmwit> -- the zombie version
16:17:48 <mmorrow> haha
16:18:16 <mmorrow> @remember dmwit [ghc] 6.AAAAAAAAAAA -- the zombie version
16:18:17 <lambdabot> Okay.
16:18:49 <lispy> GPL forbids static linking but not dynamic linking with non-free code, right?
16:26:35 <pjdelport> lispy: in court, i think it will come down to who has the more persuasive lawyers
16:27:03 <pjdelport> the question is almost religious
16:32:16 <profmakx> it's official, arrows are awesome...
16:32:32 <roconnor> profmakx: I don't get arrows
16:33:10 <profmakx> i am playing around with them at the moment
16:33:44 <roconnor> I've never used them. I feel like I'm missing out.
16:34:11 <roconnor> well, I used them in HaXml or one of the XML libs, but I just followed recipes
16:34:13 <Saizan> profmakx: in which context?
16:34:27 <profmakx> just playing around with functions
16:34:56 <profmakx> and arrows
16:35:00 <profmakx> making up examples
16:35:28 <lispy> pjdelport: huh, so I can just compile the GPL'd stuff into a DLL and use that DLL from my incompatibly licensed application?
16:35:35 <lispy> pjdelport: er, can't
16:35:57 <profmakx> i wouldn't say i fully understood them, but i like the idea until now
16:36:33 <mmorrow> that's pretty much the same as just sticking the GPL'ed code into your closed src app's code
16:36:43 <pjdelport> lispy: the intent is probably to not allow that; the LGPL is supposed to
16:36:49 <pjdelport> but it's one big gray area
16:36:53 <pjdelport> define "link"
16:37:15 <lispy> pjdelport: C++ style win32 dlls
16:37:20 <pjdelport> it becomes highly dependent on how your language and runtime works
16:37:22 <lispy> pjdelport: that's my "link" definition
16:37:40 <lispy> pjdelport: in this case, everything in C++, the dll and the application
16:37:46 <BrokenClockwork1> okay, tired as hell, good night people, thx for the help today *wave*
16:37:50 <lispy> I'm just asking here because people are smart an responsive :)
16:37:55 <pjdelport> and for example, what if you write a trivial GPLed wrapper
16:38:09 <pjdelport> that communicates with your non-GPL program over a socket or pipe
16:38:23 <pjdelport> in lieu of conventional linking
16:38:50 <pjdelport> there are all kinds of ways to subvert the definitions
16:39:21 <mmorrow> i believe it comes down to whether you're /distributing/ the binary GPL'ed code as a crucial part of your closed src app
16:39:58 <mmorrow> lispy: i feel like the whole point of the GPL is not allow what you're trying to do :)
16:40:03 <pjdelport> right, but also to what the definition of "part of" is
16:40:11 <wjt> the "imagine an ipc linker" argument
16:40:57 <wjt> the "imagine an ipc linker" argument is kind of lame; by that argument you might wind up saying that a web browser is a derivative work of a web server
16:41:20 <lispy> in this case, we used a library to auto generate C++ code for a particular schema
16:41:23 <lispy> xml schema
16:41:31 <lispy> and then we want to read/write that schema from our app
16:41:39 <mmorrow> hmm
16:41:45 <lispy> we can use a different library or something though.  I just wanted to make sure that this was illegal first
16:42:01 <mmorrow> that might be ok
16:42:05 <pjdelport> lispy: generally speaking, generated output is not covered by the license
16:42:07 <lispy> this is a format converter so that schema is integral to our app
16:42:21 <mmorrow> for instance, clearly asm that gcc outputs isn't required to be GPL
16:42:21 <EvilTerran> @remember lispy I just wanted to make sure that this was illegal first
16:42:21 <lambdabot> Done.
16:42:22 <vixey> so
16:42:23 <vixey> http://www.cs.nott.ac.uk/~nad/publications/danielsson-types2006.tgz
16:42:28 <lambdabot> http://tinyurl.com/668o5c
16:42:28 <vixey> did anyone .. port this to Agda 2
16:42:30 <EvilTerran> quoting out-of-context is FUN! :P
16:42:30 <vixey> ? :)
16:42:42 * vixey I would like to run this code
16:43:09 <pjdelport> http://www.brouhaha.com/~eric/editorials/gpl_dynamic_link.html
16:43:16 <lambdabot> Title: Dynamic Linking and the GPL
16:43:19 <lispy> mmorrow, pjdelport: I must be confusing you.  The XML is fine.  I wanted to know about the GPL'd C++ code that that was generated from the schema.  The tool we used put the GPL on our code.
16:43:48 <TehKake> http://hpaste.org/11556 I'm kind of new to haskell, this is the first time I've delt with types that have Maybe in them, I'm not sure exactly what I'm doing wrong.
16:43:57 <pjdelport> lispy: i don't think the tool can "put the GPL" on code like that
16:44:04 <lispy> pjdelport: really?
16:44:06 <pjdelport> copyright doesn't work that way
16:44:18 * EvilTerran agrees with pjdelport
16:44:30 <pjdelport> the people who GPLed the tool do not have any copyright over the tool's output to begin with
16:44:46 <pjdelport> so the tool can add the GPL all it likes, but it carries no legal weight or meaning
16:44:52 <lispy> hmm
16:45:00 <pjdelport> you can freely ignore it
16:45:06 <vixey> TehKake: think you just gotta have (Just "This string causes an error")
16:45:09 <pjdelport> this is why GCC-compiled code is not GPLed
16:45:12 <pjdelport> for example
16:45:22 <pjdelport> the GPL only extends over GCC itself
16:45:24 <mmorrow> lispy: that's what i'm talking about. maybe i don't understand something though. so the GPL'd code is the code that /generates/ some C++ from an xml schema, right?
16:45:29 <TehKake> vixey, I actually tried that.
16:45:41 <mmorrow> if so, then i don't think that the /generated/ code has to be GPL
16:45:51 <TehKake> It gave me the same error only replaceing [CHar] with a-> Maybe a
16:45:52 <lispy> Well, the tool is not GPL'd.  Just their license agreement puts the GPL on the generated code with the provison that you can pay them $X to remove that GPL
16:46:00 <mmorrow> in the same way that asm output by gcc doesn't have to be GPL
16:46:02 <TehKake> [Char]*
16:46:04 <vixey> TehKake: ((((Just "This string causes an error"))))
16:46:05 <mmorrow> oh
16:46:16 <mmorrow> then it sounds like you're screwed :)
16:46:34 <pjdelport> lispy: ok, that's a different story then
16:46:39 <TehKake> I didn't think to do that!
16:46:41 <EvilTerran> that license agreement sounds a bit suss
16:46:45 <TehKake> Thanks vixey!
16:46:53 <mmorrow> lispy: can you afford to pay them?
16:46:59 <pjdelport> assuming you don't otherwise have rights to use the tool
16:47:00 <lispy> Right.  so we're asking another internal group if they have code for this schema already and failing that we will either use a different library, pay $x or get the code some other way
16:47:23 <lispy> The tool is free as in beer
16:47:36 <mmorrow> haha, how sneaky
16:47:38 <lispy> We haven't really started the project yet, so we can still change things
16:47:46 <EvilTerran> that does kinda make sense, actually
16:47:50 <lispy> We just found this and though we could use it
16:47:51 <EvilTerran> from their point of view
16:48:08 <mmorrow> it does
16:48:09 <pjdelport> lispy: if you have the resources, i suggest getting a copyright lawyer's opinion
16:48:16 <lispy> There are probably a million tools that generate C++ for a specific XSD
16:48:34 <pjdelport> lispy: i'm not sure if the tool can do that
16:48:35 <lispy> pjdelport: I don't think we have the resources given that we're not yet committed to using it
16:48:44 <EvilTerran> pjdelport, well, unless the $X would be insignificant compared to the price of a copyright lawyer's professional opinion
16:48:50 <pjdelport> right
16:49:02 <lispy> iirc, it's a one time licensing fee of $4k
16:49:05 <lispy> USD
16:49:12 <EvilTerran> ...
16:49:16 <pjdelport> lispy: anyway, if the linking is dynamic, the question could be moot
16:49:44 <lispy> pjdelport: okay, using a dll was my first instinct...but then I started to doubt myself
16:49:44 <pjdelport> re. that link i pasted above
16:50:31 <lispy> I think _|_ line is that we should only use this if there aren't good alternatives
16:50:53 <lispy> and we should be prepared to pay the $4k if it turns out we were wrong
16:51:01 <mmorrow> but if you have to provide the binary dynamic lib /as part of your product/, then it might as well be all one binary (in that it's essentially the same thing)
16:51:02 <pjdelport> down with GPL extortion
16:51:03 <mmorrow> (i think)
16:51:31 <vixey> my rule of thumb:
16:51:40 <vixey> release as GPL or don't touch anything GPL
16:51:47 <lispy> This is one of those times when I should use Haskell + Language.C and make my own converter :)
16:51:51 <vixey> that means readline
16:52:18 <mmorrow> i like the GPL a lot. it's great for protecting your code if protected you want it to be.
16:53:20 <lispy> I find that I like BSDing my stuff so that if I'm ever in a professional situation and I want to use a pet project because it makes a lot of sense then I can
16:53:36 <mmorrow> i don't get how people can piss and moan that they can't use GPL code in their closed source apps, when (1) that's the whole reason the author(s) made it GPL, and (2) the people aren't releasing /any/ of their source code for their app
16:53:59 <Saizan> you can always relicense your code anytime, i hope?
16:54:06 <mmorrow> (that wasn't directed at anyone in particular of course :)
16:54:13 <lispy> Saizan: it really depends on if people have contributed or not
16:54:47 <lispy> Saizan: for example, quite a few darcs devs would prefer to switch to BSD but it's not really able to happen because not all the significant authors want that
16:54:55 <vixey> mmorrow: What I don't like is I can't just take a chunk of GPL code and paste it into my program, without having to say my code is GPL too
16:55:56 <Saizan> lispy: i see
16:57:55 <mmorrow> vixey: well, you can't even do the pasting in the first place of code from a closed src app since you don't have the code in the first place. so while that may be annoying, i see GPL code as "you wouldn't even be able to see this code if it weren't for the GPL, since without GPL protection this code would never have been open sourced"
16:58:42 <vixey> mmorrow: What I really mean is, I wish GPL didn't exist - but only if closed source also didn't exist
16:58:49 <mmorrow> hah
16:59:02 <mmorrow> that would be nice
16:59:18 <mmorrow> (and it would be the same as if everything was GPL too)
16:59:36 <mmorrow> and by "same" i mean "equivalent"
16:59:37 * shapr yawns
16:59:39 <vixey> if everything was GLP I'd have to actually read the bloody thing and figure out what it means
16:59:55 <mmorrow> but it wouldn't matter anymore, since everything is GPL
17:00:00 <shapr> vixey: It's a goedel attack against the legal system.
17:00:09 <vixey> :p
17:00:10 <mmorrow> it wouldn't have to exist
17:00:12 <Peaker> shapr: haha, never heard that definition before ;-)
17:00:14 <glguy> GPL in Haskell is kind of thumbing your nose at the rest of the community "You might all be contributing your work to a common BSD collection but my code isn't going to be used in such a way"
17:00:17 <vixey> gn shapr :)
17:00:22 <shapr> gn vixey
17:00:43 <vixey> I am really annoyed I don't have the time to put all my ideas down ..
17:00:49 <mmorrow> glguy: but GPL'ed code is surely better than code which was never open-sourced in the first place
17:01:03 <glguy> is it?
17:01:09 <shapr> Personally, I prefer the GPL.
17:01:12 <glguy> it detracts from other efforts to write bSD'd code
17:01:16 <glguy> and splits effort
17:01:25 <mmorrow> well, the community gets no benefit from code they never have
17:01:27 <shapr> I've dealt with enough selfish companies that I don't trust them.
17:01:46 <cjb> moreover, you can't expect a company's management to stay trustworthy from one year to the next
17:01:49 <vixey> by the way do you mean GPL 3 or what?
17:01:52 <shapr> cjb: truly
17:02:11 <mmorrow> vixey: i do, yes
17:02:15 <vixey> ok
17:02:23 * vixey is making a note to actually read it tommorow
17:02:29 <Peaker> glguy: what is BSD's advantage over GPL?
17:02:34 * cjb uses GPLv3 > GPLv2 > BSD, in order of preference
17:02:38 <cjb> Peaker: advantage to whom?
17:02:45 <Peaker> cjb: to glguy I guess
17:02:54 <cjb> I think the answer is mu
17:03:06 <glguy> the advantage to me is that when I write stuff that I want to release BSD, I have more libraries to choose from
17:03:10 <glguy> to include in it
17:03:11 <shapr> In short, companies are scared, so they want to be able to produce closed source.
17:03:11 <cjb> the advantage is to people who want to use glguy's code without giving source code back
17:03:21 <shapr> And they can't produce closed source from GPL code.
17:03:35 <shapr> So BSD is there to allow companies to try BSD before they go GPL.
17:03:46 <shapr> That's my short and highly inaccurate perception.
17:03:56 <cjb> I guess that's one way to look at it :)
17:04:08 <Peaker> glguy: Why? You can't use GPL libs. If you use GPL, you can use BSD libs
17:04:15 <Peaker> glguy: Isn't ti the opposite?
17:04:27 <shapr> Peaker: Not from his viewpoint.
17:04:27 <glguy> Peaker, I'm not interested in imposing additional restrictions on people using my code
17:04:36 * mmorrow only uses GPL(3) when he feels a need to protect an investment, and BSD for code he writes to be a useful library
17:04:52 * mfp likes LGPL + linking exception
17:05:04 <Peaker> glguy: why not?
17:05:07 <shapr> I use GPL3 for code I've written all by myself, but otherwise I follow the community.
17:05:09 <roconnor> protect an investment?
17:05:12 <glguy> Peaker, do unto others?
17:05:17 <cjb> Peaker: I think you're correct, in terms of number of packages out there etc.
17:05:19 <glguy> I don't want people to place restrictions on me
17:05:21 <glguy> so I don't do it to them
17:05:27 <Peaker> glguy: these restrictions are exactly implementing do unto others :-)
17:05:34 <vixey> I always used BSD for the same reason as glguy
17:05:38 <shapr> glguy: Yeah, but do unto others assumes everyone else is doing the same thing.
17:05:54 <shapr> GPL is legally enforced open source.
17:05:54 <Peaker> glguy: they are demanding others to do unto others, if they want to use your softawre
17:05:54 <glguy> I'm not trying to enforce some sort of morality with my code
17:06:00 <glguy> but I'd like to make it possible
17:06:03 * cjb is motivated by what should happen to the people using his software, more than by his job in getting to write the software.
17:06:10 <mmorrow> roconnor: an investment of time and effort in code which i write that i may use to make money, but at the same time don't want to close-src
17:06:24 <xmux> GPL is software 'freedom' enforced at gunpoint
17:06:33 <mmorrow> exactly!
17:06:38 <vixey> xmux: why do you say 'gunpoint'?
17:06:39 <mmorrow> and it's excellent at that
17:06:47 <cjb> xmux: I enforce you to be free!  With this gun!  Oh, wait, that's not a good analogy at all.
17:06:55 <roconnor> mmorrow: in case some company wants to buy a non-GPL licenced version?
17:06:57 <glguy> Team America: World Police
17:07:00 <glguy> that kind of freedom?
17:07:01 <xmux> vixey: because if you infringe copyright, people with guns come to take you to court
17:07:31 <vixey> xmux: if $big_company uses my GPL library, I think there is nothing I can do, is there?
17:07:33 <mmorrow> roconnor: mostly so that no one grabs it and sticks it in some closed src app of theirs and gets my labor for free
17:07:39 <cjb> That's like saying GPL is software 'freedom' enforced by slavery.  It makes ho sense; either it produces freedom, or it produces slavery.
17:07:46 <vixey> xmux: unless I pay for lawyers and pay for court and all this crap
17:07:46 <cjb> s/ho/no/
17:07:46 * EvilTerran would consider the GPL to be more "freedom as in what RMS thinks" as compared to the other types
17:07:47 <sbahra> mmorrow, any thoughts on the FPGA issues? :)
17:07:53 <xmux> vixey: You can use any license you want.  It's your code
17:07:55 <sbahra> It has been ~2 weeks.
17:08:10 <cjb> and so then we say "well, what kind of outcome does this produce?" and we notice a lack of slavery and a presence of freedom, and we conclude it's all good.
17:08:26 <vixey> xmux: if someone else infinges on my GLP code, where do I get the gun people to take them to court?
17:08:43 <mmorrow> sbahra: ah, hey :) a bunch of thoughts, but what about FPGAs in particular?
17:08:58 <vixey> xmux: I mean they don't do it for free, do they?
17:09:06 <xmux> vixey: I think the FSF has a website set up for that purpose
17:09:07 <sbahra> mmorrow, remember I was talking about an invocation framework?
17:09:10 <cjb> vixey: you threaten to file a copyright infringement suit, and they say "oh crap, I have to either agree with the GPL or admit that I'm totally stealing this code" and then they follow the GPL.
17:09:17 <roconnor> mmorrow: I don't know how to fit your reply with your previous comment about "code which i write that i may use to make money"
17:09:19 <sbahra> mmorrow, to allow for resource allocation (scheduling compute tasks, etc...)
17:09:27 <GNU\caust1c> how can you do recursion with lambda functions?
17:09:30 <sbahra> mmorrow, asynchronous API
17:09:32 <mmorrow> sbahra: ah, yes
17:09:43 <EvilTerran> GNU\caust1c, you can't using only lambda expressions
17:09:44 <vixey> GNU\caust1c: You can't do that in haskell because of the types*
17:09:48 <cjb> vixey: the Software Freedom Law Center gives free legal facilities to free software projects.
17:09:50 <vixey> GNU\caust1c: (* this is actually possible)
17:10:05 <cjb> http://www.softwarefreedom.org/
17:10:06 <lambdabot> Title: Software Freedom Law Center
17:10:07 <GNU\caust1c> but the lambda calculus allows it?
17:10:16 <EvilTerran> GNU\caust1c, see, that's where the types come in
17:10:34 <EvilTerran> GNU\caust1c, have to seen the simply-typed lambda calculus in particular?
17:10:41 <shapr> Look at the history of WINE and Transgaming's Cedega to see how the BSD can be exploited.
17:10:43 <Peaker> glguy: I think maybe the way I look at it, is that I also follow "do unto others", but these "others" are not just the direct recipients of my code, but also indirect ones
17:10:56 <cjb> Peaker: yeah, exactly.
17:11:03 <Peaker> glguy: I don't see the direct ones as more important in any way
17:11:05 <glguy> Peaker, no, that is "require unto others"
17:11:22 <cjb> it's very developer-minded to phrase the question as if the developer giving and developer receiving the code are all that matters
17:11:27 <GNU\caust1c> hm EvilTerran, i dont really know much about the lambda calculus, thats why i ask
17:11:28 <Peaker> glguy: well, either I require the direct recipients, or I'm screwing the indirect ones
17:11:30 <cjb> there are these couple of million potential users in the middle
17:11:34 <shapr> Corporations are the most selfish shortsighted individuals I've never met.
17:11:43 <Peaker> glguy: And since I'm requiring very reasonable things, I have little problem with requiring them
17:11:47 <GNU\caust1c> i googled and didnt find much useful
17:11:59 <glguy> Peaker, and if someone can't get the code from someone I gave it to, they can get it from me
17:12:23 <glguy> if someone has a closed source program and you can't change it, don't use it
17:12:30 <Peaker> glguy: that's naive. There may be modifications that are required in order to run it on a Tivo, or to read a secret format, or whatever
17:12:30 <EvilTerran> GNU\caust1c, well, the thing about most type systems, especially those based off the STLC's type system (like haskell's), is that types must be finite
17:12:35 <mmorrow> roconnor: so yeah, someone paying me for a non-GPL license would be one way. another would be using that code as a base to provide paying people with a service that's delivered by customizing this code base to some particular need. so i'm getting paid for the customization, not the software itself. so in the latter case, i don't want someone to take this code base and put it in a shrinkwrapped closed app which aims to take my place with code i wrote helping the
17:12:36 <mmorrow> m do that
17:12:39 <Cale> http://down.codeweavers.com/ -- hehe
17:12:40 <lambdabot> Title: CodeWeavers
17:13:08 <GNU\caust1c> EvilTerran: so a recursive lambda function would be an infinite type?
17:13:14 <vixey> well actually I think you can do recursion in STLC
17:13:25 <Peaker> glguy: Your two options end up A) screwing indirect recipients of your software, while profiting direct recipients (at your expense, really), or B) helping indirect recipients, while disallowing direct ones from abusing copyright against users
17:13:26 <glguy> we aren't going to convince each other either way in an IRC channel
17:13:30 <vixey> you can write addition on N for example
17:13:49 <xmux> nobody ever convinces anybody in this particular argument
17:14:00 <vixey> xmux: actually my mind is open to change
17:14:17 <xmux> I've never seen it happen at least
17:14:21 <Saizan> vixey: can you? i thought that required System F
17:14:21 <xmux> or even close
17:14:30 <roconnor> mmorrow: in the first case, you cannot accept patches from other people (maybe you are okay with this).  In the second case, I don't see why you wouldn't want to use a BSD style licence.
17:14:42 <mmorrow> sbahra: hmm, so i haven't thought about that in particular, but that's mostly because i only know the basics of your idea. could you give me a short spiel? :)
17:14:44 <Philippa> vixey: you probably want to state the functions you're assuming are defined
17:14:50 <sbahra> mmorrow, I did :(
17:14:51 <Cale> vixey: wait, so are you saying you can do arbitrary recursion in STLC, or that you can do certain types of recursion?
17:15:00 <sbahra> mmorrow, I can't right now. I'll get back to you soon.
17:15:12 <vixey> I think you can do certain types of recursion, every polynomial function is definable or something
17:15:35 <vixey> and yes I am being horribly informal.. but I'm not very /sure/ either
17:15:44 <mmorrow> sbahra: sry. can you link me to your site again?
17:15:56 <GNU\caust1c> hmk, but in the normal Lambda calculus you can do it, because it wouldnt be turing complete if it wasnt possible, right?
17:15:59 <Cale> That I could believe, but since the STLC is strongly normalising, you clearly can't do everything.
17:16:28 <mmorrow> fpga stuff has been on the back burner the last few weeks until i get some pressing stuff out of the way
17:16:43 <vixey> GNU\caust1c: You can do lots of fun stuff, like metacircular interpreter in untyped lambda calculus :))
17:16:48 <Saizan> GNU\caust1c: right
17:16:53 <mmorrow> roconnor: but BSD code can be incorporated into a closed src app
17:16:54 <GNU\caust1c> ok
17:17:00 <EvilTerran> GNU\caust1c, the simply-typed lambda calculus *isn't* turing-complete, though
17:17:05 <mmorrow> roconnor: which is exactly what i don't want to happen
17:17:15 <EvilTerran> it's a curious result of the finite types restriction
17:17:41 <GNU\caust1c> oh, ok
17:18:03 <vixey> btw I saw the lexicographic induction proof from turing (always reducing the complexity of types when you eval) and also there is one in a book using logical relations.. does anyone know other proofs for this?
17:18:20 <vixey> oh embedding in some stronger calculus you proved normalizing works too
17:18:26 <roconnor> mmorrow: but if you want to get paid for the service of modifying your code, you still get that under a BSD code.  Your first case still stands but with the cavet that I mentioned.
17:18:54 <vixey> so I think that is 3.. but there's hundreds of proofs of pythagoras theorem.. :)
17:19:16 <EvilTerran> GNU\caust1c, see, in order for a function to call itself in lambda calculus (aka \calc), it has to recieve an expression involving itself as a parameter
17:19:33 <Cale> vixey: Structural induction on the derivation of the type.
17:19:49 <vixey> Cale, is that the one in TAPL?
17:19:50 <mmorrow> roconnor: but i don't get paid for all the places my effort make whoever wrote the closed-app money, nor can i benefit from their code in the same way that they benefited from mine
17:19:53 <Cale> vixey: yeah
17:20:00 <GNU\caust1c> yes, thats why i was wondering about it :)
17:20:12 <vixey> I bet that's the simplest one
17:20:26 <Cale> Quite possibly. :)
17:20:50 <EvilTerran> GNU\caust1c, but, in the simply typed \calc, if you try to pass some function (say f, of type A -> B) to itself, you end up with the requirement that A = A -> B
17:21:52 <Cale> It would be really funny if at some point in the future, humanity forgot that it was the lambda calculus and started referring to it as the backslash calculus.
17:21:56 <EvilTerran> = (...((A -> B) -> B) -> ... -> B) -> B -- that being an infinite type
17:21:59 <vixey> haha
17:22:06 <EvilTerran> Cale, sorry, should i be saying "hat calculus"?
17:22:13 <Cale> EvilTerran: hehe, it's all right :)
17:22:28 <roconnor> mmorrow: well, if you BSD your code, you get the option of buying their cool app.  If you GPL your code, you only get the option of buying their crappy app.  The GPL case seems strictly worse (although your first points still stands, with its cavet).
17:22:30 <vixey> how many lambdas do you think have been written
17:22:49 <EvilTerran> i'd rather we started referring to \ as "lambda"; "backslash" is too lengthy
17:23:04 <mmorrow> roconnor: what i'm (personally) saying when i GPL code is "this code is open src, but you can't take my effort, close src it, and make money off of it without contributing back to me in the form of providing me with code which i can in turn benefit from"
17:23:50 <mmorrow> that's impossible to ensure with a BSD license
17:25:32 <EvilTerran> vixey, a great many, although most of them in passages of greek :P
17:25:37 <roconnor> mmorrow: okay.  I suspect you are overvaluing your code with those restrictions, however I don't really know what code you are writing so I can say for sure.
17:25:55 <roconnor> mmorrow: I guess I'm saying that if I tried that argument about my code, I'd be overvaluing it. :)
17:26:07 <Cale> mmorrow: But the GPL does have one issue. They can write closed source software using your code anyway, so long as they don't distribute it.
17:26:15 <mmorrow> roconnor: any remote possibility makes those precautions necessary in my mind
17:26:21 <Cale> (and still make money off of it in other ways)
17:27:12 <daf> Cale: or started calling \ lambda?
17:27:13 <mmorrow> Cale: that's fine by me. as long as their not taking money out of my pocket or using my effort for free to make them money
17:27:18 <mmorrow> *they're
17:27:40 <roconnor> mmorrow: well, there is the cost I mention above to your choice.  You don't get the option of buying better closed source software from them.  And you don't get the option of buying better products from other people who would buy better softeware from them.  For me, that cost is way too much.
17:27:51 <daf> Cale: / could be backlambda
17:27:53 <roconnor> Cale: does that GPL issue apply to GPL 3?
17:28:00 <daf> roconnor: yes
17:28:04 <Cale> roconnor: I believe it ought to apply to all of them.
17:28:10 <roconnor> ok
17:28:40 <daf> the Affero GPL tries to address the problem
17:28:51 <roconnor> mmorrow: BTW, I'm not really trying to change your mind.  Just exploring your motiviations, to see if I'm wrong about how I licence my code.
17:29:07 <mmorrow> roconnor: but i don't want people buying anything from them regardless of its worth unless i get paid for my time and effort as well. this is the crucial point.
17:29:27 <EvilTerran> meanwhile, i'm just happy if someone gets use out of my code
17:30:02 <mmorrow> *buying anything from them which i however indirectly spent time working on some piece of...
17:30:27 <mmorrow> basically, "i don't work for free"
17:30:34 <EvilTerran> if it's many adoring contributors, that's awesome; if it's some big business yoinking it for evil schemes, that may not be awesome, but i'm still not that bothered, really
17:30:39 <glguy> companies make money in lots of ways other than distributing software
17:30:42 <glguy> so that really isn't ensured
17:30:46 <EvilTerran> it's fine; even if it were just me, it's fine
17:30:58 <mmorrow> glguy: hmm, that's very true.
17:31:06 <vixey> seems like the important thing is,  you have access to the source code of the programs you use
17:31:08 <roconnor> mmorrow: well, that depends on how much value you place on being able to purchase better products.  I believe it is more valueable than what I expect you will get paid, or rather I believe it would be more valuable than what I would expect to get paid for my code.
17:31:25 <vixey> isn't that what GPL is more about than "companies should not make money"
17:31:28 <mmorrow> roconnor: i place value on getting a paycheck :)
17:31:45 <roconnor> mmorrow: you place value on other things too.
17:31:52 <glguy> mmorrow, have you been paid for code you released GPL yet?
17:31:59 <roconnor> mmorrow: assuming that you ever buy stuff
17:32:06 <FunctorSalad_> what about the 'what if everyone did it?' argument? :)
17:32:24 <mmorrow> glguy: i haven't really released much code GPL at all really :)
17:32:56 <mmorrow> glguy: so no, but i'm trying to formulate a strategy for the future
17:33:41 <FunctorSalad_> roconnor: everyone else will have to pay for that software based on your BSD'ed code, too
17:34:02 <FunctorSalad_> it might become artificially scarce
17:34:16 <roconnor> FunctorSalad_: I don't understand.  No one is forced to buy anything.
17:34:44 * EvilTerran is too young and idealist to like the GPL; it's too cynical about the intentions of others for my liking :P
17:34:46 <mmorrow> roconnor: i don't think that's the case if open source code is all you write.
17:34:51 <roconnor> My GPL code has been used in a commercial product.  However, they included the source to my software AFAIK.
17:35:07 <Cale> I would release things to the public domain, but I like the disclaimer of warranty that retaining copyright and using the BSD license provides.
17:35:12 <roconnor> I didn't get paid.:)
17:35:33 <vixey> do I have the wrong impression? it seems not really about money at all, but about having access to the source code
17:35:50 <EvilTerran> roconnor, i never thought i'd see that pairing of statement and smiley in the same line O.o
17:35:51 <ivanm> roconnor: oh? which commercial product?
17:35:53 <roconnor> mmorrow: indeed, if you only write open source code, then potentially your code is more valuable.
17:35:54 <FunctorSalad_> roconnor: I was comparing the "everone GPL's code" scenario vs. "everyone involved in free software BSD's code, and companies make closed software from it" scenario
17:36:18 <roconnor> ivanm: eComStation
17:36:31 <ivanm> did they give you a free copy? :p
17:36:36 <mmorrow> roconnor: payment as i'm using it is money /or/ code, where that code would be the code that isn't close srced on account of its inability to be so if it uses your GPLed code in an essential way
17:37:05 <roconnor> ah, my code wasn't used in an essential way.
17:37:41 <ivanm> oh...
17:37:47 <ivanm> would you have wanted a free copy? :p
17:37:56 <mmorrow> roconnor: but they were able to use it without having to make their src available as well?
17:38:42 <ivanm> I wonder.... apparently you're allowed to link to GPL software as long as your product is under a GPL-compatible license...
17:38:48 <roconnor> FunctorSalad_: I still don't quite understand what you are saying, but I'm interested if you want to clairify.
17:38:57 <ivanm> does that mean you can use a BSD wrapper, and then include that wrapper in your proprietary product?
17:39:11 <roconnor> ivanm: I think they might have offered a free copy at some point.  I could probably get one out of them.
17:40:03 <ivanm> ebay! :p
17:40:07 <roconnor> mmorrow: It falls into a pretty grey area about putting my code, which is installed separately after their code is installed.
17:40:21 <mmorrow> roconnor: ah, i see
17:41:32 <roconnor> mmorrow: and their code is an operating system, so the separate install falls under the OS exception for linking purposes.
17:42:04 <mmorrow> interesting. do you have a link for this os?
17:42:13 <roconnor> http://www.ecomstation.com/
17:42:21 <lambdabot> Title: eComStation :: an OEM Upgrade to IBM OS/2. Right for today's PC hardware
17:42:23 <roconnor> maybe I should just claify that ecomstation is an OS/2 derivative.
17:42:43 <roconnor> and I wrote a multimedia extension for playing MP3, OGG, FLAC.
17:42:54 <roconnor> which plugs into OS/2's media architecture.
17:42:55 <thoughtpolice> mmorrow: how did cayenne cabalisation go? I checked out a book on FP at my library the other day and it actually has a chapter over it and I was wanting to try it :]
17:43:03 <ddarius> OS/2... Wow.
17:43:16 <roconnor> which is only GPL because I used a GPL library to do the MP3 decoding
17:43:40 <roconnor> I guess the OGG decoder is under whatever the vorbis decoder license is.
17:43:46 <roconnor> etc.
17:44:51 <roconnor> and there are patent issues. ... Actually I guess those issues have now expired.
17:45:24 <mmorrow> thoughtpolice: gah, i was stymied and half quit/have been super busy with other things. i really need to finish that though. i think now, after making an attempt at a super complex Setup.lhs, i'm going to scrap that and use the original Makefiles and Distribution.Make (so it won't be installed in a cabal-pkg dir location, but it'll at least be installable with cabal)
17:45:49 <vixey> mmorrow :Doesn't AGda 2 superceed cayenne ?
17:46:05 <enolan> @seen lemmih
17:46:06 <lambdabot> Last time I saw lemmih was when I left ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-hac07, #
17:46:06 <lambdabot> haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr and #haskell.it 2m 2d 2h 3m 46s ago, and .
17:47:04 <mmorrow> i'm not sure exactly the relation, but i've been meaning to find that out
17:47:19 <mmorrow> (i don't know much of anything about agda)
17:47:33 <vixey> oh
17:47:39 <vixey> mmorrow: I don't know much about cayenne :p
17:47:45 <mmorrow> heh
17:48:12 <mmorrow> i'm learning about cayenne, but by no means would say i know a lot
17:48:34 <Saizan> cayenne is turing-complete right?
17:48:39 <mmorrow> yes
17:48:57 <mmorrow> arbitrary recursion, etc
17:49:04 <mmorrow> IO
17:49:14 <vixey> I think you can have general recursion and IO in Agda 2 though
17:49:25 <vixey> (if you want it.. who would want it thouhgh?)
17:49:28 <jsn> i can use Parsec to write a string parser, right?
17:49:30 <mmorrow> can you do IO in agda?
17:49:40 <jsn> i mean, to parse a list of strings instead of a list of chars?
17:49:48 <geezusfreeek> mmorrow: haskell is agda's ffi :)
17:50:00 <mmorrow> geezusfreeek: heh, cayenne's as well
17:50:13 <Saizan> jsn: yes, it's polymorphic inthe token type
17:50:27 <mmorrow> cayenne actually can output (1) haskell (2) lml (3) agda
17:51:04 <mmorrow> the haskell it spits out is great ;)
17:51:29 <mmorrow> every (sub)expression is wrapped in unsafeCoerce :)
17:51:33 <vixey> lml cool
17:51:40 <jsn> mmorrow: LML is what?
17:51:45 <mmorrow> lazyml
17:51:50 <jsn> oh....
17:51:50 <roconnor> unsafeCoerce is unsafe.
17:52:01 <vixey> I always wonder why tey don't output _untyped_ lamda terms
17:52:05 <lispy> Suppose agda outputs proven correct code, but it outputs haskell which isn't proven.  What does that mean?
17:52:10 <mmorrow> roconnor: not if you've statically verified correctness in another type system
17:52:15 <roconnor> The only safe use of unsafeCoerce I've seen is for the identity function.
17:52:18 <jsn> roconnor: unsafeCat is unsaaaaaaaaaaaaaaaaaaaaaaaaaafe :)
17:52:22 <mmorrow> and it's no more unsafe than asm
17:52:22 <vixey> lispy, means the haskell code doesn't work
17:52:32 <roconnor> mmorrow: GHC does all sorts of unsafe things if your type doesn't match the value.
17:52:41 <lispy> vixey: I mean, Haskell the language isn't proven sound
17:52:47 <lispy> vixey: unlike Agda
17:52:49 <roconnor> as I have found out from extracting Coq to Haskell
17:52:58 <vixey> lispy, oh since agda is implemented in haskell
17:53:01 <lispy> vixey: so when you output some Haskell, is your resulting program sound or not?
17:53:11 <lispy> vixey: no, I mean, you extract Haskell from an agda program
17:53:17 <roconnor> I think perhaps you unsafeCasting to/from GHC.Any might maaaaaaaaaaybe be okay.
17:53:24 <lispy> vixey: suppose someone rewrite agda in agda so your implemenation was sound
17:53:26 <jsn> lispy: don't they all emit assembly?
17:53:27 <roconnor> but I wouldn't stake too much on it.
17:53:33 <mmorrow> roconnor: i've been meaning to ask augustss the particulars of how he know the haskell code won't segfault, but i'm certain that's a guarantee
17:53:37 <jsn> and assembly is unsound, right?
17:53:48 <vixey> jsn, not TAL
17:53:53 <vixey> ?go typed assembly language
17:53:55 <lambdabot> http://www.cs.cornell.edu/talc/
17:53:56 <roconnor> mmorrow: certain what is a guarantee?
17:53:56 <lambdabot> Title: Typed Assembly Language
17:54:05 <mmorrow> i mean, augustss has written at least one haskell compiler himself..
17:54:06 <vixey> I think
17:54:12 <roconnor> mmorrow: I've gotten extracted Coq code proven correct to segfault.
17:54:15 <lispy> jsn: I think the semantics of assembly could be proven sound even if you consider it untype.  But in the considering it untyped case, you're coming from a type sound language
17:54:16 <jsn> vixey: okay, but x86 assembly, that is definitely unsound?
17:54:18 <Saya> So whats the fancy feature(s) in agda that makes it even better?
17:54:34 <roconnor> mmorrow: when compiled with -O2 or something.
17:54:37 <jsn> lispy: so, are you saying, it doesn't matter?
17:54:39 <mmorrow> roconnor: a guarantee that the haskell code output by cayenne is just as "correct" as the asm output by ghc
17:55:08 <mmorrow> roconnor: cayenne's entire test suit worked for me via ghc -O2
17:55:14 <vixey> lispy, agda must assume some semantics of haskell to compile to it.. if your implementation has different semantics than the modeled one.. you know what happens
17:55:22 <vixey> it breaks
17:55:23 <roconnor> mmorrow: you must have got lucky.
17:55:27 <lispy> jsn: Well, if you're in a stronger type system and you extra sound code then as long as your extraction is proven correct the output should be safe.  Even if the target language can't gaurantee it
17:55:49 <lispy> jsn: I mean, extract sound code not extra
17:55:56 <mmorrow> roconnor: and ghc uses unsafeCoerce all the time in Core
17:56:00 <jsn> lispy: is the Cayenne to Haskell case different somehow?
17:56:14 <roconnor> mmorrow: does it cast function types to non-function types, and back?
17:56:17 <lispy> jsn: I know less about Cayenne, so I didn't go there
17:56:23 <mmorrow> roconnor: newtypes for instance require coercions
17:56:27 <mmorrow> for infinite types
17:56:41 <mmorrow> roconnor: GHC.Exts.Any
17:56:53 <mmorrow> is essential when unsafeCoercing
17:56:55 <roconnor> oh, they cast to GHC.Exts.Any?
17:57:01 <vixey> Saya, better than what?
17:57:05 <roconnor> do they do that with the cyanne extractions?
17:57:14 <mmorrow> roconnor: i'll paste some relevant code...
17:57:28 <roconnor> Coq wasn't using GHC.Ext.Any.
17:57:47 <lispy> roconnor: some generate code I saw from cayenne even coerced values that were already the right type :)
17:58:12 <roconnor> lispy: using unsafeCoerce is safe for the id function.
17:58:30 <roconnor> where the types of the value on either side are the same.
17:58:42 <roconnor> ... and plausibly safe to cast to and from GHC.Ext.Any.
17:58:49 <mmorrow> lispy, roconnor: yeah, cayenne verifies correctness in its type system, then outputs haskell with "type checking turned off"
17:59:00 <lispy> heh, nice
17:59:22 <roconnor> lispy: but if you cast functions to (), the optimiser will do bad things.
17:59:50 <Saya> Vixey, better than haskell
17:59:59 <mmorrow> (and btw cayenne doesn't use GHC.Exts.Any, but an equivalent Any)
18:00:36 <mmorrow> oh yeah, i almost forgot
18:00:40 <roconnor> mmorrow: what is the equivalent?
18:00:48 <vixey> Saya, it's totally _different_, but the types are much more expressive that you can actually describe the meaning of things in them. which is what I like
18:00:58 <mmorrow> this dir has haddocks for cayenne and module depgraphs rendered with graphviz
18:00:59 <mmorrow> http://code.haskell.org/~morrow/cayenne/cayenne.tred.png
18:01:07 <mmorrow> http://code.haskell.org/~morrow/cayenne        -- this dir
18:01:08 <lambdabot> Title: Index of /~morrow/cayenne
18:01:25 <mmorrow> haddocks: http://code.haskell.org/~morrow/cayenne/haddock/
18:01:28 <lambdabot> Title: cayenne-0.0: Cayenne
18:01:48 <vixey> Saya, so you can write out the syntax of regex for example, with the semantics (which set of terms does it match) in the types
18:01:51 <mmorrow> yeah, so making it installable under cabal as a lib was easy
18:02:02 <mmorrow> it's the executable that's a pain
18:02:18 <Saya> Oh seems good indeed, ill check it out!
18:02:23 <vixey> Saya, whereas in haskell you have  data Re = Dot | Star | Seq Re Re | ...
18:02:29 <mmorrow> (since among other things it has to get built by ghc, then build it's libs with itself
18:02:31 <vixey> Saya, which says nothing about what a 'Re' is :)
18:02:31 <mmorrow> )
18:03:21 <jsn> vixey: when you say, write out the syntax, you don't actually mean    /(.+)/    and stuff like that, do you?
18:03:27 <Saya> vixey, so what more would it tell in agda?
18:04:57 <mmorrow> roconnor: so this paste has a .cy from the testsuite, and the last paste on this page is the haskell module PTS.hs that has the definitions of interest:
18:04:59 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=47
18:05:33 <vixey> Saya, well I did this in Coq, but it could be like Dot : char -> Re char | Seq : Re x -> Re y -> Re (x ++ y)
18:05:49 <mmorrow> here's the .hs it outputs for that .cy http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=47#a49
18:05:58 <mmorrow> cast x = unsafeCoerce# x
18:06:45 <Saya> yeah im reading a little thing on it so you can specify a lot more properties for types and mix types and values, looks neat
18:06:57 <roconnor> mmorrow: I cannot tell which instances of case are being used.
18:07:05 <roconnor> s/case/cast/
18:07:39 <lispy> vixey: you could do that encoding in haskell if you allowed GADTs
18:07:48 <vixey> lispy, no you couldn't
18:08:10 <mmorrow> heh, it'd be interesting to pull out pieces of the gen hs and look at some of the subexpressions types before unsafeCoerce
18:09:11 <TomMD> ?seen dons
18:09:11 <lambdabot> dons is in #darcs, #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 1h 46m 23s ago.
18:09:22 <geezusfreeek> lispy: i think he means where "char", "x", and "y" are values, not types
18:09:32 <geezusfreeek> *she
18:09:35 <vixey> yes
18:10:05 <lispy> data Re x where Dot :: Char -> Re Char; Seq :: Re x -> Re y -> Re (x,y) -- your x ++ y I don't know the meaning of so I just used a tuple here
18:10:12 <lispy> ah
18:10:16 <Saya> "    In the same way as functions are not allowed to crash, they must also
18:10:18 <Saya> be terminating. ", hmm yeah good for proofs but doesnt it stop a class of programs here
18:10:19 <dons> hey TomMD
18:10:28 <TomMD> hey dons
18:10:42 <vixey> Saya: yeah.. all these great programs that always give the right answer but never terminate :D
18:10:48 <lispy> Saya: yeah, ones that evaluate to bottom :)
18:10:51 <TomMD> I was just digging around pureMD5 in prep for a possible stab at a pureSHA and pureAES series of packages
18:11:05 <dons> oh, goody. yes, sha has come up a bit lately
18:11:12 <TomMD> dons: So before I get started with that, I wanted to improve the MD5 performance to within shooting distance of C
18:11:33 <dons> ok.
18:11:44 <TomMD> dons: To that end, I profiled MD5 on a recent GHC and found a full third of the time is in one function - pulling Word32's from a bytestring.
18:11:44 <roconnor> TomMD: what is pureSHA?
18:11:52 <TomMD> SHA2 all in Haskell
18:12:07 <roconnor> TomMD: that exists in the crypto lib (I wrote it)
18:12:11 <TomMD> dons: So, I'm wondering if you have any ideas for an efficent pull
18:12:18 <mmorrow> i have a javascript sha laying around somewhere..
18:12:31 <dons> mm.
18:12:31 <geezusfreeek> Saya: there is also a notion of codata, which gives back a lot of those classes of programs i think you are talking about
18:12:33 <TomMD> roconnor: Works on bytestrings?
18:12:37 <dons> TomMD: using Data.Binary ?
18:12:38 <TomMD> roconnor: Fast?
18:12:38 <mmorrow> (and md5, aes (i think), and a randgen)
18:12:46 <TomMD> dons: That is actually even slower
18:12:48 <roconnor> TomMD, nope and nope :)
18:12:58 <roconnor> BTW, there was some thread I found talking about how slow the crypto hash functions were.  People speculated about what was slow, but no one profiled.
18:13:00 <dons> TomMD: there's very efficient low level code in Data.Binary for pulling things out of strict bytestrings
18:13:03 <TomMD> dons: or was
18:13:05 <dons> so you might be able to look at that.
18:13:16 <TomMD> dons: Will do.
18:13:17 <roconnor> I haven't profiled either, but I blame haskell's bit shifting operations, which have bitten me before.
18:13:25 <Saya> "if_then_else_ : {A : Set} -> Bool -> A -> A -> A
18:13:27 <Saya> if true then x else y = x
18:13:29 <Saya> if false then x else y = y"
18:13:30 <mmorrow> unsafeShiftL#
18:13:30 <Saya> cooooooooooooool
18:13:32 <Saya> geezusfreeek, nice so you basically know your program works at compile time with all this stuff
18:13:34 <dons> roconnor: ah yes, but we talked about that :)
18:13:38 <roconnor> dons says that the bitshifting code is compiled to faster code now, but I haven't checked.
18:13:42 <dons> roconnor: your experience was 2 or 3 compilers ago.
18:13:42 <TomMD> roconnor: If it isn't packed, I'd blame lists being high overhead.
18:13:59 <dons> roconnor: remember when we worked through an example on hpaste, about 6 months ago?
18:14:10 * vixey &
18:14:11 <TomMD> A purist friend of mine (HOL4 hacker) was shocked when I told him a haskell implemtation using [Word8] would be terribly slow.
18:14:17 <mmorrow> err, uncheckShiftL#
18:14:23 <roconnor> dons: Oh, did we look at the newly generated core code?
18:14:26 <dons> TomMD: but what does he think the [] in [Word8] was ?
18:14:28 <dons> roconnor: yeah.
18:14:33 <roconnor> oh good.
18:14:38 <dons> roconnor: remember how the test was being inlined, and removed?
18:14:45 <roconnor> Who knows, maybe SHA is fast now. :)
18:14:46 <mmorrow> uncheckedShiftL# -- finally
18:14:53 <dons> due to the new implementations for bit shifting that expose the innards better
18:15:12 <TomMD> dons: He knew, just thought it would do some smart strictness/packing for you.
18:15:25 <mmorrow> dons: so then uncheckShift*# isn't necessary anymore? or in certain situations?
18:15:35 <TomMD> dons: He is a math nut and not really a programmer.
18:15:36 <dons> TomMD: interesting. we do get fusion now , of course.
18:15:43 <dons> mmorrow: when the shift offset is known statically
18:15:48 <mmorrow> hmm
18:15:57 <Philippa> TomMD: the sort of stuff you can get in an ML?
18:15:57 <roconnor> TomMD: so I don't know how fast the crypto code is now.  You may want to check it out first to see how fast it is now.
18:15:57 <dons> TomMD: look in Data.Binary.Get (near the bottom)
18:15:59 <mmorrow> ah, ok. that makes sense
18:16:04 <roconnor> I bet it is way faster than 3 years ago.
18:16:22 <roconnor> (even though the code hasn't changed)
18:16:38 <roconnor> (which is the way it should be :)
18:18:13 <TomMD> 1philippa: Yes, he mentioned LISP can do it - I have no knowledge of LISP / compilers for it.
18:18:39 <ushdf> use clisp for sanity
18:18:48 <TomMD> roconnor: I'm planning on slowly developing bytestring versions of most things in crypto - eventually I hope to replace it entirely.
18:18:50 <ushdf> use scheme for precision ;)
18:19:03 <ushdf> or elegance?
18:20:01 <roconnor> TomMD: lazy bytestrings?
18:20:28 <mmorrow> TomMD: how does (does it at all?) crypto deal with scrubbing memory that had keys in it at some point?
18:20:29 <TomMD> roconnor: yep
18:20:54 <TomMD> mmorrow: I have only built the one hash alg so far.
18:21:05 <TomMD> mmorrow: it would require compiler support in general
18:21:14 <TomMD> only needing done when freeing though.
18:21:17 <mmorrow> TomMD: or manual memory management
18:21:34 <mmorrow> mallocBytes 1024 :: Ptr Word8
18:21:46 <mmorrow> heh
18:21:52 <mmorrow> IO (Ptr Word8) ;)
18:22:24 <TomMD> mmorrow: I'd ignore that in a Haskell program - your paranoia may differ.
18:22:38 <mmorrow> :)
18:23:17 <TomMD> Either way, you need compiler support is the point.
18:23:39 <mmorrow> how is manual memory management compiler support?
18:24:27 <mmorrow> i guess you could also  foreign import ccall unsafe "malloc" c_malloc :: ...
18:25:22 * mmorrow recently fully realized just how easy it is to import C functions :)
18:26:08 <TomMD> mmorrow: If the compiler copies your variables for GC and you worry about copies of your variables I can't see how, when programming in pure Haskell (no Foreign.*), you can stay safe.
18:27:07 <mmorrow> ah, i'm depending of Foreign.* and {read,write}Word*OffAddr in the above
18:27:45 <TomMD> dons: Data.Binary causes a 10x slowdown. I look into it more tomorrow.
18:28:17 <mmorrow> so i guess, depending on the ability to completely remove the posibility of the compiler messing with stuff
18:28:53 <mmorrow> (or the gc)
18:29:57 <dons> TomMD: wow.
18:30:10 <dons> TomMD: i'd love a test case
18:30:23 <TomMD> one minute
18:31:44 <TomMD> dons : http://hpaste.org/11558
18:31:55 <TomMD> Perhaps I should use Data.Binary.Strict.
18:32:00 <TomMD> Would it matter?
18:32:39 <dons> mm. well, you might be able to avoid the wrapper constructors
18:32:52 <TomMD> I thought the RULES pragma should match (fromChunks . toChunks) and [bs] with case lst of ; (a:as) -> ...
18:33:09 <dons> oh, those are quite different pieces of code
18:33:12 <dons> in the hpaste :)
18:33:17 <TomMD> yep
18:33:20 <dons> one is as low level as you can get..
18:33:40 <dons> getWord32host ?
18:33:59 <TomMD> And they actually differ in result... thought I don't think that effects this performance discussion.
18:34:13 <dons> TomMD: well, are you on a be host?
18:34:24 <dons> if not, then it has to shift things, so probably you'd test getWord32host
18:34:27 <TomMD> dons: I figured it was bounds checking and that was costing me.
18:34:29 <dons> however, the fromChunks might be the issue
18:34:32 <TomMD> dons: No, AMD64
18:34:34 <dons> useful test case.
18:39:26 <sereven> uh oh, private msgs straight to lambdabot don't break infinite evals, > repeat "uh oh" really evaluates. Does closing the connection terminate it?
18:40:33 <kpreid> there is no connection
18:40:59 <sereven> well, the chat window.. so I started a process that's still running, then.
18:44:32 <kpreid> sereven: no, that is entirely within your client, irc and lambdabot have no idea that it is open
18:45:04 <sereven> so just plain don't ever do that. Or lambdabot's smart enough to sort it out?
18:48:21 <kpreid> sereven: lambdabot is fine and not wedged at all
18:52:05 <sereven> cool... It was a bit of a surprise after seeing all the [blah ... here
18:58:17 * shapr boings
18:58:53 <shapr> whee!
18:59:32 <Nafai> Hi shapr!
18:59:36 <Nafai> Hi byorgey!
18:59:45 <tromp__> hi, Shae
19:01:35 <BMeph> Hi, Pr
19:03:07 * araujo catches the boinging shapr with a lambda web
19:03:46 <shapr> hoi tromp__ !
19:03:52 <shapr> tromp__: When are you coming to Boston?
19:04:03 * shapr is caught in the lambda web!
19:04:12 * shapr tries to unzip the web data structure.
19:04:44 * shapr throws lambda lemons at BMeph 
19:05:15 <shapr> Maybe it'd be easier if I went ahead and built ghc 6.10 before I bootstrap cabal 1.6 and all that jazz?
19:06:01 <shapr> Does anyone know where and how deeply the 4-byte alignment is baked into ghc? GHC doesn't seem very SIMD friendly.
19:06:24 <araujo> hah
19:07:05 * BMeph finishes collectiong the lambda lemons and makes Electric Lambda Lemonade!
19:08:09 <tromp__> i went to boston late last year
19:08:12 * Raynes Holds out a cut
19:08:18 <Raynes> Cup*
19:08:28 <tromp__> wont make it this year:(
19:08:35 <augustss> @seen mmorrow
19:08:36 <lambdabot> I saw mmorrow leaving #perl6, #darcs, #ghc and #haskell 31m 2s ago, and .
19:09:07 <shapr> aww
19:09:19 <shapr> tromp__: You're in Rhode Island, yeah?
19:09:30 <tromp__> Rhode->Long
19:09:33 <shapr> oh right
19:09:33 <shapr> dang
19:09:51 <shapr> Hm, 4.5 hour drive.
19:10:02 <shapr> Probably a bit too far for a Saturday Haskell meeting .
19:10:04 <tromp__> yep, take ferry to port jeff
19:11:40 <shapr> tromp__: Done any fun code lately?
19:12:00 <tromp__> Go Rules in Haskell
19:12:08 <shapr> oh neat
19:12:29 <tromp__> halfway down http://homepages.cwi.nl/~tromp/go.html
19:12:41 <lambdabot> Title: John's Go Page
19:12:53 <tromp__> looking forward to your suggestions for improvement:)
19:15:50 <shapr> tromp__: nifty!
19:16:16 * Nafai wants to do fun coding!
19:20:42 <byorgey> tromp__: very cool!
19:21:06 <byorgey> hey Nafai
19:21:51 <Nafai> How's school?
19:21:58 <tromp__> thanks, Brent
19:22:47 <tromp__> of course, efficiency was not a top concern:)
19:23:36 <tromp__> would take hours to score a real 19x19 game (if not days)
19:24:28 <dancor> is there a simple way to concat several (GenParser a st [a]).  i want many but then to concat the results..
19:25:20 <dancor> oh this is easier than i thought
19:26:39 <byorgey> tromp__: yeah, that's ok, it's neat as a specification though
19:26:46 <dancor> (fmap concat $) works just fine
19:27:25 <byorgey> Nafai: school's great!
19:27:48 <byorgey> I can't believe they are paying me just to learn all this totally sweet stuff =)
19:29:11 <Nafai> byorgey: Yeah, that rocks!
19:29:39 <byorgey> Nafai: how are you?
19:29:49 <Nafai> Not too bad
19:29:50 <x6d65> Is there a convenient way to do some operation on an infinite list until some condition is met?
19:29:55 <Nafai> Anxiously awaiting to hear about a job
19:30:45 <Nafai> Slowly progressing in my Haskell knowledge
19:32:09 <Nafai> It's coming slightly more naturally to me
19:32:59 <byorgey> Nafai: excellent =)
19:33:03 <byorgey> good luck with the job!
19:33:10 <tromp__> x6d65: what would be its type?
19:33:13 <Nafai> Thanks!
19:33:36 <byorgey> x6d65: well, starting simple, there's takeWhile
19:33:50 <tromp__> you prolly want to use span for that
19:33:51 <byorgey> > takeWhile (< 5) [1,2,4,1,0,7,4,2]
19:33:52 <lambdabot>   [1,2,4,1,0]
19:34:08 <tromp__> and map over the fst part
19:34:13 <byorgey> x6d65: what do you mean by 'do some operation'?
19:34:52 <x6d65> tromp__: The type would probably be similar to foldr.
19:35:34 <byorgey> x6d65: maybe do a scanl and do a takeWhile over that?
19:35:51 <byorgey> > takeWhile (<100) $ scanl (+) 0 [1..]
19:35:53 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55,66,78,91]
19:36:27 <byorgey> that forms successive sums of prefixes of the list until the sums reach 100.
19:36:57 <byorgey> scanl is like foldl but it gives a list of intermediate accumulator values.
19:37:35 <electronx> FatalBot
19:37:41 <x6d65> byorgey: I just want to sum a prefix of an infinite list one element at a time, with an accumulator.
19:39:08 <byorgey> x6d65: right, that's what scanl does.
19:39:17 <electronx> mother fuck....
19:39:38 <byorgey> scanl actually gives you a list of the partially accumulated values so you can do more processing with them
19:39:43 <shapr> What's up with FatalBot?
19:40:11 <byorgey> hi electronx, here to learn some Haskell?
19:40:23 <electronx> yo
19:40:26 <shapr> y0
19:40:36 <BMeph> j0
19:40:39 <electronx> my bot keeps dieing
19:40:47 <electronx> little prick
19:40:52 <electronx> :)
19:41:12 <electronx> lambdabot replacement
19:41:23 <ushdf> > "hello"
19:41:24 <lambdabot>   "hello"
19:41:27 <electronx> or just another cool bot
19:41:36 <ushdf> > "echo"
19:41:37 <lambdabot>   "echo"
19:41:40 <ushdf> > "stop copying me"
19:41:41 <lambdabot>   "stop copying me"
19:41:45 <ushdf> > "i mean it, this isn't funny"
19:41:47 <lambdabot>   "i mean it, this isn't funny"
19:41:47 <ddarius> electronx: Don't have bots join public channels without request.
19:41:54 <ushdf> > "you little shit"
19:41:55 <lambdabot>   "you little shit"
19:41:58 <ushdf> > "i'm going to kill you"
19:41:59 <lambdabot>   "i'm going to kill you"
19:42:02 * ushdf strangles lambdabot
19:42:03 --- mode: ChanServ set +o shapr
19:42:08 <shapr> ushdf: hey
19:42:08 <ushdf> i'm done!
19:42:15 * ushdf runs away
19:42:50 <shapr> ushdf: I like it when people are nice :-)
19:42:55 <shapr> electronx: Don't you?
19:43:05 --- mode: shapr set +o andyjgill
19:43:10 * shapr spreads the power!
19:43:16 <ushdf> i am being nice
19:43:22 <shapr> Spiffy!
19:43:23 <ushdf> my acting is for your entertainment
19:43:25 --- mode: shapr set -o shapr
19:43:29 <ushdf> lambdabots feelings aren't hurt ;)
19:43:30 <electronx> hey no need to get angry
19:43:37 <electronx> i'm not logging
19:43:42 <electronx> just testing
19:43:52 <shapr> electronx: I'm not angry, I just prefer a particular emotional temperature in my communities.
19:44:36 <electronx> shapr: can i have a bot in here to complement lambdabot
19:44:49 <shapr> why?
19:44:56 <chessguy> @get-slap
19:44:56 <lambdabot> shapr!!
19:44:59 <ushdf> i have a great bot written in python
19:45:02 <ushdf> i bet he would work in here
19:45:03 <shapr> hiya chessguy!
19:45:09 <chessguy> salutations!
19:45:15 <shapr> ushdf: Personally, I'd prefer you write lambdabot plugins :-)
19:45:21 <electronx> hehe
19:45:32 <shapr> We've already got a bot...
19:45:32 * Samy wants to write lambdabot plugins
19:45:42 <Samy> But I'm scared to use her on my own machines. :)
19:45:47 <Samy> Gold digger.
19:45:51 <shapr> If you've written your own bot in Haskell and you want to show it off for a few minutes, I think that's cool.
19:45:56 <shapr> Samy: c'mon, it'll be fun!
19:47:36 <electronx> shapr: ya that it
19:47:40 <shapr> k
19:47:42 <electronx> damn it
19:47:49 <shapr> Hey man, watch ya language.
19:47:54 <electronx> :)
19:47:56 <shapr> This is a family channel!
19:48:10 <shapr> At least, I keep hoping I'll meet some nice woman here who wants a family and...
19:48:13 <shapr> Well you know what I mean.
19:49:15 <ushdf> writing a haskell bot
19:49:23 <ushdf> lisp would make more sense
19:49:27 <ushdf> in that case
19:49:30 <shapr> ushdf: Do it!
19:49:30 <ushdf> can i still show it off in here ;)
19:49:50 <ushdf> i'll make him intelligent, too
19:49:51 <shapr> ushdf: Why don't you write up a comparison of lambdabot and the lisp robot once you've written in?
19:49:54 <shapr> I'd find that interesting.
19:50:02 <ushdf> i'm into AI ;)
19:50:08 <shapr> Cool!
19:50:35 <ddarius> electronx: There are plenty of other channels you can test your bot on.
19:50:48 <sbahra> Like #haskell-blah
19:50:51 * sbahra hides
19:51:00 <shapr> sbahra: Nothing interesting ever happens on #haskell-blah
19:51:03 <ddarius> #haskell-overflow would be appropriate
19:52:59 <ivanm> shapr: so why does it exist then?
19:53:16 <shapr> ivanm: Um, maybe some interesting things happen there.
19:54:07 <ivanm> but you just said nothing interesting happens...
19:54:14 <ivanm> so which statement was incorrect? :p
19:54:23 <ddarius> There is no #haskell-blah
19:54:41 <shapr> There is no Haskell Secret Underground.
19:54:49 <ivanm> ddarius: just like the lack of spoons?
19:54:56 <ddarius> Nothing like that.
19:55:30 <electronx> FatalBot
19:58:02 <electronx> FatalBot
19:58:17 <ivanm> electronx: is saying its name _meant_ to kill it?
19:58:23 <electronx> lol
19:58:24 <electronx> no
19:59:33 <electronx> FatalBot
19:59:45 <ivanm> electronx: try not saying its name ;-)
19:59:50 <ivanm> see if it hangs around longer
19:59:50 <electronx> lol
20:00:21 <ddarius> Try saying it's name in #haskell-overflow, maybe it will hang around longer in there.
20:00:30 <x6d65> byorgey: So if I want to sum, say, the first five million elements of an infinite list, how should I do that?
20:00:34 <ivanm> ddarius: a subtle hint? :p
20:00:53 <ivanm> x6d65: sum . take 5e6
20:01:16 <ivanm> I take it back, that won't work
20:01:21 <ivanm> @type 5e6
20:01:22 <lambdabot> forall t. (Fractional t) => t
20:01:23 <x6d65> Nope.
20:01:31 <ivanm> > maxBound :: Int
20:01:32 <lambdabot>   9223372036854775807
20:01:43 <ivanm> is lambdabot running on a 64bit machine?
20:01:53 <ivanm> x6d65: sum . take 5000000
20:02:05 <sjanssen> ivanm: clearly
20:02:09 <x6d65> stack overflow
20:02:22 <ivanm> x6d65: then the numbers are too big
20:02:30 <x6d65> They're 1s.
20:02:30 <ivanm> what are you doing with that sum?
20:02:35 <ivanm> oh?
20:02:42 <sjanssen> x6d65: compile with ghc -O
20:02:50 <ivanm> > sum . take 5000000 $ repeat 1
20:02:53 <lambdabot>   * Exception: stack overflow
20:02:54 <x6d65> This is interpreted.
20:02:56 <ivanm> heh
20:02:58 <x6d65> ghci
20:03:08 <ivanm> yeah, interpreted tries to create the whole list first IIRC
20:03:16 <ivanm> with -O it will do alement-at-a-time stuff
20:03:16 <sjanssen> ivanm: no
20:03:32 <sjanssen> the difference is that sum is lazy without -O
20:03:43 <ivanm> ahhh, yes
20:03:47 <ivanm> a large thunk
20:03:49 <sjanssen> x6d65: compile with ghc -O, or write a strict version of sum
20:03:59 <sjanssen> sum xs = foldl' (+) 0 xs -- will work
20:04:04 <ddarius> > foldl' (+) 0 . take 5000000 $ repeat 1
20:04:05 <lambdabot>   5000000
20:04:08 <ivanm> @src sum
20:04:09 <lambdabot> sum = foldl (+) 0
20:04:23 <ivanm> sjanssen: any particular reason sum _doesn't_ use foldl' by default?
20:04:29 <ivanm> cross-compiler compatability?
20:04:29 <x6d65> What does the strict version do?
20:04:38 <ddarius> ivanm: The Report defines it as above.
20:04:43 <ivanm> ahhhhh
20:04:53 <ivanm> x6d65: actually adds the elements as it gets them
20:05:00 <sjanssen> x6d65: it evaluates the accumulator as the list is consumed
20:05:11 <ivanm> whereas the lazy version goes "I should add this on.... shmeh, I'll wait till I absolutely have to" :p
20:05:37 <sjanssen> x6d65: the lazy version just creates a giant ((1 + 1) ... + 1) thunked expression which is then evaluated at the end
20:05:47 <xmux> Does -O help a lot?
20:06:00 <ivanm> yup
20:06:03 <sjanssen> xmux: yes, ghc -O is pretty amazing
20:06:06 <ddarius> xmux: -O (or higher) causes the strictness analyzer to run.
20:06:07 <ivanm> -O2 helps more ;-)
20:06:20 <xmux> It's good to know that there is a difference between behavior in ghci and the compiled version too
20:06:50 <x6d65> And the (take 5000000) doesn't build a list with 5,000,000 elements?
20:06:50 <xmux> I've been learning haskell by doing project euler problems and I've seen some strange behavior that can probably be explained by this
20:07:16 <ivanm> x6d65: nope
20:07:30 <x6d65> Because it will be lazy, but the strict foldl will keep evaluating the thunk?
20:07:34 <sjanssen> x6d65: that depends on how one consumes it
20:07:39 <electronx> FatalBot
20:07:56 <electronx> hey it doesn't dir
20:07:59 <electronx> die*
20:08:25 <ivanm> FatalBot
20:08:31 <ivanm> hmmmm.... _still_ doesn't die
20:08:36 <ivanm> FatalBot: will you die already?
20:09:33 <xmux> There is a lot of information scattered in many places about haskell performance optimizations, but I've never seen one complete reference.  Does it exist?
20:10:04 <electronx> lol
20:10:06 <sjanssen> xmux: http://www.haskell.org/haskellwiki/Performance
20:10:07 <lambdabot> Title: Performance - HaskellWiki
20:10:12 <ivanm> xmux: sure it does, in the repository of impossible things
20:10:15 <ivanm> ;-)
20:10:27 <x6d65> Thanks everyone for the clarifications. Is the last thing I said approximately right?
20:10:44 <sjanssen> x6d65: yes
20:11:03 <sjanssen> x6d65: both the strict and lazy versions of foldl only demand one list cell at a time
20:11:31 <electronx> FatalBot: QUIT
20:11:34 <xmux> As far as I can see that wiki page is just another incomplete scattered source of information
20:11:40 <sleven> is it true that foldl and foldl1 are kind of bad and i shoud stick to foldr and foldl' ?
20:11:49 <sjanssen> sleven: yes, it is true
20:11:53 <xmux> oh nevermind, I missed all the links
20:12:22 <xmux> This actually looks really helpful
20:12:24 <sjanssen> foldl is almost never useful, I can only think of one valid use off the top of my head
20:12:46 <electronx> can someone tell my bot to quit
20:12:53 <electronx> see if he listens to you
20:13:11 --- mode: ChanServ set +o sjanssen
20:13:19 --- kick: FatalBot was kicked by sjanssen (sjanssen)
20:13:28 <sjanssen> electronx: I told him to leave :)
20:13:38 --- mode: ChanServ set +o allbery_b
20:13:39 <ddarius> This is why you don't test bots in public channels.
20:13:58 <ddarius> sjanssen: The one use where it's equivalent to foldl'
20:14:01 <electronx> hehe
20:14:01 <sjanssen> allbery_b: I don't mean to actually ban the bot
20:14:14 <electronx> cool it woks
20:14:19 <electronx> works*
20:14:33 <sjanssen> electronx: but you should turn off auto rejoin if you want the bot to stay.  If there is ever a problem, we will be forced to ban it
20:14:38 <allbery_b> unless necessary?
20:15:14 --- mode: allbery_b set -o allbery_b
20:15:14 <electronx> yeah i'll turn that off
20:15:27 <electronx> FatalBot: uptime
20:15:27 <FatalBot> 3 minute(s), 5 second(s)
20:15:37 <sjanssen> electronx: by the way, you do know there are public logs of #haskell in several places, right?
20:15:37 <electronx> botcheck
20:15:38 <FatalBot> Logger v0.1.0
20:15:40 <shapr> electronx: Ok, enough demonstrating FatalBot.
20:15:48 <electronx> lol
20:15:49 <electronx> ok
20:15:56 <electronx> FatalBot: QUIT
20:16:07 --- mode: ChanServ set -o sjanssen
20:16:07 <electronx> bye bye little guy
20:16:15 <shapr> electronx: Is FatalBot written in Haskell?
20:16:19 <electronx> yeah
20:16:22 <shapr> Cool!
20:16:25 <shapr> Is the source online?
20:16:28 <electronx> no
20:16:36 <allbery_b> electronx: I gave a bunch of people in the channels my lambdabot lives in admin permission and express permission to @part/@quit the bot if it becomes obnoxious (or people playing with it become obnoxious)
20:16:37 <electronx> not yet!
20:17:29 <electronx> shapr: is it okay if i add a whole bunch of cool stuff and let it idle in the channel
20:17:42 <shapr> um, no
20:17:45 <electronx> it will only respond to its name
20:17:50 <allbery_b> may I suggest #haskell-overflow for testing?
20:18:01 <shapr> I think the bot quota for #haskell is fulfilled with lambdabot.
20:18:07 <electronx> lol
20:18:09 <shapr> Now if you want to write lambdabot plugins that do cool stuff, that would be nifty.
20:18:26 <allbery_b> better yet, grab a randdom unused channel and play with it there
20:18:45 <electronx> ok
20:18:52 <x6d65> sjanssen: So in (sum . take 5000000 $ repeat 1), it's just the final evaluation of the sum that causes a problem?
20:19:40 <allbery_b> hm
20:19:57 <x6d65> That is, there's never a list in memory with 5,000,000 elements, but just a giant thunk?
20:20:12 <allbery_b> speaking of plugins, I should extract patches for the changes I've made (added flexibility, a few new plugins)
20:20:23 <sjanssen> x6d65: exactly
20:23:49 <x6d65> Alright, thanks again for the help.
20:24:37 <sleven> seq_xor a b = nub $ (a\\b) ++ (b\\a)  , how can i use that on more than 2 lists?
20:24:52 <sleven> because foldl1 seq_xor a b doesnt work
20:25:11 <sleven> http://www.reddit.com/r/programming/comments/79mse/exploring_clojure_lisp_on_the_jvm_part_3_some/
20:25:13 <lambdabot> Title: Exploring Clojure (Lisp on the JVM) - Part 3 - Some Language Features : programm ..., http://tinyurl.com/6pjw9z
20:27:53 <sleven> anyone using easyVision? seems really cool
20:32:31 <mdmkolbe> Is there a generic hash function or package for haskell objects? (I might build one if there isn't already: with "instance (Data a) => Hash a")
20:32:44 <mdmkolbe> (but if a good one already exists I can just use that)
20:53:42 <ivanm> mdmkolbe: why do you need hash?
20:54:09 <ivanm> can't remember where I found it, but I once read a pretty good online article about why hash maps are bad and trees are better
20:55:45 <mdmkolbe> ivanm: what do you mean by trees are better?  Do you mean like using a ballanced tree with with only a key comparison for lookup?  If so that is not exactly the hash application I have in mind.
20:55:53 <ivanm> ahhh
20:56:00 <ivanm> what do you want hash's for?
20:56:13 <ivanm> passwords?
20:56:21 <ivanm> there's an md5 library IIRC...
20:56:24 <ivanm> @hoogle md5
20:56:24 <lambdabot> package nano-md5
20:56:24 <lambdabot> package pureMD5
20:56:28 <rwbarton> Sometimes you want an ordinary Map with (hash, value) pairs as keys, because comparing values is very expensive
20:56:28 <mdmkolbe> haskell objects as passwords, hmm
20:56:30 <ivanm> there you are ;-)
20:56:45 <ivanm> rwbarton: ahhh, yes, didn't think about that
20:56:48 <mdmkolbe> but seriously I need it for the sorts of thinks that git uses hashes of its objects for
20:56:59 <ivanm> mdmkolbe: which hask do they use?
20:57:12 <mdmkolbe> ivanm: hash?
20:57:36 <ivanm> yeah, that's what I meant :s
20:58:49 <mdmkolbe> in git, all objects (e.g. files, directories, revisions, etc.) are refered to by their hash.  I.e. the (crypographic for techincal reasons) hash is the global name (like a UUID) for the object that can be refered to by file formats and network line protocals
20:59:09 <ivanm> mdmkolbe: yes, but how do they calculate the hash?
20:59:13 <ivanm> md5? sha1?
20:59:24 <ivanm> hash is a generic class of one-way functions
20:59:35 <mdmkolbe> sha1
20:59:41 <mdmkolbe> IIRC
21:00:00 <ivanm> @hoogle sha
21:00:01 <lambdabot> Text.XHtml.Frameset shape :: String -> HtmlAttr
21:00:01 <lambdabot> Text.XHtml.Strict shape :: String -> HtmlAttr
21:00:01 <lambdabot> Text.XHtml.Transitional shape :: String -> HtmlAttr
21:00:05 <ivanm> @hoogle sha1
21:00:05 <lambdabot> No results found
21:00:08 <ivanm> @hoogle hash
21:00:08 <lambdabot> package Hashell
21:00:09 <lambdabot> Data.HashTable hashInt :: Int -> Int32
21:00:09 <lambdabot> System.Mem.StableName hashStableName :: StableName a -> Int
21:00:17 <ivanm> hmmmmm....
21:00:33 <ivanm> maybe it's combined in the md5 package? not sure what the HashTable would use...
21:00:55 <ivanm> mdmkolbe: see the Crypto library
21:01:17 <mdmkolbe> Data.Hashtable takes a hashing function as argument
21:01:59 <ddarius> Yes, a class isn't a particularly great idea for that application.
21:02:06 <ivanm> well, the Crypto library on hackage has a whole heap of hasing functions
21:02:10 <ivanm> ddarius: why not?
21:02:44 <ddarius> Because you may want different hashes for the same type.
21:02:57 <roconnor> @hayoo sha1
21:02:57 <lambdabot> Unknown command, try @list
21:03:11 <ddarius> roconnor: You haven't implemented it yet.
21:03:22 <ivanm> ddarius: :o
21:03:30 <ivanm> different hashes within the same hash map?
21:03:35 <ivanm> mightn't that lead to clashes?
21:03:47 <ivanm> @dwim sha1
21:03:47 <lambdabot> Unknown command, try @list
21:03:47 <mdmkolbe> ivanm: Crypto gives the [Int8] -> Hash part well (thx), though I'm still going to have to do the part for "(Hashtable a) => a -> [Int8]"
21:04:04 <ivanm> mdmkolbe: you're on your own there ;-)
21:06:19 <ddarius> Not different hashes within a hash table, different hashes for the same type for different hash tables or different uses of hashing.
21:06:20 <mdmkolbe> ddarius: true.  for my application I only need "one true hash", but if it might be generally usefull, I'll have to think about ways of parameterizing the hashing (both in the "a -> [Int8]" and the "[Int8] -> Hash") which might be hard without heavy performance penalties due to excessive indirects
21:06:51 <ddarius> GHC does relatively well for higher order code.
21:07:08 <mdmkolbe> ivanm: I think ddarius is refering that someone might want MD5 hash of a haskell object but another might want a SHA1 based version
21:07:35 <ivanm> isn't that _why_ classes are good? :s
21:08:32 <mdmkolbe> ivanm: to make it a class, the class would have to take the hashfunction as paramter which is unlikely to be inferable by the type system
21:09:13 <mdmkolbe> ivanm: e.g. which hash function should be used in "hash 5", there is no way to know using the class system
21:10:41 <mdmkolbe> ddarius: would you then recommend a general hash-maker function.  e.g., with type like "(Data a) => ([Int8] -> hash) -> a -> hash" (and maybe move Data from class to another parameter
21:13:34 <ddarius> I would probably just write makeOperations hash = Operations (foo hash) (bar hash) etc. if necessary, otherwise I would just parameterize the functions on the hash function.
21:14:21 <mdmkolbe> ddarius: I don't understand what you mean by makeOperations
21:15:50 <ddarius> You presumably have a bunch of operations that use a hash function.  Presumably they should all use the same hash function in any instance.
21:16:40 <mdmkolbe> I think I see where you are headed
21:16:51 <ddarius> If there is a specific data structure, I'd probably pass the hash function around with that as Data.HashTable no doubt does.
21:19:47 <steven_ashle1> Hi everyone, Why isn't () an instance of Ord :P?
21:19:57 <ddarius> @instances Ord
21:19:58 <lambdabot> (), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
21:20:11 <steven_ashle1> ahh :/
21:20:41 <ivanm> oh yea of little faith! :p
21:23:08 <ushdf> who wants to hear the song i'm writing
21:23:18 * ushdf coughs up blood
21:23:36 <mdmkolbe> ushdf: if you can pipe the sound over IRC that will be a trick
21:23:53 <ushdf> i have a link
21:24:03 <ushdf>  http://128.230.45.187:6003/ometmtm.mp3
21:25:17 <ushdf> ./` oh babe ./`
21:27:05 <mdmkolbe> what is quickest way to time a haskell function from the ghci command line?
21:28:37 <rwbarton> :set +s
21:29:38 <mdmkolbe> rwbarton: awsome, thx
21:30:02 <ushdf> nifty
21:51:53 <alt_mattr> does anyone know enough about Language.Haskell to be able to tell me what HsPatBind is?
22:14:28 <fatalerrorx> can someone invite jarvas?
22:14:44 <fatalerrorx> i want to test that it works
22:18:33 <lispy> so has nhc98 been brought back? I thought it was more or less dead
22:21:16 <pumpkin> ,OMG http://arxiv.org/pdf/0810.5056v1
22:21:18 <ivanm> fatalerrorx: no, I'm not inviting strangers into my home thank you very much! :p
22:21:19 <lunabot>  luna: Not in scope: data constructor `OMG'
22:21:23 <ivanm> heh
22:21:24 <pumpkin> ;)
22:21:41 <ivanm> pumpkin: what is it?
22:22:18 <ivanm> ahhh, the P /= NP proof?
22:22:39 <pumpkin> YES!
22:22:40 <pumpkin> THE PROOF
22:22:47 <pumpkin> haven't read it yet ;)
22:23:27 * lispy|web doesn't believe
22:23:55 <pumpkin> it's probably wrong, so I'm not going to bother reading it
22:24:00 <lispy|web> it's one of those things people claim proofs to a lot
22:24:01 <pumpkin> but OMG P /= NP!!!
22:24:03 <ivanm> lispy|web: why not?
22:24:10 <loop_> first page mentions "gmail name: stenake", can't be right
22:24:15 <ivanm> lispy|web: it actually was proven a couple of years ago
22:24:22 <ivanm> not sure if this is that paper though
22:24:41 <ivanm> then again, if you let N = 1, then P == NP :p
22:24:45 <pumpkin> lol
22:26:36 <lispy|web> what is this consistent extension stuff?  Are they actually saying that they proved it in some other theory of computation?
22:27:27 <lispy|web> That's my guess as to what the abstract is saynig
22:27:34 <lispy|web> ?users
22:27:34 <lambdabot> Maximum users seen in #haskell: 547, currently: 482 (88.1%), active: 9 (1.9%)
22:28:21 <rwbarton> Google seems to confirm that "simply consistent" is a technical term, but I haven't gotten it to tell me what it means.
22:30:47 <rwbarton> http://en.wikipedia.org/wiki/Consistent defines "consistent" and "simply consistent" but I can't work out what the difference is
22:30:49 <lambdabot> Title: Consistency - Wikipedia, the free encyclopedia
22:31:32 <ivanm> rwbarton: the latter is simple
22:31:33 <ivanm> ;-)
22:31:40 <rwbarton> Ah thanks :)
22:37:22 <lispy> rwbarton: could it be that one requires no formula and one requires no theorem?
22:39:02 <rwbarton> lispy: another website defined "simple consistency" as what I think of as consistency and "consistency" as "See simple consistency, model-theoretic consistency, proof-theoretic consistency, ..."
22:39:35 <rwbarton> lispy: So, I am going to assume it just means there is no X such that X and not X are both theorems
22:39:58 <loop_> um, what's the difference
22:40:25 <lispy|web> rwbarton: right
22:40:39 <lispy|web> rwbarton: therefore simple consistency is what we normally talk about
22:40:52 <lispy|web> (unless we're wrong)
22:40:59 <rwbarton> Yes, I think so
22:41:38 <lispy|web> rwbarton: so, it seems like this paper is saying that in some extended, but no less valid, model of computation that you can show P /= NP
22:41:45 <pumpkin> is there a simple way to invert a Data.Map ?
22:41:55 <pumpkin> as in make its keys be its values and vice versa?
22:42:09 <rwbarton> I would phrase it as "P /= NP is consistent with <something>"
22:42:16 <lispy|web> ?hoogle [(a, b)] -> [(b, a)]
22:42:17 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
22:42:17 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
22:42:17 <lambdabot> Control.Arrow (<<<) :: Arrow a => a c d -> a b c -> a b d
22:42:34 <glguy> cabal: internal error: getMBlock: mmap: Permission denied
22:42:35 <TSC> ?hoogle (a,b) -> (b,a)
22:42:36 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
22:42:36 <lambdabot> Control.Arrow (^<<) :: Arrow a => (c -> d) -> a b c -> a b d
22:42:36 <lambdabot> Control.Arrow (<<<) :: Arrow a => a c d -> a b c -> a b d
22:42:39 <lispy|web> ?hoogle fromMap
22:42:39 <lambdabot> No results found
22:42:40 <glguy> anyone know wha that is about?
22:42:55 <jeffz> glguy: maybe your filesystem doesn't support mmap
22:43:03 <TSC> pumpkin: Turn the map into a list, flip each element, turn the list back into a map
22:43:21 <lispy|web> :t map (flip (,))
22:43:22 <lambdabot> forall a a1. [a1] -> [a -> (a, a1)]
22:43:26 <loop_> lispy|web: but how is the definition of consistency on wikipedia any different from "simple consistency" ?
22:43:27 <glguy> jeffz, ext3?
22:43:39 <lispy|web> :t foldl1 (flip (,))
22:43:40 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a, a)
22:43:40 <lambdabot>       Expected type: a -> a -> a
22:43:40 <lambdabot>       Inferred type: a -> a -> (a, a)
22:43:50 <jeffz> glguy: oh, no... I've seen stuff that's needed mmap fail on ntfs under linux before.
22:43:55 <TSC> @pl (\ (a,b) -> (b,a))
22:43:55 <lambdabot> uncurry (flip (,))
22:44:09 <lispy|web> :t map (uncurry (flip (,)))
22:44:10 <lambdabot> forall b a. [(a, b)] -> [(b, a)]
22:45:05 <lispy|web> so yeah, invertMap m = toMap (map (uncurry (flip (,))) (fromMap m) -- for suitable toMap/fromMap
22:45:31 <lispy|web> toMap . map (uncurry (flip (,))) . fromMap, might be easier to read
22:45:59 <lispy|web> although, I would call it transpose not invert
22:46:19 <pumpkin> well if you think of it as a function, you're inverting it
22:46:25 <pumpkin> but yeah, I se what you mean
22:46:59 <lispy|web> pumpkin, oh good point.  a map is like a function
22:47:42 <TSC> pumpkin: It could be tricky if your map is not injective
22:47:47 <steven_ashle1> lispy|web:  I struggle to understand how ï»¿(uncurry (flip (,))) is considered better style than (\(a,b)->(b,a)) ...
22:47:48 <pumpkin> yeah, I'm assuming it is
22:48:25 <lispy|web> steven_ashle1: both are fine, but \(a,b) -> (b,a) is probably more clear as you point out
22:54:31 <dons> ?users
22:54:31 <lambdabot> Maximum users seen in #haskell: 547, currently: 479 (87.6%), active: 12 (2.5%)
23:01:23 <sjanssen> clearly the best version is toMap . map swap . fromMap where swap = thispartdoesn'tmatter
23:07:32 <lispy|web> :t thispartdoesn'tmatter
23:07:33 <lambdabot> Not in scope: `thispartdoesn'tmatter'
23:07:39 <steven_ashle1> lol
23:07:42 <lispy|web> sjanssen: what module did you import that from? :)
23:08:36 <sjanssen> my point is that you should give the function a name, and at that point it doesn't really matter what the definition looks like
23:09:51 <lispy|web> I know :)
23:10:22 <dons> mm. 1100 subscribes to http://www.reddit.com/r/haskell/
23:10:24 <lambdabot> Title: Haskell
23:10:32 <steven_ashle1> 1101 ;)
23:10:41 <dons> i wonder if we should actually use this resource.
23:10:56 <loop_> oh, there's reddit for haskell
23:11:16 <loop_> there's also reddit for bacon, mm :-)
23:11:27 <dons> gross :)
23:12:10 <sjanssen> readInt 2 (`elem` "01") digitToInt "1100"
23:12:15 <sjanssen> > readInt 2 (`elem` "01") digitToInt "1100"
23:12:16 <lambdabot>   /tmp/3050749010067470811:69:60: Not in scope: `readInt'
23:12:19 <sjanssen> bah
23:12:28 <sjanssen> anyway, 12 subscribers is not so many
23:13:04 <lispy|web> ugh, what's up with that error message?
23:13:14 <lispy|web> *why* did it reference a tmp file?
23:13:25 <lispy|web> That does not inspire confidence
23:13:32 <sjanssen> because somebody isn't using {-# LINE #-} and SOURCE pragmas
23:13:42 <sjanssen> just a cosmetic issue
23:14:02 <lispy|web> I'll believe you if you promise to be correct :)
23:14:21 <mathijs> Anyone with a copy of 'Programming in Haskell' online? I have a question on chapter 8 (parsers).
23:14:46 <lispy|web> dons: interesting, I could make a darcs reddit too it seems
23:14:57 <sjanssen> dons: I think haskell reddit is too specific to be interesting
23:15:02 <sjanssen> same with a darcs reddit
23:15:33 <lispy|web> it's like reddit for busy, focused people :)
23:15:38 <rwbarton> This paper seems to be hopelessly garbled, as well as not being written in English
23:15:56 <lispy|web> rwbarton: are you still trying to prove P /= NP?
23:16:24 <rwbarton> I was trying to figure out why this paper was wrong, and now I know why that was a dumb idea :)
23:17:49 * lispy|web thinks that P = NP, but not in a useful way FWIW
23:17:58 <lispy|web> I just don't have any proofs of why I think that :)
23:22:16 * glguy figured out why cabal-install was dying
23:22:31 <glguy> GHC makes use of PROT_EXEC'd mmapped memory
23:22:43 <glguy> which the latest SELinux policy in Fedora doesn't allow
23:22:46 <glguy> without a special type
23:23:09 * mmorrow changes his SELinux policy
23:23:34 <glguy> chcon -t unconfined_execmem_exec_t ~/.cabal/bin/cabal
23:23:37 <glguy> fixed it for me
23:23:42 <mmorrow> sweet
23:24:02 <glguy> mmorrow, I only needed this on Fedora-rawhide
23:24:05 <glguy> I think 9 is still OK
23:24:21 <glguy> GHC 6.10 or beyond, I don't remember, is supposed to move to libffi to avoid this problem
23:24:21 <mmorrow> ah i see
23:24:33 * mmorrow lazily still is on 8
23:24:35 <mmorrow> :)
23:25:14 <inimino> 6.10 isn't released yet is it?
23:25:59 <olsner> there's a release candidate iirc
23:26:07 <inimino> yeah
23:26:08 <mmorrow> oh, i meant fedora8. yeah, i noticed that libffi changes things
23:26:24 <inimino> oh, Fedora
23:26:35 <mmorrow> this segfaults in ghci now http://code.haskell.org/~morrow/code/haskell/misc/Call.html
23:26:55 <mmorrow> on account of http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=221
23:27:05 <mmorrow> :(
23:28:34 <mmorrow> (or maybe it's on account of SELinux? checking now...)
23:29:20 <dons> the core produced by ghc-core is so much more readable than ghc
23:29:41 <dons> glguy: this has also been an issue on openbsd in the past
23:29:57 <dons> preventing ghci working (where we load data as code and execute it, and also generate code dynamically)
23:30:10 <glguy> because of the W^X policy?
23:30:35 <dons> yeah.
23:31:01 <TSC> Anyone know how to fix this?
23:31:01 <TSC> $ cabal install ghc-core
23:31:01 <aeolist> guys i was reading up on erlang yesterday and came to wonder if haskell has actor model parallelism
23:31:02 <TSC> cabal: Couldn't read cabal file "./Glob/0.1/Glob.cabal"
23:31:35 <aeolist> browsing through the real world haskell book i think the answer is it doesn't? not sure
23:31:54 <lispy|web> aeolist: haskell has some very cool parallelism, but we don't have the same stuff as erlang.  In erlang threads have their own heap IIRC
23:32:09 <mmorrow> haha, awesome. is was SELinux
23:32:22 <dons> aeolist: Chan's, basically, but not quite the same.
23:32:27 <mmorrow> sudo chcon -t unconfined_execmem_exec_t /usr/local/ghc/ghc-6.10.0.20080927_2/lib/ghc-6.10.0.20080927/ghc
23:32:29 <dons> aeolist: talk to matthew-_  about it
23:32:31 <aeolist> i was more on the track actor model (messages) vs shared state
23:32:39 <aeolist> ok will do
23:32:41 <glguy> mmorrow, if you want to keep the rest of selinux
23:32:44 <dons> you can actually message threads using async exceptions.
23:32:45 <glguy> but not the execmem part
23:32:49 <lispy|web> aeolist: but we have things like software transactional memory (STM) that is an optimistic way of doing concurrency.  Combine that with GHC's very lightweight threads and you have some mean concurrency
23:32:50 <glguy> execmem_exec_t
23:32:54 <dons> pretty much any (shared mem) model for concurrency is already supported
23:33:21 <dons> the main thing is that ghc is just damn fast. so erlang's got a lot of work to do to catch up performance wise. its benefits are elsewhere.
23:33:36 <glguy> mmorrow, on my computer /usr/bin/darcs is execmem_exec_t
23:33:47 <mmorrow> hmm
23:33:47 <dons> particularly, if your problem is distribution, or catching fail-over processes, then erlang's playing at home.
23:34:13 <dons> raw performance though, not really the same league, here , on quad core, http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=hipe
23:34:20 * mmorrow looks at his SELinux policies
23:34:25 <lambdabot> Title: Haskell GHC benchmarks | x64 Ubuntu : IntelÂ® Q6600Â® quad-core Computer Languag ..., http://tinyurl.com/4mcz9g
23:34:53 <dons> (btw, i think that's a great graph next time some one says that erlang is how they're going to program that multicore :)
23:35:16 <mmorrow> i really have to rtfm for SELinux
23:35:18 <glguy> multicore is small scale
23:35:31 <glguy> multicomputer scales
23:36:03 <dons> peta scale isn't small scale.
23:36:25 <glguy> peta scale doesn't exist in more than places than I can count on my left hand
23:36:36 <dons> its big scale though
23:36:38 <glguy> and isn't generally relevant at this point
23:36:40 <lispy|web> huh, I wonder what it would take to add some sort of distributed concurrency ala erlang to ghc
23:36:43 <TSC> @index readProcess
23:36:44 <lambdabot> bzzt
23:36:45 <dons> multicore however, is ubiquitous
23:36:54 <dons> so playing well there is a useful thing.
23:36:59 <lispy|web> we could have lambda beans
23:37:15 <dons> its been well researched in the past. just a small matter of engineering
23:37:16 <sclv> lispy|web: it could be done with a library, mainly.
23:37:20 <mmorrow> anyone recall off hand what --ignore-dot-ghci should really be?
23:37:29 <lispy|web> it seems that purely functional code would make it easy to migrate code
23:37:34 <sclv> pervasive efficient serialization is an issue.
23:37:42 <mmorrow> ah
23:37:49 <mmorrow> -ignore-dot-ghci
23:37:58 <sclv> erlang's code-migration/hot-swapping is overrated/oversold
23:38:04 <dons> sclv: where you at cufp?
23:38:21 <dons> the yahoo/erlang team made the point that it is overrated/oversold, and not for production :)
23:38:28 <dons> reloading, that is.
23:38:31 <sclv> yep -- we met. i work with jeffp.
23:38:39 <dons> oh!
23:38:47 <dons> quite so, quite so.
23:38:50 <lispy|web> sclv: I was thinking of (I don't recall the term) handling the type of concurrency where you have a cluster instead of smp, that seems like a place erlang would shine
23:39:08 <sclv> the discussions on concurrency at icfp were the most useful part for some of the things i've been working on.
23:39:37 <sclv> lispy|web: it does shine there. but that's not the language, but the otp platform/libraries.
23:39:40 <dons> sclv: cool, yes, i thought there was some interesting stuff going on.
23:39:54 <lispy|web> or maybe we could have mapReduce distributed style haskell library and then work on things like protein folding :)
23:40:05 <sclv> the other interesting thing i learned about erlang is that the strict message passing model they've adopted causes problems.
23:40:30 <dons> oh? you mean, restricting to message passing only?
23:40:46 <sclv> its hard to keep track of "conversations" since every message is asynchronous and there's no built in sense of origin and sequencing.
23:40:47 <dons> i can imagine that makes some shared mem stuff a bit annoying. makes sense for some use cases.
23:40:54 <dons> ah, interesting.
23:41:06 <sclv> so a bit too primitive once things get complicated and you just have to rebuild on top of it anyway.
23:41:32 <lispy|web> they need the TCP equivalent of message passing?
23:41:56 <mmorrow> glguy: ok, i just enabled allow_exec{heap,mem,mod,stack}
23:42:05 <glguy> heh, go crazy :)
23:42:12 <sclv> so in fact, either a socket based or message-response rpc invocation style approach or both are perhaps better, and when you don't need all the extra bits you can eat the overhead.
23:42:18 <dons> mmorrow: hehe
23:42:35 <mmorrow> debauchery++
23:42:40 <glguy> mmorrow, can you add "url" to that list?
23:42:54 <mmorrow> glguy: heh
23:43:29 <dons> i notice martin sulzmann's uploading stuff to hackage. that's cool.
23:43:42 <dons> his constraint handling stuff, http://hackage.haskell.org/cgi-bin/hackage-scripts/package/multisetrewrite-0.1
23:43:48 <lambdabot> Title: HackageDB: multisetrewrite-0.1, http://tinyurl.com/66ptn4
23:44:11 <dons> oh, reminds me to bug hinze about his beautiful streams code
23:44:35 <lispy|web> which reminds me
23:44:50 <dons> yo, sulzmann's got a blog. wow.
23:45:09 <lispy|web> dons: have you guys ever planned on making a UCS-2 or UCS-4 version of bytestring.  Ya know, one that stores unicode code points?
23:45:17 <dons> didn't sjanssen do that?
23:45:20 <dons> someone did..
23:45:43 <dons> dcoutts_ had a student doing that.
23:45:49 <lispy|web> ah
23:46:04 <lispy|web> a SoC student?
23:46:12 <dons> mm. i think oxford student
23:46:14 <olsner> is it possible to make ghc print source/line information for core? anonymous lambdas and values keep getting generated or obfuscated names, so I always end up reverse-engineering the core code to find out which code I'm supposedly looking at
23:46:16 <lispy|web> cool
23:46:23 <sclv> ooh, haskell actors library too. cool.
23:46:46 <dons> stm-based caching also released today
23:47:12 <dons> http://sulzmann.blogspot.com/2008/10/actors-with-multi-headed-receive.html
23:47:17 <lambdabot> Title: Martin Sulzmann's Blog: Actors with Multi-Headed Receive Clauses, http://tinyurl.com/6248ho
23:47:36 <lispy|web> One thing that would really make GHC cool is turning it into a cross-compiler.  I wonder how much work that would be.
23:47:58 <dons> that's ghc 6.12's job. check their details page.
23:48:02 <dons> the new backend is a cross compiler
23:48:09 <lispy|web> rock on :)
23:48:22 <lispy|web> That will make things ilke iphone support (well really arm) much easier
23:48:48 <dons> sclv: everything's on hackage, it seems :)
23:49:09 <dons> sclv: so when are you guys going to start a haskell blog ? :)
23:49:17 <dons> can't let janet st. have all the bloggy fun
23:49:22 * lispy|web would like to get into GHC dev
23:49:56 <sclv> heh. not so sure about that. :-)
23:50:31 <lispy|web> dons: I'm at the ghc site, but I don't really know where to go for info on ghc6.12
23:50:39 <lispy|web> dons: any hints?
23:50:58 <dons> ah let me see... in the wiki
23:51:12 <aeolist> mmm my question is answered, nice :)
23:51:26 <sclv> jeff did get to evangelize here though: http://www.cloudconeast.com/abstracts.php#polakow
23:51:28 <dons> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/IntegratedCodeGen
23:51:32 <lambdabot> Title: Fall Forecast 2008 - Computing Among the Clouds - Abstracts
23:51:34 <lambdabot> Title: Commentary/Compiler/IntegratedCodeGen - GHC - Trac, http://tinyurl.com/6g4fqb
23:51:40 <dons> sclv: nice!
23:51:43 <sclv> h tells me that maybe 30ish people attended the talk.
23:52:30 <dons> good work.
23:52:39 <lispy|web> dons: nice, thanks
23:52:54 <olsner> lispy: me too!
23:53:17 <lispy|web> olsner: you'd like to get into ghc dev?
23:53:50 <dons> in general, worth reading,
23:53:51 <dons> http://hackage.haskell.org/trac/ghc/wiki/Status/Releases
23:53:52 <lambdabot> Title: Status/Releases - GHC - Trac
23:54:40 <olsner> yeah, or at least I *think* I want to
23:55:13 <dons> lispy|web: so people want to keep ghc 6.6
23:55:20 <dons> but turns out that is ok?
23:55:28 <efh123> (toEnum 97) == 'a'
23:55:32 <efh123> > (toEnum 97) == 'a'
23:55:33 <lambdabot>   True
23:55:38 <dons> parens not needed
23:56:20 <efh123> > toEnum 97
23:56:21 <lambdabot>   * Exception: Prelude.Enum.().toEnum: bad argument
23:56:24 <efh123> ?
23:56:43 <dons> Prelude.Enum.() ?
23:56:49 <dons> :t toEnum
23:56:50 <lambdabot> forall a. (Enum a) => Int -> a
23:57:01 <dons> > toEnum 97 :: Char
23:57:03 <lambdabot>   'a'
23:57:04 <olsner> > toEnum 0
23:57:05 <lambdabot>   ()
23:57:08 <dons> > toEnum 97 :: ()
23:57:09 <olsner> nice :)
23:57:10 <lambdabot>   * Exception: Prelude.Enum.().toEnum: bad argument
23:57:23 <dons> efh123: it is the extended defaulting picking a type for the 'a' part of toEnum
23:57:27 <dons> make sense?
23:57:33 <mmorrow> ah, i was wondering what was happening here ... http://hackage.haskell.org/trac/ghc/ticket/2685
23:57:34 <efh123> oh I see
23:57:35 <lambdabot> Title: #2685 (Panic in harpy with GHC 6.10 RC) - GHC - Trac
23:57:39 <efh123> thanks =]
23:58:00 <dons> mmorrow: fixed, isn't it?
23:58:07 * lispy|web >>= bed
23:58:07 <mmorrow> yup :)
