00:01:48 <fatalerrorx> !help
00:01:57 <fatalerrorx> .help
00:02:06 <fatalerrorx> lambdabot: help
00:02:17 <fatalerrorx> bah
00:05:02 <rwbarton> @help
00:05:02 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
00:09:28 <fatalerrorx> ah
00:35:00 <SubStack> @pl map (\f -> f 7) [succ]
00:35:00 <lambdabot> [succ 7]
00:35:11 <SubStack> well yeah...
00:35:27 <SubStack> @pl let baz=7 in map (\f -> f baz) [succ]
00:35:28 <lambdabot> [succ 7]
00:35:32 <SubStack> >_>
00:36:26 <SubStack> @pl let baz=7 in map (\f -> f baz) [succ,(+1)]
00:36:26 <lambdabot> [succ 7, 8]
00:38:12 <Asztal> > map ($ 7) [succ]
00:38:13 <lambdabot>   [8]
00:38:25 <SubStack> o_O
00:38:51 <SubStack> hey, that works pretty well
00:38:55 <SubStack> Asztal++
00:38:56 <Asztal> yep :)
00:39:00 <SubStack> didn't think about doing that
00:39:18 <SubStack> thought I'd have to break into Control.Monad or some such
00:40:33 <Axman6> :t ($ 1)
00:40:34 <lambdabot> forall a b. (Num a) => (a -> b) -> b
01:13:44 <cpfr> dons!
01:35:47 <J-roen> Hi. Can this be written more simple?  [m [] | m <- ms]
01:36:35 <Axman6> map m ms?
01:36:46 <Axman6> uh, no
01:36:59 <Axman6> :t (f$)
01:37:00 <lambdabot> forall a b. (SimpleReflect.FromExpr b, Show a) => a -> b
01:37:24 <Axman6> map ($ []) ms i think
01:37:30 <J-roen> Okay, thanks :)
01:37:37 <Axman6> try it and make sure
01:37:42 <SubStack> > map ($ []) [length]
01:37:43 <lambdabot>   [0]
01:38:00 <J-roen> Yes, it works. Thanks.
01:38:07 <mapreduce> > [m [] | m <- [const 5, const 10, length]]
01:38:09 <lambdabot>   [5,10,0]
01:38:30 <SubStack> o_O
01:38:44 <Axman6> > map ($ []) [id,(:) 1]
01:38:45 <lambdabot>   [[],[1]]
01:40:12 <RayNbow> > sequence [id, (1:)] []  -- alternative
01:40:14 <lambdabot>   [[],[1]]
01:40:45 <janimo> which is the simplest way of transforming a seconds since epoch Integer to local time strin g repr? Like ctime() in C
01:41:01 <janimo> the Haskell Time libs are frighteningly complex :)
01:42:38 <janimo> so far System.Time.TOD is the closest I could get
01:43:04 <Baughn> janimo: *Time* is frighteningly complex. :P
01:43:25 <Baughn> janimo: I imagine you want Data.Time.Format, however
01:43:28 <janimo> Baughn: even so, it is pretty easy in C
01:43:36 <janimo> thi sparticular operation
01:43:45 <janimo> if possible without the IO monad :)
01:43:47 <Baughn> janimo: Only because C makes simplifying assumptions that, actually, aren't valid all the time
01:43:56 <Baughn> Well, of course
01:43:58 <Baughn> formatTime
01:44:08 <janimo> Baughn: ok, I'll revisit that. thanks
01:45:47 <janimo> there are two steps, first making seconds since epoch into a localtime struct tm - calendarTime in Haskell I think, then printing that
01:46:04 <unenough> brain melt. yesterday i learnt about types, Functors, Applicatives, and Monads in about 3 hours
01:46:55 <Axman6> doing well
01:47:13 <mapreduce> unenough: Yeah, but did you check the date afterwards?
01:47:22 <unenough> heh
01:47:44 <unenough> actually it was until 2:30 AM so the date did change
01:48:49 <unenough> btw, functors map types to types. but in math they also map morphisms to morphisms
01:49:10 <unenough> is the analog that functors map functors to functors
01:49:12 <unenough> ?
01:51:22 <janimo> confusinlgly toUTCTIme does return a CalendarTime not a UTCTime
01:52:14 <twb> What's the haskell equivalent of mktemps?
01:52:20 <twb> Er, mkstemp.
01:52:40 <twb> That is, atomically make a temporary directory in a sensible place (e.g. $TMPDIR or /tmp).
01:53:24 <Baughn> getTemporaryDirectory
01:53:37 <Baughn> Maybe?
01:53:50 <Baughn> Hm, guess not
01:54:12 <Baughn> There's always openTempFile, but..
01:55:58 <twb> but what?
01:56:07 <Baughn> But you wanted a directory
01:56:08 <twb> Oh, but it's a file
01:56:15 <twb> Right.
01:56:40 <Baughn> It's not too hard to implement on your own, though. mkdir fails if the directory already exists.
01:57:05 <Baughn> And mkstemp was always flawed
01:57:15 <twb> Was it?  I thought that was mktemp.
01:57:26 <Baughn> Oh, wait. Yes..
01:57:37 <Baughn> But mkstemp doesn't make a directory either. :/
01:58:16 <twb> Well, REALLY what I want is to use Haskell for shell scripting, because sh sucks, I hate perl, I REALLY hate Python, and nobody else likes scsh or Lisp in general
01:58:30 <twb> So Haskell is the obvious choice ;-)
01:58:40 <Axman6> twb: you could always write one
01:59:03 <twb> Axman6: I'd like to avoid yak shaving where possible.
01:59:19 <twb> Doesn't matter, I'll just leave that bit outside of Haskell for now
02:00:09 <twb> *Main> runSL "mktemp -d" :: IO String
02:00:10 <twb> "/tmp/tmp.pyotyJbzYf"
02:01:03 <twb> Onward!  What's chdir called?  @hoogle chdir just returns the internal FFI function.
02:02:03 <Cale> :t System.Posix.Temp.mkstemp
02:02:04 <lambdabot> String -> IO (String, GHC.IOBase.Handle)
02:02:26 <Cale> (by the way)
02:02:42 <twb> Oops, /query lambdabot isn't ghci.
02:02:52 <pixel_> twb: setCurrentDirectory?
02:02:58 <twb> pixel_: thanks.
02:03:22 <pixel_> hayoo is great :)
02:16:53 <twb> How do I do tilde expansion (~/foo --> /home/twb/foo, ~root -> /root)
02:17:46 <BeelsebobWork_> anyone know if there's a way to suppress orphan instances warnings?  (i.e. I want -Wall on, but I don't care that there's these orphans)
02:19:11 <C-Keen> @hoogle globDir
02:19:12 <lambdabot> No results found
02:19:32 <C-Keen> http://users.tkk.fi/~mniemenm/glob/index.html
02:19:42 <lambdabot> Title: Glob
02:20:27 <quicksilver> BeelsebobWork_: -fno-warn-orphans ?
02:20:31 <BeelsebobWork_> hmm
02:20:40 <BeelsebobWork_> there's no way to do it in the source (not as a pragma)
02:20:50 <BeelsebobWork_> i.e. specifically mark those orphans as ones that I don't care about
02:20:52 <BeelsebobWork_> ?
02:21:00 <quicksilver> Not as far as I know.
02:21:10 <BeelsebobWork_> okay, cheers :)
02:22:06 <quicksilver> BeelsebobWork_: unless I missed it, conal still hasn't set up the suggested reactive mailing list?
02:22:26 <BeelsebobWork_> I don't think so, quite yet -- we're getting very close to making a big release announcement I think
02:22:34 <BeelsebobWork_> I *think* it'll go hand in hand with that
02:23:11 * quicksilver is playing with reactive idea again.
02:23:55 <BeelsebobWork_> cool beans
02:24:26 <StoneToad> is there a way to modify my environment for all subsequent operations with Control.Monad.Reader?
02:24:28 <BeelsebobWork_> incidentally, you may be interested, what I'm cleaning up atm is my obj parser
02:24:37 <Peaker> quicksilver: from darcs?
02:24:39 <BeelsebobWork_> I should be releasing it soon
02:25:04 <Deewiant> C-Keen: glob doesn't do tilde expansion
02:25:17 <quicksilver> Peaker: No. My own implementation ;)
02:25:44 <quicksilver> StoneToad: well you can use local but only if "all subsequent operations" are inside the local.
02:25:45 <Peaker> quicksilver: ah, cool, did you implement it in the same way conal did? Future's with MVar threads and sinks, unamb, etc?
02:25:51 <quicksilver> Peaker: No.
02:25:57 <Peaker> quicksilver: how did you implement it?
02:26:09 <Cale> StoneToad: you can use local
02:26:11 <Baughn> StoneToad: If you actually want state, there's.. er, State
02:26:24 <StoneToad> quicksilver: yea... it almost works :(  I kinda don't want my function names to only exist inside the function definition :)
02:26:33 <quicksilver> Peaker: making the IO and the blocking a little more explicity.
02:26:42 <quicksilver> Peaker: no 'unamb' and no blocking pure values.
02:26:45 <twb> How can I do this without binding x?
02:26:46 <twb> do { x <- getEnv "HOME"; setCurrentDirectory $ x </> ".rwh"; }
02:26:53 <Cale> StoneToad: you don't need them to be defined in the same place
02:27:03 <Cale> StoneToad: You just need them to be used inside the local.
02:27:06 <twb> Because </> wants String not IO String.
02:27:14 <Baughn> @. pl undo do { x <- getEnv "HOME"; setCurrentDirectory $ x </> ".rwh"; }
02:27:15 <lambdabot> setCurrentDirectory . (</> ".rwh") =<< getEnv "HOME"
02:27:17 <StoneToad> Cale: I don't think I follow you
02:27:24 <Peaker> quicksilver: so all of the values built on each other are built inside the IO monad?
02:27:30 <quicksilver> Peaker: no.
02:27:40 <Peaker> quicksilver: can I see your implementation?
02:27:49 <quicksilver> Peaker: in some sense they can only be observed in the IO monad
02:27:56 <quicksilver> but the values themselves are not of the form 'IO a'.
02:28:10 <quicksilver> and you wouldn't explicitly observe them in the IO monad, you'd use some scaffold which did that for you.
02:28:36 <Cale> StoneToad: For instance, you might have some Reader computation foo, defined elsewhere, representing the rest of the computation you're performing. If you write  local (modify (+1)) foo  then foo will be run in an environment which has had 1 added to it.
02:29:05 <quicksilver> Peaker: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=65
02:29:20 <StoneToad> ahh
02:29:29 <Cale> StoneToad: The point of the reader monad is in some sense to make local changes to the environment easy, and make it hard to forget to change things back though.
02:30:06 <Cale> (for instance, in an interpreter, where you want local variables to come into scope and get added to the environment, but then disappear when they go out of scope again)
02:30:07 <Peaker> quicksilver: you leak future threads when competing them? :)
02:30:11 <quicksilver> Peaker: the hard bit is mostly in the scaffolding :( the hard bit is interfacing to existing real sources of events
02:30:12 <pixel_> twb: note that System.Directory.getHomeDirectory may be nicer than getEnv "HOME" :)
02:30:16 <quicksilver> Peaker: I think the GC kills them in the end.
02:30:20 <StoneToad> Cale: right, which is exactly why I was using it (nested scopes) but I guess my main problem really is I can't seem to figure out how to make a combined state + reader monad
02:30:42 <Peaker> quicksilver: how can GC know that it should kill threads?
02:30:45 <Cale> StoneToad: Well, you can use monad transformers to get yourself one.
02:31:17 <Peaker> quicksilver: anyhow, thanks for that. I really wanted a working implementation to toy with!
02:31:34 <Peaker> quicksilver: I want to re-implement Phooey over SDL/CLI for educational purposes
02:31:56 <quicksilver> Peaker: the GC will kill a thread which is waiting on an MVar
02:32:01 <Baughn> Peaker: If a thread is blocked, and no other (unblocked) threads have references to anything that can wake them, and there are no exception (signal) handlers set up.. it does realize there's no way for the thread to wake
02:32:04 <quicksilver> Peaker: if there is no other live reference to that MVar
02:32:09 <mmorrow> Peaker: i happened to read about that yesterday. so a TSO (thread state object) is just another type of thing that is a heap object and can tell if a TSO is unreachable
02:32:18 <mmorrow> or something like that..
02:32:27 <StoneToad> Cale: I'm probably missing something really simple, but I wasn't able to get ghci to accept my syntax even
02:32:27 <Cale> StoneToad: something like  newtype MyMonad a = ReaderT MyEnv (State MyState) a deriving (Functor, Monad, MonadReader r, MonadState s)
02:32:43 <Cale> StoneToad: er
02:32:53 <Cale> newtype MyMonad a = MM (ReaderT MyEnv (State MyState) a) deriving (Functor, Monad, MonadReader r, MonadState s)
02:32:56 <Cale> rather :)
02:32:58 <Peaker> mmorrow, quicksilver, Baughn: Thanks, I see.  That indeed sounds like it should work ;)
02:33:02 <Cale> (don't forget the constructor! :)
02:33:25 <StoneToad> oohhh that's what was making it not work
02:33:55 <quicksilver> Peaker: I probably should kill it explicitly though.
02:34:04 <quicksilver> actually I'm trying to avoid ever using the blocking API.
02:34:16 <pixel_> twb: as for ~user expansion, if you have a solution please tell (i need it for http://pleac.sourceforge.net/pleac_haskell/fileaccess.html#AEN368, ruby has File.expand_path, python has os.path.expanduser, but perl has nothing by default).
02:34:17 <lambdabot> Title: File Access
02:34:40 <StoneToad> Cale: thanks a lot for the help!
02:34:43 <Cale> StoneToad: Note that to derive Functor, Monad, etc. you need the newtype deriving extension
02:35:01 <Cale> StoneToad: Which I personally consider to be essential for working with monad transformers.
02:35:14 <mmorrow> Peaker: err, i meant "...a heap object, and _the GC_ can tell..." of course ;)
02:35:15 <StoneToad> how do I turn that on?
02:35:25 <Cale> {-# LANGUAGE NewtypeDeriving #-}
02:35:36 <Peaker> mmorrow: Yeah, seeing that a thread will block forever sounds possible, I mean
02:35:40 <Cale> er
02:35:42 <Peaker> brb
02:35:45 <Cale> GeneralizedNewtypeDeriving
02:35:46 <Cale> rather
02:36:07 <Cale> (just add that comment to the top of your file)
02:37:15 <Baughn> Peaker: Deadlock detection is handy, but it's only a debugging feature, of course
02:37:31 <twb> pixel_: I only know for ~/ not ~root/
02:38:19 <unenough> what do you do in haskell when you have to implement a mutablity-reliant algorithm for performance?
02:38:20 <twb> pixel_: which is expand ("~":"/":xs) = (</> xs) <<= getenv "HOME"
02:38:20 <pixel_> twb: well, the solution must be something alike http://pleac.sourceforge.net/pleac_perl/fileaccess.html#AEN368
02:38:21 <lambdabot> Title: File Access
02:38:30 <Baughn> unenough: Use State
02:39:14 <Cale> Is the Haskell PLEAC anything close to sane these days? Last time I looked at it, it used all sorts of strange definitions.
02:39:44 <StoneToad> cods: It's complaining about not being able to deduce stuff from the context in the instance declaration? (several line error message so don't want to paste it)
02:40:05 <StoneToad> woops, sorry that was directed at Cale
02:40:23 <Cale> Could you maybe put it on hpaste?
02:40:28 <Cale> @where hpaste
02:40:28 <lambdabot> http://hpaste.org/
02:40:58 <Baughn> unenough: Oh, but half the time it's possible to hide the mutability behind lazy thunk updates
02:41:39 <unenough> Baughn, i don't know what that means.
02:42:06 <StoneToad> Cale: it's at http://hpaste.org/11597
02:42:18 <Baughn> unenough: Lazy evaluation. At the machine level, that's mutation, and it can sometimes be used to implement mutation-reliant algorithms.
02:42:35 <Cale> StoneToad: can I see your test.hs as well?
02:42:42 <Baughn> unenough: You'll want to read Okasaki's book for details on that, though
02:43:00 <unenough> Purely Functional Data Structures?
02:43:14 <Baughn> Yes
02:43:37 <Cale> Of course, it's not arbitrary mutation.
02:44:08 <unenough> i did, but i can't remember what he said. i missed half his points too, because of lacking background
02:45:14 <Cale> But it's enough that I believe you can do anything in a pure lazy language which you can do in a language with mutable updates with at most a log factor hit in performance.
02:46:04 <twb> Gasp!  No wonder I've been having trouble.
02:46:13 <twb> Paredit wasn't set to automatically turn on in haskell buffers.
02:46:31 <osfameron> Cale: and how many log factors of hurting your poor brane? ;-)
02:46:58 <Cale> At worst, you end up implementing the mutable heap using something like a Data.Map
02:47:01 <StoneToad> Cale: http://hpaste.org/11598 -- I trimmed out the irrelevant things (still makes the same error though)
02:47:54 <Cale> ah
02:48:01 <Cale> change r to MyEnv and s to MyState
02:48:03 <quicksilver> StoneToad: it's the 'r' and the 's'
02:48:12 <quicksilver> StoneToad: you have to tell it what it reads and what it states :)
02:48:31 <quicksilver> deriving .... MonadReader MyEnv, MonadState MyState ...
02:48:52 <StoneToad> sweet! works
02:49:13 <Cale> (sorry about that)
02:49:57 <Cale> I think at some point there was a bug in newtype deriving where it wouldn't accept specific types for r and s, and so I was confused about which way was going to work.
02:50:31 <StoneToad> I feel like learning the whole monad stuff is making my mind stretch into a 4th dimention.  I'm sure it will be great for my programing eventually, but right now I feel like I need a heatsink upgrade for my head :)
02:50:49 <Cale> hehe
02:50:58 <twb> Does Haskell have something like Python's "raw" strings, where r"\foo" â‰¡ "\\foo" ?
02:51:05 <Deewiant> unfortunately no
02:52:05 <unenough> StoneToad, that's exactly my feeling, i would say i feel like a stuffed whale
02:52:25 <unenough> it went a long distance but in the end, no brain
02:52:38 <Cale> I think in order to understand monads properly, it's best to first get the general idea of what combinator libraries are about.
02:53:18 <osfameron> what other combinator libraries are simpler than monads?
02:53:33 <Cale> It's a long-standing tradition in functional programming to design libraries in which you have various primitive computations, and then a number of ways of gluing those together in various ways.
02:54:37 <Cale> For example, in a drawing library, you might have primitive drawings consisting of circles, lines, and so on, and then ways to combine and transform drawings - putting them next to one another horizontally or vertically, scaling them, and so on.
02:54:59 <Cale> You might even have something which replaces all the primitives of one type in a drawing with other drawings.
02:55:15 <Cale> (according to some function of the primitive's parameters)
02:56:59 <Cale> So the general idea is you have some basic things, and then ways to combine them. Monads (along with applicative functors, arrows, and all those other ones you might hear about) are essentially libraries where you have some means of combination which matches a specific pattern.
02:57:25 <Cale> And because your means of combination matches that pattern, you get a bunch of potentially useful generic functions for free.
02:57:38 <Cale> (things which work in any monad)
02:58:27 <Cale> One particularly simple, but possibly enlightening example is the function 'sequence'
02:58:33 <Cale> :t sequence
02:58:34 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
02:59:35 <Cale> In the computation analogy for monads, this takes a list of computations, and produces a single computation which will run them all, giving a list of the results.
03:00:35 <Cale> You might try something like   sequence [getLine, getLine, getLine] >>= print   at the ghci prompt to see how it works in the IO monad.
03:00:56 <Cale> In the list monad, "running" a list is just picking an element from it.
03:01:05 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
03:01:06 <lambdabot>   [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2...
03:01:49 <Cale> So sequence gives you a list representing all the ways of picking an element from each of the lists.
03:02:29 <Cale> In the ((->) e) monad, "running" a function just means applying it to the parameter to which the whole computation has been applied
03:02:46 <Cale> So, in this monad, sequence applies all the functions, getting a list of results:
03:03:01 <Cale> > sequence [id, (+2), (*2), (^2), (2^)] 5
03:03:02 <lambdabot>   [5,7,10,25,32]
03:03:47 <StoneToad> how are you picking which monad to use?
03:03:54 <Cale> Type inference, basically.
03:04:09 <Cale> The type of the elements of the list I pass to sequence determines the monad.
03:05:10 <Cale> In a parsing monad, sequence gives the concatenation of a bunch of parsers: parsing the input string with each of them in turn, and returning the list of results obtained.
03:05:35 <Cale> In a state monad, it's just "run each of these in turn"
03:05:56 <damg> did anyone manage to build hmatrix? ghc reports `coarbitrary' is not a (visible) method of class `Arbitrary`
03:06:06 <Cale> > let inc = do x <- get; put (x+1); return x in runState (sequence [inc, inc, inc, inc]) 5
03:06:08 <lambdabot>   ([5,6,7,8],9)
03:06:32 <Cale> (that's both the resulting list, and the final state)
03:07:10 <Cale> So the first inc gets the initial state, which is 5, sets the state to 5+1 = 6, and then returns 5, which is the first element of that list
03:07:35 <Cale> then the second inc gets the state, which is now 6, sets the state to 7, and returns 6
03:07:37 <Cale> and so on.
03:08:26 <Cale> So sequence is a bit like a primordial loop: if we can decide what bunch of things we'd like to do ahead of time, sequence chains them together.
03:09:04 <Cale> By combining sequence with the standard list function 'map', we get something which looks an awful lot like a foreach loop:
03:09:18 <Cale> foreach xs f = sequence (map f xs)
03:09:41 <Cale> f here represents the 'body' of the loop, as a function from elements of the list to actions to be performed
03:09:53 <Cale> You'll find this function in Control.Monad, named forM
03:09:59 <Cale> forM [1..10] print
03:10:05 <Cale> Will print the numbers from 1 up to 10
03:10:30 <Cale> forM [1..10] $ \x -> do print x; getLine
03:10:48 <Cale> Will get 10 lines from the user, and collect them into a list.
03:11:25 <Cale> Hehe, is anyone still listening to this, or am I just rambling? :)
03:11:47 <osfameron> (I just checked back - got busy all of a sudden tho' :-)
03:11:48 <StoneToad> I'm reading it
03:11:53 <dreixel> can anyone suggest a simple way of rounding a Double to two decimal places? I don't like '(/ 100) . fromIntegral . (round :: Double -> Int). (* 10000)'
03:12:20 <dcoutts> Cale: sorry, I just woke up, what were you saying?
03:12:31 <quicksilver> dreixel: I'm sorry that you don't like it, but I think it's the best way :)
03:12:40 <dreixel> quicksilver: really?
03:12:49 <Cale> dcoutts: Did I highlight you?
03:13:20 <quicksilver> dreixel: well, it's a pretty concise description of the algorithm. You're free to give it a name if you like, for convenient use :)
03:13:42 <dcoutts> Cale: sorry, was just joking
03:13:46 <Cale> ah :)
03:13:50 <dreixel> it looks awful. at first I thought there should be some function roundN :: Int -> Double -> Int
03:14:10 <dreixel> (with RealFrac and Integral instead)
03:14:15 <StoneToad> dreixel: you just made one...
03:14:20 <dreixel> that would round to a number of places
03:14:21 <Cale> dcoutts: There was someone yesterday with a GTK problem, but we got a solution for him.
03:14:58 <dreixel> well, ok, I'll be happy, then.
03:14:59 <Cale> dcoutts: It was basically how to ignore repeated keypress events for the same key which were the result of the key being held down.
03:15:00 <dcoutts> jolly good
03:15:11 <quicksilver> dcoutts: something the GTK api doesn't appear to make very easy?
03:15:33 <Cale> We ended up storing the keys in a Data.Set.
03:16:01 <Cale> It would be interesting to know if there's a simpler way :)
03:16:24 <dcoutts> Cale: hmm
03:16:39 <dcoutts> aye, nothing immediately springs to mind
03:16:46 <pixel_> dreixel: (read . printf "%.2f") :: Double -> Double    \o/
03:17:15 <pixel_> (no kidding, that's the way people do it in perl...)
03:17:45 <dcoutts> perhaps it supports key down and up events
03:21:25 <dreixel> pixel_: at least it's shorter, but it's not really prettier :p
03:23:16 <fatalerrorx> how to convert int to char?
03:23:29 <fatalerrorx> @hoogle Int -> Char
03:23:29 <lambdabot> Data.Char chr :: Int -> Char
03:23:30 <lambdabot> Data.Char intToDigit :: Int -> Char
03:23:30 <lambdabot> Data.ByteString.Char8 index :: ByteString -> Int -> Char
03:24:05 <Axman6> > intoToChar 3
03:24:07 <lambdabot>   Not in scope: `intoToChar'
03:24:17 <Axman6> > intoToDigit 3
03:24:18 <lambdabot>   Not in scope: `intoToDigit'
03:24:26 <Axman6> > intToDigit 3
03:24:27 <lambdabot>   '3'
03:24:30 <Axman6> > intToDigit 30
03:24:32 <lambdabot>   * Exception: Char.intToDigit: not a digit 30
03:25:11 <RayNbow> > intToDigit $ 30 `div` 2
03:25:12 <lambdabot>   'f'
03:25:34 <Axman6> ah, hex digits then?
03:25:40 <RayNbow> yup
03:25:43 <Axman6> > map intToDigit [1..]
03:25:44 <lambdabot>   "123456789abcdef* Exception: Char.intToDigit: not a digit 16
03:25:50 <Axman6> handeh
03:27:38 <unenough> Cale, thanks, i was reading it
03:27:42 <unenough> with a lag
03:28:04 <unenough> by just hanging around here you learn alot
03:28:23 <Axman6> indeed
03:28:25 <EvilTerran> learning by osmosis!
03:29:06 <dcoutts> Cale: so you told the guy to use the onKeyPress and to use a set to track the set of keys that have been pressed without yet being released?
03:29:21 <quicksilver> dcoutts: yes.
03:29:24 <twb> EvilTerran: there's a Calvin and Hobbes cartoon about that
03:29:46 <unenough> there is no key-up event?
03:29:50 <twb> EvilTerran: they cut open Calvin's skull and scoop knowledge in, then let him go enjoy his childhood instead of being in school.
03:29:50 <unenough> key-down/key-up
03:30:36 <quicksilver> unenough: not directly, in GTK, apparently.
03:30:42 <quicksilver> which is kind-of X11's fault
03:30:47 <Cale> dcoutts: yeah
03:30:48 <quicksilver> because there isn't one, directly, in X11 either.
03:31:08 <quicksilver> X11's keyboard lib takes the view that autorepeat happens at a lower level
03:31:09 <twb> Er, xev can register KeyUp and KeyDown events separately
03:31:20 <quicksilver> twb: KeyPress and KeyRelease
03:31:25 <twb> Sorry, yes
03:31:30 <dcoutts> unenough: there is, but the keyboard repeat means you get multiple key pressed events if you hold a key down
03:31:30 <quicksilver> twb: and KeyPress is triggered by auto-repeating keys
03:31:34 <quicksilver> i.e. held down.
03:31:37 <twb> quicksilver: oh ew
03:31:40 <quicksilver> twb: so it's not really KeyDown.
03:31:54 <quicksilver> X11's keyboard lib takes the view that autorepeat happens at a lower level... and a well designed app isn't supposed to be able to tell the difference.
03:31:58 <quicksilver> Which is kind of fair enough, but not.
03:32:12 <EvilTerran> twb, well, i wouldn't really  call that osmosis
03:32:13 <twb> quicksilver: not even apps like xtest and xnee ? ;-)
03:32:30 <quicksilver> it does let a particular app turn key repeat off entirely, at which point KeyPress and KeyRelease really do mean KeyDown and KeyUp
03:32:34 <quicksilver> maybe games should do that.
03:32:38 <twb> EvilTerran: well, that would be the early adopter model
03:32:51 <quicksilver> ...but I'm not sure if GTK exposes that functionality.
03:32:52 <twb> quicksilver: I hate it when apps do that stuff
03:32:58 <quicksilver> well, quite.
03:33:03 <twb> quicksilver: or like when Flash issues a whole keyboard grab
03:33:17 <twb> So I can't use C-t b to move the mouse out of it to get Ratpoison to hear my keys again
03:33:22 <Cale> I've had trouble with various games not filtering keyboard events in this way, and ending up having sticky controls.
03:33:37 <Cale> (so I have to  xset r off  to get them to work)
03:33:40 <twb> Cale: I see that in VNC and RDP clients
03:36:35 <quicksilver> twb: well I think we're noisily agreeing.
03:36:46 <quicksilver> we *can* understand why xlib tries to be didactic about it.
03:36:54 <quicksilver> but we can also see the disadvantages of it
03:36:56 <quicksilver> *shrug*
03:42:45 <unenough> i disagree!
03:52:17 <unenough> does HAppS have some sort of templating language for HTML? or anything equivalent?
03:55:45 <_spm_Draget> http://rafb.net/p/TI2dDd28.html
03:55:47 <lambdabot> Title: Nopaste - No description
03:56:00 <_spm_Draget> Supposed to return always [1] for a non-empty graph
03:57:05 <Taejo> _spm_Draget: what is the type of inreach?
03:58:11 <_spm_Draget> It should return a list
03:58:31 <Taejo> _spm_Draget: it is a list? or it is a function that returns a list?
03:58:35 <BeelsebobWork_> @src forM_
03:58:35 <lambdabot> forM_ = flip mapM_
03:58:57 <Taejo> _spm_Draget: I'm assuming you want to know why it isn't typechecking?
03:59:08 * _spm_Draget nods ._.
03:59:30 <Taejo> _spm_Draget: inreach is a function taking two arguments, right?
03:59:46 <_spm_Draget> Yes Taejo
04:00:00 <Taejo> _spm_Draget: so give it two arguments
04:00:26 <_spm_Draget> Ah, sorry, silly me
04:01:29 <_spm_Draget> Thanks, it works.
04:02:03 <Taejo> _spm_Draget: sure
04:02:49 <Taejo> _spm_Draget: what exact error were you getting? (it should say something like "Probable cause: inreach is applied to too few arguments")
04:03:50 <_spm_Draget> Taejo: 'Couldn't match expected type `[Integer]' against inferred type `[Integer] -> [Integer] -> [Integer]' (ghc)
04:04:58 <_spm_Draget> ghc complains when I, for example, define inreach right after 'where' in the same line. According to a tutorial I have here, they put subfunction in the same line with where... maybe some other compiler accepts it. What would be 'correct' in haskell?
04:05:35 <Taejo> _spm_Draget: I think if your definition is only one line, you can put it immediately after
04:05:49 <Taejo> but I don't think I've ever seen anyone do that
04:06:36 <quicksilver> _spm_Draget: "ghc complains" isn't very helpful
04:06:57 <quicksilver> _spm_Draget: we need to see error messages and the code causing them
04:07:19 <quicksilver> putting 'where' on the same line as a declaration is permitted
04:07:35 <quicksilver> but it would be an error in some kind of layout block, because the where would be attaching to the wrong thing.
04:08:06 <_spm_Draget> quicksilver: :9:2: parse error on input `inreach'
04:08:35 <_spm_Draget> I see, thank you
04:08:37 <quicksilver> if it's exactly the code you've pasted
04:08:49 <quicksilver> then it's probably because 'where' introduces a layout block
04:08:56 <quicksilver> and the 'inreach' lines need to be indented to the right
04:08:57 <_spm_Draget> quicksilver: Yes, just with the inreach definition moved behind the where
04:08:59 <quicksilver> they need to be inside the where
04:09:13 <_spm_Draget> Ah, I understand
04:11:13 <_spm_Draget> Learning haskell is fun. I need to go now, tho.
04:11:16 <_spm_Draget> Thanks again
04:13:31 <b_jonas> hello
04:13:40 <b_jonas> > map (\x -> if (0/=x) then Just x else Nothing) [1, 0, 2, 3, 4, 5, 0, 0, 0, 4, 3, 2, 4]
04:13:41 <lambdabot>   [Just 1,Nothing,Just 2,Just 3,Just 4,Just 5,Nothing,Nothing,Nothing,Just 4,...
04:13:52 <b_jonas> is there a way to write this better?
04:14:30 <quicksilver> > map (\x -> guard (0/=x) >> return x) [1,0,2,3,4,5,0,0,0,4,3,2,4]
04:14:31 <lambdabot>       No instance for (Show (m a))
04:14:31 <lambdabot>        arising from a use of `show' at <in...
04:14:39 <quicksilver> > map (\x -> guard (0/=x) >> return x) [1,0,2,3,4,5,0,0,0,4,3,2,4] :: [Maybe Int]
04:14:41 <lambdabot>   [Just 1,Nothing,Just 2,Just 3,Just 4,Just 5,Nothing,Nothing,Nothing,Just 4,...
04:14:43 <b_jonas> ah, thanks
04:14:46 <quicksilver> FSOV 'better'
04:14:52 <b_jonas> I thought it had to be something like that
04:14:57 <b_jonas> but couldn't get it exactly
04:15:08 <b_jonas> makes sense
04:15:24 <b_jonas> the original channelnge was this:
04:15:52 <b_jonas> in a list of integers, replace zeros with the last nonzero number before it
04:15:56 <b_jonas> and I wrote this:
04:16:05 <b_jonas> > scanr1 mplus $ map (\x -> if (0/=x) then Just x else Nothing) [1, 0, 2, 3, 4, 5, 0, 0, 0, 4, 3, 2, 4]
04:16:07 <lambdabot>   [Just 1,Just 2,Just 2,Just 3,Just 4,Just 5,Just 4,Just 4,Just 4,Just 4,Just...
04:16:18 <b_jonas> > map fromJust . scanr1 mplus $ map (\x -> if (0/=x) then Just x else Nothing) [1, 0, 2, 3, 4, 5, 0, 0, 0, 4, 3, 2, 4]
04:16:19 <Axman6> @hoogle (a -> Bool) -> a -> Maybe a
04:16:19 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
04:16:19 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
04:16:19 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
04:16:20 <lambdabot>   [1,2,2,3,4,5,4,4,4,4,3,2,4]
04:16:58 <Axman6> [1,2,2,3...?
04:17:03 <Axman6> 2,2?
04:17:13 <b_jonas> uh
04:17:17 <Axman6> oh, sorted
04:17:19 <b_jonas> then it's wrong, yes
04:17:29 <b_jonas> this one copies from the right
04:17:31 <Axman6> no, not sorted
04:17:33 <b_jonas> whereas it should copy from the right
04:17:48 <b_jonas> > reverse . map fromJust . scanr1 mplus . map (\x -> if (0/=x) then Just x else Nothing) $ reverse [1, 0, 2, 3, 4, 5, 0, 0, 0, 4, 3, 2, 4]
04:17:50 <lambdabot>   [1,1,2,3,4,5,5,5,5,4,3,2,4]
04:18:00 <b_jonas> @define inp = [1, 0, 2, 3, 4, 5, 0, 0, 0, 4, 3, 2, 4]
04:18:29 <b_jonas> @define out = [1, 1, 2, 3, 4, 5, 5, 5, 5, 4, 3, 2, 4]
04:18:40 <b_jonas> > out == (reverse . map fromJust . scanr1 mplus . map (\x -> if (0/=x) then Just x else Nothing) $ reverse inp)
04:18:41 <lambdabot>   Not in scope: `inp'
04:18:54 <b_jonas> @let out = [1, 1, 2, 3, 4, 5, 5, 5, 5, 4, 3, 2, 4]
04:18:55 <lambdabot>  <local>:1:0:
04:18:55 <lambdabot>      Multiple declarations of `L.out'
04:18:55 <lambdabot>      Declared at: .L.hs:7...
04:19:07 <b_jonas> @let output = [1, 1, 2, 3, 4, 5, 5, 5, 5, 4, 3, 2, 4]
04:19:08 <lambdabot>  Defined.
04:19:17 <b_jonas> @let input = [1, 0, 2, 3, 4, 5, 0, 0, 0, 4, 3, 2, 4]
04:19:18 <lambdabot>  Defined.
04:19:23 <b_jonas> > out == (reverse . map fromJust . scanr1 mplus . map (\x -> if (0/=x) then Just x else Nothing) $ reverse inp)
04:19:24 <lambdabot>   Not in scope: `inp'
04:20:02 <b_jonas> ok, this doesn't work for me today :-)
04:20:46 <Axman6> b_jonas: would something like (map fromJust.filter (==Nothing)) be useful?
04:21:13 <Axman6> wait, no, totally forgot the original problem
04:21:30 <b_jonas> still it would be
04:21:43 <Axman6> well... good :)
04:21:47 <Axman6> getting something right today
04:21:53 <b_jonas> apart from the scanfold one like this there were two other kinds of solutions on the list
04:21:57 <Axman6> stupid statics bridge :(
04:22:09 <b_jonas> of course you'd just filter (0/=) in that case
04:22:15 <b_jonas> most probably
04:22:29 <Axman6> yeah, i was about to say that
04:23:30 <b_jonas> anyway, the two other principles are: generating a list of indices to that shorter filtered list; and cutting the list to chunks of a nonzero element and then a few zeros
04:23:56 <b_jonas> my first solution used indexing
04:24:03 <b_jonas> the scan didn't occurr to me at all
04:24:28 <b_jonas> I wrote the scan here only after I read such a solution
04:27:11 <ToRA|MSR> > let foo = \(x:xs) -> runRWS (forM xs (\x -> if (x == 0) then get >>= tell . (:[]) else (get >>= tell . (:[]) >> put x))) () x in let thd (_,x',x) = x ++ [x'] in thd . foo $ [1,1,1,0,0,0,2,0,3,0]
04:27:12 <lambdabot>   [1,1,1,1,1,1,2,2,3,3]
04:27:39 <b_jonas> tell? what's tell
04:27:42 <b_jonas> @type tell
04:27:43 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
04:27:53 <ToRA|MSR> i don't think it handles edge cases well
04:28:03 <ToRA|MSR> but it's a different approach to the problem
04:29:27 <Deewiant> > let foo = go Nothing where go _ [] = []; go l (0:xs) = fromJust l : go l xs; go l (x:xs) = x : go (Just x) xs in foo [1,0,2,3,4,5,0,0,0,4,3,2,4]
04:29:28 <lambdabot>   [1,1,2,3,4,5,5,5,5,4,3,2,4]
04:31:01 <saftarn> is it hard to install coq on ubuntu?
04:31:05 <saftarn> becuase i cant do it
04:31:05 <b_jonas> > concat $ zipWith replicate (map length $ groupBy (\x y -> 0==y) input) (filter (0/=) input)
04:31:06 <lambdabot>   [1,1,2,3,4,5,5,5,5,4,3,2,4]
04:31:18 <Axman6> ubuntu's full of coq
04:31:18 <Axman6> >_>
04:31:46 <b_jonas> this is the variant with cutting the list to chucks that comes out the most concise in J
04:31:56 <b_jonas> well, no
04:31:58 <b_jonas> second most concise
04:32:04 <b_jonas> the most concise is the scan one actually
04:32:06 <mapreduce> saftarn: No, because I have done it already and forgotten that I have.
04:32:15 <mapreduce> (I was going to install it just now to answer your question)
04:32:35 <b_jonas> but I think that one might be sacrificing speed for conciseness becasue it's quadratic time
04:33:57 <b_jonas> yeah, it is quadratic time
04:34:02 <b_jonas> just checked
04:34:07 <b_jonas> probably has a linear time version too
04:34:49 <mapreduce> Stop! Quadratic time!
04:34:54 <opqdonut> :D
04:34:55 <mapreduce> Not quite the same ring to it.
04:34:57 <opqdonut> :D:D
04:35:57 <lilac> can't compute this!
04:37:46 <b_jonas> yeah, I could write a linear time version of it easily
04:38:10 <b_jonas> but I'm not sure you can make that one more concise than the replicate one
04:38:14 <b_jonas> at least in J
04:38:38 <b_jonas> in imperative languages solutions similar to the scan one come out the most concise
04:38:57 <Taejo> @djinn doubleneg ? a -> Not (Not a)
04:38:57 <lambdabot> Cannot parse command
04:39:04 <Taejo> @djinn
04:39:04 <lambdabot> Cannot parse command
04:39:58 <b_jonas> I've no idea what RWS does
04:40:10 <b_jonas> so I don't understand that solution
04:41:27 <quicksilver> RWS is just reader writer and state together
04:41:31 <lilac> @djinn a -> Not (Not a)
04:41:31 <lambdabot> f a b = b a
04:41:41 <Taejo> lilac: thanks
04:41:47 <b_jonas> quicksilver: you mean completely unconnected?
04:41:53 <Taejo> :t \a b -> b a
04:41:54 <lambdabot> forall t t1. t -> (t -> t1) -> t1
04:41:57 <quicksilver> yes.
04:42:06 <b_jonas> ok, I'll try to read it like that then
04:42:07 <quuxman> playing around with Factor... how I long for a real type system. This function takes a "model" (equiv. to Haskell's IORef I believe), but doesn't say a model of WHAT
04:42:10 <quicksilver> ReaderT r WriterT w StateT s Identity
04:42:14 <quicksilver> modulo some parens
04:42:58 <quuxman> guess I should go join #factor
04:43:49 <mapreduce> quuxman: #concatenative
04:43:56 <quuxman> mapreduce: apparently their aliased
04:44:13 <mapreduce> Ah.
04:44:48 <mapreduce> I believe there is an experiment to create a statically typed Factor, but that it didn't get very far.
04:45:05 <quuxman> but I must say, Factor's UI rules... I like the search and built in help
04:45:12 <mapreduce> To some extent it is statically typed, in that stack effects are statically checked.
04:45:28 <mapreduce> it being Factor.
04:46:47 <Axman6> i just started downloading the google tech talk on factor... right before you started talking about it
04:46:54 <Axman6> i'd never heard of it before
04:47:14 * Axman6 blames reddit
04:48:31 <quuxman> Axman6: I heard about Factor and downloaded it a year ago or so, but then I found Haskell...
04:48:44 <Axman6> heh
04:50:55 <quuxman> @seen humasect
04:50:56 <lambdabot> I saw humasect leaving #haskell-overflow 13d 5h 58m 36s ago, and .
04:53:18 <mapreduce> Axman6: I listened to most of that yesterday.. it was strange to see someone on video who I had removed from IRC channels. :)
04:53:36 <Axman6> ha. why was that?
04:53:59 <mapreduce> He used to post segoat or something.  Unscrambling is for the reader.
04:54:21 <Axman6> heh
04:54:24 <quuxman> that doesn't make sense
04:54:57 <mapreduce> Slava was a known troll, probably until he started working on factor properly.  He was never particularly malicious though.
04:55:07 <mapreduce> And always obviously intelligent.
04:55:40 <quicksilver> Oh. I thought you were saying humasect was a troll.
04:55:44 <quicksilver> that didn't sound right :)
04:56:10 <Axman6> "Tests are for people who don't believe in themselves."
04:56:40 <mapreduce> Axman6: They are for me then.
04:57:02 <mapreduce> Though I'm reasonably sure I'm real.
04:57:49 * arjanb likes the idea of concatenative languages but they are too pointless for me to use
04:58:11 <Axman6> http://tinyurl.com/6zao4v
04:58:13 <lambdabot> Title: tirdun comments on What is your worst programming habit?
04:59:36 <mapreduce> arjanb: I see what you did there, very good.
05:00:27 <b_jonas> > evalState (mapM (\x -> do { if 0 /= x then put x else return (); get }) input) 0
05:00:28 <lambdabot>   [1,1,2,3,4,5,5,5,5,4,3,2,4]
05:00:46 <b_jonas> this is the scan solution that is quite concise in imperative languages
05:00:54 <b_jonas> it's not too bad in haskell too
05:04:20 <quuxman> for certain things, tests really do make sense, but most of the code I write I don't bother
05:05:16 <quuxman> automated tests that is
05:07:21 <mr_H> hello
05:07:27 <Axman6> o/
05:07:35 <mr_H> i have a list of strings, how do i remove the entries that are composed of only spaces ?
05:07:49 <mr_H> like \n\t and stuff like that
05:08:01 <Cale> filter (not . all isSpace)
05:08:15 <ziman> how readable ;)
05:08:16 <mr_H> :D
05:08:35 <Cale> > filter (not . all isSpace) ["\n\t", "Hello \n", "   "]
05:08:36 <lambdabot>   ["Hello \n"]
05:08:51 <Cale> isSpace is in Data.Char
05:08:54 <mr_H> and how do i remove trailing spaces in entries ?
05:09:15 <quuxman> along with a whole bunch of other handy unicode functions
05:09:19 <Beelsebob> > reverse . dropWhile isSpace . reverse "Hello \n"
05:09:20 <lambdabot>   Couldn't match expected type `a -> [Char]'
05:09:23 <mr_H> allright :)
05:09:26 <Beelsebob> > reverse . dropWhile isSpace . reverse $ "Hello \n"
05:09:27 <lambdabot>   "Hello"
05:09:41 <Axman6> if (isSpace.last) str then [] else last str
05:09:43 <Axman6> or something
05:12:17 <Beelsebob> > filter (not . null) . map (reverse . dropWhile isSpace . reverse) $ ["\n\t", "Hello \n", "  "]
05:12:18 <lambdabot>   ["Hello"]
05:12:39 <_andre> > takeWhile (not.isSpace) "Hello  \n"
05:12:40 <lambdabot>   "Hello"
05:12:57 <Beelsebob> > takeWhile (not . isSpace) "Hello world \n"
05:12:59 <lambdabot>   "Hello"
05:13:04 <Axman6> > takewhile (not.isSpace) "hello world "
05:13:05 <lambdabot>   Not in scope: `takewhile'
05:13:08 <quicksilver> Beelsebob lost the world :(
05:13:11 <Axman6> god damn it Beelsebob!
05:13:19 * Beelsebob pwns Axman6, yet again
05:13:22 <Axman6> i hate you so much, stop doing that!
05:14:01 <mr_H> you guys are l33t :D
05:14:29 <mr_H> i shall isolate myself and meditate on haskell list functions in order to achieve enlightment
05:15:10 <Axman6> you'll find that talking in here is far more productive
05:15:21 <Beelsebob> not always
05:15:44 <kaol> @arr
05:15:44 <lambdabot> Yeh scurvy dog...
05:17:44 <mr_H> when ghci outputs error messages, i sometimes find myself exchanging all '.' operators for '$' operators
05:17:56 <mr_H> much like a noob in C exchanging all * for & :P
05:18:01 <mr_H> thats how i feel
05:18:06 <Axman6> i do that a lot :\
05:18:11 <quicksilver> I suspect that isn't guaranteed to fix all errors :)
05:18:15 <mr_H> :D
05:18:22 <mr_H> quicksilver: you suspect well
05:18:54 <Axman6> $ saves more typing than (.)
05:18:54 <Axman6> (f.g.h) x, f$g$h$x
05:19:18 <PeakerWork> f.g.h$x
05:19:29 <PeakerWork> . is easier than $ :)
05:19:33 <osfameron> and less fugly
05:19:41 <Axman6> and . leads to strange code like ((.).f) ...
05:19:53 <Axman6> PeakerWork: yeah i do that too
05:20:21 <quuxman> partial application of compose always confuses me for some reason
05:20:35 <Axman6> f x.g $ y?
05:21:14 <PeakerWork> (f.).g  kind of confused me too, still
05:21:21 <PeakerWork> confuses
05:22:19 <Cale> ((f .) . g) x y = (f .) (g x) y = (f . g x) y = f (g x y)
05:22:56 <lilac> @type (\f -> fmap f) :: (b -> c) -> (a -> b) -> (a -> c)
05:22:57 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
05:22:58 <lilac> @type \f -> (f.)
05:22:59 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
05:23:04 <Cale> So you can think of this partial application as delaying the parameters from getting to f, allowing g to eat them.
05:23:15 <lilac> (f.) is just fmap for reader
05:23:22 <mr_H> ouch
05:23:28 <mr_H> that is too much sand for my truck
05:23:29 <Cale> (.) is just fmap for reader
05:23:36 <lilac> that too :)
05:24:10 <mr_H> grr, im scratching my brain trying to understand this
05:24:15 <lilac> so (f.).g == fmap f . g
05:24:47 <Cale> (((f .) .) . g) x y z = ((f .) .) (g x) y z = ((f .) . g x) y z = (f .) (g x y) z = (f . g x y) z = f (g x y z)
05:24:56 <b_jonas> yeah, makes sense
05:26:20 <Axman6> that's horrible
05:26:42 <mr_H> what does fmap do ? :P
05:26:44 <PeakerWork> Cale: Thanks. I will have to run it through probably a few more times to really remember this deduction ;)
05:26:52 <mr_H> isn't it the same as map ?
05:26:59 <lilac> map is fmap for lists
05:27:01 <b_jonas> mr_H: more general
05:27:12 <b_jonas> mr_H: fmap is a generalization of liftM
05:27:17 <mr_H> ah
05:27:22 <mr_H> what is liftM ?
05:27:29 <b_jonas> for lists, it's map
05:27:34 <Cale> hehe
05:27:40 <Axman6> :t liftM
05:27:41 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
05:27:51 <b_jonas> @src liftM
05:27:51 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
05:27:57 <mr_H> i dont understand kinds
05:28:05 <mr_H> ah ok
05:28:09 <Axman6> you should learn to ;)
05:28:11 <b_jonas> don't read the kind then, read only the part after the forall
05:28:16 <Axman6> they're very very very useful
05:28:19 <b_jonas> after the forall dot that is
05:28:24 * quuxman feels like making a reference to the rabbit hole
05:28:30 <ziman> > cycle "map, which is fmap for lists, which is generalized "
05:28:31 <lambdabot>   "map, which is fmap for lists, which is generalized map, which is fmap for ...
05:28:32 <mr_H> it lifts monad and applies function to its content
05:28:34 <Cale> mr_H: Suppose we have some structure datatype f. For example, f = List or f = Tree or f = IO. Then fmap :: (a -> b) -> (f a -> f b)
05:28:58 <mr_H> ahh
05:29:00 <Cale> Basically you can think of it as applying the function to all the elements of the structure.
05:29:05 <mr_H> clear as water :)
05:29:09 <mr_H> thanks :)
05:29:28 <mr_H> that is very useful indeed
05:29:45 <mr_H> so (.) is fmap for "reader"
05:29:47 <mr_H> what is reader ?
05:29:49 <b_jonas> I don't understand Functors so I just think of it as liftM except that it also maps through the snd of a (,)
05:29:52 <Axman6> > fmap (+1) (Just 3)
05:29:52 <Cale> Of course, what the "elements" mean is a little hazy sometimes.
05:29:53 <lambdabot>   Just 4
05:30:01 <b_jonas> mr_H: reader is the (->)s monad/functor
05:30:02 <Cale> For functions from a fixed type, it's the elements of the codomain.
05:30:10 <Cale> (or the range, if you prefer)
05:30:33 <PeakerWork> mr_H: If you consider a function to be a "box" that contains its result value,  and "fmap" as something that applies a function to box contents, then "fmap" on a function applies a function to a function's result.
05:30:46 <Cale> So fmap f g  is the function which applies f to the result of applying g
05:31:04 <Cale> That is,  fmap f g x = f (g x)
05:31:10 <Cale> So fmap f g = f . g
05:31:18 <mr_H> yes
05:31:21 <mr_H> good
05:31:40 <Cale> I've suggested quite often that we use . as notation for fmap, for this reason.
05:31:40 <mr_H> i dont recall using the (->)
05:31:45 <mr_H> only on lambdas
05:32:27 <mr_H> nice :)
05:32:27 <Cale> (since it's such a nice notation, and fmap is such an important operation with composition as an important special case)
05:32:40 <mr_H> now i understand yes
05:32:44 <b_jonas> mr_H: in this case, (->) is the type constructor for functions in prefix notation: (->) a b is the same as a -> b
05:32:53 <mr_H> ill have to practice it in order not to loose this understanding though
05:33:01 <b_jonas> mr_H: so (->) a is a higher-order type that maps b to a -> b
05:33:10 <mr_H> ah ok ok
05:33:24 <mr_H> haskell is full of logic
05:34:04 <Cale> So, that is, if f = (->) e, then  fmap :: (a -> b) -> ((->) e a -> (->) e b)
05:34:05 <Cale> which is
05:34:16 <Cale> fmap :: (a -> b) -> (e -> a) -> (e -> b)
05:34:30 <Cale> and that *must* be composition :)
05:35:22 <mr_H> yes
05:35:48 <Axman6> i remember defining that using that monad definition thing from... that tony guy's blog...
05:36:46 <Cale> This (->) e is not only a functor, but also a monad, and so we can write things like:
05:37:02 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "Hello"
05:37:03 <lambdabot>   ("Hello","olleH","HELLO")
05:37:10 <mr_H> but the -> is not really an operator, just an "indicator" right ?
05:37:18 <Cale> It's an operator on types.
05:37:20 <mr_H> a "type operator"
05:37:23 <mr_H> yes
05:37:24 <mr_H> that
05:37:43 <mr_H> so yes, it makes perfect sense
05:37:44 <mr_H> cool
05:37:44 <mr_H> :D
05:37:51 <mr_H> i have learn't something today
05:37:56 <mr_H> learnt
05:37:58 <mr_H> whatever
05:38:00 <mr_H> :P
05:38:02 <Cale> :)
05:45:01 <mapreduce> Learnt in British English, learned otherwise.
05:45:06 <quuxman> Cale: a silly way to say: map ($ "Hello") [id, map toUpper, reverse]
05:46:06 <quuxman> er, mr_H... Cale is obviously aware of that
05:47:01 <Axman6> mapreduce: you make it sound like learnt is somehow incorrect
05:48:50 <mapreduce> It is, in US English, as far as I know.
05:49:09 <mapreduce> Wikipedia concurs.
05:49:22 <Axman6> there's no such thing as US English, there's just English, and incorrect english
05:49:26 <mr_H> have learned is correct ?
05:49:30 <Philippa> Axman6: bullshit
05:49:32 <mapreduce> Axman6: Rubbish.
05:49:39 <Axman6> bullshit nothing
05:49:40 <mr_H> Axman6: nazi style ? :P
05:49:59 <mr_H> aren't we the little nazi :D
05:50:03 <Philippa> Axman6: I don't see an Academie Anglaise...
05:50:13 <mapreduce> vive l'oignon
05:50:18 <b_jonas> @type (learned, learnt)
05:50:19 <lambdabot> Not in scope: `learned'
05:50:19 <lambdabot> Not in scope: `learnt'
05:50:24 <b_jonas> so both are wrong
05:50:40 <Axman6> the changes americans have made to english are to typically american, lazy and unnecessary
05:50:53 <mapreduce> Axman6: Not completely.
05:51:09 <Philippa> Axman6: drop the nationalist crap. Doubly so given that some of them are /absences/ of changes that happened in British/Commonwealth English
05:51:14 <mapreduce> Many words we think of as British came to us via the Americans.  It is not as simple as that.
05:51:30 <Axman6> and it frustrates me when people try and tell me i'm wrong when i use correct english
05:51:35 <mapreduce> E.g., roger (meaning to sodomise), is a word from America.
05:51:41 <Philippa> so you'll return the favour? Idiot
05:52:07 <mapreduce> Axman6: So tell them that your word is correctly spelled in the dialect of English you're using.
05:52:16 <Axman6> i'll do the same because there are defined spellings for things, and american ignore them
05:52:21 <mr_H> lunch time
05:52:22 <mr_H> bye
05:52:27 <Philippa> like I said, there's no Academie Anglaise
05:52:40 <Philippa> there's just a bunch of dictionaries, all produced by individuals with no actual authority
05:52:58 <Axman6> bah
05:53:11 <Philippa> hell, do you really want us to do things more like the French? :-)
05:53:16 <mapreduce> (The academie francaise controls French.  A similar organisation exists for Spanish)
05:53:32 <b_jonas> I prefer the french way actually
05:53:50 * Philippa very much doesn't
05:53:56 <Axman6> and it has nothing to do with nationalism. i'm australian, and i couldn't give a crap about the british most of the time. but adding ize to words? totally unnecessary, and dropping u's because people are lazy
05:53:59 <b_jonas> even on one side of the ocean, there are lots of things no-one can agree how to write in English
05:54:00 <Philippa> English thrives on being a mongrel, just like the nation does
05:54:19 <mapreduce> Axman6: Back when England owned America, English used ize.
05:54:20 <b_jonas> eg. how do you spell Masters degree
05:54:21 <Philippa> Axman6: actually they drop it because in US accents they don't pronounce the us either
05:54:35 <b_jonas> master, masters, master's, and how to capitalize
05:54:40 <b_jonas> noone agrees
05:54:45 <b_jonas> it just sucks
05:54:50 <Axman6> Philippa: that's not an excuse for spelling it inccorrectly
05:55:07 <mapreduce> Axman6: I recommend Bill Bryson's book about English, whose name escapes me.
05:55:16 <Philippa> @quote axman6 "Philippa: that's not an excuse for spelling it inccorrectly"
05:55:16 <lambdabot> No quotes for this person. stty: unknown mode: doofus
05:55:20 <Philippa> @addquote axman6 "Philippa: that's not an excuse for spelling it inccorrectly"
05:55:21 <lambdabot> Unknown command, try @list
05:55:25 <mapreduce> Made in America.
05:55:52 <Axman6> Philippa: how very mature
05:55:54 <Philippa> @remember axman6 "Philippa: that's not an excuse for spelling it inccorrectly"
05:55:55 <lambdabot> Done.
05:55:58 <mapreduce> It is quite balanced, he's lived in the UK and Australia too, so don't expect it to be a jingoing "woohoo for the US" book.
05:56:01 * quicksilver laughs
05:56:04 <Philippa> welcome to the quotebot, that's what it's for
05:56:12 <quicksilver> Axman6: think you might be taking things a little seriously? ;)
05:56:21 <b_jonas> in addittion, the french academy did remove all the stupid exceptions from spelling from French in the spelling reform
05:56:28 <pyNem> how do I power a rational number to a rational number?
05:56:31 <b_jonas> so now French spelling is logical, with no exceptions
05:56:39 <b_jonas> of course, it wouldn't be possible to do that with English
05:56:46 <mapreduce> b_jonas: The British government did the same at one point.
05:56:48 <b_jonas> for you don't just have to remove a few exceptions there
05:56:54 <Philippa> yeah. I'll dig up the James Nicoll quote, shall I?
05:57:02 <b_jonas> but still I like the idea of a central academy
05:57:02 <cnwdup> How can I make this list ["foobar", 2] valid as an argument which is passed to a function expecting forall a. (PrintfArg a) => [a]?
05:57:05 <Axman6> quicksilver: i find stupidity very frustrating at times
05:57:09 <b_jonas> that's what we have for Hungarian too
05:57:19 <mapreduce> b_jonas: How do you make it central?  Stick it in the Atlantic?
05:57:22 <Philippa> b_jonas: I don't think it's so appropriate for natural languages
05:57:45 <b_jonas> mapreduce: you could have one per country then
05:58:09 <Twey> 125337 < Axman6> and it has nothing to do with nationalism. i'm australian, and i couldn't give a crap about the british most  of the time. but adding ize to words? totally unnecessary, and dropping u's because people are lazy
05:58:10 <b_jonas> mapreduce: a separate one in the UK, one in US, one in Canada, one in Oz, etc
05:58:10 <mapreduce> b_jonas: For the UK you can reasonably count the Oxford English Dictionary as that.
05:58:16 <b_jonas> even that would be better than no authority
05:58:29 <Philippa> mapreduce: nah, there's more to a language than vocab
05:58:31 <byorgey> pyNem: use **
05:58:31 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
05:58:36 <Twey> Axman6: They don't seem to understand that 'ou' is a digroph for schwa :(
05:58:37 <quicksilver> Axman6: you certainly won't find stupidity in Philippa; you won't find much in #haskell.
05:58:40 <byorgey> > (3%4) ** (1%2)
05:58:40 <mapreduce> The English dictionaries in the UK are more snapshots of language than definitions of language.
05:58:41 <lambdabot>       No instance for (Floating (Ratio t))
05:58:41 <lambdabot>        arising from a use of `**' ...
05:58:48 <b_jonas> mapreduce: I should check out the OED once
05:58:49 <byorgey> > (3%4) ** (1/2)
05:58:50 <lambdabot>       No instance for (Floating (Ratio t))
05:58:50 <lambdabot>        arising from a use of `**' ...
05:58:51 <Philippa> “The problem with defending the purity of the English language is that English is about as pure as a cribhouse whore. We don’t just borrow words; on occasion, English has pursued other languages down alleyways to beat them unconscious and rifle their pockets for new vocabulary.” - James Nicoll
05:59:05 <b_jonas> I've never seen it actually and I've no idea if it's a good dictionary or a bad one
05:59:05 <byorgey> > (3/4) ** (1/2)
05:59:10 <lambdabot>   0.8660254037844386
05:59:10 <quicksilver> cnwdup: ["foobar",2] is (probably) not a valid argument for anything.
05:59:15 <byorgey> there we go =)
05:59:16 <Twey> Axman6: So you end up with words like 'color' that look like they should be pronounced [koloÉ¹]
05:59:18 <mapreduce> I used to enjoy chasing words in cheap dictionaries, looking for a definition that used a w2ord not defined.
05:59:21 <mapreduce> s/2//
05:59:21 <Axman6> quicksilver: i wasn't implying Philippa was stupid, though he was implying i way
05:59:22 <Twey> Philippa: Bwahahaha!  :-D
05:59:28 <quicksilver> cnwdup: it's only valid in the presence of an instance Num String.
05:59:37 <quicksilver> cnwdup: ...which probably isn't something you have or want.
05:59:42 <Philippa> Axman6: oh boy. Some english speaker you are...
05:59:48 <mapreduce> Axman6: Philippa might not be a 'he'.
05:59:50 <Philippa> wrong pronoun, I think you'll find
06:00:00 <Twey> Heh
06:00:11 <Philippa> mapreduce: in fact, it's pretty unlikely to find a Philippa who is
06:00:12 * Twey likes 've'/'ver'/'vis'
06:00:21 <Philippa> Twey: I ain't virtual :-)
06:00:23 <cnwdup> quicksilver: It should be transformed to [UPrintf "foobar", UPrintf 2] by calling (map toUPrintf ["foobar", 2]). But I'd like to move that step to the function and not to everywhere I call the function. Is this possible?
06:00:29 <b_jonas> what the shit is happening? mokka.hu search is down
06:00:37 <mapreduce> Philippa: Yes, it's probably not the most common of names for transexuals. :)
06:00:37 <quicksilver> cnwdup: No, it should not be.
06:00:59 <cnwdup> quicksilver: Ok
06:01:03 <quicksilver> cnwdup: ["foobar",2::Int] is not a valid haskell term
06:01:05 <Philippa> mapreduce: I think you'll find the appropriate way to address a a trans woman is "she", too
06:01:09 <Twey> Philippa: Doesn't matter, gender-neutrality = love :-P
06:01:19 <Axman6> like many people on irc, i don't tend to read people's nicks to the point where they go into thinking about their sex. think of it as lazy evalation
06:01:21 <quicksilver> cnwdup: all elements of a list have the same type.
06:01:28 <quuxman> hm, I don't think there's a built-in way to exponentiate Ratios
06:01:34 <Twey> Axman6: Another argument for gender-neutral pronouns!
06:01:36 <Philippa> Twey: Singular they's by far the best choice in general practice though
06:01:45 <Philippa> yeah. Which "he" very much isn't
06:01:46 <byorgey> quuxman: you can raise a Rational to an integral power
06:01:46 <cnwdup> quicksilver: Yeah, I thought I could bypass that in this situation as it'd be useful as far as I can see.
06:01:55 <byorgey> > (3%4) ^ 3
06:01:56 <lambdabot>   27%64
06:02:02 <byorgey> > (3%4) ^^ -3
06:02:03 <lambdabot>       precedence parsing error
06:02:03 <lambdabot>          cannot mix `(^^)' [infixr 8] and pref...
06:02:07 <Twey> Philippa: And alas, it will remain thus until we bring 've' into general usage :-P
06:02:07 <byorgey> > (3%4) ^^ (-3)
06:02:09 <lambdabot>   64%27
06:02:14 * Twey evangelises.
06:02:25 <byorgey> but you can't raise a Rational to a Rational, because in general you might not get another Rational as a result.
06:02:48 <quicksilver> cnwdup: there may be ways to bypasss it. But not using the list type.
06:02:48 <b_jonas> is OED a good dictionary? should I check it out at some point?
06:03:00 <quicksilver> cnwdup: it is, in a sense, an 'hole' in the language.
06:03:00 <mapreduce> b_jonas: It is.
06:03:03 <Axman6> i also mistook the rudeness to be charastic of a man, most women on IRC are far less agressive
06:03:05 <Twey> Philippa: I'm trying to spread it a little, and having luck mostly with intellectuals :-\
06:03:13 <byorgey> ^ is for positive integer powers, ^^ is for any integer power, and ** is for general floating-point exponentiation
06:03:16 <b_jonas> I hate how Webster's have long chains of definitions where a word is defined using an equally obscure word
06:03:17 <quuxman> byorgey: ah duh. It'd have to be Ratio -> Ratio -> Either Ratio Rational -- :)
06:03:22 <Twey> b_jonas: It's the closest thing to a definitive dictionary English has :-P
06:03:31 <quicksilver> cnwdup: that you can't necessarily factor [f a, f b] into map f [a,b]
06:03:37 <Philippa> Twey: Like I said, I ain't virtual. Yes, I did read Diaspora :-) Realistically the spivak pronouns're next in line in that people have a fairly easy time understanding them in speech, and after that probably ze/hir's the most commonly used - in rather limited circles, much as it's fairly frequent on e.g. alt.polyamory
06:03:38 <byorgey> quuxman: yes, you could write a function with that type.
06:03:41 <quicksilver> cnwdup: (if a and b have different types)
06:03:47 <b_jonas> Twey: what I mean is, is it usable casually, or is it only for professionals?
06:03:56 <b_jonas> I have a really good Longman dictionary
06:04:01 <quuxman> pyNem: does that answer your question?
06:04:03 <cnwdup> quicksilver: Ok. Think I'll just have to live with that.
06:04:04 <byorgey> quuxman: er, I think you mean Either Double Rational
06:04:05 <quicksilver> cnwdup: but that's a consequence of some good things about the haskell type sysems ;)
06:04:07 <byorgey> or something like that
06:04:28 <Philippa> b_jonas: yeah, I do have to wonder how many contractions the OED bothers with - a'ight, for example
06:04:43 <quuxman> byorgey: yes, that's what I meant :-P
06:04:48 <Twey> Philippa: The Spivaks are very daft, I find, since it's common to omit the 'th' from plural pronouns in rapid/dialectical speech
06:04:59 <mapreduce> I don't have my dictionaries to hand, otherwise I'd answer.
06:05:02 <b_jonas> otoh, I have seen an ugly circular definition in MÃ‰K (the definitive dictionary for Hungarian) too which defined two words from each other so you couldn't figure out the meaning
06:05:13 <Twey> b_jonas: Yes, I find it quite usable.
06:05:23 <Philippa> Twey: eh, same issue as singular they. But that's also why they make sense to people with less educational effort: they get parsed as if they were singular they
06:05:58 <mapreduce> I find it a little annoying that I don't get some form of digital access to dead-tree books that I buy.
06:06:00 <Twey> Philippa: I think that only exacerbates the problem
06:06:03 <b_jonas> I'll look at OED in some library then, I think I haven't yet seen it in a bookstore or used book store but if I might start looking for it more
06:06:08 <pyNem> byorgey, quuxman I thought so too
06:06:13 <BrokenClockwork> what's my first place to go, when I want to look up for already defined functions of the haskel lib?
06:06:15 <pyNem> But, it doesnt quite work here..
06:06:20 <pyNem> let me just put up the code on hpaste
06:06:22 <Philippa> Twey: Like I said, plenty of historical precedent for singular they
06:06:26 <byorgey> pyNem: ok
06:06:31 <mapreduce> BrokenClockwork: hoogle
06:06:31 <quicksilver> BrokenClockwork: haskell.org/hoogle is handy
06:06:33 <Twey> Sure, lots, but I don't like overloading words that way
06:06:38 <smtms> mapreduce, O'Reilly offers digital access to its printed books
06:06:38 * Cale likes singular they.
06:06:46 <quicksilver> BrokenClockwork: so is http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
06:06:47 <lambdabot> Title: Haskell Hierarchical Libraries
06:06:50 <BrokenClockwork> thx quicksilver
06:06:54 <Twey> It's more about technical advantages than historical precedent
06:06:59 <mapreduce> smtms: I think the only O'Reilly books I have are review copies.
06:07:04 <Philippa> tbh, I think making it usable is more important. People can already use singular they, indeed they already do
06:07:21 <Twey> I think that usability will come with wider adoption
06:07:35 <quuxman> BrokenClockwork: hayoo is an improved hoogle, btw
06:07:47 <Philippa> well yes, it's just that wider adoption won't happen at all quickly. You're talking something that'd take more than a generation
06:07:52 <b_jonas> by the way, Hungarian also recently has lots of really bad dictionaries that are produced very cheaply from some stolen century old public domain dictionary
06:07:53 <Twey> Of course
06:07:55 <pyNem> byorgey, quuxman http://hpaste.org/11602
06:08:02 <Twey> But if we try, it might happen
06:08:06 <Philippa> whereas frankly, we need GNPs now
06:08:15 <b_jonas> they're trying to seel them to parents of schoolchildren who don't know what to buy
06:08:27 <Twey> It's still *usable*, one just has to explain the concept every so often
06:08:46 <Philippa> trust me, that's not usable. I meet this in practice - a good friend of mine locally doesn't /have/ a gender, for example
06:09:04 <Twey> Sure
06:09:05 <byorgey> pyNem: eh?  (a/b)^(c/d) is not equal to (a^b)/(c^d)
06:09:10 <b_jonas> lots of those fake dictionaries are labeled "AkadÃ©miai" (academy) whereas the real MÃ‰K, while it is published by the Magyar TudomÃ¡nyos AkadÃ©mia, does not actually say "AkadÃ©mia" on it
06:09:24 <Philippa> hell, if you've poked around for pages about GNPs you've probably read their old web site at some point
06:09:31 <Twey> The old FAQ?
06:09:47 <b_jonas> (a/b)^(c/d) doesn't even typecheck, does it?
06:09:50 <byorgey> pyNem: if you want to allow ^ and stay within Rationals then you will have to disallow anything but integers as exponents
06:09:51 <b_jonas> @type (a/b)^(c/d)
06:09:52 <lambdabot> Expr
06:09:58 <quicksilver> @type (^)
06:09:59 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
06:10:01 <byorgey> b_jonas: well, no, I meant as a mathematical equation, not Haskell syntax
06:10:05 <b_jonas> @type (a_/b_)^(c_/d_)
06:10:06 <lambdabot> Not in scope: `a_'
06:10:06 <lambdabot> Not in scope: `b_'
06:10:06 <lambdabot> Not in scope: `c_'
06:10:17 <b_jonas> @type \a b c d -> (a/b)^(c/d)
06:10:18 <lambdabot> forall a a1. (Integral a1, Fractional a1, Fractional a) => a -> a -> a1 -> a1 -> a
06:10:36 <Twey> But 've' seems perfectly comprehensible to me, even without prior knowledge â€” it follows English syntax for pronouns, it's not 'he' or 'she', so the chances are it's gender-neutral
06:10:40 <byorgey> pyNem: i.e. check if the denominator of the exponent is 1, if so use ^^ to raise the lhs to the power of the numerator of the rhs, otherwise return Nothing
06:10:46 <Philippa> I don't think they hosted that one as opposed to an article enumerating the known examples at the time and explaining their preference. They wrote a few other FAQs though, including setting out a definition of asexual that turned into something of a new identity
06:10:48 <dolio> @src Integral
06:10:48 <lambdabot> class  (Real a, Enum a) => Integral a  where
06:10:48 <lambdabot>     quot, rem, div, mod :: a -> a -> a
06:10:48 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
06:10:48 <lambdabot>     toInteger           :: a -> Integer
06:10:59 <b_jonas> I for one like the ey--em--eir spivaks
06:10:59 <byorgey> pyNem: otherwise, if you want general exponents, you will have to use Double instead of Rational
06:11:14 <Philippa> Twey: yeah, but it doesn't actually work like that for everyone - some people do trip on unfamiliar vocab
06:11:48 <b_jonas> but it might be that those only work in writing (like irc)
06:11:53 <Twey> Philippa: That's where the brief educational bit comes in
06:11:56 <pyNem> byorgey, I know it isnt, I was just checking if that can be done .. I was going to rewrite it to another form including sqrt
06:12:02 <Philippa> Twey: no, it's not. Some people need more than brief
06:12:07 <Twey> Philippa: I find if you just say 'gender-neutral pronoun' most people go 'oh, OK'
06:12:18 <byorgey> pyNem: ok, well, the reason it is failing right now is that ^ is only for positive exponents
06:12:18 <Twey> Some people do, aye
06:12:25 <byorgey> pyNem: use ^^ to allow negative integer exponents too
06:12:32 <Twey> But... it's worth a few minutes of wasted time to explain it, in my opinion :)
06:12:40 <Philippa> Twey: that's a lot less the case amongst native english speakers, especially those who were poor at languages at school
06:12:46 <Twey> (I think that may be something of an oxymoron...)
06:12:50 <quicksilver> pyNem: what are you actauly hoping to achieve?
06:12:52 <Philippa> I'm telling you it takes more than a few minutes of explanation for many people
06:13:05 <quicksilver> pyNem: You do appreciate the reason the function is segmented?
06:13:09 <Twey> Philippa: How long?
06:13:12 <b_jonas> Does "ve" work for foriegn people who can't pronounce "w" properly?
06:13:16 <Philippa> potentially years of reinforcement
06:13:33 <Twey> But doesn't that also apply to existing vocabulary used in new ways?
06:13:46 <Philippa> it's a much lesser burden, and it's also /already used that way/
06:14:08 <byorgey> sorry, can the discussion of pronouns be taken to -blah?
06:14:11 <Philippa> I've seen it in the UI of popular web sites
06:14:12 <Philippa> sure
06:14:14 <Twey> Sorry, sure
06:14:18 <byorgey> np, thanks
06:14:41 <b_jonas> byorgey: good idea
06:15:43 <byorgey> pyNem: any number can be raised to a positive integer power -- it's just repeated multiplication
06:15:46 <byorgey> @type (^)
06:15:47 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
06:16:16 <quicksilver> basically ^ only requires (*), ^^ requires (/) and ** requires exp/log
06:16:20 <pyNem> quicksilver, I dont actually appreciate the segmentation
06:16:25 <Axman6> @where CReal
06:16:25 <lambdabot> I know nothing about creal.
06:16:26 <pyNem> oh
06:16:27 <byorgey> but only sets of numbers with multiplicative inverses can be raised to a negative power
06:16:31 <Axman6> @index CReal
06:16:31 <lambdabot> bzzt
06:16:32 <pyNem> obviously
06:16:35 <Axman6> bleh
06:16:36 <byorgey> since e.g.  2^(-3) == 1/2^3
06:16:43 <byorgey> @type (^^)
06:16:44 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
06:16:45 <pyNem> the field must have an inverse for ^^
06:16:48 <byorgey> right
06:16:48 <quicksilver> right
06:16:54 <quicksilver> so we're out of Integral
06:16:59 <quicksilver> and in to Fractional.
06:17:01 <pyNem> (sorry, was on the phone till now)
06:17:03 <pyNem> quicksilver, yeah
06:17:05 <byorgey> so the different operators put different restrictions on the classes of arguments you can give them
06:17:10 <pyNem> byorgey, agreed
06:17:12 <quicksilver> Then for irrational powers you need transcendentals
06:17:17 <pyNem> quicksilver, agreed
06:17:23 <quicksilver> hence the segmentation.
06:17:24 <Axman6> anyone know how to :m CReal in ghci?
06:17:50 <pyNem> byorgey, so to implement Rational^Rational, ill have to use approx after that?
06:18:03 <pyNem> :t approxRational
06:18:05 <lambdabot> forall a. (RealFrac a) => a -> a -> Rational
06:18:08 <byorgey> right, Rational^Rational might not be rational.
06:18:16 <Axman6> @hoogle CReal
06:18:16 <lambdabot> No results found
06:18:18 <Cale> (e.g. 2^(1/2))
06:18:22 <byorgey> e.g.  3^(1/2) = sqrt(3) which is irrational.
06:18:22 <Axman6> bah!
06:18:27 <pyNem> Cale yeah got that :)
06:18:42 <pyNem> Hm.. the problem I am trying to solve is four Fours
06:18:51 <pyNem> with just +, *, -, and /
06:18:58 <pyNem> I dont get too many answers
06:19:44 <pyNem> can someone explain the heirarchy of the classes, Floating, Real, Fractional, etc.. ?
06:20:21 <Cale> http://haskell.org/onlinereport/basic.html#standard-classes
06:20:21 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
06:20:27 <Cale> there's a diagram around there
06:20:33 <pyNem> thanks Cale
06:20:43 <Cale> Also, if you look at the Prelude, you'll see what operations are in each
06:20:48 <pyNem> byorgey, quicksilver, so my safest bet is powering only if it x%1 ?
06:20:59 <pyNem> Cale, oh .. thanks :)
06:21:41 <byorgey> pyNem: yes, that, or if you really want you can convert both to Double, do the exponentiation with **, then apply approxRational to the result
06:22:04 <byorgey> but since the goal is to get nice integer results (right?) it is unlikely to be helpful to do the latter
06:22:19 <byorgey> so restricting to only integer powers seems reasonable
06:23:00 <pyNem> byorgey, hm.. ok
06:23:10 <pyNem> makes sense ..
06:23:17 <pyNem> byorgey, thanks a lot :)
06:23:20 <janimo> what are the criteria for having some functions in lazy but not in the strict bytestring libs? like having replicate in Prelude and both bytestrings but cycle and repeat only in Prelude and Lazy?
06:23:23 <gal_bolle> did some progress get made on the cabal-debian front?
06:23:27 <byorgey> pyNem: you're welcome =)
06:23:56 <pastorn> i want to sleep
06:24:02 <pastorn> how do i go about that?
06:24:38 <pyNem> oh, btw, why cant i load a program into ghci with :l once I write a main ?
06:24:54 <pastorn> found nothing on sleep on hoogle and not anything useful when searching for "Int -> IO ()"
06:25:12 <quicksilver> pastorn: threadDelay
06:25:15 <mapreduce> @hoogle IO () -> IO ()
06:25:15 <lambdabot> System.Mem.Weak addFinalizer :: key -> IO () -> IO ()
06:25:15 <lambdabot> Control.Concurrent.MVar addMVarFinalizer :: MVar a -> IO () -> IO ()
06:25:15 <lambdabot> Foreign.Concurrent addForeignPtrFinalizer :: ForeignPtr a -> IO () -> IO ()
06:25:23 <quicksilver> (it might be interesting to ask why you want to sleep)
06:25:24 <mapreduce> @hoogle threadDelay
06:25:24 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
06:25:33 <Cale> pastorn: You lay down and close your eyes. :)
06:25:33 <mapreduce> @hoogle Int -> IO ()
06:25:33 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
06:25:33 <lambdabot> Control.Concurrent.QSemN signalQSemN :: QSemN -> Int -> IO ()
06:25:33 <lambdabot> Control.Concurrent.QSemN waitQSemN :: QSemN -> Int -> IO ()
06:25:46 <Cale> But, uh, yeah, threadDelay :)
06:25:49 <pastorn> quicksilver: thanks
06:25:54 <Badger> Cale: bad, bad, bad. :P
06:26:12 <mapreduce> threadDelay is the top link on the hoogle site too.
06:26:15 <int-e> pyNem: that's odd. loading should work. (you still have to execute 'main' yourself though)
06:27:18 <dmwit> janimo: Strict ByteStrings are strict.
06:27:37 <pastorn> Cale: oh, i thought that was something different as it was in Control.Concurrent and not in System.Thread or System.IO
06:27:41 <dmwit> janimo: Cycle/repeat (which would make infinite ByteStrings) doesn't really make sense.
06:28:26 <Cale> pastorn: Yeah, if you're writing a single threaded program, it just delays the only thread.
06:29:33 <pastorn> cool
06:29:46 <janimo> dmwit: I guess it makes sense
06:30:12 <janimo> dmwit: your answer I mean :)
06:34:10 <janimo> dmwit: any idea why splitAt's first arg is Int for strict and Int64 for the lazy bytestring function?
06:34:34 <quuxman> pyNem: you can "execute" the program with the ":main" command too
06:34:45 <quicksilver> janimo: because strict bytestrings can only be as big as Ints
06:34:56 <quicksilver> janimo: whilst lazies can be bigger :)
06:35:00 <janimo> I wonder if these differences are there to make switching the APIs hard and make one think of the solution beforehand
06:35:02 <pyNem> int-e, quuxman yeah .. it works.. (wonder why i was having problems yesterday with another program)
06:35:41 <quicksilver> janimo: I don't think so. I think they're there to indicate real differences.
06:35:55 <quicksilver> The fact that strict bytestrings can only be as long as an Int is a fact!
06:36:27 <janimo> quicksilver: ok, makes sense
06:37:13 <janimo> I was trying to use network-bytestring and had to change the previous uses of lazy to strict
06:37:34 <janimo> as I could not match them
06:38:19 <BrokenClockwork1> How do I stanll Yi? It says "get it from Hackage. Configure, compile and install Yi as you would do for any other Cabal package. "
06:39:14 <lilac> why does lazy bytestring use Int64 not Integer for splitAt?
06:41:04 <quuxman> BrokenClockwork1: cabal install Yi
06:41:32 <quuxman> BrokenClockwork1: (assuming you have cabal-install installed of course)
06:41:57 <quicksilver> lilac: fairly good question.
06:42:04 <quicksilver> lilac: efficiency/speed I guess
06:42:32 <BrokenClockwork1> oh, I think I cant get it, ebcaue Wikipedia says "minimal windows support" ?
06:42:50 <dcoutts> lilac: if you can make a lazy bytestring that's longer than an int64 can hold I'll be very impressed
06:43:19 <gal_bolle> how do i uninstall packages with cabal?
06:43:36 <Cale> Data.ByteString.Lazy.repeat 'a'
06:43:42 <Cale> er...
06:43:46 <Cale> Something like that
06:43:48 <quicksilver> dcoutts: cycle (pack "hidcoutts")
06:44:15 <dcoutts> quicksilver: that's not quite the same thing of course
06:44:47 <quicksilver> well it is and it isn't.
06:45:15 <quicksilver> it's certainly a lazy bytestring that you could legitimately index at an index beyond maxBound :: Int64
06:45:21 <quicksilver> of course, it would be rather slow to do so.
06:45:42 <dcoutts> right
06:45:49 <quuxman> how do I install a specific version of a package?
06:46:08 <dcoutts> quuxman: cabal install foo-1.0
06:48:25 <maltem> dcoutts: I suppose whether Int64 has been the right choice will depend on how well murphy's law applies :)
06:50:22 <maltem> er, moore's law, even
06:50:27 <maltem> but murphy's too :)
06:51:12 <dcoutts> maltem: all you need to demonstrate it was bad choice is 8,388,608 terabytes of data :-)
06:51:13 <gal_bolle> i'm trying to install yi, but i get a conflict in bytestrings. www.haskell.org/yi tells me to remove any old version of yi i have, but i don't know how to do that
06:51:59 <quuxman> gal_bolle: ghc-pkg unregister ...
06:52:03 <maltem> dcoutts: You don't know the system requirements of Windows 9 yet! :)
06:52:13 <dcoutts> gal_bolle: it might work anyway, if the configure warning is just for bytestring then ignore it and carry on with the build step
06:52:14 <gal_bolle> quuxman: thanks
06:52:24 <dcoutts> maltem: heh heh :-)
06:52:27 <gal_bolle> that's all cabal needs?
06:52:42 <gal_bolle> maybe cabal remove pkg should be an alias for it
06:53:03 <gal_bolle> dcoutts i think it's an error, not a warning
06:53:06 <dcoutts> gal_bolle: huh? I don't understand
06:53:07 <gal_bolle> let me see
06:53:24 <dcoutts> gal_bolle: the conflict problem is not related to there being any existing version of yi installed
06:53:46 <gal_bolle> ok, when i do a cabal install yi, i get the conflict
06:54:06 <gal_bolle> and when i do runhaskell Setup.hs configure, it tells me dependencies are missing
06:54:09 <gal_bolle> which i have
06:54:13 <dcoutts> gal_bolle: ah, then use cabal configure && cabal build && cabal install --only
06:54:40 <gal_bolle> that works, great
06:54:40 <maltem> gal_bolle: cabal install implies --user
06:54:43 <gal_bolle> many thanks
06:54:50 <pyNem> what is the simplest way I can use lhs2tex on a file?
06:55:09 <maltem> pyNem: er, `lhs2tex file`?
06:55:10 <pyNem> I get a lot of errors when I simply do lhs2TeX file.lhs > texfile.tex ; latex texfile.tex
06:55:11 <ivanm> what's this --only flag? cabal install --help doesn't list it :s
06:55:28 <maltem> pyNem: ah, you need an %include in your file
06:55:30 <dcoutts> ivanm: shh, it's a secret
06:55:34 <ivanm> ahhhh
06:55:42 <ivanm> what's it do? doesn't rebuild deps?
06:56:13 <dcoutts> ivanm: it's used internally by cabal install --root-cmd
06:56:55 <dcoutts> ivanm: but it's handy in this case to avoid going via the dep resolver which does not let you proceed if there are dep conflicts
06:57:29 <dcoutts> and yi gets plenty of dep conflicts which just by luck turn out to be false positives
06:57:36 <ivanm> how come?
06:57:41 <ivanm> cabal's fault or yi's fault?
06:57:55 <dcoutts> depends on your point of view :-)
06:58:01 <dcoutts> I think it's yi's fault :-)
06:58:06 <maltem> ivanm: yi requires quite specific versions of some packages
06:58:10 <dcoutts> it really does require two versions of bytestring
06:58:15 <ivanm> oh, and is there any way to get cabal to stop complaining about not being able to find base==4 for HUnit when doing "cabal upgrade"?
06:58:20 <ivanm> maltem: *nod*
06:58:26 <ivanm> dcoutts: :o
06:58:32 <dcoutts> which cabal's dep resolver is specifically trying to avoid, because it cannot be sure it'll work, and it usually doesn't
06:58:51 <ivanm> why would you need 2 versions of a lib?
06:58:55 <ivanm> isn't that a Bad Thing?
06:59:08 <dcoutts> ivanm: it's only a bad thing if it fails
06:59:31 <ivanm> oh.... I thought the diamond dependency problem was the result of multi-versions :s
06:59:42 <dcoutts> and cabal-install pretty much has to make the conservative assumption that it will fail
06:59:51 <dcoutts> it doesn't have enough info to know when it'll actually work
07:00:05 <quicksilver> ivanm: it only matters if the two usages of the doubled-up library try to talk to each other.
07:00:10 <quicksilver> (but cabal can't tell)
07:00:21 <dcoutts> ivanm: re hunit, yes, there is. The answer is to poke me to upload the fixed version.
07:00:30 <ivanm> ahhh
07:00:34 <ivanm> dcoutts: poke!
07:00:36 <ivanm> dcoutts: poke!
07:00:37 <ivanm> dcoutts: poke!
07:00:47 <ivanm> happy now? :P
07:00:51 * Botje joins the fun
07:00:54 <Botje> dcoutts: poke!
07:00:54 <Botje> dcoutts: poke!
07:00:55 <Botje> dcoutts: poke!
07:01:07 <dcoutts> ivanm: no, sorry, I've got another 4000 emails to download :-)
07:01:12 <ivanm> lambdabot needs a @poke command
07:01:14 <ivanm> dcoutts: heh
07:01:17 <dcoutts> my adsl doesn't do multi-tasking
07:01:25 <ivanm> well, you're just under half way...
07:01:27 <ivanm> :o
07:02:53 <pyNem> maltem i have %include lhs2TeX.fmt %include lhs2TeX.sty at the top of my file
07:04:23 <ivanm> is there an command in the normal libraries that I can use to replace all '.' with '-' in a String?
07:04:44 <ivanm> (a map with an if statement?)
07:05:01 <pyNem> ivanm, a list comprehnesion?
07:05:09 <dcoutts> ivanm: yep, just use a map
07:05:19 <ivanm> pyNem: that would just be a map anyway ;-)
07:05:38 <pyNem> ivanm, yeah .. but easier on the eye, if you are doing a lot
07:05:49 * ivanm begs to differ
07:05:50 <dcoutts> ivanm: map dotToDash blah where dotToDash '.' = '-'; dotToDash c = c
07:05:59 <maltem> pyNem: hm. well what are the errors?
07:06:00 <ivanm> yeah, just did that ;-)
07:06:14 <ivanm> pyNem: maps are chainable, maps are pointfree, etc.
07:06:54 <pyNem> maltem, one of the first i get is l.14 \usepackage{ amstext}?
07:07:39 <ivanm> you don't have amslatex installed? :o
07:08:05 <pyNem> ivanm, I am new to this, :D
07:08:38 <ivanm> ahhhh
07:08:46 <maltem> pyNem: ah so you're just missing some latex package(s)
07:09:04 * ivanm thought amslatex came with most tex distributions by default :s
07:09:17 <pyNem> malcolmw, ivanm where can i find this on a deb system (a search for asm brings nothing relavant)
07:10:09 <ivanm> ams, not asm
07:10:12 <ivanm> ;-)
07:10:22 <ivanm> you're using texlive or tetex?
07:10:25 <byorgey> pyNem: maybe that's supposed to be \usepackage{amstex} instead of {amstext} ?
07:10:42 <maltem> pyNem: on ubuntu it's in texlive-latex-base, but it looks like you're not using texlive
07:10:47 <byorgey> oh, nvm, this is output from lhs2tex?
07:10:51 <ivanm> byorgey: ahh, that's probably it
07:11:07 <ivanm> pyNem: what byorgey said
07:11:16 <maltem> byorgey: there's also amstext
07:11:25 <ivanm> maltem: is there? I can't find it...
07:11:35 <ivanm> take it back, I can
07:11:37 <byorgey> ok, I believe you
07:11:46 <maltem> not sure what it's about, but it is there :) /usr/share/texmf-texlive/tex/latex/amsmath/amstext.sty in my case
07:11:53 <ivanm> @slap the person who wrote the dodgy texmfind script
07:11:53 * lambdabot will count to five...
07:13:44 <pyNem> maltem, ivanm i still dont understand
07:14:17 <ivanm> ignore what I just said :p
07:15:14 <pyNem> ivanm, http://hpaste.org/11603
07:15:17 <pyNem> that is my lhs file
07:15:28 <pyNem> I thought, if ran lhs2tex and latexed it, it would work
07:16:12 <ivanm> pyNem: I think you still need \documentclass, etc. in there
07:16:20 <pyNem> ivanm, oh ..
07:16:20 <maltem> pyNem: oh you also have to format it as a latex document
07:16:26 <ivanm> but I only used lhs2tex once, and that was last year
07:16:45 <pyNem> ivanm, so .. it seems to suck for documenting small haskell programs
07:16:54 <ivanm> pyNem: depends
07:16:58 <ivanm> on what you want ;-)
07:17:06 <ivanm> and how you define "suck"
07:17:09 <maltem> yeah you need at least \documentclass..., \begin{document}, \end{document}
07:17:11 <pyNem> ivanm, agreed.. it gives you total control
07:17:17 <pyNem> maltem, ivanm know an alternative for smaller programs?
07:17:27 <ivanm> then again, lhs2tex is only really good if you want a fully formatted document version of your code
07:17:35 <ivanm> e.g. for a paper
07:17:41 <ivanm> pyNem: just document it?
07:17:49 <ivanm> or do you want to create an article?
07:17:53 <ivanm> pandoc is an alternative...
07:17:55 <pyNem> ivanm, create an article
07:18:03 <pyNem> oh .. ivanm .. how do i use that?
07:18:14 <ivanm> if you produce html, it can do syntax highlighting
07:18:15 * maltem was going to suggest pandoc too
07:18:20 <ivanm> @go pandoc
07:18:26 <lambdabot> http://johnmacfarlane.net/pandoc/
07:18:26 <lambdabot> Title: Pandoc
07:18:37 <ivanm> but lhs2tex would probably be better
07:18:43 <ivanm> alternatively, use standard tex with listings
07:19:12 <pyNem> ivanm, yeah .. thought about that
07:19:14 * ivanm uses listings for code snippets in his thesis, but all the code is defined elsewhere
07:19:15 <maltem> there is a problem with pandoc though, it interprets ">" lines as blockquotes
07:19:27 <maltem> (that is, markdown does)
07:19:32 <ivanm> oh, in that case it won't be a runnable file
07:19:48 <ivanm> or does it support the tex-style literate stuff?
07:20:01 <ivanm> IIRC, pandoc uses ~~~~~~~ for code delimeters
07:20:36 <maltem> ivanm: ah I think pandoc accepts tex syntax embedded in markdown
07:20:58 <ivanm> maltem: no, I meant the \begin{code}...\end{code} method for literate haskell
07:21:34 <maltem> ivanm: yeah wouldn't that be tex syntax?
07:21:40 <ivanm> *shrug*
07:21:57 <ivanm> pyNem: no matter what you use, the [(Operator,'+'), etc. stuff  won't be printed as code
07:22:19 <ivanm> so you'd probably want to wrap it in a \verb|...|
07:22:27 <pyNem> ivanm  .. oh ..
07:22:27 <ivanm> at the very least
07:22:39 <maltem> pandoc is just missing a reader for a document "like markdown, but literate code"
07:22:45 <ivanm> if you're using tex-based
07:23:25 <ivanm> pyNem: you'd be better off coding it elsewhere, then using something like the listings environment and copy/pasting code where you want it
07:23:38 <pyNem> ivanm, hm..
07:23:49 <pyNem> how about if i wanted to convert this to say, a blog post?
07:23:50 <pyNem> just curious
07:24:02 <ivanm> or if you use the \begin{code}...\end{code} format, then you can have it as a .lhs file, with all the latex stuff around it
07:24:11 <ivanm> pyNem: in that case, it depends on what your blog engine is
07:24:13 <kosmikus> pyNem: for some reason it's a common misconception that lhs2TeX will magically insert TeX commands. this is not the case. lhs2TeX has to be run on a LaTeX document that is valid except for Haskell code.
07:24:23 <ivanm> since each one of them uses a different delimeter for code AFAIK
07:24:38 <ivanm> so speaketh kosmikus :p
07:24:46 * ivanm should hit the sack
07:24:47 <ivanm> g'night all
07:25:00 <pyNem> ivanm, oh .. thanks .. gnite
07:25:04 <pyNem> kosmikus, oh ..
07:25:28 <kosmikus> pyNem: look at the manual for examples.
07:25:32 <pyNem> kosmikus, isnt there anything, which will say, even give me a pdf with different formatting for the code, and otherwise for a simple lhs document
07:26:26 <kosmikus> pyNem: you mean fully automatic? I wouldn't know.
07:27:23 <pyNem> kosmikus, hm.. thanks :)
07:27:32 * pyNem has to go for dinner now .. it is _late_
07:27:34 <pyNem> seeya people
07:27:37 <pyNem> thnx
07:38:06 <jcpetruzza> hi, i'm having a strange problem using cabal
07:38:25 <jcpetruzza> i have a library code that works fine as long as i don't install it
07:38:38 <jcpetruzza> (install it as a proper library, i mean)
07:39:05 <Cale> what happens when you do install it?
07:39:06 <jcpetruzza> once i install it and try to use it, i get some linker error
07:39:18 <jcpetruzza> unknown symbol `___stginit_hintzm0zi3zi0zi0_HintziGHC_'
07:39:24 <Cale> --make ?
07:39:53 <jcpetruzza> when loading it in ghci
07:39:57 <Cale> In order to use a package, you need to either specify --make on the GHC commandline, or an appropriate package flag, like -package hint
07:40:01 <jcpetruzza> or using it with runhaskell
07:40:05 <Cale> hmm
07:40:14 <Cale> Okay, that's strange then.
07:40:38 <jcpetruzza> Cale: it used to work! but after some refactoring, i started to get this :S
07:41:53 <Cale> hmm
07:42:29 <jrh> I have a variable that I'm updating continuously from a thread -- replacing the contents every 10th of a second or so (timing's unimportant as long as it's fast).  Would I rather use an MVar or a TVar for this?  I'm reading only from one other thread.
07:43:00 <quicksilver> jrh: I suppose an MVar would be 'simpler'
07:43:17 <quicksilver> TVar is really for the case that you read more than one thing and you want to guarantee a consistent read set.
07:43:21 <quicksilver> (without locking)
07:43:22 <bd_> jrh: Can you afford to 'miss' an update? Is it okay to read the same value more than once?
07:43:36 <quicksilver> in practice you could use either though.
07:43:37 <jrh> quicksilver: why?  It looks like the simplicity would be the same.  I don't care about missing updates at all
07:43:41 <Cale> You might even want a SampleVar
07:43:53 <quicksilver> jrh: simpler in the sense that MVar is plain IO
07:43:55 <jrh> SampleVar, Cale?
07:44:00 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-SampleVar.html
07:44:01 <lambdabot> Title: Control.Concurrent.SampleVar, http://tinyurl.com/57k2gb
07:44:04 <quicksilver> jrh: and TVar requires you to wrap it up in atomically
07:44:10 <quicksilver> jrh: not a big problem I admit :)
07:44:31 <quicksilver> Cale: Ooh. that one is new isn't it?
07:44:35 <quicksilver> FSOV 'new'
07:44:44 <Cale> It's actually been there for quite some time.
07:44:54 <jrh> actually, SampleVar's exactly what I want
07:44:54 <Cale> But it's rarely used for some reason.
07:44:59 <jrh> thanks Cale
07:45:05 <Cale> no problem
07:45:31 <bd_> what's the purpose of the readers field in the samplevar implementation?
07:45:54 <bd_> just to implement isEmpty without races?
07:46:09 <nominolo|msr> @seen tibbe
07:46:09 <lambdabot> I saw tibbe leaving #xmonad, #ghc and #haskell 6h 36m 32s ago, and .
07:58:44 <nominolo|msr> nice piece from the Parsec source: ParsecT $ \s -> liftM (fmap (liftM (fmap f))) (runParsecT p s)
07:58:44 <nominolo|msr>  
07:59:07 <nominolo|msr> :t liftM . fmap . liftM . fmap
07:59:08 <lambdabot> forall (m :: * -> *) (f :: * -> *) (m1 :: * -> *) a b (f1 :: * -> *). (Functor f1, Monad m1, Functor f, Monad m) => (a -> b) -> m (f (m1 (f1 a))) -> m (f (m1 (f1 b)))
07:59:34 <Philippa> nominolo: heh. I wouldn't be surprised if the liftMs correspond to one monad and the fmaps the other
07:59:34 <nominolo|msr> isn't liftM = fmap?
07:59:41 <Philippa> not guaranteed
07:59:48 <Philippa> you can't use fmap for Monads in general
08:00:15 <nominolo|msr> Philippa: but that's mostly a bug
08:00:21 <quicksilver> I make it a rule to use fmap in general
08:00:24 <quicksilver> or <$>
08:00:27 <telexicon> always reinventing the wheel
08:00:28 <quicksilver> and add any missing instances.
08:00:34 <ziman> why? aren't Monads Functors, too?
08:00:36 <nominolo|msr> Philippa: shouldn't we have class Functor m => Monad m ?
08:01:10 <Cale> We indeed should have that, but it seems we're all too scared to change the Prelude :P
08:02:52 <Philippa> nominolo: we shouldn't be requiring it in libraries when the Monad interface doesn't require it
08:03:49 * byorgey isn't scared to change the Prelude!
08:03:55 * byorgey unilaterally changes the Prelude
08:04:15 <Cale> yay!
08:04:22 * byorgey renames "Monad" to "ByorgeyRocks"
08:04:28 <Cale> boo!
08:04:30 <byorgey> and also makes it require Functor
08:04:35 <Cale> yay!
08:04:37 * quicksilver doesn't understand what Philippa means by 'the Monad interface doesn't require it'
08:05:05 <Cale> Monad is not technically a subclass of Functor, even though this is the case.
08:05:55 <quicksilver> code which is polymorphic over "some Functor f" should also run on monads.
08:06:02 <quicksilver> therefore is is a BUG if there is a monad which is not a Functor.
08:06:06 <quicksilver> that's my opinion.
08:06:20 <lilac> ParsecT $ \s -> (fmap ^ 4) f $ runParsecT p s
08:06:24 <quicksilver> (and it's a bug in the Prelude that we don't enforce this rulee)
08:06:27 <nominolo|msr> @tell tibbe I (mostly) solved the Parser on Enumerator issue
08:06:28 <lambdabot> Consider it noted.
08:06:29 <ziman> isn't, given a monad, there always also a functor given by fmap = (>>= (return . f)) ?
08:06:40 <Cale> fmap = liftM
08:06:44 <byorgey> ziman: indeed.
08:07:03 <lilac> but there being a functor does not imply that there's a Functor
08:07:06 <nominolo|msr> @tell tibbe I so should put that on my blog :)
08:07:06 <lambdabot> Consider it noted.
08:07:34 <byorgey> fmap ^ 4 ?
08:08:24 <quicksilver> fmap . fmap . fmap . fmap
08:08:34 <byorgey> hehe, if only that worked =)
08:08:58 <byorgey> not that I ever have much cause to iterate a function some fixed number of times
08:09:07 <mauke> fmap `fmap` fmap `fmap` fmap `fmap` fmap
08:09:09 <lilac> if only you could just say 'fmap' in such cases
08:09:34 <quicksilver> lilac: you can, sort of.
08:09:43 <byorgey> lilac: I think such trickery exists, somewhere
08:09:47 <byorgey> @google deep fmap
08:09:50 <lambdabot> http://okmij.org/ftp/Haskell/typecast.html
08:09:50 <lambdabot> Title: Type improvement constraint
08:09:51 <lilac> mauke: fmap fmap (fmap fmap (fmap fmap fmap)) ?
08:09:57 <quicksilver> data TypeCompose f g a = O (f (g a))
08:10:10 <quicksilver> instance Functor f, Functor g => Functor (O f g)
08:10:15 <byorgey> ah, that too
08:10:20 <quicksilver> -- this is more simple minded that the deep fmap stuff.
08:11:01 <byorgey> does the deep fmap stuff infer the correct 'level' at which to apply the function based on the type?
08:11:29 <lilac> mauke: fmap fmap `fmap` fmap fmap `fmap` fmap fmap $ fmap
08:11:34 <byorgey> that would be sweet, obviously the type composition can't do that
08:12:11 <nominolo|msr> mauke: that dangerously looks like "fap fap fap"
08:12:22 <Valodim> fmap fmap fmap?
08:12:24 <Valodim> haha, great
08:12:47 <lilac> fmaps and brackets: a universal model of computation?
08:13:59 <BMeph> t: fmap fmap `fmap` fmap fmap `fmap` fmap fmap $ fmap
08:14:33 <quicksilver> CEILING CAT IS WATCHING YOU FMAP
08:14:56 <dolio> @yow!
08:14:57 <lambdabot> World War Three can be averted by adherence to a strictly enforced dress code!
08:15:17 <mauke> http://macrochan.org/search.py?tag=Animals%3ADogs%3AAdvice%20Dog
08:15:18 <lambdabot> Title: Macrochan
08:22:49 <Philippa> nominolo: what was the fix with the parsing issue, btw?
08:23:11 <Philippa> Parsec3's internals are still a tad odd, it could probably use refactoring for readability (especially where it's fmapping four deep)
08:27:15 <nominolo|msr> Philippa: well, using Koen Claessen's parallel parsing processes it's just another interpreter for the core combinators
08:27:34 <nominolo|msr> Philippa: I use:
08:27:38 <nominolo|msr> newtype Iter a m r = Iter { runIter :: r -> a -> m (Either r (r, Iter a m r)) }
08:27:38 <nominolo|msr> newtype Enum m a = Enum (forall r. Iter a m r -> r -> m r)
08:27:38 <nominolo|msr>  
08:28:34 <nominolo|msr> Philippa: i didn't look at translating try, though
08:28:46 <nominolo|msr> and I have no lookahead combinator yet
08:29:26 <nominolo|msr> Koen kind of cheated by giving the lookahead combinator the whole remaining input
08:32:16 <matthew-_> which module defines Num ?
08:32:48 <matthew-_> ahh, I see, it's still in prelude
08:33:07 <matthew-_> but is actually implemented in GHC.Num
08:33:40 <quicksilver> the Prelude exports it
08:33:50 <quicksilver> but just becase you export something doesn't mean you have implemented it ;)
08:36:51 <paghots> testing. please ignore.
08:36:53 <paghots> thanks.
08:37:27 <paghots> @urnick: testing.
08:37:28 <lambdabot> Unknown command, try @list
08:38:43 <tromp__> > 24*8/60
08:38:44 <lambdabot>   3.2
08:39:15 <nominolo|msr> > 24*8/60 :: Rational Int
08:39:16 <lambdabot>       Kind error: `Rational' is applied to too many type arguments
08:39:16 <lambdabot>      In th...
08:39:27 <nominolo|msr> > 24*8/60 :: Rational
08:39:28 <lambdabot>   16%5
08:39:51 <mr_H> check it: http://calculist.blogspot.com/2008/10/sweet.html
08:50:24 <xhanjian> > 16%5
08:50:25 <lambdabot>   16%5
08:50:36 <xhanjian> >:t 16%5
08:50:46 <xhanjian> > :t 16%5
08:50:47 <lambdabot>   <no location info>: parse error on input `:'
08:50:58 <xhanjian> :t 16%5
08:50:59 <lambdabot> forall t. (Integral t) => Ratio t
09:03:01 <dons> did everyone see the super mario bros impl. video in haskell? http://www.reddit.com/r/programming/comments/7aap0/making_super_nario_bros_in_haskell_youtube/
09:03:02 <xenoblitz> How possibile is it in gtk2hs to make a key event close an old timer event and create a newer one, sort of reset it but with a different time
09:03:03 <lambdabot> Title: Making 'Super Nario Bros.' in Haskell - YouTube : programming, http://tinyurl.com/69cxv3
09:03:11 <mr_H> i did dons :)
09:03:13 <mr_H> amazing
09:03:32 <mr_H> i really liked the level design in text :)
09:03:43 <mr_H> smart
09:03:45 <dcoutts> xenoblitz: quite possible
09:03:58 <dcoutts> xenoblitz: just delete the old timer and make a new one
09:04:49 <xenoblitz> dcoutts: just a sec as I am being AMAZED at this youtube video
09:04:55 <xenoblitz> dcoutts: lol
09:04:59 <dcoutts> heh
09:05:33 <mr_H> what is so special about reddit ?
09:05:41 <mr_H> i keep seeing lots of links to it
09:05:51 <dons> mr_H: its a useful community url aggregation/submission site
09:06:36 <mr_H> oh nice
09:06:52 <thoughtpolice> dons: did you see slava's tech talk? really neat.
09:07:07 <dons> thoughtpolice: he's giving one at galois in 2 hrs
09:07:10 <mr_H> now, haskell related, how do i insert a new line in a list of strings, after each string that contains a digit ?
09:07:19 <thoughtpolice> dons: ! :]
09:07:27 <mr_H> ["hi", "123", "there"]
09:07:33 <mauke> concatMap (
09:08:33 <mauke> concatMap (\x -> if containsDigit x then [x, "\n"] else [x])
09:08:52 <lilac> containsDigit = any isDigit
09:08:54 <mr_H> :D
09:09:01 <xenoblitz> dcoutts: hi again... i have made such an attempted but I am stuck on something really minor ... let me hpaste
09:09:02 <mr_H> oh
09:09:07 <mr_H> i want "all isDigit"
09:09:11 <mr_H> yes
09:09:12 <mr_H> thanks :D
09:09:29 <mauke> not (any (not . isDigit))
09:09:33 <lilac> lol
09:09:36 <mr_H> :)
09:09:40 <mr_H> okey
09:09:54 <xenoblitz> dcoutts: http://hpaste.org/11605
09:10:06 <lilac> where any f xs = not (all (not . f) xs)
09:10:10 <ToRA|MSR> xenoblitz: have a look at timeoutRemove in System.Glib.MainLoop
09:10:24 <xenoblitz> dcoutts: I would like to return the HandlerId so that I can change it
09:10:42 <BeelsebobWork_> what's the best way to get cabal to bundle files with a library, but not actually ever touch them?
09:10:48 <xenoblitz> ToRA|MSR: ok I shall, but if you can spot what I am doing wrong here: http://hpaste.org/11605
09:11:01 <dcoutts> xenoblitz: then store the handler id in a reference
09:11:22 <dcoutts> BeelsebobWork_: do you mean to include them in the sdist tarball, or do you mean to have them installed with the lib, like data files?
09:11:28 <jrh> dcoutts: would it be possible sometime to change the argument order in idleAdd, timeoutAdd, and similar functions that take arguments and an IO action?  It'd be nice if the IO action was universally last
09:11:30 <xenoblitz> i'm starting to feel messy coding with alot of IORefs and MVars
09:11:31 <mr_H> is there any way in ghci to execute the function, but first reloading the file where it is defined ?
09:11:40 <BeelsebobWork_> dcoutts: included in the sdist tarball but otherwise ignored
09:11:43 <mr_H> in one command
09:11:47 <jrh> that way you can do things like timeoutAdd pri $ do foo; bar
09:11:55 <dcoutts> jrh: I've wanted to do that for ages, but it'll break all users if we use the same name
09:12:09 <dcoutts> jrh: I think there's an open ticket on that if you'd like to comment
09:12:20 <dcoutts> BeelsebobWork_: ok, that's extra-source-files
09:12:34 <BeelsebobWork_> cheers dcoutts
09:12:48 <jrh> dcoutts: will do.
09:12:53 <dcoutts> BeelsebobWork_: and in recent cabal versions that supports simplistic globbing
09:12:57 <lilac> dcoutts: addTimeout, addIdle, etc. sound nicer to me anyway tbh ;-)
09:13:11 <BeelsebobWork_> dcoutts: globbing?
09:13:18 <dcoutts> BeelsebobWork_: *.txt
09:13:24 <BeelsebobWork_> ah, cool
09:13:27 <BeelsebobWork_> examples/*?
09:13:31 <dcoutts> no
09:13:36 <BeelsebobWork_> :(
09:13:55 <dcoutts> it's restricted so you don't accidentally include too much
09:14:03 <BeelsebobWork_> hmm, I see
09:14:12 <mauke> examples/coca-cola-bottle
09:14:19 <dcoutts> and because it's easier to explain the semantics
09:14:22 <xenoblitz> dcoutts,ToRA|MSR: http://hpaste.org/11605#a1 ... is there no other way apart from adding an IORef?
09:14:26 <BeelsebobWork_> hmm, that would be a good example actually mauke
09:15:56 <dcoutts> xenoblitz: I'd use newtype DelayAction = DelayAction (IORef HandlerId)
09:16:07 <dcoutts> changeDelay :: ... -> DelayAction -> IO ()
09:16:32 <xenoblitz> ok
09:16:33 <dcoutts> oh, actually: newtype DelayAction = DelayAction (IORef (Maybe HandlerId))
09:16:40 <dcoutts> since you can remove the delay entirely
09:16:58 <xenoblitz> dcoutts: no actually you can't in this game :P
09:17:06 <xenoblitz> but thanks for that :)
09:17:16 <dcoutts> xenoblitz: then remove removeDelay :: HandlerId -> IO () from your api
09:17:39 <tryitn1> how does haskell memoize ? if i'm trying to find the LCS (longest common subsequence) f(i,j) | s(i)=s(j) f(i-1,j-1) +1  otherwise  max((f(i,j-1),f(i-1,j)), does it memozie the calls automaticlaly
09:17:48 <mauke> tryitn1: haskell doesn't memoize
09:17:59 <xenoblitz> dcoutts: ah yes i see what you mean
09:18:23 <xenoblitz> dcoutts: thanks
09:18:29 <dcoutts> xenoblitz: np
09:20:22 <xenoblitz> another quick question: IORef vs MVar, what's the core difference between them?
09:20:49 <mauke> IORefs are just mutable variables
09:21:07 <mauke> MVars are more fancy
09:21:13 <mauke> they can be empty or full
09:21:41 <PeakerWork> I think more importantly you can block on MVar reading/writing?
09:21:41 <mauke> writing to a full MVar blocks until the MVar is empty; reading from an empty MVar blocks until it's full
09:22:15 <xenoblitz> so basically IORef isn't "thread safe" but MVar is
09:22:22 <tryitn1> mauke, if i want to find the length of  longest common subsequences of 4 strings , how do i do it, the strings are big like 10000 chars
09:22:43 <mauke> dunno, use some algorithm
09:22:54 <lilac> 'some algorithm'. love it :)
09:22:55 <quicksilver> xenoblitz: IORef is thread safe in a weak sense (it won't segfault)
09:23:09 <xenoblitz> i c
09:23:13 <quicksilver> xenoblitz: but MVar gives more clearly determined semantics
09:23:16 <xenoblitz> if 2 threads access the same IORef
09:23:23 <xenoblitz> you will see the latest
09:23:28 <quicksilver> if 2 threads read the same IORef -> no problem at all
09:23:35 <xenoblitz> what if they write?
09:23:35 <quicksilver> if 2 threads write to it -> you don't know who will win.
09:23:36 <lilac> tryitn1: take all suffixes (use tails), sort them, then one linear pass should do the trick
09:24:04 <xenoblitz> quicksilver: thanks
09:24:04 <osfameron> there are descriptions of the LCS algorithms on wikipedia for example
09:24:20 <osfameron> (I could never make head or tail of them myself, but hey ho)
09:24:41 <lilac> osfameron: try \x -> (head x, tail x)
09:24:44 <lilac> :D
09:24:54 <tryitn1> lilac, does suffixes assume substring instead of subsequence
09:25:55 <osfameron> lilac: I don't see how that gives me LCS, but I'm willing to accept the algorithm is somehow easier in haskell than the imperative version I looked at (was a couple of years ago mind)
09:27:55 <mr_H> can i filter reddit results, and subscribe by rss to the filter i created ?
09:28:10 <mr_H> i want o subscribe only to haskell and linux related results on reddit
09:30:45 <lilac> tryitn1: ah sorry, subsequences not substrings :) never mind then
09:31:07 <lilac> tryitn1: sounds like a job for dynamic programming tho (certainly in the case of 2 strings)
09:38:02 <Twey> osfameron: It doesn't give you the LCS, it's how you make the head and tail of it :-P
09:39:49 <osfameron> Twey: oh dear :-)
09:40:14 <Twey> Haha, yes, I liked it
09:40:40 <osfameron> I am staring at cobol and perl... sense of humour may be failing me :-)
09:43:54 <mauke> perl -e "print chr ord q sleep s and print chr ord q xor x and print chr ord q sleep s and print chr ord q x y x and print chr ord q open do and print chr ord q qw q and print chr ord q and quotemeta and print chr ord q ref tr and print lc chr oct ord q chr uc and print chr oct oct oct oct oct oct oct oct oct ord ord uc q map m"
09:45:13 <mapreduce> mr_H: Yahoo Pipes might be good for that.
09:47:15 <mr_H> nice :D
09:47:22 <tryitn1> what are yahoo pipes /
09:47:41 <mr_H> yahoo pipes is a visual parsing language for web pages
09:47:55 <bd_> mr_H: no, a visual filtering language for RSS feeds
09:47:59 <bd_> has nothing to do with web pages
09:48:01 <mr_H> oh
09:48:03 <mr_H> yes
09:48:04 <mr_H> :P
09:48:15 <mr_H> i thought it worked out html also
09:48:30 <mr_H> nice
09:48:30 <mr_H> :)
09:56:07 <mr_H> help in optimizing (for readability): http://hpaste.org/11606
09:56:12 <mr_H> please
09:57:31 <quicksilver> your basic technique looks fine, mr_H
09:57:36 <quicksilver> I would break it up and name the parts
09:59:38 <b_jonas> mr_H: how about this:  let trim = f . f where f = reverse . dropWhile isSpace; in unlines $ map trim results
10:00:09 <b_jonas> oh wait, you want to remove the all-space strings too
10:00:20 <Deewiant> unlines . filter (not.null) . map trim $ results
10:00:20 <b_jonas> and split to words
10:00:25 <b_jonas> hmm, disregard this then
10:00:32 <Deewiant> ah, word split, missed that
10:00:54 <Mzzz> Hello, a question here: After loading the following module:
10:00:55 <Mzzz>  
10:00:55 <Mzzz>   module SandBox where
10:00:55 <Mzzz>  
10:00:58 <Mzzz>   class MyNum a where
10:00:58 <Deewiant> @let results = ["this\n\n\n\n\t\t\t\t\t\t", "        ", "\n\n\n\t", "        \nis a test\n\n\n", "    123", "     ok?"]
10:00:59 <lambdabot>  Defined.
10:01:01 <Mzzz>     mnf :: a -> a
10:01:04 <Mzzz>  
10:01:07 <Mzzz>   instance MyNum Int where
10:01:10 <Mzzz>     mnf x = 0
10:01:13 <Mzzz>  
10:01:17 <Mzzz>   instance MyNum Char where
10:01:20 <Mzzz>     mnf x = '0'
10:01:23 <Mzzz>  
10:01:26 <Mzzz> Evaluate `mnf 0' in Hugs will result in the following error:
10:01:29 <Mzzz>  
10:01:33 <Mzzz>   SandBox> mnf 0
10:01:36 <Mzzz>   ERROR - Unresolved overloading
10:01:39 <Mzzz>   *** Type       : (Num a, MyNum a) => a
10:01:39 <Mzzz>   *** Expression : mnf 0
10:01:42 <Mzzz>  
10:01:47 <Mzzz> I think in `(Num a, MyNum a)=>a', the only type `a' can have is Int, thus
10:01:50 <Mzzz> there is no ambiguity, why still `Unresolved overloading'?
10:02:05 <quicksilver> Mzzz: some other module might define instance MyNum String
10:02:11 <quicksilver> Mzzz: classes are open.
10:02:15 <quicksilver> and treated as such.
10:02:28 <Deewiant> > let trim = f.f where f = reverse.dropWhile isSpace in unlines . concatMap words . filter (not.null) . map trim $ results
10:02:29 <quicksilver> (PS don't paste so many lines into the channel)
10:02:30 <lambdabot>   "this\nis\na\ntest\n123\nok?\n"
10:03:00 <Deewiant> mr_H: I don't see where you got the extra line break between "123" and "ok?", the above is how I'd do it
10:03:31 <pixel_> mr_H: yeah, a call to "words" in missing in your code
10:03:50 <b_jonas> > concatMap words results
10:03:51 <lambdabot>   ["this","is","a","test","123","ok?"]
10:03:51 <mr_H> hmm
10:03:52 <pixel_> otherwise "is a test" is kept on a single line
10:04:00 <b_jonas> > unlines $ concatMap words results
10:04:01 <lambdabot>   "this\nis\na\ntest\n123\nok?\n"
10:04:04 <Deewiant> mr_H: or right, you want a line break after any numeric string?
10:04:12 <Mzzz> quicksilver: So there will be no such check as "can `a' takes more than one type?"
10:04:29 <mr_H> what if i want it to be context dependent, like, to add a newline only in the first "all character (non-numeric)" string, after the numeric string ?
10:04:33 <Deewiant> > let trim = f.f where f = reverse.dropWhile isSpace in unlines . map (\s -> if any isDigit s then s ++ "\n" else s) . concatMap words . filter (not.null) . map trim $ results
10:04:34 <lambdabot>   "this\nis\na\ntest\n123\n\nok?\n"
10:04:49 <Deewiant> like so?
10:04:50 <mr_H> yes
10:05:01 <b_jonas> Deewiant: does that differ from mine?
10:05:08 <mr_H> more like \n\n after the 123
10:05:25 <Deewiant> b_jonas: it adds a line break after the 123
10:05:31 <Deewiant> but good point, words does the trimming by itself
10:05:31 <b_jonas> Deewiant: why do you need to trim and filter? words does that fine itself
10:05:56 <b_jonas> do you mean as in "123abc" would be split to two words?
10:06:05 <mr_H> what about this: "this\n\nis\na\ntest\n123\n\nok?" ? (like two newlines only on the first character-only string)
10:06:45 <b_jonas> I don't get what you want
10:06:47 <Deewiant> > unlines . map (\s -> if any isDigit s then s ++ "\n" else s) . concatMap words $ results
10:06:48 <lambdabot>   "this\nis\na\ntest\n123\n\nok?\n"
10:07:08 <mr_H> hmm
10:07:30 <Deewiant> b_jonas: I just never realize that words eats whitespace :-)
10:07:46 <b_jonas> we need the "stand back, I know regular expressions" guy
10:07:59 <mr_H> :)
10:08:06 <b_jonas> this one that is, http://xkcd.com/208/
10:08:07 <lambdabot> Title: xkcd - A Webcomic - Regular Expressions
10:08:09 <mr_H> thanks
10:13:31 * BMeph wants a "Stand back, I know lambda calculus" T-shirt
10:14:48 <leimy> BMeph: that'd be so excellent
10:16:09 <Saizan> with alpha,beta, and eta reduction rules on the back?
10:16:46 <quicksilver> fear the man who can combine the power of lambda calculus with M-butterfly
10:17:11 <boyscared> i did a `cabal update' and then a `cabal list' but get this error when listing: cabal: Couldn't read cabal file "./derive/0.1.2/derive.cabal"
10:17:22 <boyscared> anything i can do about that?
10:17:35 <b_jonas> heh
10:17:41 <dcoutts> boyscared: what does cabal --version say?
10:18:00 <boyscared> doesn't recognize the --version option
10:18:07 <boyscared> maybe i need to update cabal?
10:18:20 <dcoutts> boyscared: ok, you've got a very very old version of cabal-install, you want to upgrade
10:18:26 <b_jonas> BMeph: but of course http://xkcd.com/224/ applies
10:18:27 <lambdabot> Title: xkcd - A Webcomic - Lisp
10:18:35 <boyscared> ok, thanks. will try that
10:19:20 <b_jonas> http://store.xkcd.com/ has a tee shirt with the regular expressions stuff, not lambda calculus for this reason
10:19:21 <lambdabot> Title: xkcd store
10:20:04 <b_jonas> otoh from the title text of the regex comic, I assume there must be some similar scenario for lambda calculus too
10:26:50 <boyscared> Is there a way to unregister old versions of packages I no longer want? I installed the latest version of Cabal, but the old one is still showing up on ghc-pkg -l
10:27:12 <dcoutts> boyscared: there's no particular problem in leaving them registered
10:27:35 <dcoutts> boyscared: and be careful with unregistering things since you can break dependencies
10:27:55 <dcoutts> but if you're sure you know what you're doing then ghc-pkg unregister [--user] is what you want
10:28:04 <boyscared> I did unregister my old version of cabal-install, but that was possible since I had the old install dir hanging around
10:28:46 <boyscared> Thanks. I'd like to kinda just start over with the latest everything
10:43:07 * BMeph also wants a "HASKELL it works, bitches" T-shirt. No confusion with Lisp there!
10:43:30 <Beelsebob> what's a haskell it works?
10:43:52 <Beelsebob> BMeph's punctuation -- it doesn't work.
10:43:52 <Beelsebob> :P
10:44:14 * BMeph thinks it should have "xmonad / darcv / cabal" on its back.
10:44:54 * Beelsebob wonders why you would chose those 3 of the ~800 options on Hackage
10:45:52 <sw17ch> Is there something I need to know to rebuild the network package on Windows?
10:46:05 <sw17ch> I can't seem to get it to work.
10:46:12 <Deewiant> You need to be able to run 'configure'.
10:46:23 <Deewiant> Beyond that I don't think there was anything special.
10:46:28 <BMeph> Beelsebob: If all things xkcd weren't flagged by my corporate filter, I'd point you to the shirt. Maybe when I'm at home (and I remember), I'll point it your way, but I'm sure someone else may oblige before then. :)
10:46:47 <sw17ch> Deewiant, the problem i run into is that i need hsc2hs, but the cabal package is broken... so i fixed and installed it
10:47:18 <sw17ch> Deewiant, then i can at least start building network, but it chokes on the spaces in the build path
10:48:02 <Deewiant> sw17ch: Crap software like that is one of the reasons I try to do things in paths that lacks spaces :-P
10:48:12 <sw17ch> hehe
10:48:16 <sw17ch> well, in this case, i am...
10:48:25 <sw17ch> but it insists on doing something in C:\Program Files\Haskell
10:48:47 <sw17ch> Can some one else confirm the problem with hsc2hs's package in hackagE?
10:48:49 <Deewiant> I've renamed and moved my Program Files to a directory called Programs :-)
10:49:16 <Deewiant> What it should do in the end is install itself to that directory, and that should definitely work (or countless others would've complained, I'm sure)
10:49:41 <sw17ch> Deewiant, actually, now that i look at it again, it's from the linker arguments
10:50:20 <sw17ch> Deewiant, here's my whole sob story: http://www.haskell.org/pipermail/haskell-cafe/2008-October/050012.html
10:50:22 <lambdabot> Title: [Haskell-cafe] Problems with Windows, http://tinyurl.com/6rsrv6
10:51:51 <Saizan> ?hackage hsc2hs
10:51:52 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hsc2hs
10:52:26 <sw17ch> Saizan, it seems that it doesn't properly unmask packages 'process' and 'directory'
10:52:42 <Saizan> sw17ch: btw, are you sure that you don't have a hsc2hs isntalled with ghc?
10:52:44 <Deewiant> sw17ch: it might help if you don't run it from the windows command prompt, but from a cygwin or MSYS prompt
10:53:14 <sw17ch> Saizan, i may, but if that's the case, it isn't picked up on by the install process
10:54:14 <sw17ch> Saizan, here's my build output
10:54:14 <sw17ch> http://hpaste.org/11608
10:54:26 <sw17ch> Deewiant, I've tried it from both the windows cmdline and cygwin
10:55:06 <sw17ch> Saizan, once I hacked the cabal file for hsc2hs and did a configure/build/install, the errors at  the bottom of the paste go away and i end up with the space-in-path-name errors from the mailing list
10:55:28 <sw17ch> so, either it's not in my path when installed with ghc, or it's not included
10:55:51 <sw17ch> though, now that i look at this, it does see it
10:56:00 <sw17ch> but it doesn't seem that network's install process sees it
10:56:46 <sw17ch> err, i have it installed with ghc, but it's not found during the network build process
10:57:02 <Saizan> so, maybe you've to set %Path%?
10:57:33 <Saizan> you can run cabal install or setup configure with -v to see which hsc2hs is picked up
10:58:13 <sw17ch> Saizan, it's in my $PATH
10:58:24 <sw17ch> and ghc is in my %PATH%
10:58:35 <sw17ch> ah, hsc2hs is in my %PATH%
10:58:52 <paggas> say i have a number of configuration variables that are set once in main, and i want to use them in some other functions. is there a way to avoid having to pass them around as function arguments all the time? and i don't want to use IORef, since that would put my functions in the IO monad. thanks!
10:59:20 <Saizan> sw17ch: which? the one you compiled yourself or the one shipped with ghc?
10:59:39 <Saizan> sw17ch: if you run runhaskell Setup configure -v you'll see which one Cabal sees
10:59:42 <sw17ch> Saizan, the one shipped
10:59:42 <dcoutts> sw17ch: what is the problem? is it the configure script in the network package that fails?
11:00:01 <sw17ch> dcoutts, no, the configure runs just fine, but it seems that the build fails
11:00:06 <sw17ch> here, i'll paste the -v output
11:00:40 <Saizan> paggas: you can use the Reader monad
11:00:41 <sw17ch> http://hpaste.org/11608#a1
11:01:41 <sw17ch> dcoutts, Saizan  ^^
11:02:13 <Cale> paggas: You *could* use the reader monad, but packaging all your configuration into a single datatype and passing it explicitly is probably best.
11:02:30 <dcoutts> sw17ch: that warning about winsoc does not look good
11:02:44 <sw17ch> dcoutts, I didn't think so
11:03:00 <sw17ch> I've tried this from both the windows command line and the cygwin shell
11:03:10 <Cale> paggas: While it might seem a bit of a burden at first, it's actually useful to know what the behaviour of a function depends on -- when you do this, you get information about which parts of the program are affected by configuration settings.
11:03:13 <sw17ch> I got it to run from cmd.exe by adding the cygwin bin/ directory to my windows path
11:03:18 <dcoutts> sw17ch: if I were you I'd not bother trying to recompile the network package
11:03:36 <sw17ch> dcoutts, Here's my problem. I have a project that needs parsec-3. The project also needs network
11:03:43 <dcoutts> ah
11:03:43 <sw17ch> Network is compiled against parsec-2
11:03:50 <dcoutts> as it should be
11:04:03 <sw17ch> so, there's a problem then
11:04:15 <dcoutts> well, yes and no
11:04:32 <dcoutts> this is an example where the cabal-install restriction is too strict
11:04:43 <dcoutts> but there's not enough info available for it to know that
11:05:24 <sw17ch> dcoutts, so, is it safe to continue with both packages as dependencies?
11:05:28 <paggas> Cale: i think i'll go with explicit passing :) though it feels kindof low-level, it would be nice to do it like, say, C++, having all conf variables in an object :)
11:05:51 <sw17ch> Is this the first time this problem has come up?
11:06:12 <paggas> plus, Reader isn't installed by default in my GHC setup
11:06:22 <Cale> Oh, you're missing the mtl?
11:06:44 <dcoutts> sw17ch: in this case it should be safe, no it's not the first time
11:07:28 <sw17ch> dcoutts: alright, is there a way/plan to fix this in the future?
11:08:31 <Ikkebr> uia
11:08:36 <Ikkebr> esqueci que era hj que saia o ubuntu
11:10:26 <dcoutts> sw17ch: yes, the plan is to let packages specify private build-depends, eg in this case network has a private dependency on parsec
11:10:36 <dcoutts> so the constraint does not escape
11:11:11 <sw17ch> ah, well... then i'll forget about this problem and move on to more troubling matters, like finding a way call ioctl's from haskell :)
11:11:11 <dcoutts> sw17ch: more generally it's just a hard problem, it goes to the heart of what it means to allow the safe composition of packages
11:11:13 <sw17ch> thanks
11:11:35 <sw17ch> dcoutts, yes, there's been quite a discussion on Cafe.
11:11:40 <dcoutts> it's really a type checking problem in disguise
11:11:50 <dcoutts> sw17ch: has there? last couple days? I'd have missed it
11:39:43 <pumpkin_> lol, "The last ten digits of Graham's number are ...2464195387."
11:39:52 <pumpkin_> anyone have any idea how one would compute that?
11:40:01 <lilac> pumpkin_: mod 10^10
11:40:30 <pumpkin_> would it be tractable even with modular exponentiation though?
11:40:41 <pumpkin_> I'm not sure
11:40:44 <lilac> nor i
11:41:03 <pumpkin_> because you need to exponentiate x times, where x is the full result (not modular) of another large exponentiation
11:41:08 <pumpkin_> recursively
11:41:40 <rwbarton> But that large exponentiation only needs to be done modulo some other small number, and so on
11:42:21 <pumpkin_> oh they describe an algorithm
11:44:34 <sw17ch> dcoutts, well, in the past there was. not in the last few days.
12:15:32 <boyscared> Is there a way to upgrade 'base' registered to ghc? I have base-3.0.2.0, but a pkg wants version 4.
12:16:35 <Cale> boyscared: I believe that essentially means it wants GHC 6.10
12:16:55 <Cale> boyscared: You might try looking for a slightly older version of the package.
12:19:32 <boyscared> ah ok, guess i'll ignore that upgrade then
12:20:58 <Herbi> hi
12:23:54 <byorgey> hi Herbi
12:24:08 <Herbi> any haskell experts here? :D
12:24:29 <daf> we do what we can
12:24:34 <Herbi> ^^
12:24:35 <byorgey> Herbi: you might find one or two ;)
12:24:45 <byorgey> Herbi: do you have some questions?
12:24:50 <Herbi> a lot ^^
12:25:00 <Cale> feel free to ask away :)
12:25:11 <Herbi> just began with haskell at university and i have no clue, what they are talking about
12:25:27 <Herbi> i have a graph
12:25:28 <Herbi> type Graph = [(Integer, Integer)]
12:26:02 <byorgey> ok, so a graph is a list of edges?
12:26:08 <tromp__> directed graph?
12:26:18 <Herbi> and need a function reach:: Graph -> Integer -> [Integer], which determines all from Integer reachable nodes
12:26:29 <Herbi> directed
12:26:41 <Herbi> Graph is a list of edges
12:26:44 <Cale> Herbi: okay
12:27:20 <tromp__> i recently wrote (almost) such a function in my Go Rules
12:27:30 <Cale> Herbi: So start with finding the neighbours of a given node.
12:27:44 <Herbi> yeah, i have also a local function given
12:28:04 <Herbi> reach':: [Integer] -> [Integer] -> [Integer]
12:28:34 <tromp__> sounds like expand function in http://homepages.cwi.nl/~tromp/go/SimpleGo.hs
12:29:07 <Herbi> (nodes of which i do not know the neighbors) -> (reachable nodes) -> ?
12:29:14 <tromp__> although that's more like http://en.wikipedia.org/wiki/Special:Search?go=Go&search=Integer -> [Integer]
12:29:26 <tromp__> oops
12:31:21 <tromp__> you want to take all neighbours of the "frontier" that are not in already visited nodes
12:33:42 <tromp__> map visited &  frontier to visited' & frontier', stop when frontier' is empty
12:33:58 <Herbi> ah
12:33:58 <Herbi> ok
12:34:25 <tromp__> then visited' is everythinbg reachable
12:37:42 <mml`> :t union
12:37:43 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
12:38:15 <mml`> > union [0,3,6,9,12,15] [0,5,10,15]
12:38:16 <lambdabot>   [0,3,6,9,12,15,5,10]
12:42:49 <mml`> @pl \m n -> 0 == (n `mod` m)
12:42:50 <lambdabot> ((0 ==) .) . flip mod
12:42:58 <tromp__> > otherwise
12:42:59 <lambdabot>   True
12:43:12 <mml`> @pl \m n -> (n `mod` m) == 0
12:43:12 <lambdabot> flip flip 0 . ((==) .) . flip mod
12:43:32 <mml`> both of those are about as easy to read as hairy postscript code
12:46:03 <mml`> @src any
12:46:04 <lambdabot> any p =  or . map p
12:46:11 <quicksilver> I think I miss a safe 'tryReadMVar'
12:46:19 <quicksilver> and I can't build on myself, on a single MVar
12:46:29 <quicksilver> I can do it with an auxiliary MVar (0
12:47:44 <quicksilver> Ah, I see I'm not the first to discuss this.
12:47:49 <quicksilver> mailing list post from 2004!
12:48:16 <b_jonas> from the thread synchronization tools, I'm missing the condition variable
12:48:47 <b_jonas> I can implement it -- I couldn't have invented the implementation alone but luckily I found an article with it
12:49:33 <b_jonas> that article lists two implementations, a slower one and one that works only if you have access to the scheduler internals which I don't
12:51:08 <mml`> @pl \x -> or [f x, g x]
12:51:09 <lambdabot> or . liftM2 (:) f (return . g)
12:51:15 <quicksilver> b_jonas: I've heard someone else say that but I've not yet met a case where condvars were the obviously right answer
12:52:03 <quicksilver> b_jonas: (.... to me, I mean ;)
12:52:04 <jescutie> Hey! My friend's band, Circumstance, just released a free album called Breakfast Champion. You can download it here: http://dudesweat.sweatparty.com/?p=737 If you listen to it and like it, tell me what you think? Please?
12:52:05 <lambdabot> Title: Download mpFREEZE! | dudesweat
12:52:07 <b_jonas> (for the record, that article is http://birrell.org/andrew/papers/ImplementingCVs.pdf )
12:52:09 <lambdabot> Title: Implementing Condition Variables with Semaphores
12:52:09 --- mode: ChanServ set +o quicksilver
12:52:17 * quicksilver smirks
12:52:20 --- mode: quicksilver set -o quicksilver
12:52:30 <geezusfreeek> heh
12:53:34 <quicksilver> wow. And another post back in 2002!
12:53:42 <quicksilver> and a commit message in conal's repo
12:53:56 <quicksilver> not coincidentally, conal is trying to solve the same problem I am.
12:53:56 <quicksilver> hmm.
13:08:57 <b_jonas> quicksilver: that might have been me, I've argued for condition variables once on this channel
13:09:23 <b_jonas> so what would this safe tryReadMVar do?
13:11:38 <Herbi> how do i get a list of all integers in [(Integer, Integer)] wiithout duplicates?
13:11:46 <b_jonas> oh, I see
13:11:51 <Herbi> result should be [Integer] then
13:12:07 <b_jonas> getting the status and the contents of the MVar at the same time
13:12:16 <b_jonas> yeah, you probably need an auxiliary lock for that
13:13:50 <rwbarton> Herbi: well, the simplest way is to build the list of all integers possibly with duplicates, and then apply nub
13:14:20 <Herbi> kk
13:14:30 <Herbi> and how do i get te list of all integers? :D
13:14:53 <jsn> > concatMap (\ (x,y) -> [x,y] ) [(1,2),(2,3)]
13:14:54 <b_jonas> concatMap or something
13:14:55 <lambdabot>   [1,2,2,3]
13:15:19 <jsn> > nub $ concatMap (\ (x,y) -> [x,y] ) [(1,2),(2,3)]
13:15:20 <lambdabot>   [1,2,3]
13:15:27 <akorn> hi! i've been trying to learn the basics of haskell.. i come from a procedural background and i find it a bit difficult to grasp the concept behind it
13:15:49 <rwbarton> > let allIntegers x = map fst x ++ map snd x in allIntegers [(1,2),(2,3)]
13:15:50 <akorn> can you give me some practical applications where haskell is very good for +
13:15:51 <lambdabot>   [1,2,2,3]
13:16:10 <mauke> akorn: compilers, version control systems, window managers, irc bots
13:16:14 <Botje> akorn: making ice cream!
13:16:14 <akorn> that might help to understand the type of problem domain that its suitable for
13:16:17 <b_jonas> haskell is good for anything
13:16:17 <luite_> akorn: mario clones ;)
13:16:24 <rwbarton> akorn: Pretty much all programming languages are good for addition. :)
13:16:36 <jsn> akorn: scripting, text processing, servers
13:16:43 <b_jonas> text processing?
13:16:45 <mauke> monadic stack pointer overflow
13:16:53 <jsn> b_jonas: yeah, i like it for that
13:17:05 <akorn> so you are basically saying it's as good as the procedural ones for every problem domain?
13:17:15 <IsoPallo_> No, better :)
13:17:16 <jsn> akorn: there are many procedural languages
13:17:17 <b_jonas> jsn: do you use the Parsec library or something else or both?
13:17:26 <jsn> b_jonas: i use parsec
13:17:37 <jsn> b_jonas: i don't even use regexen any more
13:17:46 <b_jonas> akorn: probably no, no one programming language can be best in everything
13:17:47 <rwbarton> akorn: You can easily translate a program in any procedural language into Haskell if you want.
13:17:52 <b_jonas> jsn: I see
13:17:53 <jsn> akorn: it is suitable for most any problem domain
13:18:03 <akorn> interesting
13:18:06 <jsn> akorn: it lacks libraries for game programming
13:18:09 <rwbarton> akorn: but Haskell gives you additional ways to build your program out of smaller pieces.
13:18:19 <rwbarton> akorn: I suggest looking at the paper "Why functional programming matters"
13:18:29 <jsn> akorn: there is some work to use it on embedded systems but i don't know how practical that is
13:18:51 <akorn> i just dont see the way to solve some things in haskell.. thats of course my problem ;)
13:19:03 <sjanssen> akorn: can you give an example?
13:19:16 <akorn> do you have recommendations how to start understanding the functional way of thinking
13:19:37 <jsn> akorn: hang out on this channel and ask specific questions about specific problems
13:19:53 <akorn> ok. i'll try to think of something coherent
13:19:56 <jsn> that is how i learned :)
13:20:06 <vixey> ?go Curry Howard Isomorphism
13:20:09 <lambdabot> http://en.wikipedia.org/wiki/Curry-Howard_correspondence
13:20:09 <lambdabot> Title: Curry-Howard correspondence - Wikipedia, the free encyclopedia
13:21:12 <akorn> interesting.. i take it you all have a strong mathematical background ?
13:21:20 <Botje> not me
13:21:28 <mauke> me neither
13:21:29 <Botje> haskell is easy to use, don't worry :P
13:21:32 <Daniel_H> My maths is alright.
13:21:38 <Daniel_H> nothing special by far.
13:21:46 <akorn> ok, i have hope then. :)
13:21:48 <b_jonas> I have a mathematical foreground
13:21:55 <akorn> :P
13:21:55 <mauke> haha
13:22:08 <Daniel_H> and I'm finding algebra really hard if that makes you feel better :P
13:22:17 <mauke> preflex: quote
13:22:17 <preflex>  <procyon> optimizing bubblesort is like masturbating.  Sure, it's not going to do you much good in the long run, and it's probably a waste of time, but it still feels good.
13:22:26 <Daniel_H> wait what.
13:27:09 <akorn> is haskell suitable for xml manipulation?
13:27:37 <mauke> http://hackage.haskell.org/packages/archive/pkg-list.html
13:27:37 <lambdabot> Title: HackageDB: packages by category
13:27:39 <Cale> akorn: There are some libraries for it of varying complexity. I don't think anything is *really* suitable for XML manipulation though. ;P
13:28:14 <Cale> (But I just really dislike XML)
13:28:50 <akorn> Cale: why is that? I guess XML is the prominent way of representing structured data at the moment
13:29:11 <Cale> Well, it's not as effective at its job than many much simpler things would be.
13:29:21 <vixey> akorn: it's one of the many
13:30:16 <Cale> Really, it's a way to represent trees, and out of the possible syntaxes for representing trees, it is rather verbose and overcomplicated.
13:30:53 <b_jonas> did xml invent all that <? and <! stuff or is that an sgml heritage?
13:30:58 <dcoutts> because it was designed for representing documents, not trees
13:31:09 <dcoutts> b_jonas: sgml
13:31:50 <Cale> dcoutts: Of course, because that's the natural thing to design something for when what you really want is a representation for trees :P
13:31:53 <b_jonas> I don't even understand what <? and <! are supposed to do
13:32:04 <b_jonas> and how they're different
13:32:08 <b_jonas> whatever
13:32:45 <dcoutts> Cale: but that's my point, I'm not sure they were really aiming it at general hierarchical data
13:32:52 <akorn> Cale: sure, XML is often an overkill but i'm sure it has made obsolete vast amounts of boiler plate parsing code and related errors
13:35:34 <dmwit> akorn: Show and Read don't suck, and they have also made obsolete vast amounts of boiler plate parsing code.
13:35:47 <vixey> akorn: Have you ever seen lisp?
13:35:57 <dmwit> Lisp is another great example.
13:36:02 <Cale> akorn: S-expressions would have done the same :P
13:36:28 <mauke> (L (I (S (P))))
13:36:33 <dmwit> 'lisp
13:36:38 <mauke> ))))))))))))))))))))))
13:36:51 <dmwit> Look at all those smiles at the end of the program!
13:36:53 <akorn> so i take it XML is a no-no? ;)
13:36:54 <Cale> XML has replaced boilerplate parsing code with mostly horrifying APIs that struggle to deal with its complexity.
13:37:10 <vixey> akorn: you can do XML fine in haskell
13:37:12 <Cale> akorn: Well, if you really need it, we have libraries like HaXml and HXT.
13:37:28 <Cale> I just personally don't like XML, and generally wouldn't use it :P
13:37:32 <dmwit> If you're starting something new, I recommend thinking hard before using XML.
13:37:33 <akorn> ok :)
13:37:37 <Herbi> how do i load the module List?
13:37:42 <dmwit> If you have to interface with somebody else's XML, then, well...
13:37:47 <dmwit> Herbi: import Data.List
13:37:54 <Cale> Herbi: in ghci, you'd  :m + Data.List
13:37:55 <dmwit> Herbi: (in a file; in ghci, it's :m +Data.List)
13:38:05 <dmwit> Herbi: (in hugs, :l List or something like that)
13:38:14 <mauke> :also Data.List
13:38:26 <Herbi> thx
13:39:15 <vixey> <title>My Great Webpage</title>
13:39:20 <akorn> Cale: surely you cant dismiss the benefits of XML files and schemas for eg. configuration files and such ..
13:39:26 <vixey> (title "My Great Webpage")
13:39:50 <Herbi> i get a lot of "not on scope" errors
13:39:50 <Herbi> http://privatepaste.com/5e0xlghodk
13:39:51 <luite_> benefits? I don't find xml very readable as a configuration file format
13:39:51 <mauke> akorn: er, configuration files should be hand-editable
13:40:04 <Herbi> eg. for childs
13:40:18 <mauke> that's because it's "children" :-)
13:40:21 <vixey> Herbi, #
13:40:22 <vixey> type Graph = [(Integer, Integer)]
13:40:24 <mauke> also, because it's not in scope
13:40:26 <vixey> very strange
13:40:28 <Herbi> lol, yeah :D
13:40:34 <vixey> type Graph = [(Integer, [Integer])]
13:40:40 <vixey> this is not more sensible?
13:40:47 <mauke> childs is a variable that's local to reach'
13:40:56 <mauke> it's not visible in reach
13:41:05 <quicksilver> b_jonas: the key part is not ever actually making the MVar empty
13:41:16 <quicksilver> b_jonas: that's the problem with a naive tryReadMVar
13:41:21 <quicksilver> b_jonas: the MVar will be briefly empty
13:41:30 <quicksilver> b_jonas: (so actually it races with another copy of iteslf)
13:41:58 <akorn> mauke: imo some obscure text property files are impossible to edit without referring to the (often missing?) documentation.. with XML schemas you can actually comment all the fields, give constraints for the data and provide sensible default values
13:42:02 <Cale> akorn: I would usually either use a 'show' of my program's data structures, actual Haskell code (a la xmonad), or else perhaps something using S-expressions.
13:42:22 <Herbi> ahf, I see
13:42:23 <mauke> akorn: no thanks
13:42:26 <Cale> (or a binary format, if it seemed appropriate)
13:42:31 <ahf> hesselink: ;)
13:42:32 <mauke> I'd use an ini file
13:42:34 <ahf> wow..
13:42:37 <ahf> double-fail :)
13:43:51 <vixey> Herbi, does that besite do encryption on the server side?
13:43:52 <akorn> Cale: thanks for the tips but i better learn the basics of haskell before i go into xml processing ;)
13:44:04 <b_jonas> quicksilver: yes
13:44:06 <Herbi> I dunno
13:44:19 <vixey> Herbi, looks like it does it on the server side to me
13:44:27 <vixey> Herbi, .. what's the point in that?
13:44:38 <b_jonas> quicksilver: but it is easy to solve with an extra lock: you just protect all operations (including tryReadMVar) with that lock
13:45:04 <Herbi> using privatepaste?
13:45:15 <akorn> i'll try to think of better example
13:45:52 <vixey> what is the point in privatepaste doing server side encryption
13:46:05 <narasim_7> hello..i am trying writing some programs for the exercises in realworldhaskell. I am trying out problem 7 in  chapter 3 and i get stuck up on this compiler error  Occurs check: cannot construct the infinite type: a = [[a] -> [a]]..can someone help me out with interpreting this message ...
13:46:27 <narasim_7> here is the code ...http://hpaste.org/11611
13:46:41 * Cale looks :)
13:46:46 <mauke> narasim_7: you've misspelled intersperse in line 2
13:47:09 <mauke> 'xs == []' better written as 'null xs'
13:47:21 <Cale> ah, yep, mauke's got it :)
13:47:28 <mauke> (map (:) x) : [] has the wrong type
13:47:32 <narasim_7> yeah..changed it now..
13:47:41 <mauke> what is it supposed to do?
13:47:52 <Cale> :t map (:)
13:47:53 <lambdabot> forall a. [a] -> [[a] -> [a]]
13:47:59 <mauke> :t intersperse
13:48:00 <lambdabot> forall a. a -> [a] -> [a]
13:48:52 <narasim_7> mauke: i am pasting the behavior from real world haskell
13:48:55 <narasim_7> ghci> intersperse ',' ["foo"] "foo" ghci> intersperse ',' ["foo","bar","baz","quux"] "foo,bar,baz,quux"
13:49:55 <mauke> ok, but (map (:) x) : [] still doesn't make sense
13:50:04 <narasim_7> mauke: given a list of lists , the function joins the lists together with a separator into a single list..
13:50:53 <b_jonas> is taht just: intersperse = (intercalate . (:[]))
13:51:18 <mauke> heh, you're not allowed to use intercalate
13:51:24 <mauke> (yes)
13:51:28 <b_jonas> > let { intersperse = intercalate . (:[]) } in intersperse ',' ["foo","bar","baz","quux"]
13:51:29 <lambdabot>   "foo,bar,baz,quux"
13:51:38 <narasim_7> mauke: yes i see that it has type [[a]]
13:51:48 <mauke> narasim_7: no, it doesn't
13:52:06 <mauke> :t (map (:) ?x) : []
13:52:07 <lambdabot> forall a. (?x::[a]) => [[[a] -> [a]]]
13:52:11 <narasim_7> b_jonas: :) now i have to figure out what that means
13:52:23 <mauke> it has the type [[[a] -> [a]]]
13:52:38 <b_jonas> narasim_7: do you know what the smiley (:[]) means?
13:53:26 <narasim_7> b_jonas: no..did i say something wrong..?
13:54:16 <Herbi> why is 'b' not in scope?
13:54:17 <Herbi> (visited ++ [a | a <- ns, elem (b, a) graph | b <- visited])
13:54:33 <narasim_7> mauke: one thing..suppose a function has to match a pattern in a list , will func (x:xs) work..even if xs is a list of lists
13:54:47 <mauke> yes
13:54:50 <mofmog> what's meant by * -> * ?
13:54:53 <narasim_7> mauke:  ok..
13:55:25 <mofmog> does it mean a type must be parametric? data Foo a = Lol | Bar a
13:55:32 <mauke> mofmog: yes
13:55:35 <mauke> :k Maybe
13:55:36 <lambdabot> * -> *
13:55:41 <narasim_7> mauke: thanks..
13:55:45 <mofmog> so what does it mean exactly
13:55:50 <narasim_7> thanks others..will keep working on this problem
13:57:10 <lucca> narasim_7: one thing you can do is change the type signature to a concrete type, like Char; then you can sometimes get more specific error messages about where type inferencing is getting confused
13:57:20 <lucca> (and change it back when you're fixed)
13:57:46 <mofmog> i'm trying to learn how to define my own monads- so that means that all monadic types MUST be parametric?
13:57:54 <mauke> mofmog: yes
13:57:56 <narasim_7> lucca: ok..yeah..probably  i would do try a specific case  and then get the generic thing to work..thanks..
14:01:45 <akorn> Cale: ok, here's a problem which i find difficult to convert into haskell. say i have a set of 2d points which represent some mass concentrations. i want to calculate a force field that the mass point exert for some rectangular area .. for example 100x100 array representing 2d space from (0,0) to (100,100)
14:02:13 <Cale> okay.
14:02:14 <akorn> err.. thats a bit vague explanation, do you understand what i mean?
14:02:30 <Cale> Basically a 100 by 100 array of densities?
14:02:31 <paggas> how do i enable antialiasing in opengl?
14:02:42 <akorn> Cale: yeah
14:02:45 <Gabriel_> Fire
14:02:49 <vixey> paggas: multitude of ways
14:03:03 <Gabriel_> Including fire.
14:03:38 <akorn> Cale: in procedural language i'd make nested loops for x and y and calculate the force for each point
14:03:42 <b_jonas> akorn: well, firstly you need a function that calculates the force a single point mass exerts to another point,
14:03:50 <Cale> paggas: http://www.haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-Antialiasing.html -- my guess is that it has to do with setting one of these
14:03:51 <lambdabot> Title: Graphics.Rendering.OpenGL.GL.Antialiasing, http://tinyurl.com/5b3wuc
14:04:06 <mofmog> akorn: map?
14:04:08 <b_jonas> akorn: then either you write a function that adds those forces for a list of masses and then map that for each coordinate in the grid,
14:04:11 <Herbi> any1 can help
14:04:37 <Cale> akorn: Here, you might use a list comprehension, together with the 'sum' function.
14:04:44 <Cale> (to sum up the forces)
14:04:54 <akorn> i dont know where to start.. thats the problem
14:04:55 <b_jonas> akorn: or map the force by each single point mass to the whole grid and then sum those results pointwise
14:05:11 <b_jonas> akorn: first decide how you represent a single point mass
14:05:37 <b_jonas> akorn: perhaps as a tuple or data type that stores the coordinates and mass
14:05:50 <akorn> b_jonas: say the inputs are 3-tuples.. (Float, Float, Float) or something ?
14:05:51 <Cale> b_jonas: He has an array of densities
14:05:54 <paggas> Cale: these are all gettable, the only one that can be set is multisampling, and it does nothing...
14:06:00 <akorn> (x,y,mass)
14:06:04 <Cale> paggas: hmm
14:06:55 <Cale> akorn: Oh, okay.
14:06:58 <b_jonas> akorn: so are the point masses in a regular grid too like Cale implies or irregularly with coordinates?
14:07:09 <Cale> akorn: So, that's a bit different...
14:07:33 <akorn> Cale: no, sorry. i ment that the points are just some "mass centers".. err.. whats the correct term for this
14:07:50 <akorn> Cale: yeah, i didnt actually mean densities.
14:07:53 <Cale> akorn: So, you don't have an array?
14:07:55 <sjanssen> akorn: centroid?
14:08:03 <Cale> Just a bunch of point masses, yeah?
14:08:09 <akorn> yeah thats right
14:08:14 <Cale> okay
14:08:46 <akorn> and the array would represent the force that would be exerted to some object.. if it would be suddenly dropped on that point
14:09:00 <Cale> ah, okay
14:09:03 <akorn> hehe :P
14:09:09 <akorn> sorry ;)
14:09:11 <Cale> So the array is the output.
14:09:14 <akorn> yes
14:09:22 <paggas> vixey: how do you do it, then? :)
14:09:33 <Cale> Okay, so start with a function which finds, for an arbitrary point in space, what the force would be.
14:09:50 <Cale> Then the array is just a bunch of applying that function over and over.
14:10:25 <akorn> i guess in this case it would be f=m/r^2 for x and y component
14:10:53 <Cale> That's for just two point masses, right?
14:11:10 <akorn> yeah true.. i have to sum them up for each point
14:11:19 <Cale> I suppose you're doing it for a hypothetical mass of 1 unit or something.
14:11:27 <sjanssen> there's a neat algorithm for N body simulations in the recent DPH paper
14:13:11 <sjanssen> http://www.cse.unsw.edu.au/~chak/papers/PLKC08.html not exactly the same problem, but somewhat related
14:13:13 <lambdabot> Title: Research Papers of Manuel Chakravarty
14:13:16 <akorn> Cale: yes, is that a force field o?
14:13:20 <akorn>  -o
14:13:21 <Cale> So you have something like   force masses (x,y) = sum [mass m / (distance (location m) (x,y))^2 | m <- masses]
14:13:57 <Cale> Where, say, you have some datatype like:  data Mass = Mass { mass :: Double, location :: (Double, Double) }
14:14:15 <Cale> and a function  distance :: (Double, Double) -> (Double, Double) -> Double
14:15:13 <Cale> So given a list of masses, and a point, the function force finds the force that would be exerted on a mass of one unit at that point.
14:16:00 <Cale> (you might prefer it to find the force exerted on an arbitrary mass of type Mass, and that's easy too)
14:16:12 <cyph1e> If I want to call f twice with argument x, I can do \f -> \x -> f (f x), however, why does \f -> f f give error?
14:16:33 <Cale> cyph1e: Because no function can be applied to itself as a parameter.
14:16:46 <Cale> cyph1e: you might mean \f -> f . f
14:16:50 <sjanssen> @type id id
14:16:51 <lambdabot> forall a. a -> a
14:16:58 <Deewiant> @type fix fix
14:16:59 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
14:16:59 <lambdabot>     Probable cause: `fix' is applied to too many arguments
14:16:59 <lambdabot>     In the first argument of `fix', namely `fix'
14:17:03 <Cale> okay, id is sufficiently polymorphic :)
14:17:04 <Deewiant> oops
14:17:06 <cyph1e> I see
14:17:14 <Deewiant> @ty const const
14:17:15 <lambdabot> forall a b b1. b1 -> a -> b -> a
14:17:16 <Cale> But it's not really the 'same' id there.
14:17:35 <Cale> It's two different specialisations.
14:17:40 <sjanssen> > (\f -> f f) id -- for example
14:17:42 <lambdabot>       Occurs check: cannot construct the infinite type: t = t -> t1
14:17:42 <lambdabot>      Prob...
14:18:06 <paczesiowa> how do I make this work: "a \/ b = a :\/: b" ?
14:18:08 <akorn> Cale: thanks, i'll chew that for a while :)
14:18:28 <mauke> GODDAMN (C++)--
14:18:37 <sjanssen> @karma (C++)
14:18:37 <lambdabot> (C++) has a karma of -1
14:18:37 <Deewiant> @karma (C++)
14:18:38 <lambdabot> (C++) has a karma of -1
14:18:49 <Deewiant> @karma C
14:18:49 <lambdabot> C has a karma of 0
14:18:52 * Cale imagines a lolcat saying "I can not has polymorphic instantiation?!"
14:19:02 <osfameron> I'm working through to Mock a Mockingbird, and I'm completely baffled by the *process* he goes through to prove the equivalences.  "This ones' easy!  If it's true for all y, then it's true when y = Lx!"  (paraphrasing)  I don't understand why it's obvious that I should try setting one variable to one expression etc. :-(
14:19:04 <sjanssen> C is special cased in the karma plugin
14:19:11 <Deewiant> aw
14:19:12 <mauke> preflex: karma C++
14:19:12 <preflex>  karma for C++: -23
14:19:17 <Deewiant> preflex: karma C
14:19:17 <preflex>  karma for C: 39339
14:19:18 <Cale> akorn: to make the array then, you'd just apply that function for a bunch of particular points
14:19:25 <Cale> akorn: and use something like listArray
14:19:31 <Cale> or array
14:19:34 <Cale> :t array
14:19:35 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
14:20:15 <Cale> > array ((0,0),(5,5)) [((x,y),x+y) | x <- [0..5], y <- [0..5]]
14:20:16 <lambdabot>   array ((0,0),(5,5)) [((0,0),0),((0,1),1),((0,2),2),((0,3),3),((0,4),4),((0,...
14:20:19 <sjanssen> paczesiowa: that looks valid to me, what exactly is the problem?
14:20:20 <quicksilver> b_jonas: yes, at the cost of changing all the primitives
14:20:44 <akorn> Cale: this sounds like exactly the kind of problem i need to learn how to solve in haskell to it going ;)
14:20:46 <Cale> (something like that, but with x+y replaced with a call to that force function, and possibly some scaling applied)
14:20:52 <quicksilver> b_jonas: so you have to wrap it all up in an abstract type
14:20:59 <b_jonas> quicksilver: yeah
14:21:13 <quicksilver> b_jonas: which is fine, but as far as I understand it the native implementation of MVars in GHC would actually support the primitive I want :)
14:21:15 <b_jonas> unless of course you extend it inside-out object way
14:21:23 <b_jonas> you can do that in theory as it's all in IO
14:21:26 <Cale> akorn: Of course, you only make an array in Haskell if you're going to do a lot of random lookups.
14:21:36 <Cale> akorn: and you're not going to do so many updates
14:21:50 <paczesiowa> sjanssen: "data a \/ b = a :\/: b" gives Malformed head of type or class declaration
14:22:20 <akorn> Cale: ok, ill return later with more questions :)
14:22:23 <Cale> akorn: If you need to do lots of updates, and the problem is not so performance-dire that you'd be willing to go to using mutable arrays, then something like Data.Map is usually quite effective
14:22:54 <vixey> osfameron: dammit!
14:22:58 <Cale> For this particular problem, something like a space-partitioning tree would probably be even better.
14:23:02 <sjanssen> paczesiowa: oh, \/ isn't a valid type name
14:23:05 <dmwit> paczesiowa: You probably need a real name for the type.
14:23:06 <vixey> osfameron: I meant to pick that book up from the library to try it again today
14:23:12 <vixey> I forgot  of course
14:23:19 <sjanssen> paczesiowa: it has to start with :, just like data constructors
14:23:21 <dmwit> paczesiowa: (i.e. something starting with an upper case letter)
14:23:26 <osfameron> vixey: heh, easy to do
14:23:28 <Cale> (you can compute centre of mass going up the tree, and only worry about effects of individual particles when they're close by)
14:23:36 <osfameron> vixey: it was very cheap on amazon.co.uk if that's any help
14:23:48 <paczesiowa> sjanssen: thanks, now it works
14:23:52 <vixey> I can get it free from the library, I just have to not fall asleep...
14:23:53 <sjanssen> paczesiowa: you probably also need to turn on the type operators extension
14:24:14 <quicksilver> b_jonas: what I *actually* want is a Chan with peekChan and tryPeekChan
14:24:19 <paczesiowa> sjanssen: -fglasgow-exts seems enough
14:24:39 <sjanssen> paczesiowa: boo!  -fglasgow-exts should be considered deprecated
14:24:49 <sjanssen> all the cool kids use {-# LANGUAGE #-} now
14:24:52 <quicksilver> b_jonas: implementing them with MVars needs a working tryReadMVar...
14:25:00 <akorn> my way of thinking about the solutions of problems seems to be too much dependent on having some baskets where to store things :(
14:25:04 <mauke> {-# LANGUAGE Perl #-}
14:25:04 <dmwit> LANGUAGE is a nice fad.
14:25:04 <quicksilver> LANGUAGE TypeOperators
14:25:07 <quicksilver> I think.
14:25:10 <b_jonas> quicksilver: for that, I'd reimplement Chan (for which I used condition variables)
14:25:18 <quicksilver> b_jonas: I am reimplementing Chan.
14:25:40 <dons> lambdabot: @join #concatenative
14:25:43 <mauke> I am reimplementing lambda calculus. In C++.
14:25:43 <quicksilver> b_jonas: the way that occured to me, it turns out, is much the way Control.Concurrent does it.
14:25:51 <paczesiowa> is there LANGUAGE ALLOFTHEM?
14:26:01 <akorn> Cale: i seem to instantly think: "here's a variable, store something in me and manipulate me!" :D
14:26:04 <mauke> paczesiowa: that would kind of defeat the point
14:26:08 <quicksilver> b_jonas: a linked list with MVars all the way down, and a pointer to the end.
14:26:09 <sjanssen> paczesiowa: no, and that would defeat the purpose
14:26:12 <akorn> Cale: whats the equivalent in haskell ?
14:26:13 <b_jonas> Cale: and if I have access to the implementation then a peek is trivial
14:26:14 <dolio> You don't want all of them.
14:26:16 <vixey> I'd like that
14:26:18 <Cale> akorn: Right, variables are not the names of locations, they're the names of values.
14:26:19 <dolio> Some of them are evil.
14:26:19 <dmwit> akorn: variables don't ;-)
14:26:19 <vixey> I want all of them
14:26:21 <mauke> akorn: IORef
14:26:24 <paczesiowa> dolio: yes I do:>
14:26:29 <b_jonas> so is a tryPeek
14:26:51 <b_jonas> tryPeek just locks thr structure and looks at the list
14:27:08 <quicksilver> b_jonas: true. I don't have a global lock on the structure.
14:27:10 <paczesiowa> instead of compiling 20 times and adding correct extensions, I just add one switch and my ugly oneliner works
14:27:12 <quicksilver> (that would be one way of doing it)
14:27:12 <Cale> akorn: We have IORefs, STRefs, and then things like MVars, TVars (for concurrency communication), and then various kinds of mutable arrays. They're accessible from either the IO or ST monad.
14:27:24 <Cale> akorn: So you can do imperative programming in Haskell...
14:27:37 <sjanssen> paczesiowa: yeah, I think -fglasgow-exts is okay for quick hacks
14:27:40 <b_jonas> whereas peek waits the same way as read but doesn't remove the element after that, only then you have to make sure write broadcasts on the condition variable, not just signals
14:27:44 <akorn> huh :P
14:27:50 <b_jonas> so the reader doesn't block if there's a peeker waiting
14:28:00 <sjanssen> enumeration of all required extensions is really only needed for released code
14:28:01 <quicksilver> b_jonas: yeah.
14:28:08 <Cale> akorn: It's just discouraged for beginners. Once you learn to do things without mutation, then you can use them :)
14:28:28 <akorn> in philosophical sense though.. i always deal with values directly, not the references
14:28:31 <Cale> akorn: (also, the language will tend to get in your way if you try to overuse them)
14:28:32 <akorn> in haskell that is
14:28:35 <akorn> ?
14:28:36 <Cale> yeah
14:28:37 <mauke> akorn: yep
14:28:40 <mauke> unboxed bindings
14:28:56 <quicksilver> b_jonas: I'm implementing futures, which needs an idempotent read. i.e. a peek
14:29:04 <mauke> this may be easier to understand if you're coming from OCaml :-)
14:29:08 <Cale> Of course... behind the scenes, the runtime system is passing everything by reference, but that's unrelated ;)
14:29:09 <quicksilver> b_jonas: and a need both nonblocking and blocking versions.
14:29:10 <akorn> hmm.. im most familiar with java in which almost everything is references :P
14:29:39 <Cale> The reason for that is that values at runtime can still be expressions that haven't been evaluated yet.
14:29:46 <conal> quicksilver: "and a commit message in conal's repo"  about what?
14:30:14 <Cale> So it represents everything as a pointer to code which is going to run and return the value, and that code updates itself after being run the first time, so that next time it immediately returns the value.
14:30:20 <quicksilver> conal: tryReadMVar
14:30:32 <quicksilver> conal: it figures we keep solving the same subproblems
14:30:33 <dmwit> Haskell: the sane interface to self-modifying code.
14:31:13 <b_jonas> quicksilver: so what would you using for reimplementing the Chan assuming you had a MVar with such an operation?
14:31:13 <quicksilver> conal: since we're trying to solve the same big problem :)
14:31:40 <conal> quicksilver: sure.
14:31:43 <b_jonas> or, in general, how would you reimplement Chan?
14:32:01 <quicksilver> b_jonas: just as Control.Concurrent does it. But exposing more primitives.
14:32:13 <quicksilver> b_jonas: I wouldn't need to rewrite it at all if I could access their internals.
14:32:25 <quicksilver> there's nothing wrong with that implementation, for what I'm trying to do.
14:32:29 <quicksilver> Just the set of primitives it exposes.
14:32:37 <quicksilver> conal: to turn a Chan into an Event, safely
14:32:40 <Herbi> where is the parse error in pattern?
14:32:41 <Herbi> hasedgeto graph x:xs e = (elem (x, e) graph) || (hasedgeto graph xs e)
14:32:46 <quicksilver> conal: I need a non-blocking peek onto a Chan
14:32:54 <quicksilver> conal: I suspect you've tried something very similar yourself.
14:32:56 <paczesiowa> (x:xs)
14:33:18 <Herbi> thx
14:33:25 <conal> quicksilver: yeah, similar.
14:33:37 <dmwit> Herbi: Most of the parens on the right are unnecessary.
14:33:46 <paczesiowa> Herbi: and you can drop outer parens
14:33:55 <b_jonas> quicksilver: I don't remember that implementation
14:33:58 <quicksilver> conal: my basic Future building block used forkIO. But I realise that that introduces nondeterminacy. That's fine for asynchronous events.
14:34:02 <Cale> Herbi: the general rule is that function application binds tighter than any operator
14:34:12 <quicksilver> conal: but it is too nondeterministic for syncrhonous events
14:34:17 <Herbi> kk
14:34:22 <b_jonas> quicksilver: does it use queues of waiting threads?
14:34:24 <Cale> Herbi: so   hasedgeto graph x:xs e   parses as   (hasedgeto graph x) : (xs e)
14:34:33 <Herbi> i wasn't sure if missing parens are the cause and added them
14:34:48 <conal> quicksilver: are you going for a defined/precise (denotational) semantics?
14:34:48 <Cale> and    elem (x, e) graph || hasedgeto graph xs e   parses as how you wrote it :)
14:35:11 <quicksilver> b_jonas: No. It doesn't explicitly use threads at all. Although it uses MVars which can of course have waiters.
14:35:15 <akorn> when i think of it.. i think in java or other OOP, much of "power" of OO is actually in dividing and structuring the code in parts, where the actually data processing is same old C stuff
14:35:17 <quicksilver> b_jonas: ...but the I need tryReadMVar
14:35:22 <quicksilver> b_jonas: ...which is where we came in ;)
14:35:33 <lament> akorn: that's my impression too
14:35:46 <lament> akorn: most of the power is due to forced namespace structuring
14:35:49 <paggas> anyone know how to enable antialiasing in opengl? basically, if i draw some lines, should i expect them to be antialiased, or does this only happen with triangles and quads?
14:35:54 <luite_> do I need to do anything special to install happy? i get this error when doing ./Setup configure: Setup: The program happy is required but it could not be found
14:35:58 <quicksilver> conal: yes. In particular in a single threaded program, if you post something to an event you want it immediately available.
14:36:07 <lament> akorn: in Haskell there's modules for that but they're not as convenient
14:36:17 <akorn> lament: you mean like the variable scope or something?
14:36:22 <lament> akorn: but in general java class ~ haskell module
14:36:29 <lament> akorn: name scope, yes
14:36:42 <quicksilver> conal: if you have asynchronous events then an event you post, even in the same thread, doesnt' become available until it suits the GHC scheduler to shcedule whichever thread is responsible for 'progressing' that Event.
14:36:47 <lament> and "forced" factoring into small chunks of code
14:36:53 <lament> which you get in haskell too
14:36:59 <quicksilver> conal: which lead to some key presses being noticed one 'tick' late.
14:37:08 <akorn> lament: true
14:37:10 <quicksilver> conal: although, it was non-deterministic. Sometimes it was fine.
14:37:23 <conal> quicksilver: so the scheduler nondeterminism (sometimes) shows through to the library semantics?
14:37:28 <quicksilver> conal: exactly.
14:37:34 <quicksilver> conal: overuse of forkIO is the culprit.
14:37:41 <quicksilver> (not surprising, in retrospect)
14:37:43 <akorn> there are certainly many application where the concept of object and class in OO terminology fits very well
14:38:05 <lament> akorn: so you pretty much get most of the OO benefits by having a module that exports an opaque data type and functions that act on it
14:38:26 <conal> quicksilver: guaranteeing determinism (and hence simple semantics) was the most challenging bit for me.  it's what motivated unamb.
14:38:28 <quicksilver> conal: my new rul eo fthumb is that if an event is genuinely asynchronous (like a network read) tehre is no harm it being in a forkIO.
14:38:41 <lament> akorn: no inheritance though :(
14:38:42 <quicksilver> conal: because, after all, you have no way of observing determinacy in that case.
14:38:44 <jsn> paggas: i'm not sure how to do it in haskell
14:38:47 <paczesiowa> lament: minus side effects, and inheritance
14:38:48 <akorn> i have a feeling that in general in haskell everything is deterministic and precise ?
14:39:04 <lament> in general everything in programming is deterministic and precise
14:39:10 <quicksilver> conal: but if an event is synchronous w.r.t the rest of your code, e.g. explicitly posted or explicitly timed, then it better be deterministic.
14:39:12 <conal> quicksilver: you could still do (True <$ e) `mappend` (False <$ e)
14:39:19 <jsn> paggas: you have enabled  GL_LINE_SMOOTH  ?
14:39:25 <conal> quicksilver: when e is asynchronous
14:39:29 <sjanssen> akorn: everything not involving the IO Monad is deterministic
14:39:35 <lament> paczesiowa: inheritance is a big one. Not having it pisses me off.
14:39:39 <akorn> i mean.. is it usually difficult to implement some "rule-of-thumb" heuristics and such which defy a formal mathematical definition?
14:39:47 <b_jonas> quicksilver: I'll look at Chan's source then
14:39:50 <quicksilver> conal: remind me what <$ means
14:39:56 <quicksilver> b_jonas: sorry. Two conversations at once :)
14:39:59 <conal> @type (<$)
14:39:59 <quicksilver> b_jonas: althugh related.
14:40:00 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
14:40:01 <Herbi> any1 interested in a search for e infinite loop? ^^
14:40:11 <paczesiowa> lament: try OOHaskell:>
14:40:12 <vixey> Herbi, yes
14:40:18 <quicksilver> b_jonas: it's like a linked list, with MVars at every link
14:40:19 <Herbi> here you go: http://privatepaste.com/86SlC1i9H2
14:40:22 <conal> quicksilver: it replaces an event's values with a single one.
14:40:23 <geezusfreeek> even with it available to me, i hate inheritance. i almost always just use simple delegation
14:40:25 <quicksilver> b_jonas: and an MVar to the 'end' kept at all times.
14:40:37 <vixey> Herbi, same comment wrt. you Graph type
14:40:44 <Herbi> yes
14:40:45 <conal> quicksilver: it's like fmap . const
14:40:48 <Herbi> bit with a infinite loop
14:40:53 <paggas> jsn: actually i didn't... i thought hint LineSmooth would be enough!
14:40:55 <quicksilver> conal: Yes agreed. I understand the point you're making.
14:40:59 <vixey> Herbi, i.e. why not type Graph = [(Integer,[Integer])] ?
14:41:07 <Herbi> reach [(1,2), (2,3), (3,4)] 1 was called
14:41:12 <quicksilver> conal: that concerns me less at this instant, but I'd still like to solve it.
14:41:18 <quicksilver> conal: I think I had a solution to that one in fact ;)
14:41:24 <Herbi> because the excersice does not say so ;)
14:41:31 <b_jonas> quicksilver: could you maybe use ghc internals (instead of just the MVar api) to implement that mvar operation?
14:41:34 <quicksilver> conal: but I never finished it. My concentration is now on the synchronousevent.
14:41:35 <jsn> paggas: hinting speaks to how it should do it -- not whether it should do it :)
14:41:55 <quicksilver> b_jonas: yeah, I certainly could. I'm not sure I understand them well enough.
14:42:06 <b_jonas> I see
14:42:18 <quicksilver> b_jonas: I'd like to speak to someone who can remember why the MVar API was designed that way and see if they have good reasons for it not being in the interface.
14:42:20 <jsn> paggas: in C  glEnable(GL_LINE_SMOOTH);  (it's been awhile, please double check that)
14:42:27 <quicksilver> b_jonas: in practical terms I will add one of the locks you suggested.
14:42:29 <b_jonas> quicksilver: I see
14:42:37 <quicksilver> b_jonas: either a per-MVar lock or a per-Chan one.
14:42:46 <paggas> jsn: well, i enabled lineSmooth, and the lines are drawn in a different way now, but still it's not smooth as in using the alpha channel!
14:42:52 <b_jonas> I guess a per-chan one could work
14:42:52 <conal> quicksilver: do you use MacOS, emacs, and graphics?
14:43:18 <b_jonas> that way you could even make it work with just wrapping Chan, not reimplementing it
14:43:29 <jsn> paggas: well, at this point, i must refer you to the red book -- it's all tuning from here on in :)
14:43:51 <paggas> jsn: seems it just draws lines with a width of 2 pixels
14:44:28 <jsn> what did you set the hint to?
14:44:37 <conal> quicksilver: i ask because i'm ready to give up on win32 for haskell work and am deciding between mac & linux.  BeelsebobWork_ suggested that you & i use similar tools and i might ask how happy you are with MacOS as an environment for haskell, emacs & graphics.
14:45:25 <SubStack> package management on osx is a hassle though, compared to say debian
14:45:49 <inimino> indeed
14:46:15 <Deewiant> and compared to windows? ;-)
14:46:17 <quicksilver> conal: I use haskell, emacs, macos and glut
14:46:28 <quicksilver> conal: I don't do anything much cleverer than glut.
14:46:32 <Deewiant> conal: still no luck with glut?
14:46:35 <quicksilver> although I did do a brief experiemtn in wx.
14:46:37 <jsn> conal: i use OS X with Haskell, and so far I haven't had any worries -- but i don't do much with emacs or graphics
14:46:49 <conal> Deewiant: i might be getting closer.
14:47:07 <quicksilver> b_jonas: yes, I could wrap chan because they supply 'unRead'
14:47:07 <jsn> conal: you will really want to have the MacPorts system available for installing libs, though
14:47:09 <lucca> I haven't been able to get OpenGL working with haskell on osx yet
14:47:11 <quicksilver> b_jonas: or, whatever they call it.
14:47:13 <conal> quicksilver: with wxhaskell?
14:47:17 <quicksilver> conal: yeah.
14:47:21 <conal> jsn: what's MacPorts?
14:47:22 <lucca> either via GLUT or XGL
14:47:34 <conal> lucca: eep
14:47:35 <quicksilver> conal: I did a very small GUI app. and I use (faceless) wx to load images and fonts for opengl code
14:47:42 <b_jonas> quicksilver: if you only want peek, not tryPeek, you don't even need an unRead
14:47:43 <jsn> conal: it is a system of recipes for *NIX packages
14:47:47 <quicksilver> lucca: strange. I never had any trouble.
14:47:50 <conal> quicksilver: how did wxhaskell installation & use go?
14:47:53 <quicksilver> b_jonas: I need tryPeek though.
14:48:10 <quicksilver> conal: I had no troubles. I mayhave been lucky :)
14:48:11 <jsn> conal: are you familiar with FreeBSD ports or Gentoo's Portage?
14:48:22 <lucca> quicksilver: Hmmm, i'll re-check my methodology then.
14:48:28 <conal> jsn: not at at.  what are they?
14:48:33 <jsn> basically, you want to install OpenSSL
14:48:47 <jsn> so you say (on a Mac)  port install openssl
14:49:00 <conal> jsn: sounds pretty friendly :)
14:49:10 <jsn> and then it says, to build this thing, i need this and this and this
14:49:27 <b_jonas> quicksilver: I'm not sure if that can be implemented by wrapping. maybe it can, with storing an optional first element in an extra MVar which you fill when you peek and examine before reading the inner Chan
14:49:29 <jsn> so it downloads   readline  and  gettext  and other stuff
14:49:37 <jsn> then it compiles them and installs them
14:49:39 <quicksilver> b_jonas: *nod*
14:49:53 <jsn> it applies Mac specific patches sometimes
14:49:55 <quicksilver> b_jonas: I think there needs to be a bit more documentation about this stuff.
14:50:11 <quicksilver> b_jonas: in particular, MVars in practice should always be used according ot certain disciplines.
14:50:22 <quicksilver> b_jonas: I wonder if those disciplines should be newtypes, with limited operations.
14:50:27 <quicksilver> b_jonas: keep us a bit more sane.
14:50:52 <luite_> hmm, apparently happy 1.17 needs an older cabal to install correctly, so now I'm trying to build cabal-1.4.0.2. but it doesn't compile with ghc 6.10. has anything changed in the api (seems to bee something in GHC,Exception)?
14:51:12 <jsn> (the original motivation for this system comes from FreeBSD, which could use a lot of Linux programs -- if they were patched. so they made a system to automatically "port" the programs to FreeBSD. so now everyone calls their source-based package manager a "port system" even when it is not porting anything)
14:52:00 <jsn> i use the GHC-6.8.3 binary for OS X, though -- because the port failed to build :(
14:52:57 <b_jonas> quicksilver: my discipline is to use only mutexes (which are special semaphores so upping twice has an undefined behaiviour) and condition variables (with listen and broadcast), for those two are sufficent to implement anything else
14:53:15 <b_jonas> I mean to implement anything else easily
14:53:31 <b_jonas> because in theory just mutexes are enough to implement condition variables
14:53:52 <quicksilver> right. in theory mvars are enough to implement everything, too
14:54:03 <quicksilver> in practice we want *convenient* primitives not just complete ones :)
14:54:16 <b_jonas> yes, that's why I'm saying mutexes plus condition variables
14:54:40 <b_jonas> it might of course be that I have just programmed too few threaded apps that really bad things didn't come up
14:56:32 <b_jonas> for example, an MVar can be implemented using an ioref maybe that has its contents, a mutex that all operations lock, and two condvars, one that's broadcast on taking and one that's broadcast on putting
14:58:01 <mauke> huh?
14:58:16 <mauke> wouldn't it be easier to just use two mutexes?
14:58:29 <jsn> paggas: any luck?
14:59:02 <b_jonas> mauke: two mutexes in what way?
14:59:22 <paggas> jsn: nope :| i'm doing some tests in C now, maybe it's haskell's fault!
14:59:28 <mauke> well, here's how I made an MVar in C#: http://mauke.ath.cx/stuff/c%23/stress.cs
14:59:38 <jsn> paggas: i would like to know what you discover
14:59:57 <paggas> jsn: okay :)
15:00:13 <b_jonas> mauke: let me look
15:02:15 <quicksilver> b_jonas: do condvars have guaranteed timely wakeup?
15:02:23 <quicksilver> b_jonas: or just 'will wake that thread up sometime' ?
15:02:30 <b_jonas> quicksilver: no, not in my interpretation
15:02:38 * quicksilver nods
15:02:53 <quicksilver> (GHC's scheduler has no way to make any such guarantee, for example)
15:03:50 <b_jonas> however, I do like to assume that mutexes are fair in each waiter eventually gets the lock if the mutex is unlocked enough times (because eg. the waiters are woken up in fifo order)
15:04:02 <Herbi> how do I check if a list contains an element?
15:04:09 <b_jonas> if that doesn't happen I could implement such a mutex from plain mutexes but it would get ugly
15:04:13 <Herbi> dumb question >.<
15:04:17 <Herbi> elem ;)
15:04:43 <quicksilver> b_jonas: yeah, GHC MVars are first slept, first woken
15:05:07 <b_jonas> quicksilver: oh wait, by timely wakeup you don't mean that signal wakes them up in fifo order, right?
15:05:36 <b_jonas> mauke: that might work, I'll have to think about it
15:08:08 <b_jonas> mauke: nice. I think that would work
15:08:29 <bockmabe> Do you guys think it's possible to build some haskell code which controls interactive session ala expect, and then have quicktest drive it so that you could test non-haskell interactive programs with quickcheck?
15:10:53 <dmwit> The cool thing about quickcheck is that it automatically makes your test cases.
15:11:14 <dmwit> So unless you can come up with a principled way of doing that for an arbitrary text interface, I hardly think it's worth it...
15:11:25 * lament fires the entire QA department
15:11:31 <bockmabe> :-)
15:11:41 <Peaker> fuzz testing is not the end-all of testing...
15:11:43 <dmwit> Oh, it's still worthwhile to test.
15:11:52 <dmwit> You just have to make all the tests by hand, is all. =P
15:12:20 <Peaker> you can't really map the interesting test space with some random samples, in most non-trivial cases
15:12:34 <Peaker> at least when speaking of larger tested units
15:12:35 <b_jonas> maybe it's a web or gui app and the test is supposed to test that the program doesn't crash if someone bangs on the keyboard and clicks randomly like a million monkeys
15:12:37 <bockmabe> peaker, yeah agreed.  It's only one of many tests that should be run.
15:13:36 <b_jonas> quicksilver: wait, what are these Events you mentioned?
15:14:49 <b_jonas> oh, it's something related to STM
15:23:23 <mmorrow> bockmabe: i've seen some instances of Arbitrary for ASTs of languages. possibly if you can come up with/already have a grammar for valid input to some program, then you can encode that in haskell, make an instance of Arbitrary for it, then fire away
15:24:03 <mmorrow> this may work or may not depending on the particular situation of course..
15:24:38 <Peaker> BONUS_: everyone loves your tutorial ;)
15:26:42 <geezusfreeek> what tutorial is this?
15:26:52 <teratorn> http://learnyouahaskell.com
15:26:55 <lambdabot> Title: Learn You a Haskell for Great Good!
15:27:56 <geezusfreeek> oh, i didn't realize that was BONUS_'s
15:28:15 <geezusfreeek> yes, it seems nice based on my cursory skim of the first couple pages
15:28:35 <geezusfreeek> and it is certainly popular
15:28:49 <Peaker> hey, why does ghci seem to use some weird limited form of type inference?
15:29:07 * dmwit guesses monomorphism restriction
15:29:23 <dmwit> But we'll need a bit more info to answer for sure.
15:29:36 <Peaker> let u = unionWith and then :t u -> u :: (a -> a -> a) -> Map () a -> Map () a -> Map () a
15:29:40 <Peaker> (From Data.Map)
15:29:45 <paggas> jsn: well, i transcribed my program to C, and antialiasing still works the same!
15:29:45 <Peaker> @type unionWith
15:29:46 <lambdabot> Not in scope: `unionWith'
15:29:50 <Peaker> @type Data.Map.unionWith
15:29:51 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> M.Map k a -> M.Map k a -> M.Map k a
15:29:55 <dmwit> Peaker: That's the MR for sure.
15:30:01 <jsn> paggas: so the problem is not with haskell?
15:30:09 <dmwit> :set -fno-monomorphism-restriction
15:30:42 <Peaker> ah, yeah
15:31:05 <b_jonas> eek
15:31:20 <b_jonas> would that setting not cause problems with lots of ordinary code?
15:31:54 <bockmabe> mmorrow, yeah that's kind of what I was brainstorming on. Though my UI is also modal. so there's a specific parse tree for each mode, but I could start with one mode.
15:32:20 <tanob> has anybody here that already tried Cal ?
15:36:14 <mmorrow> bockmabe: cool, that sounds like an interesting experiment
15:36:18 <paggas> jsn: probably yes
15:36:38 <paggas> jsn: i think i'll have a look at nvidia-settings now... :)
15:38:58 <mmorrow> bockmabe: i guess you could implem an (N)DFA (or equivalent) that knows how to generate appropriate random AST fragments/expressions/whatever given the current mode and its stack or something
15:39:04 <mmorrow> then have that talk to the prog
15:39:46 <mmorrow> or s/NFDA/whatever-the-needed-automaton-is/ given your prog's structure
15:41:52 <mmorrow> ("NDFA" sounds like it'll be complex to implem, but i believe it should be pretty simple by using a group of mutually recursive functions and a list carried around as a param as the stack)
15:42:41 <pumpkin_> nondeterministic finite automaton?
15:42:50 <mmorrow> yes
15:42:59 <pumpkin_> those don't have stacks?
15:43:04 <vixey> they do not have stacks
15:43:05 <mmorrow> or whatever the one is called that has a stack :)
15:43:06 <pumpkin_> but they do have sets of possible current states
15:43:10 <pumpkin_> that's a PDA
15:43:11 <vixey> pushdown automata do
15:43:12 <ddarius> pushdown automata
15:43:17 <mmorrow> ah, that one
15:43:22 <mmorrow> hrm
15:43:30 <pumpkin_> there are other more obscure ones, like stacks of stacks
15:43:31 <mmorrow> what's the def of NDFA?
15:43:39 <pumpkin_> it recognizes regular languages
15:43:42 <mmorrow> which are strictly more po.
15:43:44 <pumpkin_> just like a normal DFA
15:43:50 <mmorrow> yeah, o was just reading about those yesterday
15:43:52 <pumpkin_> but it's easier to write one :P
15:43:54 <mmorrow> s/o/i/
15:44:02 <bockmabe> Ah... yes pushdown automata.  Yea NDFA is common in regex matcher no?
15:44:11 <mmorrow> i believe so
15:44:14 <pumpkin_> well common regexes aren't strictly regular
15:44:23 <pumpkin_> in fact, some of them are more than context-free
15:44:55 <pumpkin_> backreferences give them way more power than the "formal regex"
15:48:12 <bockmabe> I see, so it's backreferences that make it so that they can't be implemented as a strict NDFA?
15:49:12 <dmwit> yes
15:49:16 <paggas> jsn: i have the feeling that the alpha channel isn't enabled.... maybe it's disabled by gluOrtho2D?
15:49:47 <jsn> paggas: i don't really know
15:50:17 <paggas> jsn: nope, ortho2D isn't the problem
15:50:18 <jsn> paggas: it doesn't seam reasonable that transparency is altered by a projection command
15:51:17 <paggas> jsn: what is the proper way to enable the alpha channel? with glutInitDisplayMode(GLUT_RGBA), right?
15:51:52 <jsn> that seems right, yeah
15:52:10 <jsn> why do you think the alpha channel is disabled?
15:53:24 <mopped> [b | b <- [1..1000], k <- [1..100], u <- [0..100], 2^k - 3*u /= b] how can I make it so that it only composes a list of values of b which has no values of k and u that meet the rule (ie, only adds it to the list after k and u and have both looped out)
15:54:05 <pumpkin_> looped out?
15:54:06 <tibbe> nominolo: did you test network-bytestring with base-4?
15:54:06 <lambdabot> tibbe: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:55:00 <nominolo> tibbe: don't know, probably not, since that would fail due to extensible exceptions, i presume
15:55:03 <paggas> jsn: heck, i enabled antialiasing from nvidia-settings, and it works now!
15:55:21 <tibbe> nominolo: I would be interested hearing about that parser/enumerator thing. I've been rewriting that part of Hyena lately.
15:55:26 <jsn> paggas: aha
15:55:26 <tibbe> nominolo: ok
15:55:32 <mopped> filter (\x -> null ([ x | k <- [1..100], u <- [1..100], 2^k - 3*u == x])) [1..100] is there a neater version of this?
15:55:32 <tibbe> nominolo: pushing anew version now
15:56:01 <paggas> jsn: maybe i need to call some special nvidia specific function? :S
15:56:01 <nominolo> tibbe: take a look at http://github.com/nominolo/enumerator/tree/hacking
15:56:03 <lambdabot> Title: nominolo's enumerator at hacking â€” GitHub
15:56:14 <tibbe> will do
15:56:35 <nominolo> tibbe: that's in non-mergable state, but look at the bottom of the (only) file
15:57:40 <tibbe> nominolo: ok
15:57:53 <tibbe> nominolo: just pushed a new network-bytestring with your depency update
15:57:58 <tibbe> to hackage
16:00:19 <tibbe> nominolo: just browsed through the code, looks interesting
16:00:31 <tibbe> nominolo: I'll have another look in 2 weeks when I get back from Africa
16:01:15 <nominolo> tibbe: oooh.  have fun!
16:01:23 <mmorrow> i've been thinking about parsing lately and tend to use pushdown automata for by-hand-parsers in haskell with some mutually rec funcs and a single stack or a stack and a stack of stacks. apparently yacc/happy uses a single stack. then i started thinking about what type of other structure (other than a stack) would allow for context-sensitive parsing without making it painful, and have started considering seeing what i can do with a zi
16:01:23 <mmorrow> pper on a graph. anyone have any thoughts on that?
16:01:30 <jdrake> Who among you is brave enough to answer a question? I am looking towards writing a parser of sorts that would have potential application to multiple backends. The syntax it would parse is likely TeX style input (but not TeX itself). I need to make this extensible to new commands. Any ideas?
16:02:01 <nominolo> mmorrow: do you know "Parallel Parsing Processes" by Koen Claessen?
16:02:03 <mmorrow> (or the simpler case of a zipper on a tree)
16:02:10 <dmwit> jdrake: Look at the docs for Parsec.
16:02:19 <Peaker> I don't understand why everybody is writing parsers.. stop inventing syntaxes, use DSLs :)
16:02:20 <mmorrow> nominolo: ooh, yeah i'm in the process of working through that. great paper
16:02:32 <Pseudonym> DSLs need a syntax.
16:02:40 <Peaker> Pseudonym: not a parser
16:02:41 <nominolo> mmorrow: alternatively there's an interesting fully lazy parser google for "Polish Parsers Hughes Swierstra"
16:02:48 <vixey> what do you have againt  App (App (App (Lam .. ?
16:02:49 <vixey> :)
16:02:53 <Pseudonym> What do you propose, then, Peaker?
16:02:57 <mmorrow> Peaker: new languages need parsers :)
16:03:00 <jsn> Peaker: people don't need to agree on that
16:03:02 <vixey> jdrake: it is probably not actually the _parser_ that is changed, but the interpretation
16:03:04 <Peaker> Pseudonym: Use Haskell syntax ;)
16:03:07 <vixey> jdrake: (am I right?)
16:03:14 <Pseudonym> Peaker, ah, you refer to embedded DSLs.
16:03:14 <vixey> Peaker; (see above)
16:03:18 <jsn> haskell syntax does not have HERE documents
16:03:21 <Pseudonym> That's not _always_ appropriate.
16:03:24 <vixey> jsn, yes it does
16:03:27 <Peaker> vixey: Surely some infix magic can fix that ;)
16:03:33 <jsn> vixey: not in GHC
16:03:39 <Pseudonym> Sometimes, there's a sufficient disconnect between the model and the source code that a compiler is more appropriate.,
16:03:40 <mmorrow> Peaker: and there isn't a sufficiently capable haskell parser not tied to ghc and usable anywhere as far as i know..
16:03:42 <jdrake> vixey, probably right. It would probably have to be changed after that to figure out what is valid afterwards.
16:03:48 <dzlk> Arguably a DSL is by definition a syntax. Otherwise it's a library or a language extension or some such.
16:04:04 <vixey> jdrake: so you could have one fixed parses ?
16:04:05 <jsn> vixey: they have quasi-quoting in 6.10
16:04:08 <Pseudonym> dzlk: Arguably, many libraries are EDSLs.
16:04:09 <vixey> parser*
16:04:12 <Pseudonym> e.g. Parsec
16:04:35 <vixey> dzlk: pretty much everything is a DSL, it's weird to even have a name for it
16:04:45 <jdrake> vixey, Well, It is likely something like \command[parameter][...]{body} or something like that that has to be interpreted later.
16:04:56 <jdrake> Peaker, I am not seeing what makes a DSL different from the thing that processes latex input
16:05:07 <Peaker> jdrake: I said DSL I should have said EDSL
16:05:16 <jdrake> The difference?
16:05:29 <Pseudonym> jdrake: EDSL : Library :: DSL : Compiler
16:05:35 <mmorrow> Peaker: haskell-src-exts is nice, but fails when (e.g.) trying to parse the entire ghc src tree reliably
16:06:06 <Pseudonym> Nonetheless, some DSLs are already specified for you.
16:06:11 <Pseudonym> So you have no choice.
16:06:15 <Pseudonym> e.g. ASN.1
16:06:17 <Peaker> mmorrow: well, some other standard syntax for EDSL's then.  Reinventing grammars all the time is annoying ;)  Also, it would be nice if there were nice GUI editors for this structure, instead of a grammar altogether
16:06:21 <Pseudonym> Or XSLT.
16:06:35 <jdrake> Pseudonym, I do not quite see what you mean
16:06:44 <vixey> Peaker: "it would be nice if there were nice GUI editors for this structure" - yes, do it
16:06:46 <Pseudonym> ASN.1 is a DSL which is already specified for you.
16:06:53 <Pseudonym> You can't embed ASN.1 in Haskell.  Not really.
16:06:58 <Pseudonym> You need to compile it to Haskell.
16:07:17 <shapr> Like Dominic Steinitz' project does.
16:07:22 <mmorrow> Peaker: totally, s/gui/gui+anything that makes it easier/
16:07:23 <Pseudonym> Precisely.
16:07:41 <jdrake> What does the 'E' standard for
16:07:47 <Pseudonym> Embedded
16:08:08 <Pseudonym> OTOH, you can't compile yacc to Haskell, since C is implicitly embedded in the yacc semantic actions.
16:08:21 <Pseudonym> So for parsing, you can come up with your own DSL, and embed it.
16:08:40 <jsn> we will be writing plain text in 80 column terminals forever
16:08:59 <Peaker> jsn: why do you hate programmers?
16:09:00 <Pseudonym> Standards are good.  If there's a standard which does it, you'd better have a good reason not to use it.
16:09:01 <Adamant> jsn: the alternative is writing code in XML
16:09:20 <jsn> Peaker: plain text is truly refined
16:09:27 <Adamant> which has been seriously proposed
16:09:43 <Peaker> jsn: then why almost all of the keys in my editor map to actions that do unsenseful things to my Haskell program?
16:09:59 <jsn> Peaker: what?
16:10:03 <Pseudonym> Adamant: You identify the problem with standards, which is that people apply them to situations which they weren't designed for.
16:10:09 <jsn> Peaker: i'm not sure what that has to do with anything
16:10:14 <jdrake> Ah, an EDSL is not what I am after
16:10:20 <Pseudonym> And arguably are a poor fit.
16:10:29 <Peaker> jsn: I want an editor that maps keyboard keys to useful, meaningful changes to the code. Not a dumb text string
16:11:18 <jsn> Peaker: well, you want too much
16:11:26 <b_jonas> that reminds me, I'll have to patch an option in my editor for the bracket matching to not treat backslashes as something that esacpe a bracket
16:11:27 <steven_ashley> Hi guys, is there any reason why data types and classes can't have the same identifier. Other than to reduce confusion?
16:11:32 <teratorn> jsn: haha, nonsense :)
16:11:40 <b_jonas> becuase \(x,y) -> foo sometimes occurs in haskell
16:11:42 <teratorn> jsn: this is an active area of research :)
16:11:49 <jsn> thankfully, no one ever has an no one ever will get over the visual coding hump
16:11:56 <Pseudonym> Peaker: Someone needs to design a keyboard with only two keys.  "Do What I Mean" and "Now Do What I Meant To Say".
16:12:01 <jsn> it has been an active area of research forever
16:12:06 <Peaker> Pseudonym: ;)
16:12:24 <Peaker> jsn: Difficult problems have been solved before
16:12:36 <Peaker> jsn: Pure FP was not thought practical for a long while, was it?
16:12:37 <jsn> ill-posed problems don't get solved
16:13:12 <nominolo> steven_ashley: well, for one thing, a class is implemented as a record (a lookup table if you will)
16:13:27 <vixey> steven_ashley, it does seem like a non-essential restriction
16:13:29 <teratorn> I'm tempted to paste the subtext video link.. not that subtext is particularly interesting, but I think it shows that these problems *can* be solved
16:13:29 <dzlk> XML is really just a text representation with an extra layer of syntax, which is one of the reasons I think coding in XML is a terrible idea.
16:13:50 <vixey> teratorn: Code has to be written though
16:14:01 <b_jonas> steven_ashley: how about does the export syntax?
16:14:02 <vixey> teratorn: no one does this because current tools are good enough
16:14:13 <nominolo> steven_ashley: but you could certainly introduce another namespace for it, but there may be ambiguities in the syntax
16:14:25 <teratorn> vixey: I don't think they're good enough. I think that the cost of change is prohibitive, however.
16:14:37 <Twey> Grr, what was the reasoning behind making ^^ do exponentiation instead of the more logical tetration?  :(
16:14:42 <Peaker> vixey: "good" is a relative term. When something better pops up, the old thing is no longer "good enough"
16:14:52 <nominolo> Twey: the logical what?
16:14:54 <teratorn> Peaker: yeah, well put
16:15:25 <Twey> nominolo: Tetration... n ^^ 3 = n ^ n ^ n
16:15:30 <b_jonas> Twey: is tetration actually useful?
16:15:36 <Twey> b_jonas: Yes
16:15:40 <steven_ashley> nominolo: I thought there might be, b_jonas brings up a good point though currently classes are implicitly exported so I think that is less of an issue.
16:15:54 <Twey> I was just using in in a SICP exercise :-\
16:15:59 <b_jonas> Twey: I mean, so useful to get such a shorthand notation
16:16:05 <Twey> Probably not
16:16:16 <Twey> But ^^ shouldn't be exponentiation :-\
16:16:22 <b_jonas> steven_ashley: isn't it instances that are implicitly exported?
16:16:29 <loop_> used in 1 sicp exercise /= used all the time
16:16:31 <steven_ashley> ahh sorry yes, your right there
16:16:32 <Twey> It's like defining (/) to do addition
16:17:10 <nominolo> :t (^^)
16:17:11 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
16:17:11 <steven_ashley> yep that would create an ambiguity
16:17:14 <steven_ashley> cheers :)
16:17:41 <b_jonas> otoh the whole export and import syntax is strange and hard to extend
16:17:55 <b_jonas> with the type and value namespaces together
16:18:15 <b_jonas> some ghc extension even clashes with it I think
16:18:24 <nominolo> b_jonas: there're suggestions for adding keywords
16:18:51 <nominolo> ie, import Foo ( type A, class B )
16:18:56 <paggas> what is the haskell equivalent of {if (x) return;} ? that is, if a condition is true, exit from an IO computation without executiong the rest of the instructions
16:19:06 <mauke> paggas: no such thing
16:19:10 <steven_ashley> b_jonas: The reason I am asking is I am silly of making up names for existential types :P
16:19:29 <nominolo> paggas: unless x (rest of instructions ...)
16:19:31 <Peaker> hmm, wouldn't it make sense to have (+), (++)=(*), (+++)=(^), (++++)=(^^), and so on? :)
16:19:32 <mauke> 'if x then return () else do'
16:19:51 <nominolo> mauke: return () is tricky
16:19:58 <nominolo> mauke: for newbies that is
16:20:09 * Peaker just realized "if" is the catamorphism of Bool
16:20:19 <geezusfreeek> nomeata, i don't see how unless is any less tricky though
16:20:22 <geezusfreeek> @src unless
16:20:22 <lambdabot> unless p s = if p then return () else s
16:20:32 <steven_ashley> @src when
16:20:32 <lambdabot> when p s = if p then s else return ()
16:20:34 <b_jonas> Peaker: no, we should have (+) for addittion, (Ã—) for multiplication, (*) for exponentiation
16:20:52 <b_jonas> and (%) for division of course
16:21:08 <geezusfreeek> i think % makes fine sense for rationals
16:21:11 <steven_ashley> b_jonas: what about the poor C programmers ;)
16:21:14 <b_jonas> or maybe (Ã·) for division instead
16:21:23 <mauke> (âŠ˜)
16:21:28 <geezusfreeek> b_jonas, what is wrong with (/) for division?
16:21:31 <Peaker> @type guard
16:21:32 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
16:21:42 <nominolo> geezusfreeek: the problem with return is that it doesn't actually return in the way it does in other languages
16:21:42 <nominolo> geezusfreeek: it's really "pass" or "skip"
16:22:02 <geezusfreeek> nominolo, yes, and unless does the same thing
16:22:12 <b_jonas> unless?
16:22:17 <geezusfreeek> @src unless
16:22:18 <lambdabot> unless p s = if p then return () else s
16:22:22 <b_jonas> ah
16:22:34 <b_jonas> that's useful
16:22:47 <b_jonas> it allows me to write that thing from yesterday more concisely
16:22:55 <geezusfreeek> b_jonas, also see when
16:22:56 <geezusfreeek> @src when
16:22:57 <lambdabot> when p s = if p then s else return ()
16:23:09 <nominolo> geezusfreeek: well, unless doesn't contain a visible "return" so it's harder to think it would actually "return" (in the java/c sense)
16:23:24 <steven_ashley> unless = when . not
16:23:26 <steven_ashley> ;)
16:23:34 <nominolo> :t when . not
16:23:35 <geezusfreeek> i suppose
16:23:35 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
16:23:43 <nominolo> steven_ashley: nope
16:23:49 <steven_ashley> :t unless
16:23:51 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
16:23:55 <steven_ashley> hmm?
16:23:59 <nominolo> err...
16:24:05 <geezusfreeek> i think that is right
16:24:26 <nominolo> hm, got me confused
16:24:29 <steven_ashley> lol
16:24:58 <nominolo> monadic + pure function composition always confuses me
16:25:22 * nominolo prefers pointed style in all but the most simplest cases
16:25:52 <b_jonas> @let input = [1, 0, 2, 3, 4, 5, 0, 0, 0, 4, 3, 2, 4];
16:25:53 <lambdabot>  <local>:4:0:
16:25:53 <lambdabot>      Multiple declarations of `L.input'
16:25:53 <lambdabot>      Declared at: <loca...
16:25:56 <b_jonas> @let input = [1, 0, 2, 3, 4, 5, 0, 0, 0, 4, 3, 2, 4]
16:25:57 <lambdabot>  <local>:4:0:
16:25:57 <lambdabot>      Multiple declarations of `L.input'
16:25:57 <lambdabot>      Declared at: <loca...
16:26:01 <b_jonas> @let inp = [1, 0, 2, 3, 4, 5, 0, 0, 0, 4, 3, 2, 4]
16:26:02 <lambdabot>  Defined.
16:26:03 * geezusfreeek usually prefers point free style except when flip is required to do so
16:26:08 <geezusfreeek> or a crazy amount of parens
16:26:12 <b_jonas> > evalState (mapM (\x -> do { unless (0 == x) (put x); get }) input) 0
16:26:13 <steven_ashley> nominolo: if you think of when as when :: Bool -> (m () -> m ()) it makes things easier
16:26:14 <lambdabot>   [1,1,2,3,4,5,5,5,5,4,3,2,4]
16:26:15 <b_jonas> there
16:26:17 <Peaker> nominolo: @pl is slowly gaining favor with me ;)  I love liftA* stuff
16:26:45 <b_jonas> that's like what I wrote yesterday but then I was using if ... then ... else return () explicitly
16:27:00 <geezusfreeek> @pl evalState (mapM (\x -> do { unless (0 == x) (put x); get }) input) 0
16:27:00 <lambdabot> (line 1, column 27):
16:27:01 <lambdabot> unexpected "{"
16:27:01 <lambdabot> expecting variable, "(", operator or ")"
16:27:05 <geezusfreeek> woop
16:27:25 <geezusfreeek> @pl \x -> unless (0 == x) (put x)
16:27:26 <lambdabot> liftM2 unless (0 ==) put
16:27:57 <nominolo> Peaker: yes, but i find myself trying to @unpl it the next time i try to read that code.
16:28:04 <geezusfreeek> @pl \x -> unless (0 == x) (put x) >> get
16:28:05 <lambdabot> (>> get) . liftM2 unless (0 ==) put
16:28:26 <nominolo> Peaker: which is why i think @pl can be a huge maintainability killer
16:28:27 <geezusfreeek> ^ is starting to get weirder
16:28:55 <steven_ashley> @pl \a -> a >>= id
16:28:55 <lambdabot> join
16:29:00 <geezusfreeek> i find point free style easier to read now
16:29:08 <geezusfreeek> than pointed style, much of the time
16:29:11 <Peaker> nominolo: I'm slowly starting to think in these weird terms that some of the @pl stuff that seemed crazy seems readable now (Still a lot seems just crazy :)
16:29:52 <SubStack> pl <3
16:30:06 <b_jonas> @pl (<3)
16:30:06 <lambdabot> (< 3)
16:30:09 <nominolo> yes, but if you want your code to be hackable, you shouldn't scare off, say 50+% of potential contributors
16:30:11 <Peaker> nominolo: I think when I saw vixey use  liftA2 (/) sum length,  I had a *ting* of understanding :)
16:30:48 <b_jonas> Peaker: oh yeah, that one is The example they show J forks to J beginners
16:30:56 <nominolo> > liftA2 (/) sum length [1..]
16:30:56 <Peaker> @unpl liftA2 (/) sum length
16:30:57 <lambdabot> liftA2 (/) sum length
16:30:57 <lambdabot>       No instance for (Fractional Int)
16:30:58 <lambdabot>        arising from a use of `/' at <i...
16:30:58 <b_jonas> (+/%#) meaning average
16:31:09 <Peaker> nominolo: if you gotta nit-pick it has to be genericLength ;)
16:31:22 <nominolo> :t liftA2 (/) sum length
16:31:23 <lambdabot>     No instance for (Fractional Int)
16:31:23 <lambdabot>       arising from a use of `/' at <interactive>:1:7-9
16:31:23 <lambdabot>     Possible fix: add an instance declaration for (Fractional Int)
16:31:31 <Peaker> :t liftA2 (/) sum genericLength
16:31:32 <lambdabot> forall a. (Fractional a) => [a] -> a
16:31:46 <Saizan> == average
16:31:51 <Peaker> > (liftA2 (/) sum genericLength) [10,20,30]
16:31:52 <lambdabot>   20.0
16:31:54 <nominolo> is that A for arrow or A for applicative?
16:31:58 <Peaker> nominolo: Applicative
16:32:04 <Peaker> nominolo: liftM2 would also work
16:32:08 <Peaker> > (liftM2 (/) sum genericLength) [10,20,30]
16:32:09 <lambdabot>   20.0
16:32:30 <Peaker> b_jonas: what are J forks?
16:32:40 <mauke> > (return (/) <*> sum <*> genericLength) [10,20,30]
16:32:42 <lambdabot>   20.0
16:32:48 <mauke> > (pure (/) <*> sum <*> genericLength) [10,20,30]
16:32:49 <lambdabot>       Ambiguous occurrence `pure'
16:32:50 <lambdabot>      It could refer to either `Control.Appl...
16:32:51 <RayNbow> :t let infixl 1 Â«, Â»; (Â«) = flip liftM2; (Â») = ($);    in    sum Â«(/)Â» genericLength
16:32:52 <mauke> meh
16:32:53 <lambdabot> forall a. (Fractional a) => [a] -> a
16:33:02 <nominolo> well if you code contains average = ... then it's still maintainable, i guess :)
16:33:06 <b_jonas> Peaker: it's a builtin rule in the J grammar
16:33:24 <Peaker> > ((/) <$> sum <*> genericLength) [10,20,30]
16:33:26 <lambdabot>   20.0
16:33:29 <Saizan> , [$i| (/) sum genericLength |] [10,20,30]
16:33:56 <lunabot>  20.0
16:34:25 <geezusfreeek> Saizan, what extension is that one?
16:34:35 <RayNbow> looks like Template Haskell
16:34:35 <b_jonas> Peaker: it says that if u, v, w are three verbs then the expression u v w (which you usually have to parenthisize) is evaluated to a verb that's like liftM2 v u w when monadically used
16:34:38 <Peaker> nominolo: I think of functions as "boxes" that contain their result, and liftA2 takes a function and makes it apply to the contents of 2 boxes, returning a box with the result. In this case, the box with the result is another function..
16:34:39 <nominolo> Saizan: i for "idiom" ?
16:34:44 <Saizan> nominolo: right
16:34:56 <b_jonas> Peaker: and \x y -> v (u x y) (w x y) when diadically used
16:35:13 <Saizan> geezusfreeek: the [$foo| ... |] syntax is quasiquoting, part of TH in 6.10
16:35:18 <Peaker> b_jonas: what if the verb takes verbs normally? Does it still lift it?
16:35:23 <geezusfreeek> quasiquoting, that what i was looking for
16:35:53 <steven_ashley> nominolo: I think the biggest maintenance cost is things like forgetting about some state you later need. You need to thread it through all of your computations. Or not using generic data structures, so that later when you want to change the structure, you need to change every function that uses it.
16:35:59 <Peaker> nominolo: so   liftA2 (/) sum length   takes the box with the sum, and divides it by the box with the length
16:36:20 <Peaker> nominolo: but Applicative values cannot leave their boxes, so the result must also remain in a box
16:36:25 <geezusfreeek> i tend to use pointed style for exploratory programming, i must admit
16:36:26 <b_jonas> Peaker: a verb does not take verbs, if you want something that takes verbs you need either an adverb or conjuction, or pass the gerund form of the verb (which is a noun that represents that verb or in general any type of value)
16:36:31 <mmorrow> nominolo: just got "Polish Parsers, step by step". looks verrrry interesting :)
16:36:44 <geezusfreeek> well, more often than the final result anyway
16:36:50 <Peaker> b_jonas: does that mean it doesn't have higher-order stuff? only 2nd-order or such?
16:37:12 <nominolo> mmorrow: fwiw, Yi contains an implementation of it
16:37:12 <nominolo> mmorrow: and probably polyparse too
16:37:21 <nominolo> mmorrow: though, the latter is GPL
16:37:45 <b_jonas> Peaker: you can have higher-order because a gerun can represent not only a verb but a noun or adverb or conjunction too; also an adverb or conjunction can return (but not accept) any value
16:38:11 <nominolo> Peaker: yes, but you have to know how the Applicative instance for that particular type works
16:38:31 <nominolo> Peaker: for example, there's also the ZipList variant
16:38:32 <Peaker> nominolo: well, the type is function
16:38:34 <mmorrow> nominolo: oh, nice. i saw that Yi code a few weeks ago and took note, but haven't gone back to look at it yet or knew it was related to this paper
16:38:43 <Peaker> nominolo: in this case, since sum and length are functions
16:39:00 <b_jonas> Peaker: also you can manipulate names (symbols) whose associated variable store a value of any part of speach, and you can create an anonymous name by creating an anon locale (namespace) and using some name from it
16:39:12 <Peaker> b_jonas: that reminds me of K, is it related?
16:39:14 <mmorrow> on the topic of Yi, i think Yi is going to become great
16:39:15 <nominolo> Peaker: ahh, right, i was thinking of lists
16:39:17 <b_jonas> Peaker: yes
16:39:39 <Peaker> b_jonas: Is K used outside of the financial industry, making its author millions?
16:40:22 <nominolo> mmorrow: it's coming along nicely
16:40:22 <b_jonas> Peaker: K is later than J, has much fewer primitives, is said to be faster but that's becasue it does not check overflow for integer operations and in such way lower-level than J,
16:40:46 * Peaker visited a Hedge Fund in NYC, where K was shown.  One crazy language ;)
16:40:47 <b_jonas> Peaker: I don't know. I tried to find stuff out about K but I didn't find good documentation so I decided I don't need it
16:41:00 <Peaker> b_jonas: The guy I talked to in the hedge fund was a big K fan
16:41:19 <nominolo> J is crazy
16:41:20 <Pseudonym> So how much is programming languages the cause of the current financial crisis?
16:41:23 <b_jonas> Peaker: plus I use J as a way to write quick calculations very easily, not for big programs, and for this reason more builtins are a big advantage
16:41:33 <b_jonas> nominolo: yes, it is
16:41:42 <Peaker> b_jonas: does it save you a lot over ghci?
16:42:06 <b_jonas> Peaker: probably yes, but it might just be that I'm not good enough in haskell yet
16:42:25 <b_jonas> Peaker: it makes lots of Project Euler-like comutations very easy, especially ones with numbers
16:42:31 <jsn> Pseudonym: a strongly normalizing language would not have accepted the specification for many mortgage backed securities
16:42:40 <b_jonas> Peaker: though I don't do Project Euler itself, I do have to calculate similar stuff sometimes
16:42:55 <b_jonas> jsn: lol
16:43:47 <b_jonas> Peaker: J gets concise for things you commonly want to do, but it gets awkward if you want to do general things
16:43:58 <b_jonas> like lambdas or higher-order stuff or anything general I can think of
16:44:01 <Peaker> b_jonas: The guy said "You may get the impression K can only do a bunch of very specific things well, but in no way scale to do general things well, but it turns out, it can do general things well"
16:44:17 <b_jonas> no, I don't know what K can do
16:44:20 <BONUS_> I saw a blog post detailing how Haskell could have actually been used to avert the economic crisis by using a contract monad
16:44:26 <BONUS_> or something like that
16:44:38 <b_jonas> and I'm also not saying definitely that J can only do some things well, because there are some people who use it as a general programming language
16:44:41 <b_jonas> but I don't
16:44:51 <b_jonas> I don't write long programs in J
16:44:53 <b_jonas> at least not yet
16:44:57 <Peaker> I saw "Money as Debt", and it predicts huge foreclosure crises OR exponentially growing sums of money are inevitable
16:45:16 <b_jonas> if I reimplemented J and added my extensions, maybe I could write longer stuff in it
16:45:16 <BONUS_> yeah i saw that too
16:45:27 <Peaker> (if the total amount of money does not grow exponentially fast enough, someone must foreclosure)
16:45:38 <geezusfreeek> Money as Debt made a lot of sense, for the most part
16:45:43 <BONUS_> its interesting though how i get stuff like FP but i really dont understand economy
16:45:53 <BONUS_> even watching that Money as Debt only made it partly clear
16:46:09 <Peaker> geezusfreeek: I wish it used a bit less demagogic-stuff like the pyramid, or the Death-Banging on a "Debt" sign
16:46:17 <Peaker> it makes it seem like propaganda :)
16:46:31 <geezusfreeek> yeah
16:46:41 <geezusfreeek> well, it kind of is, i think
16:46:53 <Peaker> BONUS_: I think I watched Money as Debt like 3 times.  There are a few things that don't add up for me
16:46:57 <geezusfreeek> even to the point of making very specific suggestions at the end
16:47:09 <b_jonas> anyway, good night now
16:47:29 <geezusfreeek> some of the proposed solutions don't seem to fit the problem to me
16:47:36 <BONUS_> yeah
16:48:04 <Peaker> BONUS_: The initial investor money is supposedly multiplied by 90, not 9 to form loan money. But this is not true because if they did that, they could not have 10% more deposits than loans.  I think the multiplier is just 9, and not 90 (and this is what mainstream economy says, I think, too)
16:48:30 <BONUS_> hmmm
16:48:33 <Peaker> Now, if the multiplier is 9, that means that they've exhausted their ability to create money - and cannot loan you more money to create money...
16:49:20 <Peaker> By saying that people can go in debt to create money, that means that we've not hit the factor of 9 limit yet
16:49:38 <BONUS_> yeah, when you put it that way..
16:49:39 <Peaker> But if so, is their claim that 95% of money is non-reserve possibly true?
16:50:05 <geezusfreeek> Peaker, interesting. i will have to watch it again to catch up to your argument though
16:50:21 <geezusfreeek> i will take notes next time
16:50:35 <BrokenClockwork> http://hpaste.org/11622 : I would like to reform this into a [Integer]->Integer->[Integer], but I have no clue yet, just goofed a little bit around
16:51:07 <geezusfreeek> BrokenClockwork, what is it supposed to do?
16:51:26 <BrokenClockwork> ah nevermind I need it to return a function
16:51:34 <BrokenClockwork> eh an Integer
16:51:40 <BrokenClockwork> it's alright
16:51:47 <Peaker> BrokenClockwork: would be nice to replace the recursion with some higher-order magic
16:52:06 <int-e> > scanl (\x y -> x*10 + y) 0 [1,2,3,4,5,6,7,8,9] -- hmm.
16:52:07 <lambdabot>   [0,1,12,123,1234,12345,123456,1234567,12345678,123456789]
16:52:08 <BrokenClockwork> huh? *g*
16:52:15 <BrokenClockwork> sorry I don't get this one
16:52:16 <geezusfreeek> that use of length makes me cringe... O(n^2) as it is
16:54:48 <geezusfreeek> time to leave work!
16:54:48 <Peaker> dec digits base = sum $ zipWith (*) (iterate (base*) 1) (reverse digits)
16:55:18 <Peaker> BrokenClockwork: how about that one?
16:55:18 <int-e> dec xs b = foldl' (\x y -> b*x + y) 0 xs
16:55:41 <Peaker> @type foldl'
16:55:42 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
16:55:53 <geezusfreeek> @pl \x y -> b*x + y
16:55:54 <lambdabot> (+) . (b *)
16:56:02 <geezusfreeek> eh, a bit weird i guess
16:56:53 <geezusfreeek> @pl  dec xs b = foldl' (\x y -> b*x + y) 0 xs
16:56:53 <lambdabot> dec = flip (flip foldl' 0 . ((+) .) . (*))
16:56:59 <geezusfreeek> @pl  dec b xs = foldl' (\x y -> b*x + y) 0 xs
16:57:00 <lambdabot> dec = flip foldl' 0 . ((+) .) . (*)
16:57:13 <BrokenClockwork> that looks pretty
16:57:20 <BrokenClockwork> but well, dunno *shrug*
16:57:34 <geezusfreeek> :t  \b -> foldl' (\x y -> b*x + y) 0
16:57:35 <lambdabot> forall b. (Num b) => b -> [b] -> b
16:58:14 <BrokenClockwork> well I won't complain my first haskell programm is working :)
16:58:17 <geezusfreeek> dec b = foldl' (\x y -> b*x + y) 0 -- :)
16:58:50 <Saya> well im glad we can still make comments in haskell :) im sure you could reduce this to half its size!
16:58:52 <mmorrow> @src foldl
16:58:52 <lambdabot> foldl f z []     = z
16:58:52 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
16:58:57 <mmorrow> @src foldl'
16:58:57 <lambdabot> foldl' f a []     = a
16:58:58 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
16:59:31 <mmorrow> foldl' f a! (x:xs) = foldl' f (f z x)  xs
16:59:42 <mmorrow> (equiv)
16:59:47 <mmorrow> oops
16:59:53 <mmorrow> foldl' f !a (x:xs) = foldl' f (f z x)  xs
16:59:56 <mmorrow> ;)
17:07:09 <mmorrow> , let list n _ [] = n ; list _ c (x:xs) =  c x xs ; foldl' = fix (\k f !a xs -> list a (\x xs -> k f (f a x) xs) xs) in foldl' (+) 0 [1..1000000]
17:07:19 <lunabot>  500000500000
17:07:52 <__abz> @pl all2 f a b = all (uncurry f) (zip a b)
17:07:52 <lambdabot> all2 = (. zip) . (.) . all . uncurry
17:08:22 <mmorrow> @pl \f a xs -> fix (\k f !a xs -> list a (\x xs -> k f (f a x) xs) xs) f a xs
17:08:22 <lambdabot> (line 1, column 22):
17:08:23 <lambdabot> unexpected "!"
17:08:23 <lambdabot> expecting pattern or "->"
17:08:28 <mmorrow> @pl \f a xs -> fix (\k f a xs -> list a (\x xs -> k f (f a x) xs) xs) f a xs
17:08:29 <lambdabot> fix (const . const . join . flip list . (`ap` join (join id)))
17:09:44 <mmorrow> i can't believe there's a `maybe' and `either' but no `list' :(
17:10:17 <Taral> mmorrow: foldr
17:10:31 <mmorrow> it's different
17:10:35 <Taral> how?
17:11:12 <gwern> 'lo all
17:11:12 <lambdabot> gwern: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:11:14 <int-e> 'list' only takes apart the outermost constructor.
17:11:23 <Taral> @type  \f a xs -> fix (\k f a xs -> list a (\x xs -> k f (f a x) xs) xs) f a xs
17:11:24 <lambdabot> Not in scope: `list'
17:11:36 <Taral> @type \f a xs -> fix (\k f a xs -> list a (\x xs -> k f (f a x) xs) xs) f a xs
17:11:37 <lambdabot> Not in scope: `list'
17:11:39 <mmorrow> , let list n _ [] = n ; list _ c (x:xs) =  c x xs in list Nothing (Just . zip [0..] . fmap (:[])) [0..4]
17:11:40 <Taral> ?
17:11:45 <lunabot>  luna: Couldn't match expected type `[[a1]] -> Data.Maybe.Maybe a'
17:11:48 <mmorrow> grr
17:12:00 <mmorrow> oh heh
17:12:23 <Taral> @type \n c l -> match l with [] -> n | x:xs -> c x xs
17:12:24 <lambdabot> parse error on input `->'
17:12:47 <int-e> case l of
17:12:54 <int-e> where did "match l with" come from?
17:12:56 <mmorrow> , let list n _ [] = n ; list _ c (x:xs) =  c x xs in list Nothing (\x xs -> list [x] (\y ys -> y:x:ys++xs)) [0..4]
17:12:57 <Taral> @type \n c l -> case l of [] -> n | x:xs -> c x xs
17:12:58 <lambdabot> parse error on input `|'
17:13:01 <lunabot>  luna: Couldn't match expected type `Data.Maybe.Maybe a'
17:13:04 <mmorrow> gahh
17:13:08 <Taral> @type \n c l -> case l of {[] -> n; x:xs -> c x xs}
17:13:09 <lambdabot> forall t t1. t -> (t1 -> [t1] -> t) -> [t1] -> t
17:13:10 <mmorrow> , let list n _ [] = n ; list _ c (x:xs) =  c x xs in list [9] (\x xs -> list [x] (\y ys -> y:x:ys++xs)) [0..4]
17:13:16 <lunabot>  luna: Couldn't match expected type `[t]'
17:13:22 <gwern> @messages
17:13:22 <lambdabot> ivanm said 23h 31m 4s ago: this was _darcs_ I was trying it with!
17:13:23 <lambdabot> ivanm said 23h 11m 41s ago: What I was hoping what that change-monger would parse the _entire_ darcs changes history
17:13:25 <Taral> oho!
17:13:27 <Taral> that's right.
17:13:38 <Taral> mmorrow: list has an infinite type, I think.
17:13:54 <Taral> oh, no.
17:13:57 <mmorrow> it's related to that, totally
17:13:57 <Taral> something related does.
17:14:02 <mmorrow> heh, yes
17:14:06 <mmorrow> check out SAPL
17:14:10 <Taral> anyway, most of the time you use case
17:14:11 <int-e> @type let list n _ [] = n ; list _ c (x:xs) =  c x xs in list
17:14:12 <lambdabot> forall t t1. t -> (t1 -> [t1] -> t) -> [t1] -> t
17:14:24 <gwern> @tell ivanm parse the entire history? if you want the entire thing, just call 'darcs changes'. I think there's a function for doing something that simple. maybe you could write this up in an email or something in detail because I'm not seeing your issue with the details you've given me
17:14:24 <lambdabot> Consider it noted.
17:14:40 <mmorrow> , let list n _ [] = n ; list _ c (x:xs) =  c x xs in list [9] (\x xs -> list [x] (\y ys -> y:x:ys++xs) xs) [0..4]
17:14:46 <lunabot>  [1,0,2,3,4,1,2,3,4]
17:14:50 <mmorrow> finallyy
17:15:03 <gwern> haskell facts:
17:15:07 <gwern> 1) all Haskellers are mammals
17:15:18 <gwern> 2) haskellers exist to flip out and code
17:15:28 <gwern> 3) they flip out and code *all* the time
17:15:43 <Adamant> 4) something about monads and awesomeness
17:15:57 <Taral> mmorrow: Either and Maybe aren't inductive types. So simple elimination is a more common operation for them.
17:16:00 <int-e> @type \n c -> snd . foldr (\x (y, z) -> (c x z, x:z)) (n, [])
17:16:01 <lambdabot> forall a a1. a -> (a1 -> [a1] -> a) -> [a1] -> [a1]
17:16:10 <int-e> @type \n c -> fst . foldr (\x (y, z) -> (c x z, x:z)) (n, [])
17:16:11 <lambdabot> forall a a1. a -> (a1 -> [a1] -> a) -> [a1] -> a
17:16:25 <BrokenClockwork> so
17:16:28 <Taral> int-e: cute!
17:16:52 <BrokenClockwork> if && is the opposite to ||, what's the opposite to == ?
17:17:05 <int-e> Taral: it's hopelessly inefficient, of course :)
17:17:11 <Taral> yeah. :(
17:17:14 <BrokenClockwork> ./0
17:17:15 <BrokenClockwork> nvm
17:17:18 <BrokenClockwork> ./=
17:17:59 <Taral> BrokenClockwork: Doesn't really apply.
17:18:10 <Taral> && is dual to || because a && b == ~(~a || ~b)
17:18:46 <Taral> I suppose /= would be dual to ==, but how is that useful?
17:20:21 <quuxman> I'm trying to install Yi but it complains I don't have alex (which I installed). However, alex doesn't appear in "ghc-pkg list", just seems to have a executable in ~/.cabal/bin
17:21:09 <Taral> ok I go home now.
17:24:39 <alexsuraci> I wish people would stop having alex troubles so I don't get pinged all the time D:
17:25:04 <quuxman> alexsuraci: heh. You don't know anything about this problem do you?
17:25:09 <Peaker> hehe, why does alex ping you? nick completion exists
17:25:31 <alexsuraci> quuxman: nope, my IRC app just goes "ding!" all the time :P
17:25:55 <alexsuraci> I have it set for alex for other channels
17:26:14 <gwern> My friend Mark said that he saw a Haskeller totally prove some kid's theorem just because the kid opened a window.
17:26:26 <gwern> And that's what I call REAL ULTIMATE POWER!!!!!
17:26:50 <Japsu> POZAH
17:26:58 <dolio> @quote OlegFacts
17:26:59 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
17:27:33 <gwern> 'Q: Why is everyone so obsessed with Haskell? A: Because Haskellers are the ultimate paradox: on the one hand, they don't give a crap, and avoid success at all costs, and on the other, they are mathematically precise'
17:28:10 <Ikkebr> hah great
17:28:45 <gwern> 'Q: What do Haskellers do when they're not flipping out or coding? A: Most of their free time is spent writing monad tutorials, but sometimes they prove stuff about their code. (Ask Mark if you don't believe me.)'
17:28:46 <Ikkebr> > @quote OlegFacts
17:28:47 <lambdabot>   <no location info>: parse error on input `@'
17:28:57 <Ikkebr> @quote OlegFacts
17:28:57 <lambdabot> OlegFacts says: GHC doesn't have a type checker. It emails your types to Oleg for checking.
17:29:26 <quuxman> ah "Currently, Cabal doesn't track programs, just libraries" (from Yi page on HaskellWiki)
17:29:29 <rwbarton> @quote ghc exploded
17:29:29 <lambdabot> ghc says: My brain just exploded.
17:29:37 <rwbarton> ... so what does it mean when that happens? :)
17:29:53 <gwern> quuxman: yeah, it's quite an annoyance huh
17:30:02 <dolio> You used a let binding to destruct an existential wrapper.
17:30:22 <rwbarton> hmm, failed attempt at humor
17:30:37 <dolio> There's more to the error message than that.
17:30:39 <Peaker> Hmm.. there's no:  Ord k => [(k, a)] -> Map k [a]   ?
17:30:50 <gwern> rwbarton: it means you did something very wrong, and it's time to employ the ancient art of errorku. The ancient art of aborting yourself if you can't find anyone else to.
17:30:57 <int-e> @type Data.Map.fromList
17:30:58 <lambdabot> forall k a. (Ord k) => [(k, a)] -> M.Map k a
17:31:05 <int-e> ah.
17:31:05 <Peaker> int-e: I have repetitions
17:31:20 <Pseudonym> gwern: Not true.  I spend more time providing lemmas to the type checker so that _it_ can prove stuff about my code.
17:31:22 <gwern> Haskellers use all sorts of techniques to terminate themselves. 'error', killThread, throwSignal, etc. that's why there are so few Haskellers left today
17:31:50 <Peaker> @hoogle [(k, a)] -> Map k [a]
17:31:51 <lambdabot> No results found
17:31:54 <Peaker> :-(
17:32:06 <rwbarton> @type M.fromListWith (++)
17:32:07 <lambdabot> forall a k. (Ord k) => [(k, [a])] -> M.Map k [a]
17:32:13 <int-e> @type Data.Map.fromListWith (++) . map (second (:[]))
17:32:15 <lambdabot> forall b d. (Ord d) => [(d, b)] -> M.Map d [b]
17:32:22 <int-e> not pretty.
17:32:28 <quuxman> blarg, it says in the next sentence to just "cabal install alex" (which I've done) and it'll fix it. But Yi has a _dependency_ on alex, and cabal doesn't even know it exists
17:32:50 * gwern reads the Haskell timeline. '4.5 bya: Haskellers discover flipping out, and so Church gives them dominion over everything computable'
17:32:55 <quuxman> maybe the darcs version will work
17:33:05 <Peaker> int-e: thanks
17:33:11 <gwern> quuxman: interesting. but with yi, it's always a good idea to try to use darcs :)
17:33:24 <Pseudonym> To be fair, Church only gave us dominion over terminating computations.
17:33:49 <gwern> who got the non-terminating ones?
17:33:55 <Adamant> Oleg
17:34:02 <ushdf> http://en.wikipedia.org/wiki/Monad_(Gnosticism)
17:34:02 <gwern> (and if it doesn't terminate, is it really a computation?)
17:34:12 <ushdf> gwern: turing says yes
17:34:29 <gwern> ack. nm then. far be it from me to contradict Turing
17:34:34 <ushdf> i have a Zombie Alan Turing
17:34:45 <Peaker> int-e: I try not to use Arrow functions, though ;)
17:35:23 <ushdf> i used lambda functions all the time in php and C
17:35:27 <ushdf> i called them variables ;)
17:36:13 <ivanm> gwern: yeah, I thought change-monger would use darcs changes and output the whole history
17:36:14 <lambdabot> ivanm: You have 1 new message. '/msg lambdabot @messages' to read it.
17:37:12 <gwern> ivanm: why would it output the whole history? the use case is just for changes since the last tag
17:37:36 <gwern> where tag == version
17:37:40 <ivanm> ahhhhhh
17:37:44 <gwern> sadly, not everyone is careful to tag
17:37:45 * ivanm gets it now
17:37:49 <int-e> @type foldl (\m (k, a) -> M.alter (Just . maybe [a] (a:)) k m) M.empty
17:37:50 <lambdabot> forall t t1. (Ord t) => [(t, t1)] -> M.Map t [t1]
17:37:57 <gwern> but I'm sure if there were some reason to, people would do it more foten
17:38:09 <ivanm> gwern: though how would one get the initial Changelog? after all, how many people tag the creation of a new repo?
17:38:55 <gwern> ivanm: er. I dunno. I only thought about the case where you have an existing project which has a tag or two already
17:39:17 <ivanm> *nod*
17:39:37 <ivanm> but basically it's doing darcs changes --since foo >> Changelog ?
17:39:42 <ivanm> (for darcs repos that is)
17:39:59 <Peaker> hmm, there's no (map toLower) function?
17:40:21 <gwern> ivanm: for darcs repos, yup
17:40:27 <gwern> the git command was a little more difficult iirc
17:40:38 <SamB_XP> Peaker: sure there is ... you just gave the expression for it, after all!
17:40:53 <Peaker> SamB_XP: I mean, it doesn't have a name, that surprises me
17:40:55 <dolio> Why would you need a name for map toLower?
17:41:15 <int-e> mapToLower ;)
17:41:36 <int-e> @src concatMap
17:41:37 <lambdabot> concatMap f = foldr ((++) . f) []
17:41:53 <gwern> @pl concatMap f = foldr ((++) . f) []
17:41:53 <lambdabot> concatMap = flip foldr [] . ((++) .)
17:41:56 <int-e> @type concat . map
17:41:57 <lambdabot>     Couldn't match expected type `[[a]]'
17:41:57 <lambdabot>            against inferred type `[a1] -> [b]'
17:41:57 <lambdabot>     Probable cause: `map' is applied to too few arguments
17:42:02 * gwern ponders which one looks worse
17:42:11 <int-e> @type (concat .) . map
17:42:13 <lambdabot> forall a a1. (a1 -> [a]) -> [a1] -> [a]
17:42:45 <int-e> gwern: both :)
17:43:17 <gwern> agreed
17:43:29 <dolio> @pl (join .) . fmap
17:43:29 <lambdabot> (=<<)
17:44:25 <dolio> @pl (concat .) . map
17:44:25 <int-e> @src [] (>>=)
17:44:26 <lambdabot> (=<<)
17:44:26 <lambdabot> xs >>= f     = concatMap f xs
17:44:55 <Peaker> Its a bit weird that fmap and >>= take their args flipped
17:45:00 <Peaker> @type flip fmap
17:45:01 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
17:45:04 <Peaker> @type (>>=)
17:45:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:45:25 <Peaker> Its easier to explain the difference between them when the parallels are shown
17:45:28 <int-e> >>= is the odd one here, for purely practical reasons.
17:45:43 <Peaker> then maybe fmap is..
17:45:55 <int-e> foo >>= \a -> blah >>= \b -> ... wouldn't work as well with =<<
17:46:14 <Philonous> @src concatMap
17:46:14 <lambdabot> concatMap f = foldr ((++) . f) []
17:46:20 <int-e> fmap has a natural type - (a -> b) -> (f a -> f b)
17:47:05 <dolio> @type ap
17:47:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
17:47:13 <Peaker> maybe <$> should have been (flip fmap) instead of fmap
17:47:34 <Peaker> also, I think <*> is really a lifted $, so it should have gotten <$>, not fmap
17:47:37 <int-e> <$> is used differently from >>= though
17:47:53 <mmorrow> Taral: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=319#a321
17:48:00 <int-e> > (+) <$> [1,2] <*> [4,10]
17:48:01 <lambdabot>   [5,11,6,12]
17:48:50 <int-e> > [1,2] >>= \a -> [4,10] >>= \b -> a+b : []
17:48:51 <lambdabot>   [5,11,6,12]
17:49:09 <Peaker> > let (<$$>) = flip (<$>) in [1,2] <$$> (+) <*> [4,10]
17:49:10 <lambdabot>   [5,11,6,12]
17:49:59 <dolio> @type (<$$>)
17:50:00 <lambdabot> Not in scope: `<$$>'
17:50:14 <dolio> @type (<**>)
17:50:15 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
17:50:42 <sm> how do I convert NominalDiffTime to Float ?
17:50:50 <mmorrow> Taral: it gets pretty painful as well to make a maybe/either/list/etc fold for larger datatypes, but with the pain lessened by generating the code i'm starting to find actual uses for folds of arbitrary types
17:52:06 <int-e> @type realToFrac
17:52:07 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
17:52:25 <int-e> sm: realToFrac should do the trick
17:52:30 <sm> thank you, it does
17:52:53 <mmorrow> eg, you can write
17:52:56 <mmorrow> idFoldExp {foldLamE = \(LamE x (LamE y e)) -> LamE [x,y] e}
17:53:01 <mmorrow> instead of
17:53:26 <mmorrow> asdf (LamE x (LamE y e)) = LamE [x,y] e
17:53:28 <mmorrow> asdf e = e
17:54:42 <mmorrow> idFoldList {foldCons = \x xs -> .... }
17:54:44 <Saizan> mmorrow: you've one LamE too many somewhere?
17:55:02 <mmorrow> , src 'LamE
17:55:20 <mmorrow> wake up lunabot
17:55:21 <lunabot>  data Exp = ... | LamE ([Pat]) Exp | ...
17:55:21 <lunabot>  infixl 9
17:55:23 <Saizan> also, won't the first crash if there's a LamE not containing another one?
17:55:47 <mmorrow> Saizan: using these defs http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=319#a322
17:55:52 <int-e> mmorrow: x ++ y instead of [x,y]?
17:55:55 <mmorrow> the above are equiv
17:56:04 <mmorrow> int-e: oops, you're right
17:56:05 <mmorrow> :)
17:56:22 <mmorrow> typesystem++
17:56:56 <mmorrow> Saizan: oh crap, yes you're right
17:56:59 <mmorrow> hmm
17:57:36 <mmorrow> ok, i've gotta somehow incorporate a way to default to id or something somehow..
17:57:45 <quuxman> cabal seems to be pretty broken
17:58:03 <Peaker> @karma typesystem
17:58:03 <lambdabot> typesystem has a karma of 1
17:58:05 <Saizan> maybe you want some other -morphism instead of cata :)
17:58:11 <Ikkebr> @quote OlegFacts
17:58:12 <lambdabot> OlegFacts says: GHC doesn't have a type checker. It emails your types to Oleg for checking.
17:58:14 <Saizan> quuxman: why?
17:58:16 <Ikkebr> @quote OlegFacts
17:58:16 <lambdabot> OlegFacts says: GHC doesn't have a type checker. It emails your types to Oleg for checking.
17:58:22 <quuxman> "cabal: yi.cabal: This package requires Cabal version: >=1.6" and I have Cabal-1.6.0.1 installed
17:58:23 <mmorrow> Saizan: good point
17:58:45 <Saizan> quuxman: what does cabal --version says?
17:59:36 <quuxman> "cabal-install version 0.5.1" and "using version 1.4.0.1 of the Cabal library". Guess that would explain it
18:00:03 <quuxman> I tried uninstalling Cabal-1.4.0.1 but it just reinstalled it
18:00:11 <mmorrow> Saizan: ok, i'm going to look into other ways, but off the cuff i think this'd work:
18:00:31 <Saizan> quuxman: you can use "cabal install cabal-install" to update cabal-install
18:00:39 <quuxman> Saizan: already tried that
18:00:40 <Saizan> quuxman: you may need cabal update first
18:01:24 <quuxman> why doesn't cabal just install new versions of packages when dependencies require them?
18:01:25 <mmorrow> foldLamE :: ([] Pat -> Exp -> r_0) =====>  foldLamE :: ((r -> r -
18:01:26 <mmorrow> goo
18:01:39 <mmorrow> i'd need to be able to pass a pattern to do what i'm thinking
18:02:11 <Saizan> quuxman: it does for libraries, but not for tools
18:02:12 <quuxman> oh damn, I have two versions of cabal installed. That's the problem. I'm using /usr/local/bin/cabal
18:02:21 <mmorrow> (i'm trying to not use any pattern matches myself)
18:03:16 <Saizan> mmorrow: you may need a quoter that adds a default pattern
18:03:26 <mmorrow> haha, i was just thinking that :)
18:03:45 <mmorrow> i'm glad i'm not the only one
18:04:32 <Saizan> heh, if patterns were first class..
18:04:42 <mmorrow> totally
18:05:30 <quuxman> still have the alex problem (sorry alexsuraci)
18:06:20 <dolio> View patterns are first class.
18:07:53 <mmorrow> i'd need to be able to pass a pattern to a function to be able to do what i was trying
18:09:12 <Saizan> quuxman: do you have ~/.cabal/bin in your path?
18:09:24 <mmorrow> (of course my "problem" could be easily solved if i wasn't explicitly not allowing myself to use a case .. of ..)
18:09:53 <quuxman> Saizan: yeah definitely. alex runs... and alex --version reports the correct version
18:10:27 <mmorrow> idFoldExp {foldLamE = \e -> case e of LamE x (LamE y e) -> LamE [x,y] e ; _ -> e}
18:11:06 <quuxman> I think this is the third time I've tried to build Yi. One of these times I'll get it working :-P
18:11:06 <mmorrow> but then that particular use of idFoldExp really is superfluous then
18:11:27 <mmorrow> oh, i'm an idiot
18:11:45 <Saizan> quuxman: how are you building it? cabal install yi or runhaskell Setup configure ... ?
18:11:56 <Saizan> quuxman: in the latter case you may need to rerun configure
18:11:57 <mmorrow> none of this is necessary since my expression wasn't even of the correct type
18:12:33 <mmorrow> grr, but the case .. of .. is still unavoidable:
18:12:54 <mmorrow> ooh, it /is/ avoidable:
18:13:04 <quuxman> Saizan: cabal install Yi wasn't working, so I downloaded the darcs version and I finally got "cabal configure" to work (though with a warning) but "cabal build" fails with "cabal: The program alex is required but it could not be found"
18:13:59 <mmorrow> err, it's avoidable if i had a way to default..
18:14:06 <quuxman> Saizan: I got it to configure by simply commenting out the alex dependency from yi.cabal
18:15:14 <quuxman> damnit alex, why can't you get along with cabal? :-P
18:15:42 <Saizan> quuxman: well here cabal can find alex with no problems, we should try to figure out why it can't on your system
18:16:28 <mmorrow> i'm back to square one :P
18:16:53 <Saizan> quuxman: cabal configure -v says "No alex found." ?
18:19:00 <mmorrow> idFoldExp {foldLamE = \x e -> case e of LamE y e -> LamE (x++y) e}
18:19:15 <quuxman> hmm, well if I uncomment out "build-tools:   alex >= 2.0.1 && < 3" it says "cabal: alex version >=2.0.1 && <3 is required but it could not be found.". Running "alex --version" reports 2.3, but alex is not shown in "ghc-pkg list"
18:19:15 <mmorrow> that's decent though
18:19:50 <mmorrow> idFoldExp {foldLamE = \x e -> case e of LamE y e -> LamE (x++y) e ; _ -> LamE x e} -- ;)
18:20:06 <Saizan> quuxman: alex is not a library so it won't be in ghc-pkg list
18:22:01 <quuxman> Saizan: cabal doesn't seem to know alex exsists, because if I run "cabal install alex" it downloads, compiles, and reinstalls it
18:22:22 <quuxman> well, I don't know about downloading, but it definitely recompiles and reinstalls it
18:22:43 <Saizan> heh right, it doesn't keep track of programs
18:23:01 <quuxman> so how can it be complaining that it can't find it??
18:23:10 <Saizan> but it does find them if they're in the path
18:23:27 <Saizan> but.. can you try "cabal clean" and then "cabal configure -v" ?
18:24:21 <quuxman> Saizan: yeah... it doesn't change anything. same error. Before that htere's a warning about regex-tdfa and yi requiring different versions of parsec
18:25:23 <Saizan> cabal configure --with-alex=/path/to/alex ?
18:26:18 <grul> I'm writing a test function and I want it to return True if the test is successful or the indata if the test fails. How do I use different return types like this?
18:27:05 <dibblego> indata?
18:27:26 <grul> well I send two Integer to the function
18:27:43 <Saizan> grul: you could use Maybe (Integer,Integer), where Nothing means success
18:27:58 <Saizan> or you could define a specific union type yourself
18:28:09 <grul> oh, Maybe
18:28:09 <quuxman> Saizan: huh, that did the trick
18:28:26 <grul> this language amazes me
18:28:37 <Saizan> data Result a = Success | Input a
18:29:12 <grul> oh, that's probably clearer
18:29:23 <grul> thanks, I'll give it a try
18:31:25 <quuxman> Saizan: w00t. thanks to you I'm running yi!
18:32:16 <Saizan> yay :D
18:32:40 * Saizan installs it too, at this point
18:32:53 <quuxman> lol, it crashed when I pressed <space.
18:33:22 <sm> whyy is it so hard to find a pastebot that doesn't suck, stays up, and notifies ?
18:33:46 <Saizan> sm: you mean for this channel or in general?
18:33:53 <sm> generally
18:34:07 <sm> hpaste is up but corrupted my unicode chars and didn't notify here
18:35:08 <sm> paste.lisp.org.. well apparently I can never remember its url. Let's try again
18:37:07 <sm> I'm doing runInteractiveCommand and waitForProcess, and I think http://paste.lisp.org/display/69482 is hanging if the command is slow ?
18:38:07 <Saizan> sm: you should consume the output _before_ using waitForProcess
18:38:42 <Saizan> sm: otherwise it will hang when the program fills the buffer
18:38:47 <sm> Saizan: thanks, why is that ?
18:39:11 <sm> to a dumb api user, my usage seems intuitively right
18:41:00 <Saizan> when the buffer of a pipe (like out here ) is full and you try to write to it you block
18:41:53 <Saizan> until the buffer is emptied by the other program reading from the pipe, but you are waiting for the cmd to end, so there's a cyclic wait causing a deadlock
18:42:18 <sm> I see.. so I need to understand that the pipes are not just infinite streams that will hold data until I want it, but blocking buffered pipes I need to consume so the command can run
18:42:31 <Saizan> right
18:42:55 <sm> and is _ <- hGetContents out sufficient ? I think so
18:43:02 <Saizan> you should fork a thread that consumes err in parallel btw
18:43:15 <sm> ack
18:43:45 <Saizan> no, you want something like do str <- hGetContents out; evaluate (length str)
18:43:57 <Saizan> since hGetContents uses lazy IO
18:44:04 <sm> ok
18:44:45 <sm> that's very helpful, thanks. I was hoping to find a one-liner to read the output of a command.
18:44:49 <Saizan> in the new process package (shipped with 6.10) there's readProcess which already does this for you
18:45:06 <sm> in this case I'm just timing so I guess I can use System.Cmd
18:45:14 <sm> ah, great
18:50:05 <quuxman> so is there a guide for hacking yi somewhere? And is it to the point where I can open a buffer and write editor functions like in emacs?
18:50:36 <quuxman> wah, :help is not implemented
18:53:19 <Saizan> ?hackage regex-tdfa
18:53:19 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regex-tdfa
18:56:52 <teratorn> could someone tell me what I'm doing wrong?
18:56:53 <teratorn> import System
18:56:53 <teratorn> main = putStrLn (show (sum ((map read System.getArgs) :: [Int])))
18:57:16 <teratorn> trying to print a sum of the arguments interpreted as integers
18:57:21 <ivanm> whats the error?
18:57:30 <teratorn>     Couldn't match expected type `[String]'
18:57:30 <ivanm> @src print
18:57:30 <teratorn>            against inferred type `IO [String]'
18:57:30 <lambdabot> print x = putStrLn (show x)
18:57:42 <ivanm> teratorn: ahhh.... you want this
18:58:46 <ivanm> main = do args <- getArgs ; let intArgs = map read args :: [Int] ; print $ sum intArgs
18:58:57 <ivanm> note that I'm using ";" to mean start a new line
19:00:29 <Saizan> you can inline the definition of intArgs
19:00:47 <ivanm> yeah, I just felt it might be clearer if I separated it
19:01:05 <PHO_> main = putStrLn . show . sum . map read =<< System.getArgs
19:01:08 <PHO_> like this?
19:01:52 <ivanm> PHO_: I think you'll find that it mightn't know what type of Num values to use
19:02:03 <ivanm> @type sum $ map read =<<
19:02:04 <lambdabot> parse error (possibly incorrect indentation)
19:02:05 <PHO_> ivanm: ah, indeed
19:02:10 <ivanm> besides, you need a '$' somewhere
19:02:18 <ivanm> @type sum $ map read =<< System.getArgs
19:02:19 <lambdabot>     Couldn't match expected type `[[String]]'
19:02:19 <lambdabot>            against inferred type `IO [String]'
19:02:19 <lambdabot>     In the second argument of `(=<<)', namely
19:02:40 <ivanm> @type sum $ (map read) =<< System.getArgs
19:02:42 <lambdabot>     Couldn't match expected type `[[String]]'
19:02:42 <lambdabot>            against inferred type `IO [String]'
19:02:42 <lambdabot>     In the second argument of `(=<<)', namely
19:02:47 <ivanm> *shrug*
19:03:03 <PHO_> main = putStrLn . show . sum . (map read :: [String] -> [Int]) =<< System.getArgs
19:03:13 <ivanm> still won't work....
19:03:22 <ivanm> need to liftM (show . sum) or something as well
19:03:35 <ivanm> @type (map read :: [String] -> [Int]) =<< System.getArgs
19:03:36 <lambdabot>     Couldn't match expected type `[[String]]'
19:03:36 <lambdabot>            against inferred type `IO [String]'
19:03:36 <lambdabot>     In the second argument of `(=<<)', namely
19:04:22 <ddarius> ivanm: PHO_'s code is fine, except print would be better than putStrLn . show
19:04:33 <ivanm> ddarius: oh? so why can't lambdabot type match it?
19:04:45 <ddarius> ivanm: Because you aren't writing his code.
19:04:49 <teratorn> what does the type `IO [String]` even mean?
19:05:00 <ivanm> @type sum . (map read :: [String] -> [Int]) =<< System.getArgs
19:05:02 <lambdabot>     Couldn't match expected type `m b' against inferred type `Int'
19:05:02 <lambdabot>       Expected type: [String] -> m b
19:05:02 <lambdabot>       Inferred type: [String] -> Int
19:05:02 <ddarius> :t putStrLn . show . sum . (map read :: [String] -> [Int]) =<< System.getArgs
19:05:03 <lambdabot> IO ()
19:05:10 <ddarius> ivanm: That's not his code.
19:05:19 <ivanm> hmmmm.... so why won't a partial fragment type-check?
19:05:26 <ivanm> teratorn: it's a list of strings in the IO monad
19:05:28 <ddarius> ivanm: Because it's not a subexpression.
19:05:35 <ivanm> hmmmm?
19:05:42 <ddarius> It's (print . show . sum . map read) =<< System.getArgs
19:05:46 <PHO_> http://hpaste.org/11625 it worked.
19:05:46 <ivanm> ahhhh
19:05:48 <ivanm> duh
19:05:59 * ivanm thought it just went to map read
19:06:29 <ivanm> ddarius: that's not right.... "print . show" ?
19:06:30 <ivanm> ;-)
19:07:40 <teratorn> what is the =<< function?
19:08:06 <qwr_> teratorn: flip (>>=)
19:08:07 <ivanm> @src (=<<)
19:08:07 <lambdabot> f =<< x = x >>= f
19:08:10 <ivanm> @src Monad
19:08:11 <lambdabot> class  Monad m  where
19:08:11 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
19:08:11 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
19:08:11 <lambdabot>     return      :: a -> m a
19:08:11 <lambdabot>     fail        :: String -> m a
19:08:17 <ivanm> teratorn: ^^
19:10:02 <teratorn> great now I have 37 more questions (:
19:10:16 <PHO_> haha
19:10:25 <ivanm> don't worry, the number of questions you'll have will only grow quadratically, not exponentially ;-)
19:14:51 * PHO_ currently has e^(iÏ€) questions.
19:14:59 <twb>  re parsing command-line arguments, what are my options?
19:15:50 <ddarius> PHO_: And which question is that?
19:15:55 <sbahra> twb, one bad example of an option taken: http://kerneled.org/dump/Porte/Porte/Tool.hs
19:16:05 <ddarius> Or I guess answer.
19:16:11 <PHO_> ddarius: go ahead
19:16:15 <sbahra> twb, dons blog has some examples, too.
19:16:25 <ivanm> twb: getArgs, or else there's a simpleArgs package on hackage IIRC
19:16:29 <sbahra> twb, look at toolMain (getArgs)
19:18:48 <twb> @hoogle getArgs
19:18:48 <lambdabot> System.Environment getArgs :: IO [String]
19:19:56 <sbahra> :t System.Environment.getArgs
19:19:57 <lambdabot> IO [String]
19:21:02 <dblazakis> @pl \x -> fmap return x
19:21:02 <lambdabot> fmap return
19:21:12 <PHO_> twb: try this: http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html
19:21:14 <lambdabot> Title: System.Console.GetOpt, http://tinyurl.com/y3585u
19:21:38 <sbahra> haha dblazakis
19:22:03 <sbahra> PHO_, nice
19:23:27 <dblazakis> sbahra: hehe
19:23:31 <dblazakis> :t fmap return
19:23:32 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Functor f, Monad m) => f a -> f (m a)
19:37:50 <twb> I'm using HSH to run shell commands; how can I direct them to files?
19:38:07 <twb> Specifically I want to run "curl $URL >$file" then "mutt -f $file".
19:40:07 <twb> http://hpaste.org/11626
19:50:10 <sm> why does http://community.haskell.org/admin/account_request.html keep saying there's a newline in my key ? and does it accept an id_rsa.pub ?
19:50:11 <lambdabot> Title: Account Request
19:50:14 <quuxman> how do I recompile the config in Yi?
19:50:50 <quuxman> a website I found says "M-x reconfigE" but that's no longer a command it appears
19:52:11 <thoughtpolice> afaik you have to have ghcAPI support enabled to reload in-situ
19:52:15 <thoughtpolice> and that is kind of fragile stuff
19:52:20 <twb> sm: it accepted my id_rsa.pub
19:52:35 <sm> thx
19:52:37 <thoughtpolice> so you might just have to restart and run yi or 'ghc --make ~/.yi/yi.hs' or something
19:55:32 <abbe> twb: curl $URL |mutt -f /dev/stdin
19:56:00 <twb> abbe: that doesn't work, because mutt relies on stdin for user input
19:57:28 <twb> Actually, probably a good way for me to learn how to write shell scripts in Haskell would be to start by writing a shell in Haskell.
19:57:49 <abbe> twb: :)
19:57:56 <abbe> ,hsh
19:58:01 <twb> I'm using hsh.
19:58:02 <lunabot>  luna: Not in scope: `hsh'
19:58:18 <Nafai> twb: That could be fun, actually!
19:58:20 <twb> It offers fork, exec and piping, but not redirection.
19:58:31 <twb> Nafai: it's a basic first-year undergrad exercise.
19:58:35 <abbe> like Emacs
20:00:19 <Raynes> <3 emacs
20:00:41 <twb> â™¥ Emacs?
20:00:51 <sm> I can't use that haskell.org accounr request form. Who could I talk to about it ?
20:01:02 <twb> sm: what browser are you using?
20:01:06 <sm> safari
20:01:14 <sm> I'll try another, I guess
20:01:15 <twb> Bleh.
20:01:21 <twb> It worked in Midori
20:01:23 <Nafai> twb: That doesn't diminish the fun-factor
20:01:38 <twb> Nafai: I didn't mean to imply that
20:02:26 <twb> @hoogle interact
20:02:27 <lambdabot> Prelude interact :: (String -> String) -> IO ()
20:02:27 <lambdabot> Data.ByteString interact :: (ByteString -> ByteString) -> IO ()
20:02:27 <lambdabot> System.IO interact :: (String -> String) -> IO ()
20:02:29 <sm> nope, same problem with firefox
20:02:55 <sm> ok, there was a trailing nl that time. And yes, it worked with ff
20:10:29 <t_> logger time
20:21:50 <mmorrow> convert stdin to an arg
20:21:59 <mmorrow> $ foo "`cat`"
20:22:22 <mmorrow> (in the slight chance that's what was even being discussed)
20:22:28 <mmorrow> :)
20:22:47 <mmorrow> or if there're '\n's
20:23:02 <mmorrow> $ foo "`cat | tr '\n' ' '`"
20:23:51 <mmorrow> , (\(_,_,_,_,_,x,_,_)->x) $(tupE (fmap lift [1..8]))
20:23:56 <lunabot>  luna: Ambiguous type variable `a' in the constraints:
20:24:01 <mmorrow> , (\(_,_,_,_,_,x,_,_)->x) $(tupE (fmap lift [1..8::Int]))
20:24:08 <twb> Nafai: here's one http://www.csse.monash.edu.au/courseware/cse2302/2003/
20:24:10 <lunabot>  6
20:24:12 <lambdabot> Title: CSE2302 Operating Systems
20:24:17 * Nafai looks
20:25:50 <Nafai> twb: Cool, thanks.  That sounds like a fun exercise I might try in order to learn Haskell better
20:30:05 <mmorrow> this'll let you feed ghc from stdin:
20:30:08 <mmorrow> $ ghc -DASDF="stdin.hs" -cpp `cat > stdin.hs;echo stdin.hs`
20:30:18 <mmorrow> oops
20:30:37 <mmorrow> $ ghc `cat > stdin.hs;echo stdin.hs`
20:30:38 <mmorrow> or
20:30:55 <mmorrow> $ ghc -DASDF="`cat`" -cpp `echo ASDF > stdin.hs;echo stdin.hs`
20:32:08 <mmorrow> http://hpaste.org/11628
20:32:51 <mlh_zombie> that was the basis of an Obfuscated C entry way back
20:33:01 <mmorrow> oh sweet
20:33:04 <mmorrow> link?
20:33:16 <mmorrow> (or approximate year)
20:35:23 <mmorrow> lol
20:35:27 <mmorrow> from 2004:
20:35:29 <mmorrow> vik2 - Calculates prime numbers using only CPP
20:35:37 <mmorrow> http://www.ioccc.org/2004/vik2.c
20:35:58 <ddarius> @google "Lennart Augustsson" IOCCC
20:35:59 <lambdabot> No Result Found.
20:36:32 <ddarius> Stupid lambdabot
20:36:44 <mmorrow> heh
20:36:57 <mmorrow> http://www.ioccc.org/2001/anonymous.c -- dynamic x86 binary translator
20:37:11 <mmorrow> ddarius: are you thinking of the interpreter?
20:37:16 <mmorrow> that one's sweet
20:37:40 <ddarius> Lennart has won the IOCCC a few times
20:38:05 <shapr> Lennart is ... unusual.
20:38:28 <Nafai> Hehy shapr!
20:38:32 <Nafai> Hey, even
20:39:17 <shapr> hiya!
20:40:02 <mmorrow> http://www.ioccc.org/1996/august.c
20:40:17 <mmorrow> http://www.ioccc.org/years.html#1985_august
20:40:18 <lambdabot> Title: Previous IOCCC Winners
20:40:25 <mmorrow> http://www.ioccc.org/years.html#1986_august
20:40:27 <lambdabot> Title: Previous IOCCC Winners
20:41:07 <shapr> We should do IOHCC again.
20:41:18 <shapr> I should see if I can find the results of previous contests on my old hard drives.
20:41:23 <alc> i've installed a lambdabot.  how can i disable a feature (in a rc file maybe)? like this auto-read-title one?
20:42:18 <ddarius> There's a command that will turn that off.
20:49:18 <alc> hmm, which is?
20:49:24 <alc> http://code.haskell.org/lambdabot/COMMANDS
20:55:19 <sjanssen> alc: you might have to edit the source
20:55:21 <ddarius> @help url-off
20:55:21 <lambdabot> Plugin `help' failed with: Plugin/Url.hs:13:4-75: Non-exhaustive patterns in function moduleHelp
20:55:26 <ddarius> @help url
20:55:26 <lambdabot> url <key>. Return element associated with key
20:55:31 <ddarius> @help url-title
20:55:31 <lambdabot> url-title <url>. Fetch the page title.
20:55:48 <sjanssen> oh, url-off
20:55:59 <sjanssen> http://haskell.org
20:56:00 <lambdabot> Title: Haskell - HaskellWiki
20:56:02 <sjanssen> @url-off
20:56:02 <lambdabot> Url disabled
20:56:05 <sjanssen> http://haskell.org
20:56:08 <sjanssen> @url-on
20:56:09 <lambdabot> Url enabled
20:56:14 <twb> Why is "main = forkProcess" wrong?
20:56:21 <dibblego> @users
20:56:22 <lambdabot> Maximum users seen in #haskell: 551, currently: 474 (86.0%), active: 19 (4.0%)
20:56:27 * lispy is reminded of wayne's world "Game on!"
20:56:39 <sjanssen> lispy: heh
20:56:45 <lispy> ?hoogle forkProcess
20:56:46 <lambdabot> No results found
20:56:54 <sjanssen> twb: forkProcess is "IO () -> IO Pid", right?
20:56:54 <alc> great
20:56:56 <twb> It's in System.Posix.Process
20:56:56 <alc> thanks
20:56:59 <sjanssen> main must have type IO a
20:57:00 <twb> sjanssen: yeah
20:57:01 <dolio> Both you and I know: there is no film in this camera!
20:57:09 <alc> xxx-on, xxx-off
20:57:16 <lispy> you mean, IO (), right?
20:57:23 <twb> sjanssen: does it mean that forkProcess takes a monadic function?
20:57:31 <sjanssen> twb: yep
20:57:35 <twb> Ah
20:57:36 <shapr> @cheat-on
20:57:37 <lambdabot> Unknown command, try @list
20:57:39 <shapr> aww
20:57:44 <shapr> Where's cheats mode in lambdabot?
20:57:47 <lispy> ?shapr-on
20:57:47 <lambdabot> Unknown command, try @list
20:57:51 <twb> shapr: that was a little more clever than I was expecting
20:57:59 <twb> Oops, bad completion
20:58:09 <shapr> twb: I was about to say... wasn't that funny, really.
20:58:15 <lispy> main = forkProcess main
20:58:24 <twb> lispy: isn't that a forkbomb?
20:58:25 <ddarius> shapr: The cheat code isn't going to be that obvious.
20:58:26 <sjanssen> lispy: forkbomb!
20:58:35 <lispy> twb: still wouldn't type check I think
20:58:45 <shapr> ddarius: They must have added it since I hacked anything into lambdabot.
20:58:49 <ddarius> Why wouldn't it typecheck?
20:58:49 <roconnor> > fix forkProcess
20:58:50 <lambdabot>   Not in scope: `forkProcess'
20:58:51 <lispy> :t fixM
20:58:53 <lambdabot> Not in scope: `fixM'
20:58:55 <shapr> I had a coupla decent lambdabot plugin ideas, but I forgot 'em :-(
20:59:04 <ddarius> Ah, nevermind.
20:59:12 <ddarius> It almost type checks.
20:59:15 <shapr> OH I remember... should be transparent across xmpp.
20:59:33 <shapr> So that I could use lambdabot from work via gtalk.
21:00:16 <lispy> shapr: oh or an irc/xmpp gateway :)
21:00:33 <lispy> ?hoogle fixM
21:00:34 <lambdabot> No results found
21:00:46 <lispy> am I on crack, I thought there was a fix for monads
21:00:57 <twb> lispy: ooooooh
21:01:00 <mlh_zombie> mmorrow: I was thinking of this one: 1988 spinellis	#include "/dev/tty"
21:01:09 <twb> lispy: now I get it: forkProcess takes the child function
21:01:15 <mlh_zombie> mmorrow: I was thinking of this one: 1988 spinellis #include "/dev/tty"
21:01:16 <lispy> twb: right-o
21:01:22 <twb> lispy: I thought it took a dispatch function on the PID
21:01:24 <mlh_zombie> mmorrow: I was thinking of this one: 1988 spinellis
21:01:26 <roconnor> lispy: there is.
21:01:29 <mlh_zombie> oops
21:01:35 <mmorrow> mlh_zombie: awesome. /me takes note
21:01:42 <ddarius> :t mfix
21:01:43 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
21:01:45 <roconnor> @hoogle mfix
21:01:45 <lambdabot> Control.Monad.Fix mfix :: MonadFix m => (a -> m a) -> m a
21:01:49 <lispy> twb: clever isn't it?  You basically pass the main function that you want to execute
21:02:03 <twb> lispy: I've had a lot of fun with fork FFIs
21:02:13 <twb> lispy: it was basically working out how much abstraction forkProcess provided
21:02:52 <twb> What's wrong with my syntax here?
21:02:53 <twb> main = print =<< forkProcess $ \ -> print "I'm th' child!"
21:03:15 <twb> I guess I just drop \ ->
21:03:31 <dmwit> :t forkProcess
21:03:32 <lambdabot> Not in scope: `forkProcess'
21:03:33 <sjanssen> twb: parses as (print =<< forkProcess) $ print "child"
21:03:40 <twb> Oopsie
21:03:48 <twb> main = print =<< (forkProcess $ print "I'm th' child!") -- works
21:03:59 <twb> Looks ugly, tho
21:04:00 <sjanssen> twb: also, you're going to accumulate zombie processes doing that
21:04:34 <twb> sjanssen: I can worry about that later.
21:04:42 <roconnor> sjanssen: huh?
21:05:02 <lispy> main = forkProcess main >> main
21:05:07 <lispy> that will get you resource exhausted really fast
21:05:09 <sjanssen> roconnor: the parent must wait for the child to return
21:05:14 <sjanssen> Unix 101
21:05:18 <twb> WTF
21:05:28 <twb> Why does comment-dwim do ";;;" at the start of a line?
21:05:36 <twb> Oh... it's paredit
21:05:41 <roconnor> sjanssen: huh?
21:05:54 <sjanssen> roconnor: do you know fork(), from posix?
21:06:06 <roconnor> I know the principle
21:06:54 <sjanssen> forkProcess is fork(), it creates a new process and gives the PID of the child to the parent process
21:07:28 <sjanssen> parents must collect their children's exit codes, or they will leave a "zombied" process
21:08:00 <roconnor> why do they need to do that?
21:08:08 <sjanssen> that is how Unix works
21:08:19 <lispy> roconnor: it's possible that the parent needs to get values from the child after it exits
21:08:33 <lispy> roconnor: so unix keeps the dead process around for a bit to see if the parent wants anything from it
21:08:52 <roconnor> when the parent dies, doesn't the childeren die?
21:09:06 <sjanssen> roconnor: no
21:09:14 <roconnor> or rater when the parent dies and the children die, aren't everyone dead?
21:09:50 <lispy> roconnor: um, i think the child does die with the parent
21:10:21 <sjanssen> lispy: no, it doesn't
21:10:55 <roconnor> main = print =<< (forkProcess $ print "I'm th' child!") -- what's the problem? two processes, they both end quickly.
21:11:14 <lispy> maybe i'm confuisng it with the case where you're trying to read from the parent's pipe and the parent dies
21:11:19 <sjanssen> roconnor: the child process remains as a zombie process entry
21:11:24 <sjanssen> roconnor: seriously, try it.
21:11:34 <sjanssen> this is how Unix works
21:11:46 <sjanssen> http://en.wikipedia.org/wiki/Zombie_process
21:11:47 <roconnor> that ... makes no sense
21:11:47 <lambdabot> Title: Zombie process - Wikipedia, the free encyclopedia
21:11:51 <bd_> Is that even safe in the threaded RTS?
21:12:25 <bd_> I mean, from what I understand the child doesn't get a running io manager thread
21:12:26 <sjanssen> roconnor: the OS has no way of knowing whether a parent of the parent will want to collect the exit code
21:12:30 <bd_> so the instant you block, you deadlock
21:13:11 <roconnor> oh wow ``When a process loses its parent, init becomes its new parent. Init periodically executes the wait system call to reap any zombies with init as parent.
21:13:15 <sjanssen> roconnor: the OS can't just arbitrarily forget those exit codes, they might be important
21:13:30 <roconnor> sjanssen: when the parent is dead, I'm pretty sure it won't want the exit code.
21:13:42 <lispy> roconnor: right
21:13:47 <sjanssen> roconnor: it might have passed the pid (which is just an int) to another process
21:13:59 <bd_> sjanssen: however only the parent is allowed to wait() for the process
21:14:04 <roconnor> sjanssen: that's true.
21:14:23 <roconnor> bd_: good point
21:14:32 <sjanssen> bd_: really?
21:14:32 <bd_> you could ptrace() it to become the parent though
21:14:58 <bd_> sjanssen: sure, otherwise you could        ECHILD (for waitpid() or waitid()) The process specified by pid  (waitâ€
21:15:02 <bd_>               pid())  or  idtype  and id (waitid()) does not exist or is not a
21:15:04 <bd_>               child of the calling process.
21:15:07 <bd_> err
21:15:14 <bd_> right, paste got mixed in there, but yeah, it's an error to specify a child you don't own
21:15:21 <bd_> otherwise you could confuse the real parent
21:15:31 <bd_> not to mention race with the real parent
21:27:44 <roconnor> ugh, ran out of disk space, so my computer decided to turn itself off. ... at least I think that was the cause.
21:28:27 <lispy> that makes sense it's like, "Oh my brain is full.  May I be excused?"
21:28:35 <boyscared> can anyone who's read a few books on the subject recommend a best introductory title for category theory?
21:29:22 <lispy> Idon't think Learn you a category for great good has been released yet
21:32:01 <twb> I can get my head around this: main = do { l <- getLine; print $ words l }
21:32:01 <twb> But when I look at a line like this, I haven't got any mental model to follow data flow through the expression: main = print . words =<< getLine
21:33:29 <twb> If you were presented with the latter (and didn't know what it meant), how would you go about understanding it?
21:33:37 <alc> btw, i installed the lambdabot using cabal-install =)
21:33:57 <sjanssen> twb: do you understand (>>=)?  Do you understand how (>>=) and do are related?
21:34:12 <twb> sjanssen: sure, I wrote both the lines above.
21:34:29 <twb> sjanssen: but I want to be able to write/read the latter directly.
21:34:39 <sjanssen> ah
21:34:46 <twb> Right now I basically have to translate it into do form, like a foreign language
21:34:51 <sjanssen> you can read =<< as reverse sequenced function application
21:35:10 <sjanssen> @type (=<<)
21:35:11 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
21:35:13 <sjanssen> @type ($)
21:35:14 <lambdabot> forall a b. (a -> b) -> a -> b
21:35:21 <sjanssen> see the similarity in the types?
21:35:29 <alc> the process is smooth, except one thing: happy depends on happy itself
21:36:53 <twb> OK, lemme think about this for a bit
21:37:00 <lispy> twb: oh, have you seen the Haskell98 report?
21:37:01 <sjanssen> in an impure language you'd write "print . words $ getLine"
21:37:35 <twb> lispy: not in the last two months ;-)
21:37:44 <twb> *twelve
21:38:03 <twb> sjanssen: OK, I think I get that now.
21:38:36 <lispy> twb: on this page, scroll down to section 3.14 http://www.haskell.org/onlinereport/exps.html
21:38:38 <lambdabot> Title: The Haskell 98 Report: Expressions
21:38:58 <lispy> twb: look in the box "Translation"
21:39:25 <lispy> hmm..not a terrific way to show you the translation...i've seen better
21:39:27 <sjanssen> lispy: but "Translation" isn't good enough! :)
21:39:46 <lispy> do { p <- e; f p } == e >>= f
21:40:23 <twb> lispy: I grok that bit well
21:40:35 <sjanssen> twb wants to be a native speaker of the Monad operators, you're just showing him the foreign language dictionary :)
21:40:48 <sjanssen> being able to translate is only half the battle
21:40:48 <twb> Just so.
21:40:57 <dblazakis> @hoogle [(a, b)] -> a -> Maybe b
21:40:57 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
21:40:57 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
21:40:57 <lambdabot> Data.Array.Base (!) :: (IArray a e, Ix i) => a i e -> i -> e
21:41:13 <twb> For some reason I find >>= easier than <<=
21:41:42 <twb> Which is dumb, because without the monadicity, =<< is the normal function application flow
21:42:12 <sjanssen> twb: perhaps because (>>=) follows order of effect execution, while (=<<) reverses it?
21:42:17 <twb> sjanssen: yeah
21:42:25 <twb> Because for monads time is important
21:42:40 <sjanssen> (=<<) is certainly an acquired taste
21:42:58 <sjanssen> I generally use (=<<) when I'm thinking about the function bit rather that the effect bit
21:43:14 * twb walks through the HM unification for "getLine >>= print . words" in order to understand how the composition step fits in.
21:43:31 <sjanssen> or, the data returned by the monadic function rather than the effects executed
21:43:48 <lispy> for me >>= really fits the Functor aspect of a monad
21:43:58 <lispy> I think, Oh, I look in the book and pass the contents on
21:44:02 <roconnor> >>= follow the flow of information; =<< follows shitty mathematical notation.
21:44:02 <sjanssen> huh?
21:44:12 <twb> roconnor: haha
21:44:52 <twb> Yeah, any time I study mathematics I get annoyed by how dumb notations of some brilliant, but loony, 19th century mathematician become conventions.
21:45:24 <twb> e.g. the notation for fixed integration
21:47:07 <roconnor> perhaps =<< is also useful for the backwards state monad.
21:47:19 <roconnor> but I suspect not even then.
21:47:55 <sjanssen> roconnor: you don't like (=<<)?
21:48:28 <roconnor> I like it as much as I like math notation
21:48:33 <sjanssen> ah
21:48:39 <BMeph> twb: Actually, >>= is just a composition away from the Kleisli form. :)
21:49:07 <sjanssen> roconnor: if you don't like "f x", then I don't suppose you'd like "f =<< x" either
21:49:10 <sjanssen> fair enough
21:52:22 <twb> I like "f x" in the context of languages where arity is always exactly one.
21:53:02 <twb> And with implicit currying, of course
21:53:54 <twb> It's been too long since I did any forth
21:55:37 <twb> With getLine, how do I cope with EOF?
21:55:54 <twb> Basically I want to iterate with Maybe line -> iterate; Nothing -> stop
21:56:17 <twb> (Rather, I'm using getLine atm, I don't have to.)
21:57:25 <sjanssen> twb: getLine will thrown an exception on EOF
21:57:42 <twb> So the question becomes: how do I work with exceptions in Haskell.
21:57:49 * twb heads on over to RWH
22:11:39 <Pseudonym> .ignore -Aqrs_iLy507
22:19:26 <mmorrow> \h done cont -> if isEOF h then done else getLine >>= \l -> cont l
22:20:11 <mmorrow> (\h done cont -> if isEOF h then done else getLine >>= \l -> cont l) stdin (exitWith ExitSuccess) putStrLn
22:21:32 <adu> that is the most confusing thing I have ever seen
22:22:07 <mmorrow> (\h done cont -> if isEOF h then done else getLine >>= \l -> cont l) stdin (putStrLn "error: no input" >> exitWith (ExitFailure 1))  (\l -> = launchMissilesWithMsg l)
22:22:15 <mmorrow> s/=//
22:22:21 <adu> lol
22:22:54 <adu> launchMissilesWithMsg "please use do notation"
22:22:59 <mmorrow> heh, yeah i realized right after i hit enter that that probably hurt more than it helped ...
22:23:05 <mmorrow> :)
22:23:22 <mmorrow> launchMissilesWithMsg "CAN HAS STDIO?"
22:24:09 <adu> Ceiling Cat sayed let there be aminals, and there was aminals but he did not eated dem...
22:24:12 <mmorrow> but hopefully the second example righted that ;)
22:24:48 <mmorrow> whoever first thought of "but i eated it" is a geniush
22:25:20 <adu> I want to eat XHTML
22:25:39 <adu> and spit dynamic SVG
22:26:12 <mmorrow> sounds like a dental delicacy
22:26:39 <adu> wanna see my DSVG experiment?
22:26:48 <mmorrow> yes
22:26:50 <adu> http://tetration.itgo.com/svg/dsDragTest.svg
22:27:20 <mmorrow> wow
22:27:41 * mmorrow bookmarks 4 times and goes to bed :)
22:28:10 <mmorrow> nice button effect btw
22:28:20 <adu> thanks :)
22:28:41 <adu> i've been meaning to polish it by using more bezier curves and less polygons
22:30:24 <mmorrow> (b)splines ftw
22:30:49 <mmorrow> although i wouldn't ditch the current polygon look, i like it
22:33:08 <adu> mmorrow: if you go up one level, you'll see I also have an experiment with splines:
22:33:08 <adu> http://tetration.itgo.com/svg/dsBell.svg
22:35:23 <jdrake> adu, nice svg
22:35:40 <adu> jdrake: thanks
22:36:26 <jdrake> adu, especially the mouse click
22:36:57 <adu> jdrake: do you mean the Octagon button hover effect?
22:37:06 <jdrake> click to increase speed
22:37:19 <adu> o right, thats a bug
22:37:43 <jdrake> nah, a feature!
22:37:57 <jdrake> What do you make these with?
22:37:58 <adu> its because I added a runloop starter in the onclick and the onload (because I couldn't get the onload handler working)
22:38:06 <adu> jdrake: a text editor
22:38:20 <jdrake> adu, you edit xml by hand? You poor soul
22:38:31 <adu> jdrake: no, not be hand
22:38:46 <adu> jdrake: I use emacs' C-c / a lot
22:38:59 <jdrake> I am not sure what that is
22:39:34 <adu> <b>text(ctrl-c /) expands to <b>text</b>
22:39:47 <jdrake> ah, not bad
22:39:53 <jdrake> I could never work with emacs
22:40:01 <adu> I could never work with anything else
22:40:09 <jdrake> nano and gedit
22:40:29 <adu> both rather featureless
22:40:36 <jdrake> yep, that is how I like it
22:40:54 <jdrake> I like nano because I know virtually all the keys you can use
22:41:12 <jdrake> But due to some years on the mac, I always run it as pico
22:41:13 <adu> but you don't need to, they're all on the screen
22:41:24 <jdrake> But I do anyways :p
22:41:46 <adu> I used pico/nano myself up until about a year ago
22:41:58 <jdrake> How did you get into emacs?
22:42:06 <adu> the tutorial
22:42:27 <adu> I just spent a week of studying.
22:42:47 <adu> instead of checking email, I would go thru the emacs tutorial, and instead of surfing the web, I would read the emacs manual
22:43:07 <jdrake> That isn't a bad way I guess
22:43:33 <jdrake> I might try it again
22:43:47 <sm> what's the null operation in a monad, eg in IO ? I need to fill an unused case clause
22:44:06 <jdrake> I am for now going to need to read the parsec manual, because I hope to use it and not have to go to python to write my document processor.
22:44:10 <lament> sm: return ()
22:44:27 <sm> hmm, but won't that exit the whole do block ?
22:44:28 <adu> and in the end it has paid off, because I can now sort 10,000 lines and copy a column of text (like characters 10-15) accross dozens of lines with 3 keystrokes, and this gives me time to surf the web more
22:44:36 <sm> I have more to do
22:44:38 <lament> sm: no
22:45:09 <lament> return does not exit anything; you need to read more about how monads and the do notation work
22:45:12 <adu> jdrake: theres actually 2, Parsec.pdf and parsec.pdf, one is better than the other... I don't remember which tho
22:45:26 <adu> jdrake: some places have one as parsec-paper.pdf, I think that one is better
22:45:26 <jdrake> I have the 'parsec.pdf'
22:45:27 <sm> right you are, thanks
22:45:44 <jdrake> :t return
22:45:45 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
22:46:34 <lispy> :t \f m -> m >>= return . f
22:46:35 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b) -> m a -> m b
22:46:42 <adu> sm: do notation is a fancy land where procedures turn into sugar
22:47:06 <jdrake> To be honest I am a little wary of parsers, *never* had a good time with them
22:47:09 <lispy> programmable semicolons
22:47:27 <lispy> jdrake: I feel that way about regular expressions
22:47:45 <jdrake> lispy, with some quick ref I can write a regex
22:47:46 <adu> jdrake: aside from parsec (my favorite parser builder in the world) my next favorite parsing library is "PLY" for python
22:47:51 <Pseudonym> adu: That sounds like something out of a bad kids' musical.  It's a land of sugar and easier syntax!
22:48:11 <lispy> very recently in python I was befuddled by this re.match("a*", "b") returning true
22:48:18 <lament> No sugar tonight in my coffee; no sugar tonight in my tea
22:48:27 <lament> No sugar to stand beside me; no sugar to ride with me
22:48:49 <jdrake> adu, how would you describe PLY?
22:48:52 <lispy> I was very confused that a* should match b
22:48:57 <lament> No sugar tonight in my lambdas; No sugar tonight in my >>=
22:49:01 <adu> jdrake: more unified than lex/yacc
22:49:16 <adu> jdrake: you can build a single Python class to hold all lex/yacc information
22:49:33 <lament> (An exercise for the reader: To rhyme something to that last line)
22:49:35 <jdrake> What makes parsec better?
22:49:44 <adu> jdrake: higher-order
22:49:53 <lament> jdrake: it's pure joy to use
22:49:57 <lament> have you tried it?
22:50:03 <jdrake> I am reading parsec.pdf now
22:50:18 <jdrake> lament, must keep in mind that I am fairly new to haskell
22:50:20 <dibblego> if t is a subset of u then u -> x is a subset of t -> x correct? i.e. (u -> x) -> t -> x Then it was put to me that how can that be the case then |u -> x| is greater than |t-> x|
22:50:24 <adu> jdrake: you can't make parsers for JavaScript's "in" thing or Haskell's op_n thing very well in Python
22:50:52 <rwbarton> dibblego: t -> x is a quotient of u -> x
22:50:52 <jdrake> My parsing should be decidedly simple
22:51:10 <dibblego> rwbarton, then "is a subset of" is incorrect?
22:51:12 <jdrake> I am writing a latex style parser, but it is not actually for anything latex
22:51:18 <dibblego> er, "is a superset of"
22:51:20 <adu> jdrake: both of which require higher-order to describe correctly imho
22:51:39 <Pseudonym> The crucial difference between lex and yacc, IMO, is that lex does ambiguity resolution silently, and yacc does it noisily.
22:51:43 <adu> jdrake: or maybe just lambdas......
22:51:49 <Pseudonym> THat's why people don't write lexers in yacc, even though it's possible in principle.
22:52:17 <rwbarton> dibblego: the map (u -> x) -> (t -> x) throws away information about the images of everything that's in u but not t.  It's not injective, so u -> x is not a subset of t -> x
22:52:33 <adu> jdrake: is it for polyurithane?
22:52:36 <rwbarton> dibblego: I'm not sure what you're asking about "superset"
22:52:37 <adu> lol
22:52:41 <jdrake> adu, eh?
22:52:44 <jdrake> What is that
22:52:54 <adu> jdrake: its a type of rubber-like material
22:53:14 <Pseudonym> polyurethane
22:53:18 <adu> o oops
22:53:22 <Pseudonym> The "ure" is form urea.
22:53:26 <Pseudonym> from
22:53:31 <jdrake> adu, I will rephrase - for TeX syntax
22:53:43 <adu> Pseudonym: what kind of "ambiguity resolution" is there in lex?
22:54:03 <adu> jdrake: I know what you meant the first time, I've written 3 papers in latex
22:54:07 <Pseudonym> adu: You don't need to specify a regex for identifiers that excludes keywords.
22:54:14 <jdrake> adu, just making sure :p
22:54:41 <dibblego> rwbarton, my brain is slowly getting it, thanks
22:54:42 <jdrake> I am only stealing the semblance of TeX, not actually using TeX. I think its markup is superior
22:55:11 <Pseudonym> Instead, if something matches multiple regexes, lex picks the first one in the lex script.
22:55:14 <jdrake> I might even get to the point of using in a wiki I want to write
22:55:51 <jdrake> But first I must parse
22:55:53 <adu> jdrake: well, parsec is a great way to go then
22:56:16 <Pseudonym> Some languages also have an overlap between their integer syntax and their floating point syntax.
22:56:42 <adu> lisp = lispAtom <|> parens $ many $ lexeme lisp
22:56:46 <jdrake> Nobody else I know dabbles in 'strange' languages, and thus look negatively towards my haskell use :p, but I continue to look at it anyways :p
22:57:07 <dibblego> jdrake, find new friends :)
22:57:24 <adu> jdrake: I have somewhat the same problem
22:57:39 <jdrake> dibblego, these are people I know in real life, and are among the brains in the small town
22:57:49 <adu> jdrake: but I think I've convinced at least 3 ppl at my work that Haskell is better, and 1 of them is interested in learning it :)
22:58:14 <jdrake> I hate to say it, but most people inhabiting Sarnia seem a little dense on the intellectual side of things.
22:58:20 <dibblego> jdrake, find a bigger town with better brains :)
22:58:51 <jdrake> dibblego, I go to university in about 2 years, or least that is the plan. Town is about 4 times larger (~360kppl)
22:58:54 <adu> Canada?
22:59:00 <jdrake> adu, yes sir
22:59:13 <adu> wow, even google maps makes it look cold
22:59:20 <Pseudonym> I heard an interesting comment from someone from the OMG today.
22:59:29 <Pseudonym> It was words to this effect:
22:59:32 <jdrake> adu, I will have you know that I am further south than some places in california
22:59:43 <jdrake> adu, another problem I have is that I don't often complete things ;P
23:00:09 <Pseudonym> All new programming languages need to look like C++.  The reason is, if it looks like C++, then a programmer can write "Hello World" within half an hour, and thus be hooked.
23:00:31 <Pseudonym> It doesn't matter how unlike C++ it is semantically.  The key is to make "Hello World" look familiar.
23:00:34 <Adamant> > "hello world"
23:00:35 <lambdabot>   "hello world"
23:00:43 <adu> jdrake: amen to that... I've been working on building an editor for 10 years
23:00:46 <Pseudonym> main = putStrLn "Hello world"
23:00:55 <jdrake> adu, I wanted to write a better nano
23:00:56 <rwbarton> main = printf "Hello world" -- :)
23:01:00 <adu> jdrake: and all I have to show for it is some SVG tests, and a crappy language spec
23:01:05 <Pseudonym> Except that to compile, you need:
23:01:07 <Pseudonym> module Main where
23:01:10 <dibblego> main { printf "Hello world" }
23:01:18 <dibblego> main { printf "Hello world"; }
23:01:22 <sjanssen> Pseudonym: no, module Main where is implicit when no module decl. is present
23:01:31 <rwbarton> Mine does require an import though.
23:01:31 <Pseudonym> Ah, true.
23:01:33 <jdrake> dibblego, may I suggest we had a few superfluous ; to help?
23:01:45 <dibblego> main = { printf "Hello world"; }
23:02:06 <sjanssen> dibblego: nope
23:02:09 <jdrake> :t ("Hello world")
23:02:10 <lambdabot> [Char]
23:02:20 <sjanssen> main = do { printf "Hellow world"; } -- will work
23:02:23 <jdrake> main = { printf ("Hello world"); }
23:02:33 <rwbarton> main = printf("Hello world"); -- also works
23:02:45 <sjanssen> ah yes, gotta have the parens
23:02:54 <jdrake> STOP! LOOK AT US!!!!
23:03:11 <adu> > printf("Hello world");
23:03:12 <lambdabot>   Add a type signature
23:03:20 <bd_> :t printf
23:03:21 <lambdabot> forall r. (PrintfType r) => String -> r
23:03:24 <adu> I love how bossy lambdabot is :)
23:03:33 <sjanssen> > printf("Hello world") :: String;
23:03:35 <lambdabot>   "Hello world"
23:03:35 <bd_> hm, is IO () a PrintfType?
23:03:41 <bd_> :t printf("Hello World") :: IO ()
23:03:42 <sjanssen> bd_: yse
23:03:42 <lambdabot> IO ()
23:03:46 <bd_> oh, neat
23:03:51 <Pseudonym> @hoogle PrintfType
23:03:51 <lambdabot> Text.Printf class PrintfType t
23:03:51 <lambdabot> Text.Printf class HPrintfType t
23:04:15 <jdrake> Is there any one in particular that is a good teacher of parsers that would be able to set me on the right track if I derail? I like to keep these things in mind as I proceed :p
23:04:51 <sjanssen> @instances PrintfType
23:04:52 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
23:05:01 <sjanssen> @instances-import Text.Printf PrintfType
23:05:02 <lambdabot> (a -> r), IO a, [c]
23:05:28 <sm> what would be a better way to report failure in this IO statement ? let (testsfile:iterations:repodir:exes') = args `catch` error usage
23:05:51 <sjanssen> sm: that is probably a type error
23:05:57 <sm> yes it is
23:06:06 <sjanssen> is args an IO value?
23:06:21 <sm> no, the previous line was args <- getArgs
23:06:52 <sm> so I want to show usage and exit for the wrong number of args
23:07:06 <sjanssen> so you could use: (do (testfile:iterations:repodir:exes') <- getArgs; dostuffhere) `catch` fail usage
23:07:23 <sjanssen> @type catch
23:07:24 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
23:07:45 <sjanssen> actually `catch` const (fail usage)
23:08:21 <sjanssen> alternatively, do args <- getArgs; case args of (tests:blah:blah) -> dostuffhere; _ -> fail usage
23:08:21 <jdrake> How does tihs work? http://hpaste.org/11631
23:08:37 <sm> fair enough.. if possible I'd like to have the error right on this line, not at the end of the whole do block
23:09:03 <sjanssen> sm: can't really do that
23:09:34 <sm> for example, I want to catch an error only in this pattern match, not any old error that happens in the block
23:09:49 <sjanssen> you'd want to use case, then
23:10:06 <sm> I see
23:10:59 <sm> I'm not entirely happy, but I'm grateful !
23:11:05 <sjanssen> jdrake: what is your question?
23:11:16 <jdrake> sjanssen, I don't understand how that parser works
23:11:25 <sjanssen> sm: or perhaps you turn it into a mini-function, acquireArgs :: IO ArgType
23:11:55 <jdrake> sjanssen, it looks like it wants a char then a (, then recursive?
23:12:01 <sjanssen> sm: then you can put the exception logic in that function, and not taint your main at all
23:12:15 <sm> thanks sjanssen, I'll explore that
23:12:22 <sjanssen> jdrake: it doesn't want "a" char, it wants only '('
23:12:27 <sjanssen> otherwise the parser fails
23:12:40 <jdrake> oh, char '(' is the character it wants then
23:13:13 <sjanssen> (<|>) composes two parsers, it executes the first argument unless it fails, in which case it executes the second argument
23:13:20 <rwbarton> char '(' is a really simple parser that either eats a '(' character and succeeds, or fails without eating anything.
23:14:20 <jdrake> ok on, (())  it eats the first two in recursion, then it tries to recurse again: but then it is ')' instead of '('
23:14:53 <sjanssen> jdrake: so when it is ')', char '(' fails, backing up to the return case
23:15:03 <rwbarton> right, so then it tries the second option, 'return ()' which succeeds, consuming nothing
23:16:05 <jdrake> So through all that it consumes nothing?
23:16:21 <sjanssen> jdrake: it consumes things
23:16:23 <rwbarton> At that point it has consumed "(("
23:16:38 <sjanssen> jdrake: remember that the first and second char '(' parsers succeed
23:16:49 <jdrake> yes
23:17:35 <jdrake> Does the thing have three different executions of return ()?
23:18:10 <sjanssen> jdrake: I count two
23:18:21 <jdrake> Shouldn't it be 1 for every )?
23:18:34 <sjanssen> yeah, you're right
23:18:37 * sjanssen can't count
23:20:24 <jdrake> ok, I think I can continue. I really have to just read a few more pages and try something
23:25:00 <jdrake> What I am sort of missing here is if you wanted to construct a tree of something you are reading in, how does the parser actually construct said tree? I would prefer to have it named simply if possible to not confuse the weary traveller.
23:27:09 <rwbarton> Parsers return values (just like IO actions return values).
23:27:38 <rwbarton> if your parser is made by sequencing several smaller parsers, you can combine the results however you want and return that
23:28:37 <rwbarton> I think there's an example of that soon after this example in the parsec manual.
23:29:33 <jdrake> I am starting an actual source file to test with
23:32:47 <jdrake> I am getting a parse error with the line: run :: Show a => Parser a -> String -> IO ()    It suggests possible incorrect indentation, but there is none.
23:33:06 <jdrake> Whole source: http://hpaste.org/11632
23:33:44 <rwbarton> that usually indicates a problem somewhere slightly above that line
23:33:53 <jdrake> crap
23:34:03 <jdrake> I replaced import with the module name itself
23:34:07 <jdrake> Ignore me, or shoot me
23:34:26 <jdrake> and please get ghc to tell me the real problem :p
23:36:11 <jdrake> I find the syntax they use here to be very wierd
23:36:27 <jdrake> Why use do{ ...  \n     ; ...  \n     ; ...    ]
23:36:29 <jdrake> }
23:37:03 <rwbarton> Some people prefer that; I don't know why
23:41:37 <snails> http://www.youtube.com/watch?v=Cac2-dTkayY
23:41:38 <lambdabot> Title: YouTube - NILE - Sacrifice Unto Sebek
23:42:31 <sjanssen> snails: what does this have to do with Haskell?
23:44:13 <snails> good tutorial.
23:44:55 <jdrake> With this: http://hpaste.org/11632#a1   It tries to sell test0r1, 2, 3 as all the same, but test0r1 only returns ')'. Also, in #3, how would you put that into the syntax ithout all of the ; { }, etc.
23:46:24 <sjanssen> @type Text.ParserCombinators.Parsec.char
23:46:25 <lambdabot> forall st. Char -> Text.ParserCombinators.Parsec.Char.CharParser st Char
23:46:46 <sjanssen> jdrake: they all parse the same thing, but their return values are a bit different
23:47:02 <jdrake> and the first are discarded
23:47:02 <rwbarton> testOr3 = (try (string "(a") >> char ')' >> return "(a)") <|> string "(b)"
23:47:22 <sjanssen> jdrake: right
23:47:27 <jdrake> rwbarton, I like the do syntax, not so fond of { } and ;
23:47:35 <jdrake> sjanssen, I remember that part of monads :p
23:47:49 <rwbarton> jdrake: Sure, then you can spread it out over lines, you might need some parentheses
23:48:01 <jdrake> rwbarton, what I am not clear on is where <|> connects with do
23:48:21 <rwbarton> (do ...) <|> string "(b)"
23:49:02 <jdrake> So if string "(b)" did anything else it would either need to be in a do or >>, >>= other things?
23:49:16 <sjanssen> jdrake: http://hpaste.org/11632#a2
23:49:41 <rwbarton> Well there are lots of ways to make actions out of simpler ones--(>>=) but also when, sequence, etc.
23:49:42 <sjanssen> jdrake: yes
23:49:45 <jdrake> Can it be done with layout alone without extra brackets?
23:50:07 <sjanssen> not in this case, due to the <|>
23:50:20 <sjanssen> or maybe it can be done
23:50:26 <rwbarton> jdrake: of course you could replace the expression in ()s with a where-bound name
23:50:55 <jdrake> rwbarton, not trying to get fancy
23:51:32 <rwbarton> Well, a lot of the time that's a sensible thing to do anyways.  parser = parseFoo <|> parseBar where parseFoo = do ...; parseBar = do ...
23:52:27 <jdrake> rwbarton, I would agree when it is more complicated
23:53:01 <adu> testBit 1 7
23:53:08 <adu> > testBit 1 7
23:53:09 <lambdabot>   Add a type signature
23:53:16 <adu> > testBit 1 7 :: Bool
23:53:17 <lambdabot>   Add a type signature
23:53:26 <jdrake> :t testBit
23:53:27 <lambdabot> forall a. (Bits a) => a -> Int -> Bool
23:53:28 <adu> > testBit 1 (7::Int)
23:53:29 <lambdabot>   Add a type signature
23:53:42 <adu> > testBit (7::Int) 1
23:53:43 <lambdabot>   True
23:53:44 <jdrake> > testBit (1::Int) 7
23:53:45 <lambdabot>   False
23:55:33 <sjanssen> jdrake: http://hpaste.org/11632#a3 layout only
23:56:04 <jdrake> you are awesome
23:56:13 <jdrake> The method in this book is so ugly
23:56:27 <sjanssen> beware of this style, it is very tricky to tell where the <|> applies
23:58:31 <jdrake> sjanssen, I shall try
23:59:04 <adu> > c2w 'h'
23:59:05 <lambdabot>   Not in scope: `c2w'
23:59:10 <jdrake> I have one coming up that shall be instructive in your statement
