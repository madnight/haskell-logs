00:03:03 <trzkril> is there an elegant way to define a map from a finit set of Char to an Enum?
00:04:04 <trzkril> using pattern matching doesn't seem right: http://hpaste.org/11071
00:05:22 <Eridius> association list?
00:06:03 <trzkril> that would at least look better, yes
00:06:42 <trzkril> i already thought of arrays but obviously that doesn't work
00:08:15 <dmwit_> lookup (zip "23456789TJQKA" [Two..Ace])
00:08:17 <dmwit_> :t lookup
00:08:18 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
00:08:23 <dmwit_> Okay, flip lookup.
00:08:52 <trzkril> thanks
00:09:13 <trzkril> so many useful structures still to explore...
00:13:48 <cads> @pl fib x | x == 0 = 0; fib x | x == 1 = 1; fib x | otherwise = fib (x-1) + fib (x-2)
00:13:48 <lambdabot> (line 1, column 16):
00:13:48 <lambdabot> unexpected "="
00:13:48 <lambdabot> expecting variable, "(", operator, "<*", "*>", "<$>", "<$", "<**>", "==", "/=", "<", "<=", ">=", ">", "`elem`", "`notElem`" or end of input
00:14:04 <dmwit_> pl doesn't do guards
00:14:15 <dmwit_> Also blocks.
00:14:52 <cads> @pl f x = x^2
00:14:52 <lambdabot> f = (^ 2)
00:15:07 <dmwit_> ?pl fix (\f x -> if x < 2 then x else f (x-1) + f (x-2))
00:15:07 <lambdabot> fix (ap (if' =<< (< 2)) . ap (ap . ((+) .) . (. subtract 1)) (. subtract 2))
00:15:07 <cads> ah
00:15:48 <rwbarton> It does let ... in as long as there are no patterns
00:17:04 <cads> the output from pl reminds me of some insane J verb
00:17:17 <rwbarton> Hmm, but...
00:17:22 <rwbarton> @pl let f (x, y) = 3 in f
00:17:22 <lambdabot> const 3
00:17:29 <rwbarton> > let f (x, y) = 3 in f undefined
00:17:31 <lambdabot>   * Exception: Prelude.undefined
00:20:07 <cads> is map implemented as   map f [] = []; map f (x:xs) = (f x):(map f xs) ?
00:20:19 <Eridius> @src map
00:20:19 <Saizan> yup
00:20:19 <lambdabot> map _ []     = []
00:20:19 <lambdabot> map f (x:xs) = f x : map f xs
00:22:02 <Eridius> rwbarton:
00:22:07 <Eridius> > let f ~(x, y) = 3 in f undefined
00:22:08 <lambdabot>   3
00:22:40 <cads> hmm, I am still unsure of when functions can do without soft parenthetical padding
00:23:09 <dmwit_> Don't worry about it too much.
00:23:31 <dmwit_> Extra parens rarely hurt readability, except when used maliciously.
00:24:46 <cads> .. like in lisp
00:25:31 <cads> I don't mind the parenthese, but I'd like to know the precedence better
00:25:56 <Eridius> you can use :info op to view precedence
00:26:15 <Eridius> if an operator doesn't have a defined precedence, I think it's infixl 5 (but it could be infix or infixr, I'm not sure of that)
00:26:34 <Eridius> of course, I'm still a bit hazy on how exactly to interpret infixl/infix/infixr
00:27:08 <Eridius> I know how to interpret it when it's the only operator being used, like 1:2:3:[], but when you get combinations of operators with different infix's, that confuses me
00:27:12 <cads> as all things haskell it suggests some amazing hierarchy
00:28:05 <Eridius> alright, time to watch Ghostbusters II
00:28:26 <cads> don't cross the breams
00:28:33 <Eridius> I love how it starts with "5 Years Later". It's like "yeah bitch, if you ain't seen Ghostbusters, you got no clue what's going on now"
00:30:21 <Saizan> cads: the easy rule to remember is that function application has higher precedence than every operator
00:30:44 <Saizan> s/every/any/
00:32:13 <hackage> Uploaded to hackage: ghc-core 0.4.1
00:32:13 <hackage> Uploaded to hackage: uvector 0.1.0.2
00:47:33 <cads> @pl \ n -> [1..n]
00:47:33 <lambdabot> enumFromTo 1
00:47:43 <cads> fucking sweet.
00:59:21 <sheyll>  
00:59:26 <sheyll> hi
00:59:44 <cads> herro
01:00:11 <sheyll> do you have a recommendation for a good read about the diffrence between newtype and data?
01:00:11 <cads> @pl subst (a:as) (b:bs) = (a == b) && (prefix as bs) || (subst (a:as) bs)
01:00:14 <lambdabot> subst = fix (flip ap tail . (. head) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . ap (ap . ((flip . (liftM2 (||) .)) .) . (. prefix) . flip . (((.) . (&&)) .) . (=
01:00:14 <lambdabot> =)) . (. (:)) . (.))
01:00:14 <lambdabot> optimization suspended, use @pl-resume to continue.
01:00:44 <cads> @pl-resume
01:00:46 <lambdabot> subst = fix ((`ap` tail) . (. head) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . ap (ap . ((flip . (liftM2 (||) .)) .) . (. prefix) . flip . (((.) . (&&)) .) . (==
01:00:46 <lambdabot> )) . (. (:)) . (.))
01:00:50 <cads> :D
01:01:10 <Cale> sheyll: the Haskell report mentions the difference
01:02:11 <Deewiant> @pl subst (a:as) (b:bs) = a == b && (prefix as bs || subst' (a:as) bs)
01:02:12 <lambdabot> subst = ap (flip flip tail . (ap .) . flip flip head . ((.) .) . ap ((.) . flip . (((.) . (&&)) .) . (==)) (ap (ap . ((||) .) . prefix) . (subst' .) . (:)) . head) tail
01:02:23 <Cale> sheyll: Basically, it's that if you say, have  newtype N = N Integer, then undefined :: N is the same thing as N undefined :: N
01:02:33 <cads> Deewiant: I love this thing
01:02:43 <Deewiant> cads: yes, it can be fun to play with
01:02:47 <Cale> Whereas with data D = D Integer, those two are distinguishable
01:03:36 <Cale> case (D undefined) of D x -> 5  will be 5, but  case undefined of D x -> 5 will be undefined
01:04:00 <Cale> So the difference is rather subtle there.
01:05:38 <Cale> sheyll: Of course, there's a big difference from the perspective that newtype only lets you define types with one case and one field, and there's newtype deriving, which lets (almost) any class for which the original type had an instance be derived.
01:08:45 <cads> @unpl subst' = fix ((`ap` tail) . (. head) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . ap (ap . ((flip . (liftM2 (||) .)) .) . (. prefix) . flip . (((.) . (&&)) .) . (==)) . (. (:)) . (.))
01:08:46 <lambdabot> subst' = fix (\ ba -> (\ dr k -> (\ y -> ((\ cn cs -> (\ eg ac ad -> (\ as -> (cn == ad) && (prefix eg as)) >>= \ af -> ac >>= \ ae -> return (af || ae)) >>= \ cp -> cs >>= \ co -> return (cp co)) >>
01:08:46 <lambdabot> = \ cg -> (\ es ax -> ba (((:)) es ax)) >>= \ cf -> return (cg cf)) (head dr) k (head y)) >>= \ bo -> tail >>= \ bn -> return (bo bn)) >>= \ eu -> tail >>= \ et -> return (eu et))
01:09:37 <cads> lemme see if that works heh
01:11:20 <lispy> Cale: go look at my email about Haskell in python and comment ;)
01:11:35 <lispy> Cale: I'm just teasing of course
01:11:43 <lispy> but, I waiting for smart people to comment
01:12:34 <dons> here are the packages that break with ghc 6.10, and why,
01:12:35 <dons>  http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/15430
01:12:40 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/3ruoyg
01:12:43 <dons> have a think about them, if you're a maintainer.
01:12:51 <dons> and we'll collect all the standard solutions.
01:13:21 <dons> 58/600 or so break. so a bit less than 10% new breakage. most of which is easy to fix.
01:14:03 <lispy> dons: I cehcked, none of my packages on that list
01:14:13 <lispy> dons: should we be emailing the maintainers directly?
01:17:35 <Saizan> dons: hslogger looks affected by the changes to Data.Map here
01:18:01 <dons> hslogger has been fixed. cabal update
01:18:19 <dons> lispy: soon. tomorrow maybe.
01:18:32 <dons> once a few wise heads look at the results (sent to glasgow-haskell-users@)
01:18:40 <dons> i'd like Ross' input on the Arrow class changes
01:18:52 <lispy> sounds good
01:19:04 <dons> best managed ghc release transition ever :)
01:19:13 <dons> no more fear: we know exactly what's going to break and how
01:19:16 <dons> so we can plan for it.
01:19:34 <dons> all thanks to cabal-install and hackage
01:19:52 <lispy> we build this hackage!
01:20:02 <dons> with cabal install
01:20:08 * lispy breaks into 80s songs
01:20:15 <dons> :)
01:29:58 <besiria> i can't understand how MonadWriter works. tell,listen,pass what these functions do?
01:30:50 <Saizan> > runWriter $ tell [1] >> tell [2]
01:30:51 <lambdabot>   ((),[1,2])
01:31:13 <dmwit_> besiria: tell makes a log of things you've written
01:31:18 <dmwit_> :t pass
01:31:19 <lambdabot> forall (m :: * -> *) a w. (MonadWriter w m) => m (a, w -> w) -> m a
01:31:50 <dmwit_> I guess pass is much like "modify" for the State monad; it just munges the log somehow.
01:32:26 <dmwit_> > runWriter $ tell [1] >> return ((), take 5 . cycle) >>= pass
01:32:27 <lambdabot>   Couldn't match expected type `[a] -> [a]'
01:32:54 <Saizan> > runWriter $ pass (tell [1] >> return ((), take 5 . cycle))
01:32:55 <lambdabot>   ((),[1,1,1,1,1])
01:33:13 <dmwit_> oh right
01:33:15 <Saizan> > runWriter $ listen $ pass (tell [1] >> return ((), take 5 . cycle))
01:33:16 <lambdabot>   (((),[1,1,1,1,1]),[1,1,1,1,1])
01:33:55 <dmwit_> > runWriter $ tell [1] >> pass (return ((), take 5 . cycle))
01:33:55 <Saizan> the important one is tell anyhow
01:33:56 <lambdabot>   ((),[1* Exception: Prelude.cycle: empty list
01:34:05 <dmwit_> huh
01:34:26 <dmwit_> Ah, that makes sense, actually.
01:34:40 <besiria> so it works like a log
01:34:59 <dmwit_> besiria: Of course it depends on your Monoid.
01:35:05 <besiria> the writer type is a monoid and the logs are mappended?
01:35:05 <dmwit_> But mostly yes, it works like a log.
01:35:10 <dmwit_> besiria: yes
01:35:16 <besiria> dmwit_: ok thx
01:35:26 <besiria> so i should not care about listen and pass?
01:36:09 <dmwit_> Well, it depends on what you're doing, I guess.
01:36:17 <dmwit_> If you need listen or pass, then pay attention to them. =P
01:36:36 <dmwit_> They're there because at some time, somebody wanted them...
01:37:05 <besiria> hmm a MonadState could work like a MonadWriter, right?
01:37:18 <dmwit_> Yes.
01:37:18 <besiria> like a log
01:37:23 <besiria> ok ty
01:37:26 <dmwit_> Yes, you could use MonadState to keep a log.
01:37:48 <Saizan> tell x = modify (`mappend` x)
01:37:52 <dmwit_> Though if you're just keeping a log... MonadWriter is really the way to go. =)
01:38:55 <dmwit_> Writer has a pretty narrow use case, I think.
01:38:57 <Saizan> State lets you cheat and edit the log of previous computations
01:39:01 <dmwit_> I used it for the first time just last week.
01:40:36 <besiria> State is awesome
01:50:29 <olsner> Yuck! I just realized I have a problem that's probably best solved with Perl :(
01:51:10 <ivanm> olsner: impossible!
01:51:27 <ivanm> unless it involves mangling in an evil sort of way... >_>
01:51:29 <dmwit_> I suggest sleeping on it.
01:51:55 <dmwit_> Sometimes I realize I'd rather deal with the problem than with the solution. =P
01:51:59 <olsner> well, the perl program could start a haskell program and speak to it over a socket I guess
01:53:35 <olsner> hmm, a gtk2hs GUI would be a definite possibility ... and it could hopefully hide away the required perl ugliness into a child process (however you do those on windows...)
01:54:28 <Saizan> what's so perlish about it?
01:54:53 <olsner> there's a specific perl interface it has to use
01:56:11 <olsner> I *could* start figuring out how perl dll interfaces work and ffi them
01:56:57 <mnislaih> dcoutts: there ? I am trying out RC1 of 6.10 and cabal-install eats my memory when checking dependencies.
01:57:12 <olsner> well, it's a work problem anyway, it'll have to wait until tuesday
01:57:15 <mnislaih> dcoutts: should I rebuild cabal-install itself  with the bundled version of Cabal? what is the right way to do it ?
01:57:49 <Saizan> mnislaih: you need darcs version of cabal-install
01:58:02 <Saizan> mnislaih: built with the Cabal ghc-6.10 provides
01:58:02 <mnislaih> Saizan: thanks
02:01:23 <mnislaih> Saizan:  darcs version at darcs.haskell.org/cabal-install ? That one requires Cabal 1.6, ghc ships with 1.5
02:16:15 <Saizan> mnislaih: oh, yeah, versions have been bumped very recently, update Cabal :)
02:23:57 <phoenixblitz> Hi guys, I have a mini problem... the code is at http://hpaste.org/11072
02:24:34 <phoenixblitz> The problem is that for some reason even if gravity = 1, the thread doesn't seem to sleep 1 second (gravity x 1000000 microseconds)
02:24:41 <phoenixblitz> it seems to take ALOT more time
02:24:44 <phoenixblitz> more like 5 seconds
02:25:58 <phoenixblitz> actually its quite at random it seems
02:26:02 <phoenixblitz> can anyone help?
02:28:36 <phoenixblitz> i updated the link with the updateWindow function @ http://hpaste.org/11072#a1
02:29:26 <phoenixblitz> is there possibly no one?? :/
02:29:49 <phoenixblitz> wow this is the first time #haskell has let me down
02:39:29 <mib_l0d7bzhc> > 1+1
02:39:31 <lambdabot>   2
02:39:34 <mib_l0d7bzhc> wow
02:39:36 <mib_l0d7bzhc> no one here
02:39:52 <zachk> > 2 + 2
02:39:54 <lambdabot>   4
02:40:00 <zachk> > "hello mibbit person"
02:40:01 <lambdabot>   "hello mibbit person"
02:42:23 <mnislaih> Saizan: I get undefined symbols from GHC.Base when finally linking cabal-install. Any ideas ?
02:43:22 <BeelsebobWork> @users
02:43:22 <lambdabot> Maximum users seen in #haskell: 518, currently: 475 (91.7%), active: 9 (1.9%)
02:43:32 <BeelsebobWork> mib_l0d7bzhc: only 475 no ones?
02:44:27 <snhmib> can i do io in a monad like this: newtype TclBinder a = TclBinder (TclBinderState -> IO (TclBinderState, a))
02:44:29 <snhmib> ?
02:47:28 <mnislaih> ok, problem solved, the missing symbols from GHC.Base were due to object files around from a previous erroneus attempt at bulding it with ghc 6.8.2
02:48:40 <xenoblitz> guys... Saizan, BeelsebobWork, quicksilver, any haskellbot I might have forgotten: I have a really strange problem @ http://hpaste.org/11072#a1, the problem is that my thread is working erratically, very erratically and I can't figure what is wrong with the code :(
02:49:35 <BeelsebobWork> xenoblitz: sorry, I don't do imperative programming
02:49:57 <xenoblitz> BeelsebobWork: but mate I can't do that otherwise :S
02:50:12 <xenoblitz> BeelsebobWork: can I?
02:50:23 <BeelsebobWork> sure -- reactive time
02:50:38 <xenoblitz> can you point me to a link?
02:51:32 <BeelsebobWork> http://code.haskell.org/reactive/
02:51:33 <lambdabot> Title: Index of /reactive
02:52:56 <xenoblitz> thanks mate i'll look it up
02:53:52 <xenoblitz> sigh althought I wish to do this, its pretty advanced ... http://haskell.org/haskellwiki/Reactive
02:53:54 <lambdabot> Title: Reactive - HaskellWiki
02:53:55 <xenoblitz> thanks all the same
02:55:49 <Saizan> xenoblitz: define erratically
02:56:51 <xenoblitz> Saizan: i added putstrln after everyline now and its blocking totally at random
02:57:38 <b_jonas> I have a stupid question again
02:58:01 <xenoblitz> Saizan: it seems that the problem is with the readMVar and putMVar and takeMVar
02:58:49 <xenoblitz> Saizan: threadDelay works ok with them
02:58:58 <xenoblitz> Saizan: I mean *WITHOUT them
02:58:59 <Saizan> xenoblitz: it's not clear to me why you're using an MVar
02:59:05 <b_jonas> last time someone talked about how someone would want to serialize algebraic data to types composed of tuples and eithers and units
02:59:20 <b_jonas> and then someone, I think quicksilver, mentioned that you also need Mu if you want recursive types too
02:59:47 <b_jonas> but is Mu really enough if you're only allowed to use tuples and eithers and units? don't you need something more?
02:59:48 <xenoblitz> Saizan: because i would like to have another thread access the same MVar Game, so both update the same item
03:00:12 <xenoblitz> forkIO $ gameLoop window gameVar
03:00:13 <xenoblitz> userInputLoop window gameVar
03:00:20 <xenoblitz> just to give you an indication
03:02:07 <Saizan> ok, but you're getting weird behaviour from just gameLoop, with no other thread involved?
03:02:17 <xenoblitz> yes
03:04:27 <Saizan> b_jonas: i guess you can have some problems with function types
03:04:40 <Cale> b_jonas: Seems to me that it should be, unless you have function types... yeah
03:05:34 <b_jonas> Saizan, Cale: sure, functions would cause problems, but even with just plain recursive algebraic types I think you can't use Mu this way
03:05:49 <b_jonas> you'd have to be able to define a new (non-recursive or less recursive) data type to pass to Mu
03:06:12 <Cale> Oh, yes you would.
03:06:38 <b_jonas> but that data type would be * -> * ranked
03:06:43 <Cale> Unless you had type lambda.
03:06:58 <b_jonas> and you can't build an equivalent to it with just pairs and eithers and units
03:07:01 <Cale> Yeah, Mu demands a type function.
03:07:15 <Cale> You need a lambda.
03:07:19 <b_jonas> obviously if you take just non-recursive types then pairs, eithers and units are enough
03:07:26 <b_jonas> bad
03:07:36 <b_jonas> so is there some way this equivalent type thing can be done?
03:08:01 <b_jonas> with, like, a few more simple types added?
03:08:25 <Saizan> i guess you need higher order sum and product, and a const like functor
03:08:49 <b_jonas> hmm
03:08:53 <Saizan> (+) and (*) bifunctor are often overloaded like that in the CT papers i've seen
03:09:25 <Saizan> like type  f :+: g x = (f x, g x)
03:10:01 <BeelsebobWork> I take it you guys have all seen the TypeCompose module?
03:10:12 <Cale> I'm not sure you'll get everything unless you also have type lambda though.
03:14:44 <Saizan> Mu (Const () :+: (Const A :*: Id)) ~~ [A] ?
03:14:58 <Saizan> do we need S too? :)
03:15:15 <b_jonas> can S even be done?
03:15:35 <mib_l0d7bzhc> bored
03:16:09 <b_jonas> shouldn't it be (f :*: g) x = (f x, g x) though?
03:16:28 <b_jonas> also, wouldn't these cause problems with the type system restrictions?
03:16:46 <Saizan> b_jonas: yeah, i got the symbol wrong
03:17:13 <BeelsebobWork> (f :+: g) x = Either (f x) (g x)?
03:17:24 <Saizan> you mean the restriction on "type"?
03:17:30 <Saizan> BeelsebobWork: yeah
03:17:52 <b_jonas> Saizan: I'm not sure. maybe more than one restriction
03:18:41 <b_jonas> btw, how's haskell handling those recursive data definitions that lead to an infinite data types needed if you want to expand a polymorphic function? iirc it's called non-generative polymorphism
03:18:49 <Saizan> you could define them as newtypes, however
03:20:56 <b_jonas> yeah, :+: and such surely
03:22:55 <Saizan> i'm not sure if it's relevant, but the usual solution when you get an infinite type is to use a recursive newtype instead
03:23:30 <b_jonas> yes, that's not what I mean though
03:23:51 <b_jonas> what I mean is things like data Foo a = Bar (Foo (a,a)) | Qux a;
03:24:34 <b_jonas> so then if you define a polymorphic function of type Foo a -> Bool then it will have to work for an infinite concrete types
03:25:13 <b_jonas> so you can't compile it by generating code for it for every possible monomorphic type
03:25:21 <b_jonas> (template-like that is)
03:26:05 <Saizan> well, but it's not like id :: a -> a is compiled by generating code for every possible type
03:26:38 <b_jonas> yes, I know ghc usually doesn't compile like that
03:26:43 <b_jonas> for practical reasons
03:26:49 <b_jonas> but it could be compiled like that too
03:26:55 <b_jonas> id too could be
03:27:27 <Saizan> yeah, but if you don't there's no problem, no?
03:27:28 <b_jonas> I just tried, and ghc doesn't seem to complain for such non-generative polymorphism
03:27:48 <b_jonas> Saizan: I wonder if there's some kind of restriction rule on them
03:28:03 <b_jonas> maybe some of them work and some constructs don't
03:28:08 <b_jonas> I tried this definition
03:28:16 <b_jonas> data Twin a b = Moar (Twin (b,a) b) | Enuf a a deriving ...
03:28:48 <b_jonas> then Twin () a describes two "lists" of a of equal length
03:28:52 <Saizan> ah, ok, i'm not aware any restrictions
03:28:55 <b_jonas> so there's Moar (Moar (Enuf (2,(9,())) (5,(3,()))));
03:29:03 <b_jonas> which has type Twin () Int
03:29:20 <b_jonas> but you have to have the same number of integers in  (2,(9,())) and in  (5,(3,()))
03:30:16 <ziman> hm, using `newtype Inf a = Inf (Inf a)', typing `Inf undefined' into GHCI gave a quite surprising result for me
03:30:41 <b_jonas> ziman: did it say no instance Show?
03:30:49 <ziman> erm, deriving Show
03:31:12 <b_jonas> it started showing "Inf " and then printed an exception message then?
03:31:16 <Saizan> you got a Prelude.undefined error i guess
03:31:17 <b_jonas> that would be my guess
03:31:17 <ziman> > cycle "Inf(" -- this is what it did
03:31:18 <lambdabot>   "Inf(Inf(Inf(Inf(Inf(Inf(Inf(Inf(Inf(Inf(Inf(Inf(Inf(Inf(Inf(Inf(Inf(Inf(In...
03:31:29 <Saizan> oh, nice :)
03:31:36 <ziman> no Prelude.undefined
03:31:56 <b_jonas> > [2, undefined]
03:31:58 <lambdabot>   [2,* Exception: Prelude.undefined
03:32:01 <b_jonas> hmm
03:32:06 <ziman> i'm pondering why, now
03:32:44 <Saizan> well, try myshow (Inf x) = "Inf (" ++ show x ++ ")"
03:32:46 <mauke> probably because show (Inf x) = "Inf (" ++ show x
03:33:19 <b_jonas> what type is `Inf undefined' there?
03:33:25 <Saizan> Inf a
03:34:04 <b_jonas> Saizan: it has to have a monomorphic type if it's shown
03:34:16 <b_jonas> Saizan: as in when you type `1' to ghci, it will be Integer I guess
03:34:21 <mauke> then it probably defaults to ()
03:34:25 <Saizan> oh, right, it's defaulted to ()
03:34:30 <b_jonas> > \x->1
03:34:32 <lambdabot>       Overlapping instances for Show (t1 -> t)
03:34:32 <lambdabot>        arising from a use of `...
03:34:39 <Saizan> :t []
03:34:40 <lambdabot> forall a. [a]
03:34:43 <Saizan> > []
03:34:45 <lambdabot>   []
03:34:52 <mauke> :t undefined
03:34:53 <lambdabot> forall a. a
03:34:54 <mauke> > undefined
03:34:55 <lambdabot>   * Exception: Prelude.undefined
03:43:23 <mib_efpcpmsk> > 1+1
03:43:25 <lambdabot>   2
03:43:31 <mib_efpcpmsk> > 2+2
03:43:33 <lambdabot>   4
03:43:39 <mib_efpcpmsk> hey guys i have a questioon on functions
03:43:41 <Baughn> > iterate (*2) 1
03:43:43 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
03:43:43 <mib_efpcpmsk> lets say i have 2 functions
03:43:52 <mib_efpcpmsk> both function used the same variable name
03:43:55 <mib_efpcpmsk> would it clash?
03:43:59 <vixey> no
03:44:00 <Baughn> No
03:44:05 <vixey> NO
03:44:06 <vixey> :))
03:44:06 <Baughn> Haskell uses lexical scoping
03:44:09 <mib_efpcpmsk> like add a b = a+b and multiply a b = a*b
03:44:18 <mib_efpcpmsk> why it does not clash? could someone explain to me
03:44:27 <vixey> it's because of lambda
03:44:29 <mib_efpcpmsk> i heard that haskell variables are global unless its local (in let and in)
03:44:32 <mauke> have you ever written programs in any language?
03:44:39 <Baughn> mib_efpcpmsk: Function parameters are also local
03:44:43 <mib_efpcpmsk> not really active in writing programs
03:44:56 <vixey> read about lambda calculus for a formal description of scope
03:45:02 <Baughn> mib_efpcpmsk: Also, haskell doesn't have global values. They're always at most module-global
03:45:10 <Baughn> vixey: ..that might be overkill
03:45:20 <mib_efpcpmsk> baughn: what does it mean by function parameters are local?
03:45:35 <Baughn> mib_efpcpmsk: "foo a b = ..." <-- a and b only exist inside the definition of foo
03:45:44 <Baughn> So they won't clash with anything else
03:45:49 <Baughn> ..which is how every other language works
03:45:52 <mib_efpcpmsk> oh thanks baughn for the clarification :D
03:46:04 <mib_efpcpmsk> baughn : how about module-global? can explain?
03:46:06 <mauke> Baughn: except for perl!
03:46:09 <Baughn> It also allows shadowing - you can say "foo words lines = ...", but that's discouraged as confusing
03:46:29 <Baughn> (In case you're wondering, words and lines are also the names of functions in the prelude)
03:46:33 <Baughn> > words "Howdy, neighbour"
03:46:35 <lambdabot>   ["Howdy,","neighbour"]
03:46:54 <mauke> mib_efpcpmsk: every haskell identifier belongs to some module
03:47:05 <mib_efpcpmsk> to mauke: like prelude?
03:47:09 <mauke> yes
03:47:14 <Baughn> mib_efpcpmsk: If you don't name the module with a line like "module Foo where", the module is implicitly named Main
03:47:15 <mib_efpcpmsk> i see
03:47:31 <mib_efpcpmsk> oh i did nt know that
03:47:36 <b_jonas> well, non-generative polymorphism does seem to work: http://erxz.com/pb/12663
03:47:41 <lambdabot> Title: freenode_web paste from "b_jonas" at 71.6.194.243...
03:47:47 <Baughn> mib_efpcpmsk: The point is, a value in module Foo won't clash with one of the same name in module Bar, unless you explicitly export it from Foo /and/ import Foo into Bar
03:47:56 <b_jonas> I could define a type Twin that holds two equally long lists of integers
03:48:09 <b_jonas> and a function that zips that to a [(Int, Int)]
03:48:18 <SamB_XP> Baughn: or export it from both and import them into Baz
03:48:24 <b_jonas> so haskell does allow these
03:48:27 <b_jonas> question solved
03:48:29 <Baughn> mib_efpcpmsk: Oh, and haskell doesn't have global variables, whether module-global or otherwise, period. It does have local variables, though you should try to do without
03:48:37 <vixey> b_jonas: http://www.eecs.usma.edu/webs/people/okasaki/icfp99.ps
03:49:11 <SamB_XP> Baughn: then what are all these top-level identifiers I've been using ?
03:49:28 <Eridius> oops, I accidentally wrote a program that sucked up 1.3GB before I realized it and terminated it
03:49:30 <Baughn> SamB_XP: Definitions
03:49:54 <Baughn> Eridius: +RTS -M512m might be good while developing
03:50:18 <Eridius> neat
03:50:18 <Baughn> SamB_XP: You can't really have a variable that's not, well, variable, now can you?
03:50:35 <SamB_XP> Baughn: I've been asking myself that for years
03:51:00 <Baughn> SamB_XP: In haskell at least, I prefer to reserve that word for MVars, STVars, IORefs, etc. etc. etc.
03:51:00 <Eridius> Baughn: and I can use that when compiling a program?
03:51:11 <Baughn> Eridius: Sorry. Well, you could, but it'd only affect the compiler.
03:51:13 <Eridius> oh
03:51:26 <Eridius> so every single haskell compiled program understands +RTS args then?
03:51:28 <Baughn> Eridius: What you can do is write a shell script to run it. Or bake a test-run into a makefile. :P
03:51:38 <Baughn> Every single GHC-compiled program
03:51:41 <Eridius> huh
03:51:48 <Baughn> Try +RTS --help
03:52:07 <b_jonas> vixey: thanks for the pointer
03:52:08 <mib_efpcpmsk> baughn : what is a lexical scoping
03:52:23 <Baughn> mib_efpcpmsk: http://en.wikipedia.org/wiki/Lexical_scoping#Static_scoping_.28also_known_as_lexical_scoping.29
03:52:26 <lambdabot> Title: Scope (programming) - Wikipedia, the free encyclopedia, http://tinyurl.com/26ulml
03:53:07 <Baughn> Eridius: Oh, and only parameters that actually work with your program will show up in that help screen, which depends on compile-time options. Check the ghc manual for the rest.
03:53:11 <vixey> seriously, read a math text on lambda calculus
03:53:27 <vixey> this stuff has been made completely unambiguous and formal
03:53:40 <mauke> boring
03:53:45 <b_jonas> vixey: do you mean untyped lambda calculus?
03:54:08 <vixey> yeah it's completely boring
03:54:11 <b_jonas> vixey: also, wait, is that for me or someone else?
03:54:17 <vixey> no not you b_jonas
03:54:25 * b_jonas tries to write the inverse of the ziptwin function
03:54:38 <Baughn> *zipWith?
03:54:44 <mib_efpcpmsk> how does b_jonas make the red word
03:54:51 <mib_efpcpmsk> without his name appearing
03:54:57 <Baughn> Isn't that just unzip . map?
03:55:14 <mauke> mib_efpcpmsk: what?
03:56:03 <b_jonas> I think I read a paper somewhere that said this wasn't allowed in standard ml (or some such language)
03:56:15 <b_jonas> Baughn: no, the ziptwin function I pasted to http://erxz.com/pb/12663
03:56:26 <vixey> b_jonas: I think it's the polymorphic recursion
03:56:34 <Baughn> b_jonas: Oh, zipTWin
04:02:21 <darx> hi, can someone suggest some resources on recursion removal. i'm specifically looking for a general overview of all the techniques. thanks..
04:03:50 <mauke> what's recursion removal?
04:04:03 <Baughn> Replacing explicit recursion with higher-order functions, maybe?
04:04:15 <mauke> I choose fix
04:04:18 <darx> recursion to iteration perhaps?
04:04:30 <Baughn> In haskell?
04:04:32 <mauke> iteration is just a special case of recursion
04:04:34 <vixey> darx: are you writing a compiler?
04:05:25 <b_jonas> darx: the book Higher Order Perl by Mark Jason Dominus have quite a lot written about it
04:06:21 <b_jonas> back to the mu thing, the point is, you can define instances so all types built from tuples and eithers and units are instance of a class
04:06:37 <darx> b_jonas, vixey, thanks
04:06:42 <b_jonas> and you can do that even for mu I guess, but you can't just do it for all types defined from type lambdas
04:06:57 <b_jonas> which is why it would be nice to have an equivalent to all types built from just a few primitives
04:07:01 <vixey> what mu thing?
04:07:03 <viyenga> related to recursion I have a question. Are there posssibly self recursive functions which cannot be converted to a tail call optimized version?
04:07:23 <mauke> fib n = fib (n - 1) + fib (n - 2)
04:07:46 <viyenga> yeah but traditionally the fib problem is solved by counting up
04:07:49 <vixey> viyengo: That question is too vague to answer
04:07:55 <mauke> my version doesn't have a base case
04:09:55 <path[l]> vixey: oh? sorry I dont understand why? I mean I recently saw a tail optimized version of the fibbonacci problem. So I was wondering if any recursive function can be invariable converted to a tail optimized form or is it not always the case. I was trying to see if I could come up with a simple problem where that isnt possible.
04:10:47 <vixey> path[1]: If you write a recursive program in haskell I can always rewrite it in java using while loops
04:10:47 <mauke> tsum (Leaf n) = n; tsum (Branch l r) = tsum l + tsum r
04:11:01 <vixey> path[1]: does that help?
04:11:26 <mauke> if you write a recursive program in C, I can always rewrite it in asm using conditional jumps
04:11:27 <vixey> (I mean is that related to what you are thinking about?)
04:11:47 <vixey> I didn't use C because it may or may not do TCO
04:11:50 <b_jonas> vixey: this mu thing: http://erxz.com/pb/12664
04:11:51 <lambdabot> Title: freenode_web paste from "b_jonas" at 71.6.194.243...
04:11:57 <path[l]> vixey: I guess. Following from there does it mean any iterative program  can be written in a tail call optimized manner?
04:12:12 <b_jonas> vixey: representing any algebraic data type from a few simple types
04:12:21 <vixey> b_jonas: ah ok
04:12:42 <vixey> path[1]: Yes, that's one of the ways schemers program
04:12:52 <path[l]> Ive just come across tail call optimization recently, so Im trying to understand it
04:13:10 <vixey> path[1]: Scheme is a really good context to understand it in
04:13:23 <mauke> "read SICP!"
04:13:25 <Cale> path[l]: You can take that as a definition of an iterative program.
04:13:44 <Cale> (one which runs in constant stack)
04:13:49 <vixey> path[1]: If you want to nail this down learn how to CPS convert Scheme code and look at how tail calls (as defined in R5RS) end up
04:14:00 <Cale> Though you have to be careful what you mean by stack space :)
04:14:30 <path[l]> ah ok thanks. A lot of this terminology isnt familiar to me, but Ill look it up :)
04:19:25 <mauke> why didn't anyone tell me about System.Timeout!
04:19:32 <mauke> this is awesome
04:20:55 <b_jonas> the unzip function works too: http://erxz.com/pb/12665
04:20:55 <lambdabot> Title: freenode_web paste from "b_jonas" at 71.6.194.243...
04:21:17 <b_jonas> but the bad news is, something in my ghc is broken
04:22:06 <b_jonas> ah, it works now
04:22:22 <b_jonas> so the trick is, ghci doesn't require the main module to be called Main but ghc does
04:22:41 <b_jonas> if you call the module something different, you can :load the module with ghci and :main
04:22:48 <b_jonas> but you can't compile the program that way
04:22:55 <b_jonas> ok, I'll have to remember that
04:23:00 <SamB_XP> you can too
04:23:07 <SamB_XP> you just have to pass some special flags
04:25:57 <b_jonas> so this thing is called polymorphic recursion then
04:25:58 <b_jonas> I see
04:26:39 <int-e> b_jonas: there is a -main-is option for ghc
04:26:43 <vixey> b_jonas: I think you can pack a bit more expressivity in with GADTs too
04:27:29 <int-e> b_jonas: http://www.haskell.org/ghc/docs/latest/html/users_guide/options-phases.html#id340655
04:27:30 <lambdabot> Title: 5.10.�Options related to a particular phase, http://tinyurl.com/smq5n
04:41:21 <mib_efpcpmsk> >1+1
04:41:26 <mib_efpcpmsk> > 1+1
04:41:27 <lambdabot>   2
04:41:57 <mib_efpcpmsk> hey guys, what kind of ordering function that allows me to extract 1 element at a time from [[String]] so i could feed it to my another function
04:42:33 <mib_efpcpmsk> which takes in 2 list, ABC [Int] [String] <<< i want to feed this function with 1 element at a time from [[String]]
04:42:43 <mib_efpcpmsk> concatMap?
04:43:06 <mauke> map
04:43:11 <b_jonas> mibbit: a good rule of thumb is to figure out what type the function you want would be, and hoogle for it
04:43:26 <b_jonas> mibbit: for I'm not really sure what exactly you want
04:43:44 <b_jonas> feed one element at a time to a function is not quite specific
04:44:15 <Philonous1> Is there a data structure for "sparse" lists, i.e. lists that have some fixed value almost everywhere but a few places?
04:44:16 <b_jonas> could be map, mapM, find, foldr, whatever
04:44:40 <b_jonas> Philonous1: maybe an IntMap
04:44:46 <b_jonas> Philonous1: depends on what you want to do with them
04:44:48 <mauke> Philonous1: Data.Map
04:44:59 <Philonous1> Thanks, I'll look into them
04:45:00 <b_jonas> Philonous1: see Data.IntMap
04:45:54 <oklopol> > let coolmap v fl = map (f -> f v) fl in coolmap 4 [(*2), (+5), (*3)]
04:45:54 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 34}
04:45:55 <lambdabot> ...
04:46:09 <mauke> \
04:46:15 <oklopol> > let coolmap v fl = map (\f -> f v) fl in coolmap 4 [(*2), (+5), (*3)]
04:46:16 <lambdabot>   [8,9,12]
04:46:20 <oklopol> thanks
04:46:22 <mauke> ($ v)
04:46:35 <mib_efpcpmsk> b_jonas writeRow :: [Int] -> [[String]] -> String
04:46:36 <mauke> > sequence [(*2), (+5), (*3)] 4
04:46:38 <lambdabot>   [8,9,12]
04:46:50 <mib_efpcpmsk> b_jonas writeCell :: [Int] -> [String] -> String
04:46:55 <b_jonas> mibbit: try hoogling for it
04:47:06 <mib_efpcpmsk> where to hoogling?
04:47:08 <b_jonas> @hoogle [Int] -> [[String]] -> String
04:47:09 <lambdabot> Test.QuickCheck configEvery :: Config -> Int -> [String] -> String
04:47:19 <b_jonas> that's not what you want
04:47:22 <b_jonas> let's try something more general
04:47:46 <b_jonas> well I still don't understand what function you want really
04:47:56 <mib_efpcpmsk> b_jonas its actualy a custom function
04:48:19 <mib_efpcpmsk> i just basically want to allow writeRow to feed an [Int] and [String] into writeCell
04:48:34 <Philonous1> b_jonas: Data.IntMap.findWithDefault is exactly what I was looking for. Thanks :)
04:48:34 <b_jonas> ah
04:48:44 <mib_efpcpmsk> but the raw data is in [[String]] , so i need to take 1 element out of [[String]]
04:48:47 <b_jonas> I see
04:49:14 <mib_efpcpmsk> [[String]] = [ [string],[string2], [string3]...]
04:49:22 <b_jonas> maybe map, I'm not sure
04:49:37 <b_jonas> what would you do with all the resulting strings you get from the lots of writeCell calls?
04:49:37 <mib_efpcpmsk> so i want to take 1 element out and place it into writeCell (this is the purpose of my writeRow)
04:49:52 <mib_efpcpmsk> display a table
04:50:07 <mib_efpcpmsk> [[string]] is a list of records
04:50:31 <mib_efpcpmsk> so i want each element displayed in 1 line then ++ "\n" then ++ the next element ++"\n"
04:50:52 <int-e> > unlines ["abc", "def", "geh"]
04:50:53 <lambdabot>   "abc\ndef\ngeh\n"
04:51:00 <int-e> @hoogle [String] -> String
04:51:01 <lambdabot> Prelude unlines :: [String] -> String
04:51:01 <lambdabot> Prelude unwords :: [String] -> String
04:51:01 <lambdabot> Data.List unlines :: [String] -> String
04:52:36 <mib_efpcpmsk> unlines is good
04:52:40 <b_jonas> mibbit: well, I think you want map to get a list of results from calling writeCell many times, and then some function to concatenate it
04:52:48 <b_jonas> concat or unlines or intersperse or intercalate
04:52:53 <mib_efpcpmsk> however, i have made a custom function writeCell that does unlines + something else
04:52:54 <b_jonas> you might even want concatMap
04:53:16 <mib_efpcpmsk> the thing that puzzles me is how to get 2 list into a function while the second list is [[String]]
04:53:54 <b_jonas> apply writeCell partially to just the first argument, and pass that to map?
04:54:05 <b_jonas> or define a helper with one argument
04:54:25 <b_jonas> or mapM on the (->)[Int] monad
04:54:39 <b_jonas> you want to pass the same [Int] to each invocation, right?
04:54:46 <b_jonas> or something more complicated?
04:54:51 <mib_efpcpmsk> what is invocation?
04:55:20 <b_jonas> I mean you call writeCell multiple times
04:55:28 <b_jonas> with different second arguments
04:55:34 <b_jonas> but do you want the first argument to be the same?
04:56:19 <mib_efpcpmsk> b_jonas http://hpaste.org/11058#a8
04:57:23 <mib_efpcpmsk> i need some kind of higher order function to be used in there , because i realised that higher order function makes it loops for a list
04:57:29 <b_jonas> > map ((++) "foo") ["bar", "qux"]
04:57:30 <lambdabot>   ["foobar","fooqux"]
04:57:35 <b_jonas> > mapM (++) ["bar", "qux"] "foo"
04:57:37 <lambdabot>   ["barfoo","quxfoo"]
04:58:34 <mib_efpcpmsk> > mapM (++) ["bar", "qux"] ["bar", "qux","app"]
04:58:36 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
04:58:52 <mib_efpcpmsk> > :t mapM
04:58:52 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 8}
04:58:53 <lambdabot>  ...
04:58:53 <int-e> liftM2
05:00:00 <b_jonas> so don't you want just `writeRow spaces strings = map (writeCell spaces) strings' or soemthing?
05:01:40 <mib_efpcpmsk> oh
05:03:29 <mib_efpcpmsk> *** Does not match : [Char]
05:03:40 <mib_efpcpmsk> *** Type           : [[Char]]
05:03:48 <mib_efpcpmsk> how do i read the error message?
05:04:38 <int-e> [Char] is String
05:04:38 <mauke> you used an expression of type [[Char]] in a context that expects a [Char]
05:04:40 <Arnar_> hey all..
05:04:49 <mib_efpcpmsk> hi arnar
05:04:58 <mib_efpcpmsk> thanks mauke
05:04:59 <mauke> or equivalently, [String] where String was expected
05:05:12 <Arnar_> quick question: is this only a question of style or also performance? --> reverse . map (3*) . filter odd $ [1..10]   vs.  reverse $ map (3*) $ filter odd $ [1..10]
05:05:41 <mauke> style
05:05:55 <Arnar_> mauke: ok, thanks
05:06:24 <mauke> :t mapMaybe (\x -> if odd x then Just x else Nothing)
05:06:26 <lambdabot> forall a. (Integral a) => [a] -> [a]
05:06:27 <mib_efpcpmsk> b_jonas: map does not work
05:09:25 <mib_efpcpmsk> @hoogle [[String]] -> [String]
05:09:26 <lambdabot> Prelude unlines :: [String] -> String
05:09:26 <lambdabot> Prelude unwords :: [String] -> String
05:09:26 <lambdabot> Data.List unlines :: [String] -> String
05:09:49 <mauke> :t concat
05:09:50 <lambdabot> forall a. [[a]] -> [a]
05:10:01 <mib_efpcpmsk> thanks mauke
05:10:07 <mib_efpcpmsk> trying to figure out which function does that
05:10:45 <mib_efpcpmsk> but
05:10:50 <mib_efpcpmsk> it does not solve my problem
05:11:01 <mib_efpcpmsk> it actually makes the whole list of string within the list joins together
05:11:17 <mib_efpcpmsk> i wanted to extract 1 part of a list within a list to feed into my function
05:12:00 <mib_efpcpmsk> [[abc],[def],[ghi]] >> im currently finding a function to extract [abc] first and feed into my function, and auto loop, by feeding the next list and so on
05:12:23 <mauke> map
05:12:24 <mib_efpcpmsk> mauke do you know any in built function that allows extraction?
05:12:40 <mauke> that's what map does
05:13:03 <mib_efpcpmsk> but map requires some kind of function + a list
05:13:14 <mauke> which is what you just said you have
05:13:59 <mib_efpcpmsk> writeRow spaces strings = map (writeCell spaces a) (a:strings) ++ "\n"
05:14:06 <mib_efpcpmsk> writeRow spaces strings = map (writeCell spaces a) (a : strings) ++ "\n"
05:14:19 <mauke> what is 'a' there?
05:14:22 <mib_efpcpmsk> how do i throw the element a into my function?
05:14:33 <mauke> map (writeCell spaces) strings
05:14:38 <mib_efpcpmsk> a indicates 1 element from string and placed into writeCell that takes in 2 arguments
05:14:46 <mib_efpcpmsk> i tried that but it comes out an error
05:14:57 <mauke> yes, because of the ++ "\n"
05:15:08 <b_jonas> map and then concat
05:15:10 <mib_efpcpmsk> why the ++ \n cause the error?
05:15:20 <mauke> what does writeCell return?
05:15:20 <eu-prleu-peupeu> hello people from planet haskell
05:15:23 <b_jonas> like concat (map (writeCell spaces) strings) maybe
05:16:49 <mib_efpcpmsk> umm maybe is a function or something else?
05:18:15 <b_jonas> no, that's just english
05:18:27 <b_jonas> the expression is `concat (map (writeCell spaces) strings'
05:18:30 <b_jonas> without the quotes
05:18:39 <b_jonas> I'm saying maybe because that too might not be what you want
05:21:35 <mib_efpcpmsk> ok thanks b_jonas
05:21:45 <mib_efpcpmsk> because i saw somewhere in haskell, maybe is also a function
05:21:59 <vixey> :t Maybe
05:22:00 <vixey> :t maybe
05:22:00 <lambdabot> Not in scope: data constructor `Maybe'
05:22:01 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
05:22:03 <b_jonas> yeah, my statement was  confusing
05:22:09 <vixey> :k Maybe
05:22:10 <vixey> :k maybe
05:22:10 <lambdabot> * -> *
05:22:11 <lambdabot> Not in scope: type variable `maybe'
05:22:17 <Botje> both maybe and Maybe are functions *runs*
05:22:48 <b_jonas> why does it say it's not in scope? it's in the prelude
05:22:52 <b_jonas> :t Maybe 1
05:22:53 <lambdabot> Not in scope: data constructor `Maybe'
05:22:58 <vixey> there are 3 scopes in haskell
05:23:03 <b_jonas> > Maybe 1
05:23:04 <lambdabot>   Not in scope: data constructor `Maybe'
05:23:15 <b_jonas> oh, I see
05:23:20 <vixey> maybe I should 2 scopes
05:23:21 <b_jonas> it's a tycon, not a constructor
05:23:25 <vixey> anyway, values :: types :: kinds
05:23:30 <b_jonas> eek
05:23:43 <b_jonas> I'll just assume kinds don't have a scope
05:23:50 <b_jonas> a namespace that is
05:24:11 <vixey> well I think there's some extension for putting names into the kind space
05:24:18 <vixey> but we can probably ignore that
05:24:55 <b_jonas> you could say there are four scopes though because there are two flat ones (constructors and tycons) and two real nesting scopes (variables and type variables but the latter only as a ghc extension)
05:25:44 <b_jonas> @kind (->)
05:25:45 <lambdabot> ?? -> ? -> *
05:25:57 <b_jonas> after this I'm not so surprised there are extensions to kinds
05:26:06 <b_jonas> but I hope that's only for unboxed types and stuff like those
05:35:54 <besiria> what is an unboxed type?
05:36:09 <b_jonas> besiria: I don't want to know. it's something needed for the internals of ghc to work.
05:36:57 <thoughtpolice> besiria: you mean like Int# or something?
05:37:23 <besiria> thoughtpolice: i don't really know. that's why i'm asking
05:37:55 <thoughtpolice> besiria: an unboxed value is a strict value; with lazy evaluation you have 'boxed' values which correspond to a thunk you can force
05:38:18 <thoughtpolice> with things like strictness analysis you can determine where certain boxed values should be in fact, unboxed.
05:38:46 <mauke> http://arcanux.org/lambdacats/boxed.jpg
05:39:18 <thoughtpolice> besiria: for example, you have regular (lazy) Ints and then you have unboxed Ints which are represented by the type 'Int#' - Int#'s are just strict versions
05:39:33 <thoughtpolice> naturally unboxed values are nice for speed
05:40:10 <besiria> and !Int is unboex too?
05:40:38 <besiria> unboxed*
05:41:11 <thoughtpolice> never seen '!Int' :]
05:41:55 <int-e> thoughtpolice: data Foo = Foo !Int !Int -- never seen that?
05:42:00 <Saizan> you can have data Foo = Foo !Int, which means that the Int is forced whenever the Foo constructor is
05:42:23 <Saizan> so in that case the Int can be unboxed
05:42:28 <mauke> funboxed!
05:42:29 <int-e> besiria: anyway, it's not unboxed per se. But the compiler may unbox it as an optimization
05:43:13 <besiria> thoughtpolice: i mean the bang patterns
05:48:15 <skorpan> how come ghc is 250 MB?
05:48:38 <mauke> efficient compression algorithms
05:48:44 <skorpan> :P
05:52:20 <mib_efpcpmsk> hmm
05:52:44 <b_jonas> skorpan: two things, the extralibs and libraries compiled for profiling
05:52:54 <mib_efpcpmsk> hey guys, how do i total up the value in the list? [1,2,3] = 1+2+3
05:52:59 <b_jonas> if you don't compile the profiling versions you get only 200M on x86
05:53:10 <mib_efpcpmsk> map (+) [1,2,3]?
05:53:21 <b_jonas> with the extralibs
05:53:40 <ziman> @src foldr
05:53:40 <lambdabot> foldr f z []     = z
05:53:40 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:53:53 <vixey> mib_efpcpmsk:  sum
05:53:54 <b_jonas> catawhat?
05:55:50 <therp> shared libraries are on its way
05:55:59 <therp> s/its/their/
05:57:01 <thomashartman1> now that the bytestring interface has changed, what should I do instead of .... > hGetContentsWithCursorN k h start = (lazyRead start) >>= return . LPS
05:57:07 <thomashartman1> (no more LPS apparently)
05:57:43 <Saizan> fromChunks ?
06:00:06 <thomashartman1> saizan: thanks, at least it compiles now. I'm trying to cabalize Benjamin Midfield's external sort
06:02:18 <Philonous1> >foldr1 (.) ([id,id,id] ++ [id,id]) $ 2
06:02:32 <b_jonas> space after the angle
06:02:38 <Philonous1> > foldr1 (.) ([id,id,id] ++ [id,id]) $ 2
06:02:39 <lambdabot>   2
06:02:44 <Philonous1> k, thanks
06:02:51 <opqdonut> :)
06:03:19 <b_jonas> or there's @run
06:03:27 <opqdonut> > appEndo (msum . map Endo ([id,id,id] ++ [id,id])) 2
06:03:28 <lambdabot>   Couldn't match expected type `a -> [m a1]'
06:03:36 <b_jonas> the long form is needed if you want to use it in @@ or @?
06:04:42 <opqdonut> > appEndo (mconcat $ map Endo ([id,id,id] ++ [id,id])) 2
06:04:44 <lambdabot>   2
06:04:45 <opqdonut> :)
06:06:13 <mib_efpcpmsk> > :t sum
06:06:13 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 8}
06:06:13 <lambdabot>  ...
06:06:22 <mib_efpcpmsk> @sum
06:06:23 <lambdabot> Maybe you meant: bug run src
06:06:27 <kpreid> :t sum
06:06:29 <lambdabot> forall a. (Num a) => [a] -> a
06:06:29 <ziman> @hoogle Endo
06:06:30 <lambdabot> Data.Monoid newtype Endo a
06:06:30 <lambdabot> Data.Monoid Endo :: a -> a -> Endo a
06:06:30 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
06:06:32 <b_jonas> so does "regular" in http://www.willamette.edu/~fruehr/haskell/evolution.html#categorical refers to that it doesn't work with this polymorphic recursion thing?
06:06:34 <lambdabot> Title: The Evolution of a Haskell Programmer, http://tinyurl.com/3swhu
06:06:36 <b_jonas> that makes sense
06:06:41 <kpreid> > sum [1,2,3]
06:06:42 <lambdabot>   6
06:06:49 <mib_efpcpmsk> my god
06:06:50 <mauke> preflex: seen ndm
06:06:50 <preflex>  ndm was last seen on #xmonad 43 days, 20 hours, 32 minutes and 37 seconds ago, saying: cool :)
06:06:55 <mib_efpcpmsk> sthanks kpreid
06:07:01 <mib_efpcpmsk> yipee
06:07:28 <mib_efpcpmsk> kinda funny, have not practised haskell , and i forgot about sum[1,2,3]
06:07:33 <mib_efpcpmsk> -_- "
06:14:52 <mib_efpcpmsk> wow quiet here
06:15:01 <mauke> preflex: quote
06:15:01 <preflex>  <mdxi> womens clothing sizes and bistromathematics are very closely-related branches of number theory
06:15:51 <mib_efpcpmsk> mauke whats up?
06:18:58 <rook> is there a function which can search a list of chars for occurrences of a string?
06:19:05 <rook> elemIndices for strings or so?
06:19:36 <ddarius> :t isInfixOf
06:19:37 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
06:19:56 <rook> i need the position of the string also
06:20:06 <thomashartman1> rook: cabal install pcre-regex
06:20:33 <rook> it's for university and there is a very restricted environment
06:21:24 <thomashartman1> rook: I think parsec also gives you position of the current match. not sure though.
06:21:30 <ddarius> There should be a regex library distributed with GHC
06:21:57 <ddarius> Failing that, changing the (relatively naive) source for isInfixOf to return locations would be very easy
06:22:25 <thomashartman1> ddarius: there is, but I've found it lacks a lot of stuff I need so I usually use pcre. it might bo what rook needs though.
06:23:06 <rook> ddarius: is this library also distributed with hugs? we have to use hugs
06:23:21 <mauke> ah, so speed doesn't matter anyway?
06:23:21 <ddarius> I don't know.
06:23:24 <rook> sorry for the dumb questions, just started with huskell yesterday
06:23:40 <ddarius> @src isInfixOf
06:23:41 <lambdabot> isInfixOf needle haystack = any (isPrefixOf needle) (tails haystack)
06:23:43 <rook> mauke, it shouldn't take longer than 5 seconds, but the function is very short
06:24:05 <thomashartman1> rook: I think parsec definitely works on hugs
06:24:34 <rook> tanks thomashartman1, i'll try that, and isInfixOf also
06:25:19 <mauke> :t \needle haystack -> findIndices (needle `isPrefixOf`) (tails haystack)
06:25:20 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [Int]
06:25:24 <mauke> ta da
06:25:39 <thomashartman1> hey, anybodyy here ever sorted a billion element list, with haskell or anything else? I'm trying to do this using external sort, code for which was posted to haskell cafe by ben midfield a while back
06:25:56 <thomashartman1> so far it's been running on my crappy little laptop for five minutes or so
06:26:29 <thomashartman1> at least it hasn't hogged all my ram like prelude sort would, so I can still irc :)
06:26:52 <mauke> > (\needle haystack -> findIndices (needle `isPrefixOf`) (tails haystack)) "wh" "where why what"
06:26:53 <lambdabot>   [0,6,10]
06:27:26 <thomashartman1> @src findIndices
06:27:27 <lambdabot> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
06:27:36 <thomashartman1> @info findIndices
06:27:36 <lambdabot> findIndices
06:27:38 <rook> thanks, will try that
06:28:24 <ddarius> I was about to write out exactly that list comprehension with the relevant thing substituted when mauke wrote his solution.
06:28:43 <ddarius> (except I switched the order of the tuple)
06:31:28 <ddarius> @unpl ap findIndices isPrefixOf . tails
06:31:29 <lambdabot> (\ c -> (findIndices >>= \ e -> isPrefixOf >>= \ d -> return (e d)) (tails c))
06:32:34 <mauke> :t ap findIndices isPrefixOf . tails
06:32:35 <lambdabot>     Couldn't match expected type `a -> Bool'
06:32:36 <lambdabot>            against inferred type `[a1]'
06:32:36 <lambdabot>     Probable cause: `isPrefixOf' is applied to too few arguments
06:32:54 <mauke> you shouldn't even need ap here
06:33:01 <mauke> just lots of . and flip
06:33:18 <rook> mauke: i'm sorry, but i really have no clue
06:33:45 <mauke> about what?
06:33:46 <rook> http://hpaste.org/11073 thats how far i came until now :(
06:33:59 <rook> how do i implement the source you posted above?
06:34:38 <mauke> ersetze e s = findIndices (s `isPrefixOf`) (tails e)
06:35:30 <rook> wow, thanks a lot mauke
06:42:49 <vixey> ?djinn ((u -> o) -> (v -> o)) -> (v -> u)
06:42:49 <lambdabot> -- f cannot be realized.
06:42:55 <vixey> ?djinn (v -> u) -> ((u -> o) -> (v -> o))
06:42:56 <lambdabot> f a b c = b (a c)
06:43:12 <vixey> huh why does it only work in one direction
06:43:57 <ddarius> vixey: It's the scope of the forall
06:43:57 <vixey> grrr :(
06:44:19 <vixey> ?djinn ((u -> ()) -> (v -> ())) -> (v -> u)
06:44:19 <lambdabot> -- f cannot be realized.
06:44:27 <Saizan> no
06:44:30 <vixey> is there a name for this thing?
06:44:37 <Saizan> yoneda lemma?
06:44:46 * vixey has called too many thing swizzler already
06:44:46 <vixey> oh really??
06:44:46 <ddarius> What it looks like you are trying to get at is a corollary to the Yoneda lemma
06:44:51 <vixey> cool!
06:45:11 <Saizan> (forall o. (u -> o) -> (v -> o)) -> (v -> u)
06:45:38 <Saizan> that "can be realized"
06:46:22 <ddarius> Namely as \f -> f id
06:47:48 <adekoba> I'm parsing ID3 tags with the binary package using separate constructors for both of the ID3v2.3 and ID3v2.4 versions. Much of the structure is the same for each, only one small difference. Is there a way to reuse code between the two instances?
06:48:05 <ddarius> Sure
06:48:16 <vixey> why does Yoneda lemma naturally occur?
06:48:29 <ddarius> Define "naturally occur"?
06:48:59 <adekoba> ddarius: what would be the best method?
06:49:31 <vixey> I mean which sort of cases can this situation appear
06:49:32 <ddarius> adekoba: Write a function parameterized on the difference, then write both instances in terms of that function.
06:50:19 <dino-> I have a cabal-install question. Can I instruct cabal-install to use a locally available .tar.gz instead of going out to get it from the network?
06:50:38 <dino-> I mean, I'm working on something of my own, and I'd like to test the install against the .tar.gz I just built here.
06:51:15 <adekoba> ddarius: right now, I've made binary instances for each subpart, then in each major instance, used those sub-instances... It's just that I would need to make two different instances for the parsing difference, and as far as I can tell, that's impossible
06:51:25 <ddarius> vixey: That particular special case you listed occurs constantly in CT.  It is very common to prove that Hom(A,-) ~ Hom(B,-) and via Yoneda that means A ~ B (or vice versa)
06:51:44 <adekoba> ddarius: so for a parameter, I would use a bool?
06:51:53 <dino-> Is this what --package-db is for?
06:51:54 <ddarius> vixey: Yoneda is the connection between the "representability" style of definition/proof and the universal arrow style.
06:51:56 <vixey> hmmm
06:52:22 <ddarius> adekoba: You'd just directly abstract out whatever is different.
06:53:29 <adekoba> ddarius: hm, not sure what you mean by "abstract out". You mean not exporting the constructor for the subpart?
06:53:44 <ddarius> I mean use a lambda abstraction.
06:54:09 <vixey> type WhatMayThisBeCalled e o = (e -> o) -> o
06:54:23 <vixey> @src Cont
06:54:23 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
06:54:23 <vixey> :t Cont
06:54:23 <lambdabot> forall a r. ((a -> r) -> r) -> Cont r a
06:54:35 <vixey> so what does Yoneda Lema have to do with Cont?
06:54:45 <adekoba> ddarius: ok. Thanks.
06:56:35 <mib_efpcpmsk> hey guys
06:56:42 <mib_efpcpmsk> i have a problem
06:56:42 <mib_efpcpmsk> if i have 2 list [1,2] and [1,2,3,4,5]
06:56:49 <mib_efpcpmsk> how do i make the 2nd list same as the first list?
06:57:03 <b_jonas_> huh?
06:57:10 <vixey> > zip [1,2] [1,2,3,4,5]
06:57:10 <lambdabot>   [(1,1),(2,2)]
06:57:10 <vixey> > map fst (zip [1,2] [1,2,3,4,5])
06:57:10 <lambdabot>   [1,2]
06:57:16 <vixey> > map snd (zip [1,2] [1,2,3,4,5])
06:57:19 <mib_efpcpmsk> the first list is the selection, i select 1 and 2 out of 1,2,3,4,5
06:57:19 <lambdabot>   [1,2]
06:57:19 <Axman6> f xs ys = xs >_>
06:57:33 <rook> how can i extract an Int out of an [Int]? i have the position of the element in the list
06:57:40 <thomashartman1> rook: !!
06:57:48 <Axman6> rook: xs !! pos
06:57:52 <rook> thank you
06:57:58 <mib_efpcpmsk> hi axman
06:58:01 <mib_efpcpmsk> hi axman6
06:58:06 <mib_efpcpmsk> i got your code right :)
06:58:11 <mib_efpcpmsk> its working fine now
06:58:16 <Axman6> (y)
06:58:20 <ivanm> mib_efpcpmsk: what's the next item in the sequence? ;-)
06:58:27 <mib_efpcpmsk> (y) << means?
06:58:45 <Axman6> ah, msn thing, it's a thumbs up
06:58:47 <mib_efpcpmsk> ivanm: huh?
06:58:47 <thomashartman1> mib: I think you just want drop, maybe with reveerse
06:58:47 <mib_efpcpmsk> ivanm: what do you mean?
06:58:49 <mib_efpcpmsk> axman6: oh,
06:58:53 <thomashartman1> @1+2
06:58:53 <lambdabot> Unknown command, try @list
06:58:57 <Japsu> heh, msn
06:58:59 <thomashartman1> how do execute a command again?
06:59:15 * Japsu would use d_(^_____^)_b
06:59:20 <Axman6> > a + b
06:59:34 <lambdabot>   a + b
06:59:47 <Axman6> Japsu: heh, i like it
07:00:16 <Japsu> these asiatic emoticons are way more expressive ;)
07:02:08 <thomashartman1> 1+2
07:02:31 <Axman6> thomashartman1: >
07:02:54 <thomashartman1> > 1+2
07:03:15 <lambdabot>   3
07:03:18 <ddarius> vixey: The dual form of the actual Yoneda lemma states: Nat(Hom(A,-), F) ~ FA natural in A, let F = Id, you get Nat(Hom(A,B), B) -> B natural in A and B
07:03:18 <mib_efpcpmsk> :t smd
07:03:18 <lambdabot> Not in scope: `smd'
07:03:18 <mib_efpcpmsk> :t snd
07:03:18 <lambdabot> forall a b. (a, b) -> b
07:03:18 <mib_efpcpmsk> can someone explain how snd works?
07:03:18 <mib_efpcpmsk> it just selects the second one?
07:03:18 <Axman6> snd (x,y) = y
07:03:18 <mauke> @src snd
07:03:18 <lambdabot> snd (_,y) =  y
07:03:18 <ddarius> vixey: You may also want to look at: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Yoneda.html
07:03:18 <lambdabot> Title: Control.Functor.Yoneda, http://tinyurl.com/436p4v
07:04:05 <thomashartman1> > take 2 [1,2,3,4,5]
07:04:25 <lambdabot>   [1,2]
07:04:40 <thomashartman1> mib: that what you want?
07:05:02 <mib_efpcpmsk> umm
07:06:52 <mib_efpcpmsk> not exactly
07:07:29 <mib_efpcpmsk> lets say if i created a list for selection [1,5] and my second list is [1,2,3,4,5], i want to remove 2,3,4 and create a new list [1,5]
07:07:45 <mauke> why not just take the selection list?
07:07:46 <mauke> foo x y = x
07:07:46 <ddarius> er the last B should be an A (and technically the Nat should be a Hom in the latter case)
07:08:07 <mib_efpcpmsk> umm my second list is actually a table
07:08:10 <thomashartman1> mib: just use index
07:08:10 <mib_efpcpmsk> index?
07:08:10 <mauke> define "table"
07:08:10 <thomashartman1> !!
07:08:10 <mib_efpcpmsk> table with lots of list in it..
07:08:10 <Axman6> thomashartman1: ?
07:08:10 <mauke> define "table"
07:08:10 <mib_efpcpmsk> so if a user says i want [1,2] so my table just shows [1,2] and not [1,2,3,4,5]
07:08:10 <mib_efpcpmsk>  if a user says i want [2,5] so my table just shows [2,5] and not [1,2,3,4,5]
07:08:10 <vixey> I don't really understand that dual form ddarius
07:08:10 <Axman6> ok, my phone is officially awesome. the word moonshit is in its dictionary, and i didn't add it
07:08:10 <thomashartman1> > [ [1,2,3,4,5] !! 1, [1,2,3,4,5] !! 5 ]
07:08:10 <mauke> mib_efpcpmsk: you're not making any sense
07:08:10 <lambdabot>   [2,* Exception: Prelude.(!!): index too large
07:08:10 <thomashartman1> > [ [1,2,3,4,5] !! 0, [1,2,3,4,5] !! 4 ]
07:08:10 <lambdabot>   [1,5]
07:08:10 <Axman6> mib_efpcpmsk: can't you just show [2,5] then? :\
07:08:32 <mib_efpcpmsk> [2,5] is the selection
07:08:53 <mib_efpcpmsk> just like a GUI
07:09:12 <mib_efpcpmsk> and i need to form a new table with only 2 and 5  by using the old table
07:09:15 <Axman6> you need to explain what you want more clearly i think
07:09:15 <ddarius> In Haskell-speak: forall a. Functor f => (forall b. (a -> b) -> f b)) ~ f a
07:09:15 <mauke> mib_efpcpmsk: you're still not making any sense
07:09:15 <Axman6> why do you need to use the old table at all?
07:09:16 <thomashartman1> > [ [1,2,3,4,5] !! 1, [1,2,3,4,5] !! 4 ]
07:09:16 <lambdabot>   [2,5]
07:09:16 <b_jonas> Axman6: their dictionary are heavily compressed, the requirements is only that it has all real words in frequency order before any non-existing word for any digit sequence, not that it doesn't have non-real words
07:09:16 <Axman6> thomashartman1: that's pretty disguating :\
07:09:16 <thomashartman1> sowwy
07:09:16 <mib_efpcpmsk> the old table has all the fields, [1,2,3,4,5] as in [color, brightness, etc, fields], so the user just want to see specific fields in the table
07:09:16 <mib_efpcpmsk> is that easy to understand?
07:09:16 <thomashartman1> > let l = [1,2,3,4,5] in [l !!1, l!!4]
07:09:16 <lambdabot>   [2,5]
07:09:16 <Axman6> b_jonas: yes, it does does seem to think that 37 js is a word...
07:09:18 <thomashartman1> :t 1
07:09:18 <lambdabot> forall t. (Num t) => t
07:09:18 <thomashartman1> :t map (!!) [1,4]
07:09:18 <ddarius> > zipWith (!!) (repeat [1,2,3,4,5]) [1,4]
07:09:18 <lambdabot> forall a. (Num [a]) => [Int -> a]
07:09:18 <lambdabot>   [2,5]
07:09:18 <thomashartman1> :t \selections map (!!) selections [1,2,3,4,5]
07:09:18 <lambdabot> parse error (possibly incorrect indentation)
07:09:18 <mib_efpcpmsk> mauke: do you understand?
07:09:23 <mauke> I'm not sure
07:09:23 <mauke> why isn't this list a record?
07:09:23 <mib_efpcpmsk> axman6: you understand?
07:09:23 <Axman6> mib_efpcpmsk: sounds like an array would be helpful. let arr = array (0,10) [0..10] in (arr ! 2, arr ! 5)
07:09:23 <thomashartman1> let l = [1,2,3,4,5], selections = [1,4] in selections
07:09:23 <Axman6> i think i do now
07:09:23 <Axman6> maybe
07:09:48 <thomashartman1> > let l = [1,2,3,4,5], selections = [1,4] in selections
07:10:02 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 27}
07:10:05 <lambdabot> ...
07:10:15 <thomashartman1> > let l = [1,2,3,4,5]; selections = [1,4] in selections
07:10:20 <lambdabot>   [1,4]
07:10:33 <Axman6> > array (0,25) ['a'..'z']
07:10:48 <lambdabot>   Couldn't match expected type `(t, e)' against inferred type `Char'
07:11:41 <Axman6> :\
07:11:59 <mib_efpcpmsk> mauke: its like this, i have a table with many fields, example: name, age, gender, ocupation, birthdate, etc, the user selects only name and age, so the table only displays the contents of name and age
07:12:44 <thomashartman1> > let l = [1,2,3,4,5]; selections = [1,4] in ( map (!!) selections ) l
07:13:52 <lambdabot>   Couldn't match expected type `t1 -> t'
07:14:37 <mauke> mib_efpcpmsk: yes. why is your "table" represented by a list?
07:17:40 <mauke> wait, it can't be
07:45:00 <dino-> I guess the more general question is: can I have the cabalized something .tar.gz downloaded first, and instruct cabal-install to install that, not go get it from the network.
07:45:00 <mib_efpcpmsk> mauke: my table has many lists
07:45:00 <thomashartman1> > let l = [1,2,3,4,5]; selections = [1,4] in ( map (\s -> (!!s)) selections ) l
07:45:00 <lambdabot>   Couldn't match expected type `t1 -> t'
07:45:00 <mauke> you can't store name and age in the same list
07:45:00 <Axman6> this is why i think he needs an array
07:45:00 <mauke> Axman6: arrays are homogenous too
07:45:00 <mib_efpcpmsk> mauke : my table has many list >>>> "many"
07:45:00 <Axman6> mauke: you could if you defined a datatype to do so
07:45:00 <mauke> mib_efpcpmsk: so?
07:45:00 <b_jonas> wait, four arrows?
07:45:00 <mib_efpcpmsk> that list is just to define the fields, the other list are for contents and others
07:45:00 <thomashartman1> :t let l = [1,2,3,4,5]; selections = [1,4] in ( map (!!) selections)
07:45:00 <lambdabot> forall a. (Num [a]) => [Int -> a]
07:45:00 <ddarius> dino-: If you type 'cabal install' in a directory containing a .cabal file, that gets installed.
07:45:01 <Axman6> > map (!!) [1..5]
07:45:01 <lambdabot>       Overlapping instances for Show (Int -> a)
07:45:01 <lambdabot>        arising from a use of ...
07:45:01 <Axman6> > map (!!) [1..5] :: Expr
07:45:01 <lambdabot>   Couldn't match expected type `Expr'
07:45:01 <mauke> mib_efpcpmsk: I have serious doubts regarding the sanity of your data structure
07:45:01 <b_jonas> flip
07:45:01 <Axman6> > map (!!) [1..5] :: [Expr]
07:45:01 <lambdabot>   Couldn't match expected type `Expr'
07:45:01 <thomashartman1> map (!!) [1..5] :: [Int] -> Int
07:45:01 <mib_efpcpmsk> mauke : its pretty easy to understand, >> the only thing now is i just want to know how to select :)
07:45:01 <thomashartman1> :t map (!!) [1..5] :: [Int] -> Int
07:45:01 <Axman6> yoy fail lambdabot, you know that?
07:45:01 <Axman6> u*
07:45:01 <lambdabot>     Couldn't match expected type `[Int] -> Int'
07:45:01 <lambdabot>            against inferred type `[Int -> a]'
07:45:01 <b_jonas> > map ((!!) "abcde") [1, 3]
07:45:01 <lambdabot>   "bd"
07:45:01 <mauke> whatever
07:45:01 <thomashartman1> ya know what, I miss ghci :)
07:45:01 <dino-> ddarius: ok, so if you did want to install something you downloaded first, you must unpack and do from within its root.
07:45:01 <mib_efpcpmsk> user selects specific fieldds [name, age] from table that has these fields [name, age, gender, ocupation, birthdate]
07:45:01 <ddarius> dino-: Yes
07:45:01 <mauke> preflex: ? .my
07:45:01 <preflex>  Malaysia
07:45:01 <dino-> But no switch a-la Debian's dpkg -i
07:45:02 <ddarius> dino-: I don't know.  I don't think so for the version of cabal-install I have, but maybe the newer version has such a thing (or maybe I'm just missing it)
07:45:02 * Axman6 goes to sleep
07:45:02 <Axman6> night all
07:45:02 <ivanm> dino-: you have to realise something that dcoutts explained to me when I complained about something in cabal-install... it's still new!
07:45:02 <mib_efpcpmsk> night axman6
07:45:02 <ivanm> cya Axman6
07:45:02 <dino-> ivanm: no no, I understand. I'm just trying to figure out if I should stop looking for what I'm looking for.
07:45:02 * Axman6 highfives ivanm with regard to RWH purchase
07:45:02 <ivanm> yup
07:45:02 <ivanm> heh
07:45:02 <ivanm> not till december though :(
07:45:02 <Axman6> yeah :(
07:45:02 <kohwj> hm, wxhaskell looks more active than qthaskell
07:45:02 <Axman6> but... i have like two months off uni then :d
07:45:03 <thomashartman1> l = [1,2,3,4,5]
07:45:03 <thomashartman1> selections = [1,4]
07:45:03 <thomashartman1> getsel t s = t !! s
07:45:03 <thomashartman1> t = map (getsel l ) selections
07:45:03 <thomashartman1> t does what mib wants.
07:45:03 <b_jonas> > map (BSC.ref (BSC.pack "abcde")) [1, 3]
07:45:03 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
07:45:03 <dino-> ddarius, ivanm: thank you
07:45:03 <b_jonas> > map (BSC.elem (BSC.pack "abcde")) [1, 3]
07:45:03 <thomashartman1> guess playing pingpong with lambdabot just doesn't work for me
07:45:03 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
07:45:03 <b_jonas> > BS.empty
07:45:03 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
07:45:03 <Axman6> b_jonas: you're not wearing enough protection
07:45:03 <b_jonas> so Data.ByteString is imported under a short alias but you can't use it?
07:45:03 <mib_efpcpmsk> thomashartman1 : i'll try out your code :)
07:45:03 <mib_efpcpmsk> oh yeah, just wandering, what does !! means? the double exclamation mark
07:45:03 <b_jonas> I like the 'getsel t s = t !! s' part
07:45:03 <mauke> @src (!!)
07:45:03 <lambdabot> xs     !! n | n < 0 = undefined
07:45:03 <lambdabot> []     !! _         = undefined
07:45:03 <lambdabot> (x:_)  !! 0         = x
07:45:03 <lambdabot> (_:xs) !! n         = xs !! (n-1)
07:45:03 <mib_efpcpmsk> a newbie example of how to use !! ?
07:45:03 <vixey> first you look at the type
07:45:03 <vixey> :t (!!)
07:45:03 <lambdabot> forall a. [a] -> Int -> a
07:45:03 <vixey> and you see that it takes a list of some a's
07:45:03 <vixey> :t [3,5,6,8,4,5]
07:45:03 <lambdabot> forall t. (Num t) => [t]
07:45:03 <vixey> and it takes an int, index into the list, ei.  3 :: Int
07:45:03 <vixey> so what is the type of  [3,5,6,8,4,5] !! 3 ?
07:45:03 <vixey> :t [3,5,6,8,4,5] !! 3
07:45:03 <lambdabot> forall t. (Num t) => t
07:45:03 <mib_efpcpmsk> type a
07:45:03 <vixey> > oaue
07:45:03 <lambdabot>   Not in scope: `oaue'
07:45:03 <vixey> > [3,5,6,8,4,5] !! 3
07:45:03 <vixey> yeah
07:45:03 <lambdabot>   8
07:45:04 <mib_efpcpmsk> > ["apple","pear", "orange","grape","yoghurt"] !! 3
07:45:04 <lambdabot>   "grape"
07:45:04 <vixey> 0 is the start
07:45:04 <mib_efpcpmsk> oh
07:45:04 <mib_efpcpmsk> so a list is an array?
07:45:04 <vixey> no
07:45:04 <vixey> > ["zero", "one", "two", "..."]
07:45:04 <mib_efpcpmsk> array starts with zero right?
07:45:04 <lambdabot>   ["zero","one","two","..."]
07:45:04 <vixey> > ["zero", "one", "two", "..."] !! 0
07:45:04 <vixey> > ["zero", "one", "two", "..."] !! 1
07:45:04 <lambdabot>   "zero"
07:45:04 <vixey> > ["zero", "one", "two", "..."] !! 2
07:45:04 <lambdabot>   "one"
07:45:04 <lambdabot>   "two"
07:45:04 <mauke> mib_efpcpmsk: no
07:45:04 <vixey> it's  not the LIST that starts at 0
07:45:04 <vixey> it's !!
07:45:04 <Axman6> > map ((!!) [1,2,3,4,5]) [0..4]
07:45:04 <lambdabot>   [1,2,3,4,5]
07:45:04 <mib_efpcpmsk> example of an array?
07:45:04 <mib_efpcpmsk> i always thought that list is an array
07:45:04 <vixey> no list and array are different
07:45:04 <mib_efpcpmsk> vixey: example?
07:45:04 <mauke> > array ('a', 'd') [('a', 10), ('c', 20), ('d', 30), ('b', 1000)]
07:45:04 <vixey> I don't know what you're asking
07:45:04 <lambdabot>   array ('a','d') [('a',10),('b',1000),('c',20),('d',30)]
07:45:04 <Axman6> arrays are quite a bit more complicated than lists
07:45:04 <mauke> there's an array with indices from 'a' to 'd'
07:45:04 <mauke> > array ('a', 'd') [('a', 10), ('c', 20), ('d', 30), ('b', 1000)] ! 'b'
07:45:04 <lambdabot>   1000
07:45:04 <mib_efpcpmsk> vixey: mib_efpcpmsk example of an array?
07:45:04 <vixey> what
07:45:04 <mib_efpcpmsk> i stated the quesiotn above, example of array?
07:45:04 <vixey> good bye
07:45:04 <mauke> mib_efpcpmsk: that's not a question
07:45:04 <mauke> mib_efpcpmsk: that's a bunch of words with a question mark at the end
07:45:04 <mib_efpcpmsk> how do you define a question?
07:45:04 <mauke> heh
07:45:04 <mib_efpcpmsk> ? << question
07:45:05 <vixey> @src Monad Cont
07:45:05 <lambdabot> Source not found. :(
07:45:05 <Axman6> ha
07:45:05 <vixey> @src Cont return
07:45:05 <lambdabot> return a = Cont ($ a)
07:45:05 <vixey> @src Cont >>=
07:45:05 <lambdabot> Source not found. There are some things that I just don't know.
07:45:05 <vixey> @src Cont (>>=)
07:45:05 <lambdabot> m >>= k  = Cont $ \c -> runCont m $ \a -> runCont (k a) c
07:45:05 <vixey> :t runCont
07:45:05 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
07:45:05 <Axman6> mib_efpcpmsk: the prescence of a question doesn;t make it a question
07:45:05 <vixey> @src Cont
07:45:05 <lambdabot> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
07:45:05 <Axman6> "Hi, my name is Bob?" <-- not a question
07:45:05 <vixey> oh
07:45:05 <mib_efpcpmsk> Axman6 mib_efpcpmsk: the prescence of a question doesn;t make it a question . proof
07:45:05 <vixey> I think there is something very important and very deep in here and I can't see what it is
07:45:05 <vixey> wrt. Yoneda and Cont and all this
07:45:05 <Axman6> question mark*
07:45:05 <b_jonas> Is this a question?
07:45:05 <vixey> I've seen a proof that uses Yoneda lemma and I wonder if it is _possible_ to write it without
07:45:05 <mauke> @keal
07:45:05 <lambdabot> need 1 to do a while 0 does !a. need 1 to do a while 0 does !a
07:45:05 <mib_efpcpmsk> b_jonas Is this a question?  << its a question
07:45:05 <vixey> @KEAL
07:45:05 <lambdabot> Unknown command, try @list
07:45:05 <vixey> @keal
07:45:05 <lambdabot> need 1 to do a while 0 does !a. need 1 to do a while 0 does !a
07:45:05 <vixey> @keal
07:45:05 <lambdabot> T could perform expressions 600mb and bigger
07:45:05 <vixey> I invent T!
07:45:30 <ziman> who is keal?
07:45:30 <Axman6> anyway, sleep time. goodnight all
07:45:30 <mauke> ziman: some crazy guy
07:45:30 <vixey> @keal
07:45:30 <lambdabot> making a bot of me is highly offensive
07:45:30 <vixey> @keal
07:45:30 <lambdabot> the [nsa] even make light green both ways once
07:45:30 <mauke> preflex: be PoppaVic
07:45:30 <preflex>  yeah, but is amazingly issue is, problem: not mine.
07:45:30 <thomashartman1> > map ((!!) [1,5]) [0..4]
07:45:30 <lambdabot>   [1,5,* Exception: Prelude.(!!): index too large
07:45:30 <thomashartman1> > map ((!!) [1,2]) [0..4]
07:45:30 <lambdabot>   [1,2,* Exception: Prelude.(!!): index too large
07:45:30 <kolmodin> is there a cli to hpaste?
07:45:30 <thomashartman1> :q
07:45:30 <mib_efpcpmsk> > map ((!!) [1,2,3,4,5]) [0..4]
07:45:30 <lambdabot>   [1,2,3,4,5]
07:45:30 <mauke> kolmodin: http://mauke.ath.cx/stuff/perl/pastebin
07:45:30 <mib_efpcpmsk> > map ((!!) [1,2,3,4,5]) [0..1]
07:45:30 <lambdabot>   [1,2]
07:45:30 <mib_efpcpmsk> > map ((!!) [1,2,3,4,5]) [1,4]
07:45:30 <lambdabot>   [2,5]
07:45:30 <Axman6> mib_efpcpmsk: there are better ways of doing that
07:45:30 <kohwj> hm.. Gtk2Hs looks impressive.
07:45:30 <Axman6> but i need to sleep, someone else may enlighten you
07:45:30 <kolmodin> mauke: thanks!
07:45:30 <mib_efpcpmsk> thanks axman6
07:45:30 <Axman6> kohwj: think it's the most well supported gui interface for haskell
07:45:30 <kohwj> Axman6: initial googling inicates that that qthaskell < wxhaskell (no wx 2.8 support yet?) < Gtk2Hs
07:45:30 <Axman6> yup
07:45:30 <kohwj> Axman6: aah! only 0.9.12 is in the gentoo repos. well, I'll just install it the old-fashioned way then.
07:45:30 <moshisushi> hello, how do i generate a list of random numbers in haskell?
07:45:30 <mauke> first you get your hands on a RNG
07:45:30 <Pip-chan> It's time
07:45:30 <mauke> e.g. do { rng <- newStdGen; let numbers = randoms rng; ...
07:45:30 <kohwj> moshisushi: http://www.zvon.org/other/haskell/Outputrandom/Random_c.html
07:45:30 <lambdabot> Title: Haskell : Random
07:45:30 <Pip-chan> To learn Haskell
07:45:30 <kohwj> lambdabot is pretty fast.
07:45:30 <kohwj> is it cached?
07:45:30 <Pip-chan> lambdabot, Hi
07:45:30 <Pip-chan> And what's the best Haskell book for newbies ?
07:45:30 <mauke> Gentle Introduction
07:45:30 <mauke> AHAHAHAHA
07:45:30 <vixey> lol
07:45:30 <Pip-chan> :O
07:45:30 <mauke> http://haskell.org/haskellwiki/Books http://haskell.org/haskellwiki/Tutorials
07:45:30 <lambdabot> Title: Books - HaskellWiki
07:45:30 <Pip-chan> thanks
07:45:57 <mauke> http://haskell.org/haskellwiki/Real_World#haskell
07:45:57 <kohwj> mauke: i don't really see the joke- is the Gentle Introduction really rough?
07:45:58 <lambdabot> Title: Real World - HaskellWiki
07:46:02 <mauke> kohwj: yes
07:46:46 <kohwj> mauke: hm.. you're right, it's introducing list comprehensions in the second page
07:48:38 <Pip-chan> How is the OReilly one, real world, just out recently ?
07:48:55 <mauke> delicious (haven't read it, but the authors hang out in this channel)
07:49:57 <Pip-chan> Yeah, I assume it delicious too, OReilly produces the best computer books
07:58:17 <wjt> Pip-chan: http://book.realworldhaskell.org/read/
07:58:37 <lambdabot> Title: Real World Haskell
07:58:46 <Pip-chan> ok
07:59:12 <Pip-chan> Haskell is a deep language, and we think that learning it is a hugely rewarding experience. :O
07:59:12 <Pip-chan> So it takes time
08:01:30 <Axman6> any good language does
08:02:10 <mauke> only a few years
08:02:14 <mauke> 10 or 15
08:02:14 <Axman6> but getting started is easy
08:02:29 <Axman6> heh
08:03:06 <kohwj> what? 10 to 15?
08:03:51 <kohwj> you're joking, right?
08:05:04 <Botje> he is
08:05:20 <Pip-chan> who gonna invent a language that takes 10 or 15 years to master
08:05:27 <Botje> it's more like 20 to 35
08:05:27 <opqdonut> 35? not nearly enough
08:05:50 <kohwj> wtf
08:06:02 * Beelsebob giggles
08:06:06 <vixey> Pip-chan: I don't think that is the language designers primary concern
08:06:06 <Pip-chan> >.<
08:06:06 <Beelsebob> kohwj: the language was standardised in 1998
08:06:09 <Beelsebob> that gives you a hint as to the most time people can have had to master it
08:06:11 <Botje> don't worry
08:06:15 <Botje> you can be fluent in haskell in a matter of weeks
08:06:15 <Beelsebob> (other than with old versions, and miranda and past similar languages)
08:06:15 <Botje> truly mastering haskell is something else entirely :)
08:06:15 <vixey> yeah Botje is right
08:06:15 <kohwj> define "master" then
08:06:15 <b_jonas> Beelsebob: well, people are still discovering tricks which don't currently work, which is why there are still new extensions
08:06:18 <Beelsebob> yep, but I'd hardly say that you're not a master of haskell until you know every possible trick ever going to be invented
08:06:18 <niklaus> how do we find s1 + 2*s2 + 3*s3+...+n*sn where sn it the subset of n distinct elements from a set of (a elements). The vlaue of sn is the product of elements in the set.
08:06:18 <kohwj> and what do you mean by "trick"?
08:06:18 <Axman6> niklaus: zipWith (*) [1..] xs
08:06:18 <Axman6> niklaus: sum $ zipWith (*) [1..] xs even
08:06:18 <niklaus> Axman6, does that do brute force
08:06:18 <niklaus> n is like 10^5
08:06:21 <Axman6> it does. if you have that many, you need a better algorithm ;)
08:06:25 <Axman6> actually, 10^5 isn;t that big
08:06:29 <b_jonas> niklaus: is that some Viete-formula stuff?
08:06:32 <kohwj> Beelsebob, it may be 10 years old, but I don't think age has anything to do with how deep a language is. see: python
08:06:32 <vixey> kohwj: huh?
08:06:32 <Axman6> > sum $ zipWith (*) [1..] [1..10^5]
08:06:32 <lambdabot>   333338333350000
08:06:32 <Axman6> niklaus: ^^
08:06:32 <Axman6> didn;t take long
08:06:32 <kohwj> vixey: what would you like me to disambiguate?
08:06:32 <vixey> kohwj: what about python
08:06:32 <niklaus> Axman6, the numbers needn't be from 1 10^5 it can be random btw hod eos it compute
08:06:32 <niklaus> sorry how does it compute
08:06:32 <kohwj> vixey: python is 17 years old, but it is less "deep" than haskell. the age of a language has nothing to with how deep it is
08:06:34 <vixey> kohwj: oh ok
08:06:39 <kohwj> so, i'm still skeptical that one needs 10 years to master Haskell
08:06:40 <Axman6> niklaus: f xs = sum . zipWith (*) [1..] $ xs -- that should be fine
08:06:45 <niklaus> Axman6, does it generate all the subsets once
08:06:45 <Axman6> huh?
08:06:48 <Axman6> i'm not sure what you're asking for... and i'm sleepy -_-
08:06:50 <niklaus> Axman6, it should be sum of invidiaul elements + 2* { sum of product of 2 elements from set} + 3 * {sum of product of 3 elements from s3et }
08:06:50 <niklaus> ...
08:07:07 <niklaus> for 1 ,2,3, it will be 1+2+3 + 2*{1*2 + 1*3 + 2*3} + 3*{1*2*3}
08:07:22 <Axman6> hmm, interesting
08:34:57 <b_jonas> niklaus: compute the sum, sum of squares, some of cubes, ..., sum of nth powers,
08:35:10 <mm_freak> 2*{1*2 + 1*3 + 2*3}  ⇐ sum of product of all permutations?
09:05:00 <Axman6> i'm sure it can be done... looks like something vixey or Cale or someone would have fun with
09:05:01 * Axman6 sets the loose at the problem
09:05:01 <b_jonas> and precompute a formula that computes it from these
09:05:01 <Axman6> and mm_freak
09:05:01 <b_jonas> I think it's polynomial
09:05:01 <mm_freak> hehe
09:05:01 <b_jonas> that is, the formula is a simple polynomial
09:05:01 <b_jonas> for every n
09:05:01 <b_jonas> I'm not good in this symmetric polynomials stuff
09:05:01 <mm_freak> [1,2,3,4] → 1+2+3+4 + 2*(1*2 + 1*3 + 1*4 + 2*3 + 2*4 + 3*4) + 3*(1*2*3 + 1*2*4 + 2*3*4) ?
09:05:01 <niklaus> b_jonas, sum of squares + some of cubes ?
09:05:02 <niklaus> mm_freak, yes + 4*{1*2*3*4}
09:05:02 <b_jonas> niklaus: dunno
09:05:02 <mm_freak> ah, ok
09:05:02 <mm_freak> niklaus: then first write a permutations function
09:05:02 <niklaus> mm_freak, you mean evaluating C(n,2), n  is big 10^5
09:05:02 <niklaus> lets take for 50 here , then we'll think about grearter ones
09:05:02 <mm_freak> niklaus: unless there is a shortcut, you need the permutations themselves
09:05:02 <b_jonas> mm_freak: there is I think
09:05:02 <mm_freak> if there is, i'm out =)
09:05:02 <niklaus> mm_freak, if we do the multinomial expansion and remove the terms where power > 1 we get something like this
09:05:02 <ddarius> The Gentle Introduction is the first thing I read on Haskell and I enjoyed it quite a bit.
09:05:02 <niklaus> mm_freak, isn't it combinations
09:05:02 <b_jonas> niklaus: moment, I'll do some experiments on small n
09:05:02 <b_jonas> in case there's some simple formula
09:05:02 <mm_freak> niklaus: i really don't know…  i only recently started to learn combinatorics
09:05:02 <b_jonas> what did you get for [1,2,3,4]?
09:05:02 <b_jonas> mm_freak: I think this is not a combinatorics problem
09:05:02 <niklaus> b_jonas,  1+2+3+4 + 2*(1*2 + 1*3 + 1*4 + 2*3 + 2*4 + 3*4) + 3*(1*2*3 + 1*2*4 + 2*3*4) + 4*(1*2*3*4)
09:05:02 <b_jonas> I got 326 with a quick calculation, is that right?
09:05:02 <b_jonas> > 1+2+3+4 + 2*(1*2 + 1*3 + 1*4 + 2*3 + 2*4 + 3*4) + 3*(1*2*3 + 1*2*4 + 2*3*4) + 4*(1*2*3*4)
09:05:02 <lambdabot>   290
09:05:02 <b_jonas> ok, debug time
09:05:02 <b_jonas> > 1+2+3+4
09:05:02 <lambdabot>   10
09:05:02 <niklaus> >2^4
09:05:02 <b_jonas> > 2*(1*2 + 1*3 + 1*4 + 2*3 + 2*4 + 3*4)
09:05:02 <lambdabot>   70
09:05:02 <niklaus> > 2^4
09:05:02 <b_jonas> > 3*(1*2*3 + 1*2*4 + 2*3*4)
09:05:02 <lambdabot>   16
09:05:02 <lambdabot>   114
09:05:02 <b_jonas> I think you're missnig a term there
09:05:02 <b_jonas> > 3*(1*2*3 + 1*2*4 + 1*3*4 + 2*3*4)
09:05:02 <lambdabot>   150
09:05:02 <b_jonas> better
09:05:02 <b_jonas> > 1+2+3+4 + 2*(1*2 + 1*3 + 1*4 + 2*3 + 2*4 + 3*4) + 3*(1*2*3 + 1*2*4 + 1*3*4 + 2*3*4) + 4*(1*2*3*4)
09:05:02 <lambdabot>   326
09:05:02 <niklaus> b_jonas, cool
09:05:02 <niklaus> correct
09:05:02 <niklaus> the elements needn't be 1,2,3,4
09:05:03 <b_jonas> sure
09:05:03 <b_jonas> that's why now we have to compute sum of kth power for every k in 0..n
09:05:03 <b_jonas> and then the powers of those numbers
09:05:03 <b_jonas> and do polynomial interpolation to get a formula to get your sum from these numbers
09:05:03 <niklaus> b_jonas, example
09:05:03 <b_jonas> do this for all small n and get a suspicion
09:05:03 <b_jonas> wait, I have to write code for it
09:05:03 <niklaus> explain the algorithm
09:05:03 <b_jonas> a moment
09:05:03 <b_jonas> so basically
09:05:03 <b_jonas> I'm not allowed my bot here which hinders demonstration a bit
09:05:03 <ddarius> vixey: In relatively concrete terms, what is the dual of a vector space?
09:05:03 <vixey> I don't really know what a dual is ..
09:05:03 <b_jonas> ddarius: do you mean dual as in linear algebra?
09:05:03 <ddarius> b_jonas: Yes.
09:05:03 <b_jonas> ddarius: it's the space of linear functions from that space to the reals (or whatever field you're working on),
09:05:03 <b_jonas> for finite spaces that's a vector space exactly like yours if you consider inner product
09:05:03 <b_jonas> finite dimensional
09:05:03 <HelgeS> Ubuntu + glade + haskell, which packages do I need?
09:05:03 <b_jonas> so if you think of the vector space R^n as the space of column vectors,
09:05:03 <b_jonas> then each linear function from this to R can be represented as (the left multiplication by) a row vector of n real elements
09:05:03 <niklaus> b_jonas, u were about to tell me the way
09:05:03 <b_jonas> niklaus: yep, but ddarius' query is simpler to answer so I interrupted for a moment
09:05:03 <b_jonas> I still have yours in stack
09:05:03 <niklaus> b_jonas, just tell me what i have to read before you tell me stuff
09:05:03 <ddarius> vixey: Here's one I'm pretty confident you know, what is a definition of logical negation in logical terms?
09:05:03 <vixey> ~P = P -> False
09:05:03 <ddarius> So, double negation is?
09:05:03 <b_jonas> niklaus: symmetric polynomials. I'm not sure what book has them
09:05:03 <vixey> ~~P = (P -> False) -> False
09:05:03 <niklaus> b_jonas, so we will define a symmetric polynomial ?
09:05:03 <niklaus> b_jonas, and that allows us to compute the sum ?
09:05:03 <b_jonas> here's what I think
09:05:03 <b_jonas> you have the numbers {s_0, s_1, ..., s_n}
09:05:03 <niklaus> b_jonas, ok
09:05:03 <b_jonas> from this you compute the sum a_1 = s_0 + s_1 + ..., the sum of squares a_2 = s_0^2 + s_1^2 + ..., the sum of cubes a_3 etc up to the sum of nth powers a_n = s_0^n + s_1^n + ...
09:05:03 <b_jonas> then you compute the (not too high) powers of these: a_0, a_0^2, ..., a_0^n, a_1, a_1^2, ..., a_1^n, ..., a_n, a_n^2, ..., a_n^n
09:05:03 <b_jonas> and my suspicion is that the sum you want is a linear combination of these values
09:05:03 <b_jonas> obviously you can compute these sums of powers quite fast
09:05:03 <b_jonas> (faster than generating all combinations of values)
09:05:03 <niklaus> yes
09:05:03 <niklaus> actually powers are computable and all combs are not
09:05:03 <b_jonas> so the question is only whether there's a nice formula for the linear coefficents to get your sum from these, for each n
09:05:03 <ddarius> So for a classical logic we have ((P -> False) -> False) <=> P which is suggests an enriched Yoneda lemma in that case.
09:05:03 <b_jonas> that's why I'm trying to compute these
09:05:03 <b_jonas> and compute the coefficients
09:05:03 <b_jonas> I think I can do that for small n-s
09:05:03 <b_jonas> and then I'll look up in oeis
09:05:03 <vixey> in Int ((P -> False) -> (Q -> False)) <=> (Q -> P)
09:05:03 <vixey> I should check
09:05:03 <niklaus> b_jonas, are you trying to bulid a symmetric polynomial for this
09:05:03 <b_jonas> well, what you want to compute is a symmetrical polynomial of the s_0, ... variables
09:05:03 <vixey> no not valid in
09:05:03 <niklaus> b_jonas, wiki states what we need is an elementary symmetric polynomiali
09:05:03 <ddarius> Similarly writing V -o W for a linear transformation from V to W, the dual of V, V^*, is (V -o R) and (V^*)^* ~ V, i.e. ((V -o R) -o R) ~ V
09:05:03 <niklaus> b_jonas, i'll be back in 10 mins
09:05:03 <vixey> interesting
09:05:03 <Saizan_> the dual of a vector space?
09:05:03 <b_jonas> something is wrong with my interpreter
09:05:04 <geezusfreeek> is it usually expected that if something is both a monad and a comonad that join and duplicate are inverses?
09:05:04 <b_jonas> or it might just be the expressions I'm typing in it
09:05:04 <sclv> geezusfreeek: either they're inverses, or one is forgetful, right?
09:05:04 <geezusfreeek> sclv: yeah, that's my question. is it bad if one is forgetful?
09:05:04 <sclv> bad for what purpose? i don't think there's lots of ppl using comonads out there...
09:05:04 <Saizan_> uhm, what's the example here?
09:05:04 <geezusfreeek> i just mean is there some law out there than mandates this for well-behaved monads/comonads
09:05:04 <sclv> I don't think so... lots of things are monads or comonads in more than one way.
09:05:04 <sclv> so you'd just be providing class instances that weren't duals.
09:05:04 <geezusfreeek> im extending Reactive with some comonadic semantics. for join, the semantics are: join rr `at` t == rr `at` t `at` t
09:05:04 <sclv> on the other hand, it would probbaly be really confusing.
09:05:04 <geezusfreeek> so i'm thinking the semantics for duplicate should be dual
09:05:04 <papermachine> Reactive has comonadic semantics?
09:05:04 <papermachine> *can have
09:05:04 <geezusfreeek> papermachine: well, i have written a few valid comonads already, just not with semantics dual to the monad instance yet
09:05:04 <papermachine> is it online anywhere?
09:05:04 * papermachine really likes comonads
09:05:04 <geezusfreeek> not yet
09:05:04 <geezusfreeek> it is an experiment in progress
09:05:04 <papermachine> :(
09:05:04 <papermachine> oky
09:05:04 <geezusfreeek> it will be online
09:05:04 <papermachine> yay!
09:05:04 <geezusfreeek> just not yet
09:05:04 <sclv> I think the question you need to ask is what would cause people to want to think comonadically about reactive.
09:05:04 <sclv> And then you could know what semantics would be appropriate.
09:05:04 <sclv> Additionally, if you have a "duplicate" with a different semantics but still think its useful, you could just give it an appropriate name and stick it in the lib, even without making it the duplicate method of a comonad.
09:05:04 <geezusfreeek> i will just continue to think about this
09:05:04 <b_jonas> why doesn't this work?
09:05:04 <b_jonas> I computed the a_n and the result and it doesn't seem to linearly depend
09:05:04 <b_jonas> shit
09:05:04 <Saizan_> i guess you've seen this http://lambda-the-ultimate.org/node/988
09:05:04 <lambdabot> Title: The essence of Dataflow Programming by Tarmo Uustalu and Varmo Vene | Lambda the ...
09:05:04 <geezusfreeek> actually i saw the title a while ago but never got around to reading it. i guess it would be good material to check up on
09:05:04 <sclv> also wtf would extract be?
09:05:04 <geezusfreeek> the dual of return
09:05:04 <geezusfreeek> the result is just the initial value
09:05:04 <sclv> right -- but assuming I understand reactive right, that's Event e -> e.
09:05:04 <geezusfreeek> i'm talking Reactive a -> a
09:05:04 <geezusfreeek> data Reactive a = Stepper a (Event a)
09:05:04 <ddarius> (S, -) is a comonad and if S is a monoid then (S, -) is a monad.  Similarly, (S -> -) is a monad and if S is a monoid (S -> -) is a comonad.
09:05:04 <ddarius> The semantics of Reactive are T -> A and T is a monoid
09:05:04 <geezusfreeek> ddarius: sweet, this is what i was looking for
09:05:04 <b_jonas> niklaus: I did the calculation but it doesn't seem to work for some reason
09:05:04 <b_jonas> must have made some error
09:05:04 <ddarius> This is a quirk of these particular cases, not a general trend.
09:05:04 <Saizan_> ?type \c -> (c .) . mappend  -- ?
09:05:04 <lambdabot> forall c a. (Monoid a) => (a -> c) -> a -> a -> c
09:05:04 <ddarius> Note that join is not an inverse of duplicate (for an arbitrary monoid)
09:05:04 <geezusfreeek> ddarius: great, that makes me feel a lot better about choosing semantics i think are useful instead of the constraints of being perfect inverses
09:05:04 <geezusfreeek> although now that i think about it it is unlikely that return and extract can be inverses anyway
09:05:04 <geezusfreeek> hmm, impossible even
09:05:04 <Saizan_> with this comonad extract c = c mempty
09:05:04 <geezusfreeek> extract is forgetful
09:05:04 <geezusfreeek> yeah, with this particular one, not in general
09:05:04 <ddarius> extract . return = id, return . extract /= id
09:05:04 <geezusfreeek> ^ exactly
09:05:04 <ddarius> return . extract makes a reactive value become constantly it's current value
09:05:04 <geezusfreeek> which does seem useful at least :)
09:05:04 <geezusfreeek> well, anyway, i'm gonna get back to it. thanks for the help everybody
09:05:04 <geezusfreeek> actually i'm gonna read this essence of dataflow paper
09:05:37 <niklaus> b_jonas, anything ?
09:05:38 <b_jonas> ok, I've got some progress
09:05:52 <b_jonas> niklaus: yes, I can get the coefficients for some of the terms of your sum
09:06:00 <b_jonas> (for small n)
09:06:33 <b_jonas> still hunting bugs
09:06:48 <niklaus> b_jonas, :) what is the expansion of (1+s1)(1+s2)(1+s3)....;)
09:06:55 <b_jonas> only for the first two terms though
09:08:56 <niklaus> b_jonas, i just reminded of a polynomial (t-x1)(t-x2)(t-x3)....(t-xn) = t^n + p1*t^n-2 + p2*t^n-2 ... = where p1=x1+x2+x3.. p2=x1x2 + x2x1 + x1x3 + x3x1 etc
09:09:10 <niklaus> sorry p2=x1x2 + x1x3 + x3x1
09:11:35 <niklaus> now if we could change that t^n-1 to t^1 and we expand we have our seiries with coefficeints missing , now differentiatling our px gives the result
09:11:46 <niklaus> b_jonas, does that look ok
09:13:41 <b_jonas> dunno
09:13:46 <b_jonas> what I'm doing is this, look
09:14:04 <b_jonas> I set n to 4 for experimentation
09:14:18 <b_jonas> the the first term is s_0+...+s_3
09:14:32 <b_jonas> the second is s_0*s_1 + s_0*s_2 + .. + s_2*s_3
09:14:34 <b_jonas> etc
09:14:42 <b_jonas> I could get the coeffs to compute the first and second term
09:14:47 <b_jonas> but not the one for the third
09:14:51 <b_jonas> and I can't find the bug in my code
09:15:09 <b_jonas> for the second one I found that its
09:15:11 <niklaus> b_jonas, how are you doing it
09:15:36 <b_jonas> a_1^2-a_2 or something like that
09:15:39 <b_jonas> which seems right
09:17:06 <b_jonas> either my code is wrong or my assumptions that it is a linear combination of these is wrong
09:18:20 <b_jonas> this is annoying
09:18:25 <b_jonas> this is supposed to be simple
09:19:21 <niklaus> b_jonas, how do you find the triple products
09:19:38 <b_jonas> do you have some code for small n?
09:19:43 <b_jonas> we could check results
09:20:04 <b_jonas> maybe I'm calculating something wrong
09:20:44 <b_jonas> check these if you want to:
09:20:55 <b_jonas> the s sequence is _1.9507 1.51954 _0.146705 _1.5286
09:21:57 <b_jonas> the sum, 2*sum of prod of twos, 3*sum of prod of threes, etc is _2.10647 _4.03516 14.6076 _2.6589
15:53:48 --- topic: '["Functional code is functional", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
15:53:48 --- topic: set by dons on [Mon Oct 06 10:27:40 2008]
15:53:48 --- names: list (clog_ aik osfameron loupgaroublond der_eq medfly Cale cnwdup hrehf raxas_ Spockz}Orthesaur sioraiocht skorpan Soliah novas0x2a abbe easytiger plutonas jeffwheeler edwardk kscaldef unenough mishok13 nybyn hugo__ O_4 Toxaris Plareplane Saizan_ guille_ araujo rdd dabd astrobunny|afk turjo zoq _cheerios asdf25 m4thrick ronwalf obsethryl Averell pumpkin_ dmwit pardus eu-prleu-peupeu lars_t_ cpfr smr emma njbartlett jfredett pstickne ArthurClemens)
15:53:48 --- names: list (BMeph dolio mwc tennin jberg- dvekravy vithos BONUS_ QplQyer sebaseba nich name SyntaxNinja papermachine aeolist mrd-_ sclv pastorn moshisushi kosmikus hesselink jamii binrapt dblazakis joelpet kpreid _ar shteou nathanic Cthulhon thingwath MaK1 synthasee Associat0r lekro Nshag ilkkah BCoppens RayNbow vixey snhmib astrolabe ttmrichter wolgo__ ToRA|MSR_ arjanb musiKk olsner cladhaire sheyll therp dibblego yakov2 uebayasi xHemi gogonkt_)
15:53:48 --- names: list (moozilla dancor Sartak Nanar Eridius Eelis cp1134 zeno Dessous gaagaaga2 Viniceos eno Mr_Awesome thoughtpolice solrize kayess_ Jedai gweiqi heavensrevenge tromp_ lasts Ycros dejones dort nwf vincenz keseldude jdrake ddarius ivan djinni u51z3h4 jeffersonheard lambdabot wagle tarbo Beelsebob elias` Ferdirand gds roderyk proq bts- alesb fophillips Asztal ozy` Debolaz leimy jan_ lefant ertai intoverflow atsampson jelmer metasyntax luite_)
15:53:48 --- names: list (encryptio_ Badger baaba Axman6 sbahra smtms drbean maxote BeelsebobWork vegai clanehin JuanDaugherty dino- sereven bd_ creaux pcapriotti reqamst mmorrow mauke SamB_XP hackage r0bby gbeshers arjanoosting alexsuraci smg cjb zamez Jaak xinming nottha_k Shurique PsiOmega byorgey ax1z u_quark Trin_away ilyak glguy agentzh Araneidae |Jedai| oklopol blazzy felipe jeffz lunabot moonpatio yango kennyv saccade agemo mulletron bitrot`` MyCatVerbs)
15:53:48 --- names: list (syscrash dmead orbitz equanimity QtPlatypus Botje bbs mightybyte nominolo DustyDingo cognominal c9s boyscared MrDomino geocalc SamB_irssi fxr Baughn lhoerste1 dufflebu1k ArneB liyang DarthMeh clog DrSyzygy Twigathy flori lispy Skyp ski_ lucca dhpe_ GNU\caust1c elliottt jonafan pfo mornfall sek fnordus enderbean ski mlh mm_freak nornagon cods Taggnostr slarba_ MarcWeber Caelum og Khisanth twifkak joed matthew-_ thedward gbacon score hellige)
15:53:48 --- names: list (lilac erg koninkje_away polux thorkilnaur Tigge DuClare scook0 obraun taruti TOLUanckA nnunley_ qebab pafcu Pistahh Riastradh kaol sutats Lamperi ksandstr xsdg sbok maskd mfp Shimei Poeir rwbarton Olathe juhp bohanlon levitation[A] noZone mattiast tltstc pizza_ rodge Arnar_ Somni IsoPallo desp Heffalump Axioplase_ Guest177 Kinks ahf authentic moconnor_ znutar_ lanaer mml` quicksilver SimonRC_ pengrate integral SamB sophacles dcoutts_)
15:53:48 --- names: list (eyck_ mascht mux davidL issal acura regulate nasloc__ hhurtta daf scorch mike_mcclurg thetallguy inimino djjack_ shepheb pantsd_ allbery_b mercury^ PHO_ SubStack shukhov tverwaes TSC spoop profmakx Japsu nemik Elly earthy glith frederik kar-1 Boney @ChanServ jamesjb stylus saiam dublpaws Vulpyne tessier Guest42280 kalven jql r3m0t bockmabe liesen Draconx rog preflex tmielika mapreduce And[y] Apocalisp ac mjrosenb mopped netcat DRMacIver)
15:53:48 --- names: list (klugez shawn shrimpx Guest20327 SUNWjoejaxx welterde Choko newsham stevan pdewacht kokekola lament chr1s birkenfeld Megant eelco sebbe1991 loop wolverian yahooooo malouin m_stone Tomas dfeuer shapr Igloo rue kolmodin Liskni_si audreyt chrisdone Tobsan kig Samy sad0ur fadec Mitar kg4qxk iggly idnar nothingmuch Anthraxx czShadoW arj__ Philippa_ Blub\0 stalker_ pjdelport sjanssen oeblink OnionKnight noj wjt Bleadof edwinb pa-ching freshhawk)
15:53:48 --- names: list (dfranke mrd cjay opqdonut funktio kpk Vq^ qwr Zao ulfdoz jleedev miasma Deewiant marmolak ibid _muke ziman bran dons pcc1 mwhitney tuukkah Nafai flux dionoea tero- Spark Laney pragma_ xian laz0r)
16:01:49 <dons> Baughn: hehe
16:01:56 <dons> the haskell devs been hacking some.
16:08:12 <mmorrow> <mmorrow> vixey: (here's the proof outline http://afp.sourceforge.net/browser_info/current/HOL/Compiling-Exceptions-Correctly/outline.pdf)
16:08:15 <lambdabot> Title: Compiling Exceptions Correctly, http://tinyurl.com/4fzocs
16:08:19 <mmorrow> err, oops wrong link
16:08:55 <mmorrow> http://afp.sourceforge.net/browser_info/current/HOL/Category/outline.pdf
16:08:58 <lambdabot> Title: Category Theory to Yoneda’s Lemma, http://tinyurl.com/53ejee
16:09:07 <mmorrow> this looks cool also:
16:09:17 <mmorrow> http://afp.sourceforge.net/entries/MiniML.shtml
16:09:18 <lambdabot> Title: Archive of Formal Proofs
16:09:30 <mmorrow> and the proof outline
16:09:32 <mmorrow> http://afp.sourceforge.net/browser_info/current/HOL/MiniML/outline.pdf
16:09:34 <lambdabot> Title: MiniML, http://tinyurl.com/3foxgb
16:11:26 <olsner> heh, "[...] proves Yoneda's lemma and aims to be readable by humans" ... I wonder if those properties aren't mutually exclusive :P
16:13:17 <ddarius> Yoneda's lemma is really easy to prove.
16:14:08 <olsner> I don't really have any idea what it is though
16:16:08 <Badger> early learner:
16:16:14 <Badger> how does one do the equiv of
16:16:28 <Badger> printf( "%s", string );
16:16:28 <Badger> ?
16:16:36 <ddarius> > printf "%s" "foo"
16:16:37 <lambdabot>   Add a type signature
16:16:39 <ddarius> > printf "%s" "foo" :: String
16:16:41 <lambdabot>   "foo"
16:16:56 <olsner> > putStr string
16:16:57 <lambdabot>   Not in scope: `string'
16:17:00 <olsner> > putStr "foo"
16:17:01 <ddarius> Of course, unless you actually want format strings, most people would use putStr
16:17:04 <ddarius> or putStrLn
16:17:05 <lambdabot>   * Exception: "<IO ()>"
16:17:23 <vixey> > uncurry      printf("%s", "foo")      :: String
16:17:24 <lambdabot>   "foo"
16:17:29 <ddarius> (incidentally, printf in Haskell corresponds (roughly) to both printf and sprintf)
16:18:04 <kpreid> (but not fprintf...)
16:18:10 <Badger> hmm
16:18:16 <Badger> if foo is a function?
16:18:19 <ddarius> :t hprintf
16:18:20 <lambdabot> Not in scope: `hprintf'
16:18:23 <ddarius> :t hPrintf
16:18:24 <lambdabot> forall r. (HPrintfType r) => GHC.IOBase.Handle -> String -> r
16:18:34 <ddarius> Badger: Functions aren't displayable.
16:18:41 <Badger> ...
16:18:45 <Badger> Odd.
16:19:03 <mauke> C functions aren't displayable either
16:19:11 <vixey> eek
16:19:22 <Badger> I'm thinking equiv to printf( "%s", SDL_GetError );
16:19:29 <vixey> SDL_GetError()
16:19:29 <vixey> ?
16:19:30 <Badger> GetError is in HSDL
16:19:30 <mauke> that looks invalid
16:19:34 <Badger> er
16:19:34 <Badger> yes
16:19:40 <vixey> SDL_GetError() isn't a function
16:19:42 <Badger> GetError() even
16:19:42 <mmorrow> invalid salad?
16:20:12 <kpreid> Badger: Ah, you mean displaying the result of a function.
16:20:22 <olsner> a function call in haskell is just a value (well, function calls are just values in C too... disregarding side-effects)
16:20:25 <Badger> I probably do. :P
16:20:40 <kpreid> Badger: print (reverse "hello")
16:20:42 <Cale> Badger: See, printf in Haskell has a strange type, because printf is required to take arbitrarily many parameters.
16:20:55 <olsner> but you have to add show if the value isn't a string... like
16:20:56 <olsner> > printf "%s" (show 42)
16:20:57 <lambdabot>   Add a type signature
16:21:03 <Badger> heh
16:21:13 <Cale> Badger: Which means that its result after taking the first n parameters must be any one of a large number of types of functions.
16:21:14 <kpreid> Badger: unless you want formatted output, printf-in-Haskell is a distraction, you want just print or putStr
16:21:18 <Cale> (and results)
16:22:20 <ddarius> olsner: Yoneda is a pretty simple result.  It's important, but mostly in the way that, say, the convolution theorem is important, which is to say central but usually tacit.)
16:22:22 <Badger> kpreid: you mean putStr ignores \n and the like?
16:23:12 <Cale> I've finally come to a proper understanding of what Yoneda's lemma actually means just recently.
16:23:31 <dmwit> Badger: No, why would it ignore \n?
16:23:33 <Cale> I read the result and proof a long time ago, but somehow missed the point :)
16:23:35 <ddarius> Cale: I think there are several "proper understandings" of what Yoneda means.
16:23:47 * vixey knows none of them
16:25:20 <Cale> Well, okay, the one which I've come to is that the Yoneda embedding is a kind of "completion" for categories. It takes your (possibly crappy) category and embeds it in a possibly much larger category which has all the constructions you'd generally want.
16:25:43 <vixey> that's surreal
16:25:43 <Cale> And it does so in such a way that the only arrows between any two objects in the image of the embedding are the arrows from the original category.
16:26:04 <vixey> this is exactly the sort of thing I'm doing - and the yoneda stuff came up naturally
16:26:45 <Cale> So if you can use the constructions in this larger category to show that some arrow exists between two objects in the image of your original category, then there must be an arrow between them in your original category as well.
16:26:54 <Cale> And if it's a unique arrow, then that arrow was unique.
16:27:30 <shapr> How do you catch a unique arrow? You 'nique up on it...
16:27:39 <vixey> lol
16:27:47 <ddarius> Indeed, that is one of the perspectives: embed a category into presheafs over that category.
16:28:13 <ddarius> There is actually a completion construction that works this way.
16:29:45 <ddarius> A related perspective views presheaves as "variable sets" acted on by the category.
16:29:47 <Cale> So, from my perspective, the fact that it's Set^(C^op) specifically is sort of "part of the implementation" of that completion.
16:30:03 <Cale> But yeah, you can start to take that apart.
16:32:14 <hackage> Uploaded to hackage: CheatSheet 1.1
16:32:42 <shapr> ooh, hackage bot!
16:32:47 <shapr> @seen hpaste
16:32:48 <lambdabot> I haven't seen hpaste.
16:33:03 <mauke> preflex: seen hpaste
16:33:04 <preflex>  hpaste was last seen on #haskell 92 days, 7 hours, 34 minutes and 25 seconds ago, saying:  Mitar pasted "Hot to indent?" at http://hpaste.org/8869
16:34:01 <shapr> whoa
16:34:05 <shapr> it's been broken a loong time.
16:35:00 <dons> ?users
16:35:01 <lambdabot> Maximum users seen in #haskell: 518, currently: 480 (92.7%), active: 18 (3.8%)
16:36:15 <ddarius> Cale: One unique-ish perspective (or at least I haven't seen presented this way) is that there are two styles of "doing" category theory that I call Set Category Theory and Cat Category Theory.  The former using representability as it's primary tool and the latter using universal arrows, and Yoneda is the bridge between them. Set CT transports the structure of Set throughout the categories and Cat CT the structure of Cat.
16:37:31 <jml> shapr: hi :)
16:39:23 <T-Cell> how would I do  cos of 0 degrees?
16:39:28 <Cale> > cos 0
16:39:30 <lambdabot>   1.0
16:39:49 <ddarius> Cale: Have you ever read "Basic Concepts of Enriched Category Theory"?
16:39:49 <vixey> > cos (0 * 360 / (2*pi))
16:39:50 <lambdabot>   1.0
16:39:55 <ddarius> > 1.0
16:39:56 <lambdabot>   1.0
16:39:57 <Cale> (though that's radians, of course, 0 = 0 degrees)
16:40:07 <Cale> ddarius: Nope.
16:40:16 <Cale> ddarius: Is it available online?
16:40:18 <ddarius> @google "Basic Concepts of Enriched Category Theory"
16:40:21 <lambdabot> http://www.tac.mta.ca/tac/reprints/articles/10/tr10abs.html
16:40:21 <lambdabot> Title: Basic Concepts of Enriched Category Theory
16:40:28 <dufflebu1k> Has anyone tried install validate-0.0 with cabal and succeeded?
16:41:07 <ddarius> This little page is cool: http://www.tac.mta.ca/tac/reprints/index.html
16:41:08 <lambdabot> Title: Reprints in Theory and Applications of Categories
16:41:16 * dons continues building all of hackage against 6.10
16:41:18 <dons> go cabal, go!
16:41:29 <dons> shapr: i want to print off some nice "there is no cabal" tshirts, like the xmonad ones.
16:41:35 <dons> with the box/star cabal logo on the front
16:41:38 <dons> and the slogan on the back.
16:41:43 <dons> whaddya think?
16:42:46 <olsner> there is no cabal?
16:42:59 <nominolo> TINC
16:43:01 <dons> that's right. you never heard otherwise.
16:43:26 <olsner> oh, as in the usenet cabal
16:44:22 <Cale> olsner: No, the Haskell Cabal obviously :)
16:44:32 <ddarius> As in the HSU
16:44:36 <Cale> Which doesn't exist ;)
16:45:02 <olsner> Obviously. :)
16:45:35 <olsner> I'd like to have a few cool haskell t-shirts
16:46:20 <Cale> ddarius: By the way, I'm not sure if I linked to it before, but I recently read Awodey's introductory category theory book, which gave me the insight on Yoneda, and was quite enjoyable overall.
16:47:33 <jml> Cale: that's the Oxford one?
16:47:47 <Cale> It seems like it would be good for computer science people who want to learn category theory, since it doesn't appear to have so many prerequisites.
16:48:04 <Cale> http://cale.yi.org/share/Category%20Theory%20-%20S.%20Awodey%20(Clarendon,%202006)%20WW.pdf
16:48:07 <lambdabot> Title: cache:http://cale.yi.org/share/Category%20Theory%20-%20S.%20Awodey%20(Clarendon, ..., http://tinyurl.com/4jav6v
16:49:17 <Cale> I'm not entirely sure how my friend got that PDF. ;)
16:51:57 <dmwit> wgot
16:52:32 <Cale> Heh, there should be a lolcat version of wget called whas
16:55:08 <shapr> dons: I'd buy one!
16:55:23 <ddarius> Cale: I think you did mention it, but it doesn't look familiar.
16:56:32 <Cale> "Basic Concepts of Enriched Category Theory" looks good, I'll read it :)
16:57:08 <BMeph> I want a T with "Xmonad | Cabal | Darcs" on the front, and on the back, "HASKELL   it works, bitches" ;)
16:57:37 <ddarius> Cale: It's the most comprehensive resource I've found on indexed (co)limits, a very underappreciated (or at least underexposed) tool of category theory.
16:57:47 <BMeph> might have to ask the xkcd crew for permission, but I'm sure they'd give it... :)
16:58:05 <Cale> ddarius: Indexed in more than the usual sense?
16:58:16 <ddarius> indexed not parameterized
16:58:27 <ddarius> A more modern name is weighted (co)limits.
16:58:32 <ddarius> Though I prefer the older name.
17:01:41 <Badger> Err.
17:02:32 <Badger> So, um, how does one stick function foo's result into a line of output?
17:03:06 <dmwit> :t print
17:03:07 <lambdabot> forall a. (Show a) => a -> IO ()
17:03:18 <mauke> @src print
17:03:18 <lambdabot> print x = putStrLn (show x)
17:03:31 <dmwit> Badger: You might also like
17:03:32 <dmwit> :t interact
17:03:33 <lambdabot> (String -> String) -> IO ()
17:03:51 <dmwit> Badger: Provide a function from input String to output String, and interact handles the rest.
17:04:11 <dmwit> main = interact id -- here's an implementation of Unix' "cat" command
17:05:09 <dmwit> main = interact (map toUpper) -- you could write a SHOUT command almost as easily =)
17:05:41 * Badger sits dazed by dmwit's haskell-fu
17:05:53 <Badger> Little of that made sense to me. :P
17:05:58 <lasts> @src interact
17:05:58 <lambdabot> interact f = do s <- getContents; putStr (f s)
17:06:03 * Badger goes to reflect upon it,
17:06:21 <dmwit> Badger: Oh, have you written any Haskell program before?
17:06:39 <Badger> To be honest, no. :P
17:06:42 <dmwit> You can get pretty far with Haskell just using ghci and never writing an actual program. =)
17:06:45 * Badger is elarning.
17:07:15 <dmwit> Badger: There is a distinguished function called "main" that is the entry point of any Haskell program.
17:07:40 <dmwit> It has type "IO ()", which for now you can think of as just saying that it might do some input and output, and doesn't result in any interesting result.
17:08:26 <Badger> hmm.
17:08:27 <Cale> It can actually have type IO t for any given t.
17:08:30 <dmwit> "interact" is one way to construct a value of type "IO ()".
17:08:34 <Cale> (the result is discarded)
17:08:41 <dmwit> Cale: Well, in GHC it can, but I think H98 specifies IO ().
17:08:41 <Badger> ah.
17:08:47 <Cale> really?
17:09:00 * Cale checks :)
17:09:48 <Cale> "The value of the program is the value of the identifier main in module Main, which must be a computation of type IO t for some type t"
17:10:10 <Peaker> Badger: what languages are you familiar with?
17:10:14 <dmwit> Huh, okay. =)
17:10:39 <dmwit> Cale: Which section was that in?  And how did you find it so fast?
17:10:50 <Cale> http://haskell.org/onlinereport/modules.html
17:10:51 <lambdabot> Title: The Haskell 98 Report: Modules
17:10:57 * dmwit tried Expressions, Declarations and Bindings, Modules, and Syntax Reference with no luck
17:11:01 <Cale> I have bookmarks to every section of the Report :)
17:11:30 <dmwit> I must have just missed it, I guess.
17:11:44 <Cale> I typed "/main" and noticed that it was right at the top there :)
17:12:00 <Badger> Peaker: C
17:12:13 <Badger> ...and that's about it.
17:12:32 <dmwit> Badger: Welcome to the light side of the Force. =)
17:12:39 <Peaker> :-)
17:12:46 <Badger> heheh
17:12:50 <Badger> Thanks.
17:13:06 <Badger> the light side is pretty tough. :P
17:13:06 <dmwit> Where it takes longer to start, and requires a lot of discipline, but the payoff is enormous in the end...
17:13:13 <wjt> is there a combinator for \m cond -> do { x <- m; guard (cond x); return x } ?
17:13:27 <dmwit> wjt: No.
17:13:41 <Peaker> Badger: (IO some_type_here) is a type of a value.  That value is called an "action".  The action is a description of some ordered actions/side-effects and computations to perform
17:13:43 <dmwit> wjt: I have such a definition in module Dmwit, though, because I find it very useful.
17:13:47 * wjt declares it to be >?>
17:14:08 <dmwit> wjt: ensure p x = guard (p x) >> return x -- actually, this is what I use, slightly different
17:15:31 <Peaker> Badger: As you probably read, Haskell is "purely functional". That means a normal function is like a math-function. It cannot "do" anything, except compute a result that ONLY depends on its inputs.   A Haskell program does not "do" anything, instead it builds up a description of what to do, in the form of an "action", or an (IO some_type) value...
17:16:09 <wjt> dmwit: ah, that's easier to read
17:16:16 <Peaker> Badger: main is basically a function that returns this description of what to do to its caller, who can actually run the stuff described by the (IO whatever) value
17:16:43 <Badger> Ouch.
17:17:23 <dmwit> wjt: Incidentally, yours can be written as "m >>= ensure cond" (or do { x <- m; ensure cond x }) if you use that definition of ensure.
17:17:44 <wjt> dmwit: yes
17:18:09 <Badger> Peaker: does this mean that:
17:18:12 <Peaker> Badger: in real Haskell programs, most of your code remains pure, and does not have to return IO actions -- which has a lot of very very nice consequences
17:18:18 <Badger> main = do *all this*
17:18:20 <[mharrison]> Why does Haskell seem to have a hard time displaying ints?  I don't see what's wrong with this.  http://rafb.net/p/h9e9rd14.html
17:18:21 <lambdabot> Title: Nopaste - No description
17:18:54 <dmwit> [mharrison]: zip does not apply the functions in the second list.
17:19:15 <dmwit> [mharrison]: So what you end up with is a list of (Int, Int -> Int), i.e., pairs of values and functions.
17:19:20 <dmwit> There's no way to print functions in general.
17:19:30 <dmwit> So it just complains.
17:19:30 <[mharrison]> dmwit, ah, I see
17:19:41 <[mharrison]> dmwit, that's useful to know.  Thanks
17:19:43 <dmwit> [mharrison]: If you read the error, it says the same thing I just did, but a little more tersely. ;-)
17:20:07 <Badger> Peaker: very very nice, eh? :P
17:20:30 <Peaker> Badger: main can ask other functions to return actions too, and then use those to build up its own action
17:20:39 <Peaker> Badger: You aren't forced to put the whole description just in main
17:22:33 <ozy`> [mharrison]: perhaps you wanted this...?
17:22:35 <ozy`> > zipWith (+) [1,2,3] [2,3,4]
17:22:36 <lambdabot>   [3,5,7]
17:23:46 <dmwit> > zipWith (flip id) [1,2,3] [(+2), (+3), (+4)]
17:23:47 <lambdabot>   [3,5,7]
17:23:53 <Cale> Badger: The main nice thing about this way of doing things is that it ensures that if a function gives some result for a given input, then it always gives the same result.
17:24:13 <dmwit> Nah, the main nice thing is that the programmer can be sure nothing sneaky is happening.
17:24:18 <dmwit> compositionality, etc.
17:24:18 <ozy`> dmwit: aha, I knew that was useful for something!
17:24:26 <Cale> Badger: Even in the case of a function of type (a -> IO b), for a given value of type a, the function must always give the same (IO b) action.
17:24:33 <Peaker> Badger: "do" is just a syntax sugar that helps you build up "big" actions from small ones
17:24:38 <[mharrison]> ozy`, nah.  I'm doing stupid homework where we only have a handful of funcs to use.  (and I'm not asking for help on the homework - just clarification on what the error message(s) mean)
17:24:54 <dmwit> or: Nah, the main nice thing is that you can code up small modules in isolation, then combine them without fear.
17:25:29 <dmwit> or: Nah, the main nice thing is that you can use equational reasoning.
17:25:40 <dmwit> (i.e. there's lots of nice things about referential transparency. =)
17:25:45 <Peaker> Badger: in C, a function is a series of statements.  Each statement is also kind of like an action.  You have a semicolon concatanating these little actions into bigger actions.  Haskell's "do" notation is similar - and newlines/semicolons are converted to the >> or >>= operator to concatenate the little actions into big ones
17:25:47 <Cale> Well, yes, that's largely a consequence of the fact that functions have no effects other than to produce their result and depend on nothing but their parameters.
17:26:40 <pcc1> is there a function defined :: a -> Bool s.t. defined undefined = False, defined _ = True
17:26:50 <Cale> There is a major, but subtle difference between  "v <- f x"  in a do-block and something like v = f(x) in C though.
17:26:53 <dmwit> It is not possible to define such a function.
17:27:17 <ddarius> "major but subtle" ...
17:27:34 <Cale> ddarius: It's a big difference, but it's hard to see for beginners, is what I mean.
17:28:05 <Cale> In C, v = f(x) updates the memory location named by v with the value returned by executing f(x).
17:28:09 <[mharrison]> woot!   I solved it.  Thanks, dmwit
17:28:39 <Cale> In Haskell,  v <- f x  gives a name to the result of executing the action f x
17:28:43 <Cale> (it names it v)
17:29:05 <[mharrison]> funcval x (car:cdr) = (car x) : (map (\f -> (f x)) cdr)   was what I was looking for
17:29:20 <asdf_> anyone know anything about lambdabot? I tried building it, and everything works except @run anything, like @run length [1,2] and it just says "Terminated"
17:29:27 <pcc1> hmm, I am trying to build a large data structure incrementally, so I figured to use undefined in the places where the values haven't been given yet.  is there a better way? (other than Maybe, as this could complicate the code that works on the final data structure)
17:29:59 <dmwit> pcc1: Maybe is the way.
17:29:59 <Cale> [mharrison]: funcval x fs = map ($ x) fs
17:30:23 <mauke> cyclic programming
17:30:24 <dmwit> pcc1: You can also use undefined, but then you just have to be careful never to access a particular part of the value until it has been defined.
17:30:32 <[mharrison]> Cale, what's ($ x) shorthand for?  Whatever it is, we're not allowed to use it on this damned assignment
17:30:47 <dmwit> ?src ($)
17:30:47 <lambdabot> f $ x = f x
17:30:48 <Cale> Ah, that's just the function which takes a function and applies it to x.
17:31:01 <dmwit> [mharrison]: ($x) = \f -> f x
17:31:07 <Cale> yeah
17:31:16 <[mharrison]> Would be nice shorthand to use
17:31:20 <Cale> So you could write  funcval x fs = map (\f -> f x) fs
17:31:30 <Cale> or even:
17:31:34 <pcc1> dmwit: thanks, will try and work something out
17:31:37 <Cale> funcval x = map (\f -> f x)
17:31:43 <dmwit> :t map . ($)
17:31:43 <ddarius> "Indeed, the subject might better have been called abstract function theory, or, perhaps even better: archery."
17:31:44 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:31:53 <Cale> ($) = id
17:31:54 <dmwit> oh
17:31:54 <Cale> ;)
17:31:57 <dmwit> :t map . flip id
17:31:58 <lambdabot> forall a c. a -> [a -> c] -> [c]
17:32:06 <dmwit> :t sequence
17:32:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
17:32:07 <ddarius> pcc1: undefined is equivalent to an infinite loop.
17:32:14 <ddarius> (conceptually at least)
17:32:17 <dmwit> :t sequence :: [a -> c] -> a -> [c]
17:32:18 <lambdabot> forall a c. [a -> c] -> a -> [c]
17:32:51 <[mharrison]> Cale, oh, neat.  I had a "repeat" statement in there earlier - we're supposed to take a value and a list of functions and return a list containing each func applied to that val
17:33:01 <Cale> [mharrison]: yeah
17:33:08 <Cale> [mharrison]: so, that's one way to do it
17:33:19 <dmwit> [mharrison]: Surprise your TA, write "f = sequence". =)
17:33:37 <[mharrison]> heh
17:33:52 <Cale> It's worth noting that funcval = sequence would require Control.Monad.Instances to be imported
17:33:56 <[mharrison]> If we could use the rest of the prelude and code intelligently, I would =)
17:34:06 <Cale> Since for some stupid reason, that instance is not in the Prelude.
17:37:29 <pcc1> if I have something like "data Test tmap = Test (tmap Integer)" is there a tmap x I can give so that data Test x = Test Integer?
17:38:03 <dmwit> Id
17:38:42 <pcc1> where's Id defined?
17:38:44 <dmwit> ?index Id
17:38:44 <lambdabot> bzzt
17:38:51 <dmwit> Control.Monad, maybe?
17:39:06 <ddarius> dmwit: You can't pass in type Id a = a and using a newtype would add a layer of indirection (for [finger] typing)
17:39:15 <dmwit> dmwit: Control.Monad.Identity
17:39:22 <dmwit> er, pcc1, even
17:39:52 <dmwit> ddarius: I'm not sure I understood you, but are you just complaining that Test Id has an extra wrapper?
17:40:00 <ddarius> Yes.
17:40:02 <dmwit> ouk
17:40:21 <dmwit> Not much you can do about that, at least in Haskell.
17:40:29 <ddarius> Indeed.
17:41:25 <ddarius> Also neither will lead to an extra unused parameter 'x', but that's probably a "typo" ?
17:41:33 <dmwit> I think so.
17:57:17 <Peaker> are default methods implementations only useful for optimized instance implementations, or do some change semantics when overriding the defaults?
17:58:01 <dmwit> Peaker: It's usually optimization.
17:58:42 <Peaker> Couldn't optimization be done in a more general way?  Why only allow specializing these for instances? Why not allow overriding any context-specific function?
17:58:56 <Peaker> (where these overrides are supposed to maintain semantics)
17:58:58 <dmwit> GHC does allow that, via its {-# RULES #-}.
17:59:18 <Peaker> okay, then aren't default methods superfluous?
17:59:30 <dolio> They can be useful if there are multiple different sets of minimally required definitions for a certain class.
17:59:40 <dolio> And some are easier for a particular type than others.
17:59:44 <mauke> @src Eq
17:59:44 <lambdabot> class  Eq a  where
17:59:44 <lambdabot>     (==), (/=)   :: a -> a -> Bool
18:00:04 <Peaker> Ah, so you have a and b both circularly defined based on each other
18:00:10 <dmwit> right
18:00:19 <Peaker> I see, that cleared it up, thanks :)
18:00:40 <dolio> For instance, return and (>>=) cover everything for Monad, but so does return, fmap and join.
18:01:01 <dolio> Although that option isn't available in the current libraries.
18:02:15 <Peaker> yeah, if Monad subclassed Functor, maybe return/join (optionally >>= instead of join) would make better candidates for usual implementation?
18:02:31 <dmwit> :t \m mf -> join (fmap mf m)
18:02:32 <lambdabot> forall a (m :: * -> *) a1. (Monad m, Functor m) => m a -> (a -> m a1) -> m a1
18:02:34 <dolio> Yeah. That's how I'd do it.
18:02:37 <ddarius> @src (==)
18:02:37 <lambdabot> x == y = not (x /= y)
18:02:39 <ddarius> @src (/=)
18:02:40 <lambdabot> x /= y = not (x == y)
18:02:57 <dolio> Eq and Ord are actual examples.
18:03:47 <Peaker> though I can't think of any case where you'd want to implement /= rather than == :-)
18:05:53 <dolio> Yeah, I don't have any good examples for why /= would be significantly easier than ==.
18:06:07 <dolio> Or why (<=) would be easier than compare or vice versa.
18:08:01 <dmwit> > let nan = 0/0 in (nan > nan, compare nan nan)
18:08:02 <lambdabot>   (False,GT)
18:08:50 <dolio> Clearly than needs some "data Bool' = True | False | FileNotFound" action.
18:08:59 <dmwit> =)
18:09:05 <dmwit> Brillant!
18:09:43 <mmorrow>  Maybe Bool
18:11:37 * mmorrow wishes either was data E a b = L a | R b instead of its current excessively verbose def :)
18:12:00 <mmorrow> and data M a = N | J a :):)
18:12:17 <dolio> a + b
18:12:29 <mmorrow> c?
18:12:47 <ddarius> data a :+ b = Inl a | Inr b
18:12:47 <dmwit> dolio: '+' isn't upper-case. ;-)
18:13:00 <dmwit> yeah
18:13:02 <dolio> SPJ wants to make it so for types.
18:13:02 * BMeph wishes there were a way to re-create existing types w/o re-[finger]typing everything
18:13:20 * Peaker wishes Conal's FRP/GUI libraries were polished enough so he could try to write a non-textual code editor, where verbosity of names is a non-issue :)
18:13:28 <mmorrow> how lovely. instead of  ThisDataConstrictprStandsFortheLACKOfAnythingNotNotNothing
18:14:13 <mmorrow> i sometimes don't use either because i don't want to add that huge word to my type sig
18:14:51 <ddarius> It's called a type synonym
18:15:54 <dons> current build status for ghc 6.10 Rc
18:15:55 <dons>  http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/15452
18:15:59 <mmorrow> i'd rather just make another data E a b = L a | R b
18:15:59 <dons> 6% breakage atm.
18:16:00 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/4d7v86
18:16:05 <dons> down 2% from yesterday
18:16:23 <mmorrow> type syns do nothing about the constructors
18:16:55 <dmwit> There's value constructors, too, for everything but pattern matching.
18:17:02 <dmwit> s/constructors/synonyms/
18:17:17 <mmorrow> that a big "but" there
18:17:37 <Cale> mmorrow: If you're going to do that, you should probably name the constructors more meaningfully :)
18:17:38 <dmwit> Since your use case is when you want to use the "either" function, anyway, that "but" hardly matters.
18:17:52 <mauke> I like big "buts"
18:18:01 <dmwit> But can you lie?
18:18:06 <Cale> mmorrow: But the advantage to using Either in the first place is that there are library functions for working with values of Either type.
18:18:10 <BMeph> mauke: ...and you cannot lie? ;p
18:18:28 <mmorrow> Cale: totally, hence my displeasure with their verbosity :)
18:18:43 <Cale> mmorrow: I don't really see what's so verbose about it, myself.
18:18:43 <BMeph> Cale: Perhaps mmorrow wants to prove he is a "real man"? ;)
18:19:04 <mmorrow> because, although i may bitch and moan, i'll inevitably use them
18:19:06 <Peaker> wouldn't it be nice to define an adapter between two isomorphic data types, so that it can auto-convert back and forth between them?
18:19:35 <dmwit> I sometimes think that.
18:19:37 <Cale> Peaker: If it did that implicitly, type inference would become hell.
18:19:39 <dmwit> Then I wake up again.
18:19:40 <BMeph> Peaker: Kind of like a phantom type class, eh? :)
18:19:52 <Peaker> BMeph: I am not sure, maybe :)
18:20:15 <Cale> Also, the meaning of a program would become somewhat ambiguous.
18:20:20 <dmwit> But it *would* be nice to be able to declare a bijection for writing class instances.
18:20:37 <Cale> Especially as typeclass instances can be different for unequal but isomorphic types.
18:20:52 <dmwit> Such an extension could even be written as a preprocessor -- that is, it has no effect on type checking or anything.
18:21:15 <Guest177> Can someone please remind me what ++ is, again?
18:21:20 <Cale> Concatenation
18:21:24 <ddarius> @src (++)
18:21:25 <lambdabot> []     ++ ys = ys
18:21:25 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
18:21:25 <lambdabot> -- OR
18:21:25 <lambdabot> xs ++ ys = foldr (:) ys xs
18:21:27 <dmwit> Guest177: It concatenates (exactly) two lists.
18:21:28 <Cale> > [1,2,3] ++ [4,5]
18:21:29 <lambdabot>   [1,2,3,4,5]
18:21:33 <Guest177> dmwit: aha, thankyou
18:21:35 <Peaker> Cale: then maybe everyone should write class-specific functions instead of type-specific functions?   Either and E can both be instances of some class?
18:21:37 <BMeph> dmwit: ndm's type aliases, p'haps? :)
18:21:49 <dmwit> BMeph: Not sure, link?
18:21:59 <dons> Baughn: how's the cabal install build going?
18:22:21 <Cale> Peaker: Consider the three instances of Monoid for types isomorphic to Maybe a
18:22:24 <Peaker> I think it sucks Haskell has non-overloadable things like Bool/etc
18:22:33 <Cale> I think it's fine.
18:23:01 <Cale> Bool is sufficiently important to get a name
18:23:06 <Peaker> Cale: it breaks so many cute things, like Behavior's overloading, augustus's tracer, etc
18:23:21 <Peaker> s/breaks/significantly limits
18:23:24 <dolio> Clearly Bool should be named 2.
18:23:30 <mmorrow> why can't you "overload" Bool?
18:23:37 <Peaker> Cale: I am not saying it should not get a name, just that it should be a class instead of a type
18:23:40 <mmorrow> {-# LANGUAGE NoImplicitPrelude #-}
18:23:59 <Peaker> mmorrow: by overload, I mean by able to have (<) :: Behavior -> Behavior -> Behavior
18:23:59 <BMeph> dmwit: Oops, never mind, it's john meacham, and it's a class alias: http://repetae.net/recent/out/classalias.html
18:24:10 <lambdabot> Title: Class Alias Proposal for Haskell
18:24:22 <mmorrow> i checked the asm output with ghc -S and that + data A = A and there was literally /nothing/ other that my A in it :)
18:24:24 <younder> I get a error "not in scope" when loading mylengh
18:24:25 <Cale> Peaker: What, something like  class Bool b where toBool :: b -> Bool; fromBool :: Bool -> b
18:24:35 <younder> what is it talking about?
18:24:40 <Cale> Peaker: with the law that those are bijective?
18:25:16 <Peaker> Cale: No no, I think maybe something like class Ord b => Bool b where True :: b ; False :: b
18:25:17 <Cale> younder: Means that it can't find the function or value you're referring to.
18:25:20 <dmwit> BMeph: No, I'm talking about something a little different.
18:25:33 <dmwit> BMeph: For example, in what I propose, you might write
18:25:33 <Peaker> Cale: maybe that has to be true/false (not constructors)
18:25:43 <dmwit> instance Num Char using (ord, chr) -- or something like that
18:25:43 <Peaker> Cale: Ord/Eq allows "if"/etc to work on these
18:25:46 <Cale> Peaker: Why Ord?
18:25:46 <mmorrow> Peaker: why not just redefine (<) if you /must/ have it be yours? :)
18:25:47 <younder> cale: duh, but why not.. I am looking at it and just asked it to load it
18:25:57 <Cale> Peaker: How so?
18:25:58 <dmwit> BMeph: (Not that that is a good example.)
18:26:09 <Peaker> mmorrow: It lets me use existing code that uses (<) so it applies to my types too
18:26:29 <Cale> Peaker: How does 'if' work on Integer with true = 1; false = -1, say?
18:26:37 <mmorrow> Peaker: i guess what i'm saying is, why are you attached to the four chars "Bool"? why not make that exact class where true :: a ; false :: a?
18:26:40 <dmwit> BMeph: Incidentally, generalized newtype deriving for "newtype Foo a = Foo {unFoo :: a}" would become "instance Whatever Foo using (Foo, unFoo)". =)
18:26:51 <mmorrow> and call it "Bill" or something
18:27:01 <Peaker> Cale: If you have a value of type (Bool b => b), just compare it with (true :: b)
18:27:10 <Peaker> Cale: "if" could do that, that is
18:27:13 <dons> awesome, wxcore and wx installing out of the box with ghc 6.10
18:27:15 <Cale> Peaker: and if the value is not true or false?
18:27:22 <dons> cabal install wxcore -- just freaking works.
18:27:29 <Cale> Peaker: which branch does the if pick then?
18:27:38 <Peaker> Cale: Heh, I missed that completely :)
18:28:13 <Peaker> Cale: I guess your toBool/fromBool suggestion is better
18:28:21 <Peaker> Cale: why not do that?
18:28:26 <Cale> Because it's silly.
18:29:18 <Peaker> Cale: it lets me use functions that are directly/indirectly using Bool, on Behaviors, or Traced values, etc
18:29:23 <Cale> The code for toBool and fromBool is usually simple enough and rare enough that it's not even a problem to inline it everywhere that it's needed.
18:29:24 <mmorrow> yeah, data InjProj a b = InjProj { inj :: a -> b ; proj :: b -> a }
18:29:46 <Cale> You're going to have to show me at least one of these examples.
18:30:14 <Cale> My assumptions about my Bool class mean that there's only two values of your other type anyway.
18:30:20 <Cale> So why not just use Bool in the first place?
18:30:24 <mmorrow> (or s/Iso/InjProj/ if in your context Inj and Proj will not be appropriate terms to use)
18:30:32 <mmorrow> err, split that s///
18:30:35 <mmorrow> gah!
18:30:35 <Peaker> Cale: I was wanting this for FRP Behaviors, though it doesn't make sense there, because you can't "if" on a behavior
18:30:37 <mmorrow> flip
18:31:06 <Peaker> Cale: It still could be nice for Traced Bools, but I guess its already much less useful
18:31:21 <Cale> We'd probably want  toBool . fromBool and fromBool . toBool to both be id, anyway...
18:31:46 <Cale> Now, having a nice class for Lattices and other kinds of orderings would indeed be very nice.
18:31:47 <dmwit> BMeph: Although that is a really good idea.  Any clue about whether there's any movement to actually implement it?
18:31:57 <Cale> But I don't think a class for booleans specifically is needed.
18:31:57 <Peaker> Cale: What are lattices?
18:32:14 <hackage> Uploaded to hackage: OneTuple 0.2.0
18:32:16 <Cale> http://en.wikipedia.org/wiki/Lattice_(order)
18:34:28 <BMeph> dmwit: It's probably in the thick stack of "Milestone: Haskell'''''''''''''''" proposals. ;)
18:34:42 <dmwit> heh
18:34:44 <dmwit> also =/
18:35:13 <Cale> Class aliases are one of the extensions I most want to see implemented.
18:35:46 <shapr> @users
18:35:47 <lambdabot> Maximum users seen in #haskell: 518, currently: 463 (89.4%), active: 13 (2.8%)
18:37:32 <BMeph> So, what's the time limit on being "active"? :)
18:39:50 <Peaker> If I create create a class for a type, make a method for each data constructor (e.g just/nothing methods), and a method for the catamorphism (e.g a maybe method),  is this class usable just like the data type?  Would that make it possible to create an alternate less verbose data type that is equivalent to another?
18:39:57 <Peaker> s/create create/create
18:40:10 <dmwit> You can't pattern match on class functions.
18:40:23 <dmwit> This really bites, because the most useful pattern matches are deep.
18:40:23 <Peaker> dmwit: Yeah, but I can extract the data with the catamorphism
18:40:32 <dmwit> Not as conveniently.
18:41:02 <Peaker> hypothetically, with possible language support for convenient pattern matching using the catamorphism?
18:41:08 <dmwit> f (Left (Left (Left x))) = x; f (Right (Left y)) = y -- really annoying to represent as a catamorphism
18:41:24 <dmwit> Also, catamorphisms can't represent partial functions, though I might consider that a positive side-effect. =P
18:41:41 <Peaker> dmwit: what do you mean?
18:41:56 <dmwit> Peaker: For example, 'f' as defined there *cannot* be written using only "either".
18:42:09 <Peaker> dmwit: oh, you have to handle all the cases, yeah
18:42:14 <Peaker> dmwit: you could give undefined...
18:42:40 <dmwit> Yep, but then you get a different exception.
18:43:28 <mauke> pmf = error "pattern match failure"
18:44:03 <mauke> either (either id pmf) (either id pmf) pmf
18:44:10 <mauke> hmm
18:44:20 <Peaker> well, this could theoretically allow mmorrow to define his own Either with less verbose constructors, but still enjoy the various libraries for Either, no?
18:46:22 <mib_izd2mka1> test
18:46:22 <mib_izd2mka1> > 1+1
18:46:23 <lambdabot>   2
18:46:36 <Cale> There was a guy working on a system for formalising mathematics in which proofs could be transparently applied across isomorphisms of all types, but the system apparently had a semantics valued in the category of homotopy types, and sounded like it was in very early stages.
18:46:53 <mib_izd2mka1> hey guys, i have a problem with lists ["orange"] ['apple", "pear", "orange"]
18:47:18 <Cale> mib_izd2mka1: Note that 'apple" is a syntax error, just in case that's the problem ;)
18:47:31 <mib_izd2mka1> oh
18:47:33 <mib_izd2mka1> my god
18:47:37 <mib_izd2mka1> quotes -_-"
18:47:40 <mib_izd2mka1> your eyes are sharp
18:47:58 <ddarius> Frank Atanassow was working on a language or language extension that would automatically use isomorphism between types in some way.
18:48:05 <BMeph> dmwit: Found the ticket: http://hackage.haskell.org/trac/ghc/ticket/788
18:48:07 <mib_izd2mka1> thats my first problem ^_^ thanks cale
18:48:07 <lambdabot> Title: #788 (Class aliases (as proposaed by John Meacham)) - GHC - Trac
18:48:40 <jeffz> mib_izd2mka1: if you use an editor with syntax highlighting you would have been able to spot it much more easily
18:48:44 <ozy`> mib_izd2mka1: syntax highlighting would spot that for you :p
18:49:03 <BMeph> dmwit: Oh, my bad - it's 'milestone: _|_' :P
18:49:05 <Cale> ddarius: He had some bizarre construction called the homotopy lambda calculus. :)
18:49:06 <halberd> Here is a difficult problem:  you have objects with arbitrary velocities and positions, of varying masses, placed along the number line where each object has a set width, and the objects can collide partially elastically, and the goal is to simulate this so that no two objects ever intersect
18:49:47 <dmwit> halberd: 1D physics?
18:49:49 <halberd> I tried to solve this using doubles but floating point rounding errors actually become a problem
18:50:00 <halberd> 1D for simplification to get away from all the other issues of collision detection
18:50:03 <ddarius> Cale: Sounds interesting.
18:50:18 <dmwit> halberd: Have you heard of "swept volume collision detection"?
18:50:19 <mib_izd2mka1> my 2nd problem is how do i produce a list of Int? fruitSelection :: [String] -> [String] -> [Int] . Example: ["ice","lol","pear"] -> ["car","ice","lol","box","pear"]  -> [1, 2,4]
18:50:24 <halberd> my attempt was actually 2D but that is irrelevant
18:50:41 <mib_izd2mka1> how do i do comparison in haskell  so it would produce a list of Int
18:50:50 <halberd> yes dmwit I have heard of that but I don't believe it guarantees non-intersection
18:50:52 <humasect> > 1 % 3 / 3 % 20
18:50:53 <lambdabot>       No instance for (Integral (Ratio t))
18:50:53 <lambdabot>        arising from a use of `show...
18:50:55 <Cale> mib_izd2mka1: First of all, work it out for looking up just one element
18:50:59 <ddarius> Cale: My introductory article on CT using spaces as categories and points as objects is somewhat stalled on how -not- to end up with omega categories.
18:51:01 <Cale> mib_izd2mka1: and then use map
18:51:09 <dmwit> halberd: Also, did you know that there's a pretty nice 2D physics library available called Hipmunk?  (Which does *not* use swept-volume collision detection.)
18:51:14 <halberd> it simply guarantees that a fast object won't hop over another one
18:51:35 <Cale> ddarius: Which category for a given space?
18:51:35 <ddarius> The library is Chipmunk, Hipmunk is just a binding.
18:51:40 <mib_izd2mka1> cale: First of all, work it out for looking up just one element >> what do you mean by looking up 1?
18:51:47 <cads> halberd: those object are moving according to just plain conservation of momentum?
18:51:50 <mib_izd2mka1> cale: does it involve an inbuilt function?
18:51:53 <dmwit> ddarius: Yes, yes.  I'm sloppy.
18:52:04 <halberd> haven't heard of hipmunk, but I am not just asking for a "reasonable" collision solution, I am trying to find one that guarantees non-intersection
18:52:12 <Cale> ddarius: The category of its open sets with arrows being inclusions?
18:52:18 <Cale> er, points being objects?
18:52:18 <ddarius> Cale: A category of paths roughly as the continuous image of an interval.
18:52:30 <halberd> my solution is actually okay because I added intersection spring forces in a separate phase to resolve intersections
18:52:31 <Cale> mm...
18:52:35 <Cale> okay
18:52:41 <ddarius> I.e. a super concrete way of visualizing categories.
18:53:01 <halberd> yeah cads but momentum need not be conserved so long as the collisions are "reasonable" and non-intersection is assured
18:53:06 <[mharrison]> arg.  How do I define a function that doesn't take any args?  So I can have "foo x" return "x+1" and "foo" return "defaultvalue + 1"?
18:53:06 <Cale> Do you perhaps mean the fundamental groupoid?
18:53:18 <humasect> @showmeanewtrick
18:53:19 <lambdabot> Unknown command, try @list
18:53:19 <ddarius> Cale: It leads to the fundamental groupoid, yes.
18:53:29 <mauke> [mharrison]: you don't
18:53:41 <dmwit> halberd: It seems like you should be able to calculate the time until the first collision.
18:53:50 <halberd> yes dmwit that is exactly what I did for my scheme
18:53:51 <Cale> [mharrison]: By "function that doesn't take any args" do you perhaps mean a constant?  foo = 5
18:53:52 <[mharrison]> I don't?  So I need to have foo x = x+1,  foo2 = default+1 ?
18:53:56 <halberd> the problem with that is floating point rounding errors
18:53:58 <ddarius> Cale: The problem is getting a strict 1- or 2-category out of it in a well-motivated way.
18:54:02 <dmwit> halberd: ah
18:54:04 <mauke> [mharrison]: depends on what you're really trying to do
18:54:07 <cads> halberd, can you use rootfinding to simply calculate the timepoints where objects collide?
18:54:13 <Cale> [mharrison]: Something can't be both an integer and a function.
18:54:19 <Cale> [mharrison]: You have to decide ;)
18:54:20 <halberd> yes that's what I did
18:54:31 <Peaker> [mharrison]: Haskell functions don't have defaults.. You can create a fooWithDefault function, or pass a record of args after updating it
18:54:32 <mib_izd2mka1> Cale: what function does it involve for finding 1 element?
18:54:34 <Cale> [mharrison]: (that's slightly a lie, since typeclass polymorphism can do that)
18:54:46 <Cale> mib_izd2mka1: You might use findIndex
18:54:49 <halberd> to do it with a guarantee of non-intersection I think you can't use floating points, you have to use a discrete space and velocities need to be discrete too
18:54:51 <Cale> :t findIndex
18:54:52 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
18:54:59 <Cale> er, or elemIndex
18:55:02 <Cale> :t elemIndex
18:55:02 <[mharrison]> Cale, oh geez.  I totally misspoke.  I'm trying to define something like:   "foo x = x + 1" if an argument is passed, and "foo = foo defaultval" if no arg is given
18:55:03 <dmwit> halberd: How about Rational?
18:55:03 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
18:55:16 <mib_izd2mka1>  @hoogle [String] -> Int
18:55:25 <halberd> I suspect that rational numbers would suffer from the same floating-point errors, or else become unreasonably large
18:55:27 <Twey> [mharrison]: You want optional arguments, in other words?
18:55:32 <dmwit> halberd: I bet that would really get you just about everything you want, with the single exception that velocities and positions wouldn't be *quite* as arbitrary as they used to be.
18:55:40 <dmwit> halberd: Rational never rounds.
18:55:40 <Cale> [mharrison]: Oh, you don't generally do that. You can with some typeclass hackery, but it's not usually advisable.
18:55:49 <halberd> I mean my solution's flaw is that it suffers from double-precision underflow
18:55:58 <[mharrison]> Cale, bummer, thanks.
18:56:00 <Cale> [mharrison]: You may want  foo :: Maybe Int -> Int
18:56:01 <dmwit> halberd: Rational never rounds.  Seriously.
18:56:03 <halberd> rationals that mimicked that exactly would quickly become huge
18:56:03 <Twey> Typeclass hackery or a list.
18:56:14 <dmwit> Well, that's true.
18:56:23 <Cale> [mharrison]: Like  foo Nothing = foo (Just defaultval); foo (Just x) = x + 1
18:56:37 <dmwit> halberd: What are you *doing* that has such weird requirements?
18:56:58 <Cale> mib_izd2mka1:
18:57:01 <halberd> ah well I'm just making a game, and for that my solution is sufficient, but this is an academic problem which would be interesting to solve
18:57:16 <Cale> > elemIndex "orange" ["apple", "orange", "pear"]
18:57:17 <lambdabot>   Just 1
18:57:38 <Cale> [mharrison]: The other way would be:
18:57:46 <Cale> class Foo t where
18:57:49 <Cale>    foo :: t
18:57:55 <Cale> instance Foo Integer where
18:58:05 <Cale>    foo = defaultval
18:58:09 <Twey> Haha, you can tell it's midterm season — the Java homework questions are on the uprise.
18:58:12 <[mharrison]> Cale, ack.  I'm just going to require an input value be specified..much easier
18:58:15 <Cale> instance Foo (Integer -> Integer) where
18:58:19 <Cale>    foo x = x + 1
18:58:28 <Twey> [mharrison]: That's the simple way.  :)
18:58:31 <[mharrison]> lol
18:58:32 <[mharrison]> ew
18:58:38 <mib_izd2mka1> Cale mib_izd2mka1:  you call me?
18:58:39 <[mharrison]> But thanks, good to know for outside-of-class coding
18:58:48 <mauke> Cale: and that requires a language extension
18:58:49 <Cale> mib_izd2mka1: Yes, to show you that elemIndex example
18:58:54 <mib_izd2mka1> oh
18:58:56 <mib_izd2mka1> thanks
18:58:57 <mauke> Cale: and lots of type annotations
18:59:01 <Cale> mauke: Oh? Which one?
18:59:06 <mauke> FlexibleInstances
18:59:06 <Cale> ah, right
18:59:08 <Cale> yes it does.
18:59:10 <Twey> [mharrison]: Optional arguments are considered stylistically bad, generally — since you lose type-safety
18:59:18 <[mharrison]> hmmm interesting
18:59:27 <cads> halberd: I've wondered about handing 2d collisions of geometric objects using arbitrary precision irration number classes
18:59:35 <Twey> If you have a function (a -> b) and the a argument is optional, there's no way to tell if it's of type (a -> b) or of type b
18:59:47 <halberd> I suppose you could use rational numbers to calculate collisions precisely, but then have a "cleanup stage" where you attempt to find safe, non-intersecting ways to round the positions of each object
18:59:47 <Twey> (until runtime)
19:00:33 <mib_izd2mka1> :t elemIndex
19:00:34 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
19:00:37 <Cale> Twey: hmm, I'm not sure about that
19:00:50 <Cale> Twey: It seems like the typeclass trick shows that it can be known statically.
19:00:54 <cads> halberd: right, some way of reigning in the precision level of the position and velocity vector, probably while objects are far away from each other/ in between collisions
19:01:10 <halberd> so that gives rise to another problem--given a set of intervals on the rational number line, how can you find a way to round each one to a given precision without intersecting them?
19:01:24 <mib_izd2mka1> :t findIndex
19:01:25 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
19:01:43 <Frowardd> Help me haskell mens! I forget which is camel and which is pascall: isItThis or IsItThis?
19:01:50 <mib_izd2mka1> hey guys , what does it mean by Maybe Int?
19:01:59 <mauke> @src Maybe
19:02:00 <lambdabot> data Maybe a = Nothing | Just a
19:02:00 <Cale> Frowardd: Those are both camelCase.
19:02:02 <Twey> Frowardd: They're both camel
19:02:02 <mib_izd2mka1> both elemIndex and findIndex produces a Maybe Int
19:02:10 <Frowardd> wait
19:02:12 <Frowardd> well what is pascall
19:02:15 <Frowardd> man I am confused
19:02:18 <Cale> pascall?
19:02:25 <cads> halberd, interesting problem
19:02:26 <Frowardd> pascel?
19:02:26 <Japsu> TheseAreTypesClassesOrConstructors and theseAreFunctions
19:02:26 <Cale> I don't even know what you mean :)
19:02:31 <Frowardd> The spellings, she does not love me so much.
19:02:36 <Twey> Cale: Well, no — you can't tell what type it is, just that it's a Foo
19:02:40 <Cale> Frowardd: What's your *real* question?
19:02:52 <Frowardd> THat actually is my real question.
19:02:55 <Frowardd> I am simple man, with simple needs.
19:02:56 <Twey> It could be either Integer or (Integer -> Integer)
19:02:59 <Cale> Twey: well, it has type  forall t. (Foo t) => t
19:03:01 <Peaker> would using TH be a reasonable approach to implementing class aliases?
19:03:01 --- mode: ChanServ set +o dons
19:03:02 * Twey nods.
19:03:04 <Twey> Precisely
19:03:11 <humasect> "the two alternatives upper camel case and lower camel case. Some people and organizations use the term camel case only for the latter, and refer to upper camel case as Pascal case."
19:03:13 <dmwit> Frowardd: Pascal is a programming language that is otherwise unrelated to Haskell.
19:03:21 <Cale> Frowardd: oh, well then your question does not make a whole lot of sense ;)
19:03:30 <Japsu> PascalCase, camelCase then
19:03:31 <Frowardd> Wait
19:03:31 <dmwit> Frowardd: Where did you get the idea that it referred to a capitalization technique?
19:03:32 <Twey> So while you don't exactly lose type-safety, you lose the ability to do anything other than call `foo` on it.
19:03:41 <Frowardd> Oh
19:03:46 <Cale> Frowardd: I was assuming that you were really asking a question about Haskell naming conventions, because I'm generous ;)
19:03:51 <Twey> Heh
19:04:03 <Frowardd> I am sorry! I have overridden the immediate usefullness of this channel (inr elation to myself) wiht a google!
19:04:04 <Frowardd> http://www.flexwiki.com/default.aspx/FlexWiki/PascalCase.html
19:04:15 <lambdabot> Title: Pascal Case
19:04:19 <cads> halberd, with the problem of the motion simulation, I think there are methods of analyzing the numerical stability, so that you can get a measure of how "good enough" your algorithm is, also an estimate of how precise real world measurements of a similar system could be
19:04:20 <Frowardd> Hererin is contained the answer to my question, of which you (excellent) fellows were ignorant
19:04:24 <halberd> I can formalize that further--you have a set of non-intersecting intervals on the rational number line and you want to map it to a set of intervals whose denominators are no greater than d, such that the distance between any endpoint of an interval and its image is less than epsilon, and none of the images of the intervals intersect
19:04:45 <Cale> Frowardd: That's odd. I would call both of them camel case.
19:04:55 <halberd> er, a set of intervals whose endpoints have denominators no greater than d
19:04:56 <Frowardd> I actually know nothing about haskell! someone recommended this channel to me becasue it is high traffic~! I do not know why they would do a despicable thing. I will now cease from polluting this channel with my drunken STOPUR.
19:05:05 <mauke> Cale: he's a troll
19:05:07 <Cale> Frowardd: hehe
19:05:10 <ozy`> Frowardd: I've never seen anyone distinguish "Pascal case" from camel case
19:05:14 <Frowardd> Cale, well man it's all semantics really, I mean who understands langauge as it continues to evolve.
19:05:18 <dons> mauke: should i act?
19:05:21 <Cale> ozy`: That website apparently seems to.
19:05:21 <humasect> camels have one hump
19:05:29 <mauke> CTCP Pirated reply from Frowardd: Xchat "offical nigger build" 2.8.7 running on JEWS JEWS JEWS
19:05:32 <Frowardd> dons, please do not ban me!
19:05:35 <Cale> humasect: Not all camels!
19:05:39 <Frowardd> dons, I will cease any action upon request!
19:05:41 --- mode: dons set +b *!*n=dDerf@*.hsd1.md.comcast.net
19:05:41 --- kick: Frowardd was kicked by dons (dons)
19:05:49 --- mode: ChanServ set -o dons
19:05:53 <dons> if you have to ask, then you're trolling.
19:06:03 <dons> cheers mauke
19:06:07 <humasect> Dromedary is the name of the one-hump camels. my bad=)
19:06:24 <Peaker> do some Haskell extensions get implemented with TH?
19:06:40 <dons> Peaker: people write "preprocessor" extensions in TH
19:06:53 <dons> but its lightweight enough we don't usually think of them as extensoins
19:06:59 <dons> they're usually specific to a particular app too
19:07:02 <Peaker> dons: I was looking at "class aliases", and it sounds as though it might be possible to implement with TH?
19:07:06 <cads> oh why in god's name does ghci in windows not have command completion *sudden panic attack*
19:07:16 <dons> cads, prob. no readline.
19:07:16 <humasect> can i do something like this in TH? -> map (\n -> import n) [Data.Rational,Data.Maybe,...]
19:07:19 <halberd> actually, rounding down should always be sufficient
19:08:23 <cads> halberd, I think rational numbers that are close enough together that you'd worry about them intersecting after being round will just be mapped to the same number
19:08:34 <[mharrison]> Unresolved overloading...wtfux, I'm not trying to overload anything!
19:08:40 <cads> s/round/rounded
19:08:55 <halberd> yes but you could reframe the problem slightly so that the intervals are open
19:08:57 <dmwit> [mharrison]: Probably the result of using "read".
19:08:59 <Peaker> dons: I haven't actually used TH, so maybe I'm overestimating its power
19:09:08 <dmwit> [mharrison]: Give an explicit type to read the value as.
19:09:14 <dmwit> (If that's what it is.)
19:09:27 <younder> cads Isuspect you mean real numbers as rational numbers are not rounded
19:09:30 <dmwit> return-type polymorphism woo woo!
19:09:56 <mib_izd2mka1> > elemIndex "orange" ["apple", "orange", "pear"]
19:09:57 <lambdabot>   Just 1
19:10:11 <mib_izd2mka1> > elemIndex ["orange","apple"] ["apple", "orange", "pear"]
19:10:12 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
19:10:13 <dmwit> halberd: As a side note, if you're using Doubles, but running into underflow, could you periodically scale your simulation so that all objects are in the range, say, [-100,100]?
19:10:25 <[mharrison]> dmwit, iterate (\r -> (mod (r*multp + incr) modu) / modu) seed  - addition of the " / modu" is what created the error
19:10:48 <dmwit> [mharrison]: mod and (/) don't have matching types:
19:10:49 <dmwit> :t mod
19:10:51 <lambdabot> forall a. (Integral a) => a -> a -> a
19:10:52 <dmwit> :t (/)
19:10:53 <lambdabot> forall a. (Fractional a) => a -> a -> a
19:11:02 <cads> younder, we're talking about a hypothetical operation that takes a rational number with a heavy representation and maps it to a nearby rational number which is less precise (or takes less data in its representation)
19:11:02 <dmwit> [mharrison]: It's hard to be both Integral and Fractional. ;-)
19:11:17 <dmwit> [mharrison]: Use `div` instead, or convert to a Fractional using fromIntegral.
19:11:19 <dmwit> :t fromIntegral
19:11:20 <lambdabot> forall a b. (Num b, Integral a) => a -> b
19:11:21 <dmwit> :t div
19:11:22 <lambdabot> forall a. (Integral a) => a -> a -> a
19:11:28 <humasect> > (1 / 40,1 `div` 40)
19:11:29 <lambdabot>   (2.5e-2,0)
19:11:44 <mib_izd2mka1> > elemIndex "box" ["apple", "orange", "pear"]
19:11:44 <[mharrison]> dmwit, yeah...I've been trying to figure out wtf it means by Integral since i'm not attemping any calculus =P
19:11:45 <lambdabot>   Nothing
19:12:00 <cads> hehe
19:12:02 <mib_izd2mka1> hey guys, umm so elemIndex only produces Just 1 and Nothing only?
19:12:06 <dmwit> [mharrison]: heh
19:12:06 <halberd> well actually I misspoke when I said underflow, what it really is, is that if you have an object sandwiched in a line of other objects, and each collision loses energy, it gets so close to its neighbors that slight rounding errors make it overlap the neighbors
19:12:10 <dmwit> ?instances Integral
19:12:10 <lambdabot> Int, Integer
19:12:12 <humasect> @src elemIndex
19:12:13 <lambdabot> elemIndex x     = findIndex (x==)
19:12:19 <halberd> the speeds underflow but that's not the real problem
19:13:19 <dmwit> halberd: Have you considered tolerating a little bit of overlap? =P
19:13:41 <humasect> > elemIndex 9999999 $ replicate 0 10000000
19:13:42 <lambdabot>   Nothing
19:13:53 <Twey> []
19:13:58 <humasect> yeah=)
19:14:01 <mib_izd2mka1> humasect = human + insect?
19:14:15 <mib_izd2mka1> just wandering
19:14:16 <halberd> dmwit: yeah my current attempt does that
19:14:17 <humasect> huma++sect
19:14:30 <dmwit> > elemIndex 9999999 $ [0..10000000]
19:14:32 <mib_izd2mka1> putStr"huma"++"sect"
19:14:32 <lambdabot>   Just 9999999
19:14:49 <halberd> well I'm going to try using arbitrary precision rationals and a round-down feature
19:14:49 <mib_izd2mka1> btw whats the difference between putStr and putStrLn
19:14:57 <araujo> a newline
19:14:57 <mauke> @src putStrLn
19:14:57 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
19:15:04 <jeffz> mib_izd2mka1: you should read your documentation
19:15:06 <mib_izd2mka1> oh thanks mauke
19:15:18 <ozy`> mib_izd2mka1: the (Just x | Nothing) dichotomy is for any situation where a function might have to signal that there's no applicable answer
19:15:19 <mib_izd2mka1> what kind of documentation should i read?
19:15:22 <Twey> 031457 < lambdabot> putStrLn s =  do putStr s; putChar '\n'
19:15:27 <Twey> Is that the case on Windows as well?
19:15:30 <mauke> Twey: yes
19:15:35 <humasect> mib_izd2mka1: http://www.haskell.org/ghc/dist/current/docs/libraries/index.html
19:15:35 <lambdabot> Title: Haskell Hierarchical Libraries
19:15:53 <Twey> So on Windows one would commonly do `putStrLn "foo\r"` or something?
19:15:58 <mauke> know your portable newline abstraction [spoiler]it's called \n[/spoiler]
19:16:04 <Twey> Oooh.
19:16:13 <Twey> I see
19:16:26 <cads> halberd, with inelastic collisions objects may stick together.. I think you could model that as considering such objects to be "in contact" with each other, and suspend collision checking between the two, as well as considering their speeds and locations to be one
19:16:36 <mauke> the I/O system converts between \n and whatever on-disk representation your OS uses
19:16:46 * Twey nods.
19:16:47 <mauke> unless you open the file in binary mode
19:17:11 <mauke> in conclusion, endl is completely overused in C++
19:17:25 <cads> halberd, that way if two objects are in contact, they won't drift together or randomly spring apart
19:17:40 <halberd> hm cads I could do that but it would add some complexity, I'm going to try the rationals + rounding first
19:18:10 <cads> sure
19:18:25 <mauke> (just for reference: foo << endl is the same as foo << '\n' << flush)
19:18:38 <[mharrison]> I daresay this is effing confusing.  map (\d -> d / v) funcThatReturnsListOfInts returns the crazy overloading integrals error.  But map (\d -> d / v) [the,list,of,ints,returned,by,the,previous,func] is fine
19:18:44 <mib_izd2mka1> thanks ozy
19:18:48 <mib_izd2mka1> thanks ozy`
19:18:59 <mauke> [mharrison]: [1,2,3] isn't a list of ints
19:19:02 <Cale> [mharrison]: / only works with fractional types
19:19:12 <Cale> [mharrison]: In particular, it does not work with Integer
19:19:13 <mauke> :t [1,2,3]
19:19:14 <lambdabot> forall t. (Num t) => [t]
19:19:24 <Cale> [1,2,3] is a polymorphic list of numbers
19:19:34 <ozy`> mib_izd2mka1: for what it's worth, my client highlights both of those, by the way :p
19:19:34 <mib_izd2mka1> cale": polymorphic list?
19:19:41 <Cale> mib_izd2mka1: yep
19:19:50 <mib_izd2mka1> cale : what is a polymorphic list?
19:19:51 <Cale> It could be a list of Double, could be a list of Integer
19:19:58 <Cale> or any other numeric type
19:20:02 <mauke> > [1,2,3] :: [Rational]
19:20:04 <lambdabot>   [1%1,2%1,3%1]
19:20:10 <mauke> > [1,2,3] :: [Complex Float]
19:20:11 <Cale> > [1,2,3] :: [CReal]
19:20:11 <lambdabot>   [1.0 :+ 0.0,2.0 :+ 0.0,3.0 :+ 0.0]
19:20:12 <lambdabot>   [1.0,2.0,3.0]
19:20:22 <mib_izd2mka1> cale: thanks! so it could be also called as numeric list?
19:20:30 <Cale> Sure if you like.
19:20:35 <[mharrison]> Polymorphic list of nums...mkay.  Haskell and I differ in our terminology =P
19:20:40 <Cale> The actual type is (Num t) => [t]
19:20:46 <Twey> Hahaha
19:21:00 <BMeph> mauke: Maybe you meant: "C++ is completely overused"? ;)
19:21:03 <mib_izd2mka1> oh learned something new, i always have the perception that number in a list = list of Int, or list of Float
19:21:21 <Cale> now, let's look at [mharrison]'s function
19:21:24 <[mharrison]> mib_izd2mka1, well, that would make sense.  Since that's how it works everywhere else =P
19:21:24 <mauke> BMeph: you are both right
19:21:35 <Cale> :t let f xs = map (/ 5) xs in f
19:21:36 <lambdabot> forall a. (Fractional a) => [a] -> [a]
19:21:47 <Cale> Oho, it works for any Fractional type at all.
19:21:52 <Cale> But Integer is not Fractional.
19:22:03 <Cale> However, [1,2,3] *could* be of a Fractional type
19:22:04 <humasect> ?instances Fractional
19:22:05 <lambdabot> Double, Float
19:22:31 <Cale> There's also Rational, Complex Double, CReal, and others, in libraries other than the Prelude :)
19:22:38 <cads> halberd, you might like to check out these fun little physics applets: http://kotsoft.googlepages.com/physicsdemos
19:22:41 <[mharrison]> :t randomInts seed multp incr modu = iterate (\r -> (mod (r*multp + incr) modu)) seed
19:22:49 <lambdabot> Title: kotsoft - physics demos
19:22:49 <lambdabot> parse error on input `='
19:22:49 <Cale> :t let f xs = map (/ 5) xs in f [1,2,3]
19:22:50 <lambdabot> forall t. (Fractional t) => [t]
19:23:22 <Cale> So now, applying this function to [1,2,3], we get a list of values which not only must be numbers, they must be numbers of a fractional type.
19:23:25 <mauke> :t let randomInts seed multp incr modu = iterate (\r -> (mod (r*multp + incr) modu)) seed in randomInts
19:23:26 <lambdabot> forall a. (Integral a) => a -> a -> a -> a -> [a]
19:23:31 <[mharrison]> :t take 10(let randomInts seed multp incr modu = iterate (\r -> (mod (r*multp + incr) modu)) seed)
19:23:32 <lambdabot> parse error on input `)'
19:23:38 <[mharrison]> Whoops
19:23:40 <ddarius> mauke: If you care enough about keeping buffers full, you know not to use endl.
19:23:43 <cads> http://kotsoft.googlepages.com/sanddemo.html is particularly impressive, from a collision detection perspective
19:23:44 <lambdabot> Title: Untitled Document
19:23:50 <Cale> However, if we try to apply the function to [1::Integer, 2, 3], we'll find that it fails:
19:23:55 <Cale> :t let f xs = map (/ 5) xs in f [1::Integer,2,3]
19:23:56 <lambdabot>     No instance for (Fractional Integer)
19:23:56 <lambdabot>       arising from a use of `f' at <interactive>:1:27-44
19:23:56 <lambdabot>     Possible fix: add an instance declaration for (Fractional Integer)
19:24:17 <BMeph> :t randomInts seed multp incr modu = iterate (\r -> (mod (r*multp + incr) modu)) seed in randomInts
19:24:18 <lambdabot> parse error on input `='
19:24:22 <humasect> @src returnA
19:24:22 <lambdabot> returnA = arr id
19:24:34 <BMeph> :t let randomInts seed multp incr modu = iterate (\r -> (mod (r*multp + incr) modu)) seed in randomInts
19:24:35 <lambdabot> forall a. (Integral a) => a -> a -> a -> a -> [a]
19:24:46 <Cale> [mharrison]: Does that make sense now?
19:25:07 <BMeph> :t let randomInts seed multp incr modu = iterate (\r -> ((r*multp + incr) / modu)) seed in randomInts
19:25:08 <lambdabot> forall a. (Fractional a) => a -> a -> a -> a -> [a]
19:25:16 <Cale> I suppose one last thing which should be said is that there's a defaulting rule
19:25:49 <Cale> If a module ends up with some ambiguous types that are only constrained by the numeric classes in the Prelude, then Haskell will default them.
19:26:05 <Cale> First it will see if Integer satisfies the constraints, and then Double
19:26:12 <[mharrison]> Cale, it makes as much sense as I expect Haskell to, yes
19:26:15 <Cale> (you can change the list of types to try using a default declaration)
19:26:24 <mib_izd2mka1> hmm
19:26:27 <mib_izd2mka1> > elemIndices 'a' "abbacca"
19:26:28 <lambdabot>   [0,3,6]
19:26:36 <mib_izd2mka1> could someone explain how does elemIndices works?
19:26:42 <humasect> @src elemIndices
19:26:42 <lambdabot> elemIndices x   = findIndices (x==)
19:26:57 <[mharrison]> But the rest of the universe lets me divide an int by another int and we call it a fraction
19:26:59 <Cale> When you write something like 5 in a Haskell source file, it actually means fromInteger (5 :: Integer)
19:27:12 <Cale> [mharrison]: But it's not an Integer, in general.
19:27:19 <mib_izd2mka1> humasect o_o *blur*
19:27:27 <Cale> Whereas:
19:27:27 <humasect> @src findIndices
19:27:28 <lambdabot> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
19:27:29 <Cale> :t (/)
19:27:30 <lambdabot> forall a. (Fractional a) => a -> a -> a
19:27:49 <Cale> The return type of (/) is the same as the type of its parameters.
19:27:56 <humasect> hm, Rational is not a Fractional ?
19:28:00 <Cale> It is.
19:28:01 <dmwit> [mharrison]: Incidentally, you can have fractions, too, if you want:
19:28:10 <Cale> Rational is not in scope for @instances
19:28:13 <mib_izd2mka1> what does elemIndices tries to do?
19:28:15 <dmwit> > (3%5) * (14%16)
19:28:17 <lambdabot>   21%40
19:28:18 <humasect> oh ok
19:28:32 <Cale> mib_izd2mka1: Finds all the locations in a list at which a given element occurs
19:28:33 <mib_izd2mka1> what is the purpose of elemIndices?
19:28:48 <Cale> > elemIndices 'a' "abracadabra"
19:28:49 <lambdabot>   [0,3,5,7,10]
19:28:53 <mib_izd2mka1> oh
19:28:57 <mib_izd2mka1> thanks cale for explaining
19:28:59 <Cale> > elemIndices 'a' "mississippi"
19:29:00 <lambdabot>   []
19:29:48 <Cale> mib_izd2mka1: findIndices on the other hand, finds all the locations in a list which satisfy a given predicate
19:30:02 <mib_izd2mka1> cale:L that would be useful for my problem
19:30:03 <Cale> > findIndices (>10) [1,54,2,5,23,8,46]
19:30:04 <lambdabot>   [1,4,6]
19:30:12 <Cale> yeah, it would
19:31:23 <Cale> There are a lot of ways to approach your problem. A list comprehension could also work really nicely.
19:31:53 <mib_izd2mka1> just wandering
19:32:04 <mib_izd2mka1> how do i join a list of number? like [5] ++ [1]
19:32:08 <Cale> yep
19:32:37 <mib_izd2mka1> thought ++ is only for strings o_o
19:32:39 <cads> I there anything more to list comprehesions that a function on some variables guarded by source lists for the values of the variables, and predicates that those values must fulfill?
19:32:44 <mib_izd2mka1> "45" ++ "54"
19:32:45 <Cale> nope
19:32:47 <Cale> :t (++)
19:32:48 <lambdabot> forall a. [a] -> [a] -> [a]
19:33:00 <cads> In other words, are list comprehensions all of the form [F(x1, x2,..., xn)| x1 <- xs1, x2 <- xs2,..., P1(x1,x2..), P2(x1,x2..),...] >
19:33:18 <Cale> cads: the predicates can be interleaved with the generators
19:33:23 <dmwit> cads: The bindings and predicates can be arbitrarily interleaved.
19:33:27 <Cale> cads: Also, there's let
19:33:31 <Cale> But essentially, yes
19:33:44 <cads> where does let come into that?
19:33:51 <dmwit> cads: You can also do pattern matches; this is equivalent to first filtering out the elements that do not match.
19:34:04 <dmwit> > [x | y <- [1..10], let x = y + 1]
19:34:06 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
19:34:19 <dmwit> cads: let can also be arbitrarily interleaved
19:34:24 <cads> ah
19:34:33 <Cale> > [(x,y) | k <- [0..10], x <- [0..k], let y = k - x]
19:34:34 <lambdabot>   [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2...
19:34:45 <dmwit> > [x | Just x <- [Just 3, Nothing, Just 5]] -- an example of the pattern match thing I was talking about
19:34:46 <lambdabot>   [3,5]
19:35:18 <dmwit> cads: If you grok the list monad, list comprehensions are pretty trivially convertible into do notation.
19:35:18 <halberd> cads: those physics sims are extremely neat
19:35:49 <cads> thanks for the examples
19:36:18 <mib_izd2mka1> list comprehension = higher order functions?
19:36:27 <dmwit> no
19:36:40 <mib_izd2mka1> why no?
19:36:41 <dmwit> List comprehensions are a convenient way of constructing lists.
19:36:57 <dmwit> Higher order functions are a convenient way of constructing functions. =P
19:37:08 <Cale> List comprehensions are syntax sugar for a bunch of concatMaps though
19:37:16 <Cale> :t concatMap
19:37:17 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
19:38:07 <mib_izd2mka1> thanks dmwit + cale
19:38:21 <Cale> mib_izd2mka1: I'm not sure you want me to give it away, but there's a *really* simple way to solve your problem with a list comprehension
19:38:43 <mib_izd2mka1> you could give  ^_^
19:39:01 <Cale> Well, okay...
19:39:02 <Cale> > [k | (k,x) <- zip [0..] "abracadabra", y <- "abc", x == y]
19:39:03 <lambdabot>   [0,1,3,4,5,7,8,10]
19:39:33 <ozy`> > let (^_^) = (+) in "pizza"
19:39:33 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 16}
19:39:33 <lambdabot> ...
19:39:45 <Cale> _ technically is not a symbol character
19:40:32 <Cale> mib_izd2mka1: do you see how that works?
19:40:56 <Cale> The elements of "abracadabra" are paired with their positions in the list, using zip [0..]
19:41:12 <Cale> and (k,x) is chosen from that list
19:41:20 <Cale> (of positions and elements)
19:41:36 <Cale> then y is chosen from the list of elements in the list of things we're looking for
19:41:48 <Cale> and if x is equal to y, then k, the index is returned
19:44:25 <mib_izd2mka1> im trying to figure out which part starts first
19:44:36 <Cale> (k,x) <- zip [0..] "abracadabra"
19:44:45 <mib_izd2mka1> ok
19:44:49 <Cale> and then y <- "abc"
19:44:54 <Cale> and then the test x == y
19:45:02 <Cale> But really, they're interleaved
19:45:13 <mib_izd2mka1> o_o
19:45:19 <Cale> It picks one such (k,x), the first one
19:45:25 <mib_izd2mka1> i kinda scared when i see those arrows <- phobia
19:45:30 <mib_izd2mka1> confusing
19:45:47 <mib_izd2mka1> i know that <- those arrows are used for monads
19:45:50 <Cale> So, to make an element of the list... it picks a pair (k,x)
19:46:04 <Cale> starting with the first one in the list zip [0..] "abracadabra"
19:46:08 <Cale> which is (0,'a')
19:46:27 <Cale> and then it picks a value for y from "abc", starting with the first one
19:46:31 <Cale> y = 'a'
19:46:42 <Cale> Then it checks to see if x == y
19:46:45 <Cale> 'a' == 'a'
19:47:05 <Cale> and so the element which goes into the list is given by the part before the |, which is k
19:47:08 <Cale> 0
19:47:17 <Cale> > [k | (k,x) <- zip [0..] "abracadabra", y <- "abc", x == y]
19:47:19 <lambdabot>   [0,1,3,4,5,7,8,10]
19:47:33 <Cale> So you can see that the first element is indeed 0
19:48:06 <Cale> Then it actually continues, picking a different y (a small inefficiency of this approach)
19:48:34 <pastorn> anyone have any experience with UTF? i have a good symbol that i want to rotate 180 degrees
19:48:49 <Twey> Uh
19:49:05 <Twey> I think you mean Unicode... but unicode doesn't allow for rotation
19:49:06 <pastorn> i looked at some manuals... i see it mentioned here and there, but no examples
19:49:17 <pastorn> mirroring then
19:49:19 <Cale> but of course, y = 'b' won't work, because x == y will fail there
19:49:20 <Twey> Maybe there's a rotated version of it already... what is it?
19:49:26 <Twey> No, it doesn't allow that either
19:49:30 <pastorn> an arrow
19:49:38 <Riastradh> pastorn, may I suggest the Unicode book, so that you get a sense of what Unicode is about, and of its terminology?
19:49:53 <dmwit> Mirroring is possible, I think.
19:50:03 <dmwit> At least upside-down is possible, no?
19:50:12 <Twey> pastorn: Paste it here
19:50:27 <Twey> ↑↓←→
19:50:41 <pastorn> Twey: not those... hang on...
19:51:28 <Twey> dmwit: No — not explicitly
19:51:38 <pastorn> ↩ ↪
19:51:47 <Twey> dmwit: There are just a lot of Unicode characters that happen to look like other Unicode characters
19:51:50 <pastorn> or maybe ↺ ↻
19:52:04 <pastorn> i want those turned upside down...
19:52:31 <pastorn> Riastradh: how thick is the book?
19:52:35 <pjdelport> ↶ ↷ ?
19:52:41 <pastorn> pjdelport: no
19:53:06 <pastorn> i't supposed to symbol a 90 degree turn
19:53:20 <pastorn> for someone walking upwards
19:53:28 <pastorn> so to speak...
19:53:40 <Twey> pastorn: I'm sorry, I don't think that's possible
19:53:43 <pjdelport> ↰ etc?
19:53:55 <Twey> pastorn: http://www.alanwood.net/unicode/arrows.html — here are all your Unicode arrows
19:53:57 <lambdabot> Title: Arrows - Test for Unicode support in Web browsers
19:54:13 <Twey> See if you can't find one that suits
19:54:25 <mib_izd2mka1> thanks cale, now i understand how the code works :)
19:54:51 <Twey> Hmm
19:54:54 <Cale> Somewhat more efficient would be:
19:55:06 <Cale> > [k | (k,x) <- zip [0..] "abracadabra", x `elem` "abc"]
19:55:07 <lambdabot>   [0,1,3,4,5,7,8,10]
19:55:12 <Twey> If I have a list: [[a, b], [c, d]]
19:55:25 <Cale> (but of course, you need to know about elem for that :)
19:55:33 <mib_izd2mka1> but
19:55:46 <mib_izd2mka1> cale": why does it only stop at a in y<-abc
19:55:47 <Twey> And I want to do something like: do a <- thatlist !! 1; b <- thatlist !! 2; [a, b]
19:55:53 <mib_izd2mka1> cale: it does not auto loop?
19:56:01 <Cale> mib_izd2mka1: It doesn't, it continues with y = b
19:56:01 <Twey> Can I arrive at the list [a, b] without having to manually assign each of those?  Some sort of map?
19:56:06 <Cale> and y = 'c' as well
19:56:42 <_ar> how do i make something deriving Eq, Show if it's constructor is a GADT
19:56:42 <pjdelport> > findIndices (`elem` "abc") "abracadabra"
19:56:43 <lambdabot>   [0,1,3,4,5,7,8,10]
19:57:11 <Cale> _ar: you can't
19:57:16 <mib_izd2mka1> cale: umm so y value has 'a' and it checks through abracadabra, but it does not use b to check 1 more time, and later c another time?
19:57:16 <dmwit> _ar: Sorry, you're out of luck.
19:57:22 <Cale> _ar: you have to write the instance by hand
19:57:37 <Cale> mib_izd2mka1: It does use b and c to check.
19:57:38 <_ar> okay i get it
19:57:44 <Cale> mib_izd2mka1: Of course, those tests fail.
19:57:45 <pjdelport> > sequence [[a, b], [c, d]]
19:57:46 <lambdabot>   [[a,c],[a,d],[b,c],[b,d]]
19:57:51 <mib_izd2mka1> if it uses b and c, wouldn';t it produce 2 more lists?
19:57:56 <pastorn> > System.IO.UTF8.putStr "\x21b0 \x21b1" -- might work
19:57:56 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
19:57:57 <pjdelport> Twey: that?
19:57:59 <Twey> Hmmm
19:58:00 <Cale> mib_izd2mka1: 2 more elements you mean?
19:58:03 <mib_izd2mka1> cale : just like the 'a' value
19:58:11 <Twey> pjdelport: Yes, that's it.  Thanks :)
19:58:11 <Cale> mib_izd2mka1: Note that we have a condition which says x == y
19:58:22 <Cale> mib_izd2mka1: So unless x == y, we don't put that k in the list.
19:58:42 <Cale> mib_izd2mka1: It might be clearer if we change the list a bit:
19:58:43 <pastorn> Twey: thanks for the link, i was looking for something like that, but unicode.org isn't the easiest site to navigate
19:58:53 <Cale> > [(k,x,y) | (k,x) <- zip [0..] "abracadabra", y <- "abc", x == y]
19:58:54 <lambdabot>   [(0,'a','a'),(1,'b','b'),(3,'a','a'),(4,'c','c'),(5,'a','a'),(7,'a','a'),(8...
19:59:13 <mib_izd2mka1> oh
19:59:18 <Cale> mib_izd2mka1: So this is now telling us the k, x, and y for which the test succeeded.
19:59:20 <mib_izd2mka1> now it makes sense :D
19:59:34 <Cale> and if we remove the condition x == y
19:59:37 <Cale> > [(k,x,y) | (k,x) <- zip [0..] "abracadabra", y <- "abc"]
19:59:39 <lambdabot>   [(0,'a','a'),(0,'a','b'),(0,'a','c'),(1,'b','a'),(1,'b','b'),(1,'b','c'),(2...
19:59:42 <Twey> pastorn: Aye, I noticed :(
19:59:50 <Cale> You can see all the tests which would be taking place.
20:00:02 <_ar> Cale, dmwit: when i put Eq (Actor) => ActorClass Actor in my instance i get "non type-variable argument in constraint... -XFlexibleContexts ...". Am I doing this wrong?
20:00:11 <_ar> @paste
20:00:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:00:16 <Cale> Of course, this doesn't take advantage of the fact that we know that at most one element of "abc" will be equal to x
20:00:43 <_ar> http://hpaste.org/11088
20:00:52 <Cale> _ar: Actor is either an instance of Eq, or it is not
20:01:03 <Cale> _ar: Which makes your condition redundant.
20:01:16 <Cale> (this is something which you must already know)
20:01:36 <Cale> Have you written an instance of Eq for Actor?
20:01:49 <Cale> If so, then delete that constraint because you know that it's true.
20:02:01 <Cale> If not, then you should either write one, or not write this instance ;)
20:02:37 <Cale> Typeclass constraints always constrain type variables.
20:03:01 <_ar> i see
20:03:18 <_ar> i was confused. i thought i could somehow force future instances to be eq
20:03:23 <_ar> instead of implementing it for the class
20:03:36 * BMeph has lots of experience with double-U-T-F...
20:04:16 <Cale> _ar: I'm not sure what you mean
20:04:29 <Cale> _ar: this is just one instance
20:05:06 <Cale> _ar: when you put typeclass constraints on a (polymorphic) instance, it constrains the conditions under which the instance applies
20:05:14 <_ar> Cale: i thought by writing an eq constraint in the class definition i was requiring those things which are instances of the class to also be instances of eq
20:05:21 <Cale> ah, you are
20:05:39 <Cale> class Eq a => ActorClass a where ...
20:05:58 <Cale> It's still supposed to be a type variable there ;)
20:06:08 <Cale> (but you said you were writing an instance)
20:06:15 <Twey> pastorn: ↱ and ↰ sound like your best bet for a 90° turn from vertical
20:06:48 <pastorn> yeah, but i like the round ones :/
20:07:06 <Twey> Oh ah :-\
20:07:31 <pastorn> how decided what arrows to put in? was this bell labs doing?
20:07:34 <_ar> you have to forgive me, the exact notions of instances, types, classes, and inerhitance are all mush =). my intuition is very heavily tainted by c++
20:07:50 <Cale> _ar: yes, these words mean completely different things in Haskell
20:07:56 <Twey> pastorn: Pass
20:08:03 <_ar> i'm still working to overcome this
20:08:15 <Cale> "U+034F COMBINING GRAPHEME JOINER" ... "the name of this character is misleading; it does not actually join graphemes"
20:08:22 <Twey> Hahahaha
20:08:25 <Twey> Nice
20:09:01 <dmwit> pastorn: It sounds like you actually want graphics, not text.
20:09:07 * Twey nods.
20:09:37 <pastorn> dmwit: i do, but terminals are simpler
20:09:55 <pastorn> the fewer dependencies, the better
20:10:11 <Cale> H҉E҉L҉L҉O҉
20:10:19 <Cale> Unicode is insane. ;)
20:11:01 <dmwit> pastorn: If you are using text, use *text*.
20:11:15 <dmwit> Say, "walk to the east, then north" instead of using a little arrow.
20:11:24 <Twey> Cale: Cripes!
20:11:26 <dmwit> Or whatever it is the arrow means.
20:13:23 <Cale> U+2061 FUNCTION APPLICATION
20:13:28 <Cale>  • contiguity operator indicating application of a function
20:13:33 <Cale> [not a printable character]
20:15:10 <pastorn> dmwit: yeah, i will make one mapping to ascii and one to unicode
20:15:10 <pastorn> unicode will probably be available through $ prog --pretty
20:19:06 <mib_izd2mka1> cale, the lesser comma in a function means more efficient?
20:19:24 <mib_izd2mka1> [k | (k,x) <- zip [0..] "abracadabra", x `elem` "abc"]  vs [k | (k,x) <- zip [0..] "abracadabra", y <- "abc", x == y]
20:19:39 <Cale> mib_izd2mka1: Well, not necessarily, but generally, if you're picking from fewer lists, you'll have less work to do.
20:19:53 <Cale> In the first one, you have to consider the efficiency of elem
20:20:02 <papermachine> Cale, what is that weird text from?
20:20:09 <Cale> The only advantage it has over the latter is that elem stops when it finds the element.
20:20:23 <Cale> papermachine: Descriptions of Unicode characters.
20:20:42 <papermachine> Cale, specifically the HELLO with dots around it
20:20:48 <mib_izd2mka1> cale: example of stopping?
20:20:58 <Cale> papermachine: Oh, I just made that myself.
20:21:13 <Cale> > 5 `elem` [1..]
20:21:14 <lambdabot>   True
20:21:24 <mib_izd2mka1> oh,
20:21:27 <Cale> mib_izd2mka1: If it didn't stop, that would never have returned true :)
20:21:27 <mib_izd2mka1> ok :)
20:21:49 <_ar> Cale: if i wanted to define Show a for all a of class ActorClass, how would i write that instance?
20:21:51 <papermachine> Cale, Oh, I thought Unicode had a whole table of dotted letters :(
20:21:54 <mib_izd2mka1> makes sense :D
20:22:20 <mib_izd2mka1> that sounds like considering how lazy would the function be?
20:22:31 <mib_izd2mka1> the lazier = more efficient
20:22:57 <dmwit> papermachine: Unicode has a character that says to surround the next character with dashes like that.
20:22:59 <mib_izd2mka1> am i right/wrong?
20:23:03 <Cale> papermachine: No, it has one combining form which puts dots around stuff :)
20:23:18 <dmwit> papermachine: It's to signify millions in some culture (Japanese?).
20:23:20 <Twey> papermachine: It was U+0489 COMBINING CYRILLIC MILLIONS SIGN
20:23:29 <dmwit> Russian
20:23:32 <Cale> _ar: That instance will require the "undecidable instances" extension.
20:23:33 <Twey> Cyrillic
20:23:36 <papermachine> I wonder how hard it would be to convince the UTF people to sneak cursive lojban into it.
20:23:42 <Twey> Other languages than Russian use cyrillic
20:23:46 <dmwit> ok
20:23:54 <Twey> papermachine: srilermorna?
20:23:59 <_ar> Cale: so i am likely structuring my program incorrectly?
20:24:10 <papermachine> aye.
20:24:15 <Cale> _ar: Not necessarily...
20:24:17 <_ar> i mean if i am working against the grain to the point of requiring an extension
20:24:55 <Cale> _ar: But... it might be more straightforward just to write a function which is the equivalent of show without actually having an instance.
20:24:57 <Twey> papermachine: They don't like doing constructed languages, I think :-\  However, there is a constructed script registry that aims to regulate the use of the private use areas for constructed languages.
20:25:02 <_ar> i wonder if i'm trying to abstract things with classes where that isn't the appropriate abstraction in haskell
20:25:11 <Cale> _ar: that is possible.
20:25:12 <Twey> papermachine: We're aiming to use that for Lak's latest script.
20:25:28 <papermachine> Twey, I thought Klingon was in UTF-16
20:25:32 <papermachine> wtf.
20:25:32 <dmwit> no
20:25:38 <Twey> papermachine: No, it isn't
20:25:40 <dmwit> That is a common misconception.
20:25:40 <papermachine> I'm mistaken then.
20:25:45 <papermachine> Yay I'm common!
20:25:47 * Twey nods.
20:25:48 <Twey> Haha
20:25:48 * papermachine dances.
20:26:01 <papermachine> alrighty then.
20:26:24 <Cale> _ar: It's very easy to overuse typeclasses, because they taste so delicious, but after a while if you find out that you have lots of classes and very few instances, it can be somewhat unsatisfying.
20:26:58 <_ar> Cale: i guess there is no cure for that but experience
20:27:05 <Cale> yeah
20:27:17 <Cale> Also, something to consider is just a record type containing some functions.
20:27:49 <Cale> Which is equivalent to a typeclass, but allows you to pass around instances explicitly, and have more than one instance for a given type.
20:28:07 <_ar> oh that's an interesting idea
20:29:18 <Cale> Not always the right thing, but it's often a possibility which is overlooked.
20:29:53 <rdmltrs> does anyone know what the $ operator does?
20:30:04 <papermachine> rdmltrs, nothing
20:30:06 <_ar> @src $
20:30:06 <lambdabot> f $ x = f x
20:30:18 <_ar> it groups everything that follows it into a single argument
20:30:29 <Twey> ($) = id
20:30:29 <_ar> (saves you from putting ()'s)
20:30:32 <Cale> yeah, it binds as weakly as possible
20:30:35 <rdmltrs> ahh okay thank you
20:30:51 <cads> > :info $
20:30:51 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 8}
20:30:51 <lambdabot>  ...
20:31:00 <Cale> So you can write things like   f . g . h $ k x y
20:31:57 <Twey> (f . g . h) (k x y)
20:33:12 <rdmltrs> for some reason i thought it had something to do with forcing evaluation
20:33:18 <Cale> It's also extremely handy with functions whose last parameter is a do-block or a lambda which produces a do-block
20:33:38 <Cale> As a matter of fact, $! does have to do with forcing evaluation :)
20:33:46 <rdmltrs> ah okay
20:33:52 <rdmltrs> that clears up my confusion
20:34:16 <Cale> ($! is just like $, but forces the parameter up to determining its top-level constructor before applying the function)
20:34:56 <Cale> $ is also very handy when you have something which is taking a do-block or a lambda as its last argument
20:34:58 <Cale> like:
20:35:12 <Cale> forM [1..10] $ \x ->
20:35:18 <Cale>   do print x
20:35:25 <Cale>      getLine
20:35:34 <Twey> Isn't the $ unnecessary?
20:35:42 <sbahra> Hi.
20:35:52 <Twey> Lambdas extend as far as possible anyway, right?
20:35:54 <sbahra> What was the GHC extension to have ByteString overload String?
20:36:05 <Saizan> :t forM [] \x -> undefined
20:36:06 <lambdabot> parse error on input `\'
20:36:08 <sbahra> thoughtpolice was telling me about this yesterday.
20:36:33 <Saizan> :t forM [] (\x -> undefined)
20:36:35 <lambdabot> forall (m :: * -> *) b. (Monad m) => m [b]
20:36:45 <Cale> There's weird parsing issues with lambda if you don't surround it with parens normally.
20:37:02 <Cale> I actually don't quite understand why the $ or parens are needed myself.
20:37:06 <Twey> Hum.
20:37:24 <Saizan> sbahra: OverloadedStrings
20:37:30 <sbahra> Saizan, thank you.
20:39:43 <mib_izd2mka1> ["Orange","Pear", "Apple"] !! [0,1]
20:39:51 <mib_izd2mka1> > ["Orange","Pear", "Apple"] !! [0,1]
20:39:52 <lambdabot>   Couldn't match expected type `Int' against inferred type `[a]'
20:40:05 <mib_izd2mka1> hey guys, i received tihs problem, what does it mean?
20:40:36 <mib_izd2mka1> ["Orange","Pear", "Apple"] !! [0,1] >>> should produce ["Orange","Pear"]
20:40:44 <Twey> No it shouldn't
20:40:49 <papermachine> Why would it?
20:40:56 <Twey> > map (map (!!) [0, 1]) ["Orange", "Pear", "Apple"]
20:40:58 <lambdabot>   Couldn't match expected type `a -> b'
20:41:01 <Twey> Aw :(
20:41:17 <Twey> Oh, hmn
20:41:19 <papermachine> > map (["Orange", "Pear", "Apple"] !!) [0, 1]
20:41:21 <lambdabot>   ["Orange","Pear"]
20:41:25 <Twey> Oh, that's the one :)
20:41:30 <papermachine> ;)
20:41:37 <dblazakis> :t (!!)
20:41:38 <lambdabot> forall a. [a] -> Int -> a
20:41:47 <mib_izd2mka1> > [1,2,3,4,5] !! [1,2]
20:41:50 <lambdabot>   Couldn't match expected type `Int' against inferred type `[a]'
20:43:01 <papermachine> > map (map (flip . (!!)) [0, 1]) ["Orange", "Pear", "Apple"]
20:43:02 <lambdabot>   Couldn't match expected type `a -> b'
20:43:10 <papermachine> boo.
20:43:24 <mib_izd2mka1> woah thats strange
20:43:47 <mib_izd2mka1> thakns papermachine
20:43:49 <papermachine> Oh, I didn't need the dot.
20:44:09 <papermachine> > map (map (flip (!!)) [0, 1]) ["Orange", "Pear", "Apple"]
20:44:10 <lambdabot>   Couldn't match expected type `a -> b'
20:44:21 * papermachine shrugs.
20:45:55 <Saizan> > (map (!!) [0, 1]) `sequence` ["Orange", "Pear", "Apple"]
20:45:57 <lambdabot>   Couldn't match expected type `[[Char]]' against inferred type `Int'
20:46:12 <Saizan> > (map (flip (!!)) [0, 1]) `sequence` ["Orange", "Pear", "Apple"]
20:46:14 <lambdabot>   ["Orange","Pear"]
20:46:39 <papermachine> :t sequence
20:46:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
20:46:55 <papermachine> ah, I see.
20:47:15 <Saizan> m = ((->) [String]) here
21:03:33 <dmwit> > zipWith (!!) [0, 1] ["Orange", "Pear", "Apple"]
21:03:34 <lambdabot>   Couldn't match expected type `Int' against inferred type `[Char]'
21:03:39 <dmwit> er
21:03:44 <dmwit> > zipWith (flip (!!)) [0, 1] ["Orange", "Pear", "Apple"]
21:03:45 <lambdabot>   "Oe"
21:14:10 <mib_izd2mka1> > 1+1
21:14:11 <lambdabot>   2
21:14:15 <mib_izd2mka1> oh im alive
21:14:48 <mib_izd2mka1> eh, why is it so quiet
21:15:18 <mib_izd2mka1> hmm guys i have a problem with this [Int] -> [[String]] -> [[String]]
21:16:40 <mib_izd2mka1> how do i truncate and keep some elements from 2nd argument [[String]] ?
21:16:51 <mib_izd2mka1> based on the [Int]
21:17:01 <mib_izd2mka1> is there an inbuilt function to do that/
21:17:15 <jeffz> mib_izd2mka1: have you looked at the documentation for Data.List?
21:17:39 <mib_izd2mka1> no
21:17:51 <jeffz> why not?
21:18:01 <mib_izd2mka1> i do not have 1?
21:18:08 <mib_izd2mka1> is it on the net or something?
21:18:17 <jeffz> mib_izd2mka1: it's installed locally usually, but also here http://www.haskell.org/ghc/dist/current/docs/libraries/index.html
21:18:18 <lambdabot> Title: Haskell Hierarchical Libraries
21:18:32 <mib_izd2mka1> oh ok
21:18:42 <mib_izd2mka1> i'll book mark it now :)
21:18:44 <jeffz> mib_izd2mka1: spend some time exploring.
21:19:05 <mib_izd2mka1> jeffz, you studied the whole libraries?
21:19:33 <jeffz> mib_izd2mka1: not in depth, but I refer to it daily
21:19:37 <Cale> mib_izd2mka1: You might also like to know that you can set your nickname on IRC with /nick <whatever> :)
21:20:15 <mib_izd2mka1> oh ok
21:20:22 <mib_izd2mka1> cale what name could you give me?
21:20:36 <Cale> I don't know, I'm just using my real name myself :P
21:20:59 <Cale> heh
21:21:08 <elac> lol reverse -_-"
21:21:11 <Twey> Haha
21:21:26 <Twey> 'Imitation is the sincerest form of flattery'
21:21:30 <Twey> So they say...
21:21:35 <TomMD> > reverse "Cale" == "elac"
21:21:36 <lambdabot>   False
21:21:41 <TomMD> lambdabot disagrees
21:21:47 <TomMD> Sensitive bot.
21:21:58 <yewT> > reverse "Cale" == "elaC"
21:21:59 <lambdabot>   True
21:22:03 <yewT> aha
21:22:21 <Cale> http://www.superpoop.com/101208/john-mccain-on-net-neutrality.jpg hehe
21:22:38 <yewT> why do i need to use a nick?
21:23:11 <Cale> yewT: Well, I suppose you don't have to. Mibbit gives you a random one.
21:24:43 <yewT> just wandering
21:24:53 <yewT> would drop be efficient to remove some element from a list?
21:24:57 <dmwit> s/a/o/
21:25:14 <Axman6> no one knows who you are when you use the mibbit nicks
21:25:29 <yewT> like ["apple", "pear", "orange"] >> ["apple", "pear"] >> i dropped orange so it forms a new list
21:26:24 <yewT>  drop "apple" ["apple", "pear", "orange"]
21:26:27 <yewT> >  drop "apple" ["apple", "pear", "orange"]
21:26:27 <Cale> yewT: That's not what drop does.
21:26:28 <lambdabot>   Couldn't match expected type `Int' against inferred type `[Char]'
21:26:34 <yewT> o_o
21:26:42 <Cale> yewT: drop removes elements from the beginning of a list
21:26:47 <Cale> (which is indeed efficient)
21:26:59 <yewT> >  drop 1 ["apple", "pear", "orange"]
21:27:00 <lambdabot>   ["pear","orange"]
21:27:05 <Cale> Removing them from the end is significantly less efficient, since the start of the list has to be rebuilt.
21:27:15 <yewT> >  drop 3 ["apple", "pear", "orange"]
21:27:15 <Axman6> > drop 10000 [1..]
21:27:16 <lambdabot>   []
21:27:17 <lambdabot>   [10001,10002,10003,10004,10005,10006,10007,10008,10009,10010,10011,10012,10...
21:27:47 <yewT> how do i specify an item to be dropped? like i want to drop number 3 which is orange, but it drops all 3
21:29:19 <pjdelport> > (++) <$> take 2 <*> drop 3 $ "abcde"
21:29:21 <lambdabot>   "abde"
21:29:21 <Axman6> you're not used to haskell programming are you
21:29:41 <yewT> axman6, you reffering to me?
21:29:41 <Olathe> > let dropOne 0 (_:xs) = xs; dropOne n (x:xs) = x:dropOne (n - 1) xs in dropOne 3 "zomg !"
21:29:43 <lambdabot>   "zom !"
21:29:52 <Axman6> yes
21:30:04 <yewT> yeah, i don't program haskell 24/7
21:30:18 <yewT> axman6 nor work as a haskell programmer
21:30:19 <Olathe> Why not ?
21:30:44 <dmwit> :t (uncurry (++) . second (drop 1) .) . splitAt n
21:30:44 <lambdabot>     The operator `.' [infixr 9] of a section
21:30:45 <lambdabot>         must have lower precedence than the operand `(.)' [infixr 9]
21:30:45 <lambdabot>         in the section: `(uncurry (++) . second (drop 1) .)'
21:30:46 <Axman6> i think you need to go through some tutorials and learn about the way things are done in haskell
21:30:50 <Axman6> yewT: neither do i, and i doubt many people here do
21:31:02 <dmwit> :t \n -> uncurry (++) . second (drop 1) . splitAt n
21:31:03 <lambdabot> forall a. Int -> [a] -> [a]
21:31:12 <Cale> > let remove n xs = take (n-1) xs ++ drop n xs in remove 2 ["apple", "pear", "orange"]
21:31:13 <lambdabot>   ["apple","orange"]
21:31:17 <Cale> er
21:31:57 <Cale> > let remove n xs = take n xs ++ drop (n+1) xs in remove 2 ["apple", "pear", "orange"]
21:31:58 <lambdabot>   ["apple","pear"]
21:32:06 <Cale> That's probably a better convention :)
21:32:07 <Twey> Heh
21:32:22 <Twey> Hm
21:32:34 <Cale> You could also use splitAt
21:33:05 <yewT> cale , why the 2 functions do differently?   ["apple","orange"] vs ["apple","pear"]. is the 2nd one starts from 0?
21:33:07 <Cale> But if you have to remove items from the middle of a list repeatedly, then probably a list is the wrong datastructure for you.
21:33:12 <Cale> yeah
21:33:22 <pjdelport> > (!! 2) $ zipWith (++) <$> inits <*> tail.tails $ "abcde"
21:33:23 <lambdabot>   "abde"
21:33:29 <pjdelport> har
21:35:06 <Cale> yewT: functions which refer to specific indices in lists are usually considered a bit unnatural
21:35:37 <yewT> why is it so?
21:35:48 <Cale> Because of the way that lists are built up.
21:36:01 <yewT> so i should use an array instead of list? o_o
21:36:19 <Cale> Every list in Haskell is either an empty list [], or it is a list constructed by adding an element to the beginning of another list.
21:36:21 <Cale> (x:xs)
21:36:25 <yewT> list to me its like array
21:36:40 <Cale> They're rather different.
21:37:08 <yewT> i guess i have not used array in haskell , usually i see list
21:37:11 <Cale> An array is in some sense constructed all at once as one flat structure, and can be accessed quickly anywhere.
21:37:22 <pjdelport> yewT: it depends what you're trying to accomplish
21:37:29 <Cale> Haskell has a number of types of arrays, and they can be indexed by various types.
21:37:37 <pjdelport> think of lists as being Haskell's version of loops, rather than arrays
21:37:40 <Cale> However, updating arrays anywhere is not cheap.
21:37:50 <yewT> not cheap?
21:38:04 <Cale> Because you have to copy the whole array.
21:38:29 <Cale> (Unless it's a mutable array, but those are only allowed in certain contexts)
21:38:35 <Nafai> pjdelport: lists as loops?  That's an interesting analogy
21:38:52 <Cale> Yeah, lists are a whole lot more like loops.
21:39:02 <inimino> even more like generators
21:39:06 <Cale> They're loops which have not yet happened.
21:39:24 <Nafai> inimino: I definitely can see the analogy to generators
21:39:25 <Cale> Or if you want, they're things to be looped over.
21:39:25 <yewT> are the higher order function which makes the list loop = list are a whole lot more like loops?
21:39:42 <pjdelport> inimino: generators are a more specific thing
21:40:02 <adu> yey! i did it!
21:40:05 <yewT> what is a generator?
21:40:25 <pjdelport> Haskell lists are like generator loops only to the same extent as they are like non-generator loops
21:40:26 <Cale> yewT: Well, if I understand what you're saying, yes, it's really in unison with higher order functions that lists become our loops.
21:40:42 <yewT> thanks cale
21:41:03 <yewT> so what is generator? create a random result out of a list?
21:41:04 <pjdelport> yewT: http://en.wikipedia.org/wiki/Generator_(computer_science)
21:41:18 <pjdelport> yewT: no, they're related to coroutines
21:41:22 <adu> yewT: i don't know about Haskell, but in math, {0, (+1)} is a generator for the naturals
21:41:47 <pjdelport> that's yet another different sense of generator :)
21:41:49 <Axman6> naturals aren't negative?
21:42:09 <Axman6> i'd never thought about that, makes sense...
21:42:13 <pjdelport> yewT: one way to think of it is that lists are "reified" loops
21:42:18 <inimino> pjdelport: a generator is like a lazy list in a way that other loops aren't
21:42:24 <pjdelport> and loops are "evaporated" lists
21:42:40 <adu> Axman6: correct, but whether or not 0 is a natural is a matter of debate
21:42:44 <pjdelport> inimino: that's a question of strict versus non-strict evaluation
21:42:48 <Axman6> heh
21:42:48 <Twey> iterate (+1) 0
21:42:51 <Twey> [0 ..]
21:42:51 <pjdelport> inimino: not lists versus generators
21:43:12 <inimino> pjdelport: well, yes, but Haskell is a lazy language
21:43:18 <pjdelport> right
21:43:21 <adu> > iterate (+1) 1
21:43:22 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
21:43:26 <pjdelport> so the comparison to generators is a red herring :)
21:43:41 <inimino> so if you have a Haskell list, what you have is a lot more like a Python generator than it is like a Python loop
21:43:55 <inimino> (that's not a generator)
21:43:58 <pjdelport> inimino: a Python generator doesn't necessarily contain any loop
21:44:12 <inimino> that's true
21:44:18 <inimino> but also irrelevant ;-)
21:44:25 <pjdelport> the Haskell list is like the Python loop (which happens to be contained in a generator, or not)
21:44:40 <pjdelport> the analogy is with the loop, not the generator
21:44:58 <Saizan> a list doesn't necessarily contain any loop either?
21:44:58 <inimino> only if you ignore laziness
21:45:00 <Cale> Something like s = 0; for i = 1 to 10; s <- s + i; print s  might be rewritten as  mapM_ print (scanl (+) 0 [1..10])
21:45:22 <yewT> pjdelport and loops are "evaporated" lists . what does it mean by evaporated list?
21:45:34 <pjdelport> yewT: it's not precise term, i just made it up
21:45:45 <yewT> what does it mean by evaporated?
21:45:54 <yewT> in the list term
21:46:11 <Cale> yewT: He means it in the sense that as you process a list, using it up, you're doing something loop-like.
21:46:27 <inimino> yewT: I thought he meant something like "reduced to its fundamental rule"
21:46:49 <pjdelport> yewT: what i mean is that the data structure (a list) and the control structure (a loop) are at a deeper level really the same thing
21:46:59 <pjdelport> you can turn one into the other
21:46:59 <adu> i finally did it: http://hpaste.org/6302#a1
21:47:25 <yewT> thanks cale, your explanation makes sense
21:47:29 <Cale> A loop either does nothing (because it's a loop over nothing) or it consists of doing something followed by another loop.
21:47:38 <pjdelport> there's a thing called list fusion
21:47:56 <yewT> list fusion = [5]++[1] ?
21:48:04 <pjdelport> nope
21:48:07 <pjdelport> that's concatenation :)
21:48:11 <yewT> o_o
21:48:14 <Cale> yewT: More like  map f . map g = map (f . g)
21:48:16 <pjdelport> if you have a program which produces a list, and then consumes in
21:48:16 <yewT> dragonball have fusion thingy
21:48:19 <pjdelport> consumes it, even
21:48:30 <pjdelport> then it turns out you never really need to construct the list to begin with
21:48:49 <pjdelport> you can "fuse" the list construction and deconstruction together
21:48:57 <pjdelport> to end up with a program that no longer involves any explicit list
21:49:00 <adu> yewT: fusion is when GHC recognizes that (concat . map) == concatMap and there is a better implementation for it...
21:49:02 <pjdelport> but still does the same thing
21:49:20 <pjdelport> the list data structure becomes the program's control structure
21:49:27 <Axman6> > foldl' (*) [1..1000000]
21:49:29 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
21:49:29 <lambdabot>        arising from a use...
21:49:37 <Cale> > foldl' (*) 1 [1..1000000]
21:49:37 <pjdelport> so the structure is still there, but the actual list is "evaporated"
21:49:41 <Axman6> that list isn't necessary
21:49:43 <Axman6> uh yes
21:49:46 <Cale> That's going to be a very large number.
21:49:50 <adu> yewT: in my incorrect opinion, fusion == optimization
21:49:52 <lambdabot>   thread killed
21:49:53 <Axman6> i hope so
21:50:02 <Axman6> > foldl' (*) 1 [1..100000]
21:50:12 <inimino> heh
21:50:17 <lambdabot>   thread killed
21:50:23 <Axman6> > foldl' (*) 1 [1..10000]
21:50:26 <lambdabot>   284625968091705451890641321211986889014805140170279923079417999427441134000...
21:50:38 <Cale> Yeah, 10000 factorial is a little more reasonable :)
21:50:44 <cp1134> is $ an operator?
21:50:48 <Cale> cp1134: yeah
21:50:49 <pjdelport> :t ($)
21:50:51 <lambdabot> forall a b. (a -> b) -> a -> b
21:50:52 <Axman6> >length . show . foldl' (*) 1 $ [1..10000]
21:50:55 <Cale> cp1134: It doesn't do much though :)
21:50:57 <Axman6> > length . show . foldl' (*) 1 $ [1..10000]
21:50:59 <Cale> @src ($)
21:50:59 <lambdabot> f $ x = f x
21:51:00 <lambdabot>   35660
21:51:09 <pjdelport> ($) = id
21:51:22 <adu> cp1134: one way of thinking of $ is as placing parens until the end of the expression
21:51:24 <Cale> cp1134: It's mostly just used because it binds very weakly to its arguments, which helps avoid parens.
21:51:32 <Cale> So you can write:
21:51:36 <Axman6> 4 is pretty useful sometimes
21:51:37 <Cale> f . g . h $ k x y
21:51:39 <Axman6> $*
21:51:39 <Axman6> heh
21:51:47 <Cale> Instead of (f . g . h) (k x y)
21:51:53 <cp1134> ah ok
21:51:56 <Cale> Or f (g (h (k x y)))
21:52:06 <inimino> 4 is useful too
21:52:06 <adu> Cale: I just do f $ g $ h $ k x y
21:52:31 <Cale> But that's not quite as nice, because (.) is a nicer operation than ($)
21:52:31 <adu> inimino: I never use 4
21:52:48 <inimino> adu: how do you count?
21:52:50 <adu> Cale: well if ($) was called (\) then it would be nice
21:52:53 <Cale> (and it relies on the fact that $ is declared as right associative)
21:52:56 <pjdelport> one, two, many
21:52:57 <adu> inimino: 1,2,3...
21:53:12 <Cale> (.) is associative which means that  (f . g) . h = f . (g . h)
21:53:12 <inimino> hehe
21:53:17 <Axman6> 1,2,3,2^2,5,2*3,7,2^3
21:53:28 <inimino> aha
21:53:30 <Cale> Which is useful in refactoring programs
21:53:35 <inimino> prime factors
21:53:50 <inimino> who needs 4 then, out with it
21:53:58 <adu> Cale: i guess thats why they call them composition monoids
21:54:13 <Cale> See... in  f . g . h $ k x y, we have that g . h is effectively a "subexpression"
21:54:22 <Cale> as is f . g
21:54:33 <Cale> But g $ h is not going to mean anything
21:55:05 <Cale> (It usually won't even typecheck!)
21:55:05 <adu> Cale: but doesn't that choke and say "first argument of h ($) has wrong type"
21:55:14 <Cale> That's my point.
21:55:34 <adu> Cale: then why are you saying "f . g . h $ k x y" if it won't work?
21:55:39 <Cale> It will work.
21:55:47 <adu> you just said it didn't
21:55:47 <Cale> I'm assuming that f . g . h $ k x y  works
21:55:52 <Cale> g $ h won't
21:56:06 <adu> I know "(f . g . h) $ k x y" works
21:56:07 <Cale> But g . h does
21:56:10 <McHomy_> fick en
21:56:19 <Cale> oh, (.) binds tightly
21:56:29 <adu> tigher than ($)?
21:56:34 <Cale> much
21:56:37 <adu> ok
21:56:39 <adu> you win
21:56:43 <Cale> infixr 9 .
21:56:45 <McHomy_> C++?
21:56:48 <Cale> infixr 0 $
21:56:58 <Cale> McHomy_: This is #haskell
21:57:13 <McHomy_> -.-
21:57:32 <adu> wow, muchmuch tighter
21:57:42 <Cale> McHomy_: Haskell is a nice purely functional programming language.
21:57:53 <McHomy_> dool
21:58:24 <adu> McHomy_: its #1 claim to fame is that it is pure, its #2 claim to fame is its unbelievable threading speed
21:58:26 <Twey> With a proper type system *ducks*
21:58:39 <McHomy_> teach me
21:58:44 * Axman6 wonders where the C++ came from in #haskell
21:58:46 <Axman6> C--
21:58:48 <dmwit> ?where learn
21:58:48 <lambdabot> I know nothing about learn.
21:58:51 <adu> C--
21:58:52 <dmwit> ?where learning
21:58:52 <lambdabot> I know nothing about learning.
21:58:52 <Cale> McHomy_: Well, there are some good books and tutorials we can point you at.
21:58:57 <dmwit> ?wiki learning
21:58:57 <lambdabot> http://www.haskell.org/haskellwiki/learning
21:58:57 <Axman6> just to keep lambdabot's score low
21:59:01 <dmwit> there
21:59:08 <Cale> http://book.realworldhaskell.org/read/
21:59:13 <lambdabot> Title: Real World Haskell
21:59:16 <McHomy_> i like c++
21:59:16 <dmwit> ?where gentle
21:59:16 <lambdabot> http://www.haskell.org/tutorial/
21:59:17 <rwbarton> ^^++
21:59:19 <adu> RWH++
21:59:19 <Cale> Is a newish book on Haskell
21:59:23 <ddarius> I believe there's an exception for C++
21:59:36 <McHomy_> but i'm here
21:59:38 <adu> McHomy_: then you will love typeclasses
21:59:42 <ddarius> Not even published is pretty new.
21:59:43 <Axman6> McHomy_: flist of factorials in haskell: facs = 1:1:zipWith (+) facs (tail facs)
21:59:49 <Cale> ddarius: It's not published?
22:00:10 <Cale> Axman6: you mean fib?
22:00:14 <Axman6> uh, fibonacci numbers even
22:00:16 <pjdelport> Axman6: you seem to be telling a fib
22:00:19 <Axman6> i do
22:00:20 <dmwit> > let fibs = 1:1:zipWith (+) fibs (tail fibs) in fibs -- McHomy_
22:00:21 <mmorrow> , let fib m n = m : fib n (m+n) in fib 0 1
22:00:21 <Cale> ahaha
22:00:21 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
22:00:22 <McHomy_> pls admin i'm from austria
22:00:23 <lunabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,109...
22:00:24 <Axman6> :)
22:00:58 <adu> McHomy_: you know the whole template<arg> thing? well, you don't need "<>" in Haskell :)
22:01:12 <Cale> > nubBy (\x y -> y `mod` x == 0) [2..]
22:01:13 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
22:01:34 <Cale> (while we're on the subject of numeric sequences ;)
22:01:37 <adu> > nubBy (((>1).).gcd) [2..]
22:01:39 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
22:01:45 <cp1134> is '<-' the assignment operator to a 'local' variable inside a do?
22:01:51 * ddarius doesn't understand #haskell sometimes.
22:01:56 <Cale> cp1134: It's a little different from that.
22:01:58 <dmwit> cp1134: Something like that.
22:01:58 <adu> cp1134: almost
22:01:58 <ddarius> cp1134: No.
22:02:03 <dmwit> bwahaha
22:02:09 * Axman6 is different
22:02:14 <Axman6> Cale: yes! yes it is!
22:02:19 <Axman6> cp1134*
22:02:35 <pjdelport> cp1134: let x = ... is a local variable inside a do
22:02:40 <cp1134> so in general i can't take a variable that has been assigned by '<-' inside a do and pull it outside the do and use '=' ?
22:02:45 <Cale> cp1134: If you write something like y = f(x) in C, it means to execute f(x) and update the memory location named y with the value returned.
22:02:56 <ozy`> > let muda = "MUDA " ++ muda in muda
22:02:58 <lambdabot>   "MUDA MUDA MUDA MUDA MUDA MUDA MUDA MUDA MUDA MUDA MUDA MUDA MUDA MUDA MUDA...
22:03:12 <pjdelport> cp1134: <- is for monadic binding
22:03:13 <Cale> cp1134: If you write y <- f x in a Haskell do-block, it means to execute the action f x and *name its result* y
22:03:35 <Cale> cp1134: That is, it's not like you're updating a memory cell, you're just giving a name to something.
22:03:37 <ddarius> ozy`: In Haskell we write that cycle "MUDA "
22:03:43 <cp1134> hmmm
22:03:43 <adu> cp1134: in my incorrect opinion, if 'expr' is of type 'a' then (x = b) is the right "assign" and if 'expr' is of type 'M a' (where M is a monad) then (x <- y) is the right "assign"...
22:04:00 <pjdelport> cp1134: for the list monad, for example, "x <- foo; ..." basically means "for x in foo: ..."
22:04:06 <ozy`> ddarius: I couldn't be bothered to look up the name of that function... Haskell's laziness is contagious
22:04:16 <adu> ozy`: lolol
22:04:18 <Cale> > (do x <- [1,2,3]; y <- [4,5]; return (x,y))
22:04:19 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
22:04:22 <ddarius> > fix . (++) $ "MUDA "
22:04:24 <lambdabot>   "MUDA MUDA MUDA MUDA MUDA MUDA MUDA MUDA MUDA MUDA MUDA MUDA MUDA MUDA MUDA...
22:04:33 <ozy`> @src fix
22:04:34 <lambdabot> fix f = let x = f x in x
22:04:45 <Cale> In the list monad, things get a little farther from assignment, as pjdelport points out.
22:04:49 <Axman6> someone correct me if i'm wrong, but x <- [1..10] means x is all the values 1..10 'at once' right?
22:04:59 <yewT> Axman6 is different << how does axman6 does that
22:04:59 <Cale> Axman6: or in turn.
22:05:17 <adu> Axman6: just about
22:05:18 <dmwit> yewT: /me
22:05:31 * yewT i am a newbie haskell
22:05:32 * Axman6 /me's
22:05:35 <yewT> cool :D
22:05:54 <Cale> > cycle "DESU "
22:05:54 <adu> Axman6: its more like it tries all the values in the list, and the ones that are happy make it to the final result
22:05:55 <lambdabot>   "DESU DESU DESU DESU DESU DESU DESU DESU DESU DESU DESU DESU DESU DESU DESU...
22:06:06 <Twey> Haha
22:06:27 <Cale> Somehow I knew that would get a laugh out of Twey.
22:06:37 <cp1134> so i'm looking at some code that does: x <- spawnPipe "foo" inside a do. I'd like to do it outside the do but x = spawnPipe "foo" doesn't seem to work... (i'm obviously very new to haskell)
22:06:38 <adu> Twey: are you japanese?
22:06:46 <Twey> Cale: Simple pleasures for simple minds :-P
22:06:51 <Twey> adu: いいえ
22:07:11 <pjdelport> @undo do x <- spawnPipe "foo"
22:07:12 <lambdabot>  Parse error at end of input
22:07:16 <adu> nice, getting a UTF8 compatible chat client finally paid off
22:07:17 <pjdelport> @undo do {x <- spawnPipe "foo"}
22:07:18 <lambdabot>  Parse error at "}" (column 25)
22:07:20 <Twey> Haha
22:07:23 <pjdelport> @undo do { x <- spawnPipe "foo"; x }
22:07:24 <lambdabot> spawnPipe "foo" >>= \ x -> x
22:07:27 <Cale> cp1134: okay, so x <- spawnPipe "foo" means to execute the IO action spawnPipe "foo" and name its result x
22:07:48 <Cale> cp1134: x = spawnPipe "foo" means define x to be the same action as spawnPipe "foo"
22:08:00 <Cale> cp1134: You can only execure IO actions from other IO actions.
22:08:02 <Axman6> isn't x >>= id a proper function someone?
22:08:04 <Cale> execute*
22:08:06 <Axman6> join perhaps?
22:08:08 <Axman6> @src join
22:08:08 <lambdabot> join x =  x >>= id
22:08:09 <Cale> Axman6: yes
22:08:19 <Axman6> whoot
22:08:50 <Twey> Hmm?
22:08:53 <Twey> x >>= id?
22:08:58 <Cale> cp1134: A do-block lets you glue a bunch of IO actions together into a larger one which runs some of them, possibly captures their results and uses those to determine what to do.
22:08:58 <Twey> Oh
22:09:00 <Twey> Yes
22:09:13 <Cale> cp1134: Eventually, your 'main' will be one of these IO actions.
22:09:24 <adu> Twey: 僕も、でも、日本語わかります
22:09:46 <Twey> adu: あそ？どこに住んでいますか
22:10:05 <Cale> cp1134: The upshot of this is that you cannot use spawnPipe from inside a function which is not meant to be doing IO. For instance, if your function has type  Integer -> Integer, then it absolutely cannot have executed spawnPipe
22:10:24 <cp1134> Cale: hehe, ok. i'll keep playing with it. i'm only through chp 2. in realworld haskell
22:10:24 * BMeph loves smoked and execured ham. ;)
22:10:36 <Cale> cp1134: It's also important to realise that simply evaluating IO actions does not cause their execution to occur.
22:10:45 <ozy`> I find "MUDA MUDA MUDA" to be a more timely meme than "DESU DESU DESU"... no pun intended, naturally
22:10:45 <cp1134> I was just looking through some xmonad.hs files and trying to make sense of them ;)
22:11:01 <adu> Twey: 大阪に
22:11:14 <Axman6> bogner: you'd love this place called poachers pantry here then. best smoked meats i've ever tasted
22:11:17 <Axman6> uh,  BMeph
22:11:18 <Cale> cp1134: You can think of an IO action of type (IO t) as little executable file which when run will produce a value of type t, but evaluating it doesn't cause it to run.
22:11:30 <Twey> adu: なるほど、だから日本語を
22:11:40 <Twey> いつから？
22:11:43 <ddarius> Hmm... bold text makes kanji hard to read.
22:12:03 <Twey> ddarius: I think most fonts don't have bold Han characters...
22:12:07 <Cale> cp1134: You can stick a bunch of them in a list, pass them to other functions, or whatever, without fear of causing them to execute inadvertently.
22:12:25 <cp1134> Cale: so how do you finally execute them?
22:12:39 <Cale> cp1134: Well, eventually main is executed by the Haskell runtime.
22:12:44 <ddarius> Twey: Then one of these kanji characters renders in a pretty difficult to read format.
22:12:47 <Cale> In turn, it will be built up from other IO actions.
22:12:51 <adu> Twey: and thats where ya lost me
22:13:00 <pjdelport> hence the statement that Haskell has first-class support for imperative programming
22:13:09 <adu> Twey: what does naruhodo mean?
22:13:20 <Cale> adu: roughly "I see"
22:13:28 <Twey> adu: 'I see, that's why <unspecif.> Japanese.  Since when?'
22:14:25 <ddarius> Twey: No, it has a bold font.
22:15:05 <Twey> ddarius: Oh ah :-\  Which font is that?
22:15:10 <Cale> I have at least one font on my machine with bold kanji. It's almost unreadable.
22:15:29 <Cale> (except in very large sizes, of course)
22:15:52 <Cale> cp1134: Does that make some kind of sense?
22:15:52 <ddarius> Bitstream Vera Sans Mono Bold
22:16:20 <ddarius> It's a reasonably pretty rendition especially when not bolded but not at 12 point.
22:16:32 <Cale> cp1134: For example,  main = do putStrLn "Hello, World!"; x <- myIOAction; print x
22:16:53 <adu> Twey: 1994から、2000まで、六年かんぐらい...
22:17:11 <Cale> cp1134: I should also make it clear how this does not necessarily (and usually should not) result in your whole program being written in the IO monad.
22:17:58 <Cale> cp1134: Note that we can write things like:  main = do x <- getLine; let y = processLine x; putStrLn y -- where processLine :: String -> String
22:18:37 <Twey> adu: あぁ、過去のことですか。まだ住んでいると思いました。
22:18:39 <Cale> cp1134: So because these IO actions (which are doing the actual input and output) can call our pure functions, we don't need to make everything be in IO.
22:18:40 <yewT> is it possible to use multiple let in 1 function?
22:18:57 <Cale> yewT: yes, though if they are together, you can merge them
22:19:01 <yewT> is it possible to use let without an in?
22:19:02 <cp1134> Cale: i'm slowly getting it
22:19:15 <Cale> yewT: let without in is part of the do-syntax
22:19:21 <yewT> i remember seeing a code with let without in
22:19:29 <Cale> But outside of do, it needs an 'in'
22:19:29 <yewT> so let = do?
22:19:34 <Cale> no
22:19:42 <Cale> do x <- getLine
22:19:47 <Cale>    let y = reverse x
22:19:54 <Cale>    putStrLn y
22:19:58 <cp1134> Cale: haskell is definitely very different from other languages i have used, so it is taking me a bit longer to pick it up
22:20:04 <Cale> cp1134: yeah
22:20:06 <Axman6> lets syntax is let something = somethingElse in f something right?
22:20:08 <Axman6> needs the in
22:20:10 <Cale> cp1134: That's to be expected :)
22:20:13 <newsham> y <- return $ reverse x
22:20:18 <yewT> ok thanks for clarifying cale
22:20:28 <Axman6> cp1134: once you get what's going on, you'll love it though
22:20:33 <newsham> no "in" is needed in a do-block.
22:20:35 <Cale> newsham: Except that's bad style :)
22:20:44 <Cale> newsham: no, actually, you can't do some things that way
22:20:54 <adu> Twey: がんばれね :)
22:21:00 <Cale> "y <-" is secretly a lambda binding
22:21:05 <Cale> and as such, it's monomorphic
22:21:22 <cp1134> are there any other free books available that you would recommend in addition to Real World Haskell?
22:21:37 <newsham> cp1134: you might not need another one ;-)
22:21:38 <Saizan> ddarius: i got to this as a definition of free applicative functor, but it could be simpler? http://hpaste.org/11091
22:21:40 <Cale> cp1134: There's "Yet Another Haskell Tutorial" and the Wikibook.
22:21:41 <rwbarton> also if y was a more complicated pattern, what happens on pattern match failure is different
22:22:03 <Axman6> cp1134: google for haskell tutorials, and do as many as you can
22:22:03 <TomMD> cp1134: the original SPJ books on STG is free these days.
22:22:07 <Cale> cp1134: If you're looking to purchase a dead tree book, then Graham Hutton's is supposed to be very good.
22:22:11 <Axman6> if you fine them hard, try others and come back once you're more experiences
22:22:19 <TomMD> Not that this is for the same audience as rwh.
22:22:33 <newsham> does spj's book on implementing miranda count?
22:22:43 <Axman6> is RWH designed for beginners?
22:22:48 <Cale> Axman6: yes
22:22:52 <newsham> rwh is a good book for beginners.
22:22:55 <Axman6> i got the impression is was a little more advanced
22:22:57 <Axman6> righto
22:23:16 <newsham> if the beginner is a non-programmer, I really like "two-dozen short lessons"
22:23:18 <Cale> It ends up in more advanced territory than most intro tutorials, certainly.
22:23:42 <Axman6> most RW* books aeem to skip any introduction, and go into building a webserver and messaging client
22:23:50 <Cale> http://en.wikibooks.org/wiki/Haskell
22:23:51 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
22:24:03 <Axman6> i've got Haskell: The art of functional programming. i've learnt a lot more here :\
22:24:05 <cp1134> i like RWH so far, but i'd also like a book similar too Python Essential Refernce
22:24:09 <Axman6> i also haven't read much of it
22:24:09 <Cale> http://en.wikibooks.org/wiki/Haskell/YAHT
22:24:27 <newsham> http://www.cs.ou.edu/~rlpage/fpclassCurrent/textbook/haskell.shtml
22:24:29 <lambdabot> Title: Two Dozen Short Lessons in Haskell, http://tinyurl.com/hl9mm
22:24:38 <Cale> cp1134: Eventually, you'll definitely want to know about the Report. http://haskell.org/onlinereport/
22:24:39 <lambdabot> Title: The Haskell 98 Language Report
22:24:39 <cp1134> basically a run down on the operators and stuff available in the libraries in addition to a solid intro book
22:24:46 <adu> cp1134: that scheme book SICP
22:24:57 <Cale> (which is the last defined standard, though the language has evolved significantly from that)
22:25:19 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html -- this is another extremely important reference
22:25:20 <lambdabot> Title: Haskell Hierarchical Libraries
22:25:34 <adu> cp1134: I didn't have RWH when I was learning Haskell, i learned from the report
22:25:38 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html -- and for more general libraries
22:25:43 <lambdabot> Title: HackageDB: packages by category
22:25:45 <adu> ahh page 26.... i remember the days
22:26:13 <adu> cp1134: have you read SICP?
22:26:39 <Cale> http://cs.anu.edu.au/Student/comp1100/haskell/tourofsyntax.html -- this is a nice tour of a good fragment of the basic syntax of Haskell.
22:26:41 <lambdabot> Title: Tour of the Haskell Syntax
22:26:45 <cp1134> adu: a few chapters here and there. no where close to working throught the whole thing. i've gone through more of "the little schemer"
22:26:52 <Baughn> dons: Kinda paused for sleep, but despite myself it's approaching completion now
22:26:55 <newsham> are there any symbolic mathematics libraries for haskell?
22:27:07 <Baughn> Nothing quite as horrible as waking up in the middle of a mental defragmentation cycle
22:27:11 <Cale> newsham: The closest thing I can think of is DoCon
22:27:15 <adu> newsham: Data.Number.Symbol
22:27:35 <Cale> http://www.haskell.org/docon/
22:27:36 <lambdabot> Title: DoCon the Algebraic Domain Constructor
22:28:01 <adu> newsham: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/numbers
22:28:02 <lambdabot> Title: HackageDB: numbers-2008.4.20, http://tinyurl.com/33mfjx
22:28:15 <newsham> ty
22:28:52 <Cale> newsham: I haven't really tried it though.
22:29:04 <newsham> hmm, neither of these do symbolic integration or differentiation do they?
22:29:08 <Cale> no
22:30:12 <Cale> I'm sure that if you wanted to implement the Risch algorithm, people would love it :)
22:30:18 <adu> newsham: the numeric-prelude might
22:30:52 <Cale> I doubt there's anything which does significantly more than polynomials in terms of symbolic integration.
22:31:28 <newsham> i dont know what the risch algorithm is
22:31:57 <rwbarton> Is that the one that's not really an algorithm?
22:32:48 <Cale> As far as I know, it's really an algorithm.
22:33:12 <Cale> It's a decision procedure for determining if an elementary function has an elementary integral, and if so, finding it.
22:33:37 <rwbarton> wikipedia: "Also, the Risch algorithm is not an "algorithm" literally, because it needs as a part to check if some expression is equivalent to zero."
22:34:06 <rwbarton> "And for a common meaning of what an "elementary function" is it's not known whether such an algorithm exists or not"
22:34:48 <Cale> I'm not sure that excludes it from being an algorithm. So it requires an oracle. ;)
22:35:03 <rwbarton> Well, OK :)
22:35:39 <adu> plenty of algorithms are like (if x == 0 then ...)
22:36:14 <jdrake> Now, there is one other function that is useful, which I'll call unit (in Haskell, we call it something else, but its name can confuse imperative programmers). unit just takes a normal value and makes it into a Maybe value by putting a Just in front of it: unit x = Just x       Being that I am programming in haskell, what is this 'unit' that may be confusing nature?
22:36:18 <Cale> adu: Well, in this case, x can be any symbolic expression, and you're asking if it's identically zero
22:36:40 <Cale> Though, that last paragraph on wikipedia is confusing.
22:36:44 <rwbarton> jdrake: 'return'
22:36:57 <ddarius> Saizan: That's a bit brute force, the issue is whether it is free in the appropriate sense.
22:37:09 <jdrake> Some hath suggested reading this: http://www.reddit.com/r/programming/comments/64th1/monads_in_python_in_production_code_you_can_and/c02u9mb
22:37:11 <lambdabot> Title: 808140 comments on Monads, in Python, in production code! -- "you can and should ..., http://tinyurl.com/4m4jae
22:37:12 <Cale> It says that if we add abs(x) to the list of elementary functions, then no such function exists, but abs(x) = sqrt(x^2)
22:37:23 <adu> jdrake: I think "return" is better than "unit"
22:37:50 <jdrake> hmm, that must be why they say it could confuse imperative programmers.
22:37:51 <dmwit> Cale: It just says no *algorithm* exists.
22:37:56 <newsham> jdrake: the syntax hack is somewhat interesting, but still a hack.
22:38:02 <adu> jdrake: its very comforting and refreshing to see familiar names and realize that they are greater and more general ideas than you thought they were...
22:38:05 <newsham> jdrake: i dont see what's so ugly about using lambdas.
22:38:08 <Cale> dmwit: er... yes
22:38:09 <Cale> :)
22:38:11 <dmwit> Cale: Oh, never mind me, I misunderstood what you were saying.
22:38:29 <Cale> dmwit: You were right to complain :)
22:38:32 <jdrake> So a monad is essentially that which has return and bind (>>=) defined for it?
22:38:45 <Cale> jdrake: yeah, and those satisfy a few simple laws
22:38:51 <pjdelport> jdrake: with the appropriate semantics
22:38:55 <Saizan> ddarius: i guess i'm not really sure what the expected relation with the underlying functor should be
22:39:04 <newsham> jdrake: http://www.thenewsh.com/~newsham/x/machine/monad.py
22:39:14 <ddarius> Saizan: The question is what is the "underlying" functor.
22:39:15 <jdrake> There is almost no function that I am not using monads, so I might as well get to know them better now
22:39:26 <newsham> only slightly harder to use bind with lambdas
22:39:36 <pjdelport> jdrake: a monad is just a fancier functor
22:39:36 <Cale> jdrake: http://www.haskell.org/haskellwiki/Monads_as_Computation
22:39:40 <jdrake> newsham, IT BURNS IT BURNS!
22:39:42 <lambdabot> Title: Monads as computation - HaskellWiki
22:39:43 <ddarius> Saizan: The issue is that there is more than one answer to that corresponding to different notions of "freeness"
22:39:49 <newsham> it doesnt burn
22:40:08 <adu> jdrake: yes
22:40:26 <newsham> (also it implements fmap and ap as operators)
22:40:34 <adu> jdrake: 'Monad' is an interface for anything that implements 'return' and (>>=)
22:40:49 <Cale> jdrake: I might recommend you check out that tutorial, and ask me questions (I wrote it)
22:40:57 * pjdelport doesn't like (>>=)
22:41:07 <rwbarton> newsham: ah, finally a python program I can read! :)
22:41:14 <jdrake> Cale, I might do that
22:41:16 <pjdelport> yay for join and lift
22:41:20 <jdrake> I am not sure that monads belong in python
22:41:24 <adu> pjdelport: I would perfer (;;) if Haskell syntax would allow it
22:41:25 <Cale> jdrake: It's brief, but I think it gets across some important bits which other more comprehensive tutorials leave out.
22:41:43 <pjdelport> adu: you mean >> ?
22:41:54 <adu> pjdelport: >> already has a meaning
22:41:55 <newsham> jdrake: I'm not sure graphs belong in python
22:41:57 <jdrake> Cale, I am interested in practical concerns rather than mathematics. Does the article satisfy that?
22:42:00 <newsham> after all, graphs are confusing
22:42:01 <rwbarton> adu: surely you don't want to replace >>= by ;;?
22:42:07 <pjdelport> adu: yes, that's what i'm getting at
22:42:11 <Cale> jdrake: To some extent :)
22:42:22 <jdrake> Cale, so I don't need a math degree?
22:42:23 <dmwit> ?go io monad for people who just don't care
22:42:25 <lambdabot> http://sigfpe.blogspot.com/2007/11/io-monad-for-people-who-simply-dont.html
22:42:25 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care
22:42:26 <Cale> jdrake: I don't explain how it connects to proper mathematics at all.
22:42:28 <adu> rwbarton: yes, thats what I was implying
22:42:42 <mm_freak> @src foldl
22:42:42 <lambdabot> foldl f z []     = z
22:42:42 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
22:42:51 <pjdelport> adu: ;; would suggest >>, not >>=
22:42:54 <adu> pjdelport: so swap (>>=) and (>>)?
22:43:00 <dmwit> ?src foldl'
22:43:01 <lambdabot> foldl' f a []     = a
22:43:01 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
22:43:01 <rwbarton> but but... >>= propagates a value
22:43:30 <Cale> jdrake: and it's mostly focused on the way of looking at things that makes the most common monads for functional programming make the most sense.
22:43:47 <jdrake> Cale, make sense to read then :-)
22:43:48 <adu> rwbarton: then (;=) maybe
22:43:55 <Cale> jdrake: Of course, like any good abstraction you can twist things around and look at them from a completely different angle.
22:44:08 <newsham> I agree with ">>=" being lame.
22:44:11 <ddarius> Saizan: One approach may be to look at what the applicative functors induced by free monads look like.
22:44:13 <newsham> it obviously shoulda been "=<<"
22:44:17 <newsham> :)
22:44:18 <Cale> :t (=<<)
22:44:19 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
22:44:26 <jdrake> newsham,  <<=
22:44:54 <dmwit> (<<=) doesn't look half bad
22:44:59 <Cale> =<< is nice in combination with the do-syntax
22:45:01 <jdrake> crazy bind: <<=>>  doesn't know which way its going!
22:45:01 <dolio> =<< doesn't work very well for writing imperative-like code.
22:45:18 <Cale> do x <- process =<< getThing
22:45:20 <newsham> dolio: perfect.  encourages applicative :)
22:45:22 <ddarius> dolio: print =<< getLine
22:45:24 <idnar> >>=<<
22:45:29 <dmwit> dolio: Either (>>=) or (.) is backwards, in my opinion.
22:45:49 <idnar> dmwit: (.) is obviously backwards
22:45:51 <pjdelport> dmwit: definitely (>>=)
22:45:56 <dmwit> There you have it.
22:45:59 <Axman6> i only rerally got (.) when i realised it was pipe in terminal, backwards
22:45:59 <Cale> If (.) is backwards then so is function application
22:46:00 <idnar> at least, (.) always confuses me :/
22:46:15 <Cale> We should be writing x f rather than f x ;)
22:46:17 <dolio> dmwit: But when people point out how do notation is arrived at, it's "foo >>= \a -> bar >>= \b -> ...".
22:46:17 <newsham> print =<< (+5) <$> readIO =<< readFile "foo"
22:46:22 <adu> (x)f is weird
22:46:28 <Axman6> foo|bar == bar . foo
22:46:31 <jdrake> Cale, moore figured that out in the 70s
22:46:32 <newsham> print . (+5) =<< readIO =<< readFile "foo"
22:46:33 <idnar> Cale: I could live with that
22:46:33 <ddarius> Cale: We can start being like those relational people and write x.f.g
22:46:48 <Cale> ddarius: Some category theorists like it too.
22:46:49 <adu> jdrake: who is moore?
22:47:04 <jdrake> I believe his name was Chuck Moore
22:47:06 <pjdelport> adu: Chuck Moore, inventor of Forth
22:47:09 <dolio> With the reverse, it's "(\a -> (\b -> ...) =<< bar) =<< foo"
22:47:09 <adu> ooo forth
22:47:20 <dons> Baughn: wow, with -O0 ?
22:47:34 <jdrake> Try to do monads in forth!
22:47:38 * Axman6 proposes g · f = f (g x)
22:47:39 <newsham> dolio: too many points
22:47:41 <dmwit> dolio: Notice that I did not come down on one side or the other of the (.)/(>>=) divide.
22:47:43 <jdrake> It is impervious to your wicked ways!
22:47:46 <Axman6> · opt-shift-9 for those mac users
22:48:00 <adu> · hmm
22:48:03 <Cale> Axman6: surely you want another x there ;)
22:48:19 <Axman6> Cale: no, it appears laxily >_>
22:48:21 <newsham> most channels you diss an editor or an os and get a flame war
22:48:25 <Axman6> z*
22:48:28 <dolio> newsham: Yeah, well, forgoing points takes getting used to. :)
22:48:29 <newsham> on #haskell, its about >>= vs =<<
22:48:45 <Axman6> or maybe g » f = f . g
22:48:48 <idnar> this is hardly a flamewar
22:48:53 <adu> dmwit: your neutrality is very much in between I give you 2 thumbs sideways...
22:48:56 <newsham> idnar: add some wood
22:49:06 <dolio> I'm not saying I don't use (=<<), it's just that if you're modelling imperative programs, (>>=) makes sense.
22:49:07 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "Hello"
22:49:08 <lambdabot>   ("Hello","olleH","HELLO")
22:49:21 <dmwit> Axman6: How about >>>
22:49:26 <dolio> Which is what got monads into Haskell, right?
22:49:29 <dmwit> :t (>>>) `asTypeOf` flip (.)
22:49:30 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
22:49:31 <Axman6> that works
22:49:44 <dmwit> Hey, what do you know, it already exists! \o/
22:49:56 <newsham> > liftM3 (,,) id reverse (map toUpper) "Hello"
22:49:57 <lambdabot>   ("Hello","olleH","HELLO")
22:49:58 <idnar> @type >>>
22:49:59 <lambdabot> parse error on input `>>>'
22:50:04 <idnar> @type (>>>)
22:50:05 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a c d -> a b d
22:50:13 <idnar> @type (.)
22:50:14 <Cale> > sequence [id, reverse, map toUpper] "Hello"
22:50:14 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
22:50:15 <lambdabot>   ["Hello","olleH","HELLO"]
22:50:19 <Axman6> what about >-
22:50:26 <newsham> > (,,) <$> id <*> reverse <*> map toUpper $ "Hello"
22:50:27 <lambdabot>   ("Hello","olleH","HELLO")
22:50:27 <idnar> >-<
22:50:34 <Axman6> g >- f = f . g
22:50:41 <Axman6> or even... >_>
22:50:45 <idnar> isn't >- taken by arrows?
22:50:48 <ddarius> I believe >- is used in arrow syntax
22:50:52 <Cale> Used to be.
22:50:53 <Axman6> >->?
22:50:54 <ddarius> -< is definitely
22:51:03 <Cale> For some stupid reason, they removed that direction of writing arrows.
22:51:12 <idnar> >- x -> y <- z -< eek!
22:51:31 <adu> i love arrows, but i've never used them
22:51:34 * Axman6 kinda like >-
22:51:38 <Axman6> >-> even
22:51:43 <adu> I need to use arrows
22:51:46 <dolio> I think >- is free.
22:52:07 <Axman6> it's like >>= zoomed out...
22:52:13 <dolio> proc x -> do a <- f -< b ; ...?
22:52:43 <Axman6> yeah, >- and -< look yuck to me
22:52:47 <Axman6> >-> and <-< work well
22:52:49 <dmwit> > let a >- b = 3 in x >- y
22:52:50 <lambdabot>   3
22:53:07 <Axman6> old school arrows, where you'd have >>>--->
22:53:17 <dmwit> heh
22:53:42 <dmwit> If it had a notch at the back for stringing, it would be =>>>--->
22:54:26 <adu> =D
22:54:44 <idnar> hahaha
22:54:56 <Axman6> i like that
22:55:06 <Axman6> ok, all arrows must now have notches
22:58:02 <adu> is it possible to import .... hiding a typeclass?
22:58:10 <Baughn> Sorry
22:58:24 <Baughn> Best you can do is newtype the type and not derive that typeclass
22:58:39 <adu> what about hiding a member of a typeclass?
22:58:48 <dmwit> That should be no problem.
22:59:01 <dmwit> You won't be able to declare new instances in that module, of course.
22:59:09 <jdrake> Cale, x >> y = x >>= (\k -> y)  is specifically passing the output of x to the lambda function and applying y without any care of k, correct?
22:59:18 <dmwit> (At least, you won't be able to define that function in an instance.)
22:59:30 <dmwit> jdrake: right
22:59:33 <adu> like ... hiding (fromIntegral)
22:59:33 <adu> oops fromInteger is the member...
22:59:34 <Cale> jdrake: yeah, it effectively discards the result of x
22:59:53 <Cale> jdrake: and runs y next regardless of what result x had
23:00:06 <jdrake> @src (<-)
23:00:06 <lambdabot> Source not found. :(
23:00:11 <jdrake> How does <- work
23:00:27 <dmwit> It's syntax.
23:00:29 <Cale> do v <- x; <stmts>  is translated into  x >>= \v -> do { <stmts> }
23:00:40 <dmwit> Damn, Cale types fast.
23:00:54 <idnar> dmwit: he's a bot in disguise
23:01:14 <jdrake> Cale, need some more information
23:01:16 <dmwit> fast...ly
23:01:18 <stepcut> any idea where the best place to get haskell-mode head is ?
23:01:24 <adu> jdrake: k could be replaced with _
23:01:28 <Cale> jdrake: Well, okay... do you understand what >>= does yet?
23:01:48 <Cale> jdrake: Each <- in the do-block is translated into >>=
23:02:16 <jdrake> Not quite there yet, but I am thinking in  main = getLine >>= putStrLn  it is obvious
23:02:27 <Cale> yeah.
23:02:38 <pjdelport> main = putStrLn =<< getLine
23:02:59 <Cale> Let's not confuse things with that whole =<< vs. >>= nonsense here ;)
23:03:07 <Axman6> bah
23:03:15 <Cale> So in that case,  getLine  is executed, and its result is passed to  putStrLn  which produces another action and that's run.
23:03:23 <Axman6> >>= reads better
23:03:47 <jdrake> Cale, cat = char 'c' >> char 'a' >> char 't' >> return "It's a cat."   is entirely not understandable to me
23:03:55 <jdrake> "would try to match the string "cat", and if the parse succeeded, would return the string "It's a cat.". "
23:04:04 <Axman6> do a >>= then do b >>= ... instead of do after =<< doing b after doing =<< do a
23:04:10 <adu> jdrake: its one of the 5-7 reserved operators
23:04:12 <zachk> actions are the key to monads for me
23:04:33 <dmwit> jdrake: ah... that's in the Parsec monad.
23:04:34 <Cale> jdrake: okay, the idea here is that  char x  is a parser which eats a character of the input, succeeding if that character is x
23:04:44 <adu> jdrake: that looks like Parsec
23:04:50 <jdrake> One could construct an entire application with gtk2hs without really understanding monads.
23:04:50 <Cale> It *could* be Parsec
23:04:52 <rwbarton> and it spits it back out if it wasn't x
23:04:59 <Cale> jdrake: Yes.
23:05:14 <Cale> jdrake: Okay, let's look at this more carefully.
23:05:20 * adu imagines how a parser would spit... ew
23:05:31 <Cale> Suppose we wanted to represent parsers.
23:06:13 <adu> jdrake: thats similar to string "cat" >> return "its a cat"
23:06:38 <jdrake> I think I need one line of thought from Cale to get through my pain :-(
23:06:58 <ddarius> or "It's a cat" $> string "cat"
23:07:16 <Axman6> jdrake: Cale's the man when it comes to explaining stuff nicely :)
23:07:19 <adu> ddarius: what does $> do?
23:07:26 <ddarius> @src ($>)
23:07:26 <lambdabot> Source not found. You speak an infinite deal of nothing
23:07:31 <Axman6> @src ($>)
23:07:31 <Cale> uh, come to #haskell-overflow and we'll design a parsing library :)
23:07:31 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
23:07:32 <Axman6> lame
23:07:35 <rwbarton> @src (*>)
23:07:36 <lambdabot> (*>) = liftA2 (const id)
23:07:49 <ddarius> ($>) = fmap . const
23:07:54 <adu> ii can explain
23:09:02 <ddarius> Why don't we just make #haskell-cale ?
23:09:53 <Axman6> sounds like a very good idea
23:10:07 * dmwit creates a #dmwit
23:10:09 <adu> or #haskell-adu
23:10:37 <dmwit> I'm an op! ^_^
23:14:45 <idnar> #caleskell
23:16:34 <Axman6> #hascale
23:16:39 <Axman6> i can #hascale?
23:16:43 <idnar> heh
23:18:56 <adu> wow
23:26:44 <Axman6> would it be possible (or useful) to have a a function say print' :: IO String -> IO ()? so you could do "do print' getLine"? and would that actually work?
23:27:03 <newsham> is #haskell-cale like #haskell-cafe?
23:27:09 <Baughn> Axman6: Possible, sure. Useful, not really.
23:27:24 <Baughn> Axman6: That'd just be print =<< getLine
23:27:46 <newsham> ?type (>>= print)
23:27:47 <lambdabot> forall a. (Show a) => IO a -> IO ()
23:27:47 <Axman6> ah, fair enough
23:28:10 <Baughn> But if you use it a lot, feel free to name it. ;)
23:28:51 <Axman6> i was just curious, reading http://sigfpe.blogspot.com/2007/11/io-monad-for-people-who-simply-dont.html
23:28:52 <lambdabot> Title: A Neighborhood of Infinity: The IO Monad for People who Simply Don't Care, http://tinyurl.com/yplmwx
23:29:48 <newsham> axman: if you use =<<, ., <$> and <*> you get stuff code that reads sort of like normal function application
23:30:15 <Axman6> @src (<*>)
23:30:15 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
23:30:17 <Axman6> @src (<$>)
23:30:17 <lambdabot> f <$> a = fmap f a
23:30:25 <Axman6> ah, handeh
23:30:32 <Axman6> wherte's <$> defined?
23:30:33 <newsham> <$> for fmap, <*> for ap (when monad)
23:30:34 <Axman6> -t
23:30:39 <dibblego> Control.Applicative
23:30:58 <dibblego> > (+) <$> Just 7 <*> Just 8
23:30:59 <lambdabot>   Just 15
23:31:30 <Axman6> :t (<*>)
23:31:32 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
23:31:46 <dibblego> <$> ~= fmap and <*> ~= ap
23:31:55 <dibblego> > (+) `fmap` Just 7 `ap` Just 8
23:31:56 <lambdabot>   Just 15
23:31:56 <Axman6> @src ap
23:31:56 <lambdabot> ap = liftM2 id
23:31:57 <newsham> > maybe "oops" show =<< (+) <$> Just 7 <*> Just 8
23:31:58 <lambdabot>   Couldn't match expected type `[Maybe a]'
23:33:11 <newsham> oops, thats not a =<< :)
23:34:57 <newsham> > flip lookup [(10,"boo"),(15,"wee")]  =<< ((+) <$> Just 7 <*> Just 8)
23:34:58 <lambdabot>   Just "wee"
23:36:41 <newsham> ap mf mx = do { f <- mf; x <- mf; return (f x) }
23:36:58 <adu> newsham: what do <$> and <*> do?
23:37:41 <newsham> ?type (++) <$> readFile "foo" <*> readFile "bar"
23:37:42 <lambdabot> IO [Char]
23:37:52 <newsham> ?type (++)
23:37:53 <lambdabot> forall a. [a] -> [a] -> [a]
23:38:00 <newsham> ?type (++) <$> readFile "foo"
23:38:01 <lambdabot> IO ([Char] -> [Char])
23:38:09 <newsham> ?type (++) <$> readFile "foo" <*> readFile "bar"
23:38:10 <lambdabot> IO [Char]
23:38:27 <newsham> ?type return (++) <*> readFile "foo" <*> readFile "bar"
23:38:28 <lambdabot> IO [Char]
23:38:33 <adu> ?t (<$>)
23:38:34 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
23:38:38 <adu> ?t (<*>)
23:38:38 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
23:38:49 <dibblego> > (+) <$> [1..5] <*> [100..110]
23:38:50 <lambdabot>   [101,102,103,104,105,106,107,108,109,110,111,102,103,104,105,106,107,108,10...
23:38:56 <adu> ?type (<$>)
23:38:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:39:04 <dibblego> @type fmap
23:39:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:39:06 <dibblego> @type ap
23:39:07 <adu> ?type (<*>)
23:39:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
23:39:08 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
23:39:09 <newsham> so   return (++) :: IO ([Char] -> [Char] -> [Char])
23:39:20 <newsham> and then `ap` with    IO [Char]
23:39:27 <newsham> gives you  IO ( [Char] -> [Char])
23:39:31 <dibblego> > (+) <$> Just 5 <*> Just 7
23:39:32 <lambdabot>   Just 12
23:39:33 <newsham> and `ap` with another IO [Char]
23:39:35 <newsham> and you get IO [Char]
23:39:37 <dibblego> > pure (+) <*> Just 5 <*> Just 7
23:39:38 <lambdabot>       Ambiguous occurrence `pure'
23:39:38 <lambdabot>      It could refer to either `Control.Appl...
23:39:45 <dibblego> > Control.Applicative.pure (+) <*> Just 5 <*> Just 7
23:39:46 <lambdabot>   Just 12
23:40:03 <dibblego> > return (+) `ap` Just 5 `ap` Just 7
23:40:04 <lambdabot>   Just 12
23:40:10 <dibblego> > (+) `fmap` Just 5 `ap` Just 7
23:40:12 <lambdabot>   Just 12
23:40:49 <adu> so <$> is fmap and <*> is ap?
23:40:55 <newsham> for monads, yah
23:40:55 <dibblego> approximately, yes
23:41:07 <pumpkin_> what does Just do?
23:41:08 <dibblego> Applicative is a more general abstraction than Monad
23:41:11 <dibblego> @type Just
23:41:12 <lambdabot> forall a. a -> Maybe a
23:41:26 * pumpkin_ has a lot more reading to do :P
23:41:27 <newsham> Just is a constructor for   Maybe a = Nothing | Just a
23:41:36 <adu> pumpkin_: it returns a Maybe value
23:41:44 <pumpkin_> hmm
23:42:05 <adu> pumpkin_: if x :: a then (Just x) :: Maybe a
23:42:06 <pumpkin_> so a Maybe value is either the specified type or nothing?
23:42:14 <pumpkin_> and the specified type is referred to as Just the speficied type?
23:42:24 <adu> pumpkin_: yes
23:42:30 <dibblego> a Maybe value is like nullable value from imperative languages
23:42:31 <pumpkin_> interesting
23:42:33 <newsham> the type is Maybe the specified type
23:42:37 <newsham> the value is Just the specified value
23:42:41 <adu> pumpkin_: it also prevents you from using it right away without checking stuff
23:43:04 <newsham> ?type Just (5 :: Int)
23:43:05 <lambdabot> Maybe Int
23:43:26 <newsham> ?type Nothing :: Maybe Int
23:43:27 <lambdabot> Maybe Int
23:44:22 <newsham> kinda like a list that is either empty or has exactly one value in it
23:44:59 <adu> ?type maybeToList
23:45:00 <lambdabot> forall a. Maybe a -> [a]
23:45:11 <newsham> ?hoogle [a] -> Maybe a
23:45:11 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
23:45:11 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
23:45:11 <lambdabot> Prelude head :: [a] -> a
23:45:39 <newsham> > listToMaybe . maybeToList $ [1..]
23:45:40 <lambdabot>   Couldn't match expected type `Maybe a' against inferred type `[a1]'
23:45:57 <newsham> > maybeToList.listToMaybe $ [1..]
23:45:58 <lambdabot>   [1]
23:50:15 <adu> @src ap
23:50:15 <lambdabot> ap = liftM2 id
23:50:23 <adu> @src liftM2
23:50:24 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
23:52:30 <Axman6> :t liftM2
23:52:31 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:53:16 <adu> :t zipWith
23:53:17 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
23:54:59 <adu> @check True
23:55:00 <lambdabot>   "OK, passed 500 tests."
23:56:04 <adu> @check (\xs -> zipWith (+) [1..10] xs == liftM2 (+) [1..10] xs)
23:56:05 <lambdabot>   "Falsifiable, after 4 tests:\n[-1,2,1]\n"
23:57:20 <jdrake> Do we have any haskell jabber server?
23:57:32 <jdrake> that is, a jabber server written in haskel
23:57:39 <adu> > liftM2 (+) [1..10] [1..10]
23:57:40 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7...
23:57:45 <adu> > zipWith (+) [1..10] [1..10]
23:57:46 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
23:59:05 <adu> > [ x*y | x <- [1..10], y <- [1..10] ]
23:59:06 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,2,4,6,8,10,12,14,16,18,20,3,6,9,12,15,18,21,24,27,30,...
23:59:19 <adu> > [ x+y | x <- [1..10], y <- [1..10] ]
23:59:20 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7...
23:59:39 <yewT> is it possible to use do..... and let in together?
23:59:48 <adu> yewT: yes
