00:00:27 <jsnx> however, the nifty thing about erlang is how it glosses over the difference between local and remote processing
00:00:28 <sbahra> wooo!
00:00:30 <sbahra> close one!
00:00:40 <sbahra> 90883 sbahra        1 118    0  1707M  1457M CPU0   0   8:57 100.00% euler
00:00:43 <sbahra> it's getting smaller
00:01:41 <TSC> Which problem?
00:01:48 <the_unmaker> jsnx: how does erlang do that?
00:01:55 <jsnx> erlang isn't really functional in the large
00:02:15 <jsnx> it's more like everything was done via shell pipes
00:02:33 <jsnx> everything can block, fail due to network problems, &c.
00:02:53 <jsnx> even if you're program is local, you treat it like it is made of disparate, failure prone components
00:03:32 <the_unmaker> well no one cares about functional unless it delivers results
00:03:47 <dmwit> jsnx: That library looks pretty neat.
00:03:49 <jsnx> the_unmaker: that is a non-sequitur :)
00:04:11 <jsnx> the_unmaker: erlang pays heavily for making the network abstraction pervasive
00:04:29 <the_unmaker> jsnx: how so?
00:04:39 <the_unmaker> and what do you think non sequiter means?
00:04:47 <jsnx> it's a functional language and strings are immutable, but if you send a string from one process to another, you don't get a reference, you get a copy
00:05:53 <jsnx> there have been some efforts toward high performance erlang
00:06:17 <Axman6> @hoogle CReal
00:06:18 <lambdabot> No results found
00:06:23 <jsnx> but the "network model" seems to be a hangup for them
00:06:30 <Axman6> @where CReal
00:06:30 <lambdabot> I know nothing about creal.
00:06:37 <dmwit> ?go creal haskell
00:06:39 <lambdabot> http://www.haskell.org/haskellwiki/Libraries_and_tools/Mathematics
00:06:39 <ivanm> @index CReal
00:06:39 <lambdabot> Title: Applications and libraries/Mathematics - HaskellWiki
00:06:39 <lambdabot> bzzt
00:06:49 <Axman6> thanks :)
00:06:56 <jsnx> the_unmaker: erlang also has a rich set of libraries for monitoring and controlling processes
00:07:02 <dmwit> Axman6: There's actually several other competing libraries to offer arbitrary-precision floating point.
00:07:17 <ttt--> http://www.iist.unu.edu/~vs/haskell/dhs/counter.html
00:07:18 <Axman6> got any recommendations?
00:07:19 <lambdabot> Title: Erlang-style Distributed Haskell: Counter Example
00:07:30 <dmwit> Axman6: I recommend CReal. ;-)
00:07:36 <Axman6> heh, ok
00:07:45 <the_unmaker> ok
00:08:14 <the_unmaker> erlang seems with mnesia to have the ability to 1 use multiple nodes for processing 2 have a db that works with it
00:08:33 <the_unmaker> can haskel do this? and how does erlang pay ? like where does it have trouble?
00:08:38 <the_unmaker> IM very curious
00:08:54 <ttt--> someone should put that (dhs) on hackage, i cant get it installed :)
00:09:05 <jsnx> any DB allows you to use multiple "nodes" for processing
00:09:23 <the_unmaker> aolserver combines event+threads as does apache event worker
00:09:26 <sbahra> euler: out of memory (requested 3145728 bytes) ;[
00:09:27 <the_unmaker> hmmmm
00:09:39 <jsnx> Mnesia has no advantage over PostGreSQL in that regard
00:09:55 <dmwit> sbahra: 3MB doesn't seem so bad. =P
00:10:11 <sbahra> dmwit, 2.8GB + 3MB ;[
00:10:12 <jsnx> haskell does not ship with a rich platform for monitoring, message passing and process control like Erlang
00:10:17 <dmwit> sbahra: ;-)
00:10:22 <sbahra> I actually have to think now
00:10:27 <jsnx> the OTP is a big part of what makes erlang valuable
00:10:34 <dmwit> sbahra: Which problem?
00:10:37 <sbahra> map (\(a, b) -> (a, b, (read a :: Integer) ^ (read b :: Integer))) (zip (map (takeWhile (/= ',')) $ (lines . filter (/= '\r')) j) (map tail (map (dropWhile (/= ',')) $ (lines . filter (/= '\r')) j)))
00:10:48 <ivanm> sbahra: thinking? are we allowed to do that now?
00:11:03 * ivanm warily looks up to see if the not-so-secret overlords are watching
00:11:05 <ivanm> ;-)
00:11:10 <jsnx> however -- and this is just a practical problem, not an architectural one -- erlang is a terrible, terrible language
00:11:34 <jsnx> it has no regexen, poor string handling, poor arithmetic handling, awful syntax...
00:11:37 <ivanm> jsnx: the syntax?
00:11:38 <sbahra> dmwit, 99, it's an easy problem. I just didn't use tail recursion in finding the tuple with the maximum exponent.
00:11:39 <dmwit> sbahra: Your modem is set to the wrong baud rate.
00:11:44 <jsnx> ivanm: many things
00:11:51 <sbahra> dmwit, haha
00:11:51 <jsnx> terrible module system
00:11:57 <jsnx> no module heirarchy
00:12:02 <jsnx> every module is top level
00:12:22 <sbahra> dmwit, I wanted to solve it using a quick 1 liner
00:12:26 <dmwit> yeah
00:12:43 <jsnx> the_unmaker: so i fear you have a hobson's choice
00:12:52 <the_unmaker> whos hobson
00:12:58 <jsnx> the_unmaker: or rather, a morton's fork :)
00:13:21 <dmwit> sbahra: The longest part of my solution is parsing the file. =/
00:13:30 <the_unmaker> jsnx: are you this intellectual always?
00:13:34 <jsnx> hobson was a stable manager, and you could have any horse as long as it was the one nearest the door
00:13:55 <ivanm> apparently, people don't think functionally: http://guidewiredevelopment.wordpress.com/2008/10/03/dont-believe-the-hype/
00:13:57 <lambdabot> Title: Don’t Believe the Hype « Development at Guidewire, http://tinyurl.com/4pjklw
00:14:01 <sbahra> dmwit, the above does the parsing + computation of the exponent into a 3-tuple
00:14:12 <sbahra> I guess that is the "longest"
00:14:14 <jsnx> morton was tax collector, and if you spent a lot of money, he assumed you must have money to spare, whereas if you were frugal, he assumed you had a big savins
00:14:23 <sbahra> dmwit, did you use a 1-liner?
00:14:28 <dmwit> yep
00:14:33 <sbahra> hker
00:14:50 <dmwit> sbahra: You're damn close, just don't use (^) and you won't run out of memory.
00:15:14 <sbahra> hm?
00:15:15 <dmwit> sbahra: Hint: comparisons have the same result if you apply a monotonically increasing function to both sides. ;-)
00:15:17 <the_unmaker> so your saying what in plain english?
00:15:20 <jsnx> the_unmaker: i started learning FP with erlang, actually, and gave it up because it's really not even as rich as Perl for general programming
00:16:04 <jsnx> the_unmaker: there is no good option for writing concurrent, scalable programs
00:16:10 <jsnx> none
00:16:20 <ivanm> there are only less worse options
00:16:21 <luqui> ivanm, really?  ya think?  ;-)
00:16:30 <jsnx> ivanm: not even :)
00:16:40 <dmwit> jsnx: ATS ;-)
00:16:57 <jsnx> learn a bad language with good libraries or one of numerous good languages with bad libraries
00:17:02 <the_unmaker> woa
00:17:04 <jsnx> dmwit: ATS has message passing?
00:17:06 <luqui> ivanm, "people don't think functionally" is true
00:17:10 <ivanm> jsnx: what do you classify Haskell as then?
00:17:12 <the_unmaker> thats how I feel
00:17:13 <luqui> ivanm, "people don't think imperatively" is also true
00:17:24 <ttt--> Doesnt erlang allow concurrent scalable programs?
00:17:24 <the_unmaker> 100s have done stuff with perl yet lispers say its utter crap
00:17:26 <ivanm> luqui: *shrug* functional programming makes a lot more sense to me than imperative programming
00:17:33 <jsnx> ttt--: yes
00:17:36 <luqui> ivanm, which did you learn first?
00:17:45 <ivanm> imperative
00:17:52 <luqui> how long have you been doing functional?
00:17:57 <jsnx> ivanm: good language, bad message passing libs
00:18:01 <ttt--> Oh, i thought you said there are none
00:18:05 <the_unmaker> some admin I know get really angery when I mention lisp, as if Im trying to outdo them by using a different language and nto confoming
00:18:12 <the_unmaker> whihc of course I am
00:18:13 <the_unmaker> :)
00:18:18 <jsnx> ttt--: i said there is no good choice
00:18:27 <bigtalk> is there some findFirst funtion? like dropUntil but stop as soon as cond is met
00:18:37 <ivanm> luqui: I did a semester of scheme back in 04, but found haskell end of 06 and have been using it predominantly since
00:18:41 <sjanssen> bigtalk: dropWhile
00:18:42 <dmwit> bigtalk: find
00:18:46 <ivanm> jsnx: oh? what's so bad about STM?
00:18:46 <dmwit> :t find
00:18:47 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
00:18:49 <the_unmaker> ivanm: what about common lisp?
00:18:55 <ivanm> the_unmaker: never touched it
00:18:56 <dmwit> Or dropWhile, if that's what you want.
00:18:59 <jsnx> ivanm: you can't do STM over the network, can you?
00:19:02 <the_unmaker> common lisp books really suck so far as I ve seen
00:19:03 <ivanm> have tried to grok elisp, but don't know it well enough
00:19:08 <ivanm> jsnx: true...
00:19:18 <ivanm> duh, message-_passing_
00:19:22 <jsnx> ivanm: and it's not message passing anyway
00:19:33 <the_unmaker> does the type thing make sense if you study haskell enough?
00:19:46 <luqui> jsnx, you can't?
00:19:47 <ivanm> jsnx: yeah, I mis-interpreted what you said
00:19:51 <jsnx> ivanm: it doesn't have monitoring, &c. erlang lets you right a complete network application, with restarts, reporting, &c.
00:19:54 <luqui> jsnx, I think you can do STM over the network
00:19:56 <dmwit> the_unmaker: What's "the type thing"?
00:20:07 <ivanm> luqui: isn't it based on the RTS between internal threads?
00:20:07 <jsnx> luqui: wow
00:20:08 <luqui> jsnx, isn't that what databases do?
00:20:14 <jsnx> luqui: most don't
00:20:23 <bigtalk> jsnx: how can you complain that a language doesn't have feature x when it wasnt made for that. Erlang was created for programming massively concurrent and faulttolerant systems, mainly telephone-switches and  succeeded/succeeds at that. Noone said it was a great language for webapps.
00:20:35 <jsnx> luqui: only very expensive databases let you use more than one computer at a time for the same database
00:20:44 <jsnx> bigtalk: right
00:20:46 * atsampson peers up -- if you're interested in message-passing concurrency for Haskell, you might like my officemate's project: http://www.cs.kent.ac.uk/projects/ofa/chp/
00:20:47 <lambdabot> Title: Communicating Haskell Processes
00:20:49 <luqui> yeah, postgres is pretty expensive
00:21:04 <jsnx> luqui: postgres can't do joins across a cluster
00:21:13 <jsnx> luqui: it can actually share indices
00:21:21 <ivanm> luqui: how much did Sun pay for it again? :P
00:21:31 <luqui> jsnx, how is that analogous to STM?
00:21:32 <jsnx> luqui: the only ones that can right now are oracle, db2 and sql server
00:21:34 <sbahra> dmwit, yes, nod
00:21:38 <jsnx> luqui: transactionality
00:21:51 <jsnx> luqui: you can't do transactions across a postgresql cluster
00:21:52 <luqui> jsnx, I am not following.
00:22:09 <the_unmaker> what about distributed in memory hashes?
00:22:11 <luqui> jsnx, ohohohohoh I get it.
00:22:21 <bigtalk> jsnx; actually saw more what youw rote, practical not architectural problem. true
00:22:32 <jsnx> luqui: the state of the database -- indices, transaction logs, &c. -- is not shared or voted on by the members of a postgresql cluster
00:22:48 <luqui> jsnx, right, all the state has to be in one place.  Okay, now I see your argument.
00:23:01 <jsnx> the_unmaker: if there is not confirmation/quorums, you do not have a real shared memory system
00:23:22 <jsnx> db2 and sql server actually both got their cross cluster transactions from the same place
00:23:27 * dmwit wants a pi-calculus machine!
00:23:30 <jsnx> tandem's nonstopsql
00:23:37 <luqui> ew pi calculus
00:23:39 <dmwit> Preferably about 100 of them!
00:23:41 <jsnx> which they got to buy little pieces of
00:23:52 <jsnx> this problem was solved in the eighties, but...
00:23:59 <bigtalk> but i want find but return the value that met the condition
00:24:34 <dmwit> > find odd [2,4,5,3] -- find already does that, bigtalk
00:24:35 <lambdabot>   Just 5
00:24:39 <jsnx> there is a general confirmation protocol -- paxos -- which addresses these problems
00:25:01 <ivanm> > find odd [2,4,6]
00:25:02 <the_unmaker> hm
00:25:02 <lambdabot>   Nothing
00:25:06 <jsnx> it is very rarely implemented
00:25:22 <luqui> in fact, the one that's missing is finding the index that matched.
00:25:26 <dmwit> It's kind of complicated.
00:25:42 <dmwit> Not difficult, I think.  Just complicated.
00:26:08 <luqui> > let findIdx p l = fst <$> find (f . snd) (zip [0..] l) in findIdx odd [2,4,5,3]
00:26:09 <lambdabot>       No instance for (SimpleReflect.FromExpr Bool)
00:26:09 <lambdabot>        arising from a use...
00:26:18 <luqui> > let findIdx p l = fst <$> find (p . snd) (zip [0..] l) in findIdx odd [2,4,5,3]
00:26:20 <lambdabot>   Just 2
00:26:33 <dmwit> :t findIndex
00:26:34 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
00:26:38 <luqui> no way
00:26:40 <dmwit> luqui: wheels, etc
00:26:43 <luqui> where's that from?
00:26:49 <dmwit> ?index findIndex
00:26:49 <lambdabot> Data.List, Data.Map
00:26:53 <luqui> I could have sworn it didn't exist!
00:26:55 <luqui> :-)
00:26:59 <dmwit> =)
00:27:28 <luqui> zip is a cool function.
00:27:37 <luqui> not advanced, just very useful
00:27:43 <dmwit> Yep.
00:27:48 <dmwit> I use zip and zipWith a lot.
00:27:51 <ivanm> luqui: does it _need_ to be advanced? ;-)
00:27:54 <dmwit> Recently, I've started using transpose, too.
00:28:00 <bigtalk> @src find
00:28:01 <lambdabot> find p          = listToMaybe . filter p
00:28:03 <luqui> what, no. better if it's not.
00:28:04 <ivanm> @type transpose
00:28:05 <lambdabot> forall a. [[a]] -> [[a]]
00:28:14 <luqui> (but it's not cool the same way catamorphisms are cool, for example)
00:28:15 <Axman6> i found a nice use for zipWith yesterday
00:28:20 <ivanm> duh, pseudo-matrix transposition
00:28:35 <dmwit> ivanm: Right, and the generalization of zip.
00:28:36 <Axman6> not particularly interesting, but made life easy.
00:28:46 <ivanm> dmwit: is it? I suppose it is...
00:28:52 <dmwit> > uncurry zip ([a, b, c], [d, e, f])
00:28:53 <lambdabot>   [(a,d),(b,e),(c,f)]
00:28:56 <ivanm> except that generalisation of single-type zip ;-)
00:28:58 <luqui> > (zipWith . zipWith) (+) [[1,2],[3,4]] [[5,6],[7,8]]
00:29:00 <dmwit> > transpose [[a, b, c], [d, e, f]]
00:29:00 <lambdabot>   [[6,8],[10,12]]
00:29:01 <lambdabot>   [[a,d],[b,e],[c,f]]
00:29:16 <dmwit> ivanm: Yeah, they generalize in different directions. =)
00:29:23 <ivanm> heh
00:29:47 <dmwit> luqui: whoa
00:29:56 <dmwit> Oh, I see.
00:29:56 <luqui> dmwit, yeah, isn't that neat?  :-)
00:30:04 <luqui> it generalizes arbitrarily
00:30:31 <dmwit> It's very clever. =)
00:30:41 <the_unmaker> http://guidewiredevelopment.wordpress.com/2008/10/03/dont-believe-the-hype/ is this a microsoft guy?
00:30:44 <lambdabot> Title: Don’t Believe the Hype « Development at Guidewire, http://tinyurl.com/4pjklw
00:30:45 <luqui> in fact all liftAn's do that, and zipWith is a liftA2
00:30:49 <the_unmaker> he seems to say many things
00:30:52 <the_unmaker> as a luddite
00:31:09 <the_unmaker> [forgive me using big words]
00:31:15 <ivanm> the_unmaker: luddite -/-> M$
00:31:30 <dmwit> "Luddite" is a big word these days?
00:31:34 <dmwit> It's only two syllables!
00:31:45 <luqui> M$ reminds me of qbasic.  wow... that was a long time ago.
00:31:47 <dmwit> Think about how difficult life would be if you could only use mono-syllables...
00:32:07 <luqui> I think he was talking about "things"
00:32:23 <luqui> dmwit, I think it was Paul Graham who did a whole speech that way!
00:32:32 <dmwit> No, Paul Graham isn't that cool.
00:32:35 <dmwit> Alan Kay, maybe.
00:32:54 <luqui> anyway.  whoever it was defined every polysyllabic word he used before he used it.
00:33:02 <luqui> as an analogy to coding.
00:33:15 <dmwit> I know.
00:33:22 <dmwit> I've watched the talk, it's a pretty fun one.
00:33:29 <luqui> I only read it.
00:36:03 <dmwit> Guy Steele
00:36:09 <jsnx> the_unmaker: i try to use aphorisms, not long words
00:36:19 <jsnx> hehe
00:36:41 <the_unmaker> jsnx: are you english?
00:37:47 <dmwit> http://video.google.com/videoplay?docid=-8860158196198824415&ei=HR3nSPnUHIaYrQLWhZmZCw&q=guy+steele
00:37:49 <lambdabot> Title: Growing a Language, by Guy Steele, http://tinyurl.com/48k5e6
00:38:29 <jsnx> the_unmaker: what?
00:40:07 <jsnx> the_unmaker: you're in socal, aren't you?
00:40:14 <jsnx> that explains it...
00:43:09 <the_unmaker> los angeles
00:44:14 <jsnx> ah, okay
00:44:35 <jsnx> i am from iowa
00:44:50 <the_unmaker> is this the same steele who wrote common lisp spec?
00:45:15 <jsnx> we treasure our vocabularies there -- we have to keep ourselves occupied in between harvests
00:46:11 <the_unmaker> iowa
00:46:13 <the_unmaker> wow
00:46:21 <the_unmaker> I ddin't know they had englishmen there
00:46:49 <the_unmaker> http://www.geocities.com/tablizer/oopbad.htm how about this guy?
00:46:55 <lambdabot> Title: OOP Criticism
00:47:53 <the_unmaker> wow guy steele looks liek a sun guy
00:49:51 <lispy> criticism is cheap, effective solutions/replacements are hard
00:50:37 <lispy> IMO, there is nothing wrong with oop.  I'd just rather be writing functionally
00:50:40 <retrohscoder> what is the best way to write this C code in haskell?       x = (x == 0) ? 1 : x;        or if (x == 0) {x = 1;} else {/* do nothing*/}
00:51:29 <lispy> How can you write an equation saying that a value has a different value than itself?
00:51:30 <dmwit> retrohscoder: You don't do that, if you can help it.
00:51:56 <retrohscoder> hmm
00:52:13 <the_unmaker> bill joy is apparently a good programmer?
00:52:22 <dmwit> Bill Joy wrote vi, no?
00:52:26 <dmwit> He's pretty okay. =)
00:52:55 <the_unmaker> vi is one of my oft used tools
00:53:03 <nanothief> retrohscoder: something like "x2 = if (x == 0) then 1 else x" would work
00:53:07 <the_unmaker> simple hard weird adn powerful all at same time
00:53:49 * lispy has to wonder if 'x = 1' is really signifying 'x = True'
00:53:50 <nha__> can lambdabot strictify snippets
00:53:51 <luqui> @pl \(X f) -> X . (<*>) (fmap (<*>) f) . runX
00:53:51 <lambdabot> (line 1, column 5):
00:53:51 <lambdabot> unexpected "f"
00:53:51 <lambdabot> expecting operator or ")"
00:54:01 <nha__> like that hackage db app
00:54:12 <luqui> @pl \(Just f) -> Just . (<*>) (fmap (<*>) f) . runX
00:54:12 <lambdabot> (line 1, column 8):
00:54:12 <lambdabot> unexpected "f"
00:54:12 <lambdabot> expecting operator or ")"
00:54:19 <lispy> nha__: strictify?  Hmm...that sonuds interesting.  What do you have in mind?
00:54:28 <luqui> oh, no pattern matching, of course.  how would it destruct ;-)
00:54:34 <nha__> "strictify: Find a local optimum of strictness annotations."
00:54:43 <luqui> @pl \f -> X . (<*>) (fmap (<*>) (runX f)) . runX
00:54:44 <lambdabot> (X .) . (. runX) . (<*>) . fmap (<*>) . runX
00:54:51 <luqui> not pretty :-(
00:55:07 <nha__> was just asking because the app requires unix
00:55:27 <the_unmaker> is vi ok for doing haskell?
00:55:42 <dmwit> I use vim.
00:55:51 <the_unmaker> emacs is like learning a programming lang for me I got slime going but go remembering those keys woa nelly
00:55:58 <the_unmaker> cool vim is what i like
00:56:19 <lispy> the_unmaker: most people here seem to think emacs/vim are the best Haskell editors out there at the moment.  Next might be something random like eclipse with the fp extension
00:56:41 <jsnx> ed is the standard text editor
00:56:44 <jsnx> in iowa
00:56:53 <lispy> ed :: Corn -> Code
00:57:02 <lispy> That's why they like itin Iowa
00:57:16 <dmwit> et :: Corn -> IO Poo
00:57:30 <jsnx> we don't need to stinkin' visual this-and-that
00:58:20 <jsnx> we used to edit with sed while walkin' uphill both ways in a snow storm to...
00:59:26 * lispy wonders about the implications of unsafePerformIO . et
01:01:14 <nanothief> How do you efficiently build a ByteString? Looking at the docs it states that cons is an O(n) operation, which would be very slow if called many times
01:01:36 <lispy> nanothief: I think it depends very much on what your data source is
01:01:58 <lispy> nanothief: you can read a file into bytestring with a primitive, iirc
01:02:48 <nanothief> lispy: well I am converting a data structure to a ByteString, so it would involve many separate cons to put all the stuff on
01:04:16 <lispy> ?hoogle String -> ByteString
01:04:17 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
01:04:17 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
01:04:17 <lambdabot> Prelude read :: Read a => String -> a
01:04:22 <Axman6> any chance someone could explain to me what http://projecteuler.net/index.php?section=problems&id=69 is asking for in phi(n)? i don't understand how to figure out what's relatively prime
01:04:23 <lambdabot> Title: Problem 69 - Project Euler
01:04:43 <lispy> nanothief: maybe a lazy pack would suite you best?
01:05:19 <lispy> Axman6: looking now.  Maybe it's gcd related?
01:05:28 <Axman6> yeah, i think so
01:05:34 <arjanb> nanothief: a lazy ByteString is better for that, and you could take a look at Data.Binary (.Builder)
01:05:58 <nanothief> lispy: yes, cons for a lazy bytestring is an O(1) op, thanks
01:06:07 <lispy> Axman6: ah, relatively prime means the only divisor they share is 1
01:06:19 <Axman6> yeah, that makes sense, thanks
01:06:21 <lispy> nanothief: cons or pack?
01:06:41 <lispy> ?hoogle cons
01:06:42 <lambdabot> Data.ByteString cons :: Word8 -> ByteString -> ByteString
01:06:42 <lambdabot> Data.ByteString.Char8 cons :: Char -> ByteString -> ByteString
01:06:42 <lambdabot> Data.ByteString.Lazy cons :: Word8 -> ByteString -> ByteString
01:06:46 <nanothief> cons, pack is still O(n)
01:07:30 <nanothief> actually pack has to be O(n), what was I thinking :P
01:07:58 <nha__> putting a strict value inside a "Maybe" makes it lazy right
01:08:35 <lispy> > let foo (Just _) = 4 in foo (Just undefined)
01:08:36 <lambdabot>   4
01:08:39 <nanothief> arjanb: where can I find Data.Binary? its not on the ghc librariies index page
01:09:30 <lispy> nha__: it doesn't make the value any lazier, but it does wrap it up...so you can choose to not look at it, as I did in the foo definition...is that what you meant?
01:10:28 <lispy> Axman6: by the way, phi(n) has a nice elegant formula if you know the prime factorization of n
01:10:41 <nha__> whats the memory overhead of it? it doesnt need to create a thunk or anything right
01:10:48 <Axman6> lispy: care to share? :P
01:11:03 <lispy> Axman6: and if computation time becomes an issue with that problem, you could generate the numbers in the range via their factorizations I think
01:11:22 <lispy> nha__: I don't know the answer to that
01:11:29 <nha__> ok thanks anyway
01:11:46 <arjanb> nanothief: it's on hackage (find a library link top left on haskell.org)
01:12:02 <lispy> Axman6: wikipedia surely has it.  It's quite an illustrative example of modern proof technique to derive the computational formula.
01:12:42 <lispy> Axman6: eg., you start from the properties you want phi(n) to satisfy and then you can actually derive the necessary computation...
01:13:59 <nanothief> arjanb: I've found it now, thanks
01:14:56 <Axman6> bleh, too tired, brute forcing it will be fine ;)
01:15:26 <lispy> Axman6: another approach would be to write a factoring algorithm and then factor all the numbers, build a table and then use that facotrization.  Better yet is to figure out how to compute n/phi(n) efficiently some other way :)
01:16:53 <Axman6> well it's got the be the number that has the most factors right?
01:17:23 <Axman6> compared to its size
01:17:31 <lispy> the solution may not be unquie though, so that makes the search harder, right?
01:18:09 <lispy> but yeah, perfect numbers seem like they'd be likely to have the maximum
01:18:19 <lispy> 6, 28 and I think 496
01:18:25 <lispy> ?oeis 6 28
01:18:26 <lambdabot>  Perfect numbers n: n is equal to the sum of the proper divisors of n.
01:18:26 <lambdabot>  [6,28,496,8128,33550336,8589869056,137438691328,2305843008139952128,26584559...
01:19:35 <lispy> so the largest perfect # in you range is 8128
01:19:53 <Axman6> how do you compute perfect numbers?
01:19:57 * Axman6 googles
01:20:09 <EvilTerran> by brute force
01:20:19 <EvilTerran> but you can probably skip the odd numbers for most purposes ;)
01:20:52 <EvilTerran> > filter odd ([6,28,496]...)
01:20:53 <lambdabot>   Not in scope: `...'
01:20:57 <EvilTerran> , filter odd ([6,28,496]...)
01:20:59 <lunabot>  luna: Not in scope: `...'
01:21:01 <EvilTerran> o
01:22:24 <lispy> actually perfect numbers correspond to mersenne primes
01:22:29 <Axman6> well 8128 isn't the answer
01:22:36 <lispy> see here: http://modular.math.washington.edu/gap/Manuals//doc/htm/ref/CHAP015.htm
01:22:39 <lambdabot> Title: [ref] 15 Number Theory, http://tinyurl.com/5334zo
01:22:44 <lispy> go down to the sigma function
01:22:50 <Cthulhon> Whether there are any odd perfect numbers is an open question, no?
01:22:54 <lispy> 15.4
01:22:56 <Asztal> yes
01:23:28 <ivan_m> but there probably aren't
01:23:29 <lispy> nah, perfect numbers are certainly odd ;)
01:23:31 <Asztal> but not under 10^300 :)
01:23:36 <ivan_m> lispy: lol
01:23:39 <int-e> Even perfect numbers are of the form 2^p(2^p-1) where 2^p-1 is prime, i.e. a Mersenne prime. Odd perfect numbers are conjectured not to exist. right.
01:23:59 <int-e> uhm. 2^(p-1)(2^p-1)
01:24:13 <ivan_m> int-e: "conjectured not to exist" == "probaly not, but we haven't worked out how to prove it yet" ? :p
01:24:30 <int-e> yes, and possibly never will.
01:26:09 <lispy> Axman6: I bet you'll find it handy to write a program to compute phi(n) for each number in that range, build a Data.Map or similar, and then once you have that as static data, write a program that uses it to compute n/phi(n)
01:26:35 <lispy> Or wait, does Project Euler just let you give the answers instead of requiring you to run a program?
01:26:51 <int-e> lispy: it does.
01:26:56 <papermachine> lispy, euler doesn't care what you do as long as you get an answer.
01:27:06 <lispy> oh right, sorry
01:28:08 <lispy> either way, factoring all the numbers up to 1,000,000 shouldn't take long, should it?
01:28:34 <lispy> I think it would take O(1) time
01:33:45 <lispy> (that was a joke based on the fact that the input set is fixed at a particular n, so you can just asy it's constant time...)
01:34:25 <int-e> n/phi(n) = product{ p/(p-1) | p divides n } ... you really don't have to factor.
01:34:42 <lispy> ah
01:35:13 <int-e> lispy: you can produce the factorizations by running the sieve of Erathostenes, so it's O(n log(n)), for numbers up to n.
01:35:19 <lispy> just needs primes up to sqrt(n) ?
01:36:25 <int-e> lispy: well, first observe that if n is not square-free, then there's a smaller n with the same n/phi(n). and then think about the individual prime factors, using that p/(p-1) is a montonically decreasing function.
01:36:58 <int-e> lispy: more like log(n)^2 or so. (not sure about the exponent, 2 is a conservative estimate)
01:37:54 <int-e> it's really a pen and paper problem
01:39:47 <retrohscoder> anyone have any experience using HOpenGL DisplayLists ?
01:40:21 <lispy> not the display lists, no
01:40:29 <lispy> I did start writing some HOpenGL tutorials
01:40:32 <lispy> ?where nehe-tuts
01:40:33 <lambdabot> darcs get http://projects.codersbase.com/repos/nehe-tuts/
01:40:35 <int-e> lispy: oh when I said "you don't have to factor" I mean the whole problem, maximizing n/phi(n) for n in a range starting at 1. calculating n/phi(n) requires factorization.
01:40:39 <lispy> But, I didn't get to display lists yet
01:40:46 <retrohscoder> heh
01:41:01 <retrohscoder> I'm doing fine so far
01:41:03 <retrohscoder> but
01:41:11 <retrohscoder> I can't figure out what to do for Display Lists
01:42:24 <Axman6> lispy: those tutes look good, i mi8ght give them a go :0
01:42:27 <Axman6> *
01:43:05 <lispy> Axman6: oh, I should say, it's just the Haskell code, you can go to the nehe website for the explanations
01:43:29 <Axman6> where's the website?
01:43:54 <Axman6> http://nehe.gamedev.net apparently...?
01:43:56 <lispy> Axman6: should be a link in a readme
01:43:59 <lispy> Axman6: ya
01:44:06 <lambdabot> Title: NeHe Productions: Main Page
01:44:47 <retrohscoder> heh I've done the NEHE tutorials in C++, Python, and Ruby :D
01:45:39 <lispy> I really only stopped because I didn't know how to render text
01:45:45 <lispy> I should pick it up again at some point
01:47:15 <retrohscoder> hehe
01:47:30 <retrohscoder> well if I figure it out, I'll surely let you know
01:47:33 <retrohscoder> :)
01:53:42 <Axman6> lispy: take font files, and convery them to polygons, and use those? :P
01:53:49 <Axman6> convert*
01:55:34 <lispy> Axman6: I think we have Haskell libs that are equivalent to the nehe solutions, except maybe cross platorm, and I just needed to pick one
01:55:40 <lispy> I think sdl can render text
01:55:58 <lispy> although, I think I was trying to avoid using sdl?  Can't recall now
01:56:11 <lispy> retrohscoder: if you do, the tuts are in a darcs repo and I accept patches
01:56:30 <retrohscoder> :D
01:56:47 <retrohscoder> I'll keep you posted
01:56:51 <lispy> cool
02:12:18 * retrohscoder screams
02:12:38 <retrohscoder> somehow firefox just closed on me and I lost about 70 tabs of urls
02:13:29 <ivanm> retrohscoder: no session saving? :o
02:13:35 <ivanm> how old is your copy of ff?
02:14:08 <retrohscoder> its set to save the session....and when it reopened, it just showed my homepage....I double checked my preferences.. its set to open previous pages
02:14:14 <retrohscoder> firefox 3.1
02:15:33 <retrohscoder> ...ooh CTRL+SHIFT+H ....
02:15:45 * retrohscoder breathes a sigh of relief.
02:16:57 <nha__> hmm
02:17:10 <nha__> what to use if you need tail recursive State monad?
02:29:56 <jsnx> what do y'all think about rendering text in freetype to get textures, then placing the textures into the scene?
02:30:04 <jsnx> i haven't actually tried it
02:32:10 <Asztal> retrohscoder: yeah, it's doing that to me too :(
02:32:35 <Asztal> there's a "Recover from last session" menu item which just complains that it's unrecoverable
02:34:01 <jeffz> I've almost stopped using firefox because of it's unreliability, it doesn't remember what I had open when it crashes either.
02:35:01 * EvilTerran reads
02:35:03 <EvilTerran> "The first axiom is akin to the associativity in monoids, the second axiom to the existence of an identity element. Indeed, a monad on C can alternatively be defined as a monoid in the category EndC whose objects are the endofunctors of C and whose morphisms are the natural transformations between them, with the monoidal structure induced by the composition of endofunctors."
02:35:23 <EvilTerran> ^ and it makes sense to me! O.o
02:35:48 <EvilTerran> #haskell++ for the various people who've explained CT to me over the last few months
02:35:53 <Lord_Illidan> Hi, I've been reading this code, and I'm not sure what it's doing, it's another euler solution (Already solved it myself, but wanted to see what other more capable people turned up with). Here's my solution http://hpaste.org/10888
02:36:30 <Lord_Illidan> And here is the haskellwiki euler solution http://www.haskell.org/haskellwiki/Euler_problems/21_to_30#Problem_22
02:36:33 <lambdabot> Title: Euler problems/21 to 30 - HaskellWiki, http://tinyurl.com/3z96ab
02:36:49 <Lord_Illidan> I am not sure what this code is doing : let names = sort $ read$"["++ input++"]"
02:36:57 <Lord_Illidan> never saw read being used by that
02:37:11 <EvilTerran> my solution is 4 lines
02:37:24 <EvilTerran> two of which are "import Control.Monad; import Data.List"
02:37:27 <EvilTerran> <.<  >.>
02:38:16 <Lord_Illidan> I still have to get the hang of monads, though
02:38:29 <Axman6> Lord_Illidan: it's just turning it into a string that looks like a list, and then into a list of names
02:38:41 <EvilTerran> actually, 3 lines, i don't need Control.Monad
02:38:46 <Axman6> heh
02:39:26 <EvilTerran> but i did preprocess the file to replace "\",\"" with " "
02:39:30 <EvilTerran> probably in perl
02:39:46 <Lord_Illidan> yes, EvilTerran, that's what's getting me, those back slashes in the output
02:40:48 <int-e> heh. I included the file in the haskell source ;)
02:41:29 <nha__> jsnx: you have a freetype binding?
02:41:43 <Axman6> awesome: ghc-6.8.3: panic! (the 'impossible' happened)
02:41:43 <Axman6>   (GHC version 6.8.3 for i386-apple-darwin):
02:41:43 <Axman6> 	linkBCO: >= 64k insns in BCO
02:41:57 <retrohscoder> O_o
02:42:38 * EvilTerran removes the preprocessing requirement
02:42:44 <EvilTerran> ok, now it's four lines again
02:42:59 <birkenfeld> Axman6: I know that error...
02:43:25 <Axman6> there's not a limit on the number of bytes a .hs file can be is there? :\
02:43:37 <birkenfeld> it's something with overlong lists
02:43:56 <birkenfeld> it happened to me for an Alex-generated lexer
02:44:08 * EvilTerran refactors a bit
02:44:22 <Axman6> lame
02:44:35 <birkenfeld> but only for GHCi
02:44:57 <retrohscoder> anyone know the HOpenGL equivalent to glEnable(GL_DEPTH_TEST); ?
02:45:34 <Twey> And it's not `glEnable gL_DEPTH_TEST`?
02:46:09 <ivanm> what's a pattern binding? when you define a function with no or implicit parameters?
02:46:21 <EvilTerran> Lord_Illidan, if you're interested, here's my solution: http://hpaste.org/10888#a1
02:46:23 <ivanm> (e.g. f = (+) 1)
02:46:29 <Deewiant> retrohscoder: depthFunc $= Just Less
02:46:57 <vixey> (f,g,h) = ((+1),(*2),5448)
02:47:03 <retrohscoder> Deewiant: thanks
02:47:28 <Axman6> birkenfeld: fixed it, just replaced random ','s with "] ++  ["
02:47:31 <Axman6> :P
02:47:45 <birkenfeld> hehe
02:47:51 <EvilTerran> ivanm, a simple binding is just <name> = ..., a function binding is when it has parameters, and a pattern binding is when a constructor is involved
02:47:52 <EvilTerran> iirc
02:47:59 <Lord_Illidan> Nice, but you changed the names.txt didn't you?
02:48:06 <ivanm> EvilTerran: *nod*
02:48:10 <Lord_Illidan> That's what confusing me the most, the I/O part
02:48:27 <ivanm> EvilTerran: so a pattern binding is a special case of a simple binding, a function binding or either?
02:48:52 <EvilTerran> ivanm, http://haskell.org/onlinereport/decls.html#sect4.4.3
02:48:53 <lambdabot> Title: The Haskell 98 Report: Declarations
02:49:06 <EvilTerran> no, a simple binding is the intersection of function bindings and pattern bindings
02:49:11 <ivanm> EvilTerran: yeah, I'm looking at it
02:49:24 <ivanm> there's no constructors there that I can see :s
02:49:40 <EvilTerran> in that there's no parameters in the pattern (so it could be a pattern binding), and there's no constructors in it (so it could be a function binding)
02:49:51 <ivanm> also, why is it guarded for the p match?
02:50:29 <EvilTerran> Lord_Illidan, i didn't change names.txt for that version
02:50:58 <EvilTerran> Lord_Illidan, (map preproc) replaces the quotemarks and commas with spaces, so (words) can break it up correctly
02:51:56 <Lord_Illidan> I see
02:52:07 <Lord_Illidan> I prefer your version to the read$ version, actually
02:52:09 <Lord_Illidan> Thanks
02:52:29 * EvilTerran is cunning :D
02:52:55 <Lord_Illidan> however, your claim of 4 lines is deceptive
02:53:00 <Lord_Illidan> you're using semicolons
02:53:08 <EvilTerran> > read $ "[" ++ "\"foo\",\"bar\",\"baz\"" ++ "]" :: [String]
02:53:09 <lambdabot>   ["foo","bar","baz"]
02:53:14 <EvilTerran> that's what the read$ version is doing
02:53:18 <EvilTerran> eh
02:53:21 <ivanm> EvilTerran: OK.... so it's a pattern binding whenever the LHS contains a single "thing"?
02:53:36 <EvilTerran> Lord_Illidan, i'd be more inclined to disqualify my version for having a line of >80 characters
02:53:50 <EvilTerran> Lord_Illidan, seeing as it'd be a simple modification to get rid of those semicolons
02:53:58 <Lord_Illidan> Why, is having long lines frowned upon in haskell?
02:54:16 <EvilTerran> preproc x = if x == ',' || x == '"' then ' ' else x
02:54:30 <EvilTerran> because otherwise you could cram most programs onto one line (apart from the imports)
02:54:36 <luqui> Long lines is typically frowned upon in all programming...
02:54:49 <luqui> s/is/are/   (derrr)
02:54:57 <Lord_Illidan> True :D *hides*
02:54:57 <EvilTerran> and 80 is the traditional width of terminals, so makes for a reasonable arbitrary limit
02:55:17 <EvilTerran> ivanm, i'm not explaining this very well, er... =/
02:55:19 <Lord_Illidan> I've got a 177 long line in one of my programs :|
02:55:28 <luqui> EvilTerran, even the imports
02:55:40 <luqui> module Foo where { import Bar; import Baz; ... }
02:55:42 <EvilTerran> luqui, well, Lord_Illidan seems to count ; as a line delimiter
02:55:44 <Lord_Illidan> and a 195 long line in another :|
02:56:11 <EvilTerran> ivanm, it's a pattern binding if the LHS of the = is, well, a pattern
02:56:12 <luqui> EvilTerran, oh you're talking about just writing the whole program as a huge lambda expr?
02:56:19 <EvilTerran> luqui, pretty much, yeah :P
02:56:22 <Lord_Illidan> However, I do use long variable names
02:56:26 <EvilTerran> main = <big scary thing>
02:56:47 <EvilTerran> use >> and >>= instead of do-notation, etcetc
02:57:03 <ivanm> EvilTerran: so something like "addOne = map (+1)" is a pattern binding, because the LHS is a solitary "object"?
02:57:06 <Lord_Illidan> Oh, and can anyone enlighten me, in "[" ++ "\"foo\",\"bar\",\"baz\"" ++ "]" , what the heck are the backslashes?
02:57:32 <ivanm> Lord_Illidan: well, if strings are contained by "...", how do you put a " in a String?
02:57:47 <ivanm> you quote it out, using a backslash
02:57:55 <EvilTerran> ivanm, yeah, pretty much; something's a pattern iff it's valid to use it on the LHS of a -> in a case
02:58:02 <Lord_Illidan> ah, curse me for a fool
02:58:05 <ivanm> *nod*
02:58:10 <EvilTerran> you can't say "case ... of foo x -> ..."
02:58:11 * ivanm curses Lord_Illidan for a fool
02:58:13 <ivanm> happy now? :p
02:58:23 <Lord_Illidan> 10x
02:58:34 <ivanm> EvilTerran: ahhhhh..... but are functions like what I had above also pattern bindings?
02:58:40 <ivanm> because haskell-src says they are :p
02:58:49 <EvilTerran> ivanm, "foo x = ..." is a function binding, because it's declaring something with a parameter
02:58:56 <EvilTerran> "Foo x = ..." is a pattern binding
02:59:00 <EvilTerran> "foo = ..." could be either
02:59:05 <Axman6> whoot, got problem 22
02:59:21 <ivanm> ahhh
02:59:30 <EvilTerran> ivanm, the report calls things of the form "foo = ..." a "simple pattern binding"
02:59:35 <ivanm> EvilTerran: *nod*
02:59:39 <ivanm> that makes more sense now :p
02:59:59 <Lord_Illidan> when I do this, though : let hello = "\"foo\",\"bar\",\"baz\""; hello
03:00:09 <Lord_Illidan> I get a bunch of underlines
03:00:15 <Lord_Illidan> I mean, backslashes
03:00:18 <EvilTerran> which is why i said "simple pattern bindings are the intersection of pattern bindings and function bindings"
03:00:18 * ivanm wished haskell-src was better documented, as to what it's shortened forms mean
03:00:29 <retrohscoder> what would one need to do in order to implement a nested for-loop such as this?
03:00:29 <EvilTerran> Lord_Illidan, that's because it's passing the string to show
03:00:31 <retrohscoder> for (i = -3; i < 3; i++) {
03:00:33 <retrohscoder>         for (j = -3; j < 3; j++) {
03:00:35 <retrohscoder>             foo(i * 10.0, j * 10.0);
03:00:36 <retrohscoder>             foo2(); foo3();
03:00:38 <retrohscoder>         }
03:00:39 <ivanm> > "\"foo\",\"bar\",\"baz\""
03:00:40 <retrohscoder>     }
03:00:41 <lambdabot>   "\"foo\",\"bar\",\"baz\""
03:00:41 <Lord_Illidan> I see, damn ghci
03:00:44 <EvilTerran> retrohscoder, please use a pastebin
03:00:52 <Axman6> far out... why does my solution take 0.024s :|
03:00:55 <retrohscoder> EvilTerran: sorry.
03:00:56 <ivanm> retrohscoder: first of all, not paste it directly into IRC :p
03:00:58 <EvilTerran> > show "this string has a \" in it"
03:00:59 <Axman6> haskell confuses me >_<
03:00:59 <lambdabot>   "\"this string has a \\\" in it\""
03:01:04 <EvilTerran> > show $ show "this string has a \" in it"
03:01:05 <lambdabot>   "\"\\\"this string has a \\\\\\\" in it\\\"\""
03:01:15 <EvilTerran> > fix show -- and one more for laughs
03:01:17 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
03:01:31 <retrohscoder> http://pastebin.ca/1218840
03:01:35 <kaol> :t fix show
03:01:37 <lambdabot> String
03:02:01 <kaol> :t (fix, show)
03:02:02 <lambdabot> forall a a1. (Show a1) => ((a -> a) -> a, a1 -> String)
03:02:07 <EvilTerran> Lord_Illidan, try: putStrLn "this string has a \" in it"
03:02:08 <EvilTerran> in ghci
03:02:36 <Lord_Illidan> yes, that works
03:02:37 <EvilTerran> Lord_Illidan, the way ghci outputs things is, if their type is IO <something> it runs them as-is, otherwise, it wraps them in a call to print
03:02:39 <EvilTerran> ?src print
03:02:39 <lambdabot> print x = putStrLn (show x)
03:02:45 <Lord_Illidan> I see
03:02:51 <Lord_Illidan> Ah well, I'm learning more about ghci
03:02:52 <retrohscoder> anyone?
03:02:54 <Lord_Illidan> thanks
03:03:12 <ivanm> what's that scanl1 function on fix show?
03:03:25 <Axman6> retrohscoder: something like [foo1 (10*a) (10*b) | a [(-3)..3], b <- [(-3)..3]] should do it, without the foo2 or foo3... and you get a list...
03:03:35 <Axman6> but, you'll figure it out. forget about loops, they
03:03:38 <Axman6> re silly
03:03:41 <Axman6> >_>
03:03:44 <EvilTerran> > [(x,y) | x <- "ABC", y <- [1,2,3]] -- retrohscoder
03:03:44 <retrohscoder> haha
03:03:45 <lambdabot>   [('A',1),('A',2),('A',3),('B',1),('B',2),('B',3),('C',1),('C',2),('C',3)]
03:03:49 <ivanm> retrohscoder: what are foo2 and foo3?
03:04:07 <retrohscoder> just more functions that need to be called inside the inner loop
03:04:20 <Axman6> retrohscoder: you can't really do that in haskell
03:04:23 <ivanm> > [(i*10,j*10) | i <- [-3..3], j <- [-3,3] ]
03:04:25 <lambdabot>   [(-30,-30),(-30,30),(-20,-30),(-20,30),(-10,-30),(-10,30),(0,-30),(0,30),(1...
03:04:26 <ivanm> retrohscoder: ^^
03:04:33 <ivanm> that's probably the closest you can get
03:04:37 <Axman6> since they almost certianly will ahve side effects right?
03:04:37 <EvilTerran> Lord_Illidan, another thing you might find useful about ghci; you can write anything you could have in a line in a do-block too
03:04:38 <kaol> if it's something that has side effects, look for forM
03:04:39 <ivanm> but don't forget, IO is _bad_
03:05:05 <retrohscoder> hmmm
03:05:17 <retrohscoder> thanks I've got some different ideas to think about
03:05:17 <EvilTerran> Lord_Illidan, such as "let x = ...; y = ...", which would bring x and y into scope for future use
03:05:20 <Axman6> Lord_Illidan: was it you who posted the problem 22?
03:05:42 <EvilTerran> Lord_Illidan, or "x <- ...", which'd do the same, only running ... as an IO action instead of just taking it as-is
03:05:54 <kaol> > forM [1..3] (\x -> forM [1..3] (\y -> return (x,y)))
03:05:55 <lambdabot>       No instance for (Show (m [[(t, t1)]]))
03:05:55 <lambdabot>        arising from a use of `sh...
03:06:28 <ivanm> EvilTerran: so, whenever a variable is defined, it would also be a simple pattern binding?
03:06:45 <EvilTerran> ivanm, yeah, as long as you're not doing any pattern-matching
03:06:55 <EvilTerran> "x = ..." - simple pattern binding
03:07:00 <EvilTerran> "(x,y) = ..." - pattern binding
03:07:05 <ivanm> ahhhh
03:07:48 <kaol> > forM [1..3] (\x -> forM [1..3] (\y -> return (x,y))) :: Maybe [[(Int, Int)]]
03:07:49 <lambdabot>   Just [[(1,1),(1,2),(1,3)],[(2,1),(2,2),(2,3)],[(3,1),(3,2),(3,3)]]
03:08:05 <Axman6> x = ... will match anything (of the right type), things like (x,y), (Just a) will only match things of the form (a,b), Just x etc
03:08:06 <kaol> ghci's automatic lifting to IO struck again
03:09:17 <Axman6> retrohscoder: it's usually a bad idea to try and directly convert something imperative to haskell. you need to thinks about things differently (ie. better)
03:09:32 <retrohscoder> Axman6: yeah I know that
03:09:37 <kaol> or perhaps forM_ if the side effects are all you want
03:09:40 <retrohscoder> I'm working on it
03:19:19 <Axman6> @hoogle sort
03:19:20 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
03:19:20 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
03:19:20 <lambdabot> Data.ByteString.Char8 sort :: ByteString -> ByteString
03:19:26 <Axman6> @hoogle isSort
03:19:26 <lambdabot> No results found
03:19:29 <Axman6> hmm
03:32:40 <ttt--> Is the splice function $() from template haskell directly available? something Exp -> String
03:32:57 <ttt--> or ExpQ
03:34:10 <EvilTerran> the splice is a no-op
03:34:28 <EvilTerran> it's not converted to a string and then parsed again, the syntax tree is spliced in directly
03:34:37 <ttt--> oh i see
03:34:40 <EvilTerran> but i believe there's a prettyprinting function somewhere
03:34:48 <ttt--> too bad :)
03:34:50 <ttt--> oh
03:35:23 <EvilTerran> , ppr [| \x -> (x,x) |]
03:35:30 <lunabot>  luna: No instance for (Language.Haskell.TH.Ppr.Ppr
03:35:30 <lunabot>                     Language.Haskell.TH.Lib.ExpQ)
03:35:30 <lunabot>    arising from a use of `Language.Haskell.TH.Ppr.ppr'
03:35:42 <EvilTerran> hm
03:35:53 <EvilTerran> , pprint <$> [| \x -> (x,x) |]
03:35:55 <lunabot>  luna: Not in scope: `<$>'
03:36:08 <EvilTerran> , pprint `fmap` [| \x -> (x,x) |] {- GAH -}
03:36:13 <lunabot>  \x_0 -> (x_0, x_0)
03:36:17 <EvilTerran> there we go
03:36:29 <ttt--> awesome, thanks
03:36:54 <EvilTerran> Language.Haskell.TH.pprint :: Ppr a => a -> String
03:37:12 <ttt--> , pprint (LitE (IntegerL 3))
03:37:15 <lunabot>  "3"
03:47:47 <pmurias> what's the state of hat - the Hakell Tracer?
03:49:53 <EvilTerran> it's haskell, it's stateless :P
03:50:18 <jmg> hi everyone
03:51:00 <vixey> hello
03:52:18 <jmg> does anyone know how to tell cabal-install to generate hoogle databases files for every installed packacke?
03:58:22 <pmurias> EvilTerran: you know if hat works with the latest ghc?
03:58:36 <EvilTerran> pmurias, no, sorry - i was just being silly :P
03:59:32 <Lord_Illidan> Sorry everyone I had to go out
04:43:38 <vixey> ?users
04:43:38 <lambdabot> Maximum users seen in #haskell: 516, currently: 481 (93.2%), active: 3 (0.6%)
04:46:37 <byorgey> morning vixey
04:46:44 <vixey> hello byorgey
04:48:53 <byorgey> vixey: how's your language coming? =)
04:49:42 <vixey> most of it is in my head :)
04:50:04 <vixey> I think I will probably have a go at implementing induction-recursion at some point
04:50:31 <byorgey> cool =)
04:50:39 <vixey> (so that's like when you define some data mutually recursive with some functions)
04:58:02 <vixey> j #math
05:05:34 <mmorrow> , src 'Just
05:05:46 <lunabot>  luna: Not in scope: type constructor or class `Just'
05:05:49 <mmorrow> hmm
05:05:59 <BONUS> so get this http://luqui.org/blog/archives/2008/10/03/laziness-and-the-monad-laws/
05:06:07 <vixey> , src 'Maybe
05:06:09 <lunabot>  luna: Not in scope: data constructor `Maybe'
05:06:12 <lambdabot> Title: Laziness and the monad laws @ The dreams that stuff is made of, http://tinyurl.com/3oqxqa
05:06:13 <mmorrow> , src ''Just
05:06:15 <lunabot>  luna: Not in scope: type constructor or class `Just'
05:06:17 <mmorrow> , src ''Maybe
05:06:17 <BONUS> interesting thing: the Identity monad is implemented like this
05:06:21 <lunabot>  data Maybe a = Nothing
05:06:21 <lunabot>               | Just a
05:06:32 <BONUS> m >>= f = f (runIdentity m)
05:06:33 <mmorrow> i wonder why it can't find Just
05:06:38 <mmorrow> , Just 20
05:06:40 <lunabot>  Just 20
05:06:43 <BONUS> and it seems like that doesnt satisfy right unit
05:06:44 <BONUS> welp
05:06:46 <vixey> , data T = O | T T T
05:06:48 <lunabot>  luna: parse error on input `data'
05:06:50 <mmorrow> , src 'Maybe.Just
05:06:52 <lunabot>  luna: Not in scope: data constructor `Maybe.Just'
05:07:03 <luqui> BONUS, that's because Identity is a newtype
05:07:08 <luqui> so Identity _|_ and _|_ are the same
05:07:19 <mmorrow> , 'Just
05:07:20 <BONUS> oooh, I totally overlooked that
05:07:21 <lunabot>  Data.Maybe.Just
05:07:21 <BONUS> yeah
05:07:31 <BONUS> excellent
05:07:50 <BONUS> this OneTuple thing is strange though
05:07:52 <mmorrow> ahh. somehow i'm losing the info in the Name over the course of the un-uglifying/dyn-evaling
05:07:59 <BONUS> why implement OneTuple as a library when there's already Identity
05:08:04 <mmorrow> oh
05:08:07 <luqui> yeah, in spite of it's triviality, it's weird to me too
05:08:36 <luqui> BONUS, well, take for example Mu Identity vs. Mu OneTuple.  THe former has only one value, whereas the latter has infinitely many.
05:08:44 <mmorrow> , [d|data T = O | T T T|]
05:08:47 <lunabot>  DataD [] T [] [NormalC O [],NormalC T [(NotStrict,ConT T),(NotStrict,ConT...
05:08:51 <BONUS> ah, hmm
05:08:52 <Axman6> @where Data.Ratio
05:08:52 <lambdabot> I know nothing about data.ratio.
05:08:52 <luqui> Mu OneTuple actually has a most peculiar domain ordering
05:09:01 <Axman6> @where Ratio
05:09:02 <lambdabot> I know nothing about ratio.
05:09:08 <byorgey> people, I'm pretty sure OneTuple was intended as a joke.
05:09:09 <vixey> , let foldT o t O = o ; foldT o t (T x y) = t (foldT o t x) (foldT o t x)
05:09:11 <lunabot>  luna: parse error on input `)'
05:09:24 <luqui> it's just the naturals, but with 0 [= 1 [= 2 [= 3 [= ...
05:09:28 <byorgey> I don
05:09:32 <mmorrow> vixey: heh. not quite yet. i /really/ want to figure out how to make that work though ;)
05:09:38 <vixey> yay
05:09:38 <byorgey> don't know how else to read the announcement email =)
05:09:47 * vixey looks forward to it
05:09:59 <luqui> so functions from Mu OneTuple are "gradual refinements"
05:10:16 <luqui> of some single value
05:11:01 <Axman6> > 428%999 :: Rational
05:11:02 <lambdabot>   428%999
05:11:08 <Axman6> > 428%999 ::Double
05:11:09 <lambdabot>   Couldn't match expected type `Double'
05:11:24 <Axman6> > 428/999
05:11:26 <lambdabot>   0.42842842842842843
05:11:29 <mauke> > 428/999 :: Rational
05:11:30 <lambdabot>   428%999
05:11:33 <Axman6> > 3/7
05:11:35 <lambdabot>   0.42857142857142855
05:12:04 <mauke> > toRational 0.42857142857142855
05:12:06 <lambdabot>   7720456504063707%18014398509481984
05:12:46 <Axman6> > 428/999 :: CReal
05:12:47 <lambdabot>   0.4284284284284284284284284284284284284284
05:12:57 <Axman6> > 3/7 :: CReal
05:12:58 <lambdabot>   0.4285714285714285714285714285714285714286
05:13:26 <vixey> :t unfoldr
05:13:28 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
05:13:30 <Axman6> :t 1%2
05:13:31 <lambdabot> forall t. (Integral t) => Ratio t
05:14:08 <vixey> Mu (Maybe (a, _)) ~ [a]
05:14:18 <mapreduce> > toRational 3/7
05:14:19 <lambdabot>   3%7
05:14:27 <vixey> @src []
05:14:28 <lambdabot> data [] a = [] | a : [a]
05:14:51 <Axman6> @src %
05:14:51 <lambdabot> x % y = reduce (x * signum y) (abs y)
05:15:11 <Axman6> @src reduce
05:15:11 <lambdabot> reduce _ 0 = undefined
05:15:16 <lambdabot> reduce x y = (x `quot` d) :% (y `quot` d)
05:15:16 <lambdabot>     where d = gcd x y
05:15:54 <Cthulhon> > toRational $ 3/7
05:15:55 <lambdabot>   7720456504063707%18014398509481984
05:15:59 <vixey> can't really unfold something into a tree in the obvious way
05:21:23 <Axman6> @src Ratio <
05:21:23 <lambdabot> Source not found. Wrong!  You cheating scum!
05:21:26 <Axman6> @src Ratio.<
05:21:26 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
05:21:29 <Axman6> @src Ratio.(<)
05:21:30 <lambdabot> Source not found. Maybe if you used more than just two fingers...
05:21:34 <Axman6> @src Data.Ratio.(<)
05:21:34 <lambdabot> Source not found. Where did you learn to type?
05:21:35 <vixey> ?docs Ratio
05:21:36 <lambdabot> Ratio not available
05:21:39 <vixey> look up in the docs
05:21:39 <Axman6> rawr
05:21:49 <vixey> there is a link to source code
05:24:28 <taruti> Where was the fancy Data.Binary derivate with continuations and error handling?
05:24:43 <Axman6> hmm, i've founf http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Ratio.html#t%3ARatio, no mention of how ordering is performed
05:24:50 <lambdabot> Title: Data.Ratio, http://tinyurl.com/ytrm99
05:24:58 <vixey> oh
05:25:02 <vixey> maybe it's in the report then
05:25:09 <vixey> or the Prelude
05:26:27 <mauke> (x:%y) <  (x':%y')  =  x * y' <  x' * y
05:27:27 <Axman6> yeah, found it eventually. thanks :)
05:28:10 <mm_freak_> is there a way to get the number of threads the user specified in the threaded RTS?
05:28:17 <ivanm> mmorrow: in haskell-src-exts, do you know what "HsIPBind" represents?
05:36:42 <ttt--> What does this mean: "Cannot find module .. it is hidden"
05:37:57 <Beelsebob> anyone know of a good un-directed graph module?
05:40:39 <mmorrow> ivanm: an irrefutable pattern
05:40:42 <mmorrow> , parseHsPat "~(a,b)"
05:40:45 <lunabot>  Right (HsPParen (HsPIrrPat (HsPTuple [HsPVar (HsIdent "a"),HsPVar (HsIden...
05:41:09 <mmorrow> oh, HsIPBind... hmm, a sec
05:41:13 <ivanm> heh
05:41:25 <ivanm> but what _does_ an irrefutable pattern mean, anyway?
05:41:35 <mm_freak_> ttt--: ghc --make
05:42:10 <ivanm> oh, wait, looks like it's the binding using ?x, etc.
05:42:24 <ttt--> mm_freak_, same error
05:42:30 <kolmodin> ?tell nattfodd cinnamon roll day today! hope you get some too :)
05:42:30 <lambdabot> Consider it noted.
05:43:16 <mm_freak_> oh
05:45:01 <mmorrow> ohh, cool.
05:45:10 <mmorrow> it's an implicit parameter
05:45:17 <mmorrow> , prettyPrint (HsIPBind (SrcLoc [] 0 0) (HsIPDup "a") (HsLit (HsInt 42)))
05:45:20 <lunabot>  "?a = 42"
05:46:08 <mmorrow> , src 'HsIPBind
05:46:16 <ivanm> OK, that makes sense
05:46:21 <lunabot>  data HsIPBind = HsIPBind SrcLoc HsIPName HsExp
05:46:48 <mmorrow> , src 'HsIPVar
05:46:54 <lunabot>  luna: Not in scope: type constructor or class `HsIPVar'
05:47:22 <mmorrow> heh, i just realized why none of the names with a single "'" are working.
05:47:31 * mmorrow fixes
05:48:33 <ivanm> oh?
05:49:32 <golubovsky> Hi everybody, Dimitry is here
05:51:07 <Saizan> do we have an haskell audio player yet?
05:51:11 <golubovsky> I have a question: if I found a problem in HEAD library (that is, at darcs.haskell.org) which trac would I use to report a ticket?
05:51:29 <ivanm> Saizan: I think dons made one once...
05:51:56 <Saizan> ivanm: it could only play mp3s though, iirc
05:52:55 <Saizan> golubovsky: the ghc one if it's one in libraries/
05:52:56 <ivanm> yeah
05:53:43 <golubovsky> OK, thanks, will submit to GHC.
05:54:29 * golubovsky went to submit a ticket...
05:54:33 <golubovsky> bye.
05:57:10 <skorpan> http://i34.tinypic.com/2418608.jpg
05:58:43 <konstantin_> Hi!
05:59:00 <konstantin_> I am Haskell newbie
05:59:09 <konstantin_> please point me in right direction
05:59:25 <konstantin_> my function should return different results
05:59:36 <vixey> hello
05:59:41 <vixey> :)
05:59:47 <konstantin_> when it gots empty list, list with single element and list with multiple elements
06:00:01 <konstantin_> What is the best way to implement the fnction?
06:00:05 <vixey> what is your function called?
06:00:24 <konstantin_> vixey, it doesn't matter. func1
06:00:31 <vixey> oh it does matter
06:00:35 <konstantin_> vixey, i am trying to find approach :-)
06:00:40 <konstantin_> vixey, why?
06:00:48 <vixey> well does it classify the list, so we can call it classify
06:00:51 <ttt--> hi, i cant seem to load a module, ghc says it is hidden: http://hpaste.org/10889
06:01:04 <vixey> and what type of values does it give?
06:01:15 <vixey> i.e. it takes in a list [a], but what does it give out?
06:01:34 <konstantin_> vixey, [a] -> Maybe a
06:01:47 <vixey> ok so now you can write the first line,
06:01:51 <vixey> classify :: [a] -> Maybe a
06:02:04 <konstantin_> vixey, yep. classify [] = Nothing
06:02:08 <vixey> and you now have to write 3 equations, with the patterns of type [a]
06:02:13 <vixey> yeah you know how to do it
06:02:23 <Olathe> > let omg [] = 0; omg [x] = 1; omg (x:xs) = 1.0/0.0 in omg [1..3]
06:02:24 <lambdabot>   Infinity
06:02:53 <konstantin_> does classify [x] = Maybe x match with single element list?
06:03:07 <Olathe> konstantin_: Yes.
06:03:14 <konstantin_> Thanks.
06:03:22 <konstantin_> Will it match always?
06:03:36 <konstantin_> Or it will match only if i will define 3rd line
06:03:47 <konstantin_> with classify (x:xs) = ....
06:03:52 <konstantin_> ?
06:03:55 <vixey> if you have patterns,
06:03:58 <vixey> foo P1 = ...
06:04:00 <vixey> foo P2 = ...
06:04:03 <vixey> foo P3 = ...
06:04:05 <vixey> etc
06:04:18 <Olathe> > let omg [] = "Empty"; omg [x] = "One element: " ++ show x; omg (x:xs) = "Many elements: " ++ (concat.intersperse ", ".map show $ (x:xs)) in omg [1..3]
06:04:19 <vixey> it will always try to match with P1, and only if it didn't work, it'll try P2
06:04:19 <lambdabot>   "Many elements: 1, 2, 3"
06:04:23 <Olathe> > let omg [] = "Empty"; omg [x] = "One element: " ++ show x; omg (x:xs) = "Many elements: " ++ (concat.intersperse ", ".map show $ (x:xs)) in omg [1]
06:04:24 <lambdabot>   "One element: 1"
06:04:26 <Olathe> > let omg [] = "Empty"; omg [x] = "One element: " ++ show x; omg (x:xs) = "Many elements: " ++ (concat.intersperse ", ".map show $ (x:xs)) in omg []
06:04:27 <lambdabot>   "Empty"
06:04:42 <konstantin_> ok. order matters
06:04:49 <Olathe> Yep.
06:04:54 <konstantin_> Thanks
06:08:40 <byorgey> konstantin_: also, classify [x] = Maybe x  is not correct; Maybe is a type constructor.  I think you mean  classify [x] = Just x
06:09:05 <byorgey> Just and Nothing create Maybe values
06:09:20 <konstantin_> byorgey, huh :-) ghci told me about this
06:09:24 <konstantin_> few seconds ago
06:09:27 <byorgey> hehe, I bet it did =)
06:09:53 <konstantin_> byorgey, anyway thank you for your caution
06:21:34 <Twey> @src (.)
06:21:35 <lambdabot> (f . g) x = f (g x)
06:23:11 <konstantin_> @src Maybe
06:23:12 <lambdabot> data Maybe a = Nothing | Just a
06:23:19 <konstantin_> @src tail
06:23:19 <lambdabot> tail (_:xs) = xs
06:23:19 <lambdabot> tail []     = undefined
06:23:36 <konstantin_> @src last
06:23:36 <lambdabot> last [x]    = x
06:23:36 <lambdabot> last (_:xs) = last xs
06:23:36 <lambdabot> last []     = undefined
06:25:47 <tirpen> Can anyone explain what the RWS monad is? from the type signatures I get the feeling that it's a combined reader, writer and state monad, is this about correct?
06:26:07 <konstantin_> @src init
06:26:07 <lambdabot> init [x]    = []
06:26:07 <lambdabot> init (x:xs) = x : init xs
06:26:07 <lambdabot> init []     = undefined
06:26:56 <dblazakis> tirpen: i have no idea, but it seems like the name matches up too -- RWS (Read/Write/State)
06:27:31 <tirpen> That was my thought too, and it has type r -> s -> (a, s, w) so it kind of makes sense.
06:28:11 <tirpen> I'm working my way through all the standard libs, trying to understand what each of them do, but this one kind of stumped me. :)
06:31:38 <dblazakis> tirpen: heh, i'm sure there are many more to puzzle over ;-)
06:32:08 <mmorrow> , src 'Just
06:32:11 <konstantin_> I give up
06:32:13 <lunabot>  data Maybe a = ... | Just a | ...
06:32:13 <lunabot>  infixl 9
06:32:28 <konstantin_> I can not complete task :-(
06:32:46 <mmorrow> , src 'DataD
06:32:50 <lunabot>  luna: Not in scope: data constructor `Language.Haskell.TH.Syntax.DataD'
06:32:55 <mmorrow> grgr
06:33:17 <ozy`> > a ^&$ b = [a, b] ++ (a ^&$ b)
06:33:17 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 16}
06:33:17 <lambdabot> ...
06:33:31 <mmorrow> , DataD
06:33:33 <lunabot>  luna: No instance for (GHC.Show.Show
06:33:33 <lunabot>                     (Language.Haskell.TH.Syntax.Cxt
06:33:33 <lunabot>                      -> Language.Haskell.TH.Syntax.Name
06:33:41 <tirpen> dblazakis: There sure is, I think I get what almost everythin in the Data.* and Control.* groups does now however. And that's probably enought to get along fine for a while.
06:33:44 <ozy`> how do I invented operator? ¯\O_o/¯
06:33:52 <mmorrow> , src 'Left
06:33:56 <lunabot>  data Either a b = ... | Left a | ...
06:33:56 <lunabot>  infixl 9
06:36:41 <mmorrow> , src 'DataD
06:36:45 <lunabot>  data Dec = ... | DataD Cxt | ...
06:36:45 <lunabot>  infixl 9
06:36:51 <mmorrow> @yow
06:36:52 <lambdabot> ... My pants just went on a wild rampage through a Long Island Bowling Alley!!
06:37:19 <mmorrow> awcrap
06:37:38 <Beelsebob> @vixen why would your pants do that?
06:37:39 <lambdabot> why not?
06:37:45 <Beelsebob> @vixen fair point
06:37:46 <lambdabot> ever feel like you're going around in circles?
06:38:03 <ozy`> > _ <?> _ = "pizza"
06:38:04 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 16}
06:38:04 <lambdabot> ...
06:38:43 <ozy`> I get the feeling lambdabot isn't in a particularly cooperative mood today
06:39:08 <Beelsebob> > let _ <?> _ = "pizza" in 5 <?> 10
06:39:08 <tirpen> let  _ <?> _ = "pizza"
06:39:09 <lambdabot>   "pizza"
06:39:14 <ozy`> ahhhh
06:39:15 <ozy`> well then
06:39:17 <tirpen> 12431 <?> 33
06:39:19 <tirpen> > 12431 <?> 33
06:39:20 <lambdabot>   Not in scope: `<?>'
06:39:32 <Beelsebob> @let _ <?> _ = "pizza"
06:39:33 <lambdabot>  Defined.
06:39:41 <Beelsebob> > 123431 <?> 33
06:39:42 <lambdabot>   "pizza"
06:39:53 <tirpen> Ah, I knew it was something like that. :)
06:39:58 <Beelsebob> ahh, the well known pizza combinator
06:40:01 <Beelsebob> how we missed you
06:40:49 <byorgey> > 1 <?> 2 <?> 6 <?> "foo" <?> [True,False]
06:40:50 <lambdabot>   "pizza"
06:40:52 <tirpen> foldr (<?>) _ ["So","very","useful!"]
06:40:54 <mmorrow> , src 'DataD
06:40:54 <tirpen> > foldr (<?>) _ ["So","very","useful!"]
06:40:54 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
06:40:54 <lambdabot>  ...
06:40:58 <lunabot>  Killed.
06:40:59 <mmorrow> , src 'DataD
06:41:04 <lunabot>  Killed.
06:41:30 <Beelsebob> > foldr (<?>) undefined ["so","very","useful"]
06:41:31 <byorgey> tirpen: _ only works as a pattern, not as an arbitrary value
06:41:31 <lambdabot>   "pizza"
06:41:36 <tirpen> > foldr (<?>) "" ["So","very","useful!"]
06:41:37 <lambdabot>   "pizza"
06:41:42 <tirpen> Ahhh.
06:41:57 <mmorrow> , src 'DataD
06:42:02 <lunabot>  data Dec = ... | DataD Cxt Name ([Name]) ([Con]) ([Name]) | ...
06:42:02 <lunabot>  infixl 9
06:42:04 <mmorrow> finally
06:42:19 <mmorrow> , src 'Left
06:42:24 <lunabot>  data Either a b = ... | Left a | ...
06:42:24 <lunabot>  infixl 9
06:44:23 <ozy`> @let a ^&%$ b = case a of "pepperoni" -> b | otherwise -> b : ("cheese" ^&%$ b)
06:44:24 <lambdabot>   Parse error
06:45:24 <ozy`> can new operators only be defined with angle bracket notation?
06:45:44 <byorgey> I think the error it was complaining about was the | in between your cases
06:45:51 <ozy`> oh, that might be it
06:46:00 <ziman> let a #$%^ b = 1 in 6 #$%^ 8
06:46:02 <ziman> > let a #$%^ b = 1 in 6 #$%^ 8
06:46:03 <lambdabot>   1
06:46:06 <byorgey> should be  case blah of { pattern -> result ; pattern -> ... }
06:47:17 <ozy`> d'oh, right, ML uses | for matching... Haskell just uses it for guards
06:49:35 <ako_0_> What are guards?
06:50:39 <ozy`> > let a <?> b | a == "pepperoni" = b
06:50:40 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
06:50:40 <lambdabot>  ...
06:50:55 <ozy`> I might be doing it wrong again
06:51:00 * ozy` checks
06:51:45 <Beelsebob> @let "pepperoni" <?> b = b
06:51:46 <lambdabot>  <local>:3:0:
06:51:46 <lambdabot>      Warning: Pattern match(es) are overlapped
06:51:46 <lambdabot>               In...
06:51:51 <ivanm> is there a version of \\ that deletes _all_ matches?
06:51:56 <mmorrow> , src '(:)
06:51:58 <ivanm> since \\ only deletes the first match :s
06:52:00 <lunabot>  data [a] = ... | (:) a ([a]) ([a]) | ...
06:52:00 <lunabot>  infixr 5
06:54:08 <ozy`> > let my_min a b | a < b = a
06:54:08 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
06:54:08 <lambdabot>  ...
06:54:19 <ozy`> > let my_min a b | a < b = a in my_min 3 5
06:54:20 <lambdabot>   3
06:54:32 <ozy`> ako_0_: gentlemen, behold
06:54:39 <Axman6> is there any predefined way to do a parallel filter on a list?
06:55:42 <Axman6> or parallel list comprehensions
06:55:45 <ozy`> Axman6: parallel in the sense of concurrent?
06:55:54 <Axman6> yeah
06:56:00 <b_jonas> Axman6: filter with the filtering function backgrounded
06:56:07 <mmorrow> , src '(:)
06:56:11 <lunabot>  data = ... | (:) a ([a]) | ...
06:56:11 <lunabot>  infixr 5
06:56:24 <mmorrow> sigh
06:57:01 <Axman6> bah, i need a better solution to this problem -_-
06:57:19 <ako_0_> ozy`: I've not really learnt any Haskell yet, about to read a book, a spec of info here and there will make my reading/learning experience much easier :P
06:57:28 <Axman6> it's O(n^2) atm, and n = 1000000
06:57:41 <b_jonas> Axman6: dunno, write a function or something
06:57:48 <Axman6> yeah :\
06:57:58 <Axman6> might use fmap
06:58:04 <Axman6> or somehting
06:58:15 <ozy`> ako_0_: basically, a guard (the part between | and = in my example above) is an additional check on a pattern match
06:58:22 <b_jonas> maybe you need a variant map that runs in parallel and a compress after that
06:58:33 <ako_0_> ozy`: hmm, okay, thanks :0
06:58:35 <hackage> Uploaded to hackage: OneTuple 0.1.1
06:58:39 <ako_0_> s/0$/)/
06:58:57 <b_jonas> there must be a parallel mapM somewhere in the library
06:59:35 <mmorrow> , src '(:)
06:59:39 <lunabot>  data [a] = ... | (:) a ([a]) | ...
06:59:39 <lunabot>  infixr 5
06:59:42 <mmorrow> woohoo
06:59:57 <ozy`> ako_0_: what book are you getting into? presumably RWH?
07:00:39 <ako_0_> ozy`: the craft of Haskell programming, or a single title - any good?
07:00:44 <ako_0_> s/single/similar/
07:01:26 <ozy`> ako_0_: I haven't read any other Haskell books... I'm learning online using RWH
07:01:35 <ako_0_> Ah :)
07:01:50 <ako_0_> ozy`: for my degree I need to use Haskell, probably only to a basic extent
07:02:01 <jpcooper> ako_0_, you are a lucky person
07:02:04 <ozy`> from what I hear, most authors are like "FUNCTIONAL PROGRAMMING IS FUNCTIONAL!!!" whereas these guys are more like "yeah but practical programming is practical. map wash_dish dishes"
07:02:11 <ako_0_> but I can't handle only doing it a little bit, I've got some kind of disorder where I feel I have to become an expert in it
07:02:28 <jpcooper> I came to Glasgow university thinking that there'd be a lot of Haskell. It's turned out that my degree is full of Java. I'm thinking of switching to maths only instead of that and CS
07:02:32 <ako_0_> jpcooper: I was thinking that, I was like "woah, we're going to use Haskell?!"
07:02:39 <ako_0_> Yeah
07:02:42 <ako_0_> We do have Java
07:02:49 <jpcooper> but thankfully I met John O'Donnel and Cordedlia Hall
07:02:51 <vixey> @remember ozy` most authors are like "FUNCTIONAL PROGRAMMING IS FUNCTIONAL!!!" whereas these guys are more like "yeah but practical programming is practical. map wash_dish dishes"
07:02:52 <lambdabot> It is stored.
07:02:57 <ako_0_> I read 60 pages of my Java book and already I'm months ahead of class
07:03:15 <jpcooper> Donnell*
07:03:27 <jpcooper> excuse my typing. We have the heating off to save money
07:05:43 <b_jonas> @pl \x y -> concat $ zipWith replicate x y
07:07:39 <jpcooper> FreeNode: the new Dalnet
07:07:40 <b_jonas> strange
07:08:04 <b_jonas> @bot
07:09:17 --- mode: irc.freenode.net set +o ChanServ
07:09:44 <Ycros> ozy`: my client compressed it down to two lines
07:09:44 <ivanm> Ycros: :o what do you use?
07:09:45 <Ycros> ivanm: irssi :)
07:09:46 <ivanm> ahhh
07:09:47 <Ycros> not sure why I got two lines and Axman6 only got one though
07:10:04 <ozy`> Ycros: I've been bugging the developer of my client to fix the way netsplits are handled
07:10:04 <ivanm> Ycros: longer lines? :p
07:10:15 <ivanm> ozy`: what do you use?
07:10:23 <Axman6> Ycros: maybe i'm more hardcore?
07:10:34 <Ycros> Axman6: ha
07:10:37 <Axman6> ozy`: you're not using linkinus are you?
07:11:10 <ozy`> ivanm, Axman6: Limechat
07:11:23 <Axman6> ah, nice
07:11:51 <Axman6> yeah i can tollerate limechat. the fact you can hack it so easily is a big bonus
07:12:07 <ozy`> yeah
07:12:25 <Axman6> but it's bloated, so i don't use it
07:12:31 <ozy`> I mainly use it because it (alongside irssi, I suppose) is the client that doesn't suck
07:12:49 <ozy`> it's terrible for chatting on freenode
07:12:55 <Axman6> @src catMaybes
07:12:56 <lambdabot> catMaybes ls = [x | Just x <- ls]
07:12:57 <ozy`> specifically because of the netsplits
07:13:30 <vixey> :t concatMap (maybe mzero return)
07:13:31 <lambdabot> forall a. [Maybe a] -> [a]
07:14:11 <Axman6> gahh, i'm failing at project euler atm. i have solutions that will work, but not for quite a few hours
07:14:29 <vixey> hours ...
07:14:37 <Axman6> yes
07:14:38 <ozy`> Axman6: that sounds unpleasant
07:14:42 <Axman6> very
07:14:49 <ozy`> IIRC they're supposed to run in under a few minutes
07:15:12 <Axman6> i can't think of better ways to do them except by slightly reducing the problems, and running them in parallel -_-
07:15:23 <ozy`> so either your algorithm is wrong, or you're stubbing your soul on edge cases (well, maybe side cases) of Haskell's default data structures
07:15:34 <vixey> what's the question?
07:15:44 <Axman6> problems 69 and 71
07:15:49 <vixey> which one
07:15:57 <Axman6> both -_-
07:16:04 <Axman6> start with 71 if you want
07:16:23 <Axman6> that's the one i'm sure there has to be an easier way of doing it
07:17:37 <Lord_Illidan> Can anyone tell me of a way to store stuff in a datastructure?
07:17:38 <n00b> hey guys, i got a piece of code, but i wanna trace it using math and i can't seem to see how it came by the answer i am getting
07:17:40 <mmorrow> :t (maybe mzero return =<<)
07:17:41 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m (Maybe a) -> m a
07:17:47 <n00b> can anyone trace it for me please?
07:18:02 <mmorrow> ?index MonadPlus
07:18:02 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
07:18:09 <mmorrow> ?instances MonadPlus
07:18:09 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
07:19:04 <Ycros> ozy`: I'd hack in some support for you, but I'm not running OSX anywhere at the moment
07:19:36 <n00b> http://hpaste.org/10890
07:19:48 <n00b> here is the code
07:19:59 <n00b> please take a look, i really need to understand what i am doing
07:20:08 <n00b> ???
07:20:12 <ozy`> Ycros: don't sweat it :p
07:21:40 <mm_freak_> say i have an even number of computations, which all have roughly the same run-time…  if i parallelize them using parMap and use two OS threads on dual core, i'd expect a run-time of a bit more than half of the total time
07:21:41 <n00b> http://hpaste.org/10890
07:21:46 <n00b> anyone?
07:22:07 <byorgey> n00b: no need to repeat yourself
07:22:11 <mm_freak_> what i get in practice is that the run-time is reduced to about 75%
07:22:20 <mm_freak_> is this normal or am i doing something wrong?
07:22:29 <vixey> parallelism doesn't work.
07:22:41 <byorgey> n00b: what's the difficulty?
07:22:47 <ozy`> vixey: that's an interesting generalization
07:22:56 <n00b> coins 50 5 = 3765
07:23:07 <n00b> i wanna know how it came by the answer
07:23:12 <mm_freak_> vixey: ?
07:23:17 <n00b> annotate if possible
07:24:01 <Lord_Illidan> Can someone help me out with this... I'm feeling like such a noob http://hpaste.org/10891
07:24:48 <Lord_Illidan> The problem is in the last line sum [x|x<-[1..28123],testAbundantSum x (takeWhile (<x) abundantNumbers)]. Is abundantNumbers being recalculated for every x?
07:24:59 <Lord_Illidan> Because that would explain why it's so slow
07:25:31 <vixey> Lord_Illidan: What's with the type annotations?
07:25:47 <n00b> byorgey can u help me please?
07:25:53 <mmorrow> > map ((`appEndo` 3) . snd) . runWriterT $ (tell (Endo (*2)) >> tell (Endo (join (*))))
07:25:54 <lambdabot>   [18]
07:26:03 <byorgey> n00b: well, the first step in evaluating coins 50 5  would be to check the condition  d <= 0 || x < 0
07:26:12 <byorgey> that is clearly false, as is x == 0
07:26:31 <n00b> understand
07:26:34 <n00b> that
07:26:36 <byorgey> so the third case applies:  coins 50 5 = coins (50-5) 5 + coins 50 4
07:26:50 <n00b> k
07:27:03 <mm_freak_> Lord_Illidan: your bottleneck is the properDivisors function, and yes, it is recalculated for every x
07:27:03 <ronwalf> Is there anyway for GHC to statically link to libGMP (on OS X)?  It keeps linking to GMP.framework, and I can't distribute anything I compile
07:27:10 <mmorrow> sweet. Writer (Endo a) a
07:27:22 <Lord_Illidan> I thought properDivisors was working quite well
07:27:32 <byorgey> the intuition here would be that you can make change for 50 cents using coins with values 1-5 by either using one 5 cent coin and making change for 45, or just making change using coins 1-4
07:27:33 <n00b> when it says (50-5) 5 does it multiply it ?
07:27:33 <Lord_Illidan> given that it's only recalculating up to sqrt x
07:27:48 <Lord_Illidan> and it's also generating pairs
07:27:48 <byorgey> n00b: no, those are just two parameters to the coins function
07:28:00 <n00b> k
07:28:03 <byorgey> so then we have coins 45 5  and coins 50 4
07:28:13 <byorgey> then you apply the definition again to each of those
07:28:24 <Lord_Illidan> mm_freak_, I thought my problem was that I had to memoize abundantNumbers somehow
07:28:29 <n00b> k
07:28:34 <byorgey> coins 45 5 = coins 40 5 + coins 45 4, and coins 50 4 = coins 46 4 + coins 50 3
07:28:39 <byorgey> and so on
07:28:46 <mmorrow> > let endo f = tell (Endo f) in uncurry (flip appEndo) . runWriter $ (endo (*7) >> endo (`div`3) >> return 14)
07:28:47 <lambdabot>   28
07:28:49 <mm_freak_> Lord_Illidan: you don't need to memoize it, since you don't reuse it anyway
07:28:53 <byorgey> you end up with a ginormous tree of calls to coins
07:29:18 <byorgey> and eventually it gets down to base cases (where d <= 0 || x < 0, or x == 0)
07:29:23 <Lord_Illidan> mm_freak_, what do you mean?
07:29:28 <byorgey> and then it adds up all those ones and zeros
07:29:43 <byorgey> n00b: does that make sense?
07:29:44 <mm_freak_> Lord_Illidan: you calculate abundantNumber 1, abundantNumber 2, abundantNumber 3, etc.
07:30:05 <mm_freak_> nothing there to memoize
07:30:48 <mm_freak_> Lord_Illidan: i wrote that divisors function in terms of a factors function
07:30:52 <n00b> nope
07:30:52 <mm_freak_> and a subsets function
07:30:59 <n00b> not fully
07:31:11 <Lord_Illidan> I have this line of code : testAbundantSum x (takeWhile (<x) abundantNumbers) I am thinking that the bottleneck is due to abundantNumbers in all it's entirety being generated each time
07:31:20 <Lord_Illidan> Or am I wrong, and it's only generated once?
07:31:34 <n00b> can u annotate my code, cause reading piece by piece with the screen moving make things hard
07:31:40 <n00b> if can't it's ok
07:32:04 <mm_freak_> Lord_Illidan: yes, nothing is memoized there
07:32:50 <mm_freak_> Lord_Illidan: you can force memoization by passing the list of abundant numbers as an argument to testAbundantSum
07:33:20 <dolio> No. abundantNumbers is computed once.
07:33:25 <Lord_Illidan> mm_freak_, I am passing it as an argument
07:33:26 <mm_freak_> although i'm not sure whether that would work
07:33:48 <mm_freak_> oh, stop…  i've overlooked something
07:33:55 <mm_freak_> dolio is right
07:34:04 <byorgey> n00b: http://hpaste.org/10890#a1
07:34:06 <Lord_Illidan> mm_freak_, testAbundantSum is taking an Int and [Int], x and takeWhile (<x) abundantNumbers
07:34:12 <n00b> thanks
07:34:18 <Lord_Illidan> so where's the massive slowdown then?
07:35:38 <Lord_Illidan> I tried to speed it up somewhat by using takeWhile
07:38:57 <dolio> Well, you're doing testAbundantSum 28,000 times...
07:39:17 <dolio> As well as (takeWhile (<x) abundantNumbers) 28,000 times.
07:39:39 <Lord_Illidan> hmm
07:39:44 <dolio> Each call to testAbundantSum calls abundantNumber several times.
07:39:53 <Lord_Illidan> I know, trying to speed it up
07:40:21 <vixey> Lord_Illidan: What's with the type annotations?
07:40:32 <Lord_Illidan> vixey, what type annotations?
07:40:45 <vixey> Lord_Illidan: ... in yoru code
07:41:32 <Lord_Illidan> vixey, what's wrong with them?
07:41:50 <vixey> Lord_Illidan: I think it's odd you annotated everything except one definition in your code
07:41:52 <ozy`> it was on the news this mroing, a mother in ar had killed her three kids...
07:42:22 <Lord_Illidan> I didn't think it necessary to annotate abundantNumbers
07:42:36 <ozy`> s/^(.*)$/"\1"/
07:42:58 <Lord_Illidan> it's evident that it's an [Int]
07:43:10 <vixey> Lord_Illidan: yeah so why did you annotate anything else?
07:43:26 <vixey> Lord_Illidan: All I understand, and Nothing I understand.. but . in between?
07:43:31 <Lord_Illidan> hmm, at uni we got drilled into defining these annotations
07:43:59 <Lord_Illidan> But I was lazy and left one out
07:44:10 * vixey is so lazy she leaves them _all_ out
07:44:18 <Lord_Illidan> heh
07:44:26 <vixey> (actually it's not lazyness)
07:44:48 <Lord_Illidan> Could dynamic programming solve it?
07:45:04 <mm_freak_> with haskell you're lazy enough usually
07:45:20 <mm_freak_> haskell code is usually much shorter than code from other languages
07:45:30 <dolio> You might want to make an array of bools that tell you which numbers are abundant.
07:45:42 <Lord_Illidan> and sometimes, much harder to understand too
07:45:50 <mm_freak_> so don't be spare at the wrong end =)
07:46:04 <Lord_Illidan> dolio, you mean a 28000 array of bools?
07:46:13 <dolio> Right.
07:46:13 <mm_freak_> only if you want it…
07:46:20 <dolio> That's not really that big.
07:46:26 <Lord_Illidan> dolio, how would that be faster?
07:46:32 <Axman6> gahh, i need an efficient way to solve this :(
07:46:35 <Lord_Illidan> Or am I merely being unimaginative?
07:46:37 <mm_freak_> Lord_Illidan: btw, you can speed properDivisors up greatly by writing it in terms of the prime factors of a number
07:46:47 <dolio> Evidently I didn't do that, though.
07:48:05 <dolio> According to my code, I did pretty much exactly what your code does, and it worked fine.
07:48:53 <SamB_XP> dolio: what CPUs are each of you using ?
07:49:19 <Lord_Illidan> dolio, you're referring to my problem?
07:49:22 <dolio> Athlon 64 3000+
07:49:24 <mm_freak_> uhm…  something i need to remark:  although it works in this code, (truncate . sqrt . fromIntegral) is a dangerous function
07:49:26 <dolio> Yes.
07:49:30 <mm_freak_> it will give wrong results for larger numbers
07:50:23 <dolio> Takes 40 seconds here.
07:50:23 <Lord_Illidan> mm_freak_, Actually I got that by trial and error
07:50:40 <Beelsebob> @type isqrt
07:50:41 <lambdabot> Not in scope: `isqrt'
07:50:48 <Lord_Illidan> I couldn't write [1..sqrt x]
07:50:56 <Axman6> @hoogle sqrt
07:50:57 <lambdabot> Prelude sqrt :: Floating a => a -> a
07:51:00 <Axman6> lame
07:53:14 <Lord_Illidan> mm_freak_, I'm trying it for some large numbers
07:53:20 <Lord_Illidan> and it's working
07:53:38 <Lord_Illidan> >truncate . sqrt . fromIntegral $ 3434343423234232323
07:54:09 <Lord_Illidan> > truncate . sqrt . fromIntegral $ 3434343423234232323
07:54:10 <lambdabot>   1853198160
07:54:40 <Axman6> > 1853198160^2
07:54:41 <lambdabot>   3434343420227385600
07:54:49 <sclv> it won't work once you start overflowing the bounds of double.
07:55:04 <Lord_Illidan> Axman6, however I am converting the result to int, mind
07:55:12 <Lord_Illidan> to Integer, sry
07:55:32 <sclv> > fromIntegral 10^1000 :: Double
07:55:34 <lambdabot>   Infinity
07:55:43 <Axman6> > truncate . sqrt . fromIntegral $ (maxbound :: Int)
07:55:44 <lambdabot>   Not in scope: `maxbound'
07:55:49 <Axman6> > truncate . sqrt . fromIntegral $ (maxBound :: Int)
07:55:50 <lambdabot>   3037000499
07:55:57 <Lord_Illidan> Anyway, I was thinking more in terms of 28000 being the maximum I would go for this exercise :D
07:56:05 <Axman6> > (3037000499^2, macBound :: Int)
07:56:06 <lambdabot>   Not in scope: `macBound'
07:56:09 <Axman6> > (3037000499^2, maxBound :: Int)
07:56:11 <lambdabot>   (9223372030926249001,9223372036854775807)
07:56:40 <Lord_Illidan> dolio, I wonder..perhaps mine isn't working because I overstepped the int boundary?
07:56:48 <Lord_Illidan> Because it's been running for a good 5 mins now
07:58:04 <mm_freak_> dolio, Lord_Illidan:  my little tool functions may be of help:  http://hpaste.org/10892
07:58:14 <mm_freak_> see the 'divisors' function
07:58:14 <dolio> Why are you sorting the divisors?
07:58:34 <Olathe> > let iSqrt 0 = 0; iSqrt n = if x*x <= n then x else x - 1 where x = shiftL (iSqrt (shiftR n 2)) 1 + 1 in iSqrt (maxBound :: Int)
07:58:35 <lambdabot>   3037000499
07:59:05 <Lord_Illidan> good call, I did that for early presentation to myself, actually
07:59:08 <Lord_Illidan> might as well remove it
08:00:36 <dolio> Incidentally 'foo x | bar x = True | otherwise = False' is identical to 'foo x = bar x'
08:01:47 <Axman6> hopefully ghc would pick that up
08:01:51 <Twey> Which, incidentally, is identical to foo = bar
08:02:20 <dolio> Sure, but in reality, he has expressions, not a simple function call.
08:02:40 <dolio> Like 'abundantNumber x = (sum . properDivisors $ x) == x'
08:02:59 <dolio> Which isn't going to be nicer point free.
08:03:16 <mm_freak_> Olathe: in my experience, (*2) is faster than a shiftL
08:03:25 <Twey> Aye to that
08:03:25 <mm_freak_> and (`div` 2) is faster than a shiftR
08:03:33 <mm_freak_> at least with GHC 6.8
08:03:37 <Axman6> i remember when we were doing haskell last semester, a lot of people would do things like foo x | x < a && x > b = True | otherwise False. they were all pretty happy when i informed them how much extra typing they were doing
08:03:51 <dolio> :)
08:03:59 <Twey> Axman6: You teach?
08:04:10 <Axman6> heh, nah, i was learning at the same time :P
08:04:13 <Twey> Oh, heh
08:04:41 <Axman6> everyone was like "oh Axman, you're so awesome and sexy, how did you get soo good at haskell? like omg"
08:04:44 <Axman6> >_>
08:04:47 <Lord_Illidan> :P
08:04:52 * Twey grins.
08:05:47 <Olathe> (flip.flip id=<<)(sum.properDivisors)x(==)
08:06:02 <Peaker> teaching ML in universities around here is like super-progressive. Even Scheme is losing favor
08:06:17 <Peaker> I don't think many professors here know Haskell at all
08:06:29 <Axman6> aussie unis seem to like haskell
08:06:33 <vixey> next they will teach everyone java and python
08:06:38 <Axman6> especially UNSW
08:06:47 <Axman6> vixey: yeah... we're doing java
08:06:52 <Twey> Ow
08:06:54 <Twey> What?
08:06:57 <Lord_Illidan> We use java
08:07:01 <Lord_Illidan> and did some prolog
08:07:08 <Lord_Illidan> and haskell too
08:07:13 <Twey> You did Haskell, and now you're doing Java?
08:07:18 <Lord_Illidan> I believe we'll be covering c#
08:07:19 <Axman6> yeah :\
08:07:20 <SamB_XP> the good, the bad, and the ugly ?
08:07:23 <Lord_Illidan> lol
08:07:23 <Twey> 'This is what you can do...'
08:07:27 <SamB_XP> which is bad and which is ugly ?
08:07:34 <Twey> 'BUT WE'RE GOING TO FORCE YOU TO DO THIS INSTEAD!  AHAHAHAHA!'
08:07:41 <Axman6> the uni sees java as more practical
08:07:41 <Lord_Illidan> Nah, we have an OOP course in Java, and a declerative course in prolog & haskell
08:08:11 <Cthulhon> Java is much maligned, but the core language isn't really that bad. :\
08:08:23 <Cthulhon> It's the ;ibraries that will kill you.
08:08:26 <vixey> Java is a fine language actually
08:08:28 <Cthulhon> *libraries
08:08:29 <Lord_Illidan> I still understand java more than haskell :D
08:08:40 <vixey> It's just sort of boring because there's so many languages similar
08:08:52 <SamB_XP> but it's so VERBOSE
08:08:55 <dblazakis> @unpl either (const False) (const True)
08:08:55 <lambdabot> either (\ _ -> False) (\ _ -> True)
08:09:03 <vixey> It's not very verbose
08:09:03 <Cthulhon> Spring drove me crazy trying to work out the 'autowiring' mess.
08:09:03 <Lord_Illidan> to take from mm_freak's provided code
08:09:05 <SamB_XP> does Java have operator overloading yet ?
08:09:06 <Lord_Illidan> isPrime n = and $ map (\x -> n `rem` x /= 0) $ takeWhile (\x -> x*x <= n) primes
08:09:13 <Lord_Illidan> I can't understand that line
08:09:14 <Twey> I was talking to somebody yesterday who wrote a fifty-line homework assignment in Java
08:09:25 <Twey> We laughed when I pointed out that it was three lines in Haskell
08:09:25 <SamB_XP> Twey: was it Hello World?
08:09:29 <Lord_Illidan> without writing it down on some paper and dry running it
08:09:30 <Twey> SamB_XP: Close :-P
08:09:34 <Cthulhon> And Tomcat exceptions are like whole books.
08:09:38 <vixey> You can do some very elegant programs in Java with a bit of reflection
08:09:52 <Olathe> Can gcc produce .class files ?
08:10:01 <Cthulhon> gcj can.
08:10:03 <Axman6> Olathe: it can compile java, so i assume so
08:10:04 <Lord_Illidan> You can make inelegant programs in haskell too
08:10:09 * Lord_Illidan points to his own code
08:10:16 <Olathe> I wonder if you could compile Haskell to .class, then decompile to Java.
08:10:16 <vixey> embedding declarative languages taking into account class hierarchy and such
08:10:17 <SamB_XP> vixey: classic reflection (i.e. thinking) or the dynamic sort (ala Python)
08:10:17 <Twey> Heh
08:10:19 <Lord_Illidan> Does that mean that haskell is bad?
08:10:26 <dblazakis> can you bind to a pattern match in a list comprehension? that would be cool sugar
08:10:29 <vixey> the Java library called reflection
08:10:36 <vixey> dblazakis: try it!
08:10:40 <Cthulhon> Decompiling Java is hairy.
08:10:51 <shrughes> Lord_Illidan: yes, it is bad, but Haskell \ {p | p is inelegant} is good.
08:10:56 <Twey> vixey: And yet it's still far more hideous than the equivalent Python
08:11:06 <dolio> > let justs l = [ x | Just x <- l] in justs [Just 5, Just 6, Nothing, Just 7]
08:11:07 <lambdabot>   [5,6,7]
08:11:10 <SamB_XP> Olathe: you could not understand the result any better than you can understand Core
08:11:12 <vixey> oh s it?
08:11:15 <Axman6> Lord_Illidan: what don't you understand about that isPrime func?
08:11:16 <vixey> I wouldn't know
08:11:24 <Cthulhon> I've done my share of bytecode (reverse) engineering, and it doesn't always translate to Java just because some of it can be decompiled.
08:11:26 <Lord_Illidan> The syntax, Axman6 the syntax
08:11:35 <Axman6> what's wrong with it?
08:11:36 <Lord_Illidan> looking at it gives me a headache
08:11:38 <Olathe> SamB_XP: That would be OK :)
08:11:40 <Axman6> heh
08:11:42 <Cthulhon> As .class file obfuscators love to take advantage of...
08:11:44 <dblazakis> that's awesome
08:11:50 <ronwalf> My biggest problem with Haskell is having to read a research paper before I use some of the libraries :)
08:12:03 <Lord_Illidan> I can understand it, but just looking at it makes my head hurt :S
08:12:08 <Axman6> ronwalf: heh
08:12:10 <SamB_XP> ronwalf: heh
08:12:12 <Cthulhon> The Java bytecode has GOTO opcodes, for example.
08:12:18 <SamB_XP> I love it when I can do that
08:12:25 <dblazakis> Cthulhon: they are restricted tho
08:12:31 <Axman6> Lord_Illidan: break it into steps them. "first it... then it... then it..."
08:12:32 <dblazakis> for implementing exceptions
08:12:46 <Cthulhon> You can't use the goto from within Java, sure.
08:12:52 <Lord_Illidan> What's `rem`?
08:12:55 <Lord_Illidan> Same as `mod`?
08:12:55 <Axman6> Cthulhon: oh no, not GOTOs, think of the raptors!
08:13:02 <shrughes> "first it... returns a thunk.  the end."
08:13:04 <Olathe> Lord_Illidan: It's like mod.
08:13:06 <Lord_Illidan> I didn't do it :D
08:13:06 <Twey> Lord_Illidan: Types
08:13:08 <SamB_XP> damn netsplits
08:13:12 <Twey> :t rem
08:13:14 <lambdabot> forall a. (Integral a) => a -> a -> a
08:13:15 <Twey> :t mod
08:13:16 <lambdabot> forall a. (Integral a) => a -> a -> a
08:13:18 <Olathe> Lord_Illidan: Pretty much identical, except for negative inputs.
08:13:19 <Twey> Oh
08:13:21 <Lord_Illidan> Same types
08:13:21 <Twey> Not types.
08:13:23 <Twey> My error.
08:13:26 <Axman6> Lord_Illidan: the difference is in how they handle negative numbers
08:13:29 <Lord_Illidan> ah
08:13:31 <SamB_XP> I wish x-chat 2.0 had supported those like irssi does
08:13:32 <ozy`> > rem -3 2
08:13:33 <lambdabot>       No instance for (Num (a -> a -> a))
08:13:33 <lambdabot>        arising from a use of `-' at...
08:13:35 <Cthulhon> If you ever reverse an obfuscated class file, you'll see that GOTOs can be used liberally.
08:13:44 <ozy`> > mod -3 2
08:13:44 <Twey> > 6.4 `mod` 1
08:13:45 <lambdabot>       No instance for (Num (a -> a -> a))
08:13:46 <lambdabot>        arising from a use of `-' at...
08:13:46 <lambdabot>   Add a type signature
08:13:50 <ronwalf> The beauty of haskell: A five line program -> four papers, and a PhD thesis.
08:13:52 <ozy`> whoops
08:13:52 <Twey> :(
08:13:57 <Lord_Illidan> lol
08:13:57 <Axman6> ozy`: (-3)
08:13:59 <SamB_XP> why doesn't Java allow goto ?
08:14:02 <olsner> > catMaybes [Just 3, Nothing, Just 42]
08:14:02 <ozy`> Axman6: D'OH
08:14:03 <lambdabot>   [3,42]
08:14:13 <ozy`> SamB_XP: because goto is not object-oriented
08:14:16 <dblazakis> Cthulhon: I thought they were restricted to a function or something like that -- not that that means you can't make a function completely unreadable
08:14:20 <dolio> SamB_XP: It's Evil.
08:14:33 <Twey> How do we check if a Float is whole in Haskell, then?
08:14:38 <dolio> SamB_XP: And break/continue are All You Ever Need.
08:14:38 <SamB_XP> dolio: yes, Java is, isn't it?
08:14:43 <Lord_Illidan> Didn't Ballmer sh** in a box and call the result C#?
08:14:52 <sclv> isPrime n = and . map ((/=0) . rem n) . takeWhile ((<=n) . (^2)) $ primes -- this syntax is maybe clearer?
08:14:55 <SamB_XP> Lord_Illidan: no, that was just a rumour
08:14:55 <Twey> round foo == fromIntegral foo?
08:14:57 <Cthulhon> $Yeah, it's restricted to funnction scope, but you can still do all sorts of nasty tricks with that.
08:14:59 <Lord_Illidan> lol
08:15:17 <dolio> Although Java even has labelled breaks.
08:15:20 <SamB_XP> Lord_Illidan: they couldn't figure out how to turn his shit into a programming language, so they actually designed one instead
08:15:44 <dolio> So you might be able to do arbitrary gotos, I can't recall.
08:15:45 <sclv> a float is never whole, conceptually.
08:15:51 <Cthulhon> More to the point, I don't thik translating Haskell into bytecode with proper Java semantics is doable.
08:15:56 <Axman6> sclv: that in my book is a lot less clear
08:16:02 <shrughes> Twey: ceiling foo == floor foo
08:16:02 <Cthulhon> *think
08:16:04 <dolio> goto label; = while (true) { break label; }
08:16:05 <dolio> :)
08:16:07 <ozy`> Lord_Illidan: it's true that, presumably for marketing reasons, C# is largely a reimplementation of Java on many levels (and Java is shit) but it does have some actual design going on... OR SO I HEARD
08:16:09 <vixey> Cthulhon: I don't know what thath means
08:16:12 <Axman6> i think too many haskell users are too addicted to (.)
08:16:24 <Twey> ozy`: It's true
08:16:28 <Twey> It has stuff
08:16:29 <shrughes> Twey: (== 0) . snd . properFraction $ foo
08:16:35 <SamB_XP> yes, they fixed a lot of nasty stuff didn't they?
08:16:41 <Twey> shrughes: Ah, nice
08:16:45 <sclv> if I do lots of math on floats and I come out with a whole looking number, I have no guarantee that's not just an accident of rounding.
08:16:48 <Twey> SamB_XP: They introduced some, too.
08:16:50 <SamB_XP> C# 3 borders on actually usable, I think
08:16:53 <Twey> But that's mostly in the libraries.
08:17:15 <Olathe> So, when is someone going to implement exact arithmetic ?
08:17:21 <Lord_Illidan> Lol..you're saying actually usable, and millions of programmers have already been using C# since day 1
08:17:23 <Axman6> woah, irssi didn't catch that one -_-
08:17:27 <Twey> They have things like transparent setters and getters, which eliminate getFoo, setFoo, getBar, setBar, getBaz, setBaz...
08:17:37 <SamB_XP> sclv: you never can, unless you work with only the rationals
08:17:39 <Twey> Axman6: Aye x.x
08:17:46 <shrughes> they have (gasp) closures
08:17:49 <Gilly> i've been wondering if halting problem is decidable in some language which is not turing complete but still offers us a meaningful programming environment - in otherwords, how much do you think we'd have to let go in order to make it decidable?
08:17:52 <SamB_XP> sclv: comparison of reals for equality is undecidable
08:18:10 <sclv> SamB_XP: agreed.
08:18:13 <SamB_XP> well, semi-undecidable
08:18:19 <vixey> Cthulhon:what does it mean?
08:18:35 <shrughes> Gilly: you couldn't make an interpreter for a turing-complete language
08:18:36 <SamB_XP> if they aren't equal, you'll eventually detect THAT
08:18:37 <sclv> Olathe: I think we have it?
08:18:42 <sclv> CReal
08:18:47 <vixey> Gilly: almost certainly yes
08:19:03 <dolio> Oh, I guess labeled break can't jump to arbitrary locations. Just jump out of labeled loops.
08:19:05 <Cthulhon> vixey: Being able to compile to bytecode is not the same as being able to compile to bytecode that has a clear Java representation.  Doing the former is relatively easy.  Doing the latter is very hard.  Things like typeclasses are different enough from interfaces that you'd have to rig a system to sort it out.  Things like lazy evaluation would require liberal use of anonymous subclasses...
08:19:07 <vixey> Gilly: any strongly normalizing calculus has the trivial answer, yes everything halts
08:19:09 <Axman6> > pi :: CReal
08:19:10 <Gilly> also i'd want it to be practically decidable
08:19:10 <lambdabot>   3.1415926535897932384626433832795028841972
08:19:16 <Lord_Illidan> I have to go out for a bit
08:19:22 <Lord_Illidan> bye all
08:19:43 <Olathe> sclv: Yeah, but with that, you still have the issue of x == floor x being hard to decide sometimes.
08:19:46 <Axman6> > length . show $ pi :: CReal
08:19:47 <lambdabot>   Couldn't match expected type `CReal' against inferred type `Int'
08:19:56 <Axman6> > length . show $ (pi :: CReal)
08:19:58 <vixey> Cthulhon: oh right, I see what you mean -- that sounds like a really weird goal
08:19:58 <lambdabot>   42
08:20:07 <scodil> the answer
08:20:10 <Cthulhon> Well, blame Olathe .
08:20:15 <Olathe> > showCReal 100 pi
08:20:15 <Cthulhon> He brought it up.
08:20:16 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
08:20:40 <vixey> What about Q(π)
08:20:40 <vixey> ?
08:20:42 <Gilly> well - if we'd still like to see recursion then how far can we go?
08:21:03 <Axman6> as far as i'm concerned, that's mnore than enough accuracy. you only need π to 42 places to be able to draw a circle around our galaxy with an accuracy of ±1mm
08:21:18 <sclv> Olathe, hmm... good point.
08:21:24 <Axman6> @src CReal pi
08:21:24 <lambdabot> Source not found. That's something I cannot allow to happen.
08:21:51 <shrughes> why do you need pi for that?
08:21:59 <Peaker> @src pi
08:21:59 <lambdabot> Source not found.
08:22:09 <Axman6> how fast are operations on CReals anyway?
08:22:12 <sclv> shrughes: yeah, to be fair, what you really need is a really big compass.
08:22:19 <vixey> Is exact real arithmetic possible with decidable equality?
08:22:20 <scodil> yeah its easy to do without pie. just tie one end of a long string around the black hole at the center
08:22:25 <scodil> pi
08:22:26 <scodil> hah
08:22:27 <Axman6> shrughes: i'm saying a circle big enough
08:22:37 <vixey> like find some canonical (and finite) representation for every real?
08:22:53 <shrughes> Axman6: and how is pi connected to the accuracy of the circle?
08:23:11 <Axman6> i forget :P
08:23:30 <vixey> shrughes: It's just a phrase people memorized from blue peter or something like that
08:23:34 <Axman6> maybe it was the circumference of said circle
08:23:47 <SamB_XP> scodil: what the heck?
08:24:03 <sclv> The bigger the circle, the higher the accuracy/pi ratio I think, so its sort of silly.
08:24:05 <maltem> vixey: I wouldn't think that such a thing existed :)
08:24:06 <SamB_XP> you can't tie a string around a black hole, for two reasons
08:24:21 <SamB_XP> the first of which is far more important
08:24:25 <vixey> no canonical rep. for computable reals?
08:24:25 <sclv> if the circle was bigger, then it would be even less than 1mm
08:24:27 <SamB_XP> IT WOULD BE SUCKED IN
08:24:35 <vixey> any proofs that can't exist?
08:24:49 <sclv> SamB_XP: I worry less about that than that
08:24:52 <sclv> I WOULD BE SUCKED IN
08:24:55 <shrughes> SamB_XP: if it were orbiting fast enough no
08:24:57 <Axman6> :t showCReal
08:24:58 <lambdabot> Int -> CReal -> String
08:25:07 <SamB_XP> sclv: well, you could have been using tiny robots
08:25:07 <vixey> @quote orbit
08:25:07 <lambdabot> DRMacIver says: #haskell doesn't so much wander off topic as orbit it. :)
08:25:34 <Axman6> > last $ showCReal maxBound pi
08:25:35 <lambdabot>   * Exception: Negative exponent
08:25:41 <Axman6> > last.show $ showCReal maxBound pi
08:25:41 <SamB_XP> my second reason was going to be that you can't exactly tie a string around a marble, either
08:25:42 <lambdabot>   * Exception: Negative exponent
08:25:46 <Axman6> gah
08:25:51 <maltem> vixey: I think it's enough to say that it isn't possible to compare arbitrary infinite sequences in finite time?
08:25:59 <Axman6> > last.show $ showCReal (maxBound-1) pi
08:25:59 <scodil> SamB_XP: fine, give a monkey one end of the string and send him through the black hole with orders to tie it off to the first lamppost he finds in the fantastic alternate universe on the other side
08:26:00 <lambdabot>   * Exception: Negative exponent
08:26:02 <vixey> maltem: No I don't think so
08:26:05 <Axman6> :|
08:26:12 <Axman6> > last.show $ showCReal (maxBound :: Int) pi
08:26:13 <vixey> maltem: maybe some kind of tree representation could work
08:26:13 <lambdabot>   * Exception: Negative exponent
08:26:16 <tirpen> vixry: There is an uncountable infinite number of reals, and any binary representation is per default countable, henche it's impossible.
08:26:17 <SamB_XP> scodil: that only works if it's a stable wormhole
08:26:23 <Axman6> whatchoo talkin 'bout lambdabot
08:26:39 <Axman6> > maxBound :: Int
08:26:40 <lambdabot>   9223372036854775807
08:26:40 <sclv> hmm... you're right. I think that you've enumerated the only two reasons why we can't tie a string around a black hole. once you solve those two and only those two, bob's your uncle.
08:26:44 <scodil> SamB_XP: well Einstein and Disney disagree there
08:26:48 <vixey> tirpen: I'm only interested in computable reals, which are countable
08:26:55 <SamB_XP> scodil: hmm/
08:26:58 <tirpen> Ahh. Sorry.
08:27:11 <maltem> vixey: oh. then it's a different story, of course...
08:27:14 <scodil> and you can too tie a string around a marble. make a net.
08:27:16 <SamB_XP> scodil: wouldn't the string break if it was unstable ?
08:27:26 <SamB_XP> scodil: that's not one string anymore
08:27:31 <Axman6> > last $ showCReal (10000000000) pi
08:27:34 <sclv> it depends if its a bendy string
08:27:44 <scodil> bendy but not stretchy
08:27:47 <lambdabot>   thread killed
08:27:50 <scodil> a chain
08:27:52 <Axman6> > last $ showCReal (10000000) pi
08:28:08 <lambdabot>   thread killed
08:28:14 <Axman6> > last $ showCReal (100000) pi
08:28:16 <SamB_XP> anyway, since when do we care about disney's opinion regarding physics ?
08:28:30 <lambdabot>   thread killed
08:28:36 <Axman6> fail
08:30:54 <ozy`> hmm, how do I get the first N elements of a list?
08:31:00 <Cale> ozy`: take
08:31:05 <Cale> > take 12 [1..100]
08:31:09 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12]
08:31:20 <ozy`> ahhh
08:31:21 <ozy`> thanks
08:31:48 <eyu100> > last $ showCReal (10) pi
08:31:50 <lambdabot>   '6'
08:33:30 <Cale> > showCReal 100 pi
08:33:32 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
08:33:44 <Cale> > drop 900 (showCReal 1000 pi)
08:33:46 <lambdabot>   "03598253490428755468731159562863882353787593751957781857780532171226806613...
08:34:29 <ronwalf> heh - I get a 10 fold increase in executable size using -O3
08:34:42 <ronwalf> (2.4MB to 21MB)
08:35:11 <Axman6> i didn't think GHC took notice of anything higher than  -O2. anytyhing higher was treated as -O2
08:35:24 <ronwalf> could be
08:36:09 * ronwalf doesn't actually read the man pages
08:36:54 * ronwalf blames the extensible datatypes design he's using
08:37:10 <ronwalf> So I get slow-small or fast-large
08:37:44 <ronwalf> Can you mix -O's in the compilation?
08:38:04 <ronwalf> Do bad things happen if one .o is compiled with -O1 and another with -O2 ?
08:38:37 <Axman6> i doubt it
08:38:40 <Cale> ronwalf: I would be surprised if that was the case. You should be able to mix them.
08:38:50 <SamB_XP> depends what you mean by bad ;-P
08:39:09 <ronwalf> Yeah, -O2 produces the same results (21MB)
08:39:34 <Cale> That's interesting. I wonder what's happening to the core.
08:40:05 <Cale> Maybe there are lots of specialisations to particular types being generated?
08:40:21 <SamB_XP> but GHC doesn't have sUPERSPECIALIZE
08:41:49 <ronwalf> There are many types and classes
08:42:00 <ronwalf> (and ~2500 lines of code)
08:43:15 <SamB_XP> don't you just like it when you get near 10kB/loc ?
08:44:46 <Axman6> hmm, is there any way to rearrange n*(x+y) = xy so that you can solve for x (or y)
08:45:07 <dmwit> sure
08:45:19 <shrughes> n = 1/(1/x+1/y)
08:45:44 <Axman6> shrughes: need to find x or y
08:45:55 <dmwit> Axman6: Group all the x terms together.
08:46:12 <dmwit> You can do it, just give it a little thought. =)
08:46:48 <Axman6> i just need it do that x (or y) is only on one side of the equation
08:46:55 <Axman6> so*
08:47:05 <vixey> Axman6: What are you trying to do with it?
08:47:14 <dolio> xy - n*(x+y) = 0. Done!
08:47:17 <Axman6> http://projecteuler.net/index.php?section=problems&id=110 ;)
08:47:18 <lambdabot> Title: Problem 110 - Project Euler
08:47:42 <dmwit> Axman6: Try expanding n*(x+y).
08:47:48 <vixey> not going to tell me?
08:48:25 <Axman6> i'm hoping i can rearrange it so it's easier to see the solution :\
08:48:58 <Cale> Axman6: Use distributivity first, then put all the terms with, say, an x in them on one side, and factor out the x.
08:49:02 <Axman6> hmm, n = xy/(x+y) is something we used a lot in electronics
08:49:24 <vixey> Axman6: What are trying to do with the equation?
08:49:35 <Axman6> play with it...
08:49:45 * vixey sighs
08:50:02 <dmwit> vixey: He's trying to solve the Project Euler problem he linked to.
08:50:06 <dolio> He gave you a link that explains the whole problem.
08:50:09 <dmwit> right
08:50:19 <Axman6> vixey: i want it in the form of x = ... where ... has no x
08:50:34 <dmwit> Axman6: You can do it.
08:50:38 <Cale> That is, from n*(x+y) = nx + ny, so the equation becomes nx + ny - xy = 0. But then nx - xy = -ny, and x(n-y) = -ny. So x = -ny/(n-y), so long as n is not equal to y.
08:50:47 <dmwit> I'm hoping nobody here will do it for you, but if you keep asking, they might...
08:50:54 <dmwit> ah
08:50:57 <dmwit> there we go =P
08:50:58 <Cale> heh
08:51:06 <Cale> Does that make sense?
08:51:52 <Axman6> i'm just making sure i'm not being really retarded with my rearrangement
08:51:59 <Axman6> Cale: where's the n*(x+y) = nx + ny come from?
08:52:10 <Cale> Axman6: The distributive law.
08:52:24 <Axman6> oh right
08:52:44 <Axman6> heh, i get what you mean, i thought you'd rearranged the original equation to be like that
08:52:52 <Cale> Distributivity is one of the most fundamental properties of numbers. It's the essence of how addition and multiplication are related to one another.
08:53:34 <Axman6> yeah i know what you mean, i thought you'd truend x*y into n*x + n*y
08:53:54 <Cale> ah
08:53:59 <SamB_XP> heh
08:54:06 <SamB_XP> that would be nonsense ;-)
08:54:33 <gwern> so, I'm loading a list of favorite vocabulary words into typespeed, a little speed typing game. I discover that every time it loads my new list, it segfaults. I am perplexed, did I violate the formatting? as far as I can tell, no, but I begin binary bisecting the list to find the offending entry. but I find after a while it apprently is in the last half, but I can't figure out which word is 'bad'
08:54:40 <gwern> so, can you guess what the problem was?
08:54:48 * gwern supplies a hint: typespeed is written in C
08:54:48 <MyCatVerbs> Cale: but only if you define multiplication and addition in a way in which the law holds. :D
08:55:02 <ttt--> hi, i'd like to functions from Hint.Parsers in my module, but i keep getting the error that 'Hint.Parsers' is hidden. I tried "-p hint" and ghc-pkg expose hint (global and user).. None of this seems to help. Any ideas?
08:55:07 <vixey> is it \0 ??
08:55:08 <ttt--> like to use*
08:55:10 <Cale> MyCatVerbs: Well, yes. But we probably wouldn't call them that if it didn't. :)
08:55:13 <gwern> vixey: nope
08:55:23 <gwern> ttt--: are you building via cabal?
08:55:25 <SamB_XP> gwern: no idea!
08:55:33 <ttt--> yes, i installed hint with cabal
08:55:36 <gwern> SamB_XP: I'll tell you. I had more than 1024 words
08:55:40 <SamB_XP> hah
08:55:50 <vixey> wow
08:56:00 <maltem> ttt--: how do you compile/load/run your program?
08:56:03 <vixey> software!
08:56:06 <gwern> I eventually figured this out when I saw a segfault with 1025 words, and then I removed one and it worked, and no matter what I added to bring it up to 1025 words, it broke
08:56:12 * gwern hates C
08:56:18 <ttt--> maltem, i :load it in ghci
08:56:18 * vixey hates software
08:56:28 <MyCatVerbs> Cale: jah. I fully support the proposition that Leibniz will rise from his grave and eat the brains of anyone who defines operations and calls them (+) and (*) but doesn't make sure that distribution holds.
08:56:29 <ivanm> vixey: so why are you in this channel then?
08:56:37 <ivanm> why are you even using a computer, for that matter?
08:56:48 <gwern> ttt--: you know, hint doesn't expose that module
08:56:56 <ttt--> maltem, but ghc --make gives the same error
08:57:03 <gwern> you can see that in the cabal file, Parsers is in other-modules:
08:57:08 <gwern> it's not 'public'
08:57:16 <ttt--> gwern: yeah, but i thought you could circumvent that
08:57:19 <gwern> apparently hint's author thinks 'Don't use that then'
08:57:19 <ronwalf> Probably doesn't help the executable size that I have to use -fcontext-stack=40
08:57:39 <ronwalf> (these are some /big/ types!)
08:58:20 <gwern> > 1024 - 810
08:58:24 <MyCatVerbs> Cale: interestingly, I think that this means that Guido van Rossum is doomed. :)
08:58:24 <lambdabot>   214
08:59:10 <MyCatVerbs> Cale: because in Python, (("a" + "b") * 5) is well-defined, but gives a completely different answer to (("a"*5)+("b"*5)).
08:59:17 <Cale> ehehe
09:00:02 <vixey> programming languages should be implementations of field theory textbooks!
09:00:08 <ozy`> MyCatVerbs: ... strings aren't numbers
09:00:23 <maltem> ttt--: hm I would have hoped one could :(
09:00:35 <Peaker> Guido van Rossum has a beard, he can't be doomed
09:00:42 <vixey> ozy`: not even strings of digits?
09:00:51 <ozy`> (ruby does the same thing with strings)
09:00:57 <ozy`> vixey: well, in perl, sure
09:01:30 <ozy`> and also if that's how you're storing a rational number type of some kind
09:01:39 <ozy`> (or whatever)
09:01:52 <ozy`> but then the semantics are different anyway so what does it matter
09:03:24 <SamB> hmm
09:03:30 <MyCatVerbs> ozy`: yeah, and "a" * 5 is defined, and "b" * 5 is defined, but "a" * "b" is not. Iss crazeh. He's created an operator which uses the same symbol as the standard one for multiplication but which does not even form a monoid! *Le gasp!*
09:03:40 <SamB> so "IT Person" is a slightly better typorank than "Monkey", eh?
09:03:54 <SamB> I didn't know monkeys could even type
09:03:55 <MyCatVerbs> SamB: not... necessarily.
09:04:53 <MyCatVerbs> SamB: the difficulty is that while there are skilled, clever, hard-working and generally praiseworthy people with such titles, there are also a lot of basically shysters. TDWTF being more or less a catalogue, for example.
09:04:58 <SamB> hmm, apparantly typespeed recently changed rules or something ?
09:05:31 <SamB> MyCatVerbs: well, I don't think the quality of their code has much to do with their typorank
09:05:34 <Peaker> typespeed has such horrible code.. I once looked inside
09:05:42 <SamB> the typorank could be much more constant
09:06:48 <MyCatVerbs> SamB: hang on, define typorank, please?
09:07:11 <MyCatVerbs> Ah right, I see. Well...
09:07:28 <sclv> shysters is harsh. there are lots of perfectly nice ppl out there who are well intentioned and just.. fail.
09:07:31 <SamB> the text that typespeed associates with a given range of typo rates
09:08:16 <SamB> apparantly I don't type very well under pressure ?
09:08:29 <Peaker> typespeed almost gave me a heart attack once
09:08:37 <SamB> the code or the game ?
09:08:50 <Peaker> I don't get all fussy about horrible code :)
09:09:05 <SamB> well, you had just mentioned how bad it was ;-)
09:09:11 <SamB> so I wasn't sure
09:09:26 <Peaker> stressful game, almost as stressful as SC, but condensed into a couple of minutes :)
09:09:38 <SamB> StarCraft?
09:09:52 <Peaker> yeah
09:09:57 <jeffwheeler> Which game?
09:10:01 * SamB hasn't ever played
09:10:10 <SamB> jeffwheeler: typespeed
09:10:10 <Peaker> SamB: you're missing out, Starcraft is awesoem
09:13:35 <SamB> hmm, but I'd have to pay $20 to get it in physical form
09:14:08 <Peaker> SamB: if you adhere to copyright laws, possibly
09:14:30 <SamB> well, I mean, they sell it for 15 if you download it
09:14:38 <Peaker> where I am, private individuals don't generally adhere to them when doing non-profit stuff
09:16:44 <SamB> hehehe
09:17:12 <SamB> but I'm not going to find it on home of the underdog, obviously
09:18:22 <SamB> what the HECK
09:18:28 <SamB> some company has a trademark on Warez ???
09:19:33 <Peaker> heh
09:19:38 <Peaker> I think isohunt has Starcraft
09:22:31 <SamB> man, I don't have space for this :-(
09:28:20 <Peaker> SamB: hard disks are cheap
09:30:32 <MyCatVerbs> sclv: you're right, shysters *is* harsh.
09:31:10 <MyCatVerbs> sclv: but IMO, for anyone who blusters and bluffs their way into making nontechnical people think they're competent, it's totally appropriate.
09:31:44 <vixey> @seen shapr
09:31:44 <lambdabot> shapr is in #haskell, #scannedinavian, #haskell-blah and #haskell-soc. I last heard shapr speak 1h 48m 53s ago.
09:31:50 <MyCatVerbs> sclv: I have no real issue with people honestly screwing up, but I do think maybe they ought to try another (possibly even related, I dunno) career path.
09:32:12 <vixey> hi edwardk!
09:32:15 * edwardk waves hello.
09:32:20 <edwardk> heya vixey, long time no see
09:33:21 <MyCatVerbs> sclv: Hell, manglement? :)
09:33:58 <edwardk> gah, now i'm starting to wish there was an xmonad for windows ;)
09:34:09 <MyCatVerbs> sclv: I have no problem with the idea of working under someone who, if maybe not fantastically technical, is at least of a practical and down-to-earth disposition and can at least *empathize* with geeks like me. :)
09:36:40 <ttt--> woo, it got to compile
09:37:47 <ttt--> hooray for ghc-pkg expose
09:42:22 <ccdd> How do I print the help for any given statement?  Like "&&" or ":set"?
09:42:33 <newsham> ?src (&&)
09:42:33 <lambdabot> True  && x = x
09:42:33 <lambdabot> False && _ = False
09:43:31 <ccdd> newsham: sorry, question wasn't specific enough; how would I do it in ghci/hugs?
09:43:44 <newsham> go to http://haskell.org/hoogle/  type in &&, click on link,
09:43:45 <lambdabot> Title: Hoogle
09:43:56 <idnar> :set is a ghci interactive command
09:44:19 <idnar> I don't think Hoogle has those
09:44:19 <newsham> Prelude> :info (&&)
09:44:19 <newsham> (&&) :: Bool -> Bool -> Bool    -- Defined in GHC.Base
09:44:19 <newsham> infixr 3 &&
09:44:55 <newsham> :help will list some info about :set
09:45:04 <newsham> but the ultimate reference is the online docs
09:45:14 <ccdd> newsham: yeah, i'm looking at hoogle now
09:45:29 <newsham> http://haskell.org/haskellwiki/GHC
09:45:30 <lambdabot> Title: GHC - HaskellWiki
09:45:35 <ccdd> newsham: hoogle being a search for the online docs, right?
09:45:57 <newsham> yah, its a special kind of search tailored for finding functions in the library
09:46:13 <newsham> ?hoogle [a] -> a -> Maybe Int
09:46:13 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
09:46:13 <lambdabot> Data.ByteString findSubstring :: ByteString -> ByteString -> Maybe Int
09:46:13 <lambdabot> Data.ByteString.Char8 findSubstring :: ByteString -> ByteString -> Maybe Int
09:46:43 <ccdd> thanks, I only needed this because it isn't mentioned straight away in Real World Haskell, and it's kinda helpful
09:47:44 <newsham> http://book.realworldhaskell.org/read/why-functional-programming-why-haskell.html#whyfp.resources.reference
09:47:52 <lambdabot> Title: Why functional programming? Why Haskell?, http://tinyurl.com/6lmwfu
09:48:27 <the_unmaker> who here has a working haskell website
09:48:32 <the_unmaker> running on haskell
09:48:42 <newsham> i use HWS as my web server.  www.thenewsh.com
09:49:14 <newsham> http://www.thenewsh.com/~hws/
09:49:17 <lambdabot> Title: HWS - Haskell Web Server
09:49:30 <the_unmaker> oow
09:50:25 <the_unmaker> is it prefork style?
09:50:38 <the_unmaker> how does it multitask?
09:50:59 <newsham> it uses forkIO to fork one thread per connection
09:51:10 <newsham> so its single process, but multithreaded
09:51:41 <Peaker> what are the main differences between DataConstructor a b c   and DataConstructor (a,b,c) ?
09:52:16 <newsham> peaker: one has three arguments the other has a single argument that is a tuple type
09:52:40 <Peaker> I am wondering because the form DataConstructor a b c   does not lend itself to automatic extraction of its elements without a special pattern-matching function - so in a pickler combinator, I must write extractors manually :(
09:53:25 <Axman6> Peaker: the second can save you some typing (foo (DataConstructor a) = f a, instead of foo (DataConstructor a b c) = f (a,b,c)
09:53:25 <newsham> DataConstructor { getA :: a, getB :: b, getC :: c }
09:53:29 <Peaker> Could be nice if there was an automatic extraction function for every type that was auto-generated, that returned a tuple of all of its contained values?
09:54:01 <newsham> if you give the fields names, you get automatic extractors
09:54:10 <vixey> Peaker: I think you can write that
09:54:21 <Peaker> Axman6: Yeah, I am toying around with the idea of a pickler combinator, and realizing that I have no easy way to extract the data out of data-types generically
09:54:23 <Axman6> newsham: how's that work?
09:54:30 <Peaker> vixey: how?
09:54:35 <newsham> axman: [06:50] < newsham> DataConstructor { getA :: a, getB :: b, getC :: c }
09:54:38 <vixey> Peaker: using template haskell
09:54:44 <newsham> record names are extraction functions
09:54:54 <Axman6> yeah, i saw that. how would you extract the data?
09:54:55 <Peaker> vixey: all roads seem to be leading to template Haskell :)
09:54:59 <newsham> getA (DataConstructor 1 "two" 3) == 1
09:55:05 <Axman6> just gatA x = a?
09:55:07 <Peaker> newsham: yeah, but for just one specific field
09:55:11 <vixey> well I don't think you can do generic programming over data type definitions
09:55:13 <vixey> in haskell
09:55:13 <Axman6> nice
09:55:16 <Axman6> i like that :)
09:55:19 <Axman6> thanks newsham
09:55:22 <lightstep> Peaker, what about deriving Data?
09:55:28 <Peaker> newsham: In my case, maybe it would be nicer to use: DataConstructor { unDataConstructor :: (a, b, c) }
09:55:45 <Peaker> lightstep: what's the Data class?
09:55:53 <newsham> peaker: if what you really want to get access to is a tuple, yah.
09:56:04 <lightstep> it's a friend of Typeable, which gives you acess to the tags and fields and so on
09:56:06 <Peaker> newsham: I want "all" of the data for serialization purposes
09:56:27 <vixey> Peaker: You basically want something like read & show?
09:56:27 <newsham> peaker: what kind of serialization?  Data.Derive can automatically generate serialization for you
09:56:48 <Peaker> vixey: yeah, but with a combinator that you can use to describe the codec once, instead of both encode and decode functions
09:57:05 <vixey> that doesn't make sense though
09:57:21 <lightstep> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics-Basics.html
09:57:23 <lambdabot> Title: Data.Generics.Basics, http://tinyurl.com/y6cr6c
09:57:28 <Peaker> newsham: Binary serialization - I want to write a pickler combinator for the cases you'd use Data.Binary
09:57:50 <newsham> you can automatically derive Data.Binary instances for your data types using Data.Derive
09:57:51 <Peaker> vixey: Why? I want to avoid repeating the data structure in both encode and decode functions as I have to in Data.Binary
09:58:26 <Peaker> newsham: well, I can't specify a specific binary format that way, though?
09:58:43 <newsham> no, you'd be stuck w/ the format the macro package uses
09:58:59 <newsham> although you could write your own TH code to do the derivation in a custom way, if you were comfortable with TH
09:59:01 <the_unmaker> newsham: multithreaded or prefork
09:59:20 <newsham> [06:47] < newsham> it uses forkIO to fork one thread per connection
09:59:20 <newsham> [06:47] < newsham> so its single process, but multithreaded
09:59:30 <the_unmaker> er
09:59:32 <Peaker> newsham: I dislike the idea of manipulating grammar for these purposes..
09:59:33 <the_unmaker> hm
09:59:43 <the_unmaker> forks a thread but not a process? wow
09:59:49 <the_unmaker> so its low on memeory?
09:59:50 <SamB> Peaker: what do you want to do ?
09:59:56 <dblazakis> Peaker: how does that relate to things like PADS?
09:59:56 <the_unmaker> lean?
10:00:00 <Peaker> dblazakis: what's PADS?
10:00:08 <newsham> i dont know what the memory performance is.  haskell apps tend to not be too lean on memory
10:00:14 <newsham> but i've never measured it really
10:00:26 <Peaker> SamB: A pickler combinator that lets you specify specific binary formats and if you want, derive it automatically for your types
10:00:29 <dblazakis> http://research.att.com/~yitzhak/publications/padsml-popl07.pdf
10:00:31 <lambdabot> Title: PADS/ML: A Functional Data Description Language
10:00:43 <dblazakis> http://www.padsproj.org/
10:00:46 <lambdabot> Title: PADS: A System For Processing Ad Hoc Data
10:00:54 <rwbarton> the_unmaker: it's not even a new OS thread, it's a thread managed by the Haskell RTS
10:01:01 <newsham> peaker: you're manipulating your data types already -- making tuples where they wouldnt naturally be
10:01:07 <dblazakis> its a DSL tho
10:01:13 <dblazakis> not embedded, as far as i understand
10:01:47 <Peaker> newsham: yeah - I don't like that, I wish Haskell could automatically give me a tuple of all the data values in a data-type without using Typeable and friends
10:02:12 <newsham> you could use TH to automatically derive a method to do that for your data types
10:02:25 <newsham> i dont see how thats much different than using TH to auto-generate binary instances
10:02:31 <vixey> Peaker: Use TH to write deriving Sexp
10:02:48 <vixey> then you can introspect them and do all that
10:02:59 <the_unmaker> sounds good rwb
10:03:03 <lightstep> vixey, ghc already has such a function (i don't remember how it's called)
10:03:23 <shapr> vixey: you called?
10:03:42 <Peaker> vixey: I don't know TH :(
10:03:57 <vixey> shapr, oh.. just pushing buttons because I was bored :|
10:04:02 <shapr> oh ok
10:04:06 <Peaker> newsham: Binary is not nice for specifying protocols, like a pickler combinator would be
10:04:29 * araujo greets around and jump on a lambda puff
10:04:35 <newsham> i know.  thats partly because the way you would specify a getter and a putter are different.
10:04:51 <newsham> ie. you often want to make use of knowledge of items you've previously gotten
10:05:03 <vixey> shapr, I don't have my computer & reading papers is too hard (none of them make sense :p)
10:05:17 <Peaker> newsham: why wouldn't a pickler combinator do that?
10:05:26 <shapr> vixey: You need a Nokia N800! Then you can read papers on a pocket computer!
10:05:42 <SamB> vixey: try sleep
10:05:52 <vixey> I don't know.. I'm still weary of phones
10:05:53 <newsham> peaker: *shrug*
10:06:15 <the_unmaker> what is the haskell RTS? some thread thing for haskell?
10:06:19 <newsham> peaker: last time i tried i hit a mental roadblock
10:06:23 <newsham> but i think i just unblocked it.
10:06:31 <SamB> the_unmaker: there's no Haskell RTS
10:06:36 <SamB> there is a GHC RTS though
10:06:54 <rwbarton> Well, yeah.  Run-time system
10:07:01 <SamB> roughly comparable to libgcc
10:07:48 <the_unmaker> so the hws could handle a lot of users eh, because threads are lightweight
10:08:08 <the_unmaker> is there a decent plugin to postgresql?
10:08:17 <the_unmaker> anything that might do connection pool?
10:08:40 <sclv> do your own connection pooling -- seasy
10:08:45 <vixey> > 666^666
10:08:47 <lambdabot>   271541759288712855826087455170021786027838521065016987178223004696578367534...
10:08:52 <the_unmaker> oh ? k00l
10:10:59 <sclv> a chan is probably the nicest way -- from Control.Concurrent.
10:11:11 <sclv> Open up a hundred connections, stick them on a chan.
10:11:16 <sclv> pass it to all yr threads.
10:11:30 <sclv> each thread can take a connection from the chan and stick it back when its done.
10:12:08 <newsham> peaker: you want to combine pairs of get and put functions, right?
10:12:27 <newsham> but the get function is somethng like  (Get a) and the put function is something like (a -> Put)
10:12:47 <Peaker> newsham: yeah
10:13:07 <newsham> so how do you reconcile the two shapes when you're trying to glue together two tuples?
10:19:36 <Peaker> newsham: glue together two tuples?  I glue together picklers, not tuples?
10:19:51 <newsham> [07:08] < newsham> peaker: you want to combine pairs of get and put functions, right?
10:20:06 <newsham> so you have two pairs of functions.
10:20:10 <newsham> how are they glued together?
10:20:36 <Peaker> newsham: oh, that is a possible implementation of a pickler, yeah.  They can be extracted, composed, and re-inserted into a tuple
10:20:55 <Peaker> newsham: or at least, I don't see why not
10:21:04 <newsham> right, but the getters want to combine like:  do { x <- get; y <- get; return (f x y) }
10:21:20 <newsham> and the putters want to combine like:  \x y -> do { put x; put y }
10:21:36 <vixey> I can't imagine that working newsham
10:22:34 <newsham> if you start with:  (get1, \x -> put1 x) and (get2, \x -> put2 x)
10:23:02 <Peaker> newsham: combine (getter1, putter1) (getter2, putter2) = (getter, putter) where getter = do { x<-getter1 ; y<-getter2 ; return (f x y) } ; putter = ... ?
10:23:03 <newsham> how do you mix them to get something like (liftM (,) get1 get2, \x y -> put1 >> put2) ?
10:24:07 <newsham> er.. \(x,y) -> put1 x >> put2 y
10:24:17 <vixey> Peaker: I don't think that is going to work
10:24:41 <newsham> also now how do you write a combinator that needs to make a choice based on the value you recently got?
10:24:48 <newsham> (ie something like (>>=))
10:25:14 <newsham> i'm not sure its impossible to do, its just not immediately obvious to me
10:25:25 <Peaker> newsham: research.microsoft.com/~akenn/fun/picklercombinators.pdf
10:27:09 <Peaker> newsham: alt does the choice thing
10:27:09 <Cale> Is anyone here familiar with the theory of matroids?
10:28:31 <SamB> Cale: well, they suck some mysterious energy out of other life forms
10:28:40 <Xenoblitz> guys has anyone ever tried Hugs with the Haskell Graphics Library? I think have a memory problem with them :S
10:28:40 <Cale> SamB: ahaha
10:29:11 <sclv> pickler combinators are no longer a monad -- the paper explains. they're monadlike though.
10:29:13 <Cale> Xenoblitz: I'd generally try to stick to GHC these days.
10:29:13 <newsham> peaker: alt looks like discriminated union?
10:29:29 <Peaker> newsham: I don't know what that is
10:29:30 <newsham> thats only a special case of what i was discussing.
10:29:32 <Xenoblitz> Cale: plz tell me there is something similar to HGL for GHC
10:29:56 <newsham> peaker: how do you marshall an integer that specifies a length of the data to follow?
10:30:15 <Saizan> Xenoblitz: you can compile HGL with ghc too
10:30:18 <sclv> its all in the paper
10:30:43 <Xenoblitz> Saizan: any pointers on how? webpage or something?
10:30:47 <sclv> getting a nicer syntax seems possible though with some syb tricks
10:31:05 <rwbarton> @seen lispy
10:31:06 <lambdabot> lispy is in #haskell, #darcs and #haskell-blah. I don't know when lispy last spoke.
10:31:07 <Saizan> Xenoblitz: ever installed a cabal package?
10:31:13 <Peaker> newsham: I think this does that: list = sequ length nat . fixedList
10:31:15 <Saizan> ?hackage HGL
10:31:15 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HGL
10:31:20 <Cale> Xenoblitz: yes
10:31:27 <Xenoblitz> Saizan ... oops no cause i using windows
10:31:45 <Cale> Xenoblitz: in fact, I don't know if it does anymore, but HGL actually came with GHC for a long time
10:31:52 <sclv> Xenoblitz: that should work with windows?
10:31:52 <_ar> Cale: i'm vaguely familiar with matroids
10:31:59 <newsham> ahh,,  sequ :: (b->a) -> PU a -> (a -> PU b) -> PU b
10:32:04 <newsham> thats what i was looking for
10:32:10 <Axman6> Cale: sure you don't mean HOpenGL?
10:32:13 <the_unmaker> A simple graphics library, designed to give the programmer access to most interesting parts of the Win32 Graphics Device Interface and X11 library without exposing the programmer to the pain and anguish usually associated with using these interfaces.
10:32:14 <the_unmaker> lol
10:32:18 <Axman6> apparently they're different...
10:32:20 <the_unmaker> pain and anguish
10:32:21 <the_unmaker> lol
10:32:30 <Cale> _ar: Do you know whether there's a name for maps between the underlying sets of two matroids such that the preimage of any independent set is independent?
10:32:52 <Cale> _ar: It would seem to be the natural thing to define as a matroid homomorphism, but nobody seems to mention them.
10:32:52 <Saizan> Xenoblitz: you can download the archive from the above url, and follow the instructions here to install it http://www.haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package
10:32:55 <lambdabot> Title: Cabal/How to install a Cabal package - HaskellWiki, http://tinyurl.com/2ack74
10:33:04 <Cale> Axman6: I'm sure
10:33:07 <sclv> if you look at the package file it conditionally compiles different bindings based on the os
10:33:12 <Axman6> ok
10:33:18 <Xenoblitz> thanks Saizan :D
10:33:22 <Xenoblitz> i'll figure it out :)
10:34:31 <_ar> Cale: i've never studied the structure outside of it's application to graph theory. I'd call such a thing a homomorphism
10:34:45 <Axman6> "The X11 version is available via HTML as source code. " HTTP?
10:35:43 <Cale> _ar: I would too... It's possible that I've been looking at all the wrong books, but "matroid homomorphism" gets about 4 hits in google.
10:36:05 <Cale> (none of which seems particularly promising)
10:37:14 <TehZorroness> Can someone help me out with this program?  the error is included in the past: http://hpaste.org/10893
10:37:48 <_ar> Cale: If I had to guess, I doubt anyone outside of category theoretic perspective has really considered it
10:38:50 <rwbarton> TehZorroness: You need to write "return IWAD", ..., or "return $ case ..."
10:39:03 <Cale> That is both disturbing and very interesting for me. I should learn matroid theory so I can write all the obvious papers. :)
10:39:20 <TehZorroness> ahhh
10:39:45 <TehZorroness> rwbarton, you have to do that within all monadic expressions, don't you?
10:40:02 <Cale> TehZorroness: see, the last line of your do-block must itself be an action
10:40:11 <_ar> maybe a rotation? since in linear algebra a linear transformation that takes an independent set of vectors to an independent could be called rotation. granted rotation is a stronger notion then general independent set perserving maps
10:40:18 <rwbarton> TehZorroness: Every line in a do block must be an action in the monad (except lines of the form let foo = ...)
10:40:30 <Cale> TehZorroness: it's okay for that action to be described by a case-block, but in that event, each branch of the case must result in an action :)
10:40:46 <reltuk> TehZorroness: you'll also need to change main to do something like "wad <- checkWad fn\ncase wad of ..."
10:41:08 <Cale> TehZorroness: the other option is to apply return to the entire case which constructs an action that does nothing but return the value determined by the case
10:41:09 <_ar> i meant "than" not "then"
10:41:24 <Cale> _ar: yeah
10:41:30 <TehZorroness> alright
10:42:45 <Arnar_> hi all
10:43:07 <Arnar_> do you guys know of any library or datastructures to deal with image data?
10:43:12 <Arnar_> as in a 2D array of floats
10:44:05 <rwbarton> Cale: A lot of combinatorics has not been infected by category theory yet.  I like to annoy my combinatorialist friends by referring to the "real product" of graphs (it's not the Cartesian product!)
10:44:37 <TehZorroness> It compiles and runs now, I just need to find the source of a logic error now :)
10:45:09 <dmwit_> Arnar_: I used Gtk2Hs for some image manipulations recently and was pleasantly surprised at how much I could do.
10:45:16 <rwbarton> TehZorroness: Actually, this particular program probably won't work if you write "return $ case ..."
10:45:25 <dmwit> Arnar_: There are also a few other libraries available on Hackage.
10:45:36 <Arnar_> dmwit: ah, thanks
10:45:37 <dmwit> (Though their documentation is not as good as Gtk2Hs'.)
10:46:00 <Arnar_> dmwit: basically I'm looking for some general structure on which it is easy/concise to write image manipulation algorithms
10:46:03 <dmwit> If you decide to go the same route I did, you'll want to look at the Pixbuf documentation.
10:46:13 <the_unmaker> homo morphism?
10:46:16 <the_unmaker> heh
10:46:17 <Arnar_> dmwit: ah, thanks
10:46:18 <the_unmaker> lol
10:46:45 <dmwit> the_unmaker: A homomorphism is a function that "preserves structure", for a suitable definition of structure.
10:46:58 <the_unmaker> structure=state?
10:47:19 <dmwit> mmm, no, not necessarily
10:47:24 <SamB_XP> well, generally an algebraic structure
10:47:35 <rwbarton> function in the math sense, not the Pascal sense
10:47:38 <dmwit> the_unmaker: You have to specify an operation that the homomorphism preserves.
10:48:00 <dmwit> If h is a homomorphism under f, then h(f(a, b)) = f(h(a),h(b))
10:48:02 <dmwit> or something like that.
10:48:05 <SamB_XP> for instance, there is a ring homomorphism from the integers to the rationals
10:48:17 <_ar> Cale: http://www.ecp6.jussieu.fr/pageperso/las_vergnas/maths/articles/2001TPMM3.ps
10:48:19 <mauke> φ(a·b) = φ(a)·φ(b)
10:48:23 <lambdabot> http://tinyurl.com/3nfoqu
10:48:36 <dmwit> the_unmaker: I think Wikipedia has a pretty good page on it.
10:48:48 <SamB_XP> I think a homomorphism could actually be a family of related functions
10:48:52 <dmwit> mauke: Oh, good, I got it right. =P
10:49:38 <ddarius> @hackage carray
10:49:38 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/carray
10:49:39 <SamB_XP> if you had a "multi-parameter" algebraic structure ;-)
10:50:33 <TehZorroness> rwbarton, does it have to do with lazy evaluation at some level?
10:50:35 <mauke> std::φ<std::allocator<Φ> >(a·b) = std::φ<std::allocator<Φ> >(a)·std::φ<std::allocator<Φ> >(b)
10:51:00 <rwbarton> TehZorroness: Yes... it's a little unfortunate.
10:51:36 <rwbarton> TehZorroness: What's happening is that hGetContents doesn't actually read the entire file right away, it just returns a list which, when demanded, will perform the operation of reading the file and returning the results.
10:51:50 <TehZorroness> I put a putStrLn (take 4 header) before it and that made it start working :)
10:51:57 <rwbarton> TehZorroness: Yes, exactly
10:52:18 <dmwit> Lazy IO may cause more problems than it solves.
10:52:21 <b_jonas> which is evil
10:52:42 <b_jonas> I wonder why it doesn't have "unsafe" or something in its name
10:52:49 <rwbarton> If this is your entire program, you can just use readFile rather than the whole bracket/openFile/hClose/hGetContents thing.
10:53:21 <rwbarton> (The only problem with readFile is that it might not close the file handle for a long time.)
10:53:30 <TehZorroness> well, I'm just fiddling around right now trying to become more comfortable with haskell :)
10:53:48 <b_jonas> is there a safe variant that reads the file immediately by the way?
10:54:01 <TehZorroness> my mind has been rotted by C++ after all these years :)
10:54:17 <b_jonas> the name is just confusing
10:55:20 <sjanssen> b_jonas: strict ByteString's readFile will read the whole file immediately
10:55:34 <rwbarton> TehZorroness: If you read this text very carefully: http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html#v:hGetContents
10:55:36 <lambdabot> Title: System.IO, http://tinyurl.com/sbkmj
10:55:40 <rwbarton> TehZorroness: it will tell you not to do what you did :)
10:56:08 <b_jonas> sjanssen: thanks
10:56:15 <TehZorroness> haha
10:56:17 <TehZorroness> opk
10:56:20 <TehZorroness> ok*
10:57:09 <TehZorroness> I guess that's neat that it doesn't open the file right away though
10:57:49 <TehZorroness> it's bad to load a huge file into memory, and implementing something like that in C/C++ would be a pain :)
10:58:49 <rwbarton> TehZorroness: Yes, lazy IO is definitely useful, it's just also easy to write programs with it that don't work as expected.
10:59:01 <TehZorroness> as I've figured out :)
10:59:36 <b_jonas> it might be useful but it shouldn't be in the System.IO module with an inconspicious name
10:59:43 <rwbarton> (Where did you learn about bracket, BTW?  Is there an example somewhere with similar code?)
11:00:00 <TehZorroness> YAHT chapter on basic IO
11:00:15 <dmwit> whoa
11:00:25 <dmwit> YAHT puts that in the basic IO chapter?
11:00:35 <SamB_XP> dmwit: isn't it good to do that ?
11:00:56 <dmwit> I haven't used bracket, ever.
11:01:04 <b_jonas> what bracket?
11:01:05 <rwbarton> I see
11:01:08 <dmwit> Therefore, I would claim that bracket is not basic.
11:01:11 * rwbarton hasn't used bracket either
11:01:12 <SamB_XP> hahahaha
11:01:29 <SamB_XP> b_jonas not only hasn't used it -- he doesnn't know what it is ?
11:01:34 <dblazakis> :t bracket
11:01:35 <lambdabot> Not in scope: `bracket'
11:01:46 <ddarius> bracket corresponds to try/finally
11:01:50 <Deewiant> @hoogle bracket
11:01:51 <lambdabot> Control.Exception bracket :: IO a -> a -> IO b -> a -> IO c -> IO c
11:01:51 <lambdabot> Control.Exception bracket_ :: IO a -> IO b -> IO c -> IO c
11:01:51 <lambdabot> Control.Exception bracketOnError :: IO a -> a -> IO b -> a -> IO c -> IO c
11:01:51 <dmwit> dblazakis: It wraps IO actions in finalizers, in the case of an exception, I think.
11:01:54 <Deewiant> O_o
11:01:55 <Deewiant> hoogle bug
11:02:02 <b_jonas> I see
11:02:18 <TehZorroness> not a bug
11:02:26 <TehZorroness> the function handles exceptions :P
11:02:28 <dmwit> Deewiant: bug?
11:02:42 <Deewiant> dmwit: it lost the brackets in those definitions
11:02:43 <ddarius> (a -> IO b)
11:02:46 <Deewiant> (pun not intended)
11:03:01 <dmwit> ah
11:03:04 <Deewiant> IO a -> (a -> IO b) -> (a -> IO c) -> IO c
11:04:07 <_ar> Cale: http://books.google.com/books?id=puKta1Hdz-8C&pg=PA267&lpg=PA267&dq=Strong+maps+of+matroids&source=web&ots=60VUEW8grz&sig=Tbej78MvonRtR1OXIFsFz7OV3Ow&hl=en&sa=X&oi=book_result&resnum=4&ct=result
11:04:09 <lambdabot> Title: Matroid Theory - Google Book Search, http://tinyurl.com/4a2x36
11:04:25 <vixey> ##c
11:04:42 <Cale> _ar: aha, thanks :)
11:05:01 <Cale> _ar: (and thanks for that earlier paper)
11:05:23 <_ar> yeah no problem
11:09:21 <sbahra> vixey, what about it?
11:09:42 <vixey> that was obviously a typing mistake
11:09:57 <sbahra> Deewiant, http://www.thebestpageintheuniverse.net/c.cgi?u=puns
11:09:58 <lambdabot> Title: Nobody cares if your puns were intended.
11:11:41 <dons> ?users
11:11:42 <lambdabot> Maximum users seen in #haskell: 516, currently: 506 (98.1%), active: 22 (4.3%)
11:12:25 <Deewiant> sbahra: when I say "no pun intended" it means that I noticed the pun after the fact
11:12:45 <Deewiant> I don't use it in writing, but I think it has a place in interactive channels such as IRC
11:13:05 <sbahra> Deewiant, :-P
11:13:07 <Deewiant> wasn't one of Maddox's better rants anyway :-P
11:13:13 <sbahra> Agreed.
11:13:19 <dblazakis> ']]]]]]]]
11:13:34 <dblazakis> ---------
11:13:35 <dblazakis> '|
11:13:58 --- mode: ChanServ set +o dons
11:14:03 --- topic: set to '["The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
11:14:06 --- mode: ChanServ set -o dons
11:14:29 * dolio also hates '(no) pun intended'.
11:14:44 <mauke>       pun indented
11:14:45 <SamB_XP> ... what the ?
11:15:20 <dblazakis> err lambda toddler :-)
11:21:23 * SamB_XP was trying to figure out why anyone would write "(no) pun intended" -- can't they decide whether or not the pun was intentional?
11:21:34 <dons> ?users
11:21:35 <lambdabot> Maximum users seen in #haskell: 516, currently: 507 (98.3%), active: 24 (4.7%)
11:22:21 <Nafai> dons: So have you started on some gtk2hs hacking?
11:22:51 <lightstep> maybe they intended a pun but not sure if they got it right
11:23:28 * Cale considers defining a matroid object in an arbitrary category :)
11:23:43 <mauke> .oO( matroid prime )
11:23:58 <Cale> 'matroid' is an awfully silly name
11:23:59 <dons> twitter loves haskell, http://twitter.com/lallysingh/statuses/945333684
11:24:00 <lambdabot> Title: Twitter / Lally Singh: Haskell has interactive pl ...
11:24:10 <dons> there are lots of little 'falling in love with haskell' tweets like this.
11:24:15 <Cale> pregeometry would indeed be a nicer name :)
11:24:22 <kolmodin> code.haskell.org is down? or just slow?
11:24:32 <ddarius> We have interactive plotting commands?
11:24:43 <kolmodin> available over ssh, seems dead over http
11:25:17 <Cale> ddarius: Yeah, I was thinking the same thing.
11:25:50 <Cale> I would love to have a library in Haskell which came anything close to Mathematica's graphing stuff. :)
11:26:05 <ddarius> Cale: Write one.
11:27:15 <sclv> cale: as in fancy 3d stuff or just plots?
11:27:32 <Igloo> kolmodin: Ta, I've restarted apache
11:28:03 <Cale> sclv: ContourPlot3D would be awfully nice ;)
11:28:28 <kolmodin> Igloo: np, thanks
11:28:44 <sbahra> gnuplot library
11:29:24 <Cale> Does gnuplot's 3D stuff include plotting implicitly defined surfaces?
11:29:33 <Cale> Or does it just plot functions?
11:29:48 <sbahra> Explicitly defined?
11:30:04 <sbahra> Yes, whatever it is, it does it.
11:30:26 <newsham> Peaker: still here?
11:30:38 * Igloo contemplates blocking Yahoo's crawler, as that seems the most likely culprit currently
11:30:48 <sclv> i wonder how hard that would be to build with the graphics libs...
11:31:03 <Cale> (implicitly defined as in, surfaces defined by equations like f(x,y,z) = g(x,y,z))
11:31:17 <SamB_XP> Igloo: what is it crawling ?
11:31:18 <Cale> (or f(x,y,z) = 0, equivalently)
11:32:16 <newsham> cale: ask gnuplot.  run gnuplot, tpye "help splot"
11:32:17 <sbahra> Cale, oh, I'm not sure if it will handle that. Either I have 1 or more different functions or I plot data points (and most of my work involves the latter, since I'm graphing discrete things to begin with).
11:33:05 <retrohscoder> how do you know when you've had too much haskell for one day? ...when you wake up after 1pm at the foot of your DESK! :P
11:33:14 <Cale> retrohscoder: haha
11:33:33 <retrohscoder> O_o I don't even remember falling asleep
11:34:04 <newsham> at the _|_ of your desk?
11:34:20 <retrohscoder> hehe
11:34:29 <takamu> hi
11:35:09 <retrohscoder> apparently I fell out my chair..and ended up sleeping under the desk on top of the UPS and the stack of programming books :D
11:35:45 <vixey> wow
11:35:56 <Cale> takamu: hello
11:36:38 <retrohscoder> WARNING: Haskell can be dangerous in large quantities.
11:36:46 <retrohscoder> I should have read the label
11:37:22 <harrison_partch> i built the haskell ide leskah. i can crash it.
11:37:33 <harrison_partch> leskah is very alpha.
11:37:36 <takamu> I'm trying to fix a text file which has a mix of unix and windows end of lines, so I tried filter (/= '\LF') , but it doesn't work. How can I do this?
11:37:49 <vixey> :t '\LF'
11:37:51 <lambdabot> Char
11:38:00 <Cale> hmm
11:38:00 <mauke> how does it not work?
11:38:06 <takamu> I want to remove the LFs
11:38:08 <Cale> > ord '\LF'
11:38:09 <lambdabot>   10
11:38:15 <mauke> oh
11:38:17 <Deewiant> not the CRs?
11:38:17 <Cale> > ord '\n'
11:38:18 <lambdabot>   10
11:38:19 <mauke> > ord '\CR'
11:38:20 <lightstep> > fromEnum 13 :: Char
11:38:20 <lambdabot>   13
11:38:22 <lambdabot>   Couldn't match expected type `Char' against inferred type `Int'
11:38:24 <newsham> retro: hmm.. power supply probably not the best head rest
11:38:27 <newsham> maybe thats why you cant remember
11:38:28 <takamu> some lines end in CR and others in CR+LF
11:38:29 <newsham> all them EMFs
11:38:35 <Deewiant> > toEnum 13 :: Char
11:38:36 <mauke> takamu: unlikely
11:38:37 <lambdabot>   '\r'
11:38:38 <retrohscoder> newsham: hahaha
11:38:52 <mauke> takamu: only old macs used CR to end lines
11:38:55 <Cale> > ord '\r'
11:38:56 <lambdabot>   13
11:39:09 <takamu> CR is not unix style?
11:39:10 <retrohscoder> possibly. okay. I'm going to stop hijacking the channel with my insanity :D ...back to....haskell!
11:39:16 <mauke> no, unix uses a single LF
11:39:42 <takamu> ah, ok
11:39:50 <takamu> i will try removing CR then
11:40:00 <newsham> Peark/sclv/vixey: what do you think of an ugly hack like this?  http://www.thenewsh.com/~newsham/x/machine/Marshall.hs
11:40:49 <newsham> plus: notational simplicity,  minus: not efficient and somewhat hacky
11:40:50 <takamu> nope, the file doesn't change at all
11:41:52 <takamu> mmm I will report it as a ghc bug
11:41:58 <mauke> takamu: report what?
11:42:09 <takamu> filter (/= '
11:42:24 <takamu> filter (/= '\CR') doesnot change anything
11:42:25 <Deewiant> > filter (/= '\CR') "abc\rfoo\n"
11:42:27 <lambdabot>   "abcfoo\n"
11:42:30 <Deewiant> seems to work pretty well
11:42:34 <mauke> takamu: of course it doesn't, it's just a function
11:43:24 <dons> Cale: interactive plotting == ghci?
11:43:31 <dons> ?users
11:43:32 <lambdabot> Maximum users seen in #haskell: 516, currently: 509 (98.6%), active: 25 (4.9%)
11:43:33 <takamu> yes, actually I use readFile "myfile" >>= (filter (/= '\CR') >>> writeFile "result")
11:44:03 <newsham> dons: got any graphs of ?users data?   i wonder how the active percent has changed over time
11:44:03 <mauke> hmm
11:44:12 <mauke> takamu: are you doing this on windows?
11:44:20 <takamu> unix
11:44:29 <Deewiant> takamu: readFile might convert all line breaks to '\n', not sure
11:44:36 <Deewiant> although hmm
11:44:36 <ddarius> http://www.haskell.org/haskellwiki/IRC_channel
11:44:37 <lambdabot> Title: IRC channel - HaskellWiki
11:44:39 <sbahra> Deewiant, no
11:44:40 <Deewiant> writeFile should then write \n
11:45:04 <takamu> i will try to change the encoding
11:45:19 <sw17ch> can a Socket be converted to a Handle?
11:45:22 <Cale> dons: Well, if he's saying goodbye to mathematica, that means there must exist (at least) a rather excellent plotting library for Haskell. I suppose there are some charts libraries, but as far as I know, there's nothing which comes close to the stuff which mathematica handles easily.
11:45:42 <newsham> ddarius: ?
11:45:53 <takamu> ah, sorry, it worked, I was reading a different file, not "result"
11:45:58 <ddarius> At the bottom is a very long term graph
11:46:15 <newsham> but it doesnt show active percent
11:46:27 <ddarius> http://www.cse.unsw.edu.au/~dons/irc/
11:46:29 <lambdabot> Title: Haskell IRC Activity
11:47:30 <ddarius> I don't think there is anything that particularly tracks what lambdabot calls "active"
11:47:37 <ddarius> You could create it from the logs though.
11:47:43 <Deewiant> sbahra: on windows it converts \n to \r\n and eats \r
11:48:13 <Deewiant> or hmm
11:48:19 <sbahra> I don't know about that.
11:48:20 <Deewiant> argh, I'm messing up with vim
11:48:25 <sbahra> But over here, it isn't doing that.
11:48:45 <sbahra> FreeBSD
11:49:12 <pstickne> how \r\n and end are handled will 1) depend on the editor 2) depend on the IO layer and munging it does (look at cygwin)
11:49:26 <Deewiant> \n becomes \r\n, eating the \r was just a messup of mine
11:49:29 <pstickne> any sane system will treat \r\n like it is -- \r\n :-)
11:50:06 <Deewiant> a file with foo\nbar\r\nbaz\rzot became foo\r\nbar\r\nbaz\rzot
11:50:16 <pstickne> Deewiant:  eww. in what?
11:50:22 <Deewiant> readFile >>= writeFile
11:50:25 <Deewiant> under windows
11:50:36 <Deewiant> and GHC 6.10
11:50:41 <pstickne> is the file opened as text or binary?
11:50:44 <Deewiant> I don't know
11:50:49 <Igloo> text
11:50:54 <sbahra> ye
11:50:55 <Deewiant> :-/
11:51:06 <Igloo> There are other functions for using binary files
11:51:44 <Deewiant> but none which gives the contents directly, except bytestrings of course
11:52:07 <pstickne> use cygwin and disable the munging IO :-)
11:52:37 <newsham> why use cygwin?  thats just another layer of software that you added that you dont really need
11:52:38 <Deewiant> using cygwin just ain't practical, it's way too slow
11:52:39 <pstickne> (I don't know if/how haskell would still apply virtualized newlines, so :p)
11:52:49 <Deewiant> and it would in any case
11:52:58 <pstickne> I lose.
11:53:03 <Deewiant> running from a different shell won't make GHC behave differently :-P
11:53:19 <ddarius> newsham IRCs by flipping switches on a relay machine.
11:53:23 <newsham> deewiant: its possible to compile ghc in cygwin differently than the normal win32 build
11:53:41 <Deewiant> well sure
11:53:46 <Deewiant> but I'm not going to compile GHC under cygwin
11:53:49 <newsham> thats what they mean, I believe
11:53:53 <Deewiant> that would probably take approximately a year
11:53:56 <newsham> and you shouldnt :)
11:54:39 <newsham> ddarius: i'm not implying that cygwin shouldnt be used, i use it all the time, but for ghc its not usually the right choice unless there's some specific unix package you need in ghc
11:55:10 <newsham> it doesnt have anything to do with relays or asceticism
11:55:22 <shapr> I can't seem to integrate haskell-mode and ghci on windows.
11:56:14 <Deewiant> cygwin is dog-slow - or rather, the unix habit of spawning processes all willy-nilly is slow to the point of being impractical under windows
11:58:32 <b_jonas> ddarius: what, no butterfly?
11:59:06 <mauke> ip/avian carrier
11:59:32 <b_jonas> yeah, that too
12:00:21 <b_jonas> I irc with netcat sometimes
12:00:43 <b_jonas> for developping bots or once when I needed support during installing freebsd and it only gave me a busybox
12:00:57 <mauke> nice
12:01:05 <b_jonas> developpers of install cds: an irc client is a recovery tool, you need it during install
12:01:18 <newsham> privmsg b_jonas :is that even possible?
12:01:19 <mauke> can you render html in your head?
12:01:50 <b_jonas> newsham: why not?
12:01:56 <pstickne> mauke:  yes. but for some reason the screen always comes out blank.
12:02:42 <newsham> mr drake
12:03:35 <b_jonas> I wouldn't dare the avian carrier method. I don't understand tcp that much
12:04:50 <newsham> its just about telling your peer how many in-order lettes you've accepted so far
12:05:01 <newsham> and labelling each message with the count of the first letter
12:05:14 <newsham> nothing rocket sciencey
12:08:15 <dons> Arch Haskell News, http://archhaskell.wordpress.com/2008/10/04/arch-haskell-news-oct-4-2008/
12:08:17 <lambdabot> Title: Arch Haskell News: Oct 4 2008 « Arch Linux and Haskell, http://tinyurl.com/3ggzw4
12:16:20 <dons> also on reddit, http://www.reddit.com/r/programming/comments/759am/arch_haskell_news_609_haskell_packages_in_arch/
12:16:22 <lambdabot> Title: Arch Haskell News: 609 Haskell packages in Arch Linux : programming, http://tinyurl.com/4xr9d4
12:20:21 <eric_8th_Light> Anybody got a second for a basic Haskell question?
12:20:27 <mauke> sure
12:20:34 <mauke> time's up!
12:21:00 <eric_8th_Light> I want to create a type representing a tic-tac-toe board.  An array of arrays.  I've tried type Board = [[]]
12:21:12 <eric_8th_Light> and type Board = Array (Int, Int) Player
12:21:19 <eric_8th_Light> and type Board = [[Player]]
12:21:26 <eric_8th_Light> Player is just data Player = X | Y
12:21:40 <eric_8th_Light> but none of them seems to work correctly.  What am I doing wrong?
12:21:49 <mauke> what do you mean by "work correctly"?
12:21:57 <mauke> the first one looks like a syntax error to me
12:22:49 <eric_8th_Light> I'm trying to TDD a method to determine if a player is a winner - so I have this:
12:22:51 <eric_8th_Light> isWinner	:: Player -> Board -> Bool
12:22:52 <eric_8th_Light> isWinner player board = False
12:22:56 <eric_8th_Light> Only one case so far :)
12:23:00 <b_jonas> X | Y? hwo about empty elements?
12:23:07 <b_jonas> I mean empty fields
12:23:23 <b_jonas> fields with no nought or cross
12:23:49 <eric_8th_Light> How would I specify that - an underscore?
12:23:52 <eric_8th_Light> didn't think of it yet
12:24:28 <eric_8th_Light> My test case is where I get confused
12:24:29 <eric_8th_Light> I get this
12:24:29 <eric_8th_Light> testEmptyBoard = TestCase (assertEqual "Empty Board is not a winner for x" (False) (isWinner X, [[]]))
12:24:44 <eric_8th_Light> Couldn't match expected type `Bool'
12:24:44 <eric_8th_Light>            against inferred type `(Board -> Bool, [[a]])'
12:24:46 <b_jonas> no underscore, that doesn't start with an underscore so you can't use it as a constructor identifier
12:24:54 <b_jonas> just give it some name
12:25:05 <eric_8th_Light> duh
12:25:06 <eric_8th_Light> slaps head
12:25:23 <newsham> data Mark = X | O | Empty
12:25:25 <newsham> ?
12:25:26 <rwbarton> You also don't want that , after X
12:25:54 <Twey> newsham: That 'Empty' functionality is already implemented
12:26:01 <Twey> data Mark = X | O
12:26:12 <Twey> Then use a Maybe Mark
12:26:22 <b_jonas> I don't think that's really convenient
12:26:29 <eric_8th_Light> Cool got a passing test!
12:26:32 <b_jonas> depends on what you want to do with the board of course
12:26:47 <eric_8th_Light> Stinking commas - I keep putting them in out of habit
12:26:47 <b_jonas> how's [[]] an empty board?
12:26:52 <b_jonas> shouldn't boards be 3x3?
12:26:56 <retrohscoder> what do you need to import for the function forM ?
12:27:02 <rwbarton> @hoogle forM
12:27:02 <mauke> @index forM
12:27:03 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
12:27:03 <lambdabot> Data.Traversable forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
12:27:03 <lambdabot> Text.XHtml.Frameset form :: Html -> Html
12:27:03 <lambdabot> bzzt
12:27:20 <b_jonas> Control.Monad then
12:27:25 <retrohscoder> thanks
12:27:49 <newsham> empty = [[Empty,Empty,Empty],[Empty,Empty,Empty],[Empty,Empty,Empty]]
12:28:08 <eric_8th_Light> yeah I switched it to that
12:28:47 <eric_8th_Light> Now i've got this for the test case
12:28:47 <eric_8th_Light> testEmptyBoard = TestCase (assertEqual "Empty Board is not a winner for x" (False) (isWinner X [[Empty, Empty, Empty], [Empty, Empty, Empty], [Empty, Empty, Empty]]))
12:28:58 <eric_8th_Light> And this for code
12:28:59 <eric_8th_Light> data Player = X | Y | Empty
12:28:59 <eric_8th_Light> type Board  = [[Player]]
12:29:00 <eric_8th_Light> 	
12:29:00 <eric_8th_Light> isWinner	:: Player -> Board -> Bool
12:29:00 <eric_8th_Light> isWinner player board = False
12:29:09 <eric_8th_Light> and it "works" in the sense it doesn't do anything :)
12:29:17 <newsham> isWinner Empty empty
12:29:22 <b_jonas> but of course it's better to store a tictactoe board as a straight array of nine elements in magic square order
12:29:39 <newsham> magic-square order?
12:30:03 <eric_8th_Light> yeah what newsham said
12:30:17 <newsham> eric: Empty isnt really a player.
12:30:18 <b_jonas> newsham: the number in the relevant cell of a 3x3 magic square tells the index to store the element
12:30:39 <b_jonas> newsham: then all lines are of three elements whose indices sum up to the same number
12:30:55 <b_jonas> newsham: and it's also easy to see that those are the only lines (if the indices are within the bound)
12:31:13 <b_jonas> newsham: this idea is described in a book by Csákány Béla
12:31:53 <eric_8th_Light> cool
12:31:59 <newsham> bjonas: how does that simplify detecting a winner?
12:32:53 <b_jonas> newsham: you just iterate all pairs of (two different) noughts and check if the element at 12-x-y is also a nought, if it is, then nought has won
12:32:57 <b_jonas> or something like that
12:33:10 <b_jonas> you just need to check if three noughts are in indices with sum 12
12:33:38 <eric_8th_Light> Is this what you're referring to b_jonas?
12:33:39 <eric_8th_Light> http://en.wikipedia.org/wiki/Magic_square
12:33:40 <lambdabot> Title: Magic square - Wikipedia, the free encyclopedia
12:33:48 <eric_8th_Light> jinx
12:33:48 <newsham> i dont understand how thats simpler. :\
12:34:40 <eric_8th_Light> Well I had no idea how I was gonna do diagonals in this matrix
12:35:11 <eric_8th_Light> this sounds like I can make it a kind of list comprehension - if I'm using the term correctly
12:35:26 <newsham> [(i,i) | i <- [0..2]]
12:35:32 <newsham> > [(i,i) | i <- [0..2]]
12:35:33 <lambdabot>   [(0,0),(1,1),(2,2)]
12:35:37 <newsham> > [(i,2-i) | i <- [0..2]]
12:35:39 <lambdabot>   [(0,2),(1,1),(2,0)]
12:36:19 <newsham> [[(n,i) | i <- [0..2]] | n <- [0..2]]
12:36:27 <newsham> > [[(i,n) | i <- [0..2]] | n <- [0..2]]
12:36:29 <lambdabot>   [[(0,0),(1,0),(2,0)],[(0,1),(1,1),(2,1)],[(0,2),(1,2),(2,2)]]
12:36:58 <newsham> (you could also just manually enumerate all lines)
12:37:18 <newsham> there's only 8 of em
12:38:30 <eric_8th_Light> yeah I'm not worried about efficiency - just want the most haskelly solution
12:38:48 <SamB_XP> it's not like it really makes things any more or less efficient
12:39:03 <newsham> http://www.lasvegassun.com/news/2002/jun/21/columnist-susan-snyder-defeat-a-chicken-good-cluck/
12:39:06 <lambdabot> Title: Columnist Susan Snyder: Defeat a chicken? Good cluck - Las Vegas Sun, http://tinyurl.com/45cymd
12:40:09 <dmwit> THERE ARE FOUR LIGHTS
12:40:39 <b_jonas> newsham: how would you do it with a square matrix?
12:41:01 <b_jonas> newsham: oh yeah, but 8 lines is more than the 9 indices
12:41:19 <newsham> bjonas: i dont understand what you're saying
12:41:20 <b_jonas> sure, it's just a fun fact, not really useful
12:41:22 <newsham> can you be more verbose?
12:43:52 <newsham> oh, you're saying keep a list of the players magic numbers, and then take all combinations of those 3 numbers and see if any adds to 15
12:44:15 <newsham> how efficient is that?
12:44:41 <dmwit> Since there can be at most five moves... pretty efficient.
12:45:10 <newsham> but at five moves isnt that less efficient than looking at the lines one at a time?
12:45:14 <newsham> > 5 * 4 * 3
12:45:15 <lambdabot>   60
12:45:22 <newsham> > 8 * 3
12:45:23 <lambdabot>   24
12:45:24 <dmwit> > 5 * 4 * 3 / (3 * 2)
12:45:25 <lambdabot>   10.0
12:45:56 <newsham> ahh
12:46:26 <newsham> seems like an interesting approach
12:46:30 <dmwit> But, displaying the board is less efficient. =)
12:46:43 <b_jonas> you can take all the lines at once, sure
12:47:50 <b_jonas> still you can code that by iterating on all 0<=x<y<9 and setting z=12-x-y and then if 0<=z<9 && z/=x && z/=y then (x,y,z) is a line
12:48:08 <b_jonas> it's not really useful, sure, because just listing the lines is easier
12:48:14 <b_jonas> just funny
12:48:37 <newsham> what if you represent the board as  [(Maybe Mark, Int, Int)] where Ints store X and Y player's value (0 or magic number)
12:49:01 <dmwit> too complicated
12:49:12 <newsham> we didnt even introduce any functors yet
12:49:20 <b_jonas> why mahybe
12:49:25 <shrughes> folks
12:49:26 <dmwit> What are you talking about?  Lists and tuples are both Functors, as is Maybe!
12:49:28 <b_jonas> just list the marks
12:49:35 <shrughes> please stop talking about my employer's interview questions
12:49:36 <shrughes> thank you
12:49:38 <adu> newsham: wouldn't [((Int, Int), Maybe Mark)] make more sense?
12:49:52 <b_jonas> shrughes: what?
12:49:52 <adu> newsham: then you could use lookup
12:49:53 <shrughes> (:P)
12:50:15 <dmwit> Your tongue-face is trapped in a bubble! (Help!)
12:50:17 <newsham> adu: (Maybe Mark, (Int, Int))
12:50:24 <newsham> since Maybe Mark would be the key
12:50:38 <newsham> actually then just   [(Maybe Mark, Int)]
12:50:39 <adu> newsham: oh
12:50:41 <newsham> i like it
12:50:58 <b_jonas> the bad part is that you also need to translate back from the position to the magic number
12:51:05 <newsham> and you can use an unfold over splitAt 3 to print the board
12:51:09 <b_jonas> unless you make the interface such that the user inputs the magic number
12:51:18 <newsham> bjonas: no, i'm not storing position
12:51:23 <newsham> i'm storing magic number
12:51:38 <newsham> list of (mark, magic number)
12:52:31 <b_jonas> then when a human player does a step, you have to generate the magic number from their input, which is presumably of the row-column form
12:52:40 <newsham> xs = [n | (Just X, n) <- board]
12:52:50 <newsham> os = [n | (Just O, n) <- board]
12:53:18 <newsham> bjonas: magic number is pre-baked into the table
12:53:26 <newsham> maybe i should just write this out so its clear
12:53:32 <b_jonas> newsham: oh, I see
12:53:39 <b_jonas> newsham: so you store in row-major order
12:53:42 <newsham> *nod*
12:53:44 <b_jonas> all nine cells
12:53:44 <b_jonas> I see
12:53:53 <newsham> easy to print, easy to compute on
12:54:01 <b_jonas> yep
12:57:44 <b_jonas> that's a nice programming exercise
12:57:52 <b_jonas> writing tic-tac-toe I mean
12:58:09 <newsham> http://www.flickr.com/photos/gocarrt/3151572/
12:58:10 <lambdabot> Title: Tinkertoy Tic Tac Toe, designed and built by Danny Hillis and Brian Silverman on ...
13:00:08 <eric_8th_Light_> it's a standard exercise our company gives apprentice programmers.  I figured I'd try it in a new language - Haskell
13:01:25 <BMeph> Sorry for just barging on - eric_8th_Light, what's the exercise? :)
13:01:35 <b_jonas> BMeph: tic-tac-toe
13:01:49 <eric_8th_Light_> The trick is it can't be beatable
13:01:59 <b_jonas> BMeph: we're discussing what the optimal way is to store the board -- I'm still not sure
13:02:04 <b_jonas> BMeph: what's your guess?
13:02:05 <eric_8th_Light_> now no applying for jobs and cheating :)
13:02:11 <Deewiant> optimal for what purposes
13:02:14 <Twey> Array, b_jonas...
13:02:44 <Deewiant> IntSet would probably be pretty good
13:03:04 <b_jonas> IntSet? for nine elements?
13:03:13 <Deewiant> oh, plain 3x3 tic-tac-toe?
13:03:29 <Deewiant> well, you need nine trits then
13:03:40 <Deewiant> > 3^9
13:03:42 <lambdabot>   19683
13:03:49 <Deewiant> fits in a short
13:04:12 <b_jonas> less actually
13:04:33 <Deewiant> > logBase 2 19683
13:04:34 <lambdabot>   14.264662506490406
13:04:35 <b_jonas> you only need to consider ones with a balanced number of noughts and crosses
13:04:49 <Deewiant> true
13:04:56 <dmwit> > 9 * 8 * 7 * 6 * 5 * 4 * 3 * 2
13:04:56 <lightstep> and only reachable game positions
13:04:57 <lambdabot>   362880
13:05:00 <Deewiant> but how easy is that to work with
13:05:01 <b_jonas> and I think there are a few more impossible ones, like one with a row of noughts and a row of crosses
13:05:13 <dmwit> right
13:05:18 <dblazakis> how do you specify a module other than Main on the ghc command line?
13:05:22 <b_jonas> and in fact you only need one that is reachable with the strategy your computer player
13:05:24 <Twey> 210206 < eric_8th_Light_> now no applying for jobs and cheating :)
13:05:27 <dmwit> dblazakis: --main-is
13:05:36 <dblazakis> oh, i thought that was for the function
13:05:37 <Twey> eric_8th_Light_: Except you just got yourself put in the #haskell online logs :-P
13:05:44 <dmwit> dblazakis: Oh, it is, sorry.
13:05:49 <dmwit> dblazakis: Just specify the file the module is in.
13:05:57 <BMeph> b_jonas: Shorter still, since you could ignore all the ones that have to follow a winning move as well. ;)
13:06:12 <Cale> dblazakis: Well, you can specify a function other than Main.main then.
13:06:14 <eric_8th_Light_> oh crud!
13:06:17 <Cale> er, an action
13:06:27 <eric_8th_Light_> I have to kill all of you and format the servers.
13:06:27 <Deewiant> if you make your AI such that it tries to force your opponent to win, you can probably get quite low
13:06:30 <b_jonas> I'll try to implement a tictactoe now
13:06:33 <eric_8th_Light_> How do I write that in Haskell :)
13:06:34 <dmwit> dblazakis: (I may still be misunderstanding you. =P)
13:06:51 <Deewiant> but of course, there's the matter of code complexity
13:06:54 <dmwit> eric_8th_Light_: Just don't mention what company you're at.
13:06:55 <Cale> @faq Can haskell kill us all and format the servers?
13:06:55 <lambdabot> The answer is: Yes! Haskell can do that.
13:07:02 <b_jonas> heh
13:07:07 <b_jonas> kill _us_ too?
13:07:11 <b_jonas> I'm affraid now
13:07:15 <Deewiant> overall the optimal solution is probably an Int and looking at values modulo 3 :-P
13:07:21 <dblazakis> hrm, i used -main-is DPLL.main
13:07:27 <bd_> I suppose that could be considered one form of the bottom.
13:07:30 <Twey> eric_8th_Light_: import magic; main = killAll . regulars $ ircChannel "#haskell"
13:07:33 <dblazakis> and i get a link error for Main_main_closure
13:07:34 <eric_8th_Light_> killall [] = []
13:07:51 <Twey> >> formatHaskellServers
13:08:08 <eric_8th_Light_> killall (x:xs) = [ kill x | x <- xs]
13:08:35 <mauke> that's equivalent to map kill . drop 1
13:08:50 <dmwit> killall = mapM_ kill
13:09:09 <dmwit> Unless you care about the results of the killing, and then you have to use mapM
13:09:51 <Twey> (using mapM is recommended for the sort of people who like to keep bits of their victims, disadvantage: increased evidence against you)
13:09:53 <Cale> eric_8th_Light_: I might use a  Map (Int,Int) Bool to represent the board, btw. (empty positions are represented by leaving them out of the Map
13:09:55 <Cale> )
13:10:07 <BMeph> @seen heisenbug
13:10:07 <lambdabot> Last time I saw heisenbug was when I left ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-hac07,
13:10:07 <lambdabot>  #haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr and #haskell.it 1m 5d 21h 28m 10s ago, and .
13:10:15 <Twey> Interesting, Cale
13:10:24 <b_jonas> well, there are so few positions that you could make the whole thing as static html, one for each position
13:10:24 <Twey> Not an array?
13:10:34 <dmwit> b_jonas: And that's been done.
13:10:36 <Twey> Heh
13:10:39 <b_jonas> dmwit: I guess so
13:10:42 <Cale> Well, an array makes things harder to work with, since you need 3 values.
13:10:44 <BMeph> ...okay, so he's been scarse for a white, got it. ;)
13:10:47 * Twey winces.
13:10:49 <b_jonas> dmwit: I did a labyrinth once
13:10:53 <BMeph> *scarce
13:10:59 <b_jonas> dmwit: with each place as a separate node in an info file
13:11:01 <BMeph> **while
13:11:09 <b_jonas> but that's not the best part
13:11:12 <mauke> preflex: seen heisenbug
13:11:12 <preflex>  heisenbug was last seen on #haskell 42 days, 1 hour, 58 minutes and 29 seconds ago, saying: dandy, thanks Heffalump!
13:11:19 <Cale> Though, a pair of Bool arrays might be handy.
13:11:42 <b_jonas> the nice part is how good random mazes it generates with a very simple algorithm
13:12:05 <Cale> (but wouldn't ensure consistency)
13:12:26 <dmwit> b_jonas: Oh, I was thinking of this: http://blog.beef.de/2008/01/16/html-game/
13:12:28 <lambdabot> Title: A Game in plain HTML (no JavaScript, no Flash, no PHP) : Shift Happens
13:12:30 <dmwit> (Not quite tic-tac-toe.)
13:12:55 <adu> whaty?
13:13:08 <Cale> Heh, an array of Maybe Bool is another possibility :)
13:13:23 <b_jonas> ah, lights out
13:13:24 <b_jonas> nice
13:13:29 <Cale> (but if you're going for efficiency, wouldn't do as well as two UArrays of Bool)
13:13:50 <dmwit> b_jonas: You programmed in info.  That might be even nerdier than this HTML thing.
13:14:04 <b_jonas> why maybe bool? isn't an Ordering better?
13:14:16 <b_jonas> dmwit: might be, yes
13:14:23 <Cale> Well, Maybe Bool has nicer operations than Ordering
13:14:35 <Cale> hmm...
13:14:50 <Cale> I suppose mappend for Ordering does basically what we want. :)
13:15:04 <Cale> So yeah, you could go with that.
13:15:18 <Cale> > LT `mappend` GT
13:15:19 <lambdabot>   LT
13:15:24 <Cale> > GT `mappend` LT
13:15:26 <lambdabot>   GT
13:15:29 <Cale> > EQ `mappend` LT
13:15:30 <lambdabot>   LT
13:15:47 <b_jonas> ordering is a MonadPlus?
13:15:55 <mauke> unlikely
13:15:56 <dmwit> Monoid.
13:15:57 <Cale> No, Monoid
13:16:02 <b_jonas> oh, that, yeah
13:16:04 <b_jonas> makes more sense
13:16:07 <dmwit> Ordering doesn't have the right kind to be a MonadPlus.
13:16:12 <Cale> Monoid is awesome. :)
13:16:34 <mauke> mappend++
13:16:37 <dmwit> > succ `mappend` succ $ 32
13:16:38 <lambdabot>   Add a type signature
13:16:41 <dmwit> > succ `mappend` succ $ 32 :: Int
13:16:43 <lambdabot>       No instance for (Monoid Int)
13:16:43 <lambdabot>        arising from a use of `mappend' at ...
13:16:47 <Cale> It just sucks that mappend has such a stupid name rather than being (++)
13:16:48 <b_jonas> don't forget it's also an Ord
13:16:49 <dmwit> eh?
13:16:56 <dmwit> oh
13:17:01 <dmwit> > (succ `mappend` succ) 32
13:17:02 <lambdabot>   Add a type signature
13:17:05 <dmwit> > (succ `mappend` succ) 32 :: Int
13:17:06 <lambdabot>       No instance for (Monoid Int)
13:17:06 <lambdabot>        arising from a use of `mappend' at ...
13:17:12 <dolio> > appEndo (Endo succ `mappend` Endo succ) 32
13:17:14 <lambdabot>   34
13:17:20 <b_jonas> define an alias then
13:17:23 <dmwit> Oh, that sucks.
13:17:33 <rwbarton> That's Haskell 98 for you
13:17:33 <Cale> The default is the lifting instance.
13:17:41 <Cale> (for functions)
13:17:49 <dmwit> ah
13:17:58 <dmwit> Okay, yeah, that makes sense.
13:18:04 <dons> btw, people with time, pick one or two benchmarks here to parallelise, http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=ghc
13:18:09 <lambdabot> Title: Haskell GHC benchmarks | x64 Ubuntu : Intel® Q6600® quad-core Computer Languag ..., http://tinyurl.com/4qs7kc
13:18:09 <dons> we only need one a week to keep ahead.
13:18:25 <Cale> > (id `mappend` reverse) "hello"
13:18:27 <lambdabot>   "helloolleh"
13:18:59 <Cale> > sortBy (length `mappend` compare) (words "here is a bunch of words")
13:19:01 <lambdabot>   Couldn't match expected type `Int'
13:19:10 <Cale> > sortBy (comparing length `mappend` compare) (words "here is a bunch of words")
13:19:11 <lambdabot>   ["a","is","of","here","bunch","words"]
13:19:39 <mauke> sort { length $a <=> length $b || $a cmp $b } qw(here is a bunch of words)
13:20:16 <Cale> If only `mappend` could be written ++
13:20:28 <b_jonas> define it locally
13:20:28 <b_jonas> really
13:20:39 <dolio> We used to.
13:20:41 <Cale> (It used to be able to, in the bot, but hint doesn't allow for importing anything but entire modules.
13:20:44 <Cale> )
13:20:48 <lightstep> why does ghc say "unsupported extension: XPatternSignatures" if i put it in a language pragma?
13:20:49 <dolio> It caused lots of complaining, mostly. :)
13:21:01 <mauke> lightstep: remove X
13:21:05 <Cale> Well, lots of people liked it, but there were also lots of complainers :)
13:21:06 <b_jonas> @define (++) = mappend
13:21:13 <b_jonas> @let (++) = mappend
13:21:14 <lambdabot>  <local>:1:7:
13:21:14 <lambdabot>      Ambiguous type variable `a' in the constraint:
13:21:14 <lambdabot>        `Mon...
13:21:16 <dolio> No vision. :)
13:21:21 <lightstep> mauke, 10x
13:21:31 <Cale> Yeah. Does anyone want to fork base?
13:21:33 <mauke> no, just one
13:21:40 <b_jonas> @let (<>) = mappend
13:21:41 <lambdabot>  <local>:1:7:
13:21:41 <lambdabot>      Ambiguous type variable `a' in the constraint:
13:21:41 <lambdabot>        `Mon...
13:21:48 <b_jonas> what on earth is that?
13:21:49 <Cale> @undefine
13:21:56 <Cale> @let (<>) = mappend
13:21:57 <BMeph> > (succ `mappend` succ) 32 :: Sum Int
13:21:57 <lambdabot>  <local>:1:7:
13:21:57 <lambdabot>      Ambiguous type variable `a' in the constraint:
13:21:57 <lambdabot>        `Mon...
13:21:58 <lambdabot>       No instance for (Enum (Sum Int))
13:21:58 <lambdabot>        arising from a use of `succ' at...
13:22:02 <dolio> Someone figured out you can have GHC introduce MonadFail/Zero constraints with the right class hierarchy.
13:22:03 <Cale> oh, stupid MR
13:22:14 <dolio> So, we should get to it.
13:22:16 <Cale> @let x <> y = mappend x y
13:22:17 <lambdabot>  Defined.
13:22:28 <b_jonas> ah yeah, makes sense
13:22:30 <Cale> > sortBy (comparing length <> compare) (words "here is a bunch of words")
13:22:30 <lambdabot>       Ambiguous occurrence `<>'
13:22:30 <lambdabot>      It could refer to either `L.<>', defined...
13:22:33 <Cale> ...
13:22:34 <dolio> It even recognizes (a,b,c) <- m as unfailable and doesn't require fail.
13:22:39 <Cale> sigh
13:22:46 <dolio> Anyhow...
13:22:47 <Cale> @undef
13:22:53 <Deewiant> text.prettyprint.hughespj.<>
13:22:56 * dolio runs out.
13:22:57 <Cale> right
13:22:58 <Deewiant> is the other one
13:23:09 <Cale> We don't need that module, do we?
13:23:13 <b_jonas> some other symbol?
13:23:22 <Deewiant> it was used just a few days ago IIRC :-)
13:23:37 <Cale> Really? It doesn't seem like it would be particularly usable from the bot.
13:24:09 <Deewiant> Somebody showed someone else how to get block-padded text or something like that
13:24:20 <Deewiant> of course the line length had to be set to 10 or so so that you could see the line breaks
13:24:44 <Cale> ah, okay
13:24:49 <Cale> I suppose it can stay.
13:24:54 <Trinithis> @ty L.<>
13:24:55 <lambdabot> parse error on input `L.<>'
13:25:14 <Trinithis> @ty (L.<>)
13:25:14 <Cale> :t mappend
13:25:15 <lambdabot> Not in scope: `L.<>'
13:25:16 <lambdabot> forall a. (Monoid a) => a -> a -> a
13:25:22 <Cale> (I undefined)
13:25:25 <Trinithis> oh
13:25:33 <sbahra> Monoid?
13:25:35 <Cale> yeah
13:25:39 <sbahra> What is a Monoid?
13:25:46 <Deewiant> ?src Monoid
13:25:47 <lambdabot> class Monoid a where
13:25:47 <lambdabot>     mempty  :: a
13:25:47 <lambdabot>     mappend :: a -> a -> a
13:25:47 <lambdabot>     mconcat :: [a] -> a
13:25:56 <Cale> A set (or type) with an associative operation that has an identity.
13:25:59 <opqdonut> sbahra: a monoid is an associative binary operator
13:26:01 <humasect> src/Data/Bijection.hs:52:11: `>>>' is not a (visible) method of class `Arrow'     -- ahh what should i do?
13:26:04 <opqdonut> with identity, yes
13:26:08 <Trinithis> associative binary operator that is closed with an identity ely
13:26:24 <Cale> operator => closed  in my books ;)
13:26:25 <sandbox> trying to build darcs ghc with ndp support.  While building ndp I get 'no package matching dph-par was found', should I be building dph?
13:26:42 <sandbox> I found some mailing list info about the ndp package being heavily changed
13:26:46 <BMeph> instance (MonadPlus m) => forall a. (Monoid m a) -- If it could be written this way, this would be it, right? :)
13:27:05 <Deewiant> humasect: (>>>) = flip (.)
13:27:06 <Cale> BMeph: maybe...
13:27:11 <Trinithis> so for example, list' {++, []} or function's {. , id}
13:27:33 * humasect checks to see if Control.Arrow is changed in base4
13:27:42 <Deewiant> humasect: so, fix it to mess with Category.. instead of Arrow.>>>
13:27:46 <Deewiant> and yes, it is changed
13:27:51 <humasect> ahh
13:28:00 <Cale> BMeph: actually sometimes the Monoid instance doesn't agree with the MonadPlus one...
13:28:05 <humasect> ok i will link this to base3 (it is TypeCompose)
13:28:07 <Cale> BMeph: For instance, in the case of Maybe
13:28:35 <Cale> BMeph: The instance for Maybe is the lifting one, that is  instance Monoid a => Monoid (Maybe a) where ...
13:29:12 <Cale> (and we use wrappers First and Last for the other obvious ones -- First is the same as the MonadPlus monoid)
13:29:28 <b_jonas> BMeph: I'm not sure, those kind of broad class inferrings always cause problems
13:30:21 <Cale> Monoids are fundamental to computer science, but I think perhaps a little underappreciated.
13:30:53 <mauke> ooh, inspiration
13:31:08 <mauke> new paper title: "monoids on steroids"
13:31:14 <b_jonas> > mappend (First Nothing) (First Just 2)
13:31:15 <lambdabot>   Couldn't match expected type `Maybe a'
13:31:15 <ziman> guys, any ideas why this program uses only a single CPU http://hpaste.org/10895 ? (when given -N3 and there *are* those processes in top)
13:31:28 <ddarius> Cale: It's more that the general abstract pattern isn't recognized.
13:31:35 <humasect> ziman: -threaded ?
13:31:47 <ziman> -threaded is there
13:31:53 <ziman> (and the threads, too)
13:32:00 <humasect> ah, right. i'm not very smart
13:32:03 <b_jonas> > mappend (Data.Monoid.First Nothing) (Data.Monoid.First Just 2)
13:32:04 <lambdabot>   Couldn't match expected type `Maybe a'
13:32:32 <ziman> i guess there is some data dependency which causes the computation to be performed in sequence
13:32:59 <Trinithis> why is haskell soo cool?
13:33:14 <sbahra> Trinithis, hype.
13:33:47 <Cale> Trinithis: because it lies in the intersection of research languages and practical languages
13:33:54 <Trinithis> hell, for my scheme class, I made haskell-esqe currying just so I could do beautiful pointfree code
13:34:06 * sbahra gawks at scheme
13:34:09 <Cale> And I think practical uses are starting to threaten research uses, which makes me unhappy.
13:34:17 <Trinithis> lol
13:35:04 <humasect> package base-3.0.3.0 requires base-4.0.0.0   *falls over*
13:35:09 <humasect> sorry guys
13:35:17 <Cale> whaa?
13:35:40 <ddarius> I believe it is the compiler that requires it.
13:36:36 <b_jonas> oh, I'm a fool
13:36:40 <b_jonas> > mappend (Data.Monoid.First Nothing) (Data.Monoid.First $ Just 2)
13:36:41 <lambdabot>   First {getFirst = Just 2}
13:36:42 <humasect> it is picking up Control.Arrow from base4 still i think, so i will wait and learn some FRP
13:36:58 <humasect> ?instances Monoid
13:36:58 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
13:37:00 <b_jonas> @src Monoid First
13:37:00 <lambdabot> Source not found. There are some things that I just don't know.
13:37:06 <b_jonas> @src Monoid mappend
13:37:06 <lambdabot> Source not found. Just what do you think you're doing Dave?
13:37:12 <b_jonas> @src Monoid mconcat
13:37:13 <lambdabot> Source not found. Do you think like you type?
13:37:17 <humasect> @src mappend First
13:37:17 <lambdabot> Source not found. There are some things that I just don't know.
13:37:23 <b_jonas> @src First mconcat
13:37:24 <lambdabot> Source not found. Sorry.
13:37:26 <b_jonas> @src First mappend
13:37:27 <lambdabot> Source not found. The more you drive -- the dumber you get.
13:38:19 <BMeph> I thought we were trimming down the base, in preps for the whole HP thing...?
13:38:45 <humasect> yep. there is syb which is also picked up in this case
13:39:38 <jstanley> so I've a function parseInt :: String -> Int that uses reads and matches on the result. I can do parseInt "16352" and it works correctly. However, if I do a map (parseInt . show) rec (where rec :: [Text.CSV.ByteString.Field]), the parsing fails on the same data. What's happening?
13:40:18 <Trinithis> > read "123"
13:40:19 <lambdabot>   * Exception: Prelude.read: no parse
13:40:28 <Trinithis> > read "123" :: Int
13:40:29 <lambdabot>   123
13:40:34 <lightstep> jstanley, what does map show rec return?
13:40:41 <jstanley> reads "123" :: [(Int,String)]
13:40:44 <jstanley> > reads "123" :: [(Int,String)]
13:40:44 <lightstep> ["16352"]?
13:40:45 <lambdabot>   [(123,"")]
13:40:52 <mauke> > read (show "123") :: Int
13:40:53 <lambdabot>   * Exception: Prelude.read: no parse
13:41:03 <jstanley> lightstep: what do you mean?
13:41:12 <humasect> :i (::)
13:41:39 <rwbarton> jstanley: Well, check what  map show rec  produces, and that it's consistent with what you expect?
13:41:40 <lightstep> jstanley, are you sure parseInt is called with "16352"? can you check what the argument is?
13:42:08 <jstanley> lightstep: Sure. So in the error match case I print out the input string using error.
13:42:28 <jstanley> *** Exception: Contents: [], input str = "16532"
13:42:31 <jstanley> so reads is returning []
13:42:49 <mauke> what does the call to error look like?
13:42:51 <jstanley> (from -> error $ "Contents: " ++ show q ++ ", input str = " ++ s)
13:43:00 <mauke> you win this round
13:43:02 <jstanley> where q is just the left hand side of the pattern match
13:43:32 <plutonas> who can explain me that: *Main> (length.maximum) [[1..10], [50..55]]
13:43:32 <plutonas> 6
13:43:50 <lightstep> jstanley, this means that s is actualy the 7-char string "\"16352\""
13:43:55 <rwbarton> plutonas: 50 > 1, so [50..55] > [1..10]
13:44:04 <mauke> > maximum [[1..10], [50..55]]
13:44:06 <lambdabot>   [50,51,52,53,54,55]
13:44:07 <jstanley> lightstep: ugh, duh. the quotes were included in the string contents.
13:44:20 <jstanley> lightstep: so presumably the show instance for rec is doing that?
13:44:23 <plutonas> rwbarton: oh
13:44:30 <lightstep> jstanley, probably
13:44:43 <lightstep> jstanley, but i don't know this library at all
13:44:50 <plutonas> jstanley: how would i get the maximum length?
13:44:54 <plutonas> sorry meant rwbarton
13:45:07 <rwbarton> > maximum (map length [[1..10], [50..55]])
13:45:08 <lambdabot>   10
13:45:18 <mauke> :t maximumBy
13:45:19 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
13:46:00 <rwbarton> or (maximum . map length) [...]
13:46:07 <jstanley> lightstep: yeah, that's exactly, it, doing reads (drop 1 . init $ s) gets me what i want.
13:46:08 <jstanley> Thanks.
13:46:08 <lightstep> ?hoogle Double -> Int16
13:46:08 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
13:46:08 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
13:46:08 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
13:46:10 <plutonas> thanks
13:46:15 <mauke> jstanley: ouch
13:46:22 <mauke> that's evil
13:46:24 <rwbarton> jstanley: bad idea
13:46:34 <jstanley> heh, yeah, i know, it was just a test.
13:46:35 <rwbarton> jstanley: Just don't call show, there must be a Field -> String method
13:46:49 <jstanley> there isn't as far as i know, but i can look.
13:47:19 <jstanley> type Field = Data.ByteString.Internal.ByteString :(
13:47:26 <rwbarton> 'unpack' then
13:47:36 <jstanley> ah, ok -- i haven't used the bytestring library before.
13:47:40 <BMeph> unpack FTW!
13:47:53 <rwbarton> or... use the csv package, not the bytestring-csv package, if you don't want ByteStrings :)
13:48:01 <jstanley> rwbarton: :)
13:48:04 <dons> jstanley: what are you trying to do?
13:48:22 <dons> csv parsing?
13:48:26 <jstanley> dons: just use ByteString, wanted to dump some stuff.
13:48:28 <jstanley> dons: yar.
13:48:38 <dons> using the csv package for bytestrings? or by hand?
13:48:43 <jstanley> dons: I've got it now. Using your package ;P
13:48:47 <dons> avoid using unpack if at all possible - it kills performance.
13:48:55 <dons> if that matters.
13:49:10 <mauke> how bad is it if the strings are < 300 chars in length?
13:49:17 <newsham> http://www.thenewsh.com/~newsham/x/machine/TicTacToe.hs
13:49:19 <dons> probably not an issue.
13:49:23 <jstanley> dons: Yeah, I was looking at the bytestring lexer for doubles (in a separate package) -- I want something the same for integer.
13:49:33 <dons> jstanley: oh, use readInteger in the bytestring package.
13:49:41 <dons> readInt and readInteger ship with bytestring.
13:49:50 <jstanley> dons: *headdesk*
13:49:52 <jstanley> dons: thanks ;)
13:49:52 <dons> other small parsers i'm adding to the bytestring-lexer package and yet others in Data.Binary
13:50:07 <dons> :t readInteger
13:50:08 <lambdabot> Not in scope: `readInteger'
13:50:14 <dons> :t Data.ByteString.readInteger
13:50:15 <lambdabot> Not in scope: `Data.ByteString.readInteger'
13:50:19 <dons> :t Data.ByteString.Char8.readInteger
13:50:20 <lambdabot> BSC.ByteString -> Maybe (Integer, BSC.ByteString)
13:50:27 <mauke> too bad you can't derive ReadByteString
13:50:43 <jstanley> dons: Yeah, that's what I was looking for -- didn't peek in the Char8 package :)
13:50:46 <jstanley> thanks all.
13:50:53 <dons> ok.
13:51:06 <newsham> b_jonas: wrote it.
13:51:07 <dons> mauke: derive Binary
13:51:08 <dons> ?
13:51:35 <mauke> not binary, Char8 based
13:52:24 <birkenfeld> @pl \cs -> any (`elem` cs)
13:52:24 <lambdabot> any . flip elem
13:56:07 <Baughn> @ask quicksilver Could I have a copy of your shapr-script? (Just dcc it over)
13:56:08 <lambdabot> Consider it noted.
14:01:24 <b_jonas> newsham: where?
14:01:34 <b_jonas> oh, gave url above
14:01:52 <newsham> in retrospect, probably dont need to zip the magic indices in until evaluating if someone won
14:01:58 <newsham> just extra data thats constantly being copied around
14:03:17 <b_jonas> I'm being dumb now
14:03:38 <b_jonas> what's wrong with this definition:
14:03:55 <plutonas> is fn _ []
14:03:58 <plutonas> sorry
14:04:08 <b_jonas> http://erxz.com/pb/12540
14:04:09 <lambdabot> Title: freenode_web paste from "b_jonas" at 71.6.194.243...
14:04:34 <mauke> [a] is not a type variable
14:04:44 <b_jonas> but what type should this have then?
14:04:46 <newsham> there, i updated the code to not zip the board with the magic until seeing if its solved
14:05:00 <plutonas> is fn _ [] = []; fn [] _ = [] written simpler like fn _ _ = [] ?
14:05:07 <plutonas> or do i miss some cases this way?
14:05:20 <newsham> did you mean  (x:s) <- get    ?
14:05:35 <b_jonas> oh, it's missing the arguments
14:05:47 <b_jonas> no wait it's not
14:05:48 <plutonas> (i think i don't miss anything this way, but wanted to be sure
14:05:51 <b_jonas> newsham: yes
14:06:01 <rwbarton> b_jonas: there's nothing wrong with it.  You just need to turn on a language extension (probably your code is not legal in Haskell 98)
14:06:11 <newsham> > runState (do { (x:s) <- get; put s; return x }) "testing"
14:06:12 <lambdabot>   ('t',"esting")
14:06:15 <nomeata> Hi. My code handles differnt kind of “objects”, represented by a haskell type. Each has an Integer id, and an instance class Containable v where key :: v -> Key
14:06:15 <lambdabot> nomeata: You have 1 new message. '/msg lambdabot @messages' to read it.
14:06:27 <b_jonas> rwbarton: but can you not even define such a function without that extension?
14:06:34 <b_jonas> rwbarton: in some other way?
14:06:45 <b_jonas> I'll turn on glasgowexts then
14:06:58 <mauke> b_jonas: why not just flexible contexts?
14:07:07 <nomeata> I’d like to have some functions, that only need the id, to accept both the id or a full object as a parameter
14:07:15 <newsham> > runState (do { x:s <- get; put s; return x }) "testing"
14:07:16 <lambdabot>   ('t',"esting")
14:07:30 <nomeata> I tried to implement this with "class Identification for v where id :: v -> Key" and these instances:
14:07:38 <nomeata> instance (Containable v) => Identification v Key where id v = v
14:07:39 <nomeata> instance (Containable v) => Identification v v where id v = key v
14:07:43 <b_jonas> mauke: I don't want to use an extenson if I don't know what it does
14:07:58 <b_jonas> mauke: eg, I won't just turn on undecidable instances or recursive types if I don't know what it is
14:08:03 <mauke> b_jonas: er. so what does -fglasgow-exts do?
14:08:09 <dons> http://www.reddit.com/r/programming/comments/759pc/general_recursion_using_coinductive_monad_done/
14:08:11 <b_jonas> mauke: because it might cause misterious problems with the rest of the code
14:08:11 <lambdabot> Title: “General Recursion using Coinductive Monad” Done Right : programming, http://tinyurl.com/3st8sp
14:08:19 <nomeata> but trying to use that in a function with this signature: userLink :: (C.Identification User v) => v -> HotLink
14:08:29 <rwbarton> b_jonas: I think in Haskell 98 you can write the function but you can't give it a type signature...
14:08:36 <nomeata> gives me this error: Could not deduce (C.Identification for v) from the context (C.Identification User v) arising from a use of `C.id' at HTML.hs:82:31-36
14:08:37 <nomeata> Any hints?
14:08:59 <rwbarton> Anyways, there are no multiparameter type classes in Haskell 98 anyways :)
14:10:11 <nomeata> (BTW, type Key Integer holds here)
14:11:09 <nomeata> “type Key = Integer” that is
14:12:47 <b_jonas> the definition does work with -fglasgow-exts
14:12:53 <b_jonas> rwbarton: hmm, that would be strange
14:13:10 <mauke> b_jonas: yes, because -fglasgow-exts enables all kinds of unspecified extensions
14:13:13 <b_jonas> rwbarton: makes sense
14:13:28 <mauke> b_jonas: while -XFlexibleContexts just enables itself
14:13:46 <mauke> so I don't understand why you prefer -fglasgow-exts
14:14:13 <b_jonas> mauke: I can change it then
14:14:29 <mauke> change what?
14:14:37 <b_jonas> change to just -XFlexibleContexts
14:15:51 <adu> is ski here?
14:16:08 <b_jonas> why is that option not even in http://www.haskell.org/ghc/docs/latest/html/users_guide/ix01.html ?
14:16:11 <lambdabot> Title: Index
14:16:47 <mauke> good question
14:17:04 <rwbarton> b_jonas: to get a definitive list, run  ghc --supported-languages
14:17:10 <mauke> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html#options-language
14:17:11 <lambdabot> Title: Chapter�8.�GHC Language Features, http://tinyurl.com/kf2g3
14:17:19 <Deewiant> very few of the -X features are documented
14:17:38 <Deewiant> the definitive list is at http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Language-Haskell-Extension.html
14:17:39 <lambdabot> Title: Language.Haskell.Extension, http://tinyurl.com/2xjyqs
14:18:10 * rwbarton thinks ghc --supported-languages is even more definitive :)
14:18:31 <Deewiant> except that that's not online :-p
14:18:35 <b_jonas> it must be this one: http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#type-restrictions
14:18:37 <lambdabot> Title: 8.7.�Other type system extensions, http://tinyurl.com/3c7ura
14:24:26 <rwbarton> nomeata: it looks like you're essentially trying to emulate overlapping instances, so I'm not surprised you're running into trouble
14:24:43 <rwbarton> nomeata: Maybe you can make Identification a superclass of Containable though
14:25:07 <nomeata> rwbarton: but the Key itself is not Containable
14:25:08 <b_jonas> > evalState get "hello"
14:25:09 <lambdabot>   "hello"
14:25:23 * nomeata works around it using a Proxy parameter in the Identification class, seems to work well so far
14:25:26 <b_jonas> what type is get in that case?
14:25:37 <b_jonas> isn't that ambiguous?
14:25:56 <b_jonas> oh, I see
14:26:01 <b_jonas> evalState forces it
14:26:01 <b_jonas> sorry
14:27:31 <rwbarton> nomeata: Right.  So have a separate instance Identification Key
14:28:34 <rwbarton> Well, maybe I don't understand the relationship between id, key, and Key
14:28:58 <b_jonas> wow
14:29:11 <b_jonas> I wrote such complicated monadic code for a simple list operation
14:29:14 <b_jonas> I can't even believe
14:30:18 <b_jonas> > let { popState :: (MonadState [a] m) => m a; popState = do { (x : s) <- get; put s; return x; }; replaceSequentially :: (a -> Bool) -> [a] -> [a] -> [a]; replaceSequentially f q s = evalState (mapM (\x -> if f x then popState else return x) s) q; } in replaceSequentially '@' "xyz" "a@bc@d@"
14:30:19 <lambdabot>   Couldn't match expected type `a -> Bool'
14:30:27 <b_jonas> > let { popState :: (MonadState [a] m) => m a; popState = do { (x : s) <- get; put s; return x; }; replaceSequentially :: (a -> Bool) -> [a] -> [a] -> [a]; replaceSequentially f q s = evalState (mapM (\x -> if f x then popState else return x) s) q; } in replaceSequentially ('@' ==) "xyz" "a@bc@d@"
14:30:29 <lambdabot>   "axbcydz"
14:31:29 <b_jonas> is this condition particular to haskell beginners or will it get worse if I learn haskell properly?
14:32:14 <vixey> b_jonas: How should you have written it?
14:32:28 <pyNem> how do i calculate the floor of a square root of a number? i.e. type cast sqrt(n) to Int
14:33:01 <bd_> :t floor
14:33:02 <lambdabot> forall a b. (Integral b, RealFrac a) => a -> b
14:33:05 <bd_> :t floor . sqrt
14:33:06 <lambdabot> forall b a. (Floating a, Integral b, RealFrac a) => a -> b
14:33:18 <bd_> > floor . sqrt $ 16
14:33:20 <lambdabot>   4
14:34:14 <b_jonas> vixey: probably there's like two or three list functions which makes it simple
14:34:14 <lightstep> > let replaceSequentially pred repl = concatMap (\x -> if pred x then repl else [x]) in replaceSequentially ('@' ==) "xyz" "a@bc@d@"
14:34:15 <lambdabot>   "axyzbcxyzdxyz"
14:34:19 <ddarius> b_jonas: Avoiding the need for monads and knowing when they are needed is a facility that will develop.
14:34:35 <vixey> b_jonas: I doubt it
14:34:52 <vixey> b_jonas: I actually think your code was completely fine
14:35:04 <b_jonas> lightstep: not really, sorry
14:35:15 <rwbarton> b_jonas: Your code is totally reasonable.  So is a direct recursive implementation
14:35:30 <ddarius> Direct recursive would be the simplest and most obvious thing to do.
14:35:48 <b_jonas> @hoogle a -> [a] -> [[a]]
14:35:49 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
14:35:49 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
14:35:49 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
14:36:02 <b_jonas> @hoogle (a -> Bool) -> [a] -> [[a]]
14:36:03 <lambdabot> Distribution.Simple.Utils breaks :: (a -> Bool) -> [a] -> [[a]]
14:36:03 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
14:36:03 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
14:36:08 <lightstep> > let replaceSequentially p (r:rs) (x:xs) | p x = r : replaceSequentially p rs xs ; replaceSequentially p rs (x:xs) = replaceSequentially p rs xs in replaceSequentially ('@' ==) "xyz" "a@bc@d@"
14:36:08 <vixey> b_jonas: the problem is (if your me..) you see this 'replaceSequentially' thing as one program in a whole language of stateful string search and replace problems.. then you design and implement that language.. then 20 years later wonder what problem you were trying to solve in the first place
14:36:09 <lambdabot>   "xyz* Exception: /tmp/6727468316452899084:68:36-174: Non-exhaustive pattern...
14:36:35 <lightstep> > let replaceSequentially _ _ [] = [] ; replaceSequentially p (r:rs) (x:xs) | p x = r : replaceSequentially p rs xs ; replaceSequentially p rs (x:xs) = replaceSequentially p rs xs in replaceSequentially ('@' ==) "xyz" "a@bc@d@"
14:36:36 <lambdabot>   "xyz"
14:36:46 * lightstep gives up
14:37:06 <rwbarton> > let replaceSequentially p _ [] = []; replaceSequentially p r (t:ts) = if p t then head r : replaceSequentially p (tail r) ts else t : replaceSequentially p r ts in replaceSequentially ('@'==) "xyz" "a@b@c@"
14:37:07 <lambdabot>   "axbycz"
14:37:20 <dmwit> :t splitAt
14:37:21 <lambdabot> forall a. Int -> [a] -> ([a], [a])
14:37:29 <dmwit> :t break
14:37:31 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
14:37:40 <dmwit> > break (=='@') "a@b@c@"
14:37:41 <lambdabot>   ("a","@b@c@")
14:37:50 <b_jonas> vixey: actually I'd like a monad that's like state but only has popState (and a way to detect end of list) not get and put in general
14:38:10 <ddarius> > let replaceSequentially p ns [] = []; replaceSequentially p ns@(n:ns') (c:cs) | p c = n:replaceSequentially p ns' cs | otherwise = c:replaceSequentially p ns cs in replaceSequentially ('@'==) "xyz" "a@bc@d@"
14:38:11 <lambdabot>   "axbcydz"
14:38:45 <rwbarton> b_jonas: you can write  newtype Pop a b = Pop { runPop :: State [a] b }  in a module and export only what you want to
14:38:49 <vixey> b_jonas: http://code.google.com/p/rascal-haskell/source/browse/trunk/Gensym.hs?r=2
14:38:51 <lambdabot> Title: rascal-haskell - Google Code, http://tinyurl.com/4v3z6r
14:38:54 <b_jonas> it says Distribution.Simple.Utils breaks
14:39:00 <b_jonas> I wonder what that is, it's not documented
14:39:58 <b_jonas> rwbarton: the monad itself is simple to implement but the monad transformer is more complicated of course
14:40:14 <vixey> why don't you use State directly?
14:40:23 <b_jonas> vixey: ah, nice
14:40:33 <ddarius> > let replaceSequentially p (n:ns) cs = case break p of (rs,[]) -> rs; (rs,_:cs') -> rs++n:replaceSequentially p ns cs' in replaceSequentially ('@'==) "xyz" "a@bc@d@"
14:40:34 <lambdabot>   Couldn't match expected type `[a] -> ([a], [a])'
14:40:43 <b_jonas> vixey: there's a Writer too
14:40:45 <ddarius> > let replaceSequentially p (n:ns) cs = case break p cs of (rs,[]) -> rs; (rs,_:cs') -> rs++n:replaceSequentially p ns cs' in replaceSequentially ('@'==) "xyz" "a@bc@d@"
14:40:46 <lambdabot>   "axbcydz* Exception: /tmp/7585893090008926070:68:36-151: Non-exhaustive pat...
14:40:55 <b_jonas> vixey: I think of this as a sort of dual for Writer
14:41:23 <ddarius> > let replaceSequentially p ~(n:ns) cs = case break p cs of (rs,[]) -> rs; (rs,_:cs') -> rs++n:replaceSequentially p ns cs' in replaceSequentially ('@'==) "xyz" "a@bc@d@"
14:41:24 <lambdabot>   "axbcydz"
14:41:27 <ddarius> tada
14:42:41 <lispy> I rarely use ~
14:42:51 <ddarius> lispy: ~ is rarely necessary
14:43:08 <lispy> why was it useful here?
14:43:09 <rwbarton> ddarius: Your previous recursive definition had a ~ issue too, if the second string doesn't end with '@'
14:43:28 <ddarius> > let replaceSequentially p ~(n:ns) cs = case break p cs of (rs,[]) -> rs; (rs,_:cs') -> rs++n:replaceSequentially p ns cs' in replaceSequentially ('@'==) "xyz" "a@bc@d@e"
14:43:30 <lambdabot>   "axbcydze"
14:43:42 <rwbarton> The one that didn't use break
14:43:51 <lispy> I mean, I see that it fixes an exception, but I don't understand it yet
14:44:04 <lispy> rwbarton: no one replied to my email about Sealed reordering :(
14:44:19 <ddarius> lispy: Because it was pattern matching the ns list even when it wasn't being used in the base case recursive call.
14:45:10 <lispy> ddarius: oh, so you could have just written a separate case for that?
14:45:44 <rwbarton> foo ~(n:ns) ... = ... is just like foo x ... = let n = head x; ns = tail x in ...
14:45:59 <lispy> yeah, I think I'm seeing that
14:46:16 <lispy> that is handy, I bet I'll start seeing uses for it
14:47:08 <b_jonas> ah, I see why you need the tilde
14:50:03 <b_jonas> actually
14:50:13 <b_jonas> when I said a list function, I thought of something like this
14:50:22 <b_jonas> > let { splitSingle :: (a -> Bool) -> [a] -> [[a]]; splitSingle f s = case break f s of { (sp, []) -> [sp]; (sp, _ : sr) -> sp : splitSingle f sr; }; } in splitSingle ('@'==) "a@bc@d@"
14:50:23 <lambdabot>   ["a","bc","d",""]
14:50:31 <nomeata> Ok, using a Proxy parameter, and using Template Haskell to generate the prime variante of the id getter, I’m satisfied:
14:50:46 <ddarius> > let replaceSequentially p ~(n:ns) = uncurry (++) . second (\cs -> if null cs then [] else n:replaceSequentially p ns cs) . break p in replaceSequentially ('@'==) "xyz" "a@bc@d@"
14:50:48 <lambdabot>   "axyz* Exception: /tmp/842187102805170890:68:36-161: Irrefutable pattern fa...
14:50:53 <nomeata> userId :: User -> UserId
14:50:57 <nomeata> userId' :: (Container.Identification User v) => v -> Container.Key
14:51:33 <ddarius> b_jonas: Yes.  Such a function has been suggested several times.
14:51:44 <b_jonas> ddarius: it's not really general or useful though
14:52:03 <b_jonas> rather we'd need something similar, but not that one
14:52:10 <ddarius> > let replaceSequentially p ~(n:ns) = uncurry (++) . second (\cs -> if null cs then [] else n:replaceSequentially p ns $ tail cs) . break p in replaceSequentially ('@'==) "xyz" "a@bc@d@"
14:52:10 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[t]'
14:52:30 <ddarius> > let replaceSequentially p ~(n:ns) = uncurry (++) . second (\cs -> if null cs then [] else n:replaceSequentially p ns (tail cs)) . break p in replaceSequentially ('@'==) "xyz" "a@bc@d@"
14:52:31 <lambdabot>   "axbcydz"
14:52:43 <adu> @seen ski
14:52:44 <lambdabot> ski is in #haskell, #haskell.hr, #haskell-overflow and ##logic. I last heard ski speak 1d 2h 44m 47s ago.
14:52:49 <ddarius> @pl \cs -> if null cs then [] else n:f (tail cs)
14:52:49 <lambdabot> ap (flip if' [] . null) ((n :) . f . tail)
14:52:55 <ddarius> @pl \cs -> if null cs then cs else n:f (tail cs)
14:52:55 <lambdabot> ap (if' =<< null) ((n :) . f . tail)
14:53:17 <adu> @src if'
14:53:17 <lambdabot> Source not found. Wrong!  You cheating scum!
14:53:25 <b_jonas> ddarius: is that still the makind it more readable state or the golfing state?
14:53:30 <adu> @type if'
14:53:31 <lambdabot> Not in scope: `if''
14:53:51 <lispy> adu: that's if' b t e = if b then t else e
14:54:01 <adu> lispy: oh
14:54:21 <adu> @pl \a b c -> if a then b else c
14:54:22 <lambdabot> if'
14:54:25 <adu> hehe
14:56:19 <ddarius> b_jonas: The point-free definition has a pretty picture of the structure...
14:56:40 <b_jonas> that if' and the [a] -> b -> (a -> [a] -> b) -> b function aren't in the standard libraries to stop overzelous pointfreeing, right?
14:57:02 <b_jonas> does pl have a name for the latter?
14:57:34 <b_jonas> @pl \s f g -> case x of { [] -> f; a : r -> g a r }
14:57:35 <lambdabot> (line 1, column 21):
14:57:35 <lambdabot> unexpected "{"
14:57:35 <lambdabot> expecting variable, "(", operator or end of input
14:57:57 <b_jonas> @type \s f g -> case x of { [] -> f; a : r -> g a r }
14:57:59 <lambdabot>     Couldn't match expected type `Expr' against inferred type `[a]'
14:57:59 <lambdabot>     In the pattern: []
14:57:59 <lambdabot>     In a case alternative: [] -> f
14:58:03 <ddarius> :t \n j -> maybe n j . listToMaybe
14:58:04 <lambdabot> forall b a. b -> (a -> b) -> [a] -> b
14:58:31 <b_jonas> Expr
14:58:35 <b_jonas> what on earth?
14:58:37 <lispy> Doesn't everyone define their own if'?
14:58:44 <lispy> :t a
14:58:46 <lambdabot> Expr
14:58:53 <lispy> Expr is a special lambdabot feature
14:59:03 <b_jonas> @type \s f g -> case s of { [] -> f; a : r -> g a r }
14:59:05 <lambdabot> forall t t1. [t1] -> t -> (t1 -> [t1] -> t) -> t
14:59:09 <b_jonas> oh yeah, it came in because of the x
14:59:11 <vixey> lispy: I prefer the name bool and the type a -> a -> Bool -> a
14:59:25 <b_jonas> @unpl \s f g -> case s of { [] -> f; a : r -> g a r }
14:59:26 <lambdabot> \ s f g -> case s of { [] -> f; a : r -> g a r}
14:59:49 <b_jonas> vixey: makes sense
15:00:09 <lispy> ?pl \a b c -> if c then a else b
15:00:09 <lambdabot> flip . flip if'
15:00:45 <rwbarton> @pl \a b c -> [c, b] !! (fromEnum a)
15:00:45 <lambdabot> flip (flip . ((!!) .) . flip (:) . return) . fromEnum
15:01:03 <lispy> :t flip flip flip
15:01:04 <lambdabot> forall a c a1 b c1. (a -> ((a1 -> b -> c1) -> b -> a1 -> c1) -> c) -> a -> c
15:01:16 <lispy> :t fix flip
15:01:17 <lambdabot> forall b c. b -> b -> c
15:02:08 <lispy> :t fix flip 1
15:02:09 <lambdabot> forall b c. (Num b) => b -> c
15:02:20 <lispy> :t fix flip 1 1
15:02:22 <lambdabot> forall c. c
15:02:25 <mmorrow> , let replaceSequentially p env tmpl = concat . zipWith (\var (x,k) -> x ++ k var) env $ (let go _ acc [] = if null acc then [] else [(reverse acc,const[])] ; go p acc (x:xs) = if (not . p) x then go p (x:acc) xs else (reverse acc,id) : go p [] xs in go) p [] tmpl in replaceSequentially (=='@') (map show [1,3,92]) "asd@@qwert@@@@@@@@@"
15:02:26 <lispy> weird
15:02:26 <lunabot>  "asd13qwert92"
15:02:29 <lispy> > fix flip 1 1
15:02:39 <mmorrow> that's a good one
15:02:44 <mmorrow> (replaceSequentially)
15:02:45 <lambdabot>   thread killed
15:03:07 * lispy is not a huge fan of "let go"
15:03:16 <lispy> why do we call the inner function go?
15:03:21 <lispy> Seems silly :)
15:03:52 <mmorrow> it's short so doesn't take up space, and if fairly pleasant to look at?
15:03:59 <mmorrow> s/if/is/
15:04:10 <lispy> if you want short you could use initials, rs in this case
15:04:11 * ddarius uses meOut
15:05:00 <vixey> I like  let φ  for folds
15:05:13 <dmwit> I like real names.
15:05:18 <lispy> > const . fix $ flip
15:05:20 <lambdabot>       Overlapping instances for Show (b -> b1 -> b1 -> c)
15:05:20 <lambdabot>        arising from...
15:05:30 <lispy> > fix . const $ flip
15:05:32 <lambdabot>       Overlapping instances for Show ((a -> b -> c) -> b -> a -> c)
15:05:32 <lambdabot>        ar...
15:05:38 <lispy> :t fix . const $ flip
15:05:40 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
15:06:28 <lispy> :t const . fix $ flip
15:06:30 <lambdabot> forall b b1 c. b -> b1 -> b1 -> c
15:07:33 <vixey> foldFoo inl inr branch spread squux flux = φ
15:07:33 <lightstep> is writeList2Chan strict in the list? and does it keep a pointer to the beginning after it's done?
15:07:40 <vixey>  where φ (Inl x) = inl x
15:07:42 <vixey>   ...
15:08:23 <lispy> I see a capital I with 2 dots overi t
15:09:06 <b_jonas> trying to understand that statement
15:11:57 <b_jonas> lispy: tell your irc client that the channel is in utf8 then
15:12:30 <lispy> b_jonas: actually, it's that I'm on windows.  If I were viewing from my mac I bet I'd see it
15:12:35 <lispy> something about putty
15:13:27 <b_jonas> lispy: oh, in that case you both need to tell your irc client that the channel is in utf8 and the terminal is utf8, and tell the terminal to accept and send utf8
15:14:23 <b_jonas> it's a phi (0x3c6) which is 0xcf 0x86 in utf-8 and the 0xcf is i diaresis in 8859-1
15:14:36 * lispy uses the world's most complex irc setup, he uses screen + irssi on one machine and then views it via putty or Terminal.app on different machines.
15:15:06 <_ar> lispy isn't alone
15:15:12 <b_jonas> lispy: if you can't make the terminal accept utf-8 at least tell the irc client that the channel is in utf-8 so it at least outputs 8859-1 characters in a sane way
15:15:43 <lispy> b_jonas: if I don't use putty, all works.  so, dunno what to say.
15:15:50 <_ar> except i'm on linux and can see all of the utf8 encoded stuff fine
15:16:01 <b_jonas> lispy: change its settings
15:16:14 <mauke> X -> urxvt-> screen -> irssi -> irssi-proxy (running in screen) -> IRC server
15:16:40 <_ar> lispy: http://planetozh.com/blog/2007/08/how-to-display-utf8-in-your-putty-bash-shell/
15:16:43 <lambdabot> Title: How To Display UTF8 in your Putty Bash Shell « planetOzh, http://tinyurl.com/4l36oq
15:16:59 <b_jonas> I use irssi in urxvt nowdays, but it's complicated by that most urxvts I use are set up to speak 8859-2 but the one with irssi is set up to speak utf8 instead
15:17:04 <newsham> lispy: whats so complex about that?
15:17:21 <lispy> oh putty has at least 2 places that require you to say UTF8, i was only saying it in one of them....works now
15:17:38 <mauke> ＵＮＩＣＯＤＥ
15:17:41 <_ar> lispy: nvm... i didn't read that it was bash specific
15:17:48 <_ar> https://anti.teamidiot.de/nei/2007/02/irssi_putty_screen_unicode_utf/
15:17:51 <lambdabot> Title: Irssi, PuTTY, Screen & Unicode UTF-8 (anti), http://tinyurl.com/4nlfm4
15:17:54 <_ar> that one is exactly what you want
15:18:05 <newsham> i'm using putty + screen -U + irssi right now
15:18:06 <lispy> _ar: thanks, I have it working
15:18:20 <b_jonas> newsham: I actually dislike that: apps shouldn't change how my terminal is set up unless I really want them to
15:18:21 <mauke> >/ＵＮ:/ＩＣ2/ＯＤ3/Ｅ
15:18:28 <lispy> mauke: yay!
15:18:35 <lament> screen is a special case
15:18:35 <_ar> oh sorry lispy, i didn't know
15:18:42 <newsham> bjonas: it isnt
15:18:47 <b_jonas> s/newsham/_ar/
15:18:48 <b_jonas> sorry
15:18:54 <b_jonas> I meant _ar's mention of that escape sequence
15:19:49 <newsham> ＣＵＮＩＦＯＲＭ
15:19:59 <nomeata> Hi. Does http://www.haskell.org/haddock/CHANGES.txt (Haddock now understands all syntax understood by GHC 6.8.2) mean that Haddock can generate documentation for files with Template Haskell in it?
15:20:24 <b_jonas> anyway, good night now
15:20:34 <lispy> nomeata: I haven't tried with TH, but I thought there were some things that haddock didn't work on for me
15:20:57 <dons> mauke: huh.
15:21:01 <dons> i thought we disabled color :)
15:21:06 <nomeata> lispy: I heared rumors that it reads .hi files now, and they are written after TH has run, right?
15:21:07 <lispy> nomeata: I want to say, infix type constructors are still having problems?
15:21:16 <mauke> dons: I haxed the gibson
15:21:28 <lispy> dons: it's irssi only
15:22:13 <newsham> ‹›※‼
15:22:17 <nomeata> (Too bad Debian has haddock 0.8, which certainly does not grok TH)
15:22:31 <lispy> nomeata: but you can get haddock from cabal
15:22:47 * nomeata tries that
15:32:47 <nomeata> ok, it does not bail out on Template Haskell any more, but it still ignores any functions or data types generated by Template Haskell
15:35:55 <nomeata> strange. It outputs some, far from all, TH generated functions, with no apparent logic.
15:39:18 <vixey> > 1+1
15:39:20 <lambdabot>   2
15:45:38 <lispy> nomeata: does it really make sense to haddock generated functions?
15:45:54 <lispy> nomeata: What comments can you write about them if they are generated at compile time, for example
15:46:36 <nomeata> lispy: yes, comments are hard to add (until Template Haskell allows to create, well, commented functions) :-)
15:46:51 <nomeata> lispy: but they are still part of the API, and they have proper types.
15:47:20 <nomeata> lispy: and I often wonder what functions with what types are generated by some TH magic, especially around HAppS
15:48:18 <lispy> nomeata: as in HAppS uses a lot of TH or that people use TH when using HAppS?
15:48:34 <nomeata> lispy: the former
15:48:58 <nomeata> hmm. looking in the code, haddock ignors declarations with source locations that occured before
15:49:13 <nomeata> if I comment that out, I get all the gory details I want!
15:50:32 <vixey> I wonder how many PhD thesis I've read :/
15:52:36 <vixey> > let π1 (x,y) = x ; π2 (x,y) = y in π1 (3,8)
15:52:37 <lambdabot>   3
16:03:15 <Arnar_> anyone awake?
16:03:24 <vixey> yeah I am awake
16:03:29 <Arnar_> check this
16:04:11 <Arnar_> > let fmap2 f x = fmap (fmap f) x in fmap2 (+1) [[1,2],[3,4]]
16:04:12 <lambdabot>   [[2,3],[4,5]]
16:04:14 <Arnar_> right..
16:04:23 <vixey> cool lol
16:04:37 <Arnar_> @pl \f x -> fmap (fmap f) x
16:04:37 <lambdabot> fmap . fmap
16:04:41 <Arnar_> which makes perfect sense
16:04:54 <Beelsebob> uhhuh... this is very useful when combined with first and second
16:04:55 <Arnar_> > let fmap2 = fmap . fmap in fmap2 (+1) [[1,2],[3,4]]
16:04:56 <lambdabot>   [[2,3],[4,5]]
16:05:01 <Arnar_> what'
16:05:03 <Arnar_> uh
16:05:09 <Arnar_> ghci gives me an error on the last thing
16:05:23 <vixey> Arnar: maybe the error has some info?
16:05:26 <vixey> what is the error?
16:05:27 <Arnar_> hang on
16:06:32 <Arnar_> vixey: http://hpaste.org/10901
16:06:36 <Arnar_> hmm
16:06:38 <Arnar_> :t fmap
16:06:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:06:43 <Arnar_> :t prelude.fmap
16:06:44 <lambdabot> Not in scope: `prelude'
16:06:48 <vixey> :t fmap . fmap
16:06:49 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
16:06:49 <Arnar_> :t Prelude.fmap
16:06:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:07:15 <ddarius> Arnar_: Monomorphism restriction
16:07:23 <Beelsebob> > (fmap . fmap . first . fmap . second) (const 1000) [[([(1,2), (3,4)],3), ([(2,5)],2)], [([],1)], [([(9,3), (10,11)]5,), ([],6), ([],10)]]
16:07:23 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 125}...
16:07:29 <Arnar_> ddarius: hm?
16:07:36 <Beelsebob> oops, must have mucked up the brackets
16:07:55 <Beelsebob> > (fmap . fmap . first . fmap . second) (const 1000) [[([(1,2), (3,4)],3), ([(2,5)],2)], [([],1)], [([(9,3), (10,11)],5), ([],6), ([],10)]]
16:07:56 <lambdabot>   [[([(1,1000),(3,1000)],3),([(2,1000)],2)],[([],1)],[([(9,1000),(10,1000)],5...
16:08:22 <Beelsebob> Arnar: in general, sequences of fmap ., first . and second . can be used to target a function into a data structure
16:08:33 <Beelsebob> as highlighted by conal in his deep arrows stuff
16:08:48 <Arnar> Beelsebob: right.. but why does fmap.fmap work in lambdabot but not in my ghci?
16:09:00 <Beelsebob> Arnar: dunno, it *should* work in your ghci
16:09:02 <Beelsebob> pastebin it
16:09:08 <Arnar> http://hpaste.org/10901
16:09:10 <Arnar> already there
16:10:23 <Beelsebob> oh, that's because it doesn't know what functor to use there
16:10:36 <chrisdone> @src (.)
16:10:37 <lambdabot> (f . g) x = f (g x)
16:10:43 <chrisdone>  (.) is defined as fmap in lambdabot, last I checked
16:10:49 <Arnar> ah
16:10:50 <Beelsebob> in general, I don't see any reason to define a second function there Arnar
16:10:52 <vixey> :t (.)
16:10:53 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
16:10:59 <Beelsebob> just use the (fmap . fmap) at the place you want to apply it
16:11:00 <dmwit> chrisdone: You must not have checked recently.
16:11:07 <dmwit> > (+1) . [3, 4, 5] -- nope
16:11:08 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[a1]'
16:11:16 <chrisdone> wow, real error messages
16:11:48 <Arnar> Beelsebob: what if I want to hide that from someone?
16:11:49 <chrisdone> nope I have not checked recently
16:11:51 <Arnar> :)
16:12:00 <Beelsebob> Arnar: why do you want to hide it?
16:12:08 <Beelsebob> surely you're trying to make it possible to understand your code
16:12:33 <Arnar> Beelsebob: well.. say [[...],[...]] represent a 2D array
16:12:38 <Arnar> actually..
16:12:43 <Arnar> what I want is Functor [[]]
16:13:06 <vixey> do you mean /\a, [[a]]
16:13:07 <vixey> ?
16:13:18 <Arnar> yes
16:13:40 <Arnar> vixey: wait.. what's /\ ?
16:13:50 <vixey> non existing type level language
16:14:50 <Arnar> o.O
16:15:04 <chrisdone> heh, I just got a few people interested in haskell “<chrisdone> let times = 120 : map (*2) times in take 10 times => [120,240,480,960,1920,3840,7680,15360,30720,61440] / <chrisdone> /me takes plate down stairs while you all puzzle about that line of code” -- cue people trying to figure it out and ensuing interest :-)
16:15:07 <rwbarton> Arnar: You can write  newtype List2D a = List2D [[a]]  and write a Functor instance for it
16:15:28 <Arnar> rwbarton: yes.. true
16:15:45 <Arnar> I'm just curious why (fmap . fmap) can't be polymorphic
16:16:01 <Arnar> why does it need to determine the type var f
16:16:02 <vixey> Arnar: did you try it with -XNoMonomorphismRestriction ?
16:16:24 <Arnar> vixey: ah, sorry - didn't realise that's what you meant, hang on
16:16:50 <Arnar> vixey: that's it..
16:16:53 <Arnar> works
16:16:58 <vixey> great
16:17:00 <rwbarton> Arnar: Alternatively you can write a type signature for fmap2
16:18:36 <Arnar> rwbarton: tried.. gives me "illegal signature" and suggests -XPatternsSignatures
16:18:39 <Arnar> well..
16:18:45 <Arnar> I'm just being curious here..
16:18:49 <Arnar> there's no real problem
16:18:56 <lightstep> my code is leaking memory very slowly. how can i find the leak?
16:19:01 <dmwit> chrisdone: Great!
16:19:16 <dmwit> chrisdone: Who were you interesting?
16:19:38 <rwbarton> On a somewhat off-topic note, apparently postgres is getting support for WITH RECURSIVE queries, which are quite Haskell-ish
16:19:52 <rwbarton> http://archives.postgresql.org/pgsql-hackers/2008-02/msg00642.php
16:20:02 <lambdabot> Title: RFP: Recursive query in 8.4
16:20:03 <Arnar> rwbarton: nice..
16:20:03 <lightstep> Arnar, that means you give the signature inside the definition, and h98 requires you to write the signature beside it
16:20:24 <Arnar> lightstep: ah ok.. thanks
16:20:59 <cjay> sweet
16:21:14 <chrisdone> dmwit: some people the lojban community >_> I am converting many of them
16:21:32 <dmwit> Ah, yes, Haskell is a good match for people interested in lojban, I think.
16:21:39 <chrisdone> agreed
16:22:01 <lightstep> mmm.. lojban-to-type translator...
16:22:43 <vixey> rwbarton: And they terminate?
16:24:33 <rwbarton> vixey: I don't know what would happen if the graph in that example contained a cycle say.
16:24:36 <chrisdone> %t so'i jbopre cu ca ja ba ai prami la xeskyl zo'o
16:24:37 <lojbot> [([prami1 (love-r(s)):] so'i /many/ jbopre /Lojbanic-person(s)??/) cu /is/does/ <<ca /is/does/ ja /and/or/ ba .ai /{intent..}/ /will be/ prami /lov-ing/>> ([prami2 (loved thing(s)):] la / / xeskyl. /[NAME]/ zo'o /{humorously..}/)]
16:26:00 <dmwit> xeskyl is really the transliteration of Haskell?
16:26:01 <dmwit> gross
16:27:27 <dmwit> vixey: It's not hard to deal with cycles.  We had to do something similar in my undergrad databases class.
16:27:42 <dmwit> vixey: Basically, you iterate the selection until the set doesn't grow any more.
16:27:44 <chrisdone> dmwit: like Turkish, it is written as it sounds
16:27:55 <dmwit> Since it's always a subset of the full database, you can iterate at most a finite number of times.
16:28:32 * rwbarton wonders whether it's possible to encode lojban grammar in the Haskell type system
16:28:47 <dmwit> I don't know if that's exactly how they'll implement it, of course, but it seems possible.
16:28:54 * chrisdone laughs
16:30:14 <nomeata> nevermind, it was just missing those declarations where the TH did not create any appropriate type signature
16:30:17 <rwbarton> Without -fallow-undecidable-instances, I suppose
16:32:20 <dmwit> Ah, the later part of that message confirms the "grow a subset" hypothesis.
16:32:48 <cjay> dmwit, vixey: they probably use the magic sets algorithm
16:34:13 <chrisdone> lojbot is in #jbocre, which is like xkcd's R9K, but instead of original text, you are devoiced for not (grammatical) lojban speaking. it takes grammar nazi to a whole new extreme :P
16:36:28 <nicktaken> is there no #games channel?
16:37:02 <chrisdone> nicktaken: haven't you read the Freenode guidelines! only not-for-profit organisations are allowed to have channels!
16:37:30 <nicktaken> so?
16:38:20 <nicktaken> ther eis a windows channel. windows is non-rpofit?
16:38:42 <dmwit> There is?
16:38:42 <chrisdone> the freenode imps haven't discovered it yet
16:38:51 <dmwit> wow
16:38:53 <dmwit> there is
16:40:55 <mmorrow> i just realized that the "lense" idea is what i've been looking for
16:42:15 <vixey> oh what are you doing with lenses?
16:44:55 <moonpatio> i want to use them for lexing/parsing, for dynamic-eval/run-it, I/O. pretty much everything :)
16:45:15 <moonpatio> i'm thinking of a slight variation though
16:46:02 <vixey> hm?
16:46:03 <moonpatio> where you're not restricted to only /mutual/ back-and-forthing between two types, but with some mobility
16:46:16 <moonpatio> so, my first thought is:
16:47:09 <moonpatio> newtype Lens a b (forall c. a -> (b -> L c a) -> L c a)
16:47:18 <moonpatio> oh, oops. i meant:
16:47:25 <vixey> :SS
16:47:37 <dmwit> moonpatio: Have you seen the quotient lenses paper?
16:47:50 <moonpatio> newtype Lens a b (a -> C (Lens c a) b)
16:47:57 <moonpatio> (C == Cont)
16:48:10 <moonpatio> dmwit: no. i'm trying to google stuff right now actually
16:48:20 <vixey> moonpatio: it' looks  like a jacobs ladder
16:48:36 <moonpatio> runLens :: Lens a b -> (b -> L c a) -> L c a
16:48:45 <dmwit> http://www.seas.upenn.edu/~harmony/
16:48:46 <lambdabot> Title: Boomerang: A bidirectional programming language for ad-hoc data
16:49:03 <dmwit> There's a link to research papers there.
16:49:19 <moonpatio> runLens (Lens lens) k = (\a -> runC (lens a) k)
16:49:24 <moonpatio> err
16:49:32 <moonpatio> runLens :: Lens a b -> (b -> L c a) -> a -> L c a
16:49:38 <nomeata> http://trac.haskell.org/haddock/ticket/59 with my haddock patch, if anyone wants to try it out.
16:49:39 <lambdabot> Title: #59 (Template Haskell generated declarations problematic) - haddock - Trac
16:50:02 <moonpatio> dmwit: heh. i actually just found that about 1 minute ago. it looks interesting.
16:50:17 <moonpatio> oh, crap. i didn't realize i was moonpatio
16:50:33 <mmorrow> ok
16:50:34 <mmorrow> :)
16:51:23 <mmorrow> dmwit: excellent
16:51:34 <mmorrow> vixey: what's a jacob's ladder?
16:51:59 <mmorrow> so with that above type, you can do..
16:52:18 <mmorrow> (a,b) -> (c,a) -> (d,c) -> (e,d) -> ...
16:52:25 <vixey> mmorrow: they string together a few bits of wood with ribbons, it sorts of folds throught itsself in an optical illusion
16:52:40 <vixey> mmorrow: that's how confusing your type above was ...
16:52:58 <mmorrow> (or of course still do  (a,b) -> (b,a) -> (a,b))  ...  -> (c,a) -> ...)
16:53:13 <vixey> You'd need to see a real one or a video I think
16:53:23 <mmorrow> vixey: hehe
16:53:34 <vixey> btw can you encode this Lens thing as a Thrist?
16:53:51 <mmorrow> i've heard you mention that before. what's a Thrist?
16:58:36 <hackage> Uploaded to hackage: bytestring 0.9.1.3
16:58:43 <dolio> So, I've been thinking for a while today...
16:59:04 <dolio> I'm not sure I can make my explanation of monads from the other day formal.
16:59:34 <mmorrow> is it short enough to summarize briefly?
17:00:01 <dolio> Well, it was about how monads are monoids in the category of endofunctors over a category.
17:00:19 <dolio> But T `O` T doesn't seem like a product.
17:00:29 <dolio> And I doesn't seem final.
17:00:57 <dolio> So it doesn't seem like T is a monoid object in that category.
17:01:10 <rwbarton> A monoid object makes sense in any monoidal category, not just ones in which the monoidal structure is given by the categorical product.
17:01:35 <dolio> Oh, okay. That must be where I'm going wrong, then.
17:01:44 <shapr> Baughn: shapr-script?
17:02:16 <dolio> In that case, I guess it's easy.
17:02:22 <mmorrow> End(N) with morphs (+n) considered as a monoid under (.) doesn't have a terminal object
17:02:24 <vixey> hi
17:02:44 <vixey> I don't know how to put it mmorrow but there is a paper about them
17:02:57 <mmorrow> vixey: perfect
17:02:59 * mmorrow googles
17:03:37 <mmorrow> well well, there's a hackage package
17:03:39 <mmorrow> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/thrist
17:03:40 <lambdabot> Title: HackageDB: thrist-0.1
17:04:17 <rwbarton> (A monoidal category is a category with extra structure; there can be lots of different monoidal structures on a category)
17:04:46 <vixey> isn't every category a monoid?
17:04:52 <dolio> Yeah, I went and looked it up.
17:04:59 <shapr> Isn't ever monoid a category?
17:05:00 <rwbarton> A monoid is a category with one object
17:05:06 <mmorrow> err, i'm not sure if i phrased that about End(N) exactly correctly, but
17:05:14 <mmorrow> yeah, that's what made me go hm
17:05:18 <shapr> hom?
17:05:21 <mmorrow> heh
17:05:24 * shapr snickers
17:05:37 <dolio> So a monoid object is an object T with morphisms T (x) T -> T and I -> T.
17:06:10 <rwbarton> satisfying unit and associativity laws
17:06:17 <dolio> Right.
17:06:38 <rwbarton> (But those aren't extra data, so it's often convenient to forget about them.)
17:07:04 <mmorrow> one cool think is (roughly) that a monoid object in a category is equivalent to a monoid considered as a category
17:07:35 <mmorrow> (i'll have to look up the exact statement of that, but i think that's close enough for government work)
17:07:54 <mmorrow> i've always wanted to use that expression ;)
17:11:45 <Toxaris> Should I be afraid of strange closure types like 3921 and 2784?
17:13:31 <dons> yes
17:15:07 <Toxaris> are they related to my code?
17:15:31 <ddarius> dolio: Make the bicategory of spans of sets (0-cells = sets, 1-cells = pairs of functions with a common domain [spans], 2-cells = functions from those common domains that make the obvious diamond commute) and describe what a monad is in it.
17:16:00 <ddarius> (oh, composition of 1-cells is by pullback, the rest of the structure should be obvious enough)
17:16:02 <mmorrow> ok, the correct (i think) phrasing of that End(N) thing is... objects a `elem` N and morphisms are (+n) for each/every n. this cat has no terminal object.
17:16:34 <mmorrow> s/a `elem`/are `elem(s)`/
17:17:29 <ddarius> mmorrow: That just makes a category equivalent to the ordered set that N is.  Having no terminal object is simply the fact that infinity is not a natural number.
17:17:31 <mmorrow> ddarius: i have some pullback code on Maps i recently dug up for this db thing. i'll paste.
17:18:07 <mmorrow> ddarius: (i said nothing about an ordering)
17:18:25 <ddarius> mmorrow: You didn't need to.
17:18:34 <mmorrow> ddarius: yes, that is /exactly/ what having no terminal object says
17:19:43 <mmorrow> if i add an element "infinity" and a map n -> inf for every n, then that category has a terminal object.
17:23:00 <mmorrow> that just made me remember that adding infinity to R^2 gives you a sphere (context if differential geom). that always amused me for some reason
17:23:08 <mmorrow> s/if/is/
17:26:40 <vixey> and R^3 is a sphere too?
17:28:00 <nha__> what options are there for serialization that support cyclical datastructures
17:28:52 <mauke> Data::Dumper
17:29:22 <vixey> nha__: What is the data?
17:29:41 <ako_0_> $0
17:29:47 <nha__> trees with references to their parents
17:29:57 <rwbarton> nha__: You can't distinguish cyclical data structures from infinite ones with pure functions.
17:30:18 <rwbarton> nha__: And actually I don't know how to do it period if you're just given some cyclic data as input...
17:30:27 <dmwit> pointer comparison
17:30:42 <vixey> in htat case you must tag the trees with unique identities or something similar
17:31:05 <rwbarton> I tried using pointer comparison for something once, and failed.
17:31:15 <nha__> maybe its better to use a zipper for this then
17:31:36 <nha__> i have a quadtrie and want to find neighbors
17:32:09 <rwbarton> nha__: If you know what kind of cyclicity the structure has, you can probably serialize just enough information to reconstruct the structure.
17:32:57 <nha__> yea
17:33:02 <nha__> dunno if its worth going down that path though haha
17:33:58 <rwbarton> (Actually, if anyone can write a function to detect cyclic lists I'd be very interested to see it)
17:34:54 <vixey> I thought augustss wrote up something that did that
17:35:17 <vixey> something to do with Expr
17:36:07 <mauke> unsafePtrEq
17:36:19 <rwbarton> That's easier, there he can use unsafePerformIO while building the structure.
17:39:47 <b\6> having problems getting the ceiling of Int / Int as an Int.
17:39:56 <mmorrow> ddarius: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=77#a77
17:40:01 <mmorrow> (pullback)
17:40:10 <BMeph> I remember a variant of JSON that's supposed to work with them...
17:40:27 <mauke> :t (ceiling .) . ((/) `on` fromIntegral)
17:40:28 <lambdabot> forall b a. (Integral a, Integral b) => a -> a -> b
17:40:43 <b\6> mauke: thanks, studying.
17:40:52 <mauke> @unpl (ceiling .) . ((/) `on` fromIntegral)
17:40:52 <lambdabot> (\ d g -> ceiling (on (/) fromIntegral d g))
17:40:57 <mmorrow> i guess you can detect cyclic lists of your (==) is pure..
17:42:02 <dolio> ddarius: I'm a bit confused. What is the target object of the 1-cell f : X -> Y, g : X -> Z?
17:42:07 <dolio> Y x Z?
17:42:52 <mmorrow> <vixey> and R^3 is a sphere too?
17:43:41 <BMeph> nha__: Try www.jspon.org
17:44:04 <mmorrow> if you add the point at infinity to R^3, you get S^3 == the analog of a sphere (S^2) one dim up
17:44:04 <nha__> ok thanks
17:44:24 <mmorrow> vixey: and so on for any R^n
17:44:33 <mmorrow> (inf,inf,inf)
17:45:10 <rwbarton> mauke: I know the primitive exists.  But I don't know how to use it in any useful way.
17:45:13 <vixey> actually I had just read this in a knot theory book the otherday
17:45:16 <shapr> whee
17:45:20 <vixey> 2 days agdo
17:45:36 * shapr hugs vixey
17:46:06 <vixey> (:
17:46:38 <mmorrow> vixey: so S^2 it's topologically distinct from from R^2 since it take (minimally) two R^2s to cover S^2
17:46:46 <mmorrow> s/it's/is/
17:47:03 <vixey> oh ok
17:47:06 <ddarius> dolio: A 1-cell f : A -> B is a span f1 : X -> A and f2 : X -> B
17:47:24 <dolio> Oh.
17:47:37 <vixey> but I thought you could have (x,y,w) in R^3 to represent any point (x/w,y/w) or w=0 in S^2
17:49:09 <intoverflow> vixey: the representation might work, but it isn't continuous
17:49:15 <mmorrow> yes, that's P^2 :)
17:49:26 <vixey> haven't met P^n
17:50:32 <mmorrow> vixey: that's exactly (one way) to construct the two patches
17:52:21 <mmorrow> so you there are mapping R^2 to S^2. but there's a point which you can't quite get at with a single mapping of R^2, which is where another copy comes in, which is also missing a point, but that's already taken care of
17:53:46 <Philonous> And what you get is a nice little manifold?
17:53:55 <mmorrow> heh, exactly.
17:54:02 <intoverflow> s/little/compact :)
17:54:53 <Philonous> Yeah and differentiable
17:55:07 <mmorrow> and infinitely so
17:56:07 <ddarius> Now take your manifold and put a continuous vector field over it...
17:56:40 <intoverflow> brb lemme get my comb
17:57:29 <Olathe> @src concat
17:57:29 <lambdabot> concat = foldr (++) []
17:57:50 <mmorrow> then the physicists storm in and start scribbling indices all over everything ;)
17:58:18 <Olathe> How would I replace the prelude with my own when compiling ?
17:58:38 <ddarius> mmorrow: Teach the physicists geometric algebra
17:59:18 * mmorrow cackles and stirs his cauldron
18:00:55 <mmorrow> general relativity is way cool, but my eyes just glaze over after the ^iijkjlj_jllkjkl 's some in
18:01:04 <mmorrow> s/some/come/
18:01:36 <mauke> ^a_b\Omega^c_d
18:01:53 <Philonous> Don't physicists already have sheafes at their disposal?
18:02:05 <intoverflow> only the string theorists, apparently
18:03:05 <dons> http://www.reddit.com/r/programming/comments/759yn/how_to_ask_for_help_on_irc/c05pnin
18:03:08 <lambdabot> Title: Lord_Illidan comments on How to ask for help on IRC, http://tinyurl.com/3g95vp
18:03:10 <dons> go #haskell.
18:03:13 <Olathe> String theorem: Unless y is empty, length (x ++ y) > length x
18:03:33 <vixey> length (x ++ y) = length x + length y
18:04:00 <Olathe> We could build a whole string theory with theorems like these !
18:04:16 <vixey> yeah then you could prove your programs work :)
18:05:02 <Philonous> I'd like to throw in semi-commutation
18:06:04 <loop> what's semi-commutation
18:06:20 <ddarius> mmorrow: I recommend "Gauge Theory Gravity with Geometric Calculus" on this page: http://modelingnts.la.asu.edu/html/GCgravity.html
18:06:21 <lambdabot> Title: Geometric Calculus in Gravity Theory
18:06:42 <vixey> nn shapr
18:07:00 <Philonous> loop: I meant that some letters should commute
18:15:55 <mmorrow> ddarius: cool
18:20:40 <dons> http://twitter.com/paytonrules/statuses/946501437 :) good work lads.
18:20:42 <lambdabot> Title: Twitter / Eric: Officially amazed at the H ...
18:25:48 <dmwit> So I'm reading the "Theorems for Free!" paper by Wadler.
18:26:02 <dons> ?free map
18:26:03 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
18:26:09 <dons> get yr thrms.
18:26:12 <dmwit> He uses * at the type level for the [] type constructor, and * at the term level for the map function.
18:26:29 <dons> cute. 1980s old school make up your syntax
18:26:51 <ddarius> It's the Kleene Star
18:27:17 <dmwit> He writes: "Say r is the function odds : Int* -> Int* that removes all odd elements from a list of integers, and say a is inc [i.e. succ in Haskell] as before.  Now we have inc* (odds [1,2,3]) = [2,4] /= [4] = odds (inc* [1,2,3])"
18:27:23 <mauke> use Kleene Bombs to destroy it!
18:27:32 <dmwit> That's just a mistake, right?
18:28:04 <rwbarton> Yeah, he must mean [3]
18:28:16 <dmwit> Right, and swap the sides of the /=, right?
18:28:22 <dmwit> Anyway, fine.
18:28:30 <dmwit> I'm not going crazy... yet. =)
18:28:40 <mauke> "removes" is ambiguous
18:28:54 <mauke> you can read it as "deletes" or "extracts"
18:29:04 <dmwit> mauke: But neither of those interpretations fits, really.
18:29:14 <dmwit> i.e. they don't match the example he gives.
18:29:23 <rwbarton> > (map succ (filter odd [1,2,3]), filter odd (map succ [1,2,3]))
18:29:25 <lambdabot>   ([2,4],[3])
18:32:29 <mmorrow> ddarius: if you're in to general-rel/differential-geom/manifolds, this book is good (it's from 1964 though, so not categorical, but no-nonsense and covers all the background needed for these).:
18:32:33 <mmorrow> http://www.amazon.com/Geometry-Manifolds-AMS-Chelsea-Publishing/dp/0821829238/ref=pd_bbs_1?ie=UTF8&s=books&qid=1223169873&sr=8-1
18:32:37 <lambdabot> http://tinyurl.com/52kcuk
18:34:04 <mmorrow> the book itself (cover,pages,binding,..) is really well made too. probably one of my favorite books i own not-considering content.
18:35:08 * mmorrow loves seeing books on amazon for $41.00 that he paid $100 for.
18:37:48 <mmorrow> the cover truly says it all.
18:41:06 <nha__> is there a generic way to apply a record selector to an algebraic type and have it ignore types who dont have the selector instead of throwing an exception
18:43:35 <Olathe> nha__: I'm rather new to Haskell, but could you have a function that called another and returned Nothing or something if that error happened ?
18:46:04 <nha__> yea i dont want to generate an exception and have to catch it though
18:46:56 <bd_> Olathe: if what error happened?
18:47:21 <Olathe> bd_: The selector doesn't exist error or whatever nha__ was talking about.
18:47:40 <dmwit> So, this paper is a little bit weird.
18:47:43 <bd_> oh, no, that's not (safely) possible
18:47:47 <Olathe> Is there a standard command for installing a Haskell package ?
18:47:52 <dmwit> The type "Int" has the same representation as the function "id :: Int -> Int".
18:47:57 <bd_> you might be able to do a hack with unsafePerformIO and catch it in IO, but I don't know if that's a safe thing to do
18:48:02 <dmwit> Olathe: cabal install <package>
18:48:15 <dmwit> Olathe: I use cabal install <package> --global when I have super powers.
18:48:39 <Olathe> Ahh, do I have to install cabal or is it on the standard Windows ghc distribution ?
18:48:57 <dmwit> nha__: You have to manually define the selector for each constructor, sadly.
18:49:01 <eric_8th_Light> second dumb question today
18:49:09 <eric_8th_Light> Trying to define my own type with Eq
18:49:12 <eric_8th_Light> Is something wrong with this?
18:49:14 <eric_8th_Light> instance Eq Player where
18:49:14 <eric_8th_Light> 	X == X 			= True
18:49:14 <eric_8th_Light> 	Y == Y 			= True
18:49:15 <eric_8th_Light> 	Empty == Empty 	= True
18:49:15 <eric_8th_Light> 	_ == _ 			= False
18:49:19 <dmwit> ?hackage cabal-install
18:49:20 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
18:49:21 <dmwit> Olathe: ^^
18:49:33 <dmwit> eric_8th_Light: Looks fine.
18:49:37 <Olathe> Thanks :)
18:49:43 <dmwit> eric_8th_Light: You do know GHC can generate that for you, right?
18:49:48 <eric_8th_Light> I do now
18:49:53 <bd_> eric_8th_Light: assuming that the only constructors are X, Y, and Empty, that's right
18:49:53 <dmwit> right, an exercise
18:50:15 <dmwit> eric_8th_Light: Make sure the first character of each line is lined up.
18:50:25 <dmwit> If your underscores are centered, for example, that will be a parse error.
18:50:37 <dmwit> (Even though it looks prettier.)
18:50:57 <eric_8th_Light> so how come if I do this: filter (==X) [X, X] I get stack overflow?
18:51:02 <mmorrow> what is the definition of Player?
18:51:11 <mmorrow> whoa, major lag
18:51:29 <eric_8th_Light> Player is data Player = X | Y | Empty
18:51:37 <dmwit> eric_8th_Light: The stack overflow is likely to be elsewhere.
18:51:46 <dmwit> Can you try just that line in ghci?
18:51:48 <mmorrow> that Eq instance looks good to me
18:51:56 <eric_8th_Light> yeah that's what I'm trying
18:52:05 <Cale> eric_8th_Light: The only thing I can imagine is that the problem is elsewhere or your install of GHC is broken.
18:52:11 <eric_8th_Light> oh don't say that
18:52:21 <dmwit> Or he's lying.
18:52:26 <dmwit> People often forget that possibility.
18:52:29 <Cale> ehehe
18:52:31 <dmwit> (It might not even be intentional.)
18:52:36 <Cale> (and I can't think of the reason why it's the latter, anyway :)
18:52:38 <eric_8th_Light> Thanks House
18:52:43 <dmwit> ;-)
18:52:46 <Cale> eric_8th_Light: So, yeah, try it in ghci
18:52:57 <ddarius> Read Jaynes.
18:53:14 <Cale> > filter (== LT) [LT, LT]
18:53:16 <lambdabot>   [LT,LT]
18:53:18 <Jedai> @src intersect
18:53:19 <lambdabot> intersect = intersectBy (==)
18:53:35 <dmwit> eric_8th_Light: It's not meant to be an insult.  It's just easy to overlook one's own mistakes in the CS world.  I do it all the time.
18:53:39 <eric_8th_Light> I've been trying to do that - but ghci isn't letting me declare data objects manually
18:53:42 <eric_8th_Light> Yeah I know
18:53:51 <Cale> eric_8th_Light: oh, load a file with that data declaration in it
18:53:54 <ddarius> dmwit: Helps to maintain your self-esteem.
18:53:55 <dmwit> eric_8th_Light: You have to put the data definition in a file and then load it.
18:54:11 <Cale> eric_8th_Light: (like, for example, the program you're working on)
18:54:16 <eric_8th_Light> yeah that's what I've been doing
18:54:23 <eric_8th_Light> but it's got the rest of the program
18:54:27 <eric_8th_Light> I'll comment the rest out and try that
18:54:35 <Cale> okay
18:54:39 <dmwit> You don't have to run the whole program, just because it's there. ;-)
18:54:54 <Cale> Well, if you're getting a stack overflow, that means it compiles right?
18:55:01 <eric_8th_Light> yeah it does
18:55:01 <Cale> That's enough for ghci to load it
18:55:09 <Cale> It doesn't need to be able to run
18:55:19 <mmorrow> sounds like a perfect usecase for codepad.org
18:55:43 <dmwit> You're right, it does.
18:56:04 <eric_8th_Light> codepad.org?
18:57:52 <Cale> It's a pastebin which can attempt to compile and execute code, or report the errors automatically.
18:58:12 <eric_8th_Light> oh that's cool
18:58:20 <eric_8th_Light> yeah I'm looking at it now, never used it before
18:58:29 <eric_8th_Light> http://codepad.org/8booI2OE
18:58:44 <eric_8th_Light> complains there's no main - let me try a second try
18:58:59 <Cale> http://codepad.org/6N3GAFaN
18:59:41 <dmwit> eric_8th_Light: I bet it's your empty Show instance causing pain.
18:59:44 <dmwit> show = shows ""
18:59:55 <dmwit> shows =~ (++) . show
18:59:58 <Cale> Better yet,  deriving Show
19:00:16 <dmwit> Yup, derive Show for now, and write your exercise instance after it works. =)
19:00:53 <eric_8th_Light> deriving Show did it
19:01:08 <eric_8th_Light> thanks guys!
19:01:12 <eric_8th_Light> Now to watch the cubs get beat
19:01:29 <Cale> Also, word of warning, there are tabs in your source
19:01:57 <Cale> If you don't configure your editor to automatically convert tabs to spaces, you will almost certainly fight with indentation problems later.
19:02:11 <ddarius> *Ominous thunder clap*
19:07:35 <newsham> eric: i wrote a tic-tac-toe after our discussions
19:07:54 <chrisdone> sauce?
19:08:01 <dmwit_> Make tab a lexical error!
19:08:41 <lament> punishable by death
19:08:52 <newsham> btw, if you use Player = X | Y, and Maybe Player for spaces, then you can use deriving(Eq) for Player
19:09:14 <newsham> but you'll have to deal with squares as (Just X) | (Just Y) | Nothing
19:09:58 <Olathe> C:/Program Files/ghc/libHSrts.a(Main.o)(.text+0x7):Main.c: undefined reference to `__stginit_ZCMain'
19:10:04 <Olathe> What lovely thing does that mean ?
19:10:17 <dmwit> ghc --make
19:10:39 <Olathe> Thanks :)
19:11:03 <dmwit> stg = spineless tagless g-machine (i.e. GHC's theoretical underpinnings)
19:11:11 <dmwit> init = obvious
19:11:20 <dmwit> preflex: zdec ZC
19:11:20 <preflex>  :
19:11:33 <dmwit> Not sure why there's a ':' before Main, though.
19:16:29 <SamB_XP> dmwit: it's kind of like a dollar sign in C ;-P
19:16:43 <dmwit> wut
19:16:51 <SamB_XP> extra-special!
19:16:54 <dmwit> I don't recall any $ in C...
19:17:03 <dmwit> he
19:17:20 <SamB_XP> actually wait... that $ in C might be more like # in Haskell, except less-often-used
19:17:33 <SamB_XP> well, it's an extra-special module name
19:17:49 <SamB_XP> I think there is also a a __stginit_Main
19:22:28 <dino-> I was just idly reading this PG weblog post: http://www.paulgraham.com/accgen.html
19:22:37 <lambdabot> Title: Accumulator Generator
19:22:53 <dino-> And I don't get something. Why is the Haskell impl of that not simply: foo n = (\i -> n + i)
19:23:24 <dino-> It seems so simple by comparison, that I feel like I'm totally not getting the problem posed here.
19:23:34 <chrisdone> what's that program that makes an X session inside another window?
19:24:22 <rwbarton> dino-: The haskell implementation is foo = (+)
19:24:25 <chrisdone> SPJ uses it to demonstrate XMonad on the haskell video
19:24:32 <rwbarton> oh god IORef
19:24:35 <dino-> rwbarton: ya, but why.. right
19:24:38 <dino-> The IO
19:24:42 <travisbrady> can anyone give me a pointer or two in using hsc2hs? http://hpaste.org/10902
19:25:01 <rwbarton> Oh... it's supposed to have state apparently.
19:25:26 <aprocter> chrisdone: Xnest maybe?
19:25:53 <chrisdone> aprocter: that's the one! thanks!
19:26:19 <newsham> ``The problem: Write a function foo that takes a number n and returns a function that takes a number i, and returns n incremented by i.''
19:26:24 <newsham> thats not a "function"
19:26:39 <newsham> also some of his code is quite obtuse.  that's not how I'd write it in python
19:26:46 <newsham> (or haskell, for that matter)
19:26:58 <Cale> "(b) that's incremented by, not plus."
19:26:59 <dino-> These seem to have been donated by people, at the bottom.
19:27:04 <dino-> some of them at least.
19:27:30 <Cale> It seems that the idea is that it must mutate the mutable variable n, not just add i to the value n.
19:28:00 <dino-> Cale: ah
19:28:30 <Cale> heh, import IOExts seems to suggest this article is very old
19:28:39 <dmwit> Why would you make such a requirement?
19:29:15 <Axman6> sounds like a job for State?
19:29:23 <newsham> due to python's scoping silliness in closures, I'd write it as:  def accum(n) { def f(x) { f.val += x; return f.val; }; f.val = n; return f; }
19:29:24 <dmwit> I freely admit that different languages require different coding styles; should it really surprise you that foisting your style on my language will make my language look bad?
19:29:59 <newsham> but thats what you get for reading paul graham.
19:30:16 <dino-> Do all of these implementations mutate the original storage of n?
19:30:22 <dino-> I'm unable to read many of them.
19:30:36 <mmorrow> let ref = (\io -> (\i -> modifyIORef_ io (n + i))) in (\n -> return . ref =<< newIORef n)
19:30:38 <dino-> s/original/single/
19:30:47 <Azstal> the C++ one doesn't, but could be easily modified to do so
19:31:18 <dino-> Azstal: ya, the return didn't look like it to me either there.
19:31:52 <MyCatVerbs> dmwit: IMO, the Haskell example really wasn't any different to the Python example. Both languages largely use immutable data structures - infact, a one-element Python list isn't really all that different from an IORef, IMO.
19:31:55 <newsham> how about:  accum n m = (n + m, accum (n+m))    ?
19:32:27 <MyCatVerbs> newsham: onnnnly in the State monad. ;)
19:32:38 <newsham> why?
19:33:18 <newsham> huh, what are you talking about?  this python example doesnt use a list.
19:34:04 <MyCatVerbs> newsham: I mean that's roughly (modulo one newtype constructor application in the middle, and I can't remember which way around the new state and the result go) how you'd write that in the State monad. :)
19:34:10 <ddarius> accum :: Int -> Int -> (Int, Int -> (Int -> (Int, Int -> (Int, Int -> ...
19:34:35 <newsham> mycatverb: no its not.  in the state monad i probably wouldnt set the state to a lambda.
19:34:51 <newsham> ?type let accum n m = (n + m, accum (n+m)) in accum
19:34:52 <lambdabot>     Occurs check: cannot construct the infinite type: t = (a, a -> t)
19:34:52 <lambdabot>       Expected type: t
19:34:52 <lambdabot>       Inferred type: (a, a -> t)
19:35:01 <MyCatVerbs> newsham: no it doesn't, but you could transcribe the Haskell one directly into Python by using a one-element Python list where the Haskell code uses the IORef.
19:35:38 <MyCatVerbs> newsham: I'm saying that he's actually being somewhat unfair to Python there, because his Python program is worse than what the language can be made to do anyway.
19:35:58 <ddarius> Paul Graham should be ignored for the most part.
19:36:06 <newsham> [16:32] < ddarius> Paul Graham should be ignored for the most part.
19:36:24 <mmorrow> let ref = let go = (\io -> (\i -> modifyIORef io (+i))) in (\n -> newIORef n >>= \io -> return (io, go io))
19:36:30 <mmorrow> ref :: Integer -> IO (IORef Integer, Integer -> IO ())
19:36:55 <mmorrow> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=78#a78
19:37:12 <ddarius> newsham: ?
19:37:24 <newsham> ddarius: what you said.
19:37:42 <newsham> i second the motion
19:38:26 <MyCatVerbs> newsham: and also that he totally ignores how nice immutable data actually is - Hell, even the C# weenies are starting to cotton on to that now. If even Microsoft are ahead of you on the curve for, well, anything, you possibly need to worry. ;)
19:39:11 <dmwit> Well, to be fair, that article is probably five years old.
19:39:35 <MyCatVerbs> (I'm actually being quite unfair to MS there. But really, even purely-industrial people are starting to get the immutability bug now, which is pretty impressive considering that the whole idea originates pretty much entirely in academia.)
19:40:08 <newsham> http://codepad.org/45ZWYeji
19:40:20 <Olathe> If I have "data StandardNum = Integer Integer | Rational Rational | Real CReal", how do I write the type for "apply f (Integer a) = Integer (f a)" and so on ?
19:41:18 <ddarius> Olathe: Why are you asking us?  Ask GHCi.
19:41:58 <newsham> why doesnt that codepad code work when I use (,) instead of Accum?
19:42:16 <dmwit> Olathe: Note that "f" can't be used in any of the other branches.  So the type is pretty easy to write.
19:42:34 <dmwit> apply :: (Integer -> a) -> (StandardNum -> a)
19:42:46 <dmwit> Oh, even better.
19:42:56 <dmwit> apply :: (Integer -> Integer) -> (StandardNum -> StandardNum)
19:43:19 <dmwit> newsham: Because Accum is a recursive data type.
19:43:40 <rwbarton> Olathe: Perhaps you want apply :: (forall a. Num a => a -> a) -> (StandardNum -> StandardNum)?
19:43:57 <dmwit> mmmm, rank-2 polymorphism
19:47:13 <newsham> > let accum n = put n >> return (\n -> modify (+n) >> get) in runState (do { a <- accum 5; a 3; a 2 }) undefined
19:47:14 <lambdabot>   (10,10)
20:00:39 <kohwj> greetings
20:01:21 <lanaer> hi kohwj
20:10:37 <nicktaken> anyone good with the graph module?
20:11:00 <ivanm> nicktaken: which graph module?
20:11:43 <dmwit> You should just ask your question. ;-)
20:13:09 <ivanm> dmwit: he did! :p
20:13:29 <ivanm> though, it also depends on if he means Data.Graph or Data.Graph.Inductive
20:13:35 <nicktaken> import qualified Data.Graph as G
20:13:39 <dmwit> Well, if that's the whole question, the answer is definitely Yes!
20:13:50 <dmwit> *Somebody* is sure to be good with the graph module!
20:13:51 <nicktaken> G.graphFromEdges [1,2,3]
20:13:52 <nicktaken> or -[(12, 56, [1,2,3])]
20:14:00 <nicktaken> i cant construct one
20:14:01 * ivanm hasn't used the default Graph lib
20:14:06 <nicktaken> [key,key[key]]
20:14:22 <nicktaken> wtf it it normally [key -> values] right?
20:14:28 <nicktaken> [key,key,[key]]
20:14:37 <dmwit> If you want a [key -> value], try Data.Map.
20:14:45 <nicktaken> i dont want that
20:14:53 <ivanm> or IntMap if your keys are Ints
20:15:13 <dmwit> Also, it's not [key, key, [key]], it's [(node, key, [key])].
20:15:17 <nicktaken> can u show how to create a graph of this: wetgrass -> rain, dogpee, sprinkler
20:15:20 <dmwit> The first doesn't even make sense.
20:16:15 <dmwit> graphFromEdges [(WetGrass, 0, [1, 2, 3]), (Rain, 1, []), (DogPee, 2, []), (Sprinkler, 3, [])]
20:16:30 <dmwit> With a suitable data definition for WetGrass, Rain, DogPee, and Sprinkler, of course.
20:17:36 <ivanm> nicktaken: if you're just wanting to _draw_ this, there's a library you can use
20:18:10 <dons> mwhaha "agda: what the fuck is that shit? is that even programming?"
20:18:14 <dmwit> Oh, yeah, this will likely be a crappy library if you just want to draw or print a graph.
20:18:30 <nicktaken> let g1 = G.graphFromEdges [("Wet grass", 0, [1, 2, 3]), ("Rain", 1, []), ("Dogpee", 2, []), ("Sprinkler", 3, [])]
20:19:11 <ivanm> have a look at flow2dot if you just want to draw stuff
20:19:13 <kohwj> how should i define a function to return "" given an empty Data.Map? " test Data.Map.empty = "" " give me an error: "Qualified variable in pattern: Data.Map.empty"
20:19:25 <nicktaken> http://hpaste.org/10903
20:19:44 <kohwj> one solution is the if statement, but is there another way?
20:19:51 <dmwit> kohwj: If you want a textual representation of a Map, "show" is nice.
20:19:52 <dmwit> :t show
20:19:54 <lambdabot> forall a. (Show a) => a -> String
20:20:00 <nicktaken> ivanm: yes i want to be able to visualize graphs
20:20:05 <dmwit> It won't get you an empty string on empty maps, though.
20:20:06 <nicktaken> what library?
20:20:13 <ivanm> @hackage flow2dot
20:20:13 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/flow2dot
20:20:17 <ivanm> nicktaken: ^^
20:20:21 <kohwj> dmwit: i'm just learning how to use haskell
20:20:23 <ivanm> and then use graphviz on that
20:20:30 <nicktaken> but i prob want to visualize graphs created with Graph...
20:20:45 <dmwit> nicktaken: graphFromEdges has three return results, of which only one is a Graph.
20:20:53 <ivanm> nicktaken: it creates the graphs itself, not the one from Data.Graph
20:20:59 <ivanm> there are alternatives, though
20:21:01 <dmwit> If you want only the graph, you have to use "let (g1, _, _) = graphFromEdges ..."
20:21:27 <kohwj> dmwit: i know that "test [] = "empty" works, but for stuff like Data.Map...
20:21:47 <ivanm> nicktaken: have a look here for a quick run-down I did of graph visualisation in haskell: http://thread.gmane.org/gmane.comp.lang.haskell.cafe/
20:21:49 <dmwit> kohwj: Right.  I think Map purposely hides its constructors.
20:21:59 <lambdabot> Title: Gmane Loom
20:22:04 <dmwit> kohwj: So you have to use the Map module's functions to look at a Map.
20:22:08 <kohwj> dmwit: i see
20:22:15 <dmwit> kohwj: There's Map.empty, which tests whether a map is empty or not.
20:22:25 <kohwj> dmwit: yup, i can use that with "if"
20:22:30 <ivanm> nicktaken: duh, that link was wrong
20:22:32 <dmwit> kohwj: (Similar to the "null" function for lists.)
20:22:54 <kohwj> thank goodness "if" exists. for a moment I thought haskell had nothing in common with imperative languages
20:22:58 <kohwj> :P
20:23:06 <dmwit> heh
20:23:25 <ddarius> Many Haskellers would prefer 'if' be removed and replaced by a function.
20:23:43 <ivanm> ddarius: if' ?
20:23:45 <ddarius> I don't really care if it is removed or not as I rarely use it.
20:23:48 <dcoutts> well, at least overloaded syntax
20:23:51 <ivanm> like the ternary operator in Java, etc.?
20:24:24 <dcoutts> if c then t else f ==> bool c t f  or something
20:24:25 <ddarius> dcoutts: Many people would like to have partially applied uses of if.
20:24:40 <dcoutts> then call the underlying function
20:24:41 <dblazakis> looking for style comments/suggestions -- http://hpaste.org/10904
20:24:48 <ddarius> ivanm: if-then-else is already like the ternary operator is C-style languages.
20:25:09 <ivanm> true
20:25:19 <ivanm> nicktaken: this is the link I meant: http://article.gmane.org/gmane.comp.lang.haskell.cafe/44863
20:25:20 <lambdabot> Title: Gmane -- Mail To News And Back Again
20:26:01 <nicktaken> i thought haskell allowed only allowed one return resukts per function? and wlays of the same type...
20:26:17 <dons> interesting question.
20:26:22 <dmwit> dblazakis: Put dpll in the Either monad, then you don't need two case patterns.
20:26:28 <ivanm> nicktaken: that's why the good Haskell lords provided _tuples_ ;-)
20:26:39 <cjb> nicktaken: you're thinking of C ;-)
20:26:45 <Cale> ehehe
20:26:50 <ivanm> > let plusMinus x = (x+1,x-1) in plusMinus 2 -- nicktaken
20:26:52 <lambdabot>   (3,1)
20:27:24 <dblazakis> dmwit: ah, yeah, i was considering doing that, but hadn't reasoned it out yet
20:27:41 <dmwit> nicktaken: What you say is correct.  However, the value returned can have *lots* of structure.
20:27:47 <Runaro> http://www.randomhacks.net/articles/2007/03/15/data-set-monad-haskell-macros
20:27:49 <lambdabot> Title: How to make Data.Set a monad, http://tinyurl.com/22rhsc
20:28:03 <Runaro> So if Data.Set can be a monad, can it also be applicative?
20:28:09 <dmwit> (Actually, what you say is only partially correct.  We do have return-type polymorphism, which is pretty neat and very useful.)
20:28:49 <ddarius> Runaro: Anything that is an instance of Monad can be an instance of Applicative.
20:29:09 <ddarius> "instance Monad m => Applicative m where pure = return; (<*>) = ap
20:29:12 <ddarius> "
20:29:14 <Runaro> ?type (Control.Applicative.<*>)
20:29:15 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
20:29:40 <Runaro> is there such a thing as Ord (a -> b)?
20:29:55 <bd_> Runaro: what would the semantics of such a thing be?
20:30:10 <Runaro> I don't know
20:30:37 <dmwit> dblazakis: Parsec has a built-in integer parser, I think.
20:30:54 <dmwit> dblazakis: I'd prefer using that to using (liftM read $ many1 digit) as you do.
20:31:03 <bd_> the only value inhabiting all types is the bottom - so such a comparator could only look at the result of (x undefined) - and even then the only answer that'd matter is undefined
20:31:07 <dmwit> Also, many (char ' ') --> spaces
20:31:13 <dblazakis> dmwit: definitely, i missed it, do you know off the top of head what that is?
20:31:23 <dmwit> hm
20:31:25 <dblazakis> dmwit: i thought spaces included newlines
20:31:30 <Runaro> But I wonder how you would construct a Set (a -> b) without an Ord instance for functions. I suppose they would have to be singleton sets, in which case Applicative for Set is equivalent to Functor.
20:31:44 <bd_> Runaro: You don't. You use a list in that case :)
20:31:52 <dmwit> dblazakis: Sorry, you're right, spaces includes " \t\n\r" and maybe others.
20:32:03 <dmwit> dblazakis: Not sure about the name of the integer parser.
20:32:12 <dmwit> dblazakis: It might be in the Parsec.Language submodule.
20:33:13 <dblazakis> maybe in .Token
20:33:30 <dblazakis> ah, nevermind, gotcha
20:35:26 <dmwit> dblazakis: The implementation of checkImpls smells; can you say at a high level what it does?  (It's a bit late here, I'm having trouble understanding it.)
20:37:34 <dmwit> decide _ (Env _ uas) = listToMaybe uas
20:37:46 <dblazakis> dmwit: checks that an implication will not cause a conflict (conflictsVar) and short circuits (skips the recursive propagation -- bcp) if the definitions already exists in the environment
20:39:06 <dblazakis> it's a fold operator, so it propagates failure right without any further evaluation of the right (second) argument
20:44:41 <dblazakis> hmm, i guess it functions as a poor mans Maybe monad?
20:44:44 <dblazakis> that might be cleaner
20:45:27 <dblazakis> except Nothing carries a value... so, more like an Either monad (but is that defined anywhere?)
20:45:52 <nicktaken> ok anyway, lets say i just want a graph from data.graph
20:45:52 <nicktaken> i want to do let g = make a graph shomehow then print graph
20:47:47 <dmwit> dblazakis: Okay, how about this implementation of checkImpls?  (I'll annotate.)
20:49:16 <dmwit> dblazakis: I'm not totally sure it preserves the evaluation order, but I think laziness should help us out there.
20:54:41 <dblazakis> dmwit: yeah, that looks much better -- the nested cases are ugly.  i'm trying to determine if it's more understandable... it's certainly not worse :-)
20:55:11 <dmwit> Yeah, I'm not sure it's better, either.
20:55:41 <dmwit> You should keep in mind that in my current zombie state, I'm offering only tree-level comments, and don't have the processing power to give you forest-level comments.
20:57:44 <dblazakis> heh, i very much understand, thanks for the feedback
21:00:17 <nicktaken> wtf i just dont understand the Graph-library. are vertices and egdes arrays? do i need arrays? cant i just create a f------g graph easily?
21:00:21 <nicktaken> and print it
21:00:27 <nicktaken>  does it not have show implemented?
21:01:02 <dblazakis> nicktaken: what are you trying to do with it?
21:02:13 <nicktaken> just rep some data, does it matter?
21:02:32 <nicktaken> i want to construct a bayesian network eventually
21:02:52 <nicktaken> so a "event"->probability->"cause"
21:02:53 <dons> nicktaken: which graph library are you using?
21:02:59 <nicktaken> Data.graph
21:03:04 <nicktaken> is there another one?
21:03:12 <dons> yes, fgl, Data.Graph.Inductive
21:03:34 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fgl
21:03:48 <lambdabot> Title: HackageDB: fgl-5.4.1.1
21:03:58 <dons> see also http://www.google.co.uk/search?hl=en&as_sitesearch=hackage.haskell.org%2Fcgi-bin%2Fhackage-scripts%2Fpackage&as_q=graph
21:04:00 <lambdabot> Title: graph site:hackage.haskell.org/cgi-bin/hackage-scripts/package - Google Search, http://tinyurl.com/4joszs
21:04:02 <dons> other graph libs on hackage.
21:06:01 <dblazakis> nicktaken: what would you want to print out?
21:06:01 <dons> i would say we don't have a canonical lib for large graphs yet.
21:06:16 <nicktaken> there is no documentation for inductive it seems
21:06:30 <dblazakis> nicktaken: vertices and edges will give you lists
21:06:33 <dblazakis> you can print those
21:07:01 <dblazakis> :t Data.Graph.vertices
21:07:02 <lambdabot> Graph -> [Vertex]
21:07:45 <dons> nicktaken: yes, fgl is missing nice haddocks. it is a bit old-fashioned.
21:08:13 <dblazakis> > let (g, _, _) = Data.Graph.graphFromEdges [] in Data.Graph.vertices g
21:08:15 <lambdabot>   []
21:09:34 <dblazakis> > let (g, _, _) = Data.Graph.graphFromEdges [("a", 0, []), ("b", 1, [])] in Data.Graph.vertices g
21:09:35 <lambdabot>   [0,1]
21:10:36 <dblazakis> > let (g, _, _) = Data.Graph.graphFromEdges [("Wet grass", 0, [1, 2, 3]), ("Rain", 1, []), ("Dogpee", 2, []), ("Sprinkler", 3, [])] in Data.Graph.vertices g
21:10:38 <lambdabot>   [0,1,2,3]
21:10:48 <dblazakis> > let (g, _, _) = Data.Graph.graphFromEdges [("Wet grass", 0, [1, 2, 3]), ("Rain", 1, []), ("Dogpee", 2, []), ("Sprinkler", 3, [])] in Data.Graph.edges g
21:10:50 <lambdabot>   [(0,1),(0,2),(0,3)]
21:14:19 <Olathe> Is there a way to have ghci trace execution of a function ?
21:15:19 <nicktaken> but then ic ant call g
21:15:21 <nicktaken> later
21:16:18 <dblazakis> call g?
21:17:38 <dblazakis> Olathe: i thought there was a :trace in ghci, but i don't see it on the ghci 6.6 on this old ibook
21:18:07 <Olathe> It shows up here.
21:18:07 <Olathe> Prelude StandardNum Data.Ratio> :trace pr (5/(-2))
21:18:07 <Olathe> *** Exception: stack overflow
21:18:16 <dblazakis> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghci-debugger.html#tracing
21:18:18 <lambdabot> Title: 3.5.�The GHCi Debugger, http://tinyurl.com/2orwlb
21:18:24 <dblazakis> ah, too slow ;-)
21:18:56 <Olathe> dblazakis: Thanks :)
21:19:13 <Olathe> Cannot find default module for breakpoint.
21:19:15 <Olathe> Oh dear.
21:20:51 <nicktaken> well i dot he whole let thing. but how do access that later?
21:21:28 <nicktaken> man this whole thing with haskells datastructures seems like it belongs to mathematics and i s just increibly unpractical  for programming
21:21:44 <nicktaken> meh maybe i make my own graph library because this one seems rdiciulously complicated
21:24:07 <Olathe> nicktaken: Well, we won't stop you from making something more practical, of course.
21:25:16 <BMeph> dblazakis: It's a 6.8 feature, 6.6 didn't have it yet. :)
21:25:24 <dblazakis> nicktaken: although, Data.Graph seems barebones, not sure how much simpler it can get
21:25:47 <dblazakis> BMeph: ah, i guessed it was something like that, but was too lazy to look it up :)
21:33:34 <dons> nicktaken: basically, there's a complex research one, fgl, and a bare bones simple one, Data.Graph.
21:33:54 <dons> if you want to roll a nice intermediate one, using say, STUArrays, you'll get a prize.
21:34:30 <dons> Data.Graph is dead easy if you're just doing simple stuff.
21:35:22 <dons> nicktaken: it'd be interesting to see a decent design for a new graph lib.
21:35:34 <mmorrow> it would
21:36:51 <thoughtpolice> nicktaken: how is it unpractical? (curious about your thoughts)
21:37:11 <Olathe> @hoogle a -> [a] -> [a]
21:37:12 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
21:37:12 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
21:37:12 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
21:37:25 <timo> hey guys, im having a simple problem with a program i tried to whip up. i know that the problem arises from incompatable types,  however i don't know how to fix it. would someone mind checking it out (see the hpaste) http://hpaste.org/10906
21:40:49 <mmorrow> nicktaken: here's some graph stuff that just uses lists and is still performs respectably http://hpaste.org/10907
21:41:22 <Olathe> timo: Put fromInteger(round(whatever))
21:42:17 <Olathe> timo: round gives an Integral result, which can't be subtracted from a RealFrac.
21:42:24 <mmorrow> to go from say a  [(a,[a])]   to a    (a -> [a])    all you have to to is  toFun xs x = maybe [] id (lookup x xs)
21:42:26 <Olathe> timo: Or something.
21:43:03 <mmorrow> @type (maybe [] id .) . flip lookup
21:43:04 <lambdabot> forall a a1. (Eq a1) => [(a1, [a])] -> a1 -> [a]
21:43:19 <mmorrow> @type (!)
21:43:21 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
21:43:41 <mmorrow> @type (@)
21:43:43 <lambdabot> parse error on input `@'
21:43:46 <mmorrow> @type (@@)
21:43:47 <lambdabot> Not in scope: `@@'
21:43:54 <dmwit> timo: There's also properFraction, which might be interesting to you.
21:43:58 <dmwit> > properFraction (1.5)
21:44:00 <lambdabot>   (1,0.5)
21:44:10 <mmorrow> @let (@@) = (maybe [] id .) . flip lookup
21:44:11 <lambdabot>  <local>:19:30:
21:44:11 <lambdabot>      Ambiguous type variable `a' in the constraint:
21:44:11 <lambdabot>        `E...
21:44:12 <timo> olathe: thanks. that fixed that particular problem. dmwit: looks interesting, ill check it out. thanks!
21:44:15 <dmwit> :t (==0) . snd . properFraction
21:44:16 <lambdabot> forall b. (RealFrac b) => b -> Bool
21:44:33 <Olathe> Is there a replace function in the standard libraries where replace _ _ [] = []; replace e1 e2 (x:xs) = if x == e1 then e2:replace e1 e2 xs else x:replace e1 e2 xs ?
21:44:38 <mmorrow> @let (@@) = (maybe [] id .) . flip lookup :: (Eq a) => [(a,[b])] -> (a -> [b])
21:44:39 <lambdabot>  <local>:19:7:
21:44:39 <lambdabot>      Ambiguous type variable `a' in the constraint:
21:44:39 <lambdabot>        `Eq...
21:44:51 <Olathe> @hoogle a -> a -> [a] -> [a]
21:44:51 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
21:44:51 <lambdabot> Language.Haskell.TH.Syntax mkNameG_tc :: String -> String -> String -> Name
21:44:51 <lambdabot> Language.Haskell.TH CondE :: Exp -> Exp -> Exp -> Exp
21:45:00 <dmwit> Olathe: It's easy to build out of map.
21:45:03 <mmorrow> @let (xs@@x) = maybe [] id (lookup x xs)
21:45:03 <lambdabot>   Parse error in pattern:
21:45:11 <Olathe> dmwit: Sure.
21:45:13 <mmorrow> @let xs@@x = maybe [] id (lookup x xs)
21:45:15 <lambdabot>  Defined.
21:45:16 <dmwit> :t \x y -> map (\z -> if x == z then y else x)
21:45:18 <lambdabot> forall a. (Eq a) => a -> a -> [a] -> [a]
21:46:35 <dmwit> ?pl \x y -> map (\z -> if x == z then y else x)
21:46:36 <lambdabot> (map .) . (flip =<< (flip .) . flip . (if' .) . (==))
21:46:42 <dmwit> there ya go!
21:47:24 <dmwit> ?pl \x y xs -> xs >>= \z -> [y | z == x] ++ [z | z /= x]
21:47:26 <lambdabot> ((=<<) .) . ap (flip . (liftM2 (++) .) . flip flip [] . ((flip . ((:) .)) .) . flip (flip . ((==) .) . (|))) (flip flip [] . ((:) .) . (. join (|)) . (/=))
21:47:32 <dmwit> unlikely
21:47:34 <dmwit> (|)?
21:48:13 <dmwit> I always forget that ?pl doesn't do comprehensions. =P
21:52:54 <ivanm> if I import something like Data.Map qualified, but without specifying an "as" statement, do the functions then get called something like "Data.Map.assocs", or just "Map.assocs"?
21:53:25 <Olathe> > (pi :: CReal) == pi + 1/10^100
21:53:26 <lambdabot>   True
21:53:28 <Olathe> :(
21:53:38 <Olathe> > (pi :: CReal) - (pi + 1/10^100)
21:53:39 <lambdabot>   mueval: Prelude.read: no parse
21:53:44 <Olathe> No parse ?
21:53:45 <thoughtpolice> ivanm: if you do 'import qualified Data.Map' then everything is referred to with the 'Data.Map.' prefix
21:53:55 <ivanm> thoughtpolice: *nod* thought so, just wanted to check
21:54:11 <Olathe> > (pi :: CReal) - (pi + 1/(10^100))
21:54:12 <lambdabot>   0.0
21:54:40 <Olathe> > reverse $ showCReal 110 $ (pi :: CReal) - (pi + 1/(10^100))
21:54:41 <lambdabot>   "10000000000000000000000000000000000000000000000000000000000000000000000000...
21:57:32 <nicktaken> i must say the attitude here is lightyears from #lisp. and that is very good... i dont want to spit on haskell because it has some very cool features, just my head isnt really wired for it. coming from python/java/c
21:58:19 <solrize_> nothing that a little rewiring wouldn't fix ;)
21:59:46 <sbahra>  Why, what is the attitude in #lisp, nicktaken?
22:00:26 * ivanm passes nicktaken some wire cutters
22:00:34 <ivanm> here, cut out all that evil imperative stuff! :p
22:02:06 <ozy`> > reverse [1..]
22:02:09 <mmorrow> or just still do it, but with 10x the efficiency ;)
22:02:16 <lambdabot>   mueval: Prelude.read: no parse
22:03:45 <nicktaken> if i have a type that has an argument that is data.Map
22:03:53 <nicktaken> how do i declare a Map type?
22:03:57 <nicktaken> M.Map doesnt work
22:04:33 <mmorrow> import Data.Map (Map)
22:04:38 <dmwit> ivanm: Suppose you have a module "Foo.Bar" with the function "foo" in it.  An import always defines the name "Foo.Bar.foo".  The name "foo" is also defined unless you specify "qualified".  The name "Quux.foo" is also defined if you specify "as Quux".
22:04:41 <mmorrow> import qualified Data.Map as M
22:04:54 <dmwit> ivanm: That is, "qualified" and "as" are orthogonal.
22:04:56 <mmorrow> then you can use "Map" unqual for convenience in type sigs
22:05:11 <mmorrow> but all Data.Map everything else is qualified by "M"
22:05:13 <ivanm> dmwit: yeah
22:05:21 <dmwit> There are also explicit import lists and the hiding list, but we won't go there. =)
22:05:46 <ivanm> I was just looking at the report page though, and they don't cover path-based modules, so I wasn't sure if the whole thing was used as the default "as" identifier
22:06:17 <dmwit> Yeah, the report doesn't have hierarchical modules, which is a shame.
22:06:22 <ivanm> (section 5.3.4 in http://www.haskell.org/onlinereport/modules.html )
22:06:22 <lambdabot> Title: The Haskell 98 Report: Modules
22:06:28 <b\6> right now i'm splitting a list of jobs into n chunks and giving each chunk to one of n threads. they do the work and give me the answers over a Chan. i'd rather that the threads just take jobs off of the list (safely by locking or something). i don't know how.
22:06:28 <ivanm> dmwit: because they didn't think of it back then?
22:06:32 <dmwit> right
22:06:39 <dmwit> well...
22:06:50 <dmwit> They didn't imagine there would be so many libraries that it would be necessary, probably.
22:06:55 <nicktaken> mmorro, oh that worked, but if i use import qualified as M then M.Map doesnt work and M neither
22:07:35 <ivanm> is it safe to use FilePath's addExtension and splitExtension to get/set the actual module name from it's path?
22:07:39 <dmwit> nicktaken: You have to specify the key and value types, of course; are you doing that?
22:07:40 <nicktaken> actually it doesnt work
22:07:43 <dmwit> M.Map key value
22:07:46 <nicktaken> data Edge = Edge { hash :: Map } deriving (Eq, Ord, Show)
22:07:55 <rwbarton> b\6: How about writeList2Chan the list to another Chan, and have the threads read from that?
22:07:57 <mmorrow> this will turn a list of any type that is Ord into a histogram
22:08:04 <dmwit> nicktaken: Right, you need to specify more types for Map.
22:08:08 <mmorrow> M.toList $ foldl' (\m x -> M.insertWith' (+) x 1 m) M.empty (take 10000 (randomRs (0,9::Int) (mkStdGen 0)))
22:08:10 <nicktaken> dmwit: but im writing a data, i dont know before hand, oh wiat i see
22:08:13 <thoughtpolice> sbahra: from what I hear #lisp can be somewhat asshole-ish, OTOH, it's regarded to have one of the lowest signal-to-noise ratios ever
22:08:14 <dmwit> nicktaken: Map is polymorphic, and you have to pin down the polymorphism.
22:08:21 <mmorrow> > Data.Map.empty
22:08:24 <lambdabot>   /tmp/5818367812283885687:67:32: Not in scope: `Data.Map.empty'
22:08:27 <b\6> rwbarton: how do the threads read safely? 'atomically'?
22:08:33 <dmwit> nicktaken: So, for example, you could do data Edge k v = Edge { hash :: Map k v }.
22:08:35 <thoughtpolice> sbahra: from what I've seen though in general the lisp community somewhat seem like dicks :/
22:08:41 <rwbarton> b\6: Chan is automatically safe.  I think it uses MVars internally
22:08:54 <dmwit> nicktaken: Note that I don't think hash is a good name, since Map is a tree, not a hash.  But that's up to style, I guess.
22:08:58 <mmorrow> yeah MVars
22:09:00 <rwbarton> i.e. readChan is an atomic get/remove
22:09:09 <b\6> rwbarton: so if multiple threads do a read, only one will get the next element?
22:09:47 <thoughtpolice> sbahra: ex. http://groups.google.com/group/comp.lang.lisp/tree/browse_frm/thread/88a36fb2c239a44e/
22:09:48 <mmorrow> b\6: threads queue up waiting for their turn at an MVar
22:09:49 <rwbarton> b\6: That is my understanding.  However I haven't read the code to be 100% sure :)
22:09:49 <lambdabot> Title: comp.lang.lisp | Google Groups, http://tinyurl.com/3sg7md
22:10:36 <dmwit> Man, explicit import lists and hiding lists should use [], not ().
22:10:42 <dmwit> I wonder why they didn't think of that.
22:10:47 <mmorrow> b\6: if you want to be able to do something like  (getChan >> look at val >> ugh put it back) atomically you can use stm
22:10:59 <rwbarton> dmwit: Because the symbols you're importing might not all have the same type :)
22:10:59 <dmwit> b\6: You can create broadcast Chans if you need to.
22:11:01 <mmorrow> the TChan interface if pretty much identical to Chan's
22:11:02 <sbahra> hahaha thorkilnaur
22:11:05 <sbahra> thoughtpolice
22:11:07 <dmwit> rwbarton: ah =P
22:11:14 <mmorrow> you just have to wrap STM stuff in atomically
22:11:35 <b\6> mmorrow: i just need something like a mutex-protected list/stack so that all threads can be trying to pop the next job and sensible stuff happens.
22:11:50 <ivanm> thoughtpolice: signal-to-noise ratio? I guess ours must get pretty bad at times... ;-)
22:12:05 <thoughtpolice> @quote off topic
22:12:06 <lambdabot> No quotes for this person. Maybe you made a typo?
22:12:12 <thoughtpolice> hm
22:12:22 <ivanm> @quote topic
22:12:22 <lambdabot> DRMacIver says: #haskell doesn't so much wander off topic as orbit it. :)
22:12:33 <thoughtpolice> there was a better one
22:12:35 <thoughtpolice> @quote topic
22:12:36 <lambdabot> qwe1234 says: lol, thanks for the pointless offtopic post
22:12:41 <ivanm> there was a really good one about #haskell being more off-off-topic, but it's been lost :(
22:12:41 <BMeph> ivanm: Especially when Coq of a shootout comes up in conv... ;)
22:12:46 <thoughtpolice> ivanm: yeah that one
22:12:49 <ivanm> BMeph: heh
22:12:54 <BMeph> *or
22:13:02 <ivanm> thoughtpolice: lambdabot probably died after it was @remember'd
22:13:05 <thoughtpolice> sbahra: yeah, it's amazing isn't it?
22:13:13 <mmorrow> b\6: hmm. maybe have an  MVar (Chan a)  so the threads queue up on the outer mvar (since i'm not 100% sure the behaviour of the Chan implem)
22:13:46 <BMeph> Haskell: It's a language and a strange atractor! :)
22:13:56 <b\6> mmorrow: thanks.
22:14:31 <mmorrow> oh yeah, or you could dupChan a chan and multicast i believe
22:14:45 <mmorrow> (i haven't used dupChan, but it looks useful)
22:16:20 <sbahra> "Both Haskell's built-in list type and the DList  type that we defined above have poor performance characteristics under some circumstances. The Data.Sequence module defines a Seq container type that gives good performance for a wider variety of operations."
22:16:25 <sbahra> What circumstances are these?
22:16:52 <ivanm> sbahra: were's this from?
22:17:42 <b\6> mmorrow: hmm. but it's like all threads should see the same pool of jobs, but they should race to get the next job. like synchronize { jobs.pop } so that no two threads get the same job.
22:17:58 <bd_> sbahra: accessing items from the end of the list; appending lists; editing the middle of the list; etc
22:18:12 <bd_> sbahra: otoh, Data.Sequence can't represent an infinite list
22:18:28 <sbahra> ivanm, "real world haskell"
22:18:39 <sbahra> bd_, thanks, I get it.
22:19:10 <ddarius> > last [0..]
22:19:18 <lambdabot>   mueval: Prelude.read: no parse
22:19:22 <ivanm> sbahra: oh?
22:19:23 <rwbarton> b\6: I think Chans are discussed in the Tackling the Awkward Squad paper
22:19:33 <b\6> rwbarton: ok, thanks.
22:26:07 <dmwit> ?pl \xs ys -> filter (`elem` xs) ys
22:26:07 <lambdabot> filter . flip elem
22:27:02 <mmorrow> b\6: i just thought thought about what i said about putting the Chan in an MVar
22:27:28 <mmorrow> i think that's a bad idea because Chan are made of MVars anyway
22:27:40 <b\6> mmorrow: yeah, awkward squad leads me to believe it's not needed.
22:27:58 <b\6> seems like plain chan will be pretty cool.
22:28:33 <mmorrow> yeah, definitely. i mean, using them for that is their primary use-case. i wasn't thinking straight for a second there
22:28:40 <solrize_> plain chans are pretty good except they are unbounded, there is an exercise in rwh to implement bounded chans
22:28:58 <b\6> yeah, i remember reading about that. but in this case i know the input size.
22:29:30 <mmorrow> they're pretty much lists, with head and tail mvars
22:34:20 <sbahra> Who do I talk to again to have lambdabot join a channel?
22:34:28 <sbahra> iirc, Cale?
22:35:01 <sjanssen> sbahra: to join permanently, yes
22:35:07 <sjanssen> sbahra: which channel do you want?
22:35:38 <sbahra> ##FreeBSD
22:36:16 <ivanm> sbahra: what, lambdabot isn't overloaded enough as it is?
22:36:27 * ivanm thinks some serious channel filtering needs to be done to lambdabot 
22:36:29 <ivanm> @seen lambdabot
22:36:29 <lambdabot> Yes, I'm here. I'm in ##hrg, #xmonad, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosx, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.it,
22:36:29 <lambdabot>  #haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-overflow, #haskell-hac07, #haskell-books, #haskell-blah, #haskell, #ghc, #gentoo-
22:36:29 <lambdabot> uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #darcs, #arch-haskell and ##logic
22:36:34 <sbahra> It'll be nice for haskell advocacy.
22:36:40 <sbahra> And ##FreeBSD has 300+ users.
22:36:43 <ivanm> ^^ how many of those are actually haskell related?!?!?!
22:37:04 <ivanm> sbahra: hmmmm.... you probably shouldn't tell them that dons used to use OpenBSD then... ;-)
22:37:17 <sbahra> Why would dons do that?
22:37:21 <sbahra> Did he think it was secure?
22:37:43 <ivanm> *shrug* dunno, but he's now switched to arch
22:37:52 <nicktaken> data Vertex v = Vertex { value :: v } deriving (Eq, Ord, Show)
22:37:59 <nicktaken> why is it possible to set the type as v?
22:38:18 <ivanm> nicktaken: because you specified v on the LHS as a type "variable"
22:38:55 <ivanm> so you can have say "Vertex Int", "Vertex Bool", "Vertex (Vertex (Vertex Int)))", etc.
22:41:00 <sjanssen> lambdabot: @join ##FreeBSD
22:41:06 <sjanssen> @seen lambdabot
22:41:07 <lambdabot> Yes, I'm here. I'm in ##freebsd, ##hrg, #xmonad, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #macosx, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #
22:41:07 <lambdabot> haskell.it, #haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-overflow, #haskell-hac07, #haskell-books, #haskell-blah, #haskell, #ghc,
22:41:07 <lambdabot>  #gentoo-uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #darcs, #arch-haskell and ##logic
22:41:29 <mmorrow> nicktaken: in the same way as you can set the value v in (v,v) to (4,4). just s/values/types/
22:41:53 <sbahra> thanks
22:41:56 <sbahra> sjanssen
22:42:01 <mmorrow> but once the code actually gets to the point of running, the types are set in stone
22:42:03 <dons> sjanssen: freebsd? are they ok with that?
22:42:14 <sbahra> I am
22:42:17 <sjanssen> sbahra: remember you'll need to talk to Cale to make sure lambdabot is permanently there
22:42:22 <sbahra> sjanssen, cool, thanks.
22:42:25 <sjanssen> sbahra: are you an op there of some sort?
22:42:30 <sbahra> Yes
22:42:37 <dons> ah ok. good.
22:42:46 <dons> we don't want lambdabot in places she's not wanted.
22:42:51 <ddarius_> What do you need a Haskell evaluating bot for?
22:43:03 <dons> looking up hoogle queries?
22:43:23 <sbahra> Personal use. But I think users will find it useful in general, some of its features (tinyurl, for 1), calculation, etc...
22:43:37 <sbahra> But basically, ddarius_, propaganda
22:43:38 <mmorrow> @nixon
22:43:38 <lambdabot> Politics would be a helluva good business if it weren't for the goddamned people.
22:43:45 <dons> yeah, nixon has uses.
22:44:02 <mmorrow> one of my favorites
22:44:30 <dons> @b52s
22:44:31 <lambdabot> She drove a Plymouth Satellite faster than the speed of light!
22:44:36 <nicktaken> wtf namespace problems everywher
22:44:49 <mmorrow> nicktaken: manage your import list
22:45:07 <thoughtpolice> @protontorpedo
22:45:07 <lambdabot> i have a win xp box
22:45:17 <mmorrow> lol
22:45:33 <sbahra> obraun, ping?
22:45:38 <mmorrow> @quote jack-nicholson
22:45:39 <lambdabot> jack-nicholson says: You only lie to two people in your life, Linux fanboys and the police. Neither can handle the truth.
22:46:15 <mmorrow> we need some dolph lundgren quotes from that same sight. if i could only remeber the url...
22:48:18 <kohwj> does anyone know how to use Safe.readMay?
22:49:55 <mmorrow> hahaha. found it
22:49:59 <mmorrow> http://www.promotinglinux.com/truth/
22:50:04 <lambdabot> Title: The Truth™ | PromotingLinux.com
22:50:05 <mmorrow> nest site evar
22:50:09 <mmorrow> *best
22:50:32 <b\6> kohwj: Prelude Safe> readMay "123" :: Maybe Int
22:50:41 <b\6> kohwj: Prelude Safe> readMay "123x" :: Maybe Int
22:50:47 <mmorrow> the heavy use of dolph lundgren with the ear necklace in geniush
22:51:21 <kohwj> b\6: wow, thank you. how does one decipher "Read a => String -> Maybe a"?
22:51:30 <kohwj> b\6: from http://www.cs.york.ac.uk/fp/haddock/safe/Safe.html
22:51:32 <lambdabot> Title: Safe
22:52:25 <kohwj> b\6: assuming that one can learn how to use readMay from the method signature
22:52:33 <b\6> kohwj: the stuff on the left of the => are restrictions. so a, whatever type it is, needs to be an instance of Read. so the function takes a String and returns Maybe a. Maybe has two constructors, Just and Nothing.
22:52:43 <mmorrow> "During the Linux initiation, new members ["noobs"] are forced to listen to the ramblings and incoherent speeches of other Linux Lifers until complete mental breakdown occurs, after which the programming can proceed. In this decrepit state, they are encouraged to eat their own feces while meditating on the sounds and sights of HANZEL UND GRETYL."
22:53:21 <mmorrow> "Rejection of god, and perpetual perversion ensures. This is the ultimate state of a Linux user. A psychological state lower than the EMO."
22:53:59 <b\6> mmorrow: worried about readChan blocking. i can check if the chan is empty with another function, but then there's a window where some other thread could grab the last job. then the current thread would hang.
22:54:46 <mmorrow> b\6: hmm. the whole point of it is to block.
22:55:11 <mmorrow> there's a good wiki page on something that sound similar at first blush to your situation
22:55:14 <rwbarton> b\6: Use a Chan of (Maybe task), and put a whole bunch of Nothings at the end
22:55:15 <b\6> yeah, blocking is great sometimes. but then we run out of jobs.
22:55:28 <b\6> oh, ok.
22:55:36 <b\6> yeah, makes sense.
22:55:48 <mmorrow> yeah, i've used maybe for that in a chan before
22:56:02 <b\6> need as many Nothings as you have threads.
22:56:21 <b\6> or maybe even ++ repeat Nothing.
22:56:33 <sjanssen> b\6: there is always unGetChan
22:56:39 <mmorrow> (actually a TChan, where you can atomically put back Nothings though..)
22:57:02 <sjanssen> b\6: but it is probably better to have a single "finished" variable that your master thread writes to
22:57:42 <mmorrow> b\6: check out here: http://haskell.org/haskellwiki/Concurrency_demos
22:57:43 <lambdabot> Title: Concurrency demos - HaskellWiki
22:57:46 <mmorrow> in particular this one
22:57:51 <mmorrow> http://haskell.org/haskellwiki/Concurrency_demos/Graceful_exit
22:57:52 <lambdabot> Title: Concurrency demos/Graceful exit - HaskellWiki
22:58:09 <b\6> checking, thanks.
22:59:11 <mmorrow> ooh, this one's new i think (or new as of whenever i last was here). it looks directly applicable to you http://haskell.org/haskellwiki/Implement_a_chat_server
22:59:13 <lambdabot> Title: Implement a chat server - HaskellWiki
22:59:40 <b\6> looks cool.
22:59:48 * mmorrow bookmarks 4 times and plans his chat server
23:02:04 <mmorrow> friggin sweet. i love how you can have useful and functional network servers in haskell in less code than it takes to fill vertically a 1024x768 laptop screen
23:02:13 <dons> hehe
23:02:14 <b\6> yeah.
23:04:59 <lucca> okay, if you are using the STM stuff, what is the best way deal with more complicated data structures like trees and hashes?
23:05:14 <the_unmaker> anyone planning a web browser in haskell?
23:05:19 <b\6> ugh.
23:06:50 <mmorrow> the_unmaker: that's be rad. i'm down to help if someone else is all about the html parsing/rendering ;)
23:07:01 <mmorrow> s/that's/that'd/
23:07:29 <mmorrow> that seems like the (epicly huge) barrier
23:07:39 <b\6> i just wouldn't want to touch it with a billion foot pole because of all the horrible formats involved and the fact that you can't just say TOTALLY ILLEGAL JUNK when it doesn't parse.
23:08:18 <b\6> i have no idea why it came to be that html and friends get to be randomly screwed up and browsers are just supposed to guess. we don't do that with, say, exes that contain illegal opcodes.
23:08:31 <lucca> so use GLR and a more permissive grammar and take the best scoring match
23:08:58 <mmorrow> lucca: did you just volunteer to do the html parsing/rendering??? ;)
23:09:05 <lucca> no ^_^
23:09:09 <mmorrow> heh
23:09:35 <lucca> b\6: they do sorta; it's called java
23:09:48 <b\6> not sure if you're joking.
23:09:53 <Cthulhon> Parsing wouldn't be that hard.  There are certainly quirks, but it's all fairly well documented.  Rendering would be the hardest part.
23:09:57 <lucca> heh
23:10:02 <mmorrow> either way it's funny
23:10:16 <mmorrow> Cthulhon: for sure
23:10:32 <mmorrow> there's already at least one html parser on hackage
23:10:55 <lucca> rendering and maintaining the DOM in a js-modifiable manner and re-rendering as needed based on js changes and images loading... that's the tricky part I suspect
23:11:02 <mmorrow> javascript parsers (and even an js interp) as well
23:11:34 <lucca> the js implementation itself shouldn't be too bad, depending on what sorts of speed you're looking for
23:11:46 <ozy`> b\6: it's because the canonical browsers provided buggy and loosely defined HTML implementations
23:11:49 <lucca> check out the papers google has on what they do in Chrome
23:11:53 <mmorrow> lucca: yeah. i think about what strategy browsers are using and am just drawing a blank.
23:11:58 <Cthulhon> Even maintaining and re-rendering the DOM isn't very hard compared to rendering anything at all according to the W3C specs.
23:12:07 <mmorrow> lucca: hmm. i will
23:12:17 <ozy`> and HTML was touted as being easy to use, and people found ways to exploit bugs
23:12:18 <lucca> Cthulhon: arguably no one has done that yet, so clearly :p
23:12:42 <b\6> ozy`: whatever, it's bad. it makes it so difficult when pages can be arbitrarily bad and you're just supposed to deal.
23:13:05 <lucca> ozy`: there's also algorithmic complexity attacks; overflowing various stacks.  Netscape was notorious for crashing if you nested <table> too deeply
23:13:20 <Cthulhon> Things like float rules and the box model would be the hardest.
23:13:39 <ozy`> lucca: yeah, it was pretty terrible.
23:13:49 <lucca> couldn't be worse than TeX heeeh
23:14:22 <mmorrow> i volunteer for things javascript (not having to do with rendering). just putting that out there.
23:16:00 <lucca> I don't think setting out to make a general-purpose web browser is a good tactic there
23:16:17 <lucca> instead look at what niche things haskell could do rather well, like the xmonad project did
23:16:25 <mmorrow> i always find myself wanting a browser that (1) is a blank window. (2) is very lightweight. (3) (obviously renders html to said window) and has a good js interp. (4) nothing else.
23:16:50 <mmorrow> and (4) with a !
23:16:55 <lucca> defining "good" js interp is sadly subjective
23:17:50 <mmorrow> by good i mean doesn't leak memory, doesn't lock up when going into a tight loop, has a hackable interface
23:18:59 <lucca> well many of these components can be implemented as separate libraries (js, html analysis, w3c-style layout)
23:19:27 <lucca> and of course the network code to grab things and potentially cache, negotiate proxies, etc
23:20:37 <mmorrow> adding things that i'd personally like, but wouldn't expect to ever see in the near future.. threaded js exec, more than one level of permissions ==> safe level = when browsing. pull-out-the-stops level for when you want to use the browser like it was a shell/ghci
23:21:26 <mmorrow> and it'd be easy to add a webserver to the browser so it can talk to itself/others
23:23:14 <mmorrow> lucca: yeah, and the network stuff too.
23:23:38 <mmorrow> it seems like everything is there and doable, but i have no idea about the rendering
23:24:27 <lucca> set everything up with springs and masses and let it bounce around for a couple steps, heh
23:25:39 <mmorrow> lucca: totally! i've actually thought along those lines...usually when i've spent the previous 5 minutes considering what it'd take to render it, coming up with nothing, then grasping for /something/. hehe
23:26:49 <mmorrow> but i mean, who says it has to comply with any standards. the fact that it renders anything even close to usable as an interface to the other features seems like a win to me
23:29:21 <mmorrow> in other news, this irc server code on the wiki just gave me a "oh. duh." moment with fix
23:30:00 <mmorrow> i've always used newtypes to get this behaviour before, never realizing how easy it is to do with plain fix
23:30:07 <mmorrow> (in ghci)
23:30:09 <mmorrow> fix (\go -> getLine >>= \l -> if l==":q" then return () else print l >> go)
23:30:13 <mmorrow> instant repl
23:30:18 <the_unmaker> isnt html supposed to be simple?
23:30:22 <mmorrow> replace print with whatever
23:30:34 <ivanm> the_unmaker: lol
23:40:16 <ddarius_> mmorrow: Why would you need newtypes?
23:40:57 <the_unmaker> I mean it seems with wordpress html and software integration
23:41:15 <the_unmaker> idiot companies are making ti hard to use cool software by barfing out incomplete ragged implementations
23:41:41 <the_unmaker> and a shit lang liek java thrives by making idiot consultant rich integrating all the garbage
23:42:47 <mmorrow> ddarius: i think actually this fix won't work for all the stuff i thought for a second. so the newtypes come in when you need to use infinite types..
23:44:43 <solrize_> where's the eval in that repl?
23:45:17 <rwbarton> how about  forever $ ...
23:46:01 <rwbarton> @seen dons
23:46:01 <lambdabot> dons is in #haskell, #xmonad, #darcs, #ghc and #arch-haskell. I last heard dons speak 43m 47s ago.
23:55:48 <dmwit> rwbarton: forever never terminates...
23:56:18 <dmwit> :t filterM
23:56:21 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
23:57:22 <rwbarton> dmwit: right, I misparsed the if-then-else precedence
23:58:26 <dmwit> :t fix (\go -> getLine >>= \l -> when (l /= ":q") (print "eval" >> go))
23:58:27 <lambdabot> IO ()
23:58:46 <mmorrow> @tell ddarius so newtypes for stuff like this (which i don't see how to fit into Data.Function.fix's type sig) http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=79#a79
23:58:47 <lambdabot> Consider it noted.
