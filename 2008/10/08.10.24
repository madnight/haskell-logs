00:00:08 <solrize> cale, correct, just like the existence of odd perfect numbers is (maybe) unprovable, but still either true or false
00:00:24 <Cale> solrize: Right, every statement is either true or false in that sense.
00:00:37 <solrize> even CH?
00:00:45 <Cale> yes
00:00:50 <solrize> ok, that's a platonistic view
00:00:55 <Cale> No it isn't.
00:01:20 <lament> it's like perl
00:01:25 <lament> "any junk you type in will compile"
00:02:06 <Cale> It's like saying... Suppose that G is a group. Then either G has an element of order 2 or it doesn't.
00:02:07 <lament> "anything you can say has a meaning"
00:02:11 <lament> clearly not true in real life
00:02:15 <Cale> Sure, that's true.
00:02:16 <lament> lkcrxqjkcrxgqlr :)
00:02:40 <lament> not true in programming: not all programs pass type-checking
00:02:47 <lament> so why should it be true in math?
00:02:52 <Cale> lament: Oh, I wasn't referring to you.
00:03:02 <ttt--> hi, is there an inverse of M-, in haskell-mode ? (one that jumps back)
00:03:38 <Cale> lament: What do you mean by any junk you type in has a meaning?
00:03:44 <solrize> http://math.stanford.edu/~feferman/papers/predarith.pdf   i think this is what feferman wants to use instead of set theory
00:03:45 <lambdabot> Title: Predicative foundations of arithmetic
00:04:03 <Cale> solrize: Do you get what I mean about that?
00:04:15 <Cale> solrize: CH is not decided by the set axioms.
00:04:37 <lament> Cale: any junk like a formula that expresses a real number
00:04:42 <Cale> solrize: So there are models in which it's true, and models in which it's false, and models in which it's still undecidable.
00:05:05 <solrize> undecidability is about theories, not models
00:06:06 <Cale> solrize: Well, models for which there is no proof of the statement that CH is true for that model or its negation.
00:06:19 <solrize> i think we're all somewhat platonistic towards N.  if two axiom sets assign differing truth values to the same statement about N, then one of them is unsound
00:06:28 <Cale> Really?
00:06:37 <Cale> I don't think so.
00:06:39 <rwbarton> I think Cale means that inside an "ambient" set theory you can construct models of ZFC for which the ambient theory cannot prove CH or ~CH.
00:06:45 <mattam> What's CH refering to?
00:06:54 <Cale> mattam: Continuum hypothesis.
00:06:58 <mattam> Oh.
00:07:08 <Cale> mattam: The only salient feature of which is that it's undecidable in ZFC.
00:07:31 <Cale> rwbarton: exactly.
00:07:46 <mattam> In which models is it true?
00:07:53 <solrize> what's an "ambient" theory?
00:08:03 <solrize> mattam, it's true in V=L
00:08:18 <solrize> i.e. construtable set theory
00:08:20 <Cale> solrize: The one which your model theory is sitting in.
00:08:21 <solrize> constructable
00:08:32 <mattam> V=L?
00:08:59 <Cale> solrize: That is, we're studying models of ZFC, so we must have some outside theory of sets which we're using to construct models of ZFC.
00:09:19 <solrize> mattam., http://en.wikipedia.org/wiki/V=L
00:09:20 <lambdabot> Title: Axiom of constructibility - Wikipedia, the free encyclopedia
00:09:31 <solrize> cale, right, ok
00:09:41 <lament> constructible just means "well-typed", right?
00:09:47 <mattam> It that a non-trivial model?
00:09:55 <solrize> mattam, yes, very non-trivial :)
00:10:07 <solrize> it is how Godel proved CH is consistent with ZFC
00:10:42 <mattam> Wow this looks interesting. How could I miss that...
00:11:41 <solrize> basically it says, ZFC starts with the empty set and gives a bunch of axioms for constructing new sets, and V=L asserts that those constructions give you all the sets
00:11:50 <solrize> ie.. there are no inaccessible cardinals, etc
00:12:02 <Cale> I could live with V=L.
00:12:14 <Korollary> Doesn't ZFC assume an infinite set exists without a way to construct it?
00:12:26 <solrize> korollary, yes, that's the axiom of infinity
00:12:29 <solrize> it asserts that N exists
00:12:35 <rwbarton> That counts as "constructing" in this context
00:12:40 <solrize> or "omega" to use the french term ;)
00:13:02 <Cale> Korollary: The axiom of infinity and the axiom of choice are included in the allowed constructions :)
00:13:37 <solrize> cale, here is the thing, there is some proposition P about natural numbers, such that P is true in some model of ZFC and ~P is true in some other model
00:13:39 <Cale> Well, you can define a well-ordering on L, which gives you the axiom of choice anyway :)
00:13:44 <solrize> that doesn't bother us, it just means ZFC is incomplete
00:13:52 <Cale> solrize: right.
00:14:12 <Cale> It means that there are different kinds of natural numbers.
00:14:17 <solrize> but, we would still say that P is either true or false, that one of those models of ZFC is "right" and the other one is "wrong".  or rather the terms are "sound" and "unsound"
00:14:24 <Cale> Nope.
00:14:26 <Cale> I wouldn't.
00:14:32 <Cale> They're both equally good.
00:15:14 <Cale> Just like lots of groups satisfy the group axioms, and they're all equally good groups.
00:15:14 <solrize> ok, that would be considered a weirdo view :)
00:15:26 <Cale> I think this is a pretty standard view.
00:15:39 <Cale> At least in my part of the world.
00:15:57 <solrize> ???? i don't think so
00:16:30 <Cale> Saying that one perfectly good formal system is "right" and the other is "wrong" is silly.
00:16:50 <Cale> It's like asking if a chair is true or not.
00:17:14 <dolio> Platonism isn't particularly popular anymore, is it?
00:17:14 <Cale> Truth doesn't apply to it as a whole. Truth of statement is only defined *inside* formal systems.
00:17:22 <Cale> statements*
00:17:30 <dolio> Amongst mathematicians, anyhow.
00:17:40 <Cale> dolio: yeah. It's all but dead.
00:17:55 <solrize> do you know what goodstein's theorem is?
00:18:14 <Cale> yep
00:18:30 <Cale> (I thought it rang a bell and looked it up, and yeah, I've seen it before)
00:18:34 <solrize> would you say that G and ~G are equally valid, where G=goodstein's theorem?
00:18:44 <Cale> In which system?
00:18:51 <solrize> statements about N
00:19:00 <Cale> PA?
00:19:04 <Cale> ZFC?
00:19:06 <solrize> N
00:19:16 <Cale> N is a set in ZFC. Do you mean that N?
00:19:45 <solrize> ZFC is not a set, it doesn't have members :)
00:19:55 <solrize> or rather, it doesn't have members that are sets :)
00:20:13 <Cale> ZFC is a formal system which we use to talk about sets, and N is one of those sets.
00:21:00 <Cale> It doesn't make sense to talk about the natural numbers independent of a particular axiomatisation.
00:21:08 <rwbarton> Do you think there are systems X and X' which are equally valid such that X proves G and X' proves ~G
00:21:41 <Cale> Tell me what are you assuming about the natural numbers, and I'll tell you if G and ~G are still equally good or not. (Or I will take a long time to not give you any answer ;)
00:21:51 <rwbarton> Presumably you don't think a system X'' that proves 2+2=5 is valid, though.
00:22:00 <solrize> cale, i'm assuming the 2nd order peano axioms
00:22:16 <Cale> G is provable in second order PA
00:22:24 <Cale> So ~G isn't good then.
00:22:26 <solrize> ok
00:23:44 <Cale> In first order PA, the matter about whether G is true or not is unresolved, similar to how the group axioms don't tell you if there's an element of order 2.
00:24:18 <Cale> So ~G is just as good an axiom to throw in as G is.
00:24:30 <quicksilver> ...because there are "systems" (technically, models) satisfying PA in which ~G is true.
00:24:41 <quicksilver> so PA doesn't tell us anything about G.
00:24:49 <solrize> i'm not sure whether the 2nd order peano axioms prove G
00:25:05 <quicksilver> intuitively this tells us that PA is a bit weak, since G is intuitively obvious.
00:25:19 <rwbarton> So is AC :)
00:25:20 <quicksilver> However, quicksilver's intuition is not a mathematical foundation.
00:25:22 <quicksilver> pity.
00:25:34 <dolio> It totally should be.
00:25:35 <solrize> G is provable if we assume PA is consistent
00:25:57 <Cale> But PA can't prove its own consistency either.
00:26:04 <solrize> right
00:26:15 <Cale> It would be perfectly acceptable for PA to be extended with an axiom that denies its own consistence.
00:26:20 <Cale> consistency*
00:26:41 <solrize> right, however if PA is actually consistent then adding that axiom would make it unsonud
00:26:43 <solrize> unsound
00:26:53 <Cale> Sure.
00:27:10 <Cale> But we only care about that when looking in on PA from a larger system.
00:27:12 <papermachine> brb
00:27:20 <quicksilver> if it's not actually consistent, it's unsound anyway :)
00:27:47 <quicksilver> "PA's consistency proves G" <-- I didn't know that. Or I'd forgotten it.
00:27:50 <quicksilver> why is that?
00:28:51 <solrize> basically PA's consistency means you can do induction over arbitrary trees
00:28:55 <solrize> and that lets you prove G
00:29:49 <solrize> http://en.wikipedia.org/wiki/Omega-rule#.CF.89-logic   <-- I guess this can't be expressed in 1st order logic?
00:29:50 <lambdabot> Title: ω-consistent theory - Wikipedia, the free encyclopedia
00:31:14 <solrize> quicksilver, this article is pretty neat (sigfpe linked to it recently) http://math.andrej.com/2008/02/02/the-hydra-game/
00:31:18 <lambdabot> Title: Mathematics and Computation » The hydra game
00:32:14 <Cale> solrize: anyway, my philosophical view about it is that since any acceptable system (one which is consistent and contains arithmetic) can't prove its own consistency, and can't be complete, there's no use in worrying about whether statements are "really true". They're only true or false or not decided upon by the axioms of a given formal system.
00:33:28 <solrize> cale, yeah, i believe that view is not widely held among mathematicians or philosophers
00:33:34 <Cale> Really/
00:33:35 <Cale> ?
00:33:44 <Cale> It seems exceedingly common around these parts.
00:34:05 * Riastradh blinks.
00:34:41 <Cale> At least, basically all the mathematicians I know have that view.
00:34:41 <solrize> i would say lots of math people might say CH's truth or falsehood is just a matter of formal systems
00:34:53 <solrize> but they would say that the twin prime conjecture is either true or false unconditionally
00:35:09 <Cale> Well, that's just undue optimism. :)
00:35:47 <quicksilver> cale's view is almost universally held by mathematicians. And indeed by mathematical philosophers when they are choosing do "do mathematiccs"
00:35:51 <Cale> You've got to hope that you're going to find a proof of any given statement or its negation, but you may never find one.
00:35:51 <solrize> it means your definition of acceptable system is too narrow, since you left out "recursively enumerable"
00:36:07 <BeelsebobWork> gyah
00:36:14 <BeelsebobWork> the darcs manual is *really* badly written
00:36:23 <Cale> solrize: I'm unwilling to accept formal systems which don't have RE sets of axioms.
00:36:35 <solrize> quicksilver, can you name one mathematician who says the twin prime conjecture doesn't necessarily have a truth value?
00:36:38 <quicksilver> the only people IME who take a diffrent view are philosophers who are actively debating this precise point.
00:36:46 <Cale> If you can't even list the rules of the game for me, I'm not going to play it.
00:36:59 <solrize> cale, that's fine, but your description of acceptable systems was missing that part :)
00:37:32 <Cale> I don't know of anyone who advocates the use of a foundation of mathematics whose axioms are not RE.
00:38:21 <quicksilver> solrize: well, people who study these things, I imagine, do believe that twin prime is likely to be provable or disprovable in (e.g.) ZFC
00:38:42 <Cale> I think there might even be a proof that it must be decidable.
00:39:12 <quicksilver> modern mathematicians have to accept the fact that occasionally, conjectures will turn out to be independent of ZFC (or formal-system-of-choice)
00:39:15 <solrize> quicksilver, the vast majority or arithmetic statements are undecidable in ZFC or any other axiom set
00:39:20 <solrize> s/or/of
00:39:38 <rwbarton> majority by what measure?
00:39:39 <quicksilver> sometimes you might take the view that that means we're missing an axiom, so you add on.e
00:39:49 <rwbarton> I suspect not the measure of how much mathematicians care about them
00:39:50 <quicksilver> solrize: so?
00:39:59 <solrize> rwbarton, if you pick a true statement of arithmetic, the probability of it being provable approaches zero as the length of the statement increases
00:39:59 <Cale> rwbarton: ahaha!
00:40:22 <Cale> solrize: that doesn't trouble me in the least
00:40:33 <quicksilver> solrize: taking these views and debating them is fine.
00:40:42 <quicksilver> suggesting that the represent what most other mathematicians think is absurd.
00:40:51 <Cale> The vast majority of statements in the language of groups are undecidable under the group axioms.
00:41:03 <solrize> quicksilver, i don't think it's absurd to say that most CS theorists believe P != NP
00:41:28 <solrize> because there have been surveys done about that question :)
00:41:32 <Cale> solrize: they also don't believe that they have a proof of it.
00:41:53 <quicksilver> Yes. Aboslutely. Most computer scientist strongly suspect that P and NP are genuinely distinct.
00:42:18 <quicksilver> was that relevant to something else we were discussing?
00:42:23 <quicksilver> because if it is, I don't see how.
00:42:27 <solrize> yes, and i think basically all computer scientists think that P=NP is either true or false
00:42:31 <Cale> If it turned out to be undecidable, we might consider adding it as an axiom.
00:42:37 <Cale> (that they are distinct)
00:42:50 <solrize> i.e. it's like the twin prime conjecture
00:43:00 <lament> Cale: so you agree that it should be either true or false
00:43:03 <solrize> P=NP is almost certainly decidable by the way
00:43:06 <Cale> lament: no.
00:43:14 <quicksilver> I'd be surprised if P != NP turned out to be independent of ZFC.
00:43:18 <lament> Cale: yes :)
00:43:25 <quicksilver> but it would hardly be the first time mathematics has surprised me.
00:43:26 <lament> <Cale> If it turned out to be undecidable, we might consider adding it as an axiom.
00:43:33 <Cale> lament: *might*
00:43:49 <quicksilver> solrize: I've lost track of what your point might be.
00:44:00 <solrize> if P vs NP is undecidable then for practical purposes P=NP
00:44:20 <quicksilver> I stand entirely behind cale's view that conventional mathematical orthodoxy views "truth" as being relative to a given formal system.
00:44:29 <solrize> quicksilver, that statements about arithmetic are either true or false, unlike (say) statements like CH
00:44:39 <Cale> solrize: don't you mean the opposite there?
00:44:52 <solrize> cale, opposite about what?
00:44:59 <dolio> P=NP
00:45:09 <Cale> solrize: If P vs. NP is undecidable, then there can't be a P-time reduction from NP to P, so they might as well be different.
00:45:19 <Cale> (at least not a reduction we know about)
00:45:23 <quicksilver> (and in the vast majority of cases, unless formal systems are actually the object of study in question, that formal system is ZFC is somethign very like it)
00:45:31 <rwbarton> At least not a reduction we can prove is polynomial
00:45:37 <Cale> rwbarton: true.
00:45:49 <Cale> rwbarton: or correct ;)
00:45:57 <rwbarton> Yeah, I think that's how it'd have to be.
00:46:20 <solrize> cale, there is a theorem that if P vs NP is undecidable, then P is "almost" equal to NP, i.e. that any problem in NP can be solved by an algorithm that is O(n**B(n)) in the size of the problem, where B is the inverse of the ackermann function
00:46:27 <Cale> It would be really fun if someone found a reduction that appeared to reduce NP problems to P problems, but which couldn't be proved correct ;)
00:46:28 <solrize> i.e. almost a constant
00:46:36 <quicksilver> solrize: that's not attempting to discredit attempts to disagree with orthodoxy. Disagreeing with orthodoxy is great.
00:46:47 <quicksilver> but misrepresenting orthodoxy is not helpful.
00:47:18 <solrize> quicksilver, i do not think i'm misrepresenting orthodoxy.  i believe the notion that arithmetic soundness actually means something, is not unorthodox
00:47:22 <Chadversary> Q: If a statement is undecidable within a system, is system union statement as axiom guranteed to be consistent?
00:47:27 <rwbarton> Cale: there are already some weird algorithms that we can prove are optimal for a given problem, but that we don't yet know how to compute the runtime of :)
00:47:57 <quicksilver> Chadversary: No. That's "independence" which is stronger than "undecidable"
00:47:58 <Cale> Chadversary: yes
00:48:02 <quicksilver> oh.
00:48:13 <quicksilver> Cale: are you sure on that point?
00:48:14 <Cale> quicksilver: hm?
00:48:21 <Chadversary> Oh, no and yes.
00:48:26 * Chadversary scratches head.
00:48:28 <Cale> There's a lot of subtle differences in terminology here :)
00:48:31 <quicksilver> I thought it was a stronger statement "CH is independent of ZFC" than merely "CH is undecidable within ZFC"
00:48:35 <rwbarton> Chadversary: Pick either answer and add it to your system :)
00:48:43 <Cale> quicksilver: is it?
00:48:48 <quicksilver> I thought it was.
00:48:54 <Cale> quicksilver: In what way?
00:49:00 <Chadversary> qs :)
00:49:06 <Cale> That there are ZFC models of both?
00:49:13 <solrize> quicksilver in first order logic, all undecidable statements are independent (completeness theorem)
00:49:17 <Cale> I guess you can be concerned about that :)
00:49:59 <rwbarton> undecidable and independent just seem literally synonymous to me.  I'm curious what you all are talking about :)
00:50:09 <quicksilver> solrize: ah yes, of course.
00:50:14 <quicksilver> Chadversary: sorry. Cale was right.
00:50:29 <dolio> haskell@ has been getting noisy lately.
00:50:40 <quicksilver> rwbarton: "X undecidable in Z" means that there is no proof, in Z, of X.
00:50:49 <Cale> Or ~X
00:50:49 <rwbarton> No proof of Z or ~Z
00:50:53 <rwbarton> Oops, that
00:51:08 <quicksilver> rwbarton: "X independent of Z" means "X and ~Z" and "X and Z" are both consistent.
00:51:17 <quicksilver> rwbarton: so, they are formally different.
00:51:27 <Cale> That is, while you can always prove "X or ~X" you might not be able to prove which one it is :)
00:51:35 <Chadversary> Formally, but do they imply eachother? That is the question.
00:51:47 <quicksilver> as solrize correctly noted, it is the completeness theorem which shows they are equivalent
00:51:51 <quicksilver> (for first-order theories)
00:52:15 <rwbarton> I still think I disagree
00:52:22 <rwbarton> what does consistent mean?  has a model?
00:52:31 <Cale> rwbarton: Doesn't prove a contradiction.
00:52:32 <rwbarton> why not just "doesn't syntactically imply false"?
00:52:56 <Cale> rwbarton: That's my definition of it, anyway :)
00:52:59 <rwbarton> I can see a difference in some crazy non-classical logic, but I didn't think anyone was talking about that in this context.
00:53:06 <Cale> yeah.
00:53:20 <rwbarton> I'm pretty sure that (classically at least) if X and ~Z => false then X => Z.
00:54:53 <Chadversary> rwbarton: (X and ~Z ) => false    <==>   (~X or Z) or F   <==> X => Z
00:55:00 <quicksilver> I was thinking of undecidability as being syntactic and independence as being model theoretic.
00:55:25 <quicksilver> but perhaps htat was just a twisting of my personal view.
00:55:31 <solrize> i think that is right
00:55:38 <rwbarton> I see, that's not how I think of independence, but I am not an expert in the usage of this area
00:56:01 <solrize> for 1st order logic
00:56:12 <rog> @type (+) . 5
00:56:13 <lambdabot> forall b a. (Num (a -> b), Num b) => a -> b -> b
00:56:26 <rog> why isn't that an error?
00:56:53 <dolio> There could conceivably be an instance Num (a -> b).
00:56:57 <quicksilver> rog: because "5" is just some type which is NUm
00:57:08 <quicksilver> rog: and it is possible that some function type could be Num
00:57:11 <Cale> @type 5
00:57:11 <lambdabot> forall t. (Num t) => t
00:57:16 <quicksilver> (as far as haskell's type system knows, at least)
00:57:34 <Cale> rog: Normally, if you tried to compile a program with that in it, it would be an error.
00:57:54 <Cale> rog: Because it would find out that there was no instance for Num (a -> b)
00:58:11 <Cale> But you could write such an instance and resolve the problem like that :)
00:58:16 <rog> ah, i see...
00:58:43 <rog> i was confused!
00:59:06 <quicksilver> rwbarton: Yes. It's because my background is as a logician, and I have worked with systems which were not classical.
00:59:29 <rwbarton> wikipedia seems to agree with my usage, but that's not saying much
00:59:34 <quicksilver> rwbarton: so in that context I was used to distinguishing semantics and syntax in a way which is not very helpful in ZFC.
00:59:58 <quicksilver> rwbarton: because we have strong theorems about first-order classical logic which let use very reasonable ignore this distinction.
01:00:04 <quicksilver> rwbarton: sorry :)
01:01:22 <quicksilver> s/use very reasonable/us very reasonably/;
01:02:25 <solrize> http://scottaaronson.com/blog/?p=327  here is a good scott aaronson blog post about integers vs set theory
01:02:26 <lambdabot> Title: 10 Shtetl-Optimized 1 16 » Blog Archive 1 24 » Floating in Platonic heaven 36
01:03:51 <solrize> For mathematicians, this distinction between “CH-like questions” and “Goldbach/Riemann/Pvs.NP-like questions” is a cringingly obvious one, probably even too obvious to point out. But I’ve seen so many people argue about Platonism versus formalism as if this distinction didn’t exist — as if one can’t be a Platonist about integers but a formalist about transfinite sets — that I think it’s worth hammering home.
01:04:47 <Cale> Given any formal system, we can build a category from that system where there's a unique arrow from X to Y if and only if X |- Y. Suppose we have an initial object 0 (like "false"), and a terminal object 1 (like "true"), then we can say that a statement is provably true if there's an arrow 1 -> A, and provably false if A -> 0. If any A is both, then there's an arrow 1 -> 0, which means that there's an arrow between an
01:04:47 <Cale> y two objects of the category (compose that one with the arrows guaranteed by 0 and 1 being initial and terminal)
01:06:01 <solrize> do you mean A -> 1 ?
01:06:07 <Cale> no
01:06:13 <Cale> Er
01:06:23 <Cale> A -> 1 is guaranteed by the fact that 1 is terminal.
01:06:57 <solrize> oh i see
01:06:57 <Cale> If there's an arrow 1 -> 0, then you can compose A -> 1 -> 0 -> B
01:07:02 <solrize> 0 = contradictoin
01:07:05 <Cale> yeah
01:07:13 <Cale> Or "false", if you prefer.
01:07:54 <solrize> ok
01:08:00 <Cale> Of course, the statement "not A" is usually represented by the exponential object 0^A (supposing it exists)
01:09:55 <Cale> "and" is usually represented by a product object
01:10:49 <Cale> A x 0^A -> 0 is just the evaluation map for the exponential.
01:11:40 <solrize>     For every coloring of R (the reals) with a countable number of colors there exists x,y,z,w of the same color such that x+y=z+w.
01:11:48 <solrize> true or false?  :)
01:11:57 <Cale> But notice, for any pair of objects, we might have neither an arrow 1 -> A nor an arrow A -> 0
01:12:15 <solrize> right
01:12:35 <Cale> (which is analogous to the system being incomplete)
01:12:41 <solrize> ok
01:12:48 <Cale> er, for any object*
01:12:55 <Cale> Not sure why I said pair :)
01:17:21 <Cale> solrize: that sounds like something likely to depend in some way on CH.
01:17:51 <Cale> But I can't tell for sure.
01:18:26 <solrize> cale, correct :)
01:18:31 <solrize> it turns out to be equivalent to ~CH
01:18:37 <solrize> proved by Erdos
01:18:41 <Cale> cool :)
01:28:52 <BeelsebobWork> is it possible to get ghci to output ANSI colour-codes to do syntax highlighting in its output?
01:31:51 <quicksilver> Cale: "pair"?
01:32:00 <quicksilver> Cale: oops. I was scrolled up. Sorry.
01:32:24 <quicksilver> BeelsebobWork: not that I've heard of.
01:34:01 <Cale> quicksilver: I'm honestly not sure what made me say pair. Probably because I was thinking of arrows.
01:35:54 <Cale> solrize: That is a really cool example. I'm going to ask some of my friends what their intuition is about it. :) I've read just enough about CH to have a bit of a feel for what kinds of things seem to fit in that space.
01:36:55 <Cale> solrize: I can say that I've wanted CH to be true before, because it would have made my life easier, but its negation also seems to imply some pretty interesting things.
01:43:13 <solrize> http://weblog.fortnow.com/2007/11/it-was-stupid-question-or.html  it's from here
01:43:14 <lambdabot> Title: Computational Complexity: It was a stupid question!!!!!!!!!! or...
01:51:37 <jtraub> Hi!
01:51:47 <jtraub> I learn Haskell
01:51:54 <jtraub> And i would like to ask your advices
01:52:09 <jtraub> Can you give me link to good sets of exercise
01:52:11 <jtraub> ?
01:52:38 <C-Keen> jtraub: have a look at the haskell website haskell.org
01:52:38 <jtraub> i am using http://learnyouahaskell.com/ as study book
01:52:41 <lambdabot> Title: Learn You a Haskell for Great Good!
01:52:59 <jtraub> but it doesn't have any exercises :-(
01:53:14 <gal_bolle> are there exercises in rwh?
01:53:16 <jtraub> C-Keen, hmm.. I know, but i asked about good
01:53:26 <jtraub> good exercies
01:53:50 <jtraub> I can find a lot of tasks googling by haskell+exercise
01:53:52 <jtraub> :-)
01:53:56 <jtraub> Anyway thanks
01:54:01 <gal_bolle> what kind of subjects do you want to exercise on?
01:54:47 <C-Keen> jtraub: I can recommend the exercises from Simon Thompson: Haskell: The Craft of Functional Programming, Second Edition, Addison-Wesley, 507 pages, paperback, 1999. ISBN 0-201-34275-8.
01:54:59 <C-Keen> jtraub: but invent your own!
01:55:48 <jtraub> gal_bolle, hmm...
01:56:03 <jtraub> gal_bolle, i would like to find exercies
01:56:20 <jtraub> that will help to build some real program
01:56:24 <Xpen> hi guys! can someone help? I need to find immutable hashmap with O(1) lookup...
01:56:25 <jtraub> ste by step :-)
01:57:00 <quicksilver> Xpen: you could use Data.Hashtable and unsafePerformIO if you want.
01:57:04 <jtraub> C-Keen, thanks
01:57:09 <dancor> i'm trying to use haskell-src-exts parseModule to see which adjacent functions have no newline separating them
01:57:09 <quicksilver> Xpen: I doubt that is what you really want, though.
01:57:28 <dancor> however, the HsPatBind results seem to just have the line the func starts at
01:57:56 <dancor> is there something that would preserve the whitespace info i want
01:58:24 <Xpen> <quicksilver> Data.Hashtable uses destructable assignment, I need purely functional and immutable HashMap
01:59:34 <dancor> i guess i can look for empty lines between all adjacent funcs
01:59:37 <dancor> easy enough
01:59:47 <igel> Xpen: have you considered using a bloomfilter?
01:59:48 <quicksilver> Xpen: Data.Hashtable is immutable if you choose to use it that way.
02:00:03 <dancor> though i'll probably be tricked by {- \n \n -} etc
02:00:03 <quicksilver> Xpen: that's why I suggested you should use it as if it was immutable, with unsafePerformIO.
02:00:19 <quicksilver> Xpen: however, I do also think that it's probably not what you want.
02:00:23 <Xpen> <quicksilver> but it uses unsafePerformIO inside
02:00:33 <quicksilver> so?
02:00:37 <dancor> maybe not if i just look right before each function.  alright
02:00:54 <Xpen> <quicksilver> for academic purposes
02:00:56 <Xpen> ^)
02:01:01 <quicksilver> Xpen: there isn't one.
02:01:21 <quicksilver> you could write one using Data.Array if you want.
02:01:38 <quicksilver> I should be pretty surprised if it came out better than Data.Map or FingerTree
02:03:07 <Xpen> is it possible to write own HashMap in Haskell in purely functional way with O(1) lookup?
02:04:16 <Axman6> sure it's possible
02:04:26 <Xpen> Data.Hashtable has O(logN) lookup complexity
02:04:30 <quicksilver> if you're prepared to use Data.Array as a primitive, then yes.
02:04:45 <quicksilver> of course O(1) doesn't really exist.
02:05:47 <quicksilver> Xpen: I don't believe that is the case.
02:06:06 <quicksilver> Data.HashTable has O(1) lookup if you make certain assumptions about collisions and buckets and the hash function.
02:06:17 <Xpen> hmmmm
02:06:34 <Xpen> i just looked at sources of Data.Hashtable
02:07:15 <Xpen> and in commentarys there is written that lookup complexity is O(logN)
02:08:09 <Axman6> does it use lists in the buckets?
02:08:10 <xHemi> is it implemented as a tree? :)
02:08:44 <rog> Xpen: O(1) implies O(logN). so they might just be being conservative.
02:09:00 <quicksilver> Xpen: where does it say that?
02:09:35 <quicksilver> (because I'm looking at the source and I don't see it)
02:09:37 <Xpen> <quicksilver> look at the sources of Data.Hashtable
02:09:43 <Xpen> hmmm
02:10:05 <quicksilver> yes. I am looking. Tell me where it says that.
02:10:16 <Jonte__> Hello.. I have a question.. the function "reads" can be used to convert "123abc" into (123,"abc"), but is there a function which can convert "1.23abc" into (1.23, "abc") ? Is there a function which can handle doubles instead of integers?
02:10:33 <Deewiant> > reads "1.23abc" :: [(Double,String)]
02:10:34 <lambdabot>   [(1.23,"abc")]
02:10:48 <BeelsebobWork> @type reads
02:10:49 <Deewiant> reads is polymorphic, it can handle anything readable
02:10:50 <lambdabot> forall a. (Read a) => String -> [(a, String)]
02:11:01 <Jonte__> Really? Wow.. Thanks a bunch.
02:11:19 <rog> > reads "1.23ebc" :: [(Double,String)]
02:11:20 <lambdabot>   [(1.23,"ebc")]
02:11:36 <rog> > reads "1.23e4bc" :: [(Double,String)]
02:11:38 <lambdabot>   [(12300.0,"bc")]
02:11:51 <Jonte__> It works! I love you guys ;)
02:12:12 <ivanm> > reads "testing" :: [(String,String)] -- this is weird... can't read anything?
02:12:14 <lambdabot>   []
02:12:16 <Axman6> that is handeh
02:12:26 <Deewiant> > reads "\"testing\"" :: [(String,String)]
02:12:28 <lambdabot>   [("testing","")]
02:12:29 <quicksilver> ivanm: "testing" is not a haskel String
02:12:33 <ivanm> ahhhh, duh
02:12:36 <quicksilver> ivanm: '"testing"' is ;)
02:12:52 <quicksilver> s/is not a/is not the Show/Read representation of/ ;)
02:12:56 <ivanm> quicksilver: well, it is a String, but it's not the String representation of a String
02:12:57 <ivanm> heh, yeah
02:13:05 <ivanm> quicksilver: though I think your regex fails
02:13:21 <ivanm> s+is not a+is not the Show/Read representation of+ ;-)
02:13:59 <Xpen> <quicksilver> i have no sources now but I remember that there was O(logN)
02:14:16 <rog> i've found myself using a right associative operator with type ((a -> b -> c) -> (b  -> c) -> (a -> b -> c)). is there a conventional name for this?
02:14:36 <Axman6> Xpen: try this for me, type ax<tab>
02:14:46 <Xpen> Axioplase_
02:14:51 <Axman6> close enough
02:14:55 <Deewiant> ?djinn ((a -> b -> c) -> (b  -> c) -> (a -> b -> c))
02:14:55 <lambdabot> f a _ b c = a b c
02:14:56 <rog> example usage (i called it "&"): let x = flip (:) in (x & x & x) [] 2 3 4  = [4, 3, 2]
02:14:57 <Xpen> Axman6
02:15:01 <Axman6> autocomplete is very handeh ;)
02:15:05 <Xpen> =)
02:15:39 <quicksilver> Xpen: nope.
02:15:41 <Xpen> is lambdabot haskell interpeter?
02:15:47 <quicksilver> Xpen: I am looking at the sources, and there is no such comment.
02:15:58 <quicksilver> Data.Hashtable is O(1) lookup, subject to the normal worries
02:16:02 <Xpen> may be I used old sources =(
02:16:17 <quicksilver> (bucket size, quality of hash function, malicious data construction, etc etc)
02:16:27 <dmwit_> rog: That looks like something from the Reader monad, but I can't put my finger on it...
02:16:49 <quicksilver> Xpen: however I woudl recommend that you never, ever, use Data.Hashtable, and that you forget entirely about O(1).
02:16:59 <quicksilver> O(1) is a lie!
02:17:10 <dmwit_> rog: Wait... how do you combine the outputs of the two functions?
02:17:12 <Xpen> ^) ok
02:17:22 <osfameron> the cake is O(1)
02:17:37 <rog> @djinn (a -> b -> c) -> (b  -> c) -> (a -> b -> c))
02:17:37 <lambdabot> Cannot parse command
02:17:38 <dmwit_> (f & g) a b = let c1 = f a b; c2 = g b in ...?
02:17:49 <rog> @djinn (a -> b -> c) -> (b  -> c) -> (a -> b -> c)
02:17:49 <lambdabot> f a _ b c = a b c
02:17:57 <rog> oops that's wrong
02:18:11 <dmwit_> I think you've maybe got the wrong type.
02:19:11 <rog> i have. it's actually (a -> b -> c) -> (c -> d) -> (a -> b -> d)
02:19:26 <rog> @djinn (a -> b -> c) -> (c -> d) -> a -> b -> d
02:19:26 <lambdabot> f a b c d = b (a c d)
02:19:28 <Deewiant> ?djinn ((a -> b -> c) -> (c -> d) -> (a -> b -> d))
02:19:28 <lambdabot> f a b c d = b (a c d)
02:19:37 <Deewiant> ?pl f a b c d = b (a c d)
02:19:37 <lambdabot> f = flip ((.) . (.))
02:19:37 <dmwit_> ah
02:19:44 <dmwit_> Yeah, it's the boobs operator. =)
02:19:47 <Deewiant> flipped
02:19:48 <quicksilver> some people call it .:
02:19:50 <Axman6> flip boobs
02:19:50 <dmwit_> Some people call it "owl".
02:20:02 <quicksilver> I must admit I tend not to use it.
02:20:08 <quicksilver> btu it's a habit thing.
02:20:16 <Deewiant> I would if it were in the Prelude or somewhere.
02:20:25 <Axman6> :t ((.) . (.))
02:20:26 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
02:20:34 <rog> when it's right associative, it's useful for making a constructor function with an arbitrary number of args.
02:20:53 <Xpen> :t [1 2 3]
02:20:55 <lambdabot>     Ambiguous type variable `t' in the constraint:
02:20:55 <lambdabot>       `Num t' arising from the literal `2' at <interactive>:1:3
02:20:55 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
02:21:41 <rog> i was really looking for something with which i could do, e.g.: 2 & (+) & (-) & (*)
02:21:57 <rog> and produce a function with 3 args, applied in order
02:22:22 <rog> but i couldn't work out how to do it left-associatively
02:22:58 <Xpen> fac :: Integer -> Integer
02:23:05 <Xpen> fac 0 = 1
02:23:22 <Xpen> fac n | n > 0 = n * fac (n - 1)
02:23:29 <Xpen> fac 5
02:23:38 <Xpen> =)
02:23:52 <Deewiant> 120
02:23:54 <Axman6> no instance Num )
02:23:56 <Xpen> lamdabot doesnt works =))
02:23:56 <Axman6> >)>
02:24:04 <Axman6> > 1 + 1
02:24:05 <lambdabot>   2
02:24:12 <Deewiant> > let fac 0 = 1; fac n | n > 0 = n * fac (n-1) in fac 5
02:24:13 <lambdabot>   120
02:24:19 <Axman6> works fine if you use it correctly. everything needs to be on one line
02:24:26 <Axman6> and with >'s ov course
02:24:35 <Xpen> cool =)
02:25:12 <quicksilver> and everything needs to be an expression.
02:25:16 <quicksilver> not a series of declarations.
02:25:24 <quicksilver> (it doesn't contain the ghci "let-hack" either)
02:25:46 <quicksilver> although it has its own @let-hack :)
02:25:58 <Axman6> > let fac n | n > 0 = n * fac (n-1) | otherwise = 1 in fac 100
02:25:59 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
02:26:09 <Axman6> > let fac n | n > 0 = n * fac (n-1) | otherwise = 1 in fac (-100)
02:26:10 <lambdabot>   1
02:26:22 <Xpen> > fibs = 0 : 1 : [a + b | a <- fibs | b <- tail fibs]
02:26:23 <lambdabot>   <no location info>: parse error on input `='
02:26:32 <Xpen> > fibs = 0 : 1 : [a + b | a <- fibs | b <- tail fibs] in fibs 5
02:26:33 <lambdabot>   <no location info>: parse error on input `='
02:26:37 <Xpen> hmmm
02:26:39 <Axman6> need the let
02:26:43 <Axman6> let fibs = ...
02:26:47 <Xpen> > let fibs = 0 : 1 : [a + b | a <- fibs | b <- tail fibs] in fibs 5
02:26:48 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[t2]'
02:26:55 <Xpen> hmmm
02:27:00 <rog> quicksilver: thanks. :. it is then.
02:27:02 <Axman6> fibs !! 5 would work
02:27:08 <rog> quicksilver: i mean .:
02:27:15 <Axman6> > let fibs = 0 : 1 : [a + b | a <- fibs | b <- tail fibs] in fibs !! 5
02:27:16 <Xpen> > let fibs = 0 : 1 : [a + b | a <- fibs | b <- tail fibs]; fibs 5
02:27:17 <lambdabot>   5
02:27:17 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
02:27:21 <Axman6> > let fibs = 0 : 1 : [a + b | a <- fibs | b <- tail fibs] in fibs !! 500
02:27:22 <lambdabot>   139423224561697880139724382870407283950070256587697307264108962948325571622...
02:27:29 <Xpen> > let fibs = 0 : 1 : [a + b | a <- fibs | b <- tail fibs] in fibs !! 6
02:27:31 <lambdabot>   8
02:27:31 <Deewiant> rog: note that .: is the common name of (.).(.) but what you had was flip of that
02:27:36 <Xpen> ohw cool!
02:27:46 <Deewiant> rog: whether you care about that or not is up to you ;-)
02:27:52 <Axman6> > let fibs = 0 : 1 : [a + b | a <- fibs | b <- tail fibs] in fibs
02:27:53 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
02:27:55 <LoneTech> I still can't read the dottys or foralls.
02:27:58 <Xpen> (.).(.) looks like ammmm.... =)))
02:28:08 <Axman6> boobs?
02:28:14 <Xpen> yes
02:28:15 <Xpen> =)))
02:28:20 <Xpen> exactly
02:28:29 <Xpen> also _|_ looks like ammm =)
02:28:34 <Axman6> Haskell: functional porn
02:28:39 <Xpen> =)))
02:28:45 <dancor> is there a better way to do groupByAdj: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=267#a267
02:28:46 <Axman6> the orthogonallity sign?
02:28:52 <Deewiant> bottom
02:29:00 <Axman6> i know ;)
02:29:02 <osfameron> Axman6: at least there's no side effects so you won't go blind
02:29:09 <Axman6> but, that's what it looks like
02:29:11 <rog> Deewiant: hmm. maybe i'll just keep (&) for a name. doesn't seem to be much used.
02:29:32 <dancor> why do we talk about _|_ and bottom and undefined
02:29:34 <Axman6> osfameron: very good point
02:29:41 <Xpen> lazyness is really hard to debug...
02:29:53 <Axman6> why do you say that Xpen?
02:29:54 <Deewiant> but purity is easy to, so it evens otu
02:29:56 <Deewiant> s/otu/out/
02:30:28 <Xpen> Axman6 couz i spent a week to fing one stupid mistake in my code
02:30:42 <Xpen> related to lazyness...
02:31:19 <Axman6> what was it?
02:32:28 <solrize> ``Come on,'' I hear, ``how can you treat having no $0^{\char93 } $ or even CH? - you cannot say somewhere yes somewhere no!'' True, but neither could Mr. Smith have 2.4 children, and still the mythical ``normal'' American citizen is in a suitable sense a very real one. In this light, L looks like the head of a gay chapter of the Klu Klux Klan - a case worthy of study, but probably not representative.
02:32:50 <Xpen> it is really hard to explain couz it is part of one big project, simply it was implementation of clever lists with automatical synchronization on changes in database
02:33:15 <Xpen> something like yet another ORM
02:33:24 <Axman6> solrize: is there a deathnote reference in there?
02:33:36 <solrize> axman6  ?????
02:33:43 <Axman6> L looks like...
02:33:51 <solrize> L = the constructable sets
02:34:01 <Axman6> one of the main characters in the show death note was called L...
02:34:02 <solrize> discussing V=L
02:34:05 <solrize> oh
02:34:22 <solrize> no it was referring back to earlier chat about set thehory
02:34:22 <dancor> @pl \ x y -> x == y + 1
02:34:22 <lambdabot> (. (1 +)) . (==)
02:34:23 <solrize> theory
02:34:46 <solrize> that paste is from a Shelah lecture
02:35:12 <Axman6> righto
02:36:49 <swiert> kosmikus++
02:37:16 <swiert> lhs2TeX release with even better agda support.
02:38:01 <Xpen> is someone use haskell in commercial software development?
02:38:17 <rog> @type flip id
02:38:18 <lambdabot> forall b c. b -> (b -> c) -> c
02:38:31 <rog> how does that typecheck?
02:38:41 <quicksilver> by unification.
02:38:50 <quicksilver> the type of id is unified with the type expected by flip.
02:38:57 <RayNbow> :t flip
02:38:58 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
02:39:01 <RayNbow> :t id
02:39:02 <lambdabot> forall a. a -> a
02:39:10 <Axman6> there are quite a few companies that do i think Xpen. and microsoft seem to do quite a bit of research with it (SPJ mainly)
02:39:45 <Axman6> @unpl flip id
02:39:46 <lambdabot> (\ b c -> c b)
02:40:22 <Xpen> as I know MS uses Haskell only as experimental platform
02:40:42 <quicksilver> Xpen: http://www.haskell.org/haskellwiki/Haskell_in_industry
02:40:44 <lambdabot> Title: Haskell in industry - HaskellWiki
02:40:49 <Xpen> some ideas like Linq comed from haskell
02:40:54 <quicksilver> (this is a very frequently asked question)
02:40:58 <Peaker> MS probably uses Haskell only as much as the MS research guys use Haskell
02:41:23 <rog> hmm. i can't work out what the unfying terms are!
02:41:31 <quicksilver> rog: id :: (a -> a)
02:41:32 <rog> s/unfying/unifying/
02:41:47 <quicksilver> rog: flip :: (b -> c ->  d) -> (c -> b -> d)
02:41:54 <quicksilver> rog: pass id as the first arg to flip
02:42:03 <quicksilver> so unify (a -> a) with (b -> c -> d)
02:42:15 <rog> how can that work?
02:42:24 <quicksilver> they are both of the form (X -> Y)
02:42:27 <RayNbow> note that (b -> c -> d) = (b -> (c -> d))
02:42:38 <quicksilver> so you deduce a = b = c -> d
02:43:15 <kosmikus> swiert: "even better"? there was no Agda support before
02:43:40 <quicksilver> rog: make sense now?
02:43:51 * rog scratches his head
02:44:04 <swiert> kosmikus: Well - you could get away with it using some trickery.
02:44:10 <quicksilver> flip works on any function of the form (b -> c -> d)
02:44:14 <quicksilver> id is of this form
02:44:23 <quicksilver> but forcing id to be this form requires us to take
02:44:23 <swiert> And things like --no-line-pragmas were added because of Agda :)
02:44:32 <quicksilver> id :: (c -> d) -> (c -> d)
02:44:40 <quicksilver> (which is a special case of the general id)
02:44:43 <Peaker> rog: Remember that:  a -> b -> c  === a -> (b -> c)
02:44:45 <rog> quicksilver: i can't quite get my head around the fact that (a -> a) is of the same form as (a -> b -> c)
02:45:01 <quicksilver> rog: Peaker's last remark is the key one then.
02:45:03 <kosmikus> swiert: www.cs.uu.nl/~andres/lhs2tex/Agda.{lagda,pdf}
02:45:06 <quicksilver> -> is a binary connective.
02:45:26 <Deewiant> rog: also note that the a's in (a -> a) are not the same as the a in (a -> b -> c)
02:46:22 * rog feels stupid
02:47:08 <quicksilver> Deewiant: yeah, I carefully chose entirely distinct variables in my initial presentation :)
02:47:14 <Peaker> rog: its actually a bit of mind twisting for me to do the type matching too ;)
02:47:15 <swiert> kosmikus: cool. On behalf of the Nottingham FP lab - great work!
02:47:22 <C-Keen> setFdOption: unsupported Operation <- has anyone seen something like this before?
02:47:26 <Deewiant> quicksilver: I noticed :-)
02:47:36 <quicksilver> rog: don't feel stupid. It's perfectly sensible to think of -> as being an 'n-ary' operation which constructs (n-1)-ary function types.
02:47:51 <quicksilver> rog: it's just that, occasionallyl, formally, it pays to remember that it's actually binary.
02:48:41 <RayNbow> :t flip ($)
02:48:42 <lambdabot> forall a b. a -> (a -> b) -> b
02:49:45 <kosmikus> swiert: glad you like it :) I'm preparing a mail to the Agda list.
02:50:24 <RayNbow> :t ($)
02:50:25 <lambdabot> forall a b. (a -> b) -> a -> b
02:50:28 <RayNbow> :t id
02:50:29 <lambdabot> forall a. a -> a
02:50:52 <RayNbow> (why do I only notice the similarities now?)
02:51:43 <rog> it's just that as far as i can see, if you've got (a -> a) it must resolve down to something where both a's are the same type. and if i'm trying to unify it with (x -> y -> z), i've either got (x -> (y -> z))...... ...... ..... ok i see, we substitute (y -> z) for x.
02:52:55 <quicksilver> rog: exactly.
02:53:02 <quicksilver> rog: you end up proving that a = x = y -> z
02:53:02 <rog> gosh i thought i was getting better at this stuff
02:53:57 <RayNbow> hmm, what's the default precedence for `f`?
02:54:02 <Axman6> @unpl flip ($)
02:54:03 <lambdabot> (\ b c -> c b)
02:54:24 <rog> Axman6: that's where i started!
02:54:28 <RayNbow> @unpl flip id
02:54:28 <lambdabot> (\ b c -> c b)
02:54:39 <Axman6> yeah, i noticed that
02:54:50 <rog> i was wondering if there was a nice binary operator that did that...
02:55:26 <Axman6> like cat a.txt|less in a terminal?
02:55:53 <rog> Axman6: yeah, i guess that's it. i think i've already defined it as |> come to think of it...
02:56:12 <Axman6> @hoogle (|>)
02:56:12 <lambdabot> Data.Sequence (|>) :: Seq a -> a -> Seq a
02:56:12 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
02:56:12 <lambdabot> Text.Parsec.Prim (<|>) :: Monad m => ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
02:57:02 <Peaker> @src Alternative
02:57:03 <lambdabot> class Applicative f => Alternative f where
02:57:03 <lambdabot>     empty :: f a
02:57:03 <lambdabot>     (<|>) :: f a -> f a -> f a
02:57:28 <rog> well, i'm not bothering with Data.Sequence, so i think i'll stick with it...
02:58:08 <rog> (what's the point of having modular namespaces if you have to be constantly aware of the global namespace? :-))
02:58:09 <RayNbow> ah shame... `f` has the highest precedence by default...
02:58:39 <quicksilver> > let f a b = a+b in 3*4 `f` 1
02:58:41 <lambdabot>   15
02:58:46 <RayNbow> > succ `id` 3
02:58:47 <lambdabot>   4
02:58:49 <RayNbow> > succ $ 3
02:58:51 <lambdabot>   4
02:59:02 <quicksilver> RayNbow: interesting, for some reason I always thought it was the lowest, by default.
02:59:10 <quicksilver> I was quite obviously wrong ;)
02:59:20 <RayNbow> quicksilver: well, it's damn hard to find it in the Haskell report :p
02:59:27 <quicksilver> rog: I think you go through a stage of creating operators for everything
02:59:35 <RayNbow> http://www.haskell.org/onlinereport/exps.html#sect3.2    "If no fixity declaration is given for `op` then it defaults to highest precedence and left associativity (see Section 4.4.2)."
02:59:36 <lambdabot> Title: The Haskell 98 Report: Expressions
02:59:39 <quicksilver> rog: and then there is a balancing stage where you reduce your language to something manageable.
02:59:49 <Deewiant> > x `f` y `g` z
02:59:50 <lambdabot>   Add a type signature
02:59:54 <Deewiant> meh
03:00:21 <quicksilver> rog: operators are something of a readability tradeoff : since they can't really be "intuitive" your reader has to learn what they mean, to read your code.
03:00:27 <RayNbow> we should add "infixr 0 `id`" to the Prelude :p
03:00:31 <quicksilver> especially if you play with precedences.
03:00:39 <quicksilver> > x `f` y `g` z :: Expr
03:00:40 <lambdabot>   Add a type signature
03:01:17 <idnar> @type x `f` y `g` z
03:01:18 <lambdabot> forall t t1. (SimpleReflect.FromExpr (t -> Expr -> t1), SimpleReflect.FromExpr (Expr -> t)) => t1
03:01:52 <idnar> @type f x y
03:01:54 <lambdabot> forall t. (SimpleReflect.FromExpr (Expr -> t)) => t
03:01:57 <rog> quicksilver: yeah. i've definitely argued that line in the past. i think i have to allow myself to go through this stage now... :-)
03:03:10 <quicksilver> > (x `f` y `g` z) :: Expr
03:03:12 <lambdabot>   Add a type signature
03:04:24 <rog> BTW i've decided to ditch all the HList stuff and just go with Dynamic. i can't be doing with it.
03:07:26 <quicksilver> heh.
03:07:39 <quicksilver> Dynamic is an admission that you can't be bothered to manage your own existential.
03:07:48 <quicksilver> You may wish to consider managing your own existential.
03:07:54 <quicksilver> at least, examine that path.
03:08:12 <quicksilver> I forget what you're actually trying to do, though?
03:11:35 <rog> quicksilver: i've got a record with some fields that mutate through the application of uncertainty. i know the specific  type of various components at various levels, but there are some general operators that don't. i've been playing with different configurations for ages, and i may yet use existentials.
03:12:41 <rog> quicksilver: it's all been a useful learning experience :-)
03:13:49 <Axman6> :t (\a b -> b a)
03:13:50 <lambdabot> forall t t1. t -> (t -> t1) -> t1
03:14:32 <pao> does anyone know how to turn existential specification on on :t?
03:15:39 <solrize> -fglasgow-exts ?
03:15:42 <ToRA|MSR> ExistentialQuantification
03:16:04 <pao> thanks both
03:17:21 <quicksilver> rog: Dynamic is existentials, thats what I'm trying to say.
03:17:34 <quicksilver> rog: Dynamic is a special kind of existential which is in some sense 'general'.
03:17:43 <quicksilver> like a generalised sum
03:17:58 <quicksilver> sometimes it makes more sense to be more precise and solve the problem you actually have
03:18:05 <quicksilver> sometimes Dynamic is great
03:19:30 <ToRA|MSR> it's open though, which can be annoying. sometimes it's nicer to be able to use a gadt to get a closed reflection/reification scheme going.
03:19:53 <rog> ToRA|MSR: gadt?
03:20:03 <ToRA|MSR> generalized algebraic data type
03:20:18 <ToRA|MSR> data Foo a where FooInt :: Foo Int
03:20:24 <Peaker> Generalized Algebraic Data Type:  Fancy name for using a separate "data Blah where type-signature-for-each-data-constructor-here" :)
03:20:39 <Peaker> for using separate type signature for each constructor, that is
03:20:42 <ToRA|MSR> if you then have data Existential = E (Foo a) a
03:20:56 <ToRA|MSR> you can pattern match on the Foo a in the e to discover the a is really an Int
03:21:16 <Cale> quicksilver: Can you implement Dynamic using just existential types? My guess would be no...
03:21:49 <ToRA|MSR> Dynamic is a pair of an exitential and a reification of the type of a to allow type equality checks i thought
03:22:43 <rog> Peaker: presumably you meant "data Blah = type-sig ...etc"? you didn't mean "class Blah where ..."
03:22:44 <Cale> But with an existential, you can't really coerce the type back to the original type.
03:22:47 <swiert> nominolo|msr: How's the internship going?
03:23:05 <Cale> Even if you happen to know they're the same, there's nothing you can do.
03:23:22 <Peaker> rog: no, GADT is this new syntax "data Blah where { Bleh :: Blah ; Bluh :: forall a. a -> Blah }"
03:23:34 <ToRA|MSR> well with the gadt approach you can, with dynamic, since you know it's safe you can unsafeCoerce it
03:23:39 <ToRA|MSR> which the library may do under the covers
03:23:41 <nominolo|msr> swiert: all good
03:23:46 <rog> oh, i didn't realise it was a new feature
03:23:54 <Cale> ToRA|MSR: Right, my point is not what you can do using unsafeCoerce.
03:23:57 <quicksilver> Cale: you need also a reification of types.
03:23:58 <nominolo|msr> swiert: are you done travelling?
03:24:00 <swiert> nominolo|msr: what are you working on?
03:24:09 <quicksilver> Cale: and you need unsafecoerce
03:24:13 <swiert> yep - for the moment at least :)
03:24:16 <Cale> You can do anything with unsafeCoerce, so that makes the point moot ;)
03:24:34 <nominolo|msr> swiert: a library to provide IDE functionality, but no front-end
03:24:37 <quicksilver> Cale: well you can't do dynamic with just unsafeCoerce
03:24:43 <ToRA|MSR> Cale: you basically need a way of testing for type equality, there are several ways of doing this without unsafeCoerce
03:24:44 <quicksilver> Cale: you also need the TypeRep
03:24:48 <nominolo|msr> swiert: doing ghc api refactorings as i go
03:24:48 <swiert> Now I have two weeks to submit my thesis. I'll ge back on top of TMR after that.
03:24:55 <Cale> quicksilver: Well, that's just a normal typeclass.
03:25:09 <Peaker> rog: actually "data Blah :: * -> *" or "data Blah a b where" mean the same thing (basically you can use extra type variables there or explicitly specify the kind (the type variables just let you make it a fancier kind, without being usable later)
03:25:10 <quicksilver> Cale: it is and it isn't.
03:25:10 <ToRA|MSR> Baars and Swietstra descibe one, as does Weirch  (apologies for bad spelling)
03:25:15 <rog> my difficulty is i've essentially got a heterogeous collection of stuff. i want to be able to do general stuff over the collection, but also to be able to have functions mutate items in the collection later on (they know what the actual types will be). HList seemed like a good fit, only it's totally impossible to use.
03:25:16 <swiert> nominolo|msr: ah, sounds cool.
03:25:24 <quicksilver> Cale: it's not normal in the sense that if you break its contract, everything breakks.
03:25:35 <quicksilver> Cale: so for Dynamic to be "safe" Typeable has to be "special"
03:25:35 <nominolo|msr> swiert: though, atm, i'm hacking haddock to provide a framed representation
03:25:39 <Cale> I don't think you can write Dynamic with existential types alone, and without unsafeCoerce.
03:25:46 <nominolo|msr> and get rid of table-based layouts
03:25:52 <swiert> nominolo|msr: framed representation?
03:26:00 <quicksilver> Cale: you can certainly write it without unsafeCoerce
03:26:10 <Cale> Oh?
03:26:10 <quicksilver> Cale: you can write it, for example, with serialisation
03:26:14 <quicksilver> (Read/Show)
03:26:16 <Peaker> @src HList
03:26:17 <lambdabot> Source not found. stty: unknown mode: doofus
03:26:20 <swiert> nominolo|msr: you should come up to Nottingham and give an FP lunch talk about your work some time.
03:26:22 <quicksilver> there are other approaches to.
03:26:23 <Peaker> rog: I don't know HList
03:26:23 <nominolo|msr> swiert: like java-doc: in the frame one the left you have module names, on the right you have the module docs
03:26:34 <quicksilver> to make it safe you always need invariants, which are most convenient provided by the compiler, though.
03:26:35 <Cale> quicksilver: That severely constrains which types are Typeable.
03:26:43 <quicksilver> Cale: yes.
03:26:48 <Cale> quicksilver: For instance, function types and IO won't be Typeable then.
03:26:50 <swiert> nominolo|msr: right.
03:26:50 <nominolo|msr> swiert: not much to show, yet
03:27:03 <Peaker> rog: You could have a container with existential types in it that are instances of a class containing all the methods you'd apply on them
03:27:11 <hugo__> hi
03:27:26 <swiert> nominolo|msr: We're easily impressed :) And besides, it's best to plan these things early, before the end of internship panic kicks in.
03:27:43 <nominolo|msr> swiert: ah, good point
03:28:01 <nominolo|msr> i wanted to drop by anyways
03:28:43 <swiert> nominolo|msr: Definitely. Just pick a Friday that suits you and send me an e-mail.
03:29:29 <nominolo|msr> swiert: so i presume it's usually around lunch? :)
03:29:43 <swiert> nominolo|msr: We have our FP lunch on Friday - no formal talks, but more an informal whiteboard discussion with sandwiches.
03:30:04 <swiert> nominolo|msr: Yes lunch at noon; pub a few hours later.
03:30:14 <nominolo|msr> sounds nice
03:32:01 <rog> Peaker: the problem is that not all the methods that i want to be able to apply are applicable to all the stuff underneath. so underneath i've got a sum type, and if i call the wrong class method, then i'll get a "pattern not matched" error. that seems pretty similar to not being able to do fromDynamic to me...
03:32:23 <rog> s/i'll get a/i could get a/
03:32:42 <ToRA|MSR> Cale: lookup "typing dynamic typing", they show how to do dyanmic without unsafe coerce, including things like (->); though it's a slightly hairy paper
03:32:58 <Peaker> rog: why do you have different stuff that you can do different things on, in the same list?
03:33:17 <Peaker> rog: you could always place the class method results inside a Maybe, btw
03:34:03 <rog> Peaker: because the list is *essentially* heterogeneous - it's a load of variously typed parameters to a model. different operations are appropriate on different parameter types.
03:34:37 <rog> Peaker: putting class method results in a Maybe would just hide what is in fact an error...
03:34:38 <Peaker> rog: what are you doing with it? a model of what?
03:34:48 <nominolo|msr> swiert: does 11 Nov sound good?
03:34:51 <nominolo|msr> er, sorry
03:34:53 <nominolo|msr> 21 Nov
03:35:15 <rog> Peaker: any old model. but flood prediction, to start with.
03:35:19 <swiert> nominolo|msr: Perfect.
03:35:47 <swiert> nominolo|msr: I'll pencil it in. E-mail me a few days in advance and I'll be sure to send out an announcement.
03:35:52 <nominolo|msr> swiert: do you have some tips for accomodation
03:36:19 <swiert> nominolo|msr: Sure. The P&J hotel is conveniently located for the university.
03:36:57 <swiert> nominolo|msr: I can also ask around if anyone has a spare couch, if you're a bit short for money.
03:37:07 <Peaker> rog: I find it hard to envision a situation where I'd need a list that's so hetero that I can't even find a typeclass to unify it
03:37:27 <Botje> "this list is so hetero, even Oleg's helpless"
03:37:32 <gal_bolle> does haddock have a patch tracker?
03:38:27 <gal_bolle> i get a haddock: internal Haddock or GHC error: renameDecl
03:38:38 <gal_bolle> every time i try to use a -- $ comment
03:38:44 <gal_bolle> -- $identifier
03:39:15 <nominolo|msr> swiert: no it's 45 is fine for one night
03:39:41 <rog> Peaker: it's really a record rather than a list. do you find it hard to imagine a situation where you'd need a record that's so hetero that you can't find a typeclass to unify all the members of the record?
03:40:26 <quicksilver> that's not hard to imagine at all.
03:40:35 * gal_bolle thought #haskell had decided that calling people or things gay was passé and went into saying you're hetero
03:40:37 <quicksilver> typically, though, you decide the record upfront
03:40:48 <quicksilver> and then you just use ordinary types
03:41:03 <quicksilver> what you're (presumably) trying to do is to be a bit polymorphic over the detailed type of the record.
03:41:08 <Peaker> rog: then why are you putting the record in a list?
03:41:25 <quicksilver> Peaker: he wasn't. He was putting it in an HList
03:41:26 <dolio> gal_bolle: I have a friend who does that.
03:41:31 <quicksilver> Peaker: an HList is not a list. It's a record.
03:41:38 <quicksilver> despite the name ;)
03:41:44 <Peaker> oh. as I said, I don't know HLists :)
03:41:47 <Peaker> @hoogle HList
03:41:48 <lambdabot> package HList
03:42:27 <swiert> nominolo|msr: Cool - see you soon then.
03:42:54 <rog> Peaker: the difficulty is that i need to mutate the types of the fields in the record. records themselves don't allow this (you have to define a new record for each type, and there's lots of dogwork involved)
03:43:06 <nominolo|msr> swiert: did you ask ToRA|MSR?
03:43:16 <quicksilver> rog: I strongly doubt that I would use Dynamic as the solution to your problem. But I don't believe I have time to study your problem in enough detail to tell you how I'd do it :)
03:43:17 <swiert> Ah good, point.
03:43:29 <Peaker> rog: Can you give an example of what type mutation you'd do?
03:43:32 <quicksilver> rog: so, since you're the person that is doing it, I recommend you do it your way :)
03:43:38 <swiert> ToRA|MSR: The invitation to come over to Nottingham for an FP lunch extends to you too of course!
03:43:51 <ToRA|MSR> ooh
03:44:03 <swiert> ToRA|MSR: Either on the same day as nominolo or not.
03:44:19 <gal_bolle> is there a way to get "freefloating" comments in a haddocked module without using -- $ident?
03:45:34 <thorkilnaur_> gal_bolle, http://trac.haskell.org/haddock/ may be what you are looking for
03:45:35 <lambdabot> Title: haddock - Trac
03:47:29 <gal_bolle> thanks
03:47:33 <rog> Peaker: ok. i've got a variable, say x. a compact way of representing it might be x = Normal (Interval 4 10) (Interval 1.2 3.5) which would imply two level uncertainty on x. at the bottom level (the actual simulation) it's a Double. one level up, it's normally distributed. one level up again, epistemic uncertainty gives a range of means, and a range of st. devs.
03:48:43 <rog> Peaker: so i've got a set of such variables, all with different types, and different kinds of uncertainty applied, and i want to be able to change it on a whim.
03:49:17 <rog> Peaker: and the model changes different aspects at different levels; for instance evolution through time might update the mean of x.
03:49:25 <Peaker> rog: so the amount of uncertainty is encoded as a type?
03:49:40 <Peaker> rog: the mean of x affects the type?
03:49:49 <dolio> swiert: You know off hand of an example of a positive but not strictly-positive data type that introduces non-termination or the like?
03:49:53 <rog> Peaker: well, that's how i was doing it, yes.
03:50:13 <rog> Peaker: no, the mean of x doesn't affect the type. the fact that x *has* a mean affects the type.
03:50:29 <Peaker> rog: yeah but it *has* a mean all the time, that part is not dynamic, right?
03:50:36 <rog> Peaker: indeed.
03:50:52 <Peaker> rog: so the dynamic thing that makes you "mutate the type" is changing the levels of uncertainty, if I understand correctly?
03:51:05 <rog> Peaker: yes.
03:51:31 <Peaker> rog: is it possible to have that change be a value change without a type change?
03:52:00 <quicksilver> data PValue a = Exact a | Normal (PValue a) (PValue a)
03:52:07 <quicksilver> strikes me as a possible kind of model.
03:52:09 <rog> Peaker: no. well... yes, if i define a union type with everything in it, and do all the type checking via pattern matching...
03:52:22 <quicksilver> (note the recursion, the mean could itself be a distribution)
03:52:40 <lilac> quicksilver: you took the code right out of my edit buffer ;-)
03:52:56 <Peaker> rog: I don't know enough about your problem, but that doesn't sound awful
03:53:02 <rog> quicksilver: that's pretty much what i've got now.
03:53:25 <rog> quicksilver: except that there's a record of such variables, all with different types.
03:53:26 <quicksilver> so I'm still missing the part which means variables have to change type?
03:54:05 <nominolo|msr> rog: what are you trying to do?
03:54:44 <rog> quicksilver: they change type when they're sampled. so given a PValue a, i can take a particular sample from that distribution, and it becomes an a.
03:55:06 <quicksilver> no, it is still a PValue a
03:55:13 <quicksilver> it's just it's not using the 'Exact' constructor
03:55:18 <quicksilver> at least, that's what I was trying to suggest.
03:55:28 <quicksilver> s/not/now/
03:56:56 <swiert> dolio: no. I just asked Peter Morris - he says that negative data types are clearly evil.
03:57:34 <dolio> Yeah. All the examples I've found show negative types and then say "see, non-strictly-positive types are evil." :)
03:57:36 <swiert> dolio: but positive data types are a bit suspicious: there aren't many models of type theory with positive data types (Set no longer suffices for example), so people tend to be rather wary of them.
03:58:09 <Peaker> swiert: what's a positive/negative data type?
03:58:46 <swiert> Peaker: things like data E = Constructor (E -> E) is negative.
03:59:03 <swiert> there's a recursive occurence to the left of an even number of arrows.
03:59:11 <swiert> oops. I mean odd of course.
03:59:22 <swiert> positive is to the left of an even number of arrows.
03:59:30 <dolio> And I was playing with 'Foo r = (Foo r -> r) -> r' earlier and didn't get anywhere.
03:59:30 <swiert> strictly positive to the left of zero arrows.
03:59:40 <Peaker> swiert: ah
03:59:55 <swiert> Sorry guys, lunch. Bbl.
04:00:03 <dolio> Thanks anyhow.
04:00:34 <rog> quicksilver: the difficulty is your data structure assumes that the parameters to the distribution function are the same as the sample from the distribution. and i'm not sure that's true in general.
04:01:14 <quicksilver> rog: that's certainly true, but it doesn't have to be like that.
04:01:36 <quicksilver> rog: Normal distributions, at least, do have that property :)
04:01:47 <quicksilver> rog: mean + sd are the same type as the sample.
04:01:52 <rog> quicksilver: indeed they do...
04:01:55 <quicksilver> and 'Normal' was only intended as an example.
04:02:23 <quicksilver> data PValue a = ..... | Fancy (PValue a) (PValue Int) (PValue String)
04:02:24 <quicksilver> ;)
04:05:17 <rog> quicksilver: i think this approach does in fact boil down to: put everything in one big union datatype. i think the error modes will be just as if i'd used Dynamic anyway (except it'll fail with a pattern-match error instead of cannot fromDynamic)...
04:05:54 <quicksilver> rog: well there are some differences. One is that the compiler guarantees you cannot put something inside of entirely wrong type.
04:06:18 <quicksilver> with Dynamic you can stick a totally irrelevant [TextureObject] in there.
04:06:34 <quicksilver> so it's deferring a check to runtime which could otherwise have been at compile time.
04:06:55 <quicksilver> but you're right that Dynamic "like a great big union".
04:07:01 <quicksilver> it is. It's a great big union with one field per type.
04:08:35 <rog> quicksilver: depends what you mean by "totally wrong". in the context of my calculation, getting an "Exact x" where i expected a "Normal mean std" is just as totally wrong as any other irrelevant object.
04:08:49 <quicksilver> yes.
04:08:51 <dolio> ToRA|MSR: I'm about half way through that paper, but so far it becomes a lot easier with GADTs.
04:09:01 <dolio> A lot of their machinery just becomes unnecessary.
04:09:15 <rog> quicksilver: i suppose it has the advantage that it's probably easier to debug
04:09:20 <quicksilver> rog: there will normally be some aspects of the your program's type discipline that you cannot conveniently express in haskell's type system.
04:09:46 <quicksilver> rog: for example, as you know, it is not especially convenient to express "this function returns a list of length exactly 4, if I give it an input like this"
04:09:51 <quicksilver> possible, in some cases. But never convenient.
04:09:58 <rog> quicksilver: uh huh. but... it's striking the right balance...
04:10:05 <quicksilver> despite that, however, the type system *can* express, and enforce some things
04:10:08 <quicksilver> exactly.
04:10:09 <rog> quicksilver: ... which is something i'm working on!
04:10:13 <quicksilver> and it makes sense to use it when it works.
04:10:30 <quicksilver> Dynamic is "giving up" at one part of that problem.
04:10:34 <quicksilver> that can easily be the right choice.
04:10:44 <quicksilver> so making that choice is fine.
04:10:53 <rog> quicksilver: i've come from using a language with almost no dynamic types, so i'm quite happy to get along without them, in principle.
04:10:55 <quicksilver> All I'm saying, is be cognizant of the choice, and the alternative.
04:14:43 <rog> thinking about it, i still think there's a type mutation that needs to go on.
04:15:23 <rog> at the top level, you've actually got PValue (PValue a), and then one level down, you've got PValue a
04:16:04 <rog> (because the result of the top-level sample is itself a PValue.
04:22:14 <rog> i suppose the sample function could just always reduce the bottom nodes of the tree. that might work.
04:23:12 <pao> @pl \a (bsum, blist) -> (bsum+a,a:blist)
04:23:13 <lambdabot> (`ap` snd) . (. fst) . ap (flip . (((.) . (,)) .) . (+)) (:)
04:23:58 <Deewiant> @pl \a -> (+a) *** (a:)
04:23:58 <lambdabot> liftM2 (***) (+) (:)
04:24:13 <Deewiant> pao: an alternative ^
04:24:30 <pao> > :t (^)
04:24:32 <lambdabot>   <no location info>: parse error on input `:'
04:24:43 <pao> :t (^)
04:24:44 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
04:24:51 <Deewiant> only works if your (+) is commutative
04:24:56 <Deewiant> but it probably is
04:25:10 <Deewiant> pao: by ^ I was pointing to the output of lambdabot :-)
04:25:51 <pao> Deewiant: ops :-)
04:26:06 <quicksilver> rog: my idea was that you'd never need PValue (PValue a)
04:26:22 <quicksilver> rog: any necessarily recursion would be encoded in the type of PValue
04:26:32 <quicksilver> ...this is the point of recursive types, after all.
04:26:41 <pao> Deewiant: Arrows are definitely out of my understanding at the moment :-)
04:27:06 <Deewiant> pao: all you need to know is that "(f *** g) (x,y)" is "(f x, g y)"
04:27:12 <Deewiant> that's all I know ;-)
04:27:24 <pao> Deewiant: wack!
04:27:41 <pao> Deewiant: that was exactly what I was looking for :-)
04:27:59 <Deewiant> yes, it can be quite useful
04:28:09 <Deewiant> more so than Arrows in general, I find :-P
04:28:16 <pao> Deewiant: so... you allow me to use it even if I know zero Arrows? :-)
04:28:40 * EvilTerran would be tempted to include non-Arrow versions in Data.Tuple if he were in charge
04:28:43 <Deewiant> be my guest
04:28:55 <dolio> Anyone running 6.10?
04:28:59 <Deewiant> yep
04:29:20 <EvilTerran> and swap ~(x,y) = (y,x)
04:29:46 <Deewiant> what's the advantage of the ~ there
04:30:11 <EvilTerran> > let swap (x,y) = (y,x) in swap undefined
04:30:13 <lambdabot>   * Exception: Prelude.undefined
04:30:15 <EvilTerran> > let swap ~(x,y) = (y,x) in swap undefined
04:30:16 <lambdabot>   (* Exception: Prelude.undefined
04:30:20 <dolio> Deewiant: Can you load this into ghci and see if it loops the type checker (or, causes something to hang, at least): http://hpaste.org/11435
04:30:21 <Deewiant> yes, I know that
04:30:28 <EvilTerran> Deewiant, the ( is the advantage
04:30:29 <Deewiant> EvilTerran: but what's the _advantage_ ;-)
04:30:40 <rog> quicksilver: but you can't do trivially. because when you've got something like "Normal (Interval 8 9) (Interval 1 2)" how does the sample code know which level to sample at? i think though that to sample, we just reduce the height of the tree by one (it needs always to be balanced)
04:30:57 <Deewiant> dolio: I warn you that this is a 2 or 3-week old one but let's see
04:31:00 <EvilTerran> Deewiant, in that it indicates that the returned value is (_|_,???) instead of just _|_
04:31:22 <EvilTerran> (it never gets far enough in the output to tell whether the snd is _|_, although we know it is)
04:31:37 <Deewiant> dolio: gives a type error
04:31:40 <ski_> > snd (fix (\(x,y) -> (18,x*x)))
04:31:56 <lambdabot>   thread killed
04:31:57 <ski_> > snd (fix (\ ~(x,y) -> (18,x*x)))
04:31:58 <lambdabot>   324
04:32:10 <EvilTerran> and there's a use case for why that's handy :)
04:32:29 <Deewiant> EvilTerran: const (swap undefined) 3 is 3 with one and _|_ with the other?
04:32:39 <dolio> Deewiant: Well, that's better than what it does here. What's the error?
04:32:48 <ski_> (imagine using `mfix' instead of `fix' .. e.g. in the `IO', or the `STM', monad ..)
04:32:54 <EvilTerran> Deewiant, no, as const _|_ x = x
04:33:12 <Deewiant> EvilTerran: argh, const (fst $ swap undefined)
04:33:16 <Deewiant> dolio: annotated
04:33:24 <EvilTerran> er, that's the wrong way round
04:33:24 <EvilTerran> wait
04:33:38 <EvilTerran> const shouldn't particularly be relevant
04:33:55 <dolio> Ah. Thanks.
04:33:56 <Deewiant> EvilTerran: just using it as an example of something which consumes a tuple somewhere upstream
04:34:08 <Deewiant> or downstream, whichever way suits your thinking
04:34:11 <EvilTerran> hm...
04:34:36 <Deewiant> and specifically fst.swap so that it actually checks whether it's a tuple :-P
04:34:52 <EvilTerran> > let swap ~(x,y) = (y,x); swap' (x,y) = (y,x) in (swap undefined `seq` (), swap' undefined `seq` ())
04:34:54 <lambdabot>   ((),* Exception: Prelude.undefined
04:35:24 <Deewiant> yeah, that makes sense
04:35:25 <EvilTerran> Deewiant, it means that you can make a pattern match on the returned tuple without worrying about the tuple being undefined
04:35:39 <EvilTerran> which saves you having to sprinkle ~(...)s in your other patterns, at least
04:35:57 <Deewiant> EvilTerran: hmm, good point
04:36:03 <Deewiant> I was thinking that they all need to be ~
04:36:12 <Deewiant> (what's the word? refutable?)
04:36:19 <EvilTerran> irrefutable
04:36:19 <Philippa_> heh, there's nothing like chatting to a friend on OKCupid to be told her coworker knows of you via here...
04:36:23 <EvilTerran> or "lazy"
04:36:25 <Deewiant> ~ is irrefutable?
04:36:30 <Philippa_> irrefutable, yeah
04:36:33 <Deewiant> why that way around?
04:36:39 <EvilTerran> it always matches at the time of the pattern match
04:36:41 <Philippa_> Deewiant: because there's nothing that doesn't match
04:36:42 <Deewiant> doesn't it mean that you can refute it if you don't care :-P
04:36:45 <EvilTerran> it just might result in an exception later
04:36:54 <Deewiant> Philippa_: okay, that way around, fine
04:36:59 <EvilTerran> > (\Nothing -> ()) (Just 1)
04:37:00 <lambdabot>   * Exception: /tmp/7889433601117060556:69:37-50: Non-exhaustive patterns in ...
04:37:03 <Deewiant> so the match target can't refute the pattern
04:37:04 <EvilTerran> > (\ ~Nothing -> ()) (Just 1)
04:37:05 <lambdabot>   ()
04:37:19 <EvilTerran> ~(pattern with no variables) is equivalent to the pattern _
04:37:30 <EvilTerran> they both always succeed at the time
04:37:38 <Deewiant> that's a good point too, I'd forgotten about that
04:37:53 <pao> Deewiant: my intuition suggests me that Arrows has something to do with the arrow in type notation (a -> b)....
04:38:26 <Deewiant> pao: something, yes, in that all functions are arrows... but not all arrows are functions
04:39:11 <pao> Deewiant: is there any naive example of Arrows outside functions?
04:39:22 <pao> s/outside/except/
04:39:35 <Deewiant> I'm not really an Arrow expert myself mind you ;-)
04:39:41 <Deewiant> and no, not to my knowledge
04:39:58 <Deewiant> the other arrow in Control.Arrow is the Kleisli arrow formed from a monad
04:40:08 <ToRA|MSR> i thought frp and parsers are what arrows are good for?
04:40:17 <Deewiant> so I'm told
04:40:20 <Deewiant> never used them, though
04:42:04 <Peaker> Some disagree that arrows are good for FRP, too
04:42:20 <pao> argh... I surrender
04:42:37 <pao> my exercise was...
04:42:54 <pao> > foldr (:) [1..10]
04:42:55 <lambdabot>       Overlapping instances for Show ([a] -> [a])
04:42:55 <lambdabot>        arising from a use o...
04:43:02 <dolio> Parser arrows were one of the original motivations.
04:43:13 <pao> > foldr (:) [] [1..10]
04:43:15 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
04:43:27 <pao> foldr (+) 0 [1..10]
04:43:33 <Peaker> Are arrows more expressive than Applicative?
04:43:43 <pao> > foldr (+) 0 [1..10]
04:43:44 <lambdabot>   55
04:44:38 <pao> foldr point_free (0:[]) [1..10] that returns (55,[1..10])
04:44:55 <pao> please specify the point_free function... :-)
04:45:33 <Deewiant> what lambdabot gave us, no?
04:45:38 <Deewiant> > foldr (liftM2 (***) (+) (:)) (0,[]) [1..10]
04:45:39 <lambdabot>   (55,[1,2,3,4,5,6,7,8,9,10])
04:46:10 <pao> Deewiant: doh :-)
04:46:22 <chr1s> Peaker: yes, they are.
04:47:03 <pao> Deewiant: sorry... I've overlooked your suggestion
04:47:05 <mm_freak> there is an interpretation of definedness as the powerset of possible values with the partial order ⊆
04:47:10 <mm_freak> is this interpretation valid?
04:47:22 <Deewiant> pao: heh, no problem, it's good that you gave it some thought yourself ;-)
04:47:27 <mm_freak> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics#Interpretation_as_Powersets
04:47:29 <lambdabot> http://tinyurl.com/yxxgb8
04:47:33 <chr1s> Peaker: it helps me a lot whenever I see Arrow a b to read it as (a --> b)
04:49:01 <Philippa_> Peaker: arrows are a perfect match if you want something akin both to monads and to a 'circuit diagram'
04:50:47 <chr1s> Philippa_: yes, I agree. You could draw arrows as a finite state machine, that's a nice way to visualize them.
04:51:02 <pao> Deewiant: could you please confirm that an average haskell programmer has some difficulty writing down lift2M (***) (+) (:) directly or understanding it at first sight?
04:51:08 <pao> Deewiant: :-)
04:51:10 <Deewiant> pao: certainly, yes :-)
04:51:37 <SamB_XP> what's lift2M?
04:51:38 <Deewiant> I've gotten used to having lambdabot give liftM2 foo f g so I can read that, and I've gotten used to (***) so I can read that as well
04:51:41 <Deewiant> most probably haven't
04:51:42 <pao> Deewiant: nice to hear :-)
04:51:52 <Deewiant> it probably depends on how much you use @pl :-P
04:51:56 <Deewiant> SamB_XP: liftM2.
04:52:15 <chr1s> SamB_XP: http://haskell.org/hoogle/?hoogle=liftM2
04:52:16 <lambdabot> Title: liftM2 - Hoogle
04:52:50 <Deewiant> chr1s: I think it was more about the typo than the meaning of the function.
04:53:03 <chr1s> ah, I see
04:53:09 <pao> Deewiant: which is the monad in which liftM2 promotes (***) ?
04:53:19 <Deewiant> pao: the (-> r) monad.
04:53:45 <SamB_XP> :t liftM2 (***) (+) (:)
04:53:46 <lambdabot> forall a. (Num a) => a -> (a, [a]) -> (a, [a])
04:53:47 <Deewiant> pao: so you've got the monad instance of (-> r) and the arrow instance of (-> r) working together in that expression :-P
04:54:21 <pao> Deewiant: quite brain twisting :-)
04:54:29 * SamB_XP thought it was the (r ->) monad...
04:54:38 <Deewiant> d'oh, SamB_XP is right
04:54:48 <Deewiant> ((->) r) i.e. (r ->)
04:55:02 <SamB_XP> nevermind that that isn't syntactically valid ...
04:55:20 <dolio> And then you have the (-> r) . (-> r) monad.
04:55:22 <Deewiant> it isn't?
04:55:24 <Cale> The arrow instance of (->)
04:55:32 <Cale> and the monad instance of ((->) r)
04:55:36 <Deewiant> blaa
04:55:37 <pao> Deewiant: it is impossibile to define ((->) r) as an instance of Monad without newtype, right?
04:55:46 <Cale> pao: no.
04:55:47 <Deewiant> no it's not
04:55:50 <Cale> It's possible.
04:56:07 <Cale> instance Monad ((->) r) where
04:56:10 <Deewiant> It's only impossible if you've imported Control.Monad.Instances which already did it for you ;-)
04:56:13 <Cale>   return = const
04:56:20 <Deewiant> fmap = (.)
04:56:30 <Cale>   (x >>= f) k = f (x k) k
04:57:35 <Cale> Really, it should be in the Prelude :)
04:57:36 <Peaker> chr1s: what can be expressed as an applicative, and not as an arrow?
04:57:44 <Peaker> chr1s: or vice-versa?
04:57:55 <chr1s> Peaker: http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
04:58:00 <lambdabot> Title: Idioms are oblivious, arrows are meticulous, monads are promiscuous, http://tinyurl.com/6evopg
04:58:26 <Badger> heh
04:58:37 <Peaker> chr1s: that paper speaks in notations that I do not know. I wish it spoke Haskell, instead
04:58:45 <chr1s> Peaker: http://ezrakilty.net/research/2008/09/formlets_idioms_arrows_and_mon.html
04:58:46 <lambdabot> Title: Ezra's Research: Formlets; Idioms, arrows and monads, http://tinyurl.com/6hsaz6
04:58:50 <pao> Cale: Deewiant: you're taking me to higher order thinking :-)
04:59:30 <pao> I'm trying to get ((->) r) in the instance list of :info Monad in ghci ... without success...
04:59:31 <chr1s> Peaker: that blog-post explains it in a less detailed but more haskelly way
04:59:40 <Peaker> chr1s: I feel I understand well the difference between monads and arrows, and monads and applicatives, but from that it seems to me that arrows are just like applicatives except with a little more information about the computation structure
04:59:46 <Cale> Peaker: I recommend "Types and Programming Languages", which should make that kind of notation comfortable.
05:00:11 <Cale> pao: :m + Control.Monad.Instances
05:00:52 <Peaker> Cale: having a lot of notations and docs that are spread around these various notations is a big scare away from Haskell.  Is there any advantage to not using Haskell's notation?
05:01:14 <Cale> Peaker: They're using the standard notation for type theory.
05:01:36 <Cale> Probably because it's not just a Haskell paper.
05:01:46 <zachk> Cale: I am using your four infinities as my desktop background. I like your art.
05:01:51 <Cale> :)
05:01:53 <dolio> I can't imagine haskell code being clearer than the mathematical notation.
05:02:00 <Cale> zachk: cool :)
05:02:09 <pao> Cale: that doesn't work either
05:02:10 <zachk> i think it is much clearer
05:02:10 <SamB_XP> zachk: where did you ever get a big enough desktop to do *that* ?
05:02:19 <ilyak> math notation isn't that clear
05:02:30 <chr1s> Peaker: if you're serious about this, Types and Programming Languages is indeed a really good read.
05:02:31 <Cale> Prelude> :m + Control.Monad.Instances
05:02:31 <Cale> Prelude Control.Monad.Instances> :info Monad
05:02:33 <Cale> ...
05:02:33 <zachk> SamB_XP: huh, i dont understand the question
05:02:36 <Cale> instance Monad ((->) r) -- Defined in Control.Monad.Instances
05:02:44 <SamB_XP> zachk: four infinities on ONE desktop ???
05:02:56 <zachk> oh its a joke :-D
05:02:56 <Cale> SamB_XP: haha
05:03:08 <zachk> i have a lazy desktop
05:03:16 <chr1s> it helps you to understand those notations. but to be honest, most of the smart FP-people I know also don't find it easy to read that paper.
05:03:20 <Peaker> chr1s: Only comes in dead tree format?
05:03:35 <chr1s> Peaker: yes, but it's definitely a good investment.
05:03:46 <Cale> Peaker: I'm not sure, I managed to find its successor, ATTaPL in crystal clear PDF form.
05:03:51 <chr1s> it will give you a really good foundation for PL/FP research
05:04:07 <Cale> I have TaPL in dead tree form anyway, but I would love to have a nice PDF of it.
05:04:20 <Peaker> chr1s: I don't think I've read more than 1 or 2 technical dead tree books.. I tend to prefer shorter web publications and trial and error :P
05:04:48 <Cale> Well, TaPL is ~600 pages :P
05:04:50 <chr1s> whatever you want, Peaker ;)
05:05:11 <Peaker> Cale: that kind of thing is nicer spread on about 150 blog entries :)
05:05:14 <Davbo> Could someone correct me on where i'm going wrong here - http://hpaste.org/11436
05:05:20 <Davbo> please :-)
05:05:21 <SamB_XP> Peaker: huh
05:05:38 <SamB_XP> I'm often frustrated at how badly the blog entries print out ...
05:05:49 <Peaker> SamB_XP: I don't print it out, I read on screen ;)
05:05:55 <Cale> Davbo: b :: Board, but head wants a list
05:06:04 <Peaker> SamB_XP: I can copy&paste into a ghci, or search stuff I read before ;)
05:06:11 <SamB_XP> Peaker: well, I like to read on the bus and so forth ...
05:06:17 <Peaker> SamB_XP: laptops? :)
05:06:21 <Philippa_> Peaker: monads are also "just like applicatives only..." (in this case, the only is join/the ability to have higher-order computations)
05:06:26 <SamB_XP> those are expensive
05:06:29 <Cale> Davbo: also, you're not pattern matching nearly enough :)
05:06:32 <SamB_XP> which is o say, they cost money
05:06:34 <pao> Deewiant: Cale  I think I got it
05:06:41 <pao> :t liftM2 (***)
05:06:42 <lambdabot> forall (a :: * -> * -> *) b c b' c' (m :: * -> *). (Monad m, Arrow a) => m (a b c) -> m (a b' c') -> m (a (b, b') (c, c'))
05:07:01 <Davbo> Cale: Isn't Board a list of Dominoes? I'm really new to Haskell as you can probably tell..
05:07:05 <Philippa_> TaPL is good, FWIW. It's got a lot of the stuff you need to know together - sometimes you really do need to learn a field in a degree of depth rather than via a grab-bag of stuff
05:07:12 <Davbo> pattern matching, right. I'll read up on that
05:07:26 <Cale> Davbo: The first field of the only data constructor for Board is a list of Dominoes
05:07:32 <SamB_XP> Philippa_: that too
05:08:02 <Peaker> Philippa_: m (m a) is called a "higher order computation"?
05:08:43 <Peaker> Philippa_: yeah, I see monads as applicatives that can determine structure based on "runtime"/computation results..
05:08:45 <Cale> Davbo: But that doesn't mean that it's a list of Dominoes. It's a separate type, treated differently by the type system.
05:09:08 <Philippa_> Peaker: in analogy to higher order function, yeah. Similarly m a -> m b
05:09:21 <Davbo> right I see, thanks Cale
05:09:36 <Cale> Davbo: In order to get the list of dominoes out again, you can pattern match, like:  goesLP (Domino (x,y)) (Board (d:ds)) = ...
05:09:38 <Philippa_> and the paper above is independent of Haskell - indeed, it needs its own notation to make the points it's making and embedding that notation in Haskell doesn't actually do any favours in the area it's in
05:09:52 <Philippa_> not everything about arrows or monads is about Haskell
05:09:59 <Cale> Davbo: This is also a good reminder that your function will fail if the Board is empty.
05:10:08 <Cale> Davbo: So you'll have to write another case for that :)
05:10:14 * Davbo nods
05:10:47 <Davbo> righty, will go away for a bit and read up on pattern matching
05:10:48 <pao> Deewiant: in  liftM2 (***) the monad is the first argument application and the arrow is the second argument application or the other way around?
05:10:53 <Davbo> much appreciated Cale
05:11:01 <Peaker> Philippa_: Well, I was told that since Arrows and Applicative are a different kind, its hard to compare them...  But both cannot determine structure based on "runtime". Both can combine computation results.  Are there any differences that can be expressed in a couple of sentences?
05:12:31 <Philippa_> yeah: Arrows are more flexible about what has access to what results. Applicative doesn't give you enough structure to directly support an "ApplicativeChoice" class that makes what in a parser would be context-dependent decisions
05:12:34 <Deewiant> pao: what do you mean, exactly? You see the type: (Monad m, Arrow a) => m (a b c) etc. Replace "a b c" with "b -> c" and "m x" with "r -> x" so you get (r -> b -> c) -> (r -> b' -> c') -> r -> (b,b') -> (c,c')
05:13:11 <pao> Deewiant: that what I meant exactly
05:13:27 <Deewiant> pao: So I answered it?
05:13:40 <pao> Deewiant: yeah! thanks... very useful
05:13:44 <Peaker> Philippa_: an ArrowChoice-based parser is no longer context-free, right?
05:13:46 <Deewiant> great :-)
05:14:23 <Peaker> @src ArrowChoice
05:14:24 <lambdabot> Source not found. You untyped fool!
05:14:57 <Philippa_> Peaker: right
05:15:03 <Philippa_> whereas ArrowPlus is still context-free
05:15:29 <Philippa_> to put it another way: an Applicative can only use intermediate results in generating final results
05:15:36 <Philippa_> an Arrow can pass them on
05:15:50 <sm> dons: thanks for turning me on to download-curl, feed, xml, and tagsoup a few days back. I'm making progress.
05:17:18 <sm> openAsFeed seems to lose the feed's encoding, that was in the ?xml header. So I get junk characters. Is this a bug or something I'm missing ?
05:17:54 <lilac> An ArrowChoice-based parser can only make finite choices, whereas an ArrowApply-based parser can make infinite choices
05:18:17 <Philippa_> lilac: far more simply, ArrowApply gives you higher-order computations back again
05:18:35 <Philippa_> at which point you hit the turing complete class, I believe
05:18:41 <lilac> sure, but that doesn't really make the difference as obvious imo
05:18:42 <Peaker> ArrowApply ~= Monad
05:18:59 <Philippa_> yeah, where ~= is that there's an isomorphism between them
05:19:01 * sm sleeps
05:19:40 <quicksilver> ArrowApply constructs a monad of which this arrow is the kleisli arrow?
05:20:09 <lilac> ArrowMonad applied to an ArrowApply gives a monad whose Kleisli arrow is isomorphic to the original arrow
05:20:56 * quicksilver nods
05:21:03 <quicksilver> that was a long way to say "Yes" ;)
05:21:24 <lilac> yes
05:21:39 <lilac> apart from the 'isomorphic' part
05:21:45 <quicksilver> yeah.
05:21:53 <quicksilver> When I say "is", I mean isomorphic. Sometimes.
05:22:01 <quicksilver> You don't get to know when, though. You have to guess ;)
05:22:44 <mib_5szgn4zn> I again need some help with haskell and one exercise. It basically states to count the number of times each word occurs in a string. What i am doing is I split the original string to a list of many strings(using the words function) but then i get stuck on how to count the number of times each string occurs. I tried to use the length function and also tried to modify it so it returns number of times each string occurs
05:22:46 <Davbo> Big thanks Cale, think I've figured it out now :)
05:22:56 <Philippa_> lilac: sometimes, "yes, up to isomorphism" is the quick answer :-)
05:23:30 <Cale> Davbo: great :)
05:23:36 <lilac> quicksilver: i shall henceforth assume whichever interpretation makes you right ;-)
05:23:37 <Axman6> mib_5szgn4zn: isInfixOf might be useful
05:23:55 <mib_5szgn4zn> http://www.mibbit.com/pb/DZRaJC
05:23:56 <lambdabot> Title: Mibbit: PasteBin
05:24:05 <Cale> mib_5szgn4zn: you might look at 'sort' and 'group'
05:24:10 <Cale> mib_5szgn4zn: as intermediate steps
05:24:14 <mib_5szgn4zn> ive got that so far but i think im completely wrong
05:24:16 <Cale> > group "mississippi"
05:24:17 <lambdabot>   ["m","i","ss","i","ss","i","pp","i"]
05:24:23 <Cale> > sort . group $ "mississippi"
05:24:24 <lambdabot>   ["i","i","i","i","m","pp","ss","ss"]
05:24:32 <Cale> > group . sort $ "mississippi"
05:24:34 <lambdabot>   ["iiii","m","pp","ssss"]
05:24:38 <mib_5szgn4zn> yea im the guy from last night lol
05:24:42 <Cale> ah, okay
05:24:45 <Cale> So you have that.
05:24:55 <mib_5szgn4zn> ive managed that yea :-)
05:25:05 <Cale> A list of lists, each of which has all the same word, as many times as the original sentence.
05:25:11 <lilac> > map length . group . sort $ "mississippi"
05:25:13 <lambdabot>   [4,1,2,4]
05:25:14 <Cale> So now you're a 'map' away from the answer.
05:25:22 <Deewiant> > let fullGroupBy rel xs = map (\a -> filter (rel a) xs) (nubBy rel xs) in fullGroupBy (==) "mississippi"
05:25:23 <lambdabot>   ["m","iiii","ssss","pp"]
05:25:43 <Axman6> i can see one way to do it with zipWith (==)
05:25:50 <Axman6> but, it's a little ugly
05:26:05 <mib_5szgn4zn> hmm, im only very basic
05:26:06 <lilac> mib_5szgn4zn: you want something like 'map length', but not quite, since you also want to know what the word is
05:26:17 <Cale> > map (\x -> (length x, head x)) . group . sort $ "mississippi"
05:26:19 <lambdabot>   [(4,'i'),(1,'m'),(2,'p'),(4,'s')]
05:26:31 <BeelsebobWork> > let fullGroupBy = (groupBy . ) . sort in fullGroupBy "mississippi"
05:26:32 <lambdabot>   Couldn't match expected type `a1 -> a -> a -> Bool'
05:26:36 <BeelsebobWork> oops
05:26:41 <Cale> I think that was already given away last night ;)
05:26:47 <mib_5szgn4zn> lol
05:26:59 <mib_5szgn4zn> lambabot is a bot ryt?
05:27:02 <Cale> yep
05:27:05 <lilac> @type (&&&) :: (a -> b) -> (a -> c) -> (a -> (b,c))
05:27:06 <lambdabot> forall a b c. (a -> b) -> (a -> c) -> a -> (b, c)
05:27:17 <Cale> It evaluates Haskell expressions, prints types of things, and a bunch of other stuff.
05:27:20 <BeelsebobWork> > let fullGroupBy = (. sort) . groupBy in fullGroupBy "mississippi"
05:27:21 <lambdabot>   Couldn't match expected type `a -> a -> Bool'
05:27:24 <mib_5szgn4zn> ahh ok
05:27:31 <ski> @botsnack
05:27:32 <lambdabot> :)
05:27:36 <BeelsebobWork> > let fullGroupBy = (. sort) . groupBy in fullGroupBy (==) "mississippi"
05:27:38 <lambdabot>   ["iiii","m","pp","ssss"]
05:27:48 <mib_5szgn4zn> what does map do then? not sure if i can use it lol
05:28:06 <BeelsebobWork> > map (+5) [1,2,3]
05:28:08 <lambdabot>   [6,7,8]
05:28:09 <BeelsebobWork> that
05:28:16 <BeelsebobWork> applies a function to every item in a list
05:28:26 <lilac> > map f [a,b,c]
05:28:27 <mib_5szgn4zn> wicked, thanks
05:28:27 <lambdabot>   Add a type signature
05:28:31 <lilac> > map f [a,b,c] :: [Expr]
05:28:32 <lambdabot>   [f a,f b,f c]
05:28:44 <mib_5szgn4zn> that makes more sense now
05:29:34 <Axman6> mib_5szgn4zn: i've got a working version of what you want, and it doesn;t need words or sort or anything...
05:29:50 <Axman6> it's pretty intuitive too
05:30:15 <Axman6> hmm, each word... ok, that's a little more annoying
05:30:22 <Axman6> well, my thing can still be used
05:30:53 <SamB_XP> mib_5szgn4zn: when did you first suspect that lambdabot was a bot ?
05:31:07 <BeelsebobWork> mib_5szgn4zn: what is the problem you're working on?
05:31:16 <mib_5szgn4zn> speed he evaluated things at
05:31:29 <SamB_XP> mib_5szgn4zn: she!
05:31:31 <BeelsebobWork> > fix id
05:31:33 <lambdabot>   * Exception: stack overflow
05:31:36 <BeelsebobWork> she's not that fast...
05:31:37 <Deewiant> > fix error
05:31:39 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
05:31:41 <BeelsebobWork> hehehe
05:31:41 <quicksilver> let's have a race!
05:31:43 <Axman6> heh
05:31:46 <Deewiant> > last [1..]
05:31:50 <quicksilver> > 1+1
05:31:50 <quicksilver> 2
05:31:52 <quicksilver> I win!
05:31:55 <Deewiant> :-)
05:31:56 <BeelsebobWork> haha
05:31:57 <mib_5szgn4zn> i need to build a text processing application from the list processing functions in haskell
05:32:06 <lambdabot>   thread killed
05:32:19 <BeelsebobWork> mib_5szgn4zn: okay, what feature is it you're trying to implement?
05:32:23 <SamB_XP> mib_5szgn4zn: you never noticed, say, the "bot" in her name ?
05:32:26 <Axman6> mib_5szgn4zn: want to see my possibly useful solution?
05:32:59 <mib_5szgn4zn> im trying to count the occurances of each word in a given string
05:33:19 <Axman6> > let countOccs _ [] = 0; countOccs w xss@(x:xs) | (all id.zipWith (==) w) xss = 1+countOccs w xs | otherwise = countOccs w xs
05:33:20 <lambdabot>   <no location info>: parse error on input `;'
05:33:22 <mib_5szgn4zn> eg "The rain in Spain mainly falls on the plain."
05:34:00 <mib_5szgn4zn> but i can only only use basic functions :-(
05:34:09 <BeelsebobWork> > map (head &&& length) . group . sort . map toLower $ "The rain in spain falls mainly on the plain"
05:34:10 <lambdabot>   [(' ',8),('a',5),('e',2),('f',1),('h',2),('i',5),('l',4),('m',1),('n',6),('...
05:34:17 <BeelsebobWork> not quite
05:34:20 <Axman6> how odd, that woorks fine in ghci
05:34:22 <SamB_XP> mib_5szgn4zn: I guess Data.Map is out then ;-)
05:34:30 <BeelsebobWork> > map (head &&& length) . group . sort . words . map toLower $ "The rain in spain falls mainly on the plain"
05:34:31 <lambdabot>   [("falls",1),("in",1),("mainly",1),("on",1),("plain",1),("rain",1),("spain"...
05:34:33 <BeelsebobWork> done!
05:34:38 <Axman6> > let countOccs _ [] = 0; countOccs w xss@(x:xs) | (all id.zipWith (==) w) xss = 1+countOccs w xs | otherwise = countOccs w xs in countOccs "abc" "abc123acababc"
05:34:40 <lambdabot>   2
05:34:48 <mib_5szgn4zn> axman6 does it look like this : http://www.mibbit.com/pb/SNitwd
05:34:49 <lambdabot> Title: Mibbit: PasteBin
05:34:51 <Axman6> @let countOccs _ [] = 0; countOccs w xss@(x:xs) | (all id.zipWith (==) w) xss = 1+countOccs w xs | otherwise = countOccs w xs
05:34:54 <lambdabot>  Defined.
05:35:07 <SamB_XP> @yow
05:35:08 <lambdabot> Bo Derek ruined my life!
05:35:10 <SamB_XP> @yow
05:35:10 <lambdabot> I'm pretending I'm pulling in a TROUT!  Am I doing it correctly??
05:35:15 <ddarius> all id = and
05:35:16 <BeelsebobWork> mib_5szgn4zn: heh, surprisingly close to mine
05:35:27 <BeelsebobWork> (\x -> (length x, head x)) can be written as (length &&& head)
05:35:28 <Axman6> ddarius: yeah my bad
05:35:31 <Philippa_> ...that's too sane for @yow. I read it without the 'in', that was more amusing
05:35:35 <mib_5szgn4zn> cant get mine to work properly though in winhugs
05:36:06 <BeelsebobWork> mib_5szgn4zn: that's because your type signature says the word will come first, and then the number of occurances
05:36:10 <BeelsebobWork> but your definition doesn't say that
05:36:32 <mib_5szgn4zn> hmmm
05:37:31 <mib_5szgn4zn> would it be this then:
05:37:34 <mib_5szgn4zn> countWords = group . sort . map (\x -> (length x, head x))
05:37:57 <BeelsebobWork> okay... first you want to sort your words
05:37:59 <BeelsebobWork> then group them
05:38:03 <BeelsebobWork> then map a function that counts them
05:38:10 <BeelsebobWork> so your function was right before
05:38:19 <BeelsebobWork> except that your function that counts them was wrong
05:38:32 <BeelsebobWork> it returned (2, "the")
05:38:40 <Axman6> @let countWords ws = map (\w -> (w,countOccs w ws)) $ words ws
05:38:41 <lambdabot>  Defined.
05:38:43 <BeelsebobWork> while your type signature says it should return ("the", 2)
05:38:49 <Axman6> > countWords "hello my name is hello hi name"
05:38:50 <lambdabot>   [("hello",2),("my",1),("name",2),("is",1),("hello",2),("hi",1),("name",2)]
05:39:01 <BeelsebobWork> > map (head &&& length) . group . sort . words . map toLower $ "The rain in spain falls mainly on the plain"
05:39:01 <Axman6> hmm, need to filter than
05:39:03 <lambdabot>   [("falls",1),("in",1),("mainly",1),("on",1),("plain",1),("rain",1),("spain"...
05:39:26 <Axman6> @unlet countWords
05:39:27 <lambdabot>   Parse error
05:39:31 <Deewiant> @undef
05:39:38 <Axman6> @undef countWords
05:39:40 <Axman6> cheers
05:39:45 <Deewiant> @undef always wipes out everything
05:39:53 <Axman6> dang, oh well
05:40:01 <Deewiant> one can't selectively @undef
05:40:07 <Axman6> shame
05:40:12 <Axman6> @let let countOccs _ [] = 0; countOccs w xss@(x:xs) | (all id.zipWith (==) w) xss = 1+countOccs w xs | otherwise = countOccs w xs
05:40:13 <lambdabot>   Parse error
05:40:16 <Deewiant> well, it keeps cruft from accumulating
05:40:19 <Axman6> @let countOccs _ [] = 0; countOccs w xss@(x:xs) | (all id.zipWith (==) w) xss = 1+countOccs w xs | otherwise = countOccs w xs
05:40:20 <lambdabot>  Defined.
05:40:29 <Axman6> @let countWords ws = map (\w -> (w,countOccs w ws)) $ (nub.words) ws
05:40:30 <lambdabot>  Defined.
05:40:38 <Axman6> > countWords "hello my name is hello hi name"
05:40:39 <lambdabot>   [("hello",2),("my",1),("name",2),("is",1),("hi",1)]
05:41:06 <Axman6> sort could be added if needed...
05:41:14 <mib_5szgn4zn> hmm not sure if i can use countOccs, its so awkward
05:41:15 <BeelsebobWork> I'd still go with map (head &&& length) . group . sort . words . map toLower
05:41:34 <Axman6> mib_5szgn4zn: how's it awkward?
05:41:35 <Deewiant> why head and not id
05:41:45 <ivanm> BeelsebobWork: (head &&& length) does [1,1,1,1,1] -> (1,5)?
05:41:52 <BeelsebobWork> Deewiant: because id produces a list of words
05:41:55 <Cale> Deewiant: because that would leave you with a list of a bunch of the same string
05:41:58 <byorgey> ivanm: right
05:42:01 <Deewiant> ah, d'oh
05:42:01 <BeelsebobWork> ivanm: exactly
05:42:06 <mib_5szgn4zn> as i can only use basic things, if i use more adv things i havent covered yet i get marked down
05:42:10 <byorgey> (f &&& g) x = (f x, g x)
05:42:20 <byorgey> for the (->) arrow, at least
05:42:22 <Deewiant> I've been spouting all manner of nonsense today, maybe I should keep quiet :-P
05:42:25 * ivanm wish he knew about that instead of always having something like grouper as@(a:_) = (a, length as) :s
05:42:27 <BeelsebobWork> well, use \x -> (head x, length x) then
05:42:41 <Axman6> mib_5szgn4zn: it's called research, and they mark you down for learning... change school ;)
05:43:26 <Axman6> and if*
05:43:26 <mib_5szgn4zn> yea exactly lol
05:43:28 <SamB_XP> Axman6: well, I would expect the teacher to at least investigate whether the student actually understands those things or not
05:43:45 <zachk> i believe my comp sci professor is scared of recursion
05:43:52 <Axman6> yeah, i wouldn't advise mib_5szgn4zn to just copy my stuff if he didn't understand it
05:44:02 <SamB_XP> because it's not good for student to get code from somewhere else that they don't even understand!
05:44:06 <mib_5szgn4zn> im not, dont worry
05:44:09 <Cale> Yeah, that always seems strange to me. We were always allowed to use whatever results we could come up with, except in very specific cases (where using a later result to prove something would introduce circular reasoning, because what we were proving was needed for that)
05:44:40 <mib_5szgn4zn> ok ive edited it, still think im doing something wrong
05:44:42 <ski> (zachk : maybe s/he thinks you are ..)
05:44:57 <BeelsebobWork> mib_5szgn4zn: what have you got at the moment?
05:44:59 <Cale> mib_5szgn4zn: Do you know about what map does now?
05:45:06 <byorgey> zachk: hehe
05:45:16 <zachk> ski: i am only slightly scared of recursion, not very
05:45:17 <mib_5szgn4zn> yea, maps's are cleared for me
05:45:20 <Axman6> zachk: why do you believe that?
05:45:26 <mib_5szgn4zn> ohh hang on, think it works
05:45:26 <BeelsebobWork> mib_5szgn4zn: hint -- [(String, Int)] is not the same as [(Int, String)]
05:45:29 <saml> > let rec = rec in rec
05:45:32 <mib_5szgn4zn> just gonna test it
05:45:44 <lambdabot>   thread killed
05:45:54 <saml> thread killed is new bottom
05:46:01 <Cale> Recursion is a good thing to be slightly scared of, just because if you're writing things in a recursive way, you probably have missed a chance to use or define a higher order function.
05:46:03 <Cale> :)
05:46:26 <zachk> i am still tossing away my looping garbage
05:46:30 <mib_5szgn4zn> wicked, thanks guys, ive got it working
05:46:37 <zachk> so recursion is a step in the correct direction for me
05:46:45 <Taejo> > let reason_we're_here = "we're here because " ++ reason_we're_here
05:46:46 <lambdabot>   <no location info>: parse error on input `;'
05:47:18 <Deewiant> > let reason_we're_here = "we're here because " ++ reason_we're_here in reason_we're_here
05:47:20 <lambdabot>   "we're here because we're here because we're here because we're here becaus...
05:47:26 <BeelsebobWork> > fix ("we're here because " ++ )
05:47:28 <lambdabot>   "we're here because we're here because we're here because we're here becaus...
05:48:13 <saml> > let loop n f x = if n <= 1 then f else loop (n - 1) (f (f x)) in loop 10 (+1) 1
05:48:14 <lambdabot>       Occurs check: cannot construct the infinite type: t = t -> t
05:48:14 <lambdabot>      Proba...
05:50:10 <Peaker> > cycle "we're here because "
05:50:12 <lambdabot>   "we're here because we're here because we're here because we're here becaus...
05:50:23 <Peaker> what do I win? :)
05:50:25 <saml> > cycle 1
05:50:26 <lambdabot>       No instance for (Num [a])
05:50:26 <lambdabot>        arising from the literal `1' at <inter...
05:50:29 <LoneTech> where is fix from?
05:50:30 <Cale> zachk: right, it's important to master the idea of it. It's just that all the common patterns of recursion can be captured into functions. The loops you used to write turn into functions acting on lists.
05:50:38 <saml> @info? fix
05:50:39 <lambdabot> Unknown command, try @list
05:50:57 <saml> @hoogle fix
05:50:58 <lambdabot> Data.Function fix :: (a -> a) -> a
05:50:58 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
05:50:58 <lambdabot> module Control.Monad.Fix
05:51:04 <Axman6> @src fix
05:51:05 <lambdabot> fix f = let x = f x in x
05:51:11 <LoneTech> thanks
05:51:14 <saml> fix is in Data.Function
05:51:19 <zachk> what is this mondrian business
05:51:33 <saml> > fix cycle "a"
05:51:34 <lambdabot>   Couldn't match expected type `[Char] -> t'
05:51:58 <Peaker> easier to see fix as:  fix f = f (fix f)
05:52:02 <Axman6> > fix (1+)
05:52:04 <lambdabot>   * Exception: stack overflow
05:52:09 <Axman6> that was quick
05:52:33 <Axman6> > fix (\n -> 1+ $! n)
05:52:34 <lambdabot>   <no location info>: parse error on input `$!'
05:52:39 <Axman6> > fix (\n -> (1+) $! n)
05:52:47 <Peaker> I think Haskell's overloading of func-call VS let as an operational hint is a hack ;)  It would be nicer as a more orthogonal hint (perhaps more like strictness annotations?)
05:52:55 <lambdabot>   thread killed
05:53:04 <saml> > fix (\f n -> if n <= 0 then 1 else n * (f n)) (+1) 4
05:53:05 <lambdabot>       No instance for (Ord (a -> a))
05:53:05 <lambdabot>        arising from a use of `<=' at <in...
05:53:23 <saml> > fix (\n -> if n <= 0 then 1 else n * n) 4
05:53:23 <Taejo> Peaker: you mean we should separate naming from sharing?
05:53:24 <lambdabot>       No instance for (Ord (t -> a))
05:53:24 <lambdabot>        arising from a use of `<=' at <in...
05:53:48 * SamB_XP doesn't understand Peaker 
05:53:53 <Axman6> > fix f
05:53:54 <lambdabot>   Add a type signature
05:53:59 <mib_5szgn4zn> ok another question for ya all. How would I get my final output string to print out like this: http://www.mibbit.com/pb/e2Pb2y
05:54:00 <Axman6> > fix f :: Expr
05:54:00 <lambdabot> Title: Mibbit: PasteBin
05:54:01 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
05:54:30 <Peaker> Taejo, SamB_XP: no no, I don't think it makes sense for    fix f= f (fix f) to be operationally different (yet semantically equivalent) to: fix f = let x = f x in x
05:54:40 <mib_5szgn4zn> ive tried putStr but it prints in horizontally
05:54:59 <idnar> > let fix f = f (fix f) in fix f
05:55:01 <lambdabot>   Add a type signature
05:55:03 <idnar> > let fix f = f (fix f) in fix f :: Expr
05:55:04 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
05:55:05 <SamB_XP> Peaker: not even for a stupid compiler ?
05:55:12 <saml> mib_5szgn4zn, use '\n' ?
05:55:16 <idnar> > let fix f = let x = f x in x in fix f :: Expr
05:55:17 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
05:55:27 <saml> mib_5szgn4zn, oh sorry. misunderstood
05:55:28 <mib_5szgn4zn> and the *'s represent the number of occurances of the word
05:55:31 <idnar> what's the difference?
05:55:38 <Peaker> SamB_XP: I think its nicer to have the hints as actual hints, rather than overloading syntactic constructs. e.g: strictness annotations
05:55:40 <mib_5szgn4zn> its cool saml
05:56:01 <SamB_XP> Peaker: well ... how would that look ?
05:56:22 <maltem> idnar: I think the first one may blow the stack while the other doesn't. Otherwise they're equivalent
05:56:29 <Peaker> idnar: when ghc encounters fix f = ... fix f ...   it does not cache the result and recomputes (fix f) every time in the recursion.  With the "let" approach, fix f is computed once and re-used by the recursive reference
05:56:45 <mib_5szgn4zn> my output string needs to contain newline characters terminating the lines, but im not sure how to implement that
05:57:09 <Axman6> mib_5szgn4zn: print might help
05:57:14 <Peaker> SamB_XP: Perhaps fix f = f {- cache -}(fix f)   -- or some other pragma
05:57:17 <Axman6> actually, no
05:57:23 <mib_5szgn4zn> ive managed to group my string, and count the occurances
05:57:43 <mib_5szgn4zn> sort it alphabetically etc
05:57:58 <Peaker> idnar: let and func-call are denotationally/semantically equivalent, but operationally ghc assigns them different meanings
05:58:10 <Peaker> (the binding part of them at least)
06:00:24 <Philippa_> Peaker: that's exactly what you were asked about - separating naming and sharing
06:00:44 <Axman6> mib_5szgn4zn: putStrLn "test\ntest" works
06:00:54 <Peaker> oh, then yeah, separate naming from sharing ;)
06:01:22 <Philippa_> all that's actually needed to do it is another annotation that prevents thunk updates
06:01:56 <Philippa_> (thus removing the sharing)
06:02:07 <SamB_XP> oh, yes, THAT could be done ... but why ?
06:02:12 <Ingmar> Is ghc's shared library support going to be usable for 6.10.1, on Linux x86_64?
06:02:21 <Philippa_> well, it'd be useful occasionally for avoiding space leaks
06:02:25 <Peaker> SamB_XP: because fix f = f (fix f) is more readable than @src fix ?
06:02:35 <Philippa_> it's not the first time an annotation like that's been proposed
06:02:37 <luite_> what should I use instead of the Maybe monad if I want to return an error message about why it failed?
06:02:41 <Philippa_> Peaker: that doesn't achieve what you want
06:02:47 <dobblego> luite_, Either
06:02:58 <Philippa_> you're asking for CSE on fix to turn it /into/ the shared version, no?
06:03:02 <Peaker> Philippa_: why not? I assume it will identify re-use of an already-existing thunk and share that
06:03:10 <Axman6> luite_: Left String is often used for errors
06:03:12 <luite_> dobblego: does that also have the convenient 'short circuiting' of Maybe?
06:03:14 <mib_5szgn4zn> axman6, would you be be able to explain how if you got the time?
06:03:20 <Axman6> with Right a being the result
06:03:24 <dobblego> luite_, (Either e) is a monad if that is what you mean
06:03:33 <Philippa_> yeah. CSE is trickier than you think, and in a lazy language it's an easy way to gain major space leaks
06:03:36 <Axman6> mib_5szgn4zn: what am i explaining?
06:03:48 <maltem> Ingmar: It isn't in the release notes at least
06:03:49 <Cale> mm_freak: Apart from the name being inaccurate, because not every subset of the elements occurs, it's not such a terrible interpretation, but it can be a little odd.
06:03:51 <mib_5szgn4zn> how putStrLn "test\ntest" works
06:04:15 <Cale> mm_freak: (regarding that "powerset construction")
06:04:29 <zachk> cool http://doc.gold.ac.uk/~ma503am/alex/asciirave/
06:04:32 <Axman6> you just need to do "do putStrLn "your\n String"
06:04:35 <Peaker> Philippa_: I wish a runtime system could use runtime profiling and heuristics to decide what to share :)
06:04:40 <Philippa_> in the meantime, this is a case where you shouldn't be looking at the source
06:04:48 <Axman6> it's IO, so needs to be in a do construct
06:04:49 <Philippa_> Peaker: so fuck off and write one that does it
06:05:14 <Philippa_> in the meantime, it's not a viable approach - and it's certainly not appropriate for GHC as it is
06:05:44 <Peaker> Philippa_: I didn't suggest it for ghc, I suggested not using let/funcall be used to distinguish share/non-share, but rather pragmas, instead
06:06:02 <quicksilver> Axman6: part of what you said is not true.
06:06:15 <mm_freak> Cale: ok, i think, i've got the concept of definedness now
06:06:20 <quicksilver> Axman6: do notaion is jsut syntactic sugar; monadic code does not have to be in a do block
06:06:30 <Philippa_> Peaker: no, you just suggested something more specific than that - namely inserting sharing via CSE
06:06:33 <quicksilver> 'main = putStrLn "hi"' is a valid program.
06:06:34 <Axman6> ok, well fair enough
06:06:40 <mm_freak> the last thing i need to struggle with is arrows =)
06:06:48 <mm_freak> although i don't really feel the need to do so
06:06:51 <Axman6> yeah, i knew that... not sure why i said it now :P
06:07:05 <Axman6> i use main = print answer all the time
06:07:07 <Philippa_> by the time you add the pragmas into the 'nice' version of fix, it's not so nice any more
06:07:18 <Peaker> Philippa_: Well, only when the "cached" pragma is used
06:07:35 <luite_> dobblego: I meant the behaviour of the bind function for Either
06:07:42 <Philippa_> which is /still/ unclear to read. Whereas the let version makes it clear exactly what is cached and over what scope
06:07:54 <dobblego> luite_, observe:
06:08:06 <dobblego> @instances Monad
06:08:07 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
06:08:15 <dobblego> Either e <-- ding!
06:08:30 <luite_> @src (Either) (>>=)
06:08:30 <lambdabot> Source not found. You speak an infinite deal of nothing
06:08:34 <Philippa_> and given the historical context, the Right Thing is to annotate /uncached/ - not cached. Because there's no other construct that /could/ be used to provide sharing
06:08:36 <Axman6> @src Either (>>=)
06:08:36 <lambdabot> Left  l >>= _ = Left l
06:08:36 <lambdabot> Right r >>= k = k r
06:08:40 <luite_> ah, thanks
06:08:53 <Axman6> didn't actually expect that to work :P
06:08:59 <Axman6> but makes sense i guess
06:09:13 <niklaus> i have an string of brackets, i denote ( as +1 and ) as -1 , I store the cummulative sum of this string of length (30000) in an array. Now i flip some kth bracket and i want the minimum cummulative sum in less than O(n) ie something like O(logn) or so
06:09:16 <luite_> yes, I just wanted to be sure, I couldn't find it with hoogle
06:09:37 <Philippa_> you'd effectively be making haskell either call-by-name by default instead of call-by-need, or dependant on a compiler's CSE analysis
06:09:41 <Philippa_> neither of these is a good thing
06:09:54 <quicksilver> luite_: I dont' think hoogle can find instances
06:10:52 <Philippa_> (incidentally: you need to consider that top-level bindings are also all effectively let-bound - what about lambdas?)
06:11:02 <Taejo> niklaus: you mean you want the minimum value of cumsum(a)-cumsum(b) after flipping a single bracket?
06:11:10 <Peaker> Philippa_: why did you get pissed off at the suggestion of the runtime system?
06:11:57 <niklaus> Taejo, mimum value of cumsum (i ) for all 0<=i<=n
06:12:26 <Taejo> niklaus: are you committed to an array as your datastructure?
06:12:37 <saml> > > > >
06:12:38 <niklaus> Taejo, no
06:12:38 <lambdabot>   <no location info>: parse error on input `>'
06:12:39 <Philippa_> Peaker: the (perceived) sarcastic tone. It's also a really bad solution for a lot of purposes
06:12:51 <niklaus> Taejo, i can change it
06:12:58 <Philippa_> like it or not, sometimes you need to have sane semantics known at compile-time
06:13:21 <Peaker> Philippa_: I'd love to be able to specify the operational semantics completely separately from the denotational ones, somehow
06:13:26 <quicksilver> What I think is an eminently fair criticism, though ( Peaker / Philippa_ ) is that the operational consequence of naming something is not really spelt out in tutorials/docs.
06:13:36 <Taejo> niklaus: are you only ever flipping one value? or are you interleaving queries and updates?
06:13:42 <Philippa_> additionally, this is a much, much harder one than, say, what to inline
06:13:50 <Philippa_> and the heuristics can get it badly wrong
06:13:55 <Philippa_> quicksilver: yeah, that is problematic
06:14:13 <quicksilver> almost everything written about haskell allows you to drift along believing that it's all denotation and the operational aspect is somehow so 'obvious' it's hardly worth worrying about.
06:14:14 <niklaus> Taejo, interleaving flips and queries
06:14:21 <quicksilver> no one actually says that, of course.
06:14:26 <quicksilver> but it's easy to be lured into believing it.
06:14:28 <Philippa_> *nod* - which admittedly is often the case
06:14:35 <Taejo> niklaus: nice problem, I'll think about it
06:14:40 <Philippa_> it's one of those "come back to it if you know you have cause to worry" things
06:15:20 <Philippa_> Peaker: that would be nice. But we need sane defaults in the case where it's not specified, and you were effectively talking about ripping that up where a more minimal approach would do
06:16:05 <Peaker> Philippa_: I'm really just bothered because it took me many minutes to understand and later explain what fix did in its "let" notation, whereas the recursive (fix f) reference is much easier to read and explain
06:16:21 <Philippa_> and using CSE to recover sharing really isn't too sane
06:16:44 <Taejo> @src fix
06:16:44 <lambdabot> fix f = let x = f x in x
06:16:45 <Philippa_> Peaker: the lesson here is that this isn't a place where you should assume the source is the only docs you need
06:16:55 <Peaker> Philippa_: Has there been a lot of research work done on CSE?
06:17:01 <Philippa_> yes, there has
06:17:08 <Philippa_> the interaction with laziness is a bitch
06:17:09 <maltem> Peaker: for another one, fix f = x where x = f x
06:17:14 <zachk> what is a CSE?
06:17:25 <Philippa_> zachk: Common Subexpression Elimination
06:17:26 <Taejo> zachk: common subexpression elimination
06:17:40 <Philippa_> maltem: yeah, that's a nicer way to write the let version
06:18:43 <Peaker> Philippa_: why does strictness make CSE easier?
06:19:19 <Philippa_> Peaker: because there's much less of a problem with humungous potential space leaks
06:20:11 <Philippa_> under lazy evaluation, it's possible to unwittingly leave piles of thunks everywhere. Doubly bad if they're bound to a top-level variable and thus have global scope
06:23:23 <Peaker> does CSE only share equivalent expressions (e.g repeated "fix f") or also runtime-equivalent things (a "fix g" anywhere else where f happens to be == g) ?
06:23:26 <Philippa_> to put it another way: with a strict scheme, you know (at least assuming you didn't return them) when the values cease to be live
06:24:02 <Taejo> niklaus: I'm thinking of some sort of partially-sorted tree, where each node keeps track of how many queries have taken place since its children were updated
06:24:13 <Philippa_> Normally the former, in that normally you haven't recorded the constraint needed. It can be made to do the latter if you know that f == g though
06:24:41 <Peaker> Philippa_: so it only includes memoization in cases where that can be proven in compile-time?
06:24:53 <Peaker> (that it is the same call)
06:25:09 <quicksilver> CSE is a general term.
06:25:19 <quicksilver> it woudl encompass anything which can be proven to be equal
06:25:20 <niklaus> Taejo, i have a DS(fenwick tree) which stores the cummulative sum of elements (preprocessing)  and further queries/updates in O(logn), but i fail how to find it minimum of sums in O(logn)
06:25:28 <quicksilver> but it is generally apply only at compile time.
06:25:38 <zachk> yay i got myself banned from #java for saying "ill grok your face" after there was a smug comment by someone with ops
06:26:36 <Taejo> niklaus: yeah, I thought of something with binary-indexed trees (didn't know of a functional alternative)
06:26:40 <Philippa_> quicksilver: in a lot of cases there aren't any expressions left at run-time :-)
06:27:06 <Philippa_> but it's an optimisation pass and all the usual stuff about "well actually you can delay compile-time /into/ run-time" applies
06:27:32 <Philippa_> that said: it's a much, much bigger problem at runtime
06:27:45 <quicksilver> yes. My badly grammatised comment was only intended as a generalisation.
06:28:10 <quicksilver> CSE is normally considered a static/syntactic thing. But you can obviously discuss other ways of extending it.
06:28:36 <Philippa_> tbh, in sane languages where == might not be structural equality, I don't see it happening outside a dependently-typed language any time soon
06:28:42 <Philippa_> granted, plenty of dynamic languages are insane
06:28:58 <Philippa_> but then, half the insanity comes courtesy of mutability - at which point they ain't equal, they've got distinct identities
06:31:00 <mm_freak> is it an 'instance definition' or an 'instance declaration'?
06:31:08 <mm_freak> declaration, i suppose
06:31:18 <EvilTerran> i generally say "decleration", although i think they're both right
06:31:42 <Peaker> Philippa_: In what dynamic languages is == not sane?
06:31:48 <quicksilver> mm_freak: I thin kit's a definition.
06:31:56 <Taejo> I generally say "instance decelleration" because they slow the compiler down
06:32:07 <mm_freak> hehe
06:32:08 <quicksilver> mm_freak: A 'declaration' would be where you indicated the existence but deferred the implementation to elsewhere. I'm not sure.
06:32:12 <Philippa_> Peaker: ones where you've always got structural equality available
06:32:30 <Peaker> Philippa_: What is structural equality? can you give an example?
06:32:35 <mm_freak> quicksilver: it's a definition and a declaration in one shot
06:32:45 <quicksilver> mm_freak: yes, I'd agree with that.
06:32:50 <Peaker> Philippa_: a Data.Map that uses a different tree to represent the same map, still being Equal to another Data.Map ?
06:33:03 <Philippa_> no, that's precisely what structural equality /isn't/
06:33:07 <Philippa_> it'd pick up the difference
06:33:17 <mm_freak> i think, i'll say declaration
06:33:21 <Philippa_> it's "look at the actual structure" - but abstraction barriers matter
06:33:52 <mm_freak> and "definition", where i refer to the body of the instance de*
06:34:03 <mm_freak> seems to be the best approach to me
06:34:08 <Peaker> Philippa_: I don't understand - why would you want to expose the differences between two Data.Maps that are == with differing trees?
06:34:34 <Philippa_> Peaker: well, for one you might want to support reflection
06:34:40 <Philippa_> for another, you might be GvR
06:35:17 <Philippa_> which is to say: convention's not good enough for this one because someone could break it - perhaps justifiably so
06:35:18 <Peaker> Philippa_: Guido? Where does he expose such a difference?  {1:2} == {1:2} no matter what the dict internals are
06:35:35 <mm_freak> or i could write something like this:  ["definition", "declaration"] >>= ("have a look at the instance " ++)
06:35:39 <mm_freak> =)
06:36:03 <Philippa_> Peaker: yeah, now define your own class. Oh, wait, your internals are all visible
06:36:18 <BeelsebobWork> interesting -- apple's C compiler supports "higher order code blocks" now
06:36:21 <Peaker> Philippa_: but my __cmp__ (==) does not expose them?
06:36:23 <BeelsebobWork> (read lambda abstractions)
06:36:50 <Philippa_> Peaker: I don't mean "that which your language binds to ==" here
06:37:07 <Philippa_> I'm talking about whether it's possible to make that distinction at all
06:38:09 <Peaker> Philippa_: If you do some aggressive CSE that breaks code that dives into unexposed details of a class, I don't think it'd cause a riot ;)
06:38:30 <Philippa_> right until that code was supposed to have legit access to it, anyway
06:38:56 <Philippa_> and you're in no end of trouble if what it breaks involved foreign calls
06:39:15 <Philippa_> you could stuff up external resource management
06:39:18 <BeelsebobWork> http://paste.lisp.org/display/69107#4
06:39:19 <BeelsebobWork> fun
06:39:24 <BeelsebobWork> horrific syntax
06:39:27 <BeelsebobWork> but yay
06:39:45 <Philippa_> it's C, all the syntax is horrific :-)
06:40:03 <BeelsebobWork> hehe
06:40:05 <BeelsebobWork> true
06:41:05 <quicksilver> BeelsebobWork: GCC has something along these general lines, doesn't it?
06:41:18 <quicksilver> BeelsebobWork: local functions which (I think) capture local variables closure-style.
06:41:27 <BeelsebobWork> quicksilver: I'm not sure -- I only heard about this because apple's llvm-gcc started supporting it
06:42:18 <quicksilver> http://gcc.gnu.org/onlinedocs/gcc/Nested-Functions.html
06:42:26 <lambdabot> Title: Nested Functions - Using the GNU Compiler Collection (GCC)
06:42:29 <quicksilver> looks like the closures are only valid until the calling function terminates, though.
06:42:32 <quicksilver> so it's weaker.
06:50:07 <mib_5szgn4zn> how could i get my grouped string list with the number of occurances, looking like this: http://www.mibbit.com/pb/gINYnq
06:50:08 <lambdabot> Title: Mibbit: PasteBin
06:51:04 <Axman6> mib_5szgn4zn: replicate will be very helpful there
06:51:19 <Axman6> > replicate 3 '*'
06:51:21 <lambdabot>   "***"
06:51:22 <BeelsebobWork> unlines . map (\(s,c) -> pad s ++ " " ++ show c)
06:51:36 <BeelsebobWork> oh, yeh
06:51:36 <mib_5szgn4zn> eg my list is this [("around",1),("falls",1),("in",1),("mainly",1),("plain",1),("rain",1),("spain",1),("the",2)]
06:51:54 <mib_5szgn4zn> and i need to get it like how i put on the paste bin
06:52:24 <BeelsebobWork> (map . second) ((flip replicate) '*') [("around",1),("falls",1),("in",1),("mainly",1),("plain",1),("rain",1),("spain",1),("the",2)]
06:52:30 <BeelsebobWork> > (map . second) ((flip replicate) '*') [("around",1),("falls",1),("in",1),("mainly",1),("plain",1),("rain",1),("spain",1),("the",2)]
06:52:31 <lambdabot>   [("around","*"),("falls","*"),("in","*"),("mainly","*"),("plain","*"),("rai...
06:52:45 <Axman6> that's disgusting BeelsebobWork
06:53:02 <BeelsebobWork> > map (\(x,y) -> x ++ " " ++ y) . (map . second) ((flip replicate) '*') $ [("around",1),("falls",1),("in",1),("mainly",1),("plain",1),("rain",1),("spain",1),("the",2)]
06:53:04 <lambdabot>   ["around *","falls *","in *","mainly *","plain *","rain *","spain *","the *...
06:53:11 <BeelsebobWork> > unlines . map (\(x,y) -> x ++ " " ++ y) . (map . second) ((flip replicate) '*') $ [("around",1),("falls",1),("in",1),("mainly",1),("plain",1),("rain",1),("spain",1),("the",2)]
06:53:13 <lambdabot>   "around *\nfalls *\nin *\nmainly *\nplain *\nrain *\nspain *\nthe **\n"
06:53:23 <Axman6> map (\(s,c) -> pad s ++ replicate c '*') ls
06:53:25 <BeelsebobWork> needs some padding to get the layout right though
06:53:45 <BeelsebobWork> Axman6: compining fmap second and first is made of awesome and win :P
06:53:52 <Axman6> concatMap (\(s,c) -> pad s ++ replicate c '*'++ "\n") ls
06:54:16 <mib_5szgn4zn> i need to have extra spaces on the left so that the right hand ends of the words line up
06:54:27 <Axman6> that's what the pad function will do
06:54:41 <Axman6> that is left as an exercise to the reader ;)
06:55:29 <mib_5szgn4zn> thats cool, ill have to define a test of some sort to check word length ryt?
06:55:43 <BeelsebobWork> > let longest = maximum . map length; pad n xs = (++ xs) . (flip replicate) ' ' . (n-) . length $ xs; in concatMap (\(s,c) -> pad s ++ replicate c '*'++ "\n") [("around",1),("falls",1),("in",1),("mainly",1),("plain",1),("rain",1),("spain",1),("the",2)]
06:55:45 <lambdabot>   Couldn't match expected type `[b]'
06:55:55 <BeelsebobWork> bah
06:55:56 <BeelsebobWork> where
06:57:06 <mib_5szgn4zn> ohh, and say the 'the' occurs two times, and i want to put 2 *'s to represent that, how would I do that aswell?
06:57:48 <BeelsebobWork> > let longest = maximum . map length; pad n xs = (++ xs) . (flip replicate) ' ' . (n-) . length $ xs; makeLines xs = concatMap (\(s,c) -> pad (longest (map fst xs)) s ++ " " ++ replicate c '*'++ "\n") xs in makeLines [("around",1),("falls",1),("in",1),("mainly",1),("plain",1),("rain",1),("spain",1),("the",2)]
06:57:49 <lambdabot>   "around *\n falls *\n    in *\nmainly *\n plain *\n  rain *\n spain *\n   t...
06:57:51 <BeelsebobWork> done
06:58:45 <Axman6> BeelsebobWork: you fail at exercise left to the reader
06:58:49 <BeelsebobWork> hehe
06:58:54 <BeelsebobWork> I know I do
06:58:57 <BeelsebobWork> pad takes an argument
06:59:26 <mib_5szgn4zn> its cool axman6, doesnt make sense to me so need to do it myself hehe
06:59:36 <Axman6> heh
06:59:54 <BeelsebobWork> tbf pad n xs = (++ xs) . (flip replicate) ' ' . (n-) . length is fairly horrible
07:00:02 <BeelsebobWork> and I'd slap him if I got that to mark
07:00:05 <BeelsebobWork> :D
07:00:10 <mib_5szgn4zn> lol
07:00:16 <Axman6> mib_5szgn4zn: first thing you should do is write a function pad lenth str :: Int -> String -> String
07:00:36 <BeelsebobWork> and don't write it like I did
07:00:37 <BeelsebobWork> :P
07:01:28 <mib_5szgn4zn> doesnt make sense to me so i cant lol
07:01:37 <Axman6> yes, BeelsebobWork is an idiot and things cool kids should always use pointfree style
07:01:45 <Axman6> k*
07:02:07 <BeelsebobWork> Axman6: except it's not point free
07:02:07 <BeelsebobWork> :D
07:02:12 <BeelsebobWork> it's just convoluted
07:02:14 <mib_5szgn4zn> but thats how i want it: "around *\n falls *\n in *\nmainly *\n plain *\n rain *\n spain *\n t...
07:02:17 <Axman6> even worse
07:02:25 <BeelsebobWork> @pl  pad n xs = (++ xs) . (flip replicate) ' ' . (n-) . length
07:02:26 <lambdabot> pad = flip ((.) . flip (++)) . (flip replicate ' ' .) . (. length) . (-)
07:02:29 <BeelsebobWork> there you go
07:02:32 <BeelsebobWork> use that
07:02:34 <BeelsebobWork> :D
07:03:08 <Axman6> @unpl pad = flip ((.) . flip (++)) . (flip replicate ' ' .) . (. length) . (-)
07:03:09 <lambdabot> pad q c f = (replicate (q - (length f)) ' ') ++ c
07:03:16 <mib_5szgn4zn> the annoying thin is that we havent even covered that stuff
07:04:24 <Axman6> @unpl pad n xs = (++ xs) . (flip replicate) ' ' . (n-) . length
07:04:25 <lambdabot> pad n xs h = (replicate (n - (length h)) ' ') ++ xs
07:04:39 <quicksilver> omg? your lecturer expects you to be able to THINK and READ on your OWN?
07:04:42 <Axman6> why's it getting three arguments >_<
07:04:43 <quicksilver> what is the world coming to.
07:04:53 <quicksilver> I would demand a full refund.
07:04:59 <mib_5szgn4zn> lol
07:05:29 <mib_5szgn4zn> even the coversheet says dont expect to understand this, its covered further on lol
07:05:57 <Axman6> quicksilver: it is a but unfair when they are expecting you to do stuff for assignments four chapters ahead of where you're being taught. might as well not be lectured in that case
07:06:20 <mib_5szgn4zn> thats how it feels
07:06:38 <BeelsebobWork> yeh, that sucks
07:06:50 <mib_5szgn4zn> and i dont get marks for using the stuff ive not done yet
07:06:53 <mr_H> hi
07:06:58 <mib_5szgn4zn> o/
07:07:19 <mr_H> anyone knows where can i find which package to import based on a function name ?
07:07:19 <Axman6> our statics lectuere is pathetic
07:07:29 <Axman6> hoogle
07:07:35 <Axman6> @hoogle array
07:07:35 <mr_H> thanks
07:07:35 <lambdabot> package array
07:07:35 <lambdabot> Data.Array.Base array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
07:07:35 <lambdabot> Data.Array.IArray array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
07:07:51 <BeelsebobWork> mr_H: you can even get it based on a type
07:07:59 <mr_H> @hoogle isXText
07:08:00 <lambdabot> No results found
07:08:02 <mr_H> :P
07:08:06 <mr_H> guess im out of luck
07:08:06 <BeelsebobWork> @hoogle a -> Map Int a
07:08:07 <lambdabot> Data.Map singleton :: k -> a -> Map k a
07:08:07 <lambdabot> Data.Map insert :: Ord k => k -> a -> Map k a -> Map k a
07:08:07 <lambdabot> Data.Map deleteAt :: Int -> Map k a -> Map k a
07:08:12 <Axman6> @hoogle it based on a type
07:08:12 <lambdabot> No results found
07:08:14 <Axman6> damnit
07:08:23 <BeelsebobWork> @hoogle it -> based -> on -> type
07:08:24 <lambdabot> Did you mean: it -> based -> on -> Type /count=20
07:08:24 <lambdabot> Text.XHtml.Frameset (<<) :: HTML a => Html -> b -> a -> b
07:08:24 <lambdabot> Text.XHtml.Strict (<<) :: HTML a => Html -> b -> a -> b
07:08:26 <BeelsebobWork> :D
07:08:26 <mib_5szgn4zn> lambabot when were you made?
07:08:27 <Axman6> @hoogle (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
07:08:27 <lambdabot> Data.Array.Base array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
07:08:27 <lambdabot> Data.Array.IArray array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
07:08:27 <lambdabot> Data.Array.Base unsafeArray :: (IArray a e, Ix i) => (i, i) -> [(Int, e)] -> a i e
07:08:39 <BeelsebobWork> @vixen asl
07:08:39 <lambdabot> 19/f/California
07:08:42 <BeelsebobWork> there you go :)
07:08:46 <mib_5szgn4zn> lol
07:08:47 <Axman6> heh
07:09:01 <mr_H> :D
07:09:51 <maltem> Axman6: our statics lecturer, on the other hand, does the lectures in English, which has already been source for nice confusion :)
07:10:28 <Axman6> maltem: what else should it be done in?
07:10:28 <mr_H> hoogle isn't working for what i want, any other tips ?
07:10:43 <maltem> Axman6: well, in Germany...?
07:10:45 <Axman6> maltem: what do you want?
07:10:48 <mib_5szgn4zn> beats my comp sci lectures lol
07:10:52 <Axman6> maltem: french?
07:10:57 <mr_H> i need to find what module inside HXT has the function isXText ...
07:11:02 <maltem> ...
07:11:03 <mib_5szgn4zn> i learn more at home
07:11:05 <Axman6> we had the best comp sci lecturer last semester
07:11:33 <Axman6> @where hoogle
07:11:34 <lambdabot> http://haskell.org/hoogle
07:11:41 <Axman6> mr_H: try that
07:12:04 <BeelsebobWork> mr_H: grab the source, and grep it
07:12:15 <Axman6> or read it...
07:15:57 <vegai> anyone know where haskell-hint source is? the hackage page doesn't say much
07:16:57 <mr_H> BeelsebobWork: ill do that
07:19:57 <mib_5szgn4zn> am i on the right track axman6 and beelsebobwork: http://www.mibbit.com/pb/Egj0wz
07:19:58 <lambdabot> Title: Mibbit: PasteBin
07:20:05 <int-e> vegai: http://www.glyc.dc.uba.ar/daniel/repos/hint/ (via googling the author's name and 'hint')
07:20:09 <lambdabot> Title: Index of /daniel/repos/hint
07:20:19 <BeelsebobWork> mib_5szgn4zn: looks good -- but you're gonna need to add some spaces before the word
07:20:23 <BeelsebobWork> so that everything all lines up nicely
07:20:31 <BeelsebobWork> see if you can figure out how many spaces you need to add
07:20:33 <BeelsebobWork> and then add them
07:20:36 <Axman6> mr_H: yep, except you haven't padded it...
07:20:39 <Axman6> uh, mib_5szgn4zn
07:20:59 * BeelsebobWork hands Axman6 the "you've just been BeelsebobWorked trophy"
07:21:07 <vegai> int-e: thanks
07:21:17 <Axman6> might want to pad it before passing it to formatWord
07:21:35 <BeelsebobWork> mib_5szgn4zn: also, int isn't a concrete type
07:21:38 <BeelsebobWork> it's a type variable
07:22:07 <Axman6> @src unlines
07:22:08 <lambdabot> unlines = concatMap (++ "\n")
07:22:17 <Axman6> handeh
07:22:19 <mr_H> hmm
07:22:44 <mr_H> something tells me that hxt documentation is old, because i can't find isXText on the source except on a commented function :/
07:22:48 <mr_H> ehh
07:23:00 <mib_5szgn4zn> im not too sure what you mean by pad it
07:23:19 <Axman6> pad 5 "abc" = "  abc"
07:23:42 <Axman6> pad 5 "abcde" = "abcde"
07:24:10 <Axman6> mr_H: what is HXT anyway?
07:24:20 <mib_5szgn4zn> pad 5 "abc" = " abc", moves 2 the right?
07:24:44 <BeelsebobWork> mib_5szgn4zn: pad 5 should make all strings it gets 5 characters long
07:24:49 <BeelsebobWork> by adding spaces to the beginning
07:25:06 <mib_5szgn4zn> ok cool
07:25:47 <Axman6> now you just need a simple function which will do that, using replicate maybe... >_>
07:26:01 <mr_H> Axman6: its the haskell xml toolkit :P
07:26:13 <Axman6> ah
07:26:19 <mr_H> i've found it
07:26:22 <Axman6> isn't ther haxml?
07:26:30 <quicksilver> well, that's what HXT stands for
07:26:34 <quicksilver> but yes, it is only one possibility.
07:26:36 <mr_H> hxt deprecates haxml
07:26:43 <quicksilver> mr_H: it certainly does not.
07:27:03 <quicksilver> HaXML is still actively maintained.
07:27:11 <mr_H> anyway, i found it that they removed the filter operations in one of these versions
07:27:12 <quicksilver> and I don't htink HXT has a lazy parser.
07:27:22 <mr_H> hxt is based on parsec
07:27:32 <mr_H> and arrows :P
07:27:36 <mr_H> (whatever that is)
07:27:39 <mib_5szgn4zn> what does flip do guys?
07:27:57 <mr_H> switches the arguments :P
07:27:59 <Axman6> @src flip
07:28:00 <lambdabot> flip f x y = f y x
07:28:01 <mr_H> "flips" them
07:28:22 <Axman6> don't worry about flip though. people use it to make them look smart
07:28:40 <mr_H> Axman6: like most haskell functions :)
07:28:51 <Axman6> not realy
07:28:53 <Axman6> l*
07:29:09 <lilac> if it helps, you can think of flip as bind2nd
07:29:19 <Axman6> o.O
07:29:37 <mr_H> flip is nice for pointless programming
07:29:42 <Axman6> oh, i guess... i don't see how that helps though
07:29:42 <lilac> so flip map [1,2,3] is map with the second argument fixed at [1,2,3]
07:30:51 <EvilTerran> > let (<...>) = flip in (map <...> [1,2,3]) (^2)
07:30:52 <lambdabot>   [1,4,9]
07:31:02 <Axman6> flip map [1,2,3] would five you (\f -> map f [1,2,3])
07:31:11 <chrisdone> > map (flip map [1,2,3]) [(*1),(^6),(-5)]
07:31:12 <lambdabot>       No instance for (Num (a -> a))
07:31:13 <lambdabot>        arising from a use of `negate' at...
07:31:25 <EvilTerran> doh
07:31:38 <chrisdone> bloody negate
07:31:47 <chrisdone> > map (flip map [1,2,3]) [(*1),(^6),(+5)]
07:31:48 <lambdabot>   [[1,2,3],[1,64,729],[6,7,8]]
07:32:05 <EvilTerran> > [1,2,3] <**> [(*1),(^6),(+5)]
07:32:06 <lambdabot>   [1,1,6,2,64,7,3,729,8]
07:32:09 <quicksilver> flip is a very powerful way to write simple intuitive code
07:32:13 <quicksilver> @pl \a e h k l s -> h a s k e l l
07:32:15 <lambdabot> flip flip id . ((flip . ((flip . ((ap . (flip .) . flip) .)) .)) .) . flip . ((flip . (flip .) . flip) .) . flip id
07:32:22 <chrisdone> quicksilver: haha
07:32:25 <BeelsebobWork> hahahahaha
07:32:25 <Axman6> >_<
07:32:26 <chrisdone> brilliant
07:32:37 <EvilTerran> it's also a very powerful way to write completely unintelligable code
07:32:39 <BeelsebobWork> that's awesome
07:33:15 <Axman6> ok, try reading that out to a daft punk song. it totally matches the beat
07:33:47 <BeelsebobWork> @unpl flip flip id . ((flip . ((flip . ((ap . (flip .) . flip) .)) .)) .) . flip . ((flip . (flip .) . flip) .) . flip id
07:33:47 <lambdabot> (\ as f j m -> (\ cl o p -> j as p m f cl o) >>= \ bg -> (\ g -> g) >>= \ bf -> return (bg bf))
07:33:51 <BeelsebobWork> haha
07:33:54 <ystael> Axman6: is . the kick, the snare, or the hi-hat?
07:34:07 <Axman6> it's dot, but it can be whatever works...
07:34:07 <mm_freak> hmm…  i just noticed that the do-notation's '<-' binding is not equivalent to (>>=)
07:34:17 <EvilTerran> it's just a robotic voice going "dot" :P
07:34:22 <BeelsebobWork> mm_freak: sure it is
07:34:23 <int-e> mm_freak: how so?
07:34:25 <Axman6> yup
07:34:25 <BeelsebobWork> it's a sugar
07:34:30 <quicksilver> mm_freak: well it uses >>=. In the presence of patterns it's a bit more subtle.
07:34:40 <EvilTerran> BeelsebobWork, well, it's not exactly equivalent, if the pattern's refutable
07:34:41 <int-e> mm_freak: oh because of pattern matches. right.
07:34:41 <mm_freak> > Just (Left 5) >>= \(Right x) -> return x
07:34:42 <lambdabot>   * Exception: /tmp/9010775163736446563:69:54-75: Non-exhaustive patterns in ...
07:34:48 <mm_freak> yes
07:35:08 <int-e> @unpl do Just x <- y; x
07:35:08 <lambdabot> do { Just x <- y; x}
07:35:12 <int-e> @undo do Just x <- y; x
07:35:13 <lambdabot> y >>= \ a -> case a of { Just x -> x; _ -> fail ""}
07:35:43 <chrisdone> chris@chrisdesktop:~/haskell$ grep flip */*.hs -R
07:35:43 <chrisdone> lojbot/Lojbot.hs:    zo'oi = flip (subRegex (mkRegex zo'oiR)) " zo'e"
07:35:43 <chrisdone> lojbot/Lojbot.hs:    | any (flip isPrefixOf msg) p = maybe (return ()) try (match 1)
07:35:43 <chrisdone> lojbot-old/Lojbot.hs:      results = nub $ sortBy (flip $ comparing entryType) $ selrafsi'
07:35:47 <chrisdone> etc
07:35:53 <mm_freak> > Just (Left 5) >>= \a -> case a of { Just x -> return x }
07:35:54 <lambdabot>   Couldn't match expected type `Either t b'
07:36:05 <mm_freak> > Just (Left 5) >>= \a -> case a of { Just (Right x) -> return x }
07:36:06 <lambdabot>   Couldn't match expected type `Either t b'
07:36:27 <chrisdone> flip is grand
07:36:39 <chrisdone> I miss it in other languages =(
07:36:42 <mm_freak> oh, the fail case is explicit
07:36:44 <mib_5szgn4zn> BeelsebobWork and axman6, hows this: http://www.mibbit.com/pb/tA6wXo
07:36:45 <lambdabot> Title: Mibbit: PasteBin
07:37:25 <BeelsebobWork> mib_5szgn4zn: I don't think the word in your definition of word refers to the right thing
07:37:31 <mm_freak> chrisdone: i miss a lot of things in other languages
07:37:36 <idnar> @pl \n -> f a n && f b n
07:37:36 <lambdabot> ap ((&&) . f a) (f b)
07:37:42 <chrisdone> mm_freak: so do I
07:38:01 <BeelsebobWork> what you've written is equivalent of w = replicate (width - 2 - length w - length nstring) mib_5szgn4zn
07:38:07 <mib_5szgn4zn> hmmm
07:38:14 <int-e> > liftM2 (&&) odd even 2
07:38:16 <lambdabot>   False
07:38:20 <BeelsebobWork> also, why the 2 mib_5szgn4zn?
07:38:26 <mm_freak> i love monads and lazy recursive types, i love closures, pattern matching, etc.
07:38:43 <BeelsebobWork> and why subtract the length of showing the number?
07:38:46 <mm_freak> what i miss most often are all kinds of folds
07:38:54 <chrisdone> @quote chrisdone
07:38:55 <lambdabot> chrisdone says: benchmarks only exist to make fun of ruby
07:38:58 <chrisdone> @quote chrisdone
07:38:58 <lambdabot> chrisdone says: benchmarks only exist to make fun of ruby
07:39:03 <mib_5szgn4zn> i was trying a exercise example, really dont know how to do this
07:39:03 <chrisdone> gah
07:39:04 <Axman6> heh
07:39:09 <RayNbow> @quote lambdabot
07:39:09 <lambdabot> lambdabot says: Occurs check: cannot construct the infinite type: a
07:39:18 <BeelsebobWork> mib_5szgn4zn: maybe preword = replicate (with - length word) ' ' might work well for you?
07:39:28 <BeelsebobWork> haha
07:39:59 <mm_freak> uh, 'a' sure is infinite, that's obvious
07:40:10 <mm_freak> @quote the list monad
07:40:11 <lambdabot> No quotes for this person. Have you considered trying to match wits with a rutabaga?
07:40:13 <int-e> hmmm. reverse . take width . (++ repeat ' ') . reverse
07:40:19 <mm_freak> @quote mm_freak
07:40:20 <lambdabot> No quotes match. Take a stress pill and think things over.
07:40:27 <mm_freak> huh?
07:40:46 <BeelsebobWork> int-e: he's learning, I already showed him a convoluted point free way to do it
07:40:49 <BeelsebobWork> now he's doing it right
07:40:56 <mm_freak> @quote mm_freak1work
07:40:57 <lambdabot> No quotes match. Just try something else.
07:41:09 <mm_freak> whatever
07:41:11 <int-e> > replicate (-1) ' '
07:41:12 <lambdabot>   ""
07:41:33 <mm_freak> not to be or to be and (not to be or to be and (not to be or to be and …)), that is the list monad
07:41:38 <BeelsebobWork> int-e: sure, but he should be able to guarentee that won't happen in this instance
07:42:05 <chrisdone> clojure seems like a nice lisp
07:46:09 <mib_5szgn4zn> hmm, dont think i am doing this right sorry: http://www.mibbit.com/pb/hqKgF5
07:46:10 <lambdabot> Title: Mibbit: PasteBin
07:50:36 <Peaker> quicksilver: reading up -- gcc's nested functions only live while the containing function hasn't returned
07:51:30 <quicksilver> Peaker: yeah, I noted that in the next line, you'll see :P
07:51:51 <lilac> they generate a function on the stack. as if we didn't have enough opportunities for exploits.
07:52:51 <paggas> is there a function to scale a vertex? something like 2*(1, 2, 3) -> (2, 4, 6)
07:53:04 <quicksilver> paggas: no.
07:53:07 <quicksilver> but you can write it :)
07:53:18 <EvilTerran> lilac, are you sure? i thought they just generated a function that used the local variables on the stack
07:53:19 <Riastradh> lilac, `generate a function on the stack' doesn't imply that executable code goes on the stack.
07:53:29 <papermachine> scale a (x, y, z) = (a*x, a*y, a*z) dawg
07:53:39 <quicksilver> > dawg
07:53:40 <lambdabot>   Not in scope: `dawg'
07:53:50 <papermachine> sorry, that was a comment
07:53:52 <quicksilver> @vixen Who are you calling dawg?
07:53:52 <lambdabot> i truely am
07:54:03 <RayNbow> quicksilver, what about morrow's solution here? http://hpaste.org/9986#a1
07:54:24 <quicksilver> RayNbow: evil to the core :)
07:54:29 <papermachine> ooh, that's cool
07:54:43 <paggas> there must be some vertex processing library though, right? :)
07:54:43 <RayNbow> quicksilver: you mean, not very H98is? :p
07:54:47 <lilac> EvilTerran, Riastradh: they produce a single, normal function pointer. the outer function can be recursive. therefore, the function pointer returned must differ on different invocations
07:54:51 <RayNbow> *H98isch
07:54:56 <RayNbow> gah
07:54:59 * RayNbow can't type today :p
07:55:00 <papermachine> everywhere (mkT (*a)) x -- dawg
07:55:12 <lilac> therefore they're generating code. afair, they put the generated code on the stack, rather than dynamically allocated memory
07:55:30 <EvilTerran> > dawg
07:55:31 <lambdabot>   'sup
07:55:40 <papermachine> lol
07:55:59 <EvilTerran> lilac, ah, of course, recursion
07:56:00 <quicksilver> "In the GCC compiler, trampoline refers to a technique for implementing pointers to nested functions. The trampoline is a small piece of code which is constructed on the fly on the stack when the address of a nested function is taken. The trampoline sets up the static link pointer, which allows the nested function to access local variables of the enclosing functions. The function pointer is then simply the address of the trampoline."
07:56:41 <EvilTerran> ... i was about to say there'd still be a neater way of doing that, but i think quicksilver's beaten me to the punch
07:57:10 <EvilTerran> > sup dawg
07:57:11 <lambdabot>   yo
07:58:37 * EvilTerran notes with some irritation that the book he needs isn't on google book search
08:03:57 <RayNbow> :t sup
08:03:58 <lambdabot> forall t a. t -> Sym a
08:04:17 <RayNbow> > orderPizza
08:04:18 <lambdabot>   Not in scope: `orderPizza'
08:04:33 <RayNbow> lambdabot has a short-term memory
08:10:07 <Philippa_> ...building happy requires happy? Yay, clearly my GHC install is condemned to be unhappy
08:10:39 <quicksilver> you're not the first to notice that, Philippa_ . I forget the workaround though.
08:14:41 <Philippa_> grabbing the binary distro of 1.17 seems to be working
08:14:50 <Philippa_> urgh, except then it wants perl
08:14:59 <Philippa_> WTF isn't the configure stage telling me this stuff?
08:15:33 <lilac> building happy presumably just requires a pre-happy'd source tree
08:15:50 <chrisdone> it's annoying to hear people say haskell is not imperative or good at dealing with state. "haskell says your program is a calculation". no, haskell says that your program is imperative but that the bulk of code that the imperative code uses is pure
08:16:50 <chrisdone> SPJ, the Haskell grandmaster, says Haskell is his favourte imperative language, and people are saying things like that? bah flargh
08:17:13 <quicksilver> chrisdone: people being ignorant on the internet? ;P
08:17:35 <chrisdone> hehe ;-)
08:20:43 <int-e> http://xkcd.com/386/ :)
08:20:44 <lambdabot> Title: xkcd - A Webcomic - Duty Calls
08:21:14 <chrisdone> it's true
08:21:53 <medfly> lol
08:22:05 <Philippa_> I can understand people who have a vehement distaste for the monad syntax, to be fair
08:23:55 <chrisdone> I'm just watching the Clojure presentation and he says “and that's an area where I think Clojure disagrees with Haskell; if your program is mostly a calculation, you can get away with that. but most programs I've written are not calculations. I've written broadcast automation systems that have to run 24 hours a day and there's all kinds of state”
08:24:44 <Philippa_> yeah, that kind of stuff's aggravating
08:24:54 <chrisdone> yeah
08:25:01 <Philippa_> though admittedly it's understandable for people to have concerns about the operational behaviour of a State monad or similar
08:25:17 <Philippa_> (if I'm honest, I'm far more certain of how it'll behave in a strict language)
08:25:58 <Twey> @hoogle (a -> b) -> a -> a -> Ordering
08:25:59 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
08:25:59 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
08:25:59 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
08:28:43 <chrisdone> Philippa_: could be
08:32:31 <mib_harte9by> hey guys
08:32:37 <mib_harte9by> sorry to bug you agin
08:32:45 <mib_harte9by> *again
08:33:56 <mib_harte9by> beelsebobwork, i have come up with this: http://www.mibbit.com/pb/F0anfy
08:33:57 <lambdabot> Title: Mibbit: PasteBin
08:34:25 <RayNbow> mib_harte9by: you are not bugging us, we are converting you into a Haskell evangelist ;)
08:34:35 <quicksilver> the general idea of formatWord looks good, mib_harte9by
08:34:41 <quicksilver> however, the type signature is wrong
08:34:44 <mib_harte9by> however instead of multiple '*' I want them to represent the number of words in my given string
08:34:46 <quicksilver> (word,n) is not a (String)
08:34:59 <mib_harte9by> thats my tester sorry
08:35:22 <BeelsebobWork> mib_harte9by: doesn't look quite like what you indended
08:35:40 <mib_harte9by> im trying to get the * to represent the number of occurances in my string
08:36:26 <BeelsebobWork> okay
08:36:37 <BeelsebobWork> so why do you include anything to do with the width of the word in that definition?
08:36:47 <BeelsebobWork> the number of stars has nothing to do with the width of the word, no?
08:36:59 <BeelsebobWork> > replicate 5 '*'
08:37:00 <lambdabot>   "*****"
08:37:02 <mib_harte9by> its just my test sorry, i can chuck that
08:37:37 <mib_harte9by> http://www.mibbit.com/pb/Blsuej
08:37:38 <lambdabot> Title: Mibbit: PasteBin
08:38:39 <BeelsebobWork> okay, now I'm wondering how many times you want to replicate the star
08:38:55 <mib_harte9by> ive got a count function to count all the occuarnces in my string
08:39:08 <BeelsebobWork> okay, maybe you need to call it?
08:39:23 <chrisdone> hm, lame. STM in Clojure allows side effects in transactions. kind of fail
08:39:28 <mib_harte9by> yea i think so, thats what i am having trouble with
08:40:11 <mib_harte9by> eg i get this countWords "The rain in Spain falls mainly on the plain." [("falls",1),("in",1),("mainly",1),("on",1),("plain",1),("rain",1),("spain",1),("the",2)]
08:40:24 <BeelsebobWork> mib_harte9by: what's wrong with this? http://hpaste.org/11438
08:40:43 <Philippa_> chrisdone: what else do you expect in a lisp-like language?
08:40:56 <saml> > let a + b = a ++ b in "Java style string " + "concat"
08:40:58 <lambdabot>   "Java style string concat"
08:41:10 * BeelsebobWork shudders
08:41:28 <quicksilver> chrisdone: that's not fail, as long as the side-effects are forced to provide abort and rollback callbacks.
08:41:30 <chrisdone> Philippa_: perhaps a run-transaction special operator that throws exceptions when side-effectual things are used
08:41:31 <quicksilver> chrisdone: are they?
08:41:34 * quicksilver looks doubtful.
08:41:48 <mib_harte9by> i get this *** Does not match : (String,Int)
08:41:49 <chrisdone> quicksilver: no. if you print, it will print every retry time. he says "so, don't print"
08:43:33 <chrisdone> Philippa_: maybe even just using types like IO or STM. (+ 1 "2") is an error, why not (run-transaction (print "foo")) be an error? am I missing something about lisp?
08:44:11 <quicksilver> chrisdone: yes. "2" is evaluated before its type is checked.
08:44:31 <quicksilver> chrisdone: and then the result has type string, or whatever, which isn't a number and so the + gives an error.
08:44:52 <quicksilver> run-transaction can't really be call-by-value though.
08:44:57 <quicksilver> that would be a bit strange :)
08:45:02 <chrisdone> quicksilver: right, it would have to be special or a macro
08:45:12 <quicksilver> yes, it's a special form
08:45:27 <quicksilver> but my point is you can't do the kind of 'dynamic type checking' that + does
08:45:37 <quicksilver> because that's based on call-by-value, and running checks on the value.
08:48:19 <chrisdone> quicksilver: could the runtime perhaps fail/throw an exception when encountering a side-effect procedure while running a transaction?
08:48:41 <Baughn> ..I leave for two hours, and #haskell turns into #lisp
08:49:01 <quicksilver> chrisdone: well, there is no consistent way of tagging side-effect procedures.
08:49:11 <quicksilver> chrisdone: in a (mostly) call-by-value setting
08:49:23 <quicksilver> you have no idea if the next thing you evaluate might cause a side effect or not.
08:49:34 <chrisdone> quicksilver: well what about the fundamental side-effect procedures?
08:49:35 <quicksilver> of course it's possible to audit the code explicitly at runtime
08:49:52 <chrisdone> yeah, something like that?
08:50:07 <quicksilver> but that means chasing all symbols
08:50:15 <quicksilver> and requires all source to all symbols to be available
08:50:28 <quicksilver> which isn't the case in most lisps (not sure if it is in clojure?)
08:50:41 <Baughn> They aren't always all known, either
08:50:50 <quicksilver> Baughn: well, we're discussing lisp implementations of STM
08:50:58 <quicksilver> Baughn: there is a distinct haskell link
08:51:17 <quicksilver> discussing why, in the absence of any guarantee that STM transations don't have other side effects, it's a much less useful technique.
08:51:22 <Baughn> quicksilver: I wasn't protesting. Although, why would you *want* to go to those lengths to prevent IO?
08:51:33 * quicksilver hopes what I just typed answers that.
08:51:34 <chrisdone> let's say you're evaluating (run-transaction (+ 2 (do (print "foo") 5))), it could evaluate PRINT and at the evaluator throw an exception
08:51:41 <Baughn> Tell the programmer that, if he uses IO, he breaks STM
08:52:18 <Baughn> Then if he does so anyway it's his problem. I don't agree with heroic efforts to save programmers from themselvf.
08:52:51 <lilac> what about heroic efforts to enforce constraints which the programmer wants to be enforced?
08:53:22 <Baughn> It's not really that hard to avoid IO, even in lisp
08:53:58 <lilac> how can you do that without help from the type system?
08:54:20 <lilac> if you call some arbitrary function, how can you be sure it doesn't do some IO on the sly?
08:54:35 <Baughn> Documentation?
08:54:50 <Baughn> Practically speaking, you won't /have/ source, so it's really the only option
08:55:15 <lilac> note /on the sly/. maybe it updates a cache. i wouldn't expect that to be documented
08:55:40 <Baughn> Then, if it's reasonably well written, it should still be safe
08:56:16 <Baughn> (Heck, I've done that in Haskell)
08:56:23 <lilac> probably
08:56:32 <chrisdone> hmm
08:56:42 <lilac> but part of the point of STM is that you can prove things, like your program doesn't livelock or deadlock
08:57:10 <Baughn> Yes, you do lose something by not using Haskell. ^_^
08:57:44 <idnar> I think the important point is that you lose something, but not everything
08:57:50 <Baughn> That might be turned into an advantage too, though. Write STM for lisp, make programmers see its usefulness, then tell them that if they switch to haskell it works /even better/ in simple to understand ways
08:58:26 <chrisdone> I think I might prefer the language enforcing things because then I don't have to think about it as much. I don't mean because I'm lazy, but because people make mistakes and it's safer
08:58:58 <chrisdone> I don't like this whole "let's make a deal that you won't do this" business
08:59:03 <Baughn> chrisdone: Oh, I agree. I just think the proper solution is to use Haskell, not to effectively write a static checker for lisp
08:59:14 <chrisdone> Baughn: sure
08:59:25 <Baughn> Mostly since the latter won't /work/
09:04:27 <chrisdone> I do think Clojure looks like a really cool lisp though. kind of what everyone expected Arc to be (or expected it not to be, but wished otherwise), I bet. one implementation, no historical baggage, well thought out (seemingly)
09:05:10 <chrisdone> sorry, I'm off-topic
09:06:08 <chrisdone> (Arc /was/ funny, though)
09:27:52 <Cale> http://jcsu.jesus.cam.ac.uk/~csr21/lolpg.jpg
09:28:49 <lament> haha
09:35:34 <plutonas> @src unwords
09:35:34 <lambdabot> unwords [] = ""
09:35:34 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
09:39:04 <vixey> hello
09:40:19 <mib_harte9by> lambdabot:
09:40:22 <mib_harte9by> longestWord = maximum . map length pad n xs = (++ xs) . (flip replicate) ' ' . (n-) . length $ xs mWord xs = concatMap (\(s,c) -> pad (longestWord (map fst xs)) s ++ replicate c '*' ++ "\n") xs
09:41:00 <mib_harte9by> hmm, not coming out how i need it too
09:49:18 <pumpkin_> shouldn't you stick a > in front of that?
09:49:36 <vixey> @let longestWord = maximum . map length pad n xs = (++ xs) . (flip replicate) ' ' . (n-) . length $ xs mWord xs = concatMap (\(s,c) -> pad (longestWord (map fst xs)) s ++ replicate c '*' ++ "\n") xs
09:49:36 <lambdabot>   Parse error
09:53:32 <Beelsebob> vixey: you scare me
09:53:55 <vixey> !
09:53:56 <Beelsebob> mostly because you wrote *almost* exactly the same code as I wrote 6 hours ago, completely independantly
09:54:03 <Beelsebob> there's a couple of variable name differences
09:54:10 <Beelsebob> but other than that, identical
09:54:21 <vixey> It's called clairvoyant programming - the opposite of extreme programming
09:54:28 <Beelsebob> :D
09:54:41 <Beelsebob> you're obviously not doing it right though
09:54:48 <vixey> I'm just beginning
09:54:52 <Beelsebob> otherwise you would have got my superior variable names
09:54:53 <Beelsebob> :P
09:55:40 <Beelsebob> @let longestWord = maximum . map length; pad n xs = (++ xs) . (flip replicate) ' ' . (n-) . length $ xs; mWord xs = concatMap (\(s,c) -> pad (longestWord (map fst xs)) s ++ replicate c '*' ++ "\n") xs
09:55:41 <lambdabot>  Defined.
09:55:58 <vixey> :t longestWord
09:55:59 <lambdabot> forall a. [[a]] -> Int
09:56:04 <vixey> grrrr
09:56:12 <vixey> I hate Int
09:56:36 <Beelsebob> > mWord [("jam", 6), ("monkies", 2), ("ham", 5), ("spleen", 12), ("badger", 2)]
09:56:37 <lambdabot>   "    jam******\nmonkies**\n    ham*****\n spleen************\n badger**\n"
09:56:40 <elliottt> map genericLength? :)
09:56:45 <Beelsebob> :)
10:27:51 <newsham> who keeps going around telling people that haskell programs cant crash?
10:27:56 <newsham> grrrr
10:28:56 <vixey> whe cares if your program terminates as long as it gives the right answer!
10:31:35 <tromp_> my program main=main never gives the wrong answer!
10:34:35 <path[l]> if Ive got a list of items and Im trying to find min and I know the smallest possible value something can take is 0, is there a way I can get minimum of list to terminate early when it finds a 0?  Maybe by defining my own type where 0 is the smallest value?
10:35:42 <tromp_> just write your own min for class Bounded
10:35:43 <bd_> well, you can use takeWhile (>= 0)
10:36:01 <nominolo_> @seen waern
10:36:08 <bd_> or (>= minBound) if you're defining your own type
10:36:19 <bd_> actually, no, nevermind on >= minBound
10:36:22 <vixey> path[l]: Have you ever heard of continuation passing style?
10:36:25 <bd_> obviously that's always true >.<
10:36:28 <lambdabot> I saw waern leaving #darcs, #ghc, #haskell.se and #haskell 20h 6m 54s ago, and .
10:36:49 <tromp_> you can define it in terms of span (> minBound)
10:37:14 <tromp_> or just spell out the recursion
10:37:18 <Deewiant> > foldr1 (\a b -> if a == 0 then 0 else min a b) [0..]
10:37:20 <lambdabot>   0
10:37:20 <path[l]> Im afraid not vixey.
10:37:22 <path[l]> bd did you mean min of takeWhile >= 0?
10:37:51 <vixey> path[l]: It's very simple to program this using CPS, if we start from the basic recursive version that doesn't early out
10:38:08 <vixey> path[l]: why don't you hpaste the basic version?
10:38:12 <Saizan> with lazy evaluation we don't really need CPS for this
10:38:33 <tromp_> let (pos,minB) = span (>minBound) list in if null minB then min pos else minBound
10:38:37 <Saizan> as Deewiant has demonstrated
10:39:02 <path[l]> umm Im afraid I dont really have the code yet. Im still just thinking it out :), Given that haskell is strongly typed and lazy evaluated I was wondering if that would come to my aid with something like minimum
10:39:19 <path[l]> like if I defined min for my bound type, minimum would be smart enough or something
10:39:26 <vixey> path[l]: oh right, yeah don't bother with my way if you don't want to learn a new tool
10:39:28 <rwbarton> @src min
10:39:28 <lambdabot> min x y = if x <= y then x else y
10:39:40 <Deewiant> minimum won't work since it uses a left fold
10:39:45 <tromp_> oh, i meant minimum pos instead of min pos
10:39:55 <vixey> :t foldr (\x y -> min 0 (min x y)) 0
10:39:58 <lambdabot> forall b. (Ord b, Num b) => [b] -> b
10:40:35 <Deewiant> > foldr (\x y -> min 0 (min x y)) [0..]
10:40:36 <ski> > foldr (\x y -> min 0 (min x y)) 0 [1,2]
10:40:37 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
10:40:37 <lambdabot>        arising from a use...
10:40:38 <lambdabot>   0
10:40:43 <Deewiant> > foldr (\x y -> min 0 (min x y)) 0 [0..]
10:40:45 <lambdabot>   * Exception: stack overflow
10:41:07 <vixey> > foldr (\x y -> min 0 (min x y)) 0 [1..]
10:41:09 <lambdabot>   * Exception: stack overflow
10:41:10 <path[l]> Deewiant: why does it matter whether I use right or left fold? Sorry Im still learning this from a book I guess Im not far enough yet.
10:41:10 <rwbarton> path[l]: you can define <= on a newtype of Integer so that min 0 y = 0
10:41:33 <rwbarton> path[l]: but you won't be able to use minimum as Deewiant says
10:41:44 <Deewiant> path[l]: the left fold always traverses the whole list before producing a result
10:41:50 <tromp_> @let fastmin list = let (pos,minB) = span (>minBound) list in if null minB then minimum pos else minBound
10:41:51 <lambdabot>  Defined.
10:41:54 <path[l]> oh I see
10:42:03 <path[l]> ok that I think I understand.
10:42:06 <rwbarton> path[l]: I mean, minimum will then force the entire spine of the list, but not all of its the elements, so that's still something.
10:42:10 <ski> > foldr min 0 [x,y,z]
10:42:11 <lambdabot>   min x (min y (min z 0))
10:42:13 <ski> > foldl min 0 [x,y,z]
10:42:14 <lambdabot>   min (min (min 0 x) y) z
10:42:15 <tromp_> > fastmin ['\0', undef,'A']
10:42:16 <lambdabot>   Not in scope: `undef'
10:42:19 <path[l]> how about foldr then?
10:42:21 <tromp_> > fastmin ['\0', undefined,'A']
10:42:23 <lambdabot>   '\NUL'
10:42:39 <ski> (actually s/fold? min 0/fold?1 min/ ..)
10:42:40 <Deewiant> foldr works but it fills the call stack
10:43:03 <path[l]> oh I see you said foldr1 not foldr
10:43:30 <Deewiant> foldr1 is essentially just foldr
10:43:39 <path[l]> oh thats just foldr without a startig argument
10:43:47 <path[l]> yeah just saw it on hoogle :)
10:44:29 <path[l]> ok I understood the takewhile solution and tromps solution with takeWhile (though does that make it iterate the list twice?)
10:44:49 <ski> > [x..z] -- hm
10:44:50 <lambdabot>   * Exception: not a number
10:44:58 <path[l]> but I didnt understand the foldr solution yet
10:45:35 <Deewiant> > foldr1 f [x,y,z]
10:45:36 <lambdabot>   f x (f y z)
10:48:40 <path[l]> so if I do @let fastmin list = let (pos,minB) = span (>minBound) list in if null minB then minimum pos else minBound, does it run through the list twice? Once for span and once for minimum? Or does laziness prevent that?
10:50:05 <ski> barring fusion, it runs through the prefix twice
10:50:14 <path[l]> ah
10:50:38 <rwbarton> It's more that due to laziness the notion of "running through the list twice" isn't very well defined.
10:51:13 <path[l]> well I mean if I dont have a 0, it'll first hunt for a zero and then hunt for minimum
10:51:40 <ski> yes, but quite possibly these two will be interleaved
10:52:02 <ski> hm
10:52:09 <path[l]> oh automatically by the compiler?
10:52:18 <path[l]> thats pretty neat
10:52:25 <eth01> it is
10:52:40 <rwbarton> This is a tricky example, I'm not 100% sure what is going on, but let me give you an easy example
10:52:50 <rwbarton> consider   map (+2) (filter even list)
10:52:55 <path[l]> ok
10:52:59 <ski> actually `null minB' would probably construct `pos' before `minimum pos' gets a chance (stil barring fusion or other heavy oprimizations)
10:53:22 <rwbarton> In a strict language the filter would run entirely before the map and there would be a big intermediate list generated
10:53:37 <path[l]> right
10:53:49 <path[l]> ski so whats fusion? And aww I guess :/
10:53:53 <rwbarton> but in a lazy language, demanding the first element of the result just causes the filter to run long enough to return the first result, and then the (+2) happens.
10:54:06 <path[l]> ah ok, I see what you mean
10:54:06 <rwbarton> then if you demand another result, the filter runs a little longer, etc.
10:54:14 <path[l]> but as ski pointed out checking for null
10:54:18 <path[l]> makes takewhile complete
10:54:18 <ski> (path[l] : re "automatically by the compiler?" no, by the run-time system .. but possibly there will not be interleaving here .. at least with naive graph-reduction)
10:54:41 <path[l]> ah
10:54:57 <pstickne> some strict languages use explicit generators/projections to avoid the intermediate steps/data
10:55:18 <rwbarton> This behavior I described for the map (+2) (filter even list) example isn't what's called "list fusion", it's just a result of the lazy evaluation strategy
10:55:33 <rwbarton> You will see it even without any optimizations
10:55:58 <path[l]> so I guess that doesnt give me much optimisation. It looks like minimum.(takeWhile (>0)) might be faster?
10:56:00 <rwbarton> I think ski is right though that in this fastmin definition an intermediate list will get produced
10:56:09 <Baughn> map (+2) (map (*3) list) <-- This will likely be optimized to map ((+2) . (*3)) list, which I believe is fusion. At any rate, it gets rid of an intermediate list
10:56:29 <rwbarton> It gets rid of an intermediate list, but only one cons cell of that list was going to exist at a time anyways.
10:56:31 <path[l]> Baughn:  oh I see, ok
10:56:42 <vixey> ?go foldr fusion
10:56:45 <lambdabot> No Result Found.
10:56:51 <rwbarton> So both run in constant memory, but the "fusion" version will have a constant speed factor advantage.
10:57:00 <path[l]> right
10:57:30 <vixey> http://joshkos.blogspot.com/2007/11/fold-fusion-strikes-back.html
10:57:31 <lambdabot> Title: Joshsoft: Fold-Fusion Strikes Back
10:58:00 <tromp_> @let ffm x y = if y==minBound then y else min x y
10:58:01 <path[l]> so coming back to the problem I was discussing, is minimum.(takeWhile (>0)) more efficient than the span version?
10:58:01 <lambdabot>  Defined.
10:58:09 <path[l]> thanks vixey
10:58:23 <tromp_> @let fastmin2 = foldr ffm maxBound
10:58:24 <lambdabot>  Ambiguous type variable `a' in the constraints
10:58:26 <Baughn> @type span
10:58:27 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
10:58:34 <Baughn> @src span
10:58:34 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
10:58:42 <Baughn> path[l]: No, most likely not
10:59:00 <ski> @let fastmin2 :: (Ord a,Bounded a) => [a] -> a; fastmin2 = foldr ffm maxBound
10:59:01 <lambdabot>  Defined.
10:59:09 <Baughn> path[l]: If it is, the difference will be a constant additive, not even a factor
10:59:11 <tromp_> > fastmin2  ['\0', undef,'A']
10:59:12 <lambdabot>   Not in scope: `undef'
10:59:17 <tromp_> > fastmin2  ['\0', undefined,'A']
10:59:18 <lambdabot>   * Exception: Prelude.undefined
10:59:25 <rwbarton> With minimum . takeWhile (> 0) how do you know whether the list had a 0 or not?
10:59:30 <ski> > minBound :: Char
10:59:31 <lambdabot>   '\NUL'
10:59:51 <rwbarton> I guess you just need to write takeWhileAndThenOneMore
10:59:59 <path[l]> rwbarton: whoops, right I see what you mean. But yeah
11:00:07 <Baughn> Which can be conveniently written with span. :P
11:00:13 <path[l]> hehe
11:00:21 <rwbarton> @src span
11:00:22 <lambdabot> Source not found. My brain just exploded
11:00:27 <path[l]> Im trying to avoid running through the list twice when I dont have a 0
11:00:42 <tromp_> fastmin2 should do that
11:00:46 <tromp_> but it has a bug:(
11:00:55 <path[l]> yeah Im trying to understand it :D
11:01:13 <rwbarton> @src foldr
11:01:13 <lambdabot> foldr f z []     = z
11:01:13 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:01:17 <tromp_> :t foldr
11:01:18 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:01:55 <tromp_> @let ffm2 x y = if x==minBound then x else min x y
11:01:56 <lambdabot>  Defined.
11:01:59 <tromp_> use that instead
11:02:14 <path[l]> I dont understand why foldr would succeed in quitting early if foldl will not. What am I missing?
11:02:48 <Baughn> > foldr f a [b,c,d]
11:02:49 <lambdabot>   f b (f c (f d a))
11:02:51 <rwbarton> path[l]: foldr puts applications of f on the outside, so if f never inspects its second argument, the rest of the foldr won't happen
11:02:54 <Baughn> > foldl f a [b,c,d]
11:02:55 <ski> @let fastmin22 :: (Ord a,Bounded a) => [a] -> a; fastmin22 = foldr ffm2 maxBound
11:02:55 <lambdabot>   f (f (f a b) c) d
11:02:56 <lambdabot>  Defined.
11:02:57 <path[l]> oooh
11:02:58 <path[l]> k
11:03:00 <path[l]> I get it
11:03:04 <Baughn> path[l]: Evaluation is outside-in, so..
11:03:04 <ski> > fastmin22 ['\0', undefined,'A']
11:03:06 <lambdabot>   '\NUL'
11:03:24 <path[l]> so this is a bias with how arguments are inspected in haskell?
11:03:27 <Baughn> path[l]: So long as "f" returns some value (eg. a cons cell) /before/ going on to recurse into the rest of the list, foldr is superior to foldl
11:03:49 <Baughn> path[l]: If it doesn't, foldl is tail-recursive and foldr isn't
11:03:50 <ski> path[l] : no, this is a difference in the recursion of `foldr' and the recursion of `foldl'
11:03:57 <path[l]> hmm
11:03:58 <Baughn> path[l]: (Though you should always use foldl' instead of foldl)
11:04:23 <tromp_> > fastmin22  []
11:04:24 <lambdabot>   ()
11:04:38 <tromp_> cute:)
11:04:38 <Baughn> path[l]: To put it another way: foldl is tail-recursive, foldr is head-recursive. Tail-recursive is good for strict evaluation. Head-recursion is good for lazy evaluation.
11:04:51 <rwbarton> > fastmin22 ([] :: [Char])
11:04:52 <lambdabot>   '\1114111'
11:04:53 <tromp_> > minBound
11:04:54 <lambdabot>   ()
11:04:55 <path[l]> hmm
11:05:01 <Baughn> path[l]: Haskell is lazy by default.
11:05:02 <ski> path[l] : since `foldl' is "tail-recursive", it always must walk through its iteration structure before finishing .. but `foldr' delegates full responsibility to the argument `f' speak, so to speak, so `f' may return early
11:05:27 <tromp_> > minBound :: Char
11:05:29 <lambdabot>   '\NUL'
11:06:06 <Baughn> path[l]: But foldl is capable of running in constant stack space across an entire list. foldr is *not*; it *only* works when you build up a data structure that can then be consumed incrementally. (Or that you want to stick around, I suppose
11:06:48 <Baughn> Ideally we'd have a plain fold that did both, but I don't see how
11:07:20 <ski> Baughn : i'd say this depends on whether you're foldring strict function or not ..
11:07:25 <path[l]> ah ok I think I finally get it. So foldr would do f b (f c( fd ... So if f b returned without evaluating fc it ends
11:07:40 <mauke> > foldr f z [a,b,c]
11:07:41 <lambdabot>   f a (f b (f c z))
11:07:55 <tromp_> foldr can easily run in constant space
11:07:57 <Baughn> path[l]: Right, but if it can't do that, you get to stick the entire fold computation on the stack
11:08:10 <path[l]> right
11:08:12 <ski> > foldr f z [0..]
11:08:13 <lambdabot>   f 0 (f 1 (f 2 (f 3 (f 4 (f 5 (f 6 (f 7 (f 8 (f 9 (f 10 (f 11 (f 12 (f 13 (f...
11:08:19 <tromp_> e.g. foldr const
11:08:32 <path[l]> so I pay the price of stack space for a potential early return
11:08:40 <Deewiant> yep
11:08:43 <tromp_> > foldr const undefined [0..]
11:08:45 <lambdabot>   0
11:08:56 <tromp_> admittedly not to useful:(
11:09:05 <Baughn> path[l]: Part of this is the GHC evaluation model - it isn't capable of handing off partial evaluations into the heap, or in general heap-allocating stack frames. It is, however, capable of not using stack frames for anything lazy
11:09:22 <ski> hm, maybe there should be a variant of `foldr' not acceping an ending case, and giving error on empty list ?
11:09:32 <Deewiant> ski: foldr1?
11:09:51 <Baughn> path[l]: That is to say, once it's done a single dethunk, the dethunk'd bit gets stuck in the heap and the stack is back to zero. Admittedly a vast oversimplification, but..
11:09:53 <tromp_> foldr1 const undefined []
11:09:54 <ski> no, the type of `foldr1' is too restrictive
11:10:00 <tromp_> > foldr1 const undefined []
11:10:01 <lambdabot>   * Exception: Prelude.undefined
11:10:09 <tromp_> > foldr1 const 42 []
11:10:10 <lambdabot>       No instance for (Num [[a] -> a1])
11:10:10 <lambdabot>        arising from the literal `42' ...
11:10:13 <tromp_> > foldr1 const []
11:10:15 <lambdabot>   * Exception: Prelude.foldr1: empty list
11:10:21 <path[l]> what does foldl` do? I dont understand the strict thing
11:10:49 <Baughn> path[l]: That forces the evaluation of the produces structure at each iteration of the fold, assuming it's an atomic value
11:11:02 <ski> @let foldrS f [] = error "foldrS _ []"; foldrS f (a:as) = f a (foldrS f as)
11:11:03 <Baughn> path[l]: Um. The problem with foldl is..
11:11:03 <lambdabot>  Defined.
11:11:05 <ski> @type foldrS
11:11:06 <lambdabot> forall t t1. (t -> t1 -> t1) -> [t] -> t1
11:11:10 <ski> that one
11:11:55 <Baughn> path[l]: foldl itself is tail-recursive. It runs in constant space. However, it runs in constant space while building up a value consisting of a Giant Chain of Thunks (tm), that is the f applications, that have to be forced all at once once foldl is technically done
11:12:16 <Baughn> path[l]: foldl' forces those to be done while the fold is running, avoiding the otherwise inevitable stack overflow
11:12:23 <Baughn> path[l]: The optimizer usually turns foldl into foldl'
11:12:56 <Baughn> path[l]: ..is this helping at all?
11:13:20 <path[l]> umm I think so. Im sure some of this will only make sense to me weeks from now
11:13:36 <path[l]>  When would I not want to use foldl' then? And want foldl instead
11:13:53 <mauke> basically, never
11:13:54 <Deewiant> a good rule of thumb is "never"
11:13:56 <rwbarton> BTW, none of the span solutions really work.  minimum . takeWhileAndOneMore (> 0) with a straightforward recursive definition of takeWhileAndOneMore works
11:14:24 <path[l]> I understood the foldl and foldr diference and how Id skip out early. And thats great, so thanks guys.
11:14:49 <path[l]> oh it doesnt? hehe I see
11:14:51 <ski> (for fun on "returning early", see `find' at <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>)
11:14:52 <lambdabot> http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>
11:15:05 <Baughn> path[l]: As I understand it, the only reason foldl isn't defined as foldl' is because you could, theoretically, make a haskell implementation that wouldn"t have these issues - and anyhow it doesn't affect semantics, only whether or not your program crashes
11:15:23 <path[l]> ah
11:16:11 <SamB_XP> Baughn: I thought it was because foldl might sometimes be needed when you were actually using a lazy function ?
11:16:15 <rwbarton> > foldl' (\x y -> y) 0 [3, undefined, 5]
11:16:16 <lambdabot>   * Exception: Prelude.undefined
11:16:19 <rog> if i'm getting a "non-exhaustive patterns in lambda" error, is there a straightforward way to see what the pattern's trying to match against, other than by changing all the patterns to case statements with error clauses that print it?
11:16:22 <rwbarton> > foldl (\x y -> y) 0 [3, undefined, 5]
11:16:24 <lambdabot>   5
11:16:29 <SamB_XP> oh, wait, but that's not SEMANTIC need
11:16:32 <SamB_XP> sorry ;-)
11:16:36 * ski curses rwbarton and his fast fingers
11:16:36 <Baughn> SamB_XP: I've heard mutterings to that effect, on occasion. I just haven't gotten any good explanations of why.
11:16:50 <SamB_XP> since you still need a finite list for it to work ...
11:16:51 <Deewiant> rog: you can try compiling with -Wall
11:17:16 <path[l]> well I guess Ill get back to reading through rwh
11:17:57 <Baughn> path[l]: The lesson here is, I think, that you _do_ still have to understand the entire tower of code that haskell runs on, right down to the machine
11:18:08 <path[l]> yeah
11:18:11 <Baughn> That's probably why people have trouble with haskell so much. It's a high tower. :P
11:18:35 <rog> Deewiant: i know my patterns are potentially non-exhaustive - my runtime invariants *should* keep it ok. but it's not. presumably compiling with -Wall will just tell me what i already know?
11:18:45 <path[l]> I  agree, I cant just take the functions at face value if Im interested in efficiency. Ill have to understand whats going on
11:18:47 <SamB_XP> well, you don't have to understand it all thoroughly at least ;-)
11:18:59 * rog wishes for some kind of a debugger!
11:19:14 <vixey> debuggers are horrible :/
11:19:19 <SamB_XP> rog: allocation profiling?
11:19:22 <Deewiant> rog: well yeah, if you know the ones that won't work which it could possibly be, then just trace it at runtime
11:19:27 <vixey> debugging code is admitting defeat
11:19:27 * mauke gives rog ghci
11:19:29 <SamB_XP> what are your patterns ?
11:20:00 <SamB_XP> are they for custom types ?
11:20:08 <vixey> rog: Sometimes you can express the invarients in the type system
11:20:17 <vixey> rog: with e.g. GADTs
11:20:22 <SamB_XP> ah, true
11:20:31 <SamB_XP> it's a bit awkward though :-(
11:20:37 <ski> (declarative debuggers might be better ..)
11:20:45 <SamB_XP> ski: oh, most assuredly
11:21:02 <rog> i tried to express the invariants in the type system (using HList). i gave up. my current code is at http://hpaste.org/11441#a0
11:21:12 <SamB_XP> whatever they would be would certainly be better than GHCi's for 99% of problems
11:21:41 <SamB_XP> rog: well, you COULD try using a more powerful type system -- like Coq's ;-)
11:21:42 <vixey> rog I don't see any hlist in there
11:21:49 <rog> the expression i tried was: testdfn $ mkdfn $ PDistrib normal :~ (PDistrib range :~ PDouble 5 :~ PDouble 8) :~ (PDistrib range :~ PDouble 2 :~ PDouble 3)
11:21:52 <SamB_XP> vixey: he just said he gave up on HList
11:22:15 <Samy> <vixey> debugging code is admitting defeat
11:22:15 <Samy> +1
11:22:28 <Deewiant> @remember vixey debugging code is admitting defeat
11:22:29 <lambdabot> Nice!
11:22:30 <SamB_XP> Samy: you do it like this
11:22:36 <SamB_XP> vixey++
11:22:41 <SamB_XP> @karma vixey
11:22:42 <lambdabot> vixey has a karma of 2
11:22:49 <Samy> karma sucks
11:22:49 <mauke> preflex: remember <vixey> debugging code is admitting defeat
11:22:54 <mauke> preflex: karma vixey
11:22:54 <preflex>  karma for vixey: 5
11:22:58 <rog> SamB_XP: there are always going to runtime invariants. it'd just be nice to be able to get some info about what was going on when they break
11:23:01 <mauke> Samy: you do it like this: karma--
11:23:05 <Samy> preflex, karma PoppaVic
11:23:05 <SamB_XP> Samy: I think it's more that we keep losing all manner of state ...
11:23:06 <preflex>  PoppaVic has no karma
11:23:13 <SamB_XP> HOORAY
11:23:24 <SamB_XP> hmm. but I wish he had BAD karma ...
11:23:47 <SamB_XP> so ... what language is preflex written in ?
11:23:56 <lament> PoppaVic--
11:23:59 <lament> there you go!
11:24:00 <mauke> lambdahax
11:24:02 <mauke> I mean Haskell
11:24:16 <rog> vixey: so all your code works first time?
11:24:33 <SamB> rog: no, vixey debugs it at compile time
11:24:48 <SamB> or using quickcheck or something
11:25:06 <vixey> rog: "there are always going to runtime invariants" - What does that mean?
11:25:15 <rog> s/to/to be/
11:25:30 <SamB> vixey: it means rog hasn't used a total language yet
11:25:32 <vixey> rog: stuff like runtime checking that you're not adding a int to a string?
11:25:40 <rwbarton> dfn_n is supposed to be the length of the list passed to dfn_f?  is that the invariant?
11:25:44 <SamB> oh, yes, it also means he forgot the "be"
11:26:27 <rog> vixey: no. stuff like ensuring correct node patterns in a red-black tree.
11:26:48 <ski> "runtime invariant" : user doesn't enter bad input
11:27:00 <rog> rwbarton: that's an invariant, yes.
11:27:04 <mauke> heh, from 'man gets'?
11:27:08 <vixey> rog: That's been done http://www.cs.harvard.edu/~adamc/cpdt/book/html/MoreDep.html
11:27:09 <lambdabot> Title: MoreDep
11:27:44 <dons> ?users
11:27:44 <lambdabot> Maximum users seen in #haskell: 547, currently: 516 (94.3%), active: 21 (4.1%)
11:28:21 <rog> rwbarton: the invariant i *think* is being broken is that the wrong kind of PValue is being passed to one of the lambdas.
11:28:40 <vixey> rog: in any case that wasn't really a definition, and I'm still interested in what it means
11:29:16 <rog> rwbarton: but since ghci doesn't even say what line number the pattern was on, i'm not sure.
11:29:47 <rog> vixey: stuff that you're relying on to happen, but isn't expressible in the type system.
11:30:08 <rwbarton> rog: it doesn't?!
11:30:27 <vixey> rog: ok, I disagree there need always be those
11:31:12 <rog> vixey: so you should be able to express all computations in the type system?
11:31:27 <SamB> rog: ... no
11:31:32 <vixey> rog: all logical properties yes
11:31:41 <SamB> that makes it a bit hard to check types ;-)
11:31:47 <vixey> computations are just one of several ways to express logical properties
11:33:26 <philed> Use Coq?
11:33:48 <SamB> philed: darn, did I forget to say that ?
11:35:30 <rwbarton> rog: the error message tells you a [Distrib r] pattern is failing to match
11:36:00 <SamB> perhaps the list has more than one element ?
11:36:23 <rog> so if i've got a mathematical calculation that does a sqrt, and i happen to have reversed the arguments to a subtraction, so i get an error on sqrt(-ive); how can that kind of invariant be expressed in the type system?
11:36:33 <rog> anyway, dammit, i have to go.
11:36:38 <rog> sorry.
11:36:54 <SamB> rog: well, the type of sqrt wouldn't allow negative arguments ;-)
11:37:01 <lament> can you express that at all?
11:37:05 <lament> in the type system
11:37:08 <lament> (unless you're oleg)
11:37:10 * rog leaves.
11:37:21 <rwbarton> In *some* type system, sure
11:37:25 <SamB> lament: who said anything about using Haskell ?
11:37:31 * ushdf did
11:37:32 <lament> not I
11:37:48 <lament> so the operation x-y on N should be defined when x >= y
11:37:55 <Samy> preflex, be PoppaVic
11:37:55 <preflex>  trigraphs remind me of "escapes" - which means "well, we agree - but what do we send and what does it do?"
11:37:56 <Samy> err
11:38:00 <Samy> preflex, be gongoputch
11:38:01 <preflex>  Older women do it like it was a rented vagina that was getting returned tomorrow
11:38:12 <SamB> preflex: be SamB
11:38:12 <preflex>  it still irks me that if I pass --help from my bootloader, Linux does not display usage information :-(
11:38:27 <dons> Cale: i'm wearing a tshirt with the cabal logo on it :)
11:38:32 <SamB> preflex: be SamB_XP
11:38:33 <preflex>  no quotes found for SamB_XP
11:38:38 * SamB likes that quote
11:38:46 <ushdf> !grab SamB
11:38:55 <mauke> !pancakes
11:39:01 <vixey> @pancakes
11:39:02 <lambdabot> Unknown command, try @list
11:39:06 <vixey> preflex: pancakes
11:39:27 <Deewiant> @ghc
11:39:27 <lambdabot> ghc says: Urk! Inventing strangely-kinded void TyCon: :t{tc a5gUj} (* -> *) -> * -> *
11:39:41 <rwbarton> classic
11:39:44 <SamB> hey, it worked with user-mode linux
11:40:17 <dons> its a good bug
11:55:30 <mdmkolbe> I want to learn how to use the Control.Applicative (and related) modules.  Is the "Applicative Programming with Effects" paper the best place to start?
11:56:35 <dons> mm
11:56:43 <dons> stuff in real world haskell perhaps
11:58:55 <mdmkolbe> dons: RWH has applicative functors in it?  I don't see that in the table of contents.
11:59:18 <vegai> applicative functors have a real world use case? :P
12:00:27 <pcc1> does a haskell fixed point operate in the same way as, say, a fixed point in abstract interpretation?
12:00:49 <mdmkolbe> vegai: well, that's what I'm trying to figure out if they will match the multi-core parallel algorithm with IO/mutation that I have.  IO monad is too strict but Arrows are another possibility.
12:03:07 <noteventime> Could someone suggest some neat way to find all ways to choose n adjacent items from a list?
12:03:16 <mdmkolbe> pcc1: yes and no. Yes because it calculates the same function, no because it does it differently (maybe).  The fixed point "fix f" is the same as "f (f (f (f (f (f (f ...)))))" iterated infinitely.
12:03:20 <mdmkolbe> pcc1: ﻿  The fixed point in abstract interpretation takes an empty set and iteratively applys a transfer function until the set stops changing.
12:03:45 <mdmkolbe> noteventime: is n a small fixed number (e.g. 3)?
12:04:01 <noteventime> mdmkolbe: In this case, yes
12:04:24 <sjanssen> > map (take 3) $ tails [1 .. 10]
12:04:25 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10],[1...
12:04:29 <sjanssen> is close
12:04:31 <mdmkolbe> > let x = [1,2,3,4,5] in [(i,j) | i <- x, j <- x]
12:04:32 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3...
12:04:56 <rwbarton> > let x = [1..10] in zip3 x (tail x) (tail $ tail x)
12:04:57 <lambdabot>   [(1,2,3),(2,3,4),(3,4,5),(4,5,6),(5,6,7),(6,7,8),(7,8,9),(8,9,10)]
12:04:58 <mauke> > let x = [1..5] in zip3 x (drop 1 x) (drop 2 x)
12:04:59 <lambdabot>   [(1,2,3),(2,3,4),(3,4,5)]
12:05:12 <noteventime> rwbarton: Ahh, I knew there should be something like that
12:05:15 <rwbarton> > let x = [1] in zip3 x (tail x) (tail $ tail x)
12:05:16 <lambdabot>   []
12:05:23 <pcc1> mdmkolbe: thanks.  seems like I will need to implement my own fixed-point
12:05:37 <noteventime> sjanssen: That ones also neat
12:06:04 <noteventime> mdmkolbe: That one contains all combinations, doesn't it?
12:06:38 <mdmkolbe> pcc1: if you are implementing an abstract interpretation algorithm, then you are right, the "fix" function won't help you (unless maybe you're really tricky and good at tying lazy knots but I still wouldn't recomend it)
12:06:54 <mdmkolbe> noteventime: yes, I didn't see the "adjacent" requirement the first time around
12:07:17 <vixey> abstract interpretation algorithm o_o
12:07:33 <vixey> what's that?
12:08:09 <ushdf> semantics
12:08:21 <noteventime> rwbartons works nice for fixed, though sjanssen almost works for an arbitrary number
12:08:36 <noteventime> Can anyone think of a way to not include the non-complete ones?
12:09:15 <noteventime> There are some obvious bruteish ways
12:09:34 <mdmkolbe> vixey: abs interp, is the idea that you can recover information about what values different variables can have by "predending" (i.e. abstractly) to run (i.e. interpret) your program.  But instead of variables holding values they hold sets of values.
12:09:38 <mdmkolbe> vixey: ﻿  You also have to keep iterating this process b/c if you discover more values that one variable might hold, then you have might need to update another variable to hold more values, etc.
12:09:56 <vixey> mdmkolbe: oh I see, that is pretty cool
12:09:57 <noteventime> Thanks for the suggestions :) I'll see where I can take it from here
12:19:18 <Samy> hi slash_
12:19:38 <slash_> hi
12:30:05 <keseldude> How can I use something like the equivalent of get_FOO_display() in a model's __unicode__? There is no self.get_FOO_display()
12:30:27 <quicksilver> keseldude: wrong channel?
12:30:37 <keseldude> lol whoops
12:30:46 <keseldude> sorry :-[
12:30:58 <quicksilver> no skin off my nose :)
12:31:26 <vixey> what does FOO mean?
12:32:17 <quicksilver> I imagine it's a metasyntactic variable
12:32:41 <vixey> You've got me wondering if nose skin is more valuable than other skin by the way :p
12:32:48 <quicksilver> If I ever have a blues/funk group, we'll call ourselves the Metasyntactic Variables
12:32:54 <quicksilver> we won't be very good, I'm afraid.
12:33:00 <vixey> hehe
12:33:23 <quicksilver> I should probably stick to programming.
12:33:31 <vixey> I think a "foo bar" exists somewhere
12:33:37 <vixey> drinking establishment
12:34:56 <zachk> foo bar baz
12:36:08 <Baughn> vixey: Of course it is. There's less of it, so by supply and demand...
12:36:13 <quicksilver> vixey: a few google searches confirm a couple of them.
12:36:19 <gnut> hi
12:36:24 <quicksilver> hello gnut!
12:36:32 <gnut> hello quicksilver
12:36:39 <mdmkolbe> vixey: skin removed from nose is more painful than skin removed from some other places
12:36:42 <mdmkolbe> ;-)
12:36:53 <vixey> Baughn: I'm really curious now...
12:37:16 <paggas> i'm kinda confused... i have something like this: {rnext (a, b) = do x <- randomIO; if x then return (a/2, b/2) else return ((a+1)/2, (b+1)/2)}; now, how can i iterate that? that is, get something like: [x, x>>=rnext, x>>=rnext>>=rnext, ...] (for some x), but as IO [a], not as [IO a]!
12:37:23 <paggas> thanks for any help! :)
12:37:35 <Baughn> vixey: The international trade in nose skin reached $10 million last year
12:37:55 <gnut> I'm trying to import a foreign function and I get unacceptable result types in foreign declaration... don't we just use IO blah for ccall returns if the C function could have side-effects?
12:38:00 <Baughn> paggas: Iterate, then pass through sequence?
12:38:24 <quicksilver> paggas: without cheating, you can't get an infinite list out of an infinite sequence of IO actions
12:38:38 <Baughn> paggas: The cheat is called unsafeInterleaveIO
12:38:40 <paggas> aha!
12:38:44 <quicksilver> paggas: this is because when an IO action returns a list, it must do all the IO first, then return the list
12:38:49 <quicksilver> however, (a) there is a cheat for this case
12:38:50 <paggas> but if i apply take n?
12:38:58 <quicksilver> and (b) you don't need it for random numbers, anyway
12:39:14 <quicksilver> since random numbers don't really need IO.
12:39:19 <paggas> quicksilver: what would be the Right Way? :)
12:39:20 <Baughn> paggas: Incidentally, there's already a perfectly good randoms function to get an infinite list of random numbers
12:39:54 <paggas> well, i want each number to depend on the previous one, albeit in some "random" way
12:39:58 <quicksilver> paggas: the right way would be to use the pure interface to randoms
12:40:06 <quicksilver> which takes a Gen, and returns the new Gen
12:40:19 <quicksilver> then you could build up the (infinite) list in which each item depends on the item before
12:40:55 <paggas> quicksilver: can i use the system random number generator with that? /dev/urandom etc
12:40:58 <Baughn> @type randomRs
12:41:00 <lambdabot> forall a g. (RandomGen g, Random a) => (a, a) -> g -> [a]
12:41:11 <Baughn> paggas: There really is no need. Modern pseudorandom number generators are /very/ good
12:41:12 <quicksilver> paggas: well, you can use /dev/urandom to source the initial seed
12:41:27 <quicksilver> paggas: and then use the pseudo RNG after that.
12:41:39 <rwbarton> (/dev/urandom is partly a PRNG anyways)
12:41:50 <quicksilver> then you have a truly random start, which is good enough for most purposes.
12:42:10 <Baughn> paggas: But if you use getStdGen, it will normally already have been seeded like that, so there's no need to read /dev/urandom manually
12:42:21 <paggas> but if i wanted to draw all items from /dev/random?
12:42:36 <quicksilver> then you'd be stuck in IO.
12:42:41 <Baughn> paggas: Then you'd have to read it a lot. unsafeInterleaveIO would be fairly safe in this scenario
12:42:49 <quicksilver> and this would be a fairly inoffensive use of unsafeInterleave
12:43:02 <Baughn> > randomRs (0,42) (mkStdgen 42)
12:43:03 <lambdabot>   Not in scope: `mkStdgen'
12:43:22 * quicksilver hands Baughn a capital G
12:43:24 <Baughn> ..okay, who broke \bot
12:43:29 <Baughn> > randomRs (0,42) (mkStdGen 42)
12:43:30 <lambdabot>   [36,4,7,12,39,37,40,37,38,8,27,12,42,37,34,1,41,3,1,20,4,12,3,6,37,8,10,24,...
12:44:00 <Baughn> paggas: That's a purely functional source of randomness. Of course it's completely dependent on the initial seed, but that's what randomIO is for
12:44:25 <paggas> i see, thanks for the help!
12:46:20 <Baughn> paggas: By the way, excessive reading from /dev/urandom is considered to be very rude
12:46:41 <Baughn> paggas: As on many systems it'll drain the kernel of true randomness, then switching to a PRNG, and block an programs trying to use /dev/random
12:46:58 <paggas> right
12:47:10 <gwern> @seen Cale
12:47:10 <lambdabot> Cale is in #haskell, #haskell-overflow and #ghc. I last heard Cale speak 3h 19m 17s ago.
12:47:20 <Baughn> paggas: If your numbers absolutely *have* to be utterly random.. use a cryptographic PRNG, like Blum Blum Shub. It can be implemented in about three lines of haskell.
12:47:32 <SamB> or use a radio
12:47:42 <Baughn> Tricky
12:47:57 <SamB> yes, isn't  it ?
12:48:01 <Baughn> Radio isn't very random. You'd have to pass it through a hash function anyway, which wouldn't be too much faster
12:48:15 <gwern> @tell Cale i is thinking of doing a lambdabot upload today; could you push any changes you might have?
12:48:15 <lambdabot> Consider it noted.
12:48:28 <gwern> so anyway, I was amused to see franchise in the hackage rss feed
12:48:28 <lambdabot> gwern: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:48:32 <gwern> @messages
12:48:32 <lambdabot> SamB_XP said 18h 48m 55s ago: mueval is to blame
12:48:32 <lambdabot> SamB_XP said 18h 46m 49s ago: ... for messing up the indentation of pretty-printing
12:48:55 * gwern didn't realize mueval had any pretty-printing
12:48:59 <SamB> > text "hi!" $$ text "bye!"
12:49:01 <lambdabot>   hi!
12:49:01 <lambdabot>  bye!
12:49:03 <SamB> gwern: it doesn't
12:49:31 <mib_yy0fql> @messages
12:49:31 <lambdabot> You don't have any new messages.
12:49:37 <paggas> is there a monad for RNGs, like e.g. the one described in http://en.wikibooks.org/wiki/Haskell/Understanding_monads#Random_Number_Generation?
12:49:39 <lambdabot> http://tinyurl.com/ewuzt
12:49:39 <gwern> nobody likes mib_yy0fql
12:49:51 <SamB> mib_yy0fql: if you weren't around, we wouldn't be able to figure out how to spell your nick
12:49:58 <gwern> SamB: er, what's the problem exactly? I'm not up on pretty-printing
12:50:11 <SamB> gwern: those were supposed to be aligned on the left!
12:50:26 <SamB> > text "hello!" $$ text "goodbye!"
12:50:27 <lambdabot>   hello!
12:50:27 <lambdabot>  goodbye!
12:50:31 <gwern> but they are aligned to the left! in fact everything in #haskell is to my left
12:50:55 <SamB> gwern: the lines have different numbers of spaces added
12:51:10 <Baughn> > text (repeat "foo\nbar")
12:51:11 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
12:51:15 <Saizan> > show $ text "hello!" $$ text "goodbye!"
12:51:16 <lambdabot>   "hello!\ngoodbye!"
12:51:33 <Baughn> > text (concat $ repeat "foo\nbar")
12:51:45 <lambdabot>   mueval: Prelude.read: no parse
12:51:49 <Saizan> it's not really mueval, but rather lambdabot's Plugin.Eval
12:52:36 * gwern agrees that it's not my fault
12:52:37 <SamB> Saizan: I just figure anything that's gone wrong with eval is gwern's fault these days ;-)
12:52:37 * Saizan still wonders where that "Prelude.read: no parse" comes from
12:52:53 <gwern> probably the haskell-src-exts parsing
12:52:54 <Saizan> SamB: oh, that's propably the case :)
12:52:55 * Baughn itches to fix it
12:53:20 <Baughn> ..it's just, last time I tried to fix something in \bot my computer crashed
12:53:28 <SamB> lol
12:54:23 <Saizan> gwern: but Cale ripped out the haskell-src-exts parsing
12:54:38 <gwern> indeedy
12:54:46 <gwern> but cale also often runs old stuff
12:54:59 <gwern> I would like it if he would pull and rebuild daily, but for some reason he refuses to
12:55:29 <SamB> stop coding bugs then ;-)
12:55:42 <niklaus> how many ways can a number be written as sum of 4 squares ( each of the successive  square begin greater than equal to previous one)
12:55:57 <gwern> SamB: but how can I refuse the grief-stricken pleas for features?
12:56:13 <Baughn> niklaus: N, why?
12:56:19 <gwern> 'I want to evaluate 1+1!' 'I want to evaluate "fix (1:)"' wah wah wah
12:56:32 <niklaus> Baughn, atmost 4 squares like 25 = 1^2+2^2+2^2+4^2, 3^2 + 4^2, and 5^2
12:56:49 <vixey> ughh
12:56:56 <Saizan> gwern: oh, a recurring question lately has been "why did they substitute runplugs with mueval"?
12:57:06 <vixey> I wish my IRC client had a cross posting filter
12:57:33 <gwern> Saizan: 'because it's good for your cholesterol levels'
12:57:46 <Baughn> Saizan: Because runplugs was a giant hack
12:58:00 <Saizan> Baughn: because of hs-plugins?
12:58:03 <Baughn> Or perhaps that's hs-plugins?
12:58:11 <gwern> indeed. mueval/hint are still hacky, but as the GHC API improves it becomes nicer and nicer
12:58:22 <Baughn> Saizan: Very temperamental, and we've got a perfectly good API for these things now
12:58:29 <gwern> 6.10 will let us get rid of the biggest hack, writing out a file to evaluate it...
12:58:41 <gwern> which is just crazy and always was
12:59:28 <Saizan> i thought it was to solve the problem of runplugs' zombies
12:59:56 <gwern> you'd have to ask cale about zombies
13:00:21 <Saizan> btw, now we're getting mueval zombies, it seems
13:00:27 <gwern> really?
13:01:19 <Saizan> lispy reported that, iirc
13:01:32 * gwern tries to figure out why that could be. surely it's not mueval itself which is hanging - the watchdog is supposed to guarantee termination of some sort
13:02:24 <toutoutout> visit toutoutout.net
13:02:52 <Baughn> gwern: Are they actual zombies? As in, dead processes that haven'T been reaped?
13:02:53 <Saizan> not compiling lambdabot with -threaded might cause problems with waitProcess
13:03:11 <Baughn> ..yes, why isn't it doing that anymore?
13:03:16 <gwern> Baughn: heck I dunno, this is the first I've heard of mueval zombies, anyway
13:03:32 <Baughn> Not using -threaded makes the console useless. For some reason - that actually makes no sense at all.
13:03:32 <saml> could you write this program?  it runs on background for x minutes. then it suddenly becomes fullscreen for y minutes. then it goes back to background again. for windows/linux/mac.
13:03:41 <saml> do i have to use opengl for this?
13:03:54 <Baughn> saml: Opengl would do absolutely nothing for that
13:03:57 <SamB> "on background"?
13:04:01 <SamB> you mean like a rootsaver ?
13:04:02 <saml> it is to keep me from computer for y minutes after x mininutes
13:04:03 <Baughn> Preusmably "hidden"
13:04:13 <SamB> oh.
13:04:14 <Baughn> saml: Well, you could write it
13:04:19 <gwern> Baughn: I think I might've removed the -threaded option since no one could tell me what it was there for
13:04:20 <SamB> but I *like* rootsavers!
13:04:35 <saml> screensavers should have timer
13:04:45 <Baughn> gwern: Removing it breaks the console. There's not obvious reason why this should be, but it does.
13:05:19 <gwern> Baughn: by console you mean '$lambdabot'?
13:05:35 <Baughn> gwern: I mean what you get when you type "./lambdabot"
13:05:51 <Baughn> gwern: Without -threaded, when you type in rc online.rc, that command never returns
13:05:52 <gwern> Baughn: where is ./?
13:06:01 <Baughn> gwern: ...
13:06:09 * SamB finds /usr/lib/xscreensaver/m6502
13:06:34 <Baughn> gwern: Presumably anywhere there is a functional \bot install
13:07:11 <gwern> hm, I've got lb installed via cabal, and in ~/ I can type '$lambdabot' and the console seems fine
13:07:25 <gwern> obviously 'rc online.rc' fails as there is no .rc in ~/ here
13:07:37 <Baughn> ...
13:07:52 <gwern> lambdabot> rc bin/lambdabot/online.rc
13:07:54 <gwern> is fine tho
13:09:06 <Baughn> gwern: Sure. It then fails to return and let you type in further commands.
13:09:25 <gwern> not here
13:09:34 <saml> ok. i'll write in psedocode and you write in haskell.   callAfter x fullScr where fullScr = lockScreen >> callAfter y unlockScreen
13:10:00 <gwern> http://hpaste.org/11442
13:10:34 <saml> no it should loop.   screenSaver = callAfter x (lockScreen >> callAfter y screenSaver)
13:10:46 <Baughn> gwern: Oh, excuse me. In the latest version it does return, but fail to actually /connect/
13:10:55 <Baughn> gwern: It only connects when you press ctrl-c, terminating the console
13:11:02 <Baughn> gwern: ..which seems to be the case for you as well
13:17:07 <Saizan> Baughn: ctrl-d you mean?
13:17:19 <Baughn> Saizan: That works too
13:17:47 <Baughn> Saizan: ..actually, you're right. Hm. I thought I'd pressed C-c.
13:18:24 <Saizan> i get the same behaviour here too, btw
13:51:12 <tromp_> > [0.1,0.3,0.5,0.7,0.8999999999999999]
13:51:14 <lambdabot>   [0.1,0.3,0.5,0.7,0.8999999999999999]
13:51:18 <tromp_> > [0.1,0.3,0.5,0.7,0.89999999999999999]
13:51:19 <lambdabot>   [0.1,0.3,0.5,0.7,0.9]
13:51:29 <tromp_> > [0.1,0.3,0.5,0.7,1]
13:51:30 <lambdabot>   [0.1,0.3,0.5,0.7,1.0]
13:51:33 <vixey> > 0.89999999999999999
13:51:34 <lambdabot>   0.9
13:51:50 <vixey> > 0.00000000000000001
13:51:51 <lambdabot>   1.0e-17
13:52:12 <tromp_> > [0.1, 0.3 .. 0.9999999999999999]
13:52:13 <lambdabot>   [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
13:52:25 <tromp_> that's screwed up?!
13:52:39 <ushdf> yes
13:52:46 <rwbarton> not really
13:52:59 <ushdf> not if you understand the operation of the interpretter
13:53:05 <ushdf> it's sure stupid though ;)
13:53:38 <rwbarton> There is no sensible meaning for [0.1, 0.3 .. 0.9999999999999999], so I don't see what's wrong with this one
13:53:44 <tromp_> you'd expect all elements in [a,b .. c] to be <= c
13:53:53 <ushdf> > [0.09999999999999999,0.1999999999999999..0.99999999999999999]
13:53:54 <lambdabot>   [9.999999999999999e-2,0.1999999999999999,0.2999999999999998,0.3999999999999...
13:54:05 <rwbarton> tromp_: Not really, due to floating point rounding
13:54:14 <tromp_> this is way beyond rounding
13:54:24 <rwbarton> Yes, that's because you've given it stupid input
13:54:29 <tromp_> 1.09999 is significantly larger than 1
13:54:42 <rwbarton> It would be way way worse if [0.1, 0.2 .. 0.5] didn't always return a list of 5 elements.
13:54:55 <tromp_> no, that'd be fine
13:55:02 <tromp_> that'd be rounding
13:55:10 <rwbarton> what!?
13:55:25 <rwbarton> [0.1, 0.2 .. 0.5] -> [0.1, 0.2, 0.3, 0.4, 0.5]: useful
13:55:40 <rwbarton> [0.1, 0.3 .. 0.9999999999999999] -> anything: irrelevant
13:56:05 <tromp_> > [0.1,0.3 .. 1]]
13:56:06 <lambdabot>   <no location info>: parse error on input `]'
13:56:07 <tromp_> > [0.1,0.3 .. 1]
13:56:08 <lambdabot>   [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
13:56:18 <tromp_> that's awful
13:56:32 <rwbarton> I really don't understand that
13:56:38 <tromp_> it might as well produce an infinite list!
13:56:45 <tromp_> it just ignores my upperbound
13:56:46 <rwbarton> Sure, that can happen too :)
13:56:54 <tromp_> way beyond rounding
13:57:03 <rwbarton> [a,b..c] is supposed to be an arithmetic sequence containing a, b and c
13:57:31 <tromp_> it's also supposed to have no elements larger than c
13:57:44 <rwbarton> > [0.1, 0.3 .. 1] :: [Rational]
13:57:45 <lambdabot>   [1%10,3%10,1%2,7%10,9%10,11%10]
13:58:56 <tromp_> if you want [0.1,0.2..0.5] you better write  take 5 [0.1,0.2,..]
13:59:31 <rwbarton> This makes no sense though
13:59:41 <rwbarton> Why would you ever write [0.1,0.3..1.0] ?
13:59:56 <rwbarton> Wouldn't you write [0.1,0.3..0.9] if you wanted that?
14:00:05 <tromp_> to expose bugs ?!
14:00:56 <rwbarton> As far as I can tell, your proposed change makes the notation [a,b..c] strictly less useful
14:01:49 <jsn> rwbarton: are you saying the behaviour is not an error?
14:02:08 <rwbarton> Well, the behavior certainly isn't an error, since it's specified by the Report
14:02:17 <tromp_> is it really?
14:02:19 <jsn> oh, i get it
14:02:24 <jsn> it's supposed to contain c
14:02:25 <rwbarton> I assume you mean whether the Report is in error
14:02:40 <rwbarton> and that's obviously a subjective question
14:02:41 <jsn> it's not supposed to contain only numbers less than c
14:03:02 <tromp_> i agree it should include c
14:03:17 <jsn> > [0.1,.3..0.5]
14:03:18 <lambdabot>   <no location info>: parse error on input `..'
14:03:21 <tromp_> but no numbers larger than c by more than epsilon
14:03:38 <jsn> [0.1 , 0.3 .. 0.5]
14:03:42 <tromp_> that would be strictly more useful than current implementation
14:03:51 <rwbarton> > epsilon
14:03:52 <lambdabot>   Not in scope: `epsilon'
14:03:52 <jsn> > [0.1 , 0.3 .. 0.5]
14:03:53 <lambdabot>   [0.1,0.3,0.5]
14:04:00 <tromp_> epsilon is machine precision
14:04:20 <rwbarton> "machine precision" is a tricky thing
14:04:22 <jsn> tromp_: you're saying it should contain numbers that don't obey the interval, then?
14:04:29 <lucca> > [0.1 .. 9.1]
14:04:30 <lambdabot>   [0.1,1.1,2.1,3.1,4.1,5.1,6.1,7.1,8.1,9.1]
14:04:46 <lucca> floats are not something you should enumerate anyway
14:04:49 <geezusfreeek> > [0.0001 .. 9.0001]
14:04:51 <lambdabot>   [1.0e-4,1.0001,2.0000999999999998,3.0000999999999998,4.0001,5.0001,6.0001,7...
14:05:15 <rwbarton> I do have to admit, I have a hard time with this:
14:05:31 <rwbarton> > ([0.1, 0.3 .. 1.0] :: [Rational], [1, 3 .. 10] :: [Integer])
14:05:32 <lambdabot>   ([1%10,3%10,1%2,7%10,9%10,11%10],[1,3,5,7,9])
14:05:38 <tromp_> actually, [a,b..c] should not necessarily include c
14:05:57 <tromp_> > [0,2..5]
14:05:58 <lambdabot>   [0,2,4]
14:06:10 <lucca> > [0.0000000001 .. 2.0]
14:06:11 <lambdabot>   [1.0e-10,1.0000000001,2.0000000001]
14:06:19 <geezusfreeek> huh
14:06:22 <rwbarton> Frankly the whole [a,b..c] notation is kind of questionable to begin with
14:06:24 <lucca> heh, there it includes something After the endpoint
14:06:31 <lucca> so please, don't enumerate floats
14:06:52 <rwbarton> > [0.4 .. 2.0]
14:06:53 <lambdabot>   [0.4,1.4,2.4]
14:06:54 <vixey> rwbarton: Hm why?
14:07:25 <tromp_> i'm saying that for floats, [a,b..c] should equal takeWhile (<= c) iterate (+(b-a)) a
14:07:27 <rwbarton> vixey: Just because it's unclear what it should mean except when c actually is in the arithmetic sequence beginning a, b, ...
14:07:44 <vixey> oh ok, I see
14:07:50 <vixey> it is pretty /useful/ though
14:07:52 <rwbarton> vixey: If you want a specific meaning, you should just write it :)
14:07:54 <tromp_> i can't think of another sensible implementation
14:07:55 <vixey> It doesn't really matter if it makes sense
14:08:05 <tromp_> but apparently ghci did choose something else
14:08:08 <rwbarton> vixey: I agree, that's part of the problem.
14:08:16 <vixey> hmm
14:08:17 <rwbarton> Also it's too easy to write something that's "wrong"
14:08:27 <vixey> ok that's a good point yes
14:08:39 <roconnor> does bytestring work on yhc and jhc?
14:09:04 <rwbarton> > length $ takeWhile (<= 0.5) $ iterate (+(0.02-0.01)) 0.01
14:09:05 <lambdabot>   49
14:09:57 <tromp_> last [0.01,0.02 .. 0.5]
14:10:02 <tromp_> > last [0.01,0.02 .. 0.5]
14:10:10 <thorkilnaur_> http://www.haskell.org/pipermail/libraries/2008-October/010862.html
14:10:14 <lambdabot>   0.5000000000000002
14:10:15 <rwbarton> I'm sure you'll get more user complaints about length [0.01, 0.02 .. 0.5] == 49 than about length [0.1, 0.3 .. 1.0] == 6 :)
14:10:15 <lambdabot> Title: Repair to floating point enumerations?, http://tinyurl.com/6yj9qg
14:10:20 <quicksilver> roconnor: I believe there is or used to be a pure haskell impl of bytestring.
14:10:25 <quicksilver> roconnor: but it's very slow.
14:11:16 <roconnor> quicksilver: ok
14:11:23 <tromp_> i disagree, rwbarton
14:12:10 <thorkilnaur_> > [0, 0.3 .. 1.1]
14:12:12 <lambdabot>   [0.0,0.3,0.6,0.8999999999999999,1.2]
14:12:20 <byorgey> who actually uses float enumeration, anyway?
14:12:30 <vixey> who uses floats? o_O
14:12:38 <byorgey> it's like we always argue about it, but no one actually uses it in real code
14:12:41 <vixey> don't you have to read like 20 books to do it
14:12:48 <byorgey> basically
14:12:54 <vixey> (or be a fast/lose game programmer type)
14:12:54 <byorgey> > 0/0 == 0/0
14:12:56 <lambdabot>   False
14:13:12 <byorgey> fast/lose, that's a good way to put it =)
14:13:15 <tromp_> imagine rocket choosing thrust from a range [minthrust,minthrust+0.1 .. maxthrust]
14:13:23 <ddarius> quicksilver: Uh, I'm pretty sure almost all of the current one is Haskell.  Did you mean "safe" Haskell by "pure haskell"?
14:13:26 <byorgey> using floats is a great way to fast/lose
14:13:32 <vixey> hehe
14:13:33 <tromp_> and then suddenly exceeding maxthrust by a large margin
14:14:05 <tromp_> they'd blame your "useful" implementation
14:14:32 <rwbarton> If you're using float enumerations for anything important, you're insane anyways :)
14:14:41 <byorgey> if you write your rocket controller software in Haskell and then use float enumeration, you deserve to have it crash
14:14:44 <ddarius> And according to a comment in the source, the one C file is for Hugs only.
14:15:08 <rwbarton> (Mostly because if you're using floats in the first place you need to know what you're doing)
14:15:12 <thorkilnaur_> As with anything else, you simply have to know your limitatations and those of the tools that you use
14:15:18 <byorgey> right.
14:15:54 <rwbarton> On the other hand, if I just want to see a table of sin x for x = 0.01, 0.02, .., 0.5, I'm not going to be happy to figure out how much I have to tweak the boundary case by to make sure I get 0.5 listed.
14:16:43 <byorgey> on the other other hand, if you just want to see a table of sin x for x = 0.01, 0.02, .., 0.5, you probably don't care too much whether 0.5 is included or not.
14:17:11 <thorkilnaur_> rwbarton, Knowing the limitations of floating point arithmetic, you would generate such a table looping on an integer
14:17:28 <rwbarton> thorkilnaur_: Right, but for a trivial one-off task, I'd rather not have to care
14:17:39 <Peaker> all float enumerations can be converted to integer enumerations instead (emulating fixed points)
14:17:58 <arjanb> @hoogle [Either a b] -> ([a], [b])
14:17:58 <lambdabot> No results found
14:18:27 <byorgey> now, in my opinion, the really crappy thing about this is that the same semantics are used for Rational enumerations too, even though Rationals don't have accuracy problems.
14:18:44 <vixey> :t \x -> either ((first (x:)) .) ((second (x:)) .)
14:18:46 <lambdabot> forall a a1. a -> Either (a1 -> ([a], [a])) (a1 -> ([a], [a])) -> a1 -> ([a], [a])
14:18:57 <rwbarton> byorgey: yeah.
14:18:57 <vixey> :t foldre (\x -> either ((first (x:)) .) ((second (x:)) .))
14:18:58 <lambdabot> Not in scope: `foldre'
14:19:00 <vixey> :t foldr (\x -> either ((first (x:)) .) ((second (x:)) .))
14:19:01 <lambdabot>     Couldn't match expected type `Either
14:19:01 <lambdabot>                                     (a1 -> ([a], [a])) (a1 -> ([a], [a]))'
14:19:01 <lambdabot>            against inferred type `a1 -> ([a], [a])'
14:19:15 <rwbarton> byorgey: what about [1,4..11] :: [Integer]? what should that give?
14:19:22 <thorkilnaur_> rwbarton, I guess that it hard to avoid. But see droundy's suggestion in the mail thread quoted above
14:19:32 <idnar> > [1,4..11] :: [Integer]
14:19:33 <lambdabot>   [1,4,7,10]
14:19:42 <rwbarton> er, [1,4..12] I guess
14:19:49 <idnar> > [1,4..12] :: [Integer]
14:19:50 <lambdabot>   [1,4,7,10]
14:19:58 <rwbarton> > ([1,4..12], [1.0,4.0..12.0])
14:19:59 <lambdabot>   ([1,4,7,10],[1.0,4.0,7.0,10.0,13.0])
14:20:10 <rwbarton> > [1,4..12] :: [Rational]
14:20:11 <lambdabot>   [1%1,4%1,7%1,10%1,13%1]
14:20:17 <rwbarton> Should they all be the same?
14:20:36 <byorgey> It should be the same for Rational and Integer, I reallly don't care what it is for floats.
14:20:50 * thorkilnaur_ thinks "the same" is not particularly well defined in a case like this
14:21:16 <byorgey> It is for Integer and Rational.
14:21:30 <quicksilver> ddarius: ByteString relies on unsafePerformIO, inlinePerformIO, and RULES
14:21:33 <rwbarton> thorkilnaur_: I meant in this specific case
14:22:01 <quicksilver> ddarius: that's not haskell :)
14:22:12 <tromp_> so use take 5
14:22:14 <vixey> :t foldr ?f ([],[])
14:22:15 <lambdabot> forall a a1 a2. (?f::a -> ([a1], [a2]) -> ([a1], [a2])) => [a] -> ([a1], [a2])
14:22:27 <ddarius> quicksilver: I'll take that for a "yes."
14:23:13 <rwbarton> Personally I think I'd be happy enough without any [a,b..c] syntax at all.  I suppose I can just not use it.
14:23:17 <vixey> :t foldr (\a xs'ys -> either ?f ?g a) ([],[])
14:23:18 <lambdabot> forall a b a1 a2. (?g::b -> ([a1], [a2]), ?f::a -> ([a1], [a2])) => [Either a b] -> ([a1], [a2])
14:24:24 <vixey> :t foldr (either (\x -> first (x:)) (\x -> second (x:))) ([],[])
14:24:25 <lambdabot> forall a b. [Either a b] -> ([a], [b])
14:24:52 <quicksilver> ddarius: it's the RULES that are most important. ByteString's documented interface gives a 'contract' in terms of the complexity of various operations.
14:24:55 <thorkilnaur_> rwbarton, Ok, I see
14:25:03 <vixey> :t foldr (either (first . (:)) (second . (:))) ([],[])
14:25:04 <lambdabot> forall a b. [Either a b] -> ([a], [b])
14:25:09 <quicksilver> ddarius: AFAIK, those complexities are only acheived by RULES>
14:25:11 <vixey> that was way too hard :(
14:25:24 <vixey> @let partition = foldr (either (first . (:)) (second . (:))) ([],[])
14:25:26 <lambdabot>  Defined.
14:25:30 <rwbarton> vixey: I think this function is added in 6.10
14:25:41 <vixey> I hope so, I don't want to go through that again!
14:25:43 <Peaker> @djinn [Either a b] -> ([a], [b])
14:25:43 <lambdabot> Error: Undefined type []
14:25:54 <rwbarton> f _ = ([], [])
14:26:04 <vixey> ?djinn Either a b -> (Maybe a, Maybe b)
14:26:04 <lambdabot> f a =
14:26:05 <lambdabot>     case a of
14:26:05 <lambdabot>     Left b -> (Just b, Nothing)
14:26:05 <lambdabot>     Right c -> (Nothing, Just c)
14:26:05 <Peaker> rwbarton: how interesting ;)
14:26:18 <vixey> ?magic-recusion-understanding-thing [Either a b] -> ([a], [b])
14:26:19 <lambdabot> Unknown command, try @list
14:26:19 <rwbarton> Peaker: Sadly djinn can not solve all our problems :)
14:26:29 <rwbarton> vixey: write it :)
14:26:32 <vixey> haha
14:26:36 <vixey> I was going to actually once
14:26:36 <ddarius> @djinn end world hunger
14:26:37 <lambdabot> -- f cannot be realized.
14:26:56 <vixey> I also wanted a djinn with typeclasses
14:27:17 <vixey> but I think that I couldn't implement a complete djinn that did recursion
14:27:20 <rwbarton> Is the problem that djinn solves still computable in the presence of higher-rank types
14:27:23 <rwbarton> ?
14:27:41 <vixey> IIRC no it is not, there is a proof of this in lectures on curry howard isomorphism
14:46:13 <Peaker> Beelsebob: reactive fails to build: cabal: can't find source for FRP.Reactive.Internal.Reactive in src   -- have you/conal forgot to add a file, perhaps?
14:56:43 <chrisdone> netsplit?
14:57:17 <chrisdone> oh, was it was just me
14:58:19 <Ornedan> How do the duplicate channels created by dupChan work? Specifically, if I have ch0 that's dup'd to create channels ch1 and ch2, I write something to ch0. ch1 gets read. Does ch2 still have whathever got written to ch0?
14:58:47 <sjanssen> Ornedan: yes
14:59:05 <Ornedan> sjanssen: Ok, thanks
14:59:39 <sjanssen> writing to ch0 is the same as writing to ch1 is the same as writing to ch2
14:59:54 <paggas> why does ghc need the -package parameter? aren't the import statements enough>
14:59:55 <paggas> * ?
15:00:00 <sjanssen> they all share the "write" head, but each has a different "read" head
15:00:05 <sjanssen> paggas: just use ghc --make
15:01:00 <paggas> sjanssen: nice, thanks!
15:02:41 <Ornedan> Will the list from getChanContents ever end or will it just wait forever for more data to get written to the channel? I'm guessing the latter...
15:03:24 <sjanssen> latter
15:03:35 <sjanssen> getChanContents has very limited usefulness
15:07:14 <Ornedan> I assume readChan blocks. But what about isEmptyChan?
15:08:00 <Ornedan> (I'm trying to write an asynchronous tee)
15:15:12 <hasnew> Is there a library function for removing an element from a list by index?
15:15:25 <vixey> no
15:16:14 <hasnew> Thanks.  Have written my own but wanted to make sure I wasn't reinventing the wheel.
15:16:36 <ddarius> There's a reason that "wheel" isn't in the standard library.
15:25:52 <dons> ?users
15:25:52 <lambdabot> Maximum users seen in #haskell: 547, currently: 512 (93.6%), active: 14 (2.7%)
15:27:34 <Peaker> is it evil to hide conceptually immutable reading actions behind unsafePerformIO? (e.g read "immutable" data from some website)
15:27:56 <vixey> yes
15:28:06 <Peaker> (lambdabot does that :)
15:28:13 <SamB_XP> the website is sure to go down
15:29:35 <Riastradh> Peaker, you can make the bulk of your program independent of the actions by which the data are initially obtained, and then obtain the data at the beginning of your program in the `main' routine.
15:30:32 <Peaker> Riastradh: what if the website is conceptually a huge Data.Map?
15:30:40 <Peaker> SamB_XP: the hard disk could go down too
15:31:02 <Riastradh> What I described is independent of the nature of the data.
15:31:03 <vixey> Peaker: it's just an absolutely terrible idea.. :)
15:31:20 <Peaker> Riastradh: I can't download a terabyte Data.Map before executing the program ;)
15:31:42 <Peaker> vixey: I'm trying to figure out whether I can enjoy network transparency in Haskell like I do in Python
15:31:43 <Riastradh> Then when do you want it to happen?
15:31:46 <vixey> Peaker: you can write your program in the WebMap monad which you implement to abstract this
15:31:54 <Peaker> Riastradh: I want it to query the website for lookups
15:32:11 <Riastradh> I want to know when, Peaker.
15:32:21 <vixey> Peaker: this is exactly network transparency but you'll have to implement it
15:32:30 <Riastradh> Haskell wants to know when, too -- in fact, it needs you to tell it when, because it doesn't have an implicit concept of time.
15:32:48 <Peaker> Riastradh, vixey: Yeah, ok, put it in a monad, I get it :)
15:33:10 <vixey> Peaker: You could do this in a really nice general way and put it on hackage :p
15:33:24 <vixey> (or everyone else will program in Oz)
15:33:31 <Peaker> I find it a bit disturbing though that the hard disk is considered very essentially different to the network, they are just two mediums to access data, which may have different failure probabilities
15:33:53 <vixey> Peaker: What's the difference? looks the same to me
15:34:03 <SamB_XP> how about the RAM ?
15:34:31 <Peaker> vixey: Haskell values can sit in Virtual Memory, which is swapped to disk and read implicitly by "pure" computations
15:34:50 <vixey> I don't think "swapped to disk" is relevant
15:35:03 <vixey> this is some OS detail
15:35:09 <jsn> Peaker: when the disk fails, you don't expect to handle it, right?
15:35:14 <vixey> or compiler implementation detail or something
15:35:30 <jsn> Peaker: but to write a network application, you should handle the (far more frequent) network failures
15:35:39 <vixey> the pure computations aren't swapping to disk or reading from it
15:35:42 <Peaker> jsn: the website example could also not be expected to handle it
15:35:54 <jsn> Peaker: then put it behind unsafePerformIO
15:35:55 <Peaker> vixey: OK, then RAM reads are considered pure
15:35:59 <vixey> if that is happening it's the runtime or OS or whatever doing it
15:36:01 <jsn> Peaker: it will work
15:36:03 <vixey> RAM isn't relevant eiter
15:36:08 <Peaker> jsn: Yeah, I was wondering how evil that is considered :)
15:36:16 <vixey> when you write foo = 7 you aren't saying 10 PUT 7 IN RAM 20 GOTO 10
15:36:40 <SamB_XP> that's called fix (const 7)
15:36:45 <jsn> Peaker: well, when you put it it in unsafePerformIO, you are essentially blessing it with properties a network service can not possible have
15:36:56 <Peaker> vixey: heh, and when you are using lookup someBigMap someKey -- you don't mind if that ends up reading from disk, but you do mind if it reads from a website?
15:37:29 <Peaker> jsn: because it has a slightly lower MTBF than my OS/virtual memory? :)
15:37:30 <vixey> Peaker: If I have a huge map that I want stored in a file I will be explicit about that in code
15:37:36 <RayNbow> @pl \n -> n + n `rem` 2
15:37:36 <lambdabot> ap (+) (`rem` 2)
15:37:38 <Wenwen> Gran Hermano 24 Horas Directo Gratis http://www.granhermano10-gh10.blogspot.com/
15:37:39 <lambdabot> Title: GranHermano10
15:37:40 <SamB_XP> Peaker: if it will just _|_ if there's some sort of intermittant error, yeah ...
15:37:52 <jsn> Peaker: not slightly :)
15:38:09 <Peaker> vixey: why does it matter if it comes from a data file you read explicitly (and then put it in a monad), or if it comes from the executable (was placed as a symbol in the program)
15:38:12 <jsn> Peaker: and it's not clear, for example, that you can detect a failed read without timeout or something like that
15:38:33 <SamB_XP> the MTBF for an HTTP URI is, what, an hour ?
15:38:34 <vixey> Peaker: it will have a different type depending,
15:39:02 <Peaker> vixey: why? if you deserialize it it becomes the same type?
15:39:18 <vixey> Peaker: in any case, thinking about the binary format of compiled code and RAM being swapped onto disk is not really a good level of abstraction to be thinking about haskell programs with
15:40:53 <jsn> Peaker: i guess that you can imagine web failure is just the same as RAM failure is just the same as disk failure
15:41:04 <jsn> unsafePerformIO certainly allows that
15:41:04 <Peaker> vixey: if I am forced to move a pure computation into a monad because I moved its data from a program symbol to a website, then my abstractions leaked
15:41:18 <ddarius> If RAM "fails", you're fucked.
15:41:20 <jsn> Peaker: indeed
15:41:26 <SamB_XP> Peaker: it already leaked
15:41:39 <vixey> Peaker: No not at all, You can do pure programming in the monad using the language of interaction with that store
15:41:52 <jsn> ddarius: right, if they want to make the whole program operate that way for every storage medium, they are free to do so
15:42:44 <vixey> You will have problems handling every error, your error handlers will need error handles which need error handlers...
15:42:51 <jsn> hehe
15:42:52 <Peaker> vixey: what's the advantage of rewriting the code to use a monad, instead of unsafePerformIO?
15:43:09 <vixey> Peaker: You're serious?
15:43:15 <jsn> Peaker: your code will speak falsehood in the latter case
15:43:40 <vixey> Peaker: ... and you actually wrote this using unsafePerformIO in the first place? :o
15:43:41 <Peaker> jsn: only if the website ever fails ;)
15:43:52 <jsn> no
15:43:58 <Peaker> vixey: no, I initially used a big Data.Map declared in a Haskell file
15:44:03 <vixey> ok
15:44:04 <jsn> what if the client's computer loses connectivity?
15:44:12 <Peaker> vixey: then I decided to extract it into a website
15:44:36 <ddarius> Refactor>Extract To Website...
15:44:54 <jsn> ddarius: yeah, like we've got Volta for Haskell :)
15:44:58 <tristes_tigres> hi
15:45:09 * ddarius doesn't know what Volta is.
15:45:25 <Peaker> ddarius: :-)
15:45:27 <BMeph> jsn: Refactor>Extract To Haskell
15:46:27 <jsn> ddarius: http://ajaxian.com/archives/microsoft-labs-volta-net-web-toolkit
15:46:32 <lambdabot> Title: Ajaxian » Microsoft Labs Volta: .NET Web Toolkit
15:46:48 <Peaker> vixey: I feel there's an artificial line placed somewhere in an arbitrary place between "trusted" storage (Haskell symbols) and "untrusted storage" (the file API, network, etc), even though there is overlap between the reliability of the file API and the trusted storage, and its unclear where things become unreliable enough to warrent explicit sequencing
15:47:23 <Peaker> vixey: also, while I care about detecting errors, I don't necessarily care about the sequencing at all
15:47:24 <jsn> Peaker: where does the file API actually overlap with Haskell symbols?
15:47:28 <vixey> Peaker: well it's perfectly clear to me, just look at the types
15:47:40 <Peaker> jsn: reliability-wise they both depend on the disk
15:47:54 <tristes_tigres> So Microsoft backs haskell. I feel a major collision of paradigms: Microsoft -> evil, Haskell -> good
15:47:56 <vixey> Peaker: yeah, like idioms or something, you don't have to write everything in that do notation
15:48:20 <SamB_XP> suppose the Haskell executable was on a floppy and the file was on a hard disk ....
15:48:24 <Peaker> vixey: I don't think idioms are usable for this purpose
15:48:30 <vixey> ?wiki idioms
15:48:30 <lambdabot> http://www.haskell.org/haskellwiki/idioms
15:48:41 <vixey> Peaker: I'm not saying they are, I'm saying "or something" you might take inspiration from it
15:48:47 <tristes_tigres> @slap Microsoft
15:48:47 <lambdabot> Come on, let's all slap Microsoft
15:48:50 <jsn> Peaker: yeah, but they have completely dissimilar semantics
15:49:17 <Peaker> jsn: yeah, I am wondering why they were given such dissimilar semantics.. That's what's artificial
15:49:28 <jsn> Peaker: i can turn off swap, you know
15:49:38 <SamB_XP> jsn: prove it
15:49:41 <Peaker> jsn: your symbol is still demand-loaded from disk :)
15:49:48 <tristes_tigres> @slap gates
15:49:48 * lambdabot is overcome by a sudden desire to hurt gates
15:49:50 <Peaker> jsn: from the executable
15:49:50 <ddarius> tristes_tigres: SPJ is at Microsoft Research.  Erik Meijer was a Haskeller.  There are many other Haskellers at various places in Microsoft.
15:50:09 <tristes_tigres> ddarius: That's what I mean, yes
15:50:11 <jsn> SamB_XP: don't allocate space for it?
15:50:24 <ddarius> tristes_tigres: You might have to use more colors than black and white.
15:50:33 <SamB_XP> jsn: prove that you can turn off swap
15:50:43 <vixey> has everyone read Calculating Compilers by Erik Meijer?
15:50:46 <vixey> It's _awesome_
15:50:56 <jsn> SamB_XP: i don't understand what you are talking about
15:51:08 <jsn> SamB_XP: if i don't allocate any...
15:51:26 <SamB_XP> jsn: I'm questioning whether or not you have enough RAM to get away with it
15:51:41 <jsn> all my servers run that way, actually
15:51:43 <tristes_tigres> ddarius: it seems that MS kind of taints all it touches
15:51:48 <jsn> "fail fast" and all that
15:52:05 <ddarius> tristes_tigres: Microsoft touches almost everything in the computing world.
15:52:51 <jsn> Peaker: i guess the question is, do you want a program that is proven correct in the absence of I/O failure (a usable level of assurance) or one that is able to handle I/O failure but offers fewer guarantees?
15:52:56 <tristes_tigres> ddarius: have you seen the youtube clip when 1987 mac booted up and opend word file faster than 2GHz double -core Vista laptop ?
15:53:53 <ddarius> No.  It doesn't particularly have anything to do with anything though.  Anyway, I highly suspect that the 1987 Mac boots up and opens word files faster than a 2008 Mac.
15:53:59 <jsn> SamB_XP: i have answered your question to your satisfaction, i hope
15:54:07 <Peaker> jsn: Hey, now that I think of it, readContents (and unsafeInterleaveIO in general) do let you get "pure" access to files
15:54:58 <Peaker> jsn: I guess "network" is where most draw the line between "reliable enough to stick directly into the pure machinery" and "requires explicit sequencing"
15:55:12 <sclv> filesystem too
15:55:13 <Peaker> jsn: s/"network"/"non-disk" maybe
15:55:20 <jsn> Peaker: disk access is usually treated that way, as well
15:55:21 <Peaker> @type readContents
15:55:22 <lambdabot> Not in scope: `readContents'
15:55:28 <Peaker> @type getContents
15:55:29 <lambdabot> IO String
15:55:32 <SamB_XP> well, filesystem access
15:55:35 <jsn> Peaker: basically, if it is not compiled into the executable
15:55:43 <jsn> SamB_XP: sure, yeah
15:55:50 <jsn> filesystem access
15:55:54 <SamB_XP> swap or delay-reading of pages from the executable aren't counted
15:56:02 <Peaker> jsn, sclv, SamB_XP: getContents is in IO, but the resulting value reads from the file system as the lazy pure values are used
15:56:03 <jsn> yes, true
15:56:40 <sclv> right, sure. but its not pure, just lying.
15:57:44 <jsn> i think it comes down to what you want the compiler to be able to demonstrate for you
15:58:25 <sclv> it comes down to whether you're writing something that you want to be able to reason about fully, or something where you want to wave your hands at the parts you don't care about.
15:58:36 <sclv> but since its so simple to do it right, there's really no reason to do it the other way.
15:58:40 <Peaker> sclv: but its considered acceptable to lie in that case
15:59:03 <Peaker> sclv: there's no reason to use getContents?
15:59:22 <sclv> I never would.
15:59:37 <sclv> carefully used though, lazy bytestrings and etc are ok I suppose.
15:59:39 <Peaker> @hoogle FileHandle -> String
15:59:40 <lambdabot> Did you mean: Handle -> String /count=20
15:59:40 <lambdabot> Distribution.Text display :: Text a => a -> String
15:59:40 <lambdabot> Prelude show :: Show a => a -> String
15:59:53 <Peaker> @hoogle FileHandle -> IO String
15:59:54 <lambdabot> Did you mean: Handle -> IO String /count=20
15:59:54 <lambdabot> Distribution.Package packageName :: Package pkg => pkg -> String
15:59:54 <lambdabot> Text.XHtml.Frameset prettyHtml :: HTML html => html -> String
16:01:29 <sclv> but only if yr. careful to do things right.
16:01:40 <sclv> i.e. localize the change.
16:01:58 <sclv> erm, localize the scope of the unsafeInterleaveIO
16:02:00 <Peaker> sclv: how do you read the contents of a file without unsafeInterlaveIO?
16:02:07 <sclv> strictly.
16:02:15 <Peaker> no, I don't know the action names :)
16:02:32 <Peaker> @src getContents
16:02:33 <lambdabot> getContents = hGetContents stdin
16:02:34 <Provenzano> Hi.. I'm doind a basic University work about haskell academic use
16:02:48 <Peaker> @src hGetContents
16:02:49 <lambdabot> Source not found. My mind is going. I can feel it.
16:02:54 <Provenzano> where I can find informations about that-'
16:02:56 <sclv> @hackage strict
16:02:57 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/strict
16:03:20 <sclv> http://hackage.haskell.org/packages/archive/strict/0.3.2/doc/html/src/System-IO-Strict.html#readFile in particular
16:03:22 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/5d5blm
16:04:10 <sclv> and yes, it uses hGetContents... but really the defaults should be strict to begin with, and then the lazy versions built on top of them or alongside for efficiency at worst.
16:04:42 <Peaker> sclv: Where are the seek/read-chunk equivalents for reads that don't use unsafeInterleaveIO?
16:05:24 <Saizan> Peaker: System.IO
16:06:03 <sclv> seek isn't lazy
16:06:05 <Provenzano> !commands
16:06:36 <Peaker> sclv: yeah, if its lazy its hiding impurities behind pure code again
16:06:45 <sclv> but its not!
16:07:17 <Peaker> sclv: can you show example code then? I didn't follow
16:07:19 <sclv> geLine isn't lazy either!
16:07:39 <sclv> @hoogle hSeek
16:07:40 <lambdabot> System.IO hSeek :: Handle -> SeekMode -> Integer -> IO ()
16:07:45 <sclv> how is that lazy!?
16:08:03 <Peaker> sclv: ah, just miscommunication here
16:08:18 <Peaker> sclv: by "if its lazy" I meant -- yeah, that means its not lazy
16:08:56 <sclv> anyway, yes, only hGetContents, readfile and writeFile are lazy as far as I know
16:09:02 <Peaker> sclv: I was just trying to learn the action names for strict I/O as I haven't used them yet, that's all :)
16:09:16 <sclv> http://hackage.haskell.org/packages/archive/base/3.0.2.0/doc/html/System-IO.html
16:09:17 <lambdabot> Title: System.IO, http://tinyurl.com/5ds7ox
16:09:28 <sclv> and the strict package provides versions of the missing stuff
16:10:02 <Peaker> I think the IO monad is not the right place to stick all these impurities.. its specifying more than you ought to (about ordering you don't care about, for example)
16:10:08 <SamB_XP> writeFile is lazy ?
16:11:32 <Peaker> by sequencing everything in IO, you lose potential parallelism, and potential benefits of laziness machinery of pure computations
16:11:34 <sclv> oops
16:11:40 <sclv> of course writeFile isn't lazy.
16:12:13 <sclv> if you want parallelism, use parallelism...
16:12:43 <sclv> once you actually are using parallelism then it becomes a hundred times more important not to leave any hidden side effects lurking around.
16:12:50 <Peaker> Why is everything that depends on some unsafePerformIO becoming _|_ such a horrible thing?
16:13:22 <Peaker> IOW: Why is unsafePerformIO default error handling so bad?
16:13:24 <xenoterracide> is it possible to use haskell with apache and postgres?
16:13:35 <dons> xenoterracide: of course
16:13:44 <dons> xenoterracide: i.e. fastcgi + postgres backend?
16:13:48 <Peaker> sclv: yeah, if you're just using a thread-safe library to connect to some network site, that might not be a problem
16:13:56 <dons> xenoterracide: look on hackage.haskell.org for libraries
16:17:22 <jsn> Peaker: well, isn't there a _safe_ way to handle multi-threaded I/O?
16:18:10 <jsn> the pure parallelism machinery is based on the idea that things may be evaluated at any time, if i am not mistaken
16:18:26 <jsn> i don't think this is a reasonable assumption about most I/O
16:19:54 <Peaker> jsn: true. Maybe instead of unsafePerformIO on arbitrary actions, we can use some subset or combinator library that is safe parallelism-wise.  Then we remain only with _|_ error reporting - which sounds good to me - but maybe it has downsides?
16:20:18 <Peaker> I think maybe the main disadvantage is that you need to be in IO to catch exception _|_'s ?
16:20:25 <Peaker> (maybe that could be changed)
16:20:43 <SamB_XP> not really, no
16:21:03 <Peaker> SamB_XP: not the main disadvantage, or shouldn't be changed?
16:21:12 <SamB_XP> couldn't really be changed
16:21:13 <sclv> or we could just not use unsafePerformIO when we didn't need to.
16:21:18 <sclv> but that would be too easy.
16:21:19 * Provenzano is now away, auto away after 15mins idle (log\on pager\on)
16:21:32 <RayNbow> hmm... is there a problem with getLine in GHC 6.10?
16:21:46 <Peaker> SamB_XP: why not?
16:22:03 <SamB_XP> Peaker: it would screw up the semantics
16:22:04 <Peaker> sclv: but if you put stuff in IO instead, you also lose. Its not a great solution either
16:22:06 <sclv> what would be the semantics of "catch" out of IO?
16:22:18 <sclv> Peaker: you don't lose jack by putting IO in IO
16:22:46 <sclv> wtf could you possibly lose?
16:22:49 <Peaker> sclv: I lose laziness and potential for easy parallelism (in the case that it is safe)
16:22:56 <jsn> well, i think it's more like what you could gain
16:23:09 <sclv> you lose lazy IO! which is dangerous by definition.
16:23:18 <sclv> and you don't lose the potential for easy parallelism.
16:23:24 <jsn> if you can have explicit "lazyIO" operations that can be used that way
16:23:27 <Peaker> Maybe semantics could be something like: catch :: a -> [(ExceptionInfo -> a)] -> a
16:23:43 <Peaker> sclv: its dangerous, but it has upsides as well
16:23:50 <sclv> there are no upsides.
16:23:52 <jsn> all those lazy ops are scattered all over the place
16:23:54 <Peaker> sclv: wait, why is it dangerous, because it becomes a _|_ ?
16:23:58 <djsiegel1> Can I get a code review on this short program from someone; http://hpaste.org/11439 ? (I asked a few hours ago but I think my connection flaked out) I just want some style suggestions and other general tips. For example, am I abusing >>= ?
16:24:08 <sclv> it means you can't prove things about your program.
16:24:21 <sclv> and if you care about your program, being sound, then it is a bad idea.
16:24:30 <sclv> because when you leave an out for a thing to break, eventually, it will.
16:24:40 <Peaker> sclv: unless you're willing to prove different thing about "web server is responsive" case and "non-responsive" case
16:24:45 <dobblego> djsiegel1, when you do >>= return you can instead use liftM (or any of its variants)
16:24:48 <sclv> and you will say "oh, who could have seen this !?" and I will say "hah! I did!"
16:25:14 <jsn> djsiegel1: i think it looks fine
16:25:19 <sclv> right -- if you have two cases, then your execution path is determined by which case.
16:25:25 <jsn> djsiegel1: i personally dislike >>=
16:25:30 <Peaker> sclv: note that the IO being done here is conceptually immutable. Nobody is arguing for visible side effects
16:25:35 <sclv> at which point then you need to be able to reason about evaluation order.
16:25:38 <jsn> djsiegel1: i think using '<-' is clearer
16:25:39 <djsiegel1> jsn, yeah, I was wondering about that. I just hate introducing names.
16:25:48 <jsn> djsiegel1: fair enough
16:25:48 <djsiegel1> Yeah, <- is much clearer.
16:25:51 <sclv> immutable until the server goes down.
16:25:56 <Peaker> SamB_XP: why nto have "catch :: a -> [(ExceptionInfo -> a)] -> a" semantics for catching exceptions outside IO?
16:26:05 <jsn> djsiegel1: but is it really clearer to use an extractor, for example?
16:26:07 <sclv> and then what does your program do?
16:26:11 <xenoterracide> haskell is both compiled and interpretted? how odd...
16:26:19 <SamB_XP> Peaker: have you read any papers about exceptions ?
16:26:22 <SamB_XP> it might help
16:26:24 <dobblego> djsiegel1, I usually find <- significantly less clearer
16:26:37 <jsn> djsiegel1: i think just pattern matching the tuple is just as good as using 'snd'
16:26:38 <Peaker> sclv: when it goes down, every pure computation that depends on it will fail with the exception.  It doesn't sound horrible to me, but maybe it is. I'd understand why it is horrible with an example problem, maybe
16:26:55 <sclv> ideally pure code shouldn't throw exceptions, as much as possible.
16:26:55 <Peaker> SamB_XP: what papers do you recommend?
16:27:04 <djsiegel1> jsn, but to match the tuple, I need either <- or a lambda, right?
16:27:09 <sclv> some in the libs does, like head, etc.
16:27:13 <jsn> you need '<-'
16:27:17 <sclv> s/does/do/
16:27:19 <RayNbow> hmm, has interactive IO stuff changed in GHC 6.10?
16:27:20 <jsn> that's what i'm saying
16:27:26 <SamB_XP> @google semantics for imprecise exceptions
16:27:38 <lambdabot> http://citeseer.ist.psu.edu/peytonjones99semantics.html
16:27:39 <sclv> but in general the tendency is to want complete rather than partial programs, yes.
16:27:46 <RayNbow> not everything is being flushed to stdout immediately
16:28:05 <sclv> have you set hsetbuffering?
16:28:11 <Peaker> sclv: why do exceptions in pure computations make reasoning about code hard?  Bottoms are considered when reasoning about code in general, no?
16:28:30 <SamB_XP> Peaker: it's the catching them that causes problems
16:28:51 <RayNbow> sclv: no... is that required since 6.10?
16:28:55 <sclv> right but bottom isn't the same as an exception
16:29:04 <Peaker> SamB_XP: Can you please explain why the above catch wouldn't work?  I'll RTFM, but if that is explainable separately that would be nice :)
16:29:07 <SamB_XP> sclv: it isn't ?
16:29:10 <sclv> RayNbow: its been important all along. some default in your distro may have changed something.
16:29:25 <sclv> SamB_XP: well, how do you catch non-termination?
16:29:33 <SamB_XP> Peaker: I don't quite remember what the reason was
16:29:42 <SamB_XP> sclv: okay, okay, it's not quite identical
16:30:05 <Peaker> sclv: non-termination indeed makes things hard, but hiding IO behind pure computations does not have that problem (especially with the introduction of timeouts)
16:30:23 <SamB_XP> btw that paper considers notermination to raise ALL exceptions
16:31:09 <ivanm> so if O'Reilly uses animals on its covers (like the beetle for RWH), what kind of "real" animal is this meant to be? http://blogs.msdn.com/chrsmith/archive/2008/10/19/due-out-next-year-programming-f-by-chris-smith.aspx
16:31:11 <SamB_XP> iirc
16:31:11 <lambdabot> Title: Chris Smith's completely unique view : Due out Next Year – Programming F# by C ..., http://tinyurl.com/66zwzt
16:31:41 <Saizan> when the execution of side-effects starts to depend on the forcing of values then you get a lot of problems out of laziness
16:32:00 <sclv> ivanm: a hoax
16:32:11 <ivanm> sclv: is it?
16:32:15 <LarstiQ> ivanm: a Squig
16:32:18 <sclv> read the text below
16:32:49 <RayNbow> sclv: where should I put hSetBuffering?
16:32:54 <ivanm> sclv: oh, missed that bit discussing the animal
16:32:58 <ivanm> just saw the cover itself :p
16:33:12 <sclv> hSetBuffering NoBuffering stdin (or stdout)
16:33:24 <sclv> just put it as the first line in your main = do block.
16:33:46 <RayNbow> ah thanks
16:33:50 <RayNbow> it works now :)
16:34:02 <RayNbow> I didn't have this problem in GHC 6.8.2 (WinXP)
16:35:08 <jsn> Peaker: well, that has semantic problems
16:35:53 <RayNbow> sclv++
16:35:57 <RayNbow> @karma sclv
16:35:57 <lambdabot> sclv has a karma of 1
16:36:08 <sclv> heh.
16:37:07 <jsn> Peaker: basically, you're allowing a "pure" call to have different values at different times
16:37:29 <jsn> Peaker: you may be okay with it if it is called on demand, once
16:37:39 <jsn> Peaker: for a web dictionary, that actually makes sense
16:38:03 <jsn> Peaker: but for a web datastore where you change values, it doesn't make much sense at all
16:38:33 <jsn> Peaker: do we really want to saddle upstream with a bunch of "pure" code that can't be memo-ized, for example?
16:41:16 <sclv> Peaker: ok so here's an example on the exception thing, I think... if you have "pure" exception-throwing code wrapped in "pure" catch calls, say three levels deep, and somewhere an exception gets thrown, then to figure out the catch calls you need not only the call stack but the graph of values (since we can consider the pure catch to be a container) which at any point can be very distinct -- which, in turn, means that we lose essentially a
16:41:40 <Zao> sclv: Truncated at "essentially a"
16:41:52 <sclv>  lose essentially all possibility of a sane efficient language.
16:46:36 <Botje> how do you keep track of lexical scope in an interpreter?
16:46:47 <Botje> record the actual lexical scope for every known function, i guess
16:46:49 <Botje> mumble :)
16:48:28 <vixey> Botje: what do you mean
16:48:52 <Botje> I just realized my naive interpreter is dynamically scoped
16:48:58 <Botje> i want to make it lexically scoped
16:49:09 <Botje> but for that i have to remember the environment each lambda is defined in, right?
16:49:17 <vixey> no
16:49:27 <vixey> You can use the metalanguage (haskell) lambda to define scope of your object langauge
16:49:50 <RayNbow> oh great... Hugs doesn't know Data.IntSet.findMax... :p
16:50:11 * RayNbow will just force the receiver to use GHC then :p
16:50:24 <vixey> or you can put values into a list and always lookup from the start
16:52:25 <Botje> hmm
16:52:29 <Botje> i'm currently using a Map
16:52:49 <vixey> then you must remove things from it (or replace them)
16:53:38 <Botje> not too late for a major rearchitecture :)
16:53:55 <vixey> dynamic scope isn't that bad :p
16:54:01 <vixey> there is always time for major rearchitecture!
16:54:08 <vixey> (tommorow)
16:54:09 <Botje> it is if the final goal is compiling down to C :)
16:54:47 <Botje> hmm
16:54:55 <Botje> how would dynamic scoping interact with a type system anyway
16:55:27 <vixey> I think it would cause huge problem - you wouldn't even know if the value was bound until runtime would you?
16:55:32 <BMeph> Botje: Huh? "final goal" and "compiling down to C" in the same sentence? Tsk, tsk... ;)
16:55:56 <Botje> BMeph: it's only a thesis, not a PhD! :p
16:56:06 <vixey> what is the thesis?
16:56:17 <vixey> "It is possible to write a compiler in haskell"? :p
16:56:20 <Botje> :p
16:56:26 <Botje> not quite
16:56:44 <Botje> We have this interpreter written in C
16:57:13 <Botje> it uses C functions to emulate basic blocks
16:57:28 <bd_> Botje: GHC has a dynamic scoping system, you know
16:57:30 <Botje> it has a continuation stack to put those blocks in
16:57:32 <bd_> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html 8.7.2
16:57:34 <lambdabot> Title: 8.7.�Other type system extensions, http://tinyurl.com/3c7ura
16:57:43 <Botje> bd_: i shouldn't have asked :)
16:57:49 <bd_> :)
16:58:03 <Botje> but the problem is: it's quite a PITA to code for this continuation-based language
16:58:17 <Botje> so my thesis is using CPS to convert pretty recursive code down to this ugly continuation thing
16:58:26 <vixey> oh right
16:58:39 <vixey> I actually tried something like this before
16:58:52 <vixey> it is very difficult to do CPS conversion in syntax-rules.
16:59:20 <Botje> i hadn't even considered that
16:59:26 <Botje> it sounds pretty insane :P
17:00:37 <vixey> I wonder if you'd get anything out of using continuation-c instead of normal c
17:01:00 <Botje> zero stack use, for one
17:01:11 <vixey> (I mean continuation-c the programming language)
17:01:18 <Botje> that exists?
17:01:20 <Botje> sigh :(
17:01:26 * Botje looks it up
17:01:57 <vixey> I think it's basically C with CWCC added? not sure
17:02:40 <Botje> i know about C with closures
17:36:06 <gnut> hi
17:36:10 <adekoba> hi
17:36:22 <gnut> how do you marshal C structs?
17:36:35 <gnut> I've looked all over the net, but I can't figure it out from what I found
17:36:48 <ddarius> The easiest way is to use a tool to do it for you like c2hs
17:36:57 <gnut> is it very tedious?
17:38:25 <Apocalisp> I have a tool called Gary to marshall my structs. He's pretty cheap too.
17:39:18 <gnut> heh
17:40:42 <gnut> I'm trying to write a haskell interface to a function that returns a C struct, floatcomplex which has two members, r and i... but my attempts at making Data.Complex storable, and putting that as the return type makes ghc complain
17:40:47 <ddarius> gnut: The Haskell FFI does not directly support marshalling structs.
17:41:05 <dons> gnut: use the storable-complex library?
17:41:09 <gnut> ddarius: hmm.. okay. so how do people who write haskell interfaces to C libraries that return structs do it?
17:41:16 <dons> return a Ptr
17:41:22 <dons> and use Storable to peek/poke
17:41:34 <dons> gnut: but look first at the storable-complex implementation
17:41:37 <dons> on hackage.haskell.org
17:41:39 <gnut> dons: I saw it... and it was similar. but maybe I'm not doing it right?
17:42:11 <gnut> I don't have the C source... it's a library that I want to access from Haskell.
17:42:30 <ddarius> gnut: Using the raw FFI you have to calculate the field offsets yourself and do ugly casting.  This is why people use tools.
17:42:57 <gwern> @seen Cale
17:42:57 <lambdabot> Cale is in #haskell, #haskell-overflow and #ghc. I last heard Cale speak 8h 15m 4s ago.
17:42:59 <gnut> storable-complex has instantiates Complex a to be storable... so I typed that into "type SComplex = Complex Float"... then IO SComplex as a return type fails
17:43:01 <gwern> nooo
17:43:31 <gnut> ddarius: I know the struct is just two floats back to back...
17:43:35 <gwern> dammit
17:43:58 <gwern> I guess I'll just have to dam the bullets and bite the torpedo by releasing lambdabot myself tonight
17:44:25 <gnut> ddarius: I am not against using tools either :) I just want to know how this thing works for my mental picture of the FFI
17:44:26 <Botje> yay
17:44:33 * Botje has used laziness to great effect
17:44:40 <Botje> well
17:44:42 <Botje> scratch that
17:44:48 <Botje> it's the first time i had to tie the know
17:44:50 <Botje> *knot
17:45:08 <Cale> gwern: hey. I pushed a couple additional patches.
17:45:08 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
17:45:10 <gwern> zomg, who is this Andrea Vezzosi who pushed a bunch of lb patches and has knocked my plans so deviantly askew?
17:45:18 <gwern> Cale!
17:45:33 * Botje hands gwern a pointy lambda
17:45:41 <Cale> Yeah, there were a couple from Saizan
17:45:50 * gwern senses Botje is making a joke I do not understand
17:45:51 <gnut> for a foreign import to return a type of IO blah... is there a class that blah must instantiate?
17:46:24 <Cale> gnut: Storable perhaps? I forget what the spec says.
17:46:36 <gnut> Cale: hmm... did that.
17:46:40 <Cale> It's either Storable, or it must be a native C type.
17:46:54 <Cale> (as defined in the FFI report)
17:47:05 <gwern> Cale: is #haskell lambdabot  up to date?
17:47:14 <gnut> Cale: where does it say that in the FFI report?
17:47:20 <gnut> which section
17:47:37 <Cale> gwern: apart from that patch I just pulled from you, I think so
17:47:54 <Cale> gnut: one sec, I'll find it...
17:48:01 <gwern> > 1 + "I FEEL IT. I FEEL THE COSMOS!" ++ " Scorpio has returned to the night sky"
17:48:02 <lambdabot>       No instance for (Num [Char])
17:48:02 <lambdabot>        arising from the literal `1' at <in...
17:49:04 <Cale> http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise3.html#x6-120003.2
17:49:07 <lambdabot> Title: 3 Foreign Declarations, http://tinyurl.com/yezf7t
17:49:11 * gwern doesn't notice any difference. eh. I suppose I was expecting it to defecate rainbow colored error  messages or something
17:49:23 <gwern> Cale: incidentally, any state changes?
17:49:32 <Cale> gwern: oh
17:49:33 <gwern> has in all this time no one really added any quotes or sites?
17:49:47 <Cale> All the state has been piling into the local installation.
17:50:09 <Cale> Since lambdabot no longer runs out of its build directory.
17:50:21 <Cale> I suppose I could just copy files in and record.
17:50:32 <gwern> well, if you want the state to pile up in the darcs directory, you've got to run it there
17:50:37 <gwern> that was part of the design
17:50:56 <gwern> (at least, that's how it's sposed to work, I should probably see whether it does)
17:51:19 <Cale> I agree this way is nicer, though it would be nice if it actually *worked* when the State directory was initially empty.
17:51:22 <gwern> hm, looks like it does modify state files if run in darcs dir, goody
17:51:39 <Cale> There are things like the Seen database which if lost, lambdabot can't run properly.
17:51:55 <gwern> Cale: hm? doesn't it fall back on the system databsae if there isn't a local copy?
17:52:15 <gwern> it's supposed to go 'look in ./; fall back to ~/.lambdabot; fall back to cabal copy'
17:52:21 <Cale> I'm pretty sure if creates a 0 length file and then chokes on it.
17:52:28 <Cale> it*
17:53:15 <gwern> ah. hm. I didn't think about that. I always assumed the file would have stuff in it since if it didn't exist, lb would copy over the full file from wherever
17:54:03 <gwern> Cale: how important is that bug?
17:54:27 <Cale> not that important for us, but it's probably annoying for others who want to use lambdabot
17:55:02 <gwern> can we say 'go choke on a popsicle and use lb the right way?' or is that not feasible...
17:55:12 <Cale> It would be nice if a lot of these things had empty defaults.
17:55:29 <Cale> At least, I think so.
17:55:38 <Cale> But it's not something we have to care about that much.
17:55:42 <gwern> hm. how would that be implemented?
17:55:47 <Cale> We'll wait for people to complain about it :)
17:56:11 <gwern> indeed
17:56:18 * gwern will go do the upload now
17:56:39 <gnut> Cale: thanks for the link. I have that also printed out in front of me. so it's telling me that I can only return (assuming it has side effects) IO a where a is a marshallable foreign basic type.... so using complex (defined as storable in storable-complex) is not marshallable...
17:56:43 <Cale> I have lots of changes to mueval as well, but they mostly consist of removing half the code ;)
17:56:53 * gwern wishes dcoutts_ would make cabal upload grab a tarball from dist/ by default, already
17:57:04 <gwern> Cale: well, I removed haskell-src-exts stuff from darcs mueval
17:57:16 <Cale> gnut: right... so you'll have to do extra marshalling yourself it seems
17:57:21 <dons> anyone heard from dcoutts recently?
17:57:30 <gwern> now, the question is are there any supporting libs to upload?
17:57:31 <Cale> gwern: yeah, that's what I started with, I think.
17:57:50 <lispy> dons: I just had a random idea about announcing the tech talks.  Have you thought about providing an ical feed?  Google calendars would work for example
17:58:03 <dons> mm. can you get that from upcoming?
17:58:33 <gwern> ah, lambdabot-utils needs an update
17:58:37 <dons> http://upcoming.yahoo.com/event/1274796/
17:58:38 <lambdabot> Title: Galois Tech Talk: Factor: an extensible interactive language at Galois (Thursday ...
17:58:50 <dons> lispy: there's probably tools to sync upcoming with ical
17:59:01 <dons> perhaps the 'add to calendar' link?
18:00:25 <gwern> ok, should be good
18:00:34 <lispy> dons: I can add just that event that you announced.  Maybe there is a more general solution
18:00:43 <dons> mm
18:02:29 <lispy> dons: i can subscribe to Galois as a venue
18:02:37 <lispy> dons: but it doesn't seem to have tht event, odd
18:02:51 <dons> mm
18:03:00 <dons> in 'upcoming events' ?
18:03:20 <gwern> anyone want to 'cabal install lambdabot'?
18:03:46 <dons> lispy: you tried the 'add to ical calendar'  link?
18:03:55 <dons> for upcoming events for the Galois location?
18:03:59 <lispy> dons: I went to this page and added it to my calendar: http://upcoming.yahoo.com/venue/214722/
18:04:01 <lambdabot> Title: Venue: Galois - Upcoming
18:04:07 <dons> yeah
18:04:17 <dons> e.g. its in the RSS feed, http://upcoming.yahoo.com/syndicate/v2/venue/214722
18:04:30 <lispy> hmm
18:04:47 <lispy> dons: weird that subscribbing to that didn't add anything to my calendar though
18:04:54 <lispy> needs tweaking
18:04:59 <dons> mm
18:05:03 <dons> but not my fault, i think
18:05:42 <gwern> hm, I have a chore to go do. When I get back I expect to see some build reports!
18:07:29 <lispy> dons: when I added just the event it worked...but yeah probably not your fault
18:10:24 <Samy> "After my year-long search, which included brief flings with cool (but impractical) research languages like Haskell, and the ever-promising-but-not-there-yet OCaml, I've settled on Lisp."
18:10:33 <Samy> http://steve.yegge.googlepages.com/lisp-wins
18:10:34 <lambdabot> Title: Stevey's Home Page - Lisp Wins (I think)
18:12:02 <gwern> well, that's from 2004
18:12:16 <gwern> and besides, yegge's now obsessed with javascript, last i heard
18:12:31 <jsn> Samy: I think LISP really will avoid success at all costs
18:12:49 <Samy> gwern, haha
18:13:00 <jsn> gwern: if he actually liked Haskell, I would be concerned :)
18:13:06 <Samy> jsn, I chose Haskell over LISP for many good reasons :-P
18:13:19 <gwern> Samy: none of what I said was intended to be humorous
18:13:32 <gwern> jsn: I dunno, he'd be a useful propagandist at least
18:13:43 <Samy> He likes Ruby too, most programming language "experts" that I know think Ruby is inconsistent/hacky.
18:13:50 <gwern> his first blog post would immediately overwhelm dons' wordcount of the past several years
18:14:03 <jsn> Samy: well, i'm not sure what they would base that on
18:14:21 <gwern> and we'd probably get a bang-up emacs haskell-mode within a month or two
18:14:21 <jsn> Samy: Ruby is more consistent and flexible than Python, for example
18:14:48 <jsn> gwern: maybe we'd even get to be on Google App Engine...
18:14:49 <gwern> (stefan tries, but emacs haskell-mode still isn't all that great, imo. yegge tho does great emacs modes AFAIK)
18:15:12 <jsn> Samy: i really appreciate Ruby's mixins
18:15:24 <Samy> jsn, I don't know enough about Ruby to have a worthwhile opinion of it
18:15:28 <jsn> people complain about it's blocks -- they sorta-kinda introduce lambdas
18:15:30 <gwern> jsn: unlikely - isn't app engine python only? python isn't promoted by yegge, so he has no effect on that one way or other
18:15:37 <jsn> and its procs are another way
18:15:44 <jsn> gwern: java is on it, now
18:15:57 <gwern> it is? I hadn't heard that. nm then
18:16:00 <jsn> gwern: the big question is who gets to be next
18:16:13 <jsn> gwern: python is obviously first
18:16:30 <jsn> gwern: then java
18:16:50 <jsn> gwern: but now it's down to erlang vs. ruby vs. haskell vs. o'caml
18:16:56 <gwern> (I get the vibe from general CS reading that ruby is something of a weakened smalltalk with more mainstream synatax; if it can succeed, then I suppose it should get some credit for being an even purer OO lang than c++ or java)
18:17:10 <Samy> jsn, Ruby if any, from those :-P
18:17:13 <gwern> jsn: wait, seriously? they're actually considering haskell?
18:17:20 <jsn> Samy: Ruby's FP features are half-hearted -- but its object oriented features are really nice
18:17:22 <gwern> and erlang or o'caml?
18:17:32 <jsn> gwern: i just mean, it's down to the little guys, now
18:17:39 <gwern> man, I would've said php and perl and ruby would've been the next contenders
18:17:44 <Samy> How about C#? PHP? Perl?
18:17:45 <Samy> nod
18:17:54 <jsn> oh yeah
18:18:02 <gwern> well, C# is probably out since it's MS .NET stuff
18:18:03 <jsn> i had wiped those languages from my memory
18:18:08 <gwern> :)
18:18:14 <jsn> Mono isn't good enough yet
18:18:21 <Samy> Good enough for what, jsn?
18:18:40 <jsn> hosing C# on Google's Linux infrastructure
18:18:46 <jsn> s/hosing/hosting/
18:18:52 <gwern> not to mention the legal minefield
18:19:10 <jsn> if they adopted it, though, that'd basically end-of-life Strata before it shipped!
18:19:12 <Samy> Mono provides a complete C# implementation, it lacks some .NET API things AFAIK (.forms, etc...)
18:19:18 <Samy> Then you also have things like ASP.
18:19:20 <jsn> Samy: right
18:19:48 <jsn> Samy: maybe it's actually complete enough for web apps, i haven't looked at it lately
18:20:15 <gwern> well, mono is complete enough for some GNOME apps to use it iirc
18:20:22 <Samy> Pretty popular ones too.
18:20:33 <Samy> "Popular" as in "installed a lot", but I don't know anyone who uses them :-)
18:20:35 <gwern> and I've run into a few wikipedia-related programs which try to support linux through mono
18:20:38 <Samy> An example would be "tomboy"
18:20:41 <jsn> what i mean is, complete enough to _port_ an app written for M$.Net
18:20:56 <Samy> jsn, there are several companies which have already done this.
18:20:57 <jsn> not to write a new program from whole-cloth
18:21:01 <gwern> actually, I keep meaning to try out tomboy...
18:21:04 <Samy> I remember some big company with ASP.
18:21:14 <jsn> Samy: well, then i am wrong
18:21:23 <jsn> maybe it's complete enough already
18:21:35 <jsn> and that's good, because then it should be the next thing they do
18:21:52 <Samy> Hrm
18:21:57 <jsn> gwern: i don't know what legal minefield you mention -- isn't Mono free and clear?
18:22:00 <Samy> On their homepage they list "winforms" as supported.
18:22:08 <Samy> jsn, http://www.mono-project.com/Companies_Using_Mono
18:22:13 <lambdabot> Title: Companies Using Mono - Mono
18:22:20 <Samy> Mono is free.
18:22:29 <gwern> jsn: sure, if you don't mind simply assuming entire areas of IP can't harm you. software patents, for starters
18:22:51 <jsn> gwern: well, Google is able to fight that battle if anyone can
18:23:02 <jsn> gwern: and they have the most to win from it
18:23:03 <gwern> (ah, software patents. best friend of abusive corporations everywhere)
18:23:11 <Samy> Interesting, "Wikipedia (http://wikipedia.org): WikiPedia uses Mono for its search facilities. The indexing and the actual searching is done by Mono-based applications"
18:23:22 <jsn> interesting
18:23:41 <gwern> jsn: they have the most to lose in another sense; patent infringement judgements can be enormous
18:24:12 <jsn> yeah, but those are dependent on revenue in the infringing product
18:24:16 <gwern> and that's before maybe throwing in possible multipliers (does every web access of every .net app running on google's servers count as a new infringement)?
18:24:23 <Samy> Shrug
18:24:25 <Samy> Novell is backing it.
18:24:29 <jsn> right
18:24:37 <gwern> remember that patent judgements can and have gone into the multi-hundred million dollar range
18:24:37 <Samy> I think they could afford some lawsuits from Microsoft, if any, and win. :-)
18:24:48 <jsn> the thing is, patent infringements would cover algorithms, whether they are in Mono or not
18:25:12 * gwern tries to remember that codec company which extracted something like half a billion from MS - burst inc.?
18:25:33 <gwern> they also nailed apple in the megamillions range, iirc
18:25:36 <jsn> Mono might motivate M$FT to start swinging, but...they have plenty of code that infringes Google patents, I'm sure
18:25:41 * lispy wonders how this relates to Haskell programming
18:25:42 <Samy> gwern, wow
18:25:55 <jsn> gwern: the people who nailed apple were creative, for a UI patent
18:26:02 <Samy> jsn, I think if anything, Mono is beneficial to MS.
18:26:05 <jsn> gwern: at least, they were one of the peopl
18:26:24 * jsn things lispy is right
18:26:51 * jsn s/things/thinks/
18:26:55 <Samy> gwern should join #haskell-blah :-P
18:27:06 <gwern> nevar
18:27:15 * jsn thinks Samy is right
18:27:34 <lispy> gwern: I need to apply your patches and fix that repo for autoproc
18:27:40 <Samy> One more off-topic thing, sorry.
18:27:41 <lispy> why don't I do that now
18:28:07 <gwern> lispy: why not indeed?
18:28:13 <Samy> gwern, "In September 2007 an agreement between Microsoft and Novell opened the doors to collaboration specifically on the implementation of open source implementations of Silverlight 1.0 and Silverlight 2.0." - "Microsoft proved with the CLI and the C# language that it was possible to create a powerful foundation for many languages to inter-operate. We will always have that."
18:28:16 <gwern> one cannot even pull from code.haskell.org/autoproc
18:28:39 <Samy> Anyways, I should go work on a haskell project now that I have some free hours :)
18:28:41 <lispy> gwern: yay, they apply
18:28:50 <lispy> gwern: so am I up to date with your repo?
18:28:55 <lispy> gwern: if so, I'll darcs2 ify it
18:29:00 <gwern> Samy: in exchange, I query whether that agreement only protects novell users and I give you this link http://buttersafe.com/2008/10/23/the-detour/ with a commendation to the punchline
18:29:05 <gwern> lispy: fine
18:29:05 <lambdabot> Title: 2c Buttersafe - Updated Tuesdays and Thursdays 18 » Comic Archive 49 » The Det ...
18:29:30 <gnut> so the C library function returns a struct... would I say in haskell that it returns IO Complex or IO (Ptr Complex) assuming Complex is already made Storable.
18:30:06 <gnut> when I do IO (Ptr Complex), it thinks it's okay. Complex is storable so Ptr is happy. when I do IO Complex, it's not happy.
18:30:38 <gwern> maybe there's some way to un-Ptr something? and you need to do that first
18:30:54 <Samy> gwern, funny but irrelevant :p
18:31:53 <lispy> gwern: try now
18:31:55 <gnut> gwern: maybe... but if the C function returns the struct, not the pointer, how do I tell haskell to take a non-ptr
18:32:05 <lispy> gwern: if it works, I'll make an announcement on Haskell-Cafe
18:33:04 <lispy> gwern: you'll want to 'get' a fresh copy though, as your local branches are now obsoleted by the conversion to darcs2 format
18:33:49 <gwern> lispy: of course, the real irony here is that I nuked my procmail/getmail4 setup yesterday and have gone back to straight gmail
18:33:58 <lispy> bwhuhahah!
18:34:06 * gwern darcs gets with lightning darcs-2 speed!
18:34:14 <lispy> gwern: that's the beauty of autoproc.  By the time you convert your procmalrc you switch to gmail :)
18:34:29 <lispy> gwern: should we test push?
18:34:56 <gwern> I has nothing to push :(
18:35:05 <lispy> k, I'll just announce then
18:35:18 <gwern> great
18:35:22 <gwern> I need to send a lb ann too
18:35:45 <lispy> is autoproc on hackage?
18:36:12 * gwern squints into the sky. 'It's a good day to release', 'e mumurs philosophically, and eases the email out of the scabbard
18:36:15 <sjanssen> gwern, lispy: you guys switching the lambdabot repo to darcs 2?
18:36:30 <gwern> lispy: yup, 0.1 iirc
18:36:31 <lispy> sjanssen: no, we switched the autoproc repo to dars2
18:36:52 <lispy> gwern: good stuff, I'll put in a link and let you make the judgement call on uploading a new copy to hackage
18:36:53 * sjanssen doesn't even know what atuoproc is :)
18:36:54 <gwern> sjanssen: should we switch lb? I didn't think we were running into any merge bugs making it worth the effort
18:37:05 <sjanssen> I just saw "lb" and "darcs 2" and was wondering whether I should care
18:37:11 <sjanssen> gwern: yeah, I agree
18:37:15 <gwern> on the other hand,  I would like global cache for a large repo like lb
18:37:20 <gwern> so I'm neutral on the topic
18:37:33 <gwern> lispy: ok, I'll upload darcs autoproc
18:37:50 <gwern> hm, I wonder if an upload is even necessary?
18:37:52 <sjanssen> too much of a hassle to contact all the people that use the repo (and remember that all of our users use darcs, since the packaged versions have always been broken)
18:39:06 <gwern> well, hoepfully the current one is packaged as non-broken
18:39:21 <sjanssen> ah, new package
18:39:57 <gwern> yup
18:40:07 <gwern> uploaded 4.2.2 tonight
18:40:20 <gwern> lispy: push to autoproc seems to work
18:40:44 <sjanssen> gwern: whats this Ignore-this business in your commits?
18:40:53 * gwern has no idea
18:41:00 <gwern> darcs just seems to be doing that
18:41:06 <lispy> sjanssen: it's a new darcs (mis)feature
18:41:18 <gwern> lispy: do explain further
18:41:31 <sjanssen> lispy: what does it do? (and how does one turn it off, I don't want such messages in the projects I maintain)
18:41:40 <lispy> the history of the issue is at http://bugs.darcs.net/issue27
18:41:42 <lambdabot> Title: Issue 27: patch ids are not collision-free - Darcs bug tracker
18:42:46 <lispy> sjanssen: you update that bug or send a message to darcs-users@ politely explaining why you don't like it and we use you as a real user to help aruge that issue27 was not resolve correctly
18:43:04 <gwern> lispy: autoproc-1.1 is on hackage with updated ghc-options and darcs repo location
18:43:07 <sjanssen> lispy: will anyone agree with me?
18:43:23 <sjanssen> seems like a half-assed half-solution, all due respect
18:43:26 <lispy> sjanssen: I have tried to express my discontent with this feature a few times, I could repeat myself
18:44:10 <gwern> also, for random junk, there's a lot of it
18:44:10 <sjanssen> it's exposing internal implementation as part of the user interface
18:44:19 <gwern> how many characters do you need?
18:44:42 <lispy> gwern: ah, you could update the maintainer email
18:45:52 <gwern> gott ver damt!
18:46:01 <lispy> sjanssen: newer versions of darcs will hide the "Ignore-this:" line from you when viewing changes.  But yes, when I said I didn't like seeing it in emailed patch bundles I was told, and I quote, "I don't care."  So we need more people, other than myself, to complain.
18:46:03 <sjanssen> lispy: could the random bytes only be added if a flag is given to darcs?
18:49:37 <lispy> gwern: hmm...some sort of weird darcs repo version thing going on
18:49:45 <lispy> sjanssen: Um, maybe
18:49:53 <lispy> sjanssen: that sounds easy to change
18:50:23 <gwern> *more* flags?
18:50:32 <gwern> darcs has quite enough already,,,
18:50:33 <lispy> gwern: nevermind, I'm dumb
18:51:09 <sjanssen> gwern++ making releases of lambdabot
18:58:44 <lispy> gwern++ taking over autoproc
18:58:47 * gwern decides to throw in some Borges to this lb ANN
18:59:01 <gwern> lispy: eh what? I don't use procmail any more, I am unworthy to be maintainer
18:59:14 * lispy finds this rather amusing
18:59:34 <lispy> gwern: I stopped using procmail about 1 week after I completed the first working version of autoproc
18:59:50 <lispy> gwern: so it's only fitting that you would stop using procmail right when I declare you maintainer
19:00:08 * gwern snorkles and girlishly giggles as I send off the ann
19:01:12 <lispy> heh, the readme is borked, let me fix that
19:01:29 <gwern> http://www.haskell.org/pipermail/haskell-cafe/2008-October/049795.html
19:01:31 <lambdabot> Title: [Haskell-cafe] ANN: Lambdabot 4.2.2, http://tinyurl.com/6gxfbt
19:01:55 * gwern notes lispy didn't even ask before making me maintainer
19:02:17 <lispy> I asked over email
19:02:22 <lispy> a while back
19:02:26 <gwern> you did?
19:02:26 <lispy> I thought you said yes
19:02:49 * gwern disowns my past self which said yes. You are no longer my offspring! leave this place and never return
19:02:59 <gwern> ah well, how hard could maintaining it be?
19:03:31 <lispy> yeah, I think there have historically been 2 users
19:03:34 <lispy> me and then you
19:03:35 <lispy> :)
19:03:52 <gwern> a pity, because it's a good idea
19:04:09 <gwern> I really meant to autoproc-ize my .procmailrc but you took so long applying my patches I completely lost steam
19:04:17 <lispy> it could be improved by judicious use of phantom types I believe.
19:04:21 <gwern> and that would've generated all sorts of refinements and additions
19:04:43 <lispy> oh, I assumed you could use it wether I did it or not.  My bad.
19:04:55 <lispy> I need to install gpg
19:05:06 <gwern> no, I just try to limit how much work I have locally
19:05:26 <gwern> I've been burned by the occasional situation where I have a ton of patches and upstream decides to turn'em all down
19:05:46 <lispy> ah
19:06:13 <lispy> anyone know off hand, how to get gpg on osx with port?  I see gpg-agent, I doubt that's what I want
19:07:06 <lispy> gwern: so do you mind if I update the maintainer field to point at you?
19:07:09 <gwern> wouldn't gpg-agent pull in gpg as a dep?
19:07:11 <gwern> lispy: no
19:07:22 * gwern is deeply amusedby this rpg thread on Borges: http://forum.rpg.net/showthread.php?p=8940731
19:07:55 <gnut> cool... my ffi interface works... but only for reals, not complex
19:08:06 <gnut> still haven't figured out the struct bit
19:08:09 <lispy> gwern: I'm using your gmail
19:08:12 <roconnor> maybe not the best place to ask but: can I get git to ask about commiting specific hunks like darcs does?
19:08:12 <lispy> gwern: is that accurate?
19:09:15 <gwern> lispy: yep
19:09:40 <gwern> roconnor: #git was pretty big and active last time I visited
19:10:01 <lispy> roconnor: -p
19:11:56 <pjdelport> roconnor: you can get hg to do that
19:12:36 <lispy> roconnor: git can even split the hunks, which is something the darcs users have requested for a long time but not yet received
19:13:09 <rwbarton> roconnor: git add -i
19:13:38 <roconnor> gwern: will #git thrash me if I use the word "darcs"?
19:13:47 <lispy> haha, I hope not
19:14:14 <lispy> roconnor: as far as I know, darcs hasn't done anything to offend git
19:14:15 <gwern> roconnor: I suspect they will just pity you
19:14:20 <mofmog> so i tried to do EUler 51 and i failed
19:14:20 <mofmog> in haskell
19:15:01 <lispy> mofmog :: ProjectEuler -> Maybe Success; mofmog (Problem 51) = Nothing
19:15:28 <gwern> 'poor roconnor. imagine how much time he's wasted because darcs is written in haskell. thank goodness git is written in c so we can manually unroll our duff's devices and treat our sha hashes as points and shiznit to shave off a few microseconds'
19:15:38 <gwern> *pointers
19:17:05 <roconnor> anyhow, I'll try git add -i and see what happens
19:17:43 <lispy> roconnor: if that no worky, someone told me it was -p, but then I don't use git so I'm not certain
19:19:45 <lispy> gwern: gpg-agent didn't install gpg :(
19:19:46 <gwern> 'night everyone
19:19:51 <gwern> lispy: how peculiar
19:20:32 * gwern hands lispy a dime. get yourself a real package-managed OS kid
19:27:32 <joseA> Hi
19:27:34 <chessguy> @bot
19:27:35 <lambdabot> :)
19:27:39 <chessguy> @version
19:27:40 <lambdabot> lambdabot 4.2.1
19:27:40 <lambdabot> darcs get http://code.haskell.org/lambdabot
19:27:56 <chessguy> tut tut, so obsolete
19:29:30 <roconnor> I wonder if we can use pull backs or push outs in package management to get packages that link two packages.
19:47:10 <adu> hai world!
19:48:05 <adu> kthxbye
19:48:31 <lispy> say adu to adu
19:48:48 <sereven> adieu adu
20:04:23 --- mode: irc.freenode.net set +o ChanServ
20:52:10 <edwardk> hah, anyone know what happens if you cmpxchg with the Ev register as RAX/EAX/AX/AL?
20:53:42 <path[l]> hey guys Id had a chat with some people last night about the difference between foldl and foldr here, but Im back with more questions if anyone is up to it.
20:56:15 <edwardk> ah nevermind i figured it out
20:57:33 <sbahra> edwardk, what is the "Ev register"?
20:58:00 <Cale> path[l]: sure
20:58:33 <Cale> path[l]: I made some diagrams here which illustrate the difference http://cale.yi.org/index.php/Fold_Diagrams
20:58:44 <lambdabot> Title: Fold Diagrams - CaleWiki
20:58:49 <path[l]> oh neat
20:59:53 <edwardk> sbahra: in x86/x86-64 nomenclature an Ev operand is 'any memory location or register' where v is the size selected by the operand prefix and rex byte 16, 32, or 64 bit.
21:00:17 <path[l]> whoa ok
21:00:22 <Cale> ah, a snippet of code wasn't showing up because apparently my syntax highlighter got broken
21:00:36 <sbahra> edwardk, I never heard of "Ev operand" :) Good to know.
21:00:39 <sbahra> edwardk, what are you working on?
21:00:39 <Cale> But the main thing is the diagrams for foldr and foldl
21:00:44 <path[l]> ok so yesterday I was wondering how I could use a list of items and find the smallest item and have it return early. Given that I know this particular item can never be smaller than 0
21:00:57 <Cale> okay
21:01:06 <edwardk> sbahra: the short answer is at the moment i'm interpreting x86-64 assembly, but its a side effect of a larger project ;)
21:01:16 <Cale> So first, you'll want to define a 'min' which shortcuts on that case
21:01:22 <path[l]> yeah
21:01:33 <Cale> min' 0 y = 0
21:01:42 <Cale> min' x y | x < y = x
21:01:50 <path[l]> yeah
21:02:01 <Cale> and otherwise, y
21:02:13 <Cale> and then you can use foldr1
21:02:38 <path[l]> yeah ok so the bit I didnt quite get I think was why I couldnt use foldl
21:02:51 <path[l]> and I was told that this is because its tail recursive
21:03:05 <Cale> Well, you *could* use foldl, but what happens is that foldl does nothing but call itself until it reaches the end of the list
21:03:13 <Cale> Let's evaluate it:
21:03:19 <path[l]> ok
21:03:38 <Cale> @src foldl1
21:03:38 <lambdabot> foldl1 f (x:xs) = foldl f x xs
21:03:38 <lambdabot> foldl1 _ []     = undefined
21:03:44 <Cale> right, okay :)
21:03:47 <Cale> @src foldl
21:03:47 <lambdabot> foldl f z []     = z
21:03:47 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:04:03 <Cale> So, starting with foldl1 min [1,2,3,4]
21:04:16 <Cale> -> foldl min 1 [2,3,4]
21:04:17 <path[l]> right
21:04:25 <Cale> -> foldl min (min 1 2) [3,4]
21:04:38 <Cale> -> foldl min (min (min 1 2) 3) [4]
21:04:48 <Cale> -> foldl min (min (min (min 1 2) 3) 4) []
21:05:00 <Cale> -> min (min (min 1 2) 3) 4
21:05:09 <path[l]> yeah
21:05:11 <Cale> -> min (min 1 3) 4
21:05:14 <Cale> -> min 1 4
21:05:15 <Cale> -> 1
21:05:29 <ddarius> Cale: Have you written a tool to do that for you yet?
21:05:37 <Cale> ddarius: No, I just do it by hand.
21:05:57 <path[l]> but now suppose we used min' and [12340] from min(min(min(min 1 2) 3) 4) 0)
21:06:00 <path[l]> err
21:06:06 <path[l]> make those min' instead of min
21:06:14 <path[l]> and suppose min' was
21:06:21 <path[l]> min' x 0 = 0
21:06:25 <Cale> Yes, after finding its way all the way to the end of the list, it'll be able to quit a bit early
21:06:29 <ddarius> That was more a suggestion cleverly disguised as a question than an actual question.
21:07:07 <path[l]> min' x y | x < y = x
21:07:12 <Cale> But you'll already have spent a lot of time working your way down the whole list building up the expression of min's
21:07:19 <path[l]> ah
21:07:52 <Cale> whereas if there's a 0 near the start of the list, the foldr version could skip even that
21:08:08 <Cale> Let's have a look at that.
21:08:12 <Cale> @src foldr1
21:08:12 <lambdabot> foldr1 _ [x]    = x
21:08:12 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
21:08:12 <lambdabot> foldr1 _ []     = undefined
21:08:15 <Cale> @src foldr
21:08:16 <lambdabot> foldr f z []     = z
21:08:16 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:08:25 <Cale> So...
21:08:38 <path[l]> hmm
21:08:43 <Cale> foldr1 min' [1,0,2,5,7]
21:08:45 <Cale> say
21:09:22 <Cale> -> min' 1 (foldr1 min' [0,2,5,7])
21:09:39 <Cale> -> min' 1 (min' 0 (foldr1 min' [2,5,7]))
21:10:02 <Cale> oh, but look, min' 0 doesn't look at its second argument
21:10:20 <Cale> -> min' 1 0
21:10:23 <Cale> -> 0
21:10:31 <path[l]> yeah
21:10:32 <path[l]> hmm
21:10:50 <path[l]> this is because its min(foldr) instead of foldl(min) as it was last time
21:10:57 <Cale> yeah
21:11:08 <Cale> the min is on the outside, and that's what gets evaluated first
21:11:38 <Cale> In some sense, foldr f (x:xs) returns immediately
21:11:45 <path[l]> yeah I see
21:12:05 <Cale> (foldr1)
21:12:33 <Cale> foldr1 f (x:xs) produces an application of f to x and the expression (foldr1 f xs)
21:12:38 <Cale> and f gets to evaluate next
21:13:02 <Cale> and if for any reason it doesn't look at its second parameter, the recursive call is never used.
21:13:29 <path[l]> ok I think I get how foldr works and why, but regarding foldl, someone also mentioned a  foldl' yesterday that forcibly evaluates instantly?
21:13:53 <Cale> right, it evaluates the expression that would otherwise build up, as it goes
21:14:10 <Cale> Let's look at foldl1' for this problem...
21:14:13 <path[l]> ok
21:14:38 <Cale> foldl1' min' [1,0,2,4,5]
21:14:52 <Cale> -> foldl' min' 1 [0,2,4,5]
21:15:25 <Cale> -> let y = min' 1 0 in y `seq` foldl' min' y [2,4,5]
21:16:28 <Cale> If you haven't seen seq, what it does (roughly) is the expression (y `seq` z) ensures that y is evaluated before z
21:16:29 <path[l]> hmm ok I see. This just makes it worse
21:16:36 <Cale> no, this is okay
21:16:44 <Cale> I just wanted to take a moment there :)
21:16:50 <path[l]> no no
21:16:52 <path[l]> I mean
21:16:57 <Cale> -> foldl' min' 0 [2,4,5]
21:17:17 <path[l]> foldl' does more work than foldl and doesnt give me any saving here
21:17:31 <path[l]> but yeah thats cool, I read about seq now I see it
21:17:35 <Cale> Oh, well, yes, you'll basically do lots of work -- after you hit the 0 though, you at least won't force the remainder of the elements of the list to evaluate.
21:18:02 <Cale> Like, if the list had a bunch of expressions: [1,0,product [1..1000],sum [1..100000]]
21:18:22 <joseA> hi, i need Help. I have a IO String but i don't know how unwrap it. I'm reading a line from a file with hGetLine.
21:18:42 <Cale> joseA: an (IO String) is like a program which if you run it, will produce a String
21:19:01 <path[l]> hmm
21:19:07 <Cale> joseA: To run it, you write  do x <- myIOString; ...
21:19:28 <ddarius> joseA: I'd recommend that you not think of it as "wrapped up."
21:19:30 <Cale> joseA: that do-block becomes another IO action, and eventually, your main is an IO action.
21:20:13 <Cale> It's not like there's any one mysterious String in there. It's an action which gets a String from the user or does some kind of I/O to produce a string.
21:20:37 <ddarius> or maybe throws an exception and produces nothing
21:20:42 <Cale> true
21:20:51 <path[l]> I thought foldl' will still evaluate the entire list even if it hits the 0. Since foldl' min' 0 [3,4] will still do foldl' min' 0 [4] which will do min' 0 4
21:20:54 <Cale> And if you run that action multiple times, it will give you different strings.
21:21:12 <Cale> path[l]: but min' 0 4 won't force the evaluation of 4
21:21:26 <path[l]> yeah
21:21:30 <path[l]> I see what you mean
21:21:59 <Cale> So it'll still skip a little work, but much less work than the foldr version will.
21:22:09 <joseA> ok, but when i tried to run it. The compiler give me an error "Couldn't match expected type `IO t' against inferred type `Char'"
21:22:19 <joseA> i'm trying to do this:
21:22:27 <path[l]> so there's no way to force foldl to return early it looks like
21:22:31 <Cale> path[l]: right.
21:22:41 <Cale> path[l]: As a result, foldl never works with infinite lists.
21:22:46 <Cale> path[l]: But foldr can.
21:22:52 <joseA>  firstLine<- hGetLine filehand
21:22:54 <joseA>  x<- head firstLine
21:23:03 <Cale> let x = head firstLine
21:23:20 <Cale> head firstLine is a Char, not an IO action, so you don't have to run it.
21:23:25 * jauaor invites joseA to #haskell.es
21:23:50 <Cale> joseA: Does that make sense?
21:23:59 <Cale> firstLine :: String
21:23:59 <joseA> ok ok
21:24:08 <joseA> yes, I understand
21:24:12 <Cale> cool :)
21:24:21 <path[l]> ah
21:24:33 <path[l]> ok hypothetical question
21:24:36 <joseA> thank you Cale and I'm sorry for my english
21:25:01 <Cale> joseA: I didn't notice any problems with your English :)
21:25:38 <Cale> > [[1..k] | k <- [1..]]
21:25:41 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2...
21:25:42 <path[l]> if I have a function f a b where f a b != f b a and hence I needed to operate the list from left to right. But if I needed an early return my best bet is to define f' a b = f b a ?
21:25:48 <Cale> > foldr (++) [] [[1..k] | k <- [1..]]
21:25:50 <lambdabot>   [1,1,2,1,2,3,1,2,3,4,1,2,3,4,5,1,2,3,4,5,6,1,2,3,4,5,6,7,1,2,3,4,5,6,7,8,1,...
21:25:59 <joseA> well, thanks
21:26:18 <joseA> see you !
21:26:18 <Cale> joseA: Let us know if you have any other problems getting things to work :)
21:26:57 <path[l]> whoa Ive not seen this expression before. [[1..k] | k <- [1..]]
21:27:01 <Cale> path[l]: It's best to define a version of the function which can return early after seeing its first parameter and without looking at the second.
21:27:12 <path[l]> I know 1..k and 1... are ranges where 1.. is infinite
21:27:18 <Cale> > [1..k]
21:27:19 <lambdabot>   * Exception: not a number
21:27:19 <Cale> > [1..10]
21:27:21 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
21:27:41 <Cale> The other bit of syntax is called a list comprehension
21:27:42 <shrughes> > [1..] :: [Word8]
21:27:43 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
21:27:45 <path[l]> but this looks like [1..k] is a range where k is every element in  the other list
21:27:48 <path[l]> ah I see
21:27:54 <shrughes> > length ([1..] :: [Word8])
21:27:55 <lambdabot>   255
21:27:55 <Cale> > [(x,y) | x <- [1,2,3], y <- [4,5]]
21:27:57 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
21:28:08 <path[l]> so its like a foreach element in the second list evaluate the first
21:28:21 <Cale> Something like that...
21:28:27 <path[l]> oh and it does cross products
21:28:39 <path[l]> I guess I need to work up to that chapter
21:28:42 <Cale> For each x chosen from [1,2,3] and each y from [4,5], (x,y) is an element of the list.
21:28:52 <path[l]> cool
21:28:53 <Cale> You can also add conditions...
21:28:59 <Cale> > [(x,y) | x <- [1,2,3], y <- [4,5], even (x+y)]
21:29:00 <lambdabot>   [(1,5),(2,4),(3,5)]
21:29:11 <Cale> So these are the pairs which add to an even number.
21:29:17 <path[l]> ooh
21:29:18 <path[l]> neat
21:29:26 <path[l]> well thanks a lot for the help on foldr vs foldl. I guess I'll get back to working through the book
21:29:31 <Cale> :)
21:29:55 <Cale> No problem, don't hesitate to ask if you have any more questions :)
21:30:34 <path[l]> you've been very patient, I appreciate it
21:30:56 <Cale> :)
21:45:30 <edwardk> @seen sbahra
21:45:31 <lambdabot> sbahra is in ##logic, #haskell, ##freebsd, #ghc and #haskell-blah. I last heard sbahra speak 44m 51s ago.
22:09:42 <Samy> edwardk, had to run out to greet some guests :)
22:09:57 <edwardk> samy: ah
22:11:33 <lennort> can somebody recommend a good haskell tutorial for someone who hasn't done functional programming before?
22:14:45 <Cale> lennort: have you tried LYAH?
22:14:49 <Cale> @where lyah
22:14:49 <lambdabot> www.learnyouahaskell.com
22:15:04 <Cale> @where yaht
22:15:04 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
22:15:10 <Cale> @where wikibook
22:15:11 <lambdabot> http://en.wikibooks.org/wiki/Haskell
22:15:25 <Cale> There's also "Real World Haskell"
22:15:28 <Cale> @where rwh
22:15:28 <lambdabot> http://www.realworldhaskell.org/blog/
22:15:35 <lennort> i have not, thanks
22:15:41 <Cale> ah, that's the blog, you'll find a link to the full book from there
22:15:53 <Samy> lennort, and if you're willing to purchase a book (though you can download it illegally), check out "The Craft of Functional Programming" by Simon Thompson
22:16:02 <Plareplane> the full book: http://book.realworldhaskell.org/read/
22:16:13 <lambdabot> Title: Real World Haskell
22:18:02 <lennort> awesome, thanks for all the links.
22:19:32 <Cale> Oh, if we're talking about paper books, Graham Hutton's book is supposed to be a really solid intro and got good reviews.
22:35:31 <ivanm> can anyone think of a relatively simple example I can use to compare mathematical syntax to haskell syntax and show how mathematical haskell is?
22:36:49 <rwbarton> list comprehensions?
22:37:05 <vegai> y-combinator?
22:37:18 <vegai> infinite recursion
22:37:21 <jauaor> list comprehensions for sure
22:37:23 <ivanm> I was after something showing off the types actually
22:37:30 <ivanm> vegai: what's a y-combinator?
22:37:43 <rwbarton> I can't think of other ways off the top of my head that haskell syntax is particularly more like math than other languages are
22:37:43 <shrughes> _the_ y combinator :)
22:38:11 <jauaor> comparing list comprehensions with set builder notation is nice
22:38:23 <shrughes> ivanm: i think the basic factorial function is an excellent example:
22:38:33 <shrughes> factorial 0 = 1  ;  factorial n = n * factorial (n - 1)
22:38:37 <vegai> f g = g (f g) -- was it this one?
22:38:52 <ivanm> ahhh, yes, that will do nicely
22:38:56 <ivanm> thanks shrughes
22:38:57 <rwbarton> Yeah, factorial is good
22:39:04 <shrughes> the trick is to tell them first you'll just define the function mathematically
22:39:05 * ivanm was trying to think of some arbitrary function
22:39:10 <rwbarton> or fibonacci :)
22:39:20 <shrughes> and then say "let's translate that to haskell...... done."
22:39:41 <ivanm> actually, fibonacci might be better, as it lets me show uncurried vs curried form
22:40:01 <shrughes> what's that?
22:40:20 <shrughes> regarding its relevance to the fibonacci function
22:40:29 <vegai> how about f x = x : f (x+1)
22:40:32 <rwbarton> Also, who is your audience?
22:40:43 <ivanm> rwbarton: mathematicians
22:40:48 <vegai> nats = f 0
22:40:53 <ivanm> shrughes: f (x,y) vs f x y
22:40:59 <shrughes> oh, k
22:41:27 <ivanm> vegai: my main reason is showing off the type system for starters
22:42:07 <shrughes> the Monoid typeclass
22:42:27 <shrughes> you can't do mempty elegantly in OO languages
22:42:29 <rwbarton> hmm, it'd be better if the class methods didn't have such awful names
22:44:15 <rwbarton> In some ways the Haskell type-level syntax is more logical than the mathematical notation and is different for that reason
22:44:20 <rwbarton> e.g. (X, Y) vs. X x Y
22:44:43 <luqui> Hmm, only superficially, imo
22:44:43 <lambdabot> luqui: You have 1 new message. '/msg lambdabot @messages' to read it.
22:44:53 <rwbarton> superficially more logical?
22:44:55 <ivanm> rwbarton: yeah, I know
22:45:05 <shrughes> and   Eq a => Eq [a]... yes superficial
22:45:10 <ivanm> as well as being able to abstract over all numbers
22:45:16 <luqui> To me, (X,Y) is itself the pair of types X and Y, not the type of pairs of X and Y
22:45:39 <luqui> and yeah, the list thing is just borked, but we all know that :-)
22:45:40 <shrughes> I don't think it's superficially logical
22:45:57 <dolio> It'd be a big problem if you wanted dependent typing with universe polymorphism.
22:46:21 <luqui> dolio, why universe polymorphism?  what is universe polymorphism?
22:46:43 <shrughes> I might be misinterpreting everything
22:46:50 <dolio> luqui: Well, without universe polymorphism, you wouldn't be using (,) as a constructor at both the value and type level.
22:47:05 <dolio> Presumably.
22:47:26 <luqui> ah universe polymorphism = the lack of distinction between type and value level, in some sense?
22:47:46 <dolio> Well, in agda for instance...
22:48:20 <dolio> data Pair (A : Set) (B : Set) : Set where _,_ : A -> B -> Pair A B
22:48:39 <dolio> So, (3 , 4) : Pair Nat Nat is fine.
22:49:42 <dolio> But (Nat , Nat) is not, because Nat : Set, so you'd need A = B = Set, and Set : Set1.
22:50:15 <dolio> Which doesn't match with A : Set (Set is like Set0).
22:50:53 <luqui> ah, ok, now I see what you mean
22:50:57 <dolio> So, universe polymorphism lets you implicitly range over Ns for SetN, and lets the same constructor work for multiple levels in the type tower.
22:51:20 <luqui> aye, like Type in coq...
22:51:40 <luqui> (that highly sophisticated shorthand :-)
22:51:52 <dolio> Yeah. Agda doesn't have that, so you need to write new declarations whenever you want the same kind of structure at a different level, which is a pain.
22:53:35 <luqui> right.  that is actually one of the big things that turned me off to agda when I started with it
22:53:50 <luqui> (actually it turned me off to dependent types in general, but needlessly)
22:53:59 <luqui> now I'm a DT whore :-)
22:54:04 <dolio> :)
22:56:33 <rwbarton> I guess haskell f :: X -> Y looks superficially like math f : X -> Y, but in math we may be working in a category that's not cartesian closed, so we don't view this as a special case of "f : T"
23:13:17 <kosmikus> luqui: you know that Agda has the flag --type-in-type ? that puts you into the same situation as in Epigram. it's convenient but, in principle, inconsistent.
23:14:03 <luqui> kosmikus, nope, didn't know that.  I'm a coqlover now anyway.
23:15:10 <kosmikus> I'm still undecided. Coq certainly is more mature, but I like Agda's syntactic similarity to Haskell.
23:17:49 <dolio> It'll all become moot when Epigram 2 comes and destroys them all.
23:18:20 <wkh> wow, 479 users.
23:18:42 <kosmikus> dolio: :)
23:18:52 <Beelsebob> @users
23:18:53 <lambdabot> Maximum users seen in #haskell: 547, currently: 479 (87.6%), active: 10 (2.1%)
23:19:20 <dolio> lambdabot seems to have an off-by-one error.
23:19:49 <Beelsebob> maybe she counts herself twice?
23:19:56 <Beelsebob> or counts chanserv
23:23:13 <luqui> dolio, is that actually moving?  the blog has stagnated for a while now
23:24:54 <kosmikus> luqui: afaik, it's not a dead project, but certainly it's not moving quickly these days
