00:00:00 <jsnx> adu: even with in?
00:00:07 <adu> usually you use "let ... in .."
00:00:12 <adu> you can use that anywhere
00:00:16 <yewT> like do Function1, Function2, Function3, and below fuction3 is let Function 1 to 3 in Function4
00:00:33 <jsnx> oh
00:00:35 <adu> but in do, there is a special form: "do line1 ; line2 ; let .. ; line4 ..."
00:00:40 <ozy`> jdrake: I'm sure you could get a PHD to write one with a day's work, and then be forced to wait for their paper to be published before you get to use it....
00:00:43 <jsnx> in do.... you can just have let without in
00:00:58 <jsnx> adu: yes, indeed
00:01:02 <yewT> jsnx: without in?
00:01:05 <yewT> o_o
00:01:11 <jdrake> ozy`, that feels like you slapped the whole channel with a dead fish :p
00:01:16 <jsnx> > do { let x = 7 ; print x }
00:01:16 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 33}
00:01:17 <lambdabot> ...
00:01:21 <jsnx> damn
00:01:34 <jsnx> > do { let { x = 7 } ; print x }
00:01:35 <lambdabot>   * Exception: "<IO ()>"
00:01:40 <jsnx> !!
00:01:50 <adu> yewT: yes you can only use let without 'in' in do... it basically makes the rest of 'do' the 'in' part
00:01:52 <ozy`> jdrake: I try to do this at least once every five minutes somewhere on the internet
00:03:04 <Axman6> > do { let {x = 7;]; return x } :: Maybe Int
00:03:05 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 24}
00:03:05 <lambdabot> ...
00:03:10 <Axman6> > do { let {x = 7;}; return x } :: Maybe Int
00:03:12 <lambdabot>   Just 7
00:03:14 <jdrake> ozy`, I suggest you troll around reddit and anytime there is something about the police, defend the police in the thread some way, and you will have many responses that are negative towards yourself, your mother, and your great dead ancient progenitor.
00:03:14 <jsnx> http://hpaste.org/11092
00:04:07 <jsnx> jdrake: sounds like a matter for #haskell-blah
00:04:10 <ozy`> jdrake: trolling reddit would completely murder my attention span... I'd get lost before I ever made it to the "post comment" page
00:04:13 <adu> i like dead fish
00:04:36 <adu> ozy`: you can post on reddit?!? wow
00:04:43 <jsnx> adu: i liek them fresh and local
00:05:07 <jsnx> adu: go to digg.com -- that' where they hide the comment boxes
00:05:23 <jdrake> jsnx, how many auxillary channels do we have?
00:05:48 <ozy`> @channels
00:05:49 <lambdabot> Unknown command, try @list
00:05:52 <ozy`> hmmm
00:06:05 <jsnx> jdrake: there's also #ghc ones
00:06:17 <jsnx> off the top of my head, i don't know
00:06:27 <Baughn> @seen lambdabot
00:06:27 <lambdabot> Yes, I'm here. I'm in ##freebsd, ##hrg, #xmonad, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.
00:06:27 <lambdabot> it, #haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-overflow, #haskell-hac07, #haskell-books, #haskell-blah, #haskell, #ghc, #
00:06:27 <lambdabot> gentoo-uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #darcs, #arch-haskell and ##logic
00:07:37 <Axman6> ...
00:09:03 <ozy`> hmmm, I see Scala being mentioned more and more these days
00:09:26 <Axman6> the systax looks pretty yuck
00:11:07 <vegai> I keep reading about left-fold enumerators for IO. Is that stuff going to change something significantly?
00:11:22 <vegai> look into your crystal balls, will all IO be done through them in 3 years?
00:11:30 <ozy`> Axman6: I almost thought about looking into it at one point... and then I found out it supported (and encouraged) inline XML
00:11:53 <Axman6> :S
00:12:34 <jsnx> vegai: a cursory reading of oleg's stuff suggests it makes much more economical use of file descriptors than the lazy IO package
00:13:02 <Baughn> Axman6: No tail-call elimination support? ;-:
00:13:13 <Cthulhon> ozy`: U thought that was Groovy.
00:13:17 <Cthulhon> *I
00:13:29 <Cthulhon> Scala seemed okay.
00:13:38 <Cthulhon> But no killer features.
00:13:54 <jsnx> vegai: also interesting is the idea that left-fold enumerators are naturally "layerable" -- network packet layer, bytes stream layer, utf8 character layer...
00:14:02 <Cthulhon> Except that it runs on the JVM and its not Java.
00:14:21 <jsnx> Cthulhon: that seems to have given it an in at some shops
00:15:10 <Cthulhon> Yeah.
00:15:19 <inimino> how do you get ghci to load something interpreted even if it's already been compiled?
00:15:28 <Cthulhon> I wouldn't object to switching to it for my day job.
00:15:35 <ozy`> the JVM does not support tail call optimization as such
00:15:46 <Cthulhon> Right now I have to use Java/Spring/Tomcat.
00:15:55 <Cthulhon> It's a mess.
00:16:08 <cads> why is xml so fucked up? Mind you, I've never used it.. I also get the strong feeling that I don't particularly _want_ to use it, and I don't know exactly why.. I can think of lots of interesting things that could be done with a tree-like document it's just I don't want to touch it. Why do I feel this way?
00:16:22 <jsnx> well, if programming gets too easy -- we won't have chill jobs where we just rerun make all the time
00:16:36 <inimino> cads: because the syntax is verbose
00:16:55 <vegai> jsnx: hmm, what do these layers imply? That things are more finely typed?
00:17:29 <yewT> hmm got a problem with let and in
00:17:35 <yewT> within let, i can have many lines right?
00:17:47 <jsnx> yewT: yeah
00:18:18 <jsnx> vegai: well, they are in a sense no more finely typed than if you had a list that was made from another list that was made from another list...
00:18:46 <pjdelport> ozy`: IO is a pretty atypical monad
00:18:53 <ozy`> pjdelport: NOOOOOOOOO
00:18:57 <yewT> let (line1: add = 1+1) (line2: multiply = 2*2) (line3. subtract = 3-2) in (sum = add + multiply + subtract)
00:19:04 <jsnx> vegai: it's just that left-fold enumerators present an interface that is (apparently) more sensible in the context of file IO and network operations
00:19:15 <yewT> it gave me tihs error Syntax error in expression (unexpected `=')
00:19:24 <yewT> is it too many equal signs?
00:19:29 <jsnx> vegai: however, i just skimmed the paper
00:19:42 <yewT> jsnx: any clue with my problem?
00:19:55 <yewT> df
00:19:58 <jsnx> yewT: can you use hpaste.org please?
00:20:16 <idnar> where did the hpaste bot go?
00:20:29 <cads> I think that with html and xml I've always felt sorry for the computers that get the boring task of parsing it day in day out (not to mention the humans that have to deal with it too)
00:20:36 <jsnx> it's being lazily evaluated still?
00:21:03 <jsnx> cads: XML was my introduction to strongly typed functional programming, oddly enough
00:21:10 <jsnx> XSLT and XSD
00:21:20 <jsnx> i thought it was great (if a little verbose)
00:21:26 <pjdelport> verbosely typed functional programming
00:21:37 <jsnx> it took several years before i realized how much better it could be
00:21:44 <idnar> XSLT isn't that bad
00:21:48 <idnar> it's just the XML syntax that sucks
00:22:00 <jsnx> i think XML is good
00:22:08 <idnar> similarly, N3 is so much nicer than RDF/XML
00:24:13 <jsnx> idnar: i imagine modelling trees and lists with N3 would be a bear, though
00:24:24 <idnar> jsnx: oh, well, I wasn't suggesting that
00:24:48 <idnar> I'm just saying that most things with an XML serialization could do a lot better with an alternative serialization for human consumption
00:24:56 <jsnx> idnar: i agree
00:25:00 <idnar> for example, you could probably build a pretty nice XSLT DSL in Haskell
00:25:41 <jsnx> i think part of XML's problem was that it was trying to let people maker parsers/compilers without actually writing parsers/compilers.
00:26:31 <jsnx> know that we parsec, we can put it all behind us...
00:26:38 <idnar> haha
00:26:42 <jsnx> s/we parsec/we have parsec/
00:26:56 <idnar> almost every time I whip out a regex somewhere, I wish I had something as nice as parsec handy
00:28:36 <yewT> http://hpaste.org/11058#a10
00:28:43 <yewT> can someone check my let and in
00:28:53 <yewT> the link is above, the error message is in hpaste .org
00:29:21 <pjdelport> yewT: tabs?
00:30:23 <pjdelport> yewT: convert the tabs to spaces
00:30:38 <pjdelport> tabs are not a good idea
00:32:22 <yewT> ok
00:32:36 <yewT> umm whats the difference between tabs and spaces?
00:32:59 <ozy`> yewT: tabs are pretty much always a bad idea these days
00:33:36 <ozy`> since every editor displays them as different widths, and haskell always considers them to be eight spaces (IIRC)
00:33:38 <pjdelport> yewT: tabs are an artifact of the days when computers had to interface with typewriters
00:33:38 <yewT> ozy, after i convert all tabs into spaces, i run in into another error
00:33:39 <yewT> ERROR file:.\test.hs:2 - Syntax error in expression (unexpected `=')
00:33:48 <yewT> what does it mean?
00:33:59 <pjdelport> yewT: what's the alignment?
00:34:08 <yewT> what do you mean by the alignment?
00:34:20 <ozy`> yewT: I dunno, but I get a different error which was obvious to me when I first looked at the code....
00:34:55 <pjdelport> yewT: the let assignments have to be vertically aligned
00:34:58 <yewT> ozy` pjdelport http://hpaste.org/11058#a11
00:35:08 <yewT> i made it vertically alligned o_o
00:35:23 <pjdelport> yewT: doesn't look aligned :)
00:35:29 <Cthulhon> You can have my tabs when you pry them from my cold, dead fingers. :|
00:35:31 <yewT> the let and in is alligned
00:35:34 <Cthulhon> I like being able to configure indentation width the way I like it.
00:35:35 <pjdelport> multiply and subtract are indented by 4 spaces
00:35:58 <pjdelport> Cthulhon: except tabs don't let you do that :(
00:36:09 <Cthulhon> Yes they do.
00:36:24 <pjdelport> yewT: it's add, multiply and subtract that have to be aligned
00:36:31 <Cthulhon> Just set your tab width in your editor of choice.
00:36:49 <yewT> pjdelport, in my notepad, everything is alligned
00:37:00 <yewT> pjdelport but when i copied and paste into hpaste.org, its not alligned
00:37:12 <Cthulhon> Well, yeah, Notepad does throw a wrench in things.
00:37:15 <ozy`> yewT: http://hpaste.org/11058#a12
00:37:28 <ozy`> and, don't use notepad
00:37:33 <ozy`> get a real editor ;)
00:37:38 <ozy`> like nano
00:37:39 <ozy`> sheesh
00:38:19 <TSC> You can have any tab width as long as it is 8
00:38:27 <yewT> ok
00:38:30 <yewT> you're right
00:38:33 <yewT> it works now XD
00:38:37 <Plareplane> i'm almost convinced by reddit that it's ok to mix tabs and space as long as tabs are strictly for indentation and spaces are strictly for aligning, and tabs are always to the left of spaces
00:38:43 <yewT> im using notepad++
00:38:59 <yewT> man, having indentation problem is giving me headaches
00:39:38 <ozy`> yewT: the solution is to either use only spaces, or set your tab width to eight
00:40:03 <yewT> http://hpaste.org/11058#a13
00:40:05 <yewT> ok ozy`
00:41:16 <yewT> ozy` do you use notepad++ or something else
00:41:21 <pjdelport> Plareplane: or you could just use spaces
00:41:22 <yewT> anyone here uses notepad++ /
00:41:33 <yewT> how do i set my tab to become 8 width
00:41:40 <yewT> in notepad++
00:41:42 <ozy`> yewT: notepad++ doesn't even run on my operating system. for haskell I usually use vim
00:42:07 <yewT> vim opensource?
00:42:47 <pjdelport> yewT: yes
00:43:04 <ozy`> yewT: yeah. you should know this, by the way... it's on par with "Darth Vader is his father"
00:43:06 <pjdelport> yewT: it has a steep initial learning curve, though
00:45:55 <ozy`> yewT: you might like emacs better. somewhat gentler learning curve compared to vim, in that it at least has the same basic idea as notepad and company
00:46:33 <ozy`> also, the haskell indentation support is nicer... in fact I don't know of any editors besides emacs and yi with "smart" haskell indentation
00:49:37 <ozy`> (.... anyone should feel free to correct my short list... ;)
01:00:34 <ozy`> if I knew how to draw, I'd put together a lineup of anthropomorphized programming languages
01:01:31 <Beelsebob> you mean like the famous lambda and the chip shaking hands?
01:01:35 <ozy`> lisp and fortran would be larger-than-life... the latter would be somewhere between an olympic athlete and a Greek god, and the former would basically be Pai Mei
01:01:37 <ozy`> maybe?
01:01:59 <ozy`> I haven't heard of that, I don't think
01:02:09 * Beelsebob ponders if it can in any way be googled
01:02:49 <Beelsebob> some of the older guys will remember exactly how it came into existance -- I just remember seeing it all over my dad's stuff for a whil
01:07:24 <ozy`> Beelsebob: well part of the goal here would be to depict perl as having a mohawk, a couple of dangerous-looking test tubes, some hand grenades, mismatched socks, goggles that do nothing, and a one-man band kit
01:07:44 <Beelsebob> haha
01:08:05 <ozy`> if that's in the image you're thinking of, then we're all set
01:08:56 <ozy`> :p
01:09:18 <pjdelport> ozy`: awesome
01:09:39 <pjdelport> ozy`: you can't just have one Lisp, though
01:10:06 <Beelsebob> lisp needs to be bundled up in layers and layers of jackets
01:10:38 <ozy`> (C++, by a similar rationale, would be a cyborg whose cybernetic parts are obviously cobbled together from random pieces of junk)
01:10:38 * pjdelport guesses Scheme would be the Shaolin monk, and CL the drunken master
01:11:05 <ozy`> pjdelport: sure, I guess there could be two lisps, if that
01:11:31 <pjdelport> ozy`: and of course, they would have rich martial arts ancestry in the form of other lisps
01:11:48 <ozy`> yeah but they'd be standing in the middle of all these other languages
01:12:59 <ozy`> I'd also want to lump most of the ML line together into a single caricature
01:13:34 <ozy`> perhaps someone who is obviously Algerian?
01:14:14 <Beelsebob> surely ML would be a press with goop being poured into it and fresh anthropamorphisms coming out
01:14:24 <Beelsebob> (or the guy operating the press)
01:14:50 <ozy`> not enough room for too many props... a press would be a bit hard to identify
01:14:58 <ozy`> also most people haven't heard of ML anyway
01:17:59 <ozy`> ruby and python would be an Asian hipster and a serious-but-cute librarian, respectively
01:18:31 <ozy`> from there it gets murkier...
01:18:41 <pjdelport> Python would have to be Dutch
01:19:04 <ozy`> wooden shoes
01:20:13 <ziman> @type let s = ap in s (+) (+2) `seq` s
01:20:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
01:22:47 <ozy`> Haskell... brooding assassin, secret agent of the Illuminati, or both?
01:27:04 <yewT> hmm guys
01:27:09 <yewT> what does it mean by db operator in haskell?
01:27:20 <yewT> db operator = database operator ?
01:29:02 <yewT> no one knows?
01:32:15 <Saizan> yewT: it's probably something defined in the code you're looking at
01:32:53 <yewT> guys whats the difference between
01:32:55 <yewT> map(10+)[1,2,3]
01:32:59 <yewT> map(+10)[1,2,3]
01:33:02 <yewT> o_o
01:33:06 <yewT> both works
01:33:12 <yewT> > map(+10)[1,2,3]
01:33:13 <lambdabot>   [11,12,13]
01:33:18 <yewT> > map(10+)[1,2,3]
01:33:20 <lambdabot>   [11,12,13]
01:33:31 <Snark> yewT, isn't "+" commutative?
01:33:39 <yewT> what is commutative?
01:33:46 <Saizan> addition
01:33:56 <yewT> isnt + addition?
01:34:00 <yewT> yeah its addition
01:34:12 <yewT> just wandering how does map know where to place the element from the list into the function
01:34:18 <Saizan> however (+10) = \x -> x + 10, while (10+) = \x -> 10 + x
01:34:37 <Saizan> map doesn't care
01:34:39 <yewT> thanks saizan
01:34:47 <yewT> good explanation ^_^
01:35:41 <pjdelport> yewT: the parenthesized operator notation is known as slicing
01:36:00 <Saizan> pjdelport: "sections"
01:36:10 <pjdelport> err, what he said, yes
01:36:36 <ozy`> hmm, can (=) be redefined?
01:36:42 <pjdelport> yes
01:36:54 <pjdelport> sorry, not (=)
01:37:03 <pjdelport> but most any other operator
01:37:08 <Saizan> (and i think my explanation is not 100% correct in complex cases)
01:37:30 <yewT> pjdelport yewT: the parenthesized operator notation is known as slicing , slicing means?
01:37:34 <pjdelport> > let 2+2 = "five" in 2+2
01:37:35 <lambdabot>   "five"
01:37:47 <pjdelport> yewT: it's sectioning, not slicing, sorry
01:37:50 <ozy`> I know about other operators :p I was wondering mainly how hard it would be to implement a syntax that looked nothing like haskell
01:38:10 <ozy`> let &* = 5
01:38:13 <ozy`> erm
01:38:16 <ozy`> > let &* = 5
01:38:16 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 12}
01:38:16 <lambdabot> ...
01:38:21 <ozy`> > let &* = 5 in &*
01:38:22 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 12}
01:38:22 <lambdabot> ...
01:38:25 <ozy`> hrm
01:38:44 <ozy`> > let $* = 5 in &*
01:38:45 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 12}
01:38:45 <lambdabot> ...
01:38:48 <ozy`> bah
01:38:53 <pjdelport> > let ($%^$%&#) = (+) in 2 $%^$%&# 2
01:38:55 <lambdabot>   4
01:39:01 <ozy`> yeah I was afraid of that
01:39:23 <pjdelport> > let ($*) = 5 in (&*)
01:39:24 <lambdabot>   Not in scope: `&*'
01:39:29 <pjdelport> > let ($*) = 5 in ($*)
01:39:30 <lambdabot>   5
01:40:38 <yewT> ok pjdelport
01:41:31 <patco444> The Best Online RPG / Strategy game ever : http://www.fallensword.com/?ref=1461055
01:41:38 <lambdabot> Title: Fallen Sword v1.531 - Massively Multiplayer Online RPG (MMORPG)
01:43:42 <ozy`> > let {($%^) = length; (&*) = map; (#^+$) = ["apples", "oranges", "gnus"]} in $%^ &* #^+$
01:43:42 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 41}
01:43:42 <lambdabot> ...
01:54:36 <Saizan> Cale: btw, in mueval you've disabled blacklisting by making every function pass the test, right? but if we don't call checkNames at all from main.hs, it should report better error messages on parse errors (directly from ghc), also we avoid potential bugs in haskell-src-exts, just a thought :)
01:55:18 <Cale> Mmm... good thinking. I made my edits with boxing gloves on and not much thought ;)
02:01:01 <Cale> > System.IO.Unsafe.unsafePerformIO (print 5)
02:01:02 <lambdabot>   /tmp/3045966880408217541:67:36:
02:01:02 <lambdabot>      Not in scope: `System.IO.Unsafe.unsafe...
02:01:07 <Cale> okay :)
02:01:22 <Cale> > [x + y | x <- [1,2,3]; y <- [4,5]]
02:01:23 <lambdabot>   <no location info>: parse error on input `;'
02:01:35 <Saizan> > let {($%^) = length; (&*) = map; (#^+$) = ["apples", "oranges", "gnus"]} in $%^ &* #^+$
02:01:36 <lambdabot>   <no location info>: parse error on input `$%^'
02:03:02 <Saizan> now, if the ghci api returned an ADT for error messages instead of String we could have really nice ones :)
02:05:00 <pjdelport> > let {($%^) = length; (&*) = map; (#^+$) = ["apples", "oranges", "gnus"]} in ($%^)&*(#^+$)
02:05:01 <lambdabot>   [6,7,4]
02:05:08 <pjdelport> lovely
02:05:33 <ozy`> pjdelport: I was sincerely hoping it could be done without any parentheses....
02:05:42 <ozy`> for maximum TECO emulation
02:05:57 <pjdelport> well, you need something for the operator to apply to
02:06:39 <ozy`> tragically, this is the case
02:06:48 <yewT> > reverse[0,2]
02:06:49 <lambdabot>   [2,0]
02:10:17 <mmorrow> Saizan, Cale: one way that'd work to get ghc's error msgs easy is to instead of erroring out from checkNames, checkNames just passes the expr though upon parse error so ghc'll get that error.
02:10:31 <mmorrow> oh nice
02:10:45 <Saizan> mmorrow: we disabled checkNames directly
02:10:58 <mmorrow> hehe, nice
02:11:40 <mmorrow> wait...so checkNames was there even though the functions it was checking for weren't in scope in the first place??
02:11:50 <Cale> heh
02:11:59 <Cale> yes
02:12:02 <mmorrow> lol
02:12:15 <Cale> gwern is paranoid
02:12:27 <mmorrow> heh
02:12:52 <yewT> > map(take ["a","b","c","d"])(reverse [0,1])
02:12:53 <lambdabot>   Couldn't match expected type `Int' against inferred type `[a]'
02:13:02 <mmorrow> , map(take ["a","b","c","d"])(reverse [0,1])
02:13:04 <lunabot>  luna: Couldn't match expected type `GHC.Types.Int'
02:13:04 <Cale> They're not in scope *now*, but what if a miracle happens?! You'll wish you were checking.
02:13:56 <yewT> anyone know how to fix the problem above o_o
02:14:08 <yewT> im trying to take element 1, then element 0
02:14:19 <yewT> thats why i use reverse
02:14:32 <mmorrow> , reverse . take 2 $ ["a","b","c","d"]
02:14:34 <lunabot>  ["b","a"]
02:14:34 <Cale> That's not what take does
02:14:34 <yewT> it should take b then a
02:14:47 <yewT> cale: so what does take do?
02:14:49 <pjdelport> yewT: !! does indexing
02:14:59 <Cale> yewT: take n xs  gives the first n elements of xs
02:15:10 <Cale> > take 5 "Hello, world!"
02:15:11 <lambdabot>   "Hello"
02:15:21 <ozy`> yewT: let's get this straight... given [1, 2, 3], do you want [3, 2, 1] or [2, 1, 3]?
02:15:40 <yewT> ozy: sorry im confuse
02:15:45 <pjdelport> >  map (["a","b","c","d"] !!) (reverse [0,1])
02:15:47 <lambdabot>   ["b","a"]
02:17:05 <yewT> oh thanks pjdelport
02:17:30 * yewT tries to figure how !! works in map (["a","b","c","d"] !!) (reverse [0,1])
02:17:55 <mmorrow> if anyone's interested in how ghci works, i just took a used this thread to collect a crapload of relevant snippets from ghc src http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=80
02:17:59 <pjdelport> yewT: it does (["a","b","c","d"] !! 0) first
02:18:10 <pjdelport> err, 1
02:18:15 <pjdelport> and then 0
02:18:23 <yewT> :t !!
02:18:24 <lambdabot> parse error on input `!!'
02:18:27 <yewT> :t (!!)
02:18:28 <lambdabot> forall a. [a] -> Int -> a
02:18:30 <pjdelport> :t (!!)
02:18:31 <lambdabot> forall a. [a] -> Int -> a
02:18:50 <pjdelport> > "abc" !! 0
02:18:51 <lambdabot>   'a'
02:18:52 <pjdelport> > "abc" !! 2
02:18:54 <lambdabot>   'c'
02:19:02 <yewT> oh ok understood :)
02:19:09 <ozy`> yewT: "list !! i" is equivalent to "list[i]" in lots of other languages
02:19:50 * yewT tries to interpret what ozy explaines
02:20:16 <ozy`> yewT: what languages do you know?
02:20:32 <yewT> haskell
02:20:38 <ozy`> obviously
02:20:43 <yewT> lol
02:20:44 <ozy`> and?
02:20:47 <yewT> c
02:20:49 <yewT> but basic c
02:20:53 <yewT> -_-"
02:21:02 <ozy`> have you dealt with arrays in C?
02:21:08 <yewT> not often
02:21:29 <Cale> Oh interesting, a very new programmer :)
02:22:14 <Cale> Most of the people we get here already know at least a couple other languages well, since Haskell is (or at least was), a bit obscure. :)
02:22:18 <yewT> i heard that haskell is much easier than other programming languages
02:22:25 <yewT> so i went for haskell
02:22:32 <ozy`> yewT: but enough to see stuff like... int[12] list; list[3] = 17;
02:22:38 <ozy`> indeed
02:23:11 <Cale> I'd say it's similar to many others in terms of learning curve, if you're starting out in programming. If you know imperative programming well, then it's actually hard, because you have to unlearn stuff ;)
02:24:32 <ozy`> that's pretty accurate
02:27:11 <Cale> You might be able to draw on your knowledge of highschool algebra a bit :)
02:27:27 <Cale> Just to get a sense for how functions work.
02:27:44 <Cale> That's something you often can't do effectively in an imperative language.
02:30:41 <yewT> hmm
02:31:15 <yewT> > map (["a","b","c"] !!)[0,1]
02:31:17 <lambdabot>   ["a","b"]
02:31:23 <araujo> Haskell is a very good language to learn programming
02:31:39 <yewT> hey guys, could i make my own custom functoin that works out like !! ?
02:31:49 <yewT> > map (!! ["a","b","c"] )[0,1]
02:31:50 <lambdabot>   Couldn't match expected type `Int' against inferred type `[a]'
02:31:55 <oklopol> (!!)
02:32:16 <oklopol> > map ((!!) ["a", "b", "c"])[0,1]
02:32:18 <lambdabot>   ["a","b"]
02:32:29 <Cale> yewT: absolutely, (!!) isn't built-in
02:32:40 <yewT> i have a function call remove which takes in 2 arguments >> remove a b >> so this works? >>>  map (remove a) [1,2,3]
02:32:52 <Cale> yewT: yes
02:33:04 <yewT> *a function named "remove"
02:33:08 <oklopol> umm
02:33:12 <Cale> (of course, assuming that remove takes a number for its second parameter)
02:33:18 <pjdelport> yewT: of course
02:33:26 <hoknamahn> guys could you give me a link how to write DSO's in Haskell?
02:33:28 <pjdelport> defining functions is what Haskell does best :)
02:34:06 <yewT> so map knows the element from [1,2,3] is placed in b? >> remove a b
02:35:12 <pjdelport> yewT: right
02:35:15 <pjdelport> :t map
02:35:16 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:35:16 <Cale> yewT: In some sense, every function in Haskell has exactly one parameter.
02:35:45 <Cale> yewT: Those which seem to have more actually just produce functions which take the rest.
02:35:57 <pjdelport> yewT: map takes any function, and (remove a) is a function that still takes b
02:36:18 <pjdelport> > map (*2) [1,2,3]
02:36:20 <lambdabot>   [2,4,6]
02:36:20 <mmorrow> hoknamahn: i don't know what a DSO is
02:36:45 <pjdelport> > map (subtract 1) [1,2,3]
02:36:46 <lambdabot>   [0,1,2]
02:36:50 <mmorrow> hoknamahn: dynamic shared object?
02:36:54 <Cale> Detroit Symphony Orchestra? ;)
02:37:04 <hoknamahn> mmorrow - dynamic shared object or in terms of windows it's DLL
02:37:28 <yewT> > map( [ ["a","b","c","d","e","f"],["a","b","c","d","e","f"] ]!!)(reverse [0,2,4])
02:37:29 <lambdabot>   [* Exception: Prelude.(!!): index too large
02:37:35 <yewT> o_o
02:37:41 <hoknamahn> so basically i think how to load functions on the fly
02:37:46 <mmorrow> hoknamahn: ok cool, a quick google search landed me at a microsoftdn page about cubeanalyzerdbmissile or something ;)
02:37:56 <hoknamahn> hahaha
02:37:57 <pjdelport> yewT: that list only has two elements (the two inner lists)
02:37:58 <mmorrow> (i wasn't sure if you meant those)
02:38:08 <Cale> hoknamahn: I wonder if that's actually possible at present. I'm not sure. There's stuff to dynamically load Haskell code into Haskell programs.
02:38:08 <pjdelport> so !! 4 will fail
02:38:37 <hoknamahn> should be possible otherwise i don't know :-/
02:38:49 <mmorrow> hoknamahn: so do you want to /produce/ them or to dynamically link /to/ them (yourself) at runtime?
02:38:56 <yewT> oh
02:39:09 <hoknamahn> dynamically link
02:39:21 <yewT> i guess i need to use another map to extract 1 element from [[String]] and place it into this function map ((!!) ["a", "b", "c"])[0,1]
02:39:30 <yewT> effective?
02:39:46 <pjdelport> yewT: depends what you want to do
02:40:15 <pjdelport> yewT: what's the purpose of the nested list?
02:40:18 <mmorrow> hoknamahn: hs-plugins has a linker which resolves all the deps/etc which is built on the ghc linker which doesn't (provide an interface for) doing the auto dep chasing
02:40:27 <mmorrow> so probably hs-plugins is your best best
02:40:51 <mmorrow> hoknamahn: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/plugins
02:40:53 <lambdabot> Title: HackageDB: plugins-1.3, http://tinyurl.com/5mbt3u
02:41:13 <hoknamahn> okay mmorrow at least i know about hs-plugins. cool i'll check it. cheers
02:41:15 <Cale> Also, note that generally FFI will do the right thing.
02:41:21 <hoknamahn> but
02:41:29 <Cale> With regard to just using .so files on your system.
02:41:45 <mmorrow> i'm still slightly unclear though what exactly you're looking to do
02:41:49 <hoknamahn> but those .so should be generated by haskell
02:42:07 <Cale> I don't think it's possible at present to generate .so files with GHC.
02:42:18 <hoknamahn> well say i have a bunch of different functions which i want to load only when i need them
02:42:24 <mmorrow> ah, ok. so ghc can't quite do that yet, but it's being worked on from what i understand
02:42:45 <Cale> hoknamahn: The easiest thing would be to bite the bullet and link them statically.
02:43:03 <mmorrow> hoknamahn: http://hackage.haskell.org/trac/ghc/ticket/1876
02:43:04 <lambdabot> Title: #1876 (Complete shared library support) - GHC - Trac
02:43:14 <hoknamahn> arhhh.. okay :)
02:43:34 <mmorrow> it looks like it's close though
02:43:39 <mmorrow> "This ticket is a placeholder for the shared libraries work, which is mostly working but needs to be completed (binary distributions, issues with -rpath etc.)."
02:43:44 <hoknamahn> do we have "incomplete" support?
02:43:52 <hoknamahn> aha i see
02:43:54 <hoknamahn> cool
02:44:10 <mmorrow> possibly, but i'm not sure to what extent or what you'd have to hack on to get at it ;)
02:44:25 <yewT> pjdelport , the nested list is actually lots of records
02:44:47 <hoknamahn> i don't need it right now but probably in the nearest future
02:44:47 <yewT> pjdelport [[String]] = [ ["Jeans","Levis","Small"] , ["Shoe","Nike","Medium"] , ["Shirt","Polo","Large"] , ["Glove","Polo","Small"] , ["Item","Brand","Size"] ]
02:44:59 <pjdelport> ah
02:45:25 <mmorrow> <hoknamahn> well say i have a bunch of different functions which i want to load only when i need them
02:45:30 <yewT> so i guess i need to create another function using map to extract [jeans, levis , small] and insert into this function  map ((!!) ["a", "b", "c"])[0,1]
02:45:51 <mmorrow> you can do this actually by building a .o, then dynlinking with hs-plugins
02:46:21 <Cale> Oh, that's true.
02:47:16 <hoknamahn> good to know guys :)
02:47:18 <pjdelport> yewT: for that kind of thing, you probably want to define the inner records as tuples, to begin with
02:48:03 <pjdelport> or Haskell records
02:48:27 <Saizan> mmorrow: but you need to get those functions out of a Dynamic or similar, right?
03:00:57 <yewT> yay my code works now :D
03:01:14 <yewT> but when i combine all the functions it does not work properly -_-"
03:01:33 <mmorrow> Saizan: plugins'll load straight from a .o
03:01:40 <pjdelport> yewT: hpaste time :)
03:01:59 <mmorrow> Saizan: oh, i misunderstood you. lemme check..
03:03:19 <Baughn> @ask dons I'm isolating the builds that failed for not-my-fault reasons, but what should I do with the logs?
03:03:19 <lambdabot> Consider it noted.
03:03:45 <yewT> yay problem solved ^_^
03:03:50 <yewT> woot
03:04:11 <yewT> i forgot to include the new functions inside my main
03:04:11 <yewT> no wonder it keeps displaying the old results -_-"
03:04:32 <yewT> 1 more problem to complete *sweat*
03:04:54 * yewT takes a 5 minute break from haskelling
03:05:27 <chrisdone> mmorrow: did you get that e-mail about `validate'? heh
03:07:31 <chrisdone> @seen dufflebu1k
03:07:31 <lambdabot> dufflebu1k is in #haskell. I last heard dufflebu1k speak 10h 27m 2s ago.
03:08:07 <mmorrow> chrisdone: no, i've gotta check that email...
03:08:12 * mmorrow checks
03:09:56 <mmorrow> ah, cool. hmm, so what do you think about applying it with a #if __GHC_HASKELL__ < 609 ... #endif ?
03:10:48 <chrisdone> I wasn't sure if that was kosher. sure
03:12:07 <mmorrow> that's the only way i can think of to have it work with older bytestring versions...just assume if ghc==6.8 then it's an old bytestring pkg
03:12:25 <mmorrow> (and to have it work with newer bytestrings/6.10)
03:12:33 <chrisdone> yeah, bytestring has had the IsString instance since 0.9.0.4
03:13:00 <chrisdone> ok
03:13:14 <mmorrow> cool, sounds good to me :)
03:13:39 <chrisdone> like so? http://hpaste.org/11096
03:14:04 <chrisdone> woops
03:14:15 <chrisdone> s/60/s60
03:14:19 <chrisdone> blaefgh
03:14:22 <mmorrow> heh, yeah
03:14:23 <chrisdone> s/60/s609
03:14:28 <mmorrow> exactly
03:14:37 <chrisdone> grand
03:14:46 <mmorrow> heh
03:14:47 <chrisdone> I honestly haven't used this package :P
03:15:02 <chrisdone> I used it in Kibro a bit and now I'm refactoring it without it > ___>
03:15:40 <mmorrow> me neither, but now that i'm reminded of it i'm gonna go back through and refresh my memory
03:15:51 <chrisdone> mmk
03:16:18 <mmorrow> kthx
03:16:24 <chrisdone> rofl
03:17:10 <chrisdone> I realised a good solution to the problem of kibro creating/modifying the lighttpd.conf file, when you also want to add your own bits like mine-types
03:17:17 <chrisdone> lighttpd supports includes
03:17:37 <chrisdone> so I can just have e.g. #include "custom.conf" or whatever
03:17:42 <mmorrow> ooh, interesting.
03:18:03 <mmorrow> and just provide an empty one or something to be filled in if desired?
03:18:13 <chrisdone> yeah exactly
03:18:38 <chrisdone> jin who wrote that blog software based on kibro has ended up providing scripts to patch the lighttpd.conf and such
03:18:51 <mmorrow> nice, that's a good idea. best of both worlds and all that
03:18:56 <chrisdone> yeah
03:19:16 <chrisdone> his project has been really useful
03:19:22 <chrisdone> too bad I hate to read his source code :P
03:19:30 <chrisdone> did you see it ?
03:19:32 <mmorrow> i got panda built and checked out the code, but have yet to put it up somewhere. i plan to though
03:19:46 <chrisdone> cool
03:20:21 <yewT> > length [1,2]
03:20:22 <lambdabot>   2
03:20:25 <yewT> > length [1,2,3,4,5]
03:20:26 <lambdabot>   5
03:20:28 <chrisdone> as a warning it's kind of written to gobble up everything on the server
03:20:36 <chrisdone> with the 404-handler
03:20:52 <chrisdone> I tried to set it up as /blog/<foo>, but it's hard coded to use the root /
03:21:20 <mmorrow> hmm. there must be /some/ way to change it
03:21:40 <chrisdone> he's got
03:21:41 <mmorrow> ohh, you mean /in/ his code he hardcoded links to /?
03:21:42 <chrisdone> pages =
03:21:42 <chrisdone>     [ ("^/$"                  ,index             )
03:21:42 <chrisdone>     , ("^/([?].+$)?$"         ,index             )
03:21:43 <chrisdone> etc
03:21:46 <chrisdone> yeah exactly
03:21:51 <mmorrow> ah
03:22:09 <chrisdone> and all the links in the code aren't relative but absolute
03:22:59 <mmorrow> dang
03:23:07 <chrisdone> so I'll ask him to patch it if he feels like it
03:23:25 <mmorrow> sounds reasonable ;)
03:23:41 <mmorrow> well, it /is/ reasonable
03:24:01 <mmorrow> ok i gotta crash. catch you later.
03:24:27 <hoknamahn> guys, can instance of class have more methods than described in that class? for example cross product make sense only for 3d vectors but not 2d
03:24:35 <chrisdone> pretty cool though, I noticed that you can have (on lighttpd) a 404 handler so that you can have clever urls, right? but you can use $HTTP["url"] to limit that to certain regexes and run different fastcgi processes for different urls
03:24:37 <chrisdone> bye
03:25:23 <mmorrow> oh yeah, and you'll have to add CPP to either extensions: , LANGUAGE, or both
03:25:31 <opqdonut> hoknamahn: no, but you can do something like: "instance Vector Vector3D where ....; cross : Vector3D -> Vector3D -> Vector3D; cross = ... "
03:25:43 <opqdonut> (err, ::)
03:26:12 <mmorrow> chrisdone: lighttpd is way cool. i really want to start using it exclusively, but haven't found the time to get everything set up and flowing
03:26:25 <Valodim_> I have, and I'm more than happy =)
03:26:29 <mmorrow> later
03:26:39 <hoknamahn> but in general case i have to describe every possible methods and implement only those which make sense, right?
03:26:53 <opqdonut> welllll yes
03:26:55 <opqdonut> but that's ugly
03:27:03 <chrisdone> mmorrow: yeah! laters
03:27:05 <opqdonut> a hierarchy of classes is better
03:27:18 <hoknamahn> okay cool
03:27:20 <chrisdone> mmorrow: thanks about the CPP, I was just trying to find that
03:27:29 <opqdonut> something like VectorSpace < NormedVectorSpace < InnerProductSpace
03:27:54 <hoknamahn> thanks opqdonut
03:32:15 <hackage> Uploaded to hackage: heap 0.5.0
03:39:53 <Baughn> @tell dons cabal-install needs to actually build packages that are mentioned in preferred-versions, if they aren't already on the system. (containers<0.2 doesn't come with ghc-6.10, but Data.Map changed its interface)
03:39:53 <lambdabot> Consider it noted.
04:06:53 <hoknamahn> guys how (==) implemented in prelude for example for Int?
04:07:32 <opqdonut> ?src Int (==)
04:07:32 <lambdabot> (==) = eqInt
04:07:35 <opqdonut> :)
04:07:37 <opqdonut> builtins
04:07:41 <opqdonut> ?src Int (+)
04:07:41 <lambdabot> Source not found. Sorry.
04:07:53 <opqdonut> ?src Float (/)
04:07:53 <lambdabot> Source not found. I am sorry.
04:08:07 <kaol> @src Num (+)
04:08:07 <lambdabot> Source not found. stty: unknown mode: doofus
04:08:09 <vixey> :t eqInt
04:08:10 <lambdabot> Not in scope: `eqInt'
04:08:51 <hoknamahn> :)
04:10:37 <yewT> hmm
04:18:45 <Baughn> How do I make haddock produce a combined content file, in the style of http://www.haskell.org/ghc/docs/latest/html/libraries/index.html ?
04:18:46 <lambdabot> Title: Haskell Hierarchical Libraries
04:32:15 <hackage> Uploaded to hackage: validate 0.11
04:32:15 <hackage> Uploaded to hackage: validate 0.1
05:38:02 <besiria> what should i experience when i make a function tail recursive?
05:38:11 <besiria> is doens't stack overflows?
05:38:41 <vixey> no
05:38:51 <vixey> don't worry about tail recursion in haskel
05:39:15 <besiria> vixey: why is that?
05:39:19 <vixey> is there something you have with a stack overflow you don't know how to fix?
05:39:38 <vixey> besiria: since lazy evaluation, it works differently to say, scheme
05:40:20 <besiria> vixey: not really. i was trying the trivial factorial example
05:40:46 <vixey> so numbers are a bit weird
05:41:00 <vixey> you can think of every number, 1, 2, 3, ..., as a constructor
05:41:06 <besiria> vixey: but the tail recursive version of factorial seems to be worse in space and time
05:41:06 <vixey> they aren't built from smaller parts
05:41:38 <vixey> whereas something like a list in haskell, it is built up from lots of smaller parts
05:42:06 <ivanm> matthew-_: you around?
05:42:46 <vixey> besiria: that's not because it's tail recurive or not though, that notion isn't a useful way to analyze a haskell code
05:43:11 <vixey> what is the actualy bit of code?
05:43:24 <besiria> http://en.wikibooks.org/wiki/Haskell/Preliminaries
05:44:59 <Baughn> besiria: You need tail-recursion when you're evaluating code inside-out. Haskell evaluates outside-in by default, so it's less than useful. Except when it is.
05:45:35 <vixey> are you talking about this
05:45:35 <vixey> factorial' 0 a = a
05:45:39 <vixey> factorial' 0 a = a
05:45:40 <vixey> factorial' n a = factorial' (n-1) (n*a)
05:45:42 <vixey> this one?
05:45:43 <besiria> y
05:46:00 <vixey> ?
05:46:10 <Baughn> besiria: The factorial function just so happens to be one of the functions that haskell can't evaluate outside-in, so tail recursion is handy. It's a bad example. There are reasons for this.
05:48:17 <Baughn> besiria: http://haskell.org/haskellwiki/Stack_overflow <-- The gritty details
05:48:18 <lambdabot> Title: Stack overflow - HaskellWiki
05:48:36 <vixey> besiria: are you talking about that one?
05:48:38 <Saizan> and, if you make something tail recursive you've to make sure to add strictness to the accumulator
05:49:57 <Baughn> Typically, you'd make it tail-recursive because it's strict to begin with
05:50:01 <ivanm> @ask matthew-_ in graphviz attributes, why does Unknown "foo" "bar" get shown as: "foo"="\"bar\"", rather than: foo=bar or foo="bar" ?
05:50:01 <lambdabot> Consider it noted.
05:50:06 <Baughn> If it's lazy, you'd use head-recursion
05:51:11 <SamB_XP> Baughn: head recursion ?
05:51:26 <Baughn> SamB_XP: So to speak. What foldr does.
05:51:49 <SamB_XP> I've just never heard the term before, I could tell what you meant in context ;-)
05:51:53 <Saizan> Baughn: "guarded recursion" you mean?, however like in factorial' above, (*) is strict, but you're still going to build a big thunk in 'a'
05:52:18 <Baughn> Saizan: True, if the strictness analyzer doesn't pop it
05:52:36 <Baughn> That way, yes. You do have to make sure the /function calls/ also stay strict
05:57:10 <besiria> So, if i'm getting it right, i make a function tail-recursive only if it is strict in its arguments?
05:57:43 <Baughn> besiria: ..to a degree. I suggest you read the page I linked, though.
05:57:59 <Baughn> besiria: The key is actually whether or not it can produce a partial result
05:59:33 <SamB_XP> whether it works on data or codata?
05:59:49 <vixey> haskell only has codata
06:00:34 <besiria> Baughn: read it, thx for the link
06:02:32 <Baughn> vixey: It doesn't distinguish between them, but I still think it has data
06:02:34 <Baughn> 42, say
06:03:03 <vixey> but every data .. = ... you declare, you get back the greatest fixed point
06:03:45 <vixey> it's impossible to observe the difference for non-recursive types like Int .. with 42 in it
06:04:06 <Baughn> That's why I said it doesn't distinguish. ;)
06:04:29 <Baughn> In any case, this has nothing to do with recursion and strictness
06:04:51 <vixey> yeah I wasn't talking about that factorial thing anymor
06:07:11 <Baughn> besiria: The point is that, for a (typical) recursive function that returns (say) a list, or any other data-structure that's broken into parts, it'll typically be able to return just part of the result (the head of the list, say) and then stop, not evaluating the rst
06:07:26 <ivanm> in my .cabal file, how do I specify that it requires a package version of x.y.* ?
06:07:57 <Baughn> besiria: For this to work, you need what i called "head-recursion" - a recursive function that looks like "foo : recurse bar", which is the dual of tail-recursion
06:08:12 <ivanm> ahh, found it, ==x.y.*
06:08:12 * SamB_XP wants to see more research on guardedness
06:08:13 <Baughn> ivanm: "build-depends: base < 4, base >= 3", for example
06:08:53 <ivanm> nah, that's not what I wanted
06:08:59 <ivanm> I wanted == x.y.*
06:09:12 <ivanm> does cabal-1.6 require ghc-6.10?
06:10:06 <vixey> SamB_XP: You ever thought of trying out Bove-Capretta for _co_inductive definitions instead of inductive ones?
06:10:15 <Baughn> besiria: The point is that haskell is implemented so that the recursion terminates after getting that first part, and then starts back up when you ask for the next one, but with a fresh stack. There are a whole lot more subtleties, but that's the basic idea.
06:10:46 <Baughn> besiria: (Of course the laziness doesn't need to be one-dimensional, that's just lists)
06:11:00 <ivanm> Baughn: maybe you're right...
06:11:25 <ivanm> hackage just shows it differently :s
06:11:37 <Baughn> ivanm: What you're asking for is, iirc, something that got added very recently. Maybe even in cabal 1.6.. anyhow, something that should be in ghc 6.10
06:12:07 <ivanm> *nod*
06:19:24 <Saizan> ivanm: Cabal still supports ghc-6.6, iirc
06:19:40 <Deewiant> even 6.4
06:23:04 <ivanm> Saizan: *nod*
06:32:16 <hackage> Uploaded to hackage: SourceGraph 0.2
06:32:16 <hackage> Uploaded to hackage: Graphalyze 0.4
06:36:27 <mc__> : adds an element to the beginning of a list, is there a way to add an element to  the ending of the list (besides simply doing reverse before)
06:36:39 <vixey> yes you can use ++ [x]
06:36:58 <EvilTerran> but, that's not very efficient
06:37:02 <kaol> Data.DList can be useful
06:37:08 <vixey> it is perfectly efficient
06:37:09 <EvilTerran> so, depending on what you're after, you may want to use a Data.Sequence.Seq
06:37:12 <EvilTerran> (or a DList)
06:37:33 <mc__> I just want to append one character, nothing fancy, performance does not matter at all
06:40:21 <MarcWeber> I don't see why elc_1 isn't elc in this case.. http://rafb.net/p/HQJsZx69.html . the type of c should be determined by (PT c) which is named elc_ (line 7). The same var is called elc  (line 20) which should match elc in line 17.. What's going wrong here?
06:40:22 <lambdabot> Title: Nopaste - No description
06:47:07 <hoknamahn> guys what is analog to "\n" in haskell?
06:47:14 <mauke> "\n"
06:47:25 <hoknamahn> for show?
06:47:31 <mauke> what
06:47:48 <hoknamahn> say i want to do show 5 ++ "\n" ++ show 6
06:47:54 <mauke> ok
06:48:07 <vixey> > show 5 ++ "\n" ++ show 6
06:48:09 <lambdabot>   "5\n6"
06:48:10 <MarcWeber> hoknamahn: That's perfect what you have written, which failure do you get?
06:48:30 <MarcWeber> hoknamahn: There is another way: unlines [ show 5, show 6] don't know which you prefer
06:48:56 <mauke> no, it's intersperse '\n' [show 5, show 6]
06:49:09 <hoknamahn> i've got "5\n6"
06:49:15 <mauke> not sure about the types there; maybe I mean intercalate
06:49:35 <MarcWeber> > unlines [ show 5, show 6]
06:49:36 <lambdabot>   "5\n6\n"
06:49:53 <hoknamahn> okay works perfect
06:50:15 <hoknamahn> was confused by ghci :)
06:52:54 <Saizan> MarcWeber: what's the definition for PT?
06:53:13 <MarcWeber> data PT a b = PT b -- phantom type containing state a and the result b
06:56:30 <eu-prleu-peupeu> hello ppl from planet haskell
06:57:10 <clanehin> eu-prleu-peupeu: hi
06:58:01 <eu-prleu-peupeu> check out this amazin iphone comparison: http://i176.photobucket.com/albums/w185/sara87_bucket/difference-1.jpg
06:58:02 <lambdabot> http://tinyurl.com/3t9v6n
07:01:07 <ivanm> eu-prleu-peupeu: no, planet haskell is at planet.haskell.org
07:01:10 <ivanm> ;-)
07:27:26 <mib_ttfuvna3> > 1+1
07:27:27 <lambdabot>   2
07:27:37 <hoknamahn> 2+3
07:27:42 <yewT> > 2+3
07:27:43 <lambdabot>   5
07:27:44 <hoknamahn> > 2+3
07:27:46 <lambdabot>   5
07:27:57 <yewT> hey guys, what is a predicate in haskell terms?
07:30:23 <xerox> ?type comparing
07:30:24 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
07:30:48 <yewT> xerox sounds like a brand
07:30:57 <yewT> how do i apply where?
07:30:59 <yewT> some a = show(p where p a = a+1) ???
07:31:24 <xerox> just delete the parens
07:31:45 <xerox> optionally carriage return after show p and indent where p a = a+1 on the next line
07:32:14 <yewT> i deleted the parensthesis, but it still does not work
07:32:32 <xerox> the problem is that p is a function, and show doesn't know how to show functions
07:32:48 <xerox> you probably want to define some a = show (p a)
07:32:57 <yewT> oh ok
07:33:03 <yewT> some a = show p where p = a+1
07:33:57 <xerox> that works too
07:34:32 <yewT> xerox pro in haskell?
07:35:39 <MarcWeber> Saizan: You don't have any clue either, do you..
07:38:10 <yewT> @hoogle String -> Int
07:38:10 <lambdabot> Prelude read :: Read a => String -> a
07:38:11 <lambdabot> Text.Read read :: Read a => String -> a
07:38:11 <lambdabot> Prelude error :: String -> a
07:38:20 <yewT> @hoogle String -> Bool
07:38:20 <lambdabot> Distribution.PackageDescription flagDefault :: Flag -> Bool
07:38:20 <lambdabot> System.FilePath.Posix hasDrive :: FilePath -> Bool
07:38:20 <lambdabot> System.FilePath.Windows hasDrive :: FilePath -> Bool
07:39:05 <yewT> @hoogle (String -> Bool)
07:39:05 <lambdabot> Distribution.PackageDescription flagDefault :: Flag -> Bool
07:39:05 <lambdabot> System.FilePath.Posix hasDrive :: FilePath -> Bool
07:39:05 <lambdabot> System.FilePath.Windows hasDrive :: FilePath -> Bool
07:39:29 <yewT> @hoogle (String -> Boolean)
07:39:29 <lambdabot> Warning: Unknown type Boolean
07:39:29 <lambdabot> Prelude error :: String -> a
07:39:29 <lambdabot> Debug.Trace trace :: String -> a -> a
07:41:23 <QuietPurple> sorry, this is a really basic question, but how do i make haskell work out fractional powers? 2 ^ (1/12) doesn't work because it gets confused with types
07:41:51 <hoknamahn> **
07:41:56 <hoknamahn> 1 ** 0.5
07:42:02 <QuietPurple> ok
07:42:16 <hoknamahn> > 2 ** 1.5
07:42:17 <lambdabot>   2.8284271247461903
07:42:17 <vixey> > 2 ** (1/12)
07:42:18 <lambdabot>   1.0594630943592953
07:42:19 <QuietPurple> that i have not seen, thanks!
07:42:36 <vixey> > 1.0594630943592953 ** 12
07:42:37 <lambdabot>   2.000000000000001
07:47:33 <yewT> could someone create an example of ABC :: Int -> (Int->String) -> Int -> Int ?
07:48:05 <mauke> no, because ABC is not a valid variable name
07:48:20 <yewT> i wanna see how does a function imports another function with (Int -> String)
07:48:24 <Deewiant> ?djinn Int -> (Int -> String) -> Int -> Int
07:48:24 <lambdabot> Error: Undefined type Int
07:48:27 <vixey> :t undefined :: Int -> (Int->String) -> Int -> Int
07:48:28 <lambdabot> Int -> (Int -> String) -> Int -> Int
07:48:37 <Deewiant> ?djinn a -> (a -> b) -> a -> a
07:48:37 <lambdabot> f _ _ a = a
07:48:38 <yewT> abc :: Int -> (Int->String) -> Int -> Int ?
07:48:42 <vixey> :t (\i is j -> undefined) :: Int -> (Int->String) -> Int -> Int
07:48:43 <lambdabot> Int -> (Int -> String) -> Int -> Int
07:48:49 <vixey> :t (\i is j -> j + length is i) :: Int -> (Int->String) -> Int -> Int
07:48:50 <lambdabot>     Couldn't match expected type `[a]'
07:48:50 <lambdabot>            against inferred type `Int -> String'
07:48:50 <lambdabot>     In the first argument of `length', namely `is'
07:49:04 <vixey> :t (\i is j -> j + length (is i)) :: Int -> (Int->String) -> Int -> Int
07:49:05 <lambdabot> Int -> (Int -> String) -> Int -> Int
07:49:18 <Botje> AAAAH! TYPE SPAM!
07:49:25 <mauke> :t let abc n f i = n + length (f i) in abc
07:49:26 <lambdabot> forall t a. Int -> (t -> [a]) -> t -> Int
07:53:11 <yewT> mauke
07:53:20 <yewT> mauke could you explain me the code that you have written/.
07:53:28 <yewT> mauke:: me could not understand o_o
07:53:41 <mauke> is this you again?
07:54:20 <Botje> what part of the function don't you get?
07:56:13 <vixey> http://micah.cowan.name/2008/10/10/computers/software-development/adventures-in-haskell-part-2-kewlness/
07:56:15 <lambdabot> Title: micah.cowan.name Â» Adventures in Haskell, Part 2: Kewlness, http://tinyurl.com/3usbp4
07:56:20 <vixey> "The difference is that the Perl example will happily try to take a 5GB file and shove it all into memory (or, much more likely, make the attempt and choke), whereas the Haskell version, which looks nearly identical, will process input a bit at a time"
07:56:24 <vixey> is that true?
07:56:40 <vixey> Why does all these newbies complain they have log parsers which stack overflow
07:56:46 <vixey> I don't think haskell has any advantage over perl in here
07:56:58 <mauke> vixey: lazy IO
07:57:17 <mauke> @src hGetContents
07:57:17 <lambdabot> Source not found. It can only be attributed to human error.
07:57:20 <mauke> :-(
07:57:20 <yewT> botje: i dont understand the part where he states length((f i)
07:57:28 <vixey> unable to extract meaning ...
07:57:37 <Samy> lazy evaluation
07:57:52 <mauke> vixey: hGetContents doesn't give you a real list
07:58:07 <mauke> vixey: accessing the list elements causes read() calls to happen on the fly
07:58:12 <vixey> I know what hGetContents does but I still think this program will choke on a 5GB file
07:58:25 <mauke> why?
07:58:42 <vixey> I'm basing that on all the times people have come in here like "Argh I can't make a log parser in haskell help" and posted some code that looks exactly like that
07:58:53 <mauke> the GC should be able to clean up after putStr
07:59:28 <vixey> but does it in reality
07:59:33 <Botje> yewT: well, f is of type Int -> String
07:59:44 <Botje> so if you give it an Int (i)
07:59:49 <Botje> you get back a String
07:59:57 <mauke> vixey: trying it on /dev/urandom ...
08:00:00 <Botje> but String is really just [Char]
08:00:14 <Botje> so you can feed that to length :: [a] -> Int
08:00:35 <mauke> vixey: seems to run in constant memory
08:00:55 <mauke> and 98% CPU, of course
08:01:50 <Botje> oh noes, 2% cpu is wastedd
08:01:54 <vixey> same as perl
08:01:58 <Botje> call the ghc wastebusters :)
08:02:00 <vixey> perl test.pl < /dev/urandom
08:02:22 <mauke> I find this hard to believe
08:03:12 <mauke> most of perl's time is spent in syscalls
08:03:13 <Samy> stdin
08:03:19 <mauke> already at 15% MEM
08:03:34 <mauke> 20
08:03:51 <mauke> I killed it
08:03:59 <Samy> 11M - 37M
08:04:03 <Samy> 63M
08:04:38 <yewT> botje
08:05:11 <yewT> botje: how do i use let abc n f i = n + length (f i) in abc
08:05:20 <yewT> what value should i input in n f i
08:05:42 <Botje> uh .. whatevver you want to calculate with that?
08:05:45 <yewT> i wanna test the code
08:05:55 <yewT> could you give a sample values
08:06:06 <papermachine> When I tried to get perl to slurp /dev/urandom, it blocked forever, essentially
08:06:10 <mauke> 0 show 0
08:06:20 <Axman6> abc 10 show (Just 10000)
08:06:37 <yewT> axman6, are you talking to me?
08:06:43 <Axman6> yes
08:06:48 <vixey> I don't see anyone else around here
08:06:54 <Botje> giggle
08:06:54 <yewT> oh, put my name :) so i know
08:07:09 <Botje> only us chickens.
08:07:42 <yewT> axman6, could you provide another sample value?
08:08:05 <mauke> abc 10 show (Just 10001)
08:08:26 <yewT> with different function?
08:08:29 <Botje> yewT is draining the entropy of this channel!
08:08:31 <Axman6> abc 10 show (Just $ 3958723^9834758913)
08:08:39 <vixey> lol
08:08:41 <yewT> so this code can only use show?
08:08:47 <yewT> not any other functions?
08:08:48 <Axman6> @hoogle a -> String
08:08:49 <lambdabot> Distribution.Text display :: Text a => a -> String
08:08:49 <lambdabot> Prelude show :: Show a => a -> String
08:08:49 <lambdabot> Text.Show show :: Show a => a -> String
08:09:21 <Botje> let f 1 = "one"; f 2 = "two"; f _ = "many" in abc 123 f 2
08:10:03 <mauke> abc 10 (const "") (Just 10000)
08:10:19 <Axman6> @hoogle -> String
08:10:19 <lambdabot> Parse error:
08:10:20 <lambdabot>   --count=20 "-> String"
08:10:20 <lambdabot>              ^
08:10:24 <Axman6> fail
08:10:32 <vixey> @hoogle " ; rm *
08:10:32 <lambdabot> Parse error:
08:10:32 <lambdabot>   --count=20 "" ; rm *"
08:10:32 <lambdabot>              ^
08:11:39 <yewT> botje is draining the entropy of this channel! what do you mean by that?
08:12:03 <Botje> you're asking us for random numbers and functions
08:12:15 <Botje> thereby decreasing the total amount of randomness present
08:12:24 <Botje> it was a joke
08:12:34 <yewT> what is randomness present?
08:12:37 <vixey> you know there is actualy #random on freenode
08:12:44 <Botje> heh
08:12:50 <vixey> it's got a bot that gives you entropy
08:12:59 <Botje> cool :)
08:13:13 <yewT> i was thinking about creating my own custom function to replace show
08:13:22 <Botje> taking randomness from several big channels on irc would be a cool idea
08:13:27 <yewT> but needed to see how people make 1
08:13:31 <yewT> show isn't it inbuilt?
08:13:42 <Botje> "why are you running IRC on government property?" "randomness!"
08:13:46 <Botje> yewT: sure it is
08:13:57 <vixey> not clear what inbuilt mens
08:14:23 <Samy> vixey, no it doesn't ;[
08:14:30 <Samy> wrt #random
08:15:51 <Botje> i wonder if data.reactive would be a serious contender to POE
08:16:30 <chrisdone> there's a #hope channel with a bot that gives you lies
08:16:46 <Botje> bwahaha
08:16:51 <mauke> preflex: version
08:16:51 <preflex>  8.817
08:16:56 <mauke> here, have some entropy
08:16:57 <Botje> aare there more such channels?
08:17:16 <mauke> preflex: version
08:17:16 <preflex>  3.961
08:17:44 <vixey> preflex: be PoppaVic
08:17:44 <preflex>  C is one of those things that expects "miles", rather than "hours".
08:17:48 <vixey> @quote farber
08:17:49 <lambdabot> No quotes match. stty: unknown mode: doofus
08:17:53 <yewT> hmm hey guys , is abc n f i is same as abc n (f i) ?
08:17:54 <vixey> @farber
08:17:54 <lambdabot> Don't leave the nest that feeds you.
08:17:57 <vixey> preflex: be PoppaVic
08:17:57 <preflex>  yer back to that Ultimate Interface. I don't control it. And terms are bandied about all over where you need to ask and research.
08:17:59 <vixey> @farber
08:17:59 <lambdabot> They fell all over their faces.
08:18:06 <vixey> preflex: be PoppaVic
08:18:06 <preflex>  I said what I meant: you expect others to save you and ridicule me, (which is fine), but now pick yer GOD.
08:18:06 <yewT> abc n f i = abc n (f i ) ?
08:18:07 <vixey> @farber
08:18:07 <lambdabot> How old is your 2-year old?
08:18:18 <mauke> yewT: no
08:18:29 <mauke> abc n f i is parsed as ((abc n) f) i
08:18:35 <vixey> preflex: be PoppaVic
08:18:35 <preflex>  you know? I think is another context where you share an interface. How many wrenches you own? Metric? Ansi? blind? Ever rivet or weld?
08:18:43 <vixey> @farber
08:18:43 <lambdabot> It's a travesty on the face of the void.
08:18:56 <yewT> thanks mauke, because i reemmbered once i used 2 variables, f i , f is a function and i is variable
08:21:19 <Botje> g
08:22:50 <yewT> read x < (5.0::Double)
08:22:54 <yewT> read x < (5.0 :: Double)
08:24:51 <vixey> read x < (5.0  ::  Double)
08:24:58 <vixey> read x < (5.0   ::   Double)
08:25:20 <mauke> e  x  c  u  s  e     m  e     w  t  f     r     u     d  o  i  n
08:25:37 <yewT> mauke
08:25:41 <vixey> mauke lol
08:25:42 <yewT> mauke who are you talking to?
08:25:45 <yewT> :t read
08:25:46 <lambdabot> forall a. (Read a) => String -> a
08:26:03 <yewT> weird, i typed :t read in ghci, but it does not show this
08:26:17 <Botje> are you sure it's ghci? :P
08:26:21 <mauke> what does it show?
08:26:25 <chrisdone> it probably misses out the for all a.
08:26:48 <chrisdone> > :t read
08:26:48 <chrisdone> read :: (Read a) => String -> a
08:26:48 <lambdabot>   <no location info>: parse error on input `:'
08:26:57 <yewT> read :: Read a => String -> a
08:27:11 <yewT> sorry, i type :t read inside a .hs file that is not working -_-"
08:27:22 <chrisdone> the `forall a.' is implicit there
08:27:44 <Baughn> yewT: The parantheses are optional when there's just a single class constraint
08:30:17 <chrisdone> < PoppaVic> if yer dealing with millions of files, yer just wrong.
08:30:23 <yewT> let abc n f i = n + length (f i) in abc
08:30:32 <yewT> im still puzzled with the f, is f a function o_o
08:30:41 <vixey> yewT: Why
08:31:21 <BONUS> yeah its a function
08:31:33 <BONUS> i is applied to it, isnt it
08:31:37 <orbitz> chrisdone: http://ortdotlove.net/poppavic_wisdom.html
08:31:38 <lambdabot> Title: Words of Wisdom from PoppaVic
08:31:53 <Deewiant> > "\        \a"
08:31:54 <lambdabot>   "a"
08:31:59 <Deewiant> wow, that was new
08:32:21 <mauke> preflex: quote PoppaVic
08:32:21 <preflex>  <PoppaVic> You likely don't understand "shooting"., "reloading" or "cooking" - let alone C. I don't play executioner
08:32:38 <vixey> preflex be PoppaVic
08:32:38 <preflex>  You likely don't understand "shooting"., "reloading" or "cooking" - let alone C. I don't play executioner
08:32:40 <vixey> preflex be PoppaVic
08:32:40 <preflex>  yeah, Ia am always amazed how come I am at blame when I've a dozen other I respect that understand. What YOU want is that I agree. I don't. That's fine - it's all yers - but don't play yer shit and sneak in nazi headspace.
08:32:43 <yewT> but length only accepts 1 argument, example: length "abc" = 3, but how does it take length f i
08:32:53 <yewT> but length only accepts 1 argument, example: length "abc" = 3, but how does it take length (f i)
08:33:17 <Baughn> (f i) is a single argument
08:33:20 <mauke> yewT: (f i) returns one value, which is then passed to length
08:33:37 <vixey> yes (f i) is evaluated first and the result is passed into length :P
08:33:50 <BONUS> length (f i) is not the same as length f i or (length f) i
08:33:54 <yewT> ok, so what is the content of f? i don't see anything define in f
08:33:56 <Baughn> ..or that's how it'd work in a strict language. ^_^
08:34:12 <yewT> usually like f = (something something)
08:34:17 <Baughn> yewT: ..well, it's not exactly going to work if you don't define f
08:34:27 <Baughn> It's just a metasyntactic variable
08:34:52 <yewT> metaynstatic?
08:35:02 <Baughn> foo, bar, f, etc.
08:35:37 <Baughn> ..mind you, this being #haskell, there's at least an even chance that a random inhabitant has at some point called a function "f".
08:35:53 <vixey> f is a function
08:36:34 <yewT> is it possible that i define a function outside this function (where the user usually input values) ?
08:37:04 <yewT> meaning that the user inputs the function along with the Int values into this let and in
08:37:05 <Baughn> yewT: Users don't usually use the ghci prompt; programmers do. But sure, you can do that.
08:37:08 <Deewiant> argh at gtk2hs's configure script
08:37:10 <Deewiant> checking for the GHC package "mtl"... yes, version 1.1.0.1nmtl-1.1.0.2
08:42:12 * shapr boings
08:42:56 * chrisdone sneaks in shapr's nazi headspace
08:44:44 <yewT> > read "apple"::Int
08:44:46 <lambdabot>   * Exception: Prelude.read: no parse
08:44:49 <yewT> > read "12"::Int
08:44:50 <lambdabot>   12
08:44:58 <yewT> why apple wont work?
08:45:12 <Twey> ... because it's not a number
08:45:26 <mauke> yewT: what would you expect it to do?
08:45:27 <yewT> so read is only for number words?
08:45:38 <Baughn> yewT: It is when you tell it it is
08:45:45 <Baughn> yewT: What do you think the (:: Int) part means?
08:45:46 * Botje just noticed yewT is Twey spelled backwards.
08:45:54 <yewT> change it into and Int?
08:46:02 <pozic> > read "True"::Bool
08:46:03 <lambdabot>   True
08:46:05 <Twey> Right
08:46:09 <pozic> yewT: does that help?
08:46:10 <vixey> helllooo
08:46:11 <Twey> And what is the integer value of "apple"?
08:46:13 <Baughn> yewT: No. Type tags constrain the type, they don't change anything.
08:46:23 <Twey> vixey: Hellllllooooooo
08:46:41 <vixey> today is boring I wish it was monday
08:46:41 <Deewiant> Baughn: well, it changes it to something more constrained. :-P
08:46:42 <yewT> are there any other uses of read?
08:46:42 <Botje> ooh
08:46:46 <Botje> time to close down
08:46:52 <Botje> pc is free!
08:46:55 <Baughn> yewT: read is part of a type-class; it has many implementations. Which one gets picked depends on which type it's constrained to be.
08:47:00 <chrisdone> Twey: 24 billion?
08:47:07 <yewT> instead of changing "12" into 12
08:47:09 <Twey> Haha
08:47:28 <Twey> yewT: It's a fully-fledged parser.
08:47:39 <Twey> You can show and read complex datatypes.
08:47:44 <Baughn> > read [12,13,4.2] :: [Double]
08:47:45 <lambdabot>       No instance for (Fractional Char)
08:47:45 <lambdabot>        arising from the literal `4.2'...
08:47:54 <Baughn> > read "[12,13,4.2]" :: [Double] -- Whoops
08:47:56 <lambdabot>   [12.0,13.0,4.2]
08:48:05 <Twey> Hehe
08:48:50 <Baughn> > read "fromList [(1,2),(3,4)]" :: Map Int Int
08:48:51 <lambdabot>   Not in scope: type constructor or class `Map'
08:48:57 <Baughn> > read "fromList [(1,2),(3,4)]" :: M.Map Int Int
08:48:58 <lambdabot>   /tmp/8201377186914569321:67:81:
08:48:58 <lambdabot>      Not in scope: type constructor or clas...
08:49:08 * Baughn pouts
08:49:34 <vixey> > fromList [(1,2),(3,4)]
08:49:35 <lambdabot>   Not in scope: `fromList'
08:49:39 <vixey> > M.fromList [(1,2),(3,4)]
08:49:40 <lambdabot>   /tmp/495675232314631305:67:48: Not in scope: `M.fromList'
08:49:44 <vixey> > Map.fromList [(1,2),(3,4)]
08:49:45 <lambdabot>   fromList [(1,2),(3,4)]
08:49:58 <vixey> so basically read sucks
08:50:05 <Baughn> > read "fromList [(1,2),(3,4)]" :: Map.Map Int Int
08:50:06 <lambdabot>   fromList [(1,2),(3,4)]
08:50:34 <Baughn> Nah, it's handy. I use it a lot.
08:50:46 * Twey nods.
08:50:49 <Twey> Free serialiser!
08:50:59 <Baughn> It's like an ill-mannered, inefficient friend of Binary
08:51:06 * Twey laughs.
08:51:32 <vixey> I think I never used read
08:51:46 <chrisdone> I use read for configuration files >_>
08:51:47 <vixey> it's got this artifical separation of data vs code which I don't like
08:52:20 <pozic> read in Haskell is read from Lisp
08:52:25 <pozic> I don't see what you mean.
08:52:28 <vixey> no it's not
08:52:31 <Baughn> vixey: Well, what would you use instead?
08:52:31 <pozic> Yes, it is.
08:52:42 <agcorona> what do you use? eval?
08:52:46 <vixey> for what Baughn
08:52:46 <pozic> It's just that you cannot read functions.
08:52:57 <Baughn> vixey: Serialization
08:53:07 <vixey> I don't know
08:54:14 <agcorona> you can use eval (from haskell plugins) to read data & functions
08:54:25 <Baughn> Well, you have to be using _something_, if you're using haskell for anything at all
08:54:37 <vixey> I don't really serialze stuff from haskell
08:54:47 <vixey> I'm not even sure what that means
08:55:03 <vixey> printing out XML or something
08:55:04 <vixey> ?
08:55:07 <Baughn> "Store data for later use in another program invocation", thank you
08:55:18 <Baughn> Or "transfer data across a network"
08:55:52 <agcorona> It is possible to define a data type Lambda f= Lambda String f, and you can make it member of the class Show  using hs plugins
08:56:31 <Baughn> Actual automatic function serialization will have to wait for dynamic loading to be fixed, though
08:56:35 <vixey> for data across network it dependns on the protocol
08:56:46 <vixey> I would really doubt there is an RFC around which fits with deriving Read/Show
08:56:55 <vixey> so I wouldn't be using it in that circumstance
08:57:49 <Baughn> Plus it'd be inefficient. It's true, I always use Binary for networks.
08:57:58 <agcorona> yes you can. In Lambda String f,   string can store the string representation of the function that you previously loaded trough "eval"
08:58:26 <agcorona> when you do show(Lambfa s f)= s
08:58:33 <agcorona> itÅ simple
08:58:44 <chrisdone> how would you save a configuration like this to file for later reading? http://chrisdone.com/80-10-12%20Kibro%20refactoring#fnref3
08:58:56 <chrisdone> I used Show/Read because it's easy
08:59:21 <agcorona> you can not modify the function and write the result , like in lisp
09:00:47 <agcorona> automatic function serialization is only possible in languages where data representation and code representation are the same
09:00:54 <agcorona> like in lisp
09:01:12 <vixey> agcorona: it's done in Oz isn't it? which isn't homoiconic
09:01:34 <agcorona> but haskell uses binary representation for code, and linked objects for data
09:02:51 <agcorona> I suppose that the effort becomes more difficult when both representations differ
09:02:52 <yewT> @hoogle Int -> String
09:02:53 <lambdabot> Language.Haskell.TH tupleDataName :: Int -> Name
09:02:53 <lambdabot> Language.Haskell.TH tupleTypeName :: Int -> Name
09:02:53 <lambdabot> Language.Haskell.TH.Syntax tupleDataName :: Int -> Name
09:03:00 <yewT> o_o
09:03:20 <yewT> if i have a list of Int . example [1,2,3,4,5] and i want to feed it into read x :: Int, is it possible?
09:03:22 <dmwit__> chrisdone: For the most part, I think Show/Read is really quite fine.
09:03:40 <dmwit__> chrisdone: Unless you are actually hitting a performance bottleneck...?
09:03:47 <yewT> read x only takes in string argument, is there a function to convert those number into string?
09:04:00 <vixey> yewT: wwtf
09:04:01 <BONUS> uh, what do you want to accomplish, anyway?
09:04:02 <vixey> yewT: Why
09:04:07 <dmwit__> chrisdone: One advantage is that anybody who uses Haskell will instantly know how to read and write your configuration files.
09:04:08 <yewT> map([1,2,3,4,5])"" ?
09:04:21 <vixey> yewT what
09:04:32 <mauke> any sufficiently advanced stupidity is indistinguishable from trolling
09:04:34 <BONUS> > map read ["1","2","3","4","5"] :: [Int]
09:04:35 <lambdabot>   [1,2,3,4,5]
09:04:54 <dmwit> > read ([1..5] >>= show) :: Int
09:04:56 <lambdabot>   12345
09:05:08 <dmwit> But better is:
09:05:35 <dmwit> > foldr (\a b -> 10*a + b) 0 [1..5]
09:05:36 <lambdabot>   150
09:05:39 <dmwit> er
09:05:41 <dmwit> :t foldr
09:05:42 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
09:06:08 <vixey> > foldr (\a b -> 10*b + a) 0 (reverse [1..5])
09:06:09 <lambdabot>   12345
09:06:16 <dmwit> Yeah, we want foldl.
09:06:26 <dmwit> > foldl' (\a b -> 10*a + b) 0 [1..5]
09:06:28 <lambdabot>   12345
09:06:43 <yewT> hmm..
09:06:46 <vixey> foldr f (reverse l) = foldl (flip f) l
09:07:45 <yewT> actually, i need to use this function a x = read a x < (5::Int) so i could select 1 portion of the record
09:07:47 <agcorona> foldr (\b a -> 10*b + a) 0  [1..5]
09:08:10 <dmwit> > sum . zipWith (\a b -> 10^a*b) [0..] . reverse $ [1..5]
09:08:11 <lambdabot>   12345
09:08:20 <Deewiant> vixey: needs moar reverse
09:08:33 <agcorona> foldr (\a b -> 10*b + a) 0  [1..5]
09:08:38 <yewT> the user defines the number, example (5:Int) so it only selects records below 5
09:08:39 <dmwit> Deewiant: Nah, just needs more base cases.
09:09:00 <Deewiant> hmm, right
09:09:02 <Deewiant> my bad
09:09:38 <vixey> yewT: Maybe you should do a tutorial
09:09:50 <yewT> what kind of tutorial?
09:09:55 <vixey> haskell
09:10:08 <yewT> o_o
09:10:37 <BONUS> maybe i can interest you in www.learnyouahaskell.com
09:10:46 <BONUS> its not yet finished, but it should be enough reading material for the time being
09:10:55 <BONUS> :]
09:11:02 <dmwit> yewT: I've already pointed you at several good tutorials.
09:11:07 <pozic> BONUS: OMG
09:11:14 <BONUS> what O_O
09:11:20 <pozic> Maximum awesome!
09:11:26 <dmwit> ?where YAHT
09:11:26 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
09:11:27 <BONUS> :)
09:11:29 <pozic> BONUS: It sounds like a joke!
09:11:30 <dmwit> ?where RWH
09:11:31 <lambdabot> is http://www.realworldhaskell.org/blog/
09:11:50 <BONUS> hehe
09:11:51 <vixey> ?where+ LYAH www.learnyouahaskell.com
09:11:52 <lambdabot> It is stored.
09:11:56 <BONUS> w00t
09:12:22 <mauke> preflex: store lyah http://learnyouahaskell.com/
09:12:27 <vixey> BONUS: by the way I don't know if it's a problem with web or what
09:12:29 <lambdabot> Title: Learn You a Haskell for Great Good!
09:12:36 <pozic> BONUS: you could have a chapter named "Kicking oneself in the Haskell!" with an introduction to unsafePerformIO.
09:12:47 <BONUS> haha!
09:12:47 <yewT> hmm
09:12:48 <vixey> BONUS: but you know when a page loads, and you're scrolled half way down.. the loading of the images makes it jerk around
09:12:58 <BONUS> hmmm i'll look into that
09:13:01 <vixey> BONUS:is it possible to store the image sizes in HTML or something?
09:13:09 <dmwit> yep
09:13:09 <BONUS> yeah of course duh
09:13:12 <BONUS> i totally forgot that
09:13:12 <vixey> BONUS: do you know the thing I mean though?
09:13:15 <BONUS> yeah
09:13:21 <BONUS> i'll add the width and heights in the markup
09:13:29 <BONUS> so it doesnt move around while loading
09:13:32 <vixey> BONUS: well I think everyone forgets this so I wasn't sure if it's actually possible
09:13:41 <yewT> does anyone understand this? "Price" p $ Table where p x = read x < (5:Int) .... i don't understand the logic
09:13:46 <BONUS> thanks for noticing that, i usually review it on localhost, so i dont notice that issue
09:14:23 <mauke> yewT: there are several errors in that line
09:14:29 <chetxz> exit
09:15:18 <yewT> ?? what are the errors mauke?
09:15:19 <lambdabot> Plugin `compose' failed with: Unknown command: ""
09:15:36 <mauke> yewT: "Price" is not a function; you can't apply it to p
09:15:41 <mauke> (5:Int) is a syntax error
09:16:00 <mauke> or maybe it's just a "data constructor Int not in scope" error
09:16:07 <yewT> (5::Int) i forgot the extra colon
09:16:28 <dmwit> Your friendly neighborhood compiler will tell you theses things, too, more quickly and more reliably than mauke possibly can.
09:16:32 <mauke> if we ignore the "Price" part, we get p $ Table, which is wrong because Table is not a String
09:17:07 <yewT> its actually like this, i have a record that has "brand" "price" "popularity", the user sets "price" meaning that he selects the price category
09:17:17 <yewT> so the read x thingy will based on price
09:17:37 <yewT> so if i have prices 1-100, and user sets it as read x < 50, it only display items below price 50
09:17:52 <yewT> but the thing i don't get it is why p $ Table
09:18:02 <mauke> you sound like a PHP user
09:18:26 <yewT> php uses $$$$
09:18:37 <BONUS> lol
09:18:42 <yewT> so im still puzzled
09:18:58 <BONUS> the $ in haskell means something completely different than the $ in php
09:19:12 <BONUS> think of $ as extending a parantheses all the way to the right
09:19:25 <yewT> my p only accepts string when user is required to input "Price"p $ Table where p x = read x < (50::Int)
09:19:26 <BONUS> so foo $ bar blah is kind of like foo (bar blah)
09:20:02 <yewT> bonus, do you mean "Price" p(Table) or "Price"p (Table where p x = read x < (50::Int))
09:20:23 <mauke> wtf
09:20:35 <vixey> I'm so bored I might read a newsgroup :/
09:20:35 <yewT> extend all the way to the right o_o
09:20:47 <yewT> vixey could help me out :/
09:20:59 <vixey> yewT: sure have you read yourself a haskell yet?
09:21:04 <vixey> ?where LYAH
09:21:04 <lambdabot> www.learnyouahaskell.com
09:21:07 <yewT> i read some
09:21:17 <vixey> yewT: this is great actually, BONUS just wrote it
09:21:26 <BONUS> yeah, im in the process of writing it
09:21:28 <vixey> yewT, anyway this is my first suggestion, to read this
09:21:28 <yewT> bons wrote yaht?
09:21:32 <BONUS> and drawing it
09:21:41 <yewT> bonus wrote yaht?
09:21:45 <BONUS> yes
09:21:47 <vixey> LYAH
09:21:49 <BONUS> no not yaht
09:21:49 <vixey> not YAHT
09:21:50 <BONUS> LYAH
09:21:51 <BONUS> haha
09:21:52 <mauke> yes, "bons wrote yaht"
09:21:54 <yewT> oh
09:22:04 <vixey> @remember yewT bons wrote yaht
09:22:04 <lambdabot> Okay.
09:22:06 <BONUS> haha im lolling atm
09:22:08 <mauke> paying attention to what you're doing is not required when programming
09:22:44 <BONUS> anyway, yewT, i'd suggest just taking it from the start with Haskell and gradually working your way up
09:22:51 <BONUS> and forget almost everything you know from PHP and the like
09:22:52 <yewT> ok
09:23:07 <yewT> umm the user is required to input that
09:23:15 <yewT> and i need to create a function for it to work
09:23:18 <shapr> jiihaa
09:23:23 <yewT> you see?
09:23:27 <vixey> shapr~
09:23:27 <mauke> yewT: no
09:23:31 <vixey> muu
09:23:34 * shapr hugs vixey
09:23:37 * vixey hug
09:23:43 <shapr> How's code vixey?
09:23:48 <vixey> Hard!
09:23:59 <shapr> What are you writing?
09:23:59 <vixey> It's really difficult
09:24:15 <vixey> trying to get a nice way to do dependent pattern matching
09:24:25 <vixey> something mechanical and generic ..
09:24:30 <yewT> mauke no?
09:25:06 <mauke> yewT: why are you trying to write a program in haskell?
09:25:08 <yewT> @forget vixey shapr~
09:25:08 <lambdabot> No match.
09:25:10 <vixey> & you? how goes
09:25:37 <yewT> mauke : to solve the problem?
09:25:44 <shapr> Almost no code lately, just other life stuff instead.
09:25:46 <mauke> yewT: what problem?
09:25:48 <shapr> Lots of guitar.
09:25:55 <yewT> i have presented the problem above
09:25:55 <vixey> ho
09:26:00 <mauke> yewT: no, you haven't
09:26:11 <vixey> I'm going to get my sister to teach me this guitar ting
09:26:12 <vixey> :)
09:26:23 <shapr> vixey: It's fun.. not very algorithmic, but fun.
09:26:59 * Twey does `mapM_ (flip hSetBuffering $ NoBuffering) [stdin, stdout]` and feels guilty.
09:27:07 <shapr> Actually, I wonder how I could use Haskell to write tablature.
09:27:17 <Twey> Hahaha!
09:27:21 <Twey> Nice
09:27:28 <yewT> mauke: does anyone understand this? "Price" p $ Table where p x = read x < (5:Int) .... i don't understand the logic
09:27:30 <maltem> shapr: definitely. You'd wish you could abstract away stupid practice
09:27:39 <mauke> yewT: what logic?
09:27:47 <mauke> yewT: it's not valid Haskell code
09:27:50 <yewT> the user inputs the function name abc along with the inputs
09:27:57 <mauke> yewT: why are you trying to write a program in haskell?
09:28:04 <yewT> mauke: abc  "Price" p $ Table where p x = read x < (5:Int)
09:28:06 <shapr> maltem: I think practice will be around forever, but I would like to write something to produce an 'optimal' tuning for a particular song.
09:28:08 <yewT> abc is the function
09:28:16 <mauke> yewT: is this homework?
09:28:27 <yewT> yea
09:28:37 <shapr> @quote vixey
09:28:38 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
09:28:41 <shapr> argh
09:28:42 <shapr> @quote
09:28:43 <lambdabot> HamiltonRichards says: It's fair to say that functional programming requires a very different mind-set, but once you've made the "jump", programming in conventional languages feels like doing
09:28:43 <lambdabot> arithmetic in Roman numerals.
09:28:45 <dmwit> Oh god oh god, we've been writing his *homework* for him this whole time?
09:28:46 <vixey> I don't say anything interesting
09:29:04 <vixey> @keal
09:29:04 <lambdabot> obviously you never heard of Tier. theoretically it would work using nanobots
09:29:07 * Badger placates dmwit 
09:29:14 <yewT> dmwit: not exactly
09:29:27 <yewT> i have converted them into someting else
09:29:32 <maltem> shapr: while you're at it, do some computational mechanics to find the best guitar for a specific tuning
09:29:33 <vixey> @quote shapr
09:29:33 <lambdabot> shapr says: Windows users are like the wives of alcoholics, they'll take any amount of abuse and come right back.
09:29:43 <shapr> I think it's mostly fine to help people with their homework... either they learn something from it and it helps them, or they fail the test when we're not there.
09:29:45 <shapr> maltem: How would that work?
09:30:13 <maltem> shapr: no idea, ever studied the acoustics of a musical instrument?
09:30:14 <yewT> umm im not asking you to do the homework for me, i just want someone to explain how the logic works
09:30:26 <shapr> maltem: Nope, I've been playing guitar for about three weeks.
09:30:32 <yewT> once i understand the basic of how something works, then i implement them
09:30:37 <vixey> 3 weeks only?!
09:30:43 <shapr> I can only play a few songs, and I have a small range of five or ten chords.
09:30:47 <maltem> shapr: well I suppose there wouldn't be much point in such an analysis :)
09:30:58 <shapr> vixey: Yeah, it's a lot easier than Haskell :-)
09:31:15 <Twey> yewT: Your most obvious error is using `:` instead of `::`.
09:31:33 <BONUS> lol
09:31:35 <yewT> Twey,  i know, but i missed the extra colon
09:31:40 <BONUS> <Twey> yewT:
09:31:52 <BONUS> > reverse "Twey"
09:31:53 <lambdabot>   "yewT"
09:31:58 <shapr> @users
09:31:58 <lambdabot> Maximum users seen in #haskell: 518, currently: 502 (96.9%), active: 10 (2.0%)
09:31:59 * mauke is now known as ÊÇÊÊ
09:32:02 <vixey> BONUS: omg!!!
09:32:04 <shapr> ooh
09:32:08 <ziman> wow
09:32:15 <BONUS> haha
09:32:16 <hackage> Uploaded to hackage: unicode-prelude 0.1.1
09:32:16 <hackage> Uploaded to hackage: panda 2008.10.12
09:32:17 <yewT> the thing now is i dont understand how the logic of this >> abc "Price" p $ Table where p x = read x < (5::Int)
09:32:20 <Twey> Haha, mauke
09:32:24 <Twey> Nice :-P
09:32:31 <shapr> maltem: So, any ideas how I could use Haskell for guitar tools?
09:32:52 <surgeon> hi all, is it possible to do a double map in haskell or do I have to define a recursive function? e.g. map (map +1) [[1,3,4],[2,4,5]]
09:32:54 <dmwit> vixey: Yup, when Cale told him to pick a nick last night, he went for elac. =P
09:32:56 <shapr> Oh wait, wasn't there a HasChord extension for Haskore?
09:33:06 <dmwit> surgeon: map (map (+1)) should work.
09:33:11 <BONUS> maybe you can make a program that converts lists of [(fret, string, duration)] to ASCII tabs
09:33:21 <vixey> :t (map)
09:33:22 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:33:24 <vixey> :t (map . map)
09:33:25 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
09:33:26 <vixey> :t (map . map . map)
09:33:27 <lambdabot> forall a b. (a -> b) -> [[[a]]] -> [[[b]]]
09:33:35 <vixey> whooosh
09:33:40 <shapr> BONUS: That's a good idea.
09:33:44 <newsham> dont need duration for tabs
09:33:49 <shapr> BONUS: Read and Show for tabs?
09:33:54 <BONUS> haha yeah
09:33:56 <newsham> since they dont encode timing information
09:34:17 <Twey> yewT: I haven't been following along and have no idea what abc or a Table is, but... it defines a function in the local scope `p x = read x < (5::Int)` (i.e. check that a string x contains an Int that's lower than 5), then calls `abc "Price" p`, which presumably returns a function, which is then applied to Table
09:34:43 <maltem> shapr: hm, I'm not sure if algorithms could do any help in guitar playing... A "find the optimal fingering" algorithm would be interesting, but it's up to one's individual fingers what fingering is optimal
09:34:44 <BONUS> hmm, thats true but sometimes i find tabs with some rough timing indicated by how far apart the numbers are
09:35:21 <BONUS> or you could do something with music theroy
09:35:34 <BONUS> for instance, something that draws intervals or chords
09:35:59 <dmwit> newsham: Timing can actually affect fingerings, at least in piano.  (Dunno if tabs show fingerings, do they?)
09:36:06 <BONUS> so it would turn, "A7m" to the appropriate fingering or tab for A7minor
09:36:13 <BONUS> nah, they dont
09:36:28 <newsham> dmwit: they dont say which finger, but they say where to play a note (which is ambiguous on a guitar)
09:36:30 <yewT> twey: abc is the function that i need to create to match this user input " abc "Price" p $ Table where p x = read x < (5::Int) "
09:36:43 <newsham> which hints at which finger to use
09:36:54 <dmwit> ah
09:36:55 <shapr> newsham: I don't know if there's an easy way to calculate which finger is easiest to use.
09:37:10 <shapr> Unless you could do something like "for this fret, which fingers do you put where?" to calibrate.
09:37:12 <newsham> shapr: your brain will start doing it after a few years :)
09:37:57 <shapr> Actually, you could calculate optimal fingerings for chords that have several possibilities, as long as you look at the next chord.
09:38:00 <yewT> twey: one of the problem im facing is where to derive the "source" to feed p x, when x needs to be a string
09:38:08 <surgeon> how can I convert a string like "3.412" to a float? with read? is there even a functiont hat can convert a string with scientific notation, as ".28e-2" to a float?
09:38:15 <shapr> For example, going from a G to a C is easier if you use your pinky to hold down the high E string.
09:38:21 <dmwit> surgeon: Yes, and yes.
09:38:21 <vixey> surgeon: Write a parser
09:38:27 <mauke> > read ".28e-2" :: Double
09:38:28 <BONUS> > read "3.412" :: Float
09:38:28 <dmwit> > read "0.28e-2" :: Double
09:38:29 <lambdabot>   * Exception: Prelude.read: no parse
09:38:30 <lambdabot>   3.412
09:38:30 <lambdabot>   2.8e-3
09:38:33 <BONUS> haha
09:38:43 <dmwit> Hey, they actually came out in order! \o/
09:38:52 <yewT> twey, so my next conclusion is the "Price" set by the user as the selected category...so thats the place i get my values converted into string then feed into read x
09:39:47 <vixey> bleh
09:40:47 <newsham> yewt: is there a question somewhere?  i'm confused about what you're saying and what you're trying to do
09:41:25 <shapr> Aha, lilypond does tablature
09:42:25 <yewT> newsham, im figuring out where to get the source for x so i could feed it into px = read x < (5::Int)
09:43:09 * yewT drawing a flowchart on this problem...
09:43:14 <newsham> you mean you want to know how to read a string from user input, from a file, or from the command line?
09:43:27 <shapr> Yeah, E string, B string, etc
09:43:28 * shapr snickers
09:43:33 <BONUS> haha
09:43:36 <bran> w
09:43:43 <newsham> drop D
09:43:46 <vixey> w
09:43:51 <shapr> w
09:43:54 <mauke> Ê
09:44:00 <vixey> WWWWW i
09:44:03 <shapr> Lots of people like drop D tuning, but I don't know anything about alternate tunings yet!
09:44:04 <vixey> = lol
09:44:13 <mauke> ï½
09:44:15 <yewT> newsham: reading a string from the .hs
09:44:17 <shapr> bran: Hiya! Are you new to Haskell?
09:44:20 <yewT> newsham: the file
09:44:30 * shapr boings frumiously
09:44:43 <newsham> yewt: to put a string in your source just do:   mystring = "hello there"  in your source
09:44:58 <newsham> you want to read a string from a file?
09:45:21 <newsham> you need to use a function like "readFile" which gets you an IO action
09:45:24 <newsham> (IO String)
09:45:47 <newsham> shapr: did you see /msg, btw?
09:45:58 <shapr> Yeah, it led me into strange paths of research...
09:46:00 <skorpan> when using "cabal install", should i do that as root or as a normal user?
09:46:00 <shapr> Which I am now following
09:46:07 <shapr> skorpan: ca depend
09:46:07 <yewT> newsham :: abc :: String -> (String -> Bool) -> Table -> Table
09:46:30 <skorpan> shapr: so if i do it as root, they're installed globally i assume?
09:46:32 <shapr> skorpan: I tend to run it as my own user because it's easier to frob the installed stuff if I find a bug.
09:46:34 <shapr> skorpan: yup
09:46:37 <skorpan> cool thanks
09:46:40 <yewT> newsham , i guess p would be the (String -> Bool)
09:46:52 <shapr> skorpan: Also, installing as root tends to mean your installs all go away when you upgrade ghc
09:46:53 <newsham> yewT: i dont understand what you are saying
09:46:58 <shapr> But user installs seem to stay for me..
09:47:11 <skorpan> shapr: wow
09:47:11 <shapr> Maybe that's not a good thing if you're upgrading a major version :-)
09:47:43 <shapr> I think debian overwrites the global package listing upon upgrade.
09:48:31 <dmwit> skorpan: I think even as root you have to specify --global for cabal install to install globally.
09:48:45 <mauke> you can set the defaults in your config file
09:48:55 <shapr> Cool, I didn't know that.
09:48:58 <mauke> user-install: False
09:49:10 <skorpan> dmwit: so what happens if i install as root without --global?
09:49:15 <newsham> i think thats a fairly non-obvious design point in cabal.
09:49:23 <newsham> skorpan: it goes into ~root/.cabal
09:49:28 <newsham> or something like that
09:49:28 <skorpan> that sucks mate
09:49:30 <dmwit> skorpan: It will install with the --user command in $HOME/.cabal.
09:49:43 <dmwit> skorpan: Note that with sudo, $HOME will still be your *user*s $HOME.
09:49:43 <shapr> Is there any obvious best approach for installing as root/user/global/local ?
09:49:58 <dmwit> skorpan: Which means you'll get files owned by root in your home directory. =/
09:50:03 <skorpan> true
09:51:29 <noZone> Is there a good *online* resource discussing the ins-and-outs of lazy data structures in Haskell?
09:51:43 <vixey> what do you mean noZone
09:51:46 <vixey> lets write it
09:52:21 <dmwit> noZone: I think you can get Chris Okasaki's thesis online.
09:52:23 <surgeon> when I try to compile this command: putStr $ show $ map (map read) $ [["1.2","1.3"],["3.4","4.5"]], I get a compiler error saying something about amibguous type variable a in show and read
09:52:27 <noZone> I see books on functional data structures, but I've not yet found a good discussion of it online.
09:52:33 <dmwit> noZone: It's the less good version of his book. =)
09:52:51 <vixey> surgeon: Watch this:
09:52:54 <vixey> :t (map)
09:52:55 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:52:56 <vixey> :t (map . map)
09:52:57 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
09:52:58 <vixey> :t (map . map . map)
09:52:59 <lambdabot> forall a b. (a -> b) -> [[[a]]] -> [[[b]]]
09:53:01 <Twey> surgeon: You need to give it a type
09:53:13 <dmwit> vixey: Totally unrelated to his question.
09:53:17 <Twey> 'read' can read to any number of different types
09:53:19 <newsham> surgeon: the types of show and the types of read
09:53:20 <newsham> ?type read
09:53:21 <lambdabot> forall a. (Read a) => String -> a
09:53:22 <newsham> ?type show
09:53:23 <lambdabot> forall a. (Show a) => a -> String
09:53:28 <sebaseba> > read "1.2"
09:53:29 <lambdabot>   * Exception: Prelude.read: no parse
09:53:35 <sebaseba> > read "1.2" :: Double
09:53:37 <lambdabot>   1.2
09:53:38 <newsham> you need to let it know what type to read
09:53:47 <vixey> surgeon: so you could use (map . map) instead
09:53:52 <Twey> surgeon: Also, try to avoid strings of $
09:54:57 <surgeon> so do I have to type in map (map (read :: double)) ... - or something like this?
09:54:58 <sebaseba> surgeon: use print instead of putStr $ show ...
09:55:00 <Deewiant> > cycle "$ "
09:55:01 <lambdabot>   "$ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ $ ...
09:55:01 <newsham> ?type show . map . map read
09:55:02 <vixey> surgeon: map . map
09:55:02 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
09:55:02 <lambdabot>     Probable cause: `map' is applied to too many arguments
09:55:02 <lambdabot>     In the second argument of `(.)', namely `map read'
09:55:31 <surgeon> Twey: what would be your solution? split it up in subprocedures or use brackets? anyway it's just for testing purposes, i am new to haskell
09:55:32 <dmwit> surgeon: Close, but you'd have to use
09:55:39 <dmwit> map (map (read :: String -> Double))
09:55:39 <newsham> ?type show . map (map read)
09:55:40 <lambdabot> [[String]] -> String
09:55:54 <Twey> > show $ (map . map) read [["1.2","1.3"],["3.4","4.5"]]
09:55:55 <vixey> > let readDouble = read :: String -> Double in (map . map) readDouble [["1.2","1.3"],["3.4","4.5"]]
09:55:55 <lambdabot>   "[[* Exception: Prelude.read: no parse
09:55:56 <lambdabot>   [[1.2,1.3],[3.4,4.5]]
09:56:02 <vixey> surgeon: see ?
09:56:03 <dmwit> surgeon: It's a little unfortunate, but it's the price we pay for return-type polymorphism. =)
09:56:06 <Twey> Ack
09:56:06 <Twey> Heh
09:56:23 <Twey> > show $ (map . map) (read [["1.2","1.3"],["3.4","4.5"]] :: [[Double]])
09:56:24 <lambdabot>   Couldn't match expected type `Char' against inferred type `[a]'
09:56:37 <dmwit> > show . (map . map) (read :: String -> Double) $ [["1.2"]]
09:56:38 <lambdabot>   "[[1.2]]"
09:56:39 <Twey> *frown*
09:56:44 <Twey> Oh, fool me
09:56:56 <Twey> > show $ ((map . map) read [["1.2","1.3"],["3.4","4.5"]] :: [[Double]])
09:56:57 <lambdabot>   "[[1.2,1.3],[3.4,4.5]]"
09:57:28 <vixey> I don't like that type signature
09:57:35 <vixey> @let readDouble = read :: String -> Double
09:57:36 <lambdabot>  Defined.
09:57:40 <vixey> you can use this if you like
09:58:02 <vixey> > show $ (map . map) readDouble [["1.2","1.3"],["3.4","4.5"]]
09:58:03 <lambdabot>   "[[1.2,1.3],[3.4,4.5]]"
09:58:46 <BONUS_> vixey: i fixed the dancing text while loading on the site, thanks for warning me about that :)
09:58:55 <vixey> cool
09:59:58 <Twey> Dancing text?
10:01:17 <vixey> :k Mu
10:01:18 <lambdabot> (* -> *) -> *
10:01:24 <BONUS_> Twey: on learnyouahaskell.com i forgot to specify the image widths and heights
10:01:37 <BONUS_> so the text would kind of dance around while the images were loading
10:02:35 <Twey> Oh right
10:02:36 <Twey> Heh
10:03:08 <surgeon> Thanks guys, I guess I got it now
10:04:15 <BONUS_> Mu owns
10:09:17 <yewT> is f i = f (i) ?
10:09:27 <vixey> yes
10:09:28 <vixey> exacttly
10:09:32 <vixey> and x = (x)
10:09:33 <vixey> in general
10:09:49 <vixey> so f i = f (i) = (f (i))
10:09:57 <Deewiant> = ((f) (i))
10:10:14 <BONUS_> also, (f a) b = f a b
10:10:53 <surgeon> vixey: eh, now I got this Prelude.read: no parse, though I did it as you said, defined readDouble and connected (map . map)
10:11:08 <newsham> whats the relation between yewT and Twey?
10:11:20 <vixey> surgeon: Why
10:11:39 <Twey> newsham: Mu
10:12:13 * Twey performs a three-way pun, and feels proud.
10:12:30 <vixey> w
10:13:26 <vixey> preflex: version
10:13:26 <preflex>  6.549
10:13:31 <dmwit> surgeon:
10:13:33 <dmwit> ?hpaste
10:13:33 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:13:38 <vixey> preflex: Be pastebin
10:14:07 <mauke> what
10:14:42 <mauke> preflex: karma oleg
10:14:42 <preflex>  karma for oleg: 3
10:14:45 <mauke> oleg++
10:14:52 <vixey> oleg++
10:15:29 <surgeon> dmwit, vixey: I am reading in a file http://rafb.net/p/FXrA0I29.html
10:15:30 <lambdabot> Title: Nopaste - dread.hs
10:15:42 <vixey> surgeon: oh you are using read to parsse a file
10:15:42 <vixey> ?
10:15:51 <surgeon> readFile
10:16:03 <vixey> readDouble a = (read :: String->Double) a
10:16:05 <vixey> can be written
10:16:11 <vixey> readDouble = read :: String->Double
10:16:15 <vixey> these are equivalent
10:16:15 <vixey> a
10:16:24 <surgeon> yeah I tried that too, I just wanted to make sure the error wasn't there ;-)
10:16:41 <vixey> what's in your .dat file
10:17:44 <dmwit> surgeon: putStr . show ~= print
10:18:02 <surgeon> http://rafb.net/p/iX1prz74.html - columns with strings
10:18:03 <lambdabot> Title: Nopaste - Spule4.dat
10:18:09 <BONUS_> i thought thats putStrLn . show
10:18:10 <surgeon> aeh floats I mean
10:18:19 <dmwit> print . map (map readDouble . words) . lines $ line
10:18:21 <mauke> surgeon: you can't omit the 0 before .
10:18:22 <vixey> your code is crazy
10:18:24 <surgeon> dmwit: ah sry I already forgot
10:18:26 <dmwit> BONUS_: That's why it's whirly-equals. =)
10:18:31 <BONUS_> ah haha
10:18:47 <vixey> I think you should write a parser for this file format
10:19:06 <vixey> the parser serves as a formal description of what are valid files
10:19:11 <mauke> vixey: isn't that what he's doing?
10:19:27 <vixey> not in a way I am satisfied with
10:19:27 <dmwit> > read "0." --  surgeon, this also probably dies
10:19:28 <lambdabot>   * Exception: Prelude.read: no parse
10:19:36 <mauke> > read "0." :: Double
10:19:38 <lambdabot>   * Exception: Prelude.read: no parse
10:19:38 <dmwit> > read "0." :: Double
10:19:39 <lambdabot>   * Exception: Prelude.read: no parse
10:20:07 <surgeon> why :/ ok, than I have to learn more about parsing
10:20:16 <vixey> surgeon: Parsec has a good intro
10:20:18 <mauke> > 0.
10:20:19 <lambdabot>   <no location info>: parse error on input `;'
10:20:34 <vixey> surgeon: The way you've got it now could work but I think it is a bad way to do this
10:20:36 <mauke> haskell simply doesn't allow numbers starting/ending with .
10:21:08 <chrisdone> > reads "8." :: [(Double,String)]
10:21:09 <lambdabot>   [(8.0,".")]
10:22:20 <surgeon> oh ok, thanks for your help so far!
10:26:47 <yewT> > [1,4] vs [ [55,66,1] , [33,44,55] , [4,3,9] , [11,22,33] ]
10:26:48 <lambdabot>   Not in scope: `vs'
10:27:12 <vixey> @let vs = (>)`on`length
10:27:13 <lambdabot>  Defined.
10:27:16 <vixey> ugh
10:27:19 <vixey> stupid type system
10:27:20 <vixey> @undef
10:27:31 <vixey> @let vs x y = length x > length y
10:27:32 <lambdabot>  Defined.
10:27:40 <yewT> hey guys, how do i truncate the element from [[Int]] if one of the element matches [Int] ?
10:28:00 <vixey> yewT: what would the result be?
10:28:16 <yewT>  [1,4] vs [ [55,66,1] , [33,44,55] , [4,3,9] , [11,22,33] ] >>>[ [33,44,55] ,  [11,22,33] ]
10:28:31 <vixey> @let box = [ [55,66,1] , [33,44,55] , [4,3,9] , [11,22,33] ]
10:28:32 <lambdabot>  Defined.
10:29:11 <vixey> > filter (not . liftM2 (||) (1 `elem`) (4 `elem`)) box
10:29:13 <lambdabot>   [[33,44,55],[11,22,33]]
10:30:10 <yewT> :t liftM2
10:30:11 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
10:30:25 <vixey> actually I should have used liftA2
10:30:29 <vixey> I just used to use liftM2
10:30:38 <vixey> so replace liftM2 with liftA2
10:31:12 <vixey> yewT: liftA2 (*) f g = \x -> f x * g x
10:32:07 <yewT> umm how does liftA2 works?
10:32:18 <vixey> what do you mean
10:32:31 <vixey> :t liftA2
10:32:32 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
10:32:35 <vixey> @src Applicative
10:32:35 <lambdabot> class Functor f => Applicative f where
10:32:35 <lambdabot>     pure  :: a -> f a
10:32:35 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
10:32:49 <vixey> @src liftA2
10:32:50 <lambdabot> liftA2 f a b = f <$> a <*> b
10:33:11 <Botje> for regular monads liftM2 == liftA2, right?
10:33:28 <yewT> what does this mean? (a -> b -> c) -> f a -> f b -> f c
10:33:34 <vixey> that's a type
10:33:43 <vixey> do you understand what  a -> b -> c  is?
10:33:48 <yewT> no
10:33:53 <yewT> a function?
10:33:56 <vixey> yes
10:34:05 <yewT> ok...
10:34:08 <vixey> it's a functiont which takse an a and a b and results in a c
10:34:16 <yewT> ok
10:34:26 <yewT> so how does that relates to the f a f b fc
10:34:28 <vixey> so length :: [a] -> Int, it takes a list and results in a Int the length
10:35:00 <vixey> > liftA2 (+) (Just 1) (Just 3)
10:35:01 <lambdabot>   Just 4
10:35:05 <vixey> > (+) 1 3
10:35:06 <lambdabot>   4
10:35:10 <vixey> here is another example
10:35:11 <MyCatVerbs> vixey: rawrs! length is cycle's natural enemy. =D
10:35:18 <vixey> the function (+) :: Int -> Int -> Int
10:35:32 <vixey> is lifted by liftA2 into liftA2 (+) :: Maybe Int -> Maybe Int -> Maybe Int
10:35:40 <vixey> yewT: so in this case the 'f' was Maybe
10:35:49 <yewT> oh
10:35:50 <yewT> now i get it
10:35:52 <vixey> yewT: and does it make sense?
10:35:53 <yewT> thanks vixey
10:35:58 <vixey> yewT: ok so in my earlier one,
10:36:02 <vixey> :t liftA2 (||)
10:36:02 <lambdabot> forall (f :: * -> *). (Applicative f) => f Bool -> f Bool -> f Bool
10:36:18 <vixey> the 'f' is actually (x -> _)
10:36:34 <vixey> :t liftA2 (||) (`elem` 1) (`elem` 4)
10:36:35 <lambdabot> forall a. (Eq a, Num [a]) => a -> Bool
10:36:59 <vixey> yewT: And there are various different Applicatives, like Maybe and (x -> _) and so on
10:37:02 <vixey> @instance Applicative
10:37:02 <lambdabot> Maybe you meant: instances instances-importing
10:37:27 <yewT> ok
10:37:43 <yewT> umm just wandering , why is it called liftied?
10:37:54 <yewT> lifted by liftA2?
10:37:54 <vixey> yewT: so liftA2 takes a binary function (one that takes two parameters) and results in the new function _lifted_ into an Applicative such as Maybe or whatever
10:38:06 <vixey> :t (+)
10:38:07 <lambdabot> forall a. (Num a) => a -> a -> a
10:38:17 <vixey> :t liftA2 (+) :: Maybe a -> Maybe a -> Maybe a
10:38:18 <lambdabot>     Could not deduce (Num a) from the context ()
10:38:18 <lambdabot>       arising from a use of `+' at <interactive>:1:7-9
10:38:18 <lambdabot>     Possible fix:
10:38:23 <vixey> :t liftA2 (+) :: Num a => Maybe a -> Maybe a -> Maybe a
10:38:24 <lambdabot> forall a. (Num a) => Maybe a -> Maybe a -> Maybe a
10:38:28 <vixey> in thaht way
10:39:15 <yewT> i dont see the difference between function (+) :: Int -> Int -> Int vs liftA2 (+) :: Maybe Int -> Maybe Int -> Maybe Int (adding Maybe?)
10:39:25 <vixey> yewT: What
10:39:41 <yewT> liftA2 basically adds Maybe?
10:39:49 <vixey> yewT: no
10:40:30 <vixey> yewT: liftA2 could add Maybe or (x -> _) or ...., any Applicative
10:41:40 <yewT> gtg
10:41:43 <yewT> bye vixey
10:41:46 <vixey> bye
10:42:01 <vixey> yewT
10:43:58 <vixey> :t msum (map (flip elem) [1,4])
10:43:59 <lambdabot> forall a. (MonadPlus ((->) a), Num [a], Eq a) => a -> Bool
10:44:23 <vixey> :t msum (map elem [1,4,6,8,4,2])
10:44:25 <lambdabot> forall a. (MonadPlus ((->) [a]), Num a) => [a] -> Bool
10:44:32 <vixey> > msum (map elem [1,4,6,8,4,2]) [3,5,8,4]
10:44:33 <lambdabot>       No instance for (MonadPlus ((->) [a]))
10:44:33 <lambdabot>        arising from a use of `ms...
10:44:43 <vixey> is there any asum
10:45:46 <BONUS_> lol
10:45:50 <BONUS_> that yewT character
10:46:16 <BONUS_> #haskell's patience is unmatched
10:46:49 <ozy`> he -is- new to programming on the whole
10:47:01 <vixey> I thought they knew some PHP
10:47:40 <BONUS_> its not that he didnt know haskell, just that he didnt listen to stuff people told him and kept repeating the same thing
10:48:38 <vixey> :t foldr (liftA2 (||)) (const True)
10:48:39 <lambdabot> forall b. [b -> Bool] -> b -> Bool
10:48:45 <dmwit> The issue I have is that he refuses to look at any tutorials or in any way try to help himself.
10:48:51 <BONUS> yeah
10:48:53 <vixey> :t foldr (liftA2 (||)) (const False) (map elem [3,5,4,8,6])
10:48:54 <lambdabot> forall a. (Num a) => [a] -> Bool
10:49:10 <vixey> @let asum = foldr (liftA2 (||)) (const False)
10:49:10 <lambdabot>   Parse error
10:49:15 <vixey> wrong
10:49:51 <vixey> @tell gwern is this a mueval problem or something? vixey: @let asum = foldr (liftA2 (||)) (const False) lambdabot: Parse error
10:49:51 <lambdabot> Consider it noted.
10:49:55 <dmwit> ?undefine
10:50:11 <dmwit> ?let asum = foldr (liftA2 (||)) (const False)
10:50:11 <lambdabot>   Parse error
10:50:16 <dmwit> huh
10:50:54 <RayNbow> :t let asum = foldr (liftA2 (||)) (const False) in asum
10:50:55 <lambdabot> forall b. [b -> Bool] -> b -> Bool
10:51:10 <vixey> hm this is not a good asum
10:51:40 <vixey> @src msum
10:51:40 <lambdabot> msum =  foldr mplus mzero
10:51:45 <dmwit> ?ask vixey Why did you use ?tell instead of ?ask? ;-)
10:51:46 <lambdabot> Consider it noted.
10:51:46 <vixey> :t mplus
10:51:47 <lambdabot> vixey: You have 1 new message. '/msg lambdabot @messages' to read it.
10:51:47 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
10:53:15 <rwbarton> @hoogle Alternative a => [a b] -> a b
10:53:15 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
10:53:16 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
10:53:16 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
10:53:34 <vixey> @instances Alternative
10:53:35 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
10:53:35 <Deewiant> ?ty foldr (<|>) empty
10:53:36 <lambdabot> forall (f :: * -> *) a. (Alternative f) => [f a] -> f a
10:53:47 <vixey> @instances-importing Control.Alternative Alternative
10:53:48 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
10:53:49 <Deewiant> ?ty msum
10:53:50 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
10:53:59 <Deewiant> vixey: control.applicative
10:54:02 <vixey> @instances-importing Control.Applicative Alternative
10:54:02 <lambdabot> Maybe, WrappedMonad m, []
11:01:57 <vixey> why is @instances so rubbish
11:20:51 <dons> ?users
11:20:51 <lambdabot> Maximum users seen in #haskell: 518, currently: 507 (97.9%), active: 8 (1.6%)
11:21:31 <vixey> @free length
11:21:32 <lambdabot> length = length . $map f
11:24:57 <dons> sigfpe for ya, http://www.reddit.com/r/programming/comments/76p80/a_neighborhood_of_infinity_untangling_with/
11:24:59 <lambdabot> Title: A Neighborhood of Infinity: Untangling with Continued Fractions: part 5 : progra ..., http://tinyurl.com/54masx
11:25:24 <BONUS> woot
11:25:26 <BONUS> upvoted
11:32:16 <hackage> Uploaded to hackage: panda 2008.10.13
11:41:54 <mmorrow> > show . (map . map) (read::String->Double) $ [["1.2","1.3"],["3.4","4.5"]]
11:41:55 <lambdabot>   "[[1.2,1.3],[3.4,4.5]]"
11:43:36 <Twey> > show $ (map . map) (read :: String -> Double) [["1.2","1.3"],["3.4","4.5"]]
11:43:37 <lambdabot>   "[[1.2,1.3],[3.4,4.5]]"
11:44:28 <mmorrow> , maybe undefined (id::[[Double]]->[[Double]]) . fromDynamic . eval . show . (map . map) (read::String->Double) $ [["1.2","1.3"],["3.4","4.5"]]
11:44:38 <mmorrow> wake up lunabot
11:44:41 <Twey> Heh
11:44:43 <lunabot>  [[1.2,1.3],[3.4,4.5]]
11:44:50 <Twey> Nice speed!
11:45:26 <mmorrow> heh, it's on a hosted webserver, in a vm no doubt. it seems to get faster aftre the initial wakeup
11:45:29 <mmorrow> , maybe undefined (id::[[Double]]->[[Double]]) . fromDynamic . eval . show . (map . map) (read::String->Double) $ [["1.2","1.3"],["3.4","4.5"]]
11:45:33 <lunabot>  [[1.2,1.3],[3.4,4.5]]
11:45:36 <mmorrow> , 42
11:45:38 <lunabot>  42
11:49:53 <mmorrow> @tell chrisdone err, oops. s/__GHC_HASKELL__/__GLASGOW_HASKELL__/ ;)
11:49:53 <lambdabot> Consider it noted.
11:51:38 <skorpan> wtf
11:51:42 <skorpan> deniz@stalin:~% cabal upgrade --reinstall
11:51:42 <skorpan> Resolving dependencies...
11:51:42 <skorpan> No packages to be installed. All the requested packages are already installed.
11:51:44 <skorpan> If you want to reinstall anyway then use the --reinstall flag.
11:51:48 <skorpan> oops
11:51:55 <skorpan> so now that i pasted it, what the heck?
11:52:04 <BONUS> lol, stalin
11:52:10 <dmwit> lol, deniz
11:52:25 <skorpan> :(
11:52:57 <rwbarton> lol, %
11:53:02 <rwbarton> :)
11:53:22 <dmwit> heh
11:53:42 <skorpan> i'm glad i amuse you
11:54:12 <skorpan> IMA PLAY WORMS
11:54:18 <Twey> What's wrong with %?  :-P
12:06:03 <Arnar_> hi all
12:06:16 <Arnar_> what's the proper way again to ask lambdabot for the source of a certain instance..
12:06:26 <Arnar_> e.g. if I want to know mplus is for the State monad
12:06:43 <BONUS> i think its
12:06:47 <BONUS> @src mplus (Maybe)
12:06:49 <lambdabot> Source not found. Sorry.
12:06:54 <BONUS> @src (Maybe) mplus
12:06:54 <lambdabot> Source not found. Just what do you think you're doing Dave?
12:07:00 <BONUS> ugh, i dont know :(
12:07:05 <Arnar_> @src mplus []
12:07:05 <lambdabot> Source not found. My pet ferret can type better than you!
12:07:17 <Arnar_> it's something like that
12:07:24 <Arnar_> @src mplus :: []
12:07:25 <lambdabot> Source not found. There are some things that I just don't know.
12:07:33 <mauke> @src [] mplus
12:07:34 <lambdabot> mplus = (++)
12:07:42 <Arnar_> thx
12:07:44 <BONUS> ah
12:07:49 <Arnar_> @src State mplus
12:07:49 <lambdabot> Source not found. Just try something else.
12:08:00 <BONUS> State isnt a MonadPlus instance
12:08:04 <BONUS> afaik
12:08:15 <Arnar_> ah ok
12:08:20 <BONUS> StateT is though
12:08:21 <Arnar_> @instances MonadPlus
12:08:22 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
12:08:29 <Arnar_> ah I meant StateT
12:08:36 <Arnar_> @src StateT mplus
12:08:36 <lambdabot> Source not found. You untyped fool!
12:08:43 <BONUS> its like
12:09:09 <BONUS> StateT x `mplus` StateT y = StateT $ \t -> x t `mplus` y t
12:09:37 <BONUS> so it makes a new state transition that mpluses the two resulting states from them
12:09:58 <Arnar_> BONUS++ thanks... that's what I wanted
12:10:11 <BONUS> :]
12:10:19 <Arnar_> key thing being that it passes the same state to both
12:10:27 <BONUS> yeah
12:10:44 <BONUS> also: http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/src/Control-Monad-State-Lazy.html
12:10:46 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6nnf3q
12:11:46 <Arnar_> thanks
12:27:04 <Trinithis> how can you query whether or not a FilePath is a file or a directory
12:27:50 <mauke> @hoogle isDirectory
12:27:50 <lambdabot> No results found
12:28:20 <mauke> @hoogle doesDirectoryExist
12:28:20 <lambdabot> System.Directory doesDirectoryExist :: FilePath -> IO Bool
12:30:49 <Trinithis> thanks
12:33:48 <bos> i'm quite excited about ghc 6.10.1.
12:34:02 <Trinithis> what's new in it?
12:34:32 <Heffalump> a load of half-finished stuff :-)
12:34:45 <bos> lots of stuff. most notably, early support for data parallel haskell, quasiquotation, and a pony.
12:35:04 <bos> {-# LANGUAGE GeneralizedPony #-}
12:35:11 <Trinithis> pony?
12:35:25 <bos> oh, and view patterns. and less broken type families.
12:35:26 <Heffalump> yes. A really nice one.
12:35:28 <Trinithis> what about a kitchen sink?
12:35:45 <Heffalump> can it make the toast?
12:35:55 <Trinithis> I remember reading about view patterns... they were cool
12:38:43 <dons> 624 packages in Arch, http://archhaskell.wordpress.com/2008/10/12/arch-haskell-news-oct-12-2008/
12:38:50 <lambdabot> Title: Arch Haskell News: Oct 12 2008 Â« Arch Linux and Haskell, http://tinyurl.com/3p5a5l
12:39:06 <Heffalump> does Arch have more Haskell packages than users now?
12:39:18 <bos> yes, by a factor of 10 or so.
12:39:28 <Heffalump> I don't mean Haskell users, I mean users in general
12:39:33 <bos> :-)
12:39:56 <Heffalump> 60 Haskellers using Arch sounds like a lot
12:40:08 <dons> yeah, about 20 i'd say
12:40:18 <dons> well, though, there's 10 in the dev channel
12:40:28 <dons> and 50 unique votes for haskell-cabal
12:40:32 <dons> so maybe it's higher.
12:40:46 <hoknamahn> guys what is the main difference between arch and gentoo?
12:40:50 <dons> 50 would be a lower bound on people using cabal. (voluntary voting)
12:40:58 <dons> hoknamahn: binary vs source distribution.
12:41:01 <Heffalump> ok, that's not bad
12:41:08 <bos> dons: gentoo is source.
12:41:15 <hoknamahn> dons but arch based on gentoo?
12:41:17 <hoknamahn> not?
12:41:23 <dons> bos, right. while arch is binary
12:41:28 <dons> (and source to generate the binaries)
12:41:30 <hoknamahn> okay
12:41:31 <bos> dons: oh, i didn't know.
12:42:23 <hoknamahn> what about arch's package system? is it some sort of emerge?
12:42:34 <Twey> pacman
12:42:38 <dons> 'pacman', it reminds me of a binary git pull
12:42:43 * Twey nods.
12:42:54 <Twey> There's also a ports-like source building thing
12:43:19 <hoknamahn> so
12:43:26 <hoknamahn> any other difference?
12:43:41 <dons> one has more haskell packages.
12:43:56 <hoknamahn> what kind of packages?
12:44:00 <dons> but kolmodin is chasing pretty fast.
12:44:07 <bos> one has dons. the other has dcoutts. only one can emerge the victor!
12:44:08 <dons> all kinds, types and values of packages.
12:44:14 <Twey> Arch has huge amounts of Haskell packages in AUR.
12:44:22 <dons> bos, ah no. dcoutts moved from gentoo to cabal. that's his distro now.
12:44:29 <dons> so kolmodin is the gentoo master.
12:44:30 <bos> dons: i see :-)
12:44:42 <bos> cabal as a distro seems a little ... thin.
12:44:42 <Twey> Haha, to cabal
12:44:54 <bos> unless we can run cabal inside ghc-rts-on-xen.
12:45:00 <dons> hmm.
12:45:03 <dons> i should try that.
12:45:11 <dons> might be hard without a filesystem
12:45:20 <dons> i'll have to dig up one of those.
12:45:23 <bos> details.
12:45:35 <dons> cabal, an in-memory build system
12:46:14 <mmorrow> olegZFS
12:46:24 <Twey> Hahaha
12:46:26 <Baughn> Meh. Filesystems are *easy* if you assume there is no seek latency and the block size is 1.
12:46:37 * Twey chuckles.
12:47:37 <mmorrow> haha
12:47:56 <mmorrow> {-# LANGUAGE CanHasGeneralizedPonyDeriving #-}
12:49:16 <lament> olegZFC
12:53:09 <ujwalic> any one installed Pugs using cabal.exe on windows xp
13:01:40 <ttt--> is there already a conversion available somehow from GHC.Type to Type in template haskell?
13:02:08 <ttt--> or are those different things
13:05:40 <ddarius> Baughn: Look at the filesystem in Xok
13:07:34 <vixey> :/
13:07:36 <vixey> I hate HOAS
13:07:44 <vixey> it keeps coming up and not working
13:08:25 <ddarius> In some contexts HOAS is tricky.
13:08:45 <vixey> it can be a real pest
13:10:10 <mattam> What's wrong with it?
13:10:25 <vixey> I just keep having problems with it
13:11:07 <vixey> maybe I am too used to logic programming
13:11:13 <mattam> I mean what can you possibly be doing except representing objet-languages with it?
13:11:36 <vixey> I want to do  let y = foo x; return (\x -> y x)  with impossible scope rules
13:12:11 <vixey> constructing proofs with it
13:12:23 <vixey> except I have no choice but to use HOAS
13:13:16 <vixey> I think there is only one thing I've used HOAS for and not have problems
13:13:23 <vixey> which is an evaluator
13:14:13 <Heffalump> what scoping do you expect that code to have?
13:14:35 <vixey> well my example made no sense
13:14:44 <vixey> what I want is, say foo is Maybe a
13:14:50 <vixey> and I want to return Nothing or Maybe (x -> a)
13:15:01 <vixey> I would like to have some way to write,  (\x -> foo x)
13:15:08 <vixey> but of course that returs x -> Maybe a
13:15:20 <ddarius> fmap const
13:15:27 <vixey> and without having an actual 'x' value .. there's no way to turn x -> Maybe a into Maybe (x -> a)
13:15:30 <vixey> :t fmap const
13:15:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> f (b -> a)
13:15:53 <sjanssen> @djinn (x -> Maybe a) -> Maybe (x -> a)
13:15:53 <lambdabot> f _ = Nothing
13:16:00 <vixey> hehe
13:16:02 <sjanssen> vixey: the function can't be written
13:16:05 <BONUS> :t (\x -> foo x)
13:16:06 <lambdabot> Not in scope: `foo'
13:16:29 <sjanssen> vixey: except for const Nothing, of course
13:16:32 <vixey> sjanssen: The one I want cant
13:16:44 <vixey> at least I don't think it can
13:16:55 <ddarius> You need classical logic.
13:17:19 <vixey> I don't have it :(
13:18:26 <ddarius> callCC (\k -> return (Just (\x -> case foo x of Just a -> return a; Nothing -> k Nothing)))
13:19:12 <vixey> ahh
13:21:37 <vixey> maybe I can use cwcc in some fashion
13:27:32 <vixey> :t runCont
13:27:33 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
13:32:16 <hackage> Uploaded to hackage: panda 2008.10.15
13:32:16 <hackage> Uploaded to hackage: panda 2008.10.14
13:32:49 <zeno> > let factors x = filter (\n -> x `mod` n == 0) [1..y] where y = fromIntegral . floor . sqrt $ x in factors 24332
13:32:50 <lambdabot>   Add a type signature
13:33:09 <bos> dons: does new bytestring implement IsString now?
13:45:43 <tjb> I'm trying to model something that looks like a priority select in haskell.  i.e., something that takes a list of input sources and selects from them in a specified order.  Anyone have any suggestions as to what the function prototype should look like in haskell?
13:46:34 <tjb> I would like the "list" of input sources to be parameterizable.  So I don't have something like 'priSel :: a -> a-> a'
13:46:54 <BONUS> [a] -> [a] ?
13:49:00 <nomeata> Hi. Iâd just like to express that Iâd very much welcome a DarcsWeb installation on http://code.haskell.org/
13:49:01 <lambdabot> Title: Index of /
13:49:46 <tjb> BONUS:  I'm obviously just learning haskell.  The logic I'm trying to express is something like "if (a[0] exists) then a[0] else if (a[1] exists) then a[1] ... etc down the list of input a[]"
13:50:03 <vixey> tjb: This is really not haskell
13:50:54 <ozy`> tjb: you'd do that with recursion
13:51:04 <BONUS> so what would you want your function to do, for example
13:51:18 <araujo> http://trac.haskell.org/himerge/wiki/WikiStart
13:51:18 <lambdabot> Title: himerge - Trac
13:51:19 <araujo> :-)
13:51:36 <ozy`> tjb: except I don't know what you mean by "exists" in this context, since there's no such thing as a list with an empty slot
13:52:01 <tjb> vixey, ozy`: I'm open to suggestions.  I'm essentially trying to see how a "priority select" would be modeled/implemented in haskell
13:52:04 <dons> bos, yes, has for a while. in the .Char modules
13:52:22 <ozy`> tjb: yes you mentioned that... it depends what you'd be selecting
13:52:27 <bos> dons: ok, thanks
13:52:38 <vixey> tjb: this a[0] sort of stuff, if a is an array and 0 is an index, yous hould write a!0
13:53:25 <BMeph> araujo: I think that's what nomeata wants...only for darcs, not just gentoo stuff. :)
13:54:17 <tjb> (I'm coming from a hardware description language background) : I essentially have a "list" of FIFOs that are in a priority order.  I want to "output" from the FIFOs in their priority order
13:54:31 <tjb> sorry if this isn't making much sense from a haskell description/perspective
13:55:14 <ozy`> tjb: http://hpaste.org/11098
13:55:35 <araujo> BMeph, Plenty of people want that ... also for cabal ...
13:56:13 <rwbarton> tjb: do you already have a haskell model of a FIFO?  (A Chan perhaps?)
13:56:28 <tjb> ozy`: ahh, interesting.  Yes, that looks like what I am looking for
13:56:54 <BMeph> tjb: what you want is concat, modulo whatever container type your FIFOs are. :)
13:57:07 <ozy`> tjb: in case it's not self-evident (since I'm sure you haven't seen this before): "Maybe a" is a generic type that can either encapsulate a value of type "a," or signal the absence of any usable value whatsoever
13:57:13 <fadec> tjb: head (dropWhile (== 0) [0,0,3,1,0])
13:57:22 <BMeph> tjb: (That's the 'Haskell perspective' anyway. :)
13:57:36 <fadec> tjb: as long as there is at least one nonzero buffer
13:57:54 <nomeata> > find (/=0) [0,0,3,1,0]
13:57:55 <lambdabot>   Just 3
13:58:00 <nomeata> > find (/=0) [0,0,0,0,0]
13:58:01 <lambdabot>   Nothing
13:58:10 <BMeph> araujo: Ooh, Cabal in a GUI...my mouth is watering... :)
13:58:18 <tjb> rwbarton:  my model of a FIFO is pretty basic right now .. essentially a list of Integers
13:58:34 <tjb> BMeph:  excellent, thanks for the info.  I'll be digesting that for a few minutes still :)
13:58:58 <tjb> ozy`:  yes, that seems to be exactly what I'm trying to express
13:59:02 <araujo> BMeph, :-)
13:59:37 <araujo> BMeph, I proposed that project for last year GSoC .. but apparently there was not too much interest by then
13:59:54 <tjb> fadec:  interesting, I'll take a look at that as well.  Thanks
14:00:15 <ozy`> tjb: also, normally you'd do it fadec's way, but I didn't want to show you that immediately, just so you'd get the hang of it
14:00:25 <ozy`> erm
14:01:00 <tjb> ozy`:  yes, it seems like your idea is a little more "verbose" in the description -- good for getting the hang of it
14:01:42 <nomeata> Ways to write the âsafe headâ function: listToMaybe, find (const True). Any other clever ideas?
14:02:08 <vixey> :t listToMaybe
14:02:08 <rwbarton> unsafeCoerce# . drop 1? :)
14:02:09 <lambdabot> forall a. [a] -> Maybe a
14:02:14 * ddarius isn't sure how a GUI would make 'cabal install foo' easier.
14:02:19 <rwbarton> er, take 1, not drop 1
14:02:36 <nomeata> rwbarton: are you sure that works?
14:02:47 <ddarius> rwbarton: You don't need the drop 1
14:03:01 <rwbarton> ddarius: I suppose not
14:03:03 <rwbarton> nomeata: no
14:03:15 <vixey> safeHead (x:xs) = x
14:03:23 <vixey> :)))
14:03:57 * BMeph imagines Hackage, with a "cabal install this" option beneath the tar link
14:03:58 <nomeata> vixey: hmm. I wonder if that function is what is called âEttikettenschwindelâ in Germany
14:04:21 <nomeata> (eh, âEtikettenschwindelâ. âfalse labelingâ)
14:04:29 <DavidS333> How do I get the length of a binary file? I only get a weird symbol when I try to print its result and the length seem to be 5 but it should be over 10k! http://hpaste.org/11099
14:04:34 <ddarius> vixey: Wrong type, Just . head
14:04:37 <vixey> nice work
14:04:44 <vixey> word*
14:04:55 <DavidS333> its the png section
14:06:36 <Twey> nomeata: 'misnomer'
14:06:38 <FunctorSalad> BMeph: while we're at it, let's add one hoogle file to rule them all
14:07:01 <FunctorSalad> or maybe it has been done already?
14:07:13 <dmwit> DavidS333: That code looks fine (though the "tail" is odd).  Things to check:
14:07:15 <rwbarton> DavidS333: defaulting
14:07:25 <rwbarton> DavidS333: contents :: () or something unhelpful like that
14:07:31 <rwbarton> DavidS333: Wait, no...
14:07:36 <dmwit> :t readFile -- rwbarton, I don't think so
14:07:37 <lambdabot> FilePath -> IO String
14:07:48 <rwbarton> Ah, got confused by the read and readLn
14:07:51 <dmwit> DavidS333: Does your web server have permissions on the file?
14:08:17 <dmwit> DavidS333: Are you *sure* \r\n is the right thing to send?  Note that '\n' might not send a plain newline.
14:08:31 <rwbarton> DavidS333: (Anyways, you probably don't want 'show (contents)' but rather just 'contents', but that's not the main problem here)
14:08:35 <dmwit> DavidS333: Are you sure you want to show the contents?
14:08:56 <dmwit> DavidS333: (You probably actually want to UTF8-encode it, instead, for example, or some such thing.)
14:09:04 <rwbarton> DavidS333: What do you mean by "weird symbol"?  Can you paste the output?
14:09:13 <dmwit> DavidS333: As a side note: reading a .png as a String might not really be what you want. =P
14:09:20 <DavidS333> Well right now Im not sending anything and Im running it locally but only using show (length contents)
14:09:33 <dmwit> In future compilers, that may attempt to read the file as a UTF-8 encoded Unicode String. =)
14:09:59 <dmwit> DavidS333: Why do you run tail on the filename?
14:10:22 <rwbarton> presumably to eat a leading '/'
14:10:33 <DavidS333> exacly. :P
14:10:42 <sjanssen> DavidS333: are you on Windows?
14:10:48 <DavidS333> yes
14:11:18 <sjanssen> "\n" actually outputs as "\r\n" in Windows
14:11:27 <rwbarton> Is it possible the file contains a ^D or a ^Z or something that Windows treats as end-of-file?
14:11:39 <sjanssen> so "\r\n" expands to "\r\r\n"
14:12:09 <sjanssen> DavidS333: also, you need to open the file in binary mode in order to find the size
14:12:21 <DavidS333> I see
14:12:34 <DavidS333> why is that?
14:12:43 <sjanssen> DavidS333: because Windows has silly newline conventions
14:13:15 <DavidS333> ok
14:13:52 <BMeph> DavidS333: Just curious: what does 'readMyFile' do that readFile does not? :)
14:14:30 <DavidS333> absolutly nothing... :)
14:15:24 <DavidS333> how do I open the file in binary mode in a compact way?
14:15:33 <sjanssen> @hoogle hOpenBinaryFile
14:15:33 <lambdabot> No results found
14:15:56 <sjanssen> @hoogle openBinaryFile
14:15:56 <lambdabot> System.IO openBinaryFile :: FilePath -> IOMode -> IO Handle
14:17:05 <rwbarton> @src readFile
14:17:06 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
14:17:37 <rwbarton> You could define  readBinaryFile name = openBinaryFile name ReadMode >>= hGetContents
14:17:46 <DavidS333> cool
14:18:09 <dons> ?users
14:18:10 <lambdabot> Maximum users seen in #haskell: 518, currently: 505 (97.5%), active: 22 (4.4%)
14:19:12 <TomMD> Humm, thats a lot of people.  I think I only know six of them though.
14:19:25 <mohbana_> hi, can't i define functions on the hugs console?
14:19:28 <DavidS333> It works! Thanks!
14:19:44 <Beelsebob> mohbana_: you can -- use let
14:20:30 <DavidS333> Anyone seen "*** Exception: <socket: 1848>: commitAndReleaseBuffer: failed (No error)" before?
14:20:54 <BMeph> TomMD: What do you mean by "know"? ;)
14:22:11 <nomeata> Is there a very good reason for the functional dependendency m -> r in the class MonadReader r m?
14:22:23 <TomMD> "Know of" Mostly.  I know dons to some extent.  I know of / have talked to you, coutts and a few others..
14:22:36 <nomeata> I find it inconvenient to not be able to stack more than one MonadReaders on top of each other (as long as the type of r differs).
14:23:11 <TomMD> I've had the pleasure of meeting Gill, Marrow and SPJ, but they dont show up often.  Well, Gill is always here but not talking usually.
14:23:19 <dmwit> nomeata: Hm, how about ReaderT/
14:23:31 <nomeata> For example, in a HAppS project, all the handlers have access to general information. Those that need a logged in user have an additional MonadReaader User m constraint, making sure that there is a user logged in.
14:23:41 <nomeata> dmwit: doesnât help, itâs in the typeclass:
14:23:48 <BMeph> TomMD: Heh-heh, i get it. :)
14:24:09 <nomeata> @type do { x <- ask ; y <- ask; return ( (x,y) :: (Int,Bool) ) }
14:24:10 <lambdabot> Top level:
14:24:10 <lambdabot>     Couldn't match expected type `Int' against inferred type `Bool'
14:24:10 <lambdabot>     When using functional dependencies to combine
14:24:17 <dmwit> nomeata: ReaderT a (Reader b) -- should be in both the MonadReader a and MonadReader b classes
14:24:25 <mohbana_> can someone please confirm if i have to load a file to define functions in hugs or does the interpreter accept functions defs
14:24:45 <dmwit> mohbana_: Use "let"
14:25:06 <nomeata> dmwit: I canât change the inner monad, but trying to stack two ReaderTâs has the effect that the computations can only acces the data of the innermost ReaderT instance.
14:26:00 <nomeata> The only reason I can think for the dependency is to make the "get" have a fixed type, for better type inference. But here it hurts.
14:26:51 <nomeata> > runReaderT (runReaderT (runIdentity ( do { x <- ask ; y <- ask; return (x,y) } ) True) ()
14:26:52 <lambdabot>   <no location info>: parse error on input `;'
14:27:01 <mohbana_> seems like you can't
14:27:17 <mohbana_> http://cvs.haskell.org/Hugs/pages/users_guide/faq.html#AEN1890
14:27:18 <lambdabot> Title: Frequently Asked Questions about Hugs
14:27:22 <sjanssen> mohbana_: hugs accepts expressions only
14:27:23 <nomeata> > runReaderT (runReaderT (runIdentity ( do { x <- ask ; y <- ask; return (x,y) })) True) ()
14:27:24 <lambdabot>   Couldn't match expected type `ReaderT r1 (ReaderT r m) a'
14:27:34 <mohbana_> sjanssen: thanks
14:27:36 <sjanssen> mohbana_: you can do something like "let f = foo in f x" in a pinch
14:28:15 <nomeata> Also, for that reason thereis no instance (MonadReader r m, MonadTrans t) => MonadReader r (t m).
14:28:41 <sjanssen> nomeata: I think removing the fundep would make the auto-lifting more-or-less useless
14:29:05 <nomeata> sjanssen: wouldnât it auto-lift until it finds a type that matches?
14:29:31 <dmwit> nomeata: Ah, I see what you mean.
14:29:55 <sjanssen> nomeata: no, because GHC can't prove the absence of an instance
14:30:10 <ddarius> > runReaderT (runReaderT (runIdentity (do x <- ask; y <- lift ask; return (x,y))) True) 'a'
14:30:11 <lambdabot>   Couldn't match expected type `Identity' against inferred type `t m'
14:30:42 <dmwit> nomeata: I guess the best you can do is use WrappedMonad.
14:30:49 <dmwit> (and declare an instance by hand)
14:31:01 <rwbarton> @type runReaderT
14:31:02 <lambdabot> forall r (m :: * -> *) a. ReaderT r m a -> r -> m a
14:31:13 <rwbarton> the T's should be on the inside, no?
14:31:24 <nomeata> hmm. Then itâs probably easier to have differnt reader types for all combinations that I need
14:31:30 <ddarius> > runReaderT (runReaderT (runIdentity (do x <- lift ask; y <- (lift . lift) ask; return (x,y))) True) 'a'
14:31:31 <lambdabot>   Couldn't match expected type `Identity' against inferred type `t m'
14:31:32 <Saizan> dmwit: that doesn't help, the problem is in the class
14:31:51 <rwbarton> > runIdentity (runReaderT (runReaderT (do x <- lift ask; y <- (lift . lift) ask; return (x,y))) True) 'a'
14:31:52 <lambdabot>   Couldn't match expected type `ReaderT r Identity a'
14:31:53 <sjanssen> nomeata: perhaps you could use a variant of MonadReader that allows you to name the layers?
14:32:08 <dmwit> Saizan: pardon?
14:32:16 <rwbarton> > runIdentity (runReaderT (runReaderT (do x <- lift ask; y <- (lift . lift) ask; return (x,y)) True) 'a')
14:32:17 <hackage> Uploaded to hackage: panda 2008.10.16
14:32:17 <lambdabot>       No instance for (MonadReader a Identity)
14:32:18 <lambdabot>        arising from a use of `...
14:32:26 <rwbarton> > runIdentity (runReaderT (runReaderT (do x <- ask; y <- (lift) ask; return (x,y)) True) 'a')
14:32:27 <lambdabot>   (True,'a')
14:32:40 <nomeata> sjanssen: different classes for different types? So, ReaderWebData, ReaderUser etc.?
14:33:13 <Saizan> dmwit: oh, you were responding to (MonadReader r m, MonadTrans t) => MonadReader r (t m) ?
14:33:22 <dmwit> right
14:33:34 <sjanssen> nomeata: add a "name" parameter to each ReaderT
14:33:40 <sjanssen> nomeata: I'll have a sketch of that in a moment
14:34:11 <nomeata> Or use these type lists inside the reader. So that Iâll have (MonadReader r m, HasUser r) as the context
14:37:18 <sjanssen> nomeata: I guess my idea runs into overlapping instances
14:37:28 <sjanssen> nomeata: but different classes would certainly work
14:39:43 <nomeata> These HLists, where can I find them again?
14:40:20 <lambdabot_tester> @type map
14:40:21 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
14:40:52 <lambdabot_tester> >type map
14:41:06 <lambdabot_tester> @pl \x -> x
14:41:06 <lambdabot> id
14:41:25 <lambdabot_tester> @help
14:41:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:41:32 <lambdabot_tester> @list
14:41:33 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
14:41:41 <dmwit> lambdabot: Hiya!
14:41:46 <dmwit> lambdabot_tester: Hiya!
14:42:03 <BMeph> lambdabot_tester: Hello, may we help you with something? :)
14:42:04 <dmwit> lambdabot_tester: You can also query lambdabot in a private message if you just want to play around with it.
14:42:20 <dmwit> lambdabot_tester: If you have questions about how any particular part of lambdabot works, definitely ask here, though. =)
14:42:37 <rwbarton> @vixen how does @pl work?
14:42:37 <lambdabot> how? it depends...
14:42:47 <dmwit> It works very well, thank you!
14:42:49 <dmwit> =)
14:44:10 <gwern> 'lo all
14:44:10 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
14:44:12 <gwern> any news?
14:44:18 <gwern> (seems so)
14:44:20 <gwern> @messages
14:44:20 <lambdabot> vixey said 3h 54m 28s ago: is this a mueval problem or something? vixey: @let asum = foldr (liftA2 (||)) (const False) lambdabot: Parse error
14:44:25 <nomeata> (duh. on hackage.)
14:45:31 * gwern frowns in nomeata's general direction
14:46:09 <nomeata> gwern: because of the mention of HList?
14:46:48 <nomeata> gwern: by the way, thanks for mueval. I ripped a lot of code for it for a web interface
14:47:02 <gwern> no no, you're not supposed to rip but import! :(
14:47:31 <nomeata> gwern: sorry, wasnât possible, as you put stuff on stdout, where I needed it as a string
14:47:38 <gwern> that's why the whole library/executable split
14:47:47 <nomeata> gwern: but Iâll see if I can put some useful patches back
14:47:57 <gwern> oh, was that the problem? I wonder how hard it'd be to change that
14:48:22 <gwern> I wasn't too thrilled at interminglging Interpreter and IO, but I didn't have any real reason to work at disentangling them
14:48:27 <nomeata> gwern: http://darcs.nomeata.de/bff/MyInterpret.hs
14:48:43 <nomeata> gwern: Iâm sure youâll recognize most of it :-9
14:49:14 <nomeata> gwern: is  setInstalledModsAreInScopeQualified True dangerous? I like not having to use temporary files.
14:49:16 * gwern notes that the comments certianly look familiar
14:49:17 <gwern>                     -- Time's up. It's a good day to die.
14:49:38 <gwern> I always got a chuckle out of that one, although I doubt anyone got the reference
14:49:49 <dmwit> Klingon?
14:50:09 <nomeata> gwern: And I had the feeling that your code would be killed, even if the interpreted part returns fast enough, as the watchdog thread isnât stopped
14:50:31 <nomeata> gwern: see my timeoutIO for how I think I got it to work.
14:50:53 <gwern> nomeata: well, the qualifide thing is about code using stuff from libraries/modules which haven't been asked for
14:51:00 <gwern> if you don't mind that, it's unnecessary
14:51:06 <BMeph> gwern: DS9? ;)
14:51:33 <gwern> that is, if you don't mind your code fragments/strings doing stuff like including 'Foreign.unsafePerformIO' when you had carefully *not* imported Foreign...
14:51:47 <nomeata> gwern: will ghc use any installed package, or only packages that are already loaded?
14:51:54 <dons> ibid: around?
14:51:57 <gwern> BMeph: yeah, but I suspect DS9 stole it from somewhere else. I could swear I've seen it in some japanese works
14:52:02 <Saizan> nomeata: this works if your types are sufficiently mononomorphic: http://hpaste.org/11100
14:52:14 <gwern> nomeata: in my experiments, it'll use any function from any module from any package ghc-pkg list shows
14:52:21 <gwern> if you don't
14:52:29 <gwern> *don't use the qualified bit
14:52:37 <Saizan> nomeata: i.e. you'll get some problem if you don't annotate 1 and i  with :: Int
14:52:50 <nomeata> gwern: hmm. ok. So I put my trust in the unsafe function.
14:52:56 <BMeph> gwern: Yeah, from what fuzziness I recall, TIAGDTD is a Lakota saying, but I'd have to "research" it to be sure... ;)
14:52:57 <gwern> nomeata: it's convenient for ghci, which is why such an odd behaivour is/was default
14:54:01 <nomeata> Saizan: nice! Why exactly do you need ReaderM'?
14:54:12 <gwern> (got fixed for 6.10, iirc, but unfortunately the ghc devs haven't adde qualified imports yet, so hint is likely going to keep needing temp files...)
14:54:55 <Saizan> nomeata: becuase neither of the two overlapping instances you'd like to write for ReaderM is more general than the other, so ghc can't pick one
14:55:04 <gwern> 'Top 10 things likely to be overheard if you had a Klingon Programmer: 7) Perhaps it IS a good day to die! I say we ship it!'
14:55:32 <nomeata> gwern: so do you think is still responsible to have setInstalledModsAreInScopeQualified True?
14:55:50 <gwern> nomeata: how much do you trust your evaluated code, and what compiler are you using?
14:56:17 <nomeata> gwern: public web interface, and not sure yet (I donât run the serveR)
14:56:30 <nomeata> gwern: 6.8.2 or 6.8.3 most likely
14:56:33 <Saizan> nomeata: more details here http://www.haskell.org/pipermail/haskell/2004-June/014176.html
14:56:34 <lambdabot> Title: [Haskell] The two-class trick
14:57:20 <gwern> trusted && _ == don't use; untrusted && 6.8:_ == use; untrusted && 6.10:_ = don't use (but you should check to see that the problem really was fixed)
14:58:13 <gwern> '# Our users will know fear and cower before our software! Ship it! Ship it and let them flee like the dogs they are!'
15:00:55 <nomeata> gwern: Iâm confused. With trusted, I surely can use setInstalledModsAreInScopeQualified True? (not False)
15:01:22 <gwern> nomeata: I am unsure which way is the safe way
15:01:28 <gwern> the name, perhaps, is suboptimal
15:01:36 * gwern suggests looking at the haddocks/code
15:01:59 <nomeata> ok, thx
15:02:06 * nomeata goes to bed, good night everyone
15:02:07 <gwern> hm. if the safe way is not 'False', then mueval has a problem
15:03:18 <vixey> gwern did you get my message
15:03:25 <gwern> vixey: yes
15:03:27 <schleven> how close to the machine could haskell be bootstrapped? meaning, if you wanted to do haskell-programming on as low level as possible, where would that be?
15:03:35 <vixey> what does it mean?
15:03:37 <gwern> but then nomeata distracted me and I forgot about it
15:03:47 <schleven> im learning C right now and im amazed that people write huge systems in it, so primitive and unsafe
15:04:18 <schleven> would it be reasonable to implement haskell core in assembler than start haskellign away and just skip c?
15:04:20 <vixey> ok
15:04:25 <gwern> schleven: enough man-hours, and you can polish even a brick into a mirror
15:04:42 <schleven> philosphy of linux?
15:04:58 <schleven> doent really answer my question
15:04:58 <vixey> schleven: yeah it's crazy that people still use C for the things they do
15:04:59 <gwern> nah, that's the unix way
15:05:07 <gwern> or more generally, that's the Worse is Better way
15:05:18 <sjanssen> schleven: you could theoretically write a Haskell run time system in an assembly language
15:05:18 <gwern> (if you haven't read Worse is Better, this is a good opportunity)
15:05:21 <schleven> but what about haskell?
15:05:23 <dons> schleven: the ghc runtime runs on bare metal.
15:05:33 <dons> so you can boot ghc rts on the hardware, then run haskell programs.
15:05:33 <schleven> dons: oh really
15:05:39 <dons> as long as they don't need the filesystem, say.
15:05:45 <schleven> cool
15:05:52 <dons> yeah, so there's house (ghc as an OS on bare metal), and halvm, ghc rts on xen
15:05:57 <schleven> very cool indeed, there is some OS-experiments doen with haskell right?
15:05:59 <rwbarton> schleven: http://programatica.cs.pdx.edu/House/
15:06:01 <dons> both acting as microkernels giving you a ghc runtime
15:06:02 <lambdabot> Title: House
15:06:26 <Peaker> they still use memory separation though, right?  Why not just eliminate unsafe stuff instead of processes?
15:06:35 <Peaker> and capabilities, ofcourse :)
15:07:20 <schleven> worse is better the wikipedia article, the jwz article or something else?
15:08:10 <gwern> the rpg article
15:08:22 <gwern> you won't go wrong reading those after the original, tho
15:09:48 <gwern> vixey: well, I'm a little confused. initially I thought perhaps it was due to mueval not exposing Control.Applicative (for liftA2), but I see that it does
15:09:58 <gwern> so I'm wondering where 'Parse error' is coming from
15:10:16 <schleven> It is more important for the interface to be simple than the implementation.  vs It is more important for the implementation to be simple than the interface.
15:10:22 <vixey> me too!
15:10:31 <schleven> hmm worse is better is lazy problem-solving in my opinion
15:10:51 <gwern> it doesn't seem to be staticly in the lb source
15:10:53 <schleven> make it easy for yourself, hard for the next instead of solving a problem really well once and not having to solve it again
15:11:16 <gwern> right now I'm wondering if the asum def is even making it into L.hs, but it seems my local lb is borked, so I'm doing some reinstalling
15:11:31 <gwern> schleven: I sometimes think of it as software's Gresham's Law
15:12:37 * gwern fixes lb, and finds simple @lets work, but asum doesn't
15:13:03 <rwbarton> Could it be because there is already a Data.Foldable.asum?
15:13:11 <rwbarton> @type asum
15:13:12 <lambdabot> forall a. (Num a) => a -> a
15:13:25 <gwern> rwbarton: no. I can define asum, if I replace || with &&
15:13:33 <rwbarton> oh, mmorrow told me about this.
15:13:34 <gwern> interesting
15:13:51 <rwbarton> It's some extra syntax defined by haskell-src-exts, or something, I don't remember the details.
15:14:04 <gwern> @let asum = foldr (liftA2 (&&)) (const False)
15:14:04 <lambdabot>  <local>:4:0:
15:14:04 <lambdabot>      Multiple declarations of `L.asum'
15:14:04 <lambdabot>      Declared at: <local...
15:14:08 <dancor> schleven: the rpg article is in the unix-haters handbook: http://www.simson.net/ref/ugh.pdf
15:14:10 <lambdabot> Title: The UNIX- HATERS Handbook
15:14:15 <gwern> @undefine asum
15:14:30 <rwbarton> , (||) True False
15:14:32 <lunabot>  True
15:14:40 <gwern> dancor: incidentally, esr recently reviewed the handbook with an eye to seeing how well it's aged and how relevant it still is
15:14:53 <gwern> interesting review, I thought, as foolish as esr often is
15:15:12 <dancor> good old esr
15:15:16 <gwern> rwbarton: you know anything else?
15:15:33 <rwbarton> I believe mmorrow patched the version of haskell-src-exts or whatever used by lunabot to remove this syntax
15:16:02 <rwbarton> But it used to be that ( || ) worked, and (||) did not, because something was defining a (| ... |) kind of bracket
15:16:22 <gwern> @let asum = foldr (liftA2 ( || )) (const False)
15:16:23 <lambdabot>  Defined.
15:16:29 <gwern> huh
15:16:33 <rwbarton> Let me take a look at the logs
15:18:20 <rwbarton> gwern: http://tuukka.iki.fi/tmp/haskell-2008-10-01.html#19:49:52
15:18:24 <lambdabot> Title: haskell-2008-10-01
15:18:27 <gwern> maybe I spoke too soon; defining either asum in a file for mueval doesn't work, as it doesn't see liftA2 as defined
15:18:29 <gwern> hum
15:18:40 <schleven> i read the jwz peter gabriel and is ee his points, they are good. im rethinkign my earlier position
15:18:47 <gwern> is that a consequence of my broken experimental mueval or is it a stock mueval problem...
15:19:20 <rwbarton> > (||) True False
15:19:21 <lambdabot>   True
15:19:26 <gwern> '(i just commented out all that extra syntax in my copy of haskell-src-exts)'
15:20:22 <gwern> @seen mmorrow
15:20:22 <lambdabot> I saw mmorrow leaving #haskell, #ghc and #darcs 47m 52s ago, and .
15:20:30 <gwern> dang it
15:20:46 <rwbarton> Oh yeah, so the asum thing was weird because the definition worked in > but not in @let
15:21:02 <rwbarton> @let asum_rwbarton = liftA2 (||) (const False)
15:21:03 <lambdabot>   Parse error
15:21:21 <rwbarton> @let asum_rwbarton = foldr (liftA2 (||)) (const False)
15:21:21 <lambdabot>   Parse error
15:21:40 <rwbarton> > (foldr (liftA2 (||)) (const False) [isDigit, isAlpha]) '3'
15:21:41 <lambdabot>   True
15:21:46 <gwern> @ask mmorrow have you contacted the haskell-src-exts guys about the (||) error? did they say when it would be fixed? it'd be nice if they could fix and release, since I'm still waiting on another fix of theirs to make it into a released version
15:21:46 <lambdabot> Consider it noted.
15:22:01 <Berkay18> .
15:25:31 <gwern> vixey: so to summarize: it's their problem, it's not my fault, I didn't do it, you can't prove anything, and if you could no jury in the world would convict me
15:26:08 <vixey> I don't know who to blame!
15:26:09 <araujo> hi ho!
15:26:30 <gwern> vixey: let's blame the mimes. they won't talk
15:27:51 <gwern> dagnabbit. stock mueval also has liftA2 problems
15:28:20 <gwern> oh, but it's only in load-file
15:28:32 <gwern> well, I've always suspected load-file was broken, so that's no surprise
15:29:44 * gwern decides to have some dinner
15:31:42 <Cale> gwern: I've hackily patched all the checkNames stuff out of mueval, because it was causing problems for no real security benefit. The things it is protecting against are not in scope anyway.
15:40:00 <BMeph> "C is therefore a language for which it is easy to write a decent compiler, and it requires the programmer to write text that is easy for the compiler to interpret." BWAHAHAHA! That's rich! This guy should've wrote comedy! ;p
15:40:21 <BMeph> But wait - he DID! ;p
15:41:36 <pumpkin_> I'd imagine the parser for haskell must be rather complex?
15:42:08 <vixey> yeah parsing a language like haskell sucks
15:42:10 <Pseudonym> Not as complex as you might think.
15:42:43 <Pseudonym> The only tricky bit is the offside rule.
15:43:14 <BMeph> "Unix and C are the ultimate computer viruses." Hmm, that's going into my signature file... :)
15:43:30 <Pseudonym> BMeph: They used to say that of MS DOS.
15:43:49 <Pseudonym> It's basically a 30-year-old joke, and they just change the nouns around.
15:44:04 <Pseudonym> It's more true in the case of DOS, because it had a habit of installing itself on floppies.
15:44:38 <Philonous> You can hardly get a PC without windows these days, so I think describing windows as a virus isn't too far fetched
15:44:46 <Cale> Pseudonym: I would include infix operators in the tricky bits :)
15:44:53 <BMeph> Pseudonym: I definitely preferred CP/M, but then, I'm a old FORTH-monger... ;)
15:45:30 <Pseudonym> CP/M didn't install itself on flippies, though.
15:45:32 <Pseudonym> Cale: Really?
15:45:34 <Cale> (because of fixity declarations and the need to patch things up afterward)
15:45:41 <Pseudonym> That's no worse than C.
15:45:46 <Cale> They make the grammar context sensitive.
15:45:52 <Pseudonym> Where you need to propagate typedefs back to the lexer.
15:46:02 <Cale> Wait, what?
15:46:30 <Pseudonym> The grammar for C is not LR(1) (let alone LALR(1)).
15:46:32 <Zao> Pseudonym: C++ is more fun.
15:46:39 <Pseudonym> Yeah, C++ is ambiguous.
15:47:05 <Cale> Why do you need to propagate typedefs back to the lexer?
15:47:14 <Pseudonym> To parse C with a yacc-like tool, the lexer needs to be able to tell the difference between a type name and a symbol name.
15:47:23 <Cale> hmm
15:47:49 <pumpkin_> yup
15:48:26 <Pseudonym> The official grammar also has the if-else ambiguity, but that's not difficult.
15:50:05 <Pseudonym> Yes, C++ is even worse because of this:
15:50:15 <Pseudonym> Foo somevar(1);
15:50:27 <Pseudonym> Uhm.
15:50:31 * Pseudonym thinks
15:50:34 <Pseudonym> No, that's not it.
15:50:37 <Pseudonym> Ah, yea.
15:50:42 <Pseudonym> Foo somevar();
15:50:58 <Pseudonym> That could be a function declaration or it could be a variable declaration with a call to the default constructgor.
15:51:03 <Pseudonym> constructor
15:51:08 <Pseudonym> Or something like that.
15:51:34 <tristes_tigres> hello
15:51:40 <Pseudonym> And there are semantic rules for disambiguation.
15:52:04 <tristes_tigres> Say, any tips on how to get the utput out of this arrow ? http://hpaste.org/11101
15:52:21 <Cale> Pseudonym: I'm still not entirely sure I see the reason that the lexer cares about the difference between those. I can see how the parser would of course.
15:52:58 <Zao> Pseudonym: "If it looks like a function declaration, it is one."
15:53:17 <Pseudonym> Cale: THe parser cares about the difference, yes.l
15:54:04 <Pseudonym> But the thing is, the C grammar requires that typedef names and other identifiers be separate types of token.
15:54:10 <Pseudonym> Otherwise it's not LR(1).
15:54:14 <Cale> oh
15:54:18 <Cale> What is it then?
15:54:19 <Pseudonym> I believe (not sure) that it's LR(2).
15:54:26 <Cale> oh, well, that's not bad
15:54:30 <Pseudonym> Never actually checked that.
15:54:41 <Pseudonym> But pretty much all C parsers feed back typedef declarations to the lexer.
15:54:54 <Cale> I'd just make the lexer straightforward and give myself the extra lookahead.
15:54:58 <Pseudonym> WHich, if you think about it, is no worse than what Haskell does.
15:56:14 <Pseudonym> Yeah, just giving extra lookahead hasn't a bad plan in principle.
15:56:16 <Cale> But in Haskell, dealing with fixity declarations makes the grammar not even regular.
15:56:56 <Pseudonym> Hang on, isn't it true that you can do the trick that Gofer did of collecting expressions as a list of tokens, and then reparsing them later?
15:56:56 <Cale> Sure, the fix is not so bad.
15:57:00 <Cale> yeah
15:57:11 <Peaker> I thought regular grammar couldn't handle any form of nesting, wouldn't that be context-free, not regular?
15:57:12 <Cale> That's basically what we do, as far as I know.
15:57:16 * Pseudonym nods
15:57:36 <Cale> Er, context free I mean
15:57:51 <Cale> Sorry about that :)
15:57:58 <Peaker> yeah, so both C and Haskell aren't context-free
15:58:08 <Pseudonym> C is context-free.
15:58:10 <Cale> Peaker: C is context free.
15:58:24 <Cale> LR(2) is a subset of context free.
15:58:26 <Pseudonym> At least C89 is.
15:58:40 <gwern> Cale: but how can we be sure they aren't out of scope?
15:58:40 <tristes_tigres> is it appropriate to make fibs instance of Kleisli arrow perhaps ?
15:58:47 <rwbarton> tristes_tigres: No clever ideas, how about runArrow :: SP a b -> [a] -> [b] ; runArrow (Get f) (a:as) = runArrow (f a) as; runArrow (Put b g) as = b : runArrow g as
15:58:51 <Cale> gwern: Because we don't import them?
15:58:51 <Peaker> Cale: ...  int main() { blah(x); }   is x a variable or an arg to blah?
15:58:53 <dons> current broken packages with ghc 6.10
15:58:54 <dons>  http://www.haskell.org/pipermail/haskell-cafe/2008-October/049156.html
15:58:56 <lambdabot> Title: [Haskell-cafe] 2008-10-12 Hackage status with GHC 6.10 release candidate, http://tinyurl.com/4z5rvg
15:58:58 <dons> if you maintain something, have a look
15:59:01 <gwern> Cale: we didn't import them before, yet there they were
15:59:05 <dons> if you don't, and use one of these packages, have a look
15:59:18 <Cale> gwern: hm?
15:59:27 <gwern> @tell mmorrow the #haskell conversation about (||) I refer to can be found in http://tuukka.iki.fi/tmp/haskell-2008-10-01.html#19:49:52 btw
15:59:27 <lambdabot> Consider it noted.
15:59:42 <Cale> gwern: If you don't import any module which exports unsafePerformIO, then it won't be in scope.
15:59:51 <gwern> Cale: the ghc api allowed not-imported stuff to be used by default. checkNames defeats that even if the ghc api is being treacherous
15:59:53 <Pseudonym> Who's maintaining EdisonCore these days?
15:59:58 <Cale> gwern: We've made mistakes about which modules are okay to import before.
16:00:00 <gwern> rob docker, iirc
16:00:05 * Pseudonym nods
16:00:08 <Peaker> Cale: with a typedef for blah, its a variable. Without it, its a func-call.  That means its not context-free
16:00:19 <Cale> > System.IO.Unsafe.unsafePerformIO (print 5)
16:00:21 <lambdabot>   /tmp/9204546528159781350:67:36:
16:00:21 <lambdabot>      Not in scope: `System.IO.Unsafe.unsafe...
16:00:24 <gwern> Cale: in other words, it's not true that if you don't import...it won't be in scope
16:00:37 <Cale> gwern: That option is turned off.
16:00:43 <Cale> gwern: So they're not in scope.
16:00:49 <Cale> As you can see from the above ;)
16:01:00 <gwern> that option. for now. it's not a good track record, if you follow...
16:01:04 <tristes_tigres> rwbarton: hmm, so arrow is not like monad so you can get stuff out of it ?
16:01:11 <Cale> Don't be so paranoid ;)
16:01:20 <Pseudonym> Peaker: Sorry, this is in C89?
16:01:31 <Peaker> Pseudonym: typedef? of course
16:01:40 <gwern> Cale: it's not paranoia if they're out to get you!
16:01:45 <Pseudonym> No, the alleged ambiguity.
16:01:58 <rwbarton> tristes_tigres: huh?
16:02:00 <Peaker> Pseudonym: why wouldn't it be?
16:02:01 <Pseudonym> Can you give an example expression?
16:02:10 <Pseudonym> Or statement/decl, I guess.
16:02:16 <rwbarton> tristes_tigres: for any particular monad, you might be able to get stuff "out of it"
16:02:38 <rwbarton> tristes_tigres: e.g., you can get stuff out of [], Maybe, State s, .....
16:02:42 <tristes_tigres> rwbarton : OK? not lioke IO monad
16:02:46 <rwbarton> tristes_tigres: if you know the implementation
16:03:02 <rwbarton> tristes_tigres: Right, not the IO monad.
16:03:03 <tristes_tigres> OK, I mean it's not like IO monad
16:03:14 <tristes_tigres> rwbarton: thanks for the tip
16:03:25 <Peaker> Pseudonym: I am using "-std=c89" and yes
16:03:37 <Pseudonym> Cool.  What is it?
16:03:56 <opqdonut> why not c99?
16:04:08 <Peaker> Pseudonym: http://hpaste.org/11102
16:04:18 <Pseudonym> opqdonut: Because I have my copy of K&R open.
16:04:24 <tristes_tigres> rwbarton: amended with runArrow (Get f) [] = []; it does the trick
16:04:35 <gwern> opqdonut: because he wants to party like the tech bubble isn't bursting
16:05:10 <rwbarton> tristes_tigres: huh, I wonder how that can be necessary...
16:05:10 <opqdonut> gwern: :D
16:05:34 <Cale> Hmm, I forget if I ever came to a good solution to this problem: Is there a purely algebraic description of the syntactic monoids of context-free languages?
16:05:52 <Peaker> Pseudonym: The expression is: blah(c);  you're allowed to use int (c); to define c as an int
16:06:18 <Pseudonym> Hmm.  Actually, you're right.
16:06:18 <rwbarton> Cale: Monoids?
16:06:23 <Pseudonym> THe person who claimed it was LR(2) is therefore wrong.
16:06:26 <Pseudonym> Well caught.
16:06:32 <tristes_tigres> rwbarton: /me learning arrows by trial and error
16:06:43 <tristes_tigres> need to see how it all works
16:07:01 <Pseudonym> And it's even more of a problem in C99 because you can freely mix declarations and statements,.
16:07:08 <rwbarton> It doesn't make any difference if you remove that [] case, does it?
16:07:11 <tristes_tigres> what can be necessary ? the runArrow (Get f) [] = []; ?
16:07:20 <rwbarton> Yeah, what if you remove it?
16:07:31 <Pseudonym> Thanks, Peaker.
16:07:40 <Peaker> Pseudonym: sure
16:08:38 <tristes_tigres> rwbarton: nonexhaustive pattern error when you use it as getFibs n = runArrow fibs [1..n]
16:08:40 * Cale tries to think if this is really the question he wants to ask :)
16:09:20 <rwbarton> tristes_tigres: Oh, I was assuming you'd run it as runArrow fibs (repeat undefined) because fibs doesn't look at its input
16:09:22 * gwern watches Cale look for unknown unknowns
16:09:23 <Cale> rwbarton: L is a regular language if and only if it is the preimage of a subset of a finite monoid under a homomorphism from the free monoid on some alphabet.
16:09:28 <Pseudonym> It still suggests that an appropriate response is to parse the ambiguity as an ambiguity and resolve it at semantic analysis time.
16:09:31 <rwbarton> tristes_tigres: also, I should have called runArrow runSP
16:09:44 <Pseudonym> If nothing else, it has the possibility of better error messages.
16:10:18 <Cale> rwbarton: Which I think is an absolutely beautiful characterisation. What I'm wondering is how nice the analogous description is for context-free languages.
16:11:02 <Pseudonym> Cale: If I had to guess, I'd say quantum parsers.
16:11:35 <Pseudonym> I actually don't find it that difficult to compose grammars with spinor algebra these days.
16:12:09 <Pseudonym> Though I can't yet "see" that the algebraic form and the grammar form are equivalent to my satisfaction.
16:12:28 <Pseudonym> The trouble is that generally speaking, you don't just want to match a CFG, you want to build the tree.
16:12:29 <Cale> Well, I can see the regular case fairly clearly.
16:12:30 <rwbarton> tristes_tigres: (I assumed 'stream' means an infinite list here)
16:12:32 <Pseudonym> So the tree is the most appropriate form.
16:12:41 <Cale> There are still some things which trouble me there.
16:12:42 <tristes_tigres> runArrow fibs (repeat undefined)
16:12:52 <tristes_tigres> I mean take 10 $ runSP fibs (repeat undefined)
16:13:05 <tristes_tigres> rwbarton: OK, thanks, this work too
16:13:13 <tristes_tigres> need to think it over
16:13:32 <Cale> I got a bit stuck on describing the concatenation of languages in a purely algebraic way.
16:14:01 <Cale> Might get it if I keep trying :)
16:14:21 <Pseudonym> Oh, one thing that might help.
16:14:24 <Cale> (I mean in a categorical way in terms of the monoid homomorphisms)
16:14:39 <Pseudonym> I do believe that all CFGs can be expressed as the _inverse_ homomorphism applied to a Dyck grammar.
16:14:45 <Cale> hmm
16:14:50 <Pseudonym> Sorry, an inverse homomorphism.
16:15:08 <Pseudonym> Which makes sense when you think about it.
16:15:34 <Pseudonym> It suggests that all CFGs are basically languages of nested parentheses.
16:15:49 <Pseudonym> Ah, no, not inverse homomorphism.  Homomorphism.
16:16:02 <Cale> By inverse homomorphism, you mean preimage?
16:16:19 <Cale> mm, okay
16:16:27 <Pseudonym> Sorry, caffeine not kicked in fully yet, and can't recall wht Harrison had to say about it.
16:16:50 <Pseudonym> But if you consider, for example, a^n b^n, it's isomorphic to the one-parenthesis language.
16:16:57 <Cale> yeah
16:17:12 <Pseudonym> Well, one-nested-parenthesis.
16:17:27 <Cale> I'd appreciate any good references you have on this sort of thing, but I have to run to dinner :)
16:17:30 <newsham> S -> (S) | empty;
16:19:17 <tristes_tigres> :r
16:20:40 <tristes_tigres> rwbarton: thanks for your help, good night
16:23:42 <dobblego> Pseudonym, is this you? http://realtimecollisiondetection.net/blog/?p=81#comment-2379
16:23:44 <lambdabot> Title: 29 realtimecollisiondetection.net - the blog 29 Â» Design patterns are from hell ...
16:25:51 <mib_7pglvoua> > 1 + 1
16:25:52 <lambdabot>   2
16:26:41 <yewT> > read "5" < (5::Int)
16:26:42 <lambdabot>   False
16:26:49 <yewT> anyone here?
16:26:55 <gwern> what is read "5"?
16:27:07 <yewT> dunno
16:27:13 <gwern> > (read "5 :: Int) == (5::Int)
16:27:14 <lambdabot>   <no location info>:
16:27:14 <lambdabot>      lexical error in string/character literal at chara...
16:27:20 <gwern> > (read "5" :: Int) == (5::Int)
16:27:21 <lambdabot>   True
16:27:27 <yewT> oh i see
16:27:29 <gwern> > (read "5" :: Int) == 5
16:27:29 <yewT> gwern
16:27:30 <lambdabot>   True
16:27:31 <ddarius> dobblego: Yes, it is.
16:27:35 <yewT> is it possible to compare string with string?
16:27:49 <yewT> > read "abc" == ("abc"::String)
16:27:51 <lambdabot>   * Exception: Prelude.read: no parse
16:28:12 <gwern> interesting. ah, it must be the fromInteger coercion which makes 5 == 5::Int
16:28:15 <Peaker> I very much disagree with "design patterns from hell".  Many of them are OO specific (none language specific), but that doesn't negate their usefulness as knowledge.  Some of them are language neutral.  The strategy pattern is useful in OO and Functional languages alike
16:28:28 <gwern> > (5::Int) == (fromInteger 5)
16:28:29 <lambdabot>   True
16:28:39 <Peaker> Of course there are "generic tips" that are useful in a broad generic sense, even if "Each situation is different"
16:30:43 <lament> the idea of patterns, itself, nicely formulated, is worth more than the actual patterns
16:30:43 <yewT> gwern >>> read "abc" == ("abc"::String)
16:31:07 <lament> it's a very good idea, and while obvious in retrospect, it's a pretty significant one
16:31:11 <gwern> yewT: what do you want 'read "abc"' to produce?
16:31:23 <yewT> "abc" ?
16:31:31 <yewT> is it possible to produe the same thing?
16:31:45 <yewT> i just wanna know whether i could compare string with string as read :: string -> a
16:31:50 <gwern> is abc supposed to be a number of some kind? a String? a list? is it the Show output of some 'data' type you wrote? it could be anything
16:32:01 <yewT> "abc" is bascially a string
16:32:06 <gwern> > (read "abc" ::String) == ("abc")
16:32:07 <lambdabot>   * Exception: Prelude.read: no parse
16:32:17 <hackage> Uploaded to hackage: hackage-sparks 0.2
16:32:30 <gwern> I suppose it makes no sense for read to be 'id'
16:32:40 <gwern> > "string" :: String
16:32:41 <lambdabot>   "string"
16:32:41 <yewT> id?
16:32:49 <gwern> id == identity function
16:33:09 <Igloo> The problem is when you want to do     read "(foo, 1)" :: (String, Int). How would read know where the string was supposed to finish?
16:33:22 <gwern> if you give read some String, and you want it to return that same String, you've defined String -> String, or more generally a -> a
16:33:24 <geezusfreeek_> > read :: ("\"abc\"" :: String) == "abc"
16:33:25 <lambdabot>   <no location info>: parse error on input `"'
16:33:26 <gwern> @hoogle a -> a
16:33:26 <lambdabot> Prelude id :: a -> a
16:33:26 <lambdabot> Data.Function id :: a -> a
16:33:26 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
16:33:53 <geezusfreeek_> uh what did i do
16:34:09 <geezusfreeek_> > (read "\"abc\"" :: String) == "abc"
16:34:10 <lambdabot>   True
16:34:33 <Twey> `(a -> a) -> a -> a` does not count as a -> a :-\
16:34:36 <gwern> read shucks off the string wrapper to get at the tasy innards
16:34:59 <gwern> Twey: I suspect hoogle is looking at currying opportunities there
16:35:04 <yewT> geezusfreeek, why does that one work, whats the function of the back slashes \
16:35:12 <gwern> everywhere id == id
16:35:16 <geezusfreeek_> puts quotes inside the string
16:35:22 <geezusfreeek_> > show "abc"
16:35:24 <lambdabot>   "\"abc\""
16:35:28 <geezusfreeek_> see?
16:35:30 <yewT> oh ok
16:35:32 <yewT> thanks :)
16:35:38 <Twey> gwern: Ahh
16:36:03 <yewT> hi Twey
16:36:09 <Twey> gwern: Not necessary you know
16:36:15 <Twey> Er
16:36:16 <Twey> geezusfreeek_**
16:36:26 <gwern> Twey: hoogle does some pretty cool things internally. I never would've suspected type searching to be so difficult if not for reading various things by ndm
16:36:27 <Twey> > read "\"abc\"" == "abc"
16:36:28 <lambdabot>   True
16:36:39 <Twey> It can only be a String, because you're comparing it to a String.
16:37:05 <geezusfreeek_> i was being similar to the tries that were above
16:37:09 <Twey> gwern: I'm in awe of it, but that's not hard :-P
16:37:16 <gwern> it is to me
16:37:51 <gwern> or to put it another way, I've not heard of similar work for other languages
16:38:22 <Twey> I don't think it would be very useful in most type systems
16:38:22 <yewT> @hoogle a -> String
16:38:23 <lambdabot> Distribution.Text display :: Text a => a -> String
16:38:23 <lambdabot> Prelude show :: Show a => a -> String
16:38:23 <lambdabot> Text.Show show :: Show a => a -> String
16:38:41 <Twey> Imagine looking for every C function of type int, char*
16:38:59 <yewT> read (show x) << good?
16:39:14 <Twey> yewT: Lovely, and useless
16:39:17 <Twey> :-P
16:39:22 <yewT> since read needs string argument, and show convert it to a string
16:39:35 <geezusfreeek_> > read (show "abc") == "abc"
16:39:35 <yewT> show = putstr?
16:39:36 <lambdabot>   True
16:39:47 <geezusfreeek_> :t putStr
16:39:48 <lambdabot> String -> IO ()
16:39:48 <geezusfreeek_> :t show
16:39:49 <lambdabot> forall a. (Show a) => a -> String
16:40:01 <Twey> yewT: No... show just converts a value to a string, putStr actually outputs it.
16:40:13 <geezusfreeek_> @src print
16:40:14 <lambdabot> print x = putStrLn (show x)
16:40:15 <yewT> > read (show 4) < (5::Int)
16:40:17 <lambdabot>   True
16:40:46 <yewT> thanks geezusfreeek_
16:41:10 <geezusfreeek_> np
16:41:13 <Twey> > read (show 4) < 5
16:41:14 <lambdabot>   True
16:41:20 <schleven> pseudonym: which uni did you go to? umeå?
16:41:45 <schleven> and you were into AI but not statistics? what do you think of the field now tih the bayesian evolution?
16:42:14 <mib_qqsigp4i> hello all ... I used to program in c and c++ around 3 years ago ... I have completely lost touch. Hmmz given this backdrop i wanted to get to grips with haskell ... where do i begin ? is there a book out there  that avoids comparing haskell with other languages and teaches it to beginners ?
16:42:30 <gwern> schleven: he might not know if he hasn't updated his posteriors yet...
16:44:01 <pcc1> is there an implementation of the the search and replace stage described at http://www.cs.york.ac.uk/fp/HaXml/HaXml/Text-XML-HaXml-Verbatim.html which converts <e/> to <e></e> ?
16:44:14 <lambdabot> Title: Text.XML.HaXml.Verbatim, http://tinyurl.com/4ocy7l
16:44:35 <yewT> schleven, you could try yaht yet another haskell tutorial
16:45:09 <schleven> why?
16:45:17 <schleven> i am better at haskell than you
16:45:37 <gwern> pcc1: not that I know of, although I happen to have a tag search-and-replace program written using tagsoup
16:45:40 <schleven> map superior schlevens_skills
16:46:51 <yewT> mib_qqsigp4i you could try yaht yet another haskell tutorial
16:46:53 <pcc1> oh, this isn't for html. actually I'm tying to get my XML into canonical form: http://www.w3.org/TR/2001/REC-xml-c14n-20010315
16:46:55 <lambdabot> Title: Canonical XML
16:47:13 <yewT> schleven, i see the wrong person's message
16:47:19 <mib_qqsigp4i> yewT: tnx i will check that out ...
16:47:54 <yewT> mib_qqsigp4i >> http://learnyouahaskell.com/chapters
16:47:57 <lambdabot> Title: Learn You a Haskell for Great Good!
16:48:14 <yewT> mib_qqsigp4i >> http://micah.cowan.name/2008/09/26/computers/software-development/adventures-in-haskell/
16:48:17 <lambdabot> Title: micah.cowan.name Â» Adventures in Haskell, http://tinyurl.com/3q7ss9
16:52:41 <BMeph> yewT, mib_qqsigp4i: Also, don't forget RWH!
16:53:06 <Philonous> @type [1..10]
16:53:07 <lambdabot> forall t. (Enum t, Num t) => [t]
16:53:09 <BMeph> AKA: http://book.realworldhaskell.org/read/
16:53:12 <lambdabot> Title: Real World Haskell
16:53:14 <Saizan> dons: from your logs HAppS-Data failed to build, but it's not listed among the packages broken by 6.10, and i'm pretty sure it builds with 6.8.2
16:53:47 <adekoba> is there any way to match case expressions against espressions themselves? e.g. case 4 of; (3+1) -> True; _ -> False
16:54:02 <mauke> adekoba: no
16:54:17 <Saizan> ..for that particular case it works
16:54:34 <adekoba> > case 4 of; (3+1) -> True; _ -> False
16:54:35 <lambdabot>   <no location info>: Parse error in pattern
16:54:40 <Saizan> > case 4 of (3+1) -> True
16:54:41 <lambdabot>   <no location info>: Parse error in pattern
16:54:50 <Saizan> > case 4 of (n+1) -> True
16:54:51 <lambdabot>   True
16:54:56 <gwern> n+k patterns ftl
16:54:57 <Saizan> ah, sorry
16:55:02 <Saizan> one must be a variable
16:55:10 <geezusfreeek_> > case 4 of 4 -> True
16:55:11 <lambdabot>   True
16:55:26 <adekoba> lol, well yes. I was just using that as an example
16:55:32 <geezusfreeek_> case 3 + 1 of 4 -> True
16:55:38 <mauke> > let 4 = 3 in 4
16:55:39 <lambdabot>   4
16:55:49 <geezusfreeek_> > case 3+1 of 4 -> True
16:55:50 <lambdabot>   True
16:55:54 <adekoba> well since that doesn't work, and nesting guards does not work, am I stuck with using if/else's?
16:56:05 <rwbarton> > case 4 of x | x == 3+1 -> True
16:56:06 <lambdabot>   True
16:56:09 <geezusfreeek_> adekoba, what is it you are trying to do?
16:56:15 <yewT> bmeph, do you write haskell tutorial?
16:57:08 <BMeph> yewT: No, but I play one on the Internet! ;)
16:57:14 <gwern> I accidentally a haskell tutorial!
16:57:28 <adekoba> geezusfreeek_: well I'm using ByteString's, so I'm trying to do something like: case <bytestring> of; (pack [3,4,4]) -> True; (pack [2,1]) -> True; _ -> False
16:57:48 <adekoba> geezusfreeek_: and I don't want to unpack the original bytestring because it will be a performance hit
16:58:28 <mauke> gwern: is this bad?
16:58:30 <Cale> Pseudonym: Hmm, I guess one way of looking at my question is to suppose we take a free monoid Sigma*, and any pushdown automaton on the alphabet Sigma, and we mod out by the equivalence relation that two words v and w are equivalent if and only if for every possible state and stack, they cause the same state transition, we get another monoid. What class of monoids can we obtain in this way?
16:58:39 <gwern> hm. I wonder if you couldn't do 'case of (B.pack "foo") -> [2,1]; ...'
16:58:40 <BMeph> adekoba: Looks like pattern guards may be your bag. :)
16:58:56 <geezusfreeek_> adekoba, yeah, guards
16:58:58 <gwern> mauke: only if it was ok for GWB to accidentally the whole economy
16:59:14 <mauke> :-/
16:59:33 <Cale> (In particular, can we characterise them without explicit reference to automata?)
16:59:35 <Pseudonym> Cale, you know about spinor algebras, right?
16:59:37 <adekoba> geezusfreeek_, BMeph: I read that nesting guards is not possible? It's part of a larger function. Unless I make a separate function
16:59:48 <Cale> Pseudonym: I know of them. I'm not really very familiar.
16:59:53 <Pseudonym> Right.
16:59:58 <ddarius> Blech spinors
17:00:10 <ddarius> (or rather "spinor algebras")
17:00:10 <geezusfreeek_> adekoba, i don't see why it would be impossible as long as they are at different indentation levels. have you had problems nesting them?
17:00:13 <Pseudonym> ddarius: In this case, they're nice, because they're abstract.
17:00:24 <ddarius> GA all way
17:00:27 <Pseudonym> Essentially, a PDA is a FA with state actions.
17:00:30 * ddarius puts down pom-poms
17:00:41 <BMeph> adekoba: Yes, it sounds like you're already trying to do too much in one function. Why not break up your function into smaller, easy-to-digest parts? :)
17:01:03 <BMeph> ddarius: The cheerleading tool, or the mortar? ;)
17:01:07 <Pseudonym> So if you encode the state actions as symbols, a CFG is representable as a regular expression.
17:01:10 <adekoba> geezusfreeek_: doesn't look like it's implemented: http://thread.gmane.org/gmane.comp.lang.haskell.prime/1561
17:01:13 <lambdabot> Title: Gmane Loom
17:01:17 <schleven> if i free(p); and then do *p = 5; what should happen?
17:01:21 <schleven> is tha tundefined?
17:01:24 <adekoba> BMeph: is there no other way? I'd rather not, if I don't have to.
17:01:39 <geezusfreeek_> oh _directly_ nested guards
17:01:45 <Pseudonym> Sorry, stack ACTIONS.
17:01:46 <Pseudonym> Bleah.
17:01:51 <Pseudonym> My keyboard died last week, so I'm on the laptop keyboard.
17:01:54 <yewT> geezusfreeek, how do you underline directly
17:01:55 <Pseudonym> So sorry if I mistype styff.
17:01:57 <geezusfreeek_> yeah that isn't supported, and i think ideally you shouldn't really need them
17:02:02 <adekoba> yewT: _word_
17:02:11 <adekoba> yewT: with underscores on either side
17:02:14 <geezusfreeek_> put underscores around i
17:02:15 <geezusfreeek_> t
17:02:17 <Cale> schleven: This is #haskell, but yeah, I'm pretty sure that is not something you want to do ;)
17:02:19 <yewT> abc_
17:02:31 <ozy`> schleven: yes, that's undefined
17:02:33 <yewT> _abc_
17:02:36 <yewT> oh ok
17:02:38 <yewT> :D
17:02:45 <Pseudonym> The interesting thing is that the stack actions form an interesting algebra, and it's essentially the same as Dirac notation assuming an orthonormal basis.
17:03:03 <adekoba> geezusfreeek_: well what about this situation? What kind of nesting were you thinking of?
17:03:03 <mmorrow> Saizan: i forgot last night to try loading a haskell sym from a .o with hs-plugins. http://hpaste.org/11104
17:03:03 <lambdabot> mmorrow: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:03:23 <Twey> Cale: Mind if I /msg you?
17:03:29 <Pseudonym> If you assume a non-orthonormal basis, then you have a formal language formulation for quantum computing, but that's another topic.
17:03:29 <Cale> Twey: I don't mind.
17:03:37 <Philonous> Pseudonym: Can you suggest papers on that?
17:03:47 <mmorrow> Saizan: the Dynamic (well, Maybe a) is for `eval', but there's also unsafeEval.
17:03:49 <Pseudonym> Philonous: Yes, but it's easy enough to describe here.
17:04:00 <Pseudonym> Let 0 denote the empty set and 1 denote the empty string.
17:04:20 <Pseudonym> (I assume we all know the difference; it sometimes takes undergrads some time to work it out.)
17:04:29 <geezusfreeek_> adekoba, i will paste what i have in mind
17:04:37 <Pseudonym> Juxtaposition is concatenation, and + denotes set union.
17:04:48 <mmorrow> @tell gwern i have not contacted them about (||), but i will do that.
17:04:49 <lambdabot> Consider it noted.
17:04:59 <Pseudonym> So you have obvious laws like 0 E = 0, 1 E = E, 1 + 0 = 1 etc.
17:05:34 <Pseudonym> We add two types of symbols.
17:05:54 <Pseudonym> <i| is a push of symbol i onto the stack, and |j> is a pop of symbol j.
17:06:15 <mib_qqsigp4i> tnx BMeph but i tried rwh ... i always keep getting distracted with references to a thousand other languages in there and spend more time recalling what i has read ages back rather than understanding haskell ...
17:06:16 <Pseudonym> This satisfies the rule: <i| |j> = 1, if i=j, 0 otherwise
17:06:22 <Philonous> With concatenating a set to a string you mean the set of all concatenated string?
17:06:31 <Pseudonym> Right.
17:06:35 <Philonous> k
17:06:52 <Pseudonym> So you can think of that as an orthonormal vector space.
17:06:59 <geezusfreeek_> adekoba, eh, nevermind, taking too long for something i can just explain
17:07:02 <yewT> @tell yewT i am yewT
17:07:02 <lambdabot> You can tell yourself!
17:07:08 <yewT> lol
17:07:12 <Pseudonym> Stack operations also commute with terminal symbols.
17:07:20 <geezusfreeek_> adekoba, just make another function for the nested stuff
17:07:22 <Pseudonym> a <i| = <i| a
17:07:32 <yewT> > @tell yewT
17:07:32 <geezusfreeek_> adekoba, you can do it with "where" so it is still part of the same function definition
17:07:33 <lambdabot>   <no location info>: parse error on input `@'
17:07:36 <Pseudonym> So terminal symbols act like scalars, except that the product doesn't commute in general.
17:07:40 <Saizan> mmorrow: thanks for the test :)
17:07:40 <Pseudonym> ab /= ba
17:07:49 <Pseudonym> And that's it, pretty much.
17:08:03 <Pseudonym> a^n b^n, for example, is (a <1|)* (b |1>)*
17:08:15 <Pseudonym> Oh, yes, they also obey the change of basis law:
17:08:28 <Pseudonym> |1> <1| + ... + |n> <n| = 1
17:08:51 <Pseudonym> If the vectors form a complete basis (i.e. all stack symbols are present).
17:08:54 <adekoba> geezusfreeek_: eh, that's kind of lame. It creates a new function where there should not be one. But I suppose there is really no alternative
17:09:18 <geezusfreeek_> adekoba, what is wrong with another function? this is a functional language after all :)
17:09:46 <rwbarton> adekoba: your example didn't use nested guards anyways
17:09:56 <rwbarton> adekoba: unless you pasted something I missed
17:10:00 <Philonous> Ok thanks, I need a second to chew on that since I'm rather tired ^^
17:10:00 <Cale> Pseudonym: oh, very nice.
17:10:20 <adekoba> geezusfreeek_: well because it's only run once, it breaks the logical flow of the original function, and it adds an unnecessary function to the namespace
17:10:30 <Pseudonym> Yes, it's very cool.
17:10:52 <adekoba> rwbarton: I would like to use nested guards, but that is currently not implemented afaik
17:10:53 <geezusfreeek_> adekoba, could you show exactly what you have? i can show you what i would do
17:11:04 <adekoba> geezusfreeek_: yes, h.o.
17:11:10 <Pseudonym> Oh, Kleene star basically acts like exp.
17:11:12 <Pseudonym> But that's another topic.
17:11:35 <ddarius> generating functions...
17:11:43 <Pseudonym> Precisely.
17:11:58 <Pseudonym> E* = 1 + E + E^2 + ...
17:12:01 <rwbarton> In generatingfunction land, Kleene star = 1/(1-x)
17:12:09 <yewT> could anyone see the problem here ? map(p (show)) [1,2,3] where p x = read x < 5 ???
17:12:11 <Pseudonym> Which, if you remember that 1 + 1 = 1, is exp(E).
17:12:23 <Cale> Pseudonym: hmm...
17:12:27 <adekoba> geezusfreeek_: http://hpaste.org/11106, towards the end
17:12:50 <rwbarton> adekoba: just replace it with the case statement
17:13:00 <geezusfreeek_> adekoba, that if statement?
17:13:02 <mauke> p . show
17:13:02 <eprst> hi all. Could somebody help me with this please: http://hpaste.org/11105
17:13:03 <ddarius> yewT: What is read show
17:13:04 <adekoba> geezusfreeek_: yes
17:13:12 <Pseudonym> Cale: Want proof?
17:13:41 <adekoba> rwbarton: case statement doesn't work while refraining from unpacking the 'version' bytestring
17:14:07 <Cale> Pseudonym: So exp(x) = 1/(1-x) in this funny algebra?
17:14:14 <Pseudonym> Uhm, no.
17:14:25 <Pseudonym> E* is exp(E)
17:14:43 <Pseudonym> The actual reason is the way that its derivative acts.
17:15:16 <rwbarton> adekoba: http://hpaste.org/11106#a1
17:15:34 <geezusfreeek_> ah beat me to it
17:15:44 <geezusfreeek_> there is a second annotation too
17:15:45 <Cale> But surely 1/(1-E) = 1 + E + E^2 + ..., no?
17:16:03 <Pseudonym> Yes, but I don't believe that division enters into it here.
17:16:11 <adekoba> geezusfreeek_, rwbarton: I'll try this, thank you
17:16:12 <geezusfreeek_> there are combinations of both of those that would work as well
17:16:14 <rwbarton> Does the class CFG change if I require that there's a unique parse tree?
17:16:16 <Pseudonym> Certainly, (1-E) E* /= 1
17:16:31 <Pseudonym> Assuming that - is set difference.
17:16:50 <Pseudonym> OK.  THink of it this way.
17:16:55 <Cale> Mm, but it can't quite be set difference.
17:17:08 <Pseudonym> Consider just regular languages for the moment.
17:17:25 <Pseudonym> E is a set of strings.
17:17:40 <Pseudonym> Let d_a E = { w | aw \in E }
17:17:48 <Cale> yep
17:17:51 <Pseudonym> d_a E is itself regular.
17:18:12 <Cale> Yep.
17:18:14 <Pseudonym> Because you could imagine expressing E as a DFA, and just moving the start state to the state pointed to by the "a" transition.
17:18:36 <Pseudonym> d_a acts like a derivative with respect to a.
17:18:41 <Pseudonym> Example:
17:18:42 <Pseudonym> d_a a = 1
17:18:44 <Pseudonym> d_a b = 0
17:18:51 <Pseudonym> d_a (E + F) = d_a E + d_a F
17:18:59 <Cale> Sort of, at least :) The product rule is a little different iirc.
17:19:04 <Pseudonym> Right.
17:19:13 <Pseudonym> But there is a symmetric product that you can define.
17:19:24 <Pseudonym> The product rule is defined as follows.
17:19:37 <Pseudonym> Denote E(0) as the expression E with all terminal symbols replaced by 0.
17:19:52 <Pseudonym> E(1) is 1 if 1 \in E, or otherwise 0.
17:19:58 <Pseudonym> Sorry, E(0)
17:20:10 <Cale> yeah
17:20:17 <Pseudonym> So:
17:20:29 <Pseudonym> d_a (E F) = d_a E F + E(0) d_a F
17:20:33 <Pseudonym> So it's pretty close.
17:20:38 <Cale> yep
17:20:38 <yewT> > let map (p) (map(show)[1,2,3]) in p x = read x < 2
17:20:39 <lambdabot>   <no location info>: parse error on input `in'
17:20:45 <Pseudonym> Now.  Kleene star.
17:20:55 <Pseudonym> d_a (E*) = d_a E E*
17:21:01 <Pseudonym> See?  It's exp.
17:21:05 <yewT> > let map (p) (map(show)[1,2,3]) in p x = read x < 2 <<< how do i fix this?
17:21:06 <lambdabot>   <no location info>: parse error on input `in'
17:21:20 <Cale> With this funny derivative ;)
17:21:24 <Cale> Okay, I see that.
17:21:24 <Pseudonym> Right.
17:21:33 <Pseudonym> But it's not so funny if you think of it this way:
17:21:56 <Pseudonym> E(0) is 1 if the start state for the DFA of E is a final state, and 0 otherwise.
17:22:01 <Pseudonym> Correct?
17:22:02 <yewT> how do i map each value from the list into my p?
17:22:22 <Cale> The derivative is very natural, it's just not a derivation in the usual sense of the word.
17:22:28 <Pseudonym> Oh, you just wait.
17:23:07 <Cale> Right. w is in E if and only if (d_w E)(0) is 1
17:23:25 <Pseudonym> A state of a DFA is completely characterised by a) whether or not it's a final state, and b) its transitions.
17:23:32 <Pseudonym> In this notation, this means:
17:23:45 <Pseudonym> E = E(0) + a d_a E + b d_b E + ... + z d_z E
17:23:49 <Philonous> Ah, finally I get it. Yeah, that's pretty nifty. Kinda like regexp for context-free languages
17:23:50 <pumpkin_> this channel is starting to sound like my theory of computation course :P
17:23:58 <Pseudonym> That's Taylor's theorem!
17:24:23 <ddarius> What happens when you make generating functions with coefficients selected from a group of finite order...
17:24:24 <rwbarton> Uh, no it's not :P
17:24:28 <Pseudonym> Yeah, it is.
17:24:38 <ddarius> rwbarton: As he said earlier, 1+1 = 1
17:24:39 <Pseudonym> Think of the derivatives as partial.
17:24:43 <Cale> It's sort of analogous, but it's not directly.
17:25:26 <Pseudonym> It is directly, it just happens that in regular languages there's no remainder.
17:25:26 <Cale> Taylor's theorem normally involves powers of an element though.
17:25:38 <Cale> er
17:25:41 <Pseudonym> Cale: Remember, this is multi-variable.
17:25:47 <Cale> powers of the derivative
17:25:51 <Pseudonym> Each terminal symbol is a "variable".
17:26:16 <Cale> Right, but where's the rest of the infinite series?
17:26:29 <Pseudonym> There isn't one.  You only need one expansion step for regular languages.
17:26:34 * ddarius should read some of J. J. R. R. Rutten's work again (and see if anything new has been published)
17:26:45 <Saizan> that's the "there's no remainder" part?
17:26:50 <Pseudonym> Yup.
17:27:11 <Pseudonym> http://lambda-the-ultimate.org/node/2293 <- The gory details.
17:27:12 <Cale> It's a nice analogue anyway. :)
17:27:13 <lambdabot> Title: Derivatives of Regular Expressions | Lambda the Ultimate
17:27:27 <Cale> I'm sure that I've seen that result.
17:27:44 <rwbarton> It's not much of a result, per se :)
17:27:52 <ddarius> s/R./M./g
17:28:00 <Cale> I think I saw it in a paper by Brzozowski
17:28:12 <yewT> bye guys
17:28:12 <Pseudonym> rwbarton: I disagree.  It's a very useful result, because it leads directly to an algorithm for building DFAs directly from regular expressions.
17:28:26 <rwbarton> @src []
17:28:27 <lambdabot> data [] a = [] | a : [a]
17:28:30 <rwbarton> ^^ that is your result
17:28:55 <Pseudonym> Oh, sorry, mixed threads of discussion.
17:29:07 <Pseudonym> http://www.ninebynine.org/Software/HaskellRDF/Dfa/ <- Source code for the curious.
17:29:14 <lambdabot> Title: Index of /Software/HaskellRDF/Dfa
17:29:21 <ddarius> http://homepages.cwi.nl/~janr/papers/
17:29:27 <lambdabot> Title: Publications of Jan Rutten since 1995
17:30:14 <Cale> http://cale.yi.org/share/Regular.hs
17:30:16 <Cale> :)
17:30:32 * ddarius thinks he's also written such a program.
17:30:32 <Pseudonym> There you go.
17:30:39 <Cale> (The goal there was mostly to evaluate regular inequalities.)
17:30:56 <Cale> (But I have the derivative as well)
17:31:57 <Cale> http://cale.yi.org/share/p481-brzozowski.pdf
17:31:59 <lambdabot> Title: cache:http://cale.yi.org/share/p481-brzozowski.pdf - Google Search
17:32:04 <Cale> Theorem 4.4
17:32:07 <Cale> :)
17:32:11 <Pseudonym> That's the one.
17:32:17 <hackage> Uploaded to hackage: logfloat 0.9.1.1
17:32:17 <hackage> Uploaded to hackage: list-extras 0.2.2.1
17:33:26 <Pseudonym> But I like this notation better, because it's very suggestive that it's really Taylor's theorem.
17:33:33 <Cale> Pseudonym: Oh, that's the same as the one linked to by LtU?
17:33:40 <Pseudonym> Yeah.
17:33:51 <Cale> Yeah, I just looked :)
17:34:12 <Pseudonym> DFA construction is the recursive application of Taylor's theorem.  What could be nicer?
17:34:16 <Cale> :)
17:35:13 <ddarius> What happens if you apply that algorithm to your CFG encoded with stack operators?
17:35:44 <sw17ch> is there anything inherently slow about MVar's?
17:35:48 <BMeph> > let p x = read x < 5 in map(p (show)) [1,2,3]
17:35:49 <lambdabot>   Couldn't match expected type `String'
17:35:50 <Pseudonym> You get a nondeterministic PDA, sadly.
17:35:53 <Cale> sw17ch: No.
17:36:07 <sw17ch> Cale: sweet, so if i'm using like.... 90, that shouldn't be a problem? :D
17:36:09 <Cale> sw17ch: Well, they're slower than IORefs
17:36:15 <sw17ch> Cale: D:
17:36:19 <Cale> Yeah, that shouldn't be a problem.
17:36:28 <EvilTerran> > let p x = read x < 5 in map (p . show) [1,2,3]
17:36:30 <lambdabot>   [True,True,True]
17:36:40 <sw17ch> and, they are best used for thread synchronization right? or should i be using something else
17:37:03 <Cale> sw17ch: Yeah. For more complicated constructions you might try STM.
17:37:20 <ddarius> Pseudonym: Well I certainly don't expect a DFA to pop out.
17:37:25 <sw17ch> Cale: i'm tying together a few sockets and a few file handles, that's about it
17:37:26 <Pseudonym> CFLs have some unfortunate properties which make deterministic FA construction difficult.
17:37:55 <pumpkin_> how do PEGs fit into the picture?
17:38:00 <pumpkin_> are they equivalent to CFG?
17:38:16 <Pseudonym> For example, whether or not two CFGs accept the same language is a problem that's known to be undecidable.
17:38:29 * ddarius should apply the behavioural derivative stuff to CFGs to produce an algorithm producing PDAs and prove them equivalent.
17:38:37 <Cale> pumpkin_: iirc, PEGs can parse context sensitive languages.
17:39:11 <Cale> er, maybe not.
17:39:24 <pumpkin_> I didn't get the impresion they were that much more powerful
17:39:27 <pumpkin_> if at all
17:39:39 <pumpkin_> but couldn't find a decent overview of the distinctions
17:39:42 <Cale> Ah, okay, they're the same as Parsec without >>=, just >>
17:39:51 <Cale> So no, they can't.
17:41:53 <Philonous> Pseudonym: Are there any interesting connections between the algebra you mentioned and bra-ket (or are they basically the same?) and if yes are there papers on it?
17:42:20 <Cale> It seems like every CFL should be recognisable by a PEG, given the description on wikipedia. It's the same as picking a priority for every branch occurring in the CFG.
17:44:19 * EvilTerran tries to work out if he can pass state "back in time" in TH through clever use of template expansion stages and IORefs
17:44:22 <Pseudonym> Philonous: Kind of.  I've never seen it published formally, but Mark Hopkins used to write a lot about it on comp.compilers.
17:44:32 <Pseudonym> If you search for "quantum parsing", you'll find a lot of stuff.
17:44:50 <Pseudonym> Aha.
17:44:51 <Philonous> Ah thanks a bunch
17:44:51 <Pseudonym> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.9532
17:44:52 <lambdabot> Title: Quantum automata and quantum grammars - CiteSeerX
17:45:16 <Pseudonym> Oh, maybe not.
17:45:24 <mmorrow> i darcsified, detabbed, and built haddock docs for Oleg's Z(ipper)FS code and pu tit here http://moonpatio.com/code/zfs/
17:45:32 <mmorrow> docs at http://moonpatio.com/code/zfs/haddock/
17:45:35 <Pseudonym> It has some stuff in it, anyway.
17:45:36 <lambdabot> Title: Index of /code/zfs
17:46:07 <Philonous> Yeah, more stuff to read is good. I am a little tired of traces atm ^^
17:46:11 <Cale> There was a guy constantly bugging me for help with this stuff a while back, to the point that he was using up all my time and I had to put him on ignore.
17:46:30 <Cale> (and he clearly wasn't reading the papers I was telling him to read)
17:46:38 <mmorrow> just ghc -O2 --make ZFS.hs && ./ZFS and it'll listen of localhost:1503, then telnet in and start cd/mkdir/ls/..ing
17:46:48 <mmorrow> pretty cool stuff
17:47:28 <Cale> But, it gave me the chance to pick up a bunch of it.
17:47:42 <Saizan> at this point you could cabalize and upload on hackage
17:48:18 <Pseudonym> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.57.3042 <- THis also looks interesting.
17:48:19 <lambdabot> Title: Parikhâs Theorem in Commutative Kleene Algebra - CiteSeerX
17:48:32 <mmorrow> Saizan: is there no zfs anything on hackage already?
17:48:34 * mmorrow checks
17:49:02 <Pseudonym> That's specifically for the commutative case, where E F = F E
17:49:56 <mmorrow> Saizan: hmm, looks like there is, but it's been modified from the one on oleg's site to use CC-delcont
17:50:34 <Philonous> Thanks again
17:50:48 <Saizan> mmorrow: ah, ok then
17:51:35 <mmorrow> Saizan: i'm planning on hacking on it anyway, so i'll upload if/when it's significantly different
17:52:33 <sw17ch> is there a good tutorial on the State monad out there anywhere?
17:52:48 <ddarius> We need more non-commutative algebra.
17:53:05 <Cale> sw17ch: I was going to give one to jdrake...
17:53:23 <Cale> in #haskell-overflow, I suppose shortly :)
17:53:24 <sw17ch> Cale: but then you eated it
17:53:26 <sw17ch> ?
17:53:27 <mmorrow> ddarius: can has rubix cubes?
17:53:28 <sw17ch> :)
17:54:09 <mmorrow> HAI, I MADE YOU A CUBIX RUBE, BUT THEN I EATED IT
17:54:34 * sw17ch loves lambdacats
17:54:49 * mmorrow loves "but then i eated it"
17:56:14 <sw17ch> mmorrow, i made a lambdacat for you, but then i eated it
17:58:59 <mmorrow> the smaller the kittay, the larger the tasty!
17:59:05 <pumpkin_> then i eated it sounds too eloquent
17:59:13 <pumpkin_> the then must go
17:59:59 <mmorrow> hmm, i can see that going either way
18:02:42 <sw17ch> I MADE YOU A CURRY BUT I EATED IT
18:02:45 <sw17ch> hmmm
18:02:55 <sw17ch> i dunno, the THEN seems a little necessary there
18:05:40 <ddarius> sw17ch: If it seems necessary then it probably shouldn't be there
18:06:53 <sw17ch> ddarius, well, that's a catch 22 if i've ever seen one :)
18:07:30 <mmorrow> hmm, i think a then there would detract actually
18:09:31 <Saizan> nice, i'm working with a Monoid m => (m -> (m,a)) making it a Monad + Applicative + Monoid, where none of the operations are induced by the others
18:09:43 <rdmltrs9> hi what would cause a parse error in a pattern?
18:10:08 <rdmltrs9> I'm trying to create my own function "myjoin" which mimics the ++ operator
18:10:23 <Twey> rdmltrs9: Uhm, the pattern being unparseable :)
18:10:33 <Saizan> rdmltrs9: lots of things, maybe lack of parens? however just make us see the code
18:10:48 <EvilTerran> ?where hpaste
18:10:49 <lambdabot> http://hpaste.org/
18:10:54 <Twey> GN AR 23948 A*)# RG * GH = foo
18:11:00 <Twey> ^ parse error!
18:11:20 <rdmltrs9> specifically this line, myjoin a:c bd = a:myjoin c bd
18:11:30 <Twey> Ah
18:11:32 <Twey> Need brackets
18:11:38 <ozy`> try adding some parentheses
18:11:39 <daf> myjoin (a:c) ...
18:11:42 <Twey> myjoin (a:c) bd = a : myjoin c bd
18:11:42 <ozy`> yeah
18:11:48 <rdmltrs9> ahh okay thanks
18:11:49 <Twey> myjoin (a:c) = a : myjoin c
18:12:08 <rdmltrs9> i was going crazy thinking I had the pattern of recursion wrong or something
18:12:36 <Twey> myjoin = liftM2 (:) head (myjoin . tail)
18:13:23 <ddarius> Twey: That almost does parse.
18:16:05 <Twey> ddarius: I know, it was surprisingly difficult :-\
18:16:26 <EvilTerran> the problem there being the lack of compositionality of partial patterns in haskell
18:17:14 * Twey nods.
18:17:41 <Twey> It should probably be parsed as a : (c bd), I guess?
18:18:42 <EvilTerran> but you can't pattern-match a function application
18:19:24 <Twey> *nods*
18:20:14 <EvilTerran> in theory, given knowledge of the types of constructors and the type required, you could probably work out how to bracket a pattern correctly
18:20:35 <EvilTerran> but not expressions in general, obviously, so it'd be inconsistent to do so
18:30:31 <ozy`> http://blake.mcbride.name/software/lispf4/index.html <== the Fortran source files are in all caps. it's fun to imagine them being read aloud in the voices from that "how is babby formed" video
18:30:38 <lambdabot> Title: LISPF4 | Software Projects | Blake McBride | Arahant.Com | Nashville, TN
18:32:17 <hackage> Uploaded to hackage: uuagc 0.9.7
18:38:43 <TomMD> @hackage uuagc
18:38:44 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/uuagc
18:41:49 <sw17ch> @src forever
18:41:50 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
18:44:06 <cads> lambdabot's response would be kind of fucked up if sw17 had actually undergone shock therapy..
18:44:56 <dcoutts> cads: ah but lambdabot is clever enough not to be so insensitive
18:45:08 <dcoutts> @vixen isn't that right?
18:45:08 <lambdabot> correct
18:45:52 * sw17ch is mad at the stupid bot for making fun of his electro-shock therapy
18:45:59 <ddarius> cads: Not if it was accurate.
18:46:18 <ddarius> Ideally your mind shouldn't be the same.
18:46:43 <BMeph> cads: Yeah, it would make it eerily (and uncomfortably) astute... ;)
18:47:05 <ddarius> "The programs are getting too smart... "
18:49:25 * BMeph thinks lambdabot was being sympathetic, or maybe patronizing, but not having fun. As for the rest of the channel-zens... ;)
18:50:00 <Saizan> @src foo
18:50:01 <lambdabot> Source not found. You type like i drive.
18:50:45 <BMeph> @where foo
18:50:45 <lambdabot> I know nothing about foo.
18:50:57 <BMeph> Saizan: so there! Nyaa. ;)
18:51:52 <Saizan> she obviously have multiple personalities :)
18:52:21 <malouin> Is there some awesome way to pass tuples to binary operators?
18:52:30 <malouin> err doubles
18:52:48 <Saizan> > uncurry (+) (1,2)
18:52:49 <lambdabot>   3
18:52:54 <Saizan> like that?
18:53:43 <BMeph> malouin: We call them "pairs" around here... :)
18:53:45 <malouin> Saizan: exactly liek that!
18:53:57 <malouin> BMeph: right, it came to me after a minute.
18:56:41 <malouin> I take it there is no class for natural numbers (and zero)?
18:56:49 <malouin> ie, + and * are supported but not - and /
18:57:06 <Saizan> ?src Num
18:57:07 <lambdabot> class  (Eq a, Show a) => Num a  where
18:57:07 <lambdabot>     (+), (-), (*)           :: a -> a -> a
18:57:07 <lambdabot>     negate, abs, signum     :: a -> a
18:57:07 <lambdabot>     fromInteger             :: Integer -> a
18:57:41 <malouin> Well, I explicitly do not want to define / and - in my case, because my "numbers" cannot be negative.
18:57:55 <Saizan> yeah
18:58:00 <malouin> or rational...
18:58:15 <Saizan> as you see Num doesn't have (/), but it does contain (-)
18:58:58 <Saizan> you could just use error "(-) is not defined" as the implementation and avoid using it
18:59:11 <_pumpkin> ?src IO
18:59:11 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
18:59:15 <malouin> I suppose so.
18:59:21 <cjs> So, when I've got a zillion little things to parse out of various messages, what's the best way to access them? A function for each one?
19:00:25 <Saizan> malouin: the current numerical hierarchy is considered quite annoying by many people, so you're not alone :)
19:00:38 <_pumpkin> what are the future plans for haskell?
19:00:41 <malouin> Saizan: interesting.
19:02:14 <malouin> Saizan: so far, while they are not quite as nuanced as a real analysis textbook, they're a lot nicer than C :)
19:03:12 <Saizan> malouin: heh, that's the minimum standard here! :) (or should be)
19:03:35 <BMeph> malouinL: I suggest, cheat, and call it a monoid! >:)
19:06:13 <Saizan> _pumpkin: there's a new standard in progress called Haskell', it's going to have a new release each year from now on
19:06:36 <_pumpkin> cool
19:06:59 <Saizan> http://hackage.haskell.org/trac/haskell-prime/
19:07:01 <lambdabot> Title: Haskell Prime - Trac
19:10:06 <paczesiowa> are all those type families more powerful than fundeps?
19:12:50 <Saizan> paczesiowa: if you allow OverlappingInstances and UndecidableInstances i think they are less powerful
19:13:12 <Saizan> since patterns of a type family can't overlap at all
19:13:25 <paczesiowa> Saizan: there are no ugly switches for type families?
19:13:29 <malouin> Looks like haskell' has the same number types/classes?
19:13:33 * mml` is working through The Implementation of Functional Languages.
19:13:47 <Saizan> but there's also a proposal for closed type families which allows them
19:14:04 <paczesiowa> Saizan: but that won't be in 6.10
19:14:13 <Saizan> yeah, afaiu
19:14:38 <paczesiowa> I want more power now with my types now
19:14:54 <paczesiowa> too much now
19:15:10 <Saizan> ask Oleg :)
19:15:50 <paczesiowa> looks like he is done with HList and moved to left folds land
19:16:44 <dolio> Left folds are old news.
19:16:56 <dolio> He's all about light-weight regions for IO and such now.
19:17:17 <inimino> light-weight regions?
19:17:35 <paczesiowa> dolio: still not exactly type hacking
19:18:00 <Saizan> light-weight regions are moderately type-hacky
19:18:05 <dolio> inimino: http://www.cs.rutgers.edu/~ccshan/capability/region-io.pdf
19:18:06 <lambdabot> Title: Lightweight Monadic Regions
19:18:15 <paczesiowa> btw does anyone know him in real life? I wonder if he can walk on water and other nifty things
19:18:20 <BMeph> @help src
19:18:20 <lambdabot> src <id>. Display the implementation of a standard function
19:18:57 <dolio> They're more type-hacky than left folds and delimited continuations, at least.
19:21:29 <inimino> ah
19:33:49 <ivanm> is there any way of telling where my hGetContents errors are coming from?
19:34:19 <paczesiowa> ivanm: what errors?
19:41:09 <ivanm> paczesiowa: sorry, my computer decided to die on me
19:41:16 <ivanm> and even now X is playing up
19:41:21 * ivanm goes off to restart X
19:42:52 <rdmltrs9> > foldr (-1) 0 [1, 2, 4]
19:42:54 <lambdabot>       No instance for (Num (a -> b -> b))
19:42:54 <lambdabot>        arising from a use of `negat...
19:43:29 <paczesiowa> > foldr (subtract 1) 0 [1, 2, 4]
19:43:30 <lambdabot>       No instance for (Num (b -> b))
19:43:30 <lambdabot>        arising from the literal `1' at <...
19:43:40 <paczesiowa> > foldr (subtract ) 0 [1, 2, 4]
19:43:41 <lambdabot>   -7
19:44:09 <rdmltrs9> > foldr (-) 0 [1, 2, 4]
19:44:10 <lambdabot>   3
19:44:27 <rdmltrs9> what's the diff btw subtract and (-)
19:44:48 <paczesiowa> @src subtract
19:44:49 <lambdabot> subtract x y = y - x
19:44:54 <mml`> heh
19:44:58 <paczesiowa> flipped
19:45:22 <mml`> > subtract 3 5
19:45:24 <lambdabot>   2
19:45:33 <mml`> > flip (-) $ 3 5
19:45:34 <lambdabot>       Overlapping instances for Show (a -> a)
19:45:34 <lambdabot>        arising from a use of `s...
19:45:45 <paczesiowa> > flip (-) $ 3 $ 5
19:45:46 <lambdabot>       Overlapping instances for Show (b -> b)
19:45:46 <lambdabot>        arising from a use of `s...
19:45:56 <mml`> (flip (-)) 3 5
19:46:06 <mml`> > (flip (-)) 3 5
19:46:06 <sjanssen> @type (-)
19:46:07 <lambdabot> forall a. (Num a) => a -> a -> a
19:46:08 <lambdabot>   2
19:46:15 <paczesiowa> > flip (-) ( flip ($)) 3 5
19:46:17 <lambdabot>       Overlapping instances for Show ((a -> b) -> b)
19:46:17 <lambdabot>        arising from a us...
19:46:18 <sjanssen> @type (-1)
19:46:19 <lambdabot> forall a. (Num a) => a
19:46:49 <sjanssen> rdmltrs9: (-) has strange syntax rules, sometimes in means negation and sometimes it means subtraction
19:47:22 <inimino> @let bigLog10 n = let { str = show n; l = length str } in fromIntegral (l - 1) + (logBase 10 $ read (take 16 str) / (10^(min l 16 - 1)))
19:47:23 <lambdabot>  Defined.
19:47:59 <inimino> > logBase 10 (10^1000)
19:48:01 <lambdabot>   Infinity
19:48:13 <inimino> > bigLog10 (10^1000)
19:48:14 <lambdabot>   1000.0
19:48:27 <inimino> yay
19:48:58 <inimino> bigLog10 (2^(2^18))
19:49:04 <inimino> > bigLog10 (2^(2^18))
19:49:06 <lambdabot>   78913.20718333869
20:06:36 <juhp> bos: hi
20:06:42 <bos> blurp.
20:06:59 <bos> i've got stuff sorted now.
20:07:09 <juhp> okay cool
20:07:18 <bos> should i issue a rebuild?
20:07:25 <bos> probably not worth it.
20:07:46 * bos `ap` bed
20:07:49 <juhp> rebuild?
20:08:07 <juhp> hmm..
20:43:44 <younder> http://hpaste.org/11107
20:44:14 <younder> Had terrible trouble with getting this code to work
20:44:33 <younder> Is there a betterway to as "the last element of a list"
20:44:46 <younder> as = say
20:44:53 <paczesiowa> > last [1..]
20:44:56 <paczesiowa> > last [1..9]
20:45:03 <lambdabot>   mueval: Prelude.read: no parse
20:45:06 <lambdabot>   9
20:45:15 <paczesiowa> > last [1..]
20:45:24 <TSC> Or do you mean "all but the last"?
20:45:24 <lambdabot>   mueval: Prelude.read: no parse
20:45:34 <paczesiowa> why that doesn't parse?
20:45:47 <TSC> The error message is probably wrong
20:45:58 <rwbarton> "no parse" is referring to an error message produced by ghc that mueval couldn't parse
20:46:04 <rwbarton> , last [1..]
20:46:07 <paczesiowa> oh I see
20:46:11 <lunabot>  Killed.
20:47:13 <dcoutts> @localtime Heffalump
20:47:15 <lambdabot> Local time for Heffalump is Mon Oct 13 04:47:13 2008
20:47:54 <younder> endland
20:48:06 <younder> England
20:48:25 <Twey> It be bloody late.
20:48:39 <younder> early..
20:48:59 <Twey> Mon Oct 13 04:48:58 BST 2008
20:49:00 <younder> I just got up. GMT+1
20:49:02 <Twey> Late for me :)
20:49:05 <Twey> Ditto
21:00:12 <BMeph> younder: butLast = init. :)
21:24:41 <intrados> is yet another haskell tutorial by daume a good guide to start with?
21:25:40 <mml`> @localtime mml`
21:25:43 <lambdabot> Local time for mml` is Mon Oct 13 00:25:40 2008
21:27:27 <younder> intrados: I found it was pretty good
21:27:59 <younder> I am following it up with "Real word Haskell"
21:28:18 <intrados> is that also free?
21:28:22 <younder> yes
21:28:35 <intrados> cool. thanks
21:31:17 <Heffalump> dcoutts: you timed me?
21:33:34 <dcoutts> Heffalump: oh, about london hug stuff
21:34:00 <dcoutts> Heffalump: just thinking there might be something I could talk about that people might be interested in
21:35:23 <dcoutts> Heffalump: I'm not making a specific suggestion, just that if people say they want to hear about something and you think I'd be appropriate then I'm happy to do that
21:40:31 <Heffalump> yeah, I think that'd be great - hopefully a few other people will pipe up too, so I can get a pipeline going
21:44:50 <dgu> Can someone explain what "-XTypeSynonymInstances" does, or point me to a good reference?  (ghci is giving me an error which says to use this to make the error go away, and it does ... but I can't figure out why)
21:45:44 <Heffalump> if you have type Foo = Bar, then that flag lets you write instance SomeClass Foo
21:55:28 <dgu> I see, I guess "type String = [Char]" so to use String in the instance decl I had to use the synonym option
21:56:45 <mmorrow> i'm slightly confused about the relationship between Y and fix. also, how would i write Y without unsafeCoerce (ie what would the newtype def look like which gets around the infinite type)? http://hpaste.org/11108
21:57:28 <Cale> mmorrow: Y is usually used as a name for a particular implementation of fix
21:57:36 <Pseudonym> @src In
21:57:36 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
21:57:46 <Pseudonym> Like that?
21:57:59 <Cale> @src InR
21:57:59 <lambdabot> newtype Rec a = InR { outR :: Rec a -> a }
21:58:03 <mmorrow> Cale: this is in the context of eliminating letrec by Y+lambdas, and then lifting all the lambdas to toplevel
21:58:05 <Cale> that one is also handy
21:58:27 <Pseudonym> @src fix
21:58:28 <lambdabot> fix f = let x = f x in x
21:58:36 <Pseudonym> mmorrow: Like that?
21:58:41 <mmorrow> i have to /eliminate/ recursive lets
21:58:48 <mmorrow> not /use/ them :)
21:59:03 <Pseudonym> You can't eliminate all of them unless you use a recursive type, like Mu.
21:59:27 <dolio> @type let w x = outR x x in outR w w
21:59:28 <lambdabot>     Couldn't match expected type `Rec a'
21:59:28 <lambdabot>            against inferred type `Rec a1 -> a1'
21:59:28 <lambdabot>     In the first argument of `outR', namely `w'
21:59:34 <mmorrow> hmm.
21:59:46 <dolio> @type let w x = InR $ outR x x in outR w w
21:59:47 <lambdabot>     Couldn't match expected type `Rec a'
21:59:47 <lambdabot>            against inferred type `Rec (Rec a1 -> a1) -> Rec a1'
21:59:47 <lambdabot>     In the first argument of `outR', namely `w'
22:00:15 <mmorrow> also, what's the significance of being able to type my y there as (a -> r) -> r, which fix must be (a -> a) -> a
22:00:16 <mmorrow> ?
22:00:51 <Cale> y = \f -> (\x -> f (out x x)) (In (\x -> f (out x x)))
22:00:52 <Pseudonym> @type \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
22:00:53 <lambdabot> forall a. (a -> a) -> a
22:00:59 <dolio> @type let w x = InR $ outR x x in w (InR w)
22:01:00 <lambdabot>     Couldn't match expected type `Rec a -> a'
22:01:00 <lambdabot>            against inferred type `Rec a'
22:01:00 <lambdabot>     Probable cause: `w' is applied to too many arguments
22:01:04 <dolio> Oh well.
22:01:06 <Cale> er, outR, yes
22:01:09 <mmorrow> heh
22:01:32 <mmorrow> but
22:01:33 <mmorrow> y f = let z x = f (unsafeCoerce x x) in z z
22:01:37 <mmorrow> y :: (a -> b) -> b
22:01:57 <mmorrow> newtype C a = C (forall r. (a -> r) -> r) ?
22:01:57 <Cale> Well, unsafeCoerce lets you do lots of stupid and unsafe things.
22:02:14 <Heffalump> I doubt it'll actually work, though
22:02:23 <mmorrow> i challenge you to use that use of unsafeCoerce to segfault
22:02:24 <Pseudonym> > (\f -> (\x -> f (out x x)) (In (\x -> f (out x x)))) (\fac x = if x == 0 then 1 else x * fac (x-1)) 5
22:02:25 <mmorrow> :)
22:02:26 <lambdabot>   <no location info>: parse error on input `='
22:02:34 <mmorrow> Heffalump: doubt what will work?
22:02:38 <Pseudonym> > (\f -> (\x -> f (out x x)) (In (\x -> f (out x x)))) (\fac x -> if x == 0 then 1 else x * fac (x-1)) 5
22:02:39 <lambdabot>       Occurs check: cannot construct the infinite type: f = (->) (Mu f)
22:02:39 <lambdabot>      ...
22:02:41 <mmorrow> (that y does indeed work)
22:02:45 <mmorrow> http://hpaste.org/11108
22:02:48 <Pseudonym> Ah, crp.
22:02:53 <Pseudonym> WRong one.
22:03:10 <Pseudonym> > (\f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))) (\fac x -> if x == 0 then 1 else x * fac (x-1)) 5
22:03:12 <lambdabot>   120
22:03:16 <Pseudonym> Woo.
22:03:19 <mmorrow> weehoo
22:04:18 <Saizan> if compiled it used to make the inliner loop, though
22:04:42 * mmorrow checks
22:07:31 <Heffalump> mmorrow: the unsafeCoerce'd y? Interesting.
22:07:44 <mmorrow> yes.
22:07:57 <mmorrow> hmm, i just checked and it looks like Saizan's is correct
22:08:05 * mmorrow check different variants of the same
22:08:38 <Saizan> you can fix it with a NOINLINE rightly placed, iirc
22:10:06 <Saizan> http://www.nabble.com/Re%3A-How-to-define-Y-combinator-in-Haskell-p6331111.html
22:10:08 <lambdabot> Title: Nabble - Re: How to define Y combinator in Haskell, http://tinyurl.com/43q4r5
22:10:33 <mmorrow> haha, it'll only not loop the inliner (cse?) with no optimization
22:10:48 <mmorrow> -O and -O2 cause ghc to loop
22:10:57 <Pseudonym> Bug report.
22:11:08 <mmorrow> Saizan: excellent idea
22:11:47 <dons> wassup?
22:13:15 <Cale> Pseudonym: The bug has been known about for a long time, and I'm pretty sure it was decided not to fix it.
22:13:32 <Cale> (I'm not exactly sure why though.)
22:13:41 <dolio> Bug report? "Optimizer loops with unsafeCoerced y-combinator"?
22:13:47 <Saizan> yeah, the message i linked says so, although the referred link is broken
22:14:09 <Saizan> dolio: no, with (\f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))))
22:14:10 <mmorrow> dolio: haha, that'll get a helpful response i'm sure
22:14:24 <dolio> Oh, okay.
22:14:42 <mmorrow> Saizan: oh. i thought you were looping with the unsafeCoerced version too
22:14:48 * mmorrow was
22:14:57 <Saizan> ah
22:15:02 <Saizan> so they both loop?:)
22:15:08 <mmorrow> NOINLINE didn't work for the unsafeCoerced version
22:15:17 <mmorrow> (with -O2)
22:15:21 <mmorrow> haven't tried -O
22:15:37 <Saizan> you NOINLINE z ?
22:16:20 <mmorrow> no, was about to try that also. Also, i'm trying two variants as well
22:16:25 <mmorrow> y0 f = let z x = f (unsafeCoerce x x) in z z
22:16:30 <mmorrow> y1 f = (\x -> f (unsafeCoerce x x)) (\x -> f (unsafeCoerce x x))
22:16:34 <mmorrow> both loop
22:18:46 <mmorrow> there we go. this worked with -O2
22:18:47 <mmorrow> y0 f = let z x = f (unsafeCoerce x x) ; {-# NOINLINE z #-} in z z
22:21:13 <Saizan> the funny thing is that newtype is implemented as a coercion at the Core level too :)
22:22:01 <mmorrow> yeah, i believe they should be doing the same thing if you go deep enough
22:22:17 * BMeph imagines a pair of rough, brawny thugs with brass knuckles, cornering a slightly-built type checker in a dark alley...
22:42:40 * dmwit chuckles
22:43:13 <dmwit> ?remember sigfpe It's like deciding that the prime numbers bigger than 20 are interesting for some reason, and then choosing to name them "the primes".
22:43:13 <lambdabot> Good to know.
22:44:02 <dolio> Is that like "the calculus"?
22:44:51 <younder> dmwit: ?? signal floting point exception
22:45:05 <dmwit> Yup, that's the nick he goes by.
22:45:13 <dmwit> http://sigfpe.blogspot.com
22:45:14 <lambdabot> Title: A Neighborhood of Infinity
22:45:31 <dolio> @quote sigfpe
22:45:31 <lambdabot> sigfpe says: Haskell is so strict about type safety that randomly generated snippets of code that successfully typecheck are likely to do something useful, even if you've no idea what that useful
22:45:31 <lambdabot> thing is.
22:46:01 <Saizan> dmwit: where's that quote from?
22:46:18 <dmwit> It's in the comments to "You Could Have Invented Monads".
22:53:22 <BMeph> Sounds like an apt description of loeb, heh.
22:55:22 <younder> makes a difference to Perl which always does something sometimes even what you wand ;)
22:55:45 <younder> s/wand/want/
23:00:49 <chrisdone> coi ro do
23:00:49 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
23:01:15 <chrisdone> woot
23:01:31 <Twey> la .lamdabot. ti zvati .i'a-nai-ru'e
23:01:47 <chrisdone> mmorrow: oh, yeah, I figured that out after you left (GHC/GLASGOW) ;)
23:01:50 <Twey> Oh
23:01:52 <Twey> This is #haskell
23:02:49 <chrisdone> I like the way "coi ro do" sounds
23:03:46 * Twey sings: # coi doi ro do coi doi ro do coi doi ro do coi ro do do'u #
23:04:20 <chrisdone> it's just not the same with the do'u at the end ;-)
23:05:03 <Twey> I think it gives it character vau.  I should close all my bridi vau!
23:05:13 <chrisdone> Twey: http://jbotcan.org/what_xkcd_did_for_lojban.png
23:05:58 <mmorrow> chrisdone: heh
23:06:08 <Twey> Hahaha, chrisdone
23:07:18 <shukhov> how do you round/truncate a double in haskell?
23:07:37 <chrisdone> mmorrow: oh, I wrote this post http://chrisdone.com/80-10-12%20Kibro%20refactoring and Jinjing Wang fixed Panda so it works in a custom directory! :D!
23:07:48 <chrisdone> shukhov: floor/ceiling?
23:08:06 <chrisdone> > floor 5.25
23:08:07 <lambdabot>   5
23:08:22 <shukhov> > floor 5.25 :: Double
23:08:23 <lambdabot>       No instance for (Integral Double)
23:08:23 <lambdabot>        arising from a use of `floor' ...
23:08:30 <chrisdone> ah
23:08:36 <shukhov> :(
23:08:37 <chrisdone> > floor 5.25 :: Float -- just floats?
23:08:38 <lambdabot>       No instance for (Integral Float)
23:08:38 <lambdabot>        arising from a use of `floor' a...
23:08:53 * chrisdone baffles flabbergasts bamboozled
23:09:19 <mmorrow> heh, as i read further... "Treating expressions involving let and letrec in the manner just described is unsatisfactory for several reasons:"
23:09:22 <chrisdone> :t floor 2.5
23:09:23 <lambdabot> forall b. (Integral b) => b
23:09:38 <mmorrow> "...Eliminating the recursion by using the x-point combinator Y thus introduces unnecessary inefficiencies."
23:09:40 <mmorrow> ...
23:10:02 <mmorrow> err, that should be s/x/fix/
23:10:21 <chrisdone> heh /me was wondering what x-point was
23:10:34 <chrisdone> reading something lispy?
23:10:56 <shukhov> anyway to make and Integer to a double?
23:11:14 <chrisdone> > fromIntegral 2 :: Double
23:11:15 <lambdabot>   2.0
23:11:24 <shukhov> \o/
23:11:42 <chrisdone> >_^
23:12:36 <mmorrow> chrisdone: http://moonpatio.com/papers/lang/lambda_lift.pdf
23:12:48 <lambdabot> Title: cache:http://moonpatio.com/papers/lang/lambda_lift.pdf - Google Search
23:13:06 <mmorrow> (i've started to accumulate random papers here: http://moonpatio.com/papers/)
23:13:06 <lambdabot> Title: Index of /papers
23:13:21 <chrisdone> mmorrow: oh nice =o
23:13:54 <mmorrow> the oleg dir is kinda ahead of the others, but that's just because i just looted his site ;)
23:14:49 <chrisdone> "the G-machine", sexy
23:15:04 <dmwit> It's sexy until you realize it's tagless.
23:15:07 <dmwit> err
23:15:13 <dmwit> Wow, I totally ruined that joke.
23:15:53 <chrisdone> haha
23:15:56 <mmorrow> you win some, you lose some
23:18:42 <mmorrow> <chrisdone> mmorrow: oh, I wrote this post http://chrisdone.com/80-10-12%20Kibro%20refactoring and Jinjing Wang fixed Panda so it works in a custom directory! :D!
23:18:54 <mmorrow> sweet. that was fast turnaround
23:19:47 <mmorrow> "..., what a legend,..."
23:19:49 <mmorrow> lol
23:19:53 <mmorrow> nice touch
23:21:41 <chrisdone> haha
23:50:21 <mmorrow> this paper is awesome http://moonpatio.com/papers/interp/jfp99-monad.ps
23:50:59 <mmorrow> (i realize the dir it's in is kinda miscategorizing it now that i've started to read it..)
23:52:20 <mmorrow> enumerate the rationals Q:
23:52:41 <mmorrow> let q = zipWith (\i xs -> zip (repeat i) xs) [0..] (repeat [0..]) ; go acc (xs:xss) = let (ys,acc') = unzip . fmap (head&&&tail) $ (xs:acc) in ys ++ go acc' xss in go [] xss
23:52:46 <mmorrow> , let q = zipWith (\i xs -> zip (repeat i) xs) [0..] (repeat [0..]) ; go acc (xs:xss) = let (ys,acc') = unzip . fmap (head&&&tail) $ (xs:acc) in ys ++ go acc' xss in go [] xss
23:52:47 <lunabot>  luna: Not in scope: `xss'
23:52:51 <mmorrow> , let q = zipWith (\i xs -> zip (repeat i) xs) [0..] (repeat [0..]) ; go acc (xs:xss) = let (ys,acc') = unzip . fmap (head&&&tail) $ (xs:acc) in ys ++ go acc' xss in go [] q
23:52:53 <lunabot>  [(0,0),(1,0),(0,1),(2,0),(1,1),(0,2),(3,0),(2,1),(1,2),(0,3),(4,0),(3,1),...
23:53:46 <mmorrow> with that list, any rational is reachable in finite time
23:55:00 <mmorrow> in that paper, all they do is fork an infinite number of threads, each of which prints out (m/[1..]), and they achieve the same thing
23:55:41 <mmorrow> and they're not using haskell threads /or/ os threads
23:56:43 <BMeph> mmorrow: Hmm, I remember another pearl, that lists them (members of Q) without repeats.
23:57:13 <jsnx> i like it how the author foresaw, in 1993, the work of wadler in 1995 -- and that monads would be widely used
23:58:02 <jsnx> (top of page -- jfp '93 it says)
23:58:41 <BMeph> jsnx: I think the Journal's copyright is 1993; looks like the paper is a '99 publication. :)
