00:00:17 <lispy> > init . map snd . filter fst . zip (fix ([True, False] ++)) . ap (zipWith (+)) tail . map length . take 10 . group . fix $ show
00:00:21 <lambdabot>   [2,4,8,16]
00:00:28 <lispy> > init . map snd . filter fst . zip (fix ([True, False] ++)) . ap (zipWith (+)) tail . map length . take 100 . group . fix $ show
00:00:32 <thetallguy> Well, that's pretty twisted.
00:00:41 <lambdabot>   mueval: Prelude.read: no parse
00:00:44 <lispy> the magic is just the first few terms
00:00:53 <lispy> > map length . take 100 . group . fix $ show
00:01:07 * lispy kicks mueval
00:01:09 <lambdabot>   thread killed
00:01:20 <thetallguy> yes, fix show is definitely the weird part.
00:01:21 <lispy> > map length . take 10 . group . fix $ show
00:01:25 <lambdabot>   [1,1,1,3,1,7,1,15,1,31]
00:02:37 <lispy> :t fix show
00:02:39 <lambdabot> String
00:03:26 <thetallguy> It's interesting, but doesn't really inspire, I'm afraid.
00:03:49 <thetallguy> Still, far better than nothing.  Thanks lispy.
00:03:54 <Axman6> i find code like that pretty disgusting tbh
00:03:55 <lispy> heh
00:04:16 <lispy> thetallguy: the OOHaskell paper has some cool, legitimate uses of fix
00:04:43 <lispy> thetallguy: they use it to implement the Haskell equivalent of 'this'
00:04:58 <Axman6> @src fix
00:04:59 <lambdabot> fix f = let x = f x in x
00:05:13 <Axman6> :t fix
00:05:14 <lambdabot> forall a. (a -> a) -> a
00:05:33 <lispy> Axman6: yeah, that code is overly pointfree in the full version that generates powers of 2, but the concept of map length . group . fix $ show, is pretty cool I think
00:05:51 <Axman6> heh, yeah
00:06:11 <Axman6> i prefer the good old map (2^) [1..] personally, but whatevs
00:06:17 <lispy> heh
00:06:33 <ac> :t map length . group . fix $ show
00:06:34 <lambdabot> [Int]
00:06:59 <Axman6> @src length
00:07:00 <lambdabot> Source not found. Just try something else.
00:08:18 <lispy> length xs = length' 0 xs where length' n [] = n; length' n (y:ys) = length' (n+1) ys
00:08:56 <Axman6> length xs = foldl' (+) . map (const 1) $ xs
00:08:57 <Axman6> >_>
00:08:58 <lispy> I don't know if that's the optimal solution though, that seems too lazy
00:09:15 <lispy> yeah, foldl' seems like the way to go
00:11:20 <Axman6> length = foldl' (+) . map (const 1) -- for the pointless addicts
00:13:25 <lispy> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-List.html#length
00:13:28 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/6nneom
00:13:30 <lispy> that's the implementation GHC uses
00:15:12 <Axman6> i like mine better
00:15:28 <Axman6> why do they use Ints anyway?
00:16:14 <Axman6> > length [(minBound :: Int) .. 1+maxBound]
00:16:16 <lambdabot>   1
00:16:24 <ac> Axman6: for length? Because it's faster I presume. There's also a generic length function
00:17:03 <lispy> :t (!!)
00:17:04 <lambdabot> forall a. [a] -> Int -> a
00:17:19 <lispy> I always wondered why (!!) is Int instead of Integer myself
00:17:40 <lispy> ?hoogle [a] -> Integer -> a
00:17:41 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
00:17:41 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
00:17:41 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
00:18:07 <Axman6> > length [(minBound :: Int) .. maxBound]
00:18:19 <lispy> that's too slow for lambdabot
00:18:22 <lambdabot>   thread killed
00:18:41 <lispy> I guess genericIndex does what I want
00:18:53 <lispy> I wonder if genericDrop is strict in [a]
00:19:05 <Axman6> > maxBound - minBound :: Int
00:19:08 <lambdabot>   -1
00:19:16 <Axman6> > maxBound + minBound :: Int
00:19:17 <lispy> > head . genericDrop 1 [1..]
00:19:19 <lambdabot>   Couldn't match expected type `a -> [a1]'
00:19:19 <lambdabot>   -1
00:19:20 <cjs> The 0# means that it's unboxed, so it can be passed around in registers, I believe.
00:19:45 <lispy> > head $ genericDrop 1 [1..]
00:19:47 <lambdabot>   2
00:20:15 <lispy> oh cool, genericDrop can handle infinite streams
00:20:24 <Axman6> > (maxBound :: Int) - minBound
00:20:27 <lambdabot>   -1
00:20:32 <Axman6> rawr
00:21:31 <lispy> but maybe that's not the function I'm thinking of anyway
00:23:23 <Axman6> lispy: were you one of the ones talking about memoisation yesterday?
00:23:41 <ac> > head $ drop 1 [1..]
00:23:44 <lambdabot>   2
00:23:47 <int-e> Axman6: yes. Enum is a bit broken.
00:24:11 <int-e> oh. wait.
00:24:37 <int-e> > fromEnum (maxBound :: Word) - fromEnum (minBound :: Word)
00:24:39 <lambdabot>   * Exception: Enum.fromEnum{Word}: value (18446744073709551615) is outside o...
00:25:38 <int-e> Axman6: sorry. you were only using Bounded.
00:29:55 <Axman6> :t maxBound
00:29:56 <lambdabot> forall a. (Bounded a) => a
00:30:54 <Axman6> @instances Bounded
00:30:56 <lambdabot> (), (a, b), (a, b, c), All, Any, Bool, Char, Dual a, Int, Ordering, Product a, Sum a
00:31:27 <cjs> int-e: The exception is expected, of course.
00:32:51 <int-e> cjs: maybe. or maybe Word shouldn't be an instance of Enum in the first place.
00:33:35 <int-e> (I know. That would break [1..] :: Word and related useful list constructions)
00:34:11 <int-e> > fromEnum 1.4
00:34:14 <lambdabot>   1
00:35:10 <ac> where's (+#) defined?
00:36:36 <int-e> it's a primitive operation, it's built into the compiler.
00:38:35 <ac> when I try to use it I get an error message that it's not in scope
00:38:59 <Cale> Maybe try importing GHC.Prim?
00:39:03 <sjanssen> ac: it's exported by GHC.Exts
00:39:14 <Cale> ah, perhaps that one :)
00:41:04 <Cale> Aha, GHC.Exts seems to conveniently re-export stuff from GHC.Prim and GHC.Base and such.
00:43:07 <ac> now the question is how do I construct numbers of type Int#
00:43:22 <dons> :t 1#
00:43:24 <lambdabot> GHC.Prim.Int#
00:43:34 <dons> why are you writing Int# literals? :)
00:43:49 <ac> just curious if it will make things go faster
00:44:18 <Xenoblitz> http://hpaste.org/10968
00:44:25 <Xenoblitz> guys can you look this up a bit?
00:44:28 <sjanssen> ac: usually GHC is smart enough to automatically unbox your code
00:44:33 <Xenoblitz> i'm messing around with basic concurrency
00:45:43 <dons> ac: yeah, unlikely to make any difference.
00:45:49 <dons> look at the core first.
00:45:50 <sjanssen> Xenoblitz: some sort of indentation problem
00:45:56 <sjanssen> Xenoblitz: do you have tabs in the file?
00:46:06 <dons> ac: but of course, not a bad skill to pick up
00:46:16 <rwbarton> Xenoblitz: your main definition is messed up
00:46:17 <rwbarton> main = ...
00:46:36 <rwbarton> Or, turn on PatternSignatures :)
00:46:41 <ac> sjanssen: I was writing a program that required lots of random numbers, and I didn't care about the quality, so I hacked together a funky random number generator in Haskell. It was rather slow, so someone here suggested using the mersenne library, and even though I'm sure it's doing way more math, it was many times faster
00:46:46 <sjanssen> huh, I should have found that one
00:46:49 <Axman6> Xenoblitz: try getting rid of the type signature (comment them out)
00:47:24 <dons> ac: yeah but its way way more optimised :)
00:47:46 <Axman6> heh, yeah main is screwed up isn't it. should be main :: IO () \n main = ...
00:47:47 <dons> ac: but you should profile to see why your code is slow
00:47:48 <Xenoblitz> thanks guys i'll try
00:47:56 <Xenoblitz> so the code should be ok
00:48:20 <Xenoblitz> yeah i saw the missing main now... it was there but i editted it out by mistake
00:48:24 <Axman6> fix it and see
00:48:55 <ac> dons: how should I go about profiling my code? It's a very simple function...
00:50:44 <Xenoblitz> works now guys... was an identation error after all..
00:50:52 <Xenoblitz> and i am really amazed at how fast thread switching is
00:51:04 <Xenoblitz> f1o9r4k7
00:51:05 <Xenoblitz> f1o9r4k8
00:51:05 <Xenoblitz> f1o9r4k9
00:51:05 <Xenoblitz> f1o9r5k0
00:51:05 <Xenoblitz> f1o9r5k1
00:51:05 <Xenoblitz> f1o9r5k2
00:51:07 <Xenoblitz> f1o9r5k3
00:51:23 <Xenoblitz> i was expecting fork, number, fork, number...
00:51:24 <idnar> @hoogle sum
00:51:24 <lambdabot> Prelude sum :: Num a => [a] -> a
00:51:24 <lambdabot> Data.Foldable sum :: (Foldable t, Num a) => t a -> a
00:51:24 <lambdabot> Data.List sum :: Num a => [a] -> a
00:51:44 <Xenoblitz> anyways thanks
00:52:49 <mjrosenb> dons: hey, last night, you said i should attempt to debug ghc with gdb.  anything in particular i should do, or just break on main, and step from there?
00:56:08 <dons> quick, ask JaffaCake in #ghc
00:56:25 <dons> ac, oh, its very simple? then i'd just look at the core (using the ghc-core tool)
00:56:37 <dons> otherwise, read the profiling chapter in real world haskell (its online)
00:56:46 <ac> dons: ok, thanks :)
00:58:04 <idnar> @src maybe
00:58:04 <lambdabot> maybe n _ Nothing  = n
00:58:05 <lambdabot> maybe _ f (Just x) = f x
00:58:11 <idnar> uhm
00:58:33 <idnar> @hoogle Maybe a -> a -> a
00:58:33 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
00:58:33 <lambdabot> Prelude asTypeOf :: a -> a -> a
00:58:33 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
00:58:38 <idnar> @src fromMaybe
00:58:38 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
00:58:43 <idnar> ahh
01:04:38 <mmorrow> hmm. i'm reading oleg, and "we only use existentials and Typeable (the latter being expressible in-- Haskell98 with existentials,"
01:05:00 <mmorrow> so, i want to understand /exactly/ how to express Typeable with existentials
01:05:17 <dons> mmorrow: hmm. so a type class for all types in Typeable?
01:05:22 <mmorrow> err, that is to say, i'm not sure what he means by that
01:05:27 <dons> class Universal a where ...
01:05:32 <ejt> mmorrow: see the first scrap your boilerplate paper
01:05:34 <mmorrow> he says no classes
01:05:37 <dons> data Typeable = forall a . Universal a => a
01:05:39 <ejt> I think the appendix demonstrates this
01:05:41 <dons> ah no classes eh?
01:05:48 <dons> well, what's the fun in that? :)
01:05:48 <mmorrow> one sec
01:05:51 <mmorrow> heh
01:06:07 <mmorrow> http://okmij.org/ftp/Haskell/staged/IncopeTypecheck.hs
01:06:17 <dons> maybe he subscribes to jdh's school of `Haskell's type classes are incredibly obscure '
01:06:24 <mmorrow> (the "no classes" may not be refering to that statement in partic)
01:06:58 <mjrosenb> dons: anything?
01:07:27 <mmorrow> (that came from about paragraph 5)
01:07:31 <dons> mjrosenb: hmm. you need to find out where it is locked up?
01:08:15 <mjrosenb> that would probably be the most useful
01:08:26 <mjrosenb> guess i can just let it run for a while then ^C it
01:09:21 <mmorrow> this made me do a "omg that's awesome, and so obvious after the fact" http://okmij.org/ftp/Haskell/staged/TermLift.hs
01:10:18 <mmorrow> the interplay between to two stages there is geniush
01:11:06 <mmorrow> err, interplay is a bad word, since it's only flowing one way, i guess i mean "how the thing as a whole fits together"
01:12:36 <ejt> Olegs posts always make me feel stupid, because it's so clear when he describes stuff
01:12:54 <mmorrow> and with dynamic eval of TH expressions, that method fills in the last hole in being able to go from a String rep of the syntax to a typed interpretation thereof in one go
01:14:52 <mmorrow> ejt: he does have a nice ability to make things clear
01:15:17 <mmorrow> (but i think he's been doing this for a long time too ;)
01:19:52 <rwbarton> @quote OlegFacts
01:19:53 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
01:20:48 <mjrosenb> how do i ask the rest of the build process to build ghc with debuging symbols?
01:20:56 <mjrosenb> or is that not going to happen?
01:23:07 <mjrosenb> evidently not horribly needed
01:23:11 <mjrosenb> http://hpaste.org/10969
01:23:19 <mmorrow> dons: hmm "data Typeable = forall a . Universal a => a". is this what hs-plugins did/(does?) to get rid of the Typeable constraint in Dynamic?
01:23:49 <mmorrow> i've read that something like that was done, but haven't seen how
01:24:54 <idnar> how do I format a float as a string, with N decimal places shown?
01:25:35 <quicksilver> idnar: showEFloat, showFFloat, showGFloat
01:26:18 <idnar> > showEFloat (Just 3) 1234.56789
01:26:20 <lambdabot>       Overlapping instances for Show (String -> String)
01:26:20 <lambdabot>        arising from a...
01:26:57 <idnar> > showEFloat (Just 3) 1234.56789 ""
01:26:58 <lambdabot>   /tmp/7292086781970961156:67:72: Not in scope: `showEFloat'
01:27:14 <mjrosenb> ...
01:27:44 <mjrosenb> :t showEFloat
01:27:45 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
01:28:01 <idnar> it's -> ShowS really, it seems
01:28:02 <mmorrow> dons: hmm, looks like the reimplem of Dynamic was in the old hs-plugins, but not the current one (?)
01:28:09 <rwbarton> @src ShowS
01:28:10 <lambdabot> type ShowS = String -> String
01:28:32 <quicksilver> FFS why is lambdabot so BROKEN
01:28:34 <quicksilver> this is stupid.
01:28:45 <quicksilver> I think we should go back to hs-plugins.
01:29:51 <Axman6> eureka! i have discovered the formula for oldness
01:30:16 <Axman6> > let old n = n*(0.25+(1/n))
01:30:16 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
01:30:16 <lambdabot>  ...
01:30:23 <Axman6> yup...
01:30:26 <Axman6> > let old n = n*(0.25+(1/n)) in old n
01:30:28 <lambdabot>   n * (0.25 + 1 / n)
01:30:33 <Axman6> > let old n = n*(0.25+(1/n)) in old 18
01:30:34 <lambdabot>   5.5
01:30:40 <Axman6> ok, that's wrong
01:30:58 <Axman6> > let old n = n+50-0.75*n in old 18
01:30:59 <lambdabot>   54.5
01:31:17 <mmorrow> , src ''ShowS
01:31:31 <lunabot>  type ShowS = String -> String
01:32:12 <quicksilver> mmorrow: that's interesting
01:32:12 <rwbarton> mmorrow: did you see my hack to get src for class methods?  it was a couple of days ago
01:32:18 <mmorrow> man, that hosted machine must be in like 4 levels of VMs or something. slow as molasses
01:32:23 <quicksilver> mmorrow: what does "," do ?
01:32:31 <quicksilver> , src ''ShowS
01:32:36 <lunabot>  type ShowS = String -> String
01:33:26 <mmorrow> quicksilver: ah, the ',' is just the eval char. src :: Name -> Doc, and it uses dynamic eval to get the Info of that name via reify, then cleans it up and pprints it
01:34:54 <rwbarton> , text $ let l = lines $( do ClassOpI _ _ x _ <- reify '(**); return $ LitE $ StringL $ show (src x) ) in unwords $ [head l, "..."] ++ filter (isPrefixOf "(**)" . dropWhile isSpace) l ++ ["..."]
01:34:59 <mmorrow> dynReify n = normalizeT `fmap` fromDynamic (eval ("$(lift =<< reify "++nameToRawCodeStr n++")"))
01:34:59 <lunabot>  class (Fractional a) => Floating a where ...         (**) :: a -> a -> a ...
01:35:23 <mmorrow> and
01:35:27 <mmorrow> src = maybe (text "not found.")
01:35:27 <mmorrow>             (pprintInfo . everywhere (mkT (mkName . showNameParens . cleanName')))
01:35:27 <mmorrow>   . dynReify
01:36:06 <mmorrow> where those other funcs just unmangle it
01:36:46 <rwbarton> , src 'Just
01:36:50 <lunabot>  luna: Not in scope: type constructor or class `Just'
01:37:02 <mmorrow> oh, i fixed that, but on the lunabot on my laptop
01:37:07 <mmorrow> hold on
01:37:39 <quicksilver> mmorrow: nice.
01:37:56 <quicksilver> mmorrow: so, in a sense, you're regularising the special features LB had, by using TH?
01:38:05 <quicksilver> mmorrow: and making some TH features available in lunabot?
01:38:22 <mmorrow> quicksilver: exactly.
01:39:25 <mmorrow> (mostly so i don't have to mess with the extremely hackish bot that's feeding the input to the evaluator ;)
01:39:48 <rwbarton> quicksilver: this is basically the information that's available from :info in ghci
01:39:50 <mmorrow> well, not mostly. i use src all the time now
01:39:54 <mmorrow> yeah, exactly
01:40:12 <rwbarton> , src 'Just
01:40:14 <mmorrow> unfortunately though, TH doesn't retain instance info
01:40:19 <lunabot>  luna: /usr/local/ghc/ghc-6.10.0.20080927/lib/ghc-6.10.0.20080927/ghc-6.10...
01:40:19 <lunabot>  luna: luna: unable to load package `ghc-6.10.0.20080927'
01:40:23 <mmorrow> grrrr
01:40:50 <mmorrow> i updated my th package to fix it not finding False and broke everything
01:41:02 <mmorrow> i forgot about that :(
01:42:07 <mmorrow> well, i've gotta fix it eventually, so i guess the time is right
01:46:58 <idnar> @src on
01:46:59 <lambdabot> (*) `on` f = \x y -> f x * f y
01:47:31 <cjs> Ahg! Nailed by Map using Ord instead of Eq.
01:47:48 <cjs> Well, that will teach me to do have things EQ when they're not ==.
01:51:54 <mmorrow> rwbarton: fixed :)
01:51:58 <mmorrow> , src 'Just
01:52:05 <lunabot>  data Maybe a = ... | Just a | ...
01:52:05 <lunabot>  infixl 9
01:52:24 <rwbarton> nice
01:52:31 <mmorrow> i tried to make it pprint it just like ghci :i
01:52:44 <rwbarton> can you also fix up this hack:
01:52:46 <rwbarton> , text $ let l = lines $( do ClassOpI _ _ x _ <- reify '(**); return $ LitE $ StringL $ show (src x) ) in unwords $ [head l, "..."] ++ filter (isPrefixOf "(**)" . dropWhile isSpace) l ++ ["..."]
01:52:52 <lunabot>  class (Fractional a) => Floating a where ...         (**) :: a -> a -> a ...
01:53:01 <mmorrow> sweet
01:53:39 <mmorrow> ohh. so, i have an instance of Lift for Info. so you can just Lift it out of the $(...)
01:53:50 <mmorrow> , $(lift =<< lift '(**))
01:53:52 <lunabot>  AppE (AppE (ConE Language.Haskell.TH.Syntax.Name) (AppE (VarE Data.Packed...
01:53:52 <mmorrow> err
01:53:56 <mmorrow> , $(lift =<< reify '(**))
01:53:59 <lunabot>  ClassOpI GHC.Float.** (ForallT [a_1627414180] [AppT (ConT GHC.Float.Float...
01:54:28 <rwbarton> ah
01:54:33 <mmorrow> , case $(lift =<< reify '(**)) of ClassOpI _ _ x _ -> ppDoc x
01:54:36 <lunabot>  Floating
01:54:58 <mmorrow> hmm, ppDoc looks like it mangled it?
01:55:34 <mmorrow> , case $(lift =<< reify '(**)) of ClassOpI _ _ x _ -> x
01:55:37 <lunabot>  GHC.Float.Floating
01:55:39 <mmorrow> , case $(lift =<< reify '(**)) of ClassOpI _ _ x _ -> cleanNames x
01:55:41 <lunabot>  Floating
01:56:03 <mmorrow> looks like ppDoc needs fixing..
01:56:41 <rwbarton> @src Just
01:56:41 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
01:58:20 <mjrosenb> so, anyone know what i should be looking for within gdb?
01:59:26 <mmorrow> rwbarton: the TH pprinter for Info completely mangles the src, and i'm reparsing the pprinted src from TH with haskell-src-exts to get the nice formatting. it was a a slight pain to clean the TH data up so it would prettyprint without causing the haskell-src-exts parser to syntax err out.. :/
02:00:02 <mmorrow> , src ''Either
02:00:10 <lunabot>  Killed.
02:00:14 <mmorrow> , src ''Either
02:00:18 <lunabot>  data Either a b = Left a | Right b
02:01:13 <mmorrow> , (text . pprint . cleanNames') $(lift =<< reify ''Either)
02:01:16 <lunabot>  data Either a b = Left a | Right b
02:01:21 <mmorrow> , (text . pprint . cleanNames') $(lift =<< reify ''Monad)
02:01:24 <lunabot>  class Monad m
02:01:24 <lunabot>      where >>= :: forall m . Monad m => forall a b . m a ->
02:01:24 <lunabot>                                                      a -> m b -> m b
02:01:29 <mmorrow> , src ''Monad
02:01:33 <lunabot>  class Monad m where
02:01:33 <lunabot>          (>>=) :: forall b a . m a -> a -> m b -> m b
02:01:33 <lunabot>          (>>) :: forall b a . m a -> m b -> m b
02:02:29 <mmorrow> in particular in that example, i'm not sure what the deal is with the cxt, for every class method, "forall m . Monad m"
02:02:43 <mmorrow> i don't think that was intended (bug?)
02:03:53 <mjrosenb> that would appear to be missing some parens
02:04:43 <mjrosenb> that is quite wrong
02:05:39 <mmorrow> rwbarton: oh. if you were interested in that reify expression for actual use, i can give you the code to all the instances of Lift (i generated them. the resulting code is 1000+ lines)
02:06:54 <xpika> I want to implement an encryption algorithm in haskell for practise?
02:07:04 <xpika> does anyone know an easy common one?
02:08:36 <ozy`> xpika: sure, rot13
02:09:53 <mmorrow> rwbarton: (or i may have linked you to something containing them already at some point?)
02:10:30 <mmorrow> xpika: rsa is a classic
02:11:10 <mjrosenb> substitution cyphers are pretty easy
02:11:15 <xpika> ozy rot13 could be done in 1 lambda
02:11:22 <ozy`> xpika: yes it could
02:11:30 <ozy`> you did say "easy" and "common"
02:11:31 <mjrosenb> xpika: most things can
02:11:51 <xpika> mjrosenb: the linux kernel?
02:12:18 <mjrosenb> xpika: i guarantee that there is not a single lambda in the linux kernel, so that's done one better
02:12:54 <idnar> @hoogle IO a -> Maybe (IO a)
02:12:55 <lambdabot> Control.Exception block :: IO a -> IO a
02:12:55 <lambdabot> Control.Concurrent runInBoundThread :: IO a -> IO a
02:12:55 <lambdabot> Control.Concurrent runInUnboundThread :: IO a -> IO a
02:13:20 <Eridius_> huh, I didn't know you could hoogle method signatures
02:13:23 <ozy`> isn't the linux kernel object-oriented? there's a chance it might end up with a few lambda-like usages by accident
02:13:26 <idnar> @hoogle (b -> IO a) -> b -> Maybe (IO a)
02:13:26 <lambdabot> Control.Concurrent.MVar withMVar :: MVar a -> (a -> IO b) -> IO b
02:13:26 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
02:13:26 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
02:13:38 <mmorrow> xpika: if you want to do a symmetric one, might as well do aes, since they'll all prob be just as much effort/difficulty.
02:13:52 <idnar> @hoogle (b -> IO a) -> b -> IO (Maybe a)
02:13:53 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
02:13:53 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
02:13:53 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
02:14:16 <idnar> @type handle (const (return Nothing))
02:14:17 <lambdabot> forall a (m :: * -> *) b ex. (ArrowError ex (->), Monad m) => ((b, ex) -> m (Maybe a)) -> b -> m (Maybe a)
02:14:45 <idnar> @type return
02:14:46 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
02:14:49 <mjrosenb> Eridius_: that's 90% of what i use it for
02:14:55 <idnar> @type handle
02:14:56 <lambdabot> forall (a :: * -> * -> *) e b ex. (ArrowError ex a) => a e b -> a (e, ex) b -> a e b
02:15:25 <Eridius_> mjrosenb: it never occurred to me to search for a method signature in order to find a method that does what I want
02:15:26 <idnar> @type Control.Exception.handle
02:15:28 <lambdabot> forall a. (GHC.IOBase.Exception -> IO a) -> IO a -> IO a
02:15:37 <idnar> @type Control.Exception.handle (const (return Nothing))
02:15:38 <lambdabot> forall a. IO (Maybe a) -> IO (Maybe a)
02:17:24 <mmorrow> rwbarton: hah. i just realized tha ppDoc is fine, and i missed that you used a `src' in there
02:17:28 <mjrosenb> Eridius_: for example
02:17:42 <mmorrow> , case $(lift =<< reify '(**)) of ClassOpI _ _ x _ -> src x
02:17:47 <lunabot>  class (Fractional a) => Floating a where
02:17:47 <lunabot>          pi :: a
02:17:47 <lunabot>          exp :: a -> a
02:18:05 <mjrosenb> Eridius_: right now, i'm trying to find a function ppc64 -> ghc_6.8.3
02:18:22 <Eridius> mjrosenb: I'm not sure what you mean
02:18:26 <mjrosenb> Eridius: but hoogle has not helped with this
02:18:46 <BeelsebobWork> @seen mwallace
02:18:47 <lambdabot> I haven't seen mwallace.
02:18:56 <BeelsebobWork> @seen malcolmw
02:18:56 <lambdabot> I saw malcolmw leaving #haskell-blah, #haskell, #haskell-soc, #haskell-overflow, #darcs and #ghc 16h 6m 37s ago, and .
02:18:56 <mjrosenb> Eridius: bad joke, i've been trying to install ghc on my new desktop and it has so far been a misreable failure
02:19:03 <Eridius> ahh
02:19:06 <BeelsebobWork> bugger
02:19:47 <Eridius> ppc64 ... is this a G5? and does that mean OS X, or is this one of the rare breeds of ppc linux?
02:21:50 <BeelsebobWork> Eridius: it means its running on a G5, and who knows what OS
02:22:15 <BeelsebobWork> I believe the arch that OS X reports on such a machine is ppc64-darwin-9.5.0
02:23:09 <viktator> Hi, how do i convert an int to a double? :)
02:23:11 <mjrosenb> Eridius: it is a g5, and it is now running linux
02:23:13 <besiria> any good book on concurrency and/or parallelism?
02:23:38 <Eridius> viktator: fromIntegral should work
02:23:44 <viktator> okey thans
02:24:00 <Eridius> mjrosenb: ah well, if it's linux then I'm not even going to ask what's wrong :P
02:24:20 <BeelsebobWork> mjrosenb: I do know of a function that does that
02:24:31 <BeelsebobWork> but it calls the function insertOSXDVD
02:25:02 <viktator> is there a prelude function to count the number of digits in an int? now i use length show int
02:25:08 <BeelsebobWork> having said that, there's very little reason not to do that for most people
02:25:33 <Eridius> viktator: take the log base 10?
02:25:59 <viktator> thanks again :)
02:26:04 * Eridius chuckles
02:26:09 <Eridius> I came up with that trick in high school on my TI calculator
02:26:19 <mjrosenb>  length . show
02:26:34 <Eridius> told it to my math teacher and he was surprised he'd never thought of it
02:26:43 <viktator> :)
02:26:51 <Eridius> mjrosenb: that does have one flaw which is negative numbers will appear as having an extra digit
02:27:08 <mjrosenb> Eridius: true, but it's still smaller than yours
02:27:11 <Eridius> viktator: naturally you have to round it (well, ceil it)
02:27:18 <mjrosenb> and it wont blow up if you give it 0
02:27:19 <Eridius> mjrosenb: but probably less efficient
02:27:31 <Eridius> mjrosenb: what, -Infinity isn't correct?
02:27:44 <mjrosenb> yours has to do a converion to floating and back
02:28:06 <mjrosenb> but yeah, stringifying something is slow as hell
02:28:40 <oklocod> you can't really come up with a property of the logarithm that is basically its definition
02:29:30 <mjrosenb> oklocod: you mean thit is'nt basically its definition?
02:30:37 <Jedai> lenDigit 0 = 1; lenDigit n = 1 + logBase 10 (fromInteger . abs $ n)
02:31:07 <Jedai> oops missed a floor
02:31:14 <mjrosenb> lenDigit = length . show . abs
02:31:22 <mjrosenb> i still say mine is shorter :-p
02:32:18 <Eridius> mjrosenb: profile it
02:32:40 <pjdelport> > length . show . abs $ 1.0
02:32:41 <lambdabot>   3
02:33:07 <mjrosenb> pjdelport: ptththhhphbbptbp
02:35:12 <int-e> lenDigit 0 = 1; lenDigit n = 1 + logBase 10 (fromInteger . abs $ n)
02:35:37 <int-e> > let lenDigit 0 = 1; lenDigit n = 1 + logBase 10 (fromInteger . abs $ n) in lenDigit $ 10^10000
02:35:39 <lambdabot>   Infinity
02:36:05 <Eridius> length . show . (abs :: (Integral a) => a -> a)
02:36:43 <mjrosenb> Jedai: i think that will also do bad things if you give it -0.0
02:37:50 <oklocod> mjrosenb: i meant it's basically just knowing its definition, it's like inventing what 3+2 is after understanding addition
02:38:15 <int-e> > let f x@0 = (1/x, 0); f _ = (0, 0) in (f 0.0, f (-0.0))
02:38:16 <lambdabot>   ((Infinity,0),(-Infinity,0))
02:38:29 <Xenoblitz> help plz: http://hpaste.org/10971
02:39:04 <Jedai> mjrosenb: I though we were speaking about integer here, not float
02:40:14 <mjrosenb> Xenoblitz: http://qdb.us/104056
02:40:16 <lambdabot> Title: QDB: Quote #104056
02:40:50 <Jedai> int-e: Well logBase should be rewritten for integers I guess (or fixed, arbitrary precision real)
02:40:51 <mjrosenb> Jedai: whoops, that says frominteger, nat fromintegral
02:40:58 <Xenoblitz> please help: http://hpaste.org/10971 :P
02:41:14 <EvilTerran> Xenoblitz, please don't repeat yourself
02:41:18 <EvilTerran> we heard you the first time
02:41:25 <Xenoblitz> yes but i read what mjrosenb said
02:41:27 <Xenoblitz> :S
02:41:28 <Jedai> mjrosenb: I should have used fromIntegral instead
02:41:30 <Xenoblitz> in his link
02:41:37 <EvilTerran> ah
02:41:42 <EvilTerran> sorry, it wasn't loading for me :)
02:41:58 <EvilTerran> ok, well, the problem is that the where{} is attached to the "delayedMove lastTime window m
02:41:58 <EvilTerran> = "
02:42:01 <Xenoblitz> no problem, as opposed to np (I guess)
02:42:05 <EvilTerran> GAH EXTRANEOUS NEWLINES
02:42:16 * EvilTerran wonders if he can somehow train xchat to STOP DOING THAT
02:42:37 <Xenoblitz> i've tried to move the where around but what would be the correct indentation?
02:42:43 <EvilTerran> anyway, the scope of "game" is the do-block, which is entirely inside the where
02:42:53 <EvilTerran> there is no correct indentation, you can't attach a where to a do
02:43:17 <EvilTerran> Xenoblitz, http://hpaste.org/10971#a1
02:44:01 <Xenoblitz> seriously?? but look at this...http://hpaste.org/10972
02:44:05 <Xenoblitz> how does that work then?
02:44:09 <Xenoblitz> just asking to learn again :)
02:44:18 <Xenoblitz> oh wait
02:44:22 <Xenoblitz> so its attached to the last line?
02:44:27 <Xenoblitz> and it works by pure chance?
02:44:34 <EvilTerran> no...
02:44:36 <Eridius> it's attached to the definition
02:44:40 <EvilTerran> it's attached to the "="
02:44:41 <Xenoblitz> ah
02:44:49 <Xenoblitz> to the function itself
02:44:52 <EvilTerran> so the where can see parameters, but nothing defined within the do block
02:45:25 <Xenoblitz> ic now
02:45:30 <Xenoblitz> thanks for the clarification
02:45:34 <Xenoblitz> that's stuff you don't find anywhere
02:45:59 <viktator> is there a prelude function to count the number of digits in an int? now i use length show int
02:46:03 <viktator> sry
02:46:08 <viktator> typo
02:46:36 <EvilTerran> Xenoblitz, well, it can be deduced from the report
02:46:53 <EvilTerran> ...
02:47:08 * EvilTerran looks confusedly at viktator's retreating self
02:47:30 <Xenoblitz> i guess it could.. i need to refer to that document more often
02:47:33 <Eridius> EvilTerran: he meant to say "bye" but he typoed that into "is there a prelude function ..."
02:48:09 <EvilTerran> ah, easy mistake to make. the keys're right next to each other.
02:48:37 <EvilTerran> actually, they could be, if that was the last thing he said. i've typed a message, then hit up by accident before pressing return and sent the previous one instead
02:48:49 <EvilTerran> *the previous thing he said
02:48:52 <Cale> he did say that earlier
02:50:54 <Eridius> btw, after that discussion about log vs show, blah blah blah, I just want to remark that the log 10 trick is actually useful. As I said I first thought of that when doing TI programming, because there's no other way to do it on a TI calc
02:51:03 <int-e> > let lenDigit = succ . fst . lenBase 10 . abs; lenBase b n | n < b = (0, n); lenBase b n = let (l,n') = lenBase (b*b) n in if n' >= b then (2*l+1, n' `div` b) else (2*l, n') in map lenDigit [10^1000000, 10^1000000 - 1]
02:51:06 <lambdabot>   [1000001,1000000]
02:51:20 <Eridius> int-e: are you having fun?
02:51:24 <int-e> yes.
02:51:38 <BeelsebobWork> anyone know of any good tools for finding out where a program isn't lazy enough
02:51:44 <mjrosenb> iirc, i used that trick in vb many moons ago
02:51:52 <Eridius> BeelsebobWork: you could try yelling at it to get a job
02:51:57 <mjrosenb> BeelsebobWork: boot camp?
02:52:06 <Eridius> oh, isn't lazy enough, not is too lazy
02:52:08 <BeelsebobWork> Eridius: no, I want it to be lazier
02:52:16 <Eridius> give it a joint
02:52:31 <BeelsebobWork> mjrosenb: mostly queriing what you gain by running linux
02:52:31 <Eridius> maybe if it chills out a bit, it'll stop working so hard
02:52:51 <BeelsebobWork> mjrosenb: but bootcamp won't work on a PPC machine -- you'd need to fidle with bootx to dual-boot
02:53:06 <Jedai> BeelsebobWork: smallstep maybe ? Or just give it some value you think it should work on
02:53:08 <Eridius> BeelsebobWork: mjrosenb may have been making his own joke about lazy programs
02:53:25 <BeelsebobWork> oh
02:53:27 <BeelsebobWork> fail >.<
02:53:28 <mjrosenb> BeelsebobWork: yeah, that was my joke.
02:53:31 * Eridius chuckles
02:54:06 <mjrosenb> but i run linux mostly for the package manager (never been a fan of macports)
02:54:07 <Cale> BeelsebobWork: pattern matching is what spoils laziness.
02:54:20 <Eridius> mjrosenb: macports may not be perfect, but I would hardly throw away the OS over that
02:54:32 <BeelsebobWork> Cale: yeh, in this case I really can't see why though -- I need some way to diagnose what's demanding too much
02:54:41 <lilac> BeelsebobWork: can you paste?
02:54:47 <BeelsebobWork> sec
02:54:53 <Eridius> besides the dependency engine's general suckiness, the biggest problem macports has that other port systems don't is macports has mix-and-match variants on ports, which puts the possible combinations of ports into the uncoutably high
02:55:00 <Cale> In my case it's usually something silly, like sorting a list somewhere that I shouldn't be ;)
02:55:01 <lilac> (#haskell is the tool for finding where a program isn't lazy enough btw)
02:55:22 <Eridius> mjrosenb: maybe you should just write a new package manager for OS X? ;)
02:55:27 <mjrosenb> and because if i want to do X type stuff, i'd preffer to not have to go into obj-c
02:55:35 <Eridius> mjrosenb: what do you mean?
02:55:52 <mjrosenb> Eridius: part of the problem is that library support is a bit sketchy
02:55:55 <BeelsebobWork> lilac: http://hpaste.org/10973 <-- if I give typeOf a binding in the environment, and include a variable somewhere in the term to type check it locks up
02:56:03 <Eridius> mjrosenb: could you be a little bit more specific?
02:56:11 <mjrosenb> not that it's any less sketchy in linux on ppc64
02:56:34 <BeelsebobWork> I expected that it would be able to create a thunk for the variable's identity in the graph that could be used in typeOf' to create the graph, and then fill in the thunk
02:56:48 <mjrosenb> so when i want to write a small graphical thing
02:56:59 <mjrosenb> i usually just talk directly with xlib
02:57:04 <BeelsebobWork> lilac: of note, a variable bound by a lambda is working fine -- so the bug is somewhere in addEnvGraph
02:57:11 <Eridius> mjrosenb: well, OS X *does* have X11
02:57:30 <mjrosenb> yeah, but iirc, it's a bit of a hack
02:57:33 <Eridius> also, you can do "native" window stuff without Cocoa (using Carbon)
02:57:49 <BeelsebobWork> mjrosenb: you can install any one of apple's X11 hack XFree86 or bog standard XOrg
02:57:49 <Eridius> the various windowing toolkits generally have OS X ports
02:58:00 <int-e> BeelsebobWork: dunno, have you tried  ~(g,i) <- typeOf' e t  ?
02:58:22 <mjrosenb> iirc, there was also a bit of an issue playing .mkv
02:58:32 <Cale> BeelsebobWork: Just in case...  (g,i) <- typeOf' e t  will force evaluation, because it's a lambda binding
02:58:41 <Cale> int-e beat me to it :)
02:58:45 <BeelsebobWork> ahhhh
02:58:45 <hackage> Uploaded to hackage: storablevector 0.2.1
02:58:47 <Eridius> mjrosenb: you can use VLC for .mkv, or QuickTime Player if you have Perian installed
02:58:49 * BeelsebobWork runs off to test that
02:58:52 <int-e> BeelsebobWork: but it's a shot in the dark, I haven't looked at the precise data dependencies.
02:58:59 <Eridius> I actually just switched from using VLC to QTP because VLC appears to have a 4GB file size limit
02:59:01 <Cale> That's the only immediately suspicious thing, yeah.
02:59:09 <mjrosenb> Eridius: it's not like i wiped osx from the system, but for the time being i'm booted into linux
02:59:17 <Eridius> two different times I watched >4GB movies and VLC closed the movie near the end, as if it had finished
02:59:22 <Cale> I guess, inside typeOf', there's another one of those.
02:59:24 <Eridius> but QTP works fine
02:59:47 <mjrosenb> also, i'm not horribly familiar with the internals of osx
02:59:49 <Cale> er, duh, they're all in typeOf'
02:59:55 <Eridius> mjrosenb: fair enough. I've just never thought the few benefits linux has comes even close to outweighing the problems it has/what you're giving up by not running OS X
02:59:56 <mjrosenb> like mounting an nfs partition
03:00:07 <mjrosenb> and getting the login stuff over nis
03:00:07 <Eridius> Apple provides a read-only nfs filesysteml
03:00:09 <Eridius> *filesystem
03:00:13 <Eridius> they do that very deliberately
03:00:19 <Eridius> but you can install ntfs-3g via MacFUSE
03:00:29 <mjrosenb> nfs, not ntfs
03:00:32 <BeelsebobWork> Cale: typeOf' I'm fairly sure doesn't contain the bug -- because binding a variable in a lambda works fine
03:00:33 <Eridius> oh hey
03:00:43 <Eridius> I even said nfs and didn't catch that
03:00:44 <BeelsebobWork> (and uses the same trick)
03:00:58 <Eridius> mjrosenb: I don't know much about Apple's NFS stuff
03:01:01 <BeelsebobWork> yeh, the bug isn't the irrifutable pattern match in typeOf
03:01:05 <BeelsebobWork> :(
03:01:25 <Cale> BeelsebobWork: Is it a termination behaviour thing?
03:01:29 <Cale> Or a performance thing?
03:01:52 <int-e> hmm. mdo and Either, what does mfix look like for Either?
03:01:56 <BeelsebobWork> Cale: yeh, it doesn't terminate if I bind *any* variable in the environment, and I include a TmVar somewhere in the term
03:02:21 <Eridius> mjrosenb: did you have any problems with NFS in OS X? Because I was under the impression that it was supposed to work fine
03:02:46 <BeelsebobWork> Cale: but it does terminate if for example I attempt to type check (TmAbs "x" (TmVar "x"))
03:03:02 <mjrosenb> it took me a while to mount it
03:03:17 <BeelsebobWork> (with no environment)
03:03:17 <mjrosenb> then after i did there were issues due to different uids and gid's
03:03:29 <mjrosenb> there was also the amazing -P flag
03:03:46 <mjrosenb> which basically says talk on ports that other people can speak on
03:03:53 <BeelsebobWork> oh hmm, that's odd
03:03:57 <Cale> BeelsebobWork: So you're saying that  typeOf' empty (TmAbs "x" (TmVar "x"))  works, but  typeOf' nonEmpty (TmAbs "x" (TmVar "x")) doesn't?
03:04:58 <BeelsebobWork> Cale: no, typeOf' always works -- typeOf [] (TmAbs "x" (TmVar "x")) terminates, but typeOf [("monkies", TrBool)] (TmAbs "x" (TmVar "x")) doesn't terminate
03:05:03 <Eridius> mjrosenb: you sure the uid/gid thing isn't a flaw in NFS?
03:05:13 <Cale> ah, typeOf
03:05:29 <BeelsebobWork> so my guess is that constructing the environment requires a chunk of the graph somewhere
03:05:39 <Eridius> mjrosenb: a quick google seems to imply that NFS only talks uid/gid and not username/group name
03:05:52 <Cale> BeelsebobWork: Well, you have that mdo block there...
03:05:59 <lilac> BeelsebobWork: i think you need the (g,i) binding laziness, but you also need laziness in the (n,x) binding in addEnvGraph. not sure
03:06:35 <BeelsebobWork> lilac: oh, yeh, that's plausable
03:06:46 <mjrosenb> Eridius: this is true. but osx has a different numbering scheme
03:06:57 <Eridius> OS X starts user accounts at 501
03:07:00 <mjrosenb> Eridius: and tends to hand out uid's starting at 501
03:07:06 <BeelsebobWork> Cale: in theory, to compute the location of the things in the environment only needs the size of the graph to be computed -- which in theory doesn't need the values in it (which point at things in the env) computed
03:07:08 <mjrosenb> whereas linux starts at 1000
03:07:11 <BeelsebobWork> that's the theory at least
03:07:19 <Eridius> accounts >= 501 show up in the login panel, accounts < 500 don't (I don't know if uid 500 does)
03:07:27 <lilac> *not sure that's enough
03:07:29 <mjrosenb> also iirc osx does'nt support nis in any nice way
03:07:31 <Eridius> mjrosenb: the point here is, it's a flaw in NFS
03:07:38 <Cale> BeelsebobWork: Note that Data.Map values are structure-strict
03:07:46 <Cale> (but not value strict)
03:08:04 <Cale> So they can't be recursively defined in terms of themselves.
03:08:16 <Eridius> mjrosenb: I don't know anything about NIS, sorry
03:08:20 <BeelsebobWork> Cale: hmm, that sounds plausable as a location
03:08:32 <BeelsebobWork> ah actually
03:08:37 <BeelsebobWork> they are value strict
03:08:44 <Cale> they are?
03:08:44 <BeelsebobWork> they require the value to order themselves
03:08:50 <Cale> The keys
03:08:52 <BeelsebobWork> indeed
03:08:53 <mjrosenb> Eridius: nfs 4 has fixed this problem but i don't think anyone supports that
03:09:00 <mjrosenb> other than solaris and freebsd
03:09:02 <Cale> But not the values, I don't think.
03:09:05 <BeelsebobWork> oh, no, the keys aren't recursive there
03:09:07 <mjrosenb> not too sure about fbsd
03:09:08 <BeelsebobWork> so that's not it
03:09:12 <BeelsebobWork> it probably is the structure then
03:09:29 <Cale> well, that is the keys...
03:09:33 <Cale> hmm
03:10:03 <BeelsebobWork> Cale: hmm -- I'm not sure that makes sense actually -- becasue if you look at the definition of typeOf' for an abstraction, I use the same trick to add things to the environment map
03:10:06 <Cale> oh, but... in order to do the zip, the spine of the graphIds list will have to be lazy
03:10:31 <BeelsebobWork> Cale: yeh, which it *should* be
03:11:10 <Cale> Try adding some Debug.Trace.trace's around to observe the evaluation order perhaps.
03:11:22 <lilac> or tracing in ghci?
03:11:30 <Cale> or that :)
03:11:38 <BeelsebobWork> oh, good point
03:11:43 * BeelsebobWork goes to read the ghci debugger manual
03:12:32 <Cale> oh... I think I see what may be happening...
03:12:47 <BeelsebobWork> oh?
03:12:53 <int-e> BeelsebobWork: zip is your problem.
03:12:59 * EvilTerran wishes he had view patterns
03:12:59 <BeelsebobWork> how so?
03:13:23 <int-e> BeelsebobWork: zip is strict in both of its arguments, you need a version that is lazy in the second one, asserting that it has the right shape
03:13:40 <BeelsebobWork> int-e: oh!
03:13:43 <BeelsebobWork> I didn't realise that
03:14:06 <Cale> yeah, evaluating the first element of zip xs ys will force the evaluation of both xs and ys (up to the first cons cell, right?)
03:14:21 <BeelsebobWork> so I need zip [] _ = []; zip (x:xs) ~(y:ys) = (x,y):zip xs ys?
03:14:25 <int-e> BeelsebobWork: http://hpaste.org/10973#a1
03:14:29 <int-e> yes.
03:14:32 <Cale> and so the spine of the graphIds list gets evaluated when evaluating e
03:14:54 <BeelsebobWork> cheers guys
03:14:57 <BeelsebobWork> that was indeed the bug
03:15:07 <Cale> BeelsebobWork: Note that that new zip is slightly dangerous
03:15:10 <BeelsebobWork> thanks a lot -- it would have taken me a *long* time to spot that
03:15:17 <BeelsebobWork> Cale: yeh, but it's safe in this scenaria
03:15:26 <BeelsebobWork> because I'm certain the lists will be the same length
03:15:27 <Cale> We hope ;)
03:15:29 <Cale> okay
03:16:19 <BeelsebobWork> I think I may need to write something about that bug -- it's pretty subtle
03:16:21 <Cale> another solution would be to somehow try to ensure that addEnvGraph was really spine lazy, but that's hard
03:16:27 <Cale> er
03:16:28 <Cale> actually
03:16:36 <Cale> hmm
03:22:35 <BeelsebobWork> awesome, successfully blaming the right bits of the term now -- thanks loads Cale and int-e and lilac
03:25:28 <int-e> BeelsebobWork: hmm. would moving  let (graph, graphIds) = addEnvGraph g es  one line up and reverting to using zip also work?
03:25:43 <hugo_> hey
03:25:44 <int-e> BeelsebobWork: (i.e. tying the mfix knot on graph rather than graphIds)
03:25:49 <hugo_> i have a question about point free programming: http://hpaste.org/10974
03:25:54 <hugo_> how do i remove the "lst" ?
03:26:19 <BeelsebobWork> int-e: fraid not, that one stack overflows
03:26:30 <Cale> hugo_: Not without pain.
03:26:39 <int-e> BeelsebobWork: ok. just curious
03:26:51 <hugo_> Cale: oh :( and will it damage the readability ?
03:27:24 <Cale> hugo_: yeah, that's what I mean. I don't think there's a particularly readable way of extracting it.
03:27:34 <int-e> @type (,) <$> (fromMaybe "unnamed" . lookup "name") <*> (fromMaybe "unnamed" . lookup "name")
03:27:35 <lambdabot> [([Char], [Char])] -> ([Char], [Char])
03:27:43 <int-e> you'd lose the field names. not a good deal.
03:27:50 <hugo_> yes, i see...
03:28:02 <hugo_> its too much of a compromise
03:28:08 <hugo_> i guess ill keep it this way then :)
03:28:12 <hugo_> thanks :D
03:28:14 <Cale> Generally, where the parameter occurs many times, it gets harder to extract
03:28:35 <Cale> Even twice usually can't be dealt with without using function monad tricks :)
03:28:37 <hugo_> hmm
03:28:49 <EvilTerran> hugo_, http://hpaste.org/10974#a1
03:28:58 <EvilTerran> ah, i see it was being answered already
03:29:18 <EvilTerran> i'd be tempted to extract your fromMaybe/lookup into one function, too, actually
03:29:56 <hugo_> ohh
03:30:02 <hugo_> that is a good idea, thanks EvilTerran
03:30:16 <hugo_> i dont know what the <$> and <*> operators do...
03:30:19 <hugo_> ill have to read up
03:30:23 <mjrosenb> yeah flip lookup lst
03:30:24 <EvilTerran> Applicative is useful
03:30:55 <EvilTerran> hugo_, f <$> x1 <*> ... <*> xN = liftM{N} f x1 ... xN
03:31:11 <hugo_> ah, nice :D
03:31:34 <mjrosenb> EvilTerran: that sounds quite awesome
03:32:03 <EvilTerran> Applicative is basically a generalisation of Monad
03:32:07 <EvilTerran> to things that only have fmap and ap
03:32:25 <EvilTerran> (except it calls them <$> and <*>)
03:32:51 * mjrosenb needs to actually write the specification for a language
03:43:05 <EvilTerran> ... is the monad transformer FooT always the same as (Foo `O`)?
03:43:11 <quicksilver> no.
03:43:28 <EvilTerran> this strikes me as odd
03:43:29 <Cale> In fact, it's almost never equivalent to that.
03:43:33 <quicksilver> not even (`O` Foo)
03:43:38 <quicksilver> which is closer to the truth ;)
03:43:41 <EvilTerran> ah, yes
03:43:50 <quicksilver> MaybeT and ErrorT are of that form.
03:43:55 <quicksilver> StateT and ContT are not, IIRC.
03:43:59 <Cale> right.
03:44:47 <EvilTerran> is there a theoretical relationship between the structure of Foo and FooT?
03:45:11 <Cale> Typically, FooT Identity = Foo
03:45:19 <Cale> (up to isomorphism)
03:45:19 <EvilTerran> mmm
03:45:31 <EvilTerran> although that says very little about the shape of FooT
03:45:31 <Cale> But that's about it...
03:45:34 <Cale> yeah
03:45:50 <EvilTerran> given that that Identity could slip into the type almost anywhere
03:45:53 <lilac> am i right in thinking that the MonadLogic >>- for lists is not a legal >>= (ie, doesn't follow the monad laws)?
03:46:07 <EvilTerran> lilac, where is this?
03:46:07 <Cale> lilac: I think that's probably right.
03:46:18 <Cale> logict
03:46:27 <int-e> BeelsebobWork: ok, I think I understand where the data dependency is now - without having built the environment Map, we can't decide whether typeOf' will fail or not. If it fails, graphIds won't have a value.
03:46:29 <Cale> http://hackage.haskell.org/packages/archive/logict/0.2.3/doc/html/Control-Monad-Logic-Class.html
03:46:35 <lambdabot> Title: Control.Monad.Logic.Class, http://tinyurl.com/37f4ga
03:46:52 <BeelsebobWork> int-e: ah, yeh, that makes sense
03:46:58 <EvilTerran> hm
03:47:11 <Cale> I'm fairly sure that >>- fails associativity
03:47:13 <lilac> hmm. would a fair Applicative instance for [] be legal?
03:47:21 <EvilTerran> the >>= for Omega considers both branches and is alledgedly a Monad
03:47:34 <quicksilver> monad up to order considerations
03:47:36 <EvilTerran> s/the >>= for//
03:47:36 <quicksilver> I assume.
03:47:45 <EvilTerran> mmm
03:48:02 <quicksilver> quite a few things we want to be monads only obey the laws up to some equivalence
03:48:11 <quicksilver> which is probably fine, if you're aware of it.
03:48:12 <EvilTerran> i guess "could be made a Monad by only making the result available as some un-ordered collection"
03:48:21 <Cale> Or only apply to a subset of Haskell types.
03:48:25 <lilac> right, (>>-) isn't associative for [].
03:48:37 <EvilTerran> as in something like "runOmega :: Ord a => Omega a -> Set a"
03:49:18 <Cale> There's an idea...
03:49:26 <EvilTerran> well, doesn't it satisfy the Monad laws, just not MonadPlus?
03:49:34 <kowey> dear #haskell, i find using making Data.Map k [a] a lot... is there some sort of standard practice?
03:49:47 <Cale> Of course, you don't really get the benefit of the Ord operations throughout the computation then though
03:49:52 <EvilTerran> yeah
03:50:10 <EvilTerran> MPTCs, restricted monad classes, NoImplicitPrelude!
03:50:11 <quicksilver> kowey: that doesn't sound like something to worry about.
03:50:17 <quicksilver> kowey: do you use 'insertWith (++)\
03:50:18 <Cale> kowey: That seems like a reasonable type to me.
03:50:21 <rog_> @pl \((a,b), (c, d))) -> (a, c)
03:50:21 <lambdabot> (line 1, column 17):
03:50:21 <lambdabot> unexpected ")"
03:50:21 <lambdabot> expecting operator, pattern or "->"
03:50:40 <rog_> @pl \((a,b), (c, d))) -> (a, c))
03:50:40 <lambdabot> (line 1, column 17):
03:50:41 <lambdabot> unexpected ")"
03:50:41 <lambdabot> expecting operator, pattern or "->"
03:50:44 <rog_> oops
03:50:45 <Cale> Map Vertex (Set Vertex)  is an awesome way to represent graphs.
03:51:22 <lilac> although (>>-) /is/ associative if all you care about is the contents of the result and not the order :-/
03:51:28 <Cale> lilac: right
03:51:31 <EvilTerran> {-# LANGUAGE MultiParamTypeClasses, NoImplicitPrelude #-} import Prelude hiding (return,(>>=)); class Return m where return :: a -> m a; class Bind m a b where (>>=) :: m a -> (a -> m b) -> m b"
03:51:40 <EvilTerran> :D
03:51:42 <kowey> quicksliver, Cale: thanks... I've just always walked around with a feeling of constant re-invention :-)
03:51:51 <EvilTerran> er, "class Return m a where..."
03:52:15 <Cale> EvilTerran: That works, but you have to check more monad laws then.
03:52:31 <Cale> (aside from being a little ugly)
03:53:16 <EvilTerran> instance Ord a => Return Set a where return = S.singleton; instance (Ord a, Ord b) => Bind Set a b where m >>= f = fold (S.union . f) S.empty m
03:53:47 <rog_> @pl \((a, b), (c, d)) -> (a, c)
03:53:48 <lambdabot> uncurry ((`ap` snd) . (. fst) . (const .) . (,) . fst)
03:53:57 <rog_> not really worth it...
03:54:04 <EvilTerran> ?type fst *** fst
03:54:05 <lambdabot> forall a b a1 b1. ((a, b), (a1, b1)) -> (a, a1)
03:54:19 <EvilTerran> rog_, ^
03:54:35 <rog_> ooh that's out of my depth...
03:54:43 <rog_> @type ***
03:54:45 <lambdabot> parse error on input `***'
03:54:50 <Cale> @type (***)
03:54:51 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
03:55:00 <Cale> You can think of it as being
03:55:18 <Cale> (***) :: (b -> c) -> (b' -> c') -> ((b,b') -> (c,c'))
03:55:31 <lilac> that runOmega thing sounds nice. is there any way to opportunistically use the Ord constraint if it's present on intermediate computations?
03:55:43 <rog_> i've tried to get my head around arrows, and i haven't managed yet!
03:55:46 <EvilTerran> lilac, not really, no
03:55:47 <Cale> lilac: Not with that approach.
03:56:05 <EvilTerran> lilac, you'd need two overlapping instances of a class to do it
03:56:09 <EvilTerran> incoherent instances, even
03:56:22 <Cale> rog_: Like monads, they're just another way of structuring libraries to have some common operations so we can write some generic stuff which works across them.
03:56:28 <int-e> BeelsebobWork: oh. can you try moving up the let (graph, graphIds) = addEnvGraph g es  one line again, but this time also remove the 'let' keyword? (i.e. http://hpaste.org/10973#a2)?
03:56:46 <rog_> Cale: i kinda understand that. it's just that the abstraction isn't quite so obvious...
03:56:57 <EvilTerran> monads are *obvious"?!
03:57:07 <Cale> EvilTerran: kind of :)
03:57:10 <Cale> hehe
03:57:10 <rog_> easier than arrows...
03:57:59 <Axman6> i would not call them obvious
03:58:02 <rog_> i guess it's the fact that arrows are usually used point-free. it makes things less "concrete".
03:58:06 <Axman6> maybe not hard, just... different
03:58:18 <PeakerWork> rog_: what about proc do notation?
03:58:22 <Cale> rog_: Well, actually they're usually used with the arrow syntax, which is even less obvious
03:58:32 <Cale> rog_: (because it has an insane translation)
03:58:42 <mjrosenb> so i was able to grok monads due to the Maybe monad and the List monad
03:58:44 <rog_> yes, i've seen that, but most of the papers don't talk about that
03:58:45 <hackage> Uploaded to hackage: AERN-Real 0.9.7.2
03:58:52 <Cale> But you can see how the basic operations can be used to wire things up, and then just trust that the notation does it correctly.
03:58:52 <mjrosenb> then by writing my own
03:58:59 <lilac> Monads are much more obvious than Comonads at least
03:59:11 <rog_> i only really understood monads when i wrote a simplistic version of the IO monad in C.
03:59:15 <mjrosenb> i have no clue how to use arrows
03:59:16 <Cale> lilac: hmm... I'm not sure about that.
03:59:19 <Cale> lilac: Maybe.
03:59:30 <Axman6> mjrosenb: did you go through that list of exercises to implement the most common monads and their functions?
03:59:30 <EvilTerran> rog_, heh, i did that in SML before i found haskell
03:59:51 <Cale> Comonads are not that hard either, but maybe you wouldn't just stumble on to the idea so easily.
03:59:52 <rog_> EvilTerran: SML's perhaps easier 'cos you've got closures...
03:59:52 <PeakerWork> At first I understood arrows incorrectly, but then after a discussion here with (I forget...), where he explained how arrows are less expressive than monads, I finally understood them correctly (at least I believe I did) :)
04:00:02 <EvilTerran> rog_, yeah, that's true
04:00:04 <int-e> BeelsebobWork: (looking at the desugaring, if you write  mdo let { a = x }; let { x = f a }; return (), then 'x' gets threaded through 'mfix'. In contrast,  mdo let { a = x; x = f a }; return ()  ties the knot directly.)
04:00:16 <Axman6> PeakerWork: well, go ahead, explain then :P
04:00:22 <Cale> rog_: have you seen the diagrams at http://www.haskell.org/arrows/
04:00:23 <lambdabot> Title: Arrows: A General Interface to Computation
04:00:26 <Cale> and http://www.haskell.org/arrows/syntax.html
04:00:27 <lambdabot> Title: Arrow syntax
04:00:57 <BeelsebobWork> int-e: yeh, that works, and it's much nicer
04:00:58 <Cale> rog_: That provides a good idea of how to picture what arrows are about.
04:01:11 <PeakerWork> rog_: IMO, the important difference between arrows and monads, is that arrows do not let you structure the arrow at "runtime" (the structuring of the arrow cannot depend on the data that is flowing through the arrow)
04:01:18 <BeelsebobWork> thanks a lot :)
04:01:25 <Cale> PeakerWork: yes, that's an excellent point
04:01:38 <rog_> i have, and i understand (kind of) the principles, and even one of the original motivating examples (static info about a general parser), but i'm still in the dark generally...
04:01:50 <PeakerWork> rog_: that makes arrows less expressive than monads - but it means that arrow libraries can do interesting analysis that monad libraries cannot
04:02:39 <rog_> PeakerWork: presumably that's why they're often used point-free?
04:02:45 <PeakerWork> rog_: it also means that the arrow structure cannot be built with simple haskell functions (which is how monads have just 2 simple operations in them) but instead arrows require a bunch of structuring primitives (first, ***, and a few others) which let you build the structure of the arrow
04:02:56 <Cale> Also, with monads, you have bind:  (>>=) :: m a -> (a -> m b) -> m b, where that (a -> m b) is an arbitrary function, and as a function cannot possibly be observed except by applying it.
04:03:15 <PeakerWork> Cale: Yeah, I think that is how that above difference is expressed
04:03:15 <younder> Just worked my way through "Just another Haskell tutorial"
04:03:24 <younder> where do I go from there?
04:03:29 <Cale> With arrows, you chain things together with (>>>) :: a b c -> a c d -> a b d
04:03:49 <PeakerWork> one of the things that helped me understand arrows was using ~> syntax instead of "a b c" syntax, too :)
04:03:55 <Cale> Since both its parameters are of the type which you control, they *might possibly* be observable
04:04:12 <rog_> i get confused when the terminology goes out of my sphere (e.g. Kleisli arrows)
04:04:57 <Cale> younder: hmm... well, there's Real World Haskell, if you're looking for more book material. There's also lots of libraries on Hackage to look at, and the Hierarchical libraries documentation.
04:05:15 <Cale> younder: Also, papers by SPJ and others.
04:05:19 <rog_> so, in plain english, what does *** do?
04:05:24 <Cale> (Simon Peyton Jones)
04:05:47 <Cale> rog_: it lines two arrows up in parallel to make an arrow which sends pairs to pairs
04:06:09 <Cale> (does that make sense?)
04:06:45 <rog_> yes
04:06:53 <Cale> So if I have two arrows, f :: (a ~> b), and g :: (c ~> d), then (f *** g) :: ((a,c) ~> (b,d))
04:07:11 <PeakerWork> ~> ftw :)
04:07:17 <rog_> but those look like functions to me, not arrows...
04:07:27 <Cale> ~> might not be the function arrow ->
04:07:30 <rog_> ... or are they the same in some contexts?
04:07:34 <Cale> It might be some other type which you defined.
04:07:34 <PeakerWork> rog_: ~> vs ->  its a syntax that makes arrows more easily understood, imo :)
04:07:47 <rog_> oh, yes, v similar in my current font
04:07:48 <Cale> -> is an instance of Arrow
04:08:00 <PeakerWork> rog_: Arrow (~>) => b ~> c  is just an easier syntax than:  Arrow a => a b c
04:08:27 <rog_> does ghc understand that syntax?
04:08:36 <Cale> yes
04:08:47 <Cale> It understands  ~>  to be a type variable.
04:08:52 <Cale> (infix)
04:08:59 <EvilTerran> -XTypeOperators
04:09:10 <chr1s> nice!
04:09:14 <chr1s> I didn't know that.
04:09:37 <rog_> all these extensions. does anyone program in pure '98?
04:09:45 <chr1s> rog_: sure, all the time.
04:10:08 <Cale> I'm usually not too concerned about what extensions I use.
04:10:46 <rog_> i wasn't until i discovered that (for instance) hat only works with '98. and it'd be nice to be able to use that (if i could get it built)
04:11:42 <Cale> You can always use the GHC tracing stuff.
04:12:03 <Cale> Hat is also usually not happy about libraries too.
04:13:17 <rog_> Cale: the GHC tracing stuff doesn't work too well, i've found.
04:13:20 <Cale> hmm
04:13:30 <Cale> I haven't had much chance to use it.
04:13:50 <rog_> ... at least, if you're talking about Trace.trace
04:14:11 <Cale> rog_: As an example of something you might be able to do in some arrows which you can't do with functions, you might have arrows for manipulating time-varying values.
04:14:35 <Cale> Like "signal transformers"
04:14:59 <Cale> and then you might have a signal transformer which integrates its input signal to produce its output signal
04:15:27 <Cale> and you might have other stateful things going on
04:16:09 <Cale> Certainly, a plain function Double -> Double can't integrate its inputs, since it doesn't know what they were or will be
04:16:26 <Cale> But a   SignalTrans Double Double  might be able to.
04:16:30 <hugo_> i have another newbie question: i have this function that has a case to split an Either, then if it is Left it returns IO (), if it is Right it returns a [(String, String)], how do i fix this ? :(
04:16:49 <Cale> hugo_: well, you have to make the types match
04:17:20 <hugo_> i can't see how :/ it is not trivial
04:17:39 <Cale> Well, one thing you can do is produce an Either
04:17:54 <hugo_> oh
04:17:57 <hugo_> nice
04:18:03 <hugo_> then ill treat with it later
04:18:05 <Cale> or, you could make the result type  IO [(String,String)]
04:18:08 <Cale> yeah
04:18:42 <hugo_> IO [(String, String)] is a bit clumsy for the error message i guess :/
04:18:50 <rog_> Cale: that's interesting. 'specially as i'm doing stuff with continuously defined functions currently.
04:19:08 <hugo_> postponing the either seems like a good solution, since it will be easier to return the same type later
04:19:11 <hugo_> thanks
04:19:41 <rog_> Cale: for integration, i just have integrate :: (Double, Double) -> (Double -> Double) -> Double
04:19:53 <Cale> rog_: right
04:20:31 <Cale> and that can work reasonably well of course :)
04:21:36 <SamB_XP> heh -- continuous
04:21:37 <rog_> and yesterday's discussion about memoisation was (for me) in that context. (i.e. we want to memoise the results of the given function)
04:21:45 <SamB_XP> Double isn't continuous ;-P
04:21:59 <rog_> indeed.
04:21:59 <Cale> ah
04:22:53 <rog_> ... which means, i think, that i need a "memoisation-aware" version of integrate and friends
04:23:19 <Axman6> rog_: might want to have a look at http://www.haskell.org/haskellwiki/Memoization
04:23:20 <lambdabot> Title: Memoization - HaskellWiki
04:23:51 <rog_> i did have a look at that, but it was a while ago now.
04:24:12 <rog_> i don't think it went as far as i needed.
04:24:22 <rog_> i did find a useful paper on it somewhere.
04:24:32 <Cale> Well, if you have various integrals memoised, you could store them in a Data.Map, which you pass to your integrator, so that it can try to make use of the known intervals.
04:24:58 <Cale> (supposing that you're integrating the same function on different domains)
04:25:55 <Cale> That actually seems like it raises some interesting algorithmic questions :)
04:25:56 <hugo_> i like haskell, it enforces me to think on the error cases in order to continue with the code... finesse :)
04:26:08 <rog_> i think the paper was probably: http://www.cs.utexas.edu/~wcook/Drafts/2006/MemoMixins.pdf
04:26:10 <lambdabot> Title: Monadic Memoization Mixins
04:27:30 <rog_> Cale: the function passed to the integrator is not necessarily the very same function that is memoised...
04:28:16 <Cale> rog_: ah, well, that's more complicated, since functions are not observable apart from evaluating them at various points
04:28:28 <rog_> Cale: i'm trying to make a general framework for combining these things.
04:28:34 <Cale> (unless you represent the functions you're working with in another way)
04:29:30 <rog_> Cale: indeed. my thoughts along the lines of discretising the inputs to the function, memoising the results, and linearly interpolating in between.
04:31:15 <rog_> Cale: but in theory, i'd like to be able to be able to combine a pure function onto a memoised function. the memoisation is necessary only for some functions. at least i don't have to deal with recursion (i think)
04:31:40 <rog_> anyway, it's my own hole i'm digging!
04:31:52 <Cale> :)
04:32:47 <hugo_> hmm
04:33:04 <hugo_> what happens when i have IO IO Blah ? :P
04:33:13 <quicksilver> join.
04:33:22 <quicksilver> :t join
04:33:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
04:33:26 <hugo_> oh, nice :)
04:33:47 <Cale> A value of type IO (IO t) is an action which can do some IO before producing another action as its result.
04:34:10 <hugo_> it makes sense :)
04:34:19 <hugo_> very nice heheh
04:34:35 <rog_> in the end, the static type framework of haskell is not really the answer, 'cos my final object is to allow the user to dynamically compose functions of varying types. i'm really just using haskell to prototype an instance of the design...
04:34:36 <Cale> If x :: IO (IO t), you can also write something like  do y <- x; v <- y; ...
04:35:09 <hugo_> sequencing the IO's, i see...
04:35:33 <rog_> ... which isn't of course to say that i can't do it in haskell, just that i'll have to re-implement a type system before i do so.
04:35:41 <Cale> In fact, you can write join that way:  join x = do y <- x; v <- y; return v
04:36:24 <quicksilver> hugo_: yes, in practice you very rarely need join explicitly.
04:36:32 <quicksilver> you normaly unwrap the IOs as fast as they build up
04:36:36 <quicksilver> using >>= or do notation.
04:36:41 <quicksilver> it's good to know it exists, though
04:36:45 <quicksilver> it fills in a conceptual gap.
04:36:54 <hugo_> very flexible
04:37:08 <Cale> It's also nice to see how >>= can be written in terms of  fmap/liftM  and join
04:37:17 <Cale> x >>= f = join (fmap f x)
04:38:50 <hugo_> hmm, that is a bit more hard for me to digest... let me think on it...
04:39:02 <Cale> work out the types first :)
04:49:43 <Axman6> is 3.4s fast when calculating fib 1000000?
05:00:27 <pastorn> heh
05:00:52 <pastorn> > let fib = 0 : 1 : zipWith (+) fib (tail fib) in fib !! 1000000
05:00:54 <lambdabot>   * Exception: stack overflow
05:00:58 <Axman6> fib 100000 i mean... bit of a difference there
05:01:04 <daf> Axman6: that depends entirely on which computer you're running it on
05:01:04 <pastorn> yesh...
05:01:25 <Axman6> 2.4GHz Core 2 Duo with 4GB RAM
05:01:37 <Axman6> which... my program fills pretty quickly
05:01:39 <daf> nothing is fast without context
05:01:40 <Cale> Axman6: No, it's not particularly fast.
05:01:51 <Axman6> bah
05:02:00 <pastorn> why does that overflow?
05:02:00 <Axman6> faster than my versions used to be ;0
05:02:27 <Cale> I'm on a 2.4 GHz P4, and have a fib here which does fib 1000000 `seq` () in under a tenth of a second.
05:02:40 <Axman6> :|
05:02:54 <Axman6> but you're Cale, i'd expect no less. i'm just a mere mortal
05:03:02 <Cale> But it uses a clever algorithm :)
05:03:10 <Axman6> care to share?
05:03:12 <pastorn> doesn't (!!) forget all that's been traversed through?
05:03:35 <Cale> http://www.haskell.org/haskellwiki/The_Fibonacci_sequence
05:03:36 <lambdabot> Title: The Fibonacci sequence - HaskellWiki
05:04:12 <Cale> has some rather fast ones :)
05:04:47 <Cale> In particular, the "Fastest Fib in the West" uses a good algorithm.
05:07:16 <Cale> A good algorithm for fib will only do logarithmically many operations, that is, the number of additions and multiplications will be on the order of the number of bits of the input.
05:07:37 <Cale> (of course, additions and multiplications are not free here)
05:07:46 <Cale> (not even constant time)
05:08:43 <Axman6> the ones bt wli are crazy :|
05:09:21 <Axman6> by*
05:09:45 <Cale> well, they recurse directly on n treated as a string of bits.
05:12:59 <Cale> http://en.wikipedia.org/wiki/Fibonacci_sequence#Identity_for_doubling_n -- the identities around here are crucial for understanding.
05:13:00 <lambdabot> Title: Fibonacci number - Wikipedia, the free encyclopedia, http://tinyurl.com/9m8br
05:14:58 <pcapriotti> is ((->) a) defined as a monad somewhere in the standard libraries?
05:15:02 <Axman6> Cale: yeah well... how much RAM does yours use? mine can easily get to a GB >_>
05:15:20 <Cale> pcapriotti: yes
05:15:25 <Cale> Control.Monad.Instances
05:15:30 <Cale> or Control.Monad.Reader
05:15:32 <pcapriotti> Cale: oh, thanks
05:15:41 <Cale> It ought to be in the Prelude
05:15:45 <Cale> But it's not
05:16:21 <pcapriotti> is it possible to find out such things with hoogle?
05:17:45 <Cale> I'm not sure... I don't think so.
05:19:43 <pjdelport> @instances (->)
05:19:44 <lambdabot> Couldn't find class `(->)'. Try @instances-importing
05:19:49 <pjdelport> @instances ((->) a)
05:19:49 <lambdabot> Couldn't find class `((->) a)'. Try @instances-importing
05:20:16 <pjdelport> @instance Reader ((->) a)
05:20:16 <lambdabot> Maybe you meant: instances instances-importing
05:20:25 <Cale> If the instance is in scope, you can find out from where using  :info <classname>
05:20:42 <Cale> which will show all the instances you've got, and what module they're from
05:20:45 <pcapriotti> ok, I see
05:21:07 <Axman6> what is with freenode today
05:21:13 <Axman6> or, the last few days really
05:24:05 <Cale> instance Monoid w => Monad ((,) w)  seems completely missing
05:25:23 <Cale> Not to mention other instances for (,) a
05:27:59 <pastorn> :i Monoid
05:28:06 <pastorn> @info Monoid
05:28:06 <lambdabot> Monoid
05:28:56 <pcapriotti> is there something like safeHead :: Monad m => [a] -> m a
05:29:07 <pcapriotti> ?
05:29:39 <Cale> Not in the libraries
05:29:43 <Cale> I hate all these things which use the Monad class to express failure, anyway :/
05:29:50 <Cale> It's the wrong class for it.
05:29:58 <pjdelport> :t listToMaybe
05:29:59 <lambdabot> forall a. [a] -> Maybe a
05:30:05 <pjdelport> pcapriotti: -^
05:30:07 <Cale> yes, there is that :)
05:30:14 <Axman6> > listToMaybe []
05:30:16 <lambdabot>   Nothing
05:30:19 <pcapriotti> yeah, I know that
05:30:20 <Axman6> > listToMaybe [1..10]
05:30:22 <lambdabot>   Just 1
05:30:59 <Cale> pastorn: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
05:31:01 <lambdabot> Title: Data.Monoid, http://tinyurl.com/szdxl
05:31:01 <pcapriotti> Cale: what would do you use to express that kind of failure?
05:31:03 <Beelsebob> > listToMaybe [] :: Either String Int
05:31:04 <lambdabot>   Couldn't match expected type `Either String Int'
05:31:11 <Beelsebob> not what he was asking for then ;)
05:31:16 <Cale> pcapriotti: Well, we used to be able to use MonadZero
05:31:26 <Cale> pcapriotti: But now the closest approximation is MonadPlus.
05:31:54 <Cale> pcapriotti: Personally, though, I just use Maybe
05:32:12 <pastorn> Cale: how do i ask lambdabot something and get her to give me the URL to the api?
05:32:22 <pjdelport> :t maybe mzero return . listToMaybe
05:32:23 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [a] -> m a
05:32:25 <Cale> Uh, I don't know.
05:32:34 <pjdelport> :t maybe (fail "boink") return . listToMaybe
05:32:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => [a] -> m a
05:32:41 <Cale> I remember there was something like that at some point.
05:32:59 <Cale> @index Data.Monoid
05:33:00 <lambdabot> bzzt
05:33:02 <pjdelport> but really, Maybe is wholly descriptive
05:33:11 <Axman6> @where MonadPlus
05:33:11 <lambdabot> I know nothing about monadplus.
05:33:14 <Axman6> lame
05:33:30 <pastorn> Cale, Axman6: thanks anyway :)
05:33:50 <Cale> pastorn: I just have bookmarks to the Hierarchical libraries in my web browser :)
05:33:59 <Cale> In fact, a whole tree :)
05:34:34 <maltem> Sorry to be OT again, has this sum a specific name? http://www.planet-metax.de/texpaste/images/7a0499ae4fde2b75ed9a556c0eebf1bf.png
05:34:51 <pastorn> you manually bookmarked them all or did you do same l33t skriptin'
05:35:11 <Cale> pastorn: Drag and drop
05:35:31 <Cale> (so manually)
05:35:34 <pastorn> heh
05:35:37 <Cale> maltem: hmm
05:36:31 <pastorn> I think lambdabot should give url with the command @hoogle, is that a crazy idea?
05:36:38 <pastorn> *urls*
05:38:10 <dancor> oh nice
05:38:10 <lambdabot> dancor: You have 1 new message. '/msg lambdabot @messages' to read it.
05:38:31 <Cale> maltem: Where does it come from?
05:39:49 <Axman6> isn't (n n) 1? i could be totally wrong...
05:39:56 <ddarius> @source Data.Monoid
05:39:56 <lambdabot> http://darcs.haskell.org/packages/base/Data/Monoid.hs
05:39:57 <maltem> Cale: it arised from an exercise I was doing today. The question was, how many surjective mappings f : A -> B are there, if A and B have cardinality 11 and 4
05:39:57 <Axman6> we've never used that notation
05:40:07 <Axman6> ddarius to the rescue
05:40:26 <maltem> Axman6: it is, but then the pattern doesn't look that nice anymore ;)
05:40:34 <Axman6> heh
05:40:56 <Axman6> and (n 1) = 1 too?
05:41:02 <maltem> no, n
05:41:05 <Axman6> ok
05:42:11 <maltem> Cale: I calculated 4^11 - 4*3^11 + 6*2^11 - 4, and then, out of curiosity, wrote it out for n and k
05:43:51 <Cale> maltem: hmm... the number of surjections from a set of size n to a set of size m would be the coefficient of x^n/n! in (e^x - 1)^m...
05:44:34 <Cale> So that's [x^n/n!] sum over k = 0 to m of (m;k) e^(kx) (-1)^(m-k)
05:44:57 <Cale> = sum over k = 0 to m of (m;k) (-1)^(m-k) k^n
05:44:57 <medfly> i didn't realize he asked a question.
05:45:17 <Cale> Let's see, is that the same? :)
05:45:50 <Cale> It looks like it is... though maybe there's a term missing?
05:45:56 <lilac> medfly: "has this sum a specific name?"
05:46:01 <maltem> Cale: ah that's interesting. I tried to write it with the sum sign, but failed to find the exponent for (-1). let me have a look...
05:48:00 <nomeata> Hi. How do I wirte an instanstance for [] with TH? Neither "InstanceD [] (AppT (ConT (mkName "Class")) ListT" nor "InstanceD [] (AppT (ConT (mkName "Class")) (ConT (mkName "[]"))" seems to work.
05:49:03 <mmorrow> , [d|instance Functor [] where fmap = map|]
05:49:09 <lunabot>  luna: `fmap' is not a (visible) method of class `GHC.Base.Functor'
05:49:14 <mmorrow> gr
05:49:36 <Cale> What a strange error...
05:49:42 <mmorrow> i always just use brackets to have it print the syntax out for me, so i can see what i need to build
05:49:51 <Cale> Maybe not importing things correctly?
05:49:55 <nomeata> , [d| instance Funcotr [] |]
05:49:57 <lunabot>  luna: Not in scope: type constructor or class `Funcotr'
05:50:01 <nomeata> , [d| instance Functor [] |]
05:50:05 <lunabot>  luna: Duplicate instance declarations:
05:50:05 <lunabot>    instance GHC.Base.Functor [] -- Defined at <interactive>:1:63-72
05:50:05 <lunabot>    instance GHC.Base.Functor [] -- Defined in base:GHC.Base
05:50:09 <Cale> heh
05:50:09 <mmorrow> Cale: i think it's because i'm heavily cleaning names to make them look not hideously ugly
05:50:18 <Cale> mmorrow: hmm, okay
05:50:22 <mmorrow> hm
05:50:23 <lilac> @let n `c` r = product [r+1..n] `div` product [1..n-r]; maltem n k = sum [(n `c` (n-i)) * (n-i)^k * (-1)^i | i <- [0..n-1]]
05:50:24 <lambdabot>  <local>:23:72:
05:50:24 <lambdabot>      Ambiguous occurrence `c'
05:50:24 <lambdabot>      It could refer to either `...
05:50:29 <mmorrow> weird
05:50:31 <Cale> , [d| instance Functor ((,) a) |]
05:50:32 <maltem> Cale: alright, it is the same :)
05:50:33 <lunabot>  luna: Duplicate instance declarations:
05:50:33 <lunabot>    instance GHC.Base.Functor ((,) a)
05:50:33 <lunabot>      -- Defined at <interactive>:1:63-77
05:50:35 <mmorrow> oh, nm
05:50:52 <Cale> nomeata: heh, well, you can try it for yourself in ghci ;)
05:51:10 <int-e> nomeata: isn't there a ListT?
05:51:33 <nomeata> Cale: how do I show a [Q Dec] in ghci?
05:52:08 <mmorrow> , let x = 9 in eval "x"
05:52:11 <nomeata> Cale: there is, but using it gives me:  Malformed type ListT When splicing generated code into the program
05:52:19 <lilac> @hoogle Q a -> IO a
05:52:19 <lambdabot> Language.Haskell.TH runQ :: Quasi m => Q a -> m a
05:52:19 <lambdabot> Language.Haskell.TH.Syntax runQ :: Quasi m => Q a -> m a
05:52:19 <lambdabot> Control.Exception evaluate :: a -> IO a
05:52:22 <lunabot>  luna: Not in scope: `x'
05:52:32 <lilac> nomeata: runQ . sequence?
05:52:39 <int-e> @type Language.Haskell.TH.ListT
05:52:40 <lambdabot> Language.Haskell.TH.Syntax.Type
05:53:05 <mmorrow> , [t|forall a. [a]|]
05:53:07 <lunabot>  ForallT [a_0] [] (AppT ListT (VarT a_0))
05:53:35 <mmorrow> , 'fmap
05:53:37 <lunabot>  GHC.Base.fmap
05:53:43 <mmorrow> , cleanName 'fmap
05:53:45 <lunabot>  fmap
05:54:42 <mmorrow> , let e = varE 'fmap in [|$e (*2) [0..9]|]
05:54:44 <lunabot>  AppE (AppE (VarE fmap) (InfixE Nothing (VarE *) (Just (LitE (IntegerL 2))...
05:54:56 <mmorrow> , let e = varE (mkName "fmap") in [|$e (*2) [0..9]|]
05:54:58 <lunabot>  AppE (AppE (VarE fmap) (InfixE Nothing (VarE *) (Just (LitE (IntegerL 2))...
05:55:08 <mmorrow> , $(let e = varE 'fmap in [|$e (*2) [0..9]|])
05:55:11 <lunabot>  luna: A section must be enclosed in parentheses
05:55:11 <lunabot>    thus: (`base:GHC.Num.*` 2)
05:55:56 <mmorrow> that one i didn't cause (i don't think)
05:56:08 <mmorrow> , $(let e = varE 'fmap in [|$e ((*2)) [0..9]|])
05:56:10 <lunabot>  luna: A section must be enclosed in parentheses
05:56:10 <lunabot>    thus: (`base:GHC.Num.*` 2)
05:56:54 <mmorrow> , $(let e = varE 'fmap in [|$(appE e [|\x->x*2|]) [0..9]|])
05:56:56 <lunabot>  [0,2,4,6,8,10,12,14,16,18]
05:57:12 <mmorrow> , $(let e = varE (mkName "fmap") in [|$(appE e [|\x->x*2|]) [0..9]|])
05:57:14 <lunabot>  [0,2,4,6,8,10,12,14,16,18]
05:57:18 <mmorrow> huh
05:57:23 <Cale> maltem: Ah, it's m! {m;n}, where {m;n} is the Stirling number of the second kind, which is unsurprising, if you know what those are ;)
05:58:03 <Cale> maltem: (they tell you the number of ways of partitioning a set of size m into a set of n disjoint subsets.
05:58:05 <Cale> )
05:58:10 <maltem> Cale: ah, Stirling numbers are the next chapter, I didn't have a look at them yet. thanks :)
05:58:53 <mmorrow> , src ''Tree
05:58:53 <Cale> (disjoint, nonempty subsets)
05:58:58 <lunabot>  data Tree a = Node {rootLabel :: a, subForest :: (Forest a)}
05:59:00 <nomeata> Ok, it works with "ConT ''[]"
05:59:11 <mmorrow> nomeata: nice
05:59:47 <nomeata> but strange then that mkName "[]" did not work
05:59:55 <int-e> nomeata: but not with ListT?
06:00:33 <mmorrow> nomeata: i have a useful function which normalizes that ListT/ConT ''[] cases.
06:00:36 * mmorrow gets it
06:01:20 <nomeata> int-e: no, not here at least
06:03:55 <mmorrow> nomeata: it also normalizes tuples http://hpaste.org/10978
06:04:28 <mmorrow> ugh, the catchall case got cut off
06:05:14 <nomeata> mmorrow: coudn’t you count the number of commas?
06:06:18 <mmorrow> nomeata: i could, but since it's coming in as a type, it never has to go through a String
06:06:40 <mmorrow> (here's the crucial catchall case :) http://hpaste.org/10978#a1
06:07:15 <nomeata> mmorrow: but you are alrady mathing a string?
06:07:37 <mmorrow> nomeata: i'm matching on the name of the Type
06:07:42 <mmorrow> , ''(,,,,,,,,,,,,,,,,,,,,,)
06:07:44 <lunabot>  GHC.Tuple.(,,,,,,,,,,,,,,,,,,,,,)
06:08:06 <mmorrow> , showName ''(,,,,,,,,,,,,,,,,,,,,,)
06:08:09 <lunabot>  "GHC.Tuple.(,,,,,,,,,,,,,,,,,,,,,)"
06:08:17 <nomeata> ah, now I see. nevermind then
06:08:23 <mmorrow> , nameBase ''(,,,,,,,,,,,,,,,,,,,,,)
06:08:26 <lunabot>  "(,,,,,,,,,,,,,,,,,,,,,)"
06:08:39 <nomeata> and thanks for the code
06:08:46 <Twey> , showName ''(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
06:08:49 <lunabot>  "GHC.Tuple.(,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,...
06:09:00 <Twey> These are hard-coded, aren't they?  How high does it go again?
06:09:02 <mmorrow> nomeata: no problem. good luck with the th :)
06:09:30 <mmorrow> Twey: it's only an issue when you try to make a /value/
06:09:44 <mmorrow> , src TupE
06:09:45 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
06:09:45 <lunabot>         against inferred type `[Language.Haskell.TH.Syntax.Exp]
06:09:45 <lunabot>                                -> Language.Haskell.TH.Syntax.Exp'
06:09:48 <mmorrow> , src 'TupE
06:09:53 <lunabot>  data Exp = ... | TupE ([Exp]) | ...
06:09:53 <lunabot>  infixl 9
06:10:16 <Twey> mmorrow: Oh aye?
06:11:03 <mmorrow> , foldl appT (tupleT 2048) (replicate 2048 [t|()|])
06:11:05 <lunabot>  AppT (AppT (AppT (AppT (AppT (AppT (AppT (AppT (AppT (AppT (AppT (AppT (A...
06:12:04 <mmorrow> , $(tupE (fmap lift (replicate 63 (0::Int))))
06:12:06 <lunabot>  luna: A 63-tuple is too large for GHC
06:12:06 <lunabot>    (max size is 62)
06:12:06 <lunabot>    Workaround: use nested tuples or define a data type
06:15:20 <BeelsebobWork> @hoogle (b,[a]) -> [(b,a)]
06:15:20 <lambdabot> No results found
06:15:40 <BeelsebobWork> @pl \x y -> zip (repeat x) y
06:15:40 <lambdabot> zip . repeat
06:15:45 <BeelsebobWork> >.<
06:15:45 <BeelsebobWork> duh
06:15:56 <mmorrow> heh
06:16:56 <mmorrow> @type uncurry (fmap . (,))
06:16:58 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
06:20:20 <ChrisKeating> can someone help me get lambdabot to join my channel, we had a channel key for a brief period of time and it won't join anymore.
06:21:50 * Axman6 pokes Cale 
06:30:44 <Axman6> someone needs tomake a haskell interface for this: http://au.youtube.com/watch?v=Aj3_v7xCyJ0
06:30:44 <lambdabot> Title: YouTube - 3D LED Cube
06:31:45 <hugo_> ah
06:31:51 <hugo_> i saw it on CCC
06:31:55 <hugo_> really nice stuff
06:35:44 <younder> soulsburry hill utube is a great song
06:36:18 <younder> a break from monads and functors?
06:39:15 <BeelsebobWork> argh!
06:39:16 <ddarius> The only thing that thing is useful for is making some bad sci-fi movie.
06:39:24 <BeelsebobWork> stupid bad type system!
06:40:47 <BeelsebobWork> @djinn (a, Set b) -> Set (a, b)
06:40:47 <lambdabot> Error: Undefined type Set
06:40:58 <BeelsebobWork> @djinn (a, Data.Set b) -> Data.Set (a, b)
06:40:58 <lambdabot> Error: Undefined type Data.Set
06:41:01 <BeelsebobWork> :(
06:41:25 <ddarius> :t uncurry Data.Set.insert
06:41:26 <int-e> @type curry (Data.Set.map ((,) ?a))
06:41:27 <lambdabot> forall a. (Ord a) => (a, S.Set a) -> S.Set a
06:41:28 <lambdabot>     Couldn't match expected type `(a, b)'
06:41:28 <lambdabot>            against inferred type `S.Set a1'
06:41:28 <lambdabot>       Expected type: (a, b) -> c
06:41:56 <BeelsebobWork> ddarius: not quite what's needed
06:41:57 <ddarius> :t uncurry (Data.Set.insert . (,) 'a')
06:41:57 <int-e> @type uncurry (Data.Set.map ((,) ?a))
06:41:59 <lambdabot> forall a. (Ord a) => (a, S.Set (Char, a)) -> S.Set (Char, a)
06:41:59 <lambdabot>     Couldn't match expected type `b -> c'
06:41:59 <lambdabot>            against inferred type `S.Set (a, a1)'
06:41:59 <lambdabot>     Probable cause: `S.map' is applied to too many arguments
06:42:05 <BeelsebobWork> oh, shiny
06:42:07 <BeelsebobWork> go ddarius
06:43:04 <ddarius> :t Data.Set.Map
06:43:06 <lambdabot> Not in scope: data constructor `Data.Set.Map'
06:43:09 <ddarius> :t Data.Set.map
06:43:10 <lambdabot> forall a b. (Ord b, Ord a) => (a -> b) -> S.Set a -> S.Set b
06:43:21 <int-e> :t uncurry (\a -> Data.Set.map ((,) a))
06:43:22 <lambdabot> forall a a1. (Ord a, Ord a1) => (a, S.Set a1) -> S.Set (a, a1)
06:43:42 <int-e> stupid, I was trying to uncurry an implicit argument.
06:46:22 <younder> Still don't se what was wrong with Church 'lambda calculus'. Why bring Hascell Curry into it?
06:47:47 <younder> I have  my  mathematician cap on..
06:48:10 <hugo_> it would be great to have a "haskell code refactor tool" :D
06:49:26 <younder> It's still all lambda calucus 'under the hood'
06:50:23 <maltem> younder: for starters, Church's lambda calculus is not typed
06:50:57 <maltem> which is a huge difference
06:51:04 <younder> agreed
06:52:05 <younder> But it can be inductivly inferred from lambda calculus, and in fact is
06:53:10 <daf> there's a diference between "I can derive something usable from it" and "it's usable" :)
06:55:31 <younder> is it or should the language be buildt on the 'atoms'
06:55:39 <younder> meta programmed so to speak
06:56:38 <younder> just wondering..
06:57:31 <daf> younder: I'm not sure what good that would do
07:01:08 <younder> Just read 'The art of meta object protocol' which lead me to belive that a more flexible language is possible
07:01:58 <daf> oh, I thought you were still talking about the STLC
07:02:33 <younder> The trick is the language is defined in the language and you merly need a boot protocol to kick it up
07:02:51 <younder> 'compile the compiler'
07:05:32 <younder> I should warn you that I like to 'design' languages...
07:06:28 <PeakerWork> younder: have you heard of subtext? (www.subtextual.org)
07:07:32 <younder> No. Thanks for pointing it out.
07:09:27 <nomeata> Hi. What’s again the module in haskell that allows for simple timing tests?
07:15:48 <PeakerWork> younder: I have been convinced by the Subtextual project that we should design programming environments, not "languages" :)
07:16:12 <PeakerWork> (take the language all the way to the UI, and not design a grammar as a UI.  A grammar is a poor UI)
07:17:14 <PeakerWork> More accurately: A text editor editing a grammar is a poor UI for programming
07:18:19 <PeakerWork> A purely functional language, specifically, can benefit a lot from a more sophisticated UI as there are so many UI aspects that can benefit from the lack of side effects and their ability to simply execute any portion of the code on demand
07:19:35 <hugo_> i like vim
07:19:44 <hugo_> i think it fits nicely with haskell programming
07:20:17 <BeelsebobWork> mwuhuhuhuhu
07:20:27 <BeelsebobWork> my graph based type unification algorithm is alive :D
07:20:44 * BeelsebobWork ponders if this is a new algorithm or if he's covering old ground
07:21:03 <PeakerWork> hugo_: a text editor necessarily wastes the vast majority of input space (most keyboard keys) on meaningless things.  A good (higher level) UI should map as many possible inputs to useful meaningful things.  Not invalid syntax, for example
07:21:34 <hugo_> PeakerWork: try vim :)
07:22:31 <PeakerWork> hugo_: I have. It sucks, just like all other text editors :)  The Subtext UI seems so much better, and it too seems to be very preliminary, and suck :)
07:23:05 <PeakerWork> hugo_: why do we edit a _serialization_ of a Haskell program and why does the editor let us write syntactically invalid programs? what's the point in that?
07:23:22 <hugo_> experience
07:23:28 <PeakerWork> hugo_: even something as trivial as renaming something, becomes a chore
07:23:40 <hugo_> regular expressions
07:23:48 <pflynn> I was building the Crypto-4.1.0 package with the 6.8.3 ghc linux binary dist under CentOS 5 when I got the following error:Linking dist/build/SymmetricTest/SymmetricTest ...
07:23:48 <pflynn> [1 of 4] Compiling Codec.Utils      ( Codec/Utils.hs, dist/build/SHA1Test/SHA1Test-tmp/Codec/Utils.o )
07:23:48 <pflynn> [2 of 4] Compiling Data.Digest.SHA1 ( Data/Digest/SHA1.hs, dist/build/SHA1Test/SHA1Test-tmp/Data/Digest/SHA1.o )
07:23:48 <pflynn> [3 of 4] Compiling Codec.Text.Raw   ( Codec/Text/Raw.hs, dist/build/SHA1Test/SHA1Test-tmp/Codec/Text/Raw.o )
07:23:51 <pflynn> [4 of 4] Compiling Main             ( ./SHA1Test.hs, dist/build/SHA1Test/SHA1Test-tmp/Main.o )
07:23:54 <pflynn> ghc-6.8.3: panic! (the 'impossible' happened)
07:23:57 <BeelsebobWork> @hoogle (a -> a) -> (a -> a)
07:23:57 <lambdabot> Data.Generics.Schemes everywhere :: (a -> a) -> a -> a
07:23:57 <lambdabot> Data.Generics.Schemes everywhere' :: (a -> a) -> a -> a
07:23:57 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
07:23:58 <pflynn>   (GHC version 6.8.3 for i386-unknown-linux):
07:24:01 <pflynn> 	RegAllocLinear.getStackSlotFor: out of stack slots, try -fregs-graph
07:24:04 <pflynn>  
07:24:07 <pflynn> Please report this as a GHC bug:  http://www.haskell.org/ghc/reportabug
07:24:08 <nomeata> :r
07:24:09 <Axman6> pflynn: use a pastebin!
07:24:10 <pflynn>  
07:24:11 <BeelsebobWork> hmm
07:24:12 <lambdabot> Title: ReportABug - GHC - Trac
07:24:16 <BeelsebobWork> @hoogle fix
07:24:17 <lambdabot> Data.Function fix :: (a -> a) -> a
07:24:17 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
07:24:17 <lambdabot> module Control.Monad.Fix
07:24:24 <nomeata> sorry, wrong window (and you all know what window I was about to type in)
07:24:37 <BeelsebobWork> is there a version of fix that computes the fixed point you get to by repeated application of the function to a starting value?
07:25:02 <BeelsebobWork> > let fix' f x
07:25:02 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
07:25:02 <lambdabot>  ...
07:25:03 <BeelsebobWork> bah
07:25:54 <BeelsebobWork> > let fix' f x | f x == x = x; | otherwise = fix' f (f x) in fix' (^2) 0
07:25:54 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 37}
07:25:54 <lambdabot> ...
07:25:58 <BeelsebobWork> :(
07:26:15 <kowey> nomeata: mere you looking for benchpress maybe?
07:26:27 <kowey> *were
07:27:35 <nomeata> kowey: hmm, no, I thought it was just a simple (IO () -> IO ()) function, with similar behaviour as unix’ time, and in the standard libs. But maybe I’m mistaken.
07:34:13 <BeelsebobWork> what would anyone here call the function of type Graph k a -> k -> Graph k a, which returns the subgraph that is reachable from the key?
07:36:21 <rog_> is there a shorthand form for (\x y -> x {foo = y})?
07:36:47 <BeelsebobWork> if I create records I typically create some boilerplate setters
07:36:48 <byorgey> BeelsebobWork: 'neighborhood', perhaps?
07:36:57 <BeelsebobWork> setFoo x y = x {foo = y}
07:37:11 <BeelsebobWork> byorgey: hmm, I guess that works
07:37:29 <byorgey> there are also various packages floating around which will derive those sorts of setters for you automatically, using Template Haskell
07:39:49 <nomeata> There are free monads for functors, and I need the functor whose free monad is equivalent to Either. Any idea how to construct this? (I’m new in this area...)
07:42:43 <rog_> byorgey: thanks. not quite what i was looking for, though...
07:42:48 <jpcooper> two threads need to communicate between each other with multiple types. Is there any way in which this can be done apart from explicit shared state and selected from multiple channels?
07:47:52 <BeelsebobWork> has anyone seen any papers on doing type unification by linking things in a graph structure?
07:48:10 <BeelsebobWork> linking types specifically
07:51:12 <quicksilver> jpcooper: yes. define a new type.
07:51:32 <quicksilver> jpcooper: data Message = OneOfThese This | OneOfThose That | SomethingElseEntirely Carrot
07:52:54 <hugo_> can i use a "where" inside a do ... ?
07:53:07 <hugo_> let seems to work, but where gives an error
07:53:18 <hugo_> like "The last statement in a 'do' construct must be an expression"
07:55:02 <leimy> hmm
07:56:14 <Saizan> nomeata: Either e a ~~ Free (Const e) a where Const e r = e, afaiu
07:56:22 <quicksilver> hugo_: no. you can't use where inside an expression.
07:56:35 <quicksilver> hugo_: 'do' is no exception, it's still an expression and you still can't use where.
07:56:41 <jpcooper> quicksilver, it just seems a bit redundant to define a new type whose constructors are the names of the types which they hold
07:56:42 <nomeata> Saizan: thx!
07:56:45 <quicksilver> 'where' attaches to 'definitions'
07:56:45 <hugo_> http://hpaste.org/10979
07:56:59 <hugo_> oh :/
07:57:02 <quicksilver> jpcooper: not really no; it's just a way of formalising a choice between a finite number of types.
07:57:03 <hugo_> because let works fine
07:57:04 <nomeata> (I actually needed "Either String", so it’s data Const r = Const String)
07:57:09 <jpcooper> quicksilver, okay
07:57:15 <hugo_> then there is a difference between where and let
07:57:17 <quicksilver> hugo_: indeed it does. 'let' is an expression former.
07:57:21 <hugo_> oh
07:57:24 <quicksilver> a syntactic difference, yes.
07:57:25 <hugo_> allright then :)
07:57:33 <quicksilver> let forms expressions, where attaches to declarations.
07:57:42 <quicksilver> 'let' also has a special short form for do blocks
07:57:45 <quicksilver> but that's by the byt.
07:57:59 <hugo_> hmm ok
07:58:08 <geezusfreeek> jpcooper, presumably there is some sort of relationship between the different types of values that can be sent over this channel, no? it would make sense for them to all belong to the same data type to me
07:58:23 <hugo_> nice to know these little differences :)
07:58:39 <jpcooper> geezusfreeek, yes, thanks
07:58:46 <hackage> Uploaded to hackage: utf8-prelude 0.1.2
07:59:17 <jpcooper> geezusfreeek, so you think that I shouldn't define any lower types?
07:59:36 <Saizan> nomeata: more like newtype Const r = Const String, if we want to be picky
07:59:39 <geezusfreeek> if it is useful to have them as separate types then you should do it
07:59:44 <jpcooper> okay
08:00:14 <geezusfreeek> it's all a matter of how much abstraction you want
08:00:16 <nomeata> Saizan: just for performance reasons? Or for theretical reasons?
08:00:25 <geezusfreeek> i prefer lots of abstraction, so i tend to make many many types
08:01:25 <Saizan> nomeata: theoretical if we care about bottoms, with using data you have Const _|_ /= _|_,
08:02:10 <quicksilver> geezusfreeek: well in particular, haskell forces us to choose a type if we want to use it as the contents of a Chan, say.
08:02:16 <quicksilver> geezusfreeek: but we should not be afraid of doing that :)
08:02:18 <Saizan> nomeata: so using data Free f a = Roll (f (Free f a)) | Return a
08:02:18 <nomeata> Saizan: ok, but then the sources that I read don’t take it exact. They have "data T a = T a a" as the functor for a tree structure, and that should have the same errors
08:03:21 <geezusfreeek> quicksilver, i thought he was asking me if he should just have all those smaller types defined as part of the bigger data type rather than composing many smaller custom types
08:03:37 <quicksilver> geezusfreeek: maybe he was. It's a good question :)
08:03:40 <Saizan> nomeata: yeah, it's the same difference
08:03:45 <quicksilver> q.v. Data Types a la Carte
08:04:24 <nomeata> ok, thx
08:07:00 <hugo_> learning haskell is a fun ride :)
08:07:48 <mc__> but a challenging one
08:08:01 <hugo_> yes :)
08:08:09 <geezusfreeek> and well worth it
08:08:15 <mc__> but thats probably what makes it fun :)
08:08:32 <mc__> s/fun/funny (?)
08:08:40 <geezusfreeek> haskell is nothing like what i thought it would be before i ever started learning it
08:09:42 <hugo_> its a ride where the concrete walls of the ruling programming mindset come shattering down
08:10:09 <mc__> yeah
08:10:13 <mc__> kinda philosophical
08:10:14 <hugo_> thats, at least, a mind blowing experience
08:10:27 <hugo_> for me :)
08:11:36 <jpcooper> wrt x = actionChan >>= flip writeChan x
08:11:41 <jpcooper> is there a nicer way to write that?
08:11:48 <geezusfreeek> @pl  wrt x = actionChan >>= flip writeChan x
08:11:48 <lambdabot> wrt = (actionChan >>=) . flip writeChan
08:12:00 <jpcooper> thanks
08:12:33 <geezusfreeek> the improvement is subjective though
08:12:49 <geezusfreeek> and most of the time for me the decision to go point free is situational
08:13:52 <hugo_> is there any way to do this: f x = do return NewType bla bla bla ?
08:13:55 <quicksilver> jpcooper: in my opinion, do v <- actionChan; writeChan v x
08:14:14 <quicksilver> jpcooper: I'm no big fan of flip ;)
08:14:18 <jpcooper> aah
08:14:21 <unenough> turing incompleteness rocks!
08:14:23 <jpcooper> I'm not really a fan of do :)
08:14:24 <geezusfreeek> i agree
08:14:24 <quicksilver> but it's subjective.
08:14:32 <quicksilver> hugo_: well you don't need the word 'do' there.
08:14:39 <hugo_> oh, nice
08:14:41 <geezusfreeek> dislike flip, that is
08:14:42 <quicksilver> f x = return (NewType bla bla blad)
08:14:49 <jpcooper> hugo_, return is a function like any other
08:14:58 <quicksilver> hugo_: 'do' is for magic plumbing connecting more than one staement
08:15:08 <hugo_> oh ok...
08:15:11 <quicksilver> a do block with only one expression is just an expression
08:15:15 <quicksilver> so "do a" is just "a"
08:15:25 <unenough> turing incompleteness (may) mean that you can get much further along in automatic analysis
08:15:37 <yitz> > do 42
08:15:38 <lambdabot>       No instance for (Num (t t1))
08:15:39 <hugo_> i thought that there were just two types of building a monad, the do-block, and the normal >>= way
08:15:39 <lambdabot>        arising from the literal `42' at <i...
08:15:45 <unenough> anybody know any references about this?
08:15:51 <quicksilver> hugo_: there are.
08:15:54 <quicksilver> hugo_: and the normal >>= way
08:16:03 <quicksilver> hugo_: degenerates, when there are no >>=s :P
08:16:18 <hugo_> hehe, yes :) nice to know
08:16:37 <quicksilver> "do {a;b}" is "a >> b", and "do {a}" is just "a"
08:16:57 <hugo_> yes
08:17:10 <quicksilver> > do [1,2,3]
08:17:12 <lambdabot>   [1,2,3]
08:17:15 <younder> I'd say lerning haskell is a rough ride, but a wort while one
08:17:15 <hugo_> i thought that a do block had to finish with a return, to "elevate" the monad status
08:17:22 <quicksilver> hugo_: nope.
08:17:25 <yitz> > do {42}
08:17:27 <lambdabot>       No instance for (Num (t t1))
08:17:27 <lambdabot>        arising from the literal `42' at <i...
08:17:35 <quicksilver> hugo_: do {putStr "hi"; putStr "there"}
08:17:38 <quicksilver> hugo_: no 'return' there.
08:18:03 <hugo_> indeed
08:18:04 <quicksilver> a do block consists of a series of expressons of type "m a" (perhaps for some fixed monad m)
08:18:09 <quicksilver> and bindings of type "m a"
08:18:12 <hugo_> and i have used it before, i guess my mind was not assimilating it...
08:18:13 <quicksilver> bindings using <-
08:18:27 <quicksilver> "return foo" is certainly one choice
08:18:29 <younder> Spoken from a guy that has been a Lisper for 10 years and a mathematician for 20 or so years
08:18:34 <quicksilver> that is guaranteed to have type "m a"
08:18:41 <quicksilver> but just "foo" is also a choice
08:18:45 <quicksilver> if foo is already of monadic type.
08:18:53 <younder> and a bad typist always... (sorry)
08:18:55 <quicksilver> as in, "putStr "hello""
08:19:02 <quicksilver> younder: ;)
08:19:21 <yitz> younder: the lisp part is what was tripping you up.
08:19:53 <quicksilver> all those nasty parens everywhere, it's like leaving a garden rake on the floor
08:19:58 <quicksilver> guaranteed to trip you up?
08:20:23 <yitz> quicksilver: hehe. I was referring to the imperitaveness.
08:20:48 <yitz> quicksilver: the parens are what affected his typing.
08:20:51 <hugo_> you can have lots of parenthesis in haskell too
08:20:56 <hugo_> thats whats neat about it :)
08:21:09 <younder> No I  lie the parens. Haskell counter intuetive lexical scope frequently leaves me cursing
08:21:14 <younder> like
08:21:30 <yitz> if lisp macros are so great, let's see them define $ and get rid of all the parens.
08:21:40 <younder> Liskell
08:21:51 <younder> a branch of GHC
08:21:54 <hugo_> haskell is constantly telling you "you could use the parenthesis like in LISP", and thats part of the fun :)
08:25:19 <younder> True. ((+) 1 2 3 4)
08:25:46 <yitz> > (sum 1 2 3 4)
08:25:47 <lambdabot>       No instance for (Num (t -> t1 -> t2 -> a))
08:25:47 <lambdabot>        arising from a use of...
08:26:05 <younder> exactly
08:26:20 <younder> lol
08:28:59 <geezusfreeek> > sum [1..4]
08:29:00 <lambdabot>   10
08:29:28 <younder> > sum [1..10]
08:29:29 <lambdabot>   55
08:29:32 <quicksilver> you could make (sum 1 2 3 4) work.
08:29:34 <younder> cool
08:29:36 <quicksilver> it wouldn't be very nice, though :)
08:29:44 <geezusfreeek> it would be an oleg
08:29:55 <quicksilver> nah, it would rate around 8 milliolegs
08:30:04 <hugo_> how can i pattern match against named fields in a IO DataType -> IO bla function ?
08:30:15 <quicksilver> hugo_: you pull it out of IO first, using <-
08:30:19 <hugo_> oh
08:30:20 <hugo_> nice
08:30:21 <quicksilver> hugo_: then you pattern match normally with case.
08:30:22 <hugo_> thanks
08:30:23 <hugo_> :)
08:30:34 <yitz> hugo_: or even right at the <-
08:30:47 <yitz> on the left, that is
08:30:53 <younder> can you pattern match actions?
08:31:01 <geezusfreeek> (a, b) <- pairReturningAction
08:31:06 <younder> (I've never tried)
08:31:21 <hugo_> sweet
08:31:28 <geezusfreeek> or pairReturningAction >>= \(a, b) ->
08:31:33 <liyang> younder: if you can see the internal representation of e.g. IO a, sure, why not?
08:31:33 <quicksilver> that onlyworks if there is only one option
08:31:52 <quicksilver> although it has the interesting behaviour of calling 'fail' if it doesn't match
08:31:55 <quicksilver> which can be useful
08:32:03 <younder> Ahh. You need to see the monadic definition
08:32:20 <geezusfreeek> ... it calls fail if it doesn't match?!
08:32:24 <quicksilver> > (\l -> do {Just c <- l; return c}) $ [Just 4, Nothing, Just 5]
08:32:26 <lambdabot>   [4,5]
08:32:43 <younder> makes sense
08:32:44 <quicksilver> geezusfreeek: yes. Occasionally useful in the list monad and similar.
08:32:49 <geezusfreeek> that seems almost... perlish
08:32:59 <liyang> fail is one of those things that, well, fails. hard.
08:33:00 <quicksilver> @src catMaybes
08:33:00 <lambdabot> catMaybes ls = [x | Just x <- ls]
08:33:20 <quicksilver> ^^ the same, but list comprehension syntax not monad syntax
08:33:26 <quicksilver> same thing, though.
08:34:01 <geezusfreeek> do Just x <- ls; return x
08:34:18 <geezusfreeek> :t fromJust
08:34:19 <lambdabot> forall a. Maybe a -> a
08:34:29 <geezusfreeek> ls >>= fromJust
08:35:21 <liyang> er, there you'd just get an error in fromJust.
08:35:23 <dino-> ls >>= return . fromJust  ?
08:35:54 <quicksilver> no, you can't extract this behaviour from fromJust
08:35:55 <dino-> Ya, in the case of Nothing, careful of the error
08:35:58 <quicksilver> fromJust calls error.
08:36:12 <geezusfreeek> oops, right ^_^
08:36:20 <geezusfreeek> have to do the pattern match in do
08:36:26 <geezusfreeek> see, that behavior has thrown me off already
08:36:39 <dino-> :t fromMaybe
08:36:41 <lambdabot> forall a. a -> Maybe a -> a
08:36:56 <dino-> Or have a default value ready, if it makes sense for your code.
08:37:03 * younder notes that Tyco Brahe died because he needed to go and couln't get to a tolet in time. Let's not make the same mistake
08:37:07 <geezusfreeek> fromMaybe fail ls
08:37:16 <geezusfreeek> dang, still wrong
08:37:24 <geezusfreeek> :t fail
08:37:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
08:37:36 <geezusfreeek> i hate fail
08:37:54 <younder> why the monad there?
08:38:16 <dfrey> I seem to remember reading that there was a really easy way to create a debian package from a cabal package.  Can anyone direct me to that information?
08:38:20 <geezusfreeek> younder, fail is (in my opinion, wrongly) a part of the monad type class
08:40:26 <younder> well all languages have their warts
08:47:46 <Saizan> dfrey: http://www.haskell.org/pipermail/haskell-cafe/2008-August/046272.html
08:47:47 <lambdabot> Title: [Haskell-cafe] PRE-ANNOUNCE: cabal-debian (automatically debianize cabal package ..., http://tinyurl.com/4uw8yq
08:48:18 <younder> (glasses rotally disrupt my social skills because I am -5 and my eyes would look the sixe of dots)
08:49:30 <mrd> fail fails
08:50:38 <PeakerWork> younder: laser?
08:50:43 <younder> but of cource it does
08:52:03 <younder> PeakerWork: contacts
08:54:46 <younder> mrd: could you be more spesific?
08:55:17 <quicksilver> younder: it fails because not all monads support it
08:55:24 <quicksilver> so it shouldn't be in the Monad class
08:55:32 <quicksilver> it should be, e.g., in MonadFail or MonadZero or something.
08:56:22 <younder> like mapM perhaps..
08:56:33 <younder> as opposed to map
08:57:02 <mrd> indeed, sometimes you use mzero like fail, except it's not an error
08:57:11 <mrd> MonadPlus + [] monad
08:58:08 <PeakerWork> younder: why not laser?
08:58:31 <quicksilver> mmm I love the smell of eyeballs cooking in the morning.
08:59:20 <younder> lol
08:59:35 <dino-> But mzero doesn't take an argument. For that type of thing I've been trying to use ErrorT where you pack the error info into the Left result of the Either
09:00:04 <dcoutts> @seen dancor
09:00:04 <lambdabot> dancor is in #haskell. I last heard dancor speak 3h 21m 54s ago.
09:00:37 <dancor> dcoutts: i'm getting a different error now: Package base is required by several packages, but they require inconsistent versions
09:00:58 <dancor> i've been trying to figure out a way (hacky or not) to get it be happy with both
09:01:15 <dcoutts> dancor: oh, that should have been fixed already
09:01:28 <dcoutts> dancor: what are you trying that produces that?
09:01:33 <younder> does haskel lhave something equivelent of shaddow?
09:01:53 <dcoutts> dancor: ah! you need the latest Cabal lib too
09:01:59 <dancor> oooh
09:02:00 <zachk> younder: what is shadow
09:02:13 <dcoutts> dancor: it changes the definition of inconsistent versions :-)
09:02:16 <quicksilver> dino-: yes, throwError instead of fail.
09:03:10 <younder> zachk: It is a lisp package term meaning the local defintion shaddows the global term
09:03:35 <dino-> younder: You can import something with 'hiding' to unimport part of it.
09:03:50 <zachk> i believe haskell has local free variable 'shadowing'
09:04:33 <dino-> Consider Data.Map.lookup, collides with Prelude.lookup. But you can import Prelude hiding ( lookup )
09:05:01 <dino-> in lieu of import qualified Data.Map as Map or whatever, with explicit Map.lookup usage in your code.
09:10:38 <hugo_> is there something in haskell like the perl mongers ?
09:11:08 <quicksilver> there is an informal london haskell user group
09:11:12 <hugo_> hmm
09:11:15 <quicksilver> and a couple of others (a bay area one?)
09:11:22 <hugo_> i will start a portuguese haskell group
09:11:38 <hugo_> and it would be great if it could be part of the "global" haskell community
09:11:43 <hugo_> like the perl mongers
09:12:05 <hugo_> i have been to a few meetings of portuguese perl mongers, their organization is exceptional :)
09:15:57 <younder> no doubt, personally I would like to extend my gratifications to the english one. Thanks for excellent support
09:27:07 <hugo_> is there any string tokenizer in haskell ?
09:28:49 <Vq^> hugo_: what should it do?
09:28:50 <quicksilver> words?
09:29:10 <quicksilver> parsec has a tokeniser, although I always write my own.
09:29:19 <Botje> @pl \x -> isChar x || isPunct x
09:29:19 <lambdabot> liftM2 (||) isChar isPunct
09:29:27 <hugo_> ill use parsec then
09:29:31 <hugo_> im using parsec
09:29:42 <hugo_> to parse the file
09:29:49 <Botje> @pl \x -> and (map ($x) [isChar, isPunct]
09:29:49 <lambdabot> (line 1, column 38):
09:29:50 <lambdabot> unexpected end of input
09:29:50 <lambdabot> expecting variable, "(", operator or ")"
09:29:54 <Botje> @pl \x -> and (map ($x) [isChar, isPunct])
09:29:54 <lambdabot> and . flip map [isChar, isPunct] . flip id
09:30:34 <geezusfreeek> i hate navigating the documentation for large OO libraries
09:30:48 <geezusfreeek> "is the functionality i want here? no. is it here? no. is it here? no"
09:30:54 <Vq^> hugo_: check out makeTokenParser
09:33:04 <hugo_> well, i just want to split the string "name.config" until the '.' char, and keep the "name" part...
09:33:11 <hugo_> i think parsec is kinda overkill for that :/
09:33:55 <mauke> > span ('.' /=) "name.config"
09:33:56 <lambdabot>   ("name",".config")
09:34:08 <mauke> > fmap (drop 1) . span ('.' /=) $ "name.config"
09:34:09 <lambdabot>   ("name","config")
09:34:25 <mauke> wait, do you even care about ".config"?
09:34:35 <mauke> otherwise it's just takeWhile ('.' /=)
09:34:42 <hugo_> i dont care
09:35:53 <hugo_> sweet
09:35:54 <hugo_> :D
09:35:55 <hugo_> thanks
09:47:56 <jelmer> What's the best conveniently available binary blob data type?
09:48:37 <Saizan> ByteString?
09:49:56 <jelmer> Saizan: Ok, so only in extensions?
09:50:03 <jelmer> *external modules
09:50:32 <lilac> jelmer: you could use Integer *ducks*
09:50:53 <mauke> depends on your definition of "external"
09:51:07 <lilac> jelmer: ByteString is in the Haskell Platform, so it's not really external
09:51:23 <mauke> heh, there's a Haskell Platform now?
09:51:26 <jelmer> Sorry - I didn't have Data.Binary installed on my Debian system yet
09:51:59 <jelmer> that's why I considered it external; I'll go with it though, seems like the easiest (and clearest) one to use
09:52:02 <jelmer> thanks!
09:52:17 <mauke> ByteString++
09:52:51 <lilac> mauke: it may not have had a release yet, but it definitely exists :)
09:54:05 <dancor> why does cabal install try to install hslogger-1.0.5 when i already have it installed
09:54:19 <dancor> it must have to do with version of base it is compiled with or some such
09:55:05 <mauke> maybe some of its dependencies have been updated in the meantime
09:56:03 <BeelsebobWork> does fix' f x = if f x == x then x else fix' f (f x) exist anywhere in the prelude under some name?
09:56:25 <Deewiant> ?src until
09:56:25 <lambdabot> until p f x | p x       = x
09:56:25 <lambdabot>             | otherwise = until p f (f x)
09:56:36 <Deewiant> fix' f x = until (==x) f x
09:56:48 <Saizan> Deewiant: that's not the same
09:56:51 <dolio> Nope.
09:56:55 <mauke> the first part is 'iterate'
09:57:03 <Deewiant> oh, darn
09:57:15 <Deewiant> fix' f x = until (==x) f (f x) -- ?
09:57:15 <BeelsebobWork> Deewiant: cool
09:57:17 <dolio> fix' f = until (ap (==) f) f
09:57:25 <Deewiant> ?pl fix' f x = until (==x) f (f x) -- ?
09:57:25 <lambdabot> fix' = ap =<< flip (until . (==))
09:57:28 <mauke> D*: fail
09:57:54 <mauke> actually, dolio's look's ok
09:58:00 <BeelsebobWork> no it doesn't
09:58:06 <BeelsebobWork> Deewiant's does
09:58:11 <mauke> really?
09:58:22 <Deewiant> ?pl \x -> until (==x) f (f x)
09:58:22 <lambdabot> ap (flip until f . (==)) f
09:58:24 <BeelsebobWork> dolio's is getting into the "you can make this more obfuscated by making it point free" territory
09:58:39 <mauke> except for the whole "working" part
09:58:44 <Saizan> Deewiant's always compares with the input element, it's incorrect
09:58:45 <dolio> Deewiant's uses the original x for every calculation.
09:58:53 <BeelsebobWork> oh, woops
09:58:59 <BeelsebobWork> so it does
09:59:05 <Deewiant> oh, right
09:59:10 <Deewiant> that's not what was wanted is it now
09:59:17 <Deewiant> so
09:59:24 <dolio> You could rewrite mine as "fix' f = until (\x -> f x == x) f'
09:59:37 <BeelsebobWork> which is ap
09:59:40 <Deewiant> fix' f x = dropWhile (uncurry (/=)) . (zip`ap`tail) $ iterate f x
09:59:43 <Deewiant> or something
09:59:43 <dolio> Right.
09:59:44 <Deewiant> maybe
10:00:10 <BeelsebobWork> okay, I think actually the recursive definition with guards is looking best atm
10:00:15 <mauke> :t fst . head . dropWhile (uncurry (/=) . ap zip tail . iterate ?f
10:00:17 <lambdabot> parse error (possibly incorrect indentation)
10:00:18 * dancor was able to cabal install hsh in ghc 6.10 with just a few hacks
10:00:20 <BeelsebobWork> from a pure code readability point of view
10:00:23 <mauke> :t fst . head . dropWhile (uncurry (/=)) . ap zip tail . iterate ?f
10:00:26 <lambdabot> forall a. (?f::a -> a, Eq a) => a -> a
10:00:51 <Deewiant> is that right?
10:01:00 <Deewiant> I think it is
10:01:04 <dolio> Looks like it.
10:01:15 <dolio> All it takes is building 2 intermediate lists. :)
10:01:26 <Deewiant> shush, the optimizer can deal with it
10:01:33 <BeelsebobWork> hehe
10:01:45 <mauke> @quote endangered
10:01:46 <lambdabot> No quotes match. Maybe you made a typo?
10:01:47 <newsham> http://www.thenewsh.com/~newsham/x/machine/monad.py
10:01:51 <mauke> @quote deforestation
10:01:52 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
10:01:56 <mauke> :-(
10:02:21 <BeelsebobWork> surely there must be something to do with trees needing deforestation
10:02:42 <mauke> preflex: quote mrd
10:02:42 <preflex>  <mrd> deforestation is killing millions of endangered cons cells
10:03:04 <Deewiant> :-/
10:03:08 <Deewiant> won't anyone think of the cons cells?
10:04:26 <ziman> every time you stream fuse, ghc kills a cons cell
10:05:34 <dons> ?users
10:05:35 <lambdabot> Maximum users seen in #haskell: 540, currently: 506 (93.7%), active: 20 (4.0%)
10:05:57 <mornfall> What's the "inverse" of \\ (a list operation)?
10:06:15 <mornfall> Err, wait.
10:06:18 <mornfall> I mean intersection.
10:06:47 <Deewiant> union?
10:07:12 <geezusfreeek> :t \\
10:07:14 <lambdabot> parse error on input `\\'
10:07:17 <geezusfreeek> :t (\\)
10:07:18 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
10:07:34 <mornfall> So intersect would work?
10:07:37 <geezusfreeek> duh, doesn't help since it's a set operation
10:07:58 <Deewiant> what do you want, exactly?
10:08:18 <mornfall> I don't know how \\ works, but I just want an intersection that works the same way.
10:08:29 <mornfall> (Ie. whether it's O(n^2) or it expects sorted lists, whatever...)
10:08:33 <Deewiant> > [1..5] `intersect` [3..7]
10:08:34 <lambdabot>   [3,4,5]
10:08:49 <geezusfreeek> i don't understand the question
10:08:54 <Deewiant> > [4,1,3,2,5] `intersect` [7,6,5,3,4]
10:08:55 <lambdabot>   [4,3,5]
10:09:04 <mornfall> So that's O(n^2)
10:09:09 <Deewiant> yeah
10:09:21 <mornfall> > [4,1,3,2,5] \\ [7,6,5,3,4]
10:09:23 <lambdabot>   [1,2]
10:09:25 <mornfall> Great.
10:09:28 <mornfall> Thanks. ; - )
10:09:36 <Deewiant> no problem :-P
10:24:05 <ddarius> 540 ! ?
10:25:17 <younder> >
10:26:28 <younder> n -> n-1 ^ n * fact n
10:26:43 <younder> obvious
10:27:08 <younder> ddarius: do you se it now?
10:28:10 <younder> just call fact n-1 and the function is naturally reductive
10:28:54 <jelmer> any c2hs hackers around?
10:29:11 <younder> ddarius: do you understand recursion?
10:29:46 <newsham> [07:25] < younder> ddarius: do you understand recursion?
10:29:49 <newsham> heehee
10:31:03 <Deewiant> preflex: seen ndm
10:31:04 <preflex>  ndm was last seen on #xmonad 40 days, 56 minutes and 50 seconds ago, saying: cool :)
10:33:08 <younder> yeah school boys would find a bi of abroblem following my example literaly ;)
10:33:32 <younder> which was the point
10:37:49 <romildo> Hi.
10:39:55 <leimy> > take 10 [1..]
10:39:57 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
10:40:59 <younder> let spam=[1..]hh
10:48:13 <younder> http://www.youtube.com/watch?v=BCyKcwvV5gE
10:48:13 <lambdabot> Title: YouTube - Billy Joel-Piano Man
11:09:05 <dancor> does anyone know where GHC.Session moves to in ghc 6.10
11:10:17 <Deewiant> dancor: what did it contain, I have ghc 6.10 here and can look
11:11:51 <dancor> Deewiant: it's referenced by hint (which mueval depends on, which lambdabot depends on)
11:12:18 <dancor> i have 6.10 and i'm looking.. hint does: dyn_fl <- GHC.getSessionDynFlags ghc_session
11:12:23 <dfrey|work> I am trying to make some sense of how regular expressions are supposed to work in Haskell.  I did "import Text.Regex" and started using mkRegex and matchRegex functions.  I then decided that I needed Perl compatible regular expressions for non-greedy matching.  I'm unclear how to specify which backend to use and even which backend I was using to begin with.
11:13:24 <dancor> looks like now it's: getSessionDynFlags :: GhcMonad m => m DynFlags
11:14:01 <dancor> takes no args now
11:26:51 <maltem> dfrey|work: I think Text.Regex is a compatibility module for regex-posix. If you want a different package, just import the appropriate modules below Text.Regex
11:39:05 <dfrey|work> How to I tell GHC where libpcre is located under windows?
11:43:02 <Deewiant> -L<path where the library lives> ?
11:43:14 <Deewiant> I generally just copy stuff to ghc\gcc-lib or whatever the dir is called
11:43:46 <sw17ch> @seen lispy
11:43:47 <lambdabot> lispy is in #haskell-blah, #haskell and #darcs. I last heard lispy speak 11h 22m 16s ago.
11:46:27 <jeffersonheard> is there a function in the standard lib with prototype (Bool -> a -> Maybe a) that returns Just x if y is true otherwise Nothing?
11:46:30 <younder> wll you didn't listen hard enough
11:47:34 <lilac> @hoogle Bool -> a -> Maybe a
11:47:35 <lambdabot> Control.Exception assert :: Bool -> a -> a
11:47:35 <lambdabot> Prelude asTypeOf :: a -> a -> a
11:47:35 <lambdabot> Control.Parallel.Strategies sforce :: NFData a => a -> b -> b
11:48:04 <lilac> jeffersonheard: sadly not, no.
11:48:35 <rwbarton> \x y -> guard x >> return y
11:48:37 <sw17ch> > (\x -> if x then Just a else Nothing) True 5
11:48:39 <lambdabot>   Couldn't match expected type `t1 -> t'
11:49:02 <sw17ch> > (\x -> if x then (Just a) else Nothing) True 5
11:49:03 <lambdabot>   Couldn't match expected type `t1 -> t'
11:49:16 <sw17ch> > (\x -> if (x == True) then (Just a) else Nothing) True 5
11:49:18 <lambdabot>   Couldn't match expected type `t1 -> t'
11:49:21 <sw17ch> what am i doing wrong?
11:49:33 <rwbarton> \x a -> ...
11:49:39 <sw17ch> oh, duh
11:49:53 <sw17ch> > (\x a -> if x then Just a else Nothing) True 5
11:49:54 <lambdabot>   Just 5
11:49:58 <sw17ch> > (\x a -> if x then Just a else Nothing) False 102
11:49:59 <lilac> @pl \b a -> guard b >> return a
11:49:59 <lambdabot> (. return) . (>>) . guard
11:50:00 <lambdabot>   Nothing
11:50:09 <rwbarton> > guard True >> return 5 :: Maybe Integer
11:50:11 <lambdabot>   Just 5
11:50:14 <rwbarton> > guard False >> return 5 :: Maybe Integer
11:50:14 <jeffersonheard> I wrote the function just now, but it seems silly to create a library for it.  I'm currently mostly through writing Control.Monad.IfElse,
11:50:15 <lambdabot>   Nothing
11:50:39 <rwbarton> :t guard
11:50:40 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
11:50:43 <jeffersonheard> which handles monadic cases quite well, including anaphoric variants
11:50:53 <lilac> jeffersonheard: i'm quite fond of (<?>) :: MonadPlus => Bool -> a -> Maybe a, (<:>) :: Maybe a -> a -> a
11:51:22 <rwbarton> oh dear :)
11:51:27 <lilac> rather, (<?>) :: MonadPlus m => Bool -> a -> m a
11:52:21 <rwbarton> I like how the name <:> makes no sense on its own
11:52:31 <lilac> rwbarton: it's fine if you read it as 'else'
11:52:47 <lilac> rwbarton: the name (>>=) makes no sense unless you know what it means
11:52:50 <jeffersonheard> lilac, an example to make that a little clearer?
11:52:58 <jeffersonheard> just like a one-liner?
11:53:21 <jeffersonheard> of using <?> and <:> in conjunction...
11:53:26 <rwbarton> lilac: Sure, but I assume <:> was chosen specifically to be able to write  cond <?> val1 <:> val2
11:53:36 <younder> http://www.youtube.com/watch?v=iJj1JPZLJto&feature=related
11:53:37 <lambdabot> Title: YouTube - Elton John - Someone saved my life tonight - Live in Ephesus
11:53:43 <lilac> > let True <?> a = return a; False <?> a = mzero; (Just a) <:> _ = a; Nothing <:> a = a in          True <?> 42 <:> 76
11:53:44 <lambdabot>   42
11:53:53 <lilac> rwbarton: right you are :D
11:54:47 <lilac> @let True <?> a = return a; False <?> a = mzero; (Just a) <:> _ = a; Nothing <:> a = a
11:54:50 <lambdabot>  Defined.
11:55:30 <lilac> > lookup "foo" [("foo", 1), ("bar", 2)] <:> (-1)
11:55:31 <lambdabot>   1
11:55:34 <lilac> > lookup "baz" [("foo", 1), ("bar", 2)] <:> (-1)
11:55:35 <lambdabot>   -1
11:56:01 <newsham> lilac: nice
11:56:40 <jeffersonheard> thanks, lilac.
11:57:11 <newsham> > Nothing <:> (Nothing <:> "test")
11:57:13 <lambdabot>   "test"
11:57:53 <newsham> thats getFirst monoid
11:58:46 <hackage> Uploaded to hackage: utf8-prelude 0.1.3
11:59:23 <newsham> > First Nothing `mappend` First Nothing `mappend` First (Just "test")
11:59:24 <lambdabot>   First {getFirst = Just "test"}
12:02:18 <lilac> not quite; it statically forces the result to be 'a' not 'Maybe a'
12:03:12 <newsham> m <:> a = maybe a id m
12:03:48 <Deewiant> <:> = flip fromMaybe?
12:04:01 <newsham> ?src fromMaybe
12:04:01 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
12:04:11 <newsham> ?src maybe
12:04:11 <lambdabot> maybe n _ Nothing  = n
12:04:11 <lambdabot> maybe _ f (Just x) = f x
12:04:25 <Deewiant> ?ty \m a -> maybe a id m
12:04:26 <newsham> seems like it
12:04:26 <lambdabot> forall a. Maybe a -> a -> a
12:04:28 <Deewiant> ?ty flip fromMaybe
12:04:29 <lambdabot> forall a. Maybe a -> a -> a
12:04:43 <gbacon> @botsnack
12:04:44 <lambdabot> :)
12:04:45 <rwbarton> I think I'd prefer fromMaybe usually, it keeps the information flowing from right to left
12:05:03 <newsham> yup,  i'm just used to using "maybe".  i should use "fromMaybe" more often
12:06:37 * lilac is a weirdo, but that's ok
12:06:58 <newsham> who wants to associate with norms?
12:06:59 <lilac> i use bind2nd = flip, and withDefault = fromMaybe
12:07:56 <lilac> although withDefault is confusing because it means completely the wrong thing when used infix :(
12:08:31 <newsham> thats why they call it in"fix"
12:08:33 <Deewiant> asDefault?
12:08:36 <newsham> if it wasnt broken they wouldnt have to call it that
12:08:42 <jeffersonheard> :t <?>
12:08:43 <lambdabot> parse error on input `<?>'
12:08:49 <jeffersonheard> :t (<?>)
12:08:50 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => Bool -> a -> m a
12:08:57 <jeffersonheard> :t (<:>)
12:08:58 <lambdabot> forall t. Maybe t -> t -> t
12:09:19 <luqui> ?index (<?>)
12:09:19 <lambdabot> Text.ParserCombinators.Parsec.Prim, Text.ParserCombinators.Parsec
12:09:31 <dancor> > True <?> 4 <:> 5
12:09:33 <lambdabot>   4
12:09:37 <dancor> > False <?> 4 <:> 5
12:09:38 <lambdabot>   5
12:10:29 <newsham> ?type if'
12:10:32 <lambdabot> Not in scope: `if''
12:10:55 <lilac> > 1 `mappend` 3 :: Int
12:10:57 <lambdabot>       No instance for (Monoid Int)
12:10:57 <lambdabot>        arising from a use of `mappend' at ...
12:11:14 <newsham> ?let if' b t e = if b then t else e
12:11:17 <lambdabot>  Defined.
12:11:18 <lilac> why is there no instance for Monoid Int?
12:11:28 <newsham> > (if' True 4 5, if' False 4 5)
12:11:29 <lambdabot>   (4,5)
12:11:35 <Deewiant> because there are two possible monoids
12:11:38 <Deewiant> and newtypes for both exist
12:11:48 <newsham> > Sum 3 `mappend` Sum 5
12:11:50 <lambdabot>   Sum {getSum = 8}
12:12:07 <lilac> Deewiant: more than two, but I'd say Sum is canonical
12:12:27 <Deewiant> shrug
12:12:28 <Deewiant> ?ty Sum
12:12:29 <lambdabot> forall a. a -> Sum a
12:12:38 <Deewiant> ?instances Monoid
12:12:39 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
12:12:39 <newsham> > getSum . map Sum $ [1..10]
12:12:41 <lambdabot>   Couldn't match expected type `Sum a'
12:12:41 <ziman> hm.
12:12:50 <Deewiant> > Sum 0.5 `mappend` Sum 0.5
12:12:51 <lambdabot>   Sum {getSum = 1.0}
12:12:53 <newsham> > getSum . mconcat . map Sum $ [1..10]
12:12:54 <lambdabot>   55
12:12:55 <ziman> > Sum id `mappend` Sum id
12:12:56 <lambdabot>       No instance for (Num (a -> a))
12:12:57 <lambdabot>        arising from a use of `mappend' a...
12:13:07 <luqui> LT `mappend` GT
12:13:10 <luqui> > LT `mappend` GT
12:13:11 <lambdabot>   LT
12:13:15 <lilac> there's an instance for Applicative [] with no newtype, isn't there?
12:13:16 <luqui> that's awesome
12:13:57 <geezusfreeek> > [(+1), (+2)] <*> [5,7]
12:13:59 <lambdabot>   [6,8,7,9]
12:14:02 <bd_> > [ (a,b,a `mappend` c) | a <- [minBound..maxBound]; b <- [minBound :: Ordering, maxBound ] ]
12:14:02 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 57}
12:14:02 <lambdabot> ...
12:14:38 <luqui> lilac, that's because Applicative is a superclass of Monad, so we instantiate to pretend we can make superclasses.
12:15:00 <newsham> there are Monad's which dont have Applicative instances
12:15:12 <Cale> However, this is inexcusable.
12:15:19 <lilac> luqui: true, but the paper which introduced Applicative used a different instance for [], which doesn't extend to a monad :)
12:15:30 <luqui> lilac, what you mean the zipper?
12:15:35 <lilac> luqui: yep
12:15:38 <newsham> lilac: ZipList?
12:15:39 <geezusfreeek> > ZipList [(+1), (+2)] <*> ZipList [5,7]
12:15:40 <lambdabot>       No instance for (Show (ZipList a))
12:15:40 <lambdabot>        arising from a use of `show' ...
12:15:40 <luqui> that extends to monad just fine
12:15:48 <luqui> well, not fine.  quite inefficiently.
12:15:50 <geezusfreeek> @src ZipList
12:15:50 <newsham> hate that Show ZipList error
12:15:50 <lambdabot> Source not found. stty: unknown mode: doofus
12:15:54 <geezusfreeek> poop
12:16:01 <Cale> That one does not extend to a monad.
12:16:01 <rwbarton> , src ''ZipList
12:16:02 <newsham> > getZipList $ ZipList [(+1), (+2)] <*> ZipList [5,7]
12:16:03 <lambdabot>   [6,9]
12:16:03 <lunabot>  luna: Not in scope: type constructor or class `ZipList'
12:16:07 <Cale> (ZipList is not a monad)
12:16:13 <geezusfreeek> oh, getZipList, that i s what i was looking for
12:16:21 <newsham> cale: thats what lilac said
12:16:41 <newsham> oh, blah, nevermind
12:16:41 <luqui> Cale, no?  return = repeat ; join = diag
12:16:46 <newsham> i ccant reading comprehension
12:16:53 <geezusfreeek> i was just making it clear that there was a newtype for ZipList
12:17:40 <Cale> Hmm, is that associative?
12:17:59 <lilac> luqui: do you use fmap = map?
12:18:07 <luqui> lilac, that's the only valid fmap
12:18:29 <luqui> Cale, it certainly is for infinite lists (it's the same as monad on (Int ->))
12:18:36 <luqui> I'm not sure about finite ones
12:19:23 <Cale> Yeah, I seem to remember there being some problem with the finite ones. Maybe I'm mistaken.
12:19:29 <rwbarton> I think it's not
12:20:23 <rwbarton> @let diag [] = []; diag []:_ = []; diag (x:xs):xss = x : diag (map tail xss)
12:20:23 <lambdabot>   Parse error in pattern: HsVar (UnQual (HsIdent "diag"))
12:20:38 <rwbarton> @let diag [] = []; diag ([]:_) = []; diag ((x:xs):xss) = x : diag (map tail xss)
12:20:40 <lambdabot>  Defined.
12:20:50 <rwbarton> > diag [[1,2,3],[4],[5,6,7]]
12:20:52 <lambdabot>   [1]
12:21:16 <Cale> Right...
12:21:26 <Cale> It's not such a nice operation on finite lists.
12:21:28 <Cale> hmm
12:21:38 <dolio> @check \l -> diag (diag l) == diag (map diag (l :: [[[Int]]]))
12:21:39 <lambdabot>   Not in scope: `diag'Not in scope: `diag'Not in scope: `diag'Not in scope: `...
12:22:15 <rwbarton> @check let diag [] = []; diag ([]:_) = []; diag ((x:xs):xss) = x : diag (map tail xss) in \l -> diag (diag l) == diag (map diag (l :: [[[Int]]]))
12:22:16 <lambdabot>   "* Exception: Prelude.tail: empty list
12:22:24 <rwbarton> oops
12:22:29 <rwbarton> @check let diag [] = []; diag ([]:_) = []; diag ((x:xs):xss) = x : diag (map (drop 1) xss) in \l -> diag (diag l) == diag (map diag (l :: [[[Int]]]))
12:22:30 <lambdabot>   "Falsifiable, after 13 tests:\n[[[-4,0,2,-6],[-3,4,-5,1]],[[],[2,0,-4]],[[1...
12:22:41 <vixey> > map head (zipWith ($) ((iterate (tail .)) id) ["abc","xyz","uvw"])
12:22:43 <lambdabot>   "ayw"
12:22:44 <rwbarton> @undefine diag
12:23:29 <luqui> I guess not.  :-)
12:23:35 <centrinia> > diag $ zipWith replicate [1..] $ "Hello World!"
12:23:35 <lambdabot>   Not in scope: `diag'
12:23:37 <centrinia> Darn. :(
12:23:48 <rwbarton> @let diag [] = []; diag ([]:_) = []; diag ((x:xs):xss) = x : diag (map (drop 1) xss)
12:23:49 <lambdabot>  Defined.
12:24:23 <dolio> > let bind f m = diag (map f m) in [1,2,3] `bind` repeat
12:24:24 <lambdabot>   Couldn't match expected type `a -> [a1]'
12:24:31 <centrinia> > diag $ zipWith replicate [1..] $ "Hello World!"
12:24:32 <lambdabot>   "Hello World!"
12:24:39 <dolio> > let bind m f = diag (map f m) in [1,2,3] `bind` repeat
12:24:40 <lambdabot>   [1,2,3]
12:24:42 <centrinia> Cool. :)
12:25:31 <rwbarton> > let (>>=) m f = diag (map f m) ; return = repeat in do { x <- [1,2,3]; return x }
12:25:32 <lambdabot>   [1,2,3]
12:25:38 <rwbarton> Hmm, I can't tell whether that worked :P
12:25:45 <dolio> Nope.
12:25:57 <luqui> > let (>>=) m f = diag (map f m) ; return = repeat in do { x <- [1,2,3]; y <- [4,5,6]; return (x,y) }
12:25:58 <rwbarton> > let (>>=) m f = diag (map f m) ; return = repeat in do { x <- [1,2,3]; y <- [4,5,6]; return (x,y) }
12:25:59 <lambdabot>   [(1,4),(2,5),(3,6)]
12:25:59 <lambdabot>   [(1,4),(2,5),(3,6)]
12:26:03 <luqui> echo
12:26:15 <vixey> heh
12:26:20 <dolio> Hmm.
12:26:33 <vixey> > let (>>=) m f = diag (map f m) ; return = repeat in  [1,2,3] >> \x -> [4,5,6] >>= \y -> return (x,y)
12:26:34 <lambdabot>       The lambda expression `\ x -> ... >>= ...' has one argument,
12:26:34 <lambdabot>      but i...
12:26:35 <luqui> so.... wait... *yes* it did work
12:26:39 <dolio> That's surprising.
12:26:44 <vixey> > let (>>=) m f = diag (map f m) ; return = repeat in  [1,2,3] >>= \x -> [4,5,6] >>= \y -> return (x,y)
12:26:46 <lambdabot>   [(1,4),(2,5),(3,6)]
12:26:55 * luqui is surprised (and elated) as well
12:27:15 <vixey> > let (>>=) m f = undefined ; return = undefined in do x <- "abc" ; return "this doesn't replace bind and return"
12:27:16 <lambdabot>   * Exception: Prelude.undefined
12:27:22 <dolio> I thought you needed NoImplicitPrelude tricks for that.
12:27:24 <vixey> oh
12:27:50 <Cale> Simple example of failure: [[[0]],[[],[0,0]]]
12:27:57 <dolio> > let (>>=) m f = error "bind" ; return = error "return" in do x <- "abc" ; return "this doesn't replace bind and return"
12:27:58 <lambdabot>   * Exception: bind
12:28:05 <luqui> dolio, I think it has noimplicitprelude
12:28:12 <luqui> by it I mean lambdabot
12:28:19 <dolio> Oh, could be.
12:28:26 <rwbarton> Works in plain old ghci too
12:28:28 <Cale> > let diag [] = []; diag ([]:_) = []; diag ((x:xs):xss) = x : diag (map (drop 1) xss) in diag (diag [[[0]],[[],[0,0]]])
12:28:29 <lambdabot>   [0,0]
12:28:33 <Cale> > let diag [] = []; diag ([]:_) = []; diag ((x:xs):xss) = x : diag (map (drop 1) xss) in diag (map diag [[[0]],[[],[0,0]]])
12:28:34 <lambdabot>   [0]
12:28:43 <luqui> rwbarton, by "works" what do you mean?
12:28:50 <rwbarton> Prelude> let (>>=) m f = error "bind" ; return = error "return" in do x <- "abc" ; return "this doesn't replace bind and return"
12:28:53 <rwbarton> *** Exception: return
12:29:04 <rwbarton> oh
12:29:07 <rwbarton> sneaky
12:29:08 <vixey> > let x>>=y = show x ++ ">>=" ++ show y ; return = ("return"++) in do x <- [1,2,3] ; return (x,x)
12:29:09 <lambdabot>   Couldn't match expected type `[Char]'
12:29:12 <rwbarton> I guess it doesn't work then
12:29:23 <luqui> of course it replaces return!
12:29:27 <dolio> It obviously will work with return, since you call that directly.
12:29:33 <rwbarton> Yeah, that's a bad test case.
12:29:36 <ziman> > diag [[[0,1],[2,3]],[[4,5],[6,7]]]
12:29:37 <lambdabot>   [[0,1],[6,7]]
12:29:43 <rwbarton> OK, it doesn't replace bind.
12:30:07 <dolio> It does in lambdabot, though, for whatever flags she's running.
12:30:13 <rwbarton> Right
12:30:29 <Cale> The new quickcheck is good.
12:30:37 <luqui> > (diag.diag) [[[0,1],[2,3]],[[4,5],[6,7]]]
12:30:38 <lambdabot>   [0,7]
12:30:48 <luqui> Cale, what is good about it?
12:30:58 <Cale> luqui: It reduces counterexamples.
12:31:13 <Cale> Until it can't seem to make them any simpler.
12:31:17 <luqui> you mean it tries to find small ones?
12:31:19 <luqui> ah cool
12:31:20 <Cale> yeah
12:31:27 <mmorrow> @type diag
12:31:28 <lambdabot> forall a. [[a]] -> [a]
12:31:32 <vixey> > let x>>=y = [show x ++ ">>=" ++ show (y ())] ; return x = ["return"++show x] in do x <- [1,2,3] ; return (x,x)
12:31:33 <lambdabot>   ["return(1,1)","return(2,2)","return(3,3)"]
12:31:33 <mmorrow> > L.diag
12:31:33 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
12:31:35 <Deewiant> the old one didn't? O_o
12:31:45 <Cale> Deewiant: No, it just finds random ones.
12:32:16 <Deewiant> guess I'm confusing it with smallcheck
12:32:26 * Cale tries installing the new quickcheck on lispy's machine
12:32:43 <Cale> > quickCheck $ let diag [] = []; diag ([]:_) = []; diag ((x:xs):xss) = x : diag (map (drop 1) xss) in \l -> diag (diag l) == diag (map diag (l :: [[[Int]]]))
12:32:46 <lambdabot>   * Exception: "<IO ()>"
12:32:50 <Cale> oh, right :P
12:32:54 <Cale> @check let diag [] = []; diag ([]:_) = []; diag ((x:xs):xss) = x : diag (map (drop 1) xss) in \l -> diag (diag l) == diag (map diag (l :: [[[Int]]]))
12:32:56 <lambdabot>   "Falsifiable, after 17 tests:\n[[[-1,-1,-4,1],[-2,0,2]],[[],[3,0,1,-3]],[]]...
12:32:58 <Cale> hmm
12:33:08 <Cale> So, that's not using the new QC yet...
12:33:33 <mmorrow> > diag [[0..],[0..]]
12:33:34 <lambdabot>   [0,1]
12:33:39 <dons> ?users
12:33:40 <lambdabot> Maximum users seen in #haskell: 540, currently: 531 (98.3%), active: 20 (3.8%)
12:33:41 <mmorrow> ohh
12:34:00 <mmorrow> > diag (replicate 4 [0..3])
12:34:01 <lambdabot>   [0,1,2,3]
12:34:19 <mml`> it would be nice if lambdabot would tell you when the record was set
12:34:19 <mmorrow> > diag (repeat [0..])
12:34:21 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
12:38:08 <vixey> we should be able to reprogram lambdabot over IRC
12:39:02 <mml`> oh, aye
12:40:31 <mmorrow> heh, that'd be sweet. i want to add an `eval' to lunabot s.t. if eval invokes itself that subinvocation can modify its caller's environment. so then javascript-eval-type debauchery would be possible.
12:41:07 <mml`> trying to find intellectually interesting work through craigslist, careerbuilder, etc. seems insane.
12:41:17 <mml`> at least if i am not in sfba or boston/cambridge
12:48:16 <rwbarton> Where did "Functional code is functional" come from?  (in the /topic)
12:48:47 <Deewiant> set by  dons (n=dons@archlinux/developer/dons) [06.10.2008 20:27:40]
12:49:05 <rwbarton> http://mine.icanhascheezburger.com/view.aspx?ciid=2216121
12:49:17 <lambdabot> Title: funkshunal code iz funkshunal by rwbarton
12:49:23 <Deewiant> :-)
12:49:32 <Deewiant> lacks a timestamp
12:50:05 <rwbarton> timestamp?
12:50:12 <Deewiant> that pic
12:50:27 <Deewiant> how old is it
12:50:35 <rwbarton> Oh, I made it just now
12:52:25 <Cale> Grumble... this is braindead. How can QuickCheck not provide any real way to get hold of its output instead of printing it to the screen?
12:53:06 <Cale> (or reimplementing half of QuickCheck)
12:57:16 <jeffersonheard> what's the point of the monomorphism restriction being applied to liftM2 (&&)?
12:57:48 <Cale> jeffersonheard: It's only applied if you pattern bind a variable to that.
12:58:15 <Cale> something like   andM = liftM2 (&&)
12:58:37 <geezusfreeek> Cale, i have been frustrated with quickcheck for that reason at one time also
12:58:49 <jeffersonheard> I thought so too, but I defined (&&^) = liftM2 (&&) and I got told by the compiler to add -fno-monomorphism-restriction
12:59:00 <Cale> jeffersonheard: yes, that's the same
12:59:06 <jeffersonheard> k
12:59:14 <vixey> -XNoMonomorphismRestriction
12:59:41 <Cale> jeffersonheard: You can either {-# LANGUAGE NoMonomorphismRestriction #-}, or just apply an explicit type signature.
12:59:56 <Cale> Or add some parameters there.
13:00:20 <Cale> x &&^ y = liftM2 (&&) x y
13:00:48 <jeffersonheard> oh right.  I didn't think of the latter.  that would work, wouldn't it...
13:00:48 <mmorrow> omg, i was trying to find this bug caused by saying  where fi = fromIntegral from about 30 minutes yesterday, and was tearing my hair out. it was the monomorphism restriction (there was a lot of other code noise around, so it wasn't clear to me that fi was the culprit).
13:00:56 <mmorrow> s/from/for/
13:01:06 <Deewiant> just always put a type signature and you'll be fine :-P
13:01:07 <Cale> jeffersonheard: It would, because it's a function binding, rather than a pattern binding.
13:01:13 <vixey> :(
13:01:19 <vixey> turn it off mmorrow!
13:01:23 <vixey> permenantly
13:01:27 <Cale> The MR is one of the absolute dumbest things in the Haskell Report.
13:03:29 <Cale> It has a tendency of making programs which look correct fail to typecheck in subtle ways that are hard to figure out.
13:03:57 <dfrey|work> Cale: What is "MR"?
13:04:03 <Cale> Monomorphism restriction
13:04:03 <rwbarton> Cale: What are you talking about, having liftM2 (&&) bound at a monomorphic type might save you a few expensive dictionary unpackings :)
13:04:06 <mmorrow> after that, i'm turning if off by default in all my code now
13:04:42 <Deewiant> make your code -Wall clean and you'll never have to worry about the MR
13:04:43 <Cale> dfrey|work: It says that whenever you have a pattern-bound variable (something which looks like you're defining a constant), it's not allowed to be polymorphic.
13:06:13 <Cale> This is so that things which look like constants won't end up being evaluated multiple times.
13:06:56 <mmorrow> Deewiant: hmm, the case i had doesn't do anything that's considered a warning.
13:07:07 <Cale> Oh, I should mention, adding an explicit type signature will force it to accept the definition.
13:07:20 <Deewiant> mmorrow: -Wall should complain about the lack of a type signature
13:07:31 <Deewiant> or does the MR apply in 'where' and 'let' bindings as well?
13:07:34 <ac> mmorrow: you should put it on the MR wiki page
13:07:36 <Cale> The MR should only be a warning.
13:07:41 <mmorrow> the function is nested 2 levels deep in wheres
13:07:41 <Cale> Deewiant: yes, it does.
13:07:47 <Deewiant> ah, crap
13:08:03 <Deewiant> never mind then :-/
13:08:28 <Deewiant> I was under the impression that it only applies at the top level
13:08:51 <Cale> Back before we had forM in the libraries, I once wrote  forM = flip mapM  without thinking too hard about it, and proceeded to use it in a fairly complicated ST-monad-using program.
13:09:14 <dancor> how do you interleave events in reactive-0.8.1: http://hpaste.org/10982
13:09:35 <Cale> The error that resulted was that my computation ended up being in the ST () monad (which means I couldn't apply runST)
13:09:59 <vixey> :t forM
13:09:59 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
13:10:01 <vixey> :t flip mapM
13:10:02 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
13:10:15 <Saizan> eek, runST gives weird errors by itself if you don't know the details
13:10:18 <vixey> what was the problem with it Cale?
13:10:30 <vixey> oh caused by monomorphism?
13:10:33 <Deewiant> :t runST
13:10:34 <lambdabot> forall a. (forall s. ST s a) -> a
13:10:35 <Saizan> yeah
13:10:44 <Cale> I had to tear the whole thing apart before I realised that the monomorphism restriction was applying to my definition of forM, which meant that it was being coerced into  [a] -> (a -> ST () b) -> ST () [b]
13:10:46 <Cale> which is useless.
13:11:30 <centrinia> Does it make sense to add two algebraic data types like so? data EitherMaybe a = (Maybe a) + (Either a b) := Nothing | Just a | Left a | Right b
13:11:47 <Saizan> how did it pick ()? defaulting?
13:11:50 <centrinia> s/EitherMaybe a =/EitherMaybe a b =/
13:11:51 <newsham> ?tick ^gspc
13:11:52 <lambdabot> ^GSPC: 996.23 -60.66 (-5.74%) @ 10/7/2008 4:11pm
13:11:54 <Cale> centrinia: Well... you can't call the constructors that...
13:12:04 <Cale> Saizan: apparently, yeah
13:12:26 <Cale> centrinia: at least, so long as Maybe and Either are in scope.
13:12:38 <vixey> centrinia: Either (Maybe a) (Either a b)
13:13:16 <Cale> Yeah, what vixey said :)
13:13:24 <centrinia> Yeah. :)
13:13:50 <centrinia> However, I was wondering if my semantics make sense.
13:13:59 <vixey> centrinia: no not really
13:14:05 <centrinia> Why not?
13:14:21 <Cale> centrinia: In a fairly technical and subtle way, there's a difference between your type and Either (Maybe a) (Either a b)
13:14:25 <vixey> centrinia: You want to extend the typechecking relation so that terms in Maybe a and terms in Either a b are equivalent..?
13:14:42 <centrinia> Yes.
13:14:55 <vixey> centrinia: this is asking for trouble, like passing an Either into a function that takes a Maybe and doesn't know about these new rules
13:15:21 <Cale> The difference is that in the latter type, you have: _|_, Left _|_, Right _|_, Left (Just _|_), Right (Left _|_), Right (Right _|_)
13:15:25 <rwbarton> centrinia: Also, what if it was data EitherEither a b = (Either a b) + (Either a b) := ???
13:15:50 <Cale> and your original formulation of the sum doesn't have quite as many partially-defined terms
13:15:50 <centrinia> Oh.
13:16:19 <Cale> It only has  _|_, Just _|_, Left _|_, Right _|_
13:16:19 <centrinia> EitherEither a b := Either a b; perhaps?
13:16:42 <Cale> So the two types are not *quite* isomorphic.
13:16:53 <rwbarton> It doesn't really make sense to just start forming unions of types all over the place.
13:17:42 <rwbarton> It does make sense to form sums of types, using Either.  But the types you're adding aren't "subtypes" of the sum: you have to use the functions Left and Right to product elements of the sum type.
13:17:47 <Cale> centrinia: Either (Either a b) (Either a b) is similar in nature to (Either a b, Bool)
13:17:56 <rwbarton> (In fact there isn't really a notion of "subtype" in Haskell)
13:18:54 <vixey> what does have a notion of subtype?
13:19:13 <roconnor> @djinn Either a a -> (a,Bool)
13:19:14 <lambdabot> f a =
13:19:14 <lambdabot>     case a of
13:19:14 <lambdabot>     Left b -> (b, False)
13:19:14 <lambdabot>     Right c -> (c, False)
13:19:21 <Cale> Well, we could add subtyping. It would just generally horribly destroy type inference.
13:19:26 <roconnor> :(
13:19:46 <rwbarton> vixey: I think Scala does
13:19:55 <centrinia> Oh. :(
13:20:01 <rwbarton> No, :)
13:20:07 <romildo> Hi.
13:20:11 <Cale> Hello!
13:20:12 <roconnor> hi
13:20:20 <medfly> hey.
13:20:58 <romildo> I am writing a test gtk2hs application where I want to display an image in a tree view.
13:21:08 <mightybyte> How do I get Control.Parallel.Strategies?
13:21:20 <Cale> mightybyte: It's in the parallel package, iirc.
13:21:47 <mightybyte> Cale: Ahh, ok.  Thanks.
13:21:50 <Cale> mightybyte: Normally, it comes with GHC...
13:22:00 <mightybyte> Yeah, it's not with mine for some reason.
13:22:01 <rwbarton> mightybyte: (Are you using Ubuntu by any chance?)
13:22:05 <mightybyte> Yep
13:22:08 <rwbarton> Yeah...
13:22:19 <Cale> But some distributions distribute stripped down versions of GHC, and then separate packages.
13:22:19 <rwbarton> cabal install parallel
13:22:27 <mightybyte> Ok
13:22:39 <Cale> (supposing that you have cabal-install, which is something that you should get)
13:22:41 <rwbarton> Or in Ubuntus case, some separate packages but libghc6-parallel-dev is just missing for some reason
13:22:47 <Cale> oh.
13:22:47 <Cale> heh
13:22:59 <romildo> http://hpaste.org/10983
13:23:06 <mightybyte> rwbarton: Excellent.  That did it.
13:23:13 <Cale> We really need an Ubuntu Haskell maintainer who actually uses Haskell on a regular basis :)
13:23:55 <romildo> In my tree view test with images, I use a list store that has a String field for the path of the image.
13:24:11 <mightybyte> rwbarton: So I'm trying to parallelize that algorithm from yesterday.  I'm thinking that the ST monad is an obstacle to parallelization.
13:24:23 <sjanssen> Cale: the Haskell Platform should help
13:24:41 <medfly> Cale, hi.
13:24:43 <Cale> pixbufNewFromFileAtSize (cover row) 64 64 :: IO Pixbuf, which means that it's a computation that produces a Pixbuf
13:24:44 <romildo> Then I want the view column renderer to build a Pixbuf from it and show it.
13:24:49 <Cale> medfly: hello
13:24:54 <sjanssen> Cale: then the Ubuntu maintainer will just need to make sure all the deps of the platform meta-package are available
13:25:03 <romildo> Cale, exactly. How I would solve that
13:25:12 <rwbarton> mightybyte: Interesting
13:25:13 <pcc1> is it possible to create a type similar to Data.Dynamic that can only contain values of a certain class(es) (and thus the Dynamic value would be a member of that class)
13:25:16 <Cale> romildo: You want to run that computation first, and use its result where you currently have it.
13:25:21 <Cale> romildo: like
13:25:28 <mightybyte> rwbarton: But I could be wrong.
13:25:33 <rwbarton> mightybyte: You can probably get around it using unsafeSTToIO and so on
13:25:34 <Cale> myPixbuf <- pixbufNewFromFileAtSize (cover row) 64 64
13:25:53 <Cale> ... [ MV.cellPixbuf := myPixbuf ]
13:26:00 <rwbarton> mightybyte: The whole point of ST is that it's supposed to behave deterministically
13:26:07 <mightybyte> rwbarton: I was going to try reimplementing it as pure code
13:26:32 <mightybyte> rwbarton: Yeah, but isn't the whole point of monads to sequence computations?
13:26:43 <Cale> What you've currently written means to assign *that computation* to the MV.cellPixbuf property
13:26:54 <rwbarton> mightybyte: Right
13:27:08 <mightybyte> ...which is inherently opposed to what I'm trying to do.
13:27:20 <rwbarton> mightybyte: I mean, you can bring forkIO into the ST monad by force
13:27:28 <Cale> pcc1: There's existential types.
13:27:40 <mightybyte> rwbarton: But that's ugly.  I was trying to find an elegant approach.
13:27:45 <Cale> pcc1: for instance, you can write things like:
13:27:49 <rwbarton> mightybyte: can you hpaste your code again?
13:27:55 <mightybyte> Sure
13:28:01 <Cale> data Showable = forall a. (Show a) => Showable a
13:28:07 <romildo> cale, but there will be one different image from each row in the list store, so I have to build the pixbuf when rendering the column. Where would the coputation be done? I do not see a solution for this.
13:28:14 <Cale> instance Show Showable where
13:28:19 <Cale>    show (Showable x) = show x
13:28:34 <vorner> Hello, I have a code like do result <- hGetContents >>= return . read ; hClose handle ; return result. Is there a function that would encapsluate the hClose and push the result trough? (So I could write hGetContents >>= return result $ encaps hClose handle)
13:28:35 <pcc1> Cale: yes, thanks
13:29:04 <Cale> romildo: Well, you'd do some kind of loop, like with forM, for instance.
13:29:08 <romildo> Cale: I do not think usafePerormIO is solution, is it?
13:29:21 <Cale> romildo: unsafePerformIO is never the solution ;)
13:29:40 <dejones> How can I print out values during debugging?  I've tried using "trace 'test' ..." but that only prints 'test' -- I'd like to print the value a function returns or of a variable.
13:29:43 <dejones> Any suggestions
13:29:44 <mightybyte> rwbarton: http://hpaste.org/10951#a2
13:29:55 <mightybyte> That's the most recent.
13:29:58 <romildo> Cale, The only solution I see is storing the pixbuf itself in the list store.
13:30:19 <romildo> Cale: what I actually have is the paht for the image in the list store.
13:30:20 <sjanssen> dejones: you can output any string you'd like with trace
13:30:40 <sjanssen> dejones: trace ("x = " ++ show x) blah
13:30:46 <mightybyte> rwbarton: (the version that runs in 1m30s)
13:30:54 <rwbarton> dejones: You might like to write a helper function like  traceVal x = trace (show x) x
13:32:09 <romildo> Cale: I think that is undesirable, maybe demanding for more memory. But I am not sure.
13:32:28 <dejones> sjanssen, rwbarton: Thanks.
13:32:38 <Cale> romildo: Well, the pictures have to be allocated at some point.
13:32:45 <Cale> romildo: When do you want to allocate them?
13:33:00 <rwbarton> mightybyte: A pure version of this code might build some lists [ (n*m, n*n) | m <- [1..b`div`n] ] and merge-and-sum them, if you see what I mean
13:33:29 <mightybyte> rwbarton: Yeah, that's what I was thinking.
13:34:06 <romildo> Cale: I wan to allocate them when the corresponding row inthe store becomes visible. The list store may contain hundreds of rows.
13:34:14 <romildo> s/wan/want/
13:34:43 <Cale> romildo: Okay, so the question becomes whether or not the Gtk2 treeview provides a callback for that.
13:35:34 <vorner> Hm, is there no such function?
13:36:03 <Cale> Perhaps treeViewMapExpandedRows ?
13:37:08 <dons> ?users
13:37:08 <lambdabot> Maximum users seen in #haskell: 540, currently: 522 (96.7%), active: 24 (4.6%)
13:37:13 <Deewiant> ?pl (hGetContents >>= return . read) >>= \result -> hClose handle >> return result
13:37:13 <lambdabot> (hClose handle >>) . return =<< read `fmap` hGetContents
13:37:35 <Cale> eek
13:37:47 <Cale> Never ever call hClose on a handle to which you've applied hGetContents
13:37:54 <rwbarton> mightybyte: I think that algorithm has an extra log N time factor, which probably exceeds the number of processors you have available
13:38:09 <Deewiant> Cale: it might not be the same handle, it's vorner's code :-)
13:38:12 <Cale> The handle will be closed automatically when the list is garbage collected.
13:38:45 <Deewiant> and hey, it /could/ be ByteString's strict hGetContents
13:38:52 <romildo> Cale: if that would be possible, yet I would not know how to render the image. The renderer is configured when the view is setup. Anything beyound that may be not easy for my level of knowledge of gtk2hs.
13:39:26 <Cale> dcoutts: are you around?
13:39:34 <vorner> Cale: I have read that, but I'm not sure it is soon enough, since I want to create a program that loads some data, changes them a little and saves them back to the original file. And I need it to be closed when I start writing it.
13:39:44 <Cale> romildo: (dcoutts would know the solution to your problem if anyone does ;)
13:40:04 <rwbarton> vorner:
13:40:06 <Cale> vorner: Then hGetContents is a bad idea.
13:40:11 <dcoutts> Cale: hia
13:40:11 <rwbarton> @src (<*)
13:40:11 <lambdabot> (<*) = liftA2 const
13:40:17 <rwbarton> @. redo unpl liftM2 const
13:40:17 <lambdabot> (\ d e -> do { b <- d; a <- e; return b})
13:40:19 <Deewiant> ?ty (<*)
13:40:20 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
13:40:23 <ziman> maybe somthing like withFile?
13:40:26 <mightybyte> rwbarton: Yeah, I was trying to think of a way to avoid taht.
13:40:27 <Cale> dcoutts: romildo has a question about TreeViews
13:40:51 <vorner> Cale: hm. I wanted to read it all at once :-(.
13:40:52 <Cale> dcoutts: Basically, whether it's possible to get an image to load when a row becomes visible.
13:41:06 <ziman> @hoogle withFile
13:41:06 <lambdabot> System.IO withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
13:41:07 <lambdabot> Distribution.Simple.Utils withFileContents :: FilePath -> (String -> IO a) -> IO a
13:41:07 <lambdabot> System.Process.Internals withFilePathException :: FilePath -> IO a -> IO a
13:41:23 <rwbarton> mightybyte: It's probably unavoidable, generally having access to a mutable data structure of size N in O(1) time gives you an extra log N factor of speed
13:41:42 <vorner> ziman: thanks, that looks nice :-)
13:41:42 <dcoutts> Cale: oh do the image loading lazily?
13:41:43 <pcc1> Cale: I have my existential type but now cannot write an instance for Eq and Ord as the types are potentially different.  would rather not add a type variable everywhere so am wondering what is the best way to coerce these variables to the same type. thanks
13:41:48 <Cale> dcoutts: yeah
13:41:50 <dcoutts> Cale: I think in principle yes.
13:42:02 <vorner> but what bad can happen if I close hGetContents ed handle?
13:42:04 <Cale> pcc1: Not possible.
13:42:13 <mightybyte> rwbarton: Yeah, and lists don't give you O(1) access.
13:42:29 <Cale> pcc1: The point of existential types is to forget what the original type of the value was.
13:42:30 <dcoutts> Cale, romildo: the model has a function that returns the pixbuf on demand. The view only calls that when necessary.
13:42:48 <rwbarton> mightybyte: Right.  So, I think you basically need the IO monad
13:43:00 <rwbarton> mightybyte: hmm
13:43:01 <dcoutts> Cale, romildo: however!... by default the view has to measure the size of the rows to work out how big the view is.
13:43:06 <mightybyte> rwbarton: Hmmm, possibly an Array or a Map of some kind?
13:43:14 <Cale> vorner: You end up with a String that's truncated to whatever has been demanded by the time the hClose happens.
13:43:27 <rwbarton> mightybyte: accumArray is actually really close to what you want
13:43:28 <Cale> vorner: You see, hGetContents is slightly magical.
13:43:40 <romildo> dcoutts: basically I have the path (a String) to the image in the list store.
13:43:54 <dcoutts> Cale, romildo: so if you want genuinely lazy loading then you need to tell the view to use a fixed height row size, so that it doesn't need to compute that all at the beginning and force all the rows just to be able to measure them.
13:43:54 <Cale> vorner: It gives you a String, but the file isn't actually read until the String is evaluated, which might be later.
13:44:31 <rwbarton> mightybyte: If you have k processors, you could split up the range of n into k equal-amount-of-work pieces, accumArray on each and then spend O(nk) time adding them together
13:44:34 <Cale> vorner: So if you go and modify the file, or hClose the handle, you can end up with a String that doesn't correspond to the actual contents of the file.
13:44:42 <vorner> Ah, ok, I will just not use hClose and force the evaluation of the string before I open the file for writing
13:45:08 <mightybyte> rwbarton: Yeah, that's the direction I was heading...since parts of this algorithm are embarassingly parallel.
13:45:12 <rwbarton> vorner: Or, you can use the 'strict' package or Data.ByteString.hGetContents which is strict
13:45:56 <vorner> rwbarton: bytestrings look nice, but I did not yet learned how to write a bytestring constant in the code
13:46:31 <rwbarton> vorner: pack "foo", provided you use Data.ByteString.Char8
13:46:58 <Deewiant> use the utf8-string package
13:47:28 <vorner> Deewiant: thanks, it is probably newer than I looked last time :-)
13:48:04 <Deewiant> Char8 shouldn't exist
13:48:12 <Deewiant> it's just... wrong :-P
13:48:16 <romildo> dcoutts, Cale: one problem is that I am just learning gtk2hs from the demos (and the API, of course), and do not see how would I structure the program. Maybe if someone could write a quick example ...
13:48:28 <rwbarton> Uh, but it says *Byte*String :)
13:48:32 <Cale> fmap unpack (Data.ByteString.hGetContents h)
13:49:02 <Cale> fmap unpack (Data.ByteString.Char8.hGetContents h)
13:49:16 <Cale> (well, really import that module qualified :)
13:49:40 <Deewiant> fmap Data.ByteString.UTF8.toString (Data.ByteString.hGetContents h)
13:50:21 <dcoutts> romildo: perhaps start with a version that just loads all the pixbufs up first, leave the lazy loading to a next step
13:50:26 <vorner> Thanks for all the suggestions, seems I learned more than I thought I need :-)
13:50:27 <romildo> dcoutts: my first attempt is here: http://hpaste.org/10983, but it does not compile because pixbufNewFromFileAtSize is a monad and cannot be called directly in the function that sets attributes on the cell renderer.
13:51:24 <Cale> vorner: Lazy IO is convenient when you have a handful of files you're reading which are different from the ones you're writing, but with this kind of access pattern, kind of falls down.
13:51:59 <Cale> romildo: s/is a monad/is an action/  (monads are type constructors)
13:52:21 <dcoutts> romildo: so you can actually set attributes in IO monad
13:52:59 <byorgey> @src iterate
13:52:59 <lambdabot> iterate f x =  x : iterate f (f x)
13:53:16 <dcoutts> romildo: just use the :=> rather than := attribute setting operator
13:53:21 <thoughtpolice> @seen dons
13:53:22 <lambdabot> dons is in #xmonad, #haskell, #ghc, #darcs and #arch-haskell. I last heard dons speak 5m 40s ago.
13:53:27 <dons> yo
13:53:49 <thoughtpolice> dons: you have a quad core right?
13:53:55 <Cale> dcoutts: but you can't assign a callback to that attribute to be run when Gtk2 actually demands its value ;)
13:54:15 <Cale> (which I think is what he's trying to do?)
13:54:16 <thoughtpolice> dons: wanna try this? http://haskell.org/haskellwiki/Shootout/Parallel/BinaryTreesDPH -- need ghc 6.10
13:54:17 <lambdabot> Title: Shootout/Parallel/BinaryTreesDPH - HaskellWiki
13:55:00 <dons> ooh
13:55:08 <dons> i have a quad core, but not with ghc 6.10 on it yet.
13:55:18 <dons> thoughtpolice: you might want to send it to the list, and cc. rl and chak
13:55:34 <thoughtpolice> k
13:55:38 <dcoutts> Cale: sure you can, that's exactly what is going on
13:55:52 <Cale> oh, hmm, interesting :)
13:55:56 <dcoutts> Cale: the two lines near the end of the paste, addColumn
13:56:06 <romildo> dcoutts: thanks for the tip.
13:56:31 <dcoutts> Cale: those are callbacks that are evaluated for each row the view wants to display, they're functions that set the cell's attributes based on the current row of the model
13:56:32 <Cale> ah, I see, yes
13:56:43 <dcoutts> Cale: and setting attributes is typically pure, but need not be
13:56:45 <dons> thoughtpolice: so how's it perform without +RTS -A ?
13:56:49 <Cale> cellRendererPixbufNew is actually setting the callback :)
13:57:04 <romildo> dcoutts: with this structure, will the program load all images in memory at once, or only when the corresponding how is shown?
13:57:20 <dcoutts> romildo: you'll want to cache the pixbufs rather than load them every time
13:57:32 <dcoutts> romildo: the view can request the same row over and over again, it's fairly important
13:58:06 <dcoutts> romildo: if it does lazy loading or not depends on the view. As I mentioned, by default it has to measure the size of each row to work out the overall height of the view.
13:58:12 <moonpatio> Cale: i may be misunderstanding and i didn't see the original question, but couldn't you just do
13:58:47 <hackage> Uploaded to hackage: turing-music 0.1
13:58:47 <dcoutts> romildo: so that'd require forcing all rows (attrs for cell renderers) but I think you can get real lazy loading by telling the view to use a fixed row height.
13:59:12 <mmorrow> mkCallBack :: IO () -> IO a -> IO a ; mkCallback cb io = cb >> io
13:59:48 <Cale> Heh, turing-music looks cute :)
14:01:33 <thoughtpolice> dons: something like 30 seconds i think?
14:03:03 <thoughtpolice> dons: yeah about 39 seconds
14:03:07 <thoughtpolice> i'll put that up there
14:03:52 <rwbarton> dons: is it allowed to have the program restart itself with different RTS options?
14:04:02 <dons> rwbarton: doubt it.
14:04:03 <takamura> hi
14:04:05 <dons> rwbarton: why?
14:04:48 <rwbarton> dons: Well, if it's just a matter of getting passed a fixed argument list, you could have the program reinvoke itself with +RTS -A350M
14:05:01 <dons> ah, but we're not allowed to use GC hints
14:05:02 <ozy`> finally being able to actually read and make sense of haskell's syntax is almost as baffling an experience as seeing it and having no idea what it means
14:05:07 <dons> for binary-trees, that is.
14:05:09 <rwbarton> dons: ah, ok.
14:05:20 <dons> otherwise we'd just run it directly with +RTS -A
14:05:33 <Cale> aww, the package is missing some files...
14:05:38 <Cale> (turing-music)
14:05:40 <dons> turing-music?
14:05:41 <dons> boo
14:05:45 <dons> contact the author quickly
14:05:49 <dons> he'll probably fix it now
14:06:07 * dcoutts bangs the drum for build reporting
14:06:58 <luqui> hi.  what sort of evil hackery might I need to do to implement readTVarIO :: TVar a -> IO a, which reads a tvar without opening a transaction
14:07:10 <romildo> dcoutts: to get the view to use a fixed row height is enough to call treeViewSetFixedHeightMode in the view?
14:07:13 <dancor> reactive-0.8.1 doesn't really make any sense to me (why does Event have a list of Future's instead of just one Future Reactive like in the paper)
14:07:16 <luqui> or is that simply not possible whatsoever (or horribly horribly unsafe)
14:07:20 <dancor> i guess i'll try going back to 0.5
14:07:24 <Cale> luqui: not possible.
14:07:28 <Cale> luqui: Just apply atomically.
14:07:33 <luqui> Cale, not so simple.
14:07:36 <dcoutts> romildo: honestly I'm not sure. You may also need to explicitly set a height.
14:07:42 <Cale> luqui: why not?
14:07:43 <luqui> this needs to be done in unsafePerformIO.
14:07:52 <luqui> RTS extensions and whatnot
14:07:59 <Cale> hmm
14:08:10 <Cale> You people and your unsafePerformIO
14:08:23 <Cale> hehe
14:08:49 <luqui> yeah.  well really what I need is variables with the following property:  you can write *single* ones from IO (no transactions necessary), and you can block on multiple at a time
14:09:03 <luqui> and you can nonblocking read one inside unsafePerformIO
14:09:36 <luqui> I tried unsafeCoerce (readTVar# (unsafeCoerfe# tvar))  but that segfaults  (doesn't surprise me all that much)
14:10:07 <idnar> http://hpaste.org/10984 --- anyone feel like critiquing some newbie Haskell code?
14:10:08 <luqui> but all the transaction trickery is all safe, I just need to read one, only one!!  :-)
14:10:19 <mmorrow> what do you mean "block on multiple at a time"?
14:10:23 <bd_> luqui: Can you have a thread that updates an IOVar to shadow the TVar?
14:10:33 <luqui> block on the first of several variables to change (or in my case, "become defined")
14:10:41 <mmorrow> oh, i see
14:11:11 <mmorrow> by "become defined" you mean not have a value of undefined, right?
14:11:12 <luqui> bd_, I don't follow
14:11:18 <bd_> luqui: and, from what I understand, the raw tvars may (transiently) hold data that belongs to an aborted (or to-be-aborted) transaction, so you don't want to read it without going through all the hoops
14:11:28 <luqui> mmorrow, haha no.  I mean not have a value of Nothing.
14:11:38 <mmorrow> ah, ok
14:11:44 <bd_> luqui: well, you'd have a loop that opens a transaction, blocks until it sees the tvar have a new value, then writes it out to an IOVar
14:12:00 <thoughtpolice> dons: updated with times, i'll send to g-h-u in a little
14:12:30 <dons> cheerss
14:12:48 <pythonikkat> hi there, i'm pretty new to haskell. but is haskell adpated to computational heavy jobs?
14:13:11 <romildo> dcoutts: I think I will let this issue for later research. In the current implementation (calling pixbufNewFromFileAtSize in the function that set attributes on the cell renderer) does the images get cached?
14:13:13 <luqui> bd_, sure, but in my case, I know that no transactions will ever be aborted.
14:13:14 <mmorrow> luqui: ok, what is your policy to choose between which var in a set to grab in more than one becomes ready at once?
14:13:20 <mmorrow> s/in/if/
14:13:28 <luqui> bd_, or rather, no transactions that write anything will ever retry
14:13:31 <luqui> (only ones that read)
14:13:32 <Cale> pythonikkat: I suppose it depends a bit on what you mean by "computationally heavy"
14:13:39 <romildo> dcoutts: if not, storing the images instead of a path to them in the list store is a better solution?
14:13:52 <bd_> luqui: You don't know that no transactions will be aborted
14:13:53 <pythonikkat> Cale, e.g. scientific computation
14:13:58 <luqui> mmorrow, arbitrary, I don't care.
14:14:03 <bd_> luqui: If you can ever have two txns running at once, they may be aborted
14:14:10 <Samy> Anyone here work or ponder providing Haskell support for acceleration devices?
14:14:15 <Samy> That includes GPU, etc...
14:14:22 <mmorrow> luqui: because i bet some structure with MVars+TVars can be made, but it's structure will determine that
14:14:33 <bd_> luqui: how about something like this (untested) http://hpaste.org/10986
14:14:35 <takamura> I'm looking for a library to send e-mail. I looked at Happs and haskellnet, but they are too poorly documented, and Happs seems overkill to simply sending e-mail. Can you recommend me some other library? (or at least a good tutorial/documentation)
14:14:35 <Samy> Going to propose it as my senior design project for undergraduate.
14:14:35 <luqui> bd_, hmm, maybe ou're right.
14:14:42 <pythonikkat> Cale, in python, they have a lot of numeric support. i'm just curious how haskell does in this field
14:14:57 <Samy> pythonikkat, http://shootout.alioth.debian.org/
14:14:58 <lambdabot> Title: The Computer Language Benchmarks Game
14:15:09 <thoughtpolice> dons: think I might have a go with the other benchmarks too
14:15:12 <Samy> pythonikkat, a properly written Haskell application will pee-pee on Python with regards to compute throughput.
14:15:17 <thoughtpolice> get comprehensive stuff across the board of what we have now
14:15:18 <dons> thoughtpolice: sounds good
14:15:22 <rwbarton> luqui: what about IO $ \s -> readTVar# (unsafeCoerce# tvar) s
14:15:24 <luqui> mmorrow, the only thing I can think of is having a "callback" thing going on, which does not have nice GC properties (have to do crap with weak references and all sorts of non-hack hackery... I'd prefer to do one little teeny hack :-)
14:15:25 <rwbarton> (just a guess)
14:15:32 <Samy> The problem is, I'm actually working on something bit unique.
14:15:36 <Cale> pythonikkat: It's a general purpose language, and the code generator in GHC is not so bad. You can do quite a lot in a reasonable amount of time. It's not Fortran yet, but in the next short while as Data Parallel Haskell gets more complete, things should get really interesting.
14:15:48 <pythonikkat> Samy, i guess so.
14:16:07 <pythonikkat> Cale, this is good to know
14:16:09 <mmorrow> luqui: heh
14:16:12 <Samy> That would be FPGA support. I wrote a portable core invocation framework for, going to be forced to use IO.
14:16:14 <luqui> rwbarton, first thing I tried (used unsafeCoerce for IO, since nobody exports that constructor far as I know)
14:16:21 <rwbarton> luqui: alas
14:16:24 <luqui> rwbarton, that segfaults.
14:16:31 <Samy> Hrm, I think a better question is...
14:16:33 <rwbarton> luqui: Oh, I see, yeah
14:16:44 <Cale> pythonikkat: There are some libraries for numeric computations of various kinds. I'm not sure what is missing or needed, but there's nothing which in principle couldn't be written.
14:16:47 <Samy> Are there examples of a good asynchronous API in Haskell?
14:16:59 <jelmer> dcoutts, is there some way to use "proper" structs in c2hs (as opposed to pointers to structs) ?
14:17:17 <luqui> bd_, oh, that's not what I meant by "just one".  I meant I don't need any sort of multi blocking or anything inside the unsafe.  but that solution doesn't have nice GC properties again.
14:17:21 <dcoutts> romildo: if you can afford to load all the images into memory first then yes, do that, it's much simpler
14:17:21 <Samy> When I mean "good", I mean good design.
14:17:27 <mmorrow> Samy: sweet, what are you doing with FPGAs?
14:17:49 <pythonikkat> Cale, for me, all i care is linear algebra package, such as a rewrite to lapack or some kind of interface
14:17:54 <luqui> unfortunately, I may be stuck having to implement my own half-stm (I hope it doesn't come to that)
14:18:06 <rwbarton> luqui: (BTW, GHC.IOBase exports IO)
14:18:25 <luqui> rwbarton, thanks
14:18:56 <Cale> pythonikkat: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmatrix
14:18:58 <romildo> dcoutts: I will try it. If it becomes too expensive I think about another solution to the problem later.
14:18:58 <lambdabot> Title: HackageDB: hmatrix-0.4.0.0, http://tinyurl.com/58d3eb
14:19:03 <dcoutts> jelmer: c2hs cannot construct Storable instances for you automatically, but it can be used to write them by hand (in much the same way as you would with hsc2hs)
14:19:13 <Samy> mmorrow, let me see if I can find some slides for you, is that fine?
14:19:20 <Samy> In the mean time
14:19:21 <romildo> dcoutts: thanks for the tips.
14:19:28 <Cale> pythonikkat: I haven't used that extensively, so I don't know how nice it is, but it looks like it has lots of useful stuff.
14:19:31 <dcoutts> romildo: np
14:19:31 <Samy> @google GWU core invocation framework
14:19:34 <lambdabot> http://kerneled.org/site/?q=node/7
14:19:34 <lambdabot> Title: gca - GWU Core I/O Abstraction | kerneled.org
14:19:40 <Samy> mmorrow, that is an example.
14:20:12 <jelmer> dcoutts, thanks
14:20:25 <Samy> mmorrow, I wanted Linux to "properly" support these accelerator devices in general, specific to FPGAs is support for partial reconfiguration.
14:20:48 <Samy> mmorrow, anyhow, sponsor decided that UPC support is more important so I stopped at that library.
14:20:57 <Samy> I'll paste some examples on hpaste.
14:21:18 <mmorrow> Samy: awesome, that'd be great
14:21:51 <luqui> hm, isn't ghc in git now?
14:22:03 <pythonikkat> Cale, indeed. I had a quick look at this package, it's pretty nice. most of daily routines are covered, so I'll say this is functional enough for simple linear algebra
14:22:05 <dancor> how do you refer to (.) in Control.Category if you import it qualified as Cat
14:22:10 <Deewiant> Cat..
14:22:25 <luqui> most .. confusing .. notation .. ever!
14:22:37 <Deewiant> what else could it be :-P
14:22:49 <luqui> The half-infinite range starting at Cat
14:22:49 <Cale> dancor: Generally, you'd import the Prelude hiding ((.))
14:23:02 <Deewiant> I meant, the notation for Cat..
14:23:11 <Cale> dancor: It's too annoying to use infix operators which are qualified.
14:23:23 <luqui> Deewiant, oh.  Beats me.  :-)
14:23:27 <Deewiant> meh, I'm fine with Map.! and such
14:23:44 * rwbarton sees an opportunity here for Data.Set.Unicode
14:23:45 <luqui> Deewiant, yeah, that's fine.  It's just . that causes problems.
14:23:49 <dancor> oh i had something else wrong
14:23:49 <Cale> I'm really unhappy with Haskell's choice of module path separator.
14:23:56 <Cale> It should have been |
14:23:58 <Deewiant> luqui: yeah, but special casing it would be worse IMO.
14:24:05 <luqui> Agreed
14:24:13 <Deewiant> Cale: and then we'd have the problem of Bits|| ;-)
14:24:20 <luqui> it was an idle complaint, with no true purpose
14:24:28 <Deewiant> hmm, except it's not | is it
14:24:32 <Deewiant> ?ty (|)
14:24:33 <lambdabot> parse error on input `|'
14:24:37 <luqui> we'd have Prelude|||
14:24:38 <Deewiant> hmm
14:24:51 <Deewiant> @let (|) = (+) in 1 | 2
14:24:51 <lambdabot>   Parse error
14:25:03 <Cale> | is reserved for guards
14:25:06 <dons> ?users
14:25:06 <lambdabot> Maximum users seen in #haskell: 540, currently: 512 (94.8%), active: 22 (4.3%)
14:25:07 <rwbarton> > let f Prelude|Nothing = 0 ; ...
14:25:08 <lambdabot>   mueval: Prelude.read: no parse
14:25:11 <Samy> mmorrow, I posted an example "core description" on hpaste.
14:25:14 <Deewiant> ah right, guards
14:25:17 <Samy> mmorrow, http://hpaste.org/10987
14:25:22 <luqui> :t (Data.Bits..|.)
14:25:23 <lambdabot> forall a. (Bits a) => a -> a -> a
14:25:27 <Deewiant> I was thinking list comprehensions and wondering why it's reserved just for that
14:25:56 <Cale> So yes, you'd end up with a few possible ambiguous things, but since most people put whitespace before any guard already, that would be even less of a problem than with .
14:26:27 <ezrakilty> is there something that would make GHCi hide all the symbols but main in a module loaded with :load?
14:26:33 <Samy> mmorrow, http://hpaste.org/10988 is example usage of the API
14:26:51 <ezrakilty> (i don't have a "module" declaration and hence I'm not hiding anything myself.)
14:27:46 <ezrakilty> (odd, the problem just went away; mystified....)
14:27:51 <kosmikus> ezrakilty: if the module is compiled (not interpreted), GHCi can only see exported symbols
14:28:07 <kosmikus> ezrakilty: try removing the .o
14:28:18 <rwbarton> ezrakilty: I notice this happens sometimes when I use ghci from emacs, particularly when I load a file that hasn't changed
14:28:30 <ezrakilty> rwbarton: yes, that's the situation i was in
14:28:33 <rwbarton> ezrakilty: Maybe it happens when I ghc --make in the terminal window
14:28:46 <ezrakilty> it seemed to shake loose when I made a trivial edit and saved it.
14:28:51 <rwbarton> ezrakilty: I usually just do that, yeah
14:28:55 <Samy> mmorrow, http://hpaste.org/10989
14:29:00 <ezrakilty> maybe it was implicitly loading the nearby .o file for some reason...
14:29:09 <Saizan> that's the default
14:29:11 <hoknamahn> hi guys, is it possible to make an operator like this (^x^) :: v -> v -> v ? seems not. why?
14:29:19 <Saizan> if there's an up to date .hi .o ghci just loads them
14:29:22 <luqui> hoknamahn, a ^x^ b
14:29:29 <luqui> is that 3 or 5 tokns?
14:29:40 <Cale> hoknamahn: infix operators must be composed entirely of symbol characters
14:29:43 <Samy> mmorrow, if you have time, I would like some minutes if you have some nice ideas.
14:29:48 <Saizan> in fact it's a very useful thing to speed up module loading if you're working on just an handful of modules from a big project
14:29:58 <hoknamahn> okay cool thanks
14:29:59 <ezrakilty> hoknamahn: idenifiers have to be all symbols or all non-symbols.
14:30:17 <luqui> hoknamahn, though you can use the unicode X if you like :-)
14:30:22 <hoknamahn> but as i see ^^ doesn't work too?
14:30:26 <ozy`> "unicode X?"
14:30:34 <luqui> > let (^^) = (+) in 3 ^^ 4
14:30:36 <lambdabot>   7
14:30:41 <luqui> worksforme :-)
14:31:01 <hoknamahn> oh i meant ^ "pipe" ^
14:31:01 <hoknamahn> :)
14:31:01 <luqui> ozy`, I was referring to the "times" symbol.  I don't know the codepoint offhand
14:31:05 <rwbarton> > let a ^×^ b = a + b in 3 ^×^ 4
14:31:07 <lambdabot>   7
14:31:31 <luqui> hoknamahn, OH! you're talking about making a circumfix operator
14:31:41 <luqui> wait, are you?
14:31:56 <rwbarton> Probably not, :: v -> v -> v
14:32:01 <luqui> ah right
14:32:04 <hoknamahn> well my problem is how to describe vector operations. for example i have vector ^*^ vector to multiply components by components of vectors, ^.^ for dot product
14:32:17 <hoknamahn> and i want to describe cross product
14:32:26 <Cale> componentwise multiplication is rare
14:32:27 <hoknamahn> don't see a proper name for it
14:32:27 <rwbarton> I suggest removing the "multiply components by components of vectors" operation :)
14:32:29 <luqui> hoknamahn, you could aways do   foo `cross` bar
14:32:33 <Cale> I'd give it something less convenient.
14:32:41 <ozy`> luqui: ✕?
14:32:49 <luqui> ozy`, that's the one :-)
14:32:53 <hoknamahn> but cross isn't very short :)
14:32:55 <ozy`> > let (✕) = (*) in 3 ✕ 4
14:32:57 <lambdabot>   12
14:33:03 <luqui> hoknamahn, it's not very long
14:33:08 <hoknamahn> :D sure
14:33:26 <hoknamahn> but if i want to make consistent syntax for vector operations?
14:33:35 <luqui> if this were java it'd be  foo.EnterpriseVectorCrossProduct(bar)
14:33:50 <hoknamahn> yeah loooooooong names
14:34:00 <luqui> hoknamahn, then wouldn't you like to make consistent syntax with all of mathematics?  so you can multiply with x y instead of x * y?
14:34:18 <Cale> hoknamahn: Perhaps .*. for cross product, and *. for dot product (convention: the .'s are next to vectors)
14:34:34 <luqui> Caelum, you mean *. for scalar product?
14:34:36 <Cale> and maybe ^*^ for componentwise multiplication
14:34:41 <Cale> yeah
14:34:45 <Cale> er, scalar
14:34:48 <ozy`> luqui: don't forget, you'd have to supply several constants in SynergisticExperienceEnterpriseVectorClass as additional arguments just to get reasonable behavior
14:34:49 <Cale> Right...
14:34:56 <luqui> I do ^*^ = dot, *^ = scalar, `cross` = cross
14:35:00 <Cale> .*. would normally be my inner product :)
14:35:09 <luqui> OR!  you could use the vectorspace library which has already made all these decisions for you
14:35:13 <Cale> heh
14:35:18 <hoknamahn> what if to switch to names? dot, cross, add, subtract etc?
14:35:41 <hoknamahn> luqui nooo, i'm lerning haskell i need to write by myself :)
14:35:45 <mmorrow> luqui: i'm not sure how this can be related to what you're looking for wrt the STM, but http://hpaste.org/10990
14:35:58 <Cale> hmm
14:36:01 <Samy> mmorrow, did you think I wrote something in haskell? :-P
14:36:16 <mmorrow> Samy: awesome looking now
14:36:19 <mmorrow> heh
14:36:22 <ozy`> hoknamahn: I'd do [dotV, addV, crossV, subV] just to be sure
14:36:28 <ozy`> (and then nuke them from orbit)
14:36:28 <Cale> It seems that hmatrix uses  <>  for matrix product,  <.> for inner product,  .* for scalar multiplication
14:37:07 <Cale> It doesn't fix a notation for cross product.
14:37:10 <hoknamahn> Cale yes I have to check different libraries to find a "proper" syntax
14:37:14 <rwbarton> newtype Ket a = |a>
14:37:32 <Samy> mmorrow, anyways, that stuff was "functional", ultimately. I did some pipeline optimizations too, so you could do for example pipe(&gpipe, dwt, scale, dither). execute(&gpipe)
14:37:37 <luqui> mmorrow, thanks, but that's no better than what I'm trying to replace ;-)
14:37:38 <mmorrow> Samy: definitely, i'll hit you up with some thoughts after i go through it
14:37:51 <mmorrow> luqui: heh
14:38:14 <Samy> mmorrow, ok. cool. There is no need to use that specific library, BTW.
14:38:15 <luqui> mmorrow, currently reactive uses unamb, which races threads against each other, to block on multiple things at once
14:38:24 <luqui> this has terrible and unpredictabe performace
14:39:09 <Cale> hoknamahn: Yeah, it seems nobody has really settled on anything. Perhaps in the future, we'll have a class for additive groups, at which point you'd be able to use ordinary + for vector addition, at least :)
14:39:16 <mmorrow> luqui: i've been meaning to look into reactive after seeing quicksilver's code on moonpatio.com:8080 but haven't had the time yet. it looks really interesting
14:39:28 <Samy> mmorrow, but I really want this to be a library/runtime. I don't have time to learn Verilog/VHDL for compiler "support" (let alone language support).
14:39:33 <ozy`> hmm, I wanna use the biohazard sign as an operator now
14:39:39 <Cale> hehe
14:39:52 <mmorrow> Samy: we can generate VHDL with Lava :)
14:39:54 <Samy> mmorrow, oh, and I was thinking an RPC model.
14:40:06 <Samy> mmorrow, I'm not interested in this problem of code-generation.
14:40:14 <vixey> Haskell on Hardware?
14:40:19 <Samy> mmorrow, I'm interested in lack of runtime systems support (a nice API for asynchronous computation).
14:40:32 <ozy`> or I suppose I could use a plane as a function name and make all my variables look like skyscrapers
14:40:43 <mmorrow> Samy: ah, i see. very cool, i'll think about it.
14:40:44 <luqui> mmorrow, it is very interesting, but it is so not ready for doing Real Things in.  I'm trying to get it there...
14:40:44 <Cale> > let xs ⊕ ys = liftM2 (,) xs ys in [1,2,3] ⊕ [4,5]
14:40:45 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
14:40:45 <Samy> And when I mean "asynchronous computation", I mean offloading to hardware in a low latency manner.
14:40:59 <ozy`> (maybe just for functions with side effects)
14:41:00 <Samy> mmorrow, scheduling, etc...(I want to map all FPGAs).
14:41:04 <Samy> mmorrow, ok, cool.
14:41:12 <luqui> (and I'm getting paid for it, which is freaking wicked!)
14:41:41 <luqui> I love git!  ghc checkout in 10 minutes!
14:42:05 <mmorrow> Samy: i'm about to buy one of these: http://picocomputing.com/products/cards/e16.php
14:42:10 <lambdabot> Title: Pico Computing, Inc - Products
14:42:13 <mmorrow> sweet!!
14:42:47 <mmorrow> luqui: whoa, awesome (on the cash) :)
14:42:57 <Samy> mmorrow, seems very nice
14:43:04 <Cale> luqui: That's actually something I don't understand about git and darcs. Why should it take any longer to get a copy of the repository than it does to download the bits?
14:43:20 <luqui> isn't darcs doing some fancy merging thing?
14:43:22 <mauke> because darcs first needs to apply every single patch?
14:43:29 <Cale> As in, why the hell do they go about rebuilding the repo from patches?
14:43:50 <Cale> (Rather than just copying the thing wholesale)
14:43:57 <Samy> mmorrow, http://hpcl.gwu.edu/index.php?option=com_content&task=blogcategory&id=14&Itemid=27
14:43:59 <lambdabot> Title: High Performance Computing Lab @ GWU - Supercomputers, http://tinyurl.com/47jtaw
14:44:03 <rwbarton> to construct a working tree you mean?
14:44:20 <luqui> Cale, that's a very good question.  10 minutes is a long time for 100MB
14:44:47 <mmorrow> Samy: interesting
14:44:47 <Samy> mmorrow, ignoring the stupid name, "supercomputers", these are the kinds of FPGAs I have access (we're working on getting an XT3 and just built a new 1024-node cluster, latter not having FPGAs, though).
14:44:48 <Cale> darcs already keeps a pristine copy, doesn't it?
14:45:04 <mmorrow> Samy: (note that the express card has a Virtex-5)
14:45:12 <Samy> nod, i saw
14:45:14 <luqui> yeah, it might not be very smart about cloning it though.
14:45:22 <Cale> yeah.
14:45:29 <Samy> mmorrow, bandwidth sucks though.
14:45:37 <mmorrow> Samy: i'm so psyched to stick that in my latptop right next to the wifi card :)
14:45:50 <Cale> Maybe people value bandwidth over CPU time.
14:45:50 <mmorrow> Samy: hmm :(
14:45:51 <Samy> mmorrow, RC100 has peaked at ~9GB/s for some cores.
14:46:17 <mmorrow> heh
14:51:28 <mmorrow> <vixey> Haskell on Hardware?
14:51:41 <vixey> bye
14:51:49 <mmorrow> vixey: and dynamically reprogrammable (by itself) at that
14:52:02 <vixey> ..in the type system??
14:52:09 <mmorrow> of course!!@
14:52:11 <ziman> preflex, ping
14:53:03 <preflex> ziman, pong
14:53:31 <ziman> :)
14:57:35 <wchogg> Stupid question:  I have a program I compiled with GHC and I'm getting occasional <<loop>> errors while it's running.  Are there any runtime options I could use to get more information on which thread is having the problem?
14:58:15 <rwbarton> wchogg: Perhaps compile with profiling and run with +RTS -xc
14:58:43 <ziman> i'm trying to cabal-install some packages and i get "undefined reference to `prettyzm1zi0zi0zi0_TextziPrettyPrintziHughesPJ_lvl18_closure'" although i've reinstalled the `pretty' package several times. Is there a common way to solve such problems?
14:58:47 <hackage> Uploaded to hackage: hsyslog 1.3
14:58:47 <hackage> Uploaded to hackage: turing-music 0.1.1
14:59:09 <ziman> (i get this error in multiple packages, namely crypto, LambdaShell)
14:59:20 <Samy> mmorrow, interesting
14:59:33 <mauke> preflex: zdec prettyzm1zi0zi0zi0_TextziPrettyPrintziHughesPJ_lvl18_closure
14:59:33 <preflex>  pretty-1.0.0.0_Text.PrettyPrint.HughesPJ_lvl18_closure
15:00:22 <dcoutts> ziman: my guess is that you've got the exact same package version (pretty-1.0.0.0) registered globally and in the per-user db
15:00:52 <Samy> meh
15:01:34 <dcoutts> ziman: we don't handle that situation well, we can end up picking the wrong instance
15:03:11 <Samy> mmorrow,
15:03:28 <Samy> mmorrow, I can see why a purely functional language makes better sense than VHDL.
15:06:20 <ziman> dcoutts, i see. Is there a command to uninstall one of them? I can't find one in the docs & help.
15:06:28 <rwbarton> from the HXT package:  newtype IOLA    a b = IOLA  { runIOLA :: (a -> IO [b]) }
15:06:40 <rwbarton> This is presumably Not An Arrow, in the same way ListT is Not A Monad Transformer?
15:08:51 <dino-> That's an interesting question. Is the best way to deal with this ghc-pkg unregister?
15:09:05 <dino-> And then what if you want to track down the installed files and get rid of them?
15:09:19 <Botje> ghc-pkg terminate.
15:09:31 <Botje> soundbit of arnold optional :)
15:09:51 <dcoutts> ziman: we don't have great uninstall support yet, you can unregister the per-user one, and you can also rm the corresponding files
15:12:42 <dino-> Do the files get installed in /usr/local/lib on a *nix system? I see things that looks like much of what I've cabal installed there.
15:13:08 <dino-> Ah, I should clean this. I see things for old GHC versions and different old versions of libs that we've moved on from.
15:17:46 <dino-> Looks like from a glance at something's dist/setup-config: ...InstallDirTemplates {prefixDirTemplate = "/usr/local"...
15:18:48 <hoknamahn> guys, I'm wondering is division in general slower than multiplication? not in haskell but rather in the hardware?
15:19:01 <luite_> yes
15:19:02 <mbz> hoknamahn, yep it is.
15:19:13 <hoknamahn> okay than make sense
15:19:38 <mbz> generally division is much more slower then multiplication
15:19:49 <mbz> than
15:20:19 <hoknamahn> should haskell optimize such code x = y * (1 / 3)?
15:20:55 <mauke> what, like constant folding?
15:21:09 <hoknamahn> yes
15:25:16 <dino-> oof, it also says plainly when you ghc-pkg list: /usr/local/lib/ghc-6.8.3/package.conf:
15:25:18 <ziman> i uninstalled the global one using Setup.hs from the tarball; i'm still getting errors (-lHSpretty-1.0.0.0 not found) but i'll sort that out tomorrow. dcoutts, thanks for the hints!
15:26:16 <ozy`> hoknamahn: are haskell's floating point operations more commutative than hardware floating point in general? I know it uses a different storage method under the hood for some stuff...
15:26:45 <hoknamahn> ozy don't ask me because i'm very new to haskell
15:28:03 <dcoutts> ziman: oh, you didn't want to uninstall the global one, several other global packages depend on it
15:29:00 <ozy`> hoknamahn: heh, okay
15:30:12 <hoknamahn> :)
15:31:41 <dolio> GHC does some constant folding, but nothing that will blow your socks off.
15:33:04 <dons> unless you fuse first
15:33:10 <dons> then it makes your socks fold themselves
15:34:08 <rwbarton> It seems to convert 1/3 to 0.3333333333333333, at least if it knows it's at the Double type
15:34:10 <hoknamahn> is there any literature how to write more optimal code for ghc/
15:34:12 <hoknamahn> ?
15:34:55 <mauke> it's a black art
15:35:03 <rwbarton> hoknamahn: take a look at dons' blog
15:35:31 <rwbarton> hoknamahn: e.g. http://cgi.cse.unsw.edu.au/~dons/blog/2008/05/16
15:35:33 <lambdabot> Title: Haskell hacking
15:37:15 <hoknamahn> cool thanks a lot guys!
15:38:08 <Xenoblitz> guys does haskell have a matrix library?
15:38:20 <dolio> It has, like, two.
15:38:29 <Xenoblitz> any names?
15:38:37 <ozy`> Xenoblitz: I saw some code the other day for dealing with agents
15:38:46 <TSC> hmatrix
15:38:56 <dolio> Check hackage for hmatrix and maybe blas.
15:39:03 <Xenoblitz> thanks guys
15:39:09 <Xenoblitz> @hackage hmatrix
15:39:09 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmatrix
15:39:41 <Xenoblitz> @hackage blas
15:39:41 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/blas
15:42:02 <dancor> easy way to see subsecond difference of time between two points in program?
15:42:39 <dolio> Do it thousands of times in a loop and then divide?
15:43:03 <dancor> but should i use like the full Data.Time stuff i mean
15:43:43 <dolio> CPUTime might work. It's what I've been using to test the speed of my programs.
15:43:49 <solrize_> :t head
15:43:50 <lambdabot> forall a. [a] -> a
15:43:56 <dancor> i think that doesn't progress in real time
15:44:02 <dolio> It tells you how much time gets used by your program, not wall clock.
15:44:09 <dancor> ya i need wall clock
15:44:18 <dolio> Ah. Then it may be Data.Time, yes.
15:44:39 <dancor> i'm doing this for the Sink ITime function for runR in reactive
15:44:46 <Pseudonym> If in doubt, add "h" in front of what you want to do.  It's probably on hackage.
15:45:23 <Pseudonym> Yeah, I need to hprocess some hfiles.
15:45:44 <dons> i think you should add "monad" as a suffix
15:45:46 <ddarius> @hackage rdtsc
15:45:46 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/rdtsc
15:45:57 <Pseudonym> True.
15:46:31 <Pseudonym> So if you need to MungeMonad some hdata, hackage is where to look.
15:46:32 <Samy> ddarius, do you use it?
15:46:37 <dons> yeah.
15:46:39 <dons> zactly
15:46:55 <Samy> ddarius, I have a present for you if you do :)
15:47:08 <ddarius> I've never needed to.
15:47:25 <Pseudonym> I've never seen ddarius turn down a present, though.
15:47:39 <ddarius> Pseudonym: You've never seen me accept one either.
15:47:46 <dons> its a sad situation
15:47:56 <Samy> ah, dolio uses it
15:48:02 <Pseudonym> ddarius: I fail to see how that negates my point.
15:48:07 <ddarius> Pseudonym: I expect to be presented a present if I should ever meet you.
15:48:30 <ddarius> Negating your point wasn't my goal.
15:48:34 <Pseudonym> For some reason, I had a vision of that episode of Doctor Who.  "Breath from my mouth!"
15:48:42 <Pseudonym> Believe me, you'd turn that one down.
15:49:17 <ProaKa_> http://www.pennergame.de/change_please/7762892/
15:49:23 <lambdabot> Title: Pennergame
15:49:26 --- mode: ChanServ set +o Pseudonym
15:49:28 <Samy> dolio, what's your e-mail?
15:49:47 <dolio> Why?
15:49:53 <Samy> I just want to be friends :(
15:50:00 <Samy> But I also want to e-mail you some stuff I've been working on
15:50:03 <Samy> System.CPU.*
15:50:13 <Samy> Includes a "better" rdtsc (proper serialization).
15:50:42 <dolio> Just make a package and tell me about it when you do. :)
15:50:54 <dolio> I don't have an urgent need for CPU timing.
15:50:54 <Samy> Or I could e-mail it to you in 15 minutes.
15:51:08 <Samy> dolio, ok
15:53:10 <dolio> I've just been using it to tell me whether any given tweak made my code better or worse at, say, sorting 10 million element arrays.
15:53:30 <rwbarton> What's the relationship between Data.Generics and Data.Generics.SYB?
15:54:04 <dancor> isPrefixOf   (i had to..)
15:54:34 <ddarius> One's the same as the other but the other one is different.
15:54:34 <dolio> .SYB is in a separate package, no?
15:56:38 <rwbarton> Oh, maybe I have .SYB because I have HApps installed?
15:57:06 <dolio> It's from the syb-with-class package, I think.
15:57:34 <rwbarton> Yeah, I just missed it in ghc-pkg list the first two times.
15:58:05 <Saizan> syb-with-class has .SYB.WithClass.*
15:58:22 <rwbarton> I guess I mean, what does one do that the other doesn't.
15:58:36 <dolio> I don't think I ever read the SYB With Class paper, so I don't know what the difference is from the other stuff.
15:58:55 <dolio> If there is anything different.
15:58:56 <dons> you could read the comparitive generics paper from this year's HW.
16:01:39 <sbahra> dolio, ic
16:02:06 <rwbarton> dons: thanks.  I found something which may or may not be that, but looks very useful
16:08:23 <adu> hi
16:13:46 <dancor> how do you convert NominalDiffTime to Double (seconds)
16:14:03 <adu> dancor: something like dayFraction
16:15:47 <dancor> i don't have a TimeOfDay..
16:16:53 <dancor> toRational
16:16:59 <adu> dancor: how about (\(MkDiffTime pico) -> pico) hehe
16:17:38 <dancor> adu: i just might..
16:17:43 <shapr> @users
16:17:43 <lambdabot> Maximum users seen in #haskell: 540, currently: 491 (90.9%), active: 13 (2.6%)
16:17:48 <shapr> wow, 540!
16:17:57 <dancor> let's see if i can figure out how to go from Rational to Double
16:18:06 <adu> dancor: but then again I have no idea what Pico is
16:18:10 <pumpkin_> is there a way of making an empty "do-nothing, return-nothing" IO?
16:18:11 <shapr> Man, I want to write some code!
16:18:22 * dancor always feels silly writing fromRational . toRational
16:18:23 <shapr> pumpkin_: Yes?
16:18:36 <pumpkin_> how do I do that? I feel dirty doing a putStr ""
16:18:39 <paczesiowa> pumpkin_: return ()
16:18:42 <pumpkin_> oh, duh
16:18:44 <pumpkin_> sorry :P
16:19:11 <paczesiowa> that's return-nothing, if you want do-nothing return-nothing then do return ()
16:19:21 <pumpkin_> yeah, that's what I was looking for
16:19:22 <adu> paczesiowa: lol
16:19:23 * pumpkin_ feels stupid
16:19:33 <adu> pumpkin_: (do x) == x
16:19:47 <paczesiowa> for simple x
16:20:18 <dancor> pumpkin_: watch out for sequence too.. i'm always trying to do something i think is going to be totally crazy and then in the end it's just sequence
16:20:32 <dancor> in the TotallyCrazy Monad
16:20:37 <pumpkin_> yeah :)
16:20:50 <adu> speaking of do syntax, I need to learn how to use the (Either a) monad
16:21:05 <adu> because I am getting sick and tired of checking Left/Right
16:21:22 <paczesiowa> adu: you understand Maybe monad?
16:21:37 <adu> no, I always check for Just/Nothing lol
16:21:49 <adu> paczesiowa: but in theory, yes
16:22:04 <paczesiowa> adu: (do you understand Maybe monad) /= you understand Maybe monad :>
16:22:12 <pumpkin_> thanks!
16:22:20 <paczesiowa> adu: then Either () is just like Maybe
16:22:56 <paczesiowa> checking for Just/Nothing is ok if you do it only once
16:22:59 <BONUS_> just like a Nothing short circuits the computation to Nothing, Left <anything> short curcuits it to that
16:23:37 <paczesiowa> BONUS_: actually it short circuits it to Left that (other Left) :>
16:23:43 <BONUS_> >do {a <- Right "x"; b <- Left "crash"; Right $ a++"500"}
16:24:15 <adu> > do x <- lookup 2 [(2,"dlrow olleh")] ; return (reverse x)
16:24:16 <lambdabot>   Just "hello world"
16:25:01 <adu> > do x <- lookup 3 [(2,"dlrow olleh")] ; return (reverse x)
16:25:02 <lambdabot>   Nothing
16:25:09 <adu> hmm
16:25:54 <adu> other left?
16:26:11 <paczesiowa> adu: try writing instance Monad (Either a)
16:26:18 <adu> ok
16:26:56 <paczesiowa> adu: or read http://ro-che.blogspot.com/2008/09/haskell-puzzle-either-monad.html
16:26:58 <lambdabot> Title: Roman Cheplyaka: Haskell puzzle: Either monad, http://tinyurl.com/4ak46p
16:28:34 <dan> dfsd
16:29:31 <adu> paczesiowa: ok http://hpaste.org/10992
16:29:38 <adu> paczesiowa: now what?
16:30:11 <adu> oops forgot fail
16:30:34 <BONUS_> er
16:30:38 <BONUS_> its not Right (f ob)
16:30:47 <BONUS_> remember, f already returns a type of Either a b
16:31:20 <adu> BONUS_: oh, right, oops
16:31:21 <adu> i was so close
16:31:27 <BONUS_> haha
16:31:48 <paczesiowa> adu: usually people write Left err -> m, which doesn't work (you have to return same err but different Left)
16:33:07 <BONUS_> if you use the m and the m is, say, Either a b, then the typechecker thinks the resulting Left has to be Either a b but it can be Either a c
16:33:13 <adu> paczesiowa: why would you want to do that?
16:33:20 <BONUS_> yeah, that's why you have to recreate it
16:33:28 <BONUS_> well it would seem easier to write Left _ ->
16:33:30 <BONUS_> well it would seem easier to write Left _ -> m
16:34:04 <paczesiowa> adu: it would save memory (and char count) and it looks better
16:34:13 <adu> oh ok
16:34:26 <paczesiowa> adu: but it would be wrong:>
16:34:53 <adu> wrong?
16:35:23 <paczesiowa> adu: try it, it doesn't typecheck
16:38:03 <adu> what do you mean it doesn't typecheck
16:38:08 <adu> it compiles fine
16:39:21 <BONUS_> if you use Left _ -> m ?
16:39:23 <adu> aside from the Right (f ob) my first attempt was pretty good
16:39:32 <adu> BONUS_: no I use Left err -> Left err
16:39:49 <BONUS_> yeah, that's the correct
16:39:51 <BONUS_> version
16:40:03 <BONUS_> however, doing Left _ -> m won't work
16:40:15 <adu> because of the a/b type variables?
16:40:37 <BONUS_> yeah
16:41:17 <BONUS_> even though the type of the value if it was a Right doesn't matter, if you just use the same variable, it can't make the Right be a type of something else
16:45:01 <TomMD> Huh wha,  Coutts is in Portland?  Must get to Portland!  Missing valuable tech talks!
16:45:34 <ozy`> wow, cabal install was only released this summer?
16:46:36 <adu> ooo is there a maybeToEither function
16:46:36 <adu> ?
16:46:52 <TomMD> @hoogle maybeToEither
16:46:52 <lambdabot> No results found
16:47:01 <TomMD> @hoogle Maybe a -> Either s a
16:47:01 <lambdabot> Prelude Right :: b -> Either a b
16:47:02 <lambdabot> Data.Either Right :: b -> Either a b
16:47:02 <lambdabot> Prelude Left :: a -> Either a b
16:47:39 <BONUS_> but what would maybeToEither Nothing produce?
16:47:50 <adu> how do I simplify this: http://hpaste.org/10993
16:48:18 <TomMD> @let maybeToEither e j = if j == Nothing then (Left e) else (Right $ fromJust j)
16:48:19 <lambdabot>  Defined.
16:48:23 <paczesiowa> adu: the real problem is that some things return Maybe instead of failing in MonadError with noMsg
16:48:47 <paczesiowa> :t noMsg
16:48:47 <lambdabot> forall a. (Error a) => a
16:48:52 <adu> so I should write my own?
16:49:11 <adu> the only thing I'm going to be using alot is lookup, so maybe I could write a lookupEither function
16:50:04 <paczesiowa> adu: write lookupError :: (MonadError e m, Error e) => [(a,b)] -> a -> m b
16:50:14 <twb> Does haskell have a shell scripting EDSL analogous to scsh?
16:50:22 <paczesiowa> twb: hash
16:50:48 <adu> no code?
16:51:12 <desp> paczesiowa: ;)
16:51:29 <paczesiowa> desp: ?
16:51:43 <twb> I want to be able to write stuff like: map (pipe) [["ls"],["wc"],["cut","d ","-f1"]]
16:51:49 <twb> Er, not map, fold
16:52:20 <adu> twb: you know, haskell has: system, runProcess, etc...
16:52:45 <adu> twb: you could probably whip up something really quickly with TemplateHaskell
16:52:48 <twb> adu: the important thing is to be able to easily create pipelines of processes without fucking about with dup(2).
16:52:58 <twb> adu: I don't want to have to write and maintain the library myself
16:53:23 <paczesiowa> twb: there is error in ghc runtime that prevents those pipes
16:53:32 <twb> (Also important is the ability to detect the failure of a subprocess and propagate that upwards into an exception)
16:53:35 <Jedai> adu: maybe (fail "The error) return
16:53:38 <twb> paczesiowa: bummer.
16:53:43 <Jedai> @type maybe (fail "The error) return
16:53:44 <lambdabot> lexical error in string/character literal at end of input
16:53:49 <Jedai> @type maybe (fail "The error") return
16:53:50 <lambdabot> forall (m :: * -> *) a. (Monad m) => Maybe a -> m a
16:53:58 <adu> cool
16:54:05 <paczesiowa> Jedai: don't use fail, use throwError
16:54:20 <adu> paczesiowa: will that go into the Left constructor?
16:54:29 <Jedai> paczesiowa: Yes, you're probably right, Monad is too general
16:54:46 <Jedai> @type maybe (throwError "The error") return
16:54:47 <lambdabot> forall (m :: * -> *) a. (MonadError [Char] m) => Maybe a -> m a
16:55:01 <paczesiowa> adu: yes, Either e is MonadError for Error e
16:55:02 <adu> Jedai: will that put the error in Left?
16:55:09 <adu> o ok
16:55:19 <Jedai> adu: If you ask Either from it it will
16:55:23 <BONUS_> @let lookupError x xs = case lookup x xs of {Nothing -> fail (strMsg "failed"); (Just x) -> return x}
16:55:24 <lambdabot>  Defined.
16:55:41 <Jedai> adu: In others MonadError instances it may do something different
16:55:48 <BONUS_> > lookupError 2 [(2,4),(6,9)] :: Either String Int
16:55:49 <lambdabot>   Right 4
16:55:54 <BONUS_> > lookupError 100 [(2,4),(6,9)] :: Either String Int
16:55:56 <lambdabot>   Left "failed"
16:56:22 <adu> twb: this is how I would do it in haskell: write a [sh| ... |] parser, and a $(pipe ...) builder
16:57:19 <gnuvince_> Does anyone have the link where SPJ got an email from one of the Great Computer Language Shootout guy saying that if they let Haskell be non-strict, it beats the competition?
16:57:38 <BONUS_> what do you mean if they let it be non strict
16:57:44 <twb> adu: if I have to write a library to do it, then that's more yak shaving than I can cope with.
16:58:02 <gnuvince_> BONUS_: they add strictness annotation everywhere to be fair to other languages.
16:58:10 <Jedai> twb: You could look at HSH, it probably have everything you want
16:58:13 <BONUS_> really? lol, lame
16:58:17 <BONUS_> what the heck
16:58:33 <BONUS_> why not then just add a couple of unnecessary nested loops in C to make it slower
16:58:37 <BONUS_> so it's fair to other languages
16:59:08 <twb> Basically I have an existing 1000-line scsh script that's unmaintainable because nobody in the company can speak scsh, and scsh isn't actively maintained
16:59:25 <twb> So moving to a mainstream language like Haskell or CL would be nice.
16:59:47 <twb> HSH sounds promising, /me reads on
17:00:06 <adu> wow HSH is fascinating
17:00:19 <gnuvince_> So nobody got that link anymore?
17:00:28 <paczesiowa> twb: oh yeah, I meant hsh not hash, sorry
17:00:36 <TomMD> gnuvince_: It was sent to the ML perhaps six months ago.
17:00:38 <Jedai> BONUS_: Well no, it makes sense really, since the bench is an artificial program, some of them try to measure the construction time of some data structure that isn't used then.... It's only fair to force the construction in Haskell, if not the bench doesn't make any sense anymore
17:00:50 <gnuvince_> TomMD: yeah, I can't remember the title.
17:01:13 <TomMD> gnuvince_: If you can find the name of the guy who runs the shootout, search for that.
17:01:44 <BONUS_> hmmm, interesting
17:01:59 <adu> gnuvince_: http://markmail.org/message/2aq42qlmdtu5lyp2
17:02:00 <lambdabot> Title: [Haskell] [Fwd: Re: Computer Language Shootout] - Brent Fulgham - org.haskell.ha ...
17:02:06 <Jedai> I don't think they enforce this in every bench though, most of them are specified in terms of result printed out, not of work done in the program (not too much anyway)
17:02:10 <paczesiowa> Baughn: do you remember that pipe bug we (well, you) reported?
17:02:51 <paczesiowa> @seen Baughn
17:02:51 <lambdabot> Baughn is in #math, #haskell and #ghc. I last heard Baughn speak 1d 7h 19m 34s ago.
17:03:41 <gnuvince_> Got it: http://groups.google.com/group/fa.haskell/browse_thread/thread/2d02f2d0976a7e6d/917f9812d5b61319?lnk=gst&q=shootout#917f9812d5b61319
17:03:44 <lambdabot> Title: Comments from Brent Fulgham on Haskell and the shootout - fa.haskell | Google Gr ..., http://tinyurl.com/3v7olf
17:03:57 * sw17ch wonders if any one would object to using JSON as a config file format...
17:06:00 <rwbarton> on that note, anyone know about tools for automatically deriving JSON instances?
17:06:54 <dancor> how do i see >>= for List
17:07:15 <paczesiowa> @src (>>=) List
17:07:16 <lambdabot> Source not found. I am sorry.
17:07:18 <paczesiowa> @src (>>=) []
17:07:19 <lambdabot> Source not found. It can only be attributed to human error.
17:07:19 <rwbarton> @src [] (>>=)
17:07:19 <lambdabot> xs >>= f     = concatMap f xs
17:08:28 <dancor> Monad's seem to encapsulate notions of: actions, sequencing, and failure.
17:08:34 <dancor> what is the "action" of the List Monad
17:08:46 <BONUS_> they can also encapsulate values
17:09:05 <BONUS_> for instance, a Maybe monad can hold no value or one value
17:09:20 <BONUS_> a list can hold no value or several values
17:09:26 <ddarius> dancor: Monads encapsulate "effects," [] corresponds to non-determinism.
17:09:39 <dancor> is there a connection between Maybe/List encapsulating values and IO doing irl-actions
17:09:42 <dancor> ok, both effects..
17:09:43 <BONUS_> Just 8, the value is 8
17:09:50 <BONUS_> but when you do
17:09:53 <BONUS_> a <- [1..10]
17:10:00 <BONUS_> you can think of a as being a superposition of all those values
17:10:24 <ddarius> Actually, [] is a pretty crappy, but still handy way of representing non-determinism.
17:10:27 <dancor> i understand the List Monad, but i get fuzzy when i try to compare it with the IO Monad
17:11:12 <paczesiowa> how about ListT IO?
17:11:13 <BONUS_> you could say that the IO monad also holds a value
17:11:17 <BONUS_> only that value is an action
17:11:49 <ddarius> This "holding a value" nonsense is pointless, in my opinion.
17:11:59 <dancor> i guess "effect" is a good term for both..
17:13:03 <BONUS_> but wouldn't you say that Just 10 holds some value inside itself?
17:13:25 <dancor> what is the "effect" in the Maybe Monad
17:13:49 <dancor> it seems like the most minimal one
17:13:58 <ddarius> That's fine but that doesn't make much sense for an arbitrary monad.  It doesn't even make a ton of sense for Maybe, what value does Nothing hold?
17:14:01 <paczesiowa> reduce of stairway to heaven
17:14:03 <dancor> where there is no effect other than being and not having failed
17:14:07 <ddarius> dancor: A potentially failing computation.
17:14:09 <dancor> (become Nothing)
17:14:12 <dancor> ya
17:14:22 <dancor> but all Monad's have failure separately
17:14:29 <dancor> from having sequenceability
17:14:37 <ddarius> dancor: No they don't.
17:14:42 <dancor> both properties of their "effects"
17:14:45 <dancor> no?
17:14:47 <ddarius> Many monads have no notion of "failure"
17:14:52 <paczesiowa> Id doesn't
17:14:56 <ddarius> E.g. State, or Reader, or Writer, or Id
17:15:00 <dancor> what is fail in those cases
17:15:03 <ddarius> error
17:15:04 <paczesiowa> error
17:15:11 <dancor> so they do have failure :)
17:15:23 <ddarius> No, error "foo" is bottom.
17:15:39 <dancor> IO has the same error as Id, State, etc
17:15:47 <ddarius> dancor: No it does not.
17:16:02 <ddarius> fail for IO is throwIOError (or whatever) which is a catchable exception.
17:16:10 <ddarius> error corresponds to the computation "getting stuck"
17:16:19 <paczesiowa> error is catchable too
17:16:25 <ddarius> paczesiowa: Not in H98.
17:17:09 <paczesiowa> ddarius: well if you care about quality of code (you care about portability) then you don't use error
17:17:38 <ddarius> paczesiowa: error is fine, but it should only be used for something that "should never happen"
17:18:00 <ddarius> If you want catchable exceptions, throw exceptions.
17:18:37 <paczesiowa> ddarius: if I want exceptions I use MonadError, not ugly IO
17:18:47 <ddarius> paczesiowa: I agree.
17:18:55 <ddarius> Of course, IO is an instance of MonadError
17:19:06 <paczesiowa> but I prefer ErrorT IO
17:19:17 <paczesiowa> I love purity
17:19:24 <ddarius> Then why do you have the IO?
17:19:43 <paczesiowa> for IO:>
17:19:53 <paczesiowa> input and output, not error handling
17:20:07 <ddarius> paczesiowa: Make a newtype wrapper for it.
17:20:20 <paczesiowa> ddarius: for what?
17:20:35 <ddarius> newtype FileIO a = FileIO { runFileIO :: IO a }
17:20:51 <paczesiowa> and then wrap every readFile?
17:21:12 <ddarius> Sure.  Then you can reify any exceptions into your ErrorT values as well.
17:21:42 <ddarius> If all you're using IO for is I/O, then make a type that states that.
17:21:49 <paczesiowa> would be easier to hide instance ErrorMonad IO
17:22:04 <paczesiowa> but it sounds interesting
17:22:48 <ddarius> Hiding something, doesn't stop someone else from using ioError.  If you wrap it then you can stop that and you don't have to worry about (IO) exceptions.
17:23:57 <Saizan> or use catch in your liftIO?
17:24:21 <paczesiowa> seems like a nice idea, but it would be painful to do that. it would be great if it was common practice
17:24:39 <ddarius> It may become that way in the future.  That's what a lot of people are hoping for.
17:25:02 <paczesiowa> catch sucks. you have no assurance from type system that you caught anything
17:25:21 <paczesiowa> checked exceptions would be great
17:25:25 <dancor> doesn't the fact that List stays ordered in a certain way somewhat compromised the idea that it is nondeterministic computation
17:25:54 <dmwit> no
17:26:09 <BONUS_> just because it's nondeterministic doesn't mean it has to be randomly ordered or anything
17:26:21 <ddarius> dancor: It corresponds to a specific backtracking strategy (actually one very similar to Prolog's)
17:26:22 <dancor> > liftM2 (+) [2,3] [100,200,300]
17:26:23 <lambdabot>   [102,202,302,103,203,303]
17:26:30 <dancor> ya
17:27:03 <ddarius> I prefer the Tree monad which let's you search the tree however you like.
17:27:04 <dancor> it's not "just" ND in that way
17:27:14 <mmorrow> <paczesiowa> and then wrap every readFile?
17:27:35 <mmorrow> no, you'd make a module which hides the FileIO constructor
17:27:52 <mmorrow> and exports a function readFileIO
17:27:54 <adu> ddarius: I want something like that
17:28:03 <mmorrow> :: FilePath -> FileIO String
17:28:18 <paczesiowa> mmorrow: and I do that for whole gtk too?
17:28:29 <mmorrow> heh, tis the rub
17:28:35 <ddarius> It's trivial to write: data NonDetX = Fail | Amb x x; type NonDet = FreeMonad NonDetX
17:28:54 <ddarius> paczesiowa: Of course not.  Those go in the GUI monad.
17:28:55 <mmorrow> ioToFileIO :: IO a -> FileIO a
17:29:05 <mmorrow> fileIOToIO :: FileIO a -> IO a
17:29:18 <mmorrow> ioToFileIO = FileIO
17:29:25 <dancor> @src [] fail
17:29:26 <lambdabot> fail _      = []
17:29:28 <mmorrow> fileIOToIO = unFileIO
17:30:11 <paczesiowa> ddarius: sound like too much work to do, when essentially all I code are tools to help download pr0n
17:31:15 <mmorrow> paczesiowa: i also just jumped in, i haven't been following the discussion so i'm not sure if it's doable in your case of course :)
17:31:16 <ddarius> paczesiowa: Yeah, you adjust how you program to your needs.
17:33:38 <adu> HSH doesn't have ls...
17:34:28 <paczesiowa> adu: I think there is chapter on shell tools in rwh, maybe there is some extra code
17:34:58 * adu <3 RWH
17:35:14 <mmorrow> i hpasted FileIO because i think it's a nice example of something or other http://hpaste.org/10995
17:36:01 <Saizan> if you export ioToFileIO there's not much point in it
17:36:56 <mmorrow> paczesiowa: writing a gtk app just do dl pr0n seems like a lot of work just to dl dr0n ;)
17:37:26 <paczesiowa> depends on amounts of pr0n:>
17:37:27 <mmorrow> (pretend all the mistyped keys aren't there)
17:38:04 <mmorrow> paczesiowa: i bet using FileIO would make the pr0n downloads 2-4x faster
17:39:12 <paczesiowa> it's not speed I want, it's quality:)
17:39:43 <paczesiowa> and quality starts with quality of code of downloading tools
17:40:14 <dblazakis> @src Maybe fmap
17:40:15 <lambdabot> fmap _ Nothing       = Nothing
17:40:15 <lambdabot> fmap f (Just a)      = Just (f a)
17:40:23 <mmorrow> Saizan: you'd have to though, unless you can manage to write every function for file io a user of the lib would ever need, provide some other way to convert IO functions to FileIOs, or just restrict file io to whatever you export and not care about file io behind your back in IO
17:45:07 <Saizan> the first one is the only reasonable choice :) but we have unsafePerformIO, so..
17:49:11 <newsham> peaker: here?
17:49:25 * BMeph likes that spicy red sauce with a sweet juicy pr0n...
17:49:31 <Peaker> newsham: yeah. Sounds interesting. Its almost 3 am though, I'm falling asleep :) I'll look at it tomorrow
17:49:42 <newsham> peaker: no problem.
17:55:08 <newsham> what's a good example of imperative EDSL (ie (:=) / IORef type stuff) in haskell?
17:55:25 <newsham> I know i've seen a few that were somewhat slick before but dont remember how to find them
17:56:39 <dmwit> ?go sigfpe c in haskell
17:56:41 <lambdabot> http://sigfpe.blogspot.com/2007/05/haskell-incarnate.html
17:56:42 <lambdabot> Title: A Neighborhood of Infinity: Haskell Incarnate
17:57:13 <BMeph> newsh: HOpenGL, maybe? :)
17:57:35 <paczesiowa> newsham: lennart augustson (not sure with spelling) had some c-like dsl
17:57:44 * BMeph dislikes being "a dumb intellectual"...
17:58:47 <hackage> Uploaded to hackage: data-ivar 0.11
17:58:47 <hackage> Uploaded to hackage: data-ivar 0.1
17:58:47 <hackage> Uploaded to hackage: CheatSheet 1.0
17:59:05 <newsham> http://augustss.blogspot.com/2007/08/programming-in-c-ummm-haskell-heres.html
17:59:06 <newsham> danke
17:59:06 <lambdabot> Title: Things that amuse me, http://tinyurl.com/2948p6
18:00:07 <dmwit> Ah, I had the wrong Big Name.
18:10:53 <enderbean> Hello.
18:11:37 <BMeph> enderbean: Howdy! :)
18:11:55 <enderbean> I'm trying to write a program using wxHaskell. I'm having trouble with an event handler. Things don't seem to be executing in the order I expect them too.
18:12:02 <enderbean> :)
18:14:16 <thoughtpolice> @seen sbahara
18:14:17 <lambdabot> I haven't seen sbahara.
18:14:17 <enderbean> Its a textCtrl, the first thing I do in the event is to call propagateEvent, which should update the text with the key that was pressed, then I txt <- get t text; But txt seems to contain what was in there _before_ the key event.
18:14:28 <thoughtpolice> @seen sbahra
18:14:28 <lambdabot> sbahra is in ##logic, #ghc, #haskell, ##freebsd and #haskell-blah. I last heard sbahra speak 2h 12m 49s ago.
18:20:03 <sbahra> thoughtpolice, oi
18:20:22 <thoughtpolice> sbahra: happen to have ghc-6.10 on your 8core machine?
18:20:59 <sbahra> let me see
18:21:11 <thoughtpolice> i want someone to try this: http://haskell.org/haskellwiki/Shootout/Parallel/BinaryTreesDPH
18:21:13 <lambdabot> Title: Shootout/Parallel/BinaryTreesDPH - HaskellWiki
18:21:37 <sbahra> hm
18:22:40 <sbahra> thoughtpolice, apparently, not now?
18:22:45 <sbahra> Let me see what's up.
18:22:53 <thoughtpolice> sbahra: it's cool. i just ran it on my dual core
18:23:03 <thoughtpolice> want to see if it'll get a bunch of cores nicely :]
18:23:18 <thoughtpolice> cpu usage and time is pretty good
18:23:23 <thoughtpolice> still behind parallel strategies
18:23:32 <thoughtpolice> might be missing an optimization opportunity or two i think
18:26:20 <sbahra> master node is dealing with some other things now, thoughtpolice
18:26:46 <thoughtpolice> yeah it's fine
18:26:48 <sbahra> i have access to another machine, 8 cores.
18:26:51 <sbahra> Intel.
18:26:54 <Nafai> Any gtk2hs hackers around?
18:27:08 <thoughtpolice> sbahra: i'm thinking of moving a few of the parallel strategies versions over to DPH
18:27:11 <Nafai> I'm trying to figure out how to programmatically select an item in a treeview
18:27:18 <sbahra> DPH seems to me like meh
18:27:34 <sbahra> But that's probably because I don't know much about it :)
18:34:58 <paczesiowa> @src ErrorT
18:34:58 <lambdabot> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
18:35:14 <dolio> Nuh uh. DPH is going to solve all multi-core problems ever! :)
18:35:28 <thoughtpolice> it's fun to play with, at least
18:35:45 <Peaker> @kind ErrorT
18:35:46 <lambdabot> * -> (* -> *) -> * -> *
18:36:04 * dolio doesn't even have a multi-processor machine to play with. :(
18:38:52 <yitz> Nafai, I'm not a gtk2hs hacker, but I'm also interested in that question.
18:39:03 <yitz> Nafai: have you tried anything yet?
18:39:40 <Nafai> yitz: I'm trying out treeSelectionSelectPath
18:39:46 <Nafai> Just figuring out how to construct a TreePath
18:41:51 <paczesiowa> isn't that [Int]?
18:41:55 <Nafai> Since TreePath is just a type that seems to be an alias of a list of Ints, I'm trhying to figure it out
18:42:18 <Nafai> Let me show you the error I'm getting
18:42:23 <Nafai> I'm still a Haskell Newbie
18:42:30 <paczesiowa> I think you should query model for path to that elem and you'll get what you want
18:43:06 <Nafai> http://hpaste.org/10997
18:43:23 <Nafai> I just want to set it to the first one
18:43:33 <luqui> that GpuGen thing looks sweeet
18:44:44 <Nafai> Oh
18:44:46 <Nafai> D'oh
18:44:47 <paczesiowa> hpaste died?
18:44:49 <Nafai> n/m I figured it out :)
18:45:21 <paczesiowa> no do?
18:45:51 <cjs> What's a nice format for multi-line function signatures?
18:46:41 <paczesiowa> haskell-mode does smth nice
18:46:46 <dolio> Break at functions, line -> up with ::?
18:46:46 <Nafai> http://hpaste.org/10997#a1
18:46:57 <paczesiowa> @src ErrorT
18:46:57 <lambdabot> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
18:48:01 <yitz> Nafai: treeViewSetCursor?
18:48:01 <cjs> You mean with -> directly underneath the ::? Yeah, I'm trying that now. Seems ok. What does haskell-mode do? (I don't have emacs installed.)
18:48:27 <dolio> Yeah, that'd be my recommendation.
18:48:49 <dolio> Similar to writing bracketing in do blocks with prefixed semicolons aligned with the brackets.
18:49:21 <sbahra> dolio, :(
18:49:23 <cjs> Ewww, I've always hated that. Though not the formatting, just having brackets and semicolons.
18:49:25 <Nafai> yitz: My annotated code works
18:49:31 <sbahra> dolio, I could give you a shell on a 2xUltraSparc III.
18:49:32 <paczesiowa> cjs: http://hpaste.org/10998
18:49:45 <sbahra> dolio, with root access if you could get cabal working properly on it :-
18:49:56 <cjs> I apply Edward Tufte to code, as well.
18:50:01 <yitz> Nafai - good! Wow, this is complicated.
18:50:34 <dolio> Heh.
18:52:27 <sbahra> ;[
18:52:50 <Nafai> yitz: Yeah, a wee bit :(
18:52:53 <dolio> I guess cabal doesn't have a lot of users on such machines?
18:53:33 <adu> I have a connundrum
18:53:51 <adu> Its like the chicken and the egg with new language implementations
18:54:15 <adu> I can't implement it without a clear definition, but I can't define it clearly without experimenting with the implementation... :(
18:54:23 <sbahra> dolio, apparently not. But Sun is sponsoring someone to improve parallelism on their barrel processors (sun4v). This will mean that a proper backend needs to be implemented for it. :-P
18:54:44 <dolio> Oh, right. I remember hearing about that.
18:55:22 <yitz> adu: so just do it. then fix it later.
18:55:48 <adu> yitz: YA, thats the spirit!
18:56:06 <adu> perfect = fix eggProblem
18:56:35 <adu> or fixIO...
18:57:20 <yitz> > let eggProblem = ("Yolk":) in fix eggProblem
18:57:21 <lambdabot>   ["Yolk","Yolk","Yolk","Yolk","Yolk","Yolk","Yolk","Yolk","Yolk","Yolk","Yol...
18:57:43 <adu> that's perfect!
18:58:20 <cjs> It's iterative.
19:00:40 <paczesiowa> I hate fixing code until it typechecks and then not knowing what it does...
19:03:37 <geezusfreeek> yeah that happens to me sometimes too
19:04:03 <geezusfreeek> usually enough quickchecking makes me feel a little better, but i always end up rewriting anyway
19:04:24 * geezusfreeek is trying out smallcheck right now
19:04:58 <paczesiowa> but I don't know what it does and what it should do (I was typechecking so hard I forget what for)
19:05:04 <geezusfreeek> yeah
19:05:09 <geezusfreeek> it sucks
19:05:36 <paczesiowa> so I don't have to quickcheck it because it works:>
19:05:52 <rwbarton> Why is there an instance (Data a, Data b) => Data (a -> b)?
19:06:06 <geezusfreeek> i have written deep nestings of Data.Foldable.sequence to get my functors where i wanted them and then realized that it does different things depending on the order i nest them
19:06:09 <paczesiowa> @src Dat
19:06:10 <lambdabot> Source not found. stty: unknown mode: doofus
19:06:11 <paczesiowa> @src Data
19:06:11 <lambdabot> Source not found. Wrong!  You cheating scum!
19:06:19 <Nafai> Eek
19:06:28 <Nafai> Getting the selection seems even more complicated
19:06:51 <paczesiowa> Nafai: I have that code somewhere, wait
19:07:58 <Nafai> Thanks
19:08:25 <paczesiowa> ok hpaste
19:08:53 <paczesiowa> http://hpaste.org/10999
19:09:28 <paczesiowa> plus selection <- MV.treeViewGetSelection view
19:09:44 <Nafai> So what is widget in this code?
19:09:59 <paczesiowa> my model was Tree of widgets
19:10:16 <Nafai> My model is a list of strings
19:10:32 <mmorrow> @tell luqui that earlier thing about the TVars/etc gave me some ideas http://moonpatio.com/code/repos/proc/
19:10:32 <lambdabot> Consider it noted.
19:11:09 <paczesiowa> Nafai: so substiture str for widget and print it or smth
19:11:10 <mmorrow> this pkg uses a GADT and excessive forkIO http://moonpatio.com/code/repos/proc/  :)
19:11:11 <lambdabot> Title: Index of /code/repos/proc
19:11:33 <mmorrow> (excessive in a good way though ;)
19:11:41 <Nafai> Hrm
19:12:04 <Nafai> So this function is called whenever something is selected?
19:12:05 <luqui> mmorrow, I see you only traverse the GADT in one place.  Why not replace its representation with its traversal?
19:12:05 <lambdabot> luqui: You have 1 new message. '/msg lambdabot @messages' to read it.
19:12:12 <paczesiowa> yes
19:12:42 <mmorrow> luqui: err, have you looked at the code yet? i'm not sure how you mean
19:12:51 <paczesiowa> Nafai: selected or deselected, I think there are different modes, I chose browse mode or smth
19:13:06 <luqui> yeah I haven't, I just saw that red flag ;-)
19:13:33 <mmorrow> luqui: hehe, every subproc gets its own rts thread
19:13:35 * Nafai nods
19:14:19 <mmorrow> luqui: but that's not to say i don't have plenty i want to add/improve ;)
19:14:20 <luqui> concurrent combinators is a neat idea... I think.
19:14:46 <luqui> my earlier concern was:  is there anything stopping you from using this representation:  type Proc a b = a -> IO b
19:14:49 <mmorrow> luqui: i'm thinking something like a shell pipeline, but instead of a /line/, it's a graph
19:15:05 <luqui> well, a tree, afaict
19:15:23 <mmorrow> the GADT is the only way to type the combinations of subprocs
19:15:51 <luqui> I don't follow.  example?
19:15:58 <luqui> or point me to the place you're talking about?
19:16:48 <paczesiowa> Nafai: if you have problems, there are examples in gtk2hs tarball for listviews
19:16:49 <mmorrow> have you seen the standard GADT eval function example?
19:16:57 <Nafai> paczesiowa: Thanks
19:17:10 <mmorrow> err, ok i just thpought of a good way to say it
19:17:51 <mmorrow> a Proc [a] [b] is /not/ a ([a] -> IO [b])
19:18:02 <mmorrow> but contains a [Proc a b]
19:18:05 <mmorrow> likewise
19:18:16 <luqui> mmorrow, aha!  there it is.
19:18:28 <luqui> okay :-)
19:18:29 <mmorrow> heh. GADTs are cool
19:19:40 <mmorrow> they let you abstract away the contents, and label them with the type they'll "eventually become" after eval
19:20:49 <mmorrow> (:|||) races the two procs in parallel, and returns the result of the first one to finish
19:21:17 <mmorrow> List :: [Proc a b] -> Proc [a] [b] runs the entire list in par, and returns the results lazily
19:21:53 <mmorrow> (List makes use of a similar func to readyChan, from our earlier discussion)
19:22:23 <mmorrow> ((:|||)  kills the thread of the loser)
19:25:20 <mmorrow> luqui: yeah, that's /technically/ true that it's a tree, but since i'm in IO the subprocs can arbitrarily communicate and recover graphness
19:26:46 <Nafai> Now I need to figure out how to keep track of my model :(
19:28:28 <paczesiowa> Nafai: create it with empty list of strings and only interact with that list through model operations
19:28:50 <paczesiowa> Nafai: add elem = read model >>= write model
19:29:51 <Nafai> Here's what I'm currently doing: http://github.com/Nafai77/utilities/tree/master/src/gtkmenu.hs
19:29:53 <lambdabot> Title: src/gtkmenu.hs at master from Nafai77's utilities — GitHub
19:30:07 <Nafai> The problem is in windowKeyPressHandler
19:30:21 <Nafai> Wait
19:30:21 <Nafai> n/m
19:30:22 <Nafai> :)
19:30:51 <paczesiowa> oh, you call your model store
19:31:03 <Nafai> Yeah
19:31:09 <Nafai> Though that code doesn't quite work
19:32:26 <Nafai> http://hpaste.org/11000
19:35:11 <paczesiowa> that doesn't even compile
19:35:23 <Nafai> Let me update it real quick
19:35:51 <Nafai> Okay, refresh and that compiles
19:36:39 <paczesiowa> how do I wget that?
19:37:06 <Nafai> http://github.com/Nafai77/utilities/tree/master%2Fsrc%2Fgtkmenu.hs?raw=true
19:37:09 <lambdabot> http://tinyurl.com/446yf7
19:37:38 <Nafai> I think the problem is that I'm not updating the model reference in my MenuGUI type
19:39:17 <Nafai> I'm learning how to structure Haskell programs, so there's probably something I'm missing
19:39:22 <paczesiowa> what are you trying to do anyway?
19:40:00 <Nafai> In general with the program?
19:40:47 <paczesiowa> what do you want to happen when smth is selected
19:41:29 <Nafai> It takes a list from stdin and displays that in a treelist.  As the user types in the entry, it narrows down the list in the treelist to the entries that match the sublist.  When the user presses enter, I want to print the entry the cursor is on (if an item is selected) to stdout and then exit
19:41:48 <Nafai> So I don't care about when it is selected, just what is selected when the user hits enter
19:41:52 <sbahra> So today in class, my professor asks of us to write some pseudo-code for an algorithm...so I implement it in haskell and he says, "That's ugly pseudo-code, it has to be well-structured".
19:41:59 <sbahra> Academia@USA + 1 :-(
19:43:04 <Nafai> sbahra: :(
19:43:09 <ddarius> Perhaps your Haskell was ugly.  Perhaps your professor considers actual code, "ugly" pseudocode since it is not pseudocode.
19:43:45 <sbahra> For an algorithm that trivial, it was impossible for it to be ugly. :-)
19:44:01 <sbahra> Perhaps his name should return some result on google.com/codesearch. :-P
19:48:46 <Nafai> So close :(
19:49:50 <paczesiowa> Nafai: that looks like gtk error
19:50:08 <paczesiowa> Nafai: you have to read gtk docs
19:50:11 <Nafai> I think the problem is the model is no longer valid
19:50:34 <paczesiowa> I don't think it can be invalid
19:50:51 <Nafai> Ok
19:51:29 <paczesiowa> Nafai: you can also check http://scentric.net/tutorial/
19:51:34 <lambdabot> Title: GTK+ 2.0 Tree View Tutorial
19:51:39 <Nafai> Thanks
19:51:44 <paczesiowa> not haskell, but I learned a bit from it
19:52:10 <newsham> [16:40] < sbahra> For an algorithm that trivial, it was impossible for it to be ugly. :-)
19:52:21 <newsham> I'd mark you down just for saying that ;-)
19:53:24 <pastorn> @src guard
19:53:24 <lambdabot> guard True  =  return ()
19:53:24 <lambdabot> guard False =  mzero
19:53:44 <newsham> ?src Maybe mzero
19:53:44 <lambdabot> mzero = Nothing
19:54:14 <mmorrow> , src 'mzero
19:54:26 <lunabot>  Class op from MonadPlus: mzero :: forall m . MonadPlus m => forall a . m a
19:54:40 <pastorn> @src when
19:54:40 <lambdabot> when p s = if p then s else return ()
19:54:42 <mmorrow> ugh. i forgot to make class methods pretty
19:54:44 <pastorn> @src unless
19:54:45 <lambdabot> unless p s = if p then return () else s
19:55:08 <Cale> http://www.youtube.com/watch?v=DMSPS6us__Y -- moar coequalisers :)
19:55:09 <lambdabot> Title: YouTube - Coequalisers 2
19:55:09 <mmorrow> , src 'unless
19:55:14 <lunabot>  unless :: forall m . Monad m => Bool -> m () -> m ()
19:55:36 <adu> I actually perfer whenIO and unlessIO
19:56:01 <newsham> ?type whenIO
19:56:02 <lambdabot> Not in scope: `whenIO'
19:56:12 <adu> whenIO pf s = do p <- pf ; when p s
19:56:28 <newsham> why is that when"IO"?
19:56:44 <adu> cuz I only use it with IO
19:56:57 <adu> it could be when'
19:57:07 <newsham> pf >>= flip when s
19:57:09 <ddarius> whenM
19:57:32 <pastorn> @src mapAndUnzipM
19:57:32 <lambdabot> mapAndUnzipM f xs = sequence (map f xs) >>= return . unzip
19:57:41 <pastorn> cool
19:57:52 * pastorn is reading all about monads...
19:57:54 <newsham> ?src mapM
19:57:54 <lambdabot> mapM f as = sequence (map f as)
19:57:57 <ddarius> unzip <$> mapM f xs
19:58:12 <adu> pastorn: monads are cool
19:58:19 <pastorn> adu: indeed
19:58:29 <mmorrow> too bad they don't compose :(
19:58:41 <ddarius> Who the heck decided to make a "mapAndUnzipM" function?
19:58:55 <mmorrow> probably someone named "Andy"
19:58:59 <pastorn> heh
19:59:09 <adu> hmm... i'm andy
19:59:17 <mmorrow> it's adu's fault!!
19:59:27 <mmorrow> :)
19:59:33 <adu> i didn't do it!
19:59:50 <pastorn> aren't functions like that (:: a -> m (b,c)) good for debugging?
19:59:59 <sbahra> newsham, you actually have a clue, I would assume you have a decent argument for why it is ugly :-P
20:00:15 <adu> @pl (\pf s -> do p <- pf ; when p s)
20:00:16 <lambdabot> (line 1, column 22):
20:00:16 <lambdabot> unexpected ";"
20:00:16 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or ")"
20:00:30 <newsham> sbahra: hmm.. lets not go to far.
20:00:36 <pastorn>  @pl (\pf s -> do { p <- pf ; when p s} )
20:00:45 <pastorn> @pl (\pf s -> do { p <- pf ; when p s} )
20:00:45 <lambdabot> (line 1, column 14):
20:00:45 <lambdabot> unexpected "{"
20:00:45 <lambdabot> expecting variable, "(", operator or ")"
20:00:48 <ddarius> @. pl undo \pf s -> do p <- pf; when p s
20:00:48 <lambdabot> (. flip when) . (>>=)
20:00:58 <dolio> ddarius: You don't use that all the time?
20:01:18 <pastorn> @pl (\pf s -> pf >>= \p -> when p s)
20:01:18 <lambdabot> (. flip when) . (>>=)
20:01:20 <sbahra> newsham, when I was giving some presentation on overwriting GOT (among many other things), this person spent > 15 minutes trying to convince me that modifying GOT for 1 process affects others (and didn't think CoW was associated at all with buffer cache).
20:01:20 <EvilTerran> would it be possible, without fixIO, to embed a back-in-time state monad effect in IO?
20:01:28 <paczesiowa> Nafai: do you use list or tree as a model?
20:01:33 <ddarius> > (length "mapAndUnzipM", length "unzip <$> mapM")
20:01:34 <lambdabot>   (12,14)
20:01:40 <EvilTerran> i think it would be, but you'd have to be pretty crafty
20:01:51 <newsham> sbahra: if only it were....
20:01:54 <ddarius> > (length "mapAndUnzipM", length "unzip<$>mapM")
20:01:55 <lambdabot>   (12,12)
20:02:01 <newsham> that would definitely simplify things
20:02:02 <sbahra> newsham, taught a class on some "security" subject matter but didn't know about Coverity? Or how about things, like buffer overflows?
20:02:25 <newsham> computer security is a pretty big space.
20:02:27 <EvilTerran> or back-in-time ST. that'd be fun, i might try that.
20:02:29 <dolio> EvilTerran: You're talking about something like the backward state monad?
20:02:33 <paczesiowa> Nafai: it seems you use ListStore but try to getvalue with tree funs
20:02:36 <newsham> there's lots of stuff outside of code analysis and buffer overflows
20:02:37 <adu> sbahra: what's "got" and "cow"?
20:02:39 <EvilTerran> dolio, yes
20:02:51 <EvilTerran> expressed somehow in IO
20:03:00 <sbahra> newsham, he didn't know cryptography. He didn't know systems. He hasn't ever design and implemented a programming language.
20:03:04 <newsham> adu: GOT is a jump table for linking, COW is copy-on-write for sharing writable pages between processes
20:03:12 <dolio> EvilTerran: You might need continuations, which IO doesn't come with...
20:03:14 <mmorrow> EvilTerran: probably something using Cont*, but i'm not sure exactly how the first backintime thisng works
20:03:22 <EvilTerran> dolio, yeah =/
20:03:22 <paczesiowa> Nafai: nvm
20:03:27 <newsham> sbahra: bummer.  cant get a better teacher and/or school?
20:03:34 <EvilTerran> mmorrow, the back-in-time state is really simple, if you get the normal state monad
20:03:49 <mmorrow> EvilTerran: is there a description of it somewhere?
20:04:00 <ddarius> @google essence of functional programming
20:04:08 <lambdabot> http://citeseer.ist.psu.edu/wadler92essence.html
20:04:20 <sbahra> newsham, Long story, when I first joined GWU...I asked around for some research positions and I was told to basically fuck off until I was a senior. In return, I told those professors to fuck off by not doing the work that would teach me anything :-)
20:04:23 <rwbarton> ddarius: It's even in the Haskell Report!
20:04:33 <sbahra> newsham, and ended up getting a great research offer at the ECE department.
20:04:52 <sbahra> newsham, but now my grades are terrible. I need to write some great piece of software or have some nice publication if I ever expect to transfer :-P
20:04:54 <EvilTerran> ?src State >>=
20:04:54 <lambdabot> Source not found.
20:04:56 <EvilTerran> ?src State (>>=)
20:04:57 <lambdabot> Source not found. stty: unknown mode: doofus
20:05:00 <EvilTerran> grr
20:05:04 * sbahra is so close to graduation though
20:05:11 <EvilTerran> (State m >>= f) s = State$ uncurry f (runState m s)
20:05:16 <dolio> m >>= f = \s -> let (a,s'') = m s' ; (b,s'') = f a s in (b,s'')
20:05:18 <dolio> I believe.
20:05:28 <sbahra> Hopefully I'll pull through so I can make it to graduate school in the future, where atleast I'll have more freedom :-P
20:05:40 <Nafai> paczesiowa: Let me know if you see anything obvious
20:05:58 <sbahra> s/teach me anything/teach me nothing/
20:06:04 <adu> sbahra: I wrote a great piece of research, but no one noticed...
20:06:20 <sbahra> adu, atleast 1 professor would if the publication itself is nice.
20:06:21 <ddarius> "I'll just not do the work and get horrible grades, that will show them!"
20:06:30 <paczesiowa> Nafai: it is 5 am, I barely see anything, I could try tomorrow if you want
20:06:45 <newsham> you'll probably wanna publish some interesting papers if you're gonna try to get into grad school
20:06:45 <EvilTerran> ?type \m f -> uncurry f . runState m
20:06:46 <lambdabot> forall a b c. State b a -> (a -> b -> c) -> b -> c
20:06:49 <newsham> if your grades arent so hot
20:06:51 <EvilTerran> hm
20:06:54 <sbahra> A friend of mine, ex-drug addict, is now doing some great research in mathematics with full scholarship because of such a publication (which no one really noticed).
20:07:00 <newsham> because they wanna know you're both motivated and intelligent
20:07:07 <sbahra> newsham, nod
20:07:07 <EvilTerran> hey, that works!
20:07:48 <sbahra> newsham, problem with that is that I'm kind of limited with what papers I can write...I was working on a great one WRT formal models for packet acquisition systems and almost got fired because it wasn't immediately related to HPC. :-P
20:08:11 <harrison_partch> i wrote the first and so-far only fractal-voxel realtime raytracer and nobody cares.
20:08:13 <ddarius> You can do whatever you want on your own time.
20:08:51 <sbahra> ddarius, not in this group :-) I can do whatever research I want, as long as it is HPC. If I was to publish anything and not involve the group I work with, it is chop-chop.
20:09:04 <adu> sbahra: ya, the paper I wrote was a math paper, but 2 years later I learned it was only a generalization of a method published in 1991...
20:09:17 <sbahra> adu, haha
20:09:21 <sbahra> adu, title?
20:09:41 <adu> sbahra: http://tetration.itgo.com/paper.html
20:09:49 <newsham> adu: cool, all the math i try to do is at least 200 years further behind the cutting edge
20:10:03 <lambdabot> Title: Home of Tetration - Paper
20:10:13 <newsham> bbl
20:10:18 <adu> newsham: the word for what I do wasn't coined until 1947, so that helps ;)
20:10:36 <sbahra> adu, openoffice? ;-p
20:10:47 <adu> sbahra: ya, I have since learned to use TeX
20:11:10 <mmorrow> i wish modules were first class and could be used like datas
20:11:32 <ddarius> mmorrow: Switch to Cayenne
20:11:41 <mmorrow> ddarius: in the process ;)
20:12:06 <mmorrow> cayenne just uses expressions for modules :)
20:12:24 <Nafai> paczesiowa: Thanks for the help!
20:12:33 <ddarius> That would be part of making them first-class
20:12:34 <Nafai> paczesiowa: I'll ask around
20:13:05 <paczesiowa> Nafai: wild guess, maybe try with button?
20:13:20 <paczesiowa> Nafai: print on click
20:13:36 <Nafai> Good idea, I'll try to see if the it acts differently
20:13:40 <paczesiowa> Nafai: then refactor to those events
20:13:59 <mmorrow> ddarius: ah. i meant in the sense that data is in haskell, so i guess i used the wrong term. but of course /real/ first class is prefereable
20:14:10 <mmorrow> s/e//
20:15:27 <sbahra> Sorry for off-topic.
20:15:53 <mmorrow> i guess i should have said "a data declaration is really a mini module, complete with import/export, /but/ unlike modules (and like datas), they would also be parameterizable by typevars"
20:16:15 <mmorrow> (that's what i had in mind)
20:16:52 <rwbarton> , gshow 1
20:16:54 <lunabot>  "(1)"
20:17:00 <mmorrow> woohoo
20:17:11 <rwbarton> does that mean 1 is considered a data constructor?
20:17:37 <bd_> sure, why not?
20:17:52 <mmorrow> hmm. some parts of the TH pprinter are straight up wack. maybe some parts of Generics too?
20:18:08 <rwbarton> , src ''Constr
20:18:13 <lunabot>  data Constr = Constr {conrep :: ConstrRep,
20:18:13 <lunabot>                        constring :: String,
20:18:13 <lunabot>                        confields :: ([String]),
20:18:39 <mmorrow> (a reminder to all that lunabot'll return up to 32 lines in a /msg)
20:19:09 <mmorrow> e.g. do
20:19:17 <mmorrow> , src ''Exp
20:19:21 <lunabot>  data Exp = VarE Name
20:19:21 <lunabot>           | ConE Name
20:19:22 <lunabot>           | LitE Lit
20:20:38 <rwbarton> So, I think I'm going to autogenerate JSON instances by writing a JSON analogue of gshow/gread and then generating instances of JSON using those with some trivial Template Haskell.
20:20:46 <rwbarton> Does that sound like a reasonable thing to do?
20:20:50 <adu> , src ''Whack
20:20:51 <lunabot>  luna: Not in scope: type constructor or class `Whack'
20:20:59 <mmorrow> rwbarton: rad! for sure.
20:21:19 <rwbarton> as opposed to, say, doing whatever Data.Derive does to create instances.
20:21:34 <rwbarton> (namely building them from scratch with Template Haskell?)
20:21:44 <sw17ch> ping lispy
20:21:53 <mmorrow> i've gotta do something for a bit, but you've gotta tell me about the details later. maybe it could be done super easily with some trickery or something
20:22:09 * adu <3 TH
20:23:10 <mmorrow> rwbarton: hmm. yeah, at first glance, i'm not so sure if i'd go the Generics route, but i also haven't seen the JSON class..
20:23:26 <mmorrow> (or know what it does)
20:23:39 <lispy> sw17ch: hi
20:23:45 <dolio> @type () :: 1
20:23:46 <lambdabot>     Couldn't match expected type `Unit' against inferred type `()'
20:23:57 <sw17ch> lispy: i had a question about darcs :)
20:23:59 <jaredj> Python: ','.join(('1', '2', '3')) -> '1,2,3'. i can't find the haskell function?
20:24:16 <lispy> sw17ch: okay, ask away, BTW there is #darcs too
20:24:22 <paczesiowa> :t intersperse
20:24:22 <dolio> intercalate
20:24:23 <rwbarton> mmorrow: it's basically like Show+Read but with String replaced by JSValue, a type representing (untyped) JSON values
20:24:23 <lambdabot> forall a. a -> [a] -> [a]
20:24:30 <mmorrow> > intercalate "," (fmap show [0..9])
20:24:30 <paczesiowa> > intersperse ',' "123"
20:24:32 <lambdabot>   "0,1,2,3,4,5,6,7,8,9"
20:24:32 <lambdabot>  Terminated
20:24:36 <jaredj> sigh thanks. i found it as soon as i hit enter :)
20:24:43 <paczesiowa> > intersperse ',' "123"
20:24:44 <lambdabot>   "1,2,3"
20:24:56 <sw17ch> lispy: it's really general. Does it (or any vcs, for that matter) take into account the language syntax it's repositorying?
20:25:06 <jaredj> > intersperse ", " ["one", "two", "three"]
20:25:07 <lambdabot>   ["one",", ","two",", ","three"]
20:25:13 <jaredj> :d
20:25:17 <jaredj> > concat $ intersperse ", " ["one", "two", "three"]
20:25:18 <lambdabot>   "one, two, three"
20:25:25 <adu> jaredj: also, split c = map(tail).groupBy(const(c/=)).(c:)
20:25:26 <rwbarton> @src intercalate
20:25:26 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
20:25:39 <lispy> sw17ch: I don't know of any vcs that do that
20:25:43 <jaredj> ok there we go.
20:26:03 <sw17ch> lispy, ah, just making sure :) i was half curious if darcs was some how geared toward haskell sources specifically
20:26:26 <lispy> sw17ch: people have made proposals for this, but none have ever been implemented
20:26:38 <mmorrow> rwbarton: hmm ok. what's your intended strategy of turning the AST of some type's decl into functions (thattype -> JSValue) ?
20:26:47 <adu> lispy: I'm still implementing the char-diff
20:26:51 <sw17ch> neato
20:26:53 <lispy> adu: cool
20:27:12 <adu> lispy: just progressing slowly :P
20:27:16 * mmorrow looks up the haddocks
20:27:27 <sw17ch> has any one made a derive script for the Text.JSON module?
20:27:40 <sw17ch> similar to the one for Data.Binary
20:28:09 <rwbarton> sw17ch: That's exactly what I'm wondering/working on
20:28:23 <lispy> sw17ch: probably the most exotic patch type that darcs current has is the replace patch.  You can apply a regular expression to a file.  Many people would like to add an indentation level patch, one that changes nothing but indentation level or a block
20:28:37 <sw17ch> rwbarton, well that's interesting
20:28:56 <mmorrow> rwbarton: just saw the data decls, that is an interesting problem. catch you in a bit :)
20:28:57 <sw17ch> lispy: i was more curious about having my VCS pick out when the logic of the program was altered
20:29:17 <rwbarton> sw17ch: (you're referring to Data.Derive.Binary?)
20:29:30 <sw17ch> rwbarton: i might be...
20:29:32 * sw17ch goes to look
20:29:37 <lispy> sw17ch: diffing based on semantics is hard if you want to detect equivalent programs
20:29:58 <sw17ch> :)
20:30:04 <sw17ch> well, ast changes would be fine too
20:30:05 <lispy> sw17ch: hard as in, it should be undecidable in the general case
20:30:40 <sw17ch> yes
20:30:49 <lispy> yeah, ast changes would be do able, there you're just looking for structural changes after applying some processing function
20:31:13 <lispy> the UI would not be easy to agree on, but that can probaly wait till after you have a working proposal
20:32:12 <EvilTerran> mmorrow, here's a description of reverse state:
20:32:14 <sw17ch> that could be interesting to see
20:32:20 <EvilTerran> (State m >>= f) s = let (s', x) = m s; (s'',y) = f x s' in (s'',y)
20:32:20 <EvilTerran> (Etats m >>= f) s = let (s'', x) = m s'; (s',y) = f x s in (s'',y)
20:32:46 <lispy> sw17ch: one of the interesting thing about adding new patch types to darcs is that you really just have to figure out how your new patches commute with the existing types.  As in, your considerations are totally local.  You don't have to consider the universe at once.
20:33:12 <sw17ch> cool....
20:33:25 <sw17ch> @hackage binary
20:33:25 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
20:33:30 <rwbarton> mmorrow: here is the most trivial possibility: http://hpaste.org/11001
20:33:57 <sw17ch> rwbarton, actually, i don't know where Data.Binary.Derive is...
20:34:05 <sw17ch> i've used the script in the haddock page
20:34:07 <rwbarton> Data.Derive.Binary in the derive package
20:34:12 <EvilTerran> mmorrow, the state goes through f before it goes through m in (m >>= f), so it effectively travels up do-loops
20:34:17 <sw17ch> @hackage derive
20:34:17 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/derive
20:34:48 <chrisdone> Q: What's The Sussman's favorite nursery rhyme?
20:34:49 <chrisdone> A: Mary Had a Little Lambda
20:35:09 <lispy> EvilTerran: someone at a talk today mentioned this backtraveling state monad...were you at a talk about Cabal by any chance today?
20:35:24 <EvilTerran> nyet
20:35:29 <EvilTerran> i think about these things on my own :P
20:40:48 * sw17ch wonders if any one has experience with the Crypto library
20:42:33 <lispy> sw17ch: Never used it myself, but I've wondered about it on occasion
20:43:00 <sw17ch> lispy: i'm looking into what i want to use for scurry's encryption layer
20:43:06 <sw17ch> i'd prefer something which can work on bytestrings
20:44:43 <lispy> sw17ch: I have a hunch you may need to benchmark and extend Crypto if you use it.  Not trying to deter you in any way though.
20:45:02 <lispy> I just have a feeling it's not a widely used library
20:45:15 <sw17ch> lispy: yeah... it looks, just by glancing at it, that it won't hold up to what i'm wanting :\
20:45:18 <sw17ch> hopenssl might
20:45:28 <lispy> is hopenssl a binding?
20:45:38 <sw17ch> yes
20:46:19 <sw17ch> hrm... i need to refresh myself on how all these different thigns fit together... since the network will be distributed/serverless, i want *some* way of determining who you decide to talk to
20:46:27 <sw17ch> and i was hoping to use RSA key signing
20:47:31 <sw17ch> Codec.Encryption.PKCS1 looks promising :)
20:47:59 <lispy> sw17ch: without a global authority, do you use a web of trust then?
20:48:31 <sw17ch> lispy: yeah, that'd be the idea. i won't open a direct communication to you unless there's a signing chain from my key to yours of less than N length
20:48:57 <rwbarton> mmorrow: any ideas about http://hpaste.org/11001#a1?
20:48:59 <sw17ch> or, if you just want to play a LAN game, you turn off all the encryption and let any one connect
20:52:48 <sw17ch> HsOpenSSL doesn't have any of it's haddock info :(
20:54:44 <thoughtpolice> sw17ch: yeah I had to cut out parts of the docs because they weren't parsing correctly
20:54:51 <thoughtpolice> same with haskell-src-exts
20:55:04 <sw17ch> thoughtpolice, did you use HsOpenSSL for something?
20:55:08 <simoncpu> @slap lambdabot
20:55:08 * lambdabot slaps lambdabot
20:55:16 <simoncpu> coool
20:55:30 <thoughtpolice> sw17ch: i was playing around with it for the most part
20:55:57 <sw17ch> thoughtpolice, alright.
21:00:57 <sw17ch> i don't suppose any one has build an interface to gpg at all...
21:04:06 <dino-> The couple of places where I'm using gpg I have runInteractiveProcess to 'old school' interface with it for now.
21:04:26 <dino-> fwiw
21:15:17 <mml`> ?users
21:15:17 <lambdabot> Maximum users seen in #haskell: 540, currently: 475 (88.0%), active: 9 (1.9%)
21:18:30 <mml`> @pointful add1 = (+ 1)
21:18:30 <lambdabot> add1 a = a + 1
21:18:40 <sw17ch> if any one is looking for a fun project, I would really appreciate bindings to libgcrypt :)
21:18:53 <mml`> @pl add1 a = a + 1
21:18:54 <lambdabot> add1 = (1 +)
21:19:19 <Nafai> Hi dcoutts
21:19:35 <dcoutts> hia
21:19:43 <Nafai> Got time for a gtk2hs question?
21:19:54 <dcoutts> I guess :-)
21:20:22 <Nafai> I'm running this code: http://github.com/Nafai77/utilities/tree/master/src/gtkmenu.hs
21:20:24 <lambdabot> Title: src/gtkmenu.hs at master from Nafai77's utilities — GitHub
21:20:34 <Nafai> And when I run it and press return, I get this error:
21:20:36 <Nafai> http://hpaste.org/11000
21:20:38 <mml`> @index foldr
21:20:38 <lambdabot> Data.List, Prelude
21:21:01 <Nafai> The problem is in trying to get the selected item in a TreeView with that is ListStore backed
21:22:14 <rwbarton> mmorrow: here's a slightly less crude version http://hpaste.org/11001#a2
21:24:29 <dcoutts> Nafai: ok, so I think the problem is that you're trying to access a column in the model that does not exist
21:25:13 <Nafai> dcoutts: The 0 in treeModelGetValue?
21:25:16 <lispy> ?src succ
21:25:19 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
21:25:49 <dcoutts> Nafai: right, that model has no columns defined at all, not on the C side, it's accessed from the Haskell side
21:26:16 <dcoutts> Nafai: so access the store directly using the typed haskell api
21:27:02 <mml`> @help yhjulwwiefzojcbxybbruweejw
21:27:02 <lambdabot> V RETURNS!
21:27:05 <Nafai> Which API?
21:27:17 <mml`> huh
21:27:19 <dcoutts> Nafai: the list store api
21:27:21 <mml`> @yhjulwwiefzojcbxybbruweejw
21:27:21 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
21:28:17 <Nafai> dcoutts: http://www.haskell.org/gtk2hs/docs/gtk2hs-docs-0.9.12/Graphics-UI-Gtk-ModelView-ListStore.html#v%3AlistStoreGetValue ?
21:28:24 <lambdabot> Title: Graphics.UI.Gtk.ModelView.ListStore, http://tinyurl.com/42g8at
21:28:28 <dolio> lambdabot used to do something with a variable named v...
21:28:31 <Nafai> Is there a way to covert the TreeIter to an Int?
21:28:41 <dolio> And if you knew that, you could get random bad things to happen.
21:29:05 <dolio> So, after people did things like that, they changed the variable to yhjulwwiefzojcbxybbruweejw
21:29:20 <dolio> To make it harder to stumble upon accidentally.
21:29:34 <rwbarton> @yhjulwwiefzojcbxybbruweejw
21:29:34 <lambdabot> Exception: <<loop>>
21:29:39 <dolio> So @v and @yhjulwwiefzojcbxybbruweejw print random messages that you could have produced by that method.
21:29:42 <rwbarton> Ah, I see
21:29:42 <b7j0c> i have stopped using "do"
21:30:01 <b7j0c> do people think this is just mental masturbation or is "do" considered ghetto?
21:30:07 <lispy> not the similarity to what @yhj... just printed and the result of > fix show
21:30:09 <lispy> > fix show
21:30:10 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
21:30:32 <Pseudonym> "do" is considered useful.
21:30:54 <mml`> sometimes, 'do' really improves readability
21:30:55 <lispy> "do" or "do" not, there is no try.
21:31:05 <sjanssen> @hoogle try
21:31:05 <lambdabot> Control.Exception try :: IO a -> IO (Either Exception a)
21:31:05 <lambdabot> System.IO.Error try :: IO a -> IO (Either IOError a)
21:31:05 <lambdabot> Text.Parsec.Prim try :: Stream s m t => ParsecT s u m a -> ParsecT s u m a
21:31:13 <dcoutts> Nafai: yes listStoreGetValue. But I see, yes you've got an iter from the get selection function, hmm.
21:31:21 <lispy> (except that that try...)
21:31:37 <b7j0c> i actually find it helps me to understand monads better to leave it out. maybe once i am at the mastery level i will revert back, not needing the mental crutch
21:31:37 <sjanssen> s/that that/those three/
21:32:12 <b7j0c> by the way, can some provide a thirty-word summary as to why ByteStrings are better than Strings?
21:32:14 <dolio> Sometimes do looks nicer, sometimes >>= does.
21:32:16 <sjanssen> b7j0c: I think this is a normal progression of a Haskell programmer
21:32:31 <dcoutts> Nafai: you can convert an iter to a path
21:32:33 <dolio> I wouldn't worry about using one or the other exclusively.
21:32:39 <Nafai> dcoutts: Right, I've seen that
21:32:44 <rwbarton> do any of the report-specified modules use record syntax?
21:32:45 <lispy> b7j0c: efficiency ++ randomWords 29
21:32:49 <sjanssen> b7j0c: String is a linked list, meaning tons of memory use, ByteString is an array meaning practically minimum memory use
21:32:54 <Nafai> And a TreePath is just a [Int], so I could do a path !! 0 ?
21:33:11 <dcoutts> Nafai: right
21:33:12 <Nafai> Since I set the selection mode to single, it will always be just a single element
21:33:15 <b7j0c> cool, so why don't Strings and ByteStrings merge?
21:33:23 * Nafai tries that
21:33:48 <sjanssen> b7j0c: they're just fundamentally different, Strings are lazy where ByteStrings are strict
21:33:50 <rwbarton> @src Permissions
21:33:50 <lambdabot> Source not found. Maybe if you used more than just two fingers...
21:34:11 <sjanssen> b7j0c: their differences are their strengths in various scenarios
21:34:24 <b7j0c> sjanssen:
21:34:39 <b7j0c> how do you make my name appear bold? i know little irc
21:35:14 <dolio> Your client probably bolds your name automatically.
21:35:15 <rwbarton> b7j0c: by starting a line with 'b7j0c:'
21:35:21 <sjanssen> b7j0c: I'm not doing that, your client is probably highlighting lines with your name automatically
21:35:22 <dolio> Mine prints lines with my name in red.
21:35:35 <b7j0c> aah! cool. i am using ERC
21:35:48 <lispy> my client makes a cup of coffee for me whenever someone says my nick
21:35:53 <b7j0c> and also, don't ByteStrings support lazy use?
21:36:11 <b7j0c> you have a nice client lispy
21:36:25 <lispy> b7j0c: lazy bytestrings are [ByteString] under the hood...that is, they are chunked up versions...they get their laziness from the laziness of lists
21:36:30 <sjanssen> b7j0c: there is Data.ByteString.Lazy that supports a sort of half-lazy half-strict usage
21:36:59 <BMeph> lispy: So, what makes you drink that coffee? ;)
21:37:10 <lispy> b7j0c, BMeph: thanks for the coffee ;)
21:37:33 <b7j0c> sjanssen: so were Strings implemented as lazy ByteStrings, would you see this as a negative? i guess i find it odd that haskell has two String types
21:37:42 <sjanssen> > unwords . repeat $ "lispy"
21:37:44 <lambdabot>   "lispy lispy lispy lispy lispy lispy lispy lispy lispy lispy lispy lispy li...
21:37:54 <BMeph> lispy: Does coffee make you lispy, or does lispy make you coffee? ;p
21:37:54 * lispy feels like a badger
21:37:58 <reinerp> btw, is there a reason why there's no ByteString typeclass, which lazy and strict are both instances of?
21:38:15 <sjanssen> b7j0c: I would.  ByteString.Lazy has really tricky strictness properties that are hard to nail down
21:38:35 <juhp> can someone explain how to use cabal-install with a user ghc-6.10 install?
21:38:46 <b7j0c> sjanssen: cool. do you have any personal rules you use to determine which to use?
21:39:27 <sjanssen> b7j0c: String by default, ByteString for megabytes of data, lazy ByteString for many megabytes of data
21:39:45 <dcoutts> juhp: first off, you need the very latest darcs version of Cabal and cabal-install
21:39:54 <rwbarton> b7j0c: also, note String = string of Char, i.e., Unicode characters; ByteString = string of bytes
21:39:59 <BMeph> b7j0c: Potentially, Haskell has an infinite number of String types (IsString is a class). ;)
21:40:17 <b7j0c> cool. and on another topic, anyone here using "yi"? i built it in arch linux...seemed sort of neat. not sure if it beats emacs' haskell/flymake
21:41:02 <b7j0c> rwbarton: are ByteStrings unfit for unicode?
21:41:32 <Adamant> b7j0c: nah they do Unicode
21:41:34 <rwbarton> b7j0c: depends on the extent to which you need to understand the unicode nature of the text
21:41:43 <scook0> bytestrings store bytes
21:41:46 <adu> b7j0c: I tried it out, and I like the concept, but I still use emacs
21:41:54 <rwbarton> b7j0c: i.e., if you write 'cat' using ByteString, it will support unicode :)
21:42:02 <scook0> if you use them to store UTF-encoded bytes, that's your business
21:42:05 <sjanssen> Adamant: what?  ByteStrings do not support characters larger than 255
21:42:25 <Adamant> sjanssen: I thought you could store UTF-8 strings in ByteStrings
21:42:52 <sjanssen> Adamant: yes, but the operations work on bytes only
21:43:08 <sjanssen> Adamant: eg. head will chop multi-byte characters in half
21:43:13 <Nafai> Could someone help me write this function so it will compile: http://hpaste.org/11002
21:43:16 <adu> String /= ByteString
21:43:27 <b7j0c> so are Strings "fully" supporting of unicode? i know that java (yuck) has one strong point in its "full" unicode support (utf-16)
21:43:47 <sjanssen> b7j0c: Char is a Unicode code point, type String = [Char]
21:43:59 <sjanssen> b7j0c: (but our IO system sucks and doesn't really support Unicode)
21:44:11 <rwbarton> b7j0c: Yes.  (Technically, 16 bits is not enough to store a unicode character; maybe that's why you said "full")
21:44:25 <sw17ch> Nafai: start by breaking a lot of that into where clauses
21:44:33 <rwbarton> err, '"full"' :)
21:44:41 <lispy> > maxBound :: Char
21:44:41 <b7j0c> sjanssen: can you elaborate on haskell IO "sucking"?
21:44:42 <lambdabot>   '\1114111'
21:44:47 <dons> utf8-string ftw! utf8 should be good enough for anyone.
21:45:04 <rwbarton> Nafai: if/then/else -- the then and else need to be indented more
21:45:11 <sjanssen> b7j0c: it is totally ignorant of encodings, and just treats each byte as a character
21:45:19 <juhp> dcoutts: ok....
21:45:27 <b7j0c> agree dons, just wondering since java guys seem to play up utf-16 support
21:45:37 <Nafai> Grr.  The Emacs mode isn't wanting to indent those lines any more
21:45:47 <dons> so yeah, the default ghc IO system reads bytes, and ignores encodings.
21:45:52 <dons> but you can at least layer new encodings on top.
21:46:09 <scook0> which is (almost) the same as it implicitly assuming Latin-1 encoding
21:46:12 <juhp> dcoutts: presumably it will be ok in ghc-6.10
21:46:18 <b7j0c> sounds like the utf8-string package is a must-have
21:46:33 <dons> 'tis true.
21:46:39 <lispy> actually, based on what little I've read about encodings, that's the way you want it.  You store things in a big-enough-type internally, and you deal with encodings.  So you don't really want the RTS doing it automagically.
21:46:43 <dons> one of the most popular non-core packages.
21:46:53 <sjanssen> lispy: I don't think that is true
21:47:10 <b7j0c> dons, i preordered my real-world-haskell eons ago. any idea when they ship?
21:47:23 <Nafai> rwbarton: So, pardon the newbie question.  What can be moved into where clauses?
21:47:31 <sjanssen> lispy: what you want are two APIs: one that works with Word8 that is encoding agnostic, and one that works with Char is is encoding aware
21:47:33 <Nafai> I'm always confused about that with the do blocks
21:48:04 <lispy> sjanssen: okay, that sounds reasonable
21:48:12 <dons> b7j0c: mid-november.
21:48:19 <dons> all the copyediting is done now. off to production.
21:48:22 <dons> fire up the presses.
21:48:30 <dons> dead trees for all!
21:48:34 <b7j0c> i'm glad the book uses the traditional ORA cover style...i'm not digging some of the "new" stuff they do like the heads-up books
21:48:39 <dons> hehe
21:48:42 <b7j0c> and expensive dead trees too
21:48:46 <sjanssen> lispy: right now we have "putChar :: Char -> IO ()", which is a lie
21:48:56 <b7j0c> but i wanted to make sure people doing haskell stuff had a market
21:49:00 <sw17ch> RWH in time for Christmas!
21:49:07 <mjrosenb> dons: hey, did you see the backtrace of ghc after it hung?
21:49:16 <dons> mjrosenb: nope, did you drop it by #ghc ?
21:49:36 <mjrosenb> dons: i think so
21:49:45 <mjrosenb> iirc, i put it on hpaste
21:50:12 <Nafai> I guess I need to split this function up or something :(
21:50:17 <dcoutts> juhp: well, the right version of the Cabal lib will come with ghc. The cabal-install package is separate and will come with the platform or separately.
21:50:51 <mjrosenb> dons: it's there now
21:51:21 <juhp> dcoutts: sure
21:51:30 <b7j0c> one last random question - does any xmonad user know how to do mouseless cut and paste between windows? its the last thing keeping me reaching for the mouse
21:52:01 <mjrosenb> b7j0c: urxvt supports pasting via key-combo
21:52:09 <mjrosenb> b7j0c: don't know about cutting
21:52:14 <mjrosenb> that sounds more difficult
21:52:19 <b7j0c> thanks mjrosenb, i use urxvt!
21:52:25 <b7j0c> copy is good enough
21:52:37 <mjrosenb> or copy even
21:52:38 <b7j0c> i'll look into that!
21:52:54 <lispy> b7j0c: ask in #xmonad
21:53:05 <b7j0c> thanks lispy, will do.
21:53:18 <b7j0c> thanks everyone and good evening
21:54:01 <b7j0c> join #xmonad
21:58:47 <hackage> Uploaded to hackage: vty 3.1.2
21:59:31 <lispy> dons: will Haskell platform deal with the tool chain issues some day?  By tool chain, I mean, we still need a *good* dev environment with respect to editor support.
21:59:54 <dons> for an ide, i think we'd have to fund, as a community, someone to work on it.
22:00:06 <dons> i.e. the commercial backers would need to fund the open source work that's needed.
22:00:20 <dons> the platform just aggregates the best free software.
22:00:30 <dons> to help out the research, commercial and open source haskell users.
22:00:41 <jaredj> bah, tools
22:01:11 <dons> or we just keep using emacs and vim. and the windows guys can get visual haskell .net by paying someone to work on it.
22:01:37 <lispy> dons: okay.  I'm sitting here thinking, since I typed that, that we have a lot of the right tools we just need a nice way to pull them all together automatically.  Hoogle for your project, plus ghc-api, and a haddock browser and automatic .cabal generation.
22:01:40 * mjrosenb thinks that adding some stuff onto emacs mode would make a wonderful ide
22:02:11 <adu> like C-h would be nice
22:02:26 <lispy> mjrosenb: someone was working on a superior haskell integration mode, or some such in emacs but it dried up and went away
22:02:28 <hansfbaier> lispy: I tried leksah, it is still alpha, but I already find it pretty usable. And it is written in 100% Haskell
22:04:18 <jaredj> i can't find the blog article from six months ago but it spoke of how some people want nice tools for their dumb language, and others want a nice language, even when it means their tools have to be more generic (e.g. text editor + make, not IDE)
22:04:19 <mjrosenb> lispy: :(
22:04:25 <dons> lispy: yeah, that's definitely something that platform can help with.
22:04:42 <Nafai> jaredj: Just a second, I know what you are referring to
22:04:46 <dejones> How can I execute a function in "main" without it being printed?  is "return function" the only way?  I keep getting type error since it is not IO.
22:04:48 <jaredj> it had nice graphs
22:04:50 <dons> well, hopefully we can have smart tools (like hoogle) and nice languages too
22:05:24 <jaredj> hear hear
22:05:26 <adu> hoogle++
22:05:32 <jaredj> hooglf?
22:06:14 <Nafai> jaredj: http://osteele.com/archives/2004/11/ides
22:06:15 <lambdabot> Title: Oliver Steele » Blog Archive » The IDE Divide
22:06:21 <Nafai> Yes, I agree with dons
22:06:29 <jaredj> presto!
22:06:35 <Nafai> I don't believe that "powerful language" and "powerful tools" are mutually exclusive
22:06:58 <Nafai> After using less powerful languages with powerful tools, I know that they are generally beneficial and not just a crutch
22:07:06 <lispy> ?where shim
22:07:06 <lambdabot> http://mapcar.org/haskell/shim/ http://mawercer.de/~publicrepos/shim/
22:07:38 <lispy> damn, yeah shim seems to be dead
22:07:45 <Nafai> shim was definitely a good start
22:08:21 <dons> there's lots of things we can do with a strongly typed, purely functional language automatically.
22:08:24 <jaredj> haha "six months ago" i said. plus or minus 3.5 years
22:08:29 <dons> you get a hint with @pl or @djinn or @hoogle
22:08:44 <dons> so integration into our existing editors is the challenge (vim, emacs, visual studio)
22:08:57 <hansfbaier> http://leksah.org/
22:08:59 <dons> hare is another one, automated refactoring. yi's layout-sensitive handling
22:09:08 <lambdabot> Title: Leksah - Haskell IDE in Haskell
22:09:15 <lispy> dons: did the refactoring browser ever get finished?  It was started by a galois employee...I saw a concept demo at ICFP '06
22:09:28 <dons> hmm, not a galois thing afaik?
22:09:37 <thoughtpolice> i wanted to know about halvm
22:09:39 <Nafai> leksah was...weird
22:09:49 <dons> galois has a live tracer using hpc, that just got permission to open source
22:09:57 <lispy> cool
22:10:20 <lispy> dons: I thought the author of the refactoring browser was a galois employee, but it was a few years ago, I could be mistaken
22:10:34 <dons> you can actually see the live tracing here, movies.unsafeperformio.com/hpctpreview2.mov
22:10:45 <dons> lispy: oh, maybe programmatica?
22:10:50 <dons> that's a psu/ogi project
22:11:02 <newsham> AIG CDS staff avg'd $1M/yr
22:11:07 <dons> that video's worth a look at, btw.
22:12:26 <lispy> See, we have these tool and what not that are in common usage, but they're not integrated
22:12:26 <jaredj> that's groundbreaking but it doesn't look it.
22:12:35 <newsham> oops, wrong channel
22:12:36 <lispy> It's a problem in search of a solution :)
22:12:37 <jaredj> it needs 3d flying source listings
22:12:44 <thoughtpolice> dons: really cool
22:13:09 <thoughtpolice> hopefully integrated into ghc in a future release? :)
22:13:53 <dons> yeah. talk to andyjgill about it.
22:13:59 <lispy> if we could start a company that sells nicely polished, yet open source, haskell tool chains to people we could make a killing :)
22:14:16 <dons> selling open source. that's a plan.
22:14:22 <thoughtpolice> dons: you guys have all sorts of cool projects :]
22:14:24 <Nafai> lispy: That would rock :)  Sign me up
22:14:34 <dons> thoughtpolice: we try. :)
22:16:13 <Nafai> dcoutts: Thanks for you help, I finally got it working!
22:16:59 <jaredj> night all.
22:17:55 <Nafai> dcoutts: Latest: http://github.com/Nafai77/utilities/tree/master/src/gtkmenu.hs
22:17:57 <lambdabot> Title: src/gtkmenu.hs at master from Nafai77's utilities — GitHub
22:18:10 <Nafai> Yay, it works
22:18:17 <Nafai> I've written my first useful Haskell code
22:18:27 <mjrosenb> dons: you see the backtrace yet?
22:18:30 <Nafai> Now to make the adjustments to use it from xmonad
22:18:33 <dcoutts> Nafai: yay
22:20:50 <Nafai> Is it possible to have a key event handler on the main window and pass certain events onto a specific widget?
22:23:44 <Nafai> Is haskell.org down?
22:24:23 <mauke> http://downforeveryoneorjustme.com/haskell.org
22:24:33 <lambdabot> Title: Huh?
22:24:40 <rwbarton> http://hpaste.org/11001#a4 -- I'm stumped, why is the []-specific case working but not the Ratio-specific case?
22:26:59 <lispy> Nafai: okay, if I start taking applications I'll let you know :)
22:27:24 <rwbarton> Oh, because the Data (Ratio a) instance is missing dataCast1 most likely :(
22:27:31 <Nafai> lispy: w00t.
22:28:00 <Nafai> Once I start learning more of Haskell, it is a desire to make better / improve existing developer tools
22:29:40 <mjrosenb> Nafai: i said that too
22:29:54 <mjrosenb> Nafai: but once i learned haskell, i sort of didn't feel the need for them
22:30:19 <Nafai> I admit I don't buy that
22:30:27 <Nafai> Maybe I've become too much of a Java weenie
22:30:43 <Nafai> But I need tools better than grep and static tags to navigate and understand my code base
22:30:49 <Nafai> (And the libraries I use)
22:31:04 <Nafai> I shouldn't have to switch from my editor/IDE to a web browser to figure out APIs
22:31:07 <Nafai> etc
22:32:06 <lispy> right
22:32:35 <lispy> emacs seems to use a mark and sweep garbage collector
22:32:44 <mjrosenb> ghci has a bunch of things that you can easily extend it with
22:32:47 <Nafai> Especially when a lot of this should be trivial in a staticly-typed language like Haskell
22:32:53 <Nafai> mjrosenb: Yeah, that's what I've seen
22:33:10 <mjrosenb> so i have :hoogle foobar from within ghci
22:33:20 <lispy> I think ghc-api should be able to play an important role in a good haskell IDE
22:33:24 <mjrosenb> and of course, ghci is running inside of emacs
22:34:16 <Nafai> lispy: Definitely
22:35:16 * JuanDaugherty relents.
22:35:56 <JuanDaugherty> anybody know of a haskell CMS, not necessarily happs based?
22:38:25 <dons> JuanDaugherty: hmm, i know of some happs-based ones.
22:38:32 <dons> but isn't panda/kibro fastcgi + hdbc?
22:42:45 <newsham> "I shouldn't have to switch from my editor/IDE to a web browser to figure out APIs
22:42:53 <newsham> not really sure what that has to do with editing.
22:43:27 <newsham> isnt that kinda like saying "I shouldnt have to get out of my car to cook hotdogs"?
22:43:34 <quicksilver> no
22:43:45 <quicksilver> it's like saying "I shouldn't have to get out of my car to play the radio"
22:43:46 <rwbarton> auto-hoogle-symbol-at-point, say
22:43:57 <quicksilver> sure, car radios aren't required for the functioning of a car
22:44:09 <quicksilver> but some people enjoy them, and the traffic reports are useful.
22:44:09 <newsham> my car didnt come with a dvd player
22:44:12 <newsham> nor do I think it should
22:44:55 <newsham> you cant run an editor and a doc viewer at the same time?
22:45:12 <quicksilver> I actually don't care (personally); I see no problem with docs in a web browser. But I don't dismiss the point, it's a valid one.
22:45:24 <quicksilver> and type-sensitive autocomplete would be lovely.
22:46:14 <Cale> I can see the purpose of various nice content-aware text editor features, but I don't see the reason people seem to want everything in one window.
22:46:26 <JuanDaugherty> i don't mean somebody's half-assed science project, a joomla in haskell, something serious at least as well done as C5
22:47:16 <JuanDaugherty> i especially don't mean the darcs of CMSes, although actually that would be a start
22:47:21 <quicksilver> JuanDaugherty: no.
22:47:26 <quicksilver> JuanDaugherty: I'm fairly sure there isn't one.
22:47:44 <JuanDaugherty> quicksilver, thx.
22:47:49 <quicksilver> @google haskell cms
22:47:56 <lambdabot> http://hope.bringert.net/
22:47:56 <lambdabot> Title: Hope - About Hope
22:47:58 <quicksilver> ...except that one.
22:48:06 <quicksilver> I knew about hope, I didn't know it called itself a CMS.
22:48:08 <quicksilver> never used it.
22:48:12 <dons> panda's the newest one.
22:49:09 <dons> lots of cool haskell code is on github these days.
22:49:11 <dons> which is interesting
22:49:15 <JuanDaugherty> CMS is such a crowded field, you need to put down monster feet from the jump, just being haskell inn't enug
22:49:20 <JuanDaugherty> *enuf
22:49:51 <JuanDaugherty> have a sneaking feeling being happs based would be a mistake
22:49:58 <Cale> Why?
22:49:59 <quicksilver> Cale: in particular I don't see the obsession with 'project view' or 'file browser'. I've used a few commercial IDEs and never understood what the point was.
22:50:08 <Cale> quicksilver: yeah.
22:50:23 <mmorrow> rwbarton: awesome!
22:50:26 <quicksilver> they never seem to offer anything more interesting than a decent editors built-in file navigation tools.
22:50:36 <Cale> "Look guys, we made the file open dialog box visible all the time!"
22:50:55 <quicksilver> maybe it's a plot by monitor manufacturers.
22:50:59 <Cale> hehe
22:51:05 <JuanDaugherty> sneaking feeling = wholly subject impression which I'm not ready to defend an am even eager to find wrong
22:51:05 <mmorrow> rwbarton: hmm, i'm trying to capture the difference between that and what derive does in one sentence (and well).
22:51:11 <JuanDaugherty> *subjective
22:51:20 <dons> http://happstutorial.com/
22:51:21 <lambdabot> Title: Real World HAppS: The Cabalized, Self-Demoing HAppS Tutorial
22:51:28 <cjb> ooh.
22:51:46 <rwbarton> mmorrow: I now understand why syb-with-class is helpful here
22:51:59 <cjb> hm, shame I disagree with the second paragraph on the page, though
22:52:11 <quicksilver> I think the most rational objection to happs is that the code uses some quite advanced features which may be a barrier in understanding it.
22:52:21 <mmorrow> rwbarton: so clearly it has the Data/at-runtime aspect, but i mean more in what exactly the various Data traversals are doing and more in particular, how that could be piggybacked-on by TH at compile time
22:52:22 <quicksilver> (and personally I almost never use a library whose code I am not prepared to read)
22:52:24 <cjb> 'cause, you know, I just wrote a webapp in django.  and I didn't have to write sql.  and I didn't have to perform any operations against a database by hand.  *and it was good*.
22:52:26 <rwbarton> mmorrow: it lets you add a special case handler for types belonging to a given type class
22:52:43 <dons> JuanDaugherty: so that link might be worth snooping around on, if you're looking to do some hacking.
22:52:56 <mmorrow> rwbarton: heh, totally. i never fully understood the significance of that until right now either
22:53:11 <JuanDaugherty> yes, I'm doing a few other things ATM but have bookmarked it.
22:53:20 <rwbarton> mmorrow: so, I don't need those 20 lines of extQ.
22:53:32 <mmorrow> rwbarton: oh wait. i'm confused then
22:53:33 <cjb> dons: hm.  is it okay if I find this site pretty incoherent?
22:53:48 <quicksilver> cjb: I never understood the happs guys objections to SQL. I waver between thinking it's misinformed, thinking it's naive, and thinking I must be stupid for not understanding their point :)
22:53:49 <mmorrow> rwbarton: how did you mean?
22:53:53 <cjb> I hate the mix of long code blocks in the same style of text as the prose
22:54:05 <rwbarton> mmorrow: I think, though I haven't tried it, that I should effectively be able to replace them all with a single showJSON :: JSON a => a -> JSValue
22:54:18 <rwbarton> mmorrow: but I'm just looking at the syb-with-class paper now.
22:55:02 <Cale> Isn't a CMS just a revisioning system + file permissions?
22:55:09 <quicksilver> cjb: yes it almost looks like it's missing a stylesheet.
22:55:10 <mml`> :t undefined
22:55:11 <lambdabot> forall a. a
22:55:20 <quicksilver> Cale: plus a web interface to the above
22:55:27 <quicksilver> Cale: so non-developers can add code.
22:55:34 <mmorrow> rwbarton: i haven't gotten through any of those, but this gives me a slight motivation boost..
22:55:42 <quicksilver> Cale: plus some kind of markdown system or perhaps a GUI content editor
22:55:45 <Cale> quicksilver: ah, because we could never expect users to be able to use a computer ;)
22:55:55 <quicksilver> Cale: it's more subtle than it.
22:56:08 <quicksilver> Cale: it's because we don't want to go through code deployment.
22:56:17 <quicksilver> Cale: it's being able to add content 'live' to a running system.
22:56:32 <Cale> mm, okay
22:56:40 <quicksilver> (at least that's the key reason most places I'm familiar with use it)
22:56:51 <quicksilver> so, a typical blog post interface is a simple example.
22:58:22 <Cale> Okay, it still sounds reasonably trivial though. Maybe I'm not seeing the hideous complication. :)
23:00:06 <quicksilver> Cale: it's trivial in the sense that it doesn't contain any interesting algorithmic challenges.
23:00:18 <mmorrow> rwbarton: ahhh, i keep forgetting that syb is integrated into ghc
23:00:40 <rwbarton> mmorrow: syb-with-class seems significantly cooler
23:01:15 * mmorrow pulls up that code too
23:01:59 <Cale> I guess the two major interesting bits are what language you choose to allow users to write documents, and how you do revision control.
23:02:46 <cjb> quicksilver: yeah.  django gives me this:
23:02:47 <cjb> http://docs.djangoproject.com/en/dev/intro/tutorial01/
23:02:50 <cjb> happs gives me this:
23:02:53 <lambdabot> Title: Django | Writing your first Django app, part 1 | Django Documentation
23:02:53 <cjb> http://happstutorial.com/tutorial/main-function
23:02:54 <lambdabot> Title: Real World HAppS: The Cabalized, Self-Demoing HAppS Tutorial
23:03:05 <cjb> let's see which system I feel more trust towards.  :)
23:03:22 <rwbarton> mmorrow: also: http://lingnerd.blogspot.com/2007/12/pushing-haskells-type-system-to-limits.html
23:03:24 <lambdabot> Title: lingnerd: Pushing Haskell's type system to the limits: A reflective JSON seriali ..., http://tinyurl.com/2o29qu
23:03:38 <mmorrow> rwbarton: you're right
23:03:58 <dons> pretty. style sheets matter.
23:04:23 <dons> cjb: maybe either talk to tphyahoo or lemmih about it, or send them some diffs?
23:04:42 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/happs-tutorial
23:04:44 <lambdabot> Title: HackageDB: happs-tutorial-0.4.3, http://tinyurl.com/6repg4
23:04:44 <dons> is the source.
23:05:36 <rwbarton> mmorrow: on the other hand it all seems so much more complicated than just building instances with TH
23:05:51 <mmorrow> rwbarton: ah, sweet. i think i wasn't clear until now on the whole point of this. do we only care about /to/ JSON?
23:06:04 <rwbarton> mmorrow: No, I just haven't gotten to readJSON yet
23:06:43 <mmorrow> ah, ok. because i think that'll be harder to do with just TH and no help other that a reified Info
23:07:56 <jeffz> Cale: indexing the content so that users can find what they're looking for is the other aspect of a cms, especially if its document agnostic and documents are just binary blobs that are served with a content-type.
23:08:17 <mmorrow> well, actually i don't think it'll be any easier with generics either. any method'll need /some/ help to know how to map JSValue -> a
23:11:08 <rwbarton> mmorrow: won't it just be a similar "case" on the structure of the type a
23:12:27 <mmorrow> but i can't see an obvious canonical map from JSValue -> a for an arbitrary a
23:13:27 <mmorrow> like, what if A is TH.Exp, or Maybe (Int,(Int,Int),((Int,Int),Int))?
23:13:31 <mmorrow> s/A/a/
23:14:01 <rwbarton> I don't see why it's any harder
23:14:14 <rwbarton> of course, not all JSValues will produce valid as
23:14:30 <rwbarton> syb has a gunfold for this kind of problem
23:15:05 <mmorrow> ah, i wasn't taking into account Data. cool
23:17:52 <mmorrow> hmm. but i still don't think i see how to (for some (Data a) => a with a not-written-by-you-instance) know that if a JSValue /does/ produces a valid a, then that a makes any sense
23:18:47 <mmorrow> unless you specialize the translation for each particular type
23:19:02 <mmorrow> which is i believe equiv to just manually writing the JSON instance
23:22:09 <quicksilver> cjb: quite; although obviously poor documentation is not an indicator of poor code design.
23:22:17 <quicksilver> cjb: but it may well be factor in which you choose to use.
23:22:27 <mmorrow> nevermind. i just realized we're serializing a greadable rep
23:22:33 <quicksilver> cjb: catalyst, rails, and django all have orders of magnitude more docs out there.
23:22:39 <quicksilver> (than happs or hope)
23:34:48 <lispy> I have this code that used to compile
23:34:49 <lispy> newtype UniqueT m a = UniqueT (StateT Integer m a) deriving (Functor, Monad, MonadTrans, MonadIO, MonadError (m a))
23:35:38 <lispy> Newer version of ghc says that `MonadError (m a) (UniqueT m)' cannot be derived even with cunning newtye deriving: the eta-reduction property does not hold
23:36:18 <rwbarton> That needs to get added to @ghc
23:36:45 <lispy> ?ghc
23:36:45 <lambdabot> ghc says: Inferred type is less polymorphic than expected
23:37:06 <rwbarton> ?ghc
23:37:06 <lambdabot> ghc says: parse error on input
23:37:08 <rwbarton> ?ghc
23:37:08 <lambdabot> ghc says: From-type of Coerce differs from type of enclosed expression
23:37:13 <rwbarton> there
23:37:57 <lispy> ?index MonadError
23:37:57 <lambdabot> Control.Monad.Error
23:38:05 <lispy> ?docs MonadError
23:38:05 <lambdabot> MonadError not available
23:38:36 <rwbarton> Where is MonadError coming from in that type?
23:38:57 <lispy> what do you mean?
23:39:06 <rwbarton> is there an instance MonadError (m a) (m a)?
23:39:56 <lispy> is MonadError even derivable?
23:40:06 <lispy> I don't know what the error type should be
23:40:10 <lispy> but I know what m should be
23:40:30 <lispy> essentially, I know deriving (MonadError ? m)
23:40:42 <rwbarton> @type throwError
23:40:43 <lambdabot> forall e (m :: * -> *) a. (MonadError e m) => e -> m a
23:41:01 <rwbarton> That could certainly exist in a MonadError (m a) (m a) instance...
23:41:11 <lispy> for whatever reason, I used to be happy with MonadError (m a)
23:41:56 <rwbarton> Do you have an instance MonadError (m a) (m a) somewhere?
23:42:03 <lispy> I don't even think I use I use the MonadError instance
23:42:23 <rwbarton> I can imagine that it would choke trying to replace one of those (m a)s with UniqueT m a, that could plausibly cause "the eta-reduction property does not hold"
23:42:25 <lispy> other than newtype deriving I don't make any instances of MonadError
23:43:11 <lispy> yeah, I don't need the MonadError in there
23:43:20 <lispy> I just killed it and my program still compiles :)
23:44:32 <lispy> ah bummer, the asm code that I generate is not valid on osx
23:44:37 <lispy> ah well, I should put this toy away
23:45:27 <jdrake> Does anyone know how to use the haskell crypto library (http://www.haskell.org/crypto/) to be able to generate public/private key pairs and be able to use them to sign things (and of course verify the signature)?
23:45:28 <lambdabot> Title: The Haskell Cryptographic Library
23:58:47 <hackage> Uploaded to hackage: data-ivar 0.20
