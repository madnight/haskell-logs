00:00:00 <Xenoblitz> dons: no idea what a distro package is :S
00:00:12 <jdrake> Xenoblitz, what operating system are you running?
00:00:36 <Xenoblitz> jdrake: windows
00:00:40 <mmorrow> , let tree _ [a] = x ; tree f (a:b:cs) = tree f (cs ++ [f a b]) in tree (*) [0..3]
00:00:42 <lunabot>  luna: Not in scope: `x'
00:00:46 <mmorrow> , let tree _ [a] = a ; tree f (a:b:cs) = tree f (cs ++ [f a b]) in tree (*) [0..3]
00:00:48 <lunabot>  0
00:00:56 <jdrake> Xenoblitz, can't you use the windows' package?
00:00:57 <mmorrow> , let tree _ [a] = a ; tree f (a:b:cs) = tree f (cs ++ [f a b]) in tree (*) [0..4]
00:00:59 <lunabot>  0
00:01:20 <Xenoblitz> lemme explain a bit more
00:01:22 <mmorrow> , let tree _ [a] = a ; tree f (a:b:cs) = tree f (cs ++ [f a b]) in tree (*) [q..4]
00:01:24 <lunabot>  luna: Not in scope: `q'
00:01:25 <mmorrow> , let tree _ [a] = a ; tree f (a:b:cs) = tree f (cs ++ [f a b]) in tree (*) [1..4]
00:01:26 <lunabot>  24
00:01:37 <Xenoblitz> i have a main file and there are 4 hs files i use
00:01:46 <Xenoblitz> what would be the correct way to do things?
00:01:54 <jdrake> ah
00:02:07 <Saizan> Xenoblitz: ghc --make main.hs
00:02:25 <Saizan> Xenoblitz: where the other 4 files are in the same directory
00:03:12 <Saizan> Xenoblitz: and are in files with names corresponding to their module name
00:03:17 <mmorrow> , let rotl n = uncurry (flip (++)) . splitAt n in rotl 3 [0..9]
00:03:20 <lunabot>  [3,4,5,6,7,8,9,0,1,2]
00:03:21 <mjrosenb> morning all, anyone feel like helping me bootstrap ghc?
00:03:26 <Xenoblitz> Saizan: thanks mate... AGAIN... hehe
00:03:51 <Saizan> :)
00:04:02 <dons> Xenoblitz: ah, so you want ghc installed on your windows box?
00:04:12 <Xenoblitz> no guys its installed on a windows box
00:04:23 <mmorrow> , let rotl n = uncurry (flip (++)) . splitAt n ; rotr n = reverse . rotl n . reverse in rotr 3 [0..9]
00:04:24 <Xenoblitz> i just have no idea what params to pass to ghc and how to compile with other hs files
00:04:25 <lunabot>  [7,8,9,0,1,2,3,4,5,6]
00:04:31 <dons> Xenoblitz: oh, ghc --make A.hs
00:04:42 <Xenoblitz> dons: thanks :0
00:04:45 <Xenoblitz> * :)
00:05:08 <Xenoblitz> what about exe generation?
00:05:22 <dons> that makes an exe.
00:05:26 <dons> A.exe probably.
00:05:38 <Saizan> if A is a Main module with a main function
00:05:54 <dons> intro to haskell: 0.0
00:05:55 <Saizan> s/A is/A contains/
00:05:56 <dons> $ cat A.hs
00:05:56 <dons> main = print "hey yeah"
00:05:56 <dons> $ ghc --make A.hs
00:05:56 <dons> [1 of 1] Compiling Main             ( A.hs, A.o )
00:05:59 <dons> Linking A ...
00:06:01 <dons> $ ./A
00:06:04 <dons> "hey yeah"
00:06:06 <dons> Xenoblitz: done. ^^
00:06:13 <Xenoblitz> oh i c i need a file explicitly called Main.hs
00:06:21 <Xenoblitz> ok no
00:06:23 <Xenoblitz> a Main module
00:06:26 <dons> Xenoblitz: nope. just something with 'main = ...' in it.
00:06:37 <dons> or module Main where main = ... -- if you want to be fancy
00:06:45 <Xenoblitz> ok thanks :)
00:07:23 <mjrosenb> nobody knows about the bootstrapping system for ghc?
00:07:24 <Saizan> module A where main = ... is the only combination that won't work, unless you pass -main-is A to ghc
00:07:37 <mjrosenb> dons: i'm looking at you...
00:07:48 <mjrosenb> dons: you know everything ever about haskell :-p
00:08:13 <dons> mjrosenb: i know about the ghc bootstrapping.
00:08:34 <Samy> dons, have you played with ghc on UltraSPARC/SPARC?
00:08:34 <dons> nobody knows everything about haskell, btw. that's why we have researchers.
00:08:35 <Xenoblitz> thanks Saizan :) that clarified why i didn't get the exe
00:08:38 <dons> to go out an explore the land.
00:08:41 <dons> Samy: yeah
00:08:53 <Samy> I am having a strange issue with libncurses.
00:08:58 <Samy> When I run "ghc", I get the following:
00:09:03 <Samy> ld.so.1: ghc-6.8.3: fatal: relocation error: file /export/home/sbahra/software/lib/libncurses.so.5: symbol main: referenced symbol not found
00:09:14 <Samy> software/lib/ghc-6.8.3/ghc-6.8.3: ELF 32-bit MSB executable SPARC32PLUS Version 1, V8+ Required, dynamically linked, stripped
00:09:20 <dons> huh.
00:09:26 <Samy> Not sure why it is looking for "main" though.
00:09:31 <dons> no libncurses.so.5 ?
00:09:40 <dons> mjrosenb: what was your question, btw?
00:09:46 <Samy> It would say so, if it isn't there.
00:09:58 <Samy> But it's there.
00:09:59 <dons> so ghc was compiled against a C lib you don't have?
00:10:01 <dons> hmm
00:10:07 <Samy> software/lib/libncurses.so:     ELF 32-bit MSB dynamic lib SPARC Version 1, dynamically linked, not stripped, no debugging information available
00:10:12 <dons> right
00:10:23 <Samy> dons, this is the binary build listed on ghc's website
00:10:37 <mmorrow> wow, the reduceron2 code is cool as well. here's the in-hardware garbage collector for reduceron prog example 16 of 16 http://www.cs.york.ac.uk/fp/darcs/reduceron2/source/Red16/Collect.hs
00:10:39 <lambdabot> http://tinyurl.com/4dkmwu
00:11:00 <mmorrow> (it's only about 40 lines)
00:11:04 <dons> huh
00:11:16 <mmorrow> maybe a couple more, but under 100 ;)
00:11:21 * Samy is not sure why that build wasn't just built statically
00:11:29 <mjrosenb> dons: when i attempt to bootstrap ghc on ppc64 linux, the first time the compiler attempts to run, it just hangs
00:12:19 <dons> ok. so there's some problem in the bootstrap.
00:12:27 <dons> at this point, you have to fire up gdb to work out what went wrong.
00:12:27 <mjrosenb> Samy: because static executables are large, and tend to be less portable
00:12:37 <dons> Samy: hmm. good point though.
00:12:43 <mjrosenb> i'll install gdb
00:12:46 <dons> Samy: maybe you can just tweak the sym links.
00:13:04 <mjrosenb> dons: anything i should breakpoint on in particular?
00:15:13 <Samy> mjrosenb, not on Solaris.
00:15:32 <Samy> mjrosenb, or FreeBSD. or NetBSD. or OpenBSD. or anything but Linux :-P
00:16:23 <Samy> Would've added ~25MB, if you include libc.
00:16:39 <Samy> dons, yeah, let me see if libcurses will fool it.
00:17:35 <jdrake> ldd /usr/bin/gedit |wc -l  -> 78 !!!!     gtk2hs app: 46   lots of stuff
00:17:48 <Samy> Appears to be working.
00:17:54 <Samy> ln -s /lib/libcurses.so.1 libncurses.so.5
00:28:05 <tibbe> @seen dons
00:28:05 <lambdabot> dons is in #xmonad, #haskell, #ghc, #darcs and #arch-haskell. I last heard dons speak 8m 6s ago.
00:29:03 <Samy> ye, this isn't very usable
00:29:04 <Samy> owell
00:29:09 <tibbe> dons: I was just reading through Oleg's slides. :) It was funny to see how the Iteratee he defines is more or less exactly the same structure I used for my resumable parser, although I didn't quite realize I could reformulate iteratees in general in this way
00:30:54 <Saizan> where are the slides?
00:30:58 <thoughtpolice> hi tibbe, how goes the hacking?
00:31:13 <tibbe> thoughtpolice: good in theory but I need some more time :)
00:31:24 <tibbe> I more or less have the whole implementation laid out in my head now
00:31:37 <tibbe> but I need time to write an FFI wrapper over epoll
00:31:42 <tibbe> and optimize my parser
00:31:44 <tibbe> and release :)
00:32:57 <tibbe> Saizan: for oleg's talk?
00:33:12 <Saizan> tibbe: yes
00:33:21 <tibbe> Saizan: http://okmij.org/ftp/Haskell/Iteratee/DEFUN08-talk-notes.pdf
00:33:22 <lambdabot> Title: cache:http://okmij.org/ftp/Haskell/Iteratee/DEFUN08-talk-notes.pdf - Google Sear ...
00:33:42 <Saizan> thanks
00:33:55 <tibbe> for comparison here's the parser I wrote http://github.com/tibbe/hyena/tree/master/Hyena/Parser.hs
00:34:00 <lambdabot> Title: Hyena/Parser.hs at master from tibbe's hyena — GitHub
00:45:26 <rwbarton> Has anyone used the GHC Javascript backend from http://vir.mskhug.ru/?
00:45:28 <lambdabot> Title: GHC to JavaScript backend - Trac
00:49:41 <Axman6> rwbarton: that plus squirrelfish extreme could be quite cool
00:58:26 <rwbarton> Axman6: Yeah, I wonder about performance of this kind of thing
00:58:42 <hackage> Uploaded to hackage: yi-vty 0.3
00:58:42 <hackage> Uploaded to hackage: yi-gtk 0.3
01:05:14 <Baughn> Hang on, weren't those packages supposed to be osolete?
01:05:36 <Baughn> ...oh.
01:06:33 <rwbarton> Nice
01:07:48 <Baughn> I'm starting to think Hackage needs better categorization. It's becoming an unholy mess
01:08:03 <Baughn> ..when I first saw it there were, what, fifty packages?
01:15:32 <pastorn> @src foldr
01:15:32 <lambdabot> foldr f z []     = z
01:15:32 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
01:15:37 <pastorn> thank you :D
01:17:50 <stepcut> Baughn: yeah, the worst is multiple categories with slightly different spelling but obviously the same intent
01:19:11 <EvilTerran> perhaps a more active curator would be in order?
01:19:39 <EvilTerran> someone (or group) who could fiddle with what categories things were in
01:19:51 <Baughn> That, and a more interactive page
01:20:20 <Baughn> Some javascript, letting you sort them by (say) popularity, or newness, or...
01:21:27 * Baughn blinks. The game category is increasing, too.. I swear they're /breeding/.
01:25:52 <blakmatrix> yay fredro your back!
01:25:52 <fredro> cnbc world has no actual role
01:28:45 <BeelsebobWork> > let error2 f x y = either Left (\x' -> either Left (f x') y) x in error2 (+) (Left "Jam") (Right 5)
01:28:46 <lambdabot>       No instance for (Num (Either [Char] b))
01:28:47 <lambdabot>        arising from a use of `+...
01:29:48 * BeelsebobWork ponders
01:30:18 <rwbarton> Right . f x' ?
01:30:39 <BeelsebobWork> oh, yah
01:30:46 <BeelsebobWork> > let error2 f x y = either Left (\x' -> either Left (Right . f x') y) x in error2 (+) (Left "Jam") (Right 5)
01:30:48 <lambdabot>   Left "Jam"
01:30:55 <BeelsebobWork> > let error2 f x y = either Left (\x' -> either Left (Right . f x') y) x in error2 (+) (Right 20) (Right 5)
01:30:56 <lambdabot>   Right 25
01:31:02 <BeelsebobWork> :) that's rather nice
01:31:06 <EvilTerran> sounds like some combination of MonadError and MonadReader
01:31:20 <EvilTerran> ?unmtl ReaderT r (Either e) a
01:31:20 <lambdabot> r -> Either e a
01:31:33 <EvilTerran> ?unmtl ErrorT e (ReaderT r) a
01:31:33 <lambdabot> err: `ReaderT r (Either e a)' is not applied to enough arguments, giving `/\A. r -> Either e a A'
01:31:40 <BeelsebobWork> it's just the error monad, but with a load of unnecessary sequentiality taken out
01:33:23 * BeelsebobWork ponders actually -- that could be nicer if there's an error applicative
01:33:57 <quicksilver> the error monad is also an applicative, yes
01:34:21 <quicksilver> BeelsebobWork: isn't that just liftM2 (+) ?
01:34:25 * quicksilver has probably missed something.
01:34:28 <BeelsebobWork> > (+) <$> (Left "Jam") <*> (Right 5)
01:34:29 <lambdabot>       No instance for (Applicative (Either [Char]))
01:34:29 <lambdabot>        arising from a use...
01:34:31 <BeelsebobWork> quicksilver: it is
01:34:37 <BeelsebobWork> awww
01:34:46 <BeelsebobWork> lambdabot at least doesn't know it's an applicative
01:34:59 <quicksilver> wonder where the instance is (or isn't)
01:37:01 <quicksilver> interestingly the Control.Applicative haddock doesn't show Applicative instances for any of the mtl monads
01:37:15 <quicksilver> I wonder if they are really missing, or if that's haddock playing up.
01:37:54 <BeelsebobWork> I would have expected it to be in Control.Applicative.Error
01:37:57 <BeelsebobWork> but that's a no-go
01:38:05 <sjanssen> quicksilver: they're missing
01:38:45 * EvilTerran is rolling a Control.Functor(.*) that will, if i ever get it finished, include such things
01:39:40 <EvilTerran> and a ListT-done-right, of course :P
01:39:51 <Cale> EvilTerran: Have you seen category-extras?
01:39:52 <mmorrow> Baughn: i think if it's organized in some way, the page which lists /every/ package should stay. then there'd be other views of it or something. i really like the list-everything page.
01:40:01 <Cale> EvilTerran: and LogicT?
01:40:05 <EvilTerran> Cale, i have, yes
01:40:07 <Baughn> mmorrow: Oh, sure
01:40:17 <mmorrow> nice, i agree then ;)
01:40:22 <EvilTerran> category-extras is, i feel, excessively rigorous at the expense of being impenetrable
01:40:35 <opqdonut> :d
01:40:35 <Cale> well, yes :)
01:40:40 <opqdonut> isn't that the point
01:40:46 <Baughn> mmorrow: Actually, I think I'll spend some time writing the JS code to do said organization today. It'll be fun. :P
01:40:57 <EvilTerran> i feel there's use for a re-expression of the old Functor/Applicative/Monad heirarchy with current knowledge
01:41:04 <BeelsebobWork> bah
01:41:13 <Cale> It's probably where we're all headed eventually, but perhaps we'll come up with better names for things along the way :)
01:41:18 <EvilTerran> particularly as the do-desugaring is very friendly to cleverness in ghc6.8
01:41:26 <BeelsebobWork> after all that trying to make it neat, I figure out I really am passing data between the arguments and I need a monad :(
01:41:34 <mmorrow> Baughn: nice! i'd js (plus DOM manipulation) is extremely entertaining
01:41:51 <EvilTerran> if (>>=) :: Monad f => ..., fail :: Fail f => ..., and (>>) :: Applicative f => ...
01:42:04 <mmorrow> here's a js interpreter that may help while messing around http://moonpatio.com:8080/jsh.html
01:42:32 <Cale> Wait, can >> be written in terms of Applicative?
01:42:41 <EvilTerran> then (do x; y) :: Applicative f => ..., (do x <- m; y) :: Monad f => ..., and (do Just x <- m; y) :: (Monad f, Fail f) => ...
01:42:50 <EvilTerran> yeah, it's called (*>), isn't it?
01:42:52 <Baughn> mmorrow: Oh, that's handy
01:42:55 <EvilTerran> ?type (>>)
01:42:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
01:42:57 <Cale> hmm...
01:42:57 <EvilTerran> ?type (*>)
01:42:58 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
01:43:06 <Cale> ah, I suppose that's comparable
01:43:06 <EvilTerran> ?src (*>)
01:43:07 <lambdabot> (*>) = liftA2 (const id)
01:43:21 <Cale> > [1,2,3] *> [4,5]
01:43:23 <lambdabot>   [4,5,4,5,4,5]
01:43:26 <Baughn> mmorrow: (It'll be even more handy as an include. I'll just stick that on the hackage page while I'm working on it..)
01:43:27 <Cale> okay, I agree ;)
01:43:28 <mmorrow> Baughn: heh totally. i even implemented a command history (that's slightly buggy. you'll see why). patches welcome!
01:43:33 <EvilTerran> i *think* it has provably the same semantics according to the laws
01:44:00 <EvilTerran> so i plan to put something together that re-exports all the non-replaced bits of the Prelude
01:44:01 <mmorrow> Baughn: yeah, js is so great because you get an "in" on a page, you can manipulate it arbitrarily
01:44:15 <mmorrow> + js's eval function which is the best part of the lang imo
01:44:20 <EvilTerran> so it'd be a case of "{-# LANGUAGE NoImplicitPrelude #-}; import Prelude (); import Control.Functor"
01:44:21 <quicksilver> Cale: yes, the idiom "foo *> bar <* baz" is very useful in parsers.
01:44:27 * Baughn rushes after the bus. Later..
01:44:33 <EvilTerran> as a pseudo-drop-in replacement for the existing Monad heirarchy
01:44:36 <Axman6> @src mod
01:44:37 <lambdabot> Source not found. I feel much better now.
01:44:40 <mmorrow> *once you get an "in" ...
01:44:44 <Cale> EvilTerran: I'd really like to do a new base library with an improved Prelude.
01:44:46 <Axman6> @src divMod
01:44:46 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
01:44:47 <quicksilver> Cale: as in sym "(" *> expr <* sym ")"
01:44:52 <EvilTerran> Cale, don't we all =/
01:45:06 <Cale> EvilTerran: There ought to at least be a darcs repo for it.
01:45:11 <EvilTerran> it's my hope that we can do this piecemeal somehow
01:45:24 <EvilTerran> someone rebuilds the monad heirarchy, someone else rebuilds the numeric heirarchy, ...
01:45:31 <mmorrow> in case anyone is using jsh.html, "clear" clears the screen
01:45:45 <mmorrow> that's the only predefined op
01:45:47 <EvilTerran> people can pair up they're favourite choices in each category
01:45:51 <EvilTerran> *their
01:45:51 <mmorrow> err, s/op/cmd/
01:45:54 <Cale> and if we can just get some crucial features like class aliases into GHC...
01:46:25 <mmorrow> Cale: yes. improving the Prelude definitely
01:46:29 <Cale> With class aliases you could actually improve the numeric hierarchy a lot.
01:46:51 <Cale> Without them, all but a few minor changes are kind of questionable.
01:47:20 <Cale> I would really love to have a proper lattice hierarchy.
01:47:40 <Cale> (as well)
01:48:08 <Cale> But that's something else which kind of needs class aliases to be sane.
01:48:44 <Cale> EvilTerran: More toward the stuff you're doing, you're going to get MonadPlus/MonadZero right, right?
01:49:33 <EvilTerran> i intend to have a Fail class separate to Zero
01:49:41 <EvilTerran> and separate Additive and Alternative classes
01:49:46 <EvilTerran> (both requiring Zero, probably)
01:50:46 <Cale> aha, okay
01:52:01 <EvilTerran> Cale, this kinda thing: http://hpaste.org/10936
01:52:19 <EvilTerran> i think i may try to include the ideas of http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=111 if i can get my head round them, too
01:52:24 <lambdabot> Title: FP Lunch » Blog Archive » Modular Monad Transformers
01:52:29 <EvilTerran> (and if i think it seems appropriate, having done so)
01:54:17 <Saizan> you don't need to have transformers in the prelude or base though
01:54:45 <EvilTerran> not in the prelude
01:55:12 <EvilTerran> i'm just thinking of providing transformers based around my not-your-normal-monad-heirarchy
01:55:26 <EvilTerran> seeing as it's gonna be of slightly limited use if i don't
01:55:34 <ejt> hi, I've installed language-c via 'cabal install' but my ghc can't find it, am I being stupid ?
01:56:28 <Saizan> ejt: ghc-pkg list language-c to check that it's properly installed
01:56:41 <EvilTerran> to prevent name collisions, i intend to put all of this into submodules of Control.Functor instead of .Monad
01:57:03 <EvilTerran> seeing as Functor-ness is the unifying property of functors, monads, and applicatives
01:57:31 <Saizan> ejt: the problem might be that cabal-install defaults to an user install, while runghc Setup.hs defaults to global
01:57:51 <ejt> Saizan: ah, that sounds likely, thx
01:58:10 <ahunter1> @help pl
01:58:10 <lambdabot> pointless <expr>. Play with pointfree code.
01:58:29 <ahunter1> @pl b f g x y = f (g x y)
01:58:29 <lambdabot> b = (.) . (.)
01:59:02 * EvilTerran wanders off
02:01:25 <ejt> Saizan: y, running cabal install as myself rather than root has fixed things
02:10:06 <Cale> http://dontclickthis.whatingods.name/asp-rnd.png -- someone clearly wants Haskell.
02:10:57 <ivanm> Cale: heh, I just saw that
02:11:14 <ivanm> I CAN HAZ DETERMINISTIC RANDOMZ PLZ?
02:11:19 <ivanm> KTHX BY
02:11:34 <BeelsebobWork> @hoogle (k -> l) -> Map k a -> Map l a
02:11:35 <lambdabot> Data.Map mapKeysMonotonic :: (k1 -> k2) -> Map k1 a -> Map k2 a
02:11:35 <lambdabot> Data.Map mapKeys :: Ord k2 => (k1 -> k2) -> Map k1 a -> Map k2 a
02:11:35 <lambdabot> Data.Map mapKeysWith :: Ord k2 => (a -> a -> a) -> (k1 -> k2) -> Map k1 a -> Map k2 a
02:11:36 <musiKk> reminds me of http://xkcd.com/221/
02:11:37 <lambdabot> Title: xkcd - A Webcomic - Random Number
02:11:39 <Cale> :t random
02:11:41 <lambdabot> forall g a. (RandomGen g, Random a) => g -> (a, g)
02:11:54 <Cale> Clearly, that is the function they are looking for :)
02:15:43 <quicksilver> xkcd++
02:15:51 <quicksilver> @where haskell-indentation
02:15:51 <lambdabot> I know nothing about haskell-indentation.
02:15:56 <quicksilver> Cale: !!!!
02:16:02 <quicksilver> ah
02:16:08 <quicksilver> @where kuribas-indentation
02:16:09 <lambdabot> I know nothing about kuribas-indentation.
02:16:25 <quicksilver> Cale: why does lambdabot's where database last about 3 days at the moment?
02:17:07 <ivanm> quicksilver: because that's how long each clone of lambdabot lasts before getting rheumatoid arthritis and alzheimers and has to be put down? ;-)
02:19:34 <cpfr> will cabal-install come bundled with the next release of ghc
02:20:07 <ivanm> cpfr: doubt it
02:20:15 <cpfr> why?
02:20:19 <ivanm> it's a completely separate app
02:20:24 <ivanm> why would it become bundled?
02:20:32 <cpfr> since cabal is bundled
02:20:36 <cpfr> and its part of cabal
02:20:55 <ivanm> it's not part of cabal
02:20:58 <ivanm> it just uses cabal
02:21:02 <cpfr> oh
02:21:07 <ivanm> and has the same name, etc.
02:21:23 <ivanm> it's just a front-end to cabal
02:21:54 <Cale> quicksilver: I have no idea.
02:22:57 <Itkovian> I am being momentarily trying to figure out how to get a ConfigParser that I ca pass on to other functions. From what I understand from the documentation on monadic usage, as I want to get the parser in the main :: IO () function, I should use runErrorT. But do I need to keep all usage of the ConfigParser contained in the do block that is the runErrorT argument?
02:28:18 <Cale> Itkovian: Where is ConfigParser from?
02:28:28 <Itkovian> ConfigFile
02:28:55 <Itkovian> i.e., here http://software.complete.org/static/configfile/doc//ConfigFile/Data-ConfigFile.html
02:28:56 <Cale> okay, I'll have a look
02:28:58 <lambdabot> Title: Data.ConfigFile, http://tinyurl.com/4mnc8k
02:29:48 <Cale> ah, okay
02:30:22 <Cale> Either CPError  should do for the monad m
02:30:23 <Itkovian> If there's no error, I'd like to get the ConfigParser and be able to pass it on. But I've the feeling that may not be possible without either forcing the exception using forceEither or staying in the combined IO/Error monad
02:30:45 <Cale> You can just use a case expression to handle the error:
02:30:56 <Cale> case foo of
02:31:04 <Cale>    Left e -> ... do something with the error ...
02:31:12 <Cale>    Right x -> ... do something with the result ...
02:31:39 <Itkovian> yes, but then that would be required every time I use the parser no? I thought that's part of what the monadic use is trying to prevent
02:33:51 <Cale> okay, so you can also use it in the Either CPError monad, like:
02:33:57 <Cale>  do x <- foo
02:34:10 <Cale>     ... do stuff with x ...
02:34:40 <Cale> But eventually, you need to have a case expression, or an 'either' somewhere.
02:34:42 <Cale> :t either
02:34:44 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
02:34:58 <Itkovian> ok, thx. I'll fiddle some more
02:35:36 <Peaker> :t maybe
02:35:38 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
02:37:28 <Cale> Itkovian: The Either monad just lets you chain together possibly-failing computations so that if one fails, the whole thing does.
02:37:53 <quicksilver> in other words, it's a monad for converting FAIL to EPIC FAIL.
02:38:12 <Axman6> bleh, project euler problem 110 is hard -_-
02:38:52 <Axman6> 108 was fine brute forcing it, but even after doing a lot of readon on the problem, i still can't think of a way to not brute force it
02:40:48 <Axman6> reading even
02:44:19 <magthe> is there some way to find out which package (as listed by ghc-pkg list) provides  a specific module?
02:47:02 <magthe> I found a way go in the other direction, ie from package to modules it exposes, using ghc-pkg describe <pkg>... any ideas?
02:48:03 <quicksilver> magthe: load the module in ghci, run a function from it, and watch what ghci loads :)
02:48:13 <quicksilver> (there should be a better way but I don't know what it is)
02:48:59 <thoughtpolice> magthe: in 6.8.3 you can use 'ghc-pkg find-module <mod>'
02:54:37 <magthe> thoughtpolice: ah, and I'm stuck on 6.8.2 :(  that's good to know though
02:55:05 <magthe> quicksilver: what I ended up doing was using hoogle to look up the function, then check the URL... basically the same thing as you are suggesting ;)
02:56:50 <quicksilver> magthe: :)
02:58:03 * magthe is wondering when ghc 6.8.3 will make it into Debian Sid
02:59:11 <magthe> thanks for your help
03:03:21 <Axman6> !where unfoldr
03:03:25 <Axman6> @where unfoldr
03:03:25 <lambdabot> I know nothing about unfoldr.
03:03:29 <Axman6> @where unfold
03:03:29 <lambdabot> I know nothing about unfold.
03:03:36 <Axman6> @hoogle unfold
03:03:37 <lambdabot> Data.Tree unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
03:03:37 <lambdabot> Data.Tree unfoldForestM :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
03:03:37 <lambdabot> Data.Tree unfoldForestM_BF :: Monad m => (b -> m (a, [b])) -> [b] -> m (Forest a)
03:03:42 <Axman6> hmm
03:03:51 <solrize_> axman6, data.list
03:03:59 <Axman6> ah, cheers
03:04:20 <quicksilver> @index unfoldr
03:04:20 <lambdabot> Data.List
03:04:29 <quicksilver> Axman6: that was the command you wanted :)
03:04:45 <Axman6> thanks :)
03:05:12 <Axman6> you wouldn't happen to have a quick example of how to use unfoldr would you?
03:05:39 <quicksilver> I'm not a big fan of it, to be honest.
03:05:47 <Axman6> fair enough
03:36:28 <Botje> > unfoldr (\l -> if null l then Nothing else Just (splitAt 3 l)) [1..20]
03:36:29 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20]]
03:39:49 <Baughn> @type unfoldr
03:39:50 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
03:40:55 <Baughn> @pl \l -> unfoldr (\l -> if null l then Nothing else Just (splitAt 3 l)) l
03:40:55 <lambdabot> unfoldr (ap (flip if' Nothing . null) (Just . splitAt 3))
03:42:03 <Baughn> @pl \n l -> unfoldr (\l -> if null l then Nothing else Just (splitAt n l)) l
03:42:03 <lambdabot> unfoldr . ap (flip if' Nothing . null) . (Just .) . splitAt
03:50:30 <Stinger_> @ty if'
03:50:31 <lambdabot> Not in scope: `if''
03:50:42 <Baughn> if' p a b = if p then a else b
03:51:09 <Stinger_> @index if'
03:51:10 <lambdabot> bzzt
03:51:15 <Stinger_> heh
03:51:29 <Baughn> It's LB-local, unfortunately. Everyone defines their own, which is sad.
03:51:37 <Baughn> It should be in the prelude. I don't know why it isn't.
03:52:10 <Stinger_> Baughn, along with the above func by Botje
03:52:28 <Baughn> Stinger_: Nah, that one goes in Data.List
04:05:45 --- mode: irc.freenode.net set +o ChanServ
04:12:21 <rlj> i have a haskell program which somehow generates a weird bug i can't understand. when trying to prettyprint a matrix=[[element]] it prints it fine, but after the last row, i get *** Exception: Prelude.(!!): index too large. turns out, haskell says that length matrix = 10 (should be 9), and length (matrix !! 0) through (matrix !! 8) is also 9 (correct). but when i try to figure out what haskell thinks that (matrix !! 9) is, i 
04:16:18 <Stinger_> you got cut off
04:18:55 <Axman6> rlj: you know they indexes are 0 based yes?
04:19:10 <rlj> Axman6: yes
04:19:16 <Axman6> ok, good
04:19:34 <Axman6> want to paste the code (and maybe finish saying what got cut off earlier)?
04:20:09 <rlj> was i cut off=
04:20:09 <rlj> ?
04:20:21 <rlj> lemme paste it
04:26:28 <TheColonial> Hi everyone
04:27:09 <TheColonial> I'm in need of a bit of help with some haskell code i wrote for a Euler problem. it keeps blowing the stack despite my efforts to code for tail recursion
04:27:16 <TheColonial> the only way i can make this work is by increasing stack size..
04:27:27 <TheColonial> would someone mind taking a look at my code and verifying that it's indeed tail recursive?
04:27:36 <quicksilver> sure. paste it to hpaste.org
04:27:46 <TheColonial> okeydokes.
04:28:28 <TheColonial> quicksilver: http://hpaste.org/10940#a0
04:28:47 <Jedai> TheColonial: tail recursive is not always enough in Haskell, it is rather easy for the beginner to build humongous thunk that blow the stack when they finally have to be evaluated
04:29:02 <TheColonial> Jedai: that's what i'm afraid of :)
04:29:19 <TheColonial> Jedai: i'm relatively new to this lang still, and am trying to figure out where i could improve...
04:29:24 <quicksilver> TheColonial: did you compile with optimisation, by the way?
04:29:28 <TheColonial> Jedai: i have a long way to go :P
04:29:41 <TheColonial> quicksilver: erm... no :( ... i'm using ghc..
04:29:52 <TheColonial> quicksilver: which kind of optimisations should I be using?
04:29:57 <quicksilver> ghc -O2
04:30:01 <TheColonial> Jedai: that's why I'm here, so i can learn ;)
04:30:05 <TheColonial> ok, will try that
04:30:13 <Jedai> TheColonial: The first thing that shock me in your code is (l ++ [n])...
04:30:16 <quicksilver> that will turn on the strictness analyzer
04:30:20 <Baughn> I tend to feel it's a good idea to write code that works /without/ optimization, but -O2 does have a good chance of fixing it
04:30:24 <quicksilver> which might catch the thunk.
04:30:58 <Jedai> TheColonial: Adding an element to the end of a list is an expensive operation (O(n)), you should grow this list in the other direction
04:31:19 <Jedai> TheColonial : "(n:l)"
04:31:20 <TheColonial> Jedai: righty ho. that'll be my first change
04:31:45 <TheColonial> quicksilver: Baughn: testing with -O2 now
04:32:17 <clanehin> you may want to rewrite with foldr (if you can) or foldl', it looks like you have a manual foldl which is a known stack blower
04:32:21 <clanehin> I think
04:32:56 <TheColonial> Jedai: quicksilver: Baughn: compiled with -O2 and the suggested fix for (n:l) and boom.. worked great
04:32:57 <rlj> Axman6: found the bug
04:33:01 <TheColonial> going to try without optimisation
04:33:08 <rlj> Axman6: had to to with lazy evalutation of course
04:33:11 <Jedai> TheColonial: Right, the bug is in m'
04:33:19 <TheColonial> clanehin: yes you're right.. that's a noob mistake
04:33:23 <Baughn> TheColonial: Note that, due to laziness, "a ++ b ++ ... ++ zz" is linear in time
04:34:15 <TheColonial> clanehin: are you talking about the attempted "max" function (intuitively called m' ;)) ?
04:34:33 <Jedai> TheColonial: The strictness analyzer found out that the first arg of m' should be strict, but without optimisations, this first argument will grow in a thunk that when evaluated will blow the stack
04:34:42 <rlj> Axman6: turns out i had an off by one error (map'in on [0 .. w*h] instead of [0 .. w*h - 1], so map had already determined that the list should have 10 elements, but not evalutated them. not until asked for. so it actually displayed the whole thing, but when trying to display the 10:th row that i knew should exist, but had yet not been evaluated, it choked because that function in turn could not evaluate the tenth row since i
04:34:46 <Baughn> TheColonial: (Actually, I imagine it'd be linear regardless. Due to laziness it also doesn't blow any stacks.)
04:35:03 <clanehin> TheColonial: yes I think so
04:36:32 <TheColonial> Jedai: I see. which strictness analyser is this? i wasn't aware of it :)
04:36:32 <TheColonial> Baughn: I've removed those appends now
04:36:32 <TheColonial> updated code guys: http://hpaste.org/10940#a1
04:36:33 <Jedai> Baughn: In his case though it don't work that well because it's (...(a ++ b) ++ c) ++ d) .. ) which is quadratic
04:36:33 <Jedai> Baughn: ++ has the right precedence but he construct this one piece by piece so it doesn't matte
04:36:33 <TheColonial> still blows the stack without optimisations on
04:36:33 <quicksilver> Baughn: only because (++) associated to the right.
04:36:33 <quicksilver> ((a ++ b) ++ c ) ++ ....) is quadratic in time.
04:36:36 <quicksilver> and laziness is irrelevant to the essence of this problem
04:36:37 <TheColonial> still blows the stack without optimisations on
04:36:45 <quicksilver> although it certainly makes explanation harder :)
04:36:51 <quicksilver> TheColonial: yes, I'm not surprised.
04:36:56 <TheColonial> i have to say, i love this language
04:37:34 <Jedai> TheColonial: As I said, the problem is that the first argument of m' should be strict, with -O2, GHC use its strictness analyzer and find out this fact but without optimizations...
04:37:35 <quicksilver> TheColonial: you build a huge thunk in the third parameter of 'c'
04:37:38 <TheColonial> Jedai: going back to your comments about strictness... what do you mean "the first argument of m' should be strict"
04:37:42 <Baughn> quicksilver: Yes, it was just a sidenote, and I'm very happy about its associativity.
04:37:43 <quicksilver> sorry, second parameter.
04:37:57 <quicksilver> oh, no you don't.
04:38:03 <TheColonial> Jedai: so what does strict mean in this sense? Sorry, this concept is new to me
04:38:05 <quicksilver> I lie! the pattern match on '1' forces that thunk.
04:38:26 <clanehin> TheColonial: strict == not lazy
04:38:50 <TheColonial> how do i get that kind of output from the strictness analyser? compiling with -O2 just builds without any output. am i missing something else?
04:38:58 <TheColonial> man i hate ramp ups in new languages :) i feel like a noob
04:39:09 <Jedai> TheColonial: "strict" mean that this argument should be forced (evaluated to (weak head) normal form) before each evaluation of the function
04:39:09 <TheColonial> clanehin: i see!
04:39:36 <TheColonial> Jedai: so is there an easy way to force that?
04:39:46 <TheColonial> Jedai: thanks for the explanation by the way
04:40:13 <Jedai> TheColonial: Two : the traditional is : m' h (l:ls) = h `seq` m' (if snd h > snd l then h else l) ls
04:40:41 <Jedai> So seq force the evaluation of it's first argument before it evaluates to the second
04:40:59 <TheColonial> Jedai: right that makes sense.
04:41:07 <TheColonial> Jedai: how does that affect tail recursion?
04:41:15 <Jedai> The less traditional but arguably more aesthetic is : m' !h (l:ls) =  m' (if snd h > snd l then h else l) ls
04:41:32 <Jedai> (which is an extension of GHC, you need to allow it with a pragma)
04:41:32 <TheColonial> so the '!' forces evaluation?
04:41:37 <TheColonial> i see
04:41:37 <Baughn> TheColonial: To weak head normal form, which informally can be called "the least amount of evaluation you could do (assuming it hasn't already been done) and still do some evaluation"
04:42:03 <Jedai> TheColonial: The "!" say that this argument should be strict
04:42:22 <TheColonial> Jedai: thank you :)
04:42:52 <TheColonial> jedai: so how do i enable that via a pragma? is that a cmd line option to GHC?
04:42:56 <Jedai> TheColonial: Or you could just write this with a true foldl'
04:43:10 <TheColonial> Baughn: that kinda made sense ;)
04:43:15 <Jedai> TheColonial: A pragma is an instruction for the compiler in the source, here :
04:43:34 <Jedai> {-# LANGUAGE BangPatterns #-}
04:43:36 <clanehin> TheColonial: relying on tail recursion isn't enough in haskell, this is why it's best to use foldr or foldl'.
04:43:37 <Axman6> TheColonial: you might find $! useful too
04:43:42 <Jedai> at the beginning of the script
04:43:44 <Axman6> @src ($!)
04:43:44 <lambdabot> f $! x = x `seq` f x
04:43:49 <Axman6> saves typing
04:43:56 <TheColonial> ah! so that's what that does!
04:44:11 <TheColonial> Axman6: thanks, I've seen that in code samples around the web and have wondered what that does :)
04:44:16 <Baughn> TheColonial: Once you've got that, note that *everything* is on the heap, so the only way to blow the stack is if "the least amount of evaluation you can do" turns out to be quite a lot of evaluation
04:44:18 <Axman6> :)
04:44:55 <Baughn> TheColonial: Such as (1+ (1+ (1+ (1+...))))) <- Make that chain long enough, and you'll blow the stack. Ints are atomic, so it /has/ to evaluate the whole thing at once
04:44:58 <TheColonial> Jedai: thanks for the ref. i'll take a look
04:45:00 <niklaus> i have a sequence of numbers and an container of size M, if the size of the container is full and the next element is inserted by removing the first element  of the container. the container is ordered by their arrival, Also i need to tell whether the element exists in container if yes the element is updated as the most recent one and the oldest one is removed
04:45:37 <TheColonial> Baughn: right. digesting that :)
04:45:52 <Jedai> TheColonial: In your particular case, the standard library would allow you to write m' in another fashion : "maximumBy (comparing snd)"
04:46:31 <TheColonial> Jedai: I tried that, but i was getting stack overflows still... hence my pitiful manual attempt :) i didn't realise it was the list stuff that was also not helping.. i'll use maximumBy now and see how it goes
04:47:32 <Jedai> TheColonial: maximumBy is not very strict though but with optimisations it becomes so (you can write a strict version easily though)
04:47:34 <TheColonial> Jedai: where do i find comparing?
04:47:36 <niklaus> like for example 1,2,3,4,5,6,7,1,5and size is 5 , initially we have 5 , then 1 is replace by 6 , 2 is replaced by 7, 3 is replaced by 1 (4 5 6 7 1), 5 gets updated (4 6 7 1 5)
04:47:36 <Axman6> Jedai: ah, that's quite useful
04:47:48 <Axman6> the maximumBy (comparing snd) thing
04:48:00 <niklaus> now 8 gives 6 7 1 5 8
04:48:01 <Jedai> TheColonial: In Data.Ord I think
04:48:03 <TheColonial> Data.Ord?
04:48:04 <TheColonial> cool
04:48:07 <TheColonial> thanks
04:48:13 <niklaus> how do i solve
04:48:22 <Axman6> niklaus: so you need some FIFO structure?
04:48:36 <TheColonial> using maximumby still results ina stackoverflow
04:48:50 <niklaus> Axman6, well not really i need to find fast if the element exists or not and remove it
04:48:56 <slarba> hmm. why does forever cause space leaks?
04:49:05 <Baughn> It.. doesn't?
04:49:08 <Axman6> niklaus: Data.Map maybe? i haven't used it though...
04:49:10 <TheColonial> http://hpaste.org/10940#a2
04:49:16 <Jedai> TheColonial: Yes, maximumBy isn't very strict (but with optimisation it is, there are reasons to keep maximumBy lazy in general)
04:49:23 <TheColonial> i see :)
04:49:34 <slarba> Baughn: it seems to. I have a thread forkIO $ forever $ do ... and it leaks
04:49:41 <TheColonial> Jedai: so if i use foldl' i'd be better off?
04:50:09 <Axman6> @src foldl'
04:50:10 <lambdabot> foldl' f a []     = a
04:50:10 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
04:50:12 <Baughn> slarba: It *shouldn't*. Mind pasting your code?
04:50:43 <Jedai> A strict maximumBy is pretty easy to write : maximumBy' cmp = foldl1' (\max x -> if max `cmp` x == LT then x else max)
04:50:49 <quicksilver> slarba: I'm pretty sure forever doesn't leak itself. Something in the forever might leak, though.
04:51:03 <slarba> hmm ok
04:51:23 <TheColonial> Jedai: I haven't learnt this much about a lang in ages :)
04:51:24 <Baughn> slarba: Do you happen to keep any state between iterations?
04:51:45 <quicksilver> slarba: like stuffing an increasingly large unforced thunk into a 'state' variable, for example :)
04:51:58 <TheColonial> i got it to work
04:52:10 <slarba> the forever is in a ReaderT IO e monad
04:52:12 <Jedai> TheColonial: Haskell is very different from the mainstream, which makes it pretty interesting (whether you choose to use it after or not)
04:52:26 <TheColonial> crap... kid's awake.. brb (http://hpaste.org/10940#a3)
04:52:31 <Jedai> It blows your mind !!
04:53:04 <niklaus> i need a container where i can find ,update and remove element fast. what is that in haskell
04:53:17 <Jedai> niklaus: Set ?
04:53:17 <Baughn> niklaus: Data.Map?
04:53:22 <slarba> and oh... -O2 "enables" the leak, but without that compilation option it doesn't
04:53:51 <Jedai> niklaus: I'm not sure what you mean by "updating" an element though
04:54:48 <quicksilver> slarba: Ah, that sounds like a known GHC bug.
04:55:02 <slarba> quicksilver: I'm compiling with ghc6.8.3
04:55:10 <slarba> okay
04:55:37 <Baughn> quicksilver: Do you recall the bug id number?
04:56:03 <quicksilver> Yes, I have an index of bug id numbers in my head which I recite on the way to work each day. ;-P
04:56:12 <quicksilver> just trying to find it
04:56:12 <slarba> :))
04:57:43 <quicksilver> hmm. my google-fu fails me.
04:58:13 <Baughn> A true master would say, he has failed his google-fu
04:59:19 <niklaus> Jedai Baughn, updating an element is like updating the age of the element in the sequence if it already exists, u update with the most recent index
05:00:36 <Baughn> niklaus: Sounds like just just want a map
05:00:41 <Jedai> niklaus: A double Data.Map then (age, elem), I know there was a package on Hackage
05:02:13 <Jedai> Baughn: With just a map, normal removal would be costly, no ? (since you need the older elem)
05:02:44 <Baughn> Jedai: I don't know. He hasn't described his problem very well.
05:02:59 <Baughn> He should be able to do it with a map, though. Possibly more than one, but anyhow maps.
05:03:01 <quicksilver> slarba, Baughn : the bug I was thinking of was a bug with the so called 'state hack' GHC uses on IO
05:03:06 <quicksilver> but I could be wrong.
05:03:10 <quicksilver> and I can't find the bug
05:03:54 <Baughn> quicksilver: That's the sort of bug that should necessitate an immediate bugfix release, though
05:05:47 <Jedai> Baughn: I think I understand now : He has a set of element of limited size, he wants to remove the oldest element if he try to add an new element (different from the others) to a saturated set, so he has to keep track of the insertion order (which is modified even if the added element was already in the set and the set himself doesn't change as a result)
05:05:47 <TheColonial> Jedai: Sorry about that, i have a 8 month old who wakes a lot during the night at the mo.
05:06:28 <luqui> I suspect a Queue (Data.Sequence) together with a Map would do nicely
05:07:03 <Jedai> luqui: I think if we do it that way we don't need a Map, a Set is enough
05:07:15 <luqui> ah, I came in late.
05:07:51 <niklaus> Baughn, in a map if we order by the time of arrival ie index of the element (and the map size is bounded less than size of sequence) , then how do we find if a element exists in it or not
05:08:22 <niklaus> Jedai, what is a double Data.Map ?
05:08:38 <luqui> I think it's a bidirectional map.
05:09:00 <Jedai> luqui: But I'm not too sure, maybe with a Map (elem, age) and a queue of elem (with Data.Sequence), we could have normal update in O(1) and special update in O(log M)
05:09:01 <luqui> in the "bimap" package on hackage
05:09:40 <luqui> Jedai: how are you ever going to get a normal update in O(1)?
05:09:53 <Jedai> luqui: normal update in O(log M) too in fact... In fact it seems pretty good, I don't know which is better bidimap or this
05:10:32 <TheColonial> Jedai: according to GHC, -O2 makes it twice as fast
05:10:35 <Jedai> It's all in the constant factors there
05:10:46 <TheColonial> everyone: thanks for the help with my problem. greatly appreciated, I have learned a lot. :) Ciao for now!
05:10:51 <luqui> TheColonial, that's what the 2 stands for :-)
05:10:56 <Axman6> heh
05:11:12 <TheColonial> luqui: yeah, but that doesn't always result in 2x ;) in this case it did
05:11:21 <Axman6> "-O2 a guaranteed speed up by a factor of 2 for all programs"
05:11:23 <luqui> it was a joke
05:11:27 <TheColonial> luqui: i know ;)
05:11:28 <Jedai> TheColonial: Don't listen to luqui ! (and know that there are much quicker solutions to this problem too)
05:11:44 <TheColonial> Jedai: aye, i can imagine. mine is rather naive
05:11:54 <TheColonial> do you have time to share your views on how you'd approach this problem?
05:12:24 <Jedai> TheColonial: I can paste you my solution, which is pretty fast (and not too complex too)
05:12:55 <Jedai> TheColonial: It's a dynamic programming solution in Haskell, lazy immutable arrays are pretty good for that
05:13:04 <TheColonial> I'd love to see it please :0
05:13:32 <TheColonial> Jedai: I may have questions ;0
05:14:04 <Axman6> what's the original problem?
05:14:06 <Jedai> TheColonial: What's the number of the problem ?
05:14:10 <TheColonial> 14
05:14:20 <TheColonial> http://projecteuler.net/index.php?section=problems&id=14
05:14:21 <lambdabot> Title: Problem 14 - Project Euler
05:14:58 <Axman6> i should really do that one
05:14:59 <TheColonial> ah, i'm guessing you needed that to check through your own archived solutions ;)
05:15:19 <TheColonial> I've done a fair few of these to learn Haskell, but no doubt some of my solutions are hardly optimal
05:15:25 <TheColonial> hence revisiting a few to see how i can improve
05:15:27 <luqui> ah, I saw the best solution in my mind, but I was too lazy to implement it that way :-)
05:15:41 <TheColonial> luqui: feel free to share it now ;)
05:16:19 <Jedai> TheColonial:  http://hpaste.org/10940#a4
05:17:07 <TheColonial> wow :)
05:17:11 <TheColonial> some new stuff in here for me
05:17:51 <Jedai> (as I use maximumBy, you need to compile with -O2 to avoid blowing the stack, but that's really not the core of the solution, I could just use the maximumBy' defined above and it would work well)
05:17:58 <luqui> ah it's a limited cache ; cache all numbers <= 1000000, recompute for numbers greater
05:18:07 <TheColonial> ah i see
05:18:32 <Jedai> luqui: Yep, on my computer it get the solution in less than 2s
05:18:38 <luqui> nice
05:18:46 <TheColonial> Jedai: very quick :)
05:18:55 <TheColonial> now i need to digest wtf it's doing :D
05:19:04 <Jedai> luqui: Which is reasonably fast (you can undoubtedtly do faster though)
05:19:19 <luqui> mine mind-solution was to use an infinite memo structure
05:19:33 <luqui> (not a list though, something treelike)
05:20:12 <Jedai> luqui: This one runs slower (I tried), the limit on the cache size is pretty important for the performance I think
05:20:39 <luqui> hmm, I feel like comparing :-)
05:21:28 <Xenoblitz> guys... if you have something like type Apple = Int why can't you show something of type Apple as if it were an Int?
05:21:39 <Xenoblitz> and is there a way to work with this?
05:21:41 <TheColonial> Jedai: 1sec without -O2.... 0.46 with -O2
05:21:44 <TheColonial> impressive ;)
05:21:52 <TheColonial> mine was 7 seconds with -O2 :)
05:22:33 <Jedai> TheColonial: You have a fast computer ! :-)
05:22:38 <TheColonial> yes i do :P
05:22:48 <TheColonial> recently bought an XPS
05:22:58 <TheColonial> tis rather beefy
05:23:02 <nha__> any reasons why <<< and >>> are not defined by the Control.Arrow on this machine haha
05:23:42 <nha__> ghc 6.9.20080117
05:24:03 <Xenoblitz> is what i asked something very very obvious?
05:24:15 <Jedai> Xenoblitz: You're mistaken I think, type doesn't change anything to the instances (though newtype or data does)
05:24:30 <Xenoblitz> hmmm
05:24:35 <TheColonial> hoogle's reference for assocs isn't there
05:24:39 <TheColonial> wierd
05:24:46 <TheColonial> no page found
05:24:53 <Zao> nha__: That 6.9 sounds awfully old.
05:25:19 <nha__> is the Control.Arrow stuff older than 2008?
05:25:26 <TheColonial> @src assocs
05:25:26 <lambdabot> assocs arr@(Array l u _) = [(i, unsafeAt arr (unsafeIndex (l,u) i)) | i <- range (l,u)]
05:25:27 <Xenoblitz> Jedai can i paste the error here? (3 lines)
05:25:31 <TheColonial> ooo :)
05:25:56 <TheColonial> that is hard to digest, can someone give me a clue as to what assocs does?
05:26:01 <TheColonial> please :)
05:26:13 <TheColonial> ah! i think i get it.
05:26:31 <Jedai> TheColonial: it just returns a list of (index, element) for a given array
05:26:38 <TheColonial> Jedai: right i see. cheers.
05:27:07 <Jedai> TheColonial: of course, in most cases the whole list never goes into memory
05:27:29 <Jedai> Xenoblitz: You can but type isn't the problem
05:27:36 <Xenoblitz> Couldn't match expected type `[Char]' against inferred type `Gravity'
05:27:36 <Xenoblitz> In the second argument of `(++)', namely `g'
05:27:36 <Xenoblitz> In the second argument of `text', namely `("Speed:" ++ g)'
05:27:56 <TheColonial> Jedai: see where you have "syrs n = a" .. then "where a =listArray..... " -- why don't you just do "syrs n =listArray....."
05:28:05 <hugo_> hello
05:28:08 <Jedai> Xenoblitz: And the definition of Gravity ?
05:28:20 <Xenoblitz> Jedai: type Gravity = Int
05:28:31 <Jedai> TheColonial: because I use "a" in syr
05:28:58 <TheColonial> ah i see :)
05:29:04 <Jedai> @type (++)
05:29:05 <lambdabot> forall a. [a] -> [a] -> [a]
05:29:25 <Xenoblitz> ok wait i guess i have to explicity use show
05:29:28 <Jedai> Xenoblitz: Int isn't a list, so (++) won't work on it...
05:29:33 <Jedai> Xenoblitz: Yes
05:30:32 <Xenoblitz> thanks mate
05:30:40 <Xenoblitz> silly mistake number 193,123,120
05:30:40 <Xenoblitz> lol
05:30:47 <TheColonial> Jedai: one last question. is list comprehension faster than map in the case you use it?
05:30:51 <Jedai> Xenoblitz: You're welcome ^^
05:31:01 <TheColonial> ie.. [syr x | x <- [2..n]]
05:31:07 <Jedai> TheColonial: No, it's translated to a map anyway
05:31:10 <TheColonial> instead of map syr [2..n] ?
05:31:14 <TheColonial> ah :)
05:31:41 <TheColonial> ok well thank you very much for your help
05:31:50 <TheColonial> i'm heading to bed. i look forward to chatting to you all again.
05:31:51 <Jedai> TheColonial: In fact I should probably use map (I had something more complicated there before)
05:31:52 <TheColonial> cheers!
05:32:03 <Jedai> TheColonial: Good night :-)
05:32:04 <TheColonial> Jedai: cool :) looks fine to me anyway!
05:32:09 <TheColonial> Jedai: Night :D
05:35:19 <ejt> do I have to import something to make [] an instance of Typeable and Data ? (I'm playing with Data.Generics)
05:37:37 <nha__> hmm
05:39:57 <byorgey> ejt: [] has kind  * -> *, so you would have to make it an instance of Typeable1, not Typeable
05:40:03 <byorgey> it isn't an instance of Typeable1 already?
05:40:33 <ejt> hang on, I'll paste
05:40:45 <int-e> instance [overlap ok] Typeable1 [] -- Defined in Data.Typeable
05:41:04 <byorgey> I thought so
05:41:45 * byorgey has never actually played around with Typeable
05:42:22 <ejt> http://hpaste.org/10945
05:44:20 <Itkovian> What is the best way to obtain a nonce in String format? I thought to use Codec.Encryption.RSA.NumberTheory.randomOctet :: Int -> IO String but alas, running Codec.Binary.Base64.decode on that for use in hmac_sha1 yields Nothing rather than Just x
05:49:00 <ivanm> wow, would you look at the size of that netsplit! :o
05:51:29 <Axman6> @oesis 6 21
05:51:32 <Axman6> @oeois 6 21
05:51:33 --- mode: irc.freenode.net set +o ChanServ
05:51:34 <lambdabot>  Triangle of trinomial coefficients T(n,k) (n >= 0, 0<=k<=2n), read by rows (...
05:51:34 <lambdabot>  [1,1,1,1,1,2,3,2,1,1,3,6,7,6,3,1,1,4,10,16,19,16,10,4,1,1,5,15,30,45,51,45,3...
05:51:34 <lambdabot>  Triangle of trinomial coefficients T(n,k) (n >= 0, 0<=k<=2n), read by rows (...
05:51:34 <lambdabot>  [1,1,1,1,1,2,3,2,1,1,3,6,7,6,3,1,1,4,10,16,19,16,10,4,1,1,5,15,30,45,51,45,3...
05:51:34 <Axman6> rawr
05:53:17 <int-e> @users
05:53:17 <lambdabot> Maximum users seen in #haskell: 512, currently: 509 (99.4%), active: 6 (1.2%)
05:56:02 <maltem> ejt: I don't know anything about the Typeable stuff, but see the paste annotation for how you could use "everywhere"
05:56:46 <ejt> maltem: I think that's exactly what I'm missing
05:56:52 <ejt> thankyou
05:57:54 <maltem> ejt: heh, I had a look for some examples to get an idea of Data.Generics and the first example I found involved "everywhere" :)
05:58:14 <maltem> ejt: it seems though that the type annotation for transform is obligatory
06:00:58 <lilac> maltem: is that just the monomorphism restriction? if you inline 'transform' does it work?
06:01:22 <chrisdone> lilac, my arch enemy!
06:01:26 * chrisdone throws lambdas
06:02:24 <maltem> lilac: oh, now that I try it again, it works inline, and without annotation
06:02:30 * lilac ducks
06:02:53 * lilac shoots arrows
06:03:04 <maltem> I must have messed up something earlier... there was some existential stuff shouting at me
06:03:30 <maltem> bad parentheses I guess
06:05:07 <mmorrow> , everywhere (mkT (+1))  ((0,(0,0)),(((0,0),0),0))
06:05:10 <lunabot>  ((1,(1,1)),(((1,1),1),1))
06:06:21 <thoughtpolice> i like uniplate :]
06:06:39 <EvilTerran> isn't "everywhere" SYB?
06:07:06 <maltem> SYB?
06:07:13 <EvilTerran> Scrap Your Boilerplate
06:07:22 <EvilTerran> Data.Typeable, Data.Generics, and Data.Dynamic
06:08:40 <maltem> ah, you referred to thoughtpolice
06:08:47 <EvilTerran> yes
06:09:51 <byorgey> @index everywhere
06:09:51 <lambdabot> Data.Generics.Schemes, Data.Generics
06:10:02 <thoughtpolice> EvilTerran: yeah it is SYB, i'm just sayin'
06:10:10 <EvilTerran> oh, ok :)
06:11:34 * byorgey upgrades QuickCheck! =D
06:18:27 <maltem> , (everywhere . mkT) (+1) (0,(0,0))
06:18:29 <lunabot>  luna: Inferred type is less polymorphic than expected
06:18:29 <lunabot>    Quantified type variable `a' escapes
06:19:04 <maltem> lilac: I think that was it
06:19:58 <Saizan> ?ty Data.Generics.mkT
06:19:59 <lambdabot> forall b a. (Typeable b, Typeable a) => (b -> b) -> a -> a
06:21:00 <maltem> @type everywhere
06:21:01 <lambdabot> forall a. (Data a) => (forall a1. (Data a1) => a1 -> a1) -> a -> a
06:21:33 <Axman6> say i have a function f (a,b) = ..., is there an easy way of storing the results of all (a,b) pairs so they don't need to be recomputed? momoizing or something...
06:21:59 <luqui> Jedai, frustrated, he gives up.  Suffice to say it is _significantly_ slower to cache everything using a power-of-two memo table
06:22:04 <dancor> @pl \ f (x:xs) -> (f x):xs
06:22:04 <lambdabot> (`ap` tail) . (. head) . ((:) .)
06:22:07 <Baughn> Axman6: If you add an Ord constraint to that, you can stick it in a Map
06:22:14 <dancor> i feel like i've tried to make this cool before too
06:22:28 <dancor> i guess i'll write onHead?
06:22:30 <maltem> Axman6: Try and define a map (or array, depends on your data) at top-level
06:22:30 <Axman6> since this thing's going to be called on all the numbers [(a,b) | a <- [0..20], b <- [0..20]]
06:22:44 <Baughn> Axman6: That's just 4000 numbers. Actually..
06:22:47 <Baughn> Axman6: I'd use Array
06:22:58 * Itkovian remains flabbergasted
06:23:04 <dancor> > 21 * 21
06:23:05 <lambdabot>   441
06:23:13 <Baughn> O(4000).
06:23:16 <maltem> Axman6: you mean, f is recursive?
06:23:17 <Itkovian> @type sequence $ take 8 $ repeat (getStdRandom ( randomR(0,255)) :: IO Int)
06:23:18 <lambdabot> IO [Int]
06:23:26 <Itkovian> @type (>>=)
06:23:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
06:23:34 <dancor> big-lol notation
06:23:44 <Axman6> maltem: yes, the function is:  (a,b) = 1 + ( y `par` x) + y where x = f (a,b-1); y = f (a-1,b)
06:23:47 <Itkovian> @type (return . (map Data.Char.chr))
06:23:49 <lambdabot> forall (m :: * -> *). (Monad m) => [Int] -> m [Char]
06:23:53 <Axman6> f  (a,b) = 1 + ( y `par` x) + y where x = f (a,b-1); y = f (a-1,b) *
06:24:02 <Itkovian> So why does this not combine?
06:24:13 <Baughn> Axman6: Bad math aside, you could make an array with those for indexes; they're element-lazy, so tying the knot works fine
06:24:29 <Axman6> eh?
06:24:53 <maltem> yea you'll be fine with an array
06:24:54 <Itkovian> @type sequence $ take 8 $ repeat (getStdRandom ( randomR(0,255)) :: IO Int) >>= (return . (map Data.Char.chr))
06:24:55 <lambdabot>     Couldn't match expected type `IO Int' against inferred type `[Int]'
06:24:55 <lambdabot>       Expected type: IO Int -> b
06:24:55 <lambdabot>       Inferred type: [Int] -> [Char]
06:25:14 <Saizan> @type (sequence $ take 8 $ repeat (getStdRandom ( randomR(0,255)) :: IO Int)) >>= (return . (map Data.Char.chr))
06:25:15 <lambdabot> IO [Char]
06:25:21 <Itkovian> Grrr
06:25:24 <Itkovian> :-/
06:25:58 <Baughn> Axman6: Um. To demonstrate...
06:26:17 <Axman6> that would be much appreciated :)
06:26:24 <Itkovian> thx!
06:27:12 <Baughn> > let fibs = array (0,5) (0 : 1 : [fibs ! n-2 + fibs ! n-1 | n <- [2..5]]) in fibs
06:27:13 <lambdabot>       Occurs check: cannot construct the infinite type: e = (i, e)
06:27:14 <lambdabot>        Exp...
06:27:36 <Cale> > let fibs = listArray (0,5) (0 : 1 : [fibs ! n-2 + fibs ! n-1 | n <- [2..5]]) in fibs
06:27:37 <lambdabot>   array (0,5) [(0,0),(1,1),(2,* Exception: stack overflow
06:27:50 <Cale> > let fibs = listArray (0,5) (0 : 1 : [fibs ! (n-2) + fibs ! (n-1) | n <- [2..5]]) in fibs
06:27:51 <lambdabot>   array (0,5) [(0,0),(1,1),(2,1),(3,2),(4,3),(5,5)]
06:27:55 <Baughn> Thanks. ^_^
06:28:06 <Baughn> Axman6: Anyway, that's an array that's defined by reference to itself
06:28:15 <Axman6> hmm
06:28:20 <Baughn> Axman6: As array lookup is O(1), it's also a very useful device
06:28:40 <Axman6> i'm not sure how i'd use that for my problem :\
06:28:43 <Baughn> Axman6: And so long as there are no actual /loops/ in the definition, it'll Just Work
06:29:17 <Baughn> Axman6: Well, simple. Instead of defining a function, at the top level, define an array with the appropriate indices that contains the values you want
06:29:19 <Axman6> what's ! do?
06:29:32 <Cale> array indexing
06:29:37 <Axman6> ok
06:29:37 <dancor> @hoogle (!)
06:29:37 <lambdabot> keyword !
06:29:37 <lambdabot> Data.IntMap (!) :: IntMap a -> Key -> a
06:29:37 <lambdabot> Data.Map (!) :: Ord k => Map k a -> k -> a
06:29:53 <dancor> hoogfail
06:29:55 <Baughn> Axman6: They'll be evaluated lazily, but memoized for the next lookup
06:30:11 <Cale> :t (Data.Array.!)
06:30:12 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
06:30:15 <Axman6> what's the (0,5) out the front for?
06:30:23 <Cale> Array bounds
06:30:28 <Baughn> Anything in Ix will work
06:30:42 <Baughn> (So ((0,0),(20,20)) is perfectly valid)
06:30:44 * dancor thought all the cool kids used 1-indexed Array's
06:30:59 <Axman6> hmm, ok
06:31:08 <Cale> If you want 1-indexed, or even 7-indexed arrays, you can have them ;)
06:31:19 <Baughn> Cale: I want Pi-indexed arrays.
06:31:26 <Axman6> i always missed 7 indexed arrays when doing C :(
06:31:36 <Cale> heh,  instance Ix CReal where ...
06:31:51 <Itkovian> Given that I have an IO String, and a function decode :: String -> Maybe [Word8], how to get the IO value into the decode?
06:32:01 <Itkovian> >>= is not an option, obviously
06:32:10 <Baughn> Itkovian: >>=
06:32:30 <Itkovian> Baughn: erm, no because the monads are different, no?
06:32:36 <Itkovian> In any case it does not work
06:32:43 <Baughn> @undo do string <- getString; return (decode string)
06:32:43 <lambdabot> getString >>= \ string -> return (decode string)
06:32:55 <Baughn> @. pl undo do string <- getString; return (decode string)
06:32:56 <lambdabot> decode `fmap` getString
06:33:13 <Cale> fmap
06:33:16 <Cale> yeah
06:33:19 <Baughn> ...good pl, there
06:33:21 <BONUS> > (return "aa" :: IO String) >>= Just . (++ "haha")
06:33:22 <lambdabot>   Couldn't match expected type `IO b'
06:33:29 <BONUS> > (return "aa" :: IO String) >>= return . Just . (++ "haha")
06:33:30 <lambdabot>   * Exception: "<IO (Maybe [Char])>"
06:33:43 <Itkovian> ok, thx.
06:34:00 <Cale> Itkovian: but both the output of @pl and Baughn's input to it are relevant there:
06:34:05 <Cale> do string <- getString; return (decode string)
06:34:12 <Cale> you should know how to do it that way :)
06:34:35 <Cale> decode `fmap` getString  or  fmap decode getString   are more elegant
06:35:25 <Axman6> Baughn: yeah i have no idea how to start making this array :( i (think) i get your example, but i have no idea how to use them for my problem
06:35:28 <Baughn> @type (Just . (++ "haha")) <$> getLine
06:35:29 <lambdabot> IO (Maybe [Char])
06:36:10 <Baughn> @src (<$>)
06:36:11 <lambdabot> f <$> a = fmap f a
06:36:11 <PeakerWork> @unpl  (Just . (++ "haha")) <$> getLine
06:36:11 <lambdabot> ((\ d -> (Just) (d ++ "haha")) <$> getLine)
06:48:01 <hugo_> im using lookup function to put the values into a type constructor, but the type constructor accepts String, and the lookup returns "Maybe String", how do i change it ?
06:49:07 <geezusfreeek_> hugo_, i usually answer these sorts of questions with fmap.
06:49:23 <hugo_> hmm :D
06:49:31 <hugo_> lookup seemed so fine
06:50:05 <geezusfreeek_> if you have f :: a -> b and a value x :: Maybe a, then you can do fmap f x :: Maybe b
06:50:10 <lilac> hugo_: what do you want to happen when you look up a key which isn't present?
06:51:50 <hugo_> lilac, load a default value
06:52:03 <Deewiant> ?ty maybe
06:52:04 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
06:52:16 <Deewiant> ?ty fromMaybe
06:52:18 <lambdabot> forall a. a -> Maybe a -> a
06:56:35 <vegai> @users
06:56:35 <lambdabot> Maximum users seen in #haskell: 514, currently: 506 (98.4%), active: 16 (3.2%)
06:57:56 <Axman6> Baughn: any chance you could have a look at my code?
06:58:51 <Axman6> @oeois 2 6
06:58:52 <lambdabot>  Euler totient function phi(n): count numbers <= n and prime to n.
06:58:52 <lambdabot>  [1,1,2,2,4,2,6,4,6,4,10,4,12,6,8,8,16,6,18,8,12,10,22,8,20,12,18,12,28,8,30,...
07:00:12 <Deewiant> @oeis 0,2,6
07:00:13 <lambdabot>  Oblong (or pronic, or heteromecic) numbers: n(n+1).
07:00:13 <lambdabot>  [0,2,6,12,20,30,42,56,72,90,110,132,156,182,210,240,272,306,342,380,420,462,...
07:01:38 <Axman6> > 20*21
07:01:40 <lambdabot>   420
07:03:21 <Axman6> if someone could have a look at this for me, i'm appreciate it :\ http://hpaste.org/10947
07:03:52 <Axman6> the array is supposed to give the same answer for (n,n) as f (n,n)
07:07:23 <BeelsebobWork> what extension do I need to get recursive do notation?
07:09:19 <Saizan> Axman6: http://hpaste.org/10947#a1
07:09:50 <Saizan> BeelsebobWork: RecursiveDo
07:10:00 <BeelsebobWork> cheers Saizan
07:10:40 <Saizan> Axman6: the key is to use the array for the recursive calls
07:11:23 <Saizan> Axman6: which in turn will evaluate the function the first time you access that value, but later will just return the value
07:12:18 <Axman6> well, it works, except it's not giving me the right answer (which is my fault, the array works extremely well)
07:12:36 <Saizan> Axman6: however the needed sharing is obtained only if the array is a CAF, using (arr n) multiple times like before would create a new array each time
07:12:53 <Axman6> ah yes
07:13:21 <Axman6> this is for http://projecteuler.net/index.php?section=problems&id=15 if you're interested
07:13:22 <lambdabot> Title: Problem 15 - Project Euler
07:13:35 <Axman6> need to figure out the maths...
07:14:48 <Axman6> @oeois 2,6,20
07:14:49 <lambdabot>  Central binomial coefficients: C(2n,n) = (2n)!/(n!)^2.
07:14:49 <lambdabot>  [1,2,6,20,70,252,924,3432,12870,48620,184756,705432,2704156,10400600,4011660...
07:17:30 <Axman6> well, that's the right sequence. now i need to figure out how to arrive at that formula (i was getting there)
07:21:07 <Axman6> oh damn, it's just nCr
07:21:14 <Axman6> which makes sense
07:26:37 <Xenoblitz> is Picosec really used in the Time module? and is there perhaps something more accurate?
07:31:46 <Axman6> Xenoblitz: huh?
07:31:56 <dmead> haskell!!
07:31:57 <Axman6> i'd guess they only use nano seconds
07:32:03 <dmead> does anyone call haskell from delphi?
07:32:12 <dmead> i've got a lecacy delphi app i need to call haskell from
07:32:13 <Baughn> Xenoblitz: Picoseconds are insufficiently accurate for you?
07:32:20 <Xenoblitz> no no
07:32:21 <Baughn> Xenoblitz: Then I've got news for you, boy..
07:32:27 <Xenoblitz> its that i always get picosec = 0
07:32:32 <Baughn> Right.
07:32:32 <Xenoblitz> milliseconds would be fine by me
07:32:33 <Axman6> Xenoblitz: oh, heh, i thought you said Time Machine, and i thought i was in #macosx
07:32:48 <Baughn> Xenoblitz: Well, they /could/ be used. It's for future-proofing, basically
07:33:12 <Xenoblitz> Baughn: thanks for the clarification
07:34:08 <Baughn> Xenoblitz: As computers get faster, their clock accuracy also increases. You can easily get microsecond resolution for timers by picking the right API now, which would've been unthinkable ten years ago (on PCs)
07:34:13 <Baughn> Of course, to go from there to picoseconds...
07:34:32 <Xenoblitz> i'm writing an interactive program with haskell
07:34:45 <Xenoblitz> and i need something in the range of milliseconds i guess
07:34:55 <Xenoblitz> is it possible with any module you guys know of?
07:35:22 <Baughn> Data.Time?
07:35:55 <Xenoblitz> I'll look it up
07:36:20 <Baughn> Xenoblitz: Actually, System.Time would be best
07:36:35 <Baughn> Data.Time has lots of date manipulation stuff, but not much for actually timing things
07:36:35 <quicksil1er> nope.
07:36:40 <quicksil1er> System.Time is deprecated.
07:37:28 <Baughn> In 6.8.3?
07:37:31 <quicksil1er> 'getCurrentTime' from Data.Time.Clock is your wall-clock timer.
07:37:34 <Baughn> Well, okay. Then what?
07:37:39 <quicksil1er> Baughn: deprecated in 6.6, IIRC.
07:37:51 <Baughn> quicksil1er: The documentation doesn't /say/ so. :/
07:38:00 <quicksil1er> that doesn't make it any less true.
07:38:14 <Baughn> It still works, too
07:38:21 <quicksil1er> sure.
07:38:31 <quicksil1er> but it has a subtly broken API and some things are very hard in it.
07:38:36 <Baughn> ..I thought the point of deprecating things is so people will stop using it
07:39:14 <Xenoblitz> btw is there a place where the most recent stuff is ONLY shown?
07:39:26 <Xenoblitz> i  doubt this page i am using ... zvon.org is the latest
07:39:38 <quicksil1er> Baughn: since it continues to work there is no particular reason to force people to stop.
07:39:49 <quicksil1er> Baughn: but I recommend people use Data.Time.Foo for new code.
07:40:06 <bd_> quicksil1er: Shouldn't deprecated things have been killed when ghc made other incompatible API changes?
07:40:14 <bd_> like, say, the split-base stuff
07:40:14 <Baughn> quicksil1er: Not "force", but just writing "This module is subtly broken, we suggest using Data.Time for new code" in the documentation would be good
07:40:25 <Baughn> quicksil1er: Then you won't have to hang around to tell us. :P
07:41:26 <mmorrow> is there an english/cs word for (arity::function), but (???:type), where ??? `elem` {monomorphic,polymorhic}?
07:41:55 <mmorrow> so call this word "asdf", then
07:42:06 <mmorrow> arity : function -> Int
07:42:23 <mmorrow> asdf : type -> {"polymorphic","monomorphic"}
07:42:33 <mmorrow> arity `analogous` asdf
07:42:38 <mmorrow> (== True)
07:42:40 <quicksil1er> no, I don't believe there is.
07:42:49 <Baughn> Morphicisity?
07:42:51 <quicksil1er> "polymorphism" is hte closest I can think of.
07:42:56 <mmorrow> hmm
07:43:19 <quicksil1er> Xenoblitz: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
07:43:19 <lambdabot> Title: Haskell Hierarchical Libraries
07:43:23 <quicksil1er> Xenoblitz: is what I used.
07:43:34 <quicksil1er> Baughn: there is a deprecation note in some very recent version, I believe.
07:43:48 <Xenoblitz> quicksilv1er: thanks mate
07:44:05 <Baughn> quicksil1er: 6.10.1, you mean?
07:44:28 <Axman6> 6.10 hasn't been released has it?
07:44:42 <quicksilver> Baughn: I'm not sure :)
07:45:11 <mmorrow> Baughn: heh, Morphicity sounds the best so far
07:45:21 <Baughn> quicksilver: 6.8.3 doesn't have it, so 6.10.1 it is
07:55:46 <Axman6> rawr, the language J annoys me. it's totally unreadable
07:56:11 <lilac> Axman6: you're just not l33t enough :)
07:56:25 <Axman6> Central Binomial Coefficient in J: (! +:) 20x  -- which is (nCr 40 20)
07:56:25 <quicksilver> that's it's raisin d'eater!
07:56:52 <lilac> Axman6: oh come on, that's completely obvious! :D
07:57:08 <Axman6> i get the factorial part, but... nothing else
07:57:15 <Axman6> i understand 20 too >_>
07:57:40 <Axman6> is +:) the nCr clown?
07:58:48 <lilac> i think in this context +: means 'double'
08:02:10 <__me> http://jsoftware.com/help/dictionary/vocabul.htm
08:02:15 <lambdabot> Title: Vocabulary
08:02:34 <__me> http://jsoftware.com/help/dictionary/d102.htm
08:02:35 <lambdabot> Title: +: Double &#149 Not-Or
08:03:30 <Axman6> yeah...
08:03:34 <Axman6> that... retarded
08:03:38 <Axman6> 's*
08:03:48 <lilac> but what does "20x" mean?
08:05:27 <Xenoblitz> are there any examples of the usage of Data.Time.Clock running around cause I can't figure it out :(
08:05:30 <lilac> 20x3 apparently means 20 * e^3
08:05:39 <Axman6> J makes brainfuck look sensible
08:05:58 <maltem> and is (! +:) double the factorial, or the factorial of the double value?
08:06:15 <lilac> is it a list of a factorial function and a doubling function?
08:07:05 <lilac> presumably it's something like "(! +:) 20" is a list of 20! and (2*20)!, and the x means '\a b -> b / a / a' ?
08:07:38 <Axman6> the function is f n = (2n)!/(n!)^2
08:08:57 <lilac> ah
08:09:05 <lilac> ! as a dyad means nCr
08:09:17 <lilac> ! only means factorial as a monad.
08:09:25 <Axman6> ...
08:09:51 * maltem agrees with Axman6 on the ...
08:10:12 <lilac> so (! +:) means \n -> (+: n) ! n
08:10:14 <Axman6> stupidest. language. ever
08:11:14 <quicksilver> although also, in some sense, the cleverest :)
08:11:40 <Axman6> it's a look how awesome and fucked in the head language
08:12:12 <Axman6> in the head i am*
08:14:10 <Axman6> there should be some annotation for haskell to say momoize this function
08:14:16 <lilac> @type let n `c` r = product [r+1..n] / product [1..n-r] in (c=<<(*2))20
08:14:17 <lambdabot> forall a. (Enum a, Fractional a) => a
08:14:23 <lilac> > let n `c` r = product [r+1..n] / product [1..n-r] in (c=<<(*2))20
08:14:24 <lambdabot>   1.3784652882e11
08:14:49 <Axman6> lilac: use `div`
08:15:11 <lilac> so "(! +:)" ~> "c=<<(*2)"
08:16:05 <Axman6> does anyone agree with me on the momoisation thing? :\
08:16:11 <lilac> Axman6: i've wanted a 'plz be memoizing' thing before, but people have always pointed out that saying 'plz be memoizing' doesn't provide the compiler with enough info to do it
08:16:27 <lilac> (not sure if i agree with that position, though...)
08:16:31 <Axman6> how come?
08:16:40 <dolio> You can pretty easily construct your own memoization combinators.
08:16:52 <lilac> people usually say things like "you want to clear out the cache sometimes"
08:17:10 <Axman6> but what if you don't?
08:17:16 <Axman6> i like a full cache!
08:17:57 <Axman6> anyway something like f &a &b = someComplicated thing `using` a / somethingElse on b
08:18:14 <lilac> Axman6: how you do that depends on the input type of the function
08:18:16 <Axman6> trust me, that function works >_>
08:18:54 <lilac> Axman6: it's pretty easy to write functions of the form (Ord a) => (a -> b) -> (a -> b) which memoize
08:19:10 <Axman6> but i'd like to not have to :\
08:19:13 <lilac> heh
08:19:22 <dolio> Write a library and re-use it, then.
08:19:25 <Axman6> i mean, it doesn;t sound all that hard to me
08:19:34 <lilac> also, 'pretty easy' may involve unsafePerformIO depending on implementation choice
08:19:47 <dolio> No, you don't need unsafePerformIO.
08:19:57 <lilac> depending on implementation choice
08:19:58 <Axman6> could it not just use an array or something?
08:20:12 <lilac> Axman6: not without enumerating all the possible keys up front
08:20:19 <lilac> the same problem defeats Data.Map
08:20:19 <Axman6> yeah... well a map then
08:20:24 <Axman6> how come?
08:20:47 <Axman6> maybe something like a map in STM?
08:20:52 <lilac> because you either need to (perhaps lazily) enumerate all the keys before the first lookup, or you need to change the set of keys as items are requested
08:21:12 <lilac> structural recursion on the type is possible too, but none of these things can be done with just an Ord constraint
08:21:22 <Axman6> well, you do a lookup, if it's not there, you calculate it, and insert it no?
08:21:35 <lilac> "insert it" how?
08:21:48 <lilac> that wouldn't be pure
08:21:59 <Axman6> i was assuming Data.Map worked like a hashmap in other languages, i could be wrong?
08:22:48 <Axman6> couldn't you use STM? that seems to store some kind of state...
08:22:51 <lilac> Data.Map is a balanced binary tree
08:23:04 <Axman6> oh, heh, fair enough
08:23:39 <lilac> STM, ST, IO, State, etc. all don't save the day if you want memo :: (Ord a) => (a -> b) -> (a -> b) and not (a -> b) -> (a -> IO b)
08:23:40 <Axman6> i guess the whole idea makes it non functional
08:23:47 <Deewiant> well it /could/ be a hash table, it would just have a constraint other than Ord and be much less performant
08:24:01 <lilac> my favourite is the structural recursion method
08:24:15 <quicksilver> to do a really elegant kind of memoisation you essentially need something slightly lower level than haskell.
08:24:29 <quicksilver> you want to hook into the thunk-replacement strategy of your RTS
08:24:35 <Axman6> quicksilver: that's what i was thinking.
08:24:40 <lilac> memoBool f = let true = f True; false = f False in \b -> case b of True -> true; False -> false
08:24:44 <quicksilver> in order to generalise the solution that arrays give you.
08:25:07 <quicksilver> however there are some remarkably clever hacks you can do.
08:25:27 <quicksilver> lilac: that needs another parameter (perhaps a dummy parameter) to memoize
08:25:52 <Axman6> i thought for a long time that GHC used the fact that since you're guaranteed to get the same output for each input for a function, it would only evaluate that function with that input once, and use a stored value from there on
08:26:18 <lilac> quicksilver: i don't follow. what have i messed up?
08:26:18 <quicksilver> nope.
08:26:24 <quicksilver> everyone thinks that, Axman6
08:26:29 <quicksilver> it would be horrible if it did, though.
08:26:36 <quicksilver> (I mean, 'many people thought that once')
08:26:39 <dolio> Axman6: That uses potentially tons of memory. :)
08:26:43 <lilac> Axman6: "optimizing for space leaks"
08:27:11 <quicksilver> lilac: nothing, I misread it ;)
08:27:15 <Deewiant> it could save it to disk every now and then
08:27:16 <Axman6> quicksilver: that's why i'm thinking some kind of annotation where you can say "ok, tis thing's expensive, and called often with the same values, please remember it's value"
08:27:19 <Deewiant> which would be cool in some sense
08:27:20 <quicksilver> lilac: you did have an extra parameter and I was too stupid to see it.
08:27:23 <Deewiant> but probably not very practical
08:27:37 <Axman6> dolio: i know, that's why i want an annotation, so the developer can make the call for their situation
08:27:39 <quicksilver> Axman6: yeah, it's a very reasonable thing to ask for.
08:27:41 <lilac> quicksilver: the idiom forces the extra parameter to be somewhere silly ;D
08:28:18 * lilac wonders if you can generate memoBool from a Typeable constraint
08:28:19 <Axman6> like i said, f &a &b = momoise f a b
08:28:58 <lilac> Axman6: it's memo (as in memory), not momo</pedant>
08:29:08 <Axman6> ok, how about it out it this way, if it's not done in 5 years, i'm doing my PhD on implementing it :P
08:29:43 <Axman6> lilac: yeah, i say the word correctly in my head, i just have the wrong typing pattern in my fingers ;)
08:32:55 <Axman6> quicksilver: i just don't see how the idea is all that different to f !x for strictness
08:35:24 <quicksilver> Axman6: it's completely, utterly different.
08:35:31 <geezusfreeek> Axman6, a strictness annotation is not an optimization detail
08:35:36 <quicksilver> Axman6: you're talking about creating new thunks to store the values of cached computations.
08:35:44 <geezusfreeek> it's a change in algorithm
08:35:45 <quicksilver> that's nothing like adding a !
08:35:51 <Axman6> ok then
08:36:00 <quicksilver> still I see no reason why it shouldn't exist as a compiler pragma.
08:36:11 <geezusfreeek> yes, it would be a handy pragma
08:36:11 <Axman6> so two things then, what is the purpose of !, and what's a thunk?
08:36:12 <Deewiant> well, ! is often treated as an optimization detail anyway
08:36:31 <geezusfreeek> Deewiant, it is, but so is any other way of restructuring an algorithm :)
08:36:54 <Deewiant> alright, I suppose so :-P
08:37:27 <Axman6> i often use it to stop stack overflows  :\
08:37:34 <Axman6> i probably shouldn't, but meh
08:37:45 <quicksilver> @wiki Thunk
08:37:45 <lambdabot> http://www.haskell.org/haskellwiki/Thunk
08:37:55 <Axman6> cheers
08:38:21 <geezusfreeek> Axman6, a thunk is a reference to a computation that hasn't been evaluated yet. pattern matching evaluates thunks. ! also evaluates thunks
08:38:22 <lilac> I would think it should be implemented as a derivable typeclass
08:38:59 <Axman6> lilac: i was thinking that too
08:39:27 <mmorrow> heh, i just stack overflowed the typechecker
08:39:41 <Deewiant> O_o
08:39:42 <geezusfreeek> mmorrow, undecideable instances?
08:39:44 <Axman6> i mean, if you were to use it in a hashmap, it's have to be hashable...
08:40:14 <mmorrow> oh yeah, i do have that on
08:40:27 <mmorrow> {-# LANGUAGE TemplateHaskell, NoMonomorphismRestriction, UndecidableInstances #-}
08:40:43 <jpcooper> are computations memo-ised by default in GHC?
08:40:52 <Axman6> apparently not
08:40:53 <mmorrow> geezusfreeek: is that a somewhat common occurence with undecidable instances?
08:41:06 <mmorrow> or just a /possible/ occurence ;)
08:41:09 <ziman> only the named ones (constants)
08:41:21 <geezusfreeek> mmorrow, that is what undecideable means :)
08:41:29 <BONUS> hmmm just thinking
08:41:33 <geezusfreeek> it means you may get stuck in an infinite loop
08:41:37 <BONUS> is there any context in haskell that im not thinking of right now
08:41:44 <BONUS> where types aren't preceded with a ::
08:41:49 <geezusfreeek> if you do get stuck in such a loop it is a pretty sure bet that you have a type error anyway though
08:42:06 <Deewiant> BONUS: type Foo = Bar -- ;-)
08:42:07 <quicksilver> BONUS: when you define them for the first time?
08:42:12 <quicksilver> type,newtype,data
08:42:13 <BONUS> oh yeah, DOH
08:42:54 <geezusfreeek> jpcooper, until you get used to it, the semantics of haskell may make it _appear_ as if it sometimes memoizes things, but it actually does not
08:43:13 <geezusfreeek> ghc adds no memoization to your program though
08:43:18 <lilac> Axman6: I think you can write a structurally-recursive memo :: (Data a) => (a -> b) -> (a -> b)
08:43:23 <Axman6> is there actually any use in defining a datatype data Foo = Bar?
08:43:55 <Deewiant> there's even use for datatypes without constructors, data Foo
08:43:55 <jpcooper> geezusfreeek, are there any extensions which enable this?
08:44:47 <geezusfreeek> jpcooper, nope. at best we could add a pragma to ghc to selectively do this, but even that is not in ghc at this time
08:44:55 <geezusfreeek> there are other ways to memoize anyway though
08:45:03 <jpcooper> okay
08:45:06 <geezusfreeek> it is at worst no harder than in any other language
08:45:36 <geezusfreeek> just make a persistent loop table, or whatever fits best
08:45:46 <geezusfreeek> s/loop/lookup/
08:46:27 <quicksilver> geezusfreeek: I think you could argue that GHC does sometimes memoize things. It memoizes lets until they go out of scope.
08:46:42 <quicksilver> that's not required by the language report or the understood semantics.
08:46:43 <geezusfreeek> quicksilver, that is what i meant when i said that it could _appear_ to memoize things
08:46:52 <geezusfreeek> ah, you are right there
08:46:53 <quicksilver> but it's common to all haskell implementations I know of.
08:47:16 <quicksilver> it's generally understood (but not written down!) that giving things names introduces sharing.
08:47:16 <geezusfreeek> it also "memoizes" CAFs
08:47:27 <quicksilver> I consider it to be a shortcoming of the report that it doesn't make this explicit.
08:47:41 <quicksilver> it's just one of these pieces of wisdom people pass around word-of-irc ;)
08:47:44 <daf> yes
08:47:54 <daf> it's a bit of a stumbling block, I think
08:48:54 <Axman6> haha, i love my girlfriend, she just told me how much she loves me because i sent her a fibonacci sequence of msn kisses
08:49:42 <rog_> geezusfreeek: i've been wondering about this. i'm writing a system in which the results of some functions come from running an external simulation that might take hours or days. obviously memoisation would be useful here. but the moment i memoise, i lose access to laziness (i.e. i can't have an infinite list of results of such a function). any way around this?
08:49:55 <mmorrow> geezusfreeek: heh
08:50:06 <pcapriotti> is it possible to define scanl on a Foldable?
08:50:52 <rog_> geezusfreeek: i've been wondering if this might be a canonical time to use uncheckedIO
08:50:58 <mmorrow> geezusfreeek: so i guess that means you can do arbitrary recursion in the type system with undecidable instances?
08:51:11 <geezusfreeek> rog_, memoization != strictness :)
08:51:12 <mmorrow> here's the minimal code that shows this loop http://hpaste.org/10948
08:51:25 <Axman6> rog_: i see no reason why not
08:51:53 <geezusfreeek> rog_, for example, consider a lazy lookup table. simply define it as if every cell was filled and then whenever you look into it the table is filled
08:51:59 <rog_> geezusfreeek: except that if you're using a monad to do your memoisation, then you can't use sequence on an infinite list.
08:52:03 <Axman6> i'm nowhere near being an expert, but i have a pretty clear idea of how my implementation of the memoisation would work
08:52:39 <geezusfreeek> mmorrow, yes, arbitrary recursion with undecideable instances
08:53:01 <rog_> geezusfreeek: i think my problem comes where i've got two independent computations both of which wish to use the same memoisation.
08:53:49 <rog_> geezusfreeek: one produces an infinite list. the other uses that list (without knowing how it was produced)
08:54:17 <geezusfreeek> what part of this setup needs to be memoized?
08:54:21 <geezusfreeek> the elements of the list?
08:54:34 <mmorrow> geezusfreeek: sweet
08:55:04 <rog_> geezusfreeek: the elements of the list, yes - they are a result of the memoised function (amongst other things)
08:55:42 <zachk> java makes me want to vomit
08:55:56 <Axman6> how come?
08:56:04 <rog_> actually i think i've realised the answer: rather than having [a], i need [MemoMonad a] and the consuming function needs to be aware of the memoisation process.
08:56:25 <geezusfreeek> rog_, that would be one acceptable approach
08:56:29 <rog_> ... which it's currently not. monads are infectious, it seems.
08:56:36 <zachk> i prototyped a cs assignment in haskell and im converting it into java, and it is just tedious and boring and i dont have map or map like constructs D:
08:57:36 <Axman6> zachk: for (Object o : objects) { f(o);}?
08:57:47 <Zao> Axman6: Getting a collection out of it is more bothersome.
08:57:53 <rog_> i think this is why at worst haskell can be harder to use memoisation in than some other languages, because the "side-effectful" memoisation cannot hide behind the usual fn interface.
08:58:05 <Axman6> though, Java whinges of you do that, so you have to use ListIterators...
08:58:09 <Axman6> if*
08:58:24 <geezusfreeek> rog_, another way would be to have a top-level data structure indexed by the parameters of the function you want to memoize. it will never be garbage collected as long as it is a CAF, and you can lazily look up values from it
08:58:43 <geezusfreeek> rog_, then your list would basically be a series of lazy lookups into that structure
08:58:43 <Axman6> what is a CAF anyway?
08:59:05 <geezusfreeek> Axman6, constant applicative form. a top level constant that will not be garbage collected
08:59:12 <geezusfreeek> look it up for more details
09:00:00 <geezusfreeek> another way would be to use unsafePerformIO to store memoized values in IORefs
09:00:10 <rog_> geezusfreeek: presumably that data structure would have to be in the memoisation monad, so there's not that much difference.
09:00:25 <geezusfreeek> rog_, what memoization monad are you talking about? one you defined yourself?
09:00:32 <rog_> geezusfreeek: yes
09:00:41 <geezusfreeek> rog_, such a data structure needn't be in a monad
09:00:56 * lilac thinks that perhaps a (Data a) constraint isn't sufficient for memoization
09:01:08 <rog_> geezusfreeek: but if it isn't in a monad, i'd have to manually thread the state
09:01:18 <Axman6> well, at least i got you all talking about it
09:01:36 <lilac> @hoogle (Data a) => a -> (Constr, [Data b => b])
09:01:36 <lambdabot> Parse error:
09:01:37 <lambdabot>   --count=20 "(Data a) => a -> (Constr, [Data b => b])"
09:01:37 <lambdabot>                                                ^
09:01:54 <geezusfreeek> rog_, i think you must misunderstand me
09:02:06 <rog_> geezusfreeek: it's very likely!
09:02:17 <geezusfreeek> maybe i should do a blog post about this. it seems like there is interest
09:02:24 <geezusfreeek> i don't have the time to go into more detail right now
09:02:26 <geezusfreeek> i must get back to work
09:02:45 <rog_> geezusfreeek: ok.
09:03:31 <rog_> geezusfreeek: FWIW, the reason i'd need more than you suggested is that the memoisation process might not have indefinite-extent storage.
09:04:05 <quicksilver> a nice RTS hook might have configurable cache size
09:04:11 <geezusfreeek> ah, then some sort of monad may at least be useful, but i would have to think about it a bit
09:04:13 <quicksilver> for the memoisation process.
09:04:26 <rog_> geezusfreeek: so a never-GCd data structure wouldn't be appropriate.
09:04:41 <geezusfreeek> rog_, yes, i see what you mean
09:05:00 <rog_> geezusfreeek: also in this case, i'd probably be caching some of the results in external storage
09:05:11 <geezusfreeek> ah, definitely a monad then
09:06:04 <rog_> ... but uncheckedIO (the devil on my shoulder speaking) would allow me to hide it all under a superficial veneer of respectability...
09:06:31 <geezusfreeek> rog_, it is not necessarily evil if you maintain a pure interface
09:06:39 <lilac> is it possible, given "(Data a) => a", to produce a list of constructor arguments "[(forall b. Data b) => b]"?
09:06:47 <geezusfreeek> you simply must be careful
09:07:32 <quicksilver> lilac: I think so, yes.
09:07:49 <quicksilver> don't ask me to do it, though :)
09:08:23 * lilac stares at the type of gfoldl until brain ache ensues
09:08:29 <geezusfreeek> Am I evil if my source of power is Satan but i only use it for good?
09:08:29 * Axman6 just added a redirect from haskellwiki/CAF to haskellwiki/Constant_applicative_form
09:08:44 <rog_> geezusfreeek: this was my dilemma
09:09:00 <lilac> geezusfreeek: i think that makes you batman
09:09:57 <geezusfreeek> batman has only one rule
09:10:02 <geezusfreeek> is that his semantics?
09:12:25 <Baughn> geezusfreeek: It seems to me that, if satan is willing to lend you power in order to use it for good, then satan's evilness may have been overstated. Remember who wrote the book that claims he is.
09:13:11 <geezusfreeek> Baughn, either that or i sold him my soul in order to gain that power, but i may use it however i wish
09:15:15 <Baughn> geezusfreeek: That would make you someone who'd sacrifice everything for others, then. Hardly evil.
09:15:49 <geezusfreeek> but i use the power of SATAN (but yeah, that was my point. using unsafePerformIO doesn't have to be evil)
09:16:07 <Baughn> I think we've taken this analogy far enough. ^^;
09:16:28 <Baughn> Any moment now we'll have people stating they don't believe in unsafePerformIO
09:16:39 <Baughn> ..or perhaps they just don'T believe in safePerformIO?
09:18:12 <zachk> "I make peace, I create evil" --God from the bible, the author of evil is clearly god
09:18:43 <Baughn> "The chroot jail is needed because Cabal builds can invoke arbitrary code. " <-- chroot is NOT FOR SECURITY, damnit
09:19:05 <Baughn> zachk: Well, doh. That comes with being omnipotent.
09:19:54 <osfameron> doesn't omnipotence just mean that you *could* create evil if you wanted to
09:19:57 <zachk> God being all knowing, and all powerful, is an acceptable thesis, but when you add in all Good, it makes no sense and contradicts the judeochristian god's scriptures
09:20:02 <zachk> he has created evil
09:20:09 <dblazakis> Baughn: does it matter? you better trust what you're compiling, we don't have an evilness static analysis yet
09:20:36 <Baughn> dblazakis: Most OSs do have mechanisms to jail packages, however. It's just that chroot isn't it.
09:20:43 <Baughn> *jail package build
09:20:44 <Baughn> s
09:21:00 <dblazakis> Baughn: sure, but is it worth it? i guess...
09:21:05 <Baughn> In any case, a false sense of security is far worse than knowing it isn't safe
09:21:08 <geezusfreeek> zachk, it depends on if "free will" is considered good. in my opinion, it is the reason for the existence of evil
09:21:17 <dblazakis> Baughn: yeah, i agree
09:21:23 <ddarius> zachk: God doesn't have to follow his own rules.
09:21:23 <lambdabot> ddarius: You have 1 new message. '/msg lambdabot @messages' to read it.
09:21:24 <Baughn> geezusfreeek: Traditionally, and in the bible, free will was considered evil
09:21:44 <Baughn> geezusfreeek: It's notable that Lucifer rebelled because he wanted to have free will
09:22:29 <geezusfreeek> isn't that a self-reliant statement though? in order to rebel he must have had free will to begin with
09:22:54 <Baughn> Right, but he wasn't supposed to /use/ it
09:23:10 <Baughn> Same as with humans. We have free will, but we're supposed to follow yaweh's every whim.
09:23:45 <Baughn> ..it's irrelevant, I guess. Norse mythology's more amusing anyhow.
09:23:55 <geezusfreeek> i would suggest that we take this to #haskell-blah, but i should probably just get off irc so i can work ;)
09:23:59 <thoughtpolice> totally worth reading
09:24:14 <ddarius> Norse mythology rocks.
09:24:28 <geezusfreeek> bye everyone
09:24:30 <Baughn> It's certainly more consistent than christianity. :P
09:24:34 <thoughtpolice> #haskell can be anything you want it to be
09:24:35 <Baughn> THey even got the number of planets right
09:24:36 <thoughtpolice> :]
09:25:27 <Philonous> I'm wondering: If trees get a new ring every year, don't they stop being a tree?
09:25:46 <Baughn> ..norse mythology has nine worlds. Midgard is supposed to be the third. That's.. just freaky.
09:26:04 <ddarius> Baughn: Pluto isn't a planet.
09:26:10 <Baughn> ddarius: I was talking about Eris
09:26:45 <Baughn> ddarius: Although, there are /still/ gravitational anomalies suggesting we do have a tenth planet. Eris isn't nearly massive enough.
09:26:49 <Baughn> Now if only we could /find/ it..
09:27:16 <Baughn> ..then again, we may have gotten gravity horribly wrong
09:28:21 <Philonous> ddarius: It was a planet until 2006, And I suppose norse mythology is a little older
09:29:08 <Baughn> Philonous: Indeed it is. Norse mythology is far older - older than the discovery of /planets/, in fact.
09:30:00 <Baughn> At least up here, but even if you consider information exchange with arabia or something, they still didn't know they numbered nine
09:32:25 <dblazakis> @pl \(a,b) -> (b,a)
09:32:26 <lambdabot> uncurry (flip (,))
09:32:38 <dblazakis> :t flip
09:32:39 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
09:33:35 <mrd> Baughn: I thought that was debunked because the Voyager and Pioneer probes didn't show any orbital discrepancies
09:33:38 <dancor> do ppl distiguish funcs loosely having a type and strictly having a type?  by which i mean every function is (loosely) :: a -> b for some a and b (only constants do not even loosely have this type).  whereas id strictly :: a -> a
09:34:04 <mrd> dancor: no
09:34:09 <Baughn> mrd: In a sense. Problem is, the planets still do
09:34:27 <dancor> and (+ (1 :: Int)) is loosely a -> a but strictly Int -> Int
09:34:30 <dancor> mrd: heh ok
09:34:31 <Baughn> There are quite a few people trying to make sense of that one. ^^;
09:34:39 <mrd> dancor: (+ (1::Int)) is Int -> Int
09:35:22 <Baughn> dancor: Subtypes?
09:35:28 <quicksilver> dancor: yes, people distinguish.
09:35:31 <mrd> Haskell doesn't have subtypes
09:35:37 <quicksilver> dancor: every function 'unifies with' a -> b
09:35:45 <quicksilver> dancor: but id actually 'has the type' a -> a
09:35:46 <dancor> mrd: well here's an example where i'm starting to think about "loose" types: is there an f with const f :: a -> b -> a, and if so what are the possible types of f
09:35:58 <Baughn> mrd: The type inference engine might not, but they're still useful for reasoning about
09:35:59 <mrd> that f = const
09:36:02 <mrd> @type const
09:36:03 <lambdabot> forall a b. a -> b -> a
09:36:15 <quicksilver> people also speak of principle types.
09:36:27 <dancor> :t const const
09:36:28 <lambdabot> forall a b b1. b1 -> a -> b -> a
09:37:36 <mrd> @type const unsafeCoerce
09:37:37 <lambdabot> Not in scope: `unsafeCoerce'
09:38:12 <mrd> @hoogle unsafeCoerce
09:38:13 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
09:38:17 <ddarius> :t const const 'a'
09:38:18 <lambdabot> forall a b. a -> b -> a
09:38:35 <mrd> @type const Unsafe.unsafeCoerce
09:38:36 <lambdabot> Couldn't find qualified module.
09:38:40 <mrd> @type const Unsafe.Coerce.unsafeCoerce
09:38:42 <lambdabot> forall a b b1. b1 -> a -> b
09:38:53 <dancor> that's a -> b -> c
09:38:55 <mrd> yea
09:41:03 <dancor> so if f unified with some a_f -> b_f then can we express the type of const f
09:42:15 <dancor> all functions are "really" unary anyway right?
09:42:24 <dancor> they can just produce functions
09:42:27 <mrd> I don't think there's a typesafe f such that const f :: a -> b -> a
09:42:41 <wjt> @help djinn
09:42:41 <lambdabot> djinn <type>.
09:42:42 <lambdabot> Generates Haskell code from a type.
09:42:42 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
09:42:50 <wjt> hmm, not going to help though
09:42:51 <Baughn> dancor: Not in any real sense, since no evaluation will take place until they've accumulated all their arguments
09:43:13 <wjt> @ty const (const undefined)
09:43:15 <lambdabot> forall a b b1. b1 -> b -> a
09:43:16 <Baughn> dancor: That is, foo a b = ... isn't operationally equivalent to foo x = ... \y -> ...
09:43:18 <wjt> ah.
09:43:45 <Axman6> @djinn m a -> m b -> m (a -> b)
09:43:45 <lambdabot> -- f cannot be realized.
09:44:12 <mrd> the problem is that you are trying to take "const :: b -> a -> b" and find a parameter which can somehow turn that into "const f :: a -> b -> a" but that would require obtaining the "a" which is discarded by const.
09:44:28 <Deewiant> const (flip unsafeCoerce), no?
09:44:33 <Deewiant> or, er
09:44:36 <Deewiant> flipping that is kinda pointless
09:44:44 <BMeph> So, has a convo ever been transferred off of -blah, for being "too off-off-topic"? ;)
09:44:45 <Deewiant> but in any case
09:44:45 <mrd> then you end up with a -> b -> c
09:44:47 <Deewiant> const unsafeCoerce
09:45:00 <ddarius> BMeph: Yes.
09:45:33 <BMeph> ddarius: ...were you involved? ;)
09:45:52 <ddarius> I don't think so.  It's happened more than once.
09:46:18 <BMeph> Oh, okay. It's still awesome-sounding. :)
09:47:28 <ddarius> You do realize off-topic in #haskell-blah is Haskell.
09:47:56 <dancor> so for f g to make sense you need f :: a -> b1 -> .. -> bn and g :: b1 -> .. -> bn -> c  ?
09:48:36 <byorgey> dancor: no, for f g to make sense you need  f :: a -> b  and g :: a.
09:48:44 <byorgey> where b could be an arrow type.
09:48:54 <byorgey> well, so could a for that matter
09:49:31 <BMeph> ddarius: Technically, Haskell is the only off-topic for -blah, right? :)
09:50:03 <dancor> is -blah so -blah that it could create a topic it couldn't move
09:51:15 <ddarius> BMeph: Technically.
09:51:21 <dancor> i still think it's correct in some sense to think about functions taking their first arg to the others, for this..
09:51:50 <byorgey> dancor: what do you mean?
09:52:00 <dancor> the part where a can be an arrow type is throwing me off
09:52:14 <dancor> for things like figuring out if any f have const f :: a -> b -> a
09:52:27 <byorgey> dancor: note that -> parenthesizes to the right
09:52:38 <byorgey> so f :: a -> b -> a  is really f :: a -> (b -> a)
09:52:53 <lilac> dancor: it is correct to think of a -> b -> c as being a function which takes an a and returns a function of type b -> c
09:53:10 <byorgey> if you had a function whose argument was an arrow type, you'd need to write it with parentheses, like  f :: (a -> b) -> c
09:53:22 <byorgey> that's a function which takes a parameter of type a -> b  and returns a c
09:53:38 <byorgey> whereas f :: a -> b -> c  takes an a, and returns a function b -> c
09:53:49 <lilac> why are we calling them 'arrow types'? that makes me think of (Arrow a => a b c) not of (b -> c)
09:54:00 <byorgey> ok, function types
09:54:12 <dancor> but that makes you think of f :: ?
09:54:13 <dancor> :)
09:54:25 <byorgey> hehe
09:54:44 <byorgey> 'arrow type' is a perfectly cromulent term for  a -> b
09:55:31 <mrd> Arrows generalize arrows :)
09:56:24 <dancor> so if const :: a1 -> (b1 -> a1) and const g :: a2 -> (a2 -> b2)
09:56:38 <dancor> what has to equal what
09:56:44 <dancor> typewise
09:57:07 <mrd> const g :: b1 -> ...
09:57:28 <dancor> so a2 === b1
09:58:37 <BMeph> dancor: No, just g :: (a2 -> b2). At least, that's what I see. :)
09:59:30 <mrd> dancor: look, you can't get the a2 in the type of g to be the same as the b1 in the type of const.  these are universally quantified variables in separate scopes.
09:59:34 <BMeph> Although, you could possibly give ANY type to 'const g' and get g back. :)
09:59:45 <mrd> dancor: this is by design
10:00:01 <mrd> it's called 'abstraction' :)
10:00:24 <dancor> i have no idea how to determine the type possibilities for f when you know the types of g and g f.
10:00:28 <dancor> does anyone?
10:00:54 <mrd> it's not difficult
10:00:55 <BMeph> dancor: ...unification? ;)
10:01:16 <dancor> mrd: is it in P  :)
10:01:39 <mrd> on average
10:02:24 <Axman6> if ... then... else isn't defined as a function right? just part of the language?
10:02:32 <dancor> BMeph: is this unification, or the opposite of that
10:02:33 <mrd> Axman6: right
10:03:03 <Deewiant> then :: Then, else :: Else, if :: Bool -> Then -> a -> Else -> a -> a
10:03:13 <mrd> heh
10:03:22 <Axman6> i was just thinking about if you could actually defiine it... let if p then x else y | p = x | otherwise = y
10:03:24 <mrd> not saying that you couldn't define "if" as a function
10:03:30 <mrd> you certainly could
10:03:38 <Deewiant> not with the syntax it currently has, though
10:03:41 <dancor> :t if'
10:03:42 <lambdabot> Not in scope: `if''
10:04:01 <dancor> @pl if a then b else c
10:04:01 <lambdabot> if' a b c
10:04:11 <Axman6> somsone was saying earlier that the function if' p t f should be part of the prelude
10:04:14 <BMeph> dancor: You're asking the wrong newbie... ;)
10:04:35 <dancor> more specifically, i am also the wrong newbie
10:04:37 <BMeph> Axman6: Yes, as 'bool' ;)
10:04:41 <dancor> but not the same one ;)
10:05:22 <dancor> mrd: on average?
10:05:35 <lilac> Axman6: i'd prefer <?> :: MonadFail m => Bool -> a -> m a; <:> :: Maybe a -> a -> a
10:05:44 <joey``> Anybody know where I can find out about the "optional extensions" that are part of the hbc compiler?
10:07:55 <dons> ?users
10:07:55 <lambdabot> Maximum users seen in #haskell: 521, currently: 519 (99.6%), active: 15 (2.9%)
10:07:58 <dons> woo
10:08:00 <dons> welcome all
10:08:03 <lilac> \o/
10:08:38 <dancor> do we still fit in a 747
10:09:07 <Axman6> i'm gonna say no so we can fly in an A380
10:09:25 <dons> yeah, i'm not even sure 520 fit in an a380
10:09:51 <Axman6> i thought that if they were fitted out right, they could take 800?
10:09:55 <ozy`> "The 747-400 passenger version can accommodate 416 passengers in a typical three-class layout or 524 passengers in a typical two-class layout." <== we sure don't
10:09:58 <Axman6> i could be totally wrong...
10:10:01 * Axman6 googles
10:10:06 <dons> we're closing in on #perl fwiw
10:10:09 <dancor> Axman6: 853
10:10:17 <dons> 551 in #perl. closest we've been.
10:10:17 <Axman6> there ya go
10:10:32 <dancor> someday haskell will be as good as perl
10:10:38 <dons> we must compete!
10:10:39 <Axman6> someday? pfft
10:10:55 <ozy`> "The A380 (...) provides seating for 525 people in standard three-class configuration or up to 853 people in all economy class configuration."
10:11:05 <ozy`> an A380 is plenty
10:11:21 * dancor is _not_ sitting economy
10:11:29 <Axman6> what are the largest freenode chans?
10:11:35 <ozy`> well we can't all sit first class
10:11:43 <smtms> Axman6, #freenode might know
10:12:23 * ozy` takes a deep breath and a cold shower and queries the channel list
10:13:06 <ozy`> good grief. #ubuntu has 1392 people
10:14:08 <ozy`> after that: #gentoo (976), #debian (849), ##linux (789), ##php (689), #python (607), #django (579), ##c++ (566), #perl (561).... and us
10:14:15 * dancor still thinks is correct to say b1 === a2 in my example
10:14:29 <dancor> those vars will have to "unify" for the whole thing to
10:14:44 <dancor> or whatever hocuspocus terminology you are supposed to use
10:14:49 <dancor> when discussing such matters
10:15:59 <dons> ?users
10:15:59 <lambdabot> Maximum users seen in #haskell: 521, currently: 517 (99.2%), active: 15 (2.9%)
10:17:05 <nomeata> Hi. Someone here knowledgableabout about Data.Generics? Can I do what fmap from $(derive makeFunctor ''MyData) does with it?
10:17:57 <nomeata> I.e., write a function "(Data c) => (a -> b) -> c a -> c b"? Or does Data not really work for higher order types?
10:18:28 <mrd> dancor: i highly advise that you go ahead an implement a Hindley-Milner style type checker
10:18:34 <mrd> dancor: it's not hard at all
10:18:37 <luqui> nomeata, IIRC there's something like Data1 for that
10:18:57 <dancor> mrd: i think i need to solve the opposite problem here..
10:19:06 <mrd> type unchecking?
10:19:16 <dancor> type peeking
10:19:19 <dancor> type predicting
10:19:28 <mrd> type inference
10:19:31 <luqui> nomeata, I was wrong.  I was thinking of typeable
10:19:41 <mrd> H-M implies type inference too
10:20:03 <lilac> nomeata: you want an instance Data a => Data (c a) I think. That's what's done for Maybe, etc.
10:20:34 <luqui> isn't that an undecidable instance?
10:21:18 <lilac> shouldn't be for a specific 'c'
10:21:29 <nomeata> hmm, so , (Data (c a), Data (c b)) => (a -> b) -> c a -> c b ought to work?
10:21:33 <mrd> dancor: http://www.cs.cmu.edu/~rwh/plbook/  or  pickup a copy of Pierce.  Types and Programming Languages, for a nice textbook
10:21:34 <lambdabot> Title: Index of /~rwh/plbook
10:21:43 <luqui> nomeata, ahh yes that would be it
10:22:16 <dancor> mrd: if it's impossible, why does ghci load this program fine:   g :: a -> b -> a   g = const f   f = const undefined
10:22:54 <mrd> undefined can take on any type
10:23:08 <luqui> dancor, however such is not really necessary.  most of it is common sense once you know that inference is done by traversing the AST and generating equations, then solving the equations.
10:23:28 <luqui> (though the first time it's common sense it's very tricky... after that it's very straightforward :-)
10:23:35 <rwbarton> Whoa, you can use infix notation with class names?  class a `Foo` b where ...
10:23:37 <dancor> according to ghci here, f :: b -> a is one possibility (the only?) for const f :: a -> b -> a
10:23:54 <luqui> rwbarton, say what!?
10:23:58 * luqui tries
10:24:08 <ozy`> rwbarton: that's wacky
10:24:16 <lilac> rwbarton: ghc extension, or h98?
10:24:23 <rwbarton> or  class a :& b where ...
10:24:23 * lilac kicks self
10:24:29 <dancor> can classes be (+|+|+)-esque
10:24:32 <rwbarton> just needs MultiParamTypeClasses
10:24:39 <njbartlett> Whoa, 522 members! How long was I away exactly...?
10:24:44 <lilac> rwbarton: yea, i just realised :)
10:24:59 <mrd> dancor: undefined :: forall a. a.  no typesafe term can have that type.
10:25:02 <vixey> oh luqui
10:25:03 <vixey> hi
10:25:04 <dancor> you guys are embarrassing me in front of the new members with all this member talk
10:25:15 <luqui> vixey, hi?
10:25:26 <ozy`> I for one don't care if Haskell is popular, so long as it's useful
10:25:50 <Beelsebob> ozy`: to a certain extent those two go hand in hand
10:25:51 <vixey> Why isn't type checking a counterexample to Rices theorem?
10:25:58 <ozy`> Beelsebob: yes, I know
10:26:01 <vixey> i.e. you can always check if a program is well typed or not
10:26:07 <luqui> however instance Int `Foo` Double isn't allowed...
10:26:11 <dancor> do ppl consider undefined to not be typesafe
10:26:17 <vixey> dancor: no it's type safe
10:26:23 <dancor> vixey: i agree
10:26:36 * mrd disagrees
10:26:36 <lilac> dancor: obviously it's not total, though
10:26:39 <vixey> dancor: sorry what question were you asking?
10:26:46 <vixey> undefined is total
10:26:49 <vixey> @src undefined
10:26:49 <lambdabot> undefined =  error "Prelude.undefined"
10:26:53 <vixey> if it was,
10:26:54 <luqui> vixey, because well-typed is an extrinsic property
10:26:55 <vixey> undefined = undefined
10:26:58 <vixey> then it's not total
10:27:02 <rwbarton> luqui: that's even more bizarre
10:27:07 <mrd> undefined is effectively bottom
10:27:10 <vixey> what does extrinsic mean?
10:27:13 <lilac> vixey: how do you define total then? i'd say f is total iff f x != _|_ forall x
10:27:22 <luqui> vixey, it's a property of the source code, not of the function
10:27:25 <ozy`> vixey: opposite of intrinsic?
10:27:36 --- mode: ChanServ set +o dons
10:27:40 --- topic: set to '["Functional code is functional", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by dons
10:27:44 --- mode: ChanServ set -o dons
10:27:45 <luqui> vixey, i.e.  42 and if True then 42 else "I am a banana"    are both the same program
10:27:49 <luqui> one is well-typed, the other is not
10:28:23 <luqui> rice's theorem talks about algorithms which *cannot* distinguish the two
10:28:35 <dancor> but this is typesafe right: if True then 42 else error "I am a banana"
10:28:35 <vixey> That doesn't make sense to me
10:28:51 <vixey> How is _anything_ you can say about a program not extrinsic?
10:28:52 <luqui> dancor, typesafe, but not well-typed
10:29:18 <ozy`> > if True then 42 else "My spoon is too big"
10:29:19 <lambdabot>       No instance for (Num [Char])
10:29:20 <lambdabot>        arising from the literal `42' at <i...
10:29:22 <dancor> luqui: how is well-typed defined
10:29:28 <luqui> vixey, think of it this way.  intrinsic properties are things you can do to a function you recieve as an argument to another function in a haskell program
10:29:54 <mrd> typesafe is defined as "if term has a type then it does not get stuck. in other words, the term is a value, or it can take a step."
10:29:58 <vixey> so if you have Bool -> Bool
10:29:59 <lilac> luqui: so intrinsic properties are those provided by the semantics of the language?
10:30:06 <dancor> luqui: if you define an instance for Num String is it well-typed then
10:30:12 <mrd> undefined is neither a value, nor can it take a step
10:30:19 <mrd> it is stuck
10:30:21 <vixey> you could like, check if was a not function, that's intrinsic?
10:30:30 <luqui> lilac, uh, that's not how rice said it, but yeah, roughly it's about the semantic space and not the syntax space
10:30:31 <vixey> i.e. \f -> f True == False && f False == True
10:30:46 <luqui> dancor, lol true
10:30:55 <gmaslov> i thought undefined was supposed to be bottom, which keeps taking steps forever without becoming a value
10:31:12 <dancor> yeah in a purist implementation undefined should loop
10:31:31 <vixey> gmaslov: it's not
10:31:39 <luqui> we solve the halting problem when we can :-)
10:31:47 <dancor> i like the <<Loop>> error or whatever.  it's like ghc knows things it shouldn't know
10:31:52 <luqui> > let x = x in x
10:31:56 <vixey> is that true?
10:32:07 <lambdabot>   thread killed
10:32:08 <luqui> awww no <loop>?
10:32:23 <ozy`> > let f x = f x
10:32:23 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
10:32:23 <lambdabot>  ...
10:32:32 <vixey> luqui:Ii lost you?
10:32:37 <gmaslov> i've only seen <Loop> happen when using stuff from Control.Concurrent
10:32:39 <ozy`> > let f x = f x in f 3
10:32:54 <lambdabot>   thread killed
10:33:08 <gmaslov> i believe it can tell if a thread is waiting on something that no other thread has a reference to anymore
10:33:26 <rwbarton> gmaslov: That's a different error message, also quite cool
10:34:24 <luqui> vixey, see the second paragraph of the introduction to the article on wikipedia.
10:34:32 <vixey> I read wikipedia, it's rubbish
10:35:01 <luqui> yeah it talks about godel numberings and all sorts of unnecessary crap
10:35:38 <vixey> k. nevermind then
10:36:33 <luqui> here's another way to put it:   if you accept as input an AST to a function f, for rice's theorem to apply, f(x) = f(x') when x and x' are convertible
10:37:16 <luqui> and well-typedness does not preserve under convertibility.
10:37:53 <luqui> (namely in the case that an ill-typed term converts to a well-typed one)
10:41:45 <Taejo> vixey: did somebody answer your question about type-checking and Rice's theorem
10:42:00 <vixey> Taejo: yeah but I don't get it
10:42:07 <lispy> Rice's theorem applies to type checking?
10:42:09 <dancor> :t const (const undefined)
10:42:11 <lambdabot> forall a b b1. b1 -> b -> a
10:42:35 <lispy> I thought Rice's Theorem was roughly stated as: any not trivial property of languages in undecidable in general
10:43:00 <luqui> aye, so the argument was "well-typed is not a property of a language"
10:43:39 <lispy> I see, hmm
10:44:01 <lispy> I also recall Rice's Theorem as slightly tricky to apply
10:45:06 <lispy> interesting, wikipedia lists Rice's Theorem as a theorem about partial functions not languages
10:45:20 <lispy> "for any non-trivial property of partial functions, there exists at least one algorithm for which it is undecidable whether the algorithm computes a partial function with this property. "
10:45:29 <mml`> :t length
10:45:31 <lambdabot> forall a. [a] -> Int
10:45:36 <luqui> yep.  same diff though.  also wikipedia gives a very complicated proof.
10:45:47 <yebyen> anyone seen this before: not in scope type constructor or class E.EXCEPTION_TYPE
10:45:55 <luqui> (or sketches what would be a very complicated proof)
10:46:03 <yebyen> while compiling HApps-Server
10:46:25 <lispy> dons: is dcoutts talking on Tuesday still?  I don't recall seeing the announcement
10:46:33 <yebyen> i thought i had my compiler toolchain straightened out but i'm still getting dull errors like this one
10:46:43 <luqui> when really what it's saying is that if f x = True for some x, and f x = False for some x, then f _|_ = _|_
10:47:37 <lispy> luqui: x /= x, in that statement?
10:47:42 <luqui> yeah
10:48:00 <Taejo> lispy: they're in different scopes
10:48:03 <dancor> so haskell will let me specificize any g which is "really" g :: a -> b -> c to g :: a -> b -> a..
10:48:22 <dancor> that's the rub here
10:48:38 <luqui> yeah, a -> b -> c is only the most general type.
10:48:50 <luqui> but g has many types.
10:49:03 <lispy> > let g :: a -> b -> c; g = undefined; f :: a -> b -> c; f = g; in f
10:49:06 <lambdabot>       Overlapping instances for Show (a -> b -> c)
10:49:06 <lambdabot>        arising from a use ...
10:49:21 <lispy> :t let g :: a -> b -> c; g = undefined; f :: a -> b -> c; f = g; in f
10:49:23 <lambdabot> forall a b c. a -> b -> c
10:49:28 <dancor> i'm trying to generate random functions, given a type
10:49:32 <lispy> :t let g :: a -> b -> c; g = undefined; f :: a -> b -> a; f = g; in f
10:49:34 <lambdabot> forall a b. a -> b -> a
10:49:39 <dancor> this consideration is going to make it weirder
10:49:50 <luqui> dancor, ah, like djinn?
10:49:58 <vixey> dancor: what's a random function from () -> N ?
10:50:02 <lispy> :t let g :: a -> b -> c; g = undefined; f :: a -> a -> c; f = g; in f
10:50:04 <lambdabot> forall a c. a -> a -> c
10:50:12 <dancor> luqui: yeah but not with unique answers
10:50:17 <vixey> i.e. how do you pick a random number from 0 - infinity?
10:50:43 <dons> lispy: yes, and the announce. hasn't been sent yet.
10:50:50 <luqui> dancor, ah, you could go grab djinn and change its heuristics (which involve trying to use every variable) to rely on a random number generator
10:51:08 <Lleksah> Hi, i'm a beginner and I would like to install the "GLFW" library. Can someone help?
10:51:10 <dancor> vixey: i'm more interested in short functions that can be made from combining some well-known ones (id, map, etc).  right now :: Int always gives 1 :)
10:51:16 <dancor> luqui: interesting..
10:51:33 <luqui> vixey, that's easier to answer when numbers are Z or S n.  But you get a very biased distribution.
10:51:46 <vixey> dancor: And you are doing this with typeclass dispatch or what?
10:52:20 <dancor> vixey: i don't know what that is
10:52:24 <luqui> dancor, you do realize that such a thing is a proof generator, and is undecidable as soon as you get to recursive types (like lists)
10:52:34 <vixey> dancor: How are you programming this?
10:52:49 <dancor> luqui: what is undecideable?  i'm just searching for random generations
10:52:58 <luqui> dancor, whether any implementation exists
10:53:12 <luqui> (any total implementation, that is, you could always just toss undefined everywhere)
10:53:15 <Lleksah> I'm new to haskell and for class I need to practice a couple of haskell programs. However, I despise the computer lab and so decided to install haskell on my laptop (running x64 vista) but when I tried to run the practice files it seems I required the GLFW library.
10:53:15 <Lleksah> I downloaded the library, but I'm clueless as to how to install it on GHC. I tried running the setup command 'runhaskell Setup.hs install' but I just get an error t which says something like:
10:53:15 <Lleksah> "error reading dist\setup-config"
10:53:15 <Lleksah> Can anyone help?
10:54:09 <luqui> hmm that's an odd error.  have you tried using cabal-install?
10:54:14 <rwbarton> Lleksah: try running runhaskell Setup.hs configure --user and runhaskell Setup.hs build first
10:54:17 <mrd> dancor: the existence of a program of a particular type constitutes a proof of the proposition corresponding to that type
10:54:29 * luqui will shut up, because he is unskilled in the ways of the cabal
10:55:01 <vixey> dancor: hello?
10:55:14 <rwbarton> luqui: is there an easy argument for this undecidability result?
10:55:17 <mrd> just like there is no proof of the proposition forall A B. A implies B, there is no term of type forall a b. a -> b which is type safe.
10:55:47 <dancor> vixey: this is all i have so far: http://dzl.no-ip.org:81/gitweb/?p=pangen.git;a=blob;f=src/Main.hs
10:56:05 <vixey> dancor: ah great, thanks
10:56:15 <luqui> rwbarton, hmmmm.... I am not sure.  It may have to do with data N = Z | S N is recursive...
10:56:15 <Lleksah> rwbarton: When I do "runhaskell Setup.hs configure --user" it says : Setup.hs: No Description file found, please create a cabal-formateed description file
10:56:21 <dancor> i did a random generator for CFG's as a warm-up to this
10:56:50 <dmead> channel
10:56:57 <dmead> you can call haskell from C, right?
10:56:57 <mrd> throwing "undefined" into a program doesn't give you a good program any more than throwing bottom into a proof gives you a good proof
10:56:58 <vixey> dancor, you might wanna change
10:57:00 <vixey> (FType (Var 1) (Var 1))
10:57:02 <vixey> into something like
10:57:04 <dancor> is he channelling the dmead
10:57:08 <luqui> rwbarton, to be honest, I'm not sure it is actually; it's just a strong hunch.  I'll think about it.
10:57:10 <vixey> a --> a   where (-->) = FType ; a = Var 1
10:57:17 <dmead> wot.
10:57:18 <Lleksah> When I do "runhaskell Setup.hs configure --user" it says : Setup.hs: No Description file found, please create a cabal-formateed description file
10:57:21 <vixey> would make that code a lot easier to read
10:57:41 <Lleksah> But there is a file in the folder called GLFW.cabal
10:58:03 <dancor> vixey: ok.  i was thinking those should be generated from parsing .hs files eventually too
10:58:05 <vixey> dancor: you could also define  :-->: instead of 'FType'
10:58:10 <dmead> @hoogle c2hs
10:58:11 <lambdabot> package c2hs
10:58:11 <lambdabot> Distribution.Simple.Program c2hsProgram :: Program
10:58:11 <lambdabot> package hsc2hs
10:58:57 <dmead> @hoogle hs2c
10:58:57 <lambdabot> No results found
10:59:01 <dmead> drat
10:59:22 <vixey> dancor: cool idea though I am bookmarking this
10:59:36 <lispy> dons: okay, well people here are trying to schedule meetings at that time, so I'm putting it on my calendar as Tuesday 10:30 - noonish, and I plan to be there.
11:00:00 <dancor> vixey: luqui's suggestion of hacking djinn seems good too
11:00:09 <Lleksah> Can anyone help, I really need to install GLFW!!!
11:00:10 <vixey> dancor: oh then I'll not bookmark it
11:00:18 <vixey> already seen djinn
11:01:09 <dancor> i had thought djinn was really different bc it generates a particular type of func not any one
11:01:12 <luqui> Lleksah, your problem is strange
11:01:28 <dancor> also, djinn is just a reinvention of coq anyway :)
11:01:29 <Taejo> Lleksah: do you have SSH access to your lab?
11:01:34 <geezusfreeek> Lleksah, sounds like you are in the wrong directory or something
11:01:51 <Lleksah> Well, ghc is installed in my D: drive
11:02:00 <geezusfreeek> oh wait, no then it would say there is no setup.hs
11:02:11 <Lleksah> And I do have SSH access, but I've never tried using it before
11:02:16 <Taejo> Lleksah: you need to be in the directory where the library's source is
11:02:30 <Taejo> but if you have a deadline, you might prefer SSH
11:02:30 <Lleksah> I know, I gave the complete path to the Setup.hs
11:02:44 <Taejo> ah, that's your problem
11:02:48 <geezusfreeek> Lleksah, oh, you need to be _in_ the directory
11:03:15 <geezusfreeek> it only looks in your current directory for the .cabal file
11:03:21 <Lleksah> Oh i see, how would I go about doing that? Sorry I am a newbie.
11:03:28 <geezusfreeek> cd path/to/directory
11:03:28 <dons> lispy: ok.
11:03:35 <Lleksah> thanks
11:06:06 <Lleksah> Awesome, it's all working now
11:06:11 <Lleksah> Thanks guys
11:07:30 <dancor> @hoogle evalRandIO
11:07:30 <lambdabot> No results found
11:07:37 <dancor> why isn't that one in hoogle
11:07:45 <lilac> dancor: what does it do?
11:08:05 <dancor> lilac: http://hackage.haskell.org/packages/archive/MonadRandom/0.1.1/doc/html/Control-Monad-Random.html
11:08:07 <lambdabot> Title: Control.Monad.Random, http://tinyurl.com/69km72
11:09:06 <rwbarton> dancor: because hoogle does not index all of hackage
11:09:25 <Taejo> what does it index?
11:10:17 <rwbarton> roughly the packages that come with ghc, I think: base, array, bytestring, ...
11:12:07 <mightybyte> Are there mapM and filterM variants analogous to the foldl' variant of foldl?
11:12:56 <Beelsebob> mightybyte: mapM_?
11:13:10 <rwbarton> applying >>= strictly, you mean?
11:13:10 <mrd> in that they are strict?
11:13:15 <Beelsebob> oh, I see
11:13:20 <mrd> that would be up to the monad
11:13:22 <luqui> rwbarton: it might go something like this.  Is the recursive type X = X -> False realizable?
11:13:22 <plutonas> i am filling in a dynamic programming table, each element of the table looks like this (score, element), and is computed using the element(s) either above it, either one position on the left, either diagonally (left and above), that would produce the maximum score for the current element. My question is, how would i once i computed the maximum possible score for my current position, find out if it comes from above, l
11:13:22 <plutonas> eft or diagonally, so that i just compute this element?
11:13:30 <mightybyte> Yeah...to avoid stack overflows.
11:13:44 <plutonas> my main problem is that i can't store that information in a variable
11:13:46 <Beelsebob> mightybyte: you can't get a stack overflow from mapM
11:13:50 <Beelsebob> it's built on the heap
11:13:56 <plutonas> and making another function for it seems overkill
11:14:01 <Beelsebob> you can ofc get stack overflows from the elements of a mapM
11:14:15 <Beelsebob> but then it's not a strict mapM you want
11:14:28 <mightybyte> Beelsebob: Well, it looks like I'm getting one.
11:14:30 <luqui> rwbarton, however X is not positive in the rhs; I'm not sure something like that exists when you restrict to positive recursive types.
11:14:36 <rwbarton> > case mapM (Just . (+1)) [1..1000000] of Just _ -> 1
11:14:39 <mrd> plutonas: either examine the values in each position and compare to the current, or simultaneously populate another table with that information.
11:14:39 <lambdabot>   * Exception: stack overflow
11:14:57 <Beelsebob> > [1..10000000]
11:14:59 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
11:15:22 <mrd> I'd do the latter if it was something like all-pairs shortest path
11:15:31 * Beelsebob ponders why 
11:15:49 <mrd> (or track it in the tuple)
11:15:56 <plutonas> mrd: the first is what i currently do, but this definitely is an overkill. As for the second, should i have a matrix with kind of "arrows" showing where the value comes from? isn't there any simpler way?
11:16:08 <plutonas> mrd: no the tuple can't change :(
11:16:13 <mightybyte> Beelsebob: I've just got some big loops that are realized with mapM and filterM, and I'm trying to avoid re-implementing them to avoid the stack overflow.
11:16:34 <mrd> the "arrows" would just be indices
11:16:47 <mrd> I can't think of any other ways in general
11:16:55 <plutonas> i see, anyway thanks will see what i'll do
11:17:36 <mrd> a stack overflow from mapM could be the build-up of unevaluated terms
11:17:56 <mightybyte> mrd: Right, which is why I was asking about the foldl' analog to it.
11:18:22 <mrd> but I don't think it's mapM which is doing the building here
11:18:32 <rwbarton> I think it is unavoidable
11:19:07 <rwbarton> because you don't know, until you reach the end of the list, whether you have to output a Just or a Nothing first
11:19:33 <mrd> @type mapM
11:19:35 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
11:19:41 <rwbarton> Well, that's a pretty poor argument :)
11:19:53 <lilac> but it is true :D
11:20:16 <mrd> hmm
11:20:30 <lilac> for a specific monad you might be able to do better, though.
11:21:30 <mightybyte> mrd: I'v been working on Project Euler problems in haskell and have been frequently bitten by stack overflows similar to this.
11:21:44 <rwbarton> Yeah, I think that's right.  I'm imagining how you'd write this using a foldl' and it seems like you have to use the structure of the Maybe monad
11:22:20 <lilac> > mapM (+) [1..100000000] 42
11:22:26 <mrd> > sequence (map Just [1..1000000])
11:22:33 <lambdabot>   [43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67...
11:22:37 <lambdabot>   * Exception: stack overflow
11:22:59 <lilac> so mapM works fine on large lists in the "(->) a" monad
11:23:15 <newsham> ?tick ^gspc
11:23:16 <lambdabot> ^GSPC: 1018.92 -80.31 (-7.31%) @ 10/6/2008 2:22pm
11:23:29 <mightybyte> lilac: I'm in the IO monad
11:24:09 <rwbarton> mightybyte: Weird... I think >>= should be sufficiently strict in the IO monad to not cause this kind of problem
11:24:24 <lilac> rwbarton: isn't it the strictness which is causing the problem?
11:24:32 <lilac> > mapM (Just . (42+)) [1..]
11:24:35 <lambdabot>   * Exception: stack overflow
11:24:41 <mightybyte> rwbarton: I'll paste some code.
11:24:50 <lilac> > take 1 $ mapM (+) [1..] 42
11:24:51 <lambdabot>   [43]
11:25:26 <rwbarton> I guess 'strict' isn't what I mean
11:25:43 <rwbarton> anyways, > mapM print [1..10000000] is quite happily printing out numbers for me in ghci
11:27:02 <mightybyte> rwbarton: http://hpaste.org/10951
11:27:50 <rwbarton> mightybyte: Well, a quick suggestion is to try sequence_
11:28:15 <mightybyte> How about just mapM_?
11:28:24 <rwbarton> Even better :)
11:28:46 <Peaker> I think forM_ is less confusing than mapM_ perhaps :)
11:30:09 <mightybyte> rwbarton: Ahh, this is looking promising...
11:30:50 <rwbarton> I don't know *exactly* why building large lists of the form [(), (), (), ...] causes this problem, but it seems like a bad idea :)
11:31:15 <mightybyte> rwbarton: Ahh, I was forgetting that list.
11:32:10 <pastorn> i want read to be :: String -> Maybe a
11:32:36 <pastorn> and i'm not too familiar with the error monad... is there an easy way to use it?
11:33:00 <pastorn> like just wrapping (read myStr) inside something...
11:33:08 <dancor> pastorn: http://dzl.no-ip.org:81/gitweb/?p=futil.git;a=blob  readMb
11:33:19 <dancor> err http://dzl.no-ip.org:81/gitweb/?p=futil.git;a=blob;f=src/FUtil.hs
11:33:26 <rwbarton> pastorn: there is readMay in the 'safe' package on hackage
11:34:06 <dancor> ooh
11:34:44 <mightybyte> rwbarton: So now it makes it through the second print, but overflows on the filterM
11:35:11 <pastorn> dancor: thanks :D
11:35:45 <dancor> pastorn: the safe one is implemented differently looks like so now you have _two_ answers :)
11:37:33 <pastorn> oh, i should just be using reads...
11:37:35 <pastorn> i thing
11:37:38 <pastorn> *think*
11:37:42 <vixey> :t reads
11:37:43 <lambdabot> forall a. (Read a) => String -> [(a, String)]
11:37:52 <vixey> what are you doing that you would use reads for
11:38:35 <pastorn> i have my ad-hoc file format that i need to parse into my structure
11:38:58 <pastorn> and i'd like to move it into the maybe monad
11:39:03 <vixey> you could use parsec
11:39:08 <rwbarton> mightybyte: I see.
11:39:17 <rwbarton> I have two ugly suggestions
11:39:25 <pastorn> vixey: my files are two-three lines of metadata, and that's all, so no parsec
11:39:28 <rwbarton> actually one is too ugly to contemplate
11:39:43 <pastorn> time to learn parsec properly >>> doing ugly h4xx
11:39:45 <vixey> pastorn: Doesn't follow
11:40:23 <pastorn> it's a game, so i'm making readLevel :: String -> Maybe Level
11:40:26 <rwbarton> mightybyte: You can create an IORef and insert all the things that filterM would return into it, then readIORef the IORef
11:40:30 <dancor> parsec is its own reward
11:40:57 <dancor> you will use it again
11:41:00 <vixey> pastorn: you can do that with parsec, parsec doesn't care if you have a 3 line file or a 300 line file
11:41:20 <pastorn> vixey: but that just seems like overkill
11:41:25 <mightybyte> rwbarton: Ok.  Right now I'm trying to strictly calculate the sum instead of keeping the whole list.
11:41:30 <vixey> pastorn: it's not.
11:41:33 <plutonas> i had some code which was a ++ b ++ c, and it returned something, now that i changed it to (if something then a else []) ++ (if something-else then b else [] ++ (if something-third then c else []) in some cases it produced output before now it returns the empty list, would this mean that just else gets applied? What do you think about this style of code, am not sure if it's good style in haskell
11:41:41 <vixey> pastorn: It's exactly the right thing to use
11:41:45 <rwbarton> mightybyte: Oh, that would be slightly easier
11:41:49 <pastorn> besides, i haven't taken the course "programming languages" yet, so i'll wait with parsec until i take it
11:41:59 <dancor> well one time i saw someone use parsec to do like filter (/= ' ') and it _was_ overkill
11:42:08 <mightybyte> rwbarton: ...if it works.
11:42:13 <dancor> but at three lines it probably isn't overkill
11:42:15 <vixey> pastorn: I haven't taken a course like that but I used parsec
11:42:50 <dancor> parsing is one of those things ppl go to great lengths to not do for no reason
11:42:59 <dancor> hence regexes :)
11:43:04 <rwbarton> mightybyte: are you compiling with optimizations?
11:43:12 <mightybyte> rwbarton -O2
11:43:23 <rwbarton> ok.  foldM might work for you then
11:43:42 <rwbarton> wait, not foldM, never mind.
11:45:37 <mightybyte> rwbarton: Nope, that didn't do it.
11:47:16 <mightybyte> This is frustrating.  I love programming in haskell, but programs like this seem rather difficult to write.
11:47:28 <vixey> programs like what?
11:47:32 <plutonas> anyone?
11:47:40 <mightybyte> vixey: http://hpaste.org/10951
11:47:55 <mightybyte> vixey: ...that I've been discussing
11:47:58 <vixey> what does it do
11:48:02 <vixey> should it do*
11:48:16 <mightybyte> It's supposed to solve project euler problem 211
11:48:24 <vixey> ok
11:48:30 <luqui> ow my functionality
11:48:33 <mightybyte> Kind of an Eratosthenes seive
11:48:40 <vixey> write it in C
11:48:43 <mightybyte> I did
11:48:47 <vixey> hehe
11:49:18 <mightybyte> But I wanted to come back and do it in Haskell.
11:49:28 <vixey> that's not a good way to work
11:49:46 <mightybyte> I'm not working.  I'm learning.
11:49:47 <vixey> the way you think about a problem in C vs how you would like to think about it in haskell is probably what's causing the stack overflow
11:49:57 <vixey> that's not a good way to learn*
11:49:58 <luqui> that's a very noncomittal answer
11:50:16 <vixey> if you wanted to learn haskell it's a lot more effective to write a real/useful program
11:50:17 <mightybyte> Heh
11:50:23 <vixey> solving numeric puzzles will not get you anywhere
11:50:38 <mightybyte> That's debatable.
11:50:49 <luqui> while vixey has a point, this is a very (very) unhaskellish way to do this, and you would learn more by staying the fsck away from IO, we should also try to figure out where the stack overflow is coming from
11:51:16 <vixey> yeah, don't believe anything I say :p
11:51:22 <mightybyte> luqui: I understand that, but I think this problem would crop up no matter what approach you use.
11:51:44 <luqui> mightybyte, which problem.  the existence of stack overflows?
11:51:48 <mightybyte> Yeah
11:52:07 <luqui> well, it crops up unless you understand key points about strictness
11:52:13 <mightybyte> Since that specific problem requires looping through 64 million elements.
11:52:41 <mightybyte> luqui: True.  I've already learned some of those while solving previous PE problems.
11:53:46 <luqui> mightybyte, so why would a loop of 64 million elements necessitate a stack overflow?
11:54:11 <mightybyte> It doesn't.  But common haskell list idioms frequently do.
11:54:59 <romildo> Hi.
11:55:05 <luqui> not so often with -O2 ;-)
11:55:37 <romildo> Is it possible get the types from identifiers in a program from ghc?
11:55:40 <mightybyte> That could be, but I'm getting them here.
11:55:46 <vixey> romildo; yeah
11:56:08 <romildo> vixey, how?
11:56:14 <vixey> :t typeOf
11:56:15 <lambdabot> forall a. (Typeable a) => a -> TypeRep
11:56:20 <luqui> mightybyte, the optimizer can't do very much to IO
11:56:42 <mightybyte> luqui: Ahhh, how would you recommend going about it?
11:57:04 <Taejo> mightybyte: which PE problem was it?
11:57:15 <mightybyte> Taejo: 211, the most recent.
11:57:22 <romildo> I want ghc, the compiler, to print the types of toplevel identifiers when compiling a module. I do not need to manipulate the types at runtime. Is there such an option?
11:57:31 <Taejo> ah, then I won't have code for it lying around
11:57:57 <lispy> romildo: compile with the option -Wall and it should print top level types as warnings
11:58:02 <mightybyte> Taejo: :)
11:58:09 <romildo> lispy, ok, thanks.
11:58:29 <lispy> romildo: the thing I usually do though, is load the module in ghci and say, :t somefunction
11:58:46 <luqui> mightybyte, not touching IO.  You've got me thinking about how to approach the problem right now.
11:59:20 <dancor> romildo: also i wrote a small program to add all the types in that might be useful: http://dzl.no-ip.org:81/gitweb/?p=himp.git;a=blob;f=src/Hsig.hs
11:59:52 <luqui> brute force is probably not going to cut it no matter how you do it :-)
11:59:53 <mightybyte> luqui: Ok.  I think this sieve approach is probably the one you should look at first.  I spent a good bit of time looking at other approaches, but they seemed to be too slow.
12:00:09 <mightybyte> luqui: Yeah, that was my conclusion.
12:00:09 <lazyboy> why doesn't (return . take 2) >>= mapM someAction [1..] work? I.e it seems like mapM loops forever
12:00:38 <rwbarton> mightybyte: you might want to read about runSTArray, it lets you return an entire immutable array from a stateful computation
12:00:54 <mightybyte> rwbarton: Ok, I was wondering about using ST
12:00:55 <rwbarton> mightybyte: then you can do pure computations on the array and your stack overflows will become more predictable
12:01:02 <Xenoblitz> guys is it possible to recursively loop until a certain amount of time has passed, so that then an action is performed?
12:01:27 <dancor> @hoogle threadDelay
12:01:28 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
12:01:51 <Xenoblitz> yes but would that allow me to do IO actions in the mean time?
12:02:02 <dancor> Xenoblitz: yeah if you did them in a separate thread
12:02:06 <geezusfreeek> Xenoblitz, forkIO
12:02:32 <Xenoblitz> I would honestly hope not to have to go into concurrency at this point :S
12:02:46 <dancor> forkIO (threadDelay lolPause >> print "lol!") >> doOtherStuffInMeanTime
12:03:31 <dblazakis> @src Data.List.mapAccumL
12:03:31 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:03:42 <dblazakis> @src mapAccumL
12:03:42 <lambdabot> mapAccumL _ s []        =  (s, [])
12:03:42 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
12:03:42 <lambdabot>    where (s', y ) = f s x
12:03:42 <lambdabot>          (s'',ys) = mapAccumL f s' xs
12:03:58 <dblazakis> @src mapM
12:03:59 <lambdabot> mapM f as = sequence (map f as)
12:04:10 <Xenoblitz> dancor: what if both threads have to work on the same data? wouldn't that cause problems?
12:04:19 <dancor> Xenoblitz: you could write your own wait loop but you'd just end up hating yourself.  the concurrency stuff is pretty good / lightweight
12:04:31 <dancor> Xenoblitz: you'd use MVar's
12:04:47 <Xenoblitz> look i don't think i have to resort to threads in this case
12:04:51 <geezusfreeek> or STM if you have to keep many things in sync
12:04:54 <Xenoblitz> i might have not explained my problem well
12:04:56 <dancor> Xenoblitz: http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-MVar.html
12:04:58 <lambdabot> Title: Control.Concurrent.MVar, http://tinyurl.com/3nr8df
12:05:26 <geezusfreeek> Xenoblitz, do you mean you want to repeat some set of actions until a certain time and then move out of the loop?
12:06:07 <Xenoblitz> no... lets see ... say i have a program which every 1 second increments a value... however the user, at any given point in time may decide to increment the value by using a keyboard...
12:06:27 <dancor> i would def use an MVar for the value
12:06:28 <geezusfreeek> sounds like the perfect situation for concurrency to me
12:06:47 <dancor> you're going to reinvent it otherwise
12:06:54 <dancor> this is just like when ppl are afraid of parsing
12:07:04 <rwbarton> Xenoblitz: what would the other option be?  select(2) with a timeout?
12:07:14 <lispy> I'm typesetting some Haskell code in latex, and it's too wide...any suggestions?
12:07:28 <Xenoblitz> rwbarton: yes? :S but i am not so sure :/
12:07:57 <dancor> lispy: what are your options besides formatting the code to use fewer columns
12:08:00 <Xenoblitz> and yes guys i don't like resorting to concurrency... i can never fully understand it
12:08:19 <rwbarton> Xenoblitz: It's almost trivial in Haskell.  Something like   do mvar <- newMVar 0; forkIO $ forever $ modifyMVar (+1) mvar; forever $ do x <- getChar; modifyMVar (+1) mvar
12:08:24 <vixey> Xenoblitz: Have you ever used a program that sleeps thet way you sugested?
12:08:32 <rwbarton> Erm, put a threadDelay in the forkIO'd loop
12:09:08 <dancor> Control.Concurrent is supersweet, you have nothing to ph3@r
12:09:31 <Xenoblitz> is there like ... i donno... a tutorial with concurrency in haskell i can try to understand so that finally i get the hang of it?
12:10:00 <vixey> Xenoblitz: If you know what you want to program you shouldn't need a tutorial, just reference manuals
12:10:03 <geezusfreeek> all you need to know is the MVar stuff and forkIO
12:10:13 <Xenoblitz> ok so i have to look up Control.Concurrent
12:10:20 <Xenoblitz> thanks guys
12:10:26 <dancor> rwbarton's example code is actually a good place to start
12:10:34 <vixey> Xenoblitz: I wasn't suggesting that, I don't know what it is you are doing
12:10:48 <luqui> Xenoblitz, btw, STM is teh awsum.   put it early on your queue :-)
12:11:03 <Xenoblitz> i guess something on the lines of what rwbarton coded up there
12:11:04 <geezusfreeek> agreed. if concurrency scares you then STM will be your cure
12:11:14 <Xenoblitz> STM?
12:11:24 <geezusfreeek> software transactional memory
12:11:41 <geezusfreeek> lock-free concurrency!
12:12:05 <Xenoblitz> geezusfreeek: is that considered safe?
12:12:16 <geezusfreeek> STM is quite safe
12:12:17 <vixey> formal definition of safe? :)
12:12:23 <geezusfreeek> ha
12:12:25 <Xenoblitz> hehe you know what i mean :P
12:12:43 <Taejo> :t (**)
12:12:44 <lambdabot> forall a. (Floating a) => a -> a -> a
12:12:46 <geezusfreeek> Xenoblitz, basically you do all your work in atomic transactions, and the runtime takes care of the rest
12:12:48 <Taejo> :t (^)
12:12:49 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
12:14:04 <Xenoblitz> so lets see... a possible solution would be to either forkIO and stop one thread for a given time, do an action, stop a given time and still allow another thread to act on the data... or use a transaction system...
12:14:16 <Xenoblitz> ahhh the possibilites are boundless pinky...
12:14:27 <geezusfreeek> Xenoblitz, MVar is mutexed
12:14:52 <geezusfreeek> since you are only sharing one variable, STM is unnecessary in this case
12:14:57 <vixey> Xenoblitz: Without considering implementation at all, what are you trying to do?
12:15:23 <Xenoblitz> well hehe... i'm adding "gravity" to a tetris game
12:15:37 <Xenoblitz> every 1 second or so i'd like the brick to descend on its own
12:15:39 <vixey> ok that is definitely something you can do without any concurrent programming
12:15:52 <Xenoblitz> and if the user does something in the mean time
12:16:01 <Xenoblitz> i'd like the program to respond accordingly
12:16:24 <quicksilver> Xenoblitz: the best way to do that depends on what UI toolkit you're using
12:16:28 <quicksilver> to render your graphics
12:16:34 <quicksilver> most of them have timer callbacks.
12:16:41 <Xenoblitz> quicksilver: i am using GHL
12:16:46 <Xenoblitz> and it does have timers
12:16:51 <vixey> one simple way, is having an event loop .. it can have a Tick event (maybe with a delta from the previous time of the last Tick) and KeyboardInput events
12:17:06 <Taejo> :t True
12:17:07 <lambdabot> Bool
12:17:14 <vixey> the engine reads the queue and does what it says ..
12:17:23 <Xenoblitz> ah not a bad idea
12:18:13 <vixey> It's a really simple way to do things, and I think the whole mac os 6-7-8 etc worked like this
12:19:06 <vixey> (and of course most games followed the same idea.. and it didn't include delta times so when you buy a faster computer all the games you'd have on it got 10x harder :) )
12:19:10 <rwbarton> vixey: the problem is how do you get the events.  Anyways like quicksilver says this is probably handled by the GUI layer
12:19:20 <vixey> rwbarton: No it's not a problem, that's just implementation
12:19:26 <rwbarton> :P
12:19:32 <vixey> takes some typing out of code but .. everyone can do that
12:19:48 <Xenoblitz> my original idea was to code it in the core isntead of the interface
12:19:58 <Xenoblitz> i just needed a timer
12:20:12 <Xenoblitz> but Data.Time.Clock seems to be too much
12:20:19 <vixey> Xenoblitz: That's what I'm suggested, except that the Tick events subsume any need for a Timer
12:20:20 <Xenoblitz> and i can't get the milliseconds on a windows machine
12:20:28 <Taejo> when I'm working with positive integers only are div/mod or quot/rem more idiomatic?
12:20:31 <plutonas> i have a bit of code duplication, i have a where clause in a function, and for two of the definitions i repeat the same "sub"-where's. Though i can not move it to the exterior where. I hope i explained it well enough
12:20:58 <vixey> plutonas: why don't you hpaste it
12:21:03 <geezusfreeek> plutonas, you can't just parameterize it?
12:21:07 <plutonas> vixey: because it's homework code
12:21:13 <vixey> ok good luck with it
12:21:14 <plutonas> geezusfreeek: what do you mean?
12:21:23 <plutonas> vixey: homework is solved
12:21:28 <vixey> ok..
12:21:31 <plutonas> the thing is i wanted to make my code a bit better
12:21:34 <geezusfreeek> plutonas, if there are small differences between your two uses then you should make a function instead of a constant
12:21:49 <plutonas> geezusfreeek: the two uses are the same
12:22:11 <plutonas> the thing is that variables from the environment where it's used are different each time
12:22:43 <geezusfreeek> plutonas, exactly. make it a function that takes those variables instead of grabbing them from it environment
12:23:42 <plutonas> geezusfreeek: i'm not sure it's worth to make a function with 2 arguments for that
12:23:47 <plutonas>  where x = xs!!(i-1)
12:23:47 <plutonas>          y = ys!!(j-1)
12:24:02 <plutonas> or 2 functions with one argument each
12:24:03 <Taejo> :t (!)
12:24:04 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
12:24:28 <plutonas> and that where appears in both functions defined in my "main" where clause
12:24:36 <plutonas> well i can leave it like that i guess
12:24:50 <plutonas> just thought that perhaps there's some trick to do this
12:24:58 <geezusfreeek> are those retrieving the last elements in a list, bychance?
12:25:28 <geezusfreeek> :t last
12:25:29 <lambdabot> forall a. [a] -> a
12:25:34 <Deewiant> geezusfreeek: of course they are, of the lists (take i xs) and (take j ys) respectively :-)
12:26:02 <Taejo> :t (***)
12:26:02 <plutonas> no, it's like: where function1 i j = some stuff, and some calls of x and y ; function2 = in a similar manner
12:26:03 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:26:41 <zi> hi
12:26:47 <geezusfreeek> @pl \xs i -> xs !! (i - 1)
12:26:47 <lambdabot> (. subtract 1) . (!!)
12:27:09 <vixey> hi i
12:27:14 <Taejo> @pl \x -> (x, divisors' x)
12:27:14 <lambdabot> ap (,) divisors'
12:27:16 <vixey> zi,
12:27:26 <Deewiant> Taejo: id &&& divisors'
12:27:47 <geezusfreeek> or (,) <*> divisors
12:28:25 <geezusfreeek> i guess the Arrow version is a little more clear though
12:28:27 * vixey would write (id & divisors)
12:28:33 * vixey uses & instead of &&&
12:28:46 <geezusfreeek> is that predefined?
12:28:51 <vixey> by me.
12:28:54 <geezusfreeek> ah
12:28:55 <Deewiant> vixey: and * instead of ***? ;-)
12:29:04 <geezusfreeek> i don't alias things like that very often
12:29:09 <plutonas> ok, thanks
12:29:16 <plutonas> i think the way i have it right now is more clear though
12:29:16 <vixey> I defined a bunch of stuff from scratch
12:29:21 <plutonas> than defining lambdas
12:32:28 <lispy> operators considered harmful :)
12:32:39 <vixey> by you?
12:32:48 * lispy suggests googling "considered harmful" sometime
12:32:59 <lispy> vixey: yeah, I don't like most people's operators
12:33:06 <vixey> why?
12:33:25 <lispy> my experience with them has been lackluster
12:34:07 <vixey> don't like applicative or parsec?
12:34:34 <lispy> parsec only defines one or two I think
12:34:42 <lispy> I haven't used applicative
12:36:06 <pastorn> how does default reading work?
12:36:07 <pastorn> i have
12:36:20 <pastorn> data Direction = N | E | S | W
12:36:20 <pastorn>   deriving (Enum, Show, Read)
12:37:12 <guenni> hi, how do I make LocalTime to be an instance of Typeable?
12:37:16 <pastorn> but reads "Nlol" :: [(Direction,String)] gives me [] and not [(N,"lol")]
12:37:18 <maltem> pastorn: well "N" is read as N, and so on
12:37:36 <Botje> pastorn: needs a space
12:38:04 <pastorn> > reads "12lol" :: [ (Int,String)]
12:38:06 <lambdabot>   [(12,"lol")]
12:38:11 <pastorn> that worked...
12:38:20 <lispy> > let lol = 3 in 12lol
12:38:21 <lambdabot>       No instance for (Num (t -> a))
12:38:21 <lambdabot>        arising from the literal `12' at ...
12:38:42 <lispy> > let 12 = (+1); lol = 3 in 12lol
12:38:43 <lambdabot>       No instance for (Num (a -> a))
12:38:43 <lambdabot>        arising from the literal `12' at ...
12:38:46 <maltem> pastorn: ah yea, it must look like in Haskell code, where Nlol would be a different constructor, but 12lol gets parsed as 12 lol
12:38:52 <pafcu_> What's the easiest way to get the current date?
12:38:56 <rwbarton> > let lol = "lol"; f x y = (x, y) in f 12lol
12:38:57 <lambdabot>   (12,"lol")
12:39:31 <pastorn> oh, so the N is a constructor here...
12:39:46 <pastorn> then i understand why it needs a space
12:40:05 <vixey> > let lol = "lol" in (,)12lol
12:40:07 <lambdabot>   (12,"lol")
12:40:13 <vixey> > let lol = "lol" in (,,)12lol13
12:40:14 <lambdabot>   Not in scope: `lol13'
12:40:37 <pastorn> how do i get around it? i read some in the source and documentation about Read but i did't understand
12:41:04 <lispy> pastorn: you could make your own instances of Read
12:41:17 <lispy> instance Read Direction where ...
12:41:23 <rwbarton> pastorn: If you produce your file using the derived Show instance, you will not have any problems.  (If your entire file can be represented by something that can have derived Show and Read instances)
12:41:32 <vixey> pastorn should use Parsec but refuses to for some reason..
12:42:02 <rwbarton> But yeah, if you have a fixed file format you need to parse, use parsec
12:42:07 <maltem> hm... do we need parsec to parse one-letter identifiers? :)
12:42:22 <lispy> Read/Show are best used for serealizing data, any more specific purpose should use a different interface
12:42:28 <vixey> maltem: Do you know an easier way?
12:42:34 <pastorn> vixey: this way i'll learn more
12:42:45 <pastorn> and besides, i will be learning parsec later
12:42:50 <maltem> vixey: er, pattern-matching on the string?
12:43:14 <vixey> I don't think that is considerably easier
12:43:31 <vixey> it doesn't compose though, which actually matters
12:43:39 <lispy> readDirections [] = []; readDirections ('N':rest) = N : readDirections rest; etc
12:43:54 <vixey> readDirections = many readDirection
12:44:06 <pastorn> @logs
12:44:06 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
12:44:16 <pastorn> @log
12:44:17 <lambdabot> Maybe you meant: bug let msg yow
12:44:26 <lispy> I'm just saying, parsec isn't really needed here if you're just parsing single characters
12:44:51 <roderyk> what's the best way of handling RGB color merges? (possibly with different levels of flux). Currently I'm just xor'ing the two colors (and ignoring flux), but I'm sure there must be some accepted algorithms for this?
12:44:54 <vixey> no not needed, but it is definitely the best way to do it, don't you agree?
12:45:46 <vixey> roderyk: mixing them like light or like paint?
12:45:51 <lispy> vixey: no :)
12:46:00 <vixey> lispy: So how you would do it?
12:46:05 <roderyk> vixey: like light
12:46:12 <lispy> vixey: as I said already
12:46:15 <vixey> roderyk: You just add them then, don't average
12:46:31 <vixey> lispy: but that way doesn't compose with other parsers i.e. it's not useful
12:46:49 <lispy> vixey: if you like you can say, many = map, and give a one character version and then use your readDirecitons = map readDirection
12:47:01 <roderyk> vixey: max(a+b, 255) for each RGB value?
12:47:08 <lispy> vixey: what other parsers?  This person is not using parsec.
12:49:13 <lispy> vixey: I guess on IRC you can give suggestions with answers, but it rarely seems to work to give suggestionsn instead of answers.  Eg., people have a solution in mind, so might as well help them with that solution and offer a bit of advice and just drop the advice if they don't want it.
12:49:35 <lispy> vixey: in this case, parsec is the unwanted advice
12:49:49 <dons> ?users
12:49:50 <lambdabot> Maximum users seen in #haskell: 540, currently: 538 (99.6%), active: 23 (4.3%)
12:49:53 <dons> huh.
12:49:59 <Valodim> wow
12:50:07 <lispy> nice
12:50:12 <dons> welcome to all the new people :)
12:50:14 <lanaer> suppose I count as one of the inactive ones
12:50:16 <lispy> must be Fall term at must universities again :)
12:50:20 <lanaer> and new, as well ;)
12:50:35 <Botje> wow
12:50:37 <roderyk> lispy: lol
12:50:39 <Valodim> aw
12:50:39 <pjdelport> dons: almost over 9000
12:50:40 <lanaer> lispy: hah, indeed.
12:50:41 <Botje> this channel just keeps growing and growing
12:50:46 <lanaer> though I’m a few years past college
12:50:50 <Deewiant> there must be a space leak somewhere
12:50:54 <dons> we must be very close to #perl now
12:51:08 <dons> that'd be something of a milestone. :)
12:51:11 <Botje> perl has 582 members
12:51:18 <Botje> of which 50ish are people :p
12:51:21 <lispy> ?remember Deewiant [on the growing size of #haskell] there must be a space leak somewhere
12:51:22 <dons> 551 currently?
12:51:22 <lambdabot> I will never forget.
12:51:36 <kig> the [RGBA] over blend (non-premult) is src_a * src + ((1-src_a) * dst) .. uh, for 8-bit ints it's something like (src * src_a / 256) + (((255 - src_a) * dst) / 256). to use it for plain RGB, just replace src_a with a constant alpha
12:52:03 <plutonas> what else could fp stand for except functional programming?
12:52:13 <kig> floating point
12:52:16 <lispy> plutonas: fungus plantation
12:52:20 <Deewiant> function pointer
12:52:23 <lanaer> free penguins?
12:52:27 <mattam> free party
12:52:39 <lispy> free plantains
12:52:41 <plutonas> hm, i think i'll go with function pointer and free party for the moment
12:52:54 <plutonas> :) thanks
12:52:56 <lispy> fast programs?
12:52:58 <lanaer> free pie!
12:53:04 <kig> first post
12:53:05 <plutonas> oh fast programs is perfect
12:53:06 <plutonas> thanks
12:53:17 <pjdelport> FP is a programming language and a complexity class
12:53:30 <lispy> complexity class?
12:53:49 <plutonas> lispy: yeap
12:53:52 <lispy> Only polynomial algorithms need apply?
12:53:53 <Lord_Illidan> Free Pascal?
12:54:05 <plutonas> guys it's ok, i chose fast programs
12:54:10 <plutonas> was the best suiting :)
12:54:11 <plutonas> thanks
12:54:23 <lispy> We like over doing it :)
12:54:28 <lanaer> but… it’s *fun* to keep coming up with words
12:54:39 <lanaer> and it’s a way for me to avoid doing work
12:54:49 <lispy> Quick, someone generate all the words for FP from dict!
12:54:52 <Lord_Illidan> Generator function to generate words
12:55:09 <Lord_Illidan> F*** Pascal
12:55:12 <Lord_Illidan> :P
12:55:22 <lispy> hmm...where is dict located again?
12:55:39 <kig> an irc bot that asks people to come up with backronyms
12:55:46 <lispy>  /usr/share/dict/words
12:56:01 <Lord_Illidan> Bah, you're one of these linux freetards?
12:56:07 <kig> enter recursion
12:57:10 <vixey> roderyk: a+b
12:57:19 <vixey> roderyk: real light doesn't have a maximum of 255
12:57:58 <Lord_Illidan> Just kidding, everyone I use Linux, myself.
12:58:12 <Lord_Illidan> Listen, is there an easy way to swap 2 numbers in 2 different lists?
12:58:35 <vixey> yeah break the problem down
12:58:37 <Lord_Illidan> I wrote my own function to do it but it generates 2 more lists to do it :| is there a way to do it in place?
12:58:49 <vixey> in place? like mutating the lists?
12:58:54 <Lord_Illidan> yes
12:58:54 <jdrake> I need to convert a model component (of an MVC program) from python. In python it was implemented with a class and the data it contained was essentially a [((int,int),string)]. What would be the best way to convert this, and is there anything specifically I should read?
12:59:25 <pjdelport> jdrake: does the order matter?
12:59:26 <Lord_Illidan> I'm rather ashamed of my function tbh
12:59:57 <jdrake> pjdelport, nope, only its meaning.
13:00:09 <pjdelport> jdrake: is it a mapping?
13:00:25 <pjdelport> if so, Data.Map would be the first place to look
13:00:31 <Lord_Illidan> Here's mine : http://hpaste.org/10953
13:00:59 <jdrake> It is a planet location (x,y) and name associated with it. In python I used a list. I expect to be able to filter the stuff I need out of it.
13:01:18 <vixey> Lord_Illidan: Right idea but you should write swapVariables it terms of some smaller functions
13:01:19 <pjdelport> @index Data.Map
13:01:19 <lambdabot> bzzt
13:01:25 <pjdelport> @hoogle Data.Map
13:01:25 <lambdabot> module Data.Map
13:01:25 <lambdabot> Data.Map data Map k a
13:01:25 <lambdabot> Data.ByteString map :: (Word8 -> Word8) -> ByteString -> ByteString
13:01:31 <vixey> (which you may also need to write)
13:01:34 <pjdelport> how does this thing work again
13:01:39 <dons> jdrake: what operations do you use?
13:01:44 <dons> just listy ones, or lookup, or ... ?
13:01:52 <Lord_Illidan> smaller functions?
13:02:03 <Lord_Illidan> you mean instead of using take and drop?
13:02:06 <lispy> whoa, making acronyms from dict made waaay too many words :)
13:02:07 <jdrake> I have only used list filtering so far.
13:02:22 <dons> jdrake: so just use lists?
13:02:24 <jdrake> But this is a small demo, not the full blown program.
13:02:36 <jdrake> dons, yeah, probably best for now.
13:02:58 <jdrake> Would it be a good idea to make a datatype or something for each item?
13:03:12 <dons> perhaps, if it conveyed more meaning than a triple
13:03:28 <mml`> anybody here ever try to implement Okasaki's square matrices from http://www.eecs.usma.edu/webs/people/okasaki/icfp99.ps ?
13:03:28 <jdrake> It may later add more data to it
13:03:41 <dons> data Thing = Thing { x, y :: !Int, name :: String }
13:03:44 <dons> or something
13:03:48 <dons> data Planet = .. ?
13:03:55 <jdrake> What does !Int do?
13:04:09 <dons> oh, makes it strict, so it optimises a bit better.
13:04:19 <dons> only relevant if you care about performance to an extreme degree.
13:04:40 <jdrake> dons, I am converting the program from python :-)
13:04:47 <Deewiant> speaking of which, uvector doesn't build in 6.10 because it uses strictness annotations in newtypes
13:04:56 <dons> Deewiant: i thought i already fixed that.
13:05:00 <dons> did i not do the release yet?
13:05:05 <Deewiant> maybe you did
13:05:10 <Deewiant> this was yesterday
13:05:13 <dons> well, anyway, patch in the darcs vers. for this.
13:05:17 <pjdelport> jdrake: http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html
13:05:19 <lambdabot> Title: Data.Map, http://tinyurl.com/2mpwee
13:06:07 <jdrake> pjdelport, can maps hold records as well?
13:06:08 <pjdelport> jdrake: a lot of your questions really depend on how you want to use the structure, in the end
13:06:14 <pjdelport> maps can hold anything
13:07:01 <pjdelport> jdrake: maps are essentially like Python dicts
13:07:05 <jdrake> I think a map indexed by the (x,y) with the data associated with it in a record form (which for now is just name) would be good. Then I can do direct lookup.
13:07:11 <dons> "I’m currently writing a real-time
13:07:12 <dons> strategy game in Haskell"
13:07:16 <dons> http://intoverflow.wordpress.com/2008/10/05/recent-activities/
13:07:17 <lambdabot> Title: Recent activities « Integer Overflow
13:07:27 <dons> jdrake: yup
13:08:17 <jdrake> Right now I will just associate with a string rather than the entire data
13:08:53 <FrankDuncan> How does one ask lambdabot to join a diff channel/
13:09:08 <lispy> lambdabot: ?join #diff
13:09:08 <lambdabot> Not enough privileges
13:11:51 <jdrake> Can I have a module that spans more than one file? I wouldn't mind having a Starmap module that then has 'Model' and then 'View' in their own namespaces
13:12:45 <sjanssen> jdrake: the rule is one module per file
13:13:01 <Deewiant> you can have a package, though
13:13:03 <sjanssen> jdrake: but you could make smaller internal modules which are re-exported by one larger module
13:13:28 <dons> ?users
13:13:28 <lambdabot> Maximum users seen in #haskell: 540, currently: 537 (99.4%), active: 25 (4.7%)
13:13:35 <mc__> how can I access the value for a specific indices in an array?
13:13:45 <dons> mc__: an Array, as in Data.Array?
13:13:49 <moonpatio> @type (!)
13:13:50 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
13:13:54 <mc__> dons: yes
13:13:56 <dons> > "haskell" !! 4 -- or a list?
13:13:57 <lambdabot>   'e'
13:14:01 <dons> using (!!)
13:14:08 <dons> or (!)
13:14:12 <dons> for arrays, the former for lists.
13:14:19 <jdrake> sjanssen, how would I do this?
13:14:38 <jdrake> I like how Data is setup where you have Map and others beneath it
13:14:56 <sjanssen> jdrake: oh, you just use "module Foo.Bar.Baz where"
13:14:57 <dons> hierarchies of loveliness
13:15:00 <mc__> dons: are !/!! dangerous or something? (because the are !!!
13:15:04 <mc__> 's
13:15:08 <sjanssen> jdrake: and then the file should be located at "Foo/Bar/Baz.hs"
13:15:17 <jdrake> sjanssen, awesome, I shall use that
13:15:30 <dons> mc__: nope :)
13:15:40 <mc__> alright :)
13:15:53 <jdrake> time to do some outside work...
13:15:54 <sjanssen> mc__: they are partial though (if the index is out of bounds)
13:15:59 <mml`> :k forall b. Int
13:16:01 <lambdabot> *
13:16:12 <mml`> hmm... more to the point, isn't that just Int?
13:16:41 <sjanssen> mml`: yes
13:16:59 <mml`> sjanssen: wish ghc knew that: No instance for (Num (. (forall b) Int))
13:17:20 <mightybyte> @seen rwbarton
13:17:20 <lambdabot> rwbarton is in #darcs and #haskell. I don't know when rwbarton last spoke.
13:17:33 <sjanssen> mml`: what is "(."?
13:17:59 <Deewiant> mml`: perhaps you don't have forall enabled?
13:18:11 <mml`> sjanssen: i'm guessing it's just "forall b. Int" with "." written as a prefix operator rather than an infix operator
13:18:24 <sjanssen> mml`: that is strange, I've never seen that
13:19:28 <mml`> Deewiant: how do i enable forall?
13:19:39 <rwbarton> mightybyte: hey
13:20:12 <mc__> how to handle the case for ! when the index is out of bounds?
13:20:29 <Deewiant> mml`: Rank2Types at least enables it, not sure what's the most 'basic' one
13:20:39 <mightybyte> rwbarton: Using STUArray worked, but it was really slow.
13:20:41 <rwbarton> mml`: you probably have TypeOperators enabled but not Rank2Types/RankNTypes/ExistentialTypes/etc.
13:20:53 <mightybyte> ...took almost 18 minutes on my box
13:22:05 <mightybyte> rwbarton: ...where the C implementation took something like 30 seconds.
13:22:55 <eu-prleu-peupeu> hello people from planet haskell
13:22:55 <mml`> rwbarton: that was it exactly
13:22:58 <mml`> Deewiant++
13:24:16 <rwbarton> mightybyte: hmm, I can certainly believe that order of magnitude difference if you're not careful to write code the optimizer can handle
13:24:47 <dblazakis> ?users
13:24:47 <lambdabot> Maximum users seen in #haskell: 540, currently: 536 (99.3%), active: 21 (3.9%)
13:25:17 * rwbarton wishes there was a NoForallKeyword language pragma which was off by default & better error messages
13:26:19 <mightybyte> rwbarton: http://hpaste.org/10951#a1
13:27:17 <moonpatio> , let arr = (listArray (0,25) ['a'..'z']::Array Int Char) in map (arr!) (randomRs (0,25) (mkStdGen 0))
13:27:19 <lunabot>  "dbhambtrzyheykkrgfdsugsdifyndepytogmukbbzkyjdtxtdeftwaazpohtmwmmpnlevrzh...
13:28:45 <vixey> @arr!
13:28:46 <lambdabot> Aye
13:29:05 <rwbarton> mightybyte: are you on a 64-bit machine?
13:29:17 <mightybyte> Yes
13:29:37 <mightybyte> ...with 8 cores
13:29:59 <rwbarton> mightybyte: well, looking at the core, fillMultiples is doing dictionary unpacking on the array.  That's not good.
13:30:10 <mightybyte> Ahh
13:30:54 <mightybyte> I think I've seen this performance disparity before...hence the reason I kind of default to IOArray.
13:31:42 <rwbarton> mightybyte: Maybe if you write a totally specialized type signature for your top-level definitions
13:32:06 <mightybyte> rwbarton: Ok, I'll try that.
13:32:09 <vixey> hi has anybody written or done IO and partiality/general recursion monad together?
13:32:15 <vixey> I tried but I could not get it to work
13:32:32 <vixey> (specifically fixedpoints of tree recursive functions...)
13:34:32 <rwbarton> mightybyte: Judging from the core, that should help a lot
13:35:01 <jdrake> The only time I can have a beer, that tastes any good, is when I do some sweaty work outside. I hate doing that kind of work because I am a lazy SOB. This beer tastes good though.
13:36:17 <Sompa>  hi all, we just launched a new forum for blackhats, its at http://www.bhseo.de join now and help us build a community for bhseo's :)
13:36:19 <lambdabot> Title: bhseo.de - Index
13:36:48 <vixey> Sompa: this is off topic for freenode
13:36:50 <jdrake> Sompa, do you not know the way of the monad? The monad's hat is white.
13:37:17 <BONUS_> hey EvilTerran
13:37:29 <BONUS> is he here
13:38:10 <rwbarton> @users
13:38:10 <lambdabot> Maximum users seen in #haskell: 540, currently: 530 (98.1%), active: 23 (4.3%)
13:38:12 <sjanssen> oh, snap!
13:38:16 <BMeph> Sompa: Petition Denied. >;)
13:38:42 <sjanssen> whoa, 540?
13:39:14 <BMeph> BONUS: He's "here", but he's not *here*, if you get me. ;)
13:39:33 <BONUS> haha
13:40:40 <OceanSpray> I'd like to ask, how far is lambdabot 2: Electric Boogaloo coming along?
13:42:20 <moonpatio> , let bf [] k = k [] ; bf (Node x [] : fs) k = bf fs (\xs -> k (x:xs)) ; bf (Node x ts : fs) k = bf fs (\xs -> bf ts (\ys -> k (x:xs++ys))) in flip bf id [Node 'a'[Node 'b'[],Node 'q'[Node 'e'[],Node 'h'[]]],Node 'v'[Node '4'[],Node '*'[]]]
13:42:21 <lunabot>  "av4*bqeh"
13:42:53 <moonpatio> , flatten [Node 'a'[Node 'b'[],Node 'q'[Node 'e'[],Node 'h'[]]],Node 'v'[Node '4'[],Node '*'[]]]
13:42:55 <lunabot>  luna: Couldn't match expected type `Data.Tree.Tree a'
13:42:55 <lunabot>         against inferred type `[a1]'
13:43:02 <moonpatio> , fmap flatten [Node 'a'[Node 'b'[],Node 'q'[Node 'e'[],Node 'h'[]]],Node 'v'[Node '4'[],Node '*'[]]]
13:43:04 <lunabot>  ["abqeh","v4*"]
13:45:48 <mightybyte> rwbarton: Hmm, the type signatures don't seem to help.
13:48:17 <mightybyte> rwbarton: Oh no, I spoke too soon.  The type signatures cut it down to 4m52s.
13:49:11 <Lord_Illidan> hey
13:49:15 <Lord_Illidan> > do;x<-[1,2];delete x [1,2]
13:49:16 <lambdabot>   [2,1]
13:49:24 <Lord_Illidan> can anyone explain how that happens??
13:49:33 <vixey> > do;x<-[1,2];delete 1 [1,2]
13:49:35 <lambdabot>   [2,2]
13:49:44 <Lord_Illidan> yes, but x is a whole list
13:49:46 <vixey> > do;x<-[1,2,3,4,5];delete x [1,2,3,4,5]
13:49:48 <lambdabot>   [2,3,4,5,1,3,4,5,1,2,4,5,1,2,3,5,1,2,3,4]
13:50:01 <lispy> > delete 1 [1,2]
13:50:02 <lambdabot>   [2]
13:50:07 <vixey> > concatMap (\x -> delete x [1,2,3,4,5]) [1,2,3,4,5]
13:50:09 <lambdabot>   [2,3,4,5,1,3,4,5,1,2,4,5,1,2,3,5,1,2,3,4]
13:50:23 <lispy> Yeah, it's the concatMap getting you
13:50:32 <Lord_Illidan> I took the impression that when you have x <- [1,2] and delete x [1,2], you should end up with nul
13:50:35 <Lord_Illidan> not a swap!
13:50:50 <vixey> Lord_Illidan: see my example, it's not swapping
13:50:55 <lispy> Lord_Illidan: you concat the results of all the deletes
13:51:03 <vixey> > do;x<-[1,2];return (delete 1 [1,2])
13:51:04 <lambdabot>   [[2],[2]]
13:51:16 <vixey> > do;x<-[1,2];y <- delete x [1,2];return y
13:51:16 <BONUS> x <- [1,2] is more like: for every element in [1,2], delete that element from the list [1,2] and then concatenate that
13:51:17 <lambdabot>   [2,1]
13:51:32 <vixey> > do;x<-[1,2,3];y <- delete x [1,2,3];return y
13:51:34 <lambdabot>   [2,3,1,3,1,2]
13:51:38 <Lord_Illidan> I saw this being used in a permutation algorithm on project euler which is why I'm asking
13:51:51 <vixey> > do;x<-[1,2,3];return (delete x [1,2,3])
13:51:53 <lambdabot>   [[2,3],[1,3],[1,2]]
13:51:55 <lispy> > (\y -> do x <- y; delete x y) [1..4]
13:51:56 <Lord_Illidan> I can't for the life of me understand why it's working
13:51:56 <lambdabot>   [2,3,4,1,3,4,1,2,4,1,2,3]
13:52:18 <vixey> Lord_Illidan: did you see the example I gave above though? it should explain it .hopefully
13:52:27 <lispy> > (\y -> do x <- y; return [delete x y]) [1..4]
13:52:29 <lambdabot>   [[[2,3,4]],[[1,3,4]],[[1,2,4]],[[1,2,3]]]
13:52:38 <BONUS> the permutation algoritm is permute xs = [y:ys | y <- xs, ys <- permute (delete x xs)], right?
13:52:42 <Lord_Illidan> Here is the full one in it's entirety : http://hpaste.org/10954
13:52:43 <lispy> > (\y -> do x <- y; return $ delete x y) [1..4] -- does this help?
13:52:45 <lambdabot>   [[2,3,4],[1,3,4],[1,2,4],[1,2,3]]
13:52:51 <BONUS> read the <- as "is drawn from"
13:52:54 <vixey> Lord_Illidan: hellloooo?
13:53:05 <Lord_Illidan> sry vixey, a lot of posts at ones
13:53:08 <Cale> Using delete is a bad way to write a permutation algorithm though
13:53:08 <Lord_Illidan> once, sry
13:53:28 <Lord_Illidan> It does work, but I used a more classical Knuth-ish algorithm
13:53:29 <BONUS> Cale: do you mean because of duplicates?
13:53:35 <Cale> For one, yeah.
13:53:42 <vixey> knuth in haskell? :S yuck
13:53:54 <Cale> also, the type
13:54:00 <Cale> and the performance
13:54:11 <vixey> Lord_Illidan: You know all the datatypes in haskell are immutable and every function is pure yes?
13:54:17 <BONUS> what's wrong with the type?
13:54:23 <Lord_Illidan> vixey, yes
13:54:25 <vixey> Lord_Illidan: it admits a very different style than knuth uses..
13:54:28 <Cale> You don't need to compare things for equality in order to produce all the permutations of a list, but the 'delete' algorithm does.
13:54:47 <Lord_Illidan> I know, but it was the only algorithm I could find for lexicographical permutations
13:54:49 <BONUS> ah, that's a valid point, yes
13:55:10 <vixey> you should design one that fits with functional programming better
13:55:23 <Lord_Illidan> Yes, actually it was a bitch to do in haskell
13:55:26 <vixey> and of course it should be done via recursion,
13:55:30 <vixey> so let's think about it...
13:55:33 <Lord_Illidan> it does work via recursion
13:55:42 <vixey> if you have a way to find the permutations of xs, and you want every permutation of x:xs
13:56:05 <vixey> do you know how to do that?
13:56:22 <Lord_Illidan> not sure, give me a sec, vixey
13:56:27 <lispy> permutations [] = []; permutations [x] = [x] : permutations [] -- for a start ;)
13:56:32 <vixey> to make it more concrete
13:56:32 <Lord_Illidan> I'm still trying to comprehend the delete thing
13:56:42 <vixey> forget the delete thing
13:56:52 <lispy> delete 'delete' things
13:56:57 <vixey> say tha all the permutations of "abc" are ["abc","acb",...]
13:57:05 <Lord_Illidan> yes, ok
13:57:09 <vixey> and you want all permutations of "!abc" from that
13:57:28 <vixey> just try to write a function that turns '!' ["abc","acb",...] ~~> that
13:57:46 <vixey> if you got that correctly, then that is actually the entire program written
13:57:55 <vixey> (excep for permutation [] = [[]]
13:57:56 <vixey> )
13:58:24 <vixey> lispy, bad way to start.. :p
13:58:42 <rwbarton> vixey: it's a little tricky to write that function to be both efficient and produce its output in lexicographical order
13:59:45 <Lord_Illidan> won't work, I'm afraid when I get my mind hooked on something I can't rip it away..
13:59:50 <rwbarton> mightybyte: Is Word64 faster than Int?
14:00:49 <vixey> Lord_Illidan: oh ok, just ignore everything I said then
14:01:10 <Lord_Illidan> I'm with you, vixey, I'm with you, and thanks btw
14:01:15 <Lord_Illidan> but regarding that delete thing
14:01:37 <Lord_Illidan> I think I'm not understanding how <- works
14:01:51 <lispy> Lord_Illidan: the only reason the delete thing seems weird to you is because you don't fully understand how the instance of Monad works for lists
14:01:56 <vixey> Lord_Illidan: ok, you should try to solve the problem I mentioned with '!' and ["abc",...]
14:02:07 <vixey> Lord_Illidan: if you give up I can show you a solution
14:02:12 <lispy> > (\y -> do x <- y; return $ delete x y) [1..4] -- Lord_Illidan look at this
14:02:13 <lambdabot>   [[2,3,4],[1,3,4],[1,2,4],[1,2,3]]
14:02:44 <vixey> rwbarton: not caring about efficiency but lexicographical order?
14:02:55 <vixey> rwbarton: whath should the permutations of "123" be?
14:02:59 <hellige> any lambdabot ops about?
14:03:20 <Lord_Illidan> 123,132,213, so on
14:03:23 <mperillo_> hi
14:03:41 <dons> ?users
14:03:41 <lambdabot> Maximum users seen in #haskell: 540, currently: 525 (97.2%), active: 20 (3.8%)
14:03:43 <lispy> Lord_Illidan: do you see that the 'returned' lists are concatenated together?
14:03:56 <mperillo_> I need an advice on how to model  CSS selectors
14:04:04 <lispy> Lord_Illidan: and that by deleting x from the input list, we keep getting a new copy where just one thing is deleted?
14:04:10 <mperillo_> the grammar is   simple_selector [ combinator simple_selector ]*
14:04:31 <Lord_Illidan> maybe, but to my untrained eyes..
14:04:32 <dons> http://www.galois.com/blog/2008/10/06/tech-talk-the-future-of-cabal/
14:04:36 <rwbarton> vixey: I think it was a requirement that permutations "123" produce ["123", "132", "213", "231", "312", "321"]
14:04:37 <Lord_Illidan> heck, I should just study monads
14:04:38 <lambdabot> Title: Galois › Blog › Blog » Tech Talk: The Future of Cabal, http://tinyurl.com/3raegj
14:05:04 <Botje> mperillo_: you could see css selectors as a chain, terminated by a leaf node
14:05:07 <rwbarton> vixey: of course, if you don't care about efficiency, you can just sort at the end
14:05:10 <vixey> Lord_Illidan: the best thing you could do is figure out the function I said you could try and write..
14:05:12 <mperillo_> what it the best way to model this? [(SimpleSelector, Combinator)] or [(SimpleSelector, Maybe Combinator)] ?
14:05:19 <vixey> rwbarton: ok my way doesn't come out in that order
14:05:31 <rwbarton> vixey: Right
14:05:34 <tromp_> @let permute = join (evalStateT . mapM (const (StateT pick))) where pick [] =
14:05:34 <tromp_>  []; pick (x:xs) = (x,xs) : map (second (x:)) (pick xs)
14:05:34 <lambdabot>   Parse error
14:05:55 <mperillo_> Botje, rigth, this is current implementation I'm using
14:05:56 <tromp_> @let permute = join (evalStateT . mapM (const (StateT pick))) where pick [] = []; pick (x:xs) = (x,xs) : map (second (x:)) (pick xs)
14:05:58 <lambdabot>  Defined.
14:06:13 <tromp_> > permute "123"
14:06:14 <lambdabot>   ["123","132","213","231","312","321"]
14:06:26 <tromp_> will be lexicographic as long as argument is sorted
14:06:55 <roconnor> @hoogle [a] -> [(a,[a])]
14:06:56 <lambdabot> Data.Char readLitChar :: ReadS Char
14:06:56 <lambdabot> Numeric readFloat :: RealFrac a => ReadS a
14:06:56 <lambdabot> Prelude reads :: Read a => ReadS a
14:07:17 <Lord_Illidan> > permute [0..9]
14:07:19 <lambdabot>   [[0,1,2,3,4,5,6,7,8,9],[0,1,2,3,4,5,6,7,9,8],[0,1,2,3,4,5,6,8,7,9],[0,1,2,3...
14:07:41 <rwbarton> > permute [0..19] !! 123
14:07:43 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,15,14,16,18,19,17]
14:07:50 <mml`> > length $ permute [0..9]
14:08:05 <lambdabot>   thread killed
14:08:12 <Lord_Illidan> > permute [0..9] !! (10^6)
14:08:20 <vixey> > length $ permute [1..4]
14:08:20 <roconnor> @hoogle [a] -> [([a],a,[a])]
14:08:21 <lambdabot> No results found
14:08:22 <lambdabot>   24
14:08:27 <lambdabot>   thread killed
14:08:32 <int-e> > product [1..10]
14:08:34 <lambdabot>   3628800
14:09:16 <Botje> mperillo_: i'd model it more into the type
14:09:36 <Botje> something like data Selector = Simple SimpleSelector | Chain Combinator Selector Selector
14:09:48 <mperillo_> Botje, what do you mean?
14:11:09 <rwbarton> > let choices =  zip3 <$> (init . inits) <*> id <*> (tail . tails) in choices "12345"
14:11:11 <lambdabot>   [("",'1',"2345"),("1",'2',"345"),("12",'3',"45"),("123",'4',"5"),("1234",'5...
14:11:23 <Botje> see above :)
14:11:35 <mperillo_> Botje, thanks, it seems interesting and more structured
14:11:55 <Lord_Illidan> the functions second and pick, where are they defined?
14:12:05 <Lord_Illidan> in tromp's permute function?
14:12:09 <vixey> use hoogle
14:12:31 <mml`> @hoogle second
14:12:32 <lambdabot> Control.Arrow second :: Arrow a => a b c -> a (d, b) (d, c)
14:12:32 <lambdabot> Data.Time.Clock secondsToDiffTime :: Integer -> DiffTime
14:12:32 <lambdabot> Data.Time.Clock.TAI type LeapSecondTable = Day -> Integer
14:12:36 <mml`> @hoogle pick
14:12:36 <lambdabot> No results found
14:12:47 <Lord_Illidan> Arrow classes, hmm
14:12:48 <tromp_> i defined pick right in there
14:12:49 <Cale> Of course, perhaps more sane to understand at first would be something like:
14:13:04 <Lord_Illidan> yeah, I saw pick
14:13:19 <tromp_> second is in Prelude
14:13:26 <BMeph> > (\y -> do x <- y; return $ delete x y) [2,1,2]
14:13:28 <lambdabot>   [[1,2],[2,2],[1,2]]
14:13:42 <Lord_Illidan> <interactive>:1:0: Not in scope: `second'
14:13:45 <int-e> second is in Control.Arrow
14:14:03 <BMeph> tromp_ snd is in Prelude. :)
14:14:04 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]; permute xs = [(y:zs) | (y,ys) <- select xs; zs <- permute ys] in permute [1,2,3,4,5]
14:14:04 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 129}...
14:14:17 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]; permute xs = [(y:zs) | (y,ys) <- select xs, zs <- permute ys] in permute [1,2,3,4,5]
14:14:18 <lambdabot>   []
14:14:21 <Cale> ...
14:14:26 <Lord_Illidan> I guess, when the brain is wired to do imperative programming, doing haskell is just not in it...
14:14:31 <Cale> heh, what did I mess up...
14:14:45 <Botje> mperillo_: you might even forego Chain and encode different kind of chaining operators in the type, but that might get messy
14:15:06 <rwbarton> Cale: Well, permute [] shouldn't be []
14:15:09 <int-e> Lord_Illidan: it takes a little time to get used to.
14:15:13 <Cale> oh, right
14:15:28 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]; permute [] = [[]]; permute xs = [(y:zs) | (y,ys) <- select xs, zs <- permute ys] in permute [1,2,3,4,5]
14:15:30 <lambdabot>   [[1,2,3,4,5],[1,2,3,5,4],[1,2,4,3,5],[1,2,4,5,3],[1,2,5,3,4],[1,2,5,4,3],[1...
14:16:38 <mperillo_> Botje, the combinator is a separate type
14:17:20 <Cale> But by thinking of the remaining things to permute as a kind of nondeterministic state, we see that the type of select [a] -> [(a,[a])] is also:
14:17:29 <sereven> >select  [1..5]
14:17:29 <mperillo_> Botje, now I'm using the CSS parser from factorcss, but I don't like the code
14:17:34 <Cale> @unmtl StateT [a] [] a
14:17:34 <lambdabot> [a] -> [(a, [a])]
14:17:43 <Cale> A computation in that monad
14:18:16 <BONUS> @pl \(a,b) -> a ++ "!" ++ b
14:18:16 <lambdabot> uncurry ((. ('!' :)) . (++))
14:18:19 <BONUS> yikes
14:18:20 <sereven> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in select [1..5]
14:18:22 <lambdabot>   [(1,[2,3,4,5]),(2,[1,3,4,5]),(3,[1,2,4,5]),(4,[1,2,3,5]),(5,[1,2,3,4])]
14:18:34 <rwbarton> Whoa
14:18:37 <rwbarton> @pl ("!"++)
14:18:38 <lambdabot> ('!' :)
14:18:52 <BONUS> :)
14:18:58 <rwbarton> @pl ("!" `mappend`)
14:18:58 <lambdabot> ("!" `mappend`)
14:19:01 <Cale> (which selects something from the list of elements remaining in the state, and returns it, while removing it from the state)
14:19:05 <Cale> So...
14:19:19 <Cale> :t let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in StateT select
14:19:21 <lambdabot> forall t. StateT [t] [] t
14:20:17 <Cale> Of course, if we do this as many times as we have elements in our initial list to permute, then we'll have produced all permutations (and the state will be empty)
14:20:55 <Cale> :t let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in runStateT (mapM (const (StateT select)) [1,2,3,4,5]) [1,2,3,4,5]
14:20:56 <lambdabot> forall t. (Num t) => [([t], [t])]
14:21:02 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in runStateT (mapM (const (StateT select)) [1,2,3,4,5]) [1,2,3,4,5]
14:21:03 <lambdabot>   [([1,2,3,4,5],[]),([1,2,3,5,4],[]),([1,2,4,3,5],[]),([1,2,4,5,3],[]),([1,2,...
14:21:29 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in evalStateT (mapM (const (StateT select)) [1,2,3,4,5]) [1,2,3,4,5]
14:21:30 <lambdabot>   [[1,2,3,4,5],[1,2,3,5,4],[1,2,4,3,5],[1,2,4,5,3],[1,2,5,3,4],[1,2,5,4,3],[1...
14:21:43 <Cale> (throwing away the empty final states)
14:22:08 <ddarius> Cale and his permutations.
14:22:27 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in evalStateT (replicateM 5 (StateT select)) [1,2,3,4,5]
14:22:28 <lambdabot>   [[1,2,3,4,5],[1,2,3,5,4],[1,2,4,3,5],[1,2,4,5,3],[1,2,5,3,4],[1,2,5,4,3],[1...
14:22:38 <BONUS> lol
14:22:41 <Cale> Of course, that's the same thing, but you must know the length of the list :)
14:22:49 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in evalStateT (replicateM 3 (StateT select)) [1,2,3,4,5]
14:22:51 <lambdabot>   [[1,2,3],[1,2,4],[1,2,5],[1,3,2],[1,3,4],[1,3,5],[1,4,2],[1,4,3],[1,4,5],[1...
14:23:04 <Cale> But it generalises to a nice way to pick fewer elements :)
14:45:12 * Philonous is wondering why the Reader monad is a monad rather than a comonad
14:45:26 <Philonous> It looks like a comonad in disguise to me
14:46:06 <geezusfreeek> it can be either
14:46:10 <rwbarton> The monad Reader a is right adjoint to the comonad (,) a
14:46:19 <Philonous> I suspect that any comonad can be made a monad
14:46:21 <geezusfreeek> @unmtl Reader a
14:46:21 <lambdabot> err: `Reader a' is not applied to enough arguments, giving `/\A. a -> A'
14:46:29 <geezusfreeek> @unmtl Reader r a
14:46:29 <lambdabot> r -> a
14:46:56 <ddarius> Philonous: Certainly not in general.
14:46:57 <geezusfreeek> Philonous, i am not an expert, but i doubt it
14:47:10 <rwbarton> Philonous: No, this is something special about (,) a and Reader a
14:47:25 <rwbarton> For example, Reader a (x, y) ~= (Reader a x, Reader a y)
14:47:38 <rwbarton> but [(x, y)] ~/= ([x], [y])
14:47:47 * lispy started reading "Why dependent types matter" but is sort of frustrated with the unreadable syntax of epigram
14:48:07 <ddarius> lispy: Buy new eyes.
14:48:38 <lispy> ironically, I did that once this summer
14:48:50 <ddarius> You got ripped off.
14:49:27 <geezusfreeek> i like epigram's syntax besides that it's done with the code equivalent to ascii art
14:49:35 <geezusfreeek> if it was just a gui it would be great
14:49:58 <lispy> how would you write this? data \frac{}{Nat : *} where \frac{}{0 : Nat} \frac{n : Nat}{1+ n : Nat}
14:50:27 <lispy> What's the point, for example, of \frac{}{Nat : *}
14:51:15 <rwbarton> In case Nat was a type constructor and you wanted to say something about its arguments, I presume
14:52:38 <mmorrow> zomg inotify is useful x10
14:53:35 <lispy> <= rec x (is equivalent to haskell) = case x of
14:54:06 <rwbarton> Yeah, the <= and => bugged me
14:54:31 <lispy> I think the debuction rules bug me the most :)
14:54:47 <lispy> I have no idea how you'd write this syntax in a text editor the way they've typeset it
14:59:07 <lispy> oh, hrm, finding epigram examples programs is not easy
14:59:41 <lispy> ah, n/m found it on wikipedia
14:59:51 <lispy> yeah, wow, I would not want to write this language without massive editor support
15:00:05 <dolio> <= rec x is not equivalent to case.
15:00:06 <ddarius> That was the intent.
15:00:12 <dolio> I think <= case x is.
15:00:31 <dolio> Although I haven't done much epigram reading in a while.
15:00:59 <lispy> dolio: ah, the authors don't really explain in that paper, so I was guessing.  But, it seems that they say, <= rec x, then the next few lines define patterns on x
15:01:57 <rwbarton> lispy: Also, my very vague understanding from near the end of the paper is that 'rec' there is not a keyword in the language
15:02:05 <rwbarton> lispy: or at least, you can define your own kind of things like 'rec'
15:02:11 <dolio> I seem to recall most '<= rec x' being followed by '<= case x' as well, but maybe I'm off.
15:02:47 <dolio> And, yeah, rec is just the standard structural recursion widget, or whatever they call it.
15:02:55 <dolio> Which is a pretty cool thing about epigram.
15:03:20 <lispy> line 1:      (        !        (        !   (  n : Nat !  line2: daat !---------! where !---------! ; !---------! line 3:     ! Nat : * )      ! zero : Nat)   ! suc n : Nat)
15:03:29 <dolio> case might be 'just' a predefined view, too.
15:04:09 <lispy> given a standard 1 dimentional grammar, I think it might be a bit nicer to programmers and current tools :)
15:04:52 <rwbarton> you better not decide to rename Nat to Natural...
15:05:03 <mmorrow> inotify ftw http://hpaste.org/10960
15:08:58 <cosmint> DRMacIver
15:09:47 <DRMacIver> Hm?
15:11:14 <lispy> mmorrow: do you know about hnotify?
15:11:32 <lispy> mmorrow: oh, it lookslike you do
15:13:12 <lispy> For the record, I'm not objecting to epigram.  I'm just turned off by the syntax.
15:13:34 <dolio> It's most definitely not for use without editor support.
15:13:49 <dolio> I've actually written some by hand. It isn't very fun.
15:14:23 <dolio> I find the case trees kind of ugly, too.
15:14:52 <dolio> With all the {{{ }}}
15:19:40 <dons> ?uptime
15:19:40 <lambdabot> uptime: 1d 2h 25m 54s, longest uptime: 1m 10d 23h 44m 29s
15:23:30 <ivanm> a fair way to go to match the longest uptime...
15:24:27 <dons> 15:19  dons> ?uptime
15:24:27 <dons> 15:19  lambdabot> uptime: 3m 4d 5h 19m 26s, longest uptime: 3m 4d 5h 19m 26s
15:24:43 <dons> galois-lambdabot. it has the stability. ;)
15:25:00 <Botje> no, it doesn't have all of #haskell poking at it :P
15:28:32 <eu-prleu-peupeu> where can i learn about the ffi ?
15:33:07 <lispy> we have a galois-lambdabot?
15:34:13 <dblazakis> internal irc channel?
15:38:35 <ivanm> grc: galois relay chat ;-)
15:43:01 <njbartlett_> Anybody tried to compile Yhc on Intel Mac OSX?
15:43:29 <dmwit> eu-prleu-peupeu: The addendum to the Report is the canonical place to learn.
15:43:42 <dmwit> It says basically all there is to know, simply and nicely.
15:43:44 <eu-prleu-peupeu> thanks dmwit
15:44:55 <rwbarton> This ResultSet monad is actually kind of neat.
15:45:29 <pastorn> rwbarton: ResultSet sounds a lot like the list monad...
15:45:31 <rwbarton> It's an interesting compromise in the design space of []-like monads that deal with infinite lists "fairly"
15:45:34 <pastorn> at least the name...
15:46:05 <luqui> uh oh.   where is said ResultSet?
15:46:23 <rwbarton> luqui: In a recent email to haskell-cafe
15:47:44 <rwbarton> luqui: As far as I can tell, it really is a monad, and it can deal with infinite lists fairly, the only caveat is that you have to give it a little nudge telling it how to do so
15:48:13 <rwbarton> (by assigning elements of the infinite list "costs" which diverge to infinity)
15:48:21 <luqui> the assocativity law holds?
15:48:27 <rwbarton> I believe it does
15:48:39 <rwbarton> though I haven't proven it formally
15:48:40 <luqui> cool.  I'll have to check, but that would be nice.
15:50:13 <lispy> they're not infinite lists, they're just codata
15:50:14 <Philonous> Ah, I finally figured out why I can't build a monad out of every comonad. My idea was to just take the CoKleisli arrows as my monadic type, but for that to work I'd have to reconstruct the comonadic type later, and I can't do that for every comonad. (I guess that's what you where saying in the first place, but I needet a minute to get that)
15:53:25 <rwbarton> this is like a trick in algebra where you have some infinite-dimensional vector space, but you give a grading where each graded piece is finite-dimensional, and it becomes much easier to handle
16:04:41 <Botje> okay
16:04:42 <Botje> *splat*
16:04:52 <Botje> shouldn't have read these two last statements.
16:22:26 <rwbarton> luqui: Ah, turns out ResultSet is not a monad after all.  I just wasn't doing a sufficiently complicated test.
16:22:47 <rwbarton> luqui: It might turn out to be a monad if you restrict the kind of values you can contruct, though
16:24:43 <mightybyte> rwbarton: Wow.  Word64 is 4m52s, and Int is 1m29s.
16:26:19 <rwbarton> Int should be 64 bits anyways
16:26:29 <rwbarton> > maxBound :: Int   -- on a 64-bit platform
16:26:30 <lambdabot>   9223372036854775807
16:26:42 <dmwit> boxing?
16:26:51 <pastorn> > maxBound :: Word64
16:26:52 <lambdabot>   18446744073709551615
16:27:05 <rwbarton> Yeah, there were some Word64 <-> Int conversions in the core, though I didn't know whether it was because I was on a 32-bit system
16:27:09 <pastorn> > (maxBound :: Word64) `div` 2
16:27:11 <lambdabot>   9223372036854775807
16:28:26 <rwbarton> That's pretty close to C then.  If you wanted it to be faster, probably the next thing would be to manually fuse the mapM_ with its list argument and do strength reduction (adds instead of multiplies)
16:30:58 <rwbarton> mightybyte: so you just had to write the type signature and switch to Int?  That's pretty painless
16:40:53 <eck> is there a package (i.e. in hackage) that provides a double ended list? i'm looking for something with an O(1) append operation
16:41:14 <dmwit> Well, there's Data.Sequence.
16:41:17 <dmwit> You might also like Edison.
16:41:19 <dmwit> ?where edison
16:41:20 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/edison.html
16:41:54 <eck> neat, it looks like data.sequence does what i want
16:42:34 <dmwit> Beware of premature optimization, though, as I've heard Data.Sequence has fairly high overhead.
16:42:42 <eck> ok, thanks for the tip
16:43:37 <ziman> eck, go for difflists
16:43:52 <dmwit> Sequence is a difflist, no?
16:43:55 <ziman> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/dlist
16:43:55 <lambdabot> Title: HackageDB: dlist-0.4.1
16:44:01 <ziman> Sequence is a fingertree
16:44:32 <dmwit> Ah, okay.
16:46:50 <ziman> eck, and if you need a queue, there are simple amortized O(1)-snoc functional queues
16:47:55 * byorgey makes lambda souffle'
16:48:27 <ziman> need some curry? :)
16:51:38 <eck> maybe i should just explain what i'm trying to do... i want a function like adjMap :: (a -> a -> (a, a)) -> [a] -> [[a]] that applies a function to all of the adjacent pairs in a list
16:51:53 <eck> so for example, adjMap (\x y -> (x + y, y)) [1, 2, 3] = [[3, 2, 3], [1, 5, 3]]
16:52:31 <dmwit> what?
16:52:41 <dmwit> That output doesn't make sense to me.
16:52:48 <eck> uh maybe i wrote it wrong
16:52:57 <Olathe> \x -> [map f x, map g x]
16:53:12 <Olathe> Hmm, pairs.
16:53:15 <Olathe> Let's see.
16:53:21 <dmwit> Ah, I think I see what you're doing.
16:53:33 <Olathe> \x -> [map f (zip x (tail x), map g zip x (tail x)]
16:53:37 <dmwit> It's really weird, though.
16:53:47 <Olathe> A few errors in it.
16:54:13 <Olathe> zomg
16:54:37 <rwbarton> Can you write it symbolically? Like
16:54:43 <rwbarton> > foldr f a [x,y,z]
16:54:44 <lambdabot>   f x (f y (f z a))
16:55:11 <dmwit> rwbarton: Each pair of adjacent guys gets replaced by the function provided...
16:55:15 <Olathe> Was x ^ y :: Expr what killed lambdabot yesterday ?
16:55:35 <rwbarton> and then you zigzag them back into two lists?
16:55:41 <dmwit> one list
16:56:17 <rwbarton> adjMap (\x y -> (f x y, g x y)) [a, b, c] = ?
16:56:28 <dmwit> adjMap comb [1, 2, 3] -> [[fst (comb 1 2), snd (comb 1 2), 3], [1, fst (comb 2 3), snd (comb 2 3)]]
16:56:45 <dmwit> ...I think.
16:56:53 <dmwit> It at least matches the answer he wrote.
16:56:54 <rwbarton> I agree that that agrees with the example
16:56:57 <Olathe> @pl \(a, b) -> f a b
16:56:57 <lambdabot> uncurry f
16:57:15 <rwbarton> although then the resulting list always has length 2, why not ([a], [a])
16:57:23 <dmwit> rwbarton: It doesn't.
16:57:39 <Olathe> > let zomgMap f g xs = [map (uncurry f) xxs, map (uncurry g) xxs] where xxs = zip xs (tail xs) in zomgMap (+) (*) [1..3]
16:57:39 <dmwit> rwbarton: If the input list is longer, the output list has more (list) elements in it.
16:57:40 <lambdabot>   [[3,5],[2,6]]
16:58:04 <dmwit> rwbarton: An input list of length "n" yields an output list of length "n-1", each element of which is length "n".
16:58:05 <rwbarton> Oh, I get it
16:58:08 <dmwit> yeah
16:58:12 <dmwit> It's weird.
16:58:41 <rwbarton> It looks like it should just have a straightforward recursive definition though, no special data structures
16:58:44 <hackage> Uploaded to hackage: test-framework-quickcheck 0.2.0
16:58:44 <hackage> Uploaded to hackage: test-framework-hunit 0.2.0
16:58:44 <hackage> Uploaded to hackage: test-framework 0.2.0
16:58:47 <dmwit> right
16:59:39 <Olathe> > let zomgMap = flip flip (ap zip tail) . ((.) .) . (. ((return .) . map . uncurry)) . ap . ((:) .) . map . uncurry in zomgMap (+) (*) [1..4]
16:59:40 <lambdabot>   [[3,5,7],[2,6,12]]
16:59:48 <dmwit> > let adjMap comb (x:y:xs) = let (a, b) = adjMap x y in (a:b:xs) : (x : adjMap comb (y:xs)); adjMap comb _ = [] in adjMap (\x y -> (x + y, y)) [1..3]
16:59:50 <lambdabot>       Occurs check: cannot construct the infinite type: t = [t]
16:59:50 <lambdabot>        Expect...
17:00:28 <dmwit> > let adjMap comb (x:y:xs) = let (a, b) = comb x y in (a:b:xs) : (x : adjMap comb (y:xs)); adjMap comb xs = [xs] in adjMap (\x y -> (x + y, y)) [1..3]
17:00:29 <lambdabot>       Occurs check: cannot construct the infinite type: t = [t]
17:00:29 <lambdabot>        Expect...
17:00:45 <dmwit> oh
17:01:00 <dmwit> > let adjMap comb (x:y:xs) = let (a, b) = comb x y in (a:b:xs) : map (x:) (adjMap comb (y:xs)); adjMap comb xs = [xs] in adjMap (\x y -> (x + y, y)) [1..3]
17:01:01 <lambdabot>   [[3,2,3],[1,5,3],[1,2,3]]
17:01:10 <dmwit> close
17:01:17 <Olathe> zomg
17:01:42 <dmwit> > let adjMap comb (x:y:xs) = let (a, b) = comb x y in (a:b:xs) : map (x:) (adjMap comb (y:xs)); adjMap comb xs = [] in adjMap (\x y -> (x + y, y)) [1..3]
17:01:43 <lambdabot>   [[3,2,3],[1,5,3]]
17:01:56 <dmwit> eck: There you go.  It's gross, but...
17:02:21 <eck> thanks, it's better than the route i was going down anyway
17:02:46 <dmwit> You could probably do something sneaky with ap zip tail, too, let's see...
17:02:55 <Olathe> Hmmm...
17:03:13 <dmwit> > zip (inits [1..3]) (tails [1..3])
17:03:15 <lambdabot>   [([],[1,2,3]),([1],[2,3]),([1,2],[3]),([1,2,3],[])]
17:03:42 <dmwit> > zip (tail $ inits [1..3]) (init $ tails [1..3])
17:03:44 <lambdabot>   [([1],[1,2,3]),([1,2],[2,3]),([1,2,3],[3])]
17:04:07 <dmwit> bah
17:04:11 <dmwit> I have better things to do. =P
17:06:21 <rwbarton> Seems like the Zipper comonad would be useful here
17:07:42 <rwbarton> Asking again when different people may be around.  Anyone looked at the JavaScript backend for GHC at http://vir.mskhug.ru/?
17:07:46 <lambdabot> Title: GHC to JavaScript backend - Trac
17:13:01 <Cale> rwbarton: I hadn't seen that, but it looks interesting
17:13:19 <Cale> rwbarton: another interesting approach to this is being taken by the yhc people
17:13:33 <rwbarton> Yes, I've played with that a little bit
17:13:36 <Cale> rwbarton: and there was supposed to be a GHC -> YHC bytecode backend
17:13:48 <Cale> (being worked on)
17:14:40 <lispy> rwbarton: cool
17:15:22 <rwbarton> does anyone see a link to the repository?
17:15:39 <lispy> Okay though, if we can have javascript as a backend, when will someone polish up the java backend and make it an official part of ghc?
17:16:19 <lispy> I'd rather be able to generate .class files and slow extend that to source level compatibility
17:16:31 <lispy> even if the performance sucks at first
17:18:06 <Cale> Java and Javascript are extremely different.
17:18:21 <MichaelGG> Javascript would seem to be an easier target
17:18:31 <MichaelGG> with its dynamic typing and functional aspects..
17:20:23 <njbartlett_> lispy: Have you heard of LambdaVM?
17:20:37 <lispy> Cale: yeah, I realize.  But, I care more about jvm support than I care about javascript support
17:21:06 <Cale> lispy: I'm sure that it's doable, but I'm not sure that anyone will actually do it...
17:21:44 <Cale> Similarly, .NET support would be a nice thing to have for many people.
17:21:45 * BMeph gets a warm feeling in his middle when thinking about a Haskell-running browser...
17:21:51 <lispy> Cale: well, i know there are some hard problems.  For example, tail call optimization is disabled till future notice on the jvm because it interacts poorly with their security module
17:22:14 <lispy> er model
17:22:16 <Cale> You would do TCO beforehand, I think.
17:23:04 <Philippa_> in the general case, you can't on JVM
17:23:09 <Cale> hmm
17:23:22 <Cale> You can't implement a Haskell evaluator which maintains its own stack?
17:23:50 <luqui> stacks interact poorly with the jvm
17:24:36 <Cale> luqui: You mean user-implemented ones? Why?
17:24:52 <dons> ?users
17:24:52 <lambdabot> Maximum users seen in #haskell: 540, currently: 489 (90.6%), active: 15 (3.1%)
17:24:53 <MichaelGG> Philippa_ - you are Philippa C?
17:25:03 <luqui> nah, I'm just joking.  I was hoping to take it to a diss, but I failed.
17:25:15 <luqui> I'm also very tired and shouldn't be speaking
17:25:17 <Philippa_> as in Cowderoy, yeah
17:25:19 <Philippa_> why?
17:25:21 <MichaelGG> oh wow.
17:25:47 <dancor> using cabal-install with ghc 6.10 can't find syb-0.1.0.0
17:25:51 <dancor> where is that
17:26:38 <dcoutts> dancor: you may have to wait a bit for cabal-install to work well with ghc-6.10
17:26:49 <dcoutts> dancor: what is your specific test case?
17:26:51 <Cale> ghc-6.10 is released?
17:26:53 <lispy> Cale: oh, I wonder if the JIT compiler has enough info to do TCO
17:26:56 <dcoutts> Cale: not yet
17:27:07 <Cale> dcoutts: I was wondering how I missed that :)
17:27:18 <lispy> Cale: and some forms of TCO are still allowed.  I think you can TCO any function which only calls itself
17:27:20 <dcoutts> Cale: there are nightly pre-release builds though
17:27:24 <dancor> dcoutts: cabal install hunit  says 'Package base-3.0.3.0 depends on the following packages which are missing from the plan syb-0.1.0.0'
17:27:30 <Cale> ah, okay, so they're at that stage
17:27:39 <dcoutts> dancor: ok, that one. Yes, I've yet to fix that.
17:27:46 <dancor> ok sorry
17:28:01 <dancor> i just thought i could work around it by installing syb if someone knew where it could be found
17:28:09 <dcoutts> dancor: so that's an internal assertion about the correctness of the install plan that the resolver proposed
17:28:18 <dcoutts> dancor: it's already installed
17:29:00 <Cale> I find it interesting that goto is a reserved keyword in Java, but is not used in the language :)
17:29:20 <MichaelGG> wasnt there a .NET attempt but it died?
17:29:31 <Cale> MichaelGG: for a GHC backend, yes.
17:29:47 <Cale> MichaelGG: It's just not the sort of thing which is profitable for researchers to do.
17:29:56 <lispy> MichaelGG: there have been lots of attemps at both java and .net for haskell but everyone gives up before it finds it's way into GHC permanently
17:30:27 <noZone> @pl
17:30:28 <lambdabot> (line 1, column 1):
17:30:28 <lambdabot> unexpected end of input
17:30:28 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
17:30:38 <MichaelGG> I don't really see how it'd conceptually interop with .NET, like F# does for instance
17:30:43 <dancor> @pl \ x y -> x
17:30:44 <lambdabot> const
17:30:57 <noZone> @pl sum$map(fst)$filter(snd)[(p',all(id)[mod p' n /=0|n<-[2..95],n*n<= p'])|p<-[0..799],let p'=p*10+1007]
17:30:57 <lambdabot> (line 1, column 25):
17:30:58 <lambdabot> unexpected "["
17:30:58 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or end of input
17:31:18 <MichaelGG> I could see compiling to IL, but i dont see how that's really beneficial
17:31:22 <Cale> MichaelGG: Oh, that would be very hard. F# was designed around the notion of interoperating nicely with .NET and Haskell was not.
17:31:29 <noZone> @pl (sum$map(fst)$filter(snd)[(p',all(id)[mod p' n /=0|n<-[2..95],n*n<= p'])|p<-[0..799],let p'=p*10+1007])
17:31:30 <lambdabot> (line 1, column 26):
17:31:30 <lambdabot> unexpected "["
17:31:30 <lambdabot> expecting variable, "(", operator, "$", "$!", "`seq`" or ")"
17:31:31 <Cale> But you could do FFI.
17:31:39 <Cale> (similar to the way we do it with C)
17:31:59 <Cale> noZone: @pl doesn't know about list comprehensions, for one
17:32:08 <noZone> silly me.
17:32:10 <lispy> someone care to start H# then? :)
17:32:13 <Cale> noZone: secondly, that's already points-free, since it's not a function ;)
17:32:25 <noZone> There you go then!
17:33:18 <Cale> all id = and
17:33:54 <MichaelGG> Does FFI allow C code to call back into haskell?
17:33:57 <noZone> Sweet.
17:34:09 <dancor> map(fst) === map fst, filter(snd) === filter snd
17:34:17 <rwbarton> Also you shouldn't need to write   filter f [list comprehension]
17:34:32 <idnar> also how the heck do you read that code without spaces?
17:34:47 <noZone> Obfuscation contest.
17:34:49 <dancor> to each hiszone
17:34:50 <rwbarton> sum $ map [ p' | p <- [0..799], let p' = p*10+1007, and [ mod p' n /= 0 | n <- [2..95], n*n <= p' ] ]
17:35:00 <lispy> MichaelGG: yeah
17:35:17 <idnar> map?
17:35:19 <rwbarton> without the map
17:35:26 <idnar> ah
17:35:48 <noZone> sum of all primes ending in 7 between 1000 and 9000... on #IRP
17:35:53 <lispy> you could translate the list comp to do-notation, ?undo and ?pl
17:35:54 <Cale> > sum [ p' | p <- [0..799], let p' = p*10+1007, and [ mod p' n /= 0 | n <- [2..95], n*n <= p' ] ]
17:35:57 <lambdabot>   1153012
17:36:23 <rwbarton> @undo [ x | x <- xs, f x ]
17:36:23 <lambdabot> concatMap (\ x -> if f x then [x] else []) xs
17:36:30 <lispy> oh shiny!
17:36:55 <MichaelGG> Hmm i dont really see teh value of .NET layer just because the interop is prolly gonna be pretty bloody cumbersome i'd imagine
17:36:59 <lispy> ?. pl undo \f xs -> [ x | x <- xs, f x]
17:36:59 <lambdabot> (=<<) . flip flip [] . (`ap` return) . (if' .)
17:37:02 <mml`> suppose I have a type constructor: Square: * -> *
17:37:10 <MichaelGG> i could see exporting via C as p/invoke and whatnot
17:37:13 <lispy> ?. pl undo [ x | x <- xs, f x]
17:37:13 <lambdabot> flip (liftM2 if' f return) [] =<< xs
17:37:15 <MichaelGG> just to allow libs to use other libs...
17:37:18 <mml`> then shouldn't i oughta be able to say instance Foldable (Square t) where ... ?
17:37:21 <Cale> MichaelGG: Well, it would be nice to be able to interop with .NET in some way.
17:37:30 <MichaelGG> but even F#, natively made for .NET
17:37:34 <MichaelGG> has quite a bit of interop issues
17:37:48 <MichaelGG> namely the whole delegates fiasco nonsense
17:37:57 <MichaelGG> and calling conventions
17:38:10 <Cale> I'll admit I have almost no knowledge of .NET beyond the basic concept.
17:38:33 <lispy> Cale: you probably know as much as most .NET developers then ;)
17:38:41 <Cale> haha
17:38:42 <MichaelGG> lispy damn straight :(
17:38:57 <Cale> My understanding is that .NET is typed, but has a somewhat limited type system.
17:39:17 <Cale> which makes things difficult for interoperability
17:39:34 <lispy> supposedly C# has GADTs in the latest version
17:39:50 <MichaelGG> yea, and no "function type", they only have typed functions (Delegates) (sorry, im very ignorant and only just found out that type/category theory exists, let alone be able to speak coherently)
17:39:53 <lispy> But, I'm skeptical
17:39:57 <Cale> There was, now that I think about it, a thesis a while back which laid out exactly how .NET interoperability for Haskell might be made to work.
17:40:06 <MichaelGG> so there's no universal definition for int->int
17:40:28 <MichaelGG> that causes C#/F# issues to start
17:42:28 <adu> hi
17:42:36 <lispy> welcome back adu
17:42:41 <MichaelGG> if i understnad GADT, C# doesn't have it... like a discriminated union ? (type expr = val of int, add of expr * expr... etc?)
17:42:47 <adu> lispy: thanks
17:43:32 <adu> MichaelGG: C# has classes and enumerations and generics right? thats most of GADT
17:44:29 <adu> MichaelGG: although GADT could imply 1 of 2 things: GADT syntax or linear types
17:45:05 <adu> MichaelGG: linear types are much easier to do in other languages
17:45:08 <MichaelGG> yaew but not all of them together
17:45:12 <lispy> MichaelGG: http://research.microsoft.com/~akenn/generics/gadtoop.pdf
17:45:14 <lambdabot> Title: Generalized Algebraic Data Types and Object-Oriented Programming
17:45:40 <MichaelGG> I've found C#'s functional capabilities to be difficult and annoying. techncially you can do a few interesting things
17:45:44 <MichaelGG> but why bother :P
17:46:01 <adu> MichaelGG: the term "linear type" comes from Rec Int Int Int Int -- "multiplication" and A | B | C -- "addition"
17:46:23 <tnks> I don't suppose there's something like exuberant-ctags for Haskell/Vim, is there?
17:46:33 <lispy> MichaelGG: supposedly what that paper is selling can be used in C# 3.0
17:46:45 <adu> MichaelGG: so linear + generics + restriction = GADT
17:46:59 <MichaelGG> reading the paper
17:47:01 <lispy> tnks: hasktags
17:47:16 <tnks> lispy: I /just/ found it.
17:47:19 <tnks> thanks.
17:47:25 <lispy> tnks: np, enjoy
17:50:47 <Philippa_> adu: ...some idiot's gone and coined a definition for 'linear type' that's got nothing to do with substructural typing or linear logic?
17:51:06 <MichaelGG> Hmm rading the paper, but C# still requires you to cast stuff all over the place
17:51:13 <Philippa_> 'cos normally I'd see that called 'polynomial' (as in 'polynomial functor')
17:51:14 <adu> Philippa_: I'm trying to remember where I heard that term...
17:51:25 <MichaelGG> there's no nice type-guard-block without extra casting
17:51:36 * ddarius is with Philippa_ here on all points.
17:51:42 <MichaelGG> (which surprises me, since its generally useful in OO programming)
17:51:56 <rwbarton> Philippa_: certainly "linear" in the polynomial sense has *something* to do with linear logic
17:52:09 <Philippa_> rwbarton: smartass :-)
17:52:14 <MichaelGG> C# is also very loath to do anything that the runtime doesnt support directly, and the runtime hasnt gone anywhere since 2.0.
17:52:53 <MichaelGG> as MS says, "our users are confused as to what generics ARE, so we cant go adding any more functional stuff cause people are just too lost"
17:53:50 <Philippa_> that'd be because they did a shit job of the usability and threw around non-descriptive terms like 'generics' instead of meaningful ones like 'parametric polymorphism'
17:54:05 <adu> Philippa_: this is the only thing I could find: http://en.wikipedia.org/wiki/Linear_types
17:54:11 <Olathe> Are all these optimizations and other problems with IL solved in most machine languages ?
17:54:19 <Philippa_> for any given programming community, 'generics' = 'that form of generalisation we only just discovered and don't have a good name for'
17:54:26 <rwbarton> Well, it's harder with the terrible syntax that's totally different from term-level syntax
17:54:33 <Philippa_> adu: which is the sort I was talking about
17:54:41 <MichaelGG> Philippa_ yea ive come to realise that. i guess this is what i get for dropping out of school.
17:55:03 <adu> Philippa_: imho, 'generics' = parametric polymorphism
17:55:13 <Philippa_> adu: not in Haskell
17:55:18 <ddarius> adu: Not in the FP world
17:55:19 <Olathe> Generics are cheap versions of brand-name goods.
17:55:25 <rwbarton> Philippa_: Sounds about right, after all I have no idea what Data.Generics is for :)
17:55:33 <adu> am I mixing up my polymorphism definitions again?
17:55:37 <Philippa_> where we don't actually need a name for parametric polymorphism half the time because it's so ubiquitous :-)
17:55:52 <Philippa_> adu: no, but in haskell it's generally got more to do with polytypism
17:55:58 <ddarius> adu: Not likely.  In OO, "generics" does usually mean parametric polymorphism
17:56:03 <ddarius> (though not always even then)
17:56:14 <Philippa_> "generic function", say
17:56:39 <adu> no no no, that's ad-hoc polymorphism
17:56:40 <ddarius> Philippa_: We call it parametric polymorphism when we need to refer to it.
17:56:58 <Cale> adu: It's not ad-hoc.
17:57:04 <Philippa_> ...well, often we drop the 'parametric'
17:57:07 <ddarius> Or admittedly, just "polymorphism" many times.
17:57:11 <adu> I need to learn polymorphism all over again then
17:57:14 <Philippa_> Cale: "generic function" as in CLOS is
17:57:25 <Cale> adu: Generics usually refers to funtions defined on algebraic types by induction on the structure of the type.
17:57:37 <Cale> functions*
17:57:51 <Philippa_> I was adding an example for ddarius' statement
17:57:58 <ddarius> The point, as Philippa_ stated, is "generic" means different things in different communities and is rarely even used consistently *within* those communities.
17:58:09 <Cale> well, yes :)
17:58:18 <Cale> I'm referring to the use in pure FP :)
17:58:52 <adu> my only understanding is that "parametric polymorphism" = 1 implementation, explicit type, and "ad-hoc polymorphism" = many implementations, implicit type
17:59:50 <ddarius> adu: I don't know where you get this "explicit" and "implicit" from. (Also, pedantically, there is nothing precluding a single implementation for ad-hoc polymorphism or multiple implementations for parametric polymorphism)
18:00:15 * adu gets confuseder
18:00:20 <MichaelGG> lispy the stuff in that paper isnt in C# 3.0. afaik
18:00:32 <Philippa_> though in the latter case they need to be shown to be semantically identical if you don't want to lose parametricity, no?
18:02:11 <ddarius> Philippa_: Techinically, but that may be "trivial", e.g. specialization.
18:02:47 <Philippa_> sure. Right now, I don't need telling about trivial proofs/evidence :-)
18:03:24 <ddarius> Note to the next implementor of a proof assistant: add an "it's easy to see" operation
18:03:51 <lispy> what is a proof assistant?
18:03:58 <dfrey|work> Is there a way to do non-greedy matching with Text.Regex?
18:04:05 <lispy> Can you name one that is hard to use?  Do you mean things like Coq?
18:04:14 <adu> Philippa_: so what would you call Haskell types without "parametric polymorphism" and without GADT syntax?
18:04:15 <ddarius> lispy: Something that tries to prove things but gives up a lot.
18:04:40 <lispy> adu: algebriac data types
18:04:47 <Philippa_> adu: "types", possibly "monomorphic types" or "monotypes"? Or do you mean specifically algebraic datatypes?
18:05:07 <lispy> adu: or possibly even sum or product types
18:05:15 <adu> algebraic.... ah ok
18:05:20 <ddarius> lispy: We can have function spaces.
18:05:29 <Philippa_> adu: so called because they correspond to initial algebras
18:05:47 <adu> well doesn't sum + product = linear?
18:05:48 <rwbarton> ddarius: That always seems strange to me, -> is a lot less algebraic than Either and (,)
18:05:48 <lispy> Philippa_: can't they also correspond to final algebras?
18:05:55 <ddarius> adu: No.
18:06:04 <ddarius> sum + product = ring
18:06:15 <Cale> (kind of ;)
18:06:20 <dolio> final coalgebras.
18:06:22 <Philippa_> lispy: you mean final coalgebras, and that's in CPO or similar
18:06:28 <adu> ok ok, I'll call them algebraic types from now on
18:06:37 <ddarius> rwbarton: It's like exponentiation, but yes, in many cases those are less "algebraic"
18:06:40 <lispy> oh final coalgebras, yeah
18:06:44 <lispy> Philippa_: CPO?
18:06:47 <Philippa_> adu: no, it gives you polynomials - including the equivalent of squares, cubes...
18:06:54 <ddarius> rwbarton: For example, they lead to the need (usually) for infinitary algebra.
18:07:02 <Philippa_> lispy: the category of complete partial orders. At which point we end up talking domain theory...
18:07:19 <ddarius> Cale: That was very rough.
18:07:20 <dan> nootch
18:07:22 <adu> Philippa_: oh, your right, so they should be called polynomial types or ring types, makes much more sense
18:07:31 <Cale> ddarius: I know :)
18:07:34 <dan> can someone point me to a good tutorial on calling haskell FROM C?
18:07:35 <Cale> rwbarton: There are categories where you have something like Either and something like (,) but you don't have objects corresponding to function spaces.
18:07:40 <dan> not C from haskell
18:07:42 <dan> haskell from C
18:07:59 <adu> dan: foreign export
18:08:00 <lispy> dan: I'm pretty sure the FFI addendum in the Haskell 98 report covers that
18:08:02 <Cale> dan: The Haskell FFI documentation is fairly readable, but I can look up something more.
18:08:04 <rwbarton> Cale: Yes, most of the common ones :)
18:08:23 <dan> doesn't that let you call C functions in haskell code?
18:08:27 <dan> i want to call haskell from C
18:08:31 <lispy> dan: both
18:08:32 <Cale> dan: the FFI does both.
18:08:34 <dan> ahh
18:08:38 <adu> dan: the standard FFI specifies both directions, "foreign import" and "foreign export" in order to call Haskell from C you need the export one
18:08:39 <dan> oh
18:08:52 <dan> i thought it was like the JNI
18:08:55 <dan> only one way
18:08:56 <dan> etc
18:09:10 <Cale> You'll also need to call hs_init (or something like that, I forget how it's done)
18:09:14 <adu> dan: what's JNI?
18:09:15 <dan> mmk
18:09:18 <dan> java native interface
18:09:18 <newsham> java native interface
18:09:21 <dan> call C in java code
18:09:33 <lispy> I've called Haskell DLLs from C before
18:09:40 <dan> i'm really trying to call haskell from delphi
18:09:44 <lispy> So, what you want to do should be possible :)
18:09:45 <dan> but i there isn't a direct way
18:09:48 <dan> indeed
18:11:23 <Cale> rwbarton: I suppose, though there are quite a few common ones which have exponentials too.
18:11:48 <rwbarton> Yes.
18:12:11 <Cale> Groups are kind of bad in that respect though, and they stick out.
18:12:26 <Cale> (which is something that makes groupoids nicer to work with sometimes)
18:12:46 <lispy> So, if these types we're talking about correspond to countable sets right?  do you have an type systems that correspond to uncountable sets?
18:13:11 <Cale> lispy: Sure, in fact, the original application of type theory was to conventional mathematics
18:13:28 <Cale> lispy: Where you certainly need to deal with uncountable sets.
18:13:36 <lispy> So, what I mean is, if we have haskell's algebriac types, we get a countable set of polynomials, right?
18:13:55 <Cale> ah
18:14:04 <lispy> Can you name a type system I may have heard of that emits an uncountable set of polynomials?
18:14:04 <Cale> You mean uncountably many different types?
18:14:17 <lispy> Yeah, I guess that's what I'm essentially asking
18:14:29 <rwbarton> lispy: this is kind of like saying you can only describe finitely many sets in mathematical notation
18:14:36 <rwbarton> s/finitely many/countably many/
18:14:40 <EvilTerran> well, don't type systems generally require finite types
18:14:50 <dolio> Wasn't type theory going for a constructive basis for mathematics?
18:14:51 <EvilTerran> expressed in a (countable) language
18:14:52 <ddarius> EvilTerran: Finitely representable.
18:14:55 <dolio> Or are you talking about, like, Russel?
18:15:15 <ddarius> lispy: wtf would you do with an uncountably infinite collection of types?
18:15:23 <Cale> Well, the category of sets can be viewed as a sort of type system, and it has a proper class of 'types' then.
18:15:40 <lispy> Maybe I'm mistaken, but I'm thinking that if you take the cartesian product of countable sets you get a countable set.  And product/sum types can't do anything of higher power than cartesian products, right?
18:15:48 <Cale> I suppose it depends on what you're willing to admit as a type system ;)
18:15:51 <EvilTerran> ddarius, yeah, that's what i mean. finite in some notation, which will inevitably contain at most #N expressions
18:16:15 <rwbarton> lispy: If you don't allow recursive types, all your types are finite.
18:16:25 <Cale> lispy: There are also issues like: How many elements does the type Nat -> Bool have?
18:16:43 <rwbarton> lispy: If you do, then you can have types with an uncountable number of values, for a reasonable interpretation of value, e.g., [Integer]
18:16:51 <lispy> Cale: I don't think I'm concerned with the number of elements in the type
18:16:58 <Cale> If you require that all such elements are defined by computable functions, then the answer is "countably many"
18:17:21 <Cale> If you don't, then the answer is c-many, where c is the cardinality of the real line.
18:17:33 <EvilTerran> regulate, or the classic example would be Set Integer
18:17:36 <adu> wasn't there something like that with Species?
18:17:44 <ddarius> ℵ_1
18:17:49 <rwbarton> lispy: You're concerned with the number of types you can actually write down?  Yes, it's countable (there are only countably many haskell programs)
18:17:56 <EvilTerran> containing 2^#N values
18:17:57 <Cale> ddarius: If you're willing to accept CH, yes :)
18:18:05 <adu> iirc, Species were to algebraic types as power series are to polynomials...
18:18:20 <ddarius> Cale: Point.
18:18:27 <ddarius> In this context, I probably would.
18:18:37 <lispy> Cale: I mean, suppose we have some countable set of types, we can then combine those with sum/product to get new types.  But, wouldn't we still have countably many?  Or is that we can define an infinite number of sums/products so what I'm saying about finite cartiesian products goes out the window?
18:18:50 <EvilTerran> er, rwbarton, i mean
18:19:05 <Cale> CH is a curious thing. There are fairly convincing arguments both for and against its inclusion.
18:19:05 <lispy> rwbarton: yes, that's much closer to what I'm getting at
18:19:17 <adu> Cale: inclusion in what?
18:19:31 <Cale> adu: The set of axioms we use on a regular basis.
18:19:37 <adu> o
18:19:40 <ddarius> Cale: I tend to be a "use whatever is convenient" mathematician (to the extent that I'm a mathematician, which is not much)
18:19:46 <rwbarton> lispy: There are models of standard set theory with a countable set of sets.  This doesn't contradict the fact that some sets are uncountable when viewed from "inside" the theory.
18:19:52 <rwbarton> lispy: (But it is very confusing.)
18:20:10 <adu> so basically when will ppl stop using ZFC + CH and start using ZFCC?
18:20:26 <rwbarton> CC?
18:20:34 <adu> choice + continuum
18:20:59 <adu> doesn't ZFC = ZF + choice?
18:21:05 <Cale> adu: yes
18:21:18 <rwbarton> You're talking about a difference in name then?
18:21:29 <Cale> rwbarton: well, which implies a difference in philosophy :)
18:21:29 <lispy> Okay, so if all we have is sum/product we can only have countable many types?  Is that what people are saying?
18:21:45 <lispy> What if I add to this, existential types.
18:21:54 <EvilTerran> by an inductive proof, still yes
18:22:08 <Cale> rwbarton: Basically, when do people stop separating CH from the rest of the axioms and just tacitly accept it under most circumstances?
18:22:08 <rwbarton> I don't think many mathematicians care enough about CH
18:22:12 <Cale> (or its negation)
18:22:18 <lispy> Could I then construct a function from an uncountable set to existential bound types?
18:22:22 <EvilTerran> or, maybe more intuitively, if you can devise a finite-alphabet language in which all types can be expressed
18:22:28 <Cale> I've certainly wanted CH to be true in various places before.
18:22:37 <EvilTerran> then there's only countably many finite-length expressions
18:22:37 <Cale> Mostly in functional analysis contexts.
18:22:52 <lispy> CH?
18:22:52 <ddarius> rwbarton: Enough?  Why should they care?  It doesn't really make a difference to most of mathematics.
18:23:05 <adu> lispy: continuum hypothesis
18:23:10 <lispy> oh right
18:23:17 <EvilTerran> @go continuum hypothesis
18:23:17 <Cale> Continuum hypothesis: There is no set with cardinality strictly between that of the naturals and that of the reals.
18:23:19 <lambdabot> http://en.wikipedia.org/wiki/Continuum_hypothesis
18:23:19 <lambdabot> Title: Continuum hypothesis - Wikipedia, the free encyclopedia
18:23:23 <rwbarton> ddarius: Care enough that there is general consensus about whether or not to accept it.  (I don't care about it either.)
18:23:40 <Cale> It's independent of the other axioms of set theory (ZFC)
18:23:40 <lispy> Cale: but I'm not actually needing the CH am i?
18:24:02 <adu> I had the most interesting experience when I first encountered CH, I quickly derived a proof of it, and was about to publish when I realized it had a glaring typo
18:24:10 <Cale> lispy: No, this is a side-discussion started by ddarius calling the cardinality of (Int -> Bool)  Aleph_1
18:24:15 <ddarius> lispy: That was a tangent based on my not fully thought out use of ℵ_1
18:24:26 <lispy> ah
18:25:06 <Cale> adu: hehe
18:25:34 <ddarius> adu: You are supposed to replace the typo with "and here a miracle happens"
18:25:42 <adu> ddarius: lol
18:25:50 <Cale> I don't know about CH, but I'd be happy with global well ordering. :)
18:26:09 <rwbarton> doesn't that follow from choice?
18:26:09 <lispy> I'm still struggling with the axiom of choice
18:26:50 <Cale> rwbarton: not *quite*. You get that every set can be well ordered, but not that there's a well ordering on the whole class of sets.
18:26:54 <lispy> Or as one of my math profs said after introducing the axiom of choice, quickly stating the criticism and then saying we'd be using it in class, "Welcome to our religion!"
18:26:54 <rwbarton> Yeah, ok
18:27:42 <ddarius> lispy: Which class?
18:27:43 <Cale> Hehe, my noncommutative algebra prof said half-jokingly: "If you don't accept the axiom of choice, then you are not a mathematician, you are a logician."
18:27:46 <adu> I think the most interesting thing I learned when studying CH is that |Z^n| == |Z| and |R^n| == |R|
18:28:17 <rwbarton> Cale: It probably follows from the "universe" axioms that are common in category theory
18:28:18 <ddarius> In many cases the axiom of choice is necessary to prove results in full generality, but in practice you usually have more structure and don't need tho full result.
18:28:24 <lispy> ddarius: this was second term of abstract algebra, ... at my uni was a grad level course, but only because we didn't have an undergraduate algebra sequence
18:28:36 <ddarius> adu: You needed to study CH to know that?
18:28:49 <adu> ddarius: no, but I did
18:29:21 <adu> and the most interesting proofs of each that I found are prime factorization (or Goedel number) and base-(2i) representation
18:30:02 <Cale> ZFC seems a little bit awkward to me in that it includes axioms which make it possible to do things as if there were proper classes, but it doesn't actually talk about them explicitly.
18:30:05 <Olathe> What's the basic idea of the prime factorization proof ?
18:30:35 <ddarius> That |Z^n| == |Z| is just an immediate consequence of the typical proof that the rationals are countable.
18:30:57 <ddarius> That |R^n| == |R| is easily seen from space filling curves.
18:31:02 <adu> Olathe: and list of integers (a, b, c) can be turned into one by 2^a*3^b*5^c...
18:31:15 <Olathe> adu: Ahh, OK.
18:31:20 <adu> ddarius: nope, I never grokked the space filling curve, I thought that was a bunch of crap
18:31:36 <adu> ddarius: but base-(2i) i liked
18:31:56 <Olathe> adu: Thanks :)
18:32:08 <lispy> I thought that the Cantor dust was interesting
18:32:21 <adu> ddarius: ya, but I hated the diagonal argument, I much perferred the factorization method, because you can factor rationals too, its just that the prime exponents can be negative :)
18:32:46 <Olathe> There's a nice bijection using digit interleaving that I like.
18:33:06 <lispy> Olathe: that one is attributed to Cantor right?
18:33:11 <Olathe> Not sure.
18:33:11 <Cale> Yeah, for |R^n| = |R|, digit interleaving seems the easiest way.
18:33:29 <adu> Cale: but base-(2i) is so cool
18:33:34 <Cale> :)
18:33:45 <Olathe> I hadn't heard of the prime factorization one and that's pretty nice, too.
18:34:05 <Cale> For the prime factorisation thing to work, you need Schroeder-Bernstein of course.
18:34:36 <Olathe> Cale: What's that ?
18:35:02 <Cale> If there are injective functions f: A -> B and g: B -> A, then A and B have the same cardinality.
18:35:07 <Olathe> Ahh.
18:35:37 <Cale> This can be proved with or without the axiom of choice.
18:35:54 <adu> Olathe: the prime factorization method is only bijective between naturals, when applied to rationals you get a wierd Q <-> Z thing
18:36:02 <Cale> However, I think the similar one only replacing 'injective' with 'surjective' needs choice.
18:36:44 <Olathe> adu: You can use twos complement to avoid that, I think.
18:36:59 <Cale> (Not 100% sure about that though)
18:37:29 <adu> Olathe: how do you use 2's complement on a possibly infinite number?
18:38:12 <Olathe> > let f n = if n < 0 then -2*n + 1 else 2*n in map f [-
18:38:12 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
18:38:13 <lambdabot>  ...
18:38:17 <Olathe> > let f n = if n < 0 then -2*n + 1 else 2*n in map f [-5..5]
18:38:19 <lambdabot>   [11,9,7,5,3,0,2,4,6,8,10]
18:38:24 <lispy> Cale: I don't think so.  I recall a math prof of mine going on about how he can never decide which version of that to present to his 300 level students since they are equivalent.
18:38:26 <Olathe> > let f n = if n < 0 then -2*n - 1 else 2*n in map f [-5..5]
18:38:27 <lambdabot>   [9,7,5,3,1,0,2,4,6,8,10]
18:38:32 <Olathe> That, rather.
18:38:35 <Cale> Oh, nice, |A| = |AxA| when A is infinite is equivalent to the axiom of choice.
18:39:06 <adu> Cale: what?!?
18:39:06 <lispy> Cale: infinite allowing for countably infinite?
18:39:21 <Cale> lispy: as a special case
18:39:48 <dblazakis> :t runStateT
18:39:50 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
18:40:13 <lispy> Cale: so, |N| = |NxN|, is equivalent to the axiom of choice.  I did not know that.  Source?
18:40:21 <Cale> no
18:40:30 <Olathe> For all infinite sets A.
18:40:31 <Cale> |A| = |AxA| for every infinite set A
18:41:17 <rwbarton> Is there some subtlety about "infinite" without AC?  Or is that only in intuitionistic math?
18:41:25 <Cale> rwbarton: yes, there is
18:41:38 <Cale> rwbarton: There are two common definitions of infinite
18:42:09 <Olathe> The number after all the other numbers is very common ;)
18:42:19 <lispy> Cale: okay, you lost me.  so you're saying that if that equality holds for arbitrary sets A, that's equivalent to axiom of choice.  But, then, does the proof of |N| = |NxN| really rely on N?
18:42:46 <Olathe> lispy: Which proof of it ?
18:42:50 <Cale> lispy: The easy one does.
18:44:06 <lispy> hmm
18:44:12 * shapr boings cheerfully
18:44:22 <lispy> hey shapr
18:44:26 <shapr> hiya lispy!
18:45:31 <Cale> Also, without the axiom of choice, there must be sets A and B for which there are no injective functions A -> B or B -> A.
18:45:44 <Cale> (that is, if AoC is false)
18:46:34 <lispy> the AoC has a lot of intuitive reasons to exist
18:46:46 <Cale> (which means there are cardinals which are incomparable)
18:47:01 <Olathe> Is the AoC needed for any computable sets ?
18:47:44 <Cale> That's a good question. My gut reaction is that it doesn't affect which sets are computable.
18:48:01 <Cale> (you might need countable choice though...)
18:48:17 <Olathe> I mean, if someone dealt only with computable sets, would the axiom of choice make things easier ?
18:48:20 <lispy> well, when you have a finite cartesian product you don't need the axiom of choice, right?
18:48:36 <Cale> lispy: of countable sets?
18:48:50 <Cale> or you mean to pick an element?
18:49:01 <lispy> I didn't think the set cardinality mattered...but maybe I'm mistaken
18:49:06 <Cale> Yeah, finite Cartesian products of nonempty sets are nonempty :)
18:49:25 <lispy> the version of axiom of choice I recall, just states that given an infinite product of sets you can choose an element from each
18:49:41 <Cale> Well, that the infinite product isn't empty.
18:50:23 <rwbarton> Olathe: I think there are applications of the axiom of choice to the computable world.  e.g., Konig's tree theorem (not equivalent to AC, but its negation is consistent with the negation of AC)
18:52:00 <lispy> Yeah, it's sort of like the infinite product is _|_ in some high level sense
18:52:11 <lispy> But, since we can make sense of what _|_ should be in the places it comes up, we do so
18:52:36 <Cale> You can also say it as every surjective function f: A -> B has a right inverse g: B -> A, (that is, f . g = id) which amounts to picking an element from each of the preimages of the elements of B.
18:53:10 <Cale> Which is a nice categorical way to say it :)
18:55:33 <lispy> It would be interesting to see what mathematics is like in 200 years
18:55:36 <Saizan> not a left inverse? if f :: Bool -> () how can you write g?
18:55:48 <lispy> Some of these issues with AoC, CH and GCH may be resolved by then
18:56:11 <Philonous> Can you even pick an element of a single (infinite) set without the axiom of choice?
18:56:27 <Cale> lispy: That's not a bad approximation to the idea... see, when we have a way to distinguish a special element from each of the nonempty sets we're picking from, we don't need the axiom of choice, sort of similar to the way that we don't need some special oracle to build totally defined infinite lists which happen to be computable
18:56:41 <lispy> I recall someone proposing a proof system where we accept results once we have exhaustively tried some insanely large but finite set of inputs
18:56:42 <Cale> Philonous: yes
18:56:48 <Philonous> Cale: how?
18:56:53 <rwbarton> Philonous: If it's nonempty
18:56:59 <rwbarton> Philonous: That's a tautology
18:57:07 <Cale> There are not many empty infinite sets ;)
18:57:10 <rwbarton> Oh, I guess infinite sets are ... yeah
18:57:21 <rwbarton> So, it depends on your definition of infinite
18:57:22 <idnar> @type liftM concat
18:57:24 <lambdabot> forall a (m :: * -> *). (Monad m) => m [[a]] -> m [a]
18:57:25 <idnar> @type concatM
18:57:26 <lambdabot> Not in scope: `concatM'
18:57:40 <Cale> Philonous: When we say "pick an element" we mean that some set is not actually empty.
18:57:46 <idnar> huh, I thought there was a concatM
18:57:50 <idnar> guess not
18:58:02 <xpika> what is the default int type in ghc?
18:58:04 <Philonous> rwbarton: infinity = a subset is isomorphic to N
18:58:17 <rwbarton> Philonous: OK, then pick whichever corresponds to 1
18:58:24 <Cale> Philonous: For example, in the case of picking an element from each of an infinite indexed family of sets, we mean that a certain set of functions is nonempty.
18:58:27 <Saizan> xpika: in haskell, Integer
18:58:32 <Philonous> Oh right, that makes it too easy
18:58:36 <lispy> Cale: yeah, I learned that approximation from following proofs in class, but at some point I accidentally thought it was the actually AoC...but I see now.
18:58:37 <EvilTerran> you could have a non-constructive definition of the contents of the set
18:58:43 <EvilTerran> and still know exists x. x \in set
18:59:18 <lispy> Cale: eg., it's a handy lemma but not the full picture
18:59:20 <Philonous> Than let me rethink why I can't construct a function that maps any set in a given class to one of it's elements
18:59:25 <Cale> I like the definition: A set is infinite if it is in bijection with a proper subset of itself.
18:59:43 <Cale> But that's not equivalent to the usual definition (not finite), unless AoC is present.
18:59:54 <Cale> (actually weaker things make them equivalent too)
19:00:14 <Cale> lispy: Which approximation?
19:00:26 <lispy> And see, that's why it seems that the AoC isn't necessarily correctly stated, but the concept we are after is true
19:00:30 <idnar> @type (</>)
19:00:31 <lambdabot> Not in scope: `</>'
19:00:42 <lispy> 18:55 <Cale> lispy: That's not a bad approximation to the idea...
19:00:47 <Cale> lispy: ah
19:01:02 <idnar> @type System.FilePath.Posix.(</>)
19:01:03 <lambdabot>     Not in scope: data constructor `System.FilePath.Posix'
19:01:03 <lambdabot> Not in scope: `</>'
19:01:08 <Cale> I think "every surjective function has a right inverse" is a very clean and nice way of putting it.
19:01:19 <EvilTerran> ?hoogle </>
19:01:20 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
19:01:20 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
19:01:42 <lispy> I also hypothesize that, the question "Is P=NP?" is not correctly stated
19:01:44 <Cale> (and typically practical for use as well)
19:02:02 <Cale> lispy: What do you mean by "not correctly stated"?
19:02:22 <Olathe> It should be "Does P = NP ?"
19:02:27 <Riastradh> It's not stated in a way that makes its answer bleedingly obvious!
19:02:31 <Cale> heh
19:02:32 <EvilTerran> Cale, a right inverse by (.)?
19:02:33 <Olathe> English, people. English.
19:02:37 <Cale> EvilTerran: yes
19:02:40 <ac> @seen humasect
19:02:40 <lambdabot> I saw humasect leaving #ghc, #haskell.jp, #haskell-overflow and #haskell 1m 8d 5h 3m 55s ago, and .
19:02:41 <lispy> Cale: after taking some computability classes, I started to wonder if maybe that question is hiding some ambiguity or some other logical flaw that makes it essentially unanswerable
19:02:53 <EvilTerran> but not necessarily the otherway round... right, that makes sens
19:03:01 <EvilTerran> that seems pretty intuitively true
19:03:50 * rwbarton thinks both "Is P=NP?" and "Does P=NP?" are technically wrong
19:03:59 <lispy> Olathe: not sure how you read "Is P=NP?" but I read it as, "Is P equal to NP?", and as far as I know, that's a valid english construction :)
19:04:13 <Cale> That is, for every pair of sets A,B and function f: A -> B such that for all b in B there is some a in A for which f(a) = b, there is a function g: B -> A so that f . g = id_B
19:04:37 * Olathe calls the grammar nazi squad to ask ;)
19:04:44 <idnar> lispy: I guess if you restrict the reading of "=" to "equals", then it's not valid english
19:04:45 <rwbarton> Actually, I agree with Olathe now
19:04:49 <dolio> Pffff. What are bs? That's not categorical. :)
19:05:01 <idnar> how about just "P=NP?"
19:05:06 <Cale> dolio: functions from 1 -> B
19:05:09 <rwbarton> "Is it the case that P=NP?"
19:05:57 <Olathe> > P == NP
19:05:58 <lambdabot>   Not in scope: data constructor `P'Not in scope: data constructor `NP'
19:06:10 <dolio> You need, like, 'for all epic f : A -> B'.
19:06:20 <dolio> Or is it monic? I can never remember.
19:06:20 <Cale> If you want me to make this even more categorical, we can define a surjective function f: A -> B as one such that for every map b: 1 -> B, there is a map a: 1 -> A making the obvious triangle commute.
19:06:38 <rwbarton> Cale: That's a pretty weird definition :)
19:07:05 <Cale> and then AoC says that every surjective function is epic.
19:07:11 <Pseudonym> It occurred to me that it's only possible to have the unique morphism to a terminal object to be epic.
19:07:21 <Pseudonym> Hence, most categories do not have epic fail.
19:07:25 <lispy> is epic a term in CT?
19:07:30 <Cale> lispy: yeah
19:07:31 <lispy> oof
19:07:36 <lispy> Pseudonym: bad joke!
19:07:40 <rwbarton> lispy: it's a somewhat failed attempt at a term.
19:08:09 * lispy imagines CT students playing WoW and getting utterly confused when other players refer to things as 'epic'
19:08:13 <idnar> hahaha
19:08:16 <Cale> haha
19:08:31 <Pseudonym> Sorry, I meant to say "in trivial cases".
19:08:40 <Pseudonym> Still, it got the point across.
19:08:51 * Pseudonym shuts up now, that's enough bad jokes for one morning
19:08:53 <dolio> Woo, monic lewt!
19:09:36 <Cale> Monic Aegis of Left Inversion
19:09:46 <dolio> Heh.
19:09:58 <lispy> sounds epic :)
19:10:22 <lispy> Pseudonym: you're ajb on -cafe right?
19:10:40 <Pseudonym> Yeah, though I probably shouldn't admit it right now.
19:10:43 <Pseudonym> Sorry.
19:10:55 <lispy> Pseudonym: oh right....
19:11:03 <lispy> totally off topic then...
19:11:09 <lispy> I liked that poem about haskell names
19:11:13 <lispy> that I saw on -cafe
19:11:17 <Pseudonym> That's what I meant, yes.
19:16:18 <Cale> Heh, I just realised I messed up that joke. Clearly, it should be the Monic Arrows of Left Inversion
19:55:53 <tennin> by default does cabal-install keep the source of packages?  and if so where does it go?
19:56:38 <tennin> oh, it just keeps it as a tarball in /packages/?
19:57:35 <dcoutts> tennin: right, sources are not installed
19:58:15 <tennin> seems like most stuff in hackage would be pretty useless without source at this point
19:58:28 <tennin> but I guess you could consult them online
19:59:00 <mml`> why can i derive Show for some algebraic data types, but not others?
19:59:15 <mml`>     No instance for (Show (v (v a)))
19:59:17 <mml`>       arising from the 'deriving' clause of a data type declaration
19:59:21 <mml`> is maddening.
19:59:38 <lispy> mml`: we'd need to see more of your data definition
19:59:56 <dcoutts> mml`: sounds like you've not defined the type you think you have
20:00:00 <mml`> data Square_ v w a =
20:00:01 <mml`>     Zero (v (v a))
20:00:01 <mml`>   | Even (Square_ v (Pair w w) a)
20:00:01 <mml`>   | Odd (Square_ (Pair v w) (Pair w w) a)
20:00:01 <mml`>  deriving Show
20:00:15 * mml` is trying to create the square matrix type from an Okasaki paper.
20:00:29 <lispy> mml`: looks like Zero is the part it's barfing on
20:00:48 <mml`> correct, but why is that barfy when
20:01:05 <mml`> "data Mylist a = Mynil | Mycons a (Mylist a) deriving show" works?
20:01:16 <mml`> because of the higher kind of v?
20:01:18 <bd_> deriving (Show)
20:01:31 <dcoutts> mml`: I expect so
20:01:43 <dcoutts> what would the instance look like?
20:01:45 <Cale> mml`: Try to write it my hand, and see if it requires anything interesting
20:01:46 <lispy> mml`: hmm, Show (v (v a))), would be problematic in plain Haskell98
20:01:56 <Cale> by*
20:04:57 <sw17ch> :t curry
20:04:58 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
20:05:25 <sw17ch> > uncurry (+) (1,1)
20:05:26 <lambdabot>   2
20:06:07 <dons> shapr: did you see ?users :)
20:07:13 <lispy> ?loosers
20:07:13 <lambdabot> Unknown command, try @list
20:07:17 <lispy> ?lusers
20:07:17 <lambdabot> Maximum users seen in #haskell: 540, currently: 483 (89.4%), active: 10 (2.1%)
20:07:19 <lispy> oh!
20:07:27 <lispy> (sorry, bad joke)
20:07:34 <Samy> TEST bloop bloop
20:07:37 <Samy> ?lusers
20:07:37 <lambdabot> Maximum users seen in #haskell: 540, currently: 483 (89.4%), active: 11 (2.3%)
20:07:53 <Nafai> 540.  Nice!
20:08:08 <lispy> ?quote #haskell
20:08:08 <lambdabot> dons says: [In reference to <joelr1> did you guys know that #ocaml has 37 members and #erlang has 34 vs. 202 on #haskell?] I think part of the #haskell success comes from the approach that we all
20:08:09 <lambdabot> know each other, it's not a homework channel like #java. We created a community of peers, working on the overall goals of the community. That's why people keep coming back
20:08:13 <lispy> ?quote #haskell.leak
20:08:14 <lambdabot> No quotes match. You speak an infinite deal of nothing
20:08:20 <lispy> ?quote space leak
20:08:20 <lambdabot> No quotes for this person. Just try something else.
20:08:37 <Olathe> Wait.
20:08:39 <lispy> bah, I can't figure out how to bring that quote up again
20:08:41 <SamB_XP> ?quote space.leak
20:08:41 <lambdabot> Deewiant says: [on the growing size of #haskell] there must be a space leak somewhere
20:08:42 <Olathe> That quote wasn't humorous !
20:08:53 <Olathe> Nonhumorous quotes aren't allowed !
20:09:09 <lispy> ?quote #haskell
20:09:09 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
20:09:13 <lispy> ?quote #haskell
20:09:13 <lambdabot> shapr says: I dare you to call a substructural type system obvious anywhere outside of #haskell.
20:09:19 <SamB_XP> 202!
20:09:20 <lispy> hehe
20:09:22 <SamB_XP> that's so tiny
20:09:50 <sjanssen> any bets on the size of #ocaml now?
20:09:55 <dons> 60?
20:09:58 <SamB_XP> sjanssen: 3?
20:10:03 <Adamant> what about #erlang?
20:10:16 <SamB_XP> dons was near
20:10:22 <SamB_XP> it was 68 just now
20:10:22 <dons> 110?
20:10:23 * dons guesses.
20:10:29 <sjanssen> 67
20:10:29 <mauke> #erlang 162, #ocaml 67
20:10:33 <Adamant> aH
20:10:36 <dons> oh, erlang's doing well.
20:10:41 <Adamant> I was about to say 150
20:10:48 <SamB_XP> and probably 8 of those were us
20:10:55 <mauke> er
20:10:58 <mauke> /list #ocaml
20:11:01 <mauke> no need to join
20:11:04 <SamB_XP> oh?
20:11:05 <SamB_XP> hmm
20:11:09 <SamB_XP> fascinating
20:11:55 <Samy> ##C = 497
20:12:05 <lispy> (++) is called concatenation right?
20:12:11 <Samy> Yes
20:12:12 <lispy> and not, say, append?
20:12:19 <Adamant> wowzers (re: ##C)
20:12:32 <Adamant> or should that be wowz0rs
20:12:37 <SamB_XP> lispy: huh
20:12:42 <SamB_XP> I thought it was called append ;-)
20:13:20 <SamB_XP> Adamant: what, that's only slightly larger than this channel
20:13:23 <sjanssen> the report uses the word "append"
20:13:25 <SamB_XP> with significant overlap
20:13:29 <Samy> sjanssen, oh?
20:13:41 <SamB_XP> :t concat
20:13:42 <Adamant> SamB_XP: this chanel has 540 to 497 for ##C
20:13:42 <lambdabot> forall a. [[a]] -> [a]
20:13:47 <Samy> ohhhh, yes
20:13:48 <dblazakis> i'm trying to come up with a way to compose Either and State s.t. I can always get the state back out --http://hpaste.org/10964
20:13:49 <Adamant> hence the wowz0rs
20:13:54 <SamB_XP> Adamant: I see 484
20:13:55 <dblazakis> any suggestions?
20:13:58 <sjanssen> Samy: http://haskell.org/onlinereport/standard-prelude.html search for "append"
20:13:59 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
20:14:04 <Samy> Why is concat concatenation though?
20:14:14 <Adamant> SamB_XP: I meant as max
20:14:23 <lispy> I will call it append then
20:14:32 <Olathe> concat [concat, enation]
20:14:37 <sjanssen> lispy: ByteString does the same
20:14:53 <SamB_XP> well, concatenate and append are basically synonyms aren't they ?
20:14:59 <sjanssen> yes
20:15:11 <mauke> ErrorT State
20:15:11 <Samy> > (++) "concat" "enation"
20:15:13 <lambdabot>   "concatenation"
20:15:17 <SamB_XP> so ... no reason really ;-)
20:15:46 <Samy> > concat [["concat"], ["enation"]]
20:15:47 <lambdabot>   ["concat","enation"]
20:15:54 <lispy> dblazakis: so you can always get the state back out?
20:16:11 <lispy> dblazakis: isn't there some variant of evalState or runState that does what you want already?
20:16:14 <rwbarton> dblazakis: most likely you want EitherT (State s) instead
20:16:37 <dblazakis> lispy, the problem is that the Either monad is (Either a)
20:16:40 <lispy> ?hoogle State s a -> (a, s)
20:16:40 <lambdabot> Control.Monad.State.Lazy runState :: State s a -> s -> (a, s)
20:16:41 <lambdabot> Control.Monad.State.Strict runState :: State s a -> s -> (a, s)
20:16:41 <lambdabot> Data.Array.Base bounds :: (IArray a e, Ix i) => a i e -> (i, i)
20:16:49 <dblazakis> so, the (a,s) will be with the Right
20:17:14 <dblazakis> rwbarton: ah, i'll think about that
20:22:03 <dblazakis> mauke, ah, i think that will work, thanks (rwbarton, same thing i think)
20:26:13 * sw17ch is having a problem with his cabal file...
20:26:20 <sw17ch> configure keeps complaining about packages i know i have installed
20:26:20 <sw17ch> :/
20:26:26 <sw17ch> under an "executable" section
20:26:57 <dons> anyone tried our new haskell .net bridge yet? http://code.haskell.org/Salsa/
20:26:57 <lambdabot> Title: Index of /Salsa
20:27:12 <dcoutts> sw17ch: hpaste would be the quickest way to explain the problem
20:27:12 <lispy> sw17ch: 1) do you need to run configure again after updating the .cabal file, 2) are you sure you're not missing any packages in the executale section?  3) Maybe you need to give us the exact error at hpaste.org
20:28:22 <lispy> dons: neat find, when was that announced?
20:28:43 <sw17ch> dcoutts, lispy: ^^ http://hpaste.org/10965
20:29:40 <lispy> sw17ch: ah, you're the scurry author, howdy!
20:29:48 <sw17ch> :)
20:30:03 <sw17ch> any severe criticism for the code yet? :D
20:30:12 <dcoutts> sw17ch: try --user
20:30:24 <sw17ch> dcoutts: bingo
20:30:30 * sw17ch wonders why he doesn't know these things yet
20:30:35 <dons> lispy: not yet, but it is last year's thesis project from UNSw.
20:30:45 <dcoutts> sw17ch: if you used cabal-install it'd just work
20:31:05 * sw17ch has been having some problems with his GHC install...
20:31:19 <sw17ch> i'm fairly certain those packages were installed iwht cabal-install
20:31:24 <lispy> dons: hmm...We really need a commercial backer for projects like these.  Not a financial sponsors so much as pressure and day to day coders that need it.  Needs to get finished and out of the 'alpha' umbrella.
20:31:51 <dcoutts> lispy: mm, good idea :-)
20:31:51 <dons> lispy: http://209.85.173.104/search?q=cache:9wWG3unD_10J:www.cse.unsw.edu.au/~pls/thesis/aja-thesis.pdf
20:31:52 <lambdabot> Title: A .NET Bridge for Haskell:, http://tinyurl.com/4yzec8
20:32:03 <dons> lispy: yes, we need a commercial backer. a "red hat" for haskell.
20:32:11 <dons> that can transition research into open source and maintain it
20:32:25 <dblazakis> yep, thanks -- works as expected  http://hpaste.org/10964#a1
20:32:47 <dons> http://www.cse.unsw.edu.au/~pls/thesis/aja-thesis.pdf
20:32:50 <lambdabot> Title: A .NET Bridge for Haskell:
20:32:56 <lispy> dons: yeah, I assume galois does that a fair bit, and now well-typed is joining that rank
20:33:22 <Pseudonym> Galois can only realistically maintain anything which directly helps them.
20:33:25 <dons> i think galois would like to do it more, if there was some one to pay to maintain stuff.
20:33:39 <Pseudonym> They're not big enough.
20:33:52 <lispy> Right, so if there was money in, say, the Haskell platform there would be incentive
20:34:12 <cjs> Well, who needs a .NET bridge?
20:34:19 <dons> cjs: :)
20:34:35 <dcoutts> cjs: some commercial users are stuck on win32 sadly
20:34:38 <cjs> Ooo, that came out wrong. I mean, go find them, and you'll find your money.
20:34:43 <Pseudonym> A .NET bridge injects Haskell into the "professional software engineer" world.
20:34:43 <lispy> I was rather impressed to see that Bluespec is some 100k of haskell.
20:35:09 <dons> lispy: don't believe it. jdh said all the commercial users are fakes
20:35:19 <dons> esp. the ones with code, products and engineers
20:35:19 <lispy> dons: really?
20:35:30 <cjs> I'm not sure if that's a good thing. That's enormous! But maybe it really does enough stuff to justify that. There are million line Java products out there all over the place.
20:35:34 <dons> he says a lot of things.
20:35:40 <Pseudonym> Sounds like it.
20:35:56 <Pseudonym> This, incidentally, is one of the reasons why I think that MDD might be a good foot in the door.
20:36:05 <lispy> MDD?
20:36:15 <Pseudonym> Model-driven development.
20:36:22 <Pseudonym> It's a bit of a buzzword at the moment.
20:36:23 <dons> executable models are nice
20:36:31 <lispy> Pseudonym: oh right, I replied to you on list but no one else has yet commented
20:36:34 <Pseudonym> But it's essentially SYB for any language.
20:36:41 <cjs> Buzzword-driven-development sells.
20:36:55 <Pseudonym> SYB is _good_.
20:37:14 <lispy> I'm not about to Scrap My Beer, thank you very much :)
20:37:22 <Pseudonym> And doing it via code generation is a nice idea because it integrates with existing languages.
20:37:48 <Pseudonym> But the nice thing about MDD is that you pick what model you're generating code from.
20:38:40 <Pseudonym> The reason is that objects in highly-used languages, like .NET stuff, Java and C++, often map to concepts from the domain.
20:39:06 <Pseudonym> But it's not always a perfect fit, hence there's often boilerplate to handle the impedance mismatch.
20:39:40 <Pseudonym> And all of that is busy work.
20:39:56 <Pseudonym> Anyway.
20:39:58 <Pseudonym> It's a thought.
20:40:20 <lispy> I'll certainly entertain the idea :)
20:40:26 <Pseudonym> :-)
20:41:36 <lispy> Where I work now there are a few re-occuring themes that make it hard (impossible?) to use haskell, except for personal scripting tasks: 1) Using it makes me the opposite of a team player because only I know Haskell on the team. 2) we tend to pick language X because it's already integrated with thing Y.
20:42:10 <lispy> Your point of code generation makes sense with #2 but not #1
20:42:24 <cjs> If you can introduce pair programming, that fixes a lot of the "I'm the only one" issues.
20:42:35 <mml`> anybody have good foundational papers on nested datatypes?  i'm starting with Bird & Meertens '98
20:42:55 <Pseudonym> I think it can also defeat #1.
20:42:59 <Pseudonym> Or at least assist.
20:43:04 <lispy> cjs: yeah, we did pair programming for a while, then management became concerned that they were paying 2x instead of 1x per project
20:43:11 <Pseudonym> If your project really does involve writing a lot of boilerplate...
20:43:22 <Pseudonym> Then producing that faster will get noticed.
20:43:33 <sw17ch> so, in the BSD3 license... if the organization consists of an individual, how does one word the 4th paragraph?
20:44:07 <dblazakis> ?users
20:44:07 <lambdabot> Maximum users seen in #haskell: 540, currently: 482 (89.3%), active: 17 (3.5%)
20:44:22 <lispy> cjs: I'm also not conviced I could get someone significantly up to speed with Haskell just via pair programming.
20:44:42 <adu> lispy: that would solve the RH in no time!
20:44:54 <lispy> In my experience there is a huge gap between knowing some Haskell and really writing good general purpose code
20:45:08 <lispy> adu: sorry, RH?
20:45:18 <adu> lispy: oops that was from 2 hours ago... sory
20:45:31 <Pseudonym> OK, here's a case in point.
20:45:36 <Pseudonym> My previous job involved ASN.1.
20:45:38 <lispy> adu: no problem, just wondering because I forgot the context :)
20:45:47 <Pseudonym> So we maintained an ASN.1 compiler.
20:45:58 <Pseudonym> I say "we".  Actually, there was only one person who knew how to hack it.
20:46:00 <adu> lispy: RH=Riemann hypothesis in the context of numerical data
20:46:16 <adu> lispy: proof systems + law of large numbers?
20:46:20 <Pseudonym> That is a risk, but it's not unknown.
20:46:31 <dons> lispy: we train up people at galois fairly quickly. but we try hard to test them before we employ them, of course.
20:46:43 <Pseudonym> So being the one Haskell guy might not be much of a stretch, so long as the produced code isn't shipped.
20:47:04 <adu> dons: do I pass the test?
20:47:13 <dons> adu: i don't know. have you done the interview?
20:47:19 <adu> dons: nope
20:47:27 <dons> so neither of us know then :)
20:47:29 <sw17ch> dons: actually, i've been meaning to ask about that. how much Haskell experience to new Galois recruits usually have?
20:47:44 <dons> some have lots, some have none. most have FP experience. not all though.
20:47:53 <sw17ch> how big is galois?
20:48:08 <adu> 1 million acres
20:48:21 <dons> ~45 or so employees.
20:48:23 <cjs> lispy: Well, if they can study on their own it helps, but pair programming is one of the most comfortable ways to get up to speed, because it saves agonizing over syntax and so on.
20:48:27 <sw17ch> adu: so, every one has their own office and tennis court then ;)
20:48:48 <sw17ch> dons: huh, somehow i envisioned it being a little smaller
20:48:53 <lispy> cjs: yeah, I like pair programming.  I'm sad that my manager disapproves :(
20:48:56 <sw17ch> (not that it's a problem)
20:49:12 <dons> sw17ch: because haskell engineers are so productive, you only need a company of 3 to compete with google? :)
20:49:27 <cjs> lispy: As for the 2x instead of 1x thing, it depends on how much design you're doing and how much boilerplate you're typing. We do a lot of pair programming here, but there are still situations where it seems pointless.
20:49:29 <dons> sw17ch: btw, you're working on the vpn client/server?
20:49:33 <adu> hmm, i work at a company with ~40 employees, i wonder if thats normal
20:49:37 <sw17ch> dons: yes, and yes
20:49:50 <sw17ch> dons: i was just going to say. we should do a SLOC count between my VPN and OpenVPN when this is finished
20:49:50 <dons> sw17ch: created a lot of buzz inside galois, you'll be please to know.
20:49:57 <sw17ch> dons: wow! :D
20:50:01 <cjs> But if you can get yourself into a situation where most of the work is design, rather than typing, you basically save a lot of time on design meetings and rework costs.
20:50:11 <dons> hey, high assurance vpn --> cool
20:50:18 <Olathe> @pl pair programming
20:50:18 <lambdabot> pair programming
20:50:29 <lispy> Olathe: cute
20:50:34 <Olathe> As we can see, it's already obviously pointless ;)
20:50:34 <Pseudonym> It's a pretty cool project, sw17ch.  Can't wait to see how it works.
20:50:39 <sw17ch> dons: i've always been really good with networks... and i work a lot on the hardware level... and some one challenged me to "...make something really useful" in haskell.
20:51:08 <dons> mm. nice :)
20:51:13 <lispy> sw17ch: could be the next xmonad
20:51:27 <dons> fwiw, we do a lot of networks and hardware stuff. things that have to work right.
20:51:28 <sw17ch> lispy, and you won't even have to like tiling window managers!
20:51:49 <sw17ch> dons: hardware? what kind?
20:52:44 <lispy> sw17ch: one thing that I wondered about though, do you use version control?  You said you accepted patches, but I don't recall seeing a darcs or git repository, just a tarball.
20:52:50 <dons> fpgas.
20:53:05 <dons> yeah, the tarball was weird :)
20:53:10 <dons> repo plz
20:53:21 <adu> FPGA + HAVPN = cool
20:53:24 <sw17ch> lispy: i just cabalized and checked it into google code...
20:53:37 <lispy> sw17ch: google code, so svn?
20:53:38 <sw17ch> lispy, i don't like darcs :(
20:53:42 <sw17ch> yes
20:53:47 <sw17ch> (also, i know svn)
20:54:00 <lispy> sw17ch: uh oh, mortal enemies!  I work on darcs ;)
20:54:25 <sw17ch> lispy: i'm easy to convert :)
20:54:31 <lispy> sw17ch: (just kidding though, I don't care what people use)
20:54:56 <sw17ch> :)
20:55:11 <lispy> in fact, I use svn at work
20:55:26 <sw17ch> lispy, same here... which is why i know it best
20:55:56 <lispy> But, I do think for open source dev, that the distributed model is better.  So I encourage you to take a look at git, hg, bzr and darcs.
20:56:18 <adu> lispy: are those all distributed?
20:56:21 <sw17ch> lispy, i have a friend who's into bzr
20:56:33 <adu> lispy: whats hg?
20:56:40 <lispy> adu: I think bzr is distributed, and the other 3 are
20:57:06 <lispy> adu: hg is the one with a name that has the same root as mercury but I can't spell it :)
20:57:07 <Cale> hydrargyrum ;)
20:57:12 * sw17ch notes that google code's haskell highlighter sucks
20:57:13 * mmorrow has two of http://customcircuitsolutions.com/fim-ep3c5.html on their way and is haggling with sales via email to get one of these zomg http://www.picocomputing.com/products/cards/e16.php
20:57:13 <bd_> those are all distributed, but have very different models
20:57:14 <lambdabot> Title: Custom Circuit Solutions - FPGA Integrated Modules
20:57:25 <sw17ch> lispy, dons: http://code.google.com/p/scurry/
20:57:26 <lambdabot> Title: scurry - Google Code
20:57:34 <adu> lispy: o Murecruruial?
20:57:43 <lispy> adu: something like that, yeah
20:57:43 <Cale> Mercurial
20:57:46 * sw17ch also notes that I'm stuck using C for the ioctl's until something better comes along
20:58:30 <lispy> sw17ch: that's fine, that's how we find out which parts of the haskell library suck still.  People build real-world apps.  Then we spin off your library + api and put that on hackage
20:58:31 <cjs> Re darcs vs. svn, I don't think it's as much about open source as about whether you have one person integrating all patches, or every developer is expected to integrate his own stuff.
20:59:00 <Cale> For the element, I think I prefer the name hydrargyrum. It's nicely descriptive, even if chemically not quite right. :)
20:59:09 <sw17ch> lispy, glad to hear it. :)
20:59:24 <Cale> "watery silver"
20:59:27 <sw17ch> well, i'm in need of sleep... dons, thanks for the encouragement. it's always nice to hear :)
20:59:35 <lispy> sw17ch: g'night
20:59:36 <adu> Cale: wow
21:00:34 <lispy> cjs: so which vcs fits which model?
21:00:57 <adu> Cale: isn't silver argentum?
21:01:01 <Cale> yes
21:01:15 <adu> so shouldn't it be hydrargentium?
21:01:16 <sclv> hmm... salsa uses type families... with ghc 6.8.3 ??
21:01:35 <Cale> I think the roots are just combining a bit strangely.
21:01:59 <cjs> Distributed vcs works well when a central authority integrates patches; a centralized style works well when individual contributors integrate.
21:02:11 <cjs> The basic issue is that integration has to be serialized, more or less.
21:02:42 <BMeph> adu: argentum is Latin. Greek is argentos
21:03:02 <cjs> Centralized VCS means that anybody can have a "master" view of the release.
21:03:15 <cjs> At least, that's been my experience using both.
21:03:42 <cjs> Thus, I use svn for my open source stuff, because I'm a lazy bugger and want to make contributors do the work, and take the blame if they break stuff. :-)
21:03:58 <adu> in the Latin used in the post-classical, mid-Cale period, of course...
21:04:12 <lispy> cjs: interesting, okay
21:04:22 <Cale> heh
21:04:45 <bos> i wouldn't really agree with cjs's characterisation.
21:04:58 <cjs> lispy: BTW, this discovery was quite unexpected to me. I didn't actually imagine it would be that way when I started using distributed VCS.
21:05:45 <cjs> And it's not to say you can't use one for the other style, but each tends in a certain way.
21:06:01 <lispy> cjs: I would agree that the projects I've worked on, with say darcs, have had one person who's role was to accept patches and apply them.  Whereas at work, with svn, several people can commit.  So my experience isn't that different from what you describe.
21:06:10 <Cale> cjs: heh, we're using darcs for lambdabot, but I apply patches without looking at them. ;)
21:06:29 * lispy wiggles his finger at Cale
21:06:34 <cjs> Ah, the best of both worlds! :-)
21:06:45 <lispy> unsafeApplyPatch :: DPatch -> IO Lambdabot
21:07:20 <adu> unsafeApplyPatch launchTheMissilesPatch
21:08:32 <BMeph> So, does anyone still use Omega? Or tinker with it? :)
21:09:13 <BMeph> adu: unsafeApplyPatch launchTheFlyingPumpkinPatch? ;p
21:09:31 <adu> lol
21:09:32 <lispy> cjs: but, anyway, getting back to the OSS point.  I think the value of dvcs in OSS is that anyone can easily start hosting a branch.  Whereas with cvcs it's harder to do that, especially in a way that makes you a peer to the 'official' branch
21:10:12 <cjs> Indeed. Easiest thing to do with svn is use svk.
21:10:14 <lispy> cjs: this has other side benefits like replication
21:10:37 <cjs> Replication's easy to do with rsync.
21:11:12 <Pseudonym> I find the use of the word "svk" and the word "easy" in the same sentence unrealistic.
21:11:23 <Pseudonym> But my knowledge of such matters may be obsolete.
21:11:38 <cjs> svk's worked pretty well for me; I use it reguarly.
21:11:40 <rwbarton> With SVN it's hard as an outside developer to create and submit any large patch
21:11:54 <Pseudonym> Maybe it was the state of the documentation last time I tried it.
21:12:08 <cjs> Yup. svn works best if everybody has commit access, no doubt about it.
21:12:52 <rwbarton> (It's also harder for the outside developer to maintain some private changes over the long term, but that's not really the project's problem)
21:13:17 <lispy> right, I think linus has an essay about how cvs, in particular, puts people into a disenfranchised state when they don't have write access
21:15:07 <Pseudonym> CVS is a hack.
21:15:15 <Pseudonym> A clever hack for its time, to be sure.
21:16:15 <lispy> Speaking of which, it would be nice for vcs to become a research topic.  I think it's a significantly important part of real software projects, and yet each vcs seems to have its own model.  I think it's time to get formal and maybe end this vcs war :)
21:17:11 <cjs> CVS was an absolutely amazing hack. That something so bad could be used so broadly and last so long is a testament to the difficulty of the problem, I think.
21:17:18 <hansfbaier> lispy: AFAIK, darcs has a formal model (an algebra of patches)
21:17:37 <hansfbaier> lispy: But comparing darcs with git it is *very* slow
21:17:41 <lispy> hansfbaier: it has an abstract model, but I'm extremly hesitant to call it formal
21:17:49 <cjs> I am told that the Darcs model is basically hand-waving.
21:18:07 <hansfbaier> lispy: never looked at it in detail though.l
21:18:14 <lispy> I have :)
21:18:51 <lispy> It's handwavey in the sense that the documentation doesn't really nail it down formally, but then we do have a implementation so that's something
21:19:20 <lispy> and now we have Igloo trying his best to formalize it as Camp
21:19:49 <lispy> Sans conflicts, I think it's reasonably formalizable
21:20:00 <lispy> But, when you add conflicts people start to disagree
21:20:32 <cjs> You bet. I rather strongly disagree with the "two conflicting patches both vanish" part of it.
21:20:43 <lispy> and, last time I checked Dr. Martin Erwig at OSU has a student working on a calculus for describing changes
21:22:26 <lispy> I made a stab at formalizing just the most basic parts of patch theory in my thesis
21:22:38 <lispy> But, droundy hasn't read that chapter recently, so I don't know if he agrees :)
21:22:55 <lispy> I believe I'm correct, but we'll see :)
21:43:33 <chrisdone> one day nasreddin the sufi was approached by a woman who said “I want to ask you a question, but sufis are tricksters!”. nasreddin responded, “I wouldn't know if this were true, having never met a sufi”
21:51:06 <dons> lispy: have you shown igloo?
21:51:21 <dons> thanks chrisdone. i had to think about that one :-)
21:52:04 <lispy> dons: no, due to the scary wording from my university about the need to document all the authors of your thesis I'm afraid to show anyone outside of my committee until I'm done
21:53:03 <roconnor> how do I make a `é' in bibtex?
21:53:12 <dons> oh weird.
21:53:41 <lispy> dons: maybe I'm just paranoid.  But it seems like an avoidable risk, so I will avoid it :)
21:54:09 <lispy> dons: my concern is that he'd say, "oh you should change this or that" and then I may do that and then, is he an author?  I'm not sure...
21:54:27 <lispy> dons: otoh, discussing the topic with him would be fine
21:57:21 <dons> seems worse to have incorrect statements. but maybe you can get igloo to be a reviewer of the draft.
21:57:37 <dons> at least at my school, the grad students would hand around copies once the draft was done, for corrections.
21:57:46 <lispy> dons: I think David really should be fine to catch incorrect statements wrt to patch theory.
21:57:52 <lispy> ah
21:58:11 <dons> you'd hope so :)
21:59:30 <lispy> It's this distinction between reviwer/feedback giver and author that seems intentionally fuzzy :)
21:59:51 <lispy> if my committee says to do it, I'll do it :)
22:01:20 <witkamp> hey any one have a moment  for a really quick noob question ?
22:01:30 <witkamp> http://hpaste.org/10966
22:01:49 <lispy> witkamp: fromIntegral
22:01:56 <lispy> :t fromIntegral
22:01:56 <witkamp> thanks
22:01:57 <lambdabot> forall a b. (Num b, Integral a) => a -> b
22:02:34 <lispy> ?hoogle Word16 -> Word32
22:02:35 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
22:02:35 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
22:02:35 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
22:02:52 <lispy> oh cool, witkamp see that, hoogle could have told you what to use!
22:03:09 <witkamp> thanks
22:03:17 <lispy> hoogle++
22:03:24 <witkamp> I but i like to bother real people
22:03:31 <lispy> hehe
22:03:35 <lispy> Who says I'm real?
22:03:43 <witkamp> lol
22:04:44 <dons> i've met lispy. he seems real.
22:04:49 <dons> or else ... i met an imposter.
22:05:00 * lispy pleads the 5th
22:06:36 <witkamp> i see
22:07:00 <witkamp> I mixing up fromInteger with fromIntegral
22:07:13 <witkamp> oops
22:07:27 <lispy> it can be confusing at first because Integral is a type class, but Integer is a type
22:07:40 <witkamp> gotcha
22:07:47 <lispy> anything that is interger-ish can be in the Integral type class
22:07:57 <lispy> ?instances Integral
22:07:58 <lambdabot> Int, Integer
22:08:02 <witkamp> I think my typing reflex got the better of me
22:08:05 <Axman6> so Int8 --> Integer?
22:08:11 <lispy> there are more instances than that, BTW
22:08:35 <lispy> ?hoogle Int8 -> Integer
22:08:35 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
22:08:35 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
22:08:35 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
22:09:06 <lispy> Axman6: so for that specialized type you'd want toInteger it seems
22:09:32 <rhz> Are there any known problems building the ghc-prim package with the latest GHC?
22:09:41 <Axman6> lispy: i was talking about how Integral covered everything from Int8 to Integer
22:09:49 <Axman6> notice the --> :P
22:10:10 <lispy> Axman6: oh, I see
22:10:59 <rhz> Or for that matter, building the latest bytestring package with the latest GHC?
22:13:15 <rhz> Because when I try and build bytestring I get a missing dependancy "ghc-prim -any". But I can't build ghc-prim because it gives me errors.
22:16:55 <rhz> To be specific, doing "runhaskell Setup.hs configure" gives me errors.
22:24:46 <Axman6> is there any news on ghc 6.10?
22:31:32 <lispy> Axman6: the last I saw was an update from dcoutts saying that you can now build most cabalized programs in ghc 6.10
22:31:51 <dcoutts> well, I'm still fixing the resolver as we speak...
22:31:53 <Axman6> well that's good to know
22:32:08 <lispy> dcoutts: cool
22:32:23 <lispy> dcoutts: do you happen to know when 6.10 final is supposed to ship?
22:33:02 <dcoutts> lispy: I think Igloo expects a RC tomorrow and a final perhaps a week later
22:33:14 <lispy> cool
22:38:39 <Axman6> dcoutts: sounds good :0
22:38:41 <Axman6> :)*
22:41:25 * lispy calls it a day and heads home
22:44:43 <dons> night lispy.
22:44:57 <dons> coming in tomorrow for the cabal talk?
22:50:11 <chrisdone> cabal talk?
22:51:13 <Axman6> hmm, anyone know how to install CReal?
22:51:55 <dons> cabal install creal ?
22:52:00 <Axman6> i used darcs to get it, and it's only got a makefile for making an exe to test it. no way to install it
22:52:03 <dons> oh, in the numbers package?
22:52:08 <dons> Axman6: isn't it on hackage now?
22:52:16 <Axman6> i don't know
22:52:19 * dons doesn't install anything that's not on hackage. :)
22:52:30 <dons> cabal install numbers
22:52:37 <dons> http://hackage.haskell.org/packages/archive/numbers/2008.4.20/doc/html/Data-Number-CReal.html
22:52:39 <lambdabot> Title: Data.Number.CReal, http://tinyurl.com/5o8mj8
22:52:51 <dcoutts> chrisdone: I'm doing the galois tech talk tomorrow. I'll be talking about some topics related to cabal
22:53:02 <Axman6> does that mean it can be installed with cabal or not?
22:53:10 <dons> Axman6: it means,
22:53:11 <dons> ?faq
22:53:11 <lambdabot> The answer is: Yes! Haskell can do that.
22:53:17 <dons> $ cabal install numbers
22:53:31 <Axman6> ah ha, thanks
22:53:35 <dons> :)
22:54:59 <Axman6> dons: did you hear that the place ivman (i think...) and i ordered your book from now wants to charge people $116 for it?
22:55:06 <Axman6> we got it for less than 60 :)
22:55:56 <dons> Axman6: awesome!
22:56:05 <dons> good work, lads. get in before the dollar collapses :)
22:56:12 <Axman6> heh
22:56:27 <dons> so that really sounds like an old price when the dollar ratio was 1:0.98
22:56:31 <dons> not 1:0.7
22:56:58 <idnar> @type (>>=)
22:56:59 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
22:57:39 <jdrake> May I have a data type named Starmap within a module called Starmap.Model without conflict?
22:57:42 <vegai> was even 1:0.6 for a while
22:57:46 <cjs> Gah, you'd think that my market data feed guys were making it intentionally hard to simulate the market.
22:57:53 <quicksilver> jdrake: sure.
22:57:56 <vegai> for some reason that's completely beyond me, the us dollar seems to be strengthening
22:58:15 <Axman6> vegai: it was 1:0.5 too
22:58:17 <quicksilver> the strength of the dollar is largely controlled by .cn
22:58:25 <quicksilver> I imagine they dont' want it to collapse.
22:58:27 <Axman6> i think that was around 2001, when we went over seas... -_-
22:58:45 <Axman6> quartre punder in england cost $11AU, and was smaller than we get them here
22:58:52 <dons> jdrake: you may have that.
22:59:28 <dons> vegai: the .au dollar was on parity when they ordered the book, but is not anymore.
22:59:54 <dons> so i was talking about the .au dollar collapsing.
23:00:05 <vegai> ah.
23:02:19 <lispy> dons: yeah, I plan to be there
23:02:35 <lispy> dons: I may be hobbling though...still walking funny after the pdx marathon on sunday :)
23:02:44 <dons> awesome!
23:02:52 <dons> you can have a comfy chair then.
23:04:07 <Axman6> wow, the CReal code is crazy.
23:04:10 <lispy> dons: heeh, it's just my feet that are sore really...so any chair will do :)
23:04:29 <Axman6> i'm sure it all makes sense... but how it was all figured out, i have no idea
23:33:42 <dcoutts> dancor: ping
23:34:34 <dcoutts> @tell dancor if you could try your ghc-6.10/cabal-install test case again with the latest darcs version of cabal-install that'd be great
23:34:35 <lambdabot> Consider it noted.
23:41:33 <ac> can someone think of a data structure that makes it very easy to swap any element with one special element?
23:41:58 <ac> the obvious solution is a two element record containing an index of the special element, and an array
23:42:31 <thermoplyae> hey guys, is lambdabot owned by one of you?
23:42:40 <ac> is there a better solution?
23:42:45 <lispy> thermoplyae: owned in what way?
23:42:56 <thermoplyae> owned in the 'i control what channels he goes into' way
23:43:04 <lispy> thermoplyae: lambdabot is a community effort
23:43:06 <thermoplyae> or she, if i recall correctly
23:43:07 <dons> thermoplyae: it is owned by no man :)
23:43:10 <dons> but yes, there's a few admins.
23:43:13 <ac> thermoplyae: lambdabot is a she
23:43:31 <lispy> ac: I don't understand what you mean by special element
23:43:36 <dons> thermoplyae: which channel?
23:43:43 <ac> lispy: it's the element that can be swapped with any of the others
23:44:00 <lispy> ac: could you explain it in terms of types or with pseudo code?
23:44:06 <lispy> ac: I'm not getting it
23:44:06 <thermoplyae> dons: if you could keep her out of #math, i'd appreciate it.  doesn't get used for much except informing the whole channel that a mathbin link doesn't have a title :/
23:44:42 <lispy> thermoplyae: in that case, you probably want to discuss this with Cale
23:45:00 <thermoplyae> excellent, if cale has access, i'll threaten him.  thanks
23:45:02 <lispy> thermoplyae: you can use lambdabot to leave message for people with ?tell User message
23:45:45 <ac> lispy: well, to get straight to the point, I want a data structure appropriate for a NxN slide puzzle. The special "element" would be the gap, and the others would be an integer from say, 1-8 (for a 3x3)
23:46:04 <lispy> ac: oh, I see
23:46:21 <thermoplyae> i'll just highlight him.  thanks for the tip on Cale though
23:46:24 <thermoplyae> enjoy your monads
23:46:47 <ac> so currently I'm thinking: data Puzzle = Puzzle { gap :: (Int8, Int8); puzzle :: Array (Int8, Int8) Int8 }
23:46:55 <lispy> ac: so you'll probably want a type that has both 1-8 and the Gap as values?
23:47:01 <dons> thetallguy: oh, definitely talk to Cale then.
23:47:07 <dons> thermoplyae.
23:47:13 <ac> lispy: yeah
23:47:20 <ac> lispy: or just 0 for the gap
23:47:45 <thetallguy> dons: *snore* *Yelp!*  What?   Oh.   *snore*
23:48:37 <lispy> ac: Because you're using Array, I assume you are looking for something that support destructive updates?
23:48:37 <thetallguy> they kind of rhyme, don't they.
23:49:05 <ac> lispy: I don't care about destructive updates
23:49:15 <cjs> @vixen Who owns you?
23:49:15 <lambdabot> what about me?
23:49:25 <lispy> ac: before you go too far down that road, let me just say that when I was doing NxN board problems like knight's tour, I found it very efficient to store the positions in a list instead of updating a data structure
23:49:26 <dons> night thetallguy :)
23:49:29 <ac> lispy: I thought it might be convenient to easily tell which tile is in say, the lower right position
23:50:23 <ac> lispy: I'm going to be doing a lot of creating new boards with the gap and an adjacent piece swapped
23:50:53 <lispy> ac: right
23:51:01 <cjs> If you can come up with a structure where the gap and adjacent pieces are at the front of a list, that will be quite fast.
23:51:31 <ac> it did occur to me to represent it as a list of tupples, so the head of the list would always be the gap
23:51:38 <ac> cjs: but that did not occur to me. good idea
23:51:38 <lispy> ac: so I can see why an Array is a nice way to model the board
23:52:16 <cjs> So perhaps, data Piece = Gap | Piece Int, and data Position = Position Piece Int Int.
23:53:11 <ac> and data Puzzle = Puzzle [Position]
23:53:16 <cjs> You'll be shifting around the top bits of the list quite a lot, but the tail of it less so, so it ought be fairly efficient.
23:54:10 <thetallguy> dons: I want a bedtime story.  What's the coolest use of fix you know of?
23:54:52 <lispy> thetallguy: have you seen the way to generate powers of 2 from counting quote charaters that result from fix . show ?
23:55:02 <ac> it would probably actually be easier to say: Position = Position Piece Int, so that I can say: solved puzzle = map (\(Position p i) -> p == i) puzzle
23:55:39 <thetallguy> lispy: Is it similar to the recurrence in  Hinze's Pearl?
23:55:51 <lispy> thetallguy: I don't know Hinze's Pearl
23:56:19 <cjs> Or just generate a solved puzzle and use == on the two lists, assuming you make everything derive Eq.
23:56:37 <lispy> > init . map snd . filter fst . zip (fix ([True, False] ++)) . ap (zipWith (+)) tail . map length . group . fix $ show
23:56:53 <lambdabot>   thread killed
23:57:00 <lispy> thetallguy: try that definition in something like ghci
23:57:08 <idnar> poor thread
23:57:17 <ac> cjs: that won't work, because with your data structure there's N! possible representations of the same puzzle state where N is the number of pieces
23:57:58 <lispy> > init . map snd . filter fst . zip (fix ([True, False] ++)) . ap (zipWith (+)) tail . take 100 . map length . group . fix $ show
23:58:05 <cjs> You can just generate the solved one at the same time as you generate the scrambled one.
23:58:11 <lispy> Hmm...that used to be lazier
23:58:14 <lambdabot>   thread killed
23:59:17 <Axman6> lambdabot bought a gym membership
