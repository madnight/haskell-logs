00:01:17 <newsham> dan piponi was on nova tonight (www.pbs.org/nova)
00:01:30 <sclv> omg my brain hurts: http://github.com/nfjinjing/mps/tree/master/MPS/Snippets.hs
00:01:31 <lambdabot> Title: MPS/Snippets.hs at master from nfjinjing's mps — GitHub
00:04:33 <dons> newsham: wow
00:16:53 <mmorrow> http://www-tc.pbs.org/wgbh/nova/fractals/images/radi-13-l.jpg
00:17:34 <mmorrow> http://www-tc.pbs.org/wgbh/nova/fractals/images/radi-06-l.jpg
00:17:50 <mmorrow> (all of them @) http://www.pbs.org/wgbh/nova/fractals/radi-06.html
00:17:51 <lambdabot> Title: NOVA | Hunting the Hidden Dimension | A Radical Mind image 6 | PBS
00:20:46 <mmorrow> this is a good interview:
00:20:47 <mmorrow> http://www.pbs.org/wgbh/nova/fractals/mandelbrot.html
00:20:48 <lambdabot> Title: NOVA | Hunting the Hidden Dimension | A Radical Mind | PBS
00:21:02 <mmorrow> (link is to a transcription)
00:26:41 <Axman6> heh, i find it quite odd that (unfoldr (\x -> Just (x,sin x)) 1) !! 693551 runs fine, but (unfoldr (\x -> Just (x,sin x)) 1) !! 693552 gets a stack overflow
00:27:07 <mmorrow> the feather that broke the camel's back
00:27:23 <dolio> Now you know how big your stacks are.
00:27:26 <pumpkin> how do you unfold?
00:27:30 <pumpkin> @src unfoldr
00:27:30 <lambdabot> unfoldr f b  = case f b of
00:27:30 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
00:27:30 <lambdabot>    Nothing        -> []
00:27:33 <pumpkin> hmm
00:27:56 <Axman6> dolio: it's a pretty random number
00:27:57 <pumpkin> hmmmm
00:27:59 <Axman6> "random"
00:28:14 <Axman6> pumpkin: lets you produce a list from a single value
00:28:23 <pumpkin> oh interesting
00:28:26 <mmorrow> , unfoldr (\x -> if x < 1024 then Just (x, x+82) else Nothing) 0
00:28:29 <lunabot>  [0,82,164,246,328,410,492,574,656,738,820,902,984]
00:28:30 <rwbarton> You know what else is weird?  This random number I generated was exactly 1489084039!
00:28:46 <Axman6> > unfoldr (\x ->if x < 10  Just (x,1+ x) else Nothing) 1
00:28:47 <lambdabot>   <no location info>: parse error on input `else'
00:28:54 <Axman6> > unfoldr (\x ->if x < 10 then Just (x,1+ x) else Nothing) 1
00:28:55 <lambdabot>   [1,2,3,4,5,6,7,8,9]
00:29:03 <pumpkin> so it stops if it encounters a Nothing
00:29:08 <Axman6> yep
00:29:11 <pumpkin> I've needed something like that before
00:29:14 <Axman6> :t unfoldr
00:29:14 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
00:29:15 * pumpkin adds it to his toolbelt
00:29:24 <pumpkin> thanks!
00:29:35 <mmorrow> :t mapAccumL
00:29:36 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
00:29:37 <mmorrow> :t mapAccumR
00:29:38 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
00:29:38 <dolio> > 65536 * 12
00:29:39 <lambdabot>   786432
00:30:06 <Axman6> > unfoldr (\x -> Just (x,x)) 1 -- over complicated repeat...
00:30:07 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
00:30:11 <pumpkin> :P
00:30:49 <pumpkin> it's kinda odd to be passing that pair around, but I guess it's necessary to keep track of the previous state
00:31:01 <Axman6> i haven;t actually found a nice use for it, but i'm sure that's just because i'm not thinking hard enough
00:31:13 <mmorrow> , fix (\go x -> if x < 1024 then x : (x+1) : go (x+82) else []) 0
00:31:15 <lunabot>  [0,1,82,83,164,165,246,247,328,329,410,411,492,493,574,575,656,657,738,73...
00:31:21 <mmorrow> oops
00:31:25 <mmorrow> , fix (\go x -> if x < 1024 then x : (x+82) : go (x+82) else []) 0
00:31:27 <lunabot>  [0,82,82,164,164,246,246,328,328,410,410,492,492,574,574,656,656,738,738,...
00:31:31 <dolio> It's useful all over the place.
00:31:43 <dolio> Any time you want to write something primitive corecursive.
00:31:43 <mmorrow> oops again
00:31:49 <mmorrow> , fix (\go x -> if x < 1024 then x : go (x+82) else []) 0
00:31:51 <lunabot>  [0,82,164,246,328,410,492,574,656,738,820,902,984]
00:32:02 <mmorrow> , unfoldr (\x -> if x < 1024 then Just (x, x+82) else Nothing) 0
00:32:04 <pumpkin> why call it go?
00:32:05 <lunabot>  [0,82,164,246,328,410,492,574,656,738,820,902,984]
00:32:37 <mmorrow> pumpkin: because it is the continuation which go go gadget goes :)
00:32:47 * pumpkin 's head explodes
00:33:12 <mmorrow> so
00:33:49 <dolio> > let pick f ([],[]) = Nothing ; pick f (x:xs,y:ys) = (f x y, (xs,ys)) ; zipWith f = unfoldr (pick f) (xs,ys) in zipWith (+) [1..10] [11..20]
00:33:51 <lambdabot>   Not in scope: `xs'Not in scope: `ys'
00:34:08 <dolio> > let pick f ([],[]) = Nothing ; pick f (x:xs,y:ys) = (f x y, (xs,ys)) ; zipWith f xs ys = unfoldr (pick f) (xs,ys) in zipWith (+) [1..10] [11..20]
00:34:08 <lambdabot>   Couldn't match expected type `Maybe a'
00:34:20 <dolio> > let pick f ([],[]) = Nothing ; pick f (x:xs,y:ys) = Just (f x y, (xs,ys)) ; zipWith f xs ys = unfoldr (pick f) (xs,ys) in zipWith (+) [1..10] [11..20]
00:34:21 <lambdabot>   [12,14,16,18,20,22,24,26,28,30]
00:34:26 <dolio> There we are.
00:35:05 <dolio> > let stopAt p f x = if p x then Nothing else Just (f x) ; chunk n = unfoldr (stopAt null $ spliAt n) in chunk 5 [1..]
00:35:06 <lambdabot>   Not in scope: `spliAt'
00:35:17 <dolio> Geeze. I'm off my game tonight.
00:35:24 <dolio> > let stopAt p f x = if p x then Nothing else Just (f x) ; chunk n = unfoldr (stopAt null $ splitAt n) in chunk 5 [1..]
00:35:26 <lambdabot>   [[1,2,3,4,5],[6,7,8,9,10],[11,12,13,14,15],[16,17,18,19,20],[21,22,23,24,25...
00:35:39 <mmorrow> in fix (\f x -> ....) x0  ====> f == (\x -> fix (\f x -> .... ) x)
00:36:35 <mmorrow> , fix (\go x -> if x < 2 then x : f (x+1) else []) 0
00:36:37 <lunabot>  luna: Not in scope: `f'
00:36:41 <mmorrow> , fix (\f x -> if x < 2 then x : f (x+1) else []) 0
00:36:43 <lunabot>  [0,1]
00:36:50 <mmorrow> fix (\f x -> if x < 2 then x : f (x+1) else []) 0
00:37:01 <mmorrow> 0 : fix (\f x -> if x < 2 then x : f (x+1) else []) 1
00:37:09 <mmorrow> 0 : 1 : fix (\f x -> if x < 2 then x : f (x+1) else []) 2
00:37:15 <mmorrow> 0 : 1 : []
00:37:26 <dolio> Anyhow, unfoldr is important in a similar way that foldr is.
00:37:57 <mmorrow> (@pumpkin)
00:39:06 * pumpkin 's head is exploded, when was the last time you successfully showed something to a mass of splattered brains stuck to the wall?
00:39:24 <mmorrow> , fix (\xs -> [0,1] ++ [xs!!3, xs!!4] ++ [42])
00:39:25 <dolio> @quote brain
00:39:26 <lambdabot> _Stinger_ says: sometimes Haskell seems like an arms race between weird mathematical constructs and my brain
00:39:27 <lunabot>  [0,1,42,42,42]
00:39:34 <mmorrow> in fix (\xs -> [0,1] ++ [xs!!3, xs!!4] ++ [42])
00:39:55 <mmorrow> the xs stands for the eventual result
00:40:13 <ivanm> anyone here used the happraise app on hackage?
00:40:16 <mmorrow> so then, this will loop forever:
00:40:31 <mmorrow> , fix (\xs -> [0,1] ++ [xs!!2, 0] ++ [42])
00:40:34 <lunabot>  luna: out of memory (requested 2097152 bytes)
00:40:54 <mmorrow> since xs!!2 depends on xs!!2 depends on xs!!2 ...
00:41:13 <mmorrow> , fix (\xs -> [0,1] ++ [xs!!3, 0] ++ [42])
00:41:15 <lunabot>  [0,1,0,0,42]
00:41:28 <mmorrow> , fix (\xs -> [0,1] ++ [xs!!4, 0] ++ [42])
00:41:30 <lunabot>  [0,1,42,0,42]
00:41:49 <mmorrow> , fix (\xs -> [0,1] ++ take 3 xs ++ [42])
00:41:51 <lunabot>  [0,1,0,1,0,42]
00:42:13 <mmorrow> , fix (\xs -> [0,1] ++ take 2 (reverse xs) ++ [42])
00:42:16 <lunabot>  luna: out of memory (requested 2097152 bytes)
00:42:23 <mmorrow> , fix (\xs -> [0,1] ++ head (reverse xs) ++ [42])
00:42:24 <lunabot>  luna: Occurs check: cannot construct the infinite type: t = [t]
00:42:34 <mmorrow> , fix (\xs -> [0,1] ++ [head (reverse xs)] ++ [42])
00:42:36 <lunabot>  [0,1,42,42]
00:51:42 <mmorrow> , fix (\go n xs -> if null xs then [] else let (ys,zs) = splitAt n in ys : go (n+1) zs) 1 [0..]
00:51:44 <lunabot>  luna: Couldn't match expected type `(t, t1)'
00:51:52 <mmorrow> , fix (\go n xs -> if null xs then [] else let (ys,zs) = splitAt n xs in ys : go (n+1) zs) 1 [0..]
00:51:54 <lunabot>  [[0],[1,2],[3,4,5],[6,7,8,9],[10,11,12,13,14],[15,16,17,18,19,20],[21,22,...
00:52:37 <mmorrow> , fix (\go n xs -> if null xs then [] else let (ys,zs) = splitAt (n-2) xs in ys : go (n+3) zs) 3 [0..]
00:52:39 <lunabot>  [[0],[1,2,3,4],[5,6,7,8,9,10,11],[12,13,14,15,16,17,18,19,20,21],[22,23,2...
00:54:14 <mmorrow> i just fully understood how fix actually works about two weeks ago, and my mind is blown forever
00:58:31 <mmorrow> fix (\go hist -> getLine >>= \l -> if l==":q" then return hist else go (l:hist)) []
00:59:21 <Axman6> @index fix
00:59:21 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
00:59:35 <mmorrow> let fix f = let x = f x in x
00:59:41 <mmorrow> let fix f = f (fix f)
00:59:44 <olsner> > tails [1,2,3]
00:59:45 <lambdabot>   [[1,2,3],[2,3],[3],[]]
01:01:25 <mmorrow> > fix f :: Expr
01:01:26 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
01:10:48 <mmorrow> @type let unfoldr f = fix (\k b -> maybe [] (\(a,b') -> a : k b') (f b)) in unfoldr
01:10:49 <lambdabot> forall t a. (t -> Maybe (a, t)) -> t -> [a]
01:12:54 <mmorrow> @type let unfoldr f = fix (\k -> maybe [] (uncurry (:) . fmap k) . f) in unfoldr
01:12:55 <lambdabot> forall a a1. (a -> Maybe (a1, a)) -> a -> [a1]
01:13:29 <mmorrow> @pl \f -> fix (\k -> maybe [] (uncurry (:) . fmap k) . f)
01:13:29 <lambdabot> fix . flip ((.) . maybe [] . (uncurry (:) .) . fmap)
01:18:03 <mmorrow>  @pl should totally be a standard ghci feature
01:18:13 <Axman6> ew
01:18:43 <mmorrow> as shoud @unpl, @undo, @unmtl, and whatever other one's of this type there are
01:18:50 <mmorrow> *should
01:18:54 <Axman6> yes, those would be more handy
01:19:02 <Axman6> unmtl?
01:19:48 <mmorrow> @unmtl ConT (State s a) (ReaderT r IO b) c
01:19:48 <lambdabot> ConT (s -> (a, s)) (r -> IO b) c
01:19:54 <mmorrow> @unmtl ContT (State s a) (ReaderT r IO b) c
01:19:54 <lambdabot> err: `r -> IO b' is not a type function.
01:20:03 <mmorrow> ha
01:20:17 <mmorrow> @unmtl ContT (State s a) (ReaderT r IO) c
01:20:18 <lambdabot> (c -> r -> IO (s -> (a, s))) -> r -> IO (s -> (a, s))
01:20:36 <Axman6> o.O
01:22:01 <rwbarton> , ppDoc $( lift . fst =<< oldtype =<< [t| ContT (State Int ()) (ReaderT String IO) Bool |] )
01:22:06 <lunabot>  (Bool ->
01:22:06 <lunabot>   ([] Char) ->
01:22:06 <lunabot>   (State# RealWorld) ->
01:22:14 <mmorrow> oh sweet
01:22:25 <Axman6> State# RealWorld?
01:22:31 <rwbarton> Yeah, it expanded IO :)
01:22:34 <mmorrow> , src ''IO
01:22:39 <lunabot>  newtype IO a = IO ((State# RealWorld) ->
01:22:39 <lunabot>                     (#,#) (State# RealWorld) a)
01:23:26 <mmorrow> = IO ((State# RealWorld) -> (# State# RealWorld , a #))
01:23:35 <mmorrow> = IO (State# RealWorld -> (# State# RealWorld , a #))
01:24:07 <Axman6> , src ''RealWorld
01:24:09 <lunabot>  luna: Not in scope: type constructor or class `RealWorld'
01:24:26 <Axman6> damn, so close to the meaning of life
01:28:00 <thoughtpolice> cool! http://github.com/geekrelief/as3tohaxe/tree/master
01:28:01 <lambdabot> Title: geekrelief's as3tohaxe at master — GitHub
01:28:53 <rwbarton> The definition of RealWorld: data RealWorld
01:29:27 <Axman6> data RealWorld = <end of file and harddisk>
01:29:47 <mmorrow> , ppDoc $( lift . fst =<< oldtype =<< [t| ContT (State Int ()) (ReaderT String Maybe) Bool |] )
01:29:51 <lunabot>  (Bool -> ([] Char) -> Maybe (Int -> (,) () Int)) ->
01:29:51 <lunabot>  ([] Char) -> Maybe (Int -> (,) () Int)
01:30:18 <Axman6> what's with the (,) () Int stuff?
01:30:20 <mmorrow> , ppDoc . normalizeT $( lift . fst =<< oldtype =<< [t| ContT (State Int ()) (ReaderT String Maybe) Bool |] )
01:30:28 <lunabot>  luna: Couldn't match expected type `a -> b'
01:30:28 <Axman6> that does mean ((),Int) right?
01:30:37 <mmorrow> , src 'normalizeT
01:30:42 <lunabot>  normalizeT :: forall a . Data a => a -> a
01:30:47 <mmorrow> Axman6: exactly
01:31:01 <mmorrow> , ppDoc . normalizeT $ $( lift . fst =<< oldtype =<< [t| ContT (State Int ()) (ReaderT String Maybe) Bool |] )
01:31:01 <rwbarton> , ppDoc . normalizeT $ $( lift . fst =<< oldtype =<< [t| ContT (State Int ()) (ReaderT String Maybe) Bool |] )
01:31:04 <rwbarton> bah
01:31:04 <mmorrow> heh
01:31:05 <lunabot>  (Bool -> ([Char]) -> Maybe (Int -> ((), Int))) ->
01:31:05 <lunabot>  ([Char]) -> Maybe (Int -> ((), Int))
01:31:10 <lunabot>  (Bool -> ([Char]) -> Maybe (Int -> ((), Int))) ->
01:31:10 <lunabot>  ([Char]) -> Maybe (Int -> ((), Int))
01:31:11 <rwbarton> ooh
01:31:15 <mmorrow> ahh
01:34:08 <mmorrow> awesome. so we've got :info, generalized @unmtl, expand tysyns so far
01:34:38 <Axman6> :t either
01:34:39 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
01:38:00 <mmorrow> Axman6:
01:38:05 <mmorrow> data RealWorld
01:38:19 <mmorrow> (is the full declaration)
01:38:29 <mmorrow> ((it doesn't exists :):)
01:38:29 <Axman6> i like mine better
01:38:47 <Axman6> requires the hdd to read the real world
01:39:14 <mmorrow> the hdd doesn't exists either
01:39:25 <mmorrow> gah, s/s// s/s//
01:41:30 <BeelsebobWork> Axman6:
01:41:30 <BeelsebobWork> > let catchError f g = Right . either f g in catchError (const 0) id (Right 42)
01:41:31 <lambdabot>   Right 42
01:41:53 <BeelsebobWork> > let catchError f g = Right . either f g in catchError (const 0) id (Left "The type checker exploded in firey death when someone unsafePerformIO launchMissiled")
01:41:54 <lambdabot>   Right 0
01:42:18 <Axman6> hmm
01:44:30 <mmorrow> , let rotate = either Right Left in (rotate . rotate . rotate) (Left (Right (Left 42)))
01:44:32 <lunabot>  Right (Right (Left 42))
01:44:49 <BeelsebobWork> mmorrow: ahahaha, that's genious
01:45:14 <mmorrow> hehe, "no no, you OTHER Right..."
01:45:19 <mmorrow> *your
01:47:42 <mmorrow> @type let rotate f = either (Right . f) (Left . f) in (rotate (rotate rotate))
01:47:43 <lambdabot> forall a b. Either (Either (a -> b) (a -> b)) (Either (a -> b) (a -> b)) -> Either (Either (Either a a -> Either b b) (Either a a -> Either b b)) (Either (Either a a -> Either b b) (Either a a ->
01:47:43 <lambdabot> Either b b))
01:47:48 <mmorrow> zomg
01:48:25 <mmorrow> @type let rotate f = either (Right . f) (Left . f) in (rotate (rotate (rotate id))
01:48:26 <lambdabot> parse error (possibly incorrect indentation)
01:48:28 <mmorrow> @type let rotate f = either (Right . f) (Left . f) in (rotate (rotate (rotate id)))
01:48:29 <lambdabot> forall a. Either (Either (Either a a) (Either a a)) (Either (Either a a) (Either a a)) -> Either (Either (Either a a) (Either a a)) (Either (Either a a) (Either a a))
01:48:42 <Deewiant> @type let rotate f = either (Right . f) (Left . f) in rotate . rotate . rotate
01:48:43 <lambdabot> forall a b. (a -> b) -> Either (Either (Either a a) (Either a a)) (Either (Either a a) (Either a a)) -> Either (Either (Either b b) (Either b b)) (Either (Either b b) (Either b b))
01:48:59 <mmorrow> ohh
01:49:05 <rwbarton> @djinn (a -> b) -> Either (Either (Either a a) (Either a a)) (Either (Either a a) (Either a a)) -> Either (Either (Either b b) (Either b b)) (Either (Either b b) (Either b b))
01:49:06 <lambdabot> f a b =
01:49:06 <lambdabot>     case b of
01:49:06 <lambdabot>     Left c -> case c of
01:49:06 <lambdabot>               Left d -> case d of
01:49:06 <lambdabot>                         Left e -> Left (Left (Left (a e)))
01:49:08 <lambdabot>                         Right f -> Left (Left (Left (a f)))
01:49:10 <lambdabot>               Right g -> case g of
01:49:12 <lambdabot>                          Left h -> Left (Left (Left (a h)))
01:49:12 <mmorrow> @type let rotate f = either (Right . f) (Left . f) in rotate . rotate
01:49:14 <lambdabot>                          Right i -> Left (Left (Left (a i)))
01:49:16 <lambdabot>     Right j -> case j of
01:49:18 <lambdabot>                Left k -> case k of
01:49:19 <mmorrow> haha
01:49:20 <lambdabot>                          Left l -> Left (Left (Left (a l)))
01:49:22 <lambdabot> Plugin `djinn' failed with: thread killed
01:49:24 <lambdabot> forall a b. (a -> b) -> Either (Either a a) (Either a a) -> Either (Either b b) (Either b b)
01:49:29 <BeelsebobWork> ouch
01:49:43 <BeelsebobWork> that's one of the more awesome djinn's I've ever seen
01:50:11 <mmorrow> @type let rotate f = either (Right . f) (Left . f) in (rotate . rotate . rotate) (Left (Right (Left 42)))
01:50:12 <lambdabot>     Couldn't match expected type `a -> b'
01:50:12 <lambdabot>            against inferred type `Either (Either a1 (Either t b2)) b1'
01:50:12 <lambdabot>     In the first argument of `(rotate . rotate . rotate)', namely
01:50:44 <BeelsebobWork> @type let rotate f = either (Right . f) (Left . f) in (rotate id . rotate id . rotate id) (Left (Right (Left 42)))
01:50:45 <lambdabot> forall t b a. (Num t) => Either (Either a (Either t b)) (Either a (Either t b))
01:51:18 <mmorrow> , let rotate f = either (Right . f) (Left . f) in (rotate (rotate (rotate id))) (Left (Right (Left 42)))
01:51:21 <lunabot>  Right (Left (Right 42))
01:51:26 <mmorrow> hah
01:51:34 <mmorrow> great
01:54:55 <C-Keen> why does this function not return, when I call it? http://hpaste.org/11563
01:57:12 <mmorrow> , (return . vcat . fmap ppDoc =<<) . sequence . take 10 . iterate (\x->[|either (Right . $x) (Left . $x)|]) $ [|id|]
01:57:15 <lunabot>  id
01:57:15 <lunabot>  either (Right . id) (Left . id)
01:57:15 <lunabot>  either (Right . either (Right . id) (Left . id)) (Left . either (Right . ...
01:57:23 <Axman6> C-Keen: would a few purStr's in there help?
02:07:59 <C-Keen> Axman6: it hangs on the exitcode <- waitForProcess cmdhandle
02:08:21 <Axman6> did you write waitForProcess?
02:08:27 <C-Keen> but I don't see why it should. When running backtick "echo foo" it just hangs. and that should not take too long
02:08:55 <C-Keen> waitForProcess is part of System.Process
02:09:19 <C-Keen> :t System.Process.waitForProcess
02:09:20 <lambdabot> System.Process.Internals.ProcessHandle -> IO GHC.IOBase.ExitCode
02:09:29 <mmorrow> C-Keen: you've gotta do everything then call waitForProcess /last/
02:10:23 <C-Keen> mmorrow: I am using this twice in that function. why does it work on the former and hang on the latter then?
02:10:32 <mmorrow> http://hpaste.org/11563#a1
02:10:46 <mmorrow> oh, i didn't see that
02:10:49 <mmorrow> one sec
02:10:56 <Deewiant> C-Keen: what cmd are you running
02:11:16 <Deewiant> C-Keen: and actually, it could just be blocked on stdout, since hGetContents is lazy
02:11:32 <Deewiant> C-Keen: its output buffer, say 1024 bytes, fills up, and it blocks waiting for something to read it
02:11:33 <mmorrow> http://hpaste.org/11563#a2
02:11:42 <mmorrow> that should work (i think)
02:11:54 <C-Keen> Deewiant: oh ok, so mmorrow's suggestion is the solution to that then?
02:11:54 <Deewiant> mmorrow: you're using exitcode before it's bound
02:12:01 <mmorrow> grr
02:12:15 <mmorrow> http://hpaste.org/11563#a3
02:12:17 <Deewiant> C-Keen: I think the solution would be to force all of 'output'
02:13:04 <C-Keen> Deewiant: the equivalent of fflush in C?
02:13:16 <Deewiant> C-Keen: sorta, but not quite
02:13:19 <Deewiant> http://hpaste.org/11563#a4
02:13:37 <Deewiant> C-Keen: even if you fflush, the kernel might make it block, I think
02:14:21 <mmorrow> import Control.Parallel.Strategies
02:14:35 <C-Keen> ah I see the length forces the whole data to be read in output
02:14:36 <mmorrow> () <- return $! rnf bash
02:14:45 <Deewiant> adding a library dependency just for rnf is a bit pointless IMO :-P
02:14:51 <mmorrow> tis true
02:14:53 <Deewiant> C-Keen: yep
02:15:12 <Deewiant> C-Keen: be careful if you're running something like 'yes' which never stops :-P
02:16:11 <C-Keen> Deewiant: yep, I thought laziness was a plus in this case
02:16:28 <Deewiant> C-Keen: well, it can be, but you just can't call waitForProcess there
02:16:36 <Deewiant> either let the caller handle it or the GC
02:16:43 <Deewiant> not sure how well the latter works
02:16:55 <mmorrow> done <- newEmptyMVar; forkIO (evaluate (length bash) >> putMVar done ()); takeMVar done; .....
02:17:25 <mmorrow> that's kinda pointless here, but in the case where you have many things to evaluate
02:28:06 <jinjing> @bot
02:28:06 <lambdabot> :)
02:45:05 <kowey> does anybody remember what the deal with the FilePath package and ghc 6.6 was?
02:45:30 <kowey> hang on, it just occurred to me that I may be asking the wrong question
02:47:34 <quicksilver> filepath and ghc 6.6 works fine for me
02:47:36 <mmorrow> C-Keen: here a `run' that works fwiw http://hpaste.org/11564
02:48:22 <kowey> I think I was confused because darcs.net has the FilePath package (i.e. the old one with capitals FP)
02:48:30 <kowey> but the stock ghc 6.6 binary does not
02:49:02 <quicksilver> if you get the 6.6 "all bundled together" package
02:49:09 <quicksilver> i.e. the one with extralibs included
02:49:18 <quicksilver> then you get filepath-1.0
02:49:29 <quicksilver> at least that's what I have on this system here.
02:49:31 <kowey> ok! that's the one I want then
02:49:47 <kowey> i'm just downloading the binary
02:50:01 <kowey> although on the other hand, maybe just compiling ghc-6.6 + extralibs is the way to go
02:51:45 <C-Keen> mmorrow: thanks!
02:54:14 <mmorrow> C-Keen: Note that that func is concat'ing the stderr output to the stdout output, maybe modify that if something else makes more sense in your situation
02:54:56 <C-Keen> mmorrow: yes I noticed that thanks!
02:55:09 <mmorrow> also that's using runInteractiveCommand instead of ...Process, so you can use shell syntax in the first arg
02:59:32 <kowey> hmmph, I'm in the awkward position of trying to install a package while trying to keep two versions of GHC around
02:59:56 <kowey> basically, I want to keep using GHC 6.8.3 by default, but have GHC 6.6 around for some testing
03:00:35 <kowey> but I want to get the filepath package on GHC 6.6... if I install it however, Cabal tries to register the package with GHC 6.8.3
03:01:18 <quicksilver> kowey: I'm fairly sure what you want to do is possible.
03:01:22 <arjanb> what about installing the old stuff under another user?
03:01:29 <quicksilver> kowey: I know some people keep multiple versions around
03:01:34 <quicksilver> btu I'm not the person to tell you how :(
03:02:55 <kowey> quicksilver: thanks for the tips so far, anyway :-)
03:03:06 * kowey tries runghc Setup configure --package-db
03:03:44 <kowey> arjanb: hmm... that is another way to go about it ! :-) it's not really machine to add users on though (although I could in practice)
03:14:15 <kowey> success! runhaskell Setup configure -w /usr/local/stow/ghc-6.6/bin/ghc
03:14:39 <kowey> I realised of course that the version of ghc used to run Setup is completely irrelevant (duh)
03:14:57 <besiria> what is the way to find all the possible factors of a given number?
03:15:24 <quicksilver> besiria: Erm. That's somewhat offtopic ;)
03:15:50 <EvilTerran> quicksilver, add an implicit "in haskell", and it'd be on-topic again :P
03:15:57 <besiria> in haskell?
03:16:03 <besiria> :)
03:16:20 <EvilTerran> besiria, well, do you know how you'd write it in maths, say in set notation?
03:16:33 <EvilTerran> factors(n) = { ... }
03:17:38 <mmorrow> C-Keen: oops, i forgot to hClose out and err http://hpaste.org/11564#a1
03:18:00 <EvilTerran> (for some value of "...")
03:18:01 <besiria> EvilTerran: nope, i tried some naive function where it increments a number d and if (n `mod` d == 0) then it adds it to the list of divisors/factors
03:18:19 <besiria> EvilTerran: but that seems slowwwww...
03:18:43 <besiria> EvilTerran: basically, i'm trying the Problem 12 of ProjectEuler
03:19:51 <EvilTerran> besiria, well, that shouldn't be too bad; could you hpaste your code?
03:19:53 <EvilTerran> @hpaste
03:19:54 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:23:01 <C-Keen> mmorrow: in that function how would I return the exit value provided by waitForProcess? I am not familiar with exceptions in haskell yet. (What is \_ -> ? A Catchall statement?)
03:23:24 <C-Keen> (more precise: A lambda function that takes anything?
03:23:25 <C-Keen> )
03:23:33 <Baughn> C-Keen: \_ -> x == const x
03:23:50 <EvilTerran> == (let f _ = x in f)
03:25:11 <besiria> hmm i messed up hpaste, i shouldn't have been using w3m , back to firefox
03:29:25 <mmorrow> C-Keen: http://hpaste.org/11564#a2
03:30:10 <mmorrow> yeah, that's also somewhere where you may want to change it to suit your needs
03:30:37 <mmorrow> (the (\_ -> return ExitSuccess) in the case of some exception while waiting for the proc)
03:30:53 * EvilTerran looks at hpaste
03:31:13 * EvilTerran blinks
03:32:12 <besiria> EvilTerran: http://hpaste.org/11572
03:32:24 <EvilTerran> aha
03:32:59 <EvilTerran> besiria, ah, you just want a count, not a list of them?
03:33:26 <besiria> EvilTerran: y
03:35:04 <mmorrow> C-Keen: oops, s/Control.OldException/Control.Exception/ unless you're using 6.10
03:36:12 <EvilTerran> besiria, well, you can tidy things up a bit by using guards instead of if/then/else/if/then/else: http://hpaste.org/11572#a1
03:36:55 <C-Keen> mmorrow: I noticed thanks!
03:37:59 <EvilTerran> besiria, not that that's going to make it any faster, but it might make it easier to follow
03:38:11 <C-Keen> mmorrow++ :)
03:38:57 <mmorrow> :)
03:38:59 <besiria> EvilTerran: but i feel i'm doing this wrong.. it takes maybe hours to solve this problem
03:39:42 <EvilTerran> besiria, but, in terms of speed... well, you could probably speed things up substantially by only looking at numbers < the square root of the parameter instead of < half it
03:40:12 <EvilTerran> and then you could double the result, taking into account if it's a perfect square
03:41:34 <EvilTerran> besiria, also, note that division is significantly slower than multiplication; (n `div` 2 < d) would be better written (n < 2*d) anyway
03:44:19 <EvilTerran> besiria, sorry, i have to go; maybe someone else in here can help you tighten up the algorithm
03:44:22 <besiria> EvilTerran: thx i'll try your suggestions
03:44:34 <EvilTerran> but that should be enough to get you started
03:44:49 <EvilTerran> also: note that squaring is a LOT faster than taking the square-root
03:45:12 <EvilTerran> compare (i^2) and n, not i and (sqrt n)
03:46:36 <EvilTerran> avoiding sqrt also lets you avoid floating-point, which'd be asking for rounding errors, and would seem slightly gratuitous in what is fundamentally an integer-based problem
03:47:07 <quicksilver> squaring probably isn't all *that* much faster than taking sqrt on modern machines actually :)
03:47:12 <quicksilver> the integer point is more important.
03:58:12 <fatalerrorx> hmm
04:10:26 <Cale> http://www.toothpastefordinner.com/102908/homeopathy-ticket.gif -- ahahaha
04:15:12 <dolio> Zing.
04:16:29 <Cale> http://www.marriedtothesea.com/102908/this-is-a-robbery.gif -- also amusing :)
04:28:09 <nominolo|msr> has anyone her tried and succeeded in building network for 6.10.1?
04:28:20 <nominolo|msr> here*
04:28:52 <nominolo|msr> configure fails for me on windows
04:36:37 <Peaker> wow, a lot of #haskell seem to be using Windows
04:37:02 <dolio> That's because Linux totally sucks and so forth!
04:37:25 <SamB_XP> dolio: that can't be the explanation
04:37:50 <SamB_XP> I mean, it's clearly TRUE
04:38:00 <SamB_XP> but that doesn't explain the use of windows!
04:38:01 <Axman6> indeed
04:38:08 <dolio> :)
04:38:21 <Philippa> I had to RMA the last linux-based machine I had GHC on
04:38:25 <Axman6> there seems to be a large percentage using macs
04:38:29 <Philippa> admittedly due to hardware failure :-)
04:38:48 <SamB_XP> RMA ?
04:38:54 <Philippa> but between the gamers, those using Haskell at work and those at MSR in particular...
04:39:00 <Peaker> Of coruse, #haskell people must be wary of trying anything that is not clearly main stream, but still :)
04:39:04 <Philippa> SamB: return to the manufacturer
04:39:18 <SamB_XP> yes, gaming and work requirements are much more likely explanations ...
04:39:31 <Philippa> Peaker: nominolo|msr is at, well, MSR. That is, Microsoft Research. I'll let you work the rest out :-)
04:39:43 <Axman6> people who still think they need windows to do work annoy me
04:39:45 <Cale> Actually, I have the impression that there are fewer windows users than you might expect.
04:39:58 <Axman6> Cale: just more windows problems? :)
04:40:04 <Cale> Yes.
04:40:06 <Philippa> Axman6: sometimes you need it to do the work you're being paid for, however
04:40:18 <Philippa> *nod* - it's fairly likely
04:40:21 <Peaker> Philippa: I'd suppose the MSR people have enough freedom at work that few of them would actually use MS systems ;)
04:40:25 <Axman6> most things have better alternatives on other OSs
04:40:53 <SamB_XP> Peaker: you'd be surprised, I think ...
04:40:53 <Philippa> Axman6: the windows problems are as much due to *nix-centric code as anything else. And as for alternatives, that doesn't help if the contract says windows.
04:41:12 <Peaker> Philippa: I mean, MS is already bending over backwards, allowing them to do whatever they want with their time.. why would it care what OS they use?
04:41:38 <Axman6> bah, i've been using computers since i was at least 6, if not younger, i've never had a need for a PC
04:41:43 <Philippa> amongst other things, to ensure that eg GHC remains viable on windows?
04:41:47 <Philippa> Axman6: good for you
04:41:52 <SamB_XP> Peaker: now, sure, maybe they don't use Windows exclusively ...
04:41:52 <Axman6> PC == Windows comp
04:41:54 <Peaker> Axman6: Video games :(
04:41:59 <Axman6> not a gamer
04:42:43 <Axman6> a like a bit of CS, but not enough for me to want to use windows (got close to installing it on my MBP though)
04:43:00 <dolio> PC == John Hodgman
04:43:25 <Peaker> Axman6: I was totally addicted to SC for long whiles, so had dual booted Windows
04:43:29 <Axman6> that should be a datatype
04:44:03 <Axman6> whoot, new VMware fusion installed
04:44:41 <Peaker> is there any reason to use VMWare with a multitude of competitors these days, some of which are completely free?
04:45:13 <Peaker> I think VMWare has some nice scaling/hardware-migration features for enterprise-y servers, but outside of that?
04:45:56 <LarstiQ> Peaker: their tools are rather good
04:46:06 <Axman6> well, there's only parallels and virtualbox really, and VMware has much better *nix support, and it's better optimised than VB
04:46:15 <Peaker> LarstiQ: more information please :)
04:46:17 <LarstiQ> Axman6: Xen, kvm, qemu
04:46:51 <Axman6> two of the three don't work on OS X, and qemu's virtualisation doesn't work on OS X
04:46:52 <LarstiQ> Peaker: well, comparing the vmware serverconsole to the xen or kvm management scripts
04:46:55 <Axman6> afaik
04:47:30 <LarstiQ> Axman6: right, important for you, but not for me (which also disqualifies parallels for my case)
04:47:48 <Axman6> LarstiQ: ?
04:47:56 <Peaker> the need for virtualization is kinda proof that OS architectures suck
04:48:15 <LarstiQ> Peaker: ach *shrug*
04:48:28 <LarstiQ> Peaker: we're virtualizing hardware anyway
04:48:41 <lilac> the fact that virtualization is possible is kinda proof that CPU architectures are awesome
04:48:43 <Axman6> Peaker: i don't agree
04:48:54 <SamB_XP> lilac: not quite
04:49:03 <nominolo|msr> Peaker: well, MSR also has a unix machine
04:49:05 <SamB_XP> if it is efficient, THAT is
04:49:16 <Peaker> why do we need virtualization to support software migration across hardware?
04:49:20 <SamB_XP> nominolo: A unix machine ?
04:49:23 <lilac> SamB_XP: depends where you see the dividing line between virtualization and emulation, i guess
04:49:32 <nominolo|msr> yes, Fedora i think
04:50:00 <SamB_XP> er.
04:50:03 <SamB_XP> I meant to say ...
04:50:08 <nominolo|msr> but I thought, let's go with Windows, maybe I find some bugs ... well, so I did
04:50:08 <SamB_XP> nominolo: *A* unix machine ?
04:50:18 <nominolo|msr> SamB_XP: multicore, of course
04:50:27 <SamB_XP> nominolo: still!
04:51:05 <nominolo|msr> well, perhaps they have more, I don't know
04:51:20 <nominolo|msr> they build their own hardware, too, so...
04:51:40 <dolio> SamB_XP: That's practically multiple machines, if you're Oracle.
04:51:42 <SamB_XP> atom by atom ?
04:51:52 <Cale> nominolo|msr: So most people's desktop machines are running windows?
04:52:04 <Axman6> what's the deal with Oracle anyway?
04:52:13 <nominolo|msr> more like FPGA
04:52:24 <nominolo|msr> Cale: nearly every desktop machine
04:52:50 <nominolo|msr> but you can x-forward
04:53:00 <SamB_XP> I guess oracle is coming from the mainframe world, where licensing by distinct CPUs is common (I don't imagine redundant CPUs are counted towards that though ;-)
04:53:10 <Peaker> nominolo|msr: Don't people prefer to have an ssh-able/scriptable desktop?
04:53:37 <nominolo|msr> Peaker: many use cygwin or msys
04:53:52 <nominolo|msr> for hacking on GHC that's a minimum requirement
04:53:59 <Peaker> nominolo|msr: does cygwin have an ssh server?
04:54:14 <nominolo|msr> haven't checked, probably
04:54:49 <nominolo|msr> atm, cabal doesn't find my gcc, even though it's in the path and ./configure finds it
04:54:58 <nominolo|msr> veeery strange...
04:57:50 <C-Keen> what's the haskell idiom for removing a newline marker from the end of a string?
04:58:09 <quicksilver> the haskell idiom is not to have them there in the first place
04:58:14 <quicksilver> by using 'lines' to split your lines up.
04:58:31 <quicksilver> > lines "foo\nbar\nbaz\n\n"
04:58:32 <lambdabot>   ["foo","bar","baz",""]
04:59:26 <C-Keen> hm a combination of unlines.lines would do right?
04:59:35 <nominolo|msr> C-Keen: or init
04:59:49 <nominolo|msr> though, that will drop the last character no matter what
05:00:20 <lilac> takeWhile (/= '\n')
05:00:49 <nominolo|msr> > head $ lines "foo\nbar\nbaz\n\n"
05:00:51 <lambdabot>   "foo"
05:00:57 <quicksilver> C-Keen: well I'm not sure what you're trying to acheive.
05:00:59 <nominolo|msr> head > lines ""
05:01:06 <nominolo|msr> > head $ lines ""
05:01:07 <lambdabot>   "* Exception: Prelude.head: empty list
05:01:07 <quicksilver> unlines . lines will put the newlines back :P
05:01:36 <lilac> a friend points out that it's not surprising that msr have a fedora box; after all, bletchley park had an enigma machine
05:01:52 <quicksilver> ;)
05:02:59 <C-Keen> quicksilver: I want to get rid of \n in a portable way (even \r\n)
05:03:44 <quicksilver> win 13
05:03:47 <quicksilver> :(
05:03:49 <quicksilver> lose 16!
05:04:03 <quicksilver> C-Keen: You need to explain more.
05:05:28 <C-Keen> quicksilver: well I get a String containing a tailing end of line marker, because that is the output of a process read in with hGetContents, and to be able to reuse it I have to throw away the \n
05:06:21 <chr1s> hey all
05:06:43 <chr1s> I remember to have seen a way to have certain holes in your expressions and ask GHCi for the type of them.
05:06:49 <C-Keen> quicksilver: (I hope this is more comprehensible)
05:07:09 <chr1s> I think it had something to do with appending a question mark to a variable name, is that correct?
05:08:37 <dolio> ?foo
05:08:37 <lambdabot> Maybe you meant: faq ft todo yow
05:08:58 <dolio> @type concat ?foo
05:08:59 <lambdabot> forall a. (?foo::[[a]]) => [a]
05:09:06 <dolio> Those are implicit parameters.
05:09:47 <byorgey> asking ghci to infer the type of holes in your expressions seems about all that implicit parameters are good for... ;)
05:15:30 <chr1s> dolio: thanks.
05:16:13 <quicksilver> C-Keen: why are you using hGetContents? Why not hGetLine ?
05:17:37 <C-Keen> quicksilver: because most of the time I want everything, not just one line at a time. In this special case I want a line only.
05:20:35 <clogged> anyone doing computervision with haskell? i checked out easyVision, gonna install it on ubuntu later.
05:23:56 <BrokenClockwork> basis.hs:7.0: parse error (possibly incorrect indentation)
05:23:57 <BrokenClockwork> http://hpaste.org/11573
05:24:12 <BrokenClockwork> I don't get it, the dec-part works without the converse function
05:24:24 <BrokenClockwork> this must be about how I call dec in convert but I cannot find the mistake
05:24:41 <dmwit__> You've got no '=' in the fourth line.
05:24:51 <vixey> BrokenClock: Use a spell checker
05:25:09 <dmwit__> There are other errors, as vixey points out, but you should be able to find those more quickly. =)
05:26:22 <dmwit__> Actually, that just looks weird as !$*#.
05:26:32 <dmwit__> Why are you sometimes applying "li" and sometimes not?
05:26:48 <dmwit__> And why do you have two cases for b1 when they do the same thing (modulo li)?
05:27:19 <BrokenClockwork> I try to work this out :S
05:27:25 <Cale> tab alert, btw
05:27:41 <dmwit__> It looks like you're trying to make "convert" convert both ways -- i.e. into a base and out of a base.
05:27:44 <Cale> There are tabs in your file which will inevitably create problems
05:27:49 <dmwit__> I highly recommend *not* doing that.
05:28:17 <Cale> Make sure your editor is configured to replace them with spaces automatically.
05:30:20 <BrokenClockwork> ok hm
05:30:33 <BrokenClockwork> any advices for a nice text editor with colored syntax lightening?
05:30:36 <BrokenClockwork> @Haskell
05:30:36 <lambdabot> Unknown command, try @list
05:30:47 <mdmkolbe> What are the absolute restrictions on Modulenames, datatypenames and constructor names.  I.e. If I'm printing out (\x -> (dataTypeName (dataTypeOf x) ++ separator ++ showConstr (toConstr x))), what is a save separator to use?
05:31:21 <mdmkolbe> BrokenClockwork: (in no particular order) vim, emacs or yi
05:32:49 <BrokenClockwork> thx
05:32:58 <dmwit__> mdmkolbe: I believe the spec talks about Unicode character classes like isLetter and isPunctuation.
05:42:26 <mdmkolbe> yeah, it looks like it's set up that way, I just have to be carefull of "exceptions" like "[]", "->", etc.
05:43:43 <mdmkolbe> (oh, and the "." that might be in a float, heh)
05:46:20 <GNU\caust1c> what vim plugins do you use for indention?
05:47:30 <mdmkolbe> GNU\caust1c: for me, none.  I just always manually space it (it's not that bad if you only use 2 space indent).  But then again I'm not a vim power user.
05:47:50 <BrokenClockwork> :t -2
05:47:51 <lambdabot> forall a. (Num a) => a
05:48:04 <vixey> I've got this little IL I'd like a compiler for
05:48:25 <vixey> It's an untyped lazy lambda calculus with vectors
05:48:31 <BrokenClockwork> let a = -2
05:48:45 <vixey> (formal description: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=330#a330 )
05:48:46 <BrokenClockwork> then :t a = (Num a) => a
05:48:51 <ddarius> @google From Interpreter to Compiler and Virtual Machine
05:48:54 <lambdabot> http://www.brics.dk/RS/03/14/index.html
05:48:54 <lambdabot> Title: From Interpreter to Compiler and Virtual Machine: A Functional Derivation
05:55:14 <ddarius> @users
05:55:14 <lambdabot> Maximum users seen in #haskell: 547, currently: 504 (92.1%), active: 12 (2.4%)
06:06:42 <vixey> that technique is actually extremely beatiful
06:07:20 <quicksilver> vixey: yes, isn't it just.
06:07:27 <quicksilver> I'd read about it before but completely forgotten.
06:07:32 <quicksilver> A welcome reminder.
06:08:23 <quicksilver> I've not read this exacte paper. I think I must have seen one of those dudes present the ideas actually.
06:08:53 <ddarius> Here's a more comprehensive list of related papers: http://lambda-the-ultimate.org/node/2423#comment-38384
06:08:55 <lambdabot> Title: A functional correspondence between evaluators and abstract machines | Lambda th ...
06:26:30 <BrokenClockwork> mod 7 (-2) = -1 but also +1 when going the circle the other way, is it possible to tell haskell, jsut give me positive remains, beside defining a new function :)
06:26:48 <BrokenClockwork> ?*
06:26:48 <lambdabot> Maybe you meant: . ? @ v
06:26:56 <Axman6> > rem 7 (-2)
06:26:57 <lambdabot>   1
06:27:07 <Axman6> > rem 7 (-4)
06:27:08 <lambdabot>   3
06:27:13 <Axman6> > mod 7 (-4)
06:27:14 <lambdabot>   -1
06:27:24 <vixey> BrokenClockwork: My rule of thumb is, you should always always always define a new function
06:27:43 <BrokenClockwork> then that's the way I go ^^
06:28:10 <Axman6> mod' = abs.mod?
06:28:28 <BrokenClockwork> maybe
06:29:09 <mdmkolbe> vixey: I think that is very bad advice for Haskell programing given that the library is so rich
06:29:59 <xenoblitz> guys I know I asked about this yesterday but I am still stuck in a rut... its about http://www.haskell.org/gtk2hs/docs/current/Graphics-UI-Gtk-Abstract-Widget.html#v%3AonKeyPress... how can i define something similar to which is called onKeyDown which does 1 action when the key is pressed and that's it instead of repeating the same action over and over again?
06:29:59 <vixey> mdmkolbe: I'm not keen on the library since it prefers stuff like length :: [a] -> Int over [a] -> Integer
06:30:01 <lambdabot> Title: Graphics.UI.Gtk.Abstract.Widget, http://tinyurl.com/5h3e9d
06:30:31 <Philippa> vixey: ISTR there's a genericLength
06:31:40 <mdmkolbe> @hoogle [a] -> Integer
06:31:40 <lambdabot> Prelude head :: [a] -> a
06:31:40 <lambdabot> Prelude last :: [a] -> a
06:31:40 <lambdabot> Data.List head :: [a] -> a
06:31:47 <mdmkolbe> heh
06:32:09 <quicksilver> ddarius: reynolds = win!
06:32:43 <Axman6> @instances Integral
06:32:43 <lambdabot> Int, Integer
06:34:14 <Cale> xenoblitz: I wonder if dcoutts_ would know.
06:34:33 <sbahra> mdmkolbe, what are you looking for?
06:34:45 <int-e> @instances-importing Data.Word Data.Int Integral
06:34:45 <lambdabot> Int, Int16, Int32, Int64, Int8, Integer, Word, Word16, Word32, Word64, Word8
06:35:05 <mdmkolbe> @type genericLength
06:35:06 <lambdabot> forall b i. (Num i) => [b] -> i
06:35:31 <Cale> xenoblitz: I get the impression that X just sends lots of events if repeatkeys is on.
06:35:42 <mdmkolbe> sbahra: a length function that uses Integral instead of Int (in responce to vixey)
06:35:43 <Cale> xenoblitz: which would make things tough
06:36:03 <xenoblitz> Cale: yes... i just want to find a way to only register the first keypress... sort of onKeyDown and that's it
06:36:26 <xenoblitz> Cale: but its something beyond me at my current knowledge of Haskell
06:36:31 <Cale> xenoblitz: what events are you seeing?
06:36:39 <camio> If there's a ghc ticket that's very important to me that gets fixed, is there anything I can do besides waiting or getting into the ghc code?
06:36:47 <Cale> Do you get a key up event for every key down?
06:37:23 <Cale> camio: Subscribe to the ticket, for one.
06:37:27 <xenoblitz> Cale: no what happens is that if I use onKeyPressed... and a user just holds the key down, the action combined with that event keeps happing again and again
06:37:39 <mdmkolbe> sbahra, vixey: hmm, I wonder if it is possible to have a list with a length longer than the range of "Int" without running out of address space
06:37:43 <mdmkolbe> @src length
06:37:43 <lambdabot> Source not found. :(
06:37:56 <mdmkolbe> @source Prelude
06:37:57 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
06:37:58 <ddarius> mdmkolbe: It can't actually be realized all at the same time, but otherwise, yes.
06:38:09 <Cale> camio: and maybe try sending a message to the ghc-users list.
06:38:36 <xenoblitz> Cale: so its like onKeyDown, onKeyDown, onKeyDown, onKeyDown, onKeyUp (user stops hitting key)
06:38:42 <ddarius> mdmkolbe: E.g. length [1..2^128]
06:39:17 <xenoblitz> Cale: I know the others said its possible to write a wrapper onKeyDown but I have no idea where to start banging my head
06:39:19 <Cale> xenoblitz: Ah, so that makes it possible then. You just need to have an IORef with a Data.Set of keys which are currently pressed (you've got a KeyDown but no KeyUp yet)
06:40:07 * mdmkolbe tries it
06:40:12 <camio> Cale: How do I subscribe to the ticket? Add myself to the CC?
06:40:35 <Cale> In your onKeyDown event handler, you check and see if the key is already in the set, and if not, add the key to the set and handle the event as usual. If it is, do nothing. When the key is released, remove it from the set.
06:40:42 <ddarius> mdmkolbe: That particular example would take quite a while to execute, but should use constant memory while doing so.
06:40:50 <Cale> camio: yeah
06:41:36 <Cale> camio: which bug, btw?
06:41:41 <xenoblitz> Cale: *sigh*... I'll "try" but really its strange that such functionality was left out... thanks though
06:41:48 <camio> http://hackage.haskell.org/trac/ghc/ticket/2189
06:41:50 <lambdabot> Title: #2189 (hSetBuffer stdin NoBuffering doesn't seem to work in ghc 6.8.2 on Windows ...
06:42:02 <Cale> xenoblitz: It's possible that there's a better way.
06:42:16 <mdmkolbe> ddarius: yeah, I'm only doing 2^33
06:43:03 <Cale> xenoblitz: But generally, X apps have this problem. I've run into games where the controls were a bit sticky until I did 'xset r off'
06:43:19 <mdmkolbe> it's still running
06:43:32 <ddarius> genericLength may not have appropriate strictness, so you may have to write your own length function.
06:43:52 * mdmkolbe is thankfull for dual cores (one to peg at 100%, one to do real stuff on)
06:44:23 <xenoblitz> Cale: I just want some keys in my game to behave with repeat and some not to do so
06:45:01 <Philippa> do you mean repeat, or just "notice if it's down each frame"?
06:46:34 <xenoblitz> Philippa: if you combined onKeyPressed with a key and press said key, the action combined with that event is triggered again and again until you stop hitting the key... now I don't want such behaviour to happen on all keys... some keys should be pressed again and again...
06:46:59 <Peaker> unenough: hey
06:47:05 <Peaker> xenoblitz: most libraries will tell you when key down and when key up
06:47:11 <unenough> ho!
06:47:13 <unenough> sup
06:47:20 <Philippa> so keep track of all three messages and work from there
06:47:20 <Peaker> xenoblitz: you can combine that with timer events to repeat if you'd like
06:47:44 <quicksilver> Peaker: he's using GTK
06:47:57 <quicksilver> Peaker: the convention in X11 is that X handles key repeat
06:47:59 <quicksilver> not the client app
06:48:03 <Peaker> surely Gtk+ has these events, if you're implementing your own widget?
06:48:09 <quicksilver> so you're supposed to respect the key repeats X gives you
06:48:10 <Philippa> ah, if GTK won't give you key-down/up info then you're pretty much screwed
06:48:11 <Peaker> quicksilver: still, SDL over X11 has keydown/keyup
06:48:20 <quicksilver> and not try to re-implement a basic feature.
06:48:28 <Philippa> quicksilver: this doesn't work when the model isn't character input, though
06:48:35 <quicksilver> Peaker: SDL probably does its own low level input handling.
06:48:44 <quicksilver> Philippa: Indeed. Just repeating the party line for clarity.
06:48:47 <Philippa> yes. This problem requires it, apparently
06:48:49 <mdmkolbe> quicksilver: does X inform you that a key signal is a repeat or do you just have to recognize that Down, Down, Down has two repeats?
06:48:50 <quicksilver> not to suggest it doesn't have limitations.
06:48:55 <Cale> camio: btw, I'm not sure about this, but I think the cc field is supposed to have email addresses in it.
06:49:08 <Cale> (though, maybe usernames also work)
06:49:35 <quicksilver> if you wish to play with this at home, just type 'xev' into an X window ;)
06:49:54 <xenoblitz> quicksilver: I'm on a windows platform right now
06:49:59 <ToRA|MSR> gtk2hs lets you subscribe to onKeyEvent :: (Event -> IO Bool) -> IO Signal.  The event tells you what key was pressed and if it was a press or release.
06:50:14 <quicksilver> ToRA|MSR: that doesn't solve the repeat problem though.
06:50:23 <ToRA|MSR> with the invariant that if key repeat has happened at the wm layer, you'll get a stream of down -> down -> down -> down -> up signals
06:50:24 <quicksilver> ToRA|MSR: that just give you a single interface to press/release instead of two.
06:50:30 * quicksilver nods
06:50:37 <quicksilver> yes.
06:50:45 <ToRA|MSR> quicksilver: indeed you have to write a small wrapper to get that behaviour with ioref set or something else as described
06:51:12 <ivanm> @seen TSC
06:51:13 <lambdabot> TSC is in #haskell-blah, #xmonad and #haskell. I last heard TSC speak 4h 53m 37s ago.
06:51:17 <ToRA|MSR> but since you're writing that wrapper, you can selectively choose which keyboard-keys go into that set, and which you just do the repeat behaviour with
06:51:30 <BeelsebobWork_> Has anyone had any success with compiling alex on ghc 6.10/11?
06:51:45 <ivanm> @tell TSC I've put the slides from my honours talk mentioning Haskell on my blog... should be going up on planet whenever they next do an aggregation
06:51:45 <lambdabot> Consider it noted.
06:51:47 <quicksilver> actually my testing with "xev" does give release events for repeated keys.
06:51:57 <quicksilver> I don't have time to knock up a gtk test to compare that.
06:52:02 <ToRA|MSR> quicksilver: gtk adds that invariant afaict
06:52:48 <xenoblitz> I feel like I'm in a lecture where the lecturer keeps talking, and I know that he/she is speaking my language but the jargon is not being registered
06:52:52 <ToRA|MSR> and even if it didn't i imagine you'd get in one event loop both an up and a down
06:53:25 <quicksilver> the SDL changelog, interestingly, has "0.9.13: Finally able to detect X11 key repeat (thanks GII team!) "
06:53:35 <quicksilver> so it was presumably tricky for teh SDL team to solve this too.
06:53:36 <ToRA|MSR> xenoblitz: where does the solution stop making sense?
06:54:05 <ToRA|MSR> quicksilver: for most gtk apps, i imagine that key repeat is the right thing (navigating trees, text etc.)
06:54:09 <xenoblitz> ToRA|MSR: so lets see... i have to write a function which registers to onKeyEvent
06:54:24 <xenoblitz> in this function I have to save the variable in IORef
06:54:41 <ToRA|MSR> erm
06:54:56 <xenoblitz> no eh?
06:55:02 <ToRA|MSR> so youre handler would be :: IORef (Set Key) -> Event -> IO Bool ?
06:55:28 <ToRA|MSR> yes/no?
06:56:06 <xenoblitz> ToRA|MSR: to be honest, I don't know
06:56:22 <ToRA|MSR> ok
06:56:28 <ToRA|MSR> that's what i think it would be
06:57:21 <ToRA|MSR> erm, can you see why?
06:58:29 <xenoblitz> ToRA|MSR: yeah but its all vague... I am not familiar with IORefs and Events much...
06:58:42 <ToRA|MSR> ok, event is just a data type in gtk2hs
06:58:58 <xenoblitz> ok
06:59:52 <xenoblitz> from what I have read events are of type, Key, Button and so on
07:00:32 <ToRA|MSR> xenoblitz: http://haskell.org/gtk2hs/docs/gtk2hs-docs-0.9.10/Graphics-UI-Gtk-Abstract-Widget.html#v%3AonKeyPress
07:00:34 <lambdabot> Title: Graphics.UI.Gtk.Abstract.Widget, http://tinyurl.com/6jwwv5
07:00:58 <ToRA|MSR> so that's the docs for onKeyPress, and you should be able to click through to see how Event is defined
07:01:47 <xenoblitz> yes i know it has Event/Expose/Motion/Button/Key
07:01:51 <xenoblitz> and so on
07:02:14 <lilac> > runST $ do x <- newSTRef 0; r <- newSTRef []; let loop = do v <- readSTRef x; if v < 10 then modifySTRef r (v:) >> modifySTRef x (1+) >> loop else return () in loop; readSTRef r
07:02:15 <lambdabot>   /tmp/858552855904400407:69:48: Not in scope: `runST'/tmp/858552855904400407...
07:02:33 <vixey> does that actually work
07:02:59 <vixey> cool it does
07:03:01 <lilac> yep. it's about the most horrible haskell code i ever wrote :)
07:03:11 <vixey> I expected that you must rewrite it as runST (do ...)
07:03:11 <Axman6> heh
07:03:14 <vixey> but you don't
07:04:09 <lilac> i wonder how much slower that is than [9,8..0]
07:04:26 <vixey> ♪ runST $ do x <- newSTRef 0; r <- newSTRef []; let loop = do v <- readSTRef x; if v < 10 then modifySTRef r (v:) >> modifySTRef x (1+) >> loop else return () in loop; readSTRef r
07:04:32 <lunabot>  luna: Not in scope: `runST'
07:04:53 <vixey> :(
07:06:54 <Axman6> bah, i hate how i can view unicode fine in irssi/terminal.app, it just screws up other parts of irssi, like putting text from other chans in here
07:15:59 * alar wonders where's tuomov
07:18:30 <arjanb> not in this channel anymore..
07:19:21 <ilyak> Axman6: Works fine for me
07:19:24 <ilyak> irssi/konsole
07:24:10 <mdmkolbe> @src gshow
07:24:11 <lambdabot> Source not found. You speak an infinite deal of nothing
07:24:13 <mdmkolbe> @source gshow
07:24:14 <lambdabot> gshow not available
07:24:29 <mdmkolbe> @source length
07:24:29 <lambdabot> length not available
07:24:30 <Cale> alar: He essentially forced me to ban him.
07:24:52 <mdmkolbe> @source Data.Generics.Text
07:24:52 <lambdabot> http://darcs.haskell.org/packages/base/Data/Generics/Text.hs
07:24:58 <LarstiQ> the ion tuomov?
07:25:04 <Cale> yeah
07:25:09 * alar wonder whether tuomov repents this
07:25:25 <LarstiQ> Cale: sadly, I'm not surprised
07:25:52 <mdmkolbe> umm, where would I find the source for Data.Genrics.Text?  It's not at the place lambdabot claims.
07:26:09 <BrokenClockwork> what's the command to reverse a number's sign?
07:26:18 <lilac> negate
07:26:34 <Cale> mdmkolbe: Go here: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics-Text.html and click the "Source code" link at the top
07:26:35 <BrokenClockwork> thx
07:26:36 <lambdabot> Title: Data.Generics.Text, http://tinyurl.com/6fchqh
07:26:46 <Cale> BrokenClockwork: or just unary -
07:27:13 <mdmkolbe> Cale: thx
07:27:35 <mdmkolbe> Cale: there is no unary - function
07:27:40 <mdmkolbe> :t (-)
07:27:41 <lambdabot> forall a. (Num a) => a -> a -> a
07:27:54 <Cale> > let x = 5 in -x
07:27:55 <lambdabot>   -5
07:28:24 * mdmkolbe 's mind is blown
07:29:45 <mdmkolbe> Cale: so is that unary - just a syntactic level thing that gets translated to negate by the parser? (e.g. the way quote is treated in scheme)
07:30:26 <quicksilver> it's translated in the lexer
07:30:28 <quicksilver> I think.
07:30:28 <Cale> yes
07:30:37 <quicksilver> it's a foul rotten hack :(
07:30:40 <Cale> By the lexer?
07:30:46 <wjt> ban negative numbers!
07:30:49 <Cale> I'm not sure it happens that early.
07:31:02 <Cale> I like the fact that unary minus works correctly.
07:31:03 <LarstiQ> wjt: they're not proper 4 corners? :)
07:31:03 <mdmkolbe> quicksilver: should be parser not lexer (otherwise context gets hairy0
07:31:21 <quicksilver> no, you're right, it's the parser
07:31:26 <quicksilver> but it's "early" in the parser
07:31:31 <quicksilver> in some informal sense of early
07:31:45 <vixey> the real solution is to make '-' a character
07:32:12 <mdmkolbe> quicksilver: no, no, no, we don't want to use an Earley parser (j/k)
07:33:21 <quicksilver> vixey: and then lose the ability to use it in a binary way?
07:35:09 <Cale> Sometimes conceptual elegance is forfeited in small ways to make things more readable, and I think that's a good thing.
07:35:49 <Cale> For example, the existence of if/then/else syntax could also be viewed as unnecessary, but it's nice for certain cases.
07:36:27 <Cale> (Despite adding 3 keywords to the syntax)
07:37:20 <dolio> if/then/else strikes me as somewhat less evil than the situation with -.
07:37:25 <dolio> But maybe that's just me.
07:37:38 <vixey> hm.. I don't think if then else is nice
07:37:56 <vixey> I guess we are used to if then else in programming but I prefer bool
07:38:10 <Cale> We also have case
07:38:23 <Cale> Which could be viewed as equivalent.
07:38:33 <BeelsebobWork_> in attempting to build alex, I get     Module `Distribution.Simple.Setup' does not export `buildVerbose'.  Anyone met that before?
07:39:09 <Cale> (when restricted to the Bool type)
07:39:22 <Cale> BeelsebobWork_: hmm, Cabal version problem?
07:39:31 <BeelsebobWork_> I guess so, but I have no idea what's changed
07:39:37 <BeelsebobWork_> trying to build with Cabal 1.5.5
07:39:44 <dcoutts_> BeelsebobWork_: I thought the latest release worked with cabal-1.6
07:39:56 <BeelsebobWork_> that's a darcs get -- the hackage version gives the same error
07:40:07 <BeelsebobWork_> oh, there's cabal 1.6?  Where did I miss that?
07:40:08 <dcoutts_> BeelsebobWork_: alex was indeed one of the few that broke with cabal-1.6
07:40:18 <dcoutts_> oh yeah, I should announce it :-)
07:40:27 <BeelsebobWork_> :D
07:40:45 <BeelsebobWork_> so if I upgrade 1.5.5 to 1.6 it might start building, or will it continue to be broken?
07:41:02 <dolio> > - x `mod` y
07:41:03 <lambdabot>   negate (x `mod` y)
07:41:15 <dcoutts_> BeelsebobWork_: it'll work actually, I think
07:41:30 <vixey> is that normal
07:41:34 <BeelsebobWork_> cheers dcoutts_, I'll poke you again if it dies
07:41:48 <vixey> \m n ~~> {n/0}m
07:41:51 <dcoutts_> BeelsebobWork_: cabal-1.6 contains a compat fix that alex uses to work with multiple cabal versions
07:42:02 <vixey> describing beta reduction on de bruijn terms
07:42:13 <vixey> it's seems pretty strange putting '0' there ..
07:42:21 <dcoutts_> BeelsebobWork_: so the latest alex should work with any released cabal version, but not 1.5
07:43:11 <dolio> Seems analogous to n[x/m] for named variables.
07:43:33 <dolio> 0 is what you'll actually see in the term in lieu of a variable name.
07:43:56 <dolio> Well, not really, but whatever. :)
07:44:00 <BeelsebobWork_> dcoutts_: working, thanks :)
07:44:05 <dcoutts_> great
07:44:16 <BeelsebobWork_> although now I get a compile error, but not your problem :(
07:44:40 <BeelsebobWork_> anyone seen this one? http://hpaste.org/11575
07:45:02 <xenoblitz> guys, am trying to write a simple event handler so I can read when a key is Up or Down, (so that eventually I'll write what I need, that is onKeyDown/onKeyUp event handler using IORef) ... this is as far as I got: http://hpaste.org/11574 any tips on what the next step forward would be?
07:45:08 <dcoutts_> BeelsebobWork_: you want to build it against base 3 not 4
07:45:28 <BeelsebobWork_> ah, cheers again dcoutts_ -- fiddle alex's cabal file to specify that, or is there a simpler way?
07:45:45 <dcoutts_> BeelsebobWork_: yep, or configure --constraint='base < 4'
07:45:52 <dcoutts_> or cabal install will do that automatically
07:45:59 <dcoutts_> cabal configure is less smart atm
07:47:20 <Cale> xenoblitz: make an IORef from main and pass it into the event handlers
07:47:52 <Cale> xenoblitz: you'll probably want to import qualified Data.Set as Set; import Data.Set (Set)
07:47:56 <xenoblitz> Cale: I want to take this step at a time... any ideas on how to detect up and down keys?
07:48:12 <Cale> xenoblitz: Well, check what the eventKeyName is :)
07:48:15 <xenoblitz> Cale: what you said is of course noted :)
07:48:41 <Cale> xenoblitz: You mean the arrow keys, right?
07:49:02 <xenoblitz> Cale: ah ok just a sec :)
07:49:41 <xenoblitz> Cale: i wish to find a way to know say... "A" key down, "A" key up
07:49:49 <Cale> right
07:49:58 <Cale> That's more along the lines of what I thought
07:50:03 <quicksilver> dcoutts_: how do you set up two totally independent cabal ecosystems as the same user? E.g. for two different major GHC versions
07:50:36 <Cale> So you want something like  keys <- newIORef (Set.empty)  in main, and then pass that along to your onKeyPress and onKeyRelease handlers.
07:50:43 <dcoutts_> quicksilver: that's automatic for ghc versions
07:51:20 <Cale> The press handler is going to add things to the set, and the release handler is going to remove them.
07:51:29 <xenoblitz> Cale: yes ok but let me take this a step backwards: so to print key up and key down I still need to use onKeyPress and onKeyRelease?
07:52:02 <Cale> xenoblitz: Yeah. We're just going to filter the events a bit by keeping track of when the key is already pressed.
07:52:14 <xenoblitz> ok let me code as far as that
07:52:22 <Cale> (the problem is that you're getting too many press events, yeah?)
07:52:30 <xenoblitz> then i go to the IORef and Set thingy you said
07:52:31 <xenoblitz> yes
07:52:33 <xenoblitz> that's it
07:53:23 <xenoblitz> i'm a bit slow :P sorry
07:55:37 <Cale> xenoblitz: quite all right :)
07:55:50 <Cale> I'll be right back.
07:56:24 <quicksilver> dcoutts_: ORLY? that's clever.
07:56:40 <quicksilver> dcoutts_: when running Setup.hs how do I tell it which one to use?
07:57:24 <Saizan_> quicksilver: -w ghc-x.y where ghc-x.y is the versioned executable
07:58:27 <dcoutts_> quicksilver: --with-compiler or just -w and either a full path or a name of an exe that is on the path
07:58:43 <dcoutts_> so yes, usually just -w ghc-6.8.2 or whatever
07:58:46 <xenoblitz> Cale: http://hpaste.org/11574#a1 is as far as I got now... I guess now I have to add IORef and Set
07:59:25 <dcoutts_> quicksilver: I've got 4 ghc versions installed so I can test like: for ghc in ghc-6.4.2 ghc-6.6.1 ghc-6.8.2 ghc; do cabal clean && cabal install -w $ghc; done
08:01:29 <quicksilver> dcoutts_: cool.
08:01:31 <quicksilver> thanks :)
08:06:08 <Boney> I have a maths notation question.  I want to describe a recursive function with a base case in mathematical notation.
08:06:24 <Boney> I want to write something like:
08:06:29 <Boney> f(0) = ...
08:06:59 <Boney> f(d) = d > 0 | ... + f(d-1)
08:07:29 <vixey> usually you put | d > 0 to the right of the equation
08:07:33 <Boney> do people write such things using guards?
08:07:38 <vixey> yes
08:07:41 <Boney> ah,
08:07:41 <Cale> Or just write "otherwise"
08:07:48 <Cale> f(0) = ...
08:07:55 <Cale> f(d) = ... + f(d-1)  otherwise
08:07:56 <Boney> f(d) = ... + f(d-1) | d > 0
08:08:17 <vixey> f(d+1) = ... + f(d) works too
08:08:17 <Cale> It's perfectly acceptable to use English words to describe what you mean :)
08:08:24 <Boney> well d<0 is illegal.
08:08:48 <Cale> f: N -> N -- perhaps :)
08:09:10 <Cale> It's generally good practice to say what the domain and codomain of functions are.
08:09:29 <Boney> thanks guys, this is quite helpful.
08:09:34 <Cale> If it's obvious, you can leave it out though.
08:09:37 <xenoblitz> Cale: just a question... why do I need a Set? isn't an IORef of String enough?
08:09:47 <Boney> Cale: I think it's obvious from my semantics.
08:09:54 <Cale> xenoblitz: Well, because there can me more than one key pressed.
08:10:09 <xenoblitz> ah at the same time of course, silly me
08:10:28 <BMeph> What's the difference between the range and the codomain, and why is there a difference?
08:10:40 <RayNbow> Boney, I usually write recursive functions using this style: http://upload.wikimedia.org/math/7/6/f/76f99713cf111eb035d908228c351710.png
08:10:42 <lambdabot> http://tinyurl.com/65olmf
08:10:45 <xenoblitz> Cale: I'll try adding it for String than read about Set :)
08:10:48 <quicksilver> the codomain is the type of the destination
08:10:54 <quicksilver> the range is the part it actually covers
08:10:58 <RayNbow> except that the example I just pasted isn't a function :p
08:11:10 <quicksilver> (const 0) :: Int -> Int has codomain 'Int' but range {0}
08:11:14 <quicksilver> BMeph: clear?
08:11:36 <Cale> BMeph: If A and B are sets, then a function f: A -> B is a set of pairs (a,b) with a in A and b in B such that for each a in A, there is exactly one b in B for which (a,b) is in f. In that case we write f(a) = b. The set A is called the domain of f, and B is called the codomain.\
08:11:54 <Cale> The range of f is the set of b in B for which there exists some a in A such that f(a) = b.
08:12:12 <quicksilver> so the range is a subset of the domain
08:12:19 <Cale> For example, there is a function f: R -> R such that for each x in R, we have f(x) = x^2
08:12:25 <quicksilver> any funciton can be thought of as being a function onto its range
08:12:31 <Cale> Its codomain is R, but its range is the set of nonnegative reals.
08:12:33 <quicksilver> and, thought of that way, it is indeed "onto".
08:12:38 <quicksilver> in the technical sense of "onto"
08:13:10 <BMeph> quicksilver: Somewhat. What about when the range is a "recognized" subset/subtype (e.g., the naturals or positive ints), do you still call the codo Z, or what?
08:13:16 <Cale> A function in general, is a triple (A,B,f) where f is a function A -> B
08:13:39 <Cale> BMeph: yes.
08:13:55 <Cale> BMeph: The codomain isn't determined by the graph of the function, it must be specified.
08:14:30 <BMeph> quicksilver: Thanks, that makes sense.
08:14:56 <Cale> quicksilver: you mean 'subset of the codomain' of course
08:15:06 <BMeph> Cale: So, is it arbitrary in my last specified case?
08:15:41 <quicksilver> sorry.
08:15:53 <Cale> BMeph: Well, in order to say which function you're talking about, you have to tell me what the domain, codomain, and graph of the function are. If you're being quick, you can leave out the domain, and I can determine it from the graph (the set of pairs)
08:15:53 <quicksilver> BMeph: you can choose the codomain.
08:15:53 <Boney> RayNbow: Looks good, I'm happy so long as what I've written is legible and clear.
08:16:11 <quicksilver> this is one of the contributions of category theory
08:16:14 <Cale> BMeph: But if you leave out the codomain, it could be any set which contains the range...
08:16:16 <quicksilver> (although a rather minor one)
08:16:21 <nominolo|msr> @seen tibbe
08:16:21 <lambdabot> tibbe is in #ghc, #haskell and #xmonad. I don't know when tibbe last spoke.
08:16:26 <opqdonut> f:A->B is just syntactic sugar for that (A,B,f)
08:16:31 <quicksilver> in CT you *must* specify codomains explicitly.
08:16:33 <Cale> BMeph: which means that your function is somewhat ambiguously specified)
08:16:38 <quicksilver> in pre-CT mathematics you often' wouldn't bother
08:16:46 <quicksilver> it would either be obvious, or there would be a few obvious choices
08:16:53 <Samy> Is there a package that comes recommended for sending e-mail? (SMTP)
08:17:04 <Boney> err. I mean acceptable (peer-review etc) and clear.
08:17:50 <vixey> opqdonut: in set theory?
08:17:55 <tibbe> nominolo|msr: ping
08:18:02 <Cale> BMeph: Note that equations that a function might satisfy, as people will often do in highschool, like f(x) = x^2, is not really enough to determine a function either. You need to say what the domain and codomain are there in order to have a function.
08:18:03 <vixey> oh category theroy
08:18:32 <Cale> (It really bothers me when they ask students to determine the domain of a 'function' specified like that.)
08:19:04 <opqdonut> (yeah, they should be asking about the maximal real domain or something like that ;)
08:19:06 <BMeph> Cale, quicksilver: Hmm, interesting. I guess CT explains where and why the codomain/range dichotomy became so noted.
08:19:32 <Peaker> Cale: IANACT but I think in high school they just assume that the complex numbers are the possible inputs and outputs of all functions?
08:19:34 <xenoblitz> Cale: is this on the right track? http://hpaste.org/11574#a2
08:19:35 <Cale> BMeph: Well, also, you can't even properly define the term 'surjective' until you're willing to admit there's a distinction.
08:19:56 <vixey> surjective vs monomorphic?
08:19:59 <Cale> Peaker: Something like that. Usually not even the complex numbers.
08:20:03 <vixey> epimorphic
08:20:21 <BMeph> Cale: Yes, that makes sense. Especially your peeve, since they usually introduce complex numbers in the middle of that, which can really change the graph entirely.
08:22:05 <ToRA|MSR> xenoblitz: why are you doing \Key { ... } -> and not just making it an argument directly ( foo ioref (Key { ... } ) = ... )?  also have a look at when in Control.Monad (it's a better way of writing if blah then blah else return ())
08:22:42 <ToRA|MSR> but other than that, the logic looks good afaict
08:25:54 <xenoblitz> ToRA|MSR: :t when
08:25:54 <Cale> xenoblitz: http://hpaste.org/11574#a3
08:26:03 <xenoblitz> oops
08:26:05 <Cale> xenoblitz: (I haven't tested that)
08:26:07 <xenoblitz> :t when
08:26:08 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
08:26:36 <Cale> oh, there's a small mistake
08:26:40 <quicksilver> Cale: (... only proved it correct?)
08:26:44 <Cale> There are some k's which should be key
08:27:01 <Cale> (or vice versa)
08:27:59 <ToRA|MSR> e.g. when (val == "") (print "in")
08:28:13 <vixey> null val
08:28:16 <ToRA|MSR> there's also unless
08:28:21 <xenoblitz> ToRA|MSR: I fixed the whens
08:28:30 <xenoblitz> ToRA|MSR: i mean i added them
08:28:45 <xenoblitz> now about the argument instead of \Key...
08:29:00 <xenoblitz> Cale: I'll check out your annotation soon :)
08:29:22 <ToRA|MSR> if  foo :: a -> (b -> c), it's the same as it being :: a -> b -> c
08:29:31 <ToRA|MSR> if that's causing confusion
08:29:47 <xenoblitz> so you mean I can just remove the brackets
08:29:48 <xenoblitz> that's it?
08:30:00 <ToRA|MSR> and you can write e.g.
08:30:15 <ToRA|MSR> myKeyPressEvent ioref (Key { blah = blah }) = do
08:30:17 <ToRA|MSR> instead of
08:30:35 <ToRA|MSR> myKeyPressEvent ioref = \Key { ... } = do
08:30:50 <ToRA|MSR> sorry -> do at the end there
08:31:13 <vixey> wtf     Could not find module `Data.Time':
08:31:32 <xenoblitz> ToRA|MSR: oh i c what you mean... however may I ask what's with this { } notation
08:31:45 <xenoblitz> ToRA|MSR: i know i've seen it somewhere but its confusing me :/
08:32:01 <ToRA|MSR> record syntax
08:32:33 <ToRA|MSR> anybody got a good link for explaining it?
08:33:26 <xenoblitz> ok no worries ToRA|MSR, I'll look it up myself later
08:33:45 <BMeph> Cale? Have a wiki page for record syntax? :)
08:34:22 <Cale> hmm
08:34:52 <quicksilver> xenoblitz: are you happy with data Point = Pt Int Int, for exampole?
08:34:59 <xenoblitz> ToRA|MSR: http://hpaste.org/11574#a5 is what I got after your suggestions... I'll try to add Cale's stuff regarding the Set suggestion
08:35:16 <Cale> http://hpaste.org/11574#a6
08:35:17 <xenoblitz> quicksilver: yes
08:35:34 <quicksilver> xenoblitz: well record syntax would be data Point = Pt { x :: Int, y :: Int }
08:35:44 <quicksilver> xenoblitz: you could still write (Pt 0 0) exactly as before
08:35:56 <quicksilver> xenoblitz: but you can also now write Pt { x=0, y=0 }
08:36:11 <quicksilver> xenoblitz: and you get various other shortcuts
08:36:18 <quicksilver> xenoblitz: "x" itself is a function Point -> Int
08:36:22 <quicksilver> for 'getting' the x coordinate
08:36:29 <quicksilver> and you can update one coordinate only, like this:
08:36:33 <quicksilver> p { y = 5 }
08:36:37 <xenoblitz> quicksilver: ah wait you get ... boilerplate constructor was it???
08:36:43 <quicksilver> ... the same point as p, but with the y bit changed.
08:36:52 <quicksilver> You get a bunch of bits of boilerplate for free, yeah.
08:36:55 <xenoblitz> oh its like class get/set in OOP
08:37:06 <quicksilver> well remember it's not really mutation
08:37:14 <xenoblitz> xenoblitz: yes its a new item altogether
08:37:19 <quicksilver> it's returning a *new* point, which is the same as the old one, except
08:37:19 <xenoblitz> oops
08:37:19 <xenoblitz> xD
08:37:20 <quicksilver> yes.
08:37:21 <xenoblitz> omg hehe
08:37:26 <ToRA|MSR> i'd change the when (not ..) to unless ( ..), but other than that it looks fine
08:37:33 <quicksilver> it's a bit limited to be honest (record syntax)
08:37:40 <quicksilver> there are some things you want to say you can't say
08:37:45 <quicksilver> but it is helpful in some ways
08:37:58 <quicksilver> mainly to help you manage datas with many many fields.
08:37:59 <xenoblitz> quicksilver: I prefer the old-fashioned way... its more readable to me
08:39:57 <xenoblitz> Cale: adding in your stuff about sets :)
08:47:06 <xenoblitz> quicksilver, anyone else who knows record syntax: so if I have foo (Key { eventKeyName = key } ) are you binding actually to that "key" "variable-name"
08:47:26 <xenoblitz> i.e. you can pattern match using such a way right?
08:49:18 <dolio> @type f (State { foo = runState }) = foo
08:49:19 <lambdabot> parse error on input `='
08:49:39 <dolio> @type let f (State { foo = runState }) = foo in f
08:49:41 <lambdabot> Not in scope: `foo'
08:49:41 <lambdabot> Not in scope: `foo'
08:49:52 <dolio> @type let f (State { runState = foo }) = foo in f
08:49:53 <lambdabot> forall t t1. State t t1 -> t -> (t1, t)
08:52:17 <Saizan_> xenoblitz: yeah, key there is a fresh variable which takes the value of the eventKeyName field
08:52:18 <quicksilver> xenoblitz: yes it means subtly different things in pattern position to value position.
08:52:34 <quicksilver> in my easier to type example
08:52:42 <quicksilver> f (Pt { x = b }) = ....
08:52:53 <quicksilver> b is a fresh variable, bound to the x value of the given parameter
08:54:31 <xenoblitz> quicksilver: as such the other variable y is not pattern matched and is assumed to be _
08:54:48 <xenoblitz> f (Pt b _)
08:54:51 <xenoblitz> would be equivalent right?
08:55:03 <quicksilver> precisely.
08:55:15 <xenoblitz> quicksilver: awesome thanks
08:55:30 <xenoblitz> Saizan_: thanks as well :)
08:58:52 <xenoblitz> thanks to all you guys: http://hpaste.org/11574#a7 ... I really appreciate your help
09:12:05 * xenoblitz slaps xenoblitz around a bit with a large trout
09:12:41 <vixey> :t digitToInt
09:12:42 <lambdabot> Char -> Int
09:12:57 <vixey> > digitToInt 'x'
09:12:59 <lambdabot>   * Exception: Char.digitToInt: not a digit 'x'
09:13:03 <vixey> wonderful.................
09:13:52 <vixey> @src digitToIn
09:13:52 <vixey> @src digitToInt
09:13:53 <lambdabot> Source not found. I've seen penguins that can type better than that.
09:13:53 <lambdabot> Source not found.
09:14:40 <Deewiant> heh
09:14:43 <Deewiant>  | otherwise            =  error ("Char.digitToInt: not a digit " ++ show c) -- sigh
09:14:47 <Deewiant> gotta love that comment
09:16:43 <ttt--> why the sigh?
09:16:52 <vixey> digitToInt '0' = Just 0
09:16:52 <vixey> digitToInt '1' = Just 1
09:16:53 <vixey> ...
09:16:57 <vixey> digitToInt _ = Nothing
09:17:00 <vixey> is rather more useful
09:17:08 <ttt--> i see
09:17:12 <vixey> viz. liftM2 (,) (digitToInt m) (digitToInt n)
09:17:20 <vixey> as opposed to:
09:17:22 <vixey> try {
09:17:27 <vixey>   x := digitToInt m
09:17:34 <vixey> } catch(Exception e) ...
09:17:48 <vixey> which is what  error ("Char...., makes you type instead
09:18:28 <Peaker> exceptions may also catch unintended errors further down the stack
09:20:41 <quicksilver> and 'error' is hard to catch anyway
09:20:53 <quicksilver> int the presence of lazy evaluation.
09:21:07 <dons> http://www.reddit.com/r/programming/comments/7a3he/actor_model_concurrency_for_haskell/
09:21:09 <Philonous> > flip lookup $ zip  ['0'..'9'] [0..9] $ '3'
09:21:10 <dons> enjoy.
09:21:11 <lambdabot>   Couldn't match expected type `a -> b'
09:21:12 <lambdabot> Title: Actor model concurrency for Haskell : programming, http://tinyurl.com/6kguvm
09:22:41 <Philonous> > flip lookup (zip  ['0'..'9'] [0..9])  '3'
09:22:42 <lambdabot>   Just 3
09:22:47 <Philonous> > flip lookup (zip  ['0'..'9'] [0..9])  'a'
09:22:48 <lambdabot>   Nothing
09:23:00 <vixey> digitToInt char = findIndex (==char) "0123456789"
09:23:07 <ttt--> dons, great!
09:24:05 <Saizan_> > digitToInt 'A'
09:24:06 <lambdabot>   10
09:24:33 <quicksilver> > digitToInt 'H'
09:24:35 <lambdabot>   * Exception: Char.digitToInt: not a digit 'H'
09:24:40 <quicksilver> LAIS
09:31:14 <lispy> ?hoogle withHandle
09:31:14 <lambdabot> No results found
09:31:32 <lispy> ?hoogle :: (Handle -> IO a) -> IO a
09:31:32 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
09:31:32 <lambdabot> System.IO withBinaryFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
09:31:32 <lambdabot> System.IO withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
09:31:44 <lispy> How do you create an new handle?
09:31:52 <lispy> ?hoogle newHandle
09:31:52 <lambdabot> No results found
09:32:05 <Igloo> open(Binary)File
09:32:24 <Igloo> There might even be with* variants, I don't remember
09:32:30 <lispy> Igloo: even if I just want to make a handle for reading from a sub process?
09:32:40 <lispy> ?hoogle openFile
09:32:40 <lambdabot> System.IO openFile :: FilePath -> IOMode -> IO Handle
09:32:55 <Igloo> Some of the process creation functions return Handles, I think
09:33:27 <lispy> I want to use runProcess
09:33:30 <lispy> ?hoogle runProcess
09:33:31 <lambdabot> System.Process runProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> Maybe Handle -> Maybe Handle -> Maybe Handle -> IO ProcessHandle
09:33:40 <lispy> Which accepts it's handles
09:33:45 <Igloo> Beware that you need to be careful to avoid creating deadlocks, by reading from one handle while the buffer for another fills up
09:34:01 <lispy> the haddocks says it immediately closes them too.  I'm perplexed
09:34:27 <lispy> Igloo: I just want to read from stdout and stderr until both are done
09:34:50 <Igloo> ?type runInteractiveProcess
09:34:51 <lambdabot> Not in scope: `runInteractiveProcess'
09:34:58 <lispy> Igloo: I want a portable runInteractiveCommand that allows me to give the env
09:34:59 <Igloo> ?type System.Process.runInteractiveProcess
09:35:00 <lambdabot> FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (GHC.IOBase.Handle, GHC.IOBase.Handle, GHC.IOBase.Handle, System.Process.Internals.ProcessHandle)
09:35:33 <lispy> oh, that is on 6.6.  I will use that then
09:36:32 <vixey> this is good
09:36:33 <vixey> Stack space overflow: current size 8388608 bytes.
09:36:34 <vixey> Use `+RTS -Ksize' to increase it.
09:36:48 <vixey> what I did to get this stack overflow is... use someone else code
09:36:58 <vixey> so idk I wonder if this chess AI is bronke
09:37:12 <ToRA|MSR> if you really, really want to create handles, you could go via createPipe and fdToHandle in System.Posix.IO, but I doubt that's recommended
09:38:32 <lispy> ToRA|MSR: I need this to portable so I'm avoiding Posix
09:38:41 <ToRA|MSR> nod
09:42:08 <arnfred> bummer
09:42:20 <lispy> ?hoogle [(a, b)] -> (a, b) -> [(a, b)]
09:42:21 <lambdabot> Control.Arrow (<+>) :: ArrowPlus a => a b c -> a b c -> a b c
09:42:21 <lambdabot> Data.Array.Base (//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
09:42:21 <lambdabot> Data.Array.IArray (//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
09:42:33 <lispy> Is there a replace for assoc litss?
09:43:16 <arnfred> I don't mean to spam, but I'm just going to repeat my question, so it doesn't get drowned out in the netsplit-merge
09:43:19 <arnfred> Does anybody know what I have to do to make runhaskell see the libraries I've downloaded with cabal-install?
09:43:26 <arnfred> because right now I can't seem to install yi, because it doesn't seem to find the libraries I've already installed with cabal-install
09:43:50 <arnfred> I'm trying to get yi directly from the darcs repositories
09:43:50 <Saizan_> arnfred: pass --user to configure
09:44:07 <Saizan_> arnfred: or use "cabal install" in the yi directory
09:44:35 <arnfred> thanks, that worked :)
09:51:46 <BMeph> lispy: Isn't the whole point of POSIX specs is to be portable, though? :)
09:52:46 <lispy> BMeph: we have non POSIX systems though, like win32
09:54:04 <BMeph> lispy: Hmm...CRUSH Them! >:)
09:55:30 * BMeph waits for the day when people describe MS Windows as "like Ubuntu, but incompatible with any other Linux system"
09:55:52 <arnfred> How do I get cabal install to use the newest version of the cabal library?
09:56:22 <arnfred> I've installed both Cabal 1.4 and Cabal 1.6, but cabal-install uses 1.4, while I want it to use 1.6
09:56:23 <Philonous> And without any decent package management system -.-
09:58:07 * BMeph nods, noting that he should have added what Philonous said.
10:00:05 <Gabby> arnfred, er the latest cabal install uses 1.6 ... Cabal (==1.6.*),
10:00:43 <arnfred> Gabby, when I enter cabal-install -V, I get the following response:
10:00:54 <arnfred> cabal-install version 0.5.2
10:00:55 <arnfred> using version 1.4.0.2 of the Cabal library
10:01:09 <Saizan_> arnfred: "cabal install cabal-install" :)
10:02:03 <Saizan_> it should rebuild it against the latest Cabal, fetching the latest version of cabal-install too
10:02:19 <arnfred> Saizan_, genious!
10:02:25 <Gabby> :)
10:02:41 <arnfred> almost like bootstrapping
10:03:37 <arnfred> yi still doesn't want to build though :/
10:05:22 <vixey> the great thing about having a cabal that can reinstall itsself to fix bugs is you're totally screwed if cabal breaks
10:05:53 <Gabby> Lol
10:06:12 <quicksilver> yay for self-hosting package systems ;)
10:06:24 <quicksilver> correctness is no longer a clear description
10:06:29 <quicksilver> instead you just wonder if there is a fixed point.
10:06:36 <Saizan_> well, each version of Cabal is built using itself, not previous versions, so if there's a fix you're going to get it
10:06:55 <Saizan_> it's not like ghc :)
10:06:56 <arnfred> as long as I get my fix I'm ok
10:07:16 <vixey> I think I have a broken cabal all through 6.9 - 6.11
10:07:53 <Saizan_> vixey: it surely works fine on 6.10
10:11:28 <Cale> > fix (\x -> "As long as I get my " ++ x ++ " I'm okay.")
10:11:29 <lambdabot>   "As long as I get my As long as I get my As long as I get my As long as I g...
10:13:52 <Philonous> Maybe "Y" would be a good name for such a package system. But only becaue "S (K (S I I)) (S (S (K S) K) (K (S I I)))" is too long
10:18:57 <arnfred> I feel like a complete newbie here, but anyway: So I've installed a program (yi) wit cabal install, but how do I actually run it?
10:19:29 <byorgey> arnfred: check in ~/.cabal/bin, perhaps?
10:19:38 <byorgey> by default that's where it installs stuff
10:19:48 <arnfred> byorgey, sounds reasonable, I'll try
10:19:49 <byorgey> you can override it by giving a --prefix argument to cabal-install
10:20:01 <byorgey> or you can just add ~/.cabal/bin to your $PATH
10:20:05 <tromp__> how about SSK(S(K(SS(S(SSK))))K)
10:21:49 <arnfred> byorgey, how do I do that?
10:22:52 <byorgey> arnfred: in your ~/.bashrc you could add the line  PATH=~/.cabal/bin:$PATH
10:23:12 <arnfred> byorgey, thanks a lot
10:23:18 <byorgey> you're welcome
10:27:34 <ttt--> hi, how can i fix this dependency? http://hpaste.org/11579
10:30:54 <quicksilver> ttt--: you will need to recompile gtk with the bytestring version that yi wants.
10:31:17 <quicksilver> although does yi link to GHC's internal copy of bytestring? if it does you'll need to recompile GHC too.
10:33:06 <gio123> I have an algorithm, I proved soundness ,completness, termination of this algorithm. I gave it input(Obama,mccain) and it returns me(Obama,win) . could somebody implement it on haskell?
10:33:10 <Philonous> Btw. can cabal remove already installed packages, too?
10:33:54 <ttt--> ok, i'll try to recompile first, then ghc
10:34:02 <ttt--> recompile gtk first*
10:34:44 <Beelsebob> gio123: yes -- \(Obama, McCain) -> (Obama, Win)
10:35:04 <Beelsebob> but don't politicise #haskell please
10:35:12 <mr_H> heya
10:35:21 <mr_H> how do i clear the prompt in ghci ?
10:35:32 <mr_H> i've been loading modules, and the prompt is huge
10:35:46 <BMeph> mr_H: ":set prompt <WhatDoYouWantToSee>"
10:36:06 <ttt--> I don't think so, Philippa
10:36:12 <ttt--> Philonous*
10:36:15 <mr_H> nicee, thanks BMeph
10:38:45 <unenough> when will haskell be properly supported in debian/ubuntu?
10:38:59 <unenough> i mean , all that packaging stuff
10:39:18 <Beelsebob> why is it not supported?
10:39:39 <unenough> a while ago i tried installing some haskell library, i think it was lambdabot
10:39:56 <unenough> it was a nightmare, to download build install all the dependencies manually
10:40:05 <unenough> caused me to ditch the effort
10:40:10 <lispy> unenough: have you been introduced to cabal-install?
10:40:10 <Beelsebob> well, why don't you try to do it now, and ask questions about the process
10:40:12 <Cale> unenough: Get cabal-install first.
10:40:17 <maltem> lambdabot has been a major nightmare to build
10:40:26 <lispy> yes, but now lambdabot is on hackage
10:40:32 <Cale> lambdabot should be easy to install now, but only if you have cabal install
10:40:37 <unenough> ok
10:40:50 <unenough> last time there was some issue with cabal buti don't remember what
10:41:12 <Cale> Otherwise, it's probably *the* most painful package to try and install, because it probably has more dependencies than anything else.
10:41:26 <quicksilver> the extra libs are nice ubunut packages
10:41:56 <Cale> To be honest, for actual development, you probably don't want the ubuntu packages for libraries.
10:42:15 <unenough> so what do i want?
10:42:24 <Cale> Though it would be nice if they at least had cabal install...
10:42:35 <Cale> http://hackage.haskell.org/packages/archive/cabal-install/0.6.0/cabal-install-0.6.0.tar.gz
10:42:41 <Cale> You want this, first of all.
10:42:43 <unenough> that's what i just found out...there ain't no such package
10:42:46 <lambdabot> http://tinyurl.com/6gcmrq
10:42:48 <unenough> k
10:42:58 <Cale> It comes with a script to bootstrap it.
10:43:15 <unenough> ok
10:43:34 <Cale> after that, you can type  cabal install <name of package>  and it will download and install anything from hackage.
10:43:50 <unenough> ok, thank you. looks like things have improved, at least documentation-wise :)
10:43:53 <Cale> Well, you have to cabal update first. :P
10:43:55 <Cale> http://hackage.haskell.org/packages/archive/pkg-list.html
10:43:56 <lambdabot> Title: HackageDB: packages by category
10:44:04 <Cale> There's the list of all available packages.
10:44:22 <quicksilver> Cale: I disagree.
10:44:32 <Cale> quicksilver: with what?
10:44:39 <quicksilver> distribution packages are great for rather stable libraries
10:44:48 <dolio> blah sure is busy today.
10:44:49 <quicksilver> e.g. what we used to call extralibs
10:45:00 <Cale> quicksilver: They're good for people who just want to compile a Haskell program.
10:45:22 <quicksilver> well I do actual development and I find them very useful.
10:45:34 <quicksilver> apt-get install blah is a million times better than any alternative.
10:45:42 <Cale> But if you're a Haskell programmer, you probably want cabal install anyway, at which point distribution-specific packages are pointless :P
10:45:55 <quicksilver> no they're not.
10:45:59 <quicksilver> they can be removed, for one thing.
10:46:07 <quicksilver> they understand C library dependencies, for another.
10:46:45 <Cale> and they're usually out of date :P
10:46:54 <unenough> ok, problem: Setup: At least the following dependencies are missing: HTTP >=3000 && <3002, network >=1 && <3
10:46:57 <quicksilver> (and indeed any other dependencies which stray outside the haskell ecosystem)
10:47:03 <Cale> unenough: What are you running?
10:47:11 <quicksilver> Cale: which is why I said 'rather stable libraries'
10:47:13 <unenough> bootstrap for cabal-install
10:47:29 <quicksilver> just because you're doing development doesn't mean you necessarily need bleeding-edge versions of everything you use.
10:47:49 <lispy> anyone know why System.Environment doesn't have a setEnv?  Is this some weird win32-ism?
10:48:04 <Peaker> unenough: are you running bootstrap.sh?
10:48:05 <quicksilver> lispy: because setEnv is a strange thing to want to do.
10:48:10 <unenough> Peaker, yes
10:48:22 <Cale> unenough: odd. It's supposed to download that package itself.
10:48:23 <quicksilver> lispy: normally you launch new processes in a specific environment, but you don't change your own environment.
10:48:24 <Peaker> unenough: weird, which HTTP and network did it try to download?
10:48:26 <lispy> quicksilver: it seems to be something shell scripts do a lot
10:48:38 <quicksilver> lispy: shell scripts are strange by definition, yes.
10:48:44 <lispy> quicksilver: like they change their environment, launch a process and let it inherit
10:48:51 <quicksilver> lispy: right.
10:49:05 <quicksilver> lispy: but the clean approach is to launch a new process, specifying the environment you want when you do that.
10:49:14 <quicksilver> and that's the approach supported by the haskell portable library set.
10:49:17 <unenough> and earlier it also said:
10:49:24 <unenough> Configuring HTTP-3001.1.3...Setup: At least the following dependencies are missing: network -any, parsec -any
10:49:40 <lispy> quicksilver: but it makes emulating shell scripts more awkward :)
10:49:40 <Cale> unenough: aha
10:49:45 <quicksilver> bootstrap.sh expects you to already have the extralibs.
10:49:58 <unenough> ah
10:49:59 <quicksilver> if you're using ubuntu you need libghc6-network-dev
10:50:04 <quicksilver> and various others.
10:50:25 <quicksilver> lispy: emulating shell scripts is a rather POSIX thing to do.
10:50:31 <quicksilver> lispy: and the posix apis have setenv ;)
10:50:44 <unenough> now it would be nice if that was also automatic, i mean, cabal-install should be in ubuntu
10:51:00 <Cale> Yeah, along with a recent GHC :P
10:51:20 <quicksilver> cabal-install will surely be in the next release of ubuntu
10:51:29 <quicksilver> it wasn't really ready in time for this one.
10:51:51 <quicksilver> unoffical cabal-install debs compatible with whatever ubuntu people typically use would be nice ot have, too.
10:51:53 <Cale> quicksilver: It's not in Intrepid.
10:52:08 <quicksilver> Cale: yeah, I meant the next next one :)
10:52:13 <lispy> quicksilver: well, in this case perl is the "shell" I wanted to emulate, and perl is something you can get for win32 :)
10:52:29 <Cale> Also, Intrepid has 6.8.3, which is going to be out of date almost immediately after release.
10:52:54 <Cale> Er, 6.8.2 even.
10:52:59 <lispy> quicksilver: anyway, problem solved in a portable way.  It just made me sad that I couldn't do it the posix way of setEnv.  Instead I had to jump through some hoops to getEnv, append env and then pass the env
10:53:06 * quicksilver nods
10:53:27 <Cale> Which is why I never use my distribution's Haskell stuff...
10:53:30 <quicksilver> lispy: I did understand your point, really.
10:53:41 <quicksilver> lispy: I was just trying to explain why it is that way.
10:53:56 <quicksilver> even if you don't agree with the conclusion it helps to see how the reasoning goes.
10:53:58 <Cale> Ideally, sure, they'd have everything from Hackage available from apt.
10:53:59 <pastaroni> hey guys
10:54:02 <lispy> yeah
10:54:18 <Cale> But if they can't keep it up to date, there's almost no point, as far as I'm concerned.
10:54:27 <pastaroni> i was curious what you guys think about what a good introductory programming language would be
10:54:28 <lispy> quicksilver: although, it makes me want to submit a portable setEnv to the libs :)
10:54:34 <vixey> pastaroni: haskell
10:54:39 <quicksilver> alternatively, ideally, there will be a tool to create debs from cabal packages automatically
10:54:43 <pastaroni> vixey: lol
10:54:52 <quicksilver> instead of using cabal to install them directlly in /usr/local
10:54:59 <Cale> Actually, Haskell isn't bad as an intro language.
10:55:00 <vixey> pastaroni: what did you expect?
10:55:05 <lispy> quicksilver: but, then I wouldn't be able to use it until that function was in all versions of ghc that darcs supports, so it's like 19 years away from being useful for me.
10:55:12 <quicksilver> lispy: ;)
10:55:22 <quicksilver> lispy: I'll make a note in my diary.
10:55:26 <vixey> pastaroni: "Anything but haskell! It's way too hard"
10:55:30 <pastaroni> vixey: a more honest answer :-p
10:55:36 <Cale> But probably if you're going to be introducing someone to programming, using a language that you're familiar with is probably more important than any other factor.
10:55:46 <quicksilver> pastaroni: vixey's answer is humorous but deeply dishonest.
10:55:47 <vixey> pastaroni: ok, not haskell, it's way too hard :p
10:55:48 <unenough> pastaroni, pascal?
10:56:02 <dcoutts> @yarr!
10:56:02 <kaizoku> YARRRR
10:56:02 <lambdabot> What be a priate's favourite cheese?
10:56:02 <lambdabot> Yarrlsburg!
10:56:03 <kaizoku> YARRRR
10:56:06 <quicksilver> haskell is a far far better introductory language than Java
10:56:07 <Cale> I'd honestly advocate the use of Haskell as a beginner language.
10:56:11 <Peaker> Cale: total newbies can learn Haskell? its type system sounds difficult at first?
10:56:12 <quicksilver> which is what many unis use these days.
10:56:14 <unenough> pastaroni, it has a rather limited set of primitives
10:56:14 <dcoutts> what's this kaizoku ?
10:56:25 <pastaroni> Cale: it's not me introducing, it's professors introducing
10:56:34 <vegai> a colleague at work just recently called Haskell "an extremely difficult language"
10:56:39 <vixey> pastaroni: I'm kind of wondering what experience you have to know that I'm not being honest
10:56:39 <unenough> pastaroni, to whom?
10:56:40 <Cale> pastaroni: Are the professors used to Haskell?
10:56:55 <quicksilver> I think russian is an extremely difficult language.
10:56:56 <pastaroni> i'm making a recommendation to professors/faculty
10:57:00 <Cale> pastaroni: I would want the professors to use whatever language they are most comfortable with.
10:57:01 <vegai> oddly enough, he doesn't think I'm a genius for knowing how to write putStrLn "Hello World"
10:57:03 <quicksilver> That's merely because I don't know it.
10:57:14 <quicksilver> Russian isn't difficult for children born in russia.
10:57:23 <Cale> pastaroni: That is, don't standardise it, let each prof decide.
10:57:25 <pastaroni> they're comfortable with a variety of languages, i'm not sure about haskell
10:57:26 <vixey> vegai: Yes, I program in haskell because it's really really really hard ;)
10:58:04 <Cale> pastaroni: Unless the profs really want you to decide that for them :P
10:58:14 <pastaroni> they want my input, it seems
10:58:45 <Cale> Haskell is used to good effect as a first programming language at a lot of universities around the world.
10:58:45 <vixey> pastaroni: I'm not sure if you just came into #haskell and asked "suggest any language for beginners to learn _except_ haskell"?
10:58:51 <vegai> vixey: keeps the wage at a decent level, eh? Eh?
10:59:00 <vegai> I suppose they think I'm trying to bring in Haskell for that very reason
10:59:16 <pastaroni> these intro classes are pre-reqs for later classes, and those professors like the students to know a particular language instead of a mish-mash of different languages
10:59:35 <Cale> It's a decent choice simply because it allows one to take an abstract approach to computation and the business of programming, which can be later refined with more practical details in later years.
10:59:39 <unenough> pastaroni, i think that haskell may be harder to learn once you've learnt a 'classic' language too much
10:59:48 <pastaroni> i actually floated the idea of haskell, but it was shot down by CS majors :-/
10:59:55 <Peaker> unenough: s/classic/imperative ;)
11:00:06 <Peaker> unlearning imperative programming might be hard
11:00:27 <Cale> It also tends to be good at levelling the playing field.
11:00:30 <vegai> well, don't do it.
11:00:31 <Emiel|Fallout3> <unenough> pastaroni, i think that haskell may be harder to learn once you've learnt a 'classic' language too muc
11:00:32 <Emiel|Fallout3> it is
11:00:36 <jordi_> hi, how do you put comments in haskell?
11:00:41 <unenough> --
11:00:46 <Emiel|Fallout3> it seems to have quite uneasy flow
11:00:47 <pastaroni> and i'm focusing on programming languages for engineering, physics, and math majors
11:00:47 <Cale> People who come to university thinking that they know how to program already need to be taken down a notch :)
11:00:50 <Peaker> jordi_: -- till end of line,  or {- this is a multiline comment -}
11:00:52 <Emiel|Fallout3> compared to imperative languages
11:00:52 <jordi_> unenough: thanks!\
11:00:57 <Emiel|Fallout3> (at lesat for me)
11:01:05 <unenough> -- heh, this is the only thing i know about haskell!
11:01:06 <vixey> pastaroni: FORTRAN
11:01:07 <kaol> > 1 + {- hello world -} 2
11:01:08 <lambdabot>   3
11:01:10 <Cale> Emiel|Fallout3: Uneasy flow?
11:01:13 <Emiel|Fallout3> yea
11:01:15 <Emiel|Fallout3> like unnatural
11:01:17 <Emiel|Fallout3> because
11:01:17 <pastaroni> vixey: we're seriously considering FORTRAN, actually
11:01:18 <jordi_> Peaker: thanks, really newbie question, but nevertheless :)
11:01:22 <Cale> What do you mean by that?
11:01:22 <Emiel|Fallout3> the function have no side-effects
11:01:34 <Emiel|Fallout3> so it's truly more like math functions
11:01:40 <vixey> pastaroni: For the last time, I'm giving you serious answers, I'm not joking here
11:01:42 <vegai> that's true in other languages too, they just don't enforce it :)
11:01:44 <Emiel|Fallout3> only producing a result from arguents
11:01:46 <Peaker> s/more like/exactly like ?
11:01:48 <pastaroni> vixey: we're also considering C
11:01:55 <vixey> pastaroni: That's a terrible idea
11:01:59 <Cale> Right, but that's normal for the majority of students who have taken mathematics courses, but not computer science ones.
11:02:05 <pastaroni> vixey: what's wrong with C?
11:02:09 <unenough> C may be good for engineers
11:02:10 <cads> cale, my fear is of coming to university, being taught java, and sent with a pat on the butt into the world with a degree, never having needed to build a compiler or touch a lambda symbol
11:02:15 <vixey> pastaroni: just take my word for it ;)
11:02:15 <Emiel|Fallout3> well I started programming before i had good maths base
11:02:16 <pastaroni> vixey: C is great for engineers
11:02:19 <Emiel|Fallout3> so this is not my case :p
11:02:21 <vixey> pastaroni: no it's not
11:02:28 <Emiel|Fallout3> for example, when I tried to envision how to write some of routines of game im coding
11:02:32 <Emiel|Fallout3> which is C++
11:02:38 <Emiel|Fallout3> i couldnt find an easy way
11:02:41 <Emiel|Fallout3> for simple functions
11:02:48 <vegai> vixey: C is great for engineers, it keeps them busy. How about that?
11:02:50 <Cale> Emiel|Fallout3: If you want, I can help in translating :)
11:02:54 <Emiel|Fallout3> because there are a lot of void func(void) functions
11:03:07 <vixey> Emiel|Fallout3:  IO ()
11:03:09 <mr_H> :D
11:03:09 <Emiel|Fallout3> Cale, heard of Source engine? of half life 2
11:03:16 <Emiel|Fallout3> thats a shitload of code ^^
11:03:18 <vixey> Emiel|Fallout3:  since () -> IO () is silly
11:03:20 <Cale> Emiel|Fallout3: yes, I've played it :)
11:03:31 <mr_H> Emiel|Fallout3: C is good, C++ sucks
11:03:35 <Emiel|Fallout3> nah
11:03:37 <sbahra> mr_H, why?
11:03:38 <Emiel|Fallout3> C++ is godly
11:03:41 <Emiel|Fallout3> OO <3
11:03:50 <Emiel|Fallout3> I coded on Jedi Academy engine before
11:03:51 <pastaroni> vixey: the problem i have with fortran is that it seems to be on its way out, whereas C is going strong
11:03:52 <Cale> C++ has terrible support for OO though :/
11:03:55 <Emiel|Fallout3> it was modified quake 3
11:04:00 <Emiel|Fallout3> and when i saw C++ in HL2
11:04:02 <Emiel|Fallout3> i was like
11:04:03 <mr_H> well, i could rant about c++ for weeks
11:04:06 <Emiel|Fallout3> 'God, this is so beautiful'
11:04:07 <vixey> pastaroni: no idea what that means
11:04:11 <mr_H> but im not going to, this is haskell
11:04:13 <sbahra> Emiel|Fallout3, C++ is an industry standard, what's so surprising?
11:04:16 <mr_H> lets talk about haskell instead
11:04:18 <vixey> pastaroni: is your fortran compiler going to suddenly stop working?
11:04:22 <Emiel|Fallout3> no I mean
11:04:23 <Cale> Both C and C++ have major problems as programming languages :P
11:04:26 <Emiel|Fallout3> the code is so much easier to write
11:04:27 <Emiel|Fallout3> and comprehend
11:04:29 <Emiel|Fallout3> if you use OO
11:04:32 <sbahra> pastaroni, fortran is not on its way out.
11:04:34 <mr_H> sbahra: and what a standard... 900 pages, no deprecation policy ;)
11:04:38 <Emiel|Fallout3> Cale, all languages do.
11:04:49 <pastaroni> vixey: what i meant is that fortran doesn't seem to be used that much, whereas C is used pretty heavily in industry
11:04:53 <sbahra> pastaroni, it's going to stay for quite a while. :-P Some important applications (most of which are legacy) are written in Fortran.
11:04:59 <cads> what kind of stuff are you doing?
11:04:59 <Cale> Emiel|Fallout3: Well, compared to some others :)
11:05:09 <mr_H> besides, its a pain to link with C++
11:05:10 <vixey> pastaroni: oh well, if you have already made up your mind
11:05:10 <sbahra> pastaroni, and there have been some major developments recently for parallel computing, look at co-array fortran.
11:05:11 <Emiel|Fallout3> like?
11:05:13 <Emiel|Fallout3> dont say java
11:05:15 <Emiel|Fallout3> please dont do that
11:05:16 <Emiel|Fallout3> ;P
11:05:24 <pastaroni> vixey: i haven't....that's why i came here for input
11:05:29 <Cale> Well, nothing which the industry is using.
11:05:38 <Cale> (at least the majority of it)
11:05:41 <EmielRegis> they use it for a reason tho/...
11:05:47 <Cale> Because it's popular.
11:05:53 <cads> err, dang, I was scrolled way up..  EmielRegis, what kind of game coding thing are you trying to do? and btw, is fallout three frickin out?!
11:06:04 <EmielRegis> it is in usa
11:06:08 <EmielRegis> (im european, but I warez a lot)
11:06:16 <EmielRegis> im not trying cads :P
11:06:18 <lilac> cads: 3 more days til fallout 3 is released, i think
11:06:23 <EmielRegis> im lead coder of a modification for source engine
11:06:27 <alp2> hi, I'm trying to turn a StateT monad into an instance of MonadPlus, but I'm getting an error about kind-mismatch (see http://hpaste.org/11580). Anyone can give me an hint about how to solve this problem?
11:06:33 <EmielRegis> but i was just comparing its C++ ways to Haskell
11:06:40 <mr_H> lilac: have you checked isohunt and piratebay ? :)
11:06:47 <sbahra> pastaroni, in fact...
11:06:50 <EmielRegis> warez-bb.org is your friend
11:06:55 <noteventime> Somehow ghc has stopped acknowledging everything I install though cabal-install O_o
11:06:55 <EmielRegis> there are like 4 versions already
11:06:57 <vixey> alp2: You could use LogicT
11:07:06 <noteventime> The packages aren't listen in ghc-pkg list
11:07:07 <shepheb> my brother is playing it right now, but I don't know if he pirated it. I thought it was released on Monday, though?
11:07:08 <lilac> i think we mean different things by "out"
11:07:08 <sbahra> pastaroni, WG5 meeting was recent (Fortran International)
11:07:18 <Cale> alp2: you'll need a newtype
11:07:21 <EmielRegis> in USA yes shepheb
11:07:24 <noteventime> Is there some package config file I have to add to some environment variable somewhere?
11:07:27 <EmielRegis> in rest of world on 31st
11:07:28 <Cale> alp2: StateT Int IO (Maybe String) is not a monad.
11:07:39 <dcoutts> noteventime: you didn't change ghc version or something? or perhaps have multiple ghc versions installed?
11:07:45 <pastaroni> sbahra: i'm surprised at this recent development in fortran, i didn't think it was this active
11:08:01 <noteventime> dcoutts: Not really
11:08:05 <noteventime> I don't think so anyway
11:08:05 <Husio> how to write function that tooks list of elements and returns most common element?
11:08:08 <alp2> Cale: i see
11:08:08 <noteventime> I'm not sure when it started
11:08:10 <Cale> alp2: Remember that a monad is a type constructor.
11:08:31 <sbahra> pastaroni, thank the non-computer scientists. :-P
11:08:31 <Cale> alp2: That is, something which takes a type and produces another type.
11:08:39 <lilac> MonadT (StatT Int IO) ?
11:08:42 <Cale> Like  IO  or Maybe
11:08:43 <dolio> You should learn C++. They're getting lambda expressions in 0x!
11:08:43 <vixey> Husio: refine hat you mean by 'the most common' until it's something you can actually implement
11:08:43 <noteventime> dcoutts: I may have done a reinstall, though I'm reasonably sure I removed everything related to cabal and reinstalled it
11:09:19 <EmielRegis> dolio, yeah i read that today
11:09:22 <EmielRegis> quite cool
11:09:22 <pastaroni> sbahra: heh, funny you should mention that
11:09:26 <Husio> vixey: example:   fun [1, 3, 2, 2, 2]   returns 2
11:09:29 <EmielRegis> wonder when its gonna be released
11:09:31 <dolio> Heh.
11:09:35 <vixey> Husio: yes
11:09:36 <dolio> They're so clean and simple!
11:09:38 <dcoutts> noteventime: so reinstalling ghc would wipe out all globally registered packages, but did you say that new packages are not getting registered either?
11:09:54 <jrh> has anyone written an in-memory R-Tree implementation in Haskell yet?
11:10:01 <noteventime> dcoutts: Indeed
11:10:03 <lilac> dolio: yeah, but the c++ lambdas aren't really closures :(
11:10:14 <noteventime> dcoutts: And I don't see them in ghc-pkg's list
11:10:17 <dons> conal: where do the  unamb and checkers packages live?
11:10:24 <dons> they're not on hackage, are they?
11:10:30 <dcoutts> noteventime: well I'm interested in the latter, if you've got a simple test case and a log
11:10:34 <rwbarton> lilac: I thought you could choose whether they were closures, by picking one of eight different syntaxes...
11:10:44 <conal> @wiki unamb
11:10:45 <vixey> Husio: or split the problem into two parts:  fun = x . y,  y [1,3,2,2,2] returns [[1],[2,2,2,2],[3]], and  x [[1],[2,2,2,2],[3]] returns 2
11:10:45 <lambdabot> http://www.haskell.org/haskellwiki/unamb
11:10:52 <conal> @wiki checkers
11:10:53 <lambdabot> http://www.haskell.org/haskellwiki/checkers
11:10:54 <pastaroni> sbahra: i'm trying to decide what language to recommend for an introductory computer science class for engineering, physics, and math majors
11:11:09 <dolio> They seem to be approximately 'closures' depending on what exactly you mean by that.
11:11:09 <vixey> pastaroni: SICP
11:11:14 <noteventime> dcoutts: I'm sorry if I'm being retarded, but a log of what?
11:11:15 <conal> dons: if they're not hackaged yet, it's unintentional.  i can hackage them pronto.
11:11:18 <pastaroni> vixey: we thought about scheme
11:11:25 <lilac> rwbarton: you can choose whether they hold a crashy reference to the stack frame, or whether they copy the locals. you can't make them extend the lifetime of the locals.
11:11:27 <Husio> vixey: thanks
11:11:32 <dolio> I imagine if you tell it to capture all the variables by reference, they're essentially all you could want from a closure.
11:11:37 <conal> dons: how did you notice?
11:11:41 <sbahra> pastaroni, I personally think Haskell would be a great language for this.
11:11:42 <dolio> Not that all that isn't terrible.
11:11:45 <dcoutts> noteventime: the cabal install -v command you ran and the output it produces
11:11:53 <vixey> Husio: the nice thing about splitting up the problem is you can do it again and again until each part is completely trivial to write
11:11:56 <pastaroni> vixey: but we figured since it was their only non-CS class, and since scheme isn't used much in industry, we'd be better off with something else
11:12:05 <noteventime> dcoutts: Ohh, sure, I'll install something
11:12:09 <rwbarton> lilac: Oh, I see.  (I can never tell when C++ is going to give you a crashy stack reference...)
11:12:11 <dolio> Oh yeah, stack frames...
11:12:17 <sbahra> pastaroni, the problem is, at the moment...the "standard" for them is really Fortran or C.
11:12:22 <sbahra> pastaroni, or Matlab for prototyping.
11:12:25 <igel> does someone know when ghc-6.10 will finally be released? :)
11:12:29 <noteventime> dcoutts: Things installed through cabal-install recognise packages installed through cabal-install
11:12:34 <vixey> pastaroni: "introductory computer science class for engineering, physics, and math majors" and "it was their only non-CS class" --- these two statements seem to be contraditory
11:12:38 <pastaroni> sbahra: i tried suggesting haskell.....but my CS friends shot down the idea very hard
11:12:41 <noteventime> dcoutts: That is, during compilation of the package
11:12:45 <dcoutts> noteventime: then they must be registered with ghc
11:12:50 <jeffersonheard> pastaroni: why?
11:12:53 <pastaroni> vixey: my bad, i meant "their only CS class"
11:12:54 <sbahra> pastaroni, do any of them know haskell? :)
11:12:58 <sbahra> pastaroni, I really doubt that.
11:13:15 <cads> EmielRegis: i've been using haskell for a little bit, and so far I'm finding it hard to compare modular declarative programming with object oriented imperative programming.... I love the mathematical abstractions of haskell and the ease of prototyping of something like ruby or smalltalk and I am torn between the two.. as for c++ it is horrifying to me, and I'm sticking with C for modules that need to seriously crunch numbers when I use som
11:13:15 <cads> ething like ruby
11:13:16 <jeffersonheard> pastaroni: I suspect they thought you said Pascal.  Common mistake
11:13:17 <rwbarton> lilac: Still if I had to choose between real closures and C++'s not-by-reference lambdas I would probably choose the latter
11:13:19 <dcoutts> noteventime: cabal just asks ghc-pkg, are you sure you don't have two instances of ghc or ghc-pkg installed?
11:13:20 <EmielRegis> haskell seems liek a good choice for math peopel for me
11:13:22 <EmielRegis> but again
11:13:25 <EmielRegis> im noob so dontl isten to me
11:13:25 <EmielRegis> ;)
11:13:41 <pastaroni> sbahra: most of them do, actually......from what i've heard those who know haskell fall in love with it
11:13:44 <vixey> EmielRegis: what's a math people?
11:13:44 <dcoutts> noteventime: by default, cabal uses the ghc-pkg program in the same dir as where it found ghc
11:13:48 <noteventime> dcoutts: I think I'll just remove anything that relates to ghc to make sure :)
11:13:56 <dcoutts> noteventime: wait a sec
11:13:57 <EmielRegis> people who study maths in detail
11:14:00 <EmielRegis> generally
11:14:08 <pastaroni> sbahra: yeah, that's why we're going to recommend either fortran or c, probably c......
11:14:17 <dcoutts> noteventime: so it'd be interesting to check what which ghc and which ghc-pkg report
11:14:26 <vixey> EmielRegis: How can you generalize your own experience over that entire group of people? o_O
11:14:27 <Cale> EmielRegis: One thing I could tell you is to start by thinking a little more about what your functions depend on and what they affect. You can trivially transform a lot of imperative programs simply by adding additional parameters for all the things which the function depends on, and adding things to the result of the function for all the things which it would normally affect.
11:14:39 <EmielRegis> vixey, where am I doing that?
11:14:40 <vixey> EmielRegis: I think there are some people that study math that like things I don't like ...
11:14:44 <rwbarton> @users
11:14:44 <lambdabot> Maximum users seen in #haskell: 547, currently: 531 (97.1%), active: 37 (7.0%)
11:14:45 <noteventime> dcoutts: I get missing package errors when I try to manually compile packages
11:14:47 <pastaroni> jeffersonheard: i think they heard me correctly :-/
11:14:59 <Cale> EmielRegis: Of course, if the point of your C/C++ function is just to do some input and output, then it's probably best represented by an IO action.
11:14:59 <vixey> EmielRegis: I maybe misunderstood "haskell seems liek a good choice for math peopel for me"
11:15:22 <jeffersonheard> So no-one's speaking up about the R-Tree.  I assume no-one's written one, then.  I can't find one in hackage
11:15:22 <dcoutts> noteventime: what is the output of 'which ghc' and 'which ghc-pkg'  ?
11:15:25 <EmielRegis> I mean they will probably find the syntax and whole idea of functional programming easy
11:15:29 <vixey> EmielRegis: yeah I read it backwards somehow
11:15:39 <noteventime> dcoutts: Both are in /usr/bin
11:15:40 <EmielRegis> since they already knew functions and stuff related to them
11:15:55 <jeffersonheard> I keep getting things pushed to the top of my queue faster than I can finish my GDAL/OGR bindings.  After I get those, I'll get together an R-Tree, I suppose...
11:15:57 <Baughn> EmielRegis: There are still a lot of issues with haskell that math doesn't have, but you're actually right
11:16:00 <noteventime> dcoutts: And "locate ghc-pkg" didn't find any other
11:16:00 <lament> most people should know functions, they're in the high school curricula
11:16:06 <pastaroni> to be fair, i can see why my group would recommend teaching fortran or  c
11:16:16 <cads> For a 'math people', I saw something that fairly made me drool today. It's not a declarative language, but check this out: http://tinyurl.com/56avjm
11:16:17 <lambdabot> Title: fortifyltx.png (image)
11:16:20 <Baughn> It's been very easy to teach my math teacher some elementary haskell
11:16:27 <dcoutts> noteventime: hmm, ok, so check in cabal configure -v what path it finds ghc-pkg at
11:16:29 <pastaroni> but i'm not so sure about them as introductory languages....or why c is so much better than fortran
11:16:48 <dcoutts> noteventime: are you sure this isn't just some confusion about the difference between global and per-user registered packages?
11:16:53 <Peaker> cads: I hate math notation :P
11:16:58 <EmielRegis> Cale, you have a point in there. However, when there is a complex task, say reverse matrix, add it to player origin and then update his HUD, I'd better with a single function that encapsulates all these activities as side effects, rather than writing few haskell functions and call them each time again
11:17:12 <lament> cads: argh, that's unreadable :)
11:17:14 <vixey> Peaker: do you use different notation when writing maths?
11:17:16 <Cale> EmielRegis: You can do that in Haskell of course.
11:17:17 <cads> Peaker, I love it : )
11:17:18 <EmielRegis> Baughn, of course there are, thats why Haskell is computer language and not maths :p
11:17:20 <jeffersonheard> Looks like someone combined APL and Algol
11:17:34 <Cale> EmielRegis: However, you'll probably split the parts of it which are pure into pure functions.
11:17:36 <dolio> cads: Fortress looks pretty nice when typeset.
11:17:45 <Peaker> vixey: I don't generally write a lot of maths, and when I do, its usually just typical arithmetic syntax over ascii
11:17:58 <vixey> ok :/
11:17:59 <noteventime> dcoutts: I'm not sure about anything, the only thing I'm 100% on is that when I run "setup.hs" when compiling something not in cabal I get missing package errors :)
11:18:00 <maltem> Talking math, I'm actually very keen on DPH becoming usable, so Haskell will be nicely suited for the other aspect of math and programming
11:18:00 <Baughn> EmielRegis: But yeah, there are probably more useful concepts in math than in fortran for writing haskell programs
11:18:02 <EmielRegis> Cale, I know you can. In fact, you can everything in every language, I just don't like the hassle involved - mind I am used to thinking 'imperative' way and to get those concepts in Haskell I need to 'translate' them
11:18:19 <dcoutts> noteventime: aah, ok try runghc Setup configure --user
11:18:26 <Cale> EmielRegis: actually, you would do it basically the same way in Haskell as you would in an imperative language.
11:18:29 <lilac> igel: there's a ghc 6.10.1 tarball on the server; not clear whether it's the official release: http://haskell.org/ghc/dist/stable/dist/ghc-6.10.1-src.tar.bz2
11:18:34 <cads> dolio, I've seen haskell papers with nice typesetting and was wondering if I need to learn latex to do the same thing
11:18:34 <Cale> EmielRegis: that one in particular, anyway
11:18:39 <dcoutts> noteventime: you confused me because you said ghc-pkg list did not list the installed packages
11:18:44 <Peaker> EmielRegis: or you'd use FRP! :)
11:18:46 <lilac> igel: but i've been running it for a while and it seems pretty solid
11:18:50 <EmielRegis> FRP?
11:18:55 <noteventime> dcoutts: I thought it didn't, but I may have done a sloppy search :)
11:18:58 <Peaker> EmielRegis: Functional Reactive Programming
11:18:59 <Cale> EmielRegis: Functional Reactive Programming.
11:18:59 <noteventime> Let me check
11:19:30 <Cale> EmielRegis: It's a really cool new paradigm of sorts for doing things like robotic control, animation, games and such :)
11:19:43 <noteventime> dcoutts: I don't understand though, is that a recent change in ghc/cabal, I've been using locally installed packages without any problems until recently
11:19:48 <EmielRegis> I just read
11:19:55 <dcoutts> noteventime: no, it's not a recent change
11:20:33 <noteventime> dcoutts: Sorry, my fault, the packages seem to have been installed (don't know how I managed to miss some of them)
11:20:34 <dcoutts> noteventime: the runghc Setup configure method has always done global installs by default, cabal configure has (almost) always done per-user installs by default
11:20:45 <sbahra> pastaroni, I do not recommend C :)
11:21:08 <dcoutts> noteventime: so it is confusing because runghc Setup does a different thing, but we didn't feel we could change the old default, but we could for the new cabal-install tool
11:21:08 <pastaroni> sbahra: yeah, i don't think it's the best intro language
11:21:27 <igel> lilac, thanks
11:21:41 <pastaroni> sbahra: to be fair, though, the students who would be taught C (engineering/math/physics majors) will be coming in to the class with basic programming knowledge
11:21:54 <dcoutts> noteventime: btw, if you're using cabal-install then there is no need to ever runghc Setup.hs, cabal does all that
11:21:55 <lilac> i wonder whether simultaneously learning haskell and assembler would be a good introduction :)
11:22:12 <noteventime> dcoutts: But I'm reasonably sure (though we've proven that's not much to go on :p) I've installed things that depended on locally installed packages before. Well, it works now anyway. Thanks :)
11:22:13 <jeffersonheard> lilac: o_O
11:22:21 <BMeph> cads: Have you read Wadler's paper, "The expression lemma" I think it's called? :)
11:22:34 <pastaroni> sbahra: also, they aren't going to have any more CS courses in their degree plan, so it seems like a good idea to teach them something that they're very likely to use later
11:22:36 <dolio> cads: Unicode syntax can go a long way, if you find a font that displays a good enough subset.
11:22:37 <noteventime> dcoutts: It's Agda, and it included a makefile that ran setup for me
11:22:38 <Cale> lilac: heh, we basically simultaneously did scheme and assembler in CS 241 at Waterloo :)
11:22:54 <dcoutts> noteventime: ah
11:23:00 <dblazakis> BMeph: i don't think that's a Wadler paper, is it?
11:23:06 <cads> BMeph: wadler's got a blog! sweet
11:23:14 <BMeph> Cale: Has anyone tried to use FRP with a debugger?
11:23:27 <dolio> The expression problem is a Wadler text file, as I recall.
11:23:30 <noteventime> dcoutts: Thanks again :P I should have realised
11:23:31 <Cale> BMeph: I don't know.
11:23:33 <dolio> Probably from an e-mail.
11:23:34 <lilac> Cale: come to think of it, i think the compsci's at Cambridge were doing C and ML, which amounts to much the same thing :)
11:23:52 <sbahra> pastaroni, then just go ahead with Haskell :-P
11:24:05 <BMeph> dblazakis: Good call, it's a Laemmel paper. :)
11:24:17 <pastaroni> sbahra: lol
11:24:18 <cads> BMeph, the paper is Lammel's
11:24:20 <cads> oh
11:24:23 <dcoutts> noteventime: the solution would be for it to look in the user db too and suggest that you might have meant a --user install
11:24:24 <dolio> Oh, you were talking about the lemma paper. :)
11:24:25 <BMeph> Wadler blogged about it, that's where I saw it.
11:24:26 <dblazakis> heh, i didn't know there was an "the expression problem" also
11:25:08 <Cale> BMeph: are you thinking of coming up with a more fun kind of debugger for FRP stuff?
11:26:33 <Cale> BMeph: I can imagine a visualiser which would let you look in on something like a network of signal transformers and see what's flowing through it.
11:27:53 <Cale> Using a traditional debugger is admitting defeat :)
11:28:59 <BMeph> cads: The blog is http://wadler.blogspot.com/ specifically http://wadler.blogspot.com/2008/06/expression-lemma.html
11:29:01 <lambdabot> Title: Wadler's Blog
11:29:24 <cads> hehe, brokers with their hands on their faces
11:29:52 <Peaker> I like Subtext's approach to debugging
11:30:27 <BMeph> Cale: I was going over John Edward's papers, the "Example Centric Programming" one specifically, and his timeline of stepping through program execution reminded me of FRP. So I asked. :)
11:30:43 <pjdelport> nifty paper that
11:30:58 <BMeph> Peaker: Exactly, I'm reading a paper by the guy that does Subtext.
11:31:52 <Cale> I actually think John Edwards is a bit crazy in some ways. Drilling into an abstraction is quite often exactly the opposite of the right thing to do.
11:32:03 <Peaker> Cale: when debugging?
11:32:09 <Cale> Even when debugging.
11:32:12 <dolio> Plus he gets $400 haircuts.
11:32:32 <Cale> Especially when debugging a recursive function.
11:32:51 <Peaker> Cale: why? seems like a simple solution
11:33:08 <Cale> It's 100 times more complicated than what you actually want to do.
11:33:55 <Cale> What you want to do is to verify that it works for each base case, and then *assume* that the recursive case works and verify that it produces the correct result in terms of that.
11:33:57 <BMeph> Cale: Yeah, he writes as if he got beat up by an abstract bully as a kid... ;)
11:34:28 <BONUS_> ah yes, the recursive leap of faith
11:34:44 <BONUS_> gotta love it
11:35:34 <Cale> Drilling into the recursion is the classic beginner's mistake, and it's why many people can't understand recursion at first, because they're not willing to do take that recursive leap of faith.
11:35:43 <Peaker> Cale: but you think it works on the base case
11:35:48 <Peaker> Cale: and you're surprised with a wrong result
11:35:54 <Peaker> Cale: where do you continue?
11:35:56 <vixey> I think that 'leap of faith' is why people can't do it
11:36:23 <Cale> Peaker: You look at the inductive step.
11:37:23 <vixey> if you think that, to write something using recursion you must take ad-hoc leaps of faith without understanding .. t
11:37:31 <Cale> Usually I will actually ignore the actual specific case which is incorrect (unless there seem to be very few incorrectly handled cases), and just start taking things apart.
11:37:36 <BONUS_> well its not a leap of faith per se imho
11:37:50 <Peaker> Cale: from the bottom up, or from the wrong down?
11:37:57 <BONUS_> its more of you trusting yourself that your induction is correct
11:37:58 <Cale> Yes, it's not really a leap of faith. It's justified by the proof of mathematical induction.
11:38:10 <Cale> (or structural induction)
11:38:27 <Cale> Peaker: abstractly.
11:38:33 <vixey> the mathematics you have to know to do it is something that it seems most people do not know about or understand until they are old
11:38:41 <Peaker> Cale: I think its easier to look at something that is obviously wrong and understand that than to just ignore the particular error and look for mistakes in general
11:38:59 <dolio> It's just due to the universality of initial algebras. What could be simpler?
11:39:09 <Cale> Peaker: it is quite often much more complicated, because there will be much about the specific failing case which is entirely irrelevant to why it is failing.
11:39:46 <Cale> It's easier to try to understand what the function is doing abstractly, to arbitrary things, than to look at a specific example.
11:40:31 <Cale> and if you end up with an abstract description of what the function is producing which doesn't match your expectation, you usually can see exactly what's gone wrong
11:40:41 <Peaker> Cale: I think both methods are useful to have in the coding UI
11:40:50 <vixey> UI ?
11:40:51 <vixey> what
11:40:55 <Peaker> UI = User interface
11:41:18 <vixey> which one
11:41:18 <Cale> whereas if you trace the behaviour of a function and see that a specific thing isn't right, then you don't really have a handle on what the function is actually giving you, you just know that it doesn't match with what you want.
11:41:29 <vixey> are you talknig about an actualy debugger tool?
11:42:10 <Peaker> vixey: something like Subtext's UI
11:42:13 <Cale> Sure, it can be handy to look at specific examples sometimes, particularly when generated by tools like quickcheck that can automatically try to simplify the failing example.
11:42:17 <vixey> I don't ktnow what that is .....
11:42:23 <Cale> But more often, I find the abstract approach works better.
11:42:34 <Cale> It's just not easily supported by a tool.
11:42:50 <Cale> (this is not to say that tool support is impossible, just that it's harder)
11:43:30 <vixey> it is something nice you get from using eliminators rather than a catamorphism
11:43:51 <vixey> because this can actually describe the available values and types around you, not just the types..
11:44:18 <rwbarton> Cale: what about when you've correctly implemented what you thought was the recursive relation, but it turns out you made a non-programming error
11:44:25 <rwbarton> then looking at the code isn't going to help you
11:44:35 <rwbarton> but looking at a specific example that your code gets wrong might
11:45:00 <Cale> rwbarton: As in, you didn't know what it is that you really wanted?
11:45:07 <rwbarton> No
11:45:44 <rwbarton> You know what problem you are trying to solve, you just derived an incorrect recursive solution.
11:46:08 <rwbarton> Which you then programmed "correctly".
11:47:30 <Cale> Well, that's sort of what I'm already talking about, just that I wasn't thinking of the recursive solution being on paper first :)
11:49:03 <Cale> When your recursive thing doesn't match your abstract description of what you want, either one of the base cases doesn't solve the problem, or the recursive case doesn't solve the problem in terms of the simpler solution. Getting hold of an abstract description of what your recursive thing is actually building in that case is usually pretty helpful.
11:50:37 <rwbarton> But I already tried to do that, to write down the recursive step.
11:51:17 <rwbarton> (Let me see if I can come up with an example that's the right level of complexity...)
11:53:36 <Cale> rwbarton: Right, but you did it incorrectly, which means that what your recursive function is actually producing doesn't satisfy its abstract requirements.
11:54:01 <mmorrow> rwbarton: i think i found one
11:54:07 <mmorrow> Cale: http://hpaste.org/11581
11:54:08 <Cale> So, often working out what it really *does* satisfy will reveal the flaw in your reasoning.
11:54:19 * maltem is currently learning Java for uni and wondering whether implicit type conversion is easy or horrible
11:54:32 <luite_> can't it be both? ;)
11:54:56 <vixey> maltem: It's definitely what you want
11:55:10 <vixey> :t \x -> sum x / length x
11:55:11 <lambdabot>     No instance for (Fractional Int)
11:55:11 <lambdabot>       arising from a use of `/' at <interactive>:1:6-21
11:55:11 <lambdabot>     Possible fix: add an instance declaration for (Fractional Int)
11:55:17 <vixey> you don't get errors like that
11:55:28 <maltem> luite_: it's a non-exclusive 'or' ;)
11:55:32 <Cale> vixey: You wouldn't get errors like that if the type of length wasn't retarded.
11:55:45 <vixey> :t \x -> sum x / genericLength x
11:55:46 <lambdabot> forall a. (Fractional a) => [a] -> a
11:56:08 <BONUS_> haha
11:56:14 <BONUS_> Windows 7 is gonna have an xmonad-ish feature
11:56:25 <maltem> vixey: heh, true, I didn't get errors for what I thought were illegal expressions either
11:56:37 <BONUS_> if you drag a window to the left or right, it splits the screen into two windows
11:56:40 <vixey> I still blame the type of (/)
11:57:17 <vixey> I want a lattice of numeric types and all the ops like + / etc work wrt to it
11:57:32 <Cale> mmorrow: Except, I don't have an understanding of what that is *supposed* to be doing, so I can't try to find a bug in it :)
11:57:54 <Cale> I think / has the right type
11:57:56 <mmorrow> Cale: hehe. that function makes me shudder
11:58:25 <unenough> math functors map from category to category, but haskell functors map what?
11:58:35 <unenough> category to itself?
11:58:45 <Cale> unenough: Haskell Functors are endofunctors on the category of Haskell types
11:58:49 <mmorrow> (it hoists nested foralls in a type as high as they can go, which i needed to do in the context of applying/expanding type synonyms)
12:00:10 <mmorrow> , src 'ForallT
12:00:27 <lunabot>  data Type = ... | ForallT ([Name]) Cxt Type | ...
12:00:27 <lunabot>  infixl 9
12:00:29 <mmorrow> , src 'LamE
12:00:34 <lunabot>  data Exp = ... | LamE ([Pat]) Exp | ...
12:00:34 <lunabot>  infixl 9
12:00:55 <gio123> does somebody has this paper:  The loop complexity of regular events
12:00:57 <gio123> ?
12:01:13 <mmorrow> (ForallT <-> LamE) => ([Name <-> [Pat]) , (Type <-> Exp)
12:01:43 <mmorrow> \x -> \y z -> e =====> \x y z -> e
12:03:21 <Cale> So the idea is that this replaces something like  Integer -> (forall a. (a -> a) -> (a -> a)) with  forall a. Integer -> (a -> a) -> (a -> a) ?
12:03:53 <mmorrow> forall a. A (forall b c. b (Maybe c))   ====>  forall a b c. A (b (Maybe c))
12:04:10 <Cale> Oh...
12:04:16 <Cale> hmm...
12:04:25 <Cale> Is that a valid transformation?
12:04:31 <nominolo> tibbe|work: pong
12:04:45 <tibbe|work> nominolo: did you want something? :)
12:04:47 <Cale> I suppose it's something you can do to a type.
12:05:10 <nominolo> tibbe|work: I forgot.  But I sent you a pull request
12:05:12 <BMeph> gio123: Maybe the MIT library does. It's pretty old, so it's unlikely to be outside of microfilm. :)
12:05:37 <mmorrow> Cale: hmm, i think i just gave a bad example
12:05:49 <nominolo> tibbe|work: for a one-character patch ;)
12:05:49 <mmorrow> oh, no
12:06:03 <mmorrow> Cale: so in forall a. A (forall b c. b (Maybe c)
12:06:27 <mmorrow> the (forall b c. b (Maybe c)) is the result of just having expanded and substituted in a type sysnonym
12:06:43 <mmorrow> so the ====> forall a b c. A (b (Maybe c))
12:06:49 <mmorrow> is necessary to normalize it
12:06:55 <Cale> er, is that really what is expected?
12:07:08 <mmorrow> type A a b = a b
12:07:22 <Cale> oh.
12:07:34 <Cale> er...
12:07:46 <mmorrow> lemme find the example that actually illustrates it
12:08:19 <mmorrow> , src ''A
12:08:20 <mmorrow> , src ''B
12:08:22 <mmorrow> , src ''C
12:08:24 <lunabot>  type A x = [x]
12:08:28 <Cale> It would seem to me that ordinarily if you want to push foralls around in types, you have to at least be very careful about ->
12:08:29 <lunabot>  type B f = forall x . f x
12:08:34 <lunabot>  type C f = f Integer
12:08:51 <mmorrow> B A
12:08:57 <mmorrow> i think
12:09:24 <Saizan> Cale: yeah, you can do that only if the forall is on the RHS of ->
12:09:30 <Cale> Saizan: right.
12:09:40 <tibbe|work> nominolo: cool
12:09:46 <tibbe|work> nominolo: will look when I get home
12:10:35 <mmorrow> but the hoisting in this ctxt is being done after just having expanded a type syn, so the Type you're then transforming starts out not being correctly formed, and hoistT repairs it
12:11:12 <mmorrow> so the incoming Type is not correct
12:11:15 <Cale> mmorrow: Shouldn't B A = forall x. [x] ?
12:12:16 <Cale> mmorrow: What is it actually getting?
12:12:30 <mmorrow> , , (ppDoc . elimSyns) `fmap` [t| C A |]
12:12:32 <lunabot>  luna: parse error on input `('
12:12:35 <mmorrow> , (ppDoc . elimSyns) `fmap` [t| C A |]
12:12:40 <lunabot>  [Integer]
12:12:41 <mmorrow> , (ppDoc . elimSyns) `fmap` [t| B A |]
12:12:46 <lunabot>  forall f_0 . f_0 (forall x_1 . [x_1])
12:13:44 <mmorrow> the case that prompted me to write that function (i may have named it inappropriately) was trying to expand (C A)
12:15:28 <rwbarton> Cale: Here is a contrived example; by definition any real example would be too complicated :)
12:15:47 <rwbarton> Cale: Suppose I want to find the number of divisors of a number.  I have a handy function smallestPrimeFactor available
12:16:03 <mmorrow> (C f) $ A ==> C A ==> C (forall x. [x]) ==> (forall x. [x]) Integer ==> [Integer]
12:16:08 <rwbarton> Cale: I might reason: If n = pm, then every factor of n is either a factor of m or p times a factor of m
12:16:28 <rwbarton> Cale: and then write   numDivisors 1 = 1; numDivisors n = 2 * numDivisors (n `div` smallestPrimeFactor n)
12:16:46 <rwbarton> I try it out on 30, and it works great!  Then I try it out on 50, and it doesn't work great.
12:16:54 <mmorrow> err,
12:16:56 <mmorrow> C A ==> C (forall x. [x]) ==> (forall x. [x]) Integer ==> [Integer]
12:17:30 <mmorrow> and i was at first doing
12:17:50 <mmorrow> no wait
12:17:53 <rwbarton> Now, obviously in this case I might be able to figure out why the recursive case is false.  But imagine it's something more complicated--and now I know that it's wrong, but not why
12:18:30 <mmorrow> this is what i did first:
12:18:32 <rwbarton> So now I'd do something like this:  I know numDivisors 50 uses numDivisors 25, so I check whether the second one is right--it's not
12:18:33 <mmorrow> C A ==> C (forall x. [x]) ==> (forall x. [x]) Integer
12:18:38 <mmorrow> wrong
12:18:45 <mmorrow> so i had to
12:18:51 <rwbarton> I know numDivisors 25 uses numDivisors 5, so I check whether the second one is right--it is
12:19:07 <conal> dons: checkers and unamb are now hackage'd.  thanks for the tip.
12:19:17 <mmorrow> then apply this somehow (forall x. [x]) Integer, and hoistT is what i came up with
12:19:24 <rwbarton> Now I have a concrete example where my logic was wrong, so I can inspect why it broke down.  (That's not something the computer will help me with)
12:19:46 <Peaker> quick example of a Functor which is not Applicative?
12:19:57 <ziman> Set
12:20:10 <Peaker> ziman: why is it not applicative?
12:20:13 <mmorrow> Cale: err, i can't really recall what what happening :)
12:20:17 <Cale> ziman: If Set is a Functor, then it's a Monad, not just Applicative.
12:20:30 <mauke> can't have a Set of functions
12:20:53 <tromp__> Set x requires Eq x?
12:20:54 <ziman> hm or maybe it's not even a functor?
12:21:12 <gwern> @seen Cale
12:21:12 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I last heard Cale speak 55s ago.
12:21:24 <gwern> Good news, everyone!
12:21:24 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
12:21:28 <lilac> rwbarton: iirc hat has a diagnostic mode where it will help you perform exactly that operation
12:21:43 <gwern> Cale: I think qualified imports are now working in darcs mueval
12:21:44 <ziman> Peaker, because there's no way to write `pure' for functions (tht's why it's not Applicative)
12:21:57 <gwern> Cale: at least, the classic M.map example is now working it seems
12:21:59 <gwern> @messages
12:21:59 <lambdabot> ivanm asked 1d 5h 20m 46s ago: what exactly does your change-monger app do?
12:22:01 <ziman> but fmap (const id) won't work too, i guess
12:22:04 <Cale> rwbarton: I suppose, and I admit there are cases where looking at specific failing examples can help, supposing that they're sparse enough.
12:22:24 <mmorrow> Cale, Saizan: here's the full code giving hoistT context: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=331
12:22:36 <gwern> @tell ivanm change-monger was an idea of mine: wouldn't it be nice if cabal could automatically write a CHANGELOG or NEWS file and include it in an sdist tarball?
12:22:36 <lambdabot> Consider it noted.
12:23:04 <gwern> @tell ivanm of course, that info is locked up in one's DVCS, so one needs some git-specific way, some darcs-specific way, etc. to get all the changes since the last version.
12:23:04 <lambdabot> Consider it noted.
12:23:21 <gwern> @tell ivanm so change-monger was my attempt at compiling in one place the necessary commands
12:23:21 <mmorrow> and these too http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=331#a332
12:23:21 <lambdabot> Consider it noted.
12:23:49 <Cale> gwern: Oh, interesting. I'll darcs pull then :)
12:23:50 <gwern> @tell ivanm unfortunately, parsing CVS logs is mad difficult, and no one seemed to like my idea, so I haven't done anything with change-monger in a while
12:23:51 <lambdabot> Consider it noted.
12:24:19 <Cale> gwern: How about specific imports?
12:24:29 <rwbarton_> Cale: Whether you run into this situation depends heavily on your problem domain.  It seems to come up mostly in programming competitions :)
12:25:19 <Cale> rwbarton_: I would be more likely to go back and try to prove that my original idea was right, and find the flaw there.
12:25:26 <geezusfreeek> rwbarton_, perhaps that is because there is so little time to think that many solutions are just guesses? :)
12:25:30 <Cale> But maybe I'm strange.
12:26:11 <dcoutts> gwern: it would be cool, file a feature (though I have the slight feeling there might be a related ticket already)
12:26:32 <rwbarton_> Cale, geezusfreeek: it's probably a little of both: surely if you had a counterexample to your original idea, you'd be able to find the flaw faster.
12:26:33 <gwern> dcoutts: ...I did
12:26:36 <rwbarton_> (assuming it's sufficiently small.)
12:26:55 <dcoutts> gwern: oh, I think the existing ticket is about being able to specify a changelog and having hackage display it, while you want automatic generation based on darcs change or git or whatever
12:26:57 * gwern notes with interest that obama on intrade is now up to 85% to win. I guess that mystery mccain trader has given up
12:27:11 <gwern> dcoutts: no, I am reasonably sure my ticket is about cabal generating the changelog
12:27:23 <gwern> although specifying a changelog file is certainly a good step I suppose
12:27:28 <Cale> rwbarton_: Right... often the test case which is failing has lots of ridiculous nonsense in it which doesn't contribute much to telling you why your reasoning was invalid. But if it's anything close to minimal, then it might help.
12:29:22 <rwbarton_> Peaker: I don't know of an example, but there are sometimes several ways to make the same Functor an instance of Applicative.
12:29:58 <gwern> @tell byorgey btw, I liked your summary of the lb ANN :)
12:29:58 <lambdabot> Consider it noted.
12:30:55 <gwern> night everyone
12:31:13 <dcoutts> gwern: ah yes you filed #244 and the other one is #299
12:31:29 <rwbarton_> Peaker: So saying that a Functor "is" an Applicative isn't really the best point of view.  It's like saying the integers are a monoid, without specifying which operation you have in mind
12:32:28 <rwbarton_> Peaker: I don't know whether every Functor can be made into an Applicative in at least one way though.  It seems just barely possible to me
12:34:06 <dolio> I'm pretty sure there are functors that aren't applicative.
12:34:56 <ziman> are there functors that cannot have join? (and therefore are not monads)
12:35:06 <dolio> Yes.
12:35:29 <ziman> could you give an example?
12:35:50 <dolio> Hmm...
12:36:40 <rwbarton_> Well, a stupid example of a functor that cannot be a monad is the constant functor on the empty set (data Void a)
12:37:11 <mmorrow> this function's amusing to look at http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=331#a333
12:37:16 <rwbarton_> (because you cannot write return)
12:37:56 <ziman> hm
12:37:58 <rwbarton_> I guess that applies to Applicative, too.
12:38:33 <ziman> so fmap and join don't make up a monad; you need return, too
12:38:35 <olsner> mmorrow: ooh, is that a 64-tuple?
12:38:36 <dolio> , src ''Context
12:38:41 <lunabot>  data Context s a = Context (s -> a) s
12:38:47 <olsner> I've only seen them go to 17 in the real world :)
12:38:51 <rwbarton_> It would be more interesting to have a functor m together with return :: a -> m a that couldn't be made into a monad
12:39:45 <ziman> i guess i'll have to stop thinking about functors as containers because they can always be joined in a natural way...
12:39:48 <mmorrow> olsner: heh, i think GHC actually can't do >63
12:40:17 <mmorrow> , $(tupE (fmap list [1..63::Int]))
12:40:18 <lunabot>  luna: Not in scope: `list'
12:40:23 <mmorrow> , $(tupE (fmap lift [1..63::Int]))
12:40:25 <lunabot>  luna: A 63-tuple is too large for GHC
12:40:30 <mmorrow> , $(tupE (fmap lift [1..62::Int]))
12:40:32 <lunabot>  luna: No instance for (GHC.Show.Show
12:40:42 <mmorrow> ah, make that >62
12:41:02 <mmorrow> i think the Show instances only go to some teen
12:41:08 <mmorrow> , $(tupE (fmap lift [1..10::Int]))
12:41:11 <lunabot>  (1,2,3,4,5,6,7,8,9,10)
12:41:13 <mmorrow> , $(tupE (fmap lift [1..12::Int]))
12:41:16 <lunabot>  (1,2,3,4,5,6,7,8,9,10,11,12)
12:41:19 <mmorrow> , $(tupE (fmap lift [1..15::Int]))
12:41:22 <lunabot>  (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
12:41:26 <mmorrow> , $(tupE (fmap lift [1..19::Int]))
12:41:29 <lunabot>  luna: No instance for (GHC.Show.Show
12:41:33 <mmorrow> , $(tupE (fmap lift [1..17::Int]))
12:41:36 <lunabot>  luna: No instance for (GHC.Show.Show
12:41:39 <mmorrow> , $(tupE (fmap lift [1..16::Int]))
12:41:41 <lunabot>  luna: No instance for (GHC.Show.Show
12:41:43 <mmorrow> 15
12:41:53 <dolio> Context s (Context s a) = (s -> Context s a, s) = (s -> (s -> a, s), s) which doesn't really admit a good return, although I guess you can join them.
12:42:17 <rothjl> hey guys, i'm kinda new to haskell... i've a custume data type and now i want to create an instance of it so i can use it's functions...what is the call to actuall create the object?
12:42:25 <olsner> mmorrow: well, that's only the ones with Show instances though
12:42:36 <mmorrow> yes
12:43:06 <ziman> , $(tupE (fmap lift [1..256::Int]))
12:43:09 <lunabot>  luna: A 256-tuple is too large for GHC
12:43:23 <rwbarton_> rothjl: did you create a 'class' or a 'data'?
12:43:24 <mmorrow> , $(tupE (fmap lift [1..63::Int]))
12:43:27 <lunabot>  luna: A 63-tuple is too large for GHC
12:43:28 <mmorrow> , $(tupE (fmap lift [1..62::Int]))
12:43:30 <lunabot>  luna: No instance for (GHC.Show.Show
12:44:18 <rothjl> i createdd data
12:44:43 <mmorrow> what's the data definition?
12:44:57 <mmorrow> data A a b c = A a | B b c | C a b c
12:44:59 <mmorrow> then
12:44:59 <vixey> heyyy
12:45:25 <vixey> can you derive something that gives
12:45:29 <vixey> f (A _) = 0
12:45:32 <vixey> f (B _ _) = 1
12:45:34 <vixey> f (C _ _ _) = 2
12:45:41 <mmorrow> B 200 (A "hai")
12:45:45 <mmorrow> A 42
12:45:59 <mmorrow> C () [0..9] "asd"
12:46:01 <olsner> hmm, so what's producing the error message? ghc? it seems weird to partially support arbitrarily large tuples only to be able to print an error message about it being too large :P
12:46:15 <mmorrow> olsner: totally!
12:46:22 <Cale> rothjl: The constructors are.
12:46:42 <Cale> rothjl: For instance, if you defined something like   data Tree a = Tip | Branch a (Tree a) (Tree a)
12:46:43 <rothjl> anyone know how to create an instance of a custom data type?
12:46:51 <mmorrow> olsner: there's a comment saying what you just said somewhere, lemme find it..
12:47:02 <Cale> rothjl: then you write  Branch 5 (Branch 3 Tip Tip) (Branch 7 Tip Tip)
12:47:16 <lucca> rothjl: when you used 'data' you gave the name of the constructors, yes?  Just use the constructors
12:47:27 <lucca> in that tree example, Tip and Branch are constructors
12:48:11 <vixey> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=319 - lol
12:48:29 <vixey> this idFoldExp = FoldExp VarE ConE LitE AppE InfixE LamE TupE CondE LetE CaseE DoE CompE ArithSeqE ListE SigE RecConE RecUpdE - great
12:49:16 <rothjl> well my constructor does take any data, so i would just type the name of the constructer to create the onject?
12:49:49 <rothjl> doesn't take*
12:49:59 <rwbarton_> Yep.
12:50:03 <rwbarton_> @src Bool
12:50:03 <lambdabot> data Bool = False | True deriving (Eq, Ord)
12:50:06 <rwbarton_> > False
12:50:07 <lambdabot>   False
12:50:10 <rwbarton_> etc.
12:50:12 <rothjl> data Ship_p =
12:50:12 <rothjl>     Ship_p {...}
12:50:20 <mmorrow> olsner: goo, i can never find that when i
12:50:25 <mmorrow> 'm looking for it
12:50:26 <rothjl> so ship_p?
12:50:32 <rwbarton_> oh, what's in the {...}?
12:50:55 <rothjl> {...} stuff i coded
12:51:04 <rwbarton_> Can you hpaste the whole declaration?  http://hpaste.org
12:51:34 <rothjl> k 1 sec
12:51:47 <vixey> mmorrow, have you ever heard of lazy lambda calculus with tagged vectors?
12:52:25 <rothjl> it's up
12:52:30 <mmorrow> vixey: hmm, i'm not sure. what's the context of that?
12:53:15 <vixey> mmorrow, I wrote out the semantics for it ( http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=330 ), trying to find out if someone before me wrote a compiler for it I can use
12:53:32 <rwbarton_> rothjl: OK, you have two options
12:53:41 <vixey> seems like I am probably not going to finde it
12:53:51 <rothjl>  Ship_p(0,0,0,0,0,0)?
12:53:53 <rwbarton_> rothjl: You can write   Ship_p 2 5 3 1 9 6  to assign those fields in order
12:54:11 <rwbarton_> rothjl: or you can write  Ship_p { avx = 2, avy = 5, vz = 3, x = 1, y = 9, z = 6 }
12:54:13 <rothjl> ok and the other option
12:54:20 <rwbarton_> (and then you can put them in whatever order you want)
12:54:25 <rothjl> nice, thank you very much
12:54:48 <rothjl> this channel is such a time savor
12:55:14 <rothjl> actually the people are but you know what i mean
12:56:32 <pcc1> I have rewritten some code to use arrows, resulting in an abundance of Kleisli and runKleisli which does not look appealing.  is this the ideal approach?
12:57:12 <Philippa> pcc1: what did you reckon you were getting out of the rewrite?
12:58:03 <Philippa> and can you at least format the runKleisli calls neatly? (it ought to be possible)
12:59:21 <pcc1> the code is better but I have things like "Kleisli (mapM (runKleisli (Kleisli (..."
13:00:04 <questionaire> Hello everybody - i would like to ask a question about concatinating functions und the uncurry function ...
13:00:06 <mmorrow> vixey: i was just reading this last night, and want to implement it or similar. it's similar to the STG machine http://www.cs.uu.nl/research/techreps/repo/CS-2004/2004-052.pdf
13:00:19 <lambdabot> Title: The Lazy Virtual Machine specification
13:00:46 <mmorrow> i found it /very/ enlightening
13:01:12 <vixey> mmorrow: ok, from the intro it sounds exactly like what I was looking for
13:01:15 <opqdonut> questionaire: well go ahead and ask :)
13:01:15 <mmorrow> i guess it's somewhat of a half answer to your question
13:01:26 <mmorrow> vixey: totally
13:01:36 <vixey> is there code though?
13:01:42 <mmorrow> heh, no :(
13:01:56 <questionaire> its like: when i want to cancat 2 funtions and one of them is curried i get errors - this can be fixed with uncurry, but i think there is no function like
13:01:59 <mmorrow> err, actually they say it was used for Helium
13:02:03 <questionaire> "uncuryy this n times"
13:02:10 <mmorrow> so maybe in the Helium sources, but i haven't looked
13:02:26 <vixey> I thought I read that helium was 100x slower than hugs ..
13:02:35 <mmorrow> haha, i dunno
13:02:52 <mmorrow> at the end of that paper though, they give some benchmarks of that VM vs hugs
13:02:58 <mmorrow> and it crushes hugs
13:03:44 <mmorrow> and that VM + instructions are very similar to the bytecode for the STG machine that ghci uses
13:03:54 <mmorrow> (which is why i initially read it)
13:04:14 <mmorrow> http://moonpatio.com/docs/ghc/src/ByteCodeInstr.html
13:04:15 <lambdabot> Title: ghci/ByteCodeInstr.lhs
13:04:29 <mmorrow> http://moonpatio.com/docs/ghc/src/ByteCodeGen.html
13:04:30 <lambdabot> Title: ghci/ByteCodeGen.lhs
13:04:35 <mmorrow> http://moonpatio.com/docs/ghc/src/ByteCodeAsm.html
13:04:36 <lambdabot> Title: ghci/ByteCodeAsm.lhs
13:04:42 <mmorrow> http://moonpatio.com/docs/ghc/src/ByteCodeItbls.html
13:04:43 <lambdabot> Title: ghci/ByteCodeItbls.lhs
13:04:46 <mmorrow> http://moonpatio.com/docs/ghc/src/ByteCodeLink.html
13:04:47 <lambdabot> Title: ghci/ByteCodeLink.lhs
13:04:59 <mmorrow> all in this dir: http://moonpatio.com/docs/ghc/src/
13:05:00 <lambdabot> Title: Index of /docs/ghc/src
13:05:09 <mmorrow> and haddock docs http://moonpatio.com/docs/ghc/
13:05:10 <lambdabot> Title: ghc-6.10.0.20081007: XXX
13:05:49 <mmorrow> and the actual interpreter is
13:05:50 <mmorrow> http://darcs.haskell.org/ghc/rts/Interpreter.c
13:06:14 <mmorrow> Interpreter.c is "amusing"
13:06:51 <mmorrow> it's got nice comments with ascii diagrams of the stack at diff points as well
13:07:39 <vixey> o_o
13:07:44 <mmorrow> hehe
13:07:54 <vixey> why is nfib n = 1 + nfib (n-1) + nfib (n-2)
13:08:03 <mmorrow> haha
13:11:39 <questionaire> gn8 guys
13:11:56 <tromp__> vixey: that'd be recursion for getting fibonacci numbers minus 1
13:13:44 <Saya> and i thought ghc was made in haskell!
13:13:58 <Saya> what a disapointement :(
13:14:07 <mmorrow> Saya: that's the /bytecode/ interpreter for ghci
13:15:02 <Saya> dont care :p its no excuse
13:15:36 <mmorrow> here's (part of) the lowest level of ghc's haskell rts http://darcs.haskell.org/ghc/rts/Apply.cmm
13:15:40 <mmorrow> c minus minus
13:15:50 <Saizan> mmorrow: re hoist: nice use of forall to emulate lambda :)
13:16:10 <mmorrow> Saizan: heh, i found that amusing as well
13:17:08 <mmorrow> it changed how i looked at foralls too
13:17:33 <Saya> wow c minus minus never heard of that
13:17:41 <olsner> forall to emulate lambda? are we talking type-system programming again?
13:18:20 <Saya> isnt c small enough a language already?
13:18:33 <vixey> C isn't very good at all
13:18:35 <mmorrow> olsner: in the context of expanding/applying-and-simplifying types/tysyns
13:18:45 <aeolist> c is assembly on steroids
13:18:57 <mmorrow> Saya: C lacks the ability to jmp
13:19:00 <vixey> _on_ steriods?
13:19:08 <vixey> don't you mean, off steriods and reaching 90 years old ?
13:19:21 <aeolist> i mean, glorified assembly? pumped up assembly?
13:19:38 <mmorrow> C forces all function calls to return to the place they were called from, which is one of the restrictions c-- lifts
13:19:54 <Saya> oh so its basically assembly with a nice syntax
13:20:01 <mmorrow> they call c-- a "portable assembly lang"
13:20:06 <mmorrow> exactly
13:20:07 <aeolist> vixey: am i politically correct now? :P
13:20:09 * pjdelport longjmps over mmorrow 
13:20:16 <Philippa> vixey: nah, steroids don't necessarily have a beneficial effect. Think dumb and aggressive
13:20:37 <vixey> ahah, that works
13:20:38 <mmorrow> heh, setjmp.h is sooo botleg :)
13:20:44 <Taggnostr> is ocaml similar to haskell?
13:20:52 <Philippa> Taggnostr: somewhat
13:20:57 <pjdelport> Taggnostr: they are both computer languages
13:20:58 <aeolist> they are both functional
13:21:06 <Philippa> although ocaml is impure and strict
13:21:12 <aeolist> and eager
13:21:17 <Philippa> see "strict"
13:21:18 <vixey> and call by value!
13:21:18 <aeolist> and has some object oriented elements to it
13:21:20 <Saya> and the O
13:21:24 <rwbarton_> Their type systems are based on the same foundation
13:21:25 <aeolist> Philippa: sorry, i failed
13:21:33 <aeolist> and they are french
13:21:34 <Taggnostr> do you think it will be hard to translate http://www.ffconsultancy.com/ocaml/sudoku/index.html to haskell?
13:21:43 <Philippa> ocaml's module system is similarly powerful to type classes but has a very different emphasis
13:21:43 <lambdabot> Title: OCaml tutorials and examples
13:21:54 <Philippa> ocaml's got good support for extensible records and variants
13:21:55 <vixey> Taggnostr: If you are asking 'will this be hard' it will probably be kind of tricky ..
13:22:37 <Taggnostr> I don't know ocmal at all, and I know just a few things about haskell
13:22:50 <rwbarton_> Taggnostr: Looks like it should be easy if you don't care about runtime
13:23:13 <saml> is there eager pattern matching in haskell?
13:23:26 <saml> > let k a $! b = a in k 1 undefined
13:23:28 <lambdabot>   <no location info>: Parse error in pattern
13:23:45 <rwbarton_> Taggnostr: also, there's a page on the haskell wiki with several sudoku solver implementations :)
13:23:51 <rwbarton_> > let k a !b = a in k 1 undefined
13:23:52 <lambdabot>   <no location info>: Parse error in pattern
13:24:16 <Taggnostr> I was searching something fun and not really hard to do with haskell :P
13:24:17 <rwbarton_> saml: yes, using that syntax and -XBangPatterns
13:24:29 <saml> rwbarton_: ah thanks
13:24:34 <rwbarton_> saml: it just means  let k a b = b `seq` a  in this case
13:24:44 <rwbarton_> , let k a !b = a in k 1 undefined
13:24:47 <lunabot>  luna: Prelude.undefined
13:24:50 <rwbarton_> there :)
13:24:58 <saml> cool
13:25:52 <Deewiant> , let k a !_ = a in k 1 undefined
13:25:54 <lunabot>  luna: Prelude.undefined
13:26:25 <opqdonut> Deewiant: heh, didn't know that works
13:26:40 <opqdonut> well, no reason for it not to
13:27:05 <rwbarton_> , let seq !_ b = b in undefined `seq` 1
13:27:08 <lunabot>  luna: Prelude.undefined
13:27:15 <Saya> Taggnostr i dont think its that hard to translate from ocaml to haskell but im no expert :<
13:27:33 <Taggnostr> I could try and see what happen
13:27:34 <vixey> you may need and ocaml monad
13:27:50 <Deewiant> opqdonut: I didn't either, hence I tried it :-)
13:27:51 <Taggnostr> maybe this weekend
13:28:04 <Philippa> Saya: It depends on the code. Extensible records and variants can be a pain in the arse to translate
13:28:11 <Saya> or you could try to do it from scratch instead of translating
13:29:00 <Philippa> Taggnostr: why do you want to translate it, anyway?
13:29:13 <Saya> yeah well i dont really know ocaml exept for the syntax :p
13:29:44 <Taggnostr> I'd like to see how it works and in the meanwhile learn some more haskell
13:30:28 <Philippa> fair enough. It's just not necessarily the best way to do a solver in Haskell
13:30:54 <Taggnostr> I thought it was quite complex to do it, this seems quite easy
13:35:49 <slang> hello everyone
13:36:17 <roconnor> IIRC the salt for a password doesn't need to be cyrpto secure, since it ought to be considered public information.
13:36:37 <roconnor> what is most important is that your salts are (likely) different from everyone elses.
13:37:08 <slang> I'm trying to wrap my brain around how to encapsulate a monad transformer into the mkQ and everything generics stuff
13:39:24 <slang> my query function uses another function that requires a state transformer monad
13:40:37 <slang> so its something like isBlocking :: a -> Walker (Maybe Int)
13:40:52 <walrus>  /quit
13:41:09 <slang> but that doesn't really work, because mkQ really needs a function that returns Maybe Int
13:41:56 <rwbarton_> try mkM?
13:42:08 <slang> rwbarton_: hi
13:42:13 <slang> rwbarton_: I tried that first actually
13:42:19 <tibbe_> nominolo: you have a type in your change description ;)
13:42:37 <slang> rwbarton_: the problem there was that mkM needs a -> m a
13:43:36 <nominolo> tibbe_: oh.. dvorak typo
13:44:05 <nominolo> if you don't mind, i don't mind
13:44:52 <rwbarton_> slang: you're trying to build something to pass to everywhere?
13:45:49 <slang> rwbarton_: I'm doing a query, so I was using everything
13:46:26 <rwbarton_> or everythingM maybe
13:46:33 <rwbarton_> oh let me take a look at that
13:46:45 <rwbarton_> ok
13:46:46 <tibbe_> nominolo: I'm very anal!
13:46:56 <Saizan> ?type mkQ
13:46:58 <lambdabot> forall r b a. (Typeable b, Typeable a) => r -> (b -> r) -> a -> r
13:47:07 <slang> rwbarton_: you mean everywhereM?
13:47:07 <nominolo> tibbe_: you want me to amend?
13:47:11 <nominolo> ok, lemme see
13:47:18 <rwbarton_> slang: no I think I get what you're doing now
13:47:29 <geezusfreeek> oh wow, looks like i might get to use haskell a little at work after all
13:47:35 <Saizan> slang: why can't you have r = Walker (Maybe Int) there?
13:47:37 <rwbarton_> slang: can you write a Walker (Maybe Int) -> Walker (Maybe Int) -> Walker (Maybe Int)?
13:48:04 <slang> rwbarton_: yes, but I'm not sure how that helps
13:48:10 <tibbe_> nominolo: please
13:48:25 <Peaker> rwbarton_: was afk
13:48:29 <slang> Saizan: hmm, I guess I could do that
13:48:47 <Peaker> rwbarton_: thanks for the explanation. Intuitively, I think there are probably some Functors that cannot be made into Applicatives
13:49:03 <Philippa> I'd be extremely surprised if there weren't
13:49:04 <vixey> @src Applicative
13:49:04 <lambdabot> class Functor f => Applicative f where
13:49:04 <lambdabot>     pure  :: a -> f a
13:49:04 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
13:49:15 <slang> Saizan: I'm calling everything within the runStateT code though
13:49:18 <rwbarton_> Peaker: the boring example was data Void a {- = nothing -}
13:49:23 <Peaker> Philippa: I'm looking for examples ;)
13:49:27 <vixey> Void a isn't an applicative?
13:49:35 <Philippa> rwbarton_: that surprises me, it's a valid monad
13:49:42 <rwbarton_> Philippa: what is pure/return?
13:49:46 <slang> Saizan: how do I get at the Walker being threaded through...
13:49:55 <Philippa> rwbarton_: pure is const undefined
13:49:58 <Saizan> slang: you should use runState on the result of everything
13:50:16 <rwbarton_> Philippa: Well, if you're going to play that game, you can do it for any functor :)
13:50:19 <vixey> there is no total function a -> f a that's true ....
13:50:38 <Philippa> rwbarton_: not necessarily
13:50:39 <rwbarton_> Philippa: I was thinking we were working in the category Set
13:50:48 <Philippa> we never are
13:50:55 <rwbarton_> I always am
13:50:56 <Philippa> CPO rather than set, at a bare minimum
13:51:19 <Philippa> no, you're not. The denotation for the untyped lambda calculus is in terms of CPO
13:51:31 <slang> Saizan: within the other runStateT, or instead of my current runStateT?
13:51:35 <Philippa> Set isn't good enough
13:52:01 <rwbarton_> I don't see why you assume I'm thinking about a Haskell program.
13:52:06 <Saizan> slang: everything (>>) mkQ (return Nothing) isBlocking foo :: Walker (Maybe Int) <- then you can do what you wish with it
13:52:10 <rwbarton_> There's clearly a more natural question for the category of sets.
13:52:30 <Saizan> slang: everything (>>) (mkQ (return Nothing) isBlocking) foo :: Walker (Maybe Int), actually
13:52:30 <Philippa> rwbarton_: okay, fair enough, we're mixing applicatives and Applicatives
13:53:12 <Saizan> slang: does that make sense? i'm making wild guesses on what you want to do
13:53:24 <slang> Saizan: I'll have to think about it
13:53:40 <slang> Saizan: sorry -- I'm a little new to haskell
13:53:54 <dolio> rwbarton_: Even though the functions for Applicative etc. are inhabited, they may not satisfy the required laws if you just return bottom.
13:54:10 <nominolo> tibbe_: ok, i pushed it to the for-tibbe branch
13:54:10 <vixey> what are the laws
13:54:16 <dolio> Although, they would for Void.
13:54:17 <vixey> @laws Applicative
13:54:18 <lambdabot> Unknown command, try @list
13:54:19 <nominolo> now i have to figure out how to rename a remote tag
13:54:33 <nominolo> er branch
13:54:40 <dolio> The obvious ones. Just like for Monad.
13:54:47 <Saizan> slang: no problem, generics can also be confusing
13:55:35 <dolio> pure f <*> a = fmap f a...
13:55:36 <tibbe_> nominolo: thanks!
13:55:45 <tibbe_> nominolo: will pull it as soon as I finish work
13:55:55 <dolio> f <*> pure a = fmap ($a) f
13:55:58 <nominolo> tibbe_: be sure to pull from the right branch
13:56:57 <geezusfreeek> apparently somebody at VMware likes haskell. the Emmett compiler (compiles a C-like language to VProbes source) is written in haskell
13:57:28 <dolio> fmap f (pure a) = pure (f a)
13:57:40 <rwbarton_> What law would be violated by defining pure = undefined, (<*>) = undefined?
13:58:18 <rwbarton_> (Doesn't the type system prove there is no such law?)
13:58:43 <vixey> so..
13:58:47 <dolio> I don't have one for Applicative, but I have one for Monad.
13:58:50 <vixey> if you define <*> by cases,
13:59:01 <vixey> f <*> x = case f of
13:59:21 <nominolo> tibbe_: ah, apparently --force works, too
13:59:24 <dolio> [1,2,3] >>= return = [1,2,3] fails if you defined (>>=) as undefined.
13:59:41 <vixey> dolio, but [a] is inhabited, what if you have Void a
13:59:42 <vixey> ?
13:59:55 <dolio> I said it was fine for Void.
13:59:58 <vixey> oh ok
14:00:09 <rwbarton_> Oh, hmm
14:00:18 <vixey> I agree but tere should be a way to rule out the definition
14:00:26 <vixey> pure _ = undefined
14:00:29 <rwbarton_> OK, I am sure I could cook up one for Applicative too then.
14:00:30 <vixey> because this is not really ok
14:00:33 <dolio> But rwbarton_ said "you can [play that game] for any functor".
14:00:46 <opqdonut> vixey: why?
14:00:51 <dblazakis> > take 4 [1,2]
14:00:52 <lambdabot>   [1,2]
14:01:19 <rwbarton_> dolio: []s?  Those were my exact words :)
14:01:19 <opqdonut> oh, now i see where this discossuon came from
14:01:21 <vixey> opqdonut: It's not really a function from a -> Void a
14:01:26 <vixey> well it is..... but ....
14:01:30 <opqdonut> :=
14:01:31 <tibbe_> nominolo: so i'll pull from for_tibbe later
14:01:36 <opqdonut> *:)
14:01:55 <dolio> Well, I had to rearrange some words. :)
14:02:28 <nominolo> tibbe_: i overrode master, so it doesn't matter anymore.
14:02:38 <dolio> Anyhow, similarly, if pure = <*> = undefined, then pure id <*> [1,2,3] = fmap id [1,2,3] = [1,2,3] fails.
14:02:42 <tibbe_> nominolo: ok
14:02:56 <Peaker> is there any particular reason that "pure" is in Applicative, and not in Functor?
14:03:20 <nominolo> Peaker: why would you want pure in functor?
14:03:20 <bd_> Peaker: what would pure :: a -> [a] be?
14:03:32 <vixey> (:[])
14:03:35 <Peaker> nominolo: why would you want it in Applicative?
14:03:35 <nominolo> pure = return
14:03:46 <bd_> how about pure :: Ord k => a -> Map k a? :)
14:03:49 <rwbarton_> What would pure :: a -> Void a be? :
14:03:50 <rwbarton_> :)
14:04:10 <dolio> pure is not part of the definition of a functor.
14:04:18 <nominolo> Peaker: you cannot define pure for every functor
14:04:26 <dolio> It's part of the definition of a pointed functor, but not all functors are pointed.
14:04:31 <Peaker> nominolo: examples?
14:04:47 <dolio> Like, various comonads.
14:04:58 <dolio> Which are copointed.
14:05:04 <Peaker> So comonads are generally Functors but not Applicatives?
14:05:06 <nominolo> instance for (->) ?
14:05:12 <Peaker> (Note I don't know any category theory, just asking about Haskell classes)
14:05:38 <bd_> Peaker: I gave an example of a functor you can't define pure for with Map
14:05:46 <bd_> :t fmap :: Ord k => a -> Map k a
14:05:47 <lambdabot> Not in scope: type constructor or class `Map'
14:05:51 <bd_> :t fmap :: Ord k => a -> Data.Map.Map k a
14:05:52 <lambdabot>     Couldn't match expected type `M.Map k a'
14:05:53 <lambdabot>            against inferred type `f a1 -> f b'
14:05:53 <lambdabot>     Probable cause: `fmap' is applied to too few arguments
14:05:57 <bd_> err
14:06:06 <Peaker> bd_: I'm sorry, I lost track of that discussion
14:06:07 <bd_> :t fmap :: Ord k => (a -> b) -> (Data.Map.Map k a -> Data.Map.Map k b)
14:06:08 <lambdabot> forall a b k. (Ord k) => (a -> b) -> M.Map k a -> M.Map k b
14:06:11 <bd_> right then
14:06:33 <Peaker> bd_: so Data.Map.Map cannot be made an Applicative?
14:06:34 <bd_> since you can't instantiate a key for Map in general, your only possibilities are undefined or Map.empty
14:06:49 <bd_> either of which throws away the argument for pure and thus isn't very useful
14:07:40 <Peaker> bd_: Cool, thanks
14:09:03 <dblazakis> why would "take 4 (empty :: Data.ByteString)" still be ambiguous with Prelude.take ?
14:09:40 <dolio> Because take isn't overloaded in a type class so that it can be resolved based on type.
14:09:59 <rwbarton_> I bet there isn't a module Data that exports a type called ByteString
14:10:49 <rwbarton_> I'm confused, wouldn't Prelude.take 4 (empty :: Data.ByteString.ByteString) just give a type error matching [a] against ByteString?
14:10:56 <dolio> That'd be a problem, too. Although he could have "import qualified Data.ByteString as Data" at the top of his file.
14:11:41 <dblazakis> oh, scratch the Data
14:11:46 <dblazakis> mistype
14:12:06 <rwbarton_> Anyways, I wouldn't expect it to be ambiguous, just a type error
14:12:21 <dolio> If both Prelude.take and Data.ByteString.take are in scope, it doesn't even get to type checking, because it can't decide which take to use.
14:12:38 <rwbarton_> Oh, I see.
14:12:57 <rwbarton_> (I thought the question was why is "Prelude.take 4 (empty :: ByteString)" still ambiguous)
14:13:24 <dblazakis> dolio: type inference won't determine the type of take to use?
14:13:44 <dolio> Not unless it's in a type class.
14:14:17 <dolio> Haskell doesn't do ad-hoc overloading.
14:14:25 <dblazakis> ah, so it really works because the function have different names
14:14:34 <dblazakis> module scope
14:14:38 <dolio> Right.
14:14:55 <dblazakis> thanks
14:16:47 <yakov> hello
14:17:01 <vixey> hi
14:17:53 <yakov> guys, could anybody please take a quick look http://hpaste.org/11586
14:18:32 <vixey> I did
14:18:49 <yakov> what do you think? how can I give GHC needed info?
14:19:02 <yakov> QT intened to be monad only for "checkable" types..
14:19:05 <Botje> feed it some smrt pills
14:19:17 <vixey> why don't you just not use Monad
14:19:25 <vixey> ?
14:19:30 <opqdonut> a restricted monad?
14:19:45 <yakov> opqdonut, what is this? redeclate Monad there?
14:20:03 <opqdonut> no
14:20:15 <opqdonut> restricted monads are when you want to restrict the types that go in
14:20:17 <yakov> vixey, because i want to write concise code
14:20:19 <Peaker> @hoogle Bool -> a -> a -> a
14:20:20 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
14:20:20 <lambdabot> Test.HUnit.Text PutText :: String -> Bool -> st -> IO st -> st -> PutText st
14:20:20 <lambdabot> Foreign.Marshal.Error throwIf :: a -> Bool -> a -> String -> IO a -> IO a
14:20:29 <Peaker> there's no "if" formulated as a function?
14:20:46 <opqdonut> so something like "instance (Foo a) => Monad (QT a)"
14:20:56 <opqdonut> they
14:21:02 <Saizan> Peaker: no
14:21:02 <yakov> vixey, having "return error code" checker built-in a monad allows me to forget about this thing..
14:21:04 <opqdonut> 're hard to express in the current type system
14:21:10 <rwbarton_> yakov: can you move the checking into wrappers for sGStop and sGSetDataRef?
14:21:11 <yakov> hm..
14:21:15 <yakov> i've tried this.
14:21:23 <vixey> oh
14:21:26 <Peaker> Saizan: how do you @pl stuff with if's in them? :)
14:21:36 <yakov> rwbarton_, sure i can!
14:21:44 <opqdonut> Peaker: if
14:21:46 <opqdonut> asdf
14:21:48 <yakov> but again this will lead to code duplication
14:21:50 <opqdonut> hate this keyboard
14:21:56 <yakov> which i don't want to create
14:21:58 <Saizan> @pl \x -> if x then foo else bar
14:21:59 <lambdabot> flip (flip if' foo) bar
14:22:03 <opqdonut> Peaker: if' is the folklore name for the correspnding function
14:22:31 <dolio> Although it should clearly be bool :: a -> a -> Bool -> a
14:22:40 <Peaker> opqdonut: oh
14:22:45 <opqdonut> dolio: :)
14:23:04 <yakov> opqdonut, so.. restricted monads as you wrote give Kind mismatch obviously
14:23:12 <Peaker> dolio: order the arguments from the least useful to change to the most?
14:23:14 <rwbarton_> yakov: I think it is the best solution.  It only needs to be one line of code per foreign import
14:23:21 <rwbarton_> yakov: one extra line of code I mean
14:23:23 <yakov> but anyway thx for the tip! i need to dig this topic deeper
14:23:24 <opqdonut> yakov: that was pseudo syntax
14:23:37 <dolio> Peaker: That's the usual idea.
14:24:28 <opqdonut> yakov: google "restricted monad", see for example http://hsenag.livejournal.com/11803.html
14:24:29 <lambdabot> Title: hsenag: Restricted monads in Haskell
14:24:38 <yakov> opqdonut, well, i need to find out how to express such thing then.. it's interesting
14:24:48 <yakov> aha
14:25:13 <Saizan> yakov: i think the best solution here is to have sGStop return IO () (or QT ()) and throw and exception if it gets an error
14:25:18 <yakov> heh, i already saw that post :-) and forgot about it when it is needed :-)
14:26:06 <yakov> Saizan, i dont find these solutions with hand-made wrappers aroung foreign calls beautiful :(
14:26:49 <rwbarton_> yakov: I don't see why not; it's unreasonable to expect that the foreign API is the optimal one from Haskell's point of view.
14:27:06 <Saizan> in this case i find restricting you on Checkable types even worse
14:27:50 <yakov> rwbarton_, Saizan you see all my foreign calls return that "error value" type so it's seems to be quite general
14:27:58 <yakov> to instantiate QT as a monad
14:31:24 <rwbarton_> yakov: It doesn't seem like you need to have QT be a monad, if you only ever consider the type QT ComponentResult
14:32:27 <slang> Saizan: I wrote an orElse for monads instead of using >>, but that set me on the right track
14:32:30 <slang> Saizan: thanks!
14:34:37 <Saizan> slang: cool :)
14:40:11 <Twey> @src (->) first
14:40:11 <lambdabot> first f = f *** id
14:40:32 <Twey> ... oh that's clever
14:40:35 <Twey> @src (->) second
14:40:36 <lambdabot> second f = id *** f
14:40:59 <Twey> What's the default implementation of second?
14:41:25 <rwbarton_> @src second
14:41:26 <lambdabot> Source not found.
14:41:40 <Saizan> arr swap >>> first f >>> arr swap, iirc?
14:41:45 <rwbarton_> Probably something like   arr (\~(x, y) -> (y, x)) >>> ... yeah
14:42:00 <Twey> Saizan: I tried that but the types apparently didn't match :(
14:43:00 <Saizan> are you sure it's not something else?
14:43:05 <Twey>     No instance for (Arrow (,))
14:43:08 <Twey> Aye
14:43:13 <rwbarton_> @type swap
14:43:14 <lambdabot> forall t t1. (t, t1) -> (t1, t)
14:43:16 <Twey> Hang on, I've got it defined...
14:43:22 <rwbarton_> @type arr swap
14:43:23 <lambdabot> forall t t1 (a :: * -> * -> *). (Arrow a) => a (t, t1) (t1, t)
14:43:28 <Twey> second :: (Arrow a) => a b c -> a (d, b) (d, c)
14:43:53 <Twey> Which is correct as far as I can tell
14:44:35 <Saizan> ?type \f -> arr swap >>> first f >>> arr swap
14:44:36 <lambdabot> forall t t1 (a :: * -> * -> *) c. (Arrow a) => a t1 c -> a (t, t1) (t, c)
14:45:24 <rothjl> Hey
14:45:34 <Twey> http://hpaste.org/11587 — the full error output
14:45:40 <rothjl> Is anyone familiar with HopenGL?
14:46:01 <Twey> (16 is second = arr swap >>> first >>> arr swap
14:46:10 <ddarius> @src first
14:46:11 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:46:16 <Twey> )
14:46:25 <rwbarton_> second f = arr swap >>> first f >>> arr swap
14:46:33 <vixey> first f = arr swap >>> second f >>> arr swap
14:46:34 <rwbarton_> or second = (arr swap >>>) . (>>> arr swap) . first
14:46:38 <Twey> Ah!
14:46:53 <Deewiant> second = first >>> (>>> arr swap) >>> (arr swap >>>)
14:47:04 <unenough> Baughn, can you tell Cheiron to join #enough?
14:47:19 <Twey> Aye, that works.  Heh
14:47:21 <Deewiant> second = (>>>) first ((>>>) (>>> arr swap) ((>>>) (arr swap)))
14:47:21 <Twey> Thanks :)
14:47:27 * Twey nods.  :)
14:48:40 <rothjl> does anyone know how to create an instance of a custume data structure in Hopengl? When i call the constructor in the main loop there is an error
14:48:44 <vixey> @w80 disseminate
14:48:47 <lambdabot> *** "disseminate" wn "WordNet (r) 2.0"
14:48:47 <lambdabot> disseminate
14:48:47 <lambdabot>      v : cause to become widely known; "spread information";
14:48:47 <lambdabot>          "circulate a rumor"; "broadcast the news" [syn: {circulate},
14:48:47 <lambdabot>           {circularize}, {circularise}, {distribute}, {propagate},
14:48:49 <lambdabot>           {broadcast}, {spread}, {diffuse}, {disperse}, {pass
14:48:52 <lambdabot>          around}]
14:51:43 <rwbarton_> rothjl: a compile-time error?
14:51:51 <rothjl> yes
14:52:38 <rothjl> i'm just not sure how or where to call my constructer
14:54:20 <unenough> Baughn, thanks
14:54:55 <rothjl> "Couldn't match experted type 'IO t' agaisnt inferred type 'Ship_p'"
14:56:37 <rwbarton_> rothjl: Maybe you wrote  x <- Ship_p 0 0 0 0 0 0  instead of  let x = Ship_p 0 0 0 0 0 0
14:56:39 <pastorn> @src foldr
14:56:39 <lambdabot> foldr f z []     = z
14:56:39 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:57:39 <pastorn> @src foldl
14:57:39 <lambdabot> foldl f z []     = z
14:57:39 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:57:46 <pastorn> @src foldr'
14:57:47 <lambdabot> Source not found. You type like i drive.
14:57:51 <pastorn> @src foldl'
14:57:51 <lambdabot> foldl' f a []     = a
14:57:51 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
14:58:17 <pastorn> what's the function that has a where clause with lgo and zgo
14:58:47 <pastorn> @src Data.List.foldl
14:58:47 <lambdabot> Source not found. Take a stress pill and think things over.
15:15:17 <vixey> cool
15:15:29 <vixey> there is a video about factor
15:17:53 <BMeph> vixey: Fear Factor? ;)
15:19:28 <yakov> bb
15:37:18 <lispy> Is it just me or is Data.Map really not that efficient?
15:39:26 <dons> lispy: mm?
15:39:30 <dons> its pretty good.
15:39:53 <lispy> I'm skeptical.  I think we could do better.
15:40:13 <Cale> Data.Map has always been way more than fast enough for me.
15:40:32 <dons> lispy: suggestions welcome :)
15:40:45 <dons> ashley yakeley thinks there are faster Maps out there
15:41:02 <Cale> It's quite possible. :)
15:42:06 <Cale> I'd be more interested though in fast relational structures where you have multiple indices.
15:42:12 <lispy> dons: I'm wondering if we could buy any performance for making a special map that hides some destructive updates behind a nice pure interface or some such.   Some sort of tricks we haven't considered in the past.
15:42:32 <shapr> @yow !
15:42:32 <lambdabot> ... ich bin in einem dusenjet ins jahr 53 vor chr ... ich lande im
15:42:33 <lambdabot> antiken Rom ...  einige gladiatoren spielen scrabble ... ich rieche
15:42:33 <lambdabot> PIZZA ...
15:42:39 <dons> not sure that would help, would it?
15:43:07 <vixey> anybody read this http://arxiv.org/abs/0810.5056 ?
15:43:16 <vixey> I don't understand it :/
15:43:28 <Cale> It might very well harm performance.
15:43:35 <Cale> Depending on how that was done.
15:43:38 <thetallgu1> Zippy in German.  Nice.
15:43:53 <sjanssen> the slowness of DiffArray is an indicator that such an approach is tricky
15:43:56 <rwbarton_> vixey: is that the P vs. NP paper?
15:43:56 <lispy> dons: it might help for cases where you build or add to the map
15:44:13 <dons> diffarray is teh old
15:44:15 <Cale> vixey: I looked at it and decided that it wasn't something I was going to bother trying to read.
15:44:17 <FunctorSalad> I think there's a bug in the 'feed' package. for Atom feeds, the links belonging to an entry aren't properly parsed (the code looks right though)
15:44:19 <dons> there is no older code, afaik
15:44:30 <FunctorSalad> "not properly" meaning "not at all" here
15:44:33 <lispy> heh, yeah no DiffArray
15:44:35 <sjanssen> also, how would mutability help trees?
15:44:41 <cjb> dons: I think this might be an old conversation, but:  have you thought of rewriting one of the standard Unix tools (sort(1) is an obvious candidate, but perhaps there are others) to run as a multi-core binary that uses -N<number of processors> by default?
15:44:46 <sjanssen> dons, lispy: the point still holds
15:44:52 <dons> FunctorSalad: send a bug report, or perhaps try the head repo, http://code.galois.com/cgi-bin/gitweb
15:44:53 <lambdabot> Title: code.galois.com Git
15:44:54 <Cale> DiffArray would be cooler if it used a Data.Map to store the reverse updates.
15:45:01 <dons> cjb: nice idea
15:45:07 <FunctorSalad> dons: okay
15:45:13 <sjanssen> the overhead of a single (!) MVar adds so much overhead to DiffArray that it isn't very useful
15:45:14 <cjb> it would be pretty great to post a small implementation of a standard tool that people use in C, and be able to say "look, here's how to write the same thing that actually scales with CPUs in a third of the number of lines of code.."
15:45:19 <Cale> (rather than what ends up being effectively an association list)
15:45:48 <vixey> I got kind of lost after the first few pages
15:45:53 <lispy> cjb: heh, we need the K&R C book for Haskell :)
15:45:57 <FunctorSalad> the weird thing is that the atom xml seems to match the parser
15:46:34 <xcthulhu> lispy: Categories for the Working Mathematician?
15:46:37 <xcthulhu> j/k
15:46:57 <Pseudonym> The Working Mathematician is assumed to know a lot of topology.
15:47:11 <lispy> dons, sjanssen: okay.  I guess my brainstorming was spured on by the recent stuff on cafe about data.map and happs and then Heffalump replace a list with a map and got some speed up but nothing amazing...so I started to question map itself
15:47:51 <Cale> It might have been that the real slowness was elsewhere?
15:47:56 <lispy> in Heffalump's case it may be that there is an ineffeciency in the way the map is used
15:48:10 <rwbarton_> how big was the list?
15:48:18 <lispy> I'm not sure
15:48:21 <sjanssen> lispy: there are probably faster structures out there, size balanced maps aren't particularly popular from what I've heard
15:48:22 <vixey> I wonder if I should type it out into a proof assistant and see what happens :)
15:48:51 <vixey> although I'd probably have to understand it first
15:49:06 <jinjing> it's constant time look up, no? insertion is expensive
15:49:19 <basvandijk> lispy: there was a google summer of code project on creating efficient maps using generalised tries. See: http://hackage.haskell.org/trac/summer-of-code/ticket/1560
15:49:21 <lambdabot> Title: #1560 (Efficient Maps using Generalised Tries) - Haskell.org Google Summer of Co ...
15:49:37 <cjb> lispy: so, the difference here is that I'm mainly interested in situations where we can write really short code that's far more efficient than the C code because multicore is too scary to C programmers.
15:49:47 <xcthulhu> vixey: The proof assistant language or the P != NP paper?
15:49:55 <ddarius> Pseudonym: Topology is a pretty basic area of mathematics.
15:50:08 <cjb> sort's one obvious place where we could use multicore (sort into different buckets on different CPUs), but I can't really think of any others
15:50:11 <vixey> umm both
15:50:30 <cjb> Real World Haskell had an implementation of wc, but I'm pretty sure it was slower than wc(1) even with several cores
15:50:35 <xcthulhu> vixey: Well, don't believe everything you read on arxiv.org
15:50:45 <xcthulhu> ...you totally know that already though...
15:50:45 <vixey> I don't believe anything I read anywhere
15:51:08 <lispy> basvandijk: interesting
15:51:12 <Pseudonym> ddarius: THat's like saying that Bridge is a simple game.
15:51:12 <ddarius> Nothing is true in vixey's world.
15:51:22 <Pseudonym> It's true that the rules are simple.
15:51:49 <ddarius> Pseudonym: Categories for the Working Mathematician doesn't require you to be masterful with topology, just know something about it for the most part.
15:52:24 <dons> cjb: its not hard to beat wc.
15:52:38 <dons> http://haskell.org/haskellwiki/Wc
15:52:39 <lambdabot> Title: Wc - HaskellWiki
15:52:58 <dons> i think that was the first haskell tutorial i wrote
15:52:58 <Pseudonym> ddarius: Right.  The problem is that if the motivating examples are just as foreign as the concepts being illustrated, it's not a good learning tool.
15:53:55 <xcthulhu> cjb: Hmm... I don't know Erlang all that well, but I was under the impression that Erlang was even nicer for the distributed-computing minded programmer.
15:54:08 <xcthulhu> than Haskell or C, that is
15:54:26 <ddarius> Pseudonym: I'm saying that the "working mathematician" should not find most of the examples that foreign.
15:54:51 <Pseudonym> I've known working mathematicians who could benefit from category theory, but know very little topology.
15:55:07 <Pseudonym> At least, not the specific examples in the book.
15:55:12 <Saizan> xcthulhu: parallel != distributed
15:55:14 <ddarius> It depends on how you defining "working mathmatician"
15:55:24 <Pseudonym> I mean postdocs.
15:55:40 <Pseudonym> This may be a comment on the state of postgraduate education.
15:55:55 <ddarius> Everyone should know a little homology.  It's pretty.
15:56:05 <xcthulhu> Saizan: Hmm... you're right.  parallel < distributed (set containment).
15:56:09 <Pseudonym> Thanks!
15:56:20 <Pseudonym> Uhm.
15:56:57 <ddarius> xcthulhu: You have that backwards (at best)
15:57:18 <xcthulhu> ddarius: oh?
15:57:24 <cjb> dons: but do you think it could be made faster by going multicore?
15:57:35 <ddarius> Every distributed algorithm is parallel, but not every parallel algorithm is distributed.
15:57:35 <Saizan> i think it's more complex, e.g. in parallel programmig you can still assume shared memory most of the time
15:57:37 <cjb> I guess you're just reading linearly through the input stream, so it's entirely IO bound
15:58:18 <Pseudonym> ddarius: I think it's generall true that mathematicians think in homomorphisms and functors even if they don't realise it.
15:58:43 <xcthulhu> Pseudonym: depends on the mathematician
15:58:44 <ushdf> every distributed algorithm is distributed though
15:58:46 <ddarius> Pseudonym: I would agree with that, but then a lot of my mathematical "education" was colored by category theory.
15:59:06 <ushdf> > map (\x->sin(x)) [1..100]
15:59:08 <lambdabot>   [0.8414709848078965,0.9092974268256817,0.1411200080598672,-0.75680249530792...
15:59:09 <Pseudonym> xcthulhu: Suppose you wanted to find the centre of gravity of a triangle.
15:59:13 <alt_mattr> Pseudonym: it makes them very difficult to talk to
15:59:22 <Pseudonym> How would you do that?
15:59:26 <dons> ushdf: map sin [1..1000]
15:59:32 <xcthulhu> Pseudonym: Suppose I wanted to prove the 2nd incompleteness theorem
15:59:38 <Pseudonym> Straightedge and compass stuff.
15:59:45 <dons> cjb: sure, there's a straightforward parallelisation?
15:59:52 <ushdf> > map (\x->sin(x+2)) [1..100]
15:59:53 <lambdabot>   [0.1411200080598672,-0.7568024953079282,-0.9589242746631385,-0.279415498198...
16:00:06 <Pseudonym> xcthulhu: I'm trying to make my point with a simple problem that every mathematician should be able to do.
16:00:07 <dons> > map (sin . (+2)) [1..100]
16:00:08 <lambdabot>   [0.1411200080598672,-0.7568024953079282,-0.9589242746631385,-0.279415498198...
16:00:21 <dons> ushdf: we don't put parens around function arguments
16:00:24 <dons> > sin 5
16:00:25 <lambdabot>   -0.9589242746631385
16:00:30 <Pseudonym> One of the ways you reason about that is to find the centre of gravity of a line segment first.
16:01:07 <ushdf> > foldr (+) 1 (map (\x->sin(x+2)) [1..100])
16:01:07 <Pseudonym> Then split the triangle into line segments parallel to one side, and notice that the centres of gravity lie on a line.
16:01:08 <lambdabot>   0.5689131532427593
16:01:11 <Pseudonym> etc etc
16:01:26 <ushdf> > sin foldr (+) 1 (map (\x->sin(x+2)) [1..100])
16:01:27 <lambdabot>       No instance for (Floating ((b -> b -> b) -> b -> [b] -> b))
16:01:27 <lambdabot>        aris...
16:01:41 <dons> > sum . map sin . map (+2) $ [1.. 100]
16:01:42 <lambdabot>   -0.43108684675724085
16:01:56 <Pseudonym> Implicitly, you're using the idea of mappings which preserve theorems.
16:02:21 <xcthulhu> Pseudonym: I guess so.  But really, it depends on what sort of math you are doing; the idea of making algebraic metaphors to easier things has different milage depending on your domain.
16:04:50 <xcthulhu> Pseudonym: But... I'm just being difficult.  I think it in terms of homomorphisms all the time.
16:04:50 <rothjl> if i have a given data Ship, how would i change it's properties? Ship {x=5} but if i use Ship {x=x+1} there is an error. How would i describe this update correctly?
16:05:06 <xcthulhu> It's just hard to see it with abstract logic most of the time.
16:05:31 <sioraiocht> rothjl: Ship {x = x Ship + 1}
16:05:38 <rothjl> thx
16:05:45 <rwbarton_> s/Ship/ship/ though
16:05:48 <lament> you probably don't want to call that 'x'
16:06:02 <ddarius> Use geometric logic then.
16:06:05 <lament> probably xShip or shipX or something
16:06:08 <osfameron> yay!  Exercise 5 of To Mock a Mockingbird is trivial.  (So far they have all made me cry :-)
16:06:29 <vixey> osfameron: oh god that book killed me
16:06:54 <xcthulhu> ddarius: Mostly I study modal logic.  I don't think anyone around here does geometric logic.
16:07:25 <osfameron> vixey: it's certainly killing me.  I probably could have worked through it 12 years ago when I still remembered basic maths :-)
16:07:33 <FunctorSalad> how is the center of gravity defined in terms of elementary geometry anyway?
16:07:35 <jinjing> > ( (+1) >>> (-2) ) 2
16:07:36 <lambdabot>       No instance for (Num (b -> d))
16:07:36 <lambdabot>        arising from a use of `negate' at...
16:07:48 <lispy> jinjing: (subtract 2)
16:07:52 <lispy> maybe
16:07:54 <FunctorSalad> (rather than the integral formulation)
16:07:58 <jinjing> ( (+1) >>> (subtract 2) ) 2
16:08:07 <jinjing> > ( (+1) >>> (subtract 2) ) 2
16:08:08 <jsn> ddarius: i do not mean to be contrary, but i think distributed algorithms are actually a super set of parallel ones
16:08:08 <lambdabot>   1
16:08:17 <lispy> > ( succ >>> (subtract 2)) 2
16:08:18 <lambdabot>   1
16:08:29 <vixey> FunctorSalad: fold the triangle in half
16:08:34 <jinjing> :)
16:08:38 <jsn> ddarius: which is to say, one can develop distributed systems to support all parallel algorithms
16:08:46 <lispy> > (succ >>> (pred.pred)) 2
16:08:47 <lambdabot>   1
16:09:23 <vixey> FunctorSalad: (on all three axis, since the center of mass is on each of these axis, it must lie on the intesection)
16:09:37 <FunctorSalad> vixey: that's the solution, I mean the definition :)
16:09:45 <jsn> ddarius: but distributed systems also support message passing, and in consequence, support a broad family of inconsistent algorithms
16:10:01 <vixey> FunctorSalad: hang it by each corner and draw a line downwards ...
16:10:08 <FunctorSalad> vixey: assuming the def is different, or the problem Pseudonym mentioned would be trivial
16:10:11 <vixey> they intersect at the center of mass
16:10:17 <ddarius> jsn: This is the "there are contradictory definitions of 'more general'" thing again.  Distribution requires more structure, but then parallel algorithms are just special cases of distributed algorithms (which happen not to be distributed)
16:10:20 <vixey> this is not really math though ..
16:10:48 <jsn> ddarius: well, that is not what i meant
16:11:02 <Pseudonym> Is Euclidean geometry now considered so trivial that it's not mathematics any more?
16:11:09 <jsn> ddarius: i didn't mean, parallel algorithms "happen not to be distributed"
16:11:10 <vixey> of course not
16:11:13 <FunctorSalad> Pseudonym: I think she meant it's physics
16:11:16 <jsn> can you explain what you mean by that?
16:11:19 <Pseudonym> Ah, right.
16:11:20 <vixey> yes
16:12:06 <Pseudonym> The thing is, there are examples of even simple mathematical reasoning like that which implicitly use the ide behind homomorphisms.
16:12:32 <jsn> i meant, if you create a message passing system which is transactional, you can put any parallel algorithm on top it (you can thus "distribute" it)
16:13:32 <xcthulhu> Pseudonym: My favorite one from a young age is ln(a * b) = ln(a) + ln(b)
16:13:45 <Pseudonym> Yes, good example.
16:13:52 <ddarius> The claim is "Are all parallel algorithms distributed?" not "Are all parallel algorithms distributable?"
16:14:23 <vixey> e^(a + b) = e^a e^b
16:14:25 <Pseudonym> Not all parallel algorithms are distributed.
16:14:33 <Pseudonym> Classic example: SIMD instructions in most modern CPUs.
16:14:35 <straightd00d> anyone do a problem ticketing system in haskell wih web interface?
16:14:40 <Pseudonym> Well, I guess it's not that "classic".
16:15:04 <Pseudonym> If that's "distributed", then it's about as non-widely-distributed as it's possible to get.
16:15:32 <ivanm> dons: do we really have to go through the gentoo vs arch packaging thing again about Chart? :p
16:16:46 <straightd00d> I like arch :)
16:16:55 <straightd00d> <---using arch desktop w iceWM
16:17:07 <snk_kid> i don't think this has been posted on any haskell news site: http://uk.youtube.com/watch?v=gVLFGQGRsDw
16:17:08 <lambdabot> Title: YouTube - Making 'Super Nario Bros.' in Haskell
16:17:54 <snk_kid> links to source code too
16:19:28 <ushdf> wikipedia has a circular definition of minimax algorithm and alpha beta pruning
16:19:31 <ushdf> :/
16:19:39 <vixey> snk_kid, do you know what the music is behind it? :)
16:19:48 <snk_kid> nope
16:19:52 <vixey> ushf: PAIP has a better description that wikipedia
16:20:16 <ushdf> everything has a better description than wikipedia
16:20:32 <vixey> ushf: Ok
16:20:39 <jsn> ddarius: oh, i see
16:21:33 <snk_kid> it seems like it just went under everyone's radar
16:24:38 <rwbarton_> Looks pretty cool!
16:24:44 <straightd00d> super nario?
16:24:47 <straightd00d> wazat?
16:25:14 <snk_kid> super mario bros clone written in haskell
16:25:47 <straightd00d> that sounds good
16:26:07 <straightd00d> how about a freeware world of warcraft clone or somethng better doen in haskell?
16:26:15 <snk_kid> its got link to source code too, this should be posted on the news
16:26:20 <straightd00d> with user contributed monster sprites!
16:26:25 <vixey> snk_kid, post it :)
16:26:48 <snk_kid> i don't have an account on haskell sequence
16:27:06 <sebaseba> there are quite a few sites about Haskell that go under the radar because they're in Japanese
16:27:17 <rwbarton_> It's trying to build against an SDL binding that's not the one on hackage.
16:27:26 <rwbarton_> And yeah, the web site for the binding is in Japanese
16:28:20 <snk_kid> yeah, its a shame they keeping that they are keeping their love affair of haskell to themselves :P
16:28:21 <straightd00d> I read this essay taking a potshot at darcs for being slow or something.
16:28:27 <straightd00d> and say haskell dying etc etc
16:28:41 <straightd00d> and that haskell projects use mercural not darks for code housing
16:28:44 <straightd00d> is that all bs?
16:29:30 <sjanssen> straightd00d: I haven't heard of any Haskell projects using Mercurial
16:29:38 <FunctorSalad> haskell is dying, netcraft confirms it
16:29:51 <snk_kid> o_0
16:29:57 <BMeph> GHC does use git, though.
16:30:03 <dibblego> @instances Functor
16:30:03 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
16:30:14 <dibblego> where is the Either a Functor defined?
16:30:14 <RayNbow> I don't care about Haskell dying... I'm more concerned 'bout the birth of Haskell' :p
16:30:17 <sjanssen> straightd00d: where did you see this essay?
16:30:31 <luite_> FunctorSalad: oh good to know, so which language should I use now, according to netcraft?
16:30:34 <sjanssen> dibblego: Control.Monad.Instances
16:30:36 <BMeph> dibblego: Likely in C.M.Error
16:30:55 <dibblego> got it ta
16:31:27 <fatalerrorx> FunctorSalad: proof? post a link
16:31:34 <sjanssen> straightd00d: darcs has problems, but they aren't Haskell's fault
16:31:42 <FunctorSalad> luite_: fatalerrorx: sorry, it's an old running gag ;)
16:31:43 <fatalerrorx> haskell is stronger then before
16:31:53 <jcreigh> Looks like Haskell has offcially "made it": http://www.elance.com/c/rfp/main/rfpBid.pl?jobid=15627040
16:31:55 <lambdabot> Title: Haskell Programming: Elance Project: Login
16:32:11 <FunctorSalad> the original was "bsd is dying"
16:32:49 <fatalerrorx> FunctorSalad: thought so :)
16:32:52 <FunctorSalad> then it became "I won't believe it until netcraft confirms it" :o
16:37:56 <ivanm> with that actor model blog post/hackage package, is that basically giving erlang-style messag passing to haskell?
16:38:48 <straightd00d> damn i didnt save it
16:43:47 <Saizan> ivanm: +mulihead, in the sense that you can ask for more than one message to match, but no distribution yet
16:44:08 <ivanm> *nod*
16:44:20 <ivanm> though I'm not sure what +mulihead is meant to be... ;-)
16:44:35 <Saizan> err, multi
16:45:11 <Saizan> reading the post will be faster than me explaining it anyhow :)
16:45:32 <sbahra> jcreigh, haha
16:45:57 <ivanm> I had a quick glance through it
16:48:51 <bbs> http://hpaste.org/11590
16:49:01 <bbs> can someone help with an anonymous function there?
16:49:17 <bbs> i mean $ alone won't work
16:49:32 <bd_> what's that $ for?
16:49:50 <bbs> bd_: see paste
16:49:53 <bd_> it's invalid syntax as-is, but I'm not sure what you're trying to do with it
16:49:56 <bbs> its supposed to be a simple anonymous function
16:49:58 <bd_> I am looking at the paste :)
16:49:58 <bbs> that it will zip with
16:50:01 <bbs> oh sry
16:50:02 <bbs> :/
16:50:05 <bd_> well
16:50:09 <bd_> if you're taking a function as an argument
16:50:18 <bd_> it's not anonymous anymore (it has a name, you see :)
16:50:23 <Igloo> bbs: Is this a homework question?
16:50:29 <bd_> now... you /could/ make its name ($)
16:50:32 <vixey> bd_: you probably want like map (uncurry f)
16:50:34 <bd_> I don't recommend it
16:50:47 <bd_> vixey: why are you looking at me? :)
16:50:51 <bd_> also, what Igloo said
16:51:13 <vixey> bbs: you probably want like map (uncurry f)
16:51:39 <bbs> hmm how does that work?
16:51:56 <bbs> i know how map works
16:52:25 <vixey> you zip the things getting [(3,5),(6,1)] ..
16:52:27 <bbs> but i can't just do : zipWith map (uncurry f ) = zipp
16:52:27 <BMeph> vixey: Do you have a link to this blog you were talking about with ivanm? :)
16:52:31 <vixey> :t uncurry (*)
16:52:33 <lambdabot> forall a. (Num a) => (a, a) -> a
16:52:47 <vixey> BMeph: I don't remember this, what was it about?
16:53:37 <BMeph> vixey: Whoops, name-slide. :)
16:53:47 <BMeph> Saizan: Do you have a link to this blog you were talking about with ivanm? :)
16:54:16 <bos> @seen dons
16:54:16 <lambdabot> dons is in #darcs, #arch-haskell, #xmonad, #ghc and #haskell. I last heard dons speak 52m 34s ago.
16:54:23 <dons> yo bos
16:54:58 <snk_kid> BMeph: i saw it, it's either in haskell planet/sequence can't remember which
16:55:21 <vixey> what was it about?
16:55:42 <snk_kid> Actor library
16:57:50 <snk_kid> BMeph: http://sulzmann.blogspot.com/2008/10/actors-with-multi-headed-receive.html
16:57:52 <lambdabot> Title: Martin Sulzmann's Blog: Actors with Multi-Headed Receive Clauses, http://tinyurl.com/6248ho
16:58:31 <snk_kid> lambdabot is godly
17:00:09 <rothjl> if i have an instance of data ship and i want to return one of its value. How would i do that?
17:01:21 <bbs> vixey: i'll play
17:01:21 <gwern> 'lo all
17:01:23 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
17:01:27 <gwern> @messages
17:01:28 <lambdabot> ivanm asked 49m 37s ago: well, I got all that.... it's just that whenever I try to use it it keeps creating empty ChangeLog files :s
17:01:34 <vixey> bbs, huh
17:01:43 <rothjl> i have data ship and defined within it is a value xcoord. How would i return that value?
17:01:45 <bbs> vixey: with the stuff you just showed me
17:01:49 <bbs> looks cool
17:01:55 <vixey> oh right, good luck
17:02:02 <bbs> doesn't work right off the bat though
17:02:07 <bbs> zipWith map (uncurry f) = zipp
17:02:11 <byd00d> http://www.defmacro.org/ramblings/haskell-web.html hmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm
17:02:11 <lambdabot> Title: Haskell and Web Applications
17:02:31 <gwern> @tell ivanm eh, it's not brilliantly tested. maybe some options changed for the VCS you are using? just look at the source and try to see whether it's the command or the haskell code that is returning the empty string
17:02:31 <lambdabot> Consider it noted.
17:02:43 <gwern> 'It turns out that only 9 of the first 275 checks that I've sent out since the beginning of 2006 have actually been cashed.' <-- who would cash a Knuth check?
17:03:32 <Ferdirand>  /wi12
17:03:33 <Ferdirand> oops
17:03:54 <snk_kid> well it's the best i can do http://news.gmane.org/gmane.comp.lang.haskell.general
17:03:55 <lambdabot> Title: Gmane Loom
17:07:52 <rwbarton_> rothjl: xcoord ship
17:08:25 <byd00d> checks for what?
17:09:38 <rwbarton_> Finding errors in his books
17:10:52 <BMeph> bbs: Isn't your 'zipp' thing, just 'zip', i.e., zipWith (,)? :)
17:11:34 <rothjl> could someone please help me. I can't seem to find any good tutorials on using "data" in haskell. I'm trying to use a function i defined to return a value of a data structure i defined orr simply return the value of field in my data's instance
17:12:17 <snk_kid> rothjl: are you using record types?
17:12:39 <rothjl> i'm not sure what record types are
17:13:22 <byd00d> wow having an app run as a suer nto root is cool
17:13:27 <snk_kid> rothjl: data can be used to define different kind of types, like algebraic types
17:13:34 <byd00d> but soem people make apps so dependant on amny proggies
17:13:37 <byd00d> many
17:14:24 <gwern> byd00d: using libraries rather than rolling your own is generally a good thing
17:14:58 <byd00d> I'm supporting tomcat postgresql apps here at work
17:15:09 <byd00d> actually tomcat mysql trying to mvoe to postgres
17:15:29 <rwbarton_> rothjl: Yes, you're using record types  (data Ship_p = Ship_p { x :: GLfloat, y :: GLfloat, ... } rather than data Ship_p = Ship_p GLfloat GLfloat ...)
17:16:10 <byd00d> and im admin of boxes and thsi other amdin want to take crack at setting up app since I FAILed after 2 days [atlassain -- a corp that glommed some java n mysql together to amke thier own frankenapp, now my bosses bought it and want it installed asap and mvoed from older install at far away colo] ah the FUN
17:16:29 <rothjl> http://hpaste.org/11592
17:16:35 * gwern frowns. this Super Nario Bros haskell game wants a 'HSDL' SDL binding. why is it not using the usual sdl bindings?
17:16:35 <rwbarton_> rothjl: that defines accessor functions  x :: Ship_p -> GLfloat, etc.
17:16:36 <byd00d> giving the bugger unix perms n sudo without giving power on the box is tricky
17:16:55 <rwbarton_> gwern: I'm trying to port it to the SDL on hackage... but that seems to be missing a getKeyState binding
17:17:31 <snk_kid> rothjl: have a look about haskell data types here: http://learnyouahaskell.com/
17:17:35 <lambdabot> Title: Learn You a Haskell for Great Good!
17:17:37 <rothjl> k
17:17:43 <snk_kid> this website is awesome
17:17:44 <gwern> rwbarton_: indeed? I'm still at finding HSDL src
17:17:56 <gwern> rwbarton_: although it looks like he also did tetris besides mario
17:18:08 * gwern notes that it's amazing the proportion of haskell games done by a japanese
17:18:08 <rwbarton_> gwern: I'm working from this: http://fxp.hp.infoseek.co.jp/haskell/HSDL/doc/
17:18:10 <lambdabot> Title: hsdl-0.2.0
17:18:37 <gwern> gah, hsdl unpacks into the current dir!
17:18:39 <snk_kid> gwern: u should also note that they don't say anything about it!
17:18:47 * gwern frowns at http://fxp.hp.infoseek.co.jp/haskell/HSDL/arc/HSDL-0.2.0.zip
17:18:53 <byd00d> whats sdl?
17:18:53 <gwern> snk_kid: pardon?
17:19:17 <snk_kid> gwern: the gamez
17:19:21 <snk_kid> gwern: nvm
17:19:23 <rothjl>  i've define my data fine i just don't know the semantics of getting a value from the an instance of that data
17:19:40 <gwern> snk_kid: they say plenty about them, they're just not integrated into the English-speaking haskell community
17:20:26 <gwern> sometimes I wonder how much trouble it would be to be a japanese programmer who isn't fluent in english
17:20:48 <snk_kid> rothjil: did you have a look at that website i linked to?
17:21:10 * gwern frowns again. hardwired include paths!
17:21:18 <rothjl> ya i'm readying it right now
17:21:27 <rwbarton_> gwern: urgh, I hate the unpacking into . thing
17:21:29 <snk_kid> rothjil: check out chapter 8
17:21:44 <gwern> rwbarton_: indeed. I'm lucky it didn't clobber anything
17:21:57 <rwbarton_> rothjl: that hpaste looks fine, although it probably isn't necessary to define return_x as a name for x
17:22:35 <rothjl> ya it's pretty good but i'm looking for a specific answer on how to return a value
17:23:19 <rothjl> if i have a defined instance "a". How would I return a value of one of its field/variable?
17:23:54 <rwbarton_> x a
17:23:55 <snk_kid> haven't done any haskell in a while so i'm going to awesome you will pattern match the record instance
17:24:07 <gwern> gah!
17:24:08 <snk_kid> to pick out the member
17:24:12 <gwern> HSDL forgot the c sources!
17:24:15 <gwern> gott ver dammt
17:24:28 <vixey> @remember  <snk_kid> haven't done any haskell in a while so i'm going to awesome
17:24:28 <lambdabot> Done.
17:24:40 <snk_kid> awwwwwwwwww
17:24:41 <rwbarton_> s/awesome/assume/, that took me a while :)
17:24:50 <snk_kid> i'm tired
17:24:55 <gwern> you mean that wasn't an xmonad related dig?
17:25:26 <rwbarton_> @seen lemmih
17:25:26 <lambdabot> Last time I saw lemmih was when I left ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-hac07, #
17:25:26 <lambdabot> haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr and #haskell.it 2m 3d 1h 43m 5s ago, and .
17:25:30 <rwbarton_> @seen Lemmih
17:25:31 <lambdabot> Last time I saw Lemmih was when I left ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-hac07, #
17:25:31 <lambdabot> haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr and #haskell.it 2m 3d 1h 43m 10s ago, and .
17:25:50 <gwern> arrgggh and the older versions of HSDL include .c stubs, but I dunno  fi they're right, as they have different names
17:25:57 * gwern decides enough of this for tonight
17:26:35 <snk_kid> rothjil: did you get what i was trying to say?
17:26:47 <rwbarton_> It's reasonably close to building if you just s/Multimedia.SDL/Graphics.UI.SDL/g
17:27:07 <snk_kid> rothjil: if you look at the "record syntax" section it shows you some examples of picking out members
17:27:15 <byd00d> xmonad si nice but i invariably use the mouse so I just use iceWM
17:27:29 <rothjl> nope doesn't work(x a). I'm using HopenGL and i'm trying to use "rotate (x ship) $ Vector3 x' y' z'" but this doesn't work. My structure is defined in another module
17:27:38 <byd00d> if there was another one liek xmonad but more designed like win98 look then Id go for it, esp is super light on cpu
17:27:46 <byd00d> that would make me move offa iceWM
17:27:47 <rothjl> i'll try reading the "record syntax"
17:28:29 <gwern> byd00d: how would xmonad possibly look like win98?
17:28:53 <snk_kid> rothjl: here is another online book aswell: http://book.realworldhaskell.org/read/
17:28:54 <lambdabot> Title: Real World Haskell
17:29:59 <rothjl> thx for the book refenrences snk_kid
17:30:18 * gwern watches the nario video. pretty darn solid looking
17:30:49 <snk_kid> rothjl: no worries
17:31:46 <gwern> ...well, except for the end of the first level where the flag pole does nothing, the castle isn't there, and all you can do is commit suicide by jumping into the gulf
17:32:40 <gwern> I guess it's a prototype :)
17:35:03 <snk_kid> I have to say "Learn You a Haskell for Great Good!" is an awesome effort
17:35:40 <Gabby> And awesomely titled.
17:36:06 <snk_kid> :)
17:36:44 <osfameron> I thought it became serious a bit too quickly
17:37:01 <osfameron> I'm not saying it should have had dozens of pages of cutesy cartoon foxes and ravings about onions
17:37:24 <snk_kid> what fonts are they using for code? Consolas?
17:39:05 <snk_kid> looks like Consolas with size 12 fonts
17:41:31 <snk_kid> would be cool if there was a similar book to "the art of logic programming" but for haskell
17:42:01 <vixey> can you remind me what is that book, the art of logic programming?
17:42:18 <ivanm> @tell gwern this was _darcs_ I was trying it with!
17:42:18 <lambdabot> Consider it noted.
17:42:22 <vixey> is it prolog?
17:43:03 <snk_kid> it uses prolog, has japanese paintings (i think) on the cover
17:44:11 <vixey> oh right, yeah I read that it's fantastic actually
17:44:18 <vixey> one of the few books that covers some theory
17:44:25 <snk_kid> un
17:44:49 <snk_kid> unfortunately i just read 5 chapters (i loaned it)
17:45:28 <snk_kid> hmmm i cant find the book online at all
17:46:33 <snk_kid> oh okay it's called "The Art of Prolog, 2nd edition"
17:46:43 <snk_kid> http://mitpress.mit.edu/images/products/books/0262691639-f30.jpg
17:48:06 <snk_kid> with all the existentials up the wazoo
17:48:29 * Raynes Sees the word prolog and shoves pencils in his eyes.
17:50:05 * snk_kid whispers in Raynes ears "prolog"
17:50:18 <vixey> hi edwardk
17:50:22 <edwardk> heya
17:50:40 * Raynes Puts newspaper in his ears and gets in the fetal postion in the corner of the room.
17:50:42 <Raynes> o_o
17:50:43 <rwbarton_> I got Nario running!
17:50:44 <rwbarton_> Sort of.
17:51:33 <snk_kid> seems like the code base is quite small actually
17:53:35 <rwbarton_> I even managed to walljump off a pipe :)
17:55:52 <rwbarton_> It's really slow, though, for some reason.  And it doesn't seem to be CPU-bound.
17:57:20 <snk_kid> crap i just rated the video 3-stars by accident, i was trying to vote 5!
17:58:13 <xxgodsmackxx321> http://sarah.watchhertits.com/?id=8cc196441ea58434504e08e5a95684a3
17:58:15 <lambdabot> Title: sarah.watchhertits.com, http://tinyurl.com/5npxgo
18:00:57 <ivanm> damn spammers
18:00:58 <lambdabot> ivanm: You have 1 new message. '/msg lambdabot @messages' to read it.
18:02:56 <pumpkin> you gotta admire those porn site creators though
18:03:00 <pumpkin> so many people fall for that ruse
18:03:19 <ivanm> to click random links?
18:03:25 <pumpkin> that kind of site
18:03:31 <ivanm> especially when the url kind of gives it away?
18:03:58 <pumpkin> I mean, "my girlfriend dumped me and I'm gonna put naked pics of her up, but you gotta spread links to my site if you want to see all the pics"
18:04:09 <ivanm> ahhhh
18:04:10 <proqesi> pumpkin: hopefully they don't fall for it more than once or twice
18:04:13 <pumpkin> "oh and btw my girlfriend is over 18 and I have the records as per law xyz"
18:04:23 <vixey> #haskell-blah ?
18:05:17 <ivanm> btw, does anyone know if matlab has a "map" equivalent?
18:05:37 <ivanm> vixey: yes, but the spammers are here, not necessarily in #haskell-blah ;-)
18:05:51 <adu> ivanm: iirc, matlab has loads of operators with "map" built-in
18:06:08 <ivanm> I want to make a custom one though
18:06:42 <ivanm> well, it technically isn't a map, but I want to sum up n copies of the output of a random function
18:06:45 <ddarius> The topic of #haskell is Haskell, not spammers.
18:07:08 <rwbarton_> If anyone wants to build Nario against the SDL package on Hackage, they can try this patch: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=336#a336
18:07:18 <ivanm> ddarius: no, the topic of #haskell is " ["Functional code is functional", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]"
18:07:20 <ivanm> ;-)
18:07:21 <adu> Nario?
18:07:50 <adu> ivanm: you are quite a spammer
18:07:57 <snk_kid> adu: mario bros clone in haskell
18:07:58 <ivanm> adu: me? :o
18:08:11 <rwbarton_> adu: See recent post to haskell@, or http://uk.youtube.com/watch?v=gVLFGQGRsDw
18:08:12 <lambdabot> Title: YouTube - Making 'Super Nario Bros.' in Haskell
18:09:01 <snk_kid> it would be nice if someone would make a video of Frag
18:09:27 <adu> thats 日本語!!
18:09:43 <ivanm> three empty boxes?
18:09:54 <snk_kid> ivanm: kanji characters
18:10:12 <ivanm> ahhhhh
18:10:13 <ddarius> nihon-go
18:10:24 <snk_kid> yes nihongo
18:10:53 <snk_kid> written by nihon-jin
18:11:30 <rwbarton_> How do I get high-resolution wall clock time?
18:11:42 <adu> but I am not 日本人
18:11:53 <snk_kid> i can't read kanji :P
18:13:04 <snk_kid> "wall clock"? you want a high-res timer like QueryPerformanceTimer?
18:13:37 <rwbarton_> If that's the equivalent of gettimeofday(), yes :)
18:14:40 <rwbarton_> (A threadDelay for 1/60 sec isn't working too well on this machine)
18:15:24 <Twey> adu: 読む必要はありません :)
18:16:02 <adu> Twey: I understood the last-half of that :(
18:16:39 <snk_kid> rwbarton: gettimeofday has resolution of ~10 ms, high performance timers support a resolution of ~10 ns
18:17:44 <Twey> adu: I said there's no need to read it (the Japanese) :)
18:17:57 <rwbarton_> snk_kid: I suspect that anything that doesn't have a 1 s resolution would be sufficient
18:18:08 <jdrake> Is there any console util to be able to paste something on hpaste and return the url?
18:18:33 <adu> Twey: lol
18:19:04 <snk_kid> rwbarton_: just trying to find a timer api in haskell?
18:19:28 <adu> snk_kid: i find getDayFraction or something suffices
18:19:32 <rwbarton_> snk_kid: Yeah, I want to replace a threadDelay by a busy loop :)
18:19:59 <rwbarton_> (I'm probably supposed to do this using some sdl mechanism)
18:21:02 <snk_kid> adu: depends on what you're trying to achieve
18:22:04 <rwbarton_> snk_kid: Oh, SDL includes a 'delay' function that does what I'm trying to do.
18:23:12 <snk_kid> my work here is done
18:23:15 <snk_kid> lol
18:24:45 <edwardk> rwbarton: use a better digital camera?
18:25:53 <rwbarton_> edwardk: sort of like using a lava lamp to generate random numbers? :)
18:26:13 <edwardk> =)
18:35:51 <br1> Could somebody tell me if theorem 3.2.11 part 2 of attapl is correct?
18:39:38 <vixey> br1, yah it's true
18:41:31 <vixey> hi wy
18:41:36 <vixey> br1, you missed my message?
18:41:46 <wy> hi vixey
18:42:14 * wy is having headache with SQL
18:42:59 <vixey> SQL is pretty cool
18:43:15 <wy> Oh, no...
18:43:57 <wy> I'm glad you didn't use any informative adjectives for it. :~P
18:43:57 <br1> vixey: I just read it in the logs. It seems incorrect to me. If t is in an illegal unpacking it's stuck, but [t] still may have reductions to do
18:44:18 <vixey> br1, that up arrow does't mean 'diverges' ?
18:45:07 <wy> SQL makes me  feel someone has made a whole industry with lisp processing functions. filter, map, ...
18:45:27 <vixey> wy, my favorite thing is the SELECT statement :))
18:45:39 <vixey> wy, I found it very interesting the way it composes actually
18:45:45 <wy> vixey: That's map and filter :)
18:46:26 <wy> vixey: The thing annoyed me is actually PL/SQL. Many times you can't do what you think is natural
18:46:38 <br1> vixey: Yes.  I misread the definition (several times) and thought it meant 'is final'. Thanks a lot.
18:46:46 <vixey> br1, cool :)
18:46:55 <br1> vixey++
18:47:04 <vixey> br1, btw you don't happen to know if the source code for the deptypes chapter is anywhere?
18:47:15 <vixey> they claim it is on the books website, but I think it's not
18:49:28 <fatalerrorx> > [1..100]
18:49:30 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
18:49:32 <fatalerrorx> > [1..100]
18:49:32 <fatalerrorx> > [1..100]
18:49:32 <fatalerrorx> > [1..100]
18:49:33 <fatalerrorx> > [1..100]
18:49:34 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
18:49:35 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
18:49:35 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
18:49:35 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
18:49:56 <fatalerrorx> so is lambdabot concurrent?
18:53:05 <Ikkebr> [1**100..1**1000]
18:53:12 <Ikkebr> > [1**100..1**1000]
18:53:14 <lambdabot>   [1.0]
18:53:17 <Ikkebr> :p
18:53:18 <Ikkebr> sweet
18:53:37 <br1> vixey: I couln't find it either.
18:53:40 <vixey> > 1**(100**200**(300**500))
18:53:41 <lambdabot>   1.0
18:53:47 <fatalerrorx> lambdabot: help
18:53:54 <fatalerrorx> !help
18:54:10 <vixey> br1, oh well, there is no shortage of implementations :)
18:54:16 <shapr> fatalerrorx: y0 electronx, wassup?
18:54:23 <fatalerrorx> hey shapr
18:55:08 <shapr> How's Code?
18:55:24 <fatalerrorx> not bad getting better
18:55:34 <fatalerrorx> implmenting massive concurrency
18:55:51 <shapr> Nifty
18:55:57 <fatalerrorx> trying to get the bot to be able to have over 1000 threads going
18:56:05 <fatalerrorx> seems to die though
18:56:12 <vixey> IRC bot?
18:56:13 <ddarius> 1000 is nothing
18:56:14 <fatalerrorx> ya
18:56:28 <fatalerrorx> ddarius: its actually doing something
18:57:04 <vixey> @karma vixey
18:57:04 <lambdabot> You have a karma of 2
18:57:25 <fatalerrorx> http://webmail.optuszoo.com.au
18:57:26 <fatalerrorx> http://webmail.optuszoo.com.au
18:57:27 <fatalerrorx> http://webmail.optuszoo.com.au
18:57:27 <fatalerrorx> http://webmail.optuszoo.com.au
18:57:27 <lambdabot> Title: Optus myZOO - Webmail
18:57:28 <fatalerrorx> http://webmail.optuszoo.com.au
18:57:28 <lambdabot> Title: Optus myZOO - Webmail
18:57:28 <lambdabot> Title: Optus myZOO - Webmail
18:57:29 <lambdabot> Title: Optus myZOO - Webmail
18:57:29 <lambdabot> Title: Optus myZOO - Webmail
18:57:31 <Trinithis> @karma trinithis
18:57:31 <lambdabot> You have a karma of 0
18:57:32 <vixey> ok lol
18:58:03 <fatalerrorx> does lambda bot crap like 1k of each site?
18:58:05 <vixey> so it's a spam bot?
18:58:09 <fatalerrorx> grab*
18:58:38 <fatalerrorx> spam bot?
19:07:07 <Armored_Azrael> Hey, does anyone happen to know how to get gtk2hs to install under ghc 6.11?
19:07:26 <Armored_Azrael> (I know 6.11 isn't stable at all yet, I was just curious as ghc 6.11 has been nice for other things.)
19:07:44 <shapr> Have you tried cabal?
19:08:11 <shapr> Think of all the bugs you get to fix with the combination of ghc 6.11 and cabal 1.6 :-)
19:08:30 <Armored_Azrael> shapr: gtk2hs isn't in the cabal system
19:08:39 <shapr> oh, I thought it was.
19:08:59 <Armored_Azrael> ~$ cabal install gtk2hs
19:08:59 <Armored_Azrael> cabal: There is no package named gtk2hs
19:09:33 <Armored_Azrael> I've got their latest release, and their darcs. Neither actually compiles properly against darcs releases of ghc, and figured if anyone knew how to do it, they'd be here.
19:10:01 <shapr> Armored_Azrael: Can you cabal install yi-gtk ?
19:10:13 <Armored_Azrael> yup
19:10:39 <shapr> IT requires gtk2hs, yeah?
19:11:03 <Armored_Azrael> Oh sorry, wrong machine. I just did it on my 6.8 machine, of course that worked, onesec
19:11:23 <shapr> Armored_Azrael: I don't know that this will work, just suggesting things :-)
19:11:51 <Armored_Azrael> Thanks, I'm going to mess around a bit more (I'm actually trying to get cairo/gtk for a program I wrote, but gtk2hs is the only thing I can find that provides those packages)
19:11:58 <shapr> Ah cool
19:14:49 <lispy> sjanssen: you never complained on darcs-users or in the bug tracker about the "Ignore-this: ..." in patches.  You were going to do that right?  I'm interesting because it helps me build a case...
19:15:16 <lispy> interested*
19:15:19 * lispy fails grammar
19:29:45 * BMeph hands lispy a 'fail' monad...
19:29:57 <lispy> > fail :: Lispy ()
19:29:58 <lambdabot>   Not in scope: type constructor or class `Lispy'
19:30:46 <BMeph> lispy: You fail at failing. Ouch!
19:30:59 <lispy> This data structure is weird
19:31:17 <lispy> data StringSet = SS Bool [(Char,StringSet)]
19:31:29 <ddarius> It's a trie.
19:32:10 <lispy> well, this same program also hase data Trie a = Trie (Maybe a) [(Char,Trie a)]
19:32:34 <vixey> Mu ((,) Bool :.: [] :.: ((,) Char))
19:32:36 <vixey> :///
19:32:40 <vixey> this is ridiculous
19:32:41 <ddarius> I'm not sure what the bool is for in the StringSet, but yes, Trie () ~ StringSet
19:33:09 <lispy> ddarius: if Bool is true, then the empty string is in the StringSet, it would seem
19:33:21 <lispy> elemS "" (SS b _) = b
19:33:27 <ddarius> lispy: Okay.
19:33:46 <ddarius> So a StringSet is just a Trie with stuff in the nodes.
19:34:21 <lispy> so then, this StringSet stores strings by their first character?
19:34:37 <lispy> I should just go read what a Trie is
19:34:45 <ddarius> @google trie
19:34:47 <lambdabot> http://en.wikipedia.org/wiki/Trie
19:34:48 <lambdabot> Title: Trie - Wikipedia, the free encyclopedia
19:36:29 <lispy> heh, yeah i was reading tha
19:36:37 <lispy> that clarifies
19:56:14 <pastorn> how well does cabal work in windows?
20:00:42 <sw17ch> pastorn, it's hit and miss for me
20:01:39 <pastorn> sw17ch: aww... though the unicode support in windows is probably too bad for my app
20:01:56 <sw17ch> pastorn, wll, give it a shot
20:02:06 <sw17ch> i'm always trying to do weird things i shouldn't be doing
20:02:20 <sw17ch> so, it's the cornercases and some packages that i keep messing up
20:03:31 <shapr> pastaroni: Are you related to pastorn?
20:05:30 <pastaroni> shapr: he sounds like a distant cousin
20:05:36 <shapr> Yeah, could be.
20:05:40 <shapr> pastaroni: Are you learning Haskell?
20:05:42 <pastaroni> i bet he isn't as tasty either
20:05:43 <shapr> Long time user?
20:05:59 <pastaroni> shapr: nah, i don't know haskell :-D
20:06:05 <shapr> Oh, then you're learning!
20:06:09 <shapr> You've come to the right place!
20:06:22 <shapr> Got any questions? Or do you want the short tour?
20:07:49 <sw17ch> how's it going shapr
20:11:21 <pastaroni> shapr: heh, i dunno if i have time to learn
20:11:24 <pastaroni> i was just idling :-D
20:11:40 <shapr> oh, ok then
20:11:44 <shapr> sw17ch: Life is exciting!
20:11:45 <pastaroni> people who know it seem to love it though
20:12:00 <pastaroni> so it's on my long list of things to do when i have free time....eventually :-d
20:12:01 <sw17ch> shapr: how so?
20:12:03 <pastaroni> :-D
20:19:13 <murjoh_> my dist directory is empty after running  runhaskell Setup.hs configure
20:19:31 <murjoh_> i've never seen this and google doesn't seem to be much help ... has anyone seen this before?
20:21:14 <EvilTerran> ... is it writable?
20:21:18 <murjoh_> yes
20:22:17 <murjoh_> just installed haskell about 10-15 minutes ago on a fresh install of ubuntu. Worked for two builds, thne stopped
20:23:08 <shapr> murjoh_: You ran runhaskell Setup.hs configure && runhaskell Setup.hs build ?
20:23:51 <pastorn> murjoh_: why install ubuntu clean now? why not wait ~12 hours?
20:24:27 <bd_> might as well install the intrepid RCs, really
20:24:39 <murjoh_> pastorn, i didn't know there was a release coming up
20:24:44 <bd_> actually, it's probably a good idea to do it now - the mirrors will be hammered when the release comes :)
20:24:56 <murjoh_> shapr, it does the following -
20:25:03 <murjoh_> runhaskell Setup.hs configure --user --prefix=$HOME
20:25:03 <murjoh_> Configuring Cabal-1.6.0.1...
20:25:09 <murjoh_> runhaskell Setup.hs build
20:25:11 <murjoh_> Setup.hs: Run the 'configure' command first
20:25:37 <murjoh_> there's nothing in the configure output ...
20:25:52 <pastorn> murjoh_: yeah, 8.10 is coming any minute now...
20:25:57 <shapr> strace it?
20:27:29 <cads> oh god
20:27:39 <shapr> @seen chillix
20:27:41 <lambdabot> chillix is in #ghc. I don't know when chillix last spoke.
20:27:45 <shapr> aha
20:27:47 <murjoh_> didn't really give me meaningful information ... i see a number of syscalls ...
20:28:03 <cads> I was trying to work with strings in C, being uninitiated in such things
20:28:10 <murjoh_> execve is the only one that took up any time besides waitpid
20:28:27 <cads> and my frustration level rose until I noticed I was hyperventilating
20:29:02 <cads> feeling a little queasy I dialed a string tutorial
20:29:08 <murjoh_> oh wait ... stat64 looks like it has 35 errors ...
20:29:16 <cads> whereupon I did miss lists.
20:29:20 <murjoh_> out of 36 calls.
20:44:33 <fatalerrorx> @hoogle (Char -> Bool) -> String -> *
20:44:33 <lambdabot> Parse error:
20:44:33 <lambdabot>   --count=20 "(Char -> Bool) -> String -> *"
20:44:33 <lambdabot>                                          ^
20:44:47 <fatalerrorx> @hoogle (Char -> Bool) -> String -> (String, String)
20:44:48 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
20:44:48 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
20:44:48 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
21:01:46 <heatsink> If I say data instance Literal BoolT = Bool, does that mean that Literal BoolT should unify with Bool?
21:05:11 <sjanssen> heatsink: yes
21:05:46 <heatsink> Hmm.  Then I don't understand my bug.
21:05:49 <heatsink> http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=339#a339
21:08:22 <sjanssen> heatsink: what version of GHC are you using?
21:08:37 <Armored_Azrael> Hey, is there any way to compile a haskell program so that by defualt it uses certain RTS options?
21:08:58 <heatsink> sjanssen: 6.8.3
21:09:11 <Armored_Azrael> (for example, I need a slightly larger than standard stack for some program, is there any compile-time way to set default -Ksize higher?)
21:09:12 <sjanssen> heatsink: oh, I misread your example
21:09:22 <heatsink> actually, I get the bug with a much simpler example: let {false :: Literal BoolT; false = False}
21:10:08 <sjanssen> "data instance" won't unify, "type instance" will
21:10:22 <sjanssen> data instance Literal BoolT = Bool
21:10:42 <sjanssen> this just creates a data (value, not type) constructor called Bool with no arguments
21:10:53 <heatsink> Oh
21:10:59 <heatsink> my
21:11:00 <sjanssen> you want a type family, not a data family
21:11:23 <heatsink> Yeah, that makes sense.  Thanks.
21:11:30 <sjanssen> heatsink: also, type and data families only half-way work with GHC 6.8
21:11:37 <sjanssen> you're bound to see a bug or two
21:12:16 <heatsink> I gather they work okay as long as I don't mix family constraints with fundep constraints?
21:12:42 <sjanssen> there is brokenness even then
21:13:34 <heatsink> hmm, kay.
21:16:38 <Armored_Azrael> So nobody knows how to up default stack size to 16M in an app at compile time so that users don't have to supply the flag or wrap it with a script?
21:17:08 <ddarius> You write some C and bind it into your program.
21:17:26 * Armored_Azrael sighs
21:17:38 <Armored_Azrael> OK. Seems like it should be a ghc option to me. Is there a reason why it isn't?
21:17:48 <rwbarton> Or you could have your program re-execute itself with different RTS options...
21:18:17 <ddarius> Armored_Azrael: It's come up a few times.  It probably just hasn't been implemented.  Everyone is busy with other things.
21:18:27 <sjanssen> Armored_Azrael: http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-hooks
21:18:28 <lambdabot> Title: 5.14.�Running a compiled program, http://tinyurl.com/d7dj4
21:18:30 <Armored_Azrael> OK, thanks
21:18:38 <sjanssen> rwbarton: very clever
21:19:01 <rwbarton> sjanssen: Not my idea, I got it from the SPOJ page on the haskell wiki
21:20:38 <sjanssen> Armored_Azrael: specifically, look at ghc_rts_opts
21:20:56 <Armored_Azrael> Yes, I'm loading in the C file
21:22:36 <Armored_Azrael> Now to figure out how to make Cabal compile/link C files :P
21:23:12 <Armored_Azrael> got it
21:23:18 <sjanssen> cabal++
21:23:23 <sjanssen> @karma cabal
21:23:23 <lambdabot> cabal has a karma of 1
21:23:31 <sjanssen> @palomer
21:23:32 <lambdabot> Pfft
21:23:35 <sjanssen> @karma Cabal
21:23:35 <lambdabot> Cabal has a karma of 1
21:25:18 <gio123> does somebody has this paper:  The loop complexity of regular events?
21:32:57 <heatsink> According to citations, it's a technical report from MIT.
21:33:06 <twb> What's the difference between runhaskell and runghc?
21:33:25 <twb> The former might be hugs?
21:33:27 <dmwit_> runhaskell might not use GHC
21:33:42 <dmwit_> It might use NHC, Hugs, YHC, ... =)
21:33:54 <twb> So it's like #!/bin/sh vs. #!/bin/bash
21:34:05 <twb> Unless you're prepared to test portability, it's a good idea to use runghc
21:35:23 <heatsink> This is interesting.  The type system doesn't use GADT constructors as evidence of type class membership.  I don't know if that's a bug.  http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=341#a341
21:36:04 <BMeph> heatsink: Don't neglect: a /40-year-old/ Tech Rep from MIT... :)
21:37:35 <heatsink> Oh wow.  That explains the weird-sounding title.
21:38:48 <twb> Grr, attempting to convert real world haskell to use latin-1 encoding has two invalid UTF-8 sequences in the input HTML.
21:39:52 <twb> -       (somewhat visually similar to the mathematical <E2><89>
21:41:23 <twb> And in the bibliography
21:41:24 <twb> <p>[<abbr class="abbrev">Okasaki99</abbr>] <span class="copyright">Copyright  <A9> 1999.
21:43:20 <twb> Who do I report this to, dons?
21:44:18 <sjanssen> heatsink: the CAUOp component might be bottom
21:44:49 <heatsink> sjanssen: Oh, good point
21:45:03 * heatsink tries it with strictness
21:46:07 <heatsink> Same error with strictness.
21:47:06 <heatsink> May not be a bug tho. I'll inquire on the ghc devel list.
21:49:45 <Twey> Is there a good tutorial to arrows anywhere?  The ones I've found seem a little... incomplete.
21:50:23 <Twey> twb: Why would you want to use latin-1?  :-\
21:50:37 <twb> Twey: because html2ps only supports JIS and Latin-1
21:50:50 <Twey> Well, html2ps sucks then :-\
21:50:55 <twb> And the huge number of Ã in the printout is making me insane
21:51:01 <Twey> What do you do if you want to use Chinese?
21:51:03 <twb> Twey: the alternative is prince xml, which isn't FOSS :-(
21:51:15 <Twey> I'd be tempted to improve html2ps...
21:51:26 <twb> Twey: it's a perl script that is mostly postscript
21:51:26 <Twey> It can't be that hard, they've got multibyte already
21:51:34 <twb> Twey: fixing it is very nontrivial
21:51:38 <Twey> Ugh :(
22:06:20 <Trinithis> Twey: I read half of Generalizing Monads to Arrows a few months ago, and I rather enjoyed it.
22:11:57 <Twey> Trinithis: The differences from the modern version are not insurmountable?
22:14:49 <Trinithis> What??
22:15:26 <Twey> Hmn, it seems quite poorly typeset :-\  The font is pixellated and difficult to read
22:15:49 <Twey> Trinithis: The differences
22:16:03 <Twey> The one available online is an 'early draft'
22:16:11 <Twey> 'old draft', rather
22:16:13 <Trinithis> oh... that's the one I have
22:16:19 <Trinithis> It's still good
22:17:05 <twb> Twey: what typeset are we talking about?
22:18:02 <Twey> twb: In 'Generalizing Monads to Arrows' (Hughes, 2000)
22:22:56 <jsn> does anybody use the eclipse haskell plugin?
22:22:59 <jsn> do they like it?
23:01:36 <newsham> http://books.google.com/books?q=programming+haskell
23:01:37 <lambdabot> Title: programming haskell - Google Book Search
23:06:47 <bltrout> I'm using Network.Curl.Download but I don't know what to put in build-deps so that cabal will build my project with it.
23:07:04 <bltrout> I've tried download-curl, network and a few other variations.
23:07:15 <bltrout> (Also, hello. I'm new at this.)
23:11:35 <bltrout> Or, stated another way, for any arbitrary imported package what corresponding name must go in the build-deps line of a .cabal file?
23:13:05 <rwbarton> bltrout: I would think that if you ran 'cabal build' without listing the dependency, you'd get an error like: 'Cannot find module Network.Curl.Download; it is a member of package X, which is hidden'
23:14:43 <rwbarton> and then that X goes on the dependencies line
23:15:04 <bltrout> rwbarton: Actually, I get "Could not find module `Network.Curl.Download': Use -v to see a list of the files searched for." But I can use the module if I use ghc to compile the program or from ghci.
23:16:16 <rwbarton> Hmm, that's weird.
23:17:45 <bltrout> Any thoughts?
23:18:04 <rwbarton> Maybe it's a user vs. global issue?
23:18:16 <rwbarton> (I don't know whether that's consistent with these observations)
23:19:56 <bltrout> What could I do to confirm or disprove that hypothesis?
23:27:18 <bltrout> Okay, well, what should I have been able to add to build-deps: network?
