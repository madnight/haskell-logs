00:09:02 <dmwit> ugh
00:09:11 <dmwit> Data.Set.member should really be called Data.Set.elem
00:10:26 <ivanm> haskell-src-exts is _really_ pissing me off :@
00:10:38 <ivanm> there's no documentation!!!
00:10:48 <quicksilver> dmwit: I think we can't decide if we want to re-use names or not.
00:10:55 <quicksilver> dmwit: it is annoying having to qualify names.
00:11:40 <dmwit> quicksilver: It's elem in Data.Map, and Data.Set/Map have "elems".
00:11:52 <dmwit> ...and it's "elem" all through Edison. =P
00:13:31 * ski thinks qualifying names for "roughly the same concept" is way better than having different synonyms or whatever ..
00:14:38 <quicksilver> ski: but you can't re-export qualified names
00:14:45 <quicksilver> ski: and there is no convention about how to qualify
00:14:57 <quicksilver> so you have to read the module header to find out which qualifications this author is using
00:15:14 <quicksilver> there are lots of minor ways in which qualified names feel like second class concepts
00:16:25 <ski> agreed
00:28:10 <dmwit> Okay, golf challenge.
00:28:42 <dmwit> answer = head . head . dropWhile ((/=5) . length) . group . concat . map sort . groupBy ((==) `on` length) . map (sort . show . (^3)) $ [0..]
00:28:58 <dmwit> Bonus points if you also figure out what it does.
00:29:00 <luqui> ow
00:29:01 <mapreduce> @unpl head . head . dropWhile ((/=5) . length) . group . concat . map sort . groupBy ((==) `on` length) . map (sort . show . (^3)) $ [0..]
00:29:01 <lambdabot> (head (head (dropWhile (\ p -> (length p) /= 5) (group (concat (map sort (groupBy (on (==) length) (map (\ ae -> sort (show (ae ^ 3))) ([0 ..])))))))))
00:29:37 <sbahra> > head . head . dropWhile ((/=5) . length) . group . concat . map sort . groupBy ((==) `on` length) . map (sort . show . (^3)) $ [0..]
00:29:38 <lambdabot>   "012334556789"
00:29:55 <sbahra> group?
00:30:05 <mapreduce> :t group
00:30:06 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
00:30:12 <sbahra> ic
00:30:15 <dmwit> > group "bookkeeper"
00:30:17 <lambdabot>   ["b","oo","kk","ee","p","e","r"]
00:30:17 <sbahra> cool
00:30:32 * sbahra looks at Data.List
00:30:54 <_zenon_> group groups objects in a list with their neighbours satisfying equality
00:31:27 <luqui> sbahra, it's pretty readable actually.  it's just too long, I lose track of what's going on somewhere in the middle (readng from right to left)
00:31:34 <luqui> not sbahra, dmwit ^^
00:31:39 <dmwit> =)
00:31:50 <dmwit> It benefits a lot from intermediary names.
00:32:02 <luqui> but you're finding the least something
00:32:14 <luqui> so a "least" would be a nice one :-)
00:32:27 <_zenon_> group should not be mistaken for doing this ["hello there"] -> ["eee","h","ll","o","t","h","r"," "]
00:32:49 <luqui> by the way haskell golf is about capturing the mathematical essence of the problem, not making as short as possible, right :-)
00:32:57 <dmwit> right =)
00:33:00 <luqui> (which is so much cooler than perl golf, though somewhat more subjective)
00:33:14 <sbahra> _zenon_, [a] -> [[a]]
00:33:50 <sbahra> ah
00:33:52 <dmwit> luqui: Actually, this string: (concat . map sort . groupBy ((==) `on` length)) is a sneaky trick.  Do you see what it does?
00:33:54 <sbahra> transpose is really useful
00:34:01 <mapreduce> _zenon_: I don't know how that could be implemented.
00:35:01 <luqui> dmwit, not in any way I can explain in less than... say 20 words..
00:35:08 <sbahra> @src cycle
00:35:08 <lambdabot> cycle [] = undefined
00:35:08 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
00:35:28 <dmwit> luqui: It sorts an infinite list by length, then lexicographical ordering.
00:35:37 <luqui> mapreduce, how what could be implemented?   f :: [a] -> [[a]] = (:[])
00:35:40 <dmwit> (But assumes that the length is nondecreasing.)
00:36:30 <sbahra> @src repeat
00:36:30 <lambdabot> repeat x = xs where xs = x : xs
00:36:44 <dmwit> mapreduce: How about group . sort?
00:36:54 <dmwit> mapreduce: It could also be done without an Ord instance, but at much greater time cost.
00:36:55 <luqui> dmwit, ah, sortOn (length &&& id) ?
00:37:04 <mapreduce> > group . sort $ "hello there"
00:37:05 <lambdabot>   [" ","eee","hh","ll","o","r","t"]
00:37:22 <mapreduce> That doesn't give the same.
00:37:24 <dmwit> luqui: Yep, but for infinite lists. =)
00:37:34 <luqui> right
00:37:49 <mapreduce> I think to get was _zenon_ said you would have to hard-code it :)
00:37:50 * luqui really likes sortOn.  wants it in Data.List or something.
00:37:57 <mapreduce> As it wasn't especially mathematical.
00:38:00 <dmwit> mapreduce: It's the same modulo typos on _zenon_'s part.
00:38:05 <mapreduce> Ah.
00:38:14 <mapreduce> I didn't know what was intended, so I was reading it literally.
00:38:34 <mapreduce> How would you do it without an Ord instance?
00:38:42 <dmwit> luqui: Yeah, I always include Dmwit.hs, which has sortOn and a few other 'on' functions.
00:38:51 <sbahra> what is sortOn, luqui?
00:38:57 <sbahra> :t sortOn
00:38:58 <lambdabot> Not in scope: `sortOn'
00:39:05 <dmwit> ?go schwartzian transform
00:39:07 <lambdabot> http://en.wikipedia.org/wiki/Schwartzian_transform
00:39:10 <luqui> > let sortOn f = sortBy (\x y -> f x `compare` f y)
00:39:11 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
00:39:11 <lambdabot>  ...
00:39:12 <dmwit> sbahra: that
00:39:16 <luqui> :let sortOn f = sortBy (\x y -> f x `compare` f y)
00:39:21 <luqui> @let sortOn f = sortBy (\x y -> f x `compare` f y)
00:39:23 <lambdabot>  Defined.
00:39:26 <luqui> there we go :-)
00:39:38 <dmwit> :t \f -> sortBy (comparing f)
00:39:39 <lambdabot> forall a a1. (Ord a1) => (a -> a1) -> [a] -> [a]
00:39:45 <luqui> that is the inefficient version, should actually use a schwartzian transform
00:39:52 <dmwit> luqui: If that's all you want, "comparing" is nice.
00:40:02 <luqui> nice.  sortOn . comparing
00:40:13 <dmwit> :t \f -> map snd . sortBy (comparing fst) . map (f &&& id)
00:40:14 <lambdabot> forall a c. (Ord c) => (a -> c) -> [a] -> [a]
00:40:23 <dmwit> sbahra: This is the efficient version. =)
00:40:27 <luqui> yep
00:40:58 * luqui haskell effortlessly abstracts over what was only an idiom in perl
00:41:12 <luqui> uh, that wasn't much of an action, luqui ;-)
00:41:18 <dmwit> heh
00:41:20 <sbahra> cool
00:42:11 <dmwit> :t map snd . sortBy (comparing fst) . map . (&&& id)
00:42:12 <lambdabot>     Couldn't match expected type `[(a, b)]'
00:42:12 <lambdabot>            against inferred type `[a1] -> [(c, a1)]'
00:42:12 <lambdabot>     Probable cause: `.' is applied to too few arguments
00:42:23 <dmwit> oh
00:42:30 <dmwit> :t (map snd . sortBy (comparing fst) . map .) . (&&& id)
00:42:30 <luqui> sortOn is also semantically nicer than sortBy, since sortBy is not well-defined for all functions.
00:42:31 <lambdabot>     The operator `.' [infixr 9] of a section
00:42:31 <lambdabot>         must have lower precedence than the operand `(.)' [infixr 9]
00:42:31 <lambdabot>         in the section: `(map snd . sortBy (comparing fst) . map .)'
00:42:40 <dmwit> :t (map snd . sortBy (comparing fst) .) . map . (&&& id)
00:42:41 <lambdabot>     The operator `.' [infixr 9] of a section
00:42:41 <lambdabot>         must have lower precedence than the operand `(.)' [infixr 9]
00:42:41 <lambdabot>         in the section: `(map snd . sortBy (comparing fst) .)'
00:42:43 <dmwit> bah
00:42:57 <dmwit> :t sortBy
00:42:59 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
00:43:10 <dmwit> luqui: What do you mean?
00:43:20 <dmwit> Oh, for all first functions.
00:43:20 <dmwit> yeah
00:43:22 <luqui> sortBy is nonsense if the given relation is not transitive
00:43:36 <dmwit> But then, sortOn is nonsense if given an Ord instance that doesn't follow the rules.
00:43:52 <luqui> but when you say instance Ord, you sign a contract to obey the rules
00:43:53 <dmwit> It just pushes your semantic check into the Ord instance, is all.
00:43:57 <luqui> calling a function seldom does such thing...
00:43:57 <bigtalk> multOf m n = div n m == n / m
00:43:58 <dmwit> Well, that's true.
00:44:04 <bigtalk> mbiguous type variable `t' in the constraints:
00:44:13 * _zenon_ has to go to a lecture.. cu
00:44:18 <dmwit> bigtalk: Almost no type is both Integral and Floating.
00:44:20 <dmwit> :t div
00:44:22 <lambdabot> forall a. (Integral a) => a -> a -> a
00:44:23 <dmwit> :t (/)
00:44:25 <lambdabot> forall a. (Fractional a) => a -> a -> a
00:44:30 <dmwit> Sorry, Integral and Fractional.
00:44:36 <luqui> in my ideal world, Ord would include methods for proofs that it obeys the rules
00:47:51 <bigtalk> well how can i solve that then?
00:48:07 <dmwit> bigtalk: What are you trying to do?
00:48:07 <bigtalk> fromIntegral doesnt help
00:48:50 <dmwit> Sprinkling fromIntegral around liberally would fix the type-checking, but it's a very strange thing to do semantically, and fromIntegral can't help that.
00:48:53 <bigtalk> check if n is a mult of m. so 100%3 -> 33, 100/3 -> 33.3 33.3 != 33
00:49:02 <dmwit> Why not just use mod?
00:49:03 <dmwit> :t mod
00:49:05 <lambdabot> forall a. (Integral a) => a -> a -> a
00:49:11 <bigtalk> ah :)
00:49:41 <dmwit> For reference, here's how to fix the literal term you had:
00:49:56 <dmwit> :t \m n -> fromIntegral (div m n) == fromIntegral m / fromIntegral n
00:49:57 <lambdabot> forall a. (Integral a) => a -> a -> Bool
00:50:24 <dmwit> Much nastier than (\m n -> n `mod` m == 0). ;-)
00:50:51 <jdrake> Does anyone know if gtk2hs includes pangocairo support?
00:50:56 <dmwit> :t ((==0).). flip mod
00:50:57 <lambdabot> forall a. (Integral a) => a -> a -> Bool
00:50:59 <dmwit> jdrake: Yes, it does.
00:51:25 <dmwit> Well... I take that back.
00:51:30 <dmwit> I know it has Pango and Cairo support.
00:51:51 <jdrake> One is hardly useful without the other :-)
00:52:09 <dmwit> Here: http://www.haskell.org/gtk2hs/docs/gtk2hs-docs-0.9.12/Graphics-UI-Gtk-Pango-Rendering.html
00:52:11 <lambdabot> Title: Graphics.UI.Gtk.Pango.Rendering, http://tinyurl.com/4p6ywl
00:52:25 <dmwit> "GlyphItems can then be rendered onto the output device with functions such as cairoShowGlyphString."
00:52:35 <bigtalk> are there not any wanswers for the euler exercises?
00:52:51 <dmwit> And I dispute the claim that Pango can't be useful without Cairo, and I dispute the claim that Cairo can't be useful without Pango. =)
00:52:58 <dmwit> bigtalk: What do you mean?
00:53:04 <jdrake> dmwit, for my purposes the statement is true.
00:54:16 <dmwit> Ah, it's actually called showGlyphString, not cairoShowGlyphString.
00:54:22 <jdrake> The question that I would have essentially is this: How easy would it be to convert a python/gtk+ program to haskell? The program is essentially a gui with 3 sliders, a button, and a custom control that draws using cairo and sends out click events that are then used the main window for two labels being updated.
00:54:25 <dmwit> But yes, it has Pango+Cairo support.
00:54:45 <dmwit> jdrake: Something so simple should be no problem.
00:54:53 <Xenoblitz> Hi guys... i have a question... say you have two data types such as Color and Colour... and both share the same constructors... Red Blue Green etc etc... if you define a function to use one and not the other why does the compiler still complain?
00:54:59 <dmwit> jdrake: Especially if you were smart and used Glade to design it. ;-)
00:55:27 <dmwit> Xenoblitz: Two data types are not allowed to have the same constructors.
00:55:27 <jdrake> dmwit, I am a novice and yet know the Tao teaches us to use Glade.
00:55:33 <dmwit> Xenoblitz: It's ambiguous.
00:55:35 <dabb> :t combine
00:55:36 <lambdabot> Not in scope: `combine'
00:55:41 <jdrake> Is it easy enough to have separation of model and view?
00:55:41 <dmwit> Xenoblitz: So you have to qualify them.
00:56:12 <Xenoblitz> dmwit: so Colour.Yellow and Color.Yellow right?
00:56:15 <dmwit> jdrake: Of course.
00:56:24 <dmwit> Xenoblitz: No, you have to qualify them by the module they're in.
00:56:39 <Xenoblitz> dmwit using as?
00:56:39 <dmwit> Xenoblitz: (And you're not allowed to define the same constructor name twice within the same module.)
00:56:54 <Xenoblitz> dmwit: no they are imported modules i am using
00:56:56 <quicksilver> Xenoblitz: you might think the compiler could use type inference to solve such ambiguities.
00:57:04 <quicksilver> but, it is not designed to do that.
00:57:10 <Xenoblitz> quicksilver: yes in fact I am surprised
00:57:12 <jdrake> I essentially want to determine if haskell might be a better choice than python, for the final game development. The current demo program I wrote up, has some cludge even though it is less than 1000 lines. I tried to use a functional style where I could.
00:57:30 <jdrake> Of course, I realize that I am asking whether or not it is a good idea to use Haskell in #haskell :-)
00:57:35 <dmwit> =)
00:57:49 <quicksilver> Xenoblitz: it breaks something called the 'principle type property'
00:57:53 <dmwit> jdrake: I am currently building a little toy with Gtk2Hs/Cairo, and it's loads of fun.
00:57:53 <sbahra> http://nobodyreadsthis.co.uk/2008/03/04/haskell-after-nightfall/
00:57:54 <sbahra> heh
00:57:54 <lambdabot> Title: Haskell after Nightfall « Nobody Reads This
00:58:11 <bigtalk> or ?
00:58:13 <jdrake> dmwit, this demo is a toy, the final game is not :p
00:58:14 <bigtalk> what is or?
00:58:18 <bigtalk> and is &&
00:58:38 <mapreduce> ||
00:58:42 <Xenoblitz> quicksilver: thanks mate I'll look that principle up
00:58:52 <quicksilver> @faq Can haskell convinced jdrake that haskell is a better choice than python for his game?
00:58:52 <lambdabot> The answer is: Yes! Haskell can do that.
00:58:56 <mapreduce> > fix (True ||)
00:58:57 <lambdabot>   True
00:59:06 <dmwit> sbahra: heh, "primitive language"
01:00:13 <jdrake> dmwit, can I show you specifically the section of code that I am concerned about (with regards to cairo/pango)
01:00:31 <dmwit> I... guess so?
01:01:07 <Xenoblitz> quicksilver: can't find any info about it yet... but for the time being can I resolve it using anything?
01:01:52 <Xenoblitz> quicksilver: is it possible to use something like... import bla bla bla as "whatever" to solve this?
01:02:32 * sbahra wonders how much money dons makes off of "real world haskell"
01:02:34 <jdrake> dmwit, http://hpaste.org/10859    This code shows the use of pangocairo in how I am rendering the layout provided by pangocairo, not using a command specifically in cairo
01:03:19 <DekuDekuplex> I tried posting two messages to Haskell-Cafe about two hours ago, but neither got posted.  However, they can be seen in the Web archives.  Is Haskell-Cafe down?
01:03:29 <dmwit> jdrake: None of those actions should be any problem.
01:03:36 <dmwit> I'm not sure what you're worried about, really.
01:04:03 <jdrake> dmwit, the api seems somewhat different organization from the C docs, that is what I am concerned about.
01:04:06 <dmwit> Obviously I don't know exactly what centre_in_box does, but if it does anything like what it sounds like, that should be no problem, either.
01:04:16 <Adamant> sbahra: probably not a huge amount given the work that went into it
01:04:22 <quicksilver> DekuDekuplex: last message I have from the cafe is 5 hours ago. I think that mail server is sometimes a bit slow.
01:04:24 <dmwit> jdrake: Yeah, all the Cairo stuff is sort of smashed into a single module.
01:04:38 <quicksilver> Xenoblitz: yes.
01:04:38 <dmwit> jdrake: But the names are basically the same.
01:04:47 <Adamant> sbahra: on the other hand, I bet writing the book will have a great effect on dons' career and be great resume fodder
01:04:48 <quicksilver> Xenoblitz: impoart qualified Colour as C1
01:04:53 <quicksilver> Xenoblitz: then 'C1.Red'
01:05:06 <DekuDekuplex> quicksilver: Okay, thanks.  Then I'll just keep checking....
01:05:08 <mapreduce> I expect anybody competent would hire dons.
01:05:11 <jdrake> dmwit, centre_in_box is simple and I could do that in my sleep in haskell
01:05:18 * dmwit nods
01:05:29 <quicksilver> sbahra: you make very little money writing books unless they sell loads and loads and loads.
01:05:40 <quicksilver> sbahra: I doubt the haskell community is big enough to make dons rich in this way :)
01:05:51 <quicksilver> although I have pre-ordered on amazon as a small contribution!
01:05:52 <quicksilver> ;)
01:05:57 <jdrake> dmwit, you said you were doing a little toy with this stuff? Do you have code that draws any text with cairo?
01:06:06 <dmwit> Nope.
01:06:09 <Adamant> mapreduce: but if dons is competing for a senior position against Doppleganger dons, then the book would probably help.
01:06:28 <mapreduce> You mean there's a job for which Cale and dons might both apply? ;)
01:06:45 <dmwit> jdrake: But as I said, you should be able to translate your old code basically line-for-line.
01:06:56 <dmwit> ...if that's what you wanted to do. =P
01:07:27 <jdrake> dmwit, essentially it is. But I would love to actually see the critical methods in the docs before I actually start any translation.
01:07:41 <dmwit> What methods didn't you see in the Pango modules?
01:08:02 <dmwit> jdrake: http://www.haskell.org/gtk2hs/docs/gtk2hs-docs-0.9.12/ for a full list of bindings
01:08:03 <lambdabot> Title: Gtk2Hs
01:08:06 <dmwit> See the Pango module.
01:09:01 <jdrake> cr = pangocairo.CairoContext(context) <-- takes a cairo context and turns it into a pangocairo context that will be able to do all of the pango operations
01:09:18 <bigtalk> fibo a b n = fibo $! (a+b) a (n-1)
01:09:23 <bigtalk> how do i strict that?
01:09:52 <jdrake> Graphics.UI.Gtk.Pango.Context does not have it
01:10:20 <quicksilver> bigtalk: with the bang patterns extension you would jsut write
01:10:26 <quicksilver> fibo !a !b !n = ...
01:10:34 <quicksilver> without that extension, :
01:10:54 <quicksilver> fibo a b n = a `seq` b `seq` n `seq` fibo (a+b) a (n-1)
01:11:19 <mjrosenb> i may have asked this before
01:11:29 <mjrosenb> are there any mpi bindings for haskell?
01:13:15 <mapreduce> @go mpi haskell
01:13:27 <bigtalk> illegal bangpattern, use xbang
01:13:29 <lambdabot> http://www.foldr.org/~michaelw/hmpi/
01:13:29 <lambdabot> Title: hMPI - a Haskell binding for MPI
01:13:46 <quicksilver> bigtalk: yes, indeed. it is an extension you have to switch on.
01:14:02 <dmwit> jdrake: Sorry, my network is dropping like crazy.
01:14:15 <bigtalk> quick: how?
01:14:29 <jdrake> dmwit, np
01:14:57 <dmwit> jdrake: From the logs, I see you're worried about createContext or so?
01:15:13 <mjrosenb> not sure if it will compile with ghc larger than 5.....
01:15:25 <dmwit> There's cairoCreateContext :: Maybe FontMap -> IO PangoContext, not sure if that's what you're looking for or not.
01:15:40 <bigtalk> is there a way to compute huge fibonaccis ? i mean by somehow adding small numbers? im computing fib 1000000 with a tailrec, strict fibonacci and it never finishes(and yes it is correct, it works for n < 100)
01:15:48 <jdrake> dmwit, let me check
01:16:13 <jdrake> dmwit, what module was that in
01:16:22 <dmwit> Graphics.UI.Gtk.Cairo
01:16:31 <Saizan> bigtalk: use the closed formula?
01:16:48 <dmwit> (This module is uncharacteristically irregular for some reason.)
01:16:59 <jdrake> dmwit, I do believe that is it
01:17:27 <sbahra> ah
01:17:32 <sbahra> hmpi is really cool
01:17:49 <jdrake> dmwit, I am satisfied enough that I can begin the program the thing. Thank you very much.
01:18:04 <dmwit> > let fibs = 1:1:ap (zipWith (+)) tail fibs in fibs !! 1000000
01:18:05 <lambdabot>   * Exception: stack overflow
01:18:15 <dmwit> > let fibs = 1:1:ap (zipWith (+)) tail fibs in fibs !! 100
01:18:16 <lambdabot>   573147844013817084101
01:18:35 <dmwit> bigtalk: The 1000000th Fibonacci number is quite large indeed.
01:18:44 <dmwit> > let fibs = 1:1:ap (zipWith (+)) tail fibs in fibs !! 10000
01:18:45 <lambdabot>   544383731135652813387342609937503801353891845546959670262477158412085828656...
01:19:12 <quicksilver> bigtalk: the error message surely told you :)
01:19:27 <quicksilver> bigtalk: but you could also use {-# LANGUAGE BangPatterns #-}
01:29:45 <bigtalk> sqrt(x) = 10^(1/2 log x)
01:30:07 <bigtalk> 10**(1/2.0*math.log(10)) -> 14.167477986237712
01:30:09 <bigtalk> wtf?
01:31:33 <bigtalk> qucik? whatdo you mean?
01:31:51 <bigtalk> and dmwit, what s :ap? does not work
01:32:52 <dmwit> Why are you defining sqrt?  What's wrong with the existing one?
01:32:54 <dmwit> :t sqrt
01:32:55 <lambdabot> forall a. (Floating a) => a -> a
01:33:06 <dmwit> As for ap, you might need to import Control.Monad.Reader for that one to work.
01:33:07 <kaol> wasn't there some idiom for >>= return . ?
01:33:13 <dmwit> kaol: liftM
01:33:38 <dmwit> (or fmap, if you swing that way, or <$>)
01:33:41 <dmwit> :t <$>
01:33:42 <lambdabot> parse error on input `<$>'
01:33:46 <dmwit> :t (<$>)
01:33:47 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
01:34:25 <kaol> oh. of course. I feel a bit silly now. thanks.
01:34:39 <dmwit> bigtalk: ap is the s combinator.  It lives in the Reader monad.
01:36:17 <quicksilver> bigtalk: I told you how to turn on BangPatterns.
01:36:22 <EvilTerran> kaol, or (.) if you're Cale :P
01:37:05 <EvilTerran> (or if your Monad happens to be (e ->))
01:41:47 <kaol> this stuff is good for dropping down the LOC a bit
01:43:44 <jdrake> dmwit, something of interest, it appears that the game xiangqiboard uses stuff that I need, so the methods they use can probably work
02:08:02 <ac> is there any way to search the backlog with irssi?
02:08:30 <mapreduce> I seem to remember /lastlog regex count
02:08:43 <mapreduce> E.g., /lastlog ac 5 would give the last 5 lines containing ac.
02:09:12 <ac> I don't have a log file :-/
02:09:20 <mapreduce> It doesn't use the log file.
02:09:37 * mapreduce now uses emacs for IRC.
02:10:11 <ac> forutnately tunes.org has a very up to date log
02:11:26 <ac> the movie Hackers came up yesterday, so I went ahead and watched it. The best part was now I know where all these random songs I've had on my computer for almost a decade came from
02:13:21 <Adamant> ac: you must have trusted your techno-lust
02:13:35 * Adamant ducks to avoid bad puns
02:23:31 <ac> it was a pretty bad movie though
02:23:33 * ac ducks
02:24:28 <Adamant> ac: I don't think anyone will disagree with that one
02:34:11 <BeelsebobWork> where's the monad instance for Either String defined again?
02:34:28 <ac> Control.Monad.Error?
02:34:45 <BeelsebobWork> ah, cool, thanks
02:38:02 <besiria> has any1 tried Communicating Haskell Processes (CHP)?
02:43:35 <Leaves> hello, do you know why this doesn't work: http://hpaste.org/10860 ?
02:43:43 <Leaves> (small code sample)
02:45:11 <Xenoblitz> i am no expert
02:45:15 <Xenoblitz> but its possibly cause the where
02:45:18 <Xenoblitz> has to be in the next line
02:45:20 <sjanssen> Leaves: for one thing you're missing an Eq constraint
02:45:22 <EvilTerran> it doesn't
02:45:30 <EvilTerran> i regularly put the where on the end of the line
02:45:31 <quicksilver> Leaves: yes.
02:45:35 <sjanssen> Leaves: but really, it's easier for us if you also post the error message
02:45:47 <Xenoblitz> ok then nevermind what i said ^^
02:45:50 <Leaves> sorry, I just saw the Eq missing: now it is : http://hpaste.org/10861
02:45:55 <quicksilver> Leaves: please always also post error msg ;)
02:46:02 <Leaves> (including the error message)
02:46:13 <quicksilver> the problem is that the 'a's are not related.
02:46:21 <sjanssen> Leaves: so the 'a' in the where is not the same 'a' at the top level
02:46:24 <quicksilver> the simplest solution is just not to bother to give a signature to 'f'
02:46:46 <Leaves> quicksilver: but I want the a's to be related?
02:46:48 <quicksilver> alternatively GHC has an extension called ScopedTypeVariables
02:46:50 <quicksilver> Leaves: I know.
02:46:55 <quicksilver> Leaves: haskell98 can't do that.
02:47:01 <quicksilver> so you just leave off the signature
02:47:04 <quicksilver> it will infer it right.
02:47:13 <sjanssen> quicksilver: you keep writing what I want to write, but just a half second before :)
02:47:27 <Xenoblitz> quicksilver is a bot! :P
02:47:44 <quicksilver> sjanssen: I cheated. I tuned my IRC client to your synapses.
02:47:46 <RayNbow> quicksilver is reading your mind :p
02:48:02 <EvilTerran> on another note entirely, it seems to me that "forall x. pure id <*> x = x" can be proven from "fmap id = id" and "forall f x. fmap f x = pure f <*> x"
02:48:08 * sjanssen adjusts his tin foil hat
02:48:20 <quicksilver> Leaves: however, 'ScopedTypeVariables' is a "better" solution, but it's not standard haskell98, it's a GHC extension.
02:48:20 <Leaves> ok, thanks, but I also have a bigger peice of code  (http://hpaste.org/10862) with the same problem but there the type signatures are more important
02:48:22 <EvilTerran> sjanssen, you mean "antenna"?
02:48:23 <EvilTerran> :P
02:48:38 <sjanssen> EvilTerran: heh
02:48:51 <gal_bolle> which is the preferred, "official" version of quickCheck: 2.0, 2.1 or 2.1.0.1?
02:49:28 <EvilTerran> anyway
02:49:33 <Leaves> quicksilver: ok, I will look into the extension, to see if that solves it, thanks for your help!
02:50:04 <EvilTerran> pure id <*> x = fmap id x    by    forall f x. fmap f x = pure f <*> x
02:50:19 <EvilTerran> fmap id x = id x = x    by    fmap id = id
02:50:54 <EvilTerran> so  pure id <*> x = x  , and that law as mentioned on the Control.Applicative haddock seems redundant
02:52:27 <EvilTerran> it's bothered me for a while how many laws are mentioned for Control.Applicative, so i'm looking for ways to get rid of some of them :P
02:57:12 <Leaves> quicksilver: it works now, (had to look up how to use an extensions)
02:57:48 <quicksilver> ;)
02:57:59 <mauke> {-# LANGUAGE ext1, ext2, ext3 #-}
02:58:05 <quicksilver> I think it's fair to argue that ScopedTypeVariables really should have been in haskell 98 all along.
02:58:10 <quicksilver> it was a bug.
02:58:38 <Leaves> maybe it is going in haskell 2009
02:59:06 <EvilTerran> also, [pure f <*> pure x = fmap f (pure x)] by [fmap f x = pure f <*> x
02:59:06 <EvilTerran> ]; so [fmap f (pure x) = pure (f x)] is sufficient to get [pure f <*> pure x = pure (f x)], and a rather neater law
02:59:07 <lunabot>  luna: parse error on input `;'
02:59:11 <EvilTerran> whups
02:59:32 <mauke>  ];
02:59:58 <maltem> I find the syntax of ScopedTypeVariables to be quite subtle
03:00:09 <EvilTerran> i can't see any other redundancies, tho
03:00:09 <Leaves> quicksilver: do you know why I have to use the forall a. now?
03:00:24 <quicksilver> Leaves: just because that's how the GHC guys chose to indicate the extension
03:00:36 <quicksilver> Leaves: they wanted not to change the meaning of existing code.
03:01:02 <EvilTerran> now to prove the remaining laws independent :P
03:01:34 <Leaves> ok, maybe in haskell 2009 (if that is going to come) they can do it without, since that's a new language (sort of)
03:01:34 <EvilTerran> ... i guess you do that by finding examples where all-but-one of the laws hold
03:02:31 <EvilTerran> ... that's gonna do my head in. =/
03:02:35 <maltem> EvilTerran: you cannot prove by example, usually
03:02:46 <ako_0_> Hi; are there any Haskell books that particularly stand out as being good/
03:02:53 <ako_0_> s/\/$/?/
03:03:01 <quicksilver> Hutton's book is well received.
03:03:11 <quicksilver> the upcoming Real World Haskell looks rather good
03:03:16 <quicksilver> (you can read it online I believe)
03:03:16 <ako_0_> quicksilver: though, isn't that one fairy minimal?
03:03:21 <ako_0_> fairly*
03:03:25 <quicksilver> ako_0_: Hutton's book is for beginners, yes.
03:03:27 <quicksilver> what are you after?
03:03:29 <mauke> 700 pages minimal?
03:03:54 <ako_0_> I'm new to Haskell, though an experienced programmer, admittedly not in the functional area, though
03:04:13 <ako_0_> "Haskell: The Craft of Functional Programming" is said to be much more comprehensive?
03:04:18 <maltem> ako_0_: I found the Haskell School of Expression to be very useful, but it uses outdated library imports, so you cannot easily try everything out
03:04:45 <quicksilver> ako_0_: RWH might suit you better, perhaps.
03:04:48 <loop> hsoe is nice but it's a pretty bad reference book
03:04:51 <quicksilver> take a look at it on the web and see if you like it.
03:04:52 <EvilTerran> maltem, i mean, you can prove that P(env), Q(env) are independent by proving [exists env. !P(env) && Q(env)] && [exists env. P(env) && !Q(env)]
03:05:03 <EvilTerran> maltem, and you do existence proofs by example
03:05:08 <EvilTerran> (or can do)
03:05:14 <quicksilver> maltem, EvilTerran : you can prove lots of things by example
03:05:18 <maltem> EvilTerran, ah I see
03:05:20 <quicksilver> although it's normally called counterexample.
03:05:27 <EvilTerran> yeah
03:05:28 <quicksilver> a counterexample to the contrary :)
03:06:24 <EvilTerran> "assume P(env) ==> Q(env); find counterexample; assume Q(env) ==> P(env); find counterexample; .'. P(env), Q(env) independent"
03:07:34 <maltem> EvilTerran, I thought you were going to prove P, Q independently, rather than prove they don't imply each other
03:07:35 <quicksilver> all counter examples are based on the three-point topology.
03:08:10 <EvilTerran> maltem, thing is, these are alledgedly axioms
03:08:20 <EvilTerran> maltem, i'm trying to prove that none of them are redundant
03:09:21 <ako_0_> So if one was to confidently finish reading a beginners' Haskell book, is there a "next stage" book that would be worth reviewing?
03:10:08 <czShadoW> Something like Real world Haskell?
03:10:21 <ako_0_> Oh, I thought that was begineers'
03:10:22 <maltem> ako_0_: Browsing research paper is what some people like to do
03:10:29 <maltem> s/paper/papers/
03:22:16 <maltem> ako_0_: I don't think there would be any Haskell book that doesn't introduce syntax (and thus would qualified as advanced), though
03:26:09 <EvilTerran> ?src ap
03:26:09 <lambdabot> ap = liftM2 id
03:30:28 <Axman6> @hoogle Int -> Char
03:30:29 <lambdabot> Data.Char chr :: Int -> Char
03:30:29 <lambdabot> Data.Char intToDigit :: Int -> Char
03:30:29 <lambdabot> Data.ByteString.Char8 index :: ByteString -> Int -> Char
03:30:44 <Axman6> @hoogle Char -> Int
03:30:44 <lambdabot> Data.Char digitToInt :: Char -> Int
03:30:44 <lambdabot> Data.Char ord :: Char -> Int
03:30:44 <lambdabot> Data.ByteString.Char8 count :: Char -> ByteString -> Int
03:31:13 <mauke> > [fromEnum '@', ord '@']
03:31:15 <lambdabot>   [64,64]
03:31:50 <Axman6> is hat the ascii value?
03:32:26 <Axman6> @hoogle xor
03:32:26 <lambdabot> Data.Bits xor :: Bits a => a -> a -> a
03:32:45 <Axman6> @where Data.Bits
03:32:45 <lambdabot> I know nothing about data.bits.
03:34:57 <mauke> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Bits.html
03:34:59 <lambdabot> Title: Data.Bits, http://tinyurl.com/y8kr9v
03:39:22 <Adamant> mauke: has anyone talked about adopting a variant of Erlang's bit-syntax for Haskell?
03:39:29 <Adamant> it's pretty neat.
03:40:42 <mauke> I don't know
03:46:21 <sjanssen> Adamant: I think we might see something like that with GHC's new view patterns
03:48:18 <quicksilver> Adamant: Yes.
03:48:22 <quicksilver> Adamant: someone has talked about it.
03:48:23 <quicksilver> :)
03:48:43 <quicksilver> Adamant: I've heard it mentioned a couple of times.
03:48:54 <quicksilver> you might be able to do something with the new quasiquotation stuff.
03:52:34 <mapreduce> Erlang's bit syntax is pretty nice.
03:54:03 <dolio> What's it look like?
03:56:25 <Axman6> hmm, http://projecteuler.net/index.php?section=problems&id=59 is pretty fun in haskell :)
03:56:26 <lambdabot> Title: Problem 59 - Project Euler
03:56:36 <Axman6> mapreduce: indeed it is
03:57:02 <Axman6> dolio: http://www.postneo.com/2007/08/10/erlang-bit-syntax-and-network-programming
03:58:18 <dolio> To mimic things as closely as possible, you'd probably want the quasiquotation to turn into something like strict binary.
03:58:21 <Beelsebob> hehe, that is cool Axman6
03:58:51 <dolio> But I don't know how far you'd have to go in reproducing language constructs in such a scheme.
03:59:28 <roderyk> Anyone know about the maturity of HaskellNet? http://darcs.haskell.org/SoC/haskellnet/HaskellNet/  It seems to have been a 2006 GSoC and then abandoned (?). Just curious if anyone has used it. (I'm interested in the mail modules - smtp, imap, etc) Unless there is another email haskell lib I'm not aware of?
03:59:33 <lambdabot> Title: Index of /SoC/haskellnet/HaskellNet
04:00:00 <Axman6> you can do some awesome stuff with bit yntax, like 24 bit colour can be represented something like <<R:6, G:8, B:6>>
04:00:14 <Axman6> i think that's right, but i could easilt be wrong
04:00:21 <dolio> Like, "<<D:16, E, F/binary>> = Bin2" needs to turn into "D <- getWhatever ; E <- getWhatever2 ...".
04:00:51 <dolio> In strict-binary that is.
04:02:17 <dolio> Of course, I suppose you'd never have a "foo = Bin2" if you're doing things binary style, since you're reading from an implicit bytestring.
04:03:13 <cjay> roderyk: Network.Browser seems to have gone to the HTTP library. Similar things might have happened to the other parts
04:05:16 <cjay> weird, I thought there was stuff to do imap and smtp on hackage
04:06:13 <dolio> So, is "<< (X+32):8 || <<X:6>> <= BitStr>>" kind of like a list comprehension?
04:06:24 <dolio> Reading in 6 bit chunks, and putting out 8 bit chunks?
04:06:30 <SamB_XP> what the HECK is that ?
04:07:19 <roderyk> cjay: yea :/ I'm kind of surprised it didn't get moved anywhere. Unless it was not particularly complete / stable. (I haven't really had time to look it over yet; I was kind of hoping to avoid NiH syndrome and move on to more interesting things, heh.)
04:07:36 <dolio> You can actually get pretty close to that in Haskell, I suspect.
04:07:59 <SamB_XP> dolio: you think ?
04:08:23 <dolio> Yeah. You'd have to do a fair amount of preparation, though.
04:08:44 <dolio> Make a 6-bit datatype.
04:09:54 <dolio> do (x :: 6Bit) <- get ; tell (put (32 + 6BitTo8Bit x))
04:10:12 <dolio> And then you need a combinator that runs that until you're out of input.
04:10:28 <dolio> (And make the names legal haskell.)
04:11:11 <dolio> Put should be a monoid, so the type is WriterT Put Get () or something like that.
04:12:46 <araujo> morning
04:12:53 <Axman6> dolio: i think the best bit though is that there's no converting of data. you take the bits straight off the network or disk, without having to convert to some intermediate form. makes it very efficient. The mpeg example in the joe armstrong book is a really good example
04:14:18 <dolio> Well, you can write 'get6Bits :: Get Int' and 'put8Bits :: Int -> Put' and then there's no conversion.
04:14:53 <dolio> Of course, it's nice that Erlang writes those for you, essentially.
04:15:43 <dolio> Binary is supposed to be good at building bytestrings efficiently.
04:16:02 <dolio> And bytestrings are supposed to be fast. :)
04:17:06 <dolio> But, I mean, I'm just waving my hands. I don't have any facts on this. :)
04:18:03 <dolio> I assume the Erlang stuff is really good, since it's probably been hammered on a lot.
04:20:55 <mauke> meh, I've just solved #59 only to discover that I had already solved it
04:21:13 <_zenon_> mauke, Project Euler ?
04:21:16 <dolio> You don't keep your solutions?
04:21:27 <dolio> Meticulously stored in numbered subdirectories?
04:21:38 <SamB_XP> what? subdirectories ?
04:21:54 <SamB_XP> at least check the list before you solve one!
04:21:55 * _zenon_ always keep the solutions, for the current language... /Haskell/ProjectEuler
04:22:09 <dolio> You just let all the .his and .os and such mingle?
04:22:12 <mauke> dolio: I do, but I think I previously solved it interactively
04:22:35 <dolio> Ah.
04:23:25 <_zenon_> Are we talking project euler? Yes or no? /me is lost
04:23:33 <dolio> Yes.
04:24:06 <lightstep> in the rbstack discussion, many mails said that (++) has linear performance. but doesn't it take a constant time as long as (++) is used right-associatively?
04:24:30 <dolio> It's linear in the first argument.
04:24:44 <dolio> Assuming you demand that much of the output list.
04:25:06 <dolio> If you use it left-associatively, that turns into n^2.
04:25:13 <dolio> Right associative it's n.
04:26:48 <lightstep> why? taking the first element (actually, every element) takes the same time
04:27:20 <dolio> When you do 'm ++ n', all the cons cells of m get reconstructed.
04:27:21 <mauke> no, taking the second element takes twice as much time
04:28:01 <dolio> So, ((m ++ n) ++ o) reconstructs m to get (m ++ n), and then reconstructs (m ++ n) to get ((m ++ n) ++ o).
04:28:42 <maltem> lightstep: Maybe do you know linked lists as they are programmed in imperative languages? You'd have to traverse m to find its last element, and point it towards n's first element
04:28:48 <dolio> (m ++ (n ++ o)) reconstructs n to get (n ++ o), and then reconstruct m to get (m ++ (n ++ o)).
04:29:09 <SamB_XP> maltem: please no!
04:29:14 <SamB_XP> please please no!
04:29:22 <maltem> what do you mean?
04:29:31 * SamB_XP doesn't want to think about imperative linked lists
04:29:46 <maltem> heh
04:30:06 <Cale> dolio: Though, really, it's going to reconstruct m first
04:30:18 <lightstep> yeah, the cons cells are reconstructed, and that takes time. i think i get it
04:30:31 <maltem> SamB_XP: I think they give a good intuition why the traversal is necessary... of course in Haskell you'd argue how the expression gets reduced
04:30:42 <Cale> [1,2] ++ ([4,5] ++ [6,7,8])
04:30:53 <Cale> = 1 : ([2] ++ ([4,5] ++ [6,7,8]))
04:31:00 <Cale> = 1 : 2 : ([] ++ ([4,5] ++ [6,7,8]))
04:31:06 <Cale> = 1 : 2 : ([4,5] ++ [6,7,8])
04:31:08 <lightstep> but if the first list is not evaluated yet, will it still have overhead?
04:31:16 <SamB_XP> of course
04:31:21 <Cale> = 1 : 2 : 4 : ([5] ++ [6,7,8])
04:31:27 <Cale> = 1 : 2 : 4 : 5 : ([] ++ [6,7,8])
04:31:31 <Cale> = 1 : 2 : 4 : 5 : [6,7,8]
04:31:34 <Cale> done.
04:32:19 <SamB_XP> ([1,2] ++ [4,5]) ++ [6,7,8] ?
04:32:23 <maltem> lightstep: head (a ++ b) is one step to apply the definition of (++), and one step to extract the first element
04:32:28 <lightstep> and why are diff lists O(1)?
04:32:47 <ivanm> because dons told them to be O(1)
04:32:48 <Cale> = (1 : ([2] ++ [4,5])) ++ [6,7,8]
04:32:49 <SamB_XP> lightstep: because they don't have tails yet ;-)
04:33:06 <Cale> = 1 : (([2] ++ [4,5]) ++ [6,7,8])
04:33:46 <Deewiant> = 1 : (2 : ([] ++ [4,5]) ++ [6,7,8])
04:33:58 <Deewiant> = 1 : 2 : (([] ++ [4,5]) ++ [6,7,8])
04:34:32 <Cale> = 1 : 2 : ([4,5] ++ [6,7,8])
04:34:32 <Deewiant> = 1 : 2 : ([4,5] ++ [6,7,8])
04:34:46 <SamB_XP> @quote C-a-l-e
04:34:46 <lambdabot> No quotes match. stty: unknown mode: doofus
04:34:47 <Axman6> lightstep: when Deewiant speaks, lists listen
04:34:57 <Axman6> uh, dons even
04:35:04 <Axman6> Deewiant too sometimes
04:35:07 <Deewiant> :-P
04:35:14 * SamB_XP knew that was going to happen, but wanted to refer to the "stereo" quote anyway
04:35:46 <lightstep> this has _got_ to be quoted in the coming hwn
04:36:03 <SamB_XP> anyway, DList isn't exactly a new idea
04:36:15 <sjanssen> evidence: ShowS in the Prelude
04:36:18 <SamB_XP> it's been in the CTK since forever hasn't it ?
04:36:35 <sjanssen> @type shows
04:36:37 <lambdabot> forall a. (Show a) => a -> String -> String
04:36:51 <Deewiant> @src ShowS
04:36:52 <sjanssen> > shows 1 "suffix"
04:36:52 <lambdabot> type ShowS = String -> String
04:36:53 <lambdabot>   "1suffix"
04:37:10 <sjanssen> > shows 1 . shows 2 . shows 3 $ ""
04:37:12 <lambdabot>   "123"
04:37:26 <sjanssen> (.) is concatenation, just as in DList
04:38:12 <Axman6> :t shows
04:38:13 <lambdabot> forall a. (Show a) => a -> String -> String
04:38:21 <Axman6> damn, that's really handy
04:38:25 <Axman6> like, damn!
04:38:32 <quicksilver> I think it's actualy quite hard to explain clearly why DList and [a] have different complexity in a lazy setting.
04:38:46 <sjanssen> quicksilver: it really is
04:39:03 <quicksilver> it's probably easier to explain it in a strict setting and then say that the lazy setting doesn't change the amount of work to be done, just when it is done.
04:39:10 <lightstep> but why is it fast? i imagine (([1,2]++) . ([3,4,5]++) . id) [] reducing quickly to [1,2] ++ ([3,4,5] ++ [])
04:40:01 <lightstep> that is, you copy all the source lists
04:40:10 <opqdonut> but less copies are being made
04:40:44 <dolio> DList delays doing any actual list destruction/building until it can assure to do it right-assoiatively.
04:41:12 <opqdonut> well put
04:41:14 <lightstep> yeah, it only deals with the associativity issue
04:41:16 <dolio> Barring your converting to a list and back to a DList somewhere in the middle.
04:41:29 <quicksilver> the key observation here is that (.) is really associative, in that it doesn't matter how the RTS reduces it
04:41:48 <quicksilver> whereas (++) is pseudo associative, in that you get the same results but different operational behviour
04:41:58 <SamB_XP> easily verified by asking yourself what the associativity of (.) is ;-)
04:42:05 <quicksilver> unusual choice of words, I guess.
04:45:48 <dolio> lightstep: What DList does is let you write things with the bad associativity, but they get performed with the good associativity.
04:45:56 <dolio> So ultimately, you don't have to worry about it.
04:46:05 <lightstep> so dlists being O(1) mean that concatenating the lists in that part of the algorithm takes linear time, while creating them also takes linear time, so it is hidden in the big-O constants
04:46:31 <SamB_XP> lightstep: eh?
04:46:50 <SamB_XP> of course creating them takes linear time
04:46:51 <lightstep> and (++) takes linear time in the sense that if you do it k times, in a random associativity order, it takes O(k) more time that creating the lists in the first place
04:47:19 <lightstep> err, O(K * #lists)
04:47:30 <lightstep> or O(K * sum (map length lists))
04:47:34 <ivanm> is it possible to have all instance of class Foo be automatically instances of class Bar (i.e. instance (Foo a) => Bar a where ... )?
04:48:02 <dolio> ivanm: Yes, but that precludes any other instances of Bar under H98 rules.
04:48:02 <SamB_XP> complicated
04:48:19 <ivanm> oh...
04:48:23 <ivanm> so probably not worth it?
04:48:52 <dolio> Well, you can get fancier with overlapping instances and such.
04:49:02 <dolio> But, no, it's probably not worth it.
04:49:14 <ivanm> right-o
04:49:19 <Axman6> t kinda annoys me when  i see people using more than 1, log n, n and n^m when using big O notation
04:50:00 <dolio> What about n*m, and n + m?
04:50:10 * Deewiant likes O(α(n))
04:50:13 <maltem> ivanm: I think you even need Undecidableinstances
04:50:42 <ivanm> maltem: I don't _need_ it, as it wouldn't be that much extra effort
04:50:45 <Cthulhon> O(n!) is neat too.
04:50:46 <Axman6> dolio: they'd probably be n^2 and n
04:50:59 <Peaker> O(n!) == O(n^n) no?
04:51:17 <Deewiant> yep
04:51:26 <ivanm> is it? I thought n^n > n!
04:51:52 <dolio> m is not necessarily related to n.
04:52:08 <maltem> ivanm: right... The thing is, if that declaration were standard Haskell, then you couldn't have any other instance (Bar a)
04:52:12 <Deewiant> n^n > n! but O(n!) == O(n^n)... for computer-sciency definitions of == ;-)
04:52:26 <ivanm> Deewiant: heh
04:52:28 <Axman6> Deewiant: heh
04:52:33 <dolio> Like, say, string search algorithms, where the running time is dependent on both the string you're looking for, and the string you're searching in.
04:52:37 <Axman6> damnit, ivanm puled a Beelsebob on me!
04:52:44 <ivanm> what, d(n^n)/dn ~ d(n!)/dn ?
04:52:48 <ivanm> Axman6: hmmmm?
04:53:12 <Axman6> Beelsebob keeps saying things before i do, and it really shits me :P
04:53:55 <Cale> Deewiant: for mathematical definitions of O as well ;)
04:54:23 <Deewiant> n! is n*(n-1)*...*1 while n^n is n*n*...*n - as can (hopefully) be seen, the difference is less than n^n
04:54:55 <Deewiant> Cale: I like == to be symmetric :-P
04:55:35 <ivanm> Deewiant: then again, the difference between n^n and 1 is < n^n ...
04:56:12 <lightstep> Deewiant, n^n - n! is n^(n-o(n))  -- note the small-o
04:56:19 <Deewiant> ivanm: yes, so O(1) = O(n^n)
04:56:23 <lightstep> that is, n^n >> n!
04:56:25 <Deewiant> but O(n^n) /= O(1)
04:56:34 <quicksilver> ivanm: did you consider making Bar a superclass of Foo ?
04:56:40 <quicksilver> ivanm: that's the h98 model of that problem.
04:56:58 <quicksilver> on the downside it does force you to write all the methods
04:57:09 * maltem loves the ⊂ sign
04:57:11 <quicksilver> on the upside, it is understood by typ einference and context reduction.
04:57:28 <ivanm> quicksilver: nah... basically, I have a class that defines a function f -> (F,[F]), and for some possible values of f the list would be empty
04:57:51 <Cale> Deewiant: I disagree that O(1) = O(n^n)
04:57:53 <ivanm> so the Foo class isn't necessary, I just thought it might make it a bit simpler
04:58:03 <Cale> O(1) is a subset of O(n^n) though
04:58:13 <Deewiant> exactly
04:58:19 <maltem> Cale: thus "for computer-sciency definitions of =="
04:58:28 <Leaves> hey, If I have a global constant (that is const = 44 at the top level somewhere) and functions f uses const, how can I overwrite this?   this doesn't work: g = f where const = 3
04:58:44 <ivanm> Leaves: you mean a local value of const?
04:58:46 <ivanm> should work...
04:58:54 <ivanm> -Wall will complain, but that's not a problem
04:59:14 <Deewiant> just like length /= O(n), rather length ∈ O(n)
04:59:14 <maltem> Cale: although there may be different such ones
04:59:17 <ivanm> but if you want to change the value of the _global_ value of const... there are ways of doing it, but it's not recommended
05:00:19 <mauke> Leaves: you can't
05:00:30 <mauke> it seems like you want dynamic scoping
05:01:00 <Axman6> seems to me like those functions need rewriting...
05:01:03 <ivanm> OK, another question... if I have a type FooBar = Foo String | Bar String, is there any way of getting the string value out _without_ pattern matching (i.e. a single definition that applies to both)?
05:01:12 <Leaves> ivanm: it doesn't seem to work, f keep using the global value
05:01:20 <ivanm> Leaves: want to paste it up?
05:01:23 <ivanm> might just be a typo
05:01:33 <ivanm> but local scope > global scope AFAIK...
05:01:37 <quicksilver> data FooBar = Foo {fbStr :: String} | Bar {fbStr :: String}
05:01:40 <Leaves> the prog is pretty big, I will make an example
05:01:42 <quicksilver> then fbStr is your selector.
05:01:51 <quicksilver> but that's actually no different from writing your own selector.
05:01:58 <ivanm> quicksilver: no, I'm _using_ the data type, I'm not creating it
05:02:08 <ivanm> I didn't think there was, just wanted to check
05:02:16 <maltem> Leaves: iiuc the const in f will always be the same (hence "top-level constant")
05:02:49 <ivanm> maltem: it sounds like he has a local value in a where statement, but the function is still using the global value
05:03:04 <Leaves> ivanm: main = print g; c = 1; f = c == 1; g = f where c = 0
05:03:04 <Leaves> gives True
05:03:08 <quicksilver> depends if it's lexical or not, obviously.
05:03:23 <lightstep> Leaves, the ghc docs talk about imlicit parameter. you can make `const' an implicit paprameter of f, and have g change it locally
05:03:26 <maltem> ivanm: to me it sounds like he really defines g = f where c = 3 -- c is not referenced anywhere
05:03:32 <quicksilver> Leaves: the correct way is to make the constant a parameter of the function.
05:03:43 <ivanm> @hpaste
05:03:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:03:46 <quicksilver> implicit parameters are nasty.
05:03:48 <lightstep> Leaves, or you can make in a regular (explicit) parameter of f
05:03:53 <ivanm> Leaves: ^^ paste something up, so we can make sure we know what you mean
05:04:08 <ivanm> maltem: maybe you're right
05:04:10 <Leaves> quicksilver: I know, it's really ugly this way.. but I have the functions signature as an assignent for school, so I can't change that..
05:04:30 <mauke> Leaves: can I see the problem description?
05:04:44 <maltem> yea, that would be safest :)
05:05:07 <Leaves> mauke: http://www.cs.lth.se/EDA120/assignment3/mcs.html (it's pretty big)
05:05:11 <lambdabot> Title: Maximum common subsequence
05:05:56 <mauke> ok, but what's the task?
05:06:05 <mauke> this is just code + a description of what it does
05:06:31 <Leaves> soyy, I'm linking you to the wrong document (it's related but..)
05:07:14 <Leaves> mauke: http://hpaste.org/10864
05:07:34 <Leaves> but I know that I should really send the prarameter along
05:07:43 <mauke> http://www.cs.lth.se/EDA120/assignment3/ :-)
05:07:44 <lambdabot> Title: Assignment 3: String alignment
05:07:45 <Leaves> I just do it the way it is told me to do now
05:07:46 <Axman6> ok, slightly random mathc question, is there a simple mathematical way to write the floor function?
05:07:54 <Axman6> maths*
05:07:57 <Leaves> mauke: yes, that's it
05:08:16 <lightstep> Leaves, did you mean http://www.cs.lth.se/EDA120/assignment3/ ?
05:08:18 <lambdabot> Title: Assignment 3: String alignment
05:08:26 <lightstep> oops, someone said it earlier
05:08:40 <Leaves> yes, that's it
05:09:07 <Leaves> well, it's no big problem, I've already written a nicer function which takes it as a parameter
05:09:16 <Leaves> I will just hand in both of them
05:09:36 <mauke> Axman6: do you mean notation?
05:09:59 <Axman6> no, a function for it. like signum = x/|x|
05:10:36 <Axman6> or even x/(sqrt(x^2))
05:10:42 <Axman6> if you want to be hardcore
05:10:55 <mauke> ⎣x⎦
05:11:30 <Axman6> yeah i know the notation, just windering if it can be written mathematically as a function
05:11:42 <mauke> I don't know a way
05:11:46 <lightstep> Axman6, floor x = x - x `mod` 1.0
05:12:15 <Axman6> i guess that works, ice work
05:12:17 <Axman6> nice*
05:12:25 <mauke> max { n ∈ \
05:12:27 <mauke> er
05:12:37 <quicksilver> it's normally taken as a primitive
05:12:42 <quicksilver> written with half-brackets
05:12:45 <mauke> max { n ∈ N | n < x }
05:12:51 <quicksilver> "integer part of"
05:12:54 <mauke> make that Z
05:13:21 <lightstep> <=
05:13:30 <mauke> bah, debugging maths
05:13:43 <Axman6> heh
05:14:15 <Axman6> ha, see how you all flounder when you have no monads to torment me!
05:14:31 <maltem> mauke: |x|
05:14:33 <Axman6> displaimer: monads are no longer hard. it's ok
05:14:40 <maltem> wait
05:14:50 <maltem> sry, I mixed up IRC lines
05:14:53 <dolio> > floor (1.5 :: CReal)
05:14:54 <lambdabot>   1
05:15:07 <mauke> Cereal
05:15:35 <dolio> > truncate (1.5 :: CReal)
05:15:36 <lambdabot>   2
05:15:50 <Axman6> > 1.5 :: CReal
05:15:51 <lambdabot>   1.5
05:16:00 <Axman6> > 0.1 :: CReal
05:16:01 <lambdabot>   0.1
05:16:13 <Axman6> > 1/10 :: CReal
05:16:14 <lambdabot>   0.1
05:16:18 <Axman6> rawr
05:16:34 <mauke> > sum (replicate 10 0.1) :: Rational
05:16:35 <lambdabot>   1%1
05:17:18 <Axman6> damn haskell for taking the tricky float crap out of programming
05:17:35 <dolio> You can still have that. :)
05:17:40 <Axman6> > [1.0,1.1..2.0] :: [Rational]
05:17:42 <lambdabot>   [1%1,11%10,6%5,13%10,7%5,3%2,8%5,17%10,9%5,19%10,2%1]
05:17:54 <Axman6> > [1.0,1.1..2.0] :: [CReal]
05:17:55 <lambdabot>   [1.0,1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0]
05:18:00 <Axman6> gah
05:18:05 <Axman6> i did it the other day :(
05:18:13 <Cthulhon> > pi :: Rational
05:18:14 <lambdabot>       No instance for (Floating Rational)
05:18:14 <lambdabot>        arising from a use of `pi' a...
05:18:15 <dolio> > [1.0, 1.1 .. 2.0] :: [Float]
05:18:17 <lambdabot>   [1.0,1.1,1.2,1.3000001,1.4000001,1.5000001,1.6000001,1.7000002,1.8000002,1....
05:18:21 <Axman6> > [1.0,1.1..2.0] :: [Double]
05:18:22 <lambdabot>   [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.5000000...
05:18:34 <Axman6> that's the one i meant
05:18:40 <Axman6> so what are CReals anyway?
05:18:53 <dolio> Computable real numbers.
05:19:19 <Axman6> fair enough
05:19:25 <quicksilver> what's the implementation?
05:19:27 <Axman6> any docs on them? they seem quite useful
05:19:34 <dolio> Int -> Integer.
05:20:01 <quicksilver> digits?
05:20:05 <quicksilver> decimal digits?
05:20:41 <Axman6> dons: you around?
05:22:51 <dolio> quicksilver: Doesn't really say.
05:23:22 <quicksilver> I recall that the problem with digit-based implementations is the undetectablility of recurring decimals.
05:23:40 <quicksilver> and some people swear by sequences of intervals.
05:23:44 <quicksilver> or something.
05:23:46 <dolio> Well, I doubt it's f n = nth digit.
05:23:56 <dolio> You needn't an Integer for that.
05:24:00 * ivanm thinks we need to expand the C<Foo> concept... CBools say? :p
05:24:21 <Deewiant> newtype CBool = CBool Integer deriving Eq
05:24:28 <dolio> So I suspect it's f n = k where (k-1)/(b^n) < r < k/(b^n).
05:24:34 <Deewiant> data CBool = True | False | FileNotFound
05:24:35 <dolio> Or something of the sort.
05:24:51 <quicksilver> ah that sounds sensible.
05:24:58 <quicksilver> that sounds like a sequence of intervals, in deed :)
05:25:01 <dolio> That "where" not being haskell syntax. :)
05:25:16 <dolio> I'm not sure what b is, though.
05:27:22 <Peaker> did anyone consider the idea of making all Haskell functions operate on class instances, rather than concrete types -- except a small subset of pattern-matching functions that operate on types, but are only used via instances?
05:27:38 <Peaker> Allowing everything to be overloaded..   Which could be very useful
05:28:10 <ivanm> what are implicit parameters?
05:28:12 <Peaker> some overloading trickery like Reactive's Behavior overoading, and augustss's tracing overloads fail on boolean functions and such because they are not overloadable
05:29:49 <dolio> > let b = ?x + 5 in (let ?x = 2 in b, let ?x = 3 in b)
05:29:50 <lambdabot>   (7,8)
05:30:07 <dolio> Those are implicit parameters.
05:30:30 <ivanm> ummmmmmm...... so you're basically mapping the function (+5) over all possible values?
05:30:38 <ivanm> *possible values provided
05:30:53 <ivanm> so what does %x mean then?
05:30:54 <dolio> Implicit parameters are kind of like dynamically scoped variables.
05:30:57 <maltem> Peaker: are you thinking of e. g. define (++) in a monoid instance instead of as a standalone function?
05:31:01 <dolio> Although, apparently, not exactly.
05:31:08 <ivanm> heh
05:32:29 <Peaker> maltem: exactly.. fmap instead of map.  True and False should also be methods
05:32:50 <dolio> > let f n = \x -> ?y + x + n ; g = let ?y = 1 in f 5 in (let ?y = 0 in g 3)
05:32:51 <Peaker> maltem: I hate to see overloading libraries break down and require you to use >* and <* for it to keep working because Bool is not overloadable
05:32:51 <lambdabot>   9
05:33:43 <dolio> That's the differentiating example, depending on how you think dynamically scoped variables should work.
05:34:25 <ivanm> OK, so ?x notation lets you kind of define values 'on-the-fly'... what about %x notation?
05:34:34 <maltem> Peaker: the idea of a standard library that is actually one big algebra is quite appealing, but in some places it may again scare us :)
05:34:37 <dolio> Something I've never seen before.
05:34:47 <ivanm> well, haskell-src-exts lists them :s
05:34:55 <Peaker> I think dynamic scoping should be explicit.. just pass an environment down the stack explicitly, or use a reader
05:34:55 <ivanm> so I figured it must be _something_
05:35:02 <dolio> Does it call them anything?
05:35:03 <ivanm> though it seems the ghc user guide hasn't heard of them either :p
05:35:05 <Peaker> language support for it will just encourage bad stuff :)
05:35:56 <quicksilver> %x is antiquotes, isn't it
05:36:00 <quicksilver> (for quasiquotation)
05:36:26 <dolio> I don't think there's any automatic antiquotation.
05:36:35 <dolio> $x is antiquotation for template haskell.
05:36:56 <quicksilver> dolio: GHC 6.10 has a new quasiquote thing.
05:37:02 <quicksilver> I thought it used different syntax than TH
05:37:05 <quicksilver> not sure if % is it though :)
05:37:08 <ivanm> quicksilver: what's quasiquotation?
05:37:11 <dolio> At least, the quasiquotes paper seemed to indicate that you have to build antiquotation yourself.
05:37:21 <quicksilver> @go haskell quasiquotation
05:37:24 <lambdabot> http://www.haskell.org/haskellwiki/Quasiquotation
05:37:24 <lambdabot> Title: Quasiquotation - HaskellWiki
05:37:46 <dolio> Are %x linear implicit parameters, maybe? I never learned what those were exactly.
05:38:07 <ivanm> OK, that says how to )use_ quasiquotation, not what they are
05:38:09 <dolio> And they removed them recently, but that's the only reference I can find about them (the removal). :)
05:38:46 <Cale> http://img.thedailywtf.com/images/200809/errord/divByZero.jpg -- hehe
05:39:27 <ivanm> O...K... then...
05:39:31 <quicksilver> Ah, I think dolio could be right.
05:39:36 <ivanm> they musn't be using Haskell >_>
05:39:37 <quicksilver> linear implicit sounds likely.
05:40:00 <dolio> It is linear implicit parameters.
05:40:09 <dolio> Found an old 5.x manual.
05:41:39 <ivanm> OK, so what are linear implicit parameters?
05:43:37 <dolio> 'Linear implicit parameters are just like ordinary implicit parameters, except they are "linear" -- that is, they cannot be copied, and must be explicitly "split" instead.'
05:43:48 <dolio> But don't worry about them, because they've been removed from GHC.
05:44:05 <ivanm> ... O...K... then...
05:44:12 <ivanm> I only care because I have to parse them :p
05:46:36 <matthew-_> woah, things get _removed_ from GHC?!
05:49:06 <dolio> Reading the section, they are pretty crazy.
05:49:21 <dolio> Apparently there was a Splittable class, with method a -> (a,a)...
05:50:02 <dolio> And when you use a linear implicit parameter more than once, the compiler inserts calls to split.
05:50:20 <matthew-_> mmm. that does look pretty wack
05:50:55 <dolio> And I've never seen them used.
05:54:35 * ivanm _loves_ manually ripping apart/putting together data abstractions from other libraries :s
05:54:55 <ivanm> yesterday I was generating Pandoc values, today I'm ripping apart haskell-src-ext :s
05:56:07 <EvilTerran> is there a list of monad laws somewhere written in terms of return/fmap/join instead of return/(>>=)?
05:57:47 <dolio> Probably in a category theory textbook.
05:58:06 <EvilTerran> hm
05:58:31 <hackage> Uploaded to hackage: Pipe 2.0.1
05:58:32 * EvilTerran knows of one copy of Category Theory for Computer Scientists, and it's in a library that's only open office hours that i can't take books out of =/
05:58:54 <dolio> join (join m) = join (fmap join m)
05:59:56 <medfly> EvilTerran, scan/copy
06:00:11 <dolio> join (return m) = m...
06:00:32 <EvilTerran> medfly, eh, i guess. i might just see if i can find a second-hand copy for myself somewhere.
06:01:09 <Cthulhon> http://books.google.com/books?id=ezdeaHfpYPwC
06:01:10 <lambdabot> Title: Basic Category Theory for Computer ... - Google Book Search
06:01:15 <Cthulhon> Is that it?
06:01:22 <ivanm> EvilTerran: this is the thin little book?
06:02:01 <EvilTerran> Cthulhon, it seems to be, yes
06:02:19 <EvilTerran> ... that doesn't even mention monads on the contents page =/
06:02:33 <Cthulhon> The poreview is missing some pages, but it looks like a substantial amount is there.
06:02:36 <ivanm> EvilTerran: I thought monads weren't from Category Theory...
06:02:38 <Cthulhon> *preview
06:02:48 <ivanm> well, that's not the one I was thinking of
06:02:51 * EvilTerran hasn't actually seen a copy of it, only heard it recommended, and seen it listed on the university library database
06:03:26 <Cthulhon> The missing pages seem to be rather arbitrary.
06:03:58 <Cthulhon> 3,7,10,14...
06:03:59 <EvilTerran> ... or am i thinking of "Category Theory for Computing Science", not "Basic Category Theory for Computer Scientists"?
06:04:00 <EvilTerran> ...
06:04:07 <EvilTerran> @oeis 3 7 10 14
06:04:07 <lambdabot>  Y-projection of the tabular N X N -> N bijection A072732.
06:04:07 <lambdabot>  [0,0,2,0,1,4,0,0,3,6,0,0,1,5,8,0,0,1,3,7,10,0,0,1,2,5,9,12,0,0,1,1,4,7,11,14...
06:04:21 <Cthulhon> That must be it.
06:05:31 * ivanm has http://books.google.com/books?id=qx0lHwAACAAJ&dq=categories+and+computer+science&ei=kRjmSJqoO4f0sQOgkZW3Dw
06:05:33 <lambdabot> Title: Categories and Computer Science - Google Book Search, http://tinyurl.com/4ph65w
06:05:43 <ivanm> I got to the arrows chapter and gave up :p
06:05:53 <EvilTerran> that's a different one again
06:05:54 <ivanm> but interesting how they created stacks out of categories
06:06:06 <dolio> Anyhow, the rules are for the monad to be a monoid.
06:06:06 <EvilTerran> this seems to be a remarkably popular subject to write about
06:06:24 <dolio> With return the identity, and join the multiplication.
06:06:27 <EvilTerran> in books with confusingly-similar names
06:06:31 <ivanm> heh
06:06:45 <matthew-_> the pi-calculus doesn't have non-deterministic choice right? That's CSP?
06:07:31 <dolio> So, return :: I -> M and join :: M^2 -> M are the natural transformations in question (I is the identity functor, M is the functor for the monad).
06:08:03 <EvilTerran> matthew-_, well, i know CSP has non-det choice, anyway
06:08:26 <EvilTerran> dolio, i'm not entirely sure how those can form a monoid...
06:08:49 <dolio> So one law is M(M^2) = (M^2)M, which is join . join = join . fmap join
06:09:42 <dolio> And then you have MI = IM = M
06:09:44 <EvilTerran> ah, i see, it's a monoid in a completely different way to haskell Monoids :P
06:09:57 <dolio> It's a monoid in the category of endofunctors.
06:10:04 <EvilTerran> ... ok
06:10:17 <EvilTerran> does "MI = IM = M" translate readily into haskell?
06:10:24 <dolio> So, MI = M is join . fmap return = id
06:10:46 <quicksilver> EvilTerran: well, laws are still laws
06:10:48 <dolio> And IM = M is join . return = id
06:10:54 <quicksilver> unless they're naturality laws, which we get for free.
06:10:57 <dolio> I believe.
06:11:27 <EvilTerran> righto
06:12:09 <EvilTerran> i *think* i follow. ish.
06:12:38 <EvilTerran> not entirely clear on how one goes between the functor equalities and the haskell equalities
06:12:48 <EvilTerran> but that'd probably require a better grasp of CT than i presently have
06:13:32 <dolio> Well, return is a natural transformation from I -> M, which in haskell terms is like Id a -> M a.
06:13:39 <dolio> But you drop the Id.
06:13:57 <dolio> Since category theory doesn't need newtypes. :)
06:14:08 <EvilTerran> IM is Id `O` M ?
06:14:15 <dolio> Yeah.
06:14:16 <ski> dolio : `M(M^2)' ?
06:14:43 <ski> maybe you want s/M/mu/, there ?
06:15:01 <EvilTerran> so "M(M^2) = (M^2)M" means "M `O` (M `O` M) = (M `O` M) `O` M"?
06:15:29 <EvilTerran> (reading "=" as "is isomorphic to", i guess)
06:16:06 <dolio> Yeah. Doing the product operation in different orders doesn't change the result.
06:16:12 <EvilTerran> ie, given x :: m (m (m a)), you can join the inner two then join what's left, or join the outer two and then what's left
06:16:15 <EvilTerran> and get the same end result
06:16:19 <EvilTerran> ?
06:16:22 <dolio> Right.
06:16:29 <EvilTerran> yay, i'm getting the hang of this :)
06:16:45 <EvilTerran> hence, "join (join x) = join (fmap join x)"
06:17:40 <ski> mu . (mu .. M) = mu . (M .. mu)
06:18:15 <ski> ( mu : M . M -> M )
06:18:37 <EvilTerran> fmap return :: M (Id a) -> M (M a), so join . fmap return :: M (Id a) -> M a
06:18:58 <EvilTerran> which must be an isomorphism
06:20:11 <ski> (  eta_i : F_i -> G_i  |-  mu .. eta_0 : (M . M) . F_0 -> M . G_0  ,  eta_1 .. mu : F_1 . (M . M) -> G_1 . M  )
06:20:19 <EvilTerran> likewise, (join :: M (M a) -> M a) . (return :: Id (M a) -> M (M a)) :: Id (M a) -> M a, must be another isomorphism
06:20:31 <Axman6> what happened to all the beautiful haskell :(
06:20:41 <EvilTerran> those two corresponding to MI = M and IM = M respectively
06:21:40 <EvilTerran> Axman6, the haskell got abstracted away by the wicked category theorists and locked in the highest room of their ivory tower :P
06:22:01 <Axman6> shoo, all of you, go on, git!
06:22:17 <EvilTerran> dolio++ I feel enlightened :)
06:23:44 <ski> (to be pedantic, one needs to insert maps `(A . B) . C <-> A . (B . C)' and `A <-> A . I',`I . B <-> B' in some places, as well ..)
06:24:00 <dolio> @karma dolio -- moving on up
06:24:00 <lambdabot> You have a karma of 2
06:25:07 <mauke> preflex: karma dolio
06:25:07 <preflex>  karma for dolio: 4
06:25:20 <ski> @karma preflex
06:25:21 <lambdabot> preflex has a karma of 0
06:25:22 <Axman6> dolio: lambdabot hates you :(
06:25:30 <dolio> @karma dons
06:25:31 <lambdabot> dons has a karma of 3
06:25:35 <mauke> preflex: karma dons
06:25:35 <preflex>  karma for dons: 22
06:25:40 <mauke> that's more like it
06:25:43 <dolio> :)
06:26:29 <EvilTerran> preflex: karma
06:26:29 <preflex>  karma for EvilTerran: 11
06:26:32 <EvilTerran> :)
06:26:48 <ski> preflex: karma preflex
06:26:48 <preflex>  karma for preflex: 5
06:26:48 <medfly> is that random/
06:27:03 <mauke> no, but version is
06:27:05 <medfly> preflex: karma dons
06:27:05 <preflex>  karma for dons: 22
06:27:24 <lilac> anyone up for some golf?
06:27:29 <lilac> > let f ts [] = ts; f ts (xs:xss) = f (g ts xs) xss; g (t:ts) (x:xs) = t+x:g ts xs; g [] xs = xs; g ts [] = ts in f [] [[1,2,3],[4,5],[6,7,8,9]]
06:27:30 <lambdabot>   [11,14,11,9]
06:27:44 <EvilTerran> medfly, preflex counts the number of times people say [word]++ and [word]--, and reports the difference as that word's karma
06:27:53 <EvilTerran> preflex: karma preflex
06:27:53 <preflex>  karma for preflex: 5
06:27:55 <EvilTerran> preflex++
06:27:57 <EvilTerran> preflex: karma preflex
06:27:57 <preflex>  karma for preflex: 6
06:27:59 <medfly> fancy
06:28:29 <Axman6> preflex: karma haskell
06:28:29 <preflex>  karma for haskell: 9
06:28:36 <Axman6> @karma haskell
06:28:36 <lambdabot> haskell has a karma of 1
06:28:42 <int-e> preflex: karma c
06:28:42 <preflex>  karma for c: 32256
06:28:43 <EvilTerran> preflex: karma C
06:28:44 <preflex>  karma for C: 32256
06:28:46 <EvilTerran> heh
06:28:47 <Axman6> hakell-- :(
06:28:48 <medfly> heh
06:28:54 <int-e> preflex: karma
06:28:54 <preflex>  karma for int-e: 2
06:28:57 <Axman6> ha
06:29:02 <EvilTerran> we need to spend more time talking about c--
06:29:09 <mauke> > map sum $ transpose [[1,2,3],[4,5],[6,7,8,9]]
06:29:10 <lambdabot>   [11,14,11,9]
06:29:14 <int-e> preflex: karma c++
06:29:14 <preflex>  karma for c++: -19
06:29:15 <mauke> lilac: what do I win?
06:29:17 <int-e> c++++
06:29:18 <Axman6> so, how about that porting GHC++ to use C--?
06:29:19 <int-e> preflex: karma c++
06:29:19 <preflex>  karma for c++: -18
06:29:22 <int-e> silly :)
06:29:37 <mauke> preflex: karmatop
06:29:39 <preflex>  c: 32256; g: 1735; ##c: 1096; c/c: 885; vc: 663; #c: 501; notepad: 376; which focuses on standard c: 311; moritz: 281; "c: 263
06:29:42 <Axman6> > repeat "C--"
06:29:43 <lambdabot>   ["C--","C--","C--","C--","C--","C--","C--","C--","C--","C--","C--","C--","C...
06:29:59 <medfly> what is moritz?
06:30:11 <EvilTerran> > say . cycle $ "C-- "
06:30:12 <lambdabot>   Not in scope: `say'
06:30:18 <EvilTerran> > var . cycle $ "C-- "
06:30:19 <lambdabot>       Ambiguous occurrence `var'
06:30:19 <lambdabot>      It could refer to either `Data.Number.S...
06:30:21 <EvilTerran> grr
06:30:22 <mauke> maybe someone on #perl6?
06:30:26 <int-e> oh.
06:30:30 <medfly> oh.
06:30:32 <int-e> la la++
06:30:36 <int-e> preflex: karma la la
06:30:36 <preflex>  la la has no karma
06:30:53 * int-e wonders how the "which focuses on standard c" came to be.
06:30:58 <Axman6> preflex: karma C
06:30:58 <preflex>  karma for C: 32256
06:31:08 <mauke> int-e: use ( ) to escape spaces inside
06:31:27 <int-e> (la la++)?
06:31:32 <medfly> > repeat " C-- "
06:31:33 <lambdabot>   [" C-- "," C-- "," C-- "," C-- "," C-- "," C-- "," C-- "," C-- "," C-- "," ...
06:31:34 <int-e> preflex: karma la la
06:31:34 <preflex>  karma for la la: 1
06:31:42 <int-e> mauke: ok, that makes sense then.
06:31:56 <mauke> well, you're supposed to use "(la la)++", but the parser is ... more flexible
06:32:15 <medfly> people in this channel have such useful bots.
06:32:32 <EvilTerran> @bots
06:32:32 <lambdabot> :)
06:32:44 <int-e> I guess it's something like "you should join ##c-- (which focuses on standard c--)"
06:33:03 <Axman6> preflex: karma C++
06:33:03 <preflex>  karma for C++: -18
06:33:07 <Axman6> heh
06:33:14 <mauke> probably a factoid in ##c
06:33:16 * Axman6 tests...
06:33:18 <Axman6> preflex: karma C++
06:33:18 <preflex>  karma for C++: -18
06:33:21 <Axman6> ok, good
06:33:32 <Axman6> wait, no
06:33:40 <Axman6> preflex: karma C
06:33:40 <preflex>  karma for C: 32249
06:33:44 <Axman6> preflex: karma C++
06:33:44 <preflex>  karma for C++: -18
06:33:46 <Axman6> preflex: karma C
06:33:46 <preflex>  karma for C: 32250
06:33:52 <Axman6> heh
06:34:03 <EvilTerran> might be in the <title> of a URL frequently linked in one of the channels preflex is in
06:34:03 <mauke> EXPERT COMMAND PARSER
06:34:15 <int-e> (++
06:34:22 <EvilTerran> if there's a bot that announces <title>s in the channel
06:34:39 <int-e> (++) - I wonder if this does anything :)
06:34:49 <EvilTerran> preflex: karma ()
06:34:49 <preflex>  () has no karma
06:34:53 <Axman6> preflex: karma (
06:34:53 <preflex>  karma for (: 41
06:34:58 <EvilTerran> heh
06:35:05 <EvilTerran> preflex: karma )
06:35:05 <preflex>  karma for ): -1
06:35:06 <Axman6> (++)
06:35:06 <int-e> preflex: karma ()
06:35:07 <preflex>  () has no karma
06:35:09 <Axman6> preflex: karma (
06:35:09 <preflex>  karma for (: 41
06:35:12 <Axman6> hmm
06:35:16 <int-e> ()++
06:35:19 <int-e> preflex: karma ()
06:35:19 <preflex>  () has no karma
06:35:22 <medfly> preflex, karma C++
06:35:22 <preflex>  karma for C++: -18
06:35:24 <medfly> preflex, karma C++
06:35:24 <preflex>  karma for C++: -18
06:35:27 <EvilTerran> (())++
06:35:28 <medfly> preflex, karma C
06:35:28 <preflex>  karma for C: 32252
06:35:31 <EvilTerran> preflex: karma ()
06:35:31 <preflex>  karma for (): 1
06:35:34 <EvilTerran> ta-dah!
06:35:35 <medfly> preflex, karma C++
06:35:35 <preflex>  karma for C++: -18
06:35:35 <medfly> preflex, karma C
06:35:37 <preflex>  karma for C: 32253
06:35:39 <medfly> :)
06:35:50 <mauke> preflex: quote
06:35:51 <preflex>  <gwern> be warned preflex, your time will come! you too shall make use of mueval
06:35:52 <EvilTerran> maybe we should stop playing with preflex and get back on topic <.<  >.>
06:35:52 <int-e> preflex: karma
06:35:53 <preflex>  karma for int-e: 2
06:35:56 * int-e shrugs
06:35:57 <Axman6> > cycle "c-- "
06:35:58 <lambdabot>   "c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-- c-...
06:36:03 <ivanm> EvilTerran: topic?
06:36:05 <ivanm> @quote on-topic
06:36:05 <lambdabot> No quotes match. I feel much better now.
06:36:09 <ivanm> @quote ontopic
06:36:09 <lambdabot> No quotes match. You untyped fool!
06:36:12 <ivanm> @quote topic
06:36:12 <lambdabot> qwe1234 says: lol, thanks for the pointless offtopic post
06:36:17 <ivanm> @quote off-topic
06:36:18 <lambdabot> dmwit says: Incidentally, I'm happy that xmonad has enough followers now for the discussions to wander off-topic.
06:36:20 <ivanm> @quote off-topic
06:36:20 <lambdabot> dmwit says: Incidentally, I'm happy that xmonad has enough followers now for the discussions to wander off-topic.
06:36:23 <ivanm> @quote offtopic
06:36:23 <lambdabot> qwe1234 says: lol, thanks for the pointless offtopic post
06:36:31 <ivanm> grrr.... can't find the quote I'm after
06:36:34 <ivanm> the off-off-topic one
06:36:36 <EvilTerran> @quote off.topic
06:36:36 <lambdabot> dmwit says: Incidentally, I'm happy that xmonad has enough followers now for the discussions to wander off-topic.
06:36:42 <EvilTerran> @quote on.topic
06:36:42 <lambdabot> No quotes match. The more you drive -- the dumber you get.
06:37:18 <ezraburgh> hate to bring it back but... wikipedia has good square diagrams for the monad laws: http://en.wikipedia.org/wiki/Monad_(category_theory)#Formal_definition
06:37:21 <lambdabot> Title: Monad (category theory) - Wikipedia, the free encyclopedia, http://tinyurl.com/292hll
06:37:24 <mauke> @quote off.off
06:37:25 <lambdabot> No quotes match. Sorry.
06:37:28 <lilac> @quote orbit
06:37:29 <lambdabot> DRMacIver says: #haskell doesn't so much wander off topic as orbit it. :)
06:38:05 <mauke> preflex: karmabot
06:38:07 <preflex>  <: -3209; <-: -663; -: -452; apathy: -221; <!: -129; <--: -109; ^: -80; --: -53; -rw-r--r: -48; me: -43
06:38:22 <ivanm> maybe lambdabot lost it in her latest reboot?
06:38:31 <int-e> arrows lose!
06:38:32 <ivanm> it was on hwn a couple of releases ago
06:38:36 <Adamant> @quote monkeys
06:38:36 <lambdabot> No quotes match. :(
06:38:50 <Adamant> :(
06:39:06 <Adamant> discrimi-hating on our simian compatriots
06:39:35 <mauke> preflex: remember shepheb #haskell isn't so much on-topic when discussing Haskell, but off-off-topic.
06:41:41 <ski> preflex: karma Robert'); DROP TABLE Students;
06:41:41 <preflex>  Robert'); DROP TABLE Students; has no karma
06:42:34 <Axman6> poor little bobby tables
06:44:36 <int-e> lilac: f = foldl g
06:46:39 <int-e> > map sum $ transpose [[1,2,3],[4,5],[6,7,8,9]]
06:46:40 <lambdabot>   [11,14,11,9]
06:55:00 <lilac> yeah, map sum . transpose would be hard to beat
06:55:06 <lilac> harder one next time!
07:12:00 <Axman6> @src transpose
07:12:01 <lambdabot> transpose []             = []
07:12:01 <lambdabot> transpose ([]   : xss)   = transpose xss
07:12:01 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
07:12:30 <Botje> > foldl' (zipWith +) (repeat 0) [[1,2,3],[4,5],[6,7,8,9]]
07:12:31 <lambdabot>   Couldn't match expected type `a -> b -> c'
07:12:39 <Botje> > foldl' (zipWith (+)) (repeat 0) [[1,2,3],[4,5],[6,7,8,9]]
07:12:41 <lambdabot>   [11,14]
07:12:46 <Botje> what kind of freak section is that :/
07:13:00 <Botje> heh, makes sense :p
07:15:33 <dreixel> uh, this is a darcs question, but
07:15:34 <dreixel> how can I get patches that I already sent into a file?
07:17:03 <Deewiant> why doesn't the former of these compile? http://hpaste.org/10866
07:17:34 <ski> @let zipWithD ac bc abc = loop where {loop [] bs = map bc bs; loop as [] = map ac as; loop (a:as) (b:bs) = abc a b:loop as bs}
07:17:36 <lambdabot>  Defined.
07:17:42 <ski> > let f xss = foldl g [] xss; g ts xs = zipWithD id id (+) ts xs in f [[1,2,3],[4,5],[6,7,8,9]]
07:17:43 <lambdabot>   [11,14,11,9]
07:18:39 <EvilTerran> http://hpaste.org/10867  <- any thoughts?
07:18:59 <EvilTerran> i've been playing with NoImplicitPrelude and the do-block desugaring
07:19:15 <EvilTerran> the exampleN functions are the punchline
07:19:45 <BONUS> i think you have to move the forall all the way to the left
07:19:53 <BONUS> oh wil hmm
07:19:53 <BONUS> no
07:20:49 <BONUS> EvilTerran that looks pretty cool
07:21:00 <BONUS> i like the Functor => Pointed => Applicative => Monad thing
07:21:14 <EvilTerran> I'm particularly chuffed with (\m -> do m; pure ()
07:21:14 <EvilTerran> ) :: Applicative f => f a -> f ()
07:21:41 <EvilTerran> ... dammit, xchat, stop putting in newlines when i tell you to! :P
07:22:09 <EvilTerran> (that one relying on the desugaring using (>>) instead of (>>=) if you don't bind the result of an action)
07:23:16 <BONUS> hmmm, i havent seen bind implemented with join yet
07:23:17 <BONUS> interesting
07:23:19 <telexicon> haskell is pretty popular
07:24:37 <BONUS> although i'm never sure about hmm
07:24:48 * EvilTerran tries to think of a property that applies to [] but not Maybe, say
07:24:49 <BONUS> i know Monad shouldn't really have fail as a function of the class
07:25:12 <BONUS> but it's really handy to do fail "blah" :: Either String a
07:25:19 <EvilTerran> BONUS, that'd still work
07:25:28 <BONUS> how would you propose putting in failing with a message into monads
07:25:45 <mauke> MonadFail
07:25:46 <EvilTerran> fail :: Fail f => String -> f a
07:25:55 <BONUS> ah
07:25:57 <BONUS> that makes sense
07:26:00 <int-e> @check \xss -> (transpose . transpose . transpose) xxs == transpose (xxs :: [[Int]])
07:26:00 <telexicon> as far as functional languages go
07:26:00 <lambdabot>   Not in scope: `xxs'Not in scope: `xxs'
07:26:08 <BONUS> would you still keep MonadZero then?
07:26:11 <int-e> @check \xss -> (transpose . transpose . transpose) xss == transpose (xss :: [[Int]])
07:26:13 <EvilTerran> BONUS, i forgot Fail in my first paste; http://hpaste.org/10867#a1
07:26:16 <lambdabot>   "OK, passed 500 tests."
07:26:27 <int-e> @check \xss -> (transpose . transpose) xss == (xss :: [[Int]])
07:26:27 <lambdabot>   "Falsifiable, after 0 tests:\n[[],[1,-1],[]]\n"
07:26:57 <BONUS> how about something like FailPlus where you have mzero, fail and mempty as fail ""
07:27:02 <BONUS> i mean
07:27:02 <b_jonas> hello
07:27:05 <EvilTerran> the idea being that, if a do-block has no patterns that can fail, the class constraint will be at most (Monad f => ...)
07:27:07 <BONUS> mplus, fail and mzero as fail ""
07:27:14 <mauke> did you know? return() is idempotent in perl
07:27:19 <EvilTerran> but, if it does have such patterns, it'll be (Monad f, Fail f) => ...
07:28:14 <EvilTerran> BONUS, i'm thinking of having two pairs of classes, "class Zero f where zero :: f a" and "class Additive f where (<+>) :: f a -> f a -> f a"
07:28:30 <BONUS> ah
07:28:33 <EvilTerran> and "class Empty f where empty :: f a; class Alternative f where (<|>) :: f a -> f a -> f a"
07:28:42 <BONUS> does it make sense to have f a -> f a -> f a at all then?
07:28:47 <BONUS> why not just make it request a kind of *
07:29:00 <EvilTerran> the distinguishing feature of Alternative being that x <|> x = x
07:29:25 <EvilTerran> but i'd want some similar property that Additives would have but Alternatives would lack to make Additive worth having
07:29:58 <Deewiant> Anybody know how to use 6.10's Control.Exception.catch to catch any type of Exception? My best attempt so far resulted in finding GHC bug #2649 and I'm none the wiser for it
07:30:08 <BONUS> but what kind would you make Additive?
07:30:12 <BONUS> * or * -> *
07:30:22 <EvilTerran> BONUS, yeah, you could just do away wit hthe whole Additive/Alternative thing and throw in a Monoid constraint instead
07:30:29 <hugo__> anyone knows of a portuguese haskell community ?
07:30:49 <EvilTerran> (do {...}) <+> (do { ... }) :: (Monad m, Monoid (m a)) => m a
07:30:50 <BONUS> i really like that approach, although one downside would be that you'd have a lot of class constraints sometimes
07:30:53 <BONUS> like
07:31:03 <BONUS> (Monad m, Additive m, Zero m) => ...
07:31:22 <EvilTerran> well, Additive would be a subclass of Zero
07:31:31 <BONUS> ah
07:31:32 <EvilTerran> (forgot that earlier)
07:31:37 <BONUS> then it would be cool yeah
07:32:03 <EvilTerran> although Zero need only be a subclass of Functor for all the laws i need for it, so it would be (Monad f, Additive f) => ...
07:32:08 <dblazakis> so, what is the difference between 'pure', 'unit', and 'return'?
07:32:16 <EvilTerran> ?hoogle unit
07:32:16 <mauke>  
07:32:16 <lambdabot> Data.Generics data Unit
07:32:16 <lambdabot> Data.Generics Unit :: Unit
07:32:16 <lambdabot> Language.Haskell.Syntax unit_con :: HsExp
07:32:23 <EvilTerran> dblazakis, the types
07:32:34 <EvilTerran> although, where is unit?
07:32:53 <dblazakis> just terminology, not defined in Haskell
07:32:56 <BONUS> pure is for applicative functors, return for monads, although many times they result in the same thing
07:33:08 <jpcooper> @hoogle a -> [a]
07:33:09 <lambdabot> Prelude repeat :: a -> [a]
07:33:09 <lambdabot> Data.List repeat :: a -> [a]
07:33:09 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
07:33:11 <lilac> dblazakis: they're all special cases of a more general 'lift'-type operation, which haskell doesn't let you type ;D
07:33:15 <BONUS> > (pure 3 :: Maybe Int) == (return 3 :: Maybe Int)
07:33:16 <lambdabot>       Ambiguous occurrence `pure'
07:33:16 <lambdabot>      It could refer to either `Control.Appl...
07:33:21 <BONUS> ugh
07:33:23 <BONUS> f u lambdabot
07:33:26 * lilac ponders
07:33:37 <BONUS> haha hmm
07:33:38 <int-e> and then there's Control.Arrow.pure.
07:33:39 <BONUS> Liftable?
07:33:40 <lilac> class Lift a b where lift :: a -> b
07:33:43 <EvilTerran> could lambdabot import Control.Arrow hiding pure? it's nothing but trouble
07:33:50 <lilac> that's going to get mad overlaps
07:33:52 <EvilTerran> and you can always use arr
07:34:05 <EvilTerran> > (Control.Applicative.pure 3 :: Maybe Int) == (return 3 :: Maybe Int)
07:34:06 <lambdabot>   True
07:34:10 <int-e> @type id <$> ?x
07:34:11 <lambdabot> forall a (f :: * -> *). (Functor f, ?x::f a) => f a
07:34:13 <EvilTerran> ?src Maybe pure
07:34:13 <lambdabot> pure = return
07:34:18 <EvilTerran> :D
07:34:25 <dblazakis> heh
07:34:44 <EvilTerran> ?src Maybe (<*>)
07:34:44 <lambdabot> (<*>) = ap
07:34:47 <EvilTerran> huzzah!
07:36:33 <hugo__> maybe ill start a portuguese haskell community
07:36:41 <hugo__> since i cant find one... :/
07:38:40 <BONUS> EvilTerran you got a blog or something? you should publish this somewhere imho
07:38:53 <EvilTerran> i was thinking i might post it to haskell-cafe
07:39:09 <EvilTerran> when it's a bit more polished; i'll haddock it up first
07:39:16 <BONUS> kewl
07:39:24 <EvilTerran> also i have to write instances for everything
07:39:25 <BONUS> i'd like to subscribe to haskell-cafe but i hate getting mailing lists in my mail client and stuff
07:39:38 <EvilTerran> you can browse it on the web somewhere, sec
07:39:40 <BONUS> is there some other way to follow mailing lists without getting tons of mail in your mail client
07:39:48 <Deewiant> gmane
07:39:49 <EvilTerran> ?where haskell-cafe
07:39:50 <lambdabot> http://www.haskell.org/mailman/listinfo/haskell-cafe
07:40:20 <dblazakis> EvilTerran: what does Pointed mean?  in other words, why did you chose that name?
07:40:28 <BONUS> whats the difference between haskell-cafe and haskell anyway
07:40:29 <EvilTerran> dblazakis, i believe it's a CT term
07:40:42 <dblazakis> ah, ok, fair enough
07:40:44 <EvilTerran> ?where+ gmane  http://news.gmane.org/gmane.comp.lang.haskell.cafe
07:40:45 <lambdabot> Done.
07:41:02 <EvilTerran> i would've called it Pure, but that'd look really weird
07:41:27 <EvilTerran> BONUS, ^ the cafe
07:41:42 <BONUS> ah
07:41:45 <BONUS> cool, thanks
07:44:15 <BONUS> hey guys, im writing (yet yet yet another) haskell tutorial, mainly to gain insight myself, check it out at www.learnyouahaskell.com and please send me corrections if you find any errors
07:45:00 <ski> EvilTerran : <http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal>
07:45:19 <ski> (s/MonadOr/MonadElse/)
07:45:40 <mauke> OR ELSE
07:46:14 <ski> *nod*
07:46:32 <maltem> BONUS: wait, you're an elephant?
07:47:05 <BONUS> haha no the elephant is the reader
07:47:21 <mauke> MonadElephant
07:48:53 <maltem> wait... so _I_ am an elephant?
07:49:03 <BONUS> in a good sense :)
07:49:42 <Asztal> not only do you never forget, but your big ears allow for optimal brain cooling.
07:49:42 <maltem> heh
07:49:49 <BONUS> haha
07:50:12 <lilac> BONUS: can i report a grammatical error in your url? :)
07:50:19 <BONUS> lol
07:50:23 <BONUS> yes can you!
07:50:33 <BONUS> basically its supposed to be a tutorial for absolute beginners and the pretty pictures are there so they dont get scared
07:50:46 <lilac> it should be 'learn you a haskell for great justice'
07:50:58 <BONUS> hmm that could work too
07:51:09 <lilac> 'learn you a haskell to do way instain mother'
07:51:20 <BONUS> learn you a haskell for make benefit you
07:51:47 <lilac> "I failed to learn Haskell approximately 2 times" lol
07:52:00 <BONUS> yeah i was like screw this crap this is strange
07:52:04 <BONUS> and then i fell in love <3
07:52:46 <lilac> "Haskell was made by some really smart guys (with PhDs)" lol
07:52:46 <hugo__> :D
07:52:57 <hugo__> "haskell for fun and profit"
07:53:02 <lilac> i think that should be "(with PhDs!!)"
07:53:03 <mauke> as they say, "Powered by PhD"
07:53:11 <BONUS> haha yeah i think i'll add some exclamation marks
07:53:15 <Axman6> anyone else see that post on planet haskell about averages?
07:53:29 <hugo__> "Just Haskell It"
07:53:34 <EvilTerran> ski, aha, so the property for Additive would be left distribution!
07:53:50 <lilac> "I don't have a Mac so I don't know how to install it on OS X but it probably involves using the mouse with only one button." lol
07:53:54 <lilac> this is great
07:53:54 <BONUS> some people have accused me of trying to be like that Why guy but the only thing this has in common with his book is pretty pictures, i'm not half as wacky an zany
07:53:55 <Twey> Is this the Haskell equivalent to that Ruby tutorial?
07:53:58 <Axman6> Just Haskell or Nothing
07:54:10 <BONUS> hehe kind of
07:54:21 <BONUS> although that tutorial was a bit too much wacky and zany jokes
07:54:25 <BONUS> and too little actual tutorial
07:54:35 <Twey> That was kind of the point
07:54:42 <EvilTerran> hehe
07:55:09 <Asztal> is there a chunky bacon equivalent in this one?
07:55:10 <BONUS> yeah, i didnt like that approach too much though. so here i tried having a light atmosphere but still sticking to the point
07:55:21 <BONUS> no bacon, im allergic!
07:55:30 <Twey> It wasn't an approach, it was a parody :-P
07:55:41 <skorpan> BONUS: you should probably say something about why stuff goes wrong here: "Doing 5 * -3 will make GHCI yell at you but doing 5 * (-3) will work just fine."
07:55:52 <ski> (EvilTerran : also see /MonadPlus, if you missed it)
07:55:59 <BONUS> skorpan: yeah, i think you're right
07:56:02 <BONUS> thanks for pointing that out
07:56:09 <BONUS> i'll elaborate a bit more on the - thingy
07:56:09 <lilac> Doing 5*-3 will make GHC say something very strange indeed
07:56:11 <EvilTerran> "Haskell: When it's convenient, you shoot yourself in the foot, but it doesn't hurt if you don't look at your foot afterwards."
07:56:13 <BONUS> noted
07:56:25 <Twey> Hahaha
07:56:32 <EvilTerran> lilac, that's because *- is interpreted as one operator
07:56:40 <lilac> > let a *- b = a * (-b) in 5*-3
07:56:41 <lambdabot>   -15
07:56:42 * PHO_ failed to brainwash my co-workers into learning Haskell for letting his tongue slip "Haskell was indeed very difficult for me."
07:56:42 <EvilTerran> ski, ta
07:56:45 <lilac> EvilTerran: obviously ;)
07:57:04 <maltem> BONUS: I'm with you, I don't like why's humour particularly
07:57:05 <BONUS> anyway if you guys have any suggestions regarding learnyouahaskell.com just shoot me a mail or have lambdabot tell me, i'd appreciate it much
07:57:06 * EvilTerran thinks a ^- operator would be useful
07:57:23 <ski> for .. ?
07:57:31 <EvilTerran> but, for *- and /-, i just tend to move the - to outside the * or /
07:57:33 <lilac> BONUS: perhaps a public health notice: learn you a haskell for great good may cause you to brain much
07:57:40 <EvilTerran> > 2 ^ -1
07:57:41 <BONUS> hahaha
07:57:41 <lambdabot>       precedence parsing error
07:57:41 <lambdabot>          cannot mix `(^)' [infixr 8] and prefi...
07:57:45 <maltem> ski: nth root I guess?
07:57:55 <BONUS> brain strain warning
07:57:56 <skorpan> BONUS: you should probably make the website accept comments right there on the site, kind of like real world haskell or djangobook
07:57:57 <EvilTerran> @let x ^- y = x ^ (-y) in 2^-1
07:57:57 <ski> oh
07:57:57 <lambdabot>   Parse error
07:58:03 <EvilTerran> oops
07:58:08 <lilac> @pl \a b -> a * (-b)
07:58:08 <lambdabot> (. negate) . (*)
07:58:17 <maltem> ah no, he takes the literal meaning
07:58:20 <BONUS> yeah, i probably should, the only thing is im appropriately lazy
07:58:20 <BONUS> haha
07:58:25 <ski> @let x ^- y = x ^ (-y)
07:58:26 <lambdabot>  Defined.
07:58:30 <ski> > 2^-1
07:58:32 <lambdabot>   * Exception: Negative exponent
07:58:36 <EvilTerran> actually, that should probably be x ^^ (-y)
07:58:43 <PHO_> > 2 ** (-1)
07:58:44 <lambdabot>   0.5
07:58:47 <ski> @let x ^^- y = x ^^ (-y)
07:58:48 <lambdabot>  Defined.
07:58:51 <ski> > 2^^-1
07:58:52 <lambdabot>   0.5
07:58:59 <lilac> BONUS: do not learn you a haskell for great good if you has the dumb
07:59:09 <BONUS> wa wa wee wa is nice
07:59:23 <BONUS> haskell is for children aged 18 and up
07:59:31 <Japsu> @quote rules of go
07:59:31 <lambdabot> No quotes for this person. It can only be attributed to human error.
07:59:31 <ski> no
07:59:35 <lilac> @let (+-) = (-)
07:59:36 <Japsu> @quote sarah
07:59:36 <lambdabot>  Defined.
07:59:36 <lambdabot> sarah says: "But I don't _want_ functional programming!" -- Sarah Peyton Jones, age 11, upon hearing the rules of Go
07:59:39 <ski> (err, ECHAN)
07:59:51 <BONUS> haha
08:00:28 <lilac> #haskell is not suitable for those with nut allergies
08:00:45 <Japsu> This channel may contain nuts or remains thereof.
08:01:35 <lilac> #haskell is produced in an IRC network which also handles nuts.
08:02:27 <skorpan> BONUS: another thing... "doubleSmallNumber" with the introduction of "if" is incorrect.
08:02:39 <BONUS> lets see
08:02:44 * EvilTerran tries to work out if "fmap f zero = zero" implies "zero >>= f = zero"
08:03:03 <EvilTerran> given the laws i've defined so far
08:03:51 <BONUS> ugh yeah, indentation screwed me over
08:03:53 <BONUS> gonna fix that now
08:04:05 <dolio> zero >>= f = join (fmap f zero) = join zero =? zero
08:04:35 <lilac> i don't like layout
08:04:52 <BONUS> okay fixt
08:04:58 <lilac> it seems like it should free you from needing to know that {} rules for haskell, but it doesn't
08:05:14 * EvilTerran notes he doesn't have "f =<< x = join (f <$> x)" down, either
08:05:15 <BONUS> hmm
08:05:54 * lilac thinks the easiest way to learn haskell (for me at least) would have been to learn with {} first, then learn layout
08:06:11 <EvilTerran> other than as the default definition of =<<
08:06:21 <EvilTerran> ... but can i prove it from the other laws...
08:06:28 <BONUS> i came from python so layout was simple for me
08:06:29 <BONUS> i guess
08:06:36 <PHO_> Hmm... I like this tutorial BONUS. It would be cool if there were any tutorials like this written in Japanese...
08:06:43 <BONUS> hehe thanks
08:06:48 <BONUS> unfortunately i dont know japanese ^_^
08:07:08 <PHO_> I'm from Japan and I can't brainwash my friends into learning Haskell
08:07:20 <PHO_> because there are no good tutorials in Japanese :(
08:07:26 <BONUS> but it's licensed under creative commons so if someone wants to translate and publish it, they're free to do so hehe
08:07:38 <PHO_> hum
08:08:03 <lilac> BONUS: i came from python which made layout harder for me
08:08:17 <lilac> BONUS: because python's layout rules make intuitive sense
08:08:28 <mauke> uh huh
08:08:38 <int-e> lilac: hmm, but so do Haskell's?
08:08:41 <BONUS> i just figured: stuff thats common should be on the same column
08:09:16 <dblazakis> lilac: python has layout rules?
08:09:30 <b_jonas> dblazakis: obligatory ones
08:09:46 <mauke> one word: the forced indentation of the code
08:09:58 <dblazakis> ah, duh
08:10:04 <b_jonas> that's one of the two big problems I have with python
08:10:14 <dblazakis> calling that layout seems generous... it's really simple
08:10:18 <b_jonas> (the other is lack of simple lambda notation)
08:10:19 <b_jonas> anyway,
08:10:21 <lilac> http://hpaste.org/10868
08:10:22 <PHO_> There is just one tutorial in Japanese, titled "Easy Haskell", but it is SURPRISINGLY DIFFICULT
08:10:35 <mauke> ah, a Gentle Introduction
08:10:35 <b_jonas> I have some questions about haskell
08:10:41 <dolio> Is that the evil bird book?
08:10:54 <BONUS> haha
08:10:58 <BONUS> gentle introduction to haskell
08:11:00 <BONUS> i love that
08:11:12 <PHO_> http://www.sampou.org/haskell/tutorial-j/ This one!
08:11:19 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
08:11:29 <lilac> http://hpaste.org/10868 <-- how much do i need to move the last two lines to the right to get this to compile? and how is this obvious?
08:11:42 <Botje> just past the case
08:11:44 <Deewiant> lilac: they need to be indented further than the 'c' in 'case'
08:11:46 <mauke> @quote gentle
08:11:46 <lambdabot> lament says: gentle like gangrape
08:11:52 <lilac> Deewiant: wrong
08:11:58 <int-e> lilac: that's fine. what you're missing is that 'let' needs an 'in'
08:11:58 <lilac> Deewiant: (according to ghc)
08:12:14 <Deewiant> meh, it was just a guess :-P
08:12:20 <int-e> lilac: unless in a do block but you don't have one.
08:12:22 <b_jonas> about the ffi, a (Ptr a) can be passed to a function, returned, or Storabled, right?
08:12:23 <lilac> Deewiant: that's exactly my point
08:12:25 <Deewiant> int-e's problem is pointful as well
08:12:38 <lilac> Deewiant: if the rules aren't obvious, that's language fail imo
08:12:38 <Deewiant> lilac: i.e. seeing the error would be nice.
08:12:48 <b_jonas> do I take it right that it always represents a void * in that case?
08:12:55 <mauke> lilac: no, a language shouldn't be optimized for beginners
08:12:55 <lilac> Deewiant: "parse error (possibly incorrect indentation)"
08:13:08 <Deewiant> lilac: the rules are obvious to me in that either it doesn't matter, or there's an obvious solution
08:13:23 <int-e> lilac: add another line saying "in x"
08:13:24 <Deewiant> so start with the 'let' problem
08:13:25 <b_jonas> if so, is there a way to pass/return/serialize a pointer to a structure?
08:13:48 <lilac> Deewiant: and yet (no offense intended), you (with, i think, quite a lot of haskell experience) can't look at the code and say 'this is right' or 'this is wrong'
08:13:57 <b_jonas> obviously you could write a wrapper in c that casts from/to a void pointer, but it would still be useful
08:14:17 <lilac> with python it's /always/ obvious (except if you mix tabs and spaces). that's really all i'm saying
08:14:18 <dmwit> b_jonas: The typical trick is to make a newtype Struct = Ptr Struct.
08:14:24 <Deewiant> lilac: for the 'let' problem, I simply didn't notice the lack of a 'do' (or 'in')
08:14:27 <mauke> b_jonas: just assume all data pointers are equal
08:14:40 <Deewiant> lilac: as for indentation, I've just always indented the same way so I've never really had to care about the rules
08:14:42 <dmwit> b_jonas: (Since on the Haskell side you're never going to dereference it, hopefully, this works just fine.)
08:14:53 <Deewiant> lilac: except for my first program, pretty much
08:15:17 <lilac> Deewiant: never have i seen written down a set of indentation rules which (a) work and (b) aren't ugly. though i have asked here before...
08:15:21 <int-e> Deewiant: even with do, you need something after the let. ("the last statement of a do block must be an expression")
08:15:45 <b_jonas> mauke: but why would ffi assume that?
08:15:46 <Deewiant> int-e: true that
08:15:53 <mauke> lilac: the rule is: the first token after a layout triggering keyword determines the base indentation of the following block
08:16:00 <Deewiant> int-e: but, I hope, there'd be a different error in that case :-P
08:16:05 <b_jonas> dmwit: yeah, I meant an opaque strucure I won't ever dereference from haskell,
08:16:13 <dmwit> mauke: Because it's been true in every architecture ever made yet.
08:16:17 <Deewiant> lilac: I've never really cared about the indentation rules as I've never really had any trouble with them.
08:16:23 <b_jonas> dmwit: still, the pointer to a structure can be represented differently in C than a pointer to void/char
08:16:24 <dmwit> err, s/mauke/b_jonas/
08:16:27 <int-e> lilac: python is really not much different from C without {}. Haskell is more complex, I'll grant you that. But it's also more complex than C if you use explicit { and }.
08:16:27 <lilac> mauke: that's the haskell rule, but not what i'm asking for
08:16:33 <b_jonas> and I can't see why ffi would wnat to assume they're the same
08:16:43 <dmwit> b_jonas: Don't worry about it until it's a problem, I say. ;-)
08:16:53 <mauke> dmwit: not really true
08:17:00 <mauke> there are exceptions
08:17:05 <b_jonas> dmwit: I'm a mathematician, not an informatician, so no
08:17:47 <lilac> mauke: in C++, I go one indent stop to the right for every {, and i line up to the innermost open braket for a continued line (or one indent in if there's no bracket).
08:18:16 <lilac> mauke: i want an indentation rule for haskell which i can apply consistently, and will work
08:18:20 <ski> http://www.amazon.co.jp/%E5%85%A5%E9%96%80Haskell%E2%80%95%E3%81%AF%E3%81%98%E3%82%81%E3%81%A6%E5%AD%A6%E3%81%B6%E9%96%A2%E6%95%B0%E5%9E%8B%E8%A8%80%E8%AA%9E-%E5%90%91%E4%BA%95-%E6%B7%B3/dp/4839919623/ref=sr_1_2/375-0266840-9077220?ie=UTF8&s=books&qid=1223047009&sr=8-2
08:18:24 <ski> dolio , PHO_
08:18:27 <lambdabot> http://tinyurl.com/3rvx4o
08:18:33 <mauke> lilac: I start a new line and increase indentation for every block
08:18:41 <Deewiant> lilac: in any case, we have the fortune of having decent compilers: GHC gives an error on line 9 in your code so the problem is obviously not in the case
08:18:43 <lilac> increase indentation by how much?
08:18:47 <mauke> lilac: 4 spaces
08:18:49 <dmwit> lilac: 4 spaces
08:18:50 <dolio> Yes, the evil bird book.
08:19:15 <lilac> and what counts as a block?
08:19:24 <mauke> lilac: oh, I also do it for multiline function definitions
08:19:29 <dmwit> lilac: let, do, case, and where
08:19:33 <mauke> lilac: things in { }
08:19:44 <mauke> s/case/of/
08:19:47 <dolio> In the series with evil stork Common Lisp, and evil finch OCaml.
08:19:48 <Deewiant> in that case, though, having to indent stuff beyond the 'x' in the 'let' was surprising to me
08:19:50 <dmwit> Well, yeah.
08:19:52 <lilac> so you'd not line up the body of the case with the first token after the word 'case' ?
08:19:57 <Deewiant> I thought it'd be either beyond the 'c' or the '='
08:20:03 <dmwit> lilac: nope
08:20:09 <mauke> lilac: huh?
08:20:10 <lilac> ok, that's interesting.
08:20:43 <lilac> hoever, it fails for my pasted code, doesn't it? the body of the case lines up against the 'x'
08:20:54 <lilac> unless you indent twice there?
08:21:10 <Deewiant> lilac: the problem in your pasted code is that the 'let' has no matching 'in'.
08:21:16 <int-e> lilac: the x is already indented one level because it's inside a let.
08:21:21 <lilac> Deewiant: i know. so fix that. add an 'in x'
08:21:27 <Deewiant> lilac: and then it compiles.
08:21:38 <lilac> Deewiant: that's not the point any more.
08:21:47 <denq> hi all. sory, can't find lamdabot commands or help. can you give advice?
08:21:48 <int-e> lilac: so the Nothing will have to be indented two levels ... if you want fixed levels.
08:21:54 <mauke> lilac: http://hpaste.org/10868#a1 (consistent but ugly)
08:22:11 <dmwit> lilac: If you follow the rules, the x would be on the next line and indented four spaces.
08:22:15 <int-e> or three. your choice, again.
08:22:27 <dmwit> lilac: Then the body of the case would be indented *another* four spaces.
08:22:39 <dmwit> Oh, I see mauke already pasted that.
08:22:55 <dmwit> No sense putting a newline after the '=', though.
08:23:07 <lilac> mauke: ok, but 'not ugly' was one of my criteria.
08:23:08 <PHO_> hehe, no reviewers at amazon.co.jp are praising that book ski
08:23:17 <Deewiant> dmwit: a newline after = is exactly what I would do :-)
08:23:18 <ski> (dolio : is this <http://www.amazon.co.jp/gp/product/images/4797336021/sr=8-1/qid=1223047009/ref=dp_image_0?ie=UTF8&n=465392&s=books&qid=1223047009&sr=8-1> evil too ?)
08:23:18 <lambdabot> http://www.amazon.co.jp/gp/product/images/4797336021/sr=8-1/qid=1223047009/ref=dp_image_0?ie=UTF8&n=465392&s=books&qid=1223047009&sr=8-1>
08:23:43 <mauke> lilac: don't write code like that, then :-)
08:23:46 <lilac> mauke: also, you've indented the x= where there's no block
08:23:58 <mauke> lilac: yeah, because the definition has multiple lines
08:24:00 <lilac> ok, so what i would like to know is, how should i write code?
08:24:01 <dolio> ski: I don't know. That seal doesn't look that evil.
08:24:05 <PHO_> ski: no, that one isn't so bad
08:24:34 <lilac> put another way, i'd like a function which i can install in my brain which takes a haskell AST and produces nicely formatted, correct code
08:24:34 <ski> PHO_ : you're misunderstanding .. "evil" here was meant as a praise
08:24:40 <dmwit> lilac: Your example was just too simple.
08:24:41 <PHO_> oops
08:24:41 <mauke> lilac: like my example shows, but avoid case-in-let where possible
08:24:47 <dmwit> lilac: You'd never write such a short let.
08:24:48 <int-e> lilac: let has a block. it's let { ... } in ...
08:24:55 <dmwit> lilac: See http://hpaste.org/10868#a3
08:25:03 <mauke> lilac: it's not so bad if you use something longer than 'x'
08:25:12 <lilac> int-e: yes, but it's not let { x = { ... } } in
08:25:17 <dolio> PHO_: It's evil because the illustration on the cover has (hilarious) evil looking animals.
08:25:26 <PHO_> hehe
08:25:31 <ski> yes ? (*blank*face*)
08:26:28 <b_jonas> one thing I could do is to define a type that's a synonym to say Ptr () but document that I assume it serializes to a struct pointer, then if it doesn't work on a machine you can at least find all occurrences of it
08:26:29 <lilac> dmwit: re 'too simple', i take your point.
08:26:46 <int-e> lilac: in "-- 'Indent 4 spaces' rule, interpretation 2 (ugly?)" - you indent one level for the 'let' and one for the 'case'. I agree that mauke indented one level for a block that wasn't there.
08:27:19 <Deewiant> what you do is you indent one level for the 'let' and one for the 'x'
08:27:26 <mauke> so apparently I indent blocks and multiline definitions
08:27:27 <lilac> int-e: ok, so interpretation 2 was the right one. fair enough.
08:27:28 <dolio> Oops, I forgot guards.
08:27:43 <lilac> int-e: it still worries me that if i use the same rule but choose to indent by 2 instead of 4, i get a compile failure!
08:27:54 <int-e> lilac: not really
08:27:54 <dmwit> lilac: Also, my other rule is "use where, not let". =)
08:28:02 <Deewiant> lilac: see above. indent once for 'let' and once for the variable you define.
08:28:03 <int-e> lilac: because then your 'x' is indented too far.
08:28:17 <Deewiant> if you put the variable on the same line as the 'let' then indent once for it only.
08:28:54 <lilac> int-e: let x = case ... is indented 2, Nothing -> ... is indented 6. compile = fail.
08:29:13 <mauke> lilac: http://hpaste.org/10868#a5
08:29:17 <lilac> or should i be putting a newline after each block keyword?
08:29:30 <dmwit> lilac: Exactly.
08:29:54 <mauke> "my" style is also tab compatible
08:29:56 <Deewiant> (variable definitions count as 'block keywords')
08:30:06 <int-e> lilac: http://hpaste.org/10868#a7
08:31:56 <int-e> you really have a large degree of freedom for finding a indentation style that suits you.
08:34:38 <dolio> The problem is getting tools to do certain layouts automatically. :)
08:35:14 <dolio> Haskell mode and I disagree on some things.
08:35:33 <lilac> dolio: http://hpaste.org/10868#a9 (indented as per mauke, I think)
08:35:53 <PHO_> yeah, haskell-mode.el isn't flexible enough
08:36:17 <PHO_> so I end up with fixing indentation manually
08:36:23 <skorpan> yi's layout awareness is pretty awesome, you should try it
08:36:29 <vixey> is this some kind of haskell cubism?
08:36:31 <ozy`> do you guys -all- tend to indent by hand?
08:36:33 <PHO_> heh
08:37:15 <dmwit> ozy`: Purty much, though autoindent gets a lot of the way there for me.
08:37:32 <ozy`> dmwit: autoindent in emacs, or yi, or what?
08:37:35 <dolio> No, I just ignore the small differences that I can't adjust in haskell mode, or fix them up if I'm feeling like it.
08:37:44 <dolio> In Emacs.
08:37:56 <dolio> The vi mode used to actually let me do things my way pretty well.
08:37:56 <dmwit> ozy`: vim
08:38:08 <vixey> I just put everything on one line - that way layout doesn't pose a problem
08:38:09 <dolio> Although it's not as magic as the emacs mode.
08:39:26 <mauke> lilac: I'd indent it something like http://hpaste.org/10868#a10
08:39:33 <mauke> except I'd use 'where' instead of 'let' there
08:40:21 <dolio> Well, I would, too, but that doesn't showcase how you'd indent a let in the minority of cases you might use it.
08:42:02 <vixey> that's how I would set it out http://hpaste.org/10868#a11
08:42:56 <Philippa_> dolio: my style's a lot like yours, but I put the bindings horizontally after the where normally
08:43:13 <PHO_> http://hpaste.org/10869#a0
08:43:16 <dolio> Yeah, I might actually start the guards on the same line as f, and the quuxes on the same line as where, depending on my mood and how much horizontal space they take up.
08:43:18 <Philippa_> and often the same for guards
08:43:34 <Philippa_> right, examples for "enough room" vs "not enough room" can matter
08:43:36 <skorpan> PHO_: that is a known problem with haskell-mode.el
08:43:41 * vixey does not use if
08:43:44 <PHO_> heh
08:43:55 <skorpan> have you seen the code for the indentation cycling? it's massive
08:43:56 * int-e tends to use half indents (2 spaces) for 'in', 'where', 'then' and 'else'.
08:44:06 <PHO_> skorpan: not yet
08:44:14 * mauke is still stuck in C think
08:44:24 <Philippa_> I generally use two spaces or in line with the end of the relevant token + a space
08:44:38 <skorpan> haskell-indent.el is 1569 lines long
08:44:45 <PHO_> wa!?
08:45:07 <Philippa_> (oh, or two under the /start/ of the relevant token:
08:45:11 <Philippa_>     case foo of
08:45:15 <Philippa_>       Bar -> baz
08:45:20 * ski mostly indents by two spaces unless i want to line up things (which is often)
08:45:23 <Philippa_> )
08:45:35 <skorpan> how is vi's haskell "mode"?
08:45:38 <ski> (s/i/he/ *sigh*)
08:45:40 <Philippa_> yeah. I expect code to get heavily indented one way or another
08:45:50 <mauke> I just :set ai
08:45:51 <Philippa_> ski: I think that's recognised IRC grammar :-)
08:46:00 <BONUS> yeah, just :set ai and its fine
08:46:29 * [R]ayne Uses emacs haskell mode.
08:47:17 <ski> Philippa_ : well, i try to avoid causing a reason for anyone to call the /me police
08:47:48 <mauke> * skhe mostly indents ...
08:48:39 <ski>   case foo of
08:48:44 <ski>     Bar -> do
08:48:49 <ski>       baz
08:48:51 <ski>       quux
08:49:54 <ski>   foo [    ] = ...
08:49:59 <ski>   foo (x:xs) = ..x..xs..
08:50:16 <mauke> heh, nice
08:50:39 * lilac has looked over all the code he's ever written, and would write it as http://hpaste.org/10868#a12
08:50:48 <lilac> although i don't use if and i almost never use let
08:50:49 <int-e> ski: that breaks my builtin parser.
08:51:03 <ski> how so ?
08:51:17 <int-e> I actually have to think about what [    ] means. [] is automatic.
08:51:20 <ski> it doesn't like whitespace inside the empty list ?
08:51:32 <lilac> int-e: i'm with you on that; i parse [] as a token
08:51:33 <mauke> break perl people's parsers, put spaces after $, @ and % :-)
08:52:07 * ski parses `[]' as a special degenerate case of `[a,b,...,y,z]'
08:52:36 <Elly> your list rule ought to be [ exp* ]
08:52:47 <Elly> in which case [] is a perfectly acceptable list with exp* matching zero entries
08:52:52 <int-e> > let x@y = 23 in succ $ y % x
08:52:53 <lambdabot>   2%1
08:53:04 <ski> well, you need commas (and allow the `..' cases ..)
08:53:48 <ski> int-e : nice :)
08:54:01 <vixey> do you know any fixed width font that displays `and ' conjugates
08:54:21 <vixey> rather than it looks like \ |
08:54:32 <daf> do you mean ‘ and ’ ?
08:54:36 <lilac> on '[': look for '|', if found -> list comprehension; look for '..', if found -> enumFromTo; look for ',', if found -> list; look for ']', if found -> nil, else -> error
08:54:39 <ski> > let (cos -> x)@(sin -> y) = pi/3 in (x :+ y)
08:54:39 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 17}
08:54:39 <lambdabot> ...
08:54:41 <vixey> no I do not
08:54:48 * lilac doesn't parse [foo bar] correctly either
08:55:11 <int-e> > [42 | True]
08:55:12 <lambdabot>   [42]
08:55:17 <int-e> lilac: how about that? :)
08:55:37 <lilac> int-e: yep, that i can parse ;D
08:55:44 <Philippa_> > [42 | False]
08:55:46 <lambdabot>   []
08:55:52 <vixey> > [undefined| pi < e ]
08:55:53 <lambdabot>   []
08:56:14 <vixey> it is scarily close to oxford brackets
08:56:16 <ski> guard b = [() | b]  -- list monad
08:56:32 <ski> vixey : being ?
08:56:38 <int-e> > [p| p <- [1..10], odd p]
08:56:38 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 14}
08:56:38 <lambdabot> ...
08:56:40 <lilac> [| this |] ?
08:56:47 <int-e> > [p | p <- [1..10], odd p]
08:56:48 <lambdabot>   [1,3,5,7,9]
08:57:21 * int-e really wishes the TH people would've used [P| ] and [D| ] instead of the lower case variants.
08:57:23 <vixey> the TH stuff
08:57:36 <ski> ic
08:58:00 <int-e> (yes, it can still clash, but replicating unary constructors usually isn't that useful)
08:58:13 <lilac> let x = [| 42 |]; let y = [$x| True]
08:58:26 <ski> (usually i use `[... | ...]' .. sometimes `[ ... | ... ]')
08:58:32 <hackage> Uploaded to hackage: yi 0.5.0.1
08:58:45 <vixey> I don't really ever use list comprehensions
08:59:24 <lilac> vixey: do you use 'do' notation instead, or do you just never find the need?
08:59:52 <ski> vixey : `do'-blocks or `filter',`map',`concat',(`concatMap') ?
09:00:13 <vixey> ski, all of them
09:00:16 <mauke> argh
09:00:23 <Twey> Heh
09:00:25 <Twey> Argh, indeed
09:00:36 <mauke> I believe they're called ``faggot quotes''
09:00:43 <Twey> concatMap = (concat .) . map?
09:00:49 <ski> @src concatMap
09:00:49 <lambdabot> concatMap f = foldr ((++) . f) []
09:00:52 <mauke> Twey: yes
09:00:54 <vixey> concatMap f = concat . map f
09:01:40 <vixey> I think that I don't write a lot of programs that use lists
09:01:51 <vixey> mostly I use stacks or contexts or ...
09:01:52 <Twey> Why isn't concatMap = (concat .) . map?  Is there some advantage to that?
09:02:02 <vixey> but never really 'lists' like the sort of things that would be comprehended
09:02:16 <vixey> Twey: that's sort of horrible to read
09:02:32 <vixey> sectioning (.) is very weird
09:02:48 <Twey> Nay, vixey
09:02:50 <Twey> 'tis common enough
09:02:54 <mauke> every #haskell programmer should know (.).(.)
09:02:54 <ski> concatMap = concat .: map
09:03:15 <Twey> Aye!
09:03:20 <b_jonas> uh
09:03:23 <vixey> yeah it would be good if it was a great deal less common
09:03:24 <b_jonas> what's .:
09:03:32 <ski> (.:) = (.) . (.)
09:03:34 <vixey> (.:) = (.).(.)
09:03:37 <ski> (.::) = (.) . (.) . (.)
09:03:40 <b_jonas> hmm
09:03:42 <ski> etc.
09:03:44 <Twey> vixey: It's perfectly logical, and not at all difficult
09:03:46 <wjt> it'd be fun to use (∴) for (.:)
09:03:54 <vixey> it is difficult
09:03:57 <ski> (iirc, i came up with these particular operator names)
09:03:57 <b_jonas> @unpl .:
09:03:58 <lambdabot> (.:)
09:04:01 <Twey> What's that?  'Therefore'?
09:04:08 <b_jonas> @unpl (.) . (.)
09:04:09 <lambdabot> (\ i b c f -> i (b c f))
09:04:16 <wjt> Twey: yeah
09:04:25 <b_jonas> I see
09:04:27 * Twey has to peer at it
09:04:34 <b_jonas> so that's compose diadics
09:04:39 <Twey> My font doesn't like it, one of the dots overlaps with the bracket :(
09:04:45 <Twey> vixey: What's wrong with sectioning (.)?
09:04:45 <ski> Twey : no, it's meant to symbolize the dots in the definiens
09:05:06 <Twey> ski: Aye, but the character was 'therefore'
09:05:13 <Twey> That's what I was talking about
09:05:14 * PHO_ wants to say "λ i b c f → i (b c f)" if possible
09:05:19 <vixey> Twey: nothing is wrong with it, I just said it's weird, it either takes time to figure it out or you have memorized what it does
09:05:33 <Twey> PHO_: I was talking about that earlier
09:05:49 * [R]ayne Has fruitloops.
09:05:57 <Twey> vixey: Doesn't take that long to figure out
09:06:03 <Twey> vixey: Folds are 'weirder'
09:06:13 <vixey> no they are fundamental
09:06:23 <vixey> sectioning a (.) is definitely a trick
09:06:34 <lilac> > let (.'.) = (=>) in a :: Monad m .'. m (); a = return ()
09:06:34 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 15}
09:06:34 <lambdabot> ...
09:06:41 <ski> vixey : aye
09:06:58 * lilac plays count the reasons that's illegal
09:07:54 <PHO_> vixey: I agree with you. I can figure it out by spending a few seconds but I myself doesn't write code that way
09:08:00 <Twey> vixey: I disagree strongly
09:08:09 * [R]ayne Gives lilac a cookie. :)
09:08:13 <ski> lilac : 3 ?
09:08:14 <Twey> (.) is no more a trick than folds, and easier to figure out
09:08:24 * osfameron disagrees
09:08:35 <osfameron> folds have good easy examples like "sum" and "product"
09:08:39 <ski> folds are deep
09:08:41 <vixey> Twey: Have you seen the link between recursive functions over data and induction?
09:08:46 <osfameron> (.) is deeply higher order
09:08:57 <PHO_> folds aren't difficult at all
09:09:53 <Twey> osfameron: Higher-order?  In *my* Haskell?
09:10:15 <osfameron> hehe, didn't say there was anything wrong with higher order
09:10:30 <osfameron> but to pretend it isn't also higher confusing is disingenuous
09:10:56 <vixey> (.) (in mathematics) needn't be higher order
09:10:56 <ski> evening Erkk
09:11:15 <BONUS> vixey: how so
09:11:30 <ski> vixey : however, `(.:)' ..
09:12:31 <ski> BONUS : in category theory, composition combines two first-order values (morphisms) into one ditto
09:13:02 <BONUS> aah, category theory
09:13:08 <BONUS> gotta get me some category theory one of these days
09:13:27 <vixey> oh I was thinking set theory.. but I couldn't write out what I was thinking in a way that would make sense to anyone
09:13:29 <Twey> osfameron: Of course it's higher-order
09:13:34 <Twey> osfameron: But then, so are folds
09:13:50 * ski idly wonders whether there's any book called "Category: Theory" ..
09:13:56 <Twey> Hahaha
09:14:05 <Twey> There's probably a Wikipedia category.
09:14:34 <Twey> And if there isn't, we need to make one.
09:14:35 <osfameron> Twey: folds higher order apply a function to a set of real values and return a real value.  While composition takes 2 functions and returns another function.  The fold still feels somehow more concrete ;-)
09:14:49 <vixey> Twey, I can outline the idea if what I said didn't make sense
09:15:13 <dolio> Composition takes two functions and applies them in order to a real value and returns a real value. :)
09:15:20 * Twey nods.
09:15:22 <vixey> osfameron: since functions are values ...
09:15:25 <BONUS> you could say that composition takes two functions and whatever the second function's taking
09:15:29 <BONUS> ugh, beaten
09:15:33 <Twey> Hehe
09:15:36 <vixey> > ((+1) . (*2) . const 3) ()
09:15:37 <lambdabot>   7
09:15:58 <dolio> @src (.)
09:15:58 <lambdabot> (f . g) x = f (g x)
09:16:05 <PHO_> Twey: Almost. http://en.wikipedia.org/wiki/Category:Theories
09:16:07 <lambdabot> Title: Category:Theories - Wikipedia, the free encyclopedia
09:16:11 <ski> folds (and unfolds) are second-order
09:16:43 <vixey> unfolds are a bit tricky.. it's still not clear to me what the relation between folds and unfolds are
09:17:09 * PHO_ still doesn't know how to use unfolds
09:17:14 <ski> (by `unfolds' i mean `anamorphisms')
09:17:17 <vixey> I think you can in general invert folds (given some conditions) or 'relational catamorphisms'
09:17:18 <dolio> They're categorical duals.
09:17:32 <Twey> PHO_: Good enough :)
09:17:46 <vixey> I have no idea how to do it in practice though
09:17:48 <b_jonas> bananamorphisms
09:18:03 <Eridius> b_jonas: sounds deliciously mathematical
09:18:07 <Eridius> or mathematically delicious?
09:18:12 <dolio> At least, I think that's probably right.
09:18:35 <vixey> if a fold has something to do with 'initial algebra' (I probably read this somewhere..)
09:18:45 <PHO_> We'll have to define "delicious" in mathematical way.
09:18:48 <dolio> A fold for an initial algebra in a category would be an unfold for a coalgebra in the co-category.
09:18:50 <b_jonas> Eridius: sounds like that lambdacats image: http://arcanux.org/lambdacats/catamorphism.png
09:18:53 <vixey> unfolds have presumably something to do with terminal algebra? Actually I think this is a bad guess
09:19:03 <dolio> Terminal coalgebra, that is.
09:19:08 <Eridius> b_jonas: haha, awesome. Never seen that one
09:19:15 <ski> > unfoldr (\s -> if s == 1 then Nothing else Just (s,collatz s)) 7  where collatz n | even n = n `div` 2 | otherwise = 3*n + 1
09:19:16 <lambdabot>   [7,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2]
09:19:24 <b_jonas> Eridius: look at all the lambdacats then
09:19:28 <b_jonas> Eridius: there aren't too many
09:19:34 <b_jonas> Eridius: my fav is the KittehT
09:19:35 <Eridius> will do
09:20:15 <Eridius> bahahaha http://arcanux.org/lambdacats/undecidable.jpg
09:20:35 <ski> PHO_ : that above is a simple example ..
09:20:46 <dolio> Hey, that new one isn't imperative cat.
09:21:01 <vixey> oh I have an example of a fold/unfold I like
09:21:35 <Axman6> Eridius: lol
09:21:54 <hugo__> parsec seems preaty cool
09:21:55 <hugo__> :)
09:22:15 <hugo__> it sums up the pain of lex/yacc in a nice soft way
09:22:18 <Axman6> i should have a look at parsec
09:22:28 <Eridius> ok, here's KittehT: http://arcanux.org/lambdacats/transformer.jpg
09:22:36 <vixey> > foldr (\x y -> 10*y + x) 0 [3,5,8,4,6,1]
09:22:37 <lambdabot>   164853
09:22:40 <vixey> > unfoldr (\n -> case divMod n 10 of (0,0) -> Nothing ; (x,y) -> Just (y,x)) 164853
09:22:42 <lambdabot>   [3,5,8,4,6,1]
09:22:43 <mauke> parsec is a pretty gool guy. eh descends recursievly and doesn't afraid of anything
09:22:43 <Eridius> and with that, back to WoW
09:22:44 <hugo__> im using it to parse simple yaml file... or trying to
09:23:10 <vixey> not sure why this works though..
09:23:16 <vixey> I mean other than it obviously does
09:23:46 <Axman6> heh
09:23:55 <vixey> there are probably some general rules about it which someone wrote down somewhere, that I haven't though up
09:24:04 <vixey> thought*
09:24:37 * vixey specifically wants to see them to invert pretty printers written as folds..
09:29:50 <dolio> Your functions are isomorphisms between [Digit] and Integer.
09:30:14 <mauke> > repeat 0
09:30:15 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
09:30:34 <dolio> Ah, yeah.
09:30:36 <dolio> Oh well.
09:30:51 <dolio> [Digit] - nasty lists.
09:31:51 <ski> > unfoldr (\(a,b) -> if a == 0 then Nothing else Just (a,(b,a `mod` b))) (318049,279457)
09:31:52 <lambdabot>   [318049,279457,38592,9313,1340,1273,67]
09:33:24 <dolio> That [Digit] -> Integer can be written as a fold is guaranteed by the initiality of lists, and that Integer -> [Digit] is an unfold is the finality of lists (since they're both in Haskell).
09:33:40 <dolio> Or something of that sort.
09:33:48 <ski> (i suppose this actually is a simple `map f . iterate g $ x' .. roughly mealy vs. moore ..)
09:34:18 <b_jonas> > concatMap (repeat 5) "hello"
09:34:20 <lambdabot>   Couldn't match expected type `a -> [b]' against inferred type `[t]'
09:34:21 * dolio goes to lunch.
09:34:26 <b_jonas> > concatMap (replicate 5) "hello"
09:34:28 <lambdabot>   "hhhhheeeeellllllllllooooo"
09:34:38 <ski> > foldr (\x y -> 10*y + x) 0 (repeat 1)
09:34:40 <lambdabot>   * Exception: stack overflow
09:34:54 <mauke> > "hello" >> "hello"
09:34:54 <vixey> yes yuo have Nothing <=> 0,  and Just (y,x) <=> x+y*10
09:34:55 <lambdabot>   "hellohellohellohellohello"
09:35:06 <vixey> but making that _general_ and _formal_ is difficult
09:35:16 <mauke> > "hello" <* "hello"
09:35:17 <lambdabot>   "hhhhheeeeellllllllllooooo"
09:35:25 <vixey> (oh and correct is nice too)
09:35:33 <b_jonas> @info <*
09:35:34 <lambdabot> (<*)
09:35:40 <b_jonas> useful, eh?
09:35:43 <vixey> @info *>
09:35:44 <lambdabot> (*>)
09:35:46 <b_jonas> @type <*
09:35:48 <lambdabot> parse error on input `<*'
09:35:49 <b_jonas> @src <*
09:35:50 <lambdabot> (<*) = liftA2 const
09:35:56 <b_jonas> @type (<*)
09:35:57 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
09:36:02 <vixey> @@ @type @info <*
09:36:02 <lambdabot> Plugin `compose' failed with: Unknown command: "info"
09:36:11 <vixey> @@ @type @undo <*
09:36:12 <lambdabot>  forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
09:38:28 <Beelsebob> is there a ready to use undirected graph module hanging about anywhere?
09:40:54 <PHO_> Beelsebob: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/fgl
09:40:55 <lambdabot> Title: HackageDB: fgl-5.4.1.1
09:41:12 <ozy`> hmm, how would I automatically generate the derivatives of mathematical functions?
09:41:12 <Beelsebob> PHO_: yeh, as far as I cn tell that's all directed
09:41:17 <Beelsebob> unless I'm missing something?
09:41:34 <mauke> @index unsafePerformIO
09:41:34 <lambdabot> System.IO.Unsafe, Foreign
09:41:50 <vixey> ozy: nice question
09:42:14 <vixey> ozy: since derivatives compose really easily there's a couple solutions to it .. let me find this poste
09:43:03 <vixey> ozy, http://conway.rutgers.edu/~ccshan/wiki/blog/posts/Differentiation/
09:43:05 <lambdabot> Title: Differentiating regions, http://tinyurl.com/66oa6z
09:43:28 <ozy`> vixey: a quick disclaimer... I probably won't fully understand the solution, as I didn't even know Haskell had that degree of reflection. still on chapter 9 of RWH...
09:43:30 <ozy`> but thanks
09:43:43 <vixey> You will understand it
09:44:15 <sw17ch> has any one done packet parsing on a live stream of data?
09:44:24 <sw17ch> raw concatenated ethernet frames?
09:44:37 <sw17ch> *with haskell*
09:44:38 <sw17ch> :)
09:44:52 <Beelsebob> sw17ch: House did that
09:45:00 <sw17ch> House?
09:45:06 <ozy`> ah, the Haskell OS
09:45:07 <Beelsebob> the Haskell operating system
09:45:48 <mauke> Doctor House /= House Doctor
09:47:03 <sw17ch> ohhhh
09:47:08 <sw17ch> :P
09:47:21 * sw17ch has a very basic Haskell VPN working
09:47:23 <sw17ch> :D
09:47:28 <sw17ch> needs to parse packet data to do smart swithing
09:47:31 <sw17ch> switching*
09:47:50 <Beelsebob> sw17ch: sounds funky
09:48:57 <sw17ch> it uses tun/tap
09:49:12 <ozy`> vixey: this is an awesome find
09:49:27 <sw17ch> and i had to do some heavy lifting in C... but now that i've got that finished, it's reading the ARP packets broadcasting aroudn my local network )
09:49:28 <sw17ch> :)
09:52:36 <newsham> sw17ch: why do you need to do any switching at all?  the OS should be doing all the routing
09:52:43 <newsham> you should just be copying data back and forth
09:53:19 <sw17ch> newsham: multi-client network
09:53:41 <Axman6> sounds like a job for erlang to me, but whatevs :)
09:53:46 <newsham> your tun interface is just like any other net interface, add routing rules to the system routing table
09:53:57 <sw17ch> newsham: i'm talking about after i've read the packet from the OS
09:54:08 <sw17ch> if i have 5 people on the VPN, i don't want to broadcast the packet data to every one
09:54:09 <newsham> use one interface per client
09:54:12 <sw17ch> i want to just end it to the one that needs it
09:54:32 <sw17ch> newsham: i guess i'm confused...
09:54:36 <Axman6> sw17ch: isn't what what switching does? :\
09:54:39 <sw17ch> tun/tap doesn't actually send the packets over the network
09:54:55 <sw17ch> it's a layer directly to the OS's network stack
09:55:00 <newsham> when you write to tun, you deliver a packet that gets routed by the OS
09:55:10 <newsham> and the OS routes packets up to tun that you can read
09:55:28 <tongucyumruk> Hi all, I'm writing a parser & interpreter for for the Sİeve language (see: rfc 3028). I'm stuck at a point. Is this the right place to ask Parsec related stuff?
09:55:29 <sw17ch> newsham: yes, but when i write a packet to the device, it doesn't go out over a network connection
09:55:37 <sw17ch> it goes to the os, if the os doesn't want it, it throws the data away
09:55:41 <newsham> right
09:55:59 <tongucyumruk> BTW: The code is here: http://vc.tonguc.name/darcsweb/
09:56:05 <newsham> ok.. think of it like you a SLIP connection, and you have write access to the reomte end of the serial line
09:56:10 <lambdabot> Title: darcs - Repositories
09:56:17 <rwbarton> tongucyumruk: Sure
09:56:25 <sw17ch> so, i'm talking abotu the part where the OS writes a packet to the tun/tap device which is destined for someone on the tun/tap network
09:56:33 <Axman6> speaking of parsec, anyone know a good tutorial?
09:56:40 <sw17ch> it's up to my application to send that data
09:56:53 <ozy`> Axman6: there's that Scheme in 48 hours thing...
09:56:56 <newsham> now if you had 5 clients you wanted to connect to your computer over SLIP either you'd have 5 SLIP lines into your computer, or you'd hvae a remote router that aggregates those 5 computers onto the single SLIP line
09:57:04 <tongucyumruk> Currently, my code cannot cope with whitespace on the end
09:57:06 <Axman6> ozy`: got a link?
09:57:27 <ozy`> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
09:57:27 <sw17ch> newsham: but in this case, the application is responsible for managing those SLIP lines
09:57:29 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
09:57:29 <sw17ch> not the OS
09:57:31 <newsham> sw17ch: if you just make 5 different tun devices, and set their addresses appropriately, and set up routing table appropriately, each one will only receive packets destined to that one client
09:57:36 <rwbarton> tongucyumruk: ah yes, that often happens
09:57:39 <tongucyumruk> I mean, a sieve expression might be like that: require ["reject", "fileinto"];
09:57:47 <tongucyumruk> tihs is parsed very well
09:57:50 <tongucyumruk> but
09:57:58 <newsham> adding routing to your vpn program is only making you duplicate routing code thats alread in the kernel
09:58:04 <Axman6> newsham: i think the problem is that his app needs to decide where the things need to be sent
09:58:07 <tongucyumruk> require ["reject", "fileinto"] ;
09:58:07 <newsham> and an ad hoc way
09:58:21 <newsham> axman: and I'm saying he shouldnt, he should let the kernel do that
09:58:32 <sw17ch> newsham: the part i'm referring to is the piece that emulates a physical switch
09:58:37 <tongucyumruk> the space between the semicolon and the ] causes the headache
09:58:47 <newsham> sw17ch: and I'm saying you shouldnt do that.
09:58:57 <sw17ch> newsham: then the data gets duplicated to every client on the network
09:58:57 <newsham> i mean, you can do that...  but i wouldnt recommend it
09:59:00 <Axman6> newsham: he's talking about a higher level
09:59:04 <tongucyumruk> BTW, you can "darcs get" it from http://vc.tonguc.name/darcs/HSieve
09:59:29 <newsham> no, he's talking at a lower level (ie. what an ethernet switch does)
09:59:32 <sw17ch> os >>= tun/tap >>= myapp >>= UDP_Connection >>= [client_list]
09:59:34 <rwbarton> tongucyumruk: I think the usual solution is to wrap whatever matches the ; in "lexeme"
09:59:58 <sw17ch> if the packet the os wrote is only destined for (client_list !! 5), i dont want to send it to client_list !! 4
10:00:00 <newsham> sw17ch: do you understand what i'm proposing you do?
10:00:07 <sw17ch> yes, and i think you're not understanding what i'm actually doing
10:00:15 <newsham> i understand what you're doing.
10:00:29 <vixey> sw17ch: Could that possibly be set up via types?
10:00:29 <newsham> you are using a single tun interface, reading packets, and then determining which of a number of clients to send the packet to
10:00:57 <rwbarton> tongucyumruk: that makes it ignore leading whitespace.  Probably your ; token is equivalent to any amount of whitespace followed by ;, so that's good.
10:01:01 <sw17ch> newsham: i'm reading packets destined for some one else on the VPN
10:01:02 <vixey> make client_list a tuple or something, and put some identity in the type
10:01:06 <newsham> i am saying use one tun interface per client, and let the IP stack decide which client ot send it to
10:01:15 <newsham> yup, got that.
10:01:29 <sw17ch> so, my tun/tap device has ip 10.1.1.1, yours has 10.1.1.2
10:01:35 <geezusfreeek> I wish I was using Haskell instead of C# right now. :(
10:01:38 <sw17ch> vixey has one that's 10.1.1.3
10:01:38 * ski ought to make a language named `Steve' ..
10:01:50 <newsham> yup
10:01:51 <vixey> ski, why Steve?
10:01:51 <tongucyumruk> rwbarton: OK, I'll try and let you know, thanks
10:01:55 <b_jonas> ski: why?
10:02:00 * geezusfreeek wonders if he should try F#
10:02:01 <sw17ch> another userspace application wants to open a TCP/IP connection from my machine to 10.1.1.3
10:02:23 <newsham> sw17ch: why are you explaining to me how tun works?
10:02:23 <ski> vixey : i misread "for the S?eve language (see: rfc 3028)" above as "for the Steve language .."
10:02:24 <sw17ch> when the OS writes the SYN packet to the tun/tap, it hits the vpn application reading from /dev/net/tun
10:02:37 <vixey> geezusfreek: I'm going to make a wild guess, there is a more interesting thing you could do with your time
10:02:37 <sw17ch> now, my application has it, and it's responsible to send it out
10:02:55 <sw17ch> so, in order to make sure it gets to the right place, i write it to every one, or just 10.1.1.3's UDP connection
10:03:06 <newsham> and i am saying you should not do it that way
10:03:11 <geezusfreeek> vixey, have you used F#?
10:03:14 <sw17ch> what would you say i shoudl do?
10:03:16 <newsham> i am saying you should assign each of your clients their own tun interface
10:03:18 <ski> (also there's some joke with naming something "Steve" whose details escape my mind atm)
10:03:21 <vixey> ski, oh any progress on the lp stuff you were thinking about?
10:03:25 <ozy`> geezusfreeek: from what I understand, F# is basically ML with the .NET library
10:03:30 <sw17ch> ack, have a meeting...
10:03:36 <geezusfreeek> i know basically nothing about F# besides that
10:03:37 <newsham> and then copy data back and forth between one interface and one remote client, repeated n times for each client
10:03:43 <Asztal> geezusfreeek: you could also try Nemerle
10:03:48 <newsham> and then the routing will be handled by the kernel
10:03:51 <newsham> the way it should be
10:04:00 <ozy`> Nemerle reminds me of Scala
10:04:20 <geezusfreeek> huh, i had never even heard of nemerle
10:04:22 <newsham> (the vpn programs dont even need to have shared state or be in a shared program, they can be n independant programs)
10:04:32 <ski> vixey : well, i've had too much to do and no concentration to code .. i've thought a bit more on some problems, though
10:05:06 <newsham> so one tun interface might be 10.0.0.1/30 with a remote of 10.0.0.2/30
10:05:13 <vixey> ski, *nod* it often goes like that for me
10:05:19 <newsham> the next tun interface might be 10.0.0.5/30 with a remote of 10.0.0.6/30
10:05:21 <ski> vixey : i'm thinking of trying to design a "relational" module language ..
10:05:24 <newsham> each one is p-p
10:05:45 <vixey> ski, oh something which could subsume typeclasses?
10:05:51 <newsham> (they could also serve much bigger subnets, of course, but it sounds like you're saying you have single machines as the remote client?)
10:06:53 <geezusfreeek> i think i won't bother. my main problem right now is .NET itself anyway, which i can't get around
10:07:00 <ski> vixey : the idea being that one need not always fix which names in a module is imports and which is exports .. because i think with some definitions, either name could be the definiendum (and the other the definiens)
10:07:08 <rwbarton> Is anyone here familiar with any kind of noncommutative logic?
10:07:38 <ozy`> geezusfreeek: yeah, I get the feeling that C octothorphe would actually be a bit nice if it wasn't tied to .NET
10:07:58 <vixey> ozy: I sort of doubt it
10:08:13 <ddarius> rwbarton: Ordered linear logic?
10:08:19 <geezusfreeek> nah, it just feels like another java to me
10:08:20 <ozy`> vixey: compared to, for example, java, at least
10:08:31 <rwbarton> ddarius: Possibly, yes.  Something where (A /\ B) is not equivalent to (B /\ A)
10:08:43 <ski> vixey : imagine having a module `foo' importing predicate `P' and exporting `Q', while `bar' imports `Q' and exports `R', so we define a combined/collection module `baz' which imports `P' and exports `R' by something in the vein of `baz(P,R) :- foo(P,Q),bar(Q,R).'
10:09:12 <rwbarton> ddarius: I'm trying to understand if there is a setting where the dissection operator of "Clowns to the Left of Me, Jokers to the Right" is functorial
10:09:21 <ski> (vixey : no idea if type-classes would be related .. on very-quick glance, probably not)
10:09:26 <vixey> ski, oh right
10:09:41 <ddarius> rwbarton: Probably.
10:10:01 <ozy`> of course, I've only written two programs in C octothorpe... in one of them, the syntax helped enormously with certain parts of the control flow... in the other case, I was hamstrung by fairly obvious stuff that didn't seem to be in the standard library, and had to write myself
10:10:06 <ozy`> but that was years ago
10:10:19 <ski> vixey : i think i'd prefer allowing external linking of module names, instead of insisting on the module itself declaring where it imports its names from
10:10:25 <ozy`> (and before I knew any functional langs)
10:11:26 <mauke> :t cast
10:11:26 <lilac> from what i've seen of it, as VM-based, bytecode-compiled, C-like languages go, Db is pretty good.
10:11:27 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
10:11:38 <ski> (vixey : clarification, by "module names" i meant "names used by modules", not "names of modules" ..)
10:11:59 <vixey> ski, it does seem to me that if you have some module which deals with a structure, requiring some properties of that structure.. using this module might require a fair bit of theorem proving
10:12:35 <vixey> (or theorem assuming.. if it's not statically checked)
10:12:40 <ski> vixey : elaborate
10:13:14 <vixey> ski, perhaps a module Q exports some set, and then another module wants to put Q into the Group module, perhaps
10:14:07 <ski> vixey : you're thinking here of math (not necessarily anarchic) algebras (e.g. groups), here ?
10:14:11 <mauke> :t sequenceM_
10:14:12 <lambdabot> Not in scope: `sequenceM_'
10:14:22 <ski> @type sequence_
10:14:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
10:14:29 <vixey> ski, just as an example yeah
10:14:29 <ski> @type mapM_
10:14:31 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
10:14:33 <ski> @type forM_
10:14:34 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
10:14:52 <vixey> oh, Monad could be another example
10:15:37 <ski> vixey : yes, i've briefly considered that .. and i think that would be nontrivial .. but possibly one can have useful uses in cases with no such complex constraining relations ..
10:15:44 <ski> *nod*
10:16:43 <ski> (i'm not considering trying to allow all possibly modes of modules .. just some .. so in many cases, there would possibly be just one mode of a module)
10:17:09 <rwbarton> ddarius: Do you know what kind of categories (e.g., which abelian categories) correspond to models of ordered linear logic?
10:17:11 <vixey> oh along the lines of mercury?
10:17:16 <rwbarton> ddarius: Or is that not a well-formed question?
10:17:53 <ski> vixey : yes, possibly (though i haven't yet been able to think of a case where multi-deterministic modules would be useful ..)
10:18:59 * ski is not sure there's one ordered linear logic agreed upon ..
10:19:18 <ddarius> rwbarton: It's a well-formed question, though it may or may not help you.  I'd think a pre-monoidal category would be one place to start.
10:21:05 <Axman6> :t >>= f =<<
10:21:06 <lambdabot> parse error on input `>>='
10:21:12 <Axman6> :t (>>= f =<<)
10:21:14 <lambdabot> parse error on input `)'
10:21:26 <Axman6> meh
10:21:29 <ddarius> rwbarton: It may be easier to start with what you need and then see what has it then to look for things that maybe have what you need and then see if they do.
10:21:39 <vixey> :t ((>>= f) =<<)
10:21:40 <lambdabot> forall (m :: * -> *) a b. (Monad m, SimpleReflect.FromExpr (m b), Show a) => m (m a) -> m b
10:22:54 <ski> @type ((>>= return) =<<)
10:22:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
10:23:51 <lilac> @check \xss -> ((>>= return) =<<) xss == (join xss :: [Int])
10:23:54 <lambdabot>   "OK, passed 500 tests."
10:25:12 <ski> hm .. it could be nice if it could select an arbitrary monad .. (or at least select from some standard ones)
10:25:43 <b_jonas> wouldn't be nice for check
10:25:47 <lilac> just for @check, or in quickcheck itself?
10:26:04 <mauke> it's too bad you can't make type annotation sections
10:26:07 <b_jonas> because then if you don't realize the type is ambiguous it prints "ok" even though it tests the wrong things
10:26:08 <mauke> I could really use them here
10:26:12 <ski> QC, i thought .. but i've no idea how hard it would be
10:26:16 <lilac> b_jonas: [] is the obvious one, since it's the free Monad :D
10:26:31 <b_jonas> lilac: what? it's not the free one, is it?
10:26:41 <mauke> isn't [] the free monoid?
10:26:52 <lilac> hmm
10:26:54 <ski> mauke : right
10:27:00 <ttt--> $ is the expensive one
10:27:05 <lilac> lol
10:27:11 <b_jonas> dunno
10:27:20 <Apocalisp> monoids want to be free
10:27:26 <mauke> forM_ hs ((:: IO ()) . ev)
10:27:30 <mauke> doesn't compile :/
10:27:41 <mauke> er, make that . ($ ev)
10:28:01 <b_jonas> mauke: oh yeah, someone told he wanted that syntax earlier
10:28:07 <b_jonas> I'm not sure who it was
10:28:11 <ski> forM_ hs (ev :: _ -> IO ())
10:28:33 <mauke> except it's ($ ev)
10:28:40 <ski> er, right
10:28:49 <ski> hm
10:28:58 <vixey> mauke: What if you don't put any annotations on ??
10:29:13 <mauke> vixey: error message since hs = cast hs'
10:29:14 <rwbarton> I guess  (`asTypeOf` (undefined :: IO ()))  is a bit wordy
10:29:16 <ski> forM_ hs ev :: IO ()  -- this ?
10:29:18 <b_jonas> what?
10:29:27 <b_jonas> what on earth is _ there?
10:29:32 <mauke> vixey: the result type is ambiguous since forM_ doesn't care
10:29:53 <ski> b_jonas : an (unimplemented) wildcard in type signatures
10:30:01 <mauke> ski: no, forM_'s context is fixed
10:30:17 <mauke> :t forM_
10:30:18 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
10:30:31 <mauke> the problem is the 'b' above
10:30:45 <ski> .. oh, i thought the problem was with `m'
10:31:27 <ski> bah! .. `forM_' ought to take an action of type `a -> m ()'
10:32:38 <rwbarton> Probably we'll get type annotation sections the same time we get record update sections
10:32:42 <ski> (and we should have `done :: Monad m => m ()' and `ignore :: Functor f => f a -> f ()' ..)
10:33:11 <mauke> ACK, except s/done/whatever/
10:33:21 <ski> (:
10:33:58 <mauke> do { like; stuff; whatever }
10:35:07 <vixey> :t for
10:35:08 <lambdabot> Not in scope: `for'
10:35:15 * ski likes `if blah then do bleh else done'
10:35:33 <vixey> :t done
10:35:35 <lambdabot> String -> Int -> [[String]] -> IO String
10:35:51 <ski> meep ?
10:35:56 <mauke> :t when
10:35:57 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
10:36:02 <b_jonas> record update sections?
10:36:08 <b_jonas> what would the syntax for those be?
10:36:11 <mauke> when blah $ do bleh
10:36:24 <Axman6> > done 3 ["test","hello","something","else"]
10:36:25 <lambdabot>   Couldn't match expected type `Int' against inferred type `[a]'
10:36:26 <ski> mauke : yes, i know .. this was just the first thing that crossed
10:36:30 <ski> my mind
10:36:45 <Axman6> > done "this is a" 3 ["test","hello","something","else"]
10:36:46 <lambdabot>   Couldn't match expected type `String' against inferred type `Char'
10:36:56 <ski> @index done
10:36:57 <lambdabot> bzzt
10:37:02 <sw17ch> newsham: during my meeting i figured out where we're differing
10:37:07 <sw17ch> you're thinking of a dial-in VPN
10:37:11 <sw17ch> to an existing copper network
10:37:16 <Axman6> > done "this is a" 3 $ map return ["test","hello","something","else"]
10:37:18 <lambdabot>   * Exception: "<IO [Char]>"
10:37:25 <newsham> sw17ch: no i'm not.
10:37:28 <sw17ch> ... oh
10:37:31 <newsham> although i am drawing an analogy to one
10:37:48 <Axman6> @where done
10:37:48 <lambdabot> I know nothing about done.
10:37:51 <ski> @hoogle done
10:37:51 <lambdabot> Control.Parallel.Strategies type Done = ()
10:37:59 <newsham> i'm not saying what you're dong wont work, i'm just saying you can make it a lot simpler
10:37:59 <Axman6> hmm
10:38:01 <sw17ch> newsham, what about the case where i want 5000 members in the network (potentially)
10:38:42 <newsham> two things.  1) i quesiton why you do.  and 2) i would probably reocmmend sharing a tun device in that case
10:38:56 <sw17ch> newsham: i was planning on sharing the tun device
10:39:04 <newsham> i know, and i'm recommending you dont normally
10:39:11 <newsham> *sigh*
10:39:17 <newsham> i dont know why i bother
10:40:17 <sw17ch> newsham: just so i understand you correctly... you want me to use an individual tun device for each client on the vpn. so each of the connections between clients needs it's own tun device. if i'm connected to 10 other people, i need 10 devices
10:40:34 <newsham> yup.. thats the gist of it
10:40:43 <binrapt> not[know[i, cause_of[bother[i, void]]]]
10:40:48 <newsham> and those 10 vpns can be 10 separate programs which work independantly
10:40:52 <newsham> and can start and stop independantly
10:41:06 <sw17ch> but i want the clients to be able to communicate with eachother
10:41:33 <newsham> ps: you could also use the pppd program and inetd.  you'll need a small program which makes a pty since most pppd's reuqire a tty
10:41:37 <sw17ch> and i want them all to live in the same netmask
10:41:51 <newsham> sw17ch: they can communicate with each other.  they would by necessity have different netmasks
10:42:21 <sw17ch> newsham: if that happens, one of the main models for this kind of vpn, LAN gaming, wouldn't work
10:42:38 <sw17ch> your broadcast packets would fail to get anywhere useful
10:42:58 <newsham> thats true.  if you're trying to imitate a LAN for a specific reason (ie. LAN gaming) then sharing a tun is the way to go
10:43:14 <sw17ch> newsham: and taht's exactly waht iw as trying to do to begin with
10:43:35 <newsham> well then, carry on.
10:44:05 <sw17ch> so, when i read a packet destined for *someone* in the netmask, i do'nt want to spew it to everyone, like a hub
10:44:12 <newsham> (ps: you could use a bridge device to do that with multiple tuns, but thats starting to get more complicated than its worth)
10:44:22 <newsham> *nod* i understand the switching bit
10:44:24 <sw17ch> newsham: have you used hamachi?
10:44:29 <newsham> nope
10:44:35 <sw17ch> well, i'm writing a hamachi clone
10:44:40 <sw17ch> hamachi isn't open source... and i love it
10:44:57 <sw17ch> it implements this style of VPN LAN with a fully connected graph
10:45:03 <sw17ch> so each client is connected to each other client
10:45:24 <sw17ch> i *think* it could be made a little more friendly at the expense of latency, but that's the jist of what i'm getting at
10:45:44 <newsham> how do they create a fully connected graph when some machines dont have public IPs?
10:45:54 <sw17ch> skype firewall punching
10:45:58 <newsham> ahh
10:46:01 <sw17ch> :)
10:46:21 <newsham> neato toredo
10:46:38 <mauke> (a -> b) -> a
10:46:53 <sw17ch> the reason i want to inspect the packets is to make it behave with close to the same efficiency that your individual tun-per-client model would have
10:47:01 <sw17ch> (within a constant factor)
10:47:31 <newsham> you'll always have more latency when you're switching in userland
10:47:37 <newsham> because you get two extra kernel/usre crossings
10:47:45 <newsham> when routing between two remote clients
10:47:50 <sw17ch> newsham: of course, but stepping up latency by 10ms isn't awful
10:47:54 <newsham> wait... hrm.. i think i got that wrong
10:48:08 <newsham> yah either way its going to userland since userland has to xmit to remote, nevermind
10:48:22 <sw17ch> well, you get the switch from kernel-> user when it kernel writes to tun
10:48:35 <sw17ch> we read the packet and write to the udp/tcp socket we're using for communication
10:48:38 <sw17ch> so, that's your extra
10:48:44 <sw17ch> and on the receiving end, you have the other
10:48:50 <sw17ch> so, two extra
10:49:04 <sw17ch> one extra per hop
10:49:21 <newsham> should be way smaller than 10ms though
10:49:51 <sw17ch> oh yeah, but adding that much to it (in the worst case) wouldn't be all that bad
10:50:03 <newsham> how are you doling out addresses?
10:50:11 <sw17ch> newsham: right now, static
10:50:14 <sw17ch> i haven't gotten that far with it
10:50:36 <sw17ch> it brings up the tun/tap, makes the UDP connection, and then reads/writes
10:50:40 <sw17ch> so right now, all it does is waht you originally proposed
10:51:12 <sw17ch> making the application behave like a hub is only slightly more code (extra socket, extra read, extra write)
10:51:18 <sw17ch> for each new client
10:51:25 <sw17ch> but you get m^n bandwidth usage
10:51:39 <sw17ch> woops
10:51:42 <sw17ch> m*n bandwidth usage
10:53:06 <sw17ch> the only part i'm upset with so far is that i am performing all the ioctl's in C
10:53:11 <sw17ch> i don't think there's a happy way to do that in haskell
10:53:21 <newsham> sw17ch: you should FFI to dnet
10:53:31 <sw17ch> dnet?
10:53:54 <newsham> http://libdnet.sourceforge.net/
10:53:55 <sw17ch> (i am FFI'ing to get the FileDescriptor of /dev/net/tun)
10:53:55 <lambdabot> Title: libdnet
10:54:01 <newsham> portability library for networking tables
10:54:11 <sw17ch> oh nifty
10:54:27 <newsham> someone needs to make dnet bindings for haskell and put it on hackage
10:54:36 <Axman6> > foldr1 f [a,b,c]
10:54:37 <lambdabot>   f a (f b c)
10:54:43 <Axman6> > foldr1 f [a,b,c,d]
10:54:44 <lambdabot>   f a (f b (f c d))
10:54:49 <Axman6> > foldl1 f [a,b,c,d]
10:54:50 <lambdabot>   f (f (f a b) c) d
10:55:42 <sw17ch> newsham, have you used dnet?
10:55:48 <newsham> yup
10:56:44 <mauke> :t fromMaybe
10:56:45 <lambdabot> forall a. a -> Maybe a -> a
10:57:36 <sw17ch> newsham: gentoo complains about poor programming practices in libdnet
10:58:05 <newsham> anything specific?
10:58:17 <sw17ch> no, just one of the build warnings
10:59:01 <mm_freak> why is Char not an instance of Num?  i know, it would be kinda incorrect, but it sucks doing ord/chr all the time
10:59:16 <newsham> its written by a really good programmer, but who knows, its C, errors happen
10:59:22 <sw17ch> :)
10:59:25 <mauke> sw17ch: what's the warning?
10:59:43 <sw17ch> mauke: well, the generic scary yellow asterisk stuff gentoo spits out occasionally
11:00:00 <lilac> does there exist a well-ordering of haskell values with, say, (a, x) > x forall x?
11:00:06 <sw17ch> mauke: QA Notice: Package has poor programming practices which may compile fine but exhibit random runtime failures.
11:00:17 <mauke> sw17ch: no, the compiler warning
11:00:18 <sw17ch> and then
11:00:20 <sw17ch> mauke: ./dnet.c:3643: warning: implicit declaration of function 'strlcpy'
11:00:23 <mauke> ah
11:00:44 <mauke> but it compiled? weird
11:00:54 <mm_freak> mauke: in C implicit prototypes are allowed
11:01:01 <mm_freak> but it's a poor programming practice
11:01:05 <mauke> I know, but glibc doesn't seem to have strlcpy
11:01:17 <mm_freak> maybe that package has it itself
11:01:32 <sw17ch> newsham, libdnet looks pretty cool..and not that hard to ffi
11:01:45 <sw17ch> 1718 lines of header files with comments
11:01:49 <newsham> and once ffi'd your code will work on many platforms
11:02:01 <sw17ch> libdnet is cross platform even??
11:02:13 <newsham> bsd, linux, osx, windows, solaris, irix, hpux, tru64
11:02:16 <sw17ch> omg
11:03:02 <newsham> (in decreasing order of importance, of course ;)
11:03:31 <sw17ch> dnet/tun.h doesn't seem to give you suitable access to tun/tap :\
11:03:54 <newsham> *nod* not sure how much portability it gives to tunneling,
11:04:02 <newsham> but the other stuff like address binding should be good
11:04:09 <sw17ch> newsham, well, it seems like it's there for point-to-point tunneling
11:04:12 <sw17ch> the kind build into the kernel
11:04:27 <sw17ch> still a neat library
11:05:01 <sw17ch> oh, but it may cover it well in the interface functions
11:05:21 <newsham> what is missing, btw?
11:06:38 <mauke>   modifyIORef mv $ M.alter (Just . f . fromMaybe (HL $ tail [h])) (typeOf $ arg h)
11:06:41 <mauke> wheee
11:07:11 <newsham> sw17ch: you can probably tun_open and then tun_name to get the name, and then use the interface functions to alter netmask and p/p flag
11:07:30 <newsham> it'll prob work on at least some platforms, might not work portably
11:08:35 <thegravian> Hello, is anybody here familiar with language-c?
11:11:05 <byorgey> @seen visq
11:11:05 <lambdabot> I haven't seen visq.
11:12:00 <tristes_tigres> you can't make lamba-expression infix in haskell ?
11:12:16 <Botje> no.
11:12:22 <rwbarton> what would that mean?   (x `\` y -> x+y) ?
11:12:29 <mauke> haha
11:12:40 <rwbarton> Oh, expression, not symbol :)
11:12:44 <mauke> a `\x y -> x + y` b
11:12:46 <Botje> i presume tristes_tigres means something like (x `\x y -> foo x y` y)
11:12:51 <Botje> but that's pretty silly
11:12:55 <tristes_tigres> botje: yes
11:13:04 <opqdonut> infix expressions are implementable in haskell
11:13:29 <tristes_tigres> @type `\x y -> x +y`
11:13:30 <newsham> x `liftM2 (+)` y
11:13:30 <lambdabot> parse error on input ``'
11:13:41 <dmwit> tristes_tigres: Well, for that exact function, you'd just use `foo`.  But for more complicated things, you need to give it a name.
11:14:07 <EvilTerran> > let infixl 1 «, »; («) = flip ($); (») = ($) in [1,2,3] «zipWith(,)» "ABC"
11:14:07 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 21}
11:14:08 <lambdabot> ...
11:14:21 <tristes_tigres> dmwit: no usage like `\x y -> x +y` ?
11:14:30 <EvilTerran> , let infixl 1 «, »; («) = flip ($); (») = ($) in [1,2,3] «zipWith(+)» [4,5,6]
11:14:31 <lunabot>  luna: lexical error at character '\171'
11:14:34 <EvilTerran> grr
11:14:45 <EvilTerran> i'm sure that worked a few days ago
11:14:54 <newsham> let _f = liftM2 f in 3 _+ 5
11:15:07 <dmwit> tristes_tigres: Again, for that exact example, you'd just use +.  But no, for more complicated things, you need to name the function.
11:15:09 <EvilTerran> it works in files, anyway
11:15:35 <rwbarton> EvilTerran: Try it in privmsg, lambdabot is sending you back a different character
11:15:43 <tristes_tigres> dmwit: this restriction seems a bit artifificial, no ?
11:15:45 <EvilTerran> , let infixl 1 <|, |>; (<|) = flip ($); (|>) = ($) in [1,2,3] <|zipWith(+)|> [4,5,6]
11:15:47 <lunabot>  [5,7,9]
11:15:47 <newsham> «+»   would be kinda nice for liftM2 (+)
11:16:04 <Botje> heh
11:16:05 <dmwit> tristes_tigres: A little bit.  But it prevents things like (a `what `would` this` mean).
11:16:06 <tristes_tigres> is there a reason for it ?
11:16:09 <Botje> that's what the perl6 people are trying to do
11:16:17 <EvilTerran> adverbs!
11:16:32 <newsham> x `(liftM2 (+)) y
11:16:36 <b_jonas> you could always say `what (`would`) this` mean
11:16:49 <newsham> `(..) = `..`
11:16:55 <dmwit> b_jonas: Better is to introduce new tokens `( and `).
11:16:55 <tristes_tigres> dmwit: ah, so the problem is the declaring specific infixity for ``
11:17:07 <dmwit> b_jonas: or )`, if you prefer ;-)
11:17:17 <dmwit> tristes_tigres: No, the problem is nesting ``s.
11:17:23 <niklaus>  main = do    f <- readFile "test.txt"    let var = map doHands $ lines f        zz = filter fn var     print $ length zz
11:17:36 <thegravian> Does anybody know if there could be a way to deriving an instance of Show on Language.C.Syntax.AST without manually altering the code?
11:17:42 <b_jonas> dmwit: neither would be backwards compatible
11:17:50 <dmwit> tristes_tigres: My example could parse as (a `(what)` would `(this)` mean) or as (a `(what `(would)` this)` mean).
11:17:52 <mm_freak> hmm…  how would a correct Num Char instanciation look like?  (+) = chr . ((+) `on` ord)  -- seems incorrect to me
11:18:14 <newsham> dmwit:   `(...)  is easier than   `(...`)
11:18:21 <niklaus>  filter fn var  only puts the true values of fn into zz, i want something if (fn var is true ) then print 1 else print 2, i'm unable to get this, can someone suggest the correct syntax
11:18:40 <wjt> print (if f v then 1 else 2)
11:18:40 <dmwit> mm_freak: (chr .) . ((+) `on` ord)
11:18:50 <dmwit> :t (chr .) . ((+) `on` ord)
11:18:51 <lambdabot> Char -> Char -> Char
11:19:05 <mm_freak> uhm yeah…  indeed
11:19:07 <dmwit> mm_freak: Or, just (\x y -> chr (ord x + ord y)), which is pretty darn readable. ;-)
11:19:09 <wjt> > ((chr .) . ((+) `on` ord)) 'a' 'b'
11:19:10 <lambdabot>   '\195'
11:19:12 <wjt> how useful.
11:19:12 <b_jonas> that's the .: thing again, right?
11:19:29 <dmwit> wjt: The use would be that 0 would now be a character.
11:19:30 <rwbarton> niklaus: maybe you want    zz = map (\v -> if fn v then 1 else 2) var
11:19:30 <b_jonas> > (chr .: ((+) `on` ord)) 'a' 'b'
11:19:32 <lambdabot>   '\195'
11:19:38 <dmwit> wjt: So 'a' + 3 = 'd'.
11:19:40 <mm_freak> dmwit: yeah, in that case, the pointy style is better
11:19:47 <dmwit> wjt: (Due to Num literal magic.)
11:19:52 <wjt> @ty fromInteger
11:19:53 <lambdabot> forall a. (Num a) => Integer -> a
11:19:54 <wjt> oh, it's in *num*
11:20:00 <rwbarton> @ty 3
11:20:01 <lambdabot> forall t. (Num t) => t
11:20:07 <b_jonas> > (liftM2 chr ((+) `on` ord)) 'a' 'b'
11:20:09 <lambdabot>   Couldn't match expected type `a2 -> r' against inferred type `Char'
11:20:20 <wjt> i thought it was in Integral or something :)
11:20:22 <niklaus> wjt, it gives syntax error
11:20:30 <dmwit> b_jonas: There's two "environments", so the Reader monad doesn't quite cut it.
11:20:32 <wjt> !paste
11:20:39 <niklaus> 54.hs:38:0: parse error (possibly incorrect indentation
11:20:39 <dmwit> b_jonas: You might do something with uncurry.
11:20:40 <mm_freak> i'd love to find Char as a Num instance in the next haskell standard
11:20:43 <wjt> niklaus: paste your code to hpaste.org
11:20:46 <sw17ch> newsham, i was looing at the type flag for interface
11:20:48 <mm_freak> it sucks to do ord/chr all the time
11:20:51 <dmwit> ?paste wjt, niklaus
11:20:51 <lambdabot> Haskell pastebin: http://hpaste.org/new
11:20:55 <sw17ch> meh, i'll play with it and see what happens
11:21:02 <b_jonas> dmwit: oh yeah
11:21:03 <wjt> dmwit: ah, misremembered
11:21:08 <b_jonas> let's remain with
11:21:20 <rwbarton> ‽paste
11:21:20 <lunabot>  luna: Not in scope: `paste'
11:21:22 <b_jonas> > (((.) . (.)) chr ((+) `on` ord)) 'a' 'b'
11:21:24 <lambdabot>   '\195'
11:21:35 <niklaus> dmwit, http://hpaste.org/10871
11:21:46 <mauke> ‽()
11:21:47 <lunabot>  ()
11:22:23 <dmwit> niklaus: Your print statement is indented too far.
11:22:41 <newsham> in hawaiian "mauka" is "mountain side"
11:22:41 <niklaus> dmwit, i want it to print it for each line
11:22:42 <dmwit> niklaus: Also, you need to remove the "print" inside the "then" clause.
11:22:42 <b_jonas> what's this lunabot?
11:22:47 <mm_freak> > let π = 3.14159 in π
11:22:48 <lambdabot>   3.14159
11:22:59 <lilac> (picking up a long-dropped thread) i believe the free monad is the identity monad :-o
11:23:03 <newsham> i wonder if there's a "mauke"
11:23:11 <dmwit> niklaus: Then take a look at mapM_ or forM_.
11:23:20 <b_jonas> lilac: I think that's not it too
11:23:43 <b_jonas> lilac: but I'm not so good in it so that's just a feeling
11:23:50 <rwbarton> the identity monad is the free monad on the zero functor
11:23:53 <niklaus> dmwit, why can't it be done easily ? why doesn't print ( ) work ?
11:24:05 <lilac> b_jonas: hmm, well, i have an intuitivistic "proof"
11:24:08 <dmwit> niklaus: I don't understand.
11:24:23 <niklaus> dmwit, you said print is indented too far
11:24:45 <dmwit> niklaus: That is correct.  Your code parses as having the "print" statement in the "let" block, not the "do" block.
11:26:13 <niklaus> dmwit, can't we do something like if (true) print this else print that
11:26:21 <dmwit> niklaus: Certainly.
11:26:36 <dmwit> niklaus: You can also do (print (if true then this els that)).
11:26:41 <dmwit> niklaus: However, you can't do
11:26:49 <dmwit> print (if true then print this else that)
11:27:04 <dmwit> s/els /else /
11:27:05 <lilac> b_jonas: and i'm a clueless category theory newbie, but Identity seems to meet the universal mapping property
11:27:15 <niklaus> dmwit, yes but why am i getting indentation , i fixed the indentation
11:27:24 <dmwit> niklaus: Okay, let's see the fixed version.
11:27:45 <niklaus> dmwit, http://hpaste.org/10872
11:27:50 <b_jonas> lilac: I think it's quite the other way
11:28:00 <b_jonas> lilac: identity is the least free monad there is
11:28:04 <niklaus> dmwit, forgive my mistakes
11:28:13 <dmwit> niklaus: No problem.  What's the new error?
11:28:37 <niklaus> dmwit, Couldn't match expected type `([(a, b)], [(a, b1)])'
11:28:37 <niklaus>            against inferred type `[([(Int, Int)], [(Int, Int)])]'
11:28:37 <niklaus>     In the first argument of `p1won', namely `games'
11:28:37 <niklaus>     In the predicate expression: p1won games
11:28:37 <niklaus>     In the first argument of `print', namely
11:28:38 <niklaus>         `(if p1won games then "player 1" else "player 2")'
11:28:46 <dmwit> Okay.  That's not an indentation error.
11:29:02 <b_jonas> still that [([( thingy?
11:29:10 <dmwit> That's a type error, and if you figure out the types of "games" and "p1won" separately, you'll see why it's happening.
11:29:28 <niklaus> dmwit, how does filter figure out that
11:29:30 <dmwit> (i.e. see if you can figure out the type of "games" by hand.  It's good practice.)
11:29:41 <niklaus> dmwit, when i had filter p1won games
11:29:49 <daf> hmm
11:29:50 <niklaus> zz = filter p1won games
11:30:01 <daf> there doesn't seem to be a way to convert lazy bytestrings to strict ones
11:30:01 <dmwit> The type of "filter p1won" is to the same as the type of "p1won".
11:30:03 * dmwit shrugs
11:30:24 <dmwit> :t filter odd
11:30:25 <daf> Data.Binary produces lazy ones; HDBC consumes strict ones
11:30:25 <lambdabot> forall a. (Integral a) => [a] -> [a]
11:30:26 <dmwit> :t odd
11:30:27 <lambdabot> forall a. (Integral a) => a -> Bool
11:30:32 <daf> going via String seems silly
11:30:43 <dmwit> niklaus: You see?  Filter consumes a list, but its first argument consumes an element of the list.
11:30:44 <rwbarton> daf: I think you want S.fromChunks . L.toChunks or so
11:31:12 <daf> rwbarton: aha!
11:31:18 <rwbarton> Well, something like that.
11:31:53 <lilac> b_jonas: fwiw, this: http://comonad.com/reader/2008/monads-for-free/ appears to agree with me
11:32:00 <lambdabot> Title: The Comonad.Reader » Monads for Free
11:32:17 <lilac> hmm
11:32:18 <lilac> ish
11:32:35 <lilac> free monad there is FreeMonad a = (Integer, a)
11:32:50 <dmwit> (Integer, a)?
11:33:08 <dmwit> What's that Integer doing in my free monad?
11:33:18 <rwbarton> I think that's the free monad on the identity functor...?
11:33:20 <niklaus> dmwit,  this works http://hpaste.org/10873 but it gives aggregate result, can't we do  print (if true then "abcd" else "mnop" )
11:33:48 <dmwit> niklaus: I'm trying to convince you that your schematic "true" isn't well-typed.
11:34:03 <dmwit> niklaus: You're giving "p1won games" in the condition of the if.
11:34:04 <lilac> i think that must be wrong, since it violates the monad laws! :)
11:34:06 <rwbarton> Yeah, that's what that page says
11:34:21 <dmwit> niklaus: p1won takes an "a", but "games" is an [a].
11:34:25 <dmwit> niklaus: So the types don't match up.
11:34:32 <niklaus> dmwit, can i do filter
11:34:36 <niklaus> filter p1won games
11:34:49 <dmwit> niklaus: ...you *could*, but you still don't get a Bool out.
11:35:04 <daf> rwbarton: S.concat . L.toChunks
11:35:04 <dmwit> (i.e. it still wouldn't be well-typed)
11:35:32 <dmwit> niklaus: If you want to do an IO action for each element of a list, you have to write a loop.
11:35:38 <dmwit> niklaus: mapM_ is such a loop.
11:35:42 <dmwit> :t mapM_
11:35:44 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
11:35:44 <lilac> dmwit: there's no way to get the integer to be anything except zero :)
11:36:05 <dmwit> lilac: So how is it different from the Identity monad, practically speaking?
11:36:45 <dmwit> () x a = a
11:36:48 <rwbarton> lilac: There is, if you also allow yourself use of Roll . Succ.
11:36:53 <mauke> :t filterM
11:36:54 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
11:37:24 <lilac> rwbarton: why would you allow that?
11:37:24 <humasect> @hoogle forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
11:37:25 <lambdabot> Parse error:
11:37:25 <lambdabot>   --count=20 "forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]"
11:37:25 <lambdabot>                       ^
11:37:26 <rwbarton> lilac: Basically the free monad on a functor F is the free thing M you get from the monad laws plus a map inj :: F a -> M a.
11:37:56 <tristes_tigres> foldl f == foldr (flip f) ?
11:38:04 <lilac> rwbarton: sure. i was wondering what the 'one true free monad' would be, though.
11:38:12 <Botje> tristes_tigres: reverse in there somewhere
11:38:25 <dmwit> > (foldl f a [x,y,z], foldr (flip f) a [x,y,z]) -- tristes_tigres, I don't think so
11:38:26 <lambdabot>       Ambiguous occurrence `x'
11:38:26 <lambdabot>      It could refer to either `L.x', defined a...
11:38:30 <rwbarton> lilac: If there is such a thing, it's the Identity monad, yeah.  (What is the "one true free group"?)
11:38:32 <dmwit> ?undefine
11:38:50 <dmwit> > (foldl f a [x,y,z], foldr (flip f) a [x,y,z])
11:38:51 <lambdabot>   (f (f (f a x) y) z,f (f (f a z) y) x)
11:39:18 <rwbarton> lilac: I think it's just a terminology thing.  The normal term for "one true free" is "initial" :)
11:39:25 <dmwit> foldl f a = foldr (flip f) a . reverse
11:39:34 <dmwit> > (foldl f a [x,y,z], foldr (flip f) a . reverse $ [x,y,z])
11:39:35 <lambdabot>   (f (f (f a x) y) z,f (f (f a x) y) z)
11:39:43 <b_jonas> hmm
11:39:49 <rwbarton> @src reverse
11:39:49 <lambdabot> reverse = foldl (flip (:)) []
11:39:57 <humasect> hehe
11:39:59 <dmwit> ;-)
11:39:59 <rwbarton> and foldr (:) [] == id
11:40:00 * lilac needs to read more category theory
11:42:25 <humasect> @src curry
11:42:25 <lambdabot> curry f x y = f (x, y)
11:42:46 <humasect> oh, right .. those tuple things
11:42:46 <tristes_tigres> what does the > do, exacltly ? lambdabot help is not helpful
11:43:00 <Botje> it just evaluates stuff
11:43:01 <humasect> it is eval
11:43:01 <dmwit> tristes_tigres: It evaluates things a la ghci.
11:43:06 <dmwit> ?eval 3 + 4
11:43:14 <dmwit> ?run 3 + 4
11:43:15 <lambdabot>   7
11:43:17 <humasect> @src pi
11:43:17 <lambdabot> Source not found. :(
11:43:18 <dmwit> ?help run
11:43:18 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
11:43:31 <dmwit> humasect: It's a class function, you have to give a specific type.
11:43:34 <dmwit> ?src pi Double
11:43:35 <lambdabot> Source not found. That's something I cannot allow to happen.
11:43:35 <Beelsebob> that's not right -- curry = simmer . addSauce . marinade curryPaste
11:43:38 <dmwit> ?src Double pi
11:43:38 <lambdabot> Source not found. You type like i drive.
11:43:41 <humasect> ah, right
11:43:41 * dmwit shrugs
11:43:46 <mauke> :t (. (,)) . (.)
11:43:48 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
11:43:50 <humasect> @src (pi:: Double)
11:43:51 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
11:44:10 <dmwit> tristes_tigres: It makes IRC a literate Haskell file. =)
11:44:11 <humasect> mauke: what have you done ? =)
11:44:20 <rwbarton> \begin{code}
11:44:25 <humasect> hehe
11:44:39 <dmwit> ?djinn ((a, b) -> c) -> a -> b -> c
11:44:40 <lambdabot> f a b c = a (b, c)
11:44:43 <mauke> humasect: removed your points
11:44:46 <dmwit> ?pl f a b c = a (b, c)
11:44:46 <lambdabot> f = (. (,)) . (.)
11:44:49 <tristes_tigres> dmwit: but ghci can't evaluate  foldl f a [x,y,z]
11:44:54 <gbacon> if I have two arrows that I want to process the same document, how should I structure it? runX $ readDoc "file.xml" >>> foo &&& bar doesn't give the type I expect
11:44:59 <dmwit> tristes_tigres: Ah, that's from the SimpleReflect module.
11:45:02 <dmwit> ?where SimpleReflect
11:45:02 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
11:45:05 <mauke> tristes_tigres: only because f, a, x, y, and z are not in scope
11:45:25 <dmwit> tristes_tigres: It's not magic, there's just constants bound to some things:
11:45:26 <dmwit> :t f
11:45:27 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
11:45:33 <Deewiant> :t x
11:45:35 <lambdabot> Expr
11:45:41 <humasect> :t :t
11:45:43 <lambdabot> parse error on input `:'
11:45:46 <Deewiant> :t (:t)
11:45:48 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Expr'
11:45:48 <lambdabot>     In the second argument of `(:)', namely `t'
11:45:54 <humasect> is there a difference between :t and @type ?
11:45:54 <dmwit> :t \t -> (:t)
11:45:55 <lambdabot> forall a. [a] -> a -> [a]
11:45:58 <mauke> humasect: no
11:45:59 <humasect> hehe
11:45:59 <dmwit> humasect: spelling
11:46:01 <humasect> ok
11:46:08 <dmwit> humasect: Also, ?type works in privmsg.
11:46:08 <mauke> humasect: except @type works in /msg
11:46:15 <dmwit> bah
11:46:16 <humasect> ahh
11:46:22 * dmwit leaves mauke to the explanations
11:46:30 <tristes_tigres> > foldl g a [x,y,z]
11:46:31 <lambdabot>   g (g (g a x) y) z
11:46:36 <b_jonas> also @type is more general in that it can be used in @? or @.
11:46:36 <humasect> ?djinn (Monad m) => (a -> m Bool) -> [a] -> m [a]
11:46:37 <lambdabot> Error: Undefined type []
11:46:50 <dmwit> djinn doesn't do recursive types.
11:46:57 <dmwit> I'm not sure it does classes, either.
11:46:59 <humasect> ah, i don't know what djinn is
11:47:08 <mauke> humasect: djinn generates code from types
11:47:09 <humasect> b_jonas: what do you mean ?
11:47:16 <dolio> djinn proves your theorems.
11:47:23 <rwbarton> dmwit: It can only really handle classes with parameter of kind *.
11:47:24 <humasect> ?djinn (a -> b) -> [a] -> [b]
11:47:24 <lambdabot> Error: Undefined type []
11:47:30 <humasect> oh
11:47:34 <mauke> @djinn (a -> b) -> a -> b
11:47:34 <lambdabot> f a = a
11:47:44 <mauke> @djinn (a -> b) -> Maybe a -> Maybe b
11:47:44 <lambdabot> f a b =
11:47:44 <lambdabot>     case b of
11:47:44 <lambdabot>     Nothing -> Nothing
11:47:44 <lambdabot>     Just c -> Just (a c)
11:47:54 <humasect> !
11:48:18 <dmwit> ?djinn (Functor f) => (a -> b) -> f a -> f b
11:48:18 <lambdabot> f = fmap
11:48:28 <mauke> @djinn (b -> c) -> (a -> b) -> a -> c
11:48:28 <lambdabot> f a b c = a (b c)
11:48:33 <dolio> @djinn (a -> b) -> Not (a, Not b)
11:48:33 <lambdabot> f a (b, c) = c (a b)
11:48:36 <rwbarton> ?djinn (Functor f) => (a -> c) -> f a -> f c
11:48:36 <lambdabot> -- f cannot be realized.
11:48:43 <dmwit> ?djinn (Functor f) => (a -> b -> c) -> f (a -> b) -> f a -> f c
11:48:44 <lambdabot> -- f cannot be realized.
11:48:47 <dmwit> hmm
11:48:51 <rwbarton> @djinn-env
11:48:52 <lambdabot> data () = ()
11:48:52 <lambdabot> data Either a b = Left a | Right b
11:48:52 <lambdabot> data Maybe a = Nothing | Just a
11:48:52 <lambdabot> data Bool = False | True
11:48:52 <lambdabot> data Void
11:48:54 <lambdabot> type Not x = x -> Void
11:48:56 <lambdabot> class Eq a where (==) :: a -> a -> Bool
11:48:58 <lambdabot> class Functor f where fmap :: (a -> b) -> f a -> f b
11:49:02 <lambdabot> class CoFunctor f where cofmap :: (a -> b) -> f b -> f a
11:49:10 <dmwit> rwbarton: sad
11:49:11 <dolio> djinn doesn't really do variables with kind other than * very well.
11:49:35 <b_jonas> @. djinn type flip const
11:49:37 <lambdabot> f _ a = a
11:50:11 <rwbarton> @. pl . djinn type flip const
11:50:13 <lambdabot> f = const id
11:50:21 <dolio> It only knows that you can turn (a -> b) into (f a -> f b), not that you can do it for things besides a and b.
11:50:38 <dmwit> Haskell is so primitive.
11:50:40 <dmwit> ;-)
11:50:43 <b_jonas> is CoFunctor the same as Functor?
11:50:50 <dmwit> nope
11:50:50 <humasect> > Not 5
11:50:51 <lambdabot>   Not in scope: data constructor `Not'
11:51:00 <humasect> but it says Not in scope
11:51:06 <b_jonas> why does it seem so from djinn-type then?
11:51:08 <dolio> @djinn (Functor f) => (Int -> Bool) -> f Int -> f Bool
11:51:08 <lambdabot> Error: Undefined type Int
11:51:10 <dmwit> b_jonas: Just check the type of cofmap.
11:51:11 <rwbarton> Not is a type alias in djinn
11:51:12 <grahamhutton> b_jonas: no: contravariance!
11:51:20 <dolio> @djinn (Functor f) => (() -> Bool) -> f () -> f Bool
11:51:21 <lambdabot> -- f cannot be realized.
11:51:22 <rwbarton> that doesn't make it a data constructor in lamdabot :)
11:51:23 <b_jonas> oh, f b -> f a
11:52:06 <humasect> @. djinn type map
11:52:07 * rwbarton missed the joke
11:52:08 <lambdabot> Error: Undefined type []
11:52:19 <b_jonas> no recursive types
11:52:20 <humasect> oh, i am slow too as you can see =)
11:52:21 <b_jonas> that includes []
11:53:14 <rwbarton> Is the problem that djinn solves even computable in the presence of higher-kinded classes?
11:53:57 <humasect> @djinn Maybe a -> b -> a -> Maybe b
11:53:58 <lambdabot> f a b _ =
11:53:58 <lambdabot>     case a of
11:53:58 <lambdabot>     Nothing -> Nothing
11:53:58 <lambdabot>     Just _ -> Just b
11:54:03 * ski thinks `CoFunctor' is an ill-chosen name ..
11:54:29 <dolio> rwbarton: If you want them to work properly, then you can reduce the problem to higher-rank polymorphism.
11:54:31 <rwbarton> It seems @djinn Functor f => ... is equivalent to @djinn (forall a b. (a -> b) -> f a -> f b) -> ...
11:54:36 <humasect> i have a feeling there is no end to the secrets of haskell
11:54:37 <dolio> And I'd guess the answer is no.
11:54:42 <grahamhutton> ski: why, it stands for contravariant functor.
11:54:47 <niklaus> is there a haskell to C translater : ?
11:54:48 <rwbarton> OK, that's what I thought too
11:54:59 <mauke> niklaus: ghc
11:55:05 <mauke> humasect: http://okmij.org/ftp/Haskell/types.html#de-typechecker
11:55:06 <lambdabot> Title: Haskell Programming: Types
11:55:14 <niklaus> mauke, it produces c code ?
11:55:29 <mauke> niklaus: it can
11:55:44 <humasect> -ftoC ?
11:55:45 <niklaus> mauke, can we compile that with g++ ?
11:55:57 <mauke> niklaus: no, g++ is not a C compiler
11:56:04 <niklaus> mauke, ok gcc
11:56:15 <mauke> yes, and that's exactly what ghc -fvia-C does
11:56:24 <b_jonas> so now we have lunabot and lojbot apart from lambdabot. if I nicked my bot to l*bot, would that make you tolerate my flooding the channel with bot output more?
11:56:30 <ski_> grahamhutton : is there really a category (or quasi-category or whatever) where covariant functors in it (as objects ?) are contravariant functors in the opposite category ?
11:56:32 <humasect> :t reify
11:56:33 <lambdabot> Not in scope: `reify'
11:56:35 <humasect> thanks, mauke
11:58:05 <grahamhutton> ski: yes, contravariant functors on a category C are covariant functors on C^op.   Category theory is your friend :-)
11:58:36 <ski> grahamhutton : you misunderstand, i think
11:58:54 <grahamhutton> ski: how?  what I said is correct.
11:59:06 <humasect> @unpl (((. head . uncurry zip . splitAt 1 . repeat) . uncurry) .) . (.) . flip
11:59:06 <lambdabot> (\ k ac af -> uncurry (\ e h -> k h (ac e)) (head (uncurry zip (splitAt 1 (repeat af)))))
11:59:14 <dolio> Contravariant endofunctors in C aren't covariant endofunctors in C^op, are they?
11:59:22 <ski> example : an initial object in a category C is a terminal object in the opposite category
11:59:27 <tristes_tigres> equality of types is decidable whereas equality of functions is not
11:59:29 <rwbarton> dolio: No
11:59:43 <grahamhutton> ski: that's nothing to do with contravariance.
11:59:49 <ski> example : a monomorphism in a category C is an epimorphism in the opposite category C^op
12:00:04 <grahamhutton> ski: same answer again
12:00:18 <ski> grahamhutton : i know .. but it has all to do with the "co-" prefix .. i.e. category-theoretic dual concepts
12:00:37 <rwbarton> The co- prefix is tricky in haskell, you have to reverse some of the -> but not all of them.
12:01:22 <ski> rwbarton : it depends on which arrows are interpreted as morphism arrows, and which are interpreted as functions between (say) Hom classes
12:01:25 <grahamhutton> ski: contravariance is more complicated that it just being a "co" (dual) concept.  It's about a fundamental property of function spaces.
12:01:34 <rwbarton> ski: Exactly
12:01:53 <ski> grahamhutton : yes .. hence i do not want to use `co-' together with `functor'
12:02:10 <ski> (it's bad enough that there's a `co' in `covariant functor' ..)
12:02:21 <dolio> rwbarton: You don't have that problem if you parameterize over the type constructor for morphisms. :)
12:02:24 <grahamhutton> ski: the "co" here is used in a different sense; it's really "contra", rather than "co".
12:02:37 <b_jonas> there are now 50 google hits for zygohistomorphic prepromorphisms
12:03:32 <grahamhutton> ski: aha -- I see the problem now: when I see "covariant" functor I read this as "contravariant", which is something quite different than "co-variant".
12:03:52 <ski> grahamhutton : yes, i know that too :) .. so i accept `covariant functor' and `contravariant functor' .. but i don't like `cofunctor' (unless maybe if it is meant as a shorthand for the *former*)
12:04:21 <mauke> @vixen are you having cofun?
12:04:22 <lambdabot> i try to be fun... what do you think?
12:04:23 <grahamhutton> ski: agreed :-)
12:04:52 <ski> @google zygohistomorphic prepromorphisms
12:04:54 <lambdabot> No Result Found.
12:05:19 <tristes_tigres> ski: no swearing? this is family channel
12:05:48 <ski> @arr
12:05:48 <lambdabot> Swab the deck!
12:05:59 <dolio> @b52s
12:05:59 <lambdabot> Girl from Ipanema, she goes to Greenland
12:06:11 <dolio> There really aren't enough of those.
12:06:25 <ski> @keal
12:06:25 <lambdabot> someone needs to write a boids for haskell that emulates humans going on and off topic
12:06:29 <harrison_partch> b-52s. mid 80's release.
12:07:00 <harrison_partch> I saw them in '79 at the Motor City Roller Rink in (of course) Detroit.
12:07:06 <grahamhutton> ski: don't mess with these... you start off with a simple catamorphism, then someone convinces you to try an anamorphism, and before you know it, you are hooked on paramorphisms.   (sorry)
12:07:07 <b_jonas> some of them are logs of #haskell apparently though
12:07:08 <ski> (Babylon 5 ?)
12:07:31 <b_jonas> actually only 14 hits
12:07:38 <b_jonas> for some reason it says "about 50"
12:07:46 <b_jonas> whew
12:07:56 <ski> grahamhutton : i'm already hooked on the lighter stuff .. it's just a matter of time 'til i have to use the heavier things
12:08:00 <dolio> Their counts don't seem to be particularly accurate, usually.
12:08:40 <b_jonas> eek
12:08:53 <mauke> http://blog.desudesudesu.org/wp-content/uploads/2007/12/haskellmonadstc8.jpg
12:08:57 <lambdabot> http://tinyurl.com/46brsd
12:09:14 <opqdonut> :)
12:10:10 <hugo__> HASKELL IS BEAUTIFUL!
12:10:33 <hugo__> ...sorry, i just needed to say that :P
12:11:07 <humasect> =)
12:11:13 <Apocalisp> \o/
12:11:22 <mauke> ｂｅａｕｔｉｆｕｌ
12:12:06 <dolio> That text is all aliased and un-beautiful.
12:13:13 <mauke> ℘ℰℛℒ
12:13:25 <Apocalisp> oooh
12:13:30 <Apocalisp> can you say LaTeX?
12:13:45 <humasect> ♬
12:14:23 <mperillo> hi
12:14:24 <tristes_tigres> latexbot ?
12:14:30 <tristes_tigres> @bot
12:14:30 <lambdabot> :)
12:14:44 <mperillo> there is a function for taking all but the last n characters from a string?
12:15:05 <mperillo> I have written this function: takeR n xs = take (length xs - n) xs
12:15:21 <tristes_tigres> @pl take (length xs - n) xs
12:15:21 <lambdabot> take (length xs - n) xs
12:15:24 <opqdonut> there's a trick to it
12:15:41 <Heffalump> mperillo: reverse . drop n . reverse
12:15:51 <opqdonut> \l n -> map fst $ zip l (drop n l)
12:15:55 <Heffalump> but it's not very efficient in comparison to your one, probably.
12:15:57 <opqdonut> cool eh?
12:16:03 <geezusfreeek> @pl \n -> reverse . drop n . reverse
12:16:04 <lambdabot> (reverse .) . (. reverse) . drop
12:16:06 <Heffalump> that one's sneakier.
12:16:19 <opqdonut> reversing isn't very nic
12:16:21 <dolio> zipWith const
12:16:25 <opqdonut> ah
12:16:28 <opqdonut> yes
12:16:33 <tristes_tigres> @src reverse
12:16:33 <lambdabot> reverse = foldl (flip (:)) []
12:17:11 <mperillo> uhm, i'm quite new to Haskell, so I can't tell what version is the best
12:17:14 <tristes_tigres> @ pl ((foldl (flip (:)) []).).(.(foldl (flip (:)) [])).drop
12:17:31 <mperillo> i'm also not sure takeR is a good name
12:17:38 <geezusfreeek> opqdonut, that way is genius
12:17:45 <rwbarton> opqdonut: nice
12:17:59 <geezusfreeek> it took me a second to figure it out though
12:18:02 <opqdonut> well it's pretty obvious
12:18:18 <opqdonut> after you think of what the function would look "hand-written"
12:18:20 <geezusfreeek> @pl \l n -> map fst $ zip l (drop n l)
12:18:20 <lambdabot> (map fst .) . liftM2 (.) zip (flip drop)
12:18:46 <opqdonut> geezusfreeek: use zipWith const
12:18:49 <opqdonut> it's nicer
12:21:43 <rwbarton> Is there a way to find out what package on Hackage provides a given module?  (besides grepping 00-index.tar)
12:22:00 <mperillo> opqdonut, thanks
12:26:35 <dolio> Try searching hayoo.
12:26:44 <sw17ch> is there a way to take a bytestring 2 bytes long and convert it to a short?
12:26:50 <sw17ch> directly? (memcpy method)
12:28:23 <mmorrow> sw17ch: you'd probably need access to the raw (Foreign)Ptr for that
12:28:23 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
12:28:42 <sw17ch> mmorrow, :(
12:29:06 <dolio> fromIntegral (index 0) .|. 8 * fromIntegral (index 1)
12:29:17 <dolio> Or maybe swap the 0 and 1, depending on how it's stored.
12:29:24 <sw17ch> is that Data.Bits?
12:29:28 <sw17ch> dolio ^^
12:29:35 <dolio> .|. is.
12:29:43 <dolio> index is a bytestring function.
12:29:47 <mmorrow> oh, i misunderstood your question
12:29:47 <sw17ch> yes
12:29:49 <sw17ch> :)
12:29:51 <mmorrow> :)
12:29:58 <sw17ch> sorry mmorrow, i didn't phrase it well
12:30:10 <sw17ch> i could swear i've seen things that do this...
12:30:17 <sw17ch> ByteString -> [Word32]
12:30:19 <sw17ch> or something similar
12:30:19 <mmorrow> ByteString also has unsafeIndex if you want to avoid a bounds check
12:30:41 <mmorrow> oh
12:30:47 <mmorrow> just use Data.Binary
12:30:56 * Peaker got no reply about the everything-should-be-overloadable idea
12:30:59 <sw17ch> oh, hey, duh
12:31:01 <sw17ch> :)
12:31:05 <dolio> Yeah, there's that, too.
12:31:23 <tristes_tigres> \leave
12:32:38 <bigtalk> whre do i talk abotu coders/decoders?
12:32:40 <Peaker> what client maps /leave to quit?
12:32:52 * sw17ch wonders if any one has written data types with binary instances for network packets
12:33:28 <Peaker> I wonder why there's no famous declarative bidirectional (parsing/building) library for Haskell..
12:36:14 <mmorrow> @msg ivanm did you ever get those docs built? doing s/--|/--/ in the initial module header comments worked for me.
12:36:14 <lambdabot> Not enough privileges
12:36:22 <mmorrow> @tell ivanm did you ever get those docs built? doing s/--|/--/ in the initial module header comments worked for me.
12:36:23 <lambdabot> Consider it noted.
12:38:30 <humasect> Peaker: show/read ?
12:38:36 <sw17ch> @index liftIO
12:38:36 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
12:38:38 <humasect> is there a binary show/read, for network ?
12:39:11 <byorgey> @seen waern
12:39:12 <lambdabot> I saw waern leaving #ghc, #haskell.se and #haskell 20h 29m 52s ago, and .
12:39:20 <Peaker> humasect: well, you have to manually write show/read for each new type. And, they aren't fully supported by all data types, and they're not efficient/binary
12:39:36 <dolio> humasect: show/read doesn't give you a framework for building parsers and printers at the same time with a single set of combinators.
12:39:55 <humasect> what about deriving, Peaker ?
12:40:06 <humasect> dolio: ah..
12:40:11 <Peaker> humasect: does deriving work for read? I thought only for show
12:40:27 <humasect> i use it for both for serializing
12:43:40 <Peaker> humasect: Oh, I just tested it. I didn't know you could derive Read automatically. Cool :)
12:44:12 <Peaker> humasect: though somewhat redundant/inefficient (shows the data constructor even when there's only one, for example)
12:44:20 <humasect> regardless of the amount of code it adds, very useful too =)
12:44:45 <mmorrow> humasect: it's mostly ffi to C-land
12:44:53 <humasect> sure, but how would it parse it, if it wasn't the same thing you would need to type in haskell to define it anyway ?
12:45:35 <dolio> read and show are supposed to produce valid haskell syntax for the type.
12:45:50 <humasect> show/read + haskell types = effectively a bulk of trivial programs
12:48:58 <Peaker> well, it would be nice if there was a different class for binary serialization
12:49:17 <Peaker> then you might want to have many instances of that class for various types
12:49:24 <Peaker> which might beget a new type-system feature :)
12:49:25 <dolio> There is. See the binary package on hackage.
12:49:46 <humasect> Peaker: couldn't one make many instances of show/read ?
12:50:06 <Peaker> humasect: on the same type? it would require newtype, I think
12:50:45 <humasect> sure. wouldn't that make sense ?
12:50:55 <Peaker> Data.Binary requires specification of both get and put :(
12:51:05 <humasect> what is the requirement for deriving show/read more than once for the same type ?
12:51:36 <dibblego> humasect, you typically newtype and have one instance per type
12:51:51 <Peaker> humasect: well, I can think of some flexibility you'd be missing out on.  Each type would be hard-coded to use a specific serializer for its contained stuff, because of the exact types it used.  You cannot use a different serializer for the whole hierarchy
12:52:12 <humasect> right, dibblego
12:53:45 <humasect> derving (Show,Read) and happily ever after, Peaker =)
12:54:26 <Peaker> if the entire hierarchy of types (by hierarchy I mean children as contained values) all had multiple instances of Show/Read, then perhaps you could choose between those instances
12:54:56 <dons> ?users
12:54:57 <lambdabot> Maximum users seen in #haskell: 516, currently: 511 (99.0%), active: 15 (2.9%)
12:55:06 <dibblego> woot!
12:55:08 <Peaker> humasect: for example:  you could have a binary Show/Read instance of Int,Double,and (),  and a textual Show/Read instance for all of them. it would be nice if you could use either serializer on a tuple containing ints and doubles
12:57:18 <humasect> Peaker: so, you can make a special facility for what is on your mind? show/read is meant to be haskell syntax, ie. it can be dumped into ghci/.hs
12:57:57 <Peaker> humasect: yeah, maybe it would have to be something other than Show/Read (indeed a serialization class that has features to avoid unnecessary paren-grouping is inappropriate for general serialization)
12:58:27 <humasect> unncessary paren grouping ?
12:58:48 <Peaker> humasect: yeah, the shows precedence stuff
12:58:51 <humasect> i am curious to see how such a thing would turn out, given it arrives at implementation stage
13:05:37 <harrison_partch> I recall that when I looked at languages a decade ago, Haskell was much slower than OCaml, and now it is not slower.
13:05:56 <humasect> it's not?
13:06:06 <dons> well, in the last decade ocaml hasn't changed, but ghc has had 10 years of optimisation and runtime and parallelism research :)
13:06:15 <dons> we've learned atlot
13:06:46 <humasect> ahh, cool
13:08:37 <Peaker> humasect: I mean something like this: http://hpaste.org/10874
13:08:43 <Peaker> (though this does not work, I am not sure if it can be made to work)
13:09:31 <rwbarton> Peaker: That's almost exactly how Data.Binary works
13:09:32 <humasect> Peaker: ah, so why not use parametric types to show/read ?
13:09:38 <humasect> or that
13:09:52 <Peaker> rwbarton: Well, this is just so I'd be able to specify how to encode/decode, rather than have just one way
13:10:03 <Peaker> rwbarton: without having to newtype the entire world :)
13:10:36 <oily_boy> ok so what is the difference between sml and haskell?
13:12:18 <Philippa_> SML is strict and impure
13:12:22 <Philippa_> and doesn't have type classes
13:12:30 <Philippa_> Haskell is non-strict, pure and doesn't have modules
13:12:31 <Peaker> I don't like Data.Binary because I would like something composable like: Codec.int `followedBy` Codec.either Codec.oneType Codec.otherType, rather than having to write get/put manually
13:12:41 <Philippa_> (non-strict is often called 'lazy')
13:12:53 <humasect> the letters haskel and sm
13:13:38 <Heffalump> Haskell has the layout rule.
13:13:40 <sjanssen> Peaker: yeah, I think theres room for a combinator library that fits over Data.Binary and generates get and put from a single specification
13:14:04 <Peaker> sjanssen: that might be good Haskell practice for me...
13:14:20 <sjanssen> Peaker: and probably useful too!
13:14:48 <sjanssen> Peaker: you might search the internet for "pickler combinators", there are a few papers on this subject
13:14:56 <qwr> Philippa_: "real modules". it has some kind of modules though ;)
13:15:43 <Peaker> the search makes me feel the problem is already solved?
13:16:04 * qwr has been forced to use ocaml modules occasionally... i'd take type classes over those modules any day ;)
13:18:49 <harrison_partch> Does anyone here know of John Reppy? What do you think of his Manticore project for heterogenous multicore ML?
13:19:52 <harrison_partch> Prof. Reppy told me that OCaml's object system is "broken"
13:20:15 <harrison_partch> I think he doesn't like OCaml.
13:20:24 <Kerris4> harrison_partch: this is why we have F# :V
13:21:20 <Peaker> sjanssen: if there are tons of pickler combinators already, how come none of them became prominent and replaced Data.Binary?
13:21:33 <harrison_partch> I was looking at F# just last week! But it is such a hassle on Linux. So I looked again at Haskell. Which I think I will use now.
13:22:00 <mapreduce> harrison_partch: Apparently F# works on mono, but I haven't looked properly.
13:22:05 <Peaker> also, how can one write a pickler combinator that creates an instance of Data.Binary for you? is it possible to automate the creation of instances at all?
13:22:16 <harrison_partch> But, Kerris4, I don't quite get the point of your remark .. there is prob. a joke there.
13:22:46 <harrison_partch> Oh, yes, F# does work on mono, but there are hassles.
13:22:54 <Kerris4> harrison_partch: I'm uncertain if 1) OCaml's object system *is* broken 2)F# is necessarily an improvement over OCaml
13:23:08 <harrison_partch> Well, it doesn't matter.
13:23:22 <dolio> But it's got OMG concurrent garbage collection!
13:23:27 <mapreduce> F# is more of a version of OCaml than an improvement afaik.
13:24:29 <sjanssen> Peaker: I don't think there are any actually written, there are just papers about how to do it
13:24:50 <sjanssen> Peaker: also, the papers I've seen deal with Strings directly rather than the Get/Put Monads
13:25:02 <Vq^> harrison_partch: did he say what the supposed problem with ocamls object system was?
13:25:31 <sjanssen> Peaker: you can generate instances with Template Haskell, or you can just something like "instance Binary Foo  where get = getFromSpec foospec; put = getFromSpec putspec"
13:26:16 <Peaker> sjanssen: Both of these solutions seem hacky :)
13:26:30 <sjanssen> Peaker: why?
13:26:53 <sjanssen> the TH will look like $(makeBinaryFromSpec foospec)"
13:27:05 <sjanssen> Peaker: oh, and I meant "foospec" at the end, not "putspec"
13:27:16 <Peaker> IMO: dealing with AST's when syntax isn't the problem is hacky, and forcing the user to declare boilerplate instances of Binary is not very nice
13:27:30 <Peaker> yeah, I also thought of the manual adapters there too
13:27:56 <Peaker> why would people write papers about how to write pickler combinators, instead of writing a combinator? It doesn't sound that complicated...
13:27:58 <sjanssen> Peaker: instance Binary Foo where (get, put) = mkBinary spec -- might work, but I'm not 100% certain
13:28:33 <sjanssen> Peaker: people didn't generally write and distribute their Haskell code until fairly recently
13:28:37 <Peaker> me and I think at least 3 of my friends wrote a pickler combinator in Python :)
13:29:13 <sjanssen> oh, then I'm sure you're capable of doing it in Haskell
13:29:54 <Peaker> sjanssen: "Pattern bindings (except simple variables) not allowed in instance declarations"
13:30:09 <sjanssen> Peaker: thought that was a long shot
13:30:43 <sjanssen> Peaker: I don't understand your complaint against the TH, it seems like a very natural solution
13:31:00 <Peaker> sjanssen: I haven't used TH yet.. It smells of lisp macros :)
13:32:08 <sjanssen> the boiler plate instance also doesn't seem onerous, IMO
13:32:41 <Peaker> why use Binary at all? Why not have the pickler combinator do everything?
13:33:02 <harrison_partch> Vq^: No, it was a brief mention. He didn't say exactly but I am sure he has said more about it somewhere.
13:33:17 <dolio> Because Binary already has extensive work done producing efficent bytestring-creating code.
13:33:51 <Peaker> then why not adapt it the other way around: Have pickler combinator primitives use Binary get/put internally, rather than the other way around?
13:34:16 <Vq^> harrison_partch: ok
13:35:00 <oily_boy> so sml has imperative stuff too
13:35:02 <oily_boy> hm
13:35:11 <oily_boy> smlserver seems cool dynamic web module
13:35:20 <oily_boy> anyone playing with happs?
13:35:23 <dons> Peaker: yeah, because binary gets gigabyte throughput, and there is no pickler lib. :)
13:35:26 <sjanssen> Peaker: you don't have to use the Binary class at all
13:35:46 <sjanssen> Peaker: you can just use the Put/Get Monads if you'd like
13:36:15 <Peaker> sjanssen: I'll have to use the efficient instances of the basic types, though wouldn't I?
13:36:22 <Peaker> sjanssen: to have access to their get/put implementations..
13:36:50 <sjanssen> Peaker: just the really primitive types -- Int*, Word*, and Char should be about it
13:37:25 <sjanssen> Peaker: and all the Int and Word putters and getters are available as separate functions
13:37:50 <Peaker> ok.. I'll go toy with it
13:39:32 <gbacon> ?src groupBy
13:39:33 <lambdabot> groupBy _  []       =  []
13:39:33 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
13:39:33 <lambdabot>     where (ys,zs) = span (eq x) xs
13:40:11 <gbacon> > groupBy (\(a,b) -> fst a == snd b) [(1,2),(3,4),(1,2)]
13:40:12 <lambdabot>   Couldn't match expected type `((b1, b), (a, b1)) -> Bool'
13:40:21 <gbacon> > groupBy (\a b -> fst a == snd b) [(1,2),(3,4),(1,2)]
13:40:23 <lambdabot>   [[(1,2)],[(3,4)],[(1,2)]]
13:40:28 <gbacon> > groupBy (\a b -> fst a == snd b) [(1,2),(1,2),(1,2)]
13:40:29 <lambdabot>   [[(1,2)],[(1,2)],[(1,2)]]
13:40:53 <gbacon> > groupBy (\a b -> fst a == fst a && snd a == snd b) [(1,2),(1,2),(1,2)]
13:40:54 <lambdabot>   [[(1,2),(1,2),(1,2)]]
13:40:58 <gbacon> > groupBy (\a b -> fst a == fst a && snd a == snd b) [(1,2),(3,4),(1,2)]
13:41:00 <lambdabot>   [[(1,2)],[(3,4)],[(1,2)]]
13:44:17 <dmwit> I don't understand.
13:44:29 <dmwit> Every time I try to do something to make this animation smoother, it gets worse.
13:44:44 <mauke> try to make it choppier
13:47:37 <Peaker> the Get monad is just the State monad carrying the ByteString, so why is it reimplementing State instead of re-using State's code?
13:48:03 <Heffalump> lack of certainty over mtl's inlining?
13:49:52 <Peaker> why not fix State's code to be inlined properly then?
13:50:08 <dons> Peaker: its ContT actually :)
13:50:11 <Peaker> copy&pasted code gives me a bad taste in my mouth. Or maybe its just those cookies I ate too many of :)
13:50:51 <Peaker> dons: I didn't see instances of MonadTrans
13:51:16 <Heffalump> well, most monads are fairly trivial to implement
13:51:16 <dons> http://www.cse.unsw.edu.au/~dons/images/hac07/contT.png
13:51:20 <dons> was where it was described..
13:51:40 <Heffalump> there's a balance to be struck between code reuse and excessive abstraction
13:51:44 <Peaker> dons: the comment says Get is a State monad
13:52:03 <dons> ContT [ByteString] (STateT Buffer IO) a
13:52:36 <dons> what's the question though?
13:52:46 <dons> why does it not depend on mtl, but instead define its own Monad?
13:52:54 <Peaker> dons: yeah
13:53:22 <dons> performance, likely due to cross-package inlining, and data structure specialisation
13:54:05 <Peaker> sounds like a great opportunity to polish them optimizers and automatic specializers :)
13:54:23 <Peaker> cross-package inlining is not supported in ghc?
13:57:22 <Peaker> package/module boundaries are arbitrary. Useful for code maintenance, but probably not always the best place to put optimization locality barriers.
13:57:38 <bos> hi sioraiocht, thanks for being patient with my pesterings.
13:57:51 <sjanssen> Peaker: it does
13:59:07 <sjanssen> Peaker: probably the biggest issue is the data specialization and instance specialization that dons mentions
13:59:21 <sjanssen> Monad transformers add lots of overhead
13:59:50 <mofmog> wait
13:59:50 <Peaker> is code duplication the answer?  Is there truly a tradeoff between sane maintainable code, and good-performance?
13:59:57 <bigtalk> so as i asked yesterday, i am doing project euler exercises in haskell. i am summing all the even fibonaccis numbers bet ween 0 and 4million
14:00:03 <bigtalk> is that impossible?
14:00:07 <dmwit> Sure.
14:00:09 <mofmog> a monad just defines interfaces between functions and provices a method for joining them together in a specified manner
14:00:12 <sbahra> No, it isn't bigtalk.
14:00:12 <bigtalk> because of the size of the numvers
14:00:15 <sjanssen> Peaker: of course there's a trade off
14:00:17 <sbahra> It's easy to do.
14:00:18 <dmwit> mofmog: Exactly!
14:00:24 <mofmog> I CANT BELIEVE ITS THAT SIMPLE
14:00:34 <dmwit> =D
14:00:35 <rwbarton> @faq can haskell sum all the even fibonaccis numbers bet ween 0 and 4million
14:00:36 <lambdabot> The answer is: Yes! Haskell can do that.
14:00:39 <sbahra> bigtalk, if you want to do it quickly learn about the golden ratio though and you might want to look at the Decimal module in hackage.
14:00:45 <Peaker> sjanssen: I think all of the ugliness can be put as a special-case optimization into the compiler, at the worst case :)
14:00:47 <bigtalk> evenfibsum = sum $ filter (\x -> mod x 2 == 0) $ map fib [1..4000000]
14:01:00 <bigtalk> where fib is a tailrec fibonacci-implementation
14:01:05 <sjanssen> Peaker: and then the compiler becomes unmaintainable :)
14:01:06 <bigtalk> never finsihes
14:01:08 <mofmog> so what's a comonad then
14:01:17 <Peaker> sjanssen: yeah, but only dons and spj see that? :)
14:01:32 <sbahra> bigtalk, it will take a long long time depending on how you have implemented it :-)
14:01:42 <rwbarton> bigtalk: it says fibonacci numbers less than or equal to 4 million, not the first 4 million fibonacci numbers
14:01:42 <sjanssen> Peaker: of course the best thing would be a sufficiently smart compiler, but they wanted to write Data.Binary now
14:01:54 <lightstep> ?type even
14:01:55 <lambdabot> forall a. (Integral a) => a -> Bool
14:02:12 <sbahra> bigtalk, for example, fib n is defined by n - 1, n - 2 which is in turn defined by n - 3 n - 4, etc...imagine recalculating every single time.
14:02:17 <sjanssen> Peaker: though there was a paper submitted to the Haskell Symposium about pluggable monads, which I think might be a solution to this issue
14:02:29 <Peaker> pluggable monads? What's that?
14:02:42 <sbahra> bigtalk, look at the Fibonacci sequence entry on Wikipedia, and look how you can use the golden ratio to calculate arbitrary term.
14:02:49 <sbahra> O(1).
14:03:03 <mauke> sbahra: not really
14:03:06 <sjanssen> Peaker: a little declarative language that says something like "this monad should support State and Continuations", and it will generate the data type for you
14:03:13 <sbahra> bigtalk, also, google "dons tail recursion"
14:03:15 <mauke> you have to calculate with more precision
14:03:16 <sbahra> mauke, not really what?
14:03:21 <Peaker> sjanssen: abstraction over transformers?
14:03:30 <dmwit> sbahra: Not O(1).
14:03:45 <sjanssen> Peaker: I'd say abstraction similar to transformers
14:03:46 <dmwit> sbahra: It's O(log n) or something like that, because you have to do (^n) as a sub-calculation.
14:03:56 <bigtalk> sbaura: i know, read what i wrote, i am using atailrecursive verison, im no noob. im not using the standard exponential
14:03:58 <mauke> any solution that contains 'map fib' is already wrong
14:04:04 <mauke> just make a list of all fibonacci numbers
14:04:05 <bigtalk> fibo a b n = a `seq` b `seq` n `seq` fibo (a+b) a (n-1)
14:04:07 <Peaker> sjanssen: meant to do what transformers do, but with great optimization?
14:04:11 <sbahra> dmwit, I forget the formula, let me look at it again
14:04:17 <lightstep> you can also use the fibonacci stream, and takeWhile
14:04:20 <bigtalk> just wonderin if fib of 1000000 is so great
14:04:24 <sjanssen> Peaker: possibly, though I don't think optimization is their main goal
14:04:29 <bigtalk> it cant be used effectively
14:04:29 <rwbarton> sbahra: It's only O(1) if you have very strange ideas about what a single operation is.
14:04:30 <sbahra> dmwit, this is still "constant" though on x86*, maybe not in haskell
14:04:37 <dmwit> sbahra: No.
14:04:38 <bigtalk> but correct, i could use the golden mean but that si not exact
14:04:45 <mauke> > let fib = 0 : 1 : zipWith (+) fib (tail fib) in fib !! 1000000
14:04:47 <lambdabot>   * Exception: stack overflow
14:04:51 <mauke> heh
14:05:03 <Peaker> sbahra: the fibonacci series grows very fast out of the size that fits into an x86 register
14:05:04 <dmwit> sbahra: Unless you restrict yourself to Int.  But that's not very interesting.
14:05:11 <sjanssen> Peaker: I think the main idea behind the concept is to make it easier to define monad stacks
14:05:16 <lightstep> > let fib = 0 : 1 : zipWith (+) fib (tail fib) in sum $ filter even $ takeWhile (< 4000000) fibs
14:05:17 <lambdabot>   Not in scope: `fibs'
14:05:21 <rwbarton> bigtalk: fib 1000000 will have about 100000 digits.  But it's not relevant.  Read the problem again
14:05:22 <lightstep> > let fib = 0 : 1 : zipWith (+) fib (tail fib) in sum $ filter even $ takeWhile (< 4000000) fib
14:05:23 <lambdabot>   4613732
14:05:35 <Peaker> sjanssen: Monad Transformers have problems, could be nice to have an alternate solution. Is the idea to use a language extension?
14:05:43 <sbahra> Peaker, yes.
14:05:49 <bigtalk> rwbarton read the porblem?
14:05:50 <sjanssen> Peaker: I think its implemented as a pre-processor
14:05:56 <sjanssen> Peaker: though I'm sure TH could be used as well
14:06:03 <sbahra> Of course, once we *require* variable precision then it will not be O(1).
14:06:10 <Peaker> sjanssen: I thought TH was a preprocessor itself?
14:06:20 <sbahra> But atleast with 64-bits on x86*, it is a constant number of operations.
14:06:25 <rwbarton> sbahra: So is a lookup table
14:06:26 <Peaker> sbahra: its O(1) for inputs smaller than X is cheating :)
14:06:36 <sbahra> Peaker, shhh ;-p
14:06:37 <sjanssen> Peaker: a particularly nice preprocessor, yes
14:06:55 <dons> time for Peaker to write some code! :)
14:07:03 <rwbarton> Peaker: It's built in to ghc, you just write {-# LANGUAGE TemplateHaskell #-} at the top of your .hs file
14:07:23 <sbahra> @src (^)
14:07:23 <lambdabot> x ^ 0            =  1
14:07:24 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
14:07:25 <lambdabot>   where f _ 0 y = y
14:07:27 <lambdabot>         f x n y = g x n
14:07:29 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
14:07:31 <lambdabot>                       | otherwise = f x (n-1) (x*y)
14:07:33 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
14:07:58 <bigtalk> oh wait, im not supposed to use fib(4000000) but only fib(x) < 4000000
14:08:15 <sjanssen> dons: is there a collection of links to all the Haskell Symposium papers?
14:08:16 <dblazakis> i've noticed that the exponentiation function are discussed every day on #haskell; i wonder if that means anything...
14:10:10 <dons> sjanssen: not yet
14:10:17 <dons> the logical place to add those links would be to the video page
14:10:18 * sjanssen notes there is no link to the Haskell Symposium from haskell.org front page
14:10:27 <dons> there is to the videos
14:10:56 <dblazakis> @go Making Monads First-class with Template Haskell
14:10:59 <lambdabot> Plugin `search' failed with: No Location header found in 3xx response.
14:11:08 <sjanssen> dons: I don't remember if I've asked this before, but is a list of companies using Haskell really the best thing for the front page?
14:11:22 <bigtalk> but lets say i wanted to compute fibonacci(1000000) and not use the golden mean/approximation, is that possible on normal, modern laptop or the number is to big?
14:11:23 <dons> it might be a little knee-jerk :)
14:11:25 <dblazakis> http://www.haskell.org/haskell-symposium/2008/accepted.html
14:11:26 <lambdabot> Title: ACM SIGPLAN 2008 Haskell Symposium Accepted Papers
14:11:29 <dons> sjanssen: suggestions welcome.
14:11:42 <aprocter> Here's the monad preprocessor paper if anyone's interested: http://monadgarden.cs.missouri.edu/wiki/images/b/bc/haskell08.pdf
14:11:44 <lambdabot> Title: cache:http://monadgarden.cs.missouri.edu/wiki/images/b/bc/haskell08.pdf - Google ...
14:11:48 <sjanssen> dons: the Headlines section (including those videos) are "below the fold" in my 1280x1024 window
14:11:50 <dons> sjanssen: at least, it should be in a side  bar
14:11:57 <dons> like on python.org
14:12:34 <sbahra> bigtalk, it is possible, but you should use tail recursion (which you aren't.).
14:12:41 <aprocter> It's called MonadLab -- available for dl, but I still need to tidy a couple things up before we put it in Hackage tho  :)
14:12:44 <bigtalk> sbahra, ye si am
14:13:06 <bigtalk> http://hpaste.org/10875
14:13:08 <sbahra> "sum $ filter (\x -> mod x 2 == 0) $ map fib [1..4000000]"
14:13:14 <mauke> > let f n a b | n <= 0 = a | otherwise = a `seq` f (n - 1) b (a + b) in f 1000000 0 1
14:13:17 <sbahra> Anyways, I don't think you want my help anyways :-)
14:13:26 <dibblego> sbahra, \x -> mod x 2 == 0 is equivalent to even
14:13:27 <sjanssen> aprocter: thanks
14:13:29 <lambdabot>   thread killed
14:13:31 <bigtalk> yes i do :)
14:13:44 <sbahra> dibblego, that isn't my code
14:13:48 <sjanssen> aprocter: mind if I link to that from the symposium videos page?
14:13:51 <bigtalk>  u mena im using map or soemthing else(filter9 that isnt tailrec? because fib itslef is tailrec
14:14:02 <bigtalk> and calling fib(1000000) never finishes
14:14:02 <aprocter> sjanssen: not at all
14:14:43 <lightstep> bigtalk, you can't use the recursive algorithm for computing this number, on any language, even with all the computing power in the world
14:14:45 <dons> aprocter: how about using monadLib :)
14:15:18 <aprocter> dons: hrm don't know much about it actually  :)
14:15:19 <sjanssen> aprocter: ah yes, and it is implemented using TH.  I need to re-read your paper
14:15:59 <mauke> bigtalk: I just did it
14:16:04 <mauke> in ghci, no less
14:16:20 <bigtalk> lightstep: dude you cant use the exponential tree-recursive way, u can use the tailrecursive implementation i use
14:16:22 <aprocter> sjanssen: Yeah, the preprocessor is just kind of a thin little thing -- it generates the decls using TH, then pretty-prints them into a module  :)
14:16:30 <pjdelport> bigtalk: fib(1000000) should only take a minute or two
14:16:41 <mauke> here's the code I used:
14:16:42 <sbahra> lightstep, you can.
14:16:43 <mauke> let f n a b | n `mod` 10000 == 0 && trace (show n) False = undefined | n <= 0 = a | otherwise = a `seq` f (n - 1) b (a + b) in f 1000000 0 1
14:16:49 <sbahra> But golden ratio is much much faster.
14:17:00 <bigtalk> sbahra: yes but not exact right?
14:17:12 <mauke> arbitrary precision FP code? I don't think that's going to be fast
14:17:20 <sjanssen> aprocter: so the preprocessor is mostly used to get pretty syntax, rather than $() and such?
14:17:21 <dmwit> I don't know why you keep saying the golden ratio will be faster.
14:17:30 <sbahra> mauke, I already solved that problem he was talking about :-)
14:17:31 <aprocter> sjanssen: right
14:17:41 <sbahra> It solved it "instantly".
14:17:47 <aprocter> sjanssen: We also use it to dance around a little issue with mutual recursion
14:17:51 <sbahra> Atleast for 4,000,000 the level of precision necessary is not so much.
14:17:52 <mauke> sbahra: what, computing fib(1000000)?
14:17:58 <dmwit> Now, a matrix exponentiation... that I could believe would be faster.
14:18:04 <sbahra> fib(1) ... fib(4000000)
14:19:14 <aprocter> sjanssen: Like you can't say $(mkMonad "M" [...something involving M...]) because at splice-time the decl hasn't been, er, spliced in yet
14:19:19 <lightstep> dmwit, the golden ratio is actually fast matrix exp - the eigenvalues of the matrix are phi and 1/phi
14:19:37 <dmwit> lightstep: Right, but with Reals instead of Ints/Integers.
14:19:39 <aprocter> sjanssen: But if we just pprint the decls and let ghc resolve it later, it works out  :)
14:21:25 <dblazakis> aprocter: that paper looks pretty interesting, it may force me over the edge to learn TH -- thanks
14:21:27 <dmwit> The matrix multiply method is also instantaneous.
14:21:45 <dmwit> (Whereas the usual infinite fibs list trick is not.)
14:22:09 <aprocter> dblazakis: thanks -- always glad for any feedback!
14:24:55 <awarring> i just realized something today
14:25:45 <awarring> IO monad is unsafe because anything can execute in a computation that is in the IO monad
14:26:02 <awarring> other monads are safer because they better define the side effects they could do
14:26:11 <awarring> is this true?
14:26:26 <dons> right.
14:26:27 <seliopou> it's the sin bin
14:26:29 <mauke> some monads wrap IO
14:26:34 <dons> IO is the "cigarettes and whisky" of monads
14:26:39 <awarring> haha
14:26:39 <mauke> :t liftIO
14:26:41 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
14:27:13 <awarring> mauke: tho their types would be a giveaway that they are also in the "cigarettes and whisky" realm
14:27:21 <awarring> but good point
14:27:35 <awarring> i'll keep on the lookout for those
14:27:38 <awarring> hehe
14:27:58 <dmwit> instance MonadIO Id where liftIO = unsafePerformIO
14:28:08 <Heffalump> that's evil
14:28:14 <awarring> dons: you post a lot in reddit programming...i'm a lurker there hehe
14:30:46 <mapreduce> A quiet page-refresher.
14:30:51 <mauke> :t mfix
14:30:52 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
14:31:16 <shapr> yarr
14:31:49 <mauke> @pl handleOnce r h = mfix $ \d -> handle r (\e -> d >> h e)
14:31:49 <lambdabot> handleOnce = (mfix .) . (. flip ((.) . (>>))) . (.) . handle
14:32:01 <mauke> @pl mfix $ \d -> handle r (\e -> d >> h e)
14:32:02 <lambdabot> mfix (handle r . (. h) . (>>))
14:32:14 <skorpan> when trying to configure the darcs yi, i get this warning, which i can't figure out: http://pastebin.com/m57f65f6b
14:33:54 <mauke> sounds like you should upgrade utf8-string
14:34:36 <dons> ?users
14:34:37 <lambdabot> Maximum users seen in #haskell: 516, currently: 511 (99.0%), active: 23 (4.5%)
14:35:23 <skorpan> mauke: but i have the latest version
14:35:58 <mauke> then recompile it against bytestring-0.9.1.2
14:36:07 <rwbarton> try  cabal upgrade utf8-string  (not  cabal install utf8-string)
14:36:30 <skorpan> yup, worked
14:36:37 <skorpan> i get another warning now though :)
14:37:28 <dcoutts> rwbarton: why upgrade?
14:37:50 <dcoutts> utf8-string doesn't depend on anything else you'd be able to upgrade, so I think it'd be the same in that example
14:37:58 <Peaker> why does deriving Enum refuse to work on non-nullary constructors?
14:38:03 <skorpan> yay, it compiled even though i got the same warning but for parsec this time
14:38:13 <Peaker> could be useful to just tag the data constructor as an integer
14:39:37 <Peaker> The pickler combinator paper has this in it: "... where tag (Var _) = 0 ; tag (Lam _) =  1 ; tag (App _) = 2"
14:39:50 <Peaker> this is just repeating the constructors enumeration :(
14:40:03 <mauke> so what is toEnum 1?
14:40:25 <Peaker> mauke: oh :)  I guess I want a different class then
14:40:55 <rwbarton> Peaker: you could use Data.Derive.Enum (the answer to mauke's question there is Lam undefined)
14:41:11 <rwbarton> Peaker: there's also a ghc primitive unsafeSomething
14:41:40 <mauke> unsafeSomething likeWhatever >> dude
14:42:12 <bigtalk> fibg n = 1 / (sqrt 5) * g^n + 0.5 where g = (1 + sqrt 5) / 2.0
14:42:18 <bigtalk> *Main> fibg 1000000
14:42:18 <bigtalk> Infinity
14:42:30 <skorpan> i can't figure out how to *run* yi :|
14:42:34 <bigtalk> sbahra ^^
14:42:47 * Peaker cabal installs derive
14:42:57 <mmorrow> skorpan: you need to install a frontend still?
14:43:01 <dmwit> skorpan: How did you install it?
14:43:07 <skorpan> i installed yi only
14:43:10 <mmorrow> like yi-vty or yi-gtk
14:43:14 <skorpan> mmorrow: okay
14:43:20 <rwbarton> mmorrow: what's the ghc primitive to get the tag number of an algebraic data type value?
14:43:26 <skorpan> according to the website, that's for older versions of yi
14:43:35 <dmwit> skorpan: cabal-install?
14:43:36 <mmorrow> let tag a = I# (dataToTag# a)
14:43:48 <mmorrow> dataToTag# is in GHC.Prim
14:43:50 <skorpan> dmwit: cabal-install what?
14:43:50 <Peaker> hmm, how do I use Data.Derive.Enum?
14:43:54 <rwbarton> , dataToTag# Nothing
14:43:58 <lunabot>  luna: Not in scope: `dataToTag'
14:43:58 <lunabot>  Not in scope: `#'
14:44:00 <dmwit> skorpan: How did you install yi?  Via cabal-install?
14:44:12 <skorpan> dmwit: via the arch linux package manager
14:44:18 <skorpan> no wait, wtf
14:44:19 <skorpan> i didn't
14:44:28 <skorpan> i installed it through darcs and manually doing runghc Setup.hs
14:44:30 <mmorrow> (there's also a tagToData# (which unlike dataToTag# can segfault you for obvious reasone))
14:44:31 <Peaker> I imported Data.Derive.Enum, but it still can't auto-derive Enum for non-nullary constructors
14:44:49 <mmorrow> rwbarton: i'l add tag now
14:45:10 <dmwit> skorpan: Maybe rerun the install step and see where it puts files? ;-)
14:45:11 <rwbarton> Peaker: Right, see the documentation for Data.Derive (probably on the main module page)
14:45:32 <skorpan> dmwit: it doesn't seem to put any files anywhere, but just registers itself as a cabal package
14:45:41 <Peaker> rwbarton: http://hackage.haskell.org/packages/archive/derive/0.1.1/doc/html/Data-Derive-Enum.html isn't helpful
14:45:43 <lambdabot> Title: Data.Derive.Enum, http://tinyurl.com/43x738
14:45:49 <skorpan> Installing: /usr/local/lib/yi-0.5.0.1/ghc-6.8.2
14:45:49 <skorpan> Registering yi-0.5.0.1...
14:45:49 <mmorrow> i'll add that "src" function too in this rebuild as well
14:47:14 <rwbarton> Peaker: Turn on template haskell and write   $(derive makeEnum ''Maybe)    (s/Maybe/your type/)
14:47:27 <rwbarton> Peaker: Or use GHC.Prim.dataToTag#
14:47:51 <Peaker> rwbarton: thanks
14:49:06 <sbahra> bigtalk, ?
14:49:28 <Peaker> rwbarton: dataToTag# uses Int# (which has kind #) how do I get an Int or anything of kind * from that?
14:49:33 <mmorrow> btw, here's the top level def of that eval function
14:49:36 <mmorrow> eval = unsafePerformIO mkEvalUnsafe
14:49:38 <mmorrow> hehe
14:49:57 <mmorrow> , eval "eval \"eval\""
14:50:03 <lunabot>  <<Dynamic>>
14:50:13 <sbahra> bigtalk, that's wrong.
14:50:17 <rwbarton> Peaker: Using I#, but I don't remember where that's defined.
14:50:19 <mauke> @src Int
14:50:19 <lambdabot> data Int = I# Int#
14:50:26 <mauke> @index Int
14:50:26 <lambdabot> Data.Int, Foreign, Prelude, GHC.Exts, Graphics.Rendering.OpenGL.GL.VertexArrays, Graphics.Rendering.OpenGL.GL, Graphics.Rendering.OpenGL, Graphics.UI.GLUT, Text.Read.Lex, Text.Read
14:50:28 <mmorrow> oh yeh, GHC.Exts to get I#
14:50:35 <rwbarton> Prelude> :i Int
14:50:35 <rwbarton> data Int = GHC.Base.I# GHC.Prim.Int# 	-- Defined in GHC.Base
14:50:49 <sbahra> @src Integer
14:50:49 <lambdabot> data Integer = S# Int#
14:50:50 <lambdabot>              | J# Int# ByteArray#
14:50:59 <mmorrow> (GHC.Exts reexports it for you)
14:51:37 <shapr> Hey, is there any sort of Language.SQL?
14:51:39 <Peaker> Thanks
14:51:46 <mauke> what does S# stand for?
14:51:48 <rwbarton> Peaker: (you also need -XMagicHash)
14:51:51 <dmwit> skorpan: Anything in dist/_build?
14:51:53 <rwbarton> Small?
14:52:07 <mauke> and J#?
14:52:23 <lament> Java?
14:52:25 <Peaker> rwbarton: I use {-# OPTIONS -fglasgow-exts #-}
14:52:38 <Peaker> rwbarton: funny how $ and stuff fail because of the # kind involved
14:52:41 <skorpan> dmwit: just a bunch of *.hi and *.o files
14:52:45 <Peaker> rwbarton: I need to apply directly
14:52:47 <dmwit> huh
14:52:50 <rwbarton> Peaker: heh
14:52:54 <lament> maybe Single and Joined?
14:53:00 <lament> er, Simple
14:53:05 <lament> and Joint
14:53:47 <rwbarton> skorpan: did you check ~/.cabal/bin/ ?
14:54:21 <shapr> Maybe I could rip some code out of HaskellDB to parse SQL?
14:54:33 <skorpan> rwbarton: i don't have such a folder
14:54:46 <skorpan> i have ~/.cabal, but not ~/.cabal/bin/
14:54:55 <rwbarton> Prelude GHC.Base GHC.Prim GHC.Exts> (I# (dataToTag# 0), I# (dataToTag# (100^100 - 100^100)))
14:54:59 <rwbarton> (0,1)
14:55:35 <shapr> dcoutts: Can I associate cabal with .cabal files in my browser so I can click on things directly?
14:55:37 <hugo_> monday is the nobel prize awards
14:55:38 <Heffalump> shapr: why would HaskellDB parse SQL?
14:55:59 <mmorrow> Peaker: this is a handy wrapper for dataToTag#
14:56:00 <shapr> Heffalump: It's likely it could help me with an AST at least.
14:56:00 <dcoutts> shapr: I'm not sure what you'd have happen exactly
14:56:09 <mmorrow> tag a = I# (dataToTag# a)
14:56:26 <hugo_> anyone wants to buy me a ticket to norway on monday ? :D
14:56:36 <Heffalump> a Language.SQL would be nice
14:56:42 <shapr> dcoutts: See someone's darcs repo with a .cabal file, click on the file, have it suck down the package and build/install.
14:56:42 <Heffalump> I have an AST of my own kicking around.
14:56:48 <mmorrow> Heffalump: i have a partially complete one
14:56:49 <Heffalump> but it's typed
14:57:08 <mmorrow> with select stmt parsing so far
14:57:21 <Kerris4> hugo_: what's going on there
14:57:25 <mmorrow> (with alex+happy) but i need to rewrite it
14:57:31 <shapr> For administrivia reasons, my job wants me to write stored procedures instead of any SQL to access this database... and there are many, and the schema is changing often. So I just want to generate them.
14:57:49 <shapr> Thus I call upon the POWER OF HASKELL!
14:57:55 <Peaker> mmorrow: I wrote that wrapper too, immediately after noting $ cannot be used, yeah :)
14:57:56 <eyu100> > sum [1, 2]
14:57:58 <lambdabot>   3
14:58:05 <mmorrow> Peaker: nice
14:58:06 <shapr> Or at least, a SQL AST.
14:58:09 * Heffalump is planning on making squiggle generate stored procedures as well as SQL.
14:58:11 <shapr> mmorrow: Where's your code? Is it licensed?
14:58:18 <shapr> Heffalump: License accessible code?
14:58:30 <dcoutts> shapr: that'd be pretty hard, the .cabal file would have to reference the right repo and you'd need to teach cabal-install how to get darcs repo
14:58:31 <eyu100> > (\x -> foldl1 (+) x) [1, 2]
14:58:33 <lambdabot>   3
14:58:52 <mmorrow> shapr: the ast part is what i have to finish. it only has a rep of select stmts at this point
14:58:56 <Heffalump> I haven't got round to making a licence for it, but you can consider it BSD3.
14:59:17 <Heffalump> http://code.haskell.org/squiggle/unstable - see PrimQuery in src/Database/Squiggle/Types.hs for the AST
14:59:18 <lambdabot> Title: Index of /squiggle/unstable
14:59:19 <shapr> dcoutts: The nokia N800 handles that, it uses short simple text files to add new apt sources and then install the package.
14:59:26 <shapr> Heffalump: Yay, thanks!
14:59:34 <mmorrow> shapr: err, what exactly are you looking to do? /generate/ stored procs? where does the parsing come in?
14:59:49 <shapr> mmorrow: Nowhere really, but in for a shilling...
14:59:57 <mmorrow> Heffalump: i've looked at squiggle, very interesting.
14:59:58 <lightstep> mmorrow, does this mean that code using GHC.Exts doesn't obey tje parametericity condition?
15:00:00 <mmorrow> shapr: heh
15:00:14 <shapr> I'm starting to introduce "weird" (read as non-microsoft) tools to my workplace, so why not whip up some Haskell tools?
15:00:17 <dcoutts> shapr: though that's for packaged software, not just a darcs repo
15:00:17 <Heffalump> it's quite a way off being done :-)
15:00:26 <dcoutts> shapr: I did just add the ability to specify repos in .cabal files
15:00:32 <mmorrow> lightstep: could you state that condition to refresh my memory?
15:00:51 <lightstep> for example, a function of type (forall a. a -> Int) is constant
15:00:52 <shapr> dcoutts: Hackage sources? or actual darcs repos?
15:00:53 <mmorrow> shapr: good show
15:01:06 <dcoutts> shapr: darcs (and other) repos
15:01:08 <lightstep> and all the other stuff from Theorems for Free
15:01:14 <bos> dcoutts: oh, nice change, thanks.
15:01:47 <dcoutts> bos: actually I'd appreciate a quick review of that, to make sure the info is sufficient to use for automatic tools
15:01:56 <bos> in HEAD?
15:01:57 <shapr> mmorrow: Best option would be to suck out the database tables, and thene generate sprocs.
15:02:05 <dcoutts> bos: a good overview is in the user guide, in head
15:02:35 <bos> dcoutts: ok
15:02:39 <rwbarton> lightstep: It also doesn't have to satisfy properties like   x,y :: Integer, f :: Integer -> Int, x == y ==> f x == f y
15:02:49 <rwbarton> (where == is the Eq method)
15:02:54 <mmorrow> dcoutts: i made a quick cgi prog yesterday which takes as args two lists (only incl is req), incl=pkgname,pkgnae excl=pkgname,.., then gives pack a png of the dep-subgraph of hackage of all packages mentioning the includes with the excludes excluded
15:03:04 <shapr> Oh I had an amusing thought today...
15:03:30 <shapr> Isn't it some sort of cosmological decision whether CalendarTime should be an instance of Bounded?
15:03:34 * shapr snickers
15:03:52 <dcoutts> mmorrow: nice, just tracking build-depends ?
15:04:12 <dcoutts> mmorrow: that'd be a nice service to hook up to the new hackage server
15:04:51 <dcoutts> mmorrow: the architecture for that calls for lots of specialised clients doing cool stuff, downloading and uploading results. While the server is relatively dumb, just a information server.
15:05:00 <mmorrow> here's the link and a sample query (no ui at the moment)
15:05:02 <mmorrow> http://moonpatio.com:8080/cgi-bin/hackgraphs.cgi?incl=monadLib,HaXml&excl=panda,Barracuda,HAppS-Server,HAppS-State,HAppS-Data
15:05:04 <lambdabot> http://tinyurl.com/3fybl6
15:05:24 <mmorrow> here's a simple one http://moonpatio.com:8080/cgi-bin/hackgraphs.cgi?incl=Cabal
15:05:31 <bos> dcoutts: that's nice, and well written up. i suppose the next logical step, though, would be to provide a command line tool to pull selected info out of a cabal file.
15:05:43 <hugo_> Kerris4: nobel prize awards
15:05:55 <dcoutts> bos: oh a simple command line parser thing
15:06:09 <dcoutts> bos: like ghc-pkg describe / ghc-pkg field
15:06:27 <mmorrow> dcoutts: yeah, build-depends. i got the tarball of all the .cabal files from hackage, then parsed them all and constructed a huge graph which this cgi prog queries, generates .dot, calls graphviz
15:06:31 <bigtalk> sbahra: what is wrong? it gives the right answer for fib(12)a nd 13
15:06:39 <bigtalk> or almsotit gives 144.5 instead of 144
15:06:40 <bos> dcoutts: yes, as in "cabal-parser get source-repository.head.type"
15:06:58 <bos> dcoutts: or (less ideal) a conversion to JSON or XML
15:07:04 <dcoutts> mmorrow: I really need to make that code in cabal-install more easily accessible, the stuff that loads the hackage index into a nice internal format
15:07:42 <dcoutts> bos: right, though sometimes it'd need resolving flags etc
15:07:48 <mmorrow> dcoutts: ooh, nice. i need to look at the code to cabal-install. looks interesting + lots of useful-in-general bits.
15:08:02 <shapr> Does the Haskell community have any sort of regular irc meetings?
15:08:14 <dcoutts> mmorrow: I want to make cabal-install into a lib too, since all the various hackage clients will need these features
15:08:30 <dcoutts> shapr: ghc meeting every weds at 4pm UK time
15:08:36 <shapr> cool!
15:09:03 <eyu100> > (\x -> foldl1 (+) x) [1, 2, 3, 4, 5, 6, 7]
15:09:04 <lambdabot>   28
15:09:07 <mmorrow> dcoutts: nice, i think that'd be great as a lib
15:09:25 <walkies_died> hello
15:09:28 <eyu100> > filter (> 7) [1, 1, 7, 8]
15:09:30 <lambdabot>   [8]
15:10:12 <shapr> hi walkies
15:11:26 <mmorrow> bos, dcoutts: yes. a cli util to pull info out of .cabal files (preferably in shown [String] or some other valid haskell exp rep) would be /most/ excellent.
15:11:34 <eyu100> > let qsort (x:xs) = qsort (filter (<x) xs) ++ [x] ++ qsort (filter (>=x) xs) in qsort [100..1]
15:11:34 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 44}
15:11:34 <lambdabot> ...
15:11:44 <eyu100> > let qsort (x:xs) = qsort (filter (<x) xs) ++ [x] ++ qsort (filter (>=x) xs) in qsort [1, 2]
15:11:44 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 44}
15:11:44 <lambdabot> ...
15:11:55 <mmorrow> , let qsort (x:xs) = qsort (filter (<x) xs) ++ [x] ++ qsort (filter (>=x) xs) in qsort [100..1]
15:11:57 <lunabot>  luna: <interactive>:1:54-124: Non-exhaustive patterns in function qsort
15:12:32 <dcoutts> bos, mmorrow: please file a feature request for the command line extraction tool
15:12:34 <bos> mmorrow, dcoutts - i'd actually prefer it to be something more easily parsed from a shell script. otherwise just parsing the file from haskell is easier.
15:12:42 <eyu100> > let qsort [] = []
15:12:42 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
15:12:42 <lambdabot>  ...
15:12:56 <mmorrow> dcoutts: will do
15:12:56 <eyu100> > let qsort [] = [] in let qsort (x:xs) = qsort (filter (<x) xs) ++ [x] ++ qsort (filter (>=x) xs) in qsort [1, 2]
15:12:56 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 65}
15:12:56 <lambdabot> ...
15:13:00 <eyu100> , let qsort [] = [] in let qsort (x:xs) = qsort (filter (<x) xs) ++ [x] ++ qsort (filter (>=x) xs) in qsort [1, 2]
15:13:02 <lunabot>  luna: <interactive>:1:75-145: Non-exhaustive patterns in function qsort
15:13:19 <mmorrow> bos: true. i think it'd be good to have an --output-format switch
15:13:26 <rwbarton> eyu100: That just shadows the outer qsort
15:16:47 <walkies_died> do you guys know any papers I could read about representing board games and building a generic solver?
15:16:57 <mmorrow> dcoutts: i'm gonna clean that cgi prog's code up/add a few lacking features and i'll let you know. also, a /very/ interesting feature of graphviz is that you can generate imagemaps with hyperlinks attached to node,edges,edge-tails,edge-heads. so here i'd attach a link to the query containing each package alone to the node representing a package. i think that'd be really cool.
15:17:14 <dcoutts> mmorrow: right, that'd be cool
15:17:37 <dcoutts> mmorrow: once the platform is out, then it'd be nice to prune all the deps that are part of the platform
15:17:55 <walkies_died> I'd like to have a compact semantics for defining rules for possible next moves and winning conditions in games like chess, checkers, othello or connect four
15:18:45 <walkies_died> using that I'd like to build a generic minmax algorithm that'd find optimal moves for the game given its rules
15:19:08 <tromp_> like zillions of games?
15:19:11 <mmorrow> dcoutts: yeah. here's a tarball of the (not very cleaned-up in parts) code as-it-stands: http://moonpatio.com:8080/hackgraphs.tar.gz
15:19:56 <mmorrow> (that tarball also incidently includes most of the code to http://moonpatio.com/cgi-bin/graphedit.cgi)
15:20:01 <walkies_died> tromp, I am thinking of only those relatively simple deterministic games
15:20:23 <mmorrow> which i find handy to create quicky graphs interactively
15:20:53 <walkies_died> basically I'd like to learn about a language for constructing game trees
15:21:30 <lament> mm
15:22:26 <lament> walkies_died: that's pretty hard
15:22:55 <lament> such a language would have to be pretty general, and likely turing-complete
15:23:22 <ddarius> My board game requires evaluating a program at each step.
15:24:28 <vixey> of course it's not turing complete
15:24:36 <vixey> that would be ridiculous
15:25:03 <lament> of course?
15:26:29 <lament> you need arithmetic expressions even just for evaluating possible moves in Mancala
15:27:15 <lament> also for mancala, with relay sowing, you need to evaluate a loop
15:27:22 <lament> there you go, insta-turing-complete
15:27:30 <vixey> Do you think mancala is turing complete?
15:27:43 <lament> in what sense is a game turing-complete?
15:27:51 <vixey> (it's not)
15:28:05 <lament> vixey: i can't think of any sense in which a game can be turing-complete
15:28:17 <hugo_> how does haskell do the iteration in ['a'..'z'] ?
15:28:18 <vixey> ?go game of life
15:28:20 <lament> but we're not talking about a game; we're talking about a general language for describing rules of games
15:28:23 <lambdabot> http://www.bitstorm.org/gameoflife/
15:28:23 <lambdabot> Title: John Conway's Game of Life
15:28:23 <hugo_> does it increment the ascii value ?
15:28:26 <Heffalump> hugo_: using the Enum type class
15:28:33 <Heffalump> @pl ['a' .. 'z']
15:28:33 <lambdabot> ['a'..'z']
15:28:40 <Heffalump> bah
15:28:40 <hugo_> oh
15:28:43 <hugo_> its quite amazing :D
15:28:45 <oklopol> perhaps you could think of all possible game states after n steps as a state for the computation
15:28:45 <Heffalump> @type enumFromTo
15:28:46 <lambdabot> forall a. (Enum a) => a -> a -> [a]
15:28:48 <oklopol> lambdabot
15:28:50 <oklopol> ...
15:28:52 <oklopol> lament
15:28:52 <Heffalump> that's the function it uses
15:29:00 <hugo_> ah, i see :)
15:29:02 <mmorrow> , ['a'..]
15:29:03 <lunabot>  "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\1...
15:29:03 <ddarius> @src Enum
15:29:03 <lambdabot> class  Enum a   where
15:29:03 <lambdabot>     succ                     :: a -> a
15:29:03 <lambdabot>     pred                     :: a -> a
15:29:03 <lambdabot>     toEnum                   :: Int -> a
15:29:03 <lambdabot>     fromEnum                 :: a -> Int
15:29:05 <lambdabot> [3 @more lines]
15:29:09 <ddarius> @more
15:29:09 <lambdabot>     enumFrom                 :: a -> [a]
15:29:10 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
15:29:12 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
15:29:26 <lament> oklopol: what's the program?
15:29:34 <oklopol> the original state
15:29:53 <oklopol> there's a next-state function, defined by doing all possible moves
15:29:54 <hugo_> thats very nice :D
15:29:59 <lament> i'm pretty sure all games in mancala terminate
15:30:07 <lament> not in go, though!
15:30:14 <oklopol> go + infinite board
15:30:34 <lament> oklopol: this has potential :)
15:30:44 <hugo_> i think ill use it to match a list of (String, String) :)
15:30:45 <lament> go problems have a very CA feel
15:30:51 <mmorrow> , toUTF8 (take 10 ['\8704'..])
15:30:52 <lunabot>  ∀∁∂∃∄∅∆∇∈∉
15:30:52 <lament> even though they clearly aren't CA
15:31:04 <hugo_> bye*
15:31:13 <oklopol> i don't know much about go, just that it's hard for computers
15:31:17 <lament> i always think of esolangs and Game of Life when looking at go problems
15:31:22 <mmorrow> , fmap (utf8enc . (:[])) (take 10 ['\8700'..])
15:31:23 <lunabot>  ["\226\135\188","\226\135\189","\226\135\190","\226\135\191","\226\136\12...
15:31:42 <oklopol> go problems? perhaps that'd be a nice way to learn the game
15:31:42 <lament> oklopol: go problems have an initial state, and often there're long chains of forced moves
15:31:50 <oklopol> hmm
15:31:54 <oklopol> that's pretty nice
15:31:58 <lament> oklopol: forced in the sense that you can of course play anywhere else, but doing so would be ridiculously dumb
15:32:07 <oklopol> perhaps you could add some minimaxing to the multiway system
15:32:12 <oklopol> so that
15:32:19 <oklopol> there'd be a concept of forcing
15:32:30 <oklopol> (otherwise the dumb sequences will go on forever too)
15:33:06 <lament> right, and then you have the problem that computers are bad at go :)
15:33:15 <lament> although they're actually very good at it, these days
15:33:22 <oklopol> multiway system is what wolfram called a system where you have state transformation functions, and the global state is the set of results of applying the state transformation functions to all states in the global state
15:33:32 * oklopol read a new kind of science
15:33:47 <oklopol> but i heard later that wolfram is a dick, so i'm not proud!
15:34:01 <Heffalump> was it worth reading?
15:34:01 <oklopol> lament: how good?
15:34:04 <oklopol> i liked it
15:34:24 <lament> oklopol: better than an average club player, but not world class
15:34:28 <tromp_> go games are finite
15:34:35 <tromp_> with the superko rule
15:34:59 <lament> tromp_: even without superko, they don't qualify for turing-completeness since the set of states is finite
15:35:03 <lament> you need an infinite board anyway
15:35:07 <lament> in which case, superko is not enough
15:35:16 <cjb> ooh, go in #haskell
15:35:32 <oklopol> Heffalump: if you don't read the appendices, which contain most of the proving and math, it's a very light read, but it's full of interesting info about different kinds of CA
15:35:34 <tromp_> infinite board is not interesting, since games are never finished
15:35:53 <lament> tromp_: but we're not talking about a game, we're talking about go as a programming environment :)
15:35:53 <cjb> lament: I don't think computers are very good at Go
15:35:58 <lament> cjb: 1d
15:36:02 <lament> or so
15:36:03 <cjb> lament: no way.
15:36:17 <oklopol> 1d?
15:36:25 <oklopol> is it a go goodness level
15:36:28 <cjb> I'm 1d AGA, and the computers I've played feel at least five stones weaker.
15:36:33 <cjb> oklopol: yes
15:36:38 <lament> cjb: MoGo
15:36:45 <cjb> although I guess there are some proprietary engines I haven't played.  okay.
15:36:58 <cjb> MoGo has only got a 1d rating because it plays high-handi games against pros
15:37:07 <cjb> there's hardly any strategy involved in that
15:37:21 <cjb> (which makes sense; it's a Monte Carlo treewalking bot.)
15:37:34 <cjb> I don't think it would actually come close to winning an even game with a 1d
15:37:52 <tromp_> mogo is definitely dan level on 9x9
15:37:56 <cjb> right
15:38:00 <cjb> again because there's little strategy
15:38:17 <oklopol> 9x9 in board size?
15:38:19 <tromp_> on 19x19 it appears to be dan level when running on a supercomputer
15:38:26 <cjb> I agree the computers are getting better, but they're getting better the way chess engines got player
15:38:34 <cjb> tromp_: has it won any even games against dans?
15:38:44 <cjb> s/player/better/
15:38:46 <tromp_> of course, on kgs
15:38:51 <cjb> ok
15:38:52 <lament> cjb: mogo is available for download
15:38:57 <vixey> lament: There aren't any board games anyone plays where it isn't decidable whether or not the a play is valid
15:39:02 <lament> cjb: http://www.lri.fr/~gelly/MoGo_Download.htm
15:39:12 <cjb> lament: nod.  (but it's proprietary.)
15:39:13 <lambdabot> Title: Sylvain GELLY's Home Page
15:39:22 <tromp_> but it can be np hard
15:39:34 <lament> cjb: right, but you can play it and tell us how strong it is ;)
15:39:38 <oklopol> aren't games usually harder than np
15:39:41 <vixey> you can do NP in a strongly normalizing calculis
15:40:08 <tromp_> there are games where deciding if you have a winning *move* is np hard
15:40:16 <mmorrow> this maybe be useful...i ran into a case yesterday where i was running out of Handles with readFile. this solved that: http://hpaste.org/10877
15:40:20 <oklopol> tromp_: right
15:40:36 <tromp_> i mean whether the game can be won in 1 move
15:40:55 <thoughtpolice> mmorrow: can't you just use the 'strict' package on hackage?
15:41:02 <lament> cjb: the page says it's "3k on a fast computer"
15:41:09 <mmorrow> thoughtpolice: sure, i i wanted to import that ;)
15:41:11 <cjb> lament: it doesn't say whether that's 19x19 or 9x9
15:41:16 <lament> cjb: 19x19
15:41:19 <mmorrow> s/i/if/
15:41:20 <cjb> ah, ok
15:41:25 <lament> cjb: 3d on 9x9
15:41:29 <cjb> okay, I'm just wrong :)
15:41:41 <thoughtpolice> mmorrow: also, enumerators! ;]
15:42:22 <cjb> it's a real shame they aren't releasing source for it.
15:42:56 * Heffalump is unhappy about enumerators; they provide nice guarantees, but at a nasty cost in the way you have to write your code
15:43:00 <cjb> this whole "government-sponsored university research produces code, university refuses to release it" thing bothers me quite a lot.
15:43:09 <lament> heh
15:43:11 <mmorrow> thoughtpolice: totally. i'm currently working on writing a general incremental parsing lib using the continuation monad and etc..
15:43:53 <mmorrow> because i seem to need incremental parsing /all/ the time...
15:43:55 <walkies_died> ahh, I love this channel
15:44:00 <rwbarton> Plus, Oleg writes about them and yet they don't involve any type magic.  What's with that?
15:44:33 <thoughtpolice> Heffalump: at the very least there's oleg's Iteratee/IterateeM code you can just reuse
15:44:41 <thoughtpolice> although some of the operators in it might not be to your fancy
15:44:45 <tromp_> you can get fuego source code
15:44:46 <thoughtpolice> you'd just have to check it out I guess
15:45:16 <walkies_died> I was in jail, there was a go master who would watch our chess games always with an amused look
15:45:39 <walkies_died> "chess is just game."
15:45:42 <dibblego> bye
15:45:55 <cjb> tromp_: does it use UCT as well, or is that unique to mogo?
15:46:05 <walkies_died> then he'd laugh
15:46:27 <sbahra> http://www.cse.ogi.edu/~andy/html/intro.htm
15:46:30 <sbahra> Where did that go?
15:46:30 <tromp_> actually mogo doesn't use UCT anymore
15:46:36 <cjb> ooh
15:46:42 <sbahra> I think it's an article on combinators
15:46:53 <tromp_> it uses monte carlo tree search, but not based on UCB formula
15:47:04 <Heffalump> thoughtpolice: I'm aware of the code, it's the inversion of control from the natural lazy IO approach that I dislike.
15:47:07 <tromp_> fuego also uses monte carlo tree search
15:47:29 <tromp_> see http://cgos.boardspace.net/9x9/standings.html
15:47:38 <lambdabot> Title: (CGOS) 9x9 Computer Go Server
15:48:24 <tromp_> going home now...
15:49:00 <tristes_tigres> > map (\s->read s :: Integer)  $ map (flip replicate '1')  [1..11]
15:49:01 <lambdabot>   [1,11,111,1111,11111,111111,1111111,11111111,111111111,1111111111,111111111...
15:49:14 <tristes_tigres> sym $map (\s->read s :: Integer)  $ map (flip replicate '1')  [1..11]
15:49:14 <lament> ooh, fuego is 2k
15:49:17 <lament> on kgs
15:49:26 <tristes_tigres> > sum $ map (\s->read s :: Integer)  $ map (flip replicate '1')  [1..11]
15:49:27 <lambdabot>   12345679011
15:49:46 <lament> sure 2k isn't world class, but it's enough to beat me with 15 stones :D
15:50:51 <lament> cjb: ooh, have you played LeelaBot on KGS?
15:51:04 <cjb> lament: nope, looks interesting though
15:51:08 <lament> it's actually 1k!
15:51:15 <cjb> :)
15:51:40 <eyu100> , map (\s->read s :: Integer) $ map (flip replicate '1') [1..11]
15:51:41 <lunabot>  [1,11,111,1111,11111,111111,1111111,11111111,111111111,1111111111,1111111...
15:51:43 <lament> i suspect there's plenty bots can do to make games trickier especially against humans
15:51:49 <mmorrow> Heffalump: i've been looking in to coroutine-type stuff lately. i'm not sure the precise relation to everything yet, but it's interesting.
15:51:54 <lament> and so increase their rank
15:52:12 <cjb> hmph, leela is payware
15:52:18 <vixey> > map ("1" >>) [1..]
15:52:19 <lambdabot>       No instance for (Enum [b])
15:52:19 <lambdabot>        arising from the arithmetic sequence ...
15:52:59 <sbahra> how long has pass.net been down?
15:53:21 <lament> cjb: it's written by one person! Who has also written a chess engine! Something is wrong here
15:53:26 <cjb> haha
15:53:40 <lament> i mean there's obviously not enough research in this area
15:53:57 <cjb> one of my officemates in a research lab worked on computer go
15:54:23 <cjb> he was going for a principled approach (bayesian, boltzmann machines, learning from expert games, blah) though
15:54:34 <lament> right
15:54:37 <cjb> and it sounds like dumb brute-force is the way to go for now :)
15:54:40 <lament> yeah
15:54:55 <lament> monte carlo bots just totally blow non-monte-carlo ones out of the water
15:55:30 <lament> although i doubt that "dumb brute-force" is the most appropriate description of their algorithms :)
15:57:00 <cjb> well, without learning
15:57:36 <lament> oh, right
15:57:41 <lament> he should switch to backgammon, then :)
15:57:49 <lament> neural nets are doing very well there
15:57:56 <tristes_tigres> is @pl broken ?
15:58:16 <tristes_tigres> @pl  map  ((\s->read s :: Integer).(flip replicate '1')) [1..10]
15:58:17 <lambdabot> map ((:: Integer) . read . flip replicate '1') [1..10]
15:59:03 <tristes_tigres> @type map ((:: Integer) . read . flip replicate '1') [1..10]
15:59:04 <lambdabot> parse error on input `::'
15:59:46 <walkies_died> I am trying to imagine a game where you need a turing complete language to describe the current state and the set of possible transitions to another legal state
16:00:16 <vixey> walkies_die: Sounds like a pretty bad game to try and play
16:00:43 <walkies_died> for a lowly finite being such as myself
16:00:50 <lament> walkies_died: you wanted to describe the rules themselves, no?
16:01:36 <tristes_tigres> vixey: I imaine such a game would open wide field for cheating
16:02:01 <scodil> is there a way to query the GHC runtime to see how much memory its using? Say, to be able to specify the size of something (eg an undo buffer) in terms of bytes rather than "items"?
16:02:13 <tristes_tigres> So, @pl function of lambdabot may generate incorrect espressions
16:02:35 <mmorrow> , let isIn n = n `elem` [1,2,3,5,9] ; lex (a:b:xs) k = k (isIn a,isIn b) xs ; parse (True,False) = Node 0 [Node 0 []] ; parse _ = Node 0 [] ; runP p lex xs = lex xs (\tok xs -> p tok : runP p lex xs) in runP parse lex (cycle [0..9])
16:02:36 <lunabot>  [Node {rootLabel = 0, subForest = []},Node {rootLabel = 0, subForest = []...
16:03:40 <cjb> wow, mogo is playing really odd moves
16:03:57 <lament> cjb: are you playing it?
16:04:02 <cjb> yeah
16:04:24 <cjb> I wondered if I might not be giving it enough CPU time
16:04:29 <tristes_tigres> mmorrow: those code snippets ring a  bell
16:04:32 <cjb> but it's a quad-core machine with 6G RAM
16:04:49 <walkies_died> lament, the rules for a legal move would need to be described, as well as a representation for the game's state (possibly derived from the rules), and preferably an enumeration of the legal moves existing for a given state
16:05:16 <mmorrow> tristes_tigres: it's when you have a lexer and a parser interweaved via continuations
16:05:48 <mmorrow> e.g. ghc/haskell-src/haskell-src-exts's lexer/parser strategy
16:05:56 <vixey> parsing with continuations is very natural
16:06:15 <vixey> I guess it's the thing people usually abstract away though
16:06:58 <mmorrow> totally. and you can express some pretty crazy things context-nonquiteinpedendent things that way too
16:07:23 <tristes_tigres> walkies: on every game's field there's a Turing machine trying to assimilate all neighors
16:07:43 <mmorrow> vixey: yes. i'm trying to write a lib that'll abstract away the details and provide a nice interface to easily and /quickly/ write such parsers
16:07:44 <lament> walkies_died: let's play a game, you name a number, and then i have to name a number such that together they add up to a prime
16:08:04 <vixey> mmorrow: My biggest concern is relating pretty printers and parsers
16:08:22 <lament> walkies_died: to describe that game, you need unbounded arithmetic
16:08:36 <mmorrow> vixey: that's another interesting topic. what are you're thoughts on that?
16:08:41 <mmorrow> *your
16:09:08 <walkies_died> ah
16:09:12 <sbahra> hm
16:09:20 <sbahra> the haskell rdtsc package does not use rdtsc correctly
16:09:23 <vixey> mmorrow: I think it's beyond my ability probably
16:09:38 <mmorrow> vixey: that's doubtful
16:10:26 <mmorrow> what's the problem description you're considering?
16:10:27 <lament> walkies_died: there're also games where if you finish your turn and some condition holds true, you immediately play again with the same rules
16:10:35 <lament> walkies_died: so you need loops to describe those
16:10:49 <lament> walkies_died: given loops and unbounded arithmetic, you're pretty much screwed
16:10:54 <mmorrow> something like /deriving/ one from the other?
16:11:14 * vixey isn't terribly good at the calculations... tends to rely on a mechanical checking
16:11:32 <lament> walkies_died: (eg. checkers - after capture, you can capture again)
16:11:48 <vixey> mmorrow, yes or deriving them both from a single specification st.  parse is the left inverse of pp
16:12:04 <mmorrow> hmm, interesting
16:12:25 <walkies_died> yeah, for the first case you necessarily have to build a turing machine that counts all the primes bigger than the first number in order to enumerate the possible moves
16:12:44 <sbahra> and the description is wrong
16:12:52 <dons> sbahra: send the author a patch?
16:12:58 <sbahra> ye
16:13:08 <sbahra> I am going to write my own right now to learn some basic FFI stuff
16:15:28 <tristes_tigres> sbahra: by the way, can Pentium count floating point ops ?
16:15:31 <walkies_died> but in the second case if the game is not infinite, you can consider state transitions that lead to one side moving again as a single move
16:16:06 <kolmodin> anyone got the url to the haskell developer map?
16:16:22 <kolmodin> showing the distribution of developers on a world map
16:16:41 <lament> walkies_died: yes, but how would you describe that?
16:17:32 <sbahra> tristes_tigres, I don't know
16:17:42 <sbahra> But probably.
16:20:20 <walkies_died> hrm
16:20:57 <walkies_died> I am thinking about the example of checkers where you have the choice of taking two different directions in jumping a chain of pieces
16:22:02 <sbahra> tristes_tigres, I wish there was a standardized interface to Intel performance counters.
16:23:06 <lament> walkies_died: yes, and if i understand checkers correctly, it is all one move
16:23:51 <walkies_died> in jumping a chain of pieces you could possibly represent the transition using a state graph that has a series of nodes from which there are only one or two edges, representing one side being forced to jump the sucession of pieces, as well as the possible choice that can be made at some point
16:24:12 <tristes_tigres> sbahra: there's some stuff on perfromance measuring on http://software.intel.com/en-us/articles/measure-code-sections-using-the-enhanced-timer
16:24:15 <lambdabot> http://tinyurl.com/3gx8hd
16:25:03 <walkies_died> lament, you're right, it would be hairy
16:26:19 <sbahra> tristes_tigres, this is Windows-specific and it is just again a measurement of ticks or similar (either using rdtsc, rdtscp or HPET).
16:26:55 <sbahra> Performance counters are implemented using MSRs, which is the problem (and also require ring-0 to dictate access to them).
16:27:05 <sbahra> This is the real issue.
16:27:37 <sbahra> Of *nix operating systems, Solaris probably has best set of tools to access these things. brendang@ was supposedly working on dtrace support too
16:30:07 <sereven> kolmodin: there is this link on the wiki users group page: http://www.frappr.com/haskellers
16:30:29 <tristes_tigres> sbahra: have you seen http://icl.cs.utk.edu/papi/
16:30:30 <lambdabot> Title: PAPI
16:31:08 <sbahra> tristes_tigres, yes, very ugly compared to what Solaris provides.
16:31:23 <kolmodin> sereven: right, I found that one. but it seems it doesn't know of the users of the old list
16:32:42 <tristes_tigres> sbahra: Solaris may be going the way of Dec Irix Amiga
16:34:15 <tristes_tigres> hard to compete with free linux and cheap windows
16:35:46 <sbahra> Solaris is free.
16:36:07 <shapr> But it can't be integrated into the existing linux community.
16:37:02 <sbahra> shapr, definitely not
16:37:22 <walkies_died> is there any formal verification of the linux kernel going on?
16:37:46 <pjdelport> walkies_died: it compiles
16:37:51 <sbahra> Hm, I wish I didn't delete my code :-/
16:37:58 * sbahra recently lost a majority of his hobby work
16:38:07 <bd__> walkies_died: GCC is hardly 'formal' :)
16:38:20 <mmorrow> walkies_died: someone verified that language-c parses it all ok on their blog somewhere
16:38:33 <walkies_died> very cool
16:38:38 <mmorrow> so your work is cut out for you ;)
16:40:02 <mmorrow> walkies_died: found the link: http://www.galois.com/blog/2008/09/17/parsing-the-linux-kernel-with-haskell-experience-with-languagec/
16:40:04 <lambdabot> Title: Galois › Blog › Blog » Parsing the Linux kernel with Haskell: experience wi ..., http://tinyurl.com/3m6vyz
16:42:36 <walkies_died> I remember a paper on doing correctness proofs on the L4 kernel specifications in coq, modelling it in haskell, and translating the code to C
16:43:32 <walkies_died> which was very impressive
16:43:54 <walkies_died> even though it seemed over-hyped
16:44:09 <walkies_died> (the c translation was to be hand tuned)
16:45:55 <mmorrow> maybe the first entry on this page is related to that?
16:45:56 <mmorrow> http://www.galois.com/blog/2008/08/28/galois-tech-talks/
16:45:57 <lambdabot> Title: Galois › Blog › Blog » Galois Tech Talks
16:46:07 <mmorrow> "Large Scale Monadic Refinement - Tales from L4.verified"
16:46:36 <sbahra> What's the policy on using GNU extensions in GHC packages?
16:46:50 <thoughtpolice> sbahra: like cbits you link in via the FFI?
16:46:55 <sbahra> For example, if I want to explicitly specify the usage of fastcall for something.
16:46:58 <sbahra> thoughtpolice, yes
16:47:06 <walkies_died> http://www.ok-labs.com/blog/entry/ask-gernot-gernot-heiser-on-his-l4-verified-presentation/
16:47:09 <thoughtpolice> hm, I've never seen anything *against* it
16:47:09 <lambdabot> Title: Open Kernel Labs : Company Blog, http://tinyurl.com/4ljycw
16:47:22 <mmorrow> sbahra: i guess just note it in the "portability:" field
16:47:31 <sbahra> Ok
16:47:34 <sbahra> Another question
16:47:38 <tristes_tigres> So what language-c can do that gcc -Wall -pedantic can not ?
16:48:15 <mmorrow> tristes_tigres: parse the code to a haskell datatype
16:48:32 <tristes_tigres> mmorrow: from the pov of C programmer
16:48:37 <mmorrow> which can then be manipulated arbitrarily and possibly written back to vcode
16:48:40 <thoughtpolice> i'm not quite sure I understand your question
16:48:41 <sbahra> Right now there is "rdtsc", it is module System.CPUTime.Rdtsc. There is also "Cpuid" which is System.Cpuid.
16:48:49 <thoughtpolice> 'what can language-c do that gcc cannot'?
16:48:55 <thoughtpolice> they have different purposes
16:48:57 <sbahra> Would there be anyone against having rdtsc part of a System.CPU.Time?
16:48:59 <mmorrow> tristes_tigres: hmm, i guess if one's not using haskell, it may not be very useful.
16:49:21 <tristes_tigres> mmorrow: can it be used to find errors and improve C code ?
16:49:28 <sbahra> Not sure what cpuid would fall under, System.CPU, maybe System.CPU.Cpuid.
16:49:32 <thoughtpolice> tristes_tigres: there are analysis modules in the language-c source code
16:49:38 <thoughtpolice> although that part of the library is still under development
16:49:56 <mmorrow> tristes_tigres: oh, most definitely. if you can program an algo to do so in haskell using the C AST rep...
16:50:04 <thoughtpolice> http://hackage.haskell.org/packages/archive/language-c/0.3.1/doc/html/Language-C-Analysis.html
16:50:06 <lambdabot> Title: Language.C.Analysis, http://tinyurl.com/4z7ngl
16:50:35 <mmorrow> that reminds me...
16:50:54 <thoughtpolice> those modules could be useful for example, building a C AST so you can emit it (code generation,) and making sure the AST makes 'sense'
16:51:28 <tristes_tigres> mmorrow: but out of the box, it does not have any such tools ?
16:52:35 <thoughtpolice> tristes_tigres: see the link above
16:52:36 <bigtalk> damn wtf, if i want to do for x in xs, for y in xs, (y*x:acc)
16:52:41 <thoughtpolice> you can use that interface but it's likely to change
16:52:46 <mmorrow> tristes_tigres: i'm not sure. i believe it may have the beginnings of such, but since it's so new if it does have any, they're most likely not-quite-industrial-strength (yet ;))
16:52:50 <bigtalk> do i ahve to write a function for that? cant i do maop inside a map?
16:53:41 <thoughtpolice> bigtalk: [ x*y | x <- xs, y <- ys] ?
16:53:43 <sbahra> do you know about set builder notation, bigtalk?
16:54:04 <bigtalk> sbahara, is that what tp posted?
16:54:08 <bigtalk> no i dont know
16:54:23 <EvilTerran> > [(x,y) | x <- [1,2,3], y <- "abc"]
16:54:25 <lambdabot>   [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
16:54:44 <thoughtpolice> bigtalk: i used a list comprehension, but the notation for building sets is similar
16:54:57 <EvilTerran> set-builder notation is a maths thing
16:55:06 <EvilTerran> but it inspired the list comprehension notation in haskell
16:55:08 <mml`> anybody have a list of the CPUs supported by ghc?
16:55:26 <bigtalk> ah i see, i first thought the listcomprehnsion was parallel mao but its a nested loop
16:55:42 <EvilTerran> it's analogous to a nested loop, yeah
16:55:46 <tristes_tigres> thoughtpolice: some example of usage or case studies ?
16:56:02 <thoughtpolice> tristes_tigres: of what? using language-c or Language.C.Analysis?
16:56:33 <thoughtpolice> mml`: http://hackage.haskell.org/trac/ghc/wiki/Contributors
16:56:35 <lambdabot> Title: Contributors - GHC - Trac
16:56:41 <EvilTerran> the equivalent set-builder notation would be {(x,y) | x :- {1,2,3}, y :- {a,b,c}}
16:56:50 <thoughtpolice> mml`: there's no telling when that page was last updated, though
16:56:56 <EvilTerran> except with the "is an element of" symbol in place of :-
16:57:01 <bigtalk> ET: cool thanks
16:57:01 <tristes_tigres> thoughtpolice: the latter
16:57:16 <thoughtpolice> tristes_tigres: no
16:57:22 <thoughtpolice> like I said the interface is experimental
16:57:25 <thoughtpolice> very likely to change
16:57:36 <thoughtpolice> but you can probably put something together with what's there already
16:57:48 <thoughtpolice> just look through the docs
16:59:07 <mml`> thoughtpolice: that's a start.  thanks
16:59:12 <bigtalk> how do i convert frring?om int to st
16:59:20 <bigtalk> how do i convert from int to string?
16:59:50 <thoughtpolice> mml`: note if you are looking to get GHC on some platform that isn't there, i.e. port it, you will need an older version of GHC, like 6.4.2, as HC bootstrapping does not work in 6.8-6.10 (but it should revive in 6.12)
17:04:16 <Saizan_> bigtalk: show
17:04:24 <Saizan_> > show 1
17:04:25 <lambdabot>   "1"
17:06:56 <Olathe> > show && tell
17:06:57 <lambdabot>   Couldn't match expected type `Bool'
17:08:01 <ddarius> > show &&& tell
17:08:02 <lambdabot>       Overlapping instances for Show (a -> (String, m ()))
17:08:02 <lambdabot>        arising fro...
17:11:40 <Glurk> morning all :)
17:13:32 <Glurk> anyone awake ?
17:14:37 <mmorrow> heh, i just added the (no, you can't splice in stuff yet) c quasiquoter to lunabot's imports
17:14:39 * dolio is asleep.
17:14:39 <mmorrow> , [$c|int *x = NULL;|]
17:14:41 <lunabot>  [CDeclExt (CDecl [CTypeSpec (CIntType (NodeInfo ("",1,1) (Name {nameId = ...
17:15:45 <mmorrow> unfortunately, since language-c's Show instance for its AST isn't valid haskell syntax, lunabot can't show a prettily formatted version of the ouput in a /msg :(:(
17:16:21 <dolio> , [$c| int **(int *f ())[] = NULL; |]
17:16:23 <lunabot>  luna: :1: (column 9) [ERROR]  >>> Syntax Error !
17:16:23 <lunabot>    Syntax error !
17:16:23 <lunabot>    The symbol `int' does not fit here.
17:16:32 <dolio> Oops.
17:17:02 <mmorrow> , (text . pretty) (Node 0 [Node 1 [Node 2 []]])
17:17:03 <lunabot>  Node{rootLabel = 0,
17:17:03 <lunabot>       subForest =
17:17:03 <lunabot>         [Node{rootLabel = 1,
17:17:15 <mmorrow> (lunabot will return 32 lines max in a /msg)
17:17:30 <mmorrow> dolio: heh
17:17:40 <dolio> I fail at C.
17:18:02 <gwern> 'lo all
17:18:06 <gwern> any news?
17:20:30 <dolio> The next version of Windows is being written in Haskell.
17:21:01 <thoughtpolice> mmorrow: you mean the pretty printer actually outputting C?
17:21:14 <thoughtpolice> mmorrow: I asked the author about that, he told me how you can get it to print the raw AST instead
17:21:20 <thoughtpolice> just a sec,
17:21:42 <mmorrow> that function "pretty" show the input, then parses that with haskell-src-exts, then prettyPrints the haskell ast of the expression which that shown string represents
17:21:55 <bigtalk> http://hpaste.org/10879
17:22:03 <bigtalk> @t read
17:22:04 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
17:22:16 <thoughtpolice> mmorrow: apparently for a raw AST you can use gshow from data.generics
17:22:32 <bigtalk> read needs a astring but my function needs a [char]
17:22:38 <bigtalk> how can i fix it ^^ ?
17:22:45 <thoughtpolice> bigtalk: type String = [Char]
17:22:49 <mmorrow> ooh, i forgot about that. nice, i'll make a gpretty then. :)
17:22:53 <thoughtpolice> same thing :]
17:23:00 <dolio> > read ['5'] :: Int
17:23:01 <lambdabot>   5
17:23:02 <bigtalk> sumString "123" -> 6
17:23:14 <dolio> > digitToInt '5'
17:23:16 <lambdabot>   5
17:24:47 <bigtalk> tx
17:24:48 <sbahra> > show 5
17:24:50 <lambdabot>   "5"
17:24:52 <thoughtpolice> mmorrow: just keep in mind, the output of gshow
17:24:57 <thoughtpolice> will probably make you want to commit suicide
17:25:22 <mmorrow> thoughtpolice: i hope it parses as haskell... (about to find out)
17:25:39 <b\6> i have work to do split into pieces in a list. in another language i'd mutex-protect the list and start n threads that lock, take the first element from the list, unlock, do the work, repeat. how should i think about that in haskell?
17:25:52 <thoughtpolice> mmorrow: there's also something in the test-suite to do the same thing which might be more what you're looking for
17:26:11 <sbahra> bigtalk,
17:26:13 <sbahra> > (read . reverse . show) 12345 :: Int
17:26:15 <lambdabot>   54321
17:26:34 <sbahra> bigtalk, still working on projecteuler?
17:26:51 <b\6> sbahra: isn't that composition backwards?
17:27:24 <b\6> maybe i'm just not awake yet.
17:27:26 <Saizan_> b\6: i'd use a Chan, probably
17:27:32 <bigtalk> sbahra: yes
17:27:45 <sbahra> bigtalk, what problem are you working on?
17:27:51 <sbahra> Saizan_, a Chan
17:27:55 <bigtalk> all, i pick them off fairly fast
17:27:55 * sbahra hoogles 
17:27:57 <rwbarton> b\6: I think you want a Chan, and several forkIO'd threads.  Or if the number of items isn't huge, you can just forkIO a thread for each task, they're pretty cheap.
17:28:09 <bigtalk> sum are really easy, some are hard
17:28:11 <sbahra> bigtalk, yes, but what problem # are you working on now? or what is your username?
17:28:29 <b\6> rwbarton, Saizan_: thanks, reading.
17:28:29 <Saizan_> ?docs Control.Concurrent.Chan
17:28:30 <sbahra> I might join you for some minutes after dinner, then go back to this System.CPU thing
17:28:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html
17:28:42 <bigtalk> no username, just did 16 and 4, those were easy, looking for the next one
17:28:44 <eyu100> > (read . reverse . show) 1234567 :: Int
17:28:46 <lambdabot>   7654321
17:28:49 <eyu100> > (read . reverse . show) 1234567
17:28:51 <lambdabot>   * Exception: Prelude.read: no parse
17:28:55 <eyu100> > (read . reverse . show) 1234567 :: Int
17:28:56 <lambdabot>   7654321
17:29:05 <eyu100> > (read . reverse . show) 1234567888 :: Int
17:29:06 <lambdabot>   8887654321
17:29:10 <eyu100> > (read . reverse . show) 12345678888888888888888888888 :: Int
17:29:11 <SamB_XP> bigtalk: why no user name ?
17:29:11 <lambdabot>   2910849811631617969
17:29:16 <eyu100> > (read . reverse . show) 12345678888888888888888888888 :: Integer
17:29:18 <lambdabot>   88888888888888888888887654321
17:29:24 * sbahra gets bored of projecteuler
17:29:41 <sbahra> SamB_XP, what is yours?
17:29:52 <SamB_XP> it's either SamB or naesten
17:29:56 <SamB_XP> I can't remember which
17:30:23 <SamB_XP> check naesten first, since I'm the only one who uses that ;-)
17:31:00 <SamB_XP> though due to recent changes I may not be visible anywhere but the forums ?
17:31:04 <sbahra> http://projecteuler.net/index.php?section=profile&profile=naesten
17:31:05 <lambdabot> Title: Project Euler
17:31:20 <Olathe> @type (a -> (a, b)) -> a -> [b]
17:31:21 <lambdabot> parse error on input `->'
17:31:25 <Olathe> @hoogle (a -> (a, b)) -> a -> [b]
17:31:26 <lambdabot> No results found
17:32:04 <rwbarton> :t unfoldr . (Just .)
17:32:05 <lambdabot> forall a a1. (a1 -> (a, a1)) -> a1 -> [a]
17:32:19 <SamB_XP> hmm, since I apparantly needed to login to see that page, I can verify that naesten is my username ;-)
17:32:23 <bigtalk> i didnt see the register until now
17:32:26 <bigtalk> whats the point?
17:32:55 <SamB_XP> bigtalk: it saves the ones you've done
17:32:59 <sbahra> bigtalk, you get access to the forums after you solve a problem
17:33:06 <sbahra> bigtalk, so you can see what others did and learn from them
17:33:07 <SamB_XP> also you apparantly can't see my profile unless you do
17:33:26 <SamB_XP> one of them, I solved using a CASIO BASIC
17:33:29 <sbahra> Every problem is a different thread on their forums, you only have access if you have solved it.
17:33:39 <SamB_XP> or was it just an expression?
17:33:40 <sandbox> is there a method to get haskell to repeatedly recalculate a value instead of using the memoized one?
17:34:09 <SamB_XP> sandbox: dur ... ask dons ?
17:34:18 <Philonous> Haskell doesn't memoize afaik
17:34:19 <SamB_XP> dcoutts: ?
17:34:19 <sbahra> heh
17:34:26 <rwbarton> sandbox: what do you mean "the memoized one"?
17:34:34 <rwbarton> (example?)
17:34:45 <sandbox> I thought it memoized or removed repeatedly calculated values
17:34:46 <Cale> sandbox: Turn it into a function.
17:34:52 <Cale> no
17:35:05 <Cale> Well, constants are only computed once.
17:35:12 <sw17ch> how does one ask cabal to build a C file to be linked against?
17:35:17 <sandbox> thanks
17:35:21 <rwbarton> sandbox: Sharing is explicit.  Wherever you write a "let x = ...", or bind a value by a lambda application, you create sharing.
17:35:24 <Cale> And the parameters to a function are computed at most once in the function body.
17:35:26 <SamB_XP> Cale: which okasaki had the bad sense to refer to as "memoization"
17:35:28 <Cale> But that's it :)
17:36:57 <Cale> It would be nice sometimes if there was a way to explicitly split a value, so that evaluation of one copy wouldn't cause evaluation of the other.
17:37:07 <Cale> But needing to do that is fairly rare.
17:37:29 <rwbarton> Cale: would it be a "deep split"?
17:37:50 <Cale> That's a good question :)
17:38:01 <thoughtpolice> sw17ch: c-sources field
17:38:08 <sw17ch> ah, merci
17:38:29 <Cale> rwbarton: I think I would expect it to split up to things which were already evaluated, and not past that.
17:39:10 <bigtalk> ah cool, thats nice, ill register
17:39:46 <bigtalk> im pandemic now, you guys?
17:40:53 <ivanm> mmorrow: I tried doing that on the docs, but then haddock started complaining about some of the -- $ comments as well :s
17:41:16 <mmorrow> ivanm: oh yeah. those too.
17:41:19 <Cale> (that is, split would have no effect on things which were in WHNF already)
17:41:29 <mmorrow> just escape the '$'s with a \
17:41:56 <mmorrow> thoughtpolice: ok, gpretty worked.
17:41:59 <mmorrow> , (text . gpretty) [$c|int *x = NULL;|]
17:42:01 <lunabot>  ((:)
17:42:01 <lunabot>     (CDeclExt
17:42:01 <lunabot>        (CDecl
17:42:15 <ivanm> oh? that would do it?
17:42:20 <mmorrow> (in a /msg one can see more)
17:42:34 <ivanm> I figured by the time I did all that, there wouldn't be any docs left :s
17:42:49 <ivanm> so now I'm just going through the source file instead of bothering with the docs ;-)
17:42:52 <mmorrow> ivanm: yeah. haddock thinks it's a markup syntax char and syntax errors out
17:43:18 <mmorrow> ivanm: there's only a few chars you have to escape
17:43:32 <mmorrow> (the docs are nice)
17:43:33 <ivanm> hmmmmmm..... I still don't know why haddock doesn't like those modules though :s
17:43:58 <mmorrow> yeah, me neither actually. it's weird
17:44:22 <ivanm> and by the looks of things, that Parser.hs one never worked, even back to the first version on haddock :s
17:45:20 <eyu100> > (double.double) 2
17:45:22 <lambdabot>   Couldn't match expected type `Double' against inferred type `Doc'
17:45:34 <Olathe> @type double
17:45:35 <eyu100> > let double x = x + x in (double.double) 2
17:45:37 <lambdabot> Double -> Doc
17:45:37 <lambdabot>   8
17:45:44 <eyu100> > let double x = x + x in (double.double) 4
17:45:45 <lambdabot>   16
17:45:51 <mmorrow> ivanm: i hate when a package's docs don't build.
17:46:26 <davidL> > (succ &&& pred) 4
17:46:27 <lambdabot>   (5,3)
17:46:45 <Olathe> > succ 1.0
17:46:47 <lambdabot>   2.0
17:46:48 <ivanm> yeah :s
17:46:50 <mmorrow> there's no reason for that to fail, unless someone uses haddock markup syntax without escaping it, which is curious when they go to the trouble to also add valid haskell markup in the same module
17:46:52 <Olathe> > succ 1.4
17:46:54 <lambdabot>   2.4
17:47:04 <mmorrow> s.haskell/haddock/
17:47:09 <mmorrow> s/.//
17:47:14 <mmorrow> meta-s
17:47:48 <bigtalk> problem 4, im confused: http://hpaste.org/10880
17:48:01 <bigtalk> 999*999
17:48:07 <ivanm> mmorrow: what's really great, is when you try running haddock with -vd, and it doesn't produce any extra output :s
17:48:16 <ivanm> mmorrow: heh...
17:48:33 <mmorrow> ivanm: heh
17:48:36 <bigtalk> http://hpaste.org/10881
17:48:42 <gwern> mmorrow: sometimes haddock is just buggy
17:48:42 <bigtalk> ^^ bette rone
17:48:59 <ivanm> gwern: _sometimes_?
17:49:02 <ivanm> ;-)
17:49:06 <gwern> for example, 'data foo = bar -- ^ Example' will fail on all 2.x haddocks, iirc
17:49:22 <mmorrow> gwern: true. but invalid markup syntax errors aren't bug :)
17:49:26 <ivanm> ummmm.... I thought that wasn't valid...
17:49:32 <mmorrow> (bugs in haddock that is)
17:49:35 <gwern> ivanm: understatement is a favorite rhetorical technique of mine
17:49:54 <gwern> ivanm: well, maybe it was -- |
17:49:56 <mmorrow> i like hyperbole myself
17:50:11 * gwern forgets exactly. 
17:50:21 <gwern> it was definitely to do with type synonyms tho
17:50:22 <mmorrow> omG there were like a BILLION syntax errors
17:50:27 <mmorrow> (there were 2)
17:50:40 <ivanm> gwern: since you're not on #xmonad, is it possible for you to fix up and resend that patch for the haddock docs in Paste.hs? you seem to have extra patches in your repo that darcs here didn't like (and sjanssen said something similar)...
17:50:48 <gwern> the computer scientist's number system - 0, 1, infinity
17:51:08 <gwern> ivanm: didn't I resent the nomodmask patch?
17:51:15 <bigtalk> ^^ bette rone
17:51:17 <ivanm> oh, did you rename it?
17:51:19 <bigtalk> http://hpaste.org/10881
17:51:40 <gwern> dunno
17:52:29 <mmorrow> <thoughtpolice> mmorrow: there's also something in the test-suite to do the same thing which might be more what you're looking for
17:52:29 <ivanm> because haddock doesn't like Paste.hs, and at one stage you sent a patch regarding haddock to the mailing list...
17:52:36 * ivanm goes and digs it up
17:52:56 <mmorrow> thoughtpolice: unless it parses full haskell and prettyprints the resulting AST, it can't be capable of the equivalent
17:53:19 * gwern doesn't see any haddock related patches in my local XMCs
17:53:25 <ivanm> gwern: you sent two patches on 27/9 regarding haddock in Paste.hs
17:53:31 <mmorrow> (because doing something equivalent is equivalent to parsing+prettyprinting ;))
17:53:52 <ivanm> gwern: patch li nk: http://www.haskell.org/pipermail/xmonad/attachments/20080927/af00b195/attachment.bin
17:53:54 <lambdabot> http://tinyurl.com/4qdkfr
17:54:51 <bigtalk> i see  should use max
17:54:53 <bigtalk> @src max
17:54:54 <lambdabot> max x y = if x <= y then y else x
17:54:58 <mmorrow> well, i guess it could traverse the expression like it does with everywhere, and accumulate a pretty string rep over that traversal maybe. but that would be hard i think
17:55:23 <gwern> ivanm: I see my 2 haddock patches in the main xmc repo
17:55:42 <ivanm> oh?
17:55:51 <ivanm> I'll look again... unless they just got applied...
17:57:15 <ivanm> gwern: heh, they just got applied overnight (well, overnight for me) and I didn't think to sync yet
17:57:16 <Olathe> > let reverseDigits n = f 0 n where f r 0 = r; f r dds = f (10*r + d) ds where (ds, d) = quotRem dds 10 in reverseDigits 123
17:57:17 <lambdabot>   321
17:57:41 <ddarius> > (reverse . show) 123
17:57:42 <lambdabot>   "321"
17:57:49 <ddarius> > (read . reverse . show) 123
17:57:50 <lambdabot>   * Exception: Prelude.read: no parse
17:58:09 <gwern> ivanm: I find it helpful to add darcs pull to a cronscript
17:58:21 <ivanm> > (read . reverse . show) 123 :: Int
17:58:22 <lambdabot>   321
17:58:34 <gwern> ivanm: my entry looks like this: '@weekly   for file in `locate -b "_darcs"|grep gwern|grep -v .save |grep -v .py|grep -v ".t*x"|grep -v .tar`; do (cd $file && cd ../ && darcs pull --all &); done'
17:58:36 <Olathe> > let reverseDigits n = f 0 n where f r 0 = r; f r dds = f (10*r + d) ds where (ds, d) = quotRem dds 10 in reverseDigits (-123)
17:58:37 <lambdabot>   -321
17:58:44 * gwern notes that it is ugly, but works
17:58:52 <Olathe> > (read . reverse . show) (-123) :: Int
17:58:53 <lambdabot>   * Exception: Prelude.read: no parse
17:58:57 <ivanm> gwern: well, when I build it it does a darcs pull
17:59:10 <gwern> sure but how often do you build stuff?
17:59:28 <ivanm> daily, usually ;-)
17:59:42 * ivanm points to the fact that he's a ricer gentoo user :p
17:59:55 <gwern> man, if I tried to build my hundreds of repos daily, I'd never get anything done
18:00:02 <gwern> ah, a gentooer. that explains it
18:00:07 <ivanm> ;-)
18:00:08 <luqui> it kinda has to be ugly, because reversing digits is kind of an ugly thing to do
18:00:25 <Olathe> @pl \r dds -> (\(ds, d) -> f (10*r + d) ds).flip quotRem 10 $ dds
18:00:25 <lambdabot> (. flip quotRem 10) . (`ap` snd) . (. fst) . flip . (f .) . (+) . (10 *)
18:01:43 <bigtalk> euler #5, what dot hey mena with evenly divisible?
18:02:41 <ivanm> gwern: well, when one command rebuilds all my live packages (even cvs, etc. stuff) ... ;-)
18:02:44 <Olathe> bigtalk: x is evenly divisible by y if x/y has no remainder.
18:05:31 <bigtalk> ok so mod x y == 0
18:05:44 <bigtalk> weird is my solution works for the examle 1..10
18:05:56 <bigtalk> but i cant find the smalelst for 1..20
18:06:03 <bigtalk> i have tried up to 2million so far
18:06:37 <bigtalk> 3mil
18:07:45 <bigtalk> 5mil still no answer
18:08:35 <joey``> bigtalk: Hint - if you're only at 5mill, you'll be waiting a while!
18:09:59 <bigtalk> ok so it is very big then
18:10:14 <joey``> Much bigger than 5mill, yes.
18:10:20 <bigtalk> 3 to 20 mil im testung now
18:10:45 <joey``> You might want to refine your algorithm slightly or you'll be at it all night, hehe
18:10:47 <sbahra> :t lcm
18:10:48 <lambdabot> forall a. (Integral a) => a -> a -> a
18:10:55 <Olathe> > gcd 5 0
18:10:56 <lambdabot>   5
18:11:00 <Olathe> > lcm 5 0
18:11:01 <lambdabot>   0
18:11:04 <Olathe> > lcm 0 0
18:11:05 <lambdabot>   0
18:11:08 <Olathe> > gcd 0 0
18:11:09 <lambdabot>   * Exception: Prelude.gcd: gcd 0 0 is undefined
18:11:15 <sbahra> > foldl lcm 1 [10 .. 20]
18:11:16 <lambdabot>   232792560
18:11:36 <loop> spoiler!
18:11:40 <sbahra> haha
18:12:01 <Olathe> > denominator.sum.map (1%) $ [10 .. 20]
18:12:03 <lambdabot>   232792560
18:12:30 <sbahra> :t denominator
18:12:31 <lambdabot> forall a. (Integral a) => Ratio a -> a
18:15:51 <Olathe> > foldl1 gcd [10 .. 20]
18:15:52 <lambdabot>   1
18:15:55 <Olathe> ;)
18:19:37 <mmorrow> rwbarton: `src' is added
18:19:54 <mmorrow> , fmap src [''IO,''Maybe,''[],''()]
18:19:57 <lunabot>  [newtype IO a = IO (State# RealWorld -> (#,#) (State# RealWorld) a),data ...
18:20:02 <mmorrow> , vcat $ fmap src [''IO,''Maybe,''[],''()]
18:20:04 <lunabot>  newtype IO a = IO (State# RealWorld -> (#,#) (State# RealWorld) a)
18:20:04 <lunabot>  data Maybe a = Nothing | Just a
18:20:04 <lunabot>  data [] a = [] | a : ([a])
18:20:06 <sbahra> , help
18:20:08 <lunabot>  luna: Not in scope: `help'
18:20:15 <sbahra> fker
18:20:22 <rwbarton> , src ''EitherT
18:20:25 <lunabot>  newtype EitherT a m b = EitherT {runEitherT :: (m (Either a b))}
18:20:40 <mmorrow> i should add a `help' function to the scope to i don't have to modify the bot...
18:20:53 <mmorrow> wtf
18:20:57 <mmorrow> EitherT ??
18:21:02 <mmorrow> oh
18:21:07 <mmorrow> category-extras?
18:21:21 <rwbarton> that's my guess...
18:21:29 <rwbarton> Yeh
18:21:30 <rwbarton> Yeah
18:22:45 <mmorrow> i played with that (cat-exts) the other day for the first time (actually experimenting in ghci for more than a minute) with it. i think it will turn out to be very useful, once i learn all the various types/etc
18:23:24 <rwbarton> , src ''ZygoT
18:23:27 <lunabot>  type ZygoT = CoreaderT
18:23:28 <mmorrow> , evalQ [|fmap (*2) [0..]|]
18:23:29 <lunabot>  luna: Not in scope: `evalQ'
18:23:32 <mmorrow> crap
18:24:00 <mmorrow> , evalQ [|fmap (*2) [0..]|]
18:24:03 <lunabot>  <<[Integer]>>
18:24:18 <mmorrow> , fromDynamic (evalQ [|fmap (*2) [0..]|]) :: [Integer]
18:25:47 <rwbarton> , src 'either
18:25:56 <rwbarton> I think it broke
18:25:58 <rwbarton> , "ping"
18:26:45 <mmorrow> , fromDynamic (evalQ [|fmap (*2) [0..]|]) :: Maybe [Integer]
18:26:45 <mmorrow> um
18:27:18 <mmorrow> , evalQ [|fmap (*2) [0..]|]
18:27:21 <lunabot>  <<[Integer]>>
18:27:23 <mmorrow> , fromDynamic (evalQ [|fmap (*2) [0..]|]) :: Maybe [Integer]
18:27:26 <lunabot>  Just [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,...
18:28:08 <mmorrow> , src ''Comonad
18:28:10 <lunabot>  class Copointed w => Comonad w
18:28:10 <lunabot>      where duplicate :: forall w . Comonad w => forall a . w a ->
18:28:45 <mmorrow> hmm, need a "[@more]"
18:29:03 <mmorrow> , src ''Monad
18:29:06 <lunabot>  class Monad m
18:29:06 <lunabot>      where >>= :: forall m . Monad m => forall a b . m a ->
18:29:06 <lunabot>                                                      a -
18:29:13 <mmorrow> grr
18:29:54 <bigtalk> http://hpaste.org/10882 , euler 5, can someone tip me on optimization? i thought the 2nd would be much faster but it is still slow
18:30:09 <sw17ch> potentially dumb question... but does Data.Binary encode things in NetworkByte order, or Host?
18:31:25 <shrughes> > foldl lcm 1 [1..20]
18:31:26 <lambdabot>   232792560
18:31:26 <sbahra> > foldl1 lcm [10 .. 20]
18:31:28 <lambdabot>   232792560
18:33:40 <bigtalk> lowest common m?
18:33:50 <bigtalk> @src lcm
18:33:51 <lambdabot> lcm _ 0     =  0
18:33:51 <lambdabot> lcm 0 _     =  0
18:33:51 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
18:33:52 <Olathe> Least common multiple.
18:34:27 <rwbarton> What's this about?  Template Haskell error: Can't do `reify' in the IO monad
18:34:38 <bigtalk>  No instance for (Integral (a -> a -> a))
18:34:38 <bigtalk>       arising from a use of `lcm'
18:34:48 <bigtalk> but works in prelude...
18:34:54 <sbahra> :t lcm
18:34:55 <lambdabot> forall a. (Integral a) => a -> a -> a
18:35:01 <sbahra> lcm 2 2
18:35:08 <sbahra> > lcm 2 2
18:35:09 <lambdabot>   2
18:35:10 <sbahra> :t foldl
18:35:10 <Olathe> > let lcm x y = head $ filter (\m -> rem x m == 0 && rem y m == 0) [1..] in lcm 2 2
18:35:12 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
18:35:12 <lambdabot>   1
18:35:18 <sbahra> :t foldl1
18:35:18 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
18:35:22 <Olathe> > let lcm x y = head $ filter (\m -> rem m x == 0 && rem m y == 0) [1..] in lcm 2 2
18:35:24 <lambdabot>   2
18:35:33 <Olathe> > let lcm x y = head $ filter (\m -> rem m x == 0 && rem m y == 0) [1..] in lcm 2 73
18:35:34 <lambdabot>   146
18:35:49 <sbahra> > putStr "Test"
18:35:50 <lambdabot>   * Exception: "<IO ()>"
18:35:59 <Olathe> > let lcm x y = take 10 $ filter (\m -> rem m x == 0 && rem m y == 0) [1..] in lcm 2 73
18:36:00 <lambdabot>   [146,292,438,584,730,876,1022,1168,1314,1460]
18:36:04 <sbahra> > do putStr "Test"
18:36:05 <lambdabot>   * Exception: "<IO ()>"
18:36:07 <sbahra> fker
18:36:36 <shrughes> > let lcm xs = head . filter (\m -> all ((== 0) . rem m) xs) $ [1..]
18:36:37 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
18:36:37 <lambdabot>  ...
18:36:44 <shrughes> > let lcm xs = head . filter (\m -> all ((== 0) . rem m) xs) $ [1..] in lcm [2, 73]
18:36:45 <Olathe> > let commonMultiples x y = filter (\m -> rem m x == 0 && rem m y == 0) [1..]; leastCommonMultiple = head.commonMultiples in leastCommonMultiple 2 73
18:36:45 <lambdabot>   146
18:36:46 <lambdabot>   Couldn't match expected type `[a]'
18:36:53 <shrughes> > let lcm xs = head . filter (\m -> all ((== 0) . rem m) xs) $ [1..] in lcm [1..10]
18:36:55 <lambdabot>   2520
18:36:58 <shrughes> > let lcm xs = head . filter (\m -> all ((== 0) . rem m) xs) $ [1..] in lcm [1..20]
18:37:14 <lambdabot>   thread killed
18:37:23 <sbahra> heh
18:37:40 <Olathe> @hoogle intersection
18:37:41 <lambdabot> Data.IntMap intersection :: IntMap a -> IntMap b -> IntMap a
18:37:41 <lambdabot> Data.IntSet intersection :: IntSet -> IntSet -> IntSet
18:37:41 <lambdabot> Data.Map intersection :: Ord k => Map k a -> Map k b -> Map k a
18:37:51 <sbahra> @hoogle google
18:37:51 <lambdabot> Google rocks!
18:37:51 <lambdabot> package GoogleChart
18:37:51 <shrughes> > let lcm xs = head . filter (\m -> all ((== 0) . rem m) xs) $ [1..] in lcm [1..10] * 11 * 13 * 17 * 19 * 2
18:37:54 <lambdabot>   232792560
18:38:08 <sbahra> There is a GoogleChart package?
18:38:10 <sbahra> that is amazing
18:38:13 * sbahra checks online
18:38:24 <sbahra> wow
18:39:13 <luqui> > let lcms = foldl lcm 1 in lcm [1..10] * 11 * 13 * 17 * 19 * 2
18:39:15 <lambdabot>       No instance for (Integral [t])
18:39:15 <lambdabot>        arising from a use of `lcm' at <i...
18:39:19 <luqui> > let lcms = foldl lcm 1 in lcms [1..10] * 11 * 13 * 17 * 19 * 2
18:39:21 <lambdabot>   232792560
18:39:52 <Olathe> > let intersection [] _ = []; intersection _ [] = []; intersection xxs@(x:xs) yys@(y:ys) = if (x == y) then x:intersection xs ys else if (x < y) then intersection xs yys else intersection xxs ys in intersection [1, 2, 3] [3, 4, 5]
18:39:53 <lambdabot>   [3]
18:40:28 <Olathe> @let intersect [] _ = []; intersect _ [] = []; intersect xxs@(x:xs) yys@(y:ys) = if (x == y) then x:intersect xs ys else if (x < y) then intersect xs yys else intersect xxs ys
18:40:29 <lambdabot>  <local>:3:95:
18:40:29 <lambdabot>      Ambiguous occurrence `intersect'
18:40:29 <lambdabot>      It could refer to e...
18:40:38 <Olathe> @src intersect
18:40:38 <lambdabot> intersect = intersectBy (==)
18:40:41 <Olathe> Heh
18:40:51 <sbahra> Olathe, what is yys@(y:ys)?
18:40:51 <Olathe> > intersect [1..3] [3..5]
18:40:53 <lambdabot>   [3]
18:41:04 <Olathe> sbahra: yys = (y:ys)
18:41:23 <sbahra> can i do
18:41:30 <sbahra> a@b@...?
18:41:31 <Olathe> f yys(y:ys) = ... -> f (y:ys) = let yys = (y:ys) in ...
18:41:38 <Olathe> I'm not sure.
18:41:41 <sbahra> ok
18:41:43 <rwbarton> sbahra: I think so...
18:41:47 <sbahra> good to know
18:41:49 <Olathe> > let f a@b@(x:xs) = a in f [1..5]
18:41:51 <lambdabot>   [1,2,3,4,5]
18:41:56 <Olathe> Looks like you can.
18:42:31 <Olathe> > let multiples x = iterate (+x) x in multiples 5
18:42:33 <lambdabot>   [5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110,115,12...
18:48:43 <bigtalk> ans5 = foldl lcm 1 [1..20]
18:48:51 <bigtalk> :t lcm
18:48:52 <lambdabot> forall a. (Integral a) => a -> a -> a
18:48:58 <shrughes> > product . map (floor . (`logBase` 20.5) . fromInteger) . takeWhile (<= 20) $ nubBy (((>1) .) . gcd) [2..]
18:48:59 <adu> hi bigtalk
18:49:00 <lambdabot>   8
18:49:03 <bigtalk> so how do i get integral in there?
18:49:42 <Olathe> > let primes = nubBy (\a b -> mod b a == 0) [2..] in primes
18:49:44 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
18:49:57 <adu> :t 1
18:49:58 <lambdabot> forall t. (Num t) => t
18:50:14 <Olathe> > let primes = nubBy (\a b -> mod b a == 0) [2..] in takeWhile (<=20) primes
18:50:15 <lambdabot>   [2,3,5,7,11,13,17,19]
18:50:58 <adu> bigtalk: what do you mean?
18:51:20 <adu> @pl (\a b -> mod b a == 0)
18:51:20 <lambdabot> flip flip 0 . ((==) .) . flip mod
18:51:33 <dmwit> ?pl (\a b -> 0 == mod b a)
18:51:33 <adu> @pl (\a b -> gdc b a > 1)
18:51:34 <lambdabot> flip flip 1 . ((>) .) . flip gdc
18:51:34 <lambdabot> ((0 ==) .) . flip mod
18:51:50 <dmwit> adu: It can be quite nice... if you give ?pl a few hints about commutativity. =)
18:52:02 <dmwit> ?pl \a b -> 1 < gcd b a
18:52:03 <lambdabot> ((1 <) .) . flip gcd
18:52:06 <Olathe> > let primes = nubBy (\a b -> mod b a == 0) [2..] in map (\n -> last $ takeWhile (<=x) $ iterate (*n) n) takeWhile (<=x) primes
18:52:07 <lambdabot>   Couldn't match expected type `[Expr]'
18:52:18 * luqui is still perpexed by (.) sections...
18:52:20 <Olathe> > let primes = nubBy (\a b -> mod b a == 0) [2..]; f x = map (\n -> last $ takeWhile (<=x) $ iterate (*n) n) takeWhile (<=x) primes in f 20
18:52:21 <lambdabot>   Couldn't match expected type `[a]'
18:52:38 <dmwit> luqui: Just track through the definition, say, twice, and you'll understand it forever after.
18:52:39 <adu> > let primes = nubBy (((>1).).gcd) [2..] in primes
18:52:41 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
18:52:52 <shrughes> > map (ap (^) (floor . (`logBase` 20.5)) . fromInteger) $ nubBy (((== 1) .) gcd) [2..]
18:52:54 <lambdabot>   Couldn't match expected type `Integer -> Bool'
18:53:09 <shrughes> > map (ap (^) (floor . (`logBase` 20.5)) . fromInteger) $ nubBy (((> 1) .) . gcd) [2..]
18:53:11 <luqui> dmwit, track through the definition?  By perplexed I mean I have a hard time "seeing" it, not that I don't know what it means...
18:53:12 <lambdabot>   [16.0,9.0,5.0,7.0,11.0,13.0,17.0,19.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1...
18:53:25 <shrughes> > product . map (ap (^) (floor . (`logBase` 20.5)) . fromInteger) . takeWhile (<= 20) $ nubBy (((> 1) .) . gcd) [2..]
18:53:27 <lambdabot>   2.3279256e8
18:53:35 <Olathe> > let primes = nubBy (\a b -> mod b a == 0) [2..]; f x = product $ map (\n -> last $ takeWhile (<=x) $ iterate (*n) n) $ takeWhile (<=x) primes in f 20
18:53:37 <lambdabot>   232792560
18:53:38 <dmwit> luqui: I know.  I'm saying, track through the definition, expanding the point-free version until you "see" it.
18:53:49 <dmwit> luqui: Each time you do that, you'll "see" it a step or two sooner. =)
18:54:01 <luqui> dmwit, good advice :-)
18:54:07 <shrughes> :t product . map (ap (^) (floor . (`logBase` 20.5)) . fromInteger) . takeWhile (<= 20) $ nubBy (((> 1) .) . gcd) [2..]
18:54:08 <lambdabot> forall b. (RealFrac b, Floating b) => b
18:54:35 <adu> bigtalk: what do you mean how do you "get" Integral?
18:54:45 <Olathe> > let primes = nubBy (\a b -> mod b a == 0) [2..]; f x = product $ map (\n -> last $ takeWhile (<=x) $ iterate (*n) n) $ takeWhile (<=x) primes in f 17
18:54:46 <lambdabot>   12252240
18:55:16 <dancor> when i do   ~ cabal haddock   in the yi-0.5.0.1 source dir, it says "can't find source for module Paths_yi"
18:55:18 <Olathe> @check let primes = nubBy (\a b -> mod b a == 0) [2..]; f x = product $ map (\n -> last $ takeWhile (<=x) $ iterate (*n) n) $ takeWhile (<=x) primes in \n -> n < 1 || f n = foldl1 lcm [1..n]
18:55:18 <lambdabot>   Parse error at "=" (column 165)
18:55:24 <Olathe> @check let primes = nubBy (\a b -> mod b a == 0) [2..]; f x = product $ map (\n -> last $ takeWhile (<=x) $ iterate (*n) n) $ takeWhile (<=x) primes in \n -> n < 1 || f n == foldl1 lcm [1..n]
18:55:25 <lambdabot>   "OK, passed 500 tests."
18:56:39 <dancor> is there a way to include dist/build/autogen in the search?  and shouldn't cabal do that anyway?
18:58:35 <Saizan_> dancor: did you build first or not? and what version of cabal are you using?
18:58:53 <dancor> Saizan_: yes, 1.4.0.2
18:59:59 <Saizan_> dancor: i think a workaround might be to add dist/build/autogen to hs-sources-dirs in the .cabal file
19:00:07 <dancor> ok
19:10:20 <harrison_partch> Well, that is a relief. I thought my xmonad would ot work but I did not know how to get a window. It does work.
19:10:34 <harrison_partch> Therefore I have switched to xmonad.
19:10:59 <harrison_partch> Tomorrow I will look for SDL demos.
19:11:03 <harrison_partch> Woo hoo.
19:12:47 <bigtalk> so how do i get integral in there?
19:12:53 <bigtalk> foldl lcm 1 [1..20]
19:13:04 <bigtalk> if i do: ans = foldl lcm 1 [1..20]
19:13:17 <bigtalk> i get complaint, No instance for (Integral (a -> a -> a))
19:13:43 <dmwit> bigtalk: Maybe you should follow along with a tutorial or something.  Have you found a good one yet?
19:14:26 <adu> bigtalk: what do you mean "get integral in there"?
19:15:44 <dancor> bigtalk: is   lcm :: Int -> Int -> Int  ?
19:16:06 <dancor> it should compile if it is, like this does e.g.:
19:16:11 <dancor> > foldl (+) 1 [1..20]
19:16:12 <lambdabot>   211
19:16:31 <dancor> maybe adding that type annotation to lcm would help
19:16:31 <sbahra> bigtalk, I suggest you look at "Real World Haskell", you can read it for free online
19:16:50 <sbahra> bigtalk, a great book is "Haskell: The Craft of Functional Programming" by Simon Thompson
19:18:01 <Saizan_> ?type lcm
19:18:03 <lambdabot> forall a. (Integral a) => a -> a -> a
19:18:08 <adu> > foldl lcm 1 [1..20]
19:18:10 <lambdabot>   232792560
19:18:19 <adu> bigtalk: what was the error you got?
19:18:41 <Saizan_> bigtalk: did you redefine lcm perhaps?
19:19:41 <dancor> bigtalk: puttting in the annotation   ans :: Int   should get you a more informative error too
19:19:43 <adu> bigtalk: what version/compiler are you using?
19:19:44 <sbahra> any work being done on a hardware abstraction layer for Haskell?
19:19:50 <sbahra> Maybe bindings to HAL?
19:20:34 <dancor> bigtalk: maybe you did   print lcm   instead of   print ans   ?
19:20:49 <dancor> or something like
19:20:50 <dancor> that
19:20:54 <adu> dancor: then it would say no instance of Show
19:20:58 <dancor> ya
19:21:05 <dancor> > lcm + 4
19:21:06 <lambdabot>       No instance for (Num (a -> a -> a))
19:21:06 <lambdabot>        arising from the literal `4'...
19:24:42 <adu> i did it
19:24:45 <adu> i got the error
19:24:57 <adu> > let ans = foldl lcm 1 in ans [lcm]
19:24:58 <lambdabot>       No instance for (Integral (a -> a -> a))
19:24:58 <lambdabot>        arising from a use of `...
19:25:11 <adu> yey :)
19:25:23 <dancor> is this like code golf
19:25:47 <dancor> @ghc
19:25:47 <lambdabot> ghc says: Kinds don't match in type application
19:25:58 <dancor> make that one in 10 chars or less
19:26:11 <sbahra> @ghc
19:26:12 <lambdabot> ghc says: Precedence out of range
19:26:21 <sbahra> Precedence out of range?
19:26:27 <adu> > 1 lcm
19:26:28 <lambdabot>       No instance for (Num ((a -> a -> a) -> a1))
19:26:28 <lambdabot>        arising from the lit...
19:27:15 <harrison_partch> ?
19:27:19 <bigtalk> i use gc 6.8.3
19:27:30 <bigtalk> i use ghc-6.8.3
19:27:44 <bigtalk> havent redefined lcm
19:28:04 <adu> bigtalk: that should be good...
19:28:13 <dancor> > infxr 100 `foo`
19:28:13 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
19:28:13 <lambdabot>  ...
19:28:19 <dancor> > infixr 100 `foo`
19:28:19 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 8}
19:28:19 <lambdabot>  ...
19:28:50 <adu> > import import
19:28:50 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 8}
19:28:50 <lambdabot>  ...
19:29:07 <adu> > fromMaybe 12
19:29:07 <lambdabot>       Overlapping instances for Show (Maybe t -> t)
19:29:08 <lambdabot>        arising from a use...
19:29:23 <adu> > 1 1 1
19:29:24 <lambdabot>       No instance for (Num (t -> t1 -> a))
19:29:24 <lambdabot>        arising from the literal `1...
19:29:45 <sbahra> bigtalk, you could show us the code on hpaste.org?
19:29:45 <adu> > 1 `recip` 1
19:29:46 <lambdabot>       No instance for (Fractional (t -> a))
19:29:47 <lambdabot>        arising from a use of `rec...
19:30:23 <adu> dancor: I give up, how do you make a kind error?
19:31:28 <rwbarton> > 0 :: Maybe Maybe
19:31:29 <lambdabot>       `Maybe' is not applied to enough type arguments
19:31:29 <lambdabot>      Expected kind `*',...
19:32:04 <adu> woah does that mean you can define instances for Num (Int -> Int)?
19:32:06 <sbahra> 0 :: Maybe
19:32:10 <sbahra> > 0 :: Maybe
19:32:11 <lambdabot>       `Maybe' is not applied to enough type arguments
19:32:11 <lambdabot>      Expected kind `?',...
19:32:18 <sbahra> Kind '*'? Kind '?'?
19:32:44 <adu> > Nothing :: State
19:32:45 <lambdabot>       `State' is not applied to enough type arguments
19:32:45 <lambdabot>      Expected kind `?',...
19:32:57 <adu> > 0 :: IO IO IO
19:32:58 <lambdabot>       Kind error: `IO' is applied to too many type arguments
19:32:58 <lambdabot>      In the type...
19:33:00 <ddarius> :k (->)
19:33:01 <lambdabot> ?? -> ? -> *
19:33:06 <sbahra> a kind error
19:33:17 <sbahra> > 0 :: Maybe Maybe Maybe
19:33:18 <lambdabot>       Kind error: `Maybe' is applied to too many type arguments
19:33:18 <lambdabot>      In the t...
19:33:31 <dmwit> > 0 :: Maybe (Maybe (Maybe Int))
19:33:32 <lambdabot>       No instance for (Num (Maybe (Maybe (Maybe Int))))
19:33:32 <lambdabot>        arising from t...
19:33:34 <adu> yey I did it :)
19:33:42 <sbahra> adu, did what?
19:33:47 <ddarius> adu: Of course you can.
19:33:55 <dmwit> adu: Yes, there's an instance for Num (Int -> Integer) or so.
19:34:01 <dmwit> adu: It's very useful.
19:34:04 <ddarius> Well, with a very mild extension.
19:34:04 <dmwit> > pi :: CReal
19:34:05 <adu> I made a type error! yey!
19:34:06 <lambdabot>   3.1415926535897932384626433832795028841972
19:34:10 <sbahra> haha
19:34:13 <adu> er, kind error
19:34:16 <sbahra> ye
19:34:36 <sbahra> What does it mean, Expected kind `*'?
19:34:43 <sbahra> versus Expected kind `?'
19:35:06 <sbahra> ahh
19:36:09 <adu> > 0 :: Int Int
19:36:09 <lambdabot>       Kind error: `Int' is applied to too many type arguments
19:36:10 <lambdabot>      In the typ...
19:36:14 <adu> yes!
19:36:27 <luqui> The kind ? I believe also includes unboxed types
19:37:05 <adu> :k ST
19:37:06 <lambdabot> * -> * -> *
19:37:10 <adu> :k State
19:37:12 <lambdabot> * -> * -> *
19:37:18 <adu> :k Either
19:37:19 <lambdabot> * -> * -> *
19:37:30 <adu> :k Array
19:37:31 <lambdabot> * -> * -> *
19:37:39 <adu> this is boring
19:37:42 <luqui> lol
19:37:52 <dolio> :k ByteArray#
19:37:53 <lambdabot>     Not in scope: type constructor or class `ByteArray#'
19:38:04 <dmwit> :k Data.ByteString.ByteArray#
19:38:05 <lambdabot>     Not in scope:
19:38:05 <lambdabot>       type constructor or class `Data.ByteString.ByteArray#'
19:38:11 <dolio> :k Int#
19:38:12 <lambdabot> Not in scope: type constructor or class `Int#'
19:38:13 <dmwit> ?index ByteArray#
19:38:14 <lambdabot> bzzt
19:38:20 <sbahra> ah, cool
19:38:22 <dolio> We don't have anything fun imported anymore. :)
19:38:22 * luqui likes agda.   :t Int => Set.  :t Set => Set1.  :t Set1 => Set2.  :t Set2 => Set3.  ...  much more interesting
19:38:46 <luqui> :k (# Int,Int #)
19:38:47 <lambdabot> (#)
19:38:52 <adu> luqui: really, where are you reading this?
19:39:10 <luqui> adu, the ? thing.  I think it was explained to me in irc a few months ago.
19:39:19 <adu> luqui: no the agda thing
19:39:28 <luqui> adu, experience?
19:39:29 <adu> luqui: I am 110% interested in Agda
19:39:43 <luqui> go play with it then
19:40:20 <sbahra> What is the difference between agda and coq?
19:40:35 <luqui> One big difference is that I like coq better :-)
19:40:54 <luqui> (there are not a whole lot of differences.  I believe coq is more flexible in terms of the logics it can model, but I am not certain, since I don't know agda that well)
19:41:18 <adu> luqui: I like prolog
19:41:25 <adu> luqui: is coq anything like it?
19:41:27 <luqui> that.... is a totally different ball game
19:41:30 <sbahra> ye
19:41:55 <sbahra> adu, http://coq.inria.fr/
19:41:58 <luqui> Coq is *much* more similar to haskell than to prolog, even though it is about "logic"
19:42:06 <lambdabot> Title: The Coq proof assistant
19:42:33 <luqui> maybe it's something like lambda prolog.  I have never used it.
19:43:41 * sbahra wants to learn prolog
19:43:46 <luqui> actually that's something that's on my list.
19:43:48 <sbahra> My next stop after Haskell.
19:43:50 <dmwit> No time like the present.
19:43:50 * luqui goes and learns lambda prolog
19:44:00 <Beelsebob> luqui: I figured out the algorithm
19:44:10 <adu> sbahra: I know a bit about prolog, I write a puzzle solver in it once
19:44:20 <luqui> Beelsebob, cool.  I couldn't sleep last night because I was thinking of ways to do it. :-)
19:44:22 <Saizan_> i guess you could say that the main difference is that haskell and coq are based on intutionistic logic, while prolog on classical logic
19:44:32 <luqui> didn't come up with anything conclusive ; i never do when I'm lying in bed
19:44:47 <ddarius> Saizan_: At the level Prolog is at, it hardly matters.
19:44:48 <Beelsebob> brb luqui and I'll tell you
19:44:54 <luqui> Beelsebob, have you written it up somewhere?  if not, can you  summarize the essence
19:44:57 <luqui> Beelsebob, okay
19:45:27 <sbahra> ddarius, what do you mean?
19:45:31 <adu> Saizan_: I don't know the difference between the two, so it doesn't matter to me
19:45:37 <sbahra> Saizan_, classical logic can be modeled on Coq, no?
19:45:49 <luqui> sbahra, yep.
19:45:56 <luqui> and Prolog is constructive, AFAICT
19:46:06 <ako_0_> What practical applications does Haskell have, outside of academia?
19:46:07 <sbahra> which seems intuitionistic to me
19:46:08 <luqui> though it is hard to tell, again, at prolog's level
19:46:27 <luqui> ako_0_, it's a very good programming language
19:46:28 <sbahra> > let True --> True = True; False --> True = True; False --> False = True; True --> False = False in do p <- [True,False] ; return ((not p --> p) --> p)
19:46:29 <lambdabot>   [True,True]
19:46:45 <luqui> ako_0_, so it has all the applications of other good programming languages
19:46:50 <adu> ako_0_: saving lives, telecommunications, high assurance security, youtube, microsoft, and computer generated graphics
19:46:58 <luqui> (the more you learn haskell, the more you convince yourself that there are no others :-)
19:47:02 <ako_0_> Ha!
19:47:07 <adu> luqui: no other what's?
19:47:19 <Saizan_> sbahra: yeah, even in haskell with Cont
19:47:20 <luqui> good PLs :-)
19:47:42 <adu> luqui: there are plenty of good PLs other than Haskell, but none better :)
19:47:54 <luqui> I used to think that too.
19:47:57 <ako_0_> How does it particularly shine, in practical application, where other languages do not?
19:47:58 <luqui> =P
19:48:02 <sbahra> PLs?
19:48:04 <sbahra> Oh
19:48:07 <sbahra> Programming languages
19:48:18 <adu> ako_0_: brevity
19:48:21 <dmwit> ako_0_: It has parametric polymorphism, excellent compositionality, and its pattern-matching facilities are very nice.
19:48:56 <sbahra> oh
19:49:00 <sbahra> you used the word i was looking for
19:49:08 <sbahra> i was going along the lines of "composability"
19:49:27 <sbahra> compositionality
19:49:31 <dmwit> It's fast and powerful, it has a very easy interface to C (which means you can find libraries for it), laziness, and referential transparency to guide whole-program reasoning.
19:49:35 <adu> ako_0_: it is particularly well suited for complicated algorithms, and for very easy to read parsers
19:49:58 <sbahra> ako_0_, good performance
19:50:09 <luqui> adu, you think that is haskell's strength, parsers?  ha!
19:50:24 <adu> ako_0_: o ya, its #1 on the language shootout for 2 threading tests
19:50:31 <sbahra> ako_0_, http://shootout.alioth.debian.org/u32/
19:50:32 <lambdabot> Title: Ubuntu : Intel® Q6600® Computer Language Benchmarks Game
19:50:33 <ako_0_> Oh, cool
19:50:34 <dmwit> luqui: Compared to, say, Python?  Sure!
19:51:00 <sbahra> ako_0_, in fact, for some software I'm developing (recently), I decided to switch to haskell 3K LoC in ;-p
19:51:05 <adu> luqui: have you ever used Parsec? its beautiful!
19:51:06 <luqui> dmwit, yeah, it's just a bit too specific for me.
19:51:28 <luqui> adu, hahahaha.   it's beautiful until you use try.
19:51:46 <luqui> then it's awful.  but I'm not saying that haskell is not good at parsers
19:51:46 <bigtalk> adu: is haskell use at youtube,in telecom?
19:51:50 <dmwit> luqui: It's beautiful if the language you're parsing is beautiful.
19:51:55 <sbahra> luqui, try?
19:52:05 <dmwit> luqui: If the language you're parsing isn't beautiful, nothing you use can possibly change that. ;-)
19:52:11 <luqui> I'm saying haskell's strength is ever so slightly way larger than parsers :-)
19:52:25 <dmwit> I'm definitely in agreement with you. =D
19:52:31 <luqui> dmwit, but what if it is beautiful in a not LL(1) way?
19:52:46 <dmwit> Parsec is LALR(k).
19:52:49 <adu> bigtalk: well, yes and no, youtube rewrote some of their stuff in Haskell, but Ericsson is well known for Erlang (similar to Haskell)  in which they write all of their telecom stuff
19:53:03 <sbahra> adu, cool
19:53:03 <ddarius> dmwit: k can be arbitrarily large
19:53:10 <sbahra> adu, what stuff did youtube rewrite in haskell?
19:53:11 <dmwit> Yes, I know.
19:53:15 <ddarius> And not fixed ahead of time
19:53:30 <adu> sbahra: I don't know, I remember it being on h.o a while back
19:53:39 <sbahra> A friend @Google was complaining that Haskell was becoming too popular :-P
19:53:45 <dmwit> I'm saying it's ever slightly way better than LL(1). =)
19:54:09 <ddarius> In fact, it easy to parse context sensitive things with Parsec.  (Technically, you can parse anything parsable by a Turing machine, but then that starts to get very meaningless.)
19:55:42 <luqui> okay, maybe I'm mistaken, but I was referring to the beautiful, try-free subset of parsec, and assuming independent rules
19:55:57 <luqui> of course there are dependent rules, which you can magically code and pass information around to do any turing complete thing
19:56:07 <luqui> but I'm saying *in essence*, without try, parsec is LL(1)
19:56:17 <dmwit> Uh.
19:56:18 <dmwit> No?
19:56:23 <luqui> dmwit, do tell.
19:56:39 <dmwit> I mean...
19:57:25 * dmwit tries to remember the exact difference between LL(1) and LALR(k)
19:58:04 <luqui> it's most likely not an LALR class, because it is a top-down parser
19:58:23 <dmwit> Yeah, I guess you're right.
19:58:33 <dmwit> If you throw out try, you're not left with very many options.
19:59:18 * luqui has been wanting to write an Haskellian earley parser for a while
19:59:52 <ddarius> There are already a couple of GLR parsers
20:00:22 <dancor> is there a way to reduce the escape timeout in yi
20:02:25 <luqui> ddarius, can you point me to one.  my hackage scan came up nil
20:02:53 <ddarius> frown and happy both have GLR modes
20:04:18 * luqui doesn't consider happy very haskellian, fwiw, but thanks
20:04:36 <ddarius> http://wiki.di.uminho.pt/twiki/bin/view/Research/PURe/HaGLR
20:05:23 <bigtalk> http://hpaste.org/10883 , how do i return a value froma monad?
20:06:00 <dmwit> :t return
20:06:01 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
20:06:19 <dmwit> bigtalk: Oh, stick a ($) in there.
20:06:22 <TSC> bigtalk: You might need some parens; return (...)
20:06:30 <dmwit> bigtalk: Function application binds to the left, so that parses as
20:06:51 <dmwit> ((return DBC.split) '\n') pyramid
20:07:02 <bigtalk> p = DBC.split '\n' (DBC.readFile "C:/users/saftarn/desktop/datasets/euler18.txt"
20:07:05 <dmwit> (Note that "return" is just a function, not a keyword.)
20:07:27 <bigtalk> ah see
20:08:03 <ivanm> can qualified imports have filtering on what they're importing (e.g. hiding, etc.)?
20:08:17 <dmwit> yes
20:12:25 <bigtalk> and hot to do ByteString -> Int?
20:12:53 <bigtalk> how
20:13:31 <luqui> read . unpack
20:13:45 <bigtalk> an d string -> bytestring?
20:13:59 <dmwit> Look at the documentation.
20:14:01 <luqui> uh.  see docs.  I have not used bytestring actually
20:14:06 <dmwit> It's in there. ;-)
20:14:31 <dmwit> Oh, though you might have to look in the ByteString.Char8 docs or something like that.
20:23:24 <Asztal> @pl 6.001
20:23:24 <lambdabot> 6 . 1
20:24:59 <ivanm> "Because they are allowed to be mutually recursive" <-- (from the report) does this mean module A can import module B, which imports module A?
20:25:12 <Saizan_> yes
20:25:12 <dolio> Per the report, yes.
20:25:30 <dolio> Good luck finding a compiler that allows that that simply.
20:26:03 <dmwit> GHC does.
20:26:11 <dmwit> Look up .hs-boot (.hs_boot?) files.
20:26:22 <joed> The search of that..
20:26:23 <dolio> Yeah, you need to do extra work.
20:26:35 <dmwit> Not much.  A hint about where to start the topo-sort.
20:29:20 * luqui loathes .hs-boot files
20:30:15 <luqui> but mutually recursive modules are typically a red flag of poorly thought-out module layout.   However there are cases where it might be the best, and GHC *should* just figure it the fsck out for you
20:41:59 <bigtalk> what is the problem with mutual ecursion?
20:42:42 <dmwit> Read carefully: mutually recursive *modules*.
20:43:03 <dmwit> There's nothing inherently wrong about it, but it can be hard to reason about as a programmer.
20:43:42 <dolio> Causes problems with separate compilation, too.
20:44:00 <dolio> I've heard, at least.
20:58:21 <bigtalk> parse18 :: IO [[Int]] , i want to use that ina normal fucntion, is that impossible?
20:59:02 <bigtalk> Couldn't match expected type `[a]'
20:59:02 <bigtalk>            against inferred type `IO [[Int]]'
20:59:02 <dmwit> Yes.
20:59:07 <bigtalk> when doing heasd
20:59:09 <bigtalk> head
20:59:14 <dmwit> Yes, it is impossible.
20:59:24 <dmwit> However, you can bring your function up into the IO monad.
20:59:27 <dmwit> :t (>>=)
20:59:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
20:59:36 <dmwit> :t liftM
20:59:38 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
20:59:42 <dmwit> These two will help you do that.
20:59:47 <Saizan_> bigtalk: do list <- parse18; return (head list)
21:00:02 <dmwit> Or use do notation, yeah.
21:00:47 <Saizan_> the real answer is to read a tutorial on monads, or at least on introduction to IO
21:01:14 <bigtalk> so there is just no way of ever doing file io then using that result ina  normal pure function?
21:01:33 <bigtalk> at least without a lot of trouble and a lot of anti-idiomativ haskell
21:01:44 <TSC> Not safely
21:01:51 <TSC> I/O isn't pure
21:07:55 <Axman6> what, unsafePerformIO isn;t pure? :o
21:11:00 <luqui> bigtalk, what you say is not true
21:11:11 <luqui> that is definitely possible
21:11:40 <luqui> what is not possible is doing some IO "within" a pure function.  but you can certainly *use* results from IO in pure functions, it's just that your usage will not itself be a pure function
21:12:51 <luqui> it's exactly the same as if you declared functions in eg. C++ to be "pure" if they don't have (or depend on) side-effects.  Haskell just has a bias toward pure functions :-)
21:13:19 <ivanm> I have a list of values [a], and I want to apply a function f :: [b] -> a -> b to them, where it takes in the function applied to every other value in that list... is such a thing possible?
21:13:55 <luqui> ivanm, I don't really know what you're asking.  more concrete terms maybe?
21:13:59 <luqui> (or give a concrete example)
21:14:01 <bd_> er, the type doesn't make sense...?
21:14:19 <bd_> unless those are different variables in the two type equations
21:15:08 <Saizan_> ?type \f xs -> let rs = map (f rs) xs in rs
21:15:10 <lambdabot> forall a b. ([b] -> a -> b) -> [a] -> [b]
21:15:29 <Saizan_> now it's a matter of how lazy f is
21:15:32 <luqui> Saizan_, cool :-)
21:15:45 <ivanm> luqui: OK, I'm parsing haskell source files using haskell-src-exts... I want to parse each file into a datatype which contains the export list, as well as which functions are called from which other module... but for the latter, I need to have the export list for all other modules
21:15:49 <luqui> that's probably not what he was going for...
21:15:56 <bd_> okay, now that's a neat trick :) but probably not what ivanm wanted...
21:16:25 <ivanm> Saizan_: actually, that might do it...
21:16:27 <Saizan_> it's what he wants, it seems :)
21:16:30 <bd_> heh
21:16:30 <luqui> yay!
21:16:32 <ivanm> f should be pretty lazy ;-)
21:16:54 <ivanm> (actually, I'm thinking of using a set or map rather than a list, but that shouldn't make a difference, should it?)
21:17:26 <dmwit> Sets/Maps are spine-strict.
21:17:33 <Saizan_> yeah
21:17:46 <ivanm> dmwit: which means?
21:17:47 <Saizan_> but it still depends on how f is going to use the parameter
21:18:05 <dmwit> ivanm: For Maps, it means it's strict in the keys; for Sets, it's strict in the values.
21:18:19 <dmwit> Set v ~= Map v ()
21:18:25 <ivanm> which means they all have to be evaluated first?
21:18:39 <ivanm> for keys in the map, that won't be a problem
21:18:40 <dmwit> Pretty much, yeah.
21:18:41 <Saizan_> ivanm: if you force the set, yes
21:19:12 <sbahra> Bad interface file: /usr/local/lib/ghc-6.8.3/lib/time-1.1.2.1/Data/Time/Calendar.hi
21:19:13 <sbahra>     magic number mismatch: old/corrupt interface file?
21:19:13 <sbahra> Prelude> Segmentation fault: 11 (core dumped)
21:19:18 * sbahra wonders if his laptop has been on for too long
21:19:20 <ivanm> (well, the only reason I was thinking of using a map was to avoid traversing the whole list for a lookup)
21:19:30 <ivanm> sbahra: :o
21:19:40 <ivanm> I've only ever seen magic number mismatches for haddock parsing...
21:19:50 <sbahra> This happens to me here and there
21:20:15 <luqui> @djinn (Maybe b -> a -> b) -> Maybe a -> Maybe b
21:20:16 <lambdabot> f a b =
21:20:16 <lambdabot>     case b of
21:20:16 <lambdabot>     Nothing -> Nothing
21:20:16 <lambdabot>     Just c -> Just (a (Just (a Nothing c)) c)
21:20:23 <Saizan_> ivanm: btw, this technique is called tying the knot http://www.haskell.org/haskellwiki/Tying_the_Knot
21:20:25 <lambdabot> Title: Tying the Knot - HaskellWiki
21:20:45 <ivanm> oh, is _that_ what tying the knot refers to?
21:21:13 <Saizan_> yeah, a value defined in terms of itself
21:21:17 <luqui> that is a very strange choice of function, djinn.
21:21:55 <ivanm> ummmm.... isn't that djinn function the wrong way round?
21:22:05 <ivanm> shouldn't the first parameter be Maybe, not the second?
21:22:21 <luqui> ivanm, the first parameter has type (Maybe b -> a -> b), the second has type Maybe a
21:22:21 <bd_> :t \a b -> case b of Nothing -> Nothing; Just c -> Just (a ( Just (a Nothing c))c )
21:22:23 <lambdabot> forall t a. (Maybe a -> t -> a) -> Maybe t -> Maybe a
21:22:29 <bd_> ^^^ it's fine
21:22:30 <ivanm> duh, misread it
21:22:42 <ivanm> I was thinking f was the first parameter :s
21:23:00 * luqui made that mistake briefly, too
21:23:21 <ivanm> but applying a on itself is a bit weird...
21:24:10 <Saizan_> at least that f is more interesting than f _ _ = Nothing :)
21:24:28 <dmwit> Huh.
21:24:32 <dmwit> Any Gtk experts here?
21:24:44 <ivanm> Saizan_: heh
21:24:50 <dmwit> I'm using drawWindowGetPointer, and it's returning Nothing when the pointer is *definitely* over the widget in question.
21:25:11 <dmwit> (From the docs: "The return value is Nothing if the mouse cursor is over a different application.")
21:25:18 <luqui> Saizan_, indeed.  I'm glad djinn tries to use all the parameters
21:25:30 * luqui 's @djinn:  f = fix id
21:25:47 <dmwit> ?djinn a
21:25:48 <lambdabot> -- f cannot be realized.
21:25:59 <dmwit> ?djinn Either a (Not a)
21:26:00 <lambdabot> -- f cannot be realized.
21:26:00 <ivanm> wow, that DList example on the tying the knot page is confusing me already :s
21:26:09 <dmwit> Intuitionist logic! =D
21:26:13 <ivanm> you're passing in a value that you get out of the same function? :s
21:26:15 <Saizan_> luqui: that's unsound too! :)
21:26:25 <luqui> yep
21:26:31 <ivanm> is Not even a type?
21:26:38 <rwbarton> ?djinn Not (Not (Either a (Not a)))
21:26:38 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
21:26:41 <dmwit> type Not a = a -> Void
21:26:45 <ivanm> @hoogle Not
21:26:46 <lambdabot> Prelude not :: Bool -> Bool
21:26:46 <lambdabot> Data.Bool not :: Bool -> Bool
21:26:46 <lambdabot> Data.Char NotAssigned :: GeneralCategory
21:26:52 <ivanm> heh
21:26:53 <luqui> where data Void   (has no constructors)
21:26:55 <dmwit> data Void
21:26:59 <dmwit> yep
21:27:15 <ivanm> hmmmm....
21:27:28 <ivanm> so Void ~= _|_ ?
21:27:30 <ivanm> or () ?
21:27:44 <Saizan_> in @djinn there's no _|_
21:27:45 <luqui> ivanm, yeah, the only element inhabiting Void is _|_
21:27:58 <luqui> and also what Saizan_ said
21:28:15 <dmwit_> It [Void] plays the role of False.  Therefore "Not a" is "a implies false", or "a -> Void".
21:28:21 <ivanm> Saizan_: so djinn's rabbit hole never ends? ;-)
21:28:42 <luqui> it's funny how wrong an analogy can be while still being correct...
21:28:47 * ivanm wants to know who came up with that circular doubly-linked list example
21:29:07 <luqui> djinn has no bottom precisely because nothing never ends :-)
21:29:14 <ivanm> heh
21:29:15 <luqui> how contradictory!
21:29:38 <Saizan_> there's also a good article on using tying the knot to write an assembler by roconnor in the monad reader
21:29:46 <dmwit> I suspect user error, but I'm finding it difficult to find the error...
21:29:51 <Axman6> luqui: that hurts my head >_<
21:29:58 <Axman6> i'm not even sure why
21:34:11 <ivanm> oh, _Oleg_ wrote the TyingTheKnot article... no wonder :p
21:34:31 <dmwit> http://hpaste.org/10884
21:39:40 <eck> when i'm writing the type signature for a function, how do I say that some type a is the instance of two different type classes? (e.g. i'm looking for the syntax for something like :: Foo a, Bar a => a -> a)
21:39:54 <dmwit> (Foo a, Bar a) => a -> a
21:40:05 <dmwit> You were damn close.
21:40:09 <eck> thanks
21:40:11 <eck> i know
21:43:06 <ivanm> can modules import each other recursively? I thought you couldn't have any loops/cycles (how do you know in which order to compile them?), but the report seems to indicate that you can: "Because they are allowed to be mutually recursive, modules allow a program to be partitioned freely without regard to dependencies."
21:43:19 <dmwit> Hmm, I wonder what drawWindowGetPointer really does.  There's a widgetGetPointer, too...
21:44:36 <mjrosenb> ivanm: there's a way of breaking cycles
21:44:44 <ivanm> mjrosenb: oh? how?
21:44:47 <mjrosenb> ivanm: basically you compile one then the other then the first
21:44:56 <ivanm> ahhh
21:44:59 <mjrosenb> and the first time around, you give a magic flag
21:45:12 <mjrosenb> that says don't worry about any modules
21:45:19 <ivanm> ghci mustn't be able to do this then...
21:45:41 <selmanj> hi, can someone tell me what the haskell equivalent of the psuedocode at http://hpaste.org/10885 would be?  I'm having trouble figuring out how to go about doing it.
21:46:23 <sbahra> Looks like homework.
21:46:43 <selmanj> It's not.  I wrote that myself
21:46:46 <sbahra> What are f1, f2, f3?
21:46:56 <selmanj> Tests on s
21:47:00 <sbahra> ok
21:48:37 <selmanj> variables are immutable, right?  i couldn't do 'let x = 5' and then later in an if statemnet say 'let x = x + 2'
21:48:44 <TSC> Instead of thinking about the states of x,y,z changing, think of it as: "if f1(s), then x is 0.8, otherwise x is 0"
21:48:45 <dmwit> What are the values of x, y, and z if those tests fail?
21:48:55 <dmwit> right
21:49:04 <luqui> selmanj, you *could*, but it would mean "let x be an infinite loop", not "add 2 to x"  :-)
21:49:17 <dmwit> > let x = x + 2 in x
21:49:19 <lambdabot>   * Exception: stack overflow
21:49:22 <dmwit> What?
21:49:29 <dmwit> Where's my Exception: <<loop>>?
21:49:32 <selmanj> 2 + 2 + 2 +...
21:49:33 <selmanj> i see
21:49:35 <dmwit> > let bot = bot in bot
21:49:38 <luqui> dmwit, doesn't happen in interpreted mode
21:49:42 <moonpatio> i fixed the `src' function in lunabot and got it running on on my webhosted machine, so it can run when my laptop's not on
21:49:49 <moonpatio> , src ''Monad
21:49:50 <lambdabot>   thread killed
21:49:52 <luqui> dmwit, I guess you just made a zombie process
21:49:52 <moonpatio> haha
21:49:54 <lunabot>  class Monad m where
21:49:54 <lunabot>          (>>=) :: forall b a . m a -> a -> m b -> m b
21:49:54 <lunabot>          (>>) :: forall b a . m a -> m b -> m b
21:49:56 <moonpatio> , src ''Monad
21:50:02 <lunabot>  Killed.
21:50:07 <moonpatio> um
21:50:19 <dmwit> Whoa, your nick.
21:50:46 <luqui> selmanj, so your function is not that hard to write, it's just not a transliteration.
21:50:55 <selmanj> so instead i'd do something like
21:51:01 <luqui> selmanj, for example, how would you *define* x?
21:51:16 <selmanj> getP(s) = g1(s) + g2(s) + g3(s)
21:51:31 <moonpatio> oh, yeh i'm vnc'ed into here and just installed xchat
21:51:33 <selmanj> where g1(s) looks like if f1(s) then .8 else 0 ?
21:51:40 <dmwit> selmanj: Right!
21:51:53 <selmanj> that makes sense.  damnit why didn't i figure this out myself!
21:51:55 <dmwit> selmanj: You can even write g1 as local functions using a "where" clause.
21:51:58 <luqui> selmanj, you did
21:52:00 <mmorrow> , src ''Monad
21:52:05 <lunabot>  Killed.
21:52:06 <selmanj> well, before asking on irc i mean :)
21:52:15 <luqui> mmorrow, what are you doing over there?
21:52:27 <luqui> no worries, come for help anytime :-)
21:52:51 <mmorrow> getting lunabot working here
21:53:01 <mmorrow> , src ''Monad
21:53:06 <lunabot>  class Monad m where
21:53:06 <lunabot>          (>>=) :: forall b a . m a -> a -> m b -> m b
21:53:06 <lunabot>          (>>) :: forall b a . m a -> m b -> m b
21:53:09 <mmorrow> yesh!
21:53:20 <mmorrow> ok out
21:53:20 <rwbarton> nice
21:53:53 <luqui> does lunabot use TH for src?
21:54:24 <rwbarton> yes
21:54:27 <luqui> cool!
21:54:51 * luqui has an impulse to do let x = 42 in , src x   :-)
21:55:31 <luqui> , src 'Just
21:55:36 <lunabot>  luna: Not in scope: type constructor or class `Just'
21:55:37 <luqui> , src Just
21:55:39 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Name'
21:55:39 <lunabot>         against inferred type `a -> Data.Maybe.Maybe a'
21:55:49 <luqui> aww
21:58:56 <rwbarton> , $( do x <- reify 'Just; return $ LitE $ StringL $ show x )
21:58:58 <lunabot>  "DataConI Data.Maybe.Just (ForallT [a_1627417168] [] (AppT (AppT ArrowT (...
22:01:13 <rwbarton> , $( do DataConI _ _ x _ <- reify 'Just; return $ LitE $ StringL $ show (src x) )
22:01:17 <lunabot>  "data Maybe a = Nothing\n             | Just a\n"
22:06:28 <luqui> , let x = 42 in $( do DataConI _ _ xr _ <- reify 'x; return . LitE . StringL . show $ src xr )
22:06:32 <lunabot>  luna: Pattern match failure in do expression at <interactive>:1:70-77
22:06:43 <luqui> oh right, it wouldn't be DataCon
22:10:23 <rwbarton> , text $ let l = lines $( do ClassOpI _ _ x _ <- reify '(**); return $ LitE $ StringL $ show (src x) ) in unwords $ [head l, "..."] ++ filter (isPrefixOf "(**)" . dropWhile isSpace) l ++ ["..."]
22:10:28 <lunabot>  class (Fractional a) => Floating a where ...         (**) :: a -> a -> a ...
22:39:08 <dmwit> Man, Chipmunk is awesome!  Gtk2Hs, too.
22:40:55 <Axman6> dmwit: link?
22:41:07 <bigtalk> god haskell is a ain sometimes if i ahve inside a forM-do-return a variable that i want to update for every iteration depending on the result of the previous, how do wi write that?
22:41:11 <dmwit> To which, Chipmunk, Gtk2Hs, or the thing I'm playing with?
22:41:34 <dmwit> bigtalk: Maybe use foldM?
22:41:34 <Axman6> chipmunk. the physics thing?
22:41:39 <dmwit> yeah
22:41:55 <dmwit> http://wiki.slembcke.net/main/published/Chipmunk
22:41:58 <dmwit> ?hackage Hipmunk
22:41:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Hipmunk
22:42:00 <lambdabot> Title: Chipmunk in Main
22:44:07 <dmwit> bigtalk: But it's also likely that you should rethink your loop.
22:44:22 <dmwit> bigtalk: What are you trying to do?
22:45:03 <dons> bigtalk: update a global variable?
22:46:11 <crutcher> hey, I've got another weird peformance question. In http://hpaste.org/10886 why is fastMain 3 times faster than slowMain, even with -O2?
22:46:39 <dons> the best way to find out is to look at the core.
22:46:40 <crutcher> is the default IO buffering really that bad?
22:46:46 <dons> using a tool like ghc-core.
22:47:10 <bigtalk> http://hpaste.org/10887 , http://projecteuler.net/index.php?section=problems&id=18
22:47:13 <dmwit> crutcher: Try replicateM_
22:47:34 <dons> doesnn't look like buffering, looks like the IO [a] .
22:47:39 <dons> so yes, replicateM_
22:47:49 <dmwit> crutcher: Also, you might like readLn.
22:47:55 <dons> and not using getLine ? but using say, lazy bytestrings and integer reads
22:47:56 <dons> ?
22:47:58 <dmwit> readLn ~= getLine >>= return . read
22:48:27 <dons> this kind of code, http://shootout.alioth.debian.org/gp4/benchmark.php?test=sumcol&lang=ghc&id=6
22:48:30 <lambdabot> Title: sum-file Haskell GHC #6 program | Gentoo : Intel® Pentium® 4 Computer Language ..., http://tinyurl.com/ys3ony
22:48:44 <crutcher> okay, replicateM_ solves almost all of the difference
22:48:47 <bigtalk> ^^ i want to take the snd of choice and use that as the pos aprameter to next
22:48:58 <dons> they should yield identical core after optimisation
22:49:01 <Axman6> dmwit: you do like to plug ghc-core don;t you :P
22:49:02 <dmwit> bigtalk: You should be able to write the entire computation as a pure function.
22:49:05 <crutcher> thanks.
22:49:11 <Axman6> not that there's anything wrong with that
22:49:12 <dmwit> Axman6: eh?
22:49:20 <Axman6> uhm, dons i meant
22:49:24 <dmwit> ah
22:49:26 <scodil> has anyone here gotten gtk2hs working on the mac without X?
22:49:41 <dmwit> bigtalk: You should only need IO stuff for the... well... IO.  heh
22:50:00 <dmwit> s/computation/calculation/
22:50:07 <bigtalk> dmwit: true im confusing myself i thinl
22:52:20 <dons> sjanssen: http://shootout.alioth.debian.org/u64q/benchmark.php?test=chameneosredux&lang=all
22:52:23 <lambdabot> Title: chameneos-redux benchmark | x64 Ubuntu : Intel® Q6600® quad-core Computer Lang ..., http://tinyurl.com/6zcher
22:52:30 <Axman6> dmwit: did you see http://files.slembcke.net/chipmunk/movies/sketches.mov ?
22:52:47 <dmwit> Yep, really impressive!
22:52:55 <dons> sjanssen: so extra parallelism not helping.
22:53:07 <luqui> bigtalk, do you know about using the list monad for nondeterminism?
22:53:10 <dmwit> Axman6: Doesn't it just make you jealous of some people's programming cojones sometimes? =P
22:53:21 <Axman6> very much so
22:53:24 <dons> sjanssen: need to work on some of the others then, http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
22:53:25 <Axman6> that thing's insane :|
22:53:26 <lambdabot> Title: Create your own Ranking | x64 Ubuntu : Intel® Q6600® quad-core Computer Langua ..., http://tinyurl.com/55nbs6
22:53:28 <luqui> > do { x <- [1,2,3]; y <- [4,5,6]; return (x,y) }
22:53:29 <lambdabot>   [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
22:55:21 <luqui> yay in the default ranking Haskell is #3.  Can't complain :-)
22:55:41 <criso> ghc
22:55:44 * luqui wonders what the hell ATS is
22:57:17 <Axman6> some crazy language
22:57:19 <dmwit> It's a really ugly language.
22:57:23 <criso> yeah never heard of it
22:57:30 <dmwit> But the guy who wrote it/writes in it is genius.
22:57:31 <luqui> it has dependent types!
22:57:41 <dons> dependent types!
22:57:44 * luqui is intrigued
22:57:47 <dons> the last word in systems programming.
22:58:09 <dons> luqui: multicore is our enabler.
22:58:27 <Axman6> dmwit: see the pytamid one too?
22:58:30 <luqui> that can't be considered a bad thing :-)
23:01:35 <dmwit> Axman6: Yup, I was an avid consumer of neat videos when I discovered Chipmunk.
23:01:43 <dmwit> There's a few more cool ones in the forums and on YouTube.
23:01:59 <Axman6> i'll have a look for them, this stuff is awesome :o
23:02:11 <dmwit> (People post their projects in the forums when they're only half-finished.  They joke that the forums are where Chipmunk projects go to die. =)
23:02:44 * luqui wonders if it's even possible to have a traditional (l-r text) syntax that makes programs with so much type information readable
23:03:55 <dmwit> coq-libs: Conflicts: coq-doc # =(
23:05:00 <luqui> dmwit, trying to install coq?
23:05:05 <dmwit> yup
23:05:11 <luqui> gentoo?
23:05:21 <dmwit> The other "tu".
23:05:30 <dmwit> Ubuntu: the other untu.
23:05:31 <luqui> oh yeah?  hmm, that was totally smooth for me
23:05:51 <dmwit> N.B. I'm on Ubuntu 6.10
23:06:02 <luqui> oh, I didn't install coq-doc
23:06:18 <luqui> it's all available on the web anyway.
23:06:32 <dmwit> yeah
23:08:02 <luqui> coq (+ide) is the coolest thing I've seen for a while.  too bad its name, ehem, sucks.
23:08:12 <dmwit> Yeah!
23:08:15 <dmwit> What is up with that.
23:08:20 <luqui> how many coq extensions have you installed?  :-)
23:08:31 <TSC> I keep getting email about them
23:08:50 <dmwit> It's bad because it sounds like cock *and* because I always feel guilty about being immature every time that I think it sounds like cock.
23:09:08 <crutcher> has anyone tried to setup an internet coq theorem base?
23:09:13 <luqui> yep.   I always giggle when I tell people it's my favorite language...
23:09:26 <luqui> crutcher, that would be sweet.  hoogle for coq!
23:10:03 <crutcher> no, not to search by hand. I mean, you could do that. But mainly so that you could share computation with others.
23:10:16 <rwbarton> crutcher: A friend of mine is working on something like that, but using Isabelle, I think.  http://www.vdash.org/
23:10:19 <dmwit> coqhub
23:10:20 <luqui> (call it koogle, after the polish dish)
23:10:21 <lambdabot> Title: vdash: a wiki of formalized mathematics
23:10:22 <crutcher> Why re-prove a sub-theorem which has already been proved a lot.
23:10:49 <crutcher> vdash will count, imho, when it is more than a landing page.
23:10:55 <rwbarton> crutcher: Indeed.
23:11:03 <luqui> crutcher, I'm not sure I follow anymore.
23:11:20 <luqui> crutcher, you mean just trust that it's true if it came from the site, rather than checking it in the checker?
23:11:26 <bigtalk> question about euler18, for the bigger problem, since all paths cant be checked and there is no pattern then a heuristic rule must be used right?
23:11:29 <crutcher> I mean, the problem sounds very hard. Its one thing to say you want to work on it, and another to have anything that works.
23:11:32 <roconnor> luqui: http://helm.cs.unibo.it/ is Hoogle for Coq.
23:11:34 <lambdabot> Title: HELM Home Page
23:11:44 <roconnor> but it is offline at the moment :(
23:11:50 <roconnor> but there are sources :)
23:12:02 <roconnor> but the dependicies are complex :(
23:12:22 <crutcher> luqui: well, there are two approaches: 1 re-check locally (but with a guided check, and not a search, cheaper), or 2 use certified proofs (mathematically harder)
23:12:24 <luqui> that is hawt
23:12:57 <dmwit> bigtalk: No.
23:13:04 <dmwit> bigtalk: An exact solution is possible in a very fast way.
23:13:34 <luqui> crutcher, in fact all paths can be checked quite easily
23:13:51 <luqui> crutcher, brute force your way through this one, shouldn't take more than a second of computation time...
23:14:25 <luqui> (but as the problem mentions, the same problem arises later but with more data such that you can't brute force it)
23:14:25 <crutcher> I guess that depends on how complex a thing you ask to prove.
23:14:37 <luqui> what is a certified proof?
23:15:24 <luqui> btw why not just give the defn rather than the tactics?
23:15:40 <luqui> (defn = proof term)
23:15:49 <crutcher> there are certain proof forms for certain types of problems which can be proven to be correct with a very cheap check. In some branches of math. Its tricky.
23:16:33 <crutcher> of course, you could just trust the server.
23:16:38 <luqui> hm. anyway this is all just masturbation right?  computation time isn't actually a big issue... is it?
23:16:51 <crutcher> depends on what you want to prove.
23:17:01 <luqui> (I am still somewhat a noob, haven't done any proofs involving multiple libraries, etc.)
23:17:11 <dmwit> If you really want to prove it, you have to run the proof, probably.
23:17:31 <dmwit> But, then, it's likely that the time spent constructing the proof far outweighs the time spent running the proof checker.
23:17:49 <luqui> obviously the tactics can take longer to evaluate than the proof term.  Are there realistic cases where the proof term itself takes a significant amount of time?
23:17:52 <crutcher> Does anyone have a good set of problems to work on in Haskell?
23:18:04 <luqui> project euler?
23:18:17 <luqui> or do you mean "open problems"?
23:18:37 <crutcher> project euler and spoj are good places to start, but they don't 'do' anything, really. Their IO is very simple
23:18:57 <luqui> crutcher, oh, if you want practice with IO, just write something cool.
23:19:00 <luqui> like a game...
23:19:00 <crutcher> looking form something a bit mor active.
23:19:21 <bigtalk> dmwit: im not talking about 18 but 67 where brute force isnt possible
23:19:25 <crutcher> I'll probably just start writing a series of little languages.
23:19:39 <bigtalk> could memoization help?
23:19:45 <luqui> bigtalk, that's the trick ;-)
23:20:02 <bigtalk> memoization?
23:20:08 <luqui> getting the memo nice and elegant is a challenge, but it can be done
23:20:14 <bigtalk> ok
23:20:38 <the_unmaker> hey is haskell more fun than java or perl
23:20:39 <the_unmaker> ?
23:20:50 <luqui> YES!
23:20:56 <luqui> (and I used to *love* perl)
23:20:57 <the_unmaker> is there anything like a mod_haskell for apache?
23:20:58 <crutcher> everything is more fun than Java.
23:21:00 <rwbarton> Particularly java
23:21:05 <the_unmaker> no way u switch from perl to haskell!
23:21:12 <the_unmaker> so my instincts were correct
23:21:18 <luqui> but it is less fun (for me, depends on what you mean fun) for the first few months
23:21:34 <crutcher> perl becomes less fun the longer your perl programs get
23:21:44 <ivanm> luqui: how can anyone love perl? it's so ugly-looking!
23:21:46 <the_unmaker> ok how about common lisp
23:21:52 <the_unmaker> lisp beats haskell?
23:21:56 <luqui> ivanm, beauty is on the inside
23:21:59 <ivanm> heh
23:21:59 <crutcher> it does eventually become negative fun, erasing fun you had when you first wrote the thing you are trying to maintain
23:22:04 <luqui> not that perl is beautiful on the inside, quite the contrary
23:22:18 <ivanm> the_unmaker: I find the problem with lisp, is that when the functions get larger it's harder to tell what it does
23:22:20 <luqui> but there are some very fun women who look like dogs :-)
23:22:28 <ivanm> as it becomes too full of parentheses
23:22:38 <luqui> I find that is true of every language
23:22:46 <crutcher> luqui: is that really appropriate?
23:22:59 <luqui> lots of short functions are the key to beauty
23:23:07 <luqui> crutcher, no, it's quite offensive.
23:23:11 <the_unmaker> Im so single I need some womena dn to get rich from free software I use to produce wonderous things
23:23:13 <ivanm> luqui: well, IMHO longer haskell functions are easier to comprehend than lisp functions of the same length
23:23:33 <bigtalk> luqui,dmwit: memoization is the only way right? because there are no patterns so everyhting has to be checked to really verify, thus the only solution is "cheating" with memoization
23:23:35 <luqui> I haven't done much lisp, but I find haskell quite perplexing as functions get longer
23:23:39 <the_unmaker> I tried reading practical common lisp ansi common lisp by graham and lisp by winston and horn
23:23:46 <the_unmaker> they added in words without defining them
23:23:47 <ivanm> luqui: as for short functions... sometimes you have no choice _but_ to have a large function
23:23:47 <bigtalk> is memoizationa widely used technique just because of this fact?
23:23:48 <the_unmaker> frustrating
23:24:02 <luqui> ivanm, impossible!
23:24:23 <luqui> ivanm, the only way I can see that possible is if the function name itself is too long
23:24:37 <luqui> ivanm, because in the worst case, you factor out *every* subexpression
23:24:48 <ivanm> luqui: well, OK, I suppose I could have split it up... but then it would have been useless fragmentation instead of one larger function with quite a few statemetns in the where block
23:24:51 <luqui> and because this is haskell, you can always do that
23:24:53 <the_unmaker> the type things is kinda anaoying
23:24:59 <the_unmaker> I have this graham hutton book
23:25:09 <the_unmaker> and he uses liek symbols that are not typed on the keyboard
23:25:12 <the_unmaker> to say stuff
23:25:18 <the_unmaker> its liek cmon man
23:25:22 <luqui> ivanm, in my experience, there is always a useful fragmentation
23:25:24 <ivanm> the_unmaker: yeah, that's a common complaint with some haskell books
23:25:28 <luqui> you just have to think and look harder
23:25:29 <ivanm> they love lhs2tex too much :p
23:25:58 <ivanm> (though I think using greek characters in type statements is cool)
23:26:40 <crutcher> the_unmaker: I've noticed that they also sometimes use pictures, which also can't be typed.
23:26:43 <the_unmaker> I guess I can go back to online stuff
23:26:44 <luqui> haskell supports unicode, though, so if you can figure out how to type those characters, then you're golden
23:26:48 <ivanm> luqui: OK, how would you split up the nbrCluster function here? http://code.haskell.org/Graphalyze/Data/Graph/Analysis/Algorithms/Clustering.hs
23:26:49 <lambdabot> http://tinyurl.com/4ojhoy
23:26:54 <the_unmaker> crutcher: thats joke?
23:26:56 <luqui> (very few people actually use unicode in their source, though)
23:27:17 <the_unmaker> I mean he has a key in the back
23:27:17 <luqui> ivanm, it might take me a while, but I'm up for the challenge!
23:27:26 * ivanm wants a keyboard that supports the whole unicode set of characters! :p
23:27:30 <ivanm> luqui: heh, OK
23:27:33 <crutcher> the_unmaker: yeah.
23:27:55 <ivanm> luqui: though that way I've written it has the advantage of being almost exactly equal to the original imperative form
23:27:56 <sjanssen> dons: those results are rather surprising
23:28:09 <dons> unless you can see something funny going on.
23:28:11 <the_unmaker> I really want to learn a nice modern language like lisp smalltalk erlang but other linux admins say Im a fool and should learn something practical liek python or perl or java
23:28:17 <eck> does haskell have a function like C's strptime? (if so, what is it called?)
23:28:21 <the_unmaker> my investor friend says big company uses java
23:28:25 <the_unmaker> damn I dunno
23:28:29 <ivanm> the_unmaker: for an admin, I don't think java would be applicable
23:28:33 <the_unmaker> I even loked at SML today
23:28:38 <dons> lisp isn't terribly modern, btw.
23:28:40 <ivanm> isn't SML dead?
23:28:40 <the_unmaker> well i dont care about admin
23:28:45 <the_unmaker> I want to build software
23:28:47 <dons> nor smalltalk...
23:28:50 <ivanm> dons: even arc? ;-)
23:29:05 <the_unmaker> beleive ti or not sml has smlserver a web plugin for apache for dynamic content
23:29:09 <dons> the_unmaker: you'll need to learn something of all of them
23:29:18 <sjanssen> dons: I guess the u64q machine just performs differently than your four core box?
23:29:35 <ivanm> I'm sure I saw something the other day about how work on SML's successor stopped a couple of years ago...
23:29:36 <dons> maybe
23:29:49 <dmwit> bigtalk: I didn't use memoization in problem 67.
23:29:59 <dmwit> bigtalk: ...depending on how loosely you define memoization, I guess.
23:30:11 <dmwit> ?quote dcnstrct
23:30:11 <lambdabot> dcnstrct says: even the #lisp people say go with haskell
23:30:11 <luqui> ivanm, nevermind.  Id say that is already a bunch of small functions
23:30:14 <dmwit> the_unmaker: ^^
23:30:30 <ivanm> luqui: heh...
23:30:37 <luqui> ivanm, it's in a simulated "section" (one of my favorite coq features), where they all abstract over g.
23:30:51 <ivanm> oh?
23:30:54 <the_unmaker> learn all of them?
23:30:56 <the_unmaker> woa
23:31:01 <the_unmaker> smaltalk for web has seaside
23:31:03 <ivanm> at least the basics
23:31:12 <the_unmaker> java has prevayler which looks REALLY interesting
23:31:18 <the_unmaker> perl has BOP
23:31:26 <the_unmaker> haskell has happs
23:31:42 <eck> nevermind, i found the parse date package
23:31:42 <the_unmaker> lisp has new on called coreserver with prevayler like stuff
23:31:57 <Vq^> python has zope
23:32:13 <luqui> what exactly is lazy about ST.Lazy
23:32:18 <ivanm> FOO has BAR
23:32:41 <dmwit> eck: Data.Time.Format, right?
23:32:44 <Vq^> BAR doesn't have BAZ thought
23:32:48 <sjanssen> dons: have you picked out any that need special attention?
23:32:49 <Vq^> isn't that funny...
23:32:56 <dmwit> eck: (If not, you probably want to use that. =)
23:33:03 <crutcher> the_unmaker: web frameworks aren't that much 'better' or 'worse', you have to know what you want to happen, and you have to be right. After that, you can encode that in most frameworks.
23:33:14 <ivanm> make that: forall l, w . (Language l, WebApp l w) => l -> w ;-)
23:33:14 <dons> sjanssen: well, fannkuch needs a complete rewrite.
23:33:18 <eck> dmwit, I want the other way around, from a string to a date
23:33:29 <the_unmaker> aolserver+tcl looks awesome too because multithreaded and erlang has yaws
23:33:30 <dmwit> eck: Yep, that's in Data.Time.Format, too.
23:33:36 <dmwit> eck: See the parseTime class or whatever.
23:33:37 <eck> ah, i spoke too soon
23:33:46 <luqui> ah, I found it, it's here in the docs
23:33:49 <luqui> (surprise!)
23:33:51 <ivanm> the_unmaker: yeah, yaws definitely looks cool (performance-wise, that is)
23:33:54 <eck> thanks again :-)
23:33:55 <ivanm> luqui: lol
23:34:03 <dons> anyone used yaws?
23:34:11 <ivanm> yes, Haskell docs are usually quite good
23:34:17 <Vq^> crutcher: thats not entirely true, some fairly large webframeworks are a frikkin mess
23:34:19 <rwbarton> luqui: I used to know, remind me?
23:34:19 <ivanm> haskell-src-exts seems to be the exception :p
23:34:44 <ivanm> dons: I think part of the appeal of yaws is minesia (or whatever erlang's DBMS is)
23:34:52 <luqui> rwbarton, you mean my ST.Lazy question?
23:35:02 <rwbarton> luqui: Oh, I found it too.  Right.
23:35:20 <crutcher> Vq^: oh, they can hurt you. But I think too much emphasis is placed on 'power'. Zope isn't going to solve your app problems for you, nor is any other framework.
23:35:32 <rwbarton> ST.Lazy is kind of mysterious to me for some reason
23:35:35 <ttt--> i have used yaws once
23:35:41 * luqui too
23:35:43 * ivanm wonders how well yaws would cope under a DDOS compared to Apache
23:36:02 <Vq^> crutcher: of course not, but i'd say 'structure' instead of 'power'
23:36:10 <ttt--> It's like php, you can mix html and erlang code
23:37:03 <dmwit> I wouldn't exactly call that the defining characteristic of PHP.
23:37:18 <crutcher> Vq^: features, speed, templates, bindings. Meh. If you know what you want to happen, you can build it, if you don't, you'll hash it up in any framework.
23:37:33 <Vq^> crutcher: you're right of course
23:38:12 <Vq^> but there is this focus on templates/views in many frameworks instead of the data
23:38:26 <Vq^> just look at the URLs on the webpages you visit today
23:38:37 <crutcher> some of this "should I learn language X" reminds me of gentoo. http://funroll-loops.info/
23:38:40 <lambdabot> Title: Welcome to Gentoo is Rice, the Volume goes to 11 here.
23:38:59 <ivanm> crutcher: in what way?
23:39:03 <ivanm> and what's wrong with Gentoo?
23:39:32 <Vq^> ah, that site is so fair to gentoo :)
23:39:36 <crutcher> gentoo provides a valuable service to the opensource world by brute forcing the configuration space of the makefiles.
23:39:39 <crutcher> which is stupid.
23:40:22 <ivanm> crutcher: ummmm..... what?
23:40:23 <crutcher> but at least I benefit from people who think tweaking option #36 is a great way to spend their evenings.
23:40:54 <ivanm> you mean because they test all possible combinations of configs provided _by upstream_ that it's Gentoo's fault if something goes wrong?
23:40:55 <Vq^> crutcher: whats this about space in makefiles?
23:41:23 <crutcher> ivanm: no, no. When they blow something up, some subset of those errors get reported to upstream, and fixed.
23:41:30 <crutcher> that's good.
23:41:37 <crutcher> what's dumb is that they are doing it at all.
23:42:15 <ivanm> crutcher: in a lot of cases, it's either because upstream doesn't want to fix it, or else there are some cases where it is gentoo-specific to take into account the toolchain, etc. used
23:42:32 <the_unmaker> archlinux is the best os I have tried
23:42:35 <crutcher> Vq^: take the set of options which can be defined on a gentoo distribution as a vector. That is a position in the gentoo configuration space. It is a very very large space. Most positions have not been tested.
23:42:35 <ivanm> don't forget, for binary distros you only need to get it compiled once each time for each architecture...
23:42:39 <the_unmaker> just so painless
23:42:42 <ivanm> the_unmaker: arch isn't an OS
23:42:45 <Vq^> well, if you don't see the worth in using gentoo you are allowed to avoid it
23:42:53 <ivanm> it's a GNU/Linux distribution
23:42:55 <Vq^> crutcher: ok, i see what you mean
23:42:59 <crutcher> ivanm: most positions will NEVER be tested, because it isn't possible to try all the options.
23:43:20 <ivanm> not in combination with every possible package, no
23:43:30 <ivanm> but in situ for a particular package...
23:43:33 <the_unmaker> ivanm: er what si it then
23:43:41 <crutcher> no, actually, its worse than that. How many options are there on a given package?
23:44:00 <the_unmaker> I wonder if haskell microthreads will make a killer web server
23:44:00 <crutcher> how many different gcc flags can you set?
23:44:17 <the_unmaker> someone call it haws
23:44:21 <the_unmaker> instead of yaws
23:44:24 <the_unmaker> or hawk
23:44:28 <the_unmaker> thats catchy
23:44:34 <the_unmaker> cherokee looks fast
23:45:08 <crutcher> anyway, the analogy was that many people do the same thing with languages.
23:45:38 <crutcher> they have this idea that their problems exist in the config space, and that they just have to find the right 'magic' sweet spot.
23:45:57 <crutcher> and that generally isn't true. You have to write code. Writing code is, in general, hard.
23:46:12 <Vq^> quite right
23:46:25 <the_unmaker> I myself wish to learn to write code.
23:46:34 <the_unmaker> bash is not suitable for webaps
23:46:39 <crutcher> some languages, and some OSs, ocupy very different domains in the space, and there are real differences.
23:46:59 <Vq^> my suggesting Zope had to do mostly with the thought of the lowlevel stuff and not the large library of products
23:47:03 <crutcher> the_unmaker: see, that's my point. I've written web apps in bash. It was fun.
23:47:41 <ttt--> What are haskell microthreads?
23:48:10 <crutcher> the_unmaker: if you want to be a programmer, pick _anything_, and push it as far as you can. When you are _certain_ that you can't go further, then try something else.
23:48:17 <ivanm> ttt--: I'm guessing he's referring to the light-weight threads in the haskell RTS
23:48:23 <ivanm> rather than using server-side threads
23:48:48 <the_unmaker> i was drunk the other night and theorizing that if you could mount the broswer side as an nfs directory you could then make a dynamic page by simply changing files on the mounted dir on the home server
23:48:53 <the_unmaker> maybe I was too drunk
23:49:25 <the_unmaker> I saw a haskell paper wheere like 100,000 threads were used
23:49:28 <the_unmaker> crutcher: ok
23:49:43 <the_unmaker> so it matters not which on I pick
23:50:06 <ttt--> so normal forkIO?
23:50:46 <crutcher> the_unmaker: its about you, and how much work you put in, and not the language.
23:51:57 <ttt--> Are there libraries for doing erlang-style concurrency in haskell? Or would that not work
23:52:41 <Vq^> ttt--: erlang-style? you mean message-passing?
23:54:01 <ttt--> yeah
23:55:11 <crutcher> there was this http://www.macs.hw.ac.uk/~dsg/gdh/
23:55:14 <the_unmaker> no erlang has many small theads
23:55:15 <lambdabot> Title: Glasgow Distributed Haskell
23:55:20 <the_unmaker> 100s of 1000s on pc hardware
23:55:30 <sbahra> 90883 sbahra        1 118    0   739M   615M CPU1   0   3:45 100.00% euler
23:55:32 <sbahra> ;[
23:55:42 <Vq^> ttt--: not specifically for message-passing, no
23:55:51 <Vq^> ttt--: that i know of anyway
23:56:14 <jsnx> the_unmaker: well, that's not the real difference...
23:56:24 <ttt--> how many threads can haskell do in comparison?
23:56:31 <jsnx> the_unmaker: GHC's runtime can hit a million threads
23:56:36 <the_unmaker> really?
23:56:40 <the_unmaker> on pc hardware?
23:56:40 <ttt--> wow!
23:56:41 <the_unmaker> wow
23:56:48 <the_unmaker> jsnx: are you sure?
23:56:53 <jsnx> the_unmaker: yes
23:56:54 <Vq^> ttt--: im not entirely sure what you are looking for but it's certainly possible to do message-passing in Haskell
23:57:05 <jsnx> the_unmaker: let me look around a little bit
23:57:17 <the_unmaker> that means multi cores can work very fast but what about an application using multiple cheap computers as one
23:57:22 <sbahra> I'm not sure what it means to do a "million threads"
23:57:34 <the_unmaker> someone said too many threads are bad
23:57:50 <the_unmaker> but threads are good for multi core is what ive garnered
23:58:38 <Vq^> the_unmaker: it's not quite so simple
23:58:40 <jsnx> http://www.seas.upenn.edu/~lipeng/homepage/unify.html
23:58:41 <lambdabot> Title: Unifying events and threads
23:59:08 <jsnx> i'm not saying you'd ever use ten million threads
23:59:31 <jsnx> i'm just saying, if you need hundreds of thousands, you can definitely get them
