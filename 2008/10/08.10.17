00:00:31 <zeno> ah ok! i thought it meant i need a package called love haha
00:01:03 <zeno> hmmm same failures on alex, do i need 6.10?
00:01:10 <dcoutts> zeno: heh heh :-)
00:01:57 <dcoutts> zeno: ah so you're using ghc-6.8.x, what version of Cabal are you using?
00:02:17 <dcoutts> ghc-pkg list Cabal will tell you
00:04:04 <zeno> dcoutts: http://pastebin.ca/1229133
00:05:32 <mm_freak> mmorrow: you know what your code, and those of sjanssen and heatsink, remind me of?
00:05:53 <dcoutts> zeno: hmm, so building alex-2.3 still fails with the error message about `buildVerbose' ?
00:05:58 <mm_freak> http://www.willamette.edu/~fruehr/haskell/evolution.html
00:05:58 <lambdabot> Title: The Evolution of a Haskell Programmer
00:06:02 <zeno> yup
00:06:15 <mmorrow> rwbarton: i've been eyeing Control.Comonad.Coideal.Mutual for a few days now, i think it's going to be super useful.
00:06:19 <dcoutts> zeno: if so that's rather odd becuase Cabal-1.6.0.1 does export that function and it works when I try it
00:06:24 <mmorrow> mm_freak: hehe
00:06:57 <dcoutts> zeno: you're sure it's 2.3 you're building now, not 2.2 ?
00:07:44 <zeno>  /tmp/TMPalex-2.3/alex-2.3/Setup.lhs:6:51:
00:09:01 <dcoutts> zeno: if you run cabal install alex -v3, take a look at what version of Cabal it says it is using to compile that Setup.lhs script
00:09:08 <pumpkin_> if I call Map.findMin on the same map twice in the same expression, it'll only be evaluated once, right?
00:09:32 <pumpkin_> because the map is immutable?
00:09:43 <dmwit> If you let-bind it, it will be shared.
00:09:50 <dmwit> Otherwise you're leaving it up to the whim of the compiler.
00:10:01 <zeno>  /usr/bin/ghc is version 6.8.2
00:11:06 <zeno> dcoutts: should i use a version other than 6.8.2
00:12:13 <dcoutts> zeno: it's the version of the Cabal library that it's using to compile the Setup.lhs that I'm interested in
00:12:34 <mmorrow> wow, i haven't looked at that page for a while now. it's 10x better than i remember it
00:13:06 <dmwit> What, the evolution thing?
00:13:14 <mmorrow> yeah
00:14:00 <dcoutts> zeno: with -v, you'll notice a line where it calls ghc to compile Setup.lhs, it passes a flag like -package Cabal-1.6.0.1 when I try it, I'm wondering what it does for you.
00:14:33 <dcoutts> zeno: or with -v3 there's a couple lines:
00:14:39 <dcoutts> Using Cabal library version 1.6.0.1
00:14:39 <dcoutts> Using /tmp/TMPalex-2.3/alex-2.3/Setup.lhs as setup script.
00:14:52 <dcoutts> just before it compiles the script
00:16:30 <zeno> dcoutts: Using Cabal library version 1.5.5;Using /tmp/TMPalex-2.3/alex-2.3/Setup.lhs as setup script.
00:16:50 <dcoutts> ho ho, so why is it doing that I wonder
00:17:11 <zeno> no idea
00:17:36 <dcoutts> zeno: I'll look into it, I suspect it's because your cabal-install is built using that version of the Cabal lib
00:17:47 <dcoutts> so it prefers to use that version
00:17:59 <zeno> ah ok thanks! how to switch its pref
00:18:26 <dcoutts> zeno: I suggest you update your cabal-install to the latest version, that will build it against the latest version of the Cabal lib
00:18:32 <zeno> if possible i would remove cabal < 1.6
00:18:38 <dcoutts> zeno: ie cabal install cabal-install
00:18:50 <dcoutts> zeno: unregistering Cabal 1.5.5 might help too
00:19:06 <zeno> how do you unregister stuff?
00:19:18 <dcoutts> zeno: then it'd pick either Cabal-1.4.0.2 or 1.6.0.1, either of which would work in this case
00:19:18 <pstickne> that's so not the google way!
00:20:00 <dcoutts> zeno: ghc-pkg unregister Cabal-1.5.5, but in general you should be careful of unregistering things
00:20:13 <zeno> dcoutts: sweet works after cabal install cabal-install
00:20:19 <zeno> thanks a ton
00:23:24 <zeno> does the GTK frontend work for recent versions?
00:23:48 <rwbarton> mmorrow: the problem with this stuff in category-extras is that there are just *so* many type aliases and newtypes in the way
00:24:04 <rwbarton> e.g. *Main> runStatus $ tell [2,3,4]
00:24:04 <rwbarton> InB {outB = Biff {runBiff = Right (2,InB {outB = Biff {runBiff = Right (3,InB {outB = Biff {runBiff = Right (4,InB {outB = Biff {runBiff = Left (Identity {runIdentity = ()})}})}})}})}}
00:24:13 <sbahra> mmorrow, any thoughts on FPGAs and Haskell in light of our recent discussion?
00:24:15 <dcoutts> zeno: no problem
00:32:20 <zeno>  Could not find module `Yi.Mode.Shim': hmm how do i enable shim
00:36:21 <pumpkin_> is there some way I can ask ghci for the execution time of an expression I type in?
00:37:33 <rwbarton> :set +s
00:38:05 <pumpkin_> thanks
00:39:23 <rwbarton> mmorrow: I wrote it using category-extras (http://hpaste.org/11218#a10) but it's much slower... not sure why
00:43:17 <thoughtpolice> zeno: you have to build yi with '-fghcAPI'
00:43:57 <thoughtpolice> but the thing is the ghc package is built against bytestring and cabal (iirc,) so you can't have upgraded versions that differ from the ones that the ghc package was built against
00:44:02 <thoughtpolice> otherwise you'll have linker errs
00:46:02 <Cale> http://www.qwantz.com/  :)
00:46:07 <lambdabot> Title: qwantz.com - dinosaur comics - October 17 2008
00:51:29 <zeno> thoughtpolice: ah and i need 6.8.3 for fghcapi, but i have 6.8.2
00:51:43 <zeno> hmmm any way to enable vim keybindings w/o fghcapi?
00:53:23 <Baughn> thoughtpolice: No, you can perfectly well upgrade those two, but I /have/ run into trouble if I install the upgraded package globally, for some reason. In ~/.ghc works fine.
00:53:48 <Baughn> thoughtpolice: Cabal automatically selects the right version, however. I don't know about ghc --make; I don't use it.
00:58:01 <rwbarton> , src '':~>
00:58:06 <lunabot>  luna: parse error on input `:~>'
00:58:14 <rwbarton> , src ''(:~>)
00:58:23 <lunabot>  type (:~>) f g = forall a . (f a) -> g a
00:59:52 <nha__> is there any way to return different types from a function if they are an instance of the same type class?
01:00:52 <Baughn> nha__: Polymorphism isn't good enough?
01:01:05 <waynemokane> how can I list installed packages and versions in ghc?
01:01:11 <Baughn> waynemokane: ghc-pkg list
01:01:14 <Baughn> nha__: There are existentials, but you should generally avoid those
01:01:22 <waynemokane> Baughn: thx
01:01:48 <nha__> im not sure haha
01:02:03 <nha__> im trying to make a generic update function for this datatype
01:02:09 <nha__> that has 3 subtypes that all implement a certain type class
01:02:13 <Baughn> nha__: If you have a function such as "Foo a => Etc -> a", it will be able to return any type that's an instance of Foo, though only one at a time, and selected by the caller
01:02:33 <nha__> yea this would need to return 3 different types
01:02:38 <Baughn> nha__: ..right. See Functor; that works about the way you want, although you may want a different one.
01:02:40 <xhanjian> hi, could anyone suggest me a book for learning haskell? Now I know a little scheme and very interested in haskell
01:02:51 <Baughn> nha__: Yeah, but not all three at the same time, right?
01:02:57 <nha__> same time
01:03:03 <Adamant> xhanjian: Real World Haskell
01:03:06 <Baughn> But only those three?
01:03:10 <nha__> i think shot myself in the foot haha
01:03:11 <nha__> i*
01:03:15 <Baughn> nha__: How about combining them into a single type with data?
01:03:22 <Vq^> xhanjian: http://www.cs.nott.ac.uk/~gmh/book.html
01:03:23 <jeffz> xhanjian: http://learnyouahaskell.com
01:03:29 <nha__> yea i was thinking of that
01:03:32 <lambdabot> Title: Learn You a Haskell for Great Good!
01:03:32 <lambdabot> Title: Programming in Haskell
01:03:39 <nha__> but the code is too spread out / unrelated
01:03:40 <Adamant> xhanjian: it's freely downloadable and you can buy it if you like it
01:03:49 <Baughn> nha__: Might want to refactor it a bit, then
01:04:04 <xhanjian> thanks guys
01:04:16 <Baughn> nha__: Look.. if you really can't figure out a good solution, look at existentials, but those are *not* for the weak-minded. They're also easy to abuse.
01:04:21 <dons> learnyouahaskell.com is mega awesome
01:04:46 <jeffz> yes, it definitely seems to bridge a gap
01:05:13 <dons> i think it sets a standard for the kind of community participation in tutorial writing we can achieve.
01:05:25 <dons> anyone can step up and do something like this.
01:05:37 <dons> not just hacking the compiler etc. but contributing important pieces like this
01:06:11 <mopped> How can I run a .hs file from an interpreter?
01:06:19 <zeno> bleh cabal upgrade;cabal: cannot configure HUnit-1.2.0.2. It requires base ==4.* this is a nightmare
01:07:10 <Baughn> nha__: In practice, types are a fundamental and very important part of your program, and don't mind being declared separately from the functions that operate on them
01:07:23 <Baughn> zeno: base-4 is from ghc 6.10
01:07:59 <zeno> Baughn: so i should get 6.10 now? i just added 6,8.3
01:08:00 <Baughn> zeno: Given that it's not out yet.. well, you could install it on your own - it seems to work fine - but that would probably lead to even more cabal woes. Instead, ask for the last version of HUnit explicitly.
01:08:01 <nha__> yea i was using existentials to cram some of them into a list
01:08:11 <nha__> but that was causing other problems
01:08:12 <nha__> haha
01:08:21 <Baughn> nha__: Right. OO is rarely the answer, especially not in haskell.
01:08:53 <zeno> mopped: ghci foo.hs
01:09:07 <Baughn> nha__: Making them a single ADT seems like the obvious solutions
01:09:30 <Baughn> *solution. You rarely even need type-classes except when writing libraries, since you'll *know* what types you want your functions to handle..
01:10:00 <mopped> it complains about not having a function "main" defined, it's more of a short script
01:10:07 <mopped> (as in, real short!)
01:10:36 <zeno> is there a way to remove 6.8.3 and revert to old state?
01:10:42 <Baughn> Type-classes is so one programmer can use functions another wrote in.. type-classy ways. OO is for when you've got hundreds of schizophrenic programmers, and insufficient interfaces. *hides*
01:11:11 <Baughn> mopped: ..well, it's not going to do anything without main
01:12:11 <mopped> I'm new to haskell, and as I've done a few PE problems in python I thought i'd see the haskell counter-parts, http://www.haskell.org/haskellwiki/Euler_problems/1_to_10 - how would I run scripts that look like that ;)
01:12:13 <lambdabot> Title: Euler problems/1 to 10 - HaskellWiki
01:12:39 <Baughn> mopped: You can't.
01:12:45 <Botje_> stick it in a file
01:12:48 <Baughn> mopped: Well, you can load them up in ghci and call individual functions
01:12:50 <Botje_> and add main = print problem_1
01:13:02 <Baughn> mopped: But to have it do anything as an actual executable, you have to define main
01:13:15 <mopped> aha
01:22:04 <rwbarton> What does this error mean? (when trying to compile with profiling)  /usr/bin/ld: cannot find -lHSghc_p
01:22:40 <Zao> rwbarton: Is your GHC built with profiling support?
01:22:44 <Baughn> rwbarton: The profiling libraries are apparently missing
01:23:11 <rwbarton> I think this might be a debian bug, since I have ghc6-prof installed
01:23:15 <Baughn> The main GHC one, too. All the binary distributions should have that.. unless they split it up for some reason
01:23:24 <Baughn> rwbarton: Isn't that one.. ancient?
01:23:40 <rwbarton> version 6.8.2-7
01:23:47 <Baughn> Oh, unstable. Well..
01:23:54 <Baughn> Still, on debian, I strongly recommend you compile your own
01:23:54 <rwbarton> Testing
01:24:15 <Zao> Baughn: Debian splits profiling ones off into -prof, I believe.
01:24:52 <Baughn> Zao: Which he apparently has installed, so..
01:25:09 <Zao> Oh, missed that bit.
01:25:09 <rwbarton> Does anyone have debian and want to break profiling by upgrading to 6.8.2-7 and verifying this bug? :)
01:25:17 <Zao> "upgrading"?
01:25:21 <Baughn> rwbarton: Hang on. What *version* of ghc6-prof do you have? Check with dpkg -l ghc6 and -l ghc6-prof
01:25:34 <Baughn> They just might not be depending on each other right
01:25:34 <rwbarton> 6.8.2-7 of each
01:25:39 <Baughn> ..oh
01:25:54 <Baughn> ..well, compiling your own would fix this
01:26:13 <Baughn> rwbarton: You might want to past dpkg -L ghc6-prof, too. Let us see what's in it.
01:26:13 <rwbarton> It's a pretty recent upload I think, like September
01:26:24 <Baughn> 6.8.2 is rather old..
01:27:36 <rwbarton> yeah, looks like they've been backporting fixes from 6.8.3 maybe
01:28:06 <Baughn> That would be typical debian. I don't get it - there's a good chance of /adding/ bugs that way.
01:30:40 <rwbarton> It doesn't seem like any debian packages have ever included a libHSghc_p.so; maybe I'm doing something else wrong
01:31:13 <rwbarton> .a rather
01:31:29 <rwbarton> Well, I just searched for HSghc_p
01:32:33 <Baughn> Well, that's a problem
01:33:09 <rwbarton> I'm sure I've used the profiler before
01:33:30 <rwbarton> I upgraded from 6.8.2-5 (I think) to 6.8.2-7 yesterday or so
01:33:54 <Baughn> libHSghc_p may be the wrong name. I certainly don't have it.. then again, I'm on 6.10.
01:34:22 <Baughn> ..6.8.3 doesn't have it either.
01:34:54 <Zao> My home-built 6.8.3 doesn't have one either.
01:35:12 <rwbarton> lHSghc_p only gets two google hits, which are both logs of this channel
01:36:25 <rwbarton> Nothing obviously wrong with this, is there?  ghc --make -O2 writer2 -prof -auto-all
01:36:40 <Baughn> Nope
01:36:54 <rwbarton> OK, I'll worry about it tomorrow
01:36:55 <Zao> https://bugs.launchpad.net/ubuntu/+source/ghc6/+bug/240563
01:37:07 <Zao> Somewhat relevant.
01:38:39 <rwbarton> Thanks for the sanity checks
01:38:53 <Baughn> rwbarton: Hang on, I think I know what's going on
01:39:14 <Baughn> rwbarton: 6.8 doesn't *build* profiling libraries for the GHC API. I've run into that before.
01:39:36 <Baughn> rwbarton: You'll need to run 6.10 if you want that
01:40:20 <Baughn> rwbarton: (There were apparently issues. They're fixed now, I guess.)
01:41:15 <zeno> can you use vim mode in yi without -fghcAPI?
01:41:37 <zeno> i keep getting  Could not find module `Yi.Mode.Shim'
01:41:47 <Baughn> rwbarton: (I've got libHSghc-6.10.0.20081011_p.a here)
01:42:10 <rwbarton> Baughn: Oh, and that's a problem because I import GHC.Exts.
01:42:16 <rwbarton> Baughn: Great, I don't really need it much
01:42:25 <chrisdone> Baughn: did you see my video?
01:42:43 <Baughn> chrisdone: Sorry. My internet connection hasn't been working; I'm using gprs right now.
01:42:55 <Baughn> Which reminds me, I was going to call my isp and yell at them for a bit.
01:43:11 <chrisdone> sure
01:43:29 <rwbarton> or actually, category-extras depends on ghc. (!?)
01:43:39 <Saizan> anyone tried to use the ghc api on 6.10 ?
01:44:03 <rwbarton> Baughn: Oh well, thanks for the explanation!
01:48:44 <ahunter> Is there a reasonably good way to use the algorithms in Data.Graph if you want to be able to label edges?
01:49:13 <ahunter> Or do I just need something annoying like a secondary Data.Map (Vertex,Vertex) Label?
01:50:03 <Cale> I should really write a usable graph library based on Data.Map.
01:50:43 <Cale> ahunter: That's what I'd go with though.
01:51:09 <ahunter> Cale: figured as much, yeah.  I really don't like Data.Graph very much...wish there was something better.
01:51:19 <Cale> ahunter: Or  Map Vertex (Set (Vertex, Label))
01:52:05 <Cale> Map Vertex (VertexLabel, Set (EdgeLabel, Vertex))
01:52:30 <Cale> If you want to be thorough :)
01:52:45 <rwbarton> `cast` in GHC core is a no-op in reality, right?
01:52:51 <ahunter> Cale: I suppose that'd be more efficient?  Don't think it matters hugely in practice for now, but thanks
01:53:07 <rwbarton> It doesn't matter if the type it's casting to is six lines long? :)
01:56:27 <Cale> ahunter: Well, it supports lots of operations more efficiently than using arrays.
01:57:21 <Cale> ahunter: and of course, you can generalise  Vertex, VertexLabel, and EdgeLabel somewhat.
01:57:23 <ahunter> Cale: has anyone implemented the algorithms on that as a graph type, though?
01:58:25 <Cale> ahunter: Not that I know of, but the algorithms in Data.Graph are not so painful to implement.
01:58:40 <ahunter> Cale: True, but...project for another day, know what I mean?
01:58:55 <Cale> Right, I suppose it depends on how much you need.
01:59:33 <Cale> Data.Graph.Inductive has lots more stuff, but it has its own problems.
02:05:36 <Arnar> hi all
02:06:15 <Arnar> I have a small error when cabal installing Yi
02:06:17 <Arnar> http://gist.github.com/17383
02:06:18 <lambdabot> Title: gist: 17383 â€” GitHub
02:06:19 <ivanm> hmmmmm..... I need to do 2D and 3D plots... since I'm going to have to use gnuplot for the 3D plots, should I bother using Chart for the 2D plots or just do them in gnuplot as well?
02:06:35 <Baughn>  ivanm Yes
02:06:58 <Baughn> Whatever you feel like. Either would work, so just do what you want. :P
02:07:13 <ivanm> heh
02:07:49 * ivanm wishes there was a proper 3D plotting library or bindings to one in Haskell :s
02:12:24 <mapreduce> *  Monolith. Every non-empty ultra-connected compact space X has a largest proper open subset; this subset is called a monolith.
02:12:36 <mapreduce> Can anyone explain that in plain English?
02:13:45 <ivanm> since when has there been a gnuplot library on hackage? :o
02:13:59 <ivanm> mapreduce: set theory?
02:14:10 <mapreduce> Maths in general.
02:14:13 <ivanm> oh, wait, since yesterday....
02:14:27 <mapreduce> I think it refers to graph theory there though.
02:15:13 <mapreduce> I was writing "your suggested change makes our software tend towards a monolith" in an email to my boss, and thought I'd better look up the word. :)
02:15:36 <ivanm> yeah, the connected bit seems to refer to graph theory...
02:15:43 <ivanm> but a "proper open subset"?
02:15:58 <ivanm> mapreduce: you're looking for "monolithic" rather than "monolith", I think...
02:16:18 <mapreduce> Ah, it's in topology.
02:16:19 <mapreduce> http://www.mathdaily.com/lessons/Topology_glossary
02:16:45 <quicksilver> a monolithic design
02:16:53 <quicksilver> monolith on its own is shades of 2001
02:17:11 <mapreduce> Does a monolithic design not result in a monolith?
02:17:31 <mapreduce> Other definitions are "a building carved from a single block of stone", etc.
02:17:43 <quicksilver> nod
02:17:45 <ivanm> mapreduce: not in computing terms :p
02:17:56 <quicksilver> it's just a very seldom used noun
02:18:00 <ivanm> quicksilver: not to mention 2010, 2065 and 3001...
02:18:19 <quicksilver> almost only in the context of space odyssey
02:18:44 <ivanm> yes
02:19:36 <cads> there's the monolithic kernel design also
02:19:44 <ivanm> yup
02:20:03 <cads> ah, quicksilver mentioned that
02:20:04 <quicksilver> cads: "monolithic" is very common in software engineering
02:20:11 <quicksilver> cads: I'm just saying that the noun form is not.
02:20:20 <cads> indeed
02:21:14 <cads> hmm, http://tunes.org..../haskell  at first glance seems like it should be a haskell themed internet music station
02:21:42 <ivanm> hmmmmm..... the gnuplot cabal file says the homepage is on code.haskell.org, even though it isn't...
02:21:51 <unenough> how does one implement a destructive algorithm such as topological sort, non-destructively?
02:22:05 <unenough> i'm asking here because obviously in haskell with all the immutability, you need to do these things
02:22:11 <kowey> sigh
02:22:27 * kowey isn't confrontational enough to throw down the gauntlet
02:22:28 <kowey> http://thread.gmane.org/gmane.comp.version-control.darcs.user/14406/focus=14602
02:22:29 <ivanm> unenough: you don't make it destructive
02:22:32 <lambdabot> Title: Gmane Loom, http://tinyurl.com/6foeec
02:22:42 <unenough> ivanm, but how? make copies of the data?
02:22:44 <cads> you implement it as a recursive function
02:22:53 <ivanm> unenough: pretty much, yes
02:23:05 <unenough> cads, can you refer me to an example?
02:23:18 <ivanm> unenough: depends on what the actual algorithm you want is
02:23:22 <unenough> topological sort
02:23:35 <kowey> (this question in the link I posted is if we could get some HAppS folks fired up about writing code for an eventual darcshub)
02:23:49 <kowey> because we have bandwidth and hardware waiting to be used
02:24:04 <ivanm> kowey: what gauntlet? the designing of such a site?
02:24:33 <kowey> ivanm: well I was thinking of doing some sort of "HAppS isn't good enough" taunt :-P
02:24:49 <kowey> (/me has never actually played with HAppS and is messing around a bit)
02:24:51 <ahunter> > read ".5" :: Double
02:24:52 <lambdabot>   * Exception: Prelude.read: no parse
02:25:06 <unenough> i'm looking specifically for a non-destructive topological sort
02:25:14 <ahunter> is there a good way around this, given that I have a large family of input files that have numbers formatted like that?
02:25:18 <kowey> but I  was sighing because it's not a kind of taunt I could pull off credibly
02:26:23 <cads> unenough, I think a topology is a space where there's a notion of a partial order, this is an example of sort in such a space:  qsort :: Ord a => [a] -> [a]; qsort [] = []; qsort (s:xs) = [s | x<-xs, x<s] ++ [s] ++ [x | x<-xs, x>=s]
02:27:08 <cads> err, small typo, s/[s |/[x |
02:28:08 <rog> unenough: this thread seems relevant: http://archive.netbsd.se/?ml=haskell-cafe&a=2008-01&t=6271467
02:28:13 <lambdabot> Title: archive.netbsd.se
02:28:19 <unenough> cads, thanks. small problem tho, i was interested in the theory, i'm a haskell noob and can't really read that :)
02:28:33 <cads> crap
02:28:40 <cads> big typo, too
02:29:09 <cads> qsort :: Ord a => [a] -> [a]; qsort [] = []; qsort (s:xs) = qsort [s | x<-xs, x<s] ++ [s] ++ qsort [x | x<-xs, x>=s]
02:29:31 <luqui> it's not difficult.  one of my favorite haskell functions.
02:30:00 <cads> it's a really pretty application of list comprehensions but duplicates work
02:31:43 <cads> unenough: for the first element of the list to be qsorted, it splits the list into two lists with elements that are greater and less than the current element, respectively, and calls qsort on those sublists and then concatenates the list in order
02:31:55 <unenough> cads, ok got it, but topological sort works on unordered DAGs
02:31:58 <pjdelport> ObKvetch: that's not quicksort
02:32:34 <pjdelport> it's treesort, deforested
02:32:43 <unenough> the algorithm i know for topological sort modifies the graph in place by removing edges
02:32:52 <inimino> unenough: I think there's a page on the wiki about that topic, maybe someone else remembers it
02:33:24 <ivanm> unenough: well, you can always use FGL graphs, remove the vertex in question, modify it and put it back again
02:33:41 <unenough> FGL?
02:34:00 <ivanm> Functional Graph Library
02:34:17 <ivanm> unenough: http://www.haskell.org/haskellwiki/Blog_articles/Mathematics
02:34:18 <lambdabot> Title: Blog articles/Mathematics - HaskellWiki
02:36:03 <unenough> i think that book Purely Function Data Structures may have something about thism, but i didn't get much of that book (i'm missing some basic notions)
02:36:07 <unenough> it's not an easy read
02:36:30 <ivanm> isn't it? IIRC I didn't find it that hard when I first read it a few years ago
02:37:28 <unenough> ivanm, i've never studied data structures formally so i didn't know half the terms he mentioned
02:37:35 <ivanm> ahhh, maybe
02:37:43 <unenough> i did get the big picture though
02:37:56 <unenough> this looks relevant http://www.springerlink.com/content/p296h05q65331h36/
02:37:59 <lambdabot> Title: SpringerLink - Book Chapter
02:38:17 <rog> AFAIR, Purely Functional Data Structures focuses on general techniques rather than specific algorithms. it doesn't mention topological sort.
02:38:58 <unenough> yes, that's right too
02:40:07 <unenough> i guess i'll just copy the graph for now :)
02:40:16 <unenough> that's very very costly
02:40:32 <rog> unenough: i think what you're trying to do is straightforward if efficiency isn't a big issue (e.g. the graphs are small).
02:40:43 <rog> unenough: how big are the graphs you're dealing with?
02:40:46 <unenough> because i have to construct a list of nodes that were already copied, and search it for every new node i traverse to prevent duplicates
02:41:06 <Arnar> arhmm.. when I cabal install yi, why does it always try to fetch 0.4.3 even if the current version on hacakge is 0.5.0.1 ?
02:41:10 <unenough> rog, they're small, that's why i'm giving up and i'll just do it this way
02:41:54 <rog> unenough: if you use a Set, at least the search won't be linear.
02:42:14 <unenough> what structure does a Set use?
02:42:34 <rog> some kind of balanced tree.
02:42:44 <rog> the web page says
02:42:58 <unenough> ok. thanks all
02:43:14 <rog> unenough: see http://hackage.haskell.org/packages/archive/containers/0.1.0.1/doc/html/Data-Set.html
02:43:16 <lambdabot> Title: Data.Set, http://tinyurl.com/4eyjvx
02:44:11 <Badger> o_O
02:44:25 <Badger> lambda auto-tinifies every url?
02:44:44 <thoughtpolice> haddock 2 can grok gadts right?
02:44:53 <ivanm> Badger: if it's longer than a certain length, then yes
02:45:15 <Badger> handy stuff.
02:45:33 * ivanm finds it rather annoying tbh
02:45:59 <hugo__> good mori
02:46:01 <hugo__> morning ppl
02:46:02 <hugo__> :P
02:46:13 <quicksilver> Badger: only URLs longer than 'n' characters.
02:46:27 <quicksilver> Badger: there they are likely to be hard to copy-paste, is the theory.
02:48:56 <pelirrojo> why would a tinyurl be harder to copy and paste?
02:49:42 <ivanm> pelirrojo: no, _larger_ urls would be harder to copy/paste
02:50:23 <pelirrojo> ahhh
02:50:27 <pelirrojo> why?
02:50:34 <pelirrojo> well i guess it requires move finger moving
02:50:40 * pelirrojo is assuming all good souls use laptops
02:51:11 <ivanm> well, if it goes over multiple lines...
02:51:13 <mapreduce> Because some clients will copy it as two lines in some cases.
02:51:33 <pelirrojo> ah
02:53:25 <hugo__> i really like comment nesting :D
02:53:45 <hugo__> its "ahh, finally i can comment as i want..."
02:55:09 <pelirrojo> comments?
02:55:12 <pelirrojo> people still use those?
02:55:19 <ivanm> yes
02:55:30 <pelirrojo> it was a joke...
02:55:31 <ivanm> so other people can work out wtf you're doing
02:55:32 <ivanm> oh
02:56:23 <inimino> you should have commented it          -- this is a joke
02:56:36 <jeffz> haha, now that's a joke
02:56:42 <pelirrojo> interesting question. would any of you consider a CS degree "incomplete" if it were less than a masters level?
02:57:02 <ivanm> pelirrojo: depends on the geographical region in which it's done
02:57:13 <pelirrojo> hm, united states
02:57:35 <ivanm> well, here, Masters is a cut-down, mini bachelors/honours compressed into a year (for coursework masters)
02:58:12 * ivanm _loves_ undocumented libraries... currently trying to work out how to use the gnuplot library
02:58:19 <pelirrojo> i went to a research thing, trying to get 2nd and 3rd years interested in research, and the guest speaker was saying he prefers people stay until theyve done a phd
02:58:29 <vegai> one might consider CS degree of any level a waste of resources ... depending on one's goals
02:59:58 <mapreduce> A complete waste of beer.
03:00:24 <mapreduce> I'd consider a CS degree worthless if it didn't include lambdas.
03:00:39 <mapreduce> Mine omitted lambdas.
03:00:44 <pelirrojo> mine will include haskell it seems
03:00:59 * ivanm just did an IT degree, not a CS one
03:01:47 <Baughn> @hoogle ICANON
03:01:47 <lambdabot> System.Posix.Internals const_icanon :: CInt
03:03:18 <Baughn> @hoogle canonical
03:03:18 <lambdabot> System.Directory canonicalizePath :: FilePath -> IO FilePath
03:07:09 <Baughn> @hoogle getCurrentTime
03:07:09 <lambdabot> Data.Time.Clock getCurrentTime :: IO UTCTime
03:07:09 <lambdabot> Data.Time.LocalTime getCurrentTimeZone :: IO TimeZone
03:07:20 <hugo__> in the future, im going to win the nobel prize of literature
03:07:24 <hugo__> just so you know in advance
03:07:40 <quicksilver> hugo__: thanks. Can I get a free copy of the book, please.
03:07:58 <hugo__> quicksilver: yes, when i finish it ill send it to you
03:08:02 <cads> did your cs at least include like finite automata and turing machines, mapreduce?
03:08:10 <hugo__> it will be written in portuguese though :P
03:08:35 <quicksilver> that's OK. I jsut want to tell people "You see that nobel-prize winning book? I helped that author with his haskell"
03:08:36 <Baughn> @hoogle setCooked
03:08:36 <lambdabot> System.Posix.Internals setCooked :: FD -> Bool -> IO ()
03:08:40 <quicksilver> it doesn't matter if I can't read it.
03:08:44 <hugo__> :D
03:08:46 <mapreduce> cads: No.
03:09:05 <mapreduce> Let me summarise my degree for you:
03:09:06 <cads> what the heck did it inluJAVA?!
03:09:11 <mapreduce> Java.
03:09:29 <mapreduce> Not only that, but Java taught by people who didn't know it properly.
03:09:32 <cads> how do they figure that's computer _science_?
03:09:32 <Baughn> ..am I supposed to say "hSetBuffering stdin NoBuffering"?
03:09:41 <Baughn> That makes no sense, though. ;_;
03:09:47 <mapreduce> cads: The British Computing Society approves it.
03:10:04 * cads buys mapreduce a stiff drink
03:10:18 <cads> sounds like it was traumatic
03:10:25 <vegai> anyone know what's going on here? http://hpaste.org/11221
03:10:30 <mapreduce> Thankfully I already learned to program many years before that degree, and apart from working with Java now, I've largely recovered.
03:10:50 <vegai> what does #) mean?
03:11:08 <cads> mapreduce, from your nickname i'd guess you know about hadoop :d
03:11:24 <cads> but have you heard of clojure?
03:11:29 <mapreduce> Yes, yes.
03:11:30 <vegai> oh, he has defined (#)
03:12:17 <mapreduce> Clojure isn't interesting to me because it is dynamically typed.
03:12:23 <vegai> if (#) is defined, is this allowed then? ("foo" #)
03:12:37 <cads> aye, it be a lisp
03:12:38 <mapreduce> Hadoop is somewhat interesting, but I don't have a use for it right now.
03:12:42 <hugo__> i have recently discovered the wonders of using point-free programming in order to delay monad use
03:12:52 <mapreduce> cads: So's Liskell, but that's not dynamically typed.
03:13:35 <cads> the unholy insemination of mother lisp with haskell's filthy seed no doubt
03:15:14 <cads> hey that's just lisp on top of ghc!
03:15:35 <hugo__> in haskell, the name of function arguments is usually written in camel case ?
03:16:06 <hugo__> i writen them in c style: lowercase with '_' separating the names, like: current_day
03:16:23 <hugo__> is there a "haskell coding conventions" manual ?
03:16:28 <Cale> hugo__: usually more like currentDay
03:16:46 <therp> cads: not really, we are still missing eval, but I prefer the syntax
03:16:53 <hugo__> oh, camelcase :/
03:17:00 <quicksilver> you see both camelCase and c_style
03:17:03 <Cale> http://urchin.earth.li/~ian/style/haskell.html
03:17:05 <lambdabot> Title: Good Haskell Style
03:17:21 <hugo__> i tend to prefer c_style over camelCase
03:17:25 <quicksilver> I tend to use camelCase for exported functions but sometimes c_style_for_auxiliary_private_functions
03:17:39 <quicksilver> the coolest style cleary'names'like'this
03:17:42 <BeelsebobWork> in all honesty, I don't like his last example
03:17:43 <therp> hugo__: what's your reason to do so?
03:18:05 <BeelsebobWork> purely because I would have written it as case x of
03:18:10 <BeelsebobWork> Nothing -> 0
03:18:16 <BeelsebobWork> Just Nothing -> 1
03:18:21 <BeelsebobWork> Just (Just z) -> z
03:18:29 <BeelsebobWork> to save on indentation
03:18:47 <ahunter> So if I'm working in GHCI I can supress the output of a pure function really easily -- let x = map (*2) [1..100000], instead of just the map
03:18:49 <BeelsebobWork> (I would have indented it the same as him though)
03:19:09 <Cale> ahunter: That doesn't evaluate x though, of course.
03:19:15 <ahunter> Cale: getting there :P
03:19:30 <ahunter> I'd like to be able to do the same for monadic expressions...can I?
03:19:37 <ahunter> While forcing evaluation, actually, yes.
03:19:39 <Cale> You mean IO?
03:19:42 <ahunter> yah
03:19:52 <Cale> (while forcing execution, you mean :)
03:19:56 <BeelsebobWork> ahunter: a ghci session essentially is one big IO do block
03:19:58 <ahunter> heh
03:20:01 <quicksilver> the award for ugliest function name in the libraries goes to the author of "writeList2Chan :: Chan a -> [a] -> IO ()"
03:20:05 <Cale> Evaluating IO actions is different from executing them.
03:20:08 <quicksilver> I'm guessing JaffaCake but I don't know :)
03:20:10 <ahunter> BeelsblobWork: yeah, I know--I just odn't want it echoing back at me
03:20:14 <ahunter> Cale: ah, right
03:20:14 <quicksilver> what were they thinking?
03:20:20 <hugo__> c_style is more expressive and less ambiguous than camelCase, as experience, of working professionally with java and c, tells me
03:20:21 <ahunter> I.e. baz <- somethingThatMakesALotOfOutputIDontWantToSeeButWantToHave
03:20:32 <Cale> ahunter: GHCi used to be more sane and not print the result
03:20:35 <ahunter> can I type that at top level without waiting five minutes for the output to scroll by? :P
03:20:38 <BONUS> writeList4Chan
03:20:53 <quicksilver> -fno-print-bind-result
03:20:55 <quicksilver> or something
03:20:56 <Cale> Um, I'm pretty sure you can.
03:21:01 <quicksilver> :set -fno-print-bind-result
03:21:18 <Cale> But yeah, -fno-print-bind-result  (though that doesn't actually work as well as advertised.)
03:21:50 * Cale decides to upgrade to intrepid a little early.
03:22:48 <hugo__> but im not sure of how it fits in haskell... probably camelCase fits better than c_style, anyway whatever... as long as it is readable and consistent
03:23:27 <Cale> hugo__: camelCase makes you consistent with all the standard libraries, which is generally a good thing
03:23:45 <Cale> But of course, it doesn't matter that much.
03:24:07 <Cale> More important is that your editor is not putting tab characters into your source files.
03:24:11 <hugo__> :D
03:24:26 <hugo__> it isn't, i have it configured for 4-space-characters tabs
03:24:38 <Cale> yeah, that's a good way to go.
03:24:44 <hugo__> i haven't managed how to configure vim for haskell syntax highlight :/
03:24:53 <Cale> :syntax on
03:24:55 <Cale> usually does it
03:25:02 <hugo__> i haven't got the file
03:25:05 <Cale> oh?
03:25:06 <ivanm> hugo__: there's a haskell mode for vim IIRC
03:25:19 <ziman> just get the syntax and filetype plugins
03:25:20 <Cale> vim comes with a haskell syntax highlighter by default usually
03:25:20 <BONUS> just set syntax to on and do :set ai and you're fine
03:25:25 <Cale> (at least, in my experience)
03:25:40 <hugo__> yes, in windows it works fine, in openSuse it doesn't :/
03:25:46 <ivanm> hugo__: http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
03:25:47 <lambdabot> Title: Haskell mode for Vim
03:26:02 <BONUS> hugo: maybe you have an older versiion?
03:26:24 <hugo__> 2007 May 12
03:26:27 <hugo__> 7.1
03:27:09 <hugo__> ill work out this site :)
03:31:41 <cads> is the consumption of human flesh strictly illegal in the united states?
03:32:12 * cads wishes to be made into a soup upon his death
03:32:24 <cads> but not if it would get my friends in trouble
03:32:27 <ivanm> cads: you a fan of Stranger in a Strange Land, are you?
03:32:34 <hugo__> allright, vim is working now :)
03:32:41 <cads> lil bit
03:33:33 <hugo__> anyway, for vim users, check this video out if you haven't already: http://video.google.com/videoplay?docid=2538831956647446078&ei=w2n4SPa6IZKu2wKftrTvDg&q=vim
03:33:34 <lambdabot> Title: 7 Habits For Effective Text Editing 2.0, http://tinyurl.com/6d9nhh
03:34:01 <ivanm> cads: heh, thought so
03:34:09 <ivanm> just so you know, it's _fiction_ :p
03:34:29 <hugo__> i found it most usefull :)
03:35:06 <ivanm> anyone here familiar with gnuplot?
03:35:25 <osfameron> cads: you could maybe arrange to be souped outwith the US
03:35:39 <osfameron> I'm not sure which countries offer this service though
03:37:02 <cads> cadsbell's chickcad noodle soup?
03:55:05 <Baughn> Off the top of your hat, how much entropy would you say there's in the timing of one keyboard button press?
03:55:31 <Baughn> Or rather, one more; I likely will want more than one.
03:57:11 <rog> is there a way of getting a thread-local variable in the IO monad?
03:57:22 <Baughn> rog: Sure, IORef
03:57:33 <Baughn> rog: Just don't pass it to another thread, and it'll be thread-local.
03:57:58 <Baughn> (Normally thread-local variables are thread-local *globals*, which is why you have to specify. Haskell doesn't have globals.)
03:58:30 <rog> Baughn: but then you need the IOref itself... i was wondering if it was possible to have something similar but where the IOref could refer to different values in different threads.
03:59:13 <Baughn> rog: No. Also, you are a bad person for asking.
03:59:40 <Baughn> Though you could probably cook something up with data.map and currentThreadID
04:00:13 <rog> Baughn: the reason is i was thinking of making a little library in the IO monad where there's some state per process. and i was hoping to avoid using currentThreadID :-)
04:01:01 <Baughn> rog: You may want to rethink that design. I don't think many people would be happy about a library that somehow behaves differently depending on who calls it - generally you'll want a context to pass around instead.
04:01:16 <Baughn> Perhaps with a default, global one, like opengl and openal have
04:01:19 <rog> currentThreadID behaves differently depending on who calls it...
04:01:32 <Baughn> That's hardly the same thing
04:01:51 <quicksilver> Baughn: depends how accurate your timer is.
04:01:59 <cads> baugn, linux has /dev/rand which extracts entropy from your keyboard and network adaptor
04:01:59 <ac> blist
04:02:07 <Baughn> cads: I know. I'm not allowed to use it.
04:02:12 <quicksilver> Baughn: If you have an accurate microsecond timer, htne I'm sure there is easily 10-15 bits per keypress
04:02:12 <cads> aha
04:02:17 <Baughn> quicksilver: And I hardly need an exact answer, just.. ah.
04:02:34 <ahunter> A bit of a long shot here: has anyone seen people implement algorithms for {perfect,maximal} matchings in Haskell?
04:02:36 <quicksilver> rog: yes, please don't do that.
04:02:37 <Baughn> quicksilver: I've got whatever getCurrentTIme gives me
04:02:52 <quicksilver> rog: idiomatic haskell code does not care which thread it is run in.
04:03:07 <Baughn> quicksilver: I've got whatever getCurrentTIme gives me, which appears to be microseconds, so that sounds good.
04:03:11 <rog> Baughn: you can extract randomness, assuming preemptive scheduling, by using a beating-clocks algorithm
04:03:34 <Baughn> rog: No, I'm specifically supposed to use keyboard input. ;)
04:03:37 <rog> quicksilver: so why provide currentThreadID?
04:03:46 <Baughn> I'm stretching the assignment already by using timings instead of the character values
04:03:51 <quicksilver> rog: debugging, mainly.
04:05:10 * Baughn just throws it through show and into a cryptographic hash function set to "blend".
04:05:39 <rog> i think my other possibility is probably the better one: create a new monad, and have it convertible into IO.
04:06:14 <quicksilver> sounds better
04:06:22 <Baughn> rog: Make it an instance of MonadIO
04:06:33 <quicksilver> Baughn: how accurate getCurrentTime is depends on your platform.
04:06:43 <quicksilver> Baughn: I think it's likely to be sub-millisecond but not quite microsecond.
04:06:54 <Baughn> quicksilver: It's obviously microsecond on OS X, at least
04:07:35 <araujo> morning
04:07:39 <Baughn> quicksilver: Also, this program will most likely never be actually *run*, so.. ;_;
04:08:13 <Baughn> (At this point the ratio of mathematica-code-assignment-size to haskell-assignment-size is up to 8:1. I'm getting increasingly amused.)
04:20:01 <Baughn> @pl \k -> sum . map fst . filter snd . zip (map (2^) [0..]) . flip hashKBit (fromIntegral k) . unpack . fromString . show
04:20:02 <lambdabot> ((sum . map fst . filter snd . zip (map (2 ^) [0..])) .) . (. (unpack . fromString . show)) . flip hashKBit . fromIntegral
04:20:21 <mapreduce> @pl \x y -> x * x + y
04:20:22 <lambdabot> (+) . join (*)
04:20:27 <mapreduce> @pl \x y -> x * x + y * y
04:20:27 <lambdabot> (. join (*)) . (+) . join (*)
04:20:49 <mapreduce> There have to be better primitives for point-free. :)
04:22:30 <EvilTerran> mapreduce, yeah, the arrow ones
04:22:30 <lambdabot> EvilTerran: You have 2 new messages. '/msg lambdabot @messages' to read them.
04:22:50 <EvilTerran> , src 'id
04:23:07 <lunabot>  id :: forall a . a -> a
04:23:31 <EvilTerran> , src 'sort
04:23:37 <lunabot>  sort :: forall a . Ord a => ([a]) -> [a]
04:23:43 <EvilTerran> iiiinteresting
04:24:19 <EvilTerran> mapreduce, also, that's ((+)`on`(^2))
04:24:35 <EvilTerran> :D
04:26:48 <hugo__> hmm
04:27:40 <hugo__> ghci didn't warn me about using the same name of a function argument inside a where...
04:27:47 <hugo__> ...so it just tripped out when i ran it
04:28:08 <hugo__> strange... it should avoid those coding ambiguites, at least with a warning i think...
04:31:04 <hugo__> now, what is strange is that i can't reproduce its erroneous behaviour with a simpler function :/
04:31:33 <luqui_> hugo__, yeah, ghci probably won't.  ghc -Wall probably will though.
04:31:52 <Baughn> hugo__: So will ghci -Wall
04:32:13 <luqui_> oh yeah, ghci -Wall does all
04:32:13 <luqui_> er, also
04:32:34 <luqui_> although ghci -Wall is kindof annoying, with all the defaulting messages and whatnot
04:33:03 <hugo__> hmm ok, nice
04:37:29 <EvilTerran> are there finer-ground -W flags?
04:37:41 <EvilTerran> -Wshadowing -Wdefaulting -Wetcetc
04:38:12 <inimino> finer-grained
04:38:17 <EvilTerran> grained, yes
04:38:34 <EvilTerran> ground kinda works too; you grind something finer to get it in finer grains :P
04:38:38 <inimino> finer-ground is reserved for when GHC makes you coffee
04:38:47 <EvilTerran> anyway
04:38:53 * EvilTerran -> lecture
04:39:04 <quicksilver> EvilTerran: it wpn't be as interesting as staying here.
04:39:53 <therp> anyone up to writing a webkitgtk-based one-sandboxed-subtask-per-website/tab (chrome style) web browser in Haskell?
04:40:24 <therp> I'm SO fed up by the broken design of firefox not able to cope with websites that has badly written javascript
04:40:38 <inimino> hm, is Haskell really well-suited to that?
04:40:50 <therp> also I'm not entirely sure why it needs 1.2gb of memory
04:41:09 <therp> inimino: why not?
04:42:57 <inimino> therp: it just seems like you'd be gluing existing libraries together
04:43:09 <therp> inimino: bingo.
04:43:32 <therp> inimino: I still want to go out on Saturday night, so I would take webkit
04:44:19 <therp> the python bindings to webkit have a very encouraging 100 line demo of a web browser
04:44:49 <therp> all we'd need is a history db probably something to store user names and passwords
04:45:02 <EmielRegis> hello
04:45:03 <inimino> well, I guess I'd try Python if you want to make a prototype
04:45:05 <EmielRegis> anyone alive?
04:45:06 <Saizan_> are there proper webkit bindinings for haskell already?
04:45:10 <inimino> otherwise C++
04:45:12 <EmielRegis> i could use some help for i am haskell noob
04:45:21 <araujo> therp, I have thought to start my own Haskell browser too
04:45:23 <therp> the part that complicates the whole idea is that I want to sandbox everything in an own thread/task.
04:45:31 <therp> Saizan_: haven't found any
04:45:31 <Saizan_> EmielRegis: feel free to ask
04:45:34 <EmielRegis> ok
04:45:36 * araujo just want a usable thing
04:45:43 <EmielRegis> i want to find a way of getting elements index in a list
04:45:44 <therp> araujo: me too
04:45:51 <EmielRegis> without using elemIndex or other function
04:46:17 <quicksilver> zip "numberthis" [0..]
04:46:22 <quicksilver> > zip "numberthis" [0..]
04:46:23 <lambdabot>   [('n',0),('u',1),('m',2),('b',3),('e',4),('r',5),('t',6),('h',7),('i',8),('...
04:46:24 <araujo> therp, Also been thinking to use webkit
04:46:27 <quicksilver> EmielRegis: like that, perhaps.
04:46:34 <araujo> it seems like a nice option
04:46:43 * araujo wants to have more free time to give it a try to this
04:47:18 <therp> araujo: check out http://clemens.endorphin.org/webbrowser.py - that's the python demo of a graphic user interface to webkit
04:47:22 <inimino> therp: I guess I don't think of Haskell as a glue language
04:47:34 <EmielRegis> hmm
04:47:37 <araujo> therp, ok, thanks, I will check now
04:47:42 <therp> araujo: check out http://clemens.endorphin.org/webbrowser.py.txt  - for another mimetype
04:48:19 <therp> inimino: every language must be ready to serve as glue language. otherwise it's useless (<- personal opinion)
04:48:25 <EmielRegis> quicksilver, so given a list of strings 'list', i would do zip "wantedNumber" list ?
04:48:27 <inimino> I think of Haskell as more appropriate for doing real work, not gluing libraries together
04:48:56 <quicksilver> EmielRegis: no.
04:48:58 <inimino> therp: perhaps, but clearly something like Python has an advantage in existing bindings
04:49:01 <quicksilver> EmielRegis: zip list [0..]
04:49:08 <nha__> is there a better way to branch on GADT type aside from doing f x@(T _ _ _ ) = g x
04:49:09 <therp> inimino: that's true
04:49:28 <therp> inimino: and static typing doesn't help either with haskell
04:49:41 <inimino> therp: right
04:49:47 <quicksilver> static typing can be beneficial in glue, but you need to write the types down.
04:49:53 <quicksilver> (IYSWIM)
04:50:05 <quicksilver> and the types may not already be written down, so that makes it "more work"
04:50:18 <Saizan_> yeah, you need to convert the type of the foreign language in the haskell type system
04:50:30 <Saizan_> "types"
04:50:33 * quicksilver nods
04:50:34 <EmielRegis> ah
04:50:36 <EmielRegis> thank you
04:51:03 <inimino> the discipline of Haskell code adds work to creating a clean binding to foreign APIs
04:51:07 <Saizan_> webkit is c++ right? so you can't use c2hs/hsc2hs?
04:51:16 <inimino> yes, C++
04:51:50 <Saizan_> well, you can start with a straightforward binding and add a nicer api later
04:52:43 <therp> is it still necessary to go via a C layer to interface to C++ or are there more direct routes to C++ from haskell?
04:52:51 <rog> Baughn: if it's of any help, you *should* be able to generate real(ish) randomness with something like (http://hpaste.org/11222#a0) although actually it runs out of memory and i don't know why!
04:52:54 <therp> I think I have seen the C-layer trick with wxhaskell
04:53:02 <hugo__> i saw this portuguese joking picture of obama, it was a picture of him, like a poster, and on the right said "don't vote in white"
04:53:33 <rog> Baughn: (obviously, it's slow as hell, but at least you don't have to have a user there banging on a kbd)
04:55:13 <quicksilver> therp: how can there be a direct route when C++ doesn't have an ABI?
04:55:28 <Baughn> rog: Having a user banging on the kbd is the *point*, I'm afraid. :P
04:55:29 <quicksilver> therp: nobody knows how to link to C++ except the C++ compiler than compiled the library.
04:55:37 <Baughn> rog: If I actually wanted random numbers, I'd read /dev/random.
04:55:45 <therp> quicksilver: I would be ok with something gcc specific
04:55:54 <quicksilver> I wouldn't.
04:56:05 <quicksilver> g++'s ABI tends to change every minor version
04:56:10 <quicksilver> if not just because of the phase of the moon.
04:56:26 <rog> Baughn: ok. well, it was an interesting exercise anyway! anyone got any idea why/where it's running out of memory?
04:56:46 <quicksilver> therp: you could of course automatically generate the C warpper code
04:56:51 <quicksilver> (And then compile that with your C+ compiler)
04:57:28 <Baughn> rog: Yeah, you're stuffing v with increasingly large thunks
04:57:56 <rog> Baughn: but i tried it with a seq, and it didn't make any difference...
04:57:56 <Baughn> rog: It's perfectly capable of filling the heap before slow forces it, at which point it'd stack overflow
04:58:16 <Baughn> rog: Oh, and you want MVars. IORef isn't threadsaf.e
04:58:26 <rog> Baughn: ... that's the whole point!
04:58:36 <Baughn> rog: ...you risk corrupting the runtime
04:58:53 <rog> Baughn: really?
04:59:02 <Baughn> rog: Probably not, but it's not smart
04:59:09 <rog> Baughn: even when just reading/writing an Int?
04:59:33 <Baughn> rog: I think the read/write is actually atomic. Not that that'd help much in most cases.
04:59:42 <luqui__> oh, really?  I thought IORefs were threadsafe but just didn't provide good atomicity features
05:00:03 <Baughn> Hm, I wonder
05:00:09 <Baughn> atomicModifyIORef is certainly thread-safe
05:00:12 <luqui__> if not, then my data-ivar is horriby wrong
05:00:14 <rog> luqui__:  that's what i thought. and that was the semantics i was after.
05:00:15 <Baughn> The other functions *don't say anything*
05:00:46 <Deewiant> atomicModifyIORef says that it works if you only ever have one IORef
05:00:55 <Peaker> is STM mature? If so, why use MVars and not TVars/STM?
05:01:07 <Baughn> Deewiant: Well, yeah; you can't atomically modify two of them.
05:01:21 <Deewiant> Baughn: so that doesn't seem very robust to me :-P
05:01:38 <rog> the whole point of the function was to increment the ioref as fast as possible (to gain as much entropy as possible). so using an atomic update would be unnecessary and counterproductive
05:01:39 <Deewiant> Peaker: it might be easier to think of something in terms of MVars/Chans/QSems and whatnot
05:02:08 <Baughn> rog: I suggest you use writeIORef with $!
05:02:10 <Deewiant> I might still have a little proggy somewhere which randomly crashes with TVars but works with MVars, even though I think the code is equivalent
05:02:12 <Peaker> Aren't all these concepts possible to layer up on top of STM, and thus get the additional power of STM?
05:02:25 <luqui> a lot of times IORef is just fine for building other threading abstractions on top of.
05:02:32 <Baughn> rog: Although, you could use readIORef and seq to make the write conditional on the read value being fully evaluated
05:02:37 <luqui> assuming it really is threadsafe
05:02:38 <Deewiant> Peaker: what is the additional power of STM if you're just doing non-STM stuff?
05:02:49 <luqui> but STM is the way to go for more traditional concurrency stuff
05:03:13 <Deewiant> Peaker: and also, I don't think all the concepts exist in the library so you'd have to do the layering yourself ;-)
05:03:21 <luqui> Deewiant, how can you do STM stuff without STM is the question?
05:03:27 <Peaker> Deewiant: automatic proper error handling/unwinding, transaction aborts/retries, etc
05:03:43 <luqui> if you ever need a lock, STM is probably better because locks are hard to think about, and transactions are easy to think about
05:03:50 <luqui> (mostly because of composability)
05:04:03 <Deewiant> luqui: of course if you think your problem maps better to STM then by all means use that
05:04:07 <Peaker> lock-based code is not composable
05:04:15 <quicksilver> luqui: ...until your trasactions have to execute IO actions.
05:04:31 <quicksilver> luqui: and then you have to work out exactly what the side condition for unsafeIOtoSTM is.
05:04:37 <Deewiant> ah yes, good point, doing IO in STM is a bit tricky :-)
05:04:43 <Peaker> @type unsafeIOtoSTM
05:04:44 <lambdabot> Not in scope: `unsafeIOtoSTM'
05:04:47 <rog> luqui: i'd agree with that STM is nice for data-structure-based concurrency. it doesn't do synchronisation so well though.
05:04:48 <Peaker> @hoogle unsafeIOtoSTM
05:04:48 <lambdabot> No results found
05:04:59 <luqui> rog, it doesn't?
05:05:10 <luqui> retries work fine ime.
05:05:25 <rog> luqui: they do. but you can't have a two-way communication in STM
05:05:41 <luqui> rog, the thing is, MVar is easily implemented in STM.
05:05:56 <luqui> so whatever you could do with MVar, you can do just as easily in STM
05:05:59 <rog> luqui: MVar is data-structure baed.
05:06:14 <luqui> I don't know what you mean by that
05:06:35 <luqui> what do you propose as the alternative to STM for the situations you're talking about?
05:06:51 <rog> luqui: that's not quite true. you can easily build a primitive using MVars that not expressible within STM.
05:07:15 * luqui wonders, and challenges rog to do so as he tries to disprove this claim
05:07:41 <rog> luqui: i'm not saying STM is not great (it is); just that there are other primitives that are useful that can't be expressed within it.
05:07:42 * inimino gets popcorn
05:08:02 <rog> luqui: there was a thread on the cafe recently.
05:08:23 <luqui> yeah I totally lost interest in that thread :-)
05:08:45 * luqui still tries to disprove this, because he prefers to solve problems than to read solutions :-)
05:08:53 <luqui> it helps build understanding :-)
05:09:12 <rog> ok. well, try to build a synchronous channel primitive *within* STM.
05:09:29 <Peaker> rog: can you paste a link to that thread?
05:09:42 <luqui> rog, *within*?   you mean not using atomically?
05:10:13 <rog> Peaker: http://www.haskell.org/pipermail/haskell-cafe/2008-October/048949.html
05:10:14 <lambdabot> Title: [Haskell-cafe] synchronous channels in STM, http://tinyurl.com/5wbhg4
05:10:46 <rog> luqui: i mean that the channel operations have type STM a for some a.
05:10:56 <Saizan_> luqui: yeah, send :: Chan a -> a -> STM a, recv :: Chan a -> a -> STM a, where send blocks until a corresponding recv is done
05:11:10 <Peaker> rog: thanks
05:12:56 <luqui> of course that is impossible.  STMs don't block, IOs do.
05:12:59 <rog> anyway, i'm still not sure why this (http://hpaste.org/11222) runs out of memory. i'd have thought that with the seq, all would be fine. but it isn't.
05:13:09 <rog> luqui: STMs do block!
05:13:18 <rog> luqui: that's what retry is all about!
05:13:19 <luqui> no, STMs retry
05:13:29 <luqui> which makes the corresponding atomically block
05:13:44 <luqui> the STM itself does not block.
05:13:49 <EmielRegis> hmm
05:14:01 <EmielRegis> getElemIndex :: [(Char, Int)] -> Char -> Int
05:14:02 <EmielRegis> getElemIndex [] c = 0
05:14:02 <EmielRegis> getElemIndex (x:xs) c 	| fst x == c = return (snd x)
05:14:02 <EmielRegis> 						| otherwise = getElemIndex xs c
05:14:07 <EmielRegis> anyone can tell whats wrong with this code?
05:14:08 <luqui> btw, http://hpaste.org/11223  -- MVar in STM
05:14:12 <EmielRegis> getting wrong inferred type error
05:14:15 <EmielRegis> for snd x
05:14:19 <luqui> proof that STM is no less expressive than MVar :-)
05:14:35 <rog> luqui: i *know* it's trivial to do an MVar in STM
05:14:54 <Deewiant> EmielRegis: remove the return
05:15:11 <luqui> rog, so i ask, what is it that STM is not appropriate for, and what's the alternative?
05:15:20 <luqui> problems, not type signatures
05:15:23 <EmielRegis> oh
05:15:28 <rog> luqui: but MVar doesn't pretend to be a universally composable thing. if you're just using STM to implement MVar, you might was well use MVar...
05:15:31 <EmielRegis> heh too much C for me
05:15:55 <luqui> rog, I say, if you're just using MVar, you might as well use STM
05:15:56 <Saizan_> rog: v `seq` (v+1) is of no help, since if you need to evaluate (v+1) you already have to evaluate v, what you need is v `seq` modifyIORef v (+1)
05:16:18 <Saizan_> rog: ops, sorry wrong type
05:16:41 <audreyt> luqui: is that like "if you're just using Just/Nothing, you might as well use return/fail"?
05:16:59 <rog> luqui: STM's can't implement (for instance) RPC-type things.
05:17:18 <quicksilver> @quote final
05:17:18 <lambdabot> syntaxfree says: Functional programming has finally arrived to the masses. Its name is not Lisp, ML or Haskell: it's Visual Basic
05:17:25 <quicksilver> @quote initial
05:17:25 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
05:17:32 <Deewiant> @quote fail
05:17:32 <lambdabot> lambdabot says: Plugin `quote' failed
05:17:41 <luqui> rog, they can implement it just as well as any other concurrency primitives, I claim.
05:18:05 <luqui> audreyt, heh.  MVar is not initial for STM, since they are incompatible.
05:18:23 <quicksilver> @remember mckinna you don't need to
05:18:23 <quicksilver> produce elements of an *arbitrary* whatever-it-is when you
05:18:23 <lambdabot> I will never forget.
05:18:27 <quicksilver> gah
05:18:32 <luqui> audreyt, whereas Maybe is initial for return/fail using "maybe fail return"
05:18:33 <quicksilver> @forget mckinna you don't need to
05:18:33 <lambdabot> Done.
05:18:34 <rog> luqui: perhaps. but the point is, the moment you do that, you're going outside STM and building a new set of primitives, that don't have the nice composable semantics of STM
05:18:51 <quicksilver> @remember mckinna you don't need to produce elements of an *arbitrary* whatever-it-is when you can produce elements of the *initial* whatever-it-is
05:18:51 <lambdabot> Done.
05:18:51 <luqui> rog, it is the truth, STM can not solve all of life's problems by itself
05:19:10 <rog> luqui: so then the question is: what are good primitives to choose?
05:19:31 <byorgey> drat
05:19:39 * byorgey was hoping to solve all his life's problems with STM
05:19:45 <Saizan_> with STM is so easy to build ad-hoc primitives that i wouldn't stick to any particular set
05:19:46 <TomMD> All you need in a programming language is a 'nand' gate.
05:20:02 <luqui> rog, that is the problem's question.  my argument is, whatever they are, they are implemented in terms of atomically, and read/writeTVar  (if the primitives mention concurrency)
05:20:19 <rog> luqui: personally, i've done a lot of programming using CSP (synchronous channels) and really like it, and find it straightforward to build elegant concurrent systems that way. others care to differ :-)
05:20:32 <luqui> rog, and you can implement them in terms of STM no?
05:20:47 <inimino> byorgey: you can, but there's no guarantee on the runtime of the program.
05:20:49 <luqui> I mean, fairly straightforwardly
05:20:55 <byorgey> hehe
05:21:17 <luqui> (you can implement sTM in terms of MVar, but it's a fucking bitch, requires global table and weak references, etc.)
05:21:19 <rog> luqui: sure, i can implement them in terms of STM or MVars or whatever. but that's just an implementation concern, and not visible at the interface level.
05:21:36 <luqui> rog, I am arguing the point "there are reasons not to use STM"
05:21:39 * byorgey goes off to write a program to solve all his problems and also print busy beaver numbers
05:22:05 <quicksilver> STM has a kind of composability at the interface level
05:22:15 <quicksilver> which many other systems don't have
05:22:18 <quicksilver> that's quite interesting.
05:22:23 <luqui> rog, i.e. I argue that STM is a great concurrency *primitive*, and there is no reason to use MVar or (gah) IORef as your primtive instead.
05:22:25 <pyNem> can someone clarify this to me, wrt monads? I am learning this newly... A monad
05:22:37 <quicksilver> if you use STM as your primitive you can potentially lift it up to your interface level.
05:22:42 <pyNem> 's bind has the structure m a -> (a -> m b) -> m b
05:22:42 <quicksilver> but not always.
05:22:48 <rog> luqui: how does STM perform compared to MVars ?
05:22:48 <quicksilver> especially when other IO intervenes.
05:22:52 <luqui> i'm not saying that STM is better than all other concurrency abstracitons, i'm saying it is initial for all other concurrency abstractions
05:23:01 <pyNem> why not ..  m a -> (m a -> m b) -> m b
05:23:10 <pyNem> that would be easier to write
05:23:15 <pyNem> and easier to understand, as a pipe
05:23:30 <Deewiant> but you can't get bind from that
05:23:31 <rog> quicksilver: i agree with that. and that's why i would use STM if i did a CSP module.
05:23:34 <quicksilver> pyNem: we can do that for any type 'm'
05:23:34 <luqui> rog, the question in idiomatic usage is open.  As for when STM is simply emulating MVars, I am not sure.
05:23:39 <Deewiant> although you can get that from bind
05:23:39 <quicksilver> pyNem: doesn't need to be a monad to do that.
05:23:46 <pyNem> quicksilver, no no.. what I mean is ..
05:23:47 <quicksilver> pyNem: that's jsut function composition.
05:24:00 <pyNem> quicksilver, why not choose seomthing like that
05:24:00 <pyNem> yeah
05:24:04 <pyNem> func composition
05:24:11 <rog> quicksilver: but when doing very simple things, a one-element-buffer channel (aka. an MVar) is just fine. and universally available.
05:24:12 <Deewiant> ?ty flip id :: Monad m => m a -> (m a -> m b) -> m b
05:24:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (m a -> m b) -> m b
05:24:15 <pyNem> quicksilver, instead of having an 'a' ther e..
05:24:36 <quicksilver> pyNem: because that doesn't need a monad.
05:24:43 <quicksilver> pyNem: that is just function composition.
05:24:49 <quicksilver> pyNem: no special qualities required :)
05:24:53 <Saizan_> pyNem: because then thre's not way to observe the 'a' from inside (m a -> m b)
05:25:19 * quicksilver thinks Saizan_'s observation is more interesting, actually.
05:25:28 <quicksilver> Not more true, of course. But perhaps more to the point.
05:26:23 <pyNem> quicksilver, I am not saying that isnt. I am questioning why monads were chosen, and not just plain functional composition .. let us call my bind as >>% .. then  g >>% k now simply becomes g >>= (\x -> k (return x)) ?
05:26:42 <pyNem> Saizan_, I dint quite understand
05:26:51 <Saizan_> pyNem: try writing >>= using your >>%
05:26:58 <rog> quicksilver: which observation?
05:27:07 <Saizan_> pyNem: than you'd see that Monad's interface is more expressive than yours
05:27:12 <quicksilver> rog: the comment he made immediately before mine ;)
05:27:27 <rog> quicksilver: oh yeah, i'm blind!
05:27:33 <pyNem> Saizan_, Hm.. yes, I see problems..
05:27:37 <pyNem> Saizan_, But what if I introduce a function unlift (opposite of return)? Then wouldnt it be possible?
05:28:03 <Axman6>  how do you unlift a list?
05:28:17 <ilyak> pyNem: It is called unsafePerformIO
05:28:31 <ilyak> for IO
05:28:34 <inimino> and it's unsafe ;-)
05:28:38 <quicksilver> pyNem: if you have an opposite to return then, again, monads lose their interesting properties.
05:28:40 <ilyak> yeah, it can't be the other way
05:28:52 <pyNem> Axman6, Saizan_ I give up .. :) .. I guess a monad was a good choice after all ..
05:28:54 <pyNem> quicksilver, I realise
05:28:58 <quicksilver> pyNem: the inability to extract the value is one of the key features.
05:29:00 <Axman6> heh
05:29:02 <quicksilver> the simplest example is reader
05:29:02 <luqui> pyNem, don't give in so easily!
05:29:05 <pyNem> quicksilver, they lose their (state/contained data)
05:29:05 <Saizan_> pyNem: for a lot of monads you can't write your unlift in a meaningful way
05:29:07 <quicksilver> (r -> a)
05:29:15 <quicksilver> ^^ you can't pull the "a" out of (r -> a)
05:29:21 <pyNem> Saizan_, yeah .. I realise
05:29:22 <quicksilver> ...because you need an 'r' to do so.
05:29:26 <quicksilver> which is the point of that monad.
05:29:33 <pyNem> quicksilver, yeah .. :)
05:29:40 <Saizan_> for comonads instead..
05:29:44 <pyNem> luqui, you have suggestions to help me defend >>% ?
05:29:46 <pyNem> :D
05:30:02 <pyNem> Saizan_, Comonads? I am still learning, sorry ..
05:30:16 <luqui> pyNem, certainly not!   but there are plenty of alternatives to Monads to solve the problems monads solve.
05:30:24 <Deewiant> pyNem: hint: stay away from anything that starts with 'co'
05:30:27 <luqui> the design space is interesting, and monads are not clearly the best solution.
05:30:32 <pyNem> luqui, yeah.. but my >>% doesnt solve it
05:30:39 <luqui> true :-)
05:31:14 <ilyak> ma -> (ma -> mb) -> mb - isn't that an identity function of sort, like funcall?
05:31:16 <Saizan_> pyNem: they are the dual of monads, but they are still a rather experimental field :)
05:31:27 <luqui> (eg. uniqueness types for IO are at least as expressive as Monads.  I'm not sure if they are more so or not)
05:31:30 <ilyak> So instead of foo "bar" you now say foo `funcall` "bar"
05:31:33 <Deewiant> ilyak: flip id
05:31:38 <ilyak> maybe that
05:31:39 <Deewiant> ?ty flip id :: Monad m => m a -> (m a -> m b) -> m b
05:31:40 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (m a -> m b) -> m b
05:31:50 <luqui> Saizan_, in what way are they "experimental"?
05:31:51 <Deewiant> ?ty flip id :: a -> (a -> b) -> b
05:31:52 <Peaker> Functor m => Applicative m => Arrow m => Monad m
05:31:52 <lambdabot> forall a b. a -> (a -> b) -> b
05:32:01 <luqui> sure, we don't have very many useful examples...
05:32:24 <quicksilver> luqui: I'm pretty sure uniqueness types are not as expressive as monads, for IO.
05:32:39 <pyNem> basically, I am planning to write the Pascal -> C translator as part of my Compilers Course, in the Univ I am studying, in Haskell. Everyone else is doing it with lex and yacc.. I had understand basic functional programming (ala Scheme). I have been breaking my heads on monads?
05:32:47 <luqui> quicksilver, oh, because of concurrency?
05:32:55 <quicksilver> luqui: that springs to mind as one reason, yes.
05:33:00 <inimino> :t flip ($)
05:33:01 <lambdabot> forall a b. a -> (a -> b) -> b
05:33:04 <pyNem> While we are on it, any advice ? (I am doing something as big as this for the first time in a language I dont fully understand)
05:33:11 <luqui> quicksilver, because it is trivial to implement RealWorld -> (RealWorld, a), if RealWorld is unique
05:33:27 <quicksilver> luqui: I believe that, if you word the question quite precisely, Monads are the 'only' solution.
05:33:38 <quicksilver> luqui: however, it remains to ask if that is actually the right question.
05:33:39 <luqui> but yeah, I guess that was not a good semantics for IO to begin with...
05:33:51 <zachk> pyNem: I like to think of things is monads as having "monadic actions" the action varies from monad to monad, try monadic programming using >>= >> and lambdas, then learn the do notation
05:34:05 <vincenz> My machine at work is named 'unsafeperformio' :)
05:34:06 <zachk> s/is/in
05:34:08 <Saizan_> pyNem: http://www.haskell.org/haskellwiki/Monads_as_Containers <- this is a very good tutorial
05:34:09 <luqui> quicksilver, uh. what question?  "what is the best way to create an IO monad?"
05:34:11 <lambdabot> Title: Monads as containers - HaskellWiki
05:34:12 <pyNem> zachk, will do :)
05:34:18 <Peaker> I think monads are overly-expressive for many of the things they are being used for...
05:34:29 <ilyak> Like?
05:34:34 <pyNem> Saizan_, I am currently looking at All about monads, after giving up halfway through Wadler's paper on "M for func prog"
05:34:34 <luqui> vincenz, LOL that's a great name!
05:34:34 <Peaker> For example, parsing with monads
05:34:48 <ilyak> Monad is an interface to something
05:34:56 <ilyak> you don't have to use it
05:34:56 <quicksilver> luqui: something like "what is the best way to represent functions which have arbitrary computational effects[*] as well as producing a result; where computational effects is defined as ... "
05:34:59 <Peaker> parsing with arrows allows the parser to do interesting things parsing with monads cannot do
05:35:06 * luqui is of the opinion that if you can make a data structure into a monad efficiently, do so!  it's no crime!
05:35:07 <Saizan_> pyNem: that's pretty good too :)
05:35:09 <zachk> pyNem: learn each monad, monad by monad, learn IO, then the list Monad, then Maybe the Maybe monad, then learn ReaderT IO structurehere, then learn StateT IO structurehere
05:35:16 <ilyak> Peaker: Well, that's not because monads are overly-expressive
05:35:22 <ilyak> The opposite, I guess
05:35:23 <luqui> but a lot of times you lose efficiency that a purely applicative instance still affords
05:35:27 <maltem> Peaker: Yeah today what everyone wants is parsing with applicative functors :)
05:35:30 <Peaker> ilyak: yeah, but the monad interface means that your parser structure, in the parser instance, can be decided based on the parsed content itself
05:35:44 <pyNem> zachk, would you suggest learning everything, or just learning to use the Parser Monads and Parsec ?
05:35:53 <quicksilver> luqui: monads also appear to be more compositional than uniqueness types: try doing the equivalent of (MonadState m => m ()) in uniqueness types.
05:35:56 <Peaker> maltem: Arrows add a bit of expressiveness of Applicative, though I have to think about what the expressiveness is exactly :)
05:36:23 <Peaker> maltem: I think that extra expressiveness does not harm the parser's ability to do interesting things, but I am not sure
05:36:28 <luqui> quicksilver, I'm talking about initiality again.  monads *for IO*, so if you don't like uniqueness types, just wrap it up in a monad.
05:36:58 <luqui> so the way you do MonadState m => m () is precisely that!  you just do it.
05:37:03 <maltem> Peaker: hm, every monad is an applicative functor... what was the relation with arrows again?
05:37:17 <Peaker> ilyak: in a context-free grammar, the extra monad expressiveness means you cannot build an optimized parser from a monadic description of one
05:37:32 <Peaker> maltem: I think its: Functor m => Applicative m => Arrow m => Monad m
05:37:40 <luqui> maltem, there is the "kleisli arrow' K a b = a -> m b  for each monad
05:37:42 <Peaker> maltem: I think there are some more classes in between Arrow and Monad though
05:38:04 <luqui> Peaker, surely infinitely many of them :-)
05:38:13 <zachk> pyNem: I havent aproached major parsing yet, i hear parsec is very good, there is a scheme in 48 hours tutorial for haskell that starts right off with using parsec
05:38:15 <ilyak> Peaker: Well, if an interface gets in your way, you can scrap it I guess
05:38:22 <byorgey> Peaker: Arrow doesn't really quite fit in there
05:38:26 <Peaker> luqui: I don't know if there are infinite levels of expressiveness in between, but I think I am lacking quite a bit of theory here :)
05:38:30 <Peaker> byorgey: why not?
05:38:38 <pyNem> ok .. are monads just an abstraction for wrapping around a basic type?
05:38:40 <maltem> luqui: ah, so you can derive an arrow from any monad?
05:38:42 <luqui> Peaker, well you have to define expressiveness first.
05:38:47 <luqui> maltem, yep
05:38:55 <Peaker> ilyak: what do you mean? If you're an instance of a class, you must support the entirety of that class, and then you lose the ability to do some sorts of analysis
05:39:16 <byorgey> Peaker: the relationship betwen applicative, arrow, and monad is not just a simple generalization relationship like the relationships between functor, applicative, and monad
05:39:26 <luqui> maltem, also, you can derive a monad from any arrow a which supports app :: a (a b c, b) -> a c
05:39:27 <Saizan_> luqui: wadler has done that for us! :)
05:39:33 <byorgey> @google wadler arrow calculus
05:39:36 <lambdabot> http://homepages.inf.ed.ac.uk/wadler/topics/links.html
05:39:36 <lambdabot> Title: Wadler: Links
05:39:41 <Peaker> byorgey: why not?
05:39:44 <ivanm> what's wrong with my code here? http://hpaste.org/11224
05:39:49 <lilac> Peaker: ArrowChoice is between Arrow and ArrowApply (== Monad)
05:39:52 <ilyak> Peaker: Well, yeah, so if implementing that class gets in your way, it might be wise to drop that instance
05:39:57 <pyNem> clearly if i look at the monad laws, and think about what Saizan_ said about allowing a revert to a.. then monads are just a way of composition of wrappings on a data type?
05:39:58 <quicksilver> Peaker: Arrow and Applicative are incomparable.
05:40:06 <quicksilver> all Monads give rise to an Applicative.
05:40:12 <pyNem> so Monads, dont make things impure either?
05:40:12 <quicksilver> all Monads give rise to a particular kind of Arrow.
05:40:18 <quicksilver> not all Arrows come from Monads.
05:40:23 <quicksilver> (not all Applicatives come from Monads)
05:40:24 <Peaker> ilyak: exactly, that's what I said, you don't want a Monad instance for a context-free grammar parser
05:40:29 <luqui> pyNem, monads are a pure concept.
05:40:41 <maltem> pyNem: yeah that's right
05:40:43 <luqui> pyNem, it's just the particular IO monad which makes thing "impure" (adds effects)
05:40:45 <quicksilver> I don't know any useful examples of an Applicative which doesn't come from a Monad.
05:40:51 <Saizan_> pyNem: exactly
05:40:52 <Peaker> quicksilver: What Applicatives do not come from Monads?
05:41:01 * pyNem goes woweee.. First successful monad deduction :)
05:41:02 <quicksilver> And I only one one interesting example of an Arrow which does not come from a monad.
05:41:03 <Peaker> quicksilver: ok, what arrows then?
05:41:10 <quicksilver> the S&D parser arrow.
05:41:10 <pyNem> luqui, so how then is the Real World being passed around _efficiently_ ?
05:41:24 <luqui> pyNem, you mean in implementation land?
05:41:28 <byorgey> Peaker: see http://homepages.inf.ed.ac.uk/wadler/papers/arrows-and-idioms/arrows-and-idioms.pdf
05:41:30 <Peaker> quicksilver: it cannot be expressed as a monad?
05:41:31 <lilac> pyNem: "pure" versus "impure" in haskell basically means, "is (some part of) the return type in the IO monad?"
05:41:32 <lambdabot> Title: Idioms are oblivious, arrows are meticulous, monads are promiscuous, http://tinyurl.com/6evopg
05:41:34 <luqui> pyNem, it's just an empty token that ensures evaluation order.
05:41:36 <quicksilver> Peaker: indeed it cannot.
05:41:40 <Saizan_> pyNem: the execution of IO actions is impure, building them with >>= and return is not
05:41:44 <luqui> pyNem, it doesn't have any data in it at all :-)
05:42:16 <ivanm> nvm, my plotCol function needed a type sig for some reason :s
05:42:18 <maltem> quicksilver: I think I read someone mention applicatives being more suitable for a specific parser than monads. Don't know remember where though... maybe the yi highlighting parser
05:42:23 <Peaker> quicksilver: S&D not found in the arrows and idioms paper. What can I look for (IOW what's  S&D stand for)
05:42:34 <quicksilver> swierstra and duponcheel
05:42:37 <pyNem> luqui,  yes .. partly implementation land.. and partly in Haskell land.. how would an IO String monad be if i could "see" it?
05:42:53 <quicksilver> I"m not entirely sure if I spelt that right :)
05:43:10 <luqui> pyNem, ah, that's a question of semantics.  The canonical one would be IO String = World -> (World, String)
05:43:14 <Peaker> maltem: the extra expressiveness of monads makes the parser not optimzable because you cannot analyze the parser structure (which is based on "runtime" data)
05:43:22 <maltem> pyNem: the GHC implementation explains it with just another abstraction, the state of the world being passed around
05:43:24 <luqui> pyNem, turns out that's not a great semantics, but it does the job for simple caess.
05:43:28 <pyNem> and can I print World?
05:43:43 <luqui> pyNem, you can't even access world, because its hiding in the monad.
05:43:52 <quicksilver> GHC secretly compiles down to an impure language.
05:44:00 <pyNem> luqui, no wait I dont get this
05:44:02 <maltem> Peaker: right, that sounds like what I had in mind
05:44:03 <luqui> pyNem, but if you could, it would print the position and velocity of every particle in the universe :-)
05:44:04 <lilac> pyNem: World has no defined operations other than those provided by the haskell standard library (eg, 'print', etc)
05:44:05 <quicksilver> and that impure language works much like C or ML, in terms of how it executes IO actions.
05:44:19 <quicksilver> but the type system of the pure language keeps the impure one honest.
05:44:27 <pyNem> luqui, sorry to sound very nooby (I must be too), but just because something is hiding in the monad, doesnt mean you cant see it
05:44:37 <pyNem> clearly the >>= for IO will be able to see it
05:45:06 <ilyak> Peaker: now >>= itself is hidden
05:45:09 <luqui> pyNem, and it can, but it is hiding behind a wall of abstraction. you can't see it because the evil implementers of the IO library have not allowed you to see it.
05:45:10 <lilac> pyNem: you are correct, but the definition of IO is not exported, so /you/ can't see it, even though IO >>= can
05:45:10 <ilyak> for IO
05:45:25 <luqui> pyNem, the same way you hide the "list" representation of a Stack and only provide stack operations, for example.
05:45:55 <maltem> I think pyNem's point is that World still must have some representation
05:46:03 <pyNem> ah.. purely for curisoity, suppose I could open the IO.hi (or something similar) file, and add some sort of print ..
05:46:07 <pyNem> maltem, exactly :)
05:46:20 <luqui> pyNem, then RealWorld would probably print as something like ()
05:46:38 <pyNem> luqui, lilac, I get the >>= hiding now .. Thanks .. :) .. I never realised that >>= is also hidden
05:46:38 <luqui> but that's a hack, and is not what RealWorld *represents*
05:46:46 <Axman6> maltem:isn;t Show RealWorld implemented in Control.Eyes?
05:47:08 <quicksilver> Control.Nirvana, I think
05:47:12 <pyNem> luqui, yeah.. obviously .... it suffices to be concerned about your system, which in this case is the input stream, output stream (stream ~ buffer), and the comp state
05:47:13 <pyNem> ?
05:47:13 <Axman6> ah yes
05:47:16 <quicksilver> but you can't import that if your name isn't Simon.
05:48:27 <luqui> pyNem, yeah, but RealWorld doesn't have that in it either.  that stuff is just stored in imperative land on which haskell is implemented.
05:48:40 <pyNem> luqui, oh .. so () is faked
05:48:40 <Saizan_> btw, RealWord# is just an implementation hack GHC uses, there's no need to describe the semantics of the IO monad using State RealWord
05:48:41 <inimino> luqui: it "represents" nothing more than a value that keeps an impure computation sequenced
05:48:56 <pyNem> luqui, brilliant :) .. and C (which ghc tranlsates to) implements it
05:49:19 <luqui> inimino, I disagree.  I think it *represents* the actual real world.  It is *implemented* as a value that keeps an impure computation sequenced.
05:49:19 <Saizan_> we should stop introducing it to newbies :)
05:49:40 <pyNem> Saizan_, :) ... but yeah, it helped to know this :)
05:49:43 <inimino> luqui: well, there are alternative equally valid semantic interpretations ;-)
05:49:52 <Saizan_> pyNem: helped?
05:49:54 <luqui> inimino, hopefully there are more valid ones.
05:50:10 <luqui> inimino, neither of those is particularly meaningful  (the "real world" one is plain wrong)
05:50:43 <luqui> and the "impure computation" one is not meaningful, because we need to say what "impure" means in precise, mathematical language
05:51:21 <rog> BTW, i got the random number generator thingy working ok (at http://hpaste.org/11222#a2). is there a more compact way to write the incrementor so it doesn't run out of memory?
05:51:32 <inimino> luqui: well, that's clear enough with referential transparency, etc
05:51:35 <pyNem> Saizan_, that RealWord is "represented" by a faked () in ghc .. kind of makes you think you understand things.. even though you probably dont :(
05:51:49 <luqui> inimino, I mean you are not given computers.  you are given mathematics.  what is an impure computation?
05:51:56 <luqui> inimino, (not what *isn't* it)
05:52:03 <inimino> luqui: any computation is impure
05:52:04 <ilyak> pyNem: Why faked ()?
05:52:16 <inimino> purity is a convenient fiction
05:52:17 <luqui> inimino, what's a computation?
05:52:30 <quicksilver> rog: there really should be a strict version of modifyIORef
05:52:31 <Saizan_> pyNem: ah, yeah, but if IO wasn't explained using ReadWorld in the first place you wouldn't had this misunderstanding in the first place :)
05:52:33 <quicksilver> rog: (but there isn't)
05:52:36 <inimino> luqui: I mean the event of performing a computation :-)
05:52:42 <ilyak> pyNem: If you've got IO a, this doesn't means that the only data contained in this IO object is a
05:52:43 <Saizan_> s/in the first place//
05:53:14 <luqui> inimino, and what's an event, what does it mean to perform?    (I will stop once you say something that has a known axiomatization, or can obviously be translated to such)
05:53:24 <ilyak> This object can contain a lot of its own internal data, and monad's parameter is type of payload, not type of monad's internal structures
05:53:24 <int-e> rog: writeIORef v $! v' + 1
05:53:50 <rog> :type ($!)
05:53:58 <rog> @type ($!)
05:53:58 <ilyak> Many monads use their parameter type just to carry user's auxilary data around and don't do anything on them
05:53:59 <lambdabot> forall a b. (a -> b) -> a -> b
05:54:05 <ilyak> Like the parser monads
05:54:05 <luqui> inimino, see what I'm getting at?
05:54:10 <inimino> luqui: mathematics is axiomatized, the performance of computations (on real world machines) is obviously not
05:54:17 <lilac> some monads don't carry around an instance of the parameter type at all
05:54:22 <inimino> luqui: I don't ;-)
05:54:34 <ilyak> lilac: I guess they do
05:54:35 <int-e> rog: (writeIORef v $!) . (+1) =<< readIORef v -- if you can read that.
05:54:45 <ilyak> else they wouldn't be monads
05:54:57 <ilyak> They wouldn't obey one of monadic laws
05:54:59 <int-e> @src ($!)
05:55:00 <lambdabot> f $! x = x `seq` f x
05:55:03 <luqui> inimino, basically we want to pretend that haskell is some symbolic rewrite system, upon which we can predict behavior of any program "on paper".
05:55:39 <luqui> inimino, we have that for haskell's pure functions  (modulo performance, as you say, that's missing from our semantics)
05:55:44 <luqui> but we do *not* have that for IO
05:55:56 <luqui> the challenge is to make a semantics for IO, so we can.
05:55:56 <inimino> luqui: sure, that's why I say any actual computation carried out on real hardware is impure
05:55:56 <quicksilver> ilyak: data Zero = Zero; instance Monad Zero where return x = Zero; a >>= f = Zero
05:56:11 <quicksilver> ilyak: not instances of the parameter value there ;)
05:56:12 <inimino> luqui: well, that implies modeling the rest of the world
05:56:19 <inimino> luqui: sounds hard
05:56:20 <quicksilver> I should actually say 'data Zero a = Zero', sorry.
05:56:49 <luqui> inimino, yeah ;-).  but we should be able to model a subset, involving references and concurrency without modeling the world, right?
05:56:52 <ilyak> quicksilver: Well, you can write function that would violate the monadic law
05:56:55 <EmielRegis> is there a way of keeping some variable across different instances of one function (recursive one) ither than passing it as argument?
05:57:02 <int-e> quicksilver: in other words, Monads (as in (forall m . Monad m => m a)) are useless *g*.
05:57:02 <ilyak> quicksilver: But if you don't, yes, it can hold
05:57:16 <inimino> luqui: well, it depends on what you call a model ;-)
05:57:17 <ilyak> int-e: Why useless?
05:57:25 <luqui> inimino, I believe SPJ gave a semantics for a pretty small subset of IO in one of his papers.  An operational semantics, mind, not a denotational one (so we still don't really know what an IO action means :-)
05:57:30 <rog> int-e. i like the first one better. probably better though to define my own modifyIORef' with strict semantics. although that still doesn't get all the way there. i think. i find dealing with memory issues one of the hardest things in haskell.
05:57:41 <quicksilver> ilyak: no, that doesn't violate any of the laws.
05:57:48 <dolio> Asking for a denotational semantics of IO doesn't make much sense.
05:57:48 <ilyak> quicksilver: return a >>= f == f a
05:57:50 <quicksilver> ilyak: and no matter what function you write, it still won't.
05:58:02 <int-e> ilyak: That was tongue in cheek. What I mean is that all usefulness comes from the particular Monad instance that you use, not from the fact that it is a Monad.
05:58:04 <ilyak> quicksilver: It will if I use some unsafe IO
05:58:05 <luqui> inimino, a model is a translation into some mathematical system, such that things that are true about the program are true in its translation to the system.
05:58:11 <ilyak> int-e: Sure
05:58:18 <dolio> You could just give a GADT term algebra like Cale likes.
05:58:20 <quicksilver> Oh.
05:58:35 <quicksilver> ilyak: yes, I'm wrong.
05:58:41 <quicksilver> ilyak: that's not a monad ;)
05:58:44 <quicksilver> *sigh*
05:58:45 <dolio> And then you'd need to talk about the operational semantics of "executing" such terms to talk about what actually happens on a machine.
05:58:48 <quicksilver> I reduced to dar.
05:58:55 <lilac> quicksilver: yes it is. f a == Zero.
05:58:56 <quicksilver> ilyak: for a better example, consider Maybe.
05:59:09 <quicksilver> lilac: no, because the type of f a is not zero.
05:59:12 <ilyak> quicksilver: Well, Maybe does carry user's data around
05:59:17 <inimino> luqui: well, I mean it really depends on how much of the impure world you want to include in the model
05:59:18 <quicksilver> lilac: f is a pure funciton, a is a pure value
05:59:22 <luqui> dolio, yeah, that would be somewhere inbetween denotational and operational...
05:59:24 <quicksilver> ilyak: sometimes it does, and sometimes it doesn't.
05:59:32 <ilyak> quicksilver: Or fails
05:59:32 <quicksilver> ilyak: if it happens to be 'Nothing' it doesn't.
05:59:33 <luqui> inimino, none of it.  just concurrency and variables.
05:59:42 <ilyak> quicksilver: Monad can either carry user's data or fail
05:59:43 <quicksilver> ilyak: yes, but that's an example of it not necessarily carrying it around.
05:59:53 <ilyak> quicksilver: Okay, sorry, I correct myself
05:59:54 <quicksilver> ilyak: that's a bit closer to the truth, yes.
06:00:01 <inimino> luqui: OK, I can see where that would have some value
06:00:01 <dolio> luqui: Well, you could give a denotational semantics, it'd just be useless. :)
06:00:03 <quicksilver> but what does 'fail' mean
06:00:03 <ilyak> Monads have to either carry data around or fail if they can't
06:00:08 <quicksilver> I argue 'fail' means "not carry around user's data"
06:00:09 <luqui> dolio, why?
06:00:22 <ilyak> quicksilver: yeah, I was not entirely right
06:00:23 <quicksilver> so we have "monad's either carry around the user's data, or they don't"
06:00:34 <quicksilver> which is pretty vacuous :)
06:00:54 <ilyak> quicksilver: Well, fail is much narrower than 'or they don't and so whatever they want'
06:00:59 <luqui> hm, so it's isomorphic to maybe, quicksilver?
06:01:04 <inimino> quicksilver: but they try really hard ;-)
06:01:23 <dolio> luqui: Because defining IO like 'data IO a where GetChar :: IO Char ; PutChar :: Char -> IO () ; ...' doesn't tell you any of the stuff you actually want to know about IO.
06:01:24 <lilac> quicksilver: so it's not a monad because "return a >>= (\x -> undefined `seq` Zero)" is not _|_ ?
06:01:36 <luqui> dolio, that's not a good denotational semantics.
06:01:41 <luqui> dolio, because it has no laws.
06:01:51 <Cale> ahaha, I'm installing intrepid, and I get a message "ion3: [checkbox] Do you understand that this package is not supported by the author?"
06:02:03 <lilac> if so... data BottomMonad a; instance Monad BottomMonad where return = undefined; (>>=) = undefined
06:02:08 <quicksilver> lilac: hrm.
06:02:10 <Cale> (I must have installed ion3 at some point, not too sure why :)
06:02:15 <quicksilver> lilac: I'm having a really bad 20 minutes, aren't I?
06:02:19 <quicksilver> lilac: you were right all along.
06:02:21 <luqui> dolio, that's like the denotational semantics for numbers being "a number is a numeral, or a number + a number, or a number * a number"
06:02:22 <quicksilver> and I was right the first time.
06:02:23 <inimino> luqui: I think what you're trying to say is that a lot of stuff is in IO that shouldn't be
06:02:28 <pyNem> ilyak, then what else can be contained in IO a?
06:02:28 <quicksilver> and ilyak was wrong after all ;)
06:02:33 <quicksilver> Zero a is a monad.
06:02:34 <luqui> dolio, we have no idea what those operations mean, they'rre just symbols
06:02:40 <ilyak> pyNem: Everything
06:02:58 <ilyak> for example, you can say data MyMonad a = MyMonad a [String]
06:03:11 <Cale> The only minor trouble with term algebras for things like IO is that you have to be careful about where you interpret the monad laws.
06:03:12 <ilyak> And now it drags around your data and also some strings attached
06:03:24 <luqui> dolio, as opposed to the much better semantics for numbers "a number is 0 or S (a number)", and then + and * are definitions that translate back into that one.
06:03:32 <Cale> (or how you define bind/return)
06:03:53 <Cale> But there's nothing so morally wrong with doing things that way, anyway. :)
06:04:02 <luqui> dolio, in particular we have "2+2 = 4" in the latter but not the former.  that's what the term algebra is missing.
06:04:29 <quicksilver> Cale: I think you have to be careful wiht where you apply monad laws for any kind of abstract monad
06:04:33 <quicksilver> Cale: (like IO)
06:04:41 <Cale> yeah
06:04:44 <quicksilver> Cale: I don't think the term algebra monad makes it any worse than it was before.
06:04:54 <dolio> luqui: It's as good as you'll get for IO, because all the interesting stuff is in the execution of the term algebra, which isn't done in the language (except for unsafePerformIO, which I doubt you'll be doing nicely).
06:04:57 <ahunter> @pl f x = map (\(a,b) -> (b,a)) x
06:04:57 <lambdabot> f = map (uncurry (flip (,)))
06:05:01 <quicksilver> Laws still apply even on types which don't implement Eq
06:05:07 <quicksilver> but what they mean, requires thought.
06:05:32 <luqui> dolio, Okay, sure, all of IO, because it has FFI and all that crap.  I still challenge one to make a denotational semantics for Variables and concurrency.
06:05:35 <inimino> luqui: if you just want a denotational semantics for concurrency and variables, there's no need to drag IO into it
06:05:37 <quicksilver> I think it's safe to say that if they *do* implement Eq, then the laws should respect that instance at least.
06:05:43 <Cale> quicksilver: Well, the fact that values can actually be inspected in another way is slightly problematic.
06:05:58 <Cale> (with regard to interpreting the laws)
06:06:05 <luqui> inimino, dolio, I'm trying to argue that a term algebra is not a good denotational semantics for that subset of IO
06:06:11 <quicksilver> Cale: you can't inspect the value of 'Bind' in a very useful way
06:06:16 <quicksilver> Cale: since you can't inspect functions.
06:06:24 <ddarius> You check them with respect to an "observation" function
06:06:25 <quicksilver> Cale: so, you might as well just throw your hands in the air
06:06:32 <quicksilver> and say "I will define observation like this"
06:06:34 <Cale> It's not so much that there's an Eq instance, but you can have IO terms which are IO-equivalent, but which case can tell apart.
06:07:04 <quicksilver> Cale: there are plenty of terms in types which have a sane Eq instance, where case can tell apart Eq-equivalent terms.
06:07:10 <dolio> luqui: Well, variables is just ST, which excepting performance, has semantics similar to State.
06:07:14 <quicksilver> I think this is an understood concession of abstraction.
06:07:19 <quicksilver> not (particularly) unique to this case
06:07:23 <quicksilver> although definitely to bear in mind.
06:07:31 <dolio> luqui: With a somewhat magic state variable type.
06:07:50 <luqui> quicksilver, really?  I have gradually shifted to the perspective that Eq should really be about decidable leibniz equality.  I didn't used to think this.
06:08:15 <quicksilver> I think an Eq instance of Set which ignores the particular way the tree is built up is the correct one.
06:08:16 <luqui> dolio, yeah.  ST has a nice pretty semantics. :-)
06:08:19 <quicksilver> don't you?
06:08:24 <luqui> dolio, concurrency is where we get bitten :-)
06:08:47 <quicksilver> I also think a nice semantices for (say) MVars would be nice. And it wouldn't be the term algebra.
06:08:56 <dolio> luqui: Cooperative concurrency is pretty easy. :)
06:09:11 <luqui> dolio, that is one of the reasons I'm such a fan of FRP; is its a way to substantially grow our expressivity and maintain a simple, well-defined semantics.
06:09:20 <ddarius> luqui: Many Haskell data types don't have decidable equality.
06:09:34 <luqui> ddarius, nor do they have Eq instances.  :-)
06:09:43 <ddarius> luqui: [] has an Eq instance
06:09:50 <Cale> quicksilver: Well... as usual it becomes a question of whether you want to hide the representation of IO values (making them somewhat like what we have now), or export the constructors and allow them to be inspected with case (which would be really useful, but makes the monad laws slightly less convincing ;)
06:09:54 <zachk> is FRP hard to learn?
06:10:05 <luqui> ddarius, ah, touche!
06:10:15 <luqui> ddarius, semidecidable liebniz equality?
06:10:50 <luqui> ddarius, I guess what I'm trying to say is that the law, (a == b) = True -> a = b, is one that I (now) consider reasonable.
06:10:50 <quicksilver> luqui: but you would seem to be arguing against abstract data types?
06:11:16 <quicksilver> that doesn't mean much unless you tell us what the "=" sign was supposed to denot.
06:11:22 <Cale> "Equivalent but not equal" is the most annoying problem throughout mathematics, I think :)  Certainly with regard to questions about how to formalise things.
06:11:31 <luqui> quicksilver, that is another issue.  to what extent is the equality liebniz?  outside a barrier of abstraction perhaps :-)
06:11:49 <quicksilver> it might be another issue to you.
06:11:53 <quicksilver> to me that is *this* issue :)
06:12:00 <quicksilver> I thought it was what we were talking about.
06:12:17 <quicksilver> The Eq instance for Set is, to me, analagous to the monad laws for a term-algebra for IO.
06:12:28 <ddarius> Abstraction is quotienting
06:12:34 <quicksilver> both of them are capable of being proved "wrong" by case
06:12:37 <quicksilver> ddarius: exactly.
06:12:40 <zachk> eq on sets to mean sort both lists, then do a list compare
06:12:57 <zachk> to me means
06:12:59 <Cale> quicksilver: But having access to those constructors could be useful in either case...
06:13:02 <quicksilver> zachk: Set is not implemented as lists, but as tree.
06:13:06 <EmielRegis> seriously, functional programming sux
06:13:09 <dolio> luqui: Preepmtive concurrency where like GHC does does strike me as a problem, since the best you can do as a run function is not Conc a -> a, but Conc a -> IO a, since the results are genuinely nondeterministic. So it gets thrown back into the IO that you can't give a useful denotational semantics for.
06:13:16 <rog> quicksilver: if you couldn't see the tree, would it still be wrong?
06:13:21 <quicksilver> Cale: I think a type can be morally abstract, and permit access to the constructors for fun and possibly profit ;)
06:13:22 <luqui> quicksilver, let's take the reasonable approach that equality should be liebniz outside a barrier of abstraction.  is a term algebra a good semantics for IO?
06:13:41 <luqui> quicksilver, I will ask a related question: is a balanced tree a good semantics for Set?
06:13:42 <quicksilver> luqui: the term algebra is a thought experiment.
06:13:43 <Cale> quicksilver: Wouldn't it be nice to have a system which could do both?
06:14:07 <quicksilver> luqui: its goal (to me) is to demonstrate that IO need not be implemented by some sick hack like State#
06:14:15 <Cale> I'd really like to have proper quotient types.
06:14:30 <Cale> (with pattern matching!)
06:14:57 <luqui> quicksilver, ah, and instead implement it as the very same sick hack in InterpIO :: IOTermAlg -> IO () ?
06:15:09 <Cale> Of course, then the problem becomes how to ensure that function definitions are well-defined.
06:15:11 <luqui> (should be a lowercase i there)
06:15:44 <luqui> Cale, quotient type?   equivalence classes?
06:16:01 <ddarius> @google Altenkirch quotient types containers
06:16:05 <lambdabot> http://portal.acm.org/citation.cfm?id=1195941
06:16:05 <lambdabot> Title: Containers
06:16:10 <Cale> luqui: yeah -- like you could define a proper set type.
06:16:16 <luqui> hmm
06:16:18 <ddarius> @google "Thorsten Altenkirch"
06:16:20 <Cale> luqui: without having to hide its constructors.
06:16:20 <lambdabot> http://www.cs.nott.ac.uk/~txa/
06:16:20 <lambdabot> Title: Thorsten Altenkirch
06:16:32 <luqui> Cale, could you elaborate a bit more?  or will the paper tell me?
06:16:47 <Cale> luqui: and it would somehow make it impossible to tell equivalent sets apart using case.
06:16:50 <ddarius> http://www.cs.nott.ac.uk/~txa/publ/mpc04.pdf
06:16:52 <lambdabot> Title: Constructing Polymorphic Programs with Quotient Types
06:17:10 <Cale> (possibly by applying a normalisation to terms before pattern matching)
06:17:29 <ddarius> The species paper also has some quotient type stuff.
06:17:53 <Cale> Miranda (and pre-standardisation versions of Haskell?) had a feature called "laws" which basically did something like what I'm thinking of.
06:18:32 <ddarius> There's the OBJ family which uses term rewriting as opposed to pattern matching.
06:18:37 <quicksilver> Cale: doing it is one thing. Doing it without crippling inefficientcy is something else.
06:18:54 * ddarius tries to cripple inefficiency all the time.
06:19:08 <quicksilver> ;)
06:19:36 <quicksilver> Cale: normalising terms all over the place could work to destroy the reason we're using clever structures in the first place.
06:19:47 * rog isn't finding that paper very easy to skim!
06:20:17 <Cale> quicksilver: right...
06:20:57 <Cale> quicksilver: clearly the best solution is the homotopy lambda calculus ;)
06:21:18 <luqui> rog, I'm with you :-)
06:21:53 <Cale> (honestly I have hardly any idea what that is, only that Voevodsky is talking about it as a way to solve these problems with regard to formalising mathematics in a way which is actually useful to mathematicians.
06:22:04 <quicksilver> Cale: if you need a sympathetic referee for a research grant on a homotopy based programming language, I'll do my best ;)
06:28:38 <pastorn> anyone tried vty?
06:28:51 <pastorn> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vty
06:28:52 <lambdabot> Title: HackageDB: vty-3.1.2
06:29:02 <pastorn> it just segfaults for me...
06:36:01 <romildo> Hi.
06:36:39 <Cale> hello
06:37:32 <inimino> that paper was pretty dense
06:38:01 <romildo> Is it possible to collect many gtk2hs widgets of possibly different types in a list, maybe converting them to a more general type, and later on access them from the list and recover its original type?
06:38:54 <Cale> romildo: well, gtk2hs provides casting operators (which it inherits from gtk2)
06:39:00 <lilac> @hoogle Data.Dynamic
06:39:00 <lambdabot> module Data.Dynamic
06:39:00 <lambdabot> Data.Dynamic data Dynamic
06:39:00 <lambdabot> Data.Dynamic fromDynamic :: Typeable a => Dynamic -> Maybe a
06:39:09 <Cale> There's no need for Dynamic here.
06:39:27 <lilac> no, but sometimes it's useful to know a solution to a more general problem
06:39:27 <Cale> You can cast them all to Widget.
06:39:34 <Cale> castToWidget :: GObjectClass obj => obj -> Widget
06:39:40 <Cale> that's true :)
06:39:54 <ddarius> What happens if obj isn't of type Widget?
06:40:01 <quicksilver> fromDynamic is something of a last resort, though
06:40:10 <romildo> and how would one retrieve its original type?
06:40:19 <quicksilver> fromDynamic means "Bugger, I can't be bothered to encode this in the type system, I'll just punt it"
06:40:22 <romildo> I mean, how to convert back?
06:40:36 <quicksilver> Cale: have you see the way wxWidgets encodes subclasses?
06:40:39 <Cale> romildo: I'm uncertain about that part. It's probably best to remember that information in the first place ;)
06:42:27 <rog> a question about re-use of existing data structures. given the code in http://hpaste.org/11225#a0, is element of the list produced by slowToCalculate only calculated once, or many times?
06:42:49 <Cale> romildo: What exactly are you doing by the way?
06:43:43 <Cale> romildo: If you have a static collection of widgets from your user interface, collecting them all into a record datastructure where the fields have meaning might be better. I never personally ran into a need when using gtk2hs to collect a bunch of different widgets into a list...
06:43:52 <Cale> (or even a record for that matter)
06:44:24 <Cale> The usual approach is to set all your event handlers from main, where you have access to everything, and pass things down as necessary.
06:44:26 <romildo> I am writing an application in a somewhat abstract way, in that the I want to describe in a data structure a data model and the components used to present them to the user.
06:44:32 <Cale> mmm.. okay
06:44:42 <quicksilver> rog: once.
06:44:59 <Cale> and you want to be able to have arbitrary Gtk2 widgets, or is there a specific subset?
06:45:06 <rog> quicksilver: good, that's what i though. thanks.
06:45:22 <Cale> A tagged union type might be a good approach for some things.
06:45:28 <romildo> So I will need a list of  widgets of possibly different types.
06:45:29 <quicksilver> rog: this idiom "f x = let something = something in \y -> ...."
06:45:45 <quicksilver> rog: is a standard idiom for memoizing a partial computation.
06:45:47 <rog> quicksilver: is that a usual convention?
06:45:49 <quicksilver> yes.
06:46:09 <romildo> Cale: yes, an union type is a choice.
06:46:33 <rog> quicksilver: good. it's always nice to hit upon a common idiom by oneself...
06:47:17 <romildo> But as Gtk+ is desingned in an object oriented way, I thought that there would already be mechanisms for that in gtk2hs.
06:47:21 <Cale> Probably dcoutts_ knows of some Gtk2-specific approaches to this problem. I'm not sure if there's a way to get hold of the widget type after an upcast in order to safely downcast again.
06:48:28 <romildo> I first wrote the application in Java and now I am porting it to Haskel. In Java we have the instaceof operator that makes it easy.
06:49:20 <romildo> (I am getting tired of the verbosity of Java programs, and the lack of supporting for functional programming in it.)
06:49:29 <Cale> romildo: I suppose you actually *could* go with Data.Dynamic.
06:49:39 <Cale> :t fromDynamic
06:49:40 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
06:50:03 <Peaker> I don't know category theory, reading the arrows and idioms paper is quite hard :(
06:50:18 <Cale> oh, I'm not sure if all the Widget types are Typeable.
06:50:24 <Cale> Peaker: which paper?
06:50:41 <Peaker> Cale: "Idioms are oblivious, arrows are meticulous, monads are promiscuous"
06:50:45 <romildo> If there is no way to get the original type back, then castToWidget seems pointless, don't you think?
06:50:52 <Peaker> from MSFP2008
06:51:04 <Cale> romildo: well, there's a set of functionality available for all widgets
06:51:22 <Cale> romildo: I suppose you could take doing an upcast to mean that you no longer care about the specific widget type
06:51:26 <romildo> cads: sure, you are right.
06:51:43 <romildo> Cale: sure.
06:53:08 <Cale> Peaker: it looks like there's a lot more type theory notation in that than category theory
06:53:19 <plutonas> i have the following problem. I have a function f1 that returns Maybe ([Something], String), I want to have a function f2 of some instance to use this and have the type Maybe(T,String), my problem is when i define newtype T = Constructor [Something] and f2 = Constructor f1 then it complains that Constructor is expecting type T and not Maybe([a], String) which i also agree upon, but i don't know how i can do it the ri
06:53:19 <plutonas> ght way arround
06:53:31 <Peaker> Cale: I don't see why they can't just all use Haskell syntax :)
06:53:58 <plutonas> i hope it's clear enough
06:54:22 <Cale> Peaker: but if you want a nice intro to category theory, try this book http://cale.yi.org/share/Category%20Theory%20-%20S.%20Awodey%20(Clarendon,%202006)%20WW.pdf
06:54:30 <lambdabot> Title: cache:http://cale.yi.org/share/Category%20Theory%20-%20S.%20Awodey%20(Clarendon, ..., http://tinyurl.com/4jav6v
06:55:21 <Cale> I'm not 100% certain of its comprehensibility to nonmathematicians, but it at least seems not to have so many prerequisites :)
06:55:49 <Peaker> Cale: thanks
06:55:57 <Cale> plutonas: It sounds like maybe you need a map (\(x,y) -> (T x, y)) somewhere?
06:56:20 <Peaker> Cale: I think the URL is not working
06:56:21 <plutonas> Cale: hm, how do you mean?
06:56:30 <tromp_> http://hpaste.org/11226
06:56:36 <Cale> plutonas: oh, wait, I see
06:56:37 <Peaker> oh wait it is
06:56:53 <tromp_> my first attempt at defining Go in haskell
06:57:31 <Cale> plutonas: sorry, s/map/fmap/
06:58:01 <plutonas> Cale: f2 should return Maybe(T,String), and i have f1 that returns Maybe([Something], String) which is more or less what i want f2 to return also, the problem is to define T
06:58:17 <plutonas> (to my point of view at least) How do you mean i should use fmap?
06:58:49 <Cale> f2 = fmap (\(x,y) -> (T x,y)) . f1
06:58:58 <Cale> (supposing that they have one parameter)
06:59:03 <inimino> :t fmap
06:59:04 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:59:17 <Cale> In this case,  fmap :: (a -> b) -> Maybe a -> Maybe b
06:59:32 <plutonas> where T is the Constructor for T?
06:59:37 <Cale> yeah
06:59:42 <plutonas> hm, i see
06:59:54 <Cale> oh, you called it Constructor, sorry
07:00:26 <Cale> If you import Control.Arrow, you can write  fmap (first T)
07:00:53 <plutonas> hm, am not sure it works just a sec
07:02:21 <Peaker> In a PDF, I see a type signature: app : ((A ~> B) Ã— A) ~> B   -- what does the x mean?
07:02:35 <Cale> Peaker: Cartesian product, that is, the type of pairs
07:02:36 <quicksilver> (,)
07:02:36 <dolio> Product.
07:02:45 <quicksilver> @quote triphonic
07:02:45 <lambdabot> No quotes match. My brain just exploded
07:02:46 <Cale> We would write (A ~> B, A) ~> B
07:03:07 <Peaker> ah, thanks.
07:03:21 <Cale> Haskell notation kind of confuses the distinction between a pair of types and a type of pairs.
07:03:52 <Peaker> what's the distinction?
07:03:54 <plutonas> Cale: i get  Couldn't match expected type `a -> f ([Something], t)'
07:03:54 <plutonas>            against inferred type `Maybe ([a1], String)'
07:03:58 <plutonas> and i'm not sure why i get this
07:05:09 <Cale> Peaker: well, a pair of types is just two separate types. The Cartesian product A x B of a pair (A,B) of types is the type consisting of all possible pairs (a,b) with a :: A and b :: B
07:05:31 <Cale> plutonas: perhaps there's another parameter?
07:05:51 <plutonas> Cale: where?
07:06:00 <Cale> plutonas: maybe it should look more like  f2 x y = fmap (first T) (f1 x y) ?
07:06:34 <plutonas> ough, don't think so, let me think about it a bit longer, and if i have trouble i'll come back
07:07:00 <Cale> plutonas: well, it's saying that a function is being confused with a (non function) value
07:07:36 <Cale> Peaker: It's similar to the distinction between ([1,2,3],[4,5]) and [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
07:07:48 <plutonas> Cale: oh i think i see
07:07:53 <Cale> Peaker: the first is a pair of lists, the second is a list of pairs.
07:08:20 <Peaker> Cale: I see. But (,) the value operator and (,) the type constructor are different, the first is just pairing, the latter is doing the cartesian product, no?
07:08:27 <Cale> Peaker: yes
07:08:45 <quicksilver> Peaker: yes, and other languages use a totally different notation
07:08:50 <quicksilver> Peaker: to emphasis the difference.
07:08:56 <rog> is it guaranteed that: (read . show) (a :: Double) == a ?
07:09:05 <quicksilver> like in an ML like language (1,2) has the type "Int * Int"
07:09:10 <rog> (excepting NaN, i guess)
07:09:24 <quicksilver> Peaker: devotees of such languages claim that haskell's punning is harmful and confusing.
07:09:32 <quicksilver> I have some sympathy. We are a bit keen on punning in haskell.
07:09:40 <Cale> rog: and +-infinity...
07:09:48 <Cale> rog: That's a good question.
07:09:56 <quicksilver> I think SPJ is starting to regret it w.r.t. datakinds, too.
07:09:57 <Peaker> quicksilver: Haskell's use of (,) for types doesn't confuse me at all.. As the "type of all possible (,) combinations"
07:10:06 <Cale> @check \a -> (read . show) (a :: Double) == a
07:10:09 <lambdabot>   "OK, passed 500 tests."
07:10:10 <rog> Cale: why would you exclude +/- infinity?
07:10:19 <Peaker> quicksilver: I think if it used a different symbol for the type of tuples it would be more confusing
07:10:19 <Cale> rog: because they don't read either.
07:10:25 <dolio> > read "Infinity" :: Double
07:10:27 <lambdabot>   Infinity
07:10:32 <Cale> oh, perhaps they do
07:10:38 <rog> Cale: they should do, surely?
07:10:40 <dolio> > read "NaN" :: Double
07:10:40 <Cale> > read "NaN" :: Double
07:10:41 <lambdabot>   NaN
07:10:42 <lambdabot>   NaN
07:10:45 <quicksilver> rog: I would guess that is guaranteed.
07:10:47 <plutonas> Cale: fixed it
07:10:54 <BeelsebobWork> > read "-NaN" :: Double
07:10:55 <lambdabot>   NaN
07:10:57 <Cale> okay, that's new to me, perhaps I'm just confused ;)
07:11:00 <quicksilver> rog: it would require some trouble to be sure.
07:11:08 <quicksilver> rog: btu I think the haskell implementors probably took the trouble.
07:11:09 <dolio> NaN still fails because (NaN == NaN) is False.
07:11:15 <Cale> @scheck \a -> (read . show) (a :: Double) == a
07:11:16 <lambdabot>   "OK, passed 500 tests."
07:11:19 <plutonas> once you said it takes a value where it expects a function it was clear. Thanks a lot, i had trouble with this bit for 1.5 days
07:11:25 <Peaker> quicksilver: what about datakinds makes the (,) distinction desirable?
07:11:42 <rog> quicksilver: that would be good...
07:12:03 <rog> dolio: that was the reason for my original caveat
07:12:11 <Cale> I wonder if there's actually a fundamental problem with using the Cartesian product as the type level pairing.
07:12:58 <rog> @scheck \a -> (read . show) (a :: Double) == a
07:12:59 <lambdabot>   "OK, passed 500 tests."
07:13:21 <Cale> .oO(is that really smallcheck output?)
07:13:41 <Cale> @scheck \a b -> (a :: Int) + b == b + a
07:13:42 <lambdabot>   "OK, passed 500 tests."
07:13:46 <Peaker> Can anyone explain what kind of arrow cannot be expressed as a monad?
07:13:49 <Cale> That looks like quickcheck to me...
07:13:55 <dolio> @scheck \a b -> (a :: Bool) == b
07:13:56 <lambdabot>   "Falsifiable, after 2 tests:\nFalse\nTrue\n"
07:14:03 <dolio> @scheck \a b -> (a :: ()) == b
07:14:05 <lambdabot>   "OK, passed 500 tests."
07:14:05 <nominolo`> ?scheck \a b -> (a :: Int) + b == b + a
07:14:06 <lambdabot>   "OK, passed 500 tests."
07:14:06 <quicksilver> Peaker: wanting to distinguish between [a] meaning the type of lists
07:14:11 <quicksilver> Peaker: and [a] being a list of types
07:14:14 <dolio> Yeah, scheck is gone.
07:14:19 <quicksilver> (assumign we allow lists of types at  the kind level)
07:14:24 <Cale> odd...
07:14:32 <dolio> @list scheck
07:14:32 <lambdabot> No module "scheck" loaded
07:14:36 <nominolo`> does anyone know the status on ghc's support for indexed monads with do-notation?
07:14:37 <dolio> @list check
07:14:38 <lambdabot> check provides: check
07:14:44 <quicksilver> Cale: I don't think type-level pairing punning matters, but type-level list punning does.
07:14:46 <Cale> Peaker: Well, know any comonads?
07:15:03 <Peaker> Cale: Vaguely remember comonads are in use for infinite streams
07:15:08 <Peaker> (but otherwise no)
07:15:33 <Cale> Peaker: well, for any comonad w, the functions  a -> w b  form a Hughes Arrow.
07:15:38 <Cale> er
07:15:41 <Cale> w a -> b, rather
07:16:17 <Cale> But that's not so intuitive if you're not familiar with comonads.
07:17:04 <Cale> Another example would be provided by many stream transformer libraries which provide operations like  integrate :: StreamA Double Double
07:17:17 <Cale> for integrating an input signal to produce an output signal
07:17:18 <Peaker> What's a "Hughes Arrow"?
07:17:29 <Cale> Arrow in the non-category-theoretic sense
07:17:36 <Cale> That is, like Control.Arrow
07:17:44 <Peaker> ah
07:18:36 <Peaker> but why is that arrow not expressable as a monad?  If the arrow can be built by pure, >>>, &&&, and first, then I can build it with a Kleisly arrow?
07:18:53 <Cale> There's no monad M for which you can write a function  Double -> M Double  which magically knows where the Doubles it is getting are coming from and manages to integrate them.
07:19:38 <Cale> See, given a *single* Double, you can't possibly know which function you're integrating, and so you can't know which M Double to give.
07:19:57 <Peaker> Yeah, but how can this be expressed with an arrow?
07:20:01 <quicksilver> Peaker: in fact, we know *exactly* when an Arrow can be re-expressed as the kleisli arrow of a monad.
07:20:10 <quicksilver> it can, iff it implements ArrowApply
07:20:16 <quicksilver> (in a way consistent with all the laws)
07:21:05 <Peaker> quicksilver: I think I would understand if I saw code that defined an arrow that could not have ArrowApply implemented for it...
07:21:17 <Cale> Peaker: Well, there's nothing to prevent an A Double Double from having more structure -- perhaps A X Y represents functions (Double -> X) -> (Double -> Y)
07:22:09 <Cale> in which case, integrate :: A Double Double would be the same under the covers as  integrate' :: (Double -> Double) -> (Double -> Double)
07:22:31 <Cale> (which is much more doable, since it gets a whole function at once and can sample it as much as needed)
07:23:23 <Peaker> but can't a "Monad m => m Double" also represent a (Double -> Double) -> (Double -> Double)?
07:25:01 <Peaker> Or is: data Blah a = (a->a)->(a->a)   necessarily not an instance of Monad?
07:25:30 <Cale> It's almost certainly not.
07:25:56 <quicksilver> Peaker: what would 'return' be?
07:26:30 <quicksilver> I think it could only be vacuous
07:26:32 <Peaker> id?
07:26:34 <Cale> hehe,  return x = const (const x)
07:26:39 <quicksilver> like "return x = id"
07:26:51 <quicksilver> or "return x = iterate 5"
07:27:07 <quicksilver> hmm. const.const works.
07:27:14 <Cale> The bigger problem is coming up with a meaningful bind which satisfies the laws...
07:27:14 <quicksilver> @djinn x -> (x -> x) -> (x -> x)
07:27:15 <lambdabot> f a b _ = b a
07:27:26 <Cale> I would be somewhat surprised at it.
07:27:44 <Cale> oh, there's another option :)
07:28:04 <quicksilver> @djiin (a -> a) -> (a -> a) -> (a -> (b -> b) -> (b -> b)) -> (b -> b) -> (b -> b)
07:28:05 <lambdabot> f _ _ _ a b = a b
07:28:26 <quicksilver> that's not a very interesting answer, djinn ;)
07:28:38 <Cale> bbiab, restarting after system upgrade :)
07:28:57 <Peaker> Arrows which are not monads are also necessarily not Applicatives either, no?
07:30:18 <chr1s> Peaker: if you really want to know about the differences you should try to read http://homepages.inf.ed.ac.uk/wadler/topics/links.html#arrows-and-idioms
07:30:20 <lambdabot> Title: Wadler: Links, http://tinyurl.com/5j58vk
07:30:49 <quicksilver> Peaker: "Arrows which do not arise as the kleisli arrow of a monad"
07:31:02 <quicksilver> not quite the same thing "arrows which are not monads"
07:31:14 <chr1s> Peaker: http://ezrakilty.net/research/2008/09/formlets_idioms_arrows_and_mon.html also helped me understand the differences
07:31:16 <lambdabot> Title: Ezra's Research: Formlets; Idioms, arrows and monads, http://tinyurl.com/6hsaz6
07:31:25 <Peaker> chr1s: I tried. Its full of notations I do not know
07:31:38 <quicksilver> applicatives don't even have kleisli composition, so kleisli arrows probably aren't relevant to applicatives.
07:31:47 <chr1s> Applicative Functors is a different name for Idioms
07:31:51 <quicksilver> an applicative which had kleisli composition would be a monad.
07:32:00 <cads> amazing! apparently there's been a 99 bottles of beer program written in malbolge! http://tinyurl.com/msyz8
07:32:08 <lambdabot> Title: 99 Bottles of Beer | Language Malbolge
07:32:25 <cads> lambdabot I love your style
07:32:35 <Peaker> quicksilver: Arrows which cannot be formulated as Kleisly, cannot also be Idioms, though, right?
07:32:38 <cads> but holy cripes
07:32:42 <mightybyte> @seen dons
07:32:43 <lambdabot> dons is in #xmonad, #haskell, #ghc, #darcs and #arch-haskell. I last heard dons speak 6h 27m 5s ago.
07:33:34 <cads> holy mother of god, the program works
07:33:58 <Peaker> Would this be right: http://nextflow.dyndns.org/test.jpg ?
07:35:15 <quicksilver> cads: the malbolge one is more impressive but I have some affection for the piet one.
07:35:23 <Baughn> cads: Malbolge was broken quite a while ago
07:35:27 <Baughn> In the cryptanalytic sense
07:35:46 <Peaker> quicksilver: can you take a look at my piece of art, and say if it makes sense? :)
07:36:08 <cads> test.jpg is not loading here
07:36:09 <Baughn> cads: And if the ancient thinkers saw the sort of heroic acts of math we now do almost routinely, for fun, their heads would explode. ;)
07:36:21 <Baughn> Peaker: Aye, no response from your site
07:36:21 <Saizan_> Peaker: afaiu, that wadler paper says that if F is an applicative, then you can have and arrow A s.t. F a is isomorphic to A () a,
07:36:29 <cads> well, more like our computers do the heroics
07:36:41 <Baughn> Peaker: ..wait, there is a response. It's just horribly, horribly slow.
07:36:48 <Peaker> Baughn: its my machine, I have narrow upload
07:37:06 <Peaker> and a bunch of people all clicked the link, apparently
07:37:24 <Baughn> cads: That too, but that's not always the case. Differential cryptanalysis, for example.. those frameworks would have been perfectly usable before computers
07:37:42 <Baughn> Peaker: Next time try imageshack or something. :P
07:38:05 <cads> indeed, our abstractions and tools are unbelievably more powerful
07:38:28 <cads> it's rather hard to wrap one's mind around it
07:38:37 <cads> we've come so far
07:39:08 <Baughn> Even high-school math goes farther than Newton ever managed. 6_^
07:39:57 <Peaker> Baughn: not our High schools. We barely cover differentiation as much as Newton has
07:40:00 <cads> I think those mathematicians were severely boxed in, so that modern mathematicians are much more novel
07:40:19 <Baughn> They did have some severe misconceptions about the nature of axioms. I suppose you're right
07:40:27 <Peaker> http://img61.imageshack.us/my.php?image=testca6.jpg
07:40:39 <cads> but they tried by damn
07:40:56 <cads> I wonder what the great minds of those days could achieve in this age
07:40:58 <Baughn> Peaker: Yep, looks right
07:41:29 <Peaker> Saizan_: yeah, so every Applicative is an arrow
07:41:30 <Baughn> Wait a minute..
07:41:42 <Baughn> Every functor is not a monad. Map, say
07:41:46 <quicksilver> no it's not right.
07:41:51 <quicksilver> it's inside out ;)
07:41:53 <cads> I don't think newton discoverd all he did just because an apple fell on his head, he was either a genius or good at stealing work
07:42:00 <Baughn> Every monad is a functor, yes. :)
07:42:04 <quicksilver> functor and applicative are larger classe than monad.
07:42:22 <Saizan_> chr1s: btw of formlets, have you thought about adding syntactic sugar via QuasiQuoting?
07:42:42 <Dianora> What Newton did was apply the theory to the movement of the planets. That was major at that time.
07:42:52 <Baughn> cads: The apple story is an urban tale. When it comes to newton.. you should see his heroic efforts to invent calculus, without allowing himself to take shortcuts via limits
07:42:55 <Dianora> Thank religion for holding us back several hundred years.
07:42:58 <Peaker> quicksilver: oops :)
07:42:59 <Baughn> cads: He even *succeeded*
07:43:18 <EmielRegis>  What Newton did was use mathematics as language of science. That was his major win.
07:43:19 <Baughn> Our methods are easier, more than anything else. Of course, we still get the right answers, so..
07:43:26 <cads> quicksilver, piet is breathtaking
07:43:38 <quicksilver> how can you say the apple story is an urban myth? I've seen the tree!
07:43:41 <quicksilver> ;)
07:43:56 <Baughn> EmielRegis: Inventing calculus, I think. Even if his formalism isn't what we wound up using, the concepts have been incredibly useful, everywhere
07:44:04 <Cale> Well, that was relatively painless. :)  Some problems with the graphics driver at first, but those all but sorted themselves out. Smoothest upgrade (so far) I've had in the last few releases of Ubuntu.
07:44:10 <EmielRegis> he didnt invetn it Baughn
07:44:16 <EmielRegis> he merely wrote it down in formal way
07:44:21 <EmielRegis> again, using mathematics
07:44:38 <Baughn> Okay. Inventing formal calculus and making it actually usable. ;)
07:44:57 <EmielRegis> yea :p
07:45:06 <Cale> Newton was, iirc, responsible for the f(x) notation for function application.
07:45:16 <EmielRegis> anyway can someone answer my previous question - are there static variables (like in C++) in haskell?
07:45:23 <Cale> EmielRegis: no?
07:45:25 <EmielRegis> which are kept between all instances of function
07:45:29 <EmielRegis> dammit
07:45:31 <Baughn> EmielRegis: Not variable ones
07:45:35 <Cale> EmielRegis: That's not terribly meaningful in Haskell.
07:45:39 <EmielRegis> well
07:45:49 <Baughn> EmielRegis: What's the problem you are trying to solve?
07:45:55 <EmielRegis> i want to write a function which gets a String and a Char
07:46:01 <Baughn> Cale: So what you're saying is, Newton invented C?
07:46:02 <EmielRegis> and returns all occurences of Char in the string
07:46:02 <Cale> EmielRegis: You mean something like an IORef which is kept between invocations of an IO action?
07:46:05 <EmielRegis> all using recursion
07:46:12 <EmielRegis> and i cant do it pretty much
07:46:26 <Cale> EmielRegis: yeah, you don't need anything so fancy :)
07:46:26 <EmielRegis> cause when I do this
07:46:27 <EmielRegis> searchRec (x:xs) c 	| x == c = (getElemIndex (zip (x:xs) [0..]) c) : searchRec xs c
07:46:27 <EmielRegis> 					| otherwise = searchRec xs c
07:46:33 <EmielRegis> the element index is never right
07:46:35 <Baughn> EmielRegis: Try with Prelude.filter
07:46:38 <EmielRegis> since it only gets the tail of the list
07:46:47 <EmielRegis> i need to write it myself
07:46:49 <plutonas> why could i get this error:  Couldn't match expected type `[Statement.T]' against inferred type `T', when i have defined T as newtype T = Program [Statement.T] ?
07:46:51 <EmielRegis> coding task for uni :p
07:46:55 <Baughn> EmielRegis: Then rewrite filter on your own
07:46:56 <plutonas> is there something i understand wrong?
07:47:00 <Cale> EmielRegis: Do you know about zip?
07:47:02 <Baughn> EmielRegis: It'll be easier split in two that way
07:47:05 <EmielRegis> yes Cale
07:47:07 <EmielRegis> its int he code
07:47:12 <EmielRegis> but my problem is
07:47:12 <Cale> > zip [0..] "abracadabra"
07:47:14 <lambdabot>   [(0,'a'),(1,'b'),(2,'r'),(3,'a'),(4,'c'),(5,'a'),(6,'d'),(7,'a'),(8,'b'),(9...
07:47:23 <EmielRegis> it never returns proper index after first iteration
07:47:26 <Cale> That will probably help you with the indices.
07:47:29 <EmielRegis> cause you obviously pass only tail of  original list
07:47:36 <EmielRegis> so the index you get is smaller than it should be
07:47:49 <Cale> zipping a list with [0..] gives you a list where every element is already paired with its index
07:47:50 <Baughn> So you store the index with the element, as cale suggested
07:47:58 <EmielRegis> yes i know that
07:48:06 <Cale> So, then your problem goes away :)
07:48:09 <EmielRegis> getElemIndex :: [(Char, Int)] -> Char -> Int
07:48:09 <EmielRegis> getElemIndex (x:xs) c 	| fst x == c = snd x
07:48:09 <EmielRegis> 						| otherwise = getElemIndex xs c
07:48:14 <EmielRegis> but it still applies
07:48:18 <EmielRegis> since its recursive...
07:48:25 <EmielRegis> to check the end of list
07:48:28 <EmielRegis> after getting the firs thit
07:48:32 <EmielRegis> you need to pass the tail of list
07:48:35 <EmielRegis> for recursion
07:48:43 <EmielRegis> and then, you dont get proper index for the second element
07:48:43 <Cale> EmielRegis: oh, you're wondering what to do when the element is not found?
07:48:46 <EmielRegis> since its index of the tail
07:48:55 <EmielRegis> no lol
07:49:00 <EmielRegis> let me explain step by step
07:49:05 <Baughn> EmielRegis: With >, please
07:49:05 <Philippa_> EmielRegis: so subtract to account for that?
07:49:14 <Baughn> > zip "foo" [0..]
07:49:15 <lambdabot>   [('f',0),('o',1),('o',2)]
07:49:21 <Cale> > map fst. filter ((==a) . snd) . zip [0..] $ "abracadabra"
07:49:21 <lambdabot>   Couldn't match expected type `Expr' against inferred type `Char'
07:49:28 <Cale> > map fst. filter ((=='a') . snd) . zip [0..] $ "abracadabra"
07:49:30 <lambdabot>   [0,3,5,7,10]
07:49:30 <EmielRegis> argh
07:49:42 <EmielRegis> i need to write it myself
07:49:45 <EmielRegis> without use of any functions
07:49:48 <EmielRegis> thats my problem
07:49:51 <Cale> Right, you'll probably write something recursive
07:49:52 <Baughn> EmielRegis: Well, can't you write filter yourself?
07:49:53 <EmielRegis> basically
07:50:00 <EmielRegis> I want to do same thing as elemIndices
07:50:01 <Cale> But look at what my function is doing
07:50:44 <fynn> did you guys notice that the country to submit the most solutions for ICFP, by a vast margin, was New Zealand?
07:50:45 <Cale> The problem of losing the correct indices in the list as you recurse is solved by first zipping the list with its indices.
07:50:46 <dblazakis> EmielRegis: zip once and pass the zipped list to a helper recursive function
07:51:01 <Cale> Then you don't have to worry about where you are.
07:51:03 <fynn> followed, incidentally, by Australia?
07:51:13 <EmielRegis> hmm
07:51:18 <Baughn> fynn: Is that per capita?
07:51:21 <EmielRegis> ye ill probably try something with a helper function
07:51:22 <EmielRegis> thanks
07:51:24 <ronwe> i wonder why that is
07:51:30 <fynn> Baughn: no, it's absolute
07:51:36 <vegai> dons is from that area, fynn
07:51:39 <Cale> fynn: That is interesting, but not too surprising, given that they use functional languages in their curriculum.
07:51:48 <vegai> evangelism working? :P
07:51:55 <Baughn> ..I wish to be a new zealander. ;_;
07:51:55 <fynn> Cale: both NZ and Australia?
07:52:02 <dblazakis> anyone have country stats on #haskell?
07:52:05 <Cale> fynn: Well, I'm not 100% sure about NZ
07:52:09 <fynn> Baughn: maybe you could be an old zealander
07:52:11 <Cale> But Australia I'm sure about.
07:52:20 <fynn> Cale: NZ is the one leading the submission chart, by a huge margin
07:52:24 <Baughn> fynn: Sadly, all I am is an old fjordlander
07:52:30 <fynn> vegai: he's from NZ or OZ?
07:52:43 <fynn> here :http://www.icfpcontest.org/slideshow/icfp-08-awards-presentation-slides_files/icfp-08-awards-presentation-slides.022.png
07:52:45 <lambdabot> http://tinyurl.com/6hbmdg
07:52:46 <vegai> AU afaik
07:52:56 <Peaker> arrg. GNU paint sucks. Gimp can't easily draw circles: http://img72.imageshack.us/my.php?image=testgt4.jpg
07:53:07 <Cale> EmielRegis: A less efficient alternate solution is to use map to correct all the indices you get from the recursive call.
07:53:13 <plutonas> why could i get this error:  Couldn't match expected type `[Statement.T]' against inferred type `T', when i have defined T as newtype T = Program [Statement.T]?
07:53:14 <dblazakis> peaker try xfig for simple figures
07:53:15 <fynn> Baughn: sorry, it's per capita.
07:53:19 <EmielRegis> ok
07:53:26 <ronwe> *uses inkscape for abstract napkin art*
07:53:33 <Cale> EmielRegis: If y occurs at position n in xs then it occurs at position n+1 in (x:xs)
07:53:33 <quicksilver> plutonas: because they are different.
07:53:45 <Peaker> dblazakis: thanks.  I wonder if dot can do stuff like this
07:53:46 <EmielRegis> yes i know, thank you
07:53:46 * maltem_ was going to suggest inkscape too :)
07:53:56 <quicksilver> plutonas: if "x" has type [Statement.T] then "Program x" will have type T
07:54:03 <Baughn> Peaker: *snort*
07:54:08 <Cale> EmielRegis: (I'm just pointing out which theorem you apply, not suggesting that this is not an obvious fact ;)
07:54:16 <quicksilver> plutonas: Program is the constructor, Program :: [Statement.T] -> T
07:54:21 <Peaker> It was inside out, so does: http://img72.imageshack.us/my.php?image=testgt4.jpg  now make sense?
07:54:30 <plutonas> hm, quicksilver you're right :)
07:54:49 <fynn> Peaker: aren't everyone using inkscape nowadays?
07:55:01 <quicksilver> Peaker: No.
07:55:11 <plutonas> quicksilver: so i need to remove Program to make it work?
07:55:11 <quicksilver> Peaker: that suggests that all Arrows are applicatives, and functors.
07:55:15 <Cale> Inkscape is awesome :)
07:55:20 <quicksilver> plutonas: then it won't be a newtype anymore.
07:55:25 <Baughn> Peaker: I suppose you're right about "easily". What you do is make a circular selection, then border it, then bucket fill.
07:55:28 <quicksilver> plutonas: it depends what  you want it to do ;)
07:55:54 <quicksilver> Peaker: really it's quite hard to compare Arrow to Applicative or Functor.
07:56:04 <plutonas> quicksilver: i remove the Program constructor using pattern matching, and it works as it should
07:56:14 <quicksilver> Peaker: Arrows are of kind (* -> * -> *) and the other two are kind (* -> *)
07:56:21 <quicksilver> plutonas: ah, that's what you meant by 'rmove the Program'
07:56:35 <quicksilver> plutonas: yes, that's absolutelyright ;)
07:56:42 <plutonas> quicksilver: thank you
07:57:37 <quicksilver> Peaker: the reason we can make the comparison between Arrow and Monad is have Kleisli (in one direction) and ArrowApply, sort of, in the other.
07:59:56 <fynn> The funny thing is that despite the amount of submissions from NZ to the ICFP, Googling "Haskell New Zealand" only yields one Mrs. Lydia Haskell, discussing her upcoming trip to New Zealand.
08:00:26 <Peaker> New Zealand is a land of nice treks, sheep and kiwi, not FP :-)
08:00:28 <lilac> every Monad naturally gives rise to an Arrow and a Pointed, Applicative Functor
08:00:52 <lilac> hmm. is Pointed and Applicative enough to imply a Monad instance?
08:00:54 <Peaker> quicksilver: But isn't it still possible to draw what I have, perhaps add another circle for arrows that are not applicatives/functors?
08:00:59 <quicksilver> lilac: No.
08:01:05 <Peaker> @hoogle Pointed
08:01:05 <lambdabot> No results found
08:01:07 <dolio> All applicatives are pointed.
08:01:20 <EmielRegis> hmm
08:01:40 <quicksilver> for an Applicative to be a Monad, you need to find bind (or join) consistent with the given <*>.
08:01:41 <lilac> quicksilver: hmm. still need a join? :(
08:01:45 <EmielRegis> related to my previous question - when I zip it to get the index, I must run it outside the recursive function, right?
08:01:49 <fynn> Peaker: oh, and some Rugby players as well
08:01:54 <ronwe> probably because most people do not make an association between country of residence and programming language usage
08:02:03 <quicksilver> Peaker: I don't know what it means for an arrow to not be an applicative
08:02:03 <EmielRegis> and then call the recursive function with the tuple as argument, yes?
08:02:10 <fynn> Peaker: (I brought it up because per-capita, they lead the ICFP submission histogram by a huge margin)
08:02:17 <Peaker> fynn: I had a 3.5 month post-service (mandatory army service here) trip to NZ..
08:02:22 <quicksilver> Peaker: being an arrow is a property of kind : * -> * -> *
08:02:31 <quicksilver> Peaker: being an applicative is a property of kind : * -> *
08:02:44 <quicksilver> Peaker: there is no intersection between (*->*) and (*->*->*)
08:02:46 <fynn> Peaker: maybe you planted the seeds of Haskell among the local fauna?
08:02:57 <Peaker> fynn: I didn't know Haskell at all :)
08:03:01 <fynn> brought the monads to the sheep?
08:03:04 <quicksilver> Peaker: therefore, nothing could ever be an arrow and an applicative.
08:03:08 <fynn> hm, guess it's not you then
08:03:18 <quicksilver> now, the *only* reason that this argument doesn't apply to monad
08:03:21 <quicksilver> (and it should, really)
08:03:28 <quicksilver> is that we have "Kleisli"
08:03:31 <dolio> All arrows give rise to applicatives via partial application.
08:03:40 <fynn> it would be funny if some of those submitters were sheep though.
08:03:42 <quicksilver> which converts from (* -> *)  to (* -> * -> *)
08:03:51 <dolio> And applicatives f give rise to arrows f (a -> b).
08:03:54 <mauke> :k Kleisli
08:03:56 <lambdabot> (* -> *) -> * -> * -> *
08:04:02 <quicksilver> dolio: is that interesting, or trivial ?
08:04:07 <Peaker> quicksilver: quicksilver but partial application of a type constructor upgrades the other way around
08:04:07 <quicksilver> dolio: I ask honestly, not to be rude.
08:04:20 <dolio> quicksilver: I don't think it's trivial...
08:04:29 <Peaker> quicksilver: s/upgrades/converts
08:04:33 <quicksilver> Peaker: but that is doing something different.
08:04:37 <quicksilver> it's fixing one parameter.
08:04:47 <quicksilver> that's not adjoin to Kleisli
08:04:55 <quicksilver> (or anything similar to being adjoint to Kleisli)
08:05:07 <quicksilver> of course in general there are lots of ways to get between different kindings.
08:05:17 <quicksilver> you need to decide which ones are interesting
08:05:23 <quicksilver> if you're doing to draw a venn diagram
08:05:33 <quicksilver> "which arrows arise from monads" is a well trodden little path
08:05:37 <quicksilver> (via Kleisli)
08:05:44 <quicksilver> so I confidently know what that means.
08:05:57 <quicksilver> I don't confidently even know which question to ask for the Applicative/Arrow case
08:06:02 <quicksilver> let alone the Functor/Arrow case.
08:06:26 <quicksilver> the domain of effects is probably a key thing to consider.
08:06:45 <quicksilver> the Kleisli / ArrowApply transform takes you between arrows and monads which have the same effects.
08:06:55 <quicksilver> does the partial application transform?
08:07:40 <quicksilver> I'm pretty sure "f (a -> b)" is not an Arrow with the same effects as f.
08:07:48 <quicksilver> (as the applicative f)
08:07:59 <dolio> quicksilver: arr = pure, f >>> g = (.) <$> f <*> g, first = fmap (\f (a,c) -> (f a, c)) I think.
08:08:14 <quicksilver> do I win a #haskell monologue prize now?
08:08:20 <quicksilver> dolio: yes, that makes sense to me.
08:08:21 <lilac> yes
08:09:12 <dolio> Actually, that (>>>) is backwards, but whatever.
08:09:54 <Saul_> Is there an easy way to use parsec to parse directly from an open handle?
08:10:11 <lilac> in arrow proc notation, would it be possible to allow expressions of type "a () b" (where a is the arrow) to be accepted as commands?
08:10:28 <lilac> writing foo -< () just feels silly
08:10:54 <jeffz> Saul_: why?
08:11:15 <Saul_> I want to parse an http response
08:11:29 <lilac> Saul_: combine it with hGetContents
08:11:32 <Peaker> quicksilver: I'm sorry, I'm a little preoccupied with other things, but I'm reading everything you write :) And thanks for the explanations..
08:11:58 <jeffz> Saul_: what lilac said.
08:11:59 <Saul_> lilac: The problem with that is that the handle isn't closed, so the program won't terminate
08:12:04 <quicksilver> Peaker: I'm not tring to say you can't do a meaningful diagram.
08:12:34 <lilac> Saul_: right. so how will you know when to stop?
08:12:36 <quicksilver> Peaker: I'm tring to say that if you do do a diagram you probably have to decide which transformations from (*->*) and (*->*->*) you're using.
08:12:47 <quicksilver> and if the transformation you use for Monad is different from the transformation you use for Arrow
08:12:56 <quicksilver> then that might make the diagram pretty confusing
08:13:01 <Saul_> lilac: The parser knows when it's done
08:13:03 <quicksilver> s/Arrow/Applicative/
08:13:11 <Peaker> quicksilver: Yeah, I understand, that makes sense
08:13:20 <lilac> Saul_: then the parser can stop there.
08:13:47 <Saul_> lilac: Ok, but won't hGetContents block anyway?
08:14:17 <EmielRegis> uhn
08:14:23 <EmielRegis> how can i convert maybe int to int?
08:14:39 <quicksilver> decide what you want Nothing to represent
08:14:42 <quicksilver> and then use fromMaybe
08:14:52 <quicksilver> > fromMaybe 5 (Just 3)
08:14:53 <lambdabot>   3
08:15:01 <EmielRegis> ok
08:15:02 <EmielRegis> thanks
08:15:03 <quicksilver> > fromMaybe 5 Nothing
08:15:04 <lambdabot>   5
08:15:49 <lilac> Saul_: it's possible you'll need to set the buffering mode on the handle to something other than the default
08:16:27 <Saul_> lilac: Ok I'll try that
08:16:31 <Saul_> lilac: Thanks
08:29:13 <dons> upmods kids, http://www.reddit.com/r/programming/comments/77qxx/learn_you_a_haskell_for_great_good/ :)
08:29:15 <lambdabot> Title: Learn You a Haskell for Great Good! : programming, http://tinyurl.com/5okw6u
08:29:34 <BONUS> haha, oh my!
08:30:12 <lilac> BONUS: you knew it was coming :D
08:30:32 <BONUS> yeah haha, thats true, i was wondering how much i could put out before it got traction
08:30:41 <BONUS> but theres a decent amount of material for an absolute beginner now imho
08:30:44 <BONUS> so its all good :)
08:30:55 <dons> yeah, good work
08:31:30 <dons> you could announce it on -cafe@ too
08:31:35 <Baughn> BONUS: Instead of typing :l somefile twice, you can type :r
08:31:49 <BONUS> yeah, thats true
08:31:58 <BONUS> hmmm ... i dont know how to use mailing lists haha
08:32:06 <BONUS> but yeah, i could announce it there too
08:33:39 <BONUS> once again, if you notice any errors/corrections/requests, have lambdabot tell me or something :)
08:34:43 <Baughn> I just did. ^_^
08:35:08 <Baughn> Eh. You might want to include an example emacs configuration, for those who like that.
08:35:33 <Baughn> Then again, emacs users can probably figure out haskell-mode on their own..
08:35:40 <BONUS> haha
08:35:43 <BONUS> let me just include that :r thing
08:36:39 <dons> wow, apparently it is tutorial day, http://www.reddit.com/r/programming/comments/77pls/useful_haskell_resource_for_basic_activities_ie/
08:36:41 <lambdabot> Title: Useful haskell resource for basic activities - i.e. not just brain expanding com ..., http://tinyurl.com/5nyuo2
08:36:41 <Baughn> BONUS: You may want to mention *why* 5*-3 is bad. Not that you have to explain it, but use a footnote, or hyperlink, or something..
08:36:53 <Saizan_> quicksilver, Peaker: it's perhaps interesting that if you start with Monad m, go to Arrow (Klesli m), and then to Applicative (Kleisli m ()), you get back the same Applicative as defined with return = pure; (<*>) = ap, if you consider (() -> m a) ~= m a
08:37:36 <BONUS> Baughn: alright, noted
08:37:40 <BONUS> i'll look into that as well
08:38:14 <Baughn> BONUS: Oh, and the 5+"llama" error message specifically has GHC suggesting that you might want to /make/ "llama" a number
08:38:21 <quicksilver> Saizan_: that is interesting.
08:38:24 <BONUS> okay i added the :r thingy
08:38:34 <Baughn> Which, of course, you don't
08:38:54 <BONUS> yeah Baughn, thats true, but i kind of didnt want to go into typeclasses and such so early in the tutorial
08:39:05 <BONUS> so i just settled on telling a small lie early on
08:39:13 <BONUS> which is of course rectified later :)
08:39:14 <Baughn> BONUS: You don't need to. How about this:
08:40:01 <Baughn> BONUS: "What GHCi is telling us here is that "llama" is not a number, and so it doesn't know how to add it to 5. Specifically, since you can define your own number types, it's suggesting that you might want to make it one; we don't."
08:40:24 <Baughn> BONUS: Well, maybe you're right, but I'd put something like that in a footnote
08:40:26 <Baughn> I'm footnote-happy
08:40:29 <BONUS> haha
08:40:40 <BONUS> yeah i'll probably add something like that
08:40:46 <BONUS> or maybe exactly that :)
08:40:48 <BONUS> since you put it so well
08:41:39 <Baughn> Hum. I wonder if I could make an instance Num String that uses natural language encoding for numbers..
08:41:55 <BONUS> haha
08:42:04 <BONUS> you mean like
08:42:14 <BONUS> "Five hundred and thirty eight" + "five million"
08:42:17 <Baughn> Yes
08:42:20 <quicksilver> Baughn: of course you can.
08:42:22 <Baughn> 'fromInteger 5 :: String" == "Five"
08:42:32 <lilac> "hello" + "world" = "not a number"
08:42:35 <quicksilver> Baughn: question is, can you make it reasonably elegant? ;)
08:42:50 <quicksilver> for a follow-up gig, do roman numerals.
08:42:54 <Baughn> quicksilver: And can I make it deal well with natural language numbers? ;_;
08:43:01 <Baughn> I think I'd do roman numerals first
08:43:14 <lilac> hmm
08:43:22 <lilac> do roman numerals in the type system!
08:43:33 <lilac> > X V I I + I X
08:43:34 <lambdabot>   Not in scope: data constructor `X'Not in scope: data constructor `V'Not in ...
08:43:38 <Baughn> No. In fact, NO.
08:43:44 <quicksilver> it would actually be more impressive to do types in the roman numeral system.
08:43:47 <lilac> :( maybe i will then
08:44:34 <Baughn> BONUS: s/real number/floating-point number/
08:44:53 <Baughn> BONUS: They aren't reals by any reasonable measure
08:45:11 <Peaker> can you import a module without its weird-o instances? (e.g Num Sting) :-)
08:45:17 <Peaker> String, that is
08:45:18 <Baughn> Nope
08:45:40 <BONUS> Baughn: yes that's actually true
08:45:43 <Peaker> Then someone can easily pollute your world from a module?
08:45:48 <BONUS> that's it, you're getting co-authorship :D
08:46:40 <Baughn> BONUS: "As you've seen, we call it by sandwiching it between its arguments." <-- Don't overuse pronouns
08:46:47 <Baughn> "them" doesn't work
08:46:47 <quicksilver> instances are supposed to be global, Peaker
08:46:56 <quicksilver> any attempt to pretend they aren't normally ends in tears.
08:47:03 <Baughn> They're also supposed not to overlap, so it should never actually matter
08:47:04 <plutonas> i want to apply a function to all elements of a list, but don't care about the results, is map still the way to go?
08:47:04 <anonymouz666> hello - par::[Int]->[Int] par lista=[n|n<-lista,mod n 2==0] -- what means n|n<-lista syntax ?
08:47:24 <plutonas> i mean results come as side effects (unfortunately :P) so i don't need the return list
08:47:29 <BONUS> Baughn: haha, yeah i'll have to have some sort of editor person go over the whole thing once
08:47:33 <Baughn> plutonas: By "function", do you mean "IO procedure"?
08:47:34 <Peaker> Then Baughn better use: newtype NumString = NumString String ?
08:47:36 <Baughn> plutonas: Use mapM_
08:47:46 <BONUS> cause i aint no Hemingway
08:48:11 <Baughn> Peaker: Probably. For something this weird..
08:48:25 <Baughn> Peaker: I'll just provide a from/toString function
08:48:39 <Baughn> Well, that's basically what newtype is for. :P
08:48:44 <jcpetruzza> hi, i'm getting unusual linker errors building a project with ghc 6.8.3:
08:48:49 <jcpetruzza> Linking dist/build/hylores/hylores ...
08:48:49 <jcpetruzza> ld: atom sorting error for _HyLoResziCoreziWorker_Serial_closure_tbl and _HyLoResziCoreziWorker_SMP_closure_tbl in dist/build/hylores/hylores-tmp/HyLoRes/Core/Worker.o
08:48:49 <jcpetruzza> ....
08:48:59 <jcpetruzza> any ideas?
08:49:02 <Baughn> Jedai: OS X?
08:49:08 <Baughn> jcpetruzza: OS X?
08:49:19 <Baughn> ..ninja joiners.
08:49:20 <jcpetruzza> Baughn: yes, and ghc from macports
08:49:36 <Baughn> jcpetruzza: Is it actually causing the link to fail?
08:50:13 <jcpetruzza> Baughn: oh, i didn't check
08:50:15 <Baughn> jcpetruzza: http://www.haskell.org/pipermail/glasgow-haskell-users/2008-January/013990.html
08:50:19 <lambdabot> Title: [Fwd: Re: Problem building hdbc-sqlite3 with ghc 6.8.2], http://tinyurl.com/5nlrho
08:50:31 <jcpetruzza> Baughn: yes, the binary is there
08:50:35 <Baughn> jcpetruzza: It appears to be an artifact of macports
08:50:53 <Baughn> Or, at least, i haven't seen it since I stopped using it
08:51:01 <Baughn> Which was the same time I switched to leopard. Hmm..
08:51:53 <jcpetruzza> Baughn: I never saw it while using Tiger.
08:52:03 <jcpetruzza> Well, it's good to see nothing is broken
08:52:10 <jcpetruzza> Thanks!
08:55:12 <plutonas> can i do pattern matching in lambda? like (\ (Num x) -> x*x)?
08:56:19 <quicksilver> yes.
08:56:41 <quicksilver> > (\(Just x) -> x*x) $ Just 9
08:56:42 <lambdabot>   81
08:58:37 <leimy> on cafe, there's a rather interesting discussion about floating point possibly belonging in a Monad
08:58:45 <leimy> anyone have any thoughts about that?
08:59:02 <Baughn> Sounds reasonable. It'd have about the same semantics as Maybe, right?
08:59:05 <leimy> It really does appear that those computations belong in a Monad...
08:59:18 <leimy> well there's environmental flags for IEEE floats
08:59:21 <Baughn> Of course, it pretty much does that already
08:59:21 <leimy> for rounding and stuff
08:59:27 <quicksilver> they sort-of do, leimy
08:59:32 <leimy> also... it makes me think of Integer arithmetic
08:59:35 <Baughn> > (0/0) + 1
08:59:36 <lambdabot>   NaN
08:59:36 <leimy> like what of overflows?
08:59:40 <quicksilver> although actually it doesn' thave to be a monad necessarily.
08:59:45 <leimy> isn't  that environmental too?
08:59:46 <quicksilver> just something abstract
09:00:03 <leimy> yeah... it's just interesting what happens if one takes "purity" to the extreme.
09:00:03 <quicksilver> (1 + 2 + 4 + 5) :: AbstractDouble
09:00:08 <Baughn> NaN "taints" numbers, etc. - all the error conditions do. It seems to me that it /already/ does about everything you'd get from a monad
09:00:15 <quicksilver> runAbstract :: IEEEFlags -> AbstractDouble -> Double
09:00:55 <quicksilver> runAbstract (OverflowDoesThis ++ NaNIsAnException) (1 + 2 + 4 + 5)
09:00:59 <quicksilver> no monads needed.
09:01:04 <quicksilver> just a way to separate + pass flags.
09:01:08 <Baughn> quicksilver: ..wouldn't that imply attaching IEEE flags to each thunk and resetting the cpu every single time you evaluate one?
09:01:22 <quicksilver> Baughn: it would imply the compiler has to do some hard work.
09:01:36 <quicksilver> Baughn: and hopefully it proves that 99% of the time you always use the same flags
09:01:39 <quicksilver> and everything can optimise out the way
09:01:41 <leimy> Baughn: isn't that what people do anyway?  If they have to set flags to a known state before computation.
09:01:58 <quicksilver> Baughn: in *principle* this is certainly possible.
09:02:05 <quicksilver> maybe it's just not interesting enough to spend the time working on.
09:02:09 <quicksilver> or not interesting to the right people.
09:02:16 <Baughn> quicksilver: You'd have to prove it across libraries too. Whee.
09:02:25 <leimy> ugh
09:02:27 <quicksilver> yeah, and you'd have to understand evaluation order
09:02:34 <quicksilver> and understand about thunks being evaluated at funny times.
09:02:35 <leimy> hence monad?
09:02:38 <quicksilver> it's by no means trivial.
09:02:42 <quicksilver> but it's certainly possible.
09:02:47 <leimy> if the evaluation order is needed, don't you have to go imperative?
09:02:51 <quicksilver> no.
09:02:58 <quicksilver> it's just easier to do so :)
09:03:06 <quicksilver> it's possible to not do that, as I just showed.
09:03:07 <leimy> no I guess you can thread state through a series of expressions :-)
09:03:09 <leimy> without it.
09:03:11 <leimy> yes.
09:03:13 <leimy> you did :-)
09:03:15 <Baughn> leimy: He means, to implement it you'd have to understand how the GHC evaluation model works for lazy expressions
09:03:18 <leimy> I've been switching windows.
09:03:31 <Baughn> leimy: Since the IEEE flags happen to be part of the cpu context..
09:03:34 <quicksilver> Baughn: which, hopefully, people who hack on GHC do anyway ;)
09:03:41 <leimy> yeah
09:03:47 <Baughn> It's doomed anyhow. Does linux even save and restore those flags on context switches?
09:03:51 <quicksilver> yes.
09:03:52 <Baughn> Even if it does, I know a lot of OSs don't
09:04:02 <quicksilver> I bet linux does.
09:04:15 <quicksilver> I don' tknow for sure, I admit.
09:04:22 <quicksilver> leimy: it would be simpler to wire it into IO.
09:04:26 <quicksilver> not any old monad, though.
09:04:31 <quicksilver> it specifically would have to be IO
09:04:41 <quicksilver> (that's the only monad that has an execution order hardwired into GHC)
09:04:59 <quicksilver> it could be "pretend not to be IO" in the same sense that ST is, of course.
09:05:06 <quicksilver> but still IO underneath.
09:06:34 <Baughn> BONUS: You forgot to mention that you can prexify infix functions by wrapping them in parantheses
09:07:13 <BONUS> Baughn: yeah, that's mentioned later on i think
09:07:18 <BONUS> i'll check again though
09:07:21 <Baughn> Seems like it'd fit in the same paragraph
09:08:11 <Baughn> BONUS: Oh, and the reason your functions don't have to be in order in haskell is (practically) because the compiler compiles the entire file as a unit. The language being functional has nothing to do with it; C does the same, with the right flags.
09:08:40 <BONUS> ah
09:08:41 <Baughn> It then complains bitterly about you not adding prototypes and refuses to work right, since it was conceived on machines that lacked the memory for that sort of thing.
09:09:26 <BONUS> do you think that's something the reader should be aware of?
09:09:27 <Baughn> BONUS: In practice, you just have to say "Functions in haskell don't have to be in any particular order."; no reasoning needed. None is given in the report, really; it's just more convenient this way.
09:09:32 <Baughn> No.
09:09:35 <BONUS> ah
09:09:43 <BONUS> yeah, i'll remove the because then
09:09:54 <BONUS> in which paragraph is that mentioned again
09:10:00 <Baughn> Baby's first functions
09:10:05 <BONUS> awesome, thanks!
09:10:47 <BONUS> there we go, fixed
09:11:16 <pmurias> i have a haskell parser i want to use to preprocess to C+DSL files and then link it with the output what is the best way to do it?
09:11:25 <Baughn> BONUS: Actually, I think you should move that sentence to where you define doubleUs
09:11:32 <Baughn> BONUS: And then define doubleUs in terms of doubleMe
09:11:54 <BONUS> you're right
09:12:01 <BONUS> without the because it just doesn't fit in that beginning sentence
09:13:28 <Baughn> BONUS: Also, footnote on "where 2 is 3.": "For a few seconds, before the sun explodes."
09:13:37 <BONUS> hahah :D
09:13:50 <BONUS> yeah i'll have to think about some kind of footnotes or something
09:13:53 <Baughn> BONUS: Your typesetting is horrid, by the way. Use latex.
09:13:55 <BONUS> for stuff like that
09:14:15 <Baughn> \footnote{For a few seconds, before the sun explodes.}
09:14:25 <BONUS> latex? for publishing on the web?
09:14:30 <Baughn> Sure
09:14:35 <pumpkin_> mmm latex
09:14:37 <Baughn> It has a perfectly reasonable html output module
09:14:44 <pumpkin_> I love xetex
09:14:49 <Baughn> The typesetting will still be horrid, but not /this/ bad
09:15:05 <BONUS> why do you think its *so* bad?
09:15:14 <pumpkin_> What annoys me is that CSS still doesn't support font-specified kerning pairs
09:15:30 <pumpkin_> even the css3 draft doesn't really have much for it
09:15:38 <Baughn> BONUS: The right edge is ragged, and firefox doesn't do kerning well. Or at all.
09:15:51 <BONUS> oh that
09:15:58 <BONUS> eh i think it's readable enough
09:16:12 <BONUS> if i used latex to output the html, i can imagine what kind of horrid markup would result from that
09:16:17 <quicksilver> pumpkin_: why would that be a CSS thing?
09:16:21 <quicksilver> (not to get too badly off topic)
09:16:22 <Baughn> BONUS: With latex, you could provide a html version, get footnotes and content lists for free, and have a PDF for download too
09:16:31 <quicksilver> pumpkin_: surely if the font has kerning pairs, the browser is free to use them?
09:16:42 <Baughn> It's just basically the best way to write books. Which is kinda sad, given how old it is
09:16:46 <pumpkin_> quicksilver: well, none of the browsers I know of do :P
09:16:54 <quicksilver> pumpkin_: I bet they do on the mac.
09:16:56 <pumpkin_> not even webkit/safari
09:16:57 <pumpkin_> nope
09:16:58 <pumpkin_> :(
09:17:00 <BONUS> i was thinking of doing a print version in latex
09:17:00 <quicksilver> interesting.
09:17:04 <BONUS> i love latex too for printing
09:17:04 <quicksilver> anyhow I don't think it's a CSS issue.
09:17:14 <BONUS> but for the web? i dont know, ugh
09:17:37 <pumpkin_> letter spacing in general should be controllable through CSS, for titles with wide letter spacing and so on... and you should be able to specify auto, which means it should use the font-specified spacings, I think
09:17:37 <Asztal> Firefox 3 certainly supports font kerning
09:17:53 <pumpkin_> well yeah, but does it read the kerning pairs in fonts?
09:17:58 <pumpkin_> and respect them
09:18:06 <Baughn> BONUS: Since you /are/ on the web, you may want to make code stand out better. Use a bit of color. :)
09:18:14 <pumpkin_> you can manually set letter spacing, but that's a real pain in the ass
09:18:19 <pumpkin_> anyway, sorry for the off-topic
09:18:20 <Asztal> http://farm4.static.flickr.com/3012/2578105838_15d7de2cc4.jpg ?
09:18:21 <BONUS> Baughn: do you have js turned off?
09:18:29 <Baughn> BONUS: Of course
09:18:33 <BONUS> lol
09:18:37 <Baughn> ...
09:18:38 <pumpkin_> Asztal: oh nice
09:18:38 <Baughn> Oh god
09:18:41 <pumpkin_> maybe I should use firefox then :)
09:18:42 <BONUS> well the code is actually beautifully colored
09:18:45 <BONUS> only with css
09:18:48 <Baughn> BONUS: That makes my head hurt
09:18:49 <BONUS> i mean
09:18:49 <BONUS> js
09:18:55 <Baughn> BONUS: Use CSS, and..
09:18:59 <BONUS> makes my head wonderfully head-ache free
09:19:01 <Baughn> BONUS: Fix those colors
09:19:22 <Baughn> Why would you use /js/?
09:19:25 <nicknull> ok, time for haskellers to brag: is there a way to have automatic multicore-running programs?
09:19:27 <BONUS> if i used css, i'd have to inject a lot of presentation into the markup etc. and changing the syntax highlighting later is harder
09:19:36 <Baughn> nicknull: No.
09:19:48 <Baughn> nicknull: The problem is most likely AI-complete.
09:20:01 <Baughn> nicknull: But don't worry, we make it really easy for the I.
09:20:03 <nicknull> i mean can it be abstracted away complete? so i just write code and dont think about making it run on multiple cores?
09:20:15 <nicknull> I?
09:20:33 <Baughn> No.
09:20:40 <nicknull> you mean full-on artificial intelligence complete scaled to a megacomputer?
09:21:04 <Baughn> I mean I don't think automatic parallelisation will get anywhere, ever.
09:21:12 <Baughn> Not until we've got full-on AIs writing our programs
09:21:21 <Baughn> That doesn't mean we can't make it really easy for the /programmer/
09:21:25 <nicknull> ok
09:21:34 <Baughn> Oh, and dynamic - runtime - parallelisation should be doable
09:22:05 <Saul_> I'm having some trouble with using parsec to get a http response
09:22:07 <Baughn> (At least to the degree of parallelising functional structures that don't care about order, like maps)
09:22:14 <nicknull> because im using python+numpy+scipy+matplotlib(instead of matlab) for a lot of math computation, it is veyr ahndy having everything in one prog lang(databsehandling, scripting etc). and i want to be able to utilize those cores
09:22:21 <Saul_> I want to parse the headers and then store the content to disk
09:22:30 <Saul_> But I'm not sure how
09:22:35 <jeffz> Saul_: what have you got so far?
09:22:41 <nicknull> saul: Network.HTTP.Simple
09:22:47 <nicknull> pretty slow though
09:22:53 <Baughn> nicknull: You can call python from haskell, you know
09:23:07 <nicknull> already?
09:23:07 <Baughn> nicknull: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/MissingPy <-- This
09:23:13 <lambdabot> Title: HackageDB: MissingPy-0.10.0, http://tinyurl.com/58bhds
09:23:18 <nicknull> Baughn: cool thanks
09:23:47 <Saul_> jeffz: Not anything readable in it's current state
09:24:30 <jeffz> Saul_: well, nicknull makes a good point that you could save yourself the headache and use Network.HTTP - it's easy to get things wrong.
09:25:36 <Saul_> jeffz: Yeah I've just been reading the docs on that, I think I'll use that instead
09:25:49 <Saul_> nicknull, jeffz: Thanks
09:36:09 <NikkiWhitecraft> does anyone here have any useful links to understand basic haskell like case statements and stuff?
09:37:25 <jeffz> NikkiWhitecraft: hot off the press, http://learnyouahaskell.com/
09:37:32 <lambdabot> Title: Learn You a Haskell for Great Good!
09:37:50 <grkz> how can I read two integers i,j from cli and construct a list [i..j]? I've managed to get [i,j], but I can't seem to map enumFromTo over that -- (newbie alert)
09:37:52 <BONUS> haha
09:38:05 <NikkiWhitecraft> that's great thank you ^^ doing haskell for the first time, so a little confused
09:39:13 <nicknull> saul: oh i wasnt answering you, i said to baughn :)
09:40:00 <Saul_> <nicknull> saul: Network.HTTP.Simple
09:40:03 <nicknull> or wait i was talking to you :)
09:40:09 <nicknull> :)
09:41:34 <quicksilver> grkz: i <- readLn; j <- readLn; print ([i..j])
09:41:59 <grkz> quicksilver: thank you
09:46:13 <Cale> Or:  liftM2 enumFromTo readLn readLn
09:48:13 <roconnor> ``Manuel mentioned that since Type Families can do everything Functional Dependencies can (and more)
09:48:16 <roconnor> is this true?
09:48:44 <roconnor> the claim about type families
09:50:25 <Cale> I thought there were examples showing that was untrue, but perhaps it's been refuted.
09:50:43 <Cale> (or type families have been extended in some way?)
09:50:59 <quicksilver> I think Manuel's claim is that it can solve the same problems
09:51:08 <quicksilver> not that it can encode FDs directly, in full.
09:51:18 <quicksilver> so, it's a fuzzy claim
09:51:37 <Saizan_> i guess it also depends on what extensions you allows on both sides e.g. OverlappingInstances? closed type families?
09:52:37 <C-Keen> hi there.
09:52:44 <Cale> hello
09:56:25 <C-Keen> I have got a cabal question. I tried a cabal install hmp3 and it says that it cannot install due to the helpful error messages I don't know what to do about it
09:56:44 <C-Keen> http://hpaste.org/11227
09:57:27 <C-Keen> I am using ghc-6.8.3 with cabal 0.5.2 on OpenBSD-current / i386
09:57:30 <Cale> hmm
09:57:47 <Cale> It's possibly missing the C headers for PCRE?
09:57:47 <olsner> hmm, you probably don't have the development headers for pcre installed
09:58:03 <C-Keen> shouldn't cabal take care of that?
09:58:07 <Cale> no
09:58:10 <C-Keen> oh ok
09:58:16 <Cale> Cabal doesn't actually know about C libraries.
09:58:21 <Cale> (maybe it should...)
09:58:33 <Cale> Or at least, it doesn't know how to install them.
09:58:33 <C-Keen> but it could test them as a requirement that would be helpful
09:58:48 <roconnor> quicksilver: I have some FDs that I don't know how to write using type families
09:58:50 <C-Keen> I will install that lib and retry
09:58:53 <C-Keen> thanks cale
09:59:01 <olsner> adding a test for giving a more sensible error message for missing C libraries might be something we should do
09:59:05 <roconnor> quicksilver: but I haven't thought deeply about it
09:59:27 <dolio> I'm pretty sure you can encode FDs into type families, provided the latter have been fully implemented.
10:00:03 <dolio> Equality constraints are an important part.
10:00:14 <quicksilver> roconnor: I think the correct way to approach it is to post a message to g-h-u (or possible the cafe) entitled WAH - type families SUX0R, CAN HAZ FDS BAK PLZ?
10:00:24 <quicksilver> roconnor: then Manuel will patiently explain the answer to your problem.
10:00:27 <quicksilver> and all will be well ;)
10:00:58 <quicksilver> dolio: yes, the ability to explicitly use equality constraints appears to be a phenomenally powerful feature.
10:01:05 <quicksilver> one which I don't remotely understand the implications of yet.
10:01:52 <Cale> Heh, find some contrived example which actually doesn't translate and then figure out how to make it almost look like it came from a practical problem ;)
10:02:21 <dobblego> @users
10:02:21 <lambdabot> Maximum users seen in #haskell: 518, currently: 500 (96.5%), active: 24 (4.8%)
10:02:58 <quicksilver> heck, I don't even really understand associated data
10:03:06 <quicksilver> although it seems like a nifty thing.
10:03:11 <quicksilver> need to play with it.
10:03:29 <roconnor> my example is simply:
10:03:29 <roconnor> class Wedge a b c | a b -> c, b c -> a, c a -> b where
10:03:29 <roconnor>  (/\) :: a -> b -> c
10:04:36 <roconnor> actually my current source code says: class Wedge a b c | a b -> c {-, b c -> a, c a -> b -}where ...  I don't know why I commented that out. :^)
10:05:16 <dolio> If it's possible, it's something like: "class (Dep1 a b ~ c, Dep2 b c ~ a, Dep3 a c ~ b) => Wedge a b c where Dep1 a b :: * ; Dep2 b c :: * ; Dep3 a c :: * ; (/\) :: a -> b -> c"
10:05:52 <dolio> Oops, those should be "type DepN ..."
10:06:17 <roconnor> oh
10:06:28 <dolio> Fundeps are, of course, noticeably nicer for that example.
10:07:42 <dolio> I think the Ultimate Plan is to have the fundeps desugar into the type families/equality constraints. But that's not in yet.
10:08:03 <Ash5> Hey, can anyone give me a hand with some simple Haskell code ?
10:08:51 <dolio> Although, that sounds like it'd be terrible for error messages...
10:09:44 <sbahra> Hi Ash5
10:09:51 <Ash5> Hi :D
10:09:55 <sbahra> You're better off pasting your code :-)
10:09:58 <sbahra> So we can all see.
10:10:11 <dolio> !paste
10:10:13 <Ash5> it's hardly started tbh. im a complete novice. where do i paste it ?
10:10:18 <Ash5> !paste
10:10:24 <Saizan_> @paste
10:10:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:10:31 <dolio> Huh, hpaste isn't even here anymore, eh? :)
10:10:59 <Ash4> @paste
10:11:00 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:11:30 <Ash0> it just reopens chat when i click it
10:11:47 <Ash0> @paste
10:11:48 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:12:40 <Saizan_> Ash0: you could just type that url in your browser if your irc client is having problems with urls
10:12:45 <Ash0> http://hpaste.org/11228
10:13:04 <NikkiWhitecraft> I can't get this case statement to work
10:13:04 <Ash0> im not sure what the code is to prompt an input at the top :$
10:13:39 <Ash0> the program is basically turning a user input, lets say 'message23: hello' into 'MESSAGETWOTHREEHELLO'
10:13:51 <sbahra> Ash0, google "Real World Haskell", great book.
10:13:57 <sbahra> Ash0, the program will not do this.
10:14:06 <sbahra> Ash0, do you know how to test it?
10:14:19 <Ash0> yeah i know. im doing 1 bit at a time. thats supposed to do the 23 to twothree
10:14:27 <Ash0> yeah im using Huggs
10:14:39 <sbahra> Ash0, ok.
10:15:07 <sbahra> Ash0, well, real world haskell will show you an example of how to prompt input...check out http://book.realworldhaskell.org/read/
10:15:12 <lambdabot> Title: Real World Haskell
10:15:18 <Ash0> whats the code to prompt an input? ... i thought it was 'variable "enter message:"' then 'getLine'
10:15:39 <lilac> NikkiWhitecraft: you'll need to tell us more than that for us to help you :) which case statement? or the haskell case statement in general?
10:16:43 <Saizan_> Ash0: small exaple: main = do putStrLn "enter message:"; line <- getLine; print line
10:17:09 <NikkiWhitecraft> the haskell case statement in general
10:18:15 <Ash0> i tried that, but i didnt put the semi-colons in :$
10:18:22 <sbahra> NikkiWhitecraft, indentation is important, make sure first character of every case is "aligned"
10:20:11 <NikkiWhitecraft> I've done that
10:20:55 <rwbarton> Ash0: You don't need the semicolons if you write it on multiple lines, provided you line up the words putStrLn, line, and print
10:21:14 <Ash0> is main = do on the same line, or is it 'main =' then 'do' ... im getting an unexpected =, and its the only = in my program
10:21:21 <Ash0> ooh ok :D
10:21:28 <sbahra> NikkiWhitecraft, could you show us your code?
10:22:03 <rwbarton> The 'do' can't be at the beginning of the next line, or it looks like a new declaration.
10:22:03 <pumpkin-_> how wide is a haskell char?
10:22:36 <rwbarton> > ord maxBound
10:22:38 <lambdabot>   1114111
10:23:01 <pumpkin-_> great
10:23:07 <MyCatVerbs> pumpkin-_: one unicode code point.
10:23:13 <pumpkin-_> yup
10:23:29 <pumpkin-_> how does ord maxBound print that btw?
10:23:30 <Ash0> is it possible to filter out everything except a capital letter? so it just removes them?
10:23:38 <pumpkin-_> that's the number of code points in unicode, but I see no mention of char or anything
10:23:39 <dolio> @type ord
10:23:40 <lambdabot> Char -> Int
10:23:45 <pumpkin-_> fair enough
10:23:46 <pumpkin-_> :P
10:24:09 <BONUS_> filter (not . isUpper) "HaHahahahAH"
10:24:13 <BONUS_> > filter (not . isUpper) "HaHahahahAH"
10:24:15 <lambdabot>   "aahahah"
10:24:15 <sbahra> Ash0, look at the filter function.
10:24:17 <sbahra> :t filter
10:24:18 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
10:25:32 <CosmicRay> BONUS_: are you the one behind learnyouahaskell.com?
10:25:36 <Ash0> last question for now :P ... how could i individually read each character in a message, so i can check if its a number or letter.
10:26:17 <pumpkin-_> BONUS_: oh my @ your twitter background
10:26:19 <Ash0> example, if i had 'message42' ... how can i say "is first character (m) a number, if not, move onto second.
10:26:30 <BONUS_> pumpkin- it's magical, isn't it?
10:26:36 <pumpkin-_> extremely :P
10:26:45 <CosmicRay> pumpkin-: I'll take that as a yes ;-)
10:26:58 <jeffz> Ash0: map isAlpha "message42"
10:27:01 <pumpkin-_> CosmicRay: I guess so :P I just assumed it would be
10:27:04 <C-Keen> Cale: ah my mistake was a missing extra-include-dirs: in cabal's config
10:27:30 <CosmicRay> BONUS_: well, if so, nice work ;-)
10:27:34 <pumpkin-_> BONUS_: do you only post tweets when you're on some substance?
10:27:44 <CosmicRay> I was sorta wondering that ;-)
10:27:50 <BONUS_> haha
10:27:54 <pumpkin-_> ALIEN GANJA 12:22 PM Sep 27th from web
10:27:58 <BONUS_> i tend to post random stuff
10:27:59 <pumpkin-_> witches are people too .... not 1:53 PM Sep 30th from web
10:28:00 <BONUS_> that comes to my mind
10:28:07 <CosmicRay>   my jewish dog   9:09 AM Oct 3rd from web
10:28:17 <CosmicRay> BONUS_: you could at least use twidge (written in haskell) to post ;-)
10:28:35 <BONUS_> yeah i tried installing twidge but somehow it wouldnt work
10:28:37 <BONUS_> im gonna try again
10:28:45 <BONUS_> one of these days
10:29:03 <CosmicRay> BONUS_: any specific error messages?
10:29:14 <BONUS_> not that i can recall
10:29:27 <CosmicRay> I would be happy to help you with it if you want to try it right now
10:29:30 <sbahra> The illustrations are cool :-P
10:29:38 <Ash0> can i pm someone with a couple more questions ?
10:29:39 <BONUS_> hmm ok lets see, let me just get my laptop out
10:31:37 * JuanDaugherty has a conceptual question.
10:32:00 <JuanDaugherty> first I want to motivate it with a real world situation.
10:32:22 <dolio> Bah. The real world is for chumps!
10:32:54 <BONUS_> hmm
10:33:02 <BONUS_> strange, i thought i had cabal install installed
10:33:17 <JuanDaugherty> as it turns out current browsers don't maintain browser history for layers/frames in  the way that would make ordinary common sense and actually is what you might call completely broken.
10:33:45 <JuanDaugherty> this is for the case of multiple frames on the same page, not a single one which works exactly as expected.
10:34:06 <quicksilver> given that frames are deprecated, I doubt this problem will be solved.
10:34:10 <jeffz> Ash0: you can ask as many questions as you like in the channel
10:34:20 <JuanDaugherty> the question is, would development in Haskell tend to have elimate this because
10:34:51 <JuanDaugherty> the common sense expectation would have gotten somehow translated into an effective specification?
10:35:12 <Ash0> can someone put together a code to input prompt 'putStrLn', then read each individual character, checking for numbers 'isAlpha'
10:35:21 <JuanDaugherty> *tended to have eliminate
10:35:27 <Ash0> i have both the seperate codes, but im still not getting an output
10:35:31 <sbahra> Ash0, no.
10:35:39 <sbahra> Ash0, you need to learn how to program things yourself :-)
10:35:53 <ahunter> So during the recent discussion about MTL and avoiding the annoying quadratic instnace problem, I remember someone showing how you could use FlexibleInstances to avoid this problem entirely for new monad trasnformers..but I can't find it in the -cafe archives.  Can anyone point me to what I'm looking for/remind me how one can set up the instances?
10:36:02 <sbahra> Ash0, you obviously have not even bothered looking at a book and are rushing to have a working version of something you don't understand
10:36:21 <JuanDaugherty> I suppose if there was a Haskell browser that would be that answer there.
10:36:29 <pumpkin-_> Ash0: you can even experiment in here!
10:36:34 <sbahra> Ash0, check out "Real World Haskell", BONUS's http://learnyouahaskell.com/chapters looks really nice here
10:36:34 <lambdabot> Title: Learn You a Haskell for Great Good!
10:36:36 <pumpkin-_> although some people tend to drown out conversation by doing that
10:36:49 <pumpkin-_> there's also http://book.realworldhaskell.org/read/
10:36:50 <lambdabot> Title: Real World Haskell
10:36:51 <jeffz> JuanDaugherty: I'm not sure what you consider "ordinary common sense" in this case, but choice of programming language would not restrict different semantics of a user interface.
10:36:52 <pumpkin-_> both of them look good to me
10:37:30 <Ash0> i've actually been lecturers, taken notes, and listened (unlike most students). I can code in various other languages. I'm just not getting this lol
10:37:32 <ahunter> sbahra: having skimmed learn you a haskell briefly--admittely, probably not fair--it seems way too cutesy and felt somewhat condescending to me...RWH felt much better written
10:37:54 <sbahra> ahunter, really?
10:37:58 <JuanDaugherty> well a user expects that each frame will maintain a consistent browsing history and that the controls for forward and back navigation will work as they do on a regular page or single frame.
10:38:05 <sbahra> ahunter, I just skimmed it, didn't feel it to be condescending personally. :-P
10:38:10 <sbahra> ahunter, I think it's more "playful".
10:38:14 <JuanDaugherty> that's not the case with multiple frames/layers.
10:38:20 <CosmicRay> if only my school had taught haskell
10:38:43 <Ash0> i wish mine didnt
10:38:54 <pumpkin-_> Ash0: learning other languages doesn't mean you know haskell, clearly
10:38:57 <CosmicRay> come now, how can you come into #haskell and say that? ;-)
10:39:01 <sbahra> ahunter, best book I have read so far is Simon Thompson's
10:39:12 <pumpkin-_> Ash0: I know loads of other languages and am learning haskell for fun!
10:39:22 <pumpkin-_> cause it's so awesome :P
10:39:28 <CosmicRay> pumpkin-_: I was the same
10:39:40 <Ash0> im more into web programming, php/mysql/etc...
10:39:48 <Ash0> Haskell is doing my head in if im honest :P
10:39:49 <pumpkin-_> Ash0: there's a haskell web framework!!!
10:39:49 <jeffz> JuanDaugherty: ok, I still don't see how it's related to Haskell.  Someone else was talking about writing yet another browser, in haskell earlier
10:39:52 <CosmicRay> Ash0: so the reason they probably teach you Haskell is because it opens your mind to other ways of solving problems
10:39:53 <sbahra> Ash0, web programming in haskell is great. :)
10:40:10 <JuanDaugherty> but yes I think you're right jeffz, if the behaviour was only intuitively apparent how it possibly result in even an implicit effect specification.
10:40:15 <schme_> sbahra: What's so nice with Haskell for web programming?
10:40:16 <ahunter> sbahra: yeah.  fwiw, I also hated why's guide to ruby with a fiery burning passion.  Cute examples about entirely too silly problems, coupled with writing that takes way too much time on really, really obvious things and not-all-that-good-cartoons just screams "Well, you must be retarded if you don't know haskell.  But I'll let you be a Big Boy and impart my wisdom..." to me.
10:40:18 <pumpkin-_> Ash0: it forces you to think different... you'll be buying a mac in no time after you learn haskell
10:40:22 <CosmicRay> Ash0: if you are aware of different -- and dare I say, more elegant and simple -- ways to solve problems, it benefits you even if you don't make a career of using haskell
10:40:38 <pumpkin-_> why write a big for loop
10:40:40 <Ash0> neverrrr :P
10:40:41 <CosmicRay> Ash0: also if you are taking a computer science class, understand that CS is not about making you a good programmer
10:40:42 <JuanDaugherty> it's relevant because Haskell pushes that it is more likely to produce correct programs.
10:40:44 <pumpkin-_> when you can have a simple fold or map
10:40:53 <pumpkin-_> in many cases for loops are used
10:40:53 <sbahra> schme_, subjectively, I am not bored. :-P There are technical reasons (that are generic).
10:40:59 <jeffz> pumpkin-_: why would you buy a mac after learning Haskell?
10:41:01 <sbahra> schme_, have you looked at formlets before?
10:41:04 <ahunter> sbahra: I don't know that one...RWH was nice, straightforward, and just info-dumped effectively and efficiently, which is good when I'm not an idiot but just want a refernece for a feature I'm not really an expert in
10:41:07 <pumpkin-_> jeffz: because you think different! :P
10:41:09 <Ash0> it seems that way cosmicray. im in 2nd year, and all we've done so far is program.
10:41:17 <sbahra> ahunter, nod
10:41:17 <CosmicRay> Ash0: so here's an example.  I work for a lawn mower manufacturer.  We have various business-critical web code.  I write it -- *ALL* of it -- in Haskell.
10:41:24 <jeffz> pumpkin-_: hmm, I have been programming in Haskell for a few months and I definitely do not want a mac.
10:41:32 <pumpkin-_> Ash0: are you in a software engineering program or computer science?
10:41:37 <CosmicRay> Ash0: I can understand that.  but you haven't had any discrete math, calculus?
10:41:38 <Ash0> cs
10:41:39 <schme_> sbahra: No, not at all. I am very interested in web programming at the moment though. So I was wondering how Haskell was good for it.
10:41:41 <pumpkin-_> jeffz: jeez, it was a dumb joke :P
10:41:41 <sbahra> ahunter, well, skimming learnyouahaskell...I didn't see him wasting too many words on obvious things
10:41:57 <sbahra> schme_, look at formlets, for an example why.
10:42:01 <sbahra> schme_, also HaskellDB.
10:42:08 <jeffz> pumpkin-_: ah, you should have added a comment -- this is a joke
10:42:13 <Ash0> yeah i did A level matchs, and have done a unit in it at uni
10:42:14 <BONUS_> ah
10:42:15 <BONUS_> there we go
10:42:18 <Ash0> maths*
10:42:31 <CosmicRay> schme_: I like it because my code is as compact (or more so) than in Python, yet my code has an extremely high probability of Just Working
10:42:33 <schme_> sbahra: Right. I'll check that out. Thanks :)
10:42:38 <CosmicRay> if it compiles, it usually works
10:42:41 <pumpkin-_> jeffz: I figured that someone trying to link learning haskell to wanting a mac would be ridiculous enough to not need that, but next time I'm ridiculous I'll add a comment :)
10:42:43 <CosmicRay> no type errors found at runtime
10:43:00 <schme_> CosmicRay: I am not sure how that relates to web programming :)
10:43:02 <Ash0> I get like 90% in all other units. its nothing to do with me not trying to do it, or not understanding why Im being taught it.
10:43:14 <CosmicRay> so where's an intro to formlets?
10:43:15 <BONUS_> CosmicRay: this is what happens when i try to do a tweet: http://hpaste.org//11229
10:43:29 <CosmicRay> schme_: do you want somebody to get a type error when they click "Submit Order"?
10:43:31 <pumpkin-_> Ash0: if you're into web programming, why are you doing computer science?
10:43:38 <pumpkin-_> computer science isn't even about programming, really
10:43:45 <CosmicRay> pumpkin-_: that is a good question indeed
10:43:46 <Ash0> i need the degree to get into computer forensics
10:43:52 <vixey> "computer science" bleeeugh
10:43:57 <BONUS_> you mean like CSI? cool
10:43:59 <schme_> CosmicRay: Of course not. But programming a web app in haskell doesn't prevent errors in the app.
10:44:00 <sbahra> CosmicRay, http://haskell.org/haskellwiki/Formlets
10:44:01 <TomMD> "computer forensics" bleeeugh
10:44:01 <lambdabot> Title: Formlets - HaskellWiki
10:44:03 <CosmicRay> BONUS_: do you have curl installed?
10:44:04 <BONUS_> enhance image!
10:44:05 <Ash0> and yes it is. out of 8 units we've had in 2 years, 6 have been pure programming.
10:44:06 <pumpkin-_> and you have no interest in learning interesting problem solving techniques?
10:44:06 <vegai> I know a ruby on rails application that gets random type errors on things all the time
10:44:15 <BONUS_> CosmicRay haha you know
10:44:15 <CosmicRay> BONUS_: also you need to change your twitter password.  you just revealed it in that paste.
10:44:17 <BONUS_> i dont know if i do
10:44:21 <BONUS_> i did?
10:44:21 <sbahra> schme_, of course not, but "web apps" have SO MUCH boiler plate
10:44:22 <schme_> CosmicRay: But it seems interested. Inormally use the lisps for webprogramming here.
10:44:25 <BONUS_> shiiiit
10:44:31 <Ash0> i have an interest in learning how to program. just not in haskell :P
10:44:32 <sbahra> schme_, haskell helps avoid this boiler plate, for one.
10:44:38 <pumpkin-_> lol CosmicRay
10:44:38 <CosmicRay> BONUS_: yes, look at the --user bit ;-)
10:44:39 <ahunter> pumpkin-_: there's no need to be rude...One of my best friends who's an /excellent/ computer scientist--big on theory, loves languages and information theory--also enjoys writing webapps, which is a useful skill.  For example, he really enjoys his job working at Google on webapps. :P  Just because there are dumb web programmers doesn't mean smart people can't like doing it for a living.
10:44:42 <BONUS_> haha
10:44:43 <schme_> sbahra: I am not sure what the term boiler plate is :)
10:44:47 <BONUS_> oh man
10:44:52 <BONUS_> thanks for pointing that out
10:44:56 <BONUS_> im so stupid
10:45:03 <CosmicRay> ahunter: that too is true.
10:45:21 <CosmicRay> web programming can be an incredibly complex task that requires CS folks.  (google, for instance.)
10:45:24 <pumpkin-_> ahunter: I wasn't saying that web programming is dumb, but if as he said he's not interested in going beyond web programming, I'm not sure why he'd do a CS degree, with theory, algorithms, and so on
10:45:31 <CosmicRay> the php/mysql comment didn't lead me in that direction
10:45:45 <pumpkin-_> I do a lot of web programming myself :)
10:45:46 <ahunter> pumpkin-_: you can like theory without wanting a research job
10:46:07 <Ash0> I didnt say I am not interested in going beyond web programming
10:46:10 <BONUS_> w00t! just did an update from Twidge
10:46:11 <BONUS_> awesome
10:46:15 <CosmicRay> sweet!
10:46:18 <BONUS_> thanks!
10:46:25 <CosmicRay> no problem
10:46:26 * lispy throws his hands up in the air
10:46:26 * pumpkin-_ shrugs
10:46:28 <Ash0> I've completely projects in Java and VB, and was interested there.
10:46:37 <sbahra> schme_, http://en.wikipedia.org/wiki/Boilerplate_code
10:46:38 <Ash0> its just Haskell :P i dunno why im not getting it.
10:46:39 <lambdabot> Title: Boilerplate (text) - Wikipedia, the free encyclopedia
10:46:41 <pumpkin-_> Ash0: those are different flavors of the same thing
10:46:43 <CosmicRay> BONUS_: don't forget to change your password ;-)
10:46:43 <nicknull> i see i have a function String -> String -> String -> Int -> Float, the input to them is x <- readFile. but isnt readFile a IO String? how can i pas an IO String to a pure function? (i am)
10:46:55 <sbahra> Ash0, it's a different paradigm
10:46:58 <CosmicRay> pumpkin-_: them's fighting words ;-)
10:47:00 <BONUS_> yeah, will do!
10:47:01 <pumpkin-_> lol
10:47:02 <sbahra> Ash0, you need to forget that you know how to program
10:47:11 <sbahra> Ash0, and approach Haskell as a complete newbie
10:47:20 <jeffz> nicknull: check what the type of x is.
10:47:20 <pumpkin-_> CosmicRay: is it standard to make people paranoid about their pastes around here btw? :P
10:47:29 <Cale> nicknull: x <- readFile "foo"  means to run  readFile "foo"  and call its result x
10:47:55 <schme_> sbahra: Oh.
10:48:00 <CosmicRay> pumpkin-_: heh.  well he *did* reveal his password.  I'm just being a good citizen by pointing that out before somebody else (there *are* 498 people in here) uses it for nefarious purposes
10:48:05 <schme_> sbahra: Ya that's stupid. One stays away from that.
10:48:06 <pumpkin-_> oh lol
10:48:09 <Cale> nicknull: (Of course, this is in the middle of a do-block, so it's part of defining what another IO action does.)
10:48:10 <Ash0> i know its different. all languages are different ... or else they wouldnt exist.
10:48:17 <pumpkin-_> Ash0: some are very different
10:48:25 <pumpkin-_> cause I pasted something once and someone claimed my password was in it
10:48:26 <pumpkin-_> but it wasn't
10:48:31 <pumpkin-_> so I figured it was a standard joke :P
10:48:34 <CosmicRay> pumpkin-_: heh
10:48:53 <pa-ching> I'm curious if anyone knows of resources about optimizing the internal representation of Haskell's ADTs
10:49:05 <CosmicRay> pumpkin: thank you, that is much more nickcomplete-friendly ;-)
10:49:20 <pjdelport> Ash0: there are languages with different syntaxes / runtimes (e.g. Python/Ruby/Perl), and then entire different paradigms (Haskell, Forth, APL, Prolog, ...)
10:49:23 <pumpkin> yeah, sorry... my connection was being weird before and I ended up with all sorts of weird suffixes
10:49:24 <pa-ching> i.e. Maybe optimized to a perhaps-null pointer rather than a discriminated union
10:49:25 <CosmicRay> also I am making a note to never go on a roller coaster with BONUS_
10:49:26 <lispy> pa-ching: as a compiler or as a programmer?
10:49:35 <pa-ching> A compiler
10:49:37 <Ash0> thanks pj 8-)
10:49:51 <hugo__> hey guys
10:50:02 <BONUS_> haha
10:50:04 <CosmicRay> pumpkin: don't worry, we'll just filter isAlpha your nick from now on.
10:50:09 <pumpkin> yay
10:50:10 <lispy> pa-ching: I thought Simon Peyton-Jones and Simon Marlow both have published on this subject
10:50:11 <BONUS_> i often gfet sick and vomit on them
10:50:16 <hugo__> since i'm in desperate need of attention, i have written a small "kind of tutorial" for parsec and curl on my blog
10:50:17 <vixey> pa-ching: totally unrelated to haskell and your question too but _Inductive families need not store their indices_ in a good read
10:50:19 <hugo__> check it out: http://planaltodigital.blogspot.com/
10:50:20 <lambdabot> Title: Planalto Digital
10:50:21 <CosmicRay> BONUS_: that is not the comment I was thinking of ;-)
10:50:23 <pa-ching> lispy: Cool, thanks :)
10:50:29 <BONUS_> oh that
10:50:29 <BONUS_> lol
10:50:30 <pjdelport> Ash0: so the question is about how different various languages are
10:50:32 <hugo__> btw, blogger sucks for code :/
10:50:35 <Ash0> well atleast come next friday. i wont have to use the word 'haskell' again :P
10:50:40 <pa-ching> lispy: haven't been able to figure out good search terms for it so yeah, I'll try taht
10:50:42 <sbahra> hugo__, cool
10:50:46 <pumpkin> Ash0: lol, "yay"
10:50:50 <CosmicRay> Ash0: come next friday, you *GET* to use Haskell again!
10:50:52 <Ash0> nah pj, it was a haskell coding question ... it just got transformed :P
10:51:04 <CosmicRay> Ash0: funny how that happens here
10:51:05 <lispy> pa-ching: but, I could be off a bit.  I know they have written numerous papers on how to make GHC efficient.  Surely they will say something you find interesting.
10:51:22 <pa-ching> Ohnoes dependent types!!!1
10:51:32 <Ash0> infact. ima burn some haskell books once this project is handed in!
10:51:45 <CosmicRay> Ash0: please by mine so you can burn it
10:51:53 <pumpkin> I'd expect haskell and other functional languages would be easier for an optimizer to work with?
10:51:59 <pa-ching> "show how to use properties of elimination rules to elide constructor arguments and tags" yeah that's what I'm after
10:52:07 <pumpkin> CosmicRay: you wrote a book?
10:52:14 <schme_> formlets is just for building forms?
10:52:23 <schme_> I was hoping for a solid webframework here.
10:52:25 <CosmicRay> pumpkin: realworldhaskell.org is my most recent project (with bos and dons)
10:52:30 <pumpkin> oh cool
10:52:33 <pumpkin> was reading that earlier :P
10:52:36 <CosmicRay> schme_: happs, hsp
10:52:55 <CosmicRay> schme_: wash
10:53:08 <CosmicRay> pumpkin: <burns> excellent </burns>
10:53:22 <pumpkin> lol
10:53:32 <Cale> Ash0: Is there anything in particular you're having trouble with?
10:54:01 <lispy> Prof. Cale is here, yay! :)
10:54:18 <BONUS_> CosmicRay: you're john goerzen?
10:54:21 <igel> CosmicRay: amazon has delivery problems... i ordered a copy in august and i'll get it in december :]
10:54:24 <CosmicRay> BONUS_: indeed I am
10:54:25 * BONUS_ is starstruck
10:54:26 <Ash0> The problem is, I learn through memory. So come an exam. I don't 'know' and answer, i 'remember' an answer.
10:54:30 <CosmicRay> igel: heh
10:54:34 <pumpkin> :/
10:54:48 <Cale> Ash0: I mean with regard to Haskell specifically ;)
10:54:53 <Ash0> so i 'remember' the codes for most of my problem, but i cant put them together to make a working program
10:54:57 <CosmicRay> BONUS_: hey, I'm nobody.  I don't even have a wikipedia page. ;-)
10:54:58 <Ash0> yeah i was getting there :P
10:55:02 <sbahra> Cale, he wants you to write code for him :)
10:55:12 <Ash0> i dont want my code writen for me
10:55:21 <Ash0> i want the code i have putting together/fixing
10:55:24 <BONUS_> haha no. i *love* RWH
10:55:34 <BONUS_> gonna buy the crap out of that book
10:55:34 <CosmicRay> BONUS_: I'm glad to hear that!
10:55:43 <CosmicRay> BONUS_: I'm even happier to hear that ;-)
10:56:07 <Cale> Ash0: I'd be happy to try to explain how things work, if you're having trouble with something. Probably what is most important for getting a handle on how the language works is just to play around with it a whole lot though.
10:56:22 <CosmicRay> igel: we're in QC1 now, which means it's page layout quality check phase
10:56:22 <pumpkin> Ash0: ghci is manna from the heavens
10:56:31 <nicknull> I want to read a file of words and do "words" so i get a list of all words. i then want to fold over that list accumulating a Data.Map. now this is trivial in let's say Python. but how the f*** do i do in haskell? if member x w_map then insertwith else singleton?
10:56:34 <pumpkin> most of what I've learned so far was just playing around on the interactive console
10:56:59 <Cale> nicknull: What are the values of the Map?
10:57:00 <CosmicRay> Ash0: how about you go to hpaste.org, post the code you have so far and the problem you're having with it?
10:57:01 <lispy> nicknull: readFile
10:57:04 <Cale> nicknull: Number of occurrences?
10:57:08 <Ash0> All i need (for now) is for the user of my program to enter a message (main = do putstrline, getline, etc... - not exactly right i know)
10:57:11 <nicknull> cale: word: occcurances
10:57:51 <Ash0> is isAlpha the same as...
10:58:04 <Ash0> isDigit :: Char -> Bool
10:58:05 <Ash0> isDigit c = (c>='0')&&(c<='9')
10:58:09 <Cale> do xs <- readFile "myFile"; let occurrences = Map.fromListWith (+) (zip (words xs) (repeat 1))
10:58:10 <pumpkin> nope
10:58:23 <pumpkin> http://www.zvon.org/other/haskell/Outputchar/isAlpha_f.html
10:58:25 <lambdabot> Title: Haskell : isAlpha
10:58:26 <Cale> (you can probably finish the do-block from there)
10:58:34 <pumpkin> @src isAlpha
10:58:34 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
10:58:40 <pumpkin> oh guess not :P
10:58:45 <nicknull> cale: and purely?, no do...
10:58:57 <Cale> nicknull: You can't read a file from a pure function
10:59:15 <lispy> nicknull: the trick is to call pure code from inside the monad
10:59:19 <Cale> nicknull: If you want a pure function  String -> Map String Integer, steal the code from that let.
10:59:22 <Ash0> so isalpha outputs a boolean ?
10:59:25 <lispy> nicknull: occurences is a pure value, for example
10:59:29 <Cale> > isAlpha 'C'
10:59:31 <lambdabot>   True
10:59:36 <Cale> > isAlpha '9'
10:59:37 <lambdabot>   False
10:59:47 <Cale> Ash0: yep :)
10:59:53 <Cale> :t isAlpha
10:59:54 <lambdabot> Char -> Bool
11:00:33 <Ash0> is it possible to do something like an isalpha, but not output a boolean
11:00:43 <Ash0> so output a specific word, or go somewhere else in the program
11:00:44 <pumpkin> sure, what do you want to output?
11:00:44 <pumpkin> :P
11:00:48 <Cale> Ash0: what do you want to output instead?
11:00:52 <Cale> ah
11:00:57 <Cale> use 'if'
11:01:15 <Cale> > if isAlpha 'C' then "yes, C is a letter" else "uh..."
11:01:16 <lambdabot>   "yes, C is a letter"
11:01:19 <Ash0> i gotta check if a character is a number/letter ... so instead of true, it'd move onto the next char.
11:01:42 <BONUS_> playing with twidge now, it owns
11:02:13 <Ash0> so i have 'hello5' ... i need to check H, if H is a number, output number, if not, move onto E
11:02:24 <pumpkin> Ash0: from a high level perspective, what are you trying to do?
11:02:43 <Cale> > dropWhile (not . isAlpha) "hello5"
11:02:45 <lambdabot>   "hello5"
11:03:03 <Cale> > dropWhile (not . isDigit) "hello5"
11:03:04 <lambdabot>   "5"
11:03:22 <pumpkin> isAlpha looks for alphanumeric?
11:03:26 <Cale> > dropWhile (isAlpha) "hello5"
11:03:27 <lambdabot>   "5"
11:03:29 <CosmicRay> BONUS_: glad you like it
11:03:30 <Beelsebob> no, it looks for alph
11:03:34 <pumpkin> ah ok
11:03:38 <Cale> alphabetic
11:03:48 <Ash0> is it possible to say, if output is number, do something else?
11:03:48 <pumpkin> yeah, that's what I thought, but the "hello5" confused me
11:03:55 <pumpkin> sure :P
11:04:06 <Ash0> theres probably a much easier way of doing what i want, but aslong as it works. i'll just do it 100s of baby steps :P
11:04:06 <Beelsebob> > dropWhile isAlphaNum "hello5"
11:04:07 <Cale> Yeah, it dropped nothing because the first letter is alpha...
11:04:07 <lambdabot>   ""
11:04:20 <pumpkin> Cale: ah I see
11:04:22 <Cale> Ash0: Well, you could write this recursively...
11:04:58 <Ash0> overall i'd need hello5 changing into 'hellofive' ... but im guessing the 5 has to be 'found' first.
11:05:00 <nicknull> how do i sort a lis like: [("hello",1),("there",2)] ?
11:05:03 <Cale> Ash0: Something like dropLetters [] = []; dropLetters (x:xs) = if isAlpha x then dropLetters xs else (x:xs)
11:05:25 <pumpkin> Ash0: you'd probably want map for that
11:05:25 <Ash0> i dont need to get rid of the letters, just identify a letter from a number.
11:05:32 <Beelsebob> map (if' <$> isDigit <*> const 'D' <*> id) "hello 56 digits"
11:05:36 <Beelsebob> > map (if' <$> isDigit <*> const 'D' <*> id) "hello 56 digits"
11:05:37 <lambdabot>   Not in scope: `if''
11:05:38 <pumpkin> Ash0: or are you looking for a sequence of digits?
11:05:39 <Beelsebob> bah
11:05:45 <Cale> Ash0: ah, okay, that's a little different
11:05:53 <pumpkin> should "hello52" give "hellofivetwo" or "hellofiftytwo"?
11:05:54 <Beelsebob> > let if' x y z = if x then y else z in map (if' <$> isDigit <*> const 'D' <*> id) "hello 56 digits"
11:05:55 <lambdabot>   "hello DD digits"
11:06:04 <Ash0> hellofivetwo
11:06:11 <pumpkin> then map will do it easily
11:06:11 <nicknull> and is the re a function that makes a map a list of tuples?
11:06:19 <Cale> concatMap ;)
11:06:36 <pumpkin> aha, didn't even know that one :P I was thinking of mapping and flattening :P
11:06:40 <Ash0> so i can forget about isalpha ?
11:06:45 <Beelsebob> > let if' x y z = if x then y else z in concatMap (if' <$> isDigit <*> const "Digit" <*> (:[])) "hello 56 digits"
11:06:47 <lambdabot>   "hello DigitDigit digits"
11:07:26 <Beelsebob> > let if' x y z = if x then y else z; unDigit 5 = "five"; unDigit 2 = "two" in concatMap (if' <$> isDigit <*> unDigit <*> (:[])) "hello 56 digits"
11:07:27 <lambdabot>       No instance for (Num Char)
11:07:27 <lambdabot>        arising from a use of `unDigit' at <i...
11:07:37 <Beelsebob> > let if' x y z = if x then y else z; unDigit '5' = "five"; unDigit '2' = "two" in concatMap (if' <$> isDigit <*> unDigit <*> (:[])) "hello 56 digits"
11:07:38 <lambdabot>   "hello five* Exception: /tmp/134600578325148059:69:84-124: Non-exhaustive p...
11:07:46 <jeffz> nicknull: do you know where to find the library documentation?
11:07:47 <Beelsebob> oh wups, wrong patterns
11:07:52 <Beelsebob> > let if' x y z = if x then y else z; unDigit '5' = "five"; unDigit '6' = "six" in concatMap (if' <$> isDigit <*> unDigit <*> (:[])) "hello 56 digits"
11:07:53 <lambdabot>   "hello fivesix digits"
11:08:02 <nicknull> http://hpaste.org/11230 , how can that be allowed? shouldnt classify be impure?
11:08:15 <jeffz> nicknull: http://www.haskell.org/ghc/docs/latest/html/libraries/ - browse to Data.Map
11:08:16 <lambdabot> Title: Haskell Hierarchical Libraries
11:08:20 <nicknull> or wait
11:08:22 <Cale> Ash0: My recommendation for the overall way to write this is to make a list of the replacements: [('0',"zero"),...,('9',"nine")]
11:08:31 <Beelsebob> indeed
11:08:31 <pumpkin> Beelsebob: now you did his homework for him! :P
11:08:41 <nicknull> i can use a String-fucntion tha tis pure on impure data
11:09:02 <nicknull> im rewriting ^^ using a Map
11:09:03 <Beelsebob> nicknull: liftM
11:09:14 <nicknull> Beelsebob: foe aht?
11:09:16 <Ash0> yeah thats what i did to begin with, if char is 1, output one, if 2, two, etc...
11:09:20 <Ash0> but i couldnt get it working
11:09:21 <Beelsebob> or bind the impure data to a value
11:09:34 <Cale> Ash0: Then write a function  expand :: Char -> String  which looks in that list to see if there's something to expand it into. If not, it should just return the one-letter string with just that character
11:09:40 <pumpkin> Ash0: are you supposed to explicitly recurse? I'd imagine if it's for a class, you might
11:09:44 <Ash0> only switched from java to haskell couple of weeks ago. so still a novice.
11:09:51 <Cale> Ash0: Okay...
11:09:54 <Cale> hpaste.org/new
11:10:10 <Cale> Put what you have on there, and we'll see what might be wrong with it.
11:12:04 <Cale> or did you already put something there?
11:12:09 <Ash0> i'll put it together, its in different notepads ... 2 secs.
11:12:16 <pumpkin> :o
11:14:13 <Ash0> http://hpaste.org/11231
11:14:21 <Ash0> thats what i had to begin with, but the if statements wrong
11:14:30 <Cale> yes, it's missing an 'else'
11:14:30 <Ash0> which is the question im asking ^
11:14:39 <Ash0> doesnt else if count ?
11:14:51 <Ash0> oooh i see
11:14:54 <Cale> the if after the last else is missing its else
11:14:56 <Ash0> i'll just put else 'error'
11:15:21 <Cale> Actually, there's a better option for what you're trying to do.
11:15:54 <Cale> If you made this function Char -> String, then you could make a single-character string from the character if it wasn't a digit.
11:16:17 <Cale> That would probably fit in best with the rest of the idea of the program you're trying to write.
11:16:31 <Cale> Also, do you know about guards?
11:16:35 <Ash0> nope
11:16:40 <Cale> Or pattern matching?
11:16:46 <Ash0> once its a string, how could u get the numbers out tho ?
11:17:24 <Cale> Well, you're not really interested in knowing what number it is. You're just replacing certain characters with certain strings, no?
11:17:35 <Ash0> yeah thats right
11:17:56 <Ash0> but wouldnt u still need to pick the number out, so u can change it
11:18:32 <C-Keen> Ash0: what if n is bigger than 9 or negative?
11:18:41 <pumpkin> it's a single digit
11:18:54 <Ash0> if its 23, it'll output twothree
11:18:59 <Ash0> so bigger then 9 doesnt matter
11:19:17 <Ash0> and its a message, so like message 1, message 2 ... it wouldnt become negative
11:19:23 <C-Keen> pumpkin: oh I missed that convention
11:19:33 <Ash0> i've just else 'error'ed, incase a negative is put in
11:19:33 <Cale> http://hpaste.org/11231#a1
11:19:50 <Cale> Ash0: have a look at that way of writing it.
11:19:51 <pumpkin> Ash0: what if it's â…«?
11:19:56 <Cale> heh
11:20:03 <Ash0> it'll error :P
11:20:37 <nicknull> how do i sort a list of tuples ont he second key? like in python key=lambda x: x[1]
11:20:48 <Cale> sortBy (comparing snd)
11:21:09 <Cale> (sortBy is in Data.List, comparing is in Data.Ord)
11:21:14 <Ash0> what does the -> [x] do to end the case, output the original message?
11:21:26 <Cale> Ash0: It puts the character x into a list of length 1
11:21:30 <Cale> (which makes it into a string)
11:21:31 <C-Keen> Ash0: turning whatever char into a string
11:21:41 <hugo__> allright
11:21:42 <Cale> So, for example, 'a'  becomes "a"
11:21:50 <pumpkin> omg more quotes
11:21:51 <Ash0> and the underscore before it? ... never seen that before
11:21:57 <nicknull> what si the diff between data.list and list?
11:22:01 <hugo__> just finished reviewing the text of the curl/parsec tut
11:22:01 <Cale> That's a wildcard patter
11:22:05 <Cale> pattern*
11:22:07 <C-Keen> Ash0: that's a wildcard for anything
11:22:11 <Cale> It matches any value at all.
11:22:11 <hugo__> please leave comments
11:22:18 <hugo__> thanks :)
11:22:29 <Ash0> oh ok. im used to wildcard being a *
11:22:31 <shemale_fun> is haskell the next generation of ml?
11:22:40 <shemale_fun> how is ml worse/better?
11:22:49 <nicknull> why arent more common functions in the prelude/already in haskell withou having to import, i have like 3-4 imports in every module
11:23:01 <hugo__> shemale_fun: you can decide that by yourself, learn both, and pick the one you most like :)
11:23:03 <vixey> shemale_fun: haskell IS an ML imo, most disagree with me on that though
11:23:17 <shemale_fun> heh
11:23:21 <hugo__> shemale_fun: you can read http://planaltodigital.blogspot.com/ as an intro :)
11:23:21 <lambdabot> Title: Planalto Digital
11:23:25 <shemale_fun> i heard lisp and ml are nice
11:23:26 <hugo__> (heheh im such a spammer)
11:23:28 <nicknull> shemale_fun : kind of, you can try Ocaml as well, I find haskell to be more exciting
11:23:34 <pumpkin> I hera shemales are fun
11:23:34 <shemale_fun> ocaml?
11:23:37 <pumpkin> hear
11:23:42 <shemale_fun> bigtime
11:23:44 <Cale> nicknull: From a certain perspective, we have too much in the prelude: things in the prelude are hard to change.
11:23:47 <shemale_fun> girls are so uptight
11:23:55 <nicknull> lisp has some nice unique features(macros) and is less hardcore han haskell
11:23:59 <Ash0> do i have to define what messageNumber is before the case? ... im getting an error on the 'messageNumber =' line.
11:24:06 <shemale_fun> what about smalltalk?
11:24:20 <Cale> Ash0: messageNumber x =
11:24:39 <Cale> Ash0: Or is that not the problem?
11:24:41 <Ash0> yeah i have that. mistype* ... still error
11:24:45 <jeffz> shemale_fun: what about smalltalk? this is #haskell
11:25:14 <shemale_fun> I dotn knwo what to learn
11:25:18 <hugo__> hey shemale_fun, enough smalltalk :D
11:25:23 <shemale_fun> har har
11:25:23 <Cale> Ash0: you must have copied something incorrectly...
11:25:31 <nicknull> shemale_fun: it is an OO-language and one of the first, it is quite unique, the interface is kind of liek its own OS(try squeak). it also has a metasystem in some wya i thinkl
11:25:33 <Cale> (It works for me)
11:25:36 <rwbarton> Ash0: indentation matters
11:25:41 <vixey> ?where LYAH
11:25:41 <lambdabot> www.learnyouahaskell.com
11:25:43 <Ash0> i think the problem is i havnt got anything before the case, other then inputting the message
11:25:53 <vixey> shemale_fun: ^ read this it's kind of the forth book
11:25:57 <Cale> Ash0: Uh, this is a function declaration.
11:26:12 <rwbarton> Ash0: Your indentation in main in the hpaste is wrong, is it the same in what you're trying to compile?
11:26:26 <Cale> oh, yes, there is that...
11:26:43 <Ash0> ive took everyone out, except the input, and case
11:26:51 <Choko> shemale_fun: you bring all these evil shemale pictures into my mind :(
11:26:59 <Cale> also, in the thing you pasted, you have a line which reads:  filter (not . isUpper) message  which is an expression, and not a declaration, so it doesn't belong at the top-level of a module.
11:27:14 <Ash0> ive taken that out
11:27:17 <Cale> okay
11:27:25 <Cale> Can you hpaste your whole file?
11:27:28 <shemale_fun> bikini pics?
11:27:35 <Ash0> all i have in, is the first 3 lines, and ur case
11:27:44 <Cale> shemale_fun: If you could change your nick, that would be great :P
11:27:53 <pumpkin> Ash0: http://en.wikipedia.org/wiki/Ur?
11:28:02 <pumpkin> Cale: feeling the temptation too, eh? :P
11:28:13 <Cale> pumpkin: To kickban?
11:28:23 <pumpkin> um
11:28:24 <pumpkin> sure
11:28:37 <pumpkin> :)
11:28:38 <Cale> Ash0: indent the putStrLn and the message <- line
11:29:10 <Cale> Ash0: you want them to go inside the do-block, not be on the same level as main =
11:29:14 <Ash0> ERROR file:.\work.hs:5 - Last generator in do {...} must be an expression
11:29:14 <beer_fun> there
11:29:35 <Cale> Ash0: ah, yes, that's true
11:29:46 <nicknull> and how do i sort in descending order so i dont have to reverse in the end
11:29:57 <Cale> Ash0: Now your problem is that the last line of that do-block has a  <-  in it.
11:30:02 <nicknull> sortBy (comparing snd) (>) ?
11:30:17 <Cale> Ash0: you could do something like   print message   as the last line.
11:30:41 <Cale> nicknull: sortBy (flip (comparing snd))
11:30:56 <Ash0> the overall things an encryption program ... printing the message wouldnt go down well :P
11:31:09 <Cale> Ash0: That's okay, you'll change it later.
11:31:26 <Ash0> so change the <- line to print message ?
11:31:27 <Cale> Ash0: you could also just stick  return ()  there
11:31:39 <Cale> no, I'm saying add it after, in the same do-block
11:32:08 <C-Keen> Cale: shouldn't one wrap the pure function into some IO monad for that instead of losing purity?
11:32:18 <Cale> C-Keen: For what?
11:32:56 <C-Keen> Cale: instead of directly adding printing to the message funciton in this example, have another "putmessage" function that does that
11:33:10 <Cale> C-Keen: uh, I'm talking about his 'main'
11:33:36 <Cale> C-Keen: Which currently ends in a binding, he needs to add something to the end of it for the compiler not to complain.
11:33:49 <Cale> (or remove the  "message <-" part
11:33:51 <Cale> )
11:33:53 <C-Keen> Cale: uh, of course you are right
11:34:09 <romildo> Is it possible (and if so, is it easy) to define a new widget type in gtk2hs?
11:34:22 <Cale> romildo: that would be something to ask dcoutts_ :)
11:34:34 <Cale> (let's hope he is around :)
11:34:35 <C-Keen> Cake: it is just that I have read about this practise a lot recently
11:34:45 <romildo> dcoutts_: are you around?
11:35:00 <Cale> C-Keen: You generally want to keep IO to the places where you are actually doing input and output.
11:35:17 <Deewiant> Haddock question: A imports B. B contains a reference 'like_this' which refers to something in A. Haddock doesn't make it into a link. Is it possible somehow?
11:35:30 <Cale> C-Keen: Sometimes the nature of your problem makes this tricky, but often laziness helps a good deal.
11:35:38 <rwbarton> romildo: I believe dcoutts_ has said here that it's possible and not too hard.  You might try checking the logs
11:36:36 <rwbarton> romildo: Though if your question is really "how do I ..." it's possible the logs won't help too much :)
11:37:48 <C-Keen> I got a different problem now. I want a data structure that represents a grammar, which is made of symbols which can be terminals or other symbols. I have data Symbol = Terminal a | Symbol; I am not sure about the data types I should use for constructing though (the arguments to the constructing functions).
11:38:19 <C-Keen> and type Grammar = [Symbol];
11:38:20 <Cale> C-Keen: I'm pretty sure you don't want Symbol to be a nullary constructor there.
11:38:32 <C-Keen> Cale: I know.
11:38:34 <Cale> (but maybe you do?)
11:38:35 <Cale> okay
11:38:55 <C-Keen> but I don't know what to use to make it not just for one type
11:39:37 <Cale> There are a couple of ways I can see going about this...
11:39:45 <Cale> These grammars are context free?
11:39:50 <C-Keen> yes
11:40:12 <Cale> Okay, so you might use a Data.Map from nonterminals to lists of symbols.
11:40:55 <rwbarton> Or to sets of lists of symbols, if you might have more than one possible production for a nonterminal
11:41:03 <Cale> ... right :)
11:41:20 <C-Keen> ho would you make up the nonterminals?
11:41:51 <Cale> I would probably define a type  data Symbol a = Term a | NonTerm a
11:42:05 <DuClare> What's the end-of-line marker hGetLine uses?
11:42:19 <Cale> DuClare: I would think it's whatever '\n' is on your platform.
11:42:35 <pastorn> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/vty <-- i'm trying to use this but when i call mkVty i always get a segfault
11:42:38 <lambdabot> Title: HackageDB: vty-3.1.2
11:42:53 <C-Keen> Cale: hm, maybe that has been my mistake. I always though that I would need to make the symbol definition somewhat recursive
11:43:31 <Cale> C-Keen: well, then you make lists of those, and lists are a recursive type
11:44:02 <Cale> Ash0: any luck getting things to compile?
11:44:03 <DuClare> Hmm.
11:44:07 <C-Keen> Cale: right
11:44:28 <nicknull> i ahve a Map, i do M.lookup key Map, then with the value i want sum += value
11:44:51 <nicknull> but i get a monad right?
11:45:02 <Cale> nicknull: I think you're thinking too imperatively.
11:45:07 <Cale> nicknull: What are you trying to compute?
11:45:28 <Cale> The sum of a bunch of things which you looked up?
11:45:34 <Cale> > sum [1,5,2,6,8]
11:45:35 <lambdabot>   22
11:45:39 <nicknull> no i get exception lookup error
11:45:42 <nicknull> yes
11:45:51 <nicknull> but i look them up ina Map
11:45:57 <nicknull> so i can get exception
11:46:03 <nicknull> or a number
11:46:25 <Cale> Uh, lookup :: (Ord k) => k -> Map k a -> Maybe a
11:46:27 <Cale> right?
11:46:47 <Cale> So you'll get a bunch of Maybe things -- do you want it to fail if anything is Nothing?
11:47:04 <Ash0> nah cale. its as if im writing an essay in chinese lol
11:47:17 <nicknull> yes
11:47:21 <Cale> Ash0: What tutorials have you tried to read?
11:47:22 <nicknull> but if the element isnt there
11:47:32 <nicknull> i get an exception, not a moand
11:47:34 <Cale> Ash0: and how far did you get?
11:47:40 <Saizan> nicknull: what do you want to do if the element is not there?
11:47:43 <Ash0> Well Ive been to all my Haskell lectures, and other students have managed it.
11:47:50 <nicknull> saizan: add 0
11:47:54 <Cale> nicknull: .oO(you never get a monad, a monad is a type constructor)
11:47:55 <nicknull> or do nothing
11:47:55 <Ash0> I havnt gotten anywhere tbh. I'll probs leave it till 2morro.
11:48:10 <Cale> nicknull: you shouldn't get an exception...
11:48:12 <Saizan> nicknull: fromMaybe 0 (lookup ...)
11:48:40 <Cale> Ash0: well, you might try BONUS's tutorial...
11:48:44 <Saizan> ?type Data.Map.lookup
11:48:45 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> M.Map k a -> m a
11:48:54 <Cale> @where LYAH
11:48:54 <lambdabot> www.learnyouahaskell.com
11:48:57 <Cale> hehe
11:49:09 <Cale> It's lighthearted and should be fun.
11:49:14 <nicknull> http://hpaste.org/11232
11:49:19 <Ash0> i'll have a look. thanks
11:49:36 <nicknull> *** Exception: user error (Data.Map.lookup: Key not found)
11:49:43 <Cale> nicknull: You're doing that the hard way.
11:49:48 <Cale> nicknull: ah
11:50:07 <Cale> nicknull: actually, I'm not sure how that manages to typecheck.
11:50:22 <Saizan> which Monad instance applies there?
11:50:30 <Cale> that's a good question ;)
11:51:00 <Cale> nicknull: split the problem up, so that you do no addition until you have a list of all the things you want to add up.
11:51:27 <nicknull> it does
11:51:30 <Cale> nicknull: That is, break the problem up into one of doing a bunch of lookups, and the already-solved problem of adding a list of numbers.
11:51:35 <nicknull> cale: whats the easy way then?
11:52:01 <nicknull> cale: well that would be slightly innefficient for huge datasets
11:52:07 <Cale> not really.
11:52:10 <nicknull> and i still dont know how to do
11:52:13 <Cale> Because of list fusion.
11:52:21 <nicknull> link?
11:52:32 <Cale> sum is a good list consumer, and map is a good list producer
11:52:41 <Cale> So no list gets built.
11:53:14 <Cale> I could link you to a research paper, or to the GHC sourcecode...
11:53:40 <Cale> But trust me, it's premature optimisation to worry about that anyway ;)
11:54:01 <Cale> How big are the lists of numbers going to be?
11:54:18 <Cale> If they're millions of elements or more, go with foldl' (+) 0
11:54:43 <Cale> But I think normal optimisations will generally do a fair job of that now anyway.
11:54:49 <nicknull> ok
11:54:51 <pumpkin> how does foldl' differ from foldl?
11:54:59 <Heffalump> strict application
11:54:59 <nicknull> strict
11:55:03 <Cale> pumpkin: It's strict in the accumulating parameter
11:55:17 <vixey> @src foldl'
11:55:17 <nicknull> so how do i do the donkey lookup?
11:55:17 <lambdabot> foldl' f a []     = a
11:55:17 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
11:55:19 <vixey> @src foldl
11:55:19 <lambdabot> foldl f z []     = z
11:55:19 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
11:55:29 <nicknull> i need to use foldl by default
11:55:46 <Cale> Well, sum will usually do.
11:55:48 <nicknull> i always writ emy own recursive function with an accumulator
11:55:54 <Cale> ah
11:56:06 <Cale> Yeah, recursion is something to be avoided.
11:56:22 <BONUS_> yeah, explicit recursion
11:56:42 <Cale> If you're writing something which is recursive, it's usually best to stop and think about whether you can write it non-recursively in terms of things you already have.
11:56:46 <C-Keen> hm, how can I add a show function to my datatype?
11:56:53 <Cale> C-Keen: deriving (Show)
11:57:22 <Cale> C-Keen: Or you can write an instance of the Show class by hand, if you really want to.
11:57:33 <Cale> instance Show MyType where
11:57:38 <Cale>   show x = ...
11:57:43 <C-Keen> ah ok
11:58:18 <beer_fun> can haskell be as ncie for scripting as python?
11:58:18 <Cale> nicknull: So, about doing these lookups -- what value do you want to contribute to the sum when the thing isn't in the map?
11:58:25 <Cale> beer_fun: I think so.
11:58:36 <Cale> beer_fun: The questions you're asking are a matter of taste though.
11:58:41 <vixey> I think it is vastly better
11:58:44 <vixey> I am extremly biased
11:58:45 <Cale> beer_fun: It's best just to try it and see.
11:59:15 <nicknull> wait its not a fold
11:59:18 <nicknull> cale: 0
11:59:20 <camio> beer_fun: What kind of scripting are you referring to?
11:59:20 <Cale> nicknull: okay
11:59:47 <beer_fun> web
11:59:50 <Cale> nicknull: sum (map (\k -> Map.findWithDefault 0 k myMap) xs)
11:59:51 <beer_fun> sysadmin
11:59:55 <beer_fun> stuff liek that
12:00:01 <nicknull> hmm i can fold over a Map i see
12:00:10 <Cale> nicknull: yeah, you can do that too.
12:00:12 <nicknull> wait it is a foldl
12:00:30 <nicknull> ahah fold is a bit confusing, takes some times getting used to thinking about it
12:00:36 <camio> beer_fun: Like moving log files around and backups?
12:00:44 <beer_fun> yeah and dynamic website
12:00:47 <Cale> nicknull: Right folds are nicer to think about than left ones.
12:01:10 <nicknull> countSet set word_map = L.foldl' (\x y -> x + (M.lookup y word_map)) 0 set
12:01:10 <Cale> nicknull: foldr f z xs  just replaces each (:) in the list with f, and the [] at the end with z
12:01:21 <Cale> oh, don't do that!
12:01:25 <nicknull> lol
12:01:31 <Cale> nicknull: Break the problem up into parts first!
12:01:50 <Cale> nicknull: Lists are your loops!
12:01:50 <camio> beer_fun: For running programs and moving files around, you may find that haskell works. For dynamic web stuff, the python libs are much more mature in my experience.
12:02:11 <camio> beer_fun: But doing it in haskell is likely to be a lot more fun.
12:02:32 <camio> beer_fun: Well, I mean doing it in haskell and taking a functional approach.
12:02:58 <camio> beer_fun: Taking an imperative approach, python would be much better suited.
12:03:02 <Cale> countSet set wordMap = sum [Map.findWithDefault 0 k wordMap | k <- set]
12:03:14 <Cale> nicknull: look at how much easier that is to read!
12:03:28 <Cale> :)
12:04:05 <Cale> If you mix the addition in with the looking up, then it gets hard to think about what's going on. Just rely on laziness to do that for you.
12:04:35 <Cale> The list of elements is only going to get built as it's demanded by sum anyway.
12:04:46 <Cale> (so even without fusion, it'll never all be in memory at once)
12:05:25 <nicknull> yes, very nice
12:05:54 <dons> ?users
12:05:54 <lambdabot> Maximum users seen in #haskell: 518, currently: 502 (96.9%), active: 28 (5.6%)
12:06:04 <camio> beer_fun: You may want to check this out -> http://cgi.cse.unsw.edu.au/~dons/blog/2007/03/10#programmable-semicolons
12:06:06 <lambdabot> Title: Haskell hacking, http://tinyurl.com/ywdjsr
12:09:21 <lispy> oh, that's first 500+ time I've been around to see
12:09:25 <lispy> Way to go everyone!
12:10:25 <lament> NOBODY LEAVE THE CHANNEL!
12:13:54 <mopped> Is there a way to map a function to a list like python's reduce? ie: operator.subtract ? [1..3] would return (1-2)-3 = -4
12:14:18 <Cale> mopped: foldl
12:14:25 <rwbarton> > foldl1 f [x,y,z]
12:14:26 <lambdabot>   f (f x y) z
12:14:30 <marko> I'm looking for documentation/examples/tutorials on Takusen... Anyboby have any pointers?
12:14:35 <Cale> > foldl1 (-) [1..3]
12:14:36 <lambdabot>   -4
12:14:40 <mopped> thanks
12:14:54 <Cale> mopped: The more natural one to use is usually foldr
12:15:11 <mopped> that would be (3-2)-1?
12:15:17 <Cale> no
12:15:23 <Cale> 1 - (2 - 3)
12:15:35 <Cale> (of course, for - that's a little odd)
12:15:49 <Cale> foldr f z can be viewed as replacing each (:) with f and the [] at the end of the list with z
12:16:11 <Cale> > foldr (++) [] [[1,2,3],[4,5],[6,7,8]]
12:16:13 <lambdabot>   [1,2,3,4,5,6,7,8]
12:16:30 <Cale> > foldr (+) 0 [1,2,3]
12:16:32 <lambdabot>   6
12:16:43 <Cale> > foldr (:) [] [1,2,3]
12:16:44 <lambdabot>   [1,2,3]
12:16:53 <Cale> > foldr ((:) . (*2)) [] [1,2,3]
12:16:55 <lambdabot>   [2,4,6]
12:17:02 <Cale> (which is the same as map (*2))
12:17:12 <Cale> > foldr (:) [4,5] [1,2,3]
12:17:14 <lambdabot>   [1,2,3,4,5]
12:17:41 <mopped> should you always use prefix functions?
12:17:50 <Cale> hm?
12:18:00 <mopped> as in, you're using (+) instead of just + :P
12:18:10 <Cale> oh, in order to pass it as a parameter, yes
12:18:30 <Cale> Otherwise it would be  (foldr) + (0 [1,2,3])
12:18:43 <Cale> which is a type error, to say the least ;)
12:18:47 <mopped> aha
12:18:55 <rwbarton> :t (foldr) + (0 [1,2,3])
12:18:57 <lambdabot>     Ambiguous type variable `t' in the constraint:
12:18:57 <lambdabot>       `Num t' arising from the literal `1' at <interactive>:1:14
12:18:57 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
12:19:10 <vixey> :t +
12:19:12 <lambdabot> parse error on input `+'
12:19:14 <vixey> :t (+)
12:19:15 <lambdabot> forall a. (Num a) => a -> a -> a
12:20:18 <jeffersonheard> If a C function requires me to pass in a pointer to a pointer, how do I marshal such a thing in Haskell?
12:20:19 <nicknull> so if i first filter over a list and then map over it laziness will solve the performance for me? i shouldnt try to stick them into one?
12:20:32 <Cale> nicknull: do them separately
12:20:33 <jeffersonheard> map . filter $ list
12:20:57 <Cale> nicknull: You should never sacrifice modularity for performance before you know how the code performs.
12:21:27 <jeffersonheard> nicknull: the general idea is that function composition + laziness will handle it, yes
12:21:52 <jeffersonheard> lists aren't generally head-strict, so evaluating a function on the head of the list won't cause it all to be evaluated at once
12:22:11 <jeffersonheard> so in essence, you get function composition over single elements of a time.
12:22:24 <Cale> Perhaps we should evaluate something like that by hand, so you get a sense of how it proceeds.
12:22:34 <Cale> Let's say...
12:23:03 <Cale> map (*2) (filter (< 10) [5,30,6,754])
12:23:13 <Cale> So, first thing to evaluate is map
12:23:18 <Cale> @src map
12:23:19 <lambdabot> map _ []     = []
12:23:19 <lambdabot> map f (x:xs) = f x : map f xs
12:23:21 <SamB> the reason not to sacrifice modularity for performance in ignorance is because you will probably end up with neither
12:23:45 <Cale> It pattern matches on its second argument, so we need to know if (filter (< 10) [5,30,6,754]) is [] or (x:xs)
12:23:58 <Cale> @src filter
12:23:59 <lambdabot> filter _ []     = []
12:23:59 <lambdabot> filter p (x:xs)
12:23:59 <lambdabot>     | p x       = x : filter p xs
12:23:59 <lambdabot>     | otherwise = filter p xs
12:24:06 <sjanssen> jeffersonheard: Ptr (Ptr Foo)
12:24:16 <sjanssen> jeffersonheard: where Foo is the pointed-to type
12:24:42 <Cale> Well, [5,30,6,754] matches (x:xs) there just fine. Moreover (5 < 10) succeeds, so we get that it's (5 : filter (<10) [30,6,754])
12:25:02 <C-Keen> http://hpaste.org/11233 <- what does ghc complain about?
12:25:02 <Cale> and so x = 5, xs = filter (<10) [30,6,754]  in the call to map
12:25:10 <Cale> and we get:
12:25:27 <Cale> (5*2) : map (*2) (filter (<10) [30,6,754])
12:25:49 <Cale> nicknull: did you follow that?
12:25:52 <rwbarton> C-Keen: You can't append to a list using :
12:25:56 <Cale> I should probably use hpaste :)
12:26:18 <C-Keen> rwbarton: I want to create a new list
12:26:55 <rwbarton> C-Keen: You want something like this right?
12:26:58 <rwbarton> > [1,2,3] : 4
12:26:59 <lambdabot>       No instance for (Num [[t]])
12:26:59 <lambdabot>        arising from the literal `4' at <int...
12:27:00 <C-Keen> rwbarton: what does ':' do then
12:27:03 <rwbarton> > [1,2,3] ++ [4]
12:27:05 <lambdabot>   [1,2,3,4]
12:27:06 <rwbarton> > 4 : [1,2,3]
12:27:07 <lambdabot>   [4,1,2,3]
12:27:11 <rwbarton> :t (;)
12:27:12 <lambdabot> parse error on input `;'
12:27:13 <rwbarton> :t (:)
12:27:14 <lambdabot> forall a. a -> [a] -> [a]
12:27:22 <rwbarton> (:) is what lists are made out of
12:27:31 <C-Keen> rwbarton: oh!
12:27:32 <rwbarton> [1,2,3] = 1 : (2 : (3 : []))
12:27:33 <Saizan> dreams?
12:27:39 <jeffersonheard> sjanssen: okay...  I still have a slight problem.  in C, normally, I would just declare an OGRGeometryH *, and not assign anything to it, then call CreateFromWkb() with a pointer to that handle.
12:27:41 <idnar> (:) prepends an element to a list
12:28:28 <jeffersonheard> sjanssen: but in Haskell, I don't see a way to declare something exists and force it to exist in time to make a pointer out of it and pass it to the function
12:28:58 <sjanssen> jeffersonheard: you'll need some functions from the Foreign.* hierarchy
12:29:45 <jeffersonheard> like...  newForeignPtr?
12:30:04 <sjanssen> jeffersonheard: yeah, or malloc, or one of the alloca functions
12:30:25 <jeffersonheard> What's the difference between ForeignPtr and Ptr?
12:30:56 <sjanssen> each of them have different garbage collection behavior (Ptr is not GCed automatically, ForeignPtr is GCed, alloca will free the pointer when the function terminates)
12:31:46 <jeffersonheard> sounds like what I want is a StablePtr and then cast to and from Ptr, then
12:32:05 <Cale> nicknull: http://hpaste.org/11234
12:32:13 <C-Keen> rwbarton: http://hpaste.org/11233#a1 this makes it compile but it looks awkward
12:32:15 <sjanssen> jeffersonheard: I think you mean ForeignPtr
12:32:16 <jeffersonheard> C will allocate the memory for me, but I need to pass it an extant pointer for it to point me
12:32:41 <sjanssen> I think you want alloca
12:33:10 <sjanssen> jeffersonheard: are you supposed to free the allocated memory yourself?
12:33:11 <jeffersonheard> k
12:33:28 <jeffersonheard> no, I would call destroyGeometry to free it
12:33:38 <jeffersonheard> so yes, but not via "free"
12:33:52 <sjanssen> ah
12:34:06 <Cale> nicknull: sorry about the lack of newlines there, http://hpaste.org/11234#a1 if you haven't seen it yet ;)
12:34:14 <Baughn_> @hoogle promisc
12:34:15 <lambdabot> No results found
12:34:21 <Baughn_> @hoogle raw
12:34:21 <lambdabot> System.Posix.Internals RawDevice :: FDType
12:34:21 <lambdabot> System.Cmd rawSystem :: String -> [String] -> IO ExitCode
12:34:21 <lambdabot> Distribution.Simple.Utils rawSystemExit :: Verbosity -> FilePath -> [String] -> IO ()
12:34:54 <sjanssen> I think you want: alloca (\p -> do thatCFunction p; x <- peek p; newForeignPtr destroyGeometry x)
12:35:16 <nicknull> ah cool, ty very much cale, was busy before
12:35:16 <jeffersonheard> that makes sense
12:35:20 <jeffersonheard> thanks
12:35:37 <Cale> nicknull: So that should give you some idea of how evaluation proceeds.
12:35:51 <Cale> nicknull: Note that we always try to evaluate the outermost expression first.
12:36:09 <BONUS_> > flip (:) (flip (:) (flip (:) (flip (:) [] 3) 4) 5) 6
12:36:10 <lambdabot>   [6,5,4,3]
12:36:35 <Cale> > foldl (flip (:)) [] [3,4,5,6]
12:36:36 <lambdabot>   [6,5,4,3]
12:37:15 <Cale> > foldl (flip (:)) [2,1] [3,4,5,6]
12:37:16 <lambdabot>   [6,5,4,3,2,1]
12:37:32 <BONUS_> yup
12:37:34 <BONUS_> yay for folds!
12:38:34 <nicknull> is it normal for 6MB to take time to count all the words then return the 100 most common?
12:39:09 <Cale> nicknull: How are you counting that?
12:39:25 <Cale> (and how many words?)
12:40:45 <Cale> Note that a lot of the profiling tools count total allocation and not the maximum size of memory.
12:40:57 <BONUS_> man
12:41:02 <pumpkin> woman
12:41:07 <Cale> robot?
12:41:14 <jeffersonheard> replicant
12:41:16 <BONUS_> i just noticed that the textbook haskell quicksort function discards duplicates
12:41:18 <BONUS_> O_O
12:41:18 <olsner> hermaphrodite
12:41:19 <BONUS_> you know the
12:41:30 <musiKk> (otr: i'd say yes! it is normal for any computing to take some amount time)
12:41:33 <vixey> BONUS_: What is the code?
12:41:38 <Cale> BONUS_: uh, maybe you replaced <= with < ?
12:41:44 <nicknull> 855042 words, using a Map
12:41:49 <BONUS_> oh, duh!
12:41:50 <BONUS_> yeah
12:41:58 <BONUS_> i was just toying around with making it more readable etc
12:42:12 <BONUS_> mixed <= with <
12:42:13 <C-Keen> how can I use the function empty from Data.Map ? The compiler says not in scope. I imported it qualified: import qualified Data.Map as Map
12:42:17 <vixey> did anyone get Agda 2 to work with 6.10?
12:42:20 <Cale> nicknull: I can imagine that using 6MB.
12:43:20 <Cale> nicknull: or, you're asking if it's normal for it to take time to do that work?
12:43:27 <nicknull> 855042 words, using a Map
12:43:27 <nicknull> http://hpaste.org/11235
12:43:27 <nicknull> using ^^
12:44:01 <newsham> i finally bit the bullet and started learning coq.  i'm liking it more than agda and isabelle/hol.
12:44:29 <vixey> what will you use Coq for?
12:44:29 <nicknull> what is NaN? zerodivisionerror?
12:45:00 <fynn> newsham: isn't Coq in O'Caml?
12:45:01 <nicknull> cale: yes if it rreally has to take that long.
12:45:13 <nicknull> what is coq?
12:45:15 <fynn> and isn't there something in Haskell that's like Coq?
12:45:16 <newsham> fynn: i believe so
12:45:18 <vixey> fynn: lots of Coq is written in Coq actually I discovered
12:45:21 <newsham> vixey: learning.
12:45:22 <olsner> hmm, is fromListWith strict in the combining function?
12:45:44 <Cale> olsner: no, which is something that I often find myself annoyed with.
12:45:50 <vixey> (btw do you know any good intros for understanding Isabelle and LCF implementations?)
12:45:57 <Cale> There's insertWith' but not fromListWith'
12:46:01 <olsner> @src fromListWith
12:46:01 <lambdabot> Source not found. It can only be attributed to human error.
12:46:05 <jeffersonheard> zero division generally causes infinity, not NaN
12:46:11 <newsham> nicknull: http://coq.inria.fr/  it's a programming language and an interactive proof assistant
12:46:12 <jeffersonheard> both are floating point exceptions, though
12:46:18 <vixey> fynn: Agda is written in haskell but it's nothing like Coq
12:46:21 <olsner> 0/0 = NaN, +/-x/0 = -/+Inf?
12:46:43 <newsham> vixey: i've only used isabelle/hol.  there's a tutorial on the isabelle site for it
12:46:44 <Cale> It might actually be a good idea to write fromListWith' here
12:46:55 <fynn> vixey: yeah. I would imagine someone would implement something like Coq in Haskell
12:46:56 <Cale> nicknull: are you compiling with optimisations?
12:47:01 <vixey> about the actualy implementation of HOL?
12:47:05 <Cale> nicknull: you might want to try it, if not :)
12:47:13 <vixey> not using it
12:47:31 <newsham> vixey: oh, no idea.
12:47:32 <vixey> fynn: I don't know why it matters what language it's implemented it
12:47:36 <nicknull> here is the 2 spamfilters, my new one first and the old one later, thanks to cale and others for the advice: http://hpaste.org/11236
12:47:47 <BONUS_> @src foldl
12:47:47 <lambdabot> foldl f z []     = z
12:47:47 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:47:48 <olsner> maybe bytestringifying it too, if getting even more performance is interesting :)
12:48:27 <nicknull> cale: actually im using ghci
12:48:34 <Cale> nicknull: ah, try compiling it :)
12:48:41 <Cale> and use -O2
12:49:16 <vixey> fynn: why?
12:49:31 <vixey> fynn: Actually you can hack on one with me if you get bored
12:50:04 <jeffersonheard> sjanssen: on a slightly related note, is this a legal signature?
12:50:24 <jeffersonheard> foreign import ccall "OGR_G_CreateFromWkb" c_OGR_G_CreateFromWkb :: ForeignPtr Word8 -> SpatialReference -> Ptr Geometry -> CInt -> IO CInt
12:50:58 <pmurias> it's a bit insane but is it possible to use Cabal to build C code?
12:51:17 <Cale> nicknull: You might actually want to change that use of fromListWith to  fromListWith' = foldl' (\m (k,v) -> Map.insertWith' (+) k v m) Map.empty
12:51:21 <jeffersonheard> I was hoping to use Data.ByteString.Internal.toForeignPtr to take a byteString and pass the contents into a C function directly
12:52:04 <olsner> @ty \wordMap -> sum . map (\k -> Data.Map.findWithDefault 0 k wordMap)
12:52:05 <lambdabot> forall a a1. (Ord a1, Num a) => M.Map a1 a -> [a1] -> a
12:52:16 <Cale> nicknull: Because fromListWith will build up expressions that look like  (((...((1 + 1) + 1) +...) + 1) + 1)
12:52:39 <Cale> nicknull: and those can lead to stack overflows if they get big enough.
12:53:28 <Cale> (when they're finally evaluated)
12:53:44 <olsner> oh, and is qualification on Data.Ord really needed?
12:53:55 <Cale> no
12:54:04 <Cale> I would just
12:54:08 <Cale> import Data.List
12:54:14 <Cale> import Data.Ord
12:54:21 <olsner> and isn't the Ord stuff in the prelude anyway?
12:54:31 <Cale> There's no need for the old List library, it's redirected to Data.List anyway
12:54:36 <Cale> olsner: not comparing
12:54:45 <olsner> aah, okay
12:54:48 <Cale> import qualified Data.Map as M
12:54:52 <Cale> import Data.Map (Map)
12:55:14 <Cale> (so you don't end up messing up your types with qualified names)
12:55:52 <nicknull> is that 02 or O2?
12:55:59 <Cale> The letter O
12:56:25 <nicknull> ghc -O2 SpamFilter.hs ?
12:56:37 <Cale> throw in a --make to be same
12:56:40 <Cale> safe*
12:56:56 <nicknull> ghc --make -O2 SpamFilter.hs ?
12:56:59 <Cale> yeah
12:57:17 <Cale> you can even leave off the .hs if you're lazy.
12:58:00 <Cale> (I suppose you won't have a binary of it yet, so your shell will tab complete that bit anyway :)
12:58:38 <olsner> and if it suites your problem (i.e. you are very sure you'll only work on numbers that fit in your machine word), you could just use Int in the types rather than Num a => a etc
12:58:39 <nicknull> and that should generate SpamFilter.exe?
12:59:21 <Cale> yeah
12:59:37 <Cale> (though I've not really used ghc on windows all that much)
13:00:50 <nicknull> ir doesnt
13:01:05 <Cale> what does it do?
13:01:18 <Cale> ghc --make -O2 SpamFilter.hs -o SpamFilter.exe
13:01:19 <Cale> ?
13:01:34 <nicknull> i didnt call the module main...
13:01:36 <Cale> oh
13:01:51 <Cale> You can just remove your module declaration
13:02:17 <Cale> I suppose you could use --main-is or something, but that's a hassle.
13:02:22 <olsner> if you remove the module declaration, is it implicit that only main is exported, or do you get the same as just doing a "module Main where"?
13:02:33 <Cale> same as the latter.
13:02:42 <Cale> er...
13:02:47 <Cale> I should check :)
13:03:16 <olsner> so, would it occasionally give some kind of boost to explicitly write "module Main (main) where" rather than leaving out the module declaration?
13:03:36 <olsner> i.e. allow more inlining and all that cool stuff :P
13:04:04 <Cale> ah, no, your first guess was right
13:04:09 <Cale> An abbreviated form of module, consisting only of the module body, is permitted. If this is used, the header is assumed to be `module Main(main) where'. If the first lexeme in the abbreviated module is not a {, then the layout rule applies for the top level of the module.
13:04:37 <nicknull> so is the newer on of the 2 spamfilters i posted better?
13:05:31 <Cale> nicknull: it should be faster
13:05:45 <Cale> (significantly so)
13:05:49 <ziman> so application of the layout rule depends on the first lexeme in a `scope', in general?
13:05:58 <Cale> ziman: yeah
13:06:02 <olsner> nicknull: how slow was it before, btw?
13:06:05 <ziman> good to know.
13:06:32 <Ash0> what program do u use to compile? i think my winhugs is broken.
13:06:33 <Cale> ziman: things are supposed to line up to the column of the first non-whitespace character after let,do,where,of
13:06:35 <nicknull> can i time executiontime?
13:06:45 <Cale> Ash0: GHC
13:07:09 <Cale> Ash0: and GHCi is a nice interactive environment for testing code.
13:07:23 <olsner> in ghci, you can do :set +t to get time statistics
13:07:37 <Cale> nicknull: I suppose you could profile it.
13:07:43 <ziman> nicknull, in unix, using time (man time) or you can find some time stats in +RTS -sstderr
13:07:45 <olsner> with a compiled program, what I usually do is run it through 'time', but since that's a unix-only program :)
13:08:06 <Cale> nicknull: compile with -prof -auto-all and then run the program with the commandline args  +RTS -p
13:08:36 <Cale> nicknull: and you'll get a .prof text file which has information on how many times functions were entered, the total allocation and time they did, and so on.
13:11:04 <Cale> BONUS_: btw, for your tutorial, consider using the phrase "if expression" when referring to Haskell's  if/then/else
13:12:41 <Ash0> http://hpaste.org/11238
13:13:09 <Ash0> Cale, if i have that ^ and nothing else ... will it work ?
13:13:18 * Cale looks
13:13:20 <Ash0> do i not need something to get user input
13:13:36 <Cale> Ash0: well, in a compiled program you will
13:13:40 <Baughn> Ash0: "Work" in what sense?
13:13:41 <flazz> is there a haskell that will install on leopard without extra deps?
13:13:47 <Cale> Ash0: but that should do if you're playing around in ghci/hugs
13:13:49 <Baughn> flazz: ..no.
13:14:01 <Ash0> so i need someone before that code?
13:14:14 <Ash0> something*
13:14:20 <Baughn> Ash0: Define "work", please
13:14:28 <Ash0> work as in, give the right output
13:14:41 <Baughn> Given what input?
13:14:46 <Ash0> i compile, put a number in, and it gives output
13:15:04 <Ash0> will i be able to give an input is what im asking
13:15:05 <Baughn> There's nothing in there telling it to read or print numbers. It'll only work in ghci.
13:15:18 <Cale> Ash0: if you try to compile that program into an executable, it will complain that you haven't defined a 'main', but if you load that file into hugs, and type  taxCode 4832
13:15:23 <Cale> you should get the right result
13:15:36 <Cale> (or ghci)
13:16:03 <Ash0> thanks :D
13:16:36 <agcorona> Hi
13:16:55 <Cale> hello
13:17:43 <agcorona> sometimes makeStableName comparisons and reallyUnsafePointerEquality  d
13:17:48 <agcorona> differ
13:17:57 <Cale> I can imagine they would.
13:18:00 <agcorona> I'm confused
13:18:09 <Cale> reallyUnsafePointerEquality is reallyUnsafe
13:18:39 <Cale> Garbage collections can affect its results.
13:18:55 <agcorona> why? makeStableName guaranty that two objects are equal when they have the same stableNam
13:18:57 <agcorona> e
13:19:13 <Cale> agcorona: Right, because the system was designed to support that.
13:19:29 <Cale> That's the problem that StableNames were designed to solve.
13:19:42 <agcorona> a Garbaje Collection in the middle of the pointer comparison?
13:20:56 <Cale> I can imagine that might even happen with the new threaded GC.
13:21:02 <agcorona> so stableName is a better guaranty for two object to point to the same address?
13:21:28 <Cale> yeah
13:21:33 <agcorona> ok
13:23:22 <agcorona> so I finished what i was doing: a serializer/deserializer of  linked structures
13:23:39 <vixey> agcorona: soudns cool what's it parameterized by
13:23:41 <Baughn> Cale: The garbage collection is threaded, but it's still stop-the-world. It can't happen.
13:23:50 <Baughn> It just GCs faster
13:23:54 <Cale> Baughn: ah, that's good to know
13:23:54 <agcorona> with no ugly duplication of multiple referenced objects
13:25:23 <agcorona> for example,  let x=5, y=x in toList  S x y  returns  "S var1 var1 where{ var1=5}
13:25:58 <agcorona> a string
13:26:08 <agcorona> fromList do the oposite
13:27:05 <agcorona> now I'm just testing
13:27:35 <agcorona> with more complex data definitions
13:28:13 <nicknull> apparentl C-c- C-l is a good way t lock your computer when you are runnin a program in ghci
13:28:27 <nicknull> so cale, could you repost the link toyour explanation? thanks
13:28:40 <nicknull> and it seems the new spamfilter is faster
13:28:44 <Cale> nicknull: which one? The evaluation thing?
13:28:47 <nicknull> is there a time-function?
13:28:49 <nicknull> yes
13:29:15 <Cale> http://hpaste.org/11234#a1
13:29:52 <agcorona> vixey: I defined monadic parsers both for serialization and deserialization
13:30:07 <vixey> ah cool
13:30:11 <vixey> did you relate them at all
13:30:17 <agcorona> Ã  la Parsec
13:30:50 <agcorona> I have to test in a bit more
13:31:32 <agcorona> first I need to learn how to cabalize something. after that i will upload it to Hackage
13:31:40 <tromp_> any go players on?
13:31:56 <vixey> actually I'm confused about this type rule
13:32:12 * dancor plays the computer in go everyday
13:32:28 * Baughn loses to the computer in go every few days
13:32:32 <tromp_> i tried to program just the rules of go in haskell
13:32:41 <vixey> you know in this rule: Gamma; x : S |- f x == f' x : T   ==>  Gamma |- f == f' : S -> T ?
13:32:41 <tromp_> see http://homepages.cwi.nl/~tromp/go/Go.hs
13:32:43 * dancor has also been meaning to make own haskell wrapper for gnugo
13:33:00 <tromp_> i welcome suggestions for improvement
13:33:25 <vixey> does that mean like,..    const Nothing == id ? since (const Nothing) Nothing == id Nothing..
13:33:32 <vixey> it seems wrong to me basically
13:33:34 <nicknull> cale: that was map $ filter. what if i do filter $ map *2 ?
13:33:38 * jeffersonheard plays his wife in go every chance he gets
13:33:48 * jeffersonheard loses about half the time
13:33:53 <byorgey> vixey: the idea is that if two functions give equivalent results when applied to any input, they are indistinguishable
13:34:01 <nicknull> wait it is still element by element
13:34:02 <tromp_> it's geared toward clarity rather than efficiency
13:34:08 <dolio> vixey: It'd have to be for all x.
13:34:16 <byorgey> it is implicitly for all x.
13:34:16 <jethr0> tromp_: don't you need to differentiate living vs. dead figures? does your code do that?
13:34:16 <vixey> byorgey: that's what I would have thought, but the actual rule there says different? or does it?
13:34:21 <TomMD> Except to the human that must wait for the O(n^n) version...
13:34:33 <vixey> ... implicit forall :(
13:34:35 <Cale> nicknull: well, the filter will demand an element from the list, which will force the map down one step, and then the element will actually get evaluated (that is, the multiplication will happen) because the condition on the filter will force it to
13:34:38 <vixey> I guess that clears it up though
13:34:39 <byorgey> vixey: no, why is it different?  there are no restrictions on x
13:34:43 <tromp_> my code recognized captures of course
13:34:44 <byorgey> x is just a term variable
13:34:53 <vixey> I read it as if there is any x of type S, then ..
13:34:59 <byorgey> ah, nope =)
13:35:01 <vixey> but 'it is for ALL x of type S' ?
13:35:08 <vixey> how do you read it that way?
13:35:16 <byorgey> because it has to be a type variable
13:35:20 <byorgey> er, sorry, term variable
13:35:23 <tromp_> but scoring regards all stones on board as alive
13:35:24 <byorgey> you can't put any term there
13:35:38 <nicknull> http://hpaste.org/11239 , fromListWith' <--
13:35:51 <vixey> why I could not put Nothing for x if S was Maybe Integer though?
13:35:54 <byorgey> so if f and f' are indistinguishable when applied to a term variable, they must be indistinguishable for all inputs
13:36:10 <jethr0> tromp_: i meant situations where you're not allowed to capture, plus of course ko's, etc.
13:36:11 <byorgey> vixey: no, the x is syntactically a term variable. You can't put Nothing there.
13:36:25 <vixey> what is a term variable?
13:36:28 <tromp_> oh, it doesn't do kos yet:(
13:36:38 <tromp_> it's a work in progress
13:37:13 <byorgey> vixey: it's a variable which stands for a term.  but it's part of the syntax, not a 'meta' sort of thing.
13:37:30 <byorgey> the 'x' in  the term  \x -> x + 2  is a term variable
13:37:48 <vixey> I can almost not handle something not being meta :p
13:37:52 <tromp_> it shld really remember list of past positions
13:37:53 <vixey> I think that I understand it now though, thanks
13:37:53 <byorgey> hehe
13:37:57 <byorgey> sure
13:38:08 <jethr0> tromp_: i think it's a nice project. but as i've once started myself, i know how hard it is to determine whether a collection of stones is alive or not...
13:38:57 <tromp_> it shld just be played out, jethr0
13:39:45 <jethr0> tromp_: i guess you're right. it's been long since i've even attempted to play ;)
13:39:59 <nicknull> is there a time-function?
13:40:28 <byorgey> nicknull: what do you mean?
13:41:42 <nicknull> to time execution
13:41:43 <nicknull> runtime
13:41:55 <Ash0> how would i turn everything uppercase ?
13:42:04 <sjanssen> map toUpper
13:42:07 <vixey> EVERYTHING?
13:42:08 <jethr0> > map toUpper "hello world"
13:42:10 <lambdabot>   "HELLO WORLD"
13:42:35 <Ash0> so i can just map toUpper variablename ?
13:43:11 <byorgey> nicknull: are you on *nix or Windows?
13:43:23 <nicknull> windows
13:44:24 <byorgey> nicknull: ok, and what interpreter/compiler are you using? hugs? ghc?
13:44:42 <vixey> @let turnUppercase = map toUpper
13:44:44 <lambdabot>  Defined.
13:44:48 <jethr0> > let x = "hello world" in map toUpper x
13:44:49 <vixey> > turnUppercase "Everything"
13:44:50 <lambdabot>   "HELLO WORLD"
13:44:51 <lambdabot>   "EVERYTHING"
13:46:20 <Mitar> http://hpaste.org/11240 << why line and column values are not accessible?
13:46:52 <vixey> I think you should not have written:
13:46:54 <vixey>   do
13:47:12 <mart7> http://hpaste.org/11241   <- how can I construct a list from the arguments here?
13:47:40 <Mitar> but then i get parser errors
13:48:36 <nicknull> ghc-6.8.3,windows vista,
13:48:56 <jethr0> mart7: try changing the return type of parseWorldList to [Int]
13:49:29 <mart7> jethr0: thanks, will try
13:49:33 <jethr0> mart7: generally, the use of read (especially in this kind of context) is discouraged
13:49:39 <jethr0> :t reads
13:49:40 <lambdabot> forall a. (Read a) => String -> [(a, String)]
13:50:19 <mart7> jethr0: what would be a better approach? (in loose terms)
13:50:20 <jethr0> > read "4x" :: Int
13:50:22 <lambdabot>   * Exception: Prelude.read: no parse
13:50:30 <jethr0> because it fails ungracefully
13:50:57 <jethr0> as an easy substitute you could use "reads" which at least fails a bit more gently, but also is a bit more verbose...
13:51:18 <jethr0> > reads "x4" :: [(Int,String)]
13:51:19 <lambdabot>   []
13:51:58 <mart7> jethr0: I see, and I (think) I see your point. I'll have a look at "reads"
13:52:24 <nicknull> byorgey: win vista, ghc-6.8.3
13:52:41 <jethr0> also, there is the getopt library (http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html)
13:52:45 <lambdabot> Title: System.Console.GetOpt, http://tinyurl.com/y3585u
13:53:04 <byorgey> nicknull: ok, did you see olsner's suggestion above to use ghci for timing things?
13:53:59 <byorgey> nicknull: if you do  :set +s  in ghci, from that point on it will tell you timing info for every expression you tell it to evaluate
13:54:38 <byorgey> otherwise, if you really need something more heavyweight than that, you can use Data.Time to get the starting and ending times and subtract
14:01:19 <Ash0> why are internet tutorials on haskell so badly explained ?
14:01:40 <lament> that's a good question
14:01:58 <Ash0> for someone whos never done haskell before...
14:01:59 <Ash0> http://www.brics.dk/~amoeller/pp/Haskell-basic.pdf
14:02:02 <lambdabot> Title: Microsoft PowerPoint - Haskell-basic.ppt [Compatibility Mode]
14:02:05 <Ash0> how is that helpful ^
14:02:28 <dolio> Lots of internet haskell tutorials are written by people who just learned the stuff in the tutorial.
14:02:44 <vixey> hehe
14:03:06 <Ash0> theres no tutorials on the basics, where to start, or anything like thats.
14:03:06 <vixey> those lectures notes are awwwwful
14:03:15 <Ash0> its all 'bang. this is haskell!'
14:03:26 <dolio> Or, in that case, that was probably some 10 minute presentation at a club meeting or something.
14:03:40 <sjanssen> Ash0: you can't expect much from random stuff on the internet on any subject
14:03:52 <BONUS_> Ash0: did you manage to give learn you a haskell a shot?
14:04:09 <Ash0> i looked at it
14:04:18 <sjanssen> Ash0: try Real World Haskell, the wikibook, or the Gentle Introduction (only if you've programmed another similar language)
14:04:23 <Ash0> been there too
14:04:31 <vixey> eval = foldExpr id (+) negate (*)
14:04:37 <lament> Ash0: try YAHT
14:04:58 <nicknull> http://hpaste.org/11242 , <-- SpamFilter in 32 lines of haskell
14:05:08 <dolio> If you want an overview lecture, you should watch SPJ's 2-hour overview from one of the open source conferences a few months back.
14:05:21 <Ash0> yet another haskell tutorial .. tht was the first, and probably the best so far.
14:05:50 <dolio> http://notes-on-haskell.blogspot.com/2007/08/more-spj.html
14:05:52 <lambdabot> Title: Notes on Haskell: More SPJ
14:05:55 <dolio> My bad, apparently it was 3 hours.
14:05:55 <lament> Ash0: i agree that they all suck, or at least that important niches are not filled
14:06:05 <vixey>  I wonder about subtyping
14:06:12 <lament> Ash0: sadly the only way to fix that would be to write a better tutorial
14:06:14 <Ash0> the basics are not filled. on any tutorial.
14:06:24 <Ash0> for someone who doesnt have a clue. its impossible to learn from.
14:06:43 <lament> right
14:07:04 <vixey> Ash0: What about LYAH?
14:07:06 <sjanssen> and yet. people somehow learn how to program Haskell.
14:07:10 <vixey> Ash0: is there anything missing
14:07:42 <lament> sjanssen: i assume by "doesn't have a clue" he means doesn't know other programming languages or is otherwise unable to comprehend YAHT
14:07:54 <Ash0> link me? i dont think ive been there yet
14:08:00 <Cale> @where LYAH
14:08:01 <lambdabot> www.learnyouahaskell.com
14:08:04 <sjanssen> Ash0: oh, are you new to programming?
14:08:08 <Ash0> oooh yeah i have
14:08:19 <Ash0> im not a new programmer. but haskell is completely different to what ive done before.
14:08:39 <Ash0> i know basics in vb, java, and web programming (php, mysql) from uni work.
14:08:48 <lament> you are a new programmer :)
14:08:49 <Ash0> but we've just switched from java to a project in haskell
14:09:01 <Ash0> ok then :P
14:09:51 <Ash0> im guessing u guys writen LYAH ?
14:09:52 <Baughn> Ash0: The first thing to remember is that Haskell is not at all like anything you've used before. Pretty much none of your preconceptions will work.
14:09:53 <Cale> I started out in Haskell knowing around 10 languages, but I think that tends to get in the way more than it helps. :)
14:09:58 <Cale> Ash0: BONUS_ wrote it.
14:10:09 <Saizan> uhm, for example i don't think any tutorial tells you the syntax of function application and the use of parentheses, which si completely different from C-like languages, that got me lost when i started, until i learned lisp first
14:10:31 <Baughn> Saizan: LYAH does. ;)
14:10:42 <BONUS_> i hope it does :X
14:10:49 <Saizan> nice :)
14:11:04 <sjanssen> Saizan: is that really true?  Pretty massive oversight
14:11:09 <Ash0> none of the tutorials ive looked at tell u how to 'start a program' :P
14:11:09 <Mitar> http://hpaste.org/11243 << why do i get this error?/
14:11:30 <Ash0> most of them are 'download hugs. and now heres some code...woo'
14:11:40 <Baughn> Ash0: Download hugs.. start hugs interpreter...
14:11:42 <Cale> Mitar: {-# LANGUAGE FlexibleInstances #-}
14:11:49 <Baughn> Ash0: That's about the same as for every other language
14:11:53 <BONUS_> download hugs. now here's some monads.
14:11:55 <Cale> Mitar: unless I'm mistaken about the name of the extension
14:12:01 <Mitar> but i have used instances of lists before ..
14:12:06 <lament> Ash0: YAHT does.
14:12:10 <Mitar> or what is wrong with data type?
14:12:12 <Cale> Mitar: maybe for *all* lists
14:12:16 <Ash0> other languages have defining variables explained
14:12:24 <Cale> Mitar: like   instance Foo [a] where ...
14:12:42 <lament> Ash0: LYAH does, too.
14:12:48 <sjanssen> Saizan: looks like Gentle Intro doesn't explain function application anywhere
14:12:57 <Saizan> sjanssen: YAHT neither
14:13:20 <lament> Ash0: I'm pretty sure all haskell tutorials explain definitions.
14:13:26 <Saizan> sjanssen: and the other tutorial at the time was the one for C programmers, which i didn't try :)
14:13:28 <lament> Ash0: there's very little else in haskell.
14:13:33 <Cale> Mitar: The original Haskell 98 spec was very restrictive about how instances were selected. It said that the instance head had to consist of a single type constructor possibly applied to some type variables (and possibly with a class context restricting those type variables)
14:14:05 <jsn> Ash0: are you on windows?
14:14:07 <dolio> sjanssen: Does the section on Functions not count?
14:14:13 <Cale> Oh, heh, and the variables it was applied to had to all be distinct.
14:14:31 <Ash0> yeah windows
14:14:45 <Mitar> but is not my data type single type constructor?
14:14:45 <jsn> Ash0: ah, well, there, i don't know how to make runnable haskell scripts
14:14:48 <patco444> The Best Online RPG / Strategy game ever : http://www.fallensword.com/?ref=1461055
14:14:49 <lambdabot> Title: Fallen Sword v1.533 - Massively Multiplayer Online RPG (MMORPG)
14:14:56 <sjanssen> dolio: yeah, I suppose it does count
14:15:00 <Roey> hello
14:15:02 <Roey> you people
14:15:03 <Roey> oof
14:15:05 <Roey> http://hpaste.org/11216
14:15:13 <lament> Ash0: don't say you actually had difficulties running Haskell programs after reading all those tutorials.
14:15:15 <jsn> on UNIX you can use
14:15:17 <jsn> #!/usr/bun/env runhaskell
14:15:22 <jsn> at the top of the file
14:15:28 <dolio> sjanssen: Granted, it does come after the use of a bunch of functions.
14:15:30 <Cale> Mostly you just compile the program
14:15:32 <Roey> I love its elegance but I'm trying to make sense of its structure; how would this be expressed in a similar one-liner in PYthon?
14:15:34 <jsn> i don't know what the equivalent is on windows
14:15:36 <Baughn> jsn: And there will be delicious pastries.
14:15:42 <jsn> Cale: oh
14:15:44 <Baughn> There isn't one.
14:15:46 <sjanssen> dolio: though it doesn't come straight out and say "function application is juxtaposition"
14:16:03 <Cale> Roey: It just tests if each number 3 and up is prime.
14:16:03 <Baughn> jsn: Well, the windows equivalent would be to designate the interpreter as the default action for .hs files in the registry
14:16:10 <jsn> Baughn: you can't put something in the, uhm, registry?
14:16:12 <jsn> oh
14:16:14 <sjanssen> dolio: yeah, I assumed it didn't cover it after seeing several applications with no explanation
14:16:15 <Ash0> obviously i didnt read every word in every tutorial lament. what im saying it. every tutorial jumps straight from downloading hugs, into coding (mainly the simple maths stuff).
14:16:17 <jsn> yeah, i thought so
14:16:21 <Baughn> jsn: You can't do it on a per-file basis, like #! does
14:16:26 <Roey> Cale:  oh... I thought it builds a list of primes and tests each number against every element in the list
14:16:32 <Roey> *each successive number
14:16:33 <Cale> Roey: with the usual "test all possible divisors less than or equal to the square root" thing
14:16:37 <Ash0> but none of them tell u how to make a full program. with user inputs. stored variables. etc..
14:16:46 <lament> Roey: part of the elegance comes from the fact that isPrime and primes are defined in terms of each other. You can't easily do that in Python.
14:16:51 <Roey> lament:  hi!
14:16:53 <lament> Roey: you'd need iterators...
14:16:56 <Roey> omg they got you too????
14:16:57 <Baughn> Ash0: Have you tried Real World Haskell?
14:17:00 <Roey> this Haskell ;)
14:17:02 <Cale> oh
14:17:05 <lament> Roey: it's horrible, i know
14:17:05 <Cale> oh right...
14:17:10 <Roey> lament:  =)
14:17:11 <Ash0> yeah i think ive been to tht one
14:17:12 <Cale> heh yeah, it's only testing primes
14:17:17 <Roey> lament:  ok well assuming I had iterator functions for it
14:17:22 <Baughn> Ash0: http://book.realworldhaskell.org/read/
14:17:24 <Cale> Okay, that's trickier in python then :)
14:17:24 <lambdabot> Title: Real World Haskell
14:17:29 <Roey> lament:  see that's what I didnt' get... I never saw 'primes' defined anywhere
14:17:37 <lament> Roey: "primes = "...
14:17:41 <Roey> hrm
14:17:51 <Baughn> Ash0: It explains how to run your code in the first chapter.
14:17:52 <Ash0> ive tried LYAH, YAHT and Another Haskell Tutorial
14:17:57 <Roey> primes :: Integral i => [i]
14:18:00 <Roey> oh, so I see.
14:18:00 <Ash0> probs a couple more random ones too
14:18:14 <nicknull> how did i compile as filename again?
14:18:14 <jsn> Ash0: keep trying -- you will understand soon
14:18:15 <Roey> lament:  but how does that do anyuthing?
14:18:21 <dolio> sjanssen: All the functions before that section seem to be of arity 1.
14:18:27 <jsn> Ash0: it's just over the next hill...
14:18:28 <nicknull> ghc --make -O2 SpamFilter.hs ...
14:18:35 <nicknull> ghc --make -O2 SpamFilter.hs as SpamFilter.exe?
14:18:54 <Cale> http://hpaste.org/11216#a1 just because I can't leave some things alone ;)
14:19:01 <lament> Roey: because of lazy evaluation
14:19:03 <Roey> lament:  primes = 2 : filter isPrime [3..] <-- so primes = 2.  and you're running isPrime on every number 3 and above
14:19:05 <Roey> lament:  ok
14:19:16 <dolio> Except for the Point constructor.
14:19:28 <vixey> Roey: not sure why you would have that type annotation
14:19:33 <lament> Roey: isPrime doesn't require all primes, it just needs those that are smaller than the square root of the number it's testing.
14:19:39 <vixey> Roey: I'd leave it out completely or annotate [Integer]
14:19:46 <Roey> vixey?
14:19:47 <centrinia> Has anyone done research on types that are defined to be equivalence classes of types?
14:19:48 <Cale> Actually, it's a little unfortunate that primes isn't monomorphic, since it won't be memoised.
14:19:48 <Roey> paul vixey?
14:19:50 <Baughn> ..RWH looks a lot better than last time I looked. Rather like a real book, in fact, explaining everything in exhaustive (exhausting) detail
14:19:57 <Cale> (but maybe that's intended)
14:20:07 <Ash0> i must be missing something simple here. to me this tutorial goes straight from download to the maths coding too
14:20:09 <lament> probably because it's a real book :)
14:20:10 <vixey> centrinia: What do you mean?
14:20:19 <lament> Ash0: YAHT certainly explains in detail how to run haskell programs.
14:20:22 <Baughn> Ash0: The part where you're told to start ghci?
14:20:34 <vixey> centrinia: equiv. classes of values makes sense but of types? I don't understand..
14:20:34 <lament> Ash0: Right in the very beginning.
14:20:45 <Cale> Ash0: http://book.realworldhaskell.org/read/getting-started.html
14:20:47 <lambdabot> Title: Chapter 1. Getting Started
14:20:48 <Baughn> Ash0: Details like loading files, etc. are explained as you need them
14:20:51 <Ash0> downloading hugs, then typing in 2*3 is not what im looking for
14:20:54 <Baughn> Not before
14:21:00 <vixey> Ash0: What are you looking for
14:21:08 <Baughn> Ash0: Well, if you read RWH from front to back, it'll explain everythign in the right order
14:21:09 <jsn> Ash0: to run a haskell program:
14:21:11 <Ash0> i need to know how to input and store a variable
14:21:15 <Roey> lament:  anyway... it smells halakhically kosher but I can't prove it.
14:21:16 <vixey> Ash0: lol
14:21:18 * jsn downloads ghc
14:21:29 * jsn writes a program
14:21:30 <Ash0> the main = do thing
14:21:32 <vixey> Ash0: and how to 20 GOTO 10 ??
14:21:36 <byorgey> does anyone know if the Bool instance for IOUArray is implemented using bit-packing?
14:21:37 * jsn ghc --make Program.hs
14:21:38 <Cale> Ash0: You create a file, say, like  ScratchPad.hs
14:21:43 * jsn Program
14:21:43 <lament> Roey: it's fully kosher, it's just a little hard to understand
14:21:43 <Cale> Ash0: write in it  x = 5
14:21:51 <jsn> runs it, not so hard
14:21:55 <lament> Roey: have you seen the recursive fibonacci definition?
14:21:58 <geezusfreeek> Ash0, see the section called "A simple program" right at the very bottom of the page: http://book.realworldhaskell.org/read/getting-started.html
14:21:58 <Cale> Ash0: then load it in your favourite interpreter, and type  x
14:21:59 <ddarius> byorgey: I believe it is.
14:21:59 <lambdabot> Title: Chapter 1. Getting Started
14:22:04 <byorgey> ddarius: sweet!
14:22:05 <Cale> Ash0: and it will print 5 :)
14:22:08 <Baughn> jsn: Well, except that won't work quite as easily on windows
14:22:11 <Roey> lament:  lemme guess, it's probably expressed in half a line ;)
14:22:20 <jsn> Baughn: no?
14:22:25 <jsn> Baughn: why not?
14:22:29 <Baughn> jsn: The compiler/linker might *not* be in your PATH
14:22:34 <lament> Roey: try to wrap your head around this first:
14:22:37 <Baughn> Like, oh, most programs on windows
14:22:40 <jsn> even if you install it with the installer?
14:22:45 <centrinia> If you have something like: data Nat = Z | S Nat; data IntType = ZZ Nat Nat {- (ZZ a b) = (ZZ c d) <=> add a d = add c b -}
14:22:49 <Baughn> GHC doesn't bundle a C compiler or linker
14:22:54 <lament> Roey: fib = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ]
14:23:06 <jsn> Baughn: yes it does, it bundles GCC on windwos
14:23:17 <Baughn> jsn: It does? ...okay.
14:23:19 <Ash0> What im trying to do is, have the user input a variable, then i want to use that variable for other things..
14:23:21 <lament> Roey: instead of two things depending on each other, here there's only one that depends on itself, but the mechanism is the same
14:23:26 <jsn> Baughn: i do this on windows, actually
14:23:29 <Baughn> jsn: Hm, guess that explains its size
14:23:32 <lament> Roey: the latter entries in the list depend on the earlier entries
14:23:33 <vixey> centrinia: So you are actually making an equiv. class on the values of the type yes?
14:23:41 <jsn> not very often, but i've had to test my code on windows before, so
14:23:42 <Ash0> ..i dont want to multiply 2 by 3, or square the letter J
14:23:43 <geezusfreeek> Ash0, it sounds like you are skipping ahead
14:23:51 <Cale> Ash0: main = do x <- getLine; print (reverse x)
14:23:56 <Cale> Ash0: Something like that?
14:24:08 <Cale> Ash0: I/O typically is explained later in Haskell tutorials.
14:24:17 <centrinia> vixey, in this case, yes. :)
14:24:19 <Cale> Ash0: You really want to learn how to use the language as a fancy calculator first.
14:24:20 <vixey> centrinia: That has been studied, I think you can find lots of stuff under Quotient Types
14:24:27 <lament> Ash0: When you learn something, you start with the simple stuff and go on to the hard stuff.
14:24:27 <Baughn> Ash0: I/O is a complication, and the existence of interpreters means you can get a lot of learning done without using it
14:24:29 <centrinia> Thanks. :)
14:24:30 <jsn> personally, i think it is okay to make the first haskell program an implementation of grep or some such
14:24:34 <lament> Ash0: Simple stuff in Java happens to be hard stuff in Haskell.
14:24:41 <Roey> lament:  ah
14:24:41 <lament> Ash0: and vice-versa.
14:24:47 <jsn> i don't think so
14:24:52 <jsn> hard to explain, sure
14:24:57 <Roey> lament:  I need to learn haskell syntax... I hear it's been gaining popularity among coders in general in recent years
14:24:58 <jsn> but not hard to use or work with
14:24:59 <Baughn> I/O is *not* hard in haskell. Easier than java, I'd say
14:25:04 <jsn> yeah, really
14:25:07 <Baughn> It's just not quite as simple as not doing I/O
14:25:07 <jethr0> what i find to be a very good approach to learning haskell for real after trying around a bit is: implementing prelude functions
14:25:09 <Ash0> thats probably what the problsm is lament, since i spent last year doing java at uni
14:25:09 <vixey> Ash0: Why don't you just start programming though
14:25:15 <Ash0> now theyve switched to haskell
14:25:17 <Baughn> And most newbies have quite enough to learn at once without throwing IO into the mess
14:25:19 <lament> Ash0: right, so just ignore that and read the tutorial
14:25:19 <vixey> Ash0: You don't really need to read any tutorials at all
14:25:27 <Mitar> is this XFlexibleInstances and XTypeSynonymInstances something new which was not there in 6.6?
14:25:29 <Roey> isn't Caml a functional language too?
14:25:31 <lament> i'm pretty sure i've seen a tutorial that started with IO, though
14:25:34 <Roey> and LISP is what, then?
14:25:35 <Cale> Mitar: yes
14:25:37 <jsn> Baughn: i think I/O is most important, though
14:25:39 <Mitar> :-)
14:25:45 <Cale> Mitar: The LANGUAGE pragma stuff is new.
14:25:47 <jethr0> Roey: multiparadigm
14:25:48 <Mitar> ok ... this is why i did not get a warning before ...
14:25:49 <Roey> is there a gnu-haskell?
14:25:50 <Baughn> Ash0: Try reading RWH, starting at chapter one, proceeding through chapter two, and so on
14:25:52 <vixey> Roey: if you have the same def. of functional language yeah
14:25:54 <BONUS_> jsn: only if you want to run your program :)
14:25:54 <jsn> Roey: LISP is a huge macro langauge
14:25:59 <Baughn> Ash0: It's meant to be read in order. If you do that, you shouldn't have problems.
14:25:59 <Roey> Cale:  Pragma is an old lagnuag I thought
14:26:03 <jsn> Roey: gno
14:26:04 <Roey> vixey:  ok
14:26:16 <Cale> Mitar: We have a sensible semi-standard way to specify which language extensions we want now :)
14:26:41 <Mitar> ok, so it is normal, that code which before 6.8 compiled without warning
14:26:45 <Mitar> now produces errors?
14:26:46 <Mitar> :-)
14:26:52 <Cale> Roey: A pragma is a piece of code, usually embedded in a comment which is meant to be read by the compiler and specify some option it should use when compiling the surrounding code.
14:26:58 <Baughn> Mitar: APIs change. Just wait for 6.10 ;)
14:27:15 <Mitar> :-)
14:27:22 <Cale> Mitar: well, you might just -fglasgow-exts
14:27:29 <Cale> Mitar: I think that flag still exists.
14:27:45 <geezusfreeek> it does, but i hate that it does
14:27:48 <Roey> Cale:  ah ok, like #pragma then
14:27:53 <Roey> Cale:  often compiler-specific
14:27:54 <Mitar> ok, so is there some drawback of enabling XFlexibleInstances?
14:27:58 <jsn> Mitar: i think it would be sweet if we had "back pragmas" to enable deprecated features
14:28:00 <Roey> Cale:  and not standardied
14:28:26 <vixey> centrinia: why did you get interested in it?
14:28:28 <Cale> Roey: yeah, but some pragmas in Haskell have started becoming standard.
14:28:34 <Roey> oh! interesting.
14:28:37 <jsn> so we can just get all that GHC stuff on by default and turn on {-# GIMPED #-} for Haskell98 code
14:28:39 <Roey> Cale:  may I hang out here a bit?
14:28:52 <Cale> (not standardised, but at least supported by multiple implementations)
14:28:55 <Cale> sure!
14:28:57 <jsn> Roey: yes
14:30:13 <Roey> thanks!
14:30:15 <Roey> yeay
14:30:52 <jsn> is anyone blah-ing in blah? i got a new chat client and i don't see anything in that channel but joins and leaves
14:31:54 <Ash0> well im off. bye all.
14:31:59 <ziman> sure, very interesting discussions are going on there sometimes
14:32:09 <vixey> in #haskell-blah ?
14:34:07 <ddarius> vixey is incredulous.
14:37:56 <vixey> very true
14:39:53 <vixey> is djinn doing tablau
14:41:06 <BONUS_> i've been noticing a lot of people lately coming here with school stuff
14:41:16 <BONUS_> hehe, funny
14:42:34 <vixey> I am not sure about using the way ileanTAP or djinn or what
14:43:41 <ddarius> BONUS_: The school year just started.
14:43:49 <jethr0> BONUS_: could you help me with some code? i'm trying to write a function that "calculates the length of a list". here's my code so far: "len [xs] = do i <- 0; x <- xs; i <- i + 1; return i"
14:43:51 <jethr0> ;)
14:43:56 <BONUS_> hahaha
14:44:00 <BONUS_> oh yeah thats it then
14:44:05 <BONUS_> i've only been here since may or so
14:44:17 <jethr0> they always come back
14:44:35 <BONUS_> hey guys i want this to work i dont wanna know the basics i want this now plz !!!!
14:44:46 <jsn> send me teh monadz!
14:44:57 <Roey> see that just sounds like it should be a dirty word.
14:45:09 <Roey> "can you show me your monad?"
14:45:20 <jsn> yeah, we need to change it
14:45:21 <Roey> "here, let me fix your monad"
14:45:22 <jsn> to triad
14:45:31 <Roey> "my monads are rotten"
14:45:36 <jethr0> some people tend to give highly complex solution that any kind of tutor or teacher will spot as coming from this channel ;)
14:45:44 <BONUS_> before i had heard of monads in the FP setting, if you asked me what monads meant, i'd have said "balls"
14:45:45 <Roey> "psst, dude, lemme see your monads"
14:45:51 <Cale> monad is a portmanteux of monoid and triad
14:45:59 <Cale> er, s/x//
14:46:03 <therp> jethr0: :)
14:46:04 <BONUS_> jethr0 haha yeah that owns
14:46:06 <Roey> I know :)
14:46:07 <jethr0> what's a triad?
14:46:24 <Roey> like
14:46:28 <Roey> jesus the father, son and holy ghost
14:46:33 <Cale> jethr0: 'triad' 'triple' and a number of other things were early names for monads
14:46:36 <BONUS_> like when Beelsebob gave that guy that solution by using functions as applicative functors
14:46:42 <BONUS_> triad sounds nice
14:46:47 <ddarius> 'standard construction'
14:46:49 <Cale> jethr0: a triad in general is three things
14:47:00 <BONUS_> also cause its in music theory
14:47:04 <Roey> Cale:  triad is a 3-tuple?
14:47:08 <jethr0> k, i thought it was another category theoretic construct i didn't know yet
14:47:09 <BONUS_> and its hip now to use music theory names in programming
14:47:19 <lament> ever since C
14:47:25 <Cale> Roey: well, I just mean its English meaning
14:47:29 <jethr0> F#
14:47:30 <BONUS_> i thought it only took off from C#
14:47:38 <BONUS_> and then with F# it was like OK cool it
14:47:47 <BONUS_> when i hear triad i think chord with 3 notes
14:47:52 <BONUS_> but yeah, it would work for monads
14:47:57 <ddarius> A note name is hardly music theory.  Octave would be closer.
14:48:15 <Cale> Of course, a monad itself is a triple (T,eta,mu) with T an endofunctor, eta a natural transformation 1 -> T and mu a natural transformation T^2 -> T
14:48:16 <BONUS_> but still, i'd say it is music theory. really really basic music theory
14:48:42 <jethr0> Cale: of course it is
14:48:44 <lament> so's C :)
14:48:51 <lament> and "string"
14:49:25 <nicknull> aall p = foldr ((&&) . p) True, will that quit as sooon a p -> false ?
14:49:26 <jsn> wow, this channel is changing
14:49:33 <Cale> jsn: changing?
14:50:18 <jsn> i just mean, it's usually for a discussion of monads to go on well past the first mention of eta and mu
14:50:47 <pjdelport> > all even [1..]
14:50:48 <lambdabot>   False
14:50:52 <BONUS_> guess the category theory elite aren't here now
14:50:54 <BONUS_> except for Cale
14:50:58 <jethr0> let's start a @eval, @pl and @djinn rampage to keep the channel as it has always been...
14:51:01 <pjdelport> nicknull: -^
14:51:29 <pjdelport> @src (&&)
14:51:30 <lambdabot> True  && x = x
14:51:30 <lambdabot> False && _ = False
14:51:46 <jethr0> i'll start by trying to avoid lambdabot's security features with multiple stacked calls to "error"
14:51:49 <BONUS_> just thought of something
14:51:50 <Cale> I'm going to name my next programming language B-flat diminished ninth.
14:51:52 <vixey> wow I have 6.11
14:51:55 <BONUS_> hahaha
14:51:59 * ddarius is eating.
14:52:08 <BONUS_> my next one definitely Cmaj7
14:52:20 * vixey is trying to install haskell software
14:52:22 <BONUS_> anyway, has anyone ever written a quine in Haskell?
14:52:30 <vixey> yes I have seen one BONUS
14:52:31 <Cale> yep
14:52:33 * jethr0 will call his language dOrEmI
14:52:39 <BONUS_> show me it
14:52:53 <vixey> main = putStrLn (x ++ show x) where x = "something clever here"
14:52:55 <vixey> I thin k..
14:53:29 <vininim_> there is a error "something clever" too
14:53:31 <lament> BONUS_: how about C13addb9add#9add#11addb13addb7? It has *all* the notes!
14:53:40 <BONUS_> nana
14:53:49 <BONUS_> that would certainly be one heck of a programming language
14:54:08 * Philippa_ needs to describe a System FU
14:54:20 <vixey> haha
14:54:35 <jethr0> would be nice to name your language after the opening notes of "flight of the valkyries"
14:54:36 <pjdelport> > ap (++) show "ap (++) show "
14:54:38 <lambdabot>   "ap (++) show \"ap (++) show \""
14:54:47 <vixey> oh cool pjd
14:54:50 <vininim_> parser error on input in
14:54:55 <BONUS_> freakin cool
14:54:59 <vininim_> > parser error on input in
14:55:00 <lambdabot>   <no location info>: parse error on input `in'
14:55:04 <vixey> > <no location info>: parse error on input `in'
14:55:06 <lambdabot>   <no location info>: parse error on input `<'
14:55:07 <jethr0> hehe
14:55:09 <vininim_> heh
14:55:09 <BONUS_> haha
14:55:20 <vixey> that's also neat vininim
14:55:28 <Cale> > <no location info>: parse error on input `<'
14:55:34 <lambdabot>   <no location info>: parse error on input `<'
14:56:01 <jethr0> not sure i'd call that a _haskell_ quine
14:56:06 <vixey> @quine
14:56:07 <lambdabot> Maybe you meant: quit quote
14:56:56 <vininim_> @Maybe
14:56:57 <lambdabot> Unknown command, try @list
14:57:02 <vixey> omg :((((
14:57:05 <vininim_> @Unknown
14:57:07 <lambdabot> Unknown command, try @list
14:57:09 <vixey> cabal: ghc-pkg describe * failed. If you are using ghc-6.9 and have an empty user package database then this is probably due to ghc bug #2201. The...
14:57:12 <Cale> @where @where
14:57:13 <lambdabot> I know nothing about @where.
14:57:15 <vixey> I hate cabal so much
14:57:16 <BONUS_> @franz
14:57:16 <lambdabot> Unknown command, try @list
14:57:20 <BONUS_> haha
14:57:21 <lament> @liszt
14:57:21 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
14:57:27 <vixey> does anyone know how you fixe this thing?
14:57:27 <Cale> @where+ @where @where
14:57:27 <lambdabot> Done.
14:57:29 <Cale> @where @where
14:57:30 <lambdabot>  @where
14:57:36 <BONUS_> lol
14:57:37 <Cale> @where+ @where @where @where
14:57:38 <lambdabot> I will remember.
14:57:40 <Cale> @where @where
14:57:40 <lambdabot>  @where @where
14:57:46 <vininim_> lol
14:57:47 <BONUS_> hey, define that quine to lambdabot
14:57:54 <dmwit> ?where+ wolf AROOOOOO!
14:57:55 <lambdabot> I will remember.
14:57:57 <dmwit> ?were wolf
14:57:57 <lambdabot> AROOOOOO!
14:58:02 <BONUS_> @quine+ ap (++) show "ap (++) show "
14:58:02 <lambdabot> Unknown command, try @list
14:58:14 <BONUS_> oh it doesnt work that way
14:58:22 <BONUS_> @where+ quine ap (++) show "ap (++) show "
14:58:23 <lambdabot> It is forever etched in my memory.
14:58:34 <lament> @where quine
14:58:34 <lambdabot> ap (++) show "ap (++) show "
14:58:38 <BONUS_> col
14:58:42 <BONUS_> s/o/oo
14:59:07 <vixey> Did anyone FIX that cabal bug?
14:59:09 <pjdelport> lament: thanks
14:59:15 <vixey> I keep hearing it's fixed but it never goes away
14:59:26 <pjdelport> that quine is awesome
14:59:51 <pjdelport> you probably don't get a much purer distillation
14:59:58 <vixey> @where+ anotherQuine @where anotherQuine
14:59:59 <lambdabot> I will never forget.
15:00:01 <vixey> @where anotherQuine
15:00:02 <lambdabot>  @where anotherQuine
15:00:04 <vixey> :((
15:00:08 <vixey> not possible then
15:00:38 <nha__> does lambdabot have that pointfree generator builtin?
15:00:43 <vininim_> > 1
15:00:44 <lambdabot>   1
15:01:02 <vininim_> I has to be a program, or else it's too easy
15:01:03 <BONUS_> i think its a plugin
15:01:06 <vininim_> *it
15:01:51 <nha__> > :pf f (g x)
15:01:52 <lambdabot>   <no location info>: parse error on input `:'
15:02:31 <Cale> @pl \x -> f (g x)
15:02:31 <lambdabot> f . g
15:02:40 <nha__> thanks
15:03:01 <jethr0> nha__: don't abuse it!
15:03:14 <vixey> nobody can tell me how to have a working cabal ?
15:03:22 <jethr0> @pl \a b c d e f -> f e c d b a
15:03:23 <lambdabot> flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip . (flip .) . flip (flip . flip id)))
15:03:26 <nha__> lol
15:03:28 <nha__> nice
15:03:46 <vininim_> vixey: which bug?
15:03:58 <Cale> @pl a b c d e f g h i j k l m n o p q r s t u v w x y z = l e t s s e e y o u p o i n t s f r e e t h i s
15:03:59 <nha__> @pl \x -> (f x) a b x
15:04:00 <vixey> cabal: ghc-pkg describe * failed. If you are using ghc-6.9 and have an empty
15:04:00 <vixey> user package database then this is probably due to ghc bug #2201. The
15:04:00 <vixey> workaround is to register at least one package in the user package db.
15:04:02 <lambdabot> a = fix (const (const (const (const ((const .) . (((const .) .) .) . (((const .) .) .) . ((((const .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((((((const .) .) .) .) .) .) .) .) .) .) .)
15:04:02 <lambdabot> . (((((((((((const .) .) .) .) .) .) .) .) .) .) .) . (((((((((((const .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((const .) .) .) .) .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .)
15:04:02 <lambdabot> . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((ap .) .) .) .) .) .) .) .) . (((((((((flip .) .) .) .)
15:04:02 <lambdabot>  .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . (((((((((((flip .) .) .) .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((ap .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . ((((
15:04:04 <lambdabot> (flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . ((((((((((flip .) .) .) .) .
15:04:07 <lambdabot> [15 @more lines]
15:04:09 <lambdabot> optimization suspended, use @pl-resume to continue.
15:04:09 <dmwit> ack!
15:04:10 <fynn> arhhh
15:04:11 <lambdabot> join (flip (flip f a) b)
15:04:13 <lispy> Cale: arg!
15:04:39 <jethr0> i find the point-free version much more maintainable
15:05:17 <dons> mm
15:05:26 <jethr0> i love the fact that it's using a fix-point for a simple function application
15:05:33 <vixey> it can't be ONLY me that has all these cabal problems? :S
15:05:35 <BONUS_> lol
15:05:54 <vixey> actually knowing my luck it can
15:06:02 <vininim_> The Glorious Glasgow Haskell Compilation System, version 6.8.2
15:06:02 <BONUS_> vixey: if it makes you feel any better, i'm having a whole set of other cabal problems :]
15:06:02 <dons> mm?
15:06:05 <vininim_> =P
15:11:36 <zeno> i had cabal problems yesterday
15:13:07 <vixey> it is actually infuriating that some use Setup.lhs and some use Setup.hs
15:13:25 <BONUS_> i keep getting permission denied errors
15:13:33 <BONUS_> when it wants to write some intermediary file or something
15:13:35 <BONUS_> whats up with that
15:13:39 <vixey> oh great haskell-src doesn't even complie
15:15:12 <nha__> do you have to make an instance of Monoid to implement Foldable for a data structure?
15:16:55 <vixey> where do you get readline for ghc?
15:17:10 <vixey> 6.11 :/
15:17:14 <vixey> this is not going to work is it
15:17:42 <vixey> is there some way to make editline implement the readline interface
15:17:47 <nicknull> readLine
15:19:02 <nicknull> getline
15:19:02 <nicknull> getLine
15:19:39 <vixey> what's the compatability module for haskell exceptions
15:19:40 <vixey> ?
15:20:29 <mmorrow> Control.OldException
15:20:46 <vixey> thanks :)
15:20:52 <mmorrow> and System.Console.Editline.Readline
15:20:53 <mmorrow> :)
15:21:00 <vixey> oh brilliant
15:21:18 <jethr0> BONUS_: maybe you're in a directory you're not allowed to write to
15:22:01 <mmorrow> @pl-resume
15:22:01 <lambdabot> pointless: sorry, nothing to resume.
15:22:33 <BONUS_> jethr0: im usually in ~ when doing cabal install
15:22:41 <BONUS_> if i try to do sudo cabal install it says it can't find cabal
15:22:48 <jethr0> hmm
15:22:50 <BONUS_> cause i added the cabal bin folder to my PATH
15:25:06 <vixey> eek
15:25:11 <vixey> this is weird     Could not find module `System.Console.Editline.Readline': it is a member of package editline-0.2.0.0, which is hidden
15:25:15 <vixey> is there a way to unhide it?
15:25:24 <vixey> or do I misunderstand that message
15:25:30 <mmorrow> add it to the build-depends: if you're building a cabal package
15:25:36 <mmorrow> if not, then
15:25:45 <mmorrow> sudo ghc-pkg expose editline
15:25:48 <mmorrow> would do it
15:25:54 <lispy> vixey: that's a well known rough spot, unfortunately that error is from ghc
15:26:39 <lispy> vixey: cabal works by hiding anything that you didn't mention as a dependency.  The reasoning being that when you share your package all your dependencies have to be explicit.
15:27:18 <mmorrow> doing the "sudo ghc-pkg hide foo", "sudo ghc-pkg expose foo" dance usually works for 99% of (fixable) dependency problems i've found
15:27:30 <vixey> how do I add it to build depends?
15:27:32 <vixey> I tried like:
15:27:33 <vixey>                    editline >= 0.2 && < 6
15:27:36 <vixey> but that gives a syntax error
15:27:58 <vixey> oh I didn't put ac omma there :)))
15:28:04 <mmorrow> heh
15:29:03 <mmorrow> (also, the above "dance" being necessary when you've got multiple version of the same package installed..)
15:29:13 <mmorrow> (and only then)
15:29:28 <vixey> I will never understand how all this stuff works :[
15:29:30 <skorpan> is there any useful bittorrent client written in haskell? if not, why not?
15:29:45 <vixey> it seems to be working now though!
15:29:56 <mmorrow> vixey: just put on your hacking shoes and start flying by the seat of your pants :)
15:30:05 <mmorrow> seems to work for me with cabal stuff ;)
15:30:14 <Baughn> skorpan: Why do we need one?
15:30:28 <jethr0> skorpan: there was an ambitious project a while back. don't quite recall what it was called
15:30:36 <skorpan> Baughn: well, i was thinking since xmonad is so configurable, i'd really find a bittorrent as configurable pretty cool
15:30:37 <Baughn> skorpan: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/conjure <-- But, heh, yes.
15:30:58 <jethr0> conjure
15:31:10 <vixey> omg compile errors
15:31:22 <mmorrow> the fun begins!
15:32:24 <jethr0> not sure how much functionality is implemented in conjure yet, though
15:32:46 <jberryman> I've never done any programming with graphics, is hgl the best place to start for simple things? or is there something else out there I should look at?
15:33:00 <mmorrow> i've found two cases of common problems with 6.8.* pkgs building on >=6.9 are cause by Control.(Old)Exception and the change from (Monad m) => .. -> m a to  ... -> Maybe a in Data.Map.lookup
15:33:12 <vixey> mmorrow: That's scary!
15:33:19 <vixey> mmorrow: this is exactly the error I have
15:33:23 <mmorrow> for the first one i do:
15:33:29 <vixey> !!
15:33:41 <mmorrow> for i in `find . | grep -vE "_darcs" | grep -E "\.hs"`;do cat $i | sed -r 's/Control.Exception/Control.OldException/g' > a; mv -f a $i; done
15:33:46 <mmorrow> for the second one i do:
15:34:11 <nicknull> is a bloom_filter haskellish?
15:34:19 <mmorrow> (manually)  M.lookup .....  ====>  maybe (fail "asdfdas") id . M.lookup ......
15:34:25 <mmorrow> (hackish, but quick)
15:34:35 <nicknull> would it be a good haskell-exercise to implement?
15:34:51 <mmorrow> nicknull: bos seems to think so :)
15:34:51 <BONUS_> i've been thinkin bout implementing a bloom filter too
15:34:54 <jethr0> mmorrow: sed can actually change files in place (i think with "-i filename" or similar) making them temp file unnecessary</offtopic>
15:35:03 <BONUS_> i've known about them but i've just recently read up on them
15:35:05 <mmorrow> jethr0: ohh, good to know :)
15:35:10 <jethr0> @google bloom filter haskell
15:35:18 <lambdabot> http://www.reddit.com/r/programming/comments/74140/bloom_filters_haskell_fast_gene_sequence_analysis/
15:35:19 <lambdabot> Title: Bloom filters + Haskell = fast gene sequence analysis : programming
15:35:26 <vixey> mmorrow: soo great, thank you!
15:36:11 <mmorrow> vixey: no prob bob
15:36:13 <Peaker> They use Perl/Python for genetic stuff, right?  Even for the algorithmic stuff?
15:36:42 <bos> que?
15:36:53 <mmorrow> <nicknull> is a bloom_filter haskellish?
15:36:57 <mmorrow> <nicknull> would it be a good haskell-exercise to implement?
15:37:02 <mmorrow> :)
15:37:03 <bos> ah yes
15:37:20 <bos> i wrote a book chapter about it.
15:37:41 <bos> i think it's a good exercise, albeit a little cheaty.
15:37:50 <BONUS_> why cheat
15:37:51 <BONUS_> y
15:38:05 <bos> since it requires something like the ST monad for efficiency
15:38:26 <vixey> I kind of wish that when they make new libs they could do it with different names
15:38:35 <vixey> instead of trampling over the already existing ones breaking code people wrote
15:38:44 <vixey> I guess I am an idealist ..
15:40:13 <bos> vixey: hm?
15:41:10 <newsham> who ever heard of a library called "frank"?
15:41:36 <bos> it's an abstract sausage generator factory factory.
15:43:46 <BONUS_> man, im gonna have to start doing assembler code again for uni
15:44:16 <BONUS_> ugh, its a big mental step backwards from doing folds and maps to storing bytes to registries
15:44:47 <newsham> doesnt sound very enjoyable when you think of it like that.
15:44:57 <newsham> assembly can be loads of fun, though
15:45:05 <vixey> Can you write some compiler that turns maps and folds into really really efficient assembly? :)
15:45:10 <lament> BONUS_: sideways, not backwards
15:45:14 <BONUS_> haha
15:45:31 <lament> BONUS_: folds are not an abstraction over registers; they're just folds
15:45:43 <lament> or at least that's one way of looking at it
15:45:46 <mmorrow> let go : .... mov ... jmp test ; test ... cmp ... jne go in jmp go  -- asm can be almost haskellish
15:45:54 <BONUS_> thats true, i was looking at how high-level it is
15:46:11 <BONUS_> i prefer my code to be wider than it's long
15:46:16 <lament> haha
15:46:18 <BONUS_> instead of several times longar than it is wide
15:46:20 <Peaker> Who wants to write the X86ASM monad?
15:46:32 <mmorrow> harpy?
15:46:54 <mmorrow> http://code.haskell.org/~morrow/code/haskell/misc/fib.html
15:46:55 <Peaker> Can either emulate the x86 code you write in nice visualizing ways, or generate an .asm/executable
15:46:58 <BONUS_> oh my, an ASM monad
15:47:05 <vixey> argh..
15:47:08 <newsham> http://www.haskell.org/sitewiki/images/1/14/TMR-Issue6.pdf ?
15:47:11 <lambdabot> Title: The Monad.Reader Issue 6
15:47:13 <vixey> any clues about  Undefined symbols: "_inflateInit2", referenced from: _s4t6_info in libHSzlib-0.4.0.1.a(Stream.o)  ?
15:47:19 <Peaker> BONUS_: that could turn an ugly task into a more interesting one :)
15:47:28 <BONUS_> yeah haha
15:47:47 <BONUS_> maybe i can persuade the prof to let me write the assembly monad in haskell
15:47:48 <mmorrow> vixey: oh dear. maybe your libz os too old or too new?
15:47:50 <BONUS_> instead of doing the stuff
15:47:54 <mmorrow> s/os/is/
15:48:00 <newsham> trying to make a tomato into a car isnt very rewarding
15:48:01 <Peaker> BONUS_: you don't need permission if your monad can convert to .asm files :)
15:48:06 <newsham> but they're good in sandwiches
15:48:18 <BONUS_> haha
15:48:28 <vixey> oh I see, I'll try reinstalling zlib
15:48:34 <BONUS_> it might be a different song when i have to write the code with a pencil on the exam
15:49:06 <newsham> just enjoy the assembly for whatit is
15:49:21 <BONUS_> i guess i'll have to make that attempt
15:49:40 <mmorrow> yeah, asm is actually friggin cool. you can /whatever/ you want.
15:50:11 <lament> forth is cooler!
15:50:18 <lament> you can do /whatever/ you want
15:50:20 <newsham> like make an instruction that jumps back into itself and is then a diff instr
15:50:36 <jethr0> yeah, mutating code
15:50:48 <jethr0> way to go, maintainability
15:50:49 <newsham> not mutating, var width
15:50:51 <mmorrow> lament: heh, but can you jmp to an arbitrary other piece of code from an arbitrary piece of code
15:50:52 <mmorrow> ?
15:51:07 <mmorrow> or self-modify?
15:51:13 <lament> mmorrow: you can do anything, to a bigger extent than assembly
15:51:25 <mmorrow> lament: whoa, i've gotta learn forth then :)
15:51:31 <dmwit> Bigger extent than assembly?
15:51:35 <lament> mmorrow: be careful, it might permanently damage your brain
15:51:35 * dmwit somehow doesn't believe that
15:51:36 <Peaker> I used to know how to write small assembly programs in .COM files using only COPY CON :)
15:51:45 <mmorrow> lament: it's too late for that
15:52:00 <fynn> Peaker: you are EVIL!
15:52:07 <lament> dmwit: it's as low-level as assembly, but the language is also self-modifying
15:52:16 <lament> you're not restricted to a small set of instructions
15:52:22 * jethr0 has to concur with dmwit.
15:52:22 <dmwit> lament: It also gets turned into assembly.
15:52:24 <lament> think assembly+lisp
15:52:27 <fynn> everyone I know who did this stuff used it to write viruses to infect his sister's computer.
15:52:32 <Peaker> COPY CON BLAH.COM ; alt-180 [MOV AH,] alt-?? [I forget the quit command] alt-245 (0xCD -- INT) alt-33 (0x21, DOS interrupt)
15:52:43 <dmwit> Anybody who claims their language can do "more than assembly" is just flat wrong.
15:52:51 <mmorrow> lament: but forth surely must use the cpu's instruction set, which asm corresponds to prettyy much 1-to-1
15:53:02 <vixey> :|
15:53:03 <Peaker> I think alt-75 meant quit
15:53:06 <fynn> dmwit: right, that's like saying "my language can do stuff the CPU can't"
15:53:15 <fynn> Peaker: I knew you were evil.
15:53:16 <vixey> I reinstalled the latest one and then reinstalled the haskell zlib..
15:53:24 <vixey> still getting linking errros though
15:53:29 <Peaker> fynn: I didn't have an assembler yet :)
15:53:30 <jethr0> especially since most assemblies have nice "macro" abilities, making it possible to create a "nice low-level DSL" rather easily
15:53:42 <Peaker> fynn: I learnt assembly by looking at codeview and stepping through the code seeing what happened to registers! :)
15:53:50 <mmorrow> vixey: yuk, linker errors are teh most evil
15:53:51 <Dianora> curious, why do you want to learn assembler?
15:54:18 <Peaker> Its interesting to see the lower layers of how a computer works..
15:54:37 <fynn> Peaker: you're just strengthening my original "evil" assessment of your character.
15:54:41 <lament> mmorrow: yes, but do you see how you can do stuff in Haskell that you can't do in assembly?
15:54:55 <jethr0> i came to assembly through trying to circumvent game copy protections (back in the early 90s). and amazingly I managed with a friend to "crack" a game only be looking and tweaking the binary code (i.e. not having decompilers, code stepping, breakpoints, etc.)
15:55:02 <badsheepy> how does haskell do it then :p
15:55:03 <jethr0> don't ask how the hell we managed that ;)
15:55:14 <fynn> Dianora: there's a claim going around that one of the most important things most high-level programmers can do to improve their skills is to learn assembly and low-level computer architecture.
15:55:15 <lament> mmorrow: by "doing stuff" i mean "expressing concepts" of course
15:55:33 <mmorrow> lament: i see what you're trying to say, and i agree to an extent, but haskell code must be translated to asm eventually
15:55:38 <mmorrow> yeah
15:55:41 <lament> mmorrow: so?
15:55:50 <Dianora> Most people do not need to know assembler.
15:55:55 <mmorrow> so, that means that asm can do anything haskell can and more :)
15:56:03 <badsheepy> most people dont need to know any language whatsoever :p
15:56:09 <lament> mmorrow: in forth, assuming it doesn't have a while loop already, you can create your own while loop. You can't do that in assembly.
15:56:09 <Dianora> It's ok to have an appreciation for what goes on yes
15:56:10 <mmorrow> (it'll just take an extremely large amount of work)
15:56:20 <Dianora> but to learn hard core assembler? I don't quite understand the purpose.
15:56:22 <Peaker> jethr0: I cracked a dongle check upon my school teacher's request, also with a primitive asm debugger :)
15:56:25 <fynn> Dianora: how can you fully understand optimization without knowing assembler?
15:56:37 <Dianora> fynn: No, not in my opinion.
15:56:49 <fynn> now?  that was a "how" question ;)
15:56:49 <mmorrow> lament: you can if you think about the asm code not as single instructions but larger abstract concepts
15:56:50 <Peaker> Dianora: knowledge does not corrupt :)
15:56:53 <Dianora> fynn: but unless you are writing the optimising compiler, it's really pointless.
15:57:00 <fynn> Peaker: your knowledge does
15:57:01 <jethr0> Peaker: amazing what people (especially teenagers) can do with excessive time on their hands ^_^
15:57:02 <Dianora> Peaker: Ah, but it has to be for the right reasons.
15:57:15 <mmorrow> lament: i think we agree, but are arguing about different things :)
15:57:33 <BONUS_> in most CS unis oyu dont have a choice of learning ASM or not anyway
15:57:34 <BONUS_> soo
15:57:37 <fynn> Dianora: nah, I maintain that even in very high level languages, you only vaguely understand optimization if you don't know low-level assembly
15:57:47 <lament> mmorrow: no, i actually don't think we agree; i never agree with anyone who says "haskell is ultimately assembly" or "human beings are ultimately atoms" or any other reductionist nonsense like that :)
15:57:53 <Peaker> Dianora: why? knowledge for the wrong reasons also helps :)
15:58:06 <fynn> you can sort of understand, sure, and you can even be good at optimization. but you don't really understand what you're doing.
15:58:15 <Dianora> Peaker: I worry about people who think they can write better code than the compiler on modern RISC machines by learning asm.
15:58:33 <Peaker> Dianora: if they learn assembly very well, then either they won't think that, or they will be right
15:58:34 <Dianora> Peaker: I do not worry about the people that learn assembler so they understand why they can't write better code.
15:58:35 <mmorrow> lament: ok
15:58:53 <vixey> but with something like haskell, can't I leave all low level optimization to the compiler, only doing algorithmic optimization myself
15:58:54 <vixey> ?
15:59:02 <Dianora> Peaker: I know quite a few machines/assemblers some I am a bit rusty at.
15:59:04 <jethr0> let's all agree that brainf*ck together with ASM and haskell is turing-complete and it's all a question of how comfortable it is to program certain solutions.....
15:59:13 <Peaker> Dianora: maybe their knowledge of assembly will allow them to compare their Haskell program to a C one, and understand why performance differs
15:59:15 <Dianora> Peaker: Just don't misunderstand where I am coming *from*.
15:59:45 <jethr0> vixey: no, you'll still have to think about space leaks and to some degree performance issues.
15:59:49 <mmorrow> yes, being turing complete makes them equivalent. this is how i mean haskell and asm are the same thing.
16:00:00 <Peaker> Dianora: I don't think a lot of people try to hand-write ASM code for optimization these days, and those that do, probably do know what they're doing
16:00:07 <jethr0> but hopefully the compiler does a lot of pipelining, register allocation, data flow analysis for you
16:00:08 <Dianora> Peaker: I agree, learning at least one assembler language and understanding basic machine operations does wonders for anyone.
16:00:13 <vixey> jethr0: Yeah, that's all algorithmic
16:00:26 <fynn> Dianora: see?  so how exactly are you disagreeing with us?
16:00:28 <Dianora> Peaker: and I see where you are going with your argument. You might be right.
16:00:32 <pedrob> Hi, is there an Haskell lib for IRC?
16:00:37 <lament> haskell and asm are not equivalent, can you blank all your RAM and then physically damage some hardware in Haskell?
16:00:40 <Dianora> fynn: I was trying to make sure what was being said ;-)
16:00:40 * ivanm finds this new "Learn You a Haskell for a Great Good" tutorial slightly disturbing...
16:00:46 <jethr0> @google haskell irc library
16:00:54 <lambdabot> No Result Found.
16:01:00 <mmorrow> lament: exactly! this is how i mean that asm can do things haskell can't
16:01:01 <ivanm> lament: lol
16:01:06 <fynn> lament: you can damage hardware with asm?
16:01:13 <Dianora> fynn: yes you can
16:01:14 <ivanm> @remember lament haskell and asm are not equivalent, can you blank all your RAM and then physically damage some hardware in Haskell?
16:01:14 <lambdabot> It is stored.
16:01:15 <lament> fynn: sometimes.
16:01:18 <Dianora> depending on the machine
16:01:20 <mmorrow> i think you can destroy monotors
16:01:21 <Dianora> you can sometimes
16:01:23 <mmorrow> s/o/i/
16:01:25 * fynn learns assembly and becomes evil like Peaker 
16:01:32 <Dianora> mmorrow: that was the traditional thing people could do yes
16:01:32 <lament> you can destroy hard drives by having them spin at resonance frequency
16:01:37 <pjdelport> lament: sure you can
16:01:38 <fynn> Dianora, lament: how?  blanking writable bios?
16:01:41 <Dianora> by setting a bogus frequency on the monitor
16:01:43 <vixey> I wonder if this is zlibs fault or agdas
16:01:50 <Dianora> thus cooking it
16:01:52 <jethr0> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/irc
16:01:53 <lambdabot> Title: HackageDB: irc-0.4.3
16:01:54 <pjdelport> lament: in Haskell, everything is just one unsafePerformIO away
16:01:55 <Dianora> I doubt you could cook a modern LCD
16:01:56 <Peaker> fynn: I think the insane amounts of knowledge found in #haskell about high-level Haskell and mathematics is far more evil
16:01:57 <ivanm> you can even destroy hardware with a kernel! :p
16:02:01 <Dianora> but anything is possible.
16:02:05 <jethr0> also, lambdabot handles some of irc
16:02:07 <ivanm> (the latest intel 1000e bug in the linux kernel)
16:02:16 <fynn> Peaker: I have yet to experience such moments ;)
16:02:33 <fynn> although maybe the problem is that I phase out as soon as someone pastes terse code.
16:02:47 <fynn> I'm not nearly good enough to understand Cale's pastes etc.
16:02:56 <mmorrow> Dianora: yeah, i think it only works with moitors with electron guns
16:03:06 <jethr0> supposedly a sane operating system would prevent the user (especially non-super-users) from destroying hardware
16:03:35 <ivanm> jethr0: wouldn't that require the OS to know every single possible "bad" command though?
16:03:38 <Peaker> fynn: Cale, quicksilver and others are all far more evil :)
16:03:48 <jethr0> it was very different in the good ol' DOS times when everybody could do everything (like setting the HDD read head to sector 0)
16:03:50 <vixey> oh
16:04:08 <vixey> do I have to use cabal to compile zlib 0.4.03, and cannot use runhaskell Setup.hs ?
16:04:15 <fynn> Peaker: yeah, I should learn enough Haskell to actually understand what those guys are pasting
16:04:17 <jethr0> ivanm: no, you just need to restrict access to random memory and especially mapped hardware addresses
16:04:25 <ivanm> vixey: cabal-install is just a wrapper for runhaskell Setup.hs, etc.
16:04:38 <ivanm> which also downloads and builds dependencies, etc.
16:04:42 <vixey> even if there are c files around there
16:05:08 <ivanm> jethr0: so you can guarantee that that's the only way to do damage to hardware?
16:05:22 <jsn> well, the driver should not allow that
16:06:00 <ivanm> vixey: hmmmmm....... seeing as how I've only recently started using the runhaskell method (and that was only to prevent cabal from rebuilding libs that I'd installed globally), I wouldn't know :p
16:06:01 <jethr0> ivanm: huh? i said "a sane OS should prevent it". and i meant that it would do it by only exposing restricted commands to the user, which are supposed to not cause any hardware damage
16:06:02 <vixey> can someone please tell me how to fix "ghc-pkg describe * failed. If you are using ghc-6.9 and have an empty user package database..."?
16:06:18 <jethr0> s/to not/not to/
16:06:20 <vixey> ivanm: yeah me neither
16:06:21 <mmorrow> vixey: use the --global package db?
16:06:54 <mmorrow> (i never use the local one though, so i'm not sure the fix if you want to use that)
16:07:07 <ivanm> mmorrow: well, if you do it as local user it shows both (at least with 6.8)...
16:08:07 <mmorrow> ivanm: hmm, that's sounds like it's probably the problem then in >=6.9 ... i guess it doesn't
16:08:25 <mmorrow> (but again i never use the local one, so i'm just guessing)
16:15:25 <vixey> ughhhhh
16:15:32 <vixey> zlib.h:#define inflateInit2(strm, windowBits) \
16:15:42 <vixey> Codec/Compression/Zlib/Stream.hsc:foreign import ccall unsafe "zlib.h inflateInit2"
16:15:46 <vixey> this is ridiculous
16:15:58 <vixey> how the hell is that mean to work
16:16:33 <vixey> software--
16:16:49 <mmorrow> hackingshoes++
16:17:35 <mmorrow> vixey: try grepping zlib.h to find what you need to change "inflateInit2" to
16:17:46 <vixey> yeah I have to edit this c code to make this stuff work :/
16:17:51 <mmorrow> hehe
16:18:40 <ddarius> Programmers best get used to working in many disparate languages simultaneously.
16:18:54 <vixey> fixing this crap used to be fun when I didn't know wtf I was doing
16:20:15 <mmorrow> cursing audibly is necessary while doing things like this
16:21:15 <Peaker> vixey: if you don't know what you're doing, you're learning. Not learning is not fun
16:22:05 <fynn> yeah, which is what he said :)  he liked hacking C when he was learning C
16:22:12 <fynn> I felt the same way about Java.
16:22:27 <mmorrow> (she ;)
16:22:41 <Peaker> C is somewhat fun.  Could be nicer if it didn't screw up pointer syntax and array values
16:22:54 <fynn> but then it wouldn't be craaaazy
16:23:09 <fynn> and people who program it couldn't possibly grow foot long beards.
16:23:31 <fynn> because they wouldn't be men enough.
16:23:54 <mmorrow> i don't get when people say that pointers are "low level". imo they're a brilliantly simple yet powerful abstraction
16:24:04 <dons> with hardware support
16:24:47 <mmorrow> if only all abstractions had hardware support...
16:24:48 <lament> mmorrow: they're not much of an abstraction, that's why
16:24:50 <vixey> I think it's generally true since you have them in C and stuff
16:24:56 <mmorrow> FPGAs are teh future!
16:24:59 <vixey> but in ATS I gues you could say they are high level
16:25:10 <lament> MVars are high-level :)
16:25:16 <jsn> mmorrow: they are not an array abstraction, though
16:25:22 <nicknull> is "a pearl of wisdom" ironic?
16:25:34 <nicknull> http://arclanguage.org/item?id=722
16:25:38 <lambdabot> Title: Arc Forum | How would this Arc program be translated into other languages?
16:25:38 <nicknull> serveAs "said" $ hasIndex $ \x -> "click me" `linksTo` (text ("You said " ++ x))
16:25:43 <nicknull> who was that?
16:25:48 <nicknull> and what webframework is it?
16:25:57 <mmorrow> lement: arrows to arrows to ... is pretty ubiquitous in mathematics
16:26:06 <nicknull> made up?
16:26:20 <lament> mmorrow: sure, but that's not what pointers are
16:26:27 <mmorrow> yes it is :)
16:26:38 <mmorrow> (that's how i see them)
16:27:06 <lament> mmorrow: pointers are things you can do pointer arithmetic with; references are "arrows"
16:27:08 <vixey> yay!
16:27:13 <vixey> I finally got everything to compile
16:27:21 <lament> mmorrow: it's the arithmetic that makes pointers "low-level"
16:27:22 <mmorrow> lament: ****p
16:27:26 <Peaker> I think the difference between reference and pointer, is that a pointer can be referred to
16:27:41 <Peaker> (the pointer is itself an object)
16:27:43 <vixey> void *x = &x;
16:27:45 <mmorrow> lament: ok, i guess i'm not refering to that aspect of ptrs then
16:27:59 <vixey> now what was I doing ...
16:28:07 <lament> mmorrow: ah, but that aspect is crucial - without it, you can't have buffer overflows
16:28:25 <mmorrow> lament: what fun would puters be then!!?
16:28:31 <lament> right, exactly
16:28:34 <mmorrow> heh
16:28:54 <Peaker> with forward growing stacks, buffer overflows aren't that useful either :)
16:29:10 <sbahra> Peaker, except you have pointer overwrites.
16:29:35 <vixey> You can avoid buffer overflows and all this with a sufficiently terrifying type system from /that/ end of the cube
16:29:46 <vixey> that is what I meant about ATS earlier
16:30:04 <lament> can't sleep, the pointers will eat me
16:30:42 <vixey> @seen dcoutts
16:30:42 <lambdabot> I saw dcoutts leaving #ghc, #haskell, #gentoo-haskell and #haskell-soc 16h 2m 37s ago, and .
16:30:43 <int-e> throw sugar lambdas at the pointers
16:32:01 <mmorrow> int-e: be prepared for the inevitable retaliatory assault with pointy lambdas
16:38:17 <newsham> peaker: not true. buffers are often in a callers activation frame
16:38:33 <newsham> so even if the stack grows up, there is important data that is writable
16:38:52 <Peaker> newsham: true, didn't think of that
16:39:02 <newsham> dont worry, the attackers have :)
16:39:23 <Peaker> newsham: They also overwrite glibc's malloc-management pointers to get arbitrary code to run somehow, so buffer overflows on the heap also work
16:40:19 <newsham> if the malloc metadata is inline with the allocated data, you can overwrite the metadata.  if that data has linked lists, then you can overwrite the link pointer and cause arbitrary other addresses to be written to
16:40:53 <Adamant> basically, any even semi-arbitrary write = bad
16:40:55 <Peaker> newsham: I think its simpler than that though, I think maybe there're function pointers in there for some reason. I'm not sure though
16:41:08 <newsham> if malloc metadata is not inline, then you can still try to manipulate other data n the heap, but thats more app specific
16:41:21 <nicknull> how can i check if the stack is growing ina haskellprogram?
16:42:13 <nicknull> function pointers are fun, i made a destructive map some days ago. im too affected by haskell
16:42:22 <newsham> peaker: i think the standard malloc attack is overwritting a link pointer to point to a GOT entry (used for ELF dynamic linking), and have that GOT overwritten to point to code you provided
16:42:34 <newsham> but honestly I dont follow details of heap exploits that much
16:42:38 <Peaker> newsham: Windows is so horrible though that you don't even need buffer overflows. Any app can send messages to any other, and the DefaultWinProc that handles them generally does very stupid things like jump to arbitrary addresses in these messages
16:42:57 <Peaker> newsham: ah, interesting
16:42:57 <newsham> thats not entirely true anymore.
16:43:08 <newsham> vista has seggregated the windows messaging a little I believe
16:43:13 <Peaker> newsham: they're fixing these issues one by one as they're discovered
16:43:28 <Peaker> Maybe, I haven't kept up to date with Vista :)
16:43:43 <newsham> s'ok, nobody willingly installs vista
16:43:54 <newsham> and now we're thoroughly off-topic :)
16:44:02 <Peaker> Windows is legacy software for most hobby programmers by now, probably
16:44:15 <Peaker> How many in #haskell use Windows?
16:44:16 <newsham> still 90% market share.
16:44:20 <newsham> i'm on winxp right now
16:44:32 <Peaker> Why?
16:44:38 <newsham> work laptop.
16:44:49 * ddarius dual boots Windows, but doesn't usually use it.
16:44:54 <BONUS_> im on windows right now because i need photoshop
16:44:55 <Adamant> newsham: the Mac heads haven't gotten to you yet?
16:44:55 * ddarius uses Windows daily for work.
16:44:56 <Peaker> why not install Ubuntu on your work laptop? :)
16:44:57 <BONUS_> but i prefer linux
16:44:59 <newsham> ddarius inhaled once but didnt really like it
16:45:18 <newsham> adamant: soon enough, they're gaining 2% market share per year.
16:45:20 <Peaker> I dual boot Windows for my Starcraft addiction
16:45:34 <BONUS_> also games, yes
16:45:42 <newsham> peaker: i have ubuntu in a vmware, as well as freebsd and fedora and lots of other stuff
16:45:47 <sjanssen> Peaker: doesn't wine run that yet?
16:45:48 <ddarius> newsham: If 50 years they'll have > 100% market share
16:45:48 <newsham> and i run freebsd on my server
16:46:08 <newsham> ddarius: true, assuming the partial derivative is a constant.
16:46:16 <Adamant> newsham: ah, I just thought everyone in security was on a Mac at this point.. which is funny for other reasons.
16:46:19 <newsham> (its actually accelerating)
16:46:45 <Peaker> sjanssen: not very well
16:46:57 <Peaker> sjanssen: multiplayer barely works, and its very unstable
16:46:58 <mmorrow> vmware is suprisingly fast
16:47:07 <ddarius> mmorrow: Why wouldn't it be?
16:47:24 <Adamant> campuses have already been invaded in full, it's like 50%/50% even at the non-hoity-toity colleges.
16:47:27 <newsham> i had a mac laptop here for a few months for a gig i was working on, but had to send it back.
16:47:32 <Adamant> ah
16:47:33 <newsham> seems like a decent enough system
16:47:41 <mmorrow> i believe vmware rewrites machine code on the fly
16:47:59 <Adamant> only thing I wish is that it was as tough as a Toughbook
16:48:09 <newsham> mmorrow: i think for the kernel-mode stuff they use dynamic translation, but for userland code they can run it unmodified?
16:48:12 <Peaker> vmware is the new standard executable format (soon)
16:48:13 <Adamant> which is decidedly not the case.
16:48:18 <nicknull> Sweden will invade USA tomorrow
16:48:18 <nicknull> take your women and your gold
16:48:21 <Peaker> (a vmware image)
16:48:46 * ddarius has no women or gold
16:48:54 <Adamant> nicknull: the real Vikings are here in the US now and listening to Garrison Keillor
16:49:01 <mmorrow> newsham: i'm not sure the particulars, but it's definitely on my to-look-into list
16:49:02 <newsham> ddarius: i hear there's a man-drought in australia
16:49:13 <Peaker> there's also a water-drought in Australia
16:49:24 <newsham> mmorrow: there's an academic paper on the subject that vmware wrote
16:49:36 * mmorrow uses the googlemachine
16:50:02 <nicknull> control.monad shouldi qualify it?
16:50:30 <nicknull> which modules dont need to be qualified(ie no risk of name-clashes)?
16:50:43 <sjanssen> nicknull: Control.Monad should be safe
16:50:56 * Peaker thinks everything should be qualified or (named explicitly in parens)
16:51:05 <Peaker> Python imports are great
16:51:23 <ddarius> newsham: I heard that too
16:51:24 <sjanssen> nicknull: the ByteStrings, the Sets and the Maps are the major ones
16:51:50 <newsham> "gold coast" + women
16:52:02 <Peaker> the "M" inside names should have been a hint that it really wants to be qualified instead
16:52:03 <mmorrow> "but you'll be thirsty"
16:52:20 <ddarius> Peaker: Not really.
16:52:23 <Adamant> I think a whole bunch of Aussies moved out to Western Australia due to the mining that's been going on
16:52:36 <nicknull> im reading 50 files, several megs of data and python beats haskell
16:52:44 <Peaker> ddarius: why not?  import qualified Control.Monad as M ; M.for  instead of forM
16:52:50 <newsham> adamant: uranium?
16:52:59 <Adamant> newsham: among other things
16:53:08 <Peaker> nicknull: beats it in what?
16:53:10 <Adamant> gold and probably some fancier stuff as well
16:53:17 <mmorrow> nicknull: then you're doing it wrong :) (are you using ByteStrings?)
16:53:56 <nicknull> no bytestrings, i know but do they make usch a diff?
16:54:03 <mmorrow> omg
16:54:08 <mmorrow> HUGE diff
16:54:10 <newsham> nick: "depends", but mostly yes.
16:54:44 <Peaker> nicknull: Strings are linked lists of 32-bit unicode code points. In a 64-bit system, an ascii string will take 12 bytes for each 1 byte
16:54:45 <mmorrow> there's also a bytestring-mmap package which may or may not be applicable to your current situation
16:55:01 <ddarius> Peaker: Typically identical names in different scopes are almost substitutible (or entirely unrelated).  mapM and map are related but still significantly different.  There's also the convention of appending underscores and 's, e.g. mapM_, should we have another scope for that?
16:55:02 <mmorrow> (linux only i believe (?))
16:55:24 <Dianora> bsd as well
16:55:32 <Dianora> probably all the *nix
16:55:41 <mmorrow> oh yeah, s/linux/*nix/
16:55:56 <nicknull> Data.Char8.Bytestring ?
16:55:57 <Dianora> I am running FreeBSD 7.1 on my desktop
16:55:58 <mmorrow> s/*nix/everything but windows/ :)
16:56:07 <Dianora> I really should upgrade my server as well.
16:56:11 <badsheepy> does anything actually use 32bit unicode :o
16:56:14 <Peaker> ddarius: I wouldn't say they're entirely unrelated.. Data.List.names are related to similar Prelude.names
16:56:15 <nicknull> Data.Char8.ByteString ?
16:56:25 <Dianora> badsheepy: When they are doing chinese? ;-)
16:56:33 <nicknull> i still think it is a ridic amount of importing in haskell
16:56:34 <sjanssen> Peaker: there are no clashing names between Prelude and Data.List
16:56:37 <badsheepy> isnt chinese usable in utf-16?
16:56:44 <mmorrow> utf8 can encode all of utf8-32
16:56:45 <nicknull> if i always use Map List Maybem, why cant they be there?
16:56:50 <Peaker> ddarius: The relation between map and M.map is clear from the similar name, and the underscore doesn't currently get a module, so it probably wouldn't anyway
16:56:56 <ddarius> Peaker: I didn't say entirely unrelated in that context, and Data.List names are almost substitutible with e.g. ByteString names.
16:57:08 <mmorrow> , utf8enc [maxBound::Char]
16:57:10 <Dianora> There are a lot of purists who do not want to see glpyhs simplication..
16:57:14 <lunabot>  "\244\143\191\191"
16:57:17 <Dianora> glyph simplification
16:57:20 <Peaker> sjanssen: yeah, because the Prelude stuff is about lists, so Data.List doesn't have to include it :)
16:57:26 <ddarius> The relationship between map and mapM is also clear from the name, that doesn't gain anything.
16:57:47 <Peaker> ddarius: qualified imports gain a lot over unqualified imports
16:57:53 <Peaker> ddarius: so you gain all that
16:58:28 <ddarius> Peaker: Often they do.  I'm saying in this case you don't gain much at best, you might even be worse off.
16:58:41 <mmorrow> <mmorrow> utf8 can encode all of utf8-32
16:58:42 <mmorrow> heh
16:58:55 <mmorrow> s/utf8-32/utf32/
16:59:08 <Peaker> ddarius: if I have more than 1 unqualified import (and if considering Prelude as a default unqualified import, the first explicit one is already more than 1), I have a hard time figuring out where names are coming from
16:59:22 <Peaker> ddarius: M.for is pretty much the same as forM, except I know exactly where its coming from
16:59:59 <nicknull> whre are bytestrings?
17:00:06 <Peaker> @hoogle ByteString
17:00:06 <lambdabot> module Data.ByteString
17:00:06 <lambdabot> module Text.Parsec.ByteString
17:00:06 <lambdabot> Data.ByteString data ByteString
17:00:11 <newsham> dianora: same dianora from efnet #bsd many years ago?
17:00:24 <ddarius> Peaker: You can write M.forM
17:00:47 <ddarius> My point is that the M convention isn't solely to avoid conflicts.
17:00:48 <Dianora> yes I'm that same Dianora
17:00:53 <newsham> hi.
17:01:14 <Dianora> someone suggested I should show up here. so I did.
17:01:23 <vixey> hi Dianora
17:01:30 <Dianora> hi vixey.
17:01:31 <vixey> :)
17:01:46 <ddarius> (or even primarily to avoid conflicts, there is no "for" function)
17:01:52 <Dianora> I'm on a rather too many channels, I sometimes get confused. ;-)
17:02:12 <Peaker> ddarius: ok, I don't mind that much.  I do hate not having any clue where names are coming from. Its very annoying, and makes editor support for "jump to definition" harder too
17:03:39 <DuClare> Uhh.  Can't I pattern match a constructor and bind it to a variable as a whole, instead of having to bind each component?
17:03:45 <vixey> yes you can
17:03:52 <DuClare> How?
17:04:01 <Peaker> DuClare: blah@(Constructor _ _ _)
17:04:09 <DuClare> Right!
17:04:21 <vixey> > let test variable@Just value = (variable,value) in test (Just 3)
17:04:22 <lambdabot>       Constructor `Just' should have 1 argument, but has been given 0
17:04:22 <lambdabot>      In...
17:04:28 <vixey> > let test variable@(Just value) = (variable,value) in test (Just 3)
17:04:29 <lambdabot>   (Just 3,3)
17:04:41 <badsheepy> its sad when the answer makes no sense, but neither does the question :( i needs to read more :p
17:05:10 <cddr> what's the recommended library for processing xml in haskell?
17:05:37 <sm> Text.XHtml or tagsoup I believe
17:05:40 <cddr> hxt?
17:07:20 <DuClare> Uhuh, not very neat. :x
17:07:40 <DuClare> Oh.
17:08:32 <DuClare> Better than making a new type.
17:09:35 <gwern> @seen dons
17:09:35 <lambdabot> dons is in #xmonad, #haskell, #ghc, #darcs and #arch-haskell. I last heard dons speak 45m 31s ago.
17:10:20 <gwern> @ask dons 1) hackage bytestring has some messedup haddocks - http://hackage.haskell.org/packages/archive/bytestring/0.9.1.3/doc/html/Data-ByteString-Lazy.html says things like 'O(1) Unlike cons, 'cons\'' is strict in the ByteString that we are consing onto. ' & ' let xs = cons\' c xs in xs'
17:10:20 <lambdabot> Consider it noted.
17:11:19 <gwern> @ask dons also, I've been wondering for a while, why is Data.ByteString.Lazy missing some functions like lines, unlines, and words? when it has almost all the others
17:11:20 <lambdabot> Consider it noted.
17:11:27 <gwern> so. evening everyone
17:11:32 <gwern> any news?
17:11:58 <vixey> hi gwern
17:13:15 <mmorrow> http://www.vmware.com/pdf/asplos235_adams.pdf
17:13:17 <lambdabot> Title: A Comparison of Software and Hardware Techniques for x86 Virtualization
17:13:28 <gwern> (the only thing new with me is that I've been pondering a simple WYSIWYG HTML editor for incremental reading, but that sounds so hard I'm not sure I want to start)
17:14:29 <gwern> I am considering beating ninja gaiden on hard with the equivalent amount of effort :)
17:14:30 <dons> gwern: in .Char8
17:14:31 <lambdabot> dons: You have 6 new messages. '/msg lambdabot @messages' to read them.
17:14:39 <gwern> *equivalent amount of effort that would take
17:14:48 <sm> evening gwern .. incremental reading ?
17:14:59 <gwern> dons: yes, but char8 requires the sacrifice of UTF8 AFAIK, and I'd like to avoid that
17:15:34 <newsham> gwern: http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString-Lazy-Char8.html
17:15:37 <lambdabot> Title: Data.ByteString.Lazy.Char8, http://tinyurl.com/5ulkmj
17:15:55 <ivanm> dons: with your mkcabal app, why does it provide options for GPL-3 and GPL-2, when cabal only supports GPL?
17:15:56 <gwern> sm: a technique for turning texts into flashcard questions; I'm having such a difficult time understanding what exactly it is, because the proponents aren't very clear about it, and I figure re-implementing it is certainly one way to learn whether it's any good
17:15:57 <newsham> has lines and unlines
17:16:16 <gwern> newsham: I know that
17:16:21 <mmorrow> vixey: were you able to get that zlib problem resolved?
17:16:24 <sm> is that connected to wysiwyg html editors ? not directly I supposed
17:16:29 <vixey> mmorrow: yeah I was
17:16:35 <mmorrow> vixey: nice.
17:16:37 <sm> I'm always looking for a better one of those
17:16:42 <newsham> gwern: then why did you ask dons?  I'm confused
17:16:42 <mmorrow> vixey: how?
17:16:43 <vixey> so now I'm just playing in Agda
17:16:48 <gwern> newsham: see https://secure.wikimedia.org/wikipedia/en/wiki/User:Gwern/Archive-bot.hs
17:16:52 <lambdabot> http://tinyurl.com/6ll2q9
17:16:55 <vixey> I actually didn't so much fix the problem as sweep it under the rug
17:17:17 <mmorrow> vixey: if agda is working, problem solved :)
17:17:30 <vixey> I edited the .hsc file so that it basically shut up
17:17:37 * edwardk waves hello.
17:17:40 <edwardk> @seen bos
17:17:40 <lambdabot> bos is in #ghc and #haskell. I don't know when bos last spoke.
17:17:41 <vixey> hiya :)
17:17:42 <gwern> sm: well, it seems the fundamental idea is that supermemo uses the IE engine to display HTML docs, and HTML-ized stuff, but it hacks it up such that you can 'edit' the HTML page and delete stuff and eventually reduce any encyclopedia article or whatever into a list of question/answer pairs and the like
17:17:48 <mmorrow> vixey: good show
17:17:48 <gwern> sm: if that makes sense
17:18:05 <sm> I see!
17:18:16 <gwern> sm: obviously I thought about doing some sort of Yi mode, but then you don't get the eye-pleasing markup, just colored text at best
17:19:01 <edwardk> how well or does darcs interact with .htaccess?
17:19:08 <sm> we need a webkit/gecko/chrome in haskell, plainly
17:19:21 * gwern still isn't sure how a haskell incremental-reader would work. perhaps one would hook together pandoc and firefox? dunno
17:19:30 <newsham> gwern: i dont see why utf8 shouldnt work with Data.ByteString.Lazy.Char8,  however, it wont be a byte string of characters
17:20:06 * sm fiddles around with web presence at http://joyful.com/hledger
17:20:07 <lambdabot> Title: hledger
17:20:29 <newsham> since some characters will be made of several Word8 units
17:20:32 <mmorrow> yeah, utf8 works fine with ByteStrings... they're just an array of bytes
17:20:48 <mmorrow> but yeah, utf8 chars can be 1,2,3, or 4 bytes long
17:21:04 <gwern> I am reasonably sure my archive-bot mangles page names and URLs and wikitext with utf8 in'em
17:21:16 <sm> edwardk: I think it would respect it, like any http client, if the server is working right
17:21:27 <mmorrow> , utf8enc "âˆ€"
17:21:29 <lunabot>  "\226\136\128"
17:21:33 <mmorrow> , utf8enc "a"
17:21:35 <lunabot>  "a"
17:21:40 <edwardk> sm: i'm just curious if the darcs pull will prompt for user and pass
17:21:40 <mmorrow> , utf8enc [maxBound::Char]
17:21:42 <lunabot>  "\244\143\191\191"
17:21:43 <gwern> mmorrow: incidentally, did you know your mueval parsing code doesn't seem to handle qualified imports happily?
17:21:48 <sm> ah.. good question
17:21:57 <gwern> mmorrow: I was about to email you over that, but since you're here...
17:22:00 <Peaker> I finally fully understand how Reactive implements future values based on threads. Its pretty simple, and I'm not sure why I did not understand it before
17:22:16 <mmorrow> gwern: well of course it doesn't :) since it explicitly checks the qualified name against your whitelist
17:22:21 <vixey> Peaker: how does it work? :))
17:22:45 <gwern> mmorrow: yes, but now that hint supports qualified imports, I've wanted to make mueval support'em
17:22:58 <mmorrow> gwern: apparently though, checkNames isn't even needed since the blacklist isn't even in scope in the first place
17:23:00 <gwern> and I think I've got all the pieces done except the parser rejects'em all
17:23:01 <edwardk> sm: heh just testing it. one sec =)
17:23:05 <Peaker> vixey: A Future is  data Future a = IO a -- The action here is always a readMVar from whoever writes the future value
17:23:30 <Peaker> vixey: newFuture creates (Future a, IO a) which are the future reader and a "sink" that is the writeMVar into the future
17:23:36 <mmorrow> gwern: so you should just scrap checkNames altogether (imo)
17:23:38 <gwern> mmorrow: you think the parser should be removed entirely?
17:24:01 <mmorrow> yeah, i can't see any reason for it since nothing bad is in scope
17:24:19 <mmorrow> plus, then you don't have to depend on haskell-src-exts
17:24:32 <gwern> true
17:24:36 * gwern will do't
17:24:37 <mmorrow> win-win
17:24:38 <mmorrow> nice
17:24:46 <Peaker> vixey: future is a function that takes an action, and builds a future whose sink is feeded the result of given action. It uses unsafePerformIO so that forcing the resulting future will actually block
17:25:00 <mmorrow> whoa, you say hint does qualified imports now?
17:25:14 <vixey> oh I think I get it
17:25:22 <gwern> mmorrow: yes
17:25:24 <Peaker> vixey: I think that was the main thing that confused me-  how he generates a future value that blocks magically when you look at it
17:25:29 <vixey> do you have any neat example of using a future?
17:25:41 <mmorrow> gwern: excellent. how does it do them?
17:25:53 * mmorrow gets the hint code to see
17:25:55 <gwern> mmorrow: incidentally, mueval has a HCAR.tex now if you have anything to add to the description
17:26:01 * gwern isn't entirely sure
17:26:17 <mmorrow> gwern: nice, i will. link?
17:26:27 <Peaker> vixey: I've never used Reactive yet.. I think they're used to represent the next event/reactive value. I think a recursive type lets you chain futures into a Reactive value (a value that changes over time)
17:26:48 <gwern> mmorrow: in the repo
17:26:54 <mmorrow> ah, cool
17:27:31 <edwardk> ah score. it does work. you just have to include the username/password in the url
17:27:58 <edwardk> darcs get http://user:pass@example.com/whatever works
17:28:20 <Peaker> @hoogle Reactive
17:28:20 <lambdabot> package reactive
17:28:29 <dolio> vixey: You know how to type logical not in the Agda input mode?
17:28:55 <sm> edwardk: cool
17:29:01 <sm> what happens if you don't ?
17:29:18 <vixey> dolio: this Â¬ ? I just type option-l
17:30:21 <dolio> Yeah, that's the symbol I'm looking for.
17:30:33 <dolio> Apparently \lnot isn't where they've hidden it.
17:30:37 <mmorrow> gwern: also, i've gather from seeing various discussions that lambdabot has a bunch of good errormsg parsing/cleaning code which may be nice to incorporate into mueval.
17:30:53 <mmorrow> *gathered
17:30:53 <edwardk> the only problem with that is that it clearly drops that username and password in _darcs/prefs/repos and defaultrepo. ok. sticking with ssh! =)
17:31:04 <gwern> mmorrow: indeed? any idea what kind?
17:31:12 <vixey> can't alt-l do it?
17:31:28 <sm> oops. you could mention this in a short email to bugs@darcs.net
17:31:31 <mmorrow> gwern: i'm not sure exactly what or where, just that it apparently exists (in the lambdabot repo code i believe)
17:31:35 <dolio> Not for me.
17:31:39 <edwardk> yeah i probably should
17:32:01 <edwardk> ideally it would just notice the 'auth required' and prompt you for the username/password ala the ssh connection
17:32:30 <sm> I agree
17:35:32 * gwern growls at a hint bug. how I hates them!
17:35:44 <gwern> ghc api bugs are some of the most frustrating to deal with
17:38:16 <dons> gwern: re. error parsing, the Eval.hs module had a nice function for polishing up output of an evaluator
17:38:27 <dons> i'd imagine you could reuse all that clever regex work
17:38:43 <gwern> dons: was it dependent on a particular output format?
17:39:16 <dons> String -> String, assumed it was parsing ghc error messages
17:40:17 <gwern> hm, that'd apply to some of them I suppose
17:40:33 <mmorrow> dons: is that particular code gpl?
17:40:54 <dons> mm. no?
17:41:03 <mmorrow> cool
17:41:33 <mmorrow> oh, huh, i though lambdabot was gpl
17:41:36 <mmorrow> i guess not..
17:41:43 <mmorrow> http://code.haskell.org/lambdabot/LICENSE
17:42:26 <nicknull> im tryong to create the lisp-function when
17:42:49 <nicknull> is that oossible or even needed?
17:43:01 <Peaker> Conal's blog explanation of the Reactive implementation is so much clearer for me than the PDF.  Maybe its the use of Haskell syntax instead of unicode greek :)
17:43:07 <mmorrow> err, actually it looks like Eval.hs is gpl? http://code.haskell.org/lambdabot/Plugin/Eval.hs
17:43:21 <mmorrow> which would make lambdabot gpl?
17:43:57 <gwern> @hoogle when
17:43:57 <lambdabot> Control.Monad when :: Monad m => Bool -> m () -> m ()
17:44:06 <gwern> mmorrow: 'twould seem so.
17:44:15 <gwern> haskellers sure are casual about their licensing
17:44:32 <dons> it's BSD if you want
17:44:37 <dons> free the code!
17:44:41 <Peaker> you can lazily choose the license upon litigation
17:45:09 <Dianora> no offense meant to anyone
17:45:15 <Dianora> but I am sick and tired of the licence wars.
17:45:31 <Dianora> which is why I licence my code under the chocolate licence now.
17:45:39 <Dianora> because I don't drink beer.
17:46:00 <gwern> Dianora: 'You may not be interested in war, but war is very interested in you!'
17:46:08 * Dianora shudders
17:46:31 <nicknull> when needs to be a monad?
17:46:33 * gwern forebears from quoting more trotsky at Dianora then
17:46:42 <nicknull> when needs to be a monad?
17:46:44 <mmorrow> i use GPL or BSD depending on situation
17:46:57 <vininim> GPL needs you!
17:46:59 <Pseudonym> WHat's the chocolate licence?
17:47:02 <Dianora> oh good.
17:47:08 <gwern> nicknull: well, you're usually using it in a monad, so why not?
17:47:11 <Dianora> I am not in a den of GPL fanatics.
17:47:14 <dons> i'm 100% BSD these days, fwiw.
17:47:20 <Pseudonym> Yeah, I alternate between GPL, LGPL, BSD and MIT (though really, there's not much difference between BSD and MIT these days).
17:47:26 <dons> Dianora: 80% of haskell code is BSD-ish licensed these days
17:47:33 <Dianora> dons *nod*
17:47:37 <dons> there's maybe 10% gpl, 5% lgpl, and a little others
17:47:40 <Dianora> You know what really annoyed me ?
17:47:42 <Dianora> In the end
17:47:47 <gwern> one of these days I intend to do a game theoretic analysis of how a mix of GPL and BSD constitutes an evolutionarily stable strategy
17:47:49 <Pseudonym> Generally speaking, Id code a general-purpose Haskell library under the standard Haskell BSD-ish licence.
17:47:52 <Dianora> GPL litigation
17:47:58 <Pseudonym> If it were an application, I'd think harder.
17:47:59 <Dianora> them going after companies for using GPL code
17:48:08 <Pseudonym> Maybe BSD, maybe GPL.
17:48:12 <gwern> I think of BSd-licensed code as being those critters who go around wearing 'poison colors', but aren't actually investing in poison
17:48:12 <vininim> lol
17:48:15 <Dianora> maybe *maybe* their lawyers aren't being paid by the foundation
17:48:19 <Dianora> but I really kind of doubt it
17:48:26 <Dianora> so think about it
17:48:27 <mmorrow> Pseudonym: that's pretty much my strategy as well
17:48:31 <Dianora> something you wrote *for fun*
17:48:34 <vininim> I think they should just make a political statement and not care if the license is enforced.
17:48:38 <Dianora> you got *no money* for it
17:48:43 <Pseudonym> I reserve LGPL for non-Haskell code for the most part.
17:48:44 <Dianora> someone is getting paid for
17:48:46 <Dianora> and it's not you
17:48:51 <Dianora> that's what pisses me off
17:49:05 <Pseudonym> Now that I think about it, Dfa.lhs is under the LGPL.  I should really relicense that some day.
17:49:07 <Dianora> I write code for fun not for lawyers.
17:49:45 <dons> lispy: going to post your 'what does commute mean' to a blog  plz?
17:49:48 <mmorrow> i use GPL to protect my investment of time in code i wrote for a particular purpose, and BSD if i wrote the code for the community
17:49:52 * dons hates seeing good content only on mailing lists now
17:50:41 <Saizan> mmorrow: out of curiosity, did you try the ghc-api on 6.10?
17:50:44 <dons> mmorrow: i use BSD for apps as well, fwiw, since the haskell community benefits from the application source being reusable
17:51:06 <gwern> Pseudonym: you say that like relicensing your own code is *so* hard
17:51:31 <Pseudonym> It is, actually, because I don't know who's using it.Since it was distributed pre-hasckage.
17:51:33 <mmorrow> dons: true, but only as long as that doesn't hurt me in the process (for whatever reason) :)
17:51:38 <Pseudonym> hackage
17:52:04 <Pseudonym> It's incorporated in about a dozen projects, IIRC.
17:52:30 <mmorrow> Saizan: yes, but i extracted a large part of GHC.hs/HscTypes.lhs/HscMain.lhs and hacked them since I'm not too fond of this GhcMonad business
17:53:06 <mmorrow> and i want to make it possible to have multiple threads sharing a single HscEnv/etc
17:53:19 <gwern> Pseudonym: I don't entirely follow why re-users would make it troublesome for you?
17:54:02 <Pseudonym> The LGPL may have accidentally infected a bunch of projects due to the uncertain meaning of the LGPL for Haskell code.
17:54:03 <Cale> nicknull: Just a nitpicking point about terminology... monads are type constructors. (For example: Maybe, IO, State s, etc.) If we're talking about values of type (M a) for some monad M, then we usually say 'action', 'monadic action', 'monadic computation', or 'value typed in a monad'.
17:54:10 <gwern> just tell'em "it's BSD now, 'k"
17:54:23 <gwern> 'you can bes BSD too nao'
17:54:33 <Pseudonym> Text-editing my copy is the easy bit.
17:54:44 <Pseudonym> But I really don't know who else is using it.
17:54:53 <Pseudonym> It'd be nice to be able to push a change to everyone.
17:54:56 <vininim> and then you could pull a Theo if they try to GPL derivativies.
17:55:03 <ddarius> Pseudonym: They accepted using it under the terms of the LGPL.
17:55:03 <Pseudonym> LOL
17:55:09 <Pseudonym> Actually, Theo had a point which got lost.
17:55:19 <gwern> as is ever the case with Theo
17:55:19 <Pseudonym> WHich is that it is possible to break the BSD licence in spirit.
17:55:20 <nicknull> but when only seems to do 1 action. so when is if without else? but if i have say 5 things i need yo do when-condition?
17:55:21 <Cale> nicknull: 'when' is a function which takes a Bool and an action, and gives another action (which is a no-op if the Bool was False, and the action you gave it if the Bool was True)
17:55:36 <Pseudonym> And some of the GPLers did precisely that, which isn't polite.
17:55:40 <vininim> lol
17:55:42 <gwern> nicknull: that's how I think of it, anyway
17:55:46 <vininim> I really don't see it like that
17:55:52 <Cale> when $ do ...
17:55:53 <Cale> er
17:55:57 <Pseudonym> Not tha t"Theo" and "polite" really belong in the spame sentence.
17:55:58 <Cale> when (condition) $ do ...
17:56:07 <Pseudonym> same, not spame
17:56:11 <Pseudonym> Sorry, I hate this keyboard.
17:56:11 <Cale> do-notation is used to glue together multiple actions into one.
17:56:26 <Cale> (this is in some sense all that it does)
17:56:37 <vininim> They did what a company would do, except that the source was avalaible.
17:56:48 <vininim> available too
17:57:22 <Pseudonym> G'day.  Yeah, it's unusual.
17:57:40 <Pseudonym> Today s server upgrading day.
17:57:41 <Cale> nicknull: I think it's important to realise that do-blocks are actually expressions which evaluate to particular actions, built up from the actions listed inside them.
17:57:43 <Pseudonym> WHich takes a while.
17:58:07 <Pseudonym> Gah.
17:58:14 <Pseudonym> Mistype.  Did I mention I hate this keyboard?
17:59:23 <lament> it's an unusual keyboard that makes you mistype same as spame
17:59:56 <lispy> Some people here have asked me questions about patch theory.  I wrote up some notes that are motivated by examples: http://lists.osuosl.org/pipermail/darcs-users/2008-October/014779.html
17:59:58 <lambdabot> Title: [darcs-users] Explanation: What does commute mean?, http://tinyurl.com/66q6va
18:00:38 <Cale> > (do x <- [1,2,3]; y <- [4,5]; return (x,y)) -- The individual actions are lists, so the whole do-block evaluates to a list. "Executing" a list amounts to picking one of its elements in all possible ways.
18:00:39 <lambdabot>   [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
18:01:09 <Cale> Not sure if that helps or confuses the matter :)
18:01:44 <Cale> But, for instance,  putStrLn "foo" :: IO ()  and  (do x <- getLine; putStrLn x) :: IO () as well
18:01:56 <lispy> > do x <- "hello, "; y <- "world!"; return (x,y))
18:01:57 <lambdabot>   <no location info>: parse error on input `)'
18:02:03 <lispy> > do x <- "hello, "; y <- "world!"; return (x,y)
18:02:04 <lambdabot>   [('h','w'),('h','o'),('h','r'),('h','l'),('h','d'),('h','!'),('e','w'),('e'...
18:02:21 <lispy> > do x <- "hello, "; y <- "world!"; return [x,y]
18:02:22 <lambdabot>   ["hw","ho","hr","hl","hd","h!","ew","eo","er","el","ed","e!","lw","lo","lr"...
18:03:31 <Cale> > do x <- ["hello", "goodbye"]; y <- ["world","lispy"]; return (unwords [x,y])
18:03:32 <lambdabot>   ["hello world","hello lispy","goodbye world","goodbye lispy"]
18:04:04 <vixey> :t liftM2 (++) ["hello", "goodbye"] ["world","lispy"]
18:04:05 <lambdabot> [[Char]]
18:05:55 <nicknull> so not all do-constructs are impure
18:05:55 <sm> very nice lispy. +1 for blogging
18:06:19 <dolio> No do constructs are impure.
18:06:23 <lispy> sm: heh, not really blogging, thats the darcs mailing list...but yeah still typing up my notes
18:06:38 <sm> yeah, I'm echoing dons' suggestoin
18:06:57 <lispy> sm: I just hope it's accessible to people
18:07:07 <sm> I think it's very nicely written
18:07:10 <lispy> thanks
18:07:48 <Cale> lispy: Isn't there a little problem with your initial definition of 'commute'?
18:07:58 <sm> I think a few readers peel off right at sentence two, what does "AB <--> B'A'" mean ?
18:07:58 <Cale> I can always pick B' = A and A' = B
18:08:12 <Cale> and so any two patches will commute in that sense ;)
18:08:28 <nicknull> perms = do
18:08:28 <nicknull>   x <- [1,2,3]
18:08:28 <nicknull>   y <- [4,5]
18:08:28 <nicknull>   return (x,y)
18:08:47 <nicknull> perms :: [(Integer, Integer)]
18:09:13 <lispy> Cale: Hmm...so the whole document is trying to address that observation.  But, I didn't make that obvious enough?
18:09:25 <Cale> lispy: I'd just read the beginning :)
18:09:59 <nicknull> f q w = perms q w
18:10:12 <gwern> wonder when community.haskell.org will get darcs-2
18:10:12 <nicknull> ^^ works calling from pure function
18:10:24 <Cale> nicknull: yeah, it's just a list
18:10:41 <ddarius> f = perms and perms does not calculate permutations by the way
18:10:43 <lispy> gwern: Oh, I thought it had been upgraded.  Maybe it's just not in the same path?
18:11:18 <lispy> gwern: oh wait, it was upgraded on code.haskell.org...is that a different server?
18:11:19 <gwern> lispy: all I know's I keep getting the darcs warning everytime I push/pull from mueval
18:11:34 <sm> would this be right:  Given two patches, A and B, we say that A and B *commute* if there are patches A' and B' such that B' A' has the same effect as AB. We write this as AB <--> B' A'.
18:11:41 <gwern> for all I know they are different servers
18:11:54 <lispy> gwern: oh, that very well could be a problem with the repository.  What is the exact warning?
18:12:06 <Cale> sm: That falls prey to the same problem I just mentioned ;)
18:12:07 <gwern> although that would confuse me a little - how can I push to my mueval repo on community and have the repo publicly available on code.h.o?
18:12:10 <ushdf> > error "exact warening"
18:12:11 <lambdabot>   * Exception: exact warening
18:12:16 <sm> oops
18:12:17 <Cale> Ideally, you could define two patches commuting as meaning that AB = BA, but that's probably too strict for this setting.
18:12:19 <ddarius> sm: No.  That again is exactly what Cale said before.  Choose B' = A and A' = B.
18:12:37 <gwern> lispy: here http://hpaste.org/11245
18:12:38 <ddarius> What needs to be done is say how B and B' are related.
18:12:47 <sm> I was trying to fix my own complaint, not his.. someone else have a go ?
18:13:16 <gwern> mmorrow: btw mueval patches pushed if you care
18:13:29 <mmorrow> gwern: awesome, thx
18:13:29 <nicknull> so if i want a lisp-when, is that possible?
18:13:35 <lispy> gwern: does the file _darcs/prefs/format exist on the remote side?
18:13:39 <Cale> sm: Your version is clearer, yes.
18:13:48 <Cale> (in that dimension)
18:13:48 <gwern> lispy: no idea
18:14:04 <gwern> I suppose you'll want me to log in and look
18:14:13 <lispy> gwern: yes please :)
18:14:31 <lispy> gwern: I still have been meaning to look into the problem you noticed with autoproc.  Sorry for being slow.
18:15:46 <gwern> http://hpaste.org/11245#a1 <-- doesn't look like it
18:15:46 <lispy> gwern: I think there are 1 of two things going on, either  you're right and remote darcs is not 2.x, or the repository is so old that it makes your local darcs complain...an old repo could be upgraded
18:16:15 <gwern> seems darcs --version on community gives me 2.0.2 (release)
18:16:21 <lispy> gwern: you probably want to create an empty file with that name then
18:16:35 <thoughtpolice> lispy: you happen to know if there will be any static linked darcs 2.1 os x binaries soon? i'm using RC1 and using macports I'll have to install ghc 6.8 :/
18:16:57 <lispy> thoughtpolice: oh hang on, that's a complicated question
18:17:00 <thoughtpolice> well i mean using the 6.10 rc1
18:17:25 <lispy> thoughtpolice: someone submitted patches today and david applied them to unstable that make it compile under 6.10
18:17:34 <lispy> thoughtpolice: static linked?  Dunno, never tried that
18:17:48 <gwern> lispy: interestingly the warning goes away when I use darcs (stable) darcs
18:17:59 <gwern> perhaps there was a problem in the heuristic or whatever
18:18:07 <lispy> gwern: ah
18:18:19 <thoughtpolice> lispy: http://wiki.darcs.net/DarcsWiki/CategoryBinaries#head-25c8108e9d719be30a8cc6bcc86ce243a78b8c25
18:18:22 <lambdabot> Title: CategoryBinaries - DarcsWiki, http://tinyurl.com/3ycs9p
18:18:23 <lispy> thoughtpolice: if you don't mind building outside of macports, darcs is pretty easy to build
18:18:52 <sm> mac binaries are a good idea, noone is working on that lately
18:19:47 <thoughtpolice> lispy: right but i only have the 6.10 rc1, i don't have 6.8 (os x installer pkg removed it)
18:19:54 <thoughtpolice> and the build chokes pretty fast with it
18:20:21 <lispy> thoughtpolice: if you grab the sources from unstable, which should be safe, not much has gone in since the release, it will build with 6.10
18:20:33 <lispy> thoughtpolice: darcs get http://darcs.net/unstable
18:20:44 <thoughtpolice> lispy: ty
18:20:51 <nicknull> is the creator of darcs a hero in the haskell-community? kind of the only reasonably succesfull haskell-program
18:21:12 <sm> kind of an unsung hero
18:22:04 <thoughtpolice> xmonad? :]
18:25:44 <nicknull> man i just dont get it. how do i create a control-structure that is a non-bracnhing if and takes sveral expressions?
18:27:24 <nicknull> http://hpaste.org/11246
18:28:45 <sbahra> nicknull, could you clarify your question?
18:29:21 <dolio> > runWriter (let x = 11 in when (x > 10) (do tell [10] ; tell [20] ; tell [30]))
18:29:23 <lambdabot>   ((),[10,20,30])
18:29:30 <dolio> > runWriter (let x = 9 in when (x > 10) (do tell [10] ; tell [20] ; tell [30]))
18:29:31 <lambdabot>   ((),[])
18:30:15 <sm> add a do after the when condition ?
18:31:27 <dolio> It actually needs a "$ do" due to the vagaries of the syntax.
18:32:11 <eu-prleu-peupeu> hellloooooo
18:32:30 <sm> oh, didn't even see your lambda bot examples.. I filter that stuff out
18:35:23 <nicknull> howdod i add a do
18:35:44 <nicknull> when (20 > 10) do ; doesnt work
18:35:59 <dolio> when (20 > 10) $ do ...
18:39:33 <nicknull> f x = if x == "h" then This (read x :: Int) else That (read x :: Float)
18:39:50 <nicknull> i thought i could have diff returntypes using either
18:39:52 <nicknull> i can right?
18:40:08 <dolio> Yes. But the constructors are Left and Right.
18:40:34 <sm> dolio: I'm not quite sure why it needs that $ ?
18:40:50 <nicknull> f x = if x == "h" then Left (read x :: Int) else Right (read x :: Float)
18:40:58 <nicknull> hwod o i use it?
18:41:15 <dolio> sm: Because 'f do ...' doesn't get parsed as 'f (do ...)', but 'f $ do ...' does.
18:42:11 <sm> right.. I just thought that an indented do block would be considered a single expression
18:42:26 <dolio> Similarly, you need 'f $ \x -> ...' instead of just 'f \x -> ...', although people have proposed changing the syntax to allow it.
18:42:44 <nicknull> @src either
18:42:44 <lambdabot> either f _ (Left x)     =  f x
18:42:44 <lambdabot> either _ g (Right y)    =  g y
18:42:49 <nicknull> @src Either
18:42:49 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
18:43:00 <dolio> data Either a b = Left a | Right b
18:43:13 <nicknull> data ThisOrThat t = This t | That t
18:44:52 <eu-prleu-peupeu> what is the difference between the . operator, and the $ operator ?
18:45:24 <dolio> (.) is function composition, ($) is function application.
18:45:44 <thoughtpolice> lispy: can't build darcs2 head on 6.10 rc1
18:45:49 <nicknull> what is >>= ? bind?
18:46:00 <nicknull> what is the syntactic sugar for >>=, do?
18:46:14 <eu-prleu-peupeu> dolio: i know that, but what is the difference ?!
18:46:38 <eu-prleu-peupeu> isn't f $ g x the same as (f(g x)) ?
18:46:46 <dblazakis> eu-prleu-peupeu: f . g $ x = f (g x)
18:47:09 <dolio> Yeah. And f . g x = \y -> f (g x) y
18:47:29 <dolio> Wait, \y -> f (g x y).
18:48:31 <thoughtpolice> wtf
18:48:35 <dblazakis> nicknull: a >>= f  is do x <- a; f x
18:48:38 <thoughtpolice> hpaste is fooling around with my paste :[
18:49:20 <dblazakis> do { x <- a; f x }
18:49:27 <eu-prleu-peupeu> can i use f(x,y) in haskell ?
18:49:32 <eu-prleu-peupeu> it is common in mathematics :P
18:49:43 <dblazakis> :t uncurry
18:49:44 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
18:49:54 <lispy> thoughtpolice: ah, shoot
18:49:56 <eu-prleu-peupeu> in a man programming language, you would use parenthesis for function parameters
18:49:59 <nicknull> i dont get where a comes from
18:50:03 <dolio> Haskell has tuples.
18:50:24 <sbahra> eu-prleu-peupeu, why?
18:50:35 <dblazakis> > uncurry (+) (1,2)
18:50:37 <lambdabot>   3
18:50:43 <thoughtpolice> lispy: configure goes fine, build fails with http://hpaste.org/11248
18:50:56 <sbahra> :t uncurry (+)
18:50:57 <lambdabot> forall a. (Num a) => (a, a) -> a
18:51:16 <eu-prleu-peupeu> i still dont get the $ operator
18:51:21 <dblazakis> > let plus = uncurry (+) in plus (42, 1)
18:51:22 <lambdabot>   43
18:51:41 <lispy> thoughtpolice: looking
18:52:00 <sm> thoughtpolice: oh, that. I heard .. configure --disable-Werror might work..
18:52:17 <sm> unless that's new-fangled hackery
18:52:24 <eu-prleu-peupeu> for me, the definition of composition is f . g (x) = f(g(x)) (in maths syntax), so if (in haskell syntax) f $ g x = f(g(x)) then the $ operator looks to me like the composition operator
18:52:26 <eu-prleu-peupeu> or am i wrong ?
18:52:28 <lispy> sm: this should be the autotools build system still
18:52:41 <lispy> thoughtpolice: that's weird tho, someone sent in patches today and david applied them, let me find teh thread
18:53:06 * sm nods
18:53:11 <dolio> (f . g) x = f (g x)   (f $ g) x /= f (g x)
18:53:20 <lispy> thoughtpolice: http://lists.osuosl.org/pipermail/darcs-users/2008-October/014768.html the next message in thread is david applying them
18:53:22 <lambdabot> Title: [darcs-users] Fwd: GHC 6.10 compatibility patches, http://tinyurl.com/6pfnhv
18:53:44 <vininim> @src ($)
18:53:44 <lambdabot> f $ x = f x
18:54:10 <lispy> eu-prleu-peupeu: ($) is the function application operator
18:54:17 <ddarius> ($) is id
18:54:39 <vininim> :t ($)
18:54:40 <lambdabot> forall a b. (a -> b) -> a -> b
18:54:40 <lispy> > zipWith ($) [(+1), (+2), (+3)] [1..3]
18:54:42 <lambdabot>   [2,4,6]
18:54:43 <vininim> :t (id)
18:54:44 <lambdabot> forall a. a -> a
18:54:59 <lispy> eu-prleu-peupeu: as that zipWith demonstrates
18:55:16 <ddarius> > zipWith id [(+1), (+2), (+3)] [1..3]
18:55:18 <lambdabot>   [2,4,6]
18:55:23 <eu-prleu-peupeu> everybody just keeps repeating to me that "$ is the function aplication operator" like i am going to understand the difference between the composition one :P
18:55:28 <eu-prleu-peupeu> i think i did understand the difference
18:55:55 <lispy> eu-prleu-peupeu: well, composition is how you combine the functions, and application is how you make it compute something :)
18:56:00 <dblazakis> :t (.)
18:56:02 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
18:56:25 <eu-prleu-peupeu> like, the '.' operator, creates a new function, that is the compositino of the two, and the $ operator just applies the output of a functino to the input of the other (just like composition is done in maths), the implications of this, is that you can make point.free programming
18:56:34 <eu-prleu-peupeu> this is my perception of the problem
18:56:41 <lispy> thoughtpolice: oh, maybe his patches only help on windows
18:56:47 <mml`> :t (zipWith id)
18:56:48 <lispy> thoughtpolice: so how else can we fix your problem
18:56:49 <lambdabot> forall b c. [b -> c] -> [b] -> [c]
18:56:54 <mml`> :t (zipWith ($))
18:56:55 <lambdabot> forall a b. [a -> b] -> [a] -> [b]
18:57:01 <lispy> thoughtpolice: Oh, I know...remove -Werror from the makefile
18:57:04 <vininim> lol
18:57:45 <sm> brilliant! :)
18:58:18 <lispy> eu-prleu-peupeu: yes, we call (.) a higher order function
18:58:34 <lispy> eu-prleu-peupeu: it takes functions as parameters and does things with them
18:58:47 <nicknull> how do i use either?
18:58:53 <lispy> :t either
18:58:54 <eu-prleu-peupeu> so does $
18:58:54 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
18:59:00 <eu-prleu-peupeu> but it doesnt "create" a new function
18:59:03 <rdmltrs9> hi can you nest do's in main?
18:59:13 <lispy> > either (+1) (subtract 1) (Left 1)
18:59:15 <lambdabot>   2
18:59:17 <lispy> > either (+1) (subtract 1) (Right 1)
18:59:19 <lambdabot>   0
18:59:21 <thoughtpolice> lispy: actually
18:59:22 <mmorrow> , map (either (*2) (*10000)) [Left 8, Right 9, Left 299]
18:59:23 <dblazakis> > id $ 3
18:59:24 <lunabot>  [16,90000,598]
18:59:24 <lambdabot>   3
18:59:27 <dblazakis> > id . 3
18:59:28 <lambdabot>       No instance for (Num (a -> b))
18:59:29 <lambdabot>        arising from the literal `3' at <...
18:59:30 <thoughtpolice> the patch to do disable-Werror was for the franchise setup.hs
18:59:31 <rdmltrs9> i'm trying to get a char change and print it then get a string
18:59:36 <thoughtpolice> i've been helping roundy hack on franchise a little
18:59:37 <ivanm> rdmltrs9: yes
18:59:41 <thoughtpolice> so i'm trying building with it now
18:59:45 <rdmltrs9> hmm
18:59:53 <mmorrow> , map (either (const Nothing) (Just . const "asdf")) [Left 8, Right 9, Left 299]
18:59:55 <lunabot>  [Nothing,Just "asdf",Nothing]
19:00:01 <ivanm> but by "nest", I mean have a do as a clause in an if statement or something
19:00:20 <mmorrow> , concatMap (either (const []) (:[])) [Left 8, Right 9, Left 299]
19:00:20 <lispy> thoughtpolice: ah, then  you're on your own.  I've never installed franchise
19:00:21 <lunabot>  [9]
19:00:33 <mmorrow> , concatMap (either (:[]) (const [])) [Left 8, Right 9, Left 299]
19:00:35 <lunabot>  [8,299]
19:00:38 <rdmltrs9> i am getting weird behavior where when I put the char action above the string action it terminates before doing anything with the string
19:01:10 <nicknull> so left is the first of the 2 functions, right the second, tis that simple?
19:01:17 <mmorrow> exactly
19:01:35 <dblazakis> rdmltrs9: if you hpaste, it will be easier for people to help you figure out what went wrong
19:01:39 <mmorrow> , map (either (const False) (const True)) [Left 8, Right 9, Left 299]
19:01:40 <lunabot>  [False,True,False]
19:02:00 <thoughtpolice> lispy: yes; the build system chokes on warnings for some reason
19:02:02 <ddarius> either l r just replaces all Lefts with l and all Rights with r.
19:02:06 <thoughtpolice> so I need to fix that to build darcs with it :P
19:02:12 <nicknull> im starting to see how monads make sense and fit in with the language and are not just hammered on to do side-effects which was my first impression
19:02:15 <mmorrow> , map (maybe 0 length . either (const Nothing) (Just . const "asdf")) [Left 8, Right 9, Left 299]
19:02:17 <lunabot>  [0,4,0]
19:02:27 <lispy> thoughtpolice: david said he added a flag to franchise to build without warnings
19:02:28 <nicknull> but the do-notation is ugly and strengthens that impression
19:02:40 <lispy> thoughtpolice: so check the franchise manual
19:02:50 <mmorrow> @type either
19:02:50 <ddarius> do-notation is intentionally designed to mimic imperative notation.
19:02:51 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
19:02:54 <mmorrow> @type maybe
19:02:55 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:02:56 <dblazakis> nicknull: why do you believe it to be ugly?
19:02:57 <thoughtpolice> lispy: there is no manual :]
19:03:00 <thoughtpolice> i'll look at the patches
19:03:05 <rdmltrs9> okay its out on hpaste
19:04:04 <nicknull> do is an ugly word, it reminds me of begin end etc
19:04:13 <dblazakis> rdmltrs9: seems to work fine for me?
19:04:17 <ddarius> It's supposed to.
19:04:36 <lispy> ?quote semicolon
19:04:37 <lambdabot> No quotes match. My mind is going. I can feel it.
19:04:43 <lispy> ?quote programmable
19:04:43 <lambdabot> No quotes match. You type like i drive.
19:04:54 <lispy> ?quote monad
19:04:55 <lambdabot> dcoutts says: monad transformers are not known for their blistering speed
19:05:09 <lispy> interesting
19:05:23 <lispy> So, monad transformers tend to slow things down?
19:05:59 <nicknull> ?quote Cale
19:05:59 <lambdabot> Cale says: Ack! My head is a lattice in which finite meets distribute over arbitrary joins!
19:06:05 <nicknull> ?quote Cale
19:06:05 <lambdabot> Cale says: [dmead] yo yo yo yo what it is mother fuckers [Cale] dmead: this isn't #scheme
19:06:23 <nicknull> ?quote @Heffalump
19:06:23 <lambdabot> No quotes match. Just try something else.
19:06:29 <nicknull> ?quote nicknull
19:06:29 <lambdabot> No quotes match. You speak an infinite deal of nothing
19:06:36 <lispy> that Cale quote is awesome
19:06:43 <nicknull> ?quote Beelsebob
19:06:43 <lambdabot> beelsebob says: <lambdabot> Parse error <beelsebob> where bitch?
19:06:57 <lispy> ?quote alarm
19:06:57 <lambdabot> lispy says: I just remembered this dream i had the other morning.  I was trying to tell my alarm clock how to snooze by using a list comprehension
19:06:58 <rdmltrs9> it seems to only take the char input for me
19:07:20 <rdmltrs9> i was expecting it to take the char and uppercase it then wait for string input
19:07:55 <Pseudonym> ?quote lispy
19:07:56 <lambdabot> lispy says: Schoedinger's cat is really in a thunk not a box
19:08:18 <dolio> @quote qwe1234
19:08:19 <lambdabot> qwe1234 says: lol, 'free university of amsterdam'.
19:08:27 <sebell> PETA says: don't evaluate Schroedinger's thunk
19:08:44 <dblazakis> rdmltrs9: http://hpaste.org/11250#a1
19:09:57 <thoughtpolice> lispy: hm apparently there isn't a patch to suppress errors
19:10:35 <lispy> thoughtpolice: /setup.hs configure --disable-Werror
19:10:55 <edwardk> sebell: fortunately Schroedinger was too lazy to evaluate his cat.
19:11:13 <sebell> *phew*!
19:11:14 <lispy> thoughtpolice: http://lists.osuosl.org/pipermail/darcs-users/2008-October/014749.html
19:11:16 <lambdabot> Title: [darcs-users] GHC 6.10 compatibility patches, http://tinyurl.com/6dgk5p
19:11:21 <Dianora> He didn't bother waving his hands.
19:12:37 <lispy> thoughtpolice: good luck, I'm going to change geographical locations so I'll be out of touch for a bit
19:13:12 <nicknull> how do i save a quote
19:13:32 <nicknull> @remember Dianora He didn't bother waving his hands.
19:13:32 <lambdabot> I will remember.
19:13:38 <nicknull> ?quote Dianora
19:13:39 <lambdabot> Dianora says: He didn't bother waving his hands.
19:15:19 <nicknull> any women here?
19:15:21 <nicknull> Dianora?
19:15:28 <Dianora> yes?
19:15:47 <nicknull> @src either
19:15:48 <lambdabot> either f _ (Left x)     =  f x
19:15:48 <lambdabot> either _ g (Right y)    =  g y
19:15:57 <Dianora> I need to learn haskell
19:16:02 <vininim> what? 6.10 is out?
19:16:35 <nicknull> @remember Dianora I need to learn haskell
19:16:36 <lambdabot> Done.
19:16:42 <nicknull> ?quote Dianora
19:16:42 <lambdabot> Dianora says: He didn't bother waving his hands.
19:16:44 <nicknull> ?quote Dianora
19:16:45 <lambdabot> Dianora says: He didn't bother waving his hands.
19:16:47 <nicknull> ?quote Dianora
19:16:47 <lambdabot> Dianora says: He didn't bother waving his hands.
19:16:50 <nicknull> wtf
19:17:24 <nicknull> dianora: math-student?
19:17:41 <Dianora> I was at one time yes.
19:17:48 <Dianora> but don't tell anyone ok?
19:17:50 <rdmltrs9> dblazakis i realized the weird behavior happens only when i run it in emacs
19:18:10 <dblazakis> rdmltrs9: ah, weird
19:18:37 <dblazakis> rdmltrs9: but that means the code worked as you expected, which is always nice :-)
19:19:04 <nicknull> which is the best webframework for haskell? is there something as easy as webpy?
19:21:48 <sm> I don't think so
19:23:17 <sm> http://community.haskell.org/~sclv/hvac/ might be closest
19:23:18 <lambdabot> Title: Index of /~sclv/hvac
19:24:18 <dblazakis> i may be wrong, but webpy is basically a web server, right?  is there much framework?
19:24:41 <dblazakis> there's always happs
19:24:59 <dblazakis> ?go HAppS
19:25:04 <lambdabot> http://happs.org/
19:25:04 <lambdabot> Title: HAppS â€” The Haskell Application Server
19:27:02 <sm> true, "getting started" with happs is really easy now
19:27:23 <dblazakis> disclaimer: i've never used it -- just mentioning that it exists
19:27:33 <dblazakis> and seems to have some users
19:32:32 <Facedown> hi - can anyone recommend a book/tutorial .. i'm coming from Python ( intermediate ) and Ecmascript ( advanced )
19:32:53 <ddarius> Facedown: What do you want to get out of it?
19:33:02 <Facedown> Learn one functional programming language
19:33:10 <Facedown> As opposed to most which are imperative
19:33:22 <Facedown> My friend was making a web server in Haskell, seemed like a neat idea
19:33:33 <Facedown> and I really am curious about how functional languages work
19:34:12 <ddarius> What do you want to get out of the book?  What do you want to get out of functional programming?  What kind of things would you like to do?
19:34:34 <ddarius> I suspect, though, that the answer for you is RWH.
19:34:37 <ddarius> @where rwh
19:34:37 <lambdabot> is http://www.realworldhaskell.org/blog/
19:34:38 <rdmltrs9> real world haskell - http://book.realworldhaskell.org/ is good
19:34:43 <lambdabot> Title: Real World Haskell
19:35:00 <Facedown> neat
19:35:12 <rdmltrs9> it was your reference to web servers that made me think of it
19:36:43 <ddarius> Bird's "The Algebra of Programming" is probably much better for cultivating a functional mindset from what I hear, but it doesn't have anything like a webserver in it.
19:38:04 <rdmltrs9> ?quote protontorpedo
19:38:04 <lambdabot> No quotes match.
19:40:38 <Facedown> wow
19:40:40 <Facedown> this is really neat
19:40:44 <Facedown> i love the comments
19:41:22 <sm> yes it is
19:42:14 <rdmltrs9> ?quote brain
19:42:14 <lambdabot> adept says: I think I need a cobrain to understand coeffects
19:42:32 <sm> http://www.cs.nott.ac.uk/~gmh/book.html is also good. I thought it was online but I guess not
19:42:33 <lambdabot> Title: Programming in Haskell
19:43:05 <roconnor> does the following make sense with respect to strictness annotations:
19:43:09 <roconnor> data Red = Red
19:43:11 <roconnor> data Green = Green
19:43:11 <roconnor> data Blue = Blue
19:43:11 <roconnor> newtype Chan p a = Chan a
19:43:11 <roconnor> data XRGB a = XRGB !(Chan Red a) !(Chan Green a) !(Chan Blue a)
19:43:13 <roconnor> or
19:43:24 <roconnor> should I do newtype Chan p a = Chan !a
19:43:42 <roconnor> or any other opinions?
19:44:52 <ddarius> newtype Chan p a = Chan !a is a syntax error
19:45:18 <roconnor> ah
19:46:18 <edmccaffrey> I'm evaluating Haskell for a project -- are there any good libraries for digital signal processing?  I can create a spectrogram from a song in Python in about 6 lines, thanks to NumPy/SciPy/Audiolab, but I'm interested in doing it in Haskell if I don't need to recreate those things.
19:46:58 <roconnor> @where dsp
19:46:58 <lambdabot> I know nothing about dsp.
19:47:02 <roconnor> sucks
19:48:08 <roconnor> I mean shucks
19:48:47 <edmccaffrey> Well, I'm sure there is something, thanks.
19:49:04 <rdmltrs9> maybe - http://haskelldsp.sourceforge.net/
19:49:05 <lambdabot> Title: Matt's Haskell DSP Libraries
19:49:25 <ddarius> edmccaffrey: Hackage is the first place to look for libraries.
19:49:42 <lispy> ?users
19:49:42 <lambdabot> Maximum users seen in #haskell: 518, currently: 485 (93.6%), active: 10 (2.1%)
19:49:59 <ddarius> On it are libraries for reading/writing sound files, libraries to do FFTs, other linear algebra/numeric computing libraries.
19:50:03 <lispy> thoughtpolice: any luck?
19:50:04 <ddarius> Libraries for graphics.
19:51:02 <lispy> edmccaffrey: there should be an FFT implementaton or two on Hackage
19:51:12 <edmccaffrey> Awesome, I can do without the spectrogram if necessary, I really just didn't want to re-create my own FFT, since it would take too long to ensure that there are no subtle mistakes.
19:51:58 <thoughtpolice> lispy: not yet
19:52:14 <nicknull> wtf isnt there jus tone link to download everything that belongs to happs?
19:52:43 <nicknull> i tried the first link(it says partial though) and downloaded it but hen it complains the others ar missing
19:53:07 <edmccaffrey> Thanks for the tip about hackage -- new to Haskell and didn't know it existed -- bindings to FFTW is perfect.
19:53:45 <lispy> edmccaffrey: yeah, hackage is cool.  It's like easy_setup or whatever the python thing is called :)
19:54:19 <lispy> edmccaffrey: you can use the cabal-install tool (also on hackage) to download, install and upgrade packages
19:56:16 <mmorrow> if anyone's interested in compilers, here a pic of the inside cover of this great book i have detailing the order of optimizations in an "aggressively optimizing compiler"  http://moonpatio.com/images/compiler.jpg
19:56:51 <mmorrow> this book though has only about two pages (out of 800) on functional languages :(
19:56:57 <mmorrow> but still
19:57:44 <dblazakis> mmorrow: which book is that?
19:58:46 <mmorrow> http://www.amazon.com/Advanced-Compiler-Design-Implementation-Muchnick/dp/1558603204/ref=sr_1_1?ie=UTF8&s=books&qid=1224298679&sr=8-1
19:58:50 <lambdabot> http://tinyurl.com/5m6pqy
19:59:14 <nicknull> darcs get --partial --tag=0.9.2 http://happs.org/repos/HAppS-HTTP
19:59:20 <nicknull> darcs get --partial --tag=0.9.2 http://happs.org/repos/HAppS-State
19:59:25 <mmorrow> the search i just did on amazon actually turned up some other books that look interesting.. (i searched to that title verbatim)
19:59:31 <nicknull> how can i get all at once?
20:00:02 <lispy> nicknull: have you tried to use cabal to install it?
20:00:08 <nicknull> yes
20:00:11 <nicknull> FAIL
20:00:33 <lispy> nicknull: the --partial in that darcs get means it's a partial get of the *history*. You are getting everything in the repository otherwise
20:01:29 <nicknull> ok
20:01:44 <nicknull> anyone know happs? why cant i just pull all the six parts at once?
20:02:21 <dblazakis> nicknull: how did cabal fail?
20:03:29 <lispy> nicknull: if you're a consumer of the software and not a developer, then I would encourage to retry the cabal-install path.  I think you'll have less headache in the long run.  People here should be able to help you.
20:03:59 <nicknull> missed the other packages
20:04:06 <nicknull> so no fail
20:04:09 <sm> cabal install happs-tutorial
20:04:33 <nicknull> when i do runghc Setup configure im using cabal right?
20:04:58 <lispy> nicknull: my mistake.  I said cabal initially, I hould have said cabal-install.
20:04:59 <sm> when you do that, you're using Cabal (the framework)
20:05:21 <sm> better is to do cabal install pkg (cabal-install, the command-line tool using Cabal)
20:05:34 <dblazakis> nicknull: cabal-install is a script to grab and install all the dependencies before trying the install of whatever you wanted in the first place
20:05:34 <mmorrow> in particular, this book looks really good from the toc http://www.amazon.com/Optimizing-Compilers-Modern-Architectures-Dependence-based/dp/1558602860/ref=sr_1_3?ie=UTF8&s=books&qid=1224298679&sr=8-3
20:05:37 <lambdabot> http://tinyurl.com/5zlk7e
20:06:59 <lispy> mmorrow: i've enjoyed my copy of "Modern Compiler Design" it even has a section on Haskell.  But, I also haven't depended on it too heavily yet so it could be lacking some thing.
20:07:03 <mmorrow> this one looks excellent, but is $250 http://www.amazon.com/Compiler-Design-Handbook-Optimizations-Generation/dp/084931240X/ref=sr_1_2?ie=UTF8&s=books&qid=1224298679&sr=8-2
20:07:06 <lambdabot> http://tinyurl.com/6kt5vq
20:07:25 <mmorrow> lispy: hmm, /me searched for that one now
20:08:04 <lispy> mmorrow: http://www.cs.vu.nl/~dick/MCD.html
20:08:17 <lambdabot> Title: Modern Compiler Design
20:08:17 <ddarius> mmorrow: You hadn't heard of "Modern Compiler Design"?
20:09:05 <mmorrow> ddarius: heh, i don't think i have
20:09:12 <Dianora> ddarius: author?
20:09:18 <ddarius> mmorrow: Wow.  Have you heard of references to the "Tiger book"?
20:09:28 <mmorrow> oh yeah, i've actually been to that page
20:09:45 <mmorrow> ddarius: hmm, "Tiger book" doesn't ring a bell
20:09:52 <mmorrow> dragon bok does though
20:09:56 <mmorrow> *book
20:10:00 <Dianora> I have the dragon book.
20:10:02 <roconnor> Hey it worked already!:
20:10:04 <roconnor>     Couldn't match expected type `Green' against inferred type `Blue'
20:10:10 <lispy> why is the dragon book so popular?
20:10:11 <Dianora> good book.
20:10:12 <roconnor> types++
20:10:18 <roconnor> phantomTypes++
20:10:20 <Dianora> lispy: It's pretty practical.
20:10:32 <Dianora> lispy: But hardly useful for a good compiler writer.
20:10:34 <ddarius> Ack.  I'm thinking of "Modern Compiler Implementation"
20:10:38 <dblazakis> the Appel book is a good reference
20:10:54 <dblazakis> ddarius: that's the tiger (appel) book, right?
20:11:06 <ddarius> dblazakis: Yes.  Books technically.
20:11:21 <dblazakis> ok, right -- ML, C, Java, anythign else?
20:11:24 <Dianora> what I found amusing was the designers of clang did a recursive descent parser for 'c'
20:11:38 <Dianora> very old school
20:11:46 <ddarius> dblazakis: Just those three.
20:11:49 <Pseudonym> There's a new edition of the Dragon book, no?
20:11:56 <Dianora> Pseudonym: yes
20:11:56 <Pseudonym> THe one I have is, like, 20 years old.
20:12:03 <Dianora> heh sounds like my first copy
20:12:11 <Dianora> my first K&R is about as old as my daughter now
20:12:43 <Pseudonym> Given that my elder one is 8, she can't compare with some of my books.
20:12:52 <mmorrow> people were discussing C parsing in here a few days ago, and it's apparently context sensitive after you add in particular lang extensions (which ones i don't recall)
20:13:11 <Dianora> mmorrow: yeah making LALR(1) dicey
20:13:23 <Pseudonym> mmorrow: You need to be able to distinguish typedef names at lex time.
20:13:43 <Dianora> I never liked typedefs.
20:13:49 <mmorrow> Pseudonym: ah yeah, it was you that was talking about it
20:14:07 <Dianora> sometimes they make sense
20:14:11 <mmorrow> didn't someone give a couterexample to it being LALR(2)?
20:14:17 <Pseudonym> I have no problem in principle with typedefs, but I must say I prefer newtype if I have the option.
20:14:23 <Pseudonym> mmorrow: Yes.
20:14:27 <Dianora> parser aware lexers. yum.
20:14:31 <Pseudonym> Someone gave an example of something that was truly ambiguous.
20:14:43 <ddarius> Dianora: Better than J.
20:14:51 <eck> i'm looking for some examples of the ghc gstreamer bindings... does anyone know of any example programs that use them?
20:14:52 <Dianora> ddarius: or fortrash
20:15:58 <Pseudonym> Fortran doesn't belong in the rubbish bin, it belongs in a museum.
20:16:01 <Pseudonym> Just saying.
20:16:03 <mmorrow> heh
20:16:28 <nicknull> question about VCS, can i get with darcs from a svn repos?
20:16:32 <Dianora> Pseudonym: trust me, it's about all scientists can deal with.
20:16:41 <Dianora> well, that's not true. python too
20:16:44 <sm> nicknull: no
20:16:54 <Pseudonym> Matlab.
20:16:56 <lispy> nicknull: no, you'd have to convert the svn repo first with a tool like tailor
20:16:57 <Pseudonym> Lots and lots of matlab.
20:17:04 <mmorrow> Octave!
20:17:08 <Dianora> Pseudonym: dont' forget STABLIB
20:17:16 <Pseudonym> True.
20:17:17 * sm gets a new appreciation for that book on the shelf from http://www.cs.nott.ac.uk/~gmh/book-review.pdf
20:17:19 <lambdabot> Title: Book Review: â€œProgramming in Haskellâ€by Graham Hutton
20:17:21 <Pseudonym> It depends on the scientist, though.
20:17:35 * lispy can think of at least one scientist that knows Haskell pretty damn well
20:17:38 <Dianora> Pseudonym: I know I know ;-)
20:17:48 <Dianora> well, a CS type I would expect wouldn't be bad
20:17:51 <Dianora> but physicists.. ugh
20:18:17 <Pseudonym> I'm shocked at the number of computational biologists who don't know how to program.
20:18:28 <ddarius> What do they do?
20:18:34 <Pseudonym> You want to do protein folding, and you don't even know what source control is?
20:18:44 * lispy waits for someone to comment on the number of software engineers who don't know how to programm :)
20:19:00 <Dianora> Pseudonym: heh yeah I know I know
20:19:23 <Dianora> lispy: someone on ##c gave an example of really bad code from a CS prof who couldn't code.
20:19:29 <Dianora> lispy: point. ;-)
20:19:31 <Pseudonym> lispy: Actually, I'm not so worried about that, because most software engineers are aware of their limitations.
20:19:40 <Pseudonym> Software engineering is far more about managing customers and budgets.
20:20:00 <lispy> Pseudonym: that is so true
20:20:00 <Pseudonym> Fancy algorithms usually don't enter into it.
20:20:08 <Dianora> Pseudonym: And putting in a couple of 20 hour days just before delivery to prove what a man you are.
20:20:21 <ddarius> lispy: It's well known that programming is the easy part.
20:20:22 <lispy> ?remember Pseudonym Software engineering is far more about managing customers and budgets.
20:20:22 <lambdabot> It is stored.
20:20:30 <Pseudonym> I'm glad people do that, because it needs to be done.
20:21:40 <nicknull> where is happs-util? thats not even downloadable
20:22:37 <mmorrow> lol
20:22:41 <nicknull> python+numpy+scipy´+matplotlib is awesome
20:22:51 <mmorrow> @remember Pseudonym You want to do protein folding, and you don't even know what source control is?
20:22:52 <lambdabot> It is forever etched in my memory.
20:23:04 <Dianora> wsjt uses python+numpy+scipy plus some c and fortran glue
20:23:23 <ddarius> More programmers need to learn about biocomputing and related fields.
20:23:29 <Pseudonym> mmorrow: I dare you to put hte whole T.S. Eliot filk in @remember.
20:23:39 <Dianora> ddarius: a replacement for quantum computers?
20:23:42 <nicknull> nothing beats python when ti comes to productivity either
20:23:46 <Dianora> ddarius: the biological computer solutions?
20:23:48 <mmorrow> Pseudonym: heh
20:24:04 <Dianora> or ?
20:24:17 <Dianora> I like python.
20:25:26 <roconnor> oops, I broke ghc 6.8
20:25:32 <roconnor> made it infinite loop
20:26:39 <ddarius> GHC has had a known infinite loop bug for many, many years now.
20:27:05 <lispy> It's called undecidable instances?
20:27:19 <Dianora> I dare someone to read in "The eye of aragon"
20:27:22 <roconnor> I'm using Haskell 98 code
20:27:22 <ddarius> lispy: That's not a bug, that is, actually, a feature.
20:27:48 * lispy thought we were boing facetious
20:29:20 <nicknull> HELLO ANYONE HAVE ANY CLUE HOW TO INSTALL HAPPS? IT IS ASKING FOR LIBS THAT AR ENOT SDPWNLOAD ABLE
20:29:25 <nicknull> OR CAN ANYONE GUIDE ME AROUND CABAL
20:30:05 <lispy> hi nick.  Please be courteous :)  Did you get cabal-install installed?
20:31:01 <mmorrow> happs-util is on both hackage and the happs website
20:31:10 <mmorrow> as are all of the happs packages
20:31:31 <roconnor> oh boy, finding a minimal test case is hard
20:31:50 <nicknull> not a repo : darcs get --partial http://happs.org/HAppS
20:31:56 <lispy> ?go Minimal Test Cases Considered Harmful
20:31:59 <lambdabot> http://ajaxian.com/archives/javascript-associative-arrays-considered-harmful
20:31:59 <lambdabot> Title: Ajaxian Â» Javascript Associative Arrays considered harmful
20:32:07 <mmorrow> probably because there is no package called "HAppS"
20:32:26 <mmorrow> there is however HAppS-Util, HAppS-Data, HAppS-...
20:34:01 <mmorrow> nicknull: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:Distributed%20Computing
20:34:03 <lambdabot> Title: HackageDB: packages by category, http://tinyurl.com/yqov7f
20:34:21 <nicknull> why isnt there one package to install it all?
20:34:31 <mmorrow> beats me
20:35:20 <nicknull> does cabal-install not come with ghc-6.8.3? bu cabal does?
20:36:16 <mmorrow> also, cabal-make-you-a-sammich doesn't come with ghc until 6.12
20:36:36 <dancor> i want something like unix 'comm' to use in my haskell scripting.  do you think it should return ([a], [a], [a]) or like [Either a (Either a a)]..
20:37:27 <dancor> it's bc alexj is so crazy
20:38:10 <roconnor> can someone check if compling http://hpaste.org/11251 hangs their GHC 6.10 ?
20:38:13 <dancor> nicknull: i guess someone should make something.  i do this order: Util, Data, State, IxSet, Server
20:39:02 <lispy> nicknull: you'll need to get cabal-install from hackage
20:39:16 <lispy> nicknull: it's worth the effort
20:39:33 <lispy> nicknull: once you have a working cabal-install you can get whatever you need with a simple commandline
20:39:36 <JuanDaugherty> FTR since this is a publicly logged channel, that iFrames are not just deprecated but actively dropped from XHTML is the answer to how a Haskell would handle multiple iFrame histories differently from one in a conventional language and also the larger issue of how Haskell relates to implicit specification.
20:39:38 <dancor> oh right cabal-install will do it right
20:39:58 <JuanDaugherty> *Haskell browser
20:40:06 <sclv> install um zlib and http
20:40:12 <sclv> then cabal install installs
20:40:26 <sclv> then cabal install HAppS-Server
20:40:32 <sclv> and you have HAppS
20:40:37 <sclv> but it is not lightweight.
20:40:58 <sclv> and it is ill-documented, although there are excellent tutorials for it.
20:40:59 <dancor> roconnor: do i need some crazy -X?  http://hpaste.org/11251#a1
20:41:09 <sclv> it is however, relatively battle-tested by this point.
20:41:11 <dancor> and i couldn't get Facebook.hs to work
20:41:28 <nicknull> im missing hslogger
20:41:28 <nicknull> what is that?
20:41:28 <nicknull> it wokrs on windows right?
20:41:32 <sclv> lightweight is just use Network.CGI and roll yr own -- its shockingly easy. Or use fastcgi.
20:41:49 <sclv> if you go with the cabal install route, hslogger will be installed automatically.
20:41:51 <nicknull> im missing cabal it syas
20:41:54 <nicknull> but i have it
20:42:07 <lispy> nicknull: cabal and cabal-install are different
20:42:09 <sclv> I think the latest happs installs out of the box on windows.
20:42:12 <roconnor> dancor: no the code has a type error.  However it hangs my GHC 6.8.
20:42:15 <lispy> nicknull: could you hpaste your error message?
20:42:23 <nicknull> ok cabal-install ti is first then
20:43:00 <dancor> roconnor: same result on ghc 6.8.3 for me
20:43:04 <dancor> on another box
20:43:13 <dancor> same result = it doesn't hang
20:43:19 <roconnor> dancor: I have 6.8.2
20:43:35 <roconnor> good to know it got fixed
20:43:37 <mmorrow> cool http://moonpatio.com/images/applewo.jpg
20:43:57 <mmorrow> i think i got that img from wikipedia, but i can't remember
20:44:21 <mmorrow> it's code to a prog whose code moves in memory
20:44:36 <nicknull> jeus christ
20:44:40 <roconnor> are type classes always exported?
20:44:49 <nicknull> During interactive linking, GHCi couldn't find the following symbol:
20:44:49 <nicknull>   SHGetFolderPathA@20
20:44:49 <nicknull> This may be due to you not asking GHCi to load extra object files,
20:44:49 <nicknull> archives or DLLs needed by your current session.  Restart GHCi, specifying
20:44:49 <nicknull> the missing library usi
20:44:55 <nicknull> oops
20:45:22 <sclv> mmorrow: not to nag, but are you going to push the ieee-monad thing to hackage?
20:45:27 <nicknull> which is the latest ghc?
20:45:38 <nicknull> will upgrading solve any of this?
20:45:47 <sclv> even as is, I think it would be nice, given the conversation on -cafe, which i've been meaning to weigh in on.
20:45:51 <sclv> nicknull: latest is 6.8.3
20:46:05 <sclv> 6.8 anything should be fine for HAppS
20:46:06 <lispy> mmorrow: ieee-monad?
20:46:26 <mmorrow> sclv: i uploaded yesterday (or the day before)
20:46:31 <sclv> oh, cool!
20:46:37 <mmorrow> sclv: sorry bout the delay :)
20:46:53 <sclv> no prob -- I just wanted to be able to point to it on -cafe and get some feedback.
20:47:23 <mmorrow> sclv: cool
20:47:29 <lispy> sclv: is that for the thread that talks about doing floating point operations in IO so it can specify FP flags and traps?
20:47:34 <mmorrow> i'd love to hear what people say
20:47:41 <sclv> lispy: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ieee-utils
20:47:43 <lambdabot> Title: HackageDB: ieee-utils-0.4.0, http://tinyurl.com/3q5p2h
20:48:40 <lispy> sclv: crazy
20:49:35 <mmorrow> sclv: i came across some comments in one of the ghc codegen modules describing (the hackery involved in) how ghc generates floating point code for x86. i'll find the link..
20:50:02 <sclv> oh, cool.
20:50:03 <lispy> ?hoogle createFile
20:50:03 <lambdabot> No results found
20:50:06 <roconnor> dcoutts_ or anyone: do packages allow you to export some modules but keep other modules "internal"?
20:50:26 <sclv> roconnor: yep
20:50:35 <nicknull> unsafePerformSuicide
20:50:55 <mmorrow> also, here's ghc haddocks from a week ago tops (the 6.10 rc-1) http://moonpatio.com/docs/ghc/
20:50:56 <lambdabot> Title: ghc-6.10.0.20081007: XXX
20:51:04 <sclv> roconner: other-modules instead of exposed-modules, I think, for the internal ones.
20:51:10 <mmorrow> ok, 10 days :)
20:51:29 <roconnor> sclv: excellent
20:51:30 <lispy> mmorrow: unacceptable!
20:51:36 <nicknull> well what is hslogger?
20:51:42 * mmorrow does 50 pushups
20:51:51 <lispy> nicknull: a logging library?
20:52:04 <lispy> nicknull: is it missing, or?
20:52:28 <mmorrow> there's also HsColourized src here http://moonpatio.com/docs/ghc/src/
20:52:29 <lambdabot> Title: Index of /docs/ghc/src
20:52:40 <sclv> crazy. ghc has a maybeT transformer but the mtl still doesn't!
20:52:59 <vininim> http://www.ncbi.nlm.nih.gov/entrez/viewer.fcgi?val=NC_005109.2&from=27037561&to=27126074&strand=2&dopt=gb
20:53:01 <lambdabot> Title: NCBI Sequence Viewer v2.0, http://tinyurl.com/58w8u2
20:53:06 <vininim> errr... wrong channel
20:53:59 <nicknull> im missing unix -any . ok what does tha tmean? that i need a unix-system to run happs?
20:54:44 <sclv> the stupid happs cabal file asks for the unix package, but as i recall you don't really need it.
20:54:55 <sclv> but you need to manually go in and remove it from the cabal file before installing.
20:55:12 <sclv> Guess its not fixed on hackage, but rumor had it the cabal file was fixed in devel?
20:55:23 <lispy> if you change the .cabal file don't forget to re-run configure
20:55:47 <mmorrow> sclv: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=198#a198
20:55:50 * ddarius is going to make a project that doesn't use any external libraries but depends on all of hackage.
20:56:17 <mmorrow> that comment pretty much describes everything about the code for fp on x86 that GHC generates
20:56:18 * ddarius is sure dcoutts already has such a .cabal file.
20:56:35 <dons> ddarius: probably not, but cabal install $(cat all_of_it) works
20:57:08 <sclv> oh wow, fascinating.
20:57:12 <dons> ddarius: all of it http://galois.com/~dons/tmp/pkgs-6.10
20:57:16 <lispy> :t modify
20:57:17 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
20:57:53 <nicknull> from setup or hslogger.cabal?
20:58:14 <mmorrow> sclv: that comment is from this file http://moonpatio.com/docs/ghc/src/MachInstrs.html
20:58:18 <lambdabot> Title: nativeGen/MachInstrs.hs
20:58:29 <nicknull> if !os(win32)
20:58:29 <nicknull>         Build-Depends: unix
20:58:41 <nicknull> that?
20:58:43 <mmorrow> which is a pretty cool file i must say
20:58:55 <dancor> do ppl usually use like ((x, y), z) instead of (x, y, z) to get fst and snd
20:59:16 <dons> i think people like 'fst' and 'snd' :)
20:59:39 <lispy> dancor: I think only 2-tuples are common.  Usually people seem to make a data types for anything more than 2-tuples (in my experience)
20:59:43 <dancor> like when's the last time you used a triple instead of a grouped double
20:59:47 <dancor> ok
21:00:10 <lispy> dancor: the nice thing about a 3-tuple is that you can make it with zipWith3
21:00:37 <sclv> nicknull: that looks right.
21:00:59 <Dianora> the timing
21:01:07 <sclv> dunno why it isn't properly excluding the dependency for windows based on that cabal file though..
21:01:32 <Dianora> <srg1218:##c> vorpal: I was hoping with that many that I could convince two
21:01:32 <Dianora> +of them to do a threesome
21:01:36 <Dianora> <lispy> dancor: the nice thing about a 3-tuple is that you can make it with
21:01:36 <Dianora> +zipWith3
21:01:38 <sclv> dancor: when I use 3-tuples, I generally just write a fst3 function and snd3 function
21:01:45 <Dianora> those two lines were side by side
21:01:54 <sclv> and drop them in a where clause, or uptop if i use them frequently.
21:01:56 <pc`> \quit
21:02:06 <dancor> sclv: tho here i'm going to need first3 second3 third3 as well
21:02:29 <dancor> it's turning into a bytestring-level alternate implementation :)
21:02:40 <pc`> \help
21:02:47 <sclv> if yr using the three-tuple lots of places its worth it to declare a record type.
21:02:49 <dancor> pc`: seriously?  forward-slash
21:02:59 <dancor> /
21:03:46 <sclv> or depending on the logic of your program, rather than calling accessor functions, it might be possible to pattern match on it directly..
21:05:48 <lispy> > [] `isPrefixOf` "blah"
21:05:50 <lambdabot>   True
21:18:04 <slava> dons: ping
21:21:26 <roconnor> what operations are there on colours other than blend and composite?
21:23:21 <lispy> roconnor: ord?
21:23:30 <eck> how do you convert a Handle to a file descriptor?
21:23:42 <lispy> ?hoogle Handle -> Int
21:23:42 <lambdabot> Data.Generics.Schemes gsize :: Data a => a -> Int
21:23:43 <lambdabot> Data.Generics.Schemes gdepth :: GenericQ Int
21:23:43 <lambdabot> Data.Generics.Schemes glength :: GenericQ Int
21:23:45 <roconnor> nope
21:25:27 <roconnor> @hoogle Handle -> FileDescriptor
21:25:27 <lispy> suppose, I define (:<) infix n, and (:<-) as infix n+1, then what is the precedence of foo :< bar :<- baz, ?
21:25:27 <lambdabot> Warning: Unknown type FileDescriptor
21:25:27 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
21:25:27 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
21:26:13 <lispy> is it foo :< (bar :<- baz)?
21:26:37 <dolio> Yes.
21:27:18 <eck> ah i found it
21:27:29 <eck> there's a handleToFd in System.Posix.IO
21:27:56 <roconnor> eck: http://haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-IO.html#10
21:27:57 <lambdabot> Title: System.Posix.IO, http://tinyurl.com/2yjzc2
21:27:59 <roconnor> oh
21:28:01 <sclv> roconnor: invert?
21:28:03 <roconnor> you found it
21:28:10 <eck> you were just a moment too late :-)
21:29:15 <roconnor> sclv: hmm.
21:29:22 <roconnor> sclv: probably not.
21:29:35 <lispy> roconnor: flatten?
21:29:57 <sclv> not sure if blend and composite are enough to give you discrete control over hue saturation value either?
21:30:29 <roconnor> sclv: well, I think converting to HSV is a reasonable operation
21:30:39 <roconnor> then you can do whatever you want to those numbers
21:30:46 <sclv> and naturally back too then.
21:30:50 <roconnor> yes
21:31:01 <roconnor> Right now I only have to and from sRGB
21:31:29 <roconnor> adding HSV HLS XYZ would be good.
21:31:44 <sclv> cmyk?
21:31:45 <roconnor> maybe other RGBs as well
21:32:00 <roconnor> cmyk would be good if I knew anything about it :)
21:32:05 <mmorrow> roconnor: here a "scanned" chapter from this good compgraphics book i used in a course http://moonpatio.com:8080/color/color/
21:32:31 <mmorrow> i put that there for ddarius when he was doing some color stuff
21:32:36 <dolio> You can't possibly do anything Professional without cmyk.
21:32:41 <sclv> doesn't need to be a core operation i suppose, but also a "snap-to" function would be useful.
21:32:47 <roconnor> oh, what colour stuff was ddarious doing?
21:32:50 <mmorrow> that chapter'll tell you most everything you need to know
21:32:57 <sclv> Color -> [Colors] -> Color
21:33:11 <sclv> gives the closest matching color from a set
21:33:14 <roconnor> mmorrow: I used to work for a software video company. :)
21:33:39 <sclv> for matching pantone, or websafe, or a limited palette for whatever other reasons.
21:33:49 <roconnor> sclv: that reduces to computing the distance between colours: a difficult but interesting opertation.
21:34:08 <roconnor> I'll leave that one out for now.
21:34:12 <mmorrow> roconnor: awesome. that book is an excellent reference :)
21:34:14 <sclv> roconnor: right. also, without invert you'll need something else to give you "subtract" though?
21:35:00 <roconnor> sclv: there is no add or subtract
21:35:36 <mmorrow> roconnor: ddarius was coding what sounded like the same thing you're doing now :)
21:35:48 <mmorrow> i dunno how that went though..
21:35:53 <roconnor> :)
21:36:04 <roconnor> I probably have enough code to make a 0.1 release now
21:36:29 <roconnor> I needs some module interfaces,  haddock and quickcheck
21:36:33 <roconnor> It needs ...
21:36:45 <mmorrow> what colorspaces are you going to include?
21:37:47 <roconnor> well... the type of color is independent of the colour space I happen to be using for it's representation
21:37:58 <mmorrow> that chapter gives specs for HSL, HSV, YIQ, (RGB), ...
21:38:15 <roconnor> so that is an internal issue
21:38:29 <mmorrow> C code for conversion with minimal error as well
21:38:38 <roconnor> on the other hand, one may want to get in and out of the colour type from various parameterizations
21:38:50 <roconnor> right now I only have sRGB
21:39:09 <roconnor> I should add at least HSL and HSV
21:39:22 <mmorrow> i think colorspace conversion would be super useful for sure
21:39:27 <roconnor> some form of YUV may also be appropriate
21:39:48 <mmorrow> teh more teh better :)
21:40:45 <roconnor> :) ya
21:42:28 <roconnor> kelvin to colour :)
21:42:33 <roconnor> hmm
21:42:41 <mmorrow> heh
21:42:53 <mmorrow> computing intensity would def be useful as well
21:42:59 <mmorrow> as would gamma correction
21:43:27 <roconnor> gamma correction is a fundamental part of my library
21:43:48 <roconnor> my hope is that this library, if widely used, will prevent crappy colour mixing in haskell programs.
21:44:12 <lispy> roconnor++
21:44:30 <roconnor> types enforce that blending colours happens in a linear colour space
21:44:44 <lispy> rock on
21:44:52 <lispy> that's what I want to hera
21:44:54 <lispy> hear*
21:45:13 <mmorrow> roconnor: haha, typed color blending
21:45:17 <mmorrow> haskell++
21:45:24 <roconnor> the user would have to extract the sRGB components and mix them and put them back to subvert it.
21:45:40 <mmorrow> unsafePerformMix
21:45:47 <roconnor> :)
21:45:50 <lispy> :t writeFile
21:45:51 <lambdabot> FilePath -> String -> IO ()
21:47:13 <roconnor> mmorrow: thanks for the pictures.  I know most of that information, but makes a good reference.
21:47:32 <roconnor> esp. since I haven't done this type of work in a few yers
21:47:34 <roconnor> years
21:48:38 <roconnor> lispy: not only that but I'm using phantom types to make sure I don't mix up Red, Green and Blue channels
21:48:45 <roconnor> it already caught one error.
21:48:52 <mmorrow> no prob, i forgot i had that there until now, so wget em if you want em because i may give them the chop soon
21:48:58 <lispy> roconnor: gadts too or just phantoms?
21:51:13 <roconnor> lispy: just phantoms.  I want to keep this H98 if reasonable to do so.
21:52:04 <lispy> roconnor: oh you purists :)
21:52:17 * lispy treats GHC as if it were *the* Haskell
21:52:45 <roconnor> lispy: If I want this to be *the* standard Haskell colour library, I want it to be especially portable.
21:52:55 <lispy> roconnor: yeah
21:53:02 <lispy> I'm just teasing you
21:53:07 <roconnor> :)
21:53:42 <dons> roconnor: so more  than just RGB !Double !Double !Double ?
21:53:46 <dons> or whatever it is
21:53:54 <roconnor> > sRGB24show $ blend 0.5 black white
21:53:55 <lambdabot>   mueval: Prelude.read: no parse
21:53:56 <roconnor> "#bcbcbc"
21:53:58 <roconnor> :)
21:54:00 <dons> mmm
21:54:09 <dons> good stuff
21:54:18 <thoughtpolice> lispy: some extensions are just too nice :]
21:54:22 <roconnor> data RGB a = RGB !(Chan Red a) !(Chan Green a) !(Chan Blue a)
21:54:24 * Nafai reads learnyouahaskell.com
21:54:37 <dons> Chan??
21:54:43 <dons> no, different chan
21:54:44 <dons> phew.
21:54:47 <mmorrow> hah
21:54:51 <roconnor> newtype Chan p a = Chan a deriving (Eq)
21:55:03 <roconnor> Chan is kinda a bad name
21:55:10 <dons> Channel perhaps
21:55:13 <roconnor> but I'm not planning to export it out of the package
21:55:24 <roconnor> so I don't think it is a big deal
21:55:26 <dons> ok
21:55:33 <dons> just nearly gave me a heart attack
21:55:40 <lispy> roconnor: right, if you're using phantom types, you probably want to provide all the constructors/destructors opaquely
21:55:42 <roconnor> ya
21:55:46 <roconnor> understandable
21:56:10 <roconnor> lispy: I'm not sure I understand you, but I'm not planning to export the constructors.
21:56:17 * lispy notes that in roconnor's implementation cmyk would be 4Chan
21:56:27 * roconnor groans
21:56:49 <lispy> roconnor: my experience with phantoms is that it's usually best to do what you describe and that's what I meant
21:57:52 <roconnor> dons: I also define tan = sRGB24 0xD2 0xB4 0x8C in Data.Colour.Names
21:58:01 <roconnor> but I'm expecting that module to be imported qualified when used.
21:58:18 <roconnor> (tan clashes with a Prelude function!)
21:58:26 <lispy> > tan 0.1
21:58:28 <lambdabot>   0.10033467208545055
21:58:39 <lispy> > iterate tan
21:58:40 <lambdabot>       Overlapping instances for Show (a -> [a])
21:58:40 <lambdabot>        arising from a use of ...
21:58:53 <lispy> > fix tan
21:59:00 <lispy> > fix sin
21:59:02 <lispy> > fix cos
21:59:04 <lambdabot>   * Exception: stack overflow
21:59:04 <lambdabot>   * Exception: stack overflow
21:59:05 <lambdabot>   * Exception: stack overflow
21:59:11 <lispy> bummer
21:59:16 <lispy> I figured at least one of those wolud be 0
21:59:27 <dons> sssstack overflow eh?
21:59:44 <dmwit> 0 is not the *least* fixed-point.
21:59:46 <dmwit> ;-)
21:59:53 <dons> huh
21:59:58 <lispy> yeah, stack overflow is
22:00:07 <lispy> duh
22:00:46 <lispy> > fix (\x -> (sin x)/x)
22:00:53 <dmwit> Does anybody else find it a bit odd that fix comes from the Control.Monad hierarchy?
22:01:00 <lispy> dmwit: yes
22:01:02 <lambdabot>   thread killed
22:01:08 <roconnor> @hoogle fix
22:01:08 <lambdabot> Data.Function fix :: (a -> a) -> a
22:01:08 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
22:01:08 <lambdabot> module Control.Monad.Fix
22:01:19 <roconnor> It's also in Data.Function
22:01:19 <dmwit> Ah, at least it's in Data.Function.
22:01:22 <dmwit> That's a step forward.
22:01:27 <lispy> :t fix . fix
22:01:28 <lambdabot> forall a. ((a -> a) -> a -> a) -> a
22:01:46 <lispy> > fix (fix const)
22:01:47 <lambdabot>       Occurs check: cannot construct the infinite type: a = b -> a
22:01:47 <lambdabot>      Proba...
22:02:18 <dons> lispy: that's an evil function, 'fix tan'
22:02:32 <dons> after eating up 4g of my ram.. i can assert that safely.
22:02:32 <roconnor> > fix id
22:02:33 <lambdabot>   * Exception: stack overflow
22:02:38 <lispy> dons: lol
22:02:45 <mmorrow> , let clr (name,cons) = let (n:a:cs) = fmap mkName (name:"a":cons) in DataD [] n [a] [NormalC n (fmap (\x -> (IsStrict, AppT (AppT (VarT (mkName "Chan")) (VarT x)) (VarT a))) cs)] [] in ppDoc $ clr ("RGB",["Red","Green","Blue"])
22:02:46 <dons> i was quite surprised how malicious it was.
22:02:47 <lunabot>  data RGB a = RGB !(Chan Red a) !(Chan Green a) !(Chan Blue a)
22:02:55 <lispy> dons: yeah, why would that be so bad?
22:02:56 <mmorrow> , let clr (name,cons) = let (n:a:cs) = fmap mkName (name:"a":cons) in DataD [] n [a] [NormalC n (fmap (\x -> (IsStrict, AppT (AppT (VarT (mkName "Chan")) (VarT x)) (VarT a))) cs)] [] in ppDoc $ clr ("HSV",["H","S","V"])
22:02:59 <lunabot>  data HSV a = HSV !(Chan H a) !(Chan S a) !(Chan V a)
22:03:05 <mmorrow> ...
22:03:06 <mmorrow> :)
22:03:50 <lispy> > sin 0
22:03:52 <lambdabot>   0.0
22:03:59 <mmorrow> , let clr (name,cons) = let (n:a:cs) = fmap mkName (name:"a":cons) in DataD [] n [a] [NormalC n (fmap (\x -> (IsStrict, AppT (AppT (VarT (mkName "Chan")) (VarT x)) (VarT a))) cs)] [] in ppDoc $ clr ("HHG",["Hue","Hour","Green"])
22:04:01 <lunabot>  data HHG a = HHG !(Chan Hue a) !(Chan Hour a) !(Chan Green a)
22:04:30 <lispy> > iterate sin 0
22:04:31 <lambdabot>   [0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0....
22:04:34 <lispy> > iterate sin 1
22:04:35 <lambdabot>   [1.0,0.8414709848078965,0.7456241416655579,0.6784304773607402,0.62757183204...
22:04:49 <mmorrow> , fix tan
22:04:52 <lunabot>  luna: out of memory (requested 2097152 bytes)
22:04:55 <dmwit> > iterate sin (-2 * pi)
22:04:57 <lambdabot>   [-6.283185307179586,2.4492935982947064e-16,2.4492935982947064e-16,2.4492935...
22:05:07 <lispy> > iterate (\x -> (sin x)/x) 1
22:05:08 <lambdabot>   [1.0,0.8414709848078965,0.8860960807053615,0.87418133921778,0.8774134744008...
22:05:16 <lispy> > drop 100$ iterate (\x -> (sin x)/x) 1
22:05:17 <lambdabot>   [0.8767262153950625,0.8767262153950625,0.8767262153950625,0.876726215395062...
22:05:24 <lispy> > drop 10000$ iterate (\x -> (sin x)/x) 1
22:05:25 <lambdabot>   [0.8767262153950625,0.8767262153950625,0.8767262153950625,0.876726215395062...
22:05:39 <lispy> I thought that was supposed to approach 0
22:05:43 <dmwit> no
22:05:47 <lispy> > drop 10000$ iterate (\x -> (sin x)/x) 0.1
22:05:47 <dmwit> You're thinking of
22:05:48 <lambdabot>   [0.8767262153950625,0.8767262153950625,0.8767262153950625,0.876726215395062...
22:05:57 <dmwit> lim_{x\to0} sin x / x
22:06:00 <dmwit> Which tends to 1.
22:06:07 <dmwit> What you're doing is not the same.
22:06:26 <lispy> dmwit: oh right tends to 1
22:06:38 <mmorrow> ooh, someone had a bot that plotted mathematica commands to a dyngen image on some website the other day
22:06:47 <mmorrow> it's probably still in here
22:06:48 <ddarius> mmorrow: Cale does.
22:07:01 <lispy> dmwit: I was trying to pick something that tended the same way that the output would, like x -> y, and foo x -> y, then I could iterate to get there
22:07:15 <mmorrow> ddarius: sweet, what's its nick?
22:07:26 <ddarius> mbot
22:07:27 <lispy> mmorrow: mbot?
22:07:32 <mmorrow> mbot: help
22:07:42 <ddarius> mbot isn't in this channel
22:07:58 <lispy> ?seen mbot
22:07:58 <lambdabot> I haven't seen mbot.
22:08:29 * mmorrow checks his logs
22:08:41 <rwbarton> it was keselbot or something
22:08:48 <mmorrow> yes, exactly
22:09:30 <mmorrow> just searched my logs
22:09:34 <mmorrow> do   /msg keselbot @math Plot[x^2*Sin[1/x^2],{x,0,2}]
22:10:02 <mmorrow> crap, keselbot is gone
22:18:06 <lispy> how do you uninstall a package?
22:19:54 <rwbarton> cabal-install doesn't support uninstall, you probably just want to hide it
22:20:04 <lispy> I want to purge it
22:20:13 <lispy> I didn't want to install it, running the tests installed it :(
22:20:36 <rwbarton> hmm, then I think you have to use ghc-pkg to track it down and unregister it then remove the files
22:21:05 <lispy> well, package.conf.old doesn't have it
22:22:01 <mmorrow> i guess you can just delete it then
22:22:16 <lispy> whree would the files for the package be located?
22:22:24 <rwbarton> package.conf should tell you
22:22:34 <rwbarton> I think?
22:23:14 <rwbarton> or ghc-pkg describe foo
22:23:39 <lispy> ah $HOME/lib
22:23:42 <lispy> then foo
22:26:13 <mmorrow> ls `ghc --print-libdir`/..
22:26:18 <mmorrow> may help
22:30:08 <lispy> I got it now, thanks guys
22:43:22 <Saul_> If I make a request with the http lib and I say that I will accept gzip and deflate encodings, do I have to decode those manually or is it done for me?
22:47:05 <lispy> cabal: Error: some packages failed to install:
22:47:05 <lispy> haskell-src-1.0.1.3 failed during the building phase. The exception was:
22:47:05 <lispy> exit: ExitFailure 1
22:47:10 <lispy> is that anything to worry about?
22:47:31 <lispy> oh, happy is required
22:49:28 <mmorrow> http://arxiv.org/html/cs.PL/0311032
22:49:46 <mmorrow> Saul_: you'll have to do it manually
22:49:54 <Saul_> mmorrow: Ok thanks
22:50:32 <Saul_> mmorrow: I just saw that simpleHTTP doesn't even allow it (it just won't pass the header (plus others like connection: keep-alive))
22:52:22 <mmorrow> Saul_: hmm, sucky. if you have the time or the will, maybe you want to hack the src and add it.
22:53:13 <mmorrow> ooh, i just noticed that HTTP uses String in both Request and Responsem, ugh. you'd want ByteStrings..
22:53:38 <dons> bytestring-http is a loong needed package
22:53:58 <mmorrow> yeah, hmm
22:54:04 <Saul_> yup
22:54:45 <Saul_> Although my files are small enough to just use Strings
22:55:23 <mmorrow> the zlib package expects a lazy ByteString as input though, so you'd have to constantly be packing
22:55:44 <rwbarton> there's a package out there that's a lazy ByteString version of HTTP
22:55:55 <rwbarton> not on hackage though, I don't think
22:55:57 <lispy> mmorrow: recent versions of zlib package let you specify a chunk size, so you can use it as if it were strict
22:56:25 <mmorrow> lispy: ooh, that's awesome.
22:56:44 <mmorrow> (Saul_ unfortunately would only have a String though if he used HTTP)
22:58:06 <dons> don't pack!
22:59:46 <mmorrow> don't hit the crack!
23:02:21 <Axman6> @pl cFromP p = loadProgram ((emptyCPU . memorySize) p) p
23:02:21 <lambdabot> cFromP = loadProgram =<< emptyCPU . memorySize
23:03:22 <rwbarton> @pl \x -> f x (g x)
23:03:23 <lambdabot> ap f g
23:03:29 <rwbarton> @pl \x -> f (g x) x
23:03:29 <lispy> emptyCPU :: Intel
23:03:29 <lambdabot> f =<< g
23:03:46 <mmorrow> @pl \x y -> a = b x = y z z z
23:03:47 <lambdabot> (line 1, column 11):
23:03:47 <lambdabot> unexpected "="
23:03:47 <lambdabot> expecting variable, "(", operator or end of input
23:03:59 <mmorrow> heh, i never knew @pl did =
23:04:03 <lispy> @pl \x y -> f (g x) (g y)
23:04:03 <lambdabot> (. g) . f . g
23:04:20 <mmorrow> @pl f x y z = z (y f) x
23:04:20 <lambdabot> f = fix (flip . ((flip . flip id) .) . flip id)
23:04:28 <mmorrow> sweet
23:04:39 <Axman6> @pl \p -> f ((g.h) p) p
23:04:40 <lambdabot> f =<< g . h
23:04:45 <Axman6> good good
23:04:56 <mmorrow> @unpl f = a . b . c
23:04:57 <lambdabot> f f = a (b (c f))
23:05:04 <rwbarton> !
23:05:05 <mmorrow> heh
23:05:06 <lispy> ?pl on f g x y = f (g x) (g y)
23:05:06 <lambdabot> on = join . ((flip . ((.) .)) .) . (.)
23:05:15 <mmorrow> @unpl f = a . b
23:05:15 <lambdabot> f e = a (b e)
23:05:20 <lispy> ?src on
23:05:20 <lambdabot> (*) `on` f = \x y -> f x * f y
23:05:22 <mmorrow> @unpl f = a . b . c . d
23:05:22 <lambdabot> f g = a (b (c (d g)))
23:05:27 <rwbarton> :t let f f = a (b (c f)) in f
23:05:28 <lambdabot>     Couldn't match expected type `t -> t1' against inferred type `Expr'
23:05:28 <lambdabot>     In the first argument of `b', namely `(c f)'
23:05:28 <lambdabot>     In the first argument of `a', namely `(b (c f))'
23:05:43 <mmorrow> fail
23:05:49 <rwbarton> :t let f7 f7 = a7 (b7 (c7 f7)) in f7
23:05:50 <lambdabot> Not in scope: `a7'
23:05:50 <lambdabot> Not in scope: `b7'
23:05:50 <lambdabot> Not in scope: `c7'
23:06:04 <rwbarton> :t let f f = ?a (?b (?c f)) in f
23:06:05 <lambdabot> forall t t1 t2 t3. (?c::t2 -> t1, ?b::t1 -> t, ?a::t -> t3) => t2 -> t3
23:06:22 <mmorrow> @remember unpl f = a . b . c ===> f f = a (b (c f))
23:06:22 <lambdabot> Done.
23:06:35 <lispy> whoa
23:06:38 <rwbarton> I guess the second f shadows the first one...
23:06:55 <rwbarton> > (\x x -> x) 3 4
23:06:56 <lambdabot>       Conflicting definitions for `x'
23:06:56 <lambdabot>      In a lambda abstraction
23:07:07 <mmorrow> unpl: obfuscated haskell technique generator
23:07:16 <lispy> ?let f f = f
23:07:17 <lambdabot>  Defined.
23:07:21 <lispy> > f 1
23:07:22 <lambdabot>       Ambiguous occurrence `f'
23:07:22 <lambdabot>      It could refer to either `L.f', defined a...
23:07:30 <rwbarton> > L.f 1
23:07:31 <lambdabot>   1
23:07:53 <lispy> That's just weird
23:08:15 <lispy> GHCi> let f f = f + 1
23:08:16 <lispy> GHCi> :t f
23:08:16 <lispy> f :: (Num a) => a -> a
23:08:16 <lispy> GHCi> f 1
23:08:16 <lispy> 2
23:08:18 <mmorrow> , let f f f f f = f in f 0 1 2 3 4
23:08:19 <lunabot>  luna: Conflicting definitions for `f'
23:08:48 <lispy> I had no idea this was legal
23:09:11 <lispy> :t let f f = f f in f
23:09:13 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
23:09:13 <lambdabot>     Probable cause: `f' is applied to too many arguments
23:09:13 <lambdabot>     In the expression: f f
23:09:22 <pjdelport> lispy: you can do that in most languages
23:09:27 <mmorrow> i guess it's no different than  let x = (\x -> x)
23:09:29 <pjdelport> def foo(foo): ...
23:09:37 <mmorrow> or   case xs of x:xs ->
23:09:50 <lispy> it seems as though this disable recursion
23:10:04 <mmorrow> indeed
23:10:04 <lispy> or maybe not
23:10:10 <pjdelport> well, it shadows the outer f
23:10:10 <rwbarton> > let f f = case f of [f] -> f in f [3]
23:10:12 <lambdabot>   3
23:10:14 <lispy> > let f f = f 1 in f
23:10:15 <pjdelport> you can still use fix or whatever
23:10:15 <lambdabot>       Overlapping instances for Show ((t -> t1) -> t1)
23:10:15 <lambdabot>        arising from a ...
23:10:19 <lispy> :t let f f = f 1 in f
23:10:20 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
23:10:38 <lispy> oh, I'm sully
23:10:40 <lispy> silly
23:10:45 * Axman6 is very proud
23:10:54 <Axman6> just wrote my first working assembly program
23:11:25 <rwbarton> Axman6: using harpy?
23:11:26 <lispy> Axman6: cool, as in you're writing a compiler?
23:11:54 <Axman6> i'm using this: http://www.engr.uconn.edu/~jeffm/Classes/CSE240-Spring-2001/Projects/project05/project5/project5.html
23:11:56 <lambdabot> Title: CSE240: Intermediate Computer Systems Fall 2000 Project 5: Assembly programs, http://tinyurl.com/5hpguo
23:12:06 <Saul_> Is there something like a Map type that uses an Enum type to generate keys for new values?
23:12:13 <Axman6> i went through the first 4 projects in about 2 days, and now i'm up to writing things in assembly
23:12:13 <jeffz> hm, I wonder how hard it would be to get harpy working on x86-64
23:12:23 <Axman6> what is harpy anyway?
23:12:32 <Axman6> @where harpy
23:12:32 <lambdabot> http://uebb.cs.tu-berlin.de/harpy/
23:12:35 <jeffz> runtime codegen
23:12:47 <lispy> Axman6: cool
23:13:00 <pjdelport> Saul_: Data.IntMap ?
23:13:05 <Axman6> it's a lot of fun
23:13:16 <Axman6> especially since i've never do any assembly before
23:13:18 * lispy has a project that should probably get converted to harpy
23:13:40 <Saul_> pjdelport: That's just a more efficient version of Map for int keys
23:13:44 <rwbarton> Someone should write a Flash player using harpy
23:13:48 <Axman6> How many numbers? 2
23:13:48 <Axman6> 1? 4294967296
23:13:48 <Axman6> 2? 4
23:13:49 <Axman6> The sum is 4
23:13:54 <Axman6> >_>
23:14:19 <Saul_> pjdelport: I actually don't want to use the key when I'm inserting  something, it should come up with one itself
23:14:33 <mmorrow> someone should code up some classic virus in harpy
23:14:56 <pjdelport> Saul_: you could define a bunch of helpers then, i guess
23:14:58 <Axman6> rwbarton: possibly not related, but have you seen the C to Flash compiler written using LLVM? they're getting some pretty damn impressive results
23:15:26 <Saul_> so probably something like data EnumMap k a = forall k. (Ord k, Enum k) => EnumMap k (Map k a)
23:15:30 <rwbarton> Axman6: Hmm
23:15:38 <Saul_> pjdelport: I guess I might
23:16:05 <Saul_> Is there enough interest in that to warrant a library release?
23:16:37 <lispy> Saul_: they are stored in insertion order?
23:16:49 <lispy> Saul_: oh, n/m
23:17:14 <rwbarton> Sounds kind of like Data.Sequence
23:17:18 <pjdelport> Saul_: you could maybe define a module that just re-exports Data.IntMap, with certain operations tweaked
23:17:28 <pjdelport> like member = M.member . fromEnum
23:17:42 <pjdelport> and so on
23:18:02 <Saul_> pjdelport: But how would you determine the next key on insertion?
23:18:18 <pjdelport> next key?
23:18:35 <rwbarton> Saul_: well, you can get the maximum key out of the map in O(log n) time
23:18:53 <rwbarton> which is asymptotically how long it takes to do an insertion anyways
23:19:00 <pjdelport> that would use the fromEnum value as the key
23:19:17 <pjdelport> so the Enum instance determines all the keys
23:19:28 <Saul_> rwbarton: That might be more practical then than rewriting everything, since insertion is alteady log n
23:19:44 <pjdelport> Saul_: isn't that what you want?
23:19:57 <Saul_> pjdelport: I think you misunderstood me, I want an insert function where you don't have to provide a key for
23:20:06 <pjdelport> sure
23:20:32 <Saul_> pjdelport: and it then uses a store value to generate the next key
23:20:32 <rwbarton> Do you also have an insert function where you do specify a key?
23:20:49 <Saul_> rwbarton: That's the default for Data.Map
23:20:49 <rwbarton> You can also just keep a pair (k, Map k v)
23:21:19 <Saul_> That's the same thing as what I said above: "data EnumMap k a = forall k. (Ord k, Enum k) => EnumMap k (Map k a)"
23:21:21 <rwbarton> Right, I don't know what all the operations you want to support are, whether it's everything in Data.Map plus this new thing, or just insertion without a key and lookup, or what
23:21:27 <rwbarton> Ah, so it is.
23:21:38 <rwbarton> Although that syntax is an existential type, which I don't think you want
23:21:55 <rwbarton> Just delete the class constraint
23:22:00 <rwbarton> put it on your functions
23:22:32 <Saul_> Yeah I might, it was more for documentation
23:23:23 <Saul_> My initial idea was to not support all Map operations but only those that make sense if keys are chosen
23:24:03 <Saul_> But if I just get the max key in log n time, I can just write one new insert function and still have everything else
23:24:14 <Saul_> including the old insert
23:24:19 <pjdelport> Saul_: i thought you wanted to use Enum to get the keys?
23:24:24 <Saul_> might be more practical
23:24:57 <pjdelport> so e.g. you would redefine insert as insert x = M.insert (fromEnum x) x
23:25:06 <Saul_> insertAuto :: (Ord k, Enum k) => a -> Map k a -> Map k a
23:25:20 <pjdelport> (or M.insert =<< fromEnum)
23:25:22 <Saul_> no that is not at all what I want
23:25:52 * pjdelport must be missing something
23:26:15 <dons> ... a committee of researchers got together to design a kick-ass language ...
23:26:17 <dons> yaya, research
23:26:25 <lispy> Saul_: wouldn't you need for Map to store the value of k internally?
23:26:31 <Saul_> pjdelport: Hang on I'll define the function I mean
23:26:42 <rwbarton> I think that Map is Saul.Map
23:26:49 <pjdelport> Saul_: what's wrong with the fromEnum approach?
23:26:49 <Axman6> dons: and called it, NR, or NinjaRaptor?
23:27:11 <lispy> pjdelport: the problem is that you're fromEnuming on a instead of k, if I undertand correctly
23:27:23 <pjdelport> lispy: isn't that the whole point?
23:27:30 <pjdelport> i.e., generating k from a
23:27:46 <lispy> pjdelport: well, baed on the class constraints of EnumMap, I don't think so
23:27:56 <pjdelport> oh, i see
23:28:06 <rwbarton> I think the point is to have a source of default key values
23:28:18 <pjdelport> well, you could still use fromEnum
23:28:34 <pjdelport> insert . fromEnum
23:29:22 <lispy> pjdelport: but if you look at the type of insertAuto, it just takes the value (no key) and the map
23:29:35 <Saul_> http://hpaste.org/11252
23:29:43 <lispy> pjdelport: I'm pretty sure the keys relate to internal state of the map such as insertion order
23:30:05 <Axman6> hmm, harpy looks interesting... X86 assembly does not however
23:30:29 <Saul_> lispy, pjdelport: I pasted the function that I want
23:30:55 <lispy> Saul_: it's like a database then
23:31:03 <lispy> Saul_: with an autoincrement field
23:31:03 <rwbarton> Axman6: oh, what have you been using?
23:31:09 <Axman6> ARM
23:31:21 <Saul_> lispy: Yeah pretty much
23:31:41 <pjdelport> Saul_: so the point is to preserve insertion order?
23:31:48 <lispy> Saul_: so, it seems like you want to newtype or data it
23:32:02 <lispy> Saul_: and track the biggest key yourself
23:32:21 <lispy> Saul_: but, then asymptoticly it doesn't matter...so premature optimization
23:32:26 <Saul_> pjdelport: No it's to not have to guess a unique key for your new data
23:32:42 <Saul_> lispy: I think this function will be enough
23:32:43 <pjdelport> Saul_: if you don't need to preserve order, then you can simply use fromEnum
23:32:48 <pjdelport> much simpler
23:33:12 <lispy> pjdelport: but that requires the values to support Enum
23:33:16 <pjdelport> Saul_: fromEnum is the unique key
23:33:24 <Saul_> pjdelport: That does something different though (although it would also work)
23:33:48 <lispy> if you're going to go with that approach, just use Data.Set
23:34:01 <pjdelport> lispy: yes, but that's what he originally asked for
23:34:58 <Saul_> pjdelport: I guess that would work, but fromEnum can give some pretty big numbers and the calculation can be very time consuming
23:35:11 <lispy> Saul_: so, now there won't be much relationship between keys and values.  So what have you gained over using something like a list?
23:35:13 <Saul_> pjdelport: I just want something simple
23:35:43 <pjdelport> Saul_: the size of the numbers don't matter
23:36:27 <pjdelport> and calculation shouldn't be time consuming
23:36:41 <pjdelport> (should it?  are there any Enum instances that do something crazy?)
23:37:18 <Saul_> lispy: I'll use the keys for associating stuff to it (like filenames that are indexed with it
23:37:20 <Saul_> )
23:37:31 <lispy> pjdelport: just the one implemented by ackerman's ...nothing big ;)
23:37:42 <Saul_> and references from other data (so again like an autoincrementing table)
23:37:55 <Saul_> and seeking in maps is faster that with lists
23:38:28 <pjdelport> Saul_: as for simple, the other approach is a lot more complicated than (insert . fromEnum)
23:39:09 <Saul_> pjdelport: If in your approach you insert something, then update it, then insert the same thing again, it will overwrite the updated data (which I don't want)
23:40:04 <Saul_> pjdelport: And I don't really see how it's more complicated, I think both approaches are pretty easy
23:40:12 <dmwit_> Saul_: It sounds like it's time to define yourself a little module that has the operations you want.
23:40:24 <pjdelport> Saul_: yes, you asked for unique keys, didn't you? :)
23:40:28 <dmwit_> Change the implementation later if it turns out to be bad, but at least get the function signatures right so you can start coding.
23:40:43 <pjdelport> so you want non-unique keys, to preserve duplicate values?
23:40:50 <Saul_> pjdelport: Yes but independent of whether the data is unique
23:43:28 <pjdelport> hmm, what are the semantics you actually want?
23:43:41 <pjdelport> you want to be able to insert and update values, but also insert duplicates?
23:44:05 <pjdelport> what would the update operation do, after you've inserted a duplicate?
23:44:35 <Saul_> Well the update function is unchanged
23:44:39 <lispy> Saul_: oh have you thought about using monad Unique or UniqueT?
23:45:46 <pjdelport> Saul_: well, it would have to choose one of them to update
23:45:48 <Saul_> lispy: Seems too complicated
23:45:50 <pjdelport> or update both
23:45:52 <pjdelport> or what
23:46:10 <Saul_> pjdelport: No because if you insert the same data twice, they have different keys
23:46:33 <lispy> Saul_: monad unique just provides a stream of fresh ids, like the keys you want
23:46:33 <Saul_> pjdelport: At least with my approach, with yours the first would be overwritten
23:47:13 <pjdelport> Saul_: but you don't specify the keys
23:47:35 <Saul_> lispy: But it requires IO, and I'm not sure how this would work with a Map read from a disk (which already has keys in it)
23:47:54 <lispy> Saul_: what requires IO?
23:48:06 <lispy> Monad Unique doesn't require it
23:48:57 <Saul_> pjdelport: I don't choose them myself, but I still use them later on
23:49:01 <pjdelport> Saul_: or would you have each insert return the inserted id for future reference?
23:49:22 <pjdelport> Saul_: what's the application of this, btw?
23:49:29 <Saul_> pjdelport: I actually did just make a function that does exactly that
23:49:33 <pjdelport> it sounds a bit odd :)
23:49:57 <Saul_> It's just an in-memory database table-like thing
23:50:11 <Saul_> lispy: Sorry I was looking at Data.Unique
23:50:11 <pjdelport> right, but why these particular constraints
23:50:49 <Saul_> I wanted something akin to auto-incrementing id columns
23:51:20 <Saul_> lispy: But it's still monadic
23:51:47 <Baughn> Oh yes. Horribly off-topic, I know, but can I configure windows to get its routing tables via RIPv2 somehow?
23:52:28 <dmwit_> Yeah, this definitely isn't the place to ask that.
23:52:47 <dmwit_> Raise your hand if you aren't Baughn and you use Windows...
23:53:14 <Baughn> ....
23:53:18 * pjdelport has plenty of windows
23:53:58 * jeffz raises hand
23:54:26 <dmwit_> Baughn: There you have it. One user (two, including you) out of 470. ;-)
23:54:45 <Baughn> You know, for some reason I was *sure* there wouldn't be a #windows. Eh, let me try it there.
23:54:46 <dmwit_> Now intersect with the number of people who know about RIPv7 and routing tables...
23:55:10 <Baughn> v2. ;_;
23:55:36 <dmwit_> ;-)
