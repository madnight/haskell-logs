00:13:42 <Cale> lispy: MonadError e
00:13:56 <Baughn> @tell paczesiowa I do. I'm currently waiting for 10.1 to be released so I have a stable base to hack on.
00:13:56 <lambdabot> Consider it noted.
00:14:08 <Cale> (I'm not sure why it was  MonadError (m a) in the first place, that doesn't make a lot of sense)
00:15:49 <dolio> MonadError (m a) (m a) doesn't make any sense, since the kinds mismatch.
00:17:00 <dolio> MonadError (m a) m might, except that's likely prone to infinite types.
00:17:48 <rwbarton> Cale: but there's no e anywhere in scope
00:18:43 <Cale> rwbarton: The lifting instance applies for any e.
00:18:53 <rwbarton> dolio: Oh yeah, I meant MonadError (m a) m
00:19:51 <dolio> It doesn't work for ErrorT, for instance.
00:19:55 <rwbarton> Wait, how does ghc know what to newtype-derive the class at?  The kind of UniqueT isn't * -> *, the kind of Functors
00:20:14 <dolio> Since you'd need 'ErrorT (ErrorT (ErrorT ...)) a'.
00:20:36 <rwbarton> Does it just throw in free variables to the new type constructor until the kinds match up?
00:20:39 <dolio> You could do it with the bifunctor fixedpoint in category-extras, maybe.
00:24:08 <rwbarton> Cale: Oh, it creates an instance with a MonadError constraint.
00:24:35 <rwbarton> Cale: for some reason, I can never predict when it will create an instance with a constraint and when it will complain about a missing constraint right away.
00:24:46 <dejones_> http://www.reddit.com/r/programming/comments/75nn0/anders_hejlsberg_and_guy_steele_concurrency_and/ -- Many of the things they say regarding programming languages and concurrency are exactly what is available in Haskell.  :)
00:24:48 <lambdabot> Title: Anders Hejlsberg and Guy Steele: Concurrency and Language Design : programming, http://tinyurl.com/426wve
00:25:07 <dolio> It uses the instance for whatever the newtype wraps.
00:25:33 <dolio> So, StateT Integer m has a MonadError instance when m has an instance.
00:34:38 <lucca> > take 10 $ foldr1 (++) $ map (replicate 2) [1..]
00:34:39 <lambdabot>   [1,1,2,2,3,3,4,4,5,5]
00:36:02 <Cale> > [1..] >>= join replicate
00:36:03 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
00:36:18 <Cale> > [1..] >>= replicate 2
00:36:19 <lambdabot>   [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16...
00:36:26 <lucca> whoa :p
00:37:01 <Cale> In the list monad, >>= is concatMap (with parameters the other way around)
00:37:10 <Cale> > concatMap (replicate 2) [1..]
00:37:11 <lambdabot>   [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16...
00:38:05 <lucca> that... seems like it could be very very useful
00:39:26 <mjrosenb> what's the command to have lambdabot turn some code into point free?
00:39:48 <lucca> that would be @pl
00:40:31 <mjrosenb> ah, and does it understand recursive functions at all?
00:41:44 <TEH_REPREGNAT0R> anyone know if there's a better way to shuffle a list than this http://hpaste.org/11003 ?
00:41:56 <TEH_REPREGNAT0R> well, i'm pretty sure there is :P
00:42:15 <lucca> mjrosenb: not sure
00:42:22 <mjrosenb> knuth shuffle?
00:42:45 <TEH_REPREGNAT0R> mjrosenb that's what i was trying to do
00:42:52 <mjrosenb> that appears to be the knuth shuffle
00:43:10 <TEH_REPREGNAT0R> in particular i'm looking for a better way to do the swap
00:43:16 <TEH_REPREGNAT0R> to swap two elements of a list
00:44:55 <mjrosenb> i'd probably do something like zipWith (!!) (mapM (curry randomRIO 0) [1..]) to_be_sorted
00:45:08 <mjrosenb> althtough you might need to make it actually typecheck
00:45:21 <mjrosenb> hrmm
00:45:22 <mjrosenb> no
00:45:25 <mjrosenb> that won't work
00:45:26 <mjrosenb> nm
00:45:46 <mjrosenb> @pl (+)1
00:45:47 <lambdabot> (1 +)
00:45:56 <mjrosenb> @pl (^)4
00:45:56 <lambdabot> (4 ^)
00:46:04 <mjrosenb> @pl (^4)
00:46:04 <lambdabot> (^ 4)
00:46:09 <mjrosenb> :-p
00:46:29 <lucca> @unpl (^ 4)
00:46:29 <lambdabot> (\ a -> a ^ 4)
00:46:39 <mjrosenb> silly lambdabot, i want flip (^) 4
00:46:46 <mjrosenb> anyhow
00:47:45 <mjrosenb> > let fact 0 = 1; fact n = n*fact (n-1) in fact 4
00:47:46 <lambdabot>   24
00:48:00 <mjrosenb> @pl let fact 0 = 1; fact n = n*fact (n-1) in fact
00:48:01 <lambdabot> ap (*) (ap id (subtract 1))
00:48:16 <mjrosenb> oh my : )
00:48:42 <lucca> that won't work
00:49:39 <lucca> @pl (\x -> product [1..x])
00:49:39 <lambdabot> product . enumFromTo 1
00:49:42 <mjrosenb> lucca: what lambdabot said?
00:49:49 <lucca> try that :p
00:49:59 <lucca> > (product . enumFromTo 1) 5
00:50:00 <lambdabot>   120
00:50:17 <mjrosenb> i know how to write it, i was just testing to see if lambdabod could @pl a recursively defined function
00:50:34 <mjrosenb> s/bod/bot/
00:51:05 <rwbarton> @pl let fact n = if n == 0 then 1 else n * fact (n-1) in fact
00:51:06 <lambdabot> fix (ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1))
00:51:49 <lucca> so yes, but ew
00:52:14 <mmorrow> i have this code from yhc to permute a list
00:52:18 <mjrosenb> so i was mainly building up to this
00:52:23 <mmorrow> (it'll take a sec to type)
00:52:26 <mjrosenb> @pl let q n = if n < 2 then 1 else q (n-q(n-1)) + q(n-q(n-2))
00:52:26 <lambdabot> (line 1, column 58):
00:52:27 <lambdabot> unexpected end of input
00:52:27 <lambdabot> expecting variable, "(", operator, "+", "-", ";" or "in"
00:52:34 <mjrosenb> @pl let q n = if n < 2 then 1 else q (n-q(n-1)) + q(n-q(n-2)) in q
00:52:35 <lambdabot> fix (ap (flip if' 1 . (< 2)) . ap (ap . ((+) .) . ap (.) (ap (-) . (. subtract 1))) (ap (.) (ap (-) . (. subtract 2))))
00:53:30 <lucca> I do like how it pulls the recursion out to a leading fix
00:53:35 <mjrosenb> what module gives if'?
00:53:55 <lucca> @hoogle if'
00:53:55 <lambdabot> No results found
00:53:56 <mjrosenb> it didn't in the original version :-p
00:54:23 <glguy> mjrosenb: it isn't part of the standard libraries
00:55:07 <mjrosenb> glguy: oic, guess i'll just have to  strees myself writing it out
00:55:17 <BeelsebobWork> mjrosenb: none
00:55:18 <mjrosenb> if' c a b = if c then a else b
00:55:29 <Cale> Probably Data.Sequence would be a good way to write a reasonably fast function to produce a random permutation, unless you want to go overboard and use an STArray :)
00:55:57 <Cale> Indexing repeatedly into lists is a bad idea though.
00:56:56 <mjrosenb> you could always generate all permutations, then index into that once
00:57:30 <Cale> ehehe
00:57:58 <Cale> Well, as a tree, that wouldn't be too bad. As a list, it would be horrible :)
00:59:24 <Cale> (since laziness could ensure that you never generate bits of the tree you don't use)
01:00:41 * mjrosenb has an idea
01:03:07 <mjrosenb> swapl f a b n = f (if n == a then  b else if n == b then a else n)
01:03:32 <mjrosenb> and use something like swapl (list!!)
01:03:43 <mjrosenb> and use the code that you had before
01:04:27 <Cale> Not me :)
01:04:54 <Cale> (unless it was a long time ago)
01:06:02 <mmorrow> heh, ok just had an epic linker battle
01:06:04 <mmorrow> , let randPerm g xs = (let go _ _ [] = [] ; go g n xs = let  (i,g') = randomR (0,n) g ; (x,y:ys) = splitAt i xs in y : go g' (n-1) (x++ys) in go g (length xs-1) xs) in randPerm (mkStdGen 7238) [0..19]
01:06:06 <lunabot>  [15,12,19,14,2,6,10,18,8,9,3,1,13,11,16,7,17,0,5,4]
01:07:14 <mjrosenb> http://hpaste.org/11004
01:07:21 * mjrosenb thinks it typechecks
01:07:37 <mmorrow> randPerm http://hpaste.org/11003#a1
01:09:48 <mmorrow> , let swap a b n = take 1 . filter id . map (==n) $ [a,b,n] in map (swap 0 1) [0..2]
01:09:50 <nomeata> I wonder why there is no such function around in the standard libs: (\p a -> if p then a else mzero) :: MonadPlus m => Bool -> m a -> m a
01:09:50 <lunabot>  [[True],[True],[True]]
01:09:57 <mmorrow> crap
01:10:01 <mjrosenb> add in a paren, and a map [1..n]
01:10:18 <nomeata> it’s similar to when, or guard, but both these have m () as the return type, so they’ can not always be used.
01:10:39 <mmorrow> , let swap a b n = snd . take 1 . filter id . map ((==n)&&&id) $ [a,b,n] in map (swap 0 1) [0..2]
01:10:41 <lunabot>  luna: Couldn't match expected type `GHC.Bool.Bool'
01:10:41 <lunabot>         against inferred type `(GHC.Bool.Bool, a)'
01:10:57 <mmorrow> , let swap a b n = snd . take 1 . filter fst . map ((==n)&&&id) $ [a,b,n] in map (swap 0 1) [0..2]
01:10:58 <lunabot>  luna: Couldn't match expected type `(a, b)'
01:10:58 <lunabot>         against inferred type `[(GHC.Bool.Bool, a1)]'
01:11:59 <mmorrow> @type \a b n -> snd . take 1 . filter fst . map ((==n)&&&id) $ [a,b,n]
01:12:00 <lambdabot>     Couldn't match expected type `(a, b)'
01:12:00 <lambdabot>            against inferred type `[(Bool, a1)]'
01:12:00 <lambdabot>       Expected type: [a1] -> (a, b)
01:12:04 <retrohscoder> what is an easy way to subtract a value from each element of a list?
01:12:23 <mmorrow> @type \a b n -> map ((==n)&&&id) $ [a,b,n]
01:12:24 <lambdabot> forall a. (Eq a) => a -> a -> a -> [(Bool, a)]
01:12:43 <mmorrow> @type \a b n -> filter fst . map ((==n)&&&id) $ [a,b,n]
01:12:44 <lambdabot> forall a. (Eq a) => a -> a -> a -> [(Bool, a)]
01:12:54 <mmorrow> ohhh
01:13:07 <mmorrow> , let swap a b n = snd . head . filter fst . map ((==n)&&&id) $ [a,b,n] in map (swap 0 1) [0..2]
01:13:09 <lunabot>  [0,1,2]
01:13:47 <mmorrow> @pl \a b n -> snd . head . filter fst . map ((==n)&&&id) $ [a,b,n]
01:13:47 <lambdabot> (ap (((snd . head . filter fst) .) . map . (&&& id) . (==)) .) . (. ((. return) . (:))) . (.) . (:)
01:13:51 <idnar> what's the unicode char for -> ?
01:14:04 <nomeata> →
01:14:23 <mmorrow> , "→"
01:14:25 <lunabot>  "\8594"
01:14:31 <mmorrow> , utf8enc "→"
01:14:33 <lunabot>  "\226\134\146"
01:14:47 <idnar> will GHC accept that?
01:14:51 * mjrosenb has it
01:14:53 <mmorrow> it should
01:15:08 <idnar> is there a list of those somewhere?
01:15:25 <retrohscoder> wikipedia has them
01:15:35 <mmorrow> , toUTF8 (take 10 ['\8594'..])
01:15:35 <idnar> well, I mean, specifically in the context of GHC / Haskell
01:15:37 <lunabot>  →↓↔↕↖↗↘↙↚↛
01:15:55 <retrohscoder> somehow I think that it doesn't matter
01:16:02 <retrohscoder> UTF-8 is UTF-8
01:16:19 <idnar> yes
01:16:28 <idnar> but I don't think ↕ has any meaning in Haskell syntax
01:16:29 <mmorrow> ->   forall  ::  =>    are the syntax that you can substitute unicode for i believe
01:16:55 <mjrosenb> http://hpaste.org/11005
01:16:58 <mjrosenb> therewego
01:17:09 <mmorrow> then, any identifier can be unicode subject to the same rules as chars < \127
01:17:17 <mmorrow> s/</<=/ ;)
01:17:38 <retrohscoder> so uhm...would someone please answer my question please?
01:17:56 <idnar> > map (-5) [1,2,3,4,5]
01:17:57 <lambdabot>       No instance for (Num (a -> b))
01:17:57 <lambdabot>        arising from a use of `negate' at...
01:18:05 <luqui> > map (subtract 5) [1,2,3,4,5]
01:18:07 <lambdabot>   [-4,-3,-2,-1,0]
01:18:14 <retrohscoder> ah
01:18:17 <idnar> doh, that one always trips me up
01:18:20 <retrohscoder> thanks
01:18:35 <retrohscoder> I didn't realize there was a "subtract" function
01:18:49 <idnar> mmorrow: hmm, what's the unicode alternative for :: ?
01:18:49 <luqui> yeah, invented pretty much exactly for this use case
01:18:52 <luqui> (currying one argument)
01:18:58 <mjrosenb> really though, overloading - is JUST EVIL
01:19:01 <mmorrow> , let (↕) = (+) in 3 ↕ 4
01:19:03 <lunabot>  7
01:19:15 <mmorrow> idnar: hmm, i have to check
01:20:08 <mmorrow> , "∷"
01:20:09 <lunabot>  "\8759"
01:20:12 <mmorrow> , utf8enc "∷"
01:20:14 <lunabot>  "\226\136\183"
01:20:43 <mjrosenb> luqui: you should check out the haskell.el stuff
01:20:51 <ski> (overloading `-' for both a prefix and an infix operator may be evil .. just overloading `-' between different instances of `Num' is probably ok)
01:20:53 <mjrosenb> they have more or less everything that you could want
01:21:12 <mjrosenb> ski: i was talking about infix and prefix
01:21:24 <luqui> mjrosenb, hmm?
01:21:51 <mjrosenb> luqui: install emacs, then haskell-mode
01:21:55 <idnar> > 5 ∷ Int
01:21:57 <lambdabot>   5
01:21:58 <luqui> what would I want in it?
01:22:10 <ski> mjrosenb : i figured you probably was .. just clarification
01:22:25 <mjrosenb> luqui: because i meant to say that ta idnar
01:22:32 <mjrosenb> luqui: and i fail at tab completion
01:22:33 <luqui> mjrosenb, =P
01:23:09 <mmorrow> , "⟪⧎⟫"
01:23:10 <lunabot>  "\10218\10702\10219"
01:23:14 <luqui> digraphs in vim are pretty easy too.
01:23:16 <mmorrow> , utf8enc "⟪⧎⟫"
01:23:18 <mjrosenb> idnar: if you look at the haskell.el file, it has just about all of the useful unicode that you could want
01:23:18 <lunabot>  "\226\159\170\226\167\142\226\159\171"
01:23:22 <luqui> i mean, as long as they exist.
01:23:31 <mmorrow> , fmap (utf8enc . (:[])) "⟪⧎⟫"
01:23:33 <lunabot>  ["\226\159\170","\226\167\142","\226\159\171"]
01:23:43 <idnar> mjrosenb: okay, thanks
01:39:53 <mmorrow> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.110.5892&rep=rep1&type=pdf
01:39:56 <lambdabot> Title: cache:http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.110.5892&rep=rep1 ..., http://tinyurl.com/3sxo77
01:40:09 <mmorrow>    Definitional Interpreters for Higher-Order Programming Languages (1998) [225 citations — 2 self]
01:41:34 <mjrosenb> ermmm
01:41:47 <mjrosenb> how does lambdabot handle that
01:42:10 <mjrosenb> does it look at the MIME and just print out the url
01:42:21 <mjrosenb> or does it actually attempt to download it?
01:44:53 <sjanssen> mjrosenb: it downloads the first bit of it, and searches for a title tag
01:46:13 <sjanssen> mjrosenb: actually, that is a good question
01:46:19 <mmorrow> haha. trying to use wget for a pdf from citeseer
01:46:21 <mmorrow> HTTP request sent, awaiting response... 500 Request processing failed; nested exception is java.lang.NullPointerException
01:46:21 <mmorrow> 04:45:31 ERROR 500: Request processing failed; nested exception is java.lang.NullPointerException.
01:47:11 <sjanssen> fail
01:47:12 <mmorrow> sweet! a java segfault
01:48:08 * sjanssen wonders when he'll see ERROR 500: *** Exception: Prelude.head: empty list in the wild
01:49:22 <sjanssen> or even better "<<loop>>"
01:52:29 <besiria> wow, today i learned that records can have updates
01:52:56 <mjrosenb> besiria: yeah, that's one thing that's severly missing from sml
01:55:39 <mmorrow> lol
01:55:40 <mmorrow> Keywords: “Explaining to programmers the logical structure of programming languages is like a cat explaining to a fish what it feels like to be wet”—Gorn.
01:55:45 <mmorrow> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.85.2610
01:55:46 <lambdabot> Title: A generalization of jumps and labels - CiteSeerX
02:02:13 <mmorrow> http://www-formal.stanford.edu/jmc/recursive.html
02:02:13 <hugo__> hello
02:02:15 <hugo__> good morning :)
02:02:40 <mmorrow> mornin'
02:07:02 <scook0> @src group
02:07:03 <lambdabot> group = groupBy (==)
02:07:07 <scook0> @src groupBy
02:07:07 <lambdabot> groupBy _  []       =  []
02:07:07 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
02:07:07 <lambdabot>     where (ys,zs) = span (eq x) xs
02:16:33 --- mode: irc.freenode.net set +o ChanServ
02:29:58 <TSC> @type (<<)
02:29:59 <lambdabot> Not in scope: `<<'
02:30:10 <TSC> @type (=<<)
02:30:11 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
03:09:13 <mmorrow> <sjanssen> or even better "<<loop>>"
03:09:17 <mmorrow> hehe
03:10:15 <opqdonut> :D
03:17:55 <kowey> dcoutts: re constraint solving... there is somebody trying to develop a Haskell binding to Gecode... is that relevant?
03:32:10 <nomeata> Hi. Does anyone have experience with Test.BenchPress and Microbench, and can say which one is better in his opinion?
03:53:13 <mmorrow> how did monad comprehensions for arbitrary monads work exactly? (in particular if there's a predicate)
03:54:21 <TSC> @type guard
03:54:22 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
03:54:40 <TSC> Maybe it needs MonadPlus?
03:54:41 <mmorrow> ah. so the monad had to be MonadPlus?
03:54:47 <TSC> Don't ask me (:
03:54:58 <mmorrow> TSC:  heh :)
03:55:03 <idnar> @src guard
03:55:04 <lambdabot> guard True  =  return ()
03:55:04 <lambdabot> guard False =  mzero
03:55:12 <mmorrow> > fail "asdf" :: []
03:55:13 <lambdabot>       `[]' is not applied to enough type arguments
03:55:13 <lambdabot>      Expected kind `?', bu...
03:55:26 <mmorrow> > fail "asdf" :: forall a. [a]
03:55:27 <lambdabot>   []
03:55:40 <rog_> is there a common name for the function (\f x -> return (f x)) ?
03:55:50 <DuClare> Is there any set date for the arrival of the next standard?
03:55:57 <Heffalump> rog_: (return .)
03:56:02 <idnar> probably s/mzero/fail/
03:56:10 <BONUS> @pl \f x ->return (f x)
03:56:10 <lambdabot> (return .)
03:56:11 <mmorrow> i guess the equiv of concatMap and fail
03:56:13 <BONUS> ah yeah
03:56:24 <mmorrow> so, (=<<) and fail
03:56:25 <Heffalump> DuClare: no, but I think it'll be within the next year
03:56:38 <Cale> fail is evil
03:56:45 <rog_> Heffalump: ah of course, ta.
03:56:46 <Cale> Monad comprehensions used mzero
03:56:54 <Cale> Which was in the MonadZero class.
03:57:08 <Cale> (but is now in MonadPlus)
03:57:28 <mmorrow> , [| [ x | x<-[0,1] , and [True] ] |]
03:57:29 <Cale> Removing MonadZero was one of the larger mistakes that Haskell 98 made.
03:57:43 <lunabot>  CompE [BindS (VarP x_0) (ListE [LitE (IntegerL 0),LitE (IntegerL 1)]),NoB...
03:58:05 <mmorrow> Cale: i'm gonna make a quasiquoter to reenable comprehensions for arbitrary monads :)
03:58:23 <rog_> Heffalump: i hadn't seen the "(f .)" idiom before. nice.
03:58:31 <Cale> mmorrow: :)
03:58:43 <mmorrow> , src 'CompE
03:58:54 <lunabot>  data Exp = ... | CompE ([Stmt]) | ...
03:58:54 <lunabot>  infixl 9
03:58:54 <Heffalump> rog_: I'm not sure I particularly like it
03:58:57 <BONUS> i'd still use \f x -> g (f x) instead of (g .)
03:59:04 <BONUS> way more readable
03:59:05 <mmorrow> , src ''Stmt
03:59:10 <lunabot>  data Stmt = BindS Pat Exp
03:59:10 <lunabot>            | LetS ([Dec])
03:59:10 <lunabot>            | NoBindS Exp
03:59:29 <Cale> I really wish that someone who had the necessary experience with GHC to understand how to add monad comprehensions back would do it. SPJ said he'd accept a patch if someone went to the trouble.
04:00:42 <mmorrow> Cale: hmm. i'm looking around ghc lately, i'll see if i can figure it out.
04:01:12 <rog_> Heffalump: i can see why. but i guess if it's commonly used, it becomes obvious. i was really looking for a kind of "half liftM" that only lifts the return type - i'd called it "liftR" but wondered if there was a usual name for that operation.
04:01:38 * mmorrow is reading a paper with gopher code at the moment
04:01:43 <Heffalump> return f `ap` return x
04:01:50 <Heffalump> @type return f `ap` return x
04:01:51 <lambdabot> forall b (m :: * -> *). (Monad m, SimpleReflect.FromExpr b) => m b
04:01:58 <Heffalump> @type \f x -> return f `ap` return x
04:01:59 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b) -> a -> m b
04:02:28 <mmorrow> http://people.cs.uu.nl/jeroen/article/jpeg/
04:02:34 <lambdabot> Title: Functional Specification of the JPEG algorithm
04:02:50 <mmorrow> http://people.cs.uu.nl/jeroen/article/jpeg/jpeg.gs
04:03:25 <pjdelport> :t (return.)
04:03:26 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> b) -> a -> m b
04:03:38 <rog_> :src ap
04:03:55 <rog_> @src ap
04:03:56 <lambdabot> ap = liftM2 id
04:03:56 <mmorrow> the code of the `many' function in there was the last straw. monad comprehensions FTW!!
04:03:59 <pjdelport> @pl \f x -> return f `ap` return x
04:04:00 <lambdabot> (return .)
04:04:09 <Heffalump> I expressed it that way because `ap` is a common idiom for replacing the various liftM functions now
04:04:27 <quicksilver> pure f <*> pure x
04:04:36 <quicksilver> but personally I prefer return. I think
04:04:56 <Heffalump> until Applicative => Monad you can't really use pure and <*>, can you?
04:05:32 <Heffalump> @type (pure, <*>)
04:05:33 <lambdabot> parse error on input `)'
04:05:39 <quicksilver> I write Applicative instances for any Monad which lacks them
04:05:43 <Heffalump> @type (pure, (<*>))
04:05:43 <quicksilver> (if and when I use them)
04:05:44 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *) a1 b. (Applicative f1, Applicative f) => (a -> f a, f1 (a1 -> b) -> f1 a1 -> f1 b)
04:05:49 <quicksilver> (being a lazy programmer)
04:09:49 <rog_> quicksilver: ... but that doesn't appear to be so easy if it's actually a monad class we've got (unless you enable overlapping instances, i guess)
04:10:13 <mmorrow> quicksilver: i was talking to luqui earlier about some reactive misc, which along with your reactive code, gave me some ideas to do http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=94#a94
04:10:25 <rog_> quicksilver: ... or pass the applicative constraint all the way through, which is a hassle
04:10:48 <mmorrow> GADTs + forkIOs
04:11:01 <mmorrow> to eval "Proc"s
04:12:08 <quicksilver> mmorrow: that's an interesting set of primitives.
04:12:22 <quicksilver> mmorrow: it probably has the same non-determinism problems that luqui and I have discussed.
04:12:56 <mmorrow> quicksilver: interesting, what exactly are the problems.
04:13:01 <mmorrow> s/the/these/
04:13:10 <quicksilver> the GHC scheduler makes no guarantees
04:13:20 <quicksilver> the MVar which clears first may not be scheduled to run until after another one
04:13:24 <quicksilver> which clears slightly later
04:13:28 <quicksilver> similarly chans, etc.
04:13:47 <mmorrow> oh. hmm, that sucks
04:13:58 <quicksilver> I don't want to sound negative, though. That's a nice algebra you have there :)
04:14:05 <quicksilver> and I haven't tried anything like that.
04:14:16 <quicksilver> I'm just saying it has the same low-level issues as the things we've been working on.
04:14:16 <mmorrow> is there any way anyone's thought of to get around that?
04:14:27 <quicksilver> 2-phase commit
04:14:33 <quicksilver> basically, a variation thereof
04:14:37 <quicksilver> grab the time first
04:14:42 <quicksilver> have some kind of locking around that
04:14:45 <quicksilver> it's a bit fiddly.
04:14:46 <rog_> what's the problem with non-determinism? isn't it a useful part of parallelism?
04:14:57 <quicksilver> rog_: it's useful when you want it.
04:15:00 <quicksilver> it's annoying when you don't.
04:15:01 <quicksilver> :)
04:15:44 <mmorrow> ah, ok. i've looked at your code enough to see you're using times, but need to go through that in detail. i take it that's what you're doing there?
04:16:03 * mmorrow looks
04:17:19 <quicksilver> mmorrow: well there is a question of what determinism means.
04:17:31 <quicksilver> if two events could reasonably be said to arrive non-deterministically
04:17:39 <quicksilver> then their times may not be particularly well defined
04:17:49 <quicksilver> however, if you do find some way of measuring their times
04:17:54 <quicksilver> (like getCurrentTime at arrival)
04:18:01 <quicksilver> then what you really want is *consistency*
04:18:05 <mmorrow> yeah, i was just about to ask something along those lines
04:18:21 <quicksilver> that the one you measure as having the earliest time, really arrives first at your consumer code.
04:18:32 <rog_> i've been looking for a nice CSP-style interface in haskell. i came across CHP, but the interface seems huge. i'd like to find something with about 5 basic primitives (newchan, send, recv, alt, spawn)...
04:18:33 <quicksilver> and of course that it is consistent if you have more than one consumer
04:18:45 <quicksilver> (that latter point being more important)
04:18:52 <quicksilver> mmorrow: but some events do have deterministic time.
04:19:04 <quicksilver> mmorrow: like the ticker event which, by definition, occurs precisely every second.
04:19:05 <mmorrow> why does whether something got to the MVar first, but isn't picked up over a later arrival not just treated like that later arrival got there first?
04:19:20 <quicksilver> and you need those to guaranteed corectly interleave with the non-deterministic ones.
04:19:35 <quicksilver> mmorrow: basically there is a critical window between time measurement and MVar delivery
04:19:39 <quicksilver> (in this formulation)
04:19:48 <dmwit_> rog_: I'm not sure I understood all those acronyms, but have you seen Control.Concurrent.Chan?
04:19:49 <quicksilver> but in most other formulations there is a critical window somewhere
04:20:07 <quicksilver> especially when you consider consistent reading by multiple consumers.
04:20:15 <mmorrow> hmm
04:20:17 <quicksilver> rog_: "nice" "CSP-style" ?
04:20:24 <quicksilver> rog_: that sounds like a contradiction?
04:20:32 <quicksilver> CSP is interesting as a tool for modelling and discussion
04:20:37 <rog_> dmwit_: CHP == Communicating Haskell Processes, CSP == (tony hoare's) Communicating Sequential Processes
04:20:40 <quicksilver> it's absolutely horrible as a programming language.
04:20:49 <rog_> quicksilver: i've had the opposite experience
04:21:15 <rog_> quicksilver: i've found it really pleasant to use (admittedly in an imperative language)
04:21:30 <rog_> quicksilver: ... and one in which it was a fundamental primitive
04:22:20 <rog_> quicksilver: particularly when dealing with naturally concurrent things (such as user interaction, external IO, etc)
04:23:31 <nomeata> Is there a module that produces ASCII tables from [[String]]?
04:23:51 <rog_> quicksilver: why do you find it so horrible?
04:24:04 <dmwit_> nomeata: I don't think so.  You could try one of the pretty-printers.
04:24:23 <nomeata> thx
04:24:50 <rog_> quicksilver: i am talking about CSP with first-class channels, not the original, limited form, if that makes a difference
04:27:20 <rog_> dmwit_: i hadn't seen Control.Concurrent.Chan, but i'm really looking for something with (potentially) synchronous channels `and a join (alt) operator
04:27:45 <rog_> dmwit_: ... neither of which seem to be provided be Control.Concurrent.Chan
04:28:04 <dmwit_> You can join on an MVar.
04:28:42 <Saizan> rog_: by join/alt you mean waiting on multiple channels at the same time?
04:28:51 <rog_> Saizan: yes.
04:29:21 <Saizan> rog_: you can do that with STM, see orElse and retry
04:30:19 <Saizan> using TChan
04:31:51 <rog_> Saizan: but TChan represents an unbounded channel. is there a similar type for a synchronous channel?
04:32:31 <rog_> Saizan: (which is easier to reason about, i find)
04:36:26 <rog_> oh well
04:38:34 <quicksilver> I don't think there is anythign for synchronous channels
04:38:43 <quicksilver> although I forget the exact semantics of a synchronous channel
04:38:44 <Saizan> rog_: you want the sender to block until the receiver gets the message?
04:38:49 <quicksilver> it's probably a good question to be asking.
04:39:54 <dmwit_> I bet you could build synchronous channels out of Chan and MVar without too much trouble.
04:39:57 <Saizan> i guess you can still write it in STM
04:40:04 <rog_> Saizan: yes
04:40:26 <rog_> Saizan: it's the original CSP semantic, and is sufficient to build anything else
04:40:42 <saintiss> hi all
04:40:46 <rog_> Saizan: it can also be quite efficient
04:40:55 <saintiss> could someone point me to *the* reference paper on lazy evaluation?
04:41:16 * dmwit_ blinks
04:41:22 <dmwit_> *The* reference paper?
04:41:27 <rog_> dmwit_: yeah, i was hoping to avoid building yet another library...
04:41:46 <Saizan> rog_: yeah, i see that, so you want to build it around a simple TVar, probably a couple of them so the sender can block until the receiver signals that it has gotten the message
04:41:53 <saintiss> dmwit_, yes, like the standard work that would be referenced in a scientific paper
04:42:20 <dmwit_> hmmm
04:42:22 <rog_> Saizan: something like that, yes.
04:43:05 <dmwit_> saintiss: Which aspect of it?  The memory characteristics, the rules of the evaluation order, ...?
04:43:05 <rog_> Saizan: it becomes a bit more awkward when it comes to alt though.
04:43:16 * dmwit_ is trying to think of which papers cover it well
04:43:20 <Saizan> rog_: alt should be easy with orElse
04:43:34 <saintiss> dmwit_, introduction of the concept
04:43:55 <saintiss> dmwit_, if there's no such general work, then any aspect, but the older the better :)
04:43:59 <dmwit_> saintiss: So, semantics, then.
04:44:12 <rog_> Saizan: esp. getting the right semantics with multiple alts on the same channel (which is useful to be able to do)
04:44:26 <saintiss> dmwit_, if it was originally introduced at a semantic level, yes
04:44:36 <dmwit_> saintiss: If you really need a reference, I'm not sure what to give you.  But the Haskell wiki has several good pages on it if you're just looking to learn what it means.
04:44:52 <saintiss> dmwit_, apparently this might be a reference:
04:44:52 <Saizan> http://research.microsoft.com/~simonpj/papers/slpj-book-1987/index.htm ?
04:44:54 <lambdabot> Title: The Implementation of Functional Programming Languages, http://tinyurl.com/fvgtw
04:45:02 <saintiss> henderson/morris, 1976, "a lazy evaluator"
04:45:49 <dmwit_> saintiss: http://haskell.org/haskellwiki/Lazy_vs._non-strict
04:45:50 <lambdabot> Title: Lazy vs. non-strict - HaskellWiki
04:45:53 <dmwit_> One good article.
04:45:58 <dmwit_> I like this paper:
04:46:19 <dmwit_> http://portal.acm.org/citation.cfm?id=158511.158618
04:46:23 <lambdabot> Title: A natural semantics for lazy evaluation
04:46:40 <dmwit_> (But that's more about the memory usage aspect of lazy evaluation than anything else.)
04:46:44 <Saizan> rog_: it think it's still a matter of readChan c1 `orElse` readChan c2 `orElse` ...
04:46:53 <Saizan> rog_: if you want to add guards that's easy too
04:47:24 <saintiss> dmwit_, ok thx
04:48:50 <rog_> Saizan: but reading a chan is not just a matter of just getting the value, it's also a matter of waking up the right sender, and making sure the pair of mvars is in a consistent state while something else tries to dive in there. not too hard, i think, but not trivial either.
04:49:34 <Saizan> rog_: with TVar's that's almost trivial
04:50:10 <rog_> Saizan: i'm sure you're right. i'll have a go.
04:50:31 <Saizan> rog_: you should read somehting on the semantic of STM first
04:51:01 <rog_> Saizan: recommended reference?
04:51:27 <Saizan> http://www.haskell.org/haskellwiki/STM
04:51:28 <lambdabot> Title: Software transactional memory - HaskellWiki
04:51:43 <Saizan> http://www.haskell.org/~simonmar/papers/stm.pdf
04:51:45 <lambdabot> Title: Composable Memory Transactions
04:52:22 <rog_> Saizan: ta
04:53:13 <mmorrow> quicksilver: dynamic two-phase commit looks interesting
04:53:29 <mmorrow> i like the idea of no central control
05:01:52 <mmorrow> or no /pre/-determined central control i guess that is
05:02:11 <quicksilver> Saizan: but then again STM can't be interleaved with other IO stuff.
05:02:14 <quicksilver> well, not easily.
05:02:29 <quicksilver> I suppose I should think a bit more carefully about the side condition for unsafeIOtoSTM
05:03:30 <Saizan> i guess you can (join $ atomically (<read from one of the chans>) )
05:08:36 <mmorrow> or just create a new chan and fork an additional thread for each chan, all of which read from their chan and write to the new chan
05:08:37 <mmorrow> ?
05:09:06 <mmorrow> (and the fork one more thread as the root which reads from this top-level chan)
05:10:10 <mmorrow> that may be trying to solve a different problem completely though that you had in mind. that seemed to make sense for Proc though
05:10:18 <mmorrow> s/that/than/
05:11:02 <Saizan> i guess you can do it that way, modulo the problem with channels of multiple types
05:11:05 <quicksilver> mmorrow: I spent some time trying to work up a sensible question to ask JaffaCake about injecting some determinism into GHC's scheduler.
05:11:24 <quicksilver> Saizan: mmorrow had a pretty attractive answer to the type problem actually
05:11:40 <quicksilver> mmorrow: but I kept asking myself "am I doing this wrong? If I don't want determinism, maybe I shouldn't use these primitives"
05:11:45 <quicksilver> mmorrow: +non-
05:11:54 <mmorrow> Saizan: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=94#a94
05:12:25 <mmorrow> (here a darcs repo also http://moonpatio.com/code/repos/proc/)
05:12:26 <lambdabot> Title: Index of /code/repos/proc
05:13:41 <mmorrow> quicksilver: heh, i didn't see you +non- for a second there and was spinning in a loop
05:14:49 <mmorrow> quicksilver: i was just reading the newest reactive paper and understand somewhat more the motivation
05:14:55 * quicksilver nods
05:15:18 <quicksilver> my personaly motivation (for my version) was to expose this 'spooky' blocking behaviour as an IO flag.
05:15:31 <quicksilver> I explicitly don't like the way conal hides blocking inside pure values
05:15:41 <quicksilver> even though you can kind of make arguments that a blocking value is pure
05:15:49 <quicksilver> to me, I want to be able to see where the blocking is.
05:15:53 <quicksilver> and that's what the IO type does.
05:18:21 <cjs> Can someone help explain these errors to me? http://hpaste.org/11007
05:18:40 <mmorrow> quicksilver: hmm. i'm not sure which i'd prefer, i guess it would depend on the context. using unsafePerformIO in (on account of lazy eval) this situation seems to actually fit the "pull semantics"
05:19:18 <Saizan> mmorrow, quicksilver: can you make explicit what's the answer to the type problem if it's present in Proc? not forking just the reading but the consumer too?
05:19:52 <cjs> I can't figure out why 'seenDate `mappend` ...' would demand an instance of Monoid for UTCTime when seenDate's type is Maybe UTCTime.
05:20:06 <cjs> Shouldn't mappend's Maybe a -> Maybe a type apply here?
05:20:12 <mmorrow> Saizan: err, i didn't have an explicit solution in mind. so the situation is..
05:20:59 <Saizan> cjs: the current instance for Maybe a uses Monoid a, you want the newtype First or Last, iirc
05:20:59 <mmorrow> err, can you restate the situation?
05:21:32 <cjs> Oops, I meant Monoid a -> Monoid a...
05:22:01 <Saizan> cjs: Monoid a -> Monoid a doesn't make much sense :)
05:22:21 <cjs> Ha, I knew I was confused!
05:22:42 <cjs> > Just "foo" `mappend` Just "bar"
05:22:43 <lambdabot>   Just "foobar"
05:22:47 <cjs> Oops.
05:23:03 <cjs> I'm using completely the wrong function here, I think....
05:23:33 <Saizan> > First (Just "foo") `mappend` (First (Just "bar"))
05:23:35 <lambdabot>   First {getFirst = Just "foo"}
05:23:57 <Saizan> > Just "foo" `mplus` Just "bar" -- i'd use this
05:23:58 <lambdabot>   Just "foo"
05:24:03 <cjs> There was a way to do that with maybes without having to put "First" around them, I thought....
05:24:06 <cjs> Right, mplus. Doh.
05:24:34 <cjs> It was m-something-or-other. Anyway, thanks.
05:27:04 <Saizan> mmorrow: you just proposed to fork a thread for each Chan and make those write on a single Chan where the "main" thread reads, like in your runPar i guess, but what if instead of [Chan a] i've (Chan A,Chan B, ...) ? i.e. channels with multiple types, the easy solution is to use an union type, but also quite ugly
05:27:15 <mmorrow> Saizan: \p q r s -> (((p:***q):***r):***s)
05:27:31 <vixey> Chan (Either a (Either b ...)) ?
05:27:34 <vixey> is it not acceptable
05:28:12 <Saizan> mmorrow: that's completely different semantic, no?
05:29:44 <Saizan> vixey: still quite ugly but workable :)
05:29:54 <mmorrow> yeah it think it is ;) i could change it to have those semantics though i believe
05:31:40 <Saizan> you'd have to change the type :) i guess it's more like (chanA >>= consumeA :||| chanB >>= consumeB :||| ...)
05:31:57 <mmorrow> Saizan: oh, that;s another Constructor then
05:32:04 <mmorrow> (:>>>) :: Proc a b -> Proc b c -> Proc a c
05:32:25 <mmorrow> the GADT is the crucial part which makes this all work
05:32:47 <Saizan> you mean i should have used :>>> instead of >>=?
05:33:06 <mmorrow> it lets you type the data by what it will /eventually eval to/ rather than /what it currently is/
05:33:12 <vixey> Is this a thrist I see before me -_-
05:33:36 <Saizan> mmorrow: yeah, i get what Proc is doing
05:33:38 <mmorrow> vixey: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=94
05:35:54 <Saizan> i think you're not getting the problem :) which is waiting on multiple channels with different types and reacting only on the first message you get
05:36:56 <vixey> eek
05:37:07 <vixey> that sounds like a tricky thing to do
05:37:32 <Saizan> it's quite easy with STM
05:37:55 <Axman6> @hoogle [[a]] -> (Int, Int) -> a
05:37:55 <lambdabot> No results found
05:38:11 <cjs> Yeah, I've several times wanted what amounts to select().
05:38:12 <Axman6> @hoogle [[a]] -> (b, b) -> a
05:38:13 <lambdabot> No results found
05:38:37 <mmorrow> Saizan: ok. so a solution would be either (a) use Proc's constructors to build a proc and call runProc once (if the behaviour you want is already possible given what's there), or (b) you get you (Proc a x, Proc b y, Proc c z) as input, then call runProc on each, then newChan and use the returned Run handles to fork each into sep threads that all write to said chan, then fork the root which you create there. then finally runProc the
05:38:37 <mmorrow> root
05:38:42 <Axman6> there isn't already a function defined: xs !!! (a,b) = xs!!a!!b is there?
05:39:00 <tromp__> nope
05:39:05 <Axman6> ok
05:39:27 <Axman6> @let xs !!! (a,b) = xs!!a!!b
05:39:28 <lambdabot>  Defined.
05:39:34 <Axman6> :t (!!!)
05:39:35 <lambdabot> forall a. [[a]] -> (Int, Int) -> a
05:39:37 <vixey> you could maybe have a type like
05:39:47 <vixey> (Channel a, Callback a ())
05:39:49 <mmorrow> modulo MVar scheduling weirdness, i think that'd be equiv to runProc (List ps)
05:40:05 <mmorrow> oh crap, the Chan type
05:41:05 <Saizan> vixey: yeah, more like exist a. (Chan a, CallBack a ())
05:41:06 <mmorrow> well, since the input types are statically known, just put them to Dynamic for a second
05:41:29 <mmorrow> or tag with ints and unsafeCoerce
05:41:44 <vixey> hmmmf
05:42:54 <mmorrow> (since Dynamic does that anyways)
05:43:01 <mjrosenb> shot in the dark
05:43:14 <mjrosenb> has anyone here cross compiled ghc before?
05:45:22 <Saizan> mmorrow: i think using STM is way simpler: join $ atomically $ (consumeA <$> readTChan cA  `orElse` consumeB <$> readTChan cB  `orElse` ...)
05:47:56 <cjs> You know, Monads, Monoids, etc. etc. have so many instances that the cognitive load of using these things is quite high.
05:48:17 <mmorrow> Saizan: oh for sure simpler :)
05:48:24 <mmorrow> but not as much fun
05:48:28 <mmorrow>     My brain just exploded.
05:48:28 <mmorrow>     I can't handle pattern bindings for existentially-quantified constructors.
05:48:30 <mmorrow> heh
05:49:51 <vixey_> http://www-fp.cs.st-and.ac.uk/~eb/darcs/Idris/samples/concurrent.idr
05:50:28 <Saizan> cjs: [un]fortunately there are a lot of ways to be a monoid for some types, for Monad is simpler in general
05:59:30 <mjrosenb> vixey_: what is that?
06:00:06 <vixey_> don't know what you mean really
06:01:45 <mjrosenb> vixey_: you posted a link to something
06:01:57 <vixey> lol
06:23:40 <CosmicRay> @seen twb
06:23:40 <lambdabot> I saw twb leaving #haskell and #darcs 7h 19m 31s ago, and .
06:23:45 <CosmicRay> anyone know who twb is
06:24:24 <CosmicRay> hrm, does lambdabot not respond to /msg?
06:24:38 <Zao> CosmicRay: It does.
06:24:48 <CosmicRay> i tried /msg lambdabot help and got no response
06:25:44 <rog_> @src foldM
06:25:44 <lambdabot> foldM _ a []     = return a
06:25:44 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
06:27:09 <mjrosenb> foldM in the list monad sounds ... interesting
06:27:40 <vixey> good for writing a hamelton pathfinder
06:28:47 <Twey> foldM f a (x:xs) = f a x >>= flip (foldM f) xs
06:28:48 <Twey> >.>
06:28:49 <mjrosenb> yay exponential searches?
06:31:31 <rog_> if i want a function like foldM but with type ((a -> b -> m a) -> a -> [m b] -> m a) instead, i think that using (foldM f a (sequence bs)) will use space proportional to (length bs). is that right?
06:33:17 <rog_> i'm half way through writing a function that does this (avoiding sequence), but thought i should check my assumptions...
06:35:15 <rog_> of course, i realise it can't quite work like that. i'd need to put the sequence on a previous line in a do statement. but i think in that context, sequence is strict, right?
06:35:42 <rog_> i'm probably, in my usual newbie way, horribly misconceived here.
06:36:08 <Taejo> is cabal-install packaged for Ubuntu?
06:36:20 <mjrosenb> rog_: well you never need to use 'do'
06:37:38 <rog_> mjrosenb: well, ok (sequence bs >>= \bs' -> (foldM f a bs') then...
06:38:05 <rog_> mjrosenb: ahem. sequence >>= foldM f a
06:38:41 <mjrosenb> and you can eta-reduce that
06:38:56 <rog_> mjrosenb: anyway, i'm still wondering about the answer. if the original [m b] is a list 1e9 elements long, will i run out of space?
06:39:13 <rog_> eta-reduce?
06:39:15 <mjrosenb> err, yeah, didn't see the second one you posted
06:39:30 <mjrosenb> \ x -> f x is equivalent to f
06:39:37 <rog_> ok
06:39:57 <bd_> rog_: probably best to use sequence_ if you don't need the result
06:40:02 <bd_> @hoogle sequence_
06:40:03 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
06:40:03 <lambdabot> Control.Monad sequence_ :: Monad m => [m a] -> m ()
06:40:03 <lambdabot> Data.Foldable sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
06:40:24 <rog_> bd_: but i do need the result - it's the result that i'm wishing to fold over.
06:40:32 <bd_> oh
06:40:41 <bd_> rog_: you'd end up building the entire list in memory
06:40:49 <rog_> bd_: that's what i thought.
06:41:06 <rog_> bd_: so i can't use foldM... is the conclusion that i'd come to.
06:41:25 <rog_> bd_: but maybe there's another off-the-shelf solution
06:41:35 <bd_> rog_: well, depending on your situation, you might be able to use unsafeInterleaveIO
06:41:37 <mjrosenb> need foldM' :-p
06:41:44 <bd_> but it all depends on how you're using the result
06:41:50 <rog_> rog_: the monad isn't IO...
06:41:54 <bd_> oh
06:42:22 <mmorrow> Saizan: ok, i added that: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=94#a95
06:43:14 <bd_> rog_: in that case, the strictness of the result might well depend on what the monad is... but generally with monads you'd need to explicitly interleave the consumer with the producer ...
06:44:23 <rog_> bd_ the producer isn't in the monad (note [m b] not m [b]) so i don't think i need to do that.
06:44:51 <bd_> rog_: but you want to sequence each of those
06:45:11 <bd_> when you say sequence, you're telling Haskell to run all of these, and gather the answers, /before/ anything else in the monad
06:45:13 <bd_> so it can't be lazy
06:45:41 <bd_> if the m b has stateful effects in the monad, it makes a difference
06:46:29 <rog_> bd_: but i'm folding, so i can gather the elements in the sequence one at a time, and fold as i do it.
06:46:55 <bd_> ahh
06:47:20 <rog_> this is what i ended up doing: http://hpaste.org/11008#a0
06:47:21 <Saizan> rog_: that's what bd_ meant whan he said "explicitly interleave the consumer with the producer"
06:47:34 <Saizan> *when
06:47:50 <rog_> ok\
06:48:14 <bd_> @type \f b l -> foldM (\a m -> liftM (f a) m) b l
06:48:15 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a -> a1 -> a) -> a -> [m a1] -> m a
06:48:39 <bd_> @type \f b l -> foldM (liftM . f) b l
06:48:40 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (r -> a1 -> r) -> r -> [m a1] -> m r
06:48:45 <bd_> @type \f -> foldM (liftM . f)
06:48:45 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (r -> a1 -> r) -> r -> [m a1] -> m r
06:48:59 <bd_> @type foldM . (liftM .)
06:49:00 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (r -> a1 -> r) -> r -> [m a1] -> m r
06:49:04 <bd_> there you go :)
06:49:19 <Saizan> i'd add a seq though
06:49:48 <rog_> bd_: all of those seem to assume that f is pure, which in my case it isn't
06:49:51 <bd_> @type foldM . (liftM . ($!) .)
06:49:52 <lambdabot>     The operator `.' [infixr 9] of a section
06:49:52 <lambdabot>         must have lower precedence than the operand `(.)' [infixr 9]
06:49:52 <lambdabot>         in the section: `(liftM . ($!) .)'
06:49:59 <bd_> @type foldM . (liftM . (($!) .))
06:50:00 <lambdabot> forall b a a1. (a1 -> a -> b -> a1) -> (b -> a1) -> [b] -> a -> b -> a1
06:50:04 <bd_> hmm
06:50:05 <bd_> meh
06:50:06 <rog_> Saizan: good point.
06:50:26 <bd_> rog_: oh, hm
06:50:34 <Saizan> ?type \f -> foldM (\a m -> m >>= f a)
06:50:35 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> a1 -> m a) -> a -> [m a1] -> m a
06:51:24 <Saizan> ?type \f -> foldM (\a m -> m >>= f a >>= \x -> x `seq` return x)
06:51:25 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> a -> m a1) -> a1 -> [m a] -> m a1
06:52:09 <rog_> Saizan: like this? http://hpaste.org/11008#a1
06:53:57 <Saizan> rog_: yeah, but now that i think of it the seq is not really necessary for foldM as it is for foldl, since you still have the monad to force evaluation inside f, if you need it
06:54:05 <mmorrow> , src 'rnf
06:54:16 <lunabot>  Class op from NFData: rnf :: forall a . NFData a => Strategy a
06:54:55 <mmorrow> , let xs = [0..] in rnf xs `seq` xs
06:54:58 <lunabot>  luna: out of memory (requested 1048576 bytes)
06:55:32 <rog_> Saizan: isn't that true only if you want the monad to be always strict?
06:56:18 <mmorrow> , let x = (let f (x:xs) = 1 + x + f xs in f [0..100000]) in x
06:56:20 <lunabot>  luna: <interactive>:1:63-85: Non-exhaustive patterns in function f
06:56:28 <mmorrow> , let x = (let f [] ; f (x:xs) = 1 + x + f xs in f [0..100000]) in x
06:56:29 <lunabot>  luna: parse error on input `;'
06:56:36 <mmorrow> , let x = (let f [] = [] ; f (x:xs) = 1 + x + f xs in f [0..100000]) in x
06:56:37 <lunabot>  luna: No instance for (GHC.Enum.Enum [a])
06:56:37 <lunabot>    arising from the arithmetic sequence `0 .. 100000'
06:56:37 <lunabot>                 at <interactive>:1:104-114
06:56:45 <mmorrow> grr
06:57:01 <mmorrow> oh
06:57:07 <rog_> Saizan: 'cos otherwise (return (error "foo") >> return 5) will always fail, which it shouldn't. i think.
06:57:09 <Saizan> rog_: no, your second foldM2 is equivalent to the first foldM2 where f is substituted with \a b ->  f a b >>= \x -> x `seq` return x
06:57:19 <mmorrow> gah, i never had this much difficulty trying to cause a stack overflow ;)
06:57:28 <Saizan> rog_: regardless of the monad
06:57:50 <rog_> i see
06:58:50 <mmorrow> , foldl (\(a,b) (c,d) -> (a+c,b+d)) (0,0) (zip [0..10000] [0..])
06:58:52 <lunabot>  (50005000,50005000)
06:58:57 <mmorrow> , foldl (\(a,b) (c,d) -> (a+c,b+d)) (0,0) (zip [0..1000000000] [0..])
06:59:00 <lunabot>  luna: out of memory (requested 1048576 bytes)
06:59:05 <mmorrow> , foldl (\(a,b) (c,d) -> (a+c,b+d)) (0,0) (zip [0..10000000] [0..])
06:59:08 <lunabot>  luna: out of memory (requested 1048576 bytes)
06:59:12 <mmorrow> > foldl (\(a,b) (c,d) -> (a+c,b+d)) (0,0) (zip [0..10000000] [0..])
06:59:24 <vegai> what's lunabot?
06:59:46 <Botje> it's a lambdabot on the mooooooooooooooon
06:59:52 <mmorrow> it's an eval bot that uses the ghc-api to compile and eval expressions firectly
07:00:03 <lambdabot>   thread killed
07:00:16 <mmorrow> s/f/d/
07:00:49 <mmorrow> and lunabot uses the same eval function to eval exps at the top level as that eval function has imported into its environment
07:00:55 <mmorrow> so it imports itself
07:00:59 <mmorrow> , eval "42"
07:01:03 <lunabot>  <<Integer>>
07:01:25 <mmorrow> , eval "eval \"42\""
07:01:29 <lunabot>  <<Dynamic>>
07:01:54 <mmorrow> , (fromJust . fromDynamic . fromJust . fromDynamic) (eval "eval \"42\"") :: Integer
07:01:59 <lunabot>  42
07:02:02 <mmorrow> :)
07:02:47 <mmorrow> i can't seem to trigger a stack overflow for the life of me
07:03:05 <mmorrow> , foldr (+) 0 [0..100000]
07:03:07 <lunabot>  5000050000
07:03:27 <Saizan> > foldr (+) 0 [1..1000000000]
07:03:31 <lambdabot>   mueval: Prelude.read: no parse
07:03:31 <lambdabot>  mueval: *** Exception: stack overflow
07:03:36 <Saizan> , foldr (+) 0 [1..1000000000]
07:03:39 <lunabot>  Stack space overflow: current size 8388608 bytes.
07:03:39 <lunabot>  Use `+RTS -Ksize' to increase it.
07:03:47 <Saizan> yay!
07:03:57 <Saizan> , foldl (+) 0 [1..1000000000]
07:04:01 <lunabot>  luna: out of memory (requested 1048576 bytes)
07:04:23 <Saizan> with foldl you first have to allocate the thunk
07:05:54 <cjay> what does old lambdabot use instead of ghc-api? I thought it uses Plugins which uses ghc-api itself, doesn't it?
07:06:09 <vegai> has anyone written a 24h Haskell network server to a production environment?
07:06:42 <Saizan> cjay: plugins essentially compiled with ghc -O2, lambdabot currently uses mueval which uses hint which uses the ghc-api
07:07:09 <vegai> this looks a bit like a task that would suit Erlang perfectly. In comparison to Haskell especially because of Erlang's hot swapping mechanisms
07:07:34 <mmorrow> ok, i can't come up with an example in pure code that rnf makes possible
07:07:36 <cjay> hmm
07:07:39 <vegai> but then again, xmonad has some sort of hot swapping in place too, doesn't it? Could this be implemented in a networked server too?
07:08:03 <mauke> the magic of exec
07:08:20 <Saizan> vegai: xmonad quits and spawns a new process passing it the current state
07:08:20 <vegai> mauke: so simple?
07:08:32 <mmorrow> (i've only used it to force lazily read-in-IO data that i can think of)
07:08:35 <vegai> ah right
07:08:36 <mauke> xmonad doesn't spawn a new process, it simply execs itself
07:08:49 <mauke> well, first it spawns ghc to recompile itself
07:09:29 <mmorrow> Saizan: stoverclow ftw!
07:09:58 <Saizan> stoverclow?:)
07:10:22 <mmorrow> stack overflow ;)
07:10:36 <mmorrow> (being printed from two threads maybe)
07:10:54 <mmorrow> speaking of that, have you done anything more with parallel cabal?
07:12:17 <Saizan> mmorrow: we decided to split it in a new project for the moment http://hackage.haskell.org/trac/hackage/wiki/HBuild
07:12:24 <lambdabot> Title: HBuild - Hackage - Trac
07:12:58 <mmorrow> cool
07:13:02 <Saizan> mmorrow: but i'm in a fase of "i could do this better but i'm not exactly sure how" instead of "use the existing machinery to release a working program"
07:13:27 <Saizan> *phase
07:15:11 <mmorrow> Saizan: i feel like i'm in the phase perpetually
07:15:17 <mmorrow> for everything
07:15:47 <mmorrow> hehe
07:15:54 <mmorrow> http://moonpatio.com/rc.png
07:16:00 <mmorrow> "recursive calvin"
07:16:38 <mmorrow> i want to have to big one holding an umbrella
07:17:08 <Taejo> damn CS tutors who don't understand proof by contrapositive!
07:17:25 <Taejo> he writes in my test paper "where is the contradiction?"
07:18:00 <Saizan> heh
07:18:07 <mauke> "YES."
07:18:08 <mmorrow> well if such didn't exist, you wouldn't be able to say that
07:19:01 <Saizan> i had one prof who couldn't derive no starvation -> no deadlock from deadlock -> starvation
07:23:35 <Taejo> on the other side, my class spent 45 minutes trying to understand the proof that the halting problem is undecidable
07:23:53 <vixey> 45 minutes to understand a proof?!
07:24:12 <vixey> must be a good class
07:24:17 <Taejo> lol
07:24:28 <vixey> I think it took me years to understand that
07:24:31 <quicksilver> quite
07:24:38 <quicksilver> the halting problem being undecidable is deep.
07:24:56 <earthy> http://www.bemuzed.com/lucasd/halting-poem.html ...
07:25:02 <lambdabot> Title: lucas dixon : Scooping the Loop Snooper
07:25:23 <Taejo> years of familiarity have dulled my senses
07:25:35 <earthy> the undecidability itself is not that hard to grasp. its consequences are quite deep though
07:25:42 <vixey> completely changed my understanding of everything actually
07:26:01 <vixey> that's the problem with ideas
07:26:43 <Taejo> yeah, good point
07:29:14 <hugo__> hi
07:29:25 <hugo__> im having this stress with modules and named data types
07:29:33 <hugo__> how do i export the accessors ?
07:29:47 <vixey> accessors aren't a concept in haskell
07:29:56 <vixey> do you mean some functions you wrote? or the Constructors?
07:30:01 <hugo__> hmm
07:30:11 <Taejo> hugo__: are you talking about records?
07:30:14 <hugo__> yes
07:30:15 <hugo__> records
07:30:45 <vixey> hmmm maybe I should aknowledge that records exist..
07:30:46 <hugo__> i have this named data type, with records inside, to access them i usually apply a function with the same name as them
07:31:03 <Taejo> hugo__: can't you export it the same as any other function?
07:31:09 <hugo__> dont know
07:31:12 <hugo__> i will try it...
07:32:30 <EvilTerran> MyDataType(..) in the export list might do it
07:32:31 <EvilTerran> iirc
07:32:52 <vixey> oh they are called field names not accessors
07:32:55 <FunctorSalad> hmm... apparently cabal-install 0.52 ignores the config file? (I removed my old config in order to have the new example config file installed, just changed a few settings there)
07:33:16 <Taejo> EvilTerran: isn't (..) just for the constructors?
07:33:16 <FunctorSalad> it does open the config file, but it seems to have no effect
07:33:31 <quicksilver> I think field names (selectors) are top-level functions
07:33:34 <quicksilver> and exported as such
07:33:39 <hugo__> yes, thanks EvilTerran it worked fine :D
07:33:44 <quicksilver> oh.
07:33:45 <Elly> FunctorSalad: I like your name :)
07:33:46 <rog_> hugo__: Datatype(accessor1, accessor2...)
07:33:49 <quicksilver> I'm wrong, then.
07:33:50 <quicksilver> ;)
07:33:54 <rog_> oops
07:33:57 <FunctorSalad> Elly: :)
07:34:11 <hugo__> thanks :D
07:34:20 <EvilTerran> :)
07:34:58 <Saizan> FunctorSalad: which fields you changed?
07:36:19 <rog_> my "oops" was 'cos i'd been unknowingly scrolled up a page. but that's how i've been exporting my accessor functions, and it seems to work. so maybe it wasn't an oops after all. but maybe i shouldn't be doing it that way.
07:37:07 <dblazakis> i have a list of Maybe a, is there an idiomatic way to evaluate in order until I find a Just x, sort of the reverse of the monad
07:37:42 <FunctorSalad> Saizan: "documentation" to true, and some of the directories
07:38:29 <Saizan> > msum [Nothing,Just 1, Just 2]
07:38:30 <lambdabot>   Just 1
07:38:37 <Saizan> dblazakis: like that? ^^^
07:38:41 <dblazakis> :type msum
07:38:50 <dblazakis> Saizan: exactly
07:38:52 <Saizan> :t msum
07:38:55 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
07:39:02 <ivanm> would there be any advantage in using hmatrix over uarrays if all I'm wanting to do is change and inspect values at given co-ordinates (i.e. I'm not doing any matrix equations)?
07:39:22 <dblazakis> @src Maybe msum
07:39:22 <lambdabot> Source not found. There are some things that I just don't know.
07:39:50 <Saizan> msum = foldr mplus mzero
07:40:39 <quicksilver> ivanm: Magic 8-ball says 'no'
07:40:54 <ivanm> quicksilver: heh...
07:40:59 <quicksilver> ivanm: I'm thinking hmatrix is a win if you are multiplying huge matrices and you want that fairly fast.
07:41:09 <ivanm> yeah, but I'm not
07:41:09 <quicksilver> ivanm: but probably not relevent for a simple caes.
07:41:15 <quicksilver> mind you, you might prefer its API.
07:41:35 <ivanm> for some reason, I had this great idea of using hmatrix-matrices... but then I started coding, and I couldn't remember what the great idea was :s
07:41:41 <FunctorSalad> hmm I only tested "cabal install", maybe the config works for the others...
07:46:35 <idnar> @type when
07:46:36 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
07:46:38 <idnar> @src when
07:46:38 <lambdabot> when p s = if p then s else return ()
08:00:04 * EvilRanter casts Vanquish on EvilTerran
08:03:09 <dcoutts> FunctorSalad: does your problem look like this: http://hackage.haskell.org/trac/hackage/ticket/365
08:03:10 <lambdabot> Title: #365 (new cabal-install ignores prefix settings in my config file, fails every i ...
08:03:21 <dcoutts> FunctorSalad: if so can you append you config that is not working
08:03:29 <dcoutts> as a comment to that ticket
08:05:04 <Heffalump> dcoutts: prod re those zlib changes
08:06:28 <dcoutts> Heffalump: yep, I might do that before or during the darcs hackathon
08:06:51 <Philonous> @src liftM2
08:06:51 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
08:07:23 <Heffalump> ok
08:08:36 <Philonous> > liftM2 (+) [1,2,3] [1,10,100]
08:08:37 <lambdabot>   [2,11,101,3,12,102,4,13,103]
08:10:30 <ziman> @hoogle Show a => ZipList a -> String
08:10:30 <lambdabot> Prelude show :: Show a => a -> String
08:10:30 <lambdabot> Text.Show show :: Show a => a -> String
08:10:30 <lambdabot> Control.Applicative getZipList :: ZipList a -> [a]
08:10:45 <FunctorSalad> dcoutts: it just dawned on me that the "--" in ~/.cabal/config are comments, not the long-option-"--".....
08:10:57 <FunctorSalad> :)
08:11:00 * FunctorSalad feels silly
08:11:23 <FunctorSalad> s/are/might be/
08:12:39 <FunctorSalad> a bit confusing since the file is not valid haskell
08:13:00 <FunctorSalad> *checks* yes, that was the problem
08:13:19 <dcoutts> FunctorSalad: ok good good
08:13:26 <dcoutts> FunctorSalad: it's the same syntax as .cabal files
08:13:40 <FunctorSalad> :)
08:14:08 <Philonous> Is there a style suggestion how to call lists, heads and tails? xs@(x:xt) and (x:xs) in one file are somwhat inconsistent
08:14:17 <Twey> @pl \x -> x * x
08:14:17 <lambdabot> join (*)
08:14:28 <Taejo> Philippa_: I use xs@(x:xs')
08:14:40 <mauke> xxs@(x : xs)
08:14:41 <Taejo> oops Philonous
08:15:00 <Philonous> Even more variants don't make it any better ^^
08:15:09 * Taejo writes out 100 times I Must Not Use Tab Completion In Crowded Channels
08:15:18 <Philonous> *ggg*
08:15:24 <Plouj> hi
08:15:44 <Plouj> I'm trying to load the first tutorial in this YAHT section, and I'm getting an indentation error: http://en.wikibooks.org/wiki/Haskell/YAHT/Language_basics#Source_Code_Files
08:15:46 <lambdabot> Title: Haskell/YAHT/Language basics - Wikibooks, collection of open-content textbooks, http://tinyurl.com/297cq5
08:16:09 <Plouj> I made sure, with spaces, that where lines up with the letter 'l'l in "module"
08:16:19 <Plouj> 'l'
08:16:44 <mauke> that's completely irrelevant
08:16:52 <mauke> you can put 'where' anywhere
08:17:19 <hugo__> is there any place that i can read about the coding conventions in haskell ? like how to write the names of the vars and functions and stuff like that ?
08:17:52 <mmorrow> Philonous: i like a@(x:xs)
08:17:52 <Twey> @pl \l -> (l !! 1, l !! 2)
08:17:52 <lambdabot> liftM2 (,) (!! 1) (!! 2)
08:18:28 <Plouj> oh, wait, the indentation is wrong on line 6
08:18:35 <Plouj> but what could possibly be wrong?
08:18:42 <Plouj> z = x * fst y
08:18:52 <Plouj> doh
08:19:02 <Plouj> I missed an '=' on the line above..
08:19:05 * Twey frowns.
08:19:12 <Plouj> I'm sorry guys
08:19:26 <Twey> > liftM2 (,) (!! 1) (!! 2) $ [1, 2, 3]
08:19:27 <lambdabot>   (2,3)
08:19:31 <Philonous> mmorrow: That takes away the mnemonic that equal base name = parts of the same list
08:19:32 <Twey> . . .
08:19:39 <ejt> what does it mean when my program prints <<loop>> and exits ?
08:19:49 <mauke> ejt: you wrote an infinite loop
08:19:56 <Twey> It doesn't work when I do it in GHCi :-\
08:20:02 <Axman6> it's too lazy to actually do the loop
08:20:22 <ejt> clever of it to spot it (I haven't as yet :)
08:20:24 <Axman6> its like taying "insert loop here"
08:20:29 * Axman6 is joking btw
08:20:46 <Twey> > liftM2 (,) (!!1) (!!2) $ [1, 2, 3] -- gives me `No instance for (Monad ((->) [a]))`
08:20:47 <lambdabot>   (2,3)
08:20:59 <Axman6> didn't spot my infinite loop :( just gives me stack overflows
08:20:59 <Twey> ... but... not in lambdabot :-\
08:21:13 <Twey> , liftM2 (,) (!!1) (!!2) $ [1, 2, 3] -- lunabot?
08:21:14 <lunabot>  luna: parse error (possibly incorrect indentation)
08:21:33 <pjdelport> Twey: you might need to import Control.Monad.Instances
08:21:54 <Twey> pjdelport: Aha, thanks
08:22:40 <Philonous> Is there an official style guide for haskell?
08:23:01 <RayNbow> Twey: you could also import Control.Arrow
08:23:32 <mmorrow> Philonous: i like it precisely because it /does/ distinguish it from the x and xs, because if i'm using an @, 99% of the time i'm using the vars on either side of the @ in distinct ways
08:23:41 * Axman6 has one Haskell style rule: don't use point free style when there's more than one variable being applied to the function.
08:24:18 * Twey has one Haskell style rule: don't use point-free style when it involves more than one flip applied in sequence.
08:24:20 <mmorrow> and pair up  a@(x:xs) b@(y:ys) c@(z:zs)
08:24:59 * Axman6 adds another style rule: if you have to use flip to make something pointfree, you're doing it wrong
08:25:42 <mmorrow> on the other hand, i deliberately shadow vars in case expressions
08:25:49 <Philonous> mmorrow: I don't really see why this favourable over xs@(x:xt) ys@(y:yt) zs@(z:zt)
08:26:06 <mmorrow> because those t's are yucky
08:26:13 <mmorrow> ;)
08:26:23 <Axman6> mmorrow: i don't know why, but i agree
08:26:30 * pjdelport prefers (`foo` x) to flip foo x
08:26:39 <mmorrow> Axman6: heh
08:26:59 <Axman6> pjdelport: i'd never thought of that. nice work
08:26:59 <int-e> pjdelport: you can have both, foo `flip` x ;-)
08:27:22 <pjdelport> int-e: that is horrible
08:27:27 <pjdelport> yet interesting
08:27:29 <int-e> pjdelport: yes.
08:27:46 <pjdelport> you could read `flip` as a weird placeholder
08:28:03 <Philonous> I think xs suggests that the tail consists of more than one element and es even nonempty
08:28:12 <RayNbow> @pl \x f -> f x
08:28:12 <lambdabot> flip id
08:28:47 <mmorrow> Philonous: not nonempty, since      f [] = [] ; f (x:xs) = x : f xs
08:28:47 <dmead> Philonous,xs can be []
08:29:17 <Philonous> dmead: Of course it can, that's my point
08:29:45 * Twey disagrees with Axman6's flip rule.
08:29:51 <Axman6> :)
08:30:12 <Axman6> pointfree can be nice, but it's often grossly misused imo
08:30:12 <mmorrow> Philonous: not that it /can't/, but that that's not something i'd say is commonly connoted by humans writing xs in haskell
08:30:15 <Twey> A flip here and there can often be useful.
08:30:31 <Twey> You just have to take care not to abuse it.
08:30:32 <Axman6> i say that with all the wisdom that 8 or so months using haskell has given me ...
08:30:42 <Twey> Point-free ditto.
08:31:01 <pjdelport> > let (?) = flip in (f ? b) a :: Expr
08:31:02 <lambdabot>   f a b
08:31:05 <Twey> Some functions really are written more nicely with point-free style.
08:31:13 <Twey> Some functions, however, really aren't.
08:31:34 <dblazakis> arg, composing monads with transformers is making my head hurt
08:31:39 <vixey> I dispute any rules regarding style - putting boundries on what you do can only detract
08:31:41 <mmorrow> Twey: the ones that aren
08:31:42 * int-e usually draws the line at sections of (.)
08:31:53 <mmorrow> ']t usually arent because of how the author ordered the args
08:32:27 <mmorrow> like when i have a long lambda i want in a fold{l,r}, it's nice to
08:32:33 <Twey> mmorrow: *nods*
08:32:41 <Axman6> vixey: take them as a style guide then
08:32:45 <ziman> data SockAddr = SockAddr { saFamily :: !!Family -- from Network.Pcap
08:32:50 <ziman> what does the double bang mean?
08:33:01 <pjdelport> very strict?
08:33:19 <Axman6> must be evaluated before program execution... >_>
08:33:59 <mmorrow> , flip (flip foldl (0,0)) (zip [0..9] [0..]) $ \(x,y) -> (x+y,x-y+x*x*y)
08:34:00 <lunabot>  luna: Couldn't match expected type `(t1, t2) -> (t, t)'
08:34:00 <lunabot>         against inferred type `(t, t)'
08:34:27 <bd_> my laptop doesn't provide power usage estimates when it's plugged in :|
08:34:28 <mmorrow> , flip (flip foldl (2,3)) (zip [0..9] [0..]) $ \(x,y) (_,_)-> (x+y,x-y+x*x*y)
08:34:30 <lunabot>  (128222105817396991935516318542097267642356839347979098950933646653043281...
08:35:07 <bd_> wait, wrong window
08:36:22 <Axman6> mmorrow: wth is that :|
08:36:59 <mmorrow> some hideous contrivance which has shortened my life by 4-9 hours
08:37:12 <mmorrow> heh
08:37:22 <Axman6> does it have a point?
08:37:45 <dblazakis> is there a MaybeT anywhere
08:37:50 <dblazakis> i see one on the wikiw
08:38:14 <quicksilver> Maybe?
08:38:21 <quicksilver> there's one on the wiki and one on hackage.
08:38:40 <quicksilver> ErrorT is essentially isomorphic if you can't be bothered tro download a new package.
08:39:05 <matthew-_> @where haskell code coverage stuff and testing framework that can exercise every code path in a given function as a result of program analysis
08:39:05 <lambdabot> http://haskell.org/
08:39:10 <matthew-_> @where fail
08:39:11 <lambdabot> I know nothing about fail.
08:39:24 <Axman6> ha
08:39:25 <oklocod> :P
08:42:50 <Axman6> wow, this video is awesome. makes inventors of today look pathetic. http://www.dumpbase.net/Misc/crazy-stunts-and-inventions-from-the-1930s
08:43:03 <lambdabot> Title: Crazy Stunts and Inventions From The 1930's | Misc, http://tinyurl.com/3q552s
08:43:36 <BMeph> lambdabot++
08:43:48 <matthew-_> lambdabot: QED
08:44:44 <BMeph> matthew-_: Nice hack. ;)
08:44:55 <pjdelport> matthew-_: supercompilation!
08:45:08 <Axman6> it's amazing the way that people thought you could just move a big flat thing what was mildly wing shaped up and down and you'd fly
08:45:21 <pjdelport> matthew-_: maybe something in Supero could be adapted for that
08:46:14 <matthew-_> is there even code coverage analysis?
08:46:44 <mulletron> how do you calculate the nth root of a number in haskell?
08:47:03 <dblazakis> quicksilver: thanks
08:47:07 <Saizan> matthew-_: hpc
08:47:15 <Heffalump> @type (**)
08:47:16 <lambdabot> forall a. (Floating a) => a -> a -> a
08:47:25 <Heffalump> mulletron: using that
08:47:35 <Axman6> > 2**(1/5)
08:47:36 <lambdabot>   1.148698354997035
08:47:41 <Axman6> > 2**(1/2)
08:47:42 <lambdabot>   1.4142135623730951
08:47:49 <Axman6> > 2**(1/2) :: CReal
08:47:50 <lambdabot>   1.4142135623730950488016887242096980785697
08:47:52 <mulletron> thanks ;)
08:48:47 <Axman6> @let nthroot n r = n**(1/r)
08:48:48 <lambdabot>  Defined.
08:48:58 <olsner> I'd like that haskell-cafe-cafe mailing list, so that I can skip all the questions like "How do I do X in haskell" and only participate in the nonsense discussions
08:49:01 <Axman6> > nthroot 10 5
08:49:03 <lambdabot>   1.5848931924611136
08:49:16 <Heffalump> in 5 years will we have haskell-cafe-cafe-cafe-cafe-cafe-cafe?
08:49:29 <bd_> olsner: haskell-cafe-prime, you mean
08:49:31 <Axman6> Haskell-starbucks
08:49:39 <pjdelport> olsner: haskell-pub
08:49:42 <besiria> lol
08:50:08 <olsner> Heffalump: yes, and you'll find me always teetering on the edge to the next -cafe list :P
08:50:22 <Heffalump> I like haskell-pub
08:50:28 <olsner> pjdelport: haskell-vodka-afterparty :P
08:51:14 <pjdelport> haskell-shebeen
08:51:45 <olsner> shebeen?
08:51:59 * BMeph tries a command: cd haskell-pub; more lambda-beer
08:52:39 <pjdelport> olsner: http://en.wikipedia.org/wiki/Shebeen
08:52:40 <lambdabot> Title: Shebeen - Wikipedia, the free encyclopedia
08:55:08 <olsner> pjdelport: aha
09:00:31 * BMeph thinks #haskell-blah should be renamed ##haskell-pub
09:02:47 <vixey> mumble..
09:02:56 <vixey> I want my haskell compiler back! I can't code on this one
09:03:53 <quicksilver> ##haskell-real-ale
09:06:47 <osfameron> beer, unlike programming, is no fun without the side effects though
09:07:07 <osfameron> though drinking in a monad would be fantastic for avoiding hangovers
09:07:27 <sm> morning all
09:07:32 * Axman6 doesn't drink for the side effects
09:09:02 <sm> in the ghc time-1.1.2.1 library, Data.Time.Clock, parseTime defaultTimeLocale "%y" "08" returns the year 1908. Is this a known bug ? How do I find it in the scary ghc trac ?
09:10:08 <vixey> withoutHangover (do
09:10:10 <vixey>  ...)
09:11:57 <matthew-_> ok, so http://projects.unsafeperformio.com/hpc/ says yellow is uneval'd. So what's green and red then?
09:11:58 <lambdabot> Title: Haskell Program Coverage
09:14:09 <dons> matthew-_: always True, always False
09:15:03 <matthew-_> dons: thank you
09:16:15 <byorgey> ?source GHC.List
09:16:15 <lambdabot> GHC.List not available
09:16:51 <elzurk> why is the type signature of foldl "(a -> b -> a) -> a -> [b] -> a" and not "(a -> a -> a) -> a -> [a] -> a"?
09:17:10 <mauke> because the latter is unnecessarily restrictive
09:17:49 <elzurk> can you expand a bit?
09:18:13 <olsner> plus, the one with separate a and b types makes it easier to see what goes where
09:18:25 <BONUS> well you're probably thinking about stuff like foldl (+) 0
09:18:25 <elzurk> is the second one even correct?
09:18:33 <vixey> elzurk: Do you know what the type of \x y -> x is?
09:18:39 <BMeph> unsafePerformIO removeAldehydes -- heh-heh
09:18:51 <Axman6> elzurk: it's correct, but not as flexible as it should be
09:19:01 * sm reports http://hackage.haskell.org/trac/ghc/ticket/2671
09:19:04 <BONUS> elzurk: try giving this a read http://learnyouahaskell.com/higher-order-functions/#folds
09:19:05 <BMeph> matthew-_: A Merry Christmas? ;)
09:19:06 <olsner> BMeph: but only if you force that thunk...
09:19:11 <lambdabot> Title: Learn You a Haskell for Great Good! - Higher Order Functions
09:19:11 <lambdabot> Title: #2671 (Data.Time.Clock parseTime's %y parses "08" as 1908) - GHC - Trac
09:19:13 <Japsu> unsafePerformIO launchMissiles :: ()
09:19:28 * elzurk goes to read recommended link
09:19:39 * vixey gets ignored
09:20:07 <elzurk> vixey: is it a -> b -> a?
09:20:15 <vixey> yesa
09:20:37 <BONUS> for instance, look at this fold: foldl (\acc x -> show x ++ " ") "" [1,2,3,4,5]
09:20:50 <dons> huh
09:20:53 <dons> http://learnyouahaskell.com/ awesome.
09:20:54 <lambdabot> Title: Learn You a Haskell for Great Good!
09:20:55 <BONUS> the folding function takes a string and a showable thing
09:21:01 <BONUS> dons: im glad you like it :)
09:21:14 <BONUS> im still in the process of writing it etc.
09:21:16 <dons> :)
09:21:32 <BONUS> i doubt everything is 100% correct, so if anyone has any corrections please tell them to me, thx
09:21:50 <vixey> I knew you were up to something BONUS :p
09:21:54 <BONUS> hahaha
09:21:55 <quicksilver> awesome illustrations
09:22:01 <dons> yeah. really nice.
09:22:05 * quicksilver <3 the illustration for a texas range
09:22:10 <quicksilver> http://learnyouahaskell.com/starting-out/#texas-ranges
09:22:10 <lambdabot> Title: Learn You a Haskell for Great Good! - Starting Out
09:22:15 <BONUS> haha, they're just quick doodles
09:22:17 <dons> reminds me of http://www.lisperati.com/haskell/
09:22:20 <elzurk> I guess when I just think of fold as SUM and siblings, (a -> a -> a) makes sense, but I see there are other uses
09:23:06 <BONUS> thats a nice tutorial
09:23:11 <BONUS> i recall reading that yeah
09:23:12 <BMeph> > foldl (\acc x -> show x ++ " ") "(" [1,2,3,4,5]
09:23:12 <elzurk> yikes, I'm going to have to go through this site
09:23:13 <lambdabot>   "5 "
09:23:16 <mauke> ooh, what was that worm called
09:23:18 <mauke> wiggler?
09:23:30 <BONUS> wait
09:23:31 <BONUS> i mean
09:23:32 <vixey> which worm?
09:23:48 <vixey> elk cloner?
09:23:55 <BMeph> > foldl (\acc x -> acc ++ show x ++ " ") "" [1,2,3,4,5]
09:23:56 <lambdabot>   "1 2 3 4 5 "
09:23:59 <BONUS> > foldl (\acc x -> acc ++ show x ++ " ") "" [1,2,3,4,5]
09:24:00 <mauke> http://learnyouahaskell.com/starting-out - the description of head/tail/init/last
09:24:00 <lambdabot>   "1 2 3 4 5 "
09:24:00 <lambdabot> Title: Learn You a Haskell for Great Good! - Starting Out
09:24:03 <BONUS> i meant that
09:24:03 <BONUS> yikes
09:24:14 <BMeph> jinx! ;)
09:24:45 <vixey> ohh...
09:24:55 <vixey> from magic roundabout, I thought you meant a computer worm
09:25:02 <olsner> > init []
09:25:03 <lambdabot>   mueval: Prelude.read: no parse
09:25:03 <lambdabot>  mueval: *** Exception: Prelude.init: empty ...
09:25:37 <quicksilver> that is either a caterpillar or a centipede
09:25:46 <quicksilver> given that it's a cartoon it's hard to be sure
09:25:47 <mauke> I know it from Super Mario World
09:25:56 <BONUS> hehe, yeah its from that game
09:25:59 <quicksilver> although technically caterpillars only have six legs
09:26:00 <hugo__> if a programmer would come to you, and ask "what is so great about haskell ?" what would you answer ?
09:26:05 <quicksilver> but they have pseudopods
09:26:13 <quicksilver> hugo__: purity.
09:26:18 <vixey> eek im really confused today
09:26:20 <BONUS> hugo__: its loads of fun
09:26:23 <quicksilver> hugo__: type checking.
09:26:43 <mauke> (stupid visual puns)++
09:26:57 <hugo__> ok
09:27:03 <hugo__> thats what i said...
09:27:19 <hugo__> i had to explain what is purity and type checking... which i guess i was not very sucessfull at :P
09:27:35 <dons> fast, safe, short.
09:27:46 <hugo__> :)
09:27:50 <BONUS> i'd say that it allows you to model problems at a very high level
09:27:53 <dons> its rare to have all 3.
09:28:16 <BONUS> but i guess that comes in with short
09:28:21 <dons> yep.
09:28:22 <hugo__> fast, like in faster development time, or in efficient runtime ?
09:28:36 <dons> both. but i meant it compiles to fast code.
09:28:47 <dons> fast, safe, productive, parallel.
09:28:48 <dons> how's that?
09:29:00 <hugo__> parallel ?
09:29:03 <BONUS> that's a pretty good tagline
09:29:03 <hugo__> haskell is parellel ?
09:29:09 <hugo__> :P
09:29:13 <dons> easy to write good parallel programs, yes.
09:29:15 <BONUS> not automagically, but it's easier to parallelize
09:29:22 <dons> e.g. http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=all
09:29:22 <hugo__> oh, ok ok
09:29:24 <lambdabot> Title: Create your own Ranking | x64 Ubuntu : Intel® Q6600® quad-core Computer Langua ..., http://tinyurl.com/55nbs6
09:29:34 <dons> we've been churning out the parallel programs there with some success.
09:29:47 <younder> Well I tried explaining Haskell to a Agile programmer, but he claimed Haskell was just too lazy ;)
09:29:51 <ddarius> "What is so great about Haskell" == community
09:30:02 <BONUS> that too. everyone's really nice here
09:30:04 <hugo__> ok, ill have a nice tagline for next time someone asks me... (i just asked you guys, because im sure someone else will ask me again)
09:30:12 <dons> good stuff.
09:30:36 <BONUS> i like it when someone asked SPJ why the haskell community is regarded as so nice, and he said he didnt know but hes glad its that way
09:30:48 <quicksilver> younder: that's interesting, because I've always suspect 'Agile' means 'lazy'
09:30:55 <Twey> Hahaha
09:31:00 <quicksilver> younder: ... but with all of the negative connotations of lazy
09:31:07 <hugo__> if you would chose a keyword to define haskell community, what would that be ?
09:31:10 <quicksilver> as in "I can't be bothered to design before I write"
09:31:15 <olsner> yeah, for me, "agile" is pretty much lazy evaluation applied to the development process
09:31:17 <hugo__> perl guys like to call themselves "mongers"
09:31:20 <quicksilver> hugo__: obsessed
09:31:32 <olsner> PhD's? :P
09:31:35 <hugo__> ahah
09:31:36 <dons> "pure" ?
09:31:42 <dons> oh, monks.
09:31:47 <Axman6> heh
09:32:17 <hugo__> haskell monks ?
09:32:20 <olsner> I think of myself as a haskell 'hacker' when I code haskell
09:32:23 * vixey calls them haskell hackers
09:32:37 <hugo__> monks and hackers are nice keywords
09:32:56 <BONUS> the word hacker is strange when you think about how its used by programmers and how its used by the general public
09:33:23 <hugo__> yes, hacker is someone who uses a tool for a different purpose than that which was intended when invented... i guess...
09:33:26 <vixey> general public will learn, or not.
09:33:38 <olsner> @quote emission
09:33:38 <lambdabot> jamesbritt says: Writing Haskell, for example, involves an hour of meditation followed by the emission of a fold expression.
09:33:38 <Twey> A hacker is a hacker is a hacker.
09:33:49 <Twey> Hahaha
09:33:51 <vixey> hugo__: more direct: hacker is someone who hacks
09:33:54 <Twey> I like that one
09:33:55 <olsner> that description goes well with 'monk'
09:34:00 * Twey nods.
09:34:43 <hugo__> yes, even if it feels a rip of perl mongers heheh
09:34:53 <hugo__> "haskell monks" :)
09:35:30 <hugo__> thats nice
09:35:31 <hugo__> :)
09:36:11 <mauke> http://perlmonks.org/
09:36:12 <lambdabot> Title: PerlMonks - The Monastery Gates
09:36:39 <hugo__> hmm
09:36:53 <hugo__> how about www.hm.org (similar to www.pm.org) ?
09:37:01 <hugo__> but meaning haskell monks instead
09:37:20 <Axman6> i prefer haskell hackers
09:37:35 <mauke> A haskell comprehensive archive network, or 4chan for short
09:37:40 <mauke> er
09:37:42 <mauke> <->
09:38:08 <BONUS> monk would imply i get laid even less than i do now
09:38:09 <olsner> hmm, but "haskell monk" doesn't quite have that ring to it... phonetically... probably since it's "x- -" rather than "x- x-" like "haskell hacker(s)"
09:38:19 <Ferdirand> monad monk sounds nice too
09:38:28 <BONUS> monad monk has a nice ring
09:38:36 <hugo__> yes :)
09:39:03 <dblazakis> the monastic monadic order of haskel hackers
09:39:34 <dblazakis> renounce having an effect on the world and take up spiritual persuits
09:39:56 <pjdelport> monadic monkey
09:40:08 <dblazakis> haskell bhikkus?
09:40:20 <BONUS> monadic monkey sounds nice hehe
09:40:23 <Axman6> "The haskell athiestry: getting shit done, not whinging about it"
09:40:28 <Axman6> atheistry*
09:40:35 <hugo__> haskell hunks
09:40:43 <olsner> hmm, 'monad monk' doesn't sound like someone who produces actual running code (more like a producer of abstract nonsense :P)
09:41:47 <pjdelport> wielders of the haskell hammer
09:42:06 <hugo__> haskellz0r's
09:42:44 <wchogg> I assume the 'abstract nonsense' reference to category theory was intentional?
09:42:54 <olsner> indeed
09:43:43 * osfameron likes the "lambdacamel" moniker for perl/haskell types
09:44:03 <quicksilver> osfameron: isn't in excessive to have a moniker for such a small class? :)
09:44:15 <hugo__> heheh
09:44:17 <vixey> It's an important class
09:44:28 <olsner> eww, what an unholy union! those dirty people!
09:45:08 * olsner frets
09:45:14 <younder> Do you want some curry with that perl?
09:45:23 <hugo__> heheh :)
09:46:15 <osfameron> quicksilver: such people are clearly disturbed, and it's a good idea to identify them so they can be closely monitored
09:46:40 <vixey> says you :p
09:47:08 <vixey> who you added monads to perl?
09:48:01 <olsner> yay, functional programming in line noise
09:48:02 <Axman6> what is the point of currying anyway?
09:48:15 <vixey> Axman6: Compared to?
09:48:33 <Axman6> well... why does it exist?
09:48:36 <vixey> why curry instead of ____?
09:49:11 <mmorrow> lightly salt??
09:49:12 <olsner> well, currying gives you partial application for free
09:49:50 <olsner> and partial application for free gives you easy access to pointless techniques
09:50:47 <younder> Higher order mathematics come to mind like functors and operators
09:51:20 <Axman6> partial application?
09:51:47 <olsner> yes, that too, higher order functions are much nicer when you can send (f x) rather than having to do (\y z -> f x y z)
09:55:09 <rog_> i think this is a stupid question, but just to check: is it possible to write a function of type (Monad m) => ([a] -> b) -> ([m a] -> m b) that produces a function that doesn't use lots of space if the list is long?
09:56:34 <rog_> i don't think it is.
09:57:28 <Deewiant> I think it depends on the monad
09:57:55 <byorgey> I was just going to say the same thing.  But I think for most monads rog_ is right.
09:58:02 <byorgey> for example, consider Maybe.
09:58:19 <byorgey> given the [Maybe a], you run sequence on it to give a Maybe [a]
09:58:33 <byorgey> but you won't know whether it's a Nothing or a Just until the whole list has been processed
09:59:03 <rog_> ... so you need to keep all those a's around until they have.
09:59:04 <byorgey> which means the processing function [a] -> b can't get started until the whole list has been sequence'd
09:59:08 <byorgey> right.
09:59:10 <rog_> (was my reasoning)
09:59:50 <rog_> i think maybe i want to use Foldable rather than lists. (something i've only just come across)
10:00:16 <byorgey> I don't think that would solve the problem, though.
10:00:27 <byorgey> but it would be more general.
10:00:37 <bbs> anyone have a good set of docs discussing trasnposing matrixes / ascii character patterns?
10:00:51 <byorgey> rog_: by the way, that was far from being a stupid question =)
10:00:59 <vixey> bbs: what
10:01:24 <rog_> byorgey: i think it might if my summary function ([a] -> b) was defined as (Foldable f) => (f a -> b)
10:01:30 <rog_> byorgey: (instead)
10:01:53 <bbs> vixey: i am printing ascii characters on a screen
10:01:58 <bbs> and workign with a list of lists
10:02:00 <byorgey> rog_: you would still have the same problem that the folding wouldn't get started until the sequence was finished
10:02:14 <bbs> to make a smiple image on the screen... and i need to rotate and transpose this list of lists
10:02:16 <vixey> bbs: it's really awkward to write it for a list of lists
10:02:31 <byorgey> rog_: so it would still use a lot of memory
10:02:38 <vixey> bbs: You could make a function that takes (x,y) -> a the element at that place
10:03:00 <vixey> bbs: then create the new transposed list of lists by filling in a template shape with values from that function
10:03:23 <dblazakis> :t sequence
10:03:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:03:39 <rog_> byorgey: i'll have to think about it. i'm currently trying to "monadise" some previously monad-free code. this kind of issue seems typical of that scenario.
10:03:40 <vixey> bbs: even easier, you could turn the function (x,y) -> a into a new function (x,y) -> a that is a transposed version
10:03:58 <Deewiant> > transpose [[1,2,3],[4,5,6],[7,8,9]]
10:03:59 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
10:04:10 <vixey> bbs: (if you look at it like (x,y) -> (y,x) -> a)
10:04:32 <olsner> I guess if the monad has a sequence implementation such that it can evaluate the list lazily, it would work
10:05:07 <bbs> olsner: is that to me?
10:05:12 <byorgey> olsner: indeed.  but which monads have such a thing?
10:05:20 <rog_> olsner: but sequence isn't part of the monad class...
10:05:20 <byorgey> hm, I guess State does (?)
10:05:30 <Deewiant> ?src sequence
10:05:30 <lambdabot> sequence []     = return []
10:05:30 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
10:05:30 <lambdabot> --OR
10:05:30 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
10:05:33 <olsner> but it seems to me, what you really want might be to change the producing code so that it gives m [a] with a lazily produced list rather than [m a]
10:05:48 <byorgey> good point
10:05:49 <rog_> olsner: i don't think that's possible...
10:05:57 <bbs> Deewiant: thats pretty cool
10:06:02 <bbs> i could use that
10:06:10 <olsner> bbs: no, that was for rog_'s question
10:06:15 <bbs> olsner: k thanks
10:06:17 <rog_> olsner: well, in my case anyway.
10:06:41 <Deewiant> olsner: the transpose example was for bbs
10:07:05 <bbs> Deewiant: was sequnece for me too i thought
10:07:11 <olsner> heh, our contexts are out of sync :)
10:07:33 <Deewiant> > sequence [[1,2,3],[4,5,6],[7,8,9]]
10:07:34 <rog_> olsner: the point is that each item in the list is in the (unspecified) monad, and there are an arbitrary (possibly infinite) number of them
10:07:34 <lambdabot>   [[1,4,7],[1,4,8],[1,4,9],[1,5,7],[1,5,8],[1,5,9],[1,6,7],[1,6,8],[1,6,9],[2...
10:07:39 <Deewiant> you probably don't want that ;-)
10:07:47 <pjdelport> @hoogle [[a]] -> [[a]]
10:07:47 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
10:07:48 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
10:07:48 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
10:08:08 <pjdelport> bbs: when in doubt, hoogle the type you want
10:08:30 <bbs> pjdelport: ! :)
10:08:51 <olsner> oh, an infinite number of monadic operations in a list? that'll probably require some special circumstances...
10:09:28 <Deewiant> > repeat [1] -- voila, an infinite [m a]
10:09:30 <lambdabot>   [[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1],[1...
10:09:40 <olsner> how about making the analysis function work directly on the list-of-actions inside the monad?
10:09:50 <olsner> > sequence . repeat $ [1]
10:09:51 <lambdabot>   mueval: Prelude.read: no parse
10:09:52 <lambdabot>  mueval: *** Exception: stack overflow
10:10:48 <rog_> olsner: that's what i want to do. but i was after some way of re-using my existing analysis function. for instance, i've got something like (average :: (Num a) => [a] -> a)
10:11:19 <rog_> olsner: ... and potentially other stats-type functions, that i'd like to avoid writing in a monad-aware way.
10:12:02 <vixey> bbs: type Position = (Integer,Integer); type Dimension = (Integer,Integer); type Rectangle a = (Dimension,Position -> Maybe); transpose ((w,h),f) = ((h,w),\y x -> f x y)  -- is what I was trying to sugest
10:12:19 <olsner> afaics, with the type f :: (Monad m) => ([a] -> b) -> ([m a] -> m b) you'd have to have basically f g ms = fmap g (sequence ms) or something else that has the same set of problems
10:12:23 <vixey> bbs: Maybe a or something
10:12:46 <rog_> olsner: i *think* maybe if i write it like (average :: (Num a, Foldable f) => f a -> a) then i can avoid the problem.
10:13:01 <bbs> vixey: maybe a or something?? <--- i dont' understand there what you mean :)
10:13:17 <vixey> bbs: fixed a typing mistake in previous message
10:14:29 * vixey is reading Theorems for Free!
10:14:31 <bbs> oh ok, so i can use "a" or "something" after "Maybe"
10:15:21 <Twey> @pl \x y z -> [x, y, z]
10:15:21 <lambdabot> (. ((. return) . (:))) . (.) . (:)
10:16:01 <bbs> vixey: oh ok, so i can use "a" or "something" after "Maybe"
10:16:16 <olsner> @ty (.((.(:[])).(:))).(.).(:)
10:16:17 <lambdabot> forall a. a -> a -> a -> [a]
10:16:33 <Deewiant> ?pl \a b c -> [a,b,c]
10:16:33 <lambdabot> (. ((. return) . (:))) . (.) . (:)
10:16:55 <olsner> yes, ?pl and @pl give the same results :P
10:17:14 <Deewiant> just guessing at what the original was
10:17:35 <Deewiant> I just now noticed that it's about 5 lines above
10:17:40 <olsner> yeah :)
10:18:16 <vixey> why does @free work for fix?
10:18:31 <olsner> @help free
10:18:32 <lambdabot> free <ident>. Generate theorems for free
10:18:36 <insitu> hello, i have a question regarding fastcgi: how can I maintain state across requests ?
10:19:30 <mauke> how is that a haskell question?
10:19:48 <vixey> oh it is covered
10:20:05 <vegai> insitu: a db would be the typical choice
10:20:29 <vegai> can one use continuations for that in Haskell? I'm not sure
10:21:00 <insitu> vegai: yes, I have one for persistent data (eg. users), but I want to maintain things like sessions
10:21:37 <vegai> perhaps use memcached for those
10:21:44 <insitu> The problem seems that each request seems to be handled by a distinct invocation of a function
10:22:06 <vixey> > 1+1
10:22:08 <lambdabot>   2
10:22:15 <insitu> is this something that has already been done elsewhere ?
10:23:22 <mauke> only a thousand times
10:23:37 <mauke> in every forum or anything that lets you log in
10:23:53 <vegai> not in haskell, though
10:23:56 <insitu> mauke: good. Could you please point me to some haskell code doing that ?
10:23:59 <vegai> not thousand times, I mean :)
10:24:12 <mauke> oh, haskell. can't I do it in perl? :/
10:24:41 <insitu> mauke: sure. That's your code. I want to do it in haskell though
10:26:07 <mauke> HAppS probably has it
10:28:12 <insitu> yes, surely. I would like to understand how this is done and Happs code uses lot of template haskell
10:29:45 <insitu> and I am not very proficient with TH (nor with Haskell btw)
10:30:30 <jeffersonheard> what's the precedence of (>>=) ?
10:30:46 <Samy> :t (>>=)
10:30:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:31:20 <jeffersonheard> I know the type...  [infixl] what?
10:31:30 <Deewiant> ask GHCi, :info (>>=)
10:31:33 <jeffersonheard> thanks
10:32:17 <Samy> :i (>>=)
10:37:13 <vixey> hi
10:40:12 <Samy> Hi vixey
10:41:15 <vixey> I might try and write a generic progra
10:41:17 <vixey> program
10:43:58 <vixey> > 1+1
10:44:00 <lambdabot>   2
10:48:29 <Arnar_> hey all..
10:48:31 <rog_> i realise that perhaps i want something similar to hGetContents - that function seems to return a lazy list despite the fact that traversing it can incur many operations in the IO monad. how does this work?
10:48:48 <mauke> unsafeInterleaveIO
10:48:49 <Arnar_> what's the proper way to build a cabal package if I have the sources and I have cabal-install ?
10:48:55 <Arnar_> just run Setup.hs as usual?
10:49:01 <rog_> i.e. it cheats.
10:49:01 <vixey> @src hGetContents
10:49:01 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
10:49:03 <rog_> ok
10:50:31 <dcoutts> Arnar_: cd the/package; cabal install
10:51:02 <dcoutts> Arnar_: or if you're doing it as a developer, to hack on it, then cabal configure; cabal build etc
10:51:05 <Arnar_> dcoutts: oh right.. thanks. Now why didn't I think of that? :)
10:51:17 <Arnar_> dcoutts: ok.. thanks
10:51:17 <dcoutts> Arnar_: cabal --help will tell you
10:51:42 <Arnar_> right.. I didn't quite understand - I did "cabal install yi.cabal"
10:52:10 <dcoutts> Arnar_: ah, perhaps we should make it recognise that
10:52:16 <Arnar_> :)
10:52:41 <Arnar_> hrm.. every time I want to try some haskell software.. I give up b/c of issues with dependencies
10:52:42 <rog_> i was thinking that if i ran my monad in a concurrent process and i had synchronous (or bounded) channels, then it wouldn't be unreasonable to have a function like (Chan a -> STM [a]) where the [a] was lazily generated from channel reads from the other process. that might solve my problem. but it's probably too heavyweight...
10:52:47 <Arnar_> i.e. dependencies won't compile
10:52:50 <bbs> what is the latest ghc
10:52:57 <Arnar_> looks like it is so for Yi also
10:53:08 <dcoutts> bbs: 6.8.3, there's also a beta of 6.10
10:53:39 <dcoutts> Arnar_: can't get yi to build with cabal-install?
10:54:12 <Arnar_> dcoutts: haven't dived into it.. but yeah, it fails on Text/Regex/TDFA/ByteString.hs
10:54:35 <rog_> that way i could write liftL ([a] -> b) -> ([m a] -> m b) ok...
10:54:44 <Arnar_> also pureMD5 has problems
10:55:05 <Arnar_> (dive, dived, dived.. is that correct?)
10:55:06 <rog_> sorry, just thinking aloud. i'll be quiet now.
10:55:13 <dcoutts> Arnar_: hmm, sounds odd, it's usually fine, perhaps you should hpaste the error
10:55:17 <dcoutts> @hpaste
10:55:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:55:21 <Arnar_> dcoutts: hang on
10:55:22 <paczesiowa> Nafai: have you solved that problem yet?
10:55:22 <lambdabot> paczesiowa: You have 1 new message. '/msg lambdabot @messages' to read it.
10:56:00 <bbs> dcoutts: thanks
10:56:08 <paczesiowa> @seen Baughn
10:56:09 <lambdabot> Baughn is in #math, #haskell and #ghc. I last heard Baughn speak 10h 42m 13s ago.
10:56:45 <Arnar_> dcoutts: http://hpaste.org/11009
10:57:05 <paczesiowa> @tell Baughn actually all I wanted was that bug report, because someone was asking about such problems and I couldn't find it on ghc trac
10:57:05 <lambdabot> Consider it noted.
10:57:37 <Arnar_> dcoutts: cabal-install 0.4.2, cabal 1.3.3 and ghc 6.8.2
10:57:53 <Nafai> paczesiowa: Yes, I did.  Thanks.  dcoutts helped me figure it out last night.
10:58:09 <paczesiowa> Nafai: what was the problem?
10:58:49 <hackage> Uploaded to hackage: hpc-tracer 0.3.0
10:59:29 <Arnar_> dcoutts: don't worry to much about it.. don't have time for it now anyways :/
10:59:50 <Nafai> paczesiowa: To quote dcoutts:
10:59:51 <Nafai>  < dcoutts!n=dcoutts@unaffiliated/dcoutts: Nafai: ok, so I think the problem is that you're trying to access a column in the model that does not exist
11:00:09 <Nafai>  < dcoutts!n=dcoutts@unaffiliated/dcoutts: Nafai: right, that model has no columns defined at all, not on the C side, it's accessed from the Haskell side
11:00:12 <Nafai> 07-10-2008 22:26:16 < dcoutts!n=dcoutts@unaffiliated/dcoutts: Nafai: so access the store directly using the typed haskell api
11:00:15 <Nafai> 07-10-2008 22:27:19 < dcoutts!n=dcoutts@unaffiliated/dcoutts: Nafai: the list store api
11:00:48 <dcoutts> Arnar_: looks from that paste that everything worked. However I note that you are using quite ancient versions of Cabal and cabal-install, you want cabal-install-0.5.2
11:00:58 <paczesiowa> btw, does anyone else find yi code (I looked through frontends) to be a huge mess?
11:01:12 <Nafai> paczesiowa: As soon as github comes back up, I'll show you my code
11:01:19 <paczesiowa> Nafai: ok
11:01:51 <Arnar_> dcoutts: "quit ancient".. that's like a few weeks old right? :)
11:02:25 <dcoutts> Arnar_: 0.4.2 is well over a year old, we're using 0.5.2
11:03:05 <Arnar_> ah, ok
11:03:16 <dcoutts> Arnar_: actually I don't think 0.4.2 ever existed, did you actually mean 0.5.2?
11:03:24 <Arnar_> hmm
11:03:35 <Arnar_> arnarb-macbook:~$ cabal --version
11:03:36 <Arnar_> cabal-install version 0.4.2
11:03:42 <Arnar_> that's what it says
11:03:49 <dcoutts> Arnar_: heh, ok. You've got an old development version
11:03:57 <Arnar_> ah ok
11:04:15 <Arnar_> that might also explain why "cabal upgrade cabal" and "cabal upgrade cabal-install" fail to
11:04:20 <dcoutts> Arnar_: indeed
11:04:33 <dcoutts> Arnar_: there have been huge changes in cabal-install in the last 6 months
11:04:44 <Arnar_> ok..
11:04:54 <Arnar_> how should I go about upgrading?
11:05:58 <bbs> >2+3
11:06:02 <bbs> > 2+3
11:06:03 <lambdabot>   5
11:07:41 <bbs> i need to figure out how to do symmetry operation on a square :/
11:07:45 <bbs> thats really what i need
11:08:24 <Arnar_> bbs: what do you mean?
11:09:27 <bbs> i mean i have a matrix
11:09:33 <bbs> and i want to be able to rotate it
11:09:47 <Baughn> paczesiowa: http://hackage.haskell.org/trac/ghc/ticket/1780
11:09:49 <lambdabot> Title: #1780 (runInteractiveProcess broken with >2 processes on POSIX) - GHC - Trac
11:09:58 <Baughn> paczesiowa: It is apparently fixed
11:10:37 <bbs> Arnar_: rotate 90,180,270,flip across horizontal and vertical axis, and across major and minor diagonals
11:10:40 <bbs> thats what i mean
11:10:53 <Arnar_> ok
11:11:27 <Arnar_> bbs: your matrix is [[a]] ?
11:11:32 <Arnar_> fixed dimensions?
11:12:08 <bbs> Arnar_: yep
11:12:15 <paczesiowa> Baughn: huh, so 6.10 should be working ok. neat
11:12:25 <Baughn> paczesiowa: 6.8.3 should be working, too
11:12:45 <bbs> haha 6.8.3 works great.
11:12:48 <Baughn> The fix was merged before 6.8.3 was released
11:13:00 <Arnar_> bbs: well, transpose will mirror it on the major diagonal
11:13:02 <paczesiowa> damn, I should really fix my system and upgrade ghc
11:13:11 <Arnar_> > List.transpose [[1,2],[3,4]]
11:13:12 <lambdabot>   mueval: Prelude.read: no parse
11:13:40 <Arnar_> hm?
11:13:53 * rog_ is quite enjoying plumbing the depths of hGetContents.
11:14:10 <jeffersonheard> > Data.List.transpose http://en.wikipedia.org/wiki/Special:Search?go=Go&search=1,2],[3,4
11:14:11 <lambdabot>   mueval: Prelude.read: no parse
11:14:11 <lambdabot> http://en.wikipedia.org/wiki/Special:Search?go=Go&search=1,2],[3,4
11:14:25 <Baughn> ...what
11:14:44 <jeffersonheard> > Data.List.transpose [ [1,2],[3,4] ]
11:14:45 <lambdabot>   [[1,3],[2,4]]
11:14:50 <Baughn> Even if you /could/ have it transpose wikipedia, that would take way too long
11:14:52 <Arnar_> bbs: reverse will mirror it on the horizontal and (map reverse) will rotate it on the vertical one
11:14:55 <Arnar_> jeffersonheard: thanks
11:15:09 <Arnar_> > reverse [[1,2],[3,4]]
11:15:10 <lambdabot>   [[3,4],[1,2]]
11:15:17 <Arnar_> > map reverse [[1,2],[3,4]]
11:15:18 <lambdabot>   [[2,1],[4,3]]
11:15:25 <jeffersonheard> all articles that are inaccurate become accurate, all accurate become inaccurate, and the mods fall of the face of the TimeCube
11:15:50 <Baughn> jeffersonheard: It is not a cube. It is an N-simultaneous-day time tree.
11:15:54 <gbacon> When I try to configure lambdabot's build, Cabal complains about the package requiring multiple versions of several dependencies. Is this a known issue?
11:15:54 <bbs> Arnar_: what about rotations?
11:16:03 * jeffersonheard chuckles
11:16:25 <Baughn> ...and I'm not even kidding about that, although the "tree" part is an approximation
11:16:28 <dcoutts> gbacon: it depends which multiple packages it is
11:17:30 <Arnar_> bbs: is this homework?
11:17:58 <bbs> Arnar_: no its part of a project -- and he didn't tell us list functions yet
11:18:07 <bbs> so i am really looking more for docs
11:18:07 <bbs> not just for functions
11:18:15 <bbs> i mean i'll need ot know it for the fscking test
11:19:00 <shukhov> anyone here know hot to plot functions with gnuplot + octave? google is giving me a hard time.
11:19:19 <gbacon> dcoutts: shall I hpaste the warning?
11:19:29 <Arnar_> bbs: well.. rotation about 90 is really just (mirror_h . mirror_majordiagonal)
11:19:42 <Arnar_> bbs: the other rotations are just multiples of that
11:20:07 <Arnar_> bbs: sorry, that's 90 clockwise
11:20:29 <Arnar_> bbs: (mirror_v . mirror_majordiagonal) if you want 90 deg. anti-clockwise
11:21:00 <gbacon> dcoutts: or do you simply want a list of the indirect deps?
11:22:29 <bbs> Arnar_: ok
11:22:46 <rlorandi> shukhov, octave example: x=linspace(0,20,21); y=sin(2*pi*x/20); plot(x,y,";sine;")
11:22:48 <dcoutts> gbacon: so it tells you that it indirectly depends on two versions of package X. I'm interested in what package X is.
11:23:03 <tibbe> yi is cool :)
11:23:17 <tibbe> it makes such a big difference that I can just cabal-install it
11:23:20 <gbacon> dcoutts: binary-0.4.1, binary-0.4.3.1, bytestring-0.9.0.1, bytestring-0.9.1.3, haskell-src-1.0.1.1, haskell-src-1.0.1.2, mtl-1.1.0.0, mtl-1.1.0.1, network-2.1.0.0, network-2.2.0.0, parsec-2.1.0.0, parsec-2.1.0.1, parsec-3.0.0, regex-compat-0.91, regex-compat-0.92, regex-posix-0.93.1, regex-posix-0.93.2
11:23:24 <shukhov> rlorandi: thanks
11:23:39 <rlorandi> :-)
11:23:40 <clq> Quick newbie question: How do I limit the number of decimals of the numbers generated in a list? Like: [0.1,0,2..1] returns the 0.n numbers rather than 0.30000000000000004 etc. Thanks
11:23:52 <dcoutts> gbacon: wow, ok. That's bad. Try using cabal install --dry-run, it'll tell you what it'd reinstall to get a consistent set of dependnecies
11:24:15 <WodkaSchlunz_> how can I change my nick name?
11:24:23 <Heffalump> clq: you can't really, that's a floating point representation issue
11:24:23 <gbacon> dcoutts: I'm trying to build lambdabot from the latest revision from darcs
11:24:37 <BONUS_> clq: try doing map (/10) [1..10]
11:24:39 <Heffalump> if you want to print them out rounded, there are functions to do that, but I forget the names (showFloat?)
11:24:40 <gbacon> dcoutts: is that a bad idea? :-)
11:24:45 <BONUS_> it will look nicer but afaik its still the same thing
11:24:46 <Arnar_> bbs: http://hpaste.org/11010
11:24:52 <BONUS_> > map (/10) [1..10]
11:24:53 <lambdabot>   [0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1.0]
11:25:01 <dcoutts> gbacon: currently "cabal install" is smart and uses a constraint solving algorithm to work out what deps to use. "cabal configure" is dumb and just picks the highest versions of all available deps even if that might lead to an inconsistent set of deps.
11:25:09 <clq> Thanks!
11:25:12 <Heffalump> oh, ok :-)
11:25:13 <BONUS_> : )
11:25:14 <clq> Thats perfect.
11:25:18 <clq> Appreciated.
11:25:19 <jeffersonheard> is it possible to use TH to make better syntax than x <- readIORef y ?
11:25:26 <Baughn> [0.1..1]
11:25:28 <jeffersonheard> like x := y
11:25:29 <Baughn> > [0.1..1]
11:25:30 <lambdabot>   [0.1,1.1]
11:25:35 <BONUS_> using ranges with floating points usually turns out weird results because of the limitations of floating point numbers
11:25:38 <Baughn> > [0.0,0.1..1]
11:25:39 <lambdabot>   [0.0,0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.89999...
11:26:21 <dcoutts> gbacon: so it's not something wrong with lambdabot necessarily, just the set of dependencies we're using. Does that make any sense?
11:26:39 <bbs> Arnar_: ok -- where are some good docs on this stuff?
11:26:46 <gbacon> dcoutts: yes
11:26:49 <Arnar_> bbs: list stuff?
11:27:07 <bbs> Arnar_: yea -- i want to fully understadn it
11:27:10 <bbs> i mean this _is_ simple
11:27:16 <bbs> especially when you draw it out ;p
11:27:26 <bbs> waskally haskell confuses me sometimes though
11:27:30 <gbacon> dcoutts: cabal install --dry-run lambdabot says it would reinstall versions of parsec, network, HTTP, and oeis that are already present
11:28:09 <jeffersonheard> only sometimes?
11:28:13 <gbacon> dcoutts: should I abandon the darcs build for now?
11:28:36 <Arnar_> bbs: well.. you understand reverse, right?
11:28:41 <Arnar_> > reverse [1,2,3]
11:28:42 <lambdabot>   [3,2,1]
11:28:46 <gbacon> ?src reverse
11:28:46 <Deewiant> dcoutts: hmm, is it possible to use the smart algorithm with 'cabal configure' in the case when the package doesn't build without messing with it
11:28:46 <lambdabot> reverse = foldl (flip (:)) []
11:29:06 <Arnar_> bbs: you can see how that mirrors on horizontal axis if your matrix is a list of rows
11:29:49 <Arnar_> bbs: (map reverse) performs the reverse on each row.. i.e. it mirrors on the vertical axis
11:30:14 <Arnar_> bbs: Data.List.transpose just does what it says.. it turns rows into columns and vice versa
11:30:27 <dcoutts> Deewiant: right, that's an obvious thing to want to do and we should do it. It's slightly non-trivial because if there isn't an easy way of getting consistent deps then we can't prevent people from configuring because they might know that the inconsistent deps are ok.
11:30:30 <Arnar_> bbs: the rest is geometry
11:31:06 <Deewiant> dcoutts: 'cabal configure --force' for the inconsistent ones?
11:31:09 * rog_ has just seen the "no atomically inside unsafePerformIO" restriction. bang goes that idea...
11:31:10 <dcoutts> gbacon: so the reason it wants to rebuild those libs is to rebuild them against different versions of their deps.
11:31:27 <dcoutts> Deewiant: but what does it mean? just fall back to picking the highest?
11:31:45 <dcoutts> Deewiant: the smart algorithm cannot find nearly consistent solutions, it's consistent or fail.
11:32:00 <FunctorSalad> hmm... the current haddock doesn't like the haddock distributed with ghc 6.8.3 (something about magic numbers)... is there a replacement somewhere?
11:32:05 <dcoutts> gbacon: you can add -v to see what versions it's picking
11:32:20 <FunctorSalad> (I mean when trying to link to it, when building a haddock for sth else)
11:32:24 <Deewiant> dcoutts: I suppose, yes, since you can specify the deps manually as well, right?
11:32:37 <Deewiant> (via editing the .cabal file at least)
11:33:12 <dcoutts> Deewiant: we prefer to do that via --constraint='foo == 1.2' flags
11:33:36 <Deewiant> in any case it's "consistent [default] / highest [--force] / do it manually"
11:33:39 <dcoutts> Deewiant: the .cabal file should reflect the needs of the package, not your specific environment or configuration choices
11:34:05 <dcoutts> Deewiant: I was thinking of making it just fall back to highest with a big warning
11:34:21 <Deewiant> I suppose that would be good too
11:38:56 <gbacon> dcoutts: running cabal install in the darcs working-copy fails with a linker error for lambdabot-utils (failing symbol from parsec)
11:40:42 <dcoutts> gbacon: hmm, could try cabal clean in lambdabot dir and reinstalling lambdabot-utils
11:42:02 <gbacon> dcoutts: now I get "dependencies conflict: lambdabot-utils-4.2 requires mtl ==1.1.0.1 however mtl-1.1.0.1 was excluded because lambdabot-utils-4.2 requires mtl ==1.1.0.0"
11:42:03 <gbacon> :-(
11:44:13 <Apocalisp> is such a thing as the inverse of a function modellable in Haskell?
11:44:42 <dcoutts> gbacon: ahh, right, see cabal-install does not know how to rebuild lambdabot-utils, so it has to go with the installed version
11:45:12 <Apocalisp> the inverse of a stream, perhaps. Such that "not s" yields every value of the type of s that is not in s.
11:45:21 <dcoutts> gbacon: it only knows how to rebuild things on hackage. So it's a little harder to get consistent deps when we've got several devel packages.
11:46:22 <dcoutts> gbacon: actually that's a slightly odd error. Was that rebuilding lambdabot-utls or trying to install lambdabot after rebuilding lambdabot-utils
11:46:37 <gbacon> dcoutts: the former
11:47:15 <dcoutts> gbacon: just doing cabal install in the lambdabot utils dir
11:47:31 <dcoutts> @where lambdabot
11:47:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
11:47:35 <gbacon> dcoutts: no, cabal install --global lambdabot-utils
11:47:57 <dons> ?users
11:47:57 <lambdabot> Maximum users seen in #haskell: 540, currently: 516 (95.6%), active: 23 (4.5%)
11:48:04 <dcoutts> gbacon: oh
11:49:08 <dcoutts> gbacon: but hackage only has lambdabot-utils-0.4.1, and you're using 0.4.2
11:51:13 <gbacon> dcoutts: l-u-4.2 is also in the darcs repo
11:52:06 <dcoutts> gbacon: "cabal install" means install the thing that's in the current dir. "cabal install lambdabot-utils" means install the thing from hackage.
11:52:34 <gbacon> dcoutts: yes, I understand
11:53:14 <dcoutts> gbacon: so I don't understand why asking it to install lambdabot-utils from hackage would give error messages about version 0.4.2 which is not on hackage
11:53:36 <gbacon> dcoutts: say, who's the Barber here? :-)
11:54:27 <gbacon> dcoutts: ghc-pkg reports both 4.1 and 4.2 of lambdabot-utils installed
11:54:41 <gbacon> dcoutts: perhaps from an earlier install attempt from the darcs wc
11:55:04 <dcoutts> gbacon: I'll need more details on how to reproduce this I'm afraid, I can't diagnose what's wrong atm.
11:55:15 <dcoutts> gbacon: I'm out for lunch for about 30min
11:55:21 <gbacon> dcoutts: bon appetit
11:55:32 <gbacon> dcoutts: thanks for your help
11:56:04 <Taejo> @ty catch
11:56:05 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
11:57:55 <gbacon> ?tell dcoutts when I tried to install lambdabot-utils from hackage, I was in lb's darcs dir which has a lambdabot-utils (i.e., 4.2) subdirectory
11:57:55 <lambdabot> Consider it noted.
11:58:49 <hackage> Uploaded to hackage: hpc-tracer 0.3.1
12:02:34 <Samy> Hrm.
12:02:46 <Samy> lambdabot, @join ##FreeBSD
12:02:47 <lambdabot> Not enough privileges
12:04:38 <SamB_XP_> lambdabot: okay, we'll let you use the swimming pool on weekends
12:04:46 <SamB_XP_> NOW will you join ##freebsd ?
12:08:44 <CosmicRay> heh
12:08:58 <CosmicRay> ?tell twb I tried to find you, but you weren't around
12:08:58 <lambdabot> Consider it noted.
12:09:01 * SamB_XP_ loves how when he switches to a chrome tab and it starts swapping in, he can switch to another while he waits ;-)
12:09:07 <CosmicRay> heh
12:09:10 <CosmicRay> low ram?
12:09:28 <SamB_XP_> I think this system has 384 megs
12:09:48 <SamB_XP_> but, you know, it's never enough
12:11:30 * mml` fiddles with nested datatypes.
12:11:32 <CosmicRay> ouch.
12:12:38 <SamB_XP_> well, perhaps 2 gigs would be enough for a while
12:12:52 <SamB_XP_> that's what some of the machines at school seem to have
12:13:06 <paczesiowa> my old laptop has 192 mb, it is impossible to install haskell stuff.
12:13:32 <paczesiowa> linking cabal setup file takes few hours and then it compiles library in 2 minutes
12:14:25 <paczesiowa> any ideas why it takes so much ram?
12:15:18 <SamB_XP_> ld stinks ?
12:16:08 <SamB_XP_> uh, also perhaps that whole splitting-of-objects deal
12:16:35 <paczesiowa> I was trying to manually link it, but when I realised that depending on order of provided object files it would take different amounts of memory I gave up
12:17:08 <SamB_XP_> I rest my case ;-)
12:17:29 <paczesiowa> I think there was new linker, that was supposed to be much faster, don't know about memusage though
12:17:38 <SamB_XP_> what ?
12:17:45 <SamB_XP_> you were using gold for this ?
12:17:57 <SamB_XP_> you should probably give feedback then ...
12:18:01 <paczesiowa> no, ld
12:18:11 <SamB_XP_> oh, oh
12:18:18 <SamB_XP_> you were just saying that it exists ;-)
12:18:21 <paczesiowa> maybe gold would help
12:18:24 <paczesiowa> yes
12:18:27 * SamB_XP tires of _ after name
12:21:23 <paczesiowa> ghc calls gcc to link things right? if so it wouldn't be that easy to use different linker only for haskell stuff
12:24:47 * rog_ has realised that it's not possible to implement synchronous channels on top of STM
12:25:30 <rog_> sadly
12:27:17 <dons> really?
12:27:21 <dons> hmm.
12:27:29 <dons> you've a proof?
12:28:02 <dons> that'd be an interesting result.
12:29:28 <SamB_XP> rog: what precisely do you mean ?
12:29:29 <rog_> dons: not a proof, just a strong intuition currently. basically, with such a channel, the two sides have to negotiate, but you can't negotiate with another transaction, because each transaction runs atomically.
12:30:12 <dons> mm
12:31:02 * sw17ch wonders if there's any reason json-0.3.3 can't be bumped a version and depend on the newest version of bytestring
12:31:52 <dons> sw17ch: why would it need to?
12:32:00 <dons> btw, a new json is about to be released.
12:32:09 <dons> new fusion/seq paper, http://wwwtcs.inf.tu-dresden.de/~voigt/iandc.pdf "A Family of Syntactic Logical Relations for the Semantics of Haskell-like Languages"
12:32:13 <dons> dcoutts: ^
12:32:21 <lambdabot> Title: A Family of Syntactic Logical Relations for the Semantics of Haskell-like Langua ...
12:32:29 <sw17ch> dons: im' using binary-0.4.3.1 which requires the newest bytestring, and i'm also using json, which requries an older version
12:32:37 <sw17ch> cabal is telling me that it will probably cause a build failure
12:32:41 <SamB_XP> sw17ch: oh, specifically ?
12:32:45 <rog_> when the first party gets there, it has to a) make itself known and b) block until another party comes along. but in STM, to block you have to renounce any changes you've made, which means you can't make yourself known, then block.
12:32:54 <dons> sw17ch: ah, but no. just rebuild json against your new bytestring.
12:33:06 <dons> you just need to ensure they're both built against whichever bytestring you have installed
12:33:16 <dons> they don't "depend" on newest bytestring, just bytestring > 0.9 typically
12:33:22 <sw17ch> dons: i did a cabal install json, and it complained about a missing version
12:33:25 <dons> but you did build it against some particualrly bytestring.
12:33:25 <sw17ch> huh, odd...
12:33:31 <SamB_XP> missing version ?
12:33:33 * sw17ch has some serious problems with his ghc problem
12:33:41 <sw17ch> err..
12:33:42 <SamB_XP> problems with your problem ?
12:33:42 <sw17ch> ghc isntall
12:33:49 * sw17ch has problems with his head too
12:33:50 <ishiro_> > showHex 3 "asd"
12:33:51 <lambdabot>   mueval: Prelude.read: no parse
12:33:52 <msch> hi, is there something like List.unique or do I have to write that myself? This is my first try with Haskell and I didn't find anything in the API doc so please be gentle :)
12:33:56 <dons> nub
12:33:59 <rog_> there might be a cunning way around it, but i don't think so. i'd really like someone to show that i'm wrong!
12:34:04 <dons> > nub [1,2,1,2,3,2,1,1,1]
12:34:05 <SamB_XP> sw17ch: don't take it personally
12:34:05 <lambdabot>   [1,2,3]
12:34:15 <sw17ch> SamB_XP: oh, i won't
12:34:16 <SamB_XP> lots of people mess things up like that
12:34:18 <dons> rog_: i think its a good question/challenge for the haskell-cafe@
12:34:26 <dons> perhaps state what you need in an sync channel
12:34:38 <SamB_XP> and I have a habbit of managing to forget to actually type key words in my sentances ;-)
12:35:07 <ishiro_> why it does not work?
12:35:53 <SamB_XP> @tell gwern PLEASE get rid of this stupid "mueval: Prelude.read: no parse" error message
12:35:53 <lambdabot> Consider it noted.
12:36:06 <dons> > showHex "256"
12:36:07 <lambdabot>       Overlapping instances for Show (String -> String)
12:36:07 <lambdabot>        arising from a...
12:36:10 <dons> > showHex "256" []]
12:36:11 <lambdabot>   mueval: Prelude.read: no parse
12:36:11 <dons> > showHex "256" []
12:36:12 <lambdabot>       No instance for (Integral [Char])
12:36:13 <lambdabot>        arising from a use of `showHex...
12:36:20 <dons> :t showHex
12:36:21 <lambdabot> forall a. (Integral a) => a -> String -> String
12:36:30 <dons> > showHex 255 []
12:36:31 <lambdabot>   mueval: Prelude.read: no parse
12:36:34 <sw17ch> ah, i think i see a cabal install bug :(
12:36:42 <dons> uh? mueval?
12:36:45 <dcoutts> sw17ch: mm?
12:36:45 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:36:52 <dolio> > showHex (255 :: Int) []
12:36:53 <lambdabot>   mueval: Prelude.read: no parse
12:36:55 <sw17ch> dcoutts: --global doesn't get pushed to dependency installs
12:37:01 <rog_> dons: i'll do that. good excuse to subscribe to haskell-cafe, i guess.
12:37:09 <dons> mueval sucks. runplugs rules!
12:37:33 <sw17ch> no, never mind...
12:37:36 <sw17ch> my cabal sucks...
12:37:44 <dolio> > showHex
12:37:45 <lambdabot>       Overlapping instances for Show (a -> String -> String)
12:37:45 <lambdabot>        arising f...
12:37:45 <dcoutts> sw17ch: so what was the problem?
12:37:54 <sw17ch> dcoutts, wait, it still might be a prblem
12:38:01 <sw17ch> dcoutts: sudo cabal install --global json
12:38:06 <sw17ch> i don't have a bytestring installed
12:38:08 <sw17ch> it pulls in the latest
12:38:13 <sw17ch> tries to build it
12:38:27 <sw17ch> and then when it starts json, it fails to build claiming it's missing package bytestring
12:39:09 <sw17ch> bah, but i can't get it to actually follow the --global flag... it always ends up in my .cabal directory :(
12:39:20 <sm> is there a place I can see ghc libraries organized by package ?
12:39:25 <dcoutts> sw17ch: could you hpaste the whole log
12:40:13 <sm> or whatever you call that right column at http://www.haskell.org/ghc/docs/latest/html/libraries/index.html .. base, time, etc.
12:40:14 <lambdabot> Title: Haskell Hierarchical Libraries
12:41:17 <sw17ch> dcoutts: let me get back to you on this...
12:41:26 <sw17ch> i just realized i have a few version of cabal floating around...
12:41:58 <rwbarton> sw17ch: BTW, you may be interested in Rjson, which uses syb-with-class to do JSON serialization.  (It doesn't use the json package)
12:42:20 <rwbarton> sw17ch: I haven't tested it though, just discovered it now
12:42:35 <sw17ch> rwbarton, i think i'm going to json for now, simply b/c i know it and trust dons to maintain it :)
12:43:19 <rwbarton> sw17ch: Yeah.  Also, the whole syb-with-class approach, while ingenious, is massively overkill for this problem, IMHO
12:43:35 <sw17ch> :)
12:44:44 <dons> let's hack ghc and add 'deriving JSON)
12:45:31 <rwbarton> dons: probably I will add something to the derive package
12:48:26 <jeffersonheard> why me???  http://hpaste.org/11011
12:48:49 <sw17ch> dcoutts, my problem was that i had several differnet cabal files floating around, and which one was called depended on my current permissions...
12:49:06 <sw17ch> gentoo had installed an old one, i had upgraded that at some point, and had some how gotten a third
12:49:17 <sw17ch> i've fixed the problem :)
12:49:20 <sw17ch> yay!
12:50:57 <jeffersonheard> nm I found it
12:53:56 <dcoutts> sw17ch: so the problem was that doing sudo cabal install was using a different version of the Cabal lib ?
12:54:13 <dcoutts> sw17ch: what would have helped avoid the problem or have made it easier to diagnose?
12:54:39 <dcoutts> sw17ch: I'm rather of the opinion that we should not be encouraging sudo but instead cabal install --global --root-cmd=sudo
12:54:50 <gbacon> dcoutts: I was able to install lambdabot by installing it to --user
12:55:00 <dcoutts> because running the whole thing via sudo changes the environment so much
12:55:01 <gbacon> dcoutts: but runplugs is broken :-(
12:55:16 <dcoutts> gbacon: ok great, I can't help with runplugs though
12:55:22 <gbacon> dcoutts: thanks for your help
12:55:35 <dcoutts> gbacon: so do you know what was wrong with the global installs?
12:56:01 <dcoutts> gbacon: just the general problem of finding sane sets of deps between several devel packages ?
12:56:09 <gbacon> dcoutts: when I was running cabal install lambdabot-utils, I was in the darcs WC (which has a lambdabot-utils subdirectory)
12:56:28 <dcoutts> gbacon: that shouldn't have mattered, it doesn't look into subdirs for other .cabal files
12:57:00 <gbacon> dcoutts: no clue then
12:57:02 <dcoutts> gbacon: so I'd still be interested in a log of what was going on there
12:57:26 <gbacon> dcoutts: what would you like to see?
12:59:23 <sw17ch> dcoutts: my path and root's path variables don't match, and are in different orders
12:59:31 <sw17ch> so the sudo ... would pick a different cabal
12:59:45 <sw17ch> in this case, ti's mostly that i wanted to run a newer version than gentoo gave me
12:59:48 <sw17ch> and didn't remove the older one
13:00:19 <sw17ch> oh, and in the --global repository, i had an older version of Cabal than i had in --user
13:03:14 <gbacon> dcoutts: weird, so cabal install --global lambdabot-utils fails, but cabal install --global lambdabot succeeds
13:06:34 <dcoutts> gbacon: right, so a log of what you get when you try: cabal install --global lambdabot-utils -v
13:06:42 <dcoutts> gbacon: note the -v there
13:07:15 <gbacon> dcoutts: you want the log from ~/.cabal/log or just the command's output to the terminal?
13:07:31 <dcoutts> gbacon: just the command's output to the terminal
13:09:18 <dons> "Typing "haskell desktop wallpaper" yeilded
13:09:18 <dons> a lot of links to wallpapers with Colleen Haskell, while she's a
13:09:19 <dons> beautiful lady it wasn't exactly what I was hoping to find."
13:09:20 <dons> hehe
13:10:22 <msch> can someone tell me if there's a shorthand for lambdas with only one parameter?
13:10:23 <dons> Subject: ANNOUNCE: GHC 6.10.1 RC 1
13:10:37 <dons> msch: no shorthand
13:10:41 <msch> dons: thanks
13:10:48 <gbacon> dcoutts: email or hpaste?
13:10:49 <dons> there's shorthand for lambdas with multiple paramaters,
13:11:02 <dons> namely, instead of \x -> \y -> x + y   we can write \x y -> x + y
13:12:20 <dcoutts> gbacon: either, hpaste is probably easier
13:12:55 <dons> http://www.haskell.org/pipermail/glasgow-haskell-users/2008-October/015691.html
13:12:57 <lambdabot> Title: ANNOUNCE: GHC 6.10.1 RC 1, http://tinyurl.com/44u36m
13:14:56 <gbacon> dcoutts: http://hpaste.org/11012
13:16:05 <gbacon> dcoutts: argh, looks like it chopped the input :-(
13:16:49 <dcoutts> gbacon: you can add further sections to the same paste, it's 5k each
13:17:04 <dcoutts> gbacon: so it's deciding to install lambdabot-utils-0.4.1
13:17:11 <dcoutts> erm 4.1
13:17:31 <dcoutts> gbacon: use the annotate link
13:18:56 <gbacon> dcoutts: done
13:20:14 <dcoutts> gbacon: ah, so that's not the weird error about "dependencies conflict: lambdabot-utils-4.2 requires mtl ... etc
13:20:25 <dcoutts> gbacon: that's just the regex libs being useless
13:20:58 <gbacon> dcoutts: yeah, I unregistered lambdabot-utils-4.2
13:21:56 <dcoutts> gbacon: so I'm interested in when cabal-install's dep planning messes up, I don't mind if packages don't build :-) (unless it's my fault)
13:22:20 <dons> get testing the RC guys http://www.haskell.org/ghc/dist/stable/dist/6.10.1-rc-1/rc.html
13:22:20 <lambdabot> Title: GHC 6.10.1 RC 1
13:22:55 <rwbarton> msch: you might be looking for this kind of shorthand?
13:23:00 <rwbarton> @pl \x -> 5 + x
13:23:00 <lambdabot> (5 +)
13:24:12 <msch> well i know about that shorthand, but I wanted to construct a tuple like \x -> (x, x *2) and all the x seemed redundant
13:24:35 <jeffersonheard> How do I properly close a Gtk.Dialog when the user clicks Ok/Cancel?
13:24:47 <jeffersonheard> in the onResponse?
13:26:14 <dcoutts> jeffersonheard: hide or destroy the window
13:26:32 <dcoutts> jeffersonheard: or if you're using runDialog then that happens automagically
13:26:41 <rwbarton> msch: You can use the &&& combinator from Control.Arrow:  Prelude Control.Arrow> (id &&& (*2)) 3
13:26:45 <rwbarton> (3,6)
13:26:55 <jeffersonheard> I am using runDialog, and it's not happening.  That's what I thought was the expected behaviour
13:28:01 <Deewiant> msch: or alternatively ap (,) (*2) or (,) <*> (*2), I prefer &&& myself though
13:28:06 <jeffersonheard> I created the dialogs in Glade, but didn't add buttons, using the dialogAddButton function instead
13:28:47 <nominolo_> is there a way to delete pages on the haskellwiki (spam)
13:28:48 <msch> rwbarton: wow, that's impressive. I'm not sure if I should use that though, since I don't understand how it works.
13:29:31 <Deewiant> msch: in that case (it's generalized but you don't need to worry about that) it's just "(f &&& g) x = (f x, g x)"
13:30:30 <rwbarton> &&& is specialized to building pairs.  You can use ap or <*> more generally.  lambdabot will do this for you, although the results are usually less readable than what you started with.
13:30:37 <rwbarton> @pl \x -> (x, x*2)
13:30:37 <lambdabot> ap (,) (2 *)
13:31:19 <rwbarton> (lambdabot also thinks that x*2==2*x)
13:31:38 <msch> rwbarton, Deewiant: I see. Thank you very much.
13:32:09 <Deewiant> rwbarton: that's one of the Num laws ;-)
13:32:40 <rwbarton> There are Num laws?
13:33:43 <rwbarton> I mean, I don't disagree in this case :) but I've never seen laws for Num written down.
13:33:44 <Deewiant> I think it's somewhat implicit that Num is a ring
13:33:48 <gbacon> dcoutts: reproduced it: http://hpaste.org/11013
13:33:55 <Deewiant> but no, there are no real laws, it was more a joke :-)
13:34:42 <msch> another question: <*> is an operator imported from Control.Arrow or is it built in?
13:34:47 <rwbarton> The only law I can see written down is  abs x * signum x == x  and I never satisfy that one because the LHS is undefined :)
13:35:03 <rwbarton> <*> is from Control.Applicative
13:35:03 <Deewiant> ?index (<*>)
13:35:03 <lambdabot> bzzt
13:35:06 <Deewiant> meh
13:35:26 <Deewiant> msch: and ap is from Control.Monad
13:36:27 <msch> ok, i think i'll ignore these for a few more weeks. But I like &&&
13:37:23 <dcoutts> gbacon: thanks, mm that is odd. And that's using an unchanged lambdabot-utils.cabal right? from the darcs version
13:37:35 <gbacon> dcoutts: correct
13:37:48 <dcoutts> gbacon: thanks, I'll see if I can reproduce that
13:38:40 <gbacon> dcoutts: same error if I run cabal install from the lambdabot directory too
13:39:20 <dcoutts> gbacon: I'm guessing you've got those two versions of bytestring installed right?
13:39:35 <dcoutts> gbacon: because the .cabal file doesn't mention any particular version of bytestring at all
13:39:57 <gbacon> dcoutts: yes, both are present according to ghc-pkg
13:40:59 <dcoutts> gbacon: can you paste ghc-pkg field lambdabot-utils depends
13:41:30 <dblazakis> rog_: did you ever come up with a solution to your issue?
13:42:18 <gbacon> dcoutts: annotated
13:44:14 <dcoutts> gbacon: thanks, ah so we have two versions of lambdabot-utils installed, presumably 4.1 and 4.2
13:44:40 <gbacon> dcoutts: correct: 4.1 in global and 4.2 in user
13:51:49 <rog_> dblazakis: which issue was that?
13:52:41 <rog_> dblazakis: (i've quite a few issues :-))
13:53:50 <rog_> dblazakis: (and i've resolved a few too)
13:56:20 <dblazakis> rog_: getting a lazy function to matched that signature
13:58:49 <hackage> Uploaded to hackage: CouchDB 0.8.0.4
13:59:01 <sw17ch> oooooo.... CouchDB :D
14:01:02 * gbacon &
14:12:55 <jdrake> How can I use cabal with ghc and not have it install into ~/.cabal?
14:13:13 <geezusfreeek> jdrake, use the --global flag
14:13:38 <jdrake> geezusfreeek, can I have that done by default?
14:13:51 <geezusfreeek> i believe you can, but i do not know how
14:14:02 <geezusfreeek> you only have to use it on the configure step
14:14:30 <geezusfreeek> well, or if you are installing specific packages
14:14:39 <geezusfreeek> via hackage, i mean
14:15:58 <Saizan> jdrake: in  ~/.cabal/config set userInstall: False
14:16:45 <jdrake> Saizan, now if I happen to have installed packages already, can I just reinstall them and have it do it globally?
14:18:23 <Saizan> jdrake: yup
14:24:09 <jdrake> It appears it installed some things in /usr/local/lib. How can I get ghc to search there?
14:24:37 <rog_> dblazakis: it's not possible
14:25:40 <dcoutts> jdrake: it registers them in the global package db, so ghc knows where they are. Use ghc-pkg list to see what is registered
14:26:02 <dblazakis> rog_: ah, oh well
14:26:57 <jdrake> ok, it lists  Crypto-4.1.0 but when I do import Crypto it can't find anything
14:27:34 <rwbarton> jdrake: you need to import a module, not a package
14:29:31 <mohbana> hi, what's a (excellent) free ebook for learning haskell?
14:30:16 <ddarius> Depends on what you want, but Real World Haskell would be the current favorite.
14:30:25 <ddarius> There's also the wikibook and YAHT.
14:30:56 <mohbana> no i mean something available as a pdf, if such a thing exists
14:31:10 <ddarius> YAHT is available as a PDF
14:32:19 <Saizan> rog_: you had a problem writing send for the synchronous channels?
14:37:22 <mofmog> > 3*2
14:37:23 <lambdabot>   6
14:37:36 <mofmog> > foldl (*) 1 [3.0..365.0]
14:37:37 <lambdabot>   Infinity
14:37:50 <mofmog> > foldl (*) 1 [3..365]
14:37:52 <lambdabot>   125520643377793661464647218744060138525827601349380398834362975969505530691...
14:37:55 <mofmog> ?????????
14:37:59 <BONUS_> what the heck
14:38:12 <mofmog> i was trying to model the birthday paradox
14:38:13 <dons> Double/Integer
14:38:23 <mofmog> dons: yeah
14:38:30 <dons> > product [3..365]
14:38:31 <lambdabot>   125520643377793661464647218744060138525827601349380398834362975969505530691...
14:38:33 <lament> it's a big number
14:38:39 <dons> > product [3..365.0]
14:38:40 <lambdabot>   Infinity
14:38:48 <dons> > product [3..(365.0::CReal)]
14:38:57 <dons> no go.
14:39:03 <lambdabot>   thread killed
14:39:24 <lament> > length . show $ product [3..365]
14:39:25 <mofmog> i need to do 365!/(m!*365^m)
14:39:25 <lambdabot>   779
14:39:33 <dblazakis> > length . show $ foldl (*) 1 [3..365]
14:39:35 <lambdabot>   779
14:39:49 <dblazakis> lament: :)
14:39:57 <ziman> is there a way to make readline work with utf-8? i can't find anything in the doc and google doesn't give many useful links
14:41:13 <mofmog> > product [3..365] / 4
14:41:15 <lambdabot>   Infinity
14:41:26 <mofmog> > product [3..365]
14:41:27 <lambdabot>   125520643377793661464647218744060138525827601349380398834362975969505530691...
14:41:33 <ziman> > product [3..365] `div` 4
14:41:34 <lambdabot>   313801608444484153661618046860150346314569003373450997085907439923763826727...
14:41:42 <mofmog> but i dont exactly want div
14:41:57 <int-e> > product [3..365] / 4 :: CReal
14:42:12 <lambdabot>   thread killed
14:42:31 <int-e> > 3 * product [5..365]
14:42:33 <lambdabot>   313801608444484153661618046860150346314569003373450997085907439923763826727...
14:42:33 <ziman> > 3*product [5..365]
14:42:35 <lambdabot>   313801608444484153661618046860150346314569003373450997085907439923763826727...
14:42:36 <int-e> haha
14:42:44 <ziman> :)
14:43:03 <mofmog> oh haskell, handle large numbers better
14:43:20 <lament> it's not haskell's fault
14:43:42 <mofmog> oh finite bit computers, handle large numbers better
14:43:51 <int-e> > sum [log n | n <- [3..365]] / log 10
14:43:53 <lambdabot>   778.0987151566367
14:44:00 <rog_> Saizan: i don't think it's possible using STM, although i haven't managed to actually prove it yet.
14:44:07 <bbs> > let allTrue lis = foldr (&&) True ; let lis = [True, False, True]
14:44:08 <lambdabot>   mueval: Prelude.read: no parse
14:44:08 <int-e> > sum [log n | n <- [3..365]] / log 2 -- binary log is more relevant, I guess
14:44:10 <lambdabot>   2584.787982474591
14:44:27 <bbs> > allTrue lis = foldr (&&) True ; let lis = [True, False, True]
14:44:27 <dblazakis> @pl foldr (>>)
14:44:28 <lambdabot> foldr (>>)
14:44:28 <lambdabot>   mueval: Prelude.read: no parse
14:44:35 <int-e> which is larger than 2048, so Double won't work.
14:44:40 <bbs> @kill bbs
14:44:40 <lambdabot> Maybe you meant: keal kind tell
14:44:47 <bbs> @slap bbs
14:44:47 * lambdabot moulds bbs into a delicous cookie, and places it in her oven
14:44:59 <bbs> @bitchslap bbs
14:45:00 <lambdabot> Unknown command, try @list
14:45:37 <ziman> @slay bbs
14:45:37 * lambdabot karate-chops bbs into two equally sized halves
14:45:59 <Saizan> rog_: a solution might be to use two atomically in send, one that puts the value and the other that waits, it should still allow for alt on the receiver side
14:46:12 <int-e> @. elite slap int-e
14:46:12 <lambdabot> /M3 5MAcx$ In+-E 4bou7 wi+|-| 4 |4RgE TroUT
14:46:26 <ddarius> Interesting.
14:47:36 <rog_> Saizan: i can't see how it could work, as if you're waiting, you can't have put the value in (because of the semantics of retry)
14:48:00 <rog_> Saizan: or perhaps i've misunderstood
14:49:09 <Saizan> rog_: something like: (atomically (writeTMVar chan value) >> atomically (readTMVar lock)) :: IO ()
14:50:00 <rog_> Saizan: but then you can't have channel ops as part of STM, which would be really nice.
14:51:35 <rog_> Saizan: so in that case, you might as well just use MVars...
14:51:38 <Saizan> rog_: well, your send is clearly not an atomical operation
14:51:56 <Saizan> rog_: with MVars you've to fork threads if you want to wait on multiple channels
14:52:39 <rog_> Saizan: that's a pity.
14:53:34 <rog_> Saizan: but it's probably get-around-able, by using a single MVar to mediate several others.
14:54:17 <Saizan> rog_: i would still find it easier with STM
14:55:41 <rog_> Saizan: yeah, it's probably better than using MVars as locks.
14:57:21 <rog_> Saizan: but sadly i wouldn't get alt for free, orElse only working in STM as it does.
14:58:10 <rog_> Saizan: but maybe i am wrong; maybe there *is* a cunning way of doing synchronous channels in STM...
14:58:49 <hackage> Uploaded to hackage: hmpfr 0.1.2
14:59:25 <TomMD> @hackage hmpfr
14:59:26 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hmpfr
14:59:41 <TomMD> hackage bot should provide a url too.
14:59:48 <TomMD> or a synopsis.
15:02:27 <marko1> hi all
15:02:32 <Cale> hello!
15:03:01 <marko1> does anyone know of good examples for takusen aside from the tests?
15:06:05 <TomMD> Can't say.  I've only used haskellDB
15:15:53 <Saizan> rog_: even if send is IO, i think recv can be in STM? recv is an atomical operation
15:20:53 <inad922> hello
15:21:47 <TomMD> hello inad922
15:23:02 <inad922> Im getting the command line arguments with getArgs and its not bad since I want to give list to my haskell program but the function which I call it with doesnt accept it as a list so my question is that how Can I convert a string to a list?
15:23:07 <inad922> hello TomMD
15:24:04 <dons> hey TomMD.
15:24:07 <TomMD> inad922: I'm not sure what you are wanting.  A string is a list:  type String = [Char].
15:24:17 <TomMD> hello dons, how are things?
15:24:34 <inad922> its actually a list of numbers
15:24:36 <dons> pretty good. the rain starting in portland though :)
15:24:44 <inad922> and I want to compare them as numbers
15:24:49 <dons> TomMD: dcoutts is visiting, so we're doing some haxoring
15:24:53 <inad922> in the function to which it is passed
15:24:56 <TomMD> inad922: You want 'read'
15:24:58 <bbs> @help assocs
15:24:58 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:25:02 <bbs> @list
15:25:02 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:25:13 <bbs> :t assocs
15:25:14 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)]
15:25:19 <TomMD> ?type return . (map read) =<< getArgs
15:25:19 <bbs> hmm
15:25:20 <lambdabot> Not in scope: `getArgs'
15:25:52 <TomMD> dons: Yes, I saw Coutts gave a presentation at Galois recently.  All this work on Cabal excludes hackage-server!
15:26:10 <TomMD> Not that it isn't welcome news ;-)
15:26:34 <dons> ah. but there is also hackage-server
15:26:48 <dons> we'll probably hack on that during the darcs hackathon too, in 2 weeks
15:26:58 <dons> he did a hackage server demo at ICFP, as well.
15:27:09 <dons> we had people doing build reports live in the audience, during the talk :)
15:27:18 <TomMD> Nice!
15:27:38 <dons> so sometime after the 6.10 release, we'll start testing the haskell platform set against the new hackage sever
15:27:42 <TomMD> I setup hackage-server in the office before I left, but the lack of DNS caused issues, so it isn't used for now.
15:27:44 <dons> then move over to the new hackage
15:27:53 <dons> oh, nice. good to know.
15:30:25 <TomMD> dons: If you have heard of the DNS issue, do you know where it will finally get fixed?  Hartman thinks of it as a Network library bug while I consider it HaPPS, but its really a matter of opinion.
15:30:47 <dons> yeah, i was following.
15:31:09 <dons> we need to work out who's job it is
15:32:45 <Cale> (return . f) =<< x is the same as  fmap f x
15:33:04 <Cale> so that's  fmap (map read) getArgs
15:33:56 <Cale> Or of course, you can just use getArgs to get a list of strings, and then apply map read to them when you go to pass them to whatever function you're passing them to.
15:34:27 <bbs> hey how do i load Array?
15:34:41 <bbs> so i can access the assocs function
15:34:42 <Cale> In your module, or in ghci?
15:34:47 <bbs> in ghci
15:34:53 <Cale> :m + Array
15:34:53 <bbs> its _dontpanic_ btw
15:34:56 <Cale> or
15:34:59 <Cale> :m + Data.Array
15:35:01 <bbs> :l Data.Araay
15:35:06 <bbs> i tried that :/
15:35:33 <Cale> Yeah, :l is for loading modules that you have in source form.
15:35:47 <Cale> (and it replaces whatever other module is loaded)
15:36:03 <Cale> :m +  will add modules to the current scope
15:36:20 <Cale> (and you don't need to have their source code, so long as they're in some package on your system)
15:36:47 <bbs> Cale: do i need to import it
15:36:51 <bbs> into my module
15:36:59 <Cale> If you want to use it in that module, yes
15:37:06 <bbs> how do i do that?
15:37:08 <Cale> import Data.Array
15:37:10 <bbs> sry -- i'm brand new to haskel
15:37:14 <Cale> That's okay :)
15:37:43 <bbs> :)
15:37:47 <bbs> Cale: something else
15:37:51 <bbs> i don't mean to ask for homeowrk help
15:37:56 <bbs> but this teacher is a fscking robot
15:38:02 <bbs> and i've been after this solution for hours
15:38:03 <Cale> hehe
15:38:07 <bbs> can i post you what i have
15:38:12 <Cale> sure
15:38:28 <bbs> Your paste can be seen here: http://zlin.dk/p/?ZGY5NGY3
15:38:30 <bbs> thats what i have
15:39:04 <Cale> Be careful that Haskell is case-sensitive.
15:39:18 <Cale> (that should be 'import', not 'IMport')
15:39:38 <bbs> 2.1. Transforming quilt blocks
15:39:39 <bbs> Once you have the symmetry operations that transform lists of lists, there is one additional complication to handle. Only characters with some symmetry properties of their own lend themselves to such transformations. The letter o is simple; all transformations leave it unchanged. A quarter-turn, however, changes / into \ (ideally). Let us restrict our quilt character set to the following < > ^ v / \ o * x + | -. If we idealize them so that all angles are 45 o
15:39:47 <bbs> ffs
15:39:50 <bbs> sorry!
15:40:06 <vinicius_> isn't that from a perl blogpost or something?
15:40:12 <bbs> http://hpaste.org/11015
15:40:15 <bbs> Cale: ^
15:40:17 <bbs> vinicius_: ?
15:40:43 <vinicius_> the quilt thing
15:40:48 <bbs> vinicius_: no idea
15:40:52 <bbs> its possible the teacher stole it
15:40:54 <bbs> not sure though
15:41:07 <bbs> i'm just trying to do it legit and everyone is cheating :/
15:41:16 <bbs> i just really wanna know how to program haskell
15:41:30 <Cale> bbs: okay
15:42:11 <Cale> bbs: While you could use the Array library for something, it's probably easier just to stick to lists at first, unless you have a good reason.
15:42:39 <bbs> Cale: i mean -- its exactly how he set it up afaikt
15:43:20 <bbs> i just don't know how when i rotate to properly associate say "<" with "^" after a 90-degree clockwise
15:43:24 <Cale> Nothing in the assignment problem at least suggests to me that an array is needed.
15:43:24 <bbs> i mean all of my rotates work
15:43:27 <Cale> okay
15:43:50 <bbs> ok so do i need a few lists?
15:43:56 <bbs> like updater functions
15:44:03 <bbs> that have tuples for each
15:44:05 <Cale> So, he suggests writing a function which takes an element, and a list of pairs, and tries to find a pair in that list whose first part matches the element
15:44:15 <Cale> and in that case, returns the second part of the pair
15:44:43 <bbs> Cale: ok -- so i *do* have to do so many
15:45:01 <Cale> There is a function in the Prelude which does this.
15:45:11 <Cale> But it sounds like he wants you to write it.
15:45:38 <Cale> > lookup '^' [('>', 'v'), ('v','<'), ('<','^'),('^','>')]
15:45:39 <lambdabot>   Just '>'
15:45:40 <bbs> Cale: he wont care.
15:46:00 <lispy> here is a hint: Eq a => [(a, b)] -> a -> Maybe b, is one possible type
15:46:04 <Cale> It's a good little exercise anyway :)
15:46:05 <bbs> he gives extra points if you go beyond regular means (i.e. just pissing him off)
15:46:11 <bbs> Cale: ok :)
15:47:58 <bbs> Cale: ok so i guess i can just go from there!
15:48:08 <bbs> Cale: do you mind if i bother you later if i get stuck again?
15:48:11 <Cale> bbs: Of course, you could also just write a function by hand which makes the appropriate transformations of characters, but this approach of going via an association list makes the code cleaner.
15:48:15 <Cale> I don't mind at all.
15:48:21 <bbs> what does yoru /etc/localtime say ;p
15:48:27 <Cale> and if I'm not around, you should feel free to ask here
15:48:38 <bbs> Cale: ok :) thanks
15:48:43 <Cale> There are usually people around who are willing to help :)
15:49:06 <bbs> ok
15:49:07 <bbs> thanks
15:49:14 <bbs> i'm going to go work on this
15:49:15 <Cale> Yeah, no problem :)
15:49:20 <bbs> bbl
15:49:22 * bbs waves
15:49:24 <Cale> okay :)
15:49:29 <lispy> you don't want to know what /etc/localtime says here
15:49:40 <leimy> GMT?
15:49:41 <lispy> really strange characters
15:49:55 <lispy> I'll paste jus the first line
15:50:02 <lispy> TZif???H??????*?????ˉ??#?p?a&??t ؀????Ѡ????޳?ݩ??޾??߉????w??ip??~Y??IR??^;??)4??
15:50:12 <leimy> ah of course
15:50:22 <rwbarton> ls -l /etc/localtime may be more informative
15:50:24 <leimy> needs some lambdas
15:50:34 <rwbarton> Or not... I thought it was usually a symlink
15:50:46 <lispy> rwbarton: very much more informative
15:50:59 <lispy>  /etc/localtime@ -> /usr/share/zoneinfo/US/Pacific
15:51:09 <Cale> cale@zaphod:~$ file /etc/localtime
15:51:09 <Cale> /etc/localtime: timezone data
15:51:09 <rwbarton> Ah, mine isn't a symlink for some reason.
15:51:11 <Cale> hmm
15:51:37 <lispy> Cale: same thing here
15:51:55 <marko1> I asked before, but maybe someone has an answer now:
15:51:59 <rwbarton> Right, it's a zoneinfo file.  I think it knows when daylight savings time starts and ends, and so on
15:52:13 <marko1> does someone have a pointer to good examples on takusen>
15:52:15 <marko1> ??
15:52:38 <lispy> ?faq is there a tutorial on takusen?
15:52:38 <lambdabot> The answer is: Yes! Haskell can do that.
15:56:56 <eyeris> Where can I find the documentation for whatever is replacing ByteString.findSubstring? http://hpaste.org/11016
15:57:45 <BMeph> leimy: MOAR LABMDAS, k thxbai!
15:57:57 <leimy> werd
15:58:31 <Cale> eyeris: I would start with the Data.ByteString docs... I'll have a look too :)
15:59:16 <eyeris> It's defnitely not under the "Searching ByteStrings" section.
15:59:45 <Cale> hmm
16:00:15 <guille_> hi
16:00:24 <TomMD> eyeris, Cale: Isn't there a ByteString regex lib that can do this?
16:01:12 <lispy> TomMD: oh, if there isn't already there certainly should be.  I could see that being a nice thing to have.
16:01:38 <lispy> Not because I'm a huge fan of regular expressions, but because well, they do seem to be handy at times
16:02:04 <TomMD> lispy, eyeris: Yep, PCRE bindings work on bytestrings, so we are saved for now.
16:02:51 <eyeris> TomMD: Are those in the standard libraries
16:02:52 <eyeris> ?
16:02:57 <leimy> anyone got a good permute for bytestring?
16:03:10 <leimy> My solution was to permute stuff before packing it :-)
16:03:18 <leimy> which is crappy :-)
16:03:41 <TomMD> eyeris: "Standard" meaning distributed with ghc?  No.  But you can get that from hackage.
16:05:14 <eyeris> The reason I am asking is to determine whether the BS RE api you are talking about is the same replacement mentioned in that deprecation message
16:05:23 <TomMD> eyeris: Is 'findSubStrings' (note the plural) also depricated?
16:05:33 <eyeris> If it isn't distributed with (at least the devel version of) GHC, then it's not likely
16:06:52 <jdrake> When I do this in ghci: import SHA512, I get this: module main:SHA512 is not loaded  There is an SHA512.hs in cwd.
16:07:47 <byorgey> jdrake: try :load instead of import
16:07:52 <lispy> or :l for short
16:07:54 <lispy> hey byorgey
16:07:56 <lispy> TomMD: yay!
16:07:58 <byorgey> hey lispy!
16:08:00 <jdrake> ok, that worked
16:08:31 <byorgey> jdrake: import (or :m +) is only for modules that are installed in the ghc package library
16:08:40 <byorgey> i.e. that show up in the output of ghc-pkg list
16:09:01 <lispy> byorgey: Has school been keeping you pretty busy?
16:09:08 <byorgey> lispy: indeed it has =)
16:09:24 <TomMD> byorgey: Interesting.  The only time I've had :m not work is when I had said module in my path and installed as part of a package at the same time.
16:09:35 <byorgey> lispy: I did get your email though, and was planning to respond soon
16:09:41 <TomMD> byorgey: Remember, we expect great things.
16:09:48 <TomMD> And papers.... and code!
16:09:52 <byorgey> TomMD: ah, actually, I think you're right, I've had that same issue.
16:09:58 <byorgey> TomMD: I'm working on it!
16:10:00 <TomMD> Had fun with your new language?
16:10:03 <lispy> byorgey: no, hurry.  I think I'll be busy till probably early December
16:10:35 <byorgey> lispy: ok.  December/January might be a good time for me too (between semesters)
16:11:01 <byorgey> lispy: I've definitely thought about your idea, though.  I found myself wanting it the other day =)
16:11:21 <lispy> byorgey: yup, and I'm sure new students would like it if we make it accessible enough
16:11:32 <byorgey> lispy: indeed.
16:12:10 <byorgey> TomMD: well, any hypothetical new languages are still quite a ways off.  But I have had fun reading lots of papers so I can get to the point where it would even be possible for me to think about designing new languages. =)
16:12:25 <Saizan> rog_: http://hpaste.org/11018
16:13:51 <lispy> I've been reading about denotational semantics, codata, normalization and dependent types lately.  Boy, there is a lot of cool stuff out there.
16:14:12 <lispy> It's sad that it's all fringe and esoteric to the mainstream CS community
16:14:53 <dons> lispy: that abstract going to land on my desk tomorrow morning? :)
16:15:03 <lispy> dons: yes!
16:15:07 <dons> woot!
16:15:08 <lispy> dons: by morning, good sir!
16:15:15 <dons> jolly good.
16:17:00 <BONUS_> haha is dons lispy's professor or what
16:17:31 <byorgey> lispy: sounds neat!
16:17:43 <lispy> BONUS_: actually, just giving a talk where dons works soon :)
16:17:51 <byorgey> I'd like to read about denotational semantics at some point
16:17:52 <BONUS_> ah, cool
16:18:19 <byorgey> Penn (and the larger PL community) seems to be big on operational semantics at present
16:18:44 <lispy> byorgey: denotational semantics seems to be pretty simple.  You just denote what something means.  Like, 2 * 3 = 6, so that is the denotational semantics of 2 times 3, as I understand it.
16:19:24 <BONUS_> is f _|_ = _|_ or what
16:19:25 <byorgey> lispy: yup, you map syntactic terms in your language into a suitable mathematical domain of values.
16:19:27 <ziman> @hoogle [Bool] -> Bool
16:19:28 <lambdabot> Prelude and :: [Bool] -> Bool
16:19:28 <lambdabot> Prelude or :: [Bool] -> Bool
16:19:28 <lambdabot> Data.List and :: [Bool] -> Bool
16:19:40 <byorgey> I know the basic idea but none of the more interesting stuff.
16:19:45 <BONUS_> im still kind of dealing with how exactly _|_ works
16:20:03 <byorgey> BONUS_: f _|_ = _|_  if and only if f is strict
16:20:12 <byorgey> BONUS_: in fact, that's the definition of strictness
16:20:17 <lispy> byorgey: the book I'm reading lept from denotational semantics to natural deduction and that was the stuff that lost me.  I needed more examples
16:20:19 <BONUS_> aha
16:20:22 <BONUS_> and if f is lazy?
16:20:46 <lispy> > let f _ = 1 in f 3
16:20:47 <lambdabot>   1
16:20:48 <byorgey> BONUS_: if f is lazy, it might ignore its input.
16:21:01 <lispy> > let f _ = 1 in f undefined
16:21:02 <lambdabot>   1
16:21:05 <BONUS_> aha
16:21:05 <rwbarton> Anyone know what data structure yi uses for its text buffers?  (Data.Seq maybe?)
16:21:12 <byorgey> BONUS_: so even if its input is _|_, if f never tries to evaluate it, it can still return a non-_|_ value
16:21:22 <BONUS_> but if the _|_ needs to be evaluated, the result will be _|_?
16:21:24 <byorgey> as lispy has demonstrated
16:21:28 <byorgey> BONUS_: right.
16:21:38 <BONUS_> aha,kewl
16:21:46 <byorgey> _|_ represents computations which do not terminate (or give an error)
16:22:07 <lispy> :t undefined
16:22:09 <lambdabot> forall a. a
16:22:13 <byorgey> lispy: what book?
16:22:18 <lispy> byorgey: just a sec
16:22:23 <BONUS_> hmm yase
16:22:36 <byorgey> yase?
16:22:40 <BONUS_> i mean yes
16:22:45 <byorgey> hehe, ok =)
16:22:47 <TomMD> byorgey: Do any paper recommendations come to mind right now?  I could alwasy use more reading material to prep for Spring.
16:22:58 <eyeris> I am having trouble understanding how to get Nothing to thread through my code. Help? http://hpaste.org/11019
16:23:05 <byorgey> TomMD: I have plenty.  anything in particular you're interested in reading about?
16:23:33 <BONUS_> use Maybe as a monad
16:24:04 <lispy> byorgey: http://www.paultaylor.eu/stable/Proofs%2BTypes.html
16:24:06 <lambdabot> Title: Proofs and Types
16:24:07 <BONUS_> > do {a <- Just 2; b <- Just "haha"; c <- Just 9; return show a ++ b ++ show c}
16:24:08 <lambdabot>   Couldn't match expected type `[a]'
16:24:14 <byorgey> thanks lispy
16:24:27 <BONUS_> ugh
16:24:52 <lispy> byorgey: I'm reading it because I want to learn more about System F
16:24:57 <TomMD> byorgey: Safty, correctness, and constrained environments (embedded).
16:25:03 <BONUS_> > do {a <- Just 2; b <- Just "haha"; c <- Just 9; return $ show a : b ++ show c}
16:25:04 <lambdabot>   Couldn't match expected type `String' against inferred type `Char'
16:25:12 <BONUS_> > do {a <- Just 2; b <- Just "haha"; c <- Just 9; return $ show a ++ b ++ show c}
16:25:12 <Saizan> > do {a <- Just 2; b <- Just "haha"; c <- Just 9; return $ show a ++ b ++ show c}
16:25:13 <BONUS_> this
16:25:13 <lispy> byorgey: I think I've studied natural debuction before, but I've completely forgotten how it works :)
16:25:13 <lambdabot>   Just "2haha9"
16:25:13 <lambdabot>  Terminated
16:25:18 <BONUS_> sorry guys
16:25:24 <BONUS_> > do {a <- Just 2; b <- Just "haha"; c <- Nothing; return $ show a ++ b ++ show c}
16:25:26 <lambdabot>   Nothing
16:27:15 <newsham> > liftM3 (\a b c -> a ++ b ++ show c) (Just 2) (Just "haha") (Just 9)
16:27:16 <lambdabot>       No instance for (Num [Char])
16:27:16 <lambdabot>        arising from the literal `2' at <in...
16:27:27 <newsham> > liftM3 (\a b c -> show a ++ b ++ show c) (Just 2) (Just "haha") (Just 9)
16:27:29 <lambdabot>   Just "2haha9"
16:27:46 <eyeris>  > liftM3 (\a b c -> show a ++ b ++ show c) (Just 2) (Just "haha") (Nothing)
16:27:50 <newsham> > (\a b c -> show a ++ b ++ show c) <$> Just 2 <*> Just "haha" <*> Just 9
16:27:53 <lambdabot>   Just "2haha9"
16:27:55 <eyeris> > liftM3 (\a b c -> show a ++ b ++ show c) (Just 2) (Just "haha") (Nothing)
16:27:56 <lambdabot>   Nothing
16:28:02 <BONUS_> anyway, do notation seems perfect for that use
16:28:40 <eyeris> So my real problem is that my data constructor isn't in Maybe?
16:29:42 <rwbarton> eyeris: ColumnIndexes <$> find "Variable" <*> find "Roster" <*> ... where find s = S.findSubstring (S.pack s) line
16:30:08 <BONUS_> eyeris: t.com) has joined #haskell
16:30:08 <BONUS_> <newsham> > (\a b c -> show a ++ b ++ show
16:30:09 <BONUS_> whoops
16:30:14 <BONUS_> http://hpaste.org/11019#a1
16:30:15 <BONUS_> this
16:30:46 <BONUS_> im assuming S.findSubstring returns a Maybe value
16:32:13 <eyeris> rwbarton Thanks. I don't know about Control.Applicative and, from my brief look at it, it's over my head right now. I will come back to it later though.
16:32:25 <rwbarton> (This almost seems like a valid application for the Apply type class that lets you apply a function that takes many arguments of the same type to a list.)
16:32:31 <eyeris> BONUS_ I see. Thanks. I forget to use do when I use non-IO monads
16:32:39 <BONUS_> hehe
16:32:45 <BONUS_> do comes in handy sometimes with Maybe yeah
16:32:54 <BONUS_> and a lot of time with State and co.
16:33:06 <newsham> eyeris:   f <$> a <*> b <*> c     ==  liftM3 f a b c
16:33:13 <eyeris> Right. It should have been obvious to me when I used "thread" in my question.
16:33:18 <paczesiowa> is there a monad that doesn't like do notation?
16:33:34 <BONUS_> i usually use list comprehensions with list
16:33:52 <byorgey> paczesiowa: no.
16:34:04 <paczesiowa> I prefer maps and filters, but yeah list monad is weird
16:34:05 <rwbarton> Obviously it depends on what "like" means :)
16:34:22 <Pseudonym> List monad is no weirder than list comprehensions.
16:34:25 <byorgey> TomMD: two good papers I've read recently are "Definitional Interpreters for Higher-Order Programming Languages" by Reynolds (a classic, notable for how it naturally motivates CPS transformation) and "Well-typed programs can't be blamed" by Wadler and Findler, about pinpointing type errors in mixed typed and untyped code
16:34:36 <byorgey> dunno if you're interested in either of those, but I enjoyed them =
16:34:57 <newsham> if (f :: a -> b -> c) and (x1 :: IO a) then (f <$> x1 :: IO (b -> c))
16:34:59 <byorgey> rwbarton: heh, true =)
16:35:26 <newsham> if (x2 :: IO b) then ((f <$> x1) <*> x2 :: IO c)
16:35:53 <newsham> return f :: IO (a -> b -> c)
16:36:03 <newsham> f <$> x1 == return f <*> x1
16:36:03 <byorgey> note, <$> is just a synonym for fmap
16:36:04 <rwbarton> Hmm, I've used the ((->) r) monad but never with do notation, I think.
16:36:24 <newsham> <$> is fmap and <*> is ap.
16:36:46 <newsham> rwbarton: isnt ((->) r) just unpolished reader monad?
16:36:53 <newsham> have you used reader monad with do?
16:36:55 <rwbarton> newsham: Yes
16:36:58 <rwbarton> newsham: Probably
16:37:28 <rwbarton> Well, maybe not.
16:38:00 <byorgey> I often end up using ReaderT in a transformer stack.  not sure if I've ever used it just by itself.
16:38:56 <Pseudonym> You can't use a transformer just by itself, duh.
16:39:19 <rwbarton> OK, I've used the Identity monad but I'm sure I've never used it with do notation :)
16:39:28 <paczesiowa> couldn't you fix it?
16:39:47 <Pseudonym> One pattern I use a fair bit, BTW, is a ReaderT on top of IO, where the thing stored in ReaderT is a record of IORefs.
16:40:06 <paczesiowa> why not StateT?
16:40:23 <Pseudonym> If you also need IO, there's no reason to use StateT.
16:40:41 <paczesiowa> if you need IO there
16:40:48 <paczesiowa> 's no reason to use anything else
16:40:59 <rwbarton> I would say "if you're using a monad transformer, there's no reason to use IORefs"
16:41:00 <byorgey> ...except for the fact that IORefs are icky =P
16:41:11 <Pseudonym> That's why I always hide them.
16:41:24 <Pseudonym> Abstraction is cheap in Haskell.
16:41:27 <Saizan> Pseudonym: i'd find that useful with MVars if you need concurrency
16:42:24 <Saizan> or maybe just atomicallyModifyIORef works
16:42:54 <Pseudonym> Yes, I can see doing it with MVars too.
16:43:41 <Pseudonym> The important thing is to add a layer of abstraction so client code doesn't actually care how it's implemented.
16:43:53 <newsham> > (do { x <- (*5); y <- (*10); return (x+y)}) 3
16:43:54 <lambdabot>   45
16:44:31 <newsham> > (do { x <- (*5); y <- flip relicate 'x'; return (x,y)}) 3
16:44:32 <lambdabot>   mueval: Prelude.read: no parse
16:44:50 <newsham> > (do { x <- (*5); y <- flip replicate 'x'; return (x,y)}) 3
16:44:51 <lambdabot>   (15,"xxx")
16:47:14 <Pseudonym> Actually, now that I look at it, the reader-of-IORefs is used in lambdabot.
16:47:20 <Pseudonym> http://www.cse.unsw.edu.au/~dons/lambdabot/Lambdabot.hs
16:47:25 <Pseudonym> Only one IORef in this case.
16:47:32 <Pseudonym> Search for "newtype LB"
16:48:11 <Pseudonym> That makes sense, since IO is used most places in lambdabot.
16:52:50 <enderbean> anyone here use wxHaskell?
16:53:10 <lispy> enderbean: not recently not
16:53:17 <lispy> s/y not/no/
16:53:39 <lispy> but I have used it in the past...
16:55:01 <enderbean> lispy: hmm.. well I'm added an event to react to keys on a textCtrl, but even if I call propagateEvent the whole action runs before the text attribute updates. I could handle the key myself but that seems.. wasteful?
16:55:57 <enderbean> lispy: So I was hoping someone would know something.
16:56:16 <lispy> enderbean: I guess it's been too long, the question doesn't make much sense to me right now :(
16:56:35 <jdrake> If I have two arbitrarily long numbers and I need to encode it and decode it from a string representation (preferably hex) what would be the best way of doing this? (best if it is something that already exists)
16:56:54 <enderbean> lispy: thats ok, thanks anyway :).
16:57:10 <lispy> jdrake: I think read can handle hex
16:57:23 <lispy> > read "0xFFAA" :: Integer
16:57:24 <lambdabot>   65450
16:57:44 <jdrake> > read "0xf213987439387459387493739" :: Integer
16:57:45 <lambdabot>   1198704990575825067320042665785
16:57:51 <lispy> integer has no maxBound
16:57:59 <lispy> > maxBound :: Integer
16:58:00 <lambdabot>       No instance for (Bounded Integer)
16:58:00 <lambdabot>        arising from a use of `maxBoun...
16:58:17 <jdrake> How can I get a hex of the integer?
16:58:17 <younder> > show 126378913416
16:58:18 <lambdabot>   "126378913416"
16:58:51 <lispy> jdrake: I don't know if the prelude has a way to get hex out of an Integer, but Text.printf probably has a way
16:59:08 <jdrake> I can take that :-)
16:59:25 <lispy> > printf "%h" (1234 :: Integer)
16:59:26 <lambdabot>   Add a type signature
16:59:33 <lispy> > printf "%h" (1234 :: Integer) :: String
16:59:34 <lambdabot>   mueval: Prelude.read: no parse
16:59:34 <lambdabot>  mueval: "*** Exception: Printf.printf: bad ...
16:59:41 <Axman6> pretty easy to write a fasirly hacky function to do it for you using divMod too
16:59:41 <lispy> Not really sure how printf works :)
16:59:46 <Saizan> > showHex 123 ""
16:59:47 <lambdabot>   mueval: Prelude.read: no parse
16:59:52 <Saizan> ?ty showHex
16:59:53 <lambdabot> forall a. (Integral a) => a -> String -> String
16:59:56 <rwbarton> > printf "%x" (10^80 :: Integer) :: String
16:59:57 <lambdabot>   "35f9dea3e1f6bdfef70cdd17b25efa418ca63a22764cec100000000000000000000"
17:00:24 <rwbarton> > printf "(0x%x,0x%x)" (10^80 :: Integer) (35 :: Integer) :: String
17:00:25 <lambdabot>   "(0x35f9dea3e1f6bdfef70cdd17b25efa418ca63a22764cec100000000000000000000,0x2...
17:00:38 <rwbarton> > read "(0x35f9dea3e1f6bdfef70cdd17b25efa418ca63a22764cec100000000000000000000,0x23)"
17:00:39 <lambdabot>   mueval: Prelude.read: no parse
17:00:39 <lambdabot>  mueval: *** Exception: Prelude.read: no parse
17:00:45 <rwbarton> > read "(0x35f9dea3e1f6bdfef70cdd17b25efa418ca63a22764cec100000000000000000000,0x23)"  :: (Integer, Integer)
17:00:47 <lambdabot>   (10000000000000000000000000000000000000000000000000000000000000000000000000...
17:01:00 <lispy> > read "0f" :: Integer
17:01:01 <lambdabot>   mueval: Prelude.read: no parse
17:01:02 <lambdabot>  mueval: *** Exception: Prelude.read: no parse
17:01:18 <lispy> > read "of7" :: Integer
17:01:19 <lambdabot>   mueval: Prelude.read: no parse
17:01:19 <lambdabot>  mueval: *** Exception: Prelude.read: no parse
17:01:22 <lispy> > read "o7" :: Integer
17:01:23 <lambdabot>   mueval: Prelude.read: no parse
17:01:23 <lambdabot>  mueval: *** Exception: Prelude.read: no parse
17:01:33 <loop> > read "0x0f" :: Integer
17:01:33 <lispy> bah, the Haskell 98 report documens this :)
17:01:34 <lambdabot>   15
17:01:42 <lispy> There is some way to read octal too
17:01:46 <Axman6> lispy: octal?
17:01:49 <Axman6> yes...
17:01:58 <loop> > read "0012" :: Integer
17:01:59 <lambdabot>   12
17:02:02 <loop> hmph
17:02:14 <lispy> ?hoogle readHex
17:02:14 <lambdabot> Numeric readHex :: Num a => ReadS a
17:02:23 <jdrake> ok, I think I am good, thank you all
17:06:33 <jdrake> Q: If I put a module in 'RSA/' but I do not want to rename the module lines inside the files to be RSA.whatever, can I still import them?
17:07:10 <Saizan> jdrake: pass -IRSA to ghc/ghci
17:07:18 <Saizan> ops
17:07:20 <Saizan> -iRSA
17:07:26 <rwbarton> Long shot: Has anyone used the generic genetic programming library GPLib?  It seems it was once on hackage, but is now gone.
17:07:48 <jdrake> Saizan, maybe I should put that in a makefile or something.
17:07:56 <jdrake> hmm  make.sh :-)
17:15:15 <jdrake> What could cause a syntax error in http://hpaste.org/11022 at a non-existent line?
17:15:54 <lispy> jdrake: let main ... is wrong
17:16:08 <lispy> jdrake: top level defintions don't need a let
17:16:35 <jdrake> true enough
17:16:36 <jdrake> THank you
17:16:58 <lispy> you're welcome
17:20:34 <BMeph> jdrake: make.sh.not.war ;)
17:22:20 <Olathe> make.dir
17:23:01 <BMeph> dcoutts: Is there an IRC chan for cabal? This issue with it at work is bugging me. :|
17:23:06 <Nafai> Okay, newbie-ish question
17:23:06 <dons> #ghc
17:23:19 <Nafai> What's the difference between where and let?
17:23:33 <dons> one's an expression
17:23:33 <lispy> Nafai: the main difference is stylistic
17:24:04 <BMeph> dons: They don't have enough issues with GHC itself? 'Cause I'm pretty sure my setup is messing up the browser settings.
17:24:24 <dons> i'd seriously consider #ghc
17:24:43 <lispy> Nafai: But, then as dons said, let is an expression whereas where is a clause
17:24:43 <dcoutts> BMeph: this channel or ghc
17:24:43 <BMeph> dons: Fair enough, thanks. :)
17:25:02 <lispy> > let foo = 4 in foo -- note that lambdabot can only handle expressions
17:25:03 <lambdabot>   4
17:25:55 <Nafai> byorgey: So, in the advice you gave me in #xmonad, why let instead of where?
17:27:37 <Philonous> Does ghc discriminate between f anf \x -> f x ?
17:28:21 <dmwit__> It depends on the definition of f.
17:28:23 <rwbarton> Philonous: They are different in a small number of situations
17:28:28 <rwbarton> > undefined 3
17:28:29 <lambdabot>   mueval: Prelude.read: no parse
17:28:29 <lambdabot>  mueval: *** Exception: Prelude.undefined
17:28:47 <rwbarton> > undefined `seq` 3
17:28:48 <lambdabot>   mueval: Prelude.read: no parse
17:28:48 <lambdabot>  mueval: *** Exception: Prelude.undefined
17:28:53 <rwbarton> > (\x -> undefined x) `seq` 3
17:28:54 <lambdabot>   3
17:29:05 <dmwit__> Also, the MR may apply.
17:29:16 <Saizan> also in some cases with higher-rank polymorphism
17:29:40 <Philonous> Is undefined a function?
17:29:46 <rwbarton> Sure.
17:29:50 <rwbarton> :t undefined
17:29:51 <lambdabot> forall a. a
17:30:08 <byorgey> Nafai: ah, that's a bit different.  There's a special use of 'let' in do notation
17:30:15 <byorgey> where you don't have to have an 'in' part
17:30:21 <paczesiowa> > head $ [1] ++ map undefined [1..]
17:30:22 <lambdabot>   1
17:30:23 <Philonous> Btw, what do you mean by MR?
17:30:25 <byorgey> (technically, the 'in' part is just the rest of the do-block)
17:30:31 <paczesiowa> monomorphism restriciton
17:30:48 <byorgey> Nafai: so you can just have  'let x = y' be a line by itself in a do-block, which creates a local binding of x to y.
17:30:54 <Philonous> Hmmm, I didn't encounter that yet, I think
17:31:15 <mmorrow> Cale: zomg!
17:31:18 <Nafai> paczesiowa: BTW, here's my working code: http://github.com/Nafai77/utilities/tree/master/src/gtkmenu.hs
17:31:20 <lambdabot> Title: src/gtkmenu.hs at master from Nafai77's utilities — GitHub
17:31:21 <Cale> mmorrow: what?
17:31:23 <mmorrow> general monad comprehensions
17:31:24 <mmorrow> , flip runState (0,1) [$mc| [ m | (m,n) <- get , () <- put (n,m+n) ] |]
17:31:29 <lunabot>  (0,(1,1))
17:31:33 <mmorrow> :):)
17:31:33 <Cale> :)
17:31:41 <Cale> Very cool :)
17:31:49 <Cale> What is lunabot, btw?
17:32:03 <mmorrow> (i had to make them instances of MonadPlus, so i just did a bunch of  mzero = fail [] :(
17:32:14 <rwbarton> Sweet, combine this with a MonadFail context for fail and we can create Haskell 1.4
17:32:33 <rwbarton> mmorrow: next up is import Foo renaming ... :)
17:32:51 <mmorrow> it's an evalbot that uses the ghc-api to directly compile expression. the same way that ghci does (but ghci does a /lot/ more stuff)
17:32:57 <Saizan> didn't they re-generalize monad comprehensions in 6.10?
17:32:58 <mmorrow> rwbarton: heh
17:33:38 <Saizan> s/monad//
17:33:41 <paczesiowa> Nafai: anyway why do you need that?
17:33:42 <mmorrow> hmm, i mine is a 6.10 from maybe a week and a half ago.
17:33:49 <mmorrow> (and it doesn't have it)
17:33:56 <paczesiowa> Nafai: why not use tab-completion?
17:34:09 <mmorrow> s/i//
17:34:10 <Cale> mmorrow: Were you able to control imports in a sane way?
17:34:18 <allbery_b> I thought general monad comprehensions were ruled out
17:34:31 <allbery_b> the resulting error messages are still kinda painful if you mess up
17:34:53 <Nafai> Just a feature I'm used to from iswitch-window in sawfish and iswitch-buffer in Emacs
17:35:02 <Cale> allbery_b: SPJ said that if someone wrote a patch to add them to GHC (as an extension), then he'd accept it.
17:35:08 <mmorrow> Cale: yeah, with how the expressions input to eval get compiled, you can hide stuff by making a package which import that desired import hiding, then reexports that though itself
17:35:11 <Nafai> I'll probably eventually implement tab completion on this too
17:35:34 <Cale> allbery_b: They weren't in Haskell 98 for that reason, but there are a lot of things about Haskell 98 which are now considered silly.
17:35:46 <mmorrow> Cale: that's on my to-figure-out list :)
17:35:57 <Cale> mmorrow: awesome :)
17:36:03 <paczesiowa> Nafai: there are readline bindings so there's not much to implement
17:36:19 <Nafai> readline bindings for gtk entries?
17:36:28 <allbery_b> hm.  someone on -cafe a few months ago showed an example erro rmessage from a botched monad comprehension that made it pretty obvious that there were dragons
17:36:44 <paczesiowa> not gtk. why does it have to be gui?
17:36:54 <Cale> The error messages are no worse than those you could achieve with do-notation.
17:37:02 <Frowardd> ah, 464 people! a nice full channel!
17:37:08 <Cale> Frowardd: yep :)
17:37:14 <Cale> Frowardd: Learning Haskell?
17:37:16 <Axman6> ?users
17:37:16 <lambdabot> Maximum users seen in #haskell: 540, currently: 465 (86.1%), active: 21 (4.5%)
17:37:20 <Saizan> mmorrow: ah, no, they list these on the release page http://hackage.haskell.org/trac/ghc/wiki/SQLLikeComprehensions
17:37:21 <lambdabot> Title: SQLLikeComprehensions - GHC - Trac
17:37:26 <Axman6> where'd everyone go :o
17:37:35 <Nafai> paczesiowa: I like GUIs I guess
17:37:56 <paczesiowa> Cale: is that a pick up line like "come here often?" :)
17:38:15 <Cale> paczesiowa: heh.
17:38:23 <Frowardd> no, someone just said to lurk here
17:38:28 <allbery_b> hm, I'm nos sure it was on -cafe, might have been haskell@ or even ghc-users.  digging...
17:38:29 <Frowardd> apparently you guys are active! I need a new lurk channel.
17:38:44 <Frowardd> however if the subject is haskell..I wouldn't fit in.
17:39:09 <Axman6> Frowardd: you should learn haskell and then fit in
17:39:19 <paczesiowa> sometimes we (well not me) talk about category theory
17:39:20 <Cale> Frowardd: Well, if you have any questions about the language, or more generally about programming or category theory, feel free to ask.
17:39:46 <pjdelport> category theory: always relevant
17:39:51 <paczesiowa> so there are plenty of topics to discuss here, but haskell is the easiest one
17:40:54 <mmorrow> here's the code to the module which does all the necessary translation (hehe, you'll notice a few "we'll just not tell anyone about that ;)"s in there ;) http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=97
17:42:08 <mmorrow> hmm. actually, i thought that i had to use those cases with undefineds at the ends at one point, but now that i finished it, i don't think i need to do that at all
17:43:38 <mmorrow> err, i dunno. i think i have to. this way, if you just provide a dummy instance of MonadPlus so you can use monad comp syntax, the cases allow you to avoid weirdly defined guards??
17:44:13 <mmorrow> also, lemme know if anyone can think of better instance for MonadPlus than i have there
17:44:43 <mmorrow> Saizan: oh yeah. those look neat. i nearly forgot about them.
17:49:02 <harrison_partch> i am coding a pornographic window manager in haskell
17:49:04 <mmorrow> , (text . pretty) `fmap` elimCompQ "[ s | s <- readFile \"a.b\" , length s > 0]"
17:49:08 <lunabot>  DoE
17:49:08 <lunabot>    [BindS (VarP s_0)
17:49:08 <lunabot>       (AppE (VarE System.IO.readFile) (LitE (StringL "a.b"))),
17:49:13 <harrison_partch> "SexGonad"
17:49:13 <mmorrow> err
17:49:21 <mmorrow> , (text . prettyPrint) `fmap` elimCompQ "[ s | s <- readFile \"a.b\" , length s > 0]"
17:49:22 <lunabot>  luna: No instance for (Language.Haskell.Exts.Pretty.Pretty
17:49:22 <lunabot>                     Language.Haskell.TH.Syntax.Exp)
17:49:22 <lunabot>    arising from a use of `Language.Haskell.Exts.Pretty.prettyPrint'
17:49:32 <mmorrow> , ppDoc' `fmap` elimCompQ "[ s | s <- readFile \"a.b\" , length s > 0]"
17:49:37 <lunabot>  do s <- readFile "a.b"
17:49:37 <lunabot>     case length s > 0 of
17:49:37 <lunabot>         True -> return undefined
17:50:00 <Axman6> lunabot needs to learn to use a pastebot
17:51:14 <mmorrow> so the " True -> return undefined" is a placeholder. i think i can definitely just use guard?
17:52:14 <lispy> yeah, lunabot is a bit overly spammy...even compared to lambdabot :)
17:52:22 <mmorrow> lies!
17:52:23 <Saizan> mmorrow: yeah, why not?
17:52:37 <adu> I need help
17:52:43 <lispy> but, I dunno, this is a spammy channel :)
17:52:57 <adu> is there an easier way to do this: http://hpaste.org/11023 ?
17:53:25 <mmorrow> Saizan: when i was half-way though i was like "aw crap, there're only two MonadPluses, and i want to be able to just sidestep that restiction for the sake of entertainment"
17:53:57 <mmorrow> but you can always just move the bootleg code the the instance of MonadPlus
17:54:13 <mmorrow> yeah, totally. i'm gonna get rid of that
17:54:21 <lispy> adu: what's up with this? fmap = mapS' unsafeCoerce
17:54:45 <adu> lispy: mapS is naturally (a -> a) and it was required to be (a -> b) for fmap to be happy
17:55:12 <SamB> ... and ... how does that justify unsafeCoerce ?
17:55:16 <adu> lispy: if you can think of a better way I'm all ears :)
17:55:39 <lispy> adu: does it give a type error with out it?
17:55:47 <adu> lispy: yes
17:56:05 <paczesiowa> those damn type errors...
17:56:07 <adu> lispy: something about "unable to generalize" a to b
17:56:23 <lispy> yes, that seems right
17:56:27 <SamB> I'm guessing it isn't good to just toss an unsafeCoerce at it and forget about the type error!
17:56:34 <lispy> I'm now trying to think of ways to use your fmap to cause a segfault
17:56:35 <Saizan> adu: and why you make Sep is an instance of functor?
17:56:52 <adu> SamB: ya, theres probably a better way, I'm just not seeing it...
17:57:04 <adu> Saizan: o, i dunno, maybe I shouldn't...
17:57:20 <lispy> :t fmap
17:57:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:58:03 <Cale> mmorrow: IO is a "MonadPlus"
17:58:04 <Saizan> adu: you shouldn't :) there's no way to make it work since you've functions of type (a -> Something) in the fields
17:58:36 <mmorrow> Cale: hmm. the only ones that showed up on my :i were [] and Maybe
17:58:46 <Cale> Maybe import Control.Exception?
17:58:48 * mmorrow checks again
17:59:24 <Saizan> ?instances-importing Control.Monad MonadPlus
17:59:24 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
18:00:01 <rwbarton> Many of those have MonadPlus contexts though
18:00:05 <mmorrow> whuh
18:00:09 <adu> whats RWST
18:00:18 <mmorrow> i still only see Maybe and []
18:00:23 <ddarius> ReaderWriterState
18:00:56 <Cale> hmm
18:00:56 <reuben-> how do i compose a function Int -> Bool that returns true if its input is even and < 4000000
18:01:18 <reuben-> i want to do this just compising < 400000, even, and and
18:01:48 <Cale> liftM2 (&&) (<400000) even
18:02:00 <rwbarton> @pl (\x -> even x && (x < 4000000))
18:02:01 <lambdabot> liftM2 (&&) even (< 4000000)
18:02:33 <Cale> \x -> and [even x, x < 4000000]
18:02:37 <lispy> adu: so, I think if you did had SepHoldCustom, and fmap :: (String -> Double) -> Sep String -> Sep Double, I think we could make it segfault
18:02:38 <reuben-> liftM2 is neat
18:02:43 <mmorrow> , flip runRWS "README" [0..9] (ask >>= \(x:y:z:xs) -> tell [y,z] >> get >>= \(_:ns) -> put ns >> return (zip xs ns))
18:02:45 <lunabot>  luna: Couldn't match expected type `Control.Monad.RWS.Lazy.RWS
18:02:45 <lunabot>                                  [GHC.Types.Char] w s a'
18:02:45 <lunabot>         against inferred type `[a1]'
18:02:49 <adu> but anyways, I wasn't really asking about "instance Functor Sep" so much as "instance IsSep (Sep (Sep ..."
18:02:54 <adu> is there any way to generalize those
18:02:56 <adu> ?
18:03:01 <mmorrow> gah. i do have to control those error msgs
18:03:05 <Cale> reuben-: For it to work, you'll have to import Control.Monad.Instances
18:03:14 <Cale> (as well as Control.Monad)
18:03:38 <mmorrow> ooh. maybe that's where the hidden MonadPlus instances are ...
18:03:45 <Cale> mmorrow: Aha! It's in Control.Monad.Error
18:04:17 <lispy> adu: can we do this by adding a constraint in the instance?
18:04:19 <mmorrow> Cale: heh, i think i've ever only imported that once..
18:04:20 <adu> lispy: ya, that would be a segfault
18:04:21 <paczesiowa> adu: all your instances look the same
18:04:26 <rwbarton> adu: can you write an instance IsSep a => IsSep (Sep a)?
18:04:30 <adu> paczesiowa: they are
18:04:37 <lispy> adu: yeah, what rwbarton said
18:04:39 <paczesiowa> adu: why did you make it a class function?
18:04:53 <rwbarton> paczesiowa: there's a different String instance above
18:05:24 <paczesiowa> nvm, he uses those functions on different types inside
18:05:28 <Olathe> @type retry
18:05:29 <lambdabot> Not in scope: `retry'
18:05:43 <adu> oh, it works now
18:05:44 <adu> heh
18:05:48 <adu> n/m
18:06:30 <adu> paczesiowa: well, I wanted a nice way to do "sep ThisWay" and not care about whether or not its already been separated before...
18:07:04 <Cale> heh, I saw 'class function' and thought of "A predicate P(x,y) such that for all x, there exists a unique y for which P(x,y) holds."
18:07:56 <Cale> (I suppose that ought to mention the classes to which x and y are meant to belong to)
18:08:20 <lispy> adu: I don't really say a way to use mapS' to implement fmap
18:08:26 <adu> paczesiowa: but I had implemented it without classes before, but it was much uglier...
18:08:40 <adu> lispy: ok, I'll drop the "instance Functor" then
18:09:32 <lispy> adu: It seems like somewhere that you may want to use Typeable's cast
18:10:03 <adu> lispy: perhaps...
18:10:41 <adu> lispy: my ultimate goal is to use this type/class in both 'diff' and 'grep' tools
18:15:54 <cads> hello
18:17:21 <cads> is there a simple way configure ghci to perform tab comlpetion here in windows?
18:23:33 <bbs> Cale: i finished!
18:23:42 <bbs> its pretty fugly though
18:24:27 <Cale> bbs: cool :) need any help cleaning things up?
18:24:33 <bbs> Cale: would love some.
18:24:38 <bbs> Cale: it does work though
18:24:46 <bbs> and i just wanted to struggle though it first you know ;/
18:24:51 <Cale> yeah
18:24:58 <bbs> Cale: i defined the assoc myself too
18:24:58 <bbs> :D
18:25:02 <bbs> sec i'll paste
18:25:06 <Cale> :)
18:25:09 * bbs hugs wgetpaste in console
18:25:32 <bbs> bbs@suMO ~/sandbox/cs370/project1 $ wgetpaste project1.hs
18:25:32 <bbs> Your paste can be seen here: http://zlin.dk/p/?YjZiY2I2
18:26:05 * bbs evades lambabots verbose webpage explaination
18:26:26 <bbs> Cale: care to do a diff -ruN ?? :p
18:26:29 <bbs> lol
18:28:05 <Cale> One little style point to start with -- in Haskell, we normally indent if-expressions a little differently
18:28:09 <Cale> if foo
18:28:11 <Cale>    then bar
18:28:14 <Cale>    else quux
18:29:23 <Cale> Also, I see that there are tab characters in your source file, which is something you're going to want to avoid, by configuring your editor to turn them into spaces automatically for you.
18:29:46 <Cale> (if you're using vim, the appropriate option is expandtab, and possibly smarttab)
18:30:31 <rwbarton> Should a tool to derive JSON instances using TH live in Data.Derive.JSON or Text.JSON.Derive?  (Or somewhere else?)  The module layout guide isn't terribly helpful.
18:31:07 <Cale> rwbarton: Either of those sounds reasonable to me.
18:31:52 <bbs> Cale: ah really?
18:31:57 <Cale> bbs: yeah.
18:31:58 <bbs> i use a fancy vim
18:32:07 <bbs> (i do mostly c)
18:32:40 <bbs> Cale: so i can just do
18:32:44 <bbs> :expandtab
18:32:47 <Cale> The reason is that Haskell layout is alignment sensitive, so changing the tab width could change the meaning of the code, unless you're extremely careful in how things are laid out.
18:32:47 <bbs> :smarttab
18:32:54 <Cale> :set expandtab
18:33:00 <Cale> and :set smarttab
18:33:01 <Cale> iirc
18:33:14 <dmwit> :set softtabstop=4
18:33:18 <Cale> You could add those to your .vimrc if you don't want to have to type them regularly.
18:33:19 <dmwit> :set tabstop=4
18:33:35 <Cale> (Without the colons though.)
18:33:38 <bbs> Cale: i fixed it to
18:33:38 <bbs>   if test == b then c
18:33:38 <bbs>         else assoc test xs
18:33:43 <bbs> oops those line up right :/
18:34:29 <Cale> Next, whenever you have code which looks like:
18:34:41 <Cale> f (x:xs) = g x : f xs
18:34:56 <Cale> You should wonder about whether  f = map g
18:35:08 <Cale> (which is certainly the case if  f [] = [])
18:35:22 <lispy> ?src map
18:35:22 <lambdabot> map _ []     = []
18:35:23 <lambdabot> map f (x:xs) = f x : map f xs
18:35:42 <Cale> So, for instance, in  v_update, you have  v_update (x:xs) = map vertH x : v_update xs
18:36:00 <Cale> But you could write   v_update xs = map (map vertH) xs
18:36:18 <lispy> you could even take that a step further
18:36:27 <lispy> v_update = map (map vertH)
18:36:32 <Cale> and remove the xs from both sides of the equation, yes
18:36:41 <bbs> ah cool :)
18:36:43 <bbs> so consice
18:36:46 <bbs> i love it.
18:37:18 <Cale> Now let's look at vsew.
18:37:21 <Cale> We have
18:37:21 * lispy is reading about region IO
18:37:24 <Cale> vsew [] = []
18:37:31 <Cale> vsew (x:xs) = x ++ vsew xs
18:38:06 <Cale> I see at least one foldr1 in your code, so I take it you've been introduced to folds?
18:38:22 <bbs> Cale: a bit >)
18:38:40 <Cale> okay, so let's keep vsew in mind, and have a look at a few similar programs
18:38:45 <Cale> sum [] = 0
18:38:50 <Cale> sum (x:xs) = x + sum xs
18:38:55 <Cale> product [] = 1
18:39:02 <Cale> product (x:xs) = x * product xs
18:39:17 <bbs> sum = foldr (+)
18:39:17 <bbs> ?
18:39:20 <bbs> something like that
18:39:32 <lispy> bbs: very close, one more detail missing though
18:39:33 <bbs> sum x = foldr (+) x
18:39:47 <lispy> bbs: what is sum []?
18:39:56 <bbs> a list :)
18:40:01 <bbs> maybe
18:40:02 <Cale> sum = foldr (+) 0
18:40:02 <bbs> set
18:40:04 <lispy> :t sum []
18:40:05 <lambdabot> forall a. (Num a) => a
18:40:11 <idnar> :t foldr
18:40:12 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
18:40:13 <bbs> sum x = foldr (+:) x
18:40:16 <sbahra> Cale, could you have lambdabot rejoin ##FreeBSD?
18:40:29 <bbs> @join #freebsd
18:40:29 <lambdabot> Not enough privileges
18:40:31 <bbs> lol
18:41:25 <bbs> lispy: is that right ^
18:41:28 <lispy> :t foldr (+)
18:41:29 <lambdabot> forall a. (Num a) => a -> [a] -> a
18:41:35 <Cale_> sorry about that
18:41:37 <lispy> :t sum
18:41:38 <lambdabot> forall a. (Num a) => [a] -> a
18:41:42 <sbahra> Cale_, could you have lambdabot rejoin ##FreeBSD?
18:41:43 <lispy> bbs: do you see the difference?
18:41:43 <dmwit> bbs: You're missing a base case.
18:41:51 <Cale_> lambdabot: @join ##FreeBSD
18:41:52 <lambdabot> Not enough privileges
18:41:58 <Cale_> ...
18:41:59 <bbs> lispy: from an input to a list
18:42:00 <sbahra> Cale_.
18:42:00 <dmwit> ghosting time
18:42:01 <Cale_> oh, right
18:42:11 <Cale> lambdabot: @join ##FreeBSD
18:42:15 <sbahra> thanks
18:42:27 <Cale> sbahra: I'm not sure why it wouldn't have joined on its own...
18:42:33 <Cale> okay
18:42:41 <sbahra> An op banned it.
18:42:45 <lispy> bbs: right, so as dmwit pointed out, in the definition sum = foldr (+), you're missing the basecase.  What happens when you want to evaluate, sum []?
18:42:52 <Cale> bbs: So, looking at these three programs, we notice that two things are changing in each:
18:43:07 <Cale> 1) The value which is returned for the empty list.
18:43:30 <Cale> 2) The operation which is applied to the first element of the list and the result of recursing on the tail.
18:44:01 <bbs> ok so i need to be explicit?
18:44:08 <bbs> sum [] = []
18:44:19 <bbs> first
18:44:21 <bbs> then
18:44:27 <Cale> sum is normally expected to give a number...
18:44:29 <bbs> sum = foldr (+)
18:44:37 <Cale> no, that won't work
18:44:38 <Olathe> @src sum
18:44:39 <lambdabot> sum = foldl (+) 0
18:44:43 <bbs> hmm
18:44:55 <Olathe> I'd say sum = foldl (+) 0 ;)
18:45:07 <lispy> data Foo = forall a. F a vs. data Foo = F (forall a. a).  This is the same as if 'F' had been treated as a function arrow?  That is, moving a forall across the data constructor has the same effect as moving the forall across a function arrow?
18:45:15 <Cale> foldl is not of concern to us for now though
18:45:31 <bbs> so i have to do what then?
18:45:34 <bbs> i'm confused now
18:45:40 <bbs> sry :/
18:45:41 <Cale> bbs: Okay, so we have these two parts which are the only two things changing between all these programs.
18:45:47 <lispy> :t Just\
18:45:48 <lambdabot> parse error on input `\'
18:45:49 <lispy> :t Just
18:45:50 <lambdabot> forall a. a -> Maybe a
18:45:55 <dmwit> bbs: foldr takes both a combining function and a base case as separate arguments.
18:46:07 <bbs> AH! so i could do it w/o basecase
18:46:10 <bbs> using foldr1
18:46:17 <bbs> sum = foldr1 (+)
18:46:17 <dmwit> right!
18:46:18 <Cale> bbs: So, what we'll do is write a function, foldr f z which is going to combine the elements of the list with f, and give z for the empty list.
18:46:25 <dmwit> bbs: But, you don't want to. =)
18:46:28 <bbs> ah ok
18:46:31 <rwbarton> lispy: data Foo = forall a. F a  ==>  F :: forall a. a -> Foo;   data Foo = F (forall a. a)  ==>  F :: (forall a. a) -> Foo
18:47:02 <lispy> rwbarton: okay, so I had the right idea, but I explained it wrong.
18:47:09 <Cale> bbs: #haskell-overflow if you could, since this discussion takes a little concentration... things are a little noisy :)
18:48:34 <mmorrow> <rwbarton> Should a tool to derive JSON instances using TH live in Data.Derive.JSON or Text.JSON.Derive?
18:49:05 <rwbarton> mmorrow: too late, I already did the mkdir :)
18:49:11 <mmorrow> rwbarton: Text.JSON,Derive for sure. and the proliferation egins!
18:49:21 <mmorrow> aww
18:49:31 <rwbarton> That's what I chose too
18:49:45 <mmorrow> nice.
18:53:14 <thoughtpolice> people should make more derivations for data.derive
18:53:18 <thoughtpolice> because it's goodness :]
18:53:53 <lispy> thoughtpolice: I've never looked at it, give me 1 sentence telling me why I should look at it :)
18:54:33 <thoughtpolice> major reason: you can use template haskell to describe the derivations
18:54:41 <thoughtpolice> you need for a preprocess step, i.e. like drift
18:55:07 <thoughtpolice> makes it much easier to e.g. use cabal for your project's build
18:55:11 <rwbarton> s/you/no/ ?
18:55:16 <thoughtpolice> yeah, that
18:57:28 <jdrake> What is the difference between Int and Integer?
18:57:58 <rwbarton> Int is finite-precision, a machine word in GHC
18:58:01 <mmorrow> fixed guard
18:58:03 <mmorrow> , ppDoc' `fmap` elimCompQ "[ m | (m,n) <- get , True]"
18:58:08 <lunabot>  do (m, n) <- get
18:58:08 <lunabot>     guard True
18:58:08 <lunabot>     return m
18:59:22 <jdrake> rwbarton, ok, definitely not Int I want then
18:59:22 <mmorrow> also, lunabot's error msgs are now but tiny peeps
18:59:42 <Saizan> , () ()
18:59:44 <lunabot>  luna: Couldn't match expected type `() -> a' against inferred type `()'
18:59:55 <mmorrow> (one line limit)
19:01:10 <rwbarton> mmorrow: so if I have Template Haskell blob that I could splice in with $(...), how can I pretty-print it instead?
19:01:55 <mmorrow> so if it's (Ppr a => Q a), the pprint will print it to source syntax
19:02:16 <mmorrow> and show will give you a (valid as a haskell expression) view of it
19:03:24 <rwbarton> I get No instance for Ppr (Q [Dec]) (same with Show)
19:03:32 <mmorrow> once i realized that you can just clean the names a bit, then reparse the show/pprinted string with haskell-src-exts, then prettyPrint again from there, life was great
19:03:59 <mmorrow> ah, so there's runQ :: (Quasi m) => Q a -> m a
19:04:25 <mmorrow> (the only instances of Quasi are Q, IO, Tc_M)
19:04:41 <mmorrow> (there the _ stands for "err, can't remember")
19:05:01 <mmorrow> unQ :: Q a -> a is handy in many cases
19:05:11 <mmorrow> unQ = unsafePerformIO . runQ
19:05:45 <rwbarton> Now I get "Can't do `reify' in the IO monad"
19:05:51 <mmorrow> yeah, hehe
19:06:25 <mmorrow> so you need to lift the Info via Lift class, then splice that ExpQ rep of the Info, which evals back to that Info
19:06:39 <mmorrow> , $(lift =<< reify ''Int)
19:06:41 <rwbarton> OK, I think I did this before
19:06:41 <lunabot>  TyConI (DataD [] GHC.Types.Int [] [NormalC GHC.Types.I# [(NotStrict,ConT ...
19:07:04 <mmorrow> that was one thing that too me /forever/ to figure out
19:07:13 <mmorrow> s/too/took/
19:08:12 <mmorrow> i probably use that expression more than any other TH as well
19:08:39 <mmorrow> rwbarton: do you have the Lift instances?
19:09:59 <rwbarton> mmorrow: only for some basic haskell types
19:10:28 <rwbarton> I tried this: $(do x <- derive makeBinary ''Foo; runIO . putStrLn . pprint $ x; [|0|]) but it printed it 4 times :)
19:10:46 <mmorrow> ok. one sec. (these instances are one of the things that make TH actually not-painful to use)
19:11:14 <mmorrow> what ghc version?
19:11:51 <rwbarton> 6.8.2
19:12:31 <mmorrow> ooh, ok. no prob, a sec
19:14:04 <rwbarton> this works ok: $((LitE . StringL . pprint) <$> derive makeBinary ''Foo)
19:15:42 <mmorrow> ok, this should definitely work http://code.haskell.org/~morrow/code/haskell/th-utils/
19:15:43 <lambdabot> Title: Index of /~morrow/code/haskell/th-utils
19:16:57 <cjs> I have a lot of records that have, say a "name" field, and naming them all differently is getting to be quote a hassle (dStockName, fStockName, etc. etc.). How do I deal with this?
19:17:38 <mmorrow> rwbarton: oh crap. it may not. i'll separate the Instances from the other part that uses the newer TH
19:17:57 <rwbarton> mmorrow: It's OK, I accomplished my goal (get the derived instance as a String)
19:18:20 <mmorrow> rwbarton: you really really want these instances. :)
19:24:47 <mmorrow> rwbarton: ok, this should 100% work. it's just the the instances (which i've been meaning to separate out for a while actually) http://code.haskell.org/~morrow/code/haskell/th-instances/
19:24:47 <lambdabot> Title: Index of /~morrow/code/haskell/th-instances
19:26:12 <mmorrow> th-lift by igloo did all the derivation work
19:32:13 <mmorrow> rwbarton: also, HERA is where i'd say i learnt about TH: http://code.haskell.org/HERA/
19:32:14 <lambdabot> Title: Index of /HERA
19:34:25 <cjs> Hm.I guess there's no way around it.
19:36:45 <dmwit> cjs: Are they all in the same data declaration?
19:37:32 <cjs> No, they're in different ones, unfortunately. They do have the same types, though.
19:37:44 <cjs> This is one thing I miss from OO languages.
19:38:52 <dmwit> cjs: How about a type class?
19:39:02 <dmwit> class Named a where name :: a -> String
19:39:23 <dmwit> setName :: String -> a -> a
19:39:37 <dmwit> Or, better yet, use functional references.
19:40:56 <cjs> Hm. There's a thought. Though it might turn out to be several type classes....
19:41:11 <cjs> Seems a bit of an abuse of them, in a way, though.
19:41:26 <dmwit> Why?
19:41:31 <dmwit> You miss polymorphism from OO.
19:41:39 <dmwit> classes give us ad-hoc polymorphism.
19:41:47 <cjs> Actually, this isn't about polymorphism, it's about namespace control.
19:41:51 <dmwit> Seems like a match made in heaven to me. =)
19:42:00 <dmwit> tomato, tomahto
19:42:09 <dmwit> You want the same name to work on different types.
19:42:13 <dmwit> That's polymorphism.
19:42:15 <cjs> I do like Haskell classes very much, though.
19:43:04 <EvilTerran> as someone said, functional references are a good option for this
19:43:18 <cjs> Hm. So if I end up with, e.g., "class HasStockName where stockName :: ByteString" and "class HasStockCode where stockCode :: ByteString", that doesn'ts eem a bit odd?
19:43:22 <cjs> Functional references?
19:43:33 <dmwit> ?where funref
19:43:33 <lambdabot> I know nothing about funref.
19:43:38 <EvilTerran> emulating prototype-based OOP
19:43:41 <dmwit> ?go twanvl functional references
19:43:43 <lambdabot> No Result Found.
19:43:46 <dmwit> wut
19:44:00 <dmwit> Let me boot up Firefox and give you my bookmark.
19:44:13 <dmwit> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
19:44:20 <lambdabot> Title: Overloading functional references - 21 thoughts, http://tinyurl.com/2ustba
19:44:20 <EvilTerran> http://google.com/search?q=twanvl+functional+references&btnI
19:44:21 <lambdabot> Title: twanvl functional references - Google Search
19:44:47 <dmwit> EvilTerran: I guess the search should be s/twanvl/twan/.
19:45:07 <dmwit> Although that actually has the right hit *lower* on the list. huh
19:45:10 <EvilTerran> ?where+ FRef http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
19:45:10 <lambdabot> It is stored.
19:45:26 <dmwit> ?where fref
19:45:26 <lambdabot> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
19:47:22 <cjs> Ah, I remember these, vaguely....
19:50:52 <Nafai> What's better style, if you don't want to do something when a Maybe is Nothing and you are in a do block?  Do a case with the Nothing just being 'return ()' or a when (isJust foo) $ do let f = fromJust foo\n ... ?
19:51:27 <dmwit> How about using Maybe's bind?
19:51:33 <cjs> I've been dealing with that a lot, and heading towards composing operators in the Maybe monad.
19:51:55 <dmwit> Or, don't you mean in a Maybe do?
19:51:57 <paczesiowa> Nafai: MaybeT ?
19:52:13 <dmwit> In that case, you can use "maybe" or "fromMaybe", depending on how general you need it to be.
19:52:15 <dmwit> :t fromMaybe
19:52:16 <lambdabot> forall a. a -> Maybe a -> a
19:52:18 <dmwit> :t maybe
19:52:19 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
19:52:39 <dmwit> :t maybe (return ())
19:52:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
19:52:46 <Axman6> > maybe 3 (+1) (Just 1)
19:52:47 <lambdabot>   2
19:52:53 <Axman6> > maybe 3 (+1) (Nothing)
19:52:54 <lambdabot>   3
19:53:08 <cjs> E.g.: add fields = do x <- lookup 13 fields; y <- lookup 17 fields; return (x+y)
19:53:14 <Nafai> I want to rewrite what is here: http://github.com/Nafai77/utilities/tree/master/src/gtkmenu.hs#L137 (beginning on this line)
19:53:16 <lambdabot> Title: src/gtkmenu.hs at master from Nafai77's utilities — GitHub, http://tinyurl.com/3flxge
19:53:38 <EvilTerran> ?src fromMaybe
19:53:38 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
19:53:46 <EvilTerran> ?src maybe
19:53:46 <lambdabot> maybe n _ Nothing  = n
19:53:46 <lambdabot> maybe _ f (Just x) = f x
19:53:54 <EvilTerran> how... inconsistent
19:54:20 <rwbarton> What's with this?  Prelude> :cd "/"
19:54:20 <rwbarton> *** Exception: "/": setCurrentDirectory: does not exist (No such file or directory)
19:54:34 <cjs> Nafai: looks like you want to run in the Maybe monad, there.
19:54:35 <dmwit> Try :cd /
19:54:37 <rwbarton> Oh, it doesn't want a string.  Sorry
19:54:45 * EvilTerran expected fromMaybe = flip maybe id or similar
19:56:37 <Nafai> cjs: Could you point me to an example?
19:57:50 <cjs> Oh, wait, no, you're doing the decisions the other way around, right? Basically, a chain of things, and if the first thing returns Just x, you're done, but if it returns Nothing, you move on to the second, until you've finally found a Just x or exhausted the possibilities?
19:57:55 <paczesiowa> I don't think he wants Maybe[T] monad, once he does things in case of Nothing, and then in case of Just
19:58:09 <cjs> That's mplus.
19:58:24 <cjs> > Nothing `mplus` Nothing
19:58:25 <lambdabot>   Nothing
19:58:37 <cjs> > Nothing `mplus` Just 3
19:58:38 <lambdabot>   Just 3
19:58:45 <cjs> > Just 2 `mplus` Just 3
19:58:46 <lambdabot>   Just 2
19:58:51 <geezusfreeek_> > Nothing <|> Just 3
19:58:53 <lambdabot>   Just 3
19:58:53 <dmwit> > catMaybes [Just 2, Just 3, Nothing]
19:58:54 <lambdabot>   [2,3]
19:59:02 <dmwit> What are we talking about again?
19:59:19 <cjs> http://github.com/Nafai77/utilities/tree/master/src/gtkmenu.hs#L137
19:59:22 <lambdabot> Title: src/gtkmenu.hs at master from Nafai77's utilities — GitHub, http://tinyurl.com/3flxge
19:59:47 <mmorrow> > (maybe mzero mplus =<<) [Just 2, Just 3, Nothing]
19:59:48 <lambdabot>   Couldn't match expected type `m a -> Maybe (m a)'
20:00:05 <mmorrow> heh
20:00:14 <mmorrow> > (maybe mzero returnm =<<) [Just 2, Just 3, Nothing]
20:00:15 <lambdabot>   mueval: Prelude.read: no parse
20:00:17 <mmorrow> > (maybe mzero return =<<) [Just 2, Just 3, Nothing]
20:00:18 <lambdabot>   [2,3]
20:00:32 <cjs> So kinda like: treeSelectionGetSeleected tvs `mplus` treeModelGetIterFirst model `mplus` treeSelectionSelectIter tvs iter
20:01:06 <paczesiowa> cjs: where does iter come from?
20:01:17 <paczesiowa> it's not that easy
20:01:19 <dmwit> Nafai: Does treeModelGetIterFirst do anything bad?  (Could you safely call it in both cases?)
20:01:47 * Nafai loves getting #haskell to rewrite his code :)
20:01:48 <cjs> Well, not quite that easy, but it looks like it's all mixed up in IO....
20:02:23 <Saizan> treeSelectionGetSeleected tvs `mplus` (treeModelGetIterFirst model >>= treeSelectionSelectIter tvs iter >> return ())
20:02:34 <Nafai> Let me see what it returns if there is nothing in the tree
20:03:00 <paczesiowa> Saizan: still no iter binding
20:03:19 <Saizan> oh, i forgot to delete that :)
20:03:38 <Saizan> (treeSelectionGetSeleected tvs >> return ()) `mplus` (treeModelGetIterFirst model >>= treeSelectionSelectIter tvs >> return ())
20:03:41 <mmorrow> wow, those names are ginORMOUS
20:03:49 <paczesiowa> anyway if it is that hard to "abstract" I wouldn't do it, you'll forget what it does tomorrow
20:03:49 <dmwit> Saizan: Now, if only that type-checked...
20:04:10 <Saizan> dmwit: with MaybeT it does
20:04:16 <paczesiowa> let's not golf too hard
20:04:17 <dmwit> Needs more lift.
20:04:27 <Nafai> dmwit: Yeah, since it is in a Maybe, it's fine to call whenever
20:04:45 <dmwit> Nafai: Lovely.  My suggestion is to call that at the beginning.
20:04:55 <sw17ch> hello all!
20:05:03 <dmwit> Nafai: Then case (sel, firstItem) of (Nothing, Just iter) -> ...; _ -> return ()
20:05:15 <dmwit> Simple, and readable.
20:05:18 <zeno__> how to get Data.Time.Clock in ubuntu?
20:05:34 <paczesiowa> oldtime ?
20:05:39 <dmwit> zeno__: Dunno, I already have it.
20:05:41 <dmwit> (on ubuntu)
20:05:45 <dmwit> zeno__: What version of GHC?
20:05:51 <dmwit> sw17ch: Hiya!
20:06:03 <Nafai> dmwit: THat is simpler!
20:06:06 * Nafai tries
20:06:34 <paczesiowa> those gtk functions are dangerous - you never know when you'll get critical runtime error
20:07:04 <jdrake> Is there any example of a module that serializes and deserializes to JSON?
20:07:07 <cjs> zeno__: I do believe you need to install some sort of "ghc-all-the-other-stuff" package as well as the basic GHC package.
20:07:17 <dmwit> Ah, that might be.
20:07:41 <rwbarton> @hackage json
20:07:42 * dmwit sudo apt-get install libghc6-*-dev on every new install
20:07:45 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/json
20:07:54 <EvilTerran> Nafai, http://hpaste.org/11024 is what i'm thinking
20:08:16 <dmwit> too complicated
20:09:02 <paczesiowa> MaybeT is MonadPlus?
20:09:09 <EvilTerran> sure
20:09:11 <mmorrow> "<jdrake> Is there any example of a module that serializes and deserializes to JSON?"
20:09:21 <EvilTerran> i think so
20:09:22 <paczesiowa> iirc it wasn't because it wasn't clear how to do that
20:09:24 <mmorrow> ask rwbarton :)
20:09:32 <jdrake> Does all of the documentation for the modules get put in a specific places?
20:09:39 <sw17ch> rwbarton, how goes the json derive?
20:09:42 <paczesiowa> even though ErrorT is MonadPlus
20:10:12 <paczesiowa> EvilTerran: we are talking about hackage's MaybeT?
20:10:14 <noZone> There's example JSON code in the "Real World" book.
20:10:51 <rwbarton> mmorrow, sw17ch: http://hpaste.org/11025
20:11:15 <dmwit> EvilTerran: I think there's two ways to make MaybeT a MonadPlus, one from the Maybe version of MonadPlus, and one from the T version of MonadPlus.
20:11:56 <paczesiowa> dmwit: just like ErrorT, and that uses Either version
20:12:54 <zeno__> dmwit: 6.8.2
20:12:57 <EvilTerran> i thought it was "instance Monad m => MonadPlus (MaybeT m) where mzero = return Nothing; x `mplus` y = maybe y (return.Just) =<< x"
20:12:58 <mmorrow> rwbarton: rad
20:13:17 <EvilTerran> er, modulo MaybeT value constructors
20:14:05 <zeno__> cjs ok thx
20:14:06 <EvilTerran> instance Monad m => MonadPlus (MaybeT m) where mzero = MaybeT$ return Nothing; MaybeT x `mplus` MaybeT y = MaybeT$ maybe y (return.Just) =<< x
20:14:32 <mmorrow> rwbarton: i just started to use {} instead of _ _ _ _ and it friggin great
20:14:33 <EvilTerran> dmwit, i feel the Maybe version makes far more sense, seeing as that's kinda the reason why you'd use MaybeT
20:14:36 <sw17ch> how does one know when it's okay to use unsafePerformIO?
20:14:40 <rwbarton> mmorrow: Oh, neat
20:14:45 <mmorrow> ctor@(InfixC {})
20:14:56 <paczesiowa> EvilTerran: that makes more sense than the other way around but it's not done in MaybeT package
20:14:57 <mmorrow> isn't that just sooo swwell
20:15:02 <dmwit> EvilTerran: I'm generally with you.
20:15:05 <sw17ch> Specifically, i'd like to do something similar to the SockAddrInet Show instance here: http://haskell.org/ghc/docs/latest/html/libraries/network/src/Network-Socket.html#SockAddr
20:15:06 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/4nv9w2
20:15:48 <mmorrow> and another great thing about it is that the arity of those cons can be changed without breaking that code
20:17:21 <mmorrow> sw17ch: i think only after using it and having everything go wrong
20:17:34 <sw17ch> :)
20:18:06 <dons> haskell is ready, bring it on, http://www.reddit.com/r/programming/comments/762fl/adopting_functional_programming_or_just_why_did/
20:18:08 <lambdabot> Title: Adopting functional programming (or “Just why did people start using Python an ..., http://tinyurl.com/3gr7c4
20:18:25 <mmorrow> oh, with ffi it's needed a bunch
20:18:52 <mmorrow> and there there's usually no having to worry about how it's going to interact with laziness
20:19:17 * sw17ch is constantly mad when IO throws exceptions...
20:19:28 * sw17ch or... is mad until he finds a way not to do it in IO
20:20:03 <Cale> sw17ch: If it's IO code that's throwing exceptions, that's easy
20:20:11 <Cale> You can use catch to catch them.
20:20:24 <Cale> It's when non-IO code throws exceptions when things are annoying :)
20:20:29 <sw17ch> Cale: I know :( ... but something in me hates the try/catch paradigm
20:21:52 <jdrake> Text.JSON has a decode function that returns a JSON a => Result a; where Result is here: http://hackage.haskell.org/packages/archive/json/0.3.3/doc/html/Text-JSON.html#t%3AResult   I am wondering how you actually get your data accessible.
20:21:58 <lambdabot> Title: Text.JSON, http://tinyurl.com/5j5gdg
20:22:34 * sw17ch points out that Network.Socket needs IO to convert "10.0.0.1" from a string to an IP address
20:22:54 * sw17ch becomes frustrated and is tempted to write his own network stuff conversion library
20:23:04 <Olathe> It does ?
20:23:16 <Cale> jdrake: Well, Result isn't very different from Maybe
20:23:19 <Olathe> Does it do www.google.com using the same function ?
20:23:22 <sw17ch> inet_addr
20:23:27 <sw17ch> no
20:23:28 <Cale> jdrake: You use case to pattern match, and handle the error
20:23:28 <rwbarton> jdrake: Just pattern match the Ok away
20:23:30 <Olathe> Weird.
20:23:37 <sw17ch> Olathe: ^
20:23:53 <Cale> case decode foo of
20:24:03 <jdrake> let (Ok a) = decode ...?
20:24:05 <Cale>    Error str -> ...
20:24:05 <sw17ch> Olathe, i could understand if i needed to do IO for a DNS lookup, but just (String -> HostAddr)
20:24:07 <sw17ch> grrr
20:24:09 <Cale>    Ok x -> ...
20:24:23 <jdrake> oh, I think I can dig that
20:24:41 <Olathe> The plural of ok is ox.
20:24:50 <EvilTerran> mmorrow, ctor@InfixC{}
20:24:51 <Cale> Olathe: haha
20:24:54 * sw17ch considers throwing out his current model and trying something else
20:24:57 <EvilTerran> you don't need the parentheses
20:25:05 <paczesiowa> sw17ch: I knew you would turn to white/bright side of the exception mechanism with ErrorT:>
20:25:23 <mmorrow> EvilTerran: ooh, that's nice
20:26:02 <sw17ch> paczesiowa, ErrorT changed my life. I now go around and knock on doors trying to explain taht there's a better way. They usually take the paper on ErrorT I hand them, hand it to their dog, and tell me to get lost... they don't like us "religious types" telling them how to handle their errors
20:26:28 <mmorrow> , src ''ErrorT
20:26:29 <paczesiowa> Aaay-man brother!
20:26:33 <lunabot>  newtype ErrorT e m a = ErrorT {runErrorT :: (m (Either e a))}
20:27:09 <Olathe> Oh yeah !? Well, you can't prove that ErrorT doesn't exist !!
20:27:19 <Olathe> Oh, wait...wrong discussion.
20:27:24 <geezusfreeek_> does anybody know if there is a standard function that resembles ((a -> a -> a) -> [a] -> [a] -> [a]) of (Monoid a => [a] -> [a] -> [a]) but differs from zipWith in that the remainder of the longer list is in the result?
20:27:34 <sw17ch> if only people could see the benefit of letting the Transformer handle their errors! You are freed from the huge burden of your error patterns!
20:27:43 <geezusfreeek_> s/) of (/) or(/
20:27:45 <mmorrow> freeeeee3d!
20:27:50 <sw17ch> It takes it all, lifts it off your back! You're so free!
20:28:07 <paczesiowa> sw17ch: but you do know that it's not perfect?
20:28:07 <EvilTerran> geezusfreeek_, no such thing, unfortunately
20:28:11 <Saizan> sw17ch: between exceptions in IO and ErrorT + IO i don't see much difference
20:28:26 <paczesiowa> sw17ch: don't listen to him!
20:28:30 <Olathe> Haha
20:28:44 <paczesiowa> lies all lies!
20:28:46 <sw17ch> haha, well, it didn't take long for that religious movement to get shot down by non-believers. soon you'll be calling for the separation of Transformers and Compilers!
20:29:00 <geezusfreeek> EvilTerran: :(
20:29:21 <sw17ch> bah, no really. i'm not going to save IP addresses any more... i'm going to save strings, and convert them when i need them
20:29:24 <sw17ch> much easier that way
20:29:25 <EvilTerran> ?type \xs ys -> zipwith mappend (zipWith mappend xs (ys ++ repeat mempty)) (zipWith mappend (xs ++ repeat mempty) ys)
20:29:26 <lambdabot> Not in scope: `zipwith'
20:29:33 <EvilTerran> ?type \xs ys -> zipWith mappend (zipWith mappend xs (ys ++ repeat mempty)) (zipWith mappend (xs ++ repeat mempty) ys)
20:29:34 <lambdabot> forall a. (Monoid a) => [a] -> [a] -> [a]
20:29:56 <EvilTerran> geezusfreeek, that'd work if your monoid satisfies forall x. x `mappend` x = x
20:30:16 <EvilTerran> gotta be some more elegant way of getting the length of the longer list, though
20:30:19 <geezusfreeek> it doesn't
20:30:53 <geezusfreeek> i'll get it. i was just hoping my work might be done for me
20:31:10 <dmwit> zipWithTail f [] xs = xs; zipWithTail f xs [] = xs; zipWithTail f (x:xs) (y:ys) = f x y : zipWithTail xs ys
20:31:20 <mmorrow> @quote zip
20:31:21 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
20:31:29 <EvilTerran> ?type \xs ys -> zipWith3 (const mappend) (() <$ xs `max` () <$ ys) xs ys
20:31:30 <lambdabot>     Couldn't match expected type `f b' against inferred type `()'
20:31:30 <lambdabot>     In the second argument of `(<$)', namely `xs `max` ()'
20:31:30 <lambdabot>     In the first argument of `(<$)', namely `() <$ xs `max` ()'
20:31:36 <geezusfreeek> :t zip <*> tail
20:31:37 <lambdabot> forall b. [b] -> [(b, b)]
20:31:45 <geezusfreeek> oic
20:31:57 <EvilTerran> ?type \xs ys -> zipWith3 (const mappend) ((() <$ xs) `max` (() <$ ys)) xs ys
20:31:59 <lambdabot> forall b. (Monoid b) => [b] -> [b] -> [b]
20:32:04 <EvilTerran> aha!
20:32:23 <EvilTerran> geezusfreeek, owzat?
20:32:39 <EvilTerran> er, apart from unfinished
20:32:39 <dmwit> WTF?
20:32:50 <EvilTerran> ?type \xs ys -> zipWith3 (const mappend) ((() <$ xs) `max` (() <$ ys)) (xs ++ repeat mempty) (ys ++ repeat mempty)
20:32:51 <lambdabot> forall b. (Monoid b) => [b] -> [b] -> [b]
20:32:54 <geezusfreeek> EvilTerran: i was referring to the above quote
20:33:03 <geezusfreeek> oh, you were asking about your solution
20:33:19 <EvilTerran> dmwit, (() <$ xs) `max` (() <$ ys) produces a [()] the same length as the longer of the two lists
20:33:46 <EvilTerran> dmwit, then, with the (++ repeat mempty)s, the result list will be the length of the longer list
20:34:10 <dmwit> let zipWithTail f xs ys = let n = max (length xs) (length ys) in zipWith f xs ys ++ drop n xs ++ drop n ys
20:34:13 <EvilTerran> ?src (<$)
20:34:14 <lambdabot> (<$) = (<$>) . const
20:34:33 <dmwit> EvilTerran: Yeah, I got it.  It just took me a few reads.
20:34:52 <EvilTerran> it's needlessly clever :P
20:35:03 <EvilTerran> but works on infinite lists, unlike taking the length as an Int
20:35:03 <dmwit> ?type \f xs ys -> let n = max (length xs) (length ys) in zipWith f xs ys ++ drop n xs ++ drop n ys
20:35:04 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a] -> [a]
20:35:14 <dmwit> Yeah, the less clever version is shorter, more readable, and more general. =P
20:35:21 <dmwit> ah
20:35:22 <geezusfreeek> which is great, because i need it to work on infinite lists :)
20:35:25 <dmwit> That's a good point.
20:35:34 <dmwit> Well, my first one works on infinite lists. =)
20:35:42 <dmwit> aha!
20:35:44 <EvilTerran> ?type \f xs ys -> zipWith3 (const f) ((() <$ xs) `max` (() <$ ys)) (xs ++ repeat mempty) (ys ++ repeat mempty) -- what's that about general?
20:35:46 <lambdabot> forall d b b1. (Monoid b1, Monoid b) => (b -> b1 -> d) -> [b] -> [b1] -> [d]
20:35:49 <EvilTerran> er
20:35:59 <EvilTerran> yes, that would require some tweaking
20:36:04 <geezusfreeek> yeah i am leaning towards something like dmwit's first one
20:36:10 <dmwit> ?type \f xs ys -> let n = length (zip xs ys) in zipWith f xs ys ++ drop n xs ++ drop n ys -- works with infinite lists!
20:36:11 <lambdabot> forall b. (b -> b -> b) -> [b] -> [b] -> [b]
20:36:32 <geezusfreeek> ooh yay
20:36:46 <EvilTerran> does it?
20:36:58 <EvilTerran> ?type (\f xs ys -> let n = length (zip xs ys) in zipWith f xs ys ++ drop n xs ++ drop n ys) (,) [1..] [1..]
20:36:59 <lambdabot>     Occurs check: cannot construct the infinite type: b = (b, b)
20:36:59 <lambdabot>       Expected type: b -> b -> b
20:36:59 <lambdabot>       Inferred type: b -> b -> (b, b)
20:37:08 <EvilTerran> > (\f xs ys -> let n = length (zip xs ys) in zipWith f xs ys ++ drop n xs ++ drop n ys) (+) [1..] [1..]
20:37:09 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
20:37:17 <EvilTerran> oh, of course it does
20:37:29 <dmwit> Laziness FTW!
20:37:34 <b-04> hello
20:37:36 <b-04> bots
20:37:36 <EvilTerran> that's very clever in several ways
20:37:37 <geezusfreeek> never needs the length if it's infinite!
20:37:42 <idnar> oh awesome
20:37:43 <Pseudonym> Epic infinite fail!
20:37:45 <dmwit> yay!
20:37:58 <EvilTerran> the  ++ drop n xs ++ drop n ys is very clever too, relying as it does on at most one being non-empty
20:38:03 <dmwit> right
20:38:15 <dmwit> and the zipped length being just what we need to drop
20:38:18 <dmwit> =)
20:38:18 <geezusfreeek> unfortunately it wouldn't play nice with the GC
20:38:24 <dmwit> ah
20:38:27 <dmwit> No, it would not.
20:38:39 <EvilTerran> for that, you're gonna be using explicit recursion
20:38:42 <geezusfreeek> yeah
20:38:44 <EvilTerran> or an attribute grammar :)
20:38:48 <dmwit> b-04: Hiya!
20:38:56 <geezusfreeek> which is why i am still leaning toward dmwit's first one
20:39:14 <rwbarton> Someone with derive and a recent ghc installed want to try to replicate this panic?  http://hpaste.org/11026
20:42:15 <zeno__> odd ghci isnt finding modules in the same directory
20:43:03 <mmorrow> at least it gave some good positional info: http://hpaste.org/11026#a1
20:44:22 <mmorrow> zeno__: it also depends on where you are /and/ how the modules are named /and/ on how they refer to each other
20:45:51 <dmwit> zeno__: If you want it to find module Foo.Bar, it has to be named Bar.hs and located at in a directory under the current one called Foo.
20:46:03 <mmorrow> i usually cd .. to the root of the code dirtree, because all kinds of crazy things when you try to :l at arbitrary places in the tree
20:46:27 <mmorrow> it's a jungle in there
20:46:29 <zeno__> ok thanks
20:48:48 <geezusfreeek> well thanks for the help EvilTerran and dmwit
20:50:43 <zeno__> which to install first cabal install or cabal
20:51:05 <dmwit> cabal install
20:51:15 <zeno__> k, ty
20:51:21 <dmwit> install cabal install then cabal install cabal
20:51:43 <zeno__> man darcs is slow
20:51:44 <dmwit> That sentence just zips off the tongue. =)
20:51:54 <dmwit> Man, yes it is.
20:58:22 <zeno__> > filter ((> 2) . length) (tail (filterM (const [True, False]) ["cabal", "install", "cabal", "install"]))
20:58:23 <lambdabot>   [["cabal","install","cabal"],["cabal","install","install"],["cabal","cabal"...
20:59:27 <gmaslov> so I wrote a nice little CGI program to accept darcs patches pushed via an HTTP POST and apply them to the server-side repository. I was feeling very proud of myself, then I discovered darcs-server. there really are no original ideas :(
21:00:18 <zeno__> hmmm im writing a bittorrent tracker in haskell, wonder if thats been done before
21:02:00 <geezusfreeek> "man darcs" isn't that slow for me ;)
21:02:02 <Saizan> zeno__: cool, i guess implementing the client side of the protocol is much more work?
21:02:07 <Cale> zeno__: I think there was a client.
21:02:18 <Cale> But I'm not sure about a tracker.
21:05:11 <jdrake> How can I simply use decode :: JSON a => String -> Result a  in the repl? I want to see what it returns and associated types.
21:07:17 <Saizan> jdrake: :info JSON to see the instances of that class
21:07:47 <Saizan> jdrake: then you can do decode somestring :: Result SomeInstanceOfJSON
21:09:19 <zeno__> hmmm i needed http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib for cabal-install, downloaded the tar.gz how to install it?
21:09:20 <lambdabot> Title: HackageDB: zlib-0.4.0.4
21:09:33 <jdrake> The problem is: I don't know what type it would go as
21:09:46 <mauke> zeno__: step 1: unpack it
21:09:50 <rwbarton> jdrake: It's up to you to choose the type
21:09:59 <zeno__> mauke: did
21:10:15 <mauke> zeno__: do you want to install it in your home directory or globally?
21:10:33 <zeno__> home
21:11:10 <mauke> runhaskell Setup configure --user --prefix=/where/stuff/should/go
21:11:17 <jdrake> ok, there is this: instance (JSON a) => JSON [a] -- Defined in Text.JSON   but  decode $ encode m2 :: Result [a]  fails    with  Could not deduce (JSON a) from the context ()
21:11:20 <Saizan> zeno__: there's also bootstrap.sh in cabal-install's tarball
21:11:23 <mauke> e.g. --prefix=$HOME/usr
21:11:39 <zeno__> Saizan: it needed zlib first
21:11:43 <zeno__> mauke: thanks
21:12:25 <Saizan> zeno__: bootstrap.sh is a simple script that installs the needed dependencies for you, without using cabal-install
21:12:46 <Saizan> jdrake: you've to choose a type for that 'a' too
21:13:03 <Saizan> jdrake: what's the type of m2?
21:13:16 <jdrake> m2 :: Map [Char] Integer
21:13:31 <jdrake> fromList [("PKD",59),("PKE",38493)]
21:13:45 <zeno__> Saizan: i do that and Setup: At least the following dependencies are missing: zlib >=0.4
21:14:00 <jdrake> encode m2:  "[[\"PKD\",59],[\"PKE\",38493]]"
21:14:55 <Saizan> ok, so decode (encode m2) :: Result (Map String Integer) should work
21:15:14 <Saizan> zeno__: uhm, that's a bug then
21:16:00 <jdrake> Saizan, you are awesome!
21:22:22 <shapr> Hey, what sort of highly portable laptop would people recommend for Haskell dev?
21:22:40 <Nafai> Hi shapr!
21:22:41 <shapr> I want to install Linux on some sort of small but powerful laptop.
21:22:44 <shapr> hiya Nafai!
21:22:55 <idnar> @type getArgs
21:22:56 <lambdabot> Not in scope: `getArgs'
21:23:02 <bos> thinkpad x200
21:23:37 <shapr> bos: Any particular reason?
21:23:39 <mauke> :t System.Environment.getArgs
21:23:40 <lambdabot> IO [String]
21:23:41 <shapr> Oh, guess not :-)
21:25:29 * geezusfreeek is kind of liking smallcheck
21:27:42 <idnar> @pl \x -> (foo x) >>= bar >>= baz
21:27:43 <lambdabot> (baz =<<) . (bar =<<) . foo
21:30:25 <sw17ch> can anyone see anything wrong with this?
21:30:26 <sw17ch> http://haskell.org/ghc/docs/latest/html/libraries/network/src/Network-Socket.html#SockAddr
21:30:27 <sw17ch> woops
21:30:27 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/4nv9w2
21:30:31 <sw17ch> catch_to_maybe f a = catch (f a >>= (return . Just)) (\_ -> return Nothing)
21:30:32 <sw17ch> that
21:31:11 <sjanssen> @type Control.Exception.catch
21:31:12 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
21:31:13 <shapr> Actually, I think the thinkpad x200 is a really excellent choice!
21:31:35 <sjanssen> sw17ch: looks okay
21:31:56 <sw17ch> sjanssen, thanks.... i'm using that in combination with unsafePerformIO to make inet_addr and inet_ntoa work the way i want them to
21:32:21 <sw17ch> they are both re-entrant and threadsafe (AFAIK), so that should be okay, right?
21:35:46 <sjanssen> sw17ch: but they're not pure
21:36:06 <sw17ch> sjanssen: they aren't?
21:36:13 <sjanssen> sw17ch: inet_addr will return different results depending on the state of your DNS
21:36:22 <sjanssen> oh, nevermind
21:36:35 <sjanssen> inet_addr is just a parser
21:36:43 <sw17ch> i thought so.... you scared me for a second
21:36:53 <sjanssen> yeah, I'm wrong
21:37:03 <sw17ch> well, you're forgiven.
21:37:04 <sw17ch> :P
21:37:26 <mmorrow> hallllelllujahh!!!
21:38:38 <sw17ch> Or, should I say, you can be forgiven, if you accept the teachings of ErrorT and it's chosen prophets
21:39:04 <mmorrow> ErroRTelling me I AM Saved!
21:39:13 * Saizan wonders if there's a free applicative functor as well as a free monad
21:40:00 <ddarius> Saizan: Sure.
21:40:02 <sw17ch> mmorrow, we need to refine this and put it in the humor section of the wiki
21:40:22 <mmorrow> sw17ch: heh, i'm definitely laughing
21:41:32 <Saizan> ddarius: how does that look?
21:41:54 <sw17ch> mmorrow, i hadn't noticed the similarities until tonight...
21:42:03 <jdrake> What is the best way to create a map that does not involve creating a lot of variables to do it, but also not doing function call within functional call (like insert $ insert $ singleton)
21:42:21 <sw17ch> but if my mother ever found out that my handle is 'sw17ch', and came to the internet to see what i say... i may find my self in some trouble
21:42:37 <sw17ch> jdrake: is there a fromList?
21:42:37 <ddarius> Saizan: I think the Applicative paper or one of it's offshoots discusses such a thing, if not I'd have to figure it out.  It may or may not render nicely into Haskell, but probably does.
21:42:50 <ddarius> (or I could be wrong, but I don't think so)
21:43:00 <jdrake> sw17ch, there is
21:43:16 <zeno__> ok with multiple version of cabal-install ./bootstrap.sh i get missing dependencies: zlib >=0.4, what to try
21:43:25 <jdrake> ok, I see how it would work great
21:43:28 <sw17ch> jdrake, is that what you're looking for?
21:43:37 <jdrake> It will work
21:43:43 <Saizan> ddarius: i'll look around, thanks
21:44:02 <jdrake> I liked how the interface to HashTable looked, quite imperative
21:44:16 <mauke> heh
21:44:45 <jdrake> But somebody told me not to use it
21:45:03 <sw17ch> jdrake, yeah... it's bad
21:45:14 <jdrake> I am not sure why it is bad though
21:45:30 <mauke> it's imperative
21:46:07 <ddarius> Saizan: You could figure it out yourself.
21:46:21 <jdrake> mauke, I am in the middle of a do block
21:46:32 <mauke> so?
21:47:00 <mauke> > do { x <- [1 .. 0]; guard (even x); return x }
21:47:01 <lambdabot>   []
21:47:04 <mauke> > do { x <- [1 .. 10]; guard (even x); return x }
21:47:05 <lambdabot>   [2,4,6,8,10]
21:47:23 <jdrake> mauke, The Bible says that the world was created in 7 days - an imperative process; Thus to be imperative is divine; thus how can HashTable be bad?
21:47:34 <mauke> because it's slow
21:47:52 <jdrake> Yeah, I suppose 7 days to create the world is a little long
21:48:00 <lament> the world was evaluated in 6 days, and on the 7th god collected garbage?
21:48:16 <jdrake> lament, I like that one
21:48:49 <mmorrow> , flip runState (0,1) [$mc| [ m | (m,n) <- get , () <- put (n,m+n) ] |]
21:48:52 <Elly> jdrake: even pure algorithms still have runtime
21:48:54 <lunabot>  (0,(1,1))
21:49:18 <idnar> woo, monad comprehensions
21:49:27 <mmorrow> yeehaw!
21:49:40 <mauke> how do I comprehended monads?
21:50:16 <jdrake> mauke, it is not possible
21:50:30 <mmorrow> [$mc| .... |]  maps the inner monad comprehension to a valid do block
21:50:36 <mmorrow> , pDoc' `fmap` elimCompQ "[ m | (m,n) <- get , True]"
21:50:37 <lunabot>  luna: Not in scope: `pDoc''
21:50:41 <idnar> with template haskell lol
21:50:41 <mmorrow> , ppDoc' `fmap` elimCompQ "[ m | (m,n) <- get , True]"
21:50:46 <lunabot>  do (m, n) <- get
21:50:46 <lunabot>     guard True
21:50:46 <lunabot>     return m
21:50:49 * sw17ch finally fixed his type error, but then -Wall ruined his night
21:50:55 <jdrake> mauke, you are M mauke and you cannot comprehend M like the string can't see IO
21:51:39 <mauke> withCString code (mkFun . castPtrToFunPtr)
21:51:49 <mauke> -- make the string see io
21:52:05 <mmorrow> -- make the string /be/ io
21:52:34 <Nafai> Is there an equivalent to this call in gtk2hs? http://library.gnome.org/devel/gdk/stable/gdk-Windows.html#gdk-window-set-override-redirect
21:52:43 <lambdabot> Title: Windows, http://tinyurl.com/4sdcsg
21:53:05 <jdrake> What functions are there that I can make directories, determine if directories are in existence, what the user's directory is, opening a file and outputing to it?
21:53:36 <sjanssen> @docs System.Directory
21:53:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Directory.html
21:53:37 <mmorrow> mauke: sadly something changed over the last two months, and that code segfaults in ghci now :(
21:53:44 <mmorrow> i blame libffi
21:54:15 <mmorrow> although i know nothing about it, i can't imagine what else could have changed
21:54:21 <sjanssen> @docs System.IO
21:54:22 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
21:54:26 <sjanssen> @docs System.Env
21:54:26 <lambdabot> System.Env not available
21:54:36 <sjanssen> @docs System.Environment
21:54:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Environment.html
21:54:39 <jdrake> Perfect
21:56:02 <idnar> > flip runState (0,1) $ do (m,n) <- get; () <- put (n,m+n)
21:56:03 <lambdabot>       The last statement in a 'do' construct must be an expression
21:56:13 <idnar> > flip runState (0,1) $ do (m,n) <- get; () <- put (n,m+n); return m
21:56:14 <lambdabot>   (0,(1,1))
21:58:23 <lispy> dons: ping?
21:58:47 <lispy> dons: I have a draft of my abstract for the talk and I wondered if you would mind looking it over
21:58:48 <mmorrow> , flip runState (0,1) (replicateM 20 [$mc| [ m | (m,n) <- get , () <- put (n,m+n) ] |])
21:58:50 <hackage> Uploaded to hackage: HTTP 3001.1.3
21:58:53 <lunabot>  ([0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181],(6765,...
22:04:57 <dons> you lispy.
22:05:01 <dons> yo'
22:05:04 <dons> send it over.
22:06:36 <lispy> kk
22:07:20 <dons> (i'm sure it is fine :)
22:09:35 <lispy> I'm not, it sounds a bit depressing :)
22:13:53 <Cale> lispy: what are you going to talk about?
22:14:45 <dons> ok. i think we can cut the depressing stuff :-) even with winter coming on in portland, there's still a bit of sunshine
22:15:31 <lispy> dons: haha, yeah...making your changes now
22:16:07 <mornfall> : - )
22:16:29 <mornfall> Good luck.
22:16:33 <mornfall> --> Uni.
22:16:52 <lispy> Cale: type safe manipulations of changes in darcs
22:17:49 <jdrake> Is there any way of having a multiline string where you could output your program usage?
22:17:58 <jdrake> Or will regular quotes do it
22:18:22 <Cale> jdrake: You can use string gaps, but usually I just use unlines, and then a list of the strings for each line
22:18:22 <mmorrow> myString = concat
22:18:34 <mmorrow> err, i meant unlines
22:18:38 <mmorrow>   [ "aserfgt"
22:18:40 <mmorrow>   , ...
22:18:54 <jdrake> What are string gaps?
22:18:57 <bbs> i froze vim!
22:19:09 <rwbarton> mmorrow: you could write a quasiquoter to do it
22:19:32 <mmorrow> true. that'd be dead easy too
22:19:46 <mmorrow> here :: Quasiquoter
22:20:08 <lispy> string gaps make me sad
22:20:09 <mmorrow> here = QuasiQuoter toExpQ (\_ -> "zomg")
22:20:33 <lispy> to date, it seems as though common lisp is one of the few languages to really do multiline strings well.  I guess python would be second.
22:20:47 <mmorrow>   where toExpQ str = litE . stringL $ str
22:20:50 <pjdelport> yay for triple quoting
22:22:46 <dons> lispy: awesome. thanks!
22:22:51 <lispy> mmorrow: wait, "zomg"?
22:22:58 <dons> lispy: how often do you see martin erwig?
22:22:58 <lispy> dons: thank you for the invite and the proof reading :)
22:23:14 <lispy> dons: Not often at all.  He's more of an "on paper" advisor
22:23:17 <dons> i should get him to come visit.
22:23:24 <dons> but i guess its a bit of a drive.
22:23:32 <lispy> I do like Martin, and I would have liked to been of his students.
22:23:50 <lispy> I mean, fully his student and not co-advised
22:24:17 <lispy> dons: I could try to put a bug in his ear about it
22:24:39 <lispy> "Like, hey, I gave a talk there and it was really nice, you should give one too..."
22:25:20 <lispy> dons: I guess living far away from my university makes it harder to see my advisors too :)
22:27:59 <mmorrow> haskell and multiline Strings http://hpaste.org/11027
22:28:05 <adu> I think I finally understand fusion
22:28:07 <mmorrow> haskell winz!
22:28:36 <lispy> adu: I wanted to talk to you about the code you showed earlier
22:28:41 <lispy> adu: I was thinking about it a bit
22:28:45 <adu> lispy: oh ok
22:29:13 <lispy> adu: I think you could make it easier to work with if you could reduce the number of data construcors in the Sep type
22:29:19 <mmorrow> lispy: hrm?, "zomg \"zomg\""!
22:29:23 <lispy> adu: you have the IsSep data type, right?
22:29:41 <lispy> gah, type class, sorry
22:29:41 <adu> lispy: Sep a datatype IsSep a typeclass
22:30:13 <adu> right
22:30:23 <lispy> adu: right, i mispoke.  I was wondering.  Could you make each data constructor correspond to a type that instances IsSep?
22:30:38 <lispy> adu: if so, you may not need mapS'
22:31:12 <adu> lispy: oh, maybe
22:31:50 <lispy> adu: (a -> b) -> (b -> a) -> Sep a -> Sep b, is an odd type.  You're really saying that the custome sep type needs to have a bijective transformation for any types that you map to
22:31:54 <adu> I suppose that would take care of alot of issues...
22:32:12 <lispy> adu: and if you're saying that, then maybe you're not using the right abstractions for what you want
22:33:00 <adu> right, mapS' was a hack, but I do want "sep" and "unsep" to be bijections, that was by design
22:33:52 <lispy> adu: right, okay.  It seems as though you need a way to model that.  This goes back to either Typeable or having sep/unsep in the data constructor, near as I can tell.
22:34:30 <lispy> adu: for example, does the a in Sep a, deteremine uniquely the b in (a -> b) -> (b -> a) -> Sep a -> Sep b?
22:34:35 <adu> I suppose DoSep could be parameterized by the types ((), Char, String, ByteString, (a -> [a]), (a -> [SepInfo a]))?
22:36:06 <lispy> adu: have you see the TypeCast class in the HList paper?  That's what this reminds me of.
22:36:29 <lispy> (but maybe I'm thinking too fancy)
22:36:47 <adu> lispy: TypeCast rings a bell... but I've only skimmed the HList paper 10 times, so i'm no expert
22:36:49 <lispy> I admit, I don't really know how you concretely plan to use your Sep types and classes
22:36:55 <lispy> hehe
22:37:19 <lispy> hehe "only skimmed the [Oleg] paper 10 times, so i'm no expert"
22:37:30 <lispy> I need a shirt that says that
22:41:53 <adu> well you know Haskell
22:42:31 <mmorrow> lispy: heh, i just realized why you said that (duh)
22:42:40 <mmorrow> (\_ -> "zomg") was a mistake ;)
22:42:52 <mmorrow> (\_ -> litP . stringL $ "zomg") was a mistake ;)
22:42:57 <idnar> @type (/)
22:42:58 <lambdabot> forall a. (Fractional a) => a -> a -> a
22:43:00 <mmorrow> s/ was a mistake ;)//
22:43:15 <mmorrow> gah, i love when you make typos while trying to fix typos
22:44:04 <lispy> mmorrow: hehe
22:47:19 <Nafai> dcoutts: Hi
22:48:08 <adu> say you wanted to do some text processing on a haskell source file, and you just wanted all the definitions for "filter", so a custom parser for that might put the type in sepBegin, the definitions in sepMain and the whitespace after it in sepSp, and nothing in sepEnd, so that when "unsep" is called, the entire section can be reconstructed...
22:48:16 <Nafai> dcoutts: Is there an equivalent to this call in gtk2hs? http://library.gnome.org/devel/gdk/stable/gdk-Windows.html#gdk-window-set-override-redirect
22:48:18 <lambdabot> Title: Windows, http://tinyurl.com/4sdcsg
22:48:42 <mornfall> (Recursive typos FTW.)
22:50:20 <lispy> adu: so, Sep is a datastructure which stores a sequence of tokens, and unsep is a way to reconstruct the original data?
22:50:40 <adu> or say for instance that you wanted the first bit of all bytes of a file. you would first do bytes = (sep SepBytes contents) ; bits = (sep SepBit bytes) ; unsep (mapS head bits)
22:50:52 <adu> lispy: ya
22:51:23 <lispy> adu: okay, so it seems as though each Sep should contain it's unsep
22:51:32 <jdrake> What is a general purpose quit function?
22:51:42 <lispy> error ;)
22:51:44 <adu> jdrake: exitWith
22:52:02 <lispy> (I'm teasing, BTW)
22:53:08 <adu> lispy: actually the last one might be (unsep . unsep)
22:53:27 <lispy> adu: What I'm not clear on, is how much information you need to uniquely determine unsep from Sep a.  That is, is the type 'Sep a', enough or do you need to see the data constructor, or do you need to have the actual data inside the Sep a to be able to determine unsep?
22:53:58 <adu> i don't know
22:54:04 <lispy> adu: depending on how you answer that, I think determines how you abstract unsep
22:54:50 <jdrake> If have an args list in the form of [action, ...] how would I be able to delegate a specific function to handle certain actions and have a fail safe, and be able to send the potential tail (...) to the function?
22:55:45 <jdrake> I was wondering if case might be able to work, but I never saw a pattern where a string was prepended to a list
22:55:52 <lispy> jdrake: would an application of this be event processing?
22:56:13 <jdrake> lispy, I do not know
22:56:32 <lispy> jdrake: hmm...do you know what the type is for the list of actions?
22:56:42 <lispy> jdrake: is it just [a] or [Action] or?
22:56:47 <jdrake> Everything is a string
22:56:56 <jdrake> It is from getArgs
22:57:05 <lispy> Okay, so [String]
22:57:22 <rwbarton> jdrake: something like   do (cmd:args) <- getArgs; case cmd of "foo" -> doFoo args; "bar" -> doBar args; _ -> putStrLn ("Unknown command " ++ cmd)
22:57:29 <rwbarton> is that what you mean?
22:57:54 <jdrake> rwbarton, now what happens if getArgs returns ["singleop"]
22:58:06 <lispy> jdrake: then args = []
22:58:07 <rwbarton> jdrake: then args will be bound to []
22:58:13 <adu> lispy: by 'Sep a' being enough, do you mean that the implementation is based completely on whether your type is 'Sep String' or 'Sep ByteString'?
22:58:17 <jdrake> ok, that works for me
22:58:23 <Saizan> the only problem is if getArgs returns [] :)
22:58:27 <lispy> adu: that is correct
22:58:29 <rwbarton> if getArgs returns [], then an error will be raised
22:58:44 <jdrake> How do you deal with errors?
22:58:45 <lispy> adu: in which case, you could nail down unsep with a functional dependency on a
22:58:50 <hackage> Uploaded to hackage: derive 0.1.2
22:59:30 <rwbarton> Well, you should just write an outer case like   do allArgs <- getArgs; case allArgs of [] -> putStrLn "usage: ..."; (cmd:args) -> case cmd of ...
23:00:28 <dcoutts> Nafai: I presume you've checked and there isn't. But it looks easy to bind. So send in your patch now, in time for the next release.
23:01:19 <Nafai> Yeah, I haven't found it yet
23:02:01 <adu> lispy: in that case, I could just have (sep :: (a -> [b]) -> a -> Sep b)
23:02:12 <jdrake> rwbarton, thank you, I can do ("action":xs) -> ...
23:02:12 <adu> lispy: which means DoSep is completely gone
23:03:23 <rwbarton> jdrake: yep.  If "action" takes a fixed number of arguments (say 2) you can even do ["action", arg1, arg2] -> doAction arg1 arg2 and have a general usage message when none of the cases match
23:04:02 <jdrake> I don't think python can do this ;-)
23:04:09 <lispy> adu: well, I dunno. It all depends on what determines unsep :)
23:04:21 <adu> lispy: so by seeing the data constructor do you mean matching on SepGeneral/SepCustom like in what I posted? or you mean accessing values like whether we are concat'ing over ' ' or '\n' ?
23:04:22 <rwbarton> pattern matching ftw
23:05:55 <jdrake> useful: http://netforbeginners.about.com/od/blogchatinstantmessaging/f/whatisFTW.htm
23:05:57 <lambdabot> Title: FTW: "What is 'FTW'? What Does It Mean?", http://tinyurl.com/34v8n4
23:07:03 <lispy> adu: if you just need to see the data constructor but not the values inside it, then I was thinking you could break them out into their own types and mke a type class to bring them back together.  Then you'd have reduced back to the previous case where the type determines unsep
23:08:04 <adu> ya, I actually started implementing it that way
23:12:18 <jdrake> What does "The file is read lazily, on demand, as with getContents. " mean with regards to me getting the contents of this file into a variable?
23:12:55 <lispy> jdrake: getContents uses something we call lazy-io
23:13:52 <jdrake> So it doesn't take initiative?
23:13:53 <lispy> do contents <- getContents; ..., means that it checks that it can read from the file, but it doesn't fill contents with the full contents.  It only reads as much as it needs to into contents...that is on demand
23:14:23 <adu> lispy: you're so smart, it sounds so well designed when you put it like that
23:14:25 <jdrake> So does it read more if you are processing more?
23:14:31 <lispy> jdrake: if getContents was strict-io, then that line would mean that contents would be the *entire* contents of the file after that line
23:15:02 <jdrake> Well, I don't care if it is strict or lazy, I just want my data when I decode it :-)
23:15:09 <lispy> adu: heh, thanks.  I can't take the credit though.  Just been using haskell for a while and reading papers on it :)
23:15:12 <rwbarton> jdrake: It basically means the actual reading doesn't occur until your program observes it in some way
23:15:26 <jdrake> Sounds good enough
23:15:36 <jdrake> The data is a single line anyways.
23:15:50 <jdrake> Now how does this thing deal with IO errors?
23:16:01 <lispy> jdrake: it comes down to 2 things: 1) the performance characteristics of your program 2) when will the file be closed (not a problem with getContents, but is a problem with hGetContents)
23:16:02 <rwbarton> jdrake: There are a few caveats, e.g., don't hClose the file afterwards, unless you're sure you've processed all the data first
23:16:17 <jdrake> Because there is a chance this thing might not exist
23:16:40 <lispy> ?hoogle catch
23:16:41 <lambdabot> package catch
23:16:41 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
23:16:41 <lambdabot> Control.Exception catch :: IO a -> Exception -> IO a -> IO a
23:17:03 <lispy> jdrake: you can catch the exception that might be thrown with Control.Exception.catch (I think that's the right one)
23:17:14 <jdrake> Any examples?
23:17:24 <rwbarton> that type signature should be IO a -> (Exception -> IO a) -> IO a
23:17:39 * rwbarton has never actually bothered with catch
23:17:58 <rwbarton> all my programs' usage messages look like "Irrefutable pattern match failed on line 23" :P
23:18:13 <jdrake> How would I use it with this:       keyfileData <- readFile (configDir </> "ident")
23:18:17 <adu> lispy: so the 2 things I want this for the most is for (foldr mapS) and (fix unsep)
23:18:48 <lispy> jdrake: something like, do contents <- getContents `catch` (\e -> error "Oh noes! no contents!")
23:18:49 <rwbarton> jdrake: well what do you want to do if there's an exception?
23:18:59 <adu> lispy: maybe I should make mapS in the typeclass instead, and have like amillion sep functions
23:19:05 <jdrake> rwbarton, error out
23:19:21 <lispy> adu: perhaps.  I haven't seen your code in a while, but that's a very real possibility
23:21:48 <lispy> jdrake: the thing I don't really like about catch is that you either figure out a graceful way to return nothing or you end up calling error
23:22:31 <jdrake> Does error just quit the program?
23:23:18 <rwbarton> jdrake: just failing to catch the exception will also quit the program with an informative error message, so depending on how "friendly" you want to be, that might be the thing to do
23:23:35 <jdrake> rwbarton, I like friendly errors
23:23:37 <lispy> jdrake: an uncaught error will quit the program
23:23:47 <lispy> jdrake: but error can be caught if you like
23:24:00 <jdrake> ok, erroring out is good for now
23:24:31 <lispy> one feature at a time, right?
23:24:55 <jdrake> basically
23:25:19 <jdrake> I am essentially making a cheap version of gpg for my own program, only signing/verifying
23:27:03 <jdrake> I seem to keep like using # as a omment
23:31:07 <jdrake> :t Maybe
23:31:08 <lambdabot> Not in scope: data constructor `Maybe'
23:36:09 <lispy> data Maybe a = Nothing | Just a
23:37:03 <jdrake> Is there a way that I can have a caught error just return Nothing?
23:37:17 <quicksilver> yes.
23:37:26 <Araneidae> Just experimenting (don't really know the language yet), I wanted to write: type Id a = a; instance Monad Id where ... .  Is it even possible to express this?
23:37:28 <quicksilver> foo `catch` \_ -> return Nothing
23:37:51 <quicksilver> Araneidae: Yes. Not with 'type'. 'type' defines type synonyms, not real types.
23:37:55 <Araneidae> The problem is that I can't express the type constructor \a -> a
23:38:10 <quicksilver> data Id a = Id a or newtype Id a = Id a
23:38:14 <Araneidae> Yes, unfortunately (because I'm being insane) I want this to apply to real types.
23:38:15 <rwbarton> Araneidae: That is correct, type constructors are not lambdas.
23:38:17 <jdrake>     Couldn't match expected type `String'           against inferred type `Maybe a'
23:38:38 <jdrake>     keyfileData <- readFile (configDir </> "ident")       `catch` \_ -> return Nothing
23:38:39 <quicksilver> jdrake: well then your main action wants to return a String.
23:38:43 <quicksilver> jdrake: Nothing isn't a string ;)
23:38:49 <quicksilver> jdrake: you have to make the types match.
23:38:54 <quicksilver> perhaps you want to 'Just' the string.
23:39:23 <quicksilver> Araneidae: 'instance Monad' requires a true type constructor.
23:39:29 <lispy> Araneidae: but you can use newtype and data to apply types and thus similate type level lambdas in some sense
23:39:32 <Araneidae> What I *actually* want to do is write: instance MonadsCommute m1 m2 => Monad (m1 . m2) where ... but I can't express it
23:39:36 <quicksilver> Araneidae: typeclass search proceeeds by checking type constructors.
23:39:41 <jdrake> Here is what I need: A String out of readFile, but if it fails I want to return Nothing from the main do
23:39:47 <quicksilver> Araneidae: so there always has to be an explicit one.
23:39:57 <quicksilver> jdrake: then you want a Maybe String, not a String.
23:39:59 <Araneidae> That's fair enough, but blast, limits what I can express.
23:40:02 <quicksilver> jdrake: String doesn't have Nothing.
23:40:16 <rwbarton> Araneidae: I think if . is a type operator (data (.) m1 m2 x = Composition (m1 (m2 x))) that definition is OK.
23:40:35 <quicksilver> (fmap Just . readFile $ f) `catch` return Nothing
23:40:38 <Araneidae> Ahhh.  rwbarton, can I really write that?
23:40:54 * Araneidae goes to try
23:40:54 <rwbarton> Araneidae: But the type checker isn't ever going to take m1 (m2 x) and unify it against m x with m = m1 . m2.
23:41:03 <rwbarton> Araneidae: I think so, if you turn on TypeOperators
23:41:22 <Araneidae> Good point, I'm asking rather a lot of the typechecker!
23:41:26 <Saizan> infix type names must start with ':'
23:41:33 <lispy> Araneidae: type level lambda makes type checking undecidable, BTW :)
23:41:38 <jdrake> quicksilver, I Am not sure how that line works
23:41:39 * Araneidae wants dependent types too ;)
23:41:42 <rwbarton> Araneidae: You're asking it to be able to evaluate lambda expressions "backwards" :)
23:42:08 <quicksilver> data TypeCompose a b x = O (a (b x))
23:42:13 <quicksilver> then write a `O` b
23:42:31 <Saizan> lispy: we could at least get some combinators though!
23:42:33 <quicksilver> jdrake: the fmap Just wraps the successful result in Just
23:42:38 <Araneidae> Cheers
23:42:44 <quicksilver> jdrake: injecting the String into Maybe String
23:43:45 <jdrake> What does the . do?
23:44:01 <Araneidae> (f . g) x = f (g x)
23:44:08 <earthy> f . g = \ x -> f ( g x )
23:44:19 <lispy> ?src (.)
23:44:19 <lambdabot> (f . g) x = f (g x)
23:44:23 <rwbarton> Araneidae: Saizan is right, you'd have to write m1 :. m2
23:44:46 <quicksilver> jdrake: . just composes two functions.
23:44:51 <quicksilver> jdrake: I could have written that as
23:45:00 <quicksilver> (fmap (Just (readFile f)))
23:45:08 <quicksilver> erm
23:45:10 <quicksilver> sorry
23:45:13 <quicksilver> (fmap Just (readFile f))
23:45:16 <jdrake> What ist he difference between that and $
23:45:17 <quicksilver> like that :)
23:45:23 <lispy> infix type names require a GHC extension, infix data constructors do not, BTW.  So if you go for the infix type name, you'll need to turn on some -XFoo
23:45:26 <quicksilver> $ applys a function to a value.
23:45:42 <quicksilver> actually my preferred way to write it would be
23:45:50 <quicksilver> (Just <$> readFile f)
23:45:56 <quicksilver> but I didn't want to blind you with new operators :)
23:46:21 <lispy> (Just <$> readFile f) `catch` (const Nothing)
23:46:25 <lispy> does it get simpler?
23:46:36 <jdrake> (fmap Just . readFile $ (configDir </> "ident")) `catch` return Nothing
23:46:46 <jdrake> ACtually I like the looks of <$>
23:46:59 <lispy> oh, const (return Nothing), I guess
23:47:13 <jdrake>     (Just <$> readFile (configDir </> "ident")) `catch` return Nothing
23:47:17 <Saizan> `mplus` return Nothing
23:47:29 <jdrake> Now how do I actually get my file data out of this?
23:47:34 <rwbarton> This whole construct should be a library function it seems
23:47:34 <jdrake> case doesn't seem to work
23:47:47 <rwbarton> IO a -> IO (Maybe a)
23:48:01 <Saizan> rwbarton: there's try
23:48:05 <Saizan> ?ty try
23:48:06 <lambdabot> Not in scope: `try'
23:48:09 <lispy> rwbarton: I agree that more of the standard IO lib should have these "checked" exceptions
23:48:15 <Saizan> ?ty Control.Exception.try
23:48:16 <lambdabot> forall a. IO a -> IO (Either GHC.IOBase.Exception a)
23:48:26 <rwbarton> Saizan: Ah, good enough
23:48:57 <jdrake> ok, where does <$> come from?
23:49:09 <Baughn> Applicative
23:49:27 <Baughn> @index <$>
23:49:28 <lambdabot> bzzt
23:49:30 <Baughn> @index (<$>)
23:49:30 <lambdabot> bzzt
23:49:39 * Baughn pokes \bot with a poker
23:49:42 <rwbarton> @index (+)
23:49:42 <lambdabot> Prelude
23:50:01 <lispy> ?hoogle <$>
23:50:01 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
23:50:30 <lispy> ?type fmap
23:50:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
23:50:45 <quicksilver> jdrake: case and <-
23:50:47 <Baughn> @src (<$>)
23:50:47 <lambdabot> f <$> a = fmap f a
23:50:59 <quicksilver> maybedata <-  (fmap Just . readFile $ (configDir </> "ident")) `catch` return Nothing
23:51:13 <quicksilver> case maybedata of Nothing -> "eek there was no data"; Just s -> ...
23:51:24 <lispy> :t catch
23:51:26 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
23:51:43 <Baughn> @type maybe
23:51:44 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
23:51:50 <lispy> I think, 'return Nothing' has the wrong tye.  It needs to be, \e -> return Nothing
23:51:56 <quicksilver> yes, sorry
23:52:01 <quicksilver> you're absolutely right
23:52:11 <quicksilver> I had that in some earlier vrsion and lost it :)
23:52:15 <lispy> ?pl \e -> return Nothing
23:52:15 <lambdabot> const (return Nothing)
23:52:28 * lispy was hoping something weird involving (.)
23:52:45 <lispy> :t (const .) return Nothing
23:52:46 <lambdabot> forall b (m :: * -> *) a. (Monad m) => b -> m (Maybe a)
23:54:46 <jdrake> This is ugly, but it works: http://hpaste.org/11029
23:56:49 <lispy> jdrake: it's not so bad, but ignoring the exception from readFile is arguably worse than not handling it at all
23:57:21 <rwbarton> lispy: then the overall function will return Nothing, that might be acceptable
23:57:31 <Baughn> ..I really want to see that code with an exception-catcher that catches /only/ file-not-found
23:57:33 <jdrake> lispy, I argue that the only reasonable event that will prevent this is there not being a key to load :-)
23:57:48 <Baughn> Right now, it might be ignoring a "your printer is on fire, and your cat just ate your dog" exception
23:58:40 <rwbarton> The overly clever thing to do here is to have someData :: Result String and use the Result monad
23:58:49 <lispy> Baughn: I think that's an excellent point and a place where the java folks have us beat
23:59:15 <humasect> haven't the extensions changed in 10.1 ?
23:59:25 <humasect> exceptions
23:59:34 <Baughn> lispy: We have an exception system that can do just that, though. We just aren't using it.
23:59:55 <Baughn> (Control.Exception, dynamic exceptions)
