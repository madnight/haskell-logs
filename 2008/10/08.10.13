00:01:36 <jsnx> oh, i see now that it isn't at the top of every page
00:01:43 <jsnx> i assumed it was the page header
00:01:59 <jsnx> which usually has title, volume, date, &c.
00:09:51 <Saizan> anyone tried ghci-6.10 with libedit in emacs haskell-mode?
00:11:02 <ivanm> libedit? what's that?
00:11:37 <Saizan> the replacement for readline
00:18:58 <idnar> @type ifM
00:18:59 <lambdabot> Not in scope: `ifM'
00:19:04 <pumpkin_> someone told me how to do this yesterday, but I can't find the paste and can't remember how it worked
00:19:25 <idnar> @type if'
00:19:26 <lambdabot> Not in scope: `if''
00:19:48 <pumpkin_> but if I have a sequence defined by [1, 2] * p^[1..], where p is a prime number
00:19:59 <pumpkin_> how can I generate all its members in order
00:20:08 <idnar> @hoogle m Bool -> a -> a
00:20:08 <lambdabot> Control.Exception assert :: Bool -> a -> a
00:20:09 <lambdabot> Data.Monoid appEndo :: Endo a -> a -> a
00:20:09 <lambdabot> Control.Parallel.Strategies sforce :: NFData a => a -> b -> b
00:20:10 <Cale> What do you mean by * there?
00:20:10 <pumpkin_> a comprehension iterates over my infinite list of primes first, or the infinite list of powers first
00:20:15 <idnar> @hoogle m Bool -> a -> -> a
00:20:15 <lambdabot> Parse error:
00:20:16 <lambdabot>   --count=20 "m Bool -> a -> -> a"
00:20:16 <lambdabot>                             ^
00:20:17 <idnar> err
00:20:19 <idnar> @hoogle m Bool -> a -> a -> a
00:20:20 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
00:20:20 <lambdabot> Test.HUnit.Text PutText :: String -> Bool -> st -> IO st -> st -> PutText st
00:20:20 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
00:20:29 <pumpkin_> Cale: sorry, multiplication by either 1 or 2
00:20:30 <Cale> and by p^[1..] do you mean map (p^) [1..] ?
00:20:38 <pumpkin_> yeah
00:20:57 <pumpkin_> but p is just a prime
00:21:07 <Cale> > [k*5^n | n <- [1..], k <- [1,2]]
00:21:08 <lambdabot>   [5,10,25,50,125,250,625,1250,3125,6250,15625,31250,78125,156250,390625,7812...
00:21:09 <pumpkin_> so iterate over all primes, and multiply all integer powers by 1 or 2
00:21:12 <Cale> ah
00:21:17 <idnar> isn't there some function like that?
00:21:25 <Cale> then you need to diagonalise
00:21:35 <pumpkin_> yeah
00:21:35 <idnar> when is close, but doesn't have the "else"
00:21:48 <rwbarton> idnar: I don't think so
00:22:13 <idnar> actually, I guess the type would be m Bool -> a -> a -> m a or something
00:22:27 <rwbarton> pumpkin_: you can do some kind of merge
00:23:06 <pumpkin_> is there a built-in infinite merge?
00:23:10 <pumpkin_> for in-order lists?
00:23:23 <Cale> no
00:23:35 <pumpkin_> I guess it's relatively easy to write one
00:24:00 <Cale> I wonder if LogicT is in scope
00:24:05 <Cale> :t (>>-)
00:24:07 <lambdabot> forall (m :: * -> *) a b. (MonadLogic m) => m a -> (a -> m b) -> m b
00:24:10 <Cale> oh, good
00:24:50 <rwbarton> > let merge ((x:xs):xss) = x:merge (insert xs xss) in merge [[a*b | a <- [2..]] | b <- [2..]]   -- composites
00:24:51 <Cale> nubBy (\x y -> y `mod` x == 0) [2..] >>- \p -> [1..] >>- \n -> [1,2] >>= \k -> return (k * p^n)
00:24:52 <lambdabot>   [4,6,6,8,8,9,10,10,12,12,12,12,14,14,15,15,16,16,16,18,18,18,18,20,20,20,20...
00:24:54 <Cale> > nubBy (\x y -> y `mod` x == 0) [2..] >>- \p -> [1..] >>- \n -> [1,2] >>= \k -> return (k * p^n)
00:24:55 <lambdabot>   /tmp/3348961404183599066:67:89: Not in scope: `>>-'/tmp/3348961404183599066...
00:25:00 <Cale> er...
00:25:01 <rwbarton> Cale: lunabot has it
00:25:06 <Cale> , nubBy (\x y -> y `mod` x == 0) [2..] >>- \p -> [1..] >>- \n -> [1,2] >>= \k -> return (k * p^n)
00:25:08 <lunabot>  [2,3,4,4,4,9,8,5,8,6,16,16,16,27,32,6,32,18,64,8,64,81,128,25,128,54,256,...
00:25:12 <idnar> @instances MonadLogic
00:25:13 <lambdabot> Couldn't find class `MonadLogic'. Try @instances-importing
00:25:28 <Cale> http://hackage.haskell.org/packages/archive/logict/0.2.3/doc/html/Control-Monad-Logic.html
00:25:36 <lambdabot> Title: Control.Monad.Logic, http://tinyurl.com/4m3yqd
00:26:09 <Cale> or...
00:26:38 <Cale> er, no, it doesn't provide any nicer forms of fair conjunction
00:26:39 <jsnx> with a little quasi-quoting, we could have proskell...
00:26:58 <Badger> Haskell makes a lot of being pure, but isn't the point of any program to take input and provide output?
00:27:01 <jsnx> well, some of it
00:27:02 <Cale> MonadLogic comprehensions ;)
00:27:28 <jsnx> Badger: all of the program, most of the program, or the shell of the program?
00:27:32 <Cale> Badger: You mean a program is a pure function from inputs to outputs? ;)
00:27:35 <pumpkin_> Badger: my understanding is that it relegates all the impurity out of the main logic
00:27:48 <Badger> ah
00:27:58 <Badger> simply mostly pure then :P
00:28:16 <pumpkin_> and you can still see a program as taking input and providing output
00:28:20 <pumpkin_> in some form or another
00:28:20 <Cale> Badger: Even the way in which IO actions (which are impure) are constructed is pure.
00:28:22 <jsnx> Badger: your argument is so general -- by analogy, type systems miss the point because the point of any program is to operate on bits...
00:29:15 <Cale> Badger: The only impure bit is in the execution of IO actions, which is part of the runtime system.
00:29:33 <Cale> In some sense, all that Haskell programs do is describe (in a pure way) what is to be done.
00:29:34 <dons> Badger: the question is about whether impure things should be allowed anywhere in the code, and by default, without warning.
00:29:50 <dons> its like whether uncontrolled gotos should be allowed anywhere in a program
00:30:02 <Badger> ah.
00:30:11 <dons> sure, a program often has to make jumps, but should it be on by default? and allowed anywhere?
00:30:27 <mmorrow> also, it's just so happens that IO is with the outside world
00:30:37 <dons> so for side effects (like IO), we can't do parallelism very well, or optimisations, or reasoning about program,s if they're on by default,
00:30:40 <mmorrow> the world can be faked if you like
00:30:48 <dons> so we make them explicit, rather than implicit
00:30:52 <mmorrow> and code which does IO would be none-the-wiser
00:30:55 <dons> they're not banned, but instead, explicit.
00:31:46 <Badger> I see. Thankyou.
00:33:52 <Cale> Two things I think would be really cool to have: 1) The ability to take any IO action and write it to disk as an executable. 2) The ability to suspend the current entire state of the running Haskell program to disk as an executable.
00:35:05 <dolio> Sounds like EROS.
00:35:20 <dons> 1) is cool.
00:35:32 <dons> clean's 'esther' shell did that (via bytecode)
00:35:43 <dons> your shell actions written on the fly would be saved to disk.
00:35:49 <mmorrow> i think 1 and 2 sound awesome
00:36:06 <mmorrow> i think this can be done with ghc's bytecode
00:36:06 <dons> freezing the ghc rts. sounds like a solved problem in kernel land
00:36:19 <dons> have to work out what the use case is.
00:36:34 <dons> transparently persistant haskell-only programs?
00:36:40 <Cale> yeah
00:36:44 <pumpkin_> what should I search for if I'm looking for documentation of the pipe (|) character in haskell?
00:36:49 <pumpkin_> it's rather hard to look for on gogole
00:36:50 <pumpkin_> google
00:37:00 <pumpkin_> and haskell pipe shows up a whole bunch of random stuff
00:37:02 <dons> pumpkin_: 'guard'
00:37:03 <jeffz> pumpkin_: there's an index for the library documentation
00:37:04 <dons> it is a guard.
00:37:16 <pumpkin_> ah ok
00:37:18 <pumpkin_> thanks!
00:37:21 <mmorrow> yeah, i'm trying to think of use cases..
00:37:27 <earthy> 'Esther' could only do that thanks to the closed world assumption
00:37:30 <dons> f x | x == 2  = 7 | otherwise = 2  -->  f x = if x == 2 then 7 else 2
00:37:33 <Cale> So it would be trivial for any Haskell program to provide the user with the ability to save whatever it was he was working on.
00:37:37 <earthy> i.e. no loading of externally compiled code anymore
00:37:46 <earthy> so all
00:37:54 <earthy> 'extensions' were in bytecode rather than native cod
00:37:55 <earthy> +e
00:37:58 <dons> earthy: ah. so no new libraries added incrementally?
00:37:59 <rwbarton> I've thought about a use case for something similar
00:38:09 <kig> like smalltalk/lisp/slate/insert_image_based_system_here
00:38:09 <mmorrow> Cale: definitely, it'd be sweet for ghci, etc
00:38:10 <earthy> dons: exactly
00:38:15 <dons> that's interesting
00:38:19 <rwbarton> Suppose I run a lot of programs where I want a list of prime numbers
00:38:27 <mmorrow> earthy: you can link in arbitrary machine code once you're up and going in bytecode
00:38:35 <earthy> it was the one nasty question to ask Arjan and Rinus when they presented it
00:38:41 <dons> heh
00:38:43 <rwbarton> I should be able to write in a file    nubBy (\x y -> y `mod` x == 0) [2..]
00:38:54 <Cale> Oh, another thing: The ability to serialise any value without forcing any additional evaluation.
00:39:06 <dons> Cale: that's interesting.
00:39:11 <dons> once you do that, you can do anything.
00:39:14 <earthy> mmorrow: almost true.... they couldn't
00:39:15 <rwbarton> and load it from a program, but any graph reductions that happen get saved back to the file
00:39:22 <rwbarton> So I don't have to ever duplicate those computations
00:39:28 <mmorrow> earthy: oh, just realized you weren't talking about Haskell.. ;)
00:39:33 <earthy> mmorrow: :)
00:39:36 <Cale> dons: Well, that and capturing the continuation somehow, perhaps :)
00:39:47 <pumpkin_> oh I found the paste I was talking about
00:39:48 <pumpkin_> http://hpaste.org/11080
00:39:51 <Baughn> rwbarton: Actually, recalculating primes is likely faster than loading them from file
00:39:53 <earthy> there are other fully lazy functional programming languages out there! :)
00:39:57 <rwbarton> Baughn: In this case, yes.
00:39:58 <Baughn> rwbarton: ..if you use a less horrible algorithm
00:40:03 <pumpkin_> but it isn't working for me... it'll generate 3, 4
00:40:12 <pumpkin_> and then say Exception: <interactive>:1:4-90: Non-exhaustive patterns in function merge
00:40:19 <rwbarton> Baughn: But, the general idea stands
00:40:22 <dons> we don't need more lazy languages, we need more pure languages :-)
00:40:27 <mmorrow> Cale: also, i wanna look into that one scheme webserver that can persist schemelets/whatever. i don't see why the same thing couldn't be done with haskell
00:40:35 <Baughn> We need more lazily pure languages. ^_^
00:40:44 <pumpkin_> we need more lazy people
00:40:45 <Baughn> Or maybe we could just have haskell conquer the world?
00:40:57 <Cale> mmorrow: If you're talking about a continuation-based webserver, yeah, that can be done.
00:41:04 <dons> hey, i note we're beating Clean (finally!) on the multicore shootout.
00:41:10 <dons> hadn't realised that. yaya parallelism
00:41:15 <stepcut> yay!
00:41:19 <pumpkin_> anyone know what my issue with that paste could be?
00:41:24 <stepcut> take that clean!
00:41:36 <dons> only took 20 years :-)
00:41:39 <stepcut> :)
00:41:50 <mmorrow> Cale: totally. there's also some code on oleg's site which does this with ocaml's bytecode
00:41:52 <stepcut> concurrent haskell
00:41:54 <dons> and a change in cpu assumptions.
00:42:20 <earthy> and a change in cpus
00:42:23 <dons> fwiw, we're also beating fortran and C on multicore. so these results are subject to interpretation.
00:42:35 <earthy> concurrent clean was originally written for transputers...
00:42:43 <stepcut> STG vs ABC, who will be the champion!
00:43:00 <dons> ghc too, iirc (or at least, they ran it originally on some funky oxford multicore thingies)
00:43:28 <dons> earthy: is the current clean impl. smp friendly?
00:43:34 <Cale> pumpkin_: uh, what is wrong?
00:43:44 <pumpkin_> Prelude> take 3 vals
00:43:44 <pumpkin_> [3,4*** Exception: <interactive>:1:4-90: Non-exhaustive patterns in function merge
00:43:50 <pumpkin_> after that code
00:43:53 <Cale> pumpkin_: uh...
00:43:58 <Cale> pumpkin_: It works for me.
00:44:01 <pumpkin_> hrm
00:44:19 <Cale> I provided my own definition of primes (just the trivial nubBy one)
00:44:23 <pumpkin_> yeah, me too
00:44:30 <pumpkin_> I'm running mine in ghci
00:44:32 <earthy> dons: not sure
00:44:34 <Cale> me too
00:44:34 <pumpkin_> not sure if it should be different
00:44:36 <pumpkin_> hmm
00:45:03 <earthy> I'd guess it would be, as it takes the 'shared nothing, messages everywhere' approach to concurrency
00:45:22 <earthy> ofcourse, given that you can have higher order functions as messages...
00:45:28 <dons> well, it's a matter also of how many multicore off the shelf systems they had access to the last time the runtime was hacked on.
00:45:33 <pumpkin_> Cale: see anything wrong with http://hpaste.org/11109
00:45:44 * earthy nods
00:45:52 <rwbarton> pumpkin_: that's not how let works
00:45:57 <pumpkin_> oh :(
00:45:57 <Cale> pumpkin_: yes
00:46:00 <dons> doesn't look like any clean programs on the shootout are using more than 1 core (but that might just mean no clean people were involved in those submissions)
00:46:00 <rwbarton> those first two lines get shadowed
00:46:05 <earthy> I'd have to ask Thomas, he's much more current on matters Clean
00:46:06 <pumpkin_> ah, makes sense
00:46:16 <Cale> pumpkin_: It's best not to make any definitions at all from ghci
00:46:18 <earthy> (my knowledge is mostly a decade old already)
00:46:18 <pumpkin_> that'll teach me to reinterpret someone else' code
00:46:32 <jsnx> is clean still active?
00:46:35 <pumpkin_> Cale: what's my alternative?
00:46:39 <pumpkin_> I should write to a file and load it in?
00:46:43 <Cale> pumpkin_: Stick everything in a file, yeah
00:46:49 <Baughn> pumpkin_: And then type :r a lot
00:46:51 <pumpkin_> why are they so different?
00:46:52 <dons> jsnx: papers are still being written.
00:46:57 <jsnx> last i heard, the clean team was working on a haskell compiler...
00:46:59 <pumpkin_> the execution of a file and the interactive prompt?
00:47:08 <Cale> pumpkin_: GHCi is really designed to evaluate expressions.
00:47:10 <pumpkin_> ah
00:47:15 <Cale> Files only permit declarations.
00:47:36 <jsnx> dons: it is at chalmers, right?
00:47:39 <Baughn> Definitions. I still say haskell has no declarations
00:47:51 <rwbarton> pumpkin_: You can imagine that what you enter into ghci is in a do-block in the IO monad
00:48:05 <Cale> (and print is added as necessary)
00:48:06 <rwbarton> pumpkin_: except it adds 'return' before values not of type IO a
00:48:12 <Cale> print!
00:48:14 <rwbarton> Or print, yeah
00:48:39 <dons> jsnx: no, ru.nl
00:48:41 <rwbarton> It's hard to tell.  Both work :)
00:48:42 <Cale> Though, strangely, return does the same thing now, because GHCi prints the result of every IO action.
00:48:49 <Cale> Which is silly.
00:48:54 <earthy> jsnx: you heard 'mostly' right
00:49:03 <earthy> they're writing a Haskell frontend to the Clean compiler
00:49:04 <Cale> (sometimes you really don't want to print it)
00:49:06 <pumpkin_> rwbarton: aha, thanks
00:49:14 <earthy> (and cursing many aspects of Haskell in the meantime :))
00:49:35 <earthy> (I'd have to ask John once what aspects exactly, but I don't get 'round to Nijmegen that often anymore)
00:49:45 <dons> layout :-)
00:50:01 <earthy> no, actually :)
00:50:06 <earthy> Clean also has layout :)
00:50:07 <Cale> I'm always annoyed when I do a mapM or forM in ghci without thinking about whether it should really be mapM_ or forM_ and end up with a ton of results being printed that I don't want.
00:50:14 <dons> earthy: yeah i know :)
00:50:38 <dons> Cale: ah, not enough thought inference.
00:50:50 <dons> you should add some DoWhatIMean annotations
00:50:52 <earthy> but there's sillyness in the Haskell Prelude, e.g.
00:50:56 <Cale> dons: Well, the old ghci did exactly what I mean.
00:51:10 <Cale> dons: If I meant to print the result, I would have added >>= print to my IO action.
00:51:13 * Baughn once typed "f <- readFile "/dev/mem""
00:51:36 <dons> mm. targetting haskell as frontend is a good idea these days -- all those libraries you get access to.
00:51:48 <dons> as long as you implement 90% of ghc's features.
00:52:20 * earthy nods
00:52:38 <earthy> fortunately, the Clean toolchain already has support for most of those features, so it's mostly syntax
00:52:47 <dons> yeah.
00:53:11 <dons> it'd be interesting to see hackage structured as rings of language features. with libs that are pure h98 in the core, then wider circles around as more language features are enabled
00:53:22 <dons> we could actually construct that graph now
00:53:37 <dons> dcoutts_ has a nice programmatic interface to hackage
00:53:50 <dons> needs some polish and tutorials and ... uploading to hackage
00:53:57 <earthy> that'd be nice...
00:53:58 <dons> but then we can do a lot of analysis
00:54:05 <Baughn> ..oh, that'd be nice. I think I've been rewriting it.
00:54:31 <dons> easily answer the questions like "what things use IncoherentInstances" or "how much do i support if i only support X Y and Z"
00:54:54 <Baughn> Or not. How about things like "How many people downloaded bytestring last month"?
00:55:15 <dons> yeah, and lots of dynamic, social properties
00:55:25 <dons> we're working on those already though
00:55:39 <dons> to work out metrics for sorting through hackage for inclusion in the batteries platform
00:55:42 <jsnx> we could just put each package on facebook...
00:55:47 <dons> hehe
00:56:00 <dons> mtl is friends with arrows
00:56:12 <dons> bytestring got poked by Foreign.Storable
00:56:13 <jsnx> parsec has 10,000 friends...
00:56:30 <Baughn> I've ben working out metrics for presenting the hackage library list in a less overwhelming form. Sorting by various measures, especially popularity, would be good..
00:56:31 <dons> utf8-string has 100 new friend requests
00:56:46 <dons> Baughn: i'd love to see any ideas you had
00:56:56 <dons> we've some tickets on the platform trac instance for good metrics for quality
00:57:08 <dons> after ghc 6.10, we'll open up all that to more submission
00:57:09 <dons> s
00:57:32 <Baughn> dons: I haven't really been working on popularity measures as such, mostly javascript to /use/ them
00:58:07 <dons> the tupil guys were designing a search-based frontend to hackage
00:58:12 <dons> have the main interface be a search box
00:58:14 <dons> not a list.
00:58:31 <Baughn> How about a search box, plus a collapsed tree just beneath it?
00:58:41 <dons> maybe.
00:58:50 <mmorrow> yeah, collapsed tree ftw
00:58:56 <dons> we'll need patches to the new hackage server.
00:59:08 <mmorrow> hmm
00:59:08 <Baughn> Nah, we can do that much with pure JS
00:59:40 <Baughn> At least until the page becomes so large you don't want to pay the full bandwidth every time..
01:00:13 <jsnx> then we use AJAX...
01:00:43 <jsnx> with progress meters at each level of the tree :(
01:02:15 * Baughn wonders how many people use IE on hackage
01:02:50 <jsnx> redirect them randomly to opera, firefox, chrome?
01:03:15 <Baughn> We could still serve the static page. It's just, I wouldn't be surprised if the number is close to zero
01:03:28 <Cale> Speaking of ill-advised uses of Javascript, who else is pissed off with the hierarchical libraries index? :)
01:03:57 <jeffz> Cale: in what respect?  I visit it all the time
01:04:04 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/doc-index.html
01:04:08 <lambdabot> Title: Haskell Hierarchical Libraries (Index), http://tinyurl.com/2rgl8s
01:04:17 <Plareplane> is that the one where the javascript search box takes about 5 minutes before you kill it, but the firefox search takes 0.5 seconds?
01:04:22 <Cale> Just try and use that search!
01:04:27 <Baughn> ...what the heck
01:04:27 <Cale> yeah
01:04:41 <Baughn> It's freezing FF. ;_;
01:04:42 <jeffz> oh, I had forgotten that was there, I just use my browser's search
01:04:47 <Cale> hehe
01:04:48 <Cale> me too
01:05:00 <Cale> It used to be nicely broken into alphabetical pages.
01:05:03 <earthy> whoa, a search box. :)
01:05:11 * earthy just goes to hoogle or hayoo :)
01:05:11 <mmorrow> heh  $ sudo strings /dev/mem | less   is somewhat entertaining
01:05:22 <rwbarton> I think there's a bug in the search box.
01:05:24 <Baughn> A /bad/ search box. ;_;
01:05:29 <mmorrow> "Authentication failed and the system is halted! Please restart the system!"
01:05:33 <Baughn> Come to think of it, how do you fork off a thread in JS?
01:05:44 <flux> you don't ;)
01:05:58 <Baughn> ;_;
01:06:28 <mmorrow> Baughn: use continuations
01:06:41 <inimino> use timeouts and continuations
01:07:06 <mmorrow> this paper is probably applicable http://moonpatio.com/papers/interp/jfp99-monad.ps
01:07:54 <mmorrow> write a scheduler in js...sweet!!
01:08:13 <jsnx> make your whole program a list of JS functions that modify the list of JS functions
01:08:31 <Cale> <[;_;]>  <-- Balrog from Doukutsu Monogatari :)
01:09:14 <Baughn> ..cave story.
01:10:18 <tcesto> s.a
01:11:50 <rwbarton> Ah, here we go.  Go to http://hackage.haskell.org/packages/archive/hxt/8.1.0/doc/html/doc-index.html and wait for the page to load fully
01:11:52 <lambdabot> Title: hxt-8.1.0: A collection of tools for processing XML with Haskell. (Index), http://tinyurl.com/497nm4
01:12:07 <rwbarton> Then type (slowly, to see the bug) 'rea' in the Search box
01:12:38 <Baughn> That's a bug?
01:13:18 <rwbarton> I get "No results found" but it seems it should find readDocument, etc.
01:13:29 <Baughn> Ah
01:13:45 <Baughn> It does show readDocument, though
01:14:06 <rwbarton> Hmm... not for me, except inasmuch as it shows everything
01:14:15 <rwbarton> Weird
01:14:29 <jsnx> browsers?
01:14:39 <Baughn> FF 3.0.3
01:14:43 <rwbarton> Firefox 2.0.0.14
01:14:50 <Baughn> Hmm.. it shows readDocument, but then the script freezes
01:20:15 * inimino thoughtlessly opens a 817MiB file in vim just to see one sample line
01:32:18 <hackage> Uploaded to hackage: alex 2.3
01:32:18 <hackage> Uploaded to hackage: happy 1.18
02:09:52 <mopped> Can haskell be used the same way as popular OO languages? (python) as in - web parsing and so on etc :)
02:10:43 <jeffz> ?faq can haskell be used the same way as popular OO languages? (python) as in - web parsing and so on etc
02:10:43 <lambdabot> The answer is: Yes! Haskell can do that.
02:10:58 <mopped> ;o
02:11:05 <mopped> ?faq
02:11:06 <lambdabot> The answer is: Yes! Haskell can do that.
02:11:08 <mopped> :P
02:11:37 <Vq^> "the same way"?
02:12:09 <Vq^> whats the point of that if there is a better way?
02:12:13 <mopped> :P
02:12:30 <mopped> Can you create web scripts with haskell aswell (more like web-hacks)?
02:12:50 <Vq^> sure
02:13:08 <Vq^> not that i recomend that style with any language
02:14:08 <mopped> Well, I mainly use it for little hacks; nothing substantial - but I find functional languages (through my small time with scheme) awesome..
02:14:24 <hugo_> :)
02:14:28 <hugo_> its nice to code in haskell
02:14:47 <hugo_> soft as the morning coffee that wakes you up
02:16:11 <mopped> I'm finishing up scheme so I'm more accustomed with a recursive way of thinking, i've got a book called uh 'Introduction to functional programming using Haskell' iirc, would you reccomend going through with that or using a web tutorial?
02:17:58 <hugo_> hey mopped, i also had scheme on my mind, but i completly forgot it after a few years of C/C++, i have read through the yaht till the monads chapter (which sucks), then i've read a separate monads tut
02:18:15 <hugo_> and also had a lot of help from the guys here in the #
02:18:15 <ivanm> I just borrowed "Programming Erlang" and started reading it, and it claims that Functional programming implies no side effects.... isn't it _purely_ functional programming that implies no side effects?
02:18:39 <Saizan> mopped: if you already feel comfortable with functional programming maybe something more focused on haskell like Read World Haskell might be best, it's also available online
02:18:45 <quicksilver> it's a question of definition, ivanm
02:18:52 <ivanm> *nod*
02:19:00 <quicksilver> ivanm: it would be quite sensible for 'functional' to mean pure
02:19:11 <quicksilver> (because that is the connotation of the mathmetical 'function')
02:19:15 <ivanm> ahhh, so the various lisps are quite definitely not pure then?
02:19:15 <quicksilver> but, generally, it doesn't.
02:19:18 <Saizan> "Real"
02:19:24 <quicksilver> most people consider lisps functional, and MLs.
02:19:36 <quicksilver> it may be the relative scarcity of pure languages that cause this :)
02:19:54 <ivanm> heh
02:19:59 <quicksilver> still, even in the ML community people use 'functional' in that sense.
02:20:01 <hugo_> :P i find myself always sticked to a monad or two in haskell
02:20:13 <ivanm> quicksilver: *nod*
02:20:15 <quicksilver> like "a well designed ML program is divided into a functional part and an imperative part"
02:20:34 <ivanm> erlang's an interesting language... though it needs better syntax and static typing :p
02:21:17 <Axman6> static typ[ing is the only thing i want for erlang
02:21:29 <mopped> ok thanks Saizan hugo_
02:21:33 <Axman6> i get so lost when i don't know what functions are expecting
02:22:04 <ivanm> Axman6: yeah... "items in lists can have any type" makes them more like lisp-lists than haskell lists
02:22:37 <quicksilver> if you add static type to erlang, you get something rather like (strict) haskell with some unusual syntactic sugar.
02:22:52 <Saizan> distributed :)
02:23:08 <qebab> I like erlang
02:23:13 <ivanm> quicksilver: emphasis on unusual? :p
02:23:21 <quicksilver> yes, perhaps.
02:23:21 <qebab> it is good fun to work with
02:23:22 <mmorrow> mopped: here's a basic CGI program
02:23:24 <mmorrow> ghci> :m + Network.CGI Text.XHtml
02:23:24 <mmorrow> ghci> runCGI (output . renderHtml . body . (table <<) . fmap (\(k,v) -> tr << td << toHtml (k ++ ":" ++ v)) =<< getInputs)
02:23:31 <quicksilver> I want a proper frontend separation for GHC
02:23:38 <quicksilver> so we can experiment with different syntaxes for haskell
02:25:27 <mopped> I'll have a look at Real World Haskell :)
02:30:18 <mmorrow> mopped: here's that prog cleaned up and usable: http://hpaste.org/11110
02:30:31 <mmorrow> quicksilver: me too!
02:33:50 <mopped> seems neat mmorrow, just that I don't know what any of it means ;)
02:34:27 <mmorrow> mopped: ah, i see. do you have a haskell compiler handy?
02:34:44 <mmorrow> (and preferably a webserver, but that isn't necessary)
02:35:13 <mmorrow> to build that (it uses libs you probably have if you do), you'd just do
02:35:27 <mmorrow> ghc -O2 --make SimpleCGI.hs
02:39:28 <hugo_> is there any way to insert breakpoints, in order to evaluate possible infinite recursive loops ?
02:39:30 <hugo_> :/
02:39:44 <hugo_> i have this error condition, that might sprawl into an infinite recursion
02:39:54 <papermachine> I wrote a really naive version of gaussian elimination and I don't know where to start refactoring. http://hpaste.org/11111 :/
02:40:39 <jeffz> hugo_: error "foo"
02:40:40 <mmorrow> mopped: here's that same prog with comments http://hpaste.org/11110#a1
02:41:07 <Baughn> hugo_: GHCi also has a stepper
02:45:57 <mopped> mmorrow: is this HTML/td/tr etc part of the libs?
02:46:18 <mopped> getInput etc?
02:47:51 <jeffz> mopped: some are from Text.XHtml
02:48:04 <jeffz> mopped: getInput is from Network.CGI
02:48:10 <mmorrow> mopped: yeah. getInput is in Network.CGI and {table,body,renderHtml,tr,td,toHtml,...} is in Text.XHtml.{Strict or Transitional or ...}
02:48:22 <jeffz> mopped: http://www.haskell.org/ghc/docs/latest/html/libraries/doc-index.html
02:48:24 <lambdabot> Title: Haskell Hierarchical Libraries (Index), http://tinyurl.com/2rgl8s
02:48:30 <mmorrow> (getInput, runCGI, output are all in Network.CGI)
02:48:48 <mopped> giving something to the tr/td function encloses them in said tag does it?
02:49:09 <mmorrow> hmm, one sec.
02:52:10 <mmorrow> mopped: ok, lunabot has Text.XHtml.Strict imported
02:52:39 <mmorrow> so, toHtml turns a String into Html
02:52:44 <mmorrow> , toHtml "asdf"
02:52:46 <lunabot>  asdf
02:53:19 <mmorrow> and (<<) puts the right side which is of type Html "into" the right side
02:53:30 <mmorrow> , table << tr << td << toHtml "asdf"
02:53:32 <lunabot>  <table
02:53:32 <lunabot>  ><tr
02:53:32 <lunabot>    ><td
02:53:35 <mmorrow> ...
02:54:00 <mmorrow> and once you've constructed your html page, you use renderHtml to turn that into a String
02:54:14 <mmorrow> , thespan << toHtml "42"
02:54:16 <lunabot>  <span
02:54:16 <lunabot>  >42</span
02:54:16 <lunabot>  >
02:54:23 <mmorrow> , renderHtml (thespan << toHtml "42")
02:54:24 <lunabot>  "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\" \"http://www....
02:55:03 <mopped> thats a lot more batteries included than I expected ;)
02:55:15 <mmorrow> mopped: heh, totally.
02:55:26 <mmorrow> @type map
02:55:27 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
02:55:34 <mmorrow> , map (*2) [0..9]
02:55:36 <lunabot>  [0,2,4,6,8,10,12,14,16,18]
02:56:08 <mmorrow> , table << map (\x -> tr << td << toHtml x) ["1","2","3"]
02:56:09 <lunabot>  <table
02:56:09 <lunabot>  ><tr
02:56:09 <lunabot>    ><td
02:56:20 <mmorrow> ...
02:56:27 <mopped> \x is an anonymous function?
02:56:33 <mmorrow> exactly
02:56:40 <mmorrow> , (\x -> x) 42
02:56:42 <lunabot>  42
02:56:46 <mmorrow> , (\x -> (x,x)) 42
02:56:49 <lunabot>  (42,42)
02:56:54 <mmorrow> , (\x -> (x,repeat x)) 42
02:56:56 <lunabot>  (42,[42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42,42...
02:57:37 <ac__> I just thought of a simple operator that slightly increases readability and writeability in my opinion:
02:57:40 <mmorrow> and map "maps" its first arg (of type a -> b) over its second arg (which is a list :: [a]), and return a list of b's :: [b]
02:57:57 <ac> xs || f = fmap f xs
02:58:01 <mopped> What does << do, is that the same as tr . td . toHtml?
02:58:40 <BeelsebobWork> ac: you mean like <$> does?
02:58:50 <mmorrow> essentially, but it defines its precedence as an operator so that it's more convenient to use sometime
02:58:51 <mmorrow> s
02:58:54 <BeelsebobWork> > (+1) <$> [1,2,3,4,5]
02:58:56 <lambdabot>   [2,3,4,5,6]
02:59:05 <BeelsebobWork> > (+1) <$> (Just 6)
02:59:06 <lambdabot>   Just 7
02:59:26 <mmorrow> , table . tr . td . toHtml $ "a"
02:59:28 <lunabot>  <table
02:59:28 <lunabot>  ><tr
02:59:28 <lunabot>    ><td
02:59:39 <mmorrow> == table << tr << td << toHtml "a"
02:59:40 <ac> I like '||' because it reminds me of '|' in unix shells
02:59:56 <BeelsebobWork> ac: I think most people like <$> because it reminds them of "apply"
02:59:57 <mmorrow> but << can also take a [Html] on its right side as well
03:00:02 <mmorrow> so,
03:00:03 <BeelsebobWork> and the meaning is "apply" to everything in here
03:00:20 <mopped> Is it ever superior to have . instead of <<?
03:00:51 <mmorrow> table << [tr ...., tr ...., ....] == table << map tr [..., ..., ...]
03:01:00 <mmorrow> oh, and
03:01:15 <mmorrow> , toHtml "a" +++ toHtml "b"
03:01:17 <lunabot>  luna: Ambiguous occurrence `+++'
03:01:19 <mmorrow> grr
03:01:27 <mmorrow> , toHtml "a" Text.XHtml.Strict.+++ toHtml "b"
03:01:29 <lunabot>  ab
03:01:39 <mmorrow> so (+++) is analogous to (++)
03:01:47 <mmorrow> , [0..9] ++ [10..]
03:01:49 <lunabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,2...
03:02:08 <ac> BeelsebobWork: and of course with my definition the order of application goes from left to right
03:02:13 <mmorrow> but instead of for lists, +++ is for concatenating Html
03:02:45 <BeelsebobWork> ac: yep, which in general is gonna make a functional program look rather confused
03:02:51 <BeelsebobWork> as most things go right to left
03:03:21 <hugo_> well
03:03:55 <ac> It's always bugged me that a series of compositions goes from right to left
03:04:03 <hugo_> is it common in a recursive function, to define a "helper" function with the "stop" condition, or with an accumulator to know how many recursive iterations have passed ?
03:04:04 <mmorrow> , form << map (\x -> button ! [identifier x] << toHtml x) (map show [0..4])
03:04:06 <lunabot>  <form
03:04:08 <lunabot>  ><button id="0"
03:04:10 <lunabot>    >0</button
03:04:14 <mmorrow> ...
03:04:19 <mopped> heh
03:04:55 <mmorrow> mopped: you do incredible amounts of stuff with map
03:05:10 <hugo_> i have this list, and if the list is empty, i want to execute the function one more time and fetch the list again, then i need to throw an error :/
03:05:23 <mopped> i've used map a bit, but mostly list comprehensions
03:05:23 <hugo_> if it is still empty
03:05:37 <mmorrow> zip is also an extremely useful one
03:05:43 <mmorrow> zipWith as well
03:06:08 <mopped> would you reccomend h99 for getting myself accustomed with haskell?
03:06:22 <BeelsebobWork> ac: note, that in combination with <*> you can get any arity of liftM/liftA
03:06:34 <hugo_> mopped: only if you can read BNF like your mother language :P
03:06:44 <BeelsebobWork> > (+) <$> [1,2,3] <*> [9,8,7]
03:06:45 <lambdabot>   [10,9,8,11,10,9,12,11,10]
03:06:46 <mopped> lol
03:07:05 <BeelsebobWork> > liftA3 (+) [1,2,3] [9,8,7]
03:07:06 <lambdabot>       Overlapping instances for Show ([c] -> [d])
03:07:06 <lambdabot>        arising from a use o...
03:07:13 <BeelsebobWork> > liftA2 (+) [1,2,3] [9,8,7]
03:07:14 <mmorrow> , form << zipWith (\x y -> button ! [identifier (show x)] << toHtml y) [1..3] ["one","two","three"]
03:07:15 <lambdabot>   [10,9,8,11,10,9,12,11,10]
03:07:17 <lunabot>  <form
03:07:17 <lunabot>  ><button id="1"
03:07:17 <lunabot>    >one</button
03:07:43 <mmorrow> mopped: you should get ghc+ghci for sure :)
03:07:58 <mopped> What does the ! operator do?
03:08:29 <hugo_> it forces the evaluation of an expression, i think...
03:08:33 <mmorrow> oh, so in this context (other modules may define it to do other things), it adds attributes to a tag
03:08:40 <hugo_> i dont use it that much...
03:08:41 <araujo> morning
03:08:46 <mmorrow> , thespan << toHtml "a"
03:08:47 <hugo_> hi araujo
03:08:48 <lunabot>  <span
03:08:48 <lunabot>  >a</span
03:08:48 <lunabot>  >
03:09:15 <mmorrow> , thespan ! [theclass "pretty", identifier "nine", name "ralph"] << toHtml "a"
03:09:17 <lunabot>  <span class="pretty" id="nine" name="ralph"
03:09:17 <lunabot>  >a</span
03:09:17 <lunabot>  >
03:09:26 <araujo> hello hugo_
03:09:51 <mmorrow> (it's "theclass" and not "class" on account of class being reserved)
03:10:03 <mopped> so zipwith makes a tuple out of 1..3 and one to three, and passes it to the anonymous function so that identifier is an attribute of the button?
03:10:07 <mmorrow> and thespan since "span" is a Prelude function
03:10:35 <mmorrow> yeah, so zip takes two lists and gives you back a list of pairs
03:10:49 <mmorrow> , zip [1000..1004] [0..]
03:10:51 <lunabot>  [(1000,0),(1001,1),(1002,2),(1003,3),(1004,4)]
03:11:00 <mmorrow> it chops it at the end of the shorter list
03:11:13 <mmorrow> and    zip == zipWith (,)
03:11:24 <mmorrow> (,) == (\x y -> (x,y))
03:11:26 <mopped> so zipwith maps the zipped lists, zip just returns?
03:12:03 <BeelsebobWork> zipWith pairs elements up and applies a function to join them together
03:12:09 <hugo_> are you portuguese araujo ?
03:12:09 <mmorrow> zip is a special case of zipWith which happens to combine to paired-up items into a pair
03:12:10 <BeelsebobWork> zip happens to join them together by pairing them
03:12:15 <idnar> @src zipWith
03:12:15 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
03:12:16 <lambdabot> zipWith _ _      _      = []
03:12:24 <idnar> no
03:12:28 <araujo> hugo_, no ... mm.. my surname is very common over there right? :-)
03:12:28 <mmorrow> but zipWith may sum them, or use them in any arboitrary way
03:12:38 <BeelsebobWork> mmorrow: careful, it's also possible to say zipWith is a special case of zip
03:12:38 <mmorrow> , zipWith (+) [0..] [3..7]
03:12:40 <lunabot>  [3,5,7,9,11]
03:12:48 <hugo_> araujo: yes :)
03:12:54 <mmorrow> zip = zipWith (,)
03:13:09 <mopped> aha
03:13:15 <BeelsebobWork> zipWith f = map (uncurry f) . zip
03:13:21 <araujo> hugo_, good ... means I probably have to visit it someday :-)
03:13:32 <RayNbow> @pl zipWith f = map (uncurry f) . zip
03:13:32 <lambdabot> zipWith = (. zip) . map . uncurry
03:13:37 <mmorrow> BeelsebobWork: heh, but you're using map+uncurry :)
03:13:42 <hugo_> araujo: nice, you can stay at my place if you like
03:13:47 <BeelsebobWork> mmorrow: true, but you're using (,)
03:13:50 <araujo> hugo_, ooh hah, awesome, thanks!
03:13:57 <mmorrow> true, but 1 < 2 ;)
03:14:06 <BeelsebobWork> mmorrow: the xWith and x style are exactly as powerful as each other
03:14:07 <mmorrow> heh
03:14:15 <BeelsebobWork> it's just curried/non-curried higher order functions
03:14:29 <mopped> Is (,) predefined so that ghc knows to put (x, y), like (,,) would do (x, y, z)?
03:14:48 <hugo_> araujo: no problem, its nice to host a haskell programmer heheh
03:15:15 <idnar> zipWith f xs ys = map (uncurry f) $ zip xs ys
03:15:24 <idnar> oh
03:15:28 <idnar> I'm too late to the party
03:15:31 <mmorrow> BeelsebobWork: i suppose, but being a special case i think is different from being as powerful-as if you can postproc the output
03:15:37 <araujo> hugo_, hahaha :-)
03:15:47 <mmorrow> mopped: yes
03:16:03 <BeelsebobWork> mmorrow: I'm not sure that's true -- both can be used to get both
03:17:20 <RayNbow> http://haskell.org/ghc/docs/latest/html/libraries/base/src/Data-Tuple.html <-- mopped
03:17:22 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/42wzgt
03:18:07 * BeelsebobWork shudders
03:18:14 <mmorrow> Beelsebob: true. i guess i mean "a special case of when you're only considering those two functions defined explicitly recursively", since zip uses (,) in its definition, and zipWith doesn't
03:18:28 <mmorrow> @src zip
03:18:28 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
03:18:28 <lambdabot> zip _      _      = []
03:18:32 <mmorrow> @src zipWith
03:18:32 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
03:18:33 <lambdabot> zipWith _ _      _      = []
03:18:41 * BeelsebobWork really wishes we'd only had pairs instead of tuples
03:18:56 <BONUS_> yeah hehe
03:18:58 <BONUS_> (,,,,,,,,,,,,,,,,)
03:18:59 <BeelsebobWork> mmorrow: true
03:19:13 <mmorrow> mopped: another example is
03:19:43 <RayNbow> > (,,,,,,,,,,,,,,) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
03:19:45 <lambdabot>   (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15)
03:19:48 <RayNbow> > (,,,,,,,,,,,,,,,) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16
03:19:49 <lambdabot>       No instance for (Show
03:19:49 <lambdabot>                         (t,
03:19:49 <lambdabot>                      ...
03:19:49 <mmorrow> , zipWith ($) [(*2),(\x -> x + 4 * 7), const 0, id] [1..]
03:19:51 <lunabot>  [2,30,0,4]
03:20:46 <mopped> Confused on the ($), const 0 and id part ;)
03:21:09 <BeelsebobWork> mopped: $ is short for "apply"
03:21:23 <BeelsebobWork> so it's saying "apply the functions in the first list to the arguments in the second list"
03:21:42 <BeelsebobWork> const is a two argument function, which "const"antly returns its first argument
03:21:45 <mmorrow> Beelsebob: yeah, the only reason i'm for tuples is they're as convenient as lists, but have specified size, and O(1) indexing with template-haskell
03:21:56 <BeelsebobWork> and id is the "id"entity function, which does nothing at all to its argument
03:22:07 <mmorrow> but i hates using them not at that level
03:22:26 <mmorrow> const is the "constant" function
03:22:29 <BeelsebobWork> mmorrow: if we had tuples, then (,) could become an operator, and not require the brackets
03:22:35 <mmorrow> , map (const "hai") [0..]
03:22:37 <lunabot>  ["hai","hai","hai","hai","hai","hai","hai","hai","hai","hai","hai","hai",...
03:22:41 <BeelsebobWork> so we'd still be able to do (1,2,3,4,5,6,7,8,9)
03:22:45 <BeelsebobWork> to produce a "tuple"
03:23:14 <BeelsebobWork> the only problem would be the syntax crash with list syntactic sugar
03:23:34 <mmorrow> BeelsebobWork: so much sugar conflict
03:23:38 <BeelsebobWork> but in all honesty, I wouldn't mind losing that -- [1,2,3,4] is barely any better than (1:2:3:4:[])
03:23:38 <mmorrow> everywhere
03:23:56 <mmorrow> blasphemy!
03:24:00 <mmorrow> ;)
03:24:01 <mopped> But with those functions, how does it return them, does it return a list of say [2, 22, 0, 1], [4, 30, 0, 2], ...?
03:24:01 <Saizan> do you use tuples so much?
03:24:01 <BeelsebobWork> hehe
03:24:15 <mmorrow> Saizan: me?
03:24:17 <BeelsebobWork> Saizan: no, because they're horrible ;0
03:24:18 <BeelsebobWork> ;)
03:24:29 <BeelsebobWork> would probably use them a bit more if they were pairs always
03:24:39 <Saizan> i wouldn't use them even in that case
03:25:24 <Saizan> labelled extensible records are totally another story, instead
03:25:50 <BeelsebobWork> anyway, my main reasoning is simply that tuples make Haskell look ugly
03:25:58 <mopped> , ($) [(\x -> x * 2), id]
03:25:58 <RayNbow> @let pair = \a b f -> f a b
03:25:58 <BeelsebobWork> they're all about creating as many special-cases as you can
03:25:59 <lambdabot>  Defined.
03:26:00 <lunabot>  luna: Couldn't match expected type `a -> b' against inferred type `[a1]'
03:26:09 <mopped> , ($) [(\x -> x * 2), id] [1..4]
03:26:11 <lunabot>  luna: Couldn't match expected type `a -> b' against inferred type `[a1]'
03:26:17 <Saizan> > zipWith ($) [f,g,h] [x,y,z]
03:26:19 <lambdabot>       Ambiguous occurrence `f'
03:26:19 <lambdabot>      It could refer to either `L.f', defined a...
03:26:20 <mmorrow> mopped: so ($) is just like nothing
03:26:25 <mmorrow> , id $ 4
03:26:27 <mmorrow> , id 4
03:26:27 <lunabot>  4
03:26:28 <RayNbow> @let pfst = \p -> p (\a b -> a)
03:26:29 <Saizan> > zipWith ($) [g,h] [x,y,z]
03:26:29 <lunabot>  4
03:26:30 <lambdabot>  Defined.
03:26:30 <lambdabot>   mueval: Prelude.read: no parse
03:26:30 <lambdabot>  mueval: GhcException mkTopLevEnv: not a hom...
03:26:37 <RayNbow> @let psnd = \p -> p (\a b -> b)
03:26:38 <lambdabot>  Defined.
03:26:40 <mmorrow> @src ($)
03:26:40 <lambdabot> f $ x = f x
03:26:53 <mopped> , zipWith ($) [(\x -> x * 2), id] [1..4]
03:26:55 <lunabot>  [2,2]
03:27:01 <RayNbow> > let x = pair 1 2 in (pfst x, psnd x)
03:27:02 <BeelsebobWork> > (zipWith ($) [f,g,h] [x,y,z]) :: Expr
03:27:03 <lambdabot>   (1,2)
03:27:04 <lambdabot>       Ambiguous occurrence `f'
03:27:04 <lambdabot>      It could refer to either `L.f', defined a...
03:27:11 <BeelsebobWork> > (zipWith ($) [g,h] [x,y,z]) :: Expr
03:27:12 <lambdabot>   Couldn't match expected type `Expr' against inferred type `[b]'
03:27:15 <mopped> Bit confused with that :P
03:27:24 <BeelsebobWork> > (zipWith ($) [g,h] [x,y,z]) :: [Expr]
03:27:26 <lambdabot>   [g x,h y]
03:27:41 <BeelsebobWork> > (zipWith ($) [g,h,i,j] [w,x,y,z]) :: [Expr]
03:27:42 <lambdabot>   Couldn't match expected type `a -> Expr'
03:27:46 <mmorrow> mopped: yeah, the ($) may seem strange until you find it useful
03:27:49 <BeelsebobWork> bugger
03:28:20 <mopped> how do I map a list of functions to each value in a list
03:28:21 <mmorrow> , (*3) . (*2) . (+4) . (/20000) $ pi
03:28:23 <lunabot>  24.00094247779608
03:28:30 <ac> why are tuple constructors defined in the prelude when tuple syntax already has to be built in for pattern matching?
03:28:47 <mmorrow> mopped: ah, so you want to, for each val in the list, apply every function to it?
03:29:01 <BeelsebobWork> > [(*2), (*3), (*4)] <*> [1,2,3]
03:29:03 <lambdabot>   [2,4,6,3,6,9,4,8,12]
03:29:13 <mopped> yeah mmorrow
03:29:18 <mopped> that's what I thought ($) did :P
03:29:19 <BeelsebobWork> like that mopped
03:29:26 <mopped> yeah BeelsebobWork
03:29:36 <mmorrow> , map ($ 10) [(\x -> x * 2), id]
03:29:38 <lunabot>  [20,10]
03:29:40 <quicksilver> ac: depending what you think the prelude is, tuple constructors aren't "defined" in the prelude.
03:29:48 <BeelsebobWork> mopped: no, ($) is the "apply" function -- it takes one function, and one argument, and applies the function to the argument
03:29:54 <RayNbow> > do {f <- [(*2), (*3), (*4)]; x <- [1,2,3]; return (f x)}  -- alternative :p
03:29:54 <mmorrow> , map (\x -> map ($ x) [(\x -> x * 2), id]) [1..4]
03:29:55 <lambdabot>   [2,4,6,3,6,9,4,8,12]
03:29:56 <lunabot>  [[2,1],[4,2],[6,3],[8,4]]
03:29:59 <quicksilver> ac: the tuple constructors are built-in syntax, they can't be defined in pure haskell.
03:30:13 <mmorrow> , ($ 10) (*2)
03:30:15 <lunabot>  20
03:30:21 <mmorrow> , (\f -> f 10) (*2)
03:30:24 <lunabot>  20
03:30:40 <mmorrow> , (*2) 10
03:30:42 <lunabot>  20
03:30:46 <mmorrow> , 10*2
03:30:48 <lunabot>  20
03:30:49 <mmorrow> :)
03:30:49 <mopped> ($ *10) [1..3]
03:30:54 <mopped> , ($ *10) [1..3]
03:30:57 <lunabot>  luna: parse error on input `*'
03:31:04 <mopped> whats different between ($) and $?
03:31:07 <BeelsebobWork> > (*10) <$> [1..3]
03:31:08 <lambdabot>   [10,20,30]
03:31:16 <mopped> and <$> :)
03:31:25 <BeelsebobWork> mopped: ($) is prefix, $ is infix
03:31:32 <BeelsebobWork> <$> is a different function
03:31:40 <BeelsebobWork> @type ($)
03:31:41 <lambdabot> forall a b. (a -> b) -> a -> b
03:31:45 <BeelsebobWork> @type (<$>)
03:31:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:31:54 <BeelsebobWork> (it's similar though)
03:31:55 <mmorrow> @src (<$>)
03:31:55 <lambdabot> f <$> a = fmap f a
03:32:03 <mmorrow> for lists, fmap = map
03:32:03 <mopped> , ($) (*10) [1..4]
03:32:06 <lunabot>  luna: No instance for (GHC.Num.Num [t])
03:32:20 <int-e> , (<$>) (*10) [1..4]
03:32:21 <mmorrow> , ($) (map (*10)) [1..4]
03:32:22 <lunabot>  [10,20,30,40]
03:32:24 <lunabot>  [10,20,30,40]
03:32:31 <mopped> so use <$> on lists?
03:32:39 <mmorrow> yes
03:32:46 <BeelsebobWork> mopped: yep, you need to use <$> to apply the function *inside* a container
03:32:47 <idnar> or any other functor
03:32:54 <mmorrow> which happens to be the same as "map"
03:33:00 <BeelsebobWork> (where container is a very lose word for functor)
03:33:05 <int-e> :t id `asTypeOf` ($)
03:33:06 <lambdabot> forall a b. (a -> b) -> a -> b
03:33:20 <mmorrow> , (*2) <$> [0..]
03:33:22 <lunabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50...
03:33:33 <mmorrow> , (*2) <$> (2,4)
03:33:35 <lunabot>  (2,8)
03:33:40 <BeelsebobWork> > (*2) <$> (Just 5)
03:33:41 <lambdabot>   Just 10
03:34:08 <mmorrow> parametric polymorphism ftw
03:34:12 <BeelsebobWork> idd
03:34:43 <mopped> any reason why 2 wasnt multiplied by 2 mmorrow?
03:35:03 <Botje> @src fmap (,)
03:35:03 <lambdabot> Source not found. Just try something else.
03:35:06 <BONUS_> (,) a b as an instance of Functor is parametrized over the second parameter
03:35:17 <BONUS_> instance Functor ((,) a) where ...
03:35:20 <mmorrow> mopped: yeah, so the instance for the (,) type for the class that (<$>) is from was defined to be that way
03:35:41 <mmorrow> i thought it was strange at first too, but it made sense later
03:35:50 <BONUS_> fmap :: (a -> b) -> (c,a) -> (c,b) for tuples
03:35:55 <mmorrow> there are a bunch of functions that "split" something into a pair
03:36:00 <mopped> , (*2) <$> (3, 5, 6)
03:36:03 <lunabot>  luna: No instance for (GHC.Base.Functor ((,,) t t1))
03:36:08 <mmorrow> where the "rest" is the second element in that pair
03:36:10 <mopped> , (*2) <$> (3,5,6)
03:36:12 <lunabot>  luna: No instance for (GHC.Base.Functor ((,,) t t1))
03:36:20 <mmorrow> so <$> will apply the function to the "rest"
03:36:31 <BONUS_> to the last component usually
03:36:35 <mopped> , (*2) <$> (3,5,6,7)
03:36:37 <BONUS_> to the last type
03:36:37 <lunabot>  luna: No instance for (GHC.Base.Functor ((,,,) t t1 t2))
03:36:39 <Saizan> (mmorrow: also, that's the only instance we can write in the haskell type system :))
03:36:42 <mmorrow> mopped: heh, so only pairs really have stuff to work with them
03:36:56 <mopped> hmm ok
03:36:57 <mmorrow> Saizan: oh yeah, that's true
03:37:18 <mmorrow> , ((*2) <$>) <$> (0,(1,2))
03:37:20 <lunabot>  (0,(1,4))
03:37:28 <mmorrow> , fst (0,1)
03:37:30 <lunabot>  0
03:37:32 <mmorrow> , snd (0,1)
03:37:34 <lunabot>  1
03:37:42 <mmorrow> , (fst . snd) (0,(1,2))
03:37:45 <lunabot>  1
03:37:52 <Axman6> @instances Ix
03:37:52 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
03:38:01 <BeelsebobWork> mmorrow: hmm, that's actually a rather neater way of writing conal's fmap . fmap . fmap trick
03:38:03 <EvilTerran> @instances-importing Data.Array Ix
03:38:04 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
03:38:05 <mopped> it seems a bit wierd (the $), will come after I acctualy learn things I guess
03:38:20 <Axman6> Bool? :\
03:38:37 <EvilTerran> Axman6, that's nothing - you can use () too!
03:38:43 <Axman6> ha, yes
03:39:18 <EvilTerran> just in the interests of completeness, i guess
03:39:20 <Axman6> > array () [((),undefined)]
03:39:21 <lambdabot>   Couldn't match expected type `(i, i)' against inferred type `()'
03:39:30 <EvilTerran> i still think there should be an instance Num Bool
03:39:30 <Axman6> > array () [()]
03:39:31 <lambdabot>   Couldn't match expected type `(i, i)' against inferred type `()'
03:39:42 <Saizan> you've to give the two bounds
03:39:45 <EvilTerran> > array (minBound,maxBound) [((),"foo")]
03:39:46 <lambdabot>   array ((),()) [((),"foo")]
03:39:50 <Axman6> ah yes
03:43:30 <hugo_> is there any way to throw an "empty" data record that matches its type ? :/
03:44:31 <BONUS_> not for every type
03:44:53 <BONUS_> for lists it's [], for Maybe it's Nothing
03:44:57 <quicksilver> 'undefined' matches any type.
03:45:02 <BONUS_> so you might have to wrap your type in one of those
03:45:06 <BONUS_> yeah well there's that too
03:45:07 <quicksilver> that is probably not a sensible thing to use, though.
03:45:14 <quicksilver> Foo {} for record types
03:45:18 <quicksilver> is the same thing as undefined
03:45:25 <quicksilver> (with a slightly different error message)
03:45:29 <hugo_> hmm
03:45:42 <quicksilver> but again it's probably not what you want to do.
03:45:47 <quicksilver> it's subverting the type system.
03:45:51 <quicksilver> what *are* you trying to do?
03:45:59 <hugo_> this function i have, returns IO DataType, and i want it to throw an error in some cases, do i need to change its sig ?
03:46:07 <quicksilver> no.
03:46:11 <quicksilver> use IO exceptions.
03:46:16 <quicksilver> since you're in IO anyway.
03:46:37 <hugo_> olraite
03:46:53 <hugo_> then i dont need to return an IO DataType if i use IO exceptions ?
03:48:06 <hugo_> i find myself almost always inside a do ..., is it usual in haskell ?
03:48:24 <hugo_> i think my mind is not recursive enough...
03:48:32 <quicksilver> hugo_: you still have the type 'IO DataType'
03:48:42 <quicksilver> but the type 'IO DataType' includes the possibility of exception.
03:48:49 <hugo_> hmm nice :)
03:48:54 <quicksilver> in which case you will no get anything on type 'DataType'
03:49:05 <quicksilver> No, it's not normally to be always always inside a do
03:49:14 <quicksilver> you should be inside a do as rarely as you can
03:49:22 <quicksilver> structure as much of your code as possible as pure functions.
03:49:43 * RayNbow cringes at some reddit comments about C++...
03:49:56 <Peaker> People speak about putting finer-granularity control of side effects into IO.  Wouldn't it be simple to start off by splitting exceptions from IO into ErrorT, and then maybe use ST for refs/mutable state, and the something else for the side effects, and a simple monad transformer to combine all these into what people know as "IO" ?
03:50:42 <mornfall> Peaker: Isn't the problem with the layering order?
03:51:13 <quicksilver> I don't think you'd use a monad transformer stack.
03:51:15 <Peaker> mornfall: I think ErrorT has to be on the outside, but other than that, I am not sure
03:51:20 <quicksilver> I think you'd use type classes for capabilities.
03:51:36 <Peaker> quicksilver: what would the actual type be though?
03:51:40 <quicksilver> (MonadFile m, MonadExceptions m, MonadRefs m) => m (0
03:51:43 <quicksilver> m()
03:52:09 <Peaker> Oh, but that means that the actual monad types are still duplicating functionality..
03:52:30 <Peaker> I guess there's no contradiction, you could use a monad transformer to build the type without duplication, and typeclasses to talk about its capabilities
03:52:59 <mornfall> I find transformer stacks to be counter-intuitive.
03:53:27 <Peaker> I think defining them is a PITA, but using them is dandy :)
03:54:17 <Saizan> Peaker: ErrorT doesn't subsume IO exceptions however, you can't write throwTo or in general handle asynchronous ones
03:54:33 <Peaker> @src ErrorT
03:54:33 <lambdabot> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
03:54:57 <Peaker> Saizan: Why not?
03:55:28 <quicksilver> Peaker: because ErrorT is entirely deterministic.
03:55:36 <quicksilver> asynchronous exceptions are somethign else.
03:55:52 <quicksilver> and (threaded) async exceptions even more so.
03:56:28 <Saizan> unless you allow the RTS to magically tranform your Right something in Left exception when it decides so ;)
03:56:53 <Peaker> I think I just don't know what async exceptions are
03:57:08 <Peaker> I thought an IO operation could simply result in an exception instead of a value?
03:57:14 <mib_x329rgv7> @tell Twey back
03:57:14 <lambdabot> Consider it noted.
03:57:30 <Saizan> Peaker: yeah, but some exceptions are not caused by the operation
03:58:43 <Peaker> Saizan: thrown by other threads, that is?
03:59:18 <Saizan> yes, or from things like memory errors
03:59:40 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html#11
03:59:42 <lambdabot> Title: Control.Exception, http://tinyurl.com/yk8zqb
03:59:49 <quicksilver> Indeed the two notions are orthogonal.
04:00:02 <quicksilver> You could have synchronous-only IO exceptions.
04:00:13 <quicksilver> that is, those which are raised directly by the operation.
04:00:24 <quicksilver> and that would behave very much like ErrorT IO
04:00:33 <quicksilver> i.e. IO :. (Either Error)
04:03:08 <Peaker> why can't async exceptions be something that the IO actions convert to a sync exception upon return?
04:03:20 <Peaker> I mean, code inside IO's >>= operator and inside the built-in IO actions is "magic" anyway..
04:03:30 <Peaker> it could convert async exceptions to sync ones...
04:05:42 <nicknull> god wtf, how do i register my nick?
04:05:58 <Saizan> nicknull: /msg nickserv help register
04:10:41 <ivanm> @type ixmap
04:10:42 <lambdabot> forall i j e. (Ix j, Ix i) => (i, i) -> (i -> j) -> Array j e -> Array i e
04:10:57 <ivanm> ^^ how is that right? does haskell apply the function in reverse or something? :s
04:11:13 <quicksilver> it's a map on the indices not the elements
04:11:18 <quicksilver> obviously it has to work in reverse
04:11:19 <opqdonut> it maps on the _lookup_
04:11:21 <quicksilver> think it through.
04:11:58 <ivanm> yeah, I'm thinking it through... but how does it manage to find the inverse of the function?
04:12:47 <ivanm> > let a = listArray (1,5) [1..5] in ixmap (1,5) ((+) 1) a
04:12:49 <lambdabot>   array (1,5) [(1,2),(2,3),(3,4),(4,5),(5,* Exception: Error in array index
04:13:01 <ivanm> > let a = listArray (1,5) [1..5] in ixmap (2,6) ((+) 1) a
04:13:02 <lambdabot>   array (2,6) [(2,3),(3,4),(4,5),(5,* Exception: Error in array index
04:13:23 <ivanm> what's going on here?
04:14:01 <quicksilver> it doesn't find the inverse of the funciton.
04:14:09 <ivanm> oh, wait, I get it
04:14:11 <quicksilver> it applies the function, as given, to the indices when you look something up.
04:14:20 <ivanm> opqdonut: now I now what you mean by lookup ;-)
04:14:26 <quicksilver> you have to tell the truth about the new bounds though.
04:14:42 <ivanm> it works out what the value at each cell is by looking up the function value in the old array
04:15:25 <quicksilver> of course quite often we *do* use invertible functions.
04:15:38 <ivanm> > let a = listArray (0,4) [1..5] in ixmap (1,5) (flip mod 5) a
04:15:40 <lambdabot>   array (1,5) [(1,2),(2,3),(3,4),(4,5),(5,1)]
04:15:43 <quicksilver> so in your mental model you imagine it doesn't matter which way round you specify it.
04:15:59 <ivanm> quicksilver: :o how can you computationally invert a function?
04:16:03 <quicksilver> but, assuming you may not necessarily use an invertible function, it makes sense to specfy the i->j one
04:16:06 <quicksilver> you can't.
04:16:13 <ivanm> > let a = listArray (0,4) [1..5] in ixmap (0,4) (flip mod 5 . (+) 1) a
04:16:14 <lambdabot>   array (0,4) [(0,2),(1,3),(2,4),(3,5),(4,1)]
04:16:23 <ivanm> OK, I think I get what it's doing now
04:16:31 <ivanm> quicksilver: *nod*
04:17:30 <kazuki> :q
04:20:25 <ivanm> quicksilver: so if I want to shift the values to the right, I have to use a subtraction function?
04:23:04 <quicksilver> I think you know the answer to that :)
04:23:22 <quicksilver> I can't be quite sure, since 'to the right' is ambiguous...
04:24:08 <ivanm> by "to the right", I mean that cell x gets the value of cell x-1
04:24:27 <ivanm> by looking at what lambdabot gave me as the results, that's what it seems to need
04:24:40 <ivanm> it just seems... backwards :s
04:31:22 <ac> huh, how does one print unicode in Haskell?
04:31:47 <ac> appears that putStrLn strips any non-ascii characters out
04:31:49 <Saizan> ?hackage uft8-string
04:31:49 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/uft8-string
04:32:09 <Saizan> putStrLn currently outputs the least significant octet
04:32:33 <Saizan> which is fine for unicode < 256
04:37:19 <ivanm> if I have a function f :: [a] -> StdGen -> a, which returns a random element of a list by calculating the length of the list and picking a random element in those bounds, and I have say f' = [1..5], does the length of [1..5] get re-evaluated each time I call f' ?
04:39:37 <pjdelport> ivanm: this is tangential, but you know of the alternative algorithm that doesn't need the length beforehand?
04:39:54 <quicksilver> ivanm: yes.
04:40:12 <ivanm> pjdelport: prob half for first element, prob 1/3 for second, etc. thingy one?
04:40:20 <ivanm> yeah, couldn't be bothered with it though :p
04:40:31 <ivanm> quicksilver: that's what I thought... pity
04:40:37 <pjdelport> ivan: well, 1 for first, 1/2 for second, etc., yeah
04:40:58 <ivanm> whatever it i
04:41:00 <ivanm> *i
04:41:02 <ivanm> *is
04:41:43 <quicksilver> ivanm: it's not hard to rewrite it so it is cached when the first parameter (the [a]) is passed
04:41:54 <quicksilver> and then not re-calculated when the second parameter (StdGen) is passed.
04:41:57 <ivanm> oh? how?
04:42:26 <quicksilver> f l = let ln = length l in \g -> f_aux l ln g
04:42:33 <quicksilver> ...where f_aux = obvious stuff
04:42:51 <ivanm> ahhh
04:42:53 <ivanm> thanks quicksilver
04:42:57 <ivanm> didn't realise that would cache it
04:43:47 <hugo_> im sorry to bother, but im having problems with this IO exception and stuff: http://hpaste.org/11113
04:44:03 <hugo_> can somebody look at this messy code, and give me some hints, please ?
04:44:39 <quicksilver> I think you have the impression that 'return' means what it does in other languages.
04:44:45 <quicksilver> if so, you are wrong.
04:45:01 <quicksilver> that 'return $ head valid_lst' is completely wasted, its value is ignored.
04:45:11 <hugo_> is it ?
04:45:15 <quicksilver> yes, it is.
04:45:21 <hugo_> i thought it would also break the do ...
04:45:24 <quicksilver> you were wrong.
04:45:28 <quicksilver> return doesn't break anything.
04:45:28 <hugo_> oh
04:45:34 <quicksilver> it's nothing like return in other languages.
04:45:40 <hugo_> ok
04:45:41 <quicksilver> it was probably a bad choice of name.
04:45:51 <quicksilver> (but it's not quite *nothing* like return in other langauges, to be honest ;0
04:45:52 <pjdelport> hugo_: return is a constructor
04:45:56 <quicksilver> it's just different.
04:45:56 <Axman6> :t return
04:45:57 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
04:46:10 <quicksilver> the error is that your two case branches are not the same type.
04:46:20 <Axman6> > Data.Maybe return 10
04:46:22 <lambdabot>       Failed to load interface for `Data':
04:46:22 <lambdabot>        Use -v to see a list of the...
04:46:27 <Axman6> bleh
04:46:32 <quicksilver> any branching construct - that is, if or case - must have the same type on each branch
04:46:39 <Axman6> > return 10 :: Maybe Int
04:46:39 <hugo_> oh
04:46:40 <lambdabot>   Just 10
04:46:55 <Axman6> > return 10 :: [Int]
04:46:56 <lambdabot>   [10]
04:47:04 <hugo_> then i need to completly rethink this...
04:47:11 <quicksilver> I can't understand your code well enough to explain what you meant to do.
04:47:30 <quicksilver> if it helps, remember that case statements 'return something' as much as any other monadic expression
04:47:38 <quicksilver> so "foo <- case bar of .... "
04:47:41 <hugo_> ok, thanks
04:47:43 <quicksilver> is a perfectly sensible thing to write.
04:48:03 <quicksilver> as it stands you are ignoring the 'return value' of "case valid_lst of..."
04:48:34 <yewT> quicksilver, what does it mean by "Program error: Prelude.read: no parse"
04:49:20 <hugo_> im rewriting it...
04:49:39 <quicksilver> yewT: what does what mean?
04:49:56 <yewT> quicksilver, i received an error which says taht Program error: Prelude.read: no parse
04:50:07 <yewT> what does it mean by no parse?
04:50:15 <pjdelport> > read "5" :: Int
04:50:17 <lambdabot>   5
04:50:20 <pjdelport> > read "5" :: String
04:50:21 <lambdabot>   "* Exception: Prelude.read: no parse
04:50:32 <yewT> pjdelport, you hit right to the nail
04:50:54 <yewT> so what cause that line to pop up that message?
04:51:29 <quicksilver> yewT: it means you are using 'read' in a broken way.
04:51:29 <pjdelport> yewT: something is giving read a string which doesn't parse
04:51:32 <pjdelport> pretty much
04:51:40 <quicksilver> without seeing more of your program it's hard to be sure.
04:51:56 <BONUS_> That it doesn't know how to convert that particular string into your type
04:51:58 <pjdelport> yewT: so where are you using read, and what is the string?
04:52:19 <yewT> oh i got it
04:52:39 <yewT> i guess this was my mistake
04:53:04 <yewT> i did this >>> read "5,000" < (5000::Int)
04:53:08 <yewT> > read "5,000" < (5000::Int)
04:53:09 <lambdabot>   * Exception: Prelude.read: no parse
04:53:17 <yewT> i need to remove the comma ^_^
04:53:21 <BONUS_> yes
04:53:56 <yewT> thanks guys
04:55:06 <yewT> yay all problem solved ^_^ yipee
04:56:51 <yewT> hey guys, i wanna ask, how would you remove element from a list if it matches the user input?
04:57:02 <pjdelport> filter?
04:58:12 <pjdelport> > filter (== 2) [1..5]
04:58:14 <lambdabot>   [2]
04:58:18 <pjdelport> > filter (!= 2) [1..5]
04:58:20 <lambdabot>   Not in scope: `!='
04:58:24 <pjdelport> > filter (/= 2) [1..5]
04:58:26 <lambdabot>   [1,3,4,5]
04:58:40 <yewT> example: "a" and "b" vs [ ["a","c"],["c","b"],["d","f"],["z","x"]] >> [ ["d","f"],["z","x"] ]
04:59:04 <yewT> example: ["a","b"] vs [ ["a","c"],["c","b"],["d","f"],["z","x"]] >> [ ["d","f"],["z","x"] ]
04:59:22 <quicksilver> yewT: study pjdelport's examples.
04:59:33 <quicksilver> yewT: understanding filter is the key to answering that question.
04:59:49 <pjdelport> yewT: you'll need a slightly different different function to give to filter, but the idea is similar
05:00:18 <pjdelport> it looks like you want to test whether any element of ["a","b"] is contained in the other lists?
05:00:27 <yewT> yeah
05:00:49 <yewT> if any element matches ["a","b"] in the xs list, then remove them or create a new list without them
05:01:04 <yewT> for me, i use the later solution and able to get the answer
05:01:15 <yewT> creating a new list, but its kinda long, so i was wandering any shorter way
05:01:28 <yewT> i did not use filter for my solution
05:01:33 <pjdelport> yewT: well, filter does the removing elements part
05:01:42 <yewT> i see
05:01:49 <pjdelport> the other part is defining a function that does the comparison you want
05:02:09 <yewT> so i need to creat 2 functions? 1 to compare and the other remove?
05:02:24 <pjdelport> nah, just one to compare
05:02:35 <yewT> compare + filter in 1 function?
05:02:36 <pjdelport> do you understand filter, in general?
05:02:50 <yewT> not really
05:02:53 <pjdelport> ok
05:02:54 <pjdelport> :t filter
05:02:54 <yewT> is it like map?
05:02:55 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
05:03:04 <pjdelport> it's related
05:03:24 <BONUS_> yewT: homework again? ;)
05:03:35 <yewT> bonus no
05:03:46 <yewT> bonus_ why are you asking?
05:03:47 <pjdelport> yewT: filter takes a function, known as a predicate, that returns either True or False for each element in the list you give it
05:03:53 <BONUS_> hehe, just wondering
05:04:10 <pjdelport> and then filter returns a list of all the True elements
05:04:10 <yewT> bonus_ if its homework, so ?
05:04:16 <pjdelport> > filter even [1..]
05:04:18 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
05:04:24 <pjdelport> > filter odd [1..]
05:04:25 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
05:04:53 <yewT> so the function that filter uses must produce a bool, if its true then place it in a new list?
05:04:58 <pjdelport> > filter isLower "Hello World!"
05:05:00 <lambdabot>   "elloorld"
05:05:05 <yewT> wow cool
05:05:13 <pjdelport> > filter (not . isLower) "Hello World!"
05:05:14 <lambdabot>   "H W!"
05:05:22 <yewT> oh
05:05:24 <pjdelport> right, exactly
05:05:29 <BeelsebobWork> > filter isUpper "Hello World!"
05:05:30 <lambdabot>   "HW"
05:05:40 <pjdelport> so sorry, my examples above were a bit brief
05:05:49 <pjdelport> > filter (/= 2) [1..5]
05:05:51 <lambdabot>   [1,3,4,5]
05:06:00 <yewT> oh
05:06:13 <pjdelport> (/= 2) returns False for 2, and True for all other numbers
05:06:28 <pjdelport> so with filter, it essentially removes 2 from the list
05:07:10 <pjdelport> so given your example, you need a function that will return False for ["a","c"] and ["c","b"]
05:07:13 <pjdelport> and True for the rest
05:07:28 <yewT> ok
05:07:44 <BeelsebobWork> specifically, liftA2 (||) (== ["a","c"]) (== ["c","b"])
05:07:50 <BeelsebobWork> >.>
05:08:04 <BeelsebobWork> (that should show the lecturer what's up if this is homework :D)
05:08:37 <Axman6> @src [] (==)
05:08:37 <lambdabot> []     == []     = True
05:08:37 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
05:08:37 <lambdabot> _      == _        = False
05:09:13 <yewT> BeelsebobWork vixey provide me that example, but I could not really grasp it
05:09:33 <yewT> || is this or?
05:09:40 <BeelsebobWork> yes
05:09:52 <yewT> && and?
05:09:54 <BeelsebobWork> yes
05:09:57 <yewT> ok
05:10:00 <BeelsebobWork> @type (||)
05:10:01 <lambdabot> Bool -> Bool -> Bool
05:10:04 <BeelsebobWork> @type liftA2 (||)
05:10:05 <lambdabot> forall (f :: * -> *). (Applicative f) => f Bool -> f Bool -> f Bool
05:10:18 <BeelsebobWork> it just so happens that (a ->) is an Applicative
05:10:42 <BeelsebobWork> so liftA2 in this case makes (||) into a function :: (a -> Bool) -> (a -> Bool) -> (a -> Bool)
05:11:20 <pjdelport> BeelsebobWork: maybe Applicative is getting a bit ahead :)
05:11:35 <BeelsebobWork> indeed -- as I said, it would tell the lecturer what's going on if it is homework ;)
05:11:57 <yewT> what do you mean?
05:12:10 <yewT> tell the lecturer what's going on if it is homework  ?
05:12:52 <BeelsebobWork> if he sees liftA2 in your solution he'll go "hmm, he's got someone else to answer this question for him", because it's really rather advanced for where you are
05:13:09 <yewT> lol i see
05:13:12 <BeelsebobWork> so my recommendation is to try and come up with a function that detects those lists yourself
05:13:13 <yewT> thanks for explaining
05:13:20 <yewT> i have done that
05:13:21 <BeelsebobWork> and then try and understand liftA2 later
05:13:23 <BeelsebobWork> cool :)
05:13:28 <yewT> but my way is longer than liftA2
05:13:32 <yewT> and does not use filter
05:13:44 <yewT> so i was wandering is there a more efficient way of doing this
05:13:48 <BeelsebobWork> okay, I'd suggest then you use filter
05:13:58 <BeelsebobWork> but come up with the predicate yourself
05:14:10 <yewT> oh yeah, i wanna ask , what is a predicate
05:14:13 <yewT> is it a function?
05:14:19 <BONUS_> yeah
05:14:24 <BeelsebobWork> a predicate is any function that takes a single input, and results in a boolean
05:14:28 <BONUS_> that takes something and gives you either a True or a False
05:14:28 <BeelsebobWork> it "predicates" things
05:14:35 <BONUS_> think of it as a question
05:14:35 <BeelsebobWork> i.e. decides if they have a certain property
05:14:45 <yewT> predicate means take 1 input and produce 1 output? or multiple input and 1 output?
05:14:57 <BONUS_> it just means it produces a boolean at the end
05:15:08 <yewT> usually functions could take more than 1 input right?
05:15:24 <Axman6> not necessarilly
05:15:37 <yewT> i mean custom function?
05:15:42 <BONUS_> sometimes they take one parameter, sometimes many, etc
05:15:47 <BeelsebobWork> yewT: short answer: yes, long answer: no, but the explanation of why is complicated
05:15:59 <Axman6> yewT: a predicate can be thought of as a test, that returns true or false
05:16:08 <BeelsebobWork> i.e. for the moment, all you need to know is that they can take multiple arguments
05:16:13 <BeelsebobWork> but later, it'll be useful to see that they don't
05:16:27 <yewT> predicate only deals with Bool stuff?
05:16:36 <BeelsebobWork> it only returns Bools
05:16:41 <BeelsebobWork> so isLower is a predicate
05:16:45 <yewT> thats a good point ^_^
05:16:48 <BeelsebobWork> because it tells you whether something is lower case
05:16:52 <yewT> i learned something new today, predicate returns bool
05:17:04 <Axman6> they take the form of a -> ... -> Bool
05:17:05 <BONUS_> :]
05:17:09 <BeelsebobWork> but + is not a predicate, because it doesn't answer a yes/no question
05:17:17 <yewT> oh
05:17:19 <Axman6> where ... is any number of arguments
05:17:24 <yewT> oih yeah
05:17:47 <yewT> whts the difference between $ dollar sign VS dot . VS () parentheses
05:17:54 <yewT> i know that $ = ()
05:17:55 <Axman6> could be a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> Bool, but something like that would probably not be very useful...
05:18:00 <BeelsebobWork> yewT: a dolar sign is no different from parens
05:18:08 <BeelsebobWork> but (.) takes two functions
05:18:10 <yewT> i seen some coders use dot
05:18:23 <yewT> predicate.predicate/
05:18:25 <yewT> ?
05:18:26 <pjdelport> @src (.)
05:18:27 <lambdabot> (f . g) x = f (g x)
05:18:31 <pjdelport> @src ($)
05:18:31 <lambdabot> f $ x = f x
05:18:32 <BeelsebobWork> so... dollar takes a function and an argument and applies the function to the argument
05:18:33 <niklaus>  how many n-digit numbers there are such that no digit occurs more than 4 times ? i get the solution as x1+x2+x3+....x10=n-1 with each 0<= xi<=4 except for one for which 0<=xi<=3 (the 1st digit), total *9 , any elegant solns ?
05:18:42 <Axman6> it depends on how you want to use them. i sometimes used f $ g $ h $ i $ k x
05:18:46 <BeelsebobWork> dot instead takes two functions, and returns a new function that does one after the other
05:18:55 <Axman6> but... less so these days, now i understand how to use (.)
05:20:14 <pjdelport> yewT: (.) just glues functions together
05:20:25 <pjdelport> so that the one's "output" goes to the other's "input"
05:20:31 <yewT> BeelsebobWork mentioned returns a new function o_o any example?
05:20:45 <yewT> function1.function2 = function3?
05:20:48 <BeelsebobWork> yep
05:20:56 <BeelsebobWork> so (+1) . (+1) is a function
05:21:00 <BeelsebobWork> it adds 2 to things
05:21:07 <BeelsebobWork> > ((+1) . (+1)) 2
05:21:08 <lambdabot>   4
05:21:25 <pjdelport> yewT: look at this earlier example again
05:21:26 <yewT> :t ((+1) . (+1)) 2
05:21:27 <lambdabot> forall a. (Num a) => a
05:21:35 <BeelsebobWork> :t ((+1) . (+1))
05:21:36 <lambdabot> forall a. (Num a) => a -> a
05:21:51 <pjdelport> :t filter (not .isLower)
05:21:53 <lambdabot> [Char] -> [Char]
05:22:00 <pjdelport> :t not
05:22:00 <BeelsebobWork> :t (not . isLower)
05:22:01 <lambdabot> Bool -> Bool
05:22:02 <lambdabot> Char -> Bool
05:22:19 <pjdelport> @src not
05:22:19 <lambdabot> not True   =  False
05:22:20 <lambdabot> not False  =  True
05:22:32 <pjdelport> so not reverses a True/False value
05:23:03 <pjdelport> (not . isLower) feeds the value of isLower to not, and then returns that
05:23:18 <BeelsebobWork> > isLower 'A'
05:23:19 <lambdabot>   False
05:23:25 <BeelsebobWork> > (not . isLower) 'A'
05:23:26 <lambdabot>   True
05:24:23 <yewT> thanks BeelsebobWork
05:24:26 <yewT> i understand now :)
05:24:29 <BeelsebobWork> :)
05:24:44 <yewT> 2nd thing i learn today is dot operators combine 2 function into 1
05:25:10 <BeelsebobWork> so... given that, we can now do lots of combining functions, and then apply them with the dollar function
05:25:16 <BeelsebobWork> > not . isLower $ 'A'
05:25:18 <lambdabot>   True
05:25:41 <yewT> it looks much neater without many ()
05:25:46 <BeelsebobWork> indeed
05:25:54 <BeelsebobWork> (although sometimes the parens are useful)
05:26:40 <BeelsebobWork> so, in your example, you need to come up with a predicate function to stick in the filter
05:26:52 <yewT> which example?
05:27:05 <BeelsebobWork> the one with wanting to get rid of things that looked like ["a","b"]
05:27:06 <BeelsebobWork> etc
05:27:19 <Ferdirand> one question leading to another... when, and why, would you use a $ b $ c $ d instead of a . b . c $ d ?
05:27:27 <quicksilver> the latter, always.
05:27:37 <quicksilver> because . is associative so it has more subexpressions
05:27:41 <quicksilver> make it easier to factor code.
05:28:00 <BeelsebobWork> Ferdirand: you probably wouldn't
05:28:09 <yewT> oh
05:28:12 <yewT> cool
05:28:24 <BeelsebobWork> with the latter you can decide to move a . b . c into a seperate function, and have it carry on working
05:28:29 <BeelsebobWork> in the former, that would break
05:28:33 <yewT> what is _more subexpressions_ ?
05:28:39 <BONUS_> also a . b . c is a well types expression
05:28:43 <BONUS_> from a . b . c $ d
05:28:44 <quicksilver> "a . b" and "b . c"
05:28:48 <BONUS_> whereas a $ b $ c isnt
05:28:51 <quicksilver> are both valid subxpressions
05:28:56 <quicksilver> you can pull them out for reuse or refactor.
05:29:03 <quicksilver> (as well as "a.b.c" as BONUS_ mentioned)
05:29:19 <quicksilver> working with code which has more subexperssions is more pleasant.
05:29:26 <quicksilver> composes in more different ways.
05:29:48 <Cale> Also, this teaches you to understand function composition really well, because you see it all the time in your code.
05:30:32 <Cale> and function composition is near to the heart of what functional programming is about
05:31:14 <r3m0t> BONUS_: how is a $ b $ c not well-typed
05:31:28 <BONUS_> i meant if you have
05:31:34 <BONUS_> f $ g $ h $ a
05:31:45 <BeelsebobWork> r3m0t: because c isn't of the right type to pass to b
05:31:46 <BONUS_> the f $ g $ h part of that expression is not in itself a valid expression
05:32:00 <nicknull> k
05:32:13 <r3m0t> BONUS_: yes, but so what? the g $ h $ a part is
05:32:19 <BeelsebobWork> r3m0t: in f $ g $ h $ x only x, h $ x, g $ h $ x and f $ g $ h $ x are well typed
05:32:43 <Ferdirand> okay, but
05:32:44 <BONUS_> like quicksilver said, using composition means you have more sub-expressions
05:32:48 <BeelsebobWork> in f . g . h $ x, h $ x is, so is g . h $ x, so is f . g . h $ x, so is f . g. h, so is f . g, so is g . h
05:32:51 <Ferdirand> considering a . b $ c
05:32:51 <BONUS_> so you can identify them and take them out if you want
05:32:55 <r3m0t> ok
05:32:56 <quicksilver> r3m0t: so what? : So if you use . you get more subexpressions.
05:32:57 <Ferdirand> i cannot factor out (b $ c) either
05:33:18 <BeelsebobWork> Ferdirand: no, you can't -- but you can factor out (g . h)
05:33:21 <BeelsebobWork> or (f .g)
05:33:43 <Cale> Wait...
05:34:03 <Cale> Ferdirand: You're saying if you have a . b $ c?
05:34:04 <nicknull> what is ghc-core written in? assembler?
05:34:15 <Cale> Ferdirand: then b $ c is a valid subexpression of that.
05:34:23 <quicksilver> nicknull: ghc-core the program is written in haskell.
05:34:29 <quicksilver> nicknull: I'm not sure what you mean.
05:34:43 <Ferdirand> well, I could not replace it with: let x = b $ c in a . x
05:35:19 <Ferdirand> unless I misunderstood the idea of "pulling the expressions out" ?
05:35:31 <Cale> Right, you'd have to replace it with  let x = b $ c in a x
05:35:58 <nicknull> i mean when you want create a haskell runtime and compiler you first create ghc-core right? then write haskell on top of ghc-core?
05:36:17 <Cale> But at least you can make a definition which captures that bit at all.
05:37:38 <quicksilver> nicknull: not necessarily, no.
05:37:40 <yewT> @src [] (==)
05:37:41 <lambdabot> []     == []     = True
05:37:41 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
05:37:41 <lambdabot> _      == _        = False
05:37:46 <quicksilver> nicknull: ghc core is how GHC compiles stuff.
05:37:52 <yewT> could someone explain how these works? rc [] (==)
05:38:02 <quicksilver> nicknull: if you're writing your own haskell runtime and compiler you can do what you want.
05:38:25 <yewT> what underscore is false? _ == _ = False
05:38:34 <pjdelport> yewT: [] is the list type (or the empty list)
05:38:40 <quicksilver> the underscore is a pattern which matches anythign.
05:38:41 <r3m0t> yewT: [] == (x:xs) = False
05:38:42 <yewT> ok..
05:38:51 <pjdelport> (==) is the equality test
05:38:54 <pjdelport> > 5 == 5
05:38:55 <lambdabot>   True
05:39:01 <Ferdirand> somehow, I expected a big lazyness-related hidden catch in ($) vs (.)
05:39:02 <nicknull> quicksilver: ok but lets take ghc then.
05:39:02 <pjdelport> > "foo" == "foo"
05:39:04 <lambdabot>   True
05:39:13 <pjdelport> > "fib" == "fob"
05:39:14 <lambdabot>   False
05:40:00 <pjdelport> @src (==)
05:40:00 <lambdabot> x == y = not (x /= y)
05:40:09 <pjdelport> @src Eq
05:40:10 <lambdabot> class  Eq a  where
05:40:10 <lambdabot>     (==), (/=)   :: a -> a -> Bool
05:40:35 <pjdelport> yewT: (/=) is the inverse of (==), by the way
05:40:35 <yewT> oh ok
05:40:40 <yewT> thanks
05:40:41 <pjdelport> read as "not equal"
05:40:47 <lilac> Ferdirand: they're both kinda non-strict in the RHS. there's a ($!) which isn't, but no (.!) since function values are usually not _|_
05:40:48 <yewT> thanks pjdelport
05:40:57 * yewT takes a break from haskelling
05:40:58 <pjdelport> (==) and (/=) are not plain functions, as you can see
05:41:09 <pjdelport> they are part of the Eq type class
05:41:14 <lilac> Ferdirand: rather, no (.!) since function values are usualy strict anyway
05:41:25 <pjdelport> which means they have different definitions for various types
05:41:36 <pjdelport> you saw the (==) for lists above
05:41:53 <quicksilver> nicknull: take what about GHC?
05:41:55 <pjdelport> but other types have their own implementations
05:42:00 <pjdelport> @src Maybe (==)
05:42:01 <lambdabot> Source not found. You type like i drive.
05:42:14 <quicksilver> nicknull: GHC compiles haskell into something which is like a version of System F (a mathematical language)
05:42:30 <quicksilver> nicknull: it then compiles this thing - which is called ghc core - into native coe.
05:42:41 <quicksilver> nicknull: there are many detailed steps in between I have omitted :)
05:46:07 <eipi> hello, is there a separate channel for HAppS or is this one for all haskell related matters?
05:46:48 <earthy> this is for anything haskell (and many things not haskell but still related)
05:46:49 <chrisdone> the latter :-)
05:47:37 <Axman6> there is #happs too
05:47:43 <nicknull> quicksilver: ok i see
05:47:56 <nicknull> but what was that whole sutff written in? C?
05:48:01 <nicknull> perl ;)
05:48:06 <quicksilver> nicknull: haskell.
05:48:25 <quicksilver> or, some 95% or so is written in haskell.
05:48:34 <quicksilver> a few parts of the RTS are written in C or C--.
05:48:40 <Axman6> does the evil mangler still get used?
05:48:57 <quicksilver> only with -fvia-C, which is now deprecated, I think.
05:49:03 <Axman6> ok
05:50:06 <Japsu> @dice 1d44
05:50:06 <lambdabot> 1d44 => 33
05:51:48 <nicknull> quicksilver: how can you write something in haskell befor eit exists?
05:52:01 <nicknull> @lambdbot ?can haskell trvael through time?
05:52:01 <lambdabot> Unknown command, try @list
05:52:06 <nicknull> @list
05:52:06 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
05:52:16 <pjdelport> nicknull: same as bootstrapping any other compiler
05:52:20 <nicknull> @? Can Haskell do timetravel?
05:52:20 <lambdabot> Plugin `compose' failed with: Unknown command: ""
05:52:21 <quicksilver> nicknull: do you know what language gcc is written in?
05:52:43 <nicknull> c i can deduct since you ask
05:52:49 <quicksilver> same thing, then.
05:52:56 <nicknull> yes i see
05:52:56 <quicksilver> there's no more of a paradox in ghc than there is in gcc
05:53:04 <pjdelport> nicknull: http://en.wikipedia.org/wiki/Bootstrapping_(compilers)
05:53:05 <quicksilver> gcc is compiled with an older version of gcc
05:53:10 <quicksilver> ghc is compiled with an older version of ghc
05:53:19 <quicksilver> the very first gcc was compiled with some other C compiler
05:53:24 <nicknull> what is RTS? relatimesystem?
05:53:24 <mapreduce> Though there are interesting possibilities for persisting bugs/viruses through self-compilation.
05:53:31 <quicksilver> the very first ghc was compiled with some other haskell compiler
05:53:39 <quicksilver> (the thing we know call 'hbc', I believe)
05:53:46 <quicksilver> run tiem system
05:54:04 <nicknull> but long long long before haskell, what was the first haskell written in? :)
05:54:05 <quicksilver> it handles the details of thunk reduction and  garbage collection and IO multiplexing an
05:54:09 <pjdelport> @go reflections on trusting trust
05:54:12 <lambdabot> http://www.ece.cmu.edu/~ganger/712.fall02/papers/p761-thompson.pdf
05:54:12 <lambdabot> Title: Reflections on Trusting Trust
05:54:19 <quicksilver> a language called 'gopher', I believe.
05:54:32 <pjdelport> or http://cm.bell-labs.com/who/ken/trust.html
05:56:59 <nicknull> ok there is no spoon
05:58:02 <cjs> Hmph. Unrelated, except that I'm doing this in Haskell: on a Unix box, if I've got a 600 MB file, and I want to insert a few characters near the beginning, is there an efficient way to do this?
05:58:44 <quicksilver> not with standard posix file apis, as far as I know
05:58:54 <quicksilver> there might be something exotic and more recent.
05:59:20 <cjs> Yeah, that's what I reckoned.
06:25:55 <hugo_> i have rewritten the code: http://hpaste.org/11114
06:26:04 <hugo_> but now i have a diff error, can someone help ?
06:26:12 <hugo_> i thought IOError would go along an IO type
06:26:37 <nicknull> could haskell replce C as a systems programming language? it seems haskells purity is well suited for such things.
06:27:23 <Philippa_> nicknull: Haskell as it is couldn't, it's a GCed language. Something related could, but it'd probably be a strict language
06:28:01 <IsoPallo> Hmm... A systems programming language almost nessecarily needs some way to put in asm too...
06:28:10 <IsoPallo> typos++
06:28:11 <cjs> There was actually a paper from a project devoted to just this at the ICFP conference last month.
06:28:23 <cjs> I can try to dig up a reference, if you like.
06:28:42 <twanvl> C is also a better match to hardware, since that is not exactly pure either
06:28:42 <IsoPallo> At least I can't trust the compiler in all the small details that show up.
06:29:11 <IsoPallo> But maybe some better programmer could, don't know.
06:29:29 <cjs> It turns out that often C compilers are not all that trustworthy, either.
06:29:47 <IsoPallo> But inline asm tends to be...
06:29:54 <hugo_> gcc ftw!
06:30:16 <quicksilver> twanvl: I dispute that particular point.
06:30:26 <quicksilver> twanvl: haskell's IO monad is just as much matched to hardware as C.
06:30:56 <quicksilver> gc is likely to be a more practical concern. Although gc'ed settings have been used for fairly lowlevel stuff I believe.
06:31:17 <quicksilver> IsoPallo: linux uses very little inline asm as far as I know, for example.
06:31:19 <dolio> Some people claim that C isn't a very good match to modern processors anyway, pure or not.
06:31:28 <quicksilver> (witness the fact it works on so many different architectures)
06:32:39 <dolio> Although I suppose that'd push Haskell even further away in the comparison.
06:32:56 <dolio> (Unless, possibly, you're talking about stream processors/gpus.)
06:34:12 <IsoPallo> quicksilver: Yes, but it is made by better programmers than me :) The asm is in machine-dependet parts and often separate (not inline) that is true...
06:36:39 <nicknull> so a strict non-grabge-collected language with a assembler-interface
06:36:59 <Philonous> Is there a monad that handles fft and convolution of lists/arrays?
06:37:00 <nicknull> cjs: please a ref
06:37:24 <dolio> ATS might be closer to "systems programming suitable" than any Haskell compiler.
06:37:37 <dolio> Especially with its inline C.
06:39:02 <Cthulhon> Well, Symbolics, et al showed that functional languages can be used for systems coding with LISP machines, no?
06:39:31 <nicknull> true
06:39:54 <nicknull> but why didnt they succeed? the systems were good right? but machines to expensive?
06:40:25 <nicknull> and as that a direct result of using lisp or it could have been made as cheap as now if more research had went into it?
06:40:26 <dolio> Massive anti-lisp conspiracy.
06:40:30 <nicknull> lol
06:41:21 <quicksilver> market forces and hysterical raisins
06:41:30 <quicksilver> rather than straight-out technical causes, I imagine
06:42:01 <earthy> mostly 'not compatible with big iron' and 'nobody got fired for buying ibm'
06:42:19 <earthy> plus high price tags
06:43:46 <Philippa_> Cthulhon: that's a bit of a special case
06:45:01 <Cthulhon> How so?
06:45:07 <bockmabe> morning #haskell
06:45:11 <Cthulhon> I mean, the technology worked.
06:46:35 <Philippa_> Cthulhon: are you familiar with, amongst other things, why people might not actually consider lisp a functional language? You /are/ aware that those machines were specifically designed to run it, right?
06:46:44 <Cthulhon> Yes.
06:46:57 <Philippa_> so it's not a general environment by a long stretch
06:47:08 <Philippa_> "can it be done at all?" - well duh
06:47:26 <Philippa_> that's a no-brainer so long as you understand the languages involved
06:47:28 <chrisdone> (points at CAR and CDR)
06:47:48 <Cthulhon> Well, it's not x86, but defining 'general' as whatever we have now seems narrow minded.
06:47:49 <Philippa_> it's also not sufficient to give you use in current environments
06:48:05 <Philippa_> defining 'general' as 'should include what we have now', however...
06:48:09 <earthy> hm. it seems as though the STG is based off of Symbolics' designs...
06:49:14 <Philippa_> and x86 is far from the only issue
06:49:24 <chrisdone> I wonder what the Sussman thinks of Haskell
06:50:11 <Philippa_> for a first pass, "should be usable for most if not all tasks C is usable for given an implementation" isn't bad for "general systems programming language"
06:50:34 <idnar> http://www.haskell.org/haskellwiki/Exception -- why not use Either instead of ExAction?
06:50:36 <lambdabot> Title: Exception - HaskellWiki
06:52:25 <quicksilver> idnar: no reason at all.
06:52:34 <quicksilver> idnar: it's just written that way for clarity.
06:54:01 <idnar> quicksilver: okay
07:10:25 <mav> Hi, I'm trying to get started with Haskell. I have a trivial program that compiles w/ ghc from the command line, but gives me a './gen-api-test.hs:6:7:    Could not find module `System': it is a member of package haskell98, which is hidden' when using cabal's build command. Where can I find documentation to help me out? Thx.
07:10:25 <mav>  
07:10:34 <matthew-_> @seen ivanm
07:10:34 <lambdabot> ivanm is in #haskell, #xmonad and #gentoo-haskell. I last heard ivanm speak 20m 43s ago.
07:10:45 <matthew-_> ivanm: I am here!
07:10:46 <lambdabot> matthew-_: You have 1 new message. '/msg lambdabot @messages' to read it.
07:10:49 <matthew-_> ahh
07:12:43 <lispy> hey guys, top of the lambda!
07:12:48 <lispy> (and good morning too)
07:13:40 <matthew-_> @tell ivanm because both the key and value could potentially have strings in them, so it's the only safe thing to do
07:13:40 <lambdabot> Consider it noted.
07:13:52 <matthew-_> @tell ivanm err, I meant, spaces
07:13:52 <lambdabot> Consider it noted.
07:14:07 <ivanm> matthew-_: heh, here but not for much longer
07:14:08 <lambdabot> ivanm: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:14:20 <Baughn> mav: Basically, you just need to add "build-depends: haskell98" to the cabal file
07:14:24 <ivanm> thing is, that doesn't produce valid graphviz output then
07:14:31 <Baughn> mav: However, it might be said that haskell98 is a bit outdated. There are better functions in ghc's standard library, not to mention on hackage.
07:14:37 <matthew-_> oh, does it object to quoted keys?
07:14:42 <ivanm> yup
07:14:48 <matthew-_> bummer
07:14:52 <ivanm> yup
07:15:05 <ivanm> matthew-_: filter (not . isSpace) ?
07:15:11 <matthew-_> well then some sort of smart constructor for Unknown (i.e. an "unknown" function)
07:15:14 <matthew-_> yup, indeed
07:15:27 <matthew-_> yay, manual input validation
07:15:29 <matthew-_> yay
07:15:30 <ivanm> heh
07:15:42 * matthew-_ remembers the one thing in the world Perl is useful for
07:15:56 <ivanm> well, you also don't have options for the various ratio pre-defined values
07:16:03 <matthew-_> mmm. my bad
07:16:07 <ivanm> matthew-_: oh? perl's good for something except for mangling evilly?
07:16:17 <matthew-_> I was losing the will to live whilst writing Attributes.hs
07:16:30 <ivanm> heh, yeah, I know what you mean
07:16:52 <matthew-_> it rapidly became a hard, dull, slog which amounted in the least possible effort to get, maybe 80%, covered
07:16:59 <ivanm> yup
07:17:22 <matthew-_> yeah, feel free to fix them ;)
07:17:37 <Axman6> anyone read this? http://bit.csc.lsu.edu/~gb/csc4101/Reading/gigo-1997-04.html the story of Ada, and how it was designed to be totally disfunctional (and very expensive to use at all stages)
07:17:38 <lambdabot> Title: Sigplan Not. Apr 1997: I Have a Feeling We're Not in Emerald City Anymore
07:17:38 <ivanm> but I think if you do something with Unknown (maybe have concat . intersperse "_" . unwords ?), then it'd be OK
07:17:52 <ivanm> heh, I've actually got to write my thesis up, and I don't actually get graded on code :s
07:17:57 <ivanm> in a couple of weeks maybe
07:18:01 <ivanm> anyway, I should hit the sack
07:18:02 <ivanm> g'night
07:18:04 <matthew-_> yeah, sounds familiar ;)
07:18:06 <matthew-_> sleep well
07:18:23 <mav> Baughn: thanks, that does it. I don't have to use haskell98, but need to understand a bit better cabal. My real problem is to use a cabal installed parsec library. The only reason for haskell98 is getArgs, I'll try to find an equivalent.
07:20:54 <Baughn> mav: System.Environment
07:26:29 <mav> Baughn: thx again.
07:37:16 <patai> Hi, I have a problem with laziness and profiling. Description at http://pastebin.com/f4b9284af
07:41:53 <nicknull> anyway, haskell is just philosophically pure right? under the hood it uses impurity like hell right?
07:42:13 <Baughn> Well.. yes, that's the point of laziness
07:42:18 <Baughn> Some of the point, at least
07:42:26 <BONUS> but what matters is that its pure to you as a programmer
07:42:31 <Baughn> It still lets you _treat_ it as pure
07:42:37 <nicknull> yes
07:42:45 <BONUS> as long as it behaves like it should and its reasonably fast, i dont care what it does under the hood personally
07:42:54 <Baughn> (Except when it doesn't, as when you explicitly use that laziness to amortize data structure changes, or whatever..)
07:43:20 <nicknull> im learning C now and things like if (p=malloc(...)) make me puje. it is a test but then it changes state inside no  matter the resut of the test. seems ugly
07:43:27 <nicknull> puke
07:43:27 <Apocalisp> There's no "under the hood" at the Haskell level. You would be talking about an implementation like GHC, not Haskell itself.
07:43:35 <nicknull> sure
07:43:54 <BONUS> i'd think of malloc as primarily something that changes state
07:44:05 <BONUS> and it also reports back a pointer
07:44:38 <nicknull> yes hwta i meant was: if (p=malloc()) . the if i read as just a test. but then you have a change of state regardless of the testresult. it mixes a test with an assignemtn
07:45:03 <nicknull> i prefer then p=malloc...; if p==NULL
07:45:18 <nicknull> anyway this is not C :)
07:45:23 <lispy> nicknull: C++ actually makes this worse, by letting you create/assign a variable in an if statement so that the variable is only scoped over the if :)
07:46:39 <flux> I don't think it's worse
07:46:51 <flux> because you need to give the type there also
07:46:53 <earthy> equally bad
07:47:08 <lispy> Perhaps I should have said, encourages this
07:47:19 <flux> it's actually relatively useful feature: if (P* ptr = find()) { .. }
07:47:45 <flux> but anything more advanced is impossible, such as ((int ptr = find()) == 42) { .. }
07:47:56 <lispy> flux: well, so is the previous thing.  It's useful, that's why it occurs so much in practice...but it is kinda sneaky
07:48:12 <flux> lispy, well, compilers can give a warning for that
07:48:20 <flux> (such as gcc)
07:48:27 * lispy hugs gcc
07:48:37 <flux> whereas it's much more difficult to accidentalyl do that P*-thingy
07:48:39 <lispy> did you know gcc has a keyword for pure functions?
07:48:56 <flux> I may have read about that somewhere
07:49:04 <lispy> and it can optimize better with that information, assuming you didn't lie to it
07:49:20 <flux> I suppose it can lie it anyway, it just might break in horrible ways :)
07:49:24 <flux> s/lie/optimize/
07:49:55 <lispy> heh yeah, just like unsafePerformIO
07:51:48 <earthy> unsafeNoReallyWeMeanItThisCouldLaunchNukesPerformIO
07:52:40 <nicknull> int cube(int x) {return x*x*x;} is pure right? what keyword would i use?
07:54:11 <osfameron> nicknull: **3 ?
07:54:32 <lispy> nicknull: I'd have to check the gcc manual, it's something like __pure
07:54:55 <osfameron> ah, not paying attention, sorry
07:55:33 <lispy> nicknull: http://gcc.gnu.org/onlinedocs/gcc-4.1.2/gcc/Function-Attributes.html#index-g_t_0040code_007bpure_007d-function-attribute-1817
07:55:37 <lambdabot> Title: Function Attributes - Using the GNU Compiler Collection (GCC), http://tinyurl.com/3t5maw
07:55:47 <lispy> int square (int) __attribute__ ((pure));
07:56:38 <kpreid> lispy: ooh!
08:02:17 <yakov> hello
08:02:23 <r3m0t> hi
08:08:05 <rog_> how efficient is structure mutation? does `s {foo = bar}' always make a copy of s. or is it more intelligent about it, for instance, depending on how many currently outstanding references to s are around?
08:08:30 <rog_> (i'm talking about GHC here, BTW)
08:09:40 <rog_> (and i'm assuming that the resulting expression is actually used)
08:09:48 <hugo_> where can i find a good "haskell vs lisp" comparison ?
08:09:59 <hugo_> (a friend is asking me for one...)
08:11:15 <shukhov> scheme or cl?
08:11:26 <hugo_> cl
08:13:07 <yakov> hm, ghc 6.8.3 reports --mk-dll as an unrecognized flag in win32.. how one could build dll then
08:13:08 <shukhov> http://news.ycombinator.com/item?id=317051 ?
08:13:12 <lambdabot> Title: Hacker News | Ask HN: Deciding between Haskell & Lisp
08:13:33 <yakov> i'm making dll to be called from foreign application
08:13:39 <shukhov> no much info there though
08:14:30 <quicksilver> rog_: it always makes a copy of s, but that's cheap.
08:14:37 <quicksilver> rog_: pointer are cheap.
08:15:00 <ddarius> quicksilver: It depends on how large s is and how often this occurs.
08:15:05 <rog_> quicksilver: but, presumably, the copy isn't just a pointer copy
08:15:23 <rog_> quicksilver: i'm contemplating some quite large structures.
08:15:27 <quicksilver> rog_: it's one pointer per field of s
08:15:34 <quicksilver> typically.
08:15:42 <quicksilver> ddarius: indeed. It was a generalisation.
08:16:06 <rog_> is the same true for arrays?
08:16:18 <quicksilver> yes.
08:16:19 <rog_> i thought there were some clever optimisations around
08:16:28 <quicksilver> you were wrong.
08:16:46 <quicksilver> well, of course there are lots of clever optimisations around ;)
08:16:48 <quicksilver> but not this one.
08:17:07 <quicksilver> the nicest structure for sharing between slight modifications is something tree like
08:17:10 <quicksilver> e.g. a fingertree
08:17:14 <quicksilver> like Seq
08:17:15 <ddarius> Something along this lines -could- be done, and Clean does it, but no Haskell compiler does.
08:17:17 <rog_> ok, so if i've got a 1000000 element array and i change one element, it will be copied. even if there are no other references to it? hmm.
08:17:25 <ddarius> rog_: Yes.
08:17:39 <quicksilver> yes, if you use an immutable array.
08:17:46 <ddarius> You shouldn't be changing single elements of an immutable array at a time.
08:17:52 <quicksilver> I would say, if 1000000 element arrays with many small changes are your goal
08:17:59 <quicksilver> then that could be a good time to use a mutable array.
08:18:06 <byorgey> or a DiffArray
08:18:14 <ddarius> You could try DiffArray but I don't hear good things about it.
08:18:21 <rog_> mutable arrays... in haskell?
08:18:27 <lilac> STArray
08:18:29 <quicksilver> rog_: sure. MArray
08:18:35 <ddarius> rog_: Haskell has more array types than any language I believe.
08:18:38 <quicksilver> (IOArray, STArray, IOUArray, STUArray)
08:18:43 <rog_> @hoogle MArray
08:18:44 <lambdabot> module Data.Array.MArray
08:18:44 <lambdabot> Data.Array.Base class Monad m => MArray a e m
08:18:44 <lambdabot> Data.Array.MArray class Monad m => MArray a e m
08:18:48 <quicksilver> plus the newer things
08:18:53 <quicksilver> storablevector, uvector
08:19:00 <rog_> @hoogle STArray
08:19:00 <lambdabot> Data.Array.Base listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
08:19:00 <lambdabot> Data.Array.IArray listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
08:19:00 <lambdabot> Data.Array.Base listArrayST :: Ix i => (i, i) -> [e] -> ST s (STArray s i e)
08:19:38 <rog_> what was that quote about 100 operations on one data structure being better than 10 ops on 10 data structures.... ?
08:19:53 <conal> rog_: hm.  it's from perlis
08:20:19 <conal> It is better to have 100 functions operate on one data structure than 10 functions
08:20:31 <rog_> sometimes i wonder if haskell falls into the latter trap.
08:20:32 <ddarius> rog_: See the fourth slide of http://www.galois.com/~dons/slides/08-07-stewart.pdf
08:20:34 <lambdabot> Title: cache:http://www.galois.com/~dons/slides/08-07-stewart.pdf - Google Search
08:20:40 <conal> rog_: http://www.cs.yale.edu/quotes.html
08:20:41 <lambdabot> Title: Perlisisms - "Epigrams in Programming" by Alan J. Perlis
08:20:47 <quicksilver> rog_: haskell /= the haskell libraries
08:21:01 <conal> rog_: "9. It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures. "
08:21:02 <quicksilver> rog_: the haskell libraries are under rapid development
08:21:12 <quicksilver> all kinds of new datastructures are being tried out
08:21:32 <quicksilver> when the work is more complete it will become clearer which ones represent a good working set.
08:21:41 <ddarius> Anyway, Alan is wrong.  It's better to have 100 functions operate against one interface, but even that isn't terribly true.
08:22:00 <rog_> ddarius: "wrong" is strong there
08:22:03 <ddarius> While there is definitely scope for unification, there is a reason there are so many array types.
08:22:06 <quicksilver> there is a very large design space for how to get "efficient pure data structures"
08:22:17 <quicksilver> (made larger by different possible definitions of efficient)
08:22:21 <quicksilver> and we're exploring it still.
08:22:30 <rog_> ddarius: nice reference, BTW. ta.
08:24:01 <rog_> in my case, i'm generating code that stacks many (s -> a -> s) transformations on top of one another, folded together.
08:24:47 <ddarius> You may be able to expect inlining.
08:24:58 <ddarius> So that several of the updates will become one bigger update.
08:25:10 <rog_> ... but the underlying structure is heterogeneous, so arrays aren't a great solution either. but at least with an array one can iterate through the members algorithmically.
08:25:37 <ddarius> rog: You can have a tuple/record of IO/STRefs
08:25:48 <quicksilver> I'm a great believer in the right data structure for the right job, rog_.
08:25:57 <quicksilver> Thus far you haven't quite given us enough information about the job ;)
08:26:32 <quicksilver> nested records can be a useful point in the design space
08:26:35 <quicksilver> so can zippers
08:26:38 <rog_> true. that's partly because the "job" isn't yet fully defined.
08:26:44 <quicksilver> so can Data.Map
08:26:47 <ddarius> "Right data structure for the right job." is in stark contrast to Alan's statement.
08:26:58 <quicksilver> agreed, ddarius.
08:27:09 <quicksilver> it's the haskell way.
08:27:17 <quicksilver> Strong typing makes you choose the right structure.
08:27:18 <ddarius> quicksilver: agreed
08:27:23 <quicksilver> In perl/python you always use a dictionary.
08:27:31 <quicksilver> in java you always use a class.
08:27:35 <quicksilver> well, sort of. I exagerrate.
08:27:39 <quicksilver> but that's the idea.
08:27:48 <rog_> if the right data structure exactly depends on the job, then everyone will use different data structures. and no code will inter-operate post-design.
08:28:20 <ddarius> rog: Sure they can interoperate.  That's what interfaces are for.
08:28:30 <ddarius> Anyway, "right" can include "cost effective"
08:28:35 <conal> sjanssen: ping
08:28:56 <rog_> ddarius: only if the interface isn't defined in terms of the data structure.
08:29:12 <quicksilver> rog_: rubbish.
08:29:17 <quicksilver> you can use other people's data structures.
08:30:07 <rog_> quicksilver: sure, if you're using two pieces of code that are using different data structures in their interfaces, putting them together can be a pain
08:30:19 * quicksilver shrugs
08:30:31 <quicksilver> experience tells me that this is mostly a non-issue.
08:30:39 <quicksilver> conversion code, if it needs to be written, is trivial.
08:30:58 <ddarius> Again, this is what interfaces are for.  If two pieces of code need to work together then you define an interface for them to communicate.
08:31:54 <ddarius> That simply becomes one more constraint on your super magical data structure.
08:31:57 <lilac> the bigger issue is that the job changes during development
08:32:28 <ddarius> lilac: Which simply adds flexibility to the constraints on your super magical data structure.
08:32:47 <ddarius> I never said, and I don't think quicksilver ever implied, that "right" == maximally performant
08:33:06 <quicksilver> my experience is that if you make a mistake and have to change the underlying structure that is *easier* in haskell than any other language
08:33:15 <quicksilver> because the types have forced you to keep your interface well defined
08:33:23 <rog_> from my own experience, it's great when you have two interfaces defined in terms of the same constructs. you can just plug and play. but when putting together different data structures, there's often an impedance mismatch that means it's hard.
08:33:28 <quicksilver> and as long as client code only uses that interface, you know what you have to change.
08:33:40 <quicksilver> and the type checker finds you any bits you missed.
08:33:58 <rog_> quicksilver: i agree about those advantages. but i don't think they're a panacea
08:34:08 <quicksilver> no, not a panacea.
08:34:11 <quicksilver> just better than anything else.
08:34:23 <rog_> quicksilver: (not that i've programmed in haskell itself for long). but i am used to strictly-typed languages.
08:34:27 <quicksilver> if they were a panacea we'd all be out of a job.
08:34:36 <quicksilver> because it would all Just Work ;)
08:34:42 <hugo_> allright, my friend is emergin ghc, and is going to give haskell a try :D
08:34:46 <hugo_> haskell evangelization 101 :D
08:35:16 <BeelsebobWork> emerging ghc will take a while
08:35:24 <hugo_> heheh :)
08:36:11 <hugo_> he was looking to ditch python, and go into a functional language
08:36:15 <hugo_> nice
08:36:24 <BeelsebobWork> sounds fun
08:36:54 <rog_> if "use the right data structure for the job" is true, then why are lists so widely used? they're probably not optimal for many of the uses they're put to, but they're good enough and everyone understands them...
08:37:16 <BeelsebobWork> rog: because unfortunately the language designe decided to make them special
08:37:19 <quicksilver> well it's always possible that some decisions made by human beings are not the right decision.
08:37:23 <BeelsebobWork> so they're easier to use than any other data structure
08:37:27 <quicksilver> but, lists are actually very widely applicable
08:37:28 <idnar> rog_: if they're good enough and everyone understands them, maybe they are optimal in the ways that matter?
08:37:43 <quicksilver> they are the equivalent of other languages 'Iterator' or 'Enumerable'
08:37:45 <ddarius> rog_: Lists, in Haskell, represent loops.  Also, again, there are many factors that lead to an "optimal" choice.  Being quick to write is one factor.
08:37:54 <quicksilver> which is pretty widely applicable concept.
08:38:19 <rog_> idnar: i think that's my argument for having fewer, better understood, and more widely used data structures...
08:38:23 <ddarius> rog_: If you want to see a place where they are abused look at (some) Lisp code.
08:38:34 <quicksilver> rog_: that is a good argument.
08:38:43 <rog_> ddarius: in lisp, lists aren't really lists.
08:38:45 <quicksilver> it's just that we don't know which are the right "fewer" yet.
08:38:50 <quicksilver> not all of them, anyway.
08:38:51 <ddarius> rog_: And yet they are still abused.
08:38:54 <quicksilver> lists is definitely one.
08:39:24 <rog_> ddarius: how can you abuse something that is just a pair of pointers...?
08:39:51 <quicksilver> let me count the ways ;)
08:39:55 <ddarius> rog_: You'd think it would be hard...
08:40:50 <rog_> ddarius: problem is in lisp, you've got no tuples. or immutable data structures. yuk.
08:41:24 <rog_> ddarius: so you're forced into abuse, just 'cos it's what your parents were into. kinda.
08:41:52 <ddarius> Most languages don't have immutable data structures and they don't define everything in terms of mutable pairs.
08:42:24 <rog_> ddarius: i'm not entirely what kind of abuse you're talking here, actually.
08:42:57 <rog_> ddarius: most languages don't pretend to be multi-paradigm.
08:43:51 <ddarius> Using lists as n-tuples, using lists as arrays, using lists as dictionaries, using lists as algebraic data types, using lists as single element boxes, trying to use lists as parametric data structures, e.g. trees.
08:44:12 <ddarius> Hell using "lisp lists" as lists!
08:45:15 <lilac> lists often are the "right" data structure for the job in haskell, because they're well understood, there are a lot of pre-existing functions which work with them, etc.
08:45:43 <rog_> lilac: "pre-existing functions" is exactly the point.
08:45:46 <dolio> And then people write articles about how much better Lisp is than other languages because of the list abuse. :)
08:49:24 <rog_> ddarius: i think the key is making sure that you can't break invariants through the interface. where lisp goes wrong is defining stuff as lists when, even if that's the actual implementation, it should be hidden.
08:49:33 <quicksilver> rog_: they're the "right" structure because they represent linear loops, enumeration, etc.
08:49:55 <quicksilver> there are lots of pre-existing functions because those things are (a) common and (b) manipulatable in many interesting ways
08:49:58 <quicksilver> filter, map, etc.
08:50:13 <quicksilver> so there are reasons they are good. Not just that they're predefined.
08:52:31 <rog_> quicksilver: i agree. but i think the same reasoning *could* apply to, for instance, (key -> value) maps - once everyone agrees on a common interface to something that solves a common problem, a "software ecosystem" can grow up around it.
08:53:15 <rog_> i think that Clojure has some interesting ideas here.
08:53:16 <quicksilver> sure.
08:53:28 <quicksilver> There is a standard haskells structure for key -> value maps
08:53:39 <rog_> what's that?
08:53:44 <quicksilver> Data.Map
08:54:04 <quicksilver> it permits reasonably efficient persistent update
08:54:15 <quicksilver> and has a reasonable variety of combinators
08:55:31 <rog_> quicksilver: but it's a data structure rather than a class. so if i want to switch to (say) an array representation, it's not so easy.
08:55:49 <quicksilver> haskell interfaces typically make performance promises
08:55:56 <quicksilver> so we don't have classes for them
08:56:06 <quicksilver> because no class would be able to give interesting performance promises.
08:56:11 <mmorrow> rog_: i don't think common interface == the same implementation of that abstract interface
08:56:19 <rog_> quicksilver: no, but a given instance could.
08:56:23 <quicksilver> you can put together a trivial interface if you like.
08:56:28 <mmorrow> a finite map has some pretty standard operations
08:56:31 <quicksilver> my experience is, that's not useful.
08:56:37 <quicksilver> someone wrote a 'ListLike' class
08:56:40 <quicksilver> nobody uses it
08:56:44 <quicksilver> as far as I can see, it's not useful.
08:57:03 <quicksilver> somebody else wrote 'Foldable' which is another sense of ListLike, and that *does* get used because it *is* useful.
08:57:03 <Baughn> rog_: If you want classes, look at EdisonAPI
08:57:10 <dolio> There's a whole library of interfaces to existing Haskell data structures (and some other stuff) that no one uses.
08:57:13 <Baughn> rog_: It's got a wrapper for the standard Data.Map, too
08:57:15 <rog_> it might be useful if all the existing list-based functions could operate on it...
08:57:15 <mmorrow> lookup,insert{With{...}},toList,fromList,fold,elems,keys,mapKeys,mapElems,map,delete,intersection,union,subMap,split...
08:58:29 <quicksilver> rog_: the class replaces them, so they do.
08:58:34 <quicksilver> however, as I say, I don't find it useful.
08:58:43 <mmorrow> i never use it either
08:58:48 <quicksilver> and I've not seen any code using it so I'm assuming other people don't find it useful either.
08:59:06 <quicksilver> laziness allows you to treat [a] itself as an interface
08:59:26 <quicksilver> other list-like structures can just provide a toList view.
08:59:35 <Baughn> Asking again, how is http://www.haskell.org/ghc/docs/latest/html/libraries/index.html built? I tried asking ghc to build documentation, which it did, but failed to combine them like this
08:59:35 <lambdabot> Title: Haskell Hierarchical Libraries
08:59:54 <rog_> i was reading the "iteratees" presentation (http://okmij.org/ftp/Streams.html#iteratee) this morning, and i kept on thinking, "this should be unnecessary". in particular, other data structures can *not* always just provide a toList view.
08:59:55 <lambdabot> Title: Streams and Iteratees
09:00:18 <mmorrow> and no matter what structures you have, you'll want to fmap (\thing -> stuffWith thing) [list_of_hugely_complex_yet_encapsulated_and_standardized_things] :)
09:00:19 <rog_> (when there are side-effects involved.)
09:01:10 <Baughn> ..or I may just have forgotten to run install-docs. How odd - most of the docs got installed regardless.
09:01:11 <quicksilver> rog_: I can't see a better alternative, myself.
09:01:17 <mmorrow> so you may not want to dump a structure /to/ a list representation, but you'll always want to have a list /of/ said structures, then fold them or what-have-you
09:01:23 <rog_> classes like Functor and Monad are where haskell really shines... common interfaces to common problems.
09:01:35 <Baughn> Then again, no.. it really is broken
09:02:12 <quicksilver> rog_: sure. experience shows that Functor and Monad are useful classes.
09:02:22 <quicksilver> so are Foldable and Traversable and Applicative
09:02:32 <quicksilver> but, equally, ListLike does not appear to be.
09:02:40 <quicksilver> and I'm not sure MapLike is.
09:02:44 <quicksilver> I'm happy to be proven wrong.
09:04:20 <mmorrow> i'm starting to more and more dislike using classes at all (not refering to Functor/etc, but classes i may write), and prefer records of functions
09:04:50 <quicksilver> yes. Most uses of classes by programmers (as, arbitrarily, opposed to library authors) are wrong.
09:05:09 <quicksilver> it's more flexible and more useful to use standard higher-order techniques.
09:05:35 <quicksilver> typeclasses are for the special - and fairly unusual technique - when you want the *compiler* to select which functions to use, not the programmer
09:05:39 <quicksilver> based on type inference.
09:05:42 <mmorrow> and you're not restricted by the limitations imposed by rules for class instances/etc
09:05:58 <quicksilver> so type classes are all about ad-hoc overloading
09:06:08 <quicksilver> and nothing to do with specifying abstract interfaces
09:06:15 <quicksilver> contrary to popular belief ;)
09:06:34 <vininim_> @users
09:06:34 <lambdabot> Maximum users seen in #haskell: 518, currently: 486 (93.8%), active: 15 (3.1%)
09:06:43 <mornfall> Hm. You can't do hGetContents on a process' stdout and thet waitForProcess, right? How do you force that file contents?
09:06:43 <Baughn> quicksilver: How about when you want the programmer to select a function to use by type instead of name? ;)
09:06:44 <vininim_> oboy
09:06:52 <mornfall> Well, file, whatever.
09:07:11 <mornfall> vininim: Oboy?
09:07:17 <Baughn> mornfall: evaluate (length string)
09:07:24 <rog_> the only time i've defined a class is when i wanted functions to do particular sets of arithmetical operations on values. a class seemed like a natural fit here, and a record of functions would have been fairly awkard to use.
09:07:29 <quicksilver> mornfall: complain bitterly that hGetContents is broken.
09:07:37 <Baughn> mornfall: Hackage.strict
09:07:37 <quicksilver> mornfall: then use a strict version.
09:07:53 <mornfall> quicksilver: Which is called..?
09:07:58 <Baughn> mornfall: http://hackage.haskell.org/packages/archive/strict/0.3.2/doc/html/System-IO-Strict.html
09:08:00 <lambdabot> Title: System.IO.Strict, http://tinyurl.com/58xunw
09:08:04 <vininim> mornfall: lot's of people in the channel today =)
09:08:35 <mornfall> I think oboy is a transcription of гобой for some reason which is oboe which has some ties to some haskell people which is just weird.
09:09:01 <mornfall> Baughn: No easier way, not involving external dependencies?
09:09:04 <rog_> mornfall: you can force it by evaluating the full result of hGetContents (e.g. with length)
09:09:08 <mornfall> Baughn: (They are forbidden in a Setup.hs anyway.)
09:09:21 <mornfall> rog_: But how do I force that length to be evaluated?
09:09:26 <Baughn> mornfall: evaluate (length string), as mentioned
09:09:27 <rog_> mornfall: seq.
09:09:29 <mornfall> I could print it, but that' just wrong.
09:09:37 <Baughn> mornfall: evaluate is an IO action
09:09:46 <mornfall> Baughn: And in base?
09:09:51 <Baughn> Control.Exception, yes
09:09:54 <mornfall> Ah.
09:09:58 <ddarius> toList is like C++'s begin()
09:10:05 <mornfall> Oh d'oh.
09:10:11 <mornfall> I even use it in that file already. Sigh.
09:10:18 * mornfall hits forehead.
09:11:03 <dolio> quicksilver: Considering the connections various people have pointed out between type classes and ML modules, and the fact that the latter are used for abstract interfaces, I'm not sure your opinion is necessarily definitive.
09:11:20 <quicksilver> dolio: my opinion is never definitive, as far as I know.
09:11:26 <dolio> :)
09:11:37 <quicksilver> (unless there is a dictionary of 'quicksilver's wise sayings' of which I am unaware)
09:11:44 <dolio> Heh.
09:11:46 <Baughn> mornfall: If you're really paranoid, the correct construction is "evaluate (rnf string)"
09:11:55 <quicksilver> dolio: but, those connections are of the form "there exists and isomorphism between foo and bar"
09:12:03 <quicksilver> dolio: which is not really related to software engineering.
09:12:31 <ddarius> Another definitive saying by quicksilver
09:12:41 * mmorrow counts the seconds until he can program with something like cayenne-style records
09:12:45 <Baughn> Oh, by the way - if evaluate rnf on some overly complex data-structure twice, will it be O(1) the second time?
09:12:49 <quicksilver> dolio: in terms of how they should actually be used, in real programs, by real programmers, I submit that typeclasses are a poor notion of abstract interface.
09:12:59 <ddarius> Baughn: No.
09:13:03 <quicksilver> at least compared to 'explicit dictionary' which lives next door
09:13:09 <quicksilver> and is much more general.
09:13:24 <rog_> quicksilver: ... and in haskell '98 you can only define them with respect to a single type anyway. which is very restrictive.
09:13:40 <quicksilver> Baughn: second time wil be O(number of pointers the RTS has to follow)
09:13:43 <Baughn> ddarius: Didn't think so. Could it be, in principle? Does ghc store enough information to tell the thunk's already been (recursively) dethunked already?
09:13:47 <quicksilver> Baughn: which is O(n) in some sense.
09:13:48 <mmorrow> which cover all capabilities of ml or haskell modules, yet are first class structures
09:13:59 <ddarius> Baughn: It's not the thunks that are the problem.
09:14:01 <quicksilver> rog_: not sure what you mean by that.
09:14:21 <quicksilver> rog_: only define classes with respect to single type?
09:14:48 <rog_> quicksilver: well, you're not allowed to do: "class Blah a b where ..."
09:14:59 <quicksilver> oh, MPTCs.
09:15:01 <quicksilver> indeed, yes.
09:15:02 <Baughn> ddarius: I believe I understand. It wouldn't normally be possible for the runtime system to tell that J. Random Data doesn't point to some thunky data somewhere down the chain?
09:15:07 <quicksilver> I think that's orthogonal, though.
09:15:20 <Baughn> Well, it was just a thought, but this does mean I'll have to be very careful about using rnf
09:15:21 <quicksilver> I don't think MPTCs come up in a naive discussion of interfaces like ListLike
09:15:32 <quicksilver> although they certainly come up in the *implementation* of such things in practice
09:15:42 <quicksilver> but thats because of other problems like identifying the element type.
09:15:49 <ddarius> Baughn: It could do that some way or another, but it would be a pain to implement and significantly impact performance for very little gain.
09:16:06 <ddarius> Baughn: Don't use rnf willy-nilly.  I personally don't recommend using it at all.
09:16:12 <quicksilver> ddarius: ....unless the dawn of parallel programming causes us to use 'rnf' much more often
09:16:19 <rog_> quicksilver: it wasn't for me, the first time i started to use haskell. i tried to define a class to specify an interface involving relationships between several types, and ran straight into that restriction.
09:16:37 <quicksilver> ddarius: in which case an optimisation to stop double use being expensive might be a big win ;)
09:16:37 <rog_> quicksilver: i quickly realised that a structure containing functions was the way forward.
09:16:43 <quicksilver> rog_: *nod*
09:16:47 <Baughn> ddarius: It's annoying having to care about implementation details when multithreading, though
09:16:48 <quicksilver> (sounds like you're agreeing with me then)
09:17:01 <mmorrow> and evaluating a thunk may produce one or more /new/ thunks too...
09:17:03 <rog_> quicksilver: i am
09:17:21 <rog_> quicksilver: do you find that surprising? :-)
09:17:24 <mmorrow> so i think the only way to know if something is evaluated is to evaluate it
09:18:41 <rog_> mmorrow: ... or to `seq` it in the context of something that you know will be evaluated, presumably?
09:19:22 <quicksilver> while we're taking me as definitive. Control.Exception.evaluate considered harmful ;)
09:19:43 <quicksilver> it's a strange construct, mostly misunderstood, not obviously definable using seq and yet not adding much to seq.
09:19:59 <quicksilver> I would use seq (or directly use rnf)
09:20:22 <Baughn> Or using, sure
09:20:25 <quicksilver> C.E.evaluate is for "trying to force an asynchronous exception" IMO.
09:20:33 <quicksilver> hence its location in that module
09:20:52 <ddarius> evaluate is for forcing something when the action is executed as opposed to evaluated.
09:23:37 <nicknull> is it possible to create a stateful objectsystem in haskell with monads? or would you then have to break it so much it couldn't be considered haskell anymore?
09:23:37 <nicknull> not i will, just wondering
09:23:57 <nicknull> is it possible to create a stateful objectsystem in haskell with monads? or would you then have to break it so much it couldn't be considered haskell anymore?
09:24:46 <BONUS> uh
09:24:48 <BONUS> the State monad?
09:25:36 <opqdonut> does anyone have a pointer to a haskell implementation of okasaki's real-time queue
09:25:48 <lilac> @faq can haskell do that thing that nicknull asked?
09:25:48 <lambdabot> The answer is: Yes! Haskell can do that.
09:26:09 <quicksilver> nicknull: sure. IORef/STRef give the kind of 'reference' semantics that most people expect of an object system
09:26:12 <opqdonut> i'm having trouble with his use of laziness
09:26:18 <quicksilver> (in the IO and ST monads respectively)
09:26:55 <ddarius> opqdonut: His book should have one.
09:27:04 <opqdonut> okay
09:27:32 <BONUS> yeah i have the book here in front of me :]
09:27:33 <BONUS> it does have
09:27:39 <BONUS> the translation
09:27:50 <opqdonut> kthx, it should be in our library
09:28:11 <opqdonut> just a quick question: does the Queue structure still have three fields in the haskell version?
09:28:25 <opqdonut> i was thinkin the S isn't necessary
09:29:02 <BONUS> hmm
09:29:32 <BONUS> there are several queue data structures defined here
09:30:02 <opqdonut> the "real-time queue" is the one i'm after
09:30:03 <BONUS> banker's queue, hood melville queue, etc
09:30:18 <opqdonut> or at least that's what it's called in the thesis
09:30:30 <opqdonut> the one with worst case O(1) operations
09:30:32 <opqdonut> not amortized
09:30:59 <BONUS> im just flipping through now cause i got the book not long ago
09:30:59 <BONUS> hmm
09:32:47 <BONUS> in the book he mentions queues, batched queues and dequeues
10:10:53 <bschussek> hi all
10:11:16 <bschussek> I'm stuck on a very beginner problem: length[1,2,3] / 2 does not work
10:11:19 <bschussek> why?
10:11:51 <bschussek> the error message is: cannot infer instance, instance: fractional int
10:11:52 <wjt> :t length [1,2,3]
10:11:53 <lambdabot> Int
10:11:56 <wjt> :t (/)
10:11:57 <lambdabot> forall a. (Fractional a) => a -> a -> a
10:12:13 <bschussek> that means? :-\
10:12:38 <daf> the / operator is not defined for Int
10:12:47 <bschussek> but when I do 5/2 it works
10:12:52 <wjt> takes two arguments of the same type, and returns a value of the same type.  that type has to be able to represent fractions, which Int cannot
10:12:55 <wjt> try:
10:12:56 <daf> that's because 5 and 2 are polymorphic
10:13:11 <wjt> > fromIntegral (length [1,2,3]) / 2
10:13:13 <lambdabot>   1.5
10:13:15 <wjt> or:
10:13:21 <daf> when you write 5, it secretly means (fromIntegral 5) or something
10:13:23 <wjt> > length [1,2,3] `div` 2
10:13:24 <lambdabot>   1
10:13:38 <bschussek> wjt: the problem with div is that it's an integer division
10:13:43 <wjt> yes
10:13:52 <bschussek> I want double division though
10:14:10 <wjt> :t fromIntegral (length [1,2,3]) / 2 :: Double
10:14:11 <lambdabot> Double
10:14:24 <wjt> you need to convert the length of the list to a double, which you can do with fromIntegral
10:14:36 <bschussek> ok, that works, thanks a lot!
10:15:51 <hugo_> hmm
10:16:00 <hugo_> how do i set a breakpoint in ghci ?
10:16:19 <daf> hugo_: :break
10:20:51 <geezusfreeek_> hmm, it seems that ghc 6.8.10 refuses to compile stream-fusion
10:20:57 <geezusfreeek_> stack overflows
10:20:59 <hugo_> how do i remove a breakpoint in ghci ?
10:21:27 <geezusfreeek_> :delete
10:21:53 <geezusfreeek_> to see what you can do in ghci, try :?
10:22:08 <hugo_> thanks
10:22:45 <hugo_> is there the possibility of doing a trace after an exception occurs ?
10:23:12 <geezusfreeek_> huh, adding +RTS -K1g makes ghc take around 800 megs and then sit there. taken nearly 6 minutes so far
10:23:45 <geezusfreeek_> hugo_: i am not very intimate with trace
10:24:20 <hugo_> oh, i just wanted to check why this strange exception keeps poping :/
10:24:22 <geezusfreeek_> ^ with 100% cpu at least
10:24:55 <geezusfreeek_> hugo_: is this from an IO action or a partial function?
10:25:01 <hugo_> IO action
10:25:23 <hugo_> is a openFile: does not exist (No such file or directory), but the file exists
10:25:35 <hugo_> if i run it the second time, it goes ok
10:25:52 <geezusfreeek_> if you know where it's happening, just not what parameters are causing it, you could use Debug.Trace to output the parameters when you call the action
10:26:08 <geezusfreeek_> or just putStrLn since it's IO, woops
10:26:19 <geezusfreeek_> s/putStrLn/print/
10:26:27 <hugo_> hmm nice
10:26:52 <geezusfreeek_> oh holy crap ghc just started sucking up memory now
10:28:14 <Deewiant> geezusfreeek_: it's a known regression in 6.10
10:28:27 <geezusfreeek_> mmkay
10:28:29 <Deewiant> might be an infinite loop even
10:28:33 * Deewiant checks
10:28:37 <geezusfreeek_> yuck
10:29:09 <Deewiant> yeah, infinite loop, http://hackage.haskell.org/trac/ghc/ticket/2684
10:29:10 <lambdabot> Title: #2684 (Stack overflow in stream-fusion library with GHC 6.10 RC) - GHC - Trac
10:29:22 <ddarius> geezusfreeek: Moral of the story, switch to a strongly normalizing language.
10:29:22 <Deewiant> so there's no point in trying :-P
10:29:39 <geezusfreeek> ddarius: :)
10:36:34 <hugo_> is there any way to generate a pdf report with the program flow excution from ghci ?
10:36:53 <hugo_> showing which methods were called, with what parameters and stuff ?
10:37:13 <Baughn> hugo_: No, but that's a good idea!
10:37:57 <Baughn> hugo_: Oh, but if you're trying for coverage analysis, there is hpc
10:38:09 <hugo_> kinda of like a colored flowchart :P
10:38:20 <hugo_> or whatever
10:38:21 <hugo_> hmm hpc
10:38:47 <SamB_XP> hugo_: flowchart ????
10:38:50 <Baughn> It has to be doing something a bit like that, come to think of it. You might coerce it into making your pdf.
10:39:07 <SamB_XP> flowcharting Haskell code is probably not a very worthwhile endeavour for anyone or anything
10:39:28 <Baughn> It'd look like an explosion in a spaghetti factory. :P
10:39:35 <hugo_> :)
10:39:47 <ddarius> It would be entertaining.
10:40:07 <hugo_> i just wanted to know was my program execution until a certain exception occured
10:40:25 <Baughn> hugo_: You can get backtraces with -xc, if that's what you want
10:40:42 <Baughn> hugo_: (Requires you to compile with profiling support)
10:40:45 <hugo_> i dont know when the exception occurs :/
10:40:51 <hugo_> that sounds good
10:41:36 <Baughn> When reading such backtraces, you really must remember that ghc does graph reduction. Mostly.
10:41:55 <hugo_> oh
10:41:58 <hugo_> hmm
10:42:12 <hugo_> another noobie question: how do i perform a "head" on an empty list ?
10:42:22 <SamB_XP> hugo_: heh
10:42:24 <Baughn> What do you want to happen if you do?
10:42:26 <sjanssen> > head []
10:42:27 <lambdabot>   * Exception: Prelude.head: empty list
10:42:28 <SamB_XP> uh, you don't
10:42:33 <SamB_XP> at least, you don't WANT to
10:42:42 <Deewiant> > listToMaybe []
10:42:43 <lambdabot>   Nothing
10:42:47 <hugo_> Baughn: i want it to return the empty list :)
10:42:56 <SamB_XP> hugo_: head doesn't return a list
10:42:58 <Deewiant> > take 1 []
10:42:58 <ddarius> take 1
10:42:59 <lambdabot>   []
10:43:02 <SamB_XP> at least, not tyically
10:43:03 <hugo_> oh
10:43:07 <hugo_> yes, i see
10:43:09 <ddarius> > head [[]]
10:43:12 <lambdabot>   []
10:43:25 <Baughn> hugo_: Not particularily possible, no; you'd slam your head into the type system
10:43:32 <hugo_> ahah
10:43:44 <hugo_> i guess my head is aching from too much haskell...
10:43:46 <geezusfreeek> > listToMaybe []
10:43:47 <lambdabot>   Nothing
10:43:54 <Baughn> hugo_: Best you can do is have it return Nothing and handle it specially, but.. normally checking for a non-empty list is a precondition, so there's no point in having safeMaybe around
10:43:54 <geezusfreeek> > listToMaybe [1,2,3]
10:43:56 <lambdabot>   Just 1
10:44:04 <Baughn> Or listToMaybe
10:44:13 <Baughn> I meant safeHead, of course
10:44:23 <SamB_XP> Baughn: there is not no point
10:44:35 <SamB_XP> maybe little point
10:44:38 <vixey> what's safeMaybe
10:44:40 <hugo_> ill use "take" instead
10:44:40 <SamB_XP> @hoogle safeHead
10:44:41 <lambdabot> Data.ByteString.Unsafe unsafeHead :: ByteString -> Word8
10:44:42 <hugo_> :P
10:44:46 <hugo_> take 1 []
10:44:49 <SamB_XP> heh
10:45:00 <hugo_> > take 1 []
10:45:01 <lambdabot>   []
10:45:21 <Baughn> hugo_: "foo [] = []; foo xs = (head xs) + foo (tail xs)"  <-- I'd normally use pattern matching on both clauses, but.. you see my point?
10:45:30 <Baughn> listToaMaybe would just be a waste in most code
10:45:54 <vixey> Baughn: foldr (+) [] ??
10:46:00 <mmorrow> , let split p = fmap (drop 1) . span (not . p) in split (=='.') (show pi)
10:46:01 <lunabot>  ("3","141592653589793")
10:46:02 <hugo_> yes
10:46:04 <Baughn> vixey: *blush*
10:46:16 <Baughn> vixey: Er. Peano naturals?
10:46:32 <hugo_> its just that i have a list of possible values, and any one of them is okay as a result, so i just pick the first
10:46:34 <vixey> I don't think even /that/ will typecheck
10:46:43 <hugo_> problem is, if i use head, it will blow when the list comes empty from the function
10:46:57 <vixey> :k Mu []
10:46:58 <lambdabot> *
10:47:00 <Baughn> > foldl' (+) [] [1..3]
10:47:01 <lambdabot>       No instance for (Num [a])
10:47:01 <lambdabot>        arising from a use of `+' at <interact...
10:47:07 <mmorrow> hugo_: pattern match and cover all cases
10:47:08 <Baughn> vixey: Sure it does. Just need to instance it. ;)
10:47:23 <Baughn> Although, in this case I suppose foldr would be right..
10:47:27 <vixey> oh I was thinking you'd have to use Mu []
10:47:34 <mmorrow> if you don't cover a case and that case happens, the compiler isn't going to help you
10:47:35 <vixey> but I see what you mean just [()] works
10:47:51 <Baughn> hugo_: Right, so you use a guard to test for emptiness *before* heading it
10:48:15 <Baughn> hugo_: "foo [] = 0; foo (x:xs) = ..." is a perfectly normal pattern
10:49:00 <Deewiant> hugo_: or "foo x = if null x then ... else ,,,", but pattern matching is generally preferred
10:49:41 <Baughn> hugo_: Of course you'd typically want a fold or scan with an identity element added externally, so.. well, same thing
10:49:54 <hugo_> oh... that would require lots of change on my code :P
10:50:18 <hugo_> which is VERY ugly heheh
10:50:27 <mmorrow> , let list e _ [] = e ; list e f (x:xs) = f x xs in fmap (list (0::Int) read ) [["42","aswdfg"],[],[],["1","p"]]
10:50:29 <lunabot>  luna: No instance for (GHC.Read.Read
10:50:43 <mmorrow> , let list e _ [] = e ; list e f (x:xs) = f x xs in fmap (list (0::Int) (\x _ -> read x)) [["42","aswdfg"],[],[],["1","p"]]
10:50:45 <lunabot>  [42,0,0,1]
10:53:11 <hugo_> there should be a book like "code complete" but for haskell instead :)
10:53:36 <ddarius> We'll call it "Type Complete"
10:53:50 <hugo_> with a list of "prefered methodologies" and stuff like that...
10:53:54 <Baughn> "Correct by Compilation"
10:59:10 <dblazakis> that would make a good blog -- someone should compile helpful tips from #haskell and the mailing list
10:59:16 <dblazakis> although, dons sort of already does that
11:11:32 <harrison_partch> Setup.lhs: ld is required but it could not be found.
11:11:57 <harrison_partch> Is this "ld" something haskell or something unix?
11:12:07 <Baughn> Something unix.
11:12:29 <Baughn> You need to install some sort of compiler. Well, linker really.
11:12:39 <Baughn> (But some haskell packages do require a C compiler too)
11:15:03 <dons> harrison_partch: that's the linker, that creates executables on most systems
11:15:33 <Baughn> harrison_partch: Typically apt-get install build-essential will fix it
11:15:58 <harrison_partch> i am on nixos now
11:16:08 <harrison_partch> !!
11:16:28 <Baughn> harrison_partch: Try nix-env -i binutils, then
11:17:10 <Baughn> harrison_partch: And nix-env -i gcc, I guess
11:17:37 <harrison_partch> you sir are the mango. i salute you. thx,
11:17:47 <harrison_partch> oh, i have gcc
11:17:53 * Baughn doesn't want to be a delicious and edible fruit, though. ;_;
11:18:08 <Baughn> Right; it was complaining about ld, not gcc. That was just in case.
11:18:13 <harrison_partch> it is derived from "you the man" etc
11:18:38 <harrison_partch> i thought nixos would make a great environment for my haskell dev proect
11:18:42 <Baughn> How do you go from ape-derived environment wreckers to delicious fruit?
11:18:58 <harrison_partch> man go
11:19:13 <Baughn> harrison_partch: Heh. Nixos is interesting, but I can't help but think you'll spend more time fighting it than developing haskell.
11:19:21 * tristes_tigres does not understand, why runSP (Get f) gets to be run in http://hpaste.org/11101
11:19:40 <harrison_partch> perhaps so. i was fighting my sidux system before.
11:19:41 <SamB_XP> what is nixos?
11:19:53 <tristes_tigres> in runSP
11:20:13 <harrison_partch> i couldn't compile cabal because it needed an earlier version of itself before it could compile.
11:20:21 <Baughn> harrison_partch: Why don't you run a /normal/ system, like arch?
11:20:24 <harrison_partch> nixos.org
11:20:34 <SamB_XP> harrison_partch: what about the makefile ???
11:20:47 <harrison_partch> ?? which what ??
11:20:47 <lambdabot>  which what
11:20:54 <dcoutts> harrison_partch: hmm? Cabal bootstraps using itself, not an earlier version of itself.
11:20:58 <Baughn> SamB_XP: A fully-functional package system, theoretically. It's a bit broken at times - very much pre-alpha level.
11:20:58 <SamB_XP> doesn't cabal still have a makefile ?
11:21:24 <harrison_partch> ok i don't even care about a package system or an ide.
11:21:25 <dcoutts> SamB_XP: yes but it's completely unnecessary. Cabal is an ordinary Cabal package and can be built in the standard way.
11:21:34 <SamB_XP> a package system does you no good on it's own, anyway
11:21:39 <Baughn> SamB_XP: You're supposed to say ghc --make Setup, which will compile most of Cabal. And then use Setup to compile it using itself.
11:21:49 <SamB_XP> dcoutts: how do you do that without Cabal installed ?
11:21:55 <SamB_XP> oh.
11:21:57 <SamB_XP> coincidence ?
11:22:08 <dcoutts> SamB_XP: runghc Setup works because all the code is there locally
11:22:14 <SamB_XP> sick
11:22:18 <dcoutts> cunning
11:22:31 <dcoutts> SamB_XP: incidentally this also makes franchise work
11:22:34 <tristes_tigres> Stream processor arrow fibs in http://hpaste.org/11101 never calls Put constructor
11:23:01 <harrison_partch> sad tiger. levi-strauss ref. like it.
11:23:06 <tristes_tigres> how come runSP consumes any input then ?
11:23:15 <SamB_XP> argh
11:24:07 <SamB_XP> why does adam cadre insist on stringing his panels together horizontally ?
11:26:05 <ivan> does he have anything good besides photopia?
11:26:29 <SamB_XP> he has some comics too
11:28:01 <harrison_partch> all right, I can't mix cabal and nixos, i get that now.
11:28:34 <harrison_partch> Baughn: you still around?
11:28:47 <Baughn> harrison_partch: (aroundp) => T
11:28:59 <dcoutts> harrison_partch: oh, why not? I know some people have been doing cabal packages for nixos
11:29:31 <harrison_partch> As you guessed, i am wasting time with difficulties.
11:29:53 <harrison_partch> May I describe what I am trying to do and what my devel system has to have?
11:30:14 <Baughn> Sure
11:30:48 <tristes_tigres> fibs = Put 0 fibs'; fibs' = Put 1 ( (fibs &&& fibs') >>> arr (uncurry (+)))
11:30:58 <tristes_tigres> no Get constructor
11:32:19 <hackage> Uploaded to hackage: franchise 0.0.3
11:33:00 <harrison_partch> I want to code a new hybrid renderer. I have already written a realtime raytracer, but while processors get faster and more cored (once there are enough cores, raytracing is categorically a better way to do realtime 3d)
11:33:12 * SamB_XP is relieved that that was apparantly a fairly unusual comic page
11:33:28 <Baughn> harrison_partch: In haskell? I hope you're not hoping to beat any speed records.
11:33:51 <harrison_partch> i thought of a hybrid approach using raytracing for visibility determination only and
11:33:59 <harrison_partch> --hear me out --
11:34:06 <Baughn> Right..
11:34:12 <hugo__> i think i found the source of the error ive been trying to debug: haskell just continues evaluating expressions, without the previous one has been totally evaluated first
11:34:15 <hugo__> is this possible to occur ?!
11:34:24 <vixey> haha
11:34:25 <harrison_partch> opengl polys on the gpu
11:34:28 <SamB_XP> hugo__: it's totally normal
11:34:29 <Baughn> hugo__: Um, yeah. Laziness.
11:34:35 <hugo__> oh.. damn
11:34:36 <hugo__> :/
11:34:41 <hugo__> how do i prevent it ? :P
11:34:45 <vixey> hugo__: What's previous?
11:34:55 <hugo__> i want it to continue, only if a certain expression is totally evaluated
11:34:58 <hugo__> even inside a do ?
11:35:03 <harrison_partch> i would never write a pure tracer in a functional language, i don't think
11:35:36 <harrison_partch> anyway, i need: an editor, a commandline, and an opengl context window.
11:35:36 <vixey> hugo__: Why must you care what order things evaluated in?
11:35:47 <vixey> hugo__: This is a very low level consideration we try to avoid
11:35:51 <SamB_XP> harrison_partch: raytracing for visibility determination ???
11:35:57 <hugo__> vixey, because i have this function that creates a file, and another one that reads this file that was previously created
11:36:05 <Baughn> harrison_partch: The GPU already does visibility determination very well, though. The bits that are hard to do with scanline rendering, as opposed to raytracing, are what comes after - shadows, caustics, reflection, etc. etc. etc.
11:36:22 <hugo__> the problem is that the function that creates the file is VERY slow
11:36:26 <harrison_partch> yes. here, watch this and then i will explain:
11:36:28 <Baughn> harrison_partch: Hmm. Though you might join of the guys trying to do raytracing on CUDA
11:36:29 <vixey> hugo__: That's sequencing actions, completely differernt to evaluation order (unlike most languages would try to make you think)
11:36:43 <hugo__> so, the other ones just dumps "no such file.."
11:36:50 <hugo__> hmm
11:36:55 <hugo__> im sequencing them, inside a do
11:37:00 <vixey> hugo__: (>>) is what sequience actions
11:37:04 <harrison_partch> no, the algorithms that i like can't work on SIMD streams. Inherently MIMD
11:37:09 <hugo__> ah
11:37:11 <hugo__> allright
11:37:12 <vixey> maybe it's the wrong things you have sequienced
11:37:20 <vixey> by the way do x; y; z = x >> y >> z
11:37:31 <hugo__> well, if i put a break, then wait, then continue, it works fine
11:37:35 <hugo__> oh
11:37:44 <hugo__> so i just need to put a ';' ?
11:37:46 <harrison_partch> http://www.youtube.com/watch?v=MKMsbU1ovv8
11:37:47 <lambdabot> Title: YouTube - abraxas
11:38:09 <vixey> hugo__: No idea what "break wait continue" is
11:38:47 <hugo__> vixey, in ghci :break linenum then i just wait a bit, and do a :continue :P
11:38:58 <Baughn> harrison_partch: Interesting
11:39:00 <harrison_partch> The "visibility determination" a GPU does is "draw it all and let the zbuffer sort it out". Pretty fast for a polygon soup, too,
11:39:12 <Saizan> hugo__: how do you write to the file?
11:39:20 <harrison_partch> but if you have an objectoriented renderer
11:39:21 <hugo__> sorry, the ';' doesn't work either
11:39:37 <vixey> hugo__: oh right not programming
11:39:53 <harrison_partch> where objects draw themselves and maybe do other things like animate themselves
11:40:25 <hugo__> yes
11:40:26 <harrison_partch> you have to figure out what is visible first.
11:40:55 <harrison_partch> i did a cute little renderer in python and opengl close to a decade ago
11:41:25 <Baughn> harrison_partch: Well, yes, you could do that
11:42:07 <hugo__> hmmf :(
11:42:34 <hugo__> is there any way for me to "force" haskell to just perform an expression after the previous one was fully done ?
11:42:41 <harrison_partch> check it out: a tree is a tube + 3 occurences of [a scale, translation and rotation + the tree itself]
11:42:46 <lilac> harrison_partch: translucent objects (and more generally anything using a shader which reads the image behind the fragment) generally need to be z-sorted
11:42:53 <vixey> hugo__: Why must you work at such a low level
11:42:58 <harrison_partch> it even worked in python with softwre mesa
11:43:04 <vixey> hugo__: maybe something else is the real problems
11:43:24 <harrison_partch> course objects only draw themselves if they think they are large enough in the camera view
11:43:33 <Saizan> hugo__: it might be OS-level buffering
11:43:45 <harrison_partch> level of detail. there you go.
11:43:46 <Saizan> hugo__: do you flush or close the handle after you've written to it?
11:43:52 <hugo__> vixey: im using curlGet to create a cookie file, curl is VERY slow, so when i go to parse this cookie file, it still doesn't exist yet... (Because curl hasn't finished its task)
11:44:28 <hugo__> Saizan: how do i do that ? :P
11:45:12 <harrison_partch> lilac: that's all done in hardware is it not?
11:45:22 <hugo__> i can put my code in hpaste, but its very ugly :P
11:45:53 <Saizan> hugo__: yeah, show us the code :P
11:45:57 <vixey> hugo__: Doesn't curlGet have a way to signal the operation is complete - or give you a stream from it
11:46:11 <hugo__> vixey: i dont know :P heheh
11:46:23 <vixey> hugo__: what documentation is there?
11:46:31 <harrison_partch> lilac: tell me how a gpu would do this: http://video.google.com/videoplay?docid=-5480113446349788923&q=source:003508124996130740199&hl=en
11:46:32 <lambdabot> Title: SEVEN, http://tinyurl.com/3qf3f7
11:46:58 <Saizan> http://hackage.haskell.org/packages/archive/curl/1.3.2.1/doc/html/Network-Curl.html#v%3AcurlGet
11:47:01 <lambdabot> Title: Network.Curl, http://tinyurl.com/5l3jv7
11:47:04 <harrison_partch> so Baughn, do you think I can get HOGL working on Nixos then?
11:47:20 <Saizan> curlGet is not asynchronous or anything, afaiu
11:47:38 <Saizan> i really think this is just a matter of I/O buffering
11:47:42 <Baughn> harrison_partch: Umh. I don't see why not, but..
11:48:04 <Baughn> harrison_partch: It'd be far easier on any other OS. I can't help but think you should stop picking fights with multiple development projects at once.
11:48:33 <Deewiant> "any other"? I'd say there are more OSes on which it'll be harder :-P
11:48:35 <harrison_partch> right, that's why i was asking you. you mentioned arch. is that what you recommend?
11:48:58 <Baughn> If you just want to use haskell, and not bother having to recompile stuff yourself? Yes
11:49:09 <lilac> harrison_partch: your question implies that video could not be produced using mainstream techniques. i fail to see why.
11:49:21 <Baughn> It's probably got the best collection of up-to-date haskell packages
11:49:40 <harrison_partch> lilac: Yes. You do.
11:49:56 <harrison_partch> Baughn, I will take your advice.
11:50:05 <Baughn> harrison_partch: Personally, I use gentoo and install everything myself, manually or with cabal. But I like jumping off cliffs ahead of the other lemmings, so I'm also running 6.10.20081012.
11:51:02 <harrison_partch> No wait. Maybe I will do that. Because I had a hellish time last week after leasing a VPS and eventually switched it to Gentoo from Debian.
11:51:16 <lilac> harrison_partch: well, would you care to elaborate?
11:51:34 <harrison_partch> There's a bug in the recent Xen kernels which kills Mono on x64..
11:52:16 <hugo__> http://hpaste.org/11117  error occurs on parseCookieFile (readFile reads when curlGet hasn't finished yet), when called from the getCookieFromSite function ...
11:52:37 <harrison_partch> life is short lilac, and i am not a regular here.. perhaps i have outstayed my welcome...
11:52:52 <hugo__> any comments are very much appreciated
11:53:02 <hugo__> i feel that i really need to improve my haskell code
11:53:08 <harrison_partch> baughn: gentoo bleeding edge it'll be.
11:53:46 <Baughn> harrison_partch: The gentoo bleeding edge is really /bleeding/. Just stick with the defaults, non-~arch, and install ghc yourself..
11:54:13 <Deewiant> gentoo's bleeding edge is still 6.6, no?
11:54:27 <Baughn> Details. :P
11:54:32 <harrison_partch> well, emerge worked easily on that vps last week...
11:54:42 <ziman> Latest version installed: 6.8.3
11:54:55 <ziman> thats ~x86
11:55:03 <Deewiant> yes, ~
11:55:16 <Baughn> ziman: Eh? dev-lang/ghc doesn't even have anything newer than .8.2...
11:55:41 <lilac> harrison_partch: i'm only asking out of academic interest. your video appears to show a scene with (possibly) infinite detail, which appears to be constructed by computing the visible objects based on location. it also looks like it might be using a non-euclidean geometry, but i can't be sure. all interesting to be sure, but not enough to make me think "GPUs can't do that"
11:55:42 <Deewiant> must be the overlay
11:55:50 <Deewiant> Baughn: there's a haskell-related overlay somewhere
11:56:04 <ziman> hm, might be, i've installed the haskell overlay recently
11:56:10 <Deewiant> but everything in it is ~x86
11:56:22 <Baughn> Yes, why is that?
11:56:23 <SamB_XP> Deewiant: ???
11:56:33 <Deewiant> SamB_XP: ??
11:56:52 <SamB_XP> puzzled as to why
11:56:53 <harrison_partch> lilac: you are very clever to have noticed all that.
11:57:04 <Deewiant> yeah, beats me
11:57:59 <harrison_partch> here's what a gpu cannot do: it cannot trace pointer-linked structures through main memory and execute arbitrary code on the nodes. Because if it could do that it would be a CPU.
11:58:26 <Deewiant> harrison_partch: it can do that with video memory, though, no?
11:58:42 <SamB_XP> harrison_partch: your argument is flawed
11:58:56 <Deewiant> I'm sure all this shader programming stuff and whatnot is turing-complete
11:58:57 <SamB_XP> you are assuming that the GPU can't be a kind of CPU
11:59:03 <Saizan> hugo__: have you tried wrapping curlGetString in withCurlDo ?
11:59:15 <vixey> @w80 hypothesis
11:59:16 <lambdabot> *** "hypothesis" wn "WordNet (r) 2.0"
11:59:17 <lambdabot> hypothesis
11:59:17 <lambdabot>      n 1: a proposal intended to explain certain facts or observations
11:59:17 <lambdabot>      2: a tentative theory about the natural world; a concept that
11:59:17 <lambdabot>         is not yet verified but that if true would explain certain
11:59:17 <lilac> Deewiant: current technology doesn't really give you pointers AFAIR, but you do get arbitrary indexing into user-provided buffers
11:59:18 <lambdabot> [8 @more lines]
11:59:19 <SamB_XP> now, it's true that it's not practical for it to do all that with main memory ...
11:59:25 <hugo__> Saizan: i will try it now
11:59:27 <vixey> what's the plural of hypothesis
11:59:31 <vixey> hypothesEs?
11:59:35 <Deewiant> lilac: well, it just depends on your definition of "pointer" then ;-)
11:59:40 <SamB_XP> vixey: isn't it?
11:59:50 <Deewiant> it is
11:59:51 <vixey> hey don't do that, I'm the one asking questions!
11:59:52 <SamB_XP> @all-dict hypotheses
11:59:53 <lambdabot> *** "Hypotheses" gcide "The Collaborative International Dictionary of English v.0.48"
11:59:53 <lambdabot> Hypothesis \Hy*poth"e*sis\, n.; pl. {Hypotheses}. [NL., fr. Gr.
11:59:53 <lambdabot>    ? foundation, supposition, fr. ? to place under, ? under + ?
11:59:53 <lambdabot>    to put. See {Hypo-}, {Thesis}.]
11:59:53 <lambdabot>    1. A supposition; a proposition or principle which is
11:59:55 <lambdabot> [40 @more lines]
11:59:56 <harrison_partch> yes, i know, hide triangles in a pixel buffer, etc.
12:00:00 <harrison_partch> great.
12:00:09 <harrison_partch> not my kind of tracing
12:00:19 <hugo__> Saizan: any idea how ?
12:01:12 <newsham> sequence.complete.org is broken?
12:01:56 <tristes_tigres> haskell cuda bindings ?
12:02:09 <Saizan> hugo__: simply withCurlDo (curlGetString site [cookie, ua]
12:02:12 <Saizan> )
12:03:59 <vixey> I'm confused :[
12:04:09 <vixey> anyone want to help me figure this out
12:04:21 <harrison_partch> lilac: http://www.bluebottle.ethz.ch/download.html
12:04:24 <Tobsan> go ahead vixey
12:04:26 <byorgey> vixey: figure what out?
12:04:44 <harrison_partch> there's an iso there that you can boot. my tracer is part of it.
12:05:12 <vixey> I've got a function say,  check :: x -> Maybe o
12:05:25 <vixey> so it might return Nothing or it might give Just something..
12:05:27 <hugo__> oh nice
12:06:08 <hugo__> Saizan: btw, what do you think about my great haskell coding skillz ?
12:06:12 <vixey> now I want to something goes:  let fuu = \x -> check x
12:06:35 <hugo__> doesnt work either :(
12:06:43 <vixey> now if fuu is \x -> Nothing, I want to return Nothing, but if it's \x -> Just (check x), I should return Just (\x -> check x)
12:07:07 <vixey> How do you do this?
12:07:28 <Tobsan> vixey: that would mean that you return Just Just x
12:07:32 <vixey> or is there some sort of turing-everything-inside-out I could to do make the problem easier
12:07:34 <Tobsan> as check returns a Maybe
12:07:37 <Baughn> vixey: Um. Clarifying: Is fuu a parameter, or a function name?
12:07:49 <geezusfreeek> :t \x -> check x
12:07:50 <lambdabot> Not in scope: `check'
12:07:55 <geezusfreeek> duh :P
12:07:55 <vixey> oh Tobsan, a slight mistake:
12:07:57 <Baughn> vixey: You've already said "fuu = \x -> check x", which can be reduced to "fuu = check"
12:07:59 <vixey> \x -> Just (check x), I should return Just (\x -> check x) -- should be changed into:
12:08:05 <vixey> \x -> Just (muu x), I should return Just (\x -> muu x)
12:08:10 <Baughn> vixey: join
12:08:16 <Baughn> > join (Just (Just 2))
12:08:16 <vixey> :t join
12:08:18 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:08:18 <lambdabot>   Just 2
12:08:36 <vixey> no I definitely can't do this with join
12:08:46 <geezusfreeek> :t \x -> (undefined :: a -> Maybe b) x
12:08:47 <lambdabot> forall a b. a -> Maybe b
12:08:57 <Baughn> vixey: Yes, that function was a bit confusing. Let me try this agin:
12:08:57 <geezusfreeek> :t Just $ \x -> (undefined :: a -> Maybe b) x
12:08:58 <lambdabot> forall a b. Maybe (a -> Maybe b)
12:09:02 <BMeph> vixey: Do you mean an fmap on the result? :)
12:09:09 <vixey> I don't know BMeph
12:09:15 <vixey> I don't know if fmap can do it
12:09:17 <ddarius> vixey: What type do you want fuu to have?
12:09:19 <Baughn> vixey: You've got fuu x = case muu x of Nothing -> Nothing; Just a -> check a?
12:09:22 <geezusfreeek> :t (Just . \x -> (undefined :: a -> Maybe b)) x
12:09:24 <lambdabot> forall a b. Maybe (a -> Maybe b)
12:09:27 <BMeph> vixey: Try! :)
12:09:35 <lilac> vixey: your question doesn't seem to make much sense. do you want to statically determine whether check returns Just or Nothing?
12:09:44 <vixey> fuu :: x -> Maybe o
12:09:48 <geezusfreeek> okay i'll play in ghci
12:09:57 <Baughn> vixey: That could be written as "let fuu x = check <$> muu x"
12:09:58 <vixey> geezusfreeek: no do it here
12:10:07 <vixey> geezusfreeek: I can follow your train of thought better :))
12:10:17 <vixey> :t (<$>)
12:10:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:10:23 <Baughn> <$> = fmap
12:10:25 <geezusfreeek> i have trouble communicating with lambdabot with everybody talking anyway ;)
12:11:05 <Baughn> vixey: Or, compressing further, fuu = check <$> muu
12:11:19 <lilac> "<$>: it's not just for applicative functors"
12:11:20 <Baughn> vixey: If I got that first case expression right
12:11:24 <vixey> I don't really understand that Baughn
12:11:42 <Baughn> > (+1) <$> Nothing
12:11:43 <lambdabot>   Nothing
12:11:47 <Baughn> > (+1) <$> Just 3
12:11:49 <lambdabot>   Just 4
12:12:13 <lilac> > (+) <$> [1,2,3] <*> [4,5]
12:12:14 <Baughn> Although, that's not quite right either..
12:12:15 <lambdabot>   [5,6,6,7,7,8]
12:12:38 <vixey> I wonder if I could form my question better
12:12:52 <Baughn> vixey: Actually, I think you'd want fuu = check =<< muu
12:12:54 <ddarius> vixey: I'm sure you could as currently it makes no sense.
12:13:16 <Baughn> vixey: Er. Can you just look at the case expression I gave you earlier? I think I'm overthinking this. ;)
12:13:28 <Saizan> hugo__: btw, can't you use curlResponse and get the coockies from respHeaders ?
12:14:50 <geezusfreeek> vixey: yeah i am ever so slightly confused by the question. i _think_ i get it
12:14:51 <int-e> vixey: what would your function return for  (\x -> if odd x then Nothing else Just x) ?
12:15:29 <hugo__> Saizan: yes, i can, but it will envolve more parsing
12:16:06 <hugo__> oh
12:16:20 <hugo__> they wrap the headers in a (String, String) list
12:17:09 <lilac> vixey: fuu :: x -> Maybe (x -> Maybe o) ?
12:17:09 <vixey> int-e: very good example yes
12:17:23 <vixey> int-e: There's no way it can do some case analysis on 'x'
12:17:26 <int-e> vixey: of course if the function has the form you gave then you can use  case fuu undefined of Just _ -> Just (fuu . fromJust); Nothing -> Nothing
12:17:38 <geezusfreeek> @djinn x -> Maybe (x -> Maybe o)
12:17:39 <lambdabot> f _ = Nothing
12:17:44 <int-e> vixey: but it's clearly not a total function
12:18:11 <int-e> vixey: err. fromJust . fuu, of course.
12:18:27 <lilac> int-e: equivalently, fuu
12:18:38 <int-e> lilac: no
12:18:39 <Baughn> See, that's what =<< is for
12:19:51 <geezusfreeek> okay yeah i don't get the question
12:20:03 <hugo__> is there any way to do a sleep in haskell, in order to sync IO ? :P
12:20:16 <Baughn> hugo__: That's not how you sync IO
12:20:19 <lilac> int-e: ah right, it's Just (fromJust . fuu) not Just . fromJust . fuu. i'm still not sure that i understand what vixey wants here :-/
12:20:31 <Baughn> hugo__: ..what does "sync IO" mean in this context, anyway?
12:21:04 <hugo__> wait for curlGet to finish completely before doing a readFile for the cookieFile it should output :P
12:21:06 <Baughn> lilac: Well, wouldn't you want the whole thing to return Nothing if fuu does, not throw an exception outright?
12:21:31 <lilac> Baughn: if "fuu undefined" is "Just _", then fuu *cannot* return Nothing
12:21:47 <lilac> (unsafePerformIO notwithstanding)
12:21:47 <Baughn> True. Is it?
12:22:33 <harrison_partch> lilac: there is a sense in which your argument is correct. A GPU could render a flythough of an object like a Sierpinski cube, because the fractal object has a tiny description. In fact the geometry can easily be determined per ray. But for complicated heterogenous scenes, I think I am correct.
12:22:40 <Baughn> hugo__: Isn't curlGet already strict?
12:23:06 <int-e> geezusfreeek: as I understand it, the question is "It's easy to turn Maybe (a -> b) into a -> Maybe b). Can we go in the other direction?"
12:23:38 <lilac> harrison_partch: sure. of course, you wouldn't want to do that entirely on the GPU :) figuring out which fragments to render is much better suited to the CPU
12:24:32 <lilac> vixey: what should happen if the Nothing-ness of 'check' depends on the argument?
12:24:41 <vixey> it doesn't
12:24:52 <vixey> I do not know how to express that in the type system
12:25:03 <Baughn> vixey: To be honest, I'm still not sure what you're trying to do
12:25:17 <int-e> vixey: Maybe (a -> b)  is really what you should use for check in the first place
12:25:17 <hugo__> Baughn: i guess not :(
12:25:20 <Baughn> Or why
12:25:33 <Baughn> hugo__: What makes you think that?
12:26:03 <lilac> vixey: various options spring to mind. one is phantom types: data Maybe' a b = Nothing' | Just b; check :: Maybe' a b
12:26:06 <ddarius> @free f :: a -> Maybe a
12:26:07 <lambdabot> $map_Maybe g . f = f . g
12:26:15 <Baughn> hugo__: ..oh, it's async
12:26:22 <Baughn> hugo__: Well, you could always use curlGetString
12:26:46 <hugo__> Baughn: im using curlGetString ... same thing...
12:26:55 <Baughn> hugo__: Throw away the result string (unless you really want it), but force its length - once that length is known, the download must be complete
12:26:58 <lilac> vixey: another would be the calling code writing 'check undefined'
12:27:04 <hugo__> ah
12:27:07 <hugo__> nice hack :)
12:27:15 <hugo__> i didn't thought of that... heheh
12:27:19 <lilac> vixey: I'm assuming that the type 'x' varies, and the result of fuu depends on that type?
12:27:23 <Baughn> The curl documentation is entirely too sparse, I think
12:27:37 <Baughn> It doesn't mention laziness, which is rather important where IO is involved..
12:27:39 <b_jonas> Baughn: read the docs of the c api
12:27:48 <b_jonas> Baughn: oh, lazyness?
12:27:50 <b_jonas> dunno then
12:27:53 <ddarius> :t let fuu = case check undefined of Nothing -> const Nothing; Just _ -> const (Just id) in fuu
12:27:55 <lambdabot> Not in scope: `check'
12:27:55 <hugo__> hmm well i managed preaty well, but now i spent my afternoon trying to catch this bug :/
12:28:03 <ddarius> :t let fuu = case ?check undefined of Nothing -> const Nothing; Just _ -> const (Just id) in fuu
12:28:04 <lambdabot> forall a t b a1. (?check::a -> Maybe t) => b -> Maybe (a1 -> a1)
12:28:20 <Baughn> b_jonas: I don't see why the haskell API should be such a simple clone of the C API
12:28:23 <Baughn> We can do better
12:28:38 <ddarius> :t let fuu = case ?check undefined of Nothing -> Nothing; Just _ -> Just id in fuu
12:28:39 <lambdabot> forall a t a1. (?check::a -> Maybe t) => Maybe (a1 -> a1)
12:28:49 <b_jonas> Baughn: you could, yes, one that calls the event loop from the haskell threads
12:29:23 <b_jonas> Baughn: not much better though, the C api is well designed
12:29:47 <b_jonas> Baughn: you could still write a higher-level haskell module using the low-level one, with the low-level one still available
12:32:32 <hugo__> Baughn: how do i force the length of a string ? :P
12:32:38 <lilac> vixey: another option would be to rewrite check :: Maybe (x -> o); prove to the type system that x is not used when determining Just-ness
12:32:55 <Baughn> hugo__: I've been asked not to tell you to say "evaluate (length string)", but that works
12:33:14 <hugo__> ahah
12:33:14 <Deewiant> length string `seq` ()
12:33:29 <Baughn> ..that, meanwhile, does absolutely nothing
12:33:43 <hugo__> the secret is in the "evaluate" i see
12:33:47 <Deewiant> well, just use the value somewhere
12:33:50 <hugo__> its like the "goto" in C :P
12:33:57 <Baughn> The secret is in using the value somewhere
12:33:58 <SamB_XP> ???
12:34:05 <lilac> Baughn: doesn't it not terminate if the string is infinite? :D
12:34:08 <Baughn> evaluate is nice if you don't have anything /real/ to use it for
12:34:13 <tristes_tigres> has anyone worked through the stream processor example in citeseer.ist.psu.edu/hughes98generalising.html  ?
12:34:13 <Baughn> lilac: Well, true. :P
12:34:18 <hugo__> i dont want to print it... i guess i could store it in a temporary file :P
12:34:19 <Baughn> That's what System.Timeout is for. ;)
12:34:28 <SamB_XP> lilac: well, then you obviously don't want to force the whole thing ...
12:34:42 <hugo__> ok, thanks, im off to do something else now
12:34:49 <hugo__> great support, thanks for everything ppl ;)
12:34:53 <hugo__> haskell ftw!
12:34:57 <tristes_tigres> http://citeseer.ist.psu.edu/hughes98generalising.html
12:36:35 <lilac> length_until_you_get_bored :: Num n => n -> [a] -> (n, [a])
12:37:30 <dons> ?users
12:37:31 <lambdabot> Maximum users seen in #haskell: 518, currently: 506 (97.7%), active: 21 (4.2%)
12:37:43 <Deewiant> waa, why do I get tonnes of __stginit link errors
12:38:19 <chrisdone> I had a go at making a kind of screencast of me using Kibro. does anyone find this cool or is it actually boring? http://chrisdone.com/blog/db/static/lojbanweb.html (needs Flash)
12:42:17 <tristes_tigres> hello ? anyone out there ?
12:42:26 <chrisdone> hi tigres
12:51:32 <chrisdone> page should be accessible here iirc: http://chrisdone.com:3000/?q=dance
12:51:55 <chrisdone> I guess I need to get a microphone and actually talk
12:54:24 <chrisdone> can anyone tell me if it streams or does it try to download the whole 30MB file at once?
12:58:45 <aprocter> chrisdone: it streams for me
12:59:14 <chrisdone> aprocter: ace, thanks
13:00:34 <nomeata> „In earlier versions of GHC, the recompilation checker didn't notice changes in other packages meant that recompilation is needed. This is now handled properly, using MD5 checksums of the interface ABIs.“ Will it be possible to read this MD5 sum? It would be perfect to make Debian’s haskell packages better by depending on this checksum instead of the version of libraries.
13:01:34 <vixey> Have you seen LCF
13:01:54 <vixey> I just found out about it yesterday
13:02:15 <kaol> nomeata: ghc -show-iface
13:02:46 <nomeata> kaol: doesn’t that work on the module level?
13:03:06 <thoughtpolice> you mean like a programmatic way to get it?
13:03:34 <thoughtpolice> i mean, .hi files change a lot, even inbetween bugfix releases. not sure how easy it would be
13:03:58 <thoughtpolice> (hell they can change several times *in the middle* of a bugfix release being made)
13:04:16 <sjanssen> nomeata: there probably aren't a whole lot of times where this would actually be useful
13:04:37 <nomeata> sjanssen: what about changes to the Debian packaging only that don’t affect the ABI?
13:04:45 <sjanssen> with any optimization turned on, ABI seems very volatile in my experience with xmonad and -contrib
13:05:31 <sjanssen> nomeata: I suppose if that happens frequently it'd be useful
13:06:52 <nomeata> sjanssen: is it really that unlikely that a bugfix leaves the ABI intact?
13:07:25 <nomeata> (the point is that it would reduce the burdon on the Debian build daemons...)
13:10:36 <SamB_XP> nomeata: it probably won't be wise until we can automatically check whether the ABI has changed ...
13:11:19 <nomeata> SamB_XP: Exactly, that’s what I’m asking. The quote above is from the ghc 6.10 release notes, so it seems the code is already there.
13:12:10 <SamB_XP> oh, I see
13:12:12 <SamB_XP> cool
13:12:35 <SamB_XP> I expect that those checksums wouldn't be too hard to obtain
13:14:09 * nomeata looks forward to that.
13:19:14 <Deewiant> yaaaay
13:19:28 * Deewiant got gtk2hs to work with 6.10 on windows
13:19:38 <dcoutts> Deewiant: yay
13:19:45 <dcoutts> Deewiant: current darcs version of gtk2hs ?
13:19:58 <Deewiant> nah, 0.9.13 with a few patches
13:20:02 <dcoutts> oh
13:20:10 <Deewiant> dcoutts: because getting autoconf to work on windows is a few orders of magnitude more difficult.
13:20:19 <dcoutts> indeed
13:20:28 <dcoutts> I've never managed it
13:20:40 <Deewiant> I did try the darcs version, but I just couldn't get autoconf to behave smartly
13:20:57 <Deewiant> so I went to 0.9.13 and looked at the sourceforge forums for a notorious Binary instance
13:20:59 <dcoutts> aye, I always generate a tarball on linux and build it on win32
13:21:32 <Deewiant> are you a dev by any chance?
13:21:50 <b_jonas> hello
13:21:59 <Deewiant> dcoutts: if you are I could complain about a few things ;-)
13:22:13 <b_jonas> can you help me with how the Read mechanism works?
13:22:24 <vixey> :t read
13:22:25 <lambdabot> forall a. (Read a) => String -> a
13:22:34 <b_jonas> currently I'd like to read a list of whitespace-separated integers from a string
13:22:48 <dcoutts> Deewiant: I am, but not a very active one. Best to report things to gtk2hs-devel or direct in the bug tracker.
13:22:50 <vixey> b_jonas: that sounds like parsing not Read
13:22:50 <b_jonas> > reads "1 "
13:22:51 <lambdabot>   []
13:22:59 <b_jonas> > reads "1 " :: [(Int, String)]
13:23:00 <lambdabot>   [(1," ")]
13:23:06 <tristes_tigres> b_jonas: > reads "1" :: Int
13:23:09 <vixey> > unwords "1 6 8 4 6 5 2 1"
13:23:10 <lambdabot>   Couldn't match expected type `String' against inferred type `Char'
13:23:19 <vixey> > words "1 6 8 4 6 5 2 1"
13:23:20 <lambdabot>   ["1","6","8","4","6","5","2","1"]
13:23:30 <Deewiant> dcoutts: the sourceforge bug tracker?
13:23:37 <vixey> > map (read :: String -> Integer) . words $ "1 6 8 4 6 5 2 1"
13:23:38 <lambdabot>   [1,6,8,4,6,5,2,1]
13:23:47 <b_jonas> so I should not use read for thise but parse it in some other way, and use reads only to read the separated integers?
13:23:51 <dcoutts> Deewiant: no, the trac
13:23:57 <vixey> b_jonas: exactly yes
13:24:00 <b_jonas> I thought you could use Read directly in some way
13:24:06 <b_jonas> like
13:24:09 <vixey> no Read is not for that
13:24:11 <b_jonas> dunno
13:24:12 <b_jonas> ok
13:24:15 <vixey> you could do that but it is a terrible idea
13:24:15 <Deewiant> dcoutts: I see no link at http://www.haskell.org/gtk2hs/
13:24:27 <lambdabot> Title: Gtk2Hs
13:24:53 <dcoutts> Deewiant: see the development page, it has the link to the bug tracker
13:25:09 <Deewiant> dcoutts: ah, cheers
13:26:29 <b_jonas> what if you have bytestrings? do you have to convert them to String if you want to read an integer or float, or are there functions directly reading a single number from a BS?
13:26:46 <vixey> b_jonas: Your parser doesn't work on bytestrings as well as strings?
13:26:54 <vixey> b_jonas: What about Parsec?
13:27:02 <vixey> I think it does that..
13:27:14 <b_jonas> vixey: I don't know, I'm not familiar with Parsec
13:28:20 <b_jonas> but if I build a parser by hand or from regexen, I still need a library to read the primitive numbers
13:28:34 <b_jonas> at least that's how I expect it's supposed to work
13:28:47 <vixey> that doesn't make sense
13:28:56 <vixey> reading numbers is really easy
13:29:04 <b_jonas> integers yes, if you don't want it fast
13:29:08 <vixey> you can definitely implement that in parsec, infact it's already been done
13:29:20 <vixey> no it's not going to be fast because you didn't write it
13:29:32 <rwbarton> b_jonas: The ByteString library has readInt and readInteger, which are very fast
13:29:32 <lambdabot> rwbarton: You have 1 new message. '/msg lambdabot @messages' to read it.
13:29:40 <b_jonas> rwbarton: ah, thanks
13:29:47 <rwbarton> b_jonas: there's a readDouble in some other package, bytestring-lexer or something.
13:30:18 <tristes_tigres> rwbarton: hi, I have a followup question to yesterday's http://hpaste.org/11101
13:30:19 <vixey> b_jonas: there are functions for reading numbres in parsec
13:30:23 <b_jonas> should I look at parsec if I don't want to parse complicated things just really simple ones like this whitespace-separated integers?
13:31:02 <ziman> > map read . words $ "123 456 789"
13:31:04 <lambdabot>   [* Exception: Prelude.read: no parse
13:31:13 <ziman> :\
13:31:17 <vixey> > map read . words $ "() () ()"
13:31:19 <lambdabot>   [(),(),()]
13:31:25 <ziman> oh, mr
13:32:00 <SamB_XP> what the HECK?
13:32:11 <ziman> mm, no, defaulting.
13:32:18 <tristes_tigres> rwbarton: I don't understand why runSP (Get f) gets to be called, - fibs arrow does not have any Get constructors, so where does this get come from ?
13:32:20 <hackage> Uploaded to hackage: kibro 0.3
13:32:20 <ziman> > map read . words $ "123 456 789" :: [Integer]
13:32:21 <lambdabot>   [123,456,789]
13:32:40 <Deewiant> dcoutts: meh, one can't register into the gtk2hs trac
13:33:26 <dcoutts> Deewiant: no, just the guest account
13:33:33 <Deewiant> dcoutts: guest/guest is fine but email notification without exposing my address would be nice
13:33:53 <dcoutts> Deewiant: sorry, we got too much spam when we allowed unrestricted registration
13:34:14 <Deewiant> :-/
13:35:11 <SamB_XP> dcoutts: couldn't you just have added an "evaluate this expression" captchca ?
13:35:27 <dcoutts> SamB_XP: in principle yes
13:35:58 <dcoutts> SamB_XP: in practice my python hacking skills are not up to modifying trac
13:42:38 <Deewiant> dcoutts: okay, looks like I can file at least 3 tickets but it'll wait until tomorrow; I'll go through the build process again and actually catalogue what comes up :-)
13:44:47 <trin_cz> hi everyone, solving problem ...
13:44:59 <trin_cz> accessing global configuration in gtk handlers
13:45:04 <rwbarton> tristes_tigres: I think it comes from arr and >>>
13:45:57 <trin_cz> which way to go? readerT is nonsence (in this case) imho. What about STM?
13:46:17 <Zao> Curry along an ioref?
13:47:04 <tristes_tigres> rwbarton: but arr is on the right-hand side from >>>, and according to the definition of >>> it can appear in the result of >>> only if it is also on the left hand side of it ? Maybe, it comes from &&& &
13:47:28 <dons> Cale: do you have an .svg of the cabal star/box logo?
13:47:30 <rwbarton> tristes_tigres: but it might also come from &&&
13:47:38 <rwbarton> @src (&&&)
13:47:38 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
13:47:44 <rwbarton> @src (***)
13:47:44 <lambdabot> f *** g = first f >>> second g
13:48:06 <tristes_tigres> @src first
13:48:07 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:48:32 <dcoutts> dons: yes
13:48:34 <trin_cz> Zao: and how do i get the ioref into the handler?
13:48:49 <tristes_tigres> must be &&&
13:49:11 <rwbarton> tristes_tigres: yeah, I think so.
13:49:15 <tristes_tigres> gotta be the arr (\b->(b,b)) part
13:49:21 <dcoutts> dons: http://hackage.haskell.org/images/Cabal.svg or Built-with-Cabal.svg
13:49:50 <dons> ah ha
13:50:06 <dons> these are free and open right?
13:50:12 <dons> i can stick 'em on a cabalised tshirt?
13:51:41 <trin_cz> Zao: onClicked (button3 gui) button3_handler
13:52:16 <trin_cz> Zao: how do I access the IORef value inside button3_handler?
13:53:10 <tristes_tigres> rwbarton: tried to see it with ghci debugger, but it was not very helpful
13:53:43 <tristes_tigres> that's a problem with Haskell, debugging is not very developed
13:56:16 <Zao> trin_cz: Make the first arg an (IORef t) and do  onClicked (button3 gui) (button3_handler yourRef)
13:58:59 <vixey> any new papers about fp or haskell
13:59:00 <vixey> ?
13:59:12 <vixey> I think they stopped writing papers
13:59:49 <chrisdone> vixey: write a paper
13:59:55 <BMeph> vixey: Push direct to RSS? ;)
14:00:07 <dons> vixey: hehe. you've read all the ICFP papers?
14:00:08 <trin_cz> Zao: oh thats what you meant with currying along. silly me, thanks a lot.
14:00:43 <tristes_tigres> iso Barby doll saying "Haskell is hard"
14:02:39 <Plouj> is there a function in prelude to a list of return all permutations of a given list?
14:02:48 <Plouj> to *return a list of all permutations*
14:04:32 <ddarius> No
14:07:12 <Plouj> well
14:07:39 <Plouj> then I'm trying to just copy-paste the code from here: http://www.haskell.org/pipermail/haskell/2006-July/018298.html but either ghc can't find '\\' or 'x'
14:08:51 <rwbarton> Well, the Prelude certainly doesn't export a symbol called 'x' :)
14:09:04 <rwbarton> You should use the last definition, which doesn't use \\ either
14:10:36 <Plouj> the last definition is this, as far as I can tell:
14:10:40 <Plouj> perms xs = [x : ps | (y,ys) <- selections xs, ps <- perms ys]
14:10:44 <Plouj> selections []     = []
14:10:44 <Plouj> selections (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- selections xs]
14:10:45 <rwbarton> I see
14:10:53 <rwbarton> x -> y
14:10:54 <Plouj> and that errors out because x is not in scope in perms
14:11:18 <Plouj> y:ps?
14:11:25 <rwbarton> Right
14:11:35 <ddarius> Incidentally
14:11:37 <ddarius> @index (\\)
14:11:38 <lambdabot> bzzt
14:11:40 <ddarius> @index (\\\\)
14:11:41 <lambdabot> Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
14:12:05 <rwbarton> @index \n
14:12:06 <lambdabot> bzzt
14:12:52 <b_jonas> that it uses (\\) seems strange also because Data.List also provides a function delete to remove just one element
14:13:45 <b_jonas> that latter definition for selections is tricky though
14:14:07 <b_jonas> quite succint
14:14:20 <Plouj> great, now I'm this much closer to world domination
14:15:39 <rwbarton> > let selections = zip <$> id <*> (zipWith (++) <$> (init . inits) <*> (tail . tails)) in selections [1,2,3,4]
14:15:40 <lambdabot>   [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
14:16:13 <MarcWeber> Which is the easiest way to tell ghc that the size (phantom type) here is the same as given in the instance declaration? http://rafb.net/p/Xe6jXV20.html
14:16:14 <lambdabot> Title: Nopaste - No description
14:17:14 <BMeph> MarcWeber: There is no such thing as equating a phantom type to another! Bad monkey, no banana! ;p
14:17:46 <vixey> MarcWeber: if you erase the phantom type does this all typecheck?
14:18:02 <MarcWeber> vixey: let me try
14:18:22 <ddarius> What is the type of convert?
14:19:38 <MarcWeber> vixey: yes, it does now
14:19:47 <rwbarton> I assume from the explicit forall that you've already tried ScopedTypeVariables?
14:20:55 <Cale> > let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs] in select [1,2,3,4]
14:20:56 <lambdabot>   [(1,[2,3,4]),(2,[1,3,4]),(3,[1,2,4]),(4,[1,2,3])]
14:21:01 <MarcWeber> rwbarton: No, not yet
14:21:11 <vixey> @let let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
14:21:11 <lambdabot>   Parse error
14:21:15 <Cale> mm, that was given before :)
14:21:17 <vixey> these things never stick
14:21:28 <Cale> @let select [] = []; select (x:xs) = (x,xs) : [(y,x:ys) | (y,ys) <- select xs]
14:21:29 <lambdabot>  Defined.
14:22:39 <ddarius> select should be nicely expressible with a paramorphism
14:22:50 <MarcWeber> rwbarton: Indeed your proposal is one way to fix it, thanks
14:23:17 <b_jonas> ddarius: sure, you can solve any problem with one more level of abstraction or indirection
14:23:25 <ozy`> > select "pizza"
14:23:26 <lambdabot>   [('p',"izza"),('i',"pzza"),('z',"piza"),('z',"piza"),('a',"pizz")]
14:23:32 <ozy`> ahhhh
14:23:45 * ozy` understands now
14:24:19 <b_jonas> what if instead of selecting one character and permuting the rest, we defined permute by permuting the rest and inserting the first char to every position?
14:24:22 <b_jonas> wouldn't it be simpler?
14:25:40 <Plouj> eh, there's something wrong with that perms function, it keeps returning empty lists
14:26:55 <ddarius> > let perms [] = [[]]; perms xs = [y:ps|(y,ys) <- selections xs, ys <- perms ys]
14:26:56 <lambdabot>   <no location info>: parse error on input `;'
14:27:00 <ddarius> > let perms [] = [[]]; perms xs = [y:ps|(y,ys) <- selections xs, ys <- perms ys] in perms "abc"
14:27:01 <lambdabot>   Not in scope: `ps'Not in scope: `selections'
14:27:08 <ddarius> > let perms [] = [[]]; perms xs = [y:ps|(y,ys) <- select xs, ys <- perms ys] in perms "abc"
14:27:08 <Plouj> http://codepad.org/ZvpXR0ZN
14:27:19 <lambdabot>   Not in scope: `ps'
14:27:27 <ddarius> > let perms [] = [[]]; perms xs = [y:ps|(y,ys) <- select xs, ps <- perms ys] in perms "abc"
14:27:28 <lambdabot>   ["abc","acb","bac","bca","cab","cba"]
14:27:44 <ddarius> > let perms xs = [y:ps|(y,ys) <- select xs, ps <- perms ys] in perms "abc"
14:27:45 <vixey> Plouj: I find:
14:27:46 <lambdabot>   []
14:27:48 <vixey> main = do  putStrLn(show (perms "Mike"))
14:27:53 <vixey> Plouj: _Horrible_
14:28:02 <Plouj> vixey: huh?
14:28:14 <mauke> main = print $ perms "Mike"
14:28:22 <Plouj> oh
14:28:24 <vixey> don't define a main just load into ghci
14:28:27 <Plouj> sorry, I'm a beginner
14:28:33 <vixey> then you can go perms "Mike" in the GHCi thing
14:28:37 <vixey> like
14:28:40 <vixey> > perms "Mike"
14:28:41 <lambdabot>   Not in scope: `perms'
14:28:47 <Plouj> I thought it was easier to do it on codepad.org
14:29:05 <Plouj> I don't know about the $ operator yet
14:29:17 <mauke> main = print (perms "Mike")
14:29:37 <Plouj> ok, thanks
14:29:46 <Plouj> now, lets get back to the real issue
14:29:46 <mauke> @src print
14:29:46 <lambdabot> print x = putStrLn (show x)
14:29:58 <vixey> print = putStrLn . show
14:30:41 <wchogg> Yay, I just detected my wiimote from within Haskell...now to actually communicate with it.
14:30:44 <b_jonas> > let { ins :: a -> [a] -> [[a]]; ins x s = (x : s) : (ins1 x s); ins1 x [] = []; ins1 x (b : s) = map (b :) (ins x s); perms :: [a] -> [[a]]; perms [] = [[]]; perms (b : s) = concatMap (ins b) (perms s) } in unwords $ perms "ABCD"
14:30:45 <lambdabot>   "ABCD BACD BCAD BCDA ACBD CABD CBAD CBDA ACDB CADB CDAB CDBA ABDC BADC BDAC...
14:30:54 <b_jonas> there, inserting the first element
14:31:04 <Plouj> ddarius: where did you get your select function?
14:31:11 <rwbarton> Plouj: Anyways, I don't know if you caught it in what ddarius wrote, but the author of that perms forgot the base case  perms [] = [[]]
14:31:38 <ddarius> b_jonas: Blech
14:31:50 <b_jonas> ddarius: wassamatter?
14:31:58 <b_jonas> ddarius: the wrong order?
14:31:59 <vixey> Plouj: http://hpaste.org/7805
14:32:00 <nicknull> can u write finite state machines in haskell easily?
14:32:13 <b_jonas> oh, it's that time of the year?
14:32:22 <Plouj> vixey: holy crap, what is that?
14:32:23 <vixey> nicknull: yes you can!
14:32:31 <hcube> hi! has anyone experience with writing a simple scene graph library in haskell using opengl ?
14:32:34 <vixey> Plouj: "a solution to N-queens"
14:32:38 <Plouj> http://codepad.org/8w1S9KBw seems to work for me
14:32:40 <b_jonas> @faq can u write finite state machines in haskell easily?
14:32:43 <lambdabot> The answer is: Yes! Haskell can do that.
14:33:04 <dblazakis> vixey: now to do it in the type system
14:33:30 <ddarius> dblazakis: It's even easier in the type system
14:33:52 <rwbarton> Hmm, can we do any of the shootout benchmarks in the type system...
14:34:13 <b_jonas> rwbarton: lol
14:34:44 <dblazakis> ddarius: i thought so
14:35:07 <mauke> my solution for generating permutations: http://mauke.ath.cx/stuff/haskell/Permu.hs
14:35:27 <b_jonas> ddarius: by type system, do you mean the current one, or the one including all future extensions?
14:35:31 <vixey> very succinct mauke
14:35:50 <b_jonas> mauke: wow, a whole monad
14:36:22 <b_jonas> what on earth does it do?
14:36:36 <vixey> I don't know how to do N-queens in the type system
14:36:44 <vixey> will someone show me the code
14:36:52 <Cale> hehe, this is just my solution, only...
14:37:06 <mauke> b_jonas: it's like a combination of State/[]
14:37:21 <Cale> > select [1,2,3]
14:37:22 <lambdabot>   [(1,[2,3]),(2,[1,3]),(3,[1,2])]
14:37:29 <mauke> b_jonas: it carries a hidden list of remaining elements, which you can access with 'draw'
14:37:43 <Cale> > evalStateT . replicateM 3 . StateT select $ [1,2,3]
14:37:45 <lambdabot>   Couldn't match expected type `a -> m a1'
14:37:50 <mauke> b_jonas: 'draw' gives you access to one element, removing it from the hidden list
14:38:05 <mauke> and it works like the list monad in that it actually tries all elements in turn
14:38:12 <b_jonas> @src join
14:38:12 <lambdabot> join x =  x >>= id
14:38:17 <Cale> > evalStateT (replicateM 3 (StateT select))  [1,2,3]
14:38:19 <lambdabot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
14:38:40 <Cale> > evalStateT (mapM (StateT select) [1,2,3]) [1,2,3]
14:38:41 <b_jonas> hmm
14:38:41 <lambdabot>   Couldn't match expected type `a -> StateT s m b'
14:38:44 <Cale> er
14:38:49 <mauke> needs more return
14:38:49 <Cale> > evalStateT (mapM (const (StateT select)) [1,2,3]) [1,2,3]
14:38:51 <lambdabot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
14:38:59 <Cale> Sorry, I'm not totally awake yet ;)
14:39:53 <mauke> > join (evalStateT . mapM (const (StateT select))) [1,2,3]
14:39:55 <lambdabot>   [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
14:40:03 <mauke> ... and that's basically my 'permute'
14:40:17 <b_jonas> in ghci, can you use :m to import a module qualified as another name?
14:40:20 <b_jonas> if so, how?
14:40:57 <Cale> You can't, for some silly reason.
14:41:08 <Botje> probably because nobody wrote it yet
14:41:17 <Cale> You also can't import a subset of the names from some module
14:41:25 <Cale> Or import a module hiding things
14:41:53 <vixey> blerg I wish I was better at functional programming
14:41:57 <inimino> there should be a "No, ghci can't do that." FAQ
14:42:25 <b_jonas> thanks
14:42:35 <Botje> "no, ghci can not do that _YET_"
14:42:40 <b_jonas> I'll put those imports to a module and import that module then I guess
14:42:51 <inimino> Botje: yes
14:42:53 <Cale> b_jonas: I guess I could explain that code ;)
14:43:05 <b_jonas> Cale: which code?
14:43:20 <Cale> Using StateT select to generate permutations
14:43:38 <b_jonas> no wait, I'm trying to read it alone first
14:43:43 <Cale> :t select
14:43:44 <lambdabot> forall t. [t] -> [(t, [t])]
14:43:57 <Cale> It comes from realising that this is secretly monadic :)
14:44:03 <Cale> :t StateT select
14:44:04 <lambdabot> forall t. StateT [t] [] t
14:44:29 <mauke> btw, here's some code that uses Permu: http://rafb.net/p/99MHAI36.html
14:44:29 <leimy> ah yeah looks like State a bit
14:44:30 <lambdabot> Title: Nopaste - No description
14:44:32 <Cale> It's the operation which picks an element (and removes it) from the state, in all possible ways
14:44:42 <mauke> it's a solution for euler #43
14:45:14 <b_jonas> I did think of the list monad
14:45:16 <Cale> > runStateT (StateT select) [1,2,3]
14:45:18 <lambdabot>   [(1,[2,3]),(2,[1,3]),(3,[1,2])]
14:45:29 <b_jonas> but it became just a concatMap
14:45:38 <b_jonas> the state part is the real twist of course
14:45:46 <Cale> > runStateT (replicateM 2 (StateT select)) [1,2,3]
14:45:48 <lambdabot>   [([1,2],[3]),([1,3],[2]),([2,1],[3]),([2,3],[1]),([3,1],[2]),([3,2],[1])]
14:46:00 <vixey> > runLogicT
14:46:01 <lambdabot>       Overlapping instances for Show
14:46:01 <lambdabot>                                  (LogicT...
14:46:04 <Cale> > runStateT (replicateM 3 (StateT select)) [1,2,3]
14:46:06 <lambdabot>   [([1,2,3],[]),([1,3,2],[]),([2,1,3],[]),([2,3,1],[]),([3,1,2],[]),([3,2,1],...
14:46:12 <b_jonas> I mean, the list monad is obvious because both the selecting and the inserting solution uses concatMap, don't they?
14:46:18 <vixey> no one use logicT for anything ;/
14:46:20 * b_jonas rechecks the selecting
14:46:30 <vixey> How can I get better at using lambda?
14:46:39 <Cale> So there, you can see the 'state' in each possible world becoming depleted, and things getting added to the permutation step by step.
14:46:48 <Botje> vixey: go to lambda summer camp!
14:46:51 <mauke> vixey: write a command line calculator in lambda calculus
14:46:57 <b_jonas> yeah, it does, with list slices implicitly
14:46:58 <Cale> vixey: LogicT is actually pretty awesome.
14:47:13 <Cale> vixey: I'm usually content to build my monads over [] though.
14:47:16 <vixey> :t reflect
14:47:17 <lambdabot> forall a (m :: * -> *). (MonadLogic m) => Maybe (a, m a) -> m a
14:47:34 <Cale> LogicT provides more nice operations
14:47:51 <vixey> @instances MonadLogic
14:47:51 <lambdabot> Couldn't find class `MonadLogic'. Try @instances-importing
14:47:56 <vixey> instances--
14:48:02 <vixey> @instances-importing Something MonadLogic
14:48:02 <lambdabot> Couldn't find class `MonadLogic'. Try @instances-importing
14:48:03 <Cale> > runStateT (replicateM 4 (StateT select)) [1,2,3]
14:48:04 <lambdabot>   []
14:48:12 <vixey> @instances-importing Control.Monad.Logic MonadLogic
14:48:13 <lambdabot> Logic, LogicT m, ReaderT e m, StateT s m, WriterT w m, []
14:48:33 <vixey> why doesn't @instances just search there anyway
14:48:34 <b_jonas> so select' in mauke's solution is like the selection function in the email, right?
14:48:48 <vixey> I'm really unable to program this :/
14:48:52 <Cale> b_jonas: yeah
14:49:29 <Cale> So then once you realise that the goal is just to replicateM n (StateT select) where n is the number of elements in the list, the trick is doing it without calling length (because length is inherently ugly)
14:49:35 <Cale> ;)
14:49:46 <b_jonas> only it has a tricky use of fmap on pair
14:49:47 <Cale> But of course, mapM over the original list will do that nicely.
14:49:52 <Cale> yeah.
14:50:14 <mauke> should I use 'second'? :-)
14:50:25 <b_jonas> no
14:50:28 <Cale> Why not a list comprehension?
14:50:34 <b_jonas> meh
14:50:40 <Cale> I think it looks pretty like that :)
14:50:54 <vixey> they should have a project euler except with lambda in it
14:51:00 <Cale> Or of course, you could do it monadically.
14:51:19 <Cale> (generalise to MonadPlus! :)
14:51:22 <b_jonas> I rather thought of =<< or something
14:51:35 <vixey> :t runLogic
14:51:36 <lambdabot> forall a r. Logic a -> (a -> r -> r) -> r -> r
14:51:38 <mauke> b_jonas: that use of 'fmap' is tame, compared to liftM/return in 'permute'
14:52:08 <vixey> > runLogic (do a <- [1,2,3,5,6]; reflect (Just (a,[66,88,22])); return a)
14:52:09 <lambdabot>   Couldn't match expected type `Logic t' against inferred type `[a]'
14:52:12 <b_jonas> I'm just not so used to Functors and all these abstractions
14:52:15 <b_jonas> it's fine
14:52:16 <vixey> > runLogicT (do a <- [1,2,3,5,6]; reflect (Just (a,[66,88,22])); return a)
14:52:17 <lambdabot>   Couldn't match expected type `LogicT m t'
14:52:21 <mauke> @src (,) fmap
14:52:21 <lambdabot> fmap f (x,y) = (x, f y)
14:52:57 <b_jonas> ok, I see how draw works
14:53:08 <vixey> :|
14:53:40 <b_jonas> it returns any element removing it from the state, where any means the list monad
14:54:03 <vixey> :t modify select
14:54:04 <Cale> draw is just slightly silly, since you could just write  draw = Permu (StateT select')
14:54:04 <lambdabot>     Occurs check: cannot construct the infinite type: t = (t, [t])
14:54:05 <lambdabot>       Expected type: [t] -> [t]
14:54:05 <lambdabot>       Inferred type: [t] -> [(t, [t])]
14:54:19 <vixey> omg I cant haskell
14:54:33 <b_jonas> but then permute = join (liftM evalPermu (mapM (return draw)))
14:54:52 <mauke> @unpl join (liftM evalPermu (mapM (return draw)))
14:54:52 <lambdabot> ((liftM evalPermu (mapM (return draw))) >>= \ a -> a)
14:54:56 <mauke> :-(
14:54:59 <Cale> mauke has slightly obfuscated this seemingly on purpose :)
14:55:23 <mauke> it makes the code more fun!
14:55:24 <b_jonas> Cale: that used statet's constructor though, which you aren't supposed to, right?
14:55:35 <Cale> b_jonas: It's not totally forbidden.
14:55:37 <b_jonas> it's complicated only because StateT doesn't have the right functoin
14:55:47 <Cale> b_jonas: Sometimes it's exactly what you want.
14:55:50 <b_jonas> one that both returns something and modifies the state
14:55:59 <Cale> (it's just that's not usually how you think about StateT)
14:56:15 <Cale> See, it does have such a function
14:56:29 <Cale> It's the StateT constructor itself ;)
14:56:55 <b_jonas> Cale: um no, I meant one that modifiy-s, not put-s the variable
14:57:00 <b_jonas> so it would need to get too
14:57:16 <rwbarton> @src StateT
14:57:17 <lambdabot> Source not found.
14:57:20 <rwbarton> , src StateT
14:57:21 <Cale> :t StateT
14:57:22 <lunabot>  luna: Ambiguous occurrence `src'
14:57:22 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
14:57:49 <Cale> This is exactly the operation which we're looking for.
14:57:55 <rwbarton> @tell mmorrow 'src' in lunabot is broken: luna: Ambiguous occurrence `src'
14:57:55 <lambdabot> Consider it noted.
14:58:06 <Cale> rwbarton: uhh...
14:58:13 <rwbarton> , src ''StateT
14:58:14 <b_jonas> I don't get that last line
14:58:14 <lunabot>  luna: Ambiguous occurrence `src'
14:58:16 <vixey> can anyone name some puzzle I want to write a solverao
14:58:17 <b_jonas> how doesw it work?
14:58:23 <mauke> b_jonas: which one, permute?
14:58:28 <Cale> rwbarton: I'm not sure lunabot is supposed to have a src *function*
14:58:29 <b_jonas> yes, permute
14:58:31 <vixey> not hanoi
14:58:37 <rwbarton> Cale: Yes, it used to, it uses TH
14:58:42 <Cale> rwbarton: ah
14:58:43 <mauke> b_jonas: the main obfuscation is that it uses two different monads, one of which is trivial
14:58:47 <olsner> fannkuch perhaps?
14:58:48 <rwbarton> Cale: It's not really src, it's actually :info
14:58:49 <Cale> b_jonas: well...
14:58:58 <Cale> b_jonas: You get what StateT select does, right?
14:59:03 <mauke> welcome to the naked reader
14:59:11 <b_jonas> Cale: yes
14:59:14 <Cale> okay
14:59:30 <b_jonas> at least I restated it in English above
14:59:35 <Cale> b_jonas: So our goal is to run StateT select as many times as needed to pick all the elements out of the state
14:59:51 <Cale> > runStateT (StateT select) [1,2,3]
14:59:53 <lambdabot>   [(1,[2,3]),(2,[1,3]),(3,[1,2])]
15:00:08 <Cale> > runStateT (do x <- StateT select; y <- StateT select; return [x,y]) [1,2,3]
15:00:10 <lambdabot>   [([1,2],[3]),([1,3],[2]),([2,1],[3]),([2,3],[1]),([3,1],[2]),([3,2],[1])]
15:00:15 <Cale> Which is:
15:00:26 <Cale> > runStateT (replicateM 2 (StateT select)) [1,2,3]
15:00:27 <lambdabot>   [([1,2],[3]),([1,3],[2]),([2,1],[3]),([2,3],[1]),([3,1],[2]),([3,2],[1])]
15:00:44 <Cale> and then bumping that 2 up one more gives us everything:
15:00:47 <Cale> > runStateT (replicateM 3 (StateT select)) [1,2,3]
15:00:48 <lambdabot>   [([1,2,3],[]),([1,3,2],[]),([2,1,3],[]),([2,3,1],[]),([3,1,2],[]),([3,2,1],...
15:00:58 <Cale> (and an empty state in every case)
15:01:14 <dons> well, i made my first cabal tshirt
15:01:17 <Cale> Now, instead of replicateM, where we have to know the number of elements of the list
15:01:19 <nicknull> a finite state machine could be very simple right? like with markov-chains, it is an abstract concept that could be applied to a lot of things and doesnt have to be complicated but can be
15:01:23 <Cale> We can use mapM or forM
15:01:28 <vixey> nicknull: yes
15:01:30 <dons> cabal star/box on the front, haskell.org on the back. i'll stick it up on the spreadshirt site
15:01:31 <Cale> With a constant loop body
15:01:37 <nicknull> what is a typial problem to solve with an fsm?
15:01:38 <b_jonas> a moment
15:01:47 <Cale> > runStateT (mapM (const (StateT select)) [1,2,3]) [1,2,3]
15:01:48 <lambdabot>   [([1,2,3],[]),([1,3,2],[]),([2,1,3],[]),([2,3,1],[]),([3,1,2],[]),([3,2,1],...
15:02:00 <vixey> nicknull: why are you interested in FSMs thouh?
15:02:27 <vixey> nicknull: I think we use them as models of concurrent programs sometimes
15:02:32 <Cale> (that way, we avoid computing the length of the list)
15:03:09 <b_jonas> what's confusing is that you're using a select in the evals which is different from "select" in mauke's code I think
15:03:39 <mauke> b_jonas: this (StateT select) is the same as draw
15:04:15 <b_jonas> mauke: without the Permu wrapper, right?
15:04:54 <mauke> yeah
15:04:59 <mauke> it's just a newtype anyway
15:07:39 <vixey> > let q s = s ++ show s in q "let q s = s ++ show s in q "
15:07:40 <lambdabot>   "let q s = s ++ show s in q \"let q s = s ++ show s in q \""
15:08:26 <b_jonas> I think I see
15:08:30 <b_jonas> so the join is in the function monad
15:08:48 <b_jonas> and it is what applies the list to both the mapM (const draw) thingy
15:08:50 <b_jonas> and the list
15:08:57 <b_jonas> strange
15:09:25 <mauke> > join (*) 3
15:09:26 <lambdabot>   9
15:09:26 <b_jonas> it does seem obfuscated to me
15:09:39 <mauke> liftM and return are also from (->) e
15:09:46 <mauke> (they're (.) and const, respectively)
15:09:56 <b_jonas> mauke: yes, I got that from Cale
15:10:06 <mauke> oh, good
15:10:46 <b_jonas> maybe if you already know what join does on the function monad and use it for that idiom
15:11:07 <b_jonas> that way it seems more natural (less obfuscated)
15:11:10 <b_jonas> dunno
15:11:21 <Cale> Probably everything beyond  runStateT (mapM (const (StateT select)) xs) xs  is somewhat obfuscatory
15:11:42 <Cale> However, using join to points-free that isn't so bad.
15:11:54 <Cale> Replacing const with return is slightly evil.
15:12:17 <vixey>  hey I think cut elimination = strong normalization
15:12:39 <Cale> er, evalStateT  rather
15:12:41 <vixey>     A => B  A
15:12:44 <vixey> cut -------
15:12:46 <vixey>    B
15:12:49 <Cale> (since we're not interested in those empty lists)
15:12:59 <mauke> this is what happens when you learn idioms from lambdabot :(
15:13:41 <vixey> a cut elimination proof is the same as strong normalization isn't it?
15:13:58 <vixey> by curry howard
15:14:05 <Cale> That's just function application, isn't it?
15:14:27 <vixey> I read a cut elimination proof of linear logic
15:14:46 <vixey> and I thought, actually this is strong normalization
15:15:01 <Cale> Er, "cut elimination"? I'm a little unfamiliar with the terms.
15:15:08 <Cale> That looks like modus ponens to me.
15:15:46 <vixey> ok it says here:
15:15:57 <vixey> cut elimination theorem states:
15:16:01 <vixey> every sequent calculus  derivation can be transformed into another derivation with the same endsequent (bottom sequent) and in which the cut rule does not occur.
15:16:08 <vixey> and I think it's equiv. to
15:16:17 <Cale> Oh, apparently cut elimination is that if  (A,B,...) |- C and C |- (D,E,...) then (A,B,...) |- (D,E,...)
15:16:19 <vixey> evaluation: every term is equiv. to one with no redex
15:16:30 <vixey> normalization**
15:16:59 <Cale> mmm...
15:17:12 <Cale> It's also a bit like inlining
15:17:16 <vixey> oh!
15:17:36 <vixey> wiki agrees with me for once
15:17:43 <vixey> "For proof systems based on higher-order lambda calculus through a Curry-Howard isomorphism, cut elimination algorithms correspond to the strong reduction property (every proof term has a normal form and this normal form is reached by any complete sequence of reductions)."
15:17:45 <Cale> Which wiki?
15:17:48 <Cale> Wikipedia?
15:17:58 <mauke> the nice thing about wikis is you can MAKE them agree with you
15:18:15 <vixey> yes
15:18:40 <vixey> aww "Is there any major theorem in mathematics drier than Gentzen’s cut elimination theorem."
15:18:43 <vixey> I like the proof theory
15:18:44 <Cale> mauke: It seems hard to make wikipedia agree with my notation for the natural logarithm (I think it should be log), but it doesn't stop me from trying via search and replace from time to time.
15:19:03 <mauke> no, 'log' is clearly a binary operator
15:19:11 <mauke> the natural logarithm is ln
15:19:27 <vixey> the cut rule is exactly the beta application rule
15:19:33 <SamB_XP> no, log is clearly ambiguous
15:19:37 <b_jonas> Cale: I once replaced all thetas in an article with varthetas, and I could even justify it more or less
15:19:40 <Cale> I don't even think logarithms to other bases deserve a definition.
15:19:43 <vixey> that's like splitting up a proof into the two cases  (\x -> y[x]) o
15:19:43 <SamB_XP> it just matches exp
15:19:47 <mauke> preflex: calc 5 log 125
15:19:47 <preflex>  3
15:20:03 <mauke> PREFLEX AGREES, I WIN
15:20:05 <vixey> preflex: calc 1 + (()))) (((ao78eu
15:20:05 <preflex>  Lexical error
15:20:11 <vixey> preflex: calc 1 + (()))) (7))
15:20:11 <preflex>  8
15:20:12 <b_jonas> lambdabot: log 10
15:20:17 <b_jonas> > log 10
15:20:19 <lambdabot>   2.302585092994046
15:20:20 <Cale> Like, we don't define sin_y(x) = sin(x)/sin(y)
15:20:39 <vixey> what can you do with cut elimination
15:21:15 <vixey> weird http://en.wikipedia.org/wiki/Self-verifying_theories
15:21:16 <lambdabot> Title: Self-verifying theories - Wikipedia, the free encyclopedia
15:22:17 <b_jonas> what on earth does this error message mean?
15:22:48 <b_jonas> I must be too tired
15:23:10 <nicknull> ok i want to write a fsm. what could abe a good project? i want to get better at and understand regexps so a fsm for regexps could be a goo idea right? is the egexp-lib for haskell an fsm?
15:23:23 <vixey> nicknull: not regex I don't think so
15:23:33 <vixey> nicknull: that's more like NFA and DFA fun
15:23:36 <opqdonut> nicknull: write the transformation your self
15:23:38 <b_jonas> what does this error mean: http://hpaste.org/11118  ?
15:23:45 <opqdonut> an educational project
15:23:56 <opqdonut> minimizing a state machine is also a good excercise
15:24:24 <mauke> b_jonas: variables can't start with B
15:24:31 <b_jonas> oh
15:24:33 <b_jonas> makes sense
15:24:47 <b_jonas> I knew I was just too tired
15:27:06 <vixey> Can we take proof systems that have cut elimination and turn them into programming languages
15:27:09 <vixey>  ?
15:27:09 <kowey> anybody know how long Cabal has been under development?
15:27:31 <vixey> i.e. with INT on IK, whatever it's called you get lambda calculus
15:28:21 <b_jonas> just those two lines had two other errors apart from that
15:28:23 <b_jonas> so good night now
15:28:55 <sjanssen> kowey: since 2003, maybe earlier?
15:29:01 <nicknull> opqdonut: which transformation?
15:29:16 <kowey> sjanssen: thanks
15:29:21 <Valodim> ..is there any simple method to read and write C binary data? without having to reverse chunks of bytes all the time, I mean
15:29:32 <nicknull> whart does minimizing a state machine mean?
15:29:35 <Heffalump> Mon Apr 26 17:28:22 BST 2004  ijones@syntaxpolice.org
15:29:36 <Heffalump>   * initial Package and Use config import
15:29:40 <Heffalump> is the first darcs patch
15:30:03 <kowey> ah ok... that's certainly some longstanding work
15:30:22 <sjanssen> yeah, I guess 2003 is when the predecessor to Cabal appeared
15:30:27 <sjanssen> http://haskell.org/cabal/old.html
15:30:28 <lambdabot> Title: Old Cabal Stuff
15:30:40 <sjanssen> "For version control, we're using a tool called Arch or tla ("Tom Lord's Arch"). It is more advanced and more confusing than CVS, but it is more appropriate for a distributed, open source project. This is a great chance for you to try out version control system with a lot of momentum! "
15:30:43 <nicknull> http://en.wikipedia.org/wiki/Dfa_minimization , wow that article might be correct but it is poorly written
15:31:05 <sjanssen> tla is referred to as having momentum, must be fairly old :)
15:31:42 <SamB_XP> that's funny
15:31:57 <Heffalump> a disagreement between droundy and Tom Lord was the motivation for darcs
15:32:01 <ivanm> sjanssen: Three Letter Acronyms have momentum?
15:32:04 <SamB_XP> it seemed to me like it was a VCS with an overly ritualistic UI
15:32:04 <ivanm> ;-)
15:41:28 <bos> @seen andyjgill
15:41:28 <lambdabot> I saw andyjgill leaving #haskell and #ghc 38m 1s ago, and .
15:48:14 <nicknull> @seen lambdabot
15:48:14 <lambdabot> Yes, I'm here. I'm in ##freebsd, ##hrg, #xmonad, #unicycling, #scannedinavian, #scala, #rosettacode, #perl6, #jtiger, #jhc, #haskell_ru, #haskell.se, #haskell.ru, #haskell.no, #haskell.jp, #haskell.
15:48:14 <lambdabot> it, #haskell.hr, #haskell.fr, #haskell.fi, #haskell.es, #haskell.dut, #haskell.de, #haskell.cz, #haskell-soc, #haskell-overflow, #haskell-hac07, #haskell-books, #haskell-blah, #haskell, #ghc, #
15:48:14 <lambdabot> gentoo-uy, #gentoo-haskell, #friendly-coders, #dreamlinux-es, #darcs, #arch-haskell and ##logic
15:48:21 <nicknull> sorry
15:48:34 <nicknull> i thought lambdabot was just for haskell
15:48:51 <nicknull> @fac is lambddabot an irc-whore?
15:48:52 <lambdabot> Maybe you meant: fact fact-cons fact-delete fact-set fact-snoc fact-update faq
15:49:16 <nicknull> @fac can haskell get me jessica alba?
15:49:17 <lambdabot> Maybe you meant: fact fact-cons fact-delete fact-set fact-snoc fact-update faq
15:52:12 <inimino> ah tla, those were the days
16:00:26 <Plouj> I managed to use haskell to find a combination of bank transactions that added up to a certain amount :)
16:01:28 <Plouj> It turned out that I didn't need permutations of lists, but combinations of lists. Thankfully, someone has already solved that: http://www.haskell.org/haskellwiki/99_questions/21_to_28
16:01:30 <lambdabot> Title: 99 questions/21 to 28 - HaskellWiki
16:08:52 <halberd> Plouj: the subset sum problem is NP-complete
16:09:35 <Plouj> really?
16:09:44 <halberd> yes
16:09:47 <Plouj> I mean, is that what my problem is?
16:09:58 <Plouj> I only had 8 transactions to choose from.
16:10:14 <Plouj> and only 255 combinations
16:10:20 <halberd> I didn't read your earlier explanation but what you said now sounds like the subset sum problem
16:10:26 <halberd> fine for 8 transactions, not for 80
16:11:03 <Plouj> ah, you're right, my problem is a subset sum one
16:11:44 * Plouj makes not of that in the code
16:12:49 <Plouj> note*
16:23:03 <mmorrow> hmm, ambiguous src??
16:23:03 <lambdabot> mmorrow: You have 1 new message. '/msg lambdabot @messages' to read it.
16:23:05 <mmorrow> , src
16:23:06 <lunabot>  luna: Ambiguous occurrence `src'
16:23:12 <nicknull> is there an eval function in haskell? lets say i want a general function that takes functions as input and i want to rep them as strings(maybe not needed?), can i eval a string?
16:23:27 <Cale> nicknull: hs-plugins can do that for you
16:23:33 <Plouj> how can I remove OpenGL-2.2.1.1 from /home/plouj/.ghc/x86_64-linux-6.8.2/package.conf but keep the system one (in /usr/lib64/ghc-6.8.2/package.conf:)?
16:23:34 <Pseudonym> You're right that it's probably not needed, though.
16:23:35 <Cale> nicknull: It has a typesafe eval.
16:23:45 <Pseudonym> Generally speaking, it'
16:23:52 <Cale> nicknull: But functions are already first-class values.
16:23:52 <Pseudonym> the best representation of a function is a function.
16:23:57 <mmorrow> nicknull: hs-plugins has an eval function. lunabot does also, but it's not quite ready to be packaged.
16:24:11 <Plouj> dons: ping
16:24:21 <Pseudonym> Or, alternatively, make a DSL plus interpreter if that seems more appropriate.
16:24:46 <mmorrow> grrrrr
16:24:47 <mmorrow> `Text.XHtml.Strict.Attributes.src'
16:24:52 <Cale> http://www.mezzacotta.net/archive.php?date=random -- undoubtedly one of the largest archives of any webcomic ;)
16:24:54 <lambdabot> Title: mezzacotta - Comic Archive
16:25:47 <Cale> (of course, they're randomly generated based on the date, and so most of them are awful, but the ones which get good votes end up in the hall of fame)
16:27:31 <Cale> (er, and the best baked comics list)
16:27:38 <mmorrow> , src ''Functor
16:27:49 <lunabot>  class Functor f where
16:27:49 <lunabot>          fmap :: forall b a . (a -> b) -> f a -> f b
16:28:05 <mmorrow> , src 'LamE
16:28:10 <lunabot>  data Exp = ... | LamE ([Pat]) Exp | ...
16:28:10 <lunabot>  infixl 9
16:29:04 <mmorrow> , src ''IO
16:29:08 <lunabot>  newtype IO a = IO ((State# RealWorld) ->
16:29:08 <lunabot>                     (#,#) (State# RealWorld) a)
16:29:32 <Plouj> does anyone else get "Setup: frag.cabal:86: Parse of field 'build-depends' failed:" when building the latest checkout of frag (http://code.haskell.org/frag)?
16:29:39 <bos> yay! padl paper accepted!
16:29:44 * Cale tries
16:29:47 <Pseudonym> Woot!
16:29:52 <mmorrow> cool
16:30:14 <Pseudonym> What's it on?
16:31:08 <bos> using bloom filters for gene sequence analysis.
16:31:11 <bos> in haskell.
16:31:14 <Cale> Plouj: Well, it's compiling, so I'm probably not going to get that message.
16:31:17 <Pseudonym> Oh, that one.
16:31:21 <Pseudonym> Right.
16:31:26 <bos> @seen ketil
16:31:26 <Cale> Plouj: What are you using to build it?
16:31:26 <lambdabot> I saw ketil leaving #haskell 1m 17d 39m 33s ago, and .
16:31:50 <Pseudonym> bos, given that my next job is very likely to be in genomics, allow me to posit an observation.
16:32:01 <Pseudonym> Bioinformaticians tend to be very good scientists, but not very good engineers.
16:32:06 <bos> i know.
16:32:20 <Cale> Plouj: I'm using cabal-install with Cabal 1.4.0.1
16:32:26 <SamB_XP> that's what seperates them from god
16:32:31 <Plouj> $ runhaskell Setup configure --user --prefix=$HOME
16:32:32 <Plouj> Setup: frag.cabal:86: Parse of field 'build-depends' failed:
16:32:41 <bos> Pseudonym: they're a bunch of perl hackers, after all.
16:32:46 <SamB_XP> that, and a heck of a lot of knowledge about how DNA actually works
16:32:53 <Cale> Plouj: ghc-pkg list Cabal
16:32:55 <Pseudonym> It's also what separates them from Enterprise Java .NET/Boss hackers.
16:33:01 <Plouj> Cabal-1.2.3.0
16:33:14 <Cale> Plouj: ghc --version
16:33:22 <Plouj> version 6.8.2
16:33:31 <Cale> okay, you need to update Cabal then.
16:33:33 <SamB_XP> Pseudonym: what? those guys aren't either engineers or scientists?
16:33:49 <Cale> I would highly recommend getting cabal-install while you're at it.
16:33:54 <Pseudonym> SamB: They're engineers, or at least enough of them are that they take the engineering aspects seriously.
16:34:03 <Cale> Building packages by hand sucks.
16:34:10 <Plouj> I don't see a newer version of ghc (which comes with cabal) in my OS (Fedora 9)
16:34:32 <jeffz`> Plouj: Cabal-1.6.0.1 is on hackage
16:34:40 <Pseudonym> Anyway.
16:34:43 <Plouj> :/
16:34:53 <Plouj> I'd have to install so much crap just to get it to work
16:34:55 <Pseudonym> Sadly, bloom filters don't seem to be appropriate for the job that I'm probably going to be hired to do.
16:34:58 <SamB_XP> Plouj: you can install additional versions without causing harm
16:35:12 <Pseudonym> It's more of an inverted index-sized problem than a set-member-sized problem.
16:35:23 <Pseudonym> Still.
16:37:06 <Plouj> so, what is the main package that I should install? Cabal? Cabal-install?
16:37:34 <dons> cabal-install
16:37:42 <dons> but you can upgrade cabal first too, if you like.
16:37:50 <dons> no more building packages by hand.
16:37:54 <dons> let the package solver work it out
16:38:02 <Cale> You'll probably need to install a newer Cabal first.
16:38:19 <SamB_XP> perhaps two or three other packages
16:38:21 <Cale> Unless you get an older cabal-install...
16:38:27 <SamB_XP> it's improving, I think
16:38:30 <Cale> Yeah, there's HTTP, and zlib
16:38:37 <Cale> and maybe one other that you'll need
16:38:48 <Cale> But those are the last packages you'll ever have to install by hand
16:38:57 <Cale> Oh, also, I think there's a package you can get
16:39:02 <Cale> which does all of this automatically
16:39:21 <Cale> hmm... what was that called...
16:39:46 <jeffz`> not sp?
16:39:50 <Cale> oh
16:40:01 <Plouj> is it ok to keep an old Cabal installed system-wide?
16:40:02 <Cale> You get cabal-install, and it comes with a script which will bootstrap it
16:40:06 <Cale> Yes.
16:42:33 <Cale> jeez, compiling ObjectBehavior.hs from frag takes a long time.
16:43:41 <dons> thinking .. thinking ..
16:45:29 <Plouj> so, how do I install frag with cabal-install?
16:45:38 <Plouj> Cale:?
16:45:58 <Cale> cabal install frag
16:46:01 <Plouj> I have 3 cabals installed now :)
16:46:26 <Cale> You might want to add ~/.cabal/bin to your path
16:46:53 <Plouj> erm, oh yeah
16:47:18 <Cale> (because when you install programs as user, that's where it will install them)
16:47:41 <TSC> @type <$>
16:47:42 <lambdabot> parse error on input `<$>'
16:47:43 <Plouj> I really want to install frag from the source from darcs
16:47:45 <TSC> @type (<$>)
16:47:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:49:07 <Plouj> frag]$ runhaskell Setup configure --user
16:49:08 <Plouj> Configuring frag-1.1.2...
16:49:08 <Plouj> Setup: At least the following dependencies are missing:
16:49:08 <Plouj> base ==4.*
16:49:12 <Plouj> $ cabal install base
16:49:12 <Plouj> cabal: There is no package named base
16:49:15 <Plouj> what gives?
16:49:32 <Plouj> currently, I only have base-3.0.1.0
16:50:24 <byorgey> Plouj: what's in the frag.cabal file?  does it actually say base ==4.* ?
16:50:30 <Plouj> yeah
16:50:37 <byorgey> gee whiz
16:50:41 <Plouj> Build-Depends:       base==4.*, GLUT, OpenGL>=2.0, array, random
16:50:49 * Plouj looks at dons 
16:50:59 <byorgey> well, that means it will only work with base-4, which comes with ghc 6.10 I think
16:51:04 <Cale> wait, what?
16:51:14 <Cale> I just did a cabal install frag and it worked
16:51:20 <byorgey> Cale: I know, right?
16:51:30 <Cale> Oh, it installed 1.1.1
16:51:31 <byorgey> Cale: Plouj is building from the frag darcs source.
16:51:39 <Cale> ah, don't do that then.
16:52:02 <Plouj> well, now even cabal install frag doesn't work
16:52:07 <byorgey> "#haskell, it hurts when I do this."
16:52:10 <byorgey> "then don't do that"
16:52:12 <Plouj> cabal: cannot configure frag-1.1.2. It requires base ==4.*
16:52:24 <Cale> try  cabal install frag-1.1.1
16:52:48 <Plouj> it's running
16:52:53 <Plouj> on another note
16:53:02 <Plouj> how can I use cabal to upgrade my xmonad?
16:53:09 <Plouj> 'cabal upgrade xmonad'?
16:54:43 <Cale_> Plouj: yeah
16:55:36 <bos> Pseudonym: what kind of gig are you moving to?
17:00:53 <Plouj> bah
17:01:07 <Plouj> I get the same GL linking error when building frag as I did before
17:01:39 <Plouj> http://codepad.org/fj30ViOz
17:02:43 <thoughtpolice> Plouj: you need to build with -lglut or something on the command line
17:03:03 <thoughtpolice> it brings in the haskell library, which has foreign bindings to the actual C glut library
17:03:25 <Plouj> (that's why I didn't want to use cabal to build it)
17:03:40 <thoughtpolice> iirc, cabal can handle that for you automatically
17:03:48 <thoughtpolice> you just have to put the name of the lib in a certain field
17:03:52 <Plouj> but that linking error is from cabal
17:04:08 <bos> you need to tell cabal the name of the C library.
17:04:16 <Plouj> bos: how?
17:04:36 <bos> er, can't remember.
17:04:41 <thoughtpolice> Plouj: right, because it doesn't know it needs to link in the C library as well
17:04:45 <thoughtpolice> you can tell cabal to do it, however
17:04:47 <thoughtpolice> just a sec,
17:05:10 <thoughtpolice> Plouj: try putting a 'extra-libraries: glut' field in somewhere
17:05:26 <dcoutts> if it depends on the GLUT package then there should be no need
17:06:30 <Plouj> thoughtpolice: where is this somewhere?
17:06:38 <thoughtpolice> in the .cabal file
17:07:03 <dcoutts> that's only a workaround, the GLUT package must be borked
17:07:06 <Plouj> I don't have a .cabal file for frag
17:07:11 <dcoutts> ghc-pkg field GLUT ld-options
17:07:16 <Plouj> I'm doing 'cabal install frag'
17:07:18 <dcoutts> for me that includes -lglut
17:07:27 <Plouj> $ ghc-pkg field GLUT ld-options
17:07:27 <Plouj> ld-options:
17:07:33 <dcoutts> right, borked
17:07:59 * Plouj tries 'cabal install GLUT'
17:08:05 <dcoutts> Plouj: what platform are you building on? did you build the GLUT yourself?
17:08:06 <Plouj> GLUT was installed by Fedora 9
17:08:28 <Plouj> erm
17:08:31 <dcoutts> Plouj: in this context it's the ghc package GLUT, which is a binding to the C lib for glut
17:08:31 <Plouj> now I get this:
17:08:34 <Plouj> $ ghc-pkg field GLUT ld-options
17:08:34 <Plouj> ld-options:
17:08:34 <Plouj> ld-options:
17:08:51 <Plouj> dcoutts: I know
17:08:58 <Plouj> $ ghc-pkg list GLUT
17:08:58 <Plouj> /usr/lib64/ghc-6.8.2/package.conf: GLUT-2.1.1.1
17:08:58 <Plouj> /home/plouj/.ghc/x86_64-linux-6.8.2/package.conf: GLUT-2.1.1.2
17:09:35 <dcoutts> Plouj: so you installed the ghc GLUT package using the native fedora rpm? or from source, or both?
17:10:29 <Plouj> the system-wine GLUT was installed by 'yum install ghc'
17:14:03 <nicknull> if i have a state ina monad csn i then change thsat state inside another monad? or i have to return a new state and assign it in the main-monad?
17:31:47 <nicknull> if i have a state ina monad csn i then change thsat state inside another monad? or i have to return a new state and assign it in the main-monad?
17:32:20 <hackage> Uploaded to hackage: happy 1.18.1
17:34:34 <EvilTerran> nicknull, if you're going to repeat yourself, could you at least fix your typos first? it'd be slightly more polite that way.
17:34:45 <EvilTerran> no-one had said anything since last time, we could all still see it
17:35:30 <EvilTerran> if there's no response, that would suggest that no-one currently active (being no-one, at the moment) knows how to answer your question
17:35:54 <EvilTerran> i don't know either, unfortunately
17:38:20 <nicknull> If i have a state in a monad can I then change that state inside another monad? Or i have to return a new state and assign it in the main-monad? Lets say I am modeling a subway-coin-apparatus with a finite-state-machine and I want to store the current state in. I could ofc read and write to a file but I want to store it in a program. Could I use refs for example to manipulate that value? I guess I could do withou, just wondering.
17:41:06 <Botje> nicknull: if you used the state monad you'd probably use runState
17:41:11 <Botje> which returns an answer and a final state
17:41:18 <Botje> you can do with that state whatever you wish :)
17:47:56 <TomMD> How do I get gtk2hs to start a window as floating (esp useful with xmonad)?
17:58:40 <TomMD> > const "pong"
17:58:41 <lambdabot>       Overlapping instances for Show (b -> [Char])
17:58:41 <lambdabot>        arising from a use ...
17:58:43 <TomMD> > const "pong" ()
17:58:45 <lambdabot>   "pong"
18:00:59 <adu> hi
18:09:09 <pjdelport> > return "pong" ()
18:09:10 <lambdabot>   "pong"
18:09:15 <pjdelport> > pure "pong" ()
18:09:16 <lambdabot>       Ambiguous occurrence `pure'
18:09:16 <lambdabot>      It could refer to either `Control.Appl...
18:35:31 <adu> is there a let-like way to have temporary data?
18:36:04 <Cale> adu: What do you mean by that?
18:36:18 <Cale> adu: Data is as temporary as you keep references to it.
18:37:08 <adu> like let data Temp155 a = Temp155 a in return (Temp155 1234789) >>= \(Temp155 x) -> return x
18:37:26 <adu> or would that just be stupid
18:38:50 <EvilTerran> ah, local datatypes?
18:38:55 <adu> EvilTerran: yes
18:39:04 <EvilTerran> no, you can't do that in haskell, except by splitting things up with modules
18:40:12 <adu> EvilTerran: ok, just trying to push the limits of the status quo :)
18:40:45 <EvilTerran> it'd be nice if you could
18:41:09 <EvilTerran> i'm still wondering where local/in went between ML and haskell
18:41:21 <adu> EvilTerran: although, I'm not sure what kind of problems it would solve, aside from namespace problems
18:42:04 <juhp> hmm my ghc682 build with ghc683 failed
18:42:25 <adu> juhp: 683 doesn't build 682??? woah
18:42:34 <juhp> not for me
18:42:37 <maxote> ghc683 is more unstable than ghc682, i though
18:42:46 <juhp> hmm
18:42:50 <adu> juhp: usually ppl upgrade... maybe noone has tried downgrading
18:43:00 <juhp> sure :)
18:43:12 <adu> maxote: no 6.7 and 6.9 are unstable
18:43:14 <sclv> anyone here with a *really good* knowledge of sockets?
18:43:17 <juhp> I just had ghc683 installed and wanted to test a ghc682 build...
18:43:26 <adu> sclv: I wrote some socket code once
18:43:36 <adu> sclv: wanna see?
18:43:42 <sclv> been ramming up against something weird for about a week+ now and maybe someone could help me out.
18:44:25 <sclv> not just writing socket code, but either an explanation from the tcp stack up of how they're implemented in linux and windows, or a pointer to such.
18:44:47 <sclv> and/or a sense of how the haskell bindings on linux and windows differ.
18:44:53 <ivanm> sclv: what, wikipedia not good enough for you? :p
18:45:12 <sclv> so far, no.
18:45:16 <ivanm> :o
18:45:32 <juhp> let's hope it builds in the buildsys...
18:45:36 <sclv> first question -- in haskell if you create a simple server on a windows box, and then give it a command to drop the connection.
18:45:39 <ivanm> see? britannica was _right_! :p
18:45:52 <sclv> it doesn't fully drop it.
18:45:59 <sclv> i.e., telnet stays connection.
18:46:04 <sclv> on unix, it does.
18:46:04 <adu> sclv: http://hpaste.org/11129
18:46:28 <sclv> adu: any reason you used sockets directly instead of handles?
18:46:35 <sclv> is there a "gotcha" in the handle code?
18:46:38 <adu> sclv: to learn?
18:46:42 <sclv> ah.
18:47:01 <adu> sclv: plus, I was learning how to use netcat
18:47:23 <sclv> in any case, the more general issue is that there's a socketed application doing its thing for roughly, say, two days... and suddenly, with no error messages, the sockets all "go zombie".
18:47:37 <sclv> you connect in and they hang.
18:47:37 <dblazakis> sclv: you might learn something if you used wireshark to capture the traffic
18:47:39 <sclv> outgoing connections block forever.
18:47:45 <adu> zombie??
18:47:57 <adu> wireshark rocks!
18:48:30 <sclv> hmm... yeah... we've been poking at it with the "scientific method" (i.e. tweak and try again), since /proc was less than helpful.
18:48:43 <sclv> but yeah, netcat and wireshark might be the better way to go.
18:49:01 * adu <3 netcat
18:49:18 <sclv> anyone ever seen what I'm describing?
18:49:32 <sclv> the socket-driven part of the app becomes nonresponsive, but does *not* drop connections.
18:49:34 <dblazakis> well, you can half close a TCP connection by sending the RST from one side (IIRC)
18:49:45 <sclv> but the cli part of the app sticks around.
18:49:50 <adu> sclv: what is the socketed application called?
18:49:59 <sclv> adu: its in house code.
18:50:05 <adu> oh
18:50:22 <sclv> the underlying libraries are probably going to be released though, assuming we get it stable.
18:50:35 <dblazakis> i would use a trace tool to figure out exactly what is going on, then you can figure out what is doing the wrong thing
18:50:44 <sclv> wireshark is what you recommend?
18:50:59 <dblazakis> on windows, definitely
18:51:04 <sclv> the other way to look at it is this: we know we're not leaking fds because we can check that.
18:51:08 <sclv> (and on unix?)
18:51:23 <sclv> but since it goes for a long time and then dies, we suspect we're leaking something else.
18:51:27 <adu> wireshark has a nice GUI, but snort & tcpdump & netcat are way more powerful imho
18:51:32 <dblazakis> tcpdump would be easier than ethereal if you can come up with a good filter, but that's just me being lazy and not wanting to mess with a GUI
18:51:35 <sclv> but we don't know what else there is that *could* be leaked!
18:52:04 <dblazakis> adu: i agree, but i've never liked playing with cygwin on windows, so wireshark it is
18:52:27 <sclv> is it possible that one could leak half open tcp connections and not leak fds?
18:52:50 <rwbarton> It may be worth it to run strace or the equivalent on the server, to see if the bound socket is getting closed, or accept() is returning errors, or something
18:52:50 <lambdabot> rwbarton: You have 1 new message. '/msg lambdabot @messages' to read it.
18:52:50 <adu> dblazakis: ya, I always ran into really obscure problems like "home directory ~ does not exit" or "/lib/crt0.so not found" and the like...
18:53:36 <adu> dblazakis: cygwin is like putting sugar icing on a pile of poo
18:54:18 <dblazakis> adu: hehe, i've set it up to a point where it works nice for me, but it feel like an uphill battle
18:54:29 <dblazakis> *feels
18:54:53 <sclv> strace is sort of awful though since we usually hit this after say two days of uptime.
18:55:15 <sclv> if we really try we can hit it after say twenty minutes by generating load.
18:57:15 <dblazakis> is this one long persistent connection? or is it multiple connections over these 2 days?
18:58:14 <adu> 1 -> timeouts? ; _ -> overflow?
18:58:23 <sclv> many many connections
18:58:32 <adu> definitely an overflow
18:58:45 <sclv> right -- but of what?
18:59:02 <adu> sclv: how am I supposed to know if you don't release the code?
18:59:07 <sclv> i.e. if we're not leaking fds, what else is there to leak?
18:59:25 <dblazakis> are they very short lived?
18:59:36 <dblazakis> could leak ports
18:59:39 <dblazakis> i guess?
18:59:42 <sclv> adu: if we can distill a test case and can't solve it still, then we'll absolutely post it.
19:00:04 <sclv> hmmm.
19:00:07 <adu> sclv: have you tried "lsof -i"?
19:00:11 <dblazakis> if you exhaust available ports (all your ports are in timed wait or whatever)
19:00:24 <dblazakis> (i'm just taking shots in the dark)
19:00:54 <sclv> they're short lived, but i don't think it has to do with mass of connections -- just with overall number.
19:01:04 <dblazakis> i would count the number of successful
19:01:07 <sclv> in that once it freezes it never unfreezes.
19:01:09 <dblazakis> see if it works out to be a magic number
19:01:21 <sclv> number of successful connections in toto?
19:01:22 <sclv> hmm.
19:01:41 <dblazakis> what is the server architecture? do you spawn a thread for each connection? a process?
19:01:49 <sclv> thread per connection.
19:02:02 <sclv> mainly outgoing.
19:02:03 <dblazakis> are you leaking threads?
19:02:44 <sclv> hmm -- the threads per connection are on the server part.
19:02:49 <sclv> its the "client" bit that hangs.
19:03:04 <dblazakis> ah, i misunderstood
19:03:04 <sclv> which is an event loop.
19:03:23 <dblazakis> can another client connect to the server?
19:03:28 <sclv> (but the "client" bit also has a "server" bit that we can talk to on occasion)
19:03:42 <dblazakis> sounds complex
19:03:48 <sclv> dblazakis: as far as we can tell, yeah.
19:03:58 <sclv> we've got like eight things or so, maybe a few more.
19:04:05 <sclv> but only a few go belly up.
19:04:19 <sclv> the ones with lots of outgoing connections -- particularly to windows machines.
19:04:40 <sclv> so that's a place to try to distill things down to tomorrow.
19:04:42 <dblazakis> to keep this even remotely on topic,  the client is in Haskell? the server?
19:04:47 <sclv> both.
19:04:55 <shapr> ooh
19:04:59 <shapr> released when?
19:05:11 <sclv> not released yet -- jp talked about it at cufp though.
19:05:27 <sclv> its not going to make a good use case if everything keeps going kerfritz.
19:06:02 <sclv> (the core will be released, that is, i hope, which is a set of networking abstractions)
19:06:08 <sclv> the other stuff is all in-house.
19:06:30 <dblazakis> is it always windows only?
19:06:33 <sclv> also, maybe, eventually, no promises, we'll whip into shape his hlist for db stuff.
19:06:53 <sclv> its unix processes talking to windows ones -- only the unix ones die, but then they're doing all the chattering.
19:07:47 <dblazakis> oh when they connect to windows machine (a lot)
19:07:49 <shapr> tried swapping it around?
19:08:09 <shapr> make windows chatter and unix listen?
19:08:40 <sclv> hmm... we'd need a test case first... the windows and unix processes are each on their respective home for good reason.
19:09:02 <sclv> so again, the question is this: if we can confirm we're not leaking fds, what else is there that could be leaked?
19:09:19 <sclv> i.e. is it possible to leak ports without fds?
19:09:32 <dblazakis> yes, cause of timed wait
19:09:34 <sclv> or is there some other funny resource hiding in the networking stack that could leak?
19:09:53 <sclv> but timed wait will invariably resolve itself after four minutes, right?
19:10:01 <sclv> what command shows all ports in use?
19:10:09 <cjs> slcv: How many sockets do you have open simultaneously?
19:10:12 <sclv> is that lsof?
19:10:24 <rwbarton> I like   netstat -atnp
19:10:26 <sclv> cjs: ideally, no more than 10 or so, although potentially more.
19:10:32 <dblazakis> sclv: yeah, they never come back...
19:10:52 <sclv> buzah? never?
19:11:03 <cjs> So it's not an issue with running out of file descriptors. What exactly do you mean by "go zombie," or did I miss a precise description above?
19:11:04 <dblazakis> sclv: no i was agreeing
19:11:18 <cjs> BTW, in this case, ktrace may be more your friend than wireshark. Oops, strace, if you're using Linux.
19:11:32 <sclv> go zombie = telnet localhost 8008
19:11:39 <sclv> telnet connects. then... nothing.
19:11:44 <sclv> nonresponsive.
19:11:54 <rwbarton> telnet introduces all kinds of complicatedness
19:12:07 <dobblego> aka complication :)
19:12:08 <cjs> Ah, your server is listening, but when you connect, your server doesn't accept.
19:12:09 <dblazakis> sclv: this is telnetting to the client application?
19:12:19 <sclv> dblazakis: yep.
19:12:34 <dblazakis> so in 8008 or what ever in a control port?
19:12:47 <sclv> but if we have a supervisor process trying to query it over that port (i.e. no telnet) then it does the same thing.
19:12:51 <cjs> Yes, using nc instead of telnet is better, but actually, if this behaviour is that the TCP handshake is completed but the application then doesn't send or receive data, tcpdump and telnet will show that just fine.
19:12:55 <sclv> yep, a control port
19:13:04 <dblazakis> could it just be an infinite loop somewhere in your app keepin it from doing anything?
19:13:07 <cjs> (Or should, really.) BTW, nc == netcat
19:13:22 <dblazakis> this doesn't sound like a network issue if a TCP connection succeed
19:13:49 <sclv> dblazakis: no, because the main loop serving that port is forever $ h <- accept sock; forkIO $ dothingwith h
19:13:56 <sclv> it hangs on accept.
19:14:05 <cjs> My recommendation is to attach an strace to the process, start tcpdump, netcat -vv to that port, confirm you have full TCP handshake, and then confirm that your program returned from accept().
19:14:20 <dblazakis> i'm with cjs
19:14:23 <tanob> hello, is there any haskell library that outputs JVM bytecodes?
19:14:30 <sclv> beause if we caught an error on accept then it would at least display that.
19:14:46 <cjs> BTW, I've seen the ruby VM do exactly this. It was something interesting with signals, as I recall....
19:14:59 <cjs> s/VM/runtime/
19:15:23 <sclv> oh yeah, related question -- we've obviously got it set to ignore the signal from hangup, and then to hangup on an EOF instead.
19:15:24 <cjs> Oh, yeah, something related to EAGAIN, or lack thereof....
19:15:30 <sclv> is that an issue?
19:15:38 <sclv> it seems to be the recommended way to do things.
19:16:04 <cjs> hangup? That's an OS signal, and has nothing to do with your TCP connections, or EOF on anything you're reading, really, unless you're reading stdin.
19:17:15 <cjs> Oh, incidently, if you're doing stuff like this, and you don't have a copy of Stevens' _Advanced Programming in the UNIX Environment_, I'd highly recommend grabbing a copy. It puts examples of how to do stuff properly all in one place.
19:17:18 <sclv> gah -- i'm not being specific enough.
19:18:11 <dblazakis> SIGPIPE?
19:18:14 <cjs> Oh, one thing you might check, just as a data point, is whether you can still connect (and multiple times, even) if your listen queue is set to 0.
19:18:19 <sclv> yah, sigpipe
19:18:32 <sclv> listen queue?
19:18:36 <cjs> Ah, yes. Definitely ignore SIGPIPE. Silliest signal ever.
19:18:49 <sclv> one of the issues here is that we're working with haskell's high level api
19:19:03 <sclv> Network, not Network.Socket, and certainly not c.
19:19:10 <cjs> It's the "backlog" argument to the listen syscall. Basically, even if you're not in accept, the OS will accept and queue up (for the next time you call accept) that many connections.
19:19:21 <cjs> Ooo....I don't recommend using Network. It has...issues.
19:19:22 <sclv> so its hard to follow things all the way down the rabbit hole and see what's really happening.
19:19:31 <sclv> cjs: what issues have you discovered?
19:19:55 <cjs> Depending on the OS, binding to IPv6 instead of IPv4.
19:20:25 <cjs> And no way to control which it does.
19:20:53 <cjs> Missing options, such as no backlog argument to listen. :-)
19:21:21 <sclv> weird. the more we poke at this thing the more its like we have to throw away all the abstractions and build it from scratch. bleh :-(. much prefer to track it down at the high level and file a bug report to show why.
19:21:51 <cjs> I'd just move down to Network.Socket. It's not much more difficult to use, and will in fact probably be easier beacuse you can just do well-documented POSIX things (like from Stevens).
19:21:57 <sclv> Network could definitely use some love from people who are better at the Socket stuff than me.
19:22:13 <sclv> handles are such a nice abstraction though!
19:22:33 <dblazakis> it looks like it uses SOMAXCONN for backlog
19:22:41 <cjs> Well, my impression was that the "higher-level" IO stuff was not supposed to be a better abstraction, really, but a simpler one for those who don't need "production quality" systems, e.g., student exercises.
19:22:52 <sclv> oh...
19:22:57 <sclv> well then.
19:23:27 <sclv> so next step on the voodoo debugging train is just to move everything to Network.Sockets and try again.
19:23:32 <cjs> Basically, Network removes a bunch of details and knobs, but doesn't add anything; it's just a simplified Network.Socket.
19:23:40 <cjs> It won't be a hard move.
19:24:01 <sclv> right -- we've got all the abstractions in place.
19:24:23 <sclv> I had just thought that Network was the "right way"
19:26:00 <sclv> thanks for all the help -- got plenty of ideas to play with tomorrow.
19:26:47 <sclv> oh -- wait, one additional issue -- does socketToHandle cause any issues, or is it legit to use?
19:27:16 <sclv> i.e. if I switch to sockets directly, then should I still convert then to handles, or does that throw all the benifits out again?
19:28:26 <cjs> I've used it and it seemed fine, though I didn't use it extensively.
19:29:17 <cjs> I think you kinda have to use it for any serious server, since the socket operations return Strings, not ByteStrings.
19:29:46 <sclv> oh, right so sockets for underlying and then Network.Bytestring on top
19:30:12 <cjs> There's a Network.ByteString?
19:30:28 <sclv> yep
19:30:34 <cjs> Ooo!
19:30:37 <sclv> http://hackage.haskell.org/packages/archive/network-bytestring/0.1.1.2/doc/html/Network-Socket-ByteString.html
19:30:39 <lambdabot> Title: Network.Socket.ByteString, http://tinyurl.com/5r58kh
19:30:42 * cjs is happy about this.
19:31:05 * cjs lives and dies by ByteStrings.
19:31:39 <dblazakis> sclv: who do you work for?  you said someone who presented at CUFP?
19:32:24 <sclv> http://cufp.galois.com/2008/abstracts.html#PolakowJeff
19:32:25 <lambdabot> Title: Commercial Users of Functional Programming 2008 Program
19:32:51 <cjs> Oh, you're working with him! Cool. We're doing similar stuff, then.
19:33:04 <sclv> cjs: you were at cufp?
19:33:35 <cjs> Yup. Curt Sampson, Starling Software. (No talk, just attended.)
19:33:42 <cjs> He's got my card.
19:34:01 <sclv> we talked quite a bit.
19:34:16 <cjs> Oh, are you Jeff?
19:34:31 <sclv> no, the other guy -- I go by a nick online.
19:35:01 <yewT> hey guys, is there any function that is able to sort out alphabets? example ["ape","zebra","lion","piggy"] in ascending or descending order?
19:35:13 <cjs> "sort"? :-)
19:35:19 <sclv> ?hoogle sortBy
19:35:20 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
19:35:26 <cjs> >sort ["ape","zebra","lion","piggy"]
19:35:30 <sclv> ?hoogle comparing
19:35:30 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
19:35:30 <lambdabot> Distribution.Simple.Utils comparing :: Ord a => (b -> a) -> b -> b -> Ordering
19:35:36 <rwbarton> > sort ["ape","zebra","lion","piggy"]
19:35:37 <lambdabot>   ["ape","lion","piggy","zebra"]
19:36:04 <yewT> > reverse.sort ["ape","zebra","lion","piggy"]
19:36:05 <lambdabot>   Couldn't match expected type `a -> [a1]'
19:36:09 <yewT> > reverse $ sort ["ape","zebra","lion","piggy"]
19:36:11 <lambdabot>   ["zebra","piggy","lion","ape"]
19:36:28 <rwbarton> > sort (flip compare) ["ape","zebra","lion","piggy"]    -- better in some contexts
19:36:29 <lambdabot>   Couldn't match expected type `[a]'
19:36:38 <rwbarton> > sortBy (flip compare) ["ape","zebra","lion","piggy"]    -- better in some contexts
19:36:39 <lambdabot>   ["zebra","piggy","lion","ape"]
19:36:53 <yewT> rwbarton: better in some contexts?
19:37:13 <dblazakis> cjs: RSWF sounds pretty awesome
19:37:36 <rwbarton> if you only use the first element of the result, sortBy (flip compare) will be faster (I think)
19:38:00 <sclv> should always be faster. i think?
19:39:46 <cjs> RSWF is very cool. I'm very pleased with that project.
19:40:02 <cjs> Though of course if I re-wrote it, I'd do it in Haskell instead of Ruby next time. :-)
19:40:36 <dblazakis> cjs: i was gonna say it sounds like a natural fit (then I noticed it was Ruby and C)
19:40:45 <cjs> It's too bad we're not doing much Flash stuff any more.
19:41:25 <cjs> Well, it wouldn't be all that hard to rewrite in Haskell. But Ruby does lend some pretty nice internal DSL stuff to it.
19:51:36 <mib_i4x3ry3y> > 1+!
19:51:38 <lambdabot>   <no location info>: parse error on input `;'
19:51:51 <mib_i4x3ry3y> > 1+1
19:51:52 <lambdabot>   2
19:52:06 <yewT> > sort [9,8,7]
19:52:07 <lambdabot>   [7,8,9]
19:52:18 <yewT> > reverse $sort [9,8,7]
19:52:19 <lambdabot>   [9,8,7]
19:52:27 <yewT> > sort [ ["ape",9], ["zebra",8], ["lion",7], ["piggy",6]]
19:52:28 <lambdabot>       No instance for (Num [Char])
19:52:28 <lambdabot>        arising from the literal `9' at <in...
19:53:23 <yewT> anyon here?
19:53:41 <yewT> im unable to sort my sort [ ["ape",9], ["zebra",8], ["lion",7], ["piggy",6]]
19:54:11 <EvilTerran> yewT, that might be the type mismatch you've got there
19:54:14 <EvilTerran> ?type "ape"
19:54:15 <lambdabot> [Char]
19:54:16 <EvilTerran> ?type 9
19:54:18 <lambdabot> forall t. (Num t) => t
19:54:24 <EvilTerran> ?instances Num
19:54:25 <lambdabot> Double, Float, Int, Integer
19:54:27 <adu> yewT: are you Twey backwards?
19:54:28 <EvilTerran> no String
19:54:43 <EvilTerran> because Strings are not Numbers
19:54:59 <EvilTerran> which means you can't have strings and numbers in the same list like that
19:55:16 <EvilTerran> > ["ape",9] -- like so
19:55:17 <lambdabot>       No instance for (Num [Char])
19:55:17 <lambdabot>        arising from the literal `9' at <in...
19:55:34 <EvilTerran> > ("ape",9) -- yewT, but you can do this
19:55:35 <lambdabot>   ("ape",9)
19:56:01 * yewT ???  confused
19:56:07 <EvilTerran> it comes down to the types
19:56:12 <EvilTerran> ?type ("ape", True)
19:56:13 <lambdabot> ([Char], Bool)
19:56:35 <EvilTerran> (x,y) is a pair of elements; if (x :: a) and (y :: b), then (x,y) :: (a,b)
19:56:41 <yewT> ok
19:57:00 <EvilTerran> [x,y] is a list of elements; if (x :: a) and (y :: a) then [x,y] :: [a]
19:57:15 <EvilTerran> all elements in a list have to be the same type, but their number can vary at runtime
19:57:20 <yewT> so i was thinkig of converting those ape zebra lion piggy into number, and put them into a list, sort them out and later replace those numbers with ape ,lion, piggy, zebra, is this efficient/
19:57:29 <yewT> ?
19:57:34 <adu> yewT: try this:
19:57:38 <adu> > sortBy (compare `on` snd) [("ape",9), ("zebra",8), ("lion",7), ("piggy",6)]
19:57:39 <lambdabot>   [("piggy",6),("lion",7),("zebra",8),("ape",9)]
19:57:59 <EvilTerran> pairs (also triples (x,y,z) etc) are fixed length, but the types of the elements can be different
19:58:06 <adu> > sort [("ape",9), ("zebra",8), ("lion",7), ("piggy",6)]
19:58:07 <lambdabot>   [("ape",9),("lion",7),("piggy",6),("zebra",8)]
19:58:37 <rwbarton> yewT: what are you trying to do?
19:59:07 <yewT> adu the sort above , is it possible to just sort the numbers only
19:59:23 <adu> yewT: yup, thats the first one i did
19:59:49 <adu> > sort . map snd $ [("ape",9), ("zebra",8), ("lion",7), ("piggy",6)]
19:59:51 <lambdabot>   [6,7,8,9]
20:00:07 <BMeph> yewT: I don't know if "efficient," but it's so popular, it has its own Wikipedia entry... ;)
20:00:32 <yewT> bmpeh, could you link it to me? the wikipedia thingy
20:00:42 <BMeph> yewT: See http://en.wikipedia.org/wiki/Schwartzian_transform
20:00:43 <lambdabot> Title: Schwartzian transform - Wikipedia, the free encyclopedia
20:00:47 <yewT> thank you
20:00:48 * EvilTerran saw that coming
20:01:05 * BMeph thinks ET should've ducked, then! ;)
20:01:17 <BMeph> yewT: You're welcome. :)
20:01:26 <yewT> bmeph, is that perl or haskell?
20:01:34 <yewT> or perl = haskell?
20:01:49 <adu> yewT: no
20:02:03 <sjanssen> yewT: the technique comes from Perl, but it can be applied in any programming language
20:02:57 <ddarius> @where haskerl
20:02:57 <lambdabot> I know nothing about haskerl.
20:03:00 <BMeph> yewT: The idea came up from playing in perl, but it's used all over, even (dare I say especially) in Haskell. :)
20:03:00 <ddarius> Christ
20:03:03 <ddarius> @google Haskerl
20:03:06 <lambdabot> http://www.dcs.gla.ac.uk/~partain/haskerl.html
20:03:06 <lambdabot> Title: The Haskerl index
20:03:07 <harrison_partch> suppose i am running sidux and i want to compile yi from darcs and it says this: http://pastebin.com/m5cabeaec
20:03:16 <cads> ddarius, what is haskerl?
20:03:30 <rwbarton> I suspect people came up with the same idea in the 70s.
20:03:50 <yewT> is this [ [],[] ] same as [ () ,() ] ?
20:04:09 <BMeph> harrison_partch: Well, if it's saying something about pastebin, it's obviously broken... ;p
20:04:10 <sjanssen> yewT: no
20:04:32 <sjanssen> yewT: the first is a list of lists ([[a]]), the second is a list of ()s ([()])
20:05:15 <rwbarton> harrison_partch: You probably want to install cabal-install rather than deal with that manually
20:05:30 <yewT> what are these called? ()
20:05:36 <yewT> [] = list, () = ?
20:05:44 <harrison_partch> thank you rwbarton please go on
20:05:56 <BMeph> yewT: '()' is called 'unit'.
20:06:29 <harrison_partch> how do I install cabal-install? is there a debianized repo I can add to my apt sources?
20:06:32 <ddarius> cads: The link is right there.
20:06:41 <rwbarton> harrison_partch: Sadly, not yet
20:06:52 <harrison_partch> as far as I can tell I need cabal to be able to compile cabal
20:06:53 <rwbarton> harrison_partch: You have to install about four packages manually.
20:07:02 <dmwit__> There's a bootstrap.sh!
20:07:13 <harrison_partch> i am paying attention
20:07:14 <sjanssen> harrison_partch: Cabal is definitely available in Debian
20:07:14 <dmwit__> Unless you're on Windows, you shouldn't have to do anything manually! =)
20:07:57 <rwbarton> Debian includes a version of cabal which is recent enough to build current cabal, which is recent enough to build cabal-install. :)
20:08:01 <sjanssen> harrison_partch: under the name libghc6-cabal-dev
20:08:18 <adu> ew, Haskerl uses {} for do{}
20:08:52 <harrison_partch> http://pastebin.com/m6818132c  apt-cache does not show it
20:09:08 <bululu> BMeph: aren't '()' tuples?
20:09:32 <rwbarton> harrison_partch: It's probably included in ghc6 then.  Try ghc-pkg list, and see whether the output mentions Cabal
20:09:43 <sclv> ?remember haskerl http://www.dcs.gla.ac.uk/~partain/haskerl.html
20:09:44 <lambdabot> Done.
20:09:52 <sclv> ?where haskerl
20:09:53 <lambdabot> I know nothing about haskerl.
20:09:54 <dmwit__> bululu: You can think of () as a zero-tuple if you like.
20:09:58 <sclv> ?forget haskerl http://www.dcs.gla.ac.uk/~partain/haskerl.html
20:09:58 <lambdabot> Done.
20:10:04 <sclv> ?where+ haskerl http://www.dcs.gla.ac.uk/~partain/haskerl.html
20:10:04 <lambdabot> Good to know.
20:10:08 <sclv> ?where haskerl
20:10:09 <lambdabot> http://www.dcs.gla.ac.uk/~partain/haskerl.html
20:10:12 <sclv> there we go
20:10:21 <dmwit__> harrison_partch: I'm jumping in the middle, so forgive me if I ask something stupid that you've already answered.
20:10:31 <dmwit__> harrison_partch: What does "ghc-pkg list cabal" say?
20:10:37 <dblazakis> @where haskerl
20:10:37 <lambdabot> http://www.dcs.gla.ac.uk/~partain/haskerl.html
20:10:41 <harrison_partch>  Cabal-1.2.3 is in there
20:10:50 <adu> () :: Vec 0 a
20:10:57 <dmwit__> ?hackage cabal-install
20:10:57 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
20:11:19 <rwbarton> The dependencies on that page look really scary :)
20:11:24 <harrison_partch> cabal: command not found
20:11:34 <dmwit__> harrison_partch: cabal is not a command
20:11:45 <dmwit__> harrison_partch: (Unless you have installed cabal-install.)
20:11:51 <harrison_partch> that explains part of my confusion
20:12:02 <dmwit__> harrison_partch: I recommend you grab the tarball on that Hackage page and source bootstrap.sh in there.
20:12:13 <harrison_partch> k
20:12:44 <dmwit__> harrison_partch: (What is your actual goal?  Are you installing some other Haskell program?)
20:13:02 <yewT> bmpeh ok
20:14:03 <rwbarton> dmwit__: (it was installing yi)
20:14:08 <BMeph> dmwit__: Even on regular systems, you still have to type something... ;p
20:14:42 <harrison_partch> i want a development environment and I am going to use Haskell. I need tools.
20:15:09 <yewT>  [ ["ape",9], ["zebra",8], ["lion",7], ["piggy",6]]  for this list, i need to create 2 list and use zip to make them [ (,) , (,) ] ?
20:15:20 <adu> harrison_partch: Haskell is a great choice!
20:15:37 <dmwit__> BMeph: eh?
20:15:46 <adu> yewT: don't you listen? you have to replace ["...", #] with ("...", #)
20:15:58 <harrison_partch> Do I know haskell or ML? No. Am I a gifted programmer? yes I am. Have I coded the only realtime fractalvoxel raytracer? That I know of, yes.
20:16:14 <rwbarton> yewT: That "list" doesn't exist.
20:16:15 <yewT> umm  i dont understand
20:16:17 <bululu> yewT: you can't have lists with different types
20:16:28 <harrison_partch> so do not use runghc setup but something with boos\tstrap.sh?
20:16:43 <dmwit__> Yep, "source bootstrap.sh".
20:16:44 <adu> yewT: do you know the difference between a homogeneous-type-list and heterogeneous-type-list?
20:16:45 <harrison_partch> I have that tar unpacked.
20:16:49 <dmwit__> harrison_partch: Unless you're on Windows?
20:16:57 <yewT> adu no o_o
20:17:00 <harrison_partch> My God, no.
20:17:05 <dmwit__> Okay, good. =)
20:17:08 <EvilTerran> i doubt long words will help here, adu
20:17:14 <yewT> im trying to make [ [,] [,] [,] ] >> into [ (,) (,) ]
20:17:17 <adu> yewT: 1, 54, 32, 8, 7, 2, 34, 3, 711 -- this is homogeneous
20:17:17 <harrison_partch> Linux is too popculture for my tastes.
20:17:22 <Plareplane> the cabal that comes with ghc on debian is recent enough to build the newer cabal
20:17:53 <adu> yewT: 1, "Hello", 'x', True, SSLOn, Port 80 -- heterogeneous
20:17:57 <harrison_partch> that seems to be working thx
20:18:12 <EvilTerran> > sort [(5,"foo"),(3,"bar"),(4,"baz")]
20:18:13 <lambdabot>   [(3,"bar"),(4,"baz"),(5,"foo")]
20:18:18 <dmwit__> yewT: "Homogeneous" means "all the same" -- that is, each element, has the same type.  "Heterogeneous" means "different" -- that is, elements could have different types.  Haskell has only homogeneous lists.
20:18:29 <adu> yewT: thats because the types of those are: Int, String, Char, Bool, SSLThing, PortThing
20:18:36 <dcoutts> Plareplane: it's a myth that Cabal needs Cabal to build. It does not. It ignores any installed version of the Cabal lib and bootstraps using its own sources.
20:18:43 <adu> yewT: whereas the types of the first are Int, Int, Int, Int, Int, ...
20:18:43 <pastorn> where can i read about all the stuff that i can do with records?
20:18:53 <Plareplane> oh
20:18:54 <dmwit> pastorn: The Report is good.
20:18:57 <dmwit> ?where report
20:18:57 <lambdabot> http://www.haskell.org/onlinereport/
20:18:58 <harrison_partch> i wasted a couple of weeks on f# but i decided haskell is better. haskell used to be much slower than ocaml but apparently now it is faster.
20:19:00 <pastorn> like the new weird pattern matching stuff and more
20:19:25 <pastorn> or is that being held back until haskell' is ready?
20:19:26 <adu> yewT: Haskell only allows homogeneous lists, so you can't put strings and ints in the same list
20:19:47 <dmwit> pastorn: Oh, oh.  I didn't understand, sorry.
20:19:54 <adu> yewT: but tuples (x, y) are heterogeneous, so you can put things of different types in them
20:19:59 <rwbarton> pastorn: There's not a lot you can do with them in Haskell 98, you basically get accessor functions, record update syntax and record patterns.
20:20:10 <yewT> oh i see
20:20:40 <pastorn> rwbarton: i want to adress the contained values as constants
20:20:51 <pastorn> otherwise my code will look like shit
20:21:16 <rwbarton> I don't understand "address... as contents"
20:21:26 <rwbarton> *constants
20:21:34 <harrison_partch> anybody like to boot iso s of obscure os s ?
20:21:52 <EvilTerran> harrison_partch, only if they're written in Haskell. this is #haskell, after all.
20:22:08 <pastorn> rwbarton: say i have data Rec = R {f1 :: Int, f2 :: Int, f3 :: Int}
20:22:21 <pastorn> and then i have a function f :: Rec -> lol
20:22:39 <pastorn> i want to do this > f rec = f1 + f2
20:22:53 <adu> EvilTerran: and the words are not "long" ... they are "appropriate" :)
20:23:04 <EvilTerran> pastorn, incidentally, "data Rec = R { f1, f2, f3 :: Int }" would do the same as your data decl
20:23:05 <pastorn> not f rec = (f1 rec) + (f2 rec)
20:23:11 <yewT> tahnks for explaining
20:23:12 <harrison_partch> cabal successfully installed in /home/sr/.cabal/bin.
20:23:13 <rwbarton> pastorn: I see
20:23:22 <adu> yewT: np
20:23:24 <harrison_partch> so next step...?
20:23:49 <EvilTerran> pastorn, (e ->) monad?
20:23:54 <pastorn> and my datatype is quite... ...volatile, so i don't want to do pattern matching
20:24:03 <EvilTerran> f = (+) <$> f1 <*> f2
20:24:06 <pastorn> f (R x y z) = lol
20:24:13 <dmwit> harrison_partch: add ~/.cabal/bin to $PATH, then run "cabal install yi", I guess.
20:24:26 <yewT> how do i calculate the elements within a tuple? length(1,2) does not work, but length[1,2] works
20:24:29 <rwbarton> what about  f (R {f1=f1, f2=f2}) = f1+f2
20:24:49 <geezusfreeek_> yewT: i tuple always has statically known length
20:25:06 <pastorn> rwbarton: what would that do if i add more fields to my record?
20:25:20 <dmwit> pastorn: Try it. ;-)
20:25:24 <adu> yewT: well, you usually write your program with a known tuple length, like you say this is a tuple of type (String, Int) --in your case-- so you will always know that your tuple is of length 2
20:25:26 <geezusfreeek_> yewT: (x, y) has two elements, (x, y, z) has three, etc. and you can't just add more cells to them
20:25:27 <pastorn> true dat...
20:25:28 <yewT> statically known length? o_o
20:25:35 <adu> yewT: yes
20:25:44 <EvilTerran> pastorn, note that Foo{} is valid for all constructors Foo
20:25:53 <harrison_partch> added to PATH
20:25:54 <EvilTerran> even ones that don't use record syntax in their definition
20:26:09 <bululu> yewT: lists are dynamic, tuples are static
20:26:11 <EvilTerran> yewT, think of tuples as like the parameters of a C function, say
20:26:25 <yewT> oh , is it possible to create a function to determine how many elements in a tuple?
20:26:35 <EvilTerran> int main (int argc, char **argv) { ... }
20:26:39 <adu> harrison_partch: try installing my grep-like commandline tool :) just type "cabal install only"
20:26:41 <EvilTerran> main can only take two parameters
20:26:43 <geezusfreeek_> yewT: it would have to be overloaded
20:26:55 <bululu> yewT: yes, but only with pattern matching, overloading arguments
20:26:57 <yewT> geezusfreeek_ overloaded?
20:27:00 <geezusfreeek_> because tuples of different sizes have different types
20:27:03 <EvilTerran> we'd express that in haskell as main :: (Int, Ptr (Ptr Char)) -> IO Int
20:27:06 <EvilTerran> say
20:27:18 <EvilTerran> or indeed (Int, [String]) -> IO Int
20:27:48 <EvilTerran> yewT, do you actually need lists of variable length with elements of different types?
20:27:53 <harrison_partch> adu: i have to run cabal update first
20:27:55 <EvilTerran> you'd be amazed at how far you can get without them
20:28:02 <harrison_partch> but it is working!
20:28:07 <bululu> yewT: it would be something like: "size (_,_) = 2" then on the next line: "size (_,_,_) = 3", etc
20:28:09 <adu> yewT: don't worry, "overloaded" isn't as easy to explain as "homogeneous"
20:28:18 * Samy has a nice library going for FreeBSD ports
20:28:24 <EvilTerran> bululu, that's not valid, though; the types don't match
20:28:27 <geezusfreeek_> yewT: class TupleLength a where tupleLength :: Int; instance TupleLength (a, b) where tupleLength = 2; instance TupleLength (a, b, c) where tupleLength = 3
20:28:29 <geezusfreeek_> etc.
20:28:33 <Samy> Can parse, search, etc...INDEX.
20:28:48 <harrison_partch> adu: only installed
20:29:00 <dmwit> geezusfreeek_: You have to have tupleLength :: a -> Int
20:29:04 <yewT> wow, if there are (a,b,c,...z) thats a lot of tupleLength o_o
20:29:08 <geezusfreeek_> dmwit: ah yes
20:29:13 <bululu> EvilTerran: oh right, I forgot about that!
20:29:13 <adu> harrison_partch: I wrote only, so if you have any comments/suggestions, feel free to email
20:29:19 <EvilTerran> yewT, you don't generally need to ask how long a tuple is, anyway, seeing as you know when you write the code
20:29:19 <geezusfreeek_> yewT: that's one reason it's a bad idea
20:29:28 <geezusfreeek_> yewT: the other being that you just don't need it most of the time
20:29:39 <adu> harrison_partch: or catch me here i guess...
20:30:11 <harrison_partch> so ml type languages are taboo on this channel?
20:30:19 <EvilTerran> yewT, do you have an example of why you want variable-type variable-length lists?
20:30:24 <geezusfreeek_> harrison_partch: not taboo :P
20:30:25 <adu> harrison_partch: no, ml is like Haskell's grandma
20:30:28 <EvilTerran> harrison_partch, well, this *is* #haskell
20:30:37 <jeffz`> harrison_partch: irc generally has one topic per channel
20:30:37 <EvilTerran> but they're related, so we don't grumble too much
20:30:54 <geezusfreeek_> we look at ml respectfully like any other old geezer
20:31:18 <adu> geezusfreeek_: actually, grandma's are taboo
20:31:24 <pastorn> rwbarton: that worked quite nicely... but there's no way to make the record field functions to default to their fields value (writing "f rec" instead of "f (Rec {f1=f1,f2=f2...})")
20:31:29 <pastorn> ?
20:31:34 <yewT> EvilTerran umm nvm
20:31:35 <harrison_partch> john reppy at uchicago is working on "manticore": ml for heterogenous multicore processors
20:31:46 <yewT> EvilTerran geezusfreeek_ said it was a bad idea
20:31:50 <harrison_partch> but there isn't a release yet
20:31:59 <adu> harrison_partch: does that mean intel/ppc/mips/sparc?
20:32:06 <EvilTerran> pastorn, you can get something similar with -XRecordPunning or whatever it's called
20:32:10 <yewT> geezusfreeek_ said itss a bad idea
20:32:20 <hackage> Uploaded to hackage: WebBits 0.9.3
20:32:23 <harrison_partch> yes. i think they have it working on amd64
20:32:31 <harrison_partch> but there isn't a release yet
20:32:43 <pastorn> EvilTerran: ah, that's implemented? i saw it in the prime-webpage but assumed it wasn't in yet
20:32:52 <EvilTerran> pastorn, ah, NamedFieldPuns, that's the one
20:33:18 <harrison_partch> i like professor reppy. he was at bell labs working on ml for 11 years
20:33:25 <yewT> @src fst
20:33:26 <lambdabot> fst (x,_) =  x
20:33:44 <yewT> fst, snd, how about third, fourth fifth , sixth....?
20:33:50 <harrison_partch> ok, i must go grab some packages thx 10*1000
20:34:00 <jeffz`> yewT: you can write them if you need them
20:34:01 <EvilTerran> yewT, again, you don't really seem to need them in general
20:34:02 <pastorn> EvilTerran: where do you find this stuff?
20:34:25 <adu> yewT: well, then you have to come up with a naming scheme, like n1of3, n2of3 n3of3, n1of4, n2of4, etc...
20:34:28 <geezusfreeek> now THIS is a bad idea: http://hpaste.org/11130
20:34:48 <EvilTerran> pastorn, i discovered that one in particular by browsing through the haddock for Distribution.Extension
20:34:49 <EvilTerran> :P
20:35:15 <EvilTerran> looking for things with interesting-sounding names etcetc
20:35:16 <yewT> ok adu
20:35:23 <adu> yewT: ya, the heterogeneous support in Haskell is minimal... but then theres always the HList library if you want really strong heterogeneous lists
20:35:39 <rwbarton> But, you usually don't.
20:36:05 <adu> but also, HList is not for beginners
20:36:06 <EvilTerran> you almost never need them
20:36:11 <pastorn> so it's {GHC-Exts: -NamedFieldPuns} at the top of my module, right?
20:36:12 <EvilTerran> they're rarely worth the hassle
20:36:24 <EvilTerran> pastorn, {-# LANGUAGE NamedFieldPuns #-}
20:36:32 <pastorn> thanks
20:36:39 <EvilTerran> pragmas are always {-# SHOUTY_NAME ... #-}
20:37:26 <adu> yewT: in that naming scheme, fst = n1of2 and snd = n2of2
20:37:29 <yewT> just wandering, why there are so many zip? zip2, zip3, zip4... zip7?
20:37:36 <geezusfreeek> {-# I_DONT_KNOW_WHY_WE_ARE_YELLING ... #-}
20:37:50 <geezusfreeek> :t zip
20:37:51 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
20:37:52 <adu> yewT: because of how tuples are so wierd
20:37:53 <geezusfreeek> :t zip2
20:37:55 <lambdabot> Not in scope: `zip2'
20:37:56 <EvilTerran> yewT, because haskell didn't do tuples right, basically
20:37:59 <geezusfreeek> :t zip3
20:38:01 <lambdabot> forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
20:38:02 <pastorn> awww
20:38:07 <pastorn> "unsupported extension: NamedFieldPuns"
20:38:13 <noZone> Given the diligence it takes to learn Haskell, it's ironic that it's a lazy language.
20:38:15 <adu> yewT: you can't abstract tuples like lists, you can't say "a tuple of any length"
20:38:21 <EvilTerran> pastorn, ah, you must be on an older ghc; try RecordPuns, then
20:38:42 * pastorn is using 6.8.2
20:38:47 <adu> yewT: you can only say a 2-tuple, 3-tuple, 4-tuple, etc, its impossible to say n-tuple
20:38:51 <rwbarton> ghc --supported-languages | grep Puns
20:38:52 <EvilTerran> i was looking at the docs on haskell.org...
20:38:55 <rwbarton> RecordPuns on 6.8.2
20:39:36 <adu> I personally think tuples should have been linked, like lists
20:39:45 <EvilTerran> i agree
20:40:11 <EvilTerran> data a :*: b = a :*: !b deriving (Eq, Ord, Read, Show) or whatever
20:40:12 <adu> so (a, b, c) = (a :#$: (b :#$: (c :#$: ()))) where (:#$:) is some nicer constructor
20:40:49 <geezusfreeek> i vote for that constructor being (,)
20:40:51 <adu> maybe even :::
20:40:51 <geezusfreeek> :)
20:40:52 <EvilTerran> just like that, yeah; make tuple syntax just sugar for cons-strict pairs and ()
20:41:23 <yewT> hmm ["a","c","z"] vs [ ["z",1] , ["a",2] , ["c",3]] pattern matching >>> [ ["a",2] , ["c",3] , ["z",1]] possible?
20:41:26 <EvilTerran> geezusfreeek, but then you'd have to write (x,y,z) as (x,y,z,())
20:41:42 <EvilTerran> yewT, goddamnit, those lists ["z",1] etc aren't valid
20:41:45 <rwbarton> No, because [ ["z",1] , ["a",2] , ["c",3]] does not exist in Haskell :P
20:41:58 <adu> yewT: pattern matching like that is possible, but (again), you must use ("z",1)
20:42:07 <EvilTerran> geezusfreeek, i'd call it something else, and reserve the comma for syntactic sugar for the constructor
20:42:19 <geezusfreeek> EvilTerran: yeah that seems reasonable
20:42:26 <EvilTerran> so all the old behaviour can continue as if nothing changed
20:42:36 <EvilTerran> i think it would even be a (mostly) backwards-compatible modification
20:42:37 <yewT> is pattern matching same as "
20:42:43 <yewT> "a" == "a"
20:42:49 <dmwit> It would certainly make instances nicer.
20:42:51 <yewT> or something else
20:43:07 <geezusfreeek> then again, just saying x, y, z, () only more non-whitespace character than (x, y, z)
20:43:08 <EvilTerran> you might need FlexibleInstances with it for any existing tuple instances to not break
20:43:20 <EvilTerran> geezusfreeek, yeah, but it looks weird... :P
20:43:21 <dmwit> Since you could declare, e.g. instance (Show a, Show b) => Show (a,b) and get a show instance for arbitrarily long tuples.
20:43:29 <geezusfreeek> EvilTerran: ;)
20:43:38 <adu> but if Haskell had linked tuples I would have no reason to write a new language...
20:43:47 <adu> I would just use Haskell
20:43:47 <EvilTerran> dmwit, indeed, although you may want to tweak it so they appear as n-tuples rather than nested pairs
20:43:58 <rwbarton> adu: Haskell has linked tuples, it just also has these other tuples written (1,2,3)
20:44:01 <EvilTerran> not sure how you'd do that, but i imagine it's possible somehow
20:44:07 <dmwit> EvilTerran: (I meant internally.)
20:44:23 <dmwit> EvilTerran: (Instead of listing, by hand, all the instances for tuples of size up to 63, and then calling it a day.)
20:44:32 <EvilTerran> ah, i see
20:44:58 <adu> ya with the underlying constructor, at least (x, (y, z)) /= (x, y, z) as now
20:45:16 <EvilTerran> still, you couldn't just do it naively without the output for (1,2,3) being "(1 :*: 2 :*: 3 :*: ())"
20:45:50 <rwbarton> What can you do with    class Tuple a b c | a -> b c where encode :: (b, c) -> a; decode :: a -> (b, c);  instance Tuple (x,y) x y where ...; instance Tuple (x,y,z) x (y,z) where ...; ...
20:46:40 <adu> rwbarton: thats brilliant
20:47:04 <rwbarton> then you just need ghc to autoderive that class.  Of course, the strictness is probably wrong
20:48:22 <adu> dmwit: well, not if (a, b) == (a ::: b ::: ())
20:48:52 <dmwit> Okay, I admit that it would take a little thought, and probably break a good deal of existing programs.
20:48:57 <dolio> Make it a GADT, clearly.
20:49:11 <dmwit> But I thought the whole point of Haskell was for academics to have a language to experiment with.
20:49:26 <harrison_partch> Is there a coder here who has used opengl graphics with haskell?
20:49:32 <dmwit> "Avoid popularity at all costs," and all that. ;-)
20:49:36 <adu> dmwit: change stuff and see what breaks? lol interesting experiement
20:49:42 <dmwit> harrison_partch: You should maybe just ask your question.
20:49:48 <harrison_partch> hey, i am not popular!
20:50:05 <adu> yey harrison_partch  will be our spokes ppl
20:50:22 <harrison_partch> k. There is glut, and then there is glfw, which looks better.
20:50:25 <yewT> bye gusy
20:50:28 <yewT> bye guys*
20:50:42 <harrison_partch> but glut comes with actual demo code and glfw seems not to.
20:50:51 <adu> harrison_partch: I've use Haskell + GLUT + OpenGL before
20:51:02 <adu> need help?
20:51:16 <pastorn> i can't get it to work :/
20:51:18 <pastorn> @paste
20:51:19 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:51:43 <harrison_partch> no. i read that glfw is better than glut. q: are there any demos of this library?
20:52:00 <jeffz`> harrison_partch: http://haskell.org/haskellwiki/GLFW
20:52:11 <lambdabot> Title: GLFW - HaskellWiki
20:52:38 <harrison_partch> I have seen it and installed from there.
20:52:46 <harrison_partch> It comes with no demos.
20:52:57 <jeffz`> harrison_partch: you missed the examples then
20:53:49 <harrison_partch> you mean the code on that page? guess that'll have to do far starters. k.
20:53:58 <harrison_partch> far/for
20:54:03 <jeffz`> well, if there's something wrong with it, please tell us
20:55:02 <mml`> anybody know if galois hires telecommuters?
20:56:00 <dmwit> So what makes GLFW better than GLUT?
20:56:06 <pastorn> http://hpaste.org/11131
20:56:43 <jeffz`> harrison_partch: between that example and the documentation for GLFW and HOpenGL you should be pretty much set... bits of code can be borrowed from the glut examples too. http://hackage.haskell.org/packages/archive/GLFW/0.3/doc/html/Graphics-UI-GLFW.html
20:56:49 <lambdabot> Title: Graphics.UI.GLFW, http://tinyurl.com/3rt9gh
20:58:06 <dmwit> pastorn: needs more {}
20:58:06 <pastorn> EvilTerran, dmwit, rwbarton: could any of you please take a quick peek at my paste? http://hpaste.org/11131
20:58:15 <dmwit> pastorn: Here, I'll annotate.
20:58:20 <pastorn> dmwit: thanks :)
20:58:30 <dmwit> ewww tabs
20:58:33 <dmwit> pastorn: stop that
20:58:50 <pastorn> what? where?
20:58:50 <rwbarton> pastorn: You could use sequence in the ((->) PrintingSet) monad easily enough
20:59:12 <harrison_partch> http://www.youtube.com/watch?v=MKMsbU1ovv8
20:59:12 <lambdabot> Title: YouTube - abraxas
20:59:24 <harrison_partch> it's less than 30 seconds
20:59:37 <pastorn> rwbarton: that probably requires me to be able to understand what i was using, something i'm not :)
20:59:45 <pastorn> (the (->) e monad
20:59:57 <dmwit> pastorn: There are tabs all over the code you pasted.  If you're using vim, it's probably because you have :set noexpandtab, which you can fix by setting (surprise!) expandtab, then hitting :retab.
21:00:20 <pastorn> dmwit: but i like tabs!
21:00:31 <pastorn> okok, just for you then
21:00:36 <dmwit> ewww
21:00:40 <pastorn> haha
21:00:41 <dmwit> Anyway, I annotated.
21:01:07 <pastorn> dmwit: seriously? i have to name them all?
21:01:12 <dmwit> yup
21:01:23 <pastorn> awww, man
21:01:33 <dmwit> pastorn: Is this the only value of this type you'll be making?
21:01:46 <dmwit> If so, why not just let those be *actual* values rather than wrapping them in a data type? ;-)
21:02:05 <rwbarton> I assume there will be dosSet, ibmGraphicsSet, ...
21:02:20 <rwbarton> pastorn: see http://hpaste.org/11131#a2 for the monadic solution
21:02:35 <dmwit> Yeah, (e ->) is probably the way to go.
21:02:44 <shapr> I like tabs... guitar tabs.
21:02:49 <pastorn> rwbarton: nah, just utfSet and asciiSet
21:03:08 <dmwit> Surely those aren't in ASCII.
21:03:24 <rwbarton> dmwit: Ever played nethack? :)
21:03:40 <dmwit> nethack uses significantly more than just ASCII.
21:03:48 <rwbarton> It has an ASCII-only mode too.
21:04:09 * dmwit notes that ASCII only covers characters 0..127
21:04:16 <rwbarton> Right, it just uses | and -
21:04:32 <rwbarton> ---
21:04:32 <rwbarton> | |
21:04:33 <rwbarton> ---
21:04:38 <dmwit> Ah, I thought you were trying to tell me those box-drawing characters in his paste were in ASCII. =P
21:04:41 <pastorn> dmwit: what do you mean by "the only value"?
21:04:44 <dolio> http://hpaste.org/11132 -- inductive tuples
21:04:57 <pastorn> oh, i understod by just reading it again...
21:05:00 <pastorn> nevermind...
21:05:11 <dolio> Oops, that's got some irrelevant stuff in it.
21:05:41 <pastorn> +-+-+
21:05:41 <pastorn> | | |
21:05:41 <pastorn> +-+-+
21:06:16 <pastorn> so there's nothing i can do to make my paste work?
21:06:26 <rwbarton> pastorn: you could use modules...
21:06:29 <pastorn> as in, the way that i wrote "box"
21:06:31 <rwbarton> pastorn: if it's a compile-time option
21:06:55 * pastorn just came up with something
21:06:57 * dmwit doesn't see what's so bad about sequence
21:07:10 <pastorn> map ($charSet) (charFuns)
21:07:31 <dmwit> That's exactly what sequence was made for.
21:07:31 <rwbarton> That's equivalent to sequence.
21:07:47 <dmwit> sequence = map . flip ($)
21:07:48 <harrison_partch> hipmunk looks really cool. i saw some vids with it.
21:07:55 <dmwit> harrison_partch: ayup
21:08:11 <dmwit> harrison_partch: Are you gonna build something with it? =)
21:08:31 <harrison_partch> no, that's 2d. i am doing 3d stuff
21:08:45 <harrison_partch> easy to get distracted by this stuff
21:09:21 <harrison_partch> but i know what i am going to do. i was a ltittle stuck tonight and you fellows helped be get unstuck.
21:10:07 <harrison_partch> dmwit: have you seen: second life, croquet, etc?
21:10:19 <rwbarton> It'd be neat if lambdabot could prove little facts like "sequence x y = map ($ y) x"
21:10:20 <harrison_partch> that's the sort of thing
21:11:04 <dmwit> ?free sequence
21:11:05 <lambdabot> Expected variable or '.'
21:11:08 <pastorn> rwbarton: simple reflect + (==) ?
21:11:13 <dmwit> :t sequence
21:11:14 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
21:11:21 <harrison_partch> but based on a hybrid renderer. tracing for visibility culling, then polys.
21:11:25 <dmwit> ?free sequence :: [e -> a] -> e -> [a]
21:11:25 <lambdabot> (forall h. (forall k p. g . k = p . f                        =>                         h k = p)           =>            $map h xs = ys) => $map g . sequence xs = sequence ys . f
21:11:27 <Cale> It can prove them for specific lengths of list
21:11:29 <sjanssen> @pl map ($ f) xs
21:11:29 <lambdabot> map ($ f) xs
21:11:36 <sjanssen>  @pl isn't quite that smart
21:11:45 <dmwit> ?pl \f xs -> map ($ f) xs
21:11:45 <lambdabot> map . flip id
21:11:52 <yewT> hmm guys does haskell use wildcards?
21:11:54 <scott_> I need a little help. I'm trying to compile the "Automata for Haskell" program, which uses Edison.
21:12:06 <scott_> I used cabal to install EdisonAPI and EdisonCore
21:12:07 <pastorn> yewT: you can ignore input to functions with _
21:12:08 <rwbarton> @src sequence
21:12:09 <lambdabot> sequence []     = return []
21:12:09 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
21:12:09 <lambdabot> --OR
21:12:09 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
21:12:12 <dobblego> yewT, look up existential types
21:12:18 <dmwit> yewT: That question is even more ambiguous than usual.
21:12:23 <scott_> but when I try to compile, it can't find the modules, any ideas?
21:12:23 <pastorn> yewT: f 1 = 10; f _ = 100
21:12:38 <yewT> pastorn how does that work?
21:12:50 <rwbarton> scott_: what's the exact module name it says it can't find?
21:12:59 <dobblego> yewT, do you intend wildcards in that a type argument is not yet specified?
21:13:00 <harrison_partch> we ain't got no ma or pa, cause we is auto - ma - ta ...
21:13:03 <pastorn> yewT: if you give 1 to f you get 10 everithing else you give to f will give you 100
21:13:13 <scott_> UnorderedSet, or Assoc sometimes (depending on what I've tried)
21:13:17 <pastorn> yewT: you can even call it with (f undefined)
21:13:34 <pastorn> > let f _ = 1 in f undefined
21:13:35 <lambdabot>   1
21:14:03 <Samy> > let f _ = f undefined in f undefined
21:14:16 <pastorn> > let f x = 1 in f undefined
21:14:18 <lambdabot>   1
21:14:18 <lambdabot>   thread killed
21:14:19 <yewT> im thinking of diong this %x ["box","zebra","xylophon","lolx"] >> ["box","lolx"]
21:14:20 <harrison_partch> wow, there is hCsound!
21:14:25 <pastorn> > let f x = 1 in f undefined
21:14:27 <lambdabot>   1
21:14:27 <rwbarton> Just 'Assoc', not 'Data.Edison.Assoc'?
21:14:34 <rwbarton> scott_: ^^
21:14:56 <scott_> :rwbarton Yes, do I maybe need to add that wherever the import in the source is?
21:14:58 <pastorn> yewT: check out the functions filter and elem
21:15:08 <yewT> ok pastorn
21:15:09 <pastorn> yewT: haskell.org/hoogle
21:15:14 <rwbarton> scott_: Yeah, sounds like the source is written against a pre-hierarchical libraries version of Edison
21:15:17 <scott_> :rwbarton the instructions on the page say to use -package data, but that doesn't find anything
21:15:28 <rwbarton> s/libraries/modules/
21:15:42 <rwbarton> scott_: Yeah, that won't help.  The import lines have to change
21:15:46 <Samy> > filter (/= 't') "punt"
21:15:48 <lambdabot>   "pun"
21:15:51 <scott_> :rwbarton thanks alot
21:15:55 <scott_> rwbarton++
21:15:57 <Samy> > elem 'a' "Batman"
21:15:59 <lambdabot>   True
21:16:38 <rwbarton> (I guess there could be some voodoo ghc option that makes these changes unnecessary, but I doubt it)
21:18:37 <pastorn> yewT: you figure it out?
21:18:54 <yewT> no o_o
21:20:25 <yewT> filter is to remove , and elem checks whether its true/false
21:21:10 <Samy> no
21:21:14 <Samy> :t filter
21:21:16 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
21:21:24 <Samy> filter (== 'F') "Frog"
21:21:31 <Samy> > filter (== 'F') "Frog"
21:21:33 <lambdabot>   "F"
21:21:44 <Samy> > filter (> 3) [1 .. 6]
21:21:46 <lambdabot>   [4,5,6]
21:22:21 <pastorn> yewT: just try out elem until you figure it out
21:22:38 <yewT> pastorn  elem with filter or just elem?
21:22:46 <pastorn> just elem
21:22:59 <pastorn> write a function hasX :: String -> Bool
21:23:00 <Samy> :t elem
21:23:01 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
21:23:14 <pastorn> yewT: could prove useful :)
21:23:27 <Samy> seems ugly for substring search though
21:23:49 <Samy> hasX ah
21:23:54 <yewT> whats the purpose of hasX?
21:24:02 <yewT> grab a string and produce a boolean?
21:24:09 <pastorn> yup
21:24:20 <yewT> does it not need to grab 2 , so it could do comparison, and produce boolean?
21:24:25 <pastorn> rather, given a string, does it contain 'x'?
21:24:59 <pastorn> yewT: define hasX in terms of elem
21:25:34 <dolio> EvilTerran: http://hpaste.org/11132#a2
21:27:18 <yewT> pastorn http://hpaste.org/11134
21:27:52 <yewT> pastorn, is that what you wanted?
21:29:06 <yewT> > 1+!
21:29:06 <yewT> > 1+1
21:29:08 <lambdabot>   2
21:29:08 <lambdabot>   <no location info>: parse error on input `;'
21:29:17 <dmwit> yewT: Yup, that looks right. =)
21:30:20 <yewT> so whats next pastorn?
21:31:39 <pastorn> right
21:31:49 <rwbarton> dolio: What's the advantage of the GADT over data a ::: b = a ::: !b?
21:31:51 <pastorn> now go play with filter :)
21:32:15 <pastorn> @type filter
21:32:16 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
21:32:41 <dolio> He was lamenting that showing that would end up like "foo ::: bar ::: baz ::: ()" or something of the sort.
21:33:19 <dolio> Or (foo, (bar, (baz, ())))
21:34:38 <dolio> A GADT tuple makes sure you only construct inductive tuples, and the GADT proof lets you show them like ordinary tuples.
21:36:40 <pastorn> yewT: getting somewhere?
21:40:16 <yewT> pastorn http://hpaste.org/11134#a1
21:40:53 <pastorn> @define hasX xs = 'x' `elem` xs
21:41:12 <pastorn> @command
21:41:12 <lambdabot> Unknown command, try @list
21:41:17 <pastorn> @list
21:41:17 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
21:42:22 <pastorn> > let hasX xs = 'x' `elem` xs in filter hasX (words "abc xyz lol x1 x2 y3")
21:42:23 <lambdabot>   ["xyz","x1","x2"]
21:48:13 <yewT> pastorn?
21:48:27 <yewT> is that all or you are writing something extra?
21:50:01 <dobblego> http://hpaste.org/11135
21:50:16 <dobblego> Can the type-annotation be removed?
21:50:18 <dmwit> no
21:50:28 <dobblego> ok thanks
21:51:34 <Cale> dobblego: You could turn on ExtendedDefaultRules
21:51:39 <Cale> dobblego: I think that might solve it
21:51:52 <dobblego> Cale, it has to fit on a slide; I might leave it as is
21:52:23 <yewT> cale/doblego, how do i use the function i made above with wildcards?
21:52:37 <dobblego> yewT, what do you mean by wildcard?
21:52:47 <yewT> i'll give you an example..
21:52:59 <pastorn> yewT: where what?
21:53:00 <dobblego> are you using Java Generics term "wildcard"?
21:53:11 <yewT> %x ["box","zebra","xylophon","lolx"] >> ["box","lolx"]
21:53:26 <dobblego> yewT, you want the filter function
21:53:26 <Cale> zuh?
21:53:28 <yewT> %means wildcard + x
21:53:40 <pastorn> yewT: where can the x be in that? only last or anywhere but first?
21:53:46 <dmwit> wow
21:53:47 <Cale> filter ('x' `elem`) ["box","zebra","xylophon","lolx"]
21:53:53 <dobblego> yewT, % is written "elem" in Haskell
21:53:53 <dmwit> I think he's talking about *SQL* wildcards.
21:53:57 <Cale> > filter ('x' `elem`) ["box","zebra","xylophon","lolx"]
21:53:58 <lambdabot>   ["box","xylophon","lolx"]
21:54:07 <Cale> or:
21:54:08 <dmwit> dobblego: This is different.
21:54:08 <yewT> dmwit got that right :)
21:54:12 <Cale> > filter (elem 'x') ["box","zebra","xylophon","lolx"]
21:54:13 <lambdabot>   ["box","xylophon","lolx"]
21:54:29 <dmwit> yewT: You can use regexen for the same (but better!) effect in Haskell.
21:54:32 <pastorn> > filter (elem 'x' . tail) ["box","zebra","xylophon","lolx"]
21:54:34 <lambdabot>   ["box","lolx"]
21:54:37 <Cale> or you want only the ones ending in x?
21:54:49 <Cale> > filter (isSuffixOf "x") ["box","zebra","xylophon","lolx"]
21:54:50 <lambdabot>   ["box","lolx"]
21:54:56 <pastorn> > filter (elem 'x' . last) ["box","zebra","xylophon","lolx"]
21:54:57 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
21:54:57 <dmwit> He wants those strings matching "x$".
21:55:02 <pastorn> awww
21:55:07 <pastorn> @type last
21:55:08 <lambdabot> forall a. [a] -> a
21:55:17 <Cale> yeah, then isSuffixOf is probably the nicest way
21:55:22 <yewT> i want it to be flexible like it could be %x or %x% or x%
21:55:26 <Cale> (and generalises to more than one character)
21:55:26 <pastorn> > filter ((/ 'x' . last) ["box","zebra","xylophon","lolx"]
21:55:27 <lambdabot>   <no location info>: parse error on input `;'
21:55:38 <pastorn> > filter ((== 'x') . last) ["box","zebra","xylophon","lolx"]
21:55:39 <lambdabot>   ["box","lolx"]
21:55:41 <Cale> isPrefixOf, isInfixOf, isSuffixOf
21:55:57 <Cale> > filter (isInfixOf "lo") ["box","zebra","xylophon","lolx"]
21:55:58 <pastorn> yewT: regexp
21:55:58 <lambdabot>   ["xylophon","lolx"]
21:56:17 <Cale> Or yeah, you could use a regular expression library
21:56:31 <pjdelport> Cale: why doesn't ghci give the ambiguous type variable error?
21:57:05 <Cale> pjdelport: ExtendedDefaultRules
21:57:06 <yewT> thanks guys :)
21:57:18 <Cale> > filter (=~ "x$") ["box","zebra","xylophon","lolx"]
21:57:19 <lambdabot>   Not in scope: `=~'
21:57:22 <Cale> aww
21:57:41 <pjdelport> Cale: so that defaults to on in ghci but off in ghc?
21:58:10 <Cale> pjdelport: yeah
21:58:13 <yewT> btw someone mentioned % is elem?
21:58:29 <Cale> yewT: That was when we didn't understand what you meant by %
21:58:41 <Cale> elem is a function for testing if something is an element of a list
21:58:58 <Cale> > 'x' `elem` "xylophone"
21:58:59 <lambdabot>   True
21:59:03 <Cale> > 'x' `elem` "box"
21:59:04 <lambdabot>   True
21:59:08 <Cale> > 'x' `elem` "zebra"
21:59:10 <lambdabot>   False
21:59:44 * Cale goes to add Text.Regex.Posix to the imports :)
22:00:54 <Cale> > filter (=~ "x$") ["box","zebra","xylophon","lolx"]
22:00:56 <lambdabot>   ["box","lolx"]
22:00:59 <Cale> :)
22:01:10 <Cale> > filter (=~ "lop") ["box","zebra","xylophon","lolx"]
22:01:11 <lambdabot>   ["xylophon"]
22:01:12 <pastorn> > 2 `elem` [1..10]
22:01:13 <lambdabot>   True
22:01:16 <pastorn> > 20 `elem` [1..10]
22:01:17 <lambdabot>   False
22:01:56 <Cale> > map (=~ "o") ["box","zebra","xylophon","lolx"] :: [Int]
22:01:58 <lambdabot>   [1,0,2,1]
22:02:33 <yewT> cale, my compiler does not recognize =~
22:02:53 <yewT> do i need to :load any specific stuff?
22:03:02 <Cale> yewT: It's in the Text.Regex.Posix library
22:03:10 <Cale> In the package  regex-posix
22:03:17 <Cale> that you can get from hackage if you don't have it
22:03:21 * luqui really likes perl's contextual overloading.  He does not like haskell's contextual overloading.
22:03:26 <luqui> not because haskell does it worse
22:03:32 <yewT> hackage is similar ghci?
22:03:37 <Cale> But because Haskell does it better? ;)
22:03:38 <luqui> but because it doesn't feel like you should do that in haskell
22:03:51 <Cale> It's just typeclasses, man :)
22:03:52 <Cale> hehe
22:04:05 <ivanm> is there a way of working out what's causing a stack overflow in my code?
22:04:09 <luqui> yeah, but it's notational stuff.
22:04:11 <Cale> yewT: Hackage is similar to cpan, if you know perl.
22:04:22 <dmwit> ivanm: Maybe run it with profiling?
22:04:39 <luqui> I haven't yet found a language that can cleanly separate meaning and notation
22:04:39 <dmwit> ivanm: Or Debug.Trace.trace all your functions. ;-)
22:04:46 <ivanm> dmwit: yeah, except that it isn't at the app stage yet, just running it in ghci
22:04:58 <Cale> ivanm: Look for functions with accumulating parameters and check that they're getting forced on each iteration.
22:05:02 <ivanm> dmwit: heh, yes, but that could get very messy very fast...
22:05:16 <ivanm> Cale: I don't think any of mine are accumulating :s
22:05:27 <Cale> Or in general for expressions that are getting produced which are very deep
22:05:30 <dmwit> ivanm: Call the smallest function.  If it works, call a slightly larger function.  Repeat until you find the overflow. ;-)
22:05:34 <Cale> > foldr (+) 0 [1..1000000]
22:05:36 <lambdabot>   * Exception: stack overflow
22:05:41 <Cale> Like that.
22:05:44 <Cale> > foldl (+) 0 [1..1000000]
22:05:45 <ivanm> I've got an array (Int,Int), and I'm basically taking a location in the array, changing it, and then repeating
22:05:47 <lambdabot>   * Exception: stack overflow
22:05:49 <Cale> > foldl' (+) 0 [1..1000000]
22:05:51 <lambdabot>   500000500000
22:05:53 <dmwit> ivanm: oooo
22:05:55 <ivanm> and doing that quite a few number of times
22:06:06 <dmwit> ivanm: Did you know that Arrays are lazy? O_o
22:06:19 <ivanm> s/array/UArray
22:06:21 <Cale> ivanm: Okay, make absolutely sure that you force the evaluation of the element you're sticking in the array.
22:06:24 <dmwit> ivanm: Maybe you should take a look at one of the mutable arrays: STArray, IOArray, etc.
22:06:34 <Cale> ivanm: Wait, you have a UArray of pairs?
22:06:39 <ivanm> and I've got it listed as !UArray in my record data structure
22:06:39 <Cale> ivanm: How'd you manage that?
22:06:47 <ivanm> Cale: the indices are pairs ;)
22:06:51 <Cale> ivanm: aha
22:06:55 <yewT> factorial a | a > 0 = a*factorial(a-1) >> what does the guard do in that function?
22:07:11 <Cale> ivanm: So maybe the whole array is somehow avoiding being forced?
22:07:21 <ivanm> yeah, that's what I'm afraid of :s
22:07:27 <luqui> yewT, it's another way to write "if a > 0" (else try the other patterns)
22:07:57 <ivanm> but my record type has a !UArray (Int,Int) Int (actually, it has !Lattice, where Lattice is a type alias)
22:08:05 <Cale> okay
22:08:12 <sjanssen> ivanm: perhaps the record isn't being forced?
22:08:16 <Cale> So you just have to check that your record is being forced ;)
22:08:21 <ivanm> hmmmmm..... didn't think about that...
22:08:24 <ivanm> seq it?
22:08:26 <Cale> Is anything pattern matching against it?
22:08:29 <dmwit> luqui: Aw, you just answered the question most likely to be a homework question that we've seen all night... =P
22:08:35 <Cale> Yeah, use a bang pattern, or seq it.
22:08:40 <vininim> heh
22:08:43 <luqui> dmwit, oops =P
22:09:08 <luqui> though what kind of homework question is that?
22:09:09 <Cale> and when deciding where to place the seq, remember the identity  x `seq` x = x  ;)
22:09:23 <dmwit> luqui: One testing if you know what "guard" means.
22:09:32 <luqui> ohhh
22:09:32 <Cale> The seq should go just before your recursive call, if there is one.
22:09:45 <ivanm> Cale: yeah, seq doesn't seem to be doing anything :s
22:10:02 <luqui> dmwit, yeah I did actually find it a bit odd, after I answered, that he used the word guard and yet was asking what it does :-)
22:10:10 <Cale> ivanm: Expressions are evaluated outermost first
22:10:34 <Cale> ivanm: and evaluating  seq x y  causes x to be evaluated (up to determining the top level constructor) before resulting in y
22:11:15 <Cale> So if you have something like:
22:11:21 <ivanm> duh, I was seq`ing the wrong variable :s
22:11:22 <lispy> ?users
22:11:22 <lambdabot> Maximum users seen in #haskell: 518, currently: 451 (87.1%), active: 15 (3.3%)
22:11:27 <Cale> ah
22:11:34 <Cale> Everything is good now?
22:11:58 <ivanm> yup, looks like it is! \o/
22:12:03 <ivanm> thanks Cale, dmwit, sjanssen
22:12:27 <Cale> > map (=~ "o") ["box","zebra","xylophon","lolx"] :: [(String, String, String)]
22:12:29 <lambdabot>   [("b","o","x"),("zebra","",""),("xyl","o","phon"),("l","o","lx")]
22:13:14 <dmwit> > map (=~ "o") ["box", "zebra", "xylophon", "lolx"] :: [(String, String, String, String)]
22:13:15 <lambdabot>       No instance for (Text.Regex.Base.RegexLike.RegexContext
22:13:15 <lambdabot>                ...
22:13:25 <luqui> > map (=~ "o") ["box", "zebra", "xylophon", "lolx"] :: [Maybe String]
22:13:26 <lambdabot>       No instance for (Text.Regex.Base.RegexLike.RegexContext
22:13:26 <lambdabot>                ...
22:13:32 <Cale> :t map (=~ "o") ["box","zebra","xylophon","lolx"]
22:13:33 <lambdabot> Not in scope: `=~'
22:13:34 <luqui> aww come on, DWIM!
22:13:38 <Cale> oh, right
22:13:42 <Cale> hmm
22:13:50 <Cale> Have to add that to L.hs
22:14:02 <dmwit> luqui: Try [[String]]?
22:14:09 <dmwit> > map (=~ "o") ["box", "zebra", "xylophon", "lolx"] :: [[String]]
22:14:11 <lambdabot>   [["o"],[],["o","o"],["o"]]
22:14:22 <dmwit> err... not quite, heh
22:14:25 <Cale> @undefine
22:14:34 <Cale> :t map (=~ "o") ["box","zebra","xylophon","lolx"]
22:14:35 <lambdabot> forall target. (Text.Regex.Base.RegexLike.RegexContext Regex [Char] target) => [target]
22:14:37 <luqui> nah, that's about right.
22:14:38 <Cale> ehehe
22:15:46 <dmwit> Ah, I thought I remembered one with a 4-tuple!
22:15:49 <Cale> > map (=~ "b.*") ["box","zebra","xylophon","lolx"] :: [[String]]
22:15:50 <lambdabot>   [["box"],["bra"],[],[]]
22:15:51 <dmwit> > map (=~ "o") ["box", "zebra", "xylophon", "lolx"] :: [(String, String, String, [String])]
22:15:53 <lambdabot>   [("b","o","x",[]),("zebra","","",[]),("xyl","o","phon",[]),("l","o","lx",[])]
22:15:57 * luqui is struck by the fact that if the arguments were reversed to (=~), then it could do lazy compilation of the regex
22:16:21 <Cale> yeah, I got the order the wrong way around for that reason too
22:16:21 <dmwit> luqui: What stops it from doing lazy compilation as it is?
22:16:28 <Cale> I expected the regex to be the first parameter
22:17:00 <luqui> dmwit, well it could, but I don't believe the compilation would be shared for all elements of that list, because of the flip
22:17:01 <Cale> dmwit: He means partial application.
22:17:19 <dmwit> luqui: It wouldn't be even if (=~) were flipped.
22:17:24 * yewT wonders what are the pros are talking o_O
22:17:53 <Cale> (someRegex ~=)  could be evaluated a bit in order to cause the regex to be compiled.
22:18:06 <rwbarton> dmwit: surely it could be?  (=~) pat = let compiledPat = ... in \string -> ...
22:18:29 <dmwit> rwbarton: It *could* be, but I don't think it *would* be in any sane implementation.
22:18:34 <Cale> dmwit: Why not?
22:18:49 <dmwit> That would be memoization, no?
22:18:50 <luqui> that seems like a highly sensible thing to do
22:19:06 * dmwit wonders if he suddenly jumped off the deep end
22:19:19 * lispy waves at dmwit from dry land
22:19:21 <Cale> dmwit: That's exactly why the library provides explicit compilation operations in the first place, so that you can do that.
22:19:29 <dmwit> Cale: Well, of course.
22:19:33 <rwbarton> dmwit: I mean the regex library author writes this code, not that ghc somehow magically transforms it
22:19:41 <dmwit> If you explicitly compile things, I would certainly expect that to be shared.
22:19:46 <Cale> dmwit: It's very common. I think you generally would want to share that work.
22:19:49 <dmwit> rwbarton: Ooooh, okay.
22:20:08 <dmwit> I thought you guys were saying that (x =~) would magically store a compiled x just because it was in the other order!
22:20:16 <Cale> no
22:20:25 <dmwit> But I don't see why this let binding can't be done with the current order, so my original comment stands.
22:20:30 <Cale> Just that if the library designer had designed it that way, it could.
22:20:44 <Cale> Because the parameters are in the wrong order, of course.
22:20:49 * lispy guesses that the library author accepts patches
22:20:49 <dmwit> wait
22:20:50 * luqui wants ghc to magically transform code to memoize, but only when it's actually a good idea to do so!  Also it should solve the halting problem and make me cookies.
22:20:58 <dmwit> You guys.
22:20:58 <Cale> They have the string first.
22:21:12 <lispy> luqui: forget the halting problem, I just want the cookies
22:21:14 <dmwit> You are still saying that, with different library, the function (x =~) would be memoized.
22:21:19 <dmwit> I don't think that's correct.
22:21:25 <Cale> dmwit: s/would/could/
22:21:39 <dmwit> *could*, with a sufficiently smart compiler
22:21:44 <yewT> ok bye guys :)
22:21:45 <yewT> gtg
22:21:47 <rwbarton> In the context  map (x =~) ["foo", "bar", "baz"]
22:21:48 <dmwit> ...which we don't have.
22:21:49 <Cale> Nah, with the compiler we have now
22:21:58 <dmwit> I don't think that's correct, is it?
22:22:04 <Cale> rwbarton gives exactly the example I was going to give
22:22:09 <Cale> Look at that map
22:22:15 <lispy> Could you write a memoizing abstraction in Haskell?  One that just memoizes stuff for you?  Not sure if I monad is going to work :)
22:22:16 <rwbarton> Not, like, any two random terms in the program with the same x
22:22:22 <Cale> You'd want (x =~) to be evaluated just once
22:22:34 <Cale> (with real work getting done to compile the regex)
22:22:36 <lispy> (lisp has a way to write such an abstraction)
22:22:37 <rwbarton> lispy: Yeah, I think there's a sigfpe blog post about it
22:22:45 <lispy> rwbarton: interesting
22:22:50 <dmwit> > let f x = let y = [1..] !! x in y in f (2^31)
22:22:50 <luqui> lispy, I've been gradually hacking on a library for memoization combinators.
22:22:57 <Cale> and then that one compiled regex being used for matching against all the elements of the list
22:22:58 <lambdabot>   mueval: Prelude.read: no parse
22:23:13 <luqui> but it's pretty minimal right now, since I'm stuck on lists ;-)
22:23:14 <dmwit> no parse?
22:23:17 <dmwit> oh
22:23:21 <Cale> nested let, no {}
22:24:01 <rwbarton> luqui: have you seen this blog post to which I referred?  Unfortunately, whenever I look for it, I can never find it again
22:24:06 <lispy> dmwit: you probably want to write that interms of iterate
22:24:09 <luqui> rwbarton, I'm not sure I have
22:24:21 <dmwit> Cale: Nah, it couldn't parse the *output*.
22:24:27 <luqui> I'm a big sigfpe fan, so that surprises me
22:24:43 <rwbarton> luqui: Well, while I look harder you can try to glean the idea from http://hpaste.org/2831
22:24:56 <rwbarton> Oh, the link is in that hpaste
22:25:27 <luqui> rwbarton, oh sure, there's a library that does that on hackage
22:25:44 <luqui> by conal I think.  it's also pretty minimal
22:25:45 <rwbarton> oh?
22:25:57 <luqui> I think the approach is flawed, however, as you want more control over your memo structures than that
22:26:10 <rwbarton> Ah, I see, MemoTrie
22:26:24 <Cale> dmwit: Compare the performance of:
22:26:27 <luqui> i.e. one memo structure per type is not enough
22:26:28 <Cale> let f x = (let n = product [1..x] in \y -> n + y) in map (f 10000) [1..10]
22:26:42 <Cale> let f x y = product [1..x] + y in map (f 10000) [1..10]
22:26:48 <chylli> where is the action modifyGap in XMonad ?
22:26:54 <dons> lispy: set for tomorrow?
22:27:19 <lispy> dons: I think so.  I'm bummed I can't find the remote controll to my laptop.  Otherwise I think I'm set.
22:27:39 <dons> hehe. ok. probably won't need it -- we've got the smaller room this time.
22:27:50 <lispy> dons: oh right, not the usual room.  I forgot
22:27:58 <dons> 'sok, still pretty big
22:28:17 <Cale> (and if you want to exaggerate that, make the [1..10] list a little longer)
22:28:29 <lispy> I'll just plan on running back and forth between the screen and my keyboard
22:28:39 <Cale> So the order that the parameters to a function are in matters a lot :)
22:28:47 <lispy> and bring a laser too, but I'm not fond of pointing...I kinda prefer failing
22:28:50 <lispy> flailing*
22:31:05 <dmwit> Cale: Apparently I *did* walk right off the deep end.
22:31:09 * dmwit blinks
22:31:42 <dmwit> oh!
22:31:51 <dmwit> Yeah, okay, I'm an idiot.
22:32:00 <Cale> In the second one, it's recomputing product [1..10000] over and over
22:32:02 <dmwit> and/or I don't think carefully enough.
22:32:09 <dmwit> yeah, yeah
22:32:14 <lispy> dons: anyway, I'm off to crash I think.  See you around 10:20 tomorrow?
22:32:37 <dmwit> Cale++ for insufferable patience
22:32:44 <lispy> dmwit: I agree
22:32:45 <lispy> Cale++
22:32:58 <newsham> ?karma cale
22:32:58 <lambdabot> cale has a karma of 6
22:33:04 <newsham> ?karma+ cale
22:33:04 <lambdabot> cale's karma raised to 7.
22:33:09 <lispy> ?karma Cale
22:33:10 <lambdabot> Cale has a karma of 7
22:33:13 <pjdelport> Cale's karma must have wrapped around
22:33:15 * Cale wonders what happened to teh karmas
22:33:16 <lispy> that's been reset
22:33:21 <lispy> ?karma dons
22:33:21 <lambdabot> dons has a karma of 4
22:33:22 <Cale> apparently so
22:33:25 <lispy> ?karma lispy
22:33:26 <lambdabot> You have a karma of 3
22:33:33 <Cale> @karma+ dons
22:33:33 <lambdabot> dons's karma raised to 5.
22:33:39 <newsham> ?karma chameleon
22:33:40 <lambdabot> chameleon has a karma of 0
22:33:46 <lispy> ?karma c
22:33:47 <lambdabot> c has a karma of 0
22:33:47 <Cale> @karma+ chameleon
22:33:48 <lambdabot> chameleon's karma raised to 1.
22:34:01 <lispy> ?karma whore
22:34:01 <lambdabot> whore has a karma of 0
22:34:04 <lispy> ;)
22:34:06 <adu> hi
22:34:10 <Cale> hello
22:34:11 <newsham> lispy: wrong channel
22:34:13 <lispy> adu: hey adu
22:34:24 <adu> so earlier we were talked about linked tuples...
22:34:24 <lispy> newsham: I know...sorry.  couldn't stop myself :)
22:34:26 <dons> i lost my karmas in a series of bad mortgage security deals
22:34:34 <adu> ... so I added them to GHC :P
22:34:34 <lispy> ha
22:34:40 <newsham> shoulda bought some karma default swaps
22:34:40 <lispy> dons: wait for the bailout
22:34:41 <Cale> ahaha
22:34:47 <dons> i should ask the treasury
22:34:59 <dmwit> adu: O_o
22:35:05 <dmwit> adu: Do they work well?
22:35:06 * lispy >>= bed
22:35:06 <dons> this crisis is affecting Main Street, and #haskell now. it's gone too far.
22:35:12 <Cale> kp800 billion bailout
22:35:17 <newsham> ?tick ^gspc
22:35:18 <lambdabot> ^GSPC: 1003.35 0.00 (0.00%) @ 10/13/2008 5:19pm
22:35:21 <dons> when you don't know if even your karma is safe
22:35:23 * sadpanda waves night
22:35:26 <adu> dmwit: i dunno, I changed like 4 lines in 3 files, and I'm compiling now
22:35:34 <newsham> we just had a +11% day, its not gloom and doom every day
22:35:40 <davidL_> dons: do you know Tim Sheard?
22:35:43 <dons> davidL_: yeah
22:35:44 <mmorrow> unsafeCoerce False :: True!!
22:35:46 <Cale> ?tick TSX
22:35:46 <lambdabot> TSX: 0.00 @ 11/244/20805 11:10am
22:35:56 <davidL_> dons: ah, I have him as a professor
22:36:00 <dmwit> True is a type these days??
22:36:01 <dons> cool!
22:36:15 <davidL_> dons: does he do stuff for Galois?
22:36:21 <dons> yeah, last summer anyway.
22:36:21 <mmorrow> dmwit: oh yesh
22:36:26 <newsham> True : Prop.
22:36:27 <lispy> dmwit: having it in the type system is the first step in N oleg papers
22:36:28 <dons> he's giving a talk about it next month
22:36:41 <davidL_> he's awesome
22:36:50 <dmwit> lispy: =)
22:36:51 <dons> good guy to have as a teacher.
22:37:28 <dons> ?yow inject me with some EQUITY. my KARMA is turning into PECAN PIE
22:37:28 <lambdabot> YOW!!  What should the entire human race DO??  Consume a fifth of
22:37:28 <lambdabot> CHIVAS REGAL, ski NUDE down MT. EVEREST, and have a wild SEX WEEKEND!
22:37:29 <adu> dmwit: this is what I'm trying right now: http://haskell.pastecode.com/7639
22:37:43 <Cale> It would be cool to have a programming language where the only values were arrows between types.
22:37:57 <dons> mm. function arrows?
22:37:59 <Cale> Ordinary values would be arrows from 1 to whatever type :)
22:38:16 <Cale> yeah
22:38:20 <newsham> () -> 'c'
22:38:22 <Cale> Category theoretic arrows
22:38:30 <dons> a categorised lambda calc?
22:38:42 <Cale> yeah, then function application is just composition
22:38:52 <dmwit> adu: const Supported, eh?
22:39:13 <adu> dmwit: I don't even know what that means :D
22:39:23 * dmwit chuckles
22:39:37 <dons> today's ghc 6.10 results, http://article.gmane.org/gmane.comp.lang.haskell.cafe/46294
22:39:38 <Cale> Because if x :: 1 -> A, and f :: A -> B, then f . x :: 1 -> B
22:39:42 <dons> anyone maintain one of those last few packages?
22:39:49 <lambdabot> Title: Gmane -- Mail To News And Back Again
22:40:29 <Cale> Uh, you do ;)
22:40:33 <Cale> er, oh
22:40:39 <Cale> wrong list
22:40:59 <dons> yeah, i maintain a couple
22:41:15 <dons> i've marked which ones are easy btw.
22:41:21 <dons> 2 packages are failing purely due to the use of -Werror
22:41:34 <dons> numeric-prelude is an easy fix
22:42:06 <dons> bytestring-show, isn't that dolio ?
22:42:10 <dons> dolio: ^6
22:42:26 <dons> anyway, maintainers have 24 hours, then i start emailing them.
22:42:31 <Cale> What are the ones marked "monadic map"? Something has changed about mapM?
22:42:47 <adu> dmwit: is const Supported what determines what -fglasgow-exts does?
22:42:52 <dons> Cale: Data.Map
22:42:56 <Cale> ah
22:43:02 <dons> types aren't returnable in any monad now, just Maybe
22:43:04 <dmwit> adu: I have no idea.
22:43:08 <dons> no more fail
22:43:11 <Cale> ah, cool
22:43:23 <dmwit> What, no MonadPlus?
22:44:02 <adu> Just Maybe :: Maybe Type
22:44:26 <dcoutts> just use Maybe, it's not that hard to lift into your favorite error handling mechanism
22:44:58 <Cale> Yeah, we should appreciate the already quite universal types which we already have :)
22:45:19 <Cale> But bring back MonadZero anyway, since it's a shame that it's gone AWOL for so long.
22:45:30 <dmwit> That's dumb.  It's okay because it's easy, when it could be invisible?
22:45:47 <dcoutts> at most it's just: maybe mzero return . thePreviousThing
22:46:07 <dcoutts> dmwit: no, it describes exactly what the operation can return
22:46:15 <newsham> the stsem works fine for the well-to-do types, but it does not support the dependent types
22:48:01 <Cale> See, if something says that it's MonadPlus, I can't be completely sure if applying it in the list monad will ever possibly give me multiple results or not.
22:48:14 <nha_> whats the best way to see if code annotated with 'par' is actually running on multiple cpus
22:48:40 <Cale> dons would probably know the best answer to that.
22:48:48 <Cale> I'd probably watch my CPU meters.
22:48:55 <rwbarton> nha_: running with +RTS -sstderr should give you some idea
22:49:00 <Cale> (for a rough view)
22:49:01 <nha_> ok thanks
22:49:18 <nha_> also, is the behavior supposed to be the same with -N1 and -N2
22:49:24 <Cale> no
22:49:25 <dons> nha_: run it with 'time' and look for a number above 100%
22:49:29 <Cale> -N1 means run on one processor
22:49:35 <Cale> -N2 means run on two
22:49:41 <nha_> yea
22:49:44 <nha_> i worded it poorly
22:49:46 <rwbarton> nha_: you might have to use /usr/bin/time
22:49:52 <nha_> basicly whats happening is the mem usage skyrockets with -N1
22:49:58 <nha_> im on win32 though haha
22:49:59 <rwbarton> nha_: Ah, that can happen
22:50:00 <Cale> aha!
22:50:04 <Cale> Yes, it can happen.
22:50:25 <dons> well, make sure you're using -O2 and compiling with -threaded
22:50:30 <nha_> i am
22:50:31 <Cale> Something from the thread running on the other processor can be using up the elements, and causing them to be available for GC earlier.
22:50:46 <dons> yeah, `par` can change your space use, if you use it wrong
22:50:53 <nha_> ok
22:50:58 <Cale> Well, even if you use it right.
22:51:09 <dons> until we have a parallel debugger, it relies more on experience and trial'n'error to get it right.
22:51:16 <dons> look at programs other people have used.
22:51:18 <Cale> It can improve your space usage when space usage would normally be bad.
22:51:23 <dons> right.
22:51:37 <dons> so you can actually make more programs work with extra threads. space leaks can go away. its kinda cool
22:52:09 <rwbarton> It can also increase your space usage, just like seq.  (I think)
22:52:29 <adu> lispy: so whats new?
22:52:39 <dons> `par` also modifies the GC behaviour
22:52:49 <dons> you get new roots in the GC that aren't necessarily easy to collect
22:53:12 <Cale> rwbarton: I can imagine if you spark a ton of things, then all those requests sitting in the queue can eat memory...
22:53:49 <Cale> I wonder if there ought to be a global way to limit the number of active sparks.
22:54:10 <rwbarton> I was just imagining sparking a single computation that seqs along a list, faster than another thread is consuming it
22:54:30 <Cale> (that is, if the queue is full, it just drops new sparks on the floor until some complete)
22:54:53 <cads> I want to do haskell style list comprehensions in ruby, do you guys know if there's a paper that discusses the implementation details of haskell's comprehensions?
22:54:54 <Cale> oh, that's try
22:54:56 <Cale> true*
22:55:10 <Cale> cads: The Haskell report
22:55:17 <quicksilver> rwbarton: tehre is a bias in the directon of that not happening
22:55:18 <Cale> cads: It's basically lots of concatMap
22:55:19 <cads> I can imagine that list comprehensions are just syntactic sugar on top of monadic action
22:55:31 <Cale> Or bind for the list monad, if you prefer
22:55:34 <quicksilver> rwbarton: because consumption, generally, is faster than production
22:55:35 <rwbarton> But if you replaced that par with a seq, the memory usage would become infinite :) so I'm not sure that's exactly what I was looking for.
22:55:47 <quicksilver> rwbarton: (because production requires allocation)
22:56:02 <quicksilver> that's not an absolute and things certainly can go wrong in the way you describe.
22:56:04 <cads> cool, I'll check out the report
22:56:28 <Cale> http://haskell.org/onlinereport/exps.html#list-comprehensions
22:56:29 <lambdabot> Title: The Haskell 98 Report: Expressions
22:57:20 <quicksilver> cads: warning: a naive translations allocates many intermediate lists.
22:57:40 <quicksilver> cads: one of GHC's early optimisation goals was to make sure those intermediate lists got optimised away.
22:59:06 <adu> dmwit: I have 2 alternate ideas for linked tuples. the first is what we talked about, making (2, 3, 4) syntax sugar for something else, but another thing that was discussed several months ago was having something be syntax sugar for (2, (3, (4, ())))
22:59:17 <adu> dmwit: and of the two, the latter is much easier so thats what I did
23:02:26 <cads> quicksilver, I created a super naive implementation where I just filtered over the cartesian product of the source lists  : )
23:03:26 <cads> I am hoping I can find details about using multiple predicates, and the optimizations you mentioned
23:07:22 <dobblego> @src (Cont r) return
23:07:22 <lambdabot> Source not found. Maybe you made a typo?
23:07:29 <dmwit> ?src Cont return
23:07:29 <lambdabot> return a = Cont ($ a)
23:07:35 <dobblego> ta
23:09:30 <snails> hi
23:09:35 <snails> lol --->   www.youtube.com/watch?v=0gvw73U_VpU
23:10:15 <dmwit> I'm guessing that's off-topic.
23:10:27 <snails> it's linux
23:10:29 <snails> stuff
23:10:32 <snails> check it.
23:10:49 <dobblego> snails, #haskell is uninterested in your linux video, please take it to #haskell-blah
23:11:04 <snails> oh ok
23:11:10 <dobblego> thanks :)
23:11:14 <snails> to #haskell-blah   vroooom   EXCELLSIOR
23:12:56 <niklaus> how many  n digit integers such that sum of 3 consecutive integers is less than 10 ? how do we go aobut solving this prob
23:13:52 <dmwit> niklaus: It would be cool if you gave us a little evidence that you had tried something yourself.
23:15:01 <dolio> dons: Yes, it is. Is there a problem with it?
23:16:17 <dons> dolio: broken with ghc 6.10, due to moved Integer constructors, see http://article.gmane.org/gmane.comp.lang.haskell.cafe/46294
23:16:18 <lambdabot> Title: Gmane -- Mail To News And Back Again
23:16:22 <dolio> Ah.
23:22:25 <dolio> dons: Is that easy to fix? #ifdef or something?
23:24:09 <adu> > let n = 2 in [ m | m <- [-10^n..10], m + (m+1) + (m+2) < 10, (floor$logBase 10$abs$fromIntegral$m) + 1 <= n]
23:24:11 <lambdabot>   [-99,-98,-97,-96,-95,-94,-93,-92,-91,-90,-89,-88,-87,-86,-85,-84,-83,-82,-8...
23:32:20 <hackage> Uploaded to hackage: derive 0.1.3
23:32:20 <hackage> Uploaded to hackage: fixpoint 0.1.1
23:34:21 <cads> wow these diagrams are brilliant! http://abaris.zoo.cs.uu.nl:8080/wiki/pub/FP/CourseLiterature/haskellsyntax-main.pdf
23:34:28 <cads> what are these called?!
23:35:50 <dmwit> Pretty cool. =)
23:35:53 <flux> hmm, railroad diagrams?
23:37:43 <Cale> http://en.wikipedia.org/wiki/Railroad_diagram
23:37:52 <cads> I converged on that too :D
23:38:00 <cads> that is amazing
23:38:23 <cads> you could use that to visualize backus naur form
23:39:38 <cads> wonder if you'd want to create a syntax using a graphical tool for composing those diagrams
23:39:52 <rwbarton> A verrry long time ago I had a Pascal book with such diagrams for syntax
23:43:20 <Cale> I remember hearing that Wirth invented them.
23:46:15 <Cale> My first exposure to them was in highschool when they appeared in the documentation for Delphi.
23:49:53 <cjs> Young!
23:55:58 <cads> rwbarton: I just took a look at that pascal manual :)
23:56:21 <rwbarton> Is the Apple Pascal book?
23:56:37 <rwbarton> *Is it
23:57:18 <cjs> Apple Pascal? Like the P-System? I remember that!
