00:00:24 <Baughn> jdrake: Why do you think haskell isn't being used more?
00:00:37 <jdrake> Baughn, because it is wierd?
00:00:56 <Baughn> Never mind that, most of the people using C are doing so because they're conservative. They might have jumped to haskell, but even python would be an improvement in most cases..
00:01:13 <Baughn> jdrake: ...
00:01:18 <dons> we just need to give the masses a taste for the good stuff.
00:01:24 <dons> educate the market
00:01:25 * jeffz switched to Haskell after Baughn pointed out that something better than C existed.
00:01:37 <lispy> It must be the Common Lisper in me, but I'm still bitter than python is so popular when it's not that great :)
00:01:39 <Baughn> jdrake: I was about to agree, but then I realized - I've started to feel that the *other* languages are weird
00:01:55 <dons> jdrake: did you get your .cabal sorted?
00:02:01 <jdrake> dons, oh yes
00:02:08 <rwbarton> lispy: it sounds like you might enjoy http://web.mit.edu/rwbarton/www/python.html
00:02:09 <lambdabot> Title: Reid's Python Quiz
00:02:10 <jdrake> I will just use the symlink method
00:02:12 <Baughn> jeffz: Ah yes. My evangelical phase.
00:02:14 <dons> good stuff. now you can publish and distribute it on hackage.
00:02:16 <Eridius> hrm, am I causing problems for myself if I try and sequence a list of one million State actions?
00:02:18 <Cale> "No, the programming languages community has not been asleep at the wheel for the last 30 years." ;)
00:02:21 <Baughn> ..I'd probably still be at it, except I'm not really in ##C anymore
00:02:22 <Nafai> lispy: That's because despite the not-so-greatness, you can get stuff done rather easily in Python
00:02:34 <jdrake> Baughn, I understand C the best, python the second, and haskell the 3rd :-) I plan to make those my three choices
00:02:53 <Baughn> Eridius: Probably not
00:02:58 <jeffz> Baughn: it wasn't even all that evangelical, you just joked that if you were going to implement vb6 in any language, you'd use Haskell, so I was interested.
00:03:01 <Baughn> Eridius: Not if you use them lazily. Not if you don't, either, so long as you have the memory
00:03:16 <Eridius> I'm hitting a stack overflow when I increase my action list beyond roughly 70,000
00:03:22 <Baughn> jeffz: Heh. Then you haven't seen me in full swing
00:03:22 <lispy> Nafai: yeah, but we have other better languages that are equally mature/ready to use, that could have filled that role and been cooler :)
00:03:51 <Nafai> I know, I know
00:03:58 <dreixel> would anyone know how work with haddock in several packages? I link to the module as in "My.Module", but this module is in another package and the link created by haddock doesn't seem to work.
00:03:59 <Cale> Eridius: Stack overflows are usually caused by trying to evaluate expressions in which the outermost reducible subexpression is very deep.
00:04:11 <Nafai> I'm *trying* to replace Python with Haskell as my go-to language and it's hard
00:04:29 <Cale> Eridius: Do you have a recursive function in which there is an accumulating parameter?
00:04:35 <Baughn> Eridius: Such as making a list of a million elements, where element N+1 depends on the value of element N, and then asking for the last one
00:04:41 <Baughn> Or any equivalent code
00:04:48 <Eridius> oh wait, no accumulating. I'm just straight recursing. That's probably it
00:04:49 <jdrake> Baughn, I am generally conservative politically (fiscally conservative, but I like socialism too); I have just switched to Debian (waiting for lenny to go stable), with the intention to stick with it for a long time - to be conservative about stability :-).
00:04:51 <Eridius> durrr
00:04:51 <Baughn> (seqList fixes that one)
00:05:13 <lispy> rwbarton: sick :)
00:05:15 <Baughn> jdrake: You're a democrat?
00:05:21 <Nafai> jdrake: Wow.  If I were back on Debian I'd have to use sid. :)
00:05:22 <Eridius> I have a simple function that generates a sequence based on an initial number, with the rules that n -> n/2 (if n is even), n -> 3n + 1 (if n is odd)
00:05:33 <Nafai> jdrake: I got used to upgrading something every day and liking it :)
00:05:36 <rwbarton> lispy: #3 is my favorite
00:05:36 <Eridius> I'm using the State monad to thread a Data.Map through it to store the results of a given sequence
00:05:47 <jdrake> Baughn, no I generally prefer NDP ;-)
00:05:51 <lispy> rwbarton: I'm really fond of #2
00:05:51 <Eridius> in order to speed up generation of other sequences in which this one is the tail
00:05:55 <lispy> rwbarton: so innocent looking
00:06:01 <jdrake> Nafai, go to ubuntu then
00:06:03 <Baughn> jdrake: You have a .com address, though. >_<
00:06:09 <Eridius> but I'm probably just confusing the issue, and recursing too damn much
00:06:22 <jdrake> Baughn, you mean rogers.com?
00:06:23 <Nafai> jdrake: That's what I'm on now.  I jumped from sid to Ubuntu
00:06:28 <Baughn> jdrake: Yep
00:06:30 <rwbarton> lispy: that was actually my first experience with python.  trying to figure out how to get a python script to exit midway through
00:06:34 <jdrake> Baughn, canadian isp
00:06:39 <Cale> Eridius: aha, the trouble might be that if you don't do a lookup in that map for a long time, but lots of inserts, you'll end up with a state which looks like  insert k1 v1 (insert k2 v2 (...))
00:06:48 <Eridius> yeah
00:06:54 <lispy> rwbarton: whoa, yeah #3 is messed up
00:06:59 <jdrake> Nafai, they like to upgrade their kernel about 3 times a week, even after an LTS release
00:07:00 <Eridius> this algorithm is perfectly fine without the maps, because it's lazy
00:07:25 <Baughn> Eridius: You couldn't use Writer instead?
00:07:36 <Eridius> Baughn: I need to look up items in the Map
00:07:42 <Eridius> I'm not recording a log, I'm memoizing
00:07:59 <Baughn> Eridius: Actually, what you need is strict Map-insert
00:08:07 <Eridius> what?
00:08:29 <Eridius> for example, the number 13 turns into [13, 40, 20, 10, 5, 16, 8, 4, 2,1]. With the Map I can know that every time I hit 13 in another sequence, I can tack on [13, 40, 20, 10, 5, 16, 8, 4, 2, 1] and I'm done
00:08:34 <Cale> (and something to ensure that the updated state gets forced)
00:08:42 <jdrake> Baughn, my website is techsociety.ca :-)
00:08:52 <Baughn> Eridius: Does your state program ever /use/ the state, or just return it?
00:08:58 <Eridius> it uses the state
00:09:03 <Baughn> Eridius: If the latter, the simplest solution would be to.. oh
00:09:06 <Eridius> hell, the caller doesn't care what the state is
00:09:27 <Eridius> this is pure memoization, so I can run a sequence over a list of a million integers and not compute the same subsequences over and over
00:09:38 <Baughn> What's the domain of the key?
00:09:42 <lispy> rwbarton: I don't get #1
00:09:43 <Eridius> Integer
00:09:50 <dblhelix> dons: re plugins: what would happen if I ``make'' a file for which I do have an .o file around, but no .hi file (I get Prelude.undefined thrown at me :-()
00:09:54 <lispy> rwbarton: what did you expect?
00:10:06 <dons> dblhelix: make will likely fail. you can load those things.
00:10:12 <Eridius> oh wait, no, I have to run put on every single number I process or it's kinda pointless. bah
00:10:23 <lispy> rwbarton: 59?
00:10:32 * Eridius was thinking about removing some puts but he can't do that
00:10:37 <dblhelix> dons: indeed, but it does not nicely give me a MakeFailure :-(
00:10:38 <rwbarton> lispy: yeah
00:10:46 <maxote> @ggl Helium
00:10:46 <lambdabot> Maybe you meant: ghc pl url
00:10:59 <rwbarton> lispy: one might hope that each iteration of the loop sees a fresh i variable (but of course that's not how it works)
00:10:59 <maxote> @google Helium
00:11:01 <lambdabot> http://en.wikipedia.org/wiki/Helium
00:11:01 <lambdabot> Title: Helium - Wikipedia, the free encyclopedia
00:11:02 <Cale> Eridius: the important thing is that when the put happens, you want to ensure that the state is actually being evaluated.
00:11:15 <maxote> @google Helium Haskell
00:11:21 <lambdabot> http://www.cs.uu.nl/helium/
00:11:21 <lambdabot> Title: [ The Helium Homepage - Home]
00:11:31 <Eridius> Cale: hrm, I just turned a $ into a $! and all that happened is it prints stack overflow slightly faster
00:11:51 <Cale> Eridius: which one?
00:11:56 <Cale> Eridius: the one for put?
00:11:58 <Eridius> yeah
00:12:01 <Cale> hmm
00:12:01 <Eridius> put $ Map.insert n ns map
00:12:16 <Eridius> and I think the "slightly faster" is actually false - the $ case just got "slightly faster" too. I think I simply freed up some computing resources
00:12:22 <lispy> rwbarton: yeah, did you know that for loops create a variable with dynamic scope (meaning it persists), and that since list comps translate to for loops you can actually access the internal list comp variable afterwards?
00:12:33 <Baughn> Eridius: It might enough to use "get >>= `seq` put whatever
00:12:42 <rwbarton> lispy: Well, clearly I do now :)
00:12:54 <lispy> rwbarton: It has a weird name, but it's fully in scope
00:13:04 <Baughn> Eridius: At least, Map is spine-strict. I'm not sure that means rwhnf is enough to fully evaluate it, but it should (cross your fingers)
00:13:06 <lispy> let me see if I can find a blog about it
00:13:06 <Cale> lispy: hm?
00:13:10 <rwbarton> lispy: wait, now I'm not sure what you mean
00:13:12 <Baughn> (Well, ignoring the values)
00:13:15 <lispy> Cale: python
00:13:30 <Cale> lispy: ah
00:13:34 <maxote> @google eipack
00:13:36 <lambdabot> No Result Found.
00:13:51 <Cale> Eridius: and what is ns, btw?
00:14:04 <Eridius> the chain
00:14:11 <Eridius> the results of the computation
00:14:16 <maxote> @google eispack
00:14:22 <lambdabot> http://www.netlib.org/eispack/
00:14:23 <lambdabot> Title: EISPACK
00:14:28 <Baughn> Eridius: Or, actualy, I think that's just Control.Monad.State.Strict
00:14:43 <lispy> rwbarton: when you do, for i in blah: ..., it brings i into dynamic scope, right?
00:14:48 <Eridius> ooh, adding .Strict didn't overflow!
00:14:52 <lispy> rwbarton: so you can continue to reference i in that method
00:14:57 <Eridius> at least, on 71 thousand numbers
00:14:59 <Eridius> let's go back to a million
00:15:07 <rwbarton> lispy: Sure, I guess it counts as an assignment for the scoping rule
00:15:24 <lispy> rwbarton: well, list comps translate to for loops, literally.  And if you know the name of 'i' in the translated for loop you can access it after doing a list comp
00:15:36 <rwbarton> lispy: oh, it's not just 'i'?
00:15:58 <Eridius> hooray, I got my result!
00:15:59 <Eridius> 837799
00:16:06 <lispy> [x in blah] -> for __i in blah: ...
00:16:07 <Baughn> Eridius: Do you understand why that happened?
00:16:11 <lispy> rwbarton: something like that
00:16:11 <Eridius> thanks Baughn, I wouldn't have realized there was a separate Strict version of State
00:16:20 <sjanssen> lispy: that is awesome
00:16:30 <Eridius> Baughn: there were far too many thunks in the Lazy version, but I'm not quite sure where?
00:16:35 <Baughn> Eridius: It'd just replace put with the get-seqing version I suggested above
00:16:39 <lispy> I'm trying to find the blog where I learned this
00:16:59 <Eridius> Baughn: I pasted your get-seq thing and it gave me a type error. I didn't bother to decipher it though
00:17:07 <sjanssen> Eridius: the thunks were a bunch of snd's around your state
00:17:11 <rwbarton> lispy: the list comprehensions I know of are of the form [ foo for i in bar ] and indeed i is in scope afterwards
00:17:34 <Eridius> sjanssen: oh?
00:17:47 <sjanssen> Eridius: right, a snd for every >>= or >>
00:17:49 <Baughn> Eridius: Right. The issue is that Map is spine-strict, so if you have a large chain of (insert a b (insert a2 b2 (insert a3 b3 ...))), once the rts starts evaluating that, it has to run through every insert (all 1M of them) before it gets the first structure it can put back on the heap. That'll overflow the stack
00:17:53 <Eridius> ouch
00:18:13 <maxote> @google fortran haskell translator
00:18:15 <lambdabot> http://www.sharewareconnection.com/titles/fortran.htm
00:18:16 <lambdabot> Title: Software Download: Fortran
00:18:30 <Eridius> hmm, sjanssen and Baughn are saying different things
00:18:43 <Baughn> Eridius: Making the state strict forces it to fully evaluate each map before starting on the next one, which lets it stick it back on the heap, avoiding stack usage
00:18:57 <Baughn> (Plus, it'll be able to GC the last one when it's done with the next)
00:18:58 <sjanssen> Baughn: .Strict does not make the state strict
00:19:10 <Baughn> ...
00:19:19 * sjanssen is hunting for the source, one moment
00:19:20 <Baughn> Or I might be misunderstanding totally what actually fixed it
00:19:26 <Eridius> http://hackage.haskell.org/packages/archive/mtl/1.1.0.1/doc/html/src/Control-Monad-State-Strict.html
00:19:27 <lispy> sjanssen, rwbarton: http://morepypy.blogspot.com/2008/06/list-comprehension-implementation.html
00:19:29 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/4ky38y
00:19:29 <lambdabot> Title: PyPy Status Blog: List comprehension implementation details, http://tinyurl.com/6bf6cw
00:20:48 <sjanssen> Baugh, Eridius: look at the (>>=) for both Lazy and Strict
00:21:06 <Eridius> sjanssen: one uses a case, the other a let
00:21:10 <Eridius> I'm not sure what implications that has
00:21:11 <sjanssen> note that Lazy uses a let binding on the tuple result (a, s'), while Strict uses case
00:21:17 <sjanssen> Eridius: let is lazy
00:21:24 <Eridius> and case isn't?
00:21:34 <sjanssen> case is strict
00:22:17 <Nafai> lispy: Well, all that is happening there (unless I'm misunderstanding) is the result of the list comprehension is saved to _, which is standard python behavior
00:22:19 <Baughn> Given this, exactly why does Control.Monad.State.Lazy exist?
00:22:36 <Eridius> sjanssen: am I correct in saying that let is always an irrefutable match?
00:22:37 <Nafai> >>> 1 + 1
00:22:37 <Nafai> 2
00:22:37 <Nafai> >>> _
00:22:37 <Nafai> 2
00:22:44 <sjanssen> "let (a, s') = runState m s in runState (k a) s'" translates to "let x = runState m s in runState (k (fst x)) (snd x)"
00:22:51 <Baughn> Eridius: An irrefutable match is a let, rather.
00:22:58 <Eridius> Baughn: maybe if you never use the state then it won't ever have to evalute it?
00:23:04 <Eridius> Baughn: well, you can make irrefutable matches elsewhere with ~
00:23:04 <sjanssen> Baughn: something about _|_ >> return (), I think
00:23:07 <Baughn> Eridius: That's true regardless
00:23:19 <rwbarton> lispy: lovely
00:23:23 <Baughn> sjanssen: Ah. I suppose that makes some sense
00:23:39 <Baughn> Can't help but think Strict should be the default, though. Strict is how I assumed Lazy was behaving
00:23:41 <Saizan> sjanssen: MonadFix?
00:23:56 <Eridius> Baughn: I dunno, I tend to assume everything's Lazy by default
00:23:56 <lispy> Nafai: weird
00:24:00 <sjanssen> Eridius: yes, let bindings are very similar to irrefutable matches
00:24:24 <lispy> Nafai: how often is _ updated?
00:24:33 <Saizan> .Strict is MonadFix too
00:24:37 <Nafai> After each expression, I believe
00:24:47 <Baughn> Eridius: After a couple compiler passes, "let" has become "allocate memory" while "case" is "evaluate". More or less.
00:24:56 <Eridius> Baughn: huh
00:24:56 <Baughn> Eridius: Though, those aren"T the same lets and cases
00:25:15 <sjanssen> Baughn: that is a nice rule of thumb, actually
00:25:34 <Baughn> Right, but irrefutable matches also compile to let, don't they?
00:25:37 <sjanssen> let creates thunks, pattern matching in case evaluates them
00:25:39 <Baughn> Etc. etc.
00:26:25 <sjanssen> of course function application also creates thunks
00:26:42 <sjanssen> and case may occasionaly cause new thunks to appear
00:26:56 <Baughn> Which makes perfect sense if you consider the entire module to be a giant let. ;)
00:27:37 <Baughn> Eridius: Oh, and it was pretty simple to create a testcase where my reasoning was right. Your code just wasn't it. :P
00:27:43 <Eridius> hehe
00:27:59 <Eridius> damn, my OCaml code for this same problem is significantly faster than my Haskell code >_<
00:28:11 <Baughn> You are compiling with -O2, right?
00:28:15 <Eridius> oh, just -O
00:28:17 <sjanssen> Eridius: what does the code do?
00:28:23 <Eridius> http://projecteuler.net/index.php?section=problems&id=14
00:28:24 <lambdabot> Title: Problem 14 - Project Euler
00:28:32 <Eridius> the ocaml code compiles and runs in 9.6 seconds
00:28:39 <Baughn> And the ghc code with -O2?
00:28:41 <Eridius> the haskell code compiles and runs in 47.1 seconds
00:28:42 <lispy> Eridius: send both to haskell-cafe with timings, wait 8 hours and the haskell one will be asymptotically faster and faster in turns of wall-clock ;)
00:28:49 <Eridius> haha
00:28:53 <Baughn> Eridius: ..hold it, you aren't supposed to count the compilation time
00:29:02 <Nafai> lispy: Or optimize that process and send to dons :)
00:29:23 <sjanssen> Eridius: GHC is an incredibly slow compiler.  What do the run times alone look like?
00:29:30 <Eridius> Baughn: my makefile is set up to compile, run, delete, so it's easier to count it. The compile time is roughly the same in both cases and negligible compared to the runtime
00:29:39 <Baughn> Eridius: Not with -O2, it won't be
00:29:55 <mmorrow> * jeffz switched to Haskell after Baughn pointed out that something better than C existed.
00:30:08 <Eridius> sjanssen: the compilation here with -O takes roughly 0.2 seconds
00:30:17 <mmorrow> lol, me too (but i wasn't told by Baughn) :)
00:30:20 <sjanssen> Eridius: are you using ghc --make?
00:30:23 <Baughn> Eridius: Use -O2, I keep telling you. ;_;
00:30:23 <Eridius> yeah
00:30:38 <sjanssen> Eridius: unless you're deleting the object files, GHC isn't recompiling each time
00:30:41 <Baughn> Eridius: --make won't recompile if it finds existing files. Even if you pass different parameters.
00:30:45 <Eridius> sjanssen: I am
00:30:46 <Baughn> Eridius: You could pass it -fforce-recomp
00:31:09 <Baughn> sjanssen: Dividing by the work done by LOC, I've found ghc to be a pretty fast compiler
00:31:16 <int-e> Baughn: let f = f >>= return . (1:) in take 10 $ evalState f 0  works in Control.Monad.State.Lazy but not in .Strict
00:31:22 <Eridius> Baughn: -O2 doesn't seem to be having much effect
00:31:23 <Baughn> sjanssen: That is to say, the work my code does per LoC, not the work the compiler does
00:31:34 <sjanssen> Eridius: using the same algorithm in both versions?
00:31:43 <Eridius> sjanssen: I think so. Let me check my OCaml code
00:31:48 <Eridius> I wrote the OCaml code a while ago
00:31:56 <sjanssen> Eridius: are you using Int or Integer in the Haskell code?
00:32:01 <sjanssen> (Int is better here)
00:32:05 <Baughn> int-e: Point, but I don't think many people are using State like that
00:32:09 <Eridius> I wrote it 1.5 months ago
00:32:10 <hackage> Uploaded to hackage: Salsa 0.1.0.1
00:32:18 <Baughn> int-e: Personally I mostly use it to port imperative algorithms
00:32:20 <Eridius> sjanssen: I'm using Integer. I'm not sure how high the chain goes
00:32:33 <sjanssen> oh, this is a good point
00:32:40 <Eridius> sjanssen: my OCaml code uses Big_int, so it goes higher than 2**30
00:33:34 <Nafai> Ooo.  Salsa.
00:33:39 <Nafai> That's an interesting sounding project.
00:34:00 * mapreduce has 7 years' Salsa experience.
00:35:15 <int-e> Baughn: Yes, .Strict would be a reasonable default in my eyes, too. My point was that .Lazy is not useless.
00:36:03 <Eridius> ok, is it a bad thing that I'm sitting here confused at my own OCaml code from 1.5 months ago?
00:36:11 * Eridius is trying to figure out what this List.fold_left is for
00:36:13 <Baughn> int-e: Oh, sure. ;P
00:37:20 <int-e> Baughn: and of course, stack overflows aside (which is an awfully practical restriction), code that works with .Strict will also work with .Lazy ;-)
00:38:04 <Eridius> ooh, I know what it's for
00:38:19 <Eridius> I'm just deferring my Map mutation until I've finished calculating the unknown part of the sequence
00:38:44 <Baughn> int-e: "Except that it'll abruptly explode if you drive over 400 kilometers in one go, a honda is just as good as a prius"
00:39:27 <int-e> Baughn: yes, it'll work perfectly well if all you ever do is drive 5 or 10 miles to work ;)
00:41:04 <Saizan> or maybe you just need to compile with O2?
00:41:40 <Eridius> sjanssen: here's my OCaml and Haskell versions: http://hpaste.org/11050
00:42:50 <Eridius> compiling with -O2, my Haskell version takes 46.8 seconds
00:42:53 <Eridius> (only one trial done)
00:43:01 <Baughn> Eridius: You should get a slight speed boost by using Map.adjust, by the way
00:43:32 <Baughn> Eridius: Hang on, s/adjust/alter/
00:43:39 <Eridius> Baughn: I just looked up that function, and it only mutates anything if the value already exists
00:43:51 <Eridius> alter?
00:43:51 <Baughn> Right. alter. ;()
00:44:11 <Eridius> why would alter be more efficient than insert?
00:44:26 <Baughn> It'll only traverse the map once
00:44:42 <Baughn> Well, it wouldn't be more efficient than insert
00:44:51 <Baughn> It /would/ be more efficient than your lookup/insert combination
00:45:14 <Eridius> except I don't insert on the same key I lookup
00:45:20 <Eridius> I only insert if the lookup failed
00:45:23 <Baughn> ..whoops
00:45:23 <Saizan> Eridius: are you aware that in the haskell version you're essentially resetting back the state after the recursive call?
00:45:35 <Eridius> Saizan: how's that?
00:46:08 <Eridius> oh dur
00:46:11 <Saizan> Eridius: you use put on the map that you've getted before the call to chan'
00:46:12 <Eridius> now I see it
00:46:21 <Saizan> with the inserted item
00:46:28 <Eridius> that kinda defeats the entire purpose of using the map
00:46:34 <Saizan> yeah
00:46:39 <Saizan> you should use modify
00:46:49 <Saizan> put $ Map.insert n ns map
00:46:55 <Saizan> modify $ Map.insert n ns
00:47:14 <Baughn> Ayup. Now I'm curious what timings you get now. :)
00:47:33 <inimino> is there a canonical binomial coefficient function somewhere that everyone uses?
00:48:05 <inimino> (I mean in a library)
00:48:14 <Cale> Well, maybe something on hackage.
00:48:20 <Cale> I usually just write my own.
00:48:28 <Eridius> I get 38.8 seconds now
00:48:30 <rwbarton> I just use choose n k = (product [n-k+1..n]) `div` (product [1..k]), it's reasonably efficient
00:48:31 <inimino> ok, I'll just do that then
00:48:49 <sjanssen> Eridius: is the longest sequence 525?
00:49:13 <Eridius> sjanssen: I think that's what the OCaml version prints
00:49:25 <Eridius> well, that's the length of the longest sequence
00:49:37 <int-e> sjanssen: yes
00:49:40 <Eridius> the seed number is 837799
00:50:10 <sjanssen> Eridius: I've got a version here that runs in 4.5s
00:50:14 <Eridius> sjanssen: oh?
00:50:21 <sjanssen> hint: don't bother memozing larger than 1 million
00:50:41 <sjanssen> hint 2: use the lazy array memoization trick
00:50:43 <Eridius> hmm, I think my OCaml version already does that because it hard-codes the size of the map
00:51:00 <Saizan> sortBy (.. `on` length) looks quite a lot of wasted work too
00:51:22 <Eridius> "lazy array memoization trick?" What is this, an array that's allocated using a function that looks up values in the array?
00:51:23 <sjanssen> oh yes, don't bother keeping the actual chain, just store the length
00:51:31 <sjanssen> Eridius: yep!
00:51:53 <Eridius> sjanssen: well, keeping the actual chain is just a memory issue, not a CPU time issue, and I don't think that's a problem here
00:52:10 <jdrake> man, compiling a kernel puts my cpu up to 359K
00:52:10 <sjanssen> Eridius: as Saizan points out, sorting on length is very slow
00:52:15 <Baughn> > let fibs = arrayList (0,10) $ 0 : 1 $ [fibs ! n-2 + fibs ! n-1 | n <- [2..10]] in fibs
00:52:16 <lambdabot>   mueval: Prelude.read: no parse
00:52:27 <Baughn> ..how come I never manage to write that one right? ;_;
00:52:38 <Saizan> Eridius: you end up calculating the length of the same list multiple times
00:52:45 <Eridius> hmm
00:52:45 <sjanssen> Eridius: at the least you should use maximum, and you should also "map length" rather than call length repeatedly
00:52:53 <dmwit> http://article.gmane.org/gmane.comp.lang.haskell.cafe/7737 # lazy array memoization
00:52:56 <lambdabot> Title: Gmane -- Mail To News And Back Again
00:53:06 <int-e> Baughn: using $ instead of :?
00:53:11 <Eridius> I sorted on length rather than mapping so I would have access to the original list
00:53:17 <Eridius> because the number I wanted was the head of hte chain
00:53:26 <Baughn> > let fibs = arrayList (0,10) $ 0 : 1 : [fibs ! n-2 + fibs ! n-1 | n <- [2..10]] in fibs -- Yes, that would do it
00:53:27 <lambdabot>   mueval: Prelude.read: no parse
00:53:29 <Eridius> oh hey, there's a maximumBy
00:53:30 <sjanssen> dmwit: I keep that post bookmarked too :)
00:53:52 <Baughn> int-e: Hum. Imagine a world what \bot would actually give error messages. It would be wonderful.
00:53:57 <Baughn> Oh wait, it used to do that
00:53:59 <sjanssen> oh, they want the starting number
00:54:06 <Eridius> sjanssen: yeah
00:54:11 <dmwit> This may also be of interest:
00:54:12 <rwbarton> Baughn: You need parentheses around n-2 and n-1 for one thing
00:54:16 <sjanssen> Eridius: better to use the Map's index value rather than store it in a list
00:54:18 <dmwit> :t let sortOn f = map snd . sortBy (comparing fst) . map (f &&& id) in sortOn
00:54:19 <lambdabot> forall a c. (Ord c) => (a -> c) -> [a] -> [a]
00:54:37 <dmwit> Schwartzian transform for faster sorting. =)
00:54:44 <int-e> > let fibs = listArray (0,10) $ 0 : 1 : [fibs ! (n-2) + fibs !  (n-1) | n <- [2..10]] in elems fibs
00:54:44 <lambdabot>   mueval: Unsafe functions to use mentioned.
00:54:45 <Eridius> sjanssen: I'm not sure what you mean
00:55:02 <Saizan> i thought we removed that?
00:55:06 <int-e> , let fibs = listArray (0,10) $ 0 : 1 : [fibs ! (n-2) + fibs !  (n-1) | n <- [2..10]] in elems fibs
00:55:07 <lunabot>  luna: Not in scope: `listArray'
00:55:11 <int-e> aww.
00:55:17 <int-e> [0,1,1,2,3,5,8,13,21,34,55]
00:55:32 <Saizan> Cale: did you switch back to the old/unpatched mueval?
00:55:35 <int-e> Baughn: funny that you also mix up arrayList and listArray, I have the same problem.
00:55:49 <sjanssen> Eridius: the Map already has each starting number recorded
00:56:05 <Eridius> oh, you mean the key, not the index. Data.Map has functions to get the index for a key
00:56:26 <sjanssen> Eridius: key, index, are just words :)
00:56:30 <sjanssen> Eridius: but yes, I mean that
00:57:06 <sjanssen> Eridius: so you could do something like: fst . maximumBy snd . map (second length) . Map.toList
00:57:18 <Cale> Saizan: Oh! Duh... I just realised that I reinstalled mueval in my half-hearted attempt to get the new quickcheck working with it, but I installed the wrong one, obviously.
00:57:45 <Eridius> sjanssen: I haven't learned Control.Arrow yet, I'm not sure if I'm allowed to use second :P
00:57:55 <dmwit> heh
00:58:00 <sjanssen> Eridius: the version without is pretty easy
00:58:01 <dmwit> Have you learned frefs?
00:58:02 <Baughn> @type second
00:58:03 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
00:58:10 <sjanssen> second length = \(x, y) -> (x, length y)
00:58:10 <Eridius> dmwit: depends on what a fref is :P
00:58:11 <dmwit> second = set snd
00:58:16 <Saizan> Cale: heh :)
00:58:20 <Eridius> yeah I actually know what second does
00:58:33 <dmwit> ?where fref
00:58:33 <lambdabot> http://twan.home.fmf.nl/blog/haskell/overloading-functional-references.details
00:58:48 <Baughn> > (second (+)) (1,3) (1,4)
00:58:49 <lambdabot>   Couldn't match expected type `t1 -> t'
00:59:21 <dmwit> > second ($4) . second (+) $ (1, 3)
00:59:22 <lambdabot>   (1,7)
00:59:27 <Baughn> @type (second (+))
00:59:28 <sm> unit tests - in all your modules, or gathered into their own separate one ?
00:59:29 <lambdabot> forall a d. (Num a) => (d, a) -> (d, a -> a)
01:02:13 <Baughn> > (second (+ 3)) (1,3)
01:02:14 <lambdabot>   (1,6)
01:02:23 <Baughn> @instances Arrow
01:02:24 <lambdabot> (->), Kleisli m
01:02:58 <dmwit> sm: I think gathering them is the sanest way to do it.
01:03:28 <opqdonut> does anyone have a reference to a paper about "functional programs are (almost) runnable specifications"
01:03:39 <opqdonut> I recall seeing one
01:03:53 <sm> darn, I should have stopped after cleaning up the test module
01:03:56 <sm> I'm torn
01:04:37 <maxote> @ghc version
01:04:38 <lambdabot> ghc says: panic! (the `impossible' happened, GHC version 6.4)
01:04:44 <dmwit> ?help ghc
01:04:45 <lambdabot> ghc. Choice quotes from GHC.
01:04:55 <dmwit> ?ghc this part is totally ignored, probably
01:04:56 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
01:05:02 <ziman> @ghc
01:05:02 <lambdabot> ghc says: ld64: INFO    171: Multigot invoked. Gp relative region broken up into 2 separate regions.
01:05:10 <sm> b
01:05:53 <Eridius> incidentally, switching from sort to maximumBy only shaved off about 2 seconds
01:06:18 <dmwit> Are you still doing maximumBy (comparing length)?
01:06:32 <dmwit> Because that will be almost exactly the same running time as head . sortBy (comparing length).
01:06:50 <dmwit> You have to memoize the lengths if you want it to speed up.
01:07:10 <Eridius> yeah I know, I just thought I'd test this out
01:07:17 <maxote> is there any manner for GHC doesn't suck all the memory of the system?
01:07:21 * Eridius is reading that post on lazy array memoization
01:07:49 <Baughn> maxote: Er.. you can pass +RTS -M64m or some such to limit the maximum memory use, if that's the problem
01:08:05 <dmwit> Eridius: Oh, I just meant tuple-memoization, but arrays are nice, too.
01:08:21 <maxote> thanks Baughn
01:08:30 <Eridius> tuple-memoization?
01:08:55 <dmwit> aka the Schwartzian transform
01:09:18 <dmwit> Just make a tuple (longList, lengthOfLongList) and do maximumBy snd instead of maximumBy length.
01:09:22 <mmorrow> dolio: re church encoding vs. SAPL. so why SAPL is preferable is "summed up" by how pred is O(n) using the standard church numeral rep of N, while in SAPL it's O(1).
01:09:40 <dolio> Ah.
01:09:49 <dmwit> Although, now that I think about it, it should only be computing the length of each list once.
01:09:50 <Eridius> dmwit: what I used on that last test is: snd $ maximumBy (comparing fst) $ map (length &&& id) $ runChainState chains
01:09:51 <Saizan> what's SAPL?
01:10:01 <dmwit> Eridius: right
01:10:01 <mmorrow> i just started readed those papers again
01:10:02 <dmwit> ok
01:10:13 <dmwit> Eridius: ah!
01:10:15 <dmwit> I see.
01:10:17 <Eridius> although memoizing the lengths is probably significantly better
01:10:29 <Eridius> because as it is I'm re-calculating the length of the same sublists over and over
01:10:35 <dmwit> Eridius: exactly
01:10:36 <sjanssen> not storing the chains at all seems best
01:10:40 <maxote> don't memoize much!
01:10:59 <mmorrow> Saizan: http://www.st.cs.ru.nl/papers/2006/janj2006-TFP06-EfficientInterpretation.pdf
01:11:01 <lambdabot> Title: Efficient Interpretation by Transforming Data Types and Patterns to Functions, http://tinyurl.com/5y5sge
01:11:16 <mmorrow> http://www.st.cs.ru.nl/papers/2005/janj2005-PatternMatchingByFunctionsIFL05.pdf
01:11:19 <lambdabot> Title: Data Types and Pattern Matching by Function Application, http://tinyurl.com/4kyxdv
01:11:32 <dolio> mmorrow: That certainly makes sense. tail on a church encoded list is O(n)-ish, too.
01:11:58 <mmorrow> apparently Clean uses it as an intermediate lang, but i just tried to find mention of it in the Clean sources and didn't see anything (didn't know what to look for either)
01:12:09 <Saizan> mmorrow: ooh pdfs with meaningful names!.. thanks :)
01:21:08 <mib_dwacku> Does hugs support native multi-threading and scale when hosting web apps?
01:21:27 <ozy`> uhm
01:21:45 <kaol> Haskell is fun. I need to know what I'm doing beforehand.
01:22:10 <ozy`> mib_dwacku: I dunno about hugs. I would use GHC for hosting web apps.
01:23:22 <mib_dwacku> err..i use windows+hugs for dev and it's fast enough for my needs..just wondering if it makes sense in prod
01:23:28 <Cale> hugs is an interpreter and can generally is not designed for performance
01:23:40 <Cale> s/can/
01:23:44 <mib_dwacku> JIT'ing?
01:23:49 <EvilTerran> i definitely wouldn't use it in a production setting
01:24:13 <EvilTerran> using ghc to optimise and compile in advance is an easy, and very profitable, optimisation
01:24:19 <jeffz> mib_dwacku: it's not much effort to install ghc in windows
01:24:21 <Cale> mib_dwacku: I'm not exactly sure what its evaluation model is, but I would expect it's just doing graph reduction, and not compiling at all.
01:25:16 <ozy`> GHC's optimizations can make haskell as fast as C (depending on the application)
01:25:32 <EvilTerran> modulo writing C in haskell :P
01:26:22 <mib_dwacku> concur on that...i ran some heavy hitting matrix calc stuff just to test
01:26:32 <ozy`> EvilTerran: I've always found that use of "modulo" to be parallax
01:26:53 <EvilTerran> er, what?
01:27:09 <ozy`> precisely
01:27:18 <mib_dwacku> i am going through  realworldhaskell and the one thing missing from it is writing web apps
01:27:23 <EvilTerran> sorry, this is my pre-breakfast-and-coffee IRCing while my email loads. what?
01:27:47 <ozy`> mib_dwacku: there's a haskell framework somewhere for writing web apps... happs, IIRC
01:27:56 <ozy`> with its own tutorial and everything
01:28:17 <mib_dwacku> wondering if there's something like a nice HTML gen module ala Cl-WHO
01:30:46 <ozy`> EvilTerran: still sleeping furiously alongside those colorless green ideas?
01:30:49 <Eridius> d'oh
01:30:56 <Eridius> sjanssen: I now have a program which produces the answer in 1.6 seconds compiled with -O2
01:31:02 <Eridius> but hits a stack overflow when run in ghci
01:31:11 <mib_dwacku> any pointers to screencasts showing haskell hacking..seems to be pretty popular with many prog lanf communities nowadays
01:31:16 * EvilTerran is keepin' on truckin', is all
01:31:50 <mib_dwacku> i saw some on blip tv but that was just simon's talks
01:32:03 <kaol> http://haskell.org/haskellwiki/Video_presentations
01:32:04 <lambdabot> Title: Video presentations - HaskellWiki
01:32:12 <ozy`> mib_dwacku: I saw one video demonstrating the dangers of side effects... they wound up getting attacked by dinosaurs halfway through
01:32:18 <Cale> mib_dwacku: hehe, mostly it seems Haskell programmers produce PDFs rather than video files ;)
01:33:22 <rwbarton> ozy`: reminds me of http://lisperati.com/landoflisp/
01:34:41 <birkenfeld> @pl \f a -> map ($ a) f
01:34:41 <lambdabot> flip (map . flip id)
01:34:55 <mib_dwacku> screencasts look l33t and the LISP folks keep bragging about SLIME
01:35:26 <opqdonut> slime is nice, common lisp is awful :>
01:38:14 <osfameron> slime does look lovely
01:38:15 <Saizan> if f :: a -> m b is called a kleisli arrow, does (f =<<) :: m a -> m b have a name?
01:39:21 <Eridius> sjanssen, Baughn: Here's the new version: http://hpaste.org/11050#a2
01:40:02 <Eridius> and now I really should go to bed
01:40:08 <Eridius> ..although I never ate dinner
01:40:09 <Eridius> hmm
01:40:35 <sm> how do I tell ghci to import a module "open" like *, ignoring any .o files ?
01:40:37 <mmorrow> dolio, Saizan: (in case you haven't read this yet) here's the way datatypes are encoded as functions in SAPL http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=103
01:40:41 <sm> when I invoke it ?
01:42:08 <ozy`> rwbarton: not http://www.xkcd.com/292/ ?
01:42:09 <lambdabot> Title: xkcd - A Webcomic - goto
01:42:33 <ozy`> 'cause I'll admit straight up, that's what I was thinking of
01:42:39 <dolio> mmorrow: What's body_k?
01:42:50 <ozy`> on the other hand it would kick so much ass to have "Republic of Haskell" on my passport
01:42:56 <ozy`> seriously, I would live there
01:43:03 <birkenfeld> "flip id" is mind-boggling
01:43:11 <mmorrow> dolio: heh, i'll paste the description..
01:43:19 <ozy`> wouldn't mind at all being governed by the Illuminati or anything
01:44:01 <Kvasir> how can i print a float without the scientific notation?
01:44:54 <Kvasir> actually it prints the number as 1.2345e-3, i'd like to have 0.001234
01:45:28 <EvilTerran> something in Numeric
01:45:44 <mmorrow> dolio: http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=103#a105
01:45:51 <EvilTerran> showFFloat
01:46:27 <EvilTerran> Kvasir, showFFloat always shows it that way, showEFloat always uses exponential notation, and showGFloat chooses between the two depending on magnatude
01:46:41 <dolio> mmorrow: Sounds pretty complicated.
01:47:13 <Kvasir> uhm
01:47:21 <Kvasir> actually it's a Double, not a Float
01:47:21 <Saizan> mmorrow: so the difference with chuch encoding appears in recursive types?
01:47:27 <Cale> > showFFloat (Just 6) 0.0012345
01:47:28 <lambdabot>       Overlapping instances for Show (String -> String)
01:47:28 <lambdabot>        arising from a...
01:47:30 <Kvasir> and it doesn't work with showFFloat
01:47:31 <Cale> > showFFloat (Just 6) 0.0012345 ""
01:47:32 <lambdabot>   /tmp/1185103836966377696:67:68: Not in scope: `showFFloat'
01:47:36 <Cale> hmm
01:48:20 <Cale> I should add Numeric to the list of libraries the bot knows about
01:48:22 <Cale> Prelude Numeric> showFFloat (Just 6) 0.0012345 ""
01:48:23 <Cale> "0.001235"
01:48:59 <Cale> showFFloat is a bit misnamed. It should be showsFFloat
01:49:01 <mmorrow> Saizan: apparently, on account of always passing the continuation for each of the selector functions, they are infinite types under hindley-milner => untypeable
01:49:39 <Kvasir> i still can't make it work
01:49:40 <mmorrow> dolio: heh, the first time i read it i was like wtf, then a month or so later read it again and was like ohhhhh.
01:49:41 <Cale> (it takes an extra string parameter, and prefixes that string with its bit)
01:49:51 <Kvasir> do i have to convert the double to float?
01:50:16 <Kvasir> ok, i missed the ""
01:50:54 <Cale> To be honest, I'm not sure why they don't just produce strings.
01:50:59 <Saizan> mmorrow: oh, yeah, you need higher-rank polymorphism
01:51:03 <mmorrow> dolio, Saizan: i have some TH code that does essentially the first step there to make a FoldA record datatype from an A, so i'm gonna add the rest of the SAPL translation to that real quick..
01:51:22 <Cale> In general, the ShowS type is a nice efficiency hack, but I can't really see how for short things like this it's any better.
01:52:12 <Kvasir> how can i use ShowS?
01:52:21 <rwbarton> @src ShowS
01:52:21 <lambdabot> type ShowS = String -> String
01:52:33 <Kvasir> i'm just using haskell as a calculator, so hacks are ok
01:52:50 <Kvasir> in what module is it?
01:53:32 <Cale> Prelude
01:53:48 <Saizan> Kvasir: it's only useful if you've to repeadetly append to a list
01:53:49 <Cale> (oh, and Numeric, for this showFFloat thing)
01:54:45 <sm> how would you capture the output of an IO action for a test ?
01:54:49 <Cale> See, if instead of Strings, we use functions which add stuff to the beginning of the string they're given, then concatenation of strings (an O(n) operation) becomes function composition (an O(1) operation)
01:55:19 <Cale> sm: do result <- myIOAction; doStuffWith result
01:55:56 <sm> hi Cale.. what I mean is, my action returns (), I want to capture what it prints to stdout
01:56:25 <EvilTerran> ah, that's more awkard
01:56:32 <EvilTerran> *awkward
01:56:35 <Cale> Ah, then you need a separate process.
01:56:41 <sm> yikes
01:56:53 <rwbarton> sm: that would require some terrible hack in any language, I think.  Do you control myIOAction?
01:56:59 <sm> yes
01:57:02 <Saizan> uhm, redirect stdout to a pipe?
01:57:04 <EvilTerran> or something that pretends to be the IO monad
01:57:16 <EvilTerran> but actually uses a WriterT for stdout
01:57:38 <EvilTerran> that'd be a bit cleaner, but rather more legword
01:57:39 <EvilTerran> *k
01:57:51 <Cale> Or you could just factor the thing into a String producer and a part which prints that String.
01:58:01 <sm> yes I see
01:58:14 <sm> thanks for the pointers all
01:58:24 <Cale> (Of course, this may or may not be reasonable to do)
01:58:35 <EvilTerran> yeah, i'd make my code use a WriterT String IO itself
01:58:42 <sm> it might be a nice feature for HUnit
01:58:55 <rwbarton> then change all your putStr to tell
01:58:59 <rwbarton> etc.
01:59:08 <EvilTerran> if we had class aliases and IO broken down into classes for each bit of functionality, what you wanted would be a lot easier
01:59:38 <EvilTerran> "instance Monad m => MonadStdout (WriterT String m) where putStr = tell"
01:59:45 <rwbarton> import Prelude hiding (putStr); ...
02:00:13 <EvilTerran> you could indeed write such a MonadStdout class and hide the prelude definitions of the stdout-using functions
02:00:35 <mapreduce> @oeis [1, 2, 11]
02:00:35 <lambdabot>  Sequence not found.
02:00:47 <Cale> hmm, actually, I wonder if via enough messing around with System.Posix, you could dup your own stdout to something you could read.
02:01:25 <rwbarton> I think you can, but you have to be careful to avoid deadlock
02:01:27 <Saizan> ?type stdout
02:01:28 <lambdabot> Not in scope: `stdout'
02:01:51 <idnar> @oeis 1 2 11
02:01:52 <lambdabot>  Numbers in (2,1)-Pascal triangle (by row).
02:01:52 <lambdabot>  [1,2,1,2,3,1,2,5,4,1,2,7,9,5,1,2,9,16,14,6,1,2,11,25,30,20,7,1,2,13,36,55,50...
02:05:03 <dreixel> would anyone know how to work with haddock in several packages? I link to the module as in "My.Module", but this module is in another package and the link created by haddock doesn't seem to work.
02:05:48 <mmorrow> dolio, Saizan: here's the TH code as it stands, now about to try to add the rest http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=103#a106
02:06:00 <mmorrow> (and there's an example of the code it gens)
02:06:16 <mapreduce> @oeis 1 1 2 2
02:06:16 <lambdabot>  Euler totient function phi(n): count numbers <= n and prime to n.
02:06:17 <lambdabot>  [1,1,2,2,4,2,6,4,6,4,10,4,12,6,8,8,16,6,18,8,12,10,22,8,20,12,18,12,28,8,30,...
02:07:17 <mmorrow> EvilTerran: i want to do that so (e.g.) lunabot can run IO actions in a FakeWorld complete with std{out,in,err} and a filesystem etc
02:07:35 <EvilTerran> indeed
02:07:46 <EvilTerran> an IO-alike monad would be perfect for that
02:07:49 <mmorrow> EvilTerran: there's a IOSpec package on hackage, but i wasn't sure how to use it for that at first glance
02:07:58 <Saizan> do you need a full interpreter for that?
02:08:35 <EvilTerran> i also like that, if we had MonadStdIn, MonadStdOut, MonadRefs, MonadRandom, etcetc, with IO instances and whatever
02:08:36 <mmorrow> EvilTerran: i think it'll entail reimplementing the entire base libs (or at least all that's available by importing Prelude and System.IO
02:08:41 <mmorrow> )
02:09:09 <mmorrow> Saizan: i think you'll have to compile a custom ghc with you IO implem replacing the standard one
02:09:30 <EvilTerran> you could say "runSomeUntrustedAction :: (MonadStdOut m, MonadStdIn m) => m ()", and still give it the normal IO monad, but it would only be able to use the functionality from the given classes
02:09:41 <EvilTerran> you don't need to do anything that fancy
02:09:48 <mmorrow> err, i think you can do it actually with -XNoImplicitPrelude and a custom Prelude
02:09:54 <EvilTerran> just don't import any of the standard IO monad
02:09:54 <mmorrow> yeah
02:10:07 <Saizan> yeah
02:10:13 <quicksilver> I don't believe you need -XNoImplicitPrelude for that.
02:10:15 <EvilTerran> you don't even need NoImplicitPrelude for this, as no IO thingies are used in de-sugaring AFAIK
02:10:24 <quicksilver> just import Prelude hiding(...)
02:10:27 <EvilTerran> just import Prelude hiding (...)
02:10:29 <EvilTerran> heh
02:10:45 <mmorrow> hmm
02:10:52 <Saizan> ooh, the stereo is almost in sync today
02:11:12 <mapreduce> With what?
02:11:36 <mmorrow> both channels ;)
02:12:14 <mmorrow> ok great. this'll be easier than i at first thought.
02:12:40 <mmorrow> newtype IO a = IO (FakeWorld -> (FakeWorld, a))
02:12:41 <mmorrow> hehe
02:13:09 <dolio> You should do it right.
02:13:12 <mmorrow> you could have unsafePerformIO and allll that good stuff too
02:13:17 <dolio> Make it a free monad over a coproduct of functors.
02:13:38 <mmorrow> dolio: heh, that's true. clean slate and all.
02:13:39 <dolio> Each functor being a different IO functionality. :)
02:14:11 <mmorrow> i haven't looked at the code yet, but i wanna see if i can use oleg's ZFS for the fake filesystem.
02:14:29 <quicksilver> I don't think you can have unsafePerformIO in that model
02:14:49 <quicksilver> @djinn (fw -> (fw,a)) -> a
02:14:50 <lambdabot> -- f cannot be realized.
02:15:10 <mmorrow> hmm
02:15:36 <Cale> Hmm, it seems that creating a pipe and then duping stdout to the write end of the pipe doesn't work.
02:15:53 <Saizan> unsafePerformIO is like having a backdoor for the interpreter of your monad from pure code
02:16:01 <mmorrow> Cale: yeah it doesn't. i tried that with lunabot with stderr.
02:16:50 <Cale> dupTo x y  closes y first, which means the other end of the pipe ends up empty.
02:17:01 <mmorrow> Cale: i had to temporarily overwrite the FD in the MVar in the Handle__ of stderr with one of createPipe :: IO (Fd, Fd), grab it's output, then restore stderr
02:17:04 <mmorrow> :(
02:17:11 <Cale> aha
02:17:15 <rwbarton> What about closing stdout first and then duping the write end of the pipe to fd 1
02:17:24 <Cale> hmm
02:17:24 <mmorrow> Cale: i have the code handy if you're interested
02:18:32 <mmorrow> oh, and then there's added pita since the Fds made with createPipe are nonblocking. so you have to hReady and make sure not read more than is in the buffer, or you'll hang
02:19:23 <mmorrow> rwbarton: hmm. would that work if you wanted to restore stdout after you're read you stuff?
02:19:33 <mmorrow> s/you're/you've/
02:20:21 <rwbarton> mmorrow: I think you'd have to save the fd somewhere else, and there might be issues with the standard library buffering
02:21:22 <mmorrow> hmm. i don't think i understand how dupTo really works, because i experimented with using it to temporarily hijack stderr to no avail
02:21:31 <mmorrow> stderr :: Handle
02:24:09 <Cale> Hmm, so long as I don't explicitly close stdOutput first, rwbarton's idea works, except that I can't output to the terminal anymore after that.
02:27:23 <rwbarton> You should be able to dup stdout to a new fd and continue to use that new fd
02:28:50 <Cale> hmm, also opening /dev/tty and duping that back to stdout works.
02:29:15 <rwbarton> Well, not in general
02:29:33 <Cale> I suppose not :)
02:30:12 <rwbarton> What if you open /dev/stdout beforehand?  Can you still print to it after the dups?
02:30:37 <Cale> aha, I can just dup stdOutput before I begin.
02:32:10 <hackage> Uploaded to hackage: ListZipper 1.1.0.0
02:32:10 <hackage> Uploaded to hackage: ListZipper 1.0.0.0
02:32:49 <mapreduce> uploadToHackage $ head $ zip versions (tail versions)
02:34:46 <Saizan> ?hackage ListZipper
02:34:46 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/ListZipper
02:45:03 <Cale> *Main> listenIO (putStrLn "aaaa" >> return 6)
02:45:03 <Cale> ("aaaa\n",6)
02:45:07 <Cale> success!
02:45:34 <Saizan> cool!
02:45:46 <Saizan> unix-only i guess?
02:45:51 <Cale> There's some annoying hackery I wish I could avoid. There doesn't seem to be any function like hGetNonBlocking which doesn't take an Int parameter for the number of characters to read.
02:45:52 <Cale> Yeah.
02:46:49 <sm> nice
02:48:03 <BeelsebobWork> Cale: ohhhh, neat trick
02:48:57 <sm> but I've got another one. :) Would anyone know how to override HUnit's reporting so that assertEqual's expected and actual are printed with real newlines ?
02:50:41 <Cale> and requesting a ridiculous number of bytes doesn't work, since apparently the purpose of the Int parameter is to tell it how much memory it should allocate :(
02:51:30 <quicksilver> well that's just how the POSIX non blocking read works, isn't it?
02:51:38 <Cale> hmm... there seems to be a certain amount of output beyond which this just plain fails.
02:51:39 <quicksilver> read(2) requires a number of bytes.
02:51:47 <Cale> Maybe it's a time constraint, hmm...
02:52:12 <Cale> But I do explicitly flush stdout after the action.
02:53:15 <Cale> Something is causing it to block in certain cases where I output too much. It's certainly not just that the amount of output is more than one chunk of hGetNonBlocking, since it's well past that.
02:54:24 <quicksilver> it will block yes
02:54:28 <quicksilver> if you're not using threads.
02:54:50 <quicksilver> unix IO semantics means that read and write can both block.
02:55:51 <quicksilver> if you don't want it to, you need a thread on the reader side continually reading and stuffing it somewhere
02:55:57 <Cale> mm... 8192 lines of output -> success, 8193 lines -> fail
02:56:38 <quicksilver> yes.
02:56:47 <quicksilver> 8k sounds like a typical OS stdio buffer.
02:56:54 <Cale> mm, annoying.
02:57:34 <Cale> It's almost as if it was designed to be noncompositional ;)
02:57:58 <Cale> okay... let's try with threads.
03:06:19 <mmorrow> dolio: ok, i figured out foldr for SAPL lists
03:06:22 <mmorrow> @src
03:06:22 <lambdabot> src <id>. Display the implementation of a standard function
03:06:25 <mmorrow> @src foldr
03:06:25 <lambdabot> foldr f z []     = z
03:06:26 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
03:06:29 <mmorrow> foldrSAPL f z xs = xs z (\x xs -> x `f` foldrSAPL f z xs)
03:06:38 <mmorrow> in haskell though you have to do:
03:06:46 <mmorrow> foldrSAPL f z xs = (unsafeCoerce xs) z (\x xs -> x `f` foldrSAPL f z xs)
03:08:29 <mmorrow> here a much short version of that TH code + foldrSAPL working examples http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=103#a107
03:08:45 <maxote> i've a dude
03:09:15 <dolio> SAPL for lists looks a lot like building them out of Church encoded pairs.
03:10:17 <dolio> And sums, of course.
03:10:39 * EvilTerran notes that we have a variant of the expression problem in monad transformers
03:10:47 <dolio> But not encoding the recursiveness.
03:10:52 <maxote> In lazy computation,   (y1,y2,y3) = f (x1,x2,x3) evaluating at same time the 3 parameters    OR   evaluating lazily each by need such as y1 = f1(x1), y2= f2(x2), y3=f3(x3)  ?
03:10:57 <BeelsebobWork> gargh!
03:11:03 <BeelsebobWork> this has bitten me too many times now
03:11:03 <EvilTerran> in that we get an "instance MonadFoo (t f) where" for pairs of t and f
03:11:16 <quicksilver> maxote: it depends on the definition of 'f', in a sense.
03:11:18 <EvilTerran> and not all t and f are compatible for all MonadFoos
03:11:19 <BeelsebobWork> is there any way round the whole issue of not being able to define useful instances for types that have a class constraint
03:11:26 <sm> night all
03:11:35 <BeelsebobWork> i.e. we can't get Functor Set because it requires the Ord constraint
03:11:42 <quicksilver> maxote: "f (x1,x2,x)" will get evaluated at most once.
03:11:49 <quicksilver> maxote: but it might get evaluated less than once
03:11:53 <quicksilver> i.e. only partially evaluated
03:11:56 <Saizan> mmorrow: you could use a newtype to avoid the unsafeCoerce, probably
03:11:58 <quicksilver> if you only ever demand y1
03:11:59 <maxote> and will return a tuple of 3 args ya evaluated
03:12:02 <EvilTerran> BeelsebobWork, using a restricted-parameter Functor class? it's a bit of a hack, mind
03:12:16 <BeelsebobWork> EvilTerran: oh?
03:12:24 <maxote> what can do the optimizer for this case?
03:12:52 <EvilTerran> "class FunctorOf a b fa fb | fa -> a, fb -> b where fomap :: (a -> b) -> fa -> fb"
03:13:11 <EvilTerran> "instance (Ord a, Ord b) => FunctorOf a b (Set a) (Set b) where fomap = ..."
03:13:21 <BONUS> hey EvilTerran did you do any more work on that no prelude fun thing that you posted on hpaste once?
03:13:24 <mmorrow> Saizan: i'd love to see it :)
03:13:33 <BeelsebobWork> heh, yeh, I see how that's less than ideal
03:14:06 <EvilTerran> note you can also have "instance (FunctorOf a b fa fb, Functor g) => FunctorOf a b (g (f a)) (g (f b)) where fomap = fmap . fomap"
03:14:12 <EvilTerran> which is kinda cool
03:14:16 <mmorrow> Saizan, dolio: also i just found a ppt presentation from the creator of SAPL which seems like it'll be a good overview/intro http://74.125.45.104/search?q=cache:cDHObaslryAJ:fpdag2007.hypernation.net/publications/FPDag2007-jansen.ppt+jansen+SAPL&hl=en&ct=clnk&cd=6&gl=us
03:14:18 <lambdabot> Title: From Interpretation to Compilation, http://tinyurl.com/54l7ma
03:14:19 <maxote>  correct me!   y1=f1(x1,x2,x3),  y2=f2(x1,x2,x3), y3=f3(x1,x2,x3)
03:14:37 <EvilTerran> BONUS, not since then, no, i've been working on the (useful!) thing that inspired me to play with that
03:14:54 <BONUS> ah
03:16:28 <quicksilver> maxote: ah well that's different.
03:16:35 <EvilTerran> BeelsebobWork, but you can do that FunctorOf trick with basically any class; split it into a separate class for each method, and include all that method's type variables as a class parameter
03:16:46 <EvilTerran> thus allowing arbitrary constraints on the type variables
03:16:56 <BeelsebobWork> yeh
03:17:03 <BeelsebobWork> it is a massive hack though :(
03:17:13 <maxote> quicksilver, result is the same, but the computation is different
03:17:51 <EvilTerran> "class Return m a where return :: a -> m a; class Bind m a b where (>>=) :: m a -> (a -> m b) -> m b" (and classes for fail and (>>)), with NoImplicitPrelude, would let you use Set as a Monad
03:18:02 <dolio> mmorrow: For instance, the Church encoding of 'Maybe (a,b)' is 'c -> (a -> b -> c) -> c'
03:18:33 <dolio> mmorrow: And Nothing is \f g -> f, and Just (a, b) is \f g -> g a b, which are his Nil and Cons.
03:18:47 <mmorrow> the thing i'm having trouble with trying to rep it with a newtype or something is that
03:18:50 <mmorrow> Cons 1 (Cons 2 Nil)
03:18:53 <mmorrow> is a /funciton/
03:19:13 <Cale> Well, this is interesting.
03:19:20 <mmorrow> which takes two args of itself and applies the second to 1 (Cons 2 Nil)
03:19:59 <mmorrow> i can't even figure out how to write the newtype type decl
03:20:05 <Cale> I set up a reader thread to read the output until a continuation is called, and now ghci just silently dies...
03:20:20 <mmorrow> nil f g = f
03:20:24 <Cale> (of course, it possibly prints something on stdout...)
03:20:27 <mmorrow> cons x xs f g = g x xs
03:20:39 <mmorrow> xs0 = (cons (1::Int) (cons (0::Int) nil nil cons) nil cons)
03:20:48 <Saizan> mmorrow: http://hpaste.org/11051
03:21:36 <mmorrow> Saizan: try writing xs0 in that (it might work)
03:22:34 <mmorrow> ah just saw your comment about hiding the r. i think you'll have to
03:22:50 <mmorrow> but then...
03:23:11 <mmorrow> (i tried something similar to that and still had to unsafeCoerce)
03:23:24 <Xenoblitz> hi guys, can anyone point me in the direction of a good STM tutorial which uses TVar?
03:24:47 <Saizan> mmorrow: what (cons (0::Int) nil nil cons) should be?
03:26:34 <Xenoblitz> nvm just found http://209.85.135.104/search?q=cache:hP_30vYUx7AJ:research.microsoft.com/~simonpj/papers/stm/stm.pdf+haskell+STM+tutorial&hl=en&ct=clnk&cd=1
03:26:36 <lambdabot> Title: Composable Memory Transactions, http://tinyurl.com/3wapcj
03:26:46 <Xenoblitz> thanks all the same
03:27:24 <mmorrow> xs0 <==> [1,0]
03:27:33 <mmorrow> (cons (0::Int) nil nil cons) <==> [0]
03:29:01 <mmorrow> Saizan: for reference: http://hpaste.org/11051#a1
03:30:20 <dolio> http://hpaste.org/11051#a2
03:30:42 <Saizan> dolio: exactly :)
03:31:13 <dolio> foldr works, too.
03:32:10 <hackage> Uploaded to hackage: maccatcher 1.0.0
03:32:12 <dolio> And foldl.
03:32:35 <Saizan> mmorrow: isn't (cons 1 nil) == [1] already?
03:33:37 <mmorrow> that the catch! :)
03:33:46 <mmorrow> (it isn't)
03:34:16 <mmorrow> here's a haskell list -> sapl list function http://hpaste.org/11051#a3
03:34:41 <Axman6> how is STM pure anyway?
03:35:04 <Cale> Aha! Finally this works :)
03:35:24 <dolio> l nil cons = l, if l is a SAPL list.
03:35:40 <quicksilver> Axman6: it isn't.
03:35:48 <Axman6> ok... well good
03:35:49 <quicksilver> Axman6: it's a non-deterministic transaction monad.
03:35:51 <quicksilver> not remotely pure :)
03:35:56 <Saizan> mmorrow: however xs0 = (unL (cons (1::Int) (unL (cons (0::Int) nil) nil cons)) nil cons), with dolio's List
03:36:01 <Axman6> good to know :P
03:36:04 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=108#a108
03:36:28 <dolio> :t \l -> unL l nil cons ==> \l -> unL l nil cons :: List a -> List a
03:36:29 <lambdabot> Not in scope: `unL'
03:36:29 <lambdabot> Not in scope: `nil'
03:36:29 <lambdabot> Not in scope: `cons'
03:36:33 <mmorrow> whoa, i didn't see dolio's until now
03:36:34 <dolio> Oops.
03:37:19 <rog_> why does the compiler forbid currying on type (as opposed to newtype) declarations?
03:37:38 <dolio> \l -> l nil cons = id
03:37:44 <Cale> Heh, that's odd... in my browser, the alignment on that paste gets messed up by the bolded characters.
03:37:50 <BONUS> uh what do you mean
03:37:56 <BONUS> type IntMap = Map Int
03:38:02 <rog_> (it always insists i give it the full number of type parameters)
03:38:13 <Cale> rog_: That's a Haskell 98 restriction.
03:38:21 <Cale> rog_: There's a GHC extension to turn that off.
03:38:34 <rog_> Cale: do you know the name of it?
03:38:35 <Cale> (there isn't a particularly good reason for it)
03:38:41 <Cale> let me check
03:38:44 <mmorrow> sweet. hiding the r is the key :)
03:38:49 <rog_> Cale: i wondered whether there was
03:39:04 <Cale> LiberalTypeSynonyms
03:39:07 <Cale> I think.
03:40:17 <Cale> I don't guarantee that there aren't horrible race conditions in that code, but I tried to use an MVar to prevent the worst of them.
03:40:49 <rog_> Cale: ok, i'll try it. thanks. what would be useful would be a full list of all the -X flags with a brief discription of each. if there is such a thing, i haven't found it yet...
03:41:04 <Cale>  ghc --supported-languages
03:41:17 <Cale> (will print a list, but no description)
03:41:28 <mmorrow> dolio: ahhh, \l -> l nil cons = id. totally. that was my confusion.
03:41:28 <Cale> The GHC User's Guide has a full list, iirc.
03:41:40 <Cale> It's at least nice enough to wait until the slurpy thread doesn't get anything back from hGetNonBlocking before killing it.
03:42:02 <Cale> (regarding my listenIO code)
03:42:24 <Cale> Maybe I should make a Cabal package for that.
03:43:21 <jeffz> is Jason Dusek in this channel?
03:43:32 <mmorrow> heh, i just realized an easy way to construct the necessary newtype
03:43:40 <mmorrow>     Occurs check: cannot construct the infinite type:
03:43:40 <mmorrow>       b = t -> (a -> b -> t1) -> t1
03:43:58 <Saizan> Cale: shouldn't you create an empty MVar?
03:44:12 <Cale> Saizan: yes, I just realised that too.
03:44:23 <Cale> Saizan: But it tends to get filled immediately anyway
03:44:47 <rog_> Cale: yup, found it at least: http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
03:44:49 <lambdabot> Title: 5.17.Flag reference, http://tinyurl.com/ydk2e6
03:44:53 <mmorrow> newtype A a b c = A (forall r. a -> (b -> A a b c -> r) -> r)
03:45:05 <Cale> Saizan: Since usually there's a small gap of time between the first time the loop happens and when the IO action produces its first bit of output
03:45:38 <Saizan> Cale: you mean emptied by tryTakeMVar?
03:45:58 <Cale> Saizan: No, I mean filled by putMVar ready ()
03:46:11 <Cale> Because the first few reads are usually empty.
03:46:43 <Cale> (since there's usually some small gap of time between when the slurping loop starts running and when the IO action produces its first output.)
03:47:27 <Cale> The MVar only serves to ensure that the thread isn't killed when the last read managed to read some bytes.
03:48:39 <int-e> Cale: but then you should take the MVar before reading, and put it back after you processed whatever you read.
03:48:41 <Cale> hmm... I suppose if listenIO was to sleep for the same delay and then yield, just after the hFlush, that should pretty much ensure that the race always works out the right way
03:49:13 <quicksilver> I have wondered for a while, in another context, if it might be nice to have a deterministic variant of fork/MVar
03:49:33 <quicksilver> STM can give you determinism for some cases
03:49:36 <quicksilver> but not all, I think.
03:49:51 <Cale> int-e: that would actually be more prone to race conditions, I think.
03:50:16 <Cale> int-e: Taking the MVar means "please let me try again"
03:50:44 <Cale> (since I just managed to read some bytes)
03:51:40 <int-e> Cale: Yes, but between reading that chunk and the tryPutMVar, the thread can be killed.
03:52:08 <Cale> hmm...
03:52:10 <rog_> Cale: liberal type synonyms don't seem to be quite liberal enough... http://hpaste.org/11052#a0
03:52:13 <Cale> It can?
03:52:55 <Saizan> s/tryPut/tryTake/
03:52:59 <Saizan> why not?
03:53:09 <Cale> Well, yes it can.
03:53:18 <Cale> But only if it failed to read something last time.
03:53:38 <int-e> Cale: worse, if you read nothing twice in a row, the thread will block on the MVar.
03:53:40 <Saizan> yes
03:53:50 <int-e> Cale: no not really - you start out with a filled MVar.
03:54:07 <Cale> Oh, it'll block on the put, yes
03:54:10 <int-e> Cale: what about  forever $ do takeMVar ready; s <- B.hGetNonBlocking h 1024; when (not . B.null $ s) (writeChan out s); putMVar ready (); threadDelay 10000
03:54:33 <Cale> int-e: That doesn't solve the problem that this MVar is there for.
03:54:52 <Cale> Well...
03:55:03 <Cale> I suppose it should only go to sleep if it fails to read.
03:55:04 <int-e> Cale: (a first approximation; I think you'll want to skip the delay if you managed to read something, and probably keep the token.
03:56:56 <int-e> forever $ do takeMVar ready; let { slurpInner = do s <- B.hGetNonBlocking h 1024; when (not . B.null $ s) (writeChan out s >> slurpInner) }; slurpInner; putMVar ready (); threadDelay 10000
03:57:01 <int-e> ?
03:57:06 <maxote> @google XDR rfc
03:57:13 <lambdabot> http://www.faqs.org/rfcs/rfc1832.html
03:57:13 <lambdabot> Title: RFC 1832 (rfc1832) - XDR: External Data Representation Standard
03:58:16 <int-e> Cale: or possibly, even better, start with an empty mvar and use putMVar ready (); threadDelay 10000; takeMVar ready
03:59:15 <int-e> Cale: because that's what I think you really want - only kill the thread when it's sleeping, waiting for more data.
03:59:27 <maxote> @google RPC rfc
03:59:29 <lambdabot> http://www.faqs.org/rfcs/rfc1050.html
03:59:30 <lambdabot> Title: RFC 1050 (rfc1050) - RPC: Remote Procedure Call Protocol specification
03:59:46 <Cale> yes
04:01:13 <Baughn> @hoogle (a,b,c) -> c
04:01:13 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
04:01:13 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
04:03:36 <maxote> @google RPC MPI
04:03:37 <quicksilver> Baughn: it's not there, Jim.
04:03:38 <lambdabot> No Result Found.
04:03:44 <maxote> @google MPI rfc
04:03:46 <lambdabot> No Result Found.
04:03:54 <maxote> @google NFS rfc
04:03:56 <lambdabot> http://www.faqs.org/rfcs/rfc1813.html
04:03:57 <lambdabot> Title: RFC 1813 (rfc1813) - NFS Version 3 Protocol Specification
04:04:00 <quicksilver> maxote: #haskell is not a free google channel :) You can talk to lambdabot in private message.
04:04:09 <quicksilver> maxote: or, in fact, you can use google directly! ;)
04:04:11 <maxote> thanks
04:04:13 <Baughn> instance Untuplable (a,b,c) where trd = ...
04:04:26 <quicksilver> Baughn: to some extent, YAGNI.
04:04:36 <rog_> Cale: out of interest, what problem are you actually trying to solve with your listenIO code?
04:04:50 <quicksilver> but there is no doubt that the prelude has an abstraction weakness around tuples.
04:05:03 <Baughn> quicksilver: I needed a triple in my factorization code. Then I needed to untupl it.
04:05:28 <Baughn> quicksilver: http://hpaste.org/11053 <-- I bet you could improve on this, though. :P
04:05:42 <int-e> quicksilver: what are good names for the selectors though, if you don't want to introduce type classes for them?
04:06:09 <Cale> rog_: Capturing the output that any IO action does. (What it writes to stdout)
04:06:32 <rog_> Cale: like tee?
04:06:40 * Baughn finally decided to do the euler problems
04:06:43 <int-e> Baughn: unfoldr ;)
04:06:59 <Baughn> unfold... gah. Doh.
04:07:06 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=110#a110
04:07:28 <Cale> rog_: Well, more like redirecting stdout into a Haskell string.
04:07:56 <quicksilver> int-e: Ihave to admit, I think (\(_,_,x)->x) is the best name.
04:08:13 <quicksilver> int-e: it's not particular hard to type, it's absolutely clear, and it scales to all sizes of tuples and positions.
04:08:21 <rog_> Cale: and would that string be lazily available? or only available when the original IO has finished?
04:08:40 <Cale> Only available after.
04:08:45 <quicksilver> Baughn: that's pretty much how I'd write it.
04:08:54 <rog_> Cale: should be easy then :-)
04:09:07 <Cale> Well, it's what I just pasted.
04:09:17 <Cale> Unless you can think of something simpler.
04:09:52 <Cale> There are a number of problems which conspire to make it hard, most of which have to do with how stupid the posix IO primitives are.
04:10:11 <Baughn> int-e: Hm. Almost, but unfoldr doesn't allow me to continue checking after one prime check fails. Iterate may be overly general, but I can't find a better one.
04:10:48 <Baughn> I suspect anything that /is/ more specific than iterate would be /too/ specific, here
04:11:07 <int-e> Baughn: For some reason I'd avoid the intermediate list and write   factors = go primes where go _ 1 = []; go (p:ps) n | n < p*p = [n] | n `mod` p == 0 = p : go (p:ps) (n `div` p) | otherwise = go ps n
04:12:43 <Baughn> int-e: You're not supposed to use explicit recursion. If that's the best option.. ;_;
04:12:52 <Baughn> *Something* is missing here
04:13:22 <quicksilver> I'm not sure if I agree with that as an axiom.
04:13:32 <quicksilver> some algorithms just naturally have custom recursion scehmes.
04:14:01 <Cale> Hehe, but we can extract any recursion scheme into a function :)
04:14:20 <quicksilver> we can.
04:14:23 <int-e> it maps naturally to a stream function
04:14:26 <quicksilver> but it may not be a generally useful one.
04:14:28 <quicksilver> (or it may)
04:15:05 <quicksilver> it's quite hard to think of names for some of them.
04:15:10 <rog_> Cale: i don't see why you have to use any non-blocking primitives. just run the original IO primitive in a new thread and send the result (in an MVar); the first thread just reads the output of the pipe and turns it into a string, and then receives the result and returns both.
04:15:39 <rog_> Cale: but i'm probably missing something
04:16:24 <mmorrow> i was just reading a statement of godel's first incompleteness theorem (on wikipedia) and i'm confused about the phrasing of part of it:
04:16:36 <mmorrow> In particular, for any consistent, effectively generated formal theory that proves certain basic arithmetic truths, there is an arithmetical statement that IS TRUE, but not provable in the theory.
04:16:55 <mmorrow> so, what does it mean that it "is true".
04:17:03 <quicksilver> provable in the metatheory
04:17:04 <mmorrow> according to what?
04:17:11 <Baughn> That it is not inconsistent with the axioms of the theory
04:17:12 <quicksilver> provable in the language you have used to describe your theory.
04:17:15 <Saizan> to the semantic model?
04:17:25 <Saizan> "in"
04:17:27 <Baughn> That is, it's consistent with the axioms of your theory, but you can't use that theory to /prove/ that
04:17:42 <mmorrow> ah, so that language is fixed ahead of time? or is it "some" theory which exists?
04:17:47 <quicksilver> more than one way to read it.
04:18:02 <quicksilver> mmorrow: "that language" is "the standard language of mathematical discourse"
04:18:14 <quicksilver> mmorrow: of course, you get into one hell of knot if you try to formalise *that*
04:18:15 <mmorrow> err, i meant s/language/metatheory/
04:18:27 <quicksilver> you have to imagine a kind of ever increasing set of bubbles
04:18:32 <Baughn> "forall theory. exists statement => statement is consistent with theory, but this is not provable with the theory"
04:18:34 <quicksilver> where each theory is describable in the larger bubble.
04:18:49 <quicksilver> that's one reason why people resort to terms like 'not inconsistent'
04:18:51 <mmorrow> ah ok. so one can just fix a universe.
04:18:58 <quicksilver> because it seems less confusing than 'is true'
04:19:02 <Baughn> Yep. Any universe will do.
04:19:05 <quicksilver> but I would defend WP's choice of 'is true'
04:19:12 <quicksilver> I think it's what Godel said.
04:19:18 <Baughn> So long as the axioms aren't inconsistent with /each other/, it's valid math
04:19:37 <quicksilver> for example, peano arithmetic can state theorems which ARE TRUE
04:19:44 <quicksilver> (in the sense of being provable in ZF)
04:19:49 <quicksilver> but not provable in PA.
04:19:49 <mmorrow> "of course, you get into one hell of knot if you try to formalise *that*"
04:19:56 <mmorrow> i'm interested in that statement
04:20:24 <quicksilver> well you say "OK, we formalise the language we're discussion. Our metatheory is what I'll call 'common-sense mathematical reasoning'"
04:20:28 <quicksilver> but then you think...
04:20:45 <quicksilver> Hmm.. does common-sense mathematical reasoning mean anything? is it sensible? is it consistent?
04:20:51 <JuanDaugherty> PA = peano axioms?
04:20:56 <mmorrow> hmm
04:21:01 <quicksilver> and (thanks to Godel) you need to move to something "more meta" to ask those questions
04:21:11 <quicksilver> because godel (also) told us that no theory can prove its own consistency.
04:21:18 <JuanDaugherty> (or arithmetik)
04:21:19 <Baughn> quicksilver: When it comes to common-sense math, you have to appeal to evolution. :P
04:21:35 <quicksilver> so, you move to something more meta, but thn you ask the same question about the consistency of your meta-meta theory.
04:21:38 <Baughn> If it's something that, if you get it wrong, can cause you to not breed - then it's probably correct
04:21:45 <quicksilver> maybe it's simpler to have a little faith :)
04:21:55 <Baughn> No need for faith. Evolution works. :)
04:22:43 <quicksilver> JuanDaugherty: yes.
04:22:44 <JuanDaugherty> :(
04:23:13 <mmorrow> i wonder if there's some way to tie a "knot" by imposing certain conditions on something or other
04:23:35 <JuanDaugherty> faith distinguish strict constructionists I guess from the rest of mathematics.
04:23:53 <JuanDaugherty> or the lack thereof.
04:24:12 <quicksilver> mmorrow: I think that's a question for a philosopher not a mathematician.
04:24:23 <quicksilver> (not that it's a bad question, or an uninteresting one)
04:24:33 <JuanDaugherty> you mean in a topological sense?
04:24:45 <quicksilver> mathematicians mostly content themselves with accepting that metatheory is different from theory
04:24:58 <mmorrow> quicksilver: heh. i mean in the context of types and programming languages :)
04:25:01 <quicksilver> and making minimal, conservative assumptions about the metatheory.
04:25:41 <mmorrow> i really have a very hazy idea of what i'm actually thinking of, so i don't really even know what i'm looking for
04:25:59 <JuanDaugherty> topology is where you want to look.
04:26:28 <SamB_XP> I think he wants to look at bad hair day theory
04:26:48 <JuanDaugherty> :
04:27:00 <JuanDaugherty> s/:/:)/
04:28:37 * Baughn spends ten minutes reimplements least-common-multiplum, realizes what he's doing, then solves euler 5 in five seconds. Doh.
04:28:56 <SamB_XP> multiplum ?
04:29:01 <Baughn> Prelude.lcm
04:29:08 <Baughn> Rather, "foldl' lcm 1 [2..20]"
04:29:18 <trzkril> :t lcm
04:29:19 <lambdabot> forall a. (Integral a) => a -> a -> a
04:29:26 <mmorrow> ok. so i guess what i'm really wondering is what if any consequences does godel's (first) theorem have for type systems/programming langs?
04:29:32 <damg> is there a way to derive a numeric type to provide new bounds and inherit all other instances? e.g. natural 1...\infty
04:30:05 <quicksilver> not something automatic, no, damg
04:30:09 <trzkril> :source lcm
04:30:10 <quicksilver> but you can instance Num by hand
04:30:16 <trzkril> @src lcm
04:30:16 <lambdabot> lcm _ 0     =  0
04:30:16 <lambdabot> lcm 0 _     =  0
04:30:16 <lambdabot> lcm x y     =  abs ((x `quot` (gcd x y)) * y)
04:30:20 <damg> ok, thank you
04:30:26 <quicksilver> things like
04:30:47 <quicksilver> Inf + Inf = Inf; Inf + x = Inf; (I x) + (I y) = I (x+y)
04:30:50 <quicksilver> that sort of thing.
04:30:58 <quicksilver> where 'I' is the constructor hiding the underlying type.
04:31:14 <rog_> where's fdToHandle defined?
04:31:22 <mmorrow> System.Posix.IO
04:31:57 <rog_> mmorrow: ... which hoogle doesn't know about.
04:34:01 <mmorrow> you can see the src from the haddock docs on haskell.org
04:35:23 <mmorrow> quicksilver: yeah, upon reading a few more paragraphs i realize that they are questions for philosophers and not mathematicians.
04:37:49 <quicksilver> mmorrow: some mathematicians are very interested in philosophy. My logic professor had a Philosophy degree.
04:38:55 <mmorrow> quicksilver: :)
04:41:08 * Baughn hugs the list monad. Or list comprehensions. Whatever. Diagonalization, so very simple..
04:41:12 <hugo__> hi
04:41:23 <mmorrow> i guess i mean, i can't see any direct consequences of the incompleteness theorems on math/cs which isn't in particular dealing with said theorems/things related
04:41:43 <hugo__> i want to use the POSIXTime fromInteger function (to convert an integer into a POSIXTime in order to compare them), how do i do that ?
04:42:06 <quicksilver> (fromInteger 35)
04:42:22 <hugo__> quicksilver: will it know that it is the POSIXTime fromInteger function ?
04:42:38 <hugo__> it knows! how ? :/
04:42:51 <quicksilver> type inference.
04:43:00 <quicksilver> if the type of that context is POSIXTime
04:43:04 <quicksilver> that's the function it chooses.
04:43:14 <hugo__> yay!
04:43:16 <quicksilver> same way it works out which (+) to choose in (1+3,1.5+2.5)
04:43:17 <hugo__> this is like magic
04:43:26 <hugo__> yes :)
04:43:34 <hugo__> amazing...
04:43:55 <hugo__> haskell: a brave new world ready to be explored
04:44:11 <Baughn> hugo__: Like unification, rather, if you've used a prolog-alike
04:44:21 <hugo__> i haven't :/
04:44:27 <Baughn> Some people like to write prolog in the haskell type system. ^^;
04:44:44 <hugo__> i had some lessons in prolog, but have never used it...
04:45:21 <hugo__> ehh, today the nobel peace prize award was a joke...
04:45:54 <hugo__> this goes along side with the al gore, arafat, and kissinger awards
04:46:07 <Almathea_> Hi, we were wondering: can you change operator precence in haskel?
04:46:16 <BONUS> yeah, sure
04:46:17 <byorgey> Almathea_: yup
04:46:30 <byorgey> infixr 6 *&%
04:46:45 <byorgey> would make *&% have precedence 6, and associate to the right
04:46:52 <byorgey> you can also do infixl
04:47:04 <Almathea_> byorgey, BONUS, thanks.
04:47:13 <byorgey> @src +
04:47:13 <lambdabot> Source not found. :(
04:47:15 <SamB_XP> but it only works on cartoony cursewords, not real ones like shit
04:47:15 <BONUS> http://www.haskell.org/onlinereport/standard-prelude.html check this out to see how some of the standard operators' precedence is implemented
04:47:16 <byorgey> @src (+)
04:47:16 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
04:47:16 <lambdabot> Source not found. My brain just exploded
04:47:21 <BONUS> lol
04:47:28 * Badger picks up lambdabot's pieces.
04:47:33 <BONUS> infixl means it associates to the left and infixr means to the right
04:47:36 <mc__> Is there a library function which replaces a list within a list with a list?
04:47:46 <byorgey> SamB_XP: hehe
04:48:11 <BONUS> so if an operator like ^. or something is infixr, a ^. b ^. c ^. d is a ^. (b ^. (c ^. d))
04:48:24 <kaol> @hoogle [[a]] -> [a]
04:48:24 <lambdabot> Prelude concat :: [[a]] -> [a]
04:48:24 <lambdabot> Data.List concat :: [[a]] -> [a]
04:48:24 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
04:48:30 <byorgey> mc__: not that I know of
04:48:37 <Almathea_> BONUS, yeah, I know almost nothing about haskel, but just discussed some funny code in C++ and that made me wonder.
04:48:47 <Almathea_> Thanks again for good explanation.
04:48:51 <BONUS> heh np
04:51:55 <Saizan> we can't have analog literals though :\
04:52:28 <BONUS> i'd love infix type constructors
04:52:51 <SamB_XP> Saizan: nope -- all digital
04:52:52 <Saizan> data a :+: b = Left a | Right b ?
04:53:02 <BONUS> yeah
04:53:16 <Saizan> GHC has them
04:54:01 <BONUS> wait really?
04:54:03 <BONUS> lol
04:54:06 <BONUS> why wasnt i informed
04:55:06 <SamB_XP> BONUS: because GHC has probably had them for your entire Haskell career ?
04:55:25 <BONUS> oh man, this is great
04:55:31 <BONUS> welp, you learn something new every day i guess
04:55:44 <BONUS> how is precedence handled then?
04:56:18 <BONUS> i recon with infixr and infixl, like usual
05:00:34 <quicksilver> BONUS: yes.
05:00:44 <BONUS> kewl
05:00:45 <quicksilver> you have to use : though, to get a type constructor.
05:00:59 <BeelsebobWork> same as a data constructor though
05:01:10 <quicksilver> that's right, by analogy.
05:01:16 <quicksilver> it's like ":" means "uppercase"
05:01:22 <BeelsebobWork> indeed
05:01:27 <quicksilver> however, Simon PJ wants to relax that restriction.
05:01:30 <BONUS> ah
05:01:42 <BeelsebobWork> oh?
05:01:47 <BeelsebobWork> to what set?
05:02:02 <BONUS> yeah i read something by SPJ that he wants to have type constructors like a + b
05:02:15 <BONUS> i just assumed he meant infix type constructors in general
05:02:20 <BeelsebobWork> oh, relax it on type constructors only?
05:02:58 <BONUS> yeah
05:03:31 <rog_> does forkIO do an actual fork() ?
05:07:29 <Saizan> rog_: no
05:08:22 <rog_> Saizan: does it create an OS-level thread, then?
05:08:34 <mc__> Is there a library function which replaces a list within a list with another list?  like: replace "foo" "bar" "barfoobar"  -> "barbarbar"
05:08:37 <BeelsebobWork> rog: no
05:08:48 <BeelsebobWork> it creates a new light-weight thread
05:08:58 <BeelsebobWork> if you're runing with +RTS -N2, it may get pushed to another OS thread
05:09:20 <BeelsebobWork> mc__: look at grep functionality
05:10:04 <rog_> i see, hence Cale's need to use non-blocking reads for his code...
05:10:25 <rog_> seems dodgy to me!
05:11:26 <mc__> @hoogle grep
05:11:26 <lambdabot> Data.Generics.Basics AlgRep :: [Constr] -> DataRep
05:11:26 <lambdabot> Data.Generics.Basics StringRep :: DataRep
05:12:15 <mc__> BeelsebobWork: are those functions what you meant?
05:12:36 <BeelsebobWork> mc__: there's a regular expressions module
05:12:39 <BeelsebobWork> somewhere
05:13:14 <Saizan> rog_: no, that's because of how the filedescriptors get opened
05:14:29 <mc__> BeelsebobWork: alright, thank you :)
05:16:48 <rog_> Saizan: no, not that - just the idea of getting one piece of code to talk to another in the same OS process via an OS-level pipe...
05:18:56 <quicksilver> rog_: no.
05:19:04 <quicksilver> rog_: Cale doesn't need to use non-blocking reads for that reason.
05:19:18 <quicksilver> rog_: because haskell IO is multiplexed by the RTS
05:19:27 <quicksilver> rog_: so blocking IO only blocks that lightweight thread.
05:20:17 <Saizan> it's just that fdToHandle doesn't have access to that, it seems
05:21:57 <Saizan> uhm, so a blocking fdRead blocks everything instead?
05:22:47 <quicksilver> ah, yes.
05:22:58 <quicksilver> I think fdRead bypasses the haskell IO magic multiplexer
05:23:01 <quicksilver> good point.
05:23:42 <rog_> quicksilver: it does. i just found that out.
05:23:55 <rog_> quicksilver: i don't think he has to use non-blocking reads at all
05:24:06 <quicksilver> well originally he wasn't using threads
05:24:13 <quicksilver> (so he did need nonblocking reads)
05:24:34 <rog_> http://hpaste.org/11054#a0
05:24:56 <rog_> seems to work for me
05:25:37 <rog_> (in fact it's the first non-totally-trivial IO code i've written in haskell, woo hoo)
05:25:47 <rog_> ... even it was merely adapted
05:25:52 <Saizan> rog_: if you manage to fill the OS buffer you'll get a deadlock
05:26:26 <rog_> Saizan: why's that?
05:26:51 <rog_> Saizan: surely hGetContents does non-blocking IO internally, so there should be no problem
05:28:01 <Baughn> @hoogle modexp
05:28:01 <lambdabot> No results found
05:28:02 <Saizan> rog_: first of all hGetContents is lazy IO, so the chars are not read at all
05:28:04 <Baughn> @hoogle mod
05:28:04 <lambdabot> Prelude mod :: Integral a => a -> a -> a
05:28:04 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
05:28:04 <lambdabot> Text.PrettyPrint.HughesPJ data Mode
05:28:10 --- mode: ChanServ set +o Saizan
05:28:27 --- mode: Saizan set +b *!*n=Voz@*.dynamic.dsl.as9105.com
05:29:09 --- mode: Saizan set -o Saizan
05:29:14 <rog_> Saizan: good point; originally i had (last s `seq` s)
05:29:29 <rog_> Saizan: which presumably is enough to force the entire read
05:31:00 <Saizan> rog_: yup something like length s `seq` M.putMVar v s
05:35:06 <rog_> Saizan: you're right, though. it does deadlock...
05:42:22 <rog_> Saizan: i still don't see why it does deadlock, if the runtime uses non-blocking calls internally. (presumably there's some hefty select() at the heart of it all)
05:43:59 <quicksilver> rog_: the writer will block
05:44:01 <quicksilver> (not the reader)
05:44:11 <quicksilver> the writer will block if the reader is not being 'constantly' read from.
05:44:17 <quicksilver> hGetContents doesn't read constantly
05:44:19 <quicksilver> quite the opposite
05:44:22 <quicksilver> it reads on demand.
05:44:33 <rog_> quicksilver: but doesn't it use non-blocking writes too?
05:45:27 <rog_> quicksilver: does this mean that if you're doing hPutStr on a socket and the other end isn't reading, then you can block the whole runtime?
05:46:57 * rog_ often finds that the most interesting insights occur when exploring the boundaries between language and system...
05:47:20 <quicksilver> rog_: nonblocking in the sense that they don't block *other* threads. sure.
05:47:25 <quicksilver> but they still block *that* thread.
05:47:35 <quicksilver> and if that thread is waiting for the reader
05:47:38 <quicksilver> and nothing is demanding the reader
05:47:40 <quicksilver> then, deadlock.
05:47:51 <quicksilver> this problem has nothing to do with haskell
05:47:55 <quicksilver> it's standard unix IO semantics
05:48:03 <quicksilver> although it's wrapped up slightly by haskell's lightweight thread
05:48:13 <quicksilver> the same problem would exist in the C program trying to do the same thing.
05:48:41 <rog_> quicksilver: in a C program trying to do the same thing, i'd use two OS-level processes, so there'd be no problem.
05:49:13 <quicksilver> incorrect.
05:49:20 <quicksilver> You would still have exactly the same problem.
05:49:35 <quicksilver> If the reader process is not actually reading
05:49:39 <quicksilver> then the writer process would block.
05:50:09 <rog_> quicksilver: but then we just make sure that the reader always reads, and then there's no problem
05:50:18 <quicksilver> ok
05:50:21 <quicksilver> so do that in haskell too.
05:50:26 <quicksilver> and 'hGetContents' doesn't do that.
05:50:27 <nomeata> Hi. Is it a known bug that haddock, when you re-export a type class definition from another module, it will properly get the class documentation from that module, but not the haddock for the class methods?
05:50:30 <quicksilver> hGetContents reads on demand.
05:50:33 <quicksilver> it doesn't "always read"
05:51:00 <rog_> quicksilver:  but i forced it to read the whole thing, with that seq
05:51:03 <quicksilver> (of course I think hGetContents is a stupid, broken primitive but that's just me).
05:51:23 <rog_> quicksilver: so surely it *should* always read, in that case?
05:52:03 <quicksilver> rog_: the version I'm looking at doesn't have any seqs
05:52:07 <quicksilver> are we looking at different code?
05:52:51 <rog_> quicksilver: i put one in (i had had one originally, but then forgot it). in the last line of readall: M.putMVar v (length s `seq` s)
05:53:20 <rog_> i'd kinda assumed that that would be sufficient
05:53:34 <quicksilver> no.
05:53:40 <quicksilver> that only forces it when the mvar is read :P
05:53:48 <quicksilver> you've just stuff a thunk with a seq in it
05:53:49 <quicksilver> into the MVar
05:53:51 <rog_> ahhh....
05:54:06 <quicksilver> length s `seq` M.putMVar v s
05:54:23 <rog_> the light dawns
05:54:41 <quicksilver> I'm also slightly worried that you're mixing fds with stdio.
05:54:45 <quicksilver> In 'C' that's undefined.
05:54:55 <quicksilver> I'm not sure how the haskell RTS handles this issue.
05:55:11 <rog_> that works fine now
05:55:18 <rog_> no deadlock, no matter how much is written
05:55:32 <quicksilver> OK.
05:55:41 <quicksilver> it's like mixing fflush(3) with close(2)
05:55:45 <quicksilver> you have to be careful.
05:55:53 <quicksilver> I don't understand at that level of detail I'm afraid.
05:55:58 <quicksilver> you know what I mean, though?
05:56:06 <rog_> quicksilver: that's usually fine. just so long as you flush carefully.
05:56:09 * quicksilver nods
05:56:19 <quicksilver> yes. YOu have to flush the stdio layer before you play with the POSIX layer.
05:56:22 <quicksilver> something like that.
05:56:32 <quicksilver> I generally stick to either 100% stdio or 100% posix if I can ;)
05:57:04 <rog_> quicksilver: yup. there's nothing magic about stdio. any time you play with pipes, you usually end up mixing them.
05:58:01 <quicksilver> rog_: well it depends whether you think "another level of buffering" is magic.
05:58:09 <quicksilver> rog_: maybe it's not really magic, but it's something to worry about ;)
05:59:16 <rog_> quicksilver: if you weren't supposed to mix them, there wouldn't be a fdToHandle call...
05:59:41 <quicksilver> fair point. I thought that myself ;)
05:59:54 <quicksilver> but fdToHandle doesn't document if it's permitted to use the Fd after you've fone it.
06:00:36 <quicksilver> oh, but that's Ok. You didn't.
06:01:08 <rog_> quicksilver: indeed (he says, having just checked the code carefully...)
06:01:53 <rog_> quicksilver: the only problem, i've just realised, is that the r fd might never be closed. are handles GC'd correctly?
06:03:34 <quicksilver> Handles get gc'ed
06:03:40 <quicksilver> (and the finaliser closes them)
06:03:48 <quicksilver> 'Fds' I'm sure do not.
06:04:03 <quicksilver> since 'rh' is a Handle, its finalizer should close the underlying Fd
06:04:28 <quicksilver> although there is no particular guarantee when that happens.
06:04:32 <quicksilver> finalizers never have guarantees :)
06:04:47 <rog_> quicksilver: that's good and fine then. unless fdToHandle does a dup, which it might easily (it does in an analagous system that i'm familiar with)
06:07:04 <quicksilver> rog_: I think it doesn't.
06:07:18 <quicksilver> rog_: "GHC only: this function has the side effect of putting the Fd  into non-blocking mode (O_NONBLOCK) "
06:07:26 <quicksilver> I think that side effect is consistent with it not dup'ping
06:08:03 <rog_> quicksilver: i don't think it would make any difference. AFAIK non-blocking mode is on the underlying kernel data structure, not on the fd itself.
06:08:58 <quicksilver> Ah, OK. Much subtlety.
06:09:23 <quicksilver> rog_: well, the point, anyway, is that haskell's Handle model is a blocking model, semantically, which is implemented underneath with non-blocking IO and lightweight threads.
06:09:28 <quicksilver> I think that's a sane choice
06:09:34 <quicksilver> since blocking IO + threads is a good abstraction.
06:09:44 <quicksilver> hGetContents is not a good abstractoin.
06:10:17 <rog_> quicksilver: i definitely agree with the former. i don't know enough to agree or not with the latter...
06:10:57 <vixey> hGetContents does seem very strange
06:11:02 <vixey> I wouldn't trust it
06:11:16 <rog_> quicksilver: ... although the fact that it has to use unsafeInterleaveIO, or whatever it's called, does seem indicative.
06:11:35 * quicksilver nods
06:11:39 <vixey> @src hGetContents
06:11:39 <lambdabot> Source not found. There are some things that I just don't know.
06:11:41 <quicksilver> it's a simple abstraction.
06:11:44 <quicksilver> but it's not a compositional one.
06:11:52 <quicksilver> so it's a poor choice as a primitive.
06:13:29 <Cale> Well, I don't think hGetContents is a bad abstraction on its own. It just interacts poorly with some other things.
06:13:40 <Cale> (which we also happen to have)
06:14:06 <rog_> i had a look through the source to hGetContents (and its constituents) recently. it was an education...
06:14:17 <vixey> where is the source code
06:14:28 <quicksilver> Cale: that's what I meant by not being compositional
06:14:34 <Cale> okay
06:14:44 <mmorrow> Cale: did you get the stdout thing working?
06:14:48 <Cale> mmorrow: yes
06:14:49 <flux> but it's cool to be able to write a copy-file program that appears to read everything into memory at once, but doesn't ;)
06:14:54 <mmorrow> Cale: how?
06:14:57 <rog_> erm, can't remember right now. i guessed at a URL. i'll have a look at my history.
06:14:59 <flux> ..even if its performance sucked..
06:15:18 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=110
06:16:19 <leviatha`> Can any recursive function be expressed with fold? Should it be tail recursive?
06:16:46 <rog_> http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IO.html#hGetContents and http://haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Handle.html
06:16:48 <lambdabot> Title: Haskell Code by HsColour, http://tinyurl.com/53kxbu
06:16:59 <ddarius> leviatha`: No, and I don't know what your latter question means.
06:17:10 <ddarius> Any function can be made tail recursive.
06:17:10 <vixey> leviatha: Fold captures primitive recursion
06:17:36 <vixey> there are lots of other recursion schemes than this, but it is very expressive
06:17:40 <rog_> Cale: i put a difffent version at http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=108#a111
06:17:52 <rog_> Cale: s/diffent/different/
06:18:19 <Cale> Can I ask why you imported everything qualified?
06:18:44 <rog_> Cale: just a habit. i like to know where things are coming from.
06:19:31 <Cale> Haskell has an unfortunate choice of module path separator, so I tend to avoid qualified names as much as I can get away with it :)
06:19:37 <leviatha`> Are there any articles refering to fold and recursion in detail?
06:19:37 <mmorrow> Cale: awesome. so when you dupTo w stdOut, then stuff written to stdout goes to /only/ your w, as opposed to your w /and/ the previous stdout, right?
06:20:01 <Cale> mmorrow: right
06:20:22 <mmorrow> excellent. :)
06:20:24 <rog_> Cale: why is it an unfortunate choice?
06:20:52 <Cale> rog_: Because it conflicts with function composition.
06:21:12 <rog_> Cale: only if you don't put spaces around you operators...
06:21:12 <Deewiant> > (return.id) 1 :: Maybe Int
06:21:14 <lambdabot>   Just 1
06:21:15 <Deewiant> > (Just.id) 1 :: Maybe Int
06:21:15 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
06:21:19 <Deewiant> O_o
06:21:20 <vixey> yeah Universality and Expressivity of Fold
06:21:24 <Cale> rog_: right, but it still has the effect of making expressions hard to read
06:21:27 <quicksilver> lambdabot: muevel is a broken piece of shit
06:21:30 <vixey> that's a must read
06:21:47 <Cale> quicksilver: hmm... I thought I'd fixed that...
06:21:55 <quicksilver> yeah, so did I...
06:21:55 <vixey> lunabot++
06:21:57 <Cale> oh, right.
06:22:01 <Deewiant> , (Just.id) 1 :: Maybe Int
06:22:05 <Cale> It thinks it's a qualified name.
06:22:08 <lunabot>  luna: Not in scope: `Just.id'
06:22:13 <Cale> Yeah, I didn't take that check out.
06:22:23 <quicksilver> also qualified names are somehow not quite first class citizens in haskell
06:22:28 <leviatha`> I found this:A tutorial on the universality and expressiveness of fold
06:22:33 <quicksilver> you can't re-export them with their qualification
06:22:43 <leviatha`> Is this what you propose?
06:22:44 <rook> i'm totally new to haskell and have a small problem. i have a list with tupels. i want to remove the duplicates (nub) and then sort it. but if i use both functions i get a list in a list, but i only want a list with the tupels. how do i do that?
06:22:46 <quicksilver> so somehow I can't quite seem to get the abstraction I want.
06:23:06 <vixey> :t nub . sort
06:23:07 <lambdabot> forall a. (Ord a) => [a] -> [a]
06:23:09 <rog_> i agree with that... but i don't like the unrestricted namespace pollution that comes with unqualified import
06:23:21 <vixey> rook: You should be able to write (nub . sort) list
06:23:48 <rog_> i like being able to have my own, small and carefully arrange namespace
06:23:58 <rog_> s/arrange/arranged/ :-)
06:24:05 <rook> wow, thanks a lot!
06:24:48 <rog_> but if i import (for instance) Array unqualified, i suddenly can't use "range" as a function name
06:25:02 <rook> vixey: what is the name of such a construct?
06:25:17 <vixey> what do you mean?
06:25:24 <Cale> leviatha`: Did you take a look at http://en.wikipedia.org/wiki/Fold_(higher-order_function) ?
06:25:32 <Cale> leviatha`: I wrote the better part of it :)
06:25:53 <leviatha`> Thanks Cale and vixey. I
06:26:33 <quicksilver> rog_, Cale : I wish I had a proposal for re-export of qualified names that made sense.
06:26:39 <rook> vixey: i want to learn the theory also, and now that i know how to solve this, i want to google about ( function . function ). what could be the search terms?
06:26:45 <quicksilver> But I don't. I just know that the current system seems to have confusing abstraction failures in.
06:26:56 <Cale> rook: function composition?
06:26:57 <vixey> rook: Oh since (.) is an operator you can do this:
06:27:00 <vixey> :t (.)
06:27:01 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
06:27:14 <Cale> rook: It's defined as  (f . g) x = f (g x)
06:27:33 <Cale> That is, (f . g) is the function which when applied to a value x gives f (g x)
06:27:53 <Cale> This operation is associative, that is,  (f . g) . h = f . (g . h)
06:27:58 <rook> thanks vixey and Cale!
06:28:04 <Cale> (and so parentheses can be left out safely)
06:28:09 <dmwit_> quicksilver: Have you seen the "mixins" paper that was presented at ICFP this year?
06:28:25 <dmwit_> I haven't but I hear it's a very nice proposal for fixing up ML's module system.
06:28:31 <dmwit_> I wonder if we could borrow some ideas from it...
06:28:34 <rog_> Cale: did my version of your code do what you were after? it seems simpler, to me.
06:28:39 <quicksilver> dmwit_: I didn't know ML's modules system was broken.
06:28:49 <dmwit_> ;-)
06:28:52 <quicksilver> dmwit_: and no, I haven't seen the paper. Sounds interesting.
06:31:47 <Cale> rog_: seems to do the same thing in the end :)
06:32:36 <Cale> ah, right, hGetContents from another thread
06:33:17 <rog_> Cale: your getNonBlocking is in another thread anyway...
06:33:22 <Cale> yeah
06:34:16 <Cale> I started out with the getNonBlocking and ended up moving it to another thread because if you don't read from another thread constantly, the action can get stuck when the buffer fills
06:34:43 <Cale> But I didn't think to replace it with something simpler just because I'd moved it to another thread.
06:34:44 <rog_> the important difference i think is that i make sure to close the write end of the pipe, so that the pipe reader gets EOF.
06:36:06 <rog_> but i haven't really thought about what happens if the IO action itself forks IO. i think it should be ok, unless an actual unix process has been spawned that keeps hold of the pipe.
06:36:43 <rog_> ... in which case, listenIO will block until that exits. which is arguably correct behaviour.
06:36:54 <Cale> Well, the other problem is that it's actually catching all the stuff going to stdout
06:37:02 <Cale> and not just the stuff which x is sending
06:37:09 <Cale> So this doesn't really mix well with threads.
06:37:34 <rog_> Cale: that's unavoidable, given that you can't fork the FD space
06:38:02 <Cale> You could implement the Haskell IO primitives differently such that they could be instrumented like this.
06:38:54 <Cale> (without any need for posix)
06:38:57 <rog_> Cale: yeah. but then you'd be putting an abstraction on top of the underlying FDs, which has its disadvantages too.
06:39:26 <Cale> Well, there are already lots of abstractions on top of the FDs
06:40:02 <rog_> Cale: but currently, it seems, there's a one-to-one correspondence between a Handle and an FD.
06:41:29 <Cale> Sort of...
06:41:36 <rog_> Cale: in another system i'm familiar with, each process/thread has its own environment, inc fds, current directory, etc. if you create a new process, the environment is shared with the parent, but you can ask to fork elements of the environment, to produce, for example, an independent FD space
06:41:39 <Cale> But some Handles are pairs of FDs.
06:41:55 <rog_> Cale: really? when does that happen?
06:41:56 <Cale> and there's lots of extra information and buffering.
06:42:02 <Cale> well...
06:42:07 <Cale> data Handle
06:42:07 <Cale>   = GHC.IOBase.FileHandle FilePath !(MVar GHC.IOBase.Handle__)
06:42:07 <Cale>   | GHC.IOBase.DuplexHandle FilePath
06:42:07 <Cale>                             !(MVar GHC.IOBase.Handle__)
06:42:07 <Cale>                             !(MVar GHC.IOBase.Handle__)
06:42:08 <Cale>   	-- Defined in GHC.IOBase
06:42:39 <Cale> data Handle__
06:42:39 <Cale>   = Handle__ {haFD :: !FD,
06:42:39 <Cale> ...half a dozen other fields ... }
06:42:50 <rog_> interesting. i wonder when one of those is created...
06:42:56 <rog_> (dupexhandle, that is)
06:43:15 <quicksilver> unix domain sockets?
06:44:28 <rog_> or pipes. the comments say "FIFO" which could mean either/both
06:45:39 <rog_> i should get hold of the source, rather than rely on the web for browsing it...
06:47:17 <vixey> here is what I was looking for
06:47:21 <vixey> rog_, http://okmij.org/ftp/Streams.html#iteratee
06:47:22 <lambdabot> Title: Streams and Iteratees
06:49:01 <Cale> hmm, fdToHandle_stat makes a DuplexHandle if and only if the fd_type is Stream (as opposed to Directory, RegularFile or RawDevice)
06:49:14 <Cale> er
06:49:17 <rog_> vixey: that seems potentially very helpful, thanks.
06:49:20 <Cale> only if, I should say
06:49:55 <yitz> Cale: the problem is that all of those Handle abstractions are hard-wired into the compiler. You can't create your own.
06:50:29 <Cale> in addition, if the the requested mode is ReadWriteMode, *then* it'll make a DuplexHandle
06:50:35 <yitz> e.g., I want to wrap a handle in an SSL connection, so that I can use it transparently with the usual IO functions.
06:50:44 <rog_> vixey: and relevant to some current issues i'm having with what i'm actually supposed to be doing :-)
06:51:06 <quicksilver> rog_: yes, iteratees are a better abstraction for careful IO control than lazy IO
06:51:14 <quicksilver> rog_: they are admittedly slightly more fiddly to use.
06:51:40 <rog_> Cale: maybe it's so it can have half-closed streams.
06:54:20 <yitz> Right now, I think my workaround will have to be to shell out to fetchmail. :(
06:54:37 <yitz> (it's a pop3 connection that I need)
06:54:39 * rog_ hates it when the web browser downloads something and interferes with its modified time. if i downloaded it today, it was modified today, dammit.
06:54:52 <ilyak> rog_: Use wget
06:55:07 <rog_> ilyak: not always an option
06:55:15 <Cale> yitz: I agree. Handles should actually be much fancier :)
06:55:15 <ilyak> web browsers suck at downloading, and they can't fix it for a decade
06:55:35 <ilyak> Maybe there's something inherently incompatible between browsers and file downloading
06:55:37 <yitz> Cale: is this part of the "new IO" talk that has been going around?
06:55:42 <ilyak> They just can't figure it ouy
06:55:43 <Cale> yitz: It would be very nice, for a start, to be able to turn any String into a Handle.
06:55:44 <ilyak> out*
06:55:52 <Cale> yitz: I know nothing of this new IO talk.
06:56:01 <yitz> Cale: darn
06:56:17 <rog_> Cale: you can - just use a pipe :-)
06:56:34 <yitz> rog_: eww
06:56:36 <Cale> rog_: It's awkward as hell though.
06:56:45 <Cale> rog_: and OS-dependent.
06:56:59 <rog_> Cale: true nuff
06:57:25 <rog_> Cale: well, it's not really "awkward" as such. but it is OS-dependent
06:57:53 <yitz> Cale: if Handle were a class, any of those things would be easy
06:58:26 <rog_> yes, that would be good.
06:58:32 <Cale> There should be a bunch of primitive (read, seek, write, etc.) operations on Handles which if we can define those, we should be able to make a Handle from them.
06:58:57 <yitz> Cale: those would be the class methods.
06:59:05 <yitz> Let's start with open and close. :)
06:59:14 <rog_> but there are other issues too. what handle does putStr use?
06:59:17 <yitz> actually, no
06:59:27 <Cale> rog_: putStr always uses stdout.
06:59:37 <yitz> putStr:: Handle h => h -> String -> IO ()
06:59:50 <Cale> rog_: but yeah, we'd actually like more than just this ;)
06:59:55 <yitz> hPutStr:: Handle h => h -> String -> IO ()
07:00:08 <Cale> stdin, stdout and stderr should be rewirable on the IO action level :)
07:00:19 <Saizan> this is starting to sound a lot like java..
07:00:19 <yitz> yeah, that too.
07:00:19 <Cale> to any fancy-Handles at all
07:00:24 <rog_> so you've instantly got a problem... you can't redirect a process's stdout to a handle class of your choice
07:00:37 <yitz> Saizan: or Python or any other normal modern language
07:00:58 <rog_> Cale: they are - it's called "dup" :-)
07:01:49 <quicksilver> yitz: I don't think you particularly need classes for this.
07:01:56 <quicksilver> although it's one solution, sure.
07:02:21 <Cale> rog_: dup isn't OS-independent
07:02:40 <Cale> rog_: It's part of the Posix binding, and moreover it's ugly.
07:03:13 <rog_> Cale: agreed.
07:03:59 <Cale> quicksilver, yitz: Yeah, a simple record type for Handle would do.
07:04:08 <Cale> (a record consisting of the operations)
07:04:52 <yitz> quicksilver. Cale: Supplying a method dict is just doing classes by hand, isn't it?
07:04:57 <quicksilver> yes.
07:05:07 <quicksilver> which is much more expressive, general, and compositional.
07:05:18 <quicksilver> classes are ridiculously overused.
07:05:36 <Cale> yitz: We don't want a new instance of our class for every Handle ;)
07:05:37 <quicksilver> (probably because they sound too much like something in another language)
07:06:19 <Cale> Now, there *could* be a class here, but we'd probably want the existential type that corresponds to it anyway.
07:06:23 <quicksilver> btw, the "new IO" of which you spoke was probably just implicit UTF8 en/de coding
07:06:43 <yitz> quicksilver: oh, yeah. feh.
07:06:51 <Cale> You know what I'd really like to have?
07:06:57 <quicksilver> Cale: and an existential type is just bundling the dictionary and has no advantage over an explicit dictionary :)
07:07:04 <rog_> quicksilver: i can't believe it doesn't do that already. but i'm spoilt...
07:07:11 <quicksilver> rog_: which part?
07:07:18 <rog_> quicksilver: UTF8
07:07:35 <quicksilver> the standard just expects unicode but doesn't explain how
07:07:44 <rook> http://hpaste.org/11056 don't like the long if, could this be shorter?
07:07:48 <quicksilver> when the compiler guys came to implement it, it wasn't clear that forcing to one encoding was a sane choice
07:07:59 <quicksilver> UTF8 was much much less obviously a standard back then
07:08:00 <ski> (quicksilver : heterogenous structures ..)
07:08:13 <quicksilver> there were loads of other encodings in wide use.
07:08:17 <Cale> rook: Well, there's some obvious repetition there.
07:08:24 <quicksilver> and the choice to silently pick an encoding seemed harmful.
07:08:29 <quicksilver> actually it still does seem harmful to me
07:08:49 <quicksilver> but less harmful than having an IO abstraction that lies about its unicode credentials :)
07:08:51 <vixey> rook: You should rewrite, (sum(l)) `div` (length(l)) as sum l `div` length l
07:09:02 <Cale> rook: (which actually turns into scanning through the list l four times)
07:09:14 * rog_ sings "life's so great / when everything's UTF8"
07:10:04 <rog_> s/everything/all/ to make it scan :-)
07:10:32 <rog_> honestly, picking one encoding and sticking with it makes life so much easier
07:11:07 <rook> (length([y | y<-l, y>m]) - length([y | y<-l, y<m]) should either be 0 or 1
07:11:29 <rook> can i declare something live an interval or so to short the if construct?
07:11:37 <rook> s/live/like
07:11:51 <vixey> hmmm
07:11:59 <Cale> http://hpaste.org/11056#a1
07:12:30 <Cale> http://hpaste.org/11056#a2
07:12:36 <vixey> I think that whole function could be written as a fold :p
07:13:49 <rook> wow thanks Cale
07:18:54 <Cale> [y | y <- l, y < m] can also be written  filter (< m) l
07:19:14 <Cale> (but that's not a big deal)
07:20:42 <yitz> Cale: I have to run now. But you said:
07:20:43 <yitz> 16:06 < Cale> You know what I'd really like to have?
07:20:53 <yitz> Please tell me sometime!
07:21:44 <yitz> bye all
07:22:11 <rog_> quicksilver: think how difficult life would be if everything was agnostic about whether we were using ASCII or EBCDIC...
07:23:59 <hugo__> in parsec, how do i match any character ?
07:24:08 <vixey> anyChar
07:24:17 <hugo__> (im doing comments discard)
07:26:11 <ziman> be careful not to discard the brace (or whatever it is) ending the comment
07:27:21 <rog_> is there a deep reason why this doesn't work? or is there a compiler flag to make it ok? http://hpaste.org/11052
07:28:15 <quicksilver> rog_: well haskell is internally agnostic.
07:28:27 <quicksilver> rog_: its Char type is defined to be unicode, no encoding specified.
07:28:42 <quicksilver> rog_: so the only issue is about interface with other systems - that is, IO.
07:28:54 <quicksilver> obviously the right answer is to specify encoding at IO.
07:29:03 <rog_> quicksilver: that's a good thing. but that's also an important place to decide...
07:29:08 <quicksilver> (well one party has to specify, the other party could just acknowledge)
07:29:29 <Cale> aha, I got distracted :)
07:29:31 <quicksilver> however, the designed h98 API didn't have any way to specify encoding.
07:29:36 <quicksilver> so you have to take a punt.
07:29:45 <quicksilver> The initial GHC/hugs punt was 'truncate to 8 bits'
07:29:47 <Saizan> rog_: allowing that would make typechecking undecidable
07:29:53 <quicksilver> because every answer seemed as bad as any other.
07:30:29 <quicksilver> the new IO punt is "assume UTF8"
07:30:35 <quicksilver> which is more useful but still a punt ;)
07:30:58 <rog_> quicksilver: that's a good plan. if you want something else, you can easily get it. but utf-8 is a fine default solution.
07:31:00 <ziman> apropos unicode IO, does utf-8 work with readline? i couldn't make it work and the docs&google weren't very helpful
07:31:48 <rog_> my main gripe currently is that source files allow utf-8, but the output from the compiler strips it...
07:32:11 <hackage> Uploaded to hackage: transactional-events 0.1.0.0
07:32:42 <rog_> Saizan: ok. that's good to know. i'll make it a proper type then!
07:33:31 <quicksilver> rog_: well you have to use an encoding package
07:33:38 <quicksilver> with the current ghc
07:33:53 <quicksilver> the new utf8 stuff I describe is not yet released.
07:34:01 <dblazakis> so... i don't get it.  why is hpaste's type equivalent to fmap?
07:37:40 <rog_> dblazakis: i wondered that too
07:37:41 <Saizan> dblazakis: 'cause it's cool like that.
07:37:58 <nomeata> its not. hpastes type is more generic.
07:38:08 <nomeata> @djinn (a -> b) -> f a -> f b
07:38:08 <lambdabot> -- f cannot be realized.
07:38:24 <dblazakis> nomeata: generically *impossible*
07:38:26 <nomeata> hpaste = flip const
07:38:39 <dblazakis> :t flip const
07:38:41 <nomeata> eh, nevemrmind
07:38:42 <lambdabot> forall a b. b -> a -> a
07:38:43 <Saizan> hpaste = undefined
07:39:46 <dblazakis> i was hoping the answer would help me achieve henlightenment
07:40:36 <nomeata> @djinn (a -> a) -> a
07:40:36 <lambdabot> -- f cannot be realized.
07:40:56 <ziman> @djinn a -> (b -> a)
07:40:56 <lambdabot> f a _ = a
07:43:11 <vixey> @free const
07:43:12 <lambdabot> f . const x = const (f x) . g
07:44:24 <vixey> @free fmap
07:44:25 <lambdabot> Expected variable or '.'
07:44:33 <nomeata> @free fix
07:44:34 <lambdabot> f . g = h . f => f (fix g) = fix h
07:44:42 <vixey> @free (a -> b) -> ([a] -> [b])
07:44:42 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
07:44:49 <ziman> @help free
07:44:49 <lambdabot> free <ident>. Generate theorems for free
07:44:50 <vixey> @free map :: (a -> b) -> ([a] -> [b])
07:44:51 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
07:45:37 <vixey> @free (.)
07:45:37 <lambdabot> Pattern match failure in do expression at /tmp/ghc25834_0/ghc25834_59.hspp:54:20-34
07:45:58 <vixey> @free compose :: (b -> c) -> (a -> b) -> (a -> c)
07:45:58 <lambdabot> g . k = p . f => f . q = f1 . h => g . compose k q = compose p f1 . h
07:46:24 <dblazakis> what is =>
07:46:34 <opqdonut> implies
07:46:45 <vixey> @free maybe
07:46:46 <lambdabot> f . h = k . g => f . maybe x h = maybe (f x) k . $map_Maybe g
07:47:22 <opqdonut> how come I recall @free giving much better theorems previously
07:47:24 <vixey> @free undefined
07:47:26 <lambdabot> f undefined = undefined
07:47:56 <dblazakis> oh, actual implies
07:48:33 <vixey> @free foo :: a -> b
07:48:33 <lambdabot> g . foo = foo . f
07:49:00 <lilac> @free fmap
07:49:01 <lambdabot> Expected variable or '.'
07:49:03 <vixey> @free foo :: (a,b) -> (b,a)
07:49:03 <lambdabot> $map_Pair g f . foo = foo . $map_Pair f g
07:49:24 <vixey> @free curry
07:49:25 <lambdabot> h . k = p . $map_Pair f g => h . curry k x = curry p (f x) . g
07:49:59 <vixey> @free foldr
07:50:01 <lambdabot> (forall x. g . h x = k (f x) . g) => g . foldr h y = foldr k (g y) . $map f
07:51:12 <lilac> @free flip
07:51:14 <lambdabot> (forall x. h . k x = p (f x) . g) => h . flip k y = flip p (g y) . f
07:51:40 <vixey> :t foldr
07:51:41 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
07:51:43 <vixey> :t flip
07:51:44 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
07:52:41 <vixey> @free unsafePerformIO
07:52:42 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `unsafePerformIO'\n\n"
07:53:53 <ski> @free unsafePerformIO :: IO a -> a
07:53:53 <lambdabot> f . unsafePerformIO = unsafePerformIO . $map_IO f
07:54:46 <idnar> I don't understand any of those "theorems"
07:55:45 <lilac> idnar: that last one was saying that fmap under the IO monad is the same as fmap applied to the result, which isn't actually true for unsafePerformIO :D
07:56:04 <idnar> heh
07:56:08 <Deewiant> @free seq
07:56:09 <lambdabot> g . seq x = seq (f x) . g
07:56:17 <lilac> but then again unsafePerformIO isn't a function, so...
07:56:47 <idnar> @free id
07:56:48 <lambdabot> f . id = id . f
07:57:09 <Saizan> i don't see why that unsafePerformIO theorem shouldn't hold
07:57:19 <Saizan> it just says that it doesn't alter the value returned
07:58:11 <b_jonas> ByteString.transpose :: [ByteString] -> [ByteString] -- wow
07:59:03 <quicksilver> b_jonas: yes, I think that's one's a bit off-the-wall.
07:59:15 <quicksilver> I wonder what use they had in mind for it.
07:59:43 <Deewiant> @free foo :: Int -> Int
07:59:43 <lambdabot> foo = foo
07:59:45 <vixey> idnar: they are just equations.. what's not to understand
08:00:15 <b_jonas> quicksilver: maybe they thought you used them as an array replacement (if you don't want to mess with lower and upper bounds)
08:00:25 <b_jonas> but even that way, transpose sounds strange
08:02:13 <opqdonut> wouldn't transpose be useful in implementing BWT?
08:03:12 <Saizan> i guess the motivation is that there's a Data.List.transpose
08:06:45 <lilac> Saizan: undefined . unsafePerformIO $ launchMissiles != unsafePerformIO . liftM undefined $ launchMissiles
08:07:21 <opqdonut> yes it is
08:07:24 <opqdonut> in terms of return values
08:07:30 <ystael> it seems like every time i switch channels over to #haskell someone is talking about launching missiles.  one might be inclined to draw freudian conclusions.
08:08:00 <mapreduce> That would be an unintended side effect.
08:08:23 <mapreduce> @quote missiles
08:08:24 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
08:08:36 <Saizan> lilac: oh, but there's no undefined in @free :)
08:09:17 <mapreduce> @remember ystael it seems like every time i switch channels over to #haskell someone is talking about launching missiles.  one might be inclined to draw freudian conclusions.
08:09:17 <lambdabot> Nice!
08:09:44 <lilac> Saizan: the same holds for (\x -> ()) in place of undefined
08:10:40 <ystael> :)
08:11:45 <Saizan> lilac: point :)
08:18:03 <Peaker> newsham: you there?
08:18:36 <vixey> lilac: only expect free to work on total strict functions
08:18:54 <vixey> hm not quite what I meant to say I think
08:20:00 <lilac> vixey: unsafePerformIO fails to be a function here :D
08:20:31 <vixey> huh
08:20:32 <newsham> hi
08:21:17 <Peaker> newsham: hey. finally looking at your code :)
08:21:39 <Peaker> newsham: wondering why you defined int/char? Why not just use bin directly?
08:21:51 <Peaker> newsham: Referring to http://www.thenewsh.com/~newsham/x/machine/Marshall.hs ofcourse
08:22:17 <newsham> good quesiton, i guess i thought it was more descriptive at the time
08:22:21 <newsham> but bin should work just as well
08:22:31 <Peaker> newsham: its a cute trick you use, to be able to both extract and build a value in the same action/function
08:22:51 <newsham> perhaps foo (Foo a b c) = liftM3 Foo bin bin bin
08:23:20 <Peaker> newsham: that doesn't sound right
08:23:54 <newsham> oh, also sometimes you want something like    toEnum.fromEnum <$> word8
08:24:00 <Peaker> newsham: If Haskell provided an easy way to "extract" the internal values out of a value, and then do the reverse...
08:24:02 <newsham> in which case having "word8" would be better than "bin"
08:24:18 <BeelsebobWork> Peaker: use a combination of fmap, first and second
08:24:33 <Peaker> BeelsebobWork: I mean not out of tuples, out of data constructors
08:24:46 <rog_> what do people usually use in haskell when they want a (key -> value) map? in my case, the set of keys is small.
08:24:48 <mm_freak> why is 'forkIO' called that way?  i'd have called it just 'fork'
08:24:48 <hugo__> how do i clear a list of "Maybe DataType" to a list of "DataType" ?
08:24:49 <BeelsebobWork> Peaker: write a version of first/second for your data constructor
08:24:51 <BeelsebobWork> > (fmap . first) (+1) [(2,"jam"), (3, "ham")]
08:24:53 <lambdabot>   [(3,"jam"),(4,"ham")]
08:24:57 <Peaker> rog_: Data.Map
08:25:01 <Peaker> rog_: or assoc-list
08:25:07 <vixey> rog_: I have used Key -> Value just like you said
08:25:26 <newsham> assoc list is fine for small map
08:25:31 <BeelsebobWork> hugo__: catMaybes
08:25:40 <vixey> rog_: you can extend it with  extend map (key,val) = \x -> if x == key then val else map x
08:25:41 <BeelsebobWork> > catMaybes [Just 5, Just 10, Nothing, Just 20]
08:25:41 <lambdabot>   [5,10,20]
08:25:45 <Peaker> BeelsebobWork: I need to extract an unbound list of values
08:26:06 <mm_freak> @indes catMaybes
08:26:07 <lambdabot> Data.Maybe
08:26:16 <hugo__> thanks BeelsebobWork
08:26:34 <Peaker> BeelsebobWork: data Blah a b c = a b c Int Int -- I'd like to have an extractBlah :: Marshall a => [a] or something like this
08:26:55 <Peaker> BeelsebobWork: where it would return the 5 values of the data constructor
08:27:03 <rog_> newsham: by assoc list, you mean just [Key, Value] ?
08:27:17 <rog_> oops i mean [(Key, Value)] of course
08:27:19 <ski> > [x | Just x <- [Just 5, Just 10, Nothing, Just 20]]  -- hugo__, alternatively
08:27:20 <lambdabot>   [5,10,20]
08:27:21 <BeelsebobWork> indeed
08:27:40 <Peaker> BeelsebobWork: I guess its [forall a. Marshall a => a] actually
08:27:44 <hugo__> allright ski :D
08:27:46 <newsham> ?type lookup
08:27:47 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
08:28:07 <Peaker> BeelsebobWork: its for a pickler combinator
08:28:10 <ski> Peaker : itym `[exists a. Marshall a *> a]' or something like that ..
08:28:21 <rog_> the other thing is it needs to support efficient updates as there are going to be millions of 'em
08:28:38 <Peaker> ski: I can do that in theory - but I'd like that kind of function to exist automatically for every data constructor somehow
08:28:52 <newsham> rog: millions of em?  i thought you said just a few keys
08:29:01 <rog_> at the moment i'm using a record type, but it needs to be more dynamically programmable.
08:29:14 <Peaker> ski: I can already write dataToIndex via some GHC.Ext magic (to know which data constructor is in use)
08:29:24 <Peaker> ski: now if I want to access the data inside that constructor, I am not sure
08:29:27 <rog_> newsham: just a few keys, but many (Map -> Update -> Map) transformations
08:30:11 <rog_> thinking about it, maybe i'd be best off using an Array
08:30:24 <ski> (Peaker : was just commenting on your reversal of quantifier .. probably `[forall a. Marshall a => a]', i.e. a list of values where each value can (by the user) be instantiated into having *any* type in `Marshall' (so it must be polymorphic) .. probably this was not what you intended, no ?)
08:30:26 <newsham> rog: you could write the code in a generic way and then try out both M.Map and [(a,b)]
08:31:18 <rog_> newsham: yup. and Array k v
08:31:20 <Peaker> ski: I meant an existential list.. a hetero-list of unknown types
08:31:32 <ski> (just as i thought, then)
08:32:11 <hackage> Uploaded to hackage: Pipe 2.1.1
08:32:19 <Peaker> ski: afaik, this: [forall a. a] is an existential list?
08:32:29 <ski> nay
08:32:45 <vixey> why an hetro list?
08:32:46 <Peaker> ski: data Obj = Obj forall a. Blah a => a ;; [Obj] then
08:32:58 <mm_freak> @pl \x -> x >>= f
08:32:58 <lambdabot> (f =<<)
08:33:07 <Peaker> vixey: to be able to have a single function that extracts values out of any data constructor of any type
08:33:11 <quicksilver> Peaker: yes, or in pseudo-syntax [exists a. a]
08:33:30 <ski> the only possibly (non-bottommy) values in `[forall a. a]' are things of the form `replicate n id' for natural numbers `id' (plus `repeat id')
08:33:46 <ski> er .. no, you had `a' not `a -> a' ..
08:33:56 <quicksilver> there are no non-bottomy values in forall a. a
08:34:05 <ski> so, the only elements can be bottom
08:34:19 <quicksilver> Peaker: you don't really want [exists a . a] then
08:34:22 <Peaker> well, I know this works: data Obj = Obj forall a. Blah a => a ;; [Obj] then
08:34:27 <quicksilver> Peaker: you have to bundle some representation of the type
08:34:33 <opqdonut> yep
08:34:34 <quicksilver> e.g. a TypeRep
08:34:38 <quicksilver> which is what Typeable is.
08:34:39 <opqdonut> otherwise you can't do anything with it
08:34:47 <quicksilver> which brings us to [Dynamic] ;)
08:35:11 <mm_freak> @pl \a -> case a of { x -> undefined; y -> undefined }
08:35:11 <lambdabot> (line 1, column 17):
08:35:12 <lambdabot> unexpected "{"
08:35:12 <lambdabot> expecting variable, "(", operator or end of input
08:35:40 <Peaker> quicksilver: the only way to write a pickler combinator that can auto-make default serializers/deserializers for arbitrary Haskell data types, is to use Dynamic or T.H-style?
08:35:42 <ski> Peaker : rather something like `data Obj = forall a. Blah a => Obj a', `[Obj]' (the placing of the `forall a.' and the `Blah a =>' is crucial)
08:35:48 <BeelsebobWork> mm_freak: const undefined?
08:36:09 <quicksilver> Peaker: well the key point is you need to bundle some reification of the type.
08:36:16 <quicksilver> Peaker: it's possible to reify the type using a typeclass
08:36:20 <quicksilver> and that's what Typeable does.
08:36:23 <mm_freak> BeelsebobWork: that's not the point  i wanted to know how one could write pattern matching in point-free style
08:36:25 <Peaker> ski: well, the "forall a." is inside the data-type inside the list. I guess there's a big difference than if it is directly inside the list?
08:36:26 <vixey> Peaker: You can span a big class of data types by composing them from smaller ones like (), (,) and Either
08:36:49 <quicksilver> and data Dynamic = forall a . Typeable a => DynamicRep a
08:36:50 <sw17ch> is there  a function similar to the unix "select" call? I need to check a list of sockets for readable data.
08:36:50 <BeelsebobWork> @pl \a -> case a of {X -> 5; Y -> 6}
08:36:51 <lambdabot> (line 1, column 17):
08:36:51 <lambdabot> unexpected "{"
08:36:51 <lambdabot> expecting variable, "(", operator or end of input
08:37:04 <quicksilver> sw17ch: the simple answer is just to use forkIO
08:37:09 <quicksilver> sw17ch: have a thread waiting on each socket.
08:37:10 <mm_freak> BeelsebobWork: that's not point-free
08:37:13 <Peaker> vixey: but I cannot automatically compose the types for given arbitrary Haskell data-types, except with T.H
08:37:14 <sw17ch> quicksilver, i was thinking that
08:37:24 <sw17ch> quicksilver, i just wanted to make sure. :)
08:37:25 <ski> Peaker : if you have `data Obj = MakeObj (forall a. Blah a => a)', then you get `MakeObj :: (forall a. Blah a => a) -> Obj'
08:37:29 <vixey> mm_freak: it is
08:37:43 <mm_freak> vixey: (\a -> ...) is not point-free
08:37:47 <vixey> Peaker: no you can't do that with TH
08:38:01 <mm_freak> i'd like to get rid of naming what 'case' should match against explicitly
08:38:11 <ski> Peaker : if you have `data Obj = forall a. Blah a => MakeObj a', then you get `MakeObj :: forall a. Blah a => (a -> Obj)', which morally is the same as `MakeObj :: (exists a. Blah a *> a) -> Obj'
08:38:11 <BeelsebobWork> mm_freak: I know -- I was trying to encourage it to get rid of it
08:38:15 <ski> Peaker : note the difference
08:38:31 <mm_freak> BeelsebobWork: ah, sorry, i overlooked the '@pl' in front of it
08:38:34 <Peaker> ski: yeah, I see
08:39:11 <quicksilver> Peaker: I don't really understand what concrete problem you're trying to solve.
08:39:17 <quicksilver> I suspect Dynamic solves it, though.
08:39:35 <ski> Peaker : the difference here was not whether the quantifier was directly inside the list, or inside a datatype inside the list .. the difference was the difference between universal and existential quantification
08:39:46 <mm_freak> hmm  can i match against multiple patterns in a lambda?
08:39:48 <Peaker> quicksilver: http://www.thenewsh.com/~newsham/x/machine/Marshall.hs -- newsham lets you have a single function both extract and build a data value in a single function: see "foo (Foo ...) = ..."
08:39:54 <ski> mm_freak : yes
08:40:03 <mm_freak> ski: how?
08:40:09 <mm_freak> (without 'case')
08:40:16 <ski> > (\ (x,y) (a,b) -> (x,y,a,b)) (0,1) (2,3)
08:40:18 <lambdabot>   (0,1,2,3)
08:40:26 <mm_freak> ski: that's one pattern
08:40:52 <ski> mm_freak : oh, you meant alternative patterns .. then, no (ocaml have, me want in haskell ..)
08:40:58 <Peaker> quicksilver: I want to be able to do that without the "Dummy" stuff that newsham is using
08:41:04 <mm_freak> ok
08:41:34 <vixey> you maybe could add something by qq [$alt| p1 | p2 | p3 .. |] I wonder
08:41:54 <ski> mm_freak : workarounds are using a defined helper function which matches, and using generic matcher functions like `either',`maybe'
08:42:09 <vixey> oh, I don't think you can make qq pattern's into view patterns though (yet?)
08:42:30 <ziman> @pl (\ (x,y) (a,b) -> (x,y,a,b))
08:42:31 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (,,,))
08:42:39 <Peaker> ski: so I can give this function: 'MakeObj :: (exists a. Blah a => a) -> Obj'  a function of any "a" I choose, because it doesn't get to choose, so I do?
08:42:41 <ski> > map (maybe 0 succ) [Nothing,Just 2,Just 3,Nothing,Just 5,Nothing,Just 7,Nothing,Nothing]
08:42:42 <lambdabot>   [0,3,4,0,6,0,8,0,0]
08:43:09 <Peaker> quicksilver: People suggest TH, but I kinda hate TH :)
08:43:18 <quicksilver> newsham's stuff makes no sense to me.
08:43:27 <vixey> Peaker: I've been suggesting an approach that doesn't use TH
08:43:32 <quicksilver> why does it pass the 'x' parameter to put
08:43:35 <mm_freak> > let catMaybes = ((\cx -> case cx of { Just x -> return x; _ -> [] }) =<<) in catMaybes [Just 2, Just 3, Just 5, Nothing, Just 7]
08:43:37 <lambdabot>   [2,3,5,7]
08:43:45 <newsham> quick: see the comment at the top
08:43:59 <ski> Peaker : yes, the caller of `MakeObj' should construct a value in `exists a. Blah a => a', so the caller chooses any `a' s/he likes, satisfying `Blah'
08:44:03 <Peaker> vixey: I understand how you suggest to compose the types.  I don't understand how to rewrite a function like "foo (...) = " newsham uses with your approach.  Can you explain that?
08:44:32 <vixey> you don't even do that
08:44:33 <Peaker> ski: yeah. I have to re-think about this every time. I am not sure why it is a bit confusing :-)
08:44:35 <ski> > map foo [Nothing,Just 2,Just 3,Nothing,Just 5,Nothing,Just 7,Nothing,Nothing]  where foo Nothing = 0; foo (Just p) = succ p
08:44:36 <lambdabot>   [0,3,4,0,6,0,8,0,0]
08:45:15 <quicksilver> newsham: and why can't you just use undefined?
08:45:35 <quicksilver> and why is it putM a and not a -> putM a
08:45:44 <quicksilver> how does the *actual* value to serialise get passed in?
08:45:53 <mm_freak> > let catMaybes = concatMap maybeToList
08:45:53 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
08:45:53 <lambdabot>  ...
08:45:57 <BeelsebobWork> > map (maybe 0 succ [Nothing, Just 2, Just 3, Nothing, Just 5, Nothing, Just 7, Nothing, Nothing]
08:45:57 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 3, srcColumn = 1}
08:45:57 <lambdabot>  ...
08:46:06 <BeelsebobWork> > map (maybe 0 succ) [Nothing, Just 2, Just 3, Nothing, Just 5, Nothing, Just 7, Nothing, Nothing]
08:46:07 <lambdabot>   [0,3,4,0,6,0,8,0,0]
08:46:11 <mm_freak> > let catMaybes = concatMap maybeToList in catMaybes [Just 2, Just 3, Nothing, Just 5]
08:46:12 <lambdabot>   [2,3,5]
08:46:23 <ski> Peaker : alternatively, using the equivalent typing `MakeObj :: forall a. Blah a => (a -> Obj)', `MakeObj' promises to comply with any `a' satisfying `Blah', so the user first choses such an `a', so we get `MakeObj :: a -> Obj', now the user just provides a value in `a'
08:46:36 <ski> (s/choses/chooses/)
08:46:57 <newsham> quick: I tried to use undefined, unfort, the value get's "used" as you peek into (Foo a b c)
08:47:00 <Saizan> newsham: have you tried it with sum types?
08:47:26 <Peaker> ski: yeah, you get to choose type forall'd variables on the outer-most layer only.  Those who peel a layer get to choose the forall's they cxpose
08:47:29 <newsham> saizan: oh, hmm.. good point.
08:47:30 <Peaker> expose
08:47:56 <newsham> oh, i think it works with sumtypes.  that was kind of the point of having the put function return the input as output
08:48:05 <newsham> you can still switch on the discriminant
08:48:17 <newsham> to pick the appropriate alternative
08:48:45 <Saizan> how'd you write code?
08:49:14 <newsham> marsh x = do { n <- word8 (computeTag x); case n of { ... } }
08:49:16 <newsham> something like that
08:49:26 <newsham> but i should actually write it out ot be sure
08:49:31 <newsham> (but not right now)
08:49:40 <Saizan> ah, i see, you write both sides
08:50:33 <vixey> Peaker: Peter Morris' thesis has examples
08:51:44 <newsham> but it is irritating that computeTag and case are going to replicate the same mapping information twice
08:51:53 <newsham> unlike auto-deriving Binary
08:52:08 <Saizan> newsham: btw, did you see the paper on invertible arrows?
08:52:16 <agcorona> hi
08:52:40 <Peaker> vixey: seems like a huge read
08:52:54 <Saizan> newsham: it's essentially the same but with arrow syntax :)
08:53:07 <Saizan> it's cool that it works as a monad too
08:53:19 <agcorona> a=1; b= a.  In GHC both variables have diferent phisical addresses. Why?
08:53:38 <quicksilver> why not?
08:53:44 <quicksilver> and, "when"
08:53:52 <quicksilver> variables addresses can change.
08:53:52 <newsham> no, i saw a blog that mentioned invertible arrows (wrt functional reference) but didnt see paper.  url?
08:53:59 <agcorona> because referential transparency makes this silly, quicksilver
08:54:19 <quicksilver> agcorona: referential transparency means you shouldn't care.
08:54:19 <Peaker> agcorona: maybe it has to do with thunks and laziness
08:54:25 <agcorona> why b should copy a in another address?
08:54:28 <quicksilver> did you compile with optimisations?
08:54:35 <vixey> Peaker: There's a lot in it
08:54:50 <Saizan> newsham: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.60.7278
08:54:51 <lambdabot> Title: Applicative (Functional) Programming - CiteSeerX
08:55:02 <newsham> ty
08:55:03 <Peaker> vixey: do you mean "Constructing Universes for Generic Programming - PhD Thesis" ?
08:55:14 <vixey> yes
08:55:14 <agcorona> Peaker I can not see any reason whatsoever for making this silly waste of space
08:55:30 <quicksilver> agcorona: did you compile with optimisations on.
08:55:33 <quicksilver> agcorona: ?
08:55:37 <agcorona> no optimisation
08:55:40 <vixey> Peaker: I don't think he's written many other thesis about generic programming.. :p
08:55:41 <quicksilver> agcorona: and how did you observe the address?
08:55:55 <quicksilver> without optimisations GHC is essentially a naive graph machine.
08:56:03 <quicksilver> if you turn optimisation on it's a real compiler.
08:56:04 <agcorona> quicksilver:   let x= reallyUnsafePtrEquality#  b b in  print $  I# x
08:56:17 <newsham> i've found invertible functions to be useful several times..  should probably have a class in the std libs for em
08:56:26 <quicksilver> agcorona: try with optimisation.
08:56:30 <agcorona> sorry  let x= reallyUnsafePtrEquality#  a b in  print $  I# x
08:58:28 <agcorona> With optimisation they share the same address
08:58:32 <agcorona> rigth
08:58:47 <agcorona> but I did not expected to see this even without optimisation
08:59:15 * quicksilver shrugs.
08:59:20 <agcorona> good at last
08:59:29 <quicksilver> well consider your expectations appropriately adjusted ;)
08:59:37 <quicksilver> with optimisation off, GHC is pretty much a graph reducer.
08:59:44 <Saizan> a lazy binding is a pointer to a function.. i wouldn't worry about copying the pointer :)
08:59:45 <agcorona> This is important for a compression algorithm I m trying
09:00:27 <quicksilver> if you're trying to write an algorithm which depends on unsafePointerEquality# then, well
09:00:34 <quicksilver> you better give up if your name is not Simon
09:01:24 <agcorona> serializations lke Data Bynary are very wasteful since do not check pointer equality and thus ,  opportunities for output compression
09:01:27 <ski> (possibly s/unsafePointerEquality#/reallyUnsafePtrEquality#/)
09:01:46 <agcorona> but it is much worse when deserializing
09:02:17 <quicksilver> thanks.
09:02:25 <agcorona> because objects that were originally sharing the same address , share nothing after deserializing!!!!
09:02:37 <quicksilver> agcorona: yes, this is true.
09:02:46 <quicksilver> but really it must be fixed at the RTS level
09:02:51 <agcorona> this is important when the program deals with many many versions of the same data structure
09:03:12 <agcorona> of the same data basically as well
09:03:27 <Saizan> well, you can make the sharing explicit
09:03:30 <sw17ch> agcorona, should Data.Binary be checking that sort of thing? I think that's an optimization better left to a higher level of the GHC system.
09:03:39 <Saizan> i don't see other solutions..
09:04:19 <agcorona> sw17ch:  anyway a library such that should  be very useful
09:04:55 <sw17ch> agcorona, true. :) it just sounds so scary and dangerous
09:05:07 <agcorona> I mean not Data. Binary, but another library or even a class with default pointer checking. I  trying to do that
09:05:15 <Peaker> http://research.microsoft.com/~akenn/fun/picklercombinators.pdf speaks of such sharing
09:05:17 <lambdabot> Title: FUNCTIONAL PEARL Pickler Combinators
09:05:41 <sw17ch> I suppose it would be cool if GHC could point all references to the value "1" to the same place in memory
09:05:44 <Peaker> it detects sharing via Eq, I think, and serializing/deserializing then causes sharing to occur even when it wasn't before
09:05:58 <Peaker> sw17ch: It could be cool if "1" was unboxed :-)
09:06:08 <sw17ch> Peaker, ah, well, you know what i mean :P
09:08:57 <agcorona> I m looking at a simple class, with serialize, deserialize that uses a state containing all the already saved objects. serialize could either serialize the object to a string or create a reference to already serialized object
09:10:26 <agcorona> it can even use read and show when no match. so automatically we have  instance show a => serializable a,  automatically
09:16:21 <BMeph> Are there any Arrow types that aren't functions?
09:17:31 <Deewiant> I guess you mean "that are neither functions nor data types containing solely functions", and if so, I don't know of any
09:17:51 <geezusfreeek> BMeph, you could construct an Arrow with a GADT, but odds are that the run function would interpret it as defunctionalized functions
09:18:21 <quicksilver> agcorona, Peaker : if you're prepared to pay the cost of hash function you can check for Hash-equality and restore sharing at load time.
09:18:27 <quicksilver> btu that is, of course, relatively expensive.
09:18:31 <geezusfreeek> but i don't know arrows very well, so what do i know
09:18:41 <quicksilver> a better answer requires RTS suport.
09:19:29 <quicksilver> BMeph: essentially, no.
09:19:37 <quicksilver> BMeph: there are certainly arrows which are not 'just' functions
09:19:44 <quicksilver> BMeph: (see d&s parsers)
09:19:56 <quicksilver> BMeph: but all arrows contain a function somewhere
09:20:00 <quicksilver> they have to, because of 'arr'
09:20:12 <b_jonas> arr implies pirates, not functions
09:20:25 <dons> you guys seen all the nice haskell stories on reddit today?
09:20:32 <dons> .NET bridges, left fold io. new darcs. yay
09:20:35 <quicksilver> of course not. that's what you're for, dons.
09:20:41 <quicksilver> to tell us about reddit stories :)
09:20:58 <b_jonas> I don't read reddit neither
09:21:03 <b_jonas> link to it maybe
09:21:14 <dons> http://www.reddit.com/r/programming/
09:21:16 <dons> :P
09:21:17 <lambdabot> Title: programming
09:23:47 <geezusfreeek> the left fold io looks a lot like my most recent frp attempt
09:23:57 <agcorona> quicksilver: yes i want to restore sharing at load time. this is my purpose ;)
09:24:52 <ski>   data UnitArrow a b = UA
09:24:56 <ski>   instance Arrow UnitArrow
09:25:01 <ski>     where
09:25:06 <ski>     arr _ = UA
09:25:08 <ski>     UA >>> UA = UA
09:25:49 <ski>     (...)
09:26:08 <quicksilver> does that satisfy the laws?
09:26:37 <ski> i'm pondering that
09:31:33 <sw17ch> We need bindings to libgcrypt
09:32:42 <ski> hm, afaics, the laws should hold
09:33:02 <ski> (given `first UA = UA' rather than `first _ = UA')
09:33:34 <lilac> looks like an arrow to me :D
09:33:35 <quicksilver> ski: I suppose in some sense the laws can hardly fail to hold.
09:33:51 <quicksilver> ski: since there is only one representative of each type (UnitArrow a b)
09:33:57 <lilac> it's the Kleisli arrow of the unit monad
09:34:05 <quicksilver> ski: any equation of the form x :: UnitArrow a b = y :: UnitArrow a b
09:34:08 <quicksilver> ski: must be true :)
09:34:33 <ski> (well, i was thinking maybe some ugly bottoms would turn up ..)
09:35:45 <quicksilver> ski: bottoms don't count, for laws
09:35:51 <quicksilver> at least, that's my few.
09:35:56 <quicksilver> view.
09:35:58 <quicksilver> damn fingers.
09:36:05 <ski> we should make that into a slogan
09:36:51 <ski> @remember quicksilver bottoms don't count, for laws
09:36:51 <lambdabot> It is stored.
09:37:33 <roconnor> quicksilver++
09:41:47 <roconnor> I wonder if what we think of as laws should actually be inequalities.
09:42:37 <ski> some book on allegories used inequalities
09:42:50 <ski> (Categories, Allegories by Freyd and someone, iirc)
09:46:52 <newsham> wow, big ongoing hack of world bank computers.  someone needs to write them some secure software
09:48:19 <ski> (.. why do i associate this to AYBABTU ?)
09:51:23 <mib_1gmtbko9> test
09:51:23 <mib_1gmtbko9> 123
09:51:23 <mib_1gmtbko9> > 1+1
09:51:24 <lambdabot>   2
09:51:30 <aeolist> it works
09:51:38 <mib_1gmtbko9> anyone home?
09:51:41 <ski> no
09:51:43 <mib_1gmtbko9> aeolist is a bot?
09:51:46 <aeolist> \names
09:51:50 <aeolist> fail
09:51:58 <aeolist> 504 and everybody's away man
09:52:03 <aeolist> what are you going to do now/
09:52:18 <mib_1gmtbko9> hmm hey guys i have a problem with this code
09:52:26 <mib_1gmtbko9> umm how do i post the code?
09:52:36 <aeolist> hpaste.org
09:52:40 <mib_1gmtbko9> post directly here or somewhere else
09:52:54 <aeolist> on the site that the topic redirects you to... which is hpaste.org
09:53:00 <ski> (don't post directly here if it's "many" lines of code)
09:53:46 <mib_1gmtbko9> http://hpaste.org/11058
09:53:51 <mib_1gmtbko9> done :) take a look
09:54:45 <mib_1gmtbko9> is the code confusing?
09:54:46 <ski> > "|" ++ concat ["ab","bc"] ++ replicate 4 ' '
09:54:48 <lambdabot>   "|abbc    "
09:54:53 <ski> is that what you want ?
09:55:10 <mib_1gmtbko9> oh use concat
09:55:47 <ski> > "|" ++ [x | f <- ["ab","bc"], x <- f] ++ replicate 4 ' '  -- is also possible .. but overly verbose for this case
09:55:48 <lambdabot>   "|abbc    "
09:58:03 <mib_69066iai> testing
09:58:07 <mib_69066iai> > 1+ 1
09:58:08 <lambdabot>   2
09:58:25 <mib_69066iai> the bot
09:58:25 <mib_69066iai> ski u there?
09:58:25 <mib_69066iai> i dc by the server
09:58:38 <ski> mib_69066iai : you know you can `/msg lambdabot > 1+ 1', right ?
09:58:53 <mib_69066iai> no i dont know
09:58:54 <mib_69066iai> new to this
09:59:07 <ski> then you could try it out
09:59:17 <mib_69066iai> thanks for telling me
09:59:17 <mib_69066iai> i tried :)
09:59:21 <mib_69066iai> btw, actually the code, i want to make it like recursive
09:59:54 <mib_69066iai> i want the code to post 1 element into the code, then loop 1 time, then do the "|" + element from the list + spaces
10:00:36 <mib_69066iai> so it would be | + element 1 + spaces , loops 1 time then | + element 2 + spaces, loops again, | + element n + spaces ...
10:00:51 <mib_69066iai> instead of concat the whole thing
10:00:59 <ski> > intersperse '|' ["ab","bc"]
10:01:00 <lambdabot>   Couldn't match expected type `Char' against inferred type `[Char]'
10:01:10 <ski> er, right
10:01:16 <ski> > intercalate "|" ["ab","bc"]
10:01:18 <lambdabot>   "ab|bc"
10:01:33 <ski> > intercalate "|" ["ab","bc","cd","de"]
10:01:34 <lambdabot>   "ab|bc|cd|de"
10:02:04 <ski> hm, ok, so you want an initial '|', too ..
10:02:19 <mib_69066iai> yeah
10:02:50 <mib_69066iai> my hugs does not recognize this intercalate, what should i load?
10:02:59 <ski> @index intercalate
10:02:59 <lambdabot> bzzt
10:03:08 <ski> @type Data.List.intercalate
10:03:09 <lambdabot> forall a. [a] -> [[a]] -> [a]
10:03:11 <geezusfreeek> @hoogle intercalate
10:03:12 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
10:03:12 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
10:03:12 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
10:03:12 <ziman> Data.List but hugs doesn't have it, i guess
10:03:17 <ski> @smack lambdabot
10:03:18 <lambdabot> go slap lambdabot yourself
10:03:30 <ski> (i just tried that ..)
10:03:41 <ski> @type Data.List.intersperse
10:03:42 <lambdabot> forall a. a -> [a] -> [a]
10:04:02 <ski> > concatMap frob ["ab","bc","cd","de"]  where  frob x = "|" ++ x ++ replicate 4 ' '  -- mib_69066iai, how about this ?
10:04:04 <lambdabot>   "|ab    |bc    |cd    |de    "
10:04:25 <ziman> > let intercalate s = concat . intersperse s in intercalate ", " ["foo", "bar", "baz"]
10:04:26 <lambdabot>   "foo, bar, baz"
10:04:47 <ski> > do x <- ["ab","bc","cd","de"]; "|" ++ x ++ replicate 4 ' '  -- or this
10:04:49 <lambdabot>   "|ab    |bc    |cd    |de    "
10:05:08 <ski> > [y | x <- ["ab","bc","cd","de"] , y <- "|" ++ x ++ replicate 4 ' ']  -- or this ..
10:05:10 <lambdabot>   "|ab    |bc    |cd    |de    "
10:13:50 <sw17ch> does the reddit discussion around Haskell read like this to any one else?
10:13:54 <sw17ch> nonbeliever: "ARGH! IT'S FUNCTIONAL! YOU CAN'T DO ANYTHING WITH THAT!"
10:13:56 <sw17ch>  dons: "yes you can"
10:14:04 <sw17ch> nonbeliever: "NO YOU'RE DUMB"
10:14:10 <sw17ch> dons: "You can do it with IO"
10:14:14 <sw17ch> nonbeliever: "IO IS STUPID"
10:15:06 <czShadoW> Heh.
10:15:41 <quicksilver> that's a fairly common pattern, yes.
10:15:50 <newsham> why not just post a program written in haskell
10:15:52 <quicksilver> I don't know where dons gets the energy to engage in the conversations :)
10:15:55 <newsham> seems like a fairly easy proof
10:16:17 <ziman> yes, programs are proofs. :)
10:17:12 <vixey> programs aren't proofs
10:17:15 <vixey> :p
10:18:02 <quicksilver> programs are existence proofs.
10:18:15 <quicksilver> to prove that a class is inhabited., you just have to exhibit one.
10:18:44 <newsham> looks like we have our own reddit argument here
10:18:48 <newsham> who needs the web
10:19:14 <quicksilver> I'm pretty insulted if you think my discusisons with viexy are like reddit arguments :)
10:19:23 <dons> sw17ch: hehe
10:19:36 <dons> quicksilver: it's about hitting people with hammers.
10:19:44 <vixey> yeah
10:19:44 <dons> if you think of it like that then yes, it is just a game, and a lot of fun.
10:19:57 <vixey> I get a lot of insight just reading remarks here
10:19:59 <quicksilver> you mean like whack-a-mole
10:20:01 <dons> yep
10:20:05 <quicksilver> actually, I *do* understand, dons.
10:20:09 <dons> :)
10:20:12 <quicksilver> I used to be an avid /. commentor
10:20:15 <quicksilver> but I burnt out
10:20:17 <dons> yikes
10:20:29 <quicksilver> back in 97 when men were real men, etc.
10:20:42 <dons> funny, since there are two articles about new IO abstractions for haskell on reddit today
10:20:45 <quicksilver> when /. trolls were real /. trolls.
10:22:58 <dons> reddit's good for practicing debating skills
10:23:20 <dons> e.g. http://www.reddit.com/r/programming/comments/762fl/adopting_functional_programming_or_just_why_did/c05rv21
10:23:22 <lambdabot> Title: sanity comments on Adopting functional programming (or Just why did people st ..., http://tinyurl.com/536qhc
10:23:38 <dons> staying on message, refining points well, and learning how to negotiate without preconditions
10:23:58 <quicksilver> I believe the customary answer to that might be "Your mom's good for practicing debating skills". Or was that the 80s?
10:24:15 <dons> heh
10:24:22 <quicksilver> yes, true.
10:24:52 <quicksilver> If there is a high enough content ration then reading the debate can be quite informing.
10:24:53 <sw17ch> dons: that was the thread i was reading
10:24:57 <dons> :)
10:25:14 <sw17ch> actually, i've very nearly boomarked http://www.reddit.com/user/dons/
10:25:16 <lambdabot> Title: overview for dons
10:25:18 <dons> hehe
10:25:51 <dons> i have to say i enjoy having a beer in the evening, and smacking a few heads together on reddit. only slightly misanthropic
10:25:52 <sw17ch> whenever i think "man, reddit is boring right now", i then think "i wonder if dons was letting any one else have it recently"
10:26:21 <sw17ch> your user page is second or third on my "the internet is boring right now" list
10:26:40 <sw17ch> but any way, don't let it go to your head :P
10:26:45 <newsham> there's a difference between practicing arguing and practicing debating
10:28:39 <dons> ok. practicing street fighting moves
10:29:01 <sw17ch> dons: i'm currently engaged in one of these street fights with a former professor
10:29:05 <dons> :)
10:29:14 <sw17ch> prof: haskell can't do what C++ can do
10:29:23 <sw17ch> me: *tries very hard to hold in laughter
10:29:27 <sw17ch> me: actually....
10:29:29 <vixey> what can C++ do??
10:29:30 <sw17ch> prof: no, you're wrong
10:29:33 <b_jonas> @faq can haskell do what C++ can do?
10:29:33 <lambdabot> The answer is: Yes! Haskell can do that.
10:29:57 <sw17ch> I'm actually going to a picnic with him today, and i'm brining my initial version of scurry along :)
10:30:01 <phoenixblitz> aren't both languages Turing Complete? or whatever its called?
10:30:10 <vixey> what's scurry?
10:30:19 <vixey> phoenixblitz: yeah, that's not really relevant though
10:30:22 <sw17ch> vixey, http://code.google.com/p/scurry/
10:30:23 <lambdabot> Title: scurry - Google Code
10:30:32 <sw17ch> I'm writing a VPN in Haskell :D
10:30:42 <vixey> @vera vpn
10:30:43 <lambdabot> *** "vpn" vera "Virtual Entity of Relevant Acronyms (Version 1.9, June 2002)"
10:30:43 <lambdabot> VPN
10:30:43 <lambdabot>      Virtual Private Network
10:30:43 <lambdabot>  
10:30:55 <sw17ch> sofar the virtual and network parts of that acronym are working
10:30:57 <vixey> ah one of those....
10:31:00 * vixey wonders what that is
10:31:34 <sw17ch> vixey: a VPN?
10:31:47 <vixey> your readme does not really help
10:31:55 <sw17ch> vixey, not in the least
10:31:58 <Peaker> sw17ch: I read your wiki. I think you can hole-punch UDP by simply sending a packet from each to the other, and then a third packet after both is supposed to pass successfully
10:31:59 <sw17ch> and it's out of date
10:32:11 <hackage> Uploaded to hackage: franchise 0.0
10:32:11 <hackage> Uploaded to hackage: httpd-shed 0.2
10:32:13 <sw17ch> Peaker: yes, that's hwo i'm doing it
10:32:21 <Peaker> sw17ch: ah, cool
10:32:21 <sw17ch> well, not yet
10:32:25 <sw17ch> but i will be donig it that way :)
10:32:54 <vixey> good luck impressing him then
10:33:16 <Peaker> quicksilver: Hey, did you have any good solution to the problem from newsham's code, of how to specify a pickler combinator, without having to manually write two functions converting between a data-type and a tuple?
10:33:18 <sw17ch> vixey: well, in the end, i'll be comparing the SLOC of OpenVPN to mine
10:33:32 <vixey> is your thing equivalent to OpenVPN?
10:33:33 <sw17ch> and that's going to be waht i show him
10:33:36 <vixey> and what is SLOC??
10:33:40 <sw17ch> vixey: no, not yet :)
10:34:04 <sw17ch> (though, once i add encryption, and i get multiple clients working, it will be, but with a different server model)
10:34:06 <cjb> vixey: lines of code.
10:34:29 <sw17ch> sorry, source lines of code
10:34:43 <Peaker> sw17ch: OpenVPN does use a central server..?
10:34:57 <sw17ch> Peaker, yes, you connect to one machine, and it routes all the trafic through it
10:35:11 <sw17ch> All client trafic needs to pass through the server node
10:35:18 <Peaker> sw17ch: your wiki says you won't be.. so is it comparable?
10:35:19 <sw17ch> (unles something has changed that i'm not aware of)
10:35:19 <vixey> I see
10:35:34 <b_jonas> multiple clients working?
10:35:37 <sw17ch> Peaker, the difference is in the server model. it's not equivelant, but i think it will be close enough.
10:35:48 <b_jonas> do you mean it only allows a virtual network of a single machine now?
10:35:50 <sw17ch> b_jonas: i haven't put the threads in place to read from multiple peers yet
10:35:56 <sw17ch> b_jonas: two machines can talk
10:36:02 <sw17ch> it's another few lines to make it talk to N machines
10:36:05 <Peaker> sw17ch: I think openvpn is useful where there is physical connectivity only through that server
10:36:15 <Peaker> sw17ch: you can't physically talk with the nodes its exposing, except through it anyway
10:36:17 <sw17ch> Peaker, oh, it's a great applciation
10:36:24 <vixey> wow this makes no sense at all http://en.wikipedia.org/wiki/Virtual_private_network
10:36:26 <lambdabot> Title: Virtual private network - Wikipedia, the free encyclopedia
10:36:42 <vixey> what does it -do-?
10:37:08 <sw17ch> vixey: it emulates a normal switched network in software and usually encrypts it
10:37:25 <sw17ch> vixey: you can have a bunch of machines not on the same physical network, and have them emulate a private network
10:37:28 <sw17ch> all in the same netmask
10:37:42 <vixey> sorry I didn't understand any of that
10:37:46 <quicksilver> Peaker: no.
10:37:47 <Peaker> vixey: basically tunnelling of networks on top of existing networks
10:37:48 <vixey> it sounds cool though
10:37:50 <sw17ch> vixey, i'm bad at explaining
10:37:52 <newsham> most vpns dont emulate a switched network, they emulate a p-p link.
10:37:56 <quicksilver> Peaker: I came the conclusion that that was the critical point.
10:38:16 <sw17ch> newsham, this is true. OpenVPN can operate both ways, though.
10:38:21 <Peaker> quicksilver: is that problem not soluble at all? You're stuck with writing extractors/builders for each data constructor?
10:38:22 <quicksilver> Peaker: you want a 'deriving' clause which can specify the isomorphism between any non-recursive type and general sum/products.
10:38:23 <lilac> (OT) which is more accurate, computing the harmonic mean as 2xy/(x+y) or computing it as 2/(1/x + 1/y)?
10:38:48 <Saizan> quicksilver: i.e. Generic Haskell ?
10:38:49 <Peaker> quicksilver: What does that mean?
10:38:53 <quicksilver> Peaker: I think you need a little compiler support (automatic deriving) and possibly a little sugar.
10:38:55 <vixey> with floating point numbers lilac?
10:39:00 <rwbarton> Peaker: You want the Data class probably
10:39:11 <lilac> vixey: yes (sorry, should have said!)
10:39:29 <quicksilver> and you also need Mu.
10:39:39 <rwbarton> Peaker: look at the papers on Scrap Your Boilerplate
10:39:43 <quicksilver> if you're going to cope with recursive types.
10:39:54 <vixey> quicksilver: *nod* I was nudging him to this approach
10:40:01 <vixey> (unsuccessfully :p)
10:40:03 <Peaker> rwbarton: it lets me convert a value of type Blah (data Blah = A Int Int | B Char)  into an integer index, and then into: Either (Int, Int) Char, or somethingl ike that?
10:40:43 <rwbarton> Peaker: Well, more or less.  Though I don't think it directly supports type-indexed types
10:40:47 <vixey> Peaker: I might prefer (Int, (Int, ()))
10:40:47 <Peaker> vixey: I'm sorry, I just didn't understand what you were trying to say, and I can't read a huge book about the subject, written as a thesis, today :(
10:41:01 <vixey> Peaker: I don't mind :)
10:41:23 <Peaker> vixey: Yeah, I wish tuples were that way
10:41:24 <vixey> it is only a few hundred pages though
10:41:35 <vixey> tuples are that way
10:41:45 <pastorn> does this seem good?
10:41:47 <pastorn> type Parser a = String -> Either String a
10:41:51 <Peaker> vixey: I mean (a,b,c)===(a,(b,(c,())))
10:41:58 <vixey> pastorn: no it does not
10:42:15 <vixey> pastorn: there is a functional pearl you should read about monadic parser implementation (how parsec works)
10:42:16 <Peaker> or maybe (a,b,c)===(a,(b,c))
10:42:28 <vixey> Peaker: I have no idea why that would be good
10:42:30 <rwbarton> Peaker: instead, it gives you a combinator gmapQ :: (forall a. a -> r) -> b -> [r] (with some class constraints) that will apply its first parameter to all of the data field of the second parameter
10:42:37 <rwbarton> rwbarton: (among other combinators)
10:42:43 <Peaker> vixey: because then anything derived on a pair-tuple would automatically apply to any tuple
10:42:52 <pastorn> vixey: srsly... i'm reading all about monads, implementing the different monads in order to test them out and learn them
10:42:56 <Peaker> vixey: you only have to instantiate classes on a tuple once, and not for every possible tuple
10:43:11 <vixey> pastorn: Yes, You should read the document I mentioned
10:43:27 <Peaker> rwbarton: seems cool, I'll look into that
10:43:30 <ski> pastorn : well, are you doing ambiguous parsers ?
10:43:37 <Peaker> quicksilver: what's "Mu"?
10:43:39 <pastorn> @googlee prarsec monadic parser
10:43:41 <lambdabot> No Result Found.
10:43:42 <vixey> Peaker: Does that not already work for tuples of the form (a, ..., (z, ()) ...) ?
10:43:46 <pastorn> @google prarsec monadic parser
10:43:48 <lambdabot> No Result Found.
10:43:49 <lilac> @src Mu
10:43:49 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
10:43:59 <lilac> Peaker: ^^ everything you need to know is there :D
10:44:00 <Peaker> vixey: yeah, but not all tuples are of that form, unfortunately
10:44:08 <vixey> Peaker: Which tuples are not?
10:44:22 <pastorn> ski: i'm parsing into a specific data structure
10:44:34 <Peaker> vixey: Well, if I have  instance Blah (a,b) -- the instance will not apply to: (a,b,c), etc. That's what's bothering me
10:44:36 <ski> pastorn : recursive or non-recursive ?
10:45:04 <vixey> Peaker: It couldn't possibly -- you would have to define it inductively in either case
10:45:19 <vixey> Peaker: i.e. the only thing you get out of (a,b,c) == (a,(b,(c,()))) is syntax
10:45:23 <Peaker> lilac: Like a fix for types?
10:45:32 <lilac> Peaker: bingo
10:45:44 <pastorn> ski: non-recursive (i think)
10:45:54 <lilac> Peaker: well, for unary type constructors
10:46:25 <pastorn> ski: data Level = L { startPos :: (Int,Int), startDir :: Direction, startField :: [[Panel]]}
10:46:34 <Saizan> vixey: yeah with the latter case of tuples you can define things inductively, with "flat" ones you can't, that's what Peaker is saying
10:46:35 <Peaker> vixey: sorry, yeah, I actually meant: instance (Blah a, Blah b) => Blah (a,b)
10:47:02 <vixey> so the choice is
10:47:08 <vixey> a) use nested tuples
10:47:11 <Peaker> vixey: and then it should work for (a,b,c) too (which currently I have to instantiate separately)
10:47:15 <ski> pastorn : so the output `String' is an error message ?
10:47:17 <vixey> b) completely change the language and use nested tuples
10:47:21 <pastorn> ski
10:47:22 <vixey> I don't see why b is better than a...
10:47:22 <pastorn> yes
10:47:45 <vixey> Peaker: simply never write (a,b,c) use the syntax (a,(b,(c,())))
10:47:55 <Peaker> vixey: because a means that every useful instance of tuples has to be duplicated for tuples of 3..N unnecessarily
10:48:10 <Peaker> vixey: But if I design a library, for example, my users will use (a,b,c)
10:48:20 <ski> pastorn : you might have problems composing smaller parsers into larger ones using your type above .. if you write it all in one hunk, this may not matter much (for small parsers)
10:48:21 <Peaker> vixey: if I call a library, it may return the type (a,b,c)
10:48:21 <vixey> your users will use (a,(b,(c,())))
10:48:35 <rwbarton> Peaker: You have the same problem with  data MyTuple a b = MyTuple a b,  right?
10:48:41 <Peaker> vixey: the existence of features we deem bad is not harmless - people will use them
10:49:00 <vixey> Peaker: this is not a bad thing
10:49:07 <Peaker> rwbarton: well, in that case it may indeed make sense for the instance to be different
10:49:14 <Peaker> rwbarton: Otherwise, why did you need a new type?
10:49:24 <pastorn> ski: okay?
10:49:44 <Peaker> vixey: if I call a library and it returns (a,b,c), but I have only instantiated 2-tuples.  I have to convert stuff all over the place
10:49:47 <pastorn> where will problems occur if i do something more complex?
10:50:02 <vixey> Peaker: That doesn't seem like a problem to me
10:50:03 <Peaker> vixey: not to mention the less nice syntax. If I use nicer syntax I get non-tuples, which means even more conversions
10:50:22 <Peaker> vixey: Well, that's the reason I choose "b" and not "a"
10:50:25 <vixey> Peaker: If you call a library and it gives a  Foo  object back, you have not implemented this either
10:50:46 <Peaker> vixey: Well, I don't see people reimplementing tuple types all over the place, though
10:50:48 <ski> pastorn : consider writing a small parser to parse one `Panel' like `parsePanel :: Parser Panel'
10:50:56 <vixey> Peaker: Foo is not a tuple
10:51:04 <lilac> hmm. does GHC have an extension to do data-deriving (with the same restrictions as newtype deriving on each data constructor)?
10:51:08 <vixey> Peaker: it is any data what-so-ever that you haven't encountered yet
10:51:09 <Peaker> vixey: then it makes sense that it needs a different instance
10:51:12 <rwbarton> Peaker: Yes, that's fair
10:51:15 <ski> pastorn : now, to parse `[[Panel]]' you want to call `parsePanel', in most cases several times after another
10:51:39 <vixey> Peaker: different instance of what, to what?  I thought you were to do some generic programming, so that (a,b,c) and Foo etc are all covered _automatically_
10:51:47 <rwbarton> Peaker: perhaps there ought to be an automatically derived class Tuple a b c | a -> b c where encode :: a -> (b, c); decode -> (b, c) -> a
10:51:55 <Peaker> vixey: no, just tuples are covered automatically
10:52:00 <ski> pastorn : how will you make it so that one part of the input is eaten by one call to `parsePanel', and another part of the input is eaten by another call to `parsePanel' ?
10:52:01 <pastorn> ski: as it is now, it is in the Maybe monad:
10:52:04 <pastorn>  sequence . map sequence . map (map readPanel) $ sss
10:52:20 <ski> pastorn> :r readPanel
10:52:23 <ski> er
10:52:26 <vixey> Peaker: in that case I have lost track of your train of thought
10:52:26 <ski> pastorn> :t readPanel
10:52:35 <pastorn> readPanel :: String -> Maybe Panel
10:52:43 <vixey> Peaker: what exactly is it you were to program?
10:53:01 <Peaker> rwbarton: indeed.  Instead of modifying N-tuples to be built via 2-tuples, we could just have all N-tuples be instances of a class that allows them to be converted to 2-tuples
10:53:03 <ski> pastorn : what is `sss' ?
10:53:12 <Peaker> rwbarton: no need to auto-derive, then, I think, just instantiate all the N-tuples once?
10:53:32 <pastorn> ski: [[String]], each string representing a panel
10:53:36 <pastorn> @paste
10:53:36 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:53:44 <pastorn> ski: hang on...
10:53:59 <rwbarton> Peaker: Yeah, even without automatic derivation it would be better than the current situation where each library defines instances up to some arbitrary number and then leaves the rest to the user
10:54:07 <ski> pastorn : so you must do some pre-parsing to get from `String' to `[[String]]', no ? .. ok
10:54:21 <Peaker> vixey: I thought I had good examples. I'm no longer sure :) I'll think about it
10:55:03 <ski> pastorn : i was considering the case of parsing at top-level directly from a `String' (containing the *whole* text to be parsed)
10:55:31 <ski> (well, `String' or list of tokens, i suppose)
10:56:22 <Peaker> rwbarton: if we had class adapters (classes being instances of other classes) we could use: rwbarton: If the library could use:  instance ReducesTo2Tuple t => LibClass t where ...
10:56:29 <vixey> Peaker: I thought you were doing something like writing a bidirectional serilizer generically for a large class of data types, is that different to your actual goal?
10:56:31 <Peaker> oops, bad use of copy&paste :)
10:57:15 <Peaker> vixey: that is my current goal, but not the original goal for which I wanted the multi-tuples.  For the serializer goal I do indeed want to have automatic instances for all data types
10:57:26 <vixey> ok
10:57:59 <pastorn> http://hpaste.org/11059
10:59:51 <pastorn> my goal is to make it parse with errors instead, seing how that might be a little more useful
10:59:59 <vixey> something to think about is, Which functions can you write that operate on nested tuple structures like (a, ...(z, ())...)?
11:00:21 <visof> i'm trying to solve this problem http://projecteuler.net/index.php?section=problems&id=12, my work is http://hpaste.org/11060
11:00:27 <visof> but it's very slow
11:00:27 <vixey> I suppose there are very few in haskell
11:00:38 <visof> is there a way to get it faster
11:00:39 <visof> ?
11:01:04 <Baughn> I'm wondering - those of you working on the euler project tasks, do you just do the bare minimum to solve the task, or try to write the best possible solution?
11:01:19 <visof> if i didn't get the result in this range " from to" i change the range
11:01:19 <lilac> visof: yes, many ways :)
11:01:33 <visof> ok, how ?
11:02:02 <ski> pastorn : ok, you use `lines' to make an initial parse
11:02:15 <pastorn> ski: yes?
11:02:24 <rwbarton> visof: Mostly, you need a better algorithm for finding the number of divisors of a given number
11:02:35 <pastorn> each line represents something different, as you see with strLvl
11:02:36 <lilac> i think when i did it, i built a list of factors for all numbers; you can work out the factors for n by finding a factor f, and then combining the factors of f and n/f
11:02:42 <ski> (as mentioned, i was thinking of one-pass parsing above)
11:03:18 <visof> rwbarton factor's Algorithm is good ?
11:03:26 <visof> or need faster one too ?
11:03:45 <lilac> visof: alternatively, you can work out a lower bound for the number of factors much quicker, and only test candidates which might have >500 factors
11:03:55 <lilac> s/lower/upper/g
11:04:17 <Peaker> visof: your paste does not seem complete
11:04:24 <phoenixblitz> Guys I have a question. I need two threads to access the same item continuously as their need arises. If one thread is accessing the object it locks it out for the other, and then the other tries as soon as the item is free. Would it be enough to use MVar or woult STM with TVar be a safer and wiser choice? As such, I won't be needing atomicity, its more isolation I am after.
11:04:36 <rwbarton> visof: a cheap trick is that if you're trying to count the factors of n, and you have a factor d, then n/d is also a factor
11:04:43 <pastorn> ski: you think it would be possible to alter some of my code to show what you mean by that?
11:04:51 <rwbarton> visof: that means you roughly only have to check d up to sqrt(n) or so, and double the result
11:05:15 <ski> pastorn : i'm not sure it would be appropriate in your simple case
11:05:42 <lilac> phoenixblitz: MVar sounds fine; you can have each thread take the object, modify it and put it back. but be careful not to deadlock :D
11:06:23 <lilac> phoenixblitz: STM would guarantee you deadlock free, so if your code is more complex it may be wiser
11:06:36 <pastorn> ski: you see something that i could do to improve it?
11:06:49 <rwbarton> phoenixblitz: As long as you only have one shared object, MVar should be fine
11:07:16 <phoenixblitz> lilac: i am not very familiar with threads in programming and I'm find it hard to figure out which i need exactly, deadlock is when one of the threads doesn't let  go of the object right?
11:07:45 <bd_> phoenixblitz: deadlock is when two threads wait forever for each other to make progress
11:07:50 <bd_> or possibly more than two
11:07:50 <phoenixblitz> rwbarton: i had tried MVars but i had a problem because for some reason it seems that sometimes my code would miss a step
11:09:06 <phoenixblitz> so you guys suggest MVar
11:09:16 <pastorn> ski: (except moving the whole parsing into the error monad, whis is on top of my TODO-list)
11:09:44 <phoenixblitz> thanks guys
11:09:58 <ski> (well, i was thinking about subsituting `not $ length str < 3' with `length str >= 3', but maybe the former reads better to you ..)
11:10:20 <lilac> pastorn: the problem with your parser is that it's not composable -- if you have a Parser x and a Parser y, then you can't make a Parser (x, y) which parses an x then a y.
11:10:25 <pastorn> ski: heh, thanks :)
11:10:59 <pastorn> lilac: what? my Maybe parsing that i pasted or the Either-thingy?
11:11:12 <pastorn> type Parser a = String -> Either String a
11:12:37 <ski> lilac : as i've mentioned, possibly that will not be a problem in pastorn simple case
11:13:47 <lilac> ski: sure, but as the complexity of the parser grows, ad-hoc parsing may become more difficult
11:14:41 <ski> (*nod*)
11:15:17 <pastorn> lilac: what would i possibly want to do that would complicate thins? in what manner would i call on my parser in order for what you propose to be working and what i have not to?
11:16:27 <lilac> pastorn: suppose you want to parse a list of panels separated by commas. in your methodology that'd require a manual splitting of the string on commas first.
11:16:33 <lilac> that's fine, of course, and will work
11:17:11 <pastorn> yes
11:19:55 <Saizan> ?src ReadS
11:19:55 <lambdabot> Source not found. Where did you learn to type?
11:20:03 <Saizan> ?hoogle ReadS
11:20:03 <lambdabot> Prelude type ReadS a = String -> [(a, String)]
11:20:04 <lambdabot> Text.Read type ReadS a = String -> [(a, String)]
11:20:04 <lambdabot> Text.ParserCombinators.ReadP type ReadS a = String -> [(a, String)]
11:20:05 <lilac> pastorn: now suppose you want to parse a list of panels separated by some more complicated thing, for which you can write a parser. how would you do that?
11:20:22 <Saizan> pastorn: ReadS is a very simple type for a composable parser ^^^^
11:31:50 <pastorn> lilac: that might be a bit harder
11:33:21 <pastorn> i'd use reads over and over
11:34:40 <pastorn> spewing out data as i traverse along my string
11:36:50 <bob_asd> How I can change a IO(Int) to Int ?
11:36:58 <ski> bob_asd : no
11:37:13 <Zao> bob_asd: You probably do not want to, but unsafePerformIO and friends.
11:37:32 <Zao> bob_asd: And make sure you're quite aware what it entails.
11:37:33 <ski> bob_asd : however, you can *inside* a `do'-block "extract" the `Int', and use it there
11:37:57 <Baughn> bob_asd: "do foo <- ioIntMakingThing; dosomethingWith foo"
11:38:31 <Baughn> bob_asd: That doesn't really make foo into an Int, though. The do block actually makes the doSomethingWith function into something that can use an IO Int. :P
11:39:34 <b_jonas> @type liftM
11:39:35 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
11:40:44 <bob_asd> I will search more about it, Thanks for the help
11:41:04 <Peaker> bob_asd: what do you want to do ?
11:41:36 <Peaker> blah = do { here_is_your_int <- the_IO_int_value ; ... }  Note that blah will be an (IO Something) too
11:41:37 <dons> ?users
11:41:37 <lambdabot> Maximum users seen in #haskell: 540, currently: 509 (94.3%), active: 13 (2.6%)
11:41:57 <pastorn> bob_asd: http://arcanux.org/lambdacats.html <-- fourth from the bottom
11:42:00 <lambdabot> Title: Lambdacats
11:42:36 <ski> bob_asd : <http://web.archive.org/web/20070614083841/http://www.haskell.org/hawiki/ThatAnnoyingIoType>
11:42:36 <lambdabot> http://web.archive.org/web/20070614083841/http://www.haskell.org/hawiki/ThatAnnoyingIoType>
11:43:38 <bob_asd> `@@Peaker`@@: I'm learning funcional programming, I need make a little program to store a list of user data
11:44:16 <Peaker> bob_asd: well, only "actions" can use other "actions".  That way you can separate pure code (functions) from non-pure things that may fire missiles (actions)
11:52:41 <Peaker> vixey: I just thought of a new reason (a,(b,c)) is preferable to (a,b,c) in general. Although its actually ((a,b),c):
11:52:44 <Peaker> @type curry.curry
11:52:45 <lambdabot> forall a b b1 c. (((a, b), b1) -> c) -> a -> b -> b1 -> c
11:52:54 <b_jonas> pastorn: you must mean http://arcanux.org/lambdacats_2.html, third from bottom
11:52:55 <lambdabot> Title: Lambdacats
11:53:38 <vixey> eh
11:54:40 <pastorn> b_jonas: that as well
11:55:29 <bob_asd> Here is my code: http://hpaste.org/11062 I'm gettin trouble in "cadastrapessoa" function
11:55:54 <Peaker> vixey: the functions that work on 2-tuples compose into functions that operate on compositions of 2-tuples...
11:56:40 <Peaker> @hoogle ((a,b,c)->d) -> a -> b -> c -> d
11:56:41 <lambdabot> No results found
11:56:46 <ski> bob_asd : if you want to call `leInt' from `cadastrapessoa', then the latter must be changed to have an `IO' around its result type .. like `cadastrapessoa :: IO Pessoa'
11:56:52 <Samy> :t (curry.curry.curry)
11:56:53 <lambdabot> forall a b b1 b2 c. ((((a, b), b1), b2) -> c) -> a -> b -> b1 -> b2 -> c
11:57:04 <bob_asd> %%-ski-%%: ok
11:57:19 <ski> (because `leInt' has an `IO' in its result type .. you can't "escape" the `IO' monad)
11:57:22 <vixey> Peaker: So just use left nested tuples when you want that ... changing the language doesn't make that possible it already is
11:58:21 <Peaker> vixey: so how do I curry a 3-tuple into a function that wants 3 args?
11:58:32 <Peaker> vixey: a 3-tuple that some library threw at me?
11:58:57 * ski regrets doing `/ctcp <nick> version'
11:59:16 <Saizan> we don't see tuples so much in libraries, fortunately
11:59:33 <Peaker> heh
12:00:00 <MyCatVerbs> Peaker: uncurry3, curry3. I think they're both in the standard libraries, somewhere. :)
12:00:24 <Peaker> MyCatVerbs: @hoogle failed to find them..
12:01:08 <Samy> @hoogle (a,b,c) -> d -> a -> b -> c -> d
12:01:08 <lambdabot> No results found
12:01:11 <Samy> suk
12:01:45 <ski> @djinn (a,b,c) -> d -> a -> b -> c -> d
12:01:45 <lambdabot> f _ a _ _ _ = a
12:01:49 <ski> there you go
12:01:51 <MyCatVerbs> Samy: you have one of those arrows associating to the right when it needs to be to the left.
12:02:05 <MyCatVerbs> @hoodle ((a,b,c) -> d) -> a -> b -> c -> d
12:02:06 <lambdabot> No results found
12:02:14 <MyCatVerbs> *facepalm*
12:02:18 <Samy> haha
12:02:19 <ski> @djinn ((a,b,c) -> d) -> a -> b -> c -> d
12:02:19 <lambdabot> f a b c d = a (b, c, d)
12:02:54 <MyCatVerbs> @djinn (a -> b -> c -> d) -> (a,b,c) -> d
12:02:54 <lambdabot> f a (b, c, d) = a b c d
12:03:00 <b_jonas> @@ pl djinn ((a,b,c) -> d) -> a -> b -> c -> d
12:03:01 <lambdabot>  pl djinn ((a,b,c) -> d) -> a -> b -> c -> d
12:03:07 <b_jonas> @@ @pl @djinn ((a,b,c) -> d) -> a -> b -> c -> d
12:03:08 <lambdabot>  f = (. (,,)) . (.) . (.)
12:03:13 <b_jonas> WHAT?
12:03:26 <MyCatVerbs> What in the name of figgy pudding was that? =)
12:03:30 <Peaker> it could be nice if ghc applied djinn for missing function bodies -- where it has or inferred the type
12:03:40 <b_jonas> @@ @pl @djinn (a -> b -> c -> d) -> (a,b,c) -> d
12:03:40 <lambdabot>  (line 1, column 15):
12:03:40 <lambdabot> unexpected "="
12:03:40 <lambdabot> expecting variable, "(", operator or end of input
12:03:41 <Peaker> heh, in a cruel kind of way :)
12:04:03 <ski> @. pl djinn ((a,b,c) -> d) -> a -> b -> c -> d
12:04:04 <lambdabot> f = (. (,,)) . (.) . (.)
12:04:08 <b_jonas> @pl \a (b, c, d) -> a b c d
12:04:09 <lambdabot> (line 1, column 9):
12:04:09 <lambdabot> unexpected ","
12:04:09 <lambdabot> expecting letter or digit, operator or ")"
12:04:09 <lambdabot> ambiguous use of a non associative operator
12:04:15 <MyCatVerbs> Peaker: oh my, that would be *hilarious*.
12:04:25 <b_jonas> @pl \a -> \ (b, c, d) -> a b c d
12:04:26 <lambdabot> (line 1, column 14):
12:04:26 <lambdabot> unexpected ","
12:04:26 <lambdabot> expecting letter or digit, operator or ")"
12:04:26 <lambdabot> ambiguous use of a non associative operator
12:04:32 <b_jonas> what's the problem with that?
12:04:33 <MyCatVerbs> Peaker: hey I wonder if it'd be possible to ring up a Turing-complete language that way. =)
12:04:38 <b_jonas> @pl (1, 2)
12:04:39 <lambdabot> (1, 2)
12:04:43 <b_jonas> @pl (a, b)
12:04:43 <lambdabot> (a, b)
12:04:48 <b_jonas> @pl \ (a, b) -> 1
12:04:49 <lambdabot> const 1
12:04:50 <Peaker> MyCatVerbs: for example:  curry3 f g -- curry3 gets its type AND its body inferred here :-)
12:05:33 <Peaker> @pl \(a, b, c) -> a
12:05:33 <lambdabot> (line 1, column 7):
12:05:33 <lambdabot> unexpected ","
12:05:33 <lambdabot> expecting letter or digit, operator or ")"
12:05:33 <lambdabot> ambiguous use of a non associative operator
12:05:39 <Peaker> I think it only supports 2-tuples
12:05:46 <Peaker> yet another reason for 2-tuples-only! :-)
12:05:58 <b_jonas> @pl \ (a, b, c) -> 1
12:05:58 <lambdabot> (line 1, column 8):
12:05:59 <lambdabot> unexpected ","
12:05:59 <lambdabot> expecting letter or digit, operator or ")"
12:05:59 <lambdabot> ambiguous use of a non associative operator
12:06:07 <b_jonas> @pl \ (hah, hbh, hch) -> 1
12:06:08 <lambdabot> (line 1, column 12):
12:06:08 <lambdabot> unexpected ","
12:06:08 <lambdabot> expecting letter or digit, operator or ")"
12:06:08 <lambdabot> ambiguous use of a non associative operator
12:06:13 <b_jonas> strange
12:06:16 <Peaker> only 2-tuples
12:06:18 <Saizan> @pl \a b c -> (a,b,c)
12:06:18 <lambdabot> (,,)
12:06:23 <ozy`> @pl flip id
12:06:23 <lambdabot> flip id
12:06:27 <Saizan> heh, weird
12:06:32 <Peaker> only 2-tuple pattern matches, then
12:07:09 <b_jonas> @pl \f x -> let (a,b,c)=x in f a b c
12:07:09 <lambdabot> (line 1, column 13):
12:07:09 <lambdabot> unexpected "("
12:07:09 <lambdabot> expecting "()", natural, identifier or "in"
12:07:14 <vixey> @pl fix fix
12:07:14 <lambdabot> fix fix
12:07:20 <vixey> @pl \u -> u u
12:07:21 <lambdabot> join id
12:07:28 <vixey> @pl (\u -> u u)(\u -> u u)
12:07:32 <lambdabot> ap id id (ap id id)
12:07:32 <lambdabot> optimization suspended, use @pl-resume to continue.
12:07:45 <vixey> @pl fix ($)
12:07:46 <lambdabot> fix id
12:07:49 <ski> @pl join id (join id)
12:07:49 <lambdabot> join id (join id)
12:07:51 <Samy> :t (,)
12:07:51 <vixey> @pl fix flip
12:07:52 <lambdabot> fix flip
12:07:53 <lambdabot> forall a b. a -> b -> (a, b)
12:07:56 <Samy> haskell is 2cool
12:08:01 <vixey> @pl fix (\u -> u u)
12:08:01 <lambdabot> fix (join id)
12:08:13 <vixey> :t ap id id (ap id id)
12:08:15 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
12:08:15 <lambdabot>     Probable cause: `id' is applied to too few arguments
12:08:15 <lambdabot>     In the second argument of `ap', namely `id'
12:08:17 <vixey> :t ap id
12:08:19 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
12:09:35 <b_jonas> heh
12:09:47 <Samy> @list
12:09:49 <Samy> :(
12:10:27 <ozy`> :source ap
12:10:31 <ozy`> er
12:10:37 <ozy`> @source ap
12:10:41 <ozy`> damn
12:10:46 <ozy`> :?
12:10:53 <vixey> :t ap
12:11:09 <ozy`> ahaha
12:11:13 <ozy`> I didn't even notice it leave
12:11:22 <ozy`> :t ap
12:11:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:12:20 <Samy> @ask Cale Mind adding ##FreeBSD to lambdabot?
12:12:22 <ski> ap = liftM2 id
12:12:27 <lambdabot> Consider it noted.
12:15:45 <Peaker> could there be an eval :: String -> a   , at least in theory?
12:15:56 <rwbarton> , eval "42"
12:16:09 <lunabot>  <<Integer>>
12:16:16 <Peaker> I mean, as a library function, bringing some of the compiler into the runtime
12:16:29 <Saizan> that's what eval is
12:16:48 <Saizan> , fromJust . fromDynamic $ eval "42" :: Int
12:16:53 <lunabot>  luna: Maybe.fromJust: Nothing
12:16:54 <rwbarton> , fromJust $ fromDynamic $ eval "42" :: Integer
12:16:58 <lunabot>  42
12:17:15 <SamB_XP> @type eval
12:17:17 <lambdabot> Not in scope: `eval'
12:17:30 <newsham> , (,) ((,)) (((,)))
12:17:32 <lunabot>  luna: No instances for (GHC.Show.Show (a1 -> b1 -> (a1, b1)),
12:17:42 <SamB_XP> , eval "eval"
12:17:43 <Peaker> Saizan: I didn't know eval was in the stdlib?
12:17:46 <lunabot>  <<[Char] -> Dynamic>>
12:18:09 <SamB_XP> Peaker: it's probably in the ghc package
12:18:10 <Saizan> Peaker: it's not, but it's a tiny wrapper around the ghc-api
12:18:35 <Peaker> @hoogle String -> Dynamic
12:18:35 <lambdabot> Prelude error :: String -> a
12:18:35 <lambdabot> Debug.Trace trace :: String -> a -> a
12:18:35 <lambdabot> Distribution.ReadE readEOrFail :: ReadE a -> String -> a
12:28:09 <Peaker> Saizan: which ghc api, do you remember?
12:29:46 <Saizan> Peaker: http://www.haskell.org/haskellwiki/GHC/As_a_library
12:29:52 <lambdabot> Title: GHC/As a library - HaskellWiki
12:31:35 <Saizan> Peaker: code for lunabot http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=59
12:32:15 <jethr0> does lambdabot use ghc-as-a-library yet?
12:32:27 <sw17ch> i love haskell... i think i just accidentally made the VPN multi-client
12:32:38 <Peaker> Saizan: thanks
12:32:40 <sw17ch> i mean, it was my goal eventually, but it happened far sooner than i thought
12:32:55 <sw17ch> i inserted a map and a mapM... and it all worked !
12:33:17 <Samy> sw17ch, what are you working on?
12:33:25 <b_jonas> sw17ch: cool
12:33:58 <b_jonas> sw17ch: so what does it support? eg. what operating systems and programs work with it?
12:34:53 <Saizan> jethr0: yeah, using mueval which uses hint
12:34:59 <Saizan> which uses ghc-api
12:35:11 <jethr0> uhu
12:35:33 <jethr0> Saizan: lambdabot or lunabot?
12:36:32 <jeffersonheard> I have need for a lockfile implementation for my latest server side project....  Am I going to run into trouble with laziness not creating files when I want them created?
12:36:45 <Saizan> jethr0: lambdabot, lunabot uses the ghc-api directly
12:36:54 <jethr0> k
12:36:55 <sw17ch> Samy, b_jonas, just a sec
12:37:24 <Peaker> jeffersonheard: when you specify what effects you want happening, laziness does not get in your way
12:38:34 <b_jonas> jeffersonheard: only if you run unsafe functions like hGetContents
12:38:48 <jethr0> "unsafe"
12:38:54 <eipi-1> hi, is it appropriate place to ask basic question about ghc?
12:38:58 <dmead> jeffersonheard, use the strict filo io package
12:39:02 <jethr0> eipi-1: yes
12:39:14 <dmead> that will prevent your file io from being lazy
12:39:21 <Saizan> uh?
12:39:21 <jeffersonheard> dmead, thanks
12:39:28 <dmead> get it on hackage
12:39:30 <dmead> np
12:39:31 <sw17ch> Samy: I'm working on a sort-of VPN. It's peer to peer rather than server oriented. b_jonas: it uses the TUN/TAP module/driver. There are ports for that driver to linux, bsd, darwin, and windows
12:39:35 <Saizan> the only laziness in file I/O is when reading
12:39:42 <sw17ch> right now, it's just linux, but i don't hink it's going to be too hard to step it to windows
12:39:54 <rwbarton> jeffersonheard: if you aren't using getContents, hGetContents, readFile, etc., you don't have to worry
12:40:05 <Samy> sw17ch, ah, cool.
12:40:17 <Samy> sw17ch, Solaris has a driver too.
12:40:26 <jeffersonheard> rwbarton, so "openFile WriteMode" will create the file immediately, not when I have need for the handle?
12:40:46 <Saizan> jeffersonheard: sure
12:41:06 <rwbarton> jeffersonheard: yeah
12:41:08 <jeffersonheard> my other thought was just to use System.Process to call "touch" and "rm" and then wait on the process handles
12:41:09 <eipi-1> Thanks. then, here it is: I'm trying to get cabal working, using ghc6.8.3, but when running runhaskell setup configure for cabal 1.4.0.2, it says SHGetFolderPathA@20 cannot be found
12:41:17 <sw17ch> Samy: yes it does
12:41:36 <rwbarton> jeffersonheard: hGetContents and so on are implemented using unsafeInterleaveIO, which causes the behavior you're thinking of where IO doesn't happen until the result is demanded.
12:41:48 <sw17ch> But yeah, it was funny... i turned it from a single link, to a hub style network by altering 3 actual lines of code and removing 3.
12:41:59 <sw17ch> so, 6 lines changed, not including type signatures
12:42:01 <jeffersonheard> k.  that's all I need then, no strict file IO, as it'll be an empty file.  Just have a CGI script writing to a file and don't want it walkiing all over itself with multiple users
12:42:38 * Samy goes to pick up his statistics book
12:43:23 <Saizan> eipi-1: you're on windows, right? compile Setup.hs with ghc --make Setup.hs, and then use the resulting Setup.exe
12:43:36 <eipi-1> the message then says it's because I'm not linking the right library, but I cannot figure out what I should do...and cabal-install 0.5.2 that I downloaded from Hackage does not install because the cabal package in my ghc setup seems outdated
12:43:39 <jeffersonheard> oh...  dcoutts: I know that Gtk isn't generally thread-safe, but I can confirm that as GdkPixbuf can be accessed/written to by multiple threads without a segfault using forkIO
12:44:01 <eipi-1> saizan: thanks a lot, trying
12:44:10 <jeffersonheard> dcoutts: tried that today, and it's very effective.  So long as you're writing on unique areas of the pixbuf w/each thread
12:46:05 <b_jonas> sw17ch: I see
12:46:09 <b_jonas> sw17ch: nice indeed
12:48:01 <adekoba> anyone familiar with the binary package? Is there any way to improve the speed of "skip"?
12:48:44 <sw17ch> adekoba, i use binary... but only for 14 bytes at a time in my current application... :\
12:48:53 <dons> adekoba: hmm? improve the speed?
12:49:07 <dons> are you compiling the code? with -O2 I hope?
12:49:16 <adekoba> yes
12:49:29 <int-e> adekoba: how far are you skipping and what's the source?
12:49:41 <dons> you can use uncheckedSkip if you know you can skip
12:49:49 <dons> -- | Skip ahead @n@ bytes. No error if there isn't enough bytes.
12:49:49 <dons> uncheckedSkip :: Int64 -> Get ()
12:50:03 <dons> it just does a drop on the underlying bytestring, fiww.
12:50:12 <eipi-1> saizan: that worked, thanks again. May I ask what was the problem and why compiling setup solved it?
12:50:51 <adekoba> have a file ~4 megs, and I am skipping to an offset of remaining - 128. It takes about half a second with uncheckedSkip
12:51:06 <dons> that seems excessive.
12:51:08 <jethr0> adekoba: sounds like id3 tags ;)
12:51:12 <dons> how do you compute 'remaining'
12:51:14 <adekoba> jethr0: :D
12:51:16 <int-e> dons: there's no way to get 'skip' in binary turned into a 'seek' OS call, right?
12:51:20 <adekoba> dons: remaining function
12:51:24 <dons> are you sure it is the library 'skip' function that is the problem?
12:51:32 <dons> oh, well,
12:51:38 <dons> 'remaining' forces the rest of input.
12:51:52 <dons> so you're doing two traversals, basically, seeking to the end of input, then dropping to that point.
12:51:57 <rwbarton> adekoba: you're not using 'pack' to create the bytestring you're passing in, are you?
12:52:23 <adekoba> rwbarton: no
12:52:56 <dons> adekoba: could you process the input as a bytestring first? just to test? read the input, take its length, then use bytestring.drop
12:53:08 <dons> otherwise, construct a test case and I can have a look at it on the weekend.
12:53:27 <dons> unless you can avoid 'remainder' somehow, though, there's not really any way to make uncheckedSkip faster
12:53:34 <adekoba> dons: So you suggest instead of using binary, just to parse the bytestring beforehand?
12:53:44 <dons> well, at least to see if skip/remainder is the problem
12:53:47 <adekoba> err, not parse. Drop rather
12:53:54 <adekoba> dons: ok.
12:53:57 <jethr0> adekoba: for id3 tags you don't really need binary, do you?
12:53:58 <dcoutts> jeffersonheard: right, a pixbuf is a pretty simple wrapper around a 2d array
12:54:08 <dons> yeah, maybe you only need binary right at the end.
12:54:35 <adekoba> yes, at the end. I'm thinking I could just skip to the offset with regular bytestrings, then use binary
12:55:02 <adekoba> but then I can't make proper instances :(. I would then need to use functions
12:55:08 <dcoutts> eipi-1: the problem is this: http://hackage.haskell.org/trac/hackage/ticket/325
12:55:12 <lambdabot> Title: #325 (SHGetFolderPath requiered to configure cabal on windows) - Hackage - Trac
12:55:15 <jethr0> *yuck* functions
12:55:35 <dcoutts> eipi-1: or rather, that ticket describes the cause of the problem
12:55:50 <vixey> jethr0: eww functional programming!
12:55:51 <adekoba> potential internet sarcasm detected, elaborate
12:55:55 <dons> adekoba: if that turns out to be much faster, i'll take that as a bug reprot against binary.
12:56:12 <adekoba> dons: righto, i'll make a test
12:56:17 <jethr0> vixey: exactly. isn't this the c++ irc channel?
12:57:09 <int-e> . o O ( hSeek mp3 SeekFromEnd (-128) )
12:58:21 <jeffersonheard> oh wait...  I thank someone for implementing System.Lock.Floack
12:58:26 <jeffersonheard> Flock, that is
12:58:55 <eipi-1> dcoutts: thanks. Actually, best would be a way to set the path for where to install because c:\program files is protected on vista. After much struggling, I figured out I could use --prefix which worked ok until I ran into that other problem
12:59:14 <dons> flock's in the unix lib.
12:59:35 <eipi-1> but what I mean is some default path (I first tried to locate some config file that would contain that path)
12:59:39 <dons> System.Posix.IO
12:59:41 <monochrom> I am now scared as hell from upgrading GHC. I'm still at 6.8.2. Many lib version mismatch horror stories for 6.8.3, and too many for 6.10.
12:59:55 <dons> monochrom: don't upgrade yet.
13:00:06 <dons> wait until cabal 1.6 and cabal-install is out
13:00:07 <dcoutts> eipi-1: yes, where we install to by default on windows is a big mess
13:00:13 <dons> which automatically handles the upgrade planning
13:00:21 <dons> monochrom: after which, it is pretty trivial to upgrade
13:00:21 <monochrom> Hehe, that restores my faith, word from dons. :)
13:00:30 <dons> the big thing people: base-3 continues to ship with ghc 6.10
13:00:39 <dons> so everything that depends on it keeps working
13:00:43 <dcoutts> eipi-1: do you know where we could install that is writable per-user? We'd also need a location where we can put binaries so they end up on the %PATH%
13:00:49 <monochrom> But this "base-3 and base-4 co-exists" matter still scares me.
13:00:49 <dons> + cabal-install knows how to solve the dependencies for you.
13:00:53 <Deewiant> dons: Arrow instances don't seem to work
13:00:53 * thoughtpolice went ahead and installed the OS X pkg of 6.10 RC1
13:00:54 <jeffersonheard> dons: searching for flock in the Heirarchical Library index returns 0 results
13:01:06 <dons> so for the first time ever it will be actually possible to use automated tools to handle the ugprade
13:01:07 <thoughtpolice> most of it has been due to base-versionitis
13:01:20 <dons> Deewiant: in base-3?
13:01:21 <thoughtpolice> (problems I've had, that is)
13:01:53 <eipi-1> I've seen the path updated to c:\program files\haskell while the dir was not there. But this update, I assume, came from the ghc setup
13:01:58 <Deewiant> dons: it looks to me that packages depending on base-3 getting built against base-3 fail due to Arrow problems
13:02:03 <dcoutts> Deewiant, dons: I think arrow did get moved about a bit, split out category as a super class
13:02:05 <monochrom> I guess I can have 6.8.2, 6.8.3, 6.10 all installed, and default myself to 6.8.2.
13:02:24 <dcoutts> monochrom: yes, I do that with 6.4.2, 6.6.1, 6.8.1 and 6.10.x
13:02:26 <Deewiant> dcoutts: yep, which meant I had to do some source editing
13:02:37 <Deewiant> for HXT
13:02:51 <eipi-1> I assume the best writeable place for hackage install would be the ghc dir itself
13:03:07 <dcoutts> eipi-1: that's also in program files isn't it?
13:03:09 <thoughtpolice> 6.4.2? :]
13:03:09 <vixey> jethr0: I thought it was ALGOL
13:03:12 <djsiegel> Hey, what's a good strategy for downloading a file from the web?
13:03:18 <Deewiant> and then give it manually the correct dependencies because runghc Setup and cabal-install disagreed about what versions of packages to use
13:03:25 <eipi-1> no, you get to choose during setup
13:03:26 <dons> dcoutts: so some API in base-3 actually did change?
13:03:32 <dons> that needs to be documented, if so.
13:03:38 <djsiegel> For example, I want to download "http://google.com/something.jpg" and save it as a local file.
13:03:53 <dcoutts> dons: I'm not sure which package it's in actually, if it's base or not
13:04:11 <Deewiant> dons: Control.Arrow.Arrow got the Control.Category.Category superclass, (>>>) became a non-class method -> anything defining an instance of Arrow broke
13:04:15 <Deewiant> and that's base
13:04:15 <dcoutts> dons: but yes, if it is an api change then it should be base 3.1.x
13:04:17 <Deewiant> in base
13:04:21 <eipi-1> I got nothing in my C drive
13:04:59 <dcoutts> eipi-1: ok, but it might have been installed system wide and you still not be able to write into those ghc dirs
13:05:16 <dcoutts> eipi-1: we would really want a per-user writable place
13:05:26 <monochrom> Significantly many people are still using 6.4.2 with no choice. E.g., school still using hardware and OS that only 6.4.2 supports.
13:06:42 <thoughtpolice> like win98 or something?
13:06:53 <dons> jjs
13:06:56 <eipi-1> dcoutts: the problem is that the path are not the same depending on the windows version
13:06:59 <thoughtpolice> total bummer, especially in 2008
13:07:02 <monochrom> I'm also thinking maybe mips, sparcs, bsds...
13:07:12 <monochrom> powerpc
13:07:23 <eipi-1> dcoutts: on vista, that would be C:\user\username
13:07:27 <thoughtpolice> hm yeah
13:07:35 <thoughtpolice> hopefully if ghc becomes a cross compiler life can be much easier
13:07:52 <dons> monochrom: what hardware/OS do only 6.4.x support?
13:08:17 <monochrom> I non-constructively know they exist. :)
13:08:18 <jethr0> thoughtpolice: is it not possible currently to cross compile with ghc?
13:08:26 <thoughtpolice> not really
13:08:34 <monochrom> I'm betting Sparc and SunOS.
13:08:39 <jethr0> when going via c, then one could use gcc's cross compiling, no?
13:08:45 <eipi-1> dcoutts: but that's default and can be changed. The value can be read from HOMEPATH=
13:08:53 <thoughtpolice> jethr0: some header files and whatnot when you configure ghc are generated and specific to the machine,
13:09:00 <jethr0> hmm
13:09:00 <djsiegel> I just used (system . ("wget " ++))
13:09:05 <thoughtpolice> which is part of the reason why when you just try to port ghc, you actually have to copy header files over
13:10:01 <jethr0> wget = system . ("wget " ++)
13:10:12 <dons> we do have a Network.Download kids
13:10:16 <thoughtpolice> jethr0: from what I understand GHC simply assumes a bit about the platform its being built on when doing so
13:10:26 <jethr0> thoughtpolice: that's unfortunate
13:10:31 <eipi-1> djsiegel: I've seen some package using CURL
13:10:35 <dons> openURI "http://haskell.org"
13:10:36 <lambdabot> Title: Haskell - HaskellWiki
13:10:45 <thoughtpolice> jethr0: yes, ghc being a cross-compiler would be super dandy
13:10:48 <dons> so please don't use system "wget"
13:11:06 <jethr0> dons: using libraries is for suckers. real men reinvent the wheel everytime over ;)
13:11:48 <dcoutts> eipi-1: so long as there are apis to get that dir portably it's ok
13:12:01 <thoughtpolice> jethr0: but for ghc 6.12 there is a major build system overhaul going in, and as well john dias's new GHC backend work will be going in, so we will hopefully have A) a much better build system so we can again port GHC (hc bootstrapping,) and make cross-compilation easier if possible, and at the very least B) a much better backend for ghc altogether
13:12:15 <thoughtpolice> give it a year or so ;]
13:12:23 <eipi-1> dcouts: if the API to read environment variables is portable, then it's fine. That part, I unfortunately do not know.
13:12:26 <b_jonas> thoughtpolice: what does backend mean in this case?
13:12:41 <jethr0> nice
13:12:55 <b_jonas> thoughtpolice: is it the part that emits native code etc?
13:13:04 <thoughtpolice> b_jonas: code generation
13:13:23 <thoughtpolice> there's apparently a lot of really sophisticated dataflow optimization work going in
13:13:31 <thoughtpolice> new register allocator, etc.
13:13:35 <b_jonas> great
13:14:25 <eipi-1> dcoutts: seems like there is a system.environment in haskell, so that should not be an issue to read the dir from there
13:14:35 <thoughtpolice> b_jonas: yes, it should hopefully help a lot :]
13:15:25 <b_jonas> meanwhile, is it currently easy to compile a haskell program on one machine and run it on another machine that is of the same architecture but doesn't have ghc installed?
13:15:44 <b_jonas> is everything that's needed in the executable and possibly some shared libraries you can copy?
13:15:44 <dcoutts> eipi-1: we use a win32 function to get the per-user dir
13:16:17 <Botje> b_jonas: for most programs the only dependency is libgmp
13:16:26 <Botje> and there's work going on to lose that too, iirc
13:16:46 <thoughtpolice> b_jonas: if you do '-optl-static -static -O2' you should be fine I think
13:17:12 <thoughtpolice> gmp is currently the major thing, and it will continue to be a legal issue from what I understand until we get shared library support
13:17:36 <thoughtpolice> but we don't have that yet, because we can't (yet) have upgradable shared libraries and not have GHC/your app freak out
13:17:47 <thoughtpolice> if GMP could just be eliminated life would be good
13:17:53 <thoughtpolice> it's just a really slow process
13:18:14 <jethr0> thoughtpolice: by legal you mean statically linking non-gnu code against a gnu library?
13:18:24 <thoughtpolice> yeah
13:18:33 <adekoba> dons: turns out the bytestring and binary versions have the same time
13:18:46 <thoughtpolice> i always wondered why that (no static-linking) was a stipulation of the LGPL
13:18:48 <adekoba> dons: is there any way possible to seek with bytestrings?
13:18:59 <b_jonas> thoughtpolice: can't gmp still be dynamically loaded while haskell modules themselves are statically loaded?
13:19:07 <b_jonas> thoughtpolice: I mean what does shared library support have to do with it?
13:19:45 <jethr0> thoughtpolice: i guess it's a direct consequence of the "derived work" idea
13:19:51 <thoughtpolice> jethr0: i guess
13:20:00 <b_jonas> this is good though
13:20:50 <b_jonas> another question is, is there an easy way to compile ghc on a machine and install it to another machine that has the same arch but does not previously have ghc installed?
13:20:55 <adekoba> dons: never mind
13:20:55 <thoughtpolice> b_jonas: just a sec
13:20:56 <eipi-1> dcoutts: thinking back, you working in c:\program files\haskell is not a problem in itself. However, for some reason, we do not get to provide the authorization through the User Access Control, which is why it is not possible to work that way.
13:21:06 <thoughtpolice> b_jonas: i think there was a wiki page that might explain things better than I can
13:21:28 <dons> adekoba: no, but 'drop' is an O(1) operation on strict bytestrings.
13:21:29 <b_jonas> I'm asking because I'm still considering to rewrite the irc bot I'm running (or part of it) to haskell
13:21:32 <thoughtpolice> b_jonas: you mean just a binary distribution? seems reasonable
13:21:36 <eipi-1> dcoutts: so maybe the right way would be to see why we do not get the authorization message that would allow user to let cabal write there
13:21:44 <dons> adekoba: it should be possible to drop a 4M file in a few ms.
13:21:48 <b_jonas> but the machine where it's running doesn't currently have ghc
13:21:53 <b_jonas> and I'm not sure what I want to do
13:22:04 <dcoutts> eipi-1: could you add your thoughts to this ticket: http://hackage.haskell.org/trac/hackage/ticket/320
13:22:07 <lambdabot> Title: #320 (cooperation with Windows Vista's User Access Control) - Hackage - Trac
13:22:14 <b_jonas> if I could install ghc to it, that would solve it simply,
13:22:17 <thoughtpolice> b_jonas: http://hackage.haskell.org/trac/ghc/wiki/ReplacingGMPNotes#Introduction
13:22:21 <lambdabot> Title: ReplacingGMPNotes - GHC - Trac, http://tinyurl.com/vrtqn
13:22:39 <thoughtpolice> b_jonas: linux? have you just tried using a generic binary distribution?
13:22:42 <dcoutts> eipi-1: or this one might be relevant place to record info about default install dir on windows http://hackage.haskell.org/trac/hackage/ticket/289
13:22:42 <b_jonas> linux, yes
13:22:44 <lambdabot> Title: #289 (symlink binaries into ~/bin) - Hackage - Trac
13:22:49 <b_jonas> thoughtpolice: but I'm not root on that machine
13:22:58 <b_jonas> thoughtpolice: I can ask the admin to do things for me,
13:23:15 <thoughtpolice> b_jonas: http://haskell.org/ghc/download_ghc_683.html#x86linux -- couldn't you just put that in your $HOME and run it from there?
13:23:16 <lambdabot> Title: GHC: Download version 6.8.3
13:23:41 <adekoba> dons: 4mb files are working fine (.07s). A file of size 50megs takes .12 seconds, however, which makes me think that it would be faster just to use hSeek
13:23:49 <b_jonas> thoughtpolice: do you suppose you can just relocate that to another directory?
13:24:07 <thoughtpolice> b_jonas: it's possible, I use OS X though and have never used a binary dist off haskell.org
13:24:11 <thoughtpolice> so YMMV
13:24:18 <b_jonas> thoughtpolice: I'm rather thinking I have to rebuild with correct parameters if I want to do that
13:24:44 <thoughtpolice> b_jonas: check in #ghc for more on that note then
13:24:49 <rwbarton> adekoba: that .12 seconds could just be how long it takes to read the entire file from the kernel
13:24:55 <thoughtpolice> Igloo or someone could probably tell you
13:25:07 <b_jonas> thoughtpolice: ok, I'll try that channel
13:25:11 <Botje> 50 megs in .12 seconds is 400 MB/s
13:25:20 <Botje> i'd say that's pretty fast :P
13:25:56 <b_jonas> one other problem is that a ghc install is large
13:26:12 <b_jonas> 200M on my x86-linux machine
13:26:21 <b_jonas> and disk space on that machine is limited
13:26:24 <eipi-1> dcoutts: sure, but I'd like to investigate this more (need to find something to get started with haskell)
13:26:26 <thoughtpolice> b_jonas: that's due to extralibs for the most part
13:26:31 <b_jonas> thoughtpolice: true
13:26:38 <b_jonas> I could install without most extralibs
13:26:42 <b_jonas> and install by hand those I need
13:26:51 <thoughtpolice> b_jonas: you might be able to find a binary dist without extralibs
13:27:02 <thoughtpolice> and then just use e.g. cabal install to do the rest
13:27:05 <thoughtpolice> which would be goodness
13:27:07 <b_jonas> thoughtpolice: I don't think any binary dist would be relocatable
13:27:16 <jeffersonheard> Okay...  this works the first time, and then always complains about a lock on the file subsequent times.  Specifically about the file I create on line 20.  http://hpaste.org/11064
13:27:29 <thoughtpolice> b_jonas: i'm also not sure how much smaller ghc 6.10's dist is going to be
13:27:38 <adekoba> rwbarton: yes, true. lazy bytestring's aren't any better. Any way to make binary use hSeek instead of reading the entire file?
13:27:42 <thoughtpolice> i.e. what all is still in extralibs and what's not
13:27:45 <b_jonas> well, I guess without extralibs would make it much slower
13:28:04 <b_jonas> I'd need some of extralibs and even some cabal packages outside extralibs
13:28:10 <b_jonas> but I hope they're small
13:28:39 <b_jonas> the other solution is to always run ghc on my home machine and just install the compiled program there
13:28:55 <b_jonas> but the drawback of that is that then I can't modify the program if I'm not at home
13:29:16 <b_jonas> which would be inconvenient
13:29:26 <pstickne> b_jonas:  ssh/etc an option? :)
13:29:48 <b_jonas> pstickne: I don't want to keep my home machine up all the time
13:30:17 <b_jonas> it's convenient, sure, but no, it's not for me
13:30:27 <b_jonas> and just ghc is unlikely to change this
13:31:56 <jdrake> @src Maybe
13:31:56 <lambdabot> data Maybe a = Nothing | Just a
13:32:11 <hackage> Uploaded to hackage: panda 2008.10.11
13:32:11 <hackage> Uploaded to hackage: hslogger 1.0.6
13:38:06 <dons> anyone else notice the transactional-events impl uploaded to hackage?
13:38:12 <dons> straight from the ML paper at ICFP
13:38:32 <pao> Hi!
13:38:37 <dons> hey
13:39:18 <pao> is there a syntax to update a record providing a val -> val function?
13:39:32 <dons> rec { x = f x }
13:39:46 <dons> where 'f' is your update function, and 'rec' is your record value, with field 'x'
13:40:00 <pao> lm{key = c:(key lm)}
13:40:02 <dons> so not special syntax
13:40:06 <dons> yeah
13:40:12 <dons> with less parens
13:40:19 <dons> lm { key = c : key lm }
13:40:43 <pastorn> is does putStr handle utf?
13:40:46 <pao> I'd like to avoid writing key and lm two times :-)
13:41:00 <mauke> pastorn: not yet
13:41:33 <Deewiant> ?hackage utf8-string -- pastorn: this does
13:41:33 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/utf8-string -- pastorn: this does
13:42:28 <pastorn> thanks :)
13:42:46 <pao> dons: so I'm not missing any feature... thanks :-)
13:44:20 <dons> right
13:45:47 <pao> I've seen I'm not the only one to miss this feature...  "Proposal: Allow "\=" for field update in record update syntax" :-)
13:45:52 <jethr0> wasn't their talk of a "deriving Modify" instance at some point providing automatic modify... functions?
13:46:34 <pao> jethr0: I'm reading ...
13:46:54 <jethr0> pao: btw, "\=" looks binary while an update function would be trinery, no?
13:47:22 <jethr0> pao: i don't quite recall where I've seen it, but someone was working on derivable modify functions with Template Haskell
13:48:10 <pao> jethr0: well ... I think that's just syntactic sugar ... not really an operator... so it's basically an aestetical choice
13:48:30 <pao> jethr0: that thread mention a TH solution... yeah
13:48:34 <jethr0> k, but you need "update record field value"
13:48:43 <jdrake> :hoogle <$>
13:49:53 <ziman> @hoogle (<$>)
13:49:53 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
13:50:14 <jdrake> ziman, thank you
13:50:31 <jdrake> @hoogle mapM
13:50:31 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
13:50:31 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
13:50:31 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
13:51:30 <jethr0> seems completely arbitrary that mapM is in Prelude
13:51:47 <ddarius> It is completely arbitrary
13:52:07 <b_jonas> yeah
13:56:41 <jdrake> In gtk2hs I have a MenuItem that I need to 'activate' but there is no signal for it in http://www.haskell.org/gtk2hs/docs/gtk2hs-docs-0.9.12/Graphics-UI-Gtk-MenuComboToolbar-MenuItem.html#t%3AMenuItem  any ideas on what I can do for it?
13:56:43 <lambdabot> Title: Graphics.UI.Gtk.MenuComboToolbar.MenuItem, http://tinyurl.com/4yzsoq
13:59:28 <jdrake> nvm, it is onActivateLeft (custom names for gtk2hs)
14:00:22 <idnar> @type ap
14:00:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:00:39 <idnar> @type return . ap
14:00:41 <lambdabot> forall (m :: * -> *) (m1 :: * -> *) a b. (Monad m1, Monad m) => m1 (a -> b) -> m (m1 a -> m1 b)
14:00:46 <idnar> @type ap . return
14:00:47 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> b) -> m a -> m b
14:01:18 <idnar> @type liftM
14:01:19 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:01:52 <jethr0> somebody said that ap was deprecated...?
14:02:01 <idnar> @type (<*>)
14:02:02 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:02:15 <jethr0> or maybe that was half-joking in reference to <$> and <*>
14:02:29 <idnar> uhm, can you build ap from liftM and return? (or fmap and pure, or whatever)
14:02:36 <mauke> @src ap
14:02:36 <lambdabot> ap = liftM2 id
14:02:43 <mauke> @src liftM2
14:02:43 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:03:04 <idnar> I'm trying to envisage a world where Applicative is a Functor subclass, and Monad is an Applicative subclass
14:03:19 <jethr0> idnar: aren't we all
14:03:24 <vixey> I'm not.
14:03:33 <idnar> I'm just not sure how you define the various bits and pieces
14:04:05 <vixey> I'm not interested in a class hierarchy -- A logic language would suit me much better
14:04:38 <jethr0> vixey: have you tried prolog?
14:05:02 <vixey> jethr0: I mean to replace typeclass dispatch
14:05:20 <jethr0> not sure I understand what you mean
14:05:26 <idnar> so that liftM2 definition doesn't really work
14:06:27 <mauke> @src liftA2
14:06:27 <lambdabot> liftA2 f a b = f <$> a <*> b
14:06:36 <jethr0> hehe
14:06:59 <pastorn> @type liftA2
14:07:00 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
14:07:33 <idnar> I guess I'm still not getting it
14:07:42 <idnar> so you'd have to define both <*> and pure?
14:08:03 <idnar> oh, I guess fmap would be the default definition
14:08:29 <idnar> s/be the/have a/
14:09:51 <Japsu> @dice 1d44
14:09:51 <lambdabot> 1d44 => 8
14:10:31 <pastorn> how do i add colors to charcters in a terminal?
14:10:59 <mauke> depends on the terminal
14:11:08 <ozy`> pastorn: depends on the terminal... usually it's some sequence starting with ^[
14:11:09 <ozy`> heh
14:11:44 <adekoba> a function returns error (error :: String -> a) in a pure function, and all my attempts to catch it have failed. Would it have something to do with evaluate?
14:20:10 <pastorn> found it :D
14:20:11 <pastorn> http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/lectures/lecture2/ANSI.hs.html
14:20:24 <lambdabot> http://tinyurl.com/4oolo4
14:20:39 <pastorn> 4oolo4, nice :)
14:26:08 <bBs> > let yourmom = 10 in 5 + yourmom
14:26:10 <lambdabot>   15
14:29:05 <jethr0> @let yourmom=10
14:29:08 <lambdabot>  Defined.
14:29:14 <jethr0> > 5 + yourmom
14:29:16 <lambdabot>   15
14:31:10 <Badger> jethr0: your mom sure is young.
14:32:11 <hackage> Uploaded to hackage: franchise 0.0.1
14:32:13 <jethr0> it's not her age, it's what she has left after the crash of the dow  :~|
14:34:31 <Badger> jethr0: owch.
14:34:34 <Badger> :(
14:34:45 <jethr0> just semi-kiddin'
14:42:55 <Twey> :t fix
14:42:57 <lambdabot> forall a. (a -> a) -> a
14:43:54 <Badger> fix Twey
14:43:57 <Badger> er
14:43:59 <Badger> or even
14:44:06 <Badger> @fix Twey
14:44:06 <lambdabot> Maybe you meant: bid faq ft id thx
14:44:21 <Badger> Maybe I did.
14:44:36 <ziman> hm@bid $300
14:44:38 <ziman> @bid $300
14:44:44 <lambdabot> Can't find '$300'
14:44:52 <Badger> lambdabot is poor :(
14:44:57 <ziman> :)
14:45:38 <Twey> Haha, Badger
14:46:29 <Badger> @bid 30
14:46:30 <lambdabot> Can't find '30'
14:46:34 <Badger> @bid
14:46:35 <lambdabot> Invalid argument ''
14:47:29 * Badger wonders what you have to import to use bid.
14:52:40 <lispy> which haskell compiler is the easiest to retarget?  Is it yhc?
14:53:27 <lispy> I was just sitting here thinking, "Gosh.  I bet it would be a lot easier to use Haskell in my day job if I could easily translate Haskell to language X, Y and Z."
14:53:29 <jdrake> @src flip
14:53:29 <lambdabot> flip f x y = f y x
14:53:32 <lispy> So, how can I make that a relasity?
14:53:35 <lispy> reality*
14:53:58 <Plouj> hi
14:53:58 <rwbarton> @hackage yhccore
14:53:59 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/yhccore
14:54:01 <ozy`> lispy: whoa, that's crazy talk, duuude
14:54:04 <Plouj> what does this error mean: http://codepad.org/4cxydsPm ?
14:54:06 <lispy> Say, today I want a Haskell -> Python translator, but tomorrow I want Haskell -> Java, and next week I want Haskell -> C#.  Then I'll invoke those particular compilers once I have it in that form
14:54:08 <rwbarton> lispy: I don't know how far that will get you
14:54:46 <ozy`> lispy: that's what I was afraid you wanted. I think you are the only one in the world who wants a Haskell -> Python compiler
14:55:15 <lispy> ozy`: I'll let CPython compile it, I just want to translate my Haskell text to equivalent Python
14:55:22 <ozy`> compiling to the JVM or the CLR is definitely something people want though
14:55:38 <ozy`> lispy: that qualifies as compilation as far as I'm concerned
14:55:43 <lispy> I don't want to target the platform though.  I want to target a language :)
14:55:55 <rwbarton> lispy: Does it have to be readable Python?
14:56:35 <lispy> rwbarton: while that would be cool, I won't make it a requirement
14:56:57 <rwbarton> lispy: I think there's a yhc core interpreter written in python somewhere
14:57:12 <rwbarton> lispy: so, it shouldn't be too hard to instead translate yhc core to (possibly unreadable) python
14:58:00 <ozy`> rwbarton: interpreters have quite different back ends from compilers/translators
14:58:24 <lispy> rwbarton: yeah, there is a haskell interpreter for python called pyhi, but it's incomplete I think...plus it's not what I want to d
14:58:48 <Plouj> anyone?
14:59:18 <lispy> I'm hoping that if we can translate to source in language X that interoperability shouldn't be too hard, at least not calling the Haskell stuff from the target language (the other direction may still be rough)
14:59:39 <lispy> Other options include using FFI bridges
15:00:49 <rwbarton> Plouj: looks like 'number' is a Char, not an Integer
15:01:03 <rwbarton> Plouj: maybe you meant number == '0'
15:01:13 <Plouj> no, I want number to be an Integer
15:01:16 <Plouj> I thought that's what 'read' does
15:01:26 <Plouj> s/does/returns
15:01:26 <lispy> > read "1234" :: Integer
15:01:28 <lambdabot>   1234
15:01:35 <lispy> Plouj: it certainly can do that
15:01:40 <rwbarton> read returns whatever you want it to.  Well, apparently not in this case :)
15:01:44 <rwbarton> We need to see more code
15:01:49 <Plouj> oh, right
15:02:01 <Axman6> @src String read
15:02:01 <lambdabot> Source not found. Wrong!  You cheating scum!
15:02:07 <Axman6> it better be id...
15:02:10 <Plouj> http://codepad.org/5l9ItrQ3
15:02:13 <eipi-1> dcoutts: I updated the ticket 320 for cabal with details of a method to get elevation using win32 API
15:02:29 <mauke> Axman6: it isn't
15:02:53 <Axman6> why would it not be?
15:02:55 <rwbarton> Plouj: your problem is at putStrLn numbers
15:03:03 <mauke> Axman6: because show isn't id
15:03:15 <Plouj> really?
15:03:17 <rwbarton> Plouj: I strongly suggest you write type annotations on your top-level values, so you don't get confusing error messages like this one
15:03:21 <rwbarton> Plouj: Yes, really :)
15:03:24 <Plouj> I just put it there to stop the compiler from complaining
15:03:39 <rwbarton> Plouj: ghc has inferred that numbers is a String, because you're passing it to putStrLn
15:03:47 <rwbarton> Plouj: and therefore each number must be a Char
15:03:48 <Axman6> mauke: so read reads the show form of a string, so "\"string\""?
15:04:00 <mauke> Axman6: yes
15:04:05 <Axman6> ah ha
15:04:08 <rwbarton> Plouj: But, 0 is not a Char and that causes your error
15:04:09 <Plouj> ok, I changed it
15:04:10 <Axman6> that makes sense
15:04:25 <Plouj> rwbarton: I see
15:04:30 <Axman6> > read "string" :: String
15:04:32 <lambdabot>   "* Exception: Prelude.read: no parse
15:04:37 <Plouj> rwbarton: what do you mean by "write type annotations on your top-level values"?
15:04:48 <Axman6> > read "\"string\"" :: String
15:04:50 <lambdabot>   "string"
15:04:55 <Axman6> lambdalag -_-
15:05:14 <idnar> laggybot
15:06:10 <rwbarton> Plouj: For example, above the definition of getNumbers write the line   getNumbers :: IO [Integer]  if that's what you intend
15:06:48 <rwbarton> Plouj: Then, you would have gotten the error at the putStrLn line
15:06:57 <ArneB> @pl \x -> zip (tail x) x
15:06:57 <lambdabot> zip =<< tail
15:07:14 <pastorn> > yourmom
15:07:15 <lambdabot>   10
15:07:17 <ziman> uau
15:07:37 <ziman> @pl \x -> zip x (tail x)
15:07:37 <lambdabot> ap zip tail
15:07:54 <pastorn> @let yourdad = (-9)
15:07:55 <lambdabot>  Defined.
15:08:11 <pastorn> > yourmom + yourdad
15:08:12 <lambdabot>   1
15:08:16 <pastorn> lovely
15:09:40 <rwbarton> lispy: there's a yhc core to javascript translator.  and darcs hugs can now output yhc core.  so, that might be a place to start
15:10:38 <Guest177> Hi, does anybody have an illegally pirated copy of 'Haskell: The Craft of Functional Programming, Second Edition' for me?
15:10:51 <vixey> lol
15:11:05 <Cthulhon> The only copies I've seen were very poor scans.
15:11:08 <vixey> 7/10 original
15:11:12 <Cthulhon> Do yourself a favor and geet the dead tree version.
15:11:15 <Cthulhon> *get
15:11:21 <Cthulhon> It's not that expensive.
15:11:22 <Guest177> It costs money :\
15:11:24 <Guest177> How much?
15:11:36 <vixey> Guest177: You should go to the library
15:11:39 <Guest177> I prefer ebooks anyway, I can leave them open all of the time without them getting borked up
15:11:54 <Guest177> and just flick open my Adobe window when I next want to read
15:13:11 <lispy> rwbarton: I see.   Thank you.
15:15:13 <u51z3h4> hi
15:15:48 <dons> it's in almost every library
15:16:03 <ozy`> Guest177: dudex0rz j00 sh0uld t0t4lly ju5t g0 t0 t3h l13br4ry
15:16:19 <ozy`> also: AVAST!
15:16:20 <Cthulhon> liebrary?
15:16:32 <elliottt> libary!
15:16:49 <ozy`> Cthulhon: *insert comment about the government trying to control your mind*
15:16:54 <mauke> give me library or give me death
15:16:55 <dons> ?elite the library roxors
15:16:56 <lambdabot> THe 1I8r4ry rOXOrz
15:16:59 <davidL> lispy: how long is your talk on tuesday, will I be able to make it to my class at 12? :)
15:17:35 <lispy> davidL: I was shooting for 45 min with Q/A
15:17:54 <lispy> dons: that's the typical talk length right?
15:18:03 <dons> 10.30->11.30
15:18:07 <lispy> dons: and then people can stick around to ask more questions if they want?
15:18:08 <dons> davidL: where's your class?
15:18:11 <dons> lispy: yeah
15:18:29 <davidL> dons: a few blocks away from the new engineering building
15:18:45 <dons> at PSU?
15:18:49 <davidL> yeah
15:20:02 <dons> should be easy. we'll have  other PSU folks
15:20:57 <davidL> I'll be there
15:21:51 <eulera> someone knows some kind of online haskell interpreter?
15:22:01 <sbahra> Guest177, there a re good copies available :-P
15:22:05 <sbahra> eulera, lambdabot
15:22:05 <dons> eulera: codepad
15:22:06 <vixey> > cycle "here!! "
15:22:08 <lambdabot>   "here!! here!! here!! here!! here!! here!! here!! here!! here!! here!! here...
15:22:15 <sbahra> eulera, mibbit.com /\ lambdabot
15:22:42 <eulera> hm
15:22:43 <davidL> there was a lambdabot web interface, but it's not working
15:22:50 <Cthulhon> Codepad uses Hugs. :\
15:23:05 <eulera> how can i use lambdabot?
15:23:11 <vixey> > "Like this"
15:23:12 <lambdabot>   "Like this"
15:23:20 <eulera> "1+1"
15:23:25 <vixey> > 1+1
15:23:27 <lambdabot>   2
15:23:36 <eulera> :t foldr
15:23:37 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
15:23:39 <sbahra> codepad is a great idea though
15:23:59 <sbahra> eulera, you can also do some really other cool things
15:24:00 <sbahra> For example
15:24:02 <sbahra> @src map
15:24:03 <lambdabot> map _ []     = []
15:24:03 <lambdabot> map f (x:xs) = f x : map f xs
15:24:10 <sbahra> @list
15:24:10 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:24:20 <eulera> foldr (\x y -> x * y) 1 [1..100]
15:24:35 <sbahra> eulera, you need to prefix ">" to have something evaluated
15:24:51 <sbahra> eulera, for example, "> foldr (\x y -> x * y) 1 [1 .. 100]"
15:24:56 <eulera> ha.. thanks :)
15:25:10 <mauke> > product [1..100]
15:25:11 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
15:25:12 <eulera> > foldr (\x y -> x * y) 1 [1 .. 100]
15:25:13 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
15:25:20 <eulera> hm
15:25:25 <eulera> big number..
15:25:43 <mauke> > length . show . product $ [1..100]
15:25:44 <lambdabot>   158
15:26:01 <eulera> > foldr (\x y -> x + y)  [1 .. 100]
15:26:02 <lambdabot>       Overlapping instances for Show ([[t]] -> [t])
15:26:02 <lambdabot>        arising from a use...
15:26:11 <eulera> > sum [1..100]
15:26:12 <lambdabot>   5050
15:26:52 <vixey> anyone bored and got Agda 2 working? :?
15:27:07 <elliottt> i've got agda 2 working!
15:27:12 <vixey> cool
15:27:14 <elliottt> :)
15:27:15 <vixey> I can't run it on this machine :/
15:27:20 <elliottt> that's no good
15:27:22 <elliottt> why's that?
15:27:25 <SamB_XP> vixey: you need to get more RAM
15:27:30 <elliottt> ah, ram.
15:27:31 <SamB_XP> or a different CPU
15:27:31 <vixey> elliottt: I have to get my computer back from the people who aren't fixing it
15:27:46 <elliottt> vixey: are they just stealing it instead? :)
15:28:07 <vixey> Well I was worrying about that but I don't think so
15:30:41 <vixey> It's nice to know I'm not the only one that jumps to conclusions like that
15:30:57 <elliottt> hehe :)
15:31:23 * geezusfreeek has agda2 working at home
15:31:24 <vixey> elliottt: Yo  have written any stuff in Agda 2 yet?
15:31:48 <vixey> well if either of you get bored come to #agda and I can boss you about :p
15:31:53 <elliottt> vixey: not much.  just a few experiments :)
15:31:55 * vixey wants someone to try programming something
15:32:00 <Elly> vixey: done
15:32:07 <vixey>  what's done
15:32:11 <hackage> Uploaded to hackage: franchise 0.0.2
15:32:45 <Elly> vixey: I tried programming something
15:32:57 <vixey> Elly: oh what?
15:33:03 <Elly> vixey: nothing really :P
15:33:13 <geezusfreeek> i seem to mostly use it for playing with ideas that i can't be sure will work and want to try different properties on it
15:33:23 <geezusfreeek> the other day i prototyped some of my FRP ideas
15:33:43 <geezusfreeek> and subsequently ruled them out because they were nontrivial to prove
15:33:47 <vixey> geezusfreeek: cool you should post this stuff online it would be interesting to read over
15:33:57 <geezusfreeek> perhaps
15:34:07 <geezusfreeek> it certainly was not worthy of showing in the form it ended up in ;)
15:34:45 <monochrom> Someone is always programming something.
15:35:12 * geezusfreeek is not sure he still has it
15:35:15 <geezusfreeek> i will check when i get home
15:36:16 <mmorrow> dolio, Saizan: ok, i think i've got autoderiving the SAPL newtype+selectors (in haskell w/ newtype) from an arbitrary haskell data decl working http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=103#a112
15:42:26 <mmorrow> @pl \f_2 f_3 f_4 f_5 f_6 f_7 f_8 f_9 f_10 f_11 f_12 f_13 f_14 f_15 f_16 f_17 f_18 -> f_18 x_0 x_1
15:42:26 <lambdabot> const (const (const (const (const (const (const (const (const (const (const (const (const (const (const (const (flip ($ x_0) x_1))))))))))))))))
15:42:39 <idnar> ouch
15:43:49 <monochrom> Nice!
15:43:58 <mmorrow> heh, that not that bad actually. just a foldr
15:44:29 <mmorrow> ooh, actually..
15:44:44 <mmorrow> @pl \f_3 f_4 f_5 f_6 f_7 f_8 f_9 f_10 f_11 f_12 f_13 f_14 f_15 f_16 f_17 f_18 f_19 -> f_10 x_0 x_1 x_2
15:44:45 <lambdabot> const (const (const (const (const (const (const (const . const . const . const . const . const . const . const . const . flip (flip ($ x_0) x_1) x_2)))))))
15:44:52 <mmorrow> hmm
15:45:09 <mmorrow> forget that
15:46:17 <vixey> what are you doing with sapl
15:46:32 <rwbarton> Will ghci in 6.10 still clear the environment when a :load fails?
15:48:26 <mmorrow> vixey: i'm trying to transform a haskell data decl to its sapl form. then from there implement the pattern-match-function-def to no-patterns-sapl form translation they describe in the second sapl paper
15:48:37 <lispy> dcoutts: is there anything in cabal or cabal-install that requires Setup.hs to be named thusly?
15:49:06 <vixey> haven't seen that paper
15:49:24 <vixey> I might have 3/4 implemented something vaugly similar
15:49:25 <mmorrow> vixey: there're two papers that are i think two versions of the same thing. i'm following the newer one http://www.st.cs.ru.nl/papers/2006/janj2006-TFP06-EfficientInterpretation.pdf
15:49:28 <lambdabot> Title: Efficient Interpretation by Transforming Data Types and Patterns to Functions, http://tinyurl.com/5y5sge
15:49:34 <dcoutts> lispy: yes, hackage upload checks for it.
15:49:39 <mmorrow> the older one is http://www.st.cs.ru.nl/papers/2005/janj2005-PatternMatchingByFunctionsIFL05.pdf
15:49:45 <lambdabot> Title: Data Types and Pattern Matching by Function Application, http://tinyurl.com/4kyxdv
15:49:48 <dcoutts> lispy: and cabal-install only looks for Setup.hs or .lhs
15:49:51 <lispy> dcoutts: oh I see.  Hrm...that's going to be a problem
15:50:00 <dcoutts> lispy: how so?
15:50:00 <mmorrow> vixey: yeah, i remember you did something with a pattern match compiler
15:50:17 <dcoutts> lispy: you're talking about the franchise Setup.hs ?
15:50:43 <vixey> it is was a warm up for something harder :))
15:51:02 <mmorrow> heh
15:51:37 <vixey> this is a bit odd, I think they do it differently
15:51:55 <BMeph> dons: ping
15:52:58 <mmorrow> vixey: also there's a ppt from the sapl creator describing a (really short) sapl to C++ compiler http://fpdag2007.hypernation.net/publications/FPDag2007-jansen.ppt
15:53:11 <lambdabot> http://tinyurl.com/4j6uwa
15:53:14 <mmorrow> here's the html google link http://209.85.165.104/search?q=cache:cDHObaslryAJ:fpdag2007.hypernation.net/publications/FPDag2007-jansen.ppt+SAPL+simple+applicative+programming+language&hl=en&ct=clnk&cd=1&gl=us
15:53:15 <lambdabot> Title: From Interpretation to Compilation, http://tinyurl.com/3z5j3l
15:53:25 <inimino> what's the best way to get the log of an Integer?
15:53:53 <saml> > log 2
15:53:55 <lambdabot>   0.6931471805599453
15:54:07 <FunctorSalad> @type log
15:54:07 <saml> i don't think log is closed on integers
15:54:08 <lambdabot> forall a. (Floating a) => a -> a
15:54:09 <inimino> > log (2::Integer)
15:54:10 <lambdabot>       No instance for (Floating Integer)
15:54:10 <lambdabot>        arising from a use of `log' a...
15:54:12 <lispy> inimino: there is an integer log in GHC's prelude, but I don't think it's exported
15:54:24 <saml> inimino, you mean you want to get log of a large number?
15:54:27 <lispy> inimino: I recall using copy & paste to export it
15:54:28 <inimino> lispy: oh, hm
15:54:37 <inimino> saml: yes, precisely
15:55:12 <BMeph> inimino: Have you tried fromIntegral? :)
15:55:15 <FunctorSalad> depends on the internals of Integer if you really care about performance
15:55:16 <inimino> lispy: maybe I'll look into that
15:55:46 <inimino> BMeph: my Integer will often overflow a Double
15:55:49 <BMeph> > log.fromIntegral $ 6931471805599453
15:55:50 <FunctorSalad> (count the digits and deal with signpost errors)
15:55:51 <lambdabot>   36.474848567323065
15:56:07 <lispy> inimino: really it needs to be put into Numeric or somewhere as it's really a useful thing to have
15:56:42 <inimino> lispy: I agree, the Integer type seems to really be lacking that particular ability...
15:56:45 <saml> > log 10
15:56:47 <lambdabot>   2.302585092994046
15:56:54 <inimino> I guess I'll cut and paste
15:57:09 <FunctorSalad> so the problem is not peformance, just that it doesn't fit into double?
15:57:42 <inimino> FunctorSalad: right
15:58:44 <lispy> inimino: i was very new to haskell, it's possible I missed the export and it's really there
15:58:52 <lispy> let me see if I have that code handy
15:59:18 <FunctorSalad> inimino: unless I'm missing something you could repeatedly divide by the base, rounding down, until the result is less than the base
15:59:36 <lispy> inimino: last function in the file: http://files.codersbase.com/miller-rabin.hs
15:59:39 <FunctorSalad> (the exact procedure would depend on how you want to round the log to an integer)
15:59:41 <BMeph> inimino: Have you tried printing the result as a Rational? :)
15:59:46 <FunctorSalad> assuming you want an integer result
16:00:34 <inimino> FunctorSalad: that's true, I was just hoping there'd be a library function with less pessimal performance characteristics
16:00:45 <rwbarton> inimino: log to what base?
16:01:07 <inimino> rwbarton: 2 or e, doesn't really matter
16:01:34 <FunctorSalad> inimino: the squaring-the-base thing in what lispy linked might achieve that
16:01:59 <rwbarton> inimino: oh, you only want the log to Double precision, but the Integer might be large? hmm
16:02:02 <saml> log x = n      base^n = x      how can I find n ? given base, n, x are Integer ?
16:02:27 <inimino> rwbarton: yes, exactly
16:02:51 <lispy> inimino: yeah as FunctorSalad points out the definitions in that file are asymptotically good, but could probably be further optimized
16:02:54 <rwbarton> inimino: so ideally you'd ask gmp for the length of the Integer in base 2 and the leading 53 bits or so
16:03:02 <lispy> inimino: I found it quite fast, to be honest
16:03:34 <inimino> rwbarton: yes, exactly, but there doesn't seem to be any standard Haskell interface for that, or I'm missing it
16:04:38 <inimino> lispy: that code might be good enough for what I need
16:04:50 <inimino> (fast enough)
16:04:54 * lispy nods
16:05:01 <lispy> using gmp under the hood is a win
16:05:10 <saml> can't haskell solve equations?
16:05:22 <lispy> inimino: and there are other goodies in this file if you need them: http://files.codersbase.com/rsa.hs
16:05:36 <saml> i remember seeing something like:   f n + 1 = 3;  n => 2
16:05:52 <lispy> saml: you might be thinking of (n+k) patterns
16:06:00 <lispy> > f (n+1) = n in f 4
16:06:01 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 16}
16:06:01 <lambdabot> ...
16:06:10 <lispy> > let f (n+1) = n in f 4
16:06:11 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 24}
16:06:11 <lambdabot> ...
16:06:13 <rwbarton> > let n+1 = 3 in n
16:06:15 <lambdabot>   n
16:06:24 <rwbarton> :)
16:06:30 <lispy> what is my typo?
16:06:52 <rwbarton> works in ghci
16:07:06 <saml> lispy, ah right
16:07:09 <FunctorSalad> @more
16:07:09 <lispy> > let foo (n+1) = n in f 4
16:07:10 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 26}
16:07:10 <lambdabot> ...
16:07:10 <rwbarton> > let (n+1) = 3 in n   -- also works in ghci
16:07:10 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 22}
16:07:11 <lambdabot> ...
16:07:13 <lispy> > let foo (n+1) = n in foo 4
16:07:14 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 26}
16:07:14 <lambdabot> ...
16:07:15 <rwbarton> , let (n+1) = 3 in n
16:07:17 <lunabot>  2
16:07:18 <rwbarton> ha!
16:07:48 <idnar> heh
16:08:01 <saml> what's base of log ?
16:08:07 <idnar> > log 2
16:08:07 <inimino> saml: e
16:08:08 <lispy> inimino: I always meant to use that miller-rabin.hs to do the (string pseudo) primality tests in my rsa implementation
16:08:09 <lambdabot>   0.6931471805599453
16:08:11 <idnar> > log 10
16:08:12 <saml> > e
16:08:12 <lambdabot>   2.302585092994046
16:08:14 <lambdabot>   e
16:08:24 <idnar> > log 2.7182818284590451
16:08:26 <lambdabot>   1.0
16:08:46 <inimino> lispy: looks interesting
16:08:53 <idnar> eeeeeeeeeeeeextacy
16:10:24 <lispy> (I meant strong not string BTW)
16:10:35 <pastorn> @pl \x y -> show x ++ show y
16:10:36 <lambdabot> (. show) . (++) . show
16:10:45 <saml> > let f x (3 ^ n) | x = 3 ^ n = n in f 2342335234634565465465447456
16:10:45 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 36}
16:10:45 <lambdabot> ...
16:10:55 <saml> given 3 is base of log
16:11:07 <saml> no i fail
16:12:19 <idnar> @type (++) `on` show
16:12:20 <lambdabot> forall a. (Show a) => a -> a -> [Char]
16:12:28 <rwbarton> > logBase 3 2342335234634565465465447456 :: CReal
16:12:29 <lambdabot>   57.3641370628541642906580169261084159417096
16:12:43 <idnar> @type (&&&)
16:12:45 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
16:13:38 <TOLUanckA> 0
16:13:50 <FunctorSalad> the variable names in Arrow could be better ;-)
16:14:03 <lasts> hi, what is "* -> * -> *" ? do you have a link, something I could look at ? it's not the first time I see this strange type..
16:14:10 <vixey> yeah it should use (~>) instead of a
16:14:23 <idnar> heh
16:14:33 <idnar> lasts: that's a kind, not a type
16:14:41 <FunctorSalad> vixey: yes, but anything that doesn't suggest that a,b and c play the same role would be a start ;-)
16:14:44 <vixey> lasts: it's the kind of a type constructor that takes two types and ends up with a type
16:15:04 <vixey> lasts: so e.g  3 :: Int :: *, True :: Bool :: *
16:15:09 <saml> in a list of numbers, how can I find a number n that is n <= x ?
16:15:10 <saml> x is given
16:15:13 <lasts> hmm
16:15:14 <vixey> lasts: \3 -> True :: Int -> Bool :: *
16:15:22 <vixey> lasts: (->) :: * -> * -> *
16:15:35 <vixey> :t \3 -> True
16:15:37 <lambdabot> forall t. (Num t) => t -> Bool
16:15:42 <vixey> :/
16:15:43 <idnar> @kind Maybe
16:15:44 <lambdabot> * -> *
16:16:20 <FunctorSalad> @let x=7 in filter (<= x) [5..10]
16:16:20 <lambdabot>   Parse error
16:16:30 <FunctorSalad> >let x=7 in filter (<= x) [5..10]
16:16:30 <ozy`> @src id
16:16:31 <lambdabot> id x = x
16:16:40 <ozy`> @src flip
16:16:41 <lambdabot> flip f x y = f y x
16:16:45 <FunctorSalad> > let x=7 in filter (<= x) [5..10]
16:16:47 <lambdabot>   [5,6,7]
16:16:52 <FunctorSalad> that was @saml
16:17:04 <rwbarton> lasts:
16:17:05 <rwbarton> @kind Bool
16:17:07 <lambdabot> *
16:17:08 <rwbarton> @kind Either
16:17:09 <lambdabot> * -> * -> *
16:17:17 <rwbarton> What is the difference between Bool and Either?
16:17:21 <lasts> hmhm
16:17:46 <lasts> Either has two "type arguments" ?
16:17:51 <rwbarton> precisely
16:18:00 <lament> one is of order 0, one is of order 1?
16:18:13 <rwbarton> just like,
16:18:14 <rwbarton> :t 0
16:18:16 <lambdabot> forall t. (Num t) => t
16:18:17 <rwbarton> :t (+)
16:18:17 <lasts> but yeah, I think I've understand the basic idea of kinds
16:18:18 <lambdabot> forall a. (Num a) => a -> a -> a
16:18:28 <idnar> order 
16:18:29 <FunctorSalad> lament: order? group theory?
16:18:38 <saml> > let log3 x = head (filter (>= x) (map (3^) [1..])) in log3 234237402378739274927394723472749237263496489234
16:18:40 <lambdabot>   515377520732011331036461129765621272702107522001
16:18:40 <FunctorSalad> lament: never mind ;-)
16:18:47 <lasts> just searching for an example
16:18:50 <lament> FunctorSalad: i'm thinking polynomials
16:19:28 <FunctorSalad> lament: missed that you were answering to rwbarton (I think)
16:19:54 <idnar> can you write a type that has kind (* -> *) -> * or something crazy like that?
16:20:00 <vixey> :k Mu
16:20:01 <lambdabot> (* -> *) -> *
16:20:06 <vixey> @src Mu
16:20:07 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
16:20:09 <idnar> oh heh
16:20:09 <vixey> :k Mu Maybe
16:20:10 <rwbarton> :k RWST
16:20:11 <lambdabot> *
16:20:12 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
16:20:18 <idnar> @src RWST
16:20:18 <lambdabot> Source not found. Wrong!  You cheating scum!
16:20:22 <pastorn> can i make a class without function demands?
16:20:23 <rwbarton> , src ''RWST
16:20:28 <lunabot>  newtype RWST r w s m a = RWST {runRWST :: (r ->
16:20:28 <lunabot>                                             s -> m ((a, s, w)))}
16:20:34 <FunctorSalad> ,k gfoldl
16:20:35 <lunabot>  luna: Not in scope: `k'
16:20:39 <idnar> I think my head just exploded
16:20:45 <FunctorSalad> :kind gfoldl
16:20:51 <dmwit_> idnar: You'll get used to it.
16:21:25 <idnar> > undefined :: Mu Maybe
16:21:27 <lambdabot>       No instance for (Show (Mu Maybe))
16:21:27 <lambdabot>        arising from a use of `show' a...
16:21:38 <idnar> @type undefined :: Mu Maybe
16:21:39 <lambdabot> Mu Maybe
16:21:47 <dmwit_> pastorn: sure
16:21:49 <vixey> :t In Nothing
16:21:51 <lambdabot> Mu Maybe
16:21:56 <vixey> :t In (Just (In Nothing))
16:21:57 <lambdabot> Mu Maybe
16:22:00 <vixey> :t In Just (In (Just (In Nothing)))
16:22:01 <lambdabot>     Couldn't match expected type `Mu ((->) a)'
16:22:02 <lambdabot>            against inferred type `Maybe a'
16:22:02 <lambdabot>       Expected type: a -> Mu ((->) a)
16:22:05 <vixey> 0, 1,2, ...
16:22:18 <idnar> > In Nothing
16:22:19 <lambdabot>       No instance for (Show (Mu Maybe))
16:22:19 <lambdabot>        arising from a use of `show' a...
16:22:31 <dmwit_> pastorn: It's just not very useful.  You might as well not have the class at all.
16:22:51 <idnar> > out (In Nothing)
16:22:52 <lambdabot>       No instance for (Show (Mu Maybe))
16:22:53 <lambdabot>        arising from a use of `show' a...
16:23:10 <idnar> @type out (In Nothing)
16:23:11 <lambdabot> Maybe (Mu Maybe)
16:23:49 <sbahra> died on us?
16:23:56 <sbahra> nop
16:23:59 * idnar 's head continues to explode
16:24:37 <dolio> mmorrow: How beautiful. :)
16:25:03 <vixey> it's really a shame there's no show instance for Mu
16:25:21 <rwbarton> :t gfoldl
16:25:23 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall a1 b. (Data a1) => c (a1 -> b) -> a1 -> c b) -> (forall g. g -> c g) -> a -> c a
16:25:30 <rwbarton> > gshow (In Nothing)
16:25:31 <lambdabot>       No instance for (Data (Mu Maybe))
16:25:31 <lambdabot>        arising from a use of `gshow' ...
16:26:28 <rwbarton> > gshow (Nothing :: Maybe Integer)   -- of course, ...
16:26:29 <lambdabot>   /tmp/6099379633420777413:67:32: Not in scope: `gshow'
16:26:49 <idnar> @type gshow
16:26:50 <lambdabot> forall a. (Data a) => a -> String
16:27:07 <FunctorSalad> rwbarton: good point. I did the "found head-asploding type where head-asploding kind expected" error :(
16:28:13 <vixey> someone should add it
16:34:12 <Plouj> why do I get this error: http://codepad.org/VkVEs9uL ?
16:36:33 <BMeph> Plouj: Because in Haskell, [n:rest] /= (n:rest) :)
16:37:18 <Plouj> where did I mention (n:rest)?
16:37:36 <Plouj> what am I doing wrong?
16:37:42 <humasect> [n:rest]
16:37:49 <BMeph> Plouj: You didn't, which is my point. Replace [n:rest] with (n:rest) . :)
16:38:14 <Plouj> but I want a list, not a tuple
16:38:42 <rwbarton> : builds lists
16:38:48 <ozy`> Plouj: (n,rest) would give you a tuple. but (:) is the list-building operator
16:38:53 <BMeph> Plouj: , builds tuples. ;)
16:38:53 <Plouj> exactly
16:38:59 <Plouj> I don't want tuples
16:39:06 <Plouj> I'm only using : afaik
16:39:09 <mmorrow> dolio: :)
16:39:18 <BMeph> Plouj: Then don't use a comma. Problem solved! :)
16:39:20 <rwbarton> but you're also using []
16:39:46 <Plouj> BMeph: I don't
16:39:50 <mib_5z9h8tac> o_o
16:39:52 <mib_5z9h8tac> hi guys
16:39:53 <Plouj> rwbarton: yeah, isn't [] an empty list?
16:40:00 <rwbarton> Yes...
16:40:07 <Plouj> that's what I want...
16:40:08 <rwbarton> But [x:xs] is a list containing one list, namely x:xs
16:40:19 <humasect> (x:xs) == x : xs, Plouj
16:40:19 <BMeph> Plouj: Here's the thing: in Haskell, (n:rest) means take n:rest, and put parens around it. :)
16:40:20 <ozy`> Plouj: [n:rest] means [[n, ...]]
16:40:34 <Plouj> ozy`: oooh
16:40:45 <mib_5z9h8tac> test
16:41:05 <BMeph> mib_5z9h8tac: fail
16:41:16 <Plouj> so, I need to have (n:rest)?
16:41:23 <humasect> @hoogle lift
16:41:24 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
16:41:24 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
16:41:24 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
16:41:47 <mib_5z9h8tac> can someone take a look in this code?
16:41:49 <mib_5z9h8tac> http://hpaste.org/11058#a1
16:42:16 <Plouj> ok, that makes sense now
16:42:30 <Plouj> I always get tripped by the head:tail syntax in languges
16:42:47 * dolio blames Prolog.
16:44:00 <mib_5z9h8tac> anyone?
16:44:57 <dolio> [f | f <- ["ab", "bc"]] is the same as ["ab", "bc"].
16:46:13 <dolio> If you want to apply the formatting to each element of the list, clearly you want to be operating on the f in the output, not the entire list.
16:52:38 * BMeph hopes that immediate quit was either a network fault or an eagerness to return to hacking...
16:55:10 <dolio> He quit? Man...
16:55:17 <dolio> I should turn notifications back on.
16:56:49 <dolio> I'm pretty sure he's been here before, though, and I'm not terribly surprised by what happened.
16:56:59 <mib_5z9h8tac> hmm weird
16:57:10 <mib_5z9h8tac> i was dc, no wonder i did not received any reply
16:57:30 <mib_5z9h8tac> so does anyone know how to fix this? http://hpaste.org/11058#a1
16:57:47 <dolio> [f | f <- ["ab", "bc"]] is the same as ["ab", "bc"].
16:57:52 <dolio> If you want to apply the formatting to each element of the list, clearly you want to be operating on the f in the output, not the entire list.
17:00:05 <dolio> My comments have the power to disconnect people!
17:06:30 <Olathe> dolio: Quick, stop commenting ! ;)
17:06:49 <sbahra> Hi.
17:07:02 <sbahra> Looking at some information on ByteString in Real World Haskell.
17:07:06 <pumpkin_> haskell's syntax isn't context-free is it?
17:07:22 <sbahra> There is an example there...
17:07:22 <thoughtpolice> don't believe so, no.
17:07:30 <sbahra> L.split (',') blah
17:07:33 <sbahra> Where blah is a ByteString
17:07:45 <sbahra> However, when I do this here...
17:07:59 <sbahra>     Couldn't match expected type `Word8' against inferred type `Char'
17:08:11 <thoughtpolice> sbahra: you need Data.ByteString.Char8
17:08:22 <sbahra> dohhhhhh
17:08:24 <sbahra> Thanks
17:08:53 <thoughtpolice> sbahra: the general convention is, there are lazy bytestrings which live in Data.ByteString.Lazy.* and regular strict ones in Data.ByteString.*
17:10:13 <sbahra> nod, I copied it down wrong.
17:10:15 <thoughtpolice> sbahra: and if you have bytestring >= 0.9.0.4, and ghc >= 6.8, you can use the OverloadedStrings extension
17:10:20 <thoughtpolice> which is dandy nice
17:10:41 <thoughtpolice> it just lets you do ("hello world" :: ByteString)
17:10:44 <thoughtpolice> instead of having to pack it
17:10:45 <sbahra> Ah, great.
17:34:08 <Adamant_> why can't ghci do a Lisp-style REPL? Is it something fundamental about Haskell or just implementation choice?
17:34:34 <dolio> What's a Lisp-style REPL?
17:35:36 <dons> its an implementation choice, Adamant_
17:35:53 <skorpan> i don't get it
17:35:54 <dons> but it follows from strong static typing and dependency analysis
17:35:58 <dons> that makes things harder.
17:35:59 <skorpan> doesn't ghci do just that?
17:36:05 <dons> you can't define newtypes in ghci
17:36:09 <dons> you can in hbi though
17:36:13 <skorpan> reads expressions, evaluates them and prints them?
17:36:17 <dons> so clearly it is doable. lennart wrote a proof by construction
17:36:28 <Zao> (loop (print (eval (read]  or something in lispy languages
17:36:30 <dons> skorpan: and defines new types, and classes and ...
17:36:37 <dons> adds new derivings etc
17:36:44 <skorpan> ok
17:36:58 <skorpan> At least two Haskell implementations provide REPL functionality. The Glasgow Haskell Compiler provides ghci and the Hugs interpreter is often used by beginners as a Haskell REPL.
17:37:19 <dons> and hbi provides full file-compatible REPL
17:37:23 <mmorrow> i'm trying to figure out how to dynamically define datatypes in ghci currently
17:37:28 <skorpan> i'm not sure what's so lisp-style about lisp-style REPL
17:37:35 <dons> but Adamant_ doesn't ghci already do read/eval/print
17:37:41 <Adamant_> skorpan: you can more or less drop in your code unchanged right into the REPL in Lisp and Scheme, or simply spend all your time coding the REPL
17:37:42 <dons> it is the types and classes it doesn't do
17:37:45 <dons> but neither does lisp.
17:37:52 <lispy> Zao: hi
17:37:52 <dons> ah
17:37:56 <dons> drag and drop
17:38:16 <mmorrow> yeah, lisp has to do /significantly/ less than haskell to interpret the code
17:39:05 <mmorrow> and lisp doesn't have to worry about static typing and all that
17:39:09 <skorpan> i still think i don't quite get it. "drop in your code unchanged" isn't possible in ghci?
17:39:17 <mmorrow> :l A.hs
17:39:20 <lispy> skorpan: I don't think newbies turn to hugs anymore.  It seems more beginners are using ghci than hugs in my experience.
17:39:31 <skorpan> lispy: that was just a quote from wikipedia on REPL
17:39:41 <lispy> skorpan: ah
17:39:43 <Adamant_> skorpan: try it sometime
17:39:59 <skorpan> Adamant_: try what? ghci?
17:40:22 <Adamant_> no, just cut n pasting random Haskell programs into ghci
17:40:28 <mib_5z9h8tac> o_+o
17:40:31 <mib_5z9h8tac> weird
17:40:33 <mib_5z9h8tac> i keep dc
17:40:35 <mib_5z9h8tac> hey guys
17:40:43 <mib_5z9h8tac> i want to ask how do i take 1 element out at a time from a list
17:40:47 <rwbarton> In fact, no top-level definitions in a haskell program are legal input to ghci
17:40:51 <mib_5z9h8tac> let say i have [1,2,3,4]
17:41:01 <mib_5z9h8tac> i want to display each element out 1 time, then loop again
17:41:03 <lispy> The wise scheme/lisp/python hackers all seem to agree that you want a sterile environment when hacking your code, and that you only use a REPL for experimentation.  This idiom is actually the default with GHCi, FWIW.
17:41:07 <mib_5z9h8tac> display 1, then display 2
17:41:32 <mib_5z9h8tac>  is it like this? x <- x:xs?
17:41:37 <Adamant_> lispy: there is no general community consensus on it.
17:41:38 <mmorrow> , fix (\loop env -> getLine >>= \l -> if l==":q" then return env else let v = eval l in print v >> loop (v:env))
17:41:40 <lunabot>  luna: No instance for (GHC.Show.Show
17:41:48 <skorpan> mib_5z9h8tac: what do you want to do with each number specifically?
17:41:54 <mib_5z9h8tac>  is it like this? x <- [x:xs]?
17:42:01 <skorpan> no, it's not at all like that
17:42:11 <rwbarton> I just wish a failed load didn't clear the environment in ghci, because usually the first thing I want to do after a failed load is check the types of various expressions
17:42:12 <lispy> Adamant_: that may be, but the seasoned and wise devs I've talked to seem to agree on what I said.  At least the ones I've talked to, and it's been my experience as well.
17:42:13 <mib_5z9h8tac> actually
17:42:27 <mib_5z9h8tac> skorpan: I want to use those values into another function
17:42:34 <Adamant_> lispy: I agree many devs will agree with you, but many will not
17:42:40 <skorpan> mib_5z9h8tac: then you use the "map" function in haskell
17:42:42 <skorpan> :t map
17:42:44 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:42:57 <ozy`> mib_5z9h8tac: head (x:xs) = x -- this function will return the first item in a list
17:42:59 <mib_5z9h8tac> skorpan http://hpaste.org/11058#a3
17:43:00 <skorpan> so: map otherFunction (x:xs)
17:43:01 <mmorrow> rwbarton: yeah totally. it'd be awesome if you could also save entire ghci sessions and restore them at an arbitrary later time
17:43:08 <mib_5z9h8tac> ozy http://hpaste.org/11058#a3
17:43:10 <Adamant_> also, I want my programs bondaged and discplined, not my coding style
17:43:35 <mmorrow> rwbarton: or e.g. email them to someone else and they'd be able to load /exactly/ your heap.
17:43:41 <mib_5z9h8tac> the xs is list of int, while ys is a list of string
17:43:54 <lispy> Adamant_: then you should probable switch to a less flexible language like C
17:44:03 <Adamant_> lispy: I'm pretty much used to coding Haskell the Haskell way now.
17:44:17 <mib_5z9h8tac> o
17:44:38 <mmorrow> Adamant_: say more about what you find convenient in lisp's repl that the haskell repl lacks.
17:45:12 <mmorrow> ie what "coding style" does the lisp repl allow which ghci doesn't
17:45:15 <mmorrow> ?
17:45:20 <mib_5z9h8tac> skorpan dc
17:45:50 <Adamant_> mmorrow: developing programs at the REPL instead of developing in a text file, then loading the file in ghci
17:46:25 <humasect> :re :re :re :re :re :re :re :re
17:46:39 <mib_5z9h8tac> when i type x:xs it said x undefined variable
17:47:00 <mib_5z9h8tac> ozy : when i type x:xs it said x undefined variable
17:47:00 <ozy`> mib_5z9h8tac: that's probably because you used it on the right-hand side of a definition
17:47:18 <mib_5z9h8tac> right hand side means?
17:47:46 <mib_5z9h8tac> head (x:xs) << right hand side?
17:47:46 <ozy`> leftHandSide = rightHandSide
17:47:58 <mib_5z9h8tac> how do i use it on the righthand side?
17:48:33 <mmorrow> Adamant_: hmm, so you can already do multiline expressions in ghci. so the real/only thing that seems to be lacking then is declaration of datatypes and classes, then. ?
17:49:23 <Adamant_> lispy: I have to disagree with your C comment. I'm using Haskell because I want the bondage and discipline at the language level, I would just like for ghci to quit harshing my mellow and let me write a whole small program at the REPL. this is more or less what I am asking if is possible or if I just have to bite the bullet on it.
17:49:46 <Adamant_> mmorrow: right
17:50:06 <mmorrow> but then, what would be the behaviour be if you redefing a datatype, then there are functions existing which refer to the old version which no longer exists?
17:50:36 <mmorrow> you cannot call these functions with the old datatype, which is /not/ of the same type as the new one by the same name.
17:50:43 <lispy> Adamant_: I don't understand what you're trying to assert wrt Haskell and bondage.  Haskell is one of the most flexible languages I've ever seen.  If you want something more restrictive and less flexible, really something like C would be more appropriate.
17:51:04 <Adamant_> and having to use let for things instead of just x = y
17:51:08 <cpfr> hey how do i use cabal-install with haskell code not in hackage
17:51:25 <Adamant_> lispy: I am not using the b&d part as an insult, if that's what you're thinking.
17:51:26 <mmorrow> Adamant_: you have to use let because you're in an IO do block in ghci
17:51:37 <lispy> cpfr: I think you just need to put a .cabal file in the directory...but I'm not sure
17:51:38 <Adamant_> mmorrow: right.
17:51:53 <inimino> Adamant_: I have given up on using GHCi in the way you describe
17:52:05 <mmorrow> Adamant_: ok, if you weren't, you wouldn't be able to run /any/ IO actions without unsafePerformIO
17:52:35 <mmorrow> so there goes interaction with the outside world
17:52:50 <cpfr> lispy, if i have a cabal file
17:52:52 <Adamant_> ok. so it's not possible. got it.
17:52:56 <lispy> Adamant_: I just don't understand why you want a to use a restrictive language but you're using Haskell.  I can't grok it.
17:53:08 <mmorrow> Adamant_: i'm not saying that, i'm trying to come up with a solution :)
17:53:24 <ozy`> hmm, doesn't ATS have a very restrictive type system?
17:53:28 <lispy> cpfr: I think you can then somehow use cabal-install in that directory to install it, but I admit, never tried it.
17:54:07 <Adamant_> lispy: look, you're getting hung up on one phrase I said that is more or less my personal codewords for very strong static typing, type safety, and that works.
17:54:20 <inimino> lispy: I think Adamant_ is complaining about the REPL, not the language ;-)
17:54:46 <Adamant_> lispy: it is not intended as a insult to you, Haskell, the room, or anyone on the planet Earth
17:54:54 <mmorrow> what if there were 2 or more /modes/, where mode 0 == the current in-an-IO-do-block mode, mode 1 == at the top level of the current "interactively defined" module, ...
17:55:02 <lispy> Adamant_: I'm not insulted, don't worry.
17:55:10 <cpfr> lispy, got it
17:55:21 <lispy> Adamant_: I just find Haskell so expressive...that it's hard to understand.
17:55:27 <mmorrow> :0
17:55:28 <Adamant_> lispy: believe me, I'm not trying to be a troll or dick so if I'm coming off that way I apologize
17:55:28 <cpfr> i just do cabal {configure, build, install}
17:55:31 <mmorrow> goto mode 0
17:55:33 <mmorrow> :1
17:55:35 <mmorrow> goto mode 1
17:55:39 <lispy> Adamant_: likewise
17:56:15 <Adamant_> lispy: and you do have a point about the type system being VERY flexible so it's less aggravating than a lot of those.
17:56:21 <Adamant_> *others
17:56:35 <mmorrow> i think using modes would do it. i'm going with that then unless anyone has a better idea :)
17:56:45 <lispy> (I would say that dynamic type systems are not more expressive but they are more optimistic)
17:57:21 <mmorrow> ooh, and you could have an arbitrary number of different sessions going at once, and can switch between them when you like
17:58:23 <Adamant_> mmorrow: thanks
17:58:36 <mmorrow> Adamant_: ;)
17:58:51 <newsham> #haskell, I love you.  *hug*
17:59:08 <newsham> I just tried to ask a question on #python.  *sigh*
17:59:25 <Adamant_> newsham: minor rippage or major?
17:59:31 * lispy pats newsham on the back
17:59:43 <newsham> just people wasting my time without answering the question
17:59:48 <dino-> I know it's not the point and apologies if this was covered in the scrollback.. but I do actually enjoy the editor side-by-side with ghci. And the edit, :r, edit more loop.
17:59:54 <lispy> newsham: like we've been doing to Adamant_ :)
18:00:11 <Adamant_> lispy: you've been feeding me parts!
18:00:19 <lispy> parts?
18:00:28 <Adamant_> at least I know more about why it wasn't done that way now
18:00:32 <lispy> ah
18:00:54 <newsham> lispy: it was more like talking to eliza than that.
18:00:57 <lispy> It does have technical reasons, but I dev python with the same idiom now and it does save me headaches.
18:01:15 <lispy> I love having a REPL...that's for sure
18:01:39 <olsner> why even ask in #python? I mean, what kind of haskell problems would #python be able to help out with?
18:01:47 <lispy> olsner: lol
18:02:05 <ozy`> newsham: what was the problem, by the way?
18:02:09 <ozy`> just curious...
18:02:37 <olsner> lispy: heh, #haskell always makes me feel so witty :)
18:02:46 <Adamant_> lispy: REPL Is good
18:03:06 * lispy does the happy REPL dance
18:03:15 * Adamant_ boogies
18:03:26 <Adamant_> nobody say lambada
18:03:29 <newsham> ozy: i had questions about building pywin32 package from src.
18:03:50 <ozy`> you can build things from source on windows?!
18:03:53 <Cale> Adamant_: Just in case, the usual way to use ghci is to keep two windows open side by side, one with the file you're editing, and one with ghci.
18:03:54 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
18:04:11 <Cale> Adamant_: Then, it's easy to reload in ghci whenever you update your file
18:04:15 <newsham> ozy: when a mommy program and a daddy program love each other very much.....
18:04:31 <Cale> Just typing : by itself on a line will reload (or :r, :reload)
18:04:41 <Adamant_> Cale: right, I usually have ghci open in a subwindow in Emacs
18:04:59 <Adamant_> you were the one who taught me that actually, so thank you!
18:05:02 <Cale> :)
18:05:11 <Cale> It would be nice to have something kind of DrSchemeish.
18:06:38 <dmwit_> I thought : got changed in 6.8 to just repeat the last :command.
18:06:51 <dmwit_> (Which is significantly less useful than being an alias for :r, in my opinion.)
18:07:08 <dmwit_> Also, :r got broken in the case of compilation errors... ;/
18:07:10 * lispy was unawares of :
18:07:39 <sjanssen> dmwit_: yeah, that bug is outrageously annoying
18:08:00 <dmwit_> It makes :r almost useless.
18:08:05 <lispy> what is the bug?
18:08:07 <dmwit_> I just end up doing :l every time.
18:08:19 <sjanssen> dmwit_: well, it :r works if the very first load compiles successfully
18:08:22 <lispy> and have you made the Simons aware of it?
18:08:24 <dmwit_> lispy: If you :r a file with errors, it compiles the file, then doesn't put you in the context of that module!
18:08:38 <lispy> dmwit_: sad
18:08:59 <sjanssen> lispy: I'm surprised you haven't noticed this
18:09:01 <dmwit_> I believe the Simons are aware of it.
18:09:26 <mib_5z9h8tac> test
18:09:30 <mib_5z9h8tac> test
18:09:34 <Zao> mib_5z9h8tac: both failed.
18:09:35 <sjanssen> mib_5z9h8tac: working
18:09:39 <dmwit_> How about you /join #test?
18:09:47 <ozy`> mib_5z9h8tac: you need a new IRC client
18:09:53 <lispy> sjanssen: I won't use 6.10 until 6.10 final
18:10:02 <sjanssen> lispy: this is in 6.8
18:10:03 <ozy`> you keep getting disconnected about 30 seconds after your last question
18:10:04 <Zao> It's sad when you can't trust the software you run to work correctly.
18:10:05 <dmwit_> lispy: The bug is in 6.8.
18:10:09 <Zao> If only mibbit was written in Haskell :P
18:10:19 <mib_5z9h8tac> hey guys
18:10:25 <lispy> ah, then I am surprised I didn't notice it
18:10:52 <lispy> go little old unobservant me
18:12:52 <BMeph> mib_5z9h8tac: So, have you looked at your example lately? ;)
18:13:00 * BMeph sighs
18:13:56 <sjanssen> @keal
18:13:56 <lambdabot> the fractal is 5 irrationals
18:14:08 <dmwit> I show how to spell triangle in less than three points
18:14:42 <dmwit> triangle is five irrationals in a dark manifold
18:15:02 * Olathe starts up the techno beat.
18:15:06 <lispy> me needs 2.\overbar{9} points, at least
18:15:10 <Olathe> The fractal is five irrationals !
18:16:03 <sjanssen> Olathe: heh, @keal generated music would be awesome
18:16:04 <sjanssen> @keal
18:16:05 <lambdabot> b*(Floor[v/b^p]/b-Floor[Floor[v/b^p]/b])
18:16:10 <sjanssen> not that one so much
18:16:11 <sjanssen> @keal
18:16:11 <lambdabot> just seeing how offtopic i could get everyone
18:16:55 <lispy> keal was special.  Not everyone can see the universe unhappening
18:16:57 <lispy> ?keal
18:17:05 <lambdabot> i suggest you tear apart a 20q and plug it with the alg
18:18:07 <dolio> @protontorpedo
18:18:07 <lambdabot> so how do you use haskell tools to build large programs?
18:18:22 <sjanssen> @girl19
18:18:23 <lambdabot> I've always found myself unequal to the intellectual pressure of programming
18:18:32 <dolio> protontorpedo had kind of a 1-track mind.
18:18:51 <sjanssen> @palomer
18:18:52 <lambdabot> You're all nuts
18:18:56 <sjanssen> #haskell has the best trolls
18:19:09 <dmwit> ?palomer
18:19:09 <lambdabot> Brump!
18:19:14 <dmwit> Brump!
18:19:16 <dmwit> hehe
18:19:19 <dolio> Of course, @protontorpedo is kind of like reading reddit.
18:19:23 <mrd> sjanssen: we get what we pay for
18:20:00 <mib_xet7r3vb> man
18:20:04 <mib_xet7r3vb> crab meat
18:20:05 <mib_xet7r3vb> >1+1
18:20:07 <dolio> test
18:20:14 <mib_xet7r3vb> >2+2
18:20:19 <sjanssen> What manual page do you want?
18:20:19 <mib_xet7r3vb> >3+3
18:20:21 <dmwit> Needs more space to breathe!
18:20:24 <dmwit> > 2+2
18:20:25 <lambdabot>   4
18:20:25 <sjanssen> mib_xet7r3vb: space after >
18:20:30 <mib_xet7r3vb> hey guys
18:20:32 <mib_xet7r3vb> help me
18:20:40 <mib_xet7r3vb> my irc keep disconnecting me
18:20:54 <sjanssen> mib_xet7r3vb: can you use a real IRC client?
18:21:01 <mib_xet7r3vb> recommend me 1?
18:21:11 <mib_xet7r3vb> my xchat 30 days trial is expried
18:21:15 <sjanssen> mib_xet7r3vb: what is your operating system?
18:21:18 <mib_xet7r3vb> so i have no irc tool
18:21:18 <dmwit> 30-day trial?
18:21:20 <dmwit> WTF
18:21:20 <mib_xet7r3vb> windows
18:21:28 <dmwit> I have heard good things about mirc.
18:21:32 <mib_xet7r3vb> yeah, when i open xchat it says expired, please buy xchat
18:21:37 <mib_xet7r3vb> -_-"
18:21:46 <dmwit> But... xchat is FOSS.
18:21:51 <dolio> Isn't xchat free software?
18:21:58 <mib_xet7r3vb> i was waiting for ozy to reply on my haskell problem, but then again, i did not reeive any reply, fromthere i knew i was dc
18:22:05 * dmwit is using xchat right now
18:22:05 <sjanssen> dmwit: I think there are a few non-free front ends to xchat
18:22:13 <mrd> it's in debian main, so it's DFSG-free
18:22:15 <ozy`> mib_xet7r3vb: I keep telling you, get a new IRC client :p
18:22:17 <mib_xet7r3vb> i was waiting patiently for 15 minutes for someone to reply, but no one replied -_-"
18:22:22 <sjanssen> IIRC the Aqua front end is non-free
18:22:25 <lispy> dmwit, dolio: x-chat on windows seriously does require donation on windows :(
18:22:27 <mib_xet7r3vb> ozy, what irc do you recommend? free one
18:22:35 <ozy`> mib_xet7r3vb: what OS?
18:22:39 <mib_xet7r3vb> windows
18:22:42 <ozy`> ah
18:22:50 <dolio> Huh.
18:22:55 <dmwit> Didn't I suggest mirc?
18:23:01 <mib_xet7r3vb> is it free?
18:23:04 <ozy`> you can use mIRC even after the demo period "expires"
18:23:07 <mib_xet7r3vb> no funny 30 days trial
18:23:08 <ozy`> so it's effectively free
18:23:23 <lispy> mib_xet7r3vb: chatzilla from the mozilla people
18:23:33 <lispy> mib_xet7r3vb: pidgeon the IM can do IRC
18:23:40 <ozy`> yeah, chatzilla runs inside firefox
18:23:43 <mib_xet7r3vb> chatzilla?
18:23:53 <sjanssen> @google chatzilla
18:23:57 <lambdabot> https://addons.mozilla.org/firefox/addon/16
18:23:58 <sjanssen> srsly
18:24:10 <mib_xet7r3vb> i was asking about the left hand side and right hand side thingy
18:24:18 <ozy`> mib_xet7r3vb: yes, I remember
18:24:19 <mib_xet7r3vb> downloading fire fox ... =x
18:24:47 <dino-> I don't know how well it works, but I use irssi in Linux and there's a Windows version listed: http://irssi.org/download
18:24:53 <mib_xet7r3vb> head (x:xs)
18:25:02 <mib_xet7r3vb> i placed it on the right, but i could not make it to work
18:25:07 <mib_xet7r3vb> > 1+1
18:25:08 <lambdabot>   2
18:25:25 <mib_xet7r3vb> > 1+1 --i do this to check whether im still connected to haskell
18:25:27 <lambdabot>   2
18:26:51 <mib_xet7r3vb> hello?
18:27:22 <sjanssen> yes?
18:27:37 <sjanssen> mib_xet7r3vb: so what is your question, I must have missed it
18:28:57 <mmorrow> i just put the ghc rc's haddock docs here http://moonpatio.com/docs/ghc/
18:28:57 <mib_xet7r3vb> wait
18:29:04 <lambdabot> Title: ghc-6.10.0.20081007: XXX
18:29:05 <mib_xet7r3vb> i have opera, how do i use opera to chat here?
18:29:08 <mmorrow> and hscoloured src in here http://moonpatio.com/docs/ghc/src
18:29:09 <ozy`> mib_xet7r3vb: "head (x:xs) = x" was an example of a function definition... and then you could do "head xs" to get the first element of the list xs
18:29:10 <lambdabot> Title: Index of /docs/ghc/src
18:29:21 <mmorrow> but i didn't manage to get the source links in the haddocks
18:29:24 <mib_xet7r3vb> i heard opera have irc thingy
18:29:43 <noZone> Ahoy Ahoy maties of the good ship #haskell. Arrrrrrrrrrrrrrrrrgv.
18:30:09 <lispy> noZone: avast me heartie
18:30:15 <mib_xet7r3vb> could i write something like this ? x <- head (x:xs) ?
18:30:31 <mib_xet7r3vb> because i want to use the INT value from the list into my replicate
18:30:33 <ozy`> mib_xet7r3vb: that depends on where you write it
18:30:47 <mib_xet7r3vb> replicate (x <- head(x:xs)) ' '
18:30:53 <mib_xet7r3vb> is it correct?
18:30:56 <sjanssen> mib_xet7r3vb: in some contexts that is valid.  But I don't think it means what you think it does
18:31:01 <sjanssen> mib_xet7r3vb: that makes no sense
18:31:04 <lispy> > (\(x:xs) -> do h <- (x:xs); return h) [[[1]]]
18:31:05 <lambdabot>   [[[1]]]
18:31:27 <ozy`> mib_xet7r3vb: I think you'd want: replicate (head xs)
18:31:33 <mib_xet7r3vb> oh
18:31:34 <mmorrow> here's ghci's bytecode instruction datatype for its interp http://moonpatio.com/docs/ghc/ByteCodeInstr.html
18:31:35 <lambdabot> Title: ByteCodeInstr
18:31:40 <edwardk> @seen goltrpoat
18:31:40 <lambdabot> I haven't seen goltrpoat.
18:31:42 <mib_xet7r3vb> i''l try that out
18:32:37 <ozy`> mib_xet7r3vb: also, you don't seem to realize that (<-) is more or less specific to monads
18:32:44 <ozy`> (ie. functions with "do" blocks)
18:32:48 <mib_xet7r3vb> oh
18:32:55 <mib_xet7r3vb> thanks, i was learning monads on the other day
18:32:57 <dolio> And list comprehensions.
18:33:10 <ozy`> dolio: hence "more or less"...
18:33:12 <mib_xet7r3vb> but i couldnt think of a way to take a number from the list and add it into my function
18:33:18 <mib_xet7r3vb> so i think about using monad
18:33:20 <dolio> :)
18:33:22 <mib_xet7r3vb> monad style
18:33:37 <mib_xet7r3vb> it works!
18:33:51 <noZone> monad style... keep yer sex life out of this room.
18:35:40 <lispy> ?vixen do you like it monad style?
18:35:41 <lambdabot> sure, i definitely don't hate
18:36:01 <lispy> Vixen, not a hater.
18:36:56 <mib_xet7r3vb> hey guys
18:37:04 <mib_xet7r3vb> how do i calculate the length of each element?
18:37:06 <mib_xet7r3vb> > length["abc","def"]
18:37:07 <lambdabot>   2
18:37:16 <mib_xet7r3vb> like abc is 3 letters, it should produce 3 instead of 2
18:37:22 <lispy> > map length ["abc", "def"]
18:37:23 <lambdabot>   [3,3]
18:37:31 <mib_xet7r3vb> -_-" man you guys are pros
18:37:40 <mib_xet7r3vb> answer on the spot
18:37:42 * lispy fears he just did someone's homework for them
18:37:52 <lispy> :)
18:37:58 <mib_xet7r3vb> what  is homework?
18:38:03 <lispy> mib_xet7r3vb: that's $4 please :)
18:38:08 <mib_xet7r3vb> im not doing homework now lol
18:38:24 <lispy> mib_xet7r3vb: just put it on your tab I suppose? ;)
18:38:27 <dolio> What is the matrix?
18:39:33 <dmwit> dolio: ?
18:39:45 <sjanssen> follow the white rabbit, etc.
18:40:03 <rwbarton> @yow
18:40:03 <lambdabot> Hello.  Just walk along and try NOT to think about your INTESTINES
18:40:03 <lambdabot> being almost FORTY YARDS LONG!!
18:40:10 <Olathe> Alice ?
18:40:11 * lispy can never remember which color of pill to consume
18:40:26 * sjanssen took the lambda pill
18:40:27 <Olathe> lispy: Ask your doctor.
18:40:55 <Olathe> Red is exciting.
18:41:00 <lispy> Olathe: But, my doctor told me not to program in FP languages.
18:41:13 <Olathe> lispy: :o
18:41:21 <lispy> Just kidding!
18:41:23 <Olathe> lispy: Time for a new doctor !
18:41:40 <lispy> > let kidding! = "haha" in Just kidding!
18:41:40 <lambdabot>   mueval: SrcLoc {srcFilename = "<unknown>.hs", srcLine = 2, srcColumn = 21}
18:41:41 <lambdabot> ...
18:41:45 <mib_xet7r3vb> hey guys, whats wrong wit this? [(map length head ys)-(head xs)]
18:41:47 <lispy> > let kidding = "haha" in Just kidding
18:41:49 <lambdabot>   Just "haha"
18:41:57 <mib_xet7r3vb> xs is list of INT and ys is list of string
18:41:59 <sjanssen> mib_xet7r3vb: map length (head ys)
18:42:05 <dmwit> mib_xet7r3vb: Subtraction is not defined for lists.
18:42:12 <sjanssen> mib_xet7r3vb: also, you can't subtract a list
18:42:38 <mib_xet7r3vb> i want the length value - the INT value, so shouldnt be a problem?
18:42:42 <lispy> mib_xet7r3vb: you can only subtract lists without a type error if you're Oleg
18:42:56 <mib_xet7r3vb> who is oleg?
18:43:01 <lispy> ?quote OlegFacts
18:43:02 <lambdabot> OlegFacts says: GHC doesn't have a type checker. It emails your types to Oleg for checking.
18:43:05 <sjanssen> mib_xet7r3vb: map length produces a list of Int values, not an Int value
18:43:26 <ozy`> mib_xet7r3vb: do you want "map length ys" or "length head ys"? pay attention to what the "map" and "length" functions mean...
18:43:29 <lispy> mib_xet7r3vb: it should suffice to just say that Oleg is the Chuck Norris of Haskell.
18:43:31 <Olathe> @pl \f g xs ys -> g (f xs) (f ys)
18:43:31 <lambdabot> flip =<< ((flip . ((.) .)) .) . flip (.)
18:44:00 <lispy> Olathe: why do I have this feeling that is `on`
18:44:03 <inimino> actually, Chuck Norris is the Oleg of everything else
18:44:13 <dmwit> ?pl \g f xs ys -> g (f xs) (f ys) -- Olathe
18:44:13 <lambdabot> join . ((flip . ((.) .)) .) . (.)
18:44:14 <lispy> Olathe: (f `on` g) xs ys
18:44:30 <lispy> :t on
18:44:32 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
18:44:41 <dmwit> lispy: g `on` f?
18:44:45 <lispy> oh right
18:44:46 <dolio> g `on` f, I think.
18:44:52 <dmwit> lispy: But good call.
18:44:52 <lispy> my dyslexia ;)
18:44:53 <dmwit> lispy++
18:45:22 <mib_xet7r3vb> i mean i want the length of ys for each element . example ["abc","gfdc"] first element is 3 letters, so it subtract the int value which is from (head xs)
18:45:30 <Olathe> > (on length (-)) [1..10] [1..11]
18:45:31 <lambdabot>   Couldn't match expected type `[a] -> c' against inferred type `Int'
18:45:46 <dmwit> > (on (-) length) [1..10] [1..11]
18:45:48 <lambdabot>   -1
18:45:56 <Olathe> Ahh, neat.
18:46:07 <Olathe> > let diff xs ys = (join.((flip.((.).)).).(.)) (-) length xs ys in diff [1..10] [1..11]
18:46:08 <lambdabot>   -1
18:46:13 <lispy> > ((-) `on` length) [1..10] [1..11] -- I do think the infix helps the readability of on
18:46:15 <lambdabot>   -1
18:46:17 <Olathe> @pl isn't quite as spiffy.
18:46:17 <lambdabot> (line 1, column 23):
18:46:17 <lambdabot> unexpected end of input
18:46:17 <lambdabot> expecting white space or simple term
18:46:21 <dmwit> Me too.
18:46:37 <ozy`> mib_xet7r3vb: watch this example. pay close attention...
18:46:38 <Olathe> Infix is the work of SATAN !
18:46:38 <dmwit> err... me too on the infix+readability thing
18:46:38 <ozy`> > map length ["pizza", "cheese", "pepperoni"]
18:46:39 <lambdabot>   [5,6,9]
18:46:41 <mib_xet7r3vb> umm but the thing is, mine uses 2 different list which is not the same type, above code uses 2 list of INT
18:46:52 <lispy> > (subtract `on` length) [1..10] [1..11]
18:46:53 <lambdabot>   1
18:46:54 <sjanssen> Int, not INT, damnit :)0
18:47:12 <mib_xet7r3vb> sjanssen referring to me?
18:47:12 <lispy> subtract is flipped I guess
18:47:16 <Olathe> > ((-) `on` length) [1..10] "zomg"
18:47:17 <dmwit> right
18:47:18 <lambdabot>       No instance for (Num Char)
18:47:18 <lambdabot>        arising from the literal `1' at <inte...
18:47:20 <sjanssen> mib_xet7r3vb: yes
18:47:27 <mib_xet7r3vb> oh, sorry, Int
18:47:35 <rwbarton> @pl \x -> x - 1
18:47:35 <lambdabot> subtract 1
18:47:36 <dmwit> Olathe: Yeah, the type is restricted a little bit.
18:47:39 <mib_xet7r3vb> i place all in caps to highlight
18:47:44 <lispy> :t on
18:47:45 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
18:47:48 <Olathe> @type on
18:47:49 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
18:48:11 <lispy> :t \f g xs ys -> f (g xs) (g ys)
18:48:13 <lambdabot> forall t t1 t2. (t1 -> t1 -> t2) -> (t -> t1) -> t -> t -> t2
18:48:21 <lispy> Not much we can do about it though
18:48:24 <mib_xet7r3vb> hmm i just realise i could do it another way round
18:48:30 <Olathe> I hate how it unpolymorphizes everything like that.
18:48:34 <mib_xet7r3vb> an eye opernere from ozy
18:48:42 <Olathe> > let diff xs ys = (join.((flip.((.).)).).(.)) (-) length xs ys in diff [1..10] "zomg"
18:48:43 <lambdabot>       No instance for (Num Char)
18:48:43 <lambdabot>        arising from the literal `1' at <inte...
18:49:17 <Olathe> > let diff xs ys = length xs - length ys in diff [1..10] "zomg"
18:49:18 <lambdabot>   6
18:49:30 <dmwit> Olathe: You need higher-rank polymorphism to fix that problem.
18:49:58 <lispy> dmwit: but where do you put it?  on the xs and ys or on g?
18:50:05 <dmwit> And then you lose type inference (in a lot of cases), so it's hardly worth it...
18:50:07 <sjanssen> @type on
18:50:09 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
18:50:26 <dmwit> lispy: I think on the second function argument.
18:50:27 <ozy`> mib_xet7r3vb: there's more... check this out.
18:50:29 <ozy`> > zip ["a", "b", "c"] [1, 2, 3]
18:50:30 <lambdabot>   [("a",1),("b",2),("c",3)]
18:50:34 <rwbarton> > let on :: (c -> c -> d) -> (forall a. f a -> c) -> f x -> f y -> d ; on f g x y = f (g x) (g y) in ((-) `on` length) [1,2,3] "xyz"
18:50:35 <BMeph> Do you mean something like 'zipWith ((-).length) ys xs'?  :)
18:50:36 <lambdabot>   0
18:50:46 <dmwit> lispy: on :: (b -> b -> c) -> (forall a. a -> b) -> d -> e -> c
18:50:46 <sjanssen> dmwit: I think you need more than higher rank polymorphism to type that satisfactorily
18:51:07 <dmwit> But that is a rather unsatisfactory type.
18:51:07 <lispy> (c -> c -> d) -> (forall a. a -> b) -> a -> b -> d
18:51:08 <BMeph> ?type zipWith ((-).length)
18:51:09 <lambdabot> forall a. [[a]] -> [Int] -> [Int]
18:51:10 <Olathe> mib_xet7r3vb: What would f [1..10] "zomg" do for your f ?
18:51:13 <ozy`> BMeph: I think that's exactly what mib_xet7r3vb is after, yeah
18:51:46 <mib_xet7r3vb> man im confused, so many codes and people talking
18:51:57 <mib_xet7r3vb> don't know which to focus on
18:51:57 <lispy> > let on2 :: (c -> c -> d) -> (forall a. a -> b) -> a -> b -> d; on2 f g xs ys = f (g xs) (g ys) in undefined
18:51:58 <ozy`> mib_xet7r3vb: yeah it gets a little over-the-top in here sometimes
18:51:59 <lambdabot>   Couldn't match expected type `c' against inferred type `b'
18:52:06 <dmwit> mib_xet7r3vb: Let's go to #haskell-overflow.
18:52:11 <dmwit> mib_xet7r3vb: It's a little quieter there.
18:52:22 <lispy> > let on2 :: (c -> c -> d) -> (forall a. a -> c) -> a -> b -> d; on2 f g xs ys = f (g xs) (g ys) in undefined
18:52:23 <lambdabot>   * Exception: Prelude.undefined
18:52:34 <dmwit> lispy: wrong type
18:52:47 <dmwit> I take it back.
18:53:08 <lispy> dmwit: confusing because I use `a' in two different scopes?
18:53:23 <dmwit> No, you just had the wrong type before, and I didn't re-read. =P
18:53:40 <mib_xet7r3vb> im in haskell overflow
18:53:43 <dmwit> But as I said, that type is way unsatisfactory.
18:53:54 <lispy> dmwit: why do you feel that?
18:53:59 <dmwit> mib_xet7r3vb: err, no you aren't?
18:54:02 <dolio> That type won't work for length.
18:54:06 <BMeph> ozy`: Cool - I am becoming a Haskell initiate! ;)
18:54:12 <mib_xet7r3vb> dmwit : i click the link that you have provided to me
18:54:12 <dmwit> lispy: Because you can't pass any useful function as the second argument.
18:54:17 <lispy> > let on2 :: (c -> c -> d) -> (forall a. a -> c) -> a -> b -> d; on2 f g xs ys = f (g xs) (g ys) in (subtract `on2` length) [1..10] "zomg"
18:54:18 <lambdabot>   Couldn't match expected type `a1' against inferred type `[a]'
18:54:26 <lispy> dmwit: gotcha
18:54:30 <dmwit> mib_xet7r3vb: I didn't give you any link.
18:54:48 <dmwit> mib_xet7r3vb: Type this: "/join #haskell-overflow".
18:55:01 <dolio> For length, it needs to be (c -> c -> d) -> (forall a. [a] -> c) -> [a] -> [b] -> d
18:55:09 <ozy`> mib_xet7r3vb: your IRC client is like a tiramisu made of many layers of madness
18:55:53 <lispy> ozy`: lol, mibbet is fine actually.  I've never had the problems that some people seem to have...
18:56:27 <Olathe> ajax--
18:56:34 <dmwit> desktops++
18:56:55 <Olathe> automobiles++
18:57:05 <Olathe> @karma automobiles
18:57:05 <lambdabot> automobiles has a karma of 1
18:57:10 <dmwit> ?karma+ foo
18:57:10 <lambdabot> foo's karma raised to 1.
18:57:25 <Olathe> Ahh.
18:57:48 <Olathe> @karma+ zomg
18:57:48 <lambdabot> zomg's karma raised to 1.
18:58:32 <BMeph> ?karma Haskell
18:58:34 <lambdabot> Haskell has a karma of 13
18:59:21 <dmwit> ?karma
18:59:22 <lambdabot> You have a karma of 1
18:59:28 <Olathe> @karma c
18:59:28 <lambdabot> c has a karma of 0
18:59:39 <Olathe> That's surprising.
18:59:48 <rwbarton> @karma C
18:59:48 <lambdabot> C has a karma of 0
19:00:03 <ozy`> @karma HaSkElL
19:00:03 <lambdabot> HaSkElL has a karma of 13
19:00:27 <lispy> we talk about C++ as much as we talk about C-- obviously ;)
19:01:08 <lispy> is it easier to translate GHC external Core files or write a GHC backend?
19:02:24 <lispy> I see though, external core in GHC has a tendency to be broken
19:03:01 <rwbarton> Is external core the same as -ddump-simpl?
19:03:26 <dmwit> lispy, Olathe: special case, c++ is ignored
19:04:00 <lispy> rwbarton: no
19:04:14 <lispy> rwbarton: http://www.haskell.org/ghc/docs/latest/html/users_guide/ext-core.html
19:04:16 <lambdabot> Title: 5.15.Generating and compiling External Core Files, http://tinyurl.com/yv4yuz
19:04:36 <lispy> "Note that the format of .hcr files is different (though similar) to the Core output format generated for debugging purposes (Section 5.16, Debugging the compiler)."
19:05:03 <Olathe> dmwit: Oh :(
19:05:21 <idnar> @karma
19:05:22 <lambdabot> You have a karma of 0
19:05:43 <Olathe> @karma you
19:05:44 <lambdabot> you has a karma of 0
19:05:52 <lispy> http://osdir.com/ml/lang.haskell.cafe/2005-01/msg00040.html
19:05:53 <lambdabot> Title: RE: GHC for .NET?: msg#00040
19:06:05 <Olathe> I can has karma ?
19:09:33 <noZone> Olathe can has Just karma | Nothing
19:09:57 <cp1134> hi i'm new to haskell and run into: 'Could not find module 'System.FilePath'. I'm running haskell v 6.6. Is that an included module? or do I need to grab that from somewhere?
19:10:33 <cp1134> (This was when i was attempting to compile the latest cabal)
19:11:03 <dcoutts> cp1134: it wasn't included in ghc-6.6, you'll need to get it from hackage
19:11:40 <cp1134> dcoutts: ok. thanks!
19:12:24 <lispy> cp1134: if I were you'd I'd try to upgrade to 6.8.3, but certainly not required
19:15:31 <thoughtpolice> i thought filepath became stock in 6.6?
19:15:34 <thoughtpolice> or was that 6.6.1?
19:16:10 <dcoutts> thoughtpolice: 6.6.1
19:17:56 <BMeph> ?karma i_can
19:17:56 <lambdabot> i_can has a karma of 0
19:18:15 <Olathe> @karma lambdabot
19:18:15 <lambdabot> lambdabot has a karma of 5
19:18:16 * BMeph apologizes for not resisting that for longer.
19:18:23 <Olathe> BMeph: Heheh
19:18:30 <Olathe> lambdabot: No !
19:22:11 <dons> new wx release
19:22:18 <lispy> dons: cool
19:23:08 <dons> config/config.mk:22: *** missing separator.  Stop.
19:23:10 <dons> not for long.
19:23:18 <dons> ah my fault probably..
19:26:57 * BMeph just found another line for his "How to tell your girlfriend's a geek" file...
19:27:48 <lispy> BMeph: oh, tell me in #haskell-blah
19:32:12 <hackage> Uploaded to hackage: wx 0.10.4
19:32:12 <hackage> Uploaded to hackage: wxcore 0.10.4
19:35:58 <cp1134> is there a way to search for which package contains a particular file?
19:36:42 <cp1134> I've installed the X11 pacakge, but i'm getting an error about a missing HsX11Config.h
19:40:20 <cp1134> hmm the output of config mentions that it created the file, and the file does exist in include/ .
19:40:43 <dons> hmm.
19:40:51 <dons> you're building it with cabal ?
19:41:21 <cp1134> umm. i did: runhaskell Setup.hs configure --user --prefix=$HOME from the X11 pacakge dir
19:41:36 <dons> ok. good
19:41:39 <cp1134> (i'm totally new here, so I don't know if that is calling cabal behind the scenes or what)
19:41:49 <dons> no, that's fine. and yes, that's "cabal"
19:41:54 <dons> welcome, btw :)
19:42:02 <cp1134> thanks :)
19:42:08 <dons> so your distro doesn't have the haskell X11 package available?
19:42:12 <dons> so you have to build it yourself?
19:42:57 <cp1134> yeah. i'm running debian stable. testing has the newer haskell, but i don't feel like messing with that atm
19:43:26 <cp1134> i thought this would be pretty quick/painless :)
19:43:28 <dons> ok. but debian stable should have the x11 package?
19:43:36 <dons> i guess you're trying to install xmonad eh?
19:43:41 <cp1134> it does...but it is 1.2.x and i need 1.4.x
19:43:44 <cp1134> haha yep
19:43:46 <dons> ah yes. quite so.
19:43:51 <dons> i'm one of the xmonad authors :-)
19:43:55 <cp1134> oh sweet
19:44:02 <dons> so, let's find the debian package.
19:44:22 <dons> is it 'etch' ?
19:44:31 <cp1134> yes, that's what i'm running
19:44:35 <dons> http://people.debian.org/~jps/etch/
19:44:36 <lambdabot> Title: Index of /~jps/etch
19:44:51 <dons> has some xmonad packages for etch
19:45:26 <cp1134> ok. awesome!
19:45:30 <Axman6> what's full name of etch?
19:45:38 <Axman6> should be another word...
19:45:52 <cp1134> Axman6: not sure what you mean
19:46:04 <rwbarton> Axman6: That's Ubuntu, not Debian
19:46:11 <rwbarton> Debian is Toy Story characters
19:46:11 <Axman6> oh right, heh
19:47:40 <Axman6> and this is why i like the BSD's, it's easy to follow what's what
19:48:15 <dons> cp1134: otherwise, you're probably missing the C x11 header files
19:48:24 <dons> there's details about finding all these on the xmonad wiki
19:48:49 <cp1134> dons: i have those installed
19:51:16 <dino-> cp1134: What package is this that needs to be 1.4.x?
19:51:31 <cp1134> dino-: xmonad
19:51:48 <dino-> ah, I built mine from source
19:51:54 <dino-> my xmonad running on Debian
19:51:57 <cp1134> ah
19:52:20 <rwbarton> debian stable though? with ghc 6.6?
19:52:43 <dino-> Actually, I'm sad to now admit that I did not have time yet to upgrade from 0.7 to 0.8
19:53:02 <dino-> Yeah, that's another thing I don't use apt for: ghc 6.8.3
19:55:08 <cp1134> dons: i'm up and running now. thanks
19:55:27 <dino-> Hey, coo. This is the xmonad from apt too?
19:55:34 <dino-> I did not know it was even in there.
19:56:10 <dino-> I see testing has 0.7 atm
20:09:27 <mib_xet7r3vb> test
20:09:31 <mib_xet7r3vb> > 1+1
20:09:33 <lambdabot>   2
20:09:40 <mib_xet7r3vb> zipWith (-) (int:list) . map length $ (string:list)  >>> what does it mean by string:list ?
20:09:52 <mib_xet7r3vb> and what does it mean by int:list?
20:11:10 <dons> cp1134: great
20:12:56 <augustss> howdy
20:19:25 <Axman6> mib_xet7r3vb: without the rest of the code, i couldn't tell you for sure. but a:as means stick a on the front of the list as. if as = [2,3], a = 1, a:as = [1,2,3]
20:20:58 <mib_xet7r3vb> oh hi axman
20:20:59 <Axman6> so, string:list means stick string at the frons of the list 'list'
20:21:01 <mib_xet7r3vb> i solved it
20:21:10 <jdrake> Is there a way to have a one parameter function and pass the parameter to it, but not actually run the function? (as if you were currying)
20:21:10 <monochrom> > "hello" : [ "hi", "tofu" ]
20:21:12 <lambdabot>   ["hello","hi","tofu"]
20:21:18 <mib_xet7r3vb> but i have another quesoitn
20:21:29 <Cale> jdrake: What do you mean? Don't demand the result?
20:21:38 <augustss> jdrake: don't use the result
20:21:44 <Cale> jdrake: (f x) won't be evaluated unless you pattern match against it.
20:22:18 <mib_xet7r3vb> axman http://hpaste.org/11058#a5
20:22:24 <mib_xet7r3vb> axman6 http://hpaste.org/11058#a5
20:22:48 <mib_xet7r3vb> the spaces does not space as much as i specified in the list
20:23:20 <mib_xet7r3vb> like writeCell [5,20,15] ["123","1234',"12345"]
20:23:32 <Axman6> which bit am i looking at?
20:23:39 <mib_xet7r3vb> the spaces
20:23:40 <mib_xet7r3vb> replicate
20:23:48 <mib_xet7r3vb> i couldnt get it to make it space out more
20:23:57 <jdrake> What I need is this: I have a function (event handler) as closeEvent dialog = ...  and I need to pass dialog to it during the setting of the event, as such:          onClicked (castToButton close) (closeEvent $ castToDialog window)   But as it is, it would run it would it not?
20:24:21 <mib_xet7r3vb> like if there are 4 letters (mean 4 spaces) which is subtracted from 20, so let 16 spaces
20:24:36 <mib_xet7r3vb> so it should space out 16 spaces, before displaying the next field which is 12345
20:24:59 <Cale> jdrake: castToDialog window ?
20:25:04 <rwbarton> jdrake: No, it won't run
20:25:08 <mib_xet7r3vb> 123 -- 1234 - - - - - - - - - - - - - - - - 12345 - - - - - - - - - - -
20:25:14 <jdrake> rwbarton, I do not understand why not
20:25:15 <Axman6> so, you want the number of spaces to be 20 minus the length of the string?
20:25:17 <mib_xet7r3vb> axman6 123 -- 1234 - - - - - - - - - - - - - - - - 12345 - - - - - - - - - - -
20:25:23 <jdrake> Cale, closeEvent
20:25:23 <mib_xet7r3vb> yeah
20:25:36 <Cale> jdrake: Expressions in Haskell are evaluated outermost first.
20:25:45 <rwbarton> jdrake: just like  when False (print "this won't get printed")
20:25:45 <Axman6> mib_xet7r3vb: i'm not sure i understand the pattern there
20:25:53 <mib_xet7r3vb> the number of spaces would be used for the spacing ' '
20:26:04 <Cale> jdrake: Also, evaluating an IO action does nothing.
20:26:11 <Axman6> what number of spaces?
20:26:13 <Cale> jdrake: You have to execute it for something to happen.
20:26:16 <mib_xet7r3vb> i just want to the value of xs minus the length of string so that these value is used for spacing
20:26:26 <mib_xet7r3vb> the spaces is [5,20,15]
20:26:35 <Axman6> as, i think i get it
20:26:39 <jdrake> ok, I will take your word for it and then verify it by it working :p
20:26:44 <mib_xet7r3vb> so 123 has 3 letters (it takes 3 spaces) so it left 2 more spaces
20:26:53 <mib_xet7r3vb> so 2 spaces before 1234,
20:27:04 <mib_xet7r3vb> and 15 spaces before 12345
20:27:19 <Cale> jdrake: I can check the documentation for onClicked, but I'm pretty sure it doesn't run the action you pass it until the event actually happens :P
20:27:27 <mib_xet7r3vb> weird it should be 16 spaces before 12345
20:27:30 <mib_xet7r3vb> lol
20:27:54 <mib_xet7r3vb> axman6 123 - - | 1234 - - - - - - - - - - - - - - - - | 12345 - - - - - - - - - -
20:28:06 <Axman6> ok
20:28:23 <mib_xet7r3vb> i couldnt figure out whats wrong with the code, its looks alright to me
20:29:11 <Cale> jdrake: Right. It takes an action as a parameter, and sets that action as the event handler.
20:29:25 <rwbarton> jdrake: evaluating  print "foo"  doesn't print "foo".  Ultimately the only way to print "foo" is to write  main = print "foo"  or  main = <some expression of type IO () built out of >>= and print "foo">
20:30:16 <jdrake> hmm
20:30:56 <Cale> jdrake: If it helps, you can think of (IO t) values as bunches of source code for an action, or the text of an executable program.
20:31:08 <Axman6> mib_xet7r3vb: what about: http://hpaste.org/11058#a6
20:31:17 <jdrake> Cale, might help
20:31:18 <Cale> jdrake: Evaluating what that source code is doesn't actually make the actions it describes happen.
20:31:24 <dmwit> jdrake: Evaluating (print "foo") creates an action that *describes* printing "foo".  It is only when it is run that the description gets put to use.
20:31:25 <Axman6> uh, that's wrong, but easily fixed
20:31:28 <jdrake> Cale, that would make sense
20:31:29 <Axman6> i think
20:31:30 <Cale> You need to actually go about executing it.
20:31:56 <dmwit> Ah, as usual, Cale was quicker -- and clearer.
20:33:21 <Axman6> mib_xet7r3vb: maybe this: http://hpaste.org/11058#a7
20:33:39 <Cale> To go along with this view then, do-blocks glue the source code for a bunch of actions together into a single program. Evaluating a do-block just constructs the program but still doesn't run it.
20:33:42 <jdrake> This is confusing, http://hpaste.org/11068?lines=true   3 long scary errors follow
20:33:52 <Axman6> bleh, that code won't work either, but it needs little. just some (.)'s and $'s
20:34:01 <mib_xet7r3vb> o_O
20:34:28 <Cale> jdrake: looks like indentation problems
20:34:30 <rwbarton> jdrake: I think it's because you keep indenting things for no reason :)
20:34:30 <Axman6> :t writeCell spaces  strings = concatMap (\(l,s) ->replicate l '- ' ++ "| " ++ str ) . zipWith (\str space -> (space - (length str), str)) strings spaces
20:34:31 <Axman6> lambdabot!
20:34:32 <lambdabot> parse error on input `='
20:34:49 <Cale> jdrake: you indented onDestroy window ... enough that it became part of the previous line.
20:35:11 <jdrake> hmm, quite right
20:35:18 <Cale> jdrake: Which makes it look like the Map.lookup is supposed to find a function in the map which takes all those extra parameters ;)
20:35:56 <rwbarton> jdrake: as for line 51 -- return is not a keyword, it's just a function.  You need more parentheses there
20:36:16 <dons> ?users
20:36:17 <lambdabot> Maximum users seen in #haskell: 518, currently: 465 (89.8%), active: 13 (2.8%)
20:36:19 <Cale> Or a . after the return
20:36:35 <Cale> return . dialogRun $ castToDialog window
20:37:01 <jdrake> rwbarton, haskell uses some things as functions that I expect to be keywords!
20:37:06 <Cale> hehe
20:37:14 <jdrake> when and return both!
20:37:25 <SamB_XP> unfortunately if is not one of them :-(
20:37:29 <Cale> jdrake: return is also very different from the imperative return
20:37:34 <dino-> There are amazingly few keywords.
20:37:35 <Axman6> @let writeCell spaces  strings = concatMap (\(l,s) -> (replicate l "- ") ++ "| ":s ) . zipWith (\str space -> (space - (length str), str)) strings $ spaces
20:37:37 <lambdabot>  Defined.
20:37:52 <Cale> jdrake: It constructs an action which is a no-op that produces the value it is given.
20:38:07 <Cale> jdrake: So, used in the middle of a do-block, it does nothing at all.
20:38:13 <Axman6> > writeCell [5,20,15] ["123","1234","12345"]
20:38:14 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
20:38:26 <Axman6> bleh
20:38:34 <Cale> (rather than calling some continuation with the given value)
20:38:43 <mib_xet7r3vb> lol axman
20:38:53 <mib_xet7r3vb> writeCell is a custom function, not inbuilt function
20:39:01 <jdrake> I do not need to hear the word 'continuation'
20:39:06 <Axman6> i know, i just defined it in lambdabot
20:39:07 <Cale> hehe
20:39:20 <Cale> After you program in Haskell for long enough, it's very disorienting that every procedure in C is implicitly wrapped in call/cc
20:39:37 <mib_xet7r3vb> wow i did knot know we could defined it into lambdatbot
20:39:38 <Cale> (and return is what lets you call that continuation)
20:39:39 <Riastradh> It does call a continuation, Cale.  It doesn't *discard* its continuation, though.
20:40:03 <Olathe> @let mib = "xet7r3vb"
20:40:05 <lambdabot>  Defined.
20:40:09 <Olathe> > mib
20:40:11 <lambdabot>   "xet7r3vb"
20:40:18 <jdrake> run :: Glade.GladeXML -> IO (IO ResponseId)   Is this because I should have a <- instead of returning like return . dialogRun $ castToDialog window
20:40:42 <rwbarton> You should just run the action by not writing return :)
20:40:56 <jdrake> rwbarton, then what will happen
20:41:05 <rwbarton> the last line of a do block is a little special I guess
20:41:15 <rwbarton> same as x <- dialogRun $ castToDialog window; return x
20:41:19 <jdrake> I see, it does it properly
20:41:44 <jdrake> ok, now it returns an IO ResponseId
20:41:48 <Cale> jdrake: the way you have it written, the action is going to return the value (dialogRun $ castToDialog window), which if I'm not mistaken, is another action.
20:42:15 <Cale> That's a perfectly acceptable thing to do, but might not be what you want.
20:42:48 <Axman6> @let writeCell spaces  strings = concatMap (\(l,s) -> (concat $ replicate l "- ") ++ "| " ++ s ) $ zipWith (\str space -> (space - (length str), str)) strings  spaces
20:42:49 <lambdabot>  <local>:23:0:
20:42:49 <lambdabot>      Multiple declarations of `L.writeCell'
20:42:49 <lambdabot>      Declared at: ...
20:43:10 <Plareplane> @help
20:43:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:43:12 <Axman6> @let writeCell2 spaces  strings = concatMap (\(l,s) -> (concat $ replicate l "- ") ++ "| " ++ s ) $ zipWith (\str space -> (space - (length str), str)) strings  spaces
20:43:14 <lambdabot>  Defined.
20:43:21 <jdrake> Cale, at least the errors aren't ALWAYS as bad as C++ STL
20:43:21 <Axman6> > writeCell [5,20,15] ["123","1234","12345"]
20:43:23 <lambdabot>   Couldn't match expected type `[Char]' against inferred type `Char'
20:43:28 <Axman6> > writeCell2 [5,20,15] ["123","1234","12345"]
20:43:28 <Cale> jdrake: hehe
20:43:29 <lambdabot>   "- - | 123- - - - - - - - - - - - - - - - | 1234- - - - - - - - - - | 12345"
20:43:37 <Axman6> mib_xet7r3vb: ^^?
20:43:47 <Cale> jdrake: If they're hard to understand, just use the line and column numbers ;)
20:44:10 <Cale> jdrake: Then ponder the code at that location and look for something which seems off. :)
20:44:33 <jdrake> Cale, its either I understand it, or you guys do :-)
20:45:49 <dino-> The times when I don't indent far enough to get past the 'let ' part of a let binding, I notice I get spectacularly strange errors.
20:46:20 <mib_xet7r3vb> axman6 wow
20:46:37 <dino-> Well, maybe not strange, but a little bit away from that actual line.
20:46:39 <Olathe> Why is my CD drive spinning up ?! Oh, bad indentation...
20:46:49 <SamB_XP> Olathe: lol
20:46:49 <Axman6> that was more difficult whan i wanted it to be -_-
20:47:13 <Axman6> dino-: yeah i've noticed that quite a bit in wheres
20:47:15 <mib_xet7r3vb> uh weird
20:47:25 <mib_xet7r3vb> axman6 : shouldn;t it be the oposite way
20:47:33 <mib_xet7r3vb> axman6 123 - - | 1234 - - - - - - - - - - - - - - - - | 12345 - - - - - - - - - -
20:47:58 <Axman6> well fix it so that it is the other way around then ;)
20:48:06 <mib_xet7r3vb> ok :D
20:48:15 <Axman6> 14:31 #haskell: < mib_xet7r3vb> axman6 123 - - | 1234 - - - - - - - - - - - - - - - - | 12345 - - - - - - - -
20:48:16 <Axman6> is what you said earlier, which is pretty close to what i did
20:48:17 <jdrake> I am thinking that I cannot retrieve an object twice: starz-client: user error (glade.xmlGetWidget: no object named "Close" in the glade file)
20:58:33 <mib_xet7r3vb> > 1+1
20:58:34 <lambdabot>   2
21:03:46 <kohwj> what is the [i | i < list, condition] notation called? it looks a lot like a python list comprehension
21:04:08 <seliopou> same
21:04:09 <monochrom> list comprehension
21:04:10 <thoughtpolice> it's a list comprehension
21:04:11 <kohwj> haha!
21:04:14 <kohwj> thanks
21:04:19 <monochrom> haskell list comprehension
21:04:33 <monochrom> They learned it from us. :)
21:04:43 <kohwj> no wonder
21:04:50 <kohwj> :)
21:05:00 <seliopou> "learned" is a very generous word
21:05:20 <monochrom> It's also an encouraging word.
21:05:34 <monochrom> If only Python learned everything from us, and everything from Oleg too...
21:05:57 <monochrom> (then no one would use Python! they'd use PHP instead... :) )
21:07:22 <dino-> cp1134: How is your xmonad working?
21:07:55 <cp1134> dino-: well...i screwed around for a bit in an Xnest, and just minute ago bit the bullet and started running it for my main WM
21:08:25 <dino-> cp1134: I switched from using fluxbox, which was about as 'minimal' as I knew before xmonad.
21:08:36 <cp1134> dino-: it's interesting. the one thing i'm wishing I could do is have the equivalent of a-h, a-l for vertical resizing
21:08:37 <dino-> And wow, do I like never ever dragging windows around.
21:09:10 <dino-> cp1134: Custom layout-ish ym?
21:09:23 <jdrake> I tried xmonad before but it never agreed with me. I am a gnome-man
21:09:45 <dino-> I haven't messed around with it that was much but I believe it's really pretty simple. Somebody jump in here. Or we can go to #xmonad
21:09:54 <edwardk> i just xmonad but i do so inside of a vmware machine, so it all just sits in a window anyways. seems kinda dirty somehow
21:10:13 <edwardk> er i run
21:10:25 <dino-> s/was/way/
21:10:43 <seliopou> cp1134:  I was doing some vertical resizing earlier today, I think mod h/l worked somehow
21:11:10 <seliopou> admittedly, I hit random keys for a while before it did :P
21:11:14 <seliopou> ... and then it stopped working later
21:11:16 <seliopou> bizarre
21:11:41 <cp1134> well, maybe i explained myself wrong. I want to be able to resize the heights of the windows. a-h, a-l resizes the width
21:11:44 <edwardk> @seen bos
21:11:44 <lambdabot> Last time I saw bos was when I left ##logic, #arch-haskell, #darcs, #dreamlinux-es, #friendly-coders, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-books, #haskell-hac07, #
21:11:44 <lambdabot> haskell-overflow, #haskell-soc, #haskell.cz, #haskell.de, #haskell.dut, #haskell.es, #haskell.fi, #haskell.fr, #haskell.hr and #haskell.it 1m 12d 5h 29m 41s ago, and .
21:11:52 <dino-> cp1134: Or I'm wondering now if you're describing being able to move the "split" up/down instead of left/right
21:12:11 <dino-> Which you can do if you rotate everybody, then it moves in the other dir
21:12:33 <cp1134> dino-: yeah shift-a-j/k does that...if i understand you correctly
21:12:36 <dino-> poor bos with the busted finger. :(
21:12:53 <seliopou> cp1134: Are you not talking about the mirrored tiled layout?
21:13:51 <cp1134> seliopou: well. say I have an 80x24 window. i'd like a key sequence to make it 80x80.
21:14:15 <seliopou> oh, are you talking fvwm-style?
21:14:40 <dino-> mm, that kind of thing could probably be done with a custom layout that sizes a pane so the shell is a certain width or whatnot.
21:14:46 <cp1134> haha, i don't have a good comparison, because all other WMs i've used allow you to arbitrarily resize windows ;)
21:15:31 <seliopou> fvwm is sweet, because you can do everything you can do with a mouse with your keyboard
21:15:35 <seliopou> like move your mouse
21:15:59 <seliopou> and I think it allows you to resize the focused window with keystrokes, which I guess is what you're talking about
21:16:05 <cp1134> this might work: in screen i can go :resize +10, to grow a split by 10
21:16:16 <cp1134> (work as an example)
21:22:24 <Olathe> > Zomg.Q
21:22:25 <lambdabot>   mueval: Unsafe function(s) to use mentioned.
21:35:06 <sereven> cp1134: take a look at the xmonad-contrib module Layout.ResizableTall for that
21:39:06 <cp1134> sereven: i'll check it out. thanks
21:39:58 <sereven> hope it works well for you.
21:52:13 <cads> hello
21:52:38 <TomMD> hello cads.
21:52:51 <TomMD> The Matrix has you.
21:54:05 <Eridius> @pl \a b -> a ++ " " ++ b
21:54:05 <lambdabot> (. (' ' :)) . (++)
21:54:39 <Eridius> ok, that one's too complicated to use
21:55:04 <dibblego> \a b -> a ++ ' ' : b
21:55:12 <rwbarton> @pl \a b -> unwords [a,b]
21:55:13 <lambdabot> (unwords .) . (. return) . (:)
21:55:15 <Eridius> dibblego: yeah I'm going with that, I just like pointless style
21:55:46 <cads> @pl map (^1.5) [1..10]
21:55:46 <lambdabot> map (^ 1 . 5) [1..10]
21:56:00 <cads> what's @pl do?
21:56:05 <Eridius> converts into point-free style
21:56:12 <Axman6> aka: pointless
21:56:19 <Axman6> hence @pl, not @pf
21:56:26 <cads> heh
21:56:47 <thetallguy> ?pl f x = x * x
21:56:47 <lambdabot> f = join (*)
21:57:06 <thetallguy> ?pl f x = x * 2
21:57:19 <Axman6> i'm not a fan of pointfree style in many cases. rarely makes things clearer, especially if there's more than one argument
21:57:41 <thetallguy> It's best when there is straight composition, I think.
21:57:43 <dibblego> Axman6, you mean that \a b -> a + b is clearer than (+) ?
21:57:47 <Eridius> @pl \a b -> [a,b]
21:57:47 <lambdabot> (. return) . (:)
21:57:51 <Eridius> damnit, stop using return
21:58:04 <rwbarton> return = (:[])
21:58:04 <Axman6> dibblego: especially, not always ;)
21:58:33 <thetallguy> ?pl f x = sin x
21:58:33 <lambdabot> f = sin
21:58:40 <Eridius> > ((. (:[])) . (:)) "foo" "bar"
21:58:41 <lambdabot>   ["foo","bar"]
21:58:47 <Eridius> now that just looks silly
21:58:49 <thetallguy> ?pl f x = sin (cos x)
21:58:49 <lambdabot> f = sin . cos
21:59:06 <thetallguy> That's the kind of point-free I find most effective
21:59:17 <cads> that is nice
21:59:37 <Axman6> thetallguy: you usually use @pl for lambda expressions
21:59:45 <cads> I still have a hard time wrapping my head around how pervasive currying is
22:00:14 <Axman6> @pl \x y z -> sin (x * (sin y * cos z))
22:00:15 <lambdabot> ((sin .) .) . (. ((. cos) . (*) . sin)) . (.) . (*)
22:01:17 <cads> jesus..
22:01:32 <Axman6> indeed
22:01:35 <cads> some cases clearly are better left pointful
22:02:24 <cads> @pl p : factors (div n p) where p = ld n
22:02:24 <lambdabot> (line 1, column 31):
22:02:24 <lambdabot> unexpected "="
22:02:24 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>" or end of input
22:02:33 <Axman6> unless it's really clear what's going on, i always name parameters
22:03:00 <Axman6> things that have ((f .) . g) annoy me
22:03:21 <Axman6> i know what they do now, but it's pretty stupid to write it that way
22:03:27 <Axman6> @unpl ((f .). g)
22:03:28 <lambdabot> (\ d i -> f (g d i))
22:03:48 <cads> \n -> p : factors (div n p) where p = ld n
22:03:50 <cads> err
22:04:06 <cads> @pl \n -> p : factors (div n p) where p = ld n
22:04:06 <lambdabot> (line 1, column 37):
22:04:06 <lambdabot> unexpected "="
22:04:06 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>" or end of input
22:04:11 <ozy`> @unpl ((f .) . g .) .
22:04:11 <lambdabot> (\ c k n q -> f (g (c k n) q))
22:04:11 <Axman6> @unpl ((sin .) .) . (. ((. cos) . (*) . sin)) . (.) . (*)
22:04:12 <lambdabot> (\ j y ab -> sin (j * ((sin y) * (cos ab))))
22:05:26 <cads> gonna try this once more
22:05:54 <ozy`> @unpl (flip id)
22:05:55 <lambdabot> (\ b c -> c b)
22:05:58 <cads> @pl \n -> (ld n) : factors (div n (ld n))
22:05:58 <lambdabot> liftM2 (:) ld (factors . ap div ld)
22:06:37 <cads> transcendant.
22:07:10 <cads> especially due to the fact that :) shows up as a big smiley face in this client : )
22:08:17 <Axman6> heh
22:08:54 <Axman6> ok, 74C laptop is getting to be a little uncomfortable now...
22:10:02 <ozy`> this kid in #ruby-lang is hilarious
22:10:16 <ozy`> I haven't laughed so hard in a month
22:10:44 <Axman6> ozy`: which nick?
22:10:52 <ozy`> Axman6: sha2
22:11:01 <Axman6> k
22:11:06 * Axman6 idles in wait
22:11:25 <ozy`> http://pastie.org/289904 <== he always comes in looking for help with YAML programs that look like they were fingerpainted together
22:11:30 <lambdabot> Title: #289904 - Pastie
22:15:53 <kohwj> ozy`: hm..
22:16:53 <Axman6> ozy`: that's some nice code there
22:17:51 <Axman6> ozy`: sha1 the same person?
22:18:23 <ozy`> Axman6: yeah, he changed nicks 'cause he pinged out and didn't know how to ghost
22:18:29 <Axman6> heh
22:20:43 <Axman6> ozy`: wherez teh lolz gon?
22:20:59 <ozy`> Axman6: I dunno, maybe he got discouraged for a few minutes
22:21:06 <Axman6> lame
22:21:21 <ozy`> or he might be on the "run" end of "hit and run"
22:32:12 <hackage> Uploaded to hackage: wx 0.10.5
22:32:12 <hackage> Uploaded to hackage: wxcore 0.10.5
23:03:41 <funktio> @pl \x y z dx dy dz -> ((x,y,z),(dx,dy,dz))
23:03:41 <lambdabot> flip flip (,,) . ((flip . (((.) . (.) . (.) . (,)) .)) .) . (,,)
23:03:42 <electronx> i think the great language shootout is bull shit
23:03:58 <electronx> how can lua jit be faster then java????
23:04:41 <electronx> my bad
23:39:04 <rwbarton> @users
23:39:04 <lambdabot> Maximum users seen in #haskell: 518, currently: 460 (88.8%), active: 5 (1.1%)
