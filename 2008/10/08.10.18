00:03:17 <lispy> Haskell is a very unixy community isn't it
00:04:00 <Baughn> More like freenode is
00:04:13 <pjdelport> programming is a very unixy community
00:04:16 <Baughn> I know people who use haskell solely on windows.. but they're not in here
00:04:31 * dmwit_ nods
00:04:37 <dmwit_> There's a lot of selection bias in this room.
00:05:54 <Baughn> To begin with, windows users aren't too hot on irc
00:06:39 <Pseudonym> OK, story that just happened.  I have to share.
00:07:01 <Pseudonym> We bought an ex-rental DVD some weeks ago.  Autistic 8yo just discovered that it was an ex-rental.
00:07:07 <Pseudonym> So she crossed out the sticker on the box.
00:07:11 <Pseudonym> Why, you may ask?
00:07:19 <Pseudonym> Because, and I quote, "it is belong to us".
00:07:27 <Pseudonym> I had to bite my tongue.
00:07:39 <shrughes> all your ex-rentals are belong to you :3
00:07:50 <aeolist> what is an ex-rental
00:08:18 <Pseudonym> When a video store gets a new DVD, they buy lots.
00:08:26 <Pseudonym> But they don't need so many after the first couple of months.
00:08:33 <aeolist> so they sell them
00:08:36 <Pseudonym> So they sell a bunch of them cheap.
00:08:37 <aeolist> ok, i'm with you
00:08:39 <Pseudonym> Or, at least, some do.
00:08:43 <aeolist> yeah yeah
00:10:27 <dons> :)
00:10:40 <dmwit_> ?users
00:10:40 <lambdabot> Maximum users seen in #haskell: 518, currently: 473 (91.3%), active: 11 (2.3%)
00:11:00 <dmwit_> Seems like the number of lurkers keeps growing, but the number of active people stays exactly the same.
00:11:18 <Pseudonym> Some of them are, no doubt, selling popcorn.
00:11:19 <aeolist> that is true
00:11:30 <slava> dmwit_: its the same in #concatenative
00:11:30 <dons> scalping hackage commit bits
00:11:30 <aeolist> as lurker king, i confirm your assumption
00:11:34 <pjdelport> active conversation can only stand so many simultaneous participants
00:11:34 * lispy hides the popcorn
00:11:36 <slava> more and more lurkers every week
00:11:52 <pjdelport> should count #haskell-overflow etc. too
00:11:55 <dmwit_> pjdelport: good point
00:11:57 <dons> i've seen active up to 60, in the past. but that's a bit hectic
00:12:20 <lispy> Ugh, that must have been like #debian or #gentoo
00:12:29 <dons> let's grep the logs...
00:12:40 <lispy> oh, a thing to replay the logs
00:12:53 <lispy> what is the granularity on the date stames?
00:12:57 <lispy> stamps*
00:12:58 <Pseudonym> Yeah, at quite times, we could do a "best of".
00:13:05 <Pseudonym> Rerun clip show.
00:13:07 <dmwit_> lispy: 1s
00:13:24 <dons> 63.
00:13:33 <lispy> it would be like Tivo for IRC
00:13:39 <dons> 64.
00:13:46 <dons> looks like 64 (20.0%)
00:13:49 <dons> was the most active
00:14:15 <pjdelport> bustling
00:14:37 <dons> apparently we had a conversation last year, when 55 was the highest
00:14:53 <pjdelport> what's the activity threshold again?
00:15:24 <dons>      38 20
00:15:29 <lispy> oh, everyone script your client to ping the channel often enough that you're considered active ;)
00:15:35 <dons> 20 is the most popular number
00:16:30 <dons> 540 is the current max.
00:16:58 <dons> oh, we've caught last year's total nicks
00:20:21 <lispy> ?ghc
00:20:21 <lambdabot> ghc says: My brain just exploded.
00:20:27 <ivanm> lispy: so you want to encourage fake stats?
00:20:32 <dons> ghc says that.
00:20:40 <lispy> it says it a lot
00:20:45 <lispy> in my experience :)
00:20:55 <dons> you're a sucker for types
00:21:10 <ivanm> dons: _ghc's_ brain explodes as well?
00:21:13 <lispy> ivanm: um...I guess so.  Does that make me a bad person?
00:21:25 <lispy> ?ghc
00:21:25 <lambdabot> ghc says: Cannot desugar this Template Haskell declaration
00:21:30 <ivanm> nope, but it might make you an advertising exec :p
00:21:59 <rwbarton> ?ghc
00:21:59 <lambdabot> ghc says: internal error: Invalid object in processHeapClosureForDead
00:22:12 <lispy> heh
00:22:18 <lispy> never seen that one before
00:22:32 <dons> i wonder how we get something like http://learnyouahaskell.com/ published.
00:22:33 <lambdabot> Title: Learn You a Haskell for Great Good!
00:22:45 <dons> if it was about ruby, it'd be already on the bookshelves
00:22:53 <ivanm> dons: by being infected with ruby-itis?
00:22:59 <rwbarton> did that go up recently?
00:23:04 <ivanm> I think so
00:23:12 <rwbarton> I've seen a lot of talk about it lately, and it is pretty awesome
00:23:34 <dons> illustrations.
00:23:37 * ivanm finds it disturbing
00:23:53 <xmux> Was that written by _why?
00:23:59 <dmwit_> LYAH has been around for a year or more, I think.
00:24:27 <dons> xmux: nope. http://twitter.com/bonus500
00:24:28 <lambdabot> Title: Twitter / bonus500
00:24:34 <dons> by our very own bonus.
00:24:58 <xmux> Oh, because on the reddit thread about it there is a guy who both claims to be the author and claims to be _why
00:25:08 <adu_> i don't like 20, although I have an interesting infatuation with 8
00:25:28 <dons> xmux: hmm. no. it isn't why.
00:25:37 <dons> the author hangs out here (and has done for ages)
00:26:33 <dmwit_> adu_: 20? 8?
00:26:39 <mmorrow> ?ghc
00:26:40 <lambdabot> ghc says: Kinds don't match in type application
00:26:45 <mmorrow> ?ghc
00:26:45 <lambdabot> ghc says: magic number mismatch: old/corrupt interface file?
00:26:54 <mmorrow> that a good one
00:26:58 <mmorrow> +S
00:27:02 <mmorrow> toLower
00:27:13 <dons> we used to have a challenge to get ghc to emit those errors in channel
00:27:15 <dons> that was hard.
00:27:25 <mmorrow> heh
00:27:27 <dons> --> Kinds don't match in type application
00:27:29 <dons> try that one.
00:27:38 <dons> though with mueval, i'm not sure if it is easier or harder.
00:27:54 <dons> mueval's doing bytecode interpretation, and no optmisation?
00:28:08 <mmorrow> , [d|data A a = A a ; f :: A a b -> () ; f = undefined|]
00:28:08 <dmwit_> > return 3 :: State Id Int
00:28:09 <lambdabot>   Not in scope: type constructor or class `Id'
00:28:09 <lunabot>  luna: Kind error: `:THFake.A' is applied to too many type arguments
00:28:17 <dmwit_> > return 3 :: State Identity Int
00:28:17 <mmorrow> aww, almost :)
00:28:18 <lambdabot>       `Identity' is not applied to enough type arguments
00:28:18 <lambdabot>      Expected kind `...
00:28:22 <dons> lunabot scares me
00:28:26 <mmorrow> heh
00:28:35 <dons> can't you just reify IO?
00:28:37 <dmwit_> ah
00:28:48 <mmorrow> , $(lift =<< reify ''IO)
00:28:50 <lunabot>  TyConI (NewtypeD [] GHC.IOBase.IO [a_1627413035] (NormalC GHC.IOBase.IO [...
00:28:54 <mmorrow> , runIO
00:28:55 <lunabot>  luna: Not in scope: `runIO'
00:28:56 <dmwit_> > return 3 :: StateT (Identity Int) Int Int
00:28:58 <lambdabot>       Kind mis-match
00:28:58 <lambdabot>      Expected kind `* -> *', but `Int' has kind `*'
00:28:58 <lambdabot>     ...
00:29:18 <mmorrow> runIO is to my knowledge the only way to run IO in the TH monad
00:29:21 * dons tries to remember the lambdabot hack that involved reify, but no runIO
00:29:26 <mmorrow> ooh
00:29:33 <dons> didn't we write all this down.
00:29:34 <mmorrow> i'm extremely interested
00:29:36 <dons> kdis these days
00:29:47 <mmorrow> yeah, i've read that page many times ;)
00:30:23 <dons> we did enable TH back in the day, but only after consultation with igloo and duncan, who were doing their theses on the implementation
00:30:24 * mmorrow quickly goes for a reread to make sure he didn't miss this mysterious TH exploit
00:31:08 <dons> "We believe that Template Haskell can be made safe for users by hiding runIO and reify. "
00:31:16 <dons> so why is reify *also* needed to hide...
00:31:31 <mmorrow> yeah, but you can't actually get at anything that's not already in scope
00:31:32 <dons> you'd have to check the logs.
00:31:41 <mmorrow> i think you could maybe in the past though...
00:32:11 <dons> sjanssen: so do we know if mueval's safe against the old runplugs exploits?
00:32:18 <dons> has anyone gone throug the list?
00:32:30 <mmorrow> you can get the AST of IO's newtype decl, but you can't actually gain the ability to pattern match on it an get unsafePerformIO that way
00:32:45 <dons> mm ok
00:32:49 <ivanm> how does lunabot do haskell evaluation?
00:33:28 <mmorrow> i think that note about reify is either outdated, uses different assumptions about the in-scope functions, or is wrong
00:33:34 * dons still thinks we ditched a 4y ear old runplugs based on a posix bug in the libraries
00:33:44 <dons> mmorrow: it's possible. TH has changed a lot
00:33:45 <mmorrow> plugs is awesome
00:33:48 <dons> that was circa 2004
00:34:08 <mmorrow> [m@ganon ~]$ which plugs
00:34:08 <mmorrow> /usr/local/ghc/ghc-HEAD/bin/plugs
00:34:16 <mmorrow> :)
00:35:06 <mmorrow> ivanm: it compiles single expressions directly via ghc
00:35:30 <dons> to bytecode?
00:35:31 <ivanm> mmorrow: how does that differ from mueval, or the old hs-plugins method?
00:35:44 <dons> i think it's calling the bytecode interpreter
00:35:49 <mmorrow> yeah, sadly only to bytecode at the moment
00:35:53 <dons> while plugs uses native code, with optimisatoin.
00:36:14 <dons> what's the benefit of mueval again .. ? works around a bug in the process waiting code. grumble grumble
00:36:27 <mmorrow> it's parsing/renaming/typechecking/to-core-ing/compiling-to-bytecode/linking/running
00:37:01 <mmorrow> mueval uses the hint pkg to eval code
00:37:22 <mauke> > 1e205
00:37:23 <lambdabot>   1.0e205
00:37:25 <mmorrow> i've never used hint myself, but it uses the publicly exposed ghc-api
00:38:54 <dons> > last [ 1 .. 100000000 ]
00:38:58 <lambdabot>   100000000
00:39:07 <dons> > last [ 1 .. 10000000000000000000000000 ]
00:39:16 <mmorrow> which has changed since 6.8, so i'm not sure if hint's been updated to work with 6.10 actually
00:39:22 <lambdabot>   thread killed
00:39:23 <dons> what's the timeout on the eval now?
00:39:23 <rwbarton> > last $ take 100000000 [1..]
00:39:38 <adu_> dmwit_: what dons said
00:39:50 <lambdabot>   mueval: Prelude.read: no parse
00:39:53 <dons> > let loop () = loop () in loop () :: ()
00:40:00 <dons> scheduler est.
00:40:09 <lambdabot>   thread killed
00:40:15 <dons> > scanr (*) 1 [1..]
00:40:18 <mmorrow> dons: i'm currently working on compiling expressions to machine code instead of bytecode
00:40:21 <lambdabot>   [* Exception: stack overflow
00:40:27 <dons> bad error parsing
00:40:31 <mmorrow> without having to write to a tmp file
00:40:33 <dons> > GHC.Exts.I# 1#
00:40:33 <rwbarton> yes
00:40:37 <lambdabot>   /tmp/1321639924451236695:68:36:
00:40:37 <lambdabot>      Not in scope: data constructor `GHC.Ex...
00:40:40 <dons> super bad
00:40:46 <dons> > $( Language.Haskell.THSyntax.Q (putStr "heya") >> [| 3 |] )
00:40:49 <lambdabot>   <no location info>: parse error on input `$'
00:40:56 <dons> oh
00:41:00 <dons> , $( Language.Haskell.THSyntax.Q (putStr "heya") >> [| 3 |] )
00:41:01 <lunabot>  luna: Not in scope: data constructor `Language.Haskell.THSyntax.Q'
00:41:04 <dons> he
00:41:08 <mmorrow> s/TH//
00:41:10 <dons> > Data.Array.listArray (minBound::Int,maxBound) (repeat 0)
00:41:14 <lambdabot>   array (-9223372036854775808,9223372036854775807) [(-9223372036854775808,* E...
00:41:16 <mmorrow> err, add a .
00:41:18 <dons> cute
00:41:26 <mmorrow> , $( Language.Haskell.TH.Syntax.Q (putStr "heya") >> [| 3 |] )
00:41:28 <lunabot>  luna: Not in scope: data constructor `Language.Haskell.TH.Syntax.Q'
00:41:31 <dons> > map foo bar
00:41:34 <lambdabot>   Not in scope: `foo'Not in scope: `bar'
00:41:39 <dons> bad error parsing.
00:41:40 <mmorrow> , $(Q (putStr "heya") >> [| 3 |] )
00:41:42 <lunabot>  luna: Not in scope: data constructor `Q'
00:41:45 <dons> > (error "throw me") :: ())
00:41:48 <lambdabot>   <no location info>: parse error on input `)'
00:41:57 <dons> > ((error "throw me") :: ())
00:42:01 <lambdabot>   * Exception: throw me
00:42:01 <dons> the location info stuff sucks
00:42:13 <mmorrow> the good thing also about single expressions is that there's no enclosing code to inject anything into
00:42:32 <mmorrow> , (error "throw me") :: ())
00:42:33 <lunabot>  luna: parse error on input `)'
00:42:34 <dons> right. plugs had to parse to determine if it was an expression
00:42:55 <dons>     case parseExpr src of
00:42:55 <mauke> > fix (error . ('*' :))
00:42:56 <sm> http://hpaste.org/11254 <- wondering why this gives TypeSynonymInstances error ?
00:42:56 <dons> ..
00:42:59 <lambdabot>   "* Exception: ** Exception: ** Exception: ** Exception: ** Exception: ** Ex...
00:43:00 <rwbarton> , "foo") ++ ("bar"
00:43:02 <lunabot>  "foo"bar
00:43:08 <dons> mauke: urgh
00:43:16 <mmorrow> heh
00:43:18 <Baughn> > fix error
00:43:21 <lambdabot>   "* Exception: * Exception: * Exception: * Exception: * Exception: * Excepti...
00:43:26 <dons> ?help run
00:43:26 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
00:43:44 <mauke> sm: because MixedAmount is a type synonym
00:44:12 <sm> ah ok.. when *you* say it it's perfectly clear!
00:44:24 <sm> hmm, thanks
00:45:02 <sm> well it's a [Amount] .. how can I make that a Num instance ?
00:45:18 <mauke> do you really have to/
00:45:21 <dmwit_> sm: newtype, or -XTypeSynonyms
00:45:30 <rwbarton> "Use -XTypeSynonymInstances"
00:45:34 <dmwit_> But yeah, you should be careful about what you make into a Num instance. ;-)
00:45:36 <mauke> I mean, you don't support abs, signum, (-) or (*)
00:45:41 <mauke> how is that a number?
00:45:43 <sm> right, you noticed that eh
00:46:03 <sm> I'm a bit confused, but I do want to do simple arithmetic on these things
00:46:13 <Baughn> sm: You can always define them as undefined
00:46:29 <sm> I'd like to see some sort of helpful error
00:46:30 <rwbarton> error is fine too
00:46:32 <Baughn> sm: Oh, and if you really want to instance [Amount], you'll need flexible instances
00:47:50 <sm> trying to get into ghci so I can see what actually is going wrong with these.. it wants (-) for testing equality I think
00:48:02 <mauke> no
00:48:21 <mauke> unless your Eq instance explicitly calls (-)
00:48:54 <sm> let's see.. Amount just derives Eq
00:49:32 <sm> well, equality works fine, you're right
00:50:26 <xinming_> pastorn: ping
00:52:36 <mmorrow> here's a sequence of about 20 pastes of a ghci session while i was trying to find a path through ghc which goes from the AST ghc uses for just-parsed code through renaming/typechecking, desugaring, to core, assembling bytecode, linking the bytecode, and finally running it  http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=155
00:53:43 <mmorrow> i was able to construct an ast for a TH quoted data decl and run that, but i haven't figured out yet how to actually /add/ a data decl to the in scope declarations
00:53:57 <mmorrow> which i really want to do
00:55:19 <mmorrow> actually, this one paste has the whole thing compacted/summarized somewhat http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=155#a196
00:55:37 <therp> add a data decl.. hm iirc it was HsDecl that is responsible for that in the ast
00:56:00 <therp> further it's TyClD + DataType
00:56:48 <therp> but I'm not sure what do you mean by "in scope declarations"
00:57:26 <therp> the ast has the possibility to give you data declaration limited in scope.. but I'm not sure if you mean that
00:59:11 <mmorrow> i want to do in ghci or equiv:
00:59:21 <mmorrow> data A = A deriving (Show)
00:59:23 <mmorrow> then do
00:59:25 <mmorrow> A
00:59:29 <mmorrow> which prints "A"
00:59:34 <thoughtpolice> http://hpaste.org/11255
00:59:36 <mmorrow> like hbi does
00:59:36 <thoughtpolice> wee :]
01:00:07 <ttt--> is there a way to go from a HsQualType to Type in TH? Or are they not exactly the same?
01:00:49 <mmorrow> is that HsQualType from ghc or haskell-src(-exts)?
01:00:55 <ttt--> ghc
01:01:21 <ttt--> i didnt know there were two, what is the difference?
01:01:29 <mmorrow> hmm, you could always manually translate i guess, but i'm not sure if there's a pre-existing function
01:02:01 <mmorrow> ttt--: i have ghc haddocks here though http://moonpatio.com/docs/ghc/
01:02:02 <lambdabot> Title: ghc-6.10.0.20081007: XXX
01:02:10 <mmorrow> and HsCouloured src http://moonpatio.com/docs/ghc/src
01:02:11 <lambdabot> Title: Index of /docs/ghc/src
01:03:50 <ttt--> why isnt TH based on the type in ghc?
01:03:54 <sm> ah no, == sometimes fails
01:04:26 <mmorrow> therp: so i guess i should have said "dynamically compile a data decl from a String, then link it in"
01:04:48 <mmorrow> (assuming it doesn't conflict with pre-existing decls, etc)
01:05:17 <mmorrow> ttt--: it'd be nice if it was
01:06:10 <mmorrow> thoughtpolice: wow
01:07:23 <thoughtpolice> mmorrow: indeed, whoosh :>
01:16:52 <sm> ahaa.. there's my bug
01:17:34 <mmorrow> [m@ganon ~]$ hbi
01:17:35 <mmorrow> > data A = A deriving (Show);
01:17:35 <mmorrow> > A;
01:17:35 <mmorrow> A
01:17:36 <lambdabot>   <no location info>: parse error on input `data'
01:17:36 <lambdabot>   Not in scope: data constructor `A'
01:17:36 <mmorrow> :)
01:18:39 <mmorrow> heh, that unintentionally both illustrated that it works in hbi and that it doesn't in ghc
01:20:44 <FlamingCows> \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\]]]]]]]]]]]]]]][[[[[[----------------=========\
01:20:52 <FlamingCows> Er.
01:20:57 <FlamingCows> Oops.
01:21:35 <FlamingCows> Should have turned off my keyboard before cleaning it.
01:30:42 <aeolist> lol
01:30:45 <aeolist> fail
01:32:12 <Cthulhon> :\
01:33:59 <thoughtpolice> mmorrow: http://hpaste.org/11255#a1
01:34:01 <thoughtpolice> damn
01:35:34 <mmorrow> dang
01:36:09 <mmorrow> i have this one prog that ghc runs in constant space and jhc blows up on. i'll find it..
01:42:43 <mmorrow> thoughtpolice: here's a tarball of the .hs + a massive csv to use as input: http://moonpatio.com/code/constmem_ghc_jhc.tar.gz
01:43:25 <mmorrow> with jhc, it'll exhaust all available mem within a few seconds
01:43:39 <mmorrow> i'm not sure exactly why though
01:43:56 <mmorrow> (with ghc mem use in constant)
01:44:08 <mmorrow> s/in/is/
01:44:50 <mmorrow> i'm using
01:44:51 <mmorrow> jhc 0.5.20080307 (eogmidkiv-12)
01:45:12 <mmorrow> compiled by ghc-6.9 on a i386 running linux
01:57:40 <ivanm> mmorrow: because ghc is smarter?
01:59:04 <Baughn> mmorrow: GHC's strictness analyzer has a tendency to conceal memory leaks
01:59:15 <Baughn> mmorrow: (Try with -Onot)
01:59:40 <ivanm> Baughn: how do you hide a memory leak from the rest of the system?
01:59:48 <Baughn> Let me clarify
01:59:52 <Heffalump> that statement implies that leaking memory is a property of source
01:59:57 <Baughn> ..it is
02:00:08 <Heffalump> I'm sure there's some source that inevitably leaks memory, but some will leak memory only depending on the compilation strategy
02:00:10 <Baughn> It has a tendency to hide memory leaks by optimizing things so the program suddenly no longer leaks memory
02:00:15 <mmorrow> just check hbc, it runs it in const mem too
02:00:30 <mmorrow> [m@ganon s]$ hbc -v
02:00:30 <mmorrow> hbc Haskell98 version 0.9999.5c, 2004 Jun 29
02:00:31 <Baughn> Yes, and there are programs that can't leak memory, assuming lazy evaluation is in effect
02:01:12 <Baughn> It's very easy to hit that optimization.. arachnid. All you have to do is use foldl. ;)
02:01:24 <ozy`> http://hpaste.org/11256 <== I decided I'd get this working before I asked anyone about it. so now that I do have it working... any comments on ways I could improve it?
02:02:17 <mmorrow> Baughn: constant mem with ghc -Onot as well
02:03:02 <Baughn> mmorrow: Still, I bet you've got some code that should leak according to lazy evaluation, that is getting optimized
02:03:52 <Saizan> ozy`: use pattern matching instead of head+tail
02:03:59 <mmorrow> Baughn: check it out http://moonpatio.com/code/constmem_ghc_jhc.tar.gz
02:04:16 <mmorrow> (4MB since it includes a massive csv to use as input)
02:04:27 <mmorrow> 200,000+ lines
02:04:44 <mmorrow> i did
02:04:45 <Saizan> well, jhc deals with memory in a very different way, i'm not sure if it has a garbage collector
02:04:52 <mmorrow> ./csv < all470.csv
02:05:08 <mmorrow> Saizan: yeah, it doesn't. uses region inference
02:05:28 <ozy`> Saizan: good idea. that cuts down about 20 characters :p
02:05:56 <mmorrow> i'm not sure exactly how that works though
02:08:59 <mmorrow> here's csv.hs for reference http://moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=199#a199
02:10:08 <ozy`> Saizan: so, http://hpaste.org/11256#a1 ... anything else?
02:16:23 <mmorrow> wow, looks like jhc's getContents is part of the problem
02:16:28 <mmorrow> compile:
02:16:32 <vegai> Does anyone have examples on how to use the Hyena webserver?
02:16:40 <mmorrow> [m@ganon s]$ cat go.hs
02:16:40 <mmorrow> main = putStr =<< getContents
02:16:43 <mmorrow> then do
02:16:51 <mmorrow> [m@ganon s]$ cat /dev/urandom | od | ./go
02:17:00 <mmorrow> it'll eventually exhaust all memory
02:17:15 <kowey> does cabal install set some kind of VERBOSE flag somewhere?
02:17:45 <mmorrow> vegai: oh nice, is there a repo for that somewhere?
02:17:52 <kowey> I am working on a custom build method and when I use the cabal command, it seems to be verbose, whereas normally it is silent
02:18:16 <vegai> mmorrow: http://github.com/tibbe/hyena/tree/master
02:18:21 <lambdabot> Title: tibbe's hyena at master — GitHub
02:18:29 <mmorrow> excellent
02:18:47 <vegai> left-fold enumerators fth
02:18:52 <vegai> (for the hype) :P
02:28:26 <mmorrow> vegai: heh
02:32:35 <vegai> perhaps the great monad tutorial trend will be replaced by a left-fold enumerator tutorial trend
02:49:23 <cads> are we far away from mobile software agents which carry their own security proofs?
02:50:16 <Heffalump> Java and .NET are a step in that direction
02:52:29 <cads> I wonder if it's possible to decide whether a given piece of java can violate a security policy
02:54:06 <cads> I'd venture that it may be undecidable in general, but that a useful subset of a language may be constructed in proof frameworks that ensure safety
02:54:20 <kowey> cabal question: is import Distribution.MyCustomStuff (in Setup.hs) expected to work? [ where Distribution/MyCustomStuff.hs is in the package I'm trying to build? ]
02:54:38 <kowey> it works if I do runhaskell Setup configure, but not if I do cabal configure :-/
02:54:44 <ozy`> Heffalump: a step on a path up the slopes of Everest, perhaps
02:59:23 <nha__> are there any tools to help cleanup import cruft?
03:00:38 <sidewinder128> Hello, Does Haskell have a web framework or a web server?.
03:00:58 <ozy`> sidewinder128: happs
03:01:11 <ozy`> http://happs.org/
03:01:17 <lambdabot> Title: HAppS — The Haskell Application Server
03:01:31 <sidewinder128> alright thanks
03:02:45 <besiria> is there a way to examine interactively the order of evaluation?
03:03:32 <mauke> besiria: AFAIK, no
03:04:04 <besiria> mauke: debugging wouldn't work?
03:05:10 <mauke> hmm, maybe
03:11:06 <Philippa_> besiria: depends what you mean by 'the' order of evaluation. The GHC debugger can help
03:11:09 <Philippa_> GHCi, rather
03:16:09 <vixey> mhy would you actually ever want to consider evaluation order?
03:19:59 <romildo> Hi.
03:20:03 <vixey> hello
03:20:43 <vixey> @seen dcoutts
03:20:43 <lambdabot> I saw dcoutts leaving #ghc, #haskell, #gentoo-haskell and #haskell-soc 1d 2h 52m 37s ago, and .
03:21:37 <romildo> How to write the following expression using high order functions?
03:21:38 <romildo>   pixbufNewFromFileAtSize filePath width height >>= \x -> return (Just x)
03:21:55 <vixey> \x -> return (Just x)
03:22:04 <vixey> = \x -> (return . Just) x
03:22:09 <vixey> = return . Just
03:22:22 <vixey> :t \x -> return (Just x)
03:22:24 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m (Maybe a)
03:22:25 <vixey> :t return . Just
03:22:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m (Maybe a)
03:22:47 <vixey> (.) is higher order
03:22:59 <vixey> then I think you could also write
03:23:06 <vixey> Just <$> pixbufNewFromFileAtSize filePath width height
03:23:18 <vixey> :t Just <$> ?f
03:23:19 <lambdabot> forall a (f :: * -> *). (Functor f, ?f::f a) => f (Maybe a)
03:24:22 * mmorrow loves acm papers under lock and key
03:25:49 <romildo> :t (<$>)
03:25:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:26:27 <ziman> i just can't figure out how to define type Parser a with Parsec 3, could anyone give me a hint?
03:26:46 <romildo> Which module does defines <$> ?
03:26:54 <ziman> romildo, Control.Applicative
03:26:58 <vixey> @hoogle (<$>)
03:26:59 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
03:26:59 <ziman> @hoogle (<$>)
03:26:59 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
03:27:18 <vixey> ziman: yeah it is a bit tricky I think they changed stuff around
03:29:06 <Taejo> :t (&&&)
03:29:07 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
03:29:08 <romildo> ziman, vixey, thanks for the tips.
03:31:50 <ziman> type Parser a = Parsec String () a
03:31:53 <ziman> w00t ;)
03:32:16 <ziman> i was trying to use Char instead of String
03:36:06 <ozy`> @src ($)
03:36:06 <lambdabot> f $ x = f x
03:36:13 <ozy`> well then
03:36:45 <vixey> ($) f x = f x
03:36:48 <vixey> ($) f = f
03:36:50 <vixey> ($) = id
03:36:52 <mmorrow> besiria: you can do it with Debug.Trace http://hpaste.org/11257
03:51:52 <TSC> @hoogle iterate
03:51:52 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
03:51:53 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
03:51:53 <lambdabot> Data.ByteString.Lazy iterate :: (Word8 -> Word8) -> Word8 -> ByteString
03:51:55 <TSC> @hoogle iterateM
03:51:55 <lambdabot> No results found
03:52:00 <TSC> No iterateM?
03:52:10 <vixey> can you tell me what the type of iterateM would be
03:52:27 <TSC> No
03:52:37 <TSC> I was hoping for a magic function (:
03:52:50 <vixey> so not  (a -> m a) -> a -> m [a]  ?
03:53:19 <besiria> mmorrow: great thx. it should only be used interactively?
03:53:50 <TSC> vixey: Yeah, I guess so
03:53:59 <vixey> I'm sure that doesn't currently exist
03:54:40 <TSC> I don't see how it could even work
03:54:49 <Beelsebob> @type sequence . itterate
03:54:50 <lambdabot> Not in scope: `itterate'
03:54:54 <Beelsebob> @type sequence . iterate
03:54:55 <lambdabot>     Couldn't match expected type `[m a]'
03:54:55 <lambdabot>            against inferred type `a1 -> [a1]'
03:54:55 <lambdabot>     Probable cause: `iterate' is applied to too few arguments
03:54:59 <vixey> :t sequence . iterate ?f
03:55:00 <lambdabot> forall (m :: * -> *) a. (?f::m a -> m a, Monad m) => m a -> m [a]
03:55:13 <Beelsebob> sorted :)
03:55:16 <vixey> this is not how to do it for two reasons
03:55:21 <Beelsebob> hmm?
03:55:30 <Beelsebob> oh
03:55:34 <Beelsebob> needs an m a for a start
03:55:35 <Beelsebob> not an a
03:55:41 <TSC> I just want sequence + replicateM, I think
03:55:42 <Beelsebob> but that can easily be wrapped in a return
03:55:46 <vixey> sequence will actually try to run infinite stuff in most monads
03:55:56 <Beelsebob> oh, that's lame
03:55:59 * mmorrow is now an acm member
03:56:11 <TSC> Yeah, in my case it's IO, so infinity is bad
03:56:44 <mmorrow> besiria: err, it could be used in compiled code also, but i'm not sure what you're looking to use it for.
03:57:31 <vixey> mmorrow: If you want something good to read Yokoyama & Glück have some papers on there
03:57:45 <mmorrow> vixey: cool
04:02:27 <vixey> I might have actually fixed zlib now
04:04:22 <vixey> (other possibilyt, it might have never been broken too)
04:13:23 <vixey> I don't know if cabal install should work differently to runhaskell setup
04:13:44 <vixey> wow
04:13:44 <vixey> Agda.TypeChecking.Tests
04:13:45 <vixey> Heap exhausted;
04:13:45 <vixey> Current maximum heap size is 499998720 bytes (476 MB);
04:13:51 <vixey> 476 MB of typechecking
04:25:56 <mmorrow> vixey: re. autoderiving parsing/pprinting functions, have you seen the paper "Haskell, do you read me?: constructing and composing efficient top-down parsers at runtime"? looks good
04:26:57 <vixey> oh thanks, have not seen it
04:39:14 <ziman> i suspect something's wrong with the new buildExpressionParser :\ http://hpaste.org/11258
04:58:19 <BONUS> hey
04:58:21 <BONUS> who runs hpaste?
04:59:11 <BONUS> nvm
05:01:57 <ttt--> , 3
05:02:05 <lunabot>  3
05:02:13 <ttt--> , [| 3 |]
05:02:17 <lunabot>  LitE (IntegerL 3)
05:02:28 <ttt--> , let foo string = [| string |]
05:02:30 <lunabot>  luna: parse error on input `)'
05:04:07 <ttt--> how come this works in ghci "let foo string =  [| string |]"
05:04:19 <mauke> because ghci is like an interactive do-block
05:04:19 <ttt--> but not "let foo string = [t| string |]"
05:04:25 <vixey> , let foo string =  [| string |] in ()
05:04:25 <mauke> oh
05:04:27 <lunabot>  ()
05:04:28 <Heffalump> t means type, doesn't it?
05:04:34 <ttt--> yeah
05:04:34 <vixey> , let foo string =  [t| String |] in ()
05:04:37 <lunabot>  ()
05:04:39 <vixey> , let foo string =  [t| string |] in ()
05:04:41 <lunabot>  luna: Not in scope: type variable `string'
05:04:45 <Heffalump> so that's why, string isn't a type
05:04:46 <vixey> , let foo string =  [t| forall string. string |] in ()
05:04:48 <Heffalump> it's value
05:04:48 <lunabot>  ()
05:05:20 <ttt--> oh right
05:06:21 <ttt--> how could i get the ExpQ type from a string input?
05:12:56 <ttt--> , let foo string =  [t| forall string. string |] in (foo "String")
05:12:58 <lunabot>  ForallT [string_0] [] (VarT string_0)
05:13:03 <ttt--> oh, that works
05:13:04 <ttt--> thanks
05:13:27 <Saizan> look closer
05:13:50 <ttt--> oh it's just forall a. a?
05:13:55 <Saizan> yeah
05:14:28 <Saizan> i don't think you can get the quoter to work on arbitrary String
05:17:24 <ttt--> how does ghci do it?
05:18:32 <ttt--> it can parse [| undefined :: String |] into an Exp
05:21:53 <Saizan> , [| undefined :: String |]
05:21:56 <lunabot>  SigE (VarE undefined) (ConT String)
05:24:44 <vixey> @seen dolio
05:24:44 <lambdabot> dolio is in #ghc, #haskell-blah and #haskell. I don't know when dolio last spoke.
05:25:01 <vixey> @tell dolio \neg actually also works I just noticed
05:25:02 <lambdabot> Consider it noted.
05:32:15 <mmorrow> , lift "asdf"
05:32:17 <lunabot>  ListE [LitE (CharL 'a'),LitE (CharL 's'),LitE (CharL 'd'),LitE (CharL 'f')]
05:32:21 <mmorrow> heh
05:32:37 <mmorrow> , lift ("asdf"::String)
05:32:39 <lunabot>  ListE [LitE (CharL 'a'),LitE (CharL 's'),LitE (CharL 'd'),LitE (CharL 'f')]
05:32:44 <mmorrow> hmm, sucky
05:32:51 <vixey> , lift lift
05:32:53 <lunabot>  luna: No instance for (Language.Haskell.TH.Syntax.Lift
05:33:31 <mmorrow> anyways, lunabot has instances of show for Q {Exp,Dec,[Dec],Type,String,Doc} which use (unQ :: Q a -> a), where
05:33:41 <mmorrow> unQ = unsafePerformIO . runQ
05:34:14 <mmorrow> so if you aren't using that and want to see a Q _, runQ :: (Quasi m) => Q a -> m a
05:34:58 <mmorrow> and the only provided instances of Quasi are Q and IO
05:35:17 <mmorrow> Q is interestingly defined as well:
05:35:23 <mmorrow> , src ''Q
05:35:31 <lunabot>  newtype Q a = Q {unQ :: (forall m . Quasi m => m a)}
05:35:58 <mmorrow> , return [|()|]
05:36:00 <lunabot>  luna: No instance for (GHC.Show.Show (m Language.Haskell.TH.Lib.ExpQ))
05:36:06 <mmorrow> , return [|()|] :: ExpQ
05:36:08 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Exp'
05:36:25 <mmorrow> bah
05:36:31 <ivanm> if I've got data of the form [(a,[(b,c)])], would there be a neat/efficient way of "transposing" it into [(b,[(a,c)])] ?
05:37:02 <mmorrow> ah,
05:37:14 <mmorrow> , return (runQ [|()|]) :: ExpQ
05:37:16 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Exp'
05:37:19 <ivanm> it's representing 3D points, and I'm basically wanting to rotate the axis
05:37:25 <jethr0> ivanm: which of the inner b's would you use for the outer b?
05:37:36 <mmorrow> , runQ [|()|]
05:37:38 <lunabot>  luna: No instance for (GHC.Show.Show (m Language.Haskell.TH.Syntax.Exp))
05:38:02 <mmorrow> i guess you need to be able to see the Q con or something (?)
05:38:07 <Cale> ivanm: It might be simplest to go via a list of triples...
05:38:25 <ivanm> Cale: turn it to triples, sort, group, convert back?
05:38:35 <Cale> yeah, something like that
05:38:44 <ivanm> *sigh* that's what I was afraid of
05:38:47 <ivanm> oh well...
05:38:57 <mmorrow> @pl \[(a,[(b,c)])] -> [(b,[(a,c)])]
05:38:57 <lambdabot> (line 1, column 2):
05:38:58 <lambdabot> unexpected "["
05:38:58 <lambdabot> expecting pattern
05:39:15 <mmorrow> @pl \([(a,[(b,c)])]) -> [(b,[(a,c)])]
05:39:15 <lambdabot> (line 1, column 3):
05:39:15 <lambdabot> unexpected "["
05:39:15 <lambdabot> expecting pattern
05:39:22 <mmorrow> fail
05:39:34 <Cale> It would be interesting to have a datastructure like Data.Map but which supported arbitrarily many fast indexes on its elements.
05:39:38 <mmorrow> @pl \(a,[(b,c)]) -> (b,[(a,c)])
05:39:38 <lambdabot> (line 1, column 5):
05:39:38 <lambdabot> unexpected "["
05:39:38 <lambdabot> expecting "()", natural, identifier, "_" or "("
05:39:47 <Cale> (or Data.Set)
05:40:08 <mmorrow> how do you mean "fast indexes"
05:40:08 <mmorrow> ?
05:40:39 <Cale> I mean that you could do lookups based on any of a number of projections on the data.
05:40:39 <vixey> ivanm: Do you have an example input and output
05:40:52 <mmorrow> Cale: hmm, that's interesting
05:41:59 <Cale> Of course, you could do it with a simple collection of Data.Maps
05:42:14 <Cale> But is that really the best way?
05:42:51 <ivanm> vixey: hmmm..... [('a',[(1,Just 1),(2,Just 2)]),('b',[(1, Nothing), (2,Nothing)])] ==> [(1,[('a',Just 1),('b',Nothing)]),(2,[('a',Just 2),('b',Nothing)])]
05:42:52 <mmorrow> Cale: do you mean projections /of/ the data onto a provided key type, or projections from some type /onto/ the type of the data?
05:43:04 <mmorrow> (or either)
05:43:12 <mmorrow> (or both)
05:43:12 <Peaker> Beelsebob: Hey, are you here?
05:44:07 <Peaker> hmm. "cabal upgrade" is failing with "cabal: Couldn't read cabal file "./derive/0.1.2/derive.cabal""
05:44:16 <Cale> mmorrow: What I mean is roughly like a Data.Map with multiple keys.
05:44:37 <Cale> mmorrow: (and an operation for finding elements based on any one of them)
05:45:08 <mmorrow> ah, so the "keys" are different projection from the type of elems
05:45:13 <Cale> yeah
05:45:21 <Cale> At least, that's one way to look at it.
05:45:33 <mmorrow> hmm
05:45:34 <Cale> I suppose that's still limited in a sense.
05:46:02 <Cale> What we really need is an efficient type for arbitrary relations.
05:47:05 <Cale> (but maybe having only one element with any given coordinate would allow for a more efficient representation?)
05:47:40 <mmorrow> hrm, i'm not sure exactly
05:48:03 <mmorrow> i'm gonna think about this though
05:50:34 <Beelsebob> Peaker: I am here, yes
05:51:05 <mmorrow> supposing a Set for simplicity's sake, it seems like you'd be dealing with something like sub :: (b -> b -> Bool) -> (a -> b) -> S a -> S a
05:51:15 <Peaker> Beelsebob: I read how future values were implemented (and finally got it). I was wondering if they have deterministic behavior regarding mappend
05:51:41 <mmorrow> but then it's not clear to me how you'd be able to efficiently find that subset with only the Ord on a
05:51:53 <Peaker> Beelsebob: and what changes have you guys made to Reactive since the "simply efficient function reactivity" paper.  One thing I noticed in the blog is that conal said that the distinction between Event and Reactive value was a mistake (IIRC)
05:51:54 <vixey> transpose abc's = map joining . groupBy ((==)`on`fst) . sortBy (comparing fst) $ do (a,bc's) <- abc's; (b,c) <- bc's; return (b,[(a,c)]) where joining ((a,bc's):abc's) = (a, bc's ++ concatMap snd abc's)
05:52:23 <Peaker> Beelsebob: also, if all the problems regarding the use of threads (only getting runtime during allocations, kill races, etc) were solved
05:52:58 <mmorrow> err,  member :: (Ord a) => (b -> b -> Bool) -> (a -> b) -> b -> S a -> Bool
05:53:21 <nicknull> MissingH-1.0.0 ison Hackage but MissinyPy asks for 1.0.1 or bigger...
05:53:22 <Beelsebob> Peaker: yeh, there's still a couple of minor problems with threads
05:53:28 <mmorrow> (that sub type was borked in more ways than one)
05:53:45 <Beelsebob> we have an odd interaction with the runtime that can cause events to get delayed by rather a long time occassionally
05:53:48 <Beelsebob> that we can't figure out
05:54:16 <Peaker> Beelsebob: ghc needs a good debugger :P
05:54:21 <Beelsebob> yep
05:54:26 <Beelsebob> bloody hard that task
05:54:38 <Beelsebob> but yeh, the Event semantics aren't very nice at all, but they work, just about
05:54:58 <Beelsebob> and yes, mappend is determanistic
05:54:59 <nicknull> and then it cant find module system.posix
05:55:03 <nicknull> seriously this doesnt work
05:55:07 <Beelsebob> everything in reactive is determanistic
05:55:11 <nicknull> if u want people to use haskell
05:55:17 <nicknull> installing has to work bette
05:55:17 <Peaker> Beelsebob: how is it deterministic, if you're racing two threads to bring the next event?
05:55:26 <nicknull> or is this a windows problem mostly?
05:55:48 <Peaker> nicknull: The Haskell community has "avoid success at all costs" as a semi-humourous slogan.. :)  Basically success/popularity is not a primary goal
05:55:58 <Cale> mmorrow: Well, maybe start with something which is like Set (a,b) but where you can quickly tell if there's an element in it with any specific a or b
05:56:07 <Beelsebob> Peaker: because unamb has a precondition (which unfortunately isn't enforced, but we're sure is true whenever it's used in reactive) -- that is, the two values you pass to it must be equal
05:56:37 <Peaker> Beelsebob: Is that the way it works now in the cabal'able Reactive?
05:56:46 <Cale> mmorrow: (and find which one)
05:57:01 <Beelsebob> Peaker: uh, pass on which reactive you have -- get the darcs one -- the one in Hackage is rather out of date
05:57:19 <Peaker> Beelsebob: ah. do you have a darcs URL?
05:57:33 <Peaker> oh wait, I did darcs get it once
05:57:42 * Peaker pulls
05:57:51 <mmorrow> Cale: ah yeah, that's an idea. that reminds me of some of the example instances of Measured in the fingertree paper.
05:58:15 <mmorrow> i'll have to look at it again though to refresh my memory
05:58:26 <Beelsebob> Peaker: how recently -- conal did a clean up of where reactive repos are
05:58:38 <Cale> mmorrow: (better still if you can find all the pairs (a,b) with given a or b)
05:59:00 <vixey> omg Agda is soooooooo slow
05:59:00 <Peaker> Beelsebob: a while ago: its pulling from http://code.haskell.org/reactive
05:59:09 <Beelsebob> yep, that's the right one
05:59:11 <lambdabot> Title: Index of /reactive
05:59:13 <Peaker> Beelsebob: cool, thanks
05:59:19 <mmorrow> Cale: it'd be really cool (and useful) to have a mini language to describe the various queries you'd want
05:59:39 <Peaker> Beelsebob: For some reason, btw, I found the blog explanations of Reactive's implementation much clearer than the paper (simply efficient Functional Reactivity)
05:59:54 <Peaker> Beelsebob: its been a while and I also understand the undelying concepts better though, so maybe its just that :)
05:59:55 <ikegami__> Actually, Agda is based on ghci
06:00:04 <vixey> It's still SLOW
06:00:12 <Cale> mmorrow: Yeah, we probably are reinventing database theory ;)
06:00:59 <Beelsebob> Peaker: yeh, I think the paper really has just too much in it
06:01:08 <mmorrow> Cale: heh
06:01:31 <Beelsebob> it's rather confused between the semantics, the implementation, and the interesting stuff about why things are that way
06:03:01 <ikegami__> a tip : add -H option on .ghci in your home directory
06:03:04 <Peaker> Beelsebob: I gotta go. I'd really love to play more with Reactive... It'd be great if there were more examples to work with.  Is Phooey up-to-date w.r.t Reactive?
06:03:05 <nicknull> terrible way to name a package anyway, MissingH
06:03:41 <ikegami__> might make Agda be faster (maybe)
06:03:47 <vixey> ikegami_: oh thanks, I'll try it
06:03:53 <nicknull> is there some easy webapp-framework that just download and run? (not happs then)
06:04:19 <Peaker> how do I remove a ghc-pkg completely?
06:04:21 <ikegami__> vixey: you know, -H option requires the heap size
06:04:26 <Peaker> just remove its files and ghc-pkg hide?
06:04:31 <ikegami__> let's see the document of ghc
06:04:33 <vixey> weird
06:04:34 <vixey> no-nos-mac-pro:~ nono$ ghci -H
06:04:34 <vixey> ghc: panic! (the 'impossible' happened)
06:04:34 <vixey>   (GHC version 6.11.20081015 for i386-apple-darwin):
06:04:34 <vixey> 	ghc: panic! (the 'impossible' happened)
06:04:43 <vixey> impossible happened twice!
06:04:54 <ikegami__> for example, -H14m
06:05:01 <vixey> Static flags have not been initialised!
06:05:01 <vixey>         Please call GHC.newSession or GHC.parseStaticFlags early enough.
06:05:16 <vixey> I have export GHCRTS=-M500M in my .profile
06:05:45 <ikegami__> I don't know the deep of ghci...
06:05:59 <araujo> morning
06:06:10 <ikegami__> but 'ghci -H14m' works on my laptop
06:06:26 <vixey> ikegami_: but you don't use emacs mode?
06:06:59 <ikegami__> vixey: I use emacs mode: I don't know another way to use Agda
06:07:07 <vixey> ok
06:08:38 <vixey> actually takes about 1 min to just load my data definitions :/
06:08:48 <vixey> this is 30 lines of code
06:09:16 <ikegami__> vixey: ah, don't mind; i have the same experience
06:09:54 <vixey> It might be some terrible hack I put in the zlib though..
06:10:01 <ikegami__> for example, loading the standard library of Agda, it takes few(?) minutues on my laptop...
06:10:21 <vixey> I couldn't load the RingSolver examples from there
06:10:27 <vixey> they just took too long so I stopped it
06:10:33 <ikegami__> hehe
06:10:56 <ikegami__> you can ask how to Agda makes faster on the Agda mailing list
06:11:18 <ikegami__> main developers (Nils or Nisse) may know the howto
06:19:52 <besiria> epigram is discontinued?
06:20:03 <vixey> no I think they are still working on Epigram
06:20:16 <vixey> there is a darcs repo for 2 but it's not finished
06:38:46 <kebomix> Free programming ebooks With Direct Links & Request ebooks Here http://request-ebooks.blogspot.com/
06:38:47 <lambdabot> Title: Request E-Books
06:39:13 <badsheepy> :o
06:39:13 <Peaker> Beelsebob: sorry to bother you all the time ;) Do you know if vector-space from darcs is supposed to build?
06:39:27 <Beelsebob> oh, it is -- but it needs ghc-6.9
06:39:32 <Beelsebob> that's rather awkward atm
06:39:39 <Beelsebob> because 6.10 had a bug that stops it building
06:39:49 <Beelsebob> and 6.8 didn't support enough of type families
06:40:34 <Peaker> Beelsebob: should reactive and all its deps + phooey build on ghc 6.9?
06:40:56 <Baughn> Beelsebob: Had? Not has?
06:40:57 <Beelsebob> yes, but I can't guarentee which date it was that we all have and it works
06:40:59 <Beelsebob> let me check
06:41:22 <Beelsebob> Baughn: some of the newer builds don't -- but they have a seperate bug that stifles reactive :/
06:41:30 <Peaker> Ghc 6.10 exists?
06:41:41 <Baughn> Peaker: 6.10.0 exists, yes
06:41:46 <Baughn> That's the beta
06:41:47 <Beelsebob> not 6.10.1 though
06:41:51 <vixey> 6.11
06:42:00 <Peaker> Where can I get ghc 6.9?
06:42:03 <Baughn> ..surely, not yet
06:42:11 * vixey I am using 6.11
06:42:19 <Baughn> Peaker: Get 6.10. Stop darcs downloading patches newer than a certain date, or unpull newer ones.
06:42:23 <Beelsebob> from the ghc downloads pagke Peaker -- there's a section for snapshots
06:42:54 <Peaker> ah cool, I'll try the snapshots
06:47:14 <agcorona> any new feature in ghc 6.10?
06:47:32 <nicknull> agcorona: it is completely strict
06:47:39 <nicknull> laziness is dumped
06:47:41 <vixey> yes
06:47:48 <agcorona> hehe
06:48:02 <agcorona> laziness is nce
06:48:05 <agcorona> nice
06:48:44 <Baughn> agcorona: http://hackage.haskell.org/trac/ghc/wiki/Status/Releases <-- Yes.
06:48:51 <lambdabot> Title: Status/Releases - GHC - Trac
06:49:37 <Baughn> Beelsebob: By the way, do you have a bug report for that type family bug?
06:50:25 <nicknull> when is 10 coming?
06:50:34 <agcorona> call me back when dynamic libraries are available
06:51:01 <vixey> acrolona: What is dynamic library and why would you want that
06:51:12 <agcorona> i use eval, and for this reason I have thee complete ghc compiler in my executable file
06:51:34 <vixey> agcorona: that sounds wrong
06:51:35 <agcorona> ten megabits for a line of code
06:51:42 <nicknull> call me back when you can JUST install a library
06:51:44 <Baughn> Not megabytes?
06:51:54 <vixey> agcorona: Can you actually show me some code you have used eval like that in
06:52:01 <vixey> agcorona: I have generally found other solutions in haskell
06:52:49 <Cale> nicknull: obviously, 6.10 is coming out shortly after Ubuntu Intrepid is released ;)
06:53:04 <agcorona> you mean NOT to use eval?
06:54:46 <agcorona> well it is not so much memory , but when the ghc library is used for load, eval and so on, the size of the executable grows a lot
06:55:08 <vixey> agcorona: I'm asking what sort of code you're writing such that eval is actually useful
06:55:58 <agcorona> It is not crazy to include all libraries in one only executable, but it is better the option to avoid it
06:56:21 <vixey> ok just totally lost track of what you were saying  now
06:56:21 <agcorona> vixey: I have a web server that loads server extensions
06:56:56 <therp> vixey: I found eval to be useful for "user scripting".. I once coded a demo spread sheet mini app that used eval to evaluate cells, so I had without much hassle I had all expressive power available to the spreed sheet user..
06:57:01 <agcorona> some extensions have configuration files that include code for overriding some default functions when needed
06:57:16 <therp> vixey: also for configuration files that do more than just flip some flags, eval is quite useful
07:01:05 <hsuh> http://learnyouahaskell.com/ is down
07:01:22 <Cale> @where LYAH
07:01:34 <Cale> hmm, is lambdabot down as well?
07:01:43 <Cale> > 1 + 1
07:01:48 <Cale> @botsnack
07:02:01 <lambdabot> www.learnyouahaskell.com
07:02:01 <lambdabot> :)
07:02:05 <lambdabot>   2
07:02:13 <Cale> ah, there we are.
07:02:19 <Cale> just lagged, I suppose.
07:02:38 <Cale> I should try and ssh in and see if there's anything wron.g
07:02:48 <hsuh> :)
07:03:12 <hsuh> its not exactly down here, but just endlessly on loading
07:03:19 <Cale> (with lambdabot, I don't have access to the lyah box)
07:03:24 <Cale> Is BONUS around?
07:08:18 <nicknull> maybe Bonus
07:08:26 <hsuh> Cale: did you do anything? is back here
07:08:27 <nicknull> either nothere orhere Bonues
07:08:39 <nicknull> Just here Nothing
07:08:51 <nicknull> Just around, maybe up
07:09:27 <Cale> hsuh: LYAH? Nope.
07:09:46 <Cale> hsuh: (I was referring to logging in to check on lambdabot)
07:09:53 <Cale> ssh: connect to host codersbase.com port 22: Connection timed out
07:09:55 <Cale> mm...
07:09:55 <hsuh> oh.. right.
07:10:09 <hsuh> i just figured that bonus is a person
07:10:29 <Cale> ah, BONUS is the guy reponsible for LYAH.
07:13:11 <Monkeytail> @BONUS.. just started reading your haskell tutorial/documentation
07:13:11 <lambdabot> Unknown command, try @list
07:13:25 <Monkeytail> (Y)
07:13:52 <Monkeytail> I'm fairly new to programming..
07:15:09 <Monkeytail> first question that popped up after reading the first chapter was.. what kind of tasks is haskell good at
07:15:26 <jeffz> anything you put your mind to really...
07:15:30 <Monkeytail> like.. php:web, python: jack of all trade
07:16:00 <Monkeytail> my background is is frontend webdevelopment ('design')
07:16:18 <Monkeytail> about a year im diggin into the backend stuff
07:16:45 <Monkeytail> what about haskell.. does it has een web thing going on.. like ruby or python?
07:17:18 <jeffz> I've used it as part of a webpage before.  I can show you a small demo if you like.
07:17:37 <Monkeytail> yeah! show me
07:17:59 <jeffz> http://jeffz.name/dominia.html - enter a number between 1-100 for any class
07:18:00 <lambdabot> Title: DominiaMUD: level information page for reincarnates or multiclassing
07:18:18 <jeffz> the source is linked at the bottom of the page
07:18:38 <Monkeytail> oke.. im gone look at it
07:19:13 <Cale> Monkeytail: Haskell is a general purpose language. You could use it for just about anything you could use any programming language for.
07:21:09 <Monkeytail> jeffz: looked at it.. the source code makes me dizzy hahah
07:21:28 <jeffz> Monkeytail: not surprising :)
07:21:41 <Monkeytail> it's all that new to me :S
07:23:03 <Cale> strfy looks at first glance that it might be improved by the use of at least one list comprehension
07:24:18 <Monkeytail> how come functional programming isn't that popular as oop?
07:24:37 <Cale> Monkeytail: because it's different, and people don't like learning new things :)
07:26:00 <Monkeytail> i understand
07:26:03 <therp> Monkeytail: because 'the functions are associated with data' concept is easier to understand than the more general concept of closures and higher order functions..
07:26:25 <therp> Monkeytail: that is "easier to understand" for those imperative guys..
07:26:28 * Cale hates the abusive use of the word 'closure' with a passion.
07:27:00 <Monkeytail> hahah
07:27:46 <Cale> Actually, I'd say that a much bigger difference is the move away from using mutation all over the place.
07:28:23 <Monkeytail> my first impression (according to the tut from BONUS) was it is tailord to math kind of stuff
07:28:46 <Cale> When you're used to the sort of programming where variables are boxes whose values get changed over and over, it's very different to learn to program in a language where variables are just the names of values, and never change.
07:28:50 <dejones> http://ocw.mit.edu/OcwWeb/Electrical-Engineering-and-Computer-Science/6-827Multithreaded-Parallelism--Languages-and-CompilersFall2002/CourseHome/index.htm -- Just came across this today, from MIT OpenCourseware site, they used Haskell in the Multithreaded Parallelism: Languages and Compilers course.
07:28:51 <lambdabot> Title: MIT OpenCourseWare | Electrical Engineering and Computer Science | 6.827 Multith ..., http://tinyurl.com/2rqckl
07:28:59 <dejones> :)
07:29:24 <Cale> Monkeytail: Well, it appeals to mathematicians for the reason that functions are *really* functions.
07:29:41 <Cale> Monkeytail: But that doesn't mean that it's not good for other things :)
07:30:21 <manro> http://kukaj.php5.sk/ http://kukaj.php5.sk/ http://kukaj.php5.sk/ http://kukaj.php5.sk/
07:30:23 <lambdabot> Title: Kukaj.php5.sk
07:30:28 <Cale> Monkeytail: A really nice thing about Haskell code is that you can reason about it in much the same way that you reasoned about functions in highschool algebra.
07:30:49 <Cale> Monkeytail: that is, you evaluate expressions by replacing things with their definitions.
07:31:12 <Monkeytail> Cale: math and algebra weren't my best classes :S
07:31:27 <Cale> If you have  f x = x^2 + x + 1, then f (3*7) = (3*7)^2 + (3*7) + 1
07:31:45 <Monkeytail> Cale: I'm more of a creative guy
07:31:47 <jeffz> the first thing I disliked about programming when I first explored it was that I could _not_ reason about things in C like highschool algebra
07:31:48 <Cale> and this sort of replacement applies no matter how complicated f gets
07:31:55 <vixey> Monkeytail: hahaha
07:32:31 <Cale> Monkeytail: It's unfortunate that mathematics is not presented more often as what it really is, which is a very creative subject.
07:32:49 <Monkeytail> Cale: thats true
07:33:39 <Cale> But the point I'm trying to make is that imperative languages have you writing unfortunate things like  x = x + 1  all the time, which makes the meaning of the program hard to reason about.
07:34:05 <EvilTerran> > let x = 0; x = x + 1 in x
07:34:06 <lambdabot>       Conflicting definitions for `x'
07:34:06 <lambdabot>      In the binding group for: x, x
07:34:17 <Monkeytail> Cale: for example.. something with regular expressions.. can you give me an example about that
07:34:22 <Cale> Sure...
07:34:32 <dmwit> > let x = 0 in let x = x + 1 in x -- it's bottom, I think, EvilTerran
07:34:47 <lambdabot>   thread killed
07:34:52 <EvilTerran> > let xs = [] in let xs = 1:xs in xs -- boo!
07:34:54 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:35:24 <Cale> > "abracadabra" =~ "ab" :: Bool
07:35:25 <lambdabot>   True
07:35:29 <Cale> > "abracadabra" =~ "ab" :: Integer
07:35:30 <lambdabot>       No instance for (Text.Regex.Base.RegexLike.RegexContext
07:35:30 <lambdabot>                ...
07:35:33 <Cale> hmm
07:35:37 <Cale> > "abracadabra" =~ "ab" :: [String]
07:35:39 <lambdabot>   ["ab","ab"]
07:35:42 <EvilTerran> > "abracadabra" =~ "ab" :: Maybe Integer
07:35:43 <lambdabot>       No instance for (Text.Regex.Base.RegexLike.RegexContext
07:35:43 <lambdabot>                ...
07:35:45 <EvilTerran> o
07:35:51 <Cale> Not sure it has that ;)
07:35:57 <Cale> > "abracadabra" =~ "ab" :: [(String,String,String)]
07:35:58 <lambdabot>       No instance for (Text.Regex.Base.RegexLike.RegexContext
07:35:59 <lambdabot>                ...
07:36:02 <Cale> huh...
07:36:11 <Cale> I need to look up which overloadings it has again
07:36:21 <EvilTerran> @instances-importing Text.Regex RegexContext
07:36:22 <lambdabot> Couldn't find class `RegexContext'. Try @instances-importing
07:36:29 <dmwit> > "abracadabra" =~ "ab" :: (String, String, String)
07:36:30 <EvilTerran> @instances-importing Text.Regex.Base.RegexLike RegexContext
07:36:31 <lambdabot>   ("","ab","racadabra")
07:36:34 <dmwit> > "abracadabra" =~ "ab" :: (String, String, String, [String])
07:36:35 <lambdabot>   ("","ab","racadabra",[])
07:36:39 <Cale> (I don't use regular expressions a whole lot)
07:36:43 <dmwit> > "abracadabra" =~ "ab" :: Int
07:36:44 <lambdabot>   2
07:36:46 <EvilTerran> ?bot
07:36:47 <lambdabot> :)
07:36:48 <EvilTerran> @instances-importing Text.Regex.Base.RegexLike RegexContext
07:36:53 <EvilTerran> ...
07:37:17 <dmwit> Cale: I guess they assume that if your String is long enough that the first match overflows an Int, you're probably out of memory anyway. ;-)
07:37:25 <Monkeytail> what does "ab":: Int mean?
07:37:27 <EvilTerran> Cale, i thought Maybe Integer would make more sense than Integer, in case it doesn't find a match
07:37:28 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/regex-base/Text-Regex-Base-RegexLike.html#t%3ARegexContext
07:37:30 <lambdabot> Title: Text.Regex.Base.RegexLike, http://tinyurl.com/5vzl28
07:37:36 <Cale> ah, it's Int!
07:37:40 <dmwit> Monkeytail: Actually, the type annotation binds the *whole* expression.
07:37:55 <dmwit> Monkeytail: So it parses as (("abracadabra" =~ "ab") :: Int).
07:37:59 <mathijs> Hi all, I'm a ruby programmer, but I'm very interrested in Haskell and FP in general. Since FP is tricky to master (just started), I don't think I can switch to Haskell fully (especially for larger projects). Also, every language has its strong sides, so switching fully to haskell when ruby is capable (and easy) for a certain task (or part of it) isn't what I want. Are there any guides on using ruby and haskell together? or Haskell and C ? (I us
07:38:10 <Cale> Monkeytail: We're asking for the matcher thingy to provide us with an Int
07:38:25 <dmwit> mathijs: Look up the Haskell FFI.
07:38:25 <EvilTerran> mathijs, you were truncated at "... or Haskell and C ? (I u"
07:38:32 <dmwit> mathijs: It makes bindings to C very easy.
07:38:40 <Cale> Monkeytail: The Text.Regex.Posix library has a bunch of ways that you can ask for the results of matching.
07:38:45 <mathijs> or Haskell and C ? (I use C extensions in ruby, so I can glue those together)
07:38:51 <Cale> Monkeytail: which are differentiated by the type of result which is demanded
07:38:52 <Monkeytail> Cale: oke
07:39:04 <EvilTerran> mathijs, ah, yes, then the FFI is what you'll be after
07:39:04 <Cale> Monkeytail: If you ask for an Int, you get the number of matches
07:39:07 <EvilTerran> ?where ffi
07:39:08 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
07:39:13 <Cale> Monkeytail: If you ask for a Bool, you get whether a match exists.
07:39:39 <hsuh> can i use lambdabot to find out the insert the users on #haskell and  #ocaml, for example?
07:39:49 <Monkeytail> Cale: got it.. you must specify the kind of type it gives output?
07:39:52 <mathijs> dmwit: OK, so c would be the glue for ruby->haskell and back. sounds good, since its mostly 'normal' types like strings and numbers that I need to exchange
07:39:52 <hsuh>  /sinsert the//
07:40:06 <Cale> Monkeytail: yeah. In a real program, it might be decided by context.
07:40:08 <geezusfreeek_> ?users
07:40:09 <lambdabot> Maximum users seen in #haskell: 518, currently: 497 (95.9%), active: 12 (2.4%)
07:40:12 <mathijs> EvilTerran: thanks, I'll have a look
07:40:17 <geezusfreeek_> hsuh: that sort of thing?
07:40:23 <Cale> Monkeytail: But in one line, it's hard to provide that context without just saying what type you want.
07:40:33 <dmwit> ?users
07:40:33 <lambdabot> Maximum users seen in #haskell: 518, currently: 496 (95.8%), active: 12 (2.4%)
07:40:36 <dmwit> ?users #ocaml
07:40:36 <lambdabot> Maximum users seen in #ocaml: 1, currently: 0 (0.0%), active: 0 (NaN%)
07:40:44 <vixey> lol
07:40:44 <dmwit> hsuh: ?
07:40:48 * Cale wonders why Heffalump still has +o
07:40:51 <EvilTerran> mathijs, there's a couple of helper programs, too; they're called c2hs and hsc2hs
07:40:52 --- mode: ChanServ set +o Cale
07:40:57 --- mode: Cale set -oo Cale Heffalump
07:41:10 <EvilTerran> @@ (@where c2hs) (@where hsc2hs)
07:41:10 <lambdabot>  http://www.cse.unsw.edu.au/~chak/haskell/c2hs/ http://www.haskell.org/ghc/docs/latest/html/users_guide/hsc2hs.html
07:41:20 <ivanm> where can I get CReal from?
07:41:31 <Cale> ivanm: The numbers package on hackage
07:41:32 <ziman> @where CReal
07:41:32 <lambdabot> I know nothing about creal.
07:41:33 <ivanm> since lambdabot seems to have it, is it part of any library?
07:41:36 <Cale> ivanm: Data.Number.CReal
07:41:44 <ivanm> Cale: hmmm.... cabal doesn't seem t know about it
07:41:51 <mathijs> EvilTerran: that's helpful, any guides/howto's also maybe? the specification itself is a bit cryptic :)
07:42:12 <ivanm> Cale: or is it AERN-Real?
07:42:13 <Monkeytail> Cale: thanks for your explanations (Y)
07:42:19 <ziman> ivanm, it's `numbers'
07:42:20 <EvilTerran> c2hs in particular reads in your C headers and some info about the desired haskell types and makes the glue semi-automatically for you
07:42:23 <mathijs> EvilTerran: ah, the second link is a guide, I can start with that
07:42:50 <ivanm> thanks ziman
07:43:00 <ivanm> Cale: oh, _now_ I see what you mean :s
07:43:10 <Monkeytail> Cale: i will read next chapters of the BONUS tut tonight or tomorow
07:43:15 <Cale> > "555-1234" =~ "([0-9]*)-([0-9])*" :: Array Int String
07:43:17 <lambdabot>   array (0,2) [(0,"555-1234"),(1,"555"),(2,"4")]
07:43:29 <ivanm> Cale: is there an easy way to convert CReal to/from Double?
07:43:35 <Monkeytail> bye bye all
07:43:35 <Cale> > "555-1234" =~ "([0-9]*)-([0-9]*)" :: Array Int String
07:43:37 <lambdabot>   array (0,2) [(0,"555-1234"),(1,"555"),(2,"1234")]
07:43:55 <Cale> ivanm: realToFrac
07:43:59 <Cale> :t realToFrac
07:44:01 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
07:44:03 <ivanm> since the reason I'm considering using it is that I need to sum a list of very large numbers (and AFAIK there's no formula for adding logs of numbers)
07:44:05 <ivanm> thanks Cale
07:44:12 <ivanm> and then use that back again?
07:44:15 <mathijs> EvilTerran: but what about the other way around? at first, I will keep ruby as my main language (for overall program) and call out to haskell code for certain parts, just like I call out to c now for parts that need performance.
07:44:16 <Cale> yep
07:44:51 <hsuh> dmwit: geezusfreeek_: sort of, but intersecting #ocaml and #haskell users and displaying that
07:44:56 <Cale> mathijs: Calling Haskell code from C is a little more work than calling C from Haskell, but both are possible.
07:45:02 <hsuh> or vim and emacs, so we can identify traitors
07:45:05 <mathijs> EvilTerran: so to do this, I need c to be able to call a haskell function also, so ruby can indirectly (through c) invoke haskell
07:45:29 <mathijs> Cale: is it done with FFI too?
07:45:31 <geezusfreeek_> ah
07:45:33 <EvilTerran> thing is, if haskell isn't the "outermost" language, you need to worry about initialising the haskell RTS, i believe
07:45:34 <Cale> mathijs: If you're interested in how to do this, you should read the FFI specification, which is fairly tutorial in nature, yeah.
07:45:51 <EvilTerran> the same would apply for ruby not being the "outermost" language, though, too
07:45:51 <Cale> EvilTerran: right
07:46:29 <EvilTerran> if you had haskell as the main language, you'd have to initialise the ruby RTS from haskell; vice-versa, vice-versa
07:48:16 <mathijs> EvilTerran: well, if I learn Haskell and get better at it over time, I might switch the outermost language and call ruby from haskell, but calling ruby code isn't easy, since it would still need the ruby interpreter
07:48:43 <Botje_> write a ruby interpreter in haskell!
07:48:43 <EvilTerran> same goes for calling haskell code from other languages, only it's a runtime system for compiled code rather than an interpreter
07:48:48 <EvilTerran> Botje_, :D
07:48:52 <nicknull> are there functions in http-simple to extract the text froma site?
07:49:00 <Botje_> bonus points if it's faster and cleaner than the C implementation
07:49:14 <jeffz> nicknull: have you looked at the docs?
07:49:24 <Botje_> even more bonus points if you can do it in 500 loc ;)
07:49:40 <EvilTerran> nicknull, have a look at http://hackage.haskell.org/packages/archive/HTTP-Simple/0.1/doc/html/Network-HTTP-Simple.html
07:49:45 <EvilTerran> see if you can spot it ;)
07:49:47 <lambdabot> Title: Network.HTTP.Simple, http://tinyurl.com/63lvg8
07:50:18 <mathijs> EvilTerran: but Haskell is compiled to a standalone executable I thought? of course some library that the code is dynamically linked to, but not a dependecy such as ruby code always has
07:51:11 <Japsu> How is an interpreter more of a dependency than a dynamic library?
07:51:25 <EvilTerran> mathijs, standalone, yes, but that standalone executable *includes* the binary code for the RTS
07:51:44 <EvilTerran> the RTS still has to be initialised etc
07:52:03 <mathijs> Japsu: it has to be invoked, instead of just (dynamically) linked
07:52:33 <Japsu> mathijs: yes, and exactly why is this a problem?
07:52:49 <mathijs> EvilTerran: but I can compile haskell code into a dynamic library (.so on unix, dll on windows) right?
07:52:57 <EvilTerran> don't you "invoke" a linked library by calling its exports?
07:52:58 <Japsu> on POSIX systems you just use the hashbang line
07:53:14 <Japsu> on Windows you just write a .cmd script to invoke the interpreter for you
07:53:27 <EvilTerran> mathijs, i don't recall, but if you did, the RTS would be included in that library file
07:53:50 <mathijs> well, that's true, it's not really different in that case
07:55:01 <mathijs> EvilTerran: that's OK with me, as long as it's a library that other code can invoke, but I think FFI is capable of this.
07:58:28 <therp> mathijs: shared library support is not ready yet for mainstream consumption
07:59:18 <therp> mathijs: but most likely 6.10.2 will have support for at least x86_64/linux.
07:59:58 <mathijs> hrm... so this means I can only use haskell as 'outermost' language? or use a socket to pass data back and forth?
08:00:03 <EvilTerran> no
08:00:11 <therp> mathijs: windows dll won't be there most likely, as we don't have the human resources to slay this beast
08:00:12 <ivanm> Cale: should I expect CReal to be rather slow?
08:00:13 <EvilTerran> but it's more work to use it as an "inner" language
08:00:33 <EvilTerran> and i believe you have to link statically for the time being
08:01:43 <vixey> mathijs: I'm sure you can do FFI with C and Haskell either direction
08:02:40 <therp> vixey: yes, that's possible
08:03:07 <vixey> and you can do bidi FFI with ruby and C
08:03:17 <vixey> (althought it's a bloody pest since ruby is so badly written)
08:03:22 <mathijs> but that would mean linking the haskell code staticly to the executable?
08:03:31 <vixey> so you can surely hack something that lets you do haskell to ruby ffi both ways
08:04:07 <vixey> would not imagine it being very useful though
08:04:26 <mathijs> probably, but I can't find much information on google about it, so I guess it's not a nice thing to do :)
08:04:38 <Cale> ivanm: I don't know. It's usually reasonable for me, but it really depends on what you're computing.
08:04:55 <vixey> mathijs: which did you want to? Maybe there's an alternative way
08:05:02 <vixey> why*
08:05:23 <ivanm> well, I'm asking because with Double, I had (bad) data that showed up pretty quickly via trace... whilst with CReal it just hangs
08:05:31 <ivanm> unless CReal doesn't like ghci?
08:05:55 <Cale> ivanm: Double is going to be much much faster
08:05:59 <Cale> (regardless)
08:06:14 <ivanm> Cale: I know.... but Double fails on summing up large numbers :s
08:06:30 <vixey> :k Rational
08:06:31 <lambdabot> *
08:06:44 <ziman> :k Ratio
08:06:45 <lambdabot> * -> *
08:07:04 <Cale> ivanm: What are you computing?
08:07:07 <ivanm> so unless there's a way of being able to simplify/compute log(sum xs) using (map log xs), then Double won't work
08:07:11 <hsuh> is there any way you can get the same tab-completion you get in ghci inside emacs/inf-haskell
08:07:12 <mathijs> well, since I'm still learning, I will at first only want to hand over tasks to haskell that a: I can program in haskell and B: that haskell is very good at, so mostly calculations, parsing stuff, things like that. So I would like to be able to hand Haskell some data from ruby and get back the result
08:07:12 <hsuh> ?
08:07:40 <ivanm> Cale: implementation of the Wang-Landau algorithm, computing the density of the number of states of the 2D ising model
08:07:41 <vixey> mathijs: If you are learning haskell, programming in ruby will only slow you
08:08:16 <Cale> mathijs: While the FFI is reasonably good, it's hard enough that I expect this approach will be much harder for you than just programming something entirely in one or the other.
08:08:31 <mathijs> vixey: It's my day-job, I can't just switch over in a day :) so implementing small parts first sounds good to me?
08:08:40 <ivanm> For part of the analysis, I need to find the weighted sum of the densities found, and considering that I've got numbers like 1e19... :s
08:08:47 <vixey> mathijs: I don't understand you
08:09:10 <vixey> mathijs: I'm saying that you should write everything in haskell not just small parts _because_ you are learning haskell
08:09:12 <Cale> mathijs: Making use of the FFI involves lots of marshalling and fiddly work with I/O.
08:09:33 <Cale> mathijs: So it's usually not something you want to attempt in your first couple months.
08:09:59 <mathijs> vixey: I have quite some stuff in ruby already, I can't rewrite them all at once, so I would like to start with some small parts that feel suitable first.
08:10:52 <ivanm> Cale: and all my numbers are different powers of 2...
08:11:02 <ivanm> s/2/10
08:11:08 <Cale> ivanm: hmm...
08:11:11 <ivanm> *different orders of magnitude
08:12:09 <Cale> ivanm: is there a bound on the level of precision you're looking for?
08:12:17 <ivanm> not really
08:12:24 <ivanm> I'll be plotting the log of the results
08:12:26 <Cale> So you want an exact result?
08:12:44 <ivanm> doesn't really have to be exact
08:12:48 <Cale> okay, so for plotting, perhaps we can get away with maybe a couple of decimal places.
08:13:09 <Cale> So you can throw away all but the very largest orders of magnitude.
08:13:10 <mathijs> Cale: thought so too... maybe it's better to just invoke haskell programs from ruby then, and communicate through the STDOUT/STDIN
08:13:22 <Cale> Unless you have *a lot* of smaller order terms.
08:13:35 <Cale> mathijs: That's likely.
08:13:37 <ivanm> Cale: the log looks a bit like a gaussian...
08:13:56 <Cale> ivanm: Are they distinct powers of 10?
08:14:17 <Cale> (you said different, but I'm not sure if you meant that in a technical sense)
08:14:28 <hsuh> the type annotation "factorial :: Int -> Integer" for "factorial n = product [1..n]" errors
08:14:38 <Cale> hsuh: Yes.
08:14:46 <ivanm> Cale: http://rafb.net/p/kn0S2V31.html <-- the kind of data I'm using
08:14:47 <lambdabot> Title: Nopaste - ising.20
08:14:50 <vixey> hsush: why?
08:14:51 <Cale> hsuh: Multiplying numbers of some type results in a number of the same type.
08:14:58 <hsuh> ok
08:15:22 <ivanm> yup, Double almost instantly gives out NaN's and Infinity's, but with CReal it hangs :s
08:15:24 <Cale> ivanm: what am I looking at here?
08:15:40 <ivanm> Cale: the second digit in each pair
08:15:43 <hsuh> BONUS: so thats a little fix to apply on LYAH :)
08:16:22 <Cale> ivanm: You want to compute something like log (sum [10^k | k <- xs]), right?
08:16:27 <mathijs> well everyone, thanks for the suggestions, I think I'll just start easy, and by the time I get better at haskell I can look into FFI, at that time dynamic linking will probably be available. Or I might want to switch completely :)
08:16:42 <ivanm> Cale: roughly, yes
08:17:09 <Cale> ivanm: Is xs a list of distinct elements?
08:17:17 <ivanm> no
08:17:31 <ivanm> for starters, xs is symmetrical
08:18:22 <Cale> okay, so at most twice then?
08:18:32 <ivanm> say 4 times
08:18:42 <Cale> (I just want some assurance that we don't have exponentially many small terms)
08:19:05 <Cale> See, you can just throw away all but the largest n terms, because you're taking the log anyway.
08:19:23 <Cale> and you'll get a decent approximation that way
08:19:42 <ivanm> what I'll be doing is map (flip (/) (sum xs)) xs
08:19:57 <Cale> uhh...
08:20:02 <Cale> oh, I see
08:20:18 <Cale> map (/ sum xs) xs
08:20:25 <ivanm> so basically I'm normalising my data
08:21:06 <seydar> what's a functor?
08:21:24 <Cale> seydar: In Haskell specifically, or in general?
08:21:36 <seydar> Cale: lets start with haskel specifically
08:21:56 <ivanm> @src Functor
08:21:56 <lambdabot> class  Functor f  where
08:21:57 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
08:21:58 <Cale> In Haskell, a functor is a type constructor f which has an operation  fmap :: (a -> b) -> (f a -> f b) which satisfies two laws:
08:22:01 <Cale> fmap id = id
08:22:01 <MarcWeber> seydar: In haskell you can see it as a box containing elements on which you can apply a function using fmap (eg list or a tree or Maybe)
08:22:08 <Cale> fmap (f . g) = fmap f . fmap g
08:22:44 <ivanm> Cale: so how would I tell which values to "throw away"?
08:23:00 <seydar> Cale: does f have to be Monadic?
08:23:17 <Cale> seydar: Monads are always functors, but not vice versa.
08:23:38 <seydar> @src fmap
08:23:38 <lambdabot> Source not found. Wrong!  You cheating scum!
08:23:44 <Cale> @src Functor
08:23:45 <lambdabot> class  Functor f  where
08:23:45 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
08:23:56 <seydar> whats an example of fmap?
08:24:07 <Cale> Well, for lists, it's just the usual map
08:24:16 <Cale> For Maybe, we have something like:
08:24:22 <Cale> fmap f Nothing = Nothing
08:24:27 <Cale> fmap f (Just x) = Just (f x)
08:24:30 <ivanm> Cale: hmmm..... it seems to hang on trying to calculate a certain value :s
08:24:49 <Cale> For  data Tree a = Tip | Branch a (Tree a) (Tree a)
08:24:53 <Cale> we have:
08:24:58 <Cale> fmap f Tip = Tip
08:25:11 <Cale> fmap f (Branch x l r) = Branch (f x) (fmap f l) (fmap f r)
08:25:31 <Cale> So basically, "apply the function to all the values in the datastructure)
08:25:34 <Cale> er, "
08:26:01 <Cale> ivanm: See about throwing away all the terms except those with the highest three orders of magnitude.
08:26:24 <Cale> ivanm: that is, sortBy (flip comparing) xs, group it, and take 3.
08:26:28 <Cale> er
08:26:32 <Cale> flip compare
08:26:32 <ivanm> heh
08:28:13 <seydar> wow, fmap is powerful
08:28:26 <Cale> You're taking the logarithm, and the logarithm doesn't change very rapidly, to say the least. So comparatively small differences in the input shouldn't matter so much.
08:29:00 <ivanm> hmmmm..... CReal freezes on trying to calculate the exponential of ~ -3e23 :s
08:30:05 <Cale> hmm, that it does
08:30:07 <ivanm> so, even if I threw away all those terms, it still wouldn't work :s
08:30:15 <ivanm> any idea why?
08:30:17 <Cale> But that number is so incredibly small that it might as well be 0
08:30:21 <seydar> an action is like an applied function, right? like map f [] ?
08:30:35 <ivanm> Cale: yes... but how do I _say_ that?
08:30:43 <ivanm> say, as in tell my program that
08:30:56 <Cale> Throw such numbers away before applying exp to them.
08:31:04 <ivanm> hmmmmmm.....
08:31:17 <Cale> Decide what kind of precision you're looking for, first of all.
08:31:48 <Cale> Let's say you want the integer part, and roughly the first 3 digits after the decimal point, and the rest doesn't matter.
08:32:33 <Cale> Unless you have at least 10 terms on the order of 0.0001, throwing them away is not going to affect your result.
08:32:40 <ivanm> *shrug* I'm only plotting it anyway
08:32:45 <Cale> Unless you have at least 100 terms on the order of 0.00001, throwing them away is not going to affect your result.
08:34:19 <Cale> log 0.0001 = -9.210, so anything more negative than that, just get rid of it.
08:34:47 <seydar> how do i include or require a cabal package to my program?
08:35:01 <Cale> seydar: Are you using cabal yourself?
08:35:17 <Cale> seydar: If so, then you add the package to the build-depends line.
08:35:31 <seydar> Cale: kk. thank you!
08:35:42 <Cale> If you're just compiling something small, just use --make on the GHC commandline, and it will figure out the packages required.
08:36:33 <seydar> kk
08:36:47 <seydar> what if i want to require a specific version of a lib?
08:37:34 <ivanm> duh, I know one reason why I'm having numerics issues
08:37:52 * ivanm sets boltzmanns' constant to 1, instead of 1e-23
08:37:52 <Cale> ivanm: why's that?
08:37:59 <Cale> ah
08:38:03 <ivanm> since I'm dividing by that number, it makes things _huge_
08:38:07 <Cale> hehe
08:38:45 <ivanm> looks like I don't need CReal any more... >_>
08:39:31 <Cale> seydar: foopackage >= 2.3
08:39:39 <ivanm> OK, I still have _some_ NaNs and Infinitys...
08:39:39 <Cale> seydar: or even   foopackage == 2.3
08:40:01 <Cale> ivanm: But you're still probably summing terms which are irrelevant...
08:40:15 <Cale> (unless you did what I said to do there ;)
08:40:50 <ivanm> not yet I'm not
08:42:36 <ivanm> Cale: so you're saying to only take the largest three numbers? :s
08:42:50 <Cale> ivanm: and their duplicates
08:42:59 <ivanm> ahhhhh, yes
08:43:04 <seydar> do monads count as impure?
08:43:07 <ivanm> though by duplicates, they won't _exactly_ be equal
08:43:11 <ivanm> seydar: not all of them are
08:43:15 <Cale> seydar: IO does.
08:43:21 <Cale> seydar: and it happens to be a monad.
08:43:28 <ivanm> IO is impure by definition :p
08:44:02 <Cale> What you include in your definition of impure beyond that is probably a bit of a matter of debate.
08:44:07 <ivanm> Cale: so is there a "fuzzy" way of comparing them, to get ones of similar orders of magnitude?
08:44:15 <Cale> ST is probably the next most impure.
08:44:32 <ivanm> well, anything that requires access via IO is impure
08:44:33 <Cale> ivanm: Well, do this before you exponentiate.
08:44:58 <ivanm> hmmmmm..... that will still get me only 3 values...
08:45:01 <Cale> So you're just taking the largest 3 or so exponents.
08:45:26 <Cale> That's fine. Smaller exponents contribute almost nothing.
08:45:51 <Cale> (unless there are exponentially many of them)
08:46:00 <ivanm> hmmmmm...... not sure whether 3 of them would be sufficient though...
08:46:09 <Cale> If you want 3 digits of precision.
08:46:12 <Cale> Then it should do.
08:46:21 <ivanm> well, it won't get the duplicates
08:46:30 <Cale> Won't it?
08:46:38 <ivanm> and by "duplicate", I mean ones of the same order of magnitude
08:46:46 <Cale> concat . take 3 . group . sortBy (flip compare) $ xs
08:46:53 <Cale> ah
08:46:59 <Cale> Well, okay
08:47:18 <ivanm> flip (compare `on` round) ?
08:47:23 <Cale> Take all the ones which are within 3 of the maximum then.
08:47:37 <Cale> I didn't know the exponents were anything but integers :)
08:47:38 <ivanm> (with that being done on the logs)
08:47:45 <ivanm> heh, doubles ;-)
08:47:56 <ivanm> well, my numbers are doubles...
08:47:59 <Cale> okay
08:48:07 <ivanm> and this is base e, not base 10
08:48:29 <ivanm> so comparing the rounded values would probably work AFAICT
08:48:58 <Cale> So maybe something like  let (y:ys) = sortBy (flip compare) xs in y : takeWhile (>= y - 3) ys
08:49:16 <seydar> i'm trying to install yi, and it wants alex version >=2.0.1 && <3. i just installed alex 2.3, but yi doesn't seem to believe me
08:49:28 <seydar> understandable?
08:49:43 <Cale> yi is always a pain to install for some reason
08:49:59 <ivanm> Cale: hmmmm.....
08:50:12 <Cale> I can think that maybe you installed one of them globally and one as user? Cabal tends to keep those separate...
08:50:34 <seydar> Cale: no sir. both are as a user
08:50:37 <Cale> hmm
08:50:41 <seydar> i ran 'cabal install alex yi'
08:50:55 <Cale> ah, it should auto-install dependencies anyway
08:51:13 <seydar> it didn't, so i had to manually install alex
08:51:18 <seydar> how do i uninstall something?
08:51:25 <seydar> also, how do i view my installed packages
08:51:31 <Zao> ghc-pkg list
08:51:35 <Cale> I don't think cabal has an uninstaller.
08:51:44 <Cale> But yeah, ghc-pkg list
08:51:45 <Zao> Uninstalling is just ghc-pkg unregister and hand-obliterate things, I believe.
08:51:53 <Cale> yeah
08:52:12 <Cale> Usually I just don't uninstall things. Eventually I upgrade ghc, and blow away my old libraries.
08:53:00 <Saizan> seydar: maybe you need to put ~/.cabal/bin in your PATH?
08:53:24 <Saizan> seydar: that's where executables are installed by default on *nix
08:55:01 <seydar> Saizan: how do i run an executable file (from haskell)?
08:55:32 <Saizan> seydar: is that unrelated?
08:55:40 <seydar> Saizan: yes
08:55:54 <Saizan> seydar: see System.Process or System.Cmd
08:56:32 <ivanm> Cale: OK, so now I switch to CReal only for summing those large terms, and it works! \o/
08:56:36 <ivanm> thanks for your help
08:56:50 <seydar> yay! Saizan you were right - now yi is installing!
08:57:12 <seydar> i'm so excited to have a nice console editor with highlighting. i've been using ne, but it has no syntax highlighting
08:58:12 <Saizan> oh, there's also haskell-mode for emacs and scripts for vim btw
08:59:44 <seydar> yea, but i hate emacs and vim
09:00:17 <mauke> ;_;
09:02:01 <alexsuraci> What's the 'standard' amount of indenting for the next line after "do"?
09:02:09 <alexsuraci> Regular 4 spaces, or any sort of aligning?
09:02:16 <camio> alexsuraci: 2 spaces
09:02:35 <mauke> I use 4 spaces
09:03:01 <seydar> I use 3 - up to the first letter of the conditions
09:03:03 <camio> Yeah, four spaces is also nice if you like having your first statement after the do.
09:03:07 <seydar> s/conditions/condition
09:03:09 <alexsuraci> So there's no aligning with the "do"? (e.g. two spaces after the "do")
09:03:43 <alexsuraci> Kind of hard to exemplify this stuff in IRC. :P
09:03:59 <camio> You could try hpaste.org
09:04:10 <alexsuraci> Sure
09:05:10 <mauke> example code: http://mauke.ath.cx/stuff/haskell/inotify/System/Linux/INotify.hsc
09:05:12 <lambdabot> http://tinyurl.com/6dsxhl
09:06:19 <alexsuraci> http://hpaste.org/11263
09:07:31 <alexsuraci> looking at mauke's example the second form seems to be more common
09:07:59 <seydar> Saizan: in System.Cmd's system and rawSystem, do they _both_ ignore the SHELL variable?
09:08:17 <mauke> seydar: I hope so
09:08:30 <mauke> actually, I don't think rawSystem uses the shell
09:08:57 <camio> alexsuraci: I generally try to do the former but if I go over 80 columns I do the latter.
09:09:12 <seydar> mauke: goody! thank you
09:10:02 <alexsuraci> camio: alright, guess I'll just do that
09:10:30 <mauke> yep, commandToProcess string = return ("/bin/sh", ["-c", string])
09:14:48 <Will\home> does haskell provide a quick way to remove elements in L2 from L1
09:14:53 <vixey> yes!
09:14:57 <Will\home> the equiv of Erlang's lists:subtract(L1, L2)
09:15:05 <BONUS> :t (\\)
09:15:06 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
09:15:21 <vixey> > let l2 = "pqdb" ; l1 = "uboqq qubbop" in l1 \\ l2
09:15:22 <lambdabot>   "uoq qubbo"
09:15:25 <mauke> > "Will\\home" \\ "Wlem"
09:15:28 <lambdabot>   "il\\ho"
09:15:32 <vixey> weird it didn't work
09:15:38 <vixey> > let l2 = "pqdb" ; l1 = "uboqq qubbop" in l1 // l2
09:15:40 <lambdabot>   Couldn't match expected type `Array i e'
09:15:43 <mauke> it worked fine
09:15:44 <vixey> > let l2 = "pqdb" ; l1 = "uboqq qubbop" in l2 \\ l1
09:15:46 <lambdabot>   "d"
09:15:53 <vixey> it doesn't work :?
09:16:00 <mauke> vixey: what
09:16:05 <vixey> what am I expecting it do to
09:19:00 <Will\home> how about making a list unique? :)
09:20:18 <mauke> > nub "Will\\home"
09:20:19 <lambdabot>   "Wil\\home"
09:20:34 <Will\home> hmm, that's not quite what I need actually
09:20:35 <mauke> > nub [1,2,2,3,2,2,3,3,4,2,4]
09:20:36 <lambdabot>   [1,2,3,4]
09:21:08 <Will\home> I need \\, but I want all instances of the elements removed, so [1,2,2,3] \\ [2] would give [1,3]
09:21:11 <Will\home> if you will
09:21:38 <BONUS> you can nub it first
09:21:44 <BONUS> > nub [1,2,2,3] \\ [2]
09:21:45 <lambdabot>   [1,3]
09:21:52 <BONUS> or turn it into a Set first
09:21:58 <Will\home> but I'd want [1,1,2,2,3] \\ [2] to give [1,1,3]
09:22:04 <BONUS> oh
09:22:05 <BONUS> hmm
09:22:14 <sclv>  then you can just write the function...
09:22:30 <mauke> > filter (`notElem` [2]) [1,1,2,2,3]
09:22:31 <lambdabot>   [1,1,3]
09:22:39 <mauke> might want to turn [2] into a set first
09:23:27 <sclv> ?src \\
09:23:27 <lambdabot> (\\) = foldl (flip delete)
09:23:42 <mauke> > deleteFirstsBy (==) [1,1,2,2,3] [2]
09:23:43 <lambdabot>   [1,1,2,3]
09:23:51 <mauke> what
09:23:59 <Will\home> I think the filter got it
09:24:01 <mauke> oh, I see
09:30:55 <ivanm> Cale: ummmm..... how do I convert a CReal back to a double?
09:31:29 <vixey> hi dolio
09:32:00 <dolio> Hey.
09:32:00 <lambdabot> dolio: You have 1 new message. '/msg lambdabot @messages' to read it.
09:32:14 <dolio> I found \neg. I tabbed through the entire list of codes to find it.
09:32:33 <vixey> Agda is like 100x slower than Coq :(
09:32:46 <vixey> except I don't know how to do do the pattern matching it does yet ..
09:32:52 <vixey> so I have to use both :p
09:33:24 <dolio> It's pretty slow.
09:33:49 <vixey> I think they should use Proof General for it, with the thing that lets you only recheck what you work on.. not the entire file
09:34:13 <dolio> It started getting pretty unbearable when I was translating the coinductive general recursion paper.
09:37:20 <dolio> I started splitting it into several files, since I think that lets it not recheck everything, but that was pretty painful, too.
09:38:29 <gchin> Hi, I'm trying to find a millisecond or better resolution timer in haskell, but I don't see anything in the GHC libraries. Does anyone know of an appropriate library?
09:38:47 <vixey> dolio: did you do IO with general recursion?
09:38:54 <mauke> gchin: like threadDelay?
09:39:04 <vixey> I couldn't shoehorn IO into the monad
09:39:36 <dolio> No, I was just translating all the proofs from the paper. And I never completed them all.
09:39:45 <vixey> ok
09:39:59 <gchin> mauke: I'm trying to measure how long a function is taking, not sleeping a thread
09:40:00 <vixey> I tried in haskell to get that coinductive monad + IO but LFPs wouldn't terminate
09:40:12 <vixey> probably something silly I did but I ccouldn't see how to resolve it
09:40:16 <Cale> ivanm: Oh, that's unfortunate. The instance of Real for CReal is fake...
09:40:47 <ivanm> yeah, I noticed :s
09:40:51 <dolio> @src Real
09:40:52 <lambdabot> class  (Num a, Ord a) => Real a  where
09:40:52 <lambdabot>     toRational      ::  a -> Rational
09:41:00 <ivanm> oh well, with that filtering plain old Double seems to do well enough
09:41:11 <Cale> That's true, it should.
09:41:32 <Cale> Otherwise, I would recommend going via Integer, using round.
09:41:32 <ivanm> except that I'm getting some infs :s
09:42:05 <mauke> gchin: look at Data.Time.Clock or Data.Time.Clock.POSIX
09:42:43 <Cale> :t (/10^4) . fromIntegral . round . (*10^4) :: CReal -> Double
09:42:44 <lambdabot> CReal -> Double
09:44:22 <gchin> mauke: I've taken a look at both, but they seem to only offer resolution on the order of 1 second unless I'm mistaken
09:44:42 <mauke> data DiffTime - This is a length of time, as measured by a clock. Conversion functions will treat it as seconds. It has an accuracy of 10^-12 s.
09:45:54 <gchin> mauke: hmm, I may have overlooked that. I will try that out, thank you
09:52:01 <Saizan> gchin: if you just need it for profiling there's builtin support in the RTS
09:53:10 <camio> I just instelled Claus Reinke's vim tools for haskell. All I have to say is, wow!
09:53:24 <Zao> There's vim tools?
09:53:40 <camio> http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
09:53:45 <lambdabot> Title: Haskell mode for Vim
09:57:13 <grkz> 18:53 <camio> http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
09:57:14 <lambdabot> Title: Haskell mode for Vim
09:59:28 <camio> Hey Conal, I just discovered haskell mode for vim. It's the bomb. Something to keep in mind if you ever decide to upgrade from emacs to vim.
09:59:41 <mauke> why upgrade?
09:59:47 <mauke> you can just run vim in an emacs buffer
10:00:04 <camio> hehe
10:00:18 <mauke> EXPERT EMACS USER
10:00:21 <camio> That would be absolutely vile.
10:00:44 <mauke> .oO( pedrobear )
10:02:07 <pedrob> mauke: is that  for me?
10:02:32 <mauke> it's for no one, really
10:08:06 <luqui> camio, I'm getting pwned by haskellmode
10:08:12 <luqui> nothing seems to work...
10:09:30 <camio> luqui: Do you have vim 7.1?
10:09:42 <camio> Or 7.2 rather?
10:09:44 <luqui> ohh! I know what's going on.
10:09:55 <luqui> stuff like "Missing Braces Haddock90
10:10:01 <luqui> it's because of my stupid remapping
10:10:13 <luqui> (1 <-> !, 2 <-> @, etc.)
10:10:17 <mauke> heh, you too?
10:10:29 <camio> You do need to do something in your vimrc to not get a haddock error.
10:10:33 <luqui> yeah, it's great, isn't it?
10:10:38 <mauke> yep!
10:10:40 <luqui> camio, yeah, I already set the browser
10:10:49 <camio> What's that mapping about?
10:11:04 <camio> Flipping the number keys and their shift's?
10:11:08 <luqui> yep
10:11:16 <camio> interesting
10:11:52 <luqui> hmm, I wonder if there's a better way to do that remapping so it doesn't fsck with everything
10:12:17 <luqui> really it's because vim has such a terrible config language =/
10:13:56 <lament> hey, at least it's not a lisp!
10:14:12 <mauke> I'd prefer a lisp (as long as it's not elisp)
10:16:17 <mopped> With pattern matching, should all the = be aligned via tabs?
10:16:46 <mauke> no
10:16:48 * sclv awaits the era of a truly *awesome*  Yi
10:16:53 <mauke> nothing should ever be aligned with tabs
10:17:01 <mopped> hm?
10:17:16 <mauke> alignement is done with spaces
10:17:21 <mauke> s/nem/nm/
10:17:25 <mopped> ok
10:17:42 <mauke> aligning the = is a matter of personal style
10:17:43 <vixey> mopped: You don't have to align them at all, but in general putting tabs in your code is a horrible idea
10:17:58 <mopped> I'm sorry, my tab does 8 spaces, is that ok? :P
10:18:14 <mopped> but, why is tab a bad idea anyway?
10:18:16 <mauke> only if it really inserts spaces
10:18:20 <mopped> it does
10:18:55 <dolio> Tab is bad if your editor displays it as something other than 8 spaces, because the compiler will assume it's 8.
10:18:56 <vixey> then it's spacess not "cab"
10:19:00 <vixey> "tab"*
10:19:59 <binarybandit> mopped, as long as you're really using soft-tabs, anything goes.
10:20:05 <rwbarton> I would love to have an editor with haskell-aware "electric tabstops"
10:20:24 <lament> emacs?
10:20:31 <mopped> is it 'ok' to do [x:xs:xss] as well?
10:20:42 <vixey> mopped: what's that supposed to be
10:20:58 <vixey> :t [?x:?xs:?xss]
10:21:00 <lambdabot> Not in scope: data constructor `:?'
10:21:00 <lambdabot> Not in scope: `xs'
10:21:00 <lambdabot> Not in scope: data constructor `:?'
10:21:05 <vixey> :t [?x : ?xs : ?xss]
10:21:06 <lambdabot> forall a. (?xss::[a], ?xs::a, ?x::a) => [[a]]
10:21:19 <BONUS_> maybe you mean pattern matching on (x:xs:xxs) ?
10:21:26 <luqui> so wrong.  compiler should not assume tab = 8 spaces!
10:21:27 <mopped> yeah, sorry
10:21:28 <rwbarton> I mean http://nickgravgaard.com/elastictabstops/ ; emacs doesn't do this
10:21:29 <lambdabot> Title: Elastic tabstops - a better way to indent and align code
10:21:40 <rwbarton> It looks really nice in a proportional font with unicode and everything
10:21:42 <BONUS_> > let f (x:y:ys) = y:x:ys in f [1,2,3]
10:21:43 <lambdabot>   [2,1,3]
10:21:44 <vixey> x:y:zs
10:21:59 <mopped> thanks
10:22:41 <dolio> The compiler should throw errors for tabs. :)
10:24:20 <luqui> camio, oh, part of haskellmode woe.  :make does not work as advertised; it looks for a Makefile
10:24:48 <mauke> luqui: http://mauke.ath.cx/stuff/haskell/Makefile
10:25:27 <luqui> mauke, uh, no, in haskellmode it says :make will load the current file into ghci
10:25:31 <mauke> oh
10:33:59 <rwbarton> Does the free monad on a functor in general have a corresponding monad transformer?
10:36:45 <dolio> Monad transformers aren't exactly founded in theory.
10:37:20 <rwbarton> Fair enough.  But there are some special cases that are well-understood
10:38:57 <rwbarton> Like, I can "make m into a monad transformer" with a sufficiently nice natural transformation m n -> n m for every n
10:39:21 <dolio> Yeah.
10:40:30 <rwbarton> And if m is free on f, that's the same as a map of functors f n -> n m... I should work out what that "sufficiently nice" condition translates into
10:41:00 <Saizan> uhm, given Free f = f (Free f a) + a, Functor f, Monad m it looks like you can write a monad instance for Free (m . f)
10:41:05 <rwbarton> Well, maybe it's not the same
10:41:30 <rwbarton> Ah really?
10:41:52 <rwbarton> Well sure, but I wanted m . Free f
10:41:59 <Baughn> "data Flag = Broadcast deriving (Show,Eq)" <-- Why do I even bother?
10:42:09 <vixey> heh
10:42:33 <rwbarton> Actually, I seem to recall reading about this
10:44:15 * Saizan realizes that what he wrote is completely obvious from m being a functor too
10:45:26 <Baughn> @. pl undo do a <- get; case a of 1 -> Foo; 2 -> Bar
10:45:26 <lambdabot> (line 1, column 26):
10:45:26 <lambdabot> unexpected "{"
10:45:26 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
10:45:43 <Baughn> @undo do a <- get; case a of 1 -> Foo; 2 -> Bar
10:45:44 <lambdabot> get >>= \ a -> case a of { 1 -> Foo; 2 -> Bar}
10:45:57 <rwbarton> Hmm, really I should just check whether this is in category-extras or not :P
10:46:18 <Baughn> @pl get >>= \a -> case a of 1 -> Foo; 2 -> Bar
10:46:19 <lambdabot> (line 1, column 27):
10:46:19 <lambdabot> unexpected ">" or "-"
10:46:19 <lambdabot> expecting variable, "(", operator, ">>", ">>=", "=<<", ">>>", "^>>", "^<<" or end of input
10:46:21 <dolio> Heh. It may well be.
10:47:18 <nicknull> my biggest gripewith haskell is datastructures. did it take along time for you guys to learn to handle that? like in python, dicts/maps have like 10 operations, very convenient . Map in haskell has what, 50? and many are just lsight versions of each other. i just find the concept of non-destructive updates on datstructures(except for lists)hard to deal with. yes perhaps most cells in ym body has been replaced and maybe i conside rmyself
10:47:32 <gchin> Hmm.. is there a faster way to remove the last element of a list than: take (length list - 1) list ?
10:47:42 <vixey> nicknull: How interesting
10:47:43 <Heffalump> @type init
10:47:44 <lambdabot> forall a. [a] -> [a]
10:47:56 <Heffalump> that does it too, and it uses a slightly faster (probably) definition
10:47:58 <Heffalump> @src init
10:47:58 <lambdabot> init [x]    = []
10:47:58 <lambdabot> init (x:xs) = x : init xs
10:47:58 <lambdabot> init []     = undefined
10:47:59 <nicknull> vixey: how ironic one can be
10:48:01 <Baughn> nicknull: Yep, but reading Okasaki's paper helped me understand a lot
10:48:25 <rwbarton> Possibly much faster, depending on how the list is generated and consumed
10:48:29 <Baughn> nicknull: And then I discovered the Edison libraries which amplify Data.Map's issues tenfold. ;)
10:48:58 <gchin> ah, nevermind, init does what I want
10:49:33 <thoughtpolice> i should get a copy of okasaki's book
10:49:39 <Baughn> nicknull: You actually do need a more complex interface to persistent structures in haskell, however. For example, there's the find-element-and-change-if-found-otherwise-insert-new-value function - if we didn't have it, we'd need to traverse the map twice to do that, where an imperative language might use a pointer
10:49:53 <Baughn> thoughtpolice: There's a pdf on the internet. (Well, it's a PhD..)
10:52:10 <xxxxx> hi all
10:54:13 <Saizan> hi
10:55:04 <jethr0> hi quintuple-x
11:05:27 <nicknull> found it
11:09:38 * byorgey cooks bacon, eggs, and lambda-toast
11:09:59 <r3m0t> λ-toast, eh?
11:11:53 <Gilly> anyone know a solution for this hpaste (on compiling Agda): http://hpaste.org/5387 (I'm getting the same error)
11:12:52 <dolio> Are you building from a darcs checkout?
11:13:40 <Gilly> no, a release
11:13:42 <Gilly> 2.1.2
11:13:55 <dolio> Oh. Build from darcs. I'm pretty sure the release is oooooold.
11:14:07 <Gilly> ah, I see. thanks
11:20:51 <dons> http://www.reddit.com/r/programming/comments/77y2m/haskell_weekly_news_tutorials_a_net_bridge/
11:20:54 <lambdabot> Title: Haskell Weekly News: tutorials, a .NET bridge, networking, ghc 6.10 : programmin ..., http://tinyurl.com/6ps6wk
11:20:55 <dons> good work byorgey
11:21:43 <byorgey> thanks dons
11:22:14 <byorgey> yeah, the .NET bridge is exciting
11:22:24 <byorgey> not from a personal point of view, but in general =)
11:22:56 <mopped> > Nothing
11:22:57 <lambdabot>   Nothing
11:23:04 <dolio> Maybe that can save Haskell in the future by making use fo the OMG concurrent garbage collector.
11:23:52 <mopped> Can explain explain what Maybe/Just is/used for?
11:23:55 <Heffalump> dolio: :-)
11:24:06 <byorgey> OMG?
11:24:11 * byorgey imagines a concurrent garbage collector which every now and then goes "OMG! OUT OF MEMORY!"
11:24:13 <vixey> mopped: One use is for programming in a context where you can just totally give up at some point
11:24:28 <dolio> Hah.
11:24:56 <byorgey> mopped: basically, it lets you add a special null value (called "Nothing") to any type
11:25:15 <byorgey> for example, if you have a value of type Integer, it could be 3, 6, 19, and so on
11:25:34 <int-e> Oh, things a garbage collector could say. Hmm. "What a mess, you can clean that up yourself. I'm outta here."
11:25:36 <byorgey> but if you have a value of type Maybe Integer, it could be any of those (with a Just in front of it --- Just 3, Just 6, etc.) OR it could be Nothing
11:25:55 <mauke> optional values
11:26:15 <byorgey> mopped: using something like Maybe Integer would make sense, for example, as the return type of a function which returns an Integer but MIGHT fail for some reason
11:26:24 <mopped> aha
11:26:40 <mopped> would thinks such as :: [a] -> Maybe a, make sense at all?
11:26:47 <byorgey> mopped: sure!
11:26:47 <vixey> yes
11:27:05 <byorgey> that could be the type of, say, the safeHead function
11:27:13 <Baughn> mopped: In fact, such a function exists
11:27:23 <Baughn> > listToMaybe [2,3]
11:27:24 <lambdabot>   Just 2
11:27:37 <byorgey> oh, yes, safeHead is called listToMaybe =)
11:27:53 <mauke> preflex: quote NineVolt
11:27:53 <preflex>  <NineVolt> the one beef i have with the perl community is the whole "don't do it yourself, there's already a module you can use!" mentality.
11:27:57 <byorgey> > listToMaybe []
11:27:58 <lambdabot>   Nothing
11:28:16 <Baughn> byorgey: ..yes, but that one's implicit in the type signature
11:28:27 <Baughn> Without any as, you can't return a Just
11:28:28 <mopped> I understand Maybe in type declarations and so on, but what about Just in regular functions, what's that about
11:28:41 <byorgey> Baughn: hm?
11:29:01 <byorgey> mopped: Just and Nothing are how you make a value of a Maybe type
11:29:01 <Heffalump> mopped: Just x where x has type a constructs a value of type Maybe a
11:29:03 <Baughn> mopped: Same thing. Just is one constructor for Maybe; Nothing is the other.
11:29:14 <byorgey> mopped: for example,  Just 3 :: Maybe Int
11:29:26 <byorgey> @src Maybe
11:29:26 <lambdabot> data Maybe a = Nothing | Just a
11:29:33 <byorgey> see?
11:29:51 <Baughn> @type Just 2
11:29:52 <lambdabot> forall t. (Num t) => Maybe t
11:30:01 <Baughn> @type Just (2 :: Word8) -- Whoops
11:30:03 <lambdabot> Maybe Word8
11:30:58 <vixey> mopped: Imagine you have some area you want to search around in, and you are looking for something specific - so search :: TreasureMap -> Maybe Gold, you can  have  search (X gold) = Just gold ; search Beach = None ; search (Islands north south east west) = search north `mplus` search south ...
11:32:16 <vixey> s/None/Nothing/
11:32:36 <Baughn> Of course, a Maybe is a lot like a list that's limited to zero or one elements
11:32:41 <mopped> If one was pattern matching a 'safeSecond' or so, so it was safeSecond :: [a] -> Maybe a, safeSecond (_:x:_) = Just y, safeSecond _ = Nothing
11:32:51 <mopped> What does the Just part acctualy do?
11:33:03 <mauke> construct a value of type Maybe a
11:33:08 <mauke> :t Just
11:33:09 <lambdabot> forall a. a -> Maybe a
11:33:29 <Baughn> mopped: Are you familiar with any other languages?
11:33:32 <vixey> mopped: Can you imagine what:   safeSecond (_:x:_) = y; safeSecond _ = Nothing  means
11:33:32 <mopped> Python
11:33:40 <mopped> srry, I meant Just x* :p
11:33:58 <mopped> Well, if there IS a second element, it returns y, else it returns Nothing
11:34:00 <mopped> _ is a wildcard, right?
11:34:32 <Baughn> mopped: So.. of course these aren't at all classes, but you could (if you want to confuse yourself) think of Maybe as a class, and Just and Nothing as the (only) two functions capable of making instances of that class
11:34:52 <Baughn> mopped: Of course, then we have to get into parametric polymorphism. It's a bad explanation, I'm afraid.
11:35:11 <mopped> Ok, so perhaps it's best to ask why is it better to have Just y, so i'm able to serve Nothing aswell?
11:35:34 <Baughn> There's no point in returning Just x if you never, ever return Nothing instead
11:35:52 <Baughn> ..unless you have good reason to think you will at some point in the future
11:35:53 <mopped> alright I understand
11:35:53 <lament> mopped: you know how in python there's None...
11:36:00 <mopped> I guess I was comparing it to None
11:36:06 <mopped> in that it's always there, not of a specific type etc :P
11:36:12 <Baughn> mopped: Yeah. It's not at all None.
11:36:27 <lament> it's the equivalent of None in a statically typed setting
11:36:27 <Baughn> mopped: Maybe is just a normal data-type; there's absolutely nothing special about it.
11:36:42 <Baughn> lament: Wouldn'T the equivalent of None be |_|?
11:37:09 <lament> maybe it would if haskell had it
11:37:10 <Baughn> No, I suppose not..
11:37:13 <nicknull> what languages would haskell best replace? c++ and java?
11:37:20 <BONUS_> all of them
11:37:28 <Baughn> nicknull: IMO, anything but low-level C/assembly code
11:37:40 <mauke> .oO( Harpy )
11:38:33 <Baughn> ..that's an assembler. I don't doubt it's useful, but you won't exactly be writing in haskell
11:38:43 <Baughn> Eheh
11:38:52 <Baughn> But that does mean haskell makes a dandy assembler as well. :P
11:39:37 <Baughn> mopped: Okay. We don't have an equivalent of None, in the "can be used as member of /any/ type" sense
11:40:01 <mauke> because explicit is better than implicit!
11:40:01 <Baughn> mopped: There is bottom, but you can't compare against it or otherwise use it as a value; it's simply an exception
11:40:26 <Baughn> mopped: Maybe covers most of the use cases for None, however. You can add None to a type t by using Maybe t instead of a bare t
11:40:39 <mopped> sure, i understand
11:40:49 <mopped> and bottom is uh _|_?
11:40:56 <Samy> haha
11:40:59 <Baughn> ..yeah. I mistyped earlier
11:41:00 <Samy> Harpy is veryinteresting
11:41:07 <Baughn> Which is not actually valid syntax, mind you
11:41:42 <Baughn> lament: Which brings up an interesting point. Given that I asked meant _|_, what does |_| mean?
11:42:51 <lament> double bottom? It's apparently a ship construction method
11:43:32 <idnar> hahaha
11:43:37 <Baughn> Google is unsurprisingly unhelpful
11:44:10 <mauke> (_|_)
11:45:03 <dons> http://archhaskell.wordpress.com/2008/10/18/arch-haskell-news-oct-18-2008/
11:45:05 <lambdabot> Title: Arch Haskell News: Oct 18 2008 « Arch Linux and Haskell, http://tinyurl.com/6cndm9
11:47:31 <roxy_> is there a s3 library ?
11:47:57 <dons> yeah
11:48:26 <roxy_> all the link from there http://blog.gregheartsfield.com/2007/09/23/haskell-s3-library/#comments are dead
11:48:28 <lambdabot> Title: Haskell S3 Library, http://tinyurl.com/56ooqx
11:49:35 <roxy_> oops, I just need to say so and they become alive ...
11:50:01 <roxy_> kind of answered my question
11:50:10 <dons> it's on hackage, afaik
11:51:54 <lispy> hey everybody
11:52:17 <lispy> how's it going?
11:52:26 <lispy> we shipping lots of code today or what?
11:52:59 <pcc1> > let x = 1 where in x
11:53:00 <lambdabot>   1
11:53:18 <pcc1> > 1 where
11:53:20 <lambdabot>   1
11:53:33 <lispy> whoa
11:53:35 <lispy> that's weird
11:53:41 <mauke> > 1 where where where
11:53:42 <lambdabot>   <no location info>: parse error on input `where'
11:53:45 <mauke> :(
11:53:56 <lispy> GHCi> 1 where
11:53:56 <lispy> <interactive>:1:2: parse error on input `where'
11:54:06 <lispy> bug in mueval?
11:54:19 <mauke> misbug?
11:54:21 <Samy> mauke, how do I add a PoppaVic quote to preflex?
11:54:31 <mauke> preflex: help remember
11:54:31 <preflex>  remember NAME QUOTE - associate QUOTE with NAME
11:54:54 <Samy> preflex, remember PoppaVic does your C code care if you are Arab? ;-)
11:55:08 <mauke> yep
11:56:29 <lispy> > let x = 1 where in x where
11:56:30 <lambdabot>   1
11:57:12 <lispy> > let x = 1 where in x where where
11:57:13 <lambdabot>   <no location info>: parse error on input `where'
11:57:22 <lispy> So why is that one a parse error?
11:57:28 <lispy> > where
11:57:29 <ikegami__> > let x = 1 where
11:57:29 <lambdabot>   <no location info>: parse error on input `where'
11:57:30 <lambdabot>   <no location info>: parse error on input `;'
11:57:45 <ikegami__> hm
11:57:53 <Saizan> , 1 where
11:57:57 <lunabot>  luna: parse error on input `where'
11:58:05 <lament> Double bottoms are significantly safer than single bottoms. In case of grounding or other underwater damage, most of the time the damage is limited to flooding the bottom compartment, and the main occupied areas of the ship remain intact. For this reason, double bottoms have been required in all passenger ships for decades.
11:58:40 <lispy> > let safeError = error error "oh no!"
11:58:41 <lambdabot>   <no location info>: parse error on input `;'
11:58:47 <rwbarton> "1 where" should not be a valid expression; all of lambdabot's other judgements seem right to me
11:58:48 <lispy> > let safeError = error error "oh no!" in safeError "pizza"
11:58:49 <lambdabot>   Couldn't match expected type `[Char]'
11:59:24 <lispy> > let x = 1 where in x where -- rwbarton including this one?
11:59:25 <lambdabot>   1
11:59:48 <rwbarton> well, all the "<valid expression> where" ones are wrong
12:00:06 <lispy> right, but then why does putting one more where fix it?
12:00:21 <lispy> fix it == makes it invalid
12:00:31 <jethr0_> > let x = 1 where in x
12:00:32 <lambdabot>   1
12:00:33 <rwbarton> Well, it *should* be invalid, so who knows.
12:00:38 <mauke> because you can't attach 'where' to 'where'
12:00:45 <jethr0_> maybe the parser sees both as empty where clauses
12:01:00 <jethr0_> > 1 where
12:01:01 <lambdabot>   1
12:01:07 <lispy> > let safeError = error (error "oh noes!") :: String -> a in safeError "pizza"
12:01:09 <lambdabot>   * Exception: oh noes!
12:01:09 <rwbarton> > (1 where) where
12:01:10 <lambdabot>   <no location info>: parse error on input `where'
12:01:41 <rwbarton> > "foo") where bar = ("bar"
12:01:42 <lambdabot>   <no location info>: parse error on input `)'
12:01:51 <lispy> lament: I don't buy this double bottom being safer ;)
12:01:59 <jethr0_> rwbarton: "where" cannot be used within parens
12:02:03 <rwbarton> I know
12:02:20 <rwbarton> I guess it was unlikely that lambdabot would get that wrong.
12:02:44 <jethr0_> seem to be legal to have empty where clauses...
12:03:04 <rwbarton> sure
12:03:08 <Saizan> let x = 1 where in x works in ghci too
12:03:39 <rwbarton> It looks as though lambdabot is embedding your code in   let val = ... in print val
12:03:53 <jethr0_> rwbarton: yes, something like that
12:03:58 <rwbarton> > x where x = 1
12:03:59 <lambdabot>   1
12:04:06 <lispy> yup
12:04:08 <lispy> that works
12:04:09 <mopped> If a function is formed in a way such as f x | if x == 1 = "One" | if x == 2 = "Two" | otherwise "etc", what is this 'called' and how vital is whitespace here?
12:04:19 <jethr0_> > data X = Hello Int
12:04:20 <lambdabot>   <no location info>: parse error on input `data'
12:04:28 <rwbarton> mopped: a syntax error :P
12:04:29 <mauke> mopped: guards, and whitespace doesn't really matter
12:04:38 <rwbarton> get rid of 'if'
12:04:47 <mopped> aha, without the ifs!
12:04:53 <lispy> mopped: not to be confused with pattern guards or the monadic function guard
12:04:59 <mauke> > let f x | x == 1 = "One" | x == 2 = "Two" | otherwise = "etc" in f 2
12:05:00 <lambdabot>   "Two"
12:05:07 <jethr0_> mauke: isn't it necessary to let the guards start on new lines?
12:05:14 <jethr0_> k, never mind
12:05:24 <jethr0_> not very readable though ^_^
12:06:09 <mmorrow> > let f x|x==1="One"|x==2="Two"|otherwise="etc"in f 2
12:06:13 <lambdabot>   "Two"
12:06:26 <dons> ibid: http://archhaskell.wordpress.com/feed/ please.
12:06:42 <cjay> I always felt the "==" looked more significant than the "=", even though it isn't
12:06:58 <mauke> > let{f(x)|x==1="One"|x==2="Two"|otherwise="etc"}in(f(2))  -- ah, beautiful
12:06:59 <lambdabot>   "Two"
12:07:07 <mauke> who needs whitespace anyway
12:07:31 <cjay> the whitespace programmer
12:07:32 <dons> cute http://www.reddit.com/r/programming/comments/77y9c/pretty_printing_code_with_markup/
12:07:34 <lambdabot> Title: Pretty Printing Code with Markup : programming, http://tinyurl.com/5t8jox
12:09:04 <Heffalump> how do you pretty print to HTML anyway?
12:10:36 <vixey> paste.lisp.org
12:10:56 <vixey> that's the best HTML
12:11:59 <Heffalump> I mean from code.
12:12:10 <vixey> the source code for printing that out is on that site
12:12:12 <Heffalump> If you are using a pretty printing library, how do you render its output in HTML.
12:12:24 <vixey> oh in haskell...
12:12:47 <Heffalump> I don't want specific code, I want to understand the general approach and how Andy's new library (the pretty printing with markup above) fits in with that
12:13:15 <Samy> mauke, are my quotes added?
12:13:35 <mauke> Samy: the PoppaVic one, yes
12:13:53 <lispy> Heffalump: I'm still not sure I understand what you mean.  Don't you write combinators on top of his mark function that insert the html tags and then render using those?
12:14:20 <ibid> dons: email, please
12:14:25 <Heffalump> lispy: his mark function helps with doing stuff like colours
12:14:44 <Heffalump> but how do you get HTML that produces the same layout (indentation etc) as the pretty printing combinators would make in ASCII
12:15:48 <lispy> Heffalump: wait, do you mean you want to feed it HTML and have it do an approximate rendering as plaintext?
12:16:08 <Heffalump> no, the reverse
12:16:12 <Samy> mauke, I added 3 more
12:16:20 <mauke> Samy: in private?
12:16:22 <lispy> Heffalump: ah
12:16:27 <Samy> mauke, yes
12:16:27 <Heffalump> pretty printing combinators figure out how to add indentation and line breaks to make nice-looking ASCII
12:16:50 <mauke> Samy: that should have worked (unless you mistyped 'remember')
12:16:51 <Heffalump> if you want HTML that renders in a similar way, you have to do something completely different
12:17:16 <nicknull> is there a basic webapp-lib besides happs?
12:17:28 <Samy> mauke, yes, I did that to 1 :-P
12:17:36 <Dianora> you lot can blame Samy for me being here.
12:17:38 <dons> ibid: i thought i did a month ago :/
12:17:41 <Dianora> quite someone! quote it!
12:17:45 <Dianora> quick
12:18:22 <lispy> nicknull: depending on what functionality you need/what there is HSP, WASH, HAppsS, and one other one on the tip of my tongue
12:18:54 <mauke> hi, Dianora
12:19:23 <lispy> nicknull: oh. the other one is Janus, but it's harder to find just a sec
12:21:18 <lispy> nicknull: http://darcs2.fh-wedel.de/repos/janus/
12:21:21 <lambdabot> Title: Index of /repos/janus
12:21:46 <lispy> nicknull: my completely uneducated guess is that janus is the most similar in features to HAppS.  I could be completely and utterly wrong.
12:21:54 <lispy> nicknull: but it's ued by the hayoo people
12:22:36 * lispy wonders if nicknull sees anything he is saying
12:25:13 <mmorrow> HERA++
12:25:16 <mopped> What does   No instance for (Fractional Integer) mean, and how can I fix it? ;)
12:25:24 <mopped> (I'm trying to divide two Integers)
12:25:37 <heatsink> mopped: use div for floor division
12:25:50 <gio123>  Lets E be a reg expression and l(E) denotes number of distinct derivateves of E wrt all reg expressions. can somebody told me whether this hold l(E*)=<2l(E)
12:26:08 <mopped> I don't want floor division, I used fromIntegral to covert the integer to floats before hand
12:26:17 <heatsink> mopped: The (/) operator divides data types that approximate rational or real numbers.
12:26:25 <lispy> gio123: how does l(E) work?
12:26:26 <heatsink> oh.  Then use fromIntegral.
12:26:40 <mopped> myMean l        =       (fromIntegral (mySum l)) / (fromIntegral (myLength l))
12:26:47 <Baughn> > fromIntegral `on` (/) $ (2::Int) (3::Int)
12:26:48 <lambdabot>       precedence parsing error
12:26:48 <lambdabot>          cannot mix `on' [infixl 0] and `($)' ...
12:26:53 <byorgey> mopped: what is the type of myMean?
12:26:57 <heatsink> It might be inferring an integral type for the result of myMean.
12:26:58 <Baughn> > (fromIntegral `on` (/)) (2::Int) (3::Int)
12:26:59 <lambdabot>       No instances for (Num ((Int -> Int) -> c), Integral (Int -> Int))
12:27:00 <lambdabot>      ...
12:27:06 <mopped> ah, [Integer] -> Integer
12:27:07 <byorgey> mopped: if the output of myMean is supposed to be Integer, that could cause the error
12:27:11 <byorgey> yup =)
12:27:21 <heatsink> > ((/) `on` fromIntegral) (2::int) (3::Int)
12:27:22 <mopped> what should it be, Decimal?
12:27:22 <lambdabot>       Could not deduce (Num int) from the context ()
12:27:23 <lambdabot>        arising from the ...
12:27:26 <byorgey> mopped: Double
12:27:39 <papermachine> :t on
12:27:40 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
12:27:43 <byorgey> mopped: or Rational, if you want to be slightly fancier (import Data.Ratio)
12:27:46 <mopped> Am I able to have 'or' in type declarations? so I could have [Integer or Double] or so :P
12:27:57 <Baughn> mopped: Either
12:27:58 <rwbarton> No.
12:28:06 <mauke> mopped: (Num a) => a
12:28:08 <Baughn> [Either Integer Double]
12:28:38 <Peaker> @src Either
12:28:38 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:28:42 <byorgey> mopped: use Rational, then it will be exact
12:28:51 <Peaker> No @src for Either?
12:28:52 <Baughn> mopped: Of course, / can only return fractionals, so it'd be mymean :: b -> Fractional a => a
12:28:54 <byorgey> and you can even check to see if it's an integer (denominator r == 1)
12:28:56 <rwbarton> , src ''Either
12:29:06 <lunabot>  data Either a b = Left a | Right b
12:29:35 <rwbarton> > let mymean :: b -> Fractional a => a; mymean = undefined in mymean
12:29:36 <lambdabot>       Overlapping instances for Show (b -> a)
12:29:36 <lambdabot>        arising from a use of `s...
12:29:45 <rwbarton> Huh, didn't know that was legal.
12:30:34 <mopped> What does the => part mean mauke (as opposed to ->)
12:30:35 <Peaker> rwbarton: what's the '' about?
12:30:46 <ddarius> rwbarton: I don't believe it is in Haskell 98.
12:30:48 <rwbarton> Peaker: It's a template haskell thing
12:30:49 <mauke> mopped: (class constraints) => type
12:31:02 <mauke> mopped: -> is part of the type
12:31:08 <ddarius> rwbarton: However, it doesn't mean anything new unless you use other features not in Haskell 98.
12:31:09 <Peaker> mopped: Class type_variable => expression using type variable    it means that type_variable implements the Class, in the type expression on the right
12:31:13 <rwbarton> ddarius: Right.
12:31:30 <rwbarton> ddarius: Yeah, hugs doesn't like it in haskell 98 mode.
12:31:31 <Baughn> rwbarton: I got the order wrong
12:31:45 <dolio> rwbarton: Doesn't work in ghci without flags. I suspect it's lambdabot's -fglasgow-exts.
12:31:46 <Peaker> mopped: => is not very similar to -> at all.  a->b is just the type of a function from a to b.  => separates the class constraints from the type expression
12:31:46 <Baughn> It's supposed to be Fractional a => b -> a, of course
12:31:57 <dolio> More specifically, the error message talks about -XFlexibleContexts.
12:32:11 <gio123> lispy: l(F) is  works as follows 1) compute derivatives of E wrt regular expressions(set of words), start do derivative E wrt to elements of this set and compaier each derivatives with privious, if it is same as is computed already stop computation if not continue while same derivative is computed. count number of deference derivatives. that is l(F)
12:32:12 <mopped> Perhaps i'm too new to know about class constraints (or maybe i've already forgotten!)
12:32:26 <Cale> There is a slight similarity though, in that class contexts are a bit like implicit parameters.
12:33:17 <gio123> Cale: hi
12:33:46 <Cale> Where (Ord a) means that you have a record full of Ord operations for the type a
12:33:51 <Peaker> mopped: a class constraint says: This type variable cannot be _any_ type you wish, but only types that have an instance of a particular class
12:33:53 <lispy> gio123: for a given regular expression, what is a derivative?  Suppose my regular expression is the 'a', what are the derivatives?
12:33:58 <dmwit> gio123: Sadly, l(E*) < 2^l(E) is about the best you can do.
12:34:17 <Cale> gio123: hello. Still working with derivatives of regular expressions?
12:34:21 <dmwit> gio123: It epsilon and the empty set.
12:34:23 <dmwit> err
12:34:26 <dmwit> @lispy
12:34:26 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
12:34:42 <gio123> lispy>:empty,lambda,a
12:35:16 <lispy> what does the regular expression lambda do?
12:35:45 <dmwit> lispy: The derivative of R with respect to w is the regular expression that matches {x | wx \in |R|}.
12:35:48 <gio123> Cale: yes, i was doing something in last months, but few days ago i got book from conway and now reading it
12:35:50 <Cale> lispy: You know the DFA <-> regular expression translation?
12:36:16 <gio123> lispy: lambda denotes empty language
12:36:24 <lispy> Cale: the translation?  I guess i've forgotten it
12:36:41 <Cale> lispy: I just mean the general idea...
12:36:42 <rwbarton> is l(E) the same as the minimum number of states in a DFA for E?
12:37:06 <lispy> Cale: yeah, you can translate to a little state machine
12:37:11 <dmwit> rwbarton: No.
12:37:16 <dmwit> rwbarton: Well.
12:37:17 <Cale> lispy: The derivatives of a regular expression correspond to DFAs which are the same as that for the original expression, but whose start state is a state reachable from the start state of the original one.
12:37:31 <dmwit> rwbarton: It depends on exactly how you define RE equivalence for recognizing repeated derivatives.
12:37:49 <lispy> Cale: oh
12:38:00 <dmwit> rwbarton: If you define equivalence to be semantic equivalence, then yes; but most of the time when you're running this algorithm you pick a looser equivalence.
12:38:12 <Cale> lispy: To put it another way, the derivative of a regular language L with respect to the word w is the language {u : wu is in L}
12:38:17 <gio123> Cale: do u know that antimiros algorithm to construct DFA is mucher effecient than conway does
12:38:50 <gio123> lispy: states of machines are just derivatives of reg expressions
12:38:54 <rwbarton> dmwit: I see
12:40:28 <gio123> Cale: antimirov does synatx checking of regular expression equality and is cheap, conway does semantic checking which is quit expencive
12:40:35 <Cale> gio123: I always just construct the NFA anyway.
12:41:05 <younder> ?users
12:41:06 <lambdabot> Maximum users seen in #haskell: 518, currently: 507 (97.9%), active: 28 (5.5%)
12:41:10 <Cale> The NFA is basically just as good for all this stuff, and is easier to work with.
12:41:21 <Cale> (at least, for me)
12:41:38 <mauke> ooh, that reminds me: I have a question about regular expressions but I don't know how to phrase it in terms of maths
12:41:57 <Cale> mauke: What is it?
12:42:15 <mauke> think about a backtracking implementation of regexes
12:42:18 <Dianora> re's == FSA personified.
12:42:46 <mauke> for every | or *, you push the current state (position in the regex, position in the input string) on a stack
12:42:55 <Cale> okay
12:43:40 <mopped> makePal' has the type [a] -> [a], but i'm getting the error:     Occurs check: cannot construct the infinite type: a = [a] When generalising the type(s) for `makePal'
12:44:00 <mauke> normally, you try the first branch, and if (later on) that causes a failure, you pop the stack to try the other branch
12:44:35 <mauke> what if you pop that saved state as soon as the first branch returns?  (hmm, this description might be unclear)
12:44:59 <Cale> mauke: Wouldn't that be just like not storing it at all?
12:45:19 <mauke> silly example: 'a' =~ /(a|)a/
12:46:00 <dmwit> mauke: I think that's not ok.  Example: a*ab.
12:46:02 <mauke> normally you'd try to match the first branch 'a' (success), then the trailing 'a' (failure, back to |), the second branch (epsilon), final 'a' (success)
12:46:20 <Cale> right
12:46:23 <mopped> http://hpaste.org/11264 Complains about 'cannot construct the infinite type: a = [a]', anyone got any tips?
12:46:38 <dmwit> hm, let me think a tad longer
12:46:41 <mauke> with my change this match would fail because the saved state is lost as soon as the first branch succeeds (= you leave the '()' pair)
12:46:45 <dmwit> Oh, yeah.
12:46:55 <mauke> similarly, /a*a/ can never match
12:47:00 <Cale> right.
12:47:13 <Cale> (so why did you push it on the stack in the first place?)
12:47:13 <mauke> my question is: are real regexes more powerful?
12:47:25 <gio123> Cale: do u have book from conway?
12:47:27 <mauke> Cale: it has to be reachable in case you fail inside the first branch
12:47:33 <dmwit> mauke: With (a*b), think about matching "ab".  You would match a* to "", then pop your stack, and the remaining "ab" in the input wouldn't match the remaining "b" in the regex.
12:47:33 <int-e> mopped: l : ... has type [[a]] if l has type [a]
12:47:57 <rwbarton> > [3] : [3]
12:47:58 <lambdabot>       No instance for (Num [t])
12:47:58 <lambdabot>        arising from the literal `3' at <inter...
12:48:00 <mauke> dmwit: no, I'd match a* to "a"
12:48:03 <Cale> mauke: ah, okay.
12:48:09 <Baughn> If I have a CAF deep in some function definition, what's the chance it'll get lifted out (and therefore not GCed)? Short of making a top-level binding of it, is there any way I can force it to be?
12:48:15 <mauke> * is greedy
12:48:16 <dmwit> mauke: Okay, so greedy * matches?  I still think you have problems.
12:48:23 <Cale> mauke: So (b|)a would still succeed?
12:48:32 <mopped> hmm, ok int-e
12:48:34 <mauke> Cale: right
12:48:37 <gio123> Cale: do u have book from conway?
12:48:44 <Cale> gio123: Which book?
12:48:58 <Cale> gio123: Also, "you"
12:49:14 <mauke> is there a regular language that can't be recognized with my modified matching algorithm?
12:49:14 <gio123> Cale: Regular algebra and finite automata
12:49:22 <Cale> gio123: I don't think so.
12:49:28 <dmwit> mauke: I think so, give me a tick.
12:49:36 <mauke> ok
12:49:38 <int-e> mopped: the code looks weird, what are you trying to do?
12:49:42 <Heffalump> it's small and blue
12:49:47 <dmwit> mauke: The problem arises when you have multiple ways to "split" a *, it'll take me a second to illustrate.
12:49:52 <gio123> Cale: Do you want to have? it is fantastic book, I have a electronic verssion
12:50:01 <mopped> makes a plaindrome out of a list so [1, 2, 3] because [1, 2, 3, 3, 2, 1]
12:50:25 <rwbarton> > let x = [1,2,3] in x ++ reverse x
12:50:26 <lambdabot>   [1,2,3,3,2,1]
12:50:27 <mauke> > ap (++) reverse [1,2,3]
12:50:28 <lambdabot>   [1,2,3,3,2,1]
12:50:32 <int-e> mopped: oh. Pal = palindrome? Why don't you use 'reverse'? And to concatenate too lists, use ++.
12:50:36 <dmwit> mopped: Check the type of (:).
12:50:40 <Heffalump> gio123: I'd like an electronic version, if it's not bootlegged
12:50:41 <mopped> ah
12:51:16 <gio123> Heffalump: do you have djvu reader?
12:51:26 <Cale> mauke: Maybe something like (ab)*(abb)* ?
12:51:42 <nicknull> is there a basic webapp-lib besides happs?
12:51:58 <Heffalump> no, but it seems to be free
12:52:03 <vixey> I think that's equal to  (ab)*(|b(ab*))  isn't it?
12:52:06 <mopped> and doh, whats the opposite to drop?
12:52:11 <mopped> pick?
12:52:15 <vixey> which can be matched by maukes algorithm(?)
12:52:15 <Baughn> nicknull: THere's Network.CGI, if you want /really/ basic
12:52:18 <rwbarton> take
12:52:48 <int-e> mauke: presumably you can take the DFA for the language and convert it to a regular expression.
12:52:49 <mopped> Is there a tidier to take all but the last n of a list rather than measuring the length of the list etc?
12:53:04 <dmwit> mauke: Try (a*ab, ab).  Then a* matches a, so you're left with (ab, b), which doesn't match.  But the whole thing ought to.
12:53:08 <Baughn> mopped: reverse . take n . reverse
12:53:08 <rwbarton> mopped: there is a clever way
12:53:27 <mauke> Cale, vixey: (ab)*(b(abb)*|) -- ?
12:53:35 <Cale> yeah
12:53:36 <int-e> Baughn: drop, not take
12:53:44 <Baughn> Hm. Yes.
12:53:52 <dmwit> The 'b' isn't even necessary. =P
12:53:52 <Cale> hmm
12:54:14 <rwbarton> > let x = [1..10] in zipWith const x (drop 3 x)   -- I forget who showed me this
12:54:15 <lambdabot>   [1,2,3,4,5,6,7]
12:54:15 <mauke> dmwit: can be a*ab can be rewritten as aa*b
12:54:22 <mopped> reverse . take n . reverse l is the same as reverse (take n (reverse l))?
12:54:28 <dmwit> mauke: Oh, sure, but you didn't say anything about rewriting, did you?
12:54:41 <dmwit> (What was the actual question?)
12:54:56 <int-e> rwbarton: heh I was just going to suggest that.
12:55:00 <Cale> dmwit: The question is whether there's a regular language which can't be matched in some way by this algorithm (with some expression)
12:55:00 <dmwit> Ah, is there a regular language that can't be matched.
12:55:03 <rwbarton> dmwit: Is there a regular language for which there's no expression which mauke's algorithm detects
12:55:05 <int-e> mopped: yes
12:55:11 <gio123> Cale: could you please look that link
12:55:18 <int-e> mopped: err. (reverse . take n . reverse) l is
12:55:29 <vixey> mauke: idk they are probably equiv. I guess, if you can turn any DFA into one your regexs that can be a proof
12:55:31 <dmwit> mauke: You can construct an unambiguous RE for any regular language.
12:55:32 <Cale> gio123: What link?
12:55:44 <int-e> mopped: (often written as  reverse . take n . reverse $ l)
12:56:12 <mauke> dmwit: what's an unambiguous RE?
12:57:00 <int-e> mauke: one where the corresponding NFA is really a DFA, I'd say.
12:57:18 <mauke> looks like I have to learn about DFAs
12:57:19 <rwbarton> dmwit: I don't know if that's sufficient, certainly you need to do some factorization at least on top of having the RE be unambiguous
12:57:27 <rwbarton> I'm assuming unambiguous = matches in only one way
12:57:44 <dmwit> hmm
12:57:52 <rwbarton> Is   ab|ac   unambiguous?
12:57:53 <dons> nice http://www.reddit.com/r/programming/comments/77yfs/fpsyd_type_level_programming_extravaganza/
12:57:56 <lambdabot> Title: fp-syd: type level programming extravaganza : programming, http://tinyurl.com/6d6llz
12:58:00 <int-e> rwbarton: oh, hmm. (a*)a is unambiguous.
12:58:18 <Cale> rwbarton: you can pull the a out as a(b|c)
12:58:23 <newsham> "Theoreticians have demonstrated that ambiguous regular expressions may be rewritten in an unambiguous way. The ambiguities may be considered merely as unlucky variations over unambiguous schemas"
12:58:25 <rwbarton> Right, hence the factoring
12:58:34 <rwbarton> But is that a finite process in general?
12:58:36 <int-e> mauke: hmm, I guess that was stronger than "unambiguous", but I think that's the property your algorithm requires to work.
12:59:42 <nicknull> would it be possible to have a program that can spot potential exponential behaviour of regexps an rewrite them to more efficient versions?
12:59:46 <gio123>  Heffalump: I am uploading
12:59:56 <mopped> isPal l         |       l == (reverse l)        = True, how come that's incorrect (and sorry for the question spam!)
13:00:11 <newsham> how about not using an exponential algorithm for matching in the first place?
13:00:14 <gio123> Cale: have you cjeck the link please? I made some coments
13:00:17 <dmwit> rwbarton, mauke: I think, using derivatives, you can construct REs that are unambiguous in the "what character matches first is unambiguous" sense.
13:00:25 <rwbarton> mopped: A little silly, but it doesn't look incorrect...
13:00:26 <int-e> mopped: incorrect how? you may be lacking an | otherwise = False
13:00:28 <Cale> gio123: What link?
13:00:46 <int-e> mopped: although you should really write   isPal l = l == reverse l
13:00:50 <rwbarton> mopped: How about   isPal l = l == reverse l
13:00:50 <dmwit> i.e. the regular expression is of the form \sum_{x\in alphabet}xR.
13:00:56 <newsham> http://swtch.com/~rsc/regexp/regexp1.html
13:00:58 <lambdabot> Title: Regular Expression Matching Can Be Simple And Fast
13:00:58 <mopped> eh true
13:01:15 <dmwit> newsham: right
13:01:47 <gio123> Cale: I pmed it to you
13:01:53 <rwbarton> dmwit: You can expand that as long as you like... and then what?
13:02:04 <mopped> and the type would be [a] -> Bool, right?
13:02:12 <rwbarton> Eq a => [a] -> Bool
13:02:18 <dmwit> rwbarton: Urk, what I'm thinking of is a different result.
13:02:21 <mopped> yeah, its complaining about that :P
13:02:25 <dmwit> Rats! This is a tricky question.
13:02:33 <dmwit> I'm going to take a nap instead of thinking about it. =P
13:02:33 <rwbarton> dmwit: I'm actually curious about this unambiguous result
13:02:46 <mopped> It's part of an exercise in real world haskell, and it hasn't talked about the => yet, so perhaps I'm meant to leave out type declarations?
13:03:14 <nicknull> newsham: how about stop being a smartass?
13:03:17 <dmwit> rwbarton: What you can actually say is there's a finite number of regexes so that R_i = \sum_x xR_{ix}, and R = R_1.
13:03:22 <newsham> nicknull: ?
13:03:28 <gio123>  Cale: do you accept pms?
13:03:51 <gio123>  Cale: or I have to paste link here?
13:03:52 <dmwit> rwbarton: (Where each R_{ix} is also one of the R_i's.)
13:03:59 <rwbarton> dmwit: Yeah.
13:04:10 <dmwit> But that doesn't help in quite the way I was hoping it would.
13:04:15 <Cale> ah, okay, I hadn't noticed it
13:04:24 <rwbarton> Right, it doesn't make something that looks like a regular expression, it looks like a DFA :)
13:04:38 <Cale> gio123: Sorry, what is this about?
13:04:40 <dmwit> yep
13:04:57 <roconnor> Cale: do you use Caleskell when writing your own haskell programs?
13:04:58 <Cale> gio123: are you asking me to proofread this or what?
13:05:03 <dmwit> Well, there is a translation from DFA to regex; I wonder if mauke's algorithm works for the resulting RE?
13:05:06 <dmwit> Wouldn't that be nice?
13:05:15 <rwbarton> mauke: This seems to be almost, but not exactly, what you're asking: http://dx.doi.org/10.1006/inco.1997.2695
13:05:18 <lambdabot> Title: ScienceDirect - Information and Computation : One-Unambiguous Regular Languages* ...
13:05:25 <Cale> roconnor: By which you mean what?
13:05:41 <nicknull> it seems impossible to install anything on ahcakge,, there is always a trillion dependencies that i dont have installed
13:05:49 <mauke> Cale: redefinition of (.) and (++)
13:05:55 <Cale> nicknull: The trick is to install cabal-install first.
13:06:02 <roconnor> what mauke said
13:06:11 <Cale> nicknull: which will download and install the dependencies automatically
13:06:12 <nicknull> and i cant install cabal-install because i cantupgr ade cabal becua ei cant install something that needs cabal-install first. ctach 22
13:06:29 <Cale> roconnor: I'll redefine those by hand if I need them.
13:07:08 <sm> hi all. Is there a way to define a helper function used by several instance methods, privately within an instance declaration ?
13:07:18 <gio123> Cale: I wrote Comparison between Conway's Algorithm and Antimirov algorithm.
13:07:20 <dmwit> nicknull: What does Cabal depend on that you don't have?
13:07:21 <newsham> nicknull: you should be able to install all of the dependencies manually
13:07:33 <Cale> roconnor: But normally importing the Prelude hiding a bunch of stuff is more work than I care for.
13:07:42 <dmwit> sm: Not really.
13:07:42 <gio123> Cale: could you please read it?
13:07:47 <Cale> gio123: Why?
13:07:53 <sm> drat. thanks dmwit
13:07:53 <Cale> gio123: Do you have a specific question?
13:07:55 <dmwit> sm: You can write it in a module, then only export the instance.
13:08:04 <sm> ok
13:08:13 <gio123> Cale: to correct of something is unclear for you or give me some comments
13:08:30 <sm> probably I can exclude it from haddock in another way
13:09:29 <mauke> haddock only lists exported symbols
13:09:39 <Cale> Why don't you get your advisor to check it?
13:10:03 <gio123> Cale: I dont have advisor
13:10:15 <gio123> Cale: I am working alone at home
13:10:17 <gio123> :)
13:10:19 <BONUS_> hmm
13:10:24 <sm> I have it showing non-exported, I'm documenting for implementors
13:10:28 <BONUS_> is it possible for a type to have a kind of (* -> *) -> *
13:10:31 <vixey> :k Mu
13:10:32 <lambdabot> (* -> *) -> *
13:10:35 <sm> I'll show this, no big deal. thanks
13:10:35 <vixey> yes
13:10:37 <BONUS_> haha
13:10:43 <BONUS_> oh yeah i totally forgot about Mu
13:10:45 <mopped> How would one use the sortBy function? (or, where can I find "help files" that show an example use of a function or so)
13:10:46 <ddarius> BONUS_: By definition types have kind *.
13:10:55 <BONUS_> yeah i mean
13:10:59 <BONUS_> type constructor
13:11:01 <mauke> BONUS_: data T f = C (f ())
13:11:04 <Cale> gio123: So you're just really driven to study derivatives of regular expressions for years on end?
13:11:08 <gio123> Cale: specific question would be how conway proofs therem "A regular event E has finitely many distinct derivatives"
13:11:14 <BONUS_> hm
13:11:16 <vixey> Cale, ahahaha
13:11:17 <ddarius> However, type constructors can have any kind able to be made with the kind constructors -> and *.
13:11:40 <dmwit> gio123: Try the Brzozowski paper on derivatives.  It's pretty easy reading, and has that proof in it.
13:11:44 <gweiqi> is anybody here familiar with the paper about extending ffi with concurrency? (and familiar with ghc's runtime)
13:12:00 <Cale> dmwit: I gave him that paper, I think it was over a year ago.
13:12:15 <rwbarton> @type sortBy
13:12:16 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
13:12:26 <rwbarton> the type is the documentation
13:12:26 <nicknull> dmwit: cabal 1.6.0.1, during runghc Setup configure i get:
13:12:27 <nicknull> During interactive linking, GHCi couldn't find the following symbol:
13:12:27 <nicknull>   SHGetFolderPathA@20
13:12:39 <rwbarton> @type compare
13:12:40 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
13:12:45 <nicknull> Alternatively, this link failure might indicate a bug in GHCi.
13:12:45 <nicknull> If you suspect the latter, please send a bug report to:
13:12:45 <nicknull>   glasgow-haskell-bugs@haskell.org
13:12:50 <Zao> nicknull: ghc --make Setup
13:13:03 <Zao> And run Setup.exe instead of 'runghc Setup'
13:13:18 <mopped> does the type tell one how to use it rwbarton?
13:13:18 <Zao> Oh, cabal. Might not be able to do that then.
13:13:19 <nicknull> ok thanks doing that now,
13:13:23 <gio123> Cale: yes, right but I didnt have time to read it
13:13:24 <dmwit> nicknull: Check the output of "ghc-pkg list" for curly braces.
13:13:29 <roconnor> Cale: yeah, that's what I figued
13:13:31 <Zao> Ah, setting up cabal itself.
13:13:33 <mauke> mopped: yes, pretty much
13:13:38 <dmwit> Zao: Why wouldn't he be able to do that?
13:13:39 <Zao> Reading comprehension is overreated, I've heard.
13:13:49 <Zao> dmwit: I thought it was while he was installing a package _using_ cabal.
13:13:54 <Cale> roconnor: Which is exactly why I'd like to see that stuff in the Prelude.
13:14:00 <dmwit> Zao: (How do you think runghc does it, if not by compiling? ;-)
13:14:01 <nicknull> i ahve cabal 1.2, tyring to install 1.6.
13:14:07 <Zao> dmwit: Tnr
13:14:11 <Zao> *Throwing it at ghci?
13:14:17 <dmwit> Zao: Same question.
13:14:20 <mopped> ok, well (a -> a -> Ordering) means what? :P
13:14:24 <Cale> roconnor: Or at least in a very convenient import which doesn't require me to import the Prelude in a special way.
13:14:25 <dmwit> Zao: What can ghci do that ghc can't?
13:14:28 <mopped> I guess ordering is GT/LT/EQ etc?
13:14:29 <Zao> One has --make?
13:14:31 <rwbarton> mopped: Ah, that is a much better question :)
13:14:35 <mauke> mopped: a function that takes two values of type 'a' and returns something of type 'Ordering'
13:14:42 <Zao> Which pulls in the right libs, like say shlwapi.
13:14:51 <rwbarton> @src Ordering
13:14:51 <lambdabot> data Ordering = LT | EQ | GT
13:14:53 <Zao> Which is what he apparently didn't pull in above.
13:15:07 <dmwit> Zao: (What I'm trying to tell you is that cabal can build without having cabal installed, or else you'd be totally hosed.)
13:15:50 <rwbarton> mopped: so for example, sortBy compare is the same as sort
13:15:53 <rwbarton> @src sort
13:15:53 <lambdabot> sort = sortBy compare
13:16:03 <Zao> dmwit: Naturally, but I can't quite see what that has to do with things.
13:16:22 * Zao goes back to smashing his head against C++ code.
13:16:36 <dmwit> Zao: You said he wouldn't be able to ghc --make cabal.  But he should be able to.  I doubt it would fix anything, though.
13:16:42 <gio123> Cale: actualy I dont need derivatives at all, what U need to have algorithm to solve E<F, where E might contain variables which can instatiated by regexps
13:17:06 <Zao> dmwit: I said that I thought that it appeared when running 'cabal install whatever'.
13:17:18 <dmwit> aah
13:17:52 <dmwit> Sorry, then. =)
13:18:10 <gweiqi> here's an easier question... is anybody familiar with how GHC moved beyond having a global lock for only running one haskell thread at a time?
13:18:49 <Zao> As for why runghc does not pull in the relevant library, I have no clue, but I've solved it in the past by compiling the Setup "proper".
13:18:49 <mopped> rwbarton: and sortBy (\x y-> compare (length x) (length y)) [[1,2], [1]] should sort subsets?
13:18:49 <dancor> @pl \((x,y),z) -> ((x,z),(y,z))
13:18:50 <lambdabot> uncurry (uncurry ((. (,)) . ap . ((,) .) . (,)))
13:19:00 <dmwit> ?users
13:19:00 <lambdabot> Maximum users seen in #haskell: 518, currently: 501 (96.7%), active: 23 (4.6%)
13:19:08 * dancor is sure this is something with sequence or arrow stuff
13:19:19 <rwbarton> mopped: looks good...
13:19:22 <vixey> mopped: comparing length = (\x y-> compare (length x) (length y))
13:19:27 <rwbarton> > sortBy (\x y-> compare (length x) (length y)) [[1,2], [1]]
13:19:28 <lambdabot>   [[1],[1,2]]
13:19:31 <Zao> It might be because of that Windows static libraries generally do not link their dependencies, but let their consumer do it.
13:19:46 <Cale> gweiqi: sounds like something there ought to be a paper on.
13:19:51 <mopped> ah vixey was going to ask if i could do it without anonymous functions, as they havnt been covered yet :P
13:19:55 <rwbarton> mopped: Yeah, there's also a convenience function 'comparing'
13:19:58 <rwbarton> @src comparing
13:19:58 <lambdabot> Source not found. I am sorry.
13:20:07 <rwbarton> :t comparing
13:20:08 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
13:20:20 <vixey> mopped: never be afriad to use something not covered thougha
13:20:22 <mauke> , src 'comparing
13:20:23 <lunabot>  luna: Not in scope: `comparing'
13:20:33 <dmwit> dancor: The explicit lambda you wrote is likely to be more readable than the equivalent arrow stuff.
13:20:41 <mauke> , src 'Data.List.comparing
13:20:43 <lunabot>  luna: Not in scope: `Data.List.comparing'
13:20:48 <mauke> er, wait
13:21:02 <dancor> dmwit: ok.  but one time i thought that and the answer later was 'sequence'
13:21:24 <Cale> gweiqi: perhaps "Haskell on a Shared-Memory Multiprocessor" will answer your question?
13:21:38 <rwbarton> , src 'Data.Ord.comparing
13:21:40 <lunabot>  luna: Not in scope: `Data.Ord.comparing'
13:21:58 <rwbarton> src is just @type anyways
13:22:01 <gio123> Cale: once you wrote derivative algorithm in haskel, do you still have it?
13:22:04 <dmwit> ?pl uncurry (\(x, y) z -> ((,) z *** (,) z) (x, y))
13:22:05 <lambdabot> uncurry (uncurry ((flip (liftM2 (***) (,) (,)) .) . (,)))
13:22:09 <Cale> gio123: yeah
13:22:22 <dmwit> ?pl uncurry (\(x, y) z -> (flip (,) z *** flip (,) z) (x, y))
13:22:23 <lambdabot> uncurry (uncurry ((flip (ap ((***) . flip (,)) (flip (,))) .) . (,)))
13:22:24 <gio123> Cale: could you give me it please?
13:22:59 <gio123> Cale: you wrote derivative or partial derivative algorithm?
13:23:01 <dmwit> oops
13:23:03 <dmwit> :t uncurry
13:23:04 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
13:23:49 <Cale> gio123: http://hpaste.org/11265
13:23:57 <Cale> er, damn.
13:24:04 <Cale> here, I'll use hpaste2
13:24:17 <Cale> (that got cut off)
13:24:18 <dancor> do ppl normally call deconstructors like \ (x:xs) -> (x, xs)  decons or uncons
13:24:45 <dmwit> That's not really a deconstructor... it just substitutes one constructor for another. =P
13:24:52 <nullified> missing zlib for cabal-install
13:24:55 <rwbarton> uncons
13:24:58 <dancor> ok
13:25:07 <mauke> uncons d _ [] = d; uncons _ f (x : xs) = f x xs
13:25:13 <rwbarton> At least, I think Parsec uses that name
13:25:18 <BONUS_> > (head &&& tail) "heyho"
13:25:19 <lambdabot>   ('h',"eyho")
13:25:19 <mopped> How can I append something to a list, say [1, 2, 3] ? 4 would result in [1, 2, 3, 4]
13:25:28 <Deewiant> > [1,2,3] ++ [4]
13:25:28 <mauke> mopped: list ++ [x]
13:25:29 <lambdabot>   [1,2,3,4]
13:25:32 <Cale> http://www.moonpatio.com:8080/fastcgi/hpaste.fcgi/view?id=203#a203
13:25:34 <BONUS_> beaten so bad
13:25:38 <gweiqi> Cale: thanks
13:26:21 <Zao> > reverse $ 4 : (reverse [1,2,3])
13:26:22 <lambdabot>   [1,2,3,4]
13:26:22 <gweiqi> is there a common repository for all these papers? somehow that one evaded my google search
13:26:28 <dmwit> nullified: cabal-install comes with a bootstrap.sh; you should just source that.
13:26:29 <gio123> Cale: no docs is proveded only code:)
13:26:30 <gweiqi> Cale: ﻿is there a common repository for all these papers? somehow that one evaded my google search
13:26:46 <Cale> gio123: That's all I wrote.
13:27:04 <gio123> Cale: ok, Thanks
13:27:07 <Cale> gweiqi: I usually check Simon's page.
13:27:28 <Cale> gweiqi: Though there's a lot linked from the Haskell Wiki.
13:27:34 <dmwit> mopped: You should keep in mind that appending is pretty slow; you should always prepend if you can.
13:27:53 <Cale> gweiqi: http://research.microsoft.com/~simonpj/ has all his more recent stuff
13:28:02 <lambdabot> Title: Simon Peyton Jones
13:28:22 <gweiqi> Cale: thanks, I should have checked there first
13:28:25 <dmwit> mopped: A pattern that I see from time to time is to write a function that builds up a backwards list using prepends, then reverses at the end.  This can take an O(n^2) algorithm down to O(n). =)
13:29:05 <Cale> Better still is to use the function trick :)
13:29:23 <lispy> dmwit: i was wondering if that trick could be used to improve Writer for the list monoid
13:29:24 <Cale> Rather than working with lists, work with functions which add some bit to the start of another list.
13:29:36 <Cale> Then composition of functions is like list concatenation
13:29:40 <BONUS_> i like Dual []
13:29:49 <Cale> and you can apply the function to [] at the end to get a normal list
13:29:57 <Deewiant> Cale: or, for simplicity, use the dlist package. :-)
13:30:02 <int-e> > concatMap (init . tails) . tail . inits $ [1..4]
13:30:03 <lambdabot>   [[1],[1,2],[2],[1,2,3],[2,3],[3],[1,2,3,4],[2,3,4],[3,4],[4]]
13:30:04 <BONUS_> > getDual $ Dual [1,2,3,4] `mappend` Dual [0]
13:30:05 <lambdabot>   [0,1,2,3,4]
13:30:09 <mopped> handy dmwit
13:30:17 <Cale> Deewiant: I dunno, it seems like a lot of work to me to import a package for that.
13:30:27 <int-e> > concatMap (tail . inits) . init . tails $ [1..4]
13:30:29 <lambdabot>   [[1],[1,2],[1,2,3],[1,2,3,4],[2],[2,3],[2,3,4],[3],[3,4],[4]]
13:30:35 <Cale> Deewiant: I have no trouble just writing things directly in terms of the functions.
13:31:06 <mopped> with pattern matching how does one know its the last item of a list (x:[])?
13:31:18 <Cale> mopped: You can pattern match with [x]
13:31:26 <int-e> dmwit: one of these is O(n^3), while the other is O(n^2) :)
13:31:27 <Deewiant> Cale: I think it's clearer to write "DL.concat" than "foldr (.) id" and whatnot, plus it's in a newtype so you don't mess things up as easily ;-)
13:31:29 <Cale> Or (x:[]), sure
13:31:41 <BONUS_> you cant pattern match for the last item of a list though
13:31:44 <dmwit> int-e: uh?
13:31:47 <Cale> Deewiant: The newtype is what bothers me.
13:32:05 <Cale> Making things verbose when they don't need to be :)
13:32:26 <Deewiant> > length "DList a" < length "[a] -> [a]"
13:32:28 <lambdabot>   True
13:32:37 <Deewiant> Cale: who's verbose ;-)
13:33:01 <Cale> Moreover, most of the stuff in the DList module conflicts with Prelude names
13:33:11 <Cale> So you have to import it qualified.
13:33:32 <Deewiant> less work than writing a concatDL yourself, IMO :-)
13:33:47 <Cale> Really?
13:34:05 <nullified> woot now i should have cabal-install installed
13:34:06 <nullified> so how do i use it?
13:34:10 <Deewiant> well, considering that you need to write 3, maybe 4 functions, if you're going to use them more than once.
13:34:31 <Cale> You'd rather write  import qualified DList as DL; and then use DL.concat  than just use  foldr (.) id ?
13:35:00 <Leaves> hello, is the a nicer (faster) equivalent for (showString . unwords $ map show xv) ?
13:35:04 <Deewiant> yes, I would, because the former makes it obvious that I'm in fact concatenating lists.
13:35:36 <Cale> I dunno. I don't think it's so un-obvious :)
13:35:54 <mauke> foldr (.) id (map shows xv) ""
13:37:02 <Cale> might need an intersperse (showChar ' ')
13:38:28 <Cale> foldr (.) id . intersperse (showChar ' ') . map shows $ xv
13:39:56 <rwbarton> That doesn't look especially faster to me
13:40:49 <rwbarton> I mean, I think the answer to the original "faster" question is "not particularly"
13:41:25 <Leaves> I think this is what I'm looking for (I didn't know the intersperse function yet, which is what I had problems with)
13:41:54 <Leaves> Isn't this faster rwbarton, if the element of map show xv are long strings?
13:41:57 <rwbarton> 0 is usually considered a regular expression, right?  Even though most regular expression engines don't have syntax for it?
13:41:59 <Cale> Well, it avoids converting back and forth from strings to functions anyway.
13:42:05 <Cale> rwbarton: yes
13:42:12 <mauke> what does 0 do?
13:42:16 <rwbarton> matches nothing
13:42:25 <rwbarton> I mean, doesn't match anything :)
13:42:44 <Cale> It's the identity element for +
13:42:51 <mauke> (?!)  # in perl compatible regex engines
13:43:07 <int-e> > let rinits = scanl (flip (:)) [] in concatMap (tail . rinits) . rinits [1..3]
13:43:09 <lambdabot>   Couldn't match expected type `a -> [[b]]'
13:43:18 <int-e> > let rinits = scanl (flip (:)) [] in concatMap (tail . rinits) . rinits $ [1..3]
13:43:19 <lambdabot>   [[1],[2],[1,2],[3],[2,3],[1,2,3]]
13:43:22 <ddarius> [^.] ?
13:43:42 <mauke> ddarius: matches any character that isn't '.'
13:43:44 <rwbarton> That . is a literal, right?  But I guess you could list every character...
13:43:50 <Cale> > let rinits = scanl (flip (:)) [] in concatMap (tail . rinits) . rinits $ [1..4]
13:43:51 <lambdabot>   [[1],[2],[1,2],[3],[2,3],[1,2,3],[4],[3,4],[2,3,4],[1,2,3,4]]
13:44:49 <mauke> [^\0-\x{ffffffff}]
13:44:55 <int-e> rinits  is in some ways more natural than  inits, I think.
13:45:37 <ddarius> @src inits
13:45:38 <lambdabot> inits []     =  [[]]
13:45:38 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
13:46:38 <rwbarton> Leaves: I don't think it will be more than a constant factor faster, and I'd guess that constant factor will be small
13:47:07 <Cale> rwbarton: Well, there's something nice about not converting back and forth just for unwords.
13:47:27 <rwbarton> Sure.
13:47:56 <Leaves> rwbarton: but, isn't the whole Idea of shows and showsPrec etc for this optimalisation?
13:48:25 <Leaves> that should be: this kind of optimalisation
13:49:11 <mauke> optimalifisation!
13:50:07 <Leaves> sorry, should be optimization
13:50:14 <Leaves> I guess
13:50:24 <rwbarton> Leaves: shows is so that you don't always have to build up big strings from small ones in the structure  a ++ (b ++ (c ++ (d ++ ...)))
13:51:56 <rwbarton> Leaves: for example: (shows a . shows b) . (shows c . shows d) $ "" is better than (show a ++ show b) ++ (show c ++ show d)
13:52:21 <younder> > 3 `elem` [1,2,3,4]
13:52:23 <lambdabot>   True
13:53:07 <mauke> > 0.9 `elem` [0.1, 0.2 .. 1.0]
13:53:08 <lambdabot>   False
13:53:09 <rwbarton> Leaves: Oh, sorry, I guess the answer is yes then, because you have to apply your showString to "" to get a result out.
13:53:15 <rwbarton> Leaves: (I didn't realize what showString did at first)
13:53:47 <nicknull> so how do i use cabal-install? do i have to add it to my windows-path?
13:53:50 <rwbarton> Leaves: Still, that's only a constant factor; and unwords uses a right fold, so there's no problem there
13:54:09 <younder> mauke: makes sense as real numbers don't have exact representation
13:54:13 <Leaves> rwbarton: ok, then we agree :), yeah, maybe it would be nicer if it was called showsString
13:54:54 <mauke> nicknull: yeah, probably. I guess you get a cabal.exe on windows
13:55:11 <younder> > .2 `elem`[0.0,0.1..0.5]
13:55:12 <lambdabot>   <no location info>: parse error on input `.'
13:55:19 <younder> > .2 `elem` [0.0,0.1..0.5]
13:55:20 <lambdabot>   <no location info>: parse error on input `.'
13:55:23 <gio123> Cale: do you still have brozowski paper as i see i dont have it
13:55:29 <nicknull> i have a Main.hs
13:55:31 <rwbarton> > (0.9 :: Rational) `elem` [0.1, 0.2 .. 1.0]
13:55:32 <lambdabot>   True
13:55:34 <nicknull> no Cabal.exe
13:55:38 <younder> > .2 `elem` [0.0,0.1 .. 0.5]
13:55:39 <lambdabot>   <no location info>: parse error on input `.'
13:55:42 <nicknull> in cabal-install
13:55:43 <rwbarton> .2 /= 0.2
13:55:48 <Cale> http://cale.yi.org/share/p481-brzozowski.pdf
13:55:50 <lambdabot> Title: cache:http://cale.yi.org/share/p481-brzozowski.pdf - Google Search
13:55:52 <rwbarton> :t .2
13:55:52 <lambdabot> parse error on input `.'
13:55:58 <nicknull> cabal-install.cabal too
13:55:59 <younder> > 0.2 `elem` [0.0,0.1 .. 0.5]
13:56:00 <lambdabot>   True
13:56:24 <gio123> Cale:thanks
13:56:37 <younder> workes here because .2 has a finite number of digit representation in binary
13:57:08 <rwbarton> younder: false
13:57:11 <byorgey> uh... it does?
13:57:21 <rwbarton> works because you got lucky
13:57:25 <xxxxx> anybody know curry ?
13:57:32 <byorgey> 5 is not a power of two, last I checked =)
13:57:51 <mauke> nicknull: do you have dist\build\cabal.exe?
13:58:07 <younder> rwbarton: not lucky exactly. You can't rely on it because you think in decimal representation
13:58:08 <mauke> preflex: calc '2 0.2
13:58:08 <preflex>  0.0011001100110011001100110011001100110011001100110011
13:58:16 <vixey> xxxxx: a tiny bit
13:58:43 <nicknull> where is dist supposed to be?
13:58:58 <byorgey> xxxxx: curry the language, spice, person, or type isomorphism?
13:59:10 <mauke> nicknull: in the cabal-install directory
13:59:10 <rwbarton> or the function?
13:59:17 <byorgey> shoot, I forgot one!
14:00:24 <byorgey> I'll try again now that xxxxx is back
14:00:37 <byorgey> xxxxx: do you mean curry the language, spice, person, Prelude function, or type isomorphism?
14:00:48 <xxxxx> curry language of course
14:00:52 <rwbarton> byorgey: nice save :)
14:00:57 <byorgey> hehe =)
14:02:10 <xxxxx> i am begginning with this language and i need to construct a sequence data , like a list but with one element at least
14:02:47 <xxxxx> i know is similar to haskell , anybody can help me ? thanks and sorry for my poor english :)
14:04:31 <jeffz> xxxxx: have you tried reading an introductory tutorial?
14:04:52 <dons> ?users
14:04:52 <lambdabot> Maximum users seen in #haskell: 518, currently: 504 (97.3%), active: 23 (4.6%)
14:05:12 <vixey> xxxxx: You can try to adapt the definition of list [] maybe?
14:05:14 <xxxxx> jeffz, i do
14:05:22 <vixey> data List a = Nil | Cons a (List a)
14:06:13 <xxxxx> vixey, i think List is
14:06:13 <xxxxx> data  [a]  =  [] | a : [a] then data seq = () | ....
14:06:27 <vixey> you can't really use the () though
14:06:31 <vixey> because they already have it
14:06:52 <xxxxx> vixey, that is , data seq = () | ....
14:06:53 <jsn> xxxxx: a sequence has at least one element?
14:07:04 <petekaz> join #wikipedia
14:07:05 <vixey> it must be Seq not seq
14:07:17 <xxxxx> jsn, yes ( in my problem)
14:08:03 <jsn> data Seq a  =  One a  |  Many a (Seq a)
14:09:13 <mauke> Ap (,) []
14:09:16 <ddarius> data Seq a=One a|Many a(Seq a)
14:09:45 <jsn> xxxxx: now you can use 'One' and 'Many' in pattern matches
14:10:43 <xxxxx> jsn, mmm i do not understand well def of One and Many ... ; One could be () , for example ?
14:11:06 <nicknull> wow thanks cale,dmwit etc. cabal-install is a gift fromt he gods :)
14:11:48 <patco444> The Best Online RPG / Strategy game ever : http://www.fallensword.com/?ref=1461055
14:11:49 <lambdabot> Title: Fallen Sword v1.533 - Massively Multiplayer Online RPG (MMORPG)
14:12:41 --- mode: ChanServ set +o Cale
14:12:52 <xxxxx> jsn, i forgot that elements always inserts by end
14:12:57 --- mode: Cale set +b patco444!*@*
14:13:02 --- mode: Cale set -o Cale
14:13:51 <DuClare> Are “ErrorT ErrType (StateT StateType IO) a” and “StateT StateType (ErrorT ErrType IO) a” interchangeable?
14:14:20 <mauke> @unmtl ErrorT ErrType (StateT StateType IO) a
14:14:21 <lambdabot> StateType -> IO (Either ErrType a, StateType)
14:14:32 <mauke> @unmtl StateT StateType (ErrorT ErrType IO) a
14:14:32 <lambdabot> StateType -> IO (Either ErrType (a, StateType))
14:14:43 <mauke> that's a no
14:14:48 <DuClare> Hrrm.
14:15:12 <jsn> xxxxx: i don't think () makes any sense here
14:15:33 <jsn> xxxxx: you want at least on 'a' in the sequence, right?
14:15:41 <xxxxx> jsn, yes
14:15:51 <jsn> okay, well, () is nothing
14:15:59 <jsn> so your datatype should not allow it
14:16:29 <jsn> if you had this:  Seq a = [] | a : Seq a
14:16:41 <jsn> well, that would just be a list
14:17:00 <jsn> oh, i see what you mean now
14:17:26 <jsn> so, even though i've figured out how it makes sense, it still isn't right
14:18:07 <jsn> because '()' is the zero-tuple in Haskell, you can't use it
14:18:11 <jsn> for this purpose
14:18:28 <xxxxx> jsn, ok thanks , in curry () is Unit , so i thought that
14:18:42 <xxxxx> () --> one element
14:18:50 <jsn> in what?
14:18:57 <nicknull> in what oder do you install HAppS?
14:19:18 <xxxxx> curry , is a similar language with haskell
14:19:24 <jsn> oh
14:19:51 <xxxxx> no documentation and i just started with declarative programming
14:19:54 <xxxxx> hehe
14:20:01 <vixey> there are some docs
14:20:15 <xxxxx> yes but incomplete ...
14:20:32 <xxxxx> i have to make my job anyway
14:20:44 <BONUS_> hmm hey guys, im trying to think of a class to make
14:20:46 <BONUS_> for the tutorial
14:20:52 <BONUS_> when explaining classes
14:21:04 <BONUS_> a simple class to demonstrate how you can benefit from making your own typeclass
14:21:06 <RayNbow> @karma Cale
14:21:07 <lambdabot> Cale has a karma of 7
14:21:09 <RayNbow> Cale++
14:21:11 <vixey> class Animal => Dog where ...
14:21:11 <BONUS_> any suggestions?
14:21:15 <RayNbow> @karma Cale
14:21:15 <lambdabot> Cale has a karma of 8
14:21:21 <Peaker> Cale++
14:21:25 <BONUS_> i was thinking that might remind too much of inheritance
14:21:26 <mauke> preflex: karma Cale
14:21:26 <preflex>  karma for Cale: 22
14:21:31 <RayNbow> MonadRandom is pretty nifty :)
14:21:35 <BONUS_> cause that example is used for inheritance
14:21:40 <BONUS_> in imperative language tutorials
14:21:40 <vixey> yeah I was kidding :p
14:21:40 <BONUS_> hmm
14:21:42 <BONUS_> how about
14:21:43 <BONUS_> haha
14:21:44 <BONUS_> how about
14:22:06 <BONUS_> class YesNo y where yesno :: y -> Bool
14:22:17 <BONUS_> basically making something like idk
14:22:24 <vixey> I like  Squashable f a
14:22:29 <vixey> squash :: f a -> [a]
14:22:30 <BONUS_> instance YesNo Int where yesno 0 = False; yesno _ = True;
14:22:49 <mauke> instance YesNo [a] where yesno = not . null
14:22:57 <BONUS_> instance YesNo String where yesno "yes" = True; yesno _ = False;
14:23:07 <vixey> oops I don't want to put a in the class
14:23:17 <BONUS_> why not
14:23:23 <mauke> BONUS_: http://hackage.haskell.org/packages/archive/data-default/0.2/doc/html/Data-Default.html
14:23:32 <coram> that does seem like a good example BONUS
14:23:33 <lambdabot> Title: Data.Default, http://tinyurl.com/5bxgjp
14:23:53 <BONUS_> yeah, Default is nice too
14:23:58 <vixey> Another nice one is class Everything a where all :: [a]
14:24:06 <vixey> instace Everything Bool where all = [True,False]
14:24:18 <vixey> instace Everything a => Everything (Maybe a) where ...
14:24:23 <BONUS_> also nice
14:24:25 <mauke> [minBound .. maxBound]
14:24:43 <Cale> How about a class with a function polymorphic in the result type?
14:24:53 <nicknull> @karma nicknull
14:24:53 <lambdabot> You have a karma of 0
14:24:55 <BONUS_> Cale: example
14:25:02 <mauke> Read!
14:25:07 <vixey> all is an example of that
14:25:07 <nicknull> Cale ++
14:25:11 <BONUS_> oh you mean
14:25:11 <vixey> except it's not a function :)
14:25:16 <nicknull> @karma Cale
14:25:16 <lambdabot> Cale has a karma of 9
14:25:20 <Cale> Yeah, something like Read, but maybe different...
14:25:28 <nicknull> dmwit ++
14:25:28 <nicknull> mauke ++
14:25:28 <BONUS_> where the result is the type of the class instance
14:25:35 <nicknull> Cale ++
14:25:39 <mauke> nicknull: what
14:25:55 <nicknull> im just complimenting
14:25:57 <Cale> The regex library has a complicated example, =~ which is rather fun. Maybe it could be simplified like crazy :)
14:26:00 <rwbarton> class Fuzzy a where fuzzify :: a -> [a]; instance Fuzzy Integer where fuzzify n = [n-1, n, n+1]; ...
14:26:12 <mauke> nicknull: that doesn't count; there's a space before the ++
14:26:32 <BONUS_> haha, oh man now that I'm explaining stuff where the terminology is not so simple, I'm gonna have to have you guys go over it haha
14:26:37 <Cale> Like instead of regexes, just matching a string against another.
14:26:38 <mauke> Cale: I think class Default is probably a better example for a tutorial :-)
14:26:53 <Cale> Where if you ask for an Integer, you get the number of matches
14:26:59 <BONUS_> although i'd like the function defined by the class to be an actual mapping
14:27:02 <Cale> and if you ask for a Bool, you get whether there was a match
14:27:04 <rwbarton> BONUS_: I think some guy named Oleg has a bunch of examples of type classes :P
14:27:07 <BONUS_> e.g. not just a polymorphic constant, like Read
14:28:49 <nicknull> i get shitloads of warnings hn installing happs-state, is that normal?
14:30:09 <mmorrow> -Wall is pretty loud
14:30:34 <mmorrow> if that's not on then i'd probably worry :)
14:33:54 <DuClare> Does ghci have sth like @unmtl?
14:34:31 <BONUS_> what would that do?
14:34:32 <vixey> DuClare: You can actually use lambdabot
14:34:39 <BONUS_> un-monad transform everything?
14:34:39 <vixey> ?where GOA
14:34:40 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
14:34:52 <vixey> as GHCi
14:34:57 <Cale> BONUS_: I mean like this perhaps: http://hpaste.org/11266
14:35:27 <rwbarton> @unmtl ContT ans (StateT Integer []) x
14:35:28 <lambdabot> (x -> Integer -> [(ans, Integer)]) -> Integer -> [(ans, Integer)]
14:35:28 <vixey> ooh I want Match (String,String)
14:36:02 <mmorrow> @unmtl ContT r (ContT s (StateT s m)) a
14:36:02 <lambdabot> (a -> (r -> s -> m (s, s)) -> s -> m (s, s)) -> (r -> s -> m (s, s)) -> s -> m (s, s)
14:36:05 <mmorrow> hehe
14:36:15 <idnar> yeesh
14:36:27 <mmorrow> i don't use unmtl enough
14:36:58 * rwbarton needs @uncategory-extras
14:36:59 <BONUS_> Cale: i like that!
14:37:16 <BONUS_> yeah thats good cause you can then show them how it works nicely with type inference
14:37:23 <mmorrow> rwbarton: heh, that would be really useful actually
14:37:51 <Cale> BONUS_: and it kicks the idea that this is anything like OO classes pretty hard.
14:37:54 <nicknull> http://darcs2.fh-wedel.de/repos/janus/ , do i need anything but whats there?
14:37:55 <lambdabot> Title: Index of /repos/janus
14:38:03 <nicknull> and what do i download?
14:38:12 <BONUS_> yeah
14:38:13 <Cale> BONUS_: Because you can't do this with subtype polymorphism.
14:38:29 <mmorrow> rwbarton: oh yeah, i saw you pastes using cat-exts with the State progress thing. did you ever find out what the performance diff was on account of?
14:38:48 <BONUS_> i might use this yeah
14:39:05 <younder> > takeWhile even [1,2,3,4]
14:39:06 <lambdabot>   []
14:39:10 <rwbarton> mmorrow: no, I didn't look into it too thoroughly
14:39:15 <younder> what happed here?
14:39:55 <rwbarton> mmorrow: I thought at first it might be all the newtypes and such; I replaced runFree with unsafeCoerce# but it only got slightly faster
14:40:19 <mmorrow> rwbarton: i bet an uncategory-extras could be hacked together with reify and then just recursively expanding newtypes and tysyns
14:40:30 <mmorrow> without too much trouble
14:40:33 <rwbarton> yes
14:40:45 <younder> > takeWhile even [2,4,6,7,8]
14:40:47 <lambdabot>   [2,4,6]
14:40:52 <vixey> unsafe-category-extras??
14:40:56 <mmorrow> hehe, s/runFree/unsafeCoerce#/ is a good one
14:41:09 <rwbarton> hey, it workede :)
14:41:13 <mmorrow> good as in funny
14:41:15 <mmorrow> :)
14:41:30 <nicknull> hmatrix fails for me, anyon tried installing that?
14:41:47 <mmorrow> nicknull: what is the failure?
14:41:48 <rwbarton> It's really hard to read the core output of that program because 95% of it is type signatures.
14:42:39 * mmorrow runs ghc-core on a cat-exts prog
14:42:44 <vixey> :/
14:42:46 <vixey> I suck
14:43:13 <vixey> I spent hours getting all this stuff ready now I can't be bothered writing the actual bit
14:44:14 <rwbarton> it's just, case @ <5-line type signature> cast <20-line type signature> of ...
14:45:01 <Peaker> how does ghc bootstrap itself, on a system without Haskell?
14:45:29 <Heffalump> from C files that were generated on a system with GHC
14:45:49 <Japsu> Every time I've asked, we've concluded porting GHC to another architecture involves considerable amounts of "pain and suffering".
14:46:23 <Peaker> Heffalump: ah
14:47:05 <rwbarton> mmorrow: http://hpaste.org/11218#a12
14:49:01 <dons> Japsu: what architecture?
14:49:12 <rwbarton> mmorrow: I wonder how hard it would be to take ghc-core output and strip away all the type signatures
14:49:20 <dons> Peaker: you partially compile ghc on a host machine, yielding c versions of all the files, you take those to the new machine, and compile with gcc
14:49:25 <dons> then you use the result to build ghc.
14:49:34 <dons> its easier than porting gcc to a new arch, but it is still a bit tricky.
14:49:35 <rwbarton> mmorrow: they don't affect the semantics at that point do they?
14:49:48 <Japsu> dons: s/architecture/platform/
14:49:59 <Japsu> hardware and operating system
14:50:05 <solrize> what about retargeting the native code gen?
14:50:14 <dons> that's further work, solrize.
14:50:24 <Peaker> dons: yeah, gcc does the tough bit for you
14:50:35 <dons> Japsu: yeah, its non-trivial. but certainly doable (i've done 4 or 5 ports)
14:51:07 <dons> mm., openbsd/{x86,amd64,sparc}, netbsd/mac68k, mips/irix, dec/alpha, solaris/x86
14:51:25 <mmorrow> rwbarton: i don't believe they do, but i'm not sure if that'd do anything?
14:51:35 <mmorrow> heh, looking at the core now..
14:51:56 <rwbarton> , src ''Algebra
14:51:58 <Peaker> where does ghc-6.9 look for libedit.so.0 ?
14:52:04 <lunabot>  type Algebra f a = (f a) -> a
14:52:05 <mmorrow> do you mean somehow flatten the resulting composite datatype a la unmtl at compile-time?
14:52:26 <rwbarton> mmorrow: I just want to be able to read the thing
14:52:36 <mmorrow> haha, i got you
14:52:56 <mmorrow> hmm, yeah i bet the core could somehow be tidied..
14:53:24 <nicknull> mmorrow cabal.exe: Error: some packages failed to install:
14:53:24 <nicknull> hmatrix-0.4.0.0 failed during the building phase. The exception was:
14:53:24 <nicknull> exit: ExitFailure 1
14:53:43 <rwbarton> Mostly, I want anything that doesn't take any run time to be invisible
14:54:01 <rwbarton> so ideally I don't want to see newtype constructors either
14:54:09 <rwbarton> , src ''Fix
14:54:14 <lunabot>  newtype Fix s a = InB {outB :: (s a (Fix s a))}
14:55:06 <Peaker> I'm sorry if I missed it the last time, but why the double tag?
14:55:10 <mmorrow> nicknull: oh, hmm. i usually install that manually
14:55:20 <mmorrow> and on linux too
14:55:30 <Peaker> , src Fix
14:55:32 <lunabot>  luna: Not in scope: data constructor `Fix'
14:55:45 <nicknull> cabal install is soooo good. haskells libraries went from ranking ok to ranking in the top of all prog langs
14:55:56 <rwbarton> src is just a function.  ''Fix is a template haskell thing meaning something like "the type constructor Fix"
14:56:05 <Peaker> rwbarton: ah
14:56:10 <mmorrow> Peaker: so in TH,  '_  gives you the name of the datacon _ , and ''_ gives you the name of the type _
14:56:14 <rwbarton> , typeOf ''Fix
14:56:17 <lunabot>  Language.Haskell.TH.Syntax.Name
14:56:17 <mmorrow> , 'Just
14:56:19 <lunabot>  Data.Maybe.Just
14:56:23 <mmorrow> , ''Just
14:56:24 <lunabot>  luna: Not in scope: type constructor or class `Just'
14:56:26 <mmorrow> , ''Maybe
14:56:27 <lunabot>  Data.Maybe.Maybe
14:56:30 <mmorrow> , 'Maybe
14:56:31 <lunabot>  luna: Not in scope: data constructor `Maybe'
14:56:40 <rwbarton> , typeOf src
14:56:42 <lunabot>  luna: No instance for (Data.Typeable.Typeable
14:56:46 <rwbarton> boo
14:56:52 <mmorrow> and the function `src' is of type :: Name -> Doc
14:57:04 <mmorrow> well, actually :: Name -> Q Doc
14:57:10 <mmorrow> , src
14:57:11 <lunabot>  luna: No instance for (GHC.Show.Show
14:57:22 <mmorrow> gah, i have to clean those errmsgs
14:57:32 <theunixgeek> Is there an online Haskell interpreter?
14:57:37 <rwbarton> > "yes"
14:57:39 <lambdabot>   "yes"
14:57:41 <dons> http://codeflow.wordpress.com/2008/10/18/on-haskell-and-c/
14:57:42 <lambdabot> Title: On Haskell and C++ « Open game programming
14:57:46 <dons> is worth reading. his code is online
14:57:50 <Peaker> why is ghc-6.9 looking for libedit.so.0 and not libedit.so.2 or such ?
14:57:52 <sbahra> theunixgeek, lambdabot and codepad.org
14:57:52 <dons> code.haskell.org/freekick
14:57:53 <mmorrow> there's codepad.org
14:57:58 <theunixgeek> thanks, sbahra
14:58:07 <mmorrow> theunixgeek: codepad.org, but it uses hugs :(
14:58:19 <theunixgeek> is HUGS bad, mmorrow?
14:58:29 <dons> theunixgeek: ghc is a much better system
14:58:43 <mmorrow> not bad, but doesn't support the language extensions of GHC
14:58:46 <dons> hugs is a toy/learning tool, not a deployable implementation.
14:58:47 <theunixgeek> dons: I'm downloading it, but I still have to wait 17 minutes till the download is done
14:58:52 <BMeph> > unsafeCoerse# JavaProgrammersToUseHaskell!
14:58:53 <lambdabot>   <no location info>: parse error on input `;'
14:58:59 <dons> theunixgeek: perhaps your distro has native packages?
14:59:04 <BMeph> ...well it's worth a try. ;)
14:59:06 <dons> heh
14:59:10 <sbahra> Could someone tell me why http://kerneled.org/dump/Ports.hs sucks?
14:59:13 <nicknull> hmm cn i have cabal to download the source code as well? not just execurtable libraries
14:59:16 <theunixgeek> dons: that's what I'm downloading...
14:59:21 <dons> ok.
14:59:22 <sbahra> I would appreciate feedback (mainly on over-all design) from an experienced haskell programmer.
14:59:25 <theunixgeek> dons: I'm on OS X, by the way :P
14:59:41 <theunixgeek> my Fedora computer hasn't been able to connect to the internet lately
14:59:44 <theunixgeek> ISP problems
14:59:46 <dons> yes, you're getting an optimizing compiler, bytecode interpreter, debugger, profiler, multicore runtime system, and a full development suite
14:59:52 <dons> so that is a lot in a single package
15:00:04 <dons> sbahra: why does it suck?
15:00:13 <sbahra> You can use Tool.hs as a front-end.
15:00:14 <dons> oh, well, you're using type instead of newtype :)
15:00:26 <sbahra> dons, you tell me :-P
15:00:28 <dons> so not leaning on the type system enough
15:00:33 <sbahra> dons, ok.
15:00:43 <mmorrow> rwbarton, Peaker: err, src :: Name -> Doc
15:00:44 <dons> those fields in Port should be properly typed values, so you can't mix them up with untyped strings et al
15:01:01 <dons> using list indexing is slow and unidiomatic,
15:01:01 <dons>      maintainer = p !! 5 categories = B.words $ p !! 6
15:01:11 <dons> would be better to pattern match, perhaps?
15:01:19 <dons> or store the result of splitting in an IntMap?
15:01:26 <camio> sbahra: There are some opportunities to use point free form that aren't taken. Like putPorts and putPort.
15:01:30 <mmorrow> rwbarton, Peaker: but it's eliminating the Q with witchcraft and other burnable-at-the-stake offenses
15:01:36 <theunixgeek> this is my first time trying Haskell, so I'm wondering...
15:01:36 <theunixgeek>  why do you use it?
15:01:41 <dons> sbahra: but doesn't overall look too bad.
15:01:43 <sbahra> camio, yes, I was lazy there. Point taken.
15:01:47 <dons> theunixgeek: 'you' meaning any of us?
15:01:48 <sbahra> dons, ok.
15:01:53 <theunixgeek> yes :
15:01:54 <theunixgeek> :)
15:01:55 <sbahra> dons, why is list indexing slow, BTW?
15:02:00 <sjanssen> sbahra: I'd use a Data.Map.lookup instead of toField
15:02:12 <dons> its my job, its fun, code is shorter, faster, safer and uses multiple cores
15:02:23 <dons> sbahra: its O(n)
15:02:30 <sbahra> oh, really
15:02:31 <sbahra> ok
15:02:37 <dons> ?src (!!)
15:02:37 <lambdabot> xs     !! n | n < 0 = undefined
15:02:37 <lambdabot> []     !! _         = undefined
15:02:37 <lambdabot> (x:_)  !! 0         = x
15:02:37 <lambdabot> (_:xs) !! n         = xs !! (n-1)
15:02:42 <sbahra> makes sense
15:02:55 <camio> sbahra: I'd try to make an interface that doesn't use so much IO. (Maybe FRP framework, but that's a bit much to ask for this lib).
15:03:11 <dons> yeah, IO is fine here for now
15:03:12 <theunixgeek> dons: hm, I guess that sells it well enough
15:03:17 <jsn> theunixgeek: type inference, indentation based syntax, conceptual clarity
15:03:29 <dons> what does haskell.org say,
15:03:36 <dons> "An open source product of more than twenty years of cutting edge research, it allows rapid development of robust, concise, correct software"
15:03:38 <sbahra> camio, could you elaborate?
15:03:46 <nicknull> dons: who are you?
15:03:56 <dons> nicknull: ?
15:04:00 * dons is me
15:04:04 <jsn> hehe
15:04:12 <dons>  /whois dons
15:04:15 <dons> oh oops
15:04:16 <dons> still me.
15:04:17 <nicknull> name, if you dont mind
15:04:20 <camio> sbahra: http://www.haskell.org/frp/
15:04:21 <jsn> i think he means, who are you that you use it for work
15:04:23 <mauke> preflex: ? whois:dons
15:04:23 <preflex>  factoid not found
15:04:27 <theunixgeek> lambdabot: putStrLn "Hello World"
15:04:31 <lambdabot> Title: Functional Reactive Programming Research
15:04:41 <rwbarton> @where dons
15:04:41 <dons> ah, http://www.cse.unsw.edu.au/~dons/
15:04:42 <jsn> > putStrLn "hello world"
15:04:42 <lambdabot> http://www.cse.unsw.edu.au/~dons
15:04:43 <lambdabot> Title: Don Stewart
15:04:44 <lambdabot>   * Exception: "<IO ()>"
15:04:45 <sbahra> Ok.
15:04:54 <sbahra> Thanks dons, camio, sjanssen
15:04:56 <jsn> > 1 + 1
15:04:57 <lambdabot>   2
15:05:10 <name> nicknull: if you dont mind
15:05:16 <nicknull> is there any library that is better than http-simple for opening and getting the text of a very big amount of html files?  actually have allt he files downloaded
15:05:16 <dons> hehe
15:05:20 <mauke> preflex: ? whois:dons
15:05:20 <preflex>  Don Stewart
15:05:28 <dons> nicknull: i'd use download-curl
15:05:33 <dons> and use its lazy bytestring api
15:05:38 <dons> namely, openURI
15:05:47 <theunixgeek> @where theunixgeek
15:05:47 <lambdabot> I know nothing about theunixgeek.
15:05:53 <theunixgeek> lol :P
15:06:00 <theunixgeek> how come lambdabot can't say Hello World?
15:06:11 <dons> nicknull: do you know about hackage?
15:06:14 <mauke> > "Hello, world!"
15:06:14 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/download-curl
15:06:15 <lambdabot>   "Hello, world!"
15:06:16 <lambdabot> Title: HackageDB: download-curl-0.1.1, http://tinyurl.com/54bv5d
15:06:18 <dons> is the lib
15:06:37 <nicknull> name: what do you mean?
15:06:57 <dons> mutual recursion :)
15:07:23 <rwbarton> @botsnack
15:07:23 <lambdabot> :)
15:07:25 <dons> let f = g please ; g = f please
15:08:00 <dons> nicknull: 'name' was making a joke, nicknull> name, if you dont mind / name> nicknull: if you dont mind
15:08:03 <rwbarton> > let please = id in please (do [1,2,3])
15:08:05 <lambdabot>   [1,2,3]
15:08:09 <name> nicknull: 00:04 < nicknull> name, if you dont mind
15:08:15 <sbahra> camio, especially recommend any FRP papers?
15:08:23 <theunixgeek> BONUS_: hey, are you the one from learnmeahaskell.com ?
15:08:31 <camio> sbahra: Yeah, lemme see if I can find the ones I liked...
15:08:35 <dons> sbahra: i'd finish your io layer first please :) don't fall down the frp rabbit hole yet
15:08:39 <xenoblitz> guys has anyone perhaps found a solution for http://hackage.haskell.org/trac/ghc/ticket/1081 ? I met the same bug
15:08:42 <lambdabot> Title: #1081 (HGL indefinite pause with "thread blocked indefinitely" message) - GHC -  ...
15:08:49 <dons> xenoblitz: in hgl?
15:08:52 <xenoblitz> yes
15:09:04 <nicknull> australian?
15:09:17 <dons> xenoblitz: using Graphics.HGL.Gtk
15:09:22 <dons> nicknull: me?
15:09:27 <camio> dons has a good point. Put these readings on the todo list: 1) http://www.haskell.org/yale/papers/oxford02/index.html
15:09:28 <lambdabot> Title: Arrows, Robots, and Functional Reactive Programming
15:09:39 <camio> 2) http://www.haskell.org/yale/papers/haskell-workshop03/index.html
15:09:39 <lambdabot> Title: Haskell Workshop 2003 - The Yampa Arcade
15:09:46 <xenoblitz> dons: there is HGL.Gtk?... isn't it only SOE?
15:10:00 <camio> 3) http://conal.net/blog/posts/simply-efficient-functional-reactivity/
15:10:02 <dons> there's a gtk2hs binding with the same api
15:10:02 <lambdabot> Title: Conal Elliott » Simply efficient functional reactivity, http://tinyurl.com/6ma42k
15:10:23 <sbahra> dons, I'm not on a deadline here :-)
15:10:32 <xenoblitz> @hackage Graphics.HGL.Gtk
15:10:32 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Graphics.HGL.Gtk
15:10:59 <xenoblitz> hmmm the link is dead???
15:11:40 <rwbarton> @hackage kyugggytcx
15:11:41 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/kyugggytcx
15:12:02 <xenoblitz> ok i get the point rwbarton
15:12:05 <nicknull> curl-1.3.2.1 failed to install when downloading download-curl
15:12:49 <xenoblitz> damn... i wish HGL was still maintained... I ... realized... too late :(
15:12:50 <nicknull> exit:exitfailure 1
15:14:14 <camio> sbahra: Are you doing this project to learn more about haskell?
15:14:18 <xenoblitz> @hackage Graphics.SOE.Gtk
15:14:18 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Graphics.SOE.Gtk
15:14:38 <dons> nicknull: right, so you tried to build the 'curl' package?
15:14:42 <rwbarton> Graphics.SOE.Gtk is a module name, you want a package name
15:14:58 <dons> the main reason that would fail, nicknull, is if you didn't have libcurl (the C library) installed
15:15:12 <sbahra> camio, yes
15:15:17 <dons> nicknull: do you have 'cabal-install'? $ cabal install curl -- for example?
15:15:20 <xenoblitz> rwbarton: sorry rwbarton... i'm still trying to figure how hackage works :P
15:15:40 <sbahra> camio, and atleast, thanks to haskell, it will be useful to others and myself
15:16:02 <nicknull> curl fails to install
15:16:16 <dons> nicknull: the haskell binding, curl. or the C library?
15:16:18 <sbahra> camio, in order to help easily gather data on FreeBSD ports (as well as search more productively)
15:16:23 <nicknull> cabal.exe: Error: some packages failed to install:
15:16:23 <nicknull> curl-1.3.2.1 failed during the configure step. The exception was:
15:16:23 <nicknull> exit: ExitFailure 1
15:16:31 <camio> sbahra: The problem you're solving with your program has an imperative bias. It may be more fruitful, learning wise, to solve a more functional problem. It escapes me at the moment a good example.
15:16:40 <dons> nicknull: right, that's almost certainly due to you not having libcurl installed
15:16:48 <sbahra> camio, I've done that.
15:16:50 <dons> so use your package system to install the C curl library
15:16:50 <rwbarton> xenoblitz: Yeah, I don't know of a way to search by module name, except to grep the 00-index file :P
15:16:52 <nicknull> libcurl is what?
15:16:54 <rwbarton> xenoblitz: try soegtk
15:16:59 <dons> a C library for client-side http
15:17:02 <sbahra> camio, implemented various ADTs, etc...
15:17:03 <nicknull> a cygwin or mssy lib?
15:17:09 <dons> nicknull: oh, your on windows?
15:17:12 <nicknull> yes
15:17:26 <sbahra> camio, I want to make use of the various haskell packages (first use of ByteString, plan on using Data.Map, plan on using HTTP, etc...)
15:17:37 <dons> well, it's a ubiquitous C library, but i don't know who you get it on windows. avoid C bindings then.
15:17:48 <dons> how large are you files?
15:18:10 <xenoblitz> dons,rwbarton: thanks ... I'll try to see how I can extend it for more colours and it should be good enough for what I need (must check if I can do so,legally)... otherwise does anyone know of a simplistic graphics/win UI library I can use?
15:18:10 <sbahra> camio, as well as learn other things necessary for larger projects in haskell (design patterns)
15:18:49 <nicknull> just a few kB but loads and loads of them. its al the posts in september from HackerNews.com
15:18:51 <dons> so in a limited development environment, you'll need to find a lib that uses bytestrings or lazy bytestrings, if you want to download large data off the network (so not the String-based ones, though you can try).  maybe try http-simple or tagsoup first though, pure haskell, portable, eas yto build
15:18:53 <sbahra> camio, and also generally play more with IO monad
15:18:56 <dons> oh, a few kb.
15:19:45 <nicknull> i want to take out: </script><title
15:19:46 <dons> nicknull: oh, i'd just use say, tagsoup, http://hackage.haskell.org/packages/archive/tagsoup/0.6/doc/html/Text-HTML-Download.html
15:19:48 <lambdabot> Title: Text.HTML.Download, http://tinyurl.com/6xfan2
15:20:05 <dons> then you can use tagsoup to also do the lexing, and drop tokens you don't like
15:20:14 <nicknull> etc
15:20:23 <dons> that'll work fine on windows (it's pure haskell), so off you go.
15:20:26 <camio> sbahra: Looks like you're off to a good start.
15:21:16 <nicknull> i have tagsoup installed apparently, where is it located? can i somehow list all available imports inside ghci?
15:21:35 <camio> sbahra: Here is a good description of a functional alternative to design patterns http://luqui.org/blog/archives/2008/07/18/semantic-design/
15:21:46 <lambdabot> Title: Semantic Design @ The dreams that stuff is made of
15:21:51 <sbahra> camio, thanks
15:21:53 * sbahra reads
15:22:08 <xenoblitz> I guess that's a no... well thanks anyways guy :)
15:22:11 <xenoblitz> *guys
15:22:17 <dons> nicknull: ghc-pkg list
15:23:57 <dons> here's what i have installed, http://galois.com/~dons/tmp/dons-pkgs.txt :)
15:24:55 <coram> that's quite a list dons.
15:26:04 <dons> there's a lot of haskell code out there
15:27:00 <mmorrow> rwbarton: a preliminary version:
15:27:04 <mmorrow> , [t|Cofree (Coideal Maybe) Int|]
15:27:06 <lunabot>  AppT (AppT (ConT Cofree) (AppT (ConT Coideal) (ConT Maybe))) (ConT Int)
15:27:11 <mmorrow> , ppDoc `fmap` [t|Cofree (Coideal Maybe) Int|]
15:27:13 <lunabot>  Cofree (Coideal Maybe) Int
15:27:19 <mmorrow> expands to:
15:27:26 <mmorrow> , let issyn n | Just (TyConI (TySynD _ _ t)) <- dynReify n = Just t | otherwise = Nothing ; killsyn0 t@(ConT n) = maybe t id (issyn n) ; killsyn0 t = t ; killsyns = everywhere (mkT killsyn0) in  (ppDoc' . killsyns) `fmap` [t|Cofree (Coideal Maybe) Int|]
15:27:31 <lunabot>  Fix (PCofree f) (Ap (,) Maybe) Int
15:27:46 <mmorrow> i'll add that to lunabot
15:27:52 <rwbarton> ooh, everywhere
15:27:58 <mmorrow> everywhere FTW
15:28:19 <mmorrow> everywhere is SOOO useful
15:28:40 <mmorrow> (for non-context-sensitive stuff)
15:29:21 <keseldude> mmorrow: did you want me to keep that lambdabot 'keselbot' connected on freenode?
15:29:52 <mmorrow> keseldude: totally! it'd be way useful :)
15:30:19 <rwbarton> mmorrow: PCofree is still a type synonym
15:30:30 <rwbarton> mmorrow: What if you change the 'id' to 'killsyns'
15:30:37 <mmorrow> rwbarton: dang, hmm
15:30:48 <mmorrow> i'm not sure what's happening yet..
15:32:34 <rwbarton> I don't think everywhere will descend into terms it's replaced, will it?
15:32:52 <rwbarton> use everywhere'
15:33:08 <rwbarton> , let issyn n | Just (TyConI (TySynD _ _ t)) <- dynReify n = Just t | otherwise = Nothing ; killsyn0 t@(ConT n) = maybe t id (issyn n) ; killsyn0 t = t ; killsyns = everywhere' (mkT killsyn0) in  (ppDoc' . killsyns) `fmap` [t|Cofree (Coideal Maybe) Int|]
15:33:09 <lunabot>  Killed.
15:33:13 <rwbarton> , let issyn n | Just (TyConI (TySynD _ _ t)) <- dynReify n = Just t | otherwise = Nothing ; killsyn0 t@(ConT n) = maybe t id (issyn n) ; killsyn0 t = t ; killsyns = everywhere' (mkT killsyn0) in  (ppDoc' . killsyns) `fmap` [t|Cofree (Coideal Maybe) Int|]
15:33:13 <lunabot>  Killed.
15:33:17 <rwbarton> , 8
15:33:19 <lunabot>  8
15:33:20 <mmorrow> i'm relinking it
15:33:28 <rwbarton> , let issyn n | Just (TyConI (TySynD _ _ t)) <- dynReify n = Just t | otherwise = Nothing ; killsyn0 t@(ConT n) = maybe t id (issyn n) ; killsyn0 t = t ; killsyns = everywhere' (mkT killsyn0) in  (ppDoc' . killsyns) `fmap` [t|Cofree (Coideal Maybe) Int|]
15:33:34 <lunabot>  luna: Not in scope: type constructor or class `Ap'
15:33:40 <mmorrow> had to zap an imported module from cat-exts that had a Lift that was conflictinhg
15:33:41 <rwbarton> ok I'll wait
15:34:22 <mmorrow> grr,  luna: Not in scope: type constructor or class `Ap'
15:34:55 <mmorrow> since at least 3 levels of eval are happening in that expression, the Ap is losing its context somehow
15:35:11 <vixey> what other papers about containers are there?
15:35:38 <BBHoss> BONUS_: hi, I'm reading your intro to haskell.  For Mac OS X installs, its a simple sudo port install ghc
15:35:41 <rwbarton> it must be from dynReify right?
15:35:45 <mmorrow> oh. i must have unimported the module Ap was defined in actually
15:35:52 <mmorrow> , src ''Ap
15:35:53 <lunabot>  luna: Not in scope: type constructor or class `Ap'
15:35:55 <mmorrow> , src 'Ap
15:35:57 <lunabot>  luna: Not in scope: data constructor `Ap'
15:35:59 <mmorrow> sigh
15:36:06 <mmorrow> one sec
15:37:32 <mmorrow> crap, what luck
15:37:45 <mmorrow> type Ap p = Lift p Identity
15:38:03 <mmorrow> but i can't let Lift be in scope, or it'll conflict with TH Lift
15:38:08 <mmorrow> hmm
15:42:20 <mmorrow> ok, i did s/Lift/Lift_/ in cat-exts
15:42:44 <mmorrow> sweet
15:42:46 <mmorrow> , let issyn n | Just (TyConI (TySynD _ _ t)) <- dynReify n = Just t | otherwise = Nothing ; killsyn0 t@(ConT n) = maybe t killsyns (issyn n) ; killsyn0 t = t ; killsyns = everywhere (mkT killsyn0) in  (ppDoc' . killsyns) `fmap` [t|Cofree (Coideal Maybe) Int|]
15:42:51 <lunabot>  Fix (Biff p Identity (,) f) (Lift_ p Identity (,) Maybe) Int
15:43:08 <mmorrow> rwbarton: yeah, doing killsyns instead of id was it
15:43:19 <rwbarton> mmorrow: I see there's also everywhere' for this purpose
15:43:21 <rwbarton> , let issyn n | Just (TyConI (TySynD _ _ t)) <- dynReify n = Just t | otherwise = Nothing ; killsyn0 t@(ConT n) = maybe t id (issyn n) ; killsyn0 t = t ; killsyns = everywhere' (mkT killsyn0) in  (ppDoc' . killsyns) `fmap` [t|Cofree (Coideal Maybe) Int|]
15:43:27 <lunabot>  Fix (Biff p Identity (,) f) (Lift_ p Identity (,) Maybe) Int
15:43:38 <rwbarton> , let issyn n | Just (TyConI (TySynD _ _ t)) <- dynReify n = Just t | otherwise = Nothing ; killsyn0 t@(ConT n) = maybe t id (issyn n) ; killsyn0 t = t ; killsyns = everywhere' (mkT killsyn0) in  (ppDoc' . killsyns) `fmap` [t|Free ((,) Double) Int|]
15:43:43 <lunabot>  Fix (Biff p Identity Either f) ((,) Double) Int
15:44:05 <rwbarton> Expanding newtypes is harder, since they might be recursive
15:44:28 <nicknull> how do i import regexps?
15:45:14 <mmorrow> rwbarton: yeah, it'd be interesting to figure out how to do that while making sure you don't loop
15:45:16 <lispy> ?hoogle regexp
15:45:16 <lambdabot> package regexpr
15:45:29 <lispy> ?hoogle mkRegex
15:45:30 <lambdabot> No results found
15:45:33 <mmorrow> rwbarton: err, to implement i mean, since of course it's been figured out ;)
15:45:34 <lispy> ?hoogle mkRegexp
15:45:35 <lambdabot> No results found
15:46:17 <rwbarton> @hoogle compile
15:46:18 <lambdabot> module Distribution.Compiler
15:46:18 <lambdabot> module Distribution.Simple.Compiler
15:46:18 <lambdabot> Distribution.Simple.Compiler data Compiler
15:46:26 <rwbarton> @hoogle (=~)
15:46:26 <lambdabot> No results found
15:47:00 <nicknull> ?hoogle regex
15:47:00 <lambdabot> package regex-base
15:47:00 <lambdabot> package regex-compat
15:47:00 <lambdabot> package regex-dfa
15:47:08 <kynky> just wondering what is seen as a good way of doing erlang style concurrency in haskell, was looking into session types, but was wondering of anything else
15:47:08 <dmwit> It's in Text.Regex.????
15:47:18 <dmwit> where ???? tells what implementation you want, like Posix or PCRE or whatever.
15:47:40 <nicknull> the most pythonish
15:48:22 <kynky> or just implement my self with mvars and channels
15:50:09 <rwbarton> , let issyn n | Just (TyConI (TySynD _ _ t)) <- dynReify n = Just t | otherwise = Nothing ; killsyn0 t@(ConT n) = maybe t id (issyn n) ; killsyn0 t = t ; killsyns = everywhere' (mkT killsyn0) in  (ppDoc' . killsyns) `fmap` [t|Free ((,) Double)|]
15:50:11 <lunabot>  luna: `Control.Monad.Free.Free ((,) GHC.Types.Double)' is not applied to ...
15:50:25 <nicknull> when i do Text.Regex, which regex is that?
15:50:28 <dmwit> nicknull: "Pythonic" in this case would probably refer to the interface, and they all use the same interface.
15:50:37 <dmwit> nicknull: I believe the default is Posix.
15:50:38 <nicknull> ok
15:53:20 <nicknull> an example of use? all documentation of haskell packages seem to be devoid of examples, really a shame. i need examples to understand things
15:54:08 <dmwit> > "aba" =~ "b" :: Bool
15:54:09 <lambdabot>   True
15:54:19 <dmwit> > "aba" =~ "b" :: (String, String, String)
15:54:20 <lambdabot>   ("a","b","a")
15:54:31 <dmwit> > "aba" =~ "b" :: (String, String, String, [String])
15:54:32 <lambdabot>   ("a","b","a",[])
15:54:41 <dmwit> > "ababa" =~ "b" :: (String, String, String, [String])
15:54:43 <lambdabot>   ("a","b","aba",[])
15:54:47 <dmwit> huh
15:54:48 <dmwit> oh
15:54:55 <dmwit> > "ababa" =~ "(b)" :: (String, String, String, [String])
15:54:56 <lambdabot>   ("a","b","aba",["b"])
15:55:25 <dmwit> > "ababa" =~ "(b)" :: Int
15:55:26 <lambdabot>   2
15:55:36 <ozy`> dmwit: are there shortcuts for these operators? (specifying the type every time seems like kind of a pain... although I guess you could define the shortcuts yourself)
15:55:44 <BBHoss> how does Haskell relate to Erlang?
15:56:01 <nicknull> Not in scope: `=~'
15:56:05 <dmwit> ozy`: Just use it at the type you want it at, the type inference engine will figure it out. ;-)
15:56:07 <nicknull> and i ahve import regex
15:56:10 <ozy`> BBHoss: they're both functional languages, and they both use lowercase letters
15:56:16 <ozy`> dmwit: oh right, d'oh
15:56:24 <dmwit> nicknull: You have to import Text.Regex.SomeImplementation.  ...like I said earlier.
15:56:58 <BBHoss> ozy`: i don't know either of them, but do you think if i learned haskell or erlang, learning the other would be much easier?
15:57:12 <dmwit> Yes.
15:57:41 <nha__> erlang takes like 20min to learn if you know haskell
15:57:53 <nha__> but getting familiar with OTP takes a while
15:57:56 <ozy`> BBHoss: that depends on what functional languages you know.
15:58:05 <BBHoss> ozy`: i don't know any
15:58:09 <ozy`> (and how well you understand them)
15:58:11 <ozy`> well then
15:58:25 <ozy`> whichever one you learn first, will take a bit of work
15:58:35 <BBHoss> heh yeah i can see that :)
15:58:37 <ozy`> but the other should be much easier afterwards
15:59:11 <nha__> are there any tools for cleaning up unused imports in a file
15:59:26 <dmwit> BBHoss: I think Haskell is a lot cleaner. ...and a bit more mind-bending. ;-)
15:59:35 <BBHoss> hmm
15:59:38 <nha__> yea learn haskell first
15:59:39 <ozy`> BBHoss: are you used to programming with imperative languages, or are you fairly new to programming altogether?
15:59:39 <BBHoss> we'll see
15:59:40 <dmwit> nha__: -Wall will warn you about unused imports
15:59:47 <nha__> erlangs core lang is kinda odd
15:59:54 <nha__> dmwit: awesome, thanks
15:59:54 <BBHoss> ozy`: fairly new, my only real experience is with ruby
15:59:59 <dmwit> nha__: I'm not sure which -W flag it is to do just that warning, but I'm sure you can figure it out with a bit of man pages. ;-)
16:00:07 <nha__> yea
16:00:46 <ozy`> BBHoss: oh, so you at least should have had the opportunity to learn the (fairly basic) functional-programming-isms in ruby
16:01:15 <BBHoss> ozy`: like lambdas and procs? I'm really new, so I'm not sure what's functional and what's not
16:01:49 <nicknull> yes
16:01:53 <ozy`> BBHoss: basically, it's all the stuff you'd miss if you switched to Eiffel right now ;)
16:01:59 <nicknull> lambdas ~= procs i think
16:02:14 <BBHoss> nicknull: well you can do both in ruby
16:02:29 <BBHoss> i understand lambda calculus though, so thats not a big deal
16:02:37 <ozy`> nicknull: "proc" is more or less a synonym for "lambda" in ruby
16:02:50 <ozy`> BBHoss: well shit, man, you're good to go
16:02:58 <nicknull> bbhoss: if u know haskell, erlang is easy, but then ther is the whole platform and the concurrency part which is kind of the pont of erlang
16:03:00 <ozy`> dive right in and learn Haskell
16:03:10 <BBHoss> ozy`: i plan on it
16:03:21 <nicknull> if u learn erlang first, it is a good soft start to learn haskell
16:03:47 <dmwit> BBHoss: I recommend
16:03:47 <nha__> i dont think so
16:03:49 <BBHoss> ozy`: would haskell be good for processing large amounts of data, or would erlang be more suited for that due to concurrency and OTP?
16:03:49 <dmwit> ?where gentle
16:03:50 <lambdabot> http://www.haskell.org/tutorial/
16:04:07 <nha__> the intro level stuff in haskell is just as easy
16:04:10 <BBHoss> dmwit: this is what im reading now http://learnyouahaskell.com/starting-out
16:04:11 <lambdabot> Title: Learn You a Haskell for Great Good! - Starting Out
16:04:12 <nha__> as erlang
16:04:22 <nha__> very little real difference until you get to some of the type classes in the stdlib
16:04:22 <dmwit> BBHoss: I've also heard good things about that. =)
16:05:10 <BBHoss> dmwit: yeah i saw it on news.ycombinator.com today, figured what the hell, i'll try it out
16:05:19 <ozy`> BBHoss: processing lots of data on one machine is a fine job for Haskell. if it -needs- to be concurrent, you might turn to Erlang then....
16:05:31 * dmwit shrugs
16:05:42 <dmwit> Erlang's concurrency is still single-process...
16:05:52 <ozy`> but again, they share a lot of concepts (apart from the fact that their design goals are different)
16:05:54 <dmwit> At least in Haskell you can get multiple OS threads.
16:06:03 <ahunter1> BBHoss: I'd really recommend sticking to RWH/Gentle Guide, fwiw
16:06:17 <ozy`> http://book.realworldhaskell.org/read/ <== this is RWH, by the way
16:06:19 <nha__> haskell channels are close enough to the erlang message queues
16:06:26 <lambdabot> Title: Real World Haskell
16:06:30 <nha__> but in erlang you get free distributed computing without much work
16:06:33 <BBHoss> dmwit: the point of erlang is to NOT use threads, to setup multiple "green" threads (or processes) and use messages to pass between
16:07:07 <dmwit> BBHoss: Haskell has m-to-n thread multiplexing.  All the benefits of green threads, plus all the benefits of true concurrency.
16:08:10 <BBHoss> ok guys, thanks for your help
16:08:31 <BBHoss> i just gotta let ghc finish compiling, why the hell does it take so long?
16:08:45 <nha__> start over and enable SplitObjs
16:08:45 <mauke> why are you recompiling ghc?
16:08:47 <nha__> haha
16:08:57 <BBHoss> i'm just installing a port on os x
16:09:05 <ahunter1> BBHoss: that shouldn't take a compile IIRC...
16:09:15 <dmwit> There's a binary distribution for almost every platform available on haskell.org/ghc
16:09:56 <ozy`> BBHoss: you on PPC by any chance? (I had to compile some time back to get a recent build on my PPC machine)
16:10:09 <BBHoss> ozy`: no, a Penryn Macbook Pro
16:10:25 <BBHoss> 2.4 ghz core 2
16:10:38 <ozy`> ah, well then you can use a binary. the GHC guys have Intel binaries spewing out their ears like fruit loops
16:12:25 <BBHoss> i mean its not gonna take like 6 hours is it?
16:13:09 <mauke> depends
16:13:16 <dmwit> 2-3 has happened
16:13:18 <ozy`> BBHoss: no, from what I hear it can take as little as 20 minutes on recent Intel processors
16:13:22 <dmwit> What version of GHC are you building with?
16:13:41 <BBHoss> http://pasternak.superalloy.nl/pastes/943
16:14:10 <mauke> no, that's the ghc you're building
16:14:15 <mauke> what ghc are you building it WITH?
16:14:18 <rwbarton> ghc-6.8.2-darwin-i386-leopard-bootstrap.tar.bz2
16:14:25 <dmwit> mauke: It looks like 6.8.2 is the bootstrapper.
16:14:26 <mauke> oh
16:14:30 * mauke is blind and shuts up
16:14:31 <ozy`> that's output from macports
16:14:55 <rwbarton> I'd guess around 30 minutes
16:15:39 <nicknull> "aa<href='google.com'>ffv" =~ "<href=[a-zA-Z0-9]*" :: Bool
16:15:51 <BBHoss> ok kool
16:16:00 <dmwit> nicknull: False
16:16:05 <mauke> True
16:16:16 <dmwit> mauke: Note the single quotes...
16:16:22 <mauke> note the *
16:16:27 <dmwit> mmm
16:16:28 <nicknull> sorry i missed
16:16:33 <dmwit> nasty =P
16:16:42 <nicknull> * repeats previous
16:16:42 <nicknull> what?
16:16:42 <mauke> i r regex master
16:16:43 <nicknull> i missed i was away
16:17:03 <nicknull> but * matches [a-zA-Z0-9] right
16:17:10 <nicknull> unlimited nbr of times
16:17:33 <dmwit> nicknull: As an aside, you really don't want to use regexen to match HTML.
16:17:34 <nicknull> wait the  ' '
16:17:40 <mmorrow> it took 3+ hrs to build 6.8 with 6.4, but using 6.6+ to build a ghc only takes about 20-30 minutes depending on optim level/etc on my laptop
16:17:50 <dmwit> Use a library like Tag Soup or Beautiful Soup or whatever it's called in Haskell.
16:17:59 <mauke> dmwit: don't worry, that's not html (there is no <href> tag in html (right?))
16:18:02 <nicknull> why not?
16:18:02 <nicknull> Tagsoup
16:18:04 <dmwit> mauke: right
16:18:04 * byorgey <3 TagSoup
16:18:10 <nicknull> anyway why isnt it working?
16:18:18 <mauke> how is it not working?
16:18:43 <dons> nicknull: did you try just parsing it with tagsoup? getting the token stream?
16:19:01 <nicknull> no i will
16:19:14 <nicknull> right now im trying to use regexes
16:19:27 <nicknull> just to learn them in haskell
16:19:37 <mmorrow> what ghc are you using?
16:19:41 <mmorrow> (version)_
16:19:44 <mmorrow> s/_//
16:20:45 <nicknull> 6.8.3
16:20:54 <nicknull> how do i use \ ? since ghci complians about it
16:20:59 <nicknull> cnat prse it
16:21:27 <ozy`> how are you trying to use it?
16:21:43 <nicknull> ^^
16:21:52 <nicknull> "aa<href='google.com'>ffv" =~ "<href=[a-zA-Z0-9]*" :: Bool -> True
16:22:05 <nicknull> "aa<href='google.com'>ffv" =~ "<href=[a-zA-Z0-9]*>" :: Bool -> False
16:22:29 <dons> ah cool.
16:22:36 <dons> so you're using the Text.Regex lib?
16:22:39 <nicknull> yes
16:22:42 <dmwit> nicknull: That looks right.
16:22:57 <nicknull> .Posix
16:22:57 <nicknull> but doesnt work
16:22:57 <nicknull> as i want
16:23:05 <dmwit> nicknull: Notice that href is followed by a single quote, and google.com has a period, neither of which match your [a-zA-Z0-9] regex.
16:23:16 <nicknull> i want to match <href="something">
16:23:33 <mauke> ".*"
16:24:03 <dmwit> http://blogs.msdn.com/hackers/archive/2007/11/12/first-line-of-defense-for-web-applications-part-4.aspx
16:24:10 <lambdabot> Title: %41%43%45%20%54%65%61%6d : First Line of Defense for Web Applications – Part 4, http://tinyurl.com/5zxsao
16:24:48 <nicknull> "aa<href='google.com'>ffv" =~ "<href=[a-zA-Z0-9.]*>" :: Bool
16:24:48 <nicknull> -> False
16:24:48 <nicknull> do iabve to match the ' ' or ""
16:24:48 <nicknull> <href="google.com">
16:26:10 <byorgey> yes, so you probably want something like ['"] before and after the [a-zA-Z...
16:26:23 <byorgey> well, ['\"]
16:28:26 <nicknull> "aa<href='google.com'>ffv" =~ "<href=['][a-zA-Z0-9.]*[']>" :: Bool -> True
16:28:54 <dmwit> If there's only one character inside []'s, you can omit the []'s.
16:28:59 <dmwit> so, ['] -> '
16:30:13 <dmwit> Also, your regex won't match things like "<href='http://www.google.com/?q=a%20search&lang=en'>".
16:30:46 <dmwit> There's a stunning number of characters that are allowed in URLs, so if that's what you're trying to match... =)
16:31:05 <rwbarton> There's probably an even larger number of characters that appear in URLs.
16:31:25 <dmwit> heh
16:31:46 <mauke> dmwit: that's actually invalid html :-)
16:31:49 <dmwit> Yeah, at the risk of being repetitive... you really should use TagSoup for any real HTML munging.
16:31:54 <mauke> needs more &amp;
16:32:00 <dmwit> mauke: Right, I know.  s/'/"/g, and a few others things.
16:32:15 <dmwit> mauke: And yet most browsers would probably accept it.
16:32:16 <mauke> the ' should be fine
16:32:34 <dmwit> (And do what it means, even if not what it says.)
16:33:01 <dmwit> Actually, without the <a ...> part, they might not do what it means.
16:33:07 <dmwit> That might be too much of a stretch. =P
16:33:25 <nicknull> yes i will
16:33:33 <nicknull> i was just testing haskell-regexen :)
16:33:40 <nicknull> nw for some tagsouping
16:33:41 <ozy`> needs moar &amp;. no exceptions.
16:33:43 <mmorrow> nicknull: ah, when 6.10 comes out you can might like the regexqq package on hackage
16:33:47 <mmorrow> , [$rx| (-)? ([0-9]*) \. ([0-9]*) |] (show pi)
16:33:49 <lunabot>  Just ["3.141592653589793","","3","141592653589793"]
16:34:10 <mauke> oooh
16:34:20 <mmorrow> it uses an extension called quasiquotes enabled with -XQuasiQuotes
16:34:33 <ozy`> grooooovy
16:34:57 <nicknull> mmorrow: nice
16:35:32 <mmorrow> mauke: it's a really small amount of code and very hackable/customizable. it uses pcre-light as its backend, and i hardcoded a few regex opts, but i'm planning on adding a bunch to the pkg once people start actually being able to use it :)
16:35:51 <mmorrow> (since -XQuasiQuotes is ghc >= 6.9)
16:36:06 <mmorrow> ?hackage regexqq
16:36:06 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/regexqq
16:37:18 <mmorrow> also, pcre-light is a nice package too
16:38:46 <lispy> can someone on windows tell me what ghci prints for System.Info.os?
16:39:01 <dons> pcre-light roxors :)
16:39:56 <mauke> what's light about it?
16:40:40 <ahunter1> Erm, can someone point me to a good description of how to build a new Read instance?  Having trouble figuring out readsPrec
16:40:41 <mmorrow> it's a single module wrapper over libpcre
16:40:57 <mauke> ahunter1: the easiest way is 'deriving Read'
16:41:45 <ahunter1> mauke: no can do.  I have extant files I need to read properly which use a different format than the constructors of the datatype.
16:41:58 <dmwit> I recommend making a real parser, then.
16:42:34 <dmwit> Read is really supposed to be the dual of Show -- that is, for reading in a version that could just as well be dropped into Haskell source verbatim.
16:42:53 <dmwit> (Note: this is just my opinion, not the standard, and you can go ahead and ignore me if you prefer.)
16:42:57 <mmorrow> ahunter1: yeah, save Read for being able to Show/Read your datatype in /valid/ haskell syntax, and write a parser
16:43:00 <ahunter1> dmwit: seriously, there's no middle ground?  I mean, this is my read instance (except I can't just define read) http://hpaste.org/11268
16:43:14 <mmorrow> (...a parser for the non-haskell syntax)
16:43:40 <dmwit> ahunter1: Why does that function have to be called read?
16:43:41 <ahunter1> mmorrow/dmwit: I've heard that said before, yes, I just didn't consider this program heavyweight enough to deserve its own new parser...plus, I don't know parsec yet...
16:43:54 <dmwit> ahunter1: Just use the same function, but name it differently. ;-)
16:43:59 <ahunter1> dmwit: I suppose it doesn't.  I just defined read/show as dual to that format
16:44:06 <dmwit> parser /= parsec
16:44:06 <mmorrow> ahunter1: but your `read' function definition /is/ the parser. just don't call it read :)
16:44:12 <lispy> ahunter1: yeah, it's okay to derive (Read, Show), but if you plan to serialize the data in some existing format, make a parser.  Oh, parsec is nice :)
16:44:27 <dmwit> Also, yeah, Parsec is way nice.
16:44:45 <ahunter1> dmwit: true...when I think parser, though, I think full-out grammar, and I was under the impression that pretty much meant Parsec.
16:44:45 <mmorrow> and derive a Read instance so you can get for-free quicky serialization of your datatype
16:46:04 <mmorrow> and one option for the dual to parsec/whatever is Text.PrettyPrint
16:46:43 <mmorrow> so you can reserve your derived Show instance for actually showing you the data
16:48:11 <dons> new sigfpe, http://www.reddit.com/r/programming/comments/77zab/a_neighborhood_of_infinity_whats_the_use_of_a/
16:48:13 <lambdabot> Title: A Neighborhood of Infinity: What's the use of a transfinite ordinal? : programmi ..., http://tinyurl.com/5vbs55
16:50:26 <vixey> let ret foo x = ... foo y ...
16:51:42 <mmorrow> ahunter1: here's an example of using Text.PrettyPrint (this doesn't look so mangled when you have more than one line to write it..):
16:51:46 <mmorrow> , let (<+.>) = (Text.PrettyPrint.HughesPJ.<+>) ; fun (n,args,stmts) = text "function" <+.> text n <> parens (hcat . punctuate comma . fmap text $ args) <+.> text "{" $+$ nest 2 (vcat . fmap ((<>semi) . text) $ stmts) $+$ text "}" in fun ("id",["a"],["return(a)"])
16:51:47 <lunabot>  function id(a) {
16:51:47 <lunabot>    return(a);
16:51:47 <lunabot>  }
16:52:18 <mmorrow> (i had to do (<+.>) = (Text.PrettyPrint.HughesPJ.<+>) since there's another (<+>) in scope in lunabot)
16:52:53 <nicknull> tagsoup seems mostly bools, how do i do findStrinOfTag [tags]
16:53:02 <dmwit> byorgey: HWN's comment on sortOn seems a bit broken...
16:53:19 <ahunter1> hmm
16:53:33 <byorgey> oh?
16:53:58 <byorgey> ah! so it is
16:54:15 <byorgey> it thought the [] in the type signature was a link
16:56:16 <Peaker> ghc 6.9 wants glibc 2.8 (my glibc is just 2.7).  Why does it care about the glibc so specifically?
16:56:17 <byorgey> thanks dmwit, fixed on sequence.complete.org
16:56:47 <dmwit> I think the parens are still a little wonky.
16:57:33 <kynky> maybe it needs the newer glibc to implement a new way  of doing something more efficiently ?
16:57:34 <byorgey> the parens are as I intended them to be.
16:57:42 <byorgey> whether that is wonky is a matter of opinion.
16:57:48 <dmwit> ok =)
16:57:51 <byorgey> =)
16:57:53 <nicknull> tagsoup seems mostly bools, how do i do findStrinOfTag [tags]
16:57:58 <dons> mostly bools?
16:58:27 <dons> ?seen ndm
16:58:28 <lambdabot> I haven't seen ndm.
16:58:40 <dons> i usually use list comprehensions to filter
16:58:49 <mauke> preflex: seen ndm
16:58:49 <preflex>  ndm was last seen on #xmonad 51 days, 7 hours, 24 minutes and 36 seconds ago, saying: cool :)
16:59:50 <nicknull> result type bool
17:00:32 <nicknull> parseTags :: String -> [Tag] , i want to do: lookup sometag tags, and get a string
17:00:56 <dons> right, so let's see if i can do a little example for you
17:01:38 <nicknull> also, how do i open an "url" ina file in my computer instead of a real url ith openUrl?
17:01:41 <dons> do you know how to use list comprehensions?
17:01:48 <dons> oh, just readFile
17:02:07 <dons> or use download or download-curl libraries :)
17:03:26 <nicknull> oh sure lol
17:03:51 <nicknull> didnt eealize it was just na iostring
17:07:57 <dons> nicknull: http://hpaste.org/11269
17:08:05 <dons> so that shows how to use parseTags to get a list of tags
17:08:10 <dons> then we filter the list for only TagText elements
17:08:13 <dons> which get printed.
17:08:16 <dons> you can filter on other things
17:08:23 <dons> oh, we also throw away newline text
17:08:46 <dons> just use pattern matching on the tag to decide which ones to keep
17:12:13 <ozy`> > unwords . lines "text\nsplit across\nseveral lines"
17:12:15 <lambdabot>   Couldn't match expected type `a -> [String]'
17:12:31 <ozy`> > (unwords . lines) "text\nsplit across\nseveral lines"
17:12:32 <lambdabot>   "text split across several lines"
17:12:55 * ozy` grumbles something about memorizing operator application order
17:13:04 <conal> can a .cabal specify that some modules are to be included only under a condition like ghc>=6.10 ?
17:13:11 <Eridius> ozy`: you could have used $ instead of . in the first try
17:13:16 <Eridius> > unwords $ lines "text\nsplit across\nseveral lines"
17:13:18 <lambdabot>   "text split across several lines"
17:13:26 <Peaker> conal: did you fix vector-space to compile with 6.10?
17:13:29 <ozy`> Eridius: yeah I know
17:13:43 <conal> Peaker: yeah.  i added a bug work-around.
17:13:48 <Peaker> conal: cool
17:14:03 <conal> and now i have some new code i want to blog about that works only in 6.10+ .
17:14:19 <conal> Peaker: i've also trac-reported the ghc bug
17:16:00 <rdmltrs> does anyone know the type (or is there one) of the (<-) used to get the value out of an IO action like,
17:16:01 <Peaker> conal: I love your blog! :)
17:16:08 <rdmltrs> c<-getChar
17:16:14 <Eridius> rdmltrs: unsafePerformIO?
17:16:23 <dmwit> rdmltrs: It's sugar.
17:16:24 <rwbarton> rdmltrs: It's special syntax
17:16:25 <dons> nicknull: did that link help?
17:16:27 <dmwit> (syntax)
17:16:27 <mauke> rdmltrs: <- is not an operator and doesn't have a type
17:16:35 <Eridius> oh I misread your question
17:16:52 <Eridius> a <- b is just syntax for b >>= (\a -> ...)
17:16:53 <conal> Peaker: :) !!
17:16:55 <dmwit> rdmltrs: If you write do { c <- getChar; foo }, that's the same as writing getChar >>= \c -> foo
17:17:04 <ahunter1> Am I missing some sort of standard Data.Map function for map composition?
17:17:12 <rdmltrs> ahh okay
17:17:18 <ahunter1> I.e. I'm looking for a type signature of (about) Map a b -> Map b c -> Map a c
17:17:32 <rdmltrs> thanks everyone
17:17:34 <rwbarton> @hoogle Map a b -> Map b c -> Map a c
17:17:34 <lambdabot> Control.Arrow (>>>) :: Arrow a => a b c -> a c d -> a b d
17:17:35 <lambdabot> Control.Arrow (<<<) :: Arrow a => a c d -> a b c -> a b d
17:17:35 <lambdabot> Data.Map (\\) :: Ord k => Map k a -> Map k b -> Map k a
17:17:43 <rwbarton> I don't think so
17:17:45 <dmwit> ahunter1: I do not believe Data.Map has such a function.
17:17:48 <nicknull> dons: yes thanks
17:17:55 * lispy notes that while <- is not an op and has no type, -> is an operator with a type
17:18:01 <lispy> :t (->
17:18:02 <lambdabot> parse error on input `->'
17:18:03 <lispy> :t (->)
17:18:04 <lambdabot> parse error on input `->'
17:18:12 <lispy> well, type constructor
17:18:16 <ozy`> lispy: I just tried that actually and noted that it didn't work ;)
17:18:17 <lispy> So I guess it has a kind
17:18:19 <ozy`> neither does \
17:18:23 <lispy> :t ->
17:18:24 <lambdabot> parse error on input `->'
17:18:28 <dmwit> :k (->)
17:18:29 <lispy> :kind ->
17:18:29 <lambdabot> ?? -> ? -> *
17:18:29 <Eridius> does lambdabot do :info ?
17:18:33 <dmwit> Eridius: no
17:18:52 <rwbarton> Eridius: lunabot does some things which are like :info
17:19:04 <dmwit> ?info do { info autocorrects; it becomes undo }
17:19:04 <lambdabot> info autocorrects >> it becomes undo
17:19:52 * lispy finds it amusing that certain anatomy parts autocorrect to oeis, the db of math sequences
17:22:50 <ddarius> There are many uses of -> where it is not an operator.
17:22:50 <lispy> ddarius: I really should have called it a type constructor and said it has a kind
17:22:50 <lispy> I totally mispoke
17:22:50 * ddarius whips lispy.
17:22:50 <dcoutts> conal: yes
17:22:50 <conal> dcoutts: please tell
17:23:12 <dcoutts> conal: use: if impl(ghc >= 6.10) { exposed-modules: Blah }
17:24:12 <conal> dcoutts: oh!  i assumed the if would nest inside an exposed-modules section.  thx.
17:24:40 <dcoutts> conal: if's guard fields, not their contents
17:26:42 <conal> dcoutts: makes sense now.  and it works for me.  i also didn't realize that i could have multiple exposed-modules sections and they'd concatenate
17:27:23 <dcoutts> conal: aye. I realised that all fields are monoids of one sort or another
17:27:27 <nicknull> what is a common tag?
17:28:36 <conal> dcoutts: including the First/Last
17:28:43 <lispy> nicknull: <p> ?
17:28:44 <conal> dcoutts: ... monoid?
17:29:08 <lispy> nicknull: also, <html> :)
17:29:10 * ddarius never uses <p>
17:29:19 <dcoutts> conal: right, either first, last or list
17:29:32 <ozy`> <p> always misbehaves when I least expect it
17:29:43 <ozy`> styled divs are better
17:29:45 <conal> dcoutts: neat!
17:29:59 <dcoutts> conal: command line flags are the same
17:30:40 <nicknull> getTag :: String -> [Tag] -> [String]
17:30:49 <nicknull> getTag tag ts = [t | TagText t <- ts, t == tag]
17:30:58 <nicknull> hmm that is a wrong way ti match?
17:31:03 <nicknull> t == tag
17:33:33 <conal> dcoutts: another example of conor's "types don't just contain data, types explain data."
17:33:39 <nicknull> how do i match the tag insetad of the text? Tag doesnt work
17:34:17 <dcoutts> conal: indeed
17:37:09 <lispy> nicknull: you need the tag t, and the string tag to be the same type
17:38:04 <lispy> nicknull: when I look at your type for getTag, the first thing I wonder, is why you didn't use, getTag :: Tag -> [Tag] -> [Tag]
17:38:41 <nicknull> lol
17:38:53 * lispy has never used tag soup though
17:40:03 <nicknull> but what is the tag then? <head> for example. Head doesnt work, not <head>
17:40:36 <Peaker> @hoogle TagText
17:40:36 <lambdabot> No results found
17:41:51 <dons> nicknull: yo have to match on one of the constructors of the Tag type
17:42:08 <dons> nicknull: http://hackage.haskell.org/packages/archive/tagsoup/0.6/doc/html/Text-HTML-TagSoup.html#t%3ATag
17:42:14 <lambdabot> Title: Text.HTML.TagSoup, http://tinyurl.com/6rccdf
17:42:19 <dons> i.e. TagOpen/TagClose/TagText etc
17:42:32 <dons> play around in ghci, printing the result of parseTaggs
17:42:33 <lispy> oh, that makes a lot of sense
17:42:35 <dons> to see what you can do
17:43:10 <maestrolinux> http://s2.ar.bitefight.org/c.php?uid=19732 hello --!!! hola alguien me ayuda con esto
17:43:24 <lambdabot> Title: BiteFight Server 2 -
17:44:02 --- mode: ChanServ set +o dons
17:44:04 --- mode: dons set +b *!*n=eduardo@190.13.230.*
17:44:04 --- kick: maestrolinux was kicked by dons (dons)
17:44:07 --- mode: ChanServ set -o dons
17:44:08 <lispy> maestrolinux: is that based on HAppS?
17:44:15 <lispy> lol
17:44:20 <lispy> guess not :)
17:44:25 <dons> bit of spamming going on today
17:45:04 <vixey> :(
17:45:09 <vixey> spam is soooooo annoying
17:50:04 <nicknull> getTag tag ts = [t | t <- ts, t == TagOpen tag]
17:50:08 <rwbarton> @pl \x -> do { y <- f x; return $ fromMaybe x y }
17:50:08 <lambdabot> (line 1, column 10):
17:50:08 <lambdabot> unexpected "{"
17:50:08 <lambdabot> expecting variable, "(", operator or end of input
17:50:09 <nicknull> use my spamfilter
17:50:26 <rwbarton> @. pl undo \x -> do { y <- f x; return $ fromMaybe x y }
17:50:27 <lambdabot> liftM2 (>>=) f ((return .) . fromMaybe)
17:51:10 <lispy> rwbarton: oh, you want to do something in the maybe monad using a default?
17:51:11 <rwbarton> @pl \x -> fromMaybe x `fmap` y x
17:51:11 <lambdabot> liftM2 fmap fromMaybe y
17:51:26 <nicknull> what is tagopen::string? then Attritbue
17:51:31 <rwbarton> I want to do something in another monad, with a Maybe a result, and set a default
17:52:03 <lispy> rwbarton: setting a default is mplus I think
17:52:19 <rwbarton> Right, but also I don't want to return a Just foo
17:52:25 <lispy> well, \x y -> Just x `mplus` y
17:52:46 <lispy> well, \x y -> fromJust (Just x `mplus` y)
17:52:56 <lispy> oh wait
17:52:59 <rwbarton> Yeah, I think that ends up being longer
17:53:00 <dmwit> fromMaybe x y -- much nicer
17:53:01 <rwbarton> other order
17:53:02 <lispy> put the just x on the othre side
17:53:14 <rwbarton> I like fromMaybe x `fmap` y x
17:53:25 <lispy> :t fromMaybe.
17:53:26 <lambdabot> parse error (possibly incorrect indentation)
17:53:28 <lispy> :t fromMaybe
17:53:29 <lambdabot> forall a. a -> Maybe a -> a
17:53:44 <adu> :t fromChaos
17:53:45 <lambdabot> Not in scope: `fromChaos'
17:53:46 <lispy> oh, you are certainly riht, I just wrote a wonky fromMaybe
17:53:51 <dmwit> rwbarton: Me too, very pretty.
17:53:59 <adu> :t order
17:54:00 <lambdabot> Not in scope: `order'
17:54:21 <adu> :t flip
17:54:22 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
17:55:46 <rwbarton> @type \x -> fromMaybe x `fmap` ?f x
17:55:47 <lambdabot> forall a (f :: * -> *). (Functor f, ?f::a -> f (Maybe a)) => a -> f a
17:55:51 <lispy> ?where camp
17:55:51 <lambdabot> I know nothing about camp.
18:01:49 <nicknull> print $ getTag (TagClose "</head>") tags
18:01:54 <nicknull> getTag tag ts = [t | t <- ts, t == tag]
18:01:58 <nicknull> that compiles
18:02:02 <nicknull> but faisl to find
18:02:10 <dons> so that filters out anything that matches 'tag'
18:02:17 <dons> sorry, keeps.
18:02:23 <nicknull> what are attributes? everythign between opena nd close?
18:02:24 <mmorrow> lunabot has tagsoup
18:02:26 <mmorrow> , parseTags "<ol><li><a href=\"#\">asdf</a></li><li>42</li></ol>"
18:02:28 <lunabot>  [TagOpen "ol" [],TagOpen "li" [],TagOpen "a" [("href","#")],TagText "asdf...
18:03:03 <mmorrow> so it can help with explanations/etc.. :)
18:03:22 <nicknull> ah
18:03:30 <lispy> ?where+ Camp http://projects.haskell.org/camp/
18:03:30 <lambdabot> Okay.
18:03:52 <mmorrow> hmm, i sould probably add a big string literal full of html too
18:04:07 <mmorrow> or else it's kind of a pita
18:04:15 <mmorrow> since no IO and all
18:07:53 <lispy> mmorrow: you could add a feature that fetches a website and makes the resulting tag soup available
18:08:20 <nicknull> hmm tags in a Map would be nice
18:08:27 <nicknull> getTag tag ts = [t | TagText t <- ts, t == tag]
18:08:30 <nicknull> print $ getTag "head" tags
18:08:56 <dons> well, tagsoup is just a lexer. actually parsing it might be done with say, xml-light
18:09:10 <rwbarton> or you can just make a module exporting a function which unsafePerformIOs anything you trust
18:11:27 <nicknull> could it take insanely long time to parse haskell.org like ^^
18:11:27 <nicknull> a listcomrpehension cant loop infinetly right?
18:12:48 <mmorrow> lispy: that a great idea. i was also thinking of adding a web interface to luna as well.
18:12:55 <mmorrow> *that's
18:14:45 <mmorrow> rwbarton: hmm, that might be nice too, but i'd have to think about what that would means first
18:15:14 <mmorrow> rwbarton: did that eval work for you?
18:15:52 <mmorrow> ok, woohoo
18:16:01 <mmorrow> , html_pages
18:16:07 <lunabot>  [("http://en.wikipedia.org/wiki/Haskell_(programming_language)","<!DOCTYP...
18:16:07 <lambdabot> http://en.wikipedia.org/wiki/Haskell_(programming_language)","<!DOCTYP..
18:16:10 <mmorrow> one page so far
18:16:16 <mmorrow> it's haskell's wikipedia entry
18:16:33 <mmorrow> , src 'html_pages
18:16:38 <lunabot>  html_pages :: [(String, String)]
18:16:46 <rwbarton> mmorrow: I actually think I won't need it
18:16:50 <nicknull> fileN :: (PrintfType t1, PrintfArg t, Enum a) => a -> t -> t1
18:16:55 <rwbarton> mmorrow: I'm trying to write a command-line @uncategory-extras
18:17:01 <rwbarton> mmorrow: it's called oldtype :)
18:17:04 <nicknull> passed to readFile :: FilePath -> IO String
18:17:07 <nicknull> doesnt work
18:17:09 <mmorrow> rwbarton: oh nice
18:17:13 <nicknull> mbiguous type variable `t' in the constraints:
18:17:14 <mmorrow> heh, oldtype
18:17:31 <rwbarton> mmorrow: how do you get it to show [a] and not [] a?
18:17:51 <mmorrow> rwbarton: that single module though should give you eval + run + all that functionality in about 50 lines though, and it's completely self-contained
18:18:10 <mmorrow> ConT (mkName "[]")   vs.    ListT
18:18:17 <mmorrow> , ppDoc ListT
18:18:19 <lunabot>  []
18:18:26 <mmorrow> err
18:18:36 <nicknull> mbiguous type variable `t' in the constraints:
18:18:40 <nicknull> oops
18:18:40 <rwbarton> Oh, it's a special case in typeToName
18:18:45 <mmorrow> , ppDoc (AppT ListT (mkName "Int"))
18:18:47 <lunabot>  luna: Couldn't match expected type `Language.Haskell.TH.Syntax.Type'
18:18:56 <mmorrow> , ppDoc (AppT ListT (ConT (mkName "Int")))
18:18:58 <lunabot>  [Int]
18:19:08 <mmorrow> , ppDoc (AppT (ConT (mkName "[]")) (ConT (mkName "Int")))
18:19:11 <lunabot>  [] Int
18:19:28 <mmorrow> rwbarton: exactly
18:20:11 <rwbarton> Yeah, I'm using your cleanNames and the input looks like GHC.Base.[] GHC.Base.Char
18:20:43 <mmorrow> and the output is clean, right?
18:20:52 <rwbarton> [] Int
18:21:00 <mmorrow> oh, i see what you're saying
18:21:11 <nicknull> ah i just added my own types
18:22:04 <mmorrow> rwbarton: code to normalize ListT/etc and the code to `src' is in this one http://moonpatio.com/repos/luna-meta-devel/src/Luna/Devel/Meta.hs
18:22:39 <rwbarton> mmorrow: Ah.  Nice triangle of ,s there
18:22:52 <mmorrow> hehe, i dug it :)
18:23:15 <psu500w> How would you connect Rails and Haskell, so that Haskell handles the heavy-duty processing and Rails just presents contents to the end user?
18:23:34 <dmwit> psu500w: Probably the easiest thing is to connect at a process boundary.
18:23:39 <dmwit> Just open up a pipe or so.
18:23:50 <mmorrow> the TH Ppr is slightly buggy also. i'm trying to track them all down so i can submit a patch..
18:24:20 <rwbarton> Yeah, it seems to be missing parentheses pretty often
18:24:21 <mmorrow> (e.g. it'll omit parens in tysigs sometimes in such a way that changes the type)
18:24:30 <psu500w> dmwit: ok, thanks
18:25:11 <rwbarton> mmorrow: I don't suppose luna Utils.hs + Meta.hs are on hackage somewhere?
18:25:17 <mmorrow> rwbarton: i'll paste a fixed Ppr.hs, then just  s/import Language.Haskell.TH.Ppr/Ppr/
18:25:31 <vixey> what is meta-devel
18:25:31 <psu500w> Assume that my machine has 8 cores. Will Haskell be able to use all of them for CPU-bound processing?
18:25:55 <mmorrow> rwbarton: not yet, once 6.10 is out i'm gonna put it up
18:26:09 <mmorrow> psu500w: oh yesh
18:26:10 <dmwit> psu500w: Check out the parallelization efforts on the benchmark game.
18:26:16 <dmwit> psu500w: Haskell is pretty good at concurrency.
18:26:18 <rwbarton> psu500w: Yes, if you have a task with sufficient parallelism, and you add parallelism annotations
18:26:29 <dmwit> (Though of course you have to give it hints, no surprises there.)
18:26:31 <rwbarton> psu500w: Or use forkIO for easy threading
18:26:44 <psu500w> mmorrow, rwbarton, dmwit: that's great
18:26:59 <dmwit> ?faq Can Haskell max out my octocore?
18:26:59 <lambdabot> The answer is: Yes! Haskell can do that.
18:27:05 <dmwit> ;-)
18:27:18 <psu500w> Is http://learnyouahaskell.com/ any good to get started?
18:27:23 <lambdabot> Title: Learn You a Haskell for Great Good!
18:27:25 <dmwit> That's a fine place.
18:27:36 <ozy`> ?faq Can Haskell blah blah blah side effects?
18:27:37 <lambdabot> The answer is: Yes! Haskell can do that.
18:27:37 <dmwit> Real World Haskell is nice, too, as is the Gentle Introduction.
18:27:47 <dmwit> ?where RWH
18:27:48 <lambdabot> is http://www.realworldhaskell.org/blog/
18:27:50 <dmwit> ?where gentle
18:27:51 <lambdabot> http://www.haskell.org/tutorial/
18:28:15 <dmwit> ?where+ RWH http://www.realworldhaskell.org/blog/
18:28:15 <lambdabot> I will never forget.
18:28:24 <dons> haskell can certainly max out your octocore :)
18:28:44 <mmorrow> rwbarton: here's a Ppr.hs with a quick hacky fix for the parens thing. it's not always pretty (sometimes adds extraneous parens), but it's at least correct
18:28:46 <mmorrow> http://moonpatio.com/repos/Ppr.hs
18:29:10 <mmorrow> , src ''Algebra
18:29:14 <lunabot>  type Algebra f a = (f a) -> a
18:29:27 <mmorrow> xtraneous parens ^^^^^^^
18:29:49 <psu500w> dons: I'm interested in number theory. Is Haskell a suitable language for that?
18:30:12 <dons> i can't think of a more suitable programming language for number hacking
18:30:18 <mmorrow> psu500w: it's suitable for expressing abstract concept cleanly and directly
18:30:34 <mmorrow> *concepts
18:31:08 <mmorrow> computational?
18:31:18 <psu500w> yes mmorrow
18:32:13 <mmorrow> this page has some good links http://haskell.org/haskellwiki/Applications_and_libraries/Mathematics
18:32:17 <lambdabot> Title: Applications and libraries/Mathematics - HaskellWiki, http://tinyurl.com/2rt3uv
18:32:56 <mmorrow> and there's DoCon, although i haven't personally used it http://haskell.org/docon/
18:32:57 <lambdabot> Title: DoCon the Algebraic Domain Constructor
18:33:25 <dons> we should get docon on hackage...
18:33:41 <mmorrow> hmatrix is good for matlab-type stuff http://www.hmatrix.googlepages.com/
18:33:41 <lambdabot> Title: - hmatrix
18:33:48 <dons> all these russian guys writing haskell code, so little of it ending up on hackage
18:33:49 <mmorrow> dons: we should definitely
18:33:54 <mmorrow> heh
18:35:52 <mmorrow> , parseTags . snd $ html_pages !! 0
18:35:56 <lunabot>  [TagOpen "!DOCTYPE" [("html",""),("PUBLIC",""),("","-//W3C//DTD XHTML 1.0...
18:36:00 <dons> cute
18:37:53 <dmwit> , html_pages
18:37:56 <lunabot>  [("http://en.wikipedia.org/wiki/Haskell_(programming_language)","<!DOCTYP...
18:37:57 <lambdabot> http://en.wikipedia.org/wiki/Haskell_(programming_language)","<!DOCTYP..
18:38:58 <dmwit> , map fst . tail $ html_pages
18:39:02 <lunabot>  []
18:39:08 <dmwit> oooookay
18:40:16 <lispy> , head $ map fst $ html_pages
18:40:20 <lunabot>  "http://en.wikipedia.org/wiki/Haskell_(programming_language)"
18:40:22 <lambdabot> Title: Haskell (programming language) - Wikipedia, the free encyclopedia
18:40:32 <lispy> , head $ map snd $ html_pages
18:40:36 <lunabot>  "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n      ...
18:41:26 <lispy> , tail $ map snd $ html_pages
18:41:31 <lunabot>  []
18:41:54 <mmorrow> , nub [ fromJust (lookup "href" attrs) | TagOpen "a" attrs <- parseTags (snd $ html_pages !! 0) , "href" `elem` map fst attrs]
18:41:58 <lunabot>  ["/haskellwiki/Haskell","/haskellwiki/HaskellWiki:Community","/haskellwik...
18:43:56 <mmorrow> could be more efficient by looking up the link at the same time it checks for it
18:44:21 <mmorrow> , fmap (length . snd) html_pages
18:44:26 <lunabot>  [23019]
18:44:35 <mmorrow> , fmap (length . lines . snd) html_pages
18:44:40 <lunabot>  [379]
18:45:57 <nicknull> why does "sds\n |" =~ pat :: Bool -> True when pat=
18:46:05 <nicknull> pat = "[a-zA-Z0-9.!?,;:]"
18:46:20 <nicknull> oh wait
18:46:35 <mauke> > 's' `elem` ['a' .. 'z']
18:46:36 <lambdabot>   True
18:47:26 <twfxfnf> > error $ shell "error\n"
18:47:27 <lambdabot>   Not in scope: `shell'
18:48:05 <twfxfnf> >foldr (+) 1 (map (*) [1..100])
18:48:27 <twfxfnf> > foldr (+) 1 (map (*) [1..100])
18:48:28 <lambdabot>       No instance for (Num (a -> a))
18:48:28 <lambdabot>        arising from a use of `+' at <int...
18:48:34 <rwbarton> I wish TH were more strongly typed... with GADTs say
18:48:47 <mmorrow> rwbarton: you can layer that on
18:48:48 <twfxfnf> > foldr (+) 1 (map (^2) [1..100])
18:48:49 <lambdabot>   338351
18:48:55 <twfxfnf> good boy
18:49:11 * twfxfnf kicks lambdabot
18:49:14 <mmorrow> but if it was there by default, you wouldn't be able to do half of what you can
18:50:19 <mmorrow> newtype T a t = T (Q a)
18:50:35 <mmorrow> or sumpin
18:50:50 <nicknull> foldr (-) 0 [1..5]
18:50:55 <nicknull> foldr (-) 0 [1..5]
18:50:59 <mmorrow> > 42
18:51:01 <lambdabot>   42
18:51:02 <nicknull> @eval donkeybot
18:51:08 <nicknull> 42
18:51:10 <mmorrow> fail
18:51:26 <nicknull> am i banned from evaling?
18:51:32 <mmorrow> > fail "donkeybot" :: IO ()
18:51:33 <lambdabot>   * Exception: "<IO ()>"
18:51:43 <nicknull> 42
18:52:45 <dancor> am i a bad person if i feel like doing   f (isPrefixOf a . g)   instead of   f ((a `isPrefixOf`) . g)
18:52:46 <mauke> @help eval
18:52:46 <lambdabot> eval. Do nothing (perversely)
18:52:54 <nicknull> pat = "[a-zA-Z0-9.!?,:]*[^;|\n{}]"
18:53:03 <psu500w> This is just beautiful: foldr (+) 1 (map (^2) [1..100])
18:53:03 <nicknull> i want to match [a-zA-Z0-9.!?,:]
18:53:08 <nicknull> but not the other
18:53:55 <vixey> @let squares = map (join (*))
18:53:56 <sjanssen> dancor: you're not a bad person
18:53:57 <lambdabot>  Defined.
18:54:06 <vixey> > (sum . squares . const [1.100]) ()
18:54:08 <lambdabot>       No instance for (Fractional Integer)
18:54:08 <lambdabot>        arising from the literal `1...
18:54:13 <vixey> > (sum . squares . const [1..100]) ()
18:54:15 <lambdabot>   338350
18:54:15 <dmwit> dancor: Definitely not.
18:54:35 <dancor> it feels like lying since i'm not checking if something is a prefix of a
18:54:52 <lispy> dancor: they are both nice, but I do prefer the second one.  I might even go further and make the parameters explicit.
18:54:57 <dmwit> psu500w: Even more beautiful is sum (map (^2) [1..100]). ;-)
18:54:59 <vixey> dancor: Rename the function
18:55:15 <lispy> dancor: wait, you're not?
18:56:27 <dancor> lispy: ?   in current case, i have   uncalate glue s = case find (isPrefixOf glue . snd) $ allBreak s of ..
18:59:12 <nicknull> how do i say ina regexp, cannot contain [some_chars] ?
18:59:43 <nicknull> oh wait
18:59:55 <dmwit> [^some_chars]
19:01:14 <lispy> dancor: oh, I see what you mean
19:01:29 <lispy> dancor: you're refering to the parameter order
19:02:45 <mmorrow> ,  filter ("monad"`isInfixOf`) . concat $ [ (words . map toLower) txt | TagText txt <- parseTags (snd $ html_pages !! 0)]
19:02:49 <lunabot>  ["monad.reader","monadlab","monads"]
19:03:18 <mmorrow> ,  filter ("pure"`isInfixOf`) . concat $ [ (words . map toLower) txt | TagText txt <- parseTags (snd $ html_pages !! 0)]
19:03:23 <lunabot>  ["purely"]
19:05:38 <lispy> , filter ("Simon"`isInfixOf`) . concat $ [ (words . map toLower) txt | TagText txt <- parseTags (snd $ html_pages !! 0)]
19:05:44 <lunabot>  []
19:05:49 <mmorrow> i did map toLower
19:05:51 <lispy> what, no mention of the simons?
19:06:06 <mmorrow> ,  filter ("simon"`isInfixOf`) . concat $ [ (words . map toLower) txt | TagText txt <- parseTags (snd $ html_pages !! 0)]
19:06:12 <lunabot>  []
19:06:14 <lispy> oh, duh
19:06:19 <lispy> still, no simon
19:06:28 <mmorrow> hmm, TagText must not be picking stuff up
19:06:56 <mmorrow> i haven't lookup at the dump of the parsed tags either to know how to take it apart
19:07:43 <dons> yeah, that's best done interactively in ghci, in my experience.
19:07:52 <mmorrow> the wikimarkup might be messing with it
19:07:57 <mmorrow> yeah for sure interactively
19:07:59 <dons> explore the shape of the parse, and deconstruct it
19:09:18 <mmorrow> if it wan't for ghci, i don't know whattf i'd do..
19:09:34 <lispy> mmorrow: you'd use hugs ;)
19:09:47 <mmorrow> lispy: heh. ok, it it wasn't for a repl...
19:09:52 <mmorrow> s/it/if/
19:14:01 <rwbarton> Are partially-applied type synonyms ever allowed?
19:14:24 <ddarius> rwbarton: No.
19:14:26 <dolio> There's a GHC extension where they are in certain cases.
19:14:54 <dolio> But other than that...
19:15:15 <rwbarton> Which cases?
19:15:32 <rwbarton> Ah, found it
19:15:45 <dolio> I think it's only when expanding one type synonym fully applies another partially applied one or something of the sort.
19:16:05 <rwbarton> That's what I found.
19:16:27 <rwbarton> OK, so I can expand type synonyms lazily and they should always be fully applied when I encounter them
19:17:50 <dolio> Yeah. type Foo a b = a -> b ; type Bar f b = f b ; iid :: Bar (Foo a) b ; iid a = a
19:17:56 <nicknull> ouldn't match expected type `[Char]'
19:17:56 <nicknull>            against inferred type `IO [Char]'
19:17:56 <nicknull> why is that a problem if both are do-constructs?
19:17:59 <dolio> That works with -fglasgow-exts.
19:19:32 <dolio> That should be 'Bar (Foo a) a' of course.
19:20:45 <pastorn> nicknull: alias values you get that are bound in io with f = do { x <- getIOVal; return (fun x);}
19:21:00 <pastorn> and if you have a non-io function you do like this:
19:21:27 <pastorn> f = do { x <- getIOVal; let y = fun x; return y;}
19:28:52 <rwbarton> There's a runIO :: IO a -> Q a, so why isn't Q an instance of MonadIO?
19:30:10 <dolio> To avoid an MTL dependency?
19:30:28 <rwbarton> Hmm, plausible
19:30:29 <nicknull> http://hpaste.org/11270
19:30:39 <nicknull> i just want to generate a list of filenames
19:30:48 <nicknull> and parse them
19:31:10 <nicknull> wait i see
19:31:48 <nicknull> i dont
19:32:26 <inimino> :t printf
19:32:27 <lambdabot> forall r. (PrintfType r) => String -> r
19:32:30 <nicknull> parseFile workds
19:32:42 <nicknull> but parseFiles doesnt
19:32:46 <nicknull> or compiles
19:32:51 <nicknull> but fk up when run
19:33:46 <inimino> oh, huh, printf can return a String
19:35:42 <nicknull> it works
19:36:23 <nicknull> how do i print m [[IO [Char]]]
19:36:39 <dons> heh so that's a nested list of IO actions eh?
19:36:50 <dons> foldl1 (\x y -> x ++ " " ++ y) text
19:36:59 <dons> looks like: intercalate " "
19:37:05 <dons> :t intercalate
19:37:06 <nicknull> wait
19:37:06 <lambdabot> forall a. [a] -> [[a]] -> [a]
19:37:11 <nicknull> lol yes im tired
19:37:23 <dons> > intercalate "X" (words "hey there is something")
19:37:25 <lambdabot>   "heyXthereXisXsomething"
19:37:53 <dons> parseFiles is a bit werid
19:38:35 <nicknull> where is intercalate
19:38:39 <dons> Data.List
19:38:43 <dons> ?hoogle intercalate
19:38:43 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
19:38:43 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
19:38:43 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
19:39:04 <dons> i think i'd use a list comprehension here
19:39:52 <dons> something like,
19:39:54 <dons> parseFiles =
19:39:54 <dons>     sequence [ parseFile d f
19:39:54 <dons>              | d <- [start_dir .. stop_dir]
19:39:54 <dons>              , f <- [1..999]
19:39:56 <dons>              ]
19:40:02 <dons> (untested)
19:40:40 <dons> but a lot easier to grok, imo.
19:40:40 <nicknull> but ouldn't match expected type `Char'
19:40:41 <nicknull>            against inferred type `IO [Char]'
19:40:59 <nicknull> i thought i could be as naughty as i wanted in a do-construct?
19:41:07 <nicknull> and side-effect as mucha s i want
19:41:12 <dons> what's the type of parseFile ?
19:41:50 <nicknull> parseFile :: Int -> Int -> IO [Char]
19:41:57 <dons> ok.
19:42:23 <nicknull> i ahve a list of [[string io i guess]]
19:42:31 <nicknull> and i want to fold over them
19:42:35 <nicknull> ++
19:42:53 <dons> sequence
19:43:02 <dons> since they're monadic, you want to fold *and* run them
19:43:06 <dons> returning the resulit
19:43:08 <dons> :t sequence
19:43:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:43:20 <dons> takes a list of monadic actions, and gives you a list of results
19:44:01 <dons> nicknull: btw, http://hpaste.org/11271
19:44:11 <lispy> :t sequence (undefined :: [IO String])
19:44:12 <lambdabot> IO [String]
19:44:20 <dons> i think the nested list comprehension approach is a good bit cleaner
19:45:05 <dmwit> :t sequence . map sequence
19:45:07 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[m a]] -> m [[a]]
19:45:36 <lispy> :t zipWith sequence
19:45:37 <lambdabot> forall a b. [[b -> a]] -> [b] -> [[a]]
19:45:44 <mauke> ok, now breadth first
19:46:06 <dons> anyone want to write a binding to the mozilla javascript interpreter, http://developer.mozilla.org/En/SpiderMonkey/JSAPI_User_Guide
19:46:07 <lambdabot> Title: JSAPI User Guide - MDC
19:46:14 <dons> might be a useful project
19:46:22 <lispy> That would be a useful project I bet
19:47:27 <lispy> particularly if you want to write a webbrowser in Haskell :)
19:47:34 <inimino> what would a Haskell binding to spidermonkey look like?
19:47:40 <nicknull> ot in scope: `</>'
19:47:51 <lispy> ?hoogle (</>)
19:47:52 <lambdabot> System.FilePath.Posix (</>) :: FilePath -> FilePath -> FilePath
19:47:52 <lambdabot> System.FilePath.Windows (</>) :: FilePath -> FilePath -> FilePath
19:48:15 <SamB_XP> dons: why to the mozilla one in particular ?
19:48:27 <SamB_XP> isn't that the second-slowest in the industry ?
19:48:48 <SamB_XP> (after IE's, obviously)
19:49:03 <inimino> you mean the third-fastest?
19:49:33 <SamB_XP> inimino: perhaps!
19:49:47 <mauke> ｔｒａｃｅｍｏｎｋｅｙ
19:49:50 <lispy> SamB_XP: is webkit's javascript faster?
19:49:57 <SamB_XP> think so
19:50:10 <dolio> It was big news a while ago.
19:50:14 <SamB_XP> webkit's and V8 seem to be duking it out
19:50:53 <lispy> are they on the shootout yet?
19:51:39 <twfxfnf> > error "EXCEPTION: EXCEPTION: EXCEPTION:"
19:51:40 <lambdabot>   * Exception: EXCEPTION: EXCEPTION: EXCEPTION:
19:51:50 <dmwit> danger Danger DANGER
19:52:02 <lispy> I think being able to run Haskell code, probably with a non-standard prelude and IO facilities, on webpages would be nice
19:53:29 <inimino> the lengths people will go to to avoid writing a little JavaScript ;-)
19:54:17 <inimino> isn't there a ridiculously slow Haskell to JavaScript compiler already?
19:54:25 <rwbarton> inimino: Yes
19:54:29 <lispy> inimino: yeah, python and javascript are both languages that I avoid writing whenever I can
19:55:02 <SamB_XP> lispy: why python ?
19:55:04 <inimino> javascript is a really fun language once you get to know it...
19:55:23 <vixey> javascript and python suck
19:55:40 * lispy didn't mean to express more than preference
19:56:13 <SamB_XP> vixey: and ... haskell doesn't ?
19:56:49 <inimino> language preferences aren't subjective, they are matters of absolute truth!  Heretics should be punished!
19:57:03 <dons> inimino: a JS-targetting haskell compiler you mean?
19:57:06 <nullified> python sleeps with jessica alba when haskell cant get laid with Dwight fromt he Office
19:57:11 <dons> yeah, JS, not the best target machine in the world
19:57:24 <inimino> dons: yeah, I seem to recall seeing a demo
19:57:31 <dons> python's too slow and fat, nullified
19:57:51 <sebaseba_> @remember inimino language preferences aren't subjective, they are matters of absolute truth!  Heretics should be punished!
19:57:51 <lambdabot> Good to know.
19:57:59 <nullified> its great for scripting + numpy+scipy+matplotlib is awesome
19:58:11 <dons> bindings to C libs are cool, yes.
19:58:48 <nullified> dons: if i wanted to sue my own parseFiles, how would i do to allow foldl over iOchar [[]]
19:59:10 <dons> i can't parse that last type decl.
19:59:20 <dons> wouldn't you use sequence?
19:59:27 <dons> that's how you fold monadic actions together
19:59:47 <dons> the list comprehension approach also seems good...
19:59:55 <nullified> yes just wondering
19:59:56 <dons> http://hpaste.org/11271
20:00:02 <dons> ?src sequence
20:00:02 <lambdabot> sequence []     = return []
20:00:03 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
20:00:03 <lambdabot> --OR
20:00:03 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
20:00:03 <nullified> i thought iochar and char was equal in dos
20:00:08 <inimino> http://haskell.org/haskellwiki/Yhc/Javascript
20:00:10 <lambdabot> Title: Yhc/Javascript - HaskellWiki
20:00:13 <dons> IO Char is a monadic action that returns a Char when run
20:00:20 <dons> :t getChar -- for example
20:00:21 <lambdabot> IO Char
20:00:28 <dons> is an action that when you run it, gives you a Char
20:00:33 <sbahra> This is the nth I ask this, sorry.
20:00:34 <dons> so it has type:  IO Char
20:00:45 <sbahra> But is the GHC extension that allows ByteString's to override strings?
20:00:50 <sbahra> So I don't have to pack all over the place.
20:01:02 <inimino> OverloadedStrings
20:01:05 <sbahra> thx
20:01:27 <dons> sbahra: pro tip, in ghci you can say :set -X<tab> to tab complete on extensions
20:01:42 <dons> so type :set -XOver<tab> to find the extn. starting  with "Over"
20:01:50 <sbahra> http://www.haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution-Extension.html
20:01:51 <lispy> tab_completion++
20:01:52 <lambdabot> Title: Distribution.Extension, http://tinyurl.com/37zxes
20:02:02 <sbahra> dons, haha, ok, thanks
20:03:43 <mauke> (tab completion)++
20:04:56 <nullified> how cna i fold over the seaquence?
20:05:08 <dons> :t [getChar, getChar]
20:05:09 <lambdabot> [IO Char]
20:05:12 <dons> so that's a list of IO actions, yeah?
20:05:20 <dons> functions sitting in a data structure
20:05:26 <dons> we want to fold them together in to a single action
20:05:30 <dons> :t sequence [getChar, getChar]
20:05:31 <lambdabot> IO [Char]
20:05:44 <dons> now, we could also fold them with the monadic `then` operation, (>>)
20:05:59 <dons> :t foldr1 (>>) [getChar, getChar]
20:06:00 <lambdabot> IO Char
20:06:17 <dons> :t foldr1 (>>) [return 'y', return 'x']
20:06:18 <lambdabot> forall (m :: * -> *). (Monad m) => m Char
20:06:41 <dons> ?src sequence -- is actually defined this way
20:06:41 <lambdabot> Source not found. There are some things that I just don't know.
20:06:45 <dons> ?src sequence
20:06:45 <lambdabot> sequence []     = return []
20:06:45 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
20:06:45 <lambdabot> --OR
20:06:45 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
20:06:57 <dons> well, kinda, via do notation
20:07:07 <ddarius> @src sequence_
20:07:07 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
20:07:45 <dons> sequence_ yes.
20:07:56 <dons> so typically you never fold monadic things yourself
20:08:10 <dons> you use sequence  to run them (if you want the result), or sequence_ if you can throw away the result
20:08:51 <dons> probably a good idea to have some basic language tutorial handy while playing with this stuff
20:08:57 <dons> or at least, the type checker open
20:09:03 <dons> so you can see how the types go together
20:10:56 <crutcher> http://hpaste.org/11272
20:11:08 <crutcher> Given: k (foldl f z xs) (foldl g z' xs)
20:11:20 <crutcher> I'd like to do this: uncurry k $ foldl (\(z,z') (x,x') -> (f z x, g z' x)) xs
20:11:28 <crutcher> if I can prove that k is strict
20:11:43 <dons> oh, you want to do some fold fusion?
20:11:48 <crutcher> is this reasonable?
20:11:51 <crutcher> yeah, I guess.
20:12:03 <dons> this is the pattern that makes mean xs = sum xs / length xs works, btw
20:12:20 <dons> you can certainly write a rule to match the pattern
20:12:22 <dmwit> crutcher: Almost right, though you need more base cases, I think.
20:12:44 <crutcher> dons: yes, actually, that was the motivation. How do you write that rule? Does GHC already ahve one?
20:13:04 <dmwit> :t \k f g z z' -> liftM2 k (foldl f z) (foldl g z')
20:13:05 <lambdabot> forall r a b a1. (a -> a1 -> r) -> (a -> b -> a) -> (a1 -> b -> a1) -> a -> a1 -> [b] -> r
20:13:10 <dons> it doesn't have one yet
20:13:14 <crutcher> oops, g z' x should be g z' x'
20:13:24 <EvilTerran> ideally, it'd be more general
20:13:27 <nullified> what exactly dont you like about python?
20:13:42 <EvilTerran> could grab all traversals of a list in a given scope and zip them together
20:13:53 <crutcher> nullified: I'm not sure who you are talking to, but I could write a book on teh subject
20:15:08 <crutcher> dons: what would such a rule look like?
20:15:15 <nullified> you can start with chapter 1, paragraph 1
20:16:08 <dons> nullified: oh, compared to haskell? its the opposite in some ways, slow, dynamically typed, ad hoc. its not a matter of not liking it as a technology, but more that this is #haskell...
20:16:33 <nicknull> it makes you superproductive, there is a library for anything. code is supereasy to rea
20:16:35 <nicknull> d
20:16:45 <crutcher> it isn't a language, because it has no defined semanitcs. All behaviour is determined by dispatching to object's type struct's handlers. Result, optimizers, transformers, etc are impossible to write.
20:16:55 <dons> yeah, compared to low level languages, high level languages are awesome. esp. ones with libraries
20:17:14 <dons> and high level ones with white space layout and list comprehensions are mega fun
20:17:16 <inimino> Python has some great libraries
20:17:35 <crutcher> python is all glue. Its all compromise and agreement. It is useful, but it is not, and cannot be, robust
20:17:59 <sbahra> Let's say I have a whole bunch of types, is there a way I can easily have them all deriving some type class?
20:18:02 <SamB_XP> true enough -- it is pretty much all glue
20:18:10 <sbahra> Without having to modify every single line
20:18:28 <lispy> sbahra: there are automated ways of deriving
20:18:28 <EvilTerran> sbahra, well, you can do standalone deriving, and have all the modifications in one place
20:18:37 <EvilTerran> if you're willing to be restricted to recent GHCs
20:18:48 <sbahra> lispy, yes.
20:19:08 <nicknull> there is toUpper and toLower is haskell?
20:19:14 <lispy> nicknull:
20:19:14 <sbahra> lispy, but for example, I have newtype LOL1 = LOL1\n ..., newtype LOLN = LOLN\n
20:19:19 <dons> ?hoogle toUpper
20:19:19 <lambdabot> Data.Char toUpper :: Char -> Char
20:19:23 <lispy> nicknull: have you met hoogle?
20:19:36 <psu500w> I created a hello world sort of program. After compiling I see that the file binary produced is 500K. Why so much?
20:19:37 <lispy> nicknull: you can search by name or by type
20:19:42 <dons> http://haskell.org/hoogle/ <-- search by type or name
20:19:42 <lispy> ?hoogle Char -> Char
20:19:43 <lambdabot> Data.Char toLower :: Char -> Char
20:19:43 <lambdabot> Data.Char toTitle :: Char -> Char
20:19:43 <lambdabot> Data.Char toUpper :: Char -> Char
20:19:43 <lambdabot> Title: Hoogle
20:19:49 <nicknull> crutcher: so it is like a normal langauge :) shaped by evolution
20:19:53 <sbahra> lispy, I don't want to add deriving (Show) for every single type. I was wondering if there is an extension that will allow me to specify a list of types that are going to be deriving
20:20:00 <dons> psu500w: is a native code binary, with the haskell runtime linked in
20:20:05 <sbahra> EvilTerran, ah, sorry.
20:20:06 <lispy> nicknull: see that toLower and toUpper both show up, and it tells you where they are to import them :)
20:20:10 <dons> psu500w: you can strip out the symbols (strip foo), to take it to about 300k
20:20:22 <sbahra> EvilTerran, could you elaborate? How recent?
20:20:23 <dons> but since the runtime is 200k anyway, that's the minimum size.
20:20:26 <EvilTerran> "deriving instance Show Foo; deriving instance Show Bar; ..."
20:20:33 <lispy> sbahra: Maybe with TH or a ghc extension as others have said
20:20:34 <crutcher> nicknull: no, it isn't. Python doesn't understand its code. It is what happens when the entire language is devoted to the FFI
20:20:37 <psu500w> dons: so regardless of the complexity of my program, the overhead is constant, right?
20:20:45 <nicknull> crutcher: it is a bit of a red harring: python doesnt claim to be robust
20:20:48 <ddarius> > map toTitle ['a'..]
20:20:49 <lambdabot>   "ABCDEFGHIJKLMNOPQRSTUVWXYZ{|}~\DEL\128\129\130\131\132\133\134\135\136\137...
20:20:53 <EvilTerran> sbahra, see http://www.haskell.org/ghc/docs/latest/html/users_guide/deriving.html#stand-alone-deriving
20:20:54 <dons> yes. theres always about 200k of runtime to be compiled in.
20:20:54 <lambdabot> Title: 8.5.�Extensions to the "deriving" mechanism, http://tinyurl.com/2ts9ot
20:21:05 <nicknull> it is not made to write software for 10billion nasa spaceships
20:21:06 <ddarius> @src toTitle
20:21:06 <lambdabot> Source not found. :(
20:21:09 <dons> http://holumbus.fh-wedel.de/hayoo/hayoo.html <-- an alternativeAPI search
20:21:10 <lambdabot> Title: Hayoo!
20:21:23 <dons> nicknull: hehe, unlike haskell, which actually does get used at nasa (well, python also does)
20:21:27 <dons> but for different things
20:21:42 <sbahra> Yes, generalized newtypes aren't exactly what I wanted.
20:21:42 <psu500w> dons: that it's nothing compared to the .net runtime.
20:21:50 <sbahra> I was looking at that earlier.
20:21:54 <crutcher> nicknull: If I show you a block of python code, you cannot tell me what it will do. You can tell me what you expect, but you can't prove it, because I can slip in a crazy object, or hijack the interpreter, or screw with the dict look system.
20:22:08 <EvilTerran> sbahra, it's not generalised newtype deriving, that's something else
20:22:09 <SamB_XP> setuptools!
20:22:21 <dons> yeah, there's not much scope for verification or static analysis of python.
20:22:21 <inimino> crutcher: or you could import your own Prelude that does anything you like ;-)
20:22:25 * SamB_XP mentions a prime example of the truth fo what crutcher says 
20:22:47 <sbahra> EvilTerran, syntactically similar.
20:22:53 <sbahra> The problem for me is mainly syntactic.
20:22:57 <EvilTerran> not really
20:23:08 <EvilTerran> all the added text would be in one place
20:23:14 <crutcher> inimino: no, I couldn't violate the type system, nor the intrinsic relationships in the code. I'd be limited in Haskell, because there are formal semantics
20:23:27 <rwbarton> sbahra: You should be able to do this (literally have a list of type names in your program) using TH and Data.Derive
20:23:31 <ddarius> crutcher: No, there aren't.
20:23:47 <dons> well, there are. just not all in one place
20:23:50 <EvilTerran> crutcher, limited, but able to reason about it (more-or-less) systematically as a result. i call that a good sacrivice.
20:23:52 <dons> and the implementation isn't derived from them
20:23:57 <sbahra> Ok. I'll look at TH.
20:24:11 <ddarius> dons: Nor are they standardized, so no implementation is required to respect them.
20:24:11 <EvilTerran> dons, or automatically checked against them...
20:24:12 <SamB_XP> ddarius: well, it's a lot more like there are than for Python
20:24:24 <dons> right.
20:24:32 <ddarius> SamB_XP: It's certainly a lot more feasible.
20:24:44 <rwbarton> sbahra: note that the Data.Derive instances are not necessarily identical to the ones derived by ghc in all cases
20:24:45 <crutcher> dons: the implementation is the semantics. It could be nicer. But the same is not true in Python, the implementation is 'open', anyone can inject a new type, or screw with fundamental deffinitions from pretty much anywhere
20:24:49 <jsn> crutcher: what the type system does is check that all the names are right
20:24:55 <dons> we are able to formally reason about much of haskell though.
20:25:04 <SamB_XP> ddarius: every Haskell implementation has something resembling semantics
20:25:05 <lispy> referential transparency and strong static typing with inference is enough to make it more sane than most other languages
20:25:07 <dons> there are embeddings for fragments in twelf and isabelle, for example
20:25:12 <SamB_XP> Python ... not so much
20:25:27 <crutcher> hell, in Python you can't really be sure what 'a = b' means
20:25:27 * jsn crutcher: using unsafePerformIO in an 'evil Prelude' i can make '(+)' send your password to my gmail account
20:25:32 <dons> and extraction systems from Coq, Isabelle and Agda, so the problem isn't equivalent to the python case.
20:25:42 <SamB_XP> crutcher: can't you ?
20:25:49 <dons> there's some big gaps, of course.
20:25:51 <SamB_XP> I think it's usually fairly clear from the context ...
20:26:00 <SamB_XP> how could you hook that?
20:26:06 <dons> people are working on verified runtimes, verified GCs, etc, but that's cutting edge research
20:26:20 <nicknull> how can this work: let a =  mostCommon (countWords s)
20:26:26 <nicknull> mostCommon :: (Ord b) => M.Map [a] b -> Int -> [[a]]
20:26:51 <jsn> nicknull: most common b?
20:26:53 <crutcher> SamB_XP: eval can set the context, you can grab the dict object from stack frames, you can screw with teh function object, you can hook through the debug routines, etc.
20:27:17 <SamB_XP> hmm
20:27:23 <lispy> but, all that aside.  I mentioned it simply because I use python at work and I don't find it really all that enjoyable to work with.  I screw up a lot when I program in python and I waste a lot of time debugging.  so I don't really enjoy it as much as I enjoy some other languages I know.
20:27:40 <jsn> aye, i feel the same way
20:27:59 <SamB_XP> crutcher: but those things aren't nearly as common as some other things that actually happen
20:28:02 <dons> debugging should be a 1% activity
20:28:06 <jsn> dynamic languages force us to unit test everything
20:28:19 <vixey> jsn, not me
20:28:30 <jsn> (or to just lie about doing so)
20:28:33 <lispy> Well, I think unit testing and test driving development are good regardless.
20:28:36 <jsn> vixey: then you are special
20:28:51 <crutcher> I've used python professionally and personally for about 8 years. I've done _bad_ things in it. I've written new types, I've added constraint solvers to metaclasses, I've built self inspective dispatch systems and a mediated console (that was fun). Python is not really a language, its an agreement on how families of plugins should talk to each other.
20:29:00 <vixey> jsn, You don't have to unit test haskell code though?
20:29:27 <jsn> vixey: a great many of the tests are, i feel, covered by the type system
20:29:28 <lispy> But in python, I have to try things out quite a bit when I look at a new api just to figure out the types I'm dealing with.  That's boring.  I'd like to just ask my run-time what the interface is or look in the docs and I consider the type part of the interface.
20:29:43 <jsn> vixey: but yes, you have to unit test haskell as well
20:29:55 <vixey> jsn, I don't unit test in haskell either
20:29:58 <dons> you definitely do. QuickCheck please
20:30:06 <jsn> vixey: it was the extant, not the existence, of unit-testing that bothers me
20:30:14 <dons> QuickCheck for the invariants you can't prove in the type system
20:30:24 <jsn> right
20:30:27 <vixey> ok I don't see any difference, You can very easily write wrong programs in haskell
20:30:33 <dons> since there's always interesting properties of large systems that aren't in the type system
20:30:44 <dons> even if many of the common bugs are gone.
20:30:50 <vixey> the only thing which irons out bugs is thinking
20:30:53 <dons> you can then concentrate on the important ones
20:30:54 <ddarius> lispy: I have to agree with that (not for python since I've almost never used python but) for Prolog, lisps, JavaScript, et.
20:31:06 <inimino> dependent types would be nice too
20:31:15 <jsn> vixey: well, thinking is expensive
20:31:27 <jsn> declaring your intentions and getting them checked is cheaper
20:31:32 <SamB_XP> vixey: you'd be surprised how many bugs you can't write in Haskell
20:31:45 <vixey> SamB_XP: What do you mean
20:31:47 <SamB_XP> at least, if you hadn't just tried to write something in Python you would
20:31:50 <inimino> thinking is also the source of all bugs
20:32:16 <SamB_XP> Python can't even catch a lousy spelling error
20:32:16 <lispy> jsn: I guess that's a good way to say it.
20:32:22 <crutcher> inimino: code is the source of all bugs. We should seek to remove it whenever possible
20:32:26 <dolio> There are plenty of small bugs that are easier to find due to Haskell error messages than they are to figure out from Python functions that don't behave the way you expect.
20:32:57 <lispy> One thing I want to be able to do is REFACTOR!  I never get my code right on the nth try. It's always the n+1th try.
20:33:03 <Asztal> easier to find, yes, easier to understand the error messages... hmm :)
20:33:05 <Facedown> whoa, inimino -_-
20:33:06 <dolio> Once you get used to the error messages, that is.
20:33:08 <Facedown> long time, heh
20:34:03 <jsn> i think in a few years, all the <insert imminent dependently typed language here> programmers will be saying this stuff about Haskell
20:34:18 <dons> jsn, the formal methods people already do.
20:34:23 <lispy> jsn: you mean the people here :)
20:34:25 <dons> go talk to wouter swiestra about Agda for a while.
20:34:33 <jsn> dons: yeah, but it doesn't matter yet
20:34:39 <dons> heh.
20:34:49 <jsn> but it *will*
20:35:03 <jsn> we don't want to be all COBOL about this
20:35:07 <Nafai> I hear what you guys are saying, but it seems like it will be a very long time before I consider myself semi-productive in Haskell, compared to where I am in Python
20:35:12 <lispy> dons: oh, wouter uses agda?  I bet he'd be quite interested in collaborating on a patch theory prototype in agda then.  That's something I would like to do but I need a formal person to help me.
20:35:17 <jsn> haskell forevar...
20:35:18 <vixey> Nafai: why
20:35:22 <dons> lispy, *definitely*
20:35:30 <crutcher> jsn: You don't think someone will figure out how to hack coq or something like it into haskell programs so they are proven as they are compiled?
20:35:33 <dons> he's the guy to go to for haskell extraction from agda
20:35:46 <dons> crutcher: we already do that kind of thing
20:35:55 <jsn> crutcher: i do not think that makes any more sense than hacking haskell into pythong
20:35:57 <ddarius> crutcher: I'm not sure what that means.  Coq can already extract to Haskell.
20:35:58 <jsn> haha
20:36:03 <dons> where 'proven' means, 'proofs of particular properties'
20:36:09 <lispy> dons: that might be neat, but I just want to get PT nailed down so we can figure out how to optimize it.  The bubbling that we do now is silly as far as implementations go.
20:36:21 <crutcher> dons: I'll care when its in the Prelude.
20:36:21 <rwbarton> @hoogle Bool -> String -> m ()
20:36:21 <lambdabot> Language.Haskell.TH.Syntax qReport :: Quasi m => Bool -> String -> m ()
20:36:21 <lambdabot> Language.Haskell.TH report :: Bool -> String -> Q ()
20:36:21 <lambdabot> Language.Haskell.TH.Syntax report :: Bool -> String -> Q ()
20:36:45 <dolio> When what's in the prelude?
20:36:55 <ddarius> rwbarton: Are you looking for something like if b then return () else fail s ?
20:37:00 <rwbarton> ddarius: Precisely
20:37:12 <mauke> @src guard
20:37:12 <lambdabot> guard True  =  return ()
20:37:12 <lambdabot> guard False =  mzero
20:37:19 <crutcher> If running coq is seperate from compiling haskell, it isn't interesting, nor does it really help with bugs that much.
20:37:20 <rwbarton> mauke: I don't have a MonadPlus
20:37:24 <jsn> crutcher: my concern is that all our nifty libraries will be useless to these future programmers because, hey, they have all these weird edge cases...
20:37:34 <dons> crutcher: that's what things like agda are for. you program in the proof system
20:37:38 <Nafai> vixey: I haven't been able to "get the hang of" Haskell just yet.  It takes me forever to think of how to write things in Haskell or figure out type errors or whatever
20:37:43 <crutcher> But if you could make it a compile error for something to be unprovable, that'd be interesting.
20:37:54 <jsn> Nafai: it took me a couple of years
20:37:56 <Nafai> vixey: Yet in Python I've used it enough it's just finding the right library calls, etc
20:37:57 <ddarius> crutcher: You can just code in Coq.
20:38:03 <jsn> Nafai: it's all been spare time for me, though
20:38:09 <dons> crutcher: so people actually alreadyd do this. i work with some of them
20:38:25 <vixey> Nafai: Have you tried just ignoring the type system and writing code that makes sense?
20:38:31 <dons> they program in their proof assistant, check the interesting things, dump code out the back that actually runs.
20:38:36 <vixey> Nafai: That's what I do in haskell it works very well
20:38:36 <jsn> dons: they do this in haskell? with a modded GHC or...?
20:38:57 <Nafai> jsn: I've been doing Haskell off and on for about 2 years, but a little too off and on :)
20:39:01 <lispy> dons: that's what we do in darcs, but GHC is our prover
20:39:02 <crutcher> dons: I don't care. Until GHC does it, it gives no real benefit outside of their workflow
20:39:04 <dons> not a modded ghc, a proof assistant that emits haskell. like agda does.
20:39:07 <dons> lispy: yeah
20:39:14 <Nafai> vixey: Well, sure, until I try to compile something and get the type errors then I have to go back and think about it
20:39:18 <vixey> I wish agda was fast
20:39:29 <nicknull> i have c:/ghc/progs/dm/current_file.hs and want to import c:/ghc/progs/another_file.hs, what to i need to do?
20:39:32 <lispy> crutcher: ah, you should look at darcs then
20:39:39 <dons> crutcher: its like having a testsuite on the side, you run it when you change something
20:39:50 <lispy> crutcher: ghc is prove us some theorems for greater good
20:39:50 <dons> so you rerun the theorem prover when you change something
20:39:52 <jsn> i think the important things to realize is that haskell, too, will be some bloated, slow, fragile piece of junk some day
20:40:00 <crutcher> There are other reasons to prove things about code. You could write RULES pragmas which match certain patterns iff certain other attributes can be prove
20:40:02 <crutcher> proven
20:40:09 <dons> anyway, you won't see this in ghc, beyond the 'theorem proving' we already do in the type system
20:40:11 <vixey> Nafai: well the question is, why have you got type errors in the first place? if you wrote 7 / "foo" in any langauge you'd have a problem
20:40:36 <jsn> vixey: there are, i think, subtler reasons encountered in practice
20:40:37 <lispy> dons: what about the extended haskell checking that has showed up at icfp a couple years in a row?
20:40:47 <Nafai> vixey: True
20:40:50 <dolio> Haskell's type system (even with GHC extensions) isn't set up for the same level of theorem proving that Coq and such are.
20:40:56 <lispy> dons: that will someday be a ghc extention right?
20:40:58 <dons> yeah, there is already support for additional checkers
20:41:03 <ddarius> jsn: Most of the time, type errors indicate real errors.
20:41:10 <crutcher> vixey: in python, 7 / "foo" throws an error, but 7 * "foo" does not.
20:41:24 <dons> heh
20:41:26 <vixey> crutcher: that's sort of irrelevant to my point though
20:41:30 <mauke> crutcher: fixed in perl!
20:41:32 <jsn> ddarius: i don't deny that
20:41:39 <SamB_XP> vixey: guess what 7 * "foo" gives you in Python ?
20:41:41 <lispy> crutcher: that's funny
20:41:50 <SamB_XP> lispy: or you ;-P
20:41:51 <lispy> I just tried it
20:41:54 <vixey> I have no idea SamB_XP
20:41:54 <SamB_XP> oh
20:41:55 <nicknull> what is the goal of provability? you cant prove a program correct in the absolute sense so what is the more concrete goal u are solving now?
20:41:57 <dolio> mauke: Because 7/"foo" doesn't throw an error in perl? :)
20:41:58 <crutcher> vixey: is it? I thought we were talking about type systems and "any language"
20:42:04 <mauke> dolio: er, yes it does
20:42:04 <jsn> mauke: in perl,   7 / "foo"   works ?
20:42:06 <SamB_XP> "foofoofoofoofoofoofoo"
20:42:17 <mauke> jsn: for what definition of "works"?
20:42:19 <SamB_XP> assuming I counted right
20:42:22 <lispy> nicknull: more like, you prove you're not doing certain things that would be silly
20:42:25 <crutcher> nicknull: provability serves two goals: testing, and optimization.
20:42:34 <rwbarton> Perl: 7 * "foo" = 0
20:42:37 <jsn> mauke: it, uhm, does what i mean?
20:42:38 <ddarius> SamB_XP: Was that supposed to be surprising?
20:42:43 <crutcher> nicknull: as such, completeness isn't the crucial thing, but coverage percentage
20:42:49 <jsn> nicknull: your program is made of lots of little programs
20:42:51 <crutcher> nicknull: more coverage == more robust
20:42:51 <Nafai> I guess I just need to write some more Haskell
20:42:56 <SamB_XP> ddarius: vixey had no idea
20:43:02 <jsn> nicknull: it's nice to know that many of these little programs are proven correct
20:43:03 <Nafai> Figure out something small but useful to do
20:43:08 <SamB_XP> so I should hope it would at least be interesting to vixey ;-)
20:43:13 <vixey> not really :p
20:43:17 <mauke> rwbarton: use warnings FATAL => qw(all);
20:43:31 <ac> Heh, SPJ likes talking about "launching the missiles": "They’re not really functions however, as they have side effects. So you can call f and you can print something, or launch the missiles."
20:43:33 <vixey> I have de bruijn indice problems
20:44:00 <ac> if you're going to have side effects, you might as well have awesome ones
20:44:11 <jsn> i wonder if SPJ ever hangs out on this channel
20:44:14 <SamB_XP> vixey: write in Coq
20:44:16 <ddarius> vixey: Get rid of the de Bruijn indices and the problems will go away.
20:44:18 <SamB_XP> jsn: rarely
20:44:26 <SamB_XP> if ever
20:44:32 <ddarius> SamB_XP: He has.
20:44:35 <SamB_XP> I've seen him on IRC for brief periods
20:44:37 <mauke> preflex: seen spj
20:44:37 <preflex>  Sorry, I haven't seen spj
20:44:45 <SamB_XP> but I can't remember whether it was here or #ghc
20:44:46 <jsn> well, i'm sure he doesn't use that nic
20:45:02 <ddarius> SamB_XP: Both him and Simon Marlow have been on this channel.
20:45:02 <SamB_XP> preflex: seen simonpj
20:45:02 <preflex>  simonpj was last seen on #ghc 38 days, 12 hours, 37 minutes and 42 seconds ago, saying: Sorry went away for a moment.  I am clueless about branch tagging, but feel free to discuss it anyway!
20:45:13 <jsn> oh, interesting
20:45:29 <SamB_XP> preflex: seen jaffacake
20:45:29 <preflex>  jaffacake was last seen on #ghc 1 day, 15 hours, 23 minutes and 56 seconds ago, saying: yeah, good plan
20:45:33 <vixey> ddarius: and replace them with what?
20:45:41 * lispy has met both simons once in person and found both of them to be quite pleasant...not weird geeky anti-social types like he might have expected
20:45:41 <nicknull> yes ofc 30% proved is beter than 25%, i was just wondering if there was some specific goal but i see
20:45:44 <ddarius> vixey: With different problems.
20:45:47 <vixey> haha
20:46:05 <SamB_XP> ddarius: worse ones, almost certainly
20:46:13 <nicknull> was spj the inventor of haskell or hes just the most colorful person doing it?
20:46:19 <SamB_XP> the one thing about de bruijn problems is that they tend to be either there or not ;-)
20:46:22 <ddarius> lispy: Are you weird, geeky and anti-social?
20:46:31 <Nafai> lispy: I don't imagine SPJ as being anti-social from his presentations.  In fact, I imagine him being very outgoing and excited
20:46:34 <SamB_XP> nicknull: I'd say "animated"
20:46:40 <jsn> nicknull: well, i think the whole FP community is the "inventor"
20:46:41 <ddarius> nicknull: There is no individual inventor of Haskell.
20:46:51 <SamB_XP> not not "colorful"
20:46:56 <lispy> nicknull: you should read the history of haskell paper: http://research.microsoft.com/~simonpj/papers/history-of-haskell/index.htm
20:46:58 <lambdabot> Title: A History of Haskell, http://tinyurl.com/yowkle
20:47:00 <SamB_XP> he's so gesturetastic
20:47:19 <nicknull> lol
20:47:24 <lispy> Nafai: I had no prior knowldge of him except knowing his name when I met him in person
20:47:39 <SamB_XP> nicknull: why lol, haven't you seen any of the videos ?
20:47:42 <nicknull> i have c:/ghc/progs/dm/current_file.hs and want to import c:/ghc/progs/another_file.hs, what to i need to do?
20:47:53 <vininim> spjolicious!
20:48:29 <lispy> nicknull: Hmm...I think you can only import from higher in the directory tree
20:48:44 <ddarius> You just use -i to specify directories.
20:48:50 <lispy> nicknull: so, near as I can tell you need to move things around to import another_file into current_file
20:49:07 <crutcher> I'm interested in type-safe efficient IPC. Do I have to build my own IO, or is there a general solution?
20:49:35 <jsn> crutcher: there is Data.Binary for serialization
20:49:44 <mauke> session types?
20:49:49 <lispy> crutcher: type safe in what sense?  Oleg recently did type safe resource usage in his light weight monadic regions paper
20:50:04 <jsn> if you want message-passing, i don't know what you need; if you want shared memory, there's STM
20:50:35 <SamB_XP> STM isn't exactly IPC
20:50:37 <crutcher> I want message passing, and I want it as general and transparent as I can make it.
20:50:48 <crutcher> and it can't be shared memory, because it won't be local.
20:50:48 <jsn> SamB_XP: fair enough
20:51:05 <crutcher> I want to take a stab at large scale cluster computing in haskell
20:51:14 <crutcher> but I'd like to build something generic
20:51:16 <lispy> crutcher: then I think you want to check hackage and then plan on writing it yourself if you don't find it there
20:51:22 <lispy> ?where hackage
20:51:22 <lambdabot> http://hackage.haskell.org/
20:51:34 <crutcher> :(
20:51:53 <crutcher> I'd like to have something like a MVar, but network based.
20:52:06 <jsn> MVars are atomic, right?
20:52:09 <lispy> yeah, it sounds like you want to create a Chan that is backed by a socket
20:52:18 <crutcher> yeah, sounds right
20:52:33 <nicknull> sam: yes i ahve thats why i lol
20:52:35 <crutcher> There's been some work in this direction, I think.
20:52:51 <nicknull> he seems like areally nice guy and it is nice to see someone eo excited about what they do
20:52:56 <Nafai> *sighs* Unfortunately my last attempt at a useful Haskell program ended up being a dead end because it was something I couldn't use from Xmonad
20:53:17 <lispy> Nafai: could use from xmonad?
20:53:52 <slava> hi Nafai :)
20:54:41 <Nafai> Hi slava
20:54:59 <nicknull> if i want my own Strings-lib, can i just put it in lib? or i have to setup.hs etc, create that? or how can i link it with ghc? will it automatically check for the lib in lib?
20:55:14 <nicknull> slava pestov?
20:55:19 <Nafai> lispy: I was writing a gtk program that was called from an xmonad extension.  Since it was called from within xmonad, it blocked the window manager.  But since the wm couldn't manage it, it never displayed
20:55:23 <Nafai> slava: How's it going?
20:55:27 <Nafai> nicknull: Yes, that's the one and only
20:57:34 <rwbarton> Nafai: It should be easy to work around that with a fork of some kind
20:58:28 <Nafai> rwbarton: I haven't figured out the right way, because the result of the program is read by xmonad and then an action is performed
20:58:37 <Nafai> rwbarton: I wrote a GUI replacement for dmenu
20:58:46 <crutcher> hmm, Data.Binary looks pretty nice actually.
20:58:50 <rwbarton> Nafai: Hmm
20:59:14 <Nafai> If there is a solution, I'm all for it, 'cause I wouldn't mind hacking on this code more
20:59:25 <rwbarton> Nafai: Does it need to be xmonad that runs the action?
20:59:42 <rwbarton> Nafai: e.g. with dmenu, xmonad starts a process that runs dmenu and then execs the output
20:59:48 <ac> crutcher: yeah it's pretty decent. I've used it for de/encoding binary formats
20:59:48 <lispy> Nafai: do you know about #xmonad?
20:59:56 <slava> nicknull: yup
21:00:02 <lispy> Nafai: that would be a really great place to get help
21:00:13 <Nafai> lispy: Yes, I've talked about it at one point
21:00:22 <ac> crutcher: you can even use generic programming to automatically generate instances for Binary, though only in some cases
21:00:27 <Nafai> rwbarton: -> #xmonad
21:00:47 <nicknull> ill go create a gui in visual basic, see if i an track an ip-address
21:00:56 <ac> crutcher: actually in most cases
21:01:03 <geezusfreeek> i walk in and that's what i see first...
21:01:08 <lispy> slava: ah, you worked on jEdit it says on your wikipedia page
21:01:33 <pcc1> is there a haskell library for treating remote (e.g. sftp) filesystems the same way as local filesystems?
21:01:34 <geezusfreeek> nicknull, you mean a "gui interface" ;)
21:01:55 <crutcher> ac: cool.
21:02:36 <ac> crutcher: the only reason I couldn't generate my binary instances automatically was because I wanted extra parameters to specify compression levels and whatnot
21:03:05 <lispy> pcc1: Well, for linux there is FUSE where you could probably just treat it as a local file system period.  I don't know of a Haskell library, but have you checked hackage.haskell.org ?
21:04:10 <ac> pcc1: yeah, you could call sshfs, and then just use Haskell to talk to the file system
21:05:22 <slava> lispy: yeah i wrote it originally
21:05:40 <nicknull> geezusfreeek: you saw it? i just saw the youtube link from reddit
21:05:49 <nicknull> hilarious and embarssing
21:05:52 <pcc1> ok thanks...
21:06:39 <jsn> i would like to make an interface to some windows system functions
21:06:49 <jsn> do i need Visual Studio?
21:07:01 <jsn> i'm having trouble finding a simple example on the web
21:07:27 <Zao> jsn: No.
21:07:44 <lispy> jsn: there is a library already that access quite a bit of the win32 api
21:07:54 <Zao> http://haskell.org/ghc/docs/latest/html/libraries/Win32/System-Win32.html
21:07:56 <lambdabot> Title: System.Win32, http://tinyurl.com/ysttnk
21:08:28 <jsn> lispy: yes, but it is not enough
21:08:43 <Zao> And http://haskell.org/ghc/docs/latest/html/libraries/Win32/Graphics-Win32.html
21:08:44 <lambdabot> Title: Graphics.Win32, http://tinyurl.com/64ghjn
21:09:00 <jsn> that is pretty simple, though
21:09:07 <lispy> jsn: Well, if you can access it in gcc, in a .c file, then you can certainly access it in Haskell, pretty much the same way actually.
21:09:09 <jsn> just include the header file and that's it?
21:09:39 <jsn> to be honest, the only windows compilation i've ever done has been with GHC
21:09:57 <geezusfreeek> nicknull, yeah i saw i quite a while ago, actually, but it has nonetheless scarred me
21:14:59 <nicknull> *** Exception: C:/users/saftarn/desktop/datasets/ycnews/003/048.html: openFile: resource exhausted (Too many open files)
21:15:06 <nicknull> is there a closeFile?
21:17:55 <inimino> @hoogle hClose
21:17:56 <lambdabot> System.IO hClose :: Handle -> IO ()
21:20:13 * lispy lol's at the order of nicknull's comments
21:22:27 <nicknull> but i dont really have  handle
21:22:32 <seydar> do people here use yi often?
21:22:34 <nicknull> i ahve a steing which i readfile on
21:24:14 <dons> nicknull: right, you're using readFile and parseTags or something, on each file?
21:24:21 <dons> but you wish to open thousans of files in a row?
21:24:23 <Nafai> I've been meaning to re-try yi
21:24:26 <dons> or in parallel.
21:24:34 <dons> so you'll actually need to think about resource usage.
21:24:38 <mmorrow> nicknull: this is one way http://hpaste.org/11273
21:25:05 <dons> i'd suggest, perhaps, using the 'strict' package, and instead of System.IO.readFile, using System.IO.Strict.readFile, which will guarantee to close the file at the point you read it.
21:25:10 <seydar> Nafai: do you know where i can find some good documentation on it?
21:25:16 <vixey> I need to not have code that looks like this lift (nb_prod ty_i + nb_prod ty_j) (prod_ith_ty ty_i (nb_prod ty_i - n + 1))
21:25:31 <seydar> vixey: does lift 'lift' the viel that is a monad?
21:25:33 <vixey> does not maake sense
21:25:38 <dons> too many underscores, vixey :)
21:25:44 <Nafai> seydar: No clue, though I do remember seeing a blog about it
21:25:51 <Nafai> http://yi-editor.blogspot.com/
21:25:54 <seydar> ie, lift show $ getStr ?
21:25:56 <lambdabot> Title: The Yi Blog
21:26:03 <vixey> seydar: no
21:26:10 <vixey> seydar: it's de bruijn lift
21:26:15 <seydar> @src lift
21:26:15 <lambdabot> Source not found. Are you on drugs?
21:26:21 <mmorrow> , ?f `fmap` readLine
21:26:22 <linolium> Say I have a list of integers [1,2,3] and a function (sum a b c = a + b + c), how can I call sum with the list without separately assigning a variable to the first three items, and then calling it?
21:26:24 <lunabot>  luna: Not in scope: `readLine'
21:26:27 <mmorrow> , ?f `fmap` readLn
21:26:28 <lunabot>  luna: Unbound implicit parameter (?f::a -> b)
21:26:39 <mmorrow> oops
21:26:45 <mmorrow> , ?f `fmap` getLine
21:26:47 <lunabot>  luna: Unbound implicit parameter (?f::GHC.Base.String -> b)
21:26:52 <vixey> linolium: you can pattern match it, sum [a,b,c] = a + b + c
21:27:00 <mmorrow> , return . ?f =<< getLine
21:27:02 <lunabot>  luna: Unbound implicit parameter (?f::GHC.Base.String -> b)
21:27:12 <mmorrow> , ?f `liftM` getLine
21:27:14 <lunabot>  luna: Unbound implicit parameter (?f::GHC.Base.String -> r)
21:27:18 <mauke> linolium: sum (xs !! 0) (xs !! 1) (xs !! 2)
21:27:22 <linolium> vixey: but I would rather not edit the function sum itself, since it makes it less portable
21:27:26 <mmorrow> , ?f <$> getLine
21:27:27 <lunabot>  luna: Unbound implicit parameter (?f::GHC.Base.String -> b)
21:27:29 <vixey> linolium: what
21:27:32 <linolium> mauke: is that the best solution?
21:27:37 <mauke> linolium: no
21:27:42 <nicknull> cool thanks
21:27:44 <rwbarton> linolium: There isn't an easy way to do this.*
21:27:49 <mauke> linolium: why do you have a sum function that takes three arguments?
21:27:49 <linolium> rwbarton: ah
21:27:53 <rwbarton> linolium: (* Actually there is but it involves evil type class hackery)
21:27:58 <linolium> mauke: it does other calcuations, it was just an example
21:28:03 <Facedown> could someone link me to a pastebin of some medium level haskell app? maybe someone has a git hub that i could look at? ;p
21:28:14 <vixey> linolium: "portable"?
21:28:33 <linolium> vixey: in this case it doesn't make sense to pass a list to a function, really
21:28:34 <linolium> centreToCorner w l = sqrt((w/2)^2 + (l/2)^2)
21:28:55 <vixey> linolium: "I have a list of integers [1,2,3]"
21:29:44 <linolium> vixey: yes, but it doesn't make sense to pass the function a list of three items, except in the way it's receiving input
21:29:48 <vixey> do you know how tomake new data types?
21:30:10 <linolium> vixey: slightly
21:30:35 <vixey> just  data Name <type variables...> = Constructor1 <some types> ... | ...
21:30:44 <linolium> okay
21:31:03 <vixey> and you can pattern match with that too like foo (Constructor1 x y z ...) = x + y ...
21:31:13 <vixey> maybe with this there is a better way
21:31:38 <linolium> how would that help me?
21:33:00 <rwbarton> linolium: I take it you're reading w and l from one line of a file or something?
21:33:08 <linolium> rwbarton: yes, from standard input
21:33:13 <rwbarton> linolium: I usually write   [w, l] <- map read . words `fmap` getLine
21:33:52 <linolium> ah?
21:33:58 <linolium> I was doing return (map (read :: String -> Int) $ words line)
21:34:26 <rwbarton> Sure, I've just combined that with the previous line which probably looks like  line <- getLine
21:34:34 <linolium> ah
21:35:12 <rwbarton> If you really want to, you can write a function to apply a function of several curried arguments of the same type to a list.  I put code for that on hpaste
21:36:25 <rwbarton> linolium: http://hpaste.org/10727
21:37:22 <ahunter1> Can I safely assume that (&&) is lazy in its second argument if the first is True?
21:37:23 <linolium> rwbarton: interesting
21:38:01 <rwbarton> @src (&&)
21:38:01 <lambdabot> True  && x = x
21:38:01 <lambdabot> False && _ = False
21:38:18 <rwbarton> ahunter1: Yes
21:38:32 <rwbarton> linolium: but I don't really endorse doing this :)
21:39:24 <linolium> rwbarton: haha. so the cleanest way is to bind [the, three, arguments] to variables, and then pass them to the function?
21:40:41 <rwbarton> linolium: Yes, that's what I usually do
21:40:57 <linolium> rwbarton: cool beans
21:41:47 <nicknull> parse error on input `System.IO.Strict.readFile'
21:42:06 <nicknull> lolo ofc
21:42:14 <linolium> rwbarton: is there something I'm doing wrong here: doReadCase = return (map read . words `fmap` getLine)
21:42:46 <nicknull> ould not find module `System.IO.Strict':
21:44:02 <nicknull> mmorrow: readStrict eats yp allthe memory
21:45:37 <mmorrow> nicknull: heh, it'll do that :)
21:45:53 <mmorrow> nicknull: what are you doing in particular?
21:46:03 <mmorrow> could you hpaste the relevant part?
21:47:32 <rwbarton> linolium: just get rid of 'return'
21:47:40 <linolium> rwbarton: it's still complaining
21:47:47 <mmorrow> taking a blind guess (and assuming you're not reading massive files, just a lot of files), you can't read all the files in first with strict read
21:47:49 <rwbarton> :t map read . words `fmap` getLine
21:47:50 <lambdabot>     precedence parsing error
21:47:50 <lambdabot>         cannot mix `(.)' [infixr 9] and `fmap' [infixl 9] in the same infix expression
21:47:54 <linolium> rwbarton: cannot mix `(.)' [infixr 9] and `fmap' [infixl 9] in the same infix expression
21:47:57 <rwbarton> :t (map read . words) `fmap` getLine
21:47:58 <lambdabot> forall a. (Read a) => IO [a]
21:48:00 <rwbarton> there
21:48:07 <rwbarton> I actually write
21:48:18 <rwbarton> :t map read . words <*> getLine
21:48:19 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
21:48:19 <lambdabot>     Probable cause: `.' is applied to too many arguments
21:48:19 <lambdabot>     In the first argument of `(<*>)', namely `map read . words'
21:48:23 <mmorrow> but have to read one in, process it, free up some mem somehow, move on to the next one, ...
21:48:30 <linolium> rwbarton: what does <*> do?
21:48:34 <rwbarton> I mean
21:48:37 <rwbarton> :t map read . words <$> getLine
21:48:38 <lambdabot> forall a. (Read a) => IO [a]
21:48:44 <rwbarton> (<$>) = fmap
21:49:18 <rwbarton> It has an infix operator name which is often more convenient
21:49:25 <linolium> ah, neat
21:49:32 <vixey> map read . words . getLine
21:49:54 <thoughtpolice> i would normally say 'enumerators' here since they fit the bill perfectly for something like file reading, but... :]
21:50:17 <linolium> rwbarton: <$> is not in scope
21:50:26 <rwbarton> It's in Control.Applicative
21:50:30 <linolium> oh, okay
21:51:01 <linolium> doReadCase = (map read . words) `fmap` getLine    is giving me an Ambiguous type variable
21:51:45 <rwbarton> linolium: right.  the Monomorphism Restriction strikes again
21:51:56 <linolium> oh dear rgod, not that
21:51:58 <rwbarton> linolium: add a type signature:  doReadCase :: Read a => IO [a]
21:52:11 <rwbarton> or just turn it off
21:59:07 <nicknull> http://hpaste.org/11275
21:59:43 <ac> isn't there a funny looking operator in OpenGL for making SettableStateVars?
22:00:25 <ac> or do I really have to type "makeSettableStateVar" for every function that takes that type?
22:00:41 <vixey> let (#$!) = makeSettableStateVar
22:01:32 <ac> I'm thinking of ($=)
22:01:44 <ac> probably
22:01:49 <nha__> thats to set a statevar
22:04:14 <rwbarton> [t| Maybe Int |] produces (AppT (ConT ''Maybe) (ConT ''Int)) -- is there a similar syntax that produces just ConT ''Maybe?
22:04:27 <ac> oh I get it... you don't generally have to make them... windowTitle $= "Blah"
22:05:45 <electronx> got a question what algorithms are used for inference in predicate logic?
22:05:58 <electronx> google doesn't seem to help
22:06:07 <vixey> what's inference
22:06:20 <lispy> electronx: do you mean prolog?
22:06:26 <electronx> ya like that
22:06:44 <electronx> except prolog can't handle large knowlege bases
22:07:08 <vixey> electronx: what's inference?
22:07:22 <electronx> vixey: infering an answer
22:07:48 <lispy> vixey: it's where you have relationships given by predicates and you can give answers to questions that are phrased in the predicate logic.
22:07:53 <electronx> ie p(2, 1) is a predicate so i can infer from p(2, X) that x is probably 1
22:08:20 <vixey> You want to know how to implement Prolog?
22:08:23 <hml> on ubuntu, what do i have to install to et cabal ? i want to be able to do 'cabal  install xmonad' and have magic happen
22:09:06 <electronx> vixey: prolog has a bad inference algo
22:09:16 <lispy> electronx: You can find lots of 'mini' prolog toy implementation in Haskell if you search places like the wiki or the mailing list archives.  As for efficient algorithms...gosh I dunno.
22:09:31 <lispy> hml: hi
22:09:36 <lispy> hml: you want cabal-install
22:09:49 <electronx> lispy: i want to find out what algos they use so i can google them
22:09:53 <hml> lispy: apt-cache search cabal-0install brings up nothing
22:09:58 <hml> lispy: *cabal-install*
22:10:00 <vixey> electronx: "bad"?
22:10:09 <lispy> electronx: to be honest, I would start at wikipedia for this task :)
22:10:12 <electronx> vixey: ineficient
22:10:20 <vixey> electronx: No
22:10:22 <electronx> lispy: thanks
22:10:23 <mjg> hi - simple beginner question:  function f :: Int->Int is strictly increasing, how can I get a list of values of f a which are less than a certain value? (as in "[ f a | a<-[1..], f a < 100]", except that one never terminates)
22:10:24 <ac> what's better: GLUT, GLFW, or some third framework? Seems GLUT has a much larger API (at least the part with Haskell bindings) than GLFW, but GLFW is supposedly more up to date
22:10:32 <hml> i like glfw
22:10:39 <vixey> :t takeWhile
22:10:40 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
22:10:58 <slava> ac: i've never found anything good in that regard
22:11:11 <slava> roll your own :)
22:11:13 <lispy> hml: Well, failing your distro tool, you could get cabal-install and it's 2 or 3 dependencies from hackage.haskell.org and build/install it yourself.  I know it's painful and ubuntu should do it.
22:11:21 <mmorrow> nicknull: here's an example of a strict fold over a file http://hpaste.org/11276
22:11:26 <ac> slava: oh no :-P
22:11:54 <rwbarton> hml: there is a shell script that automates the installation of cabal-install somewhat
22:11:57 <ac> also, does anybody know of a simple graphics library on top of OpenGL? All I want to do is draw a circle
22:12:14 <vixey> ac,  why do you want to only draw a circle
22:12:14 <pcc1> is there sometihng like this: http://hackage.haskell.org/packages/archive/bytestring/0.9.1.0/doc/html/Data-ByteString-Char8.html#v:split for the Eq class
22:12:16 <lispy> ac: SDL might be better for you
22:12:18 <lambdabot> Title: Data.ByteString.Char8, http://tinyurl.com/6s62fs
22:12:24 <slava> ac: GLU can draw circles
22:12:39 <slava> use factor. we have a gui toolkit built on top of gl :)
22:12:57 <hml> factor?
22:12:59 <hml> factorcode?
22:13:08 <rwbarton> hml: download cabal-install from this page:
22:13:10 <rwbarton> @hackage cabal-install
22:13:10 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
22:13:14 <mjg> vixey: thanks :)
22:13:16 <rwbarton> and run the included bootstrap.sh script
22:13:23 <hml> lispy , rwbarton : thanks
22:13:35 <ddarius> If all you need to do is draw a circle, I imagine Cairo would be fine.
22:13:47 <vixey> ?where Diagram
22:13:48 <lambdabot> I know nothing about diagram.
22:13:52 <vixey> ?go byorgey Diagram
22:13:55 <lambdabot> http://byorgey.wordpress.com/2008/04/30/new-haskell-diagrams-library/
22:13:55 <lambdabot> Title: New Haskell diagrams library « blog :: Brent -> [String]
22:13:56 <ddarius> That said, it's easy enough to do in even raw GL.
22:14:07 <slava> GLU draws circles and its part of GL
22:15:32 <lispy> ac: have you looked at the HOpenGL nehe tutorials?  I think they have an example that is very close to what you want
22:15:38 <lispy> ?where nehe-tuts
22:15:38 <lambdabot> darcs get http://projects.codersbase.com/repos/nehe-tuts/
22:15:39 <ac> ddarius: I actually have a working version that uses Gtk2hs and Cairo that's painfully slow (I'm intending to run this on my XO laptop, so even though the graphics are terribly simple, performance matters)
22:15:41 <lispy> ac: ^^
22:15:51 <Nafai> Yay for FFIs
22:15:53 <slava> ac: in that case use raw x11?
22:17:10 <ac> slava: that'd be a real pain, right?. I'd consider using xcb, but there are no bindings for that yet
22:17:20 <slava> xcb is a bigger pain than x11
22:17:27 <slava> if all you want is monochrome graphics, x11 is trivial
22:17:38 <slava> does haskell have x11 bindings?
22:17:42 <ddarius> Yes.
22:18:16 <Nafai> Should be pretty good, xmonad uses them
22:18:28 <ac> ah ok
22:20:18 <dons> interesting, http://berger-files.blogspot.com/2008/10/thinking-about-programming.html
22:20:20 <lambdabot> Title: The Berger Files: Thinking about programming, http://tinyurl.com/6njt62
22:20:23 <ac> but why would plain X11 be better than using GLFW?
22:20:48 <slava> ac: it probably wouldn't
22:22:36 <nicknull> mmorrow : too tired now i saved the link will see tomorrow if it works
22:23:05 <dons> the x11 bindings are are almost 10 years old, I notice.
22:23:11 <dons> -- Module      :  Graphics.X11
22:23:12 <dons> -- Copyright   :  (c) Alastair Reid, 1999-2003
22:23:25 <dons> most of the recent stuff is 2007,08 for window managers.
22:24:21 <ahunter1> http://hpaste.org/11277 I'm pretty sure I'm missing a bog-standard monad combinator that'll get rid of the ugly case here; any suggestions?
22:25:34 <dons> so you only want null or the head of the list?
22:26:06 <dons> listToMaybe looks handy
22:26:07 <ahunter1> Well, I want an element if there's one, else I just return True.  Head is not all that important.
22:26:29 <dons> isJust . fmap (match c) . listToMaybe
22:26:32 <dons> or something like it
22:26:54 <ddarius> dons: Blech.  listToMaybe is good, then use maybe
22:26:57 <slava> dons: how many lines of code to open a window and render a circle in haskell?
22:26:59 <mmorrow> dons: that reminds me of the C fastcgi lib which fastcgi binds to
22:26:59 <slava> :P
22:27:02 <mmorrow>  * fcgiapp.h --
22:27:02 <mmorrow>  *      Definitions for FastCGI application server programs
22:27:02 <mmorrow>  * Copyright (c) 1996 Open Market, Inc.
22:27:07 <twfxfnf> 42004393049-290
22:27:11 <mmorrow> oh, 12 years that one.
22:27:15 <twfxfnf> > 40936803468*0234986039486039486^039486039486034986
22:27:30 <lambdabot>   thread killed
22:27:38 * twfxfnf kicks it
22:28:12 <dons> slava: using any gui lib?
22:28:15 <slava> sure
22:28:21 <slava> cross platform though
22:28:36 <dons> one or two i guess, in gtk2hs, or one of the high level libs.
22:29:21 <dons> oh, maybe use the diagrams edsl
22:29:29 <dons> byorgey_: something from Graphics.Rendering.Diagrams.Shapes
22:30:24 <dons> main = render (circle 10) -- i think, using diagrams
22:30:29 <dons> might need to be a list.
22:30:39 <slava> heh
22:31:05 <dons> main = render (hcat [blue (circle 10)] -- appox.
22:31:14 <slava> does that display a window?
22:31:26 * dons is just reading docs
22:31:46 <slava> its not that quite concise with factor's ui
22:31:50 <slava> not quite that*
22:32:05 <dons> well, that's the highest level one i could think of.
22:32:27 <dons> there's lower level ones, but super high level 'pretty printing' ones have been popular for ages.
22:32:47 <dons> conal's a good guy to ask
22:32:48 <ahunter1> dons: thanks for the listToMaybe suggestion... maybe (return True) (\r -> match c r >> return False) (listToMaybe choices) works...though still kind of messy, any pointer on where to go from there?
22:32:52 <dons> he's been doing these things for ages.
22:33:03 <dons> ahunter1: i'm not sure it's getting any clearer :)
22:33:06 <slava> for us its [ black set-color { 10 10 } { 100 100 } 100 gl-circle ] <slate> "Circle" open-window
22:33:19 <ddarius> False $> match c r
22:33:24 <ahunter1> dons: yeah...I just feel that using a case expression is kind of admitting failure
22:33:26 <dons> slava: looks good.
22:33:37 <slava> someone needs to port postscript to factor :)
22:34:00 <dons> the high level ones, http://haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries#High-level
22:34:02 <lambdabot> Title: Applications and libraries/GUI libraries - HaskellWiki, http://tinyurl.com/yttdtd
22:35:11 <ddarius> maybe (return True) (fmap (const False) . match c) . listToMaybe =<< filterM ...
22:35:42 <slava> dons: we're working on some additional file system level stuff right now: getting free disk space, etc
22:36:46 <ddarius> In fact, findCheap = (maybe (return True) (fmap (const False) . match c) . listToMaybe =<<) . filterM free . (colG !)
22:36:51 <ahunter1> ddarius: don't think that's much better
22:57:04 <ivanm> @tell Cale I've found a semi-decent method for converting CReal to Double: read . showCReal n
22:57:05 <lambdabot> Consider it noted.
22:57:32 <vininim> heh
22:57:37 <ddarius> > realFrac (pi :: CReal) :: Double
22:57:38 <lambdabot>   Not in scope: `realFrac'
22:57:53 <Cale> realToFrac fails because the instance of Real is fake
22:57:53 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
22:59:52 <ivanm> oh, you _are_ around
22:59:57 <ivanm> lambdabot said you weren't
23:00:15 <ivanm> lambdabot: I'm sorry, but my faith in you is now shattered irreperably :(
23:00:27 <Cale> I hadn't talked on IRC in a long time.
23:00:31 <ozy`> hmm. does {- | ... -} denote a documentation string?
23:00:37 <Cale> But I tend to leave my IRC client open.
23:01:29 <ivanm> ozy`: yes
23:01:43 <ivanm> the | in particular means that it's pulled in by haddock
23:02:19 <ozy`> the | was what raised my suspicious-looking eyebrow
23:02:57 <ivanm> {- ... -} is a multi-line comment
23:03:58 <ivanm> if you see {- $foo ... -}, then that's  non-attached documentation text that can be used by having in the import list -- $foo
23:04:09 <ivanm> s/import/export/
23:11:00 <roconnor> Is there some wiki guide on how to make a hackage package?
23:11:19 <dons> yeah
23:11:26 <dons> ?go how to make a haskell program
23:11:28 <lambdabot> http://www.haskell.org/hmake/
23:11:28 <lambdabot> Title: hmake - a make tool for Haskell programs
23:11:28 <ddarius> http://hackage.haskell.org/packages/upload.html
23:11:32 <dons> hmm .
23:11:43 <lambdabot> Title: HackageDB: checking and uploading packages
23:11:52 <dons> there's a howto
23:12:22 <dons> http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
23:12:23 <lambdabot> Title: How to write a Haskell program - HaskellWiki
23:12:46 <dons> start by copying a .cabal file from a reputable library or app
23:13:15 <ivanm> dons: your mkcabal app produces invalid cabal files
23:13:41 <ivanm> since it puts in GPL-{2,3}, and cabal only allows GPL
23:14:01 <ddarius> ivanm: Use BSD
23:14:04 <dons> it's well and truly out of date
23:14:10 <ivanm> ddarius: that's irrelevant
23:14:11 <dons> it was written for cabal 1.0 iirc
23:14:16 <ivanm> dons: oh?
23:14:25 <pstickne> GPL-- ^^
23:14:26 <ivanm> well, you obviously updated it to add GPL-3 support...
23:14:46 <dons> someone did
23:15:31 <ivanm> oh
23:15:40 <ivanm> any particular reason for not keeping it updated? time?
23:16:43 <dons> time
23:17:06 <dons> take it, bind to cabal and print out fresh .cabal files
23:17:17 <dons> use one of the command line interaction libs like shellac
23:17:21 <roconnor> this how-to guide is exactly what I was thinking of
23:17:33 <roconnor> How_to_write_a_Haskell_program++
23:19:13 * dons is glad roconnor is cabalising things
23:22:45 <roconnor> dons: I'm making a new hackage package!
23:22:56 <roconnor> my first one I think
23:24:12 <dons> yay!!
23:24:33 <roconnor> it needs to be cabalied first
23:24:41 <roconnor> then haddocked
23:25:03 <roconnor> ideally I should add some quickcheck properties, but maybe I'll make a 0.0.0 release first
23:30:51 <roconnor> I don't suppose people are willing to add MIT to Distribution.License.Licence?
23:31:14 <roconnor> or should I just put BSD3 into the License field?
23:35:33 <dons> oh weird. it's commented out
23:35:43 <dons> --TODO: * deprecate BSD4
23:35:43 <dons> --      * add optional gpl versions
23:35:43 <dons> --      * add MIT license
23:35:47 <dons> --    -- | The MIT license, similar to the BSD3. Very free license.
23:35:47 <dons> --  | MIT
23:35:57 <dons>   | UnknownLicense String
23:36:46 <roconnor> In that case I'll leave it as OtherLicense until MIT is added
23:37:33 <rwbarton> Is there a version of lift that lifts operations from the base monad through any number of layers?
23:37:37 <rwbarton> Or am I imagining things?
23:39:22 * exbio listens to JHWH - Wait For Tonight
23:39:33 <roconnor> rwbarton: I suspect you are imagining things
23:39:53 <roconnor> such a function would be somewhat difficult or impossible to write.
23:40:06 <ac> mlh: you said you've used GLFW, right? What's the equivalent to mainloop?
23:40:25 <ivanm> roconnor: I thought MIT was equivalent to BSD3?
23:40:30 <ac> mlh: er, mainGUI in the Haskell GLUT bindings
23:41:08 <ac> oh, I meant to ask hml, who's not here
23:42:06 <roconnor> ivanm: equivalent in spirit, but not equivalent in legal text
23:42:11 <roconnor> HNop doesn't have a README file
23:42:34 <ivanm> ahhh
23:42:44 <ivanm> roconnor: does it need one?
23:42:51 <ivanm> seeing as how it doesn't do anything... >_>
23:45:03 <roconnor> ivanm: the how-to guide suggested looking in HNop for an example of a README file
23:45:14 <ivanm> oh
23:45:17 <ivanm> *shrug*
23:45:19 <roconnor> I can't think of what to write for mine.
23:45:27 <ivanm> roconnor: what's this for?
23:45:35 <roconnor> Data.Colour
23:46:04 <ivanm> yay! correct spelling! :p
23:46:13 <ivanm> it's a list of colours and colourmaps I take it?
23:49:47 <roconnor> ivanm: I have a Data.Colour.Names module
23:49:54 <roconnor> I'm not sure what a colourmap is
23:50:09 <ivanm> a list of nice colours to use
23:50:29 <roconnor> discrete or continuous?
23:50:42 <ac> ah, it's "forever waitEvent". That's cool
23:51:13 <roconnor> what is the format for Tested-with:  ?
23:51:38 <ivanm> discrete
23:51:53 <roconnor> nope
23:52:06 <ivanm> e.g. matlab uses colourmaps for 3D plots
23:52:37 <ozy`> http://rubysnips.com/prime-mixin <== what the...
23:52:38 <lambdabot> Title: Ruby Snips Prime Numbers
23:53:43 <ivanm> wtf is that regex doing?
23:53:49 <ozy`> I have NO IDEA
23:53:56 <dons> what?
23:53:59 <dons> wtf.
23:54:09 <lament> wtf
23:54:23 <rwbarton> it makes a group of at least two 1's and then repeats it at least twice
23:54:26 <rwbarton> and negates the entire match
23:54:33 <rwbarton> and also handles the cases 0 and 1
23:54:45 <ivanm> rwbarton: yes, but doing what?
23:54:57 <lament> that's amazing
23:55:03 <rwbarton> using backreferences to make all the groups the same length
23:55:08 <rwbarton> it's not a real Regular Expression
23:55:25 <Adamant> ok. reddit has officially jumped the shark.
23:55:25 <ivanm> see, assuming it's valid, it _might_ be a valid one-line prime test... but I would define a clearer version just so people don't go wtf
23:55:34 <ivanm> Adamant: which shark?
23:55:43 <lament> Adamant: what happen
23:55:46 <Cale> Adamant: It's jumped dozens of sharks already.
23:55:54 <dons> yeah :/
23:55:55 <Adamant> ivanm: one with a hoop that's set on fire with napalm
23:55:57 <ozy`> Adamant: how is babby f--I mean, explain
23:56:06 <ozy`> at least give us a link or something
23:56:14 <dons> its interesting how they talk about the open classes, (the OO side of the expression problem)
23:56:31 <lament> open classes ruse
23:56:38 <lament> it's the only sane way
23:57:15 <dons> prime :: Integral a => a -> Bool :-)
23:57:20 <dons> open classes! hehe
23:57:42 <roconnor> How do I figureout the tested-with format for cabal?
23:57:45 <slava> the CLOS way is the best
23:57:49 <rwbarton> of course they're "open classes" in exactly the opposite sense of haskell's "open classes"
23:58:15 <Adamant> ozy`:  entire thread talking crap about Paul Graham, but doesn't rebut any of his actual points, which you can clearly do
23:58:32 <lament> dons: yeah... that does solve the same issue
23:58:42 <ozy`> Adamant: ah... well.
23:58:45 <Adamant> ozy`: also, wtf were you trying to say?
23:59:07 <ivanm> dons: I'm more interested in what that pseudo-regex is doing, and how it determines if it is indeed a prime :s
23:59:11 <ozy`> has Paul Graham even come back out of hibernation yet? I thought he wasn't due for another month
23:59:28 <ozy`> Adamant: http://www.somethingawful.com/flash/shmorky/babby.swf
23:59:34 <Adamant> ozy`: ah, got it
23:59:39 <dons> well, there's some famous primality testing (extended)-regexes
23:59:58 <dons> or at least one famous one, which this looks likely to be, actually
